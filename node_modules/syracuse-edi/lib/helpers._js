"use strict";
var helpers = require('syracuse-core/lib/helpers');
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var trace = config.edi && config.edi.cache && config.edi.cache.trace;
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var EdiTypeToClass = require("syracuse-edi/lib/enumType").EdiTypeToClass;
var serializer = require("syracuse-orm/lib/serializer");
var EdiEntity = require("./EdiEntity");
var logConfig = config && config.edi && config.edi.log;

exports.getEntity = _getEntity;

function _getEntity(_, ep, entityName, id, etag) { // get data of an entity
	try {

		var model = ep.getModel(_);
		var db = ep.getOrm(_);

		var entity = model.getEntity(_, entityName);
		var inst = db.fetchInstanceEtag(_, entity, id, etag);
		return inst && inst.serializeInstance(_, false);
	} catch (e) { // not found
		//console.log("not found instance of entity "+EdiTypeToClass[type]+" for id "+id);
		return null;
	}
};

exports.getPrototype = function(_, opt) {
	/* change by getting data from the cache. we can't recall in the same socket the prototype from X3
	var entity = endpoint.getModel(_).getEntity(_, repName, facet);
	return entity && entity.getPrototype(_, entity.name, facet); // change by*/

	var cached = EdiEntity.getEdiCacheEntity(_, {
		filter: {
			jsonWhere: {
				id: opt.repName,
				type: opt.endpoint.dataset(_)
			}
		},
		db: opt.db
	});

	return cached && cached.json(_);
};



exports.log = function(level, message) {
	/*if (logConfig && logConfig.active && logConfig.level === level)
		console.log((new Date().toString()) + " : " + level + ", " + message);*/
};



exports.EDIClass = helpers.defineClass(function(_, db, entityName) {
	trace && trace("create Class EDI " + entityName);

	// getting the administration ORM

	this.db = db || adminHelper.getCollaborationOrm(_);
	// the metamodel is associated to the orm
	this.model = this.db.model;
	this.entityName = entityName || "ediCache";
	this.entity = this.model.getEntity(_, this.entityName);
	this.factory = this.entity.factory;
}, null, {
	getInstance: function(_, filter) {
		trace && trace("get instance filter=[" + filter && JSON.stringify(filter) + "]");

		var ent;
		if (filter != null && filter.length !== 0) {
			// fetchInstance(callback, entity, filter)
			ent = this.db.fetchInstance(_, this.entity, filter);
		} else {
			// create a new object, createInstance params are : (callback, initialDataJson, ormInstance)
			ent = this.factory.createInstance(_, null, this.db);
		}
		return ent;
	},
	getInstances: function(_, filter) {
		trace && trace("get instances filter=[" + filter && JSON.stringify(filter) + "]");

		var ent;
		if (filter != null && filter.length !== 0) {
			// fetchInstance(callback, entity, filter)
			ent = this.db.fetchInstances(_, this.entity, filter);
		} else {
			ent = this.db.fetchInstances(_, this.entity, {});
		}
		return ent;
	},
	createInstance: function(_) {
		trace && trace("create instance ");

		// create a new object, createInstance params are : (callback, initialDataJson, ormInstance)
		return this.factory.createInstance(_, null, this.db);
	},
	deleteInstance: function(_, filter) {
		trace && trace("delete instances filter=[" + filter && JSON.stringify(filter) + "]");

		var inst = this.getInstance(_, filter);
		inst && inst.deleteSelf();
	},
	dropAllInstance: function(_) {
		trace && trace("drop all instances ");
		var inst = this.getInstances(_);
		inst && inst.forEach_(_, function(_, item) {
			item && item.deleteSelf();
		});
	}
});
/**
 * Created by apisu on 08/07/2014.
 */