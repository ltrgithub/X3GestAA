"use strict";
var helpers = require('syracuse-core').helpers;
var config = require('config'); // must be first syracuse require
var trace = config.edi && config.edi.cache && config.edi.cache.trace;
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var EdiTypeToClass = require("syracuse-edi/lib/enumType").EdiTypeToClass;
var serializer = require("syracuse-orm/lib/serializer");
var logConfig = config && config.edi && config.edi.log;

// define trace/log in helper in have availabity to activate them from the gui
require('syracuse-core').getTracer("edi.entity");
require('syracuse-core').getTracer("edi.process");
require('syracuse-core').getTracer("edi.parser");
require('syracuse-core').getTracer("edi.serializer");


exports.getEntity = _getEntity;

function _getEntity(_, ep, entityName, id, etag) { // get data of an entity
	try {

		var model = ep.getModel(_);
		var db = ep.getOrm(_);

		var entity = model.getEntity(_, entityName);
		var inst = db.fetchInstanceEtag(_, entity, id, etag);
		return inst && inst.serializeInstance(_, false);
	} catch (e) { // not found
		//console.log("not found instance of entity "+EdiTypeToClass[type]+" for id "+id);
		return null;
	}
};



exports.log = function(level, message) {
	/*if (logConfig && logConfig.active && logConfig.level === level)
		console.log((new Date().toString()) + " : " + level + ", " + message);*/
};


exports.protocolPropertyMap = {

	listDirectory: "EPTEPTD",
	listDirectories: {
		typeDirectory: "EPT_EPTD_PTCLINCOD",
		path: "EPT_EPTD_PTCLINVAL",
	}
};

exports.encodingMenuLocalMap = {
	1: "ascii",
	2: "utf-8",
	3: "ucs2"
};

exports.messageMappingPropertyMap = {
	fileType: "TYPFIL",
	elems: {
		flag: "EMS_EMSD_FLGREC",
		expression: 'EMS_EMSD_PROTOPATH',
		fileId: "EMS_EMSD_FILNAM",
		length: "EMS_EMSD_LNG",
		level: "EMS_EMSD_FLGREC",
		offset: "EMS_EMSD_LOC",
		isMandatory: "EMS_EMSD_MANDATORY"
	},
	classInstance: "EMS_ABRCLA",
	encoding: "CODDBA",
	elem: "EMSEMSD",
	decimalSep: "SEPDEC",
	fieldSep: "SEPFLD",
	fieldDelimiter: "FLDLIM",
	recordSep: 'SEPREC',
	dateFormat: "OPTDAT"
};
exports.xmlFilePropertyMap = {
	filesDescription: "EXFEXFF",
	filesDescriptions: {
		fileId: "EXF_EXFF_DESCRIPTION",
		fileName: "EXF_EXFF_FILNAM",
		mandatory: "EXF_EXFF_MANDATORY"
	},
	elems: {
		xmlPath: "EXF_EXFD_PATHSTR",
		expression: 'EXF_EXFD_PROTOPATH',
		type: "EXF_EXFD_PATHTYPE",
		restriction: "EXF_EXFD_PATHREST",
		fileId: "EXF_EXFD_MSGCOD"
	},
	classInstance: "ABRCLA",
	elem: "EXFEXFD"
}
exports.seqentialFilePropertyMap = {
	fileType: "TYPFIL",
	filesDescription: "ESFESFF",
	filesDescriptions: {
		fileId: "ESFF_FILCOD",
		fileName: "ESFF_FILNAM",
		primarykey: "PROTOMAIN",
		foreignkey: "PROTOLINK",
		fatherFileId: "PARFILE",
		mandatory: "MANDATORY"
	},
	elems: {
		flag: "ESFD_FLGREC",
		expression: 'ESFD_PROTOPATH',
		fileId: "ESFD_FILCOD",
		length: "ESFD_LNG",
		level: "ESFD_LEVEL",
		offset: "ESFD_LOC",
		isEnd: "ESFD_ENDREG",
		isMandatory: "ESFD_MANDATORY",
		idLine: "ESFD_FLGREC"
	},
	extId: "KEYPROTOPATH",
	classInstance: "ABRCLA",
	encoding: "CODDBA",
	elem: "ESFESFD",
	decimalSep: "SEPDEC",
	fieldSep: "SEPFLD",
	fieldDelimiter: "FLDLIM",
	recordSep: 'SEPREC',
	dateFormat: "OPTDAT"
};



exports.EdiClass = helpers.defineClass(function(_, db, entityName) {
	trace && trace("create Class EDI " + entityName);
	// getting the administration ORM

	this.db = db || adminHelper.getCollaborationOrm(_);
	// the metamodel is associated to the orm
	this.model = this.db.model;
	this.entityName = entityName || "ediCache";
	this.entity = this.model.getEntity(_, this.entityName);
	this.factory = this.entity.factory;

}, null, {
	getInstance: function(_, filter) {
		trace && trace("get instance filter=[" + filter && JSON.stringify(filter) + "]");

		var ent;
		if (filter != null && filter.length !== 0) {
			// fetchInstance(callback, entity, filter)
			ent = this.db.fetchInstance(_, this.entity, filter);
		} else {
			// create a new object, createInstance params are : (callback, initialDataJson, ormInstance)
			ent = this.factory.createInstance(_, null, this.db);
		}
		return ent;
	},
	getInstances: function(_, filter) {
		trace && trace("get instances filter=[" + filter && JSON.stringify(filter) + "]");

		var ent;
		if (filter != null && filter.length !== 0) {
			// fetchInstance(callback, entity, filter)
			ent = this.db.fetchInstances(_, this.entity, filter);
		} else {
			ent = this.db.fetchInstances(_, this.entity, {});
		}
		return ent;
	},
	createInstance: function(_) {
		trace && trace("create instance ");

		// create a new object, createInstance params are : (callback, initialDataJson, ormInstance)
		return this.factory.createInstance(_, null, this.db);
	},
	deleteInstance: function(_, filter) {
		trace && trace("delete instances filter=[" + filter && JSON.stringify(filter) + "]");

		var inst = this.getInstance(_, filter);
		inst && inst.deleteSelf(_);
	},
	dropAllInstance: function(_) {
		trace && trace("drop all instances ");
		var inst = this.getInstances(_);
		inst && inst.forEach_(_, function(_, item) {
			item && item.deleteSelf(_);
		});
	}
});
/**
 * Created by apisu on 08/07/2014.
 */