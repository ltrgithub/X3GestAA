"use strict";
var helpers = require('syracuse-core/lib/helpers');
var config = require('config'); // must be first syracuse require
var trace = config.edi && config.edi.cache && config.edi.cache.trace;
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var EdiTypeToClass = require("syracuse-edi/lib/enumType").EdiTypeToClass;
var serializer = require("syracuse-orm/lib/serializer");
var EdiEntity = require("./ediEntity");
var logConfig = config && config.edi && config.edi.log;

// define trace/log in helper in have availabity to activate them from the gui
require("syracuse-trace/lib/helper").getTracer("edi.entity");
require("syracuse-trace/lib/helper").getTracer("edi.process");
require("syracuse-trace/lib/helper").getTracer("edi.parser");
require("syracuse-trace/lib/helper").getTracer("edi.serializer");


exports.getEntity = _getEntity;

function _getEntity(_, ep, entityName, id, etag) { // get data of an entity
	try {

		var model = ep.getModel(_);
		var db = ep.getOrm(_);

		var entity = model.getEntity(_, entityName);
		var inst = db.fetchInstanceEtag(_, entity, id, etag);
		return inst && inst.serializeInstance(_, false);
	} catch (e) { // not found
		//console.log("not found instance of entity "+EdiTypeToClass[type]+" for id "+id);
		return null;
	}
};

exports.getPrototype = function(_, opt) {
	/* change by getting data from the cache. we can't recall in the same socket the prototype from X3
	var entity = endpoint.getModel(_).getEntity(_, repName, facet);
	return entity && entity.getPrototype(_, entity.name, facet); // change by*/

	var cached = EdiEntity.getEdiCacheEntity(_, {
		filter: {
			jsonWhere: {
				id: opt.repName,
				type: opt.endpoint.dataset(_)
			}
		},
		db: opt.db
	});

	return cached && cached.json(_);
};



exports.log = function(level, message) {
	/*if (logConfig && logConfig.active && logConfig.level === level)
		console.log((new Date().toString()) + " : " + level + ", " + message);*/
};


exports.protocolPropertyMap = {

	listDirectory: "EPTEPTD",
	listDirectories: {
		typeDirectory: "EPT_EPTD_PTCLINCOD",
		path: "EPT_EPTD_PTCLINVAL",
	}
};

exports.encodingMenuLocalMap = {
	1: "ascii",
	2: "utf-8",
	3: "ucs2"
};

exports.messageMappingPropertyMap = {
	fileType: "TYPFIL",
	elems: {
		flag: "EMS_EMSD_FLGREC",
		expression: 'EMS_EMSD_CODPRO',
		fileId: "EMS_EMSD_FILNAM",
		length: "EMS_EMSD_LNG",
		level: "EMS_EMSD_LEVEL",
		offset: "EMS_EMSD_LOC",
		isMandatory: "EMS_EMSD_MANDATORY"
	},
	classInstance: "EMS_ABRCLA",
	encoding: "CODDBA",
	elem: "EMSEMSD",
	decimalSep: "SEPDEC",
	fieldSep: "SEPFLD",
	fieldDelimiter: "FLDLIM",
	recordSep: 'SEPREC'
};

exports.seqentialFilePropertyMap = {
	fileType: "TYPFIL",
	filesDescription: "ESFESFF",
	filesDescriptions: {
		fileId: "ESFF_FILCOD",
		fileName: "ESFF_FILNAM",
		primarykey: "PROTOMAIN",
		foreignkey: "PROTOLINK",
		fatherFileId: "PARFILE",
		mandatory: "MANDATORY"
	},
	elems: {
		flag: "ESFD_FLGREC",
		expression: 'ESFD_PROTOPATH',
		fileId: "ESFD_FILCOD",
		length: "ESFD_LNG",
		level: "ESFD_LEVEL",
		offset: "ESFD_LOC",
		isEnd: "ESFD_ENDREG",
		isMandatory: "ESFD_MANDATORY"
	},
	classInstance: "ABRCLA",
	encoding: "CODDBA",
	elem: "ESFESFD",
	decimalSep: "SEPDEC",
	fieldSep: "SEPFLD",
	fieldDelimiter: "FLDLIM",
	recordSep: 'SEPREC'
};


exports.EDIClass = helpers.defineClass(function(_, db, entityName) {
	trace && trace("create Class EDI " + entityName);

	// getting the administration ORM

	this.db = db || adminHelper.getCollaborationOrm(_);
	// the metamodel is associated to the orm
	this.model = this.db.model;
	this.entityName = entityName || "ediCache";
	this.entity = this.model.getEntity(_, this.entityName);
	this.factory = this.entity.factory;
}, null, {
	getInstance: function(_, filter) {
		trace && trace("get instance filter=[" + filter && JSON.stringify(filter) + "]");

		var ent;
		if (filter != null && filter.length !== 0) {
			// fetchInstance(callback, entity, filter)
			ent = this.db.fetchInstance(_, this.entity, filter);
		} else {
			// create a new object, createInstance params are : (callback, initialDataJson, ormInstance)
			ent = this.factory.createInstance(_, null, this.db);
		}
		return ent;
	},
	getInstances: function(_, filter) {
		trace && trace("get instances filter=[" + filter && JSON.stringify(filter) + "]");

		var ent;
		if (filter != null && filter.length !== 0) {
			// fetchInstance(callback, entity, filter)
			ent = this.db.fetchInstances(_, this.entity, filter);
		} else {
			ent = this.db.fetchInstances(_, this.entity, {});
		}
		return ent;
	},
	createInstance: function(_) {
		trace && trace("create instance ");

		// create a new object, createInstance params are : (callback, initialDataJson, ormInstance)
		return this.factory.createInstance(_, null, this.db);
	},
	deleteInstance: function(_, filter) {
		trace && trace("delete instances filter=[" + filter && JSON.stringify(filter) + "]");

		var inst = this.getInstance(_, filter);
		inst && inst.deleteSelf();
	},
	dropAllInstance: function(_) {
		trace && trace("drop all instances ");
		var inst = this.getInstances(_);
		inst && inst.forEach_(_, function(_, item) {
			item && item.deleteSelf();
		});
	}
});
/**
 * Created by apisu on 08/07/2014.
 */