"use strict";
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var trace = config.edi && config.edi.parser && config.edi.parser.trace;
var SEQFIL_LIB = require('syracuse-edi/lib/enumType').SEQFILE_LIB;
var IMPORTFILE_LIB = require('syracuse-edi/lib/enumType').IMPORTFILE_LIB;
var ImportFileType = require('syracuse-edi/lib/enumType').ImportFileType;

var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var helpersEdi = require('syracuse-edi/lib/helpers');
var serializeHelp = require('syracuse-edi/lib/parse/helpers');
var decimal = require("syracuse-core/lib/types/decimal");
var datetime = require("syracuse-core/lib/types/datetime");
/**
 * Created by apisu on 01/07/2014.
 * parse of the edi file to a json structure regarding a specific context
 */


///
/// ### function parse that create a json file from Edi sequential file(s)
///  parse(_,buff,ediCached[,json])
///     filesBuff : buffer of the files read in string or binary
///     ediCached : contains all element for generation
exports.serialize = function(_, opt) {
	helpersEdi.log("INFO", "serialize action " + opt.action);

	// retrieve prototype
	var elems;
	var serializer;
	var sContext;
	var encoding = "utf8";
	var prototype = opt.prototype || helpersEdi.getPrototype(_, {
		endpoint: opt.process.endPoint(_),
		repName: opt.process.x3RepName(_),
		facet: "$details",
		db: opt.db
	});

	if (opt.action === "edi") {
		var seqFile = opt.process && opt.process.sequentialFile(_);

		if (seqFile) {
			trace && trace("seqFile type  " + SEQFILE_LIB[seqFile.TYPFIL]);

			serializer = SEQFIL_LIB[seqFile.TYPFIL];
			elems = seqFile.ESFESFD;
			sContext = {
				sepDecimal: seqFile.SEPDEC,
				sepField: seqFile.SEPFLD,
				sepRecord: "\n",
				delimField: seqFile.FLDLIM,
				getPropertyName: function(item) {
					return item.EXPRESSION;
				}

			};
		} else {
			throw new Error("can't find sequential File '" + opt.process.idSequentialFile(_) + "'");
		}
	} else if (opt.action === "import") {
		var messageMapping = opt.process && opt.process.messageMapping(_);

		// get instance of template model
		elems = messageMapping.EMSEMSD;

		serializer = IMPORTFILE_LIB[messageMapping.TYPFIL];
		sContext = {
			sepDecimal: messageMapping.SEPDEC,
			sepField: messageMapping.SEPFLD,
			sepRecord: "\n",
			delimField: messageMapping.FLDLIM,
			getPropertyName: function(item) {
				return item.SASVAR;
			},
			fileName: "import" + opt.process.x3RepName(_)
		};
	}

	if (serializer) {
		helpersEdi.log("FINE", "serializer used " + serializer);

		return _mapSerialize[serializer](opt.json, elems, prototype, sContext);
	} else {
		throw new Error("can't find serialize to execute :'" + serializer + "' , please check the messageMapping identified by '" + opt.process.idMessageMapping(_) + "' used");
	}

};



/*
 * return an array of all element that correspond to the key. If the property exists once, we return an array of 1 element
 * if the property is in an array we return a array of element in the same order of the array
 */
function _getJsonElem(json, key, sContext, prototype, prop) {
	function _unformatType(propItem, val) {

		switch (propItem.$type) {
			case "application/x-decimal":
				// create format
				return parseFloat((val + "").replace(".", sContext.sepDecimal), 10);

			case "application/x-boolean":
				return val;
			case "application/x-date":
				var date = datetime.parse(val, "yyyy-MM-dd");
				return date.toString("dd/MM/yyyy");
			default:
				return val;
		}
	}
	var properties = prop || prototype && prototype.$properties;
	if (key.indexOf(".") === -1) {
		var prop = serializeHelp.getProperty(properties, key);
		if (prop) {
			return _unformatType(prop, json[key]);
		} else {
			throw new Error("property " + key + " doesn't exists for the entity " + (prototype && prototype.$representation));
		}
	} else {
		var stop = false;
		var js = json;
		var result = [];
		var keys = key.split(".");
		for (var i = 0; i < keys.length && !stop; i++) {
			var item = keys[i];

			var jsTemp = js[item];
			if (!jsTemp) {
				item = prototype.$instanceUrl.substring(prototype.$instanceUrl.indexOf("/") + 1) + keys.slice(0, i + 1).join(""); // hack item is identify by concat of all parent node
				jsTemp = js[item];
			}
			js = jsTemp;

			stop = !js || Array.isArray(js) || properties[item];
			properties = serializeHelp.getProperty(properties, item);
		}
		if (Array.isArray(js)) { // add all element of each line
			var keyInArray = keys.slice(i).join(".");
			for (var k = 0; k < js.length; k++) {
				if (properties) {
					var l = _getJsonElem(js[k], keyInArray, sContext, prototype, properties);
					l && result.push(l);
				}
			}
		} else if (stop) {
			throw new Error("property " + key + " doesn't exists for the entity " + prototype.$representation + " or in not present in the json");
		} else {
			// normally we have found it
			if (js) {
				// convert value to the rigth format
				result.push(_unFormatType(properties, js));

			}
		}
		return result;
	}
};





var _mapSerialize = {
	delimited: function(json, elems, prototype, sContext) {
		var fileBuf = {};
		elems.forEach(function(elem) {

			var propertyName = sContext.getPropertyName(elem);
			propertyName = propertyName.substring(propertyName.indexOf(".") + 1);

			function _serialize(items, index) {
				items && items.forEach(function(val, idx, array) {
					if (Array.isArray(val)) {
						_serialize(val, idx);
					}
					var filename = sContext.fileName || elem.FILNAM;
					var idLine = elem.FLGREC + (index || idx); // serialize
					fileBuf[filename] = fileBuf[filename] || {};
					fileBuf[filename][idLine] = fileBuf[filename][idLine] || "";
					// add indicator when it's necessary
					if (!fileBuf[filename][idLine]) { // if empty string so start of the line
						fileBuf[filename][idLine] += sContext.delimField + elem.FLGREC + sContext.delimField;
					}

					fileBuf[filename][idLine] += (fileBuf[filename][idLine] ? sContext.sepField : "") + sContext.delimField + val + sContext.delimField;
					if (elem.ENDREG) {
						// add record separator
						fileBuff[filename][idLine] += sContext.sepRecord;
					}
				});
			}

			if (propertyName) {
				// get json element(s) identify by the propertyName
				var items = _getJsonElem(json, propertyName, sContext, prototype);
				if (items && !Array.isArray(items)) {
					items = [items];
				}
				_serialize(items);

			}
		});
		Object.keys(fileBuf).forEach(function(filename) {
			var listLine = fileBuf[filename];
			fileBuf[filename] = "";

			Object.keys(listLine).forEach(function(lineKey, idx, array) {
				fileBuf[filename] += listLine[lineKey];
				if (idx < array.length - 1) {
					fileBuf[filename] += sContext.sepRecord;
				}
			});
		});
		return fileBuf;
	},
	fixedLength: function(json, elems, prototype, sContext) {
		//the value dump that match the size describe in seqFile, we add space after value
		function _getFixedLengthValue(value, size) {
			//console.log("type="+typeof value+", value="+JSON.stringify(value)+", len="+value.length+", size="+size);
			var val = "" + value;
			var res = val;
			if (typeof value === "number") {
				// right text align
				for (var i = val.length; i < size; i++) {
					res = " " + res;
				}
			} else {
				// left text align
				for (var i = val.length; i < size; i++) {
					res += " ";
				}
			}
			return res;
		};
		var fileBuf = {};
		var missingProperty = false;
		// TODO manage array of array that can be return by getJsonElem depending of the structure
		elems.forEach(function(elem) {
			var realLoc = elem.LOC - 1;
			var propertyName = sContext.getPropertyName(elem);
			propertyName = propertyName.substring(propertyName.indexOf(".") + 1);
			if (propertyName) {

				// get json element(s) identify by the propertyName
				var items = _getJsonElem(json, propertyName, sContext, prototype);
				if (items && !Array.isArray(items)) {
					items = [items];
				}
				// TODO manage array of array that can be return by getJsonElem depending of the structure
				items && items.forEach(function(val, idx) {
					var filename = sContext.fileName || elem.FILNAM;
					fileBuf[filename] = fileBuf[filename] || {};
					fileBuf[filename][idx] = fileBuf[filename][idx] || "";
					fileBuf[filename][idx] += _getFixedLengthValue(val, elem.LNG);
				});
			}
		});
		Object.keys(fileBuf).forEach(function(filename) {
			var listLine = fileBuf[filename];
			fileBuf[filename] = "";
			Object.keys(listLine).forEach(function(lineKey, idx, array) {
				fileBuf[filename] += serializeHelp.removeSpace(listLine[lineKey]);
				if (idx < array.length - 1) {
					fileBuf[filename] += "\n";
				}

			});
		});

		return fileBuf;
	}
};

// for unit test
exports.mapSerialize = _mapSerialize;