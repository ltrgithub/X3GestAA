"use strict";
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var trace = config.edi && config.edi.parser && config.edi.parser.trace;
var seqFileType = require('syracuse-edi/lib/enumType').SEQFILE;
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var protoHelp = require('syracuse-edi/lib/parse/helpers');

/**
 * Created by apisu on 01/07/2014.
 * parse of the edi file to a json structure regarding a specific context
 */


///
/// ### function parse that create a json file from Edi sequential file(s)
///  parse(_,buff,ediCached[,json])
///     filesBuff : buffer of the files read in string or binary
///     ediCached : contains all element for generation
exports.serialize = function(_, opt) {
	var process = opt.process;
	var input = opt.input;
	var json = opt.json;
	var seqFile = process.sequentialFile(_);
	// retrieve prototype
	var facet = "$details";
	var endpointX3 = opt.endpoint;
	var entity = endpointX3.getModel(_).getEntity(_, process.x3ClassName(_), facet);
	var prototype = entity && entity.getPrototype(_, entity.name, facet);

	if (seqFile && seqFile.TYPFIL === seqFileType.FIXEDFILE) {
		trace && trace("number of files to parse " + input.length);
		trace && trace("sizeFixed " + (seqFile.TYPFIL === seqFileType.FIXEDFILE));

		return _serializeFixedSize(json, seqFile, prototype);
	} else {

	}
};



function _serializeFixedSize(json, seqFile, prototype) {

	/*
	 * return an array of all element that correspond to the key. If the property exists once, we return an array of 1 element
	 * if the property is in an array we return a array of element in the same order of the array
	 */
	function _getJsonElem(json, key, properties) {

		if (key.indexOf(".") === -1) {
			if (properties[key] || protoHelp.getSubProperties(properties) && protoHelp.getSubProperties(properties)[key]) {
				return json[key];
			} else {
				throw new Error("property " + key + " doesn't exists for the entity " + prototype.$representation);
			}
		} else {
			var stop = false;
			var js = json;
			var result = [];
			var keys = key.split(".");
			for (var i = 0; i < keys.length && !stop; i++) {
				var item = keys[i];
				js = json[item];
				stop = !js || Array.isArray(js) || properties[item];
				properties = properties[item] || protoHelp.getSubProperties(properties) && protoHelp.getSubProperties(properties)[item] || null;
			}
			if (Array.isArray(js)) { // add all element of each line
				var keyInArray = keys.slice(i).join(".");
				for (var k = 0; k < js.length; k++) {
					if (properties) {
						var l = _getJsonElem(js[k], keyInArray, properties);
						l && result.push(l);
					}
				}
			} else if (stop) {
				throw new Error("property " + key + " doesn't exists for the entity " + prototype.$representation);
			} else {
				// normally we have found it
				js && result.push(js);
			}
			return result;
		}
	}

	//the value dump that match the size describe in seqFile, we add space after value
	function _getFinalValue(value, size) {
		//console.log("type="+typeof value+", value="+JSON.stringify(value)+", len="+value.length+", size="+size);
		var val = "" + value;
		var res = val;
		if (typeof value === "number") {
			// right text align
			for (var i = val.length; i < size; i++) {
				res = " " + res;
			}
		} else {
			// left text align
			for (var i = val.length; i < size; i++) {
				res += " ";
			}
		}

		return res;
	}
	var fileBuf = {};
	var properties = prototype.$properties;
	seqFile.ESFESFD.forEach(function(item) {
		var realLoc = item.LOC - 1;
		var propertyName = item.EXPRESSION.substring(item.EXPRESSION.indexOf(".") + 1);
		// get json element(s) identify by the propertyName
		var elems = _getJsonElem(json, propertyName, properties);
		if (!Array.isArray(elems)) {
			elems = [elems];
		}
		elems && elems.forEach(function(val, idx) {
			fileBuf[item.FILNAM] = fileBuf[item.FILNAM] || {};
			fileBuf[item.FILNAM][idx] = fileBuf[item.FILNAM][idx] || "";
			fileBuf[item.FILNAM][idx] += _getFinalValue(val, item.LNG);
		});
	});
	Object.keys(fileBuf).forEach(function(filename) {
		var listLine = fileBuf[filename];
		fileBuf[filename] = "";
		Object.keys(listLine).forEach(function(lineKey, idx, array) {
			fileBuf[filename] += listLine[lineKey];
			if (idx < array.length - 1) {
				fileBuf[filename] += "\n";
			}

		});
	});

	return fileBuf;
}

exports.serializeFixedSize = _serializeFixedSize;