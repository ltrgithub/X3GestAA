"use strict";
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var trace = config.edi && config.edi.parser && config.edi.parser.trace;
var seqFileType = require('syracuse-edi/lib/enumType').SEQFILE;
/**
 * Created by apisu on 01/07/2014.
 * parse of the edi file to a json structure regarding a specific context
 */


///
/// ### function parse that create a json file from Edi sequential file(s)
///  parse(_,buff,opt)
///     buff : buffer of the file read in string or binary
///     opt : contains all element for generation
exports.parse = function(_, filesBuff, ediCached, res) {


	res = res || {};
	var seqFile = ediCached.sequentialFile(_);

	if (seqFile && seqFile.TYPFIL === seqFileType.FIXEDFILE) {

		trace && trace("number of files to parse " + filesBuff.length);
		trace && trace("sizeFixed " + (seqFile.TYPFIL === seqFileType.FIXEDFILE));

		// size if fix and we have to follow the sequential file to parse each expression
		var i = 0;
		seqFile.ESFESFD && seqFile.ESFESFD.forEach(function(item) {
			// create the json property if it doesn't exists
			if (item.EXPRESSION && item.LOC && item.LNG) {
				trace && trace("item " + JSON.stringify(item, null, 2));

				var json = res;
				var key = item.EXPRESSION;
				var jsonKey = item.EXPRESSION.split('.');
				if (jsonKey && jsonKey.length > 1) {
					json[jsonKey[0]] = json[jsonKey[0]] || {};
					for (var i = 1; i < jsonKey.length; i++) {
						json = json[jsonKey[i - 1]];
						json[keyItem] = json[keyItem] || {};
					};
				} else {
					json[key] = json[key] || {};
				}
				var val = filesBuff[item.FILNAM].substring(item.LOC, item.LNG + item.LOC).replace(/\r|\n/g, "");
				trace && trace("item value (startOffset : " + item.LOC + ", lengthToRead : " + item.LNG + ", EndOffset: " + item.LNG + item.LOC + ", val length readed : " + val.length);
				trace && trace("item value : " + val);
				trace && trace("-------------------------");

				json[key] = val;
			}
			i++;
		});
	} else {
		// case with a token (field delimiter)
	}
};

/*
 * buff
 * seqFile correspond to the sequential File
 */
function _parseFixedSize(_, buff, seqFile) {

}