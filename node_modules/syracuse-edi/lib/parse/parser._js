"use strict";
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var trace = config.edi && config.edi.parser && config.edi.parser.trace;
/**
 * Created by apisu on 01/07/2014.
 * parse of the edi file to a json structure regarding a specific context
 */


///
/// ### function parse that create a json file from Edi sequential file(s)
///  parse(_,buff,opt)
///     buff : buffer of the file read in string or binary
///     opt : contains all element for generation
exports.parse = function(_, filesBuff, opt) {

	trace && trace("number of files to parse " + filesBuff.length);
	trace && trace("sizeFixed " + opt.isSizeFixed);

	opt.json = opt.json || {};
	if (opt.isSizeFixed) {

		// size if fix and we have to follow the sequential file to parse each expression
		var i = 0;
		opt.seqFile && opt.seqFile.ESFESFD && opt.seqFile.ESFESFD.forEach(function(item) {
			// create the json property if it doesn't exists
			trace && trace("item " + JSON.stringify(item, null, 2));

			var json = opt.json;
			var key = item.EXPRESSION;
			var jsonKey = item.EXPRESSION.split('.');
			if (jsonKey && jsonKey.length > 1) {
				json[jsonKey[0]] = json[jsonKey[0]] || {};
				for (var i = 1; i < jsonKey.length; i++) {
					json = json[jsonKey[i - 1]];
					json[keyItem] = json[keyItem] || {};
				};
			} else {
				json[key] = json[key] || {};
			}
			var val = filesBuff[item.FILNAM].substring(item.LOC, item.LNG + item.LOC).replace(/\r|\n/g, "");
			trace && trace("item value (startOffset : " + item.LOC + ", lengthToRead : " + item.LNG + ", EndOffset: " + item.LNG + item.LOC + ", val length readed : " + val.length);
			trace && trace("item value : " + val);
			trace && trace("-------------------------");

			json[key] = val;

			i++;
		});
	} else {
		// case with a token (field delimiter)
	}
};

/*
 * buff
 * seqFile correspond to the sequential File
 */
function _parseFixedSize(_, buff, seqFile) {

}