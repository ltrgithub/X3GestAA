"use strict";
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var trace = config.edi && config.edi.parser && config.edi.parser.trace;
var SEQFILE_LIB = require('syracuse-edi/lib/enumType').SEQFILE_LIB;

var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var parseHelp = require('syracuse-edi/lib/parse/helpers');
var helpersEdi = require("syracuse-edi/lib/helpers");
var decimal = require("syracuse-core/lib/types/decimal");
var datetime = require("syracuse-core/lib/types/datetime");

/**
 * Created by apisu on 01/07/2014.
 * parse of the edi file to a json structure regarding a specific context
 */


///
/// ### function parse that create a json file from Edi sequential file(s)
///  parse(_,buff,ediCached[,json])
///     filesBuff : buffer of the files read in string or binary
///     ediCached : contains all element for generation
exports.parse = function(_, opt) {

	var process = opt.process;
	var input = opt.input;
	var json = opt.json;
	var seqFile = opt.process.sequentialFile(_);
	if (!seqFile || Object.keys(seqFile).length === 0) {
		throw new Error("sequential File identified by '" + opt.process.idSequentialFile(_) + "' not found in syracuse");
	}
	// retrieve prototype
	var prototype = helpersEdi.getPrototype(_, opt.process.endPoint(_), opt.process.x3RepName(_), "$details");

	trace && trace("serializer " + SEQFILE_LIB[seqFile.TYPFIL]);
	var sContext = {
		sepDecimal: seqFile.SEPDEC,
		sepField: seqFile.SEPFLD,
		sepRecord: "\n",
		delimField: seqFile.FLDLIM,
		getPropertyName: function(item) {
			return item.EXPRESSION;
		}
	};
	return _mapParse[SEQFILE_LIB[seqFile.TYPFIL]](input, seqFile.ESFESFD, prototype, json, sContext);

};

var _mapParse = {
	delimited: function(input, elems, prototype, json, sContext) {


		var jsonToGen = json || {};

		Object.keys(input).forEach(function(filename) {
			//nb of readed character
			var records = input[filename];
			if (records.indexOf(sContext.sepRecord)) {
				records = records.split(sContext.sepRecord);
			} else {
				records = [records];
			}
			if (records) {

				records.forEach(function(record) {
					var recFlag = record.split(sContext.sepField).slice(0, 1)[0];
					if (recFlag.charAt(0) === sContext.delimField && recFlag.charAt(recFlag.length - 1) === sContext.delimField) {
						recFlag = recFlag.slice(1, recFlag.length - 1);

					} else {
						throw new Error("file format doesn't correspond. field delimiter is not present for record flag " + recFlag);
					}
					var recValues = record.split(sContext.sepField).slice(1);
					elems.filter(function(prev, cur) {
						return elems[cur] && elems[cur].FILNAM === filename && elems[cur].FLGREC === recFlag;
					}).forEach(function(item, idx, arr) {
						if (idx < recValues.length) {
							var propertyName = item.EXPRESSION.substring(item.EXPRESSION.indexOf(".") + 1);

							// extract the value
							var val = recValues[idx];

							if (val && val.charAt(0) === sContext.delimField && val.charAt(val.length - 1) === sContext.delimField) {
								val = val.slice(1, val.length - 1);
							} else {
								throw new Error("file format doesn't correspond. field delimiter is not present for value " + val);
							}
							if (val) {
								console.log("val " + val + " propertyName " + propertyName);
								_addToJsonObject(propertyName, jsonToGen, prototype, item, val);
							}
						}
					});
					//console.log(JSON.stringify(jsonToGen, null, 2));
				});
			} else {
				throw new Error("File to parse is empty or not correspond to the parsing context (check EDISEQFIL)");
			}
		});
		return jsonToGen;
	},
	fixedLength: function(input, elems, prototype, json, sContext) {
		var jsonToGen = json || {};

		Object.keys(input).forEach(function(filename) {
			//nb of readed character
			var lines = input[filename];
			if (lines.indexOf("\n")) {
				lines = lines.split('\n');
			} else {
				lines = [lines];
			}
			lines && lines.forEach(function(line) {
				elems.filter(function(prev, cur) {
					return elems[cur] && elems[cur].FILNAM === filename;
				}).forEach(function(item) {
					var realLoc = item.LOC - 1;
					var propertyName = item.EXPRESSION.substring(item.EXPRESSION.indexOf(".") + 1);

					if (realLoc < line.length) {
						// extract the value
						var val = parseHelp.removeSpace(line.substring(realLoc, realLoc + item.LNG).replace("/\n|\r/g", ""));

						if (val) {
							_addToJsonObject(propertyName, jsonToGen, prototype, item, val);
						}
					}
				});
				//console.log(JSON.stringify(jsonToGen, null, 2));
			});
		});
		return jsonToGen;
	}
};

exports.mapParse = _mapParse;

/*
 *  this function allow to return the object where we have to assign the property receive from the parsing with the value
 *   parameter :
 *      key : key that is defined to sequential File that indicate the property name of the x3 instance
 *      jsonRoot : the json root object to generate. it's an empty object at the begininng
 *      prototype :  the prototype of the classe that we want to create at the end of the process. This allow to know the type of each property
 *   return  :
 *      {
 *          key : key of the property in this last level
 *          json : the json object or array where we have to assign the property with value. In the case of array we have alos to retrieve which instance in the object
 *          property : the property item that describe the property defined by the key 'key'
 *      }
 */
function _addToJsonObject(key, jsonRoot, prototype, item, value) {
	function _createEmptyItem(propItem) { // depending of the typ fo the property, it create a empty object or empty array
		return propItem && propItem.$type === "application/x-array" ? [] : {};
	}

	function _getInstanceName() {
		return prototype.$instanceUrl.substring(prototype.$instanceUrl.indexOf("/") + 1);
	}

	// get the root property level

	var properties = prototype.$properties;

	var json = jsonRoot;

	var jsonKey = key.split('.');
	// create the last element
	if (jsonKey && jsonKey.length > 1) {
		for (var i = 0; i < jsonKey.length - 1 && properties; i++) {
			var elemKey = jsonKey[i];
			var propTemp = parseHelp.getProperty(properties, elemKey);

			if (!propTemp) {
				elemKey = _getInstanceName() + jsonKey.slice(0, i + 1).join(""); // hack item is identify by concat of all parent node
				propTemp = parseHelp.getProperty(properties, elemKey);
			}
			properties = propTemp; // we get the properties of the current key until the end
			if (properties) { // we get only the object level and not the property
				json[elemKey] = json[elemKey] || _createEmptyItem(properties); // assign to json[item to create object
				json = json[elemKey];

				if (Array.isArray(json)) { // if it's an array we have to return the right object in the array
					if (json.length === 0 || (i === jsonKey.length - 2 && item.newRecord)) { // if there nothin we create or we are on the level n-2 (level of the array)
						// add a property to set which item creat a new record in array
						item.newRecord = true;
						json.push({});
					}
					json = json[json.length - 1]; // json to return is the last ojbect in the array
				}
			} else { // failed for that key

				console.log("property " + key + " doesn't exists for the entity " + prototype.$representation);
			}
		}
		properties = properties && parseHelp.getProperty(properties, jsonKey[jsonKey.length - 1]);


	} else { // case of property in root level
		properties = properties[key];

		if (!properties) {
			console.log("property " + key + " doesn't exists for the entity " + prototype.$representation);
		}
	}

	if (properties) {
		json[jsonKey[jsonKey.length - 1]] = _formatType(properties, value);

	} else {
		return null;
	}

}

function _formatType(propItem, str) {

	switch (propItem.$type) {
		case "application/x-decimal":
			// create format
			var float = parseFloat(str, 10);
			if (!float) {
				throw new Error("value " + str + " is not a decimal");
			}
			return float;
		case "application/x-integer":
			var int = parseInt(str, 10);
			if (!int) {
				throw new Error("value " + str + " is not a decimal");
			}
		case "application/x-boolean":
			return int;
		case "application/x-boolean":
			return Boolean(str);
		case "application/x-date":
			var date = datetime.parse(str, "dd/MM/yyyy");
			return date.toString("yyyyMMdd");

		default:
			return str;
	}
}