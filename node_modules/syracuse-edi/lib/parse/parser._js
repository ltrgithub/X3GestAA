"use strict";
var config = require('config'); // must be first syracuse require
var trace = config.edi && config.edi.parser && config.edi.parser.trace;
var seqFileType = require('syracuse-edi/lib/enumType').SEQFILE;
/**
 * Created by apisu on 01/07/2014.
 * parse of the edi file to a json structure regarding a specific context
 */


///
/// ### function parse that create a json file from Edi sequential file(s)
///  parse(_,buff,opt)
///     buff : buffer of the file read in string or binary
///     opt : contains all element for generation
exports.parse = function(_, filesBuff, ediCached, res) {


	res = res || {};
	var seqFile = ediCached.sequentialFile(_);
	var prototype = ediCached.prototype(_);

	if (seqFile && seqFile.TYPFIL === seqFileType.FIXEDFILE) {
		trace && trace("number of files to parse " + filesBuff.length);
		trace && trace("sizeFixed " + (seqFile.TYPFIL === seqFileType.FIXEDFILE));

		_parseFixedSize(_, filesBuff, ediCached, prototype, res);
	} else {
		// case with a token (field delimiter)
	}
};


/*
 *  this function allow to return the object where we have to assign the property receive from the parsing with the value
 *   parameter :
 *      key : key that is defined to sequential File that indicate the property name of the x3 instance
 *      jsonRoot : the json root object to generate. it's an empty object at the begininng
 *      prototype :  the prototype of the classe that we want to create at the end of the process. This allow to know the type of each property
 *   return  :
 *      {
 *          key : key of the property in this last level
 *          json : the json object or array where we have to assign the property with value. In the case of array we have alos to retrieve which instance in the object
 *          property : the property item that describe the property defined by the key 'key'
 *      }
 */
function _getJsonObject(key, jsonRoot, prototype) {
	function _createEmptyItem(propItem) { // depending of the typ fo the property, it create a empty object or empty array
		return propItem && propItem.$type === "application/x-array" ? [] : {};
	}

	function _getSubProperties(propItem) {
		if (!propItem) {
			return null;
		}
		if (Object.keys(propItem).length === 0) {
			return null;
		}
		if (propItem.$item && Object.keys(propItem.$item).indexOf("$properties") > 0) {
			return propItem.$item.$properties;
		}

		return _getSubProperties(propItem.$item);
	}
	// get the root property level

	var properties = prototype.$properties;

	var json = jsonRoot;
	var jsonKey = key.split('.');
	// create the last element
	if (jsonKey && jsonKey.length > 1) {
		for (var i = 0; i < jsonKey.length && properties; i++) {
			var item = jsonKey[i];

			properties = properties[item] || _getSubProperties(properties) && _getSubProperties(properties)[item] || null;

			if (i < jsonKey.length - 1) { // we get only the object level and not the property
				// TODO manage if we have array of object of array
				json[item] = json[item] || _createEmptyItem(properties);
				json = json[item];
			}

			// log warning
			if (!properties) {
				console.log("property " + key + " doesn't exists for the entity " + prototype.$representation);
			}
		};
	} else { // case of property in root level
		properties = properties[key];

		if (!properties) {
			console.log("property " + key + " doesn't exists for the entity " + prototype.$representation);
		}
	}
	if (properties) {
		return {
			key: jsonKey[jsonKey.length - 1],
			"json": json,
			property: properties
		};
	} else {
		return null;
	}

}

function _formatType(propItem, str) {
	switch (propItem.$type) {
		case "application/x-decimal":
			return parseFloat(str, 10);
			break;
		case "application/x-integer":
			return parseInt(str, 10);
			break;
		case "application/x-boolean":
			return Boolean(str);
			break;
		default:
			return str;
	}
}
/*
 * set the value to the right property in the json file
 *  _addInJson(propertyName, prototype, jsonToGen, value[, index])
 *  parameter :
 *      propertyName : full name fo the property (i.e : AAA.TEST.AB.CODE)
 *      prototype : object that represent the prototype of the X3 class
 *      jsonToGen : json already generate on which we have to add a property
 *      value : object that contains value of the property and if the value is at the end of th record
 *          i.e {
 *                  value : "val",
 *                  endRec : true
 *              }
 */
function _addInJson(propertyName, prototype, jsonToGen, value) {
	// TODO manage array of object of array
	var resJson = _getJsonObject(propertyName, jsonToGen, prototype);

	if (resJson) {
		console.log(resJson.property.$type);
		if (Array.isArray(resJson.json)) {
			var arr = resJson.json;
			if (arr.length === 0) { // add an element by default
				arr.push({});
			}
			var item = arr[arr.length - 1];
			item[resJson.key] = _formatType(resJson.property, value.value);
			trace && trace("item :" + JSON.stringify(item) + "-  key :" + resJson.key + "- val:" + JSON.stringify(_formatType(resJson.property, value.value)));

			if (value.endRec) {
				// add a new element in the array
				arr.push({});
			}
		} else {
			resJson.json[resJson.key] = _formatType(resJson.property, value.value);
		}
	}
}
/*
 * buff
 * seqFile correspond to the sequential File
 */
function _parseFixedSize(filesBuff, seqFile, prototype, jsonToGen) {
	function _removeSpace(str) {
		var i = 0;
		while ([" ", "\n", "\r"].indexOf(str[i]) !== -1 && i++ < str.length) {}

		str = str.substring(i);
		var i = str.length - 1;
		while ([" ", "\n", "\r"].indexOf(str[i]) !== -1 && i-- >= 0) {}
		str = str.substring(0, i + 1);
		return str;
	}
	// basic format to the right type

	// size if fix and we have to follow the sequential file to parse each expression

	Object.keys(filesBuff).forEach(function(filename) {
		//
		var currentbuff = filesBuff[filename];
		while (currentbuff) {
			var k = 0;
			var offsetLine = 0;
			seqFile.ESFESFD.forEach(function(item) {
				if (item.FILNAM == filename) {

					// extract value
					console.log(offsetLine);
					var offset = item.LOC - 1 + offsetLine;
					var propertyName = item.EXPRESSION.substring(item.EXPRESSION.indexOf(".") + 1); // remove first element
					var val = _removeSpace(filesBuff[filename].substring(offset, offset + item.LNG).replace("/\n|\r/g", ""));
					_addInJson(propertyName, prototype, jsonToGen, {
						value: val,
						endRec: item.ENDREG
					});
					if (item.ENDREG) {
						offsetLine += item.LOC + item.LNG;
					}
					console.log(JSON.stringify(jsonToGen, null, 2));
					//console.log("value '"+val +"' length " +val.length+" length expected "+ item.LNG+" expression "+item.EXPRESSION);
					currentbuff = currentbuff.substring(item.LNG);

				}
			});
		}
	});
}

exports.parseFixedSize = _parseFixedSize; // for unit test