"use strict";
var ediProcessTracer = require("syracuse-trace/lib/helper").getTracer("edi.process");
var encodingMenulocalMap = require('syracuse-edi/lib/helpers').encodingMenuLocalMap;
var Sadfsq = require("syracuse-x3/lib/clients/sadfsq/sadfsqClient").SadFsqClient;
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var protoMap = require("syracuse-edi/lib/helpers").protocolPropertyMap;
var sqMap = require("syracuse-edi/lib/helpers").seqentialFilePropertyMap; // TODO remove that requite and path the map directory in parameter
var locale = require("syracuse-core/lib/locale");

function _getSadFsq(_, endpoint, opt) {

	return new Sadfsq(_, endpoint, null, null, null, (opt.sadfsq && opt.sadfsq.recOptions) || {});

}
// retrieve EDI process context in X3 (manage with cache mechanism to prevent to generate always the data

function _getEndpoint(_, protocol, ep, opt) {
	var endpoint;
	if (protocol && protocol.$actxFolder) {
		endpoint = adminHelper.getEndpoint(_, {
			jsonWhere: {
				x3ServerFolder: protocol.$actxFolder // take the folder define in the protocol or folder by default sent by x3
			}
		});
	} else {
		endpoint = ep;
	}
	//hack
	var user = opt && opt.sadfsq && opt.sadfsq.user;
	var pass = opt && opt.sadfsq && opt.sadfsq.password;
	if (endpoint === null) {
		throw new Error(locale.format(module, "noEndpoint"));
	}
	return endpoint;
}


exports.mvReceiptArchiveFiles = function(_, protocol, inputs, ep, opt) {
	ediProcessTracer.debug && ediProcessTracer.debug(" mvReceiptArchiveFiles protocol = " + (protocol && protocol.PTCCOD) + ", endpoint = " + (ep && ep.dataset(_)));

	function _checkPatternFileName(name, sf) {
		var fileid = null;
		for (var i = 0; sf && sf[sqMap.filesDescription] && i < sf[sqMap.filesDescription].length && !fileid; i++) { // se base sur le tableau qui decrit la liste des fichiers //TODO check pattern
			var item = sf[sqMap.filesDescription][i][sqMap.filesDescriptions.fileName];
			var regexp = item ? new RegExp(item) : null;
			if (regexp && regexp.test(name)) { // TODO check pattern
				fileid = item;
			}
		}
		return fileid;
	}
	var listFile = Object.keys(inputs);
	try {

		var sadFsq = _getSadFsq(_, _getEndpoint(_, protocol, ep, opt), opt);

		// find the RECEIPT dir
		var items = protocol[protoMap.listDirectory] && protocol[protoMap.listDirectory].filter(function(item) {
			return item[protoMap.listDirectories.typeDirectory] === "DIRRECEIPT";
		});
		var receiptpath = items && items[0][protoMap.listDirectories.path];
		var items = protocol[protoMap.listDirectory] && protocol[protoMap.listDirectory].filter(function(item) {
			return item[protoMap.listDirectories.typeDirectory] === "DIRARCHIVE";
		});
		var archivepath = items && items[0][protoMap.listDirectories.path];

		//console.log("recept path " + receiptpath + " archive path " + archivepath);

		// check existence of archive dir
		if (!sadFsq.exists(_, {
			path: archivepath
		})) {
			sadFsq.mkdir(_, {
				path: archivepath
			});
		}
		for (var i = 0; i < listFile.length; i++) {
			sadFsq.mv(_, {
				path: receiptpath + "/" + listFile[i]
			}, {
				path: archivepath + "/" + listFile[i] + "_" + opt.idProcess
			});
		}
	} catch (e) {
		// log exception
		ediProcessTracer.error && ediProcessTracer.error("_getReceiptFiles message " + e + " stack " + e.stack);
		throw e;
	} finally {
		ediProcessTracer.debug && ediProcessTracer.debug(" _getReceiptFiles done");
	}
};


exports.writeIssueFiles = function(_, protocol, seqFile, ep, out, opt, map) {
	ediProcessTracer.debug && ediProcessTracer.debug(" _writeIssueFiles protocol = " + (protocol && protocol.PTCCOD) + ", endpoint = " + (ep && ep.dataset(_)) + ", files = " + JSON.stringify(Object.keys(out)));
	try {
		var dirIssue = opt.action === "import" ? "DIRIMPORT" : "DIRISSUE";
		if (opt.test)
			dirIssue = dirIssue + "TEST";

		var sadFsq = _getSadFsq(_, _getEndpoint(_, protocol, ep, opt), opt);
		var stamp = opt.unittest ? "" : (new Date()).getTime(); // don't take stamp for offline unit test
		out && Object.keys(out).forEach_(_, function(_, filename) {
			var itemsIssue = protocol && protocol[protoMap.listDirectory] && protocol[protoMap.listDirectory].filter(function(item) {
				return item && item[protoMap.listDirectories.typeDirectory] === dirIssue;
			});
			var itemsArch = protocol && protocol[protoMap.listDirectory] && protocol[protoMap.listDirectory].filter(function(item) {
				return item && item[protoMap.listDirectories.typeDirectory] === "DIRARCHIVE";
			});
			//log("filename " + /\w|\d/.test(files[filename].content) + " content '" + files[filename].content + "'  mandatory " + files[filename].mandatory);
			if ((/\w|\d/.test(out[filename].content)) || out[filename].mandatory) {
				sadFsq.writeFile(_, {
						"path": (opt.path || itemsIssue && itemsIssue[0][protoMap.listDirectories.path]) + "/" + filename
					},
					out[filename].content, {
						flag: "a+",
						encoding: opt.encoding || (seqFile && seqFile[map.encoding]) || "utf-8"
					}
				);
				if (!opt.test) {
					// save issue file is write succeed to archive folder and suffixed them with timestamp
					sadFsq.writeFile(_, {
							"path": (opt.path || itemsArch && itemsArch[0][protoMap.listDirectories.path]) + "/" + filename + "_" + opt.idProcess
						},
						out[filename].content, {
							flag: "a+",
							encoding: opt.encoding || (seqFile && encodingMenulocalMap[seqFile[map.encoding]]) || "utf-8"
						}
					);
				}
			}

		});
	} catch (e) {
		// log exception
		ediProcessTracer.error && ediProcessTracer.error("_writeIssueFiles message " + e + " stack " + e.stack);

		throw e;
	} finally {
		ediProcessTracer.debug && ediProcessTracer.debug(" _writeIssueFiles done ");
	}
};

exports.getReceiptFiles = function(_, protocol, seqFile, ep, opt) {
	ediProcessTracer.debug && ediProcessTracer.debug(" _getReceiptFiles protocol = " + (protocol && protocol.PTCCOD) + ", endpoint = " + (ep && ep.dataset(_)));

	function _checkPatternFileName(name, sf) {
		var fileid = null;
		for (var i = 0; sf && sf[sqMap.filesDescription] && i < sf[sqMap.filesDescription].length && !fileid; i++) { // se base sur le tableau qui decrit la liste des fichiers //TODO check pattern
			var item = sf[sqMap.filesDescription][i][sqMap.filesDescriptions.fileName];
			var regexp = item ? new RegExp(item) : null;
			if (regexp && regexp.test(name)) { // TODO check pattern
				fileid = item;
			}
		}
		return fileid;
	}
	try {

		var sadFsq = _getSadFsq(_, _getEndpoint(_, protocol, ep, opt), opt);

		// find the RECEIPT dir
		var items = protocol[protoMap.listDirectory] && protocol[protoMap.listDirectory].filter(function(item) {
			return item[protoMap.listDirectories.typeDirectory] === "DIRRECEIPT";
		});
		var path = items && items[0][protoMap.listDirectories.path];
		var listFile = sadFsq.readdir(_, {
			path: path
		});
		var fileBuff = {};
		for (var i = 0; i < listFile.length; i++) {
			var fileId = _checkPatternFileName(listFile[i], seqFile);
			if (fileId) {
				try {
					var filename = listFile[i];

					fileBuff[filename] = sadFsq.readFile(_, {
						path: path + "/" + listFile[i]
					}, {
						flag: "r",
						encoding: (seqFile && encodingMenulocalMap[seqFile[sqMap.encoding]]) || "utf-8"
					});
				} catch (e) {
					ediProcessTracer.error && ediProcessTracer.error("can't read file " + listFile[i] + " maybe it's a folder : message " + e + " stack " + e.stack);
				}
			}
		}
		return fileBuff;
	} catch (e) {
		// log exception
		ediProcessTracer.error && ediProcessTracer.error("_getReceiptFiles message " + e + " stack " + e.stack);
		throw e;
	} finally {
		ediProcessTracer.debug && ediProcessTracer.debug(" _getReceiptFiles done");
	}
};