"use strict";

var config = require('config');
var EdiEntity = require('../edi_Entity');
require('../edi_Process'); // TOOD rqeuire to load traces

var sa = require('syracuse-orm/lib/storageArea');
var EdiType = require('../enumType').EdiType;
var EdiTypeToClass = require('../enumType').EdiTypeToClass;
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var helpersEdi = require('../helpers');
var datetime = require('syracuse-core').types.datetime;
var scheduler = require("syracuse-event/lib/scheduler");


function _getCacheContext(_, instance, val, type) {
	console.log("_getCacheContext", type, val)
	if (val == null) return null;
	try {
		var cacheEdi = EdiEntity.getEdiCacheEntity(_, {
			filter: {
				jsonWhere: {
					$uuid: val,
				}
			},
			db: instance._db
		});
		var json = cacheEdi && cacheEdi.json(_)
		console.log("_getCacheContext.json", JSON.stringify(json))
		return cacheEdi && cacheEdi.json(_);
	} catch (e) {
		console.log(e.stack);
		return null;
	}
}

exports.entity = {
	$capabilities: "",
	$titleTemplate: "EDI list process running",
	$descriptionTemplate: " ",
	$properties: {

		idProcess: {
			$title: "Process Id " // id of the edi process
		},
		expiration: {
			$title: "Expiration time (in millisecond)",
			$type: "datetime",
			$default: datetime.fromJsDate(new Date(0))
		},
		x3RepName: {
			$title: "name of x3 representation"
		},
		folder: {
			$title: "dataset of the endpoint to use",
			$propagate: function(_, instance, val) {
				var ed = adminHelper.getEndpoint(_, {
					jsonWhere: {
						x3ServerFolder: val
					} // tar by default sent by x3
				});

				instance.endPoint(_, ed);
			}
		},
		states: {
			$title: "states of the process (generation or decode)",
			$type: "text/plain",
			$propagate: function(_, instance, val) {
				if (val) { // state store error or warning generate
					instance.status(_, "failed");
				} else { // no states store - all is ok
					instance.status(_, "success");
				}
			}
		},
		status: {
			$title: "status of the process",
			$type: "string"
		},

		idMessageMapping: {
			$title: "Id of Message Mapping",
		},
		idSequentialFile: {
			$title: "id of Sequential File",
		},
		idProtocol: {
			$title: "id of protocol",
		},
		idFlow: {
			$title: "id of flow"
		},
		idXmlFile: {
			$title: "id of xml file"
		}

	},
	$relations: {
		endPoint: {
			$title: "endpoint",
			$type: "endPoint"
		}
	},
	$functions: {
		flow: function(_) {
			if (!this._flow)
				this._flow = _getCacheContext(_, this, this.idFlow(_));
			return this._flow;
		},
		messageMapping: function(_) {
			if (!this._messageMapping)
				this._messageMapping = _getCacheContext(_, this, this.idMessageMapping(_), "idMessageMapping");
			return this._messageMapping;
		},
		sequentialFile: function(_) {
			if (!this._sequentialFile)
				this._sequentialFile = _getCacheContext(_, this, this.idSequentialFile(_), "_sequentialFile");
			return this._sequentialFile;
		},
		protocol: function(_) {
			if (!this._protocol)
				this._protocol = _getCacheContext(_, this, this.idProtocol(_), "idProtocol");
			return this._protocol;
		},
		xmlPath: function(_) {
			if (!this._xmlPath)
				this._xmlPath = _getCacheContext(_, this, this.idXmlPath(_), "xmlPath");
			return this._xmlPath;
		},
		xmlFile: function(_) {
			if (!this._xmlFile)
				this._xmlFile = _getCacheContext(_, this, this.idXmlFile(_), "xmlFile");
			return this._xmlFile;
		},
		schedule: function(_) {
			if (new Date(this.expiration(_)._value).getTime() > 0) //
				return scheduler.schedule(_, this, this.$uuid, new Date(this.expiration(_)._value).getTime(), {}, "db");
		},
		fire: function(_, key, parameters) { // call by scheduler when a print document must be purge automatically
			try {
				// delete all file store in storage relative to that process
				sa.listDocument(_, {
					sdataWhere: "description eq '" + this.idProcess(_) + "'"
				}).forEach_(_, function(_, doc) {
					doc.deleteSelf(_);
				});
				EdiEntity.removeEdiCacheEntity(_, {
					sdataWhere: "id eq '" + this.idProcess(_) + "' and type eq 'sas'"
				});
				this.deleteSelf(_);

			} catch (e) {
				console.log(e.stack);
			}
		}
	},
	$services: {}
};