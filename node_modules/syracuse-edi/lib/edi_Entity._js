"use strict";
var config = require('config'); // must be first syracuse require
var ediClass = require('./helpers').EdiClass;
var ediEntityTracer = require("syracuse-trace/lib/helper").getTracer("edi.entity");
var locale = require("syracuse-core/lib/locale");
var sa = require("syracuse-orm/lib/storageArea");
var jsxml = require('js-xml');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;



exports.$exported = true;

function _createEdiEntity(_, opt) {

	// check if json is a string that represent a json object
	if (typeof opt === "string") {
		opt = JSON.parse(opt);
	}
	if (opt && opt.json && typeof opt.json !== "object") {
		throw new Error(locale.format(module, "storeJson"));
	}
	// check if data is already exists in mongo identified by id and type that are defined as a key for EdiCache and raise an error if it's the case
	var filder = {
		"jsonWhere": {
			"id": opt.id,
			"type": opt.type
		}
	};
	var klass = new ediClass(_, opt && opt.db, opt.entity);

	if (klass.getInstance(_, filder) !== null) {
		throw new Error(locale.format(module, "cantCreate", opt.id, opt.type));
	} else {

		var ediCache = new ediClass(_, opt && opt.db, opt.entity).createInstance(_);
		if (opt.etag) {
			ediCache.etag(_, opt.etag);
		}
		if (opt.id) {
			ediCache.id(_, opt.id); // sas, message mappign etc..
		}
		ediCache.type(_, opt.type); // sas, message mappign etc..
		ediCache.json(_, opt.json); // all entity has cache

		return ediCache;
	}


}

/// !doc
///
/// ## dropAllEdiCacheEntity(_) :
/// This function allow to delete all the edi store in mongodb
///
exports.dropAllEdiCacheEntity = function(_, opt) {
	var edi = new ediClass(_, opt && opt.db);

	edi.dropAllInstance(_);


};

/// ## var uuid = createEdiCacheEntity(_,opt) :
/// This function allow to create a Edi Entity in mongodb database. It possible to create 1 entity or several in the same time
///         opt : object that describe the entity to create. This object must contains at least a json object to be store and an id that deosn't need to be unique
///         uuid : the uuid of the created entity that identified it in mongod
///
/// ```javascript
/// var opt = {
///     id : "id of the entity (i.e : INVOIC)",
///     type : "type of the entity (SeqFile, ..)",
///     etag : "etag of entity when it's stored",
///     json : {"":...},
/// };
/// uuid = "uuid of the edi entity created"
/// ```
///
/// if this function is called with in option parameter a array of json for the parameter json. it will store for each element of the array
/// a cache entity with for id  = opt.id +"_ "+index of the json element in the array". In that case it will return a array of uuid.
///
/// ```javascript
/// var opt = {
///    id : "id of the entity (i.e : INVOIC)",
///    type : "type of the entity (SeqFile, ..)",
///    etag : "etag of entity when it's stored",
///    json : [{..} , {...} , {...}]
/// };
/// uuid = ["uuid1","uuid2","uuid3"]
/// ```
///
/// in any case, if it failed it return a error.
///

function _createEdiCacheEntity(_, opt) {
	ediEntityTracer.debug && ediEntityTracer.debug("createEdiCacheEntity id = " + opt.id + ", type=" + opt.type + ", etag=" + opt.etag + " custom db specified " + (opt.db !== null));
	var uuids;
	var objs = [];
	try {
		if (Array.isArray(opt.json)) {
			uuids = [];
			var i = 0;
			opt.json.forEach_(_, function(_, item) {
				var optItem = {
					json: item,
					type: opt.type
				};
				optItem.db = opt.db;
				if (opt.etag)
					optItem.etag = opt.etag;
				optItem.id = opt.id + "_" + i;
				var obj = _createEdiEntity(_, optItem);
				//obj.save(_);
				objs.push(obj);
				uuids.push(obj.$uuid);
				i++;
			});

			return uuids.length === 0 ? null : uuids;
		} else {
			var inst = _createEdiEntity(_, opt);
			objs.push(inst);
			//inst.save(_);
			uuids = inst.$uuid;
			return uuids;
		}
	} catch (e) {
		// log exception
		ediEntityTracer.error && ediEntityTracer.error(" message " + e.message + " stack " + e.stack);

		throw e;
	} finally {
		// save if we ask to rollback in any error at the end
		for (var i = 0; objs && i < objs.length; i++) {
			objs[i].save(_);
		}
		ediEntityTracer.info && ediEntityTracer.info("createEdiCacheEntity done uuid = " + JSON.stringify(uuids));

	}
};

exports.createEdiCacheEntity = _createEdiCacheEntity;


/// ## var instances = getEdiCacheEntity(_,opt) :
/// This function allow to get an entity of several entity identified by a uuid
///     opt : json object that contains the element to get the entity. this can contains a uuid, a list of uuid or a sdatafilter
///     instance : the edi entity instance loaded if it's found or array of object {uuid: instance)} else null
///
/// possible value for parameter opt and instances  :
/// ```javascript
/// var opt = {
///    uuid : "uuid of the entity to get"
/// }
///
/// instances = { mongodb instance }
/// ```
///
/// or
///
/// ```javascript
/// var opt = {
///   uuid : ["uuid1","uuid2","uuid3"]
/// }
///
/// instances = [{ mongodb instance },...]
///
/// ```
///
/// or
///
/// ```javascript
/// var opt = {
///     filter : {
///         jsonWhere :  {
///             "id" : "value id",
///             "type" : "value type "
///         }
///     }
/// }
///
///
///
/// instances = [{ mongodb instance },...]
///
/// ```
///
exports.getEdiCacheEntity = _getEdiCacheEntity;

function _getEdiCacheEntity(_, opt) {
	ediEntityTracer.debug && ediEntityTracer.debug("_getEdiCacheEntity uuid = " + JSON.stringify(opt.uuid) + " custom db specified " + (opt.db !== null));
	try {
		if (opt.uuid) {
			if (Array.isArray(opt.uuid)) {
				var insts = [];
				opt.uuid.forEach_(_, function(_, item) {
					var filder = {
						"jsonWhere": {
							"$uuid": item
						}
					};
					ediEntityTracer.debug && ediEntityTracer.debug("filter " + JSON.stringify(filder));
					var ediSasInst = new ediClass(_, opt && opt.db).getInstance(_, filder);
					ediEntityTracer.debug && ediEntityTracer.debug("instance exists " + (ediSasInst !== null));

					if (ediSasInst) {
						insts.push(ediSasInst);
					} else {
						throw new Error(locale.format(module, "findUuid", item));
					}
				});

				return insts.length === 0 ? null : insts;
			} else {
				var filder = {
					"jsonWhere": {
						"$uuid": opt.uuid
					}
				};
				ediEntityTracer.debug && ediEntityTracer.debug("filter " + JSON.stringify(filder));
				var ediSasInst = new ediClass(_, opt && opt.db).getInstance(_, filder);
				ediEntityTracer.debug && ediEntityTracer.debug("instance exists " + (ediSasInst !== null));

				return ediSasInst;
			}
		} else if (opt.filter) {
			return new ediClass(_, opt && opt.db).getInstance(_, opt.filter);
		}
	} catch (e) {
		// log exception
		ediEntityTracer.error && ediEntityTracer.error(" message " + e.message + " stack " + e.stack);

		throw e;
	} finally {
		ediEntityTracer.info && ediEntityTracer.info("_getEdiCacheEntity done on " + ((opt.uuid && JSON.stringify(opt.uuid)) || (opt.filter && JSON.stringify(opt.filter))));
	}

};

/// ## var json = getEdiCacheJson(_,opt) :
/// This function allow to get the json of an entity or  of several entity identified by a uuid
///     opt : json object that contains the element to get the entity. this can contains a uuid, a list of uuid or a sdatafilter
///     json : the javascript object with as a key the uuid of the entity object and as a value the json object store in mongodb. Can be a single object or an array of object
///
/// ```javascript
/// var opt = {
///    uuid : "uuid of the entity to get"
/// }
///
/// json =  {"uuid" : {...} }
/// ```
///
/// or
///
/// ```javascript
/// var opt = {
///    uuid : ["uuid1","uuid2","uuid3"]
/// }
///
/// json = [{"uuid1":{...} , {"uuid2":{...} }, {"uuid3": {...}}]
///
///
/// var opt = {
///     filter : {
///         jsonWhere :  {
///             "id" : "value id",
///             "type" : "value type "
///         }
///     }
/// }
/// ```
///
exports.getEdiCacheJson = function(_, opt) {
	ediEntityTracer.debug && ediEntityTracer.debug("getEdiCacheJson uuid = " + JSON.stringify(opt.uuid) + " custom db specified " + (opt.db != null));
	try {
		if (opt.uuid) {
			if (Array.isArray(opt.uuid)) {
				var jsons = [];
				opt.uuid.forEach_(_, function(_, item) {
					var ediSasInst = new ediClass(_, opt && opt.db).getInstance(_, {
						"jsonWhere": {
							"$uuid": item
						}
					});
					if (ediSasInst) {
						var objItem = {};
						objItem[item] = ediSasInst.json(_);
						jsons.push(objItem);
					} else {
						throw new Error(locale.format(module, "findUuid", item));
					}
				});
				return jsons.length === 0 ? null : jsons;
			} else {
				var ediSasInst = new ediClass(_, opt && opt.db).getInstance(_, {
					"jsonWhere": {
						"$uuid": opt.uuid
					}
				});
				return ediSasInst && ediSasInst.json(_);
			}
		} else if (opt.filter) {
			var ediSasInst = new ediClass(_, opt && opt.db).getInstance(_, opt.filter);
			return ediSasInst && ediSasInst.json(_);
		}
		return null;
	} catch (e) {
		// log exception
		ediEntityTracer.error && ediEntityTracer.error(" message " + e.message + " stack " + e.stack);

		throw e;
	} finally {
		ediEntityTracer.debug && ediEntityTracer.debug("getEdiCacheJson done ");
	}
};



function _checkEDIVolume(_) {
	var db = adminHelper.getCollaborationOrm(_);
	var vols = db.db.collection("StorageVolume", _).find({
		code: "EDI"
	}).toArray(_);
	if (!vols || !vols.length) {
		// create std volume
		var vol = db.model.getEntity(_, "storageVolume").factory.createInstance(_, null, db);
		vol.code(_, "EDI");
		vol.description(_, {
			"default": "EDI storage volume",
			"en-US": "EDI storage volume",
			"fr-FR": "Volume EDI"
		});
		vol.storageType(_, "db_file");
		vol.save(_);
		//
	}
}

exports.getSADocument = function(_, name) {
	var list = [];
	sa.listDocuments(_, {
		sdataWhere: "description eq '" + name + "'"
	}).forEach_(_, function(_, doc) {
		var filter = {
			jsonWhere: {
				$uuid: doc.$uuid
			}
		};
		doc.properties = {
			description: name,
			content: {
				contentType: "application/text",
				fileName: doc.fileName(_),
			}
		};
		doc.dd = sa.open(_, filter);
		list.push(doc);
	});
};

exports.createSADocument = function(_, id, filename) {
	_checkEDIVolume(_); //create EDI volume
	var doc = {};
	doc.properties = {
		description: id,
		content: {
			contentType: "application/text",
			fileName: filename,
		}
	};
	doc.dd = sa.open(_, null, {
		volume: "EDI"
	});
	return doc;
};

exports.closeSADocument = function(_, documents) {
	documents && Object.keys(documents).forEach_(_, function(_, key) {
		sa.close(_, documents[key].doc.dd);
	});
};

exports.updateSADocument = function(_, d, encoding) {

	sa.write(_, d.doc.dd, d.doc.properties, new Buffer(d.output, encoding), true);

};

exports.removeSADocument = function(_, name) {
	var doc = sa.listDocuments(_, {
		sdataWhere: "description eq '" + name + "'"
	});
	doc.forEach_(_, function(_, d) {
		d.deleteSelf(_);
	});
};

/// ## updateEdiCacheEntity(_,opt) :
/// This function allow to update the json of an entity or  of several entity identified by a uuid
///     opt : json object that contains the element to get the entity. this can contains a uuid, a list of uuid or a sdatafilter
///
/// raise an exception if on the update failed.
///
/// ```javascript
/// var opt = {
///    elems : [{uuid : "uuid of the entity to update", json: {..json object to set ..} }, {..}, .. ],
///
///
/// }
/// ```
///
function _updateEdiCacheEntity(_, opt) {
	ediEntityTracer.debug && ediEntityTracer.debug("updateEdiCacheEntity elems = " + JSON.stringify(opt.elems) + " custom db specified " + (opt.db !== null));
	var instances;
	var changes = {};

	try {
		if (opt.elems) {
			// check if the elem exists for each uuid in mongodb
			opt.elems.forEach_(_, function(_, elem) {
				changes[elem.uuid] = elem.json;
			});
			instances = _getEdiCacheEntity(_, {
				uuid: Object.keys(changes),
				db: opt.db
			});
			if (!instances || instances.length !== Object.keys(changes).length) {
				ediEntityTracer.debug && ediEntityTracer.debug(" instance " + require('util').inspect(instances));
				ediEntityTracer.debug && ediEntityTracer.debug(" change " + JSON.stringify(Object.keys(changes)));

				throw new Error(locale.format(module, "findUuid", JSON.stringify(Object.keys(changes))));
			}
			instances.forEach_(_, function(_, instance) {
				instance.json(_, changes[instance.$uuid]);
				//instance.save(_);
			});
		}
	} catch (e) {
		// log exception
		ediEntityTracer.error && ediEntityTracer.error(" message " + e.message + " stack " + e.stack);

		throw e;
	} finally {
		instances && instances.forEach_(_, function(_, inst) {
			inst.save(_);
		});
		ediEntityTracer.info && ediEntityTracer.info("updateEdiCacheEntity done on " + Object.keys(changes));

	}
};
exports.updateEdiCacheEntity = _updateEdiCacheEntity;

/// ## removeEdiCacheEntity(_,opt) :
/// This function allow to remove the json of an entity or  of several entity identified by a uuid
///     opt : json object that contains the element to get the entity. this can contains a uuid, a list of uuid or a sdatafilter
///
/// ```javascript
/// var opt = {
///    uuid : "uuid of the entity to get"
/// }
///
/// ```
///
/// or
///
/// ```javascript
/// var opt = {
///    uuid : ["uuid1","uuid2","uuid3"]
/// }
///
/// var opt = {
///     filter : {
///         jsonWhere :  {
///             "id" : "value id",
///             "type" : "value type "
///         }
///     }
/// }
///
/// ```
///
exports.removeEdiCacheEntity = function(_, opt) {
	ediEntityTracer.debug && ediEntityTracer.debug("removeEdiCacheEntity uuid = " + JSON.stringify(opt.uuid) + " custom db specified " + (opt.db !== null));
	try {
		if (opt.uuid) {
			var arr = opt.uuid;
			if (!Array.isArray(arr)) {
				arr = [arr];
			}
			arr.forEach_(_, function(_, item) {
				new ediClass(_, opt && opt.db).deleteInstance(_, {
					"jsonWhere": {
						"$uuid": item
					}
				});
			});
		} else if (opt.filter) {
			new ediClass(_, opt && opt.db).deleteInstance(_, opt.filter);
		}
	} catch (e) {
		// log exception
		ediEntityTracer.error && ediEntityTracer.error(" message " + e.message + " stack " + e.stack);

		throw e;
	} finally {
		ediEntityTracer.info && ediEntityTracer.info("removeEdiCacheEntity done on =" + JSON.stringify(opt.uuid));
	}
};




function _getPrefix(jsXsd) {
	var schemaPropName = null;
	for (var i = 0; i < Object.keys(jsXsd).length && !schemaPropName; i++) {
		if (Object.keys(jsXsd)[i].indexOf("schema") !== -1) {
			schemaPropName = Object.keys(jsXsd)[i];
		}
	}
	//console.log("schemaPropName "+schemaPropName);

	// check all name space declared
	var listAttr = jsXsd[schemaPropName].$ && Object.keys(jsXsd[schemaPropName].$);
	var prefix = "";

	for (var i = 0; i < listAttr.length && !prefix; i++) {
		var attr = listAttr[i];
		//console.log("attr "+JSON.stringify(jsXsd[schemaPropName].$[attr]));

		if (jsXsd[schemaPropName].$[attr] === "http://www.w3.org/2001/XMLSchema") {
			if (attr !== "targetNameSpace") {
				prefix = attr.substring(6);
				prefix = prefix ? prefix + ":" : prefix;
			}
		}
	}
	return prefix;
}

function _executeParseXsd(_, opt, jsXsds) {

	function parseSimpleType(elems, mapSimpleType, prefix, listNameSpace) {
		if (elems && !Array.isArray(elems)) {
			elems = [elems];
		}
		elems && elems.forEach(function(elem) {
			var simpleTypes = elem[prefix + "simpleType"];
			if (simpleTypes && !Array.isArray(simpleTypes)) {
				simpleTypes = [simpleTypes];
			}
			simpleTypes && simpleTypes.forEach(function(simpleType) {
				var restriction = simpleType[prefix + "restriction"];

				var enumeration = [];
				if (restriction && restriction[prefix + "enumeration"]) {
					if (Array.isArray(restriction[prefix + "enumeration"])) {
						restriction[prefix + "enumeration"].forEach(function(enume) {
							enumeration.push(enume.$.value);
						});
					} else {
						enumeration.push(restriction[prefix + "enumeration"].$.value);

					}
				}
				mapSimpleType[listNameSpace.target + ":" + simpleType.$.name] = {
					$simple: true,
					$name: simpleType.$.name,
					$type: restriction.$.base,
					$restriction: {
						base: restriction.$.base,
						minInclusive: restriction[prefix + "minInclusive"] && restriction[prefix + "minInclusive"].$.value,
						maxInclusive: restriction[prefix + "maxInclusive"] && restriction[prefix + "maxInclusive"].$.value,
						pattern: restriction[prefix + "pattern"] && restriction[prefix + "pattern"].$.value,
						whiteSpace: restriction[prefix + "whiteSpace"] && restriction[prefix + "whiteSpace"].$.value,
						length: restriction[prefix + "length"] && restriction[prefix + "length"].$.value,
						minLength: restriction[prefix + "minLength"] && restriction[prefix + "minLength"].$.value,
						maxLength: restriction[prefix + "maxLength"] && restriction[prefix + "maxLength"].$.value
					}
				};
				if (enumeration.length) {
					mapSimpleType[listNameSpace.target + ":" + simpleType.$.name].$restriction.enumeration = enumeration;
				}
			});

		});
	}

	function parseComplexType(name, elemComplexType, map, prefix, listNameSpace) {

		var atts = elemComplexType[prefix + "attribute"] && elemComplexType[prefix + "attribute"];
		if (atts && !Array.isArray(atts)) {
			atts = [atts];
		}
		atts && atts.forEach(function(elem) {
			var type = listNameSpace.target + ":" + name;

			map[type] = map[type] || {};
			var splitType = elem.$.type && elem.$.type.indexOf(":") !== -1 ? elem.$.type.split(':') : null;

			map[type][elem.$.name] = {
				$name: elem.$.name,
				$type: splitType && listNameSpace[splitType[0]] ? listNameSpace[splitType[0]] + ":" + splitType[1] : (splitType && splitType.length ? elem.$.type : listNameSpace.target + ":" + (elem.$.type ||  elem.$.ref)),
				$leafAttribute: true
			};
			map[type].$complex = true;
			map[type].$name = name;

		});
		var elems = elemComplexType[prefix + "sequence"] && elemComplexType[prefix + "sequence"][prefix + "element"] && elemComplexType[prefix + "sequence"][prefix + "element"];
		if (!elems) {
			elems = elemComplexType[prefix + "all"] && elemComplexType[prefix + "all"][prefix + "element"] && elemComplexType[prefix + "all"][prefix + "element"];

		}
		if (elems && !Array.isArray(elems)) {
			elems = [elems];
		}
		elems && elems.forEach(function(elem) {
			//console.log("elem "+JSON.stringify(elem));
			var type = listNameSpace.target + ":" + name;

			var splitType = elem.$.type && elem.$.type.indexOf(":") !== -1 ? elem.$.type.split(':') : null;
			map[type] = map[type] || {};
			map[type][elem.$.name] = {
				$name: elem.$.name,
				$type: splitType && listNameSpace[splitType[0]] ? listNameSpace[splitType[0]] + ":" + splitType[1] : (splitType && splitType.length ? elem.$.type : listNameSpace.target + ":" + (elem.$.type ||  elem.$.name)),
				$leafElement: mapType[elem.$.type] && mapType[elem.$.type].$simple,
				$maxOccurs: elem.$.maxOccurs,
				$minOccurs: elem.$.minOccurs,
			};
			map[type].$name = name;
			map[type].$complex = true;



			parseComplexTypeInElem(elem, map, prefix, listNameSpace);

		});

	}
	// return if we have treated a complextype
	function parseComplexTypeInElem(jsXsd, mapComplexType, prefix, listNameSpace) {
		var elements = jsXsd;
		if (elements && !Array.isArray(elements)) {
			elements = [elements];
		}
		elements && elements.forEach(function(element) {
			var firstComplexType = element[prefix + "complexType"];
			if (firstComplexType) { // treat the first complex type and manage all sons
				parseComplexType(element.$.name, firstComplexType, mapComplexType, prefix, listNameSpace);
			}
		});

	}

	function parseElementsRoot(elems, mapComplexeType, prefix, listNameSpace) {
		if (elems && !Array.isArray(elems)) {
			elems = [elems];
		}
		elems && elems.forEach(function(elem) {
			var splitType = elem.$.type && elem.$.type.indexOf(":") !== -1 ? elem.$.type.split(':') : null;
			var type = splitType && listNameSpace[splitType[0]] ? listNameSpace[splitType[0]] + ":" + splitType[1] : (splitType && splitType.length ? elem.$.type : listNameSpace.target + ":" + (elem.$.type ||  elem.$.name));
			mapComplexeType[elem.$.name] = mapComplexeType[elem.$.name] || {
				$name: elem.$.name,
				$type: type,
			};
			if (mapComplexeType[type])
				mapComplexeType[type].$name = elem.$.name; // put the real for the root complexType
			mapComplexeType["root"] = mapComplexeType["root"] ||  [];
			mapComplexeType["root"].push(elem.$.name);
		});
	}

	function constructList(_, map, el, dd, content, opt) {
		var cnt = content;
		var stack = [{
			map: map,
			elem: el,
		}];
		var list = {};
		var treated = [];
		var firstWrite = true;
		while (stack.length) {
			var item = stack.pop();
			var mapType = item.map;
			var elem = item.elem;
			var father = item.father;
			var name = item.name;

			var card = null;
			if (item.minOccurs && item.minOccurs !== '0' ||  item.maxOccurs) {
				card = "[" + (item.minOccurs ||  "0") + (item.maxOccurs ? ".." + (item.maxOccurs === "unbounded" ? "n" : item.maxOccurs) : "") + "]";
			}


			if (elem) {
				if (elem && elem.$leafAttribute) {
					//console.log("$leafAttribute " + JSON.stringify(elem));
					if (list[father] && list[father].elems && list[father].elems.length) {
						list[father].elems.forEach_(_, function(_, item) {
							var att = {
								path: item.path + ".$." + (name || elem.$name),
								type: mapType[elem.$type] && mapType[elem.$type].$restriction.base || elem.$type,
								restriction: item.restriction = mapType[elem.$type] && mapType[elem.$type].$restriction
							};

							cnt = cnt + (firstWrite ? "" : "\n") + JSON.stringify(att);
							firstWrite = false;
						});
					}

				} else if (elem && (elem.$leafElement || (elem.$type && elem.$type.substring(0, 3) === "xs:"))) { // its  a simple type
					//console.log("$leafElement " + JSON.stringify(elem));

					if (list[father] && list[father].elems && list[father].elems.length) {
						list[father].elems.forEach_(_, function(_, item) {
							var element = {
								path: item.path + "." + (name || elem.$name),
								type: mapType[elem.$type] && mapType[elem.$type].$restriction.base || elem.$type,
								restriction: item.restriction = mapType[elem.$type] && mapType[elem.$type].$restriction
							};

							cnt = cnt + (firstWrite ? "" : "\n") + JSON.stringify(element);
							firstWrite = false;

						});
					}
				} else if (elem && elem.$complex) { // it's a complex type
					//console.log("complex " + JSON.stringify(elem, null, 2));

					if (!father) { // create the list of the father for the first element
						//console.log("add father " + JSON.stringify(elem.$name));

						list[elem.$name] = list[elem.$name] || {
							elems: [],
							nbsons: 0
						};


						list[elem.$name].elems.push({
							path: elem.$name + (card ? card : "")
						});
					}
					//console.log("list father "+JSON.stringify(list));

					if (list[father]) {
						list[father].elems.forEach(function(itemFather) {
							//console.log("itemFather " + JSON.stringify(itemFather));
							list[elem.$name] = list[elem.$name] || {
								elems: [],
								nbsons: 0
							};
							list[elem.$name].elems.push({
								path: itemFather.path + "." + (name || elem.$name) + (card ? card : "")
							});
							//console.log("path added "+itemFather.path + "." + elem.$name)
						});
					}

					var nb = Object.keys(elem).length;
					Object.keys(elem) && Object.keys(elem).forEach(function(item) {
						if (["$complex", "$name", "$type", "$maxOccurs", "$minOccurs"].indexOf(item) === -1) {
							stack.push({
								father: elem.$name,
								map: mapType,
								elem: mapType[item] || elem[item],
								maxOccurs: elem[item].$maxOccurs,
								minOccurs: elem[item].$minOccurs

							});
							list[elem.$name].nbsons = nb - 1;
						}
					});
					//console.log("list son "+JSON.stringify(list,null,2));

					// define that the current son is treated
					if (list[father]) {
						//console.log("nb of sons "+list[father].nbsons);
						list[father].nbsons--;
						if (!list[father].nbsons) // no more son so we delete the father context
							delete list[father];
					}
					//treated.push(elem.$name);
				} else { // case we receive the name of the root
					//console.log("root " + JSON.stringify(elem));
					stack.push({
						father: father,
						map: mapType,
						elem: mapType[elem.$type] || mapType[elem.$type.substring(0, 3)],
						name: elem.$name,
						maxOccurs: item.maxOccurs,
						minOccurs: item.minOccurs
					});
					//return elem && elem.$type && constructList(mapType, mapType[elem.$type]);
				}
			}
		}
		return cnt;
	}


	var mapType = {};

	// retrieve list of complexe contain in the xsd

	if (!jsXsds) {
		return null;
	}

	if (!Array.isArray(jsXsds)) {
		jsXsds = [jsXsds];
	}

	jsXsds && jsXsds.forEach(function(jsXsd) {
		var prefix = _getPrefix(jsXsd);
		// create list of name define in the schema
		var listNameSapce = {};
		jsXsd[prefix + "schema"].$ && Object.keys(jsXsd[prefix + "schema"].$).forEach(function(item) {
			if (item !== "http://www.w3.org/2001/XMLSchema" && item.indexOf("xmlns=") === -1) {
				listNameSapce[item] = jsXsd[prefix + "schema"].$[item];
			}
		});
		listNameSapce.target = jsXsd[prefix + "schema"].$.targetNamespace ||  jsXsd[prefix + "schema"].$.xmlns || "default";

		var listComplexType = jsXsd[prefix + "schema"][prefix + "complexType"];
		if (listComplexType) { // case of complexType describe in the root of the schema
			if (!Array.isArray(listComplexType)) {
				listComplexType = [listComplexType];
			}
			listComplexType.forEach(function(complexType) {
				parseComplexType(complexType.$.name, complexType, mapType, prefix, listNameSapce);
			});
		}
		parseComplexTypeInElem(jsXsd[prefix + "schema"][prefix + "element"], mapType, prefix, listNameSapce);

		parseSimpleType(jsXsd[prefix + "schema"], mapType, prefix, listNameSapce);

		parseElementsRoot(jsXsd[prefix + "schema"][prefix + "element"], mapType, prefix, listNameSapce);

	});

	var listXmlPath = [];
	var i = 0;
	mapType.root && mapType.root.forEach(function(rootElem) { // generate for each root element the list of possibilities
		listXmlPath[rootElem] = rootElem;
	});

	_checkEDIVolume(_);
	var ddXml = sa.open(_, null, {
		volume: 'EDI'
	});

	var content = "";
	mapType.root && mapType.root.forEach_(_, function(_, root) {
		content = constructList(_, mapType, mapType[root], ddXml, content, opt);
	});
	if (content) {
		sa.write(_, ddXml, {
			description: opt.id,
			content: {
				contentType: "plain/text",
				fileName: opt.id,
			}
		}, content, "utf8");
		var document = sa.close(_, ddXml, true);
		return document.$uuid;
	} else {
		return null;
	}

}

exports.executeParseXsd = _executeParseXsd;


function _createOrderedSchemaList(listXsd, jsonXsd, elem) {
	if (elem) { // add schema dependency
		for (var i = 0; elem.listNameSpace && i < elem.listNameSpace.length; i++) {
			var nmmspace = elem.listNameSpace[i];
			if (listXsd[nmmspace])
				_createOrderedSchemaList(listXsd, jsonXsd, listXsd[nmmspace]);
		}

		jsonXsd.push(elem.schema);
	} else {
		for (var i = 0; listXsd && i < Object.keys(listXsd).length; i++) {
			var current = listXsd[Object.keys(listXsd)[i]];
			if (current && jsonXsd.indexOf(current.schema) === -1) {
				_createOrderedSchemaList(listXsd, jsonXsd, current);
			}
		}
	}
}
/// ## var result = parseXsd(_,opt) :
/// This function parse an xsd file and store the xml path result into a entity in mongodb. it can be use for create or update the entity that containt the xmlpath. On update if the entity doesn't exists we automatically create a new entity
/// opt : contains all the element to parse the xsd in order to generate the xml path and create or update the result
/// result : contains the uuid of the edi cache entity create that contain the xml path
///
/// result = "uuid of the json store in cache",
///
///
/// ```javascript
/// var option =
///    xsdUuid : ["uuid1","uuid2"], //list of uuid of xsd file store in storage area
///    uuid : "uuid of already generate entity",
///    id : "id of the edi process"
/// };
/// ```
///
exports.parseXsd = function(_, opt) {

	try {

		// retrieve list of xsd to read in storage area
		var jsonXsd = [];
		var docs = [];

		opt.xsdUuid && Array.isArray(opt.xsdUuid) && opt.xsdUuid.forEach_(_, function(_, uuid) {

			var doc = sa.getDocumentInstance(_, {
				jsonWhere: {
					$uuid: uuid
				}
			});

			doc.content = jsxml.parse(sa.readAll(_, {
				jsonWhere: {
					$uuid: uuid
				}
			}).toString('utf8'));
			doc.filename = doc.fileName(_);

			docs.push(doc);
		});

		// sort jsxsd file in ordr to have the imported file before
		var listXsd = {};
		docs && docs.forEach(function(doc) {
			var pref = _getPrefix(doc.content);
			var schema = doc.content[pref + "schema"];
			var listNameSpace = [];
			Object.keys(schema.$).forEach(function(attr) {
				if (attr !== "xmlns" &&  attr !== "targetNamespace" && attr.indexOf("xmlns:") !== -1 && schema.$[attr] !== "http://www.w3.org/2001/XMLSchema") {
					listNameSpace.push(attr);
				}
			});

			listXsd[schema.$.target ||  schema.$.xmlns ||  "default"] = {
				pref: pref,
				schema: doc.content,
				listNameSpace: listNameSpace
			};

		});



		_createOrderedSchemaList(listXsd, jsonXsd);


		var entity = _getEdiCacheEntity(_, opt);

		var docuuid = _executeParseXsd(_, opt, jsonXsd);

		if (!entity) {
			entity = _createEdiEntity(_, {
				id: opt.id,
				type: "xmlType"
			});
		} else {
			// delete old document
			var docinst = sa.getDocumentInstance(_, {
				jsonWhere: {
					$uuid: entity.xmlPathId(_)
				}
			}, 'EDI');
			docinst && docinst.deleteSelf(_);
		}
		entity.xmlPathId(_, docuuid);
		//_updateEdiCacheEntity(_, opt)

		/*
	    comment remove of document xsd
	docs && docs.forEach_(_, function(_, doc) {
		doc.deleteSelf(_);
	});*/
		entity.save(_);
		return entity.$uuid;
	} catch (e) {
		console.error(e.stack);
		throw e;
	}
};

/// ## var result = removeXmlPath(_,opt) :
///
///

exports.removeXmlPath = function(_, opt) {
	var edicache = _getEdiCacheEntity(_, opt);
	var docuuid = edicache && edicache.xmlPathId(_);
	if (docuuid) {
		console.log("remove");
		sa.remove(_, {
			jsonWhere: {
				$uuid: docuuid
			}
		});
	}
	edicache && edicache.deleteSelf(_);
};
/// ```javascript
/// var option =
///    uuid : "uuid1", //list of uuid of xsd file store in storage area
///    startIndex : 1, //startIndex of the page
///    count : 20, // number of element  by page
/// };
/// ```
///
///
exports.getXmlPath = function(_, opt) {
	var edicache = _getEdiCacheEntity(_, opt);
	// check if the entity contain th xmlpath doc id
	var docuuid = edicache && edicache.xmlPathId(_);
	if (docuuid) {
		// the metamodel is associated to the orm
		//// read the file and return the
		var content = docuuid && sa.readAll(_, {
			jsonWhere: {
				$uuid: docuuid
			}
		}).toString('utf8') || null;

		var list = [];
		var line = content && content.split("\n");
		var startIndex = opt.startIndex && opt.startIndex > 0 ? opt.startIndex - 1 : 0;
		var count = opt.count && opt.count > 0 ? opt.count : 20;
		var k = 0;
		for (var i = startIndex; line && i < line.length && i < count + startIndex; i++) {
			var json = JSON.parse(line[i]);
			list.push({
				id: k + opt.startIndex,
				path: json.path,
				type: json.type,
				restriction: json.restriction
			});
			k++;
		}

		return {
			startIndex: opt.startIndex,
			count: count,
			elems: list,
			totalResult: line.length
		};
	} else {

		throw Error("can't find edi entity link to uuid " + (opt.uuid));
	}

};