"use strict";
var ediClass = require('./helpers').EdiClass;
var sa = require("syracuse-orm/lib/storageArea");
var jsxml = require('js-xml');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;

var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var ediEntityTracer = require('@sage/syracuse-core').getTracer("edi.entity");
var locale = require('streamline-locale');


exports.$exported = true;

function _createEdiEntity(_, opt) {

	// check if json is a string that represent a json object
	if (typeof opt === "string") {
		opt = JSON.parse(opt);
	}
	if (opt && opt.json && typeof opt.json !== "object") {
		throw new Error(locale.format(module, "storeJson"));
	}
	// check if data is already exists in mongo identified by id and type that are defined as a key for EdiCache and raise an error if it's the case
	var filder = {
		"jsonWhere": {
			"id": opt.id,
			"type": opt.type
		}
	};
	var klass = new ediClass(_, opt && opt.db, opt.entity);

	if (klass.getInstance(_, filder) !== null) {
		throw new Error(locale.format(module, "cantCreate", opt.id, opt.type));
	} else {

		var ediCache = new ediClass(_, opt && opt.db, opt.entity).createInstance(_);
		if (opt.etag) {
			ediCache.etag(_, opt.etag);
		}
		if (opt.id) {
			ediCache.id(_, opt.id); // sas, message mappign etc..
		}
		ediCache.type(_, opt.type); // sas, message mappign etc..
		ediCache.json(_, opt.json); // all entity has cache

		return ediCache;
	}


}

exports.createEdiEntity = _createEdiEntity;
/// !doc
///
/// ## dropAllEdiCacheEntity(_) :
/// This function allow to delete all the edi store in mongodb
///
exports.dropAllEdiCacheEntity = function(_, opt) {
	var edi = new ediClass(_, opt && opt.db);

	edi.dropAllInstance(_);


};

/// ## var uuid = createEdiCacheEntity(_,opt) :
/// This function allow to create a Edi Entity in mongodb database. It possible to create 1 entity or several in the same time
///         opt : object that describe the entity to create. This object must contains at least a json object to be store and an id that deosn't need to be unique
///         uuid : the uuid of the created entity that identified it in mongod
///
/// ```javascript
/// var opt = {
///     id : "id of the entity (i.e : INVOIC)",
///     type : "type of the entity (SeqFile, ..)",
///     etag : "etag of entity when it's stored",
///     json : {"":...},
/// };
/// uuid = "uuid of the edi entity created"
/// ```
///
/// if this function is called with in option parameter a array of json for the parameter json. it will store for each element of the array
/// a cache entity with for id  = opt.id +"_ "+index of the json element in the array". In that case it will return a array of uuid.
///
/// ```javascript
/// var opt = {
///    id : "id of the entity (i.e : INVOIC)",
///    type : "type of the entity (SeqFile, ..)",
///    etag : "etag of entity when it's stored",
///    json : [{..} , {...} , {...}]
/// };
/// uuid = ["uuid1","uuid2","uuid3"]
/// ```
///
/// in any case, if it failed it return a error.
///

function _createEdiCacheEntity(_, opt) {
	ediEntityTracer.debug && ediEntityTracer.debug("createEdiCacheEntity id = " + opt.id + ", type=" + opt.type + ", etag=" + opt.etag + " custom db specified " + (opt.db !== null));
	var uuids;
	var objs = [];
	try {
		if (Array.isArray(opt.json)) {
			uuids = [];
			var i = 0;
			opt.json.forEach_(_, function(_, item) {
				var optItem = {
					json: item,
					type: opt.type
				};
				optItem.db = opt.db;
				if (opt.etag)
					optItem.etag = opt.etag;
				optItem.id = opt.id + "_" + i;
				var obj = _createEdiEntity(_, optItem);
				//obj.save(_);
				objs.push(obj);
				uuids.push(obj.$uuid);
				i++;
			});

			return uuids.length === 0 ? null : uuids;
		} else {
			var inst = _createEdiEntity(_, opt);
			objs.push(inst);
			//inst.save(_);
			uuids = inst.$uuid;
			return uuids;
		}
	} catch (e) {
		// log exception
		ediEntityTracer.error && ediEntityTracer.error(" message " + e.message + " stack " + e.stack);

		throw e;
	} finally {
		// save if we ask to rollback in any error at the end
		for (var i = 0; objs && i < objs.length; i++) {
			objs[i].save(_);
		}
		ediEntityTracer.info && ediEntityTracer.info("createEdiCacheEntity done uuid = " + JSON.stringify(uuids));

	}
};

exports.createEdiCacheEntity = _createEdiCacheEntity;


/// ## var instances = getEdiCacheEntity(_,opt) :
/// This function allow to get an entity of several entity identified by a uuid
///     opt : json object that contains the element to get the entity. this can contains a uuid, a list of uuid or a sdatafilter
///     instance : the edi entity instance loaded if it's found or array of object {uuid: instance)} else null
///
/// possible value for parameter opt and instances  :
/// ```javascript
/// var opt = {
///    uuid : "uuid of the entity to get"
/// }
///
/// instances = { mongodb instance }
/// ```
///
/// or
///
/// ```javascript
/// var opt = {
///   uuid : ["uuid1","uuid2","uuid3"]
/// }
///
/// instances = [{ mongodb instance },...]
///
/// ```
///
/// or
///
/// ```javascript
/// var opt = {
///     filter : {
///         jsonWhere :  {
///             "id" : "value id",
///             "type" : "value type "
///         }
///     }
/// }
///
///
///
/// instances = [{ mongodb instance },...]
///
/// ```
///
exports.getEdiCacheEntity = _getEdiCacheEntity;

function _getEdiCacheEntity(_, opt) {
	ediEntityTracer.debug && ediEntityTracer.debug("_getEdiCacheEntity uuid = " + JSON.stringify(opt.uuid) + " custom db specified " + (opt.db !== null));
	try {
		if (opt.uuid) {
			if (Array.isArray(opt.uuid)) {
				var insts = [];
				opt.uuid.forEach_(_, function(_, item) {
					var filder = {
						"jsonWhere": {
							"$uuid": item
						}
					};
					ediEntityTracer.debug && ediEntityTracer.debug("filter " + JSON.stringify(filder));
					var ediSasInst = new ediClass(_, opt && opt.db).getInstance(_, filder);
					ediEntityTracer.debug && ediEntityTracer.debug("instance exists " + (ediSasInst !== null));

					if (ediSasInst) {
						insts.push(ediSasInst);
					} else {
						throw new Error(locale.format(module, "findUuid", item));
					}
				});

				return insts.length === 0 ? null : insts;
			} else {
				var filder = {
					"jsonWhere": {
						"$uuid": opt.uuid
					}
				};
				ediEntityTracer.debug && ediEntityTracer.debug("filter " + JSON.stringify(filder));
				var ediSasInst = new ediClass(_, opt && opt.db).getInstance(_, filder);
				ediEntityTracer.debug && ediEntityTracer.debug("instance exists " + (ediSasInst !== null));

				return ediSasInst;
			}
		} else if (opt.filter) {
			return new ediClass(_, opt && opt.db).getInstance(_, opt.filter);
		}
	} catch (e) {
		// log exception
		ediEntityTracer.error && ediEntityTracer.error(" message " + e.message + " stack " + e.stack);

		throw e;
	} finally {
		ediEntityTracer.info && ediEntityTracer.info("_getEdiCacheEntity done on " + ((opt.uuid && JSON.stringify(opt.uuid)) || (opt.filter && JSON.stringify(opt.filter))));
	}

};

/// ## var json = getEdiCacheJson(_,opt) :
/// This function allow to get the json of an entity or  of several entity identified by a uuid
///     opt : json object that contains the element to get the entity. this can contains a uuid, a list of uuid or a sdatafilter
///     json : the javascript object with as a key the uuid of the entity object and as a value the json object store in mongodb. Can be a single object or an array of object
///
/// ```javascript
/// var opt = {
///    uuid : "uuid of the entity to get"
/// }
///
/// json =  {"uuid" : {...} }
/// ```
///
/// or
///
/// ```javascript
/// var opt = {
///    uuid : ["uuid1","uuid2","uuid3"]
/// }
///
/// json = [{"uuid1":{...} , {"uuid2":{...} }, {"uuid3": {...}}]
///
///
/// var opt = {
///     filter : {
///         jsonWhere :  {
///             "id" : "value id",
///             "type" : "value type "
///         }
///     }
/// }
/// ```
///
exports.getEdiCacheJson = function(_, opt) {
	ediEntityTracer.debug && ediEntityTracer.debug("getEdiCacheJson uuid = " + JSON.stringify(opt.uuid) + " custom db specified " + (opt.db != null));
	try {
		if (opt.uuid) {
			if (Array.isArray(opt.uuid)) {
				var jsons = [];
				opt.uuid.forEach_(_, function(_, item) {
					var ediSasInst = new ediClass(_, opt && opt.db).getInstance(_, {
						"jsonWhere": {
							"$uuid": item
						}
					});
					if (ediSasInst) {
						var objItem = {};
						objItem[item] = ediSasInst.json(_);
						jsons.push(objItem);
					} else {
						throw new Error(locale.format(module, "findUuid", item));
					}
				});
				return jsons.length === 0 ? null : jsons;
			} else {
				var ediSasInst = new ediClass(_, opt && opt.db).getInstance(_, {
					"jsonWhere": {
						"$uuid": opt.uuid
					}
				});
				return ediSasInst && ediSasInst.json(_);
			}
		} else if (opt.filter) {
			var ediSasInst = new ediClass(_, opt && opt.db).getInstance(_, opt.filter);
			return ediSasInst && ediSasInst.json(_);
		}
		return null;
	} catch (e) {
		// log exception
		ediEntityTracer.error && ediEntityTracer.error(" message " + e.message + " stack " + e.stack);

		throw e;
	} finally {
		ediEntityTracer.debug && ediEntityTracer.debug("getEdiCacheJson done ");
	}
};



function _checkEDIVolume(_) {
	var db = adminHelper.getCollaborationOrm(_);
	var vols = db.db.collection("StorageVolume", _).find({
		code: "EDI"
	}).toArray(_);
	if (!vols || !vols.length) {
		// create std volume
		var vol = db.model.getEntity(_, "storageVolume").factory.createInstance(_, null, db);
		vol.code(_, "EDI");
		vol.description(_, {
			"default": "EDI storage volume",
			"en-US": "EDI storage volume",
			"fr-FR": "Volume EDI"
		});
		vol.storageType(_, "db_file");
		vol.save(_);
		//
	}
}

exports.getSADocument = function(_, name) {
	var list = [];
	sa.listDocuments(_, {
		sdataWhere: "description eq '" + name + "'"
	}).forEach_(_, function(_, doc) {
		var filter = {
			jsonWhere: {
				$uuid: doc.$uuid
			}
		};
		doc.properties = {
			description: name,
			content: {
				contentType: "application/text",
				fileName: doc.fileName(_),
			}
		};
		doc.dd = sa.open(_, filter);
		list.push(doc);
	});
};

exports.createSADocument = function(_, id, filename) {
	_checkEDIVolume(_); //create EDI volume
	var doc = {};
	doc.properties = {
		description: id,
		content: {
			contentType: "application/text",
			fileName: filename,
		}
	};
	doc.dd = sa.open(_, null, {
		volume: "EDI"
	});
	return doc;
};

exports.closeSADocument = function(_, documents) {
	documents && Object.keys(documents).forEach_(_, function(_, key) {
		sa.close(_, documents[key].doc.dd);
	});
};

exports.updateSADocument = function(_, d, encoding) {

	sa.write(_, d.doc.dd, d.doc.properties, new Buffer(d.output, encoding), true);

};

exports.removeSADocument = function(_, name) {
	var doc = sa.listDocuments(_, {
		sdataWhere: "description eq '" + name + "'"
	});
	doc.forEach_(_, function(_, d) {
		d.deleteSelf(_);
	});
};

/// ## updateEdiCacheEntity(_,opt) :
/// This function allow to update the json of an entity or  of several entity identified by a uuid
///     opt : json object that contains the element to get the entity. this can contains a uuid, a list of uuid or a sdatafilter
///
/// raise an exception if on the update failed.
///
/// ```javascript
/// var opt = {
///    elems : [{uuid : "uuid of the entity to update", json: {..json object to set ..} }, {..}, .. ],
///
///
/// }
/// ```
///
function _updateEdiCacheEntity(_, opt) {
	ediEntityTracer.debug && ediEntityTracer.debug("updateEdiCacheEntity elems = " + JSON.stringify(opt.elems) + " custom db specified " + (opt.db !== null));
	var instances;
	var changes = {};

	try {
		if (opt.elems) {
			// check if the elem exists for each uuid in mongodb
			opt.elems.forEach_(_, function(_, elem) {
				changes[elem.uuid] = elem.json;
			});
			instances = _getEdiCacheEntity(_, {
				uuid: Object.keys(changes),
				db: opt.db
			});
			if (!instances || instances.length !== Object.keys(changes).length) {
				ediEntityTracer.debug && ediEntityTracer.debug(" instance " + require('util').inspect(instances));
				ediEntityTracer.debug && ediEntityTracer.debug(" change " + JSON.stringify(Object.keys(changes)));

				throw new Error(locale.format(module, "findUuid", JSON.stringify(Object.keys(changes))));
			}
			instances.forEach_(_, function(_, instance) {
				instance.json(_, changes[instance.$uuid]);
				//instance.save(_);
			});
		}
	} catch (e) {
		// log exception
		ediEntityTracer.error && ediEntityTracer.error(" message " + e.message + " stack " + e.stack);

		throw e;
	} finally {
		instances && instances.forEach_(_, function(_, inst) {
			inst.save(_);
		});
		ediEntityTracer.info && ediEntityTracer.info("updateEdiCacheEntity done on " + Object.keys(changes));

	}
};
exports.updateEdiCacheEntity = _updateEdiCacheEntity;

/// ## removeEdiCacheEntity(_,opt) :
/// This function allow to remove the json of an entity or  of several entity identified by a uuid
///     opt : json object that contains the element to get the entity. this can contains a uuid, a list of uuid or a sdatafilter
///
/// ```javascript
/// var opt = {
///    uuid : "uuid of the entity to get"
/// }
///
/// ```
///
/// or
///
/// ```javascript
/// var opt = {
///    uuid : ["uuid1","uuid2","uuid3"]
/// }
///
/// var opt = {
///     filter : {
///         jsonWhere :  {
///             "id" : "value id",
///             "type" : "value type "
///         }
///     }
/// }
///
/// ```
///
exports.removeEdiCacheEntity = function(_, opt) {
	ediEntityTracer.debug && ediEntityTracer.debug("removeEdiCacheEntity uuid = " + JSON.stringify(opt.uuid) + " custom db specified " + (opt.db !== null));
	try {
		if (opt.uuid) {
			var arr = opt.uuid;
			if (!Array.isArray(arr)) {
				arr = [arr];
			}
			arr.forEach_(_, function(_, item) {
				new ediClass(_, opt && opt.db).deleteInstance(_, {
					"jsonWhere": {
						"$uuid": item
					}
				});
			});
		} else if (opt.filter) {
			new ediClass(_, opt && opt.db).deleteInstance(_, opt.filter);
		}
	} catch (e) {
		// log exception
		ediEntityTracer.error && ediEntityTracer.error(" message " + e.message + " stack " + e.stack);

		throw e;
	} finally {
		ediEntityTracer.info && ediEntityTracer.info("removeEdiCacheEntity done on =" + JSON.stringify(opt.uuid));
	}
};




exports.getPrefix = function(jsXsd, namespace) {
	var schemaPropName = null;
	var namespace = namespace ? namespace : "http://www.w3.org/2001/XMLSchema";
	for (var i = 0; i < Object.keys(jsXsd).length && !schemaPropName; i++) {
		if (Object.keys(jsXsd)[i].indexOf("schema") !== -1) {
			schemaPropName = Object.keys(jsXsd)[i];
		}
	}
	//console.log("schemaPropName "+schemaPropName);

	// check all name space declared
	var listAttr = jsXsd[schemaPropName].$ && Object.keys(jsXsd[schemaPropName].$);
	var prefix = "";

	for (var i = 0; i < listAttr.length && !prefix; i++) {
		var attr = listAttr[i];
		//console.log("attr "+JSON.stringify(jsXsd[schemaPropName].$[attr]));

		if (jsXsd[schemaPropName].$[attr] === namespace) {
			if (attr !== "targetNameSpace") {
				prefix = attr.substring(6);
				prefix = prefix ? prefix + ":" : prefix;
			}
		}
	}
	return prefix;
};

function _executeParseXsd(_, opt, jsXsds) {

	function _parseSimpleType(elems, mapSimpleType, prefix, listNameSpace) {
		if (elems && !Array.isArray(elems)) {
			elems = [elems];
		}
		var pref = prefix.replace(":", "");
		var namespace = listNameSpace["xmlns:" + pref];
		elems && elems.forEach(function(elem) {
			var simpleTypes = elem[prefix + "simpleType"];
			if (simpleTypes && !Array.isArray(simpleTypes)) {
				simpleTypes = [simpleTypes];
			}
			simpleTypes && simpleTypes.forEach(function(simpleType) {
				var restriction = simpleType[prefix + "restriction"];

				var enumeration = [];
				if (restriction && restriction[prefix + "enumeration"]) {
					if (Array.isArray(restriction[prefix + "enumeration"])) {
						restriction[prefix + "enumeration"].forEach(function(enume) {
							enumeration.push(enume.$.value);
						});
					} else {
						enumeration.push(restriction[prefix + "enumeration"].$.value);

					}
				}
				mapSimpleType[listNameSpace.target + ":" + simpleType.$.name] = {
					$simple: true,
					$name: simpleType.$.name,
					$type: restriction.$.base.replace(pref, namespace),
					$restriction: {
						base: restriction.$.base,
						minInclusive: restriction[prefix + "minInclusive"] && restriction[prefix + "minInclusive"].$.value,
						maxInclusive: restriction[prefix + "maxInclusive"] && restriction[prefix + "maxInclusive"].$.value,
						pattern: restriction[prefix + "pattern"] && restriction[prefix + "pattern"].$.value,
						whiteSpace: restriction[prefix + "whiteSpace"] && restriction[prefix + "whiteSpace"].$.value,
						length: restriction[prefix + "length"] && restriction[prefix + "length"].$.value,
						minLength: restriction[prefix + "minLength"] && restriction[prefix + "minLength"].$.value,
						maxLength: restriction[prefix + "maxLength"] && restriction[prefix + "maxLength"].$.value
					},
					$documentation: _parseDocumentation(prefix, simpleType)

				};
				if (enumeration.length) {
					mapSimpleType[listNameSpace.target + ":" + simpleType.$.name].$restriction.enumeration = enumeration;
				}
			});

		});
	}

	function _parseDocumentation(prefix, elem) {
		var documentation = {};
		if (elem[prefix + "annotation"] && elem[prefix + "annotation"][prefix + "documentation"]) { // add documentation
			var docs = elem[prefix + "annotation"][prefix + "documentation"];
			if (docs && !Array.isArray(docs)) {
				docs = [docs];
			}
			docs && docs.forEach(function(doc) {
				documentation[doc.$["xml:lang"]] = doc.$value;
			});
		}
		return documentation;
	}

	function _parseComplexType(name, elemComplexType, map, prefix, listNameSpace) {
		function _addElem(elems, listNameSpace, name, map, choiceItem) {
			if (elems && !Array.isArray(elems)) {
				elems = [elems];
			}
			elems && elems.forEach(function(elem) {
				//console.log("elem "+JSON.stringify(elem));
				var type;
				if (elem.$.ref) {
					// get the right
					var pref = elem.$.ref.substring(0, elem.$.ref.indexOf(":"));
					type = elem.$.ref.replace(pref, listNameSpace["xmlns:" + pref]);
					if (!mapType[type]) {
						mapType[type] = {
							$name: elem.$.ref.substring(elem.$.ref.indexOf(":"))
						};
					}

				} else {

					type = listNameSpace.target + ":" + name;
					var splitType = elem.$.type && elem.$.type.indexOf(":") !== -1 ? elem.$.type.split(':') : null;
					map[type] = map[type] || {};
					map[type][elem.$.name] = {
						$name: elem.$.name,
						$type: splitType && listNameSpace["xmlns:" + splitType[0]] ? listNameSpace["xmlns:" + splitType[0]] + ":" + splitType[1] : (splitType && splitType.length ? elem.$.type : listNameSpace.target + ":" + (elem.$.type || elem.$.name)),
						$maxOccurs: elem.$.maxOccurs,
						$minOccurs: elem.$.minOccurs,
						$documentation: _parseDocumentation(prefix, elem)
					};
					map[type].$name = name;
					map[type].$type = type;
					if (choiceItem) {
						map[type].$choice = type + "-" + choiceItem; // set the choice item to identify all element in the same choice
					}
					map[type].$complex = true;

					_parseComplexTypeInElem(elem, map, prefix, listNameSpace);
				}

			});
		}




		var atts = elemComplexType[prefix + "attribute"] && elemComplexType[prefix + "attribute"];
		if (atts && !Array.isArray(atts)) {
			atts = [atts];
		}
		atts && atts.forEach(function(elem) {
			var type = listNameSpace.target + ":" + name;

			map[type] = map[type] || {};
			var splitType = elem.$.type && elem.$.type.indexOf(":") !== -1 ? elem.$.type.split(':') : null;

			map[type][elem.$.name] = {
				$name: elem.$.name,
				$type: splitType && listNameSpace["xmlns:" + splitType[0]] ? listNameSpace["xmlns:" + splitType[0]] + ":" + splitType[1] : (splitType && splitType.length ? elem.$.type : listNameSpace.target + ":" + (elem.$.type ||  elem.$.ref)),
				$leafAttribute: true
			};
			map[type].$complex = true;
			map[type].$name = name;

		});
		var base = elemComplexType[prefix + "sequence"] || elemComplexType[prefix + "all"];
		var elems = base && base[prefix + "element"];
		var choices = base && base[prefix + "choice"];
		// if complexe containt complexCnotent we just have to
		var complexContent = elemComplexType && elemComplexType[prefix + "complexContent"];
		if (elems)
			_addElem(elems, listNameSpace, name, map);

		if (complexContent) {
			// manage xtension only today
			if (complexContent[prefix + "extension"]) {
				_addElem({
					$: {
						name: name,
						type: complexContent[prefix + "extension"].$.base
					}
				}, listNameSpace, name, map);
			}
		}

		if (choices && !Array.isArray(choices)) {
			choices = [choices];
		}
		choices && choices.forEach(function(choice, i) {
			var elems = choice[prefix + "element"];
			//console.log("elem "+JSON.stringify(elem));
			_addElem(elems, listNameSpace, name, map, i);


		});

	}
	// return if we have treated a complextype
	function _parseComplexTypeInElem(jsXsd, mapComplexType, prefix, listNameSpace) {
		var elements = jsXsd;
		if (elements && !Array.isArray(elements)) {
			elements = [elements];
		}
		elements && elements.forEach(function(element) {
			var firstComplexType = element[prefix + "complexType"];
			if (firstComplexType) { // treat the first complex type and manage all sons
				_parseComplexType(element.$.name, firstComplexType, mapComplexType, prefix, listNameSpace);
			}
		});

	}

	function _parseElementsRoot(elems, mapComplexeType, prefix, listNameSpace) {
		if (elems && !Array.isArray(elems)) {
			elems = [elems];
		}
		elems && elems.forEach(function(elem) {
			var splitType = elem.$.type && elem.$.type.indexOf(":") !== -1 ? elem.$.type.split(':') : null;
			var type = splitType && listNameSpace["xmlns:" + splitType[0]] ? listNameSpace["xmlns:" + splitType[0]] + ":" + splitType[1] : (splitType && splitType.length ? elem.$.type : listNameSpace.target + ":" + (elem.$.type ||  elem.$.name));
			mapComplexeType[listNameSpace.target + ":" + elem.$.name] = mapComplexeType[listNameSpace.target + ":" + elem.$.name] || {};

			mapComplexeType[listNameSpace.target + ":" + elem.$.name].$name = elem.$.name;
			mapComplexeType[listNameSpace.target + ":" + elem.$.name].$type = type;

			if (mapComplexeType[type])
				mapComplexeType[type].$name = elem.$.name; // put the real for the root complexType
			mapComplexeType["root"] = mapComplexeType["root"] ||  [];
			mapComplexeType["root"].push(listNameSpace.target + ":" + elem.$.name);
		});
	}

	/*
     construct and dump to a mongodb file the list of xml path using the map that describe types
     This browser the tree of type and in the same time construct a map of father to dump all path. (conversion from recursive to iteratif implem in order to prevent stackOverFlow on big volume)
     */
	function _constructList(_, map, el, dd, opt, prefixLeaf, firstWrite) {


		function isLeafElement() {

			return map[elem.$type] == null;
			/*
			 var found = false;
			 for (var i = 0; i < prefixLeaf.length && !found; i++) {
				found = (elem.$type && (elem.$type.substring(0, 3) === prefixLeaf[i] || (mapType[elem.$type] && mapType[elem.$type].$type && mapType[elem.$type].$type.substring(0, 3) === prefixLeaf[i])))
			}
			return found;*/
		}

		var hasWritten = !firstWrite;
		var stack = [{
			map: map,
			elem: el,
		}];
		var list = {};
		var treated = [];

		//console.log("list father " + JSON.stringify(list, null, 2));

		while (stack.length) {
			//console.log("list father " + JSON.stringify(list, null, 2));

			var item = stack.pop();
			var mapType = item.map;
			var elem = item.elem;
			var father = item.father;
			var name = item.name;
			var namespace = item.namespace;
			var card = null;
			if (item.minOccurs && item.minOccurs !== '0' ||  item.maxOccurs) {
				card = "[" + (item.minOccurs ||  "0") + (item.maxOccurs ? ".." + (item.maxOccurs === "unbounded" ? "n" : item.maxOccurs) : "") + "]";
			}
			//console.log("elem " + JSON.stringify(list, null, 2));


			if (elem) {
				if (elem && elem.$leafAttribute) { // we stop on the element that describe the attribute
					//console.log("$leafAttribute " + JSON.stringify(elem));

					if (list[father] && list[father].elems && list[father].elems.length) {
						list[father].elems.forEach_(_, function(_, itm) {
							var att = {
								path: itm.path + ".$." + elem.$name,
								type: mapType[elem.$type] && mapType[elem.$type].$restriction.base || elem.$type,
								restriction: mapType[elem.$type] && mapType[elem.$type].$restriction,
								documentation: itm.$documentation
							};

							// remove namespace for the path stored that will be send to the 4GL
							if (att.type.indexOf(":") !== -1) {
								att.type = att.type.substring(7);
								att.namespace = namespace
								att.type = att.type.substring(att.type.indexOf(":") + 1);
							}
							ediEntityTracer.debug && ediEntityTracer.debug("dump path " + att.path);

							sa.write(_, dd, {
								description: opt.id,
								content: {
									contentType: "plain/text",
									fileName: opt.id,
								}
							}, (!hasWritten ? "" : "\n") + JSON.stringify(att), "utf8", true);
							hasWritten = true;
						});
					}

				} else if (elem && isLeafElement()) { // its  a simple type or a link to a simple type
					//console.log("$leafElement " + JSON.stringify(elem));

					if (list[father] && list[father].elems && list[father].elems.length) {
						//onsole.log('list father ',list[father]);
						list[father].elems.forEach_(_, function(_, itm) {
							var element = {
								path: itm.path + "." + (name ||  elem.$name),
								type: mapType[elem.$type] && mapType[elem.$type].$restriction.base || elem.$type,
								restriction: mapType[elem.$type] && mapType[elem.$type].$restriction,
								documentation: itm.$documentation
							};
							ediEntityTracer.debug && ediEntityTracer.debug("dump path " + element.path);
							// remove namespace for the path stored that will be send to the 4GL

							if (element.type.indexOf(":") !== -1) {
								element.type = element.type.substring(7);
								element.namespace = namespace
								element.type = element.type.substring(element.type.indexOf(":") + 1);
							}
							sa.write(_, dd, {
								description: opt.id,
								content: {
									contentType: "plain/text",
									fileName: opt.id,
								}
							}, (!hasWritten ? "" : "\n") + JSON.stringify(element), "utf8", true);
							hasWritten = true;

						});
					}
				} else if (elem && elem.$complex) { // it's a complex type
					//console.log("complex " + JSON.stringify(elem, null, 2));
					//console.log("father " + JSON.stringify(father, null, 2));
					var fatherKey;
					if (!father) { // create the list of the father for the first element
						fatherKey = elem.$name;

						list[fatherKey] = list[fatherKey] || {
							elems: [],
							nbsons: 0
						};

						list[fatherKey].elems.push({
							path: elem.$name + (card ? card : "")
						});
					} else {
						fatherKey = father + "." + name;

						list[father].elems.forEach(function(itemFather) {
							//console.log("itemFather " + JSON.stringify(elem));
							list[fatherKey] = list[fatherKey] || {
								elems: [],
								nbsons: 0
							};
							list[fatherKey].elems.push({
								path: itemFather.path + "." + (name || elem.$name) + (card ? card : "")
							});
						});

					}
					ediEntityTracer.debug && ediEntityTracer.debug("father key treated " + fatherKey + " current " + elem.$name);
					var nb = 0;
					var namesp = elem.$type && elem.$type.substring(0, elem.$type.substring(7).indexOf(":") + 7);
					Object.keys(elem) && Object.keys(elem).forEach(function(itm) {
						if (["$complex", "$name", "$type", "$maxOccurs", "$minOccurs", "$choice"].indexOf(itm) === -1) {
							ediEntityTracer.debug && ediEntityTracer.debug("item treated", itm);
							stack.push({
								father: fatherKey,
								map: mapType,
								namespace: namespace || namesp !== "default" ? namesp : "",
								elem: mapType[itm] || elem[itm],
								maxOccurs: elem[itm].$maxOccurs,
								minOccurs: elem[itm].$minOccurs

							});
							nb++;
						}
					});
					list[fatherKey].nbsons = nb;
					ediEntityTracer.debug && ediEntityTracer.debug("finish treatement father key " + fatherKey + " current " + elem.$name);

					//console.log("list son "+JSON.stringify(list,null,2));

					// define that the current son is treated
					if (list[father]) {
						//console.log("nb of sons "+list[father].nbsons);
						list[father].nbsons--;
						if (!list[father].nbsons) // no more son so we delete the father context
							delete list[father];
					}
					//treated.push(elem.$name);
				} else { // case indirection to a complexe type decribe in another xsd element
					ediEntityTracer.debug && ediEntityTracer.debug("indirection xsd type get next element " + elem.$name);
					if (elem.$type) {
						stack.push({
							father: father,
							map: mapType,
							elem: mapType[elem.$type] || mapType[elem.$type.substring(0, 3)],
							namespace: namespace,
							name: elem.$name,
							maxOccurs: item.maxOccurs,
							minOccurs: item.minOccurs
						});
					}
					//return elem && elem.$type && constructList(mapType, mapType[elem.$type]);
				}
			}
		}
		return hasWritten;
	}


	var mapType = {};

	// retrieve list of complexe contain in the xsd

	if (!jsXsds) {
		return null;
	}

	if (!Array.isArray(jsXsds)) {
		jsXsds = [jsXsds];
	}

	var prefixLeaf = [];
	jsXsds && jsXsds.forEach(function(jsXsd) {
		var prefix = exports.getPrefix(jsXsd);
		prefixLeaf.push(prefix);
		/*var xmldsig = exports.getPrefix(jsXsd,"http://www.w3.org/2000/09/xmldsig#");
		if( xmldsig ) prefixLeaf.push(xmldsig);
*/
		// create list of name define in the schema
		var listNameSapce = {};
		jsXsd[prefix + "schema"].$ && Object.keys(jsXsd[prefix + "schema"].$).forEach(function(item) {
			if (item !== "http://www.w3.org/2001/XMLSchema" && item.indexOf("xmlns=") === -1) {
				listNameSapce[item] = jsXsd[prefix + "schema"].$[item];
			}
		});
		listNameSapce.target = jsXsd[prefix + "schema"].$.targetNamespace ||  jsXsd[prefix + "schema"].$.xmlns || "default";

		var listComplexType = jsXsd[prefix + "schema"][prefix + "complexType"];
		if (listComplexType) { // case of complexType describe in the root of the schema
			if (!Array.isArray(listComplexType)) {
				listComplexType = [listComplexType];
			}
			listComplexType.forEach(function(complexType) {
				_parseComplexType(complexType.$.name, complexType, mapType, prefix, listNameSapce);
			});
		}
		_parseComplexTypeInElem(jsXsd[prefix + "schema"][prefix + "element"], mapType, prefix, listNameSapce);

		_parseSimpleType(jsXsd[prefix + "schema"], mapType, prefix, listNameSapce);

		_parseElementsRoot(jsXsd[prefix + "schema"][prefix + "element"], mapType, prefix, listNameSapce);

	});

	var listXmlPath = [];
	var i = 0;
	mapType.root && mapType.root.forEach(function(rootElem) { // generate for each root element the list of possibilities
		listXmlPath[rootElem] = rootElem;
	});

	_checkEDIVolume(_);
	var ddXml = sa.open(_, null, {
		volume: 'EDI'
	});
	var firstWrite = true;
	//console.log("mapType ",mapType);
	mapType.root && mapType.root.forEach_(_, function(_, root) {
		firstWrite = !_constructList(_, mapType, mapType[root], ddXml, opt, prefixLeaf, firstWrite);
	});
	var document = sa.close(_, ddXml, true);
	return document.$uuid;


}

exports.executeParseXsd = _executeParseXsd;