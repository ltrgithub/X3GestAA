"use strict";

var helpers = require('syracuse-core/lib/helpers');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var Sadfsq = require("syracuse-x3/lib/clients/sadfsq/sadfsqClient").SadFsqClient;
var parser = require("./parse/parser");
var serializer = require("./parse/serializer");
var datetime = require("syracuse-core/lib/types/datetime");

var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var configEdi = config.edi;
var trace = configEdi && configEdi.cache && configEdi.cache.trace;
var EDIClass = require('./helpers').EDIClass;
var PROTOCOL = require('./enumType').PROTOCOL;
var LIB_ENCODING = require('./enumType').LIB_ENCODING;

var EdiEntity = require("./EdiEntity");
var sa = require("syracuse-orm/lib/storageArea");

/*
 * cache the running process. if it already exists, we override the information
 */
function _createEdiProcess(_, opt) {
	var klass = new EDIClass(_, opt && opt.db, 'ediProcess');
	var ediCache = klass.getInstance(_, {
		"sdataWhere": "idProcess eq '" + opt.idProcess + "'"
	});
	if (!ediCache) {
		ediCache = klass.createInstance(_);
	}
	ediCache.idProcess(_, opt.idProcess);

	ediCache.folder(_, opt.folder); // set the folder to allow the entity to get the endpoint link before setting idMessageMapping etc.. that need the endpoint
	ediCache.x3RepName(_, opt.repName);

	// if messageMapping sequentialFile and protocol are directly passe as a object, it's not necessary to get it from cache
	if (typeof opt.messageMapping === "object") {
		ediCache.messageMapping(_, opt.messageMapping);
	} else {
		ediCache.idMessageMapping(_, opt.messageMapping);
	}
	if (typeof opt.messageMapping === "object") {
		ediCache.sequentialFile(_, opt.sequentialFile);
	} else {
		ediCache.idSequentialFile(_, opt.sequentialFile);
	}
	if (typeof opt.messageMapping === "object") {
		ediCache.protocol(_, opt.protocol);
	} else {
		ediCache.idProtocol(_, opt.protocol);
	}
	if (typeof opt.flow === "object") {
		ediCache._flow(_, opt.flow);
	} else {
		ediCache.idFlow(_, opt.flow);
	}
	var timeout = (configEdi.process && configEdi.process.timeout) ? configEdi.process.timeout : 3600000;
	var stampExpiration = (new Date().getTime()) + timeout;
	ediCache.expiration(_, datetime.fromJsDate(new Date(stampExpiration)));

	ediCache.save();

	if (opt.endpoint) // define another endpoint instead of take the one association to the folder (especially for offline unit test)
		ediCache.endPoint(_, opt.endpoint);

	return ediCache;
}


function _getEdiProcess(_, opt) {
	var ediCache = new EDIClass(_, opt && opt.db, "ediProcess").getInstance(_, {
		"sdataWhere": "idProcess eq '" + opt.idProcess + "'"
	});
	ediCache && ediCache.endPoint(_, adminHelper.getEndpoint(_, {
		dataset: ediCache.folder(_)
	}));
	return ediCache;

}

function _removeEdiProcess(_, opt) {
	return new EDIClass(_, opt && opt.db, "ediProcess").deleteInstance(_, {
		"sdataWhere": "idProcess eq '" + opt.idProcess + "'"
	});
}

function _removeAllEdiProcess(_, opt) {
	return new EDIClass(_, opt && opt.db, "ediProcess").dropAllInstance(_);
}


// for unit test
exports.createEdiProcess = _createEdiProcess;
exports.getEdiProcess = _getEdiProcess;
exports.removeEdiProcess = _removeEdiProcess;
exports.removeAllEdiProcess = _removeAllEdiProcess;

exports.$exported = true;

// retrieve EDI process context in X3 (manage with cache mechanism to prevent to generate always the data

function _getEndpoint(_, protocol, ep, opt) {
	var endpoint;
	if (protocol && protocol.folder) {
		endpoint = adminHelper.getEndpoint(_, {
			dataset: protocol.folder // take the folder define in the protocol or folder by default sent by x3
		});
	} else {
		endpoint = ep;
	}
	//hack
	var user = opt && opt.sadfsq && opt.sadfsq.user;
	var pass = opt && opt.sadfsq && opt.sadfsq.password;
	return endpoint;
}

function _getSadFsq(_, endpoint, opt) {
	// hack
	var user = opt && opt.sadfsq && opt.sadfsq.user;
	var pass = opt && opt.sadfsq && opt.sadfsq.password;

	return new Sadfsq(_, endpoint.x3server(_).serverHost(_), endpoint.x3server(_).serverPort(_), user, pass, true, (opt.sadfsq && opt.sadfsq.recOptions) || {});

}

function _writeIssueFiles(_, protocol, ep, files, opt) {

	var sadFsq = _getSadFsq(_, _getEndpoint(_, protocol, ep, opt), opt);
	files && Object.keys(files).forEach_(_, function(_, filename) {
		var items = protocol && protocol.EPTEPTD && protocol.EPTEPTD.filter(function(item) {
			return item && item.EPT_EPTD_PTCLINCOD === "DIRISSUE";
		});
		sadFsq.writeFile(_, {
				"path": (opt.path || items && items[0].EPT_EPTD_PTCLINVAL) + "/" + filename
			},
			files[filename], {
				flag: "w",
				encoding: opt.encoding
			}
		);
	});



}


function _getReceiptFiles(_, protocol, seqFile, ep, opt) {
	function _checkPatternFileName(name, sf) {
		var exists = false;
		for (var i = 0; i < sf.ESFESFD.length && !exists; i++) { // se base sur le tableau qui decrit la liste des fichiers //TODO check pattern
			var item = sf.ESFESFD[i].FILNAM;
			exists = (item && name.indexOf(item) !== -1); // TODO check pattern
		}
		return exists;
	}
	var sadFsq = _getSadFsq(_, _getEndpoint(_, protocol, ep, opt), opt);

	// find the RECEIPT dir
	var items = protocol.EPTEPTD && protocol.EPTEPTD.filter(function(item) {
		return item.EPT_EPTD_PTCLINCOD === "DIRRECEIPT";
	});
	var path = items && items[0].EPT_EPTD_PTCLINVAL;
	var listFile = sadFsq.readdir(_, {
		path: path
	});
	var fileBuff = {};
	for (var i = 0; i < listFile.length; i++) {
		if (_checkPatternFileName(listFile[i], seqFile)) {
			fileBuff[listFile[i].substring(0, listFile[i].lastIndexOf("."))] = sadFsq.readFile(_, {
				path: path + "/" + listFile[i]
			}, {
				flag: "r",
				encoding: "utf-8"
			});
		}
	}
	return fileBuff;
}

exports.getReceiptFiles = _getReceiptFiles; // for unit test
exports.writeIssueFiles = _writeIssueFiles; // for unit test

/// !doc
/// ## var uuid = decodeEdiFiles(_,idProcess, opt) :
/// This function decode the edi partnet data and store in mongodb the json object corresponding to the data to load in a syraucse instance.
/// idProcess : the edi process identifiant defined in x3
/// opt : json object that provide all the needed element to let the syracuse server to retrieve his context and process the decoding
/// uuid : the uuid of the edi entity that contain the json object store.
///
/// ```javascript
/// var option = {
///    messageMapping : "uuid", //id of messageMapping
///    sequentialFile : "uuid", // id of sequentialFile
///    protocol : "uuid", // id of flow
///    flow : "uuid", // id of protocol
///    repName : "EDISIH1", // id fo the x3 class
///    folder : "GX3APP"
/// };
///
/// or
///
/// var option = {
///    messageMapping : {...}, //a Json object that represent the messageMapping
///    sequentialFile : {...}, //a Json object that represent the sequential File
///    flow : {...}, // json of the flow
///    protocol : {...}, //a Json object that represent the protocol
///    prototype : {...}, // json that represent the prototype of the representation
///    repName : "EDISIH1", // id fo the x3 class
///    folder : "GX3APP"
/// };
///
/// ```
///
exports.decodeEdiFiles = function(_, idProcess, opt) {

	opt.sadfsq.user = opt.sadfsq.user || (config.edi && config.edi.user);
	opt.sadfsq.password = opt.sadfsq.password || (config.edi && config.edi.password);
	// store in the cache the context (env) received
	var cachedEdi = _getEdiProcess(_, {
		idProcess: idProcess,
		db: opt.db
	});
	if (!cachedEdi) {
		opt.idProcess = idProcess;
		cachedEdi = _createEdiProcess(_, opt);
	}
	// read files
	var protocol = cachedEdi.protocol(_);
	var seqFile = cachedEdi.sequentialFile(_);
	var input;
	//if (protocol && protocol.PTCTYP === PROTOCOL.directory) {
	input = _getReceiptFiles(_, protocol, seqFile, cachedEdi.endPoint(_), opt);
	//}
	var option = opt;
	option.input = input;
	option.process = cachedEdi;
	var mapJson = parser.parse(_, option); // generat a map of json with id of the instance in key

	// return array of uuid and id of each document
	// [{uuid : "uuid", id :"id"}, {...}]
	var result = [];
	Object.keys(mapJson).forEach_(_, function(_, key) {
		var uuid = EdiEntity.createEdiCacheEntity(_, {
			type: idProcess,
			id: key,
			json: mapJson[key],
			db: opt.db
		});
		result.push({
			uuid: uuid,
			id: key
		});
	});
	return result;

};


function _generateFiles(_, idProcess, opt) {
	opt.sadfsq.user = opt.sadfsq.user || (config.edi && config.edi.user);
	opt.sadfsq.password = opt.sadfsq.password || (config.edi && config.edi.password);
	// store in the cache the context (env) received
	var document = _getSADocument(_, idProcess);
	var cachedEdi = _getEdiProcess(_, {
		idProcess: idProcess,
		db: opt.db
	});
	if (!cachedEdi) {
		opt.idProcess = idProcess;
		cachedEdi = _createEdiProcess(_, opt);
	}
	var protocol = cachedEdi.protocol(_);


	if (!document || !document.length) {
		document = [];
		// read files
		var option = opt;
		option.process = cachedEdi;
		option.json = EdiEntity.getEdiCacheJson(_, opt);

		var res = serializer.serialize(_, option);
		var encodingContext = opt.action === "edi" ? cachedEdi.sequentialFile(_) : cachedEdi.messageMapping(_);
		opt.encoding = opt.encoding || LIB_ENCODING[encodingContext.CODBRA];
		var fileNames = Object.keys(res);

		// store file content in store area temporary
		for (var i = 0; i < fileNames.length; i++) {
			var filename = fileNames[i];
			document.push(_createSADocument(_, idProcess, filename + "." + encodingContext.EXT, new Buffer(res[filename], opt.encoding)));
		}
	} else {
		// create res expected to write in directory the saved file
		var res = {};
		document.forEach_(_, function(_, doc) {
			res[doc.fileName(_)] = sa.readAll(_, {
				jsonWhere: {
					$uuid: doc.$uuid
				}
			}); // keep it in binary (buffer) this will be dectected in sadFsq api and it will be directly store without create a new buffer

		});
	}

	//if (protocol && protocol.PTCTYP === PROTOCOL.directory) {
	_writeIssueFiles(_, protocol, cachedEdi.endPoint(_), res, opt);
	//}
	// delete document if no error occurs during write issue file
	document.forEach_(_, function(_, doc) {
		doc.deleteSelf(_);
	});

	return res && Object.keys(res);
}

/// ## var uuid = generateEdiFiles(_,idProcess, opt) :
/// This function generate the edi partnet data regarding stored in mongodb the json object corresponding to syraucse instance.
/// idProcess : the edi process identifiant defined in x3
/// opt : json object that provide all the needed element to let the syracuse server to retrieve his context in order to process the generation
/// uuid : the uuid of the edi entity that contain the json object store.
///
/// ```javascript
/// var opt = {
///    messageMapping : "uuid", //id of messageMapping
///    sequentialFile : "uuid", // id of sequentialFile
///    protocol : "uuid", // id of protocol
///    flow : "uuid", // id of flow
///    prototype : {...}, // json that represent the prototype of the representation
///    repName : "EDISIH1", // id fo the x3 representation used for generation
///    folder : "GX3APP",
///    uuidJson :  ["uuid of the json file generate that representaiton the representation",..],
///    encoding : "utf8"
/// }
///
/// or
///
/// var opt = {
///    messageMapping : {...}, //a Json object that represent the messageMapping
///    sequentialFile : {...}, //a Json object that represent the sequential File
///    protocol : {...}, //a Json object that represent the protocol
///    flow : {..}, //a Json object that represent the protocol
///    prototype : {...}, // json that represent the prototype of the representation
///    folder : "GX3APP",
///    uuidJson :  ["uuid of the json file generate that representaiton the representation",...],
///    encoding : "utf8"
/// }
///
/// ```
///
exports.generateEdiFiles = function(_, idProcess, opt) {
	opt.action = "edi";
	// override encoding of it's defined in the context
	return _generateFiles(_, idProcess, opt);
};

/// ## var uuid = generateImportFiles(_,idProcess, opt) :
/// This function generate the import file regarding  stored in mongodb the json object corresponding to syraucse instance.
/// idProcess : the edi process identifiant defined in x3
/// opt : json object that provide all the needed element to let the syracuse server to retrieve his context in order to process the generation
/// uuid : the uuid of the edi entity that contain the json object store.
///
/// ```javascript
/// var opt = {
///    messageMapping : "uuid", //id of messageMapping
///    sequentialFile : "uuid", // id of sequentialFile
///    flow : "uuid", //a Json object that represent the protocol
///    protocol : "test", // id of protocol
///    repName : "EDISIH1", // id of the representation
///    folder : "GX3APP",
///    uuidJson :  ["uuid of the json file generate that representaiton the representation",...],
///    encoding : "utf8",
///    path : "path where the import has to be create
/// }
///
/// or
///
/// var opt = {
///    messageMapping : {...}, //a Json object that represent the messageMapping
///    sequentialFile : {...}, //a Json object that represent the sequential File
///    protocol : {...}, //a Json object that represent the protocol
///    prototype : {...}, // json that represent the prototype of the representation
///    flow : {..}, //a Json object that represent the protocol
///    folder : "GX3APP",
///    uuidJson :  ["uuid of the json file generate that representaiton the representation",...],
///    encoding : "utf8",
///    path : "path where the import has to be create
/// }
///
/// ```
///
exports.generateImportFiles = function(_, idProcess, opt) {
	opt.action = "import";
	return _generateFiles(_, idProcess, opt);

	// TODO return path of the file in folder ?
};

function _createSADocument(_, name, filename, buff) {
	return sa.writeAll(_, {
		description: name,
		content: {
			contentType: "application/text",
			fileName: filename,
		}
	}, buff, null, "EDI");
}

function _removeSADocument(_, name) {
	var doc = sa.listDocuments(_, {
		sdataWhere: "description eq '" + name + "'"
	});
	doc.forEach_(_, function(_, d) {
		d.deleteSelf(_);
	});
}

function _getSADocument(_, name) {
	return sa.listDocuments(_, {
		sdataWhere: "description eq '" + name + "'"
	});
}