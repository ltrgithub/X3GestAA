"use strict";

var helpers = require('syracuse-core/lib/helpers');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var Sadfsq = require("syracuse-x3/lib/clients/sadfsq/sadfsqClient").SadFsqClient;
var parser = require("./parse/parser");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var trace = config.edi && config.edi.cache && config.edi.cache.trace;
var EDIClass = require('./helpers').EDIClass;
var PROTOCOL = require('./enumType').PROTOCOL;


/*
 * cache the running process. if it already exists, we override the information
 */
function _createEdiProcess(_, idProcess, opt) {
	var klass = new EDIClass(_, 'ediProcess');
	var ediCache = klass.getInstance(_, {
		"sdataWhere": "idProcess eq '" + idProcess + "'"
	});
	if (!ediCache) {
		ediCache = klass.createInstance(_);
	}
	ediCache.idProcess(_, idProcess);
	ediCache.idMessageMapping(_, opt.messageMapping);
	ediCache.idSequentialFile(_, opt.sequentialFile);
	ediCache.idEdiFlow(_, opt.ediFlow);
	ediCache.idProtocol(_, opt.protocol);

	ediCache.save();

	return ediCache;
}


function _getEdiProcess(_, idProcess) {
	return new EDIClass(_, "ediProcess").getInstance(_, {
		"sdataWhere": "idProcess eq '" + idProcess + "'"
	});
}

function _removeEdiProcess(_, idProcess) {
	return new EDIClass(_, "ediProcess").deleteInstance(_, {
		"sdataWhere": "idProcess eq '" + idProcess + "'"
	});
}


// for unit test
exports.createEdiProcess = _createEdiProcess;
exports.getEdiProcess = _getEdiProcess;
exports.removeEdiProcess = _removeEdiProcess;

// retrieve EDI process context in X3 (manage with cache mechanism to prevent to generate always the data


/// ## var rep = decodeFiles(_,idProcess,env) :
///    not implemented

function _getReceiptFiles(_, protocol, seqFile, opt) {
	function _checkPatternFileName(name, sf) {
		var exists = false;
		for (var i = 0; i < sf.ESFESFD.length && !exists; i++) {
			var item = sf.ESFESFD[i];
			exists = (item && name.indexOf(item) !== -1);
		}
		return exists;
	}
	var fileOptions = {
		folder: protocol.folder,
		path: protocol.RECEIPT.EPTP_EPTD_PTCLINVAL
	};
	var endpoint = adminHelper.getEndpoint(_, {
		dataset: protocol.folder
	});
	// hack
	var user = config.edi.user;
	var pass = config.edi.password;

	var recordsOption = (opt.sadfsq && opt.sadfsq.recordOptions) || {};
	var sadFsq = new Sadfsq(_, endpoint.x3server(_).serverHost(_), endpoint.x3server(_).serverPort(_), user, pass, true, recordsOption);
	var listFile = sadFsq.readdir(_, fileOptions);
	var fileBuff = [];
	for (var i = 0; i < listFile.length; i++) {
		if (_checkPatternFileName(listFile[i], seqFile)) {
			options.name = listFile[i];
			fileBuff[listFile[i]] = sadFsq.readFile(_, options, "r");
		}
	}
	return fileBuff;
}

exports.getReceiptFiles = _getReceiptFiles; // for unit test

exports.decodeFiles = function(_, idProcess, opt) {

	//throw new Error("not implemented");

	// store in the cache the context (env) received
	var cachedEdi = _getEdiProcess(_, idProcess);
	if (!cachedEdi) {
		cachedEdi = _createEdiProcess(_, idProcess, opt);
	}
	// read files
	var protocol = cachedEdi.protocol(_);
	var seqFile = cachedEdi.sequentialFile(_);
	var input;
	if (protocol && protocol.PTCTYP === PROTOCOL.directory) {
		input = _getReceiptFiles(_, protocol, seqFile, opt);
		// store json generate in mongodb
	}
	var res = {};
	parser.parse(_, input, cachedEdi, res);

};

/// ## var listFilesId = generateFiles(_,idProcess,env) :
/// not implemented
exports.generateFiles = function(_, idProcess, env) {
	throw new Error("not implemented");
};