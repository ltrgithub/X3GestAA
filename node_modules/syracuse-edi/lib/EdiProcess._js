"use strict";

var helpers = require('syracuse-core/lib/helpers');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var Sadfsq = require("syracuse-x3/lib/clients/sadfsq/sadfsqClient").SadFsqClient;
var parser = require("./parse/parser");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var trace = config.edi && config.edi.cache && config.edi.cache.trace;
var EDIClass = require('./helpers').EDIClass;
var PROTOCOL = require('./enumType').PROTOCOL;


/*
 * cache the running process. if it already exists, we override the information
 */
function _createEdiProcess(_, idProcess, opt) {
	var klass = new EDIClass(_, 'ediProcess');
	var ediCache = klass.getInstance(_, {
		"sdataWhere": "idProcess eq '" + idProcess + "'"
	});
	if (!ediCache) {
		ediCache = klass.createInstance(_);
	}
	ediCache.idProcess(_, idProcess);
	ediCache.idMessageMapping(_, opt.messageMapping);
	ediCache.idSequentialFile(_, opt.sequentialFile);
	ediCache.idEdiFlow(_, opt.ediFlow);
	ediCache.idProtocol(_, opt.protocol);

	ediCache.save();

	return ediCache;
}


function _getEdiProcess(_, idProcess) {
	return new EDIClass(_, "ediProcess").getInstance(_, {
		"sdataWhere": "idProcess eq '" + idProcess + "'"
	});
}

function _removeEdiProcess(_, idProcess) {
	return new EDIClass(_, "ediProcess").deleteInstance(_, {
		"sdataWhere": "idProcess eq '" + idProcess + "'"
	});
}


// for unit test
exports.createEdiProcess = _createEdiProcess;
exports.getEdiProcess = _getEdiProcess;
exports.removeEdiProcess = _removeEdiProcess;

// retrieve EDI process context in X3 (manage with cache mechanism to prevent to generate always the data



function _getReceiptFiles(_, protocol, seqFile, opt) {
	function _checkPatternFileName(name, sf) {
		var exists = false;
		for (var i = 0; i < sf.ESFESFD.length && !exists; i++) {
			var item = sf.ESFESFD[i].FILNAM;
			exists = (item && name.indexOf(item) !== -1);
		}
		return exists;
	}
	var fileOptions = {
		path: protocol.RECEIPT.EPTP_EPTD_PTCLINVAL
	};
	var endpoint = adminHelper.getEndpoint(_, {
		dataset: protocol.folder
	});
	// hack
	var user = config.edi.user;
	var pass = config.edi.password;

	var recordsOption = (opt.sadfsq && opt.sadfsq.recOptions) || {};
	var sadFsq = new Sadfsq(_, endpoint.x3server(_).serverHost(_), endpoint.x3server(_).serverPort(_), user, pass, true, recordsOption);
	var listFile = sadFsq.readdir(_, fileOptions);
	var fileBuff = {};
	for (var i = 0; i < listFile.length; i++) {
		if (_checkPatternFileName(listFile[i], seqFile)) {
			fileBuff[listFile[i]] = sadFsq.readFile(_, {
				path: fileOptions.path + "/" + listFile[i]
			}, {
				flag: "r"
			});
		}
	}
	return fileBuff;
}

exports.getReceiptFiles = _getReceiptFiles; // for unit test

/// ## var uuid = decodeFiles(_,idProcess, opt) :
///   NB :  not implemented
/// This function decode the edi partnet data and store in mongodb the json object corresponding to the data to load in a syraucse instance.
///     idProcess : the edi process identifiant defined in x3
///     opt : json object that provide all the needed element to let the syracuse server to retrieve his context and process the decoding
///     uuid : the uuid of the edi entity that contain the json object store.
///
/// ```javascript
/// var opt = {
///    protocol : "id of the protocol object",
///    sequentialFile : "id of the sequential file",
///    messageMapping : "id of the messageMapping",
///    ediFlow : "id of the ediFlow"
/// }
///
/// ```
///
exports.decodeFiles = function(_, idProcess, opt) {

	//throw new Error("not implemented");

	// store in the cache the context (env) received
	var cachedEdi = _getEdiProcess(_, idProcess);
	if (!cachedEdi) {
		cachedEdi = _createEdiProcess(_, idProcess, opt);
	}
	// read files
	var protocol = cachedEdi.protocol(_);
	var seqFile = cachedEdi.sequentialFile(_);
	var input;
	if (protocol && protocol.PTCTYP === PROTOCOL.directory) {
		input = _getReceiptFiles(_, protocol, seqFile, opt);
		// store json generate in mongodb
	}
	var res = {};
	parser.parse(_, input, cachedEdi, res);

};

/// ## var uuid = generateFiles(_,idProcess, opt) :
/// This function generate the edi partnet data regarding  stored in mongodb the json object corresponding to syraucse instance.
///     idProcess : the edi process identifiant defined in x3
///     opt : json object that provide all the needed element to let the syracuse server to retrieve his context and process the decoding
///     uuid : the uuid of the edi entity that contain the json object store.
///
/// ```javascript
/// var opt = {
///    protocol : "id of the protocol object",
///    sequentialFile : "id of the sequential file",
///    messageMapping : "id of the messageMapping",
///    ediFlow : "id of the ediFlow"
/// }
///
/// ```
///
exports.generateFiles = function(_, idProcess, opt) {
	throw new Error("not implemented");
};