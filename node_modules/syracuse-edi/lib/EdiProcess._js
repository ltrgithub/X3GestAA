"use strict";

var helpers = require('syracuse-core/lib/helpers');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var Sadfsq = require("syracuse-x3/lib/clients/sadfsq/sadfsqClient").SadFsqClient;
var parser = require("./parse/parser");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var trace = config.edi && config.edi.cache && config.edi.cache.trace;
var EDIClass = require('./helpers').EDIClass;
var PROTOCOL = require('./enumType').PROTOCOL;
var EdiEntity = require("./EdiEntity");

/*
 * cache the running process. if it already exists, we override the information
 */
function _createEdiProcess(_, opt) {
	var klass = new EDIClass(_, opt && opt.db, 'ediProcess');
	var ediCache = klass.getInstance(_, {
		"sdataWhere": "idProcess eq '" + opt.idProcess + "'"
	});
	if (!ediCache) {
		ediCache = klass.createInstance(_);
	}
	ediCache.idProcess(_, opt.idProcess);
	ediCache.x3ClassName(_, opt.className);
	ediCache.idMessageMapping(_, opt.messageMapping);
	ediCache.idSequentialFile(_, opt.sequentialFile);
	ediCache.idEdiFlow(_, opt.ediFlow);
	ediCache.idProtocol(_, opt.protocol);
	ediCache.folder(_, opt.folder); // take the folder define in the protocol or folder by default sent by x3

	ediCache.save();
	ediCache.endPoint(_, adminHelper.getEndpoint(_, {
		dataset: opt.folder
	}));
	return ediCache;
}


function _getEdiProcess(_, opt) {
	var ediCache = new EDIClass(_, opt && opt.db, "ediProcess").getInstance(_, {
		"sdataWhere": "idProcess eq '" + opt.idProcess + "'"
	});
	ediCache && ediCache.endPoint(_, adminHelper.getEndpoint(_, {
		dataset: ediCache.folder(_)
	}));
	return ediCache;

}

function _removeEdiProcess(_, opt) {
	return new EDIClass(_, opt && opt.db, "ediProcess").deleteInstance(_, {
		"sdataWhere": "idProcess eq '" + opt.idProcess + "'"
	});
}

function _removeAllEdiProcess(_, opt) {
	return new EDIClass(_, opt && opt.db, "ediProcess").dropAllInstance(_);
}


// for unit test
exports.createEdiProcess = _createEdiProcess;
exports.getEdiProcess = _getEdiProcess;
exports.removeEdiProcess = _removeEdiProcess;
exports.removeAllEdiProcess = _removeAllEdiProcess;

// retrieve EDI process context in X3 (manage with cache mechanism to prevent to generate always the data



function _getReceiptFiles(_, protocol, seqFile, ep, opt) {
	function _checkPatternFileName(name, sf) {
		var exists = false;
		for (var i = 0; i < sf.ESFESFD.length && !exists; i++) {
			var item = sf.ESFESFD[i].FILNAM;
			exists = (item && name.indexOf(item) !== -1);
		}
		return exists;
	}
	var fileOptions = {
		path: protocol.RECEIPT.EPTP_EPTD_PTCLINVAL
	};
	var endpoint;
	if (protocol.folder) {
		endpoint = adminHelper.getEndpoint(_, {
			dataset: protocol.folder // take the folder define in the protocol or folder by default sent by x3
		});
	} else {
		endpoint = ep;
	}
	// hack
	var user = opt && opt.sadfsq && opt.sadfsq.user;
	var pass = opt && opt.sadfsq && opt.sadfsq.password;

	var recordsOption = (opt.sadfsq && opt.sadfsq.recOptions) || {};


	var sadFsq = new Sadfsq(_, endpoint.x3server(_).serverHost(_), endpoint.x3server(_).serverPort(_), user, pass, true, recordsOption);
	var listFile = sadFsq.readdir(_, fileOptions);
	var fileBuff = {};
	for (var i = 0; i < listFile.length; i++) {
		if (_checkPatternFileName(listFile[i], seqFile)) {
			fileBuff[listFile[i].substring(0, listFile[i].lastIndexOf("."))] = sadFsq.readFile(_, {
				path: fileOptions.path + "/" + listFile[i]
			}, {
				flag: "r",
				encoding: "utf-8"
			});
		}
	}
	return fileBuff;
}

exports.getReceiptFiles = _getReceiptFiles; // for unit test


/// ## var uuid = decodeFiles(_,idProcess, opt) :
/// This function decode the edi partnet data and store in mongodb the json object corresponding to the data to load in a syraucse instance.
///     idProcess : the edi process identifiant defined in x3
///     opt : json object that provide all the needed element to let the syracuse server to retrieve his context and process the decoding
///     uuid : the uuid of the edi entity that contain the json object store.
///
/// ```javascript
/// var option = {
///    messageMapping : "test", //id of messageMapping
///    sequentialFile : "test", // id of sequentialFile
///    protocol : "test", // id of protocol
///    className : "EDISIH1", // id fo the x3 class
///    folder : "GX3APP"
/// };
///
/// ```
///
exports.decodeFiles = function(_, idProcess, opt) {

	opt.sadfsq.user = opt.sadfsq.user || (config.edi && config.edi.user);
	opt.sadfsq.password = opt.sadfsq.password || (config.edi && config.edi.password);
	// store in the cache the context (env) received
	var cachedEdi = _getEdiProcess(_, {
		idProcess: idProcess,
		db: opt.db
	});
	if (!cachedEdi) {
		opt.idProcess = idProcess;
		cachedEdi = _createEdiProcess(_, opt);
	}
	// read files
	var protocol = cachedEdi.protocol(_);
	var seqFile = cachedEdi.sequentialFile(_);
	var input;
	var ep = cachedEdi.endPoint(_);
	if (protocol && protocol.PTCTYP === PROTOCOL.directory) {
		input = _getReceiptFiles(_, protocol, seqFile, ep, opt);
		// store json generate in mongodb
	}
	var option = opt;
	option.input = input;
	option.process = cachedEdi;
	option.endpoint = ep;
	var res = parser.parse(_, option);

	// store this result in the sas and return the uuid
	return EdiEntity.createEdiCacheEntity(_, {
		type: "sas",
		id: opt.id,
		jsons: res,
		db: opt.db
	});

};

/// ## var uuid = generateFiles(_,idProcess, opt) :
/// This function generate the edi partnet data regarding  stored in mongodb the json object corresponding to syraucse instance.
///     idProcess : the edi process identifiant defined in x3
///     opt : json object that provide all the needed element to let the syracuse server to retrieve his context and process the decoding
///     uuid : the uuid of the edi entity that contain the json object store.
///
/// ```javascript
/// var opt = {
///    protocol : "id of the protocol object",
///    sequentialFile : "id of the sequential file",
///    messageMapping : "id of the messageMapping",
///    ediFlow : "id of the ediFlow"
/// }
///
/// ```
///
exports.generateFiles = function(_, idProcess, opt) {
	throw new Error("not implemented");
};