"use strict";

var helpers = require('syracuse-core/lib/helpers');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var Sadfsq = require("syracuse-x3/lib/clients/sadfsq/sadfsqClient").SadFsqClient;
var parser = require("./parse/parser");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var trace = config.edi && config.edi.cache && config.edi.cache.trace;

var EDIClass = helpers.defineClass(function(_, entityName) {
	trace && trace("create Class EDI " + entityName);

	// getting the administration ORM
	this.db = adminHelper.getCollaborationOrm(_);
	// the metamodel is associated to the orm
	this.model = this.db.model;
	this.entityName = entityName || "ediCache";
	this.entity = this.model.getEntity(_, this.entityName);
	this.factory = this.entity.factory;
}, null, {
	getInstance: function(_, filter) {
		trace && trace("get instance filter=[" + filter && JSON.stringify(filter) + "]");

		var ent;
		if (filter != null && filter.length !== 0) {
			// fetchInstance(callback, entity, filter)
			ent = this.db.fetchInstance(_, this.entity, filter);
		} else {
			// create a new object, createInstance params are : (callback, initialDataJson, ormInstance)
			ent = this.factory.createInstance(_, null, this.db);
		}
		return ent;
	},
	getInstances: function(_, filter) {
		trace && trace("get instances filter=[" + filter && JSON.stringify(filter) + "]");

		var ent;
		if (filter != null && filter.length !== 0) {
			// fetchInstance(callback, entity, filter)
			ent = this.db.fetchInstances(_, this.entity, filter);
		}
		return ent;
	},
	createInstance: function(_) {
		trace && trace("create instance ");

		// create a new object, createInstance params are : (callback, initialDataJson, ormInstance)
		return this.factory.createInstance(_, null, this.db);
	},
	deleteInstance: function(_, filter) {
		trace && trace("delete instances filter=[" + filter && JSON.stringify(filter) + "]");

		var inst = this.getInstance(_, filter);
		inst && inst.deleteSelf();
	}
});

/*
 * cache the running process. if it already exists, we override the information
 */
function _createEdiProcess(_, idProcess, opt) {
	var klass = new EDIClass(_, 'ediProcess');
	var ediCache = klass.getInstance(_, {
		"sdataWhere": "idProcess eq '" + idProcess + "'"
	});
	if (!ediCache) {
		ediCache = klass.createInstance(_);
	}
	ediCache.idProcess(_, idProcess);
	ediCache.idMessageMapping(_, opt.messageMapping);
	ediCache.idSequentialFile(_, opt.sequentialFile);
	ediCache.idEdiFlow(_, opt.ediFlow);
	ediCache.idProtocol(_, opt.protocol);

	ediCache.save();

	return ediCache;
}


function _getEdiProcess(_, idProcess) {
	return new EDIClass(_, "ediProcess").getInstance(_, {
		"sdataWhere": "idProcess eq '" + idProcess + "'"
	});
}

function _removeEdiProcess(_, idProcess) {
	return new EDIClass(_, "ediProcess").deleteInstance(_, {
		"sdataWhere": "idProcess eq '" + idProcess + "'"
	});
}


// for unit test
exports.createEdiProcess = _createEdiProcess;
exports.getEdiProcess = _getEdiProcess;
exports.removeEdiProcess = _removeEdiProcess;

// retrieve EDI process context in X3 (manage with cache mechanism to prevent to generate always the data


/// ## var rep = decodeFiles(_,idProcess,env) :
///    not implemented

exports.decodeFiles = function(_, idProcess, opt) {
	throw new Error("not implemented");

	// store in the cache the context (env) received
	var cachedEdi = _getEdiProcess(_, idProcess);
	if (!cacheEdi) {
		cachedEdi = _createEdiProcess(_, idProcess, opt);
	}
	// read files
	var protocol = cachedEdi.getProtocol(_);
	if (protocol && protocol.isDirectory) {
		var fileOptions = {
			folder: opt.protocol.folder,
			path: opt.protocol.path
		};
		var endpoint = adminHelper.getEndpoint(_, {
			dataset: protocol.folder
		});
		var user = config.edi.user;
		var pass = config.edi.password;
		var sadFsq = new Sadfsq(_, endpoint.x3server.serverHost(_), endpoint.x3server.serverPort(_), user, pass, true, opt.sadfsq.recordOptions);
		var listFile = sadFsq.readdir(_, fileOptions);
		var fileBuff = [];
		for (var i = 0; i < listFile.length; i++) {
			options.name = listFile[i];
			fileBuff[listFile[i]] = sadFsq.readFile(_, options, "r");
		}

		parser.parse(_, fileBuff, opt);

		// store json generate in mongodb

	}

};

/// ## var listFilesId = generateFiles(_,idProcess,env) :
/// not implemented
exports.generateFiles = function(_, idProcess, env) {
	throw new Error("not implemented");
};


function _createEdiEntity(_, opt) {
	// check if json is a string that represent a json object
	if (opt && typeof opt.jsons !== "object") {
		throw new Error("can't store a non json object");
	}

	var ediCache = new EDIClass(_, opt.entity).createInstance(_);
	if (opt.etag) {
		ediCache.etag(_, opt.etag);
	}
	ediCache.type(_, opt.type); // sas, message mappign etc..
	ediCache.json(_, opt.jsons); // all entity has cache
	ediCache.save();
	return ediCache;
}
/// ## var uuids = createEdiEntity(_,opt) :

exports.createEdiCacheEntity = function(_, opt) {
	if (Array.isArray(opt.jsons)) {
		var uuids = [];
		var objs = [];
		opt.jsons.forEach_(_, function(_, item) {
			var optItem = {
				jsons: item,
				type: opt.type
			};
			if (opt.etag)
				optItem.etag = opt.etag;
			var obj = _createEdiEntity(_, optItem);
			objs.push(obj);
			uuids.push(obj.$uuid);
		});
		return uuids.length === 0 ? null : uuids;
	} else {
		return _createEdiEntity(_, opt).$uuid;
	}
};

exports.getEdiEntity = function(_, opt) {
	// TODO check if the cached entity in mongodb is up to date and update it by call x3 with etag management
	return getEdiCacheEntity(_, opt);
};
exports.getEdiJson = function(_, opt) {
	// TODO check if the cached entity in mongodb is up to date and update it by call x3 with etag management
	return getEdiCacheJson(_, opt);

};

/// ## var instances = getEdiEntity(_,opt) :

exports.getEdiCacheEntity = function(_, opt) {
	if (opt.uuid) {
		if (Array.isArray(opt.uuid)) {
			var jsons = [];
			opt.uuid.forEach_(_, function(_, item) {
				var ediSasInst = new EDIClass(_).getInstance(_, {
					"jsonWhere": {
						"$uuid": item
					}
				});
				if (ediSasInst) {
					var objItem = {};
					objItem[item] = ediSasInst;
					jsons.push(objItem);
				}
			});
			return jsons.length === 0 ? null : jsons;
		} else {
			var ediSasInst = new EDIClass(_).getInstance(_, {
				"jsonWhere": {
					"$uuid": opt.uuid
				}
			});
			return ediSasInst;
		}
	} else if (!opt.filter) {
		return EDIClass(_).getInstances(_, opt.filter);
	}
};

/// ## var jsons = getEdiJson(_,opt) :

exports.getEdiCacheJson = function(_, opt) {
	if (opt.uuid) {
		if (Array.isArray(opt.uuid)) {
			var jsons = [];
			opt.uuid.forEach_(_, function(_, item) {
				var ediSasInst = new EDIClass(_).getInstance(_, {
					"jsonWhere": {
						"$uuid": item
					}
				});
				if (ediSasInst) {
					var objItem = {};
					objItem[item] = ediSasInst.json(_);
					jsons.push(objItem);
				}
			});
			return jsons.length === 0 ? null : jsons;
		} else {
			var ediSasInst = new EDIClass(_).getInstance(_, {
				"jsonWhere": {
					"$uuid": opt.uuid
				}
			});
			return ediSasInst && ediSasInst.json(_);
		}
	} else if (!opt.filter) {
		return EDIClass(_).getInstances(_, opt.filter);
	}
};

/// ##  removeEdiEntity(_,uuids) :

exports.removeEdiCacheEntity = function(_, uuids) {
	var arr = uuids;
	if (!Array.isArray(uuids)) {
		arr = [arr];
	}
	arr.forEach_(_, function(_, item) {
		new EDIClass(_).deleteInstance(_, {
			"jsonWhere": {
				"$uuid": item
			}
		});
	});
};