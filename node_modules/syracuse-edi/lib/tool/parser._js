"use strict";
var config = require('config'); // must be first syracuse require
var trace = config.edi && config.edi.parser && config.edi.parser.trace;
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var parseHelp = require('syracuse-edi/lib/tool/helpers');
var decimal = require('syracuse-core').types.decimal;
var datetime = require('syracuse-core').types.datetime;
var log = require('syracuse-core').getTracer("edi.parser");
var locale = require('streamline-locale');
var jsxml = require('js-xml');
/**
 * Created by apisu on 01/07/2014.
 * parse of the edi file to a json structure regarding a specific context
 */


///
/// ### function parse that create a json file from Edi sequential file(s)
///  parse(_,buff,ediCached[,json])
///     filesBuff : buffer of the files read in string or binary
///     ediCached : contains all element for generation
exports.parse = function(_, opt) {
	log.info && log.info("parse ");

	var input = opt.input;
	var json = opt.json;

	if (!Object.keys(opt.prototype).length) {
		throw new Error(locale.format(module, "noPrototype", opt.repName));
	}
	log.debug && log.debug("parser used " + opt.configParser.parser);

	// sort the imput in order to process the parsing in the order from root to leaf
	/*var sortInput = {};
	 Object.keys(opt.configParser.linkKey).forEach(function(filenamePattern) { // TODO manage generation without order consideration
	 // looking for the right file
	 var found = null;
	 var regexp = new RegExp(filenamePattern);

	 });*/

	if (_mapParse[opt.configParser.parser]) {
		return _mapParse[opt.configParser.parser](input, opt.configParser, opt.prototype, json);
	} else {
		throw new Error(locale.format(module, "findParser", opt.configParser.parser));
	}

};

function getPrimaryKey(jsonInstance, item, config) {
	// retrieve the instance and compute the key

	var primarykey = "";
	config.linkKey && config.linkKey[item.fileName] && config.linkKey[item.fileName].primary && config.linkKey[item.fileName].primary.split("+").forEach(function(elemKey) {
		var jsIsnt = jsonInstance;

		if (elemKey.indexOf(".") !== -1) {
			elemKey.split(".").forEach(function(key) {
				if (Array.isArray(jsIsnt) && jsIsnt.length === 1) {
					jsIsnt = jsIsnt[0];
				}
				jsIsnt = jsIsnt && jsIsnt[key];
			});
		} else {
			jsIsnt = jsIsnt[elemKey];
		}
		if (jsIsnt)
			primarykey += jsIsnt;
		else {
			log.warn && log.warn("can't compute primary key : property " + elemKey + " no in the jsonInstance parsed");
		}
	});
	log.debug && log.debug("primary key " + primarykey);

	return primarykey;

}

function getForeignKey(jsonInstance, item, config) {
	// retrieve the instance and compute the key

	var foreignKey = "";
	config.linkKey && config.linkKey[item.fileName] && config.linkKey[item.fileName].foreign && config.linkKey[item.fileName].foreign.split("+").forEach(function(elemKey) {
		var jsIsnt = jsonInstance;

		if (elemKey.indexOf(".") !== -1) {
			elemKey.split(".").forEach(function(key) {
				if (Array.isArray(jsIsnt) && jsIsnt.length === 1) {
					jsIsnt = jsIsnt[0];
				}
				jsIsnt = jsIsnt && jsIsnt[key];
			});
		} else {
			jsIsnt = jsIsnt[elemKey];
		}
		if (jsIsnt)
			foreignKey += jsIsnt;
		else {
			log.warn && log.warn("can't compute primary key : property " + elemKey + " no in the jsonInstance parsed");
		}
	});
	log.debug && log.debug("foreign key " + foreignKey);

	return foreignKey;
}

function getSubProperty(prefixExp, prototype, configParser) {
	var propertySubPref;
	if (prefixExp && prefixExp.indexOf(".") !== -1) {
		var current = prototype.$properties ? prototype.$properties : prototype;
		prefixExp.split(".").slice(0, -1).forEach(function(elem) {
			current = parseHelp.getProperty(current, elem);
		});
		propertySubPref = current;
	} else {
		propertySubPref = prototype;
	}
	propertySubPref.$instanceUrl = prototype.$instanceUrl;
	return propertySubPref;
}

function pushJson(configParser, lastItem, res, mapJson, jsonInstance) {

	function mergeJSON(source1, source2) {
		var mergedJSON = source2 || {};
		for (var attrname in source1) {
			if (mergedJSON.hasOwnProperty(attrname)) {
				if (source1[attrname] != null) {
					if (source1[attrname].constructor == Object) {

						mergedJSON[attrname] = mergeJSON(source1[attrname], mergedJSON[attrname]);
					} else if (Array.isArray(source1[attrname])) {
						source1[attrname].forEach(function(item) {
							mergedJSON[attrname].push(item);
						});
					}
				}
			} else { //else copy the property from source1
				mergedJSON[attrname] = source1[attrname];

			}
		}
		return mergedJSON;
	}

	//var prefixExp = configParser.exppressionPrefix[lastItem.fileName];
	var primarykey = getPrimaryKey(jsonInstance, lastItem, configParser);
	var ext_primarykey = lastItem.fileId + "_" + primarykey;
	mapJson[ext_primarykey] = jsonInstance;
	if (configParser.linkKey[lastItem.fileName].fatherFileId) {
		var foreignkey = configParser.linkKey[lastItem.fileName].fatherFileId + "_" + getForeignKey(jsonInstance, lastItem, configParser);

		// find the right subproperty to associate father and son
		if (foreignkey) {
			if (mapJson[foreignkey]) {
				// merge current instance with mapJson foreignKey
				mapJson[foreignkey] = mergeJSON(jsonInstance, mapJson[foreignkey]);
			}
		}
	} else {
		mapJson[primarykey] = mergeJSON(jsonInstance, mapJson[primarykey]);
		res[primarykey] = jsonInstance;
	}
	return res;
}


var _mapParse = {


	xml: function(input, configParser, prototype, json) {

		log.info && log.info("------------------");

		log.info && log.info("parse Xml");

		var mapJson = json || {};
		var jsonInstance = {};

		// construct map protoPath, xml path regarding setup received from X3


		// for each file we parse the xml
		Object.keys(input).forEach(function(filename) {
			log.debug && log.debug("file parsed " + filename);
			var jsFile = input[filename] && jsxml.parse(input[filename]);

			function _analyseChild(jsFile, mapXmlPathValue, path, stack) {
				for (var i = 0; i < Object.keys(jsFile).length; i++) {
					var current = Object.keys(jsFile)[i];
					stack.push({
						jsxml: jsFile[current],
						path: path + "." + current + "[" + i + "]"
					});
				}
			}

			var mapXmlPathValue = {};
			var stack = [{
				jsxml: jsFile,
			}];

			while (stack.length) {
				var current = stack.pop();
				var jsFile = current.jsxml;
				var path = current.path || Â "";
				if (!Object.keys(jsFile).length) { // it's a leaf
					mapXmlPathValue[path] = jsFile;
					// TODO check the prototype path that correspond to the xml and add the value in the jsonIntance
				} else {
					if (Array.isArray(jsFile)) {
						for (var i = 0; i < jsFile.length; i++) {
							_analyseChild(jsFile, mapXmlPathValue, path + "[" + i + "]", stack);
						}
					} else {
						_analyseChild(jsFile, mapXmlPathValue, path, stack);
					}
				}
			}
		});
		log.debug && log.debug("json " + JSON.stringify(mapXmlPathValue));

		return mapJson;
	},

	sepRecord: function(input, configParser, prototype, json) {

		log.info && log.info("------------------");

		log.info && log.info("parse sepRecord");

		var mapJson = json || {};
		var jsonInstance = {};

		var res;

		log.debug && log.debug("json " + JSON.stringify(json));
		Object.keys(input).forEach(function(filename) {
			//nb of readed character
			log.debug && log.debug("file parsed " + filename);

			var records = input[filename];
			if (records.indexOf(configParser.sepRecord)) {
				records = records.split(configParser.sepRecord);
			} else {
				records = [records];
			}
			if (records) {

				records.forEach(function(record) {
					var recFlag = record.split(configParser.sepField).slice(0, 1)[0];

					var recValues = record.split(configParser.sepField).slice(1);
					log.debug && log.debug("records fields " + JSON.stringify(recValues));
					recValues.filter(function(prev, cur) {
						var regexp = new RegExp(configParser.elems[cur].fileName);
						if (regexp && regexp.test(filename)) {
							// check if the id of the line if present for that elem to filer it or not
							var idElem = configParser.elems[cur].idLineElem;
							if (idElem && Object.keys(idElem).length) { // if idelem exists and idLine correspond we have t take it else false
								return records.substring(idElem.offset, idElem.offset + idElem.length) === idElem.idLine;
							} else { // if no idElem continue in the same way by just checking the fileName
								return true;
							}
						}
						return false;
					}).forEach(function(item, idx, arr) {
						if (idx < recValues.length) {
							log.debug && log.debug("process item " + item.expression);

							var propertyName = item.expression;

							// extract the value
							var val = recValues[idx];


							if (val) {
								_addToJsonObject(propertyName, jsonInstance, prototype, item, val, configParser);
							} else if (item.isMandatory) {
								throw new Error(locale.format(module, "mandatoryField", propertyName, (prototype && prototype.$representation)));
							}
							if (idx == arr.length - 1 && Object.keys(jsonInstance).length) { // last element treated
								res = pushJson(configParser, item, res, mapJson, jsonInstance);
								jsonInstance = {};
							}
						}
					});
					//console.log(JSON.stringify(jsonToGen, null, 2));
				});
			} else {
				throw new Error(locale.format(module, "fileEmpty"));
			}
		});
		return mapJson;
	},
	sepField: function(input, configParser, prototype, json) {
		log.info && log.info("------------------");

		log.info && log.info("parse sepRecord");

		var mapJson = json || {};
		var jsonInstance = {};

		var res;
		log.debug && log.debug("json " + JSON.stringify(json));
		Object.keys(input).forEach(function(filename) {
			//nb of readed character
			log.debug && log.debug("file parsed " + filename);

			var records = input[filename];

			var recFlag = records.split(configParser.sepField).slice(0, 1)[0];

			var recValues = records.split(configParser.sepField).slice(1);
			log.debug && log.debug("records fields " + JSON.stringify(recValues));
			configParser.elems.filter(function(prev, cur) {
				var regexp = new RegExp(configParser.elems[cur].fileName);
				if (regexp && regexp.test(filename)) {
					// check if the id of the line if present for that elem to filer it or not
					var idElem = configParser.elems[cur].idLineElem;
					if (idElem && Object.keys(idElem).length) { // if idelem exists and idLine correspond we have t take it else false
						return records.substring(idElem.offset, idElem.offset + idElem.length) === idElem.idLine;
					} else { // if no idElem continue in the same way by just checking the fileName
						return true;
					}
				}
				return false;
			}).forEach(function(item, idx, arr) {
				if (idx < recValues.length) {
					log.debug && log.debug("process item " + item.expression);

					var prefixExp = configParser.exppressionPrefix[item.fileName];

					var propertyName = item.expression.indexOf(configParser.exppressionPrefix[item.fileName]) === 0 ? item.expression.substring(configParser.exppressionPrefix[item.fileName].length) : item.expression;
					var propertySubPref = getSubProperty(prefixExp, prototype, configParser);

					// extract the value
					var val = recValues[idx];


					if (val) {
						_addToJsonObject(propertyName, jsonInstance, propertySubPref, item, val, configParser);
					} else if (item.isMandatory) {
						throw new Error(locale.format(module, "mandatoryField", propertyName, (prototype && prototype.$representation)));
					}
					if (idx == arr.length - 1 && Object.keys(jsonInstance).length) { // last element treated
						res = pushJson(configParser, item, res, mapJson, jsonInstance);
						jsonInstance = {};
					}
				}
			});

			//console.log(JSON.stringify(jsonToGen, null, 2));

		});
		return res;
	},
	delimited: function(input, configParser, prototype, json) {
		log.info && log.info("------------------");

		log.info && log.info("parse delimited");

		var mapJson = json || {};
		var jsonInstance = {};

		var res = {};
		log.debug && log.debug("json " + JSON.stringify(json));
		Object.keys(input).forEach(function(filename) {
			//nb of readed character
			log.debug && log.debug("file parsed " + filename);

			var records = input[filename];
			if (records.indexOf(configParser.sepRecord)) {
				records = records.split(configParser.sepRecord);
			} else {
				records = [records];
			}
			if (records) {

				records.forEach(function(record) {
					/*var recFlag = record.split(configParser.sepField).slice(0, 1)[0];
					 if (recFlag.charAt(0) === configParser.delimField && recFlag.charAt(recFlag.length - 1) === configParser.delimField) {
					 recFlag = recFlag.slice(1, recFlag.length - 1);

					 } else {
					 throw new Error(locale.format(module, "recDelim", recFlag));
					 }*/
					var recValues = record.split(configParser.sepField);
					log.debug && log.debug("records fields " + JSON.stringify(recValues));
					configParser.elems.filter(function(prev, cur) {
						var regexp = new RegExp(configParser.elems[cur].fileName);
						if (regexp && regexp.test(filename)) {
							// check if the id of the line if present for that elem to filer it or not
							var idElem = configParser.elems[cur].idLineElem;
							if (idElem) { // if idelem exists and idLine correspond we have t take it else false
								return recValues[0] === idElem.idLine;
							} else { // if no idElem continue in the same way by just checking the fileName
								return true;
							}
							return true;

						}
						return false;
					}).forEach(function(item, idx, arr) {
						if (idx < recValues.length) {
							log.debug && log.debug("process item " + item.expression);

							// remove prefix if exists and start w
							var prefixExp = configParser.exppressionPrefix[item.fileName];

							var propertyName = item.expression.indexOf(configParser.exppressionPrefix[item.fileName]) === 0 ? item.expression.substring(configParser.exppressionPrefix[item.fileName].length) : item.expression;
							var propertySubPref = getSubProperty(prefixExp, prototype, configParser);
							// extract the value
							var val = recValues[idx];


							if (val && val.charAt(0) === configParser.delimField && val.charAt(val.length - 1) === configParser.delimField) {
								val = val.slice(1, val.length - 1);
							} else {
								throw new Error(locale.format(module, "fieldDelim", val));
							}
							if (val) {
								// TODO set prototype that correspond to the level in order to create the json instance
								_addToJsonObject(propertyName, jsonInstance, propertySubPref, item, val, configParser);
							} else if (item.isMandatory) {
								throw new Error(locale.format(module, "mandatoryField", propertyName, (prototype && prototype.$representation)));
							}
						}
						if (idx == arr.length - 1 && Object.keys(jsonInstance).length) { // last element treated
							res = pushJson(configParser, item, mapJson, jsonInstance);
							jsonInstance = {};

						}

					});
					//console.log(JSON.stringify(jsonToGen, null, 2));
				});
			} else {
				throw new Error(locale.format(module, "fileEmpty"));
			}
		});
		return res;
	},
	fixedLength: function(input, configParser, prototype, json) {
		log.info && log.info("------------------");

		log.info && log.info("parse fixed length");

		var res = {};
		var mapJson = json || {};
		var jsonInstance = {};


		log.debug && log.debug("json " + JSON.stringify(json) + " input " + input.length);
		var lastItem;

		Object.keys(input).forEach(function(filename) {
			//nb of readed character
			log.debug && log.debug("file parsed " + filename);

			var lines = input[filename];
			if (lines && lines.indexOf("\n")) {
				lines = lines.split('\n');
			} else {
				lines = [lines];
			}
			lines && lines.forEach(function(line) {

				configParser.elems.filter(function(prev, cur) {
					if (configParser.elems[cur]) {
						var regexp = new RegExp(configParser.elems[cur].fileName);

						if (regexp && regexp.test(filename)) {
							// check if the id of the line if present for that elem to filer it or not
							var idElem = configParser.elems[cur].idLineElem;

							if (idElem) { // if idelem exists and idLine correspond we have t take it else false
								return line.substring(0, idElem.length) === idElem;
							} else { // if no idElem continue in the same way by just checking the fileName
								return true;
							}
						}

					}
					return false;
				}).forEach(function(item, idx, arr) {
					lastItem = item;
					log.debug && log.debug("process item " + item.expression);
					if (item.isStart && Object.keys(jsonInstance).length) { // merge for each new record
						res = pushJson(configParser, item, res, mapJson, jsonInstance);
						log.debug && log.debug("object instance " + JSON.stringify(jsonInstance));

						jsonInstance = {};
					}

					var realLoc = item.offset;
					var prefixExp = configParser.exppressionPrefix[item.fileName];
					var propertyName = prefixExp.indexOf(".") && item.expression.indexOf(prefixExp) === 0 ? item.expression.substring(prefixExp.lastIndexOf(".") + 1) : item.expression;

					var propertySubPref = getSubProperty(prefixExp, prototype, configParser);


					if (realLoc < line.replace(/\r|\n/g, "").length) {

						// extract the value
						var val = parseHelp.removeSpace(line.substring(realLoc, realLoc + item.length).replace("/\n|\r/g", ""));
						log.debug && log.debug("process item value " + val);

						if (val) {
							_addToJsonObject(propertyName, jsonInstance, propertySubPref, item, val, configParser);
						} else if (item.isMandatory) {
							throw new Error(locale.format(module, "mandatoryField", propertyName, (prototype && prototype.$representation)));
						}
					}

				});
				//console.log(JSON.stringify(jsonToGen, null, 2));
			});
			// last merge
			if (Object.keys(jsonInstance).length)
				res = pushJson(configParser, lastItem, res, mapJson, jsonInstance);

		});

		return res;
	}
};

exports.mapParse = _mapParse;

/*
 *  this function allow to return the object where we have to assign the property receive from the parsing with the value
 *   parameter :
 *      key : key that is defined to sequential File that indicate the property name of the x3 instance
 *      jsonRoot : the json root object to generate. it's an empty object at the begininng
 *      prototype :  the prototype of the classe that we want to create at the end of the process. This allow to know the type of each property
 *   return  :
 *      {
 *          key : key of the property in this last level
 *          json : the json object or array where we have to assign the property with value. In the case of array we have alos to retrieve which instance in the object
 *          property : the property item that describe the property defined by the key 'key'
 *      }
 */
function _addToJsonObject(key, jsonRoot, prototype, item, value, config) {
	function _createEmptyItem(propItem) { // depending of the typ fo the property, it create a empty object or empty array
		return propItem && propItem.$type === "application/x-array" ? [] : {};
	}

	function _getInstanceName() {
		return prototype.$instanceUrl.substring(prototype.$instanceUrl.indexOf("/") + 1);
	}

	// get the root property level

	var properties = prototype.$properties ? prototype.$properties : prototype;
	var json = jsonRoot;

	var jsonKey = key.split('.');
	var stop = false;
	// create the last element
	if (jsonKey && jsonKey.length > 1) {
		for (var i = 0; i < jsonKey.length - 1 && !stop; i++) {
			var elemKey = jsonKey[i];
			var properties = parseHelp.getProperty(properties, elemKey);

			/*
			 manage by 4GL expression correspond to the path in the prototype
			 if (!propTemp) {
			 elemKey = _getInstanceName() + jsonKey.slice(0, i + 1).join(""); // hack item is identify by concat of all parent node
			 propTemp = parseHelp.getProperty(properties, elemKey);
			 }
			 properties = propTemp; // we get the properties of the current key until the end
			 */
			if (properties) { // we get only the object level and not the property
				json[elemKey] = json[elemKey] || _createEmptyItem(properties); // assign to json[item to create object
				json = json[elemKey];

				if (Array.isArray(json)) { // if it's an array we have to push an object if there many elemnt on the collecton or only the value
					if (properties.$item.$type === "application/json") { // if the array must ocntain json object
						if (json.length === 0 || (i === jsonKey.length - 2 && item.newRecord)) { // if there nothin we create or we are on the level n-2 (level of the array)
							// add a property to set which item creat a new record in array
							item.newRecord = true;
							json.push({});
						}
						json = json[json.length - 1]; // json to return is the last ojbect in the array
					} else { // the array contain primitve value
						stop = true; // don't analyse the reste because the property name in the prototype not correspond of seqFile description
						// case of collection that contain primitive field and not json object
					}
				}
			} else { // failed for that key
				stop = true;
				log.warn && log.warn("property " + key + " doesn't exists for the entity " + prototype.$representation);
			}
		}

		// get the property description corresponding  to the item. If the collection contain a json object we need to get the properties desciption of the item else concerve the array property descirption
		if (properties && properties.$item && properties.$item.$type === "application/json") {
			properties = parseHelp.getProperty(properties, jsonKey[jsonKey.length - 1]);
		}

	} else { // case of property in root level
		properties = properties[key];
		if (!properties) {
			log.warn && log.warn("property " + key + " doesn't exists for the entity " + prototype.$representation);
		}
	}

	if (properties) {
		if (properties.$type === "application/x-array") {
			var valFmt = _formatType(properties.$item, value, config, key);
			log.debug && log.debug("add in array  value " + valFmt);
			json.push(valFmt);
		} else {
			var valFmt = _formatType(properties, value, config, key);
			log.debug && log.debug("add " + jsonKey[jsonKey.length - 1] + " value " + valFmt);
			json[jsonKey[jsonKey.length - 1]] = valFmt;
		}
	} //else  do nothin
}

function _formatType(propItem, str, config, key) {

	switch (propItem.$type) {
		case "application/x-decimal":
			// create format
			var float = parseFloat(str, 10);
			if (!float) {
				throw new Error(locale.format(module, "formatValue", str, propItem.$type, key));
			}
			return float;
		case "application/x-integer":
			var int = parseInt(str, 10);
			if (!int) {
				throw new Error(locale.format(module, "formatValue", str, propItem.$type, key));
			}
			return int;
		case "application/x-boolean":
			return Boolean(str);
		case "application/x-date":
			var date = datetime.parse(str, config.dateFormat || "dd/MM/yyyy");

			return date.toString("yyyy-MM-dd");

		default:
			return str;
	}
}


function _throwError(message, code) {
	var e = new Error(message);
	e.code = code;
	throw e;
}


// this function takes a mapping between xml paths and paths in the resulting JSON structure
// and preprocesses it to make the transformation process more efficient
// It is assumed that all repetition groups fit together, i. e. a repetition in the XML structure 
// exactly corresponds to a repetition in the resulting JSON structure. For the JSON structure
// it is assumed, that each sub-object may be a repetition group
// OK: mappings  A.L           <-> u         type: "base:xs:string,maxLength:50"
//               A.B.C[0..n].D <-> v.w       type: "base:xs:decimal"
//               A.B.C[0..n].E <-> v.x       type: "base:xs:positiveInteger"
//               F[0..n].G.H   <-> y.z       type: "base:xs:date"
//               F[0..n].I[0..n].J <-> y.t.s type: "base:xs:boolean"
//
// not OK: mappings   A.B <-> u.v
// because no repetition group on the left hand side, but on the right hand side
//
// not OK: mappings A.B.C[0..n].D <-> v.w
//                  F[0..n].E     <-> v.x
// because different repetition groups are on the left hand side, the same on right hand side
//
// not OK: mappings A.B <-> u
//                  A.B.C <-> v
// mappings are given as arrays of objects with properties "xml" (for XML path) and "json" (for JSON ppath)
// moreover there is a datatype in "type" property
// there are special elements in the result with key "": at top level some general properties (toXML: boolean value whether
//  mapping destination is XML structure; depth: maximal depth of entries without change of repetition group)
// parameter toXML: generate mapping from JSON structure to XML structure
// the above example will result in:
// mapping to JSON: { "": {toXML: false, depth: 3}, "A.L": ["u"], "A.B.C": { "": "v", "D": "w", "E": "x"}, "F": { "":"y", "G.H": "z", "I": { "": "t", "J": "s" }}}
// mapping to XML: { "": {toXML: true, depth: 1}, "u": "A.L", "v": { "": "A.B.C", "w": "D", "x": "E"}, "y": { "":"F", "z": "G.H", "t": { "": "I", "s": "J" }}}
function preprocessMapping(_, mappings, toXML) {
	var result = {
		"": {
			toXML: !!toXML,
			depth: 1
		}
	};
	var rXML = /(.*?)\[[^\]]+\]\.?/g;
	var rJSON = /(.*?)\./g;
	var maxDepth = 0; // maximal depth of entries of same repetition group (to avoid infinite recursions)
	mappings.forEach(function(mapping) {
		var mXML = mapping.xml;
		var mJSON = mapping.json;
		console.log("AAAA " + mXML + " " + mJSON)
		if (!mXML) {
			if (!mJSON) return; // no mapping information: ignore
			else _throwError("Empty XML path for JSON path " + mJSON, "EMPTYXML")
		}
		if (!mJSON) _throwError("Empty JSON path for XML path " + mXML, "EMPTYJSON");
		// now both mappings are available		
		var object = result;
		var sBase;
		var beginningBase = "";
		var beginningDest = "";
		if (toXML) {
			var rBase = rJSON;
			var rDest = rXML;
			var mBase = mJSON;
			var mDest = mXML;
		} else {
			var rBase = rXML;
			var rDest = rJSON;
			var mBase = mXML;
			var mDest = mJSON;
		}
		rBase.lastIndex = rDest.lastIndex = 0; // initialize regular expressions
		while (sBase = rBase.exec(mBase)) {
			console.log("rbase: " + JSON.stringify(sBase))
			var pBase = sBase[1];
			var depth = pBase.replace(/[^\.]+/g, "").length;
			if (depth > maxDepth) maxDepth = depth;
			if (!pBase) _throwError("Empty part behind " + beginningBase + " in path " + mBase, "EMPTYPARTBASE");
			var sDest = rDest.exec(mDest);
			console.log("rdest: " + JSON.stringify(sDest))
			if (!sDest) _throwError("Destination path " + mDest + " contains less repetition groups than " + mBase, "DESTLESSGROUPS");
			var pDest = sDest[1];
			if (!pDest) _throwError("Empty part behind " + beginningDest + " in destination path " + mDest, "EMPTYPARTDEST");
			var mapped = object[pBase];
			if (mapped) { // mapping already exists. Check whether it is same mapping as before
				if (Array.isArray(mapped)) _throwError("Mapping from " + mBase + " to " + mDest + ": Repetition group " + beginningBase + pBase + " has already been treated as full path and was mapped to " + beginningDest + mapped, "FULLTOGROUP");
				if (mapped[""] !== pDest) _throwError("Mapping from " + mBase + " to " + mDest + ": Repetition group " + beginningBase + pBase + " was mapped to " + beginningDest + mapped[""] + " and is now mapped to different group " + beginningDest + pDest, "GROUPCHANGE");
				object = mapped;
			} else {
				Object.keys(object).forEach(function(key) {
					if (key.indexOf(pBase) === 0 && key[pBase.length] === ".") _throwError("Mapping from " + mBase + " to " + mDest + ": Path " + beginningBase + pBase + " is contained in existing path " + beginningBase + key, "CONTAINED");
					if (pBase.indexOf(key) === 0 && pBase[key.length] === ".") _throwError("Mapping from " + mBase + " to " + mDest + ": Path " + beginningBase + pBase + " is contains existing path " + beginningBase + key, "CONTAINS");
				})
				object = object[pBase] = {
					"": pDest
				}; // change value of 'object' for next step in iteration
			}
			beginningBase += sBase[0];
			beginningDest += sDest[0];
		}
		// last part
		if (rDest.exec(mDest)) _throwError("Mapping from " + mBase + " to " + mDest + ": destination path contains more repetition groups", "DESTMOREGROUPS");
		var pBase = mBase.substr(beginningBase.length);
		var pDest = mDest.substr(beginningDest.length);
		console.log("Ende " + pBase + " " + pDest)
		if (!pBase) _throwError("Empty part at the end of base path " + mBase, "EMPTYPARTBASEEND");
		if (!pDest) _throwError("Empty part at the end of destination path " + mDest, "EMPTYPARTDESTEND");
		var mapped = object[pBase];
		if (mapped) { // mapping already exists. Check whether it is same mapping as before
			if (!Array.isArray(mapped)) _throwError("Mapping from " + mBase + " to " + mDest + ": Final path " + mBase + " has already been treated as repetition group and was mapped to " + beginningDest + mapped[""], "GROUPTOFULL");
			if (mapped[0] !== pDest) _throwError("Mapping from " + mBase + " to " + mDest + ": Final path " + mBase + " was mapped to " + beginningDest + pDest + " and is now mapped to different path " + beginningDest + mapped, "FULLCHANGE");
		} else {
			// consider the type
			var max;
			var type;
			if (mapping.type) {
				var s;
				if (s = /maxLength:(\d+)/.exec(mapping.type)) {
					max = s[1];
				}
				if (s = /xs:([A-Za-z]+)/.exec(mapping.type)) {
					if (s[1] !== "string") type = s[1];
				}
			}
			if (type) max = max || "0";
			if (max) {
				if (type) {
					object[pBase] = [pDest, max, type];
				} else object[pBase] = [pDest, max];
			} else object[pBase] = [pDest];
		}

	})
	if (Object.keys(result).length < 2) _throwError("No mappings defined", "NOMAPPING")
	result[""].depth = maxDepth + 1;
	return result;
}
exports.preprocessMapping = preprocessMapping;




function convert(input, mapping) {
	var result = {};
	var maxDepth = mapping[""].maxDepth;
	var rJSON = /(.*?)\./g;

	function _conv(element, map, res, path, depth) {
		var keys = Object.keys(element);
		var i = keys.length;
		while (--i >= 0) {
			var key = keys[i];
			var path2 = path + key
			var mapped = map[path2];
			if (mapped) {
				// element found
				// create nested object if necessary and traverse within object
				var object = res;
				var s;
				var parts = mapped[0].split(".");
				for (var i = 0; i < parts.length - 1; i++) {
					if (s[1] in object) object = object[s[1]];
					else object = object[s[1]] = {}
				}
				object[par]
				rJSON.lastIndex = 0; // initialise regular expression
				var lastIndex = 0;
				while (s = rJSON.exec(mapped[0])) {}
				object[]
				mapped[0].split(".").forEach(function())



				if (Array.isArray[mapped]) {
					// direct conversion

				}
			} else {
				if (depth > 0) { // only recurse when max depth is not exceeded
					_conv(element[key], map, res, path2 + ".", depth - 1);
				}
			}
		})
}



_conv(input, mapping, result, "", maxDepth);
}