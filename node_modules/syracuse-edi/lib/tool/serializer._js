"use strict";
var config = require('config'); // must be first syracuse require
var trace = config.edi && config.edi.parser && config.edi.parser.trace;
var ImportFileType = require('../enumType').ImportFileType;
var sqMap = require('../helpers').seqentialFilePropertyMap;
var mmMap = require('../helpers').messageMappingPropertyMap;
var adminHelper = require("@sage/syracuse-lib/src/collaboration/helpers").AdminHelper;
var helpersEdi = require('../helpers');
var serializeHelp = require('./helpers');
var decimal = require('@sage/syracuse-core').types.decimal;
var datetime = require('@sage/syracuse-core').types.datetime;
var log = require('@sage/syracuse-core').getTracer("edi.serializer");
var locale = require('streamline-locale');
var jsxml = require('js-xml');
/**
 * Created by apisu on 01/07/2014.
 * parse of the edi file to a json structure regarding a specific context
 */


///
/// ### function parse that create a json file from Edi sequential file(s)
///  parse(_,buff,ediCached[,json])
///     filesBuff : buffer of the files read in string or binary
///     ediCached : contains all element for @ation
exports.serialize = function(_, opt) {

	log.info && log.info("serialize action " + opt.action);

	// retrieve prototype

	log.debug && log.debug("seqFile type  " + opt.configSerializer.serializer);

	var serializer = opt.configSerializer.serializer;

	if (_mapSerialize[serializer]) {
		log.debug && log.debug("serializer used " + serializer);
		return _mapSerialize[serializer](_, opt);
	} else {
		throw new Error(locale.format(module, "findSerializer", serializer));
	}

};


function isFinishedBySepRecord(line, sepRecord) {
	return line.lastIndexOf(sepRecord) === (line.length - sepRecord.length);
}

function _unformatType(propItem, val, sContext) {
	switch (propItem.$type) {
		case "application/x-decimal":
			// create format
			return (val + "").replace(".", sContext.sepDecimal);

		case "application/x-boolean":
			return val;
		case "application/x-date":
			var date = datetime.parse(val, "yyyy-MM-dd");
			return date.toString(sContext.dateFormat || "dd/MM/yyyy");
		default:
			return val;

	}
}
/*
 * return an array of all element that correspond to the key. If the property exists once, we return an array of 1 element
 * if the property is in an array we return a array of element in the same order of the array
 */
function _getJsonElem(json, key, sContext, prototype, prop, isMandatory) {

	var properties = prop || prototype && prototype.$properties;
	if (key.indexOf(".") === -1) {
		var prop = serializeHelp.getProperty(properties, key);
		if (prop) {
			return _unformatType(prop, json[key], sContext);
		} else {
			throw new Error(locale.format(module, "missProperty", key, (prototype && prototype.$representation)));
		}
	} else {
		var stop = false;
		var js = json;
		var result = [];
		var keys = key.split(".");
		for (var i = 0; i < keys.length && !stop; i++) {
			var item = keys[i];

			var jsTemp = js[item];
			if (!jsTemp) {
				item = prototype.$instanceUrl.substring(prototype.$instanceUrl.indexOf("/") + 1) + keys.slice(0, i + 1).join(""); // hack item is identify by concat of all parent node
				jsTemp = js[item];
			}
			js = jsTemp;

			stop = !js || Array.isArray(js) || properties[item];
			properties = serializeHelp.getProperty(properties, item);
		}
		if (Array.isArray(js)) { // add all element of each line
			var keyInArray = keys.slice(i).join(".");
			for (var k = 0; k < js.length; k++) {
				if (properties) {
					var l = _getJsonElem(js[k], keyInArray, sContext, prototype, properties, isMandatory);
					if (l) {
						if (Array.isArray(l)) {
							l.forEach(function(item) {
								result.push(item);
							});
						} else {
							result.push(l);
						}
					} else {
						// raise an error if it's a mandatory field
						if (isMandatory) {
							throw new Error(locale.format(module, "mandatoryField", key, (prototype && prototype.$representation)));
						}
						result.push("");

					}
				}
			}
		} else if (stop && isMandatory) {
			throw new Error(locale.format(module, "missProperty", key, (prototype && prototype.$representation)));
		} else {
			// normally we have found it
			if (js) {
				// convert value to the rigth format
				var r = _unformatType(properties, js, sContext);
				result.push(r ? r : "");
			} else {
				// raise an error if it's a mandatory field
				if (isMandatory) {
					throw new Error(locale.format(module, "mandatoryField", key, (prototype && prototype.$representation)));
				}
				result.push("");
			}
		}
		return result;
	}
};





var _mapSerialize = {
	xml: function(_, opt) {

		log.info && log.info("------------------");
		log.info && log.info("serialize Xml");
		var input = opt.json;
		var out = {};
		if (input) {

			var configSerializer = opt.configSerializer;
			var namespace = configSerializer.namespace;

			Object.keys(configSerializer.elems).forEach_(_, function(_, filename) {
				var elem = configSerializer.elems[filename];
				var diags = [];

				var jsonxml = serializeHelp.convert(input, serializeHelp.preprocessMapping(_, elem, true, diags, opt.prototype));

				for (var i = 0; namespace && i < Object.keys(namespace).length; i++) { // TODO set the target main namespace (ok for facturae as xmldsig is add by us). need to manage namespace during generate of jsxml in preprocessMapping or convert
					if (namespace[Object.keys(namespace)[i]]) {
						var nm = Object.keys(namespace)[i];
						jsonxml[nm.substring(0, 3).toLowerCase() + ":" + nm] = jsonxml[nm];
						delete jsonxml[nm];
						if (!jsonxml[nm.substring(0, 3).toLowerCase() + ":" + nm].$) {
							jsonxml[nm.substring(0, 3).toLowerCase() + ":" + nm].$ = {};
						}
						jsonxml[nm.substring(0, 3).toLowerCase() + ":" + nm].$["xmlns:" + nm.substring(0, 3).toLowerCase()] = namespace[nm];
					}
				}
				out[filename] = jsxml && jsxml.stringify(jsonxml, {
					indent: '\t'
				});;
			});
			log.debug && log.debug("json " + JSON.stringify(out));
			// convert jsxml to xml
		}
		return out;
	},
	sepRecord: function(_, opt) {

		var json = opt.json;
		var configSerializer = opt.configSerializer;
		var prototype = opt.prototype;
		var fileBuf = {};
		configSerializer.elems.forEach(function(elem) {

			var propertyName = elem.expression;

			function _serialize(items, level, index) {
				items && items.forEach(function(val, idx, array) {
					if (Array.isArray(val)) {
						_serialize(val, idx);
					}
					var filename = configSerializer.fileName || elem.fileName;
					var idLine = filename + level + (index || idx); // serialize
					fileBuf[filename] = fileBuf[filename] || {};
					fileBuf[filename][idLine] = fileBuf[filename][idLine] || "";
					// add indicator when it's necessary
					/*if (!fileBuf[filename][idLine]) { // if empty string so start of the line
					 fileBuf[filename][idLine] += elem.flag;
					 }*/

					fileBuf[filename][idLine] += (fileBuf[filename][idLine] ? configSerializer.sepField : "") + val;
					if (elem.isEnd && !isFinishedBySepRecord(fileBuf[filename][idLine], configSerializer.sepRecord)) {
						// add record separator
						fileBuf[filename][idLine] += configSerializer.sepRecord;
					}
				});
			}

			if (propertyName) {
				log.debug && log.debug("serialize property " + propertyName);

				// get json element(s) identify by the propertyName
				var items = _getJsonElem(json, propertyName, configSerializer, prototype, null, elem.isMandatory);
				if (items && !Array.isArray(items)) {
					items = [items];
				}
				log.debug && log.debug("items corresponding to  property " + propertyName + " : " + JSON.stringify(items));

				_serialize(items, elem.level);

			}
		});
		var filename = configSerializer.fileName;

		Object.keys(fileBuf).forEach(function(f) {
			var listLine = fileBuf[f];
			fileBuf[filename] = "";


			Object.keys(listLine).forEach(function(lineKey, idx, array) {
				fileBuf[filename] += listLine[lineKey];
				if (idx <= array.length - 1 && !isFinishedBySepRecord(fileBuf[filename], configSerializer.sepRecord)) {
					fileBuf[filename] += configSerializer.sepRecord;
				}
			});
		});
		return fileBuf;

	},
	sepField: function(_, opt) {

		var json = opt.json;
		var configSerializer = opt.configSerializer;
		var prototype = opt.prototype;
		var fileBuf = {};
		configSerializer.elems.forEach(function(elem) {

			var propertyName = elem.expression;

			function _serialize(items, index) {
				items && items.forEach(function(val, idx, array) {
					if (Array.isArray(val)) {
						_serialize(val, idx);
					}
					var filename = configSerializer.fileName || elem.fileName;
					var idLine = filename + (index || idx); // serialize
					fileBuf[filename] = fileBuf[filename] || {};
					fileBuf[filename][idLine] = fileBuf[filename][idLine] || "";
					// add indicator when it's necessary
					/*if (!fileBuf[filename][idLine]) { // if empty string so start of the line
						fileBuf[filename][idLine] += elem.flag;
					}*/

					fileBuf[filename][idLine] += (fileBuf[filename][idLine] ? configSerializer.sepField : "") + val;

				});
			}

			if (propertyName) {
				log.debug && log.debug("serialize property " + propertyName);

				// get json element(s) identify by the propertyName
				var items = _getJsonElem(json, propertyName, configSerializer, prototype, null, elem.isMandatory);
				if (items && !Array.isArray(items)) {
					items = [items];
				}
				log.debug && log.debug("items corresponding to  property " + propertyName + " : " + JSON.stringify(items));

				_serialize(items);

			}
		});
		var filename = configSerializer.fileName;

		Object.keys(fileBuf).forEach(function(f) {
			var listLine = fileBuf[f];
			fileBuf[filename] = "";


			Object.keys(listLine).forEach(function(lineKey, idx, array) {
				fileBuf[filename] += listLine[lineKey];
				/*if (idx <= array.length - 1 && !isFinishedBySepRecord(fileBuf[filename], configSerializer.sepRecord)) {
					fileBuf[filename] += configSerializer.sepRecord;
				}*/
			});
		});
		return fileBuf;
	},
	delimited: function(_, opt) {

		var json = opt.json;
		var configSerializer = opt.configSerializer;
		var prototype = opt.prototype;

		var fileBuf = {};
		var itemOfItems = {
			items: [],
		};
		var i = 0;
		configSerializer.elems.forEach(function(elem) {

			var propertyName = elem.expression;
			log.debug && log.debug("serialize filename " + elem.fileName);

			if (propertyName) {
				log.debug && log.debug("serialize property " + propertyName);

				// get json element(s) identify by the propertyName
				var items = _getJsonElem(json, propertyName, configSerializer, prototype, null, elem.isMandatory);
				if (items !== null && !Array.isArray(items)) {
					items = [items];
				}
				itemOfItems.items[i++] = {
					elem: elem,
					arr: items
				};
				itemOfItems[elem.fileName] = itemOfItems[elem.fileName] || {};
				itemOfItems[elem.fileName][elem.level] = itemOfItems[elem.fileName][elem.level] || {};

				itemOfItems[elem.fileName][elem.level].nbLine = itemOfItems[elem.fileName][elem.level].nbLine < items.length ? items.length : (itemOfItems[elem.fileName][elem.level].nbLine || 1);

				log.debug && log.debug("items corresponding to  property " + propertyName + " : " + JSON.stringify(items) + " itemofItem " + JSON.stringify(elem));

			}
		});
		itemOfItems && itemOfItems.items.forEach(function(item, idx) {
			for (var ii = 0; ii < itemOfItems[item.elem.fileName][item.elem.level].nbLine; ii++) {
				var val = item.arr[ii] !== null && (typeof item.arr[ii] !== "undefined") ? item.arr[ii] : item.arr[0];

				var filename = configSerializer.fileName || item.elem.fileName;
				var idLine = item.elem.flag + ii; // serialize
				fileBuf[filename] = fileBuf[filename] || {};
				fileBuf[filename][idLine] = fileBuf[filename][idLine] || "";
				// add indicator when it's necessary
				/*if (!fileBuf[filename][idLine]) { // if empty string so start of the line
					fileBuf[filename][idLine] += configSerializer.delimField + item.elem.flag + configSerializer.delimField;
				}*/

				if (val !== null) {
					fileBuf[filename][idLine] += (fileBuf[filename][idLine] ? configSerializer.sepField : "") + configSerializer.delimField + (val ? val : "") + configSerializer.delimField;
				}

			};
		});
		Object.keys(fileBuf).forEach(function(filename) {
			var listLine = fileBuf[filename];
			fileBuf[filename] = "";

			Object.keys(listLine).forEach(function(lineKey, idx, array) {
				fileBuf[filename] += listLine[lineKey] + configSerializer.sepRecord;

			});
		});
		return fileBuf;
	},
	fixedLength: function(_, opt) {

		var json = opt.json;
		log.debug && log.debug("JSON to serialized " + JSON.stringify(json));
		var configSerializer = opt.configSerializer;
		var prototype = opt.prototype;
		//the value dump that match the size describe in seqFile, we add space after value
		function _getFixedLengthValue(value, size) {
			//console.log("type="+typeof value+", value="+JSON.stringify(value)+", len="+value.length+", size="+size);
			var val = "" + value;
			var res = val;
			if (typeof value === "number") {
				// right text align
				for (var i = val.length; i < size; i++) {
					res = " " + res;
				}
			} else {
				// left text align
				for (var i = val.length; i < size; i++) {
					res += " ";
				}
			}
			if (res.length > size) {
				res = res.substring(0, size);
			}

			return res;
		};
		var fileBuf = {};
		var missingProperty = false;
		// TODO manage array of array that can be return by getJsonElem depending of the structure
		var itemOfItems = {
			items: [],
		};
		var i = 0;
		configSerializer.elems.forEach(function(elem) {
			var realLoc = elem.offset;
			var propertyName = elem.expression;
			log.debug && log.debug("serialize property " + propertyName);

			if (propertyName) {
				log.debug && log.debug("serialize filename " + elem.fileName);

				// get json element(s) identify by the propertyName
				var items = _getJsonElem(json, propertyName, configSerializer, prototype, null, elem.isMandatory);
				if (items && !Array.isArray(items)) {
					items = [items];
				}
				log.debug && log.debug("serialize items " + JSON.stringify(items));

				itemOfItems.items[i++] = {
					elem: elem,
					arr: items
				};
				itemOfItems[elem.fileName] = itemOfItems[elem.fileName] || {};
				itemOfItems[elem.fileName][elem.level] = itemOfItems[elem.fileName][elem.level] || {
					nbLine: 1
				};
				itemOfItems[elem.fileName][elem.level].nbLine = itemOfItems[elem.fileName][elem.level].nbLine < items.length ? items.length : (itemOfItems[elem.fileName][elem.level].nbLine || 1);
				log.debug && log.debug("filename " + elem.fileName + " level " + elem.level + " nbline " + itemOfItems[elem.fileName][elem.level].nbLine);

			}
		});
		var lastline;
		itemOfItems && itemOfItems.items.forEach(function(item, idx) {
			for (var ii = 0; ii < itemOfItems[item.elem.fileName][item.elem.level].nbLine; ii++) {
				log.debug && log.debug("write line " + ii + ", write item " + JSON.stringify(item));

				var filename = configSerializer.fileName || item.elem.fileName;
				fileBuf[filename] = fileBuf[filename] || {};
				fileBuf[filename][ii] = fileBuf[filename][ii] || "";
				// get the string correspond to the last line
				lastline = fileBuf[filename][ii];
				if (lastline.lastIndexOf(configSerializer.sepRecord) !== -1) {
					lastline = lastline.substring(lastline.lastIndexOf(configSerializer.sepRecord) + configSerializer.sepRecord.length);
				}
				var jj = 0;
				for (var jj = 0; jj < (item.elem.offset - lastline.length); jj++) {
					// add space in order to
					fileBuf[filename][ii] += " ";
				}


				var val = item.arr[ii] !== null && (typeof item.arr[ii] !== "undefined") ? item.arr[ii] : item.arr[0];
				// truncate val if it's longer that the seqfile
				val = _getFixedLengthValue(val || "", item.elem.length);
				//val = val.substring(0,item.elem.length);
				fileBuf[filename][ii] += val;

				if (item.elem.isEnd && !isFinishedBySepRecord(lastline, configSerializer.sepRecord)) { // add the endrecord
					fileBuf[filename][ii] += configSerializer.sepRecord;

				}
			}
		});
		Object.keys(fileBuf).forEach(function(filename) {
			var listLine = fileBuf[filename];
			fileBuf[filename] = "";
			Object.keys(listLine).forEach(function(lineKey, idx, array) {
				// check if the line contains something. then add if to the file
				fileBuf[filename] += listLine[lineKey];
			});
			// remove empty line
			var regexp = new RegExp(configSerializer.sepRecord + "\\s*" + configSerializer.sepRecord, "g");
			fileBuf[filename] = fileBuf[filename].replace(regexp, configSerializer.sepRecord);
		});
		// add the end sepRecord
		return fileBuf;
	}
};


// for unit test
exports.mapSerialize = _mapSerialize;