"use strict";
var config = require('config'); // must be first syracuse require
var trace = config.edi && config.edi.parser && config.edi.parser.trace;
var ImportFileType = require('syracuse-edi/lib/enumType').ImportFileType;
var sqMap = require("syracuse-edi/lib/helpers").seqentialFilePropertyMap;
var mmMap = require("syracuse-edi/lib/helpers").messageMappingPropertyMap;
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var helpersEdi = require('syracuse-edi/lib/helpers');
var serializeHelp = require('syracuse-edi/lib/tool/helpers');
var decimal = require("syracuse-core/lib/types/decimal");
var datetime = require("syracuse-core/lib/types/datetime");
var log = require("syracuse-trace/lib/helper").getTracer("edi.serializer");
var locale = require("syracuse-core/lib/locale");

/**
 * Created by apisu on 01/07/2014.
 * parse of the edi file to a json structure regarding a specific context
 */


///
/// ### function parse that create a json file from Edi sequential file(s)
///  parse(_,buff,ediCached[,json])
///     filesBuff : buffer of the files read in string or binary
///     ediCached : contains all element for @ation
exports.serialize = function(_, opt) {

	log.info && log.info("serialize action " + opt.action);

	// retrieve prototype

	log.debug && log.debug("seqFile type  " + opt.configSerializer.serializer);

	var serializer = opt.configSerializer.serializer;

	if (_mapSerialize[serializer]) {
		log.debug && log.debug("serializer used " + serializer);
		return _mapSerialize[serializer](opt.json, opt.configSerializer, opt.prototype);
	} else {
		throw new Error(locale.format(module, "findSerializer", serializer));
	}

};



/*
 * return an array of all element that correspond to the key. If the property exists once, we return an array of 1 element
 * if the property is in an array we return a array of element in the same order of the array
 */
function _getJsonElem(json, key, sContext, prototype, prop, isMandatory) {
	function _unformatType(propItem, val) {
		switch (propItem.$type) {
			case "application/x-decimal":
				// create format
				return (val + "").replace(".", sContext.sepDecimal);

			case "application/x-boolean":
				return val;
			case "application/x-date":
				var date = datetime.parse(val, "yyyy-MM-dd");
				return date.toString("dd/MM/yyyy");
			default:
				return val;

		}
	}
	var properties = prop || prototype && prototype.$properties;
	if (key.indexOf(".") === -1) {
		var prop = serializeHelp.getProperty(properties, key);
		if (prop) {
			return _unformatType(prop, json[key]);
		} else {
			throw new Error(locale.format(module, "missProperty", key, (prototype && prototype.$representation)));
		}
	} else {
		var stop = false;
		var js = json;
		var result = [];
		var keys = key.split(".");
		for (var i = 0; i < keys.length && !stop; i++) {
			var item = keys[i];

			var jsTemp = js[item];
			if (!jsTemp) {
				item = prototype.$instanceUrl.substring(prototype.$instanceUrl.indexOf("/") + 1) + keys.slice(0, i + 1).join(""); // hack item is identify by concat of all parent node
				jsTemp = js[item];
			}
			js = jsTemp;

			stop = !js || Array.isArray(js) || properties[item];
			properties = serializeHelp.getProperty(properties, item);
		}
		if (Array.isArray(js)) { // add all element of each line
			var keyInArray = keys.slice(i).join(".");
			for (var k = 0; k < js.length; k++) {
				if (properties) {
					var l = _getJsonElem(js[k], keyInArray, sContext, prototype, properties, isMandatory);
					if (l)
						result.push(l);
					else {
						// raise an error if it's a mandatory field
						if (isMandatory) {
							throw new Error(locale.format(module, "mandatoryField", key, (prototype && prototype.$representation)));
						}
						result.push("");

					}
				}
			}
		} else if (stop && isMandatory) {
			throw new Error(locale.format(module, "missProperty", key, (prototype && prototype.$representation)));
		} else {
			// normally we have found it
			if (js) {
				// convert value to the rigth format
				var r = _unFormatType(properties, js);
				result.push(r ? r : "");
			} else {
				// raise an error if it's a mandatory field
				if (isMandatory) {
					throw new Error(locale.format(module, "mandatoryField", key, (prototype && prototype.$representation)));
				}
				result.push("");
			}
		}
		return result;
	}
};





var _mapSerialize = {
	sepRecord: function(json, configSerializer, prototype) {
		var fileBuf = {};
		configSerializer.elems.forEach(function(elem) {

			var propertyName = elem.expression;

			function _serialize(items, index) {
				items && items.forEach(function(val, idx, array) {
					if (Array.isArray(val)) {
						_serialize(val, idx);
					}
					var filename = configSerializer.fileName || elem.fileName;
					var idLine = elem.flag + (index || idx); // serialize
					fileBuf[filename] = fileBuf[filename] || {};
					fileBuf[filename][idLine] = fileBuf[filename][idLine] || "";
					// add indicator when it's necessary
					if (!fileBuf[filename][idLine]) { // if empty string so start of the line
						fileBuf[filename][idLine] += elem.flag;
					}

					fileBuf[filename][idLine] += (fileBuf[filename][idLine] ? configSerializer.sepField : "") + val;
					if (elem.isEnd) {
						// add record separator
						//fileBuff[filename][idLine] += sContext.sepRecord;
					}
				});
			}

			if (propertyName) {
				log.debug && log.debug("serialize property " + propertyName);

				// get json element(s) identify by the propertyName
				var items = _getJsonElem(json, propertyName, configSerializer, prototype, null, elem.isMandatory);
				if (items && !Array.isArray(items)) {
					items = [items];
				}
				log.debug && log.debug("items corresponding to  property " + propertyName + " : " + JSON.stringify(items));

				_serialize(items);

			}
		});
		Object.keys(fileBuf).forEach(function(filename) {
			var listLine = fileBuf[filename];
			fileBuf[filename] = "";

			Object.keys(listLine).forEach(function(lineKey, idx, array) {
				fileBuf[filename] += listLine[lineKey];
				if (idx < array.length - 1 && fileBuf[filename].indexOf(configSerializer.sepRecord) >= (fileBuf[filename].length - configSerializer.sepRecord.length)) {
					fileBuf[filename] += configSerializer.sepRecord;
				}
			});
		});
		return fileBuf;

	},
	sepField: function(json, configSerializer, prototype) {
		var fileBuf = {};
		configSerializer.elems.forEach(function(elem) {

			var propertyName = elem.expression;

			function _serialize(items, index) {
				items && items.forEach(function(val, idx, array) {
					if (Array.isArray(val)) {
						_serialize(val, idx);
					}
					var filename = configSerializer.fileName || elem.fileName;
					var idLine = elem.flag + (index || idx); // serialize
					fileBuf[filename] = fileBuf[filename] || {};
					fileBuf[filename][idLine] = fileBuf[filename][idLine] || "";
					// add indicator when it's necessary
					if (!fileBuf[filename][idLine]) { // if empty string so start of the line
						fileBuf[filename][idLine] += elem.flag;
					}

					fileBuf[filename][idLine] += (fileBuf[filename][idLine] ? configSerializer.sepField : "") + val;
					if (elem.isEnd) {
						// add record separator
						fileBuff[filename][idLine] += sContext.sepRecord;
					}
				});
			}

			if (propertyName) {
				log.debug && log.debug("serialize property " + propertyName);

				// get json element(s) identify by the propertyName
				var items = _getJsonElem(json, propertyName, configSerializer, prototype, null, elem.isMandatory);
				if (items && !Array.isArray(items)) {
					items = [items];
				}
				log.debug && log.debug("items corresponding to  property " + propertyName + " : " + JSON.stringify(items));

				_serialize(items);

			}
		});
		Object.keys(fileBuf).forEach(function(filename) {
			var listLine = fileBuf[filename];
			fileBuf[filename] = "";

			Object.keys(listLine).forEach(function(lineKey, idx, array) {
				fileBuf[filename] += listLine[lineKey];

				if (idx < array.length - 1 && fileBuf[filename].indexOf(configSerializer.sepRecord) >= (fileBuf[filename].length - configSerializer.sepRecord.length)) {
					fileBuf[filename] += configSerializer.sepField;
				}
			});
		});
		return fileBuf;
	},
	delimited: function(json, configSerializer, prototype) {



		var fileBuf = {};
		var itemOfItems = {
			items: [],
		};
		var i = 0;
		configSerializer.elems.forEach(function(elem) {

			var propertyName = elem.expression;
			if (propertyName) {
				log.debug && log.debug("serialize property " + propertyName);

				// get json element(s) identify by the propertyName
				var items = _getJsonElem(json, propertyName, configSerializer, prototype, null, elem.isMandatory);
				if (items && !Array.isArray(items)) {
					items = [items];
				}
				itemOfItems.items[i++] = {
					elem: elem,
					arr: items
				};
				itemOfItems[elem.flag] = itemOfItems[elem.flag] || {};
				itemOfItems[elem.flag].nbLine = itemOfItems[elem.flag].nbLine < items.length ? items.length : (itemOfItems[elem.flag].nbLine || 1);

				log.debug && log.debug("items corresponding to  property " + propertyName + " : " + JSON.stringify(items) + " itemofItem " + JSON.stringify(elem));

			}
		});
		itemOfItems && itemOfItems.items.forEach(function(item, idx) {
			for (var ii = 0; ii < itemOfItems[item.elem.flag].nbLine; ii++) {
				var val = item.arr[ii] !== null && item.arr[ii] !== "undefined" ? item.arr[ii] : item.arr[0];

				var filename = configSerializer.fileName || item.elem.fileName;
				var idLine = item.elem.flag + ii; // serialize
				fileBuf[filename] = fileBuf[filename] || {};
				fileBuf[filename][idLine] = fileBuf[filename][idLine] || "";
				// add indicator when it's necessary
				if (!fileBuf[filename][idLine]) { // if empty string so start of the line
					fileBuf[filename][idLine] += configSerializer.delimField + item.elem.flag + configSerializer.delimField;
				}

				if (val) {
					fileBuf[filename][idLine] += (fileBuf[filename][idLine] ? configSerializer.sepField : "") + configSerializer.delimField + (val ? val : "") + configSerializer.delimField;
				}
				if (item.elem.isEnd) {
					// add record separator
					fileBuff[filename][idLine] += sContext.sepRecord;
				}
			};
		});
		Object.keys(fileBuf).forEach(function(filename) {
			var listLine = fileBuf[filename];
			fileBuf[filename] = "";

			Object.keys(listLine).forEach(function(lineKey, idx, array) {
				fileBuf[filename] += listLine[lineKey];
				if (idx < array.length - 1 && fileBuf[filename].indexOf(configSerializer.sepRecord) >= (fileBuf[filename].length - configSerializer.sepRecord.length)) {
					fileBuf[filename] += configSerializer.sepRecord;
				}
			});
		});
		return fileBuf;
	},
	fixedLength: function(json, configSerializer, prototype) {
		//the value dump that match the size describe in seqFile, we add space after value
		function _getFixedLengthValue(value, size) {
			//console.log("type="+typeof value+", value="+JSON.stringify(value)+", len="+value.length+", size="+size);
			var val = "" + value;
			var res = val;
			if (typeof value === "number") {
				// right text align
				for (var i = val.length; i < size; i++) {
					res = " " + res;
				}
			} else {
				// left text align
				for (var i = val.length; i < size; i++) {
					res += " ";
				}
			}
			return res;
		};
		var fileBuf = {};
		var missingProperty = false;
		// TODO manage array of array that can be return by getJsonElem depending of the structure
		var itemOfItems = {
			items: [],
		};
		var i = 0;
		configSerializer.elems.forEach(function(elem) {
			var realLoc = elem.offset;
			var propertyName = elem.expression;
			if (propertyName) {
				log.debug && log.debug("serialize property " + propertyName);
				// get json element(s) identify by the propertyName
				var items = _getJsonElem(json, propertyName, configSerializer, prototype, null, elem.isMandatory);
				if (items && !Array.isArray(items)) {
					items = [items];
				}
				itemOfItems.items[i++] = {
					elem: elem,
					arr: items
				};
				itemOfItems[elem.fileName] = itemOfItems[elem.fileName] || {};
				itemOfItems[elem.fileName].nbLine = itemOfItems[elem.fileName].nbLine < items.length ? items.length : (itemOfItems[elem.fileName].nbLine || 1);

			}
		});
		// TODO manage array of array that can be return by getJsonElem depending of the structure
		itemOfItems && itemOfItems.items.forEach(function(item, idx) {
			for (var ii = 0; ii < itemOfItems[item.elem.fileName].nbLine; ii++) {
				var filename = configSerializer.fileName || item.elem.fileName;
				fileBuf[filename] = fileBuf[filename] || {};
				fileBuf[filename][ii] = fileBuf[filename][ii] || "";
				while (fileBuf[filename][ii].length < item.elem.offset) {
					// add space in order to
					fileBuf[filename][ii] += " ";
				}
				if (fileBuf[filename][ii].length > item.elem.offset) {
					//TODO warning we add at the end of the string by generate a warning to describe that an issue in the seqFile description
				}
				var val = item.arr[ii] !== null && item.arr[ii] !== "undefined" ? item.arr[ii] : item.arr[0];
				fileBuf[filename][ii] += _getFixedLengthValue(val || "", item.elem.length);
				if (item.elem.isEnd) { // add the endrecord
					fileBuf[filename][ii] += configSerializer.sepRecord;
				}
			}
		});
		Object.keys(fileBuf).forEach(function(filename) {
			var listLine = fileBuf[filename];
			fileBuf[filename] = "";
			Object.keys(listLine).forEach(function(lineKey, idx, array) {
				fileBuf[filename] += listLine[lineKey];
				if (idx < array.length - 1 && fileBuf[filename].indexOf(configSerializer.sepRecord) >= (fileBuf[filename].length - configSerializer.sepRecord.length)) {
					fileBuf[filename] += configSerializer.sepRecord;
				}

			});
		});
		return fileBuf;
	}
};

// for unit test
exports.mapSerialize = _mapSerialize;