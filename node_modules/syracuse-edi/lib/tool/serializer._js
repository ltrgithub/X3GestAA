"use strict";
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var trace = config.edi && config.edi.parser && config.edi.parser.trace;
var ImportFileType = require('syracuse-edi/lib/enumType').ImportFileType;
var sqMap = require("syracuse-edi/lib/helpers").seqentialFilePropertyMap;
var mmMap = require("syracuse-edi/lib/helpers").messageMappingPropertyMap;
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var helpersEdi = require('syracuse-edi/lib/helpers');
var serializeHelp = require('syracuse-edi/lib/tool/helpers');
var decimal = require("syracuse-core/lib/types/decimal");
var datetime = require("syracuse-core/lib/types/datetime");
var log = require("syracuse-trace/lib/helper").getTracer("edi.serializer");
var locale = require("syracuse-core/lib/locale");

/**
 * Created by apisu on 01/07/2014.
 * parse of the edi file to a json structure regarding a specific context
 */


///
/// ### function parse that create a json file from Edi sequential file(s)
///  parse(_,buff,ediCached[,json])
///     filesBuff : buffer of the files read in string or binary
///     ediCached : contains all element for generation
exports.serialize = function(_, opt) {

	log.info && log.info("serialize action " + opt.action);

	// retrieve prototype

	log.debug && log.debug("seqFile type  " + opt.configSerializer.serializer);

	var serializer = opt.configSerializer.serializer;

	if (serializer) {
		log.debug && log.debug("serializer used " + serializer);
		return _mapSerialize[serializer](opt.json, opt.configSerializer, opt.prototype);
	} else {
		throw new Error(locale.format(module, "findSerializer", serializer));
	}

};



/*
 * return an array of all element that correspond to the key. If the property exists once, we return an array of 1 element
 * if the property is in an array we return a array of element in the same order of the array
 */
function _getJsonElem(json, key, sContext, prototype, prop) {
	function _unformatType(propItem, val) {

		switch (propItem.$type) {
			case "application/x-decimal":
				// create format
				return parseFloat((val + "").replace(".", sContext.sepDecimal), 10);

			case "application/x-boolean":
				return val;
			case "application/x-date":
				var date = datetime.parse(val, "yyyy-MM-dd");
				return date.toString("dd/MM/yyyy");
			default:
				return val;
		}
	}
	var properties = prop || prototype && prototype.$properties;
	if (key.indexOf(".") === -1) {
		var prop = serializeHelp.getProperty(properties, key);
		if (prop) {
			return _unformatType(prop, json[key]);
		} else {
			throw new Error(locale.format(module, "missProperty", key, (prototype && prototype.$representation)));
		}
	} else {
		var stop = false;
		var js = json;
		var result = [];
		var keys = key.split(".");
		for (var i = 0; i < keys.length && !stop; i++) {
			var item = keys[i];

			var jsTemp = js[item];
			if (!jsTemp) {
				item = prototype.$instanceUrl.substring(prototype.$instanceUrl.indexOf("/") + 1) + keys.slice(0, i + 1).join(""); // hack item is identify by concat of all parent node
				jsTemp = js[item];
			}
			js = jsTemp;

			stop = !js || Array.isArray(js) || properties[item];
			properties = serializeHelp.getProperty(properties, item);
		}
		if (Array.isArray(js)) { // add all element of each line
			var keyInArray = keys.slice(i).join(".");
			for (var k = 0; k < js.length; k++) {
				if (properties) {
					var l = _getJsonElem(js[k], keyInArray, sContext, prototype, properties);
					l && result.push(l);
				}
			}
		} else if (stop) {
			throw new Error(locale.format(module, "missProperty", key, (prototype && prototype.$representation)));
		} else {
			// normally we have found it
			if (js) {
				// convert value to the rigth format
				result.push(_unFormatType(properties, js));

			}
		}
		return result;
	}
};





var _mapSerialize = {
	delimited: function(json, configSerializer, prototype) {
		var fileBuf = {};
		configSerializer.elems.forEach(function(elem) {

			var propertyName = elem.expression;
			propertyName = propertyName.substring(propertyName.indexOf(".") + 1);

			function _serialize(items, index) {
				items && items.forEach(function(val, idx, array) {
					if (Array.isArray(val)) {
						_serialize(val, idx);
					}
					var filename = configSerializer.fileName || elem.fileName;
					var idLine = elem.flag + (index || idx); // serialize
					fileBuf[filename] = fileBuf[filename] || {};
					fileBuf[filename][idLine] = fileBuf[filename][idLine] || "";
					// add indicator when it's necessary
					if (!fileBuf[filename][idLine]) { // if empty string so start of the line
						fileBuf[filename][idLine] += configSerializer.delimField + elem.flag + configSerializer.delimField;
					}

					fileBuf[filename][idLine] += (fileBuf[filename][idLine] ? configSerializer.sepField : "") + configSerializer.delimField + val + configSerializer.delimField;
					if (elem[sqMap.elems.isEnd]) {
						// add record separator
						//fileBuff[filename][idLine] += sContext.sepRecord;
					}
				});
			}

			if (propertyName) {
				log.debug && log.debug("serialize property " + propertyName);

				// get json element(s) identify by the propertyName
				var items = _getJsonElem(json, propertyName, configSerializer, prototype);
				if (items && !Array.isArray(items)) {
					items = [items];
				}
				log.debug && log.debug("items corresponding to  property " + propertyName + " : " + JSON.stringify(items));

				_serialize(items);

			}
		});
		Object.keys(fileBuf).forEach(function(filename) {
			var listLine = fileBuf[filename];
			fileBuf[filename] = "";

			Object.keys(listLine).forEach(function(lineKey, idx, array) {
				fileBuf[filename] += listLine[lineKey];
				if (idx < array.length - 1) {
					fileBuf[filename] += configSerializer.sepRecord;
				}
			});
		});
		return fileBuf;
	},
	fixedLength: function(json, configSerializer, prototype) {
		//the value dump that match the size describe in seqFile, we add space after value
		function _getFixedLengthValue(value, size) {
			//console.log("type="+typeof value+", value="+JSON.stringify(value)+", len="+value.length+", size="+size);
			var val = "" + value;
			var res = val;
			if (typeof value === "number") {
				// right text align
				for (var i = val.length; i < size; i++) {
					res = " " + res;
				}
			} else {
				// left text align
				for (var i = val.length; i < size; i++) {
					res += " ";
				}
			}
			return res;
		};
		var fileBuf = {};
		var missingProperty = false;
		// TODO manage array of array that can be return by getJsonElem depending of the structure
		configSerializer.elems.forEach(function(elem) {
			var realLoc = elem.offset;
			var propertyName = elem.expression;
			propertyName = propertyName.substring(propertyName.indexOf(".") + 1);
			if (propertyName) {
				log.debug && log.debug("serialize property " + propertyName);
				// get json element(s) identify by the propertyName
				var items = _getJsonElem(json, propertyName, configSerializer, prototype);
				if (items && !Array.isArray(items)) {
					items = [items];
				}
				// TODO manage array of array that can be return by getJsonElem depending of the structure
				items && items.forEach(function(val, idx) {
					var filename = configSerializer.fileName || elem.fileName;
					fileBuf[filename] = fileBuf[filename] || {};
					fileBuf[filename][idx] = fileBuf[filename][idx] || "";
					fileBuf[filename][idx] += _getFixedLengthValue(val, elem.length);
				});
			}
		});
		Object.keys(fileBuf).forEach(function(filename) {
			var listLine = fileBuf[filename];
			fileBuf[filename] = "";
			Object.keys(listLine).forEach(function(lineKey, idx, array) {
				fileBuf[filename] += serializeHelp.removeSpace(listLine[lineKey]);
				if (idx < array.length - 1) {
					fileBuf[filename] += configSerializer.sepRecord;
				}

			});
		});
		return fileBuf;
	}
};

// for unit test
exports.mapSerialize = _mapSerialize;