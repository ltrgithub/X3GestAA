"use strict";
var locale = require("streamline-locale");
var log = require('@sage/syracuse-core').getTracer("edi.xml");
var DELIMITER = "|";

exports.removeSpace = function(str) {
	var i = 0;
	while ([" ", "\n", "\r"].indexOf(str[i]) !== -1 && i++ < str.length) {}

	str = str.substring(i);

	var i = str.length - 1;
	while ([" ", "\n", "\r"].indexOf(str[i]) !== -1 && i-- >= 0) {}
	str = str.substring(0, i + 1);
	return str;
};

function _getSubProperties(propItem) {
	if (!propItem) {
		return null;
	}
	if (typeof propItem === "object" && Object.keys(propItem).length === 0) {
		return null;
	}
	if (propItem.$item && Object.keys(propItem.$item).indexOf("$properties") > 0) {
		return propItem.$item.$properties;
	}

	return _getSubProperties(propItem.$item);
}
exports.getProperty = function(properties, elemKey) {
	return properties && properties[elemKey] || _getSubProperties(properties) && _getSubProperties(properties)[elemKey] || null;
};


function _throwError(message, code) {
	var e = new Error(message);
	e.code = code;
	throw e;
}


function _walkpath(protopath, element) {
	log.debug && log.debug("Walk " + element)
	if (protopath.$item && protopath.$item.$properties) protopath = protopath.$item;
	return (protopath.$properties && protopath.$properties[element]);
}


// splits path into groups according to prototype path. When it is used for a condition variable, the parameter mJSON must contain the 
// corresponding path from the mapping.
// when protopath is given, also check whether path is available according to prototype
function splitJSONPath(path, protopath, mJSON) {
	// check consistency of JSON path; use protopath for references
	var aJSON = path.split(/\./);
	for (var i = 0; i < aJSON.length; i++) {
		var part = aJSON[i];
		if (!/^\w+$/.test(part)) {
			if (mJSON)
				_throwError(locale.format(module, "wrongCondVar", mJSON, part, path), "WRONGCONDVAR");
			else
				_throwError(locale.format(module, "incorrectJson", path, part), "INCORRECTJSON");
		}
		if (protopath) {
			do {
				protopath = _walkpath(protopath, part);
				if (!protopath) {
					if (mJSON)
						_throwError(locale.format(module, "condVarNotInPrototype", mJSON, part, path), "CONDVARNOTINPROTOTYPE");
					else
						_throwError(locale.format(module, "notInPrototype", path, part), "NOTINPROTOTYPE");
				}
				if (!protopath.$type) {
					if (mJSON) _throwError(locale.format(module, "wrongCondPrototype", mJSON, part, path), "WRONCONDGPROTOTYPE");
					else
						_throwError(locale.format(module, "wrongPrototype", path, part), "WRONGPROTOTYPE");
				}
				if (i === aJSON.length - 1 && (protopath.$type === "application/x-reference" || protopath.$type === "application/x-array"))
					if (mJSON) {
						_throwError(locale.format(module, "condVarReferenceValue", mJSON, path), "CONDVARREFERENCEVALUE");
					} else
						_throwError(locale.format(module, "referenceValue", path), "REFERENCEVALUE");
				if (protopath.$type === "application/x-reference") {
					part = aJSON[i + 1]
					aJSON.splice(i, 2, aJSON[i] + "." + part);
				} else {
					break;
				}
			} while (true);
			log.debug && log.debug("base " + aJSON.join(":"));
		}
	}
	return aJSON;
}


// this function takes a mapping between xml paths and paths in the resulting JSON structure
// and preprocesses it to make the transformation process more efficient
// It is assumed that all repetition groups fit together, i. e. a repetition in the XML structure
// exactly corresponds to a repetition in the resulting JSON structure. For the JSON structure
// it is assumed, that each sub-object may be a repetition group
// OK: mappings  A.L           <-> u         type: "base:xs:string,maxLength:50"
//               A.B.C[0..n].D <-> v.w       type: "base:xs:decimal"
//               A.B.C[0..n].E <-> v.x       type: "base:xs:positiveInteger"
//               A.F[0..n].G.H   <-> y.z       type: "base:xs:date"
//               A.F[0..n].I[0..n].J <-> y.t.s type: "base:xs:boolean"
//
// not OK: mappings   A.B <-> u.v
// because no repetition group on the left hand side, but on the right hand side
//
// not OK: mappings A.B.C[0..n].D <-> v.w
//                  A.F[0..n].E     <-> v.x
// because different repetition groups are on the left hand side, the same on right hand side
//
// not OK: mapping X[0..n].D <-> x.y
// because root element is never a repetition group
//
// not OK: mapping X.A <-> u
//                 Y.B <-> v
// because there is only one root element
//
// not OK: mappings A.B <-> u
//                  A.B.C <-> v
//
// when a prototype is given (must be the full prototype object), the above rule is modified, because when a 
// property is a reference, there is no repetition group. So when u is a reference to an entity with property v,
// the following is allowed:
//   A.B <-> u.v
//
// non-unique mappings:
//
// OK (warning): A.B <-> u
//               A.B <-> v
// the same XML element is mapped to different JSON elements: it will mapped to all of them
//
// OK:           A.B <-> u, condition z = 5
//               A.C <-> u, condition z <> 5
// the same JSON element is mapped to different XML elements with condition. It will be mapped to the first
// element which satisfies the condition.
//
// About condition: All conditions have the format VARIABLE OPERATOR CONSTANT, where VARIABLE comes from
// the JSON path and must be uniquely reachable from the repetition group of the JSON mapping. Example:
// when the JSON structure is like {u:[{a:1, b:2}, {c:3,d:4}], v: 5, x:[{y:1}]}, then from mapping u.a the condition
// variables u.b, u.c, u.d, v are reachable, but not x.y. Prototypes will be respected.
// OPERATOR can be one of = (or ==) < > <= >= != (or <>) and  eq, lt, gt, le, ge, ne.
// The type of comparison will be determined by the constant (number/string comparison).
// Constant can be a number or a string. The conditions can be combined with 'and' (or & or &&) and 'or' (or | or ||)
// and brackets. 'and' takes precendence over 'or'. Example: (u.a > 5 or u.b = 6) and u.c = 7.
// When you use quotation marks within a string, they have to be escaped with '\': Example of two
// valid strings "\" ' \\", '\' " \\' 

//
// mappings are given as arrays of objects with properties "xml" (for XML path) and "json" (for JSON ppath)
// moreover there is a datatype in "type" property
// there are special elements in the result with key "": at top level some general properties (toXML: positive value when
//  mapping destination is XML structure, 0 elsewhere; depth: maximal depth of entries without change of repetition group)
// parameter toXML: generate mapping from JSON structure to XML structure
// The resulting XML should contain the tags in a certain ordering. So we will use the ordering given by the mappings, e. g.  
// when mapping for tag T1 is before mapping for tag T2 in the array of mappings, then the resulting XML will contain the tag
// T1 before the tag T2. So the mapping to XML will contain some prefixes of fixed length before the tag names. 
// The ordering of these prefixes (and therefore also the ordering of the entries) corresponds to the ordering of the mappings. 
// The fixed length is mentioned in the description:
// toXML is 0 when mapping from XML and positive (equals this length) for mapping to XML.
// The above example will result in:
// mapping to JSON: { "": {toXML: 0, depth: 3}, "A.L": ["u"], "A.B.C": { "": "v", "D": "w", "E": "x"}, "A.F": { "":"y", "G.H": "z", "I": { "": "t", "J": "s" }}}
// mapping to XML: { "": {toXML: 1, depth: 1}, "u": "0A.0L", "v": { "": "0A.1B.1C", "w": "1D", "x": "2E"}, "y": { "":"0A.3F", "z": "3G.3H", "t": { "": "4I", "s": "4J" }}}
// for internal representation of conditions, please look below to the section where the 'cond' variable is computed.
// Options: object with extra options for processing:
//    - ignoreNS: ignore name spaces when converting XML to JSON
function preprocessMapping(_, mappings, toXML, diags, prototype, options) {
	// splits the part of the XML path into parts (according ".") and assigns the prefix (found by tagtranslation object) of the first rule found for this
	// this function will also add new assignments of tags
	// uses the variable "trans" which points to "tagtranslation" object or subobject of "tagtranslation", and "prefix"
	function addPrefix(x) {
		return x.split(".").map(function(part) {
			var o = trans[part]; // o is a temporary variable
			if (o) { // already assigned with a number
				trans = o;
				return o[""];
			} else {
				o = prefix + part;
				trans = trans[part] = {
					"": o
				};
				return o;
			}
		}).join(".");
	}

	log.info && log.info("preprocessMapping " + toXML);
	var result = {
		"": {
			toXML: 0,
			depth: 1,
		}
	};
	if (options && options.ignoreNS) result[""].ignoreNS = true;
	var tagtranslation = {}; // helps to map the original tag names to the tag names with prefix. Each XML tag name will be assigned to
	// an object which contains the names of the subtags and - as value for the "" key: the name with prefix (used and created by function "addPrefix")
	// In above example, it will be
	// { "A":{"":"0A", "L":{"":"0L"}, "B":{"":"1B", "C":{"":"1C", "D":{"":"1D"}, "E":{"":"2E"}}},"F":{"":"3F","G":{"":"3G","H":{"":"3H"}},"I":{"":"4I","J":{"":"4J"}}}}
	var trans; // will be tagtranslation in the beginning, is used for walking through object structure of tagtranslation 

	// condition searches for either a real condition, e. g. a > 5, or a bracket or an operator AND or OR. 
	// Matching groups: 1 for variable, 2 for comparison operator, 3 comparison variable, 4 bracket, 5 AND operator, 6 OR operator
	var rCOND = /^\s*([\w+\.]+)\s*([!><=]{1,2}|[gtlneq]{2,3})\s*("(?:\\\\|\\"|[^"])*"|'(?:\\\\|\\'|[^'])*'|[\w\.\+\-]+)\s*|^\s*([\(\)])\s*|^\s*(\band\b|\&+)\s*|^\s*(\bor\b|\|+)\s*/;
	var maxDepth = 0; // maximal depth of entries of same repetition group (to avoid infinite recursions)
	var xmlRoot; // Name of XML root element
	if (!mappings.length) _throwError(locale.format(module, "noMapping"), "NOMAPPING")
		// find out fixed length
	var jump = 10; // when index is at least this value, then number will have one more digit
	var leadingZeros = ""; // for leading zeros (when mapping to XML)
	if (toXML) {
		// use the number of rules to find the longest necessary number (in decimal representation) to fit an array index in "mappings"
		while (jump < mappings.length) {
			jump *= 10;
			leadingZeros += "0";
		}
		result[""].toXML = leadingZeros.length + 1;
		jump = 10;
	} else
		jump = mappings.length; // large number 
	var index0 = -1;
	var prefix = ""; // prefix for XML tags containing the index in the mapping array with leading zeros
	mappings.forEach(function(mapping) {
		if (toXML) {
			if (++index0 >= jump) { // number will take one more digit: leadingZeros should be smaller
				jump *= 10;
				leadingZeros = leadingZeros.substr(1);
			}
			prefix = leadingZeros + index0; // with correct number of leading zeros to have fixed length
			if (prefix.length != result[""].toXML) throw new Error("Inconsistent prefix length " + prefix + " " + result.toXML)
		}
		var mXML = mapping.xml;
		var mJSON = mapping.json;
		var protopath = prototype;
		log.info && log.info("Mapping " + mXML + " " + mJSON)
		if (!mXML) {
			if (!mJSON) return; // no mapping information: ignore
			else _throwError(locale.format(module, "empyXmlPath", mJSON), "EMPTYXML")
		}
		if (!mJSON) _throwError(locale.format(module, "emptyJsonPath", mXML), "EMPTYJSON");
		// now both mappings are available
		var object = result;
		// split paths into parts with repetition groups
		// optional elements [0..1] do not count as repetition groups
		var tmpvar = mXML.replace(/\[0\.\.1\]/g, "");
		if (options && options.ignoreNS) tmpvar = tmpvar.replace(/[^\.\:]*\:/g, "");
		var aXML = tmpvar.split(/\[[\w\.]+\]\.?/);
		// ignore namespace part
		// check consistency of XML path
		var part;
		for (var i = 0; i < aXML.length; i++) {
			var part = aXML[i];
			if (!/^(?:[\w\$]+\.)*[\w\$]+$/.exec(part))
				_throwError(locale.format(module, "incorrectXml", mXML, part), "INCORRECTXML");
			if (i === 0) {
				var index = part.indexOf(".");
				if (aXML.length > 1 && index < 0) _throwError(locale.format(module, "rootRepetition", mBase), "ROOTREPETITION");
				var rt = part;
				if (index > 0) rt = part.substr(0, index);
				if (!xmlRoot) {
					xmlRoot = rt;
				} else {
					if (rt !== xmlRoot) _throwError(locale.format(module, "rootDifferent", xmlRoot, mBase), "ROOTDIFFERENT");
				}
			}
		}

		// check consistency of JSON path; use protopath for references
		var aJSON = splitJSONPath(mJSON, prototype);
		if (toXML) {
			var aBase = aJSON;
			var aDest = aXML;
			var mBase = mJSON;
			var mDest = mXML;
		} else {
			var aBase = aXML;
			var aDest = aJSON;
			var mBase = mXML;
			var mDest = mJSON;
		}
		// length comparison (number of nested repetition groups)
		var length = aBase.length;
		if (length !== aDest.length) {
			if (length > aDest.length)
				_throwError(locale.format(module, "destLessGroups", mDest, mBase), "DESTLESSGROUPS");
			_throwError(locale.format(module, "destMoreGroups", mDest, mBase), "DESTMOREGROUPS");
		}
		trans = tagtranslation; // 'trans' is variable for loop; will be used by "addPrefix"
		for (var i = 0; i < length - 1; i++) {
			var pBase = aBase[i];
			var pDest = aDest[i];
			var depth = pBase.replace(/[^\.]+/g, "").length;
			if (depth > maxDepth) maxDepth = depth;
			if (toXML) { // assign numbers of rules to parts
				pDest = addPrefix(pDest);
			}
			var mapped = object[pBase];
			log.debug && log.debug("mapped: " + JSON.stringify(mapped))
			if (mapped) { // mapping already exists. Check whether it is same mapping as before
				if (Array.isArray(mapped)) _throwError(locale.format(module, "fullToGroup", mBase, mDest, pBase, mapped), "FULLTOGROUP");
				if (mapped[""] !== pDest) _throwError(locale.format(module, "groupChange", mBase, mDest, pBase, mapped[""], pDest), "GROUPCHANGE");
				object = mapped;
			} else {
				Object.keys(object).forEach(function(key) {
					if (key.indexOf(pBase) === 0 && key[pBase.length] === ".") _throwError(locale.format(module, "contained2", mBase, mDest, pBase, key), "CONTAINED");
					if (pBase.indexOf(key) === 0 && pBase[key.length] === ".") _throwError(locale.format(module, "contains2", mBase, mDest, pBase, key), "CONTAINS");
				})
				object = object[pBase] = {
					"": pDest
				}; // change value of 'object' for next step in iteration
			}
		}
		// final part has definitive value and is treated differently
		var pBase = aBase[length - 1];
		var pDest = aDest[length - 1];
		pDest = addPrefix(pDest);

		log.debug && log.debug("Last parts " + pBase + " " + pDest)
		var mapped = object[pBase];
		// consider type of mapping
		var max = undefined;
		var type = undefined;
		if (mapping.type) {
			var s;
			if (s = /maxLength:\s*(\d+)/.exec(mapping.type)) {
				max = s[1];
			}
			if (s = /xs:([A-Za-z]+)/.exec(mapping.type)) {
				if (s[1] !== "string") type = s[1].toLowerCase();
			}
		}
		var cond = undefined;
		if (mapping.condition && toXML) {
			var condition = mapping.condition;
			// cond is an array of length divisible by 6, consisting of 6-blocks with the following meaning:
			// - repetition group level of condition variable (0: root level, corresponding to XML root element, 1: one repetition group within root level etc.)
			// - path of condition variable (may contain dots: then from repetition group level there will be object path and not array path to reach variable (only when the prototype contains reference elements)
			// - comparison operator, bitwise combination of 1 equality, 2 strictly bigger, 4 negation, 8 numeric, so e. g. "bigger or equal" for strings is encoded as 3, "strictly smaller" as 7.
			// - comparison constant (with which the condition variable will be compared). The constant has already the correct type.
			// - index (divisible by 6) in array to jump when condition is true (when 0: total condition true, no further execution necessary)
			// - index (divisible by 6) in array to jump when condition is false (when 0: total condition false, no further execution necessary)
			// Example:	given the mapping
			// [{ xml: "A.B[0..n].A", json: "u.v", condition: "(u.a = 2 OR w eq '3') AND (u.c = 4 OR u.d = 5) OR u.e = 6" }]
			// then the corresponding condition will be 
			// [1, "a", 9, 2, 12, 6, 0, "w", 1, 3, 12, 24, 1, "c", 9, 4, 0, 18, 1, "d", 9, 5, 0, 24, 1, "e", 9, 6, 0, 0]
			// Assume that the given JSON is
			// { w:3, u: [{a:4, c:3, d: 4, e:"6", v: "HALLO"}]}
			// This means: When finding out whether the value "HALLO" of attribute v should be written to XML, first
			// compare the value of property "a" in current repetition group as number with 2. The result is FALSE, therefore jump
			// to index 6 (which encodes condition "w eq '3'". Here "w" is at root level, one level above the current level,
			// so there is 0 at index 6 in the array). If the result had been TRUE, the program could have jumped to index 12
			// (where the condition "u.c = 4" is encoded, skipping the condition "w eq '3'"). The value of w (i. e. 3) will 
			// be converted to a string and compared with "3". The result is TRUE, so jump to 12 where the next condition is 
			// encoded. The condition is FALSE, so the next condition "u.d = 5" (encoded starting at index 18) must be evaluated. 
			// If the result had been TRUE, the value 0 at index 16 would have indicated that no further execution is necessary 
			// any more and the final result is also TRUE. The condition "u.d = 5" is also FALSE, so jump to index 24 where the
			// last condition "u.e = 6" is encoded. This condition evaluates to true, so the final result is TRUE (and "HALLO" 
			// will be put into XML). If u.e had had another value, the total condition result would have been FALSE (and "HALLO" 
			// would not have written into XML).
			var cond = [];
			// in the following, the "index of condition" is 0 for the first condition, 1 for the second condition etc.
			// so it does not correspond to the values as stored in the 'cond' array, but the factor 6 has been omitted.
			// in bracketStart and andStart we always store the index before the current condition to make counting easier.
			var bracketStart = [-1]; // Index of condition after which current bracketing level starts
			var andStart = [-2]; // Index of condition after which group of AND operands start. value -2: no such group.
			var bracketLevel = 0; // current bracket level
			var current = -1; // current index of condition (excluding)
			var startIndex = -1; // start of current grouping which is relevant for AND/OR operator
			var linkBefore = true; // beginning or there has been AND/OR operator or '(' before (necessary for syntax check)
			while (condition) {
				// Matching groups: 1 for variable, 2 for comparison operator, 3 for quotation mark (at beginning and end of string), 
				// 4 comparison variable, 5 bracket, 6 AND operator, 7 OR operator
				var r = rCOND.exec(condition);
				log.debug && log.debug("Part of condition " + condition + " " + JSON.stringify(r))
				var errorIndex = mapping.condition.length - condition.length + 1;
				if (!r)
					_throwError(locale.format(module, "wrongCondFormat", mBase, mDest, errorIndex, mapping.condition), "WRONGCONDFORMAT");
				condition = condition.substr(r[0].length);
				if (r[4]) {
					if (r[4] === '(') {
						if (!linkBefore) _throwError(locale.format(module, "wrongCondBrackOpen", mBase, mDest, errorIndex, mapping.condition), "WRONGCONDBRACKOPEN");
						bracketStart[++bracketLevel] = current;
						log.debug && log.debug("Bracket open. Level " + bracketLevel + " CURRENT " + current)
						andStart[bracketLevel] = -2;
					} else {
						if (linkBefore) _throwError(locale.format(module, "wrongCondBrackClose", mBase, mDest, errorIndex, mapping.condition), "WRONGCONDBRACKCLOSE");
						if (bracketLevel === 0) {
							_throwError(locale.format(module, "condBrackets", mBase, mDest, errorIndex, mapping.condition), "CONDBRACKETS")
						}
						startIndex = bracketStart[bracketLevel--];
						log.debug && log.debug("Bracket close. Level " + bracketLevel + " start index " + startIndex)
					}
					continue;
				}
				if (r[5] || r[6]) { // position of AND/OR operator
					var operator = r[5] || r[6];
					if (linkBefore) _throwError(locale.format(module, "wrongCondOp", mBase, mDest, operator, errorIndex, mapping.condition), "WRONGCONDOP");
					linkBefore = true;
				}
				if (r[5]) { // AND operator
					log.debug && log.debug("AND " + startIndex + " " + current + " " + andStart[bracketLevel])
					if (andStart[bracketLevel] < -1) andStart[bracketLevel] = startIndex;
					// put jump condition for TRUE on all elements between start index and current index
					for (var j = startIndex + 1; j <= current; j++)
						if (!cond[6 * j + 4]) cond[6 * j + 4] = 6 * (current + 1);
					log.debug && log.debug("Condition now " + JSON.stringify(cond))
					continue;
				}
				if (r[6]) { // OR operator
					log.debug && log.debug("OR " + startIndex + " " + current + " " + andStart[bracketLevel])
						// put jump condition for FALSE on all elements between start index and current index
					var start = andStart[bracketLevel];
					if (start == -2) start = startIndex;
					for (var j = start + 1; j <= current; j++)
						if (!cond[6 * j + 5]) cond[6 * j + 5] = 6 * (current + 1);
					andStart[bracketLevel] = -2;
					log.debug && log.debug("Condition now " + JSON.stringify(cond))
					continue;
				}
				if (!linkBefore) _throwError(locale.format(module, "wrongCondCond", mBase, mDest, r[0], errorIndex, mapping.condition), "WRONGCONDCOND");
				linkBefore = false;
				startIndex = current;
				current++;
				//				if (beginningBase !== r[1])
				//					_throwError("Mapping from " + mBase + " to " + mDest + ": condition variable " + r[1] + r[2] + " is not in same JSON object", "WRONGCONDVAR");
				var aVar = splitJSONPath(r[1], prototype, mJSON);
				// check whether value is reachable
				log.debug && log.debug("Paths of aVar and aJSON " + aVar.join(":") + " " + aJSON.join(":"))
				for (var i = 0; i < aVar.length - 1; i++) {
					if (aVar[i] !== aJSON[i]) _throwError(locale.format(module, "condVarNotUnique", mBase, mDest, r[1]), "CONDVARNOTUNIQUE");
				}
				var cmp = 0; // bits: 1 equality, 2 strictly bigger, 4 negation, 8 numeric
				switch (r[2]) { // operator
					case '=':
					case '==':
						cmp = 1;
						break; // equality
					case '!=':
					case '<>':
						cmp = 5;
						break; // inequality
					case '>':
						cmp = 2;
						break; // strictly bigger
					case '>=':
						cmp = 3;
						break; // strictly bigger or equal
					case '<':
						cmp = 7;
						break; // not (strictly bigger or equal)
					case '<=':
						cmp = 6;
						break; // not strictly bigger
					case 'ne':
						cmp = 5;
						break; // inequality
					case 'eq':
						cmp = 1;
						break; // equality
					case 'gt':
						cmp = 2;
						break; // strictly bigger
					case 'lt':
						cmp = 7;
						break; // not (strictly bigger or equal)
					case 'ge':
						cmp = 3;
						break; // strictly bigger or equal
					case 'le':
						cmp = 6;
						break; // not strictly bigger
					default:
						_throwError(locale.format(module, "wrongCondOp2", mBase, mDest, r[2]), "WRONGCONDOP");
				}
				// examine constant
				var cnst = r[3];
				if (cnst[0] == '"') { // string
					cnst = cnst.substr(1, cnst.length - 2).replace(/\\(["\\])/g, "$1");
				} else if (cnst[0] == "'") { // string
					cnst = cnst.substr(1, cnst.length - 2).replace(/\\(['\\])/g, "$1");
				} else {
					if (!/^\-?\d+(?:\.\d+)?$/.test(cnst)) {
						_throwError(locale.format(module, "wrongCondConst", mBase, mDest, cnst), "WRONGCONDCONST");
					}
					// number: force numerical comparison
					cmp |= 0x08;
					cnst = +cnst;
				}
				cond.push(aVar.length - 1, aVar[aVar.length - 1], cmp, cnst, 0, 0);
				log.debug && log.debug("Final condition " + JSON.stringify(cond));
			}
		}
		if (linkBefore) _throwError(locale.format(module, "wrongCondEnd", mBase, mDest, mapping.condition), "WRONGCONDEND");
		if (bracketLevel) _throwError(locale.format(module, "wrongCondBrack2", mBase, mDest, mapping.condition), "CONDBRACKETS2");
		if (type || cond) max = max || "0";
		if (mapped) { // mapping already exists. Check whether it is same mapping as before
			if (!Array.isArray(mapped)) _throwError(locale.format(module, "groupToFull", mBase, mDest, mBase, mapped[""]), "GROUPTOFULL");
			if (mapped[0] !== pDest) {
				if (!toXML) {
					if (!Array.isArray(mapped[0])) {
						diags.push({
							$severity: "warning",
							$message: "Path " + mBase + " is mapped to more than one path"
						});
						mapped[0] = [mapped[0], pDest];
					} else
						mapped[0].push(pDest);
				} else {
					if (!cond || mapped.length % 4) // there must be a condition on all entries - then the array consists of blocks of length 4
						_throwError(locale.format(module, "fullChange", mBase, mDest, mapped[0], pDest), "FULLCHANGE");
					mapped.push(pDest, max, type, cond);
				}
			}
		} else {
			Object.keys(object).forEach(function(key) {
					if (key.indexOf(pBase) === 0 && key[pBase.length] === ".") _throwError(locale.format(module, "contained", mBase, mDest, pBase, key), "CONTAINED");
					if (pBase.indexOf(key) === 0 && pBase[key.length] === ".") _throwError(locale.format(module, "contains", mBase, mDest, pBase, key), "CONTAINS");
				})
				// consider the type
			if (cond) object[pBase] = [pDest, max, type, cond];
			else if (type) object[pBase] = [pDest, max, type];
			else if (max) object[pBase] = [pDest, max];
			else object[pBase] = [pDest];
		}

	})
	if (Object.keys(result).length < 2) _throwError(locale.format(module, "noMapping"), "NOMAPPING")
	result[""].depth = maxDepth + 1;
	log.debug && log.debug("Result: " + JSON.stringify(result))
	return result;
}
exports.preprocessMapping = preprocessMapping;

// create nested object if necessary along path, traverse within object and finally assign value.
// example: var o = {}; _assign("a.b", o, 5); _assign("a.c", o, 7)  will change o into o = { a: { b:5}};
//   then into o = { a: {b:5, c: 7}}
function _assign(path, obj, value) {
	var parts = path.split(".");
	var len1 = parts.length - 1;
	var i = 0;
	while (i < len1) {
		var part = parts[i++];
		if (part in obj) obj = obj[part];
		else obj = obj[part] = {}
	}
	obj[parts[len1]] = value;

}

//traverse within object and finally obtain value.
//example: o = { a: {b:5, c: 7}}; _getValue("a.b", o);   will obtain 5. Will return undefined if path does not exist
//then into o = { a: {b:5, c: 7}}
function _getValue(path, obj) {
	log.debug && log.debug("GETVAL " + path + " " + JSON.stringify(obj))
	var parts = path.split(".");
	var len1 = parts.length - 1;
	var i = 0;
	while (i < len1) {
		var part = parts[i++];
		if (part in obj) obj = obj[part];
		else return undefined;
	}
	return obj[parts[len1]];

}

// converts a JavaScript object obtained from jsxml into another object coming from a prototype (or vice versa).
// Function does not perform jsxml transformation itself. Elements in the object which do not occur in the mapping will be
// ignored. Type conversions are done for date and number and boolean, i. e. there will be e. g. numbers in the object
// from prototype rather than the strings from jsxml. Strings which are too long will be truncated for jsxml format.
//
// Parameters:
// input: object to convert (either jsxml object or object corresponding to some prototype). Must be a real object.
// mapping: mapping obtained by `preprocessMapping` above. This also contains information about transformation direction
//
// the result will be the converted object
function convert(input, mapping) {
	log.info && log.info("Convert");
	var result = {};
	var repLevels = [input]; // stores for each repetition group the current object 
	var maxDepth = mapping[""].depth;
	var toXML = mapping[""].toXML;
	var ignoreNS = mapping[""].ignoreNS;
	var rJSON = /(.*?)\./g;

	// traverse the object structure and assign all keys/values again, but in the ordering of the prefixes so that the loop in jsxml 
	// will get them in the right order
	function _stripPrefix(obj) {
		if (Array.isArray(obj)) { // repetition group
			for (var i = obj.length - 1; i >= 0; i--) {
				obj[i] = _stripPrefix(obj[i]);
			}
			return obj;
		} else
		if ((typeof obj) === 'object') { // here we need to re-assign the values
			var keys = Object.keys(obj).sort(); // since all prefixes have identical length, the ordering of the keys is identical to the ordering of the prefixes
			var result = {}; // object where the keys (without prefix) will added in the ordering of the prefixes
			keys.forEach(function(x) {
				result[x.substr(toXML)] = _stripPrefix(obj[x])
			});
			return result;
		} else
			return obj; // strings and numbers: no conversion necessary
	}

	// convert the structure in "element" according to the data in "map", writes it into the object "res".
	// path: path from top level
	// depth: number of object nesting levels (to avoid infinite recursions)
	// repLevel: level within repetition groups. Used to address the correct entry within "repLevels" (necessary to find 
	// the values for a path)
	function _conv(element, map, res, path, depth, repLevel) {
		var keys = Object.keys(element);
		log.debug && log.debug("_conv " + keys.join(",") + " " + JSON.stringify(res) + " " + path + " " + depth);
		var i = keys.length;
		LOOP: while (--i >= 0) {
			var key = keys[i];
			var path2 = path + (ignoreNS ? key.replace(/^.*[\|\:]/, "") : key);
			var mapped = map[path2];
			if (mapped) {
				// element found
				if (Array.isArray(mapped)) {
					CONDITION_LOOP: for (var index = 0; index < mapped.length; index += 4) {
						if (mapped[index + 3]) { // condition
							var cond = mapped[index + 3];
							var j = 0;
							INNER_LOOP: while (true) {
								var cndVariable = _getValue(cond[j + 1], repLevels[cond[j]]);
								// get corresponding value
								var cmp = cond[j + 2];
								var val = ((cmp & 0x08) ? (+cndVariable || 0) : "" + cndVariable);
								log.debug && log.debug("Index " + j + " condition " + cond.slice(j, j + 6) + ": level " + cond[j] + ": " + JSON.stringify(val) + " " + (["", "eq", "gt", "ge", "", "ne", "le", "lt", "", "==", ">", ">=", "", "!=", "<=", "<"])[cmp] + " " + JSON.stringify(cond[j + 3]));

								if (((cmp & 0x01) && (val === cond[j + 3]) || (cmp & 0x02) && (val > cond[j + 3])) ^ !(cmp & 0x04)) {
									// condition not satisfied
									if (cond[j + 5]) j = cond[j + 5];
									else {
										log.debug && log.debug("Condition false")
										continue CONDITION_LOOP; // total condition not satisfied								
									}
								} else { // condition satisfied
									if (cond[j + 4]) j = cond[j + 4];
									else {
										log.debug && log.debug("Condition true")
										break INNER_LOOP; // total condition satisfied																	
									}
								}
							}
						}
						// direct conversion
						var value = element[key];
						if (value instanceof Object && "$value" in value) value = value.$value;
						log.debug && log.debug("Value " + value + " " + path2 + " " + mapped.join(","))
						if (toXML) {
							if (mapped[index + 2]) {
								switch (mapped[index + 2]) {
									case 'date':
										if (!(value instanceof Date)) {
											try {
												value = new Date(value);
											} catch (e) {
												throw new Error("Cannot process date " + value);
											}
										}
										value = value.toISOString().substring(0, 10);
										break;
									case 'datetime':
										if (!(value instanceof Date)) {
											try {
												value = new Date(value);
											} catch (e) {
												throw new Error("Cannot process date " + value);
											}
										}
										value = value.toISOString().substring(0, 19) + "Z";
										break;
									case 'decimal':
										value = value.toString();
										break;

									case 'integer':
									case 'int':
									case 'long':
									case 'positiveinteger':
									case 'negativeInteger':
									case 'nonNegativeInteger':
									case 'nonPositiveInteger':
									case 'short':
									case 'unsignedLong':
									case 'unsignedInt':
									case 'unsignedShort':
										value = value.toString();
										var index0 = value.indexOf('.');
										if (index0 >= 0) value = value.substr(0, index0);
										if (!/^[+-]?\d+$/.test(value)) throw new Error("Cannot process integer " + element[key])
										break;
									case 'boolean':
										value = value.toString();
										if (value !== "false" && value !== "true" && value !== "0" && value !== "1")
											throw new Error("Cannot process boolean " + element[key])
										break;
									default:
										throw new Error("Unknown format " + mapped[index + 2]);
								}
							}
							// follow format directions in mapped[1] and mapped[2]
							if (+mapped[index + 1] && value.length > +mapped[index + 1]) // length restriction
								value = value.substr(0, +mapped[index + 1])
						} else {
							if (mapped[index + 2]) {
								switch (mapped[index + 2]) {
									case 'date':
									case 'datetime':
										value = new Date(value);
										break;
									case 'decimal':
									case 'integer':
									case 'int':
									case 'long':
									case 'positiveinteger':
									case 'negativeInteger':
									case 'nonNegativeInteger':
									case 'nonPositiveInteger':
									case 'short':
									case 'unsignedLong':
									case 'unsignedInt':
									case 'unsignedShort':
										value = Number(value);
										break;
									case 'boolean':
										value = Boolean(value);
										break;
									default:
										throw new Error("Unknown format " + mapped[index + 2]);
								}
							}
						}
						var m = mapped[index];
						if (Array.isArray(m)) {
							m.forEach(function(a) {
								_assign(a, res, value);
							})
						} else
							_assign(m, res, value);
					}
				}
				else {
					// further repetition group
					var elt = element[key];
					if (!Array.isArray(elt)) elt = [elt];
					var arr = [];
					elt.forEach(function(elm) {
						var res0 = {};
						repLevels[repLevel + 1] = elm;
						_conv(elm, mapped, res0, "", maxDepth, repLevel + 1)
						if (Object.keys(res0).length)
							arr.push(res0);
					})
					_assign(mapped[""], res, arr);
				}
			} else {
				if (depth >= 0 && (element[key] instanceof Object)) { // only recurse when max depth is not exceeded
					_conv(element[key], map, res, path2 + ".", depth - 1, repLevel);
				}
			}
		}
	}

	_conv(input, mapping, result, "", maxDepth, 0);
	if (toXML) { // remove the prefixes and assign elements in correct ordering so that JSXML will put them into the right order
		result = _stripPrefix(result);
	}
	if (toXML && Object.keys(result).length === 0) {
		// provide at least a root element for XML
		Object.keys(mapping).some(function(key) {
			if (key) {
				var path;
				if (Array.isArray(mapping[key])) {
					path = mapping[key][0];
				} else {
					path = mapping[key][""];
				}
				path = path.split(".", 1)[0].substr(toXML);
				result[path] = "";
				return true;
			}
		})
	}
	return result;
}

exports.convert = convert;