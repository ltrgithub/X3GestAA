"use strict";
var log = require('syracuse-core').getTracer("edi.xml");

exports.removeSpace = function(str) {
	var i = 0;
	while ([" ", "\n", "\r"].indexOf(str[i]) !== -1 && i++ < str.length) {}

	str = str.substring(i);

	var i = str.length - 1;
	while ([" ", "\n", "\r"].indexOf(str[i]) !== -1 && i-- >= 0) {}
	str = str.substring(0, i + 1);
	return str;
};

function _getSubProperties(propItem) {
	if (!propItem) {
		return null;
	}
	if (typeof propItem === "object" && Object.keys(propItem).length === 0) {
		return null;
	}
	if (propItem.$item && Object.keys(propItem.$item).indexOf("$properties") > 0) {
		return propItem.$item.$properties;
	}

	return _getSubProperties(propItem.$item);
}
exports.getProperty = function(properties, elemKey) {
	return properties && properties[elemKey] || _getSubProperties(properties) && _getSubProperties(properties)[elemKey] || null;
};


function _throwError(message, code) {
	var e = new Error(message);
	e.code = code;
	throw e;
}


// this function takes a mapping between xml paths and paths in the resulting JSON structure
// and preprocesses it to make the transformation process more efficient
// It is assumed that all repetition groups fit together, i. e. a repetition in the XML structure
// exactly corresponds to a repetition in the resulting JSON structure. For the JSON structure
// it is assumed, that each sub-object may be a repetition group
// OK: mappings  A.L           <-> u         type: "base:xs:string,maxLength:50"
//               A.B.C[0..n].D <-> v.w       type: "base:xs:decimal"
//               A.B.C[0..n].E <-> v.x       type: "base:xs:positiveInteger"
//               A.F[0..n].G.H   <-> y.z       type: "base:xs:date"
//               A.F[0..n].I[0..n].J <-> y.t.s type: "base:xs:boolean"
//
// not OK: mappings   A.B <-> u.v
// because no repetition group on the left hand side, but on the right hand side
//
// not OK: mappings A.B.C[0..n].D <-> v.w
//                  A.F[0..n].E     <-> v.x
// because different repetition groups are on the left hand side, the same on right hand side
//
// not OK: mapping X[0..n].D <-> x.y
// because root element is never a repetition group
//
// not OK: mapping X.A <-> u
//                 Y.B <-> v
// because there is only one root element
//
// not OK: mappings A.B <-> u
//                  A.B.C <-> v
// mappings are given as arrays of objects with properties "xml" (for XML path) and "json" (for JSON ppath)
// moreover there is a datatype in "type" property
// there are special elements in the result with key "": at top level some general properties (toXML: boolean value whether
//  mapping destination is XML structure; depth: maximal depth of entries without change of repetition group)
// parameter toXML: generate mapping from JSON structure to XML structure
// the above example will result in:
// mapping to JSON: { "": {toXML: false, depth: 3}, "A.L": ["u"], "A.B.C": { "": "v", "D": "w", "E": "x"}, "A.F": { "":"y", "G.H": "z", "I": { "": "t", "J": "s" }}}
// mapping to XML: { "": {toXML: true, depth: 1}, "u": "A.L", "v": { "": "A.B.C", "w": "D", "x": "E"}, "y": { "":"A.F", "z": "G.H", "t": { "": "I", "s": "J" }}}
// arrayMode: when XML data essentially contain an array of data (with surrounding tags), it will be directly mapped to an array. This only works when there are the same surrounding
// tags (before the first repetition group) for each mapping (not yet implemented)
function preprocessMapping(_, mappings, toXML) {
	log.info && log.info("preprocessMapping " + toXML);
	var result = {
		"": {
			toXML: !!toXML,
			depth: 1
		}
	};
	var rXML = /(.*?)(\[[^\]]+\])\.?/g;
	var rJSON = /(.*?)\./g;
	var maxDepth = 0; // maximal depth of entries of same repetition group (to avoid infinite recursions)
	var xmlRoot; // Name of XML root element
	mappings.forEach(function(mapping) {
		var mXML = mapping.xml;
		var mJSON = mapping.json;
		log.debug && log.debug("Mapping " + mXML + " " + mJSON)
		if (!mXML) {
			if (!mJSON) return; // no mapping information: ignore
			else _throwError("Empty XML path for JSON path " + mJSON, "EMPTYXML")
		}
		if (!mJSON) _throwError("Empty JSON path for XML path " + mXML, "EMPTYJSON");
		// now both mappings are available
		var object = result;
		var sBase;
		var beginningBase = "";
		var beginningDest = "";
		if (toXML) {
			var rBase = rJSON;
			var rDest = rXML;
			var mBase = mJSON;
			var mDest = mXML;
		} else {
			var rBase = rXML;
			var rDest = rJSON;
			var mBase = mXML;
			var mDest = mJSON;
		}
		var firstPart = !toXML;
		rBase.lastIndex = rDest.lastIndex = 0; // initialize regular expressions
		while (sBase = rBase.exec(mBase)) {
			log.debug && log.debug("part of start mapping: " + JSON.stringify(sBase))
			var pBase = sBase[1];
			var depth = pBase.replace(/[^\.]+/g, "").length;
			if (depth > maxDepth) maxDepth = depth;
			if (!pBase) _throwError("Empty part behind " + beginningBase + " in path " + mBase, "EMPTYPARTBASE");
			if (firstPart) {
				firstPart = false;
				if (sBase[2] && depth === 0) _throwError("XML root element cannot be repetition group in path " + mBase, "ROOTREPETITION");
				var rt = pBase.substr(0, pBase.indexOf("."));
				if (!xmlRoot) {
					xmlRoot = rt;
				} else {
					if (rt !== xmlRoot) _throwError("XML root element was " + xmlRoot + " and is different in path " + mBase, "ROOTDIFFERENT");
				}
			}
			var sDest = rDest.exec(mDest);
			log.debug && log.debug("part of dest mapping: " + JSON.stringify(sDest))

			if (!sDest) _throwError("Destination path " + mDest + " contains less repetition groups than " + mBase, "DESTLESSGROUPS");
			var pDest = sDest[1];
			if (!pDest) _throwError("Empty part behind " + beginningDest + " in destination path " + mDest, "EMPTYPARTDEST");
			var mapped = object[pBase];
			log.debug && log.debug("mapped: " + JSON.stringify(mapped))
			if (mapped) { // mapping already exists. Check whether it is same mapping as before
				if (Array.isArray(mapped)) _throwError("Mapping from " + mBase + " to " + mDest + ": Repetition group " + beginningBase + pBase + " has already been treated as full path and was mapped to " + beginningDest + mapped, "FULLTOGROUP");
				if (mapped[""] !== pDest) _throwError("Mapping from " + mBase + " to " + mDest + ": Repetition group " + beginningBase + pBase + " was mapped to " + beginningDest + mapped[""] + " and is now mapped to different group " + beginningDest + pDest, "GROUPCHANGE");
				object = mapped;
			} else {
				Object.keys(object).forEach(function(key) {
					if (key.indexOf(pBase) === 0 && key[pBase.length] === ".") _throwError("Mapping from " + mBase + " to " + mDest + ": Path " + beginningBase + pBase + " is contained in existing path " + beginningBase + key, "CONTAINED");
					if (pBase.indexOf(key) === 0 && pBase[key.length] === ".") _throwError("Mapping from " + mBase + " to " + mDest + ": Path " + beginningBase + pBase + " contains existing path " + beginningBase + key, "CONTAINS");
				})
				object = object[pBase] = {
					"": pDest
				}; // change value of 'object' for next step in iteration
			}
			beginningBase += sBase[0];
			beginningDest += sDest[0];
		}
		// last part
		if (rDest.exec(mDest)) _throwError("Mapping from " + mBase + " to " + mDest + ": destination path contains more repetition groups", "DESTMOREGROUPS");
		var pBase = mBase.substr(beginningBase.length);
		var pDest = mDest.substr(beginningDest.length);
		log.debug && log.debug("last parts: " + pBase + " " + pDest)
		if (!pBase) _throwError("Empty part at the end of base path " + mBase, "EMPTYPARTBASEEND");
		if (!pDest) _throwError("Empty part at the end of destination path " + mDest, "EMPTYPARTDESTEND");
		var mapped = object[pBase];
		if (mapped) { // mapping already exists. Check whether it is same mapping as before
			if (!Array.isArray(mapped)) _throwError("Mapping from " + mBase + " to " + mDest + ": Final path " + mBase + " has already been treated as repetition group and was mapped to " + beginningDest + mapped[""], "GROUPTOFULL");
			if (mapped[0] !== pDest) _throwError("Mapping from " + mBase + " to " + mDest + ": Final path " + mBase + " was mapped to " + beginningDest + pDest + " and is now mapped to different path " + beginningDest + mapped, "FULLCHANGE");
		} else {
			Object.keys(object).forEach(function(key) {
					if (key.indexOf(pBase) === 0 && key[pBase.length] === ".") _throwError("Mapping from " + mBase + " to " + mDest + ": Path " + beginningBase + pBase + " is contained in existing path " + beginningBase + key, "CONTAINED");
					if (pBase.indexOf(key) === 0 && pBase[key.length] === ".") _throwError("Mapping from " + mBase + " to " + mDest + ": Path " + beginningBase + pBase + " contains existing path " + beginningBase + key, "CONTAINS");
				})
				// consider the type
			var max;
			var type;
			if (mapping.type) {
				var s;
				if (s = /maxLength:(\d+)/.exec(mapping.type)) {
					max = s[1];
				}
				if (s = /xs:([A-Za-z]+)/.exec(mapping.type)) {
					if (s[1] !== "string") type = s[1].toLowerCase();
				}
			}
			if (type) max = max || "0";
			if (max) {
				if (type) {
					object[pBase] = [pDest, max, type];
				} else object[pBase] = [pDest, max];
			} else object[pBase] = [pDest];
		}

	})
	if (Object.keys(result).length < 2) _throwError("No mappings defined", "NOMAPPING")
	result[""].depth = maxDepth + 1;
	return result;
}
exports.preprocessMapping = preprocessMapping;
// create nested object if necessary along path, traverse within object and finally assign value.
// example: var o = {}; _assign("a.b", o, 5); _assign("a.c", o, 7)  will change o into o = { a: { b:5}};
//   then into o = { a: {b:5, c: 7}}
function _assign(path, obj, value) {
	var parts = path.split(".");
	var len1 = parts.length - 1;
	var i = 0;
	while (i < len1) {
		var part = parts[i++];
		if (part in obj) obj = obj[part];
		else obj = obj[part] = {}
	}
	obj[parts[len1]] = value;

}


// converts a JavaScript object obtained from jsxml into another object coming from a prototype (or vice versa).
// Function does not perform jsxml transformation itself. Elements in the object which do not occur in the mapping will be
// ignored. Type conversions are done for date and number and boolean, i. e. there will be e. g. numbers in the object
// from prototype rather than the strings from jsxml. Strings which are too long will be truncated for jsxml format.
//
// Parameters:
// input: object to convert (either jsxml object or object corresponding to some prototype). Must be a real object.
// mapping: mapping obtained by `preprocessMapping` above. This also contains information about transformation direction
//
// the result will be the converted object
function convert(input, mapping) {
	log.info && log.info("Convert");
	var result = {};
	var maxDepth = mapping[""].depth;
	var toXML = mapping[""].toXML;
	var rJSON = /(.*?)\./g;

	function _conv(element, map, res, path, depth) {
		var keys = Object.keys(element);
		log.debug && log.debug("_conv " + keys.join(",") + " " + JSON.stringify(res) + " " + path + " " + depth);
		var i = keys.length;
		while (--i >= 0) {
			var key = keys[i];
			var path2 = path + key
			var mapped = map[path2];
			if (mapped) {
				// element found
				if (Array.isArray(mapped)) {
					// direct conversion
					var value = element[key];
					log.debug && log.debug("Value " + value + " " + path2 + " " + mapped.join(","))
					if (toXML) {
						if (mapped[2]) {
							switch (mapped[2]) {
								case 'date':
									if (!(value instanceof Date)) {
										try {
											value = new Date(value);
										} catch (e) {
											throw new Error("Cannot process date " + value);
										}
									}
									value = value.toISOString().substring(0, 10);
									break;
								case 'datetime':
									if (!(value instanceof Date)) {
										try {
											value = new Date(value);
										} catch (e) {
											throw new Error("Cannot process date " + value);
										}
									}
									value = value.toISOString().substring(0, 19) + "Z";
									break;
								case 'decimal':
									value = value.toString();
									break;

								case 'integer':
								case 'int':
								case 'long':
								case 'positiveinteger':
								case 'negativeInteger':
								case 'nonNegativeInteger':
								case 'nonPositiveInteger':
								case 'short':
								case 'unsignedLong':
								case 'unsignedInt':
								case 'unsignedShort':
									value = value.toString();
									var index = value.indexOf('.');
									if (index >= 0) value = value.substr(0, index);
									if (!/^[+-]?\d+$/.test(value)) throw new Error("Cannot process integer " + element[key])
									break;
								case 'boolean':
									value = value.toString();
									if (value !== "false" && value !== "true" && value !== "0" && value !== "1")
										throw new Error("Cannot process boolean " + element[key])
									break;
								default:
									throw new Error("Unknown format " + mapped[2]);
							}
						}
						// follow format directions in mapped[1] and mapped[2]
						if (+mapped[1] && value.length > +mapped[1]) // length restriction
							value = value.substr(0, +mapped[1])
					} else {
						if (mapped[2]) {
							switch (mapped[2]) {
								case 'date':
								case 'datetime':
									value = new Date(value);
									break;
								case 'decimal':
								case 'integer':
								case 'int':
								case 'long':
								case 'positiveinteger':
								case 'negativeInteger':
								case 'nonNegativeInteger':
								case 'nonPositiveInteger':
								case 'short':
								case 'unsignedLong':
								case 'unsignedInt':
								case 'unsignedShort':

									value = Number(value);
									break;
								case 'boolean':
									value = Boolean(value);
									break;
								default:
									throw new Error("Unknown format " + mapped[2]);
							}
						}
					}
					_assign(mapped[0], res, value);
				} else {
					// further repetition group
					var elt = element[key];
					if (!Array.isArray(elt)) elt = [elt];
					var arr = elt.map(function(elm) {
						var res0 = {};
						_conv(elm, mapped, res0, "", maxDepth);
						return res0;
					})
					_assign(mapped[""], res, arr);
				}
			} else {
				if (depth > 0) { // only recurse when max depth is not exceeded
					_conv(element[key], map, res, path2 + ".", depth - 1);
				}
			}
		}
	}

	_conv(input, mapping, result, "", maxDepth);
	return result;
}

exports.convert = convert;