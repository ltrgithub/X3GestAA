"use strict";
var log = require('syracuse-core').getTracer("edi.xml");

var DELIMITER = "|";

exports.removeSpace = function(str) {
	var i = 0;
	while ([" ", "\n", "\r"].indexOf(str[i]) !== -1 && i++ < str.length) {}

	str = str.substring(i);

	var i = str.length - 1;
	while ([" ", "\n", "\r"].indexOf(str[i]) !== -1 && i-- >= 0) {}
	str = str.substring(0, i + 1);
	return str;
};

function _getSubProperties(propItem) {
	if (!propItem) {
		return null;
	}
	if (typeof propItem === "object" && Object.keys(propItem).length === 0) {
		return null;
	}
	if (propItem.$item && Object.keys(propItem.$item).indexOf("$properties") > 0) {
		return propItem.$item.$properties;
	}

	return _getSubProperties(propItem.$item);
}
exports.getProperty = function(properties, elemKey) {
	return properties && properties[elemKey] || _getSubProperties(properties) && _getSubProperties(properties)[elemKey] || null;
};


function _throwError(message, code) {
	var e = new Error(message);
	e.code = code;
	throw e;
}


function _walkpath(protopath, element) {
	log.debug && log.debug("Walk " + element)
	if (protopath.$item && protopath.$item.$properties) protopath = protopath.$item;
	return (protopath.$properties && protopath.$properties[element]);
}


// splits path into groups according to prototype path. When it is used for a condition variable, the parameter mJSON must contain the 
// corresponding path from the mapping.
function splitJSONPath(path, protopath, mJSON) {
	// check consistency of JSON path; use protopath for references
	var aJSON = path.split(/\./);
	for (var i = 0; i < aJSON.length; i++) {
		var part = aJSON[i];
		if (!/^\w+$/.test(part)) {
			if (mJSON)
				_throwError("Mapping with JSON path " + mJSON + ": Part '" + part + "' of condition variable " + path + " does not have correct format", "WRONGCONDVAR");
			else
				_throwError("Mapping with JSON path " + path + ": Part " + part + " does not have correct format", "INCORRECTJSON");
		}
		if (protopath) {
			do {
				protopath = _walkpath(protopath, part);
				if (!protopath) {
					if (mJSON)
						_throwError("Mapping with JSON element " + mJSON + ": part " + part + " of condition variable " + path + " does not exist in prototype", "CONDVARNOTINPROTOTYPE");
					else
						_throwError("Mapping with JSON element " + path + ": part " + part + " does not exist in prototype", "NOTINPROTOTYPE");
				}
				if (!protopath.$type) {
					if (mJSON) _throwError("Mapping with JSON element " + mJSON + ": type for part " + part + " of condition variable " + path + " does not exist in prototype", "WRONGPROTOTYPE");
					else
						_throwError("Mapping with JSON element " + path + ": type for part " + part + " does not exist in prototype", "WRONGPROTOTYPE");
				}
				if (i === aJSON.length - 1 && (protopath.$type === "application/x-reference" || protopath.$type === "application/x-array"))
					if (mJSON) {
						_throwError("Mapping with JSON element " + mJSON + ": Condition variable " + path + ": Reference or array cannot be last part of path", "CONDVARREFERENCEVALUE");
					} else
						_throwError("Mapping with JSON element " + path + ": Reference or array cannot be last part of path", "REFERENCEVALUE");
				if (protopath.$type === "application/x-reference") {
					part = aJSON[i + 1]
					aJSON.splice(i, 2, aJSON[i] + "." + part);
				} else {
					break;
				}
			} while (true);
			log.debug && log.debug("base " + aJSON.join(":"));
		}
	}
	return aJSON;
}


// this function takes a mapping between xml paths and paths in the resulting JSON structure
// and preprocesses it to make the transformation process more efficient
// It is assumed that all repetition groups fit together, i. e. a repetition in the XML structure
// exactly corresponds to a repetition in the resulting JSON structure. For the JSON structure
// it is assumed, that each sub-object may be a repetition group
// OK: mappings  A.L           <-> u         type: "base:xs:string,maxLength:50"
//               A.B.C[0..n].D <-> v.w       type: "base:xs:decimal"
//               A.B.C[0..n].E <-> v.x       type: "base:xs:positiveInteger"
//               A.F[0..n].G.H   <-> y.z       type: "base:xs:date"
//               A.F[0..n].I[0..n].J <-> y.t.s type: "base:xs:boolean"
//
// not OK: mappings   A.B <-> u.v
// because no repetition group on the left hand side, but on the right hand side
//
// not OK: mappings A.B.C[0..n].D <-> v.w
//                  A.F[0..n].E     <-> v.x
// because different repetition groups are on the left hand side, the same on right hand side
//
// not OK: mapping X[0..n].D <-> x.y
// because root element is never a repetition group
//
// not OK: mapping X.A <-> u
//                 Y.B <-> v
// because there is only one root element
//
// not OK: mappings A.B <-> u
//                  A.B.C <-> v
//
// when a prototype is given (must be the full prototype object), the above rule is modified, because when a 
// property is a reference, there is no repetition group. So when u is a reference to an entity with property v,
// the following is allowed:
//   A.B <-> u.v
//
// non-unique mappings:
//
// OK (warning): A.B <-> u
//               A.B <-> v
// the same XML element is mapped to different JSON elements: it will mapped to all of them
//
// OK:           A.B <-> u, condition z = 5
//               A.C <-> u, condition z <> 5
// the same JSON element is mapped to different XML elements with condition. It will be mapped to the first
// element which satisfies the condition.
//
// About condition: All conditions have the format VARIABLE OPERATOR CONSTANT, where VARIABLE comes from
// the JSON path and must be uniquely reachable from the repetition group of the JSON mapping. Example:
// when the JSON structure is like {u:[{a:1, b:2}, {c:3,d:4}], v: 5, x:[{y:1}]}, then from mapping u.a the condition
// variables u.b, u.c, u.d, v are reachable, but not x.y. Prototypes will be respected.
// OPERATOR can be one of = (or ==) < > <= >= != (or <>) for numerical comparisons and 
// eq, lt, gt, le (or leq), ge (or geq), ne (or neq) for string comparisons.
// Constant can be a number or a string. The conditions can be combined with AND (or & or &&) and OR (or | or ||)
// and brackets. AND takes precendence over OR. Example: (u.a > 5 OR u.b = 6) AND u.c = 7.
//
// mappings are given as arrays of objects with properties "xml" (for XML path) and "json" (for JSON ppath)
// moreover there is a datatype in "type" property
// there are special elements in the result with key "": at top level some general properties (toXML: boolean value whether
//  mapping destination is XML structure; depth: maximal depth of entries without change of repetition group)
// parameter toXML: generate mapping from JSON structure to XML structure
// the above example will result in:
// mapping to JSON: { "": {toXML: false, depth: 3}, "A.L": ["u"], "A.B.C": { "": "v", "D": "w", "E": "x"}, "A.F": { "":"y", "G.H": "z", "I": { "": "t", "J": "s" }}}
// mapping to XML: { "": {toXML: true, depth: 1}, "u": "A.L", "v": { "": "A.B.C", "w": "D", "x": "E"}, "y": { "":"A.F", "z": "G.H", "t": { "": "I", "s": "J" }}}
// for internal representation of conditions, please look below to the section where the 'cond' variable is computed.
function preprocessMapping(_, mappings, toXML, diags, prototype) {
	log.info && log.info("preprocessMapping " + toXML);
	var result = {
		"": {
			toXML: !!toXML,
			depth: 1,
		}
	};
	// condition searches for either a real condition, e. g. a > 5, or a bracket or an operator AND or OR. 
	// Matching groups: 1 for variable, 2 for comparison operator, 3 for quotation mark (string), 4 comparison variable, 5 bracket, 6 AND operator, 7 OR operator
	var rCOND = /^\s*([\w+\.]+)\s*([!><=]{1,2}|[gtlneq]{2,3})\s*((["'])(?:\\["']|[^"'])*\4|[\w\.\+\-]+)\s*|^\s*([\(\)])\s*|^\s*(AND|\&+)\s*|^\s*(OR|\|+)\s*/;
	var maxDepth = 0; // maximal depth of entries of same repetition group (to avoid infinite recursions)
	var xmlRoot; // Name of XML root element
	if (!mappings.length) _throwError("No mapping defined", "NOMAPPING")
	mappings.forEach(function(mapping) {
		var mXML = mapping.xml;
		var mJSON = mapping.json;
		var protopath = prototype;
		log.info && log.info("Mapping " + mXML + " " + mJSON)
		if (!mXML) {
			if (!mJSON) return; // no mapping information: ignore
			else _throwError("Empty XML path for JSON path " + mJSON, "EMPTYXML")
		}
		if (!mJSON) _throwError("Empty JSON path for XML path " + mXML, "EMPTYJSON");
		// now both mappings are available
		var object = result;
		// split paths into parts with repetition groups
		// optional elements [0..1] do not count as repetition groups
		var aXML = mXML.replace(/\[0\.\.1\]/g, "").split(/\[[\w\.]+\]\.?/);
		// check consistency of XML path
		var part;
		for (var i = 0; i < aXML.length; i++) {
			var part = aXML[i];
			if (!/^(?:[\w\$]+\.)*[\w\$]+$/.exec(part))
				_throwError("Mapping with XML path " + mXML + ": Part " + part + " does not have correct format", "INCORRECTXML");
			if (i === 0) {
				var index = part.indexOf(".");
				if (aXML.length > 1 && index < 0) _throwError("XML root element cannot be repetition group in path " + mBase, "ROOTREPETITION");
				var rt = part;
				if (index > 0) rt = part.substr(0, index);
				if (!xmlRoot) {
					xmlRoot = rt;
				} else {
					if (rt !== xmlRoot) _throwError("XML root element was " + xmlRoot + " and is different in path " + mBase, "ROOTDIFFERENT");
				}
			}
		}

		// check consistency of JSON path; use protopath for references
		var aJSON = splitJSONPath(mJSON, prototype);
		if (toXML) {
			var aBase = aJSON;
			var aDest = aXML;
			var mBase = mJSON;
			var mDest = mXML;
		} else {
			var aBase = aXML;
			var aDest = aJSON;
			var mBase = mXML;
			var mDest = mJSON;
		}
		// length comparison
		var length = aBase.length;
		if (length !== aDest.length) {
			if (length > aDest.length)
				_throwError("Destination path " + mDest + " contains less repetition groups than " + mBase, "DESTLESSGROUPS");
			_throwError("Destination path " + mDest + " contains more repetition groups than " + mBase, "DESTMOREGROUPS");
		}
		// 
		for (var i = 0; i < length - 1; i++) {
			var pBase = aBase[i];
			var pDest = aDest[i];
			var depth = pBase.replace(/[^\.]+/g, "").length;
			if (depth > maxDepth) maxDepth = depth;
			var mapped = object[pBase];
			log.debug && log.debug("mapped: " + JSON.stringify(mapped))
			if (mapped) { // mapping already exists. Check whether it is same mapping as before
				if (Array.isArray(mapped)) _throwError("Mapping from " + mBase + " to " + mDest + ": Repetition group " + pBase + " has already been treated as last part of path and was mapped to " + mapped, "FULLTOGROUP");
				if (mapped[""] !== pDest) _throwError("Mapping from " + mBase + " to " + mDest + ": Repetition group " + pBase + " was mapped to " + mapped[""] + " and is now mapped to different group " + pDest, "GROUPCHANGE");
				object = mapped;
			} else {
				Object.keys(object).forEach(function(key) {
					if (key.indexOf(pBase) === 0 && key[pBase.length] === ".") _throwError("Mapping from " + mBase + " to " + mDest + ": part of path " + pBase + " is contained in corresponding part of path " + key, "CONTAINED");
					if (pBase.indexOf(key) === 0 && pBase[key.length] === ".") _throwError("Mapping from " + mBase + " to " + mDest + ": part of path " + pBase + " contains existing part of path " + key, "CONTAINS");
				})
				object = object[pBase] = {
					"": pDest
				}; // change value of 'object' for next step in iteration
			}
		}
		// final part has definitive value and is treated differently
		var pBase = aBase[length - 1];
		var pDest = aDest[length - 1];
		log.debug && log.debug("Last parts " + pBase + " " + pDest)
		var mapped = object[pBase];
		// consider type of mapping
		var max = undefined;
		var type = undefined;
		if (mapping.type) {
			var s;
			if (s = /maxLength:\s*(\d+)/.exec(mapping.type)) {
				max = s[1];
			}
			if (s = /xs:([A-Za-z]+)/.exec(mapping.type)) {
				if (s[1] !== "string") type = s[1].toLowerCase();
			}
		}
		var cond = undefined;
		if (mapping.condition && toXML) {
			var condition = mapping.condition;
			// cond is an array of length divisible by 6, consisting of 6-blocks with the following meaning:
			// - repetition group level of condition variable (0: root level, corresponding to XML root element, 1: one repetition group within root level etc.)
			// - path of condition variable (may contain dots: then from repetition group level there will be object path and not array path to reach variable (only when the prototype contains reference elements)
			// - comparison operator, bitwise combination of 1 equality, 2 strictly bigger, 4 negation, 8 numeric, so e. g. "bigger or equal" for strings is encoded as 3, "strictly smaller" as 7.
			// - comparison constant (with which the condition variable will be compared). The constant has already the correct type.
			// - index (divisible by 6) in array to jump when condition is true (when 0: total condition true, no further execution necessary)
			// - index (divisible by 6) in array to jump when condition is false (when 0: total condition false, no further execution necessary)
			// Example:	given the mapping
			// [{ xml: "A.B[0..n].A", json: "u.v", condition: "(u.a = 2 OR w eq '3') AND (u.c = 4 OR u.d = 5) OR u.e = 6" }]
			// then the corresponding condition will be 
			// [1, "a", 9, 2, 12, 6, 0, "w", 1, 3, 12, 24, 1, "c", 9, 4, 0, 18, 1, "d", 9, 5, 0, 24, 1, "e", 9, 6, 0, 0]
			// Assume that the given JSON is
			// { w:3, u: [{a:4, c:3, d: 4, e:"6", v: "HALLO"}]}
			// This means: When finding out whether the value "HALLO" of attribute v should be written to XML, first
			// compare the value of property "a" in current repetition group as number with 2. The result is FALSE, therefore jump
			// to index 6 (which encodes condition "w eq '3'". Here "w" is at root level, one level above the current level,
			// so there is 0 at index 6 in the array). If the result had been TRUE, the program could have jumped to index 12
			// (where the condition "u.c = 4" is encoded, skipping the condition "w eq '3'"). The value of w (i. e. 3) will 
			// be converted to a string and compared with "3". The result is TRUE, so jump to 12 where the next condition is 
			// encoded. The condition is FALSE, so the next condition "u.d = 5" (encoded starting at index 18) must be evaluated. 
			// If the result had been TRUE, the value 0 at index 16 would have indicated that no further execution is necessary 
			// any more and the final result is also TRUE. The condition "u.d = 5" is also FALSE, so jump to index 24 where the
			// last condition "u.e = 6" is encoded. This condition evaluates to true, so the final result is TRUE (and "HALLO" 
			// will be put into XML). If u.e had had another value, the total condition result would have been FALSE (and "HALLO" 
			// would not have written into XML).
			var cond = [];
			// in the following, the "index of condition" is 0 for the first condition, 1 for the second condition etc.
			// so it does not correspond to the values as stored in the 'cond' array, but the factor 6 has been omitted.
			// in bracketStart and andStart we always store the index before the current condition to make counting easier.
			var bracketStart = [-1]; // Index of condition after which current bracketing level starts
			var andStart = [-2]; // Index of condition after which group of AND operands start. value -2: no such group.
			var bracketLevel = 0; // current bracket level
			var current = -1; // current index of condition (excluding)
			var startIndex = -1; // start of current grouping which is relevant for AND/OR operator
			var linkBefore = true; // beginning or there has been AND/OR operator or '(' before (necessary for syntax check)
			while (condition) {
				// Matching groups: 1 for variable, 2 for comparison operator, 3 for quotation mark (at beginning and end of string), 
				// 4 comparison variable, 5 bracket, 6 AND operator, 7 OR operator
				var r = rCOND.exec(condition);
				log.debug && log.debug("Part of condition " + condition + " " + JSON.stringify(r))
				var errorIndex = mapping.condition.length - condition.length + 1;
				if (!r)
					_throwError("Mapping from " + mBase + " to " + mDest + ": condition has wrong format (position " + errorIndex + "): " + mapping.condition, "WRONGCONDFORMAT");
				condition = condition.substr(r[0].length);
				if (r[5]) {
					if (r[5] === '(') {
						if (!linkBefore) _throwError("Mapping from " + mBase + " to " + mDest + ": condition has '(' at wrong place (position " + errorIndex + "): " + mapping.condition, "WRONGCONDBRACKOPEN");
						bracketStart[++bracketLevel] = current;
						log.debug && log.debug("Bracket open. Level " + bracketLevel + " CURRENT " + current)
						andStart[bracketLevel] = -2;
					} else {
						if (linkBefore) _throwError("Mapping from " + mBase + " to " + mDest + ": condition has ')' at wrong place (position " + errorIndex + "): " + mapping.condition, "WRONGCONDBRACKCLOSE");
						if (bracketLevel === 0) {
							_throwError("Mapping from " + mBase + " to " + mDest + ": condition has more closing than opening brackets (position " + errorIndex + "): " + mapping.condition, "CONDBRACKETS")
						}
						startIndex = bracketStart[bracketLevel--];
						log.debug && log.debug("Bracket close. Level " + bracketLevel + " start index " + startIndex)
					}
					continue;
				}
				if (r[6] || r[7]) { // position of AND/OR operator
					if (linkBefore) _throwError("Mapping from " + mBase + " to " + mDest + ": condition has operator " + r[6] + " at wrong place (position " + errorIndex + "): " + mapping.condition, "WRONGCONDOP");
					linkBefore = true;
				}
				if (r[6]) { // AND operator
					log.debug && log.debug("AND " + startIndex + " " + current + " " + andStart[bracketLevel])
					if (andStart[bracketLevel] < -1) andStart[bracketLevel] = startIndex;
					// put jump condition for TRUE on all elements between start index and current index
					for (var j = startIndex + 1; j <= current; j++)
						if (!cond[6 * j + 4]) cond[6 * j + 4] = 6 * (current + 1);
					log.debug && log.debug("Condition now " + JSON.stringify(cond))
					continue;
				}
				if (r[7]) { // OR operator
					log.debug && log.debug("OR " + startIndex + " " + current + " " + andStart[bracketLevel])
						// put jump condition for FALSE on all elements between start index and current index
					var start = andStart[bracketLevel];
					if (start == -2) start = startIndex;
					for (var j = start + 1; j <= current; j++)
						if (!cond[6 * j + 5]) cond[6 * j + 5] = 6 * (current + 1);
					andStart[bracketLevel] = -2;
					log.debug && log.debug("Condition now " + JSON.stringify(cond))
					continue;
				}
				if (!linkBefore) _throwError("Mapping from " + mBase + " to " + mDest + ": condition " + r[0] + " at wrong place (position " + errorIndex + "): " + mapping.condition, "WRONGCONDCOND");
				linkBefore = false;
				startIndex = current;
				current++;
				//				if (beginningBase !== r[1])
				//					_throwError("Mapping from " + mBase + " to " + mDest + ": condition variable " + r[1] + r[2] + " is not in same JSON object", "WRONGCONDVAR");
				var aVar = splitJSONPath(r[1], prototype, mJSON);
				// check whether value is reachable
				log.debug && log.debug("Paths of aVar and aJSON " + aVar.join(":") + " " + aJSON.join(":"))
				for (var i = 0; i < aVar.length - 1; i++) {
					if (aVar[i] !== aJSON[i]) _throwError("Mapping from " + mBase + " to " + mDest + ": condition variable " + r[1] + " not uniquely determined in path", "CONDVARNOTUNIQUE");
				}
				var cmp = 0; // bits: 1 equality, 2 strictly bigger, 4 negation, 8 numeric
				switch (r[2]) { // operator
					case '=':
					case '==':
						cmp = 9;
						break; // equality
					case '!=':
					case '<>':
						cmp = 13;
						break; // inequality
					case '>':
						cmp = 10;
						break; // strictly bigger
					case '>=':
						cmp = 11;
						break; // strictly bigger or equal
					case '<':
						cmp = 15;
						break; // not (strictly bigger or equal)
					case '<=':
						cmp = 14;
						break; // not strictly bigger
					case 'ne':
					case 'neq':
						cmp = 5;
						break; // inequality
					case 'eq':
						cmp = 1;
						break; // equality
					case 'gt':
						cmp = 2;
						break; // strictly bigger
					case 'lt':
						cmp = 7;
						break; // not (strictly bigger or equal)
					case 'ge':
					case 'geq':
						cmp = 3;
						break; // strictly bigger or equal
					case 'le':
					case 'leq':
						cmp = 6;
						break; // not strictly bigger
					default:
						_throwError("Mapping from " + mBase + " to " + mDest + ": wrong operator in condition " + r[2], "WRONGCONDOP");
				}
				// examine constant
				var cnst = r[3];
				if (r[4]) // string
					cnst = cnst.substr(1, cnst.length - 2).replace(/\\(["'])/g, "$1");
				else if (!/^\-?\d+(?:\.\d+)?$/.test(cnst))
					_throwError("Mapping from " + mBase + " to " + mDest + ": wrong constant in condition: " + cnst, "WRONGCONDCONST");
				if (cmp & 0x08) cnst = +cnst
				else cnst = "" + cnst;
				cond.push(aVar.length - 1, aVar[aVar.length - 1], cmp, cnst, 0, 0);
				log.debug && log.debug("Final condition " + JSON.stringify(cond));
			}
		}
		if (linkBefore) _throwError("Mapping from " + mBase + " to " + mDest + ": condition ends unexpectedly: " + mapping.condition, "WRONGCONDEND");
		if (bracketLevel) _throwError("Mapping from " + mBase + " to " + mDest + ": condition has more opening brackets than closing brackets: " + mapping.condition, "CONDBRACKETS2");
		if (type || cond) max = max || "0";
		if (mapped) { // mapping already exists. Check whether it is same mapping as before
			if (!Array.isArray(mapped)) _throwError("Mapping from " + mBase + " to " + mDest + ": Final path " + mBase + " has already been treated as repetition group and was mapped to " + mapped[""], "GROUPTOFULL");
			if (mapped[0] !== pDest) {
				if (!toXML) {
					if (!Array.isArray(mapped[0])) {
						diags.push({
							$severity: "warning",
							$message: "Path " + mBase + " is mapped to more than one path"
						});
						mapped[0] = [mapped[0], pDest];
					} else
						mapped[0].push(pDest);
				} else {
					if (!cond || mapped.length % 4) // there must be a condition on all entries - then the array consists of blocks of length 4
						_throwError("Mapping from " + mBase + " to " + mDest + ": Final part of path " + mapped[0] + " is now mapped to different path " + pDest, "FULLCHANGE");
					mapped.push(pDest, max, type, cond);
				}
			}
		} else {
			Object.keys(object).forEach(function(key) {
					if (key.indexOf(pBase) === 0 && key[pBase.length] === ".") _throwError("Mapping from " + mBase + " to " + mDest + ": Part of path " + pBase + " is contained in existing path " + key, "CONTAINED");
					if (pBase.indexOf(key) === 0 && pBase[key.length] === ".") _throwError("Mapping from " + mBase + " to " + mDest + ": Part of path " + pBase + " contains existing path " + key, "CONTAINS");
				})
				// consider the type
			if (cond) object[pBase] = [pDest, max, type, cond];
			else if (type) object[pBase] = [pDest, max, type];
			else if (max) object[pBase] = [pDest, max];
			else object[pBase] = [pDest];
		}

	})
	if (Object.keys(result).length < 2) _throwError("No mappings defined", "NOMAPPING")
	result[""].depth = maxDepth + 1;
	return result;
}
exports.preprocessMapping = preprocessMapping;
// create nested object if necessary along path, traverse within object and finally assign value.
// example: var o = {}; _assign("a.b", o, 5); _assign("a.c", o, 7)  will change o into o = { a: { b:5}};
//   then into o = { a: {b:5, c: 7}}
function _assign(path, obj, value) {
	var parts = path.split(".");
	var len1 = parts.length - 1;
	var i = 0;
	while (i < len1) {
		var part = parts[i++];
		if (part in obj) obj = obj[part];
		else obj = obj[part] = {}
	}
	obj[parts[len1]] = value;

}

//traverse within object and finally obtain value.
//example: o = { a: {b:5, c: 7}}; _getValue("a.b", o);   will obtain 5. Will return undefined if path does not exist
//then into o = { a: {b:5, c: 7}}
function _getValue(path, obj) {
	log.debug && log.debug("GETVAL " + path + " " + JSON.stringify(obj))
	var parts = path.split(".");
	var len1 = parts.length - 1;
	var i = 0;
	while (i < len1) {
		var part = parts[i++];
		if (part in obj) obj = obj[part];
		else return undefined;
	}
	return obj[parts[len1]];

}

// converts a JavaScript object obtained from jsxml into another object coming from a prototype (or vice versa).
// Function does not perform jsxml transformation itself. Elements in the object which do not occur in the mapping will be
// ignored. Type conversions are done for date and number and boolean, i. e. there will be e. g. numbers in the object
// from prototype rather than the strings from jsxml. Strings which are too long will be truncated for jsxml format.
//
// Parameters:
// input: object to convert (either jsxml object or object corresponding to some prototype). Must be a real object.
// mapping: mapping obtained by `preprocessMapping` above. This also contains information about transformation direction
//
// the result will be the converted object
function convert(input, mapping) {
	log.info && log.info("Convert");
	var result = {};
	var repLevels = [input]; // stores for each repetition group the current object 
	var maxDepth = mapping[""].depth;
	var toXML = mapping[""].toXML;
	var rJSON = /(.*?)\./g;

	function _conv(element, map, res, path, depth, repLevel) {
		var keys = Object.keys(element);
		log.debug && log.debug("_conv " + keys.join(",") + " " + JSON.stringify(res) + " " + path + " " + depth);
		var i = keys.length;
		LOOP: while (--i >= 0) {
			var key = keys[i];
			var path2 = path + key
			var mapped = map[path2];
			if (mapped) {
				// element found
				if (Array.isArray(mapped)) {
					CONDITION_LOOP: for (var index = 0; index < mapped.length; index += 4) {
						if (mapped[index + 3]) { // condition
							var cond = mapped[index + 3];
							var j = 0;
							INNER_LOOP: while (true) {
								var cndVariable = _getValue(cond[j + 1], repLevels[cond[j]]);
								// get corresponding value
								var cmp = cond[j + 2];
								var val = ((cmp & 0x08) ? (+cndVariable || 0) : "" + cndVariable);
								log.debug && log.debug("Index " + j + " condition " + cond.slice(j, j + 6) + ": level " + cond[j] + ": " + JSON.stringify(val) + " " + (["", "eq", "gt", "ge", "", "ne", "le", "lt", "", "==", ">", ">=", "", "!=", "<=", "<"])[cmp] + " " + JSON.stringify(cond[j + 3]));

								if (((cmp & 0x01) && (val === cond[j + 3]) || (cmp & 0x02) && (val > cond[j + 3])) ^ !(cmp & 0x04)) {
									// condition not satisfied
									if (cond[j + 5]) j = cond[j + 5];
									else {
										log.debug && log.debug("Condition false")
										continue CONDITION_LOOP; // total condition not satisfied								
									}
								} else { // condition satisfied
									if (cond[j + 4]) j = cond[j + 4];
									else {
										log.debug && log.debug("Condition true")
										break INNER_LOOP; // total condition satisfied																	
									}
								}
							}
						}
						// direct conversion
						var value = element[key];
						log.debug && log.debug("Value " + value + " " + path2 + " " + mapped.join(","))
						if (toXML) {
							if (mapped[index + 2]) {
								switch (mapped[index + 2]) {
									case 'date':
										if (!(value instanceof Date)) {
											try {
												value = new Date(value);
											} catch (e) {
												throw new Error("Cannot process date " + value);
											}
										}
										value = value.toISOString().substring(0, 10);
										break;
									case 'datetime':
										if (!(value instanceof Date)) {
											try {
												value = new Date(value);
											} catch (e) {
												throw new Error("Cannot process date " + value);
											}
										}
										value = value.toISOString().substring(0, 19) + "Z";
										break;
									case 'decimal':
										value = value.toString();
										break;

									case 'integer':
									case 'int':
									case 'long':
									case 'positiveinteger':
									case 'negativeInteger':
									case 'nonNegativeInteger':
									case 'nonPositiveInteger':
									case 'short':
									case 'unsignedLong':
									case 'unsignedInt':
									case 'unsignedShort':
										value = value.toString();
										var index0 = value.indexOf('.');
										if (index0 >= 0) value = value.substr(0, index0);
										if (!/^[+-]?\d+$/.test(value)) throw new Error("Cannot process integer " + element[key])
										break;
									case 'boolean':
										value = value.toString();
										if (value !== "false" && value !== "true" && value !== "0" && value !== "1")
											throw new Error("Cannot process boolean " + element[key])
										break;
									default:
										throw new Error("Unknown format " + mapped[index + 2]);
								}
							}
							// follow format directions in mapped[1] and mapped[2]
							if (+mapped[index + 1] && value.length > +mapped[index + 1]) // length restriction
								value = value.substr(0, +mapped[index + 1])
						} else {
							if (mapped[index + 2]) {
								switch (mapped[index + 2]) {
									case 'date':
									case 'datetime':
										value = new Date(value);
										break;
									case 'decimal':
									case 'integer':
									case 'int':
									case 'long':
									case 'positiveinteger':
									case 'negativeInteger':
									case 'nonNegativeInteger':
									case 'nonPositiveInteger':
									case 'short':
									case 'unsignedLong':
									case 'unsignedInt':
									case 'unsignedShort':
										value = Number(value);
										break;
									case 'boolean':
										value = Boolean(value);
										break;
									default:
										throw new Error("Unknown format " + mapped[index + 2]);
								}
							}
						}
						var m = mapped[index];
						if (Array.isArray(m)) {
							m.forEach(function(a) {
								_assign(a, res, value);
							})
						} else
						//						try {
							_assign(m, res, value);
						/*} catch (e) {
							console.log("LLLLLLLLLLLLLLL"+JSON.stringify(mapped)+" "+index)
							throw e;
						}*/
					}
				}
				else {
					// further repetition group
					var elt = element[key];
					if (!Array.isArray(elt)) elt = [elt];
					var arr = [];
					elt.forEach(function(elm) {
						var res0 = {};
						repLevels[repLevel + 1] = elm;
						_conv(elm, mapped, res0, "", maxDepth, repLevel + 1)
						if (Object.keys(res0).length)
							arr.push(res0);
					})
					_assign(mapped[""], res, arr);
				}
			} else {
				if (depth > 0) { // only recurse when max depth is not exceeded
					_conv(element[key], map, res, path2 + ".", depth - 1, repLevel);
				}
			}
		}
	}

	_conv(input, mapping, result, "", maxDepth, 0);
	if (toXML && Object.keys(result).length === 0) {
		// provide at least a root element
		Object.keys(mapping).some(function(key) {
			if (key) {
				var path;
				if (Array.isArray(mapping[key])) {
					path = mapping[key][0];
				} else {
					path = mapping[key][""];
				}
				path = path.split(".", 1)[0];
				result[path] = "";
				return true;
			}
		})
	}
	return result;
}

exports.convert = convert;