"use strict";
var Parser = require("etna-engine/lib/parser").Parser;

exports.generate = function(node) {
	//console.log("jmqlgen:"+JSON.stringify(node));

	function genOperator(o, op, ident, value) {
		o = o || {};
		if (op === '$eq') {
			o[ident] = value;

		} else {
			o[ident] = o[ident] || {};
			o[ident][op] = value;
		}
		return o;
	};

	function genLike(o, ident, value) {
		o = o || {};
		o[ident] = o[ident] || {};
		o[ident].$regex = value;
		o[ident].$options = "i";
		return o;
	}

	function cmpOperator(op, rop) {
		return function(node, o) {
			if (node.args.length === 2) {
				if (node.args[0].tag === 'IDENT') return genOperator(o, op, node.args[0].value, node.args[1].value);
				if (node.args[1].tag === 'IDENT') return genOperator(o, rop, node.args[1].value, node.args[0].value);
				if (op === '$eq' && node.args[0].tag === 'FCALL') {
					switch (node.args[0].name) {
						case 'LEFT$':
							return genLike(o, node.args[0].args[0].value, node.args[1].value + ".*");
					}
				}
			}
		};
	}
	var operators = {
		EQ: cmpOperator("$eq", "$eq"),
		GE: cmpOperator("$gte", "$lte"),
		GT: cmpOperator("$gt", "$lt"),
		LE: cmpOperator("$lte", "$gte"),
		LT: cmpOperator("$lt", "$gt"),
		AND: function(node) {
			return node.args.reduce(function(r, arg) {
				var fn = operators[arg.op];
				if (fn) fn(arg, r);
				return r;
			}, {});
		}
	};

	function gen(node) {
		var fn = operators[node.op];
		if (fn) return fn(node);
	}
	return gen(node);
};

exports.x3ToJmql = function(expression) {
	var parsed = new Parser("CONDITION=(" + expression + ")").parse();
	return exports.generate(parsed.node.statements[0].rhs);
};