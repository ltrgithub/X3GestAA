"use strict";

var util = require("etna-supervisor/lib/util");
var generic = require("ez-streams").devices.generic;

module.exports = {
	collectionName: 'ATABLE',
	keyName: 'CODFIC',
	constructor: util.defineClass(function(superv, data) {
		this.supervisor = superv;
		this.data = data;
		this.sql = {};
	}, null, {
		init: function(_) {
			this.columns = {};
			this.data.COLUMNS.forEach_(_, function(_, data) {
				this.columns[data.CODZONE] = this.supervisor.new(_, 'Column', this, data);
			}, this);
			this.indexes = this.data.INDEXES.map_(_, function(_, data) {
				return this.supervisor.new(_, 'Index', this, data);
			}, this);
			return this;
		},
		name: {
			get: function() {
				return this.data.CODFIC;
			}
		},
		abbrev: {
			get: function() {
				return this.data.ABRFIC;
			}
		},
		column: function(name) {
			return this.columns[name];
		},
		index: function(name) {
			return this.indexes.filter(function(ind) {
				return ind.name === name;
			})[0];
		},
		reader: function(_, cnx, index, vals, where, raw) {
			var columns = this.columns;
			var param = this.supervisor.sqlDriver.param;
			var tableNames = [this.name + ' T'];
			var columnNames = [];
			var wheres = where && where.sql ? [where.sql] : [];
			var params = where && where.sql ? where.params.slice(0) : [];
			Object.keys(columns).forEach_(_, function(_, name) {
				columns[name].getSql(_, columnNames, tableNames, wheres, params, null, raw);
			});
			var indexColNames;
			if (index) {
				indexColNames = index.sqlNames(_);
				var indexCols = indexColNames.slice(0, vals.length);
				indexCols.forEach(function(name, i) {
					params.push(vals[i]);
					wheres.push(name + "=" + param(params.length - 1));
				}, this);
			}
			var sql = "select " + columnNames.join(',') + " from " + tableNames.join(',');
			if (wheres.length) sql += " where (" + wheres.join(') and (') + ')';
			if (index) sql += " order by " + indexColNames;
			return this.supervisor.sqlReader(_, cnx, sql, params);
		},
		deleteIndexes: function(_, ifExists) {
			this.indexes.forEach_(_, function(_, index) {
				try {
					var sql = this.supervisor.sqlDriver.dropIndexSql(this.name + "_" + index.name, this.name);
					this.supervisor.executeSql(_, sql);
				} catch (ex) {
					// do not fail, just report error
					if (ifExists && this.supervisor.sqlDriver.isIndexNotFound(ex)) return; // console.error(index.name + ": " + ex.message);
					else throw ex;
				}
			}, this);
		},
		createIndexes: function(_) {
			this.indexes.forEach_(_, function(_, index) {
				var sql = "create index " + this.name + "_" + index.name + //
				" on " + this.name + " (" + index.columns.map(function(col) {
					return col.name + '_0';
				}) + ")"
				this.supervisor.executeSql(_, sql);
			}, this);
		},
		clear: function(_) {
			this.supervisor.executeSql(_, "delete from " + this.name);
		},
		computeColumnNames: function(_) {
			if (!this.sql.columnNames) {
				var names = [];
				var descs = [];
				var primKey = this.indexes[0];
				var param = this.supervisor.sqlDriver.param;
				Object.keys(this.columns).forEach_(_, function(_, name) {
					var column = this.columns[name];
					column.getSql(_, names, null, null, null, descs, true);
				}, this);
				this.sql.columnNames = names.map(function(name) {
					return name.replace(/T\./g, ''); // remove leading T.
				});
				this.sql.columnDescs = descs;
				var insertVars = [],
					updateSets = [],
					updateWheres = [];
				descs.forEach(function(desc, i) {
					insertVars.push(param(i));
					if (primKey.hasColumn(desc.name)) {
						updateWheres.push(desc.name + "_" + (desc.index || 0) + "=" + param(desc.offset));
					} else {
						updateSets.push(desc.name + "_" + (desc.index || 0) + "=" + param(desc.offset));
					}
				}, this);
				this.sql.insertVars = insertVars.join(',');
				this.sql.updateSets = updateSets.join(',');
				this.sql.updateWheres = updateWheres.join(' and ');
				this.sql.deleteWheres = primKey.columns.map(function(column, i) {
					return "(" + column.name + "_0=" + param(i) + ")"; 
				}, this).join(' and ');
			}
		},
		insert: function(_, data) {
			this.computeColumnNames(_);
			var values = this.sql.columnDescs.map(function(name, i) {
				var desc = this.sql.columnDescs[i];
				var v = desc.index == null ? data[desc.name] : data[desc.name][desc.index];
				return v === undefined ? null : v;
			}, this);
			var sql = "insert into " + this.name + " (" + this.sql.columnNames.join(',') + //
			") values (" + this.sql.insertVars + ")";
			this.supervisor.executeSql(_, sql, values);
		},
		update: function(_, data) {
			this.computeColumnNames(_);
			var values = this.sql.columnDescs.map(function(name, i) {
				var desc = this.sql.columnDescs[i];
				var v = desc.index == null ? data[desc.name] : data[desc.name][desc.index];
				return v === undefined ? null : v;
			}, this);
			var sql = "update " + this.name + " T set " + this.sql.updateSets + //
			" where " + this.sql.updateWheres;
			this.supervisor.executeSql(_, sql, values);
		},
		delete: function(_, data) {
			this.computeColumnNames(_);
			var values = this.indexes[0].columns.map(function(column, i) {
				var v = data[column.name];
				return v === undefined ? null : v;
			}, this);
			var sql = "delete from " + this.name + " where " + this.sql.deleteWheres;
			this.supervisor.executeSql(_, sql, values);
		},
		loadRecords: function(_, index, vals, max, where, raw) {
			if (max == null || max < 0) max = Infinity;
			var self = this;
			return this.supervisor.sqlDriver.withConnection(_, function(_, cnx) {
				return self.reader(_, cnx, index, vals, where, raw).limit(max).toArray(_);
			});
		},
		convertIn: function(data) {
			Object.keys(this.columns).forEach(function(name) {
				var col = this.columns[name];
				data[name] = col.convertIn(data[name]);
			}, this);
		},
		writer: function(_, cnx) {
			this.computeColumnNames(_);
			var sql = "insert into " + this.name + " (" + this.sql.columnNames.join(',') + //
			") values (" + this.sql.insertVars + ")";
			var writer = this.supervisor.sqlDriver.writer(cnx, sql);
			var self = this;
			var wr = writer.pre.map(function(_, data) {
				wr.count++;
				return self.sql.columnDescs.map(function(name, i) {
					var desc = self.sql.columnDescs[i];
					var v = desc.index == null ? data[desc.name] : data[desc.name][desc.index];
					return v === undefined ? null : v;
				});
			});
			wr.count = 0;
			return wr;
		},
		drop: function(_, ifExists) {
			try {
				return this.supervisor.executeSql(_, "drop table " + this.name);
			} catch (ex) {
				if (ifExists && this.supervisor.sqlDriver.isTableNotFound(ex)) return;
				else throw ex;
			}
		},
		create: function(_, exists) {
			//trace && trace("creating table " + table.CODFIC);
			if (exists) this.drop(_);
			var sql = "create table " + this.name + " (" + Object.keys(this.columns).map(function(name) {
				var col = this.columns[name];
				return col.sqlDef();
			}, this).filter(function(def) {
				return def;
			}).join(',') + ")";
			this.supervisor.executeSql(_, sql);
		},
	}),
};