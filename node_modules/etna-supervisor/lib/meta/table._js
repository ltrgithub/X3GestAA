"use strict";

var generic = require("ez-streams").devices.generic;
var bcd = require('etna-engine/lib/runtime/bcd');
var glob = require('streamline/lib/globals');
var tdatetime = require('etna-engine/lib/runtime/tdatetime');

var util = require("etna-supervisor/lib/util");
var constants = require("etna-supervisor/lib/constants");

var tracerDbms = require("syracuse-trace/lib/helper").getTracer("etna.dbms");

module.exports = {
	collectionName: 'ATABLE',
	keyName: 'CODFIC',
	constructor: util.defineClass(function(superv, data) {
		this.supervisor = superv;
		this.data = data;
		this.sql = {};
		this.abrev = 'T';
	}, null, {
		init: function(_) {
			this.columns = {};
			this.data.COLUMNS
				.filter(function(data) {
					return !/^AX[123X]/.test(data.CODTYP);
				})
				.forEach_(_, function(_, data) {
					this.columns[data.CODZONE] = this.supervisor.new(_, 'Column', this, data);
				}, this);
			this.indexes = this.data.INDEXES.map_(_, function(_, data) {
				return this.supervisor.new(_, 'Index', this, data);
			}, this);
			return this;
		},
		name: {
			get: function() {
				return this.data.CODFIC;
			}
		},
		abbrev: {
			get: function() {
				return this.data.ABRFIC;
			}
		},
		column: function(name) {
			return this.columns[name];
		},
		index: function(name) {
			return this.indexes.filter(function(ind) {
				return ind.name === name;
			})[0];
		},
		reader: function(_, index, vals, where, raw, options) {
			var columns = this.columns;
			options = options || [];

			var param = this.supervisor.sqlDriver.param;
			var tableNames = [this.name + ' T'];
			var columnNames = [];
			var wheres = where && where.sql ? [where.sql] : [];
			var params = where && where.sql ? where.params.slice(0) : [];
			var sqlOpts = {};
			Object.keys(columns).forEach_(_, function(_, name) {
				columns[name].getSql(_, columnNames, tableNames, wheres, params, null, null, raw, sqlOpts);
			});
			var indexColNames;
			if (index) {
				indexColNames = index.sqlNames();
				var indexCols = indexColNames.slice(0, vals.length);
				indexCols.forEach(function(name, i) {
					params.push(vals[i]);
					wheres.push(name + "=" + param(params.length - 1));
				}, this);
			}
			var sql = "select ";
			if (options.limit)
				sql += "top " + options.limit + " ";
			sql += columnNames.join(',') + " from " + tableNames.join(',');
			if (wheres.length) sql += " where (" + wheres.join(') and (') + ')';
			if (index) sql += " order by " + indexColNames;

			return this.supervisor.sqlReader(_, sql, params, sqlOpts);
		},
		deleteIndexes: function(_, ifExists) {
			this.indexes.forEach_(_, function(_, index) {
				try {
					var sql = this.supervisor.sqlDriver.dropIndexSql(this.name + "_" + index.name, this.name);
					this.supervisor.executeSql(_, sql);
				} catch (ex) {
					// do not fail, just report error
					if (ifExists && this.supervisor.sqlDriver.isIndexNotFound(ex)) return;
					tracerDbms.error && tracerDbms.error(index.name + ": " + ex.message);
					//else throw ex;
				}
			}, this);
		},
		createIndexes: function(_) {
			this.indexes.forEach_(_, function(_, index) {
				var sql = "create index " + this.name + "_" + index.name + //
				" on " + this.name + " (" + index.columns.map(function(col) {
					return col.name + '_0';
				}) + ")";
				this.supervisor.executeSql(_, sql);
			}, this);
		},
		clear: function(_) {
			this.supervisor.executeSql(_, "delete from " + this.name);
		},
		computeColumnNames: function(_) {
			if (!this.sql.columnNames) {
				var names = [];
				var descs = [];
				var primKey = this.indexes[0];
				var param = this.supervisor.sqlDriver.param;

				// Add primKey first (in the correct order)...
				var columns = primKey.columns.map(function(column) {
					return column.name;
				});
				// ... and add other columns
				Object.keys(this.columns).forEach(function(column) {
					if (!primKey.hasColumn(column)) {
						columns.push(column);
					}
				});
				//console.error("columns:"+columns);

				columns.forEach_(_, function(_, name) {
					var column = this.columns[name];
					column.getSql(_, names, null, null, null, descs, true);
				}, this);

				this.sql.columnNames = names.map(function(name) {
					return name.replace(/T\./g, ''); // remove leading T.
				});
				this.sql.columnDescs = descs;
				var insertVars = [],
					updateSets = [],
					updateWheres = [];

				var offset_u = 0;
				var offset_d = 0;
				descs.forEach(function(desc, i) {
					insertVars.push(param(i));
					if (!primKey.hasColumn(desc.name)) {
						updateSets.push(desc.name + "_" + (desc.index || 0) + "=" + param(offset_u++));
					}
				}, this);
				this.sql.insertVars = insertVars.join(',');
				this.sql.updateSets = updateSets.join(',');
				this.sql.deleteWheres = primKey.columns.map(function(column) {
					return "(" + column.name + "_0=" + param(offset_d++) + ")";
				}, this).join(' and ');
				this.sql.updateWheres = primKey.columns.map(function(column) {
					return "(" + column.name + "_0=" + param(offset_u++) + ")";
				}, this).join(' and ');
				this.sql.updtickWhere_u = "(UPDTICK_0 = " + param(offset_u++) + ')';
				this.sql.updtickWhere_d = "(UPDTICK_0 = " + param(offset_d++) + ')';
			}
		},
		getInstanceKey: function(_, instance) {
			return this.indexes[0].columns.map_(_, function(_, column) {
				return instance.slot(_, column.name)._get(_, true);
			}, this).join('~');
		},

		insert: function(_, instance) {
			tracerDbms.debug && tracerDbms.debug("table.insert for " + instance.class.name);
			this.computeColumnNames(_);
			var values = this.sql.columnDescs.reduce_(_, function(_, r, desc) {
				r.push(instance.getSql(_, desc));
				return r;
			}, [], this);

			var sql = "insert into " + this.name + " (" + this.sql.columnNames.join(',') + //
			") values (" + this.sql.insertVars + ")";

			try {
				return this.supervisor.executeSql(_, sql, values);
			} catch (e) {
				tracerDbms.error && tracerDbms.error("Exception in table.insert:" + e.stack);

				throw new Error(this.supervisor.loadMessParams(_, 140, 65,
					" " + this.getInstanceKey(_, instance), // " " for unit tests only !
					this.name, (this.supervisor.sqlDriver.isUniqueViolated && this.supervisor.sqlDriver.isUniqueViolated(e)) ?
					this.supervisor.loadMessParams(_, 100, 22) :
					e.message));
			}
		},
		update: function(_, instance) {
			tracerDbms.debug && tracerDbms.debug("table.update for " + instance.class.name);
			this.computeColumnNames(_);
			var primKey = this.indexes[0];
			var values = [];
			var valuesWhere = [];

			this.sql.columnDescs.forEach_(_, function(_, desc) {
				var dest = primKey.hasColumn(desc.name) ? valuesWhere : values;
				dest.push(instance.getSql(_, desc));
			});
			// + updtick
			valuesWhere.push(instance.get(_, "UPDTICK", true));

			var values = values.concat(valuesWhere);
			var sql = "update " + this.name + " T set " + this.sql.updateSets + //
			" where " + this.sql.updateWheres + ' and ' + this.sql.updtickWhere_u;
			return this.supervisor.executeSql(_, sql, values);
		},
		delete: function(_, instance) {
			this.computeColumnNames(_);
			var values = this.indexes[0].columns.map_(_, function(_, column) {
				return instance.slot(_, column.name)._getSql(_);
			}, this);

			// + updtick
			values.push(instance.get(_, "UPDTICK", true));

			var sql = "delete from " + this.name + " where " + this.sql.deleteWheres + ' and ' + this.sql.updtickWhere_d;
			return this.supervisor.executeSql(_, sql, values);
		},
		loadRecords: function(_, index, vals, max, where, raw) {
			if (max == null || max < 0) max = Infinity;
			var self = this;
			return self.reader(_, index, vals, where, raw).limit(max).toArray(_);
		},
		convertIn: function(data) {
			Object.keys(this.columns).forEach(function(name) {
				var col = this.columns[name];
				data[name] = col.convertIn(data[name]);
			}, this);
		},
		writer: function(_, cnx) {
			this.computeColumnNames(_);
			var sql = "insert into " + this.name + " (" + this.sql.columnNames.join(',') + //
			") values (" + this.sql.insertVars + ")";
			var writer = this.supervisor.sqlDriver.writer(_, cnx, sql);
			var self = this;
			var wr = writer.pre.map(function(_, data) {
				wr.count++;
				return self.sql.columnDescs.map(function(name, i) {
					var desc = self.sql.columnDescs[i];
					var v = desc.index == null ? data[desc.name] : data[desc.name][desc.index];
					return v === undefined ? null : (desc.type ? desc.type.toSql(v) : v);
				});
			});
			wr.count = 0;
			return wr;
		},
		drop: function(_, ifExists) {
			try {
				return this.supervisor.executeSql(_, "drop table " + this.name);
			} catch (ex) {
				if (ifExists && this.supervisor.sqlDriver.isTableNotFound(ex)) return;
				else throw ex;
			}
		},
		create: function(_, exists) {
			//trace && trace("creating table " + table.CODFIC);
			if (exists) this.drop(_);
			var sql = "create table " + this.name + " (UPDTICK_0 NUMBER(10)," + Object.keys(this.columns).map(function(name) {
				var col = this.columns[name];
				return col.sqlDef();
			}, this).filter(function(def) {
				return def;
			}).join(',') + ")";
			this.supervisor.executeSql(_, sql);
		},
		links: function(_) {
			this._links = this._links || this.supervisor.new(_, 'tableLinks', this.name);
			return this._links;
		},
		description: function(_) {
			return this.supervisor.loadText(_, this.data.INTITFIC);
		},
		getRecordDescription: function(_, record) {
			// Set a default value *
			var description = "";
			if (this.data.INTIT) {
				description = record[this.data.INTIT] || description;
				if (this.data.INTITTYPE) {
					if (this.data.INTITTYPE === "ATX") {
						description = this.supervisor.loadText(_, this.data.INTIT);
					} else if (/^AX[123X]/.test(this.data.INTITTYPE)) {
						//    Read [AXX_]AXX0  = LS(0).TABLE;LS(0).INTIT;POBJ.ACTX.LAN;RECORDKEYS(1);RECORDKEYS(2)
						//    If !fstat : RECORDDESC = [F:AXX_]TEXTE : Endif
						var actx = glob.context.x3session.actx;
						var columns = this.table.indexes[0].columns;
						var param = _this.supervisor.sqlDriver.param;
						var params = [];
						var wheres = [];

						params.push(this.name);
						wheres.push("CODFIC_0=" + param(params.length - 1));
						params.push(this.data.INTIT);
						wheres.push("ZONE_0=" + param(params.length - 1));
						params.push(actx.$LAN(_));
						wheres.push("LANGUE_0=" + param(params.length - 1));
						params.push(record[columns[0]]);
						wheres.push("IDENT1_0=" + param(params.length - 1));
						params.push(record[columns[1]]);
						wheres.push("IDENT2_0=" + param(params.length - 1));
						var sql = "select TEXTE_0 from ATEXTRA  where (" + wheres.join(" and ") + ")";

						rs = self.supervisor.sqlReader(_, sql, params).toArray(_);
						description = (rs && rs.length) ? rs[0].TEXTE : "";
					}
				}
			}
			return description;
		}
	}),
};