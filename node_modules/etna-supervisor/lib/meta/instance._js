"use strict";

var util = require("etna-supervisor/lib/util");
var glob = require('streamline/lib/globals');
var tuuid = require('etna-engine/lib/runtime/tuuid');
var X3Error = require('etna-engine/lib/runtime/errors').X3Error;
var tdatetime = require('etna-engine/lib/runtime/tdatetime');

var attributes = require("etna-supervisor/lib/attributes");
var tracerJs = require("syracuse-trace/lib/helper").getTracer("etna.supervisor");

var baseInstance = require("etna-supervisor/lib/meta/baseInstance");

var tmp;
var Instance = exports.constructor = baseInstance.defineClass(function(superv, clas, parent, slots) {
	var _this = this;
	this.supervisor = superv;
	this.meta = this.class = clas;
	if (this.class) {
		this.index = this.class.index;
		Object.keys(this.class.stdMethods).forEach(function(stdMethod) {
			_this[stdMethod] = _this["$" + stdMethod];
		});
	} else {
		this.index = {};
	}
	this.properties = clas ? clas.properties : {};
	this.parent = parent;
	this.slots = slots || {};
	this.record;
	this.colnIndex;
}, null, {
	$$type: {
		get: function() {
			return "Instance";
		}
	},
	afterCreate: function(_) { // for $create action, not $edit
		return this;
	},
	clone: function() {
		var from = this;
		var to = new Instance(from.supervisor, from.class, from.parent);
		to.properties = from.properties;

		to.slots = Object.keys(from.slots).reduce(function(r, name) {
			var p = from.slots[name];
			if (p.snapshots) {
				r[name] = p;
			} else {
				r[name] = (p.clone && p.clone(this)) || p;
			}
			return r;
		}, {});

		to.diagnoses = [];
		to.snapshotof = from;
		attributes.clone(from, to);
		return to;
	},
	getChildren: function() {
		return this.slots;
	},
	updateProperty: function(from, to) {
		var _this = this;
		Object.keys(_this.slots).some(function(property) {
			if (_this.slots[property] == from) {
				_this.slots[property] = to;
				return true;
			}
			return false;
		});
	},
	revertTo: function() {
		if (!this.snapshotof) return this;
		var to = this.snapshotof;
		var from = this;

		Object.keys(from.slots)
			.filter(function(property) {
				return !!from.slots[property] && from.slots[property].revertTo;
			})
			.forEach(function(property) {
				var fromChild = from.slots[property];
				var toChild = fromChild.revertTo();
				if (toChild) {
					// Release the snapshot :
					toChild.releaseSnapshot(fromChild);
				} else {
					from.slots[property] = undefined;
				}
			});
		attributes.revertTo(this, to);
		return to;
	},
	fromRecord: function(_, record, colnIndex) {
		this.afterCreate(_);
		// copy record instead of swapping record pointers to keep system vars.

		// For slot lazy loading : 
		this.record = record;
		this.colnIndex = colnIndex;
		Object.keys(this.slots).forEach_(_, function(_, p) {
			if (this.slots[p] && this.slots[p].fromRecord) this.slots[p].fromRecord(_, record, colnIndex);
		}, this);
		return this;
	},
	crud: function(_, f) {
		var status;
		status = this.action(_, "A" + f.name + "_BEFORE", this.key);
		if (status === this.supervisor.constants.CST_AERROR) return status;
		status = f(_, this);
		if (status === this.supervisor.constants.CST_AERROR) return status;
		return this.action(_, "A" + f.name + "_AFTER", this.key);
	},
	read: function(_, key) {
		this.key = key;
		return this.crud(_, function READ(_, self) {
			return self.class.read(_, self, self.key);
		});
	},
	insert: function(_) {
		return this.crud(_, function INSERT(_, self) {
			var actx = glob.context.x3session.actx;
			self.set(_, "AUUID", tuuid.generate(), true);
			self.set(_, "CREUSR", actx.$USER(_));
			self.set(_, "UPDUSR", "");
			var now = tdatetime.now();
			if (self.get(_, "CREDATTIM").x3IsZero()) self.set(_, "CREDATTIM", now);
			if (self.get(_, "UPDDATTIM").x3IsZero()) self.set(_, "UPDDATTIM", now);
			return self.class.insert(_, self);
		});
	},
	update: function(_) {
		return this.crud(_, function UPDATE(_, self) {
			var actx = glob.context.x3session.actx;
			self.set(_, "UPDUSR", self.get(_, "UPDUSR")); // ???
			self.set(_, "UPDDATTIM", tdatetime.now());
			return self.class.update(_, self);
		});
	},
	delete: function(_) {
		return this.crud(_, function DELETE(_, self) {
			return self.class.delete(_, self);
		});
	},
	x3Compare: function(b) {
		return this === b;
	},
	method: function(name) {
		return this.methods[name];
	},
	action: function(_, action, key) {
		tracerJs.debug && tracerJs.debug("instance.action " + action + " key:" + key);
		var delayedArgs = function(_, instance, args) {
			return function(_) {
				var index = instance.class.index;
				var record = instance.record;
				if (record !== undefined) {
					// Add the record  
					var table = instance.class.table;
					var columns = table.columns;
					var value = Object.keys(columns).reduce(function(r, colName) {
						r.types[colName] = "F" + columns[colName].type.etnaType;
						if (columns[colName].data.DIME <= 1) {
							r.values[colName] = record[colName] || columns[colName].type.defaultValue;
						} else {
							r.values[colName] = [];
							for (var i = 0; i < columns[colName].data.DIME; i++) {
								r.values[colName][i] = (record[colName] && record[colName][i]) ? record[colName][i] : columns[colName].type.defaultValue;
							}
						}
						return r;
					}, {
						values: {},
						types: {}
					});

					args["F:" + table.abbrev] = {
						letter: "F",
						abrev: table.abbrev,
						value: value
					};
				}

				Object.keys(args).forEach(function(a) {
					tracerJs.debug && tracerJs.debug(a + " = " + args[a].value);
				});
				return args;
			};
		};
		// Compute the arguments for the scripts :
		var dargs = this.getActionArgs(_, action, key);
		if (/^AREAD/.test(action)) dargs = delayedArgs(_, this, this.getActionArgs(_, action, key));

		var status = this.runScripts(_, "$METHODS", dargs);
		if (status === this.supervisor.constants.CST_AERROR || !this.parent) return status;
		// Propagate the event to the parent :
		return this.parent.runScripts(_, "$METHODS", dargs);
	},

	afterQuery: function(_) {
		return this.action(_, "AQUERY_TRANS_AFTER");
	},


	controlBefore: function(_, operation) {
		// First control the instance
		var self = this;
		var status = this._actionControlBefore(_, operation);
		var control = "controlBefore" + operation;
		if (this[control]) status = this[control](_);

		if (!status) {
			// Propagate the event to children
			Object.keys(this.class.collections).forEach_(_, function(_, collection) {
				console.log("controlBefore on collection " + collection + " data:" + JSON.stringify(self.class.collections[collection].data));
			});
		}
		return status;
	},
	controlBeforeInsert: tmp = function(_) {
		try {
			// Temporary disable propagete:
			var propagate = this.propertyPropagateValue;
			this.propertyPropagateValue = undefined;
			var status = this.propertiesEvent(_, "CONTROL");
			if (status === this.supervisor.constants.CST_AERROR) return status;
			return this.action(_, "ACONTROL");
		} finally {
			// Restore the propagate function whatever happens:
			this.propertyPropagateValue = propagate;
		}
		return status;
	},
	controlBeforeUpdate: tmp,
	controlBeforeDelete: function(_) {
		// First check that the class supports DELETE operations:
		if (!this.ADELETE) throw new util.HttpError(406, this.supervisor.loadMessParams(_, 149, 31, this.supervisor.loadMess(_, 7983, 2), this.class.data.CODCLA));

		// Control blocking links :
		var tableLinks = this.class.table.links(_);
		tracerJs.debug && tracerJs.debug("Control links on :" + this.key);
		// control throws an exception if the instance cannot be deleted
		tableLinks.control(_, this.key);
		return this.supervisor.constants.CST_AOK;
	},

	controlAfter: function(_, operation) {
		console.log("TODO instance.controlAfter:" + operation);
		return this._actionControlAfter(_, operation);
	},

});