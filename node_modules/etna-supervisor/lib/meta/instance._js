"use strict";

var util 		= require("etna-supervisor/lib/util");
var glob 		= require('streamline/lib/globals');
var tuuid 		= require('etna-engine/lib/runtime/tuuid');
var X3Error 	= require('etna-engine/lib/runtime/errors').X3Error;
var variables 	= require('etna-engine/lib/runtime/variables');
var attributes  = require("etna-supervisor/lib/attributes");

var InstanceProperty   = require("etna-supervisor/lib/instanceProperty").InstanceProperty;
var InstanceCollection = require("etna-supervisor/lib/instanceCollection").InstanceCollection;

var Instance = exports.constructor = util.defineClass(function(superv, clas, parent, data, children, colnIndex) {
	this.supervisor = superv;
	this.class 		= clas;
	this.parent     = parent;
	this.data 		= data  || {};
	this.children   = children || {};
	this.colnIndex 	= colnIndex ;
	this.diagnoses 	= [];
}, null, {
	init: function(_) {
		return this;
	},
	afterCreate: function(_) { // for $create action, not $edit
		var properties = this.class.properties;
		Object.keys(properties).forEach_(_, function(_, name){
			var prop = properties[name];
			if(prop.collection){
				this.children[name] = new InstanceCollection(name,prop.collection,this);
			}
			else
				this.data[name] = new InstanceProperty(prop.type.defaultValue(),this,name);
		}, this);
		
		return this;
	},
	loadChildren: function(_, coln) {
		if (coln.mappingData) {
			var exps = coln.mappingData.EXPLNK.split(';');
			var vals = exps.map(function(exp) {
				// for now ignore [F:XXX] part - see later
				var p = exp.substring(exp.indexOf(']') + 1);
				return this.data[p];
			}, this);
			//var targetClass = this.supervisor.load(_, 'Class', mapping.CLALNK);
			var childTable = this.supervisor.load(_, 'Table', coln.mappingData.TABLNK);
			var childIndex = childTable.indexes[0];
			return coln.class.loadInstances(_, childIndex, vals);
		} else {
			// no mapping - denormalized
			//return console.error("cannot load children: " + coln.name), [];
			var procol = coln.data.PROCOL;
			if (procol === null) throw new Error(name + ": count column missing");
			var children = [];
			var count = this.data[procol];
			if (!coln.class) return console.error("ignoring collection " + coln.name), [];
			for (var i = 0; i < count; i++) {
				children.push(this.supervisor.new(_, 'Instance', coln.class,this,this.data, i));
			}
			return children;
		}
	},
	get: function(_, name) {
		// TODO: improve handling of system properties
		if (this.isContext)  return this.supervisor.context.get(_,name);
		
		if (['AERROR','ACTX'].indexOf(name) >= 0)	return this.data[name];
		
		var prop = this.class.properties[name];
		if (!prop) {
			// Can it be an external attributes :
			var valattr = this.getAttribute("$"+name);
			if(valattr === undefined) throw new Error("property not found: " + name);
			return variables.x3Val(valattr);
		}
		if (prop.collection) {
			if(!this.children[name].isLoaded){
				this.children[name].load(_,this.loadChildren(_, prop.collection)); 	
			} 

			return this.children[name];
			//return this.children[name] || (this.children[name] = this.loadChildren(_, prop.collection));
		}
		var col = prop.column;
		// col is undefined if property is volatile
		var colName = col ? col.name : name;

		this.class.invokeScripts(_, this, "GET", name,"");
		var val = this.data[colName].value;
		if (this.colnIndex != null) {
			if (!Array.isArray(val)) throw new Error(colName + ": array expected, got " + typeof val);
			val = val[this.colnIndex];
		}
		if (prop.data.CODTYP === "ATX") val = this.supervisor.loadText(_, parseInt(val, 10)); // do we need parseInt?
		//console.log("INSTANCE: GET " + name + " -> " + val + " (" + typeof val + ")");
		return val;
	},
	set: function(_, name, value, raw) {
		//console.log("instance.set "+name);
		var prop = this.class.properties[name];
		if (!prop) {
			// Can it be an external attributes :
			if(this.setAttribute("$"+name,value) !== null) return;
			throw new Error("property not found: " + name);
		}
		if (prop.collection) throw new Error("cannot set collection property: " + name);
		var col = prop.column;
		// col is undefined if property is volatile
		var colName = col ? col.name : name;
		var oldVal = this.data[colName].value;
		if (this.colnIndex != null) {
			if (!Array.isArray(value)) throw new Error(colName + ": array expected, got " + typeof value);
			oldVal = oldVal[this.colnIndex];
		}
		if (prop.data.CODTYP === "ATX") return console.error("NIY set on localized property: " + name);
		if (value === oldVal) return;
	
		this.snapshots();
	
		//console.log("INSTANCE: SET " + name + " <- " + value + " (" + typeof value + ")");
		if (this.colnIndex != null) {
			this.data[colName][this.colnIndex].value = value;
		} else {
			this.data[colName].value = value;
		}
		if (!raw) {
			if (this.class.invokeScripts(_, this, "CONTROL", name,"")) return;
			this.class.invokeScripts(_, this, "PROPAGATE", name,"");
		}
	},
	clone: function() {
		var from = this;
		var to = new Instance();
		to.supervisor = from.supervisor;
		to.class 	  = from.class;
		to.parent     = from.parent;
		to.data 	  = Object.keys(from.data).reduce(function(r, name) {
							var v = from.data[name] ;
							r[name] = (v.clone && v.clone(this)) || v;
							return r;
						},{});

		to.children   = Object.keys(from.children).reduce(function(r, name) {
							r[name] = from.children[name];
							return r;
						},{});

		to.colnIndex  = from.colnIndex ;
		to.diagnoses  = [];
		to.snapshotof = from;
		attributes.clone(from,to);
		return to;
	},
	getChildren : function() {
		return this.children;
	},
	updateChild : function(from,to) {
		var _this = this;
		Object.keys(_this.children).some(function(property) {
		    if(_this.children[property] = from) {
		    	_this.children[property] = to;
		    	return true;	
		    }
		    return false;
		});
	},
	revertTo : function() {
	    if(!this.snapshotof) return this;
	    var to   = this.snapshotof;
		var from = this;

		Object.keys(from.data)
			.filter(function(property){
				return !!from.data[property] && from.data[property].revertTo; })
			.forEach(function(property){
				from.data[property].revertTo();
				// Release the snapshot :
				from.data[property] = undefined;
		});	


		Object.keys(from.children)
			.filter(function(property){
					return !!from.children[property]; })
			.forEach(function(property) {
			var fromChild = from.children[property];
			var toChild = fromChild.revertTo();
			// Release the snapshot :
			toChild.releaseSnapshot(fromChild);
		});	
		attributes.revertTo(this,to);
		return to;		
	},
	read: function(_, key) {
		var table = this.class.table;
		var index = table.indexes[0];
				
		//console.log("index.columns " + index.columns[0].data.CODZONE);
		var param = {};		
		Object.keys(index.columns).forEach(function(k) {
			param[index.columns[k].data.CODZONE] = key[k] ;
		});
		this.data.AUUID.value = tuuid.generate() ;
		this.class.invokeScripts(_, this, "AREAD_BEFORE","","",param);
		var data = table.loadRecords(_, index, key, 1)[0];
		if (!data) return false;
		// copy data instead of swapping data pointers to keep system vars.
		Object.keys(data).forEach(function(k) {
			if(this.data[k]) this.data[k].value = data[k];
		}, this);

		this.class.invokeScripts(_, this, "AREAD_AFTER","","");
		return glob.context.x3frame.values.ASTATUS;
	},
	insert: function(_) {
		var table = this.class.table;
		table.insert(_, this.data);		
	},
	update: function(_) {
		var table = this.class.table;
		table.update(_, this.data);		
	},
	delete: function(_) {
		var table = this.class.table;
		table.delete(_, this.data);		
	},
	setPropertyAttribute:function(_,property,attribut,value) {
		this.snapshots();

		if(this.data[property]) return this.data[property].setAttribute(attribut,value);
		else if(this.children[property]) return this.children[property].setAttribute(attribut,value);
	},
	ASETATTRPROP :function(_,property,attribut,value) {
		try {
			return this.setPropertyAttribute(_,property,attribut,value);
		} catch(ex) {
			return this.supervisor.constants.CST_AERROR;
		}
	},
	getPropertyAttribute:function(_,property,attribut) {
		if(this.data[property]) return this.data[property].getAttribute(attribut);
		else if(this.children[property]) return this.children[property].getAttribute(attribut);
	},
	setColumnAttribute:function(_,collection,column,attribut,value) {
		if(this.children[collection]) return this.children[collection].setColumnAttribute(column,attribut,value);
	},
	getColumnAttribute:function(_,collection,column,attribut) {
		if(this.children[collection]) return this.children[collection].getColAttribute(column,attribut);
	},
	AGETATTRIBUTE:function(_,property,attribut) {
		return variables.x3Val(this.getPropertyAttribute(_,property,attribut))
	},
	ASETATTRIBUTE:function(_,property,attribut,value) {
		return variables.x3Val(this.setPropertyAttribute(_,property,attribut,value));
	},
	x3Compare:function(b) {
		return this === b;
	}
},{hasAttributes:true,hasSnapshots:true});