"use strict";

var util = require("etna-supervisor/lib/util");
var glob = require('streamline/lib/globals');
var tuuid = require('etna-engine/lib/runtime/tuuid');
var X3Error = require('etna-engine/lib/runtime/errors').X3Error;
var tdatetime = require('etna-engine/lib/runtime/tdatetime');
var utilRuntime = require('etna-engine/lib/runtime/util');

var db = require("etna-engine/lib/runtime/db");
var mapping = require("etna-supervisor/lib/mapping");
var constants = require("etna-supervisor/lib/constants");
var attributes = require("etna-supervisor/lib/attributes");

var tracerJs = require("syracuse-trace/lib/helper").getTracer("etna.supervisor");
var traceCRUD = require("syracuse-trace/lib/helper").getTracer("etna.crud");
var tracerEvents = require("syracuse-trace/lib/helper").getTracer("etna.events");


var baseInstance = require("etna-supervisor/lib/meta/baseInstance");

var tmp;
var Instance = exports.constructor = baseInstance.defineClass(function(superv, clas, parent, slots) {
	var self = this;
	this.supervisor = superv;
	this.meta = this.class = clas;
	this.$parent = parent;
	this.methods = {};
	if (this.class) {
		this.index = this.class.index;
		this.class.addMethods(this);
	} else {
		this.index = {};
	}
	this.properties = clas ? clas.properties : {};
	this.slots = slots || {};
	this.record;
	this.colnIndex;
	this.name = "";
}, null, {
	$$type: {
		get: function() {
			return "Instance";
		}
	},
	APARENT: {
		get: function() {
			return this.$aparent || this.$parent;
		},
		set: function(parent) {
			return this.$aparent = parent;
		}
	},
	incrementUpdtick: function(_) {
		var v = this.get(_, "UPDTICK", true);
		this.set(_, "UPDTICK", ((v === 999999999) ? 1 : v + 1), true);
	},
	afterCreate: function(_, record, colnIndex) { // for $create action, not $edit
		var instance = this;
		this.record = record;
		this.colnIndex = colnIndex;
		// Set mandatory properties
		this.class.mandatoryProperties && this.class.mandatoryProperties.forEach_(_, function(_, property) {
			instance.slot(_, property).setAsMandatory(_);
		});
		if (record) {
			if (record.AUUID) this.$uuid = record.AUUID;
			Object.keys(this.slots).forEach_(_, function(_, p) {
				if (this.slots[p] && this.slots[p].fromRecord) this.slots[p].fromRecord(_, record, colnIndex);
			}, this);
		}
		return this;
	},
	fromRecord: function(_, record, colnIndex) {
		// load keys with 
		var dataChildren = this.class.data.dataChildren;
		if (this.$parent && dataChildren && dataChildren.ownMapping) {
			this.$lazyLoading = true;
			this.relKeys = mapping.getKeys(_, dataChildren.ownMapping, record);
		}
	},
	clone: function() {
		var from = this;
		var to = new Instance(from.supervisor, from.class, from.$parent);
		to.properties = from.properties;
		// required when being called by the constructor of workingCopy
		to.record = from.record;

		to.slots = Object.keys(from.slots).reduce(function(r, name) {
			var p = from.slots[name];
			if (p.snapshots) {
				r[name] = p;
			} else {
				r[name] = (p.clone && p.clone(this)) || p;
			}
			return r;
		}, {});

		to.$updtick = from.$updtick;
		if (from.$aparent) to.$aparent = from.$aparent;
		to.diagnoses = [];
		to.proName = from.proName;
		to.$$dbgId = from.$$dbgId; // For debug only:
		to.$uuid = from.$uuid;
		to._get = from._get; // Can be modified in newInstanceCollection
		attributes.clone(from, to);
		return to;
	},
	getChildren: function() {
		return this.slots;
	},
	revertTo: function() {
		if (!this.snapshotof) return this;
		var to = this.snapshotof;
		var from = this;

		Object.keys(from.slots)
			.filter(function(property) {
				return !!from.slots[property] && from.slots[property].revertTo;
			})
			.forEach(function(property) {
				var fromChild = from.slots[property];
				var toChild = fromChild.revertTo();
				if (toChild) {
					// Release the snapshot :
					toChild.releaseSnapshot(fromChild);
				} else {
					from.slots[property] = undefined;
				}
			});
		attributes.revertTo(this, to);
		return to;
	},
	getProKeys: function(_) {
		var dataChildren = this.class.data.dataChildren;
		if (this.$parent && dataChildren && dataChildren.ownMapping) {
			var instance = this;
			dataChildren.ownMapping.MAPS
				.filter(function(map) {
					return map.PROMAP !== undefined && map.KEYMAP !== undefined;
				})
				.forEach_(_, function(_, map) {
					instance.set(_, map.KEYMAP, instance.APARENT.get(_, map.PROMAP), true);
				});
		}
	},
	getKey: function(_) {
		if (this.key) return this.key;
		// Compute the key 
		var self = this;
		return this.class.data.KEYINT ? this.class.data.KEYINT.match(/(\w+)/g).map_(_, function(_, p) {
			return self.get(_, p, true);
		}).join('~') : undefined;
	},
	getKeyTab: function(_) {
		if (this.key) return this.key;
		// Compute the key 
		var self = this;
		return this.class.data.KEYINT ? this.class.data.KEYINT.match(/(\w+)/g).map_(_, function(_, p) {
			return self.get(_, p, true);
		}) : undefined;
	},
	AREAD: function(_) {
		throw new Error("AREAD not supported");
	},
	AINSERT: function(_) {
		throw new Error("AINSERT not supported");
	},
	AUPDATE: function(_) {
		throw new Error("AUPDATE not supported");
	},
	ADELETE: function(_) {
		throw new Error("ADELETE not supported");
	},
	xmet: function(name) {
		return this.methods["xmet" + name];
	},
	crud: function(_, fname, f, key) {
		traceCRUD.debug && traceCRUD.debug(fname, key);

		var execute;
		var instance = this;
		var status = constants.CST_AOK;
		var checkStatus = function(status) {
			if (status === constants.CST_AERROR) {
				var e = new Error("abort"); // to handle abort actions carefully
				traceCRUD.error && traceCRUD.error("error raised from:" + e.stack);
				throw e;
			}
			return status;
		};
		try {
			this.transaction && this.transaction.begin(_);

			if (glob.context.x3session._crudActions === undefined) {
				glob.context.x3session._crudActions = [];
				//Define execute at the top level only
				var self = this;
				execute = function(_, event) {
					var status = constants.CST_AOK;
					glob.context.x3session._crudActions.reverse().forEach_(_, function(_, f) {
						status = Math.max(status, f(_, event));
					});
					return status;
				};
			}
			// Register a delayed action :
			glob.context.x3session._crudActions.push(function(instance, fname) {
				return function(_, event) {
					return instance.action(_, fname + "_" + event, instance.key);
				};
			}(this, fname));


			if (key) this.key = key;
			status = checkStatus(this.action(_, fname + "_BEFORE", this.key));

			status = Math.max(checkStatus(f(_, this), status));

			if (key === undefined && this.class.isInterface === false) {
				// AINSERT, AUPDATE, ADELETE
				var fct = fname.substring(1).toLowerCase();
				Object.keys(this.class.relations).forEach_(_, function(_, name) {
					status = Math.max(checkStatus(instance.get(_, name)[fct](_)));
				});
			}
			// Execute after actions before commit :
			status = execute ? Math.max(status, execute(_, "AFTER")) : status;
			this.transaction && this.transaction.commit(_);
		} catch (e) {
			status = constants.CST_AERROR;
			if (execute) {
				if (e.message !== "abort") {
					status = this.addDiagnose(_, constants.CST_AERROR, e.message);
				}
				if (key === undefined) {
					// No abort for AREAD
					status = execute ? Math.max(status, execute(_, "ABORT")) : status;
				}
			} else {
				// Let give an opportunity to the parent to run the ABORT event:
				throw e;
			}
			this.transaction && this.transaction.rollback(_);
		} finally {
			if (execute) glob.context.x3session._crudActions = undefined;
		}
		return status;
	},
	read: function(_, key, options) {
		var crud = (options && options.crud !== undefined) ? options.crud : true;
		var AREAD = function(_, instance) {
			return instance.class.read(_, instance, key);
		};
		return crud ? this.crud(_, 'AREAD', AREAD, key) : AREAD(_, this);
	},
	insert: function(_, options) {
		var raw = (options && options.raw !== undefined) ? options.raw : false;
		var crud = (options && options.crud !== undefined) ? options.crud : true;

		this.getProKeys(_);

		var AINSERT = function(_, instance) {
			var actx = glob.context.x3session.actx;
			//TODO instance.set(_, "AUUID", tuuid.generate(), true);
			instance.set(_, "AUUID", instance.$uuid, true);
			instance.set(_, "CREUSR", actx.$USER(_), raw);

			var expnum = instance.slot(_, "EXPNUM");
			if (expnum) expnum._set(_, 8, raw); // TODO EXPNUM

			instance.set(_, "UPDUSR", "", raw);
			if (instance.get(_, "CREDATTIM").x3IsZero()) instance.set(_, "CREDATTIM", tdatetime.now(), raw);
			instance.set(_, "UPDDATTIM", new tdatetime.Datetime(), raw);

			var status = instance.class.insert(_, instance);
			if (status === constants.CST_AOK) instance.set(_, "UPDTICK", 1, true);
			return status;
		};
		return crud ? this.crud(_, 'AINSERT', AINSERT) : AINSERT(_, this);
	},
	update: function(_, options) {
		var raw = (options && options.raw !== undefined) ? options.raw : false;
		var crud = (options && options.crud !== undefined) ? options.crud : true;

		this.getProKeys(_);
		var AUPDATE = function(_, instance) {
			var actx = glob.context.x3session.actx;
			instance.set(_, "UPDUSR", actx.$USER(_), raw);

			var expnum = instance.slot(_, "EXPNUM");
			if (expnum) expnum._set(_, 8, raw); // TODO EXPNUM

			instance.set(_, "UPDDATTIM", tdatetime.now(), raw);
			var status = instance.class.update(_, instance);
			if (status === constants.CST_AOK) instance.incrementUpdtick(_);
			return status;
		};
		return crud ? this.crud(_, 'AUPDATE', AUPDATE) : AUPDATE(_, this);
	},
	delete: function(_, options) {
		var raw = (options && options.raw !== undefined) ? options.raw : false;
		var crud = (options && options.crud !== undefined) ? options.crud : true;

		this.key = this.getKey(_);
		var ADELETE = function(_, instance) {
			// non controle for interfaces
			if (instance.class.isInterface === true) return constants.CST_AOK;

			// Control blocking links :
			var tableLinks = instance.class.table.links(_);
			// control throws an exception if the instance cannot be deleted
			tableLinks && tableLinks.delete(_, instance);

			var status = instance.class.delete(_, instance);
			//Just take into consideration errors at the first level 
			return instance.transaction ? status : constants.CST_AOK;
		};
		return crud ? this.crud(_, 'ADELETE', ADELETE) : ADELETE(_, this);
	},
	x3Compare: function(b) {
		return this === b;
	},
	method: function(name) {
		return this.methods[name];
	},
	action: function(_, action, key, crupro, curpth) {
		tracerEvents.debug && tracerEvents.debug("$METHODS:" + action + " KEY:" + (key || ""));
		var delayedArgs = function(_, instance, args) {
			return function(_) {
				var index = instance.class.index;
				var record = instance.record;
				if (record !== undefined) {
					// Add the record  
					var table = instance.class.table;
					var columns = table.columns;
					var recordset = Object.keys(columns).reduce(function(r, colName) {
						r.types[colName] = "F" + columns[colName].type.etnaType;
						if (columns[colName].data.DIME <= 1) {
							r.values[colName] = record[colName] || columns[colName].type.defaultValue;
						} else {
							r.values[colName] = [];
							for (var i = 0; i < columns[colName].data.DIME; i++) {
								r.values[colName][i] = (record[colName] && record[colName][i]) ? record[colName][i] : columns[colName].type.defaultValue;
							}
						}
						return r;
					}, {
						values: {},
						types: {}
					});

					var tableName = utilRuntime.instructions.C(table.name);
					var dbTable = db.instructions.FILESQL(table.abbrev, tableName, null, null)(_);

					dbTable.types = recordset.types;
					dbTable.values = recordset.values;

					args["F:" + table.abbrev] = {
						letter: "F",
						abrev: table.abbrev,
						value: dbTable
					};
				}
				Object.keys(args).forEach(function(a) {
					tracerJs.debug && tracerJs.debug(a + " = " + args[a].value);
				});
				return args;
			};
		};
		// Compute the arguments for the scripts :
		var dargs = this.getActionArgs(_, action, key, crupro, curpth);
		if (/^AREAD/.test(action)) dargs = delayedArgs(_, this, this.getActionArgs(_, action, key, crupro, curpth));

		var status;
		var instance = this;
		while (instance !== undefined) {
			if (instance.runScripts) {
				status = instance.runScripts(_, "$METHODS", dargs);
			}
			//if(action === "AINIT") return status;
			if (["AQUERY_TRANS_AFTER"].indexOf(action) < 0) {
				var baseCurpth = instance.proName || "";
				if (typeof dargs === 'function') {
					curpth = baseCurpth + (curpth ? ("." + curpth) : "");
					dargs = delayedArgs(_, this, this.getActionArgs(_, action, key, crupro, curpth));
				} else {
					dargs.CURPTH.value = baseCurpth + (dargs.CURPTH.value ? ("." + dargs.CURPTH.value) : "");
				}
			}
			instance = instance.$parent;
		}
		return status;
	},

	afterQuery: function(_) {
		return this.action(_, "AQUERY_TRANS_AFTER");
	},
	onControl: function(_, type, operation) {
		return this[type](_, operation);
	},
	propagateControl: function(_, type, operation) {
		tracerJs.debug && tracerJs.debug("propagateControl:" + [type, operation].join(','));
		var instance = this;
		var status = constants.CST_AOK;
		Object.keys(this.class.relations).forEach_(_, function(_, name) {
			status = Math.max(status, instance.get(_, name).onControl(_, type, operation));
		});
		return status;
	},

	beforeControl: function(_, operation) {
		// 1. control the instance
		var status = this.actionBeforeControl(_, operation);

		if (status === constants.CST_AERROR) return status;
		// 2. control the instance
		return this.propagateControl(_, "beforeControl", operation);
	},
	propagateControlExecution: function(_, type) {
		var status = constants.CST_AOK;
		if (this.class.isInterface === true) return status;
		var instance = this;
		Object.keys(this.class.relations).forEach_(_, function(_, name) {
			status = Math.max(status, instance.get(_, name).executeControl(_, type));
		});
		return status;
	},
	executeControl: function(_, type) {
		var control = "executeControl" + type;
		// 1.Control the instance
		var status = (this[control] && this[control](_, type)) || constants.CST_AOK;
		tracerJs.debug && tracerJs.debug("executeControl " + type + " return=" + status);
		return status;
	},
	executeControlInsert: tmp = function(_) {
		// First control ALL mandatory fields
		// deleteDiagnoses();

		var status = this.executeControl(_, "Mandatory");
		if (status === constants.CST_AERROR) return status;

		// First control ALL formats
		var status = this.executeControl(_, "Format");
		if (status === constants.CST_AERROR) return status;

		// Control Others
		return this.executeControl(_, "Others");
	},
	executeControlUpdate: tmp,
	executeControlDelete: function(_) {
		if (this.class.isInterface === true) return constants.CST_AOK;
		// First check that the class supports DELETE operations:
		if (!this.ADELETE) throw new util.HttpError(406, this.supervisor.loadMessParams(_, 149, 31, this.supervisor.loadMess(_, 7983, 2), this.class.data.CODCLA));

		// Control blocking links :
		var tableLinks = this.class.table.links(_);
		tracerJs.debug && tracerJs.debug("Control links on :" + this.key);
		// control throws an exception if the instance cannot be deleted
		if (tableLinks) return tableLinks.control(_, this);
		return constants.CST_AOK;
	},
	executeControlMandatory: function(_, type) {
		var instance = this;
		var status = constants.CST_AOK;

		// Control mandatory fields
		Object.keys(this.slots).forEach_(_, function(_, property) {
			var slot = instance.slots[property];
			// It's the first control => delete previous errors :
			slot.deleteDiagnoses && slot.deleteDiagnoses(_);
			if (slot.$isMandatory) {
				// Force the GET operator (as in 4GL)
				var value = slot._get(_);
				if (slot.isUndefined) {
					tracerJs.error && tracerJs.error("Mandatory property " + property + " is undefined");
					//  Mandatory property :
					status = Math.max(status,
						slot.addDiagnose(_, constants.CST_AERROR, instance.supervisor.loadMess(_, 123, 10)));
				}
			}
		});
		return (status === constants.CST_AERROR) ? status : this.propagateControlExecution(_, type);
	},
	executeControlFormat: function(_, type) {
		var instance = this;
		var status = constants.CST_AOK;

		// Control the format of properties set (slots)
		Object.keys(this.slots).forEach_(_, function(_, property) {
			var slot = instance.slots[property];
			if (slot.controlFormat) {
				// Force the GET operator (as in 4GL)
				var value = slot._get(_);
				status = Math.max(status, slot.controlFormat(_));
			}
		});
		return (status === constants.CST_AERROR) ? status : this.propagateControlExecution(_, type);
	},
	executeControlOthers: function(_, type) {
		var instance = this;
		var status = constants.CST_AOK;

		try {
			// Temporary disable propagete:
			var propagate = this.propertyPropagateValue;
			this.propertyPropagateValue = undefined;

			// Control on all properties :
			var properties = this.meta.data.PROPERTIES;
			Object.keys(properties)
				.filter(function(property) {
					return properties[property].FLDGRP === undefined;
				})
				.forEach_(_, function(_, i) {
					var property = properties[i].FLDCLA || properties[i].CODFLD;
					var slot = instance.slots[property];

					if (slot && slot.controlOthers) {
						// Force the GET operator (as in 4GL)
						var value = slot._get(_);
						status = Math.max(status, slot.controlOthers(_));
					}
					// Send "CONTROL"
					instance.propertyControlValue(_, property);
				});
			if (status === constants.CST_AERROR) return status;

			//Control the children
			status = this.propagateControlExecution(_, type);
			if (status === constants.CST_AERROR) return status;

			// Control the instance
			return this.action(_, "ACONTROL");
		} finally {
			// Restore propertyPropagateValue whatever happens
			this.propertyPropagateValue = propagate;
		}
	},

	afterControl: function(_, operation) {
		// 1. children
		var status = this.propagateControl(_, "afterControl", operation);
		if (status === constants.CST_AERROR) return status;

		// 2. the instance
		return this.actionAfterControl(_, operation);
	},
	getSql: function(_, desc) {
		// Set a default value :
		var value = desc.type.defaultValue;

		if (desc.index === null || desc.index === undefined) {
			var slot = this.slot(_, desc.name);
			if (slot) {
				if (!slot._getSql) {
					value = slot._get(_, true);
					slot = value.slot(_, desc.name);
				}
				value = slot._getSql(_);
			}
		} else {
			var self = this;
			Object.keys(this.class.relations).forEach_(_, function(_, name) {
				if (self.class.relations[name].class.properties[desc.name]) {
					var collection = self.slot(_, name);
					var position = desc.index + 1;
					if (position <= collection.x3Maxtab()) {
						var line = collection.index(_, position);
						slot = line.slot(_, desc.name);
						value = slot._getSql(_);
					}
					return;
				}
			});
		}
		//tracerJs.debug && tracerJs.debug("getField:" + property + " index:" + index + " =" + value);
		return value;
	},
	supportsTable: function(operation) {
		if (this.$aparent && this.$aparent.class.isInterface === true) return true;
		var collection = (this.$parent && this.$parent.collection);
		if (collection && !collection.mappingData) {
			// The instance belongs to a denormalized collection :
			//traceCRUD.debug && traceCRUD.debug(instance.class.name + "doesn't support table." + operation);
			return true;
		}
		return true;
	}
});

exports.newInstance = function(property) {
	return function(_, parent) {
		var instance = property.supervisor.new(_, 'Instance', property.collection.class, parent).afterCreate(_);
		instance.collection = property.collection;
		instance.proName = property.name;
		return instance;
	};
};