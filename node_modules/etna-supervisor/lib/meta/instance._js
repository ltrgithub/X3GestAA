"use strict";

var util = require("etna-supervisor/lib/util");

var Instance = exports.constructor = util.defineClass(function(superv, instanceFactory, data, colnIndex) {
	this.superv = superv;
	this.instanceFactory = instanceFactory;
	this.data = data;
	this.children = {};
	this.colnIndex = colnIndex;
	this.diagnoses = [];
}, null, {
	init: function(_) {
		return this;
	},
	afterCreate: function(_) { // for $create action, not $edit
		var properties = this.instanceFactory.properties;
		Object.keys(properties).forEach_(_, function(_, name){
			var prop = properties[name];
			this.data[name] = prop.collection ? [] : prop.type.defaultValue();
		}, this);
		return this;
	},
	class: {
		get: function() {
			return this.instanceFactory.class;
		},
	},
	loadChildren: function(_, coln) {
		if (coln.mappingData) {
			var exps = coln.mappingData.EXPLNK.split(';');
			var vals = exps.map(function(exp) {
				// for now ignore [F:XXX] part - see later
				var p = exp.substring(exp.indexOf(']') + 1);
				return this.data[p];
			}, this);
			//var targetClass = this.superv.load(_, 'Class', mapping.CLALNK);
			var childTable = this.superv.load(_, 'Table', coln.mappingData.TABLNK);
			var childIndex = childTable.indexes[0];
			return coln.instanceFactory.loadInstances(_, childIndex, vals);
		} else {
			// no mapping - denormalized
			//return console.error("cannot load children: " + coln.name), [];
			var procol = coln.data.PROCOL;
			if (procol === null) throw new Error(name + ": count column missing");
			var children = [];
			var count = this.data[procol];
			if (!coln.instanceFactory) return console.error("ignoring collection " + coln.name), [];
			for (var i = 0; i < count; i++) {
				children.push(this.superv.new(_, 'Instance', coln.instanceFactory, this.data, i));
			}
			return children;
		}
	},
	get: function(_, name) {
		// TODO: improve handling of system properties
		if (name === 'ACTX' || name === 'AERROR') return this.data[name];
		var prop = this.instanceFactory.properties[name];
		if (!prop) throw new Error("property not found: " + name);
		if (prop.collection) return this.children[name] || (this.children[name] = this.loadChildren(_, prop.collection));
		var col = prop.column;
		if (!col) return console.error("column not found: " + name), undefined;

		this.instanceFactory.class.invokePropertyScripts(_, this, "GET", name);

		var val = this.data[col.name];
		if (this.colnIndex != null) {
			if (!Array.isArray(val)) throw new Error(col.name + ": array expected, got " + typeof val);
			val = val[this.colnIndex];
		}
		if (prop.data.CODTYP === "ATX") val = this.superv.loadText(_, parseInt(val, 10)); // do we need parseInt?
		//console.log("INSTANCE: GET " + name + " -> " + val + " (" + typeof val + ")");
		return val;
	},
	set: function(_, name, value, raw) {
		var prop = this.instanceFactory.properties[name];
		if (!prop) throw new Error("property not found: " + name);
		if (prop.collection) throw new Error("cannot set collection property: " + name);
		var col = prop.column;
		if (!col) return console.error("NIY set on computed property: " + name);
		var oldVal = this.data[col.name];
		if (this.colnIndex != null) {
			if (!Array.isArray(val)) throw new Error(col.name + ": array expected, got " + typeof val);
			oldVal = oldVal[this.colnIndex];
		}
		if (prop.data.CODTYP === "ATX") return console.error("NIY set on localized property: " + name);
		if (value === oldVal) return;
		//console.log("INSTANCE: SET " + name + " <- " + value + " (" + typeof value + ")");
		if (this.colnIndex != null) {
			this.data[col.name][this.colnIndex] = value;
		} else {
			this.data[col.name] = value;
		}
		if (!raw) {
			if (this.instanceFactory.class.invokePropertyScripts(_, this, "CONTROL", name)) return;
			this.instanceFactory.class.invokePropertyScripts(_, this, "PROPAGATE", name);
		}
	},
	clone: function() {
		var instance = new Instance(this.superv, this.instanceFactory, util.clone(this.data, true), this.colnIndex);
		instance.children = util.clone(instance.children);
		return instance;
	},
	read: function(_, key) {
		var table = this.class.table;
		var index = table.indexes[0];
		var data = table.loadRecords(_, index, key, 1)[0];
		if (!data) return false;
		// copy data instead of swapping data pointers to keep system vars.
		Object.keys(data).forEach(function(k) {
			this.data[k] = data[k];
		}, this);
		return true;
	},
	insert: function(_) {
		var table = this.class.table;
		table.insert(_, this.data);		
	},
	update: function(_) {
		var table = this.class.table;
		table.update(_, this.data);		
	},
	delete: function(_) {
		var table = this.class.table;
		table.delete(_, this.data);		
	},
});