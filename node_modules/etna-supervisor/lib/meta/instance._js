"use strict";

var util = require("etna-supervisor/lib/util");
var glob = require('streamline/lib/globals');
var tuuid = require('etna-engine/lib/runtime/tuuid');
var X3Error = require('etna-engine/lib/runtime/errors').X3Error;
var variables = require('etna-engine/lib/runtime/variables');
var attributes = require("etna-supervisor/lib/attributes");
var tracerJs = require("syracuse-trace/lib/helper").getTracer("etna.supervisor");

var baseInstance = require("etna-supervisor/lib/meta/baseInstance");

var InstanceProperty = require("etna-supervisor/lib/instanceProperty").InstanceProperty;
var InstanceCollection = require("etna-supervisor/lib/instanceCollection").InstanceCollection;

var Instance = exports.constructor = baseInstance.defineClass(function(superv, clas, parent, slots) {
	this.supervisor = superv;
	this.meta = this.class = clas;
	this.properties = clas ? clas.properties : {};
	this.parent = parent;
	this.slots = slots || {};
	this.record;
	this.colnIndex;
}, null, {
	afterCreate: function(_) { // for $create action, not $edit
		var _this = this;
		Object.keys(this.class.stdMethods).forEach(function(stdMethod) {
			_this[stdMethod] = _this["$" + stdMethod];
		});
		return this;
	},
	set: function(_, name, value, raw) {
		tracerJs.debug && tracerJs.debug("instance.set " + name);

		this.snapshots();
		// Lazy loading of slots:
		var s = this.slot(_, name);
		if (s) s.set(_, value, raw);
		else {
			//External attributes ?
			if (this.setAttribute("$" + name, value) !== null) return;

			throw new Error("Cannot set property :" + name);
		}
	},
	clone: function() {
		var from = this;
		var to = new Instance();
		to.supervisor = from.supervisor;
		to.class = from.class;
		to.properties = from.properties;
		to.parent = from.parent;

		to.slots = Object.keys(from.slots).reduce(function(r, name) {
			var p = from.slots[name];
			if (p.snapshots) {
				r[name] = p;
			} else {
				r[name] = (p.clone && p.clone(this)) || p;
			}
			return r;
		}, {});

		to.diagnoses = [];
		to.snapshotof = from;
		attributes.clone(from, to);
		return to;
	},
	getChildren: function() {
		return this.slots;
	},
	updateProperty: function(from, to) {
		var _this = this;
		Object.keys(_this.slots).some(function(property) {
			if (_this.slots[property] == from) {
				_this.slots[property] = to;
				return true;
			}
			return false;
		});
	},
	revertTo: function() {
		if (!this.snapshotof) return this;
		var to = this.snapshotof;
		var from = this;

		Object.keys(from.slots)
			.filter(function(property) {
				return !!from.slots[property] && from.slots[property].revertTo;
			})
			.forEach(function(property) {
				var fromChild = from.slots[property];
				var toChild = fromChild.revertTo();
				if (toChild) {
					// Release the snapshot :
					toChild.releaseSnapshot(fromChild);
				} else {
					from.slots[property] = undefined;
				}
			});
		attributes.revertTo(this, to);
		return to;
	},
	fromRecord: function(_, record, colnIndex) {
		this.afterCreate(_);
		// copy record instead of swapping record pointers to keep system vars.

		// For slot lazy loading : 
		this.record = record;
		this.colnIndex = colnIndex;
		Object.keys(this.slots).forEach_(_, function(_, p) {
			if (this.slots[p] && this.slots[p].fromRecord) this.slots[p].fromRecord(_, record, colnIndex);
		}, this);
		return this;
	},
	read: function(_, key) {
		return this.class.read(_, this, key);
	},
	toRecord: function() {
		var _this = this;
		return Object.keys(this.slots).reduce(function(record, name) {
			_this.slots[name] && _this.slots[name].toRecord(record);
			return record;
		}, {});
	},
	insert: function(_) {
		var table = this.class.table;
		table.insert(_, this.toRecord());
	},
	update: function(_) {
		var table = this.class.table;
		table.update(_, this.toRecord());
	},
	delete: function(_) {
		var table = this.class.table;
		table.delete(_, this.toRecord());
	},
	setPropertyAttribute: function(_, property, attribut, value) {
		this.snapshots();
		return this.slot(_, property).setAttribute(attribut, value);
	},
	ASETATTRPROP: function(_, property, attribut, value) {
		try {
			return this.setPropertyAttribute(_, property, attribut, value);
		} catch (ex) {
			return this.supervisor.constants.CST_AERROR;
		}
	},
	getPropertyAttribute: function(_, property, attribut) {
		return this.slot(_, property).getAttribute(attribut);
	},
	setColumnAttribute: function(_, collection, column, attribut, value) {
		var slot = this.slot(_, collection);
		if (slot && slot.setColumnAttribute) return slot.setColumnAttribute(column, attribut, value);
	},
	getColumnAttribute: function(_, collection, column, attribut) {
		var slot = this.slot(_, collection);
		if (slot && slot.getColAttribute) return slot.getColAttribute(column, attribut);
	},
	AGETATTRIBUTE: function(_, property, attribut) {
		return variables.x3Val(this.getPropertyAttribute(_, property, attribut));
	},
	ASETATTRIBUTE: function(_, property, attribut, value) {
		return variables.x3Val(this.setPropertyAttribute(_, property, attribut, value));
	},
	x3Compare: function(b) {
		return this === b;
	},
	method: function(name) {
		return this.methods[name];
	},
	// _AINSERT: function(_) {
	// 	util.checkInstance(this);
	// 	this.insert(_);
	// 	return 0;
	// },
	$AREAD: function(_) {
		util.checkInstance(this);
		var key = Array.prototype.slice.call(arguments, 1);
		tracerJs.debug && tracerJs.debug("instance.AREAD(" + key + ")");
		return this.read(_, key);
	},
	// _AUPDATE: function(_) {
	// 	util.checkInstance(this);
	// 	this.update(_);
	// 	return 0;
	// },
	$ADELETE: function(_) {
		util.checkInstance(this);
		this.delete(_);
		return 0;
	},
	$properties: function(_, action, property) {
		return this.$runScripts(_, action, {
			THIS: {
				type: "LY",
				value: this
			},
			ASTATUS: {
				type: "LI",
				value: 0
			},
			CURPRO: {
				type: "LS",
				value: property
			},
			CURPTH: {
				type: "LS",
				value: property
			},
			ACTION: {
				type: "LS",
				value: action
			}
		});
	},
	$methods: function(_, action) {
		return this.$runScripts(_, action, {
			THIS: {
				type: "LY",
				value: this
			},
			ASTATUS: {
				type: "LI",
				value: 0
			},
			CURPRO: {
				type: "LS",
				value: ""
			},
			CURPTH: {
				type: "LS",
				value: ""
			},
			ACTION: {
				type: "LS",
				value: action
			}
		});
	},
	$runScripts: function(_, action, args) {
		tracerJs.debug && tracerJs.debug("instance.$methods");
		var delayedArgs = function(_, instance, args) {
			return function(_) {
				var index = instance.class.index;
				if (["AQUERY_TRANS_AFTER"].indexOf(args.ACTION.value) >= 0) {
					// Add instance's keys
					args = Object.keys(index).reduce_(_, function(_, arg, i) {
						var name = index[i].name.split(' ')[0];
						arg[name] = {
							type: index[i].etnaType,
							value: instance.get(_, name)
						};
						return arg;
					}, args);

					var record = instance.record;
					if (record !== undefined) {
						// Add the record  
						var table = instance.class.table;
						var columns = table.columns;
						var value = Object.keys(columns).reduce(function(r, colName) {
							r.types[colName] = "F" + columns[colName].type.etnaType;
							if (columns[colName].data.DIME <= 1) {
								r.values[colName] = record[colName] || columns[colName].type.defaultValue;
							} else {
								r.values[colName] = [];
								for (var i = 0; i < columns[colName].data.DIME; i++) {
									r.values[colName][i] = (record[colName] && record[colName][i]) ? record[colName][i] : columns[colName].type.defaultValue;
								}
							}
							return r;
						}, {
							values: {},
							types: {}
						});

						args["F:" + table.abbrev] = {
							letter: "F",
							abrev: table.abbrev,
							value: value
						};
					}
				}
				tracerJs.debug && Object.keys(args).forEach(function(a) {
					tracerJs.debug(a + " = " + args[a].value);
				});
				return args;
			};
		};

		var dargs = delayedArgs(_, this, args);
		tracerJs.debug && tracerJs.debug("call instance.runScripts");
		var astatus = this.runScripts(_, "$METHODS", dargs);

		if (astatus === this.supervisor.constants.CST_AOK && this.parent && this.parent.runScripts) {
			if (typeof dargs === 'function') {
				if (args.CURPTH.value) args.CURPTH.value = this.curpath + "." + args.CURPTH.value;
				args.THIS.value = this.parent;
				dargs = delayedArgs(_, this, args);
			} else {
				if (dargs.CURPTH.value) dargs.CURPTH.value = this.curpath + "." + dargs.CURPTH.value;
				dargs.THIS.value = this.parent;
			}
			tracerJs.debug && tracerJs.debug("call resource.runScripts");
			astatus += this.parent.runScripts(_, "$METHODS", dargs);
		}
		return astatus;
	}
});