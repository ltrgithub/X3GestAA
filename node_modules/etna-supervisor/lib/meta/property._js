"use strict";

var ez = require("ez-streams");
var util = require("etna-supervisor/lib/util");
var variables = require('etna-engine/lib/runtime/variables');
var InstanceProperty = require("etna-supervisor/lib/instanceProperty").InstanceProperty;
var InstanceReference = require("etna-supervisor/lib/InstanceReference").InstanceReference;
var InstanceCollection = require("etna-supervisor/lib/instanceCollection").InstanceCollection;
var glob = require('streamline/lib/globals');
var tracerJs = require("syracuse-trace/lib/helper").getTracer("etna.supervisor");

var FACETS = require("etna-supervisor/lib/meta/representation").FACETS;

var Property = exports.constructor = util.defineClass(function(superv, clas, data, repr) {
	this.supervisor = superv;
	this.data = data;
	this.class = clas;
	this.representation = repr;
}, null, {
	init: function(_) {
		if (this.type) return this;
		if (this.data.CODTYP) {
			this.type = this.supervisor.load(_, 'Type', this.data.CODTYP);
			if (!this.type) throw new Error('type not found: ' + this.data.CODTYP);
			if (this.type.data.NOLIB >= 0) {
				this.data.NOLIB = this.type.data.NOLIB;
			}
		}
		return this;
	},
	name: {
		get: function() {
			return this.isExtra === true ? this.data.CODFLD : this.data.FLDCLA;
		}
	},
	etnaType: {
		get: function() {
			return this.type.etnaType;
		}
	},
	set: function(value) {
		this.set.key = this.set.key || "L" + this.etnaType + ((this.etnaType === 'S') ? (this.data.LONG || this.type.data.LNGTYP || 250) : '');
		return variables.types[this.etnaType].set(this.name, this.set.key, value);
	},
	createInstance: function(parent) {
		if (this.collection) {
			return new InstanceCollection(parent, this.collection);
		}
		if (this.reference) return new InstanceReference(parent, this);
		return new InstanceProperty(parent, this);
	},
	clone: function(repr) {
		var p = new Property(this.supervisor, this.class, this.data, repr);
		p.type = this.type;
		p.collection = this.collection;
		return p;
	},
	targetClass: function(_) {
		if (!this.data.LNKCLA) return null;
		return this.supervisor.load(_, 'Class', this.data.LNKCLA);
	},
	prototypeNode: function(_) {
		var self = this;
		var node = {};

		if (this.exportedProperty && this.exportedProperty.data.INTPRO) node.$title = this.supervisor.loadText(_, this.exportedProperty.data.INTPRO);
		else node.$title = this.supervisor.loadText(_, this.data.INTFLD);

		if (this.exportedProperty && this.exportedProperty.data.INTSHTPRO > 0) node.$shortTitle = this.supervisor.loadText(_, this.exportedProperty.data.INTSHTPRO);
		else if (this.exportedProperty && this.exportedProperty.data.INTPRO) node.$shortTitle = this.supervisor.loadText(_, this.exportedProperty.data.INTPRO);
		else if (this.data.INTSHTFLD > 0) node.$shortTitle = this.supervisor.loadText(_, this.data.INTSHTFLD);
		else node.$shortTitle = this.supervisor.loadText(_, this.data.INTFLD);

		if (this.exportedProperty && this.exportedProperty.data.TYPAFFPRO !== 2) node.$isReadOnly = true;
		if (this.data.OBLIG === 2) node.$isMandatory = true;
		if (this.exportedProperty && this.exportedProperty.data["STA" + FACETS[this.resourceFactory.facet].prefix + "PRO"] === 2) node.$isHidden = true;
		else if (this.exportedProperty && this.exportedProperty.data["STA" + FACETS[this.resourceFactory.facet].prefix + "PRO"] === 3) node.$isExcluded = true;

		if (this.targetResourceFactory) {
			this.targetResourceFactory.fillTypeNode(_, node);
			if (this.collection && this.collection.mappingData && [2, 4].indexOf(this.collection.mappingData.TYPLNK) >= 0) {
				if (node.$item.$properties) node.$item.$instanceUrl = "{$instanceUrl}/" + this.name + "('{$uuid}')";
			}
			node.$maxItems = this.collection.data.MAXCOL;
		} else if (this.data.CODTYP != null) {
			if ((!this.isExtra && this.column !== undefined) || (this.class.data.TYPCLA && this.class.data.TYPCLA !== 2) || (this.type && this.type.data.CODCLA === 'ATEXTRA')) {
				if (this.type.data.TYPTYP === 7 || this.data.CODTYP === "ATX") {
					node.$capabilities = "sort,filter,filter_upper";
				} else if (this.type.data.TYPTYP !== 9 && this.type.data.TYPTYP !== 10) {
					node.$capabilities = "sort,filter";
				}
				if (this.type && this.type.data.CODCLA === 'ATEXTRA' && this.resourceFactory && this.resourceFactory.facet === '$edit') {
					node.$capabilities += ",localize";
				}
			}
			this.supervisor.fillTypeNode(_, this.data, node);
			if (this.exportedProperty && this.exportedProperty.data.UOMPRO !== undefined) {
				node.$value = {
					$title: "{$value} {$unit}",
					$type: node.$type,
					$precision: node.$precision,
					$scale: node.$scale,
					$format: node.$format,
				};
				delete node.$precision;
				delete node.$scale;
				delete node.$format;
				node.$type = "application/x-quantity";
				var propData = util.find(this.resourceFactory.representation.data.EXPORTED_PROPERTIES, 'CODPRO', this.exportedProperty.data.UOMPRO);
				node.$unit = propData.ALIAS + "_REF";
			}
			if (this.links && this.links["ALOB"]) {
				if (this.isExtra === true) var repr = this.class;
				else var repr = this.representation;

				if (this.type.atypepro.lisflg !== 2) {
					node.$acceptedTypes = [this.type.atypepro.protyp];
				} else {
					if (this.isExtra === true && this.class.data.PARAMS) {
						var acceptedTypes = this.class.data.PARAMS.filter(function(paramData) {
							return paramData.TYPPAR === 2 && paramData.CODFLD === self.name;
						}, this).reduce_(_, function(_, r, paramData) {
							var typpro = self.supervisor.load(_, 'Typepro', paramData.VALEUR);
							if (typpro) r.push(typpro.data.PROTYP);
							return r;
						}, []);
					} else if (this.class.data.PARAM_FLDS) {
						var acceptedTypes = this.class.data.PARAM_FLDS.filter(function(paramData) {
							return paramData.TYPPAR === 2 && paramData.FLDCLA === self.name;
						}, this).reduce_(_, function(_, r, paramData) {
							var typpro = self.supervisor.load(_, 'Typepro', paramData.VALEUR);
							if (typpro) r.push(typpro.data.PROTYP);
							return r;
						}, []);
					}
					if (acceptedTypes && acceptedTypes.length > 0) node.$acceptedTypes = acceptedTypes;
				}
				if (this.resourceFactory.facet === "$edit") node.$url = "{$instanceUrl}/" + this.name;
				else {
					if (this.type.data.TYPTYP === 10)
						node.$url = "{$baseUrl}/CDOC('";
					else
						node.$url = "{$baseUrl}/BDOC('";
					var sep = "~%C2%A8~";
					if (repr.class.data.CODREP)
						node.$url = node.$url + "R_" + repr.class.data.CODREP;
					else
						node.$url = node.$url + "C_" + repr.class.data.CODCLA;
					node.$url = node.$url + sep + this.name + this.links["ALOB"].keys.map(function(paramData) {
						return sep + (paramData.alias ? '{' + paramData.alias + '}' : paramData.value);
					}, this).join('');
					if (this.links["ALOB"].params)
						node.$url = node.$url + this.links["ALOB"].params.map(function(paramData) {
							return sep + (paramData.alias ? '{' + paramData.alias + '}' : paramData.value);
						}, this).join('');
					node.$url = node.$url + "')";
				}
			}
		} else {
			return console.error("ignoring prototype property " + this.name), undefined;
		}

		if (this.resourceFactory && this.resourceFactory.facet !== '$bulk' && this.links) {
			Object.keys(this.links).forEach_(_, function(_, name) {
				if (self.links[name].data.CMPLNK !== 19) {
					node.$links = node.$links || {};
					node.$links[name] = self.links[name].prototypeNode(_);
				}
			});
		}
		//if (this.type && (this.type.data.TYPPROSYR === 'ATYPE3' || this.type.data.CODCLA === 'ATEXTRA') //
		if (this.type && this.type.data.CODCLA === 'ATEXTRA' && this.resourceFactory && this.resourceFactory.facet === '$edit') {
			node.$links = node.$links || {};
			node.$links["$localize"] = {
				$type: 'application/json;vnd.sage=syracuse',
				$title: this.supervisor.loadMess(_, 124, 232),
				$url: ''
			};
			if (this.exportedProperty.data.CODPRO.indexOf('.') >= 0) {
				node.$links["$localize"].$url = '{$instanceUrl}/' + this.exportedProperty.data.ALIAS + '/$localize';
			} else {
				node.$links["$localize"].$url = '{$repUrl}/' + this.exportedProperty.data.ALIAS + '/$localize';
			}
		}
		return node;
	},
	calculateRef: function(_, item) {
		//Get target representation
		var codrep = "";
		var typmskrep = 1;
		if (this.isExtra) typmskrep = this.class.data.TYPMSKREP;
		else typmskrep = this.representation.data.TYPMSKREP;
		switch (typmskrep) {
			case 2:
				codrep = this.type.data.DEFREPMOB;
				break;
			case 3:
				codrep = this.type.data.DEFREPTAB;
				break;
			default:
				codrep = this.type.data.DEFREPDES;
				break;
		}
		var repr = this.supervisor.load(_, 'Representation', codrep);
		if (!repr) throw new util.HttpError(404, "representation not found: " + codrep);

		var facet = '$lookup';
		if (!repr.isFacetEnabled('$lookup')) {
			facet = '$details';
			if (!repr.isFacetEnabled('$details')) {
				facet = '$lookup';
				throw new util.HttpError(406, repr.name + " facet not enabled: $lookup");
			}
		}
		var reprResFact = repr.resourceFactory(_, facet);
		//Get target Class

		var targetClass = this.type.targetClass(_);
		if (targetClass == null) throw new Error("target class missing for reference: " + this.name);
		var self = this;
		if (this.isExtra === true && this.class.data.PARAMS) {
			var keyParams = this.class.data.PARAMS.filter(function(paramData) {
				return paramData.TYPPAR === 1 && paramData.CODFLD === self.name && paramData.TYPKEY === 2;
			}, this).reduce(function(r, paramData) {
				var propData = util.find(self.resourceFactory.representation.data.EXPORTED_PROPERTIES, 'CODPRO', paramData.VALEUR);
				if (propData) paramData.alias = propData.ALIAS;
				r.push(paramData);
				return r;
			}, []);
		} else if (this.class.data.PARAM_FLDS) {
			var tabpath = this.exportedProperty.data.CODPRO.split('.');
			var path = tabpath.slice(0, tabpath.length - 1).join('.');

			var keyParams = this.class.data.PARAM_FLDS.filter(function(paramData) {
				return paramData.TYPPAR === 1 && paramData.FLDCLA === self.name && paramData.TYPKEY === 2;
			}, this).reduce(function(r, paramData) {
				var propData = util.find(self.representation.data.EXPORTED_PROPERTIES, 'CODPRO', path + "." + paramData.VALEUR);
				if (propData) paramData.alias = propData.ALIAS;
				r.push(paramData);
				return r;
			}, []);
		} else {
			var keyParams = [];
		}

		item.$url = "{$baseUrl}/" + targetClass.name + "('{$key}" + "')?representation=" + codrep + "." + facet;

		item.$value = reprResFact.keyItems.map(function(keyitem) {
			return '{' + keyitem.alias + '}';
		}, this).join('~');

		item.$properties = {};
		reprResFact.keyItems.forEach_(_, function(_, keyitem) {
			item.$properties[keyitem.alias] = {};
			keyParams.forEach_(_, function(_, paramData) {
				if (keyitem.prop === paramData.CODPAR) {
					if (item.$key === undefined) item.$key = "";
					else item.$key = item.$key + '~';

					var targetProp = targetClass.property(paramData.CODPAR);
					// TODO: next line could cause infinite recursion??
					this.supervisor.fillTypeNode(_, targetProp.data, item.$properties[keyitem.alias]);
					delete item.$properties[keyitem.alias].$maxLength;

					if (paramData.alias) {
						item[keyitem.alias] = '{' + paramData.alias + '}';
						item.$key = item.$key + '{' + keyitem.alias + '}';
					} else {
						item[keyitem.alias] = paramData.value;
						item.$key = item.$key + paramData.value;
					}
				}
			}, this, keyitem);
		}, this);
	},
	prototypeRefNode: function(_, simpleNode) {
		var self = this;
		var node = {
			$title: simpleNode.$title,
			$shortTitle: simpleNode.$shortTitle,
			$type: "application/x-reference",
			$capabilities: simpleNode.$capabilities,
			$isMandatory: simpleNode.$isMandatory,
			$isExcluded: simpleNode.$isExcluded,
			$isHidden: simpleNode.$isHidden,
			$isReadOnly: simpleNode.$isReadOnly,
			$item: {}
		};
		if (this.resourceFactory.facet === "$edit") node.$maxLength = simpleNode.$maxLength;
		delete simpleNode.$title;
		delete simpleNode.$shortTitle;
		delete simpleNode.$capabilities;
		delete simpleNode.$isReadOnly;
		delete simpleNode.$isMandatory;
		simpleNode.$isExcluded = true;

		//console.error("CREATING REF FOR: " + this.class.name + "." + this.name);
		var item = node.$item;
		if (this.links) {
			if (this.links['$lookup']) {
				var link = this.links['$lookup'];
				var facet = '$lookup';
			} else if (this.links['$details']) {
				var link = this.links['$details'];
				var facet = '$details';
			}
		}

		if (!link) {
			//We should not go there but still leaves the code
			// is it possible to have a reference with out lookup or details ??
			self.calculateRef(_, item);
		} else {

			item.$url = "{$baseUrl}/" + link.data.CLALNK + "('{$key}" + "')?representation=" + link.data.REPLNK + "." + facet;
			if (this.isExtra === true)
				var repr = this.class;
			else
				var repr = this.representation;

			if (link.data.REPLNK === repr.name) {
				var f = repr.resourceFactory(_, facet);
			} else {
				var rep = this.supervisor.load(_, 'Representation', link.data.REPLNK);
				if (!rep) throw new util.HttpError(404, "representation not found: " + link.data.REPLNK);
				var f = rep.resourceFactory(_, facet);
			}

			item.$properties = {};

			if (f.keyItems)
				f.keyItems.forEach_(_, function(_, keyitem) {
					item.$properties[keyitem.alias] = {};
					link.keys.forEach_(_, function(_, paramData) {
						if (keyitem.prop === paramData.CODPAR) {
							if (item.$key === undefined) item.$key = "";
							else item.$key = item.$key + '~';

							if (paramData.ADRVAL === 1 || paramData.alias === self.tag) {
								if (item.$value === undefined) item.$value = "";
								else item.$value = item.$value + '~';
								item.$value = item.$value + '{' + keyitem.alias + '}';
							}

							var targetProp = f.class.property(paramData.CODPAR);
							this.supervisor.fillTypeNode(_, targetProp.data, item.$properties[keyitem.alias]);
							delete item.$properties[keyitem.alias].$maxLength;
							if (paramData.ADRVAL > 1) item.$properties[keyitem.alias].$isReadOnly = true;

							if (paramData.alias) {
								item[keyitem.alias] = '{' + paramData.alias + '}';
								item.$key = item.$key + '{' + keyitem.alias + '}';
							} else {
								item[keyitem.alias] = paramData.value;
								item.$key = item.$key + paramData.value;
							}
						}
					}, this, keyitem);
				}, this);

		}
		item.$links = simpleNode.$links;
		delete simpleNode.$links;

		return node;
		/* for info, typical result
		"C06P02_REF": {
			"$title": "{@28440}",
			"$shortTitle": "{@28440}",
			"$type": "application/x-reference",
			"$capabilities": "sort,filter",
			"$item": {
				"$url": "{$baseUrl}/AQCPROR02('{$key}')?representation=AQCPROR02.$lookup",
				"$value": "{R02P01}",
				"$key": "{R02P01}~{R02P02}",
				"$properties": {
					"R02P01": {
						"$type": "application/x-string"
					},
					"R02P02": {
						"$type": "application/x-integer"
					}
				},
				"R02P01": "{C06P02}",
				"R02P02": "{C06P03}",
				"$links": {
					"$details": {
						"$title": "{@28123}",
						"$target": "",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/AQCPROR02('{C06P02}~{C06P03}')?representation=AQCPROR02.$details"
					},
					"$lookup": {
						"$title": "{@6109}",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/AQCPROR02?representation=AQCPROR02.$lookup"
					},
					"$summary": {
						"$title": "{@25036}",
						"$target": "",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/AQCPROR02('{C06P02}~{C06P03}')?representation=AQCPROR02.$summary"
					},
					"$query": {
						"$title": "{@27982}",
						"$target": "",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/AQCPROR02?representation=AQCPROR02.$query"
					}
				}
			}
		},*/
	},
	column: {
		get: function() {
			//dbg:tracerJs.debug && tracerJs.debug("column ? "+(!!this.class.table));
			return (this.class.table && this.class.table.column(this.data.FLDCLA)) || undefined;
		}
	},

	getSql: function(_, colNames, tableNames, wheres, params, descs, cache, raw) {
		tracerJs.debug && tracerJs.debug("property.getSql:" + this.name);
		if (!this.name) return null;
		var column = this.column;
		if (/^AX[123X]/.test(this.data.CODTYP)) {
			//dbg:tracerJs.debug && tracerJs.debug("property.getSql AXX:"+this.name+" cache.texts:"+JSON.stringify(cache.texts));

			cache.texts = cache.texts || {
				properties: {}
			};

			var keyNames = this.class.table.indexes[0].sqlNames(_).slice(0, 2).map(function(key) {
				return key.substring(0, key.length - 2);
			});

			var self = this;
			var atextra = this.class.data.PARAM_FLDS.filter(function(paramData) {
				return paramData.TYPPAR === 1 && paramData.FLDCLA === self.name && paramData.TYPKEY === 2;
			}, this).reduce_(_, function(_, r, paramData) {
				r[paramData.CODPAR] = self.addFieldTransform(_, paramData.VALEUR);
				return r;
			}, {});


			cache.texts.getKeyText = cache.texts.getKeyText || function(record) {
				tracerJs.debug && tracerJs.debug("getKeyText " + atextra.IDENT1(record) + '~' + (atextra.IDENT2(record) || " "));
				return atextra.IDENT1(record) + '~' + (atextra.IDENT2(record) || " ");
			};

			cache.texts.properties[this.name] = {
				ids: [],
				texts: null,
				cacheTextKey: function(property, keys) {
					return function(cache, record) {
						record.$id = cache.texts.getKeyText(record);
						cache.texts.properties[property].ids.push(record.$id);
						return record;
					};
				}(this.name, keyNames),
				loadText: function(_this, zone, atextra) {
					//dbg:tracerJs.debug && tracerJs.debug("create loadText codfic:"+codfic+' zone:'+zone+' lan:'+lan);
					return function(_, textId) {

						if (!_this.class.cache.texts) return "";

						if (_this.class.cache.texts.properties[zone].texts === null) {
							var param = _this.supervisor.sqlDriver.param;
							var params = [];
							var wheres = [];

							params.push(atextra.CODFIC({}));
							wheres.push("CODFIC_0=" + param(params.length - 1));
							params.push(atextra.ZONE({}));
							wheres.push("ZONE_0=" + param(params.length - 1));
							params.push(atextra.LANGUE({}));
							wheres.push("LANGUE_0=" + param(params.length - 1));

							var getTextId = function(record) {
								return record.IDENT1 + '~' + (record.IDENT2 || " ");
							};
							wheres.push("((" +
								_this.class.cache.texts.properties[zone].ids.reduce(function(r, id) {
									var parts = id.split('~');
									params.push(parts[0]);
									params.push(parts[1]);
									r.push("IDENT1_0=" + param(params.length - 2) + " and " + "IDENT2_0=" + param(params.length - 1));
									return r;
								}, []).join(") or (") + "))");
							var sql = "select IDENT1_0, IDENT2_0, ZONE_0, TEXTE_0 from ATEXTRA  where (" + wheres.join(" and ") + ")";
							tracerJs.debug && tracerJs.debug("sql:" + sql);
							tracerJs.debug && tracerJs.debug("params:" + params);
							var self = _this;

							_this.class.cache.texts.properties[zone].texts = _this.supervisor.sqlDriver.withConnection(_, function(_, cnx) {
								return self.supervisor.sqlReader(_, cnx, sql, params).toArray(_);
							}).reduce(function(r, record) {
								tracerJs.debug && tracerJs.debug("record	:" + JSON.stringify(record));
								r[getTextId(record)] = record.TEXTE;
								return r;
							}, {});
							// clear the list of text ids
							_this.class.cache.texts.properties[zone].ids = [];
						}
						//dbg:tracerJs.debug && tracerJs.debug("loadText zone:"+zone+' textId:'+textId+" ="+_this.class.cache.texts.properties[zone].texts[textId]);
						return _this.class.cache.texts.properties[zone].texts[textId] || "";
					};
				}(this, this.name, atextra)
			};

		} else if (column) {
			column.getSql(_, colNames, tableNames, wheres, params, descs, cache, raw);

			if (this.isReference(_)) {
				this.getReferenceKey = function(_, $this, superv) {
					var self = $this;
					var name = self.name;
					var refKeys = self.class.data.PARAM_FLDS.filter(function(paramData) {
						return paramData.TYPPAR === 1 && paramData.FLDCLA === name && paramData.TYPKEY === 2;
					}, this).reduce_(_, function(_, r, paramData) {
						r[paramData.CODPAR] = self.addFieldTransform(_, paramData.VALEUR);
						return r;
					}, {});
					return function(record) {
						return Object.keys(refKeys).reduce(function(r, k) {
							r.push(refKeys[k](record) || "");
							return r;
						}, []).join('~');

					};
				}(_, this, this.supervisor);

				cache.references = cache.references || {};
				cache.references[this.name] = {
					$name: this.name,
					$ids: {},
					cacheReference: function(_, name, $getReferenceKey) {
						return function(cache, record) {
							var id = $getReferenceKey(record);
							if (id) cache.references[name].$ids[id] = null;
							return record;
						};
					}(_, this.name, this.getReferenceKey)
				};
			}
		} else if (this.collection && this.collection.ofIndexedProperties) {
			tracerJs.debug && tracerJs.debug("property.getSql " + this.name + " =>collection");
			// it's a denormalized collection :
			this.collection.getSql(_, colNames, tableNames, wheres, params, descs, cache, raw);
		}

	},
	isSearchable: {
		get: function() {
			return this.data && this.data.FLDSEARCH && (this.data.FLDSEARCH === 2);
		}
	},
	isReference: function(_, value) {
		if (value === undefined) {
			//var reference = (this.type && this.type.data.CODCLA && this.type.data.DEFREPDES); //this.type.data.CODCLA.length);
			var reference = (this.type && this.type.data.TYPSELSYR === 2);

			if (reference && this.class && this.class.table) {
				// A instance cannot be a reference of itself:
				reference = !((this.class.table.indexes[0].sqlNames(_).length === 1) && (this.class.name === this.type.data.CODCLA));
			}
			reference = !! reference;
			return reference;
		}
		this.reference = value;
		return;
	},
	addFieldTransform: function(_, value, index, refReader) {
		var regNum$ = /num\$\((\w*)\)/;

		if (value === '""') {
			return function() {
				return function() {
					return " ";
				};
			}();
		} else if (value.charAt(0) === '"') {
			return function(constant) {
				return function(record) {
					return constant;
				};
			}(value.substring(1, value.length - 1));
		} else if (typeof value === 'number' || (/^\d+$/.test(value))) {
			return function(constant) {
				return function(record) {
					return constant;
				};
			}(value);
		} else if (value.substring(0, 5) === 'ACTX.') {
			return function(constant) {
				return function(record) {
					return constant;
				};
			}(glob.context.x3session.actx.get(_, value.substring(5)));
		} else if (regNum$.test(value)) {
			var match = regNum$.exec(value);
			return function(fct) {
				return function(record) {
					return fct(record).toString();
				};
			}(this.addFieldTransform(_, match[1], index, refReader));
		} else {
			if (index && refReader && index.indexOf(value) < 0) {
				refReader.columns = refReader.columns || [];
				refReader.columns.push(value);
			}
			return function(column) {
				return function(record) {
					return record[column];
				};
			}(value);
		}
	},
	loadReference: function(_, record) {
		this.loadReferenceData = this.loadReferenceData || function(_, id) {
			tracerJs.debug && tracerJs.debug("loadReferenceData(" + this.name + "):" + id);

			function addTextTransform(_, _this, superv, attribute, reference, column, refReader) {

				if (!column) return;

				if (/^AX[123X]/.test(reference.properties[column].type.data.CODTYP)) {
					var index = reference.table.indexes[0].sqlNames(_).map(function(key) {
						return key.substring(0, key.length - 2);
					});


					var self = _this;
					var atextra = reference.data.PARAM_FLDS.filter(function(paramData) {
						return paramData.TYPPAR === 1 && paramData.FLDCLA === column && paramData.TYPKEY === 2;
					}, this).reduce_(_, function(_, r, paramData) {
						r[paramData.CODPAR] = self.addFieldTransform(_, paramData.VALEUR, index, refReader);
						return r;
					}, {});

					return function(superv, atextra, attribute) {
						return function(_, reader, writer) {
							var param = superv.sqlDriver.param;
							var params = [];
							var wheres = [];

							var rs = reader.readAll(_);
							if (rs && rs.length) {
								params.push(atextra.CODFIC(rs[0]));
								wheres.push("CODFIC_0=" + param(params.length - 1));
								params.push(atextra.ZONE(rs[0]));
								wheres.push("ZONE_0=" + param(params.length - 1));
								params.push(atextra.LANGUE(rs[0]));
								wheres.push("LANGUE_0=" + param(params.length - 1));

								var getTextId = function(record) {
									return record.IDENT1 + '~' + (record.IDENT2 || " ");
								};
								wheres.push("((" +
									rs.reduce(function(r, record) {
										var id1 = atextra.IDENT1(record.record);
										var id2 = atextra.IDENT2(record.record);
										params.push(id1);
										params.push(id2);
										record.reference[attribute] = id1 + '~' + id2;
										r.push("IDENT1_0=" + param(params.length - 2) + " and " + "IDENT2_0=" + param(params.length - 1));
										return r;
									}, []).join(") or (") + "))");



								var sql = "select IDENT1_0, IDENT2_0, ZONE_0, TEXTE_0 from ATEXTRA  where (" + wheres.join(" and ") + ")";
								tracerJs.debug && tracerJs.debug("sql:" + sql);
								tracerJs.debug && tracerJs.debug("params:" + params);

								var texts = superv.sqlDriver.withConnection(_, function(_, cnx) {
									return superv.sqlReader(_, cnx, sql, params).toArray(_);
								}).reduce(function(r, text) {
									r[getTextId(text)] = text.TEXTE;
									return r;
								}, {});

								rs.forEach_(_, function(_, record) {
									// update the reference:
									record.reference[attribute] = texts[record.reference[attribute]];
									//pipe the record
									writer.write(_, record);
								});
							}

						};
					}(superv, atextra, attribute);
				} else {
					refReader.columns = refReader.columns || [];
					refReader.columns.push(column);

					return function(_, reader, writer) {
						var record;
						while (record = reader.read(_)) {
							record.reference[attribute] = record.record[column];
							writer.write(_, record);
						}
					};
				}
				return;
			}

			try {
				if (!Object.keys(this.class.cache.references[this.name].$ids).length) return;

				// First create empty references :
				var refs = this.class.cache.references[this.name];
				Object.keys(refs.$ids).forEach(function(id) {
					refs[id] = {};
				});

				this.class.cache.references[this.name][id] = null;

				var reference = this.supervisor.load(_, 'Class', this.type.data.CODCLA);
				if (!reference) return;

				//var actx = glob.context.x3session.actx;

				//TODO : "COLDEC", "COLLNG"
				var refMaps = {
					SYMBOL: function(column) {
						return function(item) {
							item.reference.$symbol = item.record[column] || null;
						};
					},
					COLFMT: function(column) {
						return function(item) {
							var colfmt = item.record[column];
							if (colfmt) {
								colfmt = colfmt.split('.');
								item.reference.$precision = parseInt(colfmt[0]);
								item.reference.$scale = (colfmt.length > 1) ? parseInt(colfmt[1]) : 0;
							}
						};
					}
				};
				var refReader = Object.keys(refMaps).reduce(function(r, field) {
					if (reference.table.data[field]) {
						r.columns = r.columns || [];
						var column = reference.table.data[field];
						r.columns.push(column);
						r.maps = r.maps || [];
						if (refMaps[field]) {
							r.maps.push(refMaps[field](column));
						}
					}
					return r;
				}, {});

				var titleTransform = addTextTransform(_, this, this.supervisor, "$title", reference, reference.table.data.INTITC, refReader);
				var descTransform = addTextTransform(_, this, this.supervisor, "$description", reference, reference.table.data.INTIT, refReader);

				var reader;
				if (refReader.columns) {
					// The reference table has to be read first :
					var param = this.supervisor.sqlDriver.param;
					var params = [];
					var wheres = [];
					var ids = Object.keys(this.class.cache.references[this.name].$ids);

					var names = reference.table.indexes[0].sqlNames(_);

					var getRecordId = function(names) {
						var fields = names.map(function(name) {
							return name.substring(0, name.length - 2);
						});
						return function(record) {
							return fields.reduce(function(r, field) {
								r.push(record[field]);
								return r;
							}, []).join('~');
						};
					}(names);

					if (names.length === 1) {
						wheres.push(names[0] + " in (" + ids.map(function(id) {
							params.push(id);
							return param(params.length - 1);
						}) + ")");
					} else {
						wheres.push("(" +
							ids.map(function(id) {
								var n = 0;
								return id.split('~').reduce(function(r, part) {
									params.push(part);
									r.push(names[n++] + "=" + param(params.length - 1));
									return r;
								}, []).join(" and ");
							}).join(") or (") + ")");
					}
					// add other colums :
					names = names.concat(refReader.columns.map(function(column) {
						return column + '_0';
					}));
					var sql = "select " + names.join(',');
					sql += " from " + reference.table.name + " where (" + wheres.join(" and ") + ")";
					tracerJs.debug && tracerJs.debug("ref sql:" + sql);
					tracerJs.debug && tracerJs.debug("ref params:" + params);

					// create the reader :
					var self = this;
					reader = this.supervisor.sqlDriver.withConnection(_, function(_, cnx) {
						return self.supervisor.sqlReader(_, cnx, sql, params)
							.map(function(_, record) {
								var item = {
									id: getRecordId(record),
									record: record,
									reference: {}
								};
								//apply reference maps:
								refReader.maps && refReader.maps.forEach(function(map) {
									map(item);
								});
								return item;
							});
					});
				}
				if (titleTransform || descTransform) {
					if (!reader) {
						//We need reader
						reader = function(_, reference, ids) {
							var index = reference.table.indexes[0].sqlNames(_).map(function(key) {
								return key.substring(0, key.length - 2);
							});

							return ez.devices.generic.empty.reader.transform(function(_, reader, writer) {
								ids.forEach_(_, function(_, id) {
									var keys = id.split('~');
									var record = {
										id: id,
										record: {},
										reference: {}
									};
									for (var i = 0; i < index.length; i++) {
										record.record[index[i]] = keys[i];
									}
									writer.write(_, record);
								});
							});
						}(_, reference, Object.keys(this.class.cache.references[this.name].$ids));

					}

					if (titleTransform) reader = reader.transform(titleTransform);
					if (descTransform) reader = reader.transform(descTransform);
				}
				if (!reader) return;

				// Pipe elements in the table of references :
				var references = this.class.cache.references[this.name];
				reader.pipe(_, ez.devices.generic.writer(function(_, record) {
					if (record) references[record.id] = record.reference;
				}));

				// clear the list of $ids:
				this.class.cache.references[this.name].$ids = {};

			} catch (e) {
				tracerJs.debug && tracerJs.debug(JSON.stringify(e));
			} finally {
				tracerJs.debug && tracerJs.debug("loadReferenceData:" + JSON.stringify(this.class.cache.references[this.name][id]));
				return this.class.cache.references[this.name][id];
			}
		};

		var refId = this.getReferenceKey(record);
		tracerJs.debug && tracerJs.debug("loadReference " + this.name + " id:" + refId);
		if (!refId.length) return {};

		var reference = this.class.cache.references[this.name][refId];
		if (reference === undefined) {
			this.class.cache.references[this.name][refId] = reference = this.loadReferenceData(_, refId);
		}
		return reference;
	}
});