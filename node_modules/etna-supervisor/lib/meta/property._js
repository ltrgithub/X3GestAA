"use strict";

var ez = require("ez-streams");
var util = require("etna-supervisor/lib/util");
var tuuid = require('etna-engine/lib/runtime/tuuid');
var tdatetime = require('etna-engine/lib/runtime/tdatetime');
var variables = require('etna-engine/lib/runtime/variables');
var glob = require('streamline/lib/globals');
var tracerJs = require("syracuse-trace/lib/helper").getTracer("etna.supervisor");
var constants = require("etna-supervisor/lib/constants");
var FACETS = require("etna-supervisor/lib/meta/representation").FACETS;

function alias(alias) {
	return '{' + alias + '}';
}

/*
 - superv, clas, data are mandatory arguments of the constructor
 - newMaker, collection are optionals
*/
var Property = exports.constructor = util.defineClass(function(superv, clas, data, newMaker, collection) {
	this.supervisor = superv;
	this.data = data;
	util.checkDataProperty(this.data, "NUMFLD");
	util.checkDataProperty(this.data, "LONG");

	// class can be a representation !
	this.class = clas;
	this.collection = collection;

	this.newMaker = undefined;
	this.new = undefined;
	if (newMaker) {
		this.newMaker = newMaker;
		this.new = newMaker(this);
	}
	// Properties defined in init :
	this.type = undefined;
	this.$x3Format = undefined;
}, null, {
	init: function(_) {
		if (this.type) return this;
		if (this.data.CODTYP) {
			this.type = this.supervisor.load(_, 'Type', this.data.CODTYP);
			if (!this.type) throw new Error('type not found: ' + this.data.CODTYP);
			if (this.type.data.NOLIB > 0) {
				this.data.NOLIB = this.type.data.NOLIB;
			}
			this.$x3Format = this.type.getX3Format(this.data.LONG);
			if (this.$x3Format) tracerJs.debug && tracerJs.debug(" " + this.name + ".$x3Format=" + this.$x3Format);
		}
		return this;
	},
	name: {
		get: function() {
			return this.data.FLDCLA || this.data.CODFLD;
		}
	},
	isExtra: {
		get: function() {
			return !!this.data.CODFLD;
		}
	},
	etnaType: {
		get: function() {
			return this.type.etnaType;
		}
	},
	column: {
		get: function() {
			//dbg:tracerJs.debug && tracerJs.debug("column ? "+(!!this.class.table));
			return (this.class.table && this.class.table.column(this.data.FLDCLA)) || undefined;
		}
	},
	params: {
		get: function() {
			return this.class.data.PARAM_FLDS || this.class.data.PARAMS;
		}
	},
	keyParams: {
		get: function() {
			var self = this;
			return this.params ? this.params.filter(function(p) {
				return p.TYPPAR === 1 && (p.FLDCLA === this.name || p.CODFLD === this.name) && p.TYPKEY === 2;
			}, this) : [];
		}
	},
	keyMaps: function(_) {
		if (!this._keyMaps) {
			var self = this;
			this._keyMaps = this.keyParams.reduce_(_, function(_, r, paramData) {
				r[paramData.CODPAR] = self.addFieldTransform(_, paramData.VALEUR);
				return r;
			}, {});
		}
		return this._keyMaps;
	},
	typeParams: {
		get: function() {
			var self = this;
			return this.params ? this.params.filter(function(p) {
				return p.TYPPAR === 2 && (p.FLDCLA === this.name || p.CODFLD === this.name);
			}, this) : [];
		}
	},
	isSearchable: {
		get: function() {
			return this.data.FLDSEARCH === 2;
		}
	},
	isAtextra: {
		get: function() {
			return /^AX[123X]/.test(this.data.CODTYP);
		}
	},
	isText: {
		get: function() {
			return this.data.CODTYP === "ATX";
		}
	},
	isArray: {
		get: function() {
			return this.collection && !this.collection.mappingData && this.collection.nbrPro === 1;
		}
	},
	isInstance: {
		get: function() {
			return this.collection && this.collection.isInstance;
		}
	},
	instance: function(resource) {
		return resource.instance ? (this.isExtra ? resource : resource.instance) : resource;
	},
	ref: function(tag) {
		return tag + '_REF';
	},
	setAtextra: function(_, instance) {
		var atextra = this.supervisor.newInstance(_, "ATEXTRA");
		// Set atextra properties
		var self = this;
		var keyMaps = this.keyMaps(_);
		Object.keys(keyMaps).forEach_(_, function(_, key) {
			var keyVal = keyMaps[key](_, instance);
			keyVal = keyVal ? keyVal : " ";
			atextra.set(_, key, keyVal, true);
		});
		return atextra;
	},
	updateAtextra: function(_, instance, value) {
		// Create an instance of atextra
		var atextra = this.setAtextra(_, instance);
		// Add the text:

		var options = {
			crud: false,
			raw: true
		};

		// Try to insert the instance of atextra 
		// var st = atextra.read(_, atextra.getKeyTab(_), options);
		// atextra.set(_, "TEXTE", value, true);

		// if (st === constants.CST_AOK) atextra.update(_, options);
		// else atextra.insert(_, options);

		atextra.set(_, "TEXTE", value, true);
		try {
			// Try to insert 
			atextra.insert(_, options);
		} catch (e) {
			// Update if already inserted: 
			atextra.update(_, options);
		}
	},
	deleteAtextra: function(_, instance) {
		// Create an instance of atextra
		var atextra = this.setAtextra(_, instance);

		// Delete the instance of atextra 
		atextra.delete(_, {
			crud: false,
			raw: true
		});
	},
	set: function(value) {
		this._key = this._key || "L" + this.etnaType + ((this.etnaType === 'S') ? (this.data.LONG || this.type.data.LNGTYP || 250) : '');
		//dbg:console.log("set "+this.name+ " type:"+this.etnaType+" key:"+this._key+" value:'"+value+"'");
		return variables.types[this.etnaType].set(this.name, this._key, value);

	},
	clone: function() {
		var p = new Property(this.supervisor, this.class, this.data, this.newMaker, this.collection);
		// + set properties initialize in init (aynschronous function)
		p.type = this.type;
		p.$x3Format = this.$x3Format;
		return p;
	},
	targetClass: function(_) {
		if (!this.data.LNKCLA) return null;
		return this.supervisor.load(_, 'Class', this.data.LNKCLA);
	},
	findExportedProperty: function(name) {
		var exportedProperties = this.resourceFactory ?
			this.resourceFactory.representation.data.EXPORTED_PROPERTIES : undefined;
		return exportedProperties ? util.find(exportedProperties, 'CODPRO', name) : undefined;
	},
	prototypeNode: function(_) {
		// this.resourceFactory is normaly set !
		var factoryFacet = this.resourceFactory.facet;
		var isFactoryEditFacet = (factoryFacet === '$edit');
		var expProData = this.exportedProperty ? this.exportedProperty.data : {};

		var self = this;
		var node = {};

		var title = "";
		if (expProData.INTPRO) title = this.supervisor.loadText(_, this.exportedProperty.data.INTPRO);
		else if (this.data.INTFLD) title = this.supervisor.loadText(_, this.data.INTFLD);
		else if (this.collection && this.collection.data.INTCOL) title = this.supervisor.loadText(_, this.collection.data.INTCOL);
		node.$title = title;

		if (expProData.INTSHTPRO) node.$shortTitle = this.supervisor.loadText(_, this.exportedProperty.data.INTSHTPRO);
		else if (this.data.INTSHTFLD) node.$shortTitle = this.supervisor.loadText(_, this.data.INTSHTFLD);
		node.$shortTitle = title;

		if (expProData.TYPAFFPRO !== undefined && expProData.TYPAFFPRO !== 2) node.$isReadOnly = true;
		if (this.data.OBLIG === 2) node.$isMandatory = true;

		var prefix = FACETS[factoryFacet] && FACETS[factoryFacet].prefix;
		if (prefix) {
			var staPro = expProData["STA" + FACETS[factoryFacet].prefix + "PRO"];
			if (staPro === 2) node.$isHidden = true;
			else if (staPro === 3) node.$isExcluded = true;
		}
		if (this.targetResourceFactory && this.collection) {
			if (!(this.collection.data.MAXCOL === 1 && this.collection.data.MINCOL === 2)) {
				node.$capabilities = [];
				if (this.collection.data.FLGAPDCOL === 2) node.$capabilities.push("append");
				if (this.collection.data.FLGINSCOL === 2) node.$capabilities.push("insert");
				if (this.collection.data.FLGSUPCOL === 2) node.$capabilities.push("delete");
				if (this.collection.data.FLGTRICOL === 2) node.$capabilities.push("reorder");
				node.$capabilities = node.$capabilities.join(',');

				if (this.collection.data.MAXCOL > 0) {
					node.$maxItems = this.collection.data.MAXCOL;
					if (this.collection.data.MINCOL === 3)
						node.$minItems = node.$maxItems;
				}
			}
			this.targetResourceFactory.fillTypeNode(_, node);
			if ((this.collection.mappingData && [2, 4].indexOf(this.collection.mappingData.TYPLNK) >= 0) ||
				(this.collection.class.data &&
					(this.collection.class.data.TYPCLA === 5 || this.collection.ofIndexedProperties === true))) {
				if (node.$item.$properties) node.$item.$instanceUrl = "{$instanceUrl}/" + this.name + "('{$uuid}')";
			}
		} else if (this.data.CODTYP != null) {
			if (isFactoryEditFacet) node.$x3Format = this.$x3Format; // value or undefined !

			if ((!this.isExtra && this.column !== undefined) || (this.class.data.TYPCLA && this.class.data.TYPCLA !== 2) || (this.type.data.CODCLA === 'ATEXTRA')) {
				//#102160 : filter and filter_upper capabilities not supported in $edit facets
				//except for ATEXTRA
				if (this.type.data.CODCLA === 'ATEXTRA') {
					node.$capabilities = ["sort", "filter", "filter_upper"];
				} else if (this.type.data.TYPTYP === 7 || this.data.CODTYP === "ATX") {
					node.$capabilities = (isFactoryEditFacet ? ["sort"] : ["sort", "filter", "filter_upper"]);
				} else if ([9, 10].indexOf(this.type.data.TYPTYP) < 0) {
					node.$capabilities = (isFactoryEditFacet ? ["sort"] : ["sort", "filter"]);
				}
				if (this.type.data.CODCLA === 'ATEXTRA' && isFactoryEditFacet) {
					node.$capabilities.push("localize");
				}
				node.$capabilities = (node.$capabilities || []).join(',');
			}
			this.supervisor.fillTypeNode(_, this.data, node);
			if (expProData.UOMPRO !== undefined) {
				node.$value = ["$type", "$precision", "$scale", "$format"].reduce(function(r, a) {
					r[a] = node[a];
					node[a] = (a == "$type") ? "application/x-quantity" : undefined;
					return r;

				}, {
					$title: "{$value} {$unit}"
				});

				var propData = this.findExportedProperty(this.exportedProperty.data.UOMPRO);
				node.$unit = this.ref(propData.ALIAS);
			}
			if (this.links && this.links.ALOB) {
				var acceptedTypes = (this.type.atypepro.lisflg !== 2) ? [this.type.atypepro.protyp] :
					this.typeParams.reduce_(_, function(_, r, paramData) {
						var typpro = self.supervisor.load(_, 'Typepro', paramData.VALEUR);
						if (typpro) r.push(typpro.data.PROTYP);
						return r;
					}, []);
				if (acceptedTypes.length > 0) node.$acceptedTypes = acceptedTypes;

				if (isFactoryEditFacet) node.$url = "{$instanceUrl}/" + this.name;
				else {
					var urlKey = self.class.data.CODREP ? ["R_" + self.class.data.CODREP] : ["C_" + self.class.data.CODCLA];
					urlKey.push(this.name);
					urlKey = urlKey.concat(this.links.ALOB.keys.map(function(paramData) {
						return paramData.alias ? alias(paramData.alias) : paramData.value;
					}, this));

					if (this.links.ALOB.params)
						urlKey = urlKey.concat(this.links.ALOB.params.map(function(paramData) {
							return paramData.alias ? alias(paramData.alias) : paramData.value;
						}, this));

					node.$url = "{$baseUrl}/" + ((this.type.data.TYPTYP === 10) ? 'C' : 'B') + "DOC('" + urlKey.join("~%C2%A8~") + "')";
				}
			}
		} else {
			return tracerJs.debug("ignoring prototype property " + this.name), undefined;
		}

		if (factoryFacet !== '$bulk' && this.links) {
			Object.keys(this.links).forEach_(_, function(_, name) {
				if (self.links[name].data.CMPLNK !== 19) {
					node.$links = node.$links || {};
					node.$links[name] = self.links[name].prototypeNode(_);
				}
			});
		}
		if (this.type && this.type.data.CODCLA === 'ATEXTRA' && isFactoryEditFacet) {
			node.$links = node.$links || {};
			node.$links.$localize = {
				$type: 'application/json;vnd.sage=syracuse',
				$title: this.supervisor.loadMess(_, 124, 232),
				$url: ''
			};
			node.$links.$localize.$url = ((this.exportedProperty.data.CODPRO.indexOf('.') >= 0) ?
				'{$instanceUrl}/' : '{$repUrl}/') + this.exportedProperty.data.ALIAS + '/$localize';
		}
		return node;
	},
	calculateRef: function(_, item) {
		//Get target representation
		var codrep = "";
		var typmskrep = this.class.data.TYPMSKREP;
		switch (typmskrep) {
			case 2:
				codrep = this.type.data.DEFREPMOB;
				break;
			case 3:
				codrep = this.type.data.DEFREPTAB;
				break;
			default:
				codrep = this.type.data.DEFREPDES;
				break;
		}
		var repr = this.supervisor.load(_, 'Representation', codrep);
		if (!repr) throw new util.HttpError(404, "representation not found: " + codrep);

		var facet = '$lookup';
		if (!repr.isFacetEnabled(facet)) {
			facet = '$details';
			if (!repr.isFacetEnabled(facet)) {
				throw new util.HttpError(406, repr.name + " facet not enabled: $lookup");
			}
		}
		var reprResFact = repr.resourceFactory(_, facet);
		//Get target Class

		var targetClass = this.type.targetClass(_);
		if (targetClass == null) throw new Error("target class missing for reference: " + this.name);
		var self = this;
		var keyParams = [];
		var path = "";
		if (!this.isExtra) {
			var tabpath = this.exportedProperty.data.CODPRO.split('.');
			path = tabpath.slice(0, tabpath.length - 1).join('.') + ".";
		}

		// EXPORTED_PROPERTIES est défini au niveau du root !
		var keyParams = this.keyParams.reduce(function(r, paramData) {
			var propData = self.findExportedProperty(path + paramData.VALEUR);
			if (propData) paramData.alias = propData.ALIAS;
			r.push(paramData);
			return r;
		}, []);

		item.$url = "{$baseUrl}/" + targetClass.name + "('{$key}" + "')?representation=" + codrep + "." + facet;

		item.$value = reprResFact.keyItems.map(function(keyitem) {
			return alias(keyitem.alias);
		}, this).join('~');

		item.$properties = {};
		reprResFact.keyItems.forEach_(_, function(_, keyitem) {
			item.$properties[keyitem.alias] = {};
			item.$key = [];
			keyParams.forEach_(_, function(_, paramData) {
				if (keyitem.prop === paramData.CODPAR) {
					var targetProp = targetClass.property(paramData.CODPAR);
					// TODO: next line could cause infinite recursion??
					this.supervisor.fillTypeNode(_, targetProp.data, item.$properties[keyitem.alias]);
					item.$properties[keyitem.alias].$maxLength = undefined;

					if (paramData.alias) {
						item[keyitem.alias] = alias(paramData.alias);
						item.$key.push(alias(keyitem.alias));
					} else {
						item[keyitem.alias] = paramData.value;
						item.$key.push(paramData.value);
					}
				}
			}, this, keyitem);
			item.$key = item.$key.join('~');
		}, this);
	},
	/* prototypeRefNode generate a 'xxx_REF' node
	for info, typical result
	"C06P02_REF": {
		"$title": "{@28440}",
		"$shortTitle": "{@28440}",
		"$type": "application/x-reference",
		"$capabilities": "sort,filter",
		"$item": {
			"$url": "{$baseUrl}/AQCPROR02('{$key}')?representation=AQCPROR02.$lookup",
			"$value": "{R02P01}",
			"$key": "{R02P01}~{R02P02}",
			"$properties": {
				"R02P01": {
					"$type": "application/x-string"
				},
				"R02P02": {
					"$type": "application/x-integer"
				}
			},
			"R02P01": "{C06P02}",
			"R02P02": "{C06P03}",
			"$links": {
				"$details": {
					"$title": "{@28123}",
					"$target": "",
					"$type": "application/json;vnd.sage=syracuse",
					"$url": "{$baseUrl}/AQCPROR02('{C06P02}~{C06P03}')?representation=AQCPROR02.$details"
				},
				"$lookup": {
					"$title": "{@6109}",
					"$type": "application/json;vnd.sage=syracuse",
					"$url": "{$baseUrl}/AQCPROR02?representation=AQCPROR02.$lookup"
				},
				"$summary": {
					"$title": "{@25036}",
					"$target": "",
					"$type": "application/json;vnd.sage=syracuse",
					"$url": "{$baseUrl}/AQCPROR02('{C06P02}~{C06P03}')?representation=AQCPROR02.$summary"
				},
				"$query": {
					"$title": "{@27982}",
					"$target": "",
					"$type": "application/json;vnd.sage=syracuse",
					"$url": "{$baseUrl}/AQCPROR02?representation=AQCPROR02.$query"
				}
			}
		}
	},*/

	prototypeRefNode: function(_, simpleNode) {
		var self = this;
		var factoryFacet = this.resourceFactory.facet;
		var isFactoryEditFacet = (factoryFacet === '$edit');

		var node = ["$title", "$shortTitle", "$capabilities", "$isReadOnly", "$isHidden", "$isMandatory", "$isExcluded"]
			.reduce(function(r, a) {
				// Transfert attribute from the simpleNode to the new refNode
				r[a] = simpleNode[a];
				simpleNode[a] = (a == "$isExcluded") ? true : undefined;
				return r;
			}, {
				$type: "application/x-reference",
				$item: {}
			});

		if (isFactoryEditFacet) node.$maxLength = simpleNode.$maxLength;

		var item = node.$item;
		var link;
		var facet = '$lookup';
		if (this.links) {
			if (this.links.$lookup) {
				link = this.links.$lookup;
			} else if (this.links.$details) {
				link = this.links.$details;
				facet = '$details';
			}
		}

		if (link === undefined) {
			//We should not go there but still leaves the code
			// is it possible to have a reference with out lookup or details ??
			this.calculateRef(_, item);
		} else {
			item.$url = "{$baseUrl}/" + link.data.CLALNK + "('{$key}" + "')?representation=" + link.data.REPLNK + "." + '$lookup';
			var repr = this.resourceFactory.representation;

			if (link.data.REPLNK !== repr.name) {
				repr = this.supervisor.load(_, 'Representation', link.data.REPLNK);
				if (!repr) throw new util.HttpError(404, "representation not found: " + link.data.REPLNK);
			}
			var f = repr.resourceFactory(_, facet);

			item.$properties = {};

			if (f.keyItems)
				item.$key = [];
			item.$value = [];
			f.keyItems.forEach_(_, function(_, keyitem) {
				item.$properties[keyitem.alias] = {};
				link.keys.forEach_(_, function(_, paramData) {
					if (keyitem.prop === paramData.CODPAR) {
						if (paramData.alias === self.tag) {
							item.$value.push(alias(keyitem.alias));
						}

						var targetProp = f.class.property(paramData.CODPAR);
						this.supervisor.fillTypeNode(_, targetProp.data, item.$properties[keyitem.alias]);
						item.$properties[keyitem.alias].$maxLength = undefined;
						if (item.$properties[keyitem.alias].$value && item.$properties[keyitem.alias].$value.$type) {
							item.$properties[keyitem.alias].$type = item.$properties[keyitem.alias].$value.$type;
							item.$properties[keyitem.alias].$value = undefined;
						}
						if (paramData.ADRVAL > 1 && link.keys.length !== 1) item.$properties[keyitem.alias].$isReadOnly = true;

						if (paramData.alias) {
							item[keyitem.alias] = alias(paramData.alias);
							item.$key.push(alias(keyitem.alias));
						} else {
							item[keyitem.alias] = (paramData.TYPINT === 1 ? paramData.VALEUR : paramData.value); //pb sur SAT_REF/TYP="2" et non TYP=2
							item.$key.push(paramData.value);
						}
					}
				}, this, keyitem);
			}, this);
			item.$key = item.$key.join('~');
			item.$value = item.$value.join('~');

		}
		node.$item.$links = simpleNode.$links;
		simpleNode.$links = undefined;
		return node;
	},
	makeGetReferenceKey: function(_) {
		var name = this.name;
		var self = this;
		var refKeys = self.keyParams.reduce_(_, function(_, r, paramData) {
			r[paramData.CODPAR] = self.addFieldTransform(_, paramData.VALEUR);
			return r;
		}, {});
		return function(_, record) {
			return Object.keys(refKeys).reduce_(_, function(_, r, k) {
				var val = refKeys[k](_, record) || "";
				r.push(val);
				return r;
			}, []).join('~');

		};
	},
	getAtextraKey: function(_, instance) {
		var keyMaps = this.keyMaps(_);
		return [keyMaps.IDENT1(_, instance), keyMaps.IDENT2(_, instance)].join('~');
	},
	getSql: function(_, colNames, tableNames, wheres, params, descs, cache, raw, sqlOpts) {
		tracerJs.debug && tracerJs.debug("property.getSql:" + this.name);
		if (!this.name) return null;
		var column = this.column;
		if (this.isAtextra) {
			cache.addProperty(_, this);
		} else if (!this.collection) {
			if (column) column.getSql(_, colNames, tableNames, wheres, params, descs, raw, sqlOpts);

			if (this.isReference(_)) {
				cache.addReference(_, this);
			}
		} else if (this.collection && this.collection.ofIndexedProperties) {
			tracerJs.debug && tracerJs.debug("property.getSql " + this.name + " =>collection");
			// it's a denormalized collection :
			this.collection.getSql(_, colNames, tableNames, wheres, params, descs, cache, raw, sqlOpts);
		}

	},
	isReference: function(_, value) {
		if (value === undefined) {
			if (this.type === undefined) return false; // type isn't defined for classes and representations :

			//var reference = (this.type.data.CODCLA && this.type.data.DEFREPDES); //this.type.data.CODCLA.length);
			var reference = (this.type.data.TYPSELSYR === 2);

			if (reference && this.class.table) {
				// A instance cannot be a reference of itself:
				//reference = !((this.class.table.indexes[0].sqlNames().length === 1) && (this.class.name === this.type.data.CODCLA));
				//18/09/15
				//can't be a reference if class=current main class and property in indexkeys
				if (this.class.parent && this.class.parent.curpath === "") {
					reference = !((this.class.name === this.type.data.CODCLA) && (this.class.keyItems.indexOf(this.name) >= 0));
				}
			}
			reference = !! reference;
			return reference;
		} else if (value = true) this.getSql = undefined; // Deactivate getSql in this case
		this.reference = value;
		return;
	},
	addFieldTransform: function(_, value, index, refReader) {
		var regNum$ = /=num\$\(([\w\.]*)\)/;
		var regVal$ = /=val\(([\w\.]*)\)/;

		if (value === '""') {
			return function() {
				return function(_) {
					return " ";
				};
			}();
		} else if (value.charAt(0) === '"') {
			return function(constant) {
				return function(_, instance) {
					return constant;
				};
			}(value.substring(1, value.length - 1));
		} else if (typeof value === 'number' || (/^\d+$/.test(value))) {
			return function(constant) {
				return function(_, instance) {
					return constant;
				};
			}(value);
		} else if (value.substring(0, 5) === 'ACTX.') {
			return function(property) {
				return function(_, instance) {
					return glob.context.x3session.actx.get(_, property);
				};
			}(value.substring(5));
		} else if (regNum$.test(value) || regVal$.test(value)) {
			var match = regNum$.exec(value);
			return function(fct) {
				return function(_, instance) {
					var value = fct(_, instance);
					return value ? value.toString() : "";
				};
			}(this.addFieldTransform(_, match[1], index, refReader));
		} else {
			if (index && refReader && index.indexOf(value) < 0) {
				refReader.columns = refReader.columns || [];
				refReader.columns.push(value);
			}
			return function(_, property) {
				return function(_, instance) {
					var value;
					if (instance.properties && instance.properties[property]) {
						value = instance.get(_, property, true);
					} else if (instance.class && instance.class.codclaPath.indexOf('.') > 0) {
						// Class associated to a collection
						var path = property.split('.');
						if (path.length > 1) {
							property = path[path.length - 1];
							if (instance.class.properties[property]) {
								value = instance.get(_, property, true);
							}
						} else if (instance.$parent && instance.$parent.$parent) {
							var instance = instance.$parent.$parent;
							var slot = instance.slot(_, property);
							if (slot) value = slot._get(_);
						}
					} else {
						// HACK
						value = instance[property];
					}
					//dbg:console.error("field "+property+"="+ value);
					return value;
				};
			}(_, value);
		}
	},
	loadAtextra: function(_, instance) {
		var textId = this.getAtextraKey(_, instance);
		var zone = this.name;
		//dbg:console.log("loadAtextra "+zone+":'"+textId+"'");


		//dbg:console.log("loadAtextra ("+zone+"):"+textId);
		var ids = [textId];
		var cache = instance.cache;
		if (cache && cache.texts && cache.texts[zone]) {
			if (cache.texts[zone].texts) {
				//dbg:console.log("loadAtextra (cache) "+textId+"="+cache.texts[zone].texts[textId]);
				return cache.texts[zone].texts[textId];
			}
			ids = ids.concat(cache.texts[zone].ids);
		}
		//dbg:console.log("loadAtextra ids:"+ids);

		var param = this.supervisor.sqlDriver.param;
		var params = [];
		var wheres = [];

		var atextra = this.keyMaps(_);

		params.push(atextra.CODFIC(_, instance));
		wheres.push("CODFIC_0=" + param(params.length - 1));
		params.push(atextra.ZONE(_, instance));
		wheres.push("ZONE_0=" + param(params.length - 1));
		params.push(atextra.LANGUE(_, instance));
		wheres.push("LANGUE_0=" + param(params.length - 1));

		var gIds = ids.reduce(function(r, id) {
			var parts = id.split('~');
			r[parts[0]] = r[parts[0]] || [];
			r[parts[0]].push(parts[1]);
			return r;
		}, {});
		wheres.push("((" +
			Object.keys(gIds).reduce(function(r, ident1) {
				params.push(ident1);
				var select = "IDENT1_0=" + param(params.length - 1) + " and ";

				if (gIds[ident1].length === 1) {
					params.push(gIds[ident1][0]);
					select += "IDENT2_0=" + param(params.length - 1);
				} else {
					select += "IDENT2_0 in (" + gIds[ident1].reduce(function(r, ident2) {
						params.push(ident2);
						r.push(param(params.length - 1));
						return r;
					}, []).join(',') + ")";
				}
				r.push(select);
				return r;
			}, []).join(") or (") + "))");


		//dbg:console.error("sql:" + sql);
		//dbg:console.error("params:" + params.map(function(p){return "'"+p+"'";}));

		var getTextId = function(record) {
			return record.IDENT1 + '~' + (record.IDENT2 || " ");
		};

		var self = this;
		var sql = "select IDENT1_0, IDENT2_0, ZONE_0, TEXTE_0 from ATEXTRA  where (" + wheres.join(" and ") + ")";
		var texts = this.supervisor.sqlReader(_, sql, params)
			.toArray(_).reduce(function(r, record) {
				//tracerJs.debug && tracerJs.debug("record	:" + JSON.stringify(record));
				r[getTextId(record)] = record.TEXTE || "";
				return r;
			}, {});

		//dbg:console.log("loadAtextra texts=",texts);	

		if (cache && cache.texts && cache.texts[zone]) {
			// clear the list of text ids
			cache.texts[zone].ids = [];
			// Keep texts for next call
			cache.texts[zone].texts = texts;
		}
		return texts[textId] || "";
	},
	loadReference: function(_, instance) {
		this.loadReferenceData = this.loadReferenceData || function(_, id, instance) {
			tracerJs.debug && tracerJs.debug("loadReferenceData(" + this.name + "):" + id);

			//dbg:console.error("loadReferenceData(" + this.name + "):" + id);

			function addTextTransform(_, self, superv, attribute, reference, column, refReader) {

				if (!column) return;

				if (reference.properties[column].isAtextra) {
					var index = reference.table.indexes[0].sqlNames().map(function(key) {
						return key.substring(0, key.length - 2);
					});
					var self = self;
					var atextra = reference.data.PARAM_FLDS.filter(function(paramData) {
						return paramData.TYPPAR === 1 && paramData.FLDCLA === column && paramData.TYPKEY === 2;
					}, self).reduce_(_, function(_, r, paramData) {
						r[paramData.CODPAR] = self.addFieldTransform(_, paramData.VALEUR, index, refReader);
						return r;
					}, {});

					return function(superv, atextra, attribute) {
						return function(_, reader, writer) {
							var param = superv.sqlDriver.param;
							var params = [];
							var wheres = [];

							var rs = reader.readAll(_);
							if (rs && rs.length) {
								params.push(atextra.CODFIC(_, rs[0]));
								wheres.push("CODFIC_0=" + param(params.length - 1));
								params.push(atextra.ZONE(_, rs[0]));
								wheres.push("ZONE_0=" + param(params.length - 1));
								params.push(atextra.LANGUE(_, rs[0]));
								wheres.push("LANGUE_0=" + param(params.length - 1));

								var getTextId = function(record) {
									return record.IDENT1 + '~' + (record.IDENT2 || " ");
								};
								wheres.push("((" +
									rs.reduce_(_, function(_, r, record) {
										var id1 = atextra.IDENT1(_, record.record);
										var id2 = atextra.IDENT2(_, record.record);
										params.push(id1);
										params.push(id2);
										record.reference[attribute] = id1 + '~' + id2;
										r.push("IDENT1_0=" + param(params.length - 2) + " and " + "IDENT2_0=" + param(params.length - 1));
										return r;
									}, []).join(") or (") + "))");



								var sql = "select IDENT1_0, IDENT2_0, ZONE_0, TEXTE_0 from ATEXTRA  where (" + wheres.join(" and ") + ")";

								var texts = superv.sqlReader(_, sql, params).toArray(_).reduce(function(r, text) {
									r[getTextId(text)] = text.TEXTE;
									return r;
								}, {});

								rs.forEach_(_, function(_, record) {
									// update the reference:
									record.reference[attribute] = texts[record.reference[attribute]];
									//pipe the record
									writer.write(_, record);
								});
							}

						};
					}(superv, atextra, attribute);
				} else {
					refReader.columns = refReader.columns || [];
					refReader.columns.push(column);

					return function(_, reader, writer) {
						var record;
						while (record = reader.read(_)) {
							record.reference[attribute] = record.record[column];
							writer.write(_, record);
						}
					};
				}
				return;
			}

			try {
				var self = this;
				var ids = {};
				ids[id] = null;
				if (instance.cache && instance.cache.references) {
					ids = Object.keys(instance.cache.references[this.name].$ids).reduce(function(r, id) {
						r[id] = instance.cache.references[self.name].$ids[id];
						return r;
					}, ids);
				}
				var reference = this.supervisor.load(_, 'Class', this.type.data.CODCLA);
				if (!reference) return;

				//TODO : "COLDEC", "COLLNG"
				var refMaps = {
					SYMBOL: function(column) {
						return function(item) {
							item.reference.$symbol = item.record[column] || "";
						};
					},
					COLFMT: function(column) {
						return function(item) {
							var colfmt = item.record[column];
							if (colfmt) {
								colfmt = colfmt.split('.');
								item.reference.$precision = parseInt(colfmt[0], 10);
								item.reference.$scale = (colfmt.length > 1) ? parseInt(colfmt[1], 10) : 0;
							}
						};
					}
				};
				var refReader = Object.keys(refMaps).reduce(function(r, field) {
					if (reference.table.data[field]) {
						r.columns = r.columns || [];
						var column = reference.table.data[field];
						r.columns.push(column);
						r.maps = r.maps || [];
						if (refMaps[field]) {
							r.maps.push(refMaps[field](column));
						}
					}
					return r;
				}, {});

				var titleTransform = addTextTransform(_, this, this.supervisor, "$title", reference, reference.table.data.INTITC, refReader);
				var descTransform = addTextTransform(_, this, this.supervisor, "$description", reference, reference.table.data.INTIT, refReader);

				var reader;
				if (refReader.columns) {
					// The reference table has to be read first :
					var param = this.supervisor.sqlDriver.param;
					var params = [];
					var wheres = [];

					var names = reference.table.indexes[0].sqlNames();

					var getRecordId = function(names) {
						var fields = names.map(function(name) {
							return name.substring(0, name.length - 2);
						});
						return function(record) {
							return fields.reduce(function(r, field) {
								r.push(record[field]);
								return r;
							}, []).join('~');
						};
					}(names);

					var idsKeys = Object.keys(ids);
					if (names.length === 1) {
						wheres.push(names[0] + " in (" + idsKeys.map(function(id) {
							params.push(id);
							return param(params.length - 1);
						}) + ")");
					} else {
						wheres.push("(" +
							idsKeys.map(function(id) {
								var n = 0;
								return id.split('~').reduce(function(r, part) {
									params.push(part);
									r.push(names[n++] + "=" + param(params.length - 1));
									return r;
								}, []).join(" and ");
							}).join(") or (") + ")");
					}
					// add other colums :
					names = names.concat(refReader.columns.map(function(column) {
						return column + '_0';
					}));
					var sql = "select " + names.join(',') + " from " + reference.table.name + " where (" + wheres.join(" and ") + ")";

					//dbg:console.error("ref sql:" + sql);
					//dbg:console.error("ref params:" + params);

					// create the reader :
					var self = this;
					reader = self.supervisor.sqlReader(_, sql, params) //
					.map(function(_, record) {
						var item = {
							id: getRecordId(record),
							record: record,
							reference: {}
						};
						//apply reference maps:
						refReader.maps && refReader.maps.forEach(function(map) {
							map(item);
						});
						return item;
					});
				}
				if (titleTransform || descTransform) {
					if (!reader) {
						//We need reader
						//dbg:console.log("932 ids:"+Object.keys(ids));
						reader = function(_, reference, ids) {
							var index = reference.table.indexes[0].sqlNames().map(function(key) {
								return key.substring(0, key.length - 2);
							});

							return ez.devices.generic.empty.reader.transform(function(_, reader, writer) {
								ids.forEach_(_, function(_, id) {
									var keys = id.split('~');
									var record = {
										id: id,
										record: {},
										reference: {}
									};
									for (var i = 0; i < index.length; i++) {
										record.record[index[i]] = keys[i];
									}
									writer.write(_, record);
								});
							});
						}(_, reference, Object.keys(ids));
					}

					if (titleTransform) reader = reader.transform(titleTransform);
					if (descTransform) reader = reader.transform(descTransform);
				}
				if (!reader) return;

				// Pipe elements in the table of references :
				var references = instance.cache && instance.cache.references ? instance.cache.references[this.name] : {};
				reader.pipe(_, ez.devices.generic.writer(function(_, record) {
					if (record) references[record.id] = record.reference;
				}));

				// clear the list of $ids:
				references.$ids = {};

			} catch (e) {
				tracerJs.error && tracerJs.error(e.message);
				tracerJs.error && tracerJs.error(e.stack);
			} finally {
				tracerJs.debug && tracerJs.debug("loadReferenceData:" + JSON.stringify(references[id]));
				return references[id];
			}
		};

		var getReferenceKey = this.makeGetReferenceKey(_);

		var refId = typeof getReferenceKey === "function" && getReferenceKey(_, instance) || "";
		tracerJs.debug && tracerJs.debug("loadReference " + this.name + " id:" + refId);

		//dbg:console.error("loadReference " + this.name + " id:" + refId);
		if (!refId.length) return {};

		var reference = (instance.cache && instance.cache.references) ? instance.cache.references[this.name][refId] : undefined;
		reference = reference || this.loadReferenceData(_, refId, instance);
		if (instance.cache && instance.cache.references) instance.cache.references[this.name][refId] = reference;
		return reference;
	},
	readBDOC: function(_, ident1, ident2, ident3) {
		var sqlDriver = this.supervisor.sqlDriver;
		var param = sqlDriver.param;
		var params = [ident1, ident2, ' ', ' '];

		var field = this.data.LOBFLD || "BLOB";
		var table = this.data.LOBTAB || "ABLOB";

		var self = this;
		try {
			var i = 0;
			var rs = self.supervisor.sqlReader(_, "select C." + field + "_0 From " + table + " C Where" +
				" C.CODBLB_0=" + param(i++) + " and C.IDENT1_0=" + param(i++) + " and C.IDENT2_0=" + param(i++) + " and C.IDENT3_0=" + param(i++), params).toArray(_);
			return rs.length ? rs[0].BLOB : undefined;
		} catch (e) {
			tracerJs.error && tracerJs.error("exception in readBDOC:" + JSON.stringify(e));
		}
		return;

	}
});