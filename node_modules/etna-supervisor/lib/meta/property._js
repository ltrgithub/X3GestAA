"use strict";

var util = require("etna-supervisor/lib/util");
var variables = require('etna-engine/lib/runtime/variables');
var InstanceProperty = require("etna-supervisor/lib/instanceProperty").InstanceProperty;
var InstanceReference = require("etna-supervisor/lib/InstanceReference").InstanceReference;
var InstanceCollection = require("etna-supervisor/lib/instanceCollection").InstanceCollection;

var tracerJs = require("syracuse-trace/lib/helper").getTracer("etna.supervisor");

var Property = exports.constructor = util.defineClass(function(superv, clas, data, repr) {
	this.supervisor = superv;
	this.data = data;
	this.class = clas;
	this.representation = repr;
}, null, {
	init: function(_) {
		if (this.type) return this;
		if (this.data.CODTYP) {
			this.type = this.supervisor.load(_, 'Type', this.data.CODTYP);
			if (!this.type) throw new Error('type not found: ' + this.data.CODTYP);
			if (this.type.data.NOLIB >= 0) {
				this.data.NOLIB = this.type.data.NOLIB;
			}
		}
		return this;
	},
	name: {
		get: function() {
			return this.data.FLDCLA;
		}
	},
	etnaType: {
		get: function() {
			return this.type.etnaType;
		}
	},
	set: function(value) {
		this.set.key = this.set.key || "L" + this.etnaType + ((this.etnaType === 'S') ? (this.data.LONG || this.type.data.LNGTYP || 250) : '');
		return variables.types[this.etnaType].set(this.name, this.set.key, value);
	},
	createInstance: function(parent) {
		if (this.collection) return new InstanceCollection(parent, this.collection);
		if (this.reference) return new InstanceReference(parent, this);
		return new InstanceProperty(parent, this);
	},
	clone: function(repr) {
		var p = new Property(this.supervisor, this.class, this.data, repr);
		p.type = this.type;
		p.collection = this.collection;
		return p;
	},
	targetClass: function(_) {
		if (!this.data.LNKCLA) return null;
		return this.supervisor.load(_, 'Class', this.data.LNKCLA);
	},
	prototypeNode: function(_) {
		var self = this;
		var node = {
			$title: this.supervisor.loadText(_, this.data.INTFLD),
			$shortTitle: this.supervisor.loadText(_, this.data.INTSHTFLD),
		};
		if (this.class.data.PARAM_FLDS) {
			var keyParams = this.class.data.PARAM_FLDS.filter(function(paramData) {
				return paramData.FLDCLA === this.name && paramData.TYPKEY === 2;
			}, this);
		}
		if (this.exportedProperty && this.exportedProperty.data.TYPAFFPRO !== 2) node.$isReadOnly = true;
		/* && keyParams.some(function(param) {
			return param.MODPAR !== 1;
		})*/
		if (this.data.OBLIG === 2) node.$isMandatory = true;
		if (this.targetResourceFactory) {
			this.targetResourceFactory.fillTypeNode(_, node);
			node.$maxItems = this.collection.data.MAXCOL;
		} else if (this.data.CODTYP != null) {
			if (this.type.data.TYPTYP === 7 || this.data.CODTYP === "ATX") {
				node.$capabilities = "sort,filter,filter_upper";
			} else if (this.type.data.TYPTYP !== 9 && this.type.data.TYPTYP !== 10) {
				node.$capabilities = "sort,filter";
			}
			//if (this.type && (this.type.data.TYPPROSYR === 'ATYPE3' || this.type.data.CODCLA === 'ATEXTRA') //
			if (this.type && (this.type.data.CODCLA === 'ATEXTRA') //
				&& this.resourceFactory.facet === '$edit') {
				node.$capabilities += ",localize";
			}
			this.supervisor.fillTypeNode(_, this.data, node);
			if (this.type.data.TYPTYP === 10 && this.links["ALOB"]) {
				node.$url = "{$baseUrl}/CDOC('R_" + this.resourceFactory.representation.data.CODREP + "~" + //
				this.exportedProperty.data.ALIAS + "~" + "keys...." + "')";
			} else if (this.type.data.TYPTYP === 10) {

			}
		} else {
			return console.error("ignoring prototype property " + this.name), undefined;
		}
		if (this.resourceFactory.facet !== '$bulk' && this.links) {
			Object.keys(this.links).forEach_(_, function(_, name) {
				if (self.links[name].data.CMPLNK !== 19) {
					if (node.$links === undefined) {
						node.$links = {};
					}
					node.$links[name] = self.links[name].prototypeNode(_);
				}
			});
		}
		//if (this.type && (this.type.data.TYPPROSYR === 'ATYPE3' || this.type.data.CODCLA === 'ATEXTRA') //
		if (this.type && (this.type.data.CODCLA === 'ATEXTRA') //
			&& this.resourceFactory.facet === '$edit') {
			if (node.$links === undefined) {
				node.$links = {};
			}
			node.$links["$localize"] = {
				$type: 'application/json;vnd.sage=syracuse',
				$title: this.supervisor.loadMess(_, 124, 232),
				$url: ''
			};
			if (this.exportedProperty.data.CODPRO.indexOf('.') >= 0) {
				node.$links["$localize"].$url = '{$instanceUrl}/' + this.exportedProperty.data.ALIAS + '/$localize';
			} else {
				node.$links["$localize"].$url = '{$repUrl}/' + this.exportedProperty.data.ALIAS + '/$localize';
			}
		}
		return node;
	},
	prototypeRefNode: function(_, simpleNode) {
		var node = {
			$title: simpleNode.$title,
			$shortTitle: simpleNode.$shortTitle,
			$type: "application/x-reference",
			$capabilities: simpleNode.$capabilities,
			$isMandatory: simpleNode.$isMandatory,
			$maxLength: simpleNode.$maxLength,
			$isReadOnly: simpleNode.$isReadOnly,
			//$links: simpleNode.$links,
			$item: {
				$properties: {},
				$links: {}
			},
		};
		delete simpleNode.$title;
		delete simpleNode.$shortTitle;
		delete simpleNode.$capabilities;
		delete simpleNode.$links;
		delete simpleNode.$isReadOnly;
		delete simpleNode.$isMandatory;
		simpleNode.$isExcluded = true;

		//console.error("CREATING REF FOR: " + this.class.name + "." + this.name);
		var item = node.$item;
		//Get target Class
		var targetClass = this.type.targetClass(_);
		if (targetClass == null) throw new Error("target class missing for reference: " + this.name);
		if (this.class.data.PARAM_FLDS) {
			var keyParams = this.class.data.PARAM_FLDS.filter(function(paramData) {
				return paramData.FLDCLA === this.name && paramData.TYPKEY === 2;
			}, this);
		} else {
			var keyParams = [];
		}
		//Get target representation
		switch (this.representation.data.TYPMSKREP) {
			case 2:
				var codrep = this.type.data.DEFREPMOB;
				break;
			case 3:
				var codrep = this.type.data.DEFREPTAB;
				break;
			default:
				var codrep = this.type.data.DEFREPDES;
				break;
		}
		var repr = this.supervisor.load(_, 'Representation', codrep);
		if (!repr) throw new HttpError(404, "representation not found: " + codrep);
		var facet = '$lookup';
		if (!repr.isFacetEnabled('$lookup')) {
			facet = '$query';
			if (!repr.isFacetEnabled('$query')) {
				facet = '$lookup';
				throw new HttpError(406, "facet not enabled: " + '$lookup');
			}
		}
		var reprResFact = repr.resourceFactory(_, facet);

		var linkUrlBase = "{$baseUrl}/" + targetClass.name + "('{$key}" + "')?representation=" + codrep;
		var linkUrlBaseMultiple = "{$baseUrl}/" + targetClass.name + "?representation=" + codrep;

		item.$url = linkUrlBase + "." + facet;
		//item.$key = targetClass.keyExpression(_);
		//item.$key = reprResFact.keyItems.map(function(keyitem) {
		//	return '{' + keyitem.alias + '}';
		//}, this).join('~');
		item.$value = reprResFact.keyItems.map(function(keyitem) {
			return '{' + keyitem.alias + '}';
		}, this).join('~');
		var self = this;
		reprResFact.keyItems.forEach_(_, function(_, keyitem) {
			item.$properties[keyitem.alias] = {};
			keyParams.forEach_(_, function(_, paramData) {
				if (keyitem.prop === paramData.CODPAR) {
					if (item.$key === undefined) item.$key = "";
					else item.$key = item.$key + '~';

					var targetProp = targetClass.property(paramData.CODPAR);
					// TODO: next line could cause infinite recursion??
					this.supervisor.fillTypeNode(_, targetProp.data, item.$properties[keyitem.alias]);
					var propData = util.find(self.representation.data.EXPORTED_PROPERTIES, 'ALIAS', paramData.VALEUR);
					if (propData) paramData.isexportedproperty = true;
					else paramData.isexportedproperty = false;

					if (paramData.isexportedproperty === true) {
						item[keyitem.alias] = '{' + paramData.VALEUR + '}';
						item.$key = item.$key + '{' + keyitem.alias + '}';
					} else {
						item[keyitem.alias] = paramData.VALEUR;
						item.$key = item.$key + paramData.VALEUR;
					}
				}
			}, this, keyitem);
		}, this);

		var linkUrlBaseSingle = "{$baseUrl}/" + targetClass.name + "('" + keyParams.map(function(paramData) {
			var val = paramData.VALEUR; // strange: would be more logical to have CODPAR instead of VALEUR here
			if (paramData.isexportedproperty === true) {
				val = val.substring(val.indexOf('.') + 1); // hack to keep unit tests happy (strip COL. prefix)
				return '{' + val + '}';
			}
			return val;
		}, this).join('~') + "')?representation=" + codrep;

		if (repr.isFacetEnabled('$details')) {
			item.$links.$details = {
				$title: "details",
				// TODO 
				$target: "",
				$type: "application/json;vnd.sage=syracuse",
				$url: linkUrlBaseSingle + ".$details",
			};
		}
		if (repr.isFacetEnabled('$lookup')) {
			item.$links.$lookup = {
				$title: "select",
				// TODO 
				$type: "application/json;vnd.sage=syracuse",
				$url: linkUrlBaseMultiple + ".$lookup",
			};
		}
		if (repr.isFacetEnabled('$summary')) {
			item.$links.$summary = {
				$title: "summary",
				// TODO 
				$target: "",
				$type: "application/json;vnd.sage=syracuse",
				$url: linkUrlBaseSingle + ".$summary",
			};
		}
		if (repr.isFacetEnabled('$query')) {
			item.$links.$query = {
				$title: "select",
				// TODO 
				$type: "application/json;vnd.sage=syracuse",
				$url: linkUrlBaseMultiple + ".$query",
			};
		}

		return node;
		/* for info, typical result
		"C06P02_REF": {
			"$title": "{@28440}",
			"$shortTitle": "{@28440}",
			"$type": "application/x-reference",
			"$capabilities": "sort,filter",
			"$item": {
				"$url": "{$baseUrl}/AQCPROR02('{$key}')?representation=AQCPROR02.$lookup",
				"$value": "{R02P01}",
				"$key": "{R02P01}~{R02P02}",
				"$properties": {
					"R02P01": {
						"$type": "application/x-string"
					},
					"R02P02": {
						"$type": "application/x-integer"
					}
				},
				"R02P01": "{C06P02}",
				"R02P02": "{C06P03}",
				"$links": {
					"$details": {
						"$title": "{@28123}",
						"$target": "",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/AQCPROR02('{C06P02}~{C06P03}')?representation=AQCPROR02.$details"
					},
					"$lookup": {
						"$title": "{@6109}",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/AQCPROR02?representation=AQCPROR02.$lookup"
					},
					"$summary": {
						"$title": "{@25036}",
						"$target": "",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/AQCPROR02('{C06P02}~{C06P03}')?representation=AQCPROR02.$summary"
					},
					"$query": {
						"$title": "{@27982}",
						"$target": "",
						"$type": "application/json;vnd.sage=syracuse",
						"$url": "{$baseUrl}/AQCPROR02?representation=AQCPROR02.$query"
					}
				}
			}
		},*/
	},
	column: {
		get: function() {
			//dbg:tracerJs.debug && tracerJs.debug("column ? "+(!!this.class.table));
			return (this.class.table && this.class.table.column(this.data.FLDCLA)) || undefined;
		}
	},

	getSql: function(_, colNames, tableNames, wheres, params, descs, cache, raw) {
		//dbg:tracerJs.debug && tracerJs.debug("property.getSql "+this.name);
		var column = this.column;
		if (/^AX[123X]/.test(this.data.CODTYP)) {
			//dbg:tracerJs.debug && tracerJs.debug("property.getSql AXX:"+this.name+" cache.texts:"+JSON.stringify(cache.texts));

			cache.texts = cache.texts || {
				properties: {}
			};

			var keyNames = this.class.table.indexes[0].sqlNames(_).slice(0, 2).map(function(key) {
				return key.substring(0, key.length - 2);
			});
			if (keyNames.length == 1) {
				cache.texts.getKeyText = cache.texts.getKeyText || function(record) {
					return record.IDENT1;
				};

			} else {
				cache.texts.getKeyText = cache.texts.getKeyText || function(record) {
					return record.IDENT1 + '~' + record.IDENT2;
				};
			}

			cache.texts.properties[this.name] = {
				ids: [],
				texts: null,
				cacheTextKey: function(property, keys) {
					if (keys.length == 1) return function(cache, record) {
						record.$id = record[keys[0]];
						cache.texts.properties[property].ids.push(record.$id);
						return record;
					};
					return function(cache, record) {
						record.$id = record[keys[0]] + '~' + record[keys[1]];
						cache.texts.properties[property].ids.push(record.$id);
						return record;
					};
				}(this.name, keyNames),
				loadText: function(_this, codfic, zone, lan) {
					//dbg:tracerJs.debug && tracerJs.debug("create loadText codfic:"+codfic+' zone:'+zone+' lan:'+lan);
					return function(_, textId) {
						//dbg:tracerJs.debug && tracerJs.debug("loadText codfic:"+codfic+' zone:'+zone+' lan:'+lan);

						if (!_this.class.cache.texts) return "";

						if (_this.class.cache.texts.properties[zone].texts === null) {
							var param = _this.supervisor.sqlDriver.param;
							var params = [];
							var wheres = [];

							params.push(codfic);
							wheres.push("CODFIC_0=" + param(params.length - 1));
							params.push(zone);
							wheres.push("ZONE_0=" + param(params.length - 1));
							params.push(lan);
							wheres.push("LANGUE_0=" + param(params.length - 1));

							wheres.push("IDENT1_0 in (" + _this.class.cache.texts.properties[zone].ids.map(function(id) {
								params.push(id);
								return param(params.length - 1);
							}) + ")");


							var sql = "select IDENT1_0, IDENT2_0, TEXTE_0 from ATEXTRA  where (" + wheres.join(" and ") + ")";
							tracerJs.debug && tracerJs.debug("sql:" + sql);
							tracerJs.debug && tracerJs.debug("params:" + params);
							var self = _this;
							var recordset = _this.supervisor.sqlDriver.withConnection(_, function(_, cnx) {
								return self.supervisor.sqlReader(_, cnx, sql, params).toArray(_);
							});
							if (recordset) {
								var self = _this;
								_this.class.cache.texts.properties[zone].texts = recordset.reduce(function(r, record) {
									var id = self.class.cache.texts.getKeyText(record);
									r[id] = record.TEXTE;
									return r;
								}, {});
							}
							// clear the list of text ids
							_this.class.cache.texts.properties[zone].ids = [];
						}
						return _this.class.cache.texts.properties[zone].texts[textId] || "";
					};
				}(this, this.class.table.name, this.name, this.supervisor.LAN(_))
			};

		} else if (column) {
			//dbg:tracerJs.debug && tracerJs.debug("property.getSql "+this.name+" =>column");
			column.getSql(_, colNames, tableNames, wheres, params, descs, cache, raw);

			if (this.isReference(_)) {
				var paramRefKeys = this.class.data.PARAM_FLDS.filter(function(paramData) {
					return paramData.FLDCLA === this.name && paramData.TYPKEY === 2;
				}, this);

				cache.references = cache.references || {};
				cache.references[this.name] = {
					$name: this.name,
					$ids: {},
					cacheReference: function(_, name, refKeys) {
						return function(cache, record) {
							var id = refKeys.reduce(function(r, refKey) {
								r.push(record[refKey.VALEUR]);
								return r;
							}, []).join('~');

							if (id !== undefined) {
								cache.references[name].$ids[id] = null;
							}
							return record;
						};
					}(_, this.name, paramRefKeys)
				};
			}
		} else if (this.collection && this.collection.mappingData === undefined) {
			//dbg:tracerJs.debug && tracerJs.debug("property.getSql "+this.name+" =>collection");
			// it's a denormalized collection :
			this.collection.getSql(_, colNames, tableNames, wheres, params, descs, cache, raw);
		}

	},
	isReference: function(_, value) {
		if (value === undefined) {
			var self = this;
			return self.class.data.PARAM_FLDS.some(function(paramData) {
				return paramData.FLDCLA === self.name && paramData.TYPKEY === 2;
			}, this);

		}
		this.reference = value;
		return;
	},
	loadReference: function(_, instance) {
		var getReferenceId = function(id) {
			return id.join('~');
		};

		this.loadReferenceData = this.loadReferenceData || function(_, id) {
			var reference = this.supervisor.load(_, 'Class', this.type.data.CODCLA);
			var table = this.supervisor.load(_, 'Table', reference.table.name);

			var param = this.supervisor.sqlDriver.param;
			var params = [];
			var wheres = [];

			var fTitle = table.data.INTITC;
			var fDescription = table.data.INTIT;

			// tracerJs.debug && tracerJs.debug("loadReferenceData fTitle:"+fTitle);
			// tracerJs.debug && tracerJs.debug("loadReferenceData fDescription:"+fDescription);
			var countRefFields = 0;
			var refFields = ["SYMBOL", "COLFMT", "COLDEC", "COLLNG"].reduce(function(r, field) {
				if (table.data[field]) {
					r[field] = table.data[field];
					countRefFields++;
				}
				return r;
			}, {});

			params.push(reference.table.name);
			wheres.push("CODFIC_0=" + param(params.length - 1));

			var getRecordId;
			var ids = this.class.cache.references[this.name].$ids;
			if (id.length === 1) {
				ids[id[0]] = null;
				wheres.push("IDENT1_0 in (" + Object.keys(ids).map(function(id) {
					params.push(id);
					return param(params.length - 1);
				}) + ")");
				getRecordId = function(record) {
					return record.IDENT1;
				};
				// clear the list of $ids:
				if (this.class.cache.references[this.name].$ids) this.class.cache.references[this.name].$ids = {};

			} else {

				wheres.push(Object.keys(ids).reduce(function(r, id) {
					var keys = id.split('~');
					params.push(keys[0]);
					params.push(keys[1]);

					r.push("(IDENT1_0 =" + param(params.length - 2) + " and IDENT2_0 =" + param(params.length - 1) + ")");
					return r;
				}, []).join(" or "));

				getRecordId = function(record) {
					return record.IDENT1 + '~' + record.IDENT2;
				};

			}
			params.push(this.supervisor.LAN(_));
			wheres.push("LANGUE_0=" + param(params.length - 1));

			params.push(fTitle);
			params.push(fDescription);
			wheres.push("ZONE_0 in (" + param(params.length - 2) + "," + param(params.length - 1) + ")");

			var sql = "select IDENT1_0, IDENT2_0, ZONE_0, TEXTE_0 from ATEXTRA  where (" + wheres.join(" and ") + ")";
			tracerJs.debug && tracerJs.debug("sql:" + sql);
			tracerJs.debug && tracerJs.debug("params:" + params);
			var self = this;

			this.class.cache.references[this.name] = this.supervisor.sqlDriver.withConnection(_, function(_, cnx) {
				return self.supervisor.sqlReader(_, cnx, sql, params).toArray(_);
			}).reduce(function(r, record) {
				var id = getRecordId(record);
				r[id] = r[id] || {
					$description: '',
					$title: ''
				};
				if (record.ZONE === fDescription) r[id].$description = record.TEXTE;
				else if (record.ZONE === fTitle) r[id].$title = record.TEXTE;
				return r;
			}, this.class.cache.references[this.name]);

			if (countRefFields > 0) {
				reference.table.indexes[0].sqlNames(_);

				var names = reference.table.indexes[0].sqlNames(_);
				params = [];
				wheres = [];

				var getRefRecordId;
				if (id.length === 1) {
					wheres.push(names[0] + " in (" + Object.keys(ids).map(function(id) {
						params.push(id);
						return param(params.length - 1);
					}) + ")");

					getRefRecordId = function(key) {
						return function(record) {
							return record[key];
						};
					}(names[0].substring(0, names[0].length - 2));
				}

				sql = "select " + names + ", ";
				sql += Object.keys(refFields).map(function(field) {
					return refFields[field] + '_0';
				}).join(", ") + " from " + reference.table.name + " where (" + wheres.join(" and ") + ")";;
				tracerJs.debug && tracerJs.debug("sql:" + sql);
				tracerJs.debug && tracerJs.debug("params:" + params);

				this.class.cache.references[this.name] = this.supervisor.sqlDriver.withConnection(_, function(_, cnx) {
					return self.supervisor.sqlReader(_, cnx, sql, params).toArray(_);
				}).reduce(function(r, record) {
					if (getRefRecordId) {
						var id = getRefRecordId(record);
						r[id] = r[id] || {};
						Object.keys(refFields).forEach(function(field) {
							switch (field) {
								case 'COLFMT':
									var colfmt = record[refFields[field]];
									if (colfmt) {
										colfmt = colfmt.split('.');
										r[id].$precision = parseInt(colfmt[0]);
										r[id].$scale = (colfmt.length > 1) ? parseInt(colfmt[1]) : 0;
									}
									break;
								case 'SYMBOL':
									r[id].$symbol = record[refFields[field]] || null;
									break;
							}
						});
					}
					return r;
				}, this.class.cache.references[this.name]);
			}


			//tracerJs.debug && tracerJs.debug("this.class.cache.references[this.name]:" + JSON.stringify(this.class.cache.references[this.name]));
			return this.class.cache.references[this.name][getReferenceId(id)];
		};

		this.paramRefKeys = this.paramRefKeys || this.class.data.PARAM_FLDS.filter(function(paramData) {
			return paramData.FLDCLA === this.name && paramData.TYPKEY === 2;
		}, this);

		var self = this;
		var id = this.paramRefKeys.reduce_(_, function(_, r, param) {
			r.push((self.class.properties[param.VALEUR]) ? instance.get(_, param.VALEUR, true) : param.VALEUR);
			return r;
		}, []);

		var refId = getReferenceId(id);

		var reference = this.class.cache.references[this.name][refId];
		if (reference === undefined) {
			this.class.cache.references[this.name][refId] = reference = this.loadReferenceData(_, id);
		}
		return reference;
	}
});