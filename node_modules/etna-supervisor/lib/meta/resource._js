"use strict";

var util = require("etna-supervisor/lib/util");

var Resource = exports.constructor = util.defineClass(function(superv, resourceFactory, instance) {
	this.supervisor = superv;
	this.resourceFactory = resourceFactory;
	this.instance = instance;
}, null, {
	init: function(_) {
		return this;
	},
	dataNode: function(_) {
		var result = this.instance.class.group == null ? {
			$uuid: this.instance.data.AUUID,
			$etag: this.instance.data.UPDDATTIM,
		} : {};
		Object.keys(this.resourceFactory.properties).forEach_(_, function(_, name) {
			var prop = this.resourceFactory.properties[name];
			if (prop.collection) {
				result[prop.tag] = this.instance.get(_, name).map_(_, function(_, child) {
					return this.supervisor.new(_, 'Resource', prop.targetResourceFactory, child).dataNode(_);
				}, this);
			} else if (prop.isExtra) {
				// representation-level property - see later
			} else {
				result[prop.tag] = this.instance.get(_, name);
			}
		}, this);
		this.instance.diagnoses.forEach(function(diag) {
			var path = diag.path.split('.');
			var r = result, name;
			for (var i = 0; i < path.length - 1; i++) {
				name = path[i];
				r = r[name];
				if (!r || typeof r !== 'object') throw new Error("invalid diagnosis path: " + path.slice(0, i + 1));
			}
			name = path[i];
			r.$properties = r.$properties || {};
			var desc = r.$properties[name] = r.$properties[name] || {};
			var diags = desc.$diagnoses = desc.$diagnoses || [];
			diags.push(diag.dataNode());
		});
		return result;
	},
	clone: function() {
		return new Resource(this.supervisor, this.resourceFactory, this.instance.clone());
	},
	getDelta: function(_, old) {
		var delta = {
			$uuid: this.instance.data.AUUID,
			$etag: this.instance.data.UPDDATTIM,			
		};
		Object.keys(this.resourceFactory.properties).forEach_(_, function(_, name) {
			var prop = this.resourceFactory.properties[name];
			if (prop.collection) {
				// see later
			} else if (prop.isExtra) {
				// see later
			} else {
				var oldValue = old.instance.get(_, name);
				var newValue = this.instance.get(_, name);
				if (oldValue !== newValue) {
					delta[name] = newValue;
				}
			}
		}, this);
		console.log("GET DELTA RETURNS");
		console.log(delta);
		return delta;
	},
	applyDelta: function(_, delta) {
		// take snapshot before assigning
		var before = this.clone();
		Object.keys(delta).forEach_(_, function(_, name){
			var prop = this.resourceFactory.properties[name];
			if (!prop) return console.log("ignoring " + name  + " from delta"); 
			var v = delta[name];
			if (v === undefined) return;
			if (prop.collection) {
				// see later
			} else if (prop.isExtra) {
				// see later
			} else {
				this.instance.set(_, name, v);
			}
		}, this);
		return this.getDelta(_, before);
	}
});