"use strict";

var util = require("etna-supervisor/lib/util");
var tuuid = require('etna-engine/lib/runtime/uuid');
var variables = require('etna-engine/lib/runtime/variables');
var tracerJs = require("syracuse-trace/lib/helper").getTracer("etna.supervisor");

var constants = require("etna-supervisor/lib/constants");
var attributes = require("etna-supervisor/lib/attributes");
var baseInstance = require("etna-supervisor/lib/meta/baseInstance");

var InstanceProperty = require("etna-supervisor/lib/instanceProperty").InstanceProperty;
var InstanceCollection = require("etna-supervisor/lib/instanceCollection").InstanceCollection;

var Resource = exports.constructor = baseInstance.defineClass(function(superv, resourceFactory, instance, slots) {
	this.supervisor = superv;
	this.resourceFactory = resourceFactory;

	this.meta = this.resourceFactory.representation;

	if (this.meta) {
		this.clasName = this.meta.data.ABRCLA;
		this.index = this.resourceFactory.representation.class.index;
	}
	this.properties = this.resourceFactory.properties;
	if (instance) this.instance = instance;
	this.$exported = true;
	this.slots = slots || {};
}, null, {
	$$type: {
		get: function() {
			return "Resource";
		}
	},
	// Use bindInstance in order to set the instance.$parent !
	bindInstance: function(instance) {
		this.instance = instance;
		this.instance.$parent = this;
		return this;
	},
	dataNode: function(_, full) {
		full = (full !== undefined) ? full : true; // Default behavior = full generation
		var result = {};
		if (this.instance && this.instance.class && this.instance.class.group == null) {
			if (this.instance.class.properties['UPDDATTIM']) {
				this.instance.get(_, 'UPDDATTIM') ? this.instance.get(_, 'UPDDATTIM').toString() : "0000-00-00T00:00:00Z";
			}
		}
		result.$uuid = ((this.instance) ? this.instance.$uuid : this.$uuid).x3ToString();

		if (this.resourceFactory.$access) result.$access = this.resourceFactory.$access(_, this.instance);

		var self = this;
		Object.keys(this.properties).filter(function(name) {
			return !self.resourceFactory.properties[name].isExtraRef;
		}).forEach_(_, function(_, name) {
			var prop = this.properties[name];
			var instance = prop.instance(this);
			if (prop.collection) {
				if (prop.collection.mappingData && prop.collection.mappingData.TYPLNK === 3) {
					// Special treatment for 1x1 tables :
					var child = instance.get(_, name);
					var rChild = self.supervisor.new(_, 'Resource', prop.targetResourceFactory, child).dataNode(_, full);

					result = Object.keys(rChild).filter(function(p) {
						return p.charAt(0) !== '$';
					}).reduce(function(r, p) {
						r[p] = rChild[p];
						return r;
					}, result);

				} else {
					var lineIndex = 0;
					var isLineDeleted = false;
					var collection = instance.get(_, name);
					var snapshot = instance.$syssnapshot ? instance.$syssnapshot.get(_, name) : snapshot;
					var delta = !full && snapshot !== undefined && snapshot !== collection;
					//dbg:console.error(name+ "=> snapshot:"+(snapshot !== undefined));
					//dbg:console.error(name+ "=> delta:"+delta);

					var lines = collection.lines;
					if (delta) {
						// Compare the old and the new collection :
						if (lines.length < snapshot.lines.length) {
							// A line was deleted during the operation :
							isLineDeleted = true;
						} else {
							var diffLines = {};
							lineIndex = 0;
							diffLines = snapshot.lines.reduce(function(r, line) {
								var uuid = line.$uuid.x3ToString();
								//dbg:console.error("snapshot line:"+uuid);
								r[uuid] = ++lineIndex;
								return r;
							}, {});

							lineIndex = 0;
							var dbg = 0;
							lines.forEach_(_, function(_, line) {
								var uuid = line.$uuid.x3ToString();
								if (line.$astalin === constants.CST_ADEL || line.$astalin === constants.CST_ANEWDEL) {
									isLineDeleted = true;
								} else {
									++lineIndex;
									//dbg:console.error("collection line:"+uuid);
									if (diffLines[uuid] && line.$syssnapshot === undefined) {
										//dbg:console.error("remove "+uuid+" from diffLines");
										delete diffLines[uuid];
									} else {
										//dbg:console.error("keep line "+uuid+" from diffLines");
										var line = collection.index(_, lineIndex);
										line.$index = (lineIndex - 1);
										diffLines[uuid] = line;
									}
								};
							});
						}

						if (isLineDeleted === false) {
							// The list to send = modified lines 
							lines = [];
							Object.keys(diffLines).forEach_(_, function(_, uuid) {
								//dbg:console.error("keep line "+uuid);
								lines.push(diffLines[uuid]);
							});
						}
					}
					lineIndex = 0;
					var rChild = lines.filter(function(line) {
						// Filter line null or deleted :
						return line !== null && line.$astalin !== constants.CST_ADEL && line.$astalin !== constants.CST_ANEWDEL;
					})
						.map_(_, function(_, child) {
							var resLine = self.supervisor.new(_, 'Resource', prop.targetResourceFactory, child).dataNode(_, full);
							resLine.$index = (child.$index !== undefined) ? child.$index : lineIndex++;
							return resLine;
						}, this);
					//dbg:console.error("rChild length:"+rChild.length);


					if (!prop.collection.mappingData && prop.collection.nbrPro === 1) {
						// Special treatment for collection with only 1 property :
						result[prop.tag] = Object.keys(rChild).reduce(function(r, p) {
							var childDest;
							var val = Object.keys(rChild[p]).reduce(function(v, name) {
								v.push(rChild[p][name]);
								if (!childDest) childDest = name;
								return v;
							}, []);
							if (val.length === 1)
								r[p] = val[0];
							else if (val.length > 1) {
								r[p] = {};
								if (prop.targetResourceFactory.properties[childDest] !== undefined) {
									r[p][prop.targetResourceFactory.properties[childDest].destLookup] = val[0];
									r[p] = Object.keys(val[1]).reduce(function(o, name) {
										o[name] = val[1][name];
										return o;
									}, r[p]);
								}
							}
							return r;
						}, []);
					} else {
						result[prop.tag] = rChild;
						//dbg:console.error(prop.tag+" length:"+result[prop.tag].length);
					}
				}
			} else {
				//dbg:console.error(name+ " instance:"+!!instance)
				var slot = instance.slot(_, name);
				var value = slot._get(_, true);

				var snapshot = instance.$syssnapshot;
				var delta = !full && snapshot !== undefined;
				if (delta) {
					// Compare value and old value :
					var oldValue = snapshot.get(_, name);
					value = (oldValue.x3Compare(value) !== 0) ? value : undefined;
				}

				// Manage the value
				if (value !== undefined) {
					// Compute the value to be stored in the JSON: 
					// can be undefined for CLOBs andd BLOBs 
					value = prop.type.toJson(value, prop.data);
					if (value !== undefined) {
						result[prop.tag] = value;
						if (prop._isReference) {
							result[prop.ref(prop.tag)] = instance.get(_, prop.ref(name));
						} else if (prop.hasLookup) {
							result[prop.ref(prop.tag)] = {
								$title: ""
							};
						}
					}
				}
				if (this.resourceFactory.$attributes) {
					// Fetch attributes :
					var attributes = delta ? slot.getDeltaAttributes(_, snapshot.slot(_, name)) :
						slot.getAttributes(_);
					// Store them in the node											 
					this.resourceFactory.$attributes(result, prop.tag, attributes);
				}
				if (this.resourceFactory.$diagnoses) {
					// Manage the errors :
					var diagnoses = slot.getDiagnoses(_);
					if (delta) {
						// Compare old and current diagnoses
						var snapSlot = snapshot.slot(_, name);
						var oldDiagnoses = snapSlot.getDiagnoses(_);
						// set diagnoses to null if diagnoses were deleted:
						diagnoses = (oldDiagnoses.length && !diagnoses.length) ? null : diagnoses;
					}
					// Store them in the node											 
					this.resourceFactory.$diagnoses(result, prop.tag, diagnoses);
				}
			}
		}, this);
		if (this.resourceFactory.$diagnoses) {
			var diagnoses = this.diagnoses;
			if (this.instance) diagnoses = diagnoses.concat(this.instance.diagnoses);
			if (diagnoses.length) this.resourceFactory.$diagnoses(result, null, diagnoses);
		}
		return result;
	},
	applyDelta: function(_, delta) {
		// take snapshot before assigning
		//dbg:console.error("applyDelta on "+this.$$type+" "+this.$id.x3ToString())
		var resourceFactory = this.resourceFactory;
		var self = this;
		Object.keys(delta).forEach_(_, function(_, tag) {
			//dbg:console.log("applyDelta tag:" + tag);
			var name = resourceFactory.tag2Property(tag);
			//dbg:console.log("applyDelta name:" + name);
			var prop = self.properties[name];
			if (!prop) return; // console.log("ignoring " + tag + " from delta");

			var v = delta[tag];
			if (v === undefined) return;

			var instance = prop.instance(this);
			if (prop.collection) {
				var collection = instance.get(_, name);
				v.forEach_(_, function(_, deltaLine) {
					var uuid = deltaLine.$uuid.x3ToUuid();

					//dbg:console.log("applyDelta line uuid:" + uuid);
					var line = collection.find("$uuid", uuid);
					if (line === null) {
						//dbg:console.log("applydDelta add Line ...");
						var i = collection.add(_, deltaLine.$index ? (deltaLine.$index + 1) : constants.CST_ALASTPOS, uuid);
						var line = collection.index(_, i);
						//dbg:console.log("applydDelta added Line "+line.$uuid.x3ToString()+" parent type:"+line.$parent.$$type);
					} else {
						//dbg:console.log("applyDelta to Line " + line.$uuid.x3ToString()+" parent type:"+line.$parent.$$type);
						if (deltaLine.$isDeleted) {
							// Delete the line :
							collection.del(_, deltaLine.$index + 1);
						} else {
							var rChild = self.supervisor.new(_, 'Resource', prop.targetResourceFactory, line);
							rChild.applyDelta(_, deltaLine);
						}
					}
				});

			} else if (!/.*_REF$/.test(name)) { // See later for references :
				//dbg:console.error("applyDelta instance.set " + name + " parent type:" + instance.$parent.$$type);
				instance.set(_, name, v);
			}
		}, this);
	},
	clone: function() {
		var instance = this.instance.clone();
		return new Resource(this.supervisor, this.resourceFactory, instance).bindInstance(instance);
	},
	getChildren: function() {
		return [this.instance];
	},
	afterQuery: function(_) {
		// First call AQUERY_TRANS_AFTER on the class's instance
		return this.instance.afterQuery(_);
	},
	beforeControl: function(_, operation) {
		var status = this._actionBeforeControl(_, operation);
		return status || this.instance.beforeControl(_, operation);
	},
	afterControl: function(_, operation) {
		var status = this.instance.afterControl(_, operation);
		return status || this._actionAfterControl(_, operation);
	},
	insert: function(_) {
		return this.instance.$AINSERT(_);
	},
	update: function(_) {
		return this.instance.$AUPDATE(_);
	},
	read: function(_, key) {
		this.key = key;
		tracerJs.debug && tracerJs.debug("resource.load " + key);
		this.instance = this.supervisor.new(_, 'Instance', this.resourceFactory.representation.class, this);
		this.bindInstance(this.instance); // Set instance.$parent !
		var status = this.instance.read(_, key);
		return status;
	},
	delete: function(_) {
		return this.instance.delete(_);
	}
});