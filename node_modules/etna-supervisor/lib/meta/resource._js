"use strict";

var util = require("etna-supervisor/lib/util");
var tuuid = require('etna-engine/lib/runtime/uuid');
var variables = require('etna-engine/lib/runtime/variables');
var tracerJs = require("syracuse-trace/lib/helper").getTracer("etna.supervisor");
var attributes = require("etna-supervisor/lib/attributes");

var baseInstance = require("etna-supervisor/lib/meta/baseInstance");

var InstanceProperty = require("etna-supervisor/lib/instanceProperty").InstanceProperty;
var InstanceCollection = require("etna-supervisor/lib/instanceCollection").InstanceCollection;

var Resource = exports.constructor = baseInstance.defineClass(function(superv, resourceFactory, instance, slots) {
	this.supervisor = superv;
	this.resourceFactory = resourceFactory;
	this.meta = this.resourceFactory.representation;

	if (this.meta) {
		this.clasName = this.meta.data.ABRCLA;
		this.index = this.resourceFactory.representation.class.index;
	}
	this.properties = this.resourceFactory.properties;
	if (instance) {
		this.instance = instance;
		this.instance.parent = this;
	}
	this.$exported = true;
	this.slots = slots || {};

}, null, {
	$$type: {
		get: function() {
			return "Resource";
		}
	},
	dataNode: function(_) {
		var result = {};
		if (this.instance.class.group == null) {
			if (this.instance.class.properties['UPDDATTIM']) {
				this.instance.get(_, 'UPDDATTIM') ? this.instance.get(_, 'UPDDATTIM').toString() : "0000-00-00T00:00:00Z";
			}
		}
		if (this.resourceFactory.$uuid) result.$uuid = this.resourceFactory.$uuid(_, this.instance);
		if (this.resourceFactory.$access) result.$access = this.resourceFactory.$access(_, this.instance);

		var self = this;
		Object.keys(this.properties).filter(function(name) {
			return !self.resourceFactory.properties[name].isExtraRef;
		}).forEach_(_, function(_, name) {
			var prop = this.properties[name];
			var instance = prop.isExtra ? this : this.instance;
			if (prop.collection) {
				var rChild = instance.get(_, name).lines.map_(_, function(_, child) {
					return this.supervisor.new(_, 'Resource', prop.targetResourceFactory, child).dataNode(_);
				}, this);
				if (prop.collection.mappingData && prop.collection.mappingData.TYPLNK === 3) {
					// Special treatment for 1x1 tables :
					result = Object.keys(rChild[0]).filter(function(p) {
						return p.charAt(0) !== '$';
					})
						.reduce(function(r, p) {
							r[p] = rChild[0][p];
							return r;
						}, result);
				} else if (!prop.collection.mappingData && prop.collection.nbrPro === 1) {
					// Special treatment for collection with only 1 property :
					result[prop.tag] = Object.keys(rChild).reduce(function(r, p) {
						var childDest;
						var val = Object.keys(rChild[p]).reduce(function(v, name) {
							v.push(rChild[p][name]);
							if (!childDest) childDest = name;
							return v;
						}, []);
						if (val.length === 1)
							r[p] = val[0];
						else {
							r[p] = {};
							r[p][prop.targetResourceFactory.properties[childDest].destLookup] = val[0];
							r[p] = Object.keys(val[1]).reduce(function(o, name) {
								o[name] = val[1][name];
								return o;
							}, r[p]);
						}
						return r;
					}, []);
				} else {
					result[prop.tag] = rChild;
				}
			} else {
				result[prop.tag] = prop.type.toJson(instance.get(_, name), prop.data);
				if (prop._isReference) {
					result[prop.tag + '_REF'] = instance.get(_, name + '_REF');
				} else if (prop.hasLookup) {
					result[prop.tag + '_REF'] = {
						$title: ""
					};
				}
			}
		}, this);
		this.instance.diagnoses.forEach(function(diag) {
			var path = diag.path.split('.');
			var r = result,
				name;
			for (var i = 0; i < path.length - 1; i++) {
				name = path[i];
				r = r[name];
				if (!r || typeof r !== 'object') throw new Error("invalid diagnosis path: " + path.slice(0, i + 1));
			}
			name = path[i];
			r.$properties = r.$properties || {};
			var desc = r.$properties[name] = r.$properties[name] || {};
			var diags = desc.$diagnoses = desc.$diagnoses || [];
			diags.push(diag.dataNode());
		});
		return result;
	},
	getDiagnoses: function(reply) {
		var httpStatus = this.supervisor.constants.CST_AHTTP_OK;
		reply.$diagnoses = this.diagnoses.reduce(function(r, diag) {
			httpStatus = Math.max(httpStatus, diag.httpStatus);
			r.push(diag.dataNode());
			return r;
		}, []);
		return httpStatus;
	},
	clone: function() {
		return new Resource(this.supervisor, this.resourceFactory, this.instance.clone());
	},
	getDelta: function(_, old) {
		var delta = {
			$uuid: this.instance.data.AUUID,
			$etag: this.instance.data.UPDDATTIM,
		};
		Object.keys(this.properties).forEach_(_, function(_, name) {
			var prop = this.properties[name];
			if (prop.collection) {
				// see later
			} else if (prop.isExtra) {
				// see later
			} else {
				var oldValue = old.instance.get(_, name);
				var newValue = this.instance.get(_, name);
				if (oldValue !== newValue) {
					delta[name] = newValue;
				}
			}
		}, this);
		console.log("GET DELTA RETURNS");
		console.log(delta);
		return delta;
	},
	applyDelta: function(_, delta) {
		// take snapshot before assigning
		var before = this.clone();
		Object.keys(delta).forEach_(_, function(_, name) {
			var prop = this.properties[name];
			if (!prop) return console.log("ignoring " + name + " from delta");
			var v = delta[name];
			if (v === undefined) return;
			if (prop.collection) {
				// see later
			} else if (prop.isExtra) {
				// see later
			} else {
				this.instance.set(_, name, v);
			}
		}, this);
		return this.getDelta(_, before);
	},
	ainit: function(_) {
		var status = this.instance.ainit(_);
		return status || this._action(_, "AINIT");
	},
	actionRead: function(_, action, key) {
		tracerJs.debug && tracerJs.debug("resource.actionRead " + action + " key:" + key);
		var delayedArgs = function(_, instance, args) {
			return function(_) {
				var index = instance.class.index;
				var record = instance.record;
				if (record !== undefined) {
					// Add the record  
					var table = instance.class.table;
					var columns = table.columns;
					var value = Object.keys(columns).reduce(function(r, colName) {
						r.types[colName] = "F" + columns[colName].type.etnaType;
						if (columns[colName].data.DIME <= 1) {
							r.values[colName] = record[colName] || columns[colName].type.defaultValue;
						} else {
							r.values[colName] = [];
							for (var i = 0; i < columns[colName].data.DIME; i++) {
								r.values[colName][i] = (record[colName] && record[colName][i]) ? record[colName][i] : columns[colName].type.defaultValue;
							}
						}
						return r;
					}, {
						values: {},
						types: {}
					});

					args["F:" + table.abbrev] = {
						letter: "F",
						abrev: table.abbrev,
						value: value
					};
				}

				Object.keys(args).forEach(function(a) {
					tracerJs.debug && tracerJs.debug(a + " = " + args[a].value);
				});
				return args;
			};
		};
		// Compute the arguments for the scripts :
		var dargs = delayedArgs(_, this.instance, this.getActionArgs(_, action, key));

		// First call AQUERY_TRANS_AFTER on the class's instance
		var astatus = this.instance.runScripts(_, "$METHODS", dargs);

		if (astatus === this.supervisor.constants.CST_AOK) {
			// Second call AQUERY_TRANS_AFTER on the representation's instance
			astatus = this.runScripts(_, "$METHODS", dargs);
		}
		return astatus;
	},
	afterQuery: function(_) {
		return this.actionRead(_, "AQUERY_TRANS_AFTER");
	},
	read: function(_, key) {
		this.key = key;
		tracerJs.debug && tracerJs.debug("resource.load " + key);
		this.instance = this.supervisor.new(_, 'Instance', this.resourceFactory.representation.class, this);

		var status;
		if (status = this.actionRead(_, "AREAD_BEFORE", key)) return status;
		if (status = this.instance.read(_, key)) {
			throw new util.HttpError(404, key + ":" + this.supervisor.loadMess(_, 100, 23));

		}
		return this.actionRead(_, "AREAD_AFTER");
	},
	assertDeleteAllowed: function(_) {
		if (0) {
			// TODO AGETWRIGHTD
			throw new util.HttpError(403, this.supervisor.loadMess(_, 139, 327) + " " + this.supervisor.loadMess(_, 139, 328));
		}
	},
	controlBefore: function(_, operation) {
		var status = this._actionControlBefore(_, operation);
		return status || this.instance.controlBefore(_, operation);
	},
	controlAfter: function(_, operation) {
		var status = this.instance.controlAfter(_, operation);
		return status || this._actionControlAfter(_, operation);
	},
	delete: function(_) {
		tracerJs.debug && tracerJs.debug("resource.delete " + this.key);
		var status;
		var self = this;

		this.assertDeleteAllowed(_);

		if (status = this.withControl(_, function Delete() {
			tracerJs.debug && tracerJs.debug("Delete " + self.key);

			// // delete not blocking links :
			// tableLinks.delete(_, key);
			// reply.$diagnoses.push({
			// 	$severity: "success"
			// });
			// return status;
		})) return status;

		return this.setStatus(_, null,
			this.supervisor.constants.CST_AOK,
			this.supervisor.loadMessParams(_, 149, 61, this.key.join('~')));
	}
});