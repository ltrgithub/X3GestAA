"use strict";

var util = require("etna-supervisor/lib/util");
var utilDriver = require("etna-supervisor/lib/drivers/util");
var date = require("syracuse-core/lib/types/date");
var bcd = require('etna-engine/lib/runtime/bcd');
var uuid = require('etna-engine/lib/runtime/uuid');
var tuuid = require('etna-engine/lib/runtime/tuuid');
var tdate = require('etna-engine/lib/runtime/tdate');
var tdatetime = require('etna-engine/lib/runtime/tdatetime');
var datetime = require("syracuse-core/lib/types/datetime");
var variables = require('etna-engine/lib/runtime/variables');

exports.typTyp2EtnaType = {
	1: "J",
	2: "I",
	3: "I",
	4: "N",
	7: "S",
	8: "D",
	9: "B",
	10: "T",
	11: "Z",
	12: "E"
};

module.exports = {
	collectionName: 'ATYPE',
	keyName: 'CODTYP',
	constructor: util.defineClass(function(superv, data) {
		this.supervisor = superv;
		if (data.LNGTYP && typeof data.LNGTYP === 'string') {
			if (!isNaN(data.LNGTYP) && bcd.toDouble(bcd.fromString(data.LNGTYP)) > 0) data.LNGTYP = bcd.toDouble(bcd.fromString(data.LNGTYP));
			else delete data.LNGTYP;
		}
		this.data = data;
	}, null, {
		init: function(_) {
			return this;
		},
		getX3Format: function(propertyLength) {
			this.$x3Format = undefined;
			if (this.data.TYPTYP === 7 && (this.data.FORTYP || this.data.OPTION || this.data.LNGTYP)) {
				// type string : initialize $x3Format
				var x3Format = "K";
				var chfmt = this.data.FORTYP || "";
				var optsai = this.data.OPTION || "";
				var carfmt = "";
				var optfmt = "";

				propertyLength = propertyLength || this.data.LNGTYP;

				if (/^=|\[+|>/.test(chfmt)) chfmt = "";

				if (/C+/.test(optsai)) carfmt = "c";
				else if (/A+/.test(optsai)) carfmt = /\#+/.test(optsai) ? "B" : "A";
				else if (/\#+/.test(optsai)) carfmt = "#";
				else carfmt = "X";

				if (/T+/.test(optsai)) optfmt += "T";
				else if (/D+/.test(optsai)) optfmt += "TD";

				if (/\*+/.test(optsai)) optfmt += "*+";
				if (/1+/.test(optsai)) optfmt += "1";
				if (/z+/.test(optsai)) optfmt += "z";

				if (/=+/.test(optsai)) optfmt += "=";
				else if (/<+/.test(optsai)) optfmt += "<";
				else if (/>+/.test(optsai)) optfmt += ">";

				if (/W+/.test(optsai)) optfmt += "W";

				if (chfmt.length && !/^=/.test(chfmt)) {
					if (optsai = "" && /X+/.test(chfmt)) x3Format = undefined;
				} else chfmt = propertyLength.toString() + carfmt;
				if (/T+/.test(optfmt) && !/TD+/.test(optfmt)) x3Format = undefined;

				this.$x3Format = x3Format ? x3Format + optfmt + ":" + chfmt : "";
			}
			return this.$x3Format;
		},
		jsType: {
			get: function() {
				switch (this.data.TYPTYP) {
					case 1:
						// tiny int
						return "number";
					case 2:
						// short integer
						return "number";
					case 3:
						// long integer - was translatable text ???
						return "number";
					case 4:
						return "string";
					case 7:
						return "string";
					case 8:
						// date
						return "date";
					case 10:
						// documnet
						return "object";
					case 11:
						// uuid
						return "binary";
					case 12:
						// datetime
						return "date";
					default:
						throw new Error("NIY type: " + this.data.TYPTYP);
				}
			},
		},
		sqlType: function(colData) {
			var driver = this.supervisor.sqlDriver;
			switch (this.data.TYPTYP) {
				case 1:
					return driver.tinyIntType();
				case 2:
					// short integer
					return driver.shortIntType();
				case 3:
					// translatable text (no column)
					return driver.intType();
				case 4:
					return driver.decimalType();
				case 7:
					return driver.stringType(this.data.LNGTYP || (colData && colData.LONG) || 1020);
				case 8:
					// date
					return driver.dateType();
				case 9:
					return driver.blobType2(); // review
				case 10:
					// document
					return driver.stringType(1020); // see later
				case 11:
					return driver.uuidType();
				case 12:
					return driver.datetimeType();
				default:
					throw new Error("unsupported datatype: " + this.data.TYPTYP + " (" + typeof this.data.TYPTYP + ")");
			}
		},
		etnaType: {
			get: function() {
				if (exports.typTyp2EtnaType[this.data.TYPTYP]) {
					return exports.typTyp2EtnaType[this.data.TYPTYP];
				}
				throw new Error("NIY type: " + this.data.TYPTYP);
			}
		},
		convertIn: function(val) {
			switch (this.data.TYPTYP) {
				case 8:
					// date
					return val ? date.fromJsDate(new Date(val)) : null;
				case 12:
					// datetime
					return val ? datetime.fromJsDate(new Date(val)) : null;
				default:
					return val;
			}
		},
		toSql: function(val) {
			return val.x3ToSql(this.supervisor.sqlDriver);
		},
		fromSql: function(val) {
			return utilDriver.fromSql(val, this.data.TYPTYP, this.supervisor.sqlDriver);
		},

		toSqlQuery: function(val) {
			var driver = this.supervisor.sqlDriver;
			switch (this.data.TYPTYP) {
				case 7:
					return "'" + val + "'";
				case 8:
					return driver.sqlDate(val);
				default:
					return val;
			}
		},
		toJson: function(val, data) {
			switch (this.data.TYPTYP) {
				case 1:
					return (data.NOLIB !== 1) ? val : (val === 2 ? true : false);
				case 4:
					return val ? val.x3ToString() : 0; // val ? bcd.toString(val) : "0";
				case 8: // date
					return val ? val.x3ToJson() : null;
				case 11: // uuid
				case 12: // datetime
					return val.x3ToString(); //val.toString();
				default:
					return val;
			}
		},
		defaultValue: {
			get: function() {
				return variables.types[this.etnaType].def;
			}
		},
		fillNode: function(_, data, node) {
			if (this.atypepro === undefined) {
				var typpro = this.supervisor.load(_, 'Typepro', this.data.TYPPROSYR);
				if (!typpro) throw new Error("content type not found: " + this.data.TYPPROSYR);
				this.atypepro = {
					protyp: typpro.data.PROTYP,
					preflg: typpro.data.PREFLG,
					lisflg: typpro.data.LISFLG
				};
			}
			node.$type = this.atypepro.protyp;

			if (this.data.FMTPROSYR > 1) {
				var fmt;
				switch (this.data.FMTPROSYR) {
					case 2:
						fmt = "$email";
						break;
					case 3:
						fmt = "$phone";
						break;
					case 6:
						fmt = "TT"; // Time format hh:mm:ss
						break;
					default:
						fmt = this.supervisor.loadMess(_, 7880, this.data.FMTPROSYR);
						break;
				}
				if (fmt !== "") node.$format = fmt;

			}
			switch (this.data.TYPTYP) {
				case 2:
				case 3:
				case 4:
					var lon = 0;
					if (data.LONG >= 0) {
						lon = data.LONG;
					} else if (this.data.LNGTYP >= 0) {
						lon = this.data.LNGTYP;
					}
					if (lon >= 0) {
						node.$maxLength = parseInt(lon);
					}
					if (this.data.TYPTYP === 4 && lon >= 0) {
						node.$precision = parseInt(lon);
						var l = ("" + Math.round(lon * 1e6) / 1e6).split('.');
						node.$scale = parseInt(l[1] || 0);
						if (node.$scale === 0) node.$format = "0";
						else {
							var zero = "0000000000000000000000000000000000000000000";
							node.$format = "0." + zero.substring(0, node.$scale);
						}
					}
					break;
				case 7:
					var lon = 0;
					if (this.data.LNGTYP >= 0) {
						lon = this.data.LNGTYP;
					} else if (data.LONG >= 0) {
						lon = data.LONG;
					}
					if (lon >= 0) {
						node.$maxLength = parseInt(lon);
					}
					break;
			}
		},
		targetClass: function(_) {
			if (this.data.CODCLA) return this.supervisor.load(_, 'Class', this.data.CODCLA).init(_);
		},
		maxLength: function() {
			return this.data.LNGTYP;
		},
	}),
	// end of constructor
	fillTypeNode: function(_, superv, data, node) {
		var typ = superv.load(_, 'Type', data.CODTYP);
		if (!typ) throw new Error("type not found: " + data.CODTYP);
		if (data.NOLIB === 1) {
			node.$type = 'application/x-boolean';
		}
		//Elsif len(ASHW.ASWR(I).UOMPRO)
		// #It's a unit
		//  PROTYPE =func ASYRJSO.TYP('quantity')
		else if (data.CODTYP === 'ATX') {
			node.$type = 'application/x-string';
			node.$maxLength = 30;
		} else {
			typ.fillNode(_, data, node);
		}
		if (data.NOLIB >= 2) {
			node.$value = {
				$type: 'application/x-integer',
				$enum: superv.loadEnum(_, data.NOLIB).filter(function(entry) {
					return entry.$title !== '#'; // remove bogus entries in module list
				}),
			};
		}
	},
};