"use strict";

var util = require("etna-supervisor/lib/util");
var utilDriver = require("etna-supervisor/lib/drivers/util");
var date = require("syracuse-core/lib/types/date");
var bcd = require('etna-engine/lib/runtime/bcd');
var uuid = require('etna-engine/lib/runtime/uuid');
var tuuid = require('etna-engine/lib/runtime/tuuid');
var tdate = require('etna-engine/lib/runtime/tdate');
var tdatetime = require('etna-engine/lib/runtime/tdatetime');
var datetime = require("syracuse-core/lib/types/datetime");
var variables = require('etna-engine/lib/runtime/variables');

module.exports = {
	collectionName: 'ATYPE',
	keyName: 'CODTYP',
	constructor: util.defineClass(function(superv, data) {
		this.supervisor = superv;
		this.data = data;
	}, null, {
		init: function(_) {
			return this;
		},
		jsType: {
			get: function() {
				switch (this.data.TYPTYP) {
					case 1:
						// tiny int
						return "number";
					case 2:
						// short integer
						return "number";
					case 3:
						// long integer - was translatable text ???
						return "number";
					case 4:
						return "string";
					case 7:
						return "string";
					case 8:
						// date
						return "date";
					case 10:
						// documnet
						return "object";
					case 11:
						// uuid
						return "binary";
					case 12:
						// datetime
						return "date";
					default:
						throw new Error("NIY type: " + this.data.TYPTYP);
				}
			},
		},
		sqlType: function(colData) {
			var driver = this.supervisor.sqlDriver;
			switch (this.data.TYPTYP) {
				case 1:
					return driver.tinyIntType();
				case 2:
					// short integer
					return driver.shortIntType();
				case 3:
					// translatable text (no column)
					return driver.intType();
				case 4:
					return driver.decimalType();
				case 7:
					return driver.stringType(this.data.LNGTYP || (colData && colData.LONG) || 1020);
				case 8:
					// date
					return driver.dateType();
				case 9:
					return driver.blobType2(); // review
				case 10:
					// document
					return driver.stringType(1020); // see later
				case 11:
					return driver.uuidType();
				case 12:
					return driver.datetimeType();
				default:
					throw new Error("unsupported datatype: " + this.data.TYPTYP + " (" + typeof this.data.TYPTYP + ")");
			}
		},
		etnaType: {
			get: function() {
				switch (this.data.TYPTYP) {
					case 1:
						// tiny int
						return "J";
					case 2:
						// short integer
						return "I";
					case 3:
						// long integer - was translatable text ???
						return "I";
					case 4:
						return "N";
					case 7:
						return "S";
					case 8:
						// date
						return "D";
					case 9:
						// Blob
						return "B";
					case 10:
						// documnet
						return "T";
					case 11:
						// uuid
						return "Z";
					case 12:
						// datetime
						return "E";
					default:
						throw new Error("NIY type: " + this.data.TYPTYP);
				}
			}
		},
		convertIn: function(val) {
			switch (this.data.TYPTYP) {
				case 8:
					// date
					return val ? date.fromJsDate(new Date(val)) : null;
				case 12:
					// datetime
					return val ? datetime.fromJsDate(new Date(val)) : null;
				default:
					return val;
			}
		},
		toSql: function(val) {
			/*var driver = this.supervisor.sqlDriver;
			
			switch (this.data.TYPTYP) {
				case 4:
					return val ? bcd.toString(val) : "0";
				case 8:
					// date
					return driver.sqlDate(val ? val.toJsDate() : driver.nullDate());
				case 11:
					return driver.sqlUuid(val ? val.toString() : uuid.nullUuidString());
				case 12:
					// datetime
					return driver.sqlDatetime(val ? val.toJsDate() : driver.nullDate());
				default:
					return val === undefined ? null : val;
			}
			*/
			var v = val.x3ToSql(this.supervisor.sqlDriver);
			console.log("Value : " + val.x3ToString() + " toSql:" + v);
			return v;

		},
		fromSql: function(val) {
			/*
			var driver = this.supervisor.sqlDriver;
			switch (this.data.TYPTYP) {
				case 1:
				case 2:
				case 3:
					return typeof val === "string" ? parseInt(val, 10) : val;
				case 4:
					return val ? bcd.fromString(val) : null;
				case 8:
					// date
					return driver.fromSqlDate(val);
				case 11:
					return driver.isNullUuid(val) ? tuuid.generate() : tuuid.x3ToUuid(val);
				case 12:
					// datetime
					return driver.fromSqlDatetime(val);
				default:
					return val;
			}
			*/
			return utilDriver.fromSql(val, this.data.TYPTYP, this.supervisor.sqlDriver);
		},

		toSqlQuery: function(val) {
			var driver = this.supervisor.sqlDriver;
			switch (this.data.TYPTYP) {
				case 7:
					return "'" + val + "'";
				case 8:
					return driver.sqlDate(val);
				default:
					return val;
			}
		},
		toJson: function(val, data) {
			switch (this.data.TYPTYP) {
				case 1:
					return (data.NOLIB !== 1) ? val : (val === 2 ? true : false);
				case 4:
					return val ? bcd.toString(val) : "0";
				case 8: // date
					return val ? val.x3ToJson() : null;
				case 11: // uuid
				case 12: // datetime
					return val.x3ToString(); //val.toString();
				default:
					return val;
			}
		},
		defaultValue: function() {
			return variables.types[this.etnaType].def;
		},
		fillNode: function(_, data, node) {
			if (this.atypepro === undefined) {
				var typpro = this.supervisor.load(_, 'Typepro', this.data.TYPPROSYR);
				if (!typpro) throw new Error("content type not found: " + this.data.TYPPROSYR);
				this.atypepro = {
					protyp: typpro.data.PROTYP,
					preflg: typpro.data.PREFLG,
					lisflg: typpro.data.LISFLG
				};
			}
			node.$type = this.atypepro.protyp;

			if (this.data.FMTPROSYR > 1) {
				var fmt;
				switch (this.data.FMTPROSYR) {
					case 2:
						fmt = "$email";
						break;
					case 3:
						fmt = "$phone";
						break;
					case 6:
						fmt = "TT"; // Time format hh:mm:ss
						break;
					default:
						fmt = this.supervisor.loadMess(_, 7880, this.data.FMTPROSYR);
						break;
				}
				if (fmt !== "") node.$format = fmt;

			}

			switch (this.data.TYPTYP) {
				case 2:
				case 3:
				case 4:
					var lon = 0;
					if (data.LONG >= 0) {
						lon = data.LONG;
					} else if (this.data.LNGTYP >= 0) {
						lon = this.data.LNGTYP;
					}
					if (lon >= 0) {
						node.$maxLength = parseInt(lon);
					}
					if (this.data.TYPTYP === 4 && lon >= 0) {
						node.$precision = parseInt(lon);
						var l = ("" + Math.round(lon * 1e6) / 1e6).split('.');
						node.$scale = parseInt(l[1] || 0);
						if (node.$scale === 0) node.$format = "0";
						else {
							var zero = "0000000000000000000000000000000000000000000";
							node.$format = "0." + zero.substring(0, node.$scale);
						}
					}
					break;
				case 7:
					if (this.data.LNGTYP >= 0) {
						node.$maxLength = this.data.LNGTYP;
					} else if (data.LONG >= 0) {
						node.$maxLength = data.LONG;
					}
					break;
			}
		},
		targetClass: function(_) {
			if (this.data.CODCLA) return this.supervisor.load(_, 'Class', this.data.CODCLA).init(_);
		},
		maxLength: function() {
			return this.data.LNGTYP;
		},
	}),
	// end of constructor
	fillTypeNode: function(_, superv, data, node) {
		var typ = superv.load(_, 'Type', data.CODTYP);
		if (!typ) throw new Error("type not found: " + data.CODTYP);
		if (data.NOLIB === 1) {
			node.$type = 'application/x-boolean';
		}
		//Elsif len(ASHW.ASWR(I).UOMPRO)
		// #It's a unit
		//  PROTYPE =func ASYRJSO.TYP('quantity')
		else if (data.CODTYP === 'ATX') {
			node.$type = 'application/x-string';
			node.$maxLength = 30;
		} else {
			typ.fillNode(_, data, node);
		}
		if (data.NOLIB >= 2) {
			node.$value = {
				$type: 'application/x-integer',
				$enum: superv.loadEnum(_, data.NOLIB).filter(function(entry) {
					return entry.$title !== '#'; // remove bogus entries in module list
				}),
			};
		}
	},
};