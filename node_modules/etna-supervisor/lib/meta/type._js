"use strict";

var util = require("etna-supervisor/lib/util");
var date = require("syracuse-core/lib/types/date");
var bcd = require('etna-engine/lib/runtime/bcd');
var uuid = require('etna-engine/lib/runtime/uuid');
var tuuid = require('etna-engine/lib/runtime/tuuid');
var datetime = require("syracuse-core/lib/types/datetime");
var variables = require('etna-engine/lib/runtime/variables');

module.exports = {
	collectionName: 'ATYPE',
	keyName: 'CODTYP',
	constructor: util.defineClass(function(superv, data) {
		this.supervisor = superv;
		this.data = data;
	}, null, {
		init: function(_) {
			return this;
		},
		jsType: {
			get: function() {
				switch (this.data.TYPTYP) {
					case 1:
						// tiny int
						return "number";
					case 2:
						// short integer
						return "number";
					case 3:
						// long integer - was translatable text ???
						return "number";
					case 4:
						return "string";
					case 7:
						return "string";
					case 8:
						// date
						return "date";
					case 10:
						// documnet
						return "object";
					case 11:
						// uuid
						return "binary";
					case 12:
						// datetime
						return "date";
					default:
						throw new Error("NIY type: " + this.data.TYPTYP);
				}
			},
		},
		sqlType: function(colData) {
			var driver = this.supervisor.sqlDriver;
			switch (this.data.TYPTYP) {
				case 1:
					return driver.tinyIntType();
				case 2:
					// short integer
					return driver.shortIntType();
				case 3:
					// translatable text (no column)
					return driver.intType();
				case 4:
					return driver.decimalType();
				case 7:
					return driver.stringType(this.data.LNGTYP || (colData && colData.LONG) || 1020);
				case 8:
					// date
					return driver.dateType();
				case 9:
					return driver.blobType2(); // review
				case 10:
					// document
					return driver.stringType(1020); // see later
				case 11:
					return driver.uuidType();
				case 12:
					return driver.datetimeType();
				default:
					throw new Error("unsupported datatype: " + this.data.TYPTYP + " (" + typeof this.data.TYPTYP + ")");
			}
		},
		etnaType: {
			get: function() {
				switch (this.data.TYPTYP) {
					case 1:
						// tiny int
						return "J";
					case 2:
						// short integer
						return "I";
					case 3:
						// long integer - was translatable text ???
						return "I";
					case 4:
						return "N";
					case 7:
						return "S";
					case 8:
						// date
						return "D";
					case 10:
						// documnet
						return "B";
					case 11:
						// uuid
						return "S";
					case 12:
						// datetime
						return "E";
					default:
						throw new Error("NIY type: " + this.data.TYPTYP);
				}
			}
		},
		convertIn: function(val) {
			switch (this.data.TYPTYP) {
				case 8:
					// date
					return val ? date.fromJsDate(new Date(val)) : null;
				case 12:
					// datetime
					return val ? datetime.fromJsDate(new Date(val)) : null;
				default:
					return val;
			}
		},
		toSql: function(val) {
			var driver = this.supervisor.sqlDriver;
			switch (this.data.TYPTYP) {
				case 4:
					return val ? bcd.toString(val) : "0";
				case 8:
					// date
					return driver.sqlDate(val ? val.toJsDate() : driver.nullDate());
				case 11:
					return driver.sqlUuid(val ? val.toString() : uuid.nullUuidString());
				case 12:
					// datetime
					return driver.sqlDatetime(val ? val.toJsDate() : driver.nullDate());
				default:
					return val === undefined ? null : val;
			}
		},
		fromSql: function(val) {
			var driver = this.supervisor.sqlDriver;
			switch (this.data.TYPTYP) {
				case 1:
				case 2:
				case 3:
					return typeof val === "string" ? parseInt(val, 10) : val;
				case 4:
					return val ? bcd.fromString(val) : null;
				case 8:
					// date
					return driver.fromSqlDate(val);
				case 11:
					return driver.isNullUuid(val) ? tuuid.generate() : tuuid.x3ToUuid(val);
				case 12:
					// datetime
					return driver.fromSqlDatetime(val);
				default:
					return val;
			}
		},
		toSqlQuery: function(val) {
			var driver = this.supervisor.sqlDriver;
			switch (this.data.TYPTYP) {
				case 7:
					return "'" + val + "'";
				case 8:
					return driver.sqlDate(val);
				default:
					return val;
			}
		},
		toJson: function(val) {
			switch (this.data.TYPTYP) {
				case 4:
					return val ? bcd.toString(val) : "0";
				case 8: // date
					return val.x3ToJson();
				case 11: // uuid
				case 12: // datetime
					return val.x3ToString(); //val.toString();
				default:
					return val;
			}
		},
		defaultValue: function() {
			return variables.types[this.etnaType].def;
		},
		fillNode: function(_, node) {
			switch (this.data.TYPPROSYR) {
				case 'ATYPE0':
					// checkbox
					node.$type = 'application/x-boolean';
					break;
				case 'ATYPE1':
					// local menu
					node.$type = 'application/x-choice';
					node.$value = {
						$type: 'application/x-integer',
						$enum: this.supervisor.loadEnum(_, this.data.NOLIB),
					};
					break;
				case 'ATYPE2':
					// some integer
					node.$type = 'application/x-integer';
					break;
				case 'ATYPE3':
					// ATX: translatable text
					node.$type = 'application/x-string';
					node.$maxLength = 30; // LNGTYP is 8! this.data.LNGTYP;
					break;
				case 'ATYPE4':
					node.$type = 'application/x-decimal';
					break;
				case 'ATYPE5':
					// float
					node.$type = 'application/x-real';
					break;
				case 'ATYPE6':
					// double
					node.$type = 'application/x-real';
					break;
				case 'ATYPE7':
					node.$type = 'application/x-string';
					node.$maxLength = this.data.LNGTYP;
					break;
				case 'ATYPE8':
					node.$type = 'application/x-date';
					break;
				case 'ATYPE9':
					node.$type = 'application/x-binary';
					break;
				case 'ATYPE9-1':
					node.$type = 'image';
					//node.$url = "{$baseUrl}/BDOC('C_AUTILIS~%C2%A8~AUSPIC~%C2%A8~AUSPIC~%C2%A8~{USR}~%C2%A8~~%C2%A8~')",
					break;
				case 'ATYPE10':
					node.$type = 'application/x-document';
					break;
				default:
					console.error("UNKNOWN TYPE: " + this.data.TYPPROSYR);
					node.$type = 'application/x-' + this.data.TYPPROSYR;
			}
		},
		targetClass: function(_) {
			if (this.data.CODCLA) return this.supervisor.load(_, 'Class', this.data.CODCLA).init(_);
		},
		maxLength: function() {
			return this.data.LNGTYP;
		},
	}),
	// end of constructor
	fillTypeNode: function(_, superv, data, node) {
		switch (data.CODTYP) {
			case 'A':
				node.$type = 'application/x-string';
				node.$maxLength = data.LONG;
				break;
			case 'C':
				node.$type = 'application/x-integer';
				node.$maxLength = data.LONG;
				break;
			case 'D':
				node.$type = 'application/x-date';
				break;
			case 'DCB':
				node.$type = 'application/x-decimal';
				var l = ("" + data.LONG).split('.');
				var ilen = parseInt(l[0]);
				node.$scale = parseInt(l[1] || 0);
				node.$precision = ilen + node.$scale;
				node.$maxLength = ilen + node.$scale;
				break;
			case 'M':
			case 'MM':
				if (data.NOLIB === 1) {
					node.$type = 'application/x-boolean';
				} else {
					node.$type = 'application/x-choice';
					node.$value = {
						$type: 'application/x-integer',
						$enum: superv.loadEnum(_, data.NOLIB).filter(function(entry) {
							return entry.$title !== '#'; // remove bogus entries in module list
						}),
					};
				}
				break;
			default:
				var typ = superv.load(_, 'Type', data.CODTYP);
				if (!typ) throw console.log(data), new Error("type not found: " + data.CODTYP);
				//node.$debug = typ.data;
				typ.fillNode(_, node);
				break;
		}
	},
};