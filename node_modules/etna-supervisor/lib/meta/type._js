"use strict";

var util = require("etna-supervisor/lib/util");
var date = require("syracuse-core/lib/types/date");
var bcd = require('etna-engine/lib/runtime/bcd');
var uuid = require('etna-engine/lib/runtime/uuid');
var tuuid = require('etna-engine/lib/runtime/tuuid');
var datetime = require("syracuse-core/lib/types/datetime");
var variables = require('etna-engine/lib/runtime/variables');

module.exports = {
	collectionName: 'ATYPE',
	keyName: 'CODTYP',
	constructor: util.defineClass(function(superv, data) {
		this.supervisor = superv;
		this.data = data;
	}, null, {
		init: function(_) {
			return this;
		},
		jsType: {
			get: function() {
				switch (this.data.TYPTYP) {
					case 1:
						// tiny int
						return "number";
					case 2:
						// short integer
						return "number";
					case 3:
						// long integer - was translatable text ???
						return "number";
					case 4:
						return "string";
					case 7:
						return "string";
					case 8:
						// date
						return "date";
					case 10:
						// documnet
						return "object";
					case 11:
						// uuid
						return "binary";
					case 12:
						// datetime
						return "date";
					default:
						throw new Error("NIY type: " + this.data.TYPTYP);
				}
			},
		},
		sqlType: function(colData) {
			var driver = this.supervisor.sqlDriver;
			switch (this.data.TYPTYP) {
				case 1:
					return driver.tinyIntType();
				case 2:
					// short integer
					return driver.shortIntType();
				case 3:
					// translatable text (no column)
					return driver.intType();
				case 4:
					return driver.decimalType();
				case 7:
					return driver.stringType(this.data.LNGTYP || (colData && colData.LONG) || 1020);
				case 8:
					// date
					return driver.dateType();
				case 9:
					return driver.blobType2(); // review
				case 10:
					// document
					return driver.stringType(1020); // see later
				case 11:
					return driver.uuidType();
				case 12:
					return driver.datetimeType();
				default:
					throw new Error("unsupported datatype: " + this.data.TYPTYP + " (" + typeof this.data.TYPTYP + ")");
			}
		},
		etnaType: {
			get: function() {
				switch (this.data.TYPTYP) {
					case 1:
						// tiny int
						return "J";
					case 2:
						// short integer
						return "I";
					case 3:
						// long integer - was translatable text ???
						return "I";
					case 4:
						return "N";
					case 7:
						return "S";
					case 8:
						// date
						return "D";
					case 10:
						// documnet
						return "B";
					case 11:
						// uuid
						return "S";
					case 12:
						// datetime
						return "E";
					default:
						throw new Error("NIY type: " + this.data.TYPTYP);
				}
			}
		},
		convertIn: function(val) {
			switch (this.data.TYPTYP) {
				case 8:
					// date
					return val ? date.fromJsDate(new Date(val)) : null;
				case 12:
					// datetime
					return val ? datetime.fromJsDate(new Date(val)) : null;
				default:
					return val;
			}
		},
		toSql: function(val) {
			var driver = this.supervisor.sqlDriver;
			switch (this.data.TYPTYP) {
				case 4:
					return val ? bcd.toString(val) : "0";
				case 8:
					// date
					return driver.sqlDate(val ? val.toJsDate() : driver.nullDate());
				case 11:
					return driver.sqlUuid(val ? val.toString() : uuid.nullUuidString());
				case 12:
					// datetime
					return driver.sqlDatetime(val ? val.toJsDate() : driver.nullDate());
				default:
					return val === undefined ? null : val;
			}
		},
		fromSql: function(val) {
			var driver = this.supervisor.sqlDriver;
			switch (this.data.TYPTYP) {
				case 1:
				case 2:
				case 3:
					return typeof val === "string" ? parseInt(val, 10) : val;
				case 4:
					return val ? bcd.fromString(val) : null;
				case 8:
					// date
					return driver.fromSqlDate(val);
				case 11:
					return driver.isNullUuid(val) ? tuuid.generate() : tuuid.x3ToUuid(val);
				case 12:
					// datetime
					return driver.fromSqlDatetime(val);
				default:
					return val;
			}
		},
		toSqlQuery: function(val) {
			var driver = this.supervisor.sqlDriver;
			switch (this.data.TYPTYP) {
				case 7:
					return "'" + val + "'";
				case 8:
					return driver.sqlDate(val);
				default:
					return val;
			}
		},
		toJson: function(val) {
			switch (this.data.TYPTYP) {
				case 4:
					return val ? bcd.toString(val) : "0";
				case 8: // date
					return val ? val.x3ToJson() : null;
				case 11: // uuid
				case 12: // datetime
					return val.x3ToString(); //val.toString();
				default:
					return val;
			}
		},
		defaultValue: function() {
			return variables.types[this.etnaType].def;
		},
		fillNode: function(_, data, node) {
			if (this.atypepro === undefined) {
				//VVV var typpro = this.supervisor.load(_, 'Typepro', this.data.TYPPROSYR);
				//VVV if (!typpro) throw console.log(data), new Error("content type not found: " + this.data.TYPPROSYR);
				//VVV this.atypepro = {
				//VVV	protyp : typpro.data.PROTYP,
				//VVV	preflg : typpro.data.PREFLG,
				//VVV	lisflg : typpro.data.LISFLG
				//VVV	};
				var param = this.supervisor.sqlDriver.param;
				var params = [];
				var wheres = [];
				params.push(this.data.TYPPROSYR);
				wheres.push("COD_0=" + param(params.length - 1));
				var sql = "select PROTYP_0,PREFLG_0,LISFLG_0 from ATYPEPRO  where (" + wheres.join(" and ") + ")";
				var self = this;
				var recordset = this.supervisor.sqlDriver.withConnection(_, function(_, cnx) {
					return self.supervisor.sqlReader(_, cnx, sql, params).toArray(_);
				});
				if (recordset) {
					this.atypepro = {
						protyp: recordset[0].PROTYP,
						preflg: recordset[0].PREFLG,
						lisflg: recordset[0].LISFLG
					};
				}
				//console.log(this.data.CODTYP+" "+this.atypepro.protyp);
			}
			node.$type = this.atypepro.protyp;

			if (this.data.NOLIB >= 2) {
				// local menu
				node.$value = {
					$type: 'application/x-integer',
					$enum: this.supervisor.loadEnum(_, this.data.NOLIB),
				};
			}
			switch (this.data.TYPTYP) {
				case 2:
				case 3:
				case 4:
					var lon = 0;
					if (data.LONG >= 0) {
						node.$maxLength = data.LONG;
						lon = data.LONG;
					} else if (this.data.LNGTYP >= 0) {
						node.$maxLength = this.data.LNGTYP;
						lon = this.data.LNGTYP;
					}
					//VVVIf len(ASHW.ASWR(I).UOMPRO)=0
					//VVV Gosub PRO_ADD_SCALE
					//VVVEndif
					if (this.data.TYPTYP === 4 && lon >= 0) {
						var l = ("" + lon).split('.');
						var ilen = parseInt(l[0]);
						node.$scale = parseInt(l[1] || 0);
						node.$precision = ilen + node.$scale;
					}
					break;
				case 7:
					if (this.data.LNGTYP >= 0) {
						node.$maxLength = this.data.LNGTYP;
					} else if (data.LONG >= 0) {
						node.$maxLength = data.LONG;
					}
					break;
			}
		},
		targetClass: function(_) {
			if (this.data.CODCLA) return this.supervisor.load(_, 'Class', this.data.CODCLA).init(_);
		},
		maxLength: function() {
			return this.data.LNGTYP;
		},
	}),
	// end of constructor
	fillTypeNode: function(_, superv, data, node) {
		var typ = superv.load(_, 'Type', data.CODTYP);
		if (!typ) throw console.log(data), new Error("type not found: " + data.CODTYP);
		if (data.NOLIB === 1) {
			node.$type = 'application/x-boolean';
		}
		//Elsif len(ASHW.ASWR(I).UOMPRO)
		// #It's a unit
		//  PROTYPE =func ASYRJSO.TYP('quantity')
		else if (data.CODTYP === 'ATX') {
			node.$type = 'application/x-string';
			node.$maxLength = 30;
		} else {
			typ.fillNode(_, data, node);
		}
		if (data.NOLIB >= 2) {
			node.$value = {
				$type: 'application/x-integer',
				$enum: superv.loadEnum(_, data.NOLIB).filter(function(entry) {
					return entry.$title !== '#'; // remove bogus entries in module list
				}),
			};
		}
	},
};