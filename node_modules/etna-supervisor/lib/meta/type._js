"use strict";

var util = require("etna-supervisor/lib/util") ;
var date = require("syracuse-core/lib/types/date") ;
var bcd = require('etna-engine/lib/runtime/bcd') ;
var tuuid = require('etna-engine/lib/runtime/tuuid') ;
var datetime = require("syracuse-core/lib/types/datetime") ;
var variables = require('etna-engine/lib/runtime/variables');

module.exports = {
	collectionName: 'ATYPE',
	keyName: 'CODTYP',
	constructor: util.defineClass(function(superv, data) {
		this.supervisor = superv;
		this.data = data;
	}, null, {
		init: function(_) {
			return this;
		},
		jsType: {
			get: function() {
				switch (this.data.TYPTYP) {
				case 1:
					// tiny int
					return "number";
				case 2:
					// short integer
					return "number";
				case 3:
					// long integer - was translatable text ???
					return "number";
				case 4:
					return "string";
				case 7:
					return "string";
				case 8:
					// date
					return "date";
				case 10:
					// documnet
					return "object";
				case 11:
					// uuid
					return "binary";
				case 12:
					// datetime
					return "date";
				default:
					throw new Error("NIY type: " + this.data.TYPTYP);
				}
			},
		},
		sqlType: function(colData) {
			var driver = this.supervisor.sqlDriver;
			switch (this.data.TYPTYP) {
			case 1:
				return driver.tinyIntType();
			case 2:
				// short integer
				return driver.shortIntType();
			case 3:
				// translatable text (no column)
				return driver.intType();
			case 4:
				return driver.decimalType();
			case 7:
				return driver.stringType(this.data.LNGTYP || (colData && colData.LONG) || 1020)
			case 8:
				// date
				return driver.dateType();
			case 9:
				return driver.blobType2(); // review
			case 10:
				// document
				return driver.stringType(1020); // see later
			case 11:
				return driver.uuidType();
			case 12:
				return driver.datetimeType();
			default:
				throw new Error("unsupported datatype: " + this.data.TYPTYP + " (" + typeof this.data.TYPTYP + ")");
			}
		},
		etnaType: {
			get : function() {
				switch (this.data.TYPTYP) {
				case 1:
					// tiny int
					return "J";
				case 2:
					// short integer
					return "I";
				case 3:
					// long integer - was translatable text ???
					return "I";
				case 4:
					return "N";
				case 7:
					return "S";
				case 8:
					// date
					return "D";
				case 10:
					// documnet
					return "B";
				case 11:
					// uuid
					return "S";
				case 12:
					// datetime
					return "E";
				default:
					throw new Error("NIY type: " + this.data.TYPTYP);
				}
			}
		},
		convertIn: function(val) {
			switch (this.data.TYPTYP) {
			case 8:
				// date
				return val ? new Date(val) : null;
			case 12:
				// datetime
				return val ? new Date(val) : null;
			default:
				return val;
			}
		},
		toSql: function(val) {
			var driver = this.supervisor.sqlDriver;
			switch (this.data.TYPTYP) {
			case 4 :
				return val ? bcd.toString(val) : "0";
			case 8:
				// date
				return val ? val.toJsDate() : driver.nullDate( ) ;
			case 11 :
				return driver.sqlUuid( val ? val.toString( ) : uuid.nullUuidString( ));
			case 12:
				// datetime
				return val ? val.toJsDate() : driver.nullDate( ) ;
			default:
				return val === undefined ? null : val;
			}
		},
		fromSql: function(val) {
			var driver = this.supervisor.sqlDriver;
			switch (this.data.TYPTYP) {
			case 4 :
				return val ? bcd.fromString( val ) : null ;
			case 8:
				// date
				return driver.isNullDate( val ) ? date.fromJsDate(val) : null;
			case 11 :
				return driver.isNullUuid( val ) ? tuuid.x3ToUuid( val ) : null ;
			case 12:
				// datetime
				return driver.isNullDate( val ) ? datetime.fromJsDate(val) : null;
			default:
				return val;
			}
		},
		defaultValue: function() {
			return variables.types[this.etnaType].def;
		},
		fillNode: function(_, node) {
			switch (this.data.TYPPROSYR) {
			case 'ATYPE0':
				// checkbox
				node.$type = 'application/x-boolean';
				break;
			case 'ATYPE1':
				// local menu
				node.$type = 'application/x-choice';
				node.$value = {
					$type: 'application/x-integer',
					$enum: this.supervisor.loadEnum(_, this.data.NOLIB),
				}
				break;
			case 'ATYPE2':
				// some integer
				node.$type = 'application/x-integer';
				break;
			case 'ATYPE3':
				// ATX: translatable text
				node.$type = 'application/x-string';
				node.$maxLength = 30; // LNGTYP is 8! this.data.LNGTYP;
				break;
			case 'ATYPE4':
				node.$type = 'application/x-decimal';
				break;
			case 'ATYPE5':
				// float
				node.$type = 'application/x-real';
				break;
			case 'ATYPE6':
				// double
				node.$type = 'application/x-real';
				break;
			case 'ATYPE7':
				node.$type = 'application/x-string';
				node.$maxLength = this.data.LNGTYP;
				break;
			case 'ATYPE8':
				node.$type = 'application/x-date';
				break;
			case 'ATYPE9':
				node.$type = 'application/x-binary';
				break;
			case 'ATYPE9-1':
				node.$type = 'image';
				//node.$url = "{$baseUrl}/BDOC('C_AUTILIS~%C2%A8~AUSPIC~%C2%A8~AUSPIC~%C2%A8~{USR}~%C2%A8~~%C2%A8~')",
				break;
			case 'ATYPE10':
				node.$type = 'application/x-document';
				break;
			default:
				console.error("UNKNOWN TYPE: " + this.data.TYPPROSYR);
				node.$type = 'application/x-' + this.data.TYPPROSYR;
			}
		},
		targetClass: function(_) {
			if (this.data.CODCLA) return this.supervisor.load(_, 'Class', this.data.CODCLA).init(_);
		},
		maxLength: function() {
			return this.data.LNGTYP;
		},
	}),
	// end of constructor
	fillTypeNode: function(_, superv, data, node) {
		switch (data.CODTYP) {
		case 'A':
			node.$type = 'application/x-string';
			node.$maxLength = data.LONG;
			break;
		case 'C':
			node.$type = 'application/x-integer';
			node.$maxLength = data.LONG;
			break;
		case 'D':
			node.$type = 'application/x-date';
			break;
		case 'DCB':
			node.$type = 'application/x-decimal';
			var l = ("" + data.LONG).split('.');
			var ilen = parseInt(l[0]);
			node.$scale = parseInt(l[1] || 0);
			node.$precision = ilen + node.$scale;
			node.$maxLength = ilen + node.$scale;
			break;
		case 'M':
		case 'MM':
			if (data.NOLIB === 1) {
				node.$type = 'application/x-boolean';
			} else {
				node.$type = 'application/x-choice';
				node.$value = {
					$type: 'application/x-integer',
					$enum: superv.loadEnum(_, data.NOLIB).filter(function(entry) {
						return entry.$title !== '#'; // remove bogus entries in module list
					}),
				}
			}
			break;
		default:
			var typ = superv.load(_, 'Type', data.CODTYP);
			if (!typ) throw console.log(data), new Error("type not found: " + data.CODTYP);
			//node.$debug = typ.data;
			typ.fillNode(_, node);
			break;
		}
	},
};