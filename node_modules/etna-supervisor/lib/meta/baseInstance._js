"use strict";

var glob = require('streamline/lib/globals');
var util = require("etna-supervisor/lib/util");
var activ = require("etna-supervisor/lib/meta/activ");
var runtime = require('etna-engine/lib/runtime/runtime');
var variables = require('etna-engine/lib/runtime/variables');

var constants = require("etna-supervisor/lib/constants");
var Errors = require("etna-supervisor/lib/errors").Errors;
var Transaction = require("etna-supervisor/lib/transaction").Transaction;

var tracerJs = require("syracuse-trace/lib/helper").getTracer("etna.supervisor");

exports.defineClass = function(constructor, parent, members) {
	// Add base members :
	members.init = function(_) {
		return this;
	};

	// Lazy loading of slots:
	members.slot = function(_, name) {
		if (this.slots[name]) return this.slots[name];
		if (this.properties[name]) {
			this.slots[name] = this.properties[name].createInstance(_, this);
			if (this.record !== undefined) {
				this.slots[name].fromRecord(_, this.record, this.colnIndex);
			}
			return this.slots[name];
		}
	};

	members.sysProperty = function(name) {
		this.sysProperties = this.sysProperties || {};
		if (!this.sysProperties[name]) {
			if (name === 'AERROR') {
				this.sysProperties.AERROR = function(self) {
					return {
						get: function(_) {
							self.errors = self.errors || new Errors(self);
							return self.errors;
						}
					};
				}(this);
			} else if (name === 'ACTX') {
				this.sysProperties.ACTX = {
					get: function(_) {
						return glob.context.x3session.actx;
					}
				};
			} else if (name === 'APARENT') {
				this.sysProperties.APARENT = function(self) {
					return {
						get: function(_) {
							return self.parent;
						}
					};
				}(this);
			} else if (name === 'ASTALIN') {
				this.sysProperties.ASTALIN = function(self) {
					return {
						get: function(_) {
							return self.$astalin;
						}
					};
				}(this);
			} else if (this.clasName && name === this.clasName) {
				this.sysProperties[this.clasName] = function(self) {
					return {
						get: function(_) {
							return self.instance;
						}
					};
				}(this);
			}
		}
		return this.sysProperties[name];
	};
	members.get = function(_, name, raw) {
		tracerJs.debug && tracerJs.debug(this.$$type + " get:" + name);
		var s = this.slot(_, name) || this.sysProperty(name);
		if (s) {
			return s.get(_, raw);
		} else {
			//External attributes ?
			var valattr = this.getAttribute("$" + name);
			if (valattr !== undefined) return variables.x3Val(valattr);
			throw new Error(this.$$type + ".get property not found: " + name);
		}
	};

	members.set = function(_, name, value, raw) {
		tracerJs.debug && tracerJs.debug("instance.set " + name + " value:" + value);
		if (!raw) this.snapshots();
		// Lazy loading of slots:
		var s = this.slot(_, name);
		if (s) s.set(_, value, (raw === undefined) ? false : raw);
		else {
			try {
				//External attributes ?
				this.setAttribute("$" + name, value);
			} catch (e) {
				throw new Error("Cannot set property :" + name);
			}
		}
	};

	members.getPropertyAttribute = function(_, property, attribut) {
		return this.slot(_, property).getAttribute(attribut);
	};

	members.ASETATTRPROP = function(_, property, attribut, value) {
		try {
			return this.setPropertyAttribute(_, property, attribut, value);
		} catch (ex) {
			return constants.CST_AERROR;
		}
	};

	members.AGETATTRIBUTE = function(_, property, attribut) {
		return variables.x3Val(this.getPropertyAttribute(_, property, attribut));
	};

	members.setPropertyAttribute = function(_, property, attribut, value) {
		this.snapshots();
		return this.slot(_, property).setAttribute(attribut, value);
	};

	members.ASETATTRIBUTE = function(_, property, attribut, value) {
		return variables.x3Val(this.setPropertyAttribute(_, property, attribut, value));
	};

	members.setColumnAttribute = function(_, collection, column, attribut, value) {
		var slot = this.slot(_, collection);
		if (slot && slot.setColumnAttribute) return slot.setColumnAttribute(column, attribut, value);
	};

	members.getColumnAttribute = function(_, collection, column, attribut) {
		var slot = this.slot(_, collection);
		if (slot && slot.getColAttribute) return slot.getColAttribute(column, attribut);
	};

	members.scripts = function(_) {
		return this.meta.scripts(_);
	};

	members._actionControl = function(_, operation, type) {
		return this._action(_, ("A" + [operation, "CONTROL", type].join('_')).toUpperCase());
	};

	members._actionBeforeControl = function(_, operation) {
		return this._actionControl(_, operation, "BEFORE");
	};

	members._actionAfterControl = function(_, operation) {
		return this._actionControl(_, operation, "AFTER");
	};

	members.assertDeleteAllowed = function(_) {
		if (0) {
			// TODO AGETWRIGHTD
			throw new util.HttpError(403, this.supervisor.loadMess(_, 139, 327) + " " + this.supervisor.loadMess(_, 139, 328));
		}
	};

	members.withTransaction = function(_, f) {
		var status;
		try {
			this.transaction = new Transaction();
			var status = f(_, this);
		} finally {
			// Rollback the transaction if something goes wrong
			this.transaction.rollback(_);
			this.transaction = undefined;
		}
		return status;
	};

	members.withControl = function(_, f) {
		var status;
		this.deleteErrors(_);

		util.checkInstance(this);

		var isAllowed = this["assert" + f.name + "Allowed"];

		isAllowed && isAllowed(_);

		// Propagate the before  to all elements
		status = this.beforeControl(_, f.name);
		if (status === constants.CST_AERROR) return status;

		// Execute the control
		status = this.executeControl(_, f.name);
		if (status === constants.CST_AERROR) return status;

		// Propagate the after event to all elements
		status = this.afterControl(_, f.name);
		if (status === constants.CST_AERROR) return status;

		// Execute the operation:
		return f(_, this);
	};


	members.AINIT = function(_) {
		tracerJs.debug && tracerJs.debug("baseInstance.AINIT");

		var status = constants.CST_AOK;
		// Raz diagnosis:
		this.deleteErrors(_);

		// init properties :
		if (status = this.propertiesEvent(_, "INIT")) return status;
		if (this.instance && (status = this.instance.propertiesEvent(_, "INIT"))) return status;

		// call AINIT event 
		if (this.instance && (status = this.instance._action(_, "AINIT"))) return status;
		return this._action(_, "AINIT");
	};

	members.propertiesEvent = function(_, action) {
		var status = constants.CST_AOK;
		if (!this.scripts(_)) return status;

		// Temporary disable propagete:
		var properties = this.meta.data.PROPERTIES;
		for (var i = 0; i < properties.length; i++) {
			if (!properties[i].FLDGRP) {
				status = this.runScripts(_, "$PROPERTIES", {
					THIS: {
						type: "LY",
						value: this
					},
					ASTATUS: {
						type: "LI",
						value: constants.CST_AOK
					},
					CURPRO: {
						type: "LS",
						value: properties[i].FLDCLA || properties[i].CODFLD
					},
					ACTION: {
						type: "LS",
						value: action
					}
				});
				if (status) return status;
			}
		}
		return status;
	};

	function addPropertyEvent(action) {
		return function(_, property, oldValue) {
			var args = this.getActionArgs(_, action, null, property);
			if (oldValue) {
				args._AOLDVAL = oldValue;
			}
			var status = this.runScripts(_, "$PROPERTIES", args);
			if (status === constants.CST_AERROR || !this.parent || !this.parent.resourceFactory)
				return status;

			return this.parent.runScripts(_, "$PROPERTIES", args);
		};
	};
	members.setASTALIN = function(status) {
		var parent = this;
		while (parent && parent.$astalin === undefined) {
			//dbg:console.error("************ DBG - updated");
			parent.$astalin = status;
			parent = parent.$parent;
		}
	};

	members.propertyGetValue = addPropertyEvent("GET");
	members.propertyControlValue = addPropertyEvent("CONTROL");
	members.propertyPropagateValueEvent = addPropertyEvent("PROPAGATE");

	members.propertyPropagateValue = function(_, property, oldValue) {
		// Mark the instance as changed :
		this.setASTALIN(constants.CST_AUPD);
		return this.propertyPropagateValueEvent(_, property, oldValue);
	};

	members.addDiagnose = function(_, severity, message) {
		this.diagnoses.push(this.supervisor.new(_, 'Diagnosis', severity, message));
		return severity;
	};

	members.getDiagnoses = function(parent) {
		var self = this;
		var curpth = "";

		return Object.keys(this.slots).reduce(function(r, property) {
			var diags = self.slots[property].getDiagnoses(curpth);
			if (diags) r = r.concat(diags);
			return r;
		}, this.diagnoses.map(function(d) {
			d.PRO = curpth;
			return d;
		}));
	};
	members.$AREAD = function(_) {
		var key = Array.prototype.slice.call(arguments, 1);
		tracerJs.debug && tracerJs.debug("baseInstance.AREAD(" + key + ")");
		util.checkInstance(this);
		//?:this.deleteErrors(_);
		return this.read(_, key);
	};
	members.$AINSERT = function(_) {
		tracerJs.debug && tracerJs.debug("baseInstance.AINSERT(" + this.key + ")");
		return this.withTransaction(_, function(_, self) {
			return self.withControl(_, function Insert(_, self) {
				tracerJs.debug && tracerJs.debug("Insert " + self.key);
				return self.insert(_);
			});
		});
	};
	members.$AUPDATE = function(_) {
		tracerJs.debug && tracerJs.debug("baseInstance.AUPDATE(" + this.key + ")");
		return this.withTransaction(_, function(_, self) {
			return self.withControl(_, function Update(_, self) {
				tracerJs.debug && tracerJs.debug("Update " + self.key);
				return self.update(_);
			});
		});
	};
	members.$ADELETE = function(_) {
		tracerJs.debug && tracerJs.debug("baseInstance.ADELETE(" + this.key + ")");
		return this.withTransaction(_, function(_, self) {
			return self.withControl(_, function Delete(_, self) {
				tracerJs.debug && tracerJs.debug("Delete " + self.key);
				return self.delete(_);
			});
		});
	};

	/* 
	ADDLINE makes it possible to support the legacy syntax :
	  [L]LINE = fmet INS1.ADDLINE("AQCORDL",[V]CST_ALASTPOS)
	which should be replaced now by 
	  [L]LINE = fmet INS1.AQCORDL.AADD([V]CST_ALASTPOS)
	*/
	members.ADDLINE = function(_, collection, position) {
		return this.slot(_, collection).add(_, position);
	};

	/* 
	ADELLINE makes it possible to support the legacy syntax :
	  [L]STATUS = fmet INS1.ADELLINE("AQCORDL",[V]CST_ALASTPOS)
	which should be replaced now by 
	  [L]STATUS = fmet INS1.AQCORDL.ADEL([V]CST_ALASTPOS)
	*/
	members.ADELLINE = function(_, collection, position) {
		return this.slot(_, collection).del(_, position);
	};

	members.ADELETEERROR = function(_, group, property) {
		this.deleteErrors(_, group, property);
	};

	members.ASETERROR = function(_, path, message, severity) {
		// HACK : each time an error is added this.AERRORS is recomputed
		this.errors = undefined;
		// TODO : rechercher pointeur...
		var owner = (path && this.slots[path]) ? this.slots[path] : this;
		return owner.addDiagnose(_, severity, message);
	};

	return util.defineClass(function(superv, data, group) {
		this.supervisor = superv;
		this.data = data;
		this.key = null;
		this.diagnoses = [];
		// Call derived constructor :
		constructor.apply(this, arguments);
	}, parent, members, {
		hasAttributes: true,
		hasSnapshots: true
	});
};