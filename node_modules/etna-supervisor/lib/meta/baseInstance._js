"use strict";

var glob = require('streamline/lib/globals');
var util = require("etna-supervisor/lib/util");
var activ = require("etna-supervisor/lib/meta/activ");
var runtime = require('etna-engine/lib/runtime/runtime');
var variables = require('etna-engine/lib/runtime/variables');
var X3Error = require("etna-engine/lib/runtime/errors").X3Error;
var tuuid = require('etna-engine/lib/runtime/tuuid');

var mapping = require("etna-supervisor/lib/mapping");
var constants = require("etna-supervisor/lib/constants");
var Errors = require("etna-supervisor/lib/errors").Errors;
var Transaction = require("etna-supervisor/lib/transaction").Transaction;
var Snapshot = require("etna-supervisor/lib/snapshot").Snapshot;
var utilRuntime = require('etna-engine/lib/runtime/util');

var tracerJs = require("syracuse-trace/lib/helper").getTracer("etna.supervisor");

exports.defineClass = function(constructor, parent, members) {
	// Add base members :
	members.init = function(_) {
		return this;
	};

	// Lazy loading of slots:
	members.slot = function(_, name) {
		if (this.slots[name]) return this.slots[name];

		if (this.properties[name]) {
			this.slots[name] = this.properties[name].new(_, this);

			if (this.record !== undefined) {
				this.slots[name].fromRecord(_, this.record, this.colnIndex);
			}
			return this.slots[name];
		}
	};

	members.sysProperty = function(name) {
		this.sysProperties = this.sysProperties || {};
		if (!this.sysProperties[name]) {
			if (name === 'AERROR') {
				this.sysProperties.AERROR = function(self) {
					return {
						_get: function(_) {
							self.errors = self.errors || new Errors(_, self);
							return self.errors;
						}
					};
				}(this);
			} else if (name === 'ACTX') {
				this.sysProperties.ACTX = {
					_get: function(_) {
						return glob.context.x3session.actx;
					}
				};
			} else if (name === 'APARENT') {
				this.sysProperties.APARENT = function(self) {
					return {
						_get: function(_) {
							return self.APARENT || null;
						}
					};
				}(this);
			} else if (name === 'ASTALIN') {
				this.sysProperties.ASTALIN = function(self) {
					return {
						_get: function(_) {
							return self.$astalin;
						}
					};
				}(this);
			} else if (this.clasName && name === this.clasName) {
				this.sysProperties[this.clasName] = function(self) {
					return {
						_get: function(_) {
							return self.instance;
						}
					};
				}(this);
			}
		}
		return this.sysProperties[name];
	};
	members._get = function(_, raw) {
		if (this.$lazyLoading) {
			var self = this;
			this.class.loadInstances(_,
				this.$parent,
				mapping.getIndex(_, this.supervisor, this.class.data.dataChildren.ownMapping),
				this.relKeys,
				1,
				function(_, record) {
					self.record = record;
				}).toArray(_);
			this.$lazyLoading = false;
		}
		return this;
	};
	members.get = function(_, name, raw) {
		tracerJs.debug && tracerJs.debug(this.$$type + " get:" + name);
		var s = this.slot(_, name) || this.sysProperty(name);
		if (s) {
			return s._get(_, raw);
		} else {
			//External attributes ?
			var valattr = this.getAttribute("$" + name);
			if (valattr !== undefined) return variables.x3Val(valattr);
			throw new Error(this.$$type + ".get property not found: " + name);
		}
	};

	members.set = function(_, name, value, raw) {
		tracerJs.debug && tracerJs.debug("instance.set " + name + " value:" + value);
		if (!raw) this.snapshots();
		// Lazy loading of slots:
		var s = this.slot(_, name);
		if (s) {
			s._set(_, value, (raw === undefined) ? false : raw);
			return s;
		} else {
			try {
				//External attributes ?
				this.setAttribute("$" + name, value);
			} catch (e) {
				throw new Error("Cannot set property :" + name);
			}
		}
	};
	members.updateProperty = function(from, to) {
		var _this = this;
		Object.keys(_this.slots).some(function(property) {
			if (_this.slots[property] == from) {
				_this.slots[property] = to;
				return true;
			}
			return false;
		});
	};




	members.getPropertyAttribute = function(_, property, attribut) {
		return this.slot(_, property).getAttribute(attribut);
	};

	members.ASETATTRPROP = function(_, property, attribut, value) {
		try {
			return this.setPropertyAttribute(_, property, attribut, value);
		} catch (ex) {
			return constants.CST_AERROR;
		}
	};

	members.AGETATTRIBUTE = function(_, property, attribut) {
		return variables.x3Val(this.getPropertyAttribute(_, property, attribut));
	};

	members.setPropertyAttribute = function(_, property, attribut, value) {
		this.snapshots();
		return this.slot(_, property).setAttribute(attribut, value);
	};

	members.ASETATTRIBUTE = function(_, property, attribut, value) {
		return variables.x3Val(this.setPropertyAttribute(_, property, attribut, value));
	};

	members.setColumnAttribute = function(_, collection, column, attribut, value) {
		var slot = this.slot(_, collection);
		if (slot && slot.setColumnAttribute) return slot.setColumnAttribute(column, attribut, value);
	};

	members.getColumnAttribute = function(_, collection, column, attribut) {
		var slot = this.slot(_, collection);
		if (slot && slot.getColAttribute) return slot.getColAttribute(column, attribut);
	};

	members.scripts = function(_) {
		return this.meta.scripts(_);
	};

	members._actionControl = function(_, operation, type) {
		return this._action(_, ("A" + [operation, "CONTROL", type].join('_')).toUpperCase());
	};

	members._actionBeforeControl = function(_, operation) {
		return this._actionControl(_, operation, "BEFORE");
	};

	members._actionAfterControl = function(_, operation) {
		return this._actionControl(_, operation, "AFTER");
	};

	members.assertDeleteAllowed = function(_) {
		if (0) {
			// TODO AGETWRIGHTD
			throw new util.HttpError(403, this.supervisor.loadMess(_, 139, 327) + " " + this.supervisor.loadMess(_, 139, 328));
		}
	};

	members.withSnapshots = function(_, f) {
		this.snap = new Snapshot(this);
		return f(_, this);
	};

	members.withTransaction = function(_, f) {
		var status;
		try {
			this.transaction = new Transaction();
			var status = f(_, this);
		} finally {
			// Rollback the transaction if something goes wrong
			this.transaction.rollback(_);
			this.transaction = undefined;
		}
		return status;
	};

	members.withControl = function(_, fname, f) {
		var status;
		this.deleteErrors(_);

		util.checkInstance(this);

		var isAllowed = this["assert" + fname + "Allowed"];

		isAllowed && isAllowed(_);

		// Propagate the before  to all elements
		status = this.beforeControl(_, fname);
		if (status === constants.CST_AERROR) return status;

		// Execute the control
		status = this.executeControl(_, fname);
		if (status === constants.CST_AERROR) return status;

		// Propagate the after event to all elements
		status = this.afterControl(_, fname);
		if (status === constants.CST_AERROR) return status;

		// Execute the operation:
		return f(_, this);
	};


	members.AINIT = function(_) {
		tracerJs.debug && tracerJs.debug("baseInstance.AINIT");

		var status = constants.CST_AOK;
		// Raz diagnosis:
		this.deleteErrors(_);

		if (this.snap === undefined) {
			this.snap = new Snapshot(this);
			this.snap && this.snap.enable();
		}
		// init properties :
		if (status = this.propertiesEvent(_, "INIT")) return status;
		if (this.instance && (status = this.instance.propertiesEvent(_, "INIT"))) return status;

		// call AINIT event 
		if (this.instance && (status = this.instance._action(_, "AINIT"))) return status;
		status = this._action(_, "AINIT");

		this.snap && this.snap.disable();
		this.snap && this.snap.enable();
		return status;
	};

	members.propertiesEvent = function(_, action) {
		var status = constants.CST_AOK;
		if (!this.scripts(_)) return status;

		// Temporary disable propagete:
		var properties = this.meta.data.PROPERTIES;
		for (var i = 0; i < properties.length; i++) {
			if (!properties[i].FLDGRP) {
				status = this.runScripts(_, "$PROPERTIES", {
					THIS: {
						type: "LY",
						value: this
					},
					ASTATUS: {
						type: "LI",
						value: constants.CST_AOK
					},
					CURPRO: {
						type: "LS",
						value: properties[i].FLDCLA || properties[i].CODFLD
					},
					ACTION: {
						type: "LS",
						value: action
					}
				});
				if (status) return status;
			}
		}
		return status;
	};

	function addPropertyEvent(action) {
		return function(_, property, oldValue) {
			var args = this.getActionArgs(_, action, null, property);
			if (oldValue) {
				args._AOLDVAL = oldValue;
			}
			var status = this.runScripts(_, "$PROPERTIES", args);
			if (status === constants.CST_AERROR || !this.$parent || !this.$parent.resourceFactory)
				return status;

			return this.$parent.runScripts(_, "$PROPERTIES", args);
		};
	};
	members.setASTALIN = function(status) {
		var parent = this;
		while (parent && parent.$astalin === undefined) {
			//dbg:console.error("************ DBG - updated");
			parent.$astalin = status;
			parent = parent.$parent;
		}
	};

	members.propertyGetValue = addPropertyEvent("GET");
	members.propertyControlValue = addPropertyEvent("CONTROL");
	members.propertyPropagateValueEvent = addPropertyEvent("PROPAGATE");

	members.propertyPropagateValue = function(_, property, oldValue) {
		// Mark the instance as changed :
		this.setASTALIN(constants.CST_AUPD);
		return this.propertyPropagateValueEvent(_, property, oldValue);
	};

	members.deleteDiagnoses = function(_) {
		this.diagnoses = undefined;
	};

	members.addDiagnose = function(_, severity, message, category) {
		this.diagnoses = this.diagnoses || [];
		this.diagnoses.push(this.supervisor.new(_, 'Diagnosis', severity, message, "", category));
		return severity;
	};

	members.getDiagnoses = function(_, sort) {
		var self = this;
		var sortMethod = (sort || "sortOnTime");

		var local = (this.diagnoses || []).map_(_, function(_, d) {
			if (d.get(_, "CPY") === 0) d.set(_, "PRO", "");
			return d;
		});

		return Object.keys(this.slots).reduce_(_, function(_, r, property) {
			var diags = self.slots[property].getDiagnoses(_);
			if (diags) r = r.concat(diags);
			return r;
		}, local).sort(function(d0, d1) {
			return d0[sortMethod](d1);
		});
	};
	members.$AREAD = function(_) {
		var key = Array.prototype.slice.call(arguments, 1);
		tracerJs.debug && tracerJs.debug("baseInstance.AREAD(" + key + ")");
		util.checkInstance(this);
		return this.withSnapshots(_, function Read(_, self) {
			//?:this.deleteErrors(_);
			return self.read(_, key);
		});
	};
	members.$AINSERT = function(_) {
		tracerJs.debug && tracerJs.debug("baseInstance.AINSERT(" + this.key + ")");
		return this.withControl(_, 'Insert', function Insert(_, self) {
			return self.withTransaction(_, function(_, self) {
				tracerJs.debug && tracerJs.debug("Insert " + self.key);
				return self.insert(_);
			});
		});
	};
	members.$AUPDATE = function(_) {
		tracerJs.debug && tracerJs.debug("baseInstance.AUPDATE(" + this.key + ")");
		return this.withControl(_, 'Update', function Update(_, self) {
			return self.withTransaction(_, function(_, self) {
				tracerJs.debug && tracerJs.debug("Update " + self.key);
				return self.update(_);
			});
		});
	};
	members.$ADELETE = function(_) {
		tracerJs.debug && tracerJs.debug("baseInstance.ADELETE(" + this.key + ")");
		return this.withControl(_, 'Delete', function Delete(_, self) {
			return self.withTransaction(_, function(_, self) {
				tracerJs.debug && tracerJs.debug("Delete " + self.key);
				return self.delete(_);
			});
		});
	};

	/* 
	ADDLINE makes it possible to support the legacy syntax :
	  [L]LINE = fmet INS1.ADDLINE("AQCORDL",[V]CST_ALASTPOS)
	which should be replaced now by 
	  [L]LINE = fmet INS1.AQCORDL.AADD([V]CST_ALASTPOS)
	*/
	members.ADDLINE = function(_, collection, position) {
		return this.slot(_, collection).add(_, position);
	};

	/* 
	ADELLINE makes it possible to support the legacy syntax :
	  [L]STATUS = fmet INS1.ADELLINE("AQCORDL",[V]CST_ALASTPOS)
	which should be replaced now by 
	  [L]STATUS = fmet INS1.AQCORDL.ADEL([V]CST_ALASTPOS)
	*/

	members.getSortedDiagnoses = function(_, etype, sort) {

		var self = this;
		sort = sort || "sortOnTime";

		switch (etype) {
			case constants.CST_ACURRENT:
				return Object.keys(self.slots).filter(function(pro) {
					return self.slots[pro].collection === undefined;
				}).reduce_(_, function(_, r, property) {
					var diags = self.slots[property].getDiagnoses(_, sort);
					if (diags) r = r.concat(diags);
					return r;
				}, (self.diagnoses || [])).sort(function(d0, d1) {
					return d0[sort](d1);
				});
			case constants.CST_ALL:
			default:
				return self.getDiagnoses(_, sort);

		}
	},

	members.ADELLINE = function(_, collection, position) {
		return this.slot(_, collection).del(_, position);
	};

	members.ADELETEERROR = function(_, property) {
		var owner = (property && this.slots[property]) ? this.slots[property] : this;
		owner.deleteDiagnoses(_);
		return constants.CST_AOK;
	};

	members.ADELETEERRORALL = function(_) {
		var self = this;
		Object.keys(self.slots).forEach_(_, function(_, p) {
			self.slots[p].deleteDiagnoses(_);
		});
		return constants.CST_AOK;
	};

	members.ASETERROR = function(_, path, message, severity) {
		// HACK : each time an error is added this.AERRORS is recomputed
		//debugger;
		this.errors = undefined;
		// TODO : rechercher pointeur...
		var owner = (path && this.slots[path]) ? this.slots[path] : this;
		return owner.addDiagnose(_, severity, message);
	};


	members.onMapChange = function(_, property, value) {
		return this.slot(_, property)._set(_, value);
	};

	members.ASETERRORCAT = function(_, path, message, severity, category) {
		// HACK : each time an error is added this.AERRORS is recomputed
		this.errors = undefined;
		// TODO : rechercher pointeur...
		var owner = (path && this.slots[path]) ? this.slots[path] : this;
		return owner.addDiagnose(_, severity, message, category);
	};

	members.AGETMAXERROR = function(_) {
		var err = this.getSortedDiagnoses(_, constants.CST_ACURRENT, "sortOnSeverity")[0];
		return err ? err.severity : 0;
	};

	members.AGETMAXERRORALL = function(_) {

		var err = this.getSortedDiagnoses(_, constants.CST_ALL, "sortOnSeverity")[0];
		return err ? err.severity : 0;
	};

	members.AGETERRORSFROM = function(_, iorigin, env) {

		var errc = iorigin.getSortedDiagnoses(_).map_(_, function(_, e) {
			return e.clone(_, env);
		});
		this.diagnoses = (this.diagnoses || []).concat(errc);
		return constants.CST_AOK;
	};

	members.ASEARCHINFOS = function(_, local, property, status, selstatus) {
		var errt = this.getSortedDiagnoses(_, local).filter_(_, function(_, e) {
			var ftr = true;
			if ((local === constants.CST_ACURRENT) && property)
				ftr = ftr && (e.get(_, "PRO") === property);

			switch (selstatus) {
				case 0:
					ftr = ftr && (e.get(_, "STA") <= status);
					break;
				case 1:
					ftr = ftr && (e.get(_, "STA") === status);
					break;
				case 2:
					ftr = ftr && (e.get(_, "STA") > status);
					break;

			};
			return ftr;
		}).map_(_, function(_, e) {
			return e.clone(_);
		});

		this.atabinfos = (errt && errt.length > 0) ? errt : undefined;
		return constants.CST_AOK;
	};

	members.xmetAGETNEXTINFOS = function(_, args) {

		if (this.atabinfos && this.atabinfos.length > 0) {
			var e = this.atabinfos.shift();
			args[0] = e.get(_, "STA"); // ASTATUS
			args[1] = e.get(_, "PRO"); // PROPERTY
			args[2] = e.get(_, "LAB"); // LABEL
			args[3] = e.get(_, "MES"); // MESSAGE
			args[4] = e.get(_, "CAT"); // CATEGORY
			args[5] = e.get(_, "ENV"); // ENVIRONMENT
		} else {
			this.atabinfos = undefined;
			return constants.CST_ANOREC;
		}

		return constants.CST_AOK;
	};

	members.xmetAGETMAXERRORTXT = function(_, args) {

		// args[0] : err_type
		if ([constants.CST_ALL, constants.CST_ACURRENT].indexOf(args[0]) < 0) return new X3Error(69, "ERR_TYPE");

		var err = this.getSortedDiagnoses(_, args[0], "sortOnSeverity")[0];

		if (!err) return constants.CST_ANOREC;

		args[1] = err.get(_, "PRO"); // PROPERTY
		args[2] = err.get(_, "STA"); // ASTATUS
		args[3] = err.get(_, "LAB"); // LABEL
		args[4] = err.get(_, "MES"); // MESSAGE
		args[5] = err.get(_, "CAT"); // CATEGORY
		args[6] = err.get(_, "ENV"); // ENVIRONMENT
		return constants.CST_AOK;
	};

	members.xmethMethods = function(_, name, args) {

		var vals = utilRuntime.instructions.A(args)(_);
		var r = this[name](_, vals);
		for (var i = 0; i < args.length; i++) {
			try {
				// we try on every parameter
				if (Array.isArray(vals[i])) {
					// to do or not to do ?				
				} else
					args[i](_, variables.vOperations.SET, vals[i]);
			} catch (e) {
				if (e.errn !== 62) throw e;
			}
		}
		return r;
	};

	return util.defineClass(function(superv, data, group) {
		this.supervisor = superv;
		this.data = data;
		this.key = null;
		this.diagnoses = [];
		this.$uuid = tuuid.generate();
		// Call derived constructor :
		constructor.apply(this, arguments);
	}, parent, members, {
		hasAttributes: true,
		hasSnapshots: true
	});
};