"use strict";

var glob = require('streamline/lib/globals');
var util = require("etna-supervisor/lib/util");
var activ = require("etna-supervisor/lib/meta/activ");
var runtime = require('etna-engine/lib/runtime/runtime');

var tracerJs = require("syracuse-trace/lib/helper").getTracer("etna.supervisor");

exports.defineClass = function(constructor, parent, members) {
	// Add base members :

	members.AINIT = function(_) {
		return this.action(_, "AINIT");
	};

	members.setStatus = function(_, path, severity, message) {
		this.diagnoses.push(this.supervisor.new(_, 'Diagnosis', severity, path, message));
		return severity;
	};

	members.ASETERROR = function(_, path, message, severity) {
		return this.setStatus(_, path, severity, message);
	};

	members.init = function(_) {
		return this;
	};

	// Lazy loading of slots:
	members.slot = function(_, name) {
		if (this.slots[name]) return this.slots[name];
		if (this.properties[name]) {
			this.slots[name] = this.properties[name].createInstance(this);
			if (this.record !== undefined) {
				this.slots[name].fromRecord(_, this.record, this.colnIndex);
			}
			return this.slots[name];
		}
	};

	members.sysProperty = function(name) {
		this.sysProperties = this.sysProperties || {};
		if (!this.sysProperties[name]) {
			if (name === 'AERROR') {
				this.sysProperties.AERROR = {
					get: function(_) {
						return util.emptyArray();
					}
				};
			} else if (name === 'ACTX') {
				this.sysProperties.ACTX = {
					get: function(_) {
						return glob.context.x3session.actx;
					}
				};
			} else if (name === 'APARENT') {
				this.sysProperties.APARENT = function(self) {
					return {
						get: function(_) {
							return self.parent;
						}
					};
				}(this);
			} else if (this.clasName && name === this.clasName) {
				this.sysProperties[this.clasName] = function(self) {
					return {
						get: function(_) {
							return self.instance;
						}
					};
				}(this);
			}
		}
		return this.sysProperties[name];
	};
	members.get = function(_, name, raw) {
		tracerJs.debug && tracerJs.debug("instance get:" + name);
		var s = this.slot(_, name) || this.sysProperty(name);
		if (s) {
			return s.get(_, raw);
		} else {
			//External attributes ?
			var valattr = this.getAttribute("$" + name);
			if (valattr !== undefined) return variables.x3Val(valattr);
			throw new Error(" get property not found: " + name + JSON.stringify(e));
		}
	};

	members.set = function(_, name, value, raw) {
		tracerJs.debug && tracerJs.debug("instance.set " + name);
		this.snapshots();
		// Lazy loading of slots:
		var s = this.slot(_, name);
		if (s) s.set(_, value, raw);
		else {
			//External attributes ?
			if (this.setAttribute("$" + name, value) !== null) return;
			throw new Error("Cannot set property :" + name);
		}
	};

	members._actionControlBefore = function(_, operation) {
		return this._action(_, [operation, "CONTROL", "BEFORE"].join('_'));
	};

	members._actionControlAfter = function(_, operation) {
		return this._action(_, [operation, "CONTROL", "AFTER"].join('_'));
	};

	members.scripts = function(_) {
		return this.meta.scripts(_);
	};

	members.withControl = function(_, f) {
		var status;
		// Propagate the before  to all elements
		if (status = this.controlBefore(_, f.name)) return status;

		// Execute the operation:
		if (status = f(_)) return status;

		// Propagate the after event to all elements
		if (status = this.controlAfter(_, f.name)) return status;
	};

	return util.defineClass(function(superv, data, group) {
		this.supervisor = superv;
		this.data = data;
		this.key = null;
		this.diagnoses = [];

		// Call derived constructor :
		constructor.apply(this, arguments);
	}, parent, members, {
		hasAttributes: true,
		hasSnapshots: true
	});
};