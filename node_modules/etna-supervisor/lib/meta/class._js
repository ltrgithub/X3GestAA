"use strict";

var util = require("etna-supervisor/lib/util");
var glob = require('streamline/lib/globals');
var utilRuntime = require('etna-engine/lib/runtime/util');
var tuuid = require('etna-engine/lib/runtime/uuid');

var stdMethods = {
	ASETERROR: function(_, path, msg, severity) {
		util.checkInstance(this);
		this.diagnoses.push(this.supervisor.new(_, 'Diagnosis', severity, path, msg));
		return severity;
	},
	AINIT: function(_) {
		util.checkInstance(this);
		return this.ainit(_);
	},
	AREAD: function(_) {
		util.checkInstance(this);
		var key = Array.prototype.slice.call(arguments, 1);
		return this.read(_, key);
	},
	AINSERT: function(_) {
		util.checkInstance(this);
		this.insert(_);
		return 0;
	},
	AUPDATE: function(_) {
		util.checkInstance(this);
		this.update(_);
		return 0;
	},
	ADELETE: function(_) {
		util.checkInstance(this);
		this.delete(_);
		return 0;
	},
};

module.exports = {
	collectionName: 'ACLASSE',
	keyName: 'CODCLA',
	constructor: util.defineClass(function(superv, data, group) {
		this.supervisor = superv;
		this.data = data;
		this.collections = {};
		this.scripts = [];
		this.methods = {};
		this.keyItems = data.KEYINT ? data.KEYINT.split('+') : [];
		this.group = group;
	}, null, {
		init: function(_) {
			if (this.properties) return this;
			var tableCode = this.data.TABREF || this.data.CODCLA;
			//if (this.data.TYPCLA !== 5 && this.data.TYPCLA !== 99) {
			if (this.data.TYPCLA === 2) { // 2 for persistent class
				this.table = this.table || this.supervisor.load(_, 'Table', tableCode);
				if (!this.table) throw new Error("table not found: " + tableCode);
			} else if (this.data.table) {
				this.table = this.data.table;
			}
			this.properties = {};
			this.data.PROPERTIES.forEach_(_, function(_, propData) {
				if ((this.group || "") !== ((!propData.LNKCLA && propData.FLDGRP) || "")) return;
				var name = propData.FLDCLA;
				if (this.properties[name]) throw new Error("duplicate property " + name);
				this.properties[name] = this.supervisor.new(_, 'Property', this, propData);
			}, this);
			this.addPropTech(_);
			this.collections = {};
			this.data.COLLECTIONS.forEach_(_, function(_, data) {
				var coln = this.collections[data.CODCOL] = this.supervisor.new(_, 'Collection', this, data);
				var name = data.CODCOL;
				var p = this.properties[name];
				if (!p) {
					p = this.properties[name] = this.supervisor.new(_, 'Property', this, name);
					p.collection = coln;
					// generate synthetic class for group of indexed properties
					coln.class = this.supervisor.new(_, "Class", {
						CODCLA: this.data.CODCLA + "." + name,
						TYPCLA: 5,
						PROPERTIES: this.data.PROPERTIES.filter(function(propData) {
							return propData.FLDGRP === name;
						}),
						COLLECTIONS: [],
						table: this.table
					}, name);
				} else {
					p.collection = coln;
					var mapping = util.find(this.data.LINKS, 'REFLNK', name);
					var targetName;
					if (mapping) {
						coln.mappingData = mapping;
						targetName = mapping.CLALNK;
					} else {
						targetName = p.data.LNKCLA;
					}
					if (!targetName) throw new Error("cannot find target name for collection " + name);
					coln.class = this.supervisor.load(_, 'Class', targetName);
					if (!coln.class) throw new Error("target class missing for collection " + name);
				}
			}, this);
			if (this.data.CODTRT) {
				this.scripts = this.data.CODTRT.map_(_, function(_, codtrt) {
					return this.supervisor.loadScript(_, codtrt);
				}, this);
			}
			return this;
		},
		name: {
			get: function() {
				return this.data.CODCLA;
			}
		},
		method: function(name) {
			return this.methods[name] || stdMethods[name];
		},
		collection: function(name) {
			var coln = this.collections[name];
			if (!coln) throw new Error("collection not found: " + name);
			return coln;
		},
		property: function(name) {
			var prop = this.properties[name];
			if (!prop) throw new Error("prop not found: " + this.name + "." + name);
			return prop;
		},
		addPropTech: function(_) {
			var wprops = [{
				"FLDCLA": "ASTALIN",
				"CODTYP": "C",
				"LONG": 4
			}, {
				"FLDCLA": "_AFCRIGHT",
				"CODTYP": "A",
				"LONG": 30
			}];
			wprops.forEach_(_, function(_, wprop) {
				var name = wprop.FLDCLA;
				if (this.properties[name]) throw new Error("duplicate property " + name);
				this.properties[name] = this.supervisor.new(_, 'Property', this, wprop);
			}, this);
		},
		invokeScripts: function(_, instance, action, $curpro, $curpth, values) {
			// , instance, action, name
			var curpro = $curpro || "";
			var curpth = $curpth || "";

			var astatus = this.supervisor.constants.CST_AOK;

			this.scripts.forEach_(_, function(_, script) {
				var handler = (curpro === "") ? script.METHODS : script.PROPERTIES;

				if (!handler || astatus) return;
				var frame = glob.context.x3frame;

				var prev = frame;
				var cx = prev.context;
				glob.context.x3frame = frame = {
					values: {},
					types: {},
					context: cx,
					prev: prev,
					loopLevel: 0,
					loc: {
						file: module.id,
						line: 0
					}
				};
				// current sub is the prog itself
				frame.sub = frame;
				frame.dicts = [frame, cx.globals, cx.sys];
				try {
					util.declVar(frame, 'CURPRO', 'LS', curpro);
					util.declVar(frame, 'CURPTH', 'LS', curpth);
					util.declVar(frame, 'ACTION', 'LS', action);
					util.declVar(frame, 'THIS', 'LY', instance);
					util.declVar(frame, 'ASTATUS', 'LI', 0);

					for (var v = 0; values !== undefined && v < values.length; v++) {
						util.declVar(frame, values[v].name, 'L' + values[v].name, values[v].value);
					};
					handler(_);
					astatus = frame.values.ASTATUS;
				} finally {
					glob.context.x3frame = prev;
				}
			}, this);
			return astatus;
		},
		keyExpression: function(_) {
			var table = this.table;
			return table ? table.indexes[0].keyExpression(_) : "{" + this.data.KEYINT + "}";
		},
		createInstance: function(_, qs) {
			var now = new Date();
			var properties = {
				//TODO : AUUID: new tuuid.UUID(),
				UPDDATTIM: now,
				CREDATTIM: now,
				ACTX: this.supervisor.currentContext(_),
				AERROR: util.emptyArray(),
			};
			return this.supervisor.new(_, 'Instance', this, null, properties).afterCreate(_);
		},
		loadInstance: function(_, key, qs) {
			var table = this.table;
			var index = table.indexes[0];
			var instances = this.loadInstances(_, index, key.split('~'), 1);
			if (instances.length === 0) throw new util.HttpError(404, "instance not found: " + this.name + "('" + key + "')");
			return instances[0];
		},
		loadInstances: function(_, index, vals, max) {
			var table = this.table;
			return table.loadRecords(_, index, vals, max).map_(_, function(_, data) {
				return this.supervisor.new(_, 'Instance', this, null).fromRecord(_, data);
			}, this);
		},
		sqlReader: function(_, cnx, index, vals, where, raw) {
			var properties = this.properties;
			var param = this.supervisor.sqlDriver.param;
			var tableNames = [this.table.name + ' T'];
			var columnNames = [];
			var wheres = where && where.sql ? [where.sql] : [];
			var params = where && where.sql ? where.params.slice(0) : [];

			/*dbg*/ //console.log("reader columns...");
			Object.keys(properties).forEach_(_, function(_, name) {
				/*dbg*/ //console.log("properties["+name+"].getSql()");
				properties[name].getSql(_, columnNames, tableNames, wheres, params, null, raw);
			});

			var indexColNames;
			if (index) {
				indexColNames = index.sqlNames(_);
				var indexCols = indexColNames.slice(0, vals.length);
				indexCols.forEach(function(name, i) {
					params.push(vals[i]);
					wheres.push(name + "=" + param(params.length - 1));
				}, this);
			}
			var sql = "select " + columnNames.join(',') + " from " + tableNames.join(',');
			if (wheres.length) sql += " where (" + wheres.join(') and (') + ')';
			if (index) sql += " order by " + indexColNames;

			/*dbg*/ //console.log("\nreader sql:"+sql);
			/*dbg*/ //console.log("\nreader params:"+JSON.stringify(params));
			return this.supervisor.sqlReader(_, cnx, sql, params);
		},
		index: {
			get: function() {
				if (this._index === undefined) {
					var index = this.table.indexes[0];
					this._index = [];
					var _this = this;
					Object.keys(index.columns).forEach(function(c) {
						_this._index.push(_this.properties[index.columns[c].name]);
					});
				}
				return this._index;
			}
		},
		fromRecordMapper: function(instance, params) {
			return function(_, record) {
				if (!instance) instance = this.supervisor.new(_, 'Instance', this, null);
				this.invokeScripts(_, instance, "AREAD_BEFORE", "", "", params);
				instance.fromRecord(_, record);
				var astatus = this.invokeScripts(_, instance, "AREAD_AFTER", "", "", params);
				// TODO: check astatus
				return instance;
			}.bind(this);
		},
		ainit: function(_, instance) {
			return this.invokeScripts(_, instance, "AINIT");
		},
		read: function(_, instance, key) {
			var _this = this;
			var table = this.table;
			var index = table.indexes[0];

			var params = [];
			Object.keys(_this.index).forEach(function(i) {
				params.push({
					name: _this.index[i].name,
					type: _this.index[i].etnaType,
					value: key[i]
				});
			});

			//TODO : instance.properties.AUUID.set(_,tuuid.generate(),true);
			//var astatus = instance.supervisor.constants.CST_AERROR;
			var mapper = this.fromRecordMapper(instance, params);
			var instances = this.supervisor.sqlDriver.withConnection(_, function(_, cnx) {
				return _this.sqlReader(_, cnx, index, key).limit(1).map(mapper).toArray(_);
			});
			if (!instances || !instances.length) return instance.supervisor.constants.CST_AERROR;
			return instance.supervisor.constants.CST_AOK;
		},
		reader: function(_, cnx, index, vals, where, raw) {
			return this.sqlReader(_, cnx, index, vals, where, raw).map(this.fromRecordMapper());
		},
	}),
};