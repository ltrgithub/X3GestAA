"use strict";

var ez = require("ez-streams");
var util = require("etna-supervisor/lib/util");
var glob = require('streamline/lib/globals');
var utilRuntime = require('etna-engine/lib/runtime/util');
var tuuid = require('etna-engine/lib/runtime/uuid');
var tdate = require('etna-engine/lib/runtime/tdate');
var tdatetime = require('etna-engine/lib/runtime/tdatetime');
var variables = require('etna-engine/lib/runtime/variables');
var activ = require("etna-supervisor/lib/meta/activ");
var filterHelpers = require("syracuse-orm/lib/filters");
var constants = require("etna-supervisor/lib/constants");
var utilDriver = require("etna-engine/lib/drivers/util");
var baseClass = require("etna-supervisor/lib/meta/baseClass");
var type = require("etna-supervisor/lib/meta/type");
var newInstanceProperty = require("etna-supervisor/lib/instanceProperty").newInstanceProperty;
var newInstanceReference = require("etna-supervisor/lib/InstanceReference").newInstanceReference;
var newInstanceCollection = require("etna-supervisor/lib/instanceCollection").newInstanceCollection;
var newInstance = require("etna-supervisor/lib/meta/instance").newInstance;

var trim = utilDriver.trim;

var tracerJs = require("syracuse-trace/lib/helper").getTracer("etna.supervisor");
var cacheMethods = require('etna-supervisor/lib/builtins/ACTXCACHE').cacheMethods;

function bulkWriter(httpContext) {
	var sep;
	return ez.devices.generic.writer(function(_, resource) {
		if (!sep) {
			httpContext.response.writeHead(200, {
				"content-type": "application/json"
			});
			httpContext.response.write(_, '[');
		}
		if (resource === undefined) {
			httpContext.response.end("]");
		} else {
			httpContext.response.write(_, (sep || '') + JSON.stringify(resource.dataNode(_)), "utf8");
		}
		sep = ',';
	});
};

var typDonmet2EtnaType = {
	1: "D",
	2: "S",
	3: "I",
	4: "N",
	5: "T",
	6: "B"
};

module.exports = {
	collectionName: 'ACLASSE',
	keyName: 'CODCLA',
	constructor: baseClass.defineClass(function(superv, data, group) {
		this.relations = {};
		this.parent = null;
		this.keyItems = data.KEYINT ? data.KEYINT.split('+') : [];
		this.group = group;
		this.cache = {};
		this.curpath = "";
		this.codclaPath = this.data.CODCLA;
		this.class = this;
		if (this.data.PARAM_DEFS) {
			this.data.PARAM_DEFS = this.data.PARAM_DEFS.sort(function(ep1, ep2) {
				var info1 = ep1.CODE + "_" + (ep1.TYPKEY === 2 ? "A" : "B") + ep1.NOPAR;
				var info2 = ep2.CODE + "_" + (ep2.TYPKEY === 2 ? "A" : "B") + ep2.NOPAR;
				if (info1 < info2) return -1;
				if (info1 > info2) return 1;
				return 0;
			});
		}

		// Default behaviors
		this.reader = this.sqlReader;
		this.read = this.sqlRead;
	}, null, {
		$$type: {
			get: function() {
				return "Class";
			}
		},
		init: function(_) {
			var self = this;

			if (this.properties) return this;
			if (this.data.dataChildren) {
				if (this.data.dataChildren.ownMapping) {
					this.data.table = this.supervisor.load(_, 'Table', this.data.dataChildren.ownMapping.TABLNK);
					this.data.LINKS = this.data.dataChildren.LINKS;
					this.data.MAPS = this.data.dataChildren.MAPS;
				}
				this.data.codclaPath = this.data.dataChildren.codclaPath;
				this.parent = this.data.dataChildren.parent;
				this.curpath = this.data.dataChildren.curpath;
			}
			tracerJs.debug && tracerJs.debug("Init de  C_" + this.data.CODCLA + " " + this.curpath);
			if (this.parent) tracerJs.debug && tracerJs.debug(" parent = '" + this.parent.data.CODCLA + "'");
			var tableCode = this.data.TABREF || this.data.CODCLA;
			tracerJs.debug && tracerJs.debug("class this.data.TYPCLA:" + this.data.TYPCLA + "--" + this.data.CODCLA);
			var jsInterface;
			try {
				jsInterface = require("etna-supervisor/lib/builtins/" + this.data.CODCLA);
			} catch (e) {} finally {}

			if (jsInterface && jsInterface.AQUERY) {
				this.reader = this.jsReader;
				this.jsInterface = jsInterface;
			}
			if (this.data.TYPCLA === 2) { // 2 for persistent class
				this.table = this.table || this.supervisor.load(_, 'Table', tableCode);
				if (!this.table) throw new Error("table not found: " + tableCode);
			} else if (this.data.table) {
				this.table = this.data.table;
			}

			if (this.data.TYPCLA === 5) {
				// This class is an interface
				this.read = this.intRead;
			}

			this.properties = [{
				"FLDCLA": "ASTALIN",
				"CODTYP": "C",
				"LONG": 4
			}, {
				"FLDCLA": "AORDER",
				"CODTYP": "C",
				"LONG": 4
			}, {
				"FLDCLA": "_AFCRIGHT",
				"CODTYP": "A",
				"LONG": 30
			}].concat(this.data.PROPERTIES)
				.reduce_(_, function(_, r, propData) {
					if (!((self.group || "") !== ((!propData.LNKCLA && propData.FLDGRP) || ""))) {
						var name = propData.FLDCLA;

						tracerJs.debug && tracerJs.debug("Property : " + name);

						if (r[name]) throw new Error("duplicate property " + name);
						r[name] = self.supervisor.new(_, 'Property', self, propData, newInstanceProperty);

						if (r[name].isReference(_)) {
							// Add a property :
							tracerJs.debug && tracerJs.debug(name + " is a reference");
							name += '_REF';
							r[name] = self.supervisor.new(_, 'Property', self, propData, newInstanceReference);
							r[name].isReference(_, true);
						} else if (propData.OBLIG === 2) {
							self.mandatoryProperties = self.mandatoryProperties || [];
							self.mandatoryProperties.push(name);
						}
					}
					return r;
				}, {}, this);

			this.relations = {};
			this.data.COLLECTIONS.forEach_(_, function(_, data) {
				tracerJs.debug && tracerJs.debug("Class collection:" + data.CODCOL);
				var coln = self.relations[data.CODCOL] = self.supervisor.new(_, 'Collection', this, data);

				var name = data.CODCOL;
				var p = self.properties[name];
				if (!p) {
					self.relations[name] = coln;
					p = self.properties[name] = self.supervisor.new(_, 'Property', self, {
						FLDCLA: name
					}, newInstanceCollection, coln);

					// generate synthetic class for group of indexed properties
					coln.ofIndexedProperties = true;
					coln.class = self.supervisor.new(_, 'Class', {
						CODCLA: self.data.CODCLA + "." + name,
						TYPCLA: 1, //5,
						PROPERTIES: self.data.PROPERTIES.filter(function(propData) {
							return propData.FLDGRP === name;
						}),
						PARAM_FLDS: self.data.PARAM_FLDS,
						COLLECTIONS: [],
						table: self.table
					}, name);
					//Calculate count
					if (data.ACTGRP & data.ACTGRP !== "") {
						var activ = self.supervisor.load(_, 'Activ', data.ACTGRP);
						coln.count = activ.dimension;
					} else if (data.MAXCOL > 0) {
						coln.count = data.MAXCOL;
					}
					if (!coln.count) {
						coln.count = 1;
						coln.class.data.PROPERTIES.forEach_(_, function(_, propData) {
							if (coln.class.table) {
								var col = util.find(coln.class.table.data.COLUMNS, 'CODZONE', propData.FLDCLA);
								if (col) {
									var dime = 0;
									if (col.CODACT & col.CODACT !== "") {
										var activcol = self.supervisor.load(_, 'Activ', col.CODACT);
										dime = activcol.dimension;
									}
									dime = Math.max(dime, col.DIME);
									coln.count = Math.max(dime, coln.count);
								}
							}
						});
					}
					//
					coln.class.parent = this;
					if (coln.class.data.PROPERTIES) {
						coln.class.data.PROPERTIES.forEach_(_, function(_, prop) {
							if (coln.class.data.PARAM_FLDS) {
								coln.class.data.PARAM_FLDS.forEach_(_, function(_, fld) {
									if (fld.FLDCLA === prop.FLDCLA && fld.VALEUR) {
										if (name + "." === fld.VALEUR.substring(0, name.length + 1)) {
											fld.VALEUR = fld.VALEUR.substring(name.length + 1);
										}
									}
								}, name, prop);
							}
						}, name);
					}
				} else {
					//mapping can be on main class
					var wcurpath = name;
					var wcurcla = this;
					while (wcurcla.data.TYPCLA !== 2 && wcurcla.parent) {
						wcurpath = self.curpath + "." + wcurpath;
						wcurcla = wcurcla.parent;
					}
					var mapping = wcurcla.data.LINKS && util.find(wcurcla.data.LINKS, 'REFLNK', wcurpath);

					var targetName;
					var targetTable;
					if (mapping) {
						mapping.MAPS = [];
						if (wcurcla.data.MAPS) {
							mapping.MAPS = wcurcla.data.MAPS.filter(function(map) {
								return map.REFLNK === wcurpath;
							});

							// Memorize maps at the propeties level
							mapping.MAPS
								.filter(function(map) {
									return map.PROMAP !== undefined && map.KEYMAP !== undefined;
								})
								.forEach(function(map) {
									self.properties[map.PROMAP].proMaps = self.properties[map.PROMAP].proMaps || [];
									self.properties[map.PROMAP].proMaps.push(map);
								});
						}

						coln.mappingData = mapping;

						targetName = mapping.CLALNK;
					} else {
						targetName = p.data.LNKCLA;
					}

					if (!targetName) throw new Error("cannot find target name for collection " + name);
					tracerJs.debug && tracerJs.debug("coln.mappingData  " + JSON.stringify(coln.mappingData));

					var clas = self.supervisor.load(_, 'Class', self.codclaPath + "." + targetName, {
						ownMapping: coln.mappingData,
						//normally not needed LINKS: self.data.LINKS, // inherith from LINKS defined at the top level
						//normallynot needed MAPS: self.data.MAPS, // inherith from MAPS defined at the top level
						codclaPath: self.codclaPath + "." + targetName,
						curpath: name, //(self.curpath) ? self.curpath + "." + name : name
						parent: self,
					});
					if (!clas) throw new Error("target class missing for collection " + name);

					coln.class = clas;
					if (coln.mappingData && coln.mappingData.TYPLNK === 3) {
						// relation = class <-> class (replace p:)
						tracerJs.debug && tracerJs.debug(self.codclaPath + "." + name + " is a class");

						self.properties[name] = self.supervisor.new(_, 'Property', self, {
							FLDCLA: name
						}, newInstance, coln);
					} else {
						self.properties[name] = self.supervisor.new(_, 'Property', self, {
							FLDCLA: name
						}, newInstanceCollection, coln);
					}
				}
			}, this);

			this.stdMethods = this.data.STD_METHODS ? this.data.STD_METHODS.reduce_(_, function(_, r, method) {
				if (method.ENAMETSTD === 2 && activ.getActiv(_, self.supervisor, method.ACTMETSTD) > 0) {
					switch (method.CODMETSTD) {
						case 'C':
							r.AINSERT = method;
							break;
						case 'R':
							r.AREAD = method;
							break;
						case 'U':
							r.AUPDATE = method;
							break;
						case 'D':
							r.ADELETE = method;
							break;
					}
				}
				return r;
			}, {}) : {};

			this.methods = this.data.METHODS ? this.data.METHODS.reduce_(_, function(_, r, method) {
				var nbKeys = 0;
				var nbParam = 0;
				r[method.CODMET] = self.data.PARAM_DEFS ? self.data.PARAM_DEFS
					.filter(function(param) {
						return param.CODE === method.CODMET;
					})
					.reduce_(_, function(_, r, param) {
						nbParam++;
						if (param.TYPKEY === 2) nbKeys++;
						r[param.CODPAR] = {
							type: "L" + type.typTyp2EtnaType[param.TYPINTPAR],
							get: function(nopar) {
								return function(args) {
									return ((args && args[nopar - 1]) ? args[nopar - 1] : variables.types[type.typTyp2EtnaType[param.TYPINTPAR]].default);
								};
							}((param.TYPKEY === 2 ? 0 : nbKeys) + param.NOPAR),
						};
						if (param.MODPAR === 1) { ///1:variable arg 2:value arg 3:constant
							r[param.CODPAR].set = function(nopar) {
								return function(_, args, value) {
									var arg = args[nopar - 1];
									arg(_, variables.vOperations.SET, value);
									return arg[nopar - 1];
								};

							}((param.TYPKEY === 2 ? 0 : nbKeys) + param.NOPAR);
						}
						return r;
					}, {}) : {};
				r[method.CODMET]["ARET_VALUE"] = {
					type: "L" + typDonmet2EtnaType[method.DONMET],
					get: function(nopar) {
						return function(args) {
							return variables.types[typDonmet2EtnaType[method.DONMET]].default;
						};
					}(nbParam),
					set: function(nopar) {
						return function(_, args, value) {
							return value;
						};
					}(nbParam),
				};
				return r;
			}, {}) : {};

			// Add cache methods to the class if necessary 
			if (this.data.FLGBUFFER === 2) {
				Object.keys(cacheMethods).forEach(function(method) {
					self[method] = cacheMethods[method];
				});
			}
			return this;
		},
		/* 
		Add methods to an instance
		*/
		addMethods: function(instance) {
			var self = this;
			Object.keys(this.stdMethods).forEach(function(stdMethod) {
				instance[stdMethod] = instance["$" + stdMethod];
			});

			var xmeth = function(clas, method) {
				return function(_) {
					var args = (Array.prototype.slice.call(arguments).length > 0) ? Array.prototype.slice.call(arguments).slice(1) : [];

					var meth = self.methods[method];
					var xmethName = "xmet" + method;
					if (instance[xmethName]) {
						return instance["xmethMethods"](_, xmethName, args);
					}

					// Get arguments values :
					var vals = utilRuntime.instructions.A(args)(_);
					var methArgs = Object.keys(meth).reduce(function(r, p) {
						r[p] = {
							type: meth[p].type,
							value: meth[p].get(vals)
						};
						if (meth[p].set) r[p].set = meth[p].set;
						return r;
					}, {
						ACTION: {
							type: "LS",
							value: method
						},
						THIS: {
							type: "LY",
							value: this
						}
					});
					var status = this.runScripts(_, "$METHODS", methArgs);
					// Manage variable arguments :
					var retValue;
					Object.keys(meth).forEach_(_, function(_, arg) {
						if (meth[arg].set) {
							if (arg !== "ARET_VALUE") meth[arg].set(_, args, methArgs[arg].value);
							else retValue = meth[arg].set(_, args, methArgs[arg].value);
						}
					});
					if (retValue === undefined) return status;
					else return retValue;
				};
			};

			instance.methods["xmetAGETMAXERRORTXT"] = xmeth(self, "AGETMAXERRORTXT");

			Object.keys(this.methods).forEach(function(method) {
				instance.methods = instance.methods || {};
				instance.methods["xmet" + method] = xmeth(self, method);
			});
		},
		isSearchable: {
			get: function() {
				return this.data && this.data.FLGSEARCH && (this.data.FLGSEARCH === 2);
			}
		},
		name: {
			get: function() {
				return this.data.CODCLA;
			}
		},
		property: function(name) {
			var prop = this.properties[name];
			if (!prop) throw new Error("prop not found: " + this.name + "." + name);
			return prop;
		},
		check: function(_, facet) {
			if (!this.isActivated(_))
				throw new util.HttpError(406, this.supervisor.loadMess(_, 140, 31) + ' ' + this.data.CODCLA + " (" + this.data.CODACT + ")");
			if (facet && /^\$(search|bulk|query|lookup|details|summary|edit)$/.test(facet)) {
				if (!this.stdMethods.AREAD) throw new util.HttpError(406, this.supervisor.loadMessParams(_, 149, 31, this.supervisor.loadMess(_, 7983, 7), this.data.CODCLA));
				if (facet === "$edit" && !this.stdMethods.AINSERT && !this.stdMethods.AUPDATE) {
					throw new util.HttpError(406, this.supervisor.loadMessParams(_, 149, 32, this.supervisor.loadMess(_, 7983, 1), this.supervisor.loadMess(_, 7983, 10), this.data.CODCLA));
				}
			}
		},
		keyExpression: function(_) {
			var table = this.table;
			return table ? table.indexes[0].keyExpression(_) : "{" + this.data.KEYINT + "}";
		},
		createInstance: function(_, qs) {
			return this.supervisor.new(_, 'Instance', this).afterCreate(_);
		},
		loadInstance: function(_, parent, key, qs) {
			var table = this.table;
			var index = table.indexes[0];
			var instances = this.loadInstances(_, parent, index, key.split('~'), 1).toArray(_);
			if (instances.length === 0) throw new util.HttpError(404, "instance not found: " + this.name + "('" + key + "')");
			return instances[0];
		},
		queryExpToSelect: function(_, exp, params, tableNames) {
			var self = this;
			var map = {
				'$eq': '=',
				'$ne': '!=',
				'$gt': '>',
				'$gte': '>=',
				'$lt': '<',
				'$lte': '<=',
				'$regex': 'like'
			};
			var param = this.supervisor.sqlDriver.param;

			return Object.keys(exp).reduce_(_, function(_, r, prop) {
				var id = prop;
				var expColumn = function(column) {
					return column;
				};

				var match = id.match(/upper\((\w*)\)/);
				if (match) {
					id = match[1];
					expColumn = function(column) {
						return 'UPPER(' + column + ')';
					};
				}
				if (!self.properties[id]) throw new Error("Property " + id + " missing for class " + self.name);
				var column = self.properties[id].column.sqlName();

				var propExp = exp[prop];

				var hasExp = (typeof propExp === 'object' && propExp !== null) && Object.keys(propExp).some(function(key) {
					return (key.charAt(0) === '$');
				}) || false;

				var operators = hasExp ? propExp : {
					$eq: propExp
				};

				r.push(Object.keys(operators).reduce(function(r, operator) {
					if (map[operator]) {
						var sqlOperator = map[operator];
						var value = operators[operator];
						var valueType = typeof value;

						if (value === null || (Array.isArray(value) && !value.length)) return r;

						if (valueType === 'boolean') {
							value = value ? 2 : 1;
						} else if (self.properties[id].etnaType === 'D' && (valueType === 'string')) {
							value = new Date(value);
						} else if (self.properties[id].etnaType === 'E') {
							value = tdatetime.x3Parse(value).toJsDate();
						} else if (sqlOperator === 'like') {
							if (value.charAt(0) === '^') value = value.substring(1);
							else value = '%' + value;
							value = value.replace(/\.\*/g, '%');
						}
						params.push(value);
						r.push(expColumn(column) + ' ' + sqlOperator + ' ' + param(params.length - 1));
					}
					return r;
				}, []).join(" and "));
				return r;
			}, []).join(" and ");
		},
		queryToSelect: function(_, query, params) {
			var operator = (query.$or) ? "or" : (query.$and ? "and" : undefined);
			if (operator) {

				var self = this;
				return query['$' + operator].reduce_(_, function(_, r, exp) {
					var select = self.queryToSelect(_, exp, params);
					if (select.length) r.push('(' + select + ')');
					return r;
				}, []).join(' ' + operator + ' ');
			}
			return this.queryExpToSelect(_, query, params);
		},
		queryInstances: function(_, select, max) {
			return this.reader(_, null, select, max, null);
		},
		sqlReader: function(_, parent, select, max, $recordMapper) {
			tracerJs.debug && tracerJs.debug("class.sqlReader:" + JSON.stringify(select));

			tracerJs.debug && tracerJs.debug(this.table.name + "   " + "class.sqlReader(" + max + "):" + JSON.stringify(select));
			var self = this;
			var recordMapper = $recordMapper || function() {
					return function(_, record) {
						var astatus;
						var instance = self.supervisor.new(_, 'Instance', self, parent).afterCreate(_, record);
						return instance;
					};
				}();

			var orderBy;
			var descs = [];
			var columnNames = [];
			var wheres = [];
			var params = [];
			var properties = this.properties;
			var param = this.supervisor.sqlDriver.param;
			tracerJs.debug && tracerJs.debug("this.table = " + JSON.stringify(this.table.name));
			var tableNames = [this.table.name + ' T'];
			var sqlOpts = {};

			// add link with ACCES if ACCSTR is filled.
			if (this.data.ACCSTR) {
				tracerJs.debug && tracerJs.debug("add ACCSTR " + this.data.ACCSTR);
				tableNames.push("ACCES ACC");

				params.push(glob.context.x3session.actx.$USER(_));
				wheres.push("ACC.USR_0 = " + param(params.length - 1));
				wheres.push("ACC.CODACC_0 = T." + this.data.ACCSTR + "_0");
				wheres.push("ACC.CONSUL_0 = 2");
			}

			// clear the cache
			var cache = {};

			Object.keys(properties).forEach_(_, function(_, name) {
				tracerJs.debug && tracerJs.debug("getSql:'" + name + "'");
				properties[name].getSql && properties[name].getSql(_, columnNames, tableNames, wheres, params, descs, cache, false, sqlOpts);
			});

			this.cache = cache;
			var cacheRecord;

			if ((this.cache.texts && this.cache.texts.properties) || this.cache.references) {
				cacheRecord = function(cache, _max) {
					// Cache records in order to improve the performance of the cache of 
					// texts and references :
					var recordset = [];
					var max = _max || 100;

					function flush(_, _writer) {
						recordset.forEach_(_, function(_, record) {
							_writer.write(_, record);
						});
						recordset = [];
					}

					var fcts = [];
					//if (cache.cacheTextKey) fcts.push(cache.cacheTextKey);
					if (cache.texts) {
						Object.keys(cache.texts.properties).forEach(function(prop) {
							fcts.push(cache.texts.properties[prop].cacheTextKey);
						});
					}
					if (cache.references) {
						Object.keys(cache.references).forEach(function(ref) {
							fcts.push(cache.references[ref].cacheReference);
						});
					}
					return function(_, _reader, _writer) {
						var record;
						while (record = _reader.read(_)) {
							for (var i = 0; i < fcts.length; i++) {
								record = fcts[i](_, cache, record);
							}
							recordset.push(record);
							if (recordset.length > max) {
								flush(_, _writer);
							}
						}
						flush(_, _writer);
					};
				};
			}

			orderBy = [];
			if (select && select.$orderBy) {
				Object.keys(select.$orderBy).forEach_(_, function(_, name) {
					var column = properties[name].column.sqlName();
					orderBy.push(column + " " + ((select.$orderBy[name] === 1) ? "asc" : "desc"));
				});
			} else {
				var index = this.table.index(this.data.INDREF);
				index && index.sqlNames().forEach(function(column) {
					orderBy.push(column + " asc");
				});
			}
			if (select && (select.$query || (!select.$query && !select.$orderBy))) {
				var qsel = this.queryToSelect(_, select.$query || select, params);
				if (qsel !== "") wheres.push(qsel);
				tracerJs.debug && tracerJs.debug("wheres:" + wheres);
			}

			var i = 0;
			var sql = "select " + columnNames.join(',') + " from " + tableNames.join(',');

			if (wheres.length) sql += " where (" + wheres.join(') and (') + ')';
			if (orderBy.length) sql += " order by " + orderBy.join(',');

			var reader = self.supervisor.sqlReader(_, sql, params, sqlOpts).limit(max);
			if (cacheRecord) reader = reader.transform(cacheRecord(self.cache, max));
			reader = reader.map(recordMapper);
			return reader;
		},
		jsReader: function(_, parent, select, max, $recordMapper) {
			tracerJs.debug && tracerJs.debug("class.jsReader(" + max + "):" + JSON.stringify(select));
			var self = this;
			var recordMapper = $recordMapper || function() {
					return function(_, record) {
						return self.supervisor.new(_, 'Instance', self, null).afterCreate(_, record);
					};
				}();
			var reader = this.jsInterface.AQUERY(_, select);
			if (!reader.read) reader = this.rsReader(_, this.jsInterface.AQUERY(_, select), select);
			return reader.limit(max).map(recordMapper);
		},
		cleanFilter: function(filter) {
			var self = this;
			var keys = Object.keys(filter);
			if (!keys.length) return;

			return keys.reduce(function(r, k) {
				var match = k.match(/upper\((\w*)\)/);
				var p = match ? match[1] : k;
				r[p] = filter[k];
				if (Array.isArray(r[p])) {
					for (var i = 0; i < r[p].length; i++) {
						r[p][i] = self.cleanFilter(r[p][i]);
					}
				} else if (typeof r[p] === 'object') r[p] = self.cleanFilter(r[p]);
				return r;
			}, {});
		},
		rsReader: function(_, recordset, select) {
			if (select && select.$orderBy) {
				var sort = function(orderBy) {
					var fcts = Object.keys(orderBy).reduce(function(r, property) {
						r.push(function(ascDesc) {
							return function(a, b) {
								var A = a[property];
								var B = b[property];
								if (A > B) return ascDesc;
								if (A < B) return -1 * ascDesc;
								return 0;
							};
						}(orderBy[property]));
						return r;
					}, []);
					return function(o1, o2) {
						var cmp = 0;
						for (var i = 0; i < fcts.length; i++) {
							cmp = fcts[i](o1, o2);
							if (cmp) break;
						}
						return cmp;
					};
				}(select.$orderBy);
				recordset = recordset.sort(sort);
			}
			var reader = ez.devices.generic.empty.reader.transform(function(_, reader, writer) {
				recordset.forEach_(_, function(_, record) {
					writer.write(_, record);
				});
			});
			if (select && (select.$query || (!select.$query && !select.$orderBy))) {
				var filter = this.cleanFilter(select.$query || select);
				if (filter) reader = reader.filter(filter);
			}
			return reader;
		},
		loadInstances: function(_, parent, index, vals, max, $recordMapper) {
			return this.reader(
				_,
				parent,
				Object.keys(vals).reduce(function(o, c) {
					if (index.columns[c]) {
						if (vals[c] !== undefined) {
							o[index.columns[c].name] = vals[c];
						} else {
							o[index.columns[c].name] = index.columns[c].type.defaultValue;
						}
					}
					return o;
				}, {}),
				max,
				$recordMapper);
		},
		index: {
			get: function() {
				if (this._index === undefined) {
					if (this.table) {
						var index = this.table.indexes[0];
						this._index = [];
						var self = this;
						Object.keys(index.columns).forEach(function(c) {
							self._index.push(self.properties[index.columns[c].name]);
						});
					} else {
						this._index = [];
						var descript = this.data.KEYINT;
						if (descript && descript.length) {
							var match = descript.match(/[-+]?\w+/g);
							if (match) {
								for (var i = 0; i < match.length; i++) {
									var name = match[i];
									switch (name.charAt(0)) {
										case '+':
											name = name.substring(1) + " asc";
											break;
										case '-':
											name = name.substring(1) + " desc";
											break;
									}
									this._index[i] = {
										name: name
									};
								}
							}
						}
					}
				}
				return this._index;
			}
		},
		fromRecordMapper: function(_, instance) {
			return function(_, record) {
				tracerJs.debug && tracerJs.debug("fromRecordMapper:" + JSON.stringify(record));
				if (!instance) instance = this.supervisor.new(_, 'Instance', this, null);
				// TODO: check astatus
				return instance.afterCreate(_, record);
			}.bind(this);
		},

		keyToSelect: function(key) {
			var table = this.table;
			var index = table.indexes[0];
			var self = this;
			return Object.keys(this.index).reduce(function(r, i) {
				r[self.index[i].name] = key[i];
				return r;
			}, {});
		},
		sqlRead: function(_, instance, key) {
			var mapper = this.fromRecordMapper(_, instance);
			instance.snap && instance.snap.enable();
			var instances = this.reader(_, instance.parent, this.keyToSelect(key), 1, mapper).toArray(_);
			if (!instances || !instances.length) {
				tracerJs.error && tracerJs.error("class.read " + key + " not found");
				return constants.CST_AERROR;
			}
			instance.key = key;
			return constants.CST_AOK;
		},
		intRead: function(_, instance, key) {
			// Set key's value:
			var index = this.data.KEYINT.split('+');
			var keys = key.toString().split('~');
			var i = 0;
			index.forEach_(_, function(_, property) {
				instance.set(_, property, keys[i++], true);
			});
			var args = {
				ACTION: {
					type: "LS",
					value: "AREAD"
				},
				THIS: {
					type: "LY",
					value: instance
				}
			};
			instance.snap && instance.snap.enable();
			var status = instance.action(_, "AREAD", key);
			this.$astalin = constants.CST_ALL;
			return status;
		},
		updateTexts: function(_, instance) {
			Object.keys(instance.slots).forEach_(_, function(_, name) {
				var slot = instance.slots[name];
				if (slot.isAtextra) slot.updateAtextra(_);
				else if (slot.isText) slot.updateText(_);
			});
		},
		insert: function(_, instance) {
			tracerJs.debug && tracerJs.debug("class.insert");
			this.updateTexts(_, instance);
			return this.table.insert(_, instance);
		},
		update: function(_, instance) {
			tracerJs.debug && tracerJs.debug("class.update");
			this.updateTexts(_, instance);
			var result = this.table.update(_, instance);
			return (result && result.updateCount) ? constants.CST_AOK : constants.CST_AERROR;
		},
		delete: function(_, instance) {
			var result = this.table.delete(_, instance);
			tracerJs.debug && tracerJs.debug("class.delete result:" + JSON.stringify(result));
			Object.keys(instance.slots).forEach_(_, function(_, name) {
				var slot = instance.slots[name];
				if (slot.isAtextra) slot.deleteAtextra(_);
			});
			return (result && result.updateCount) ? constants.CST_AOK : constants.CST_AERROR;
		},
		readBDOC: function(_, property, ident1, ident2, ident3) {
			tracerJs.debug && tracerJs.debug("class.readBDOC(" + [property, ident1, ident2, ident3].join(',') + ')');
			return this.properties[property].readBDOC(_, ident1, ident2, ident3);
		},
		searchResourceFactory: function(_) {
			return this.supervisor.new(_, 'SearchResourceFactory', this);
		},
		searchProto: function(_) {
			var factory = this.searchResourceFactory(_);
			return factory.searchProto(_);
		},
		search: function(_, httpContext, qs) {
			var factory = this.searchResourceFactory(_);
			var dst = bulkWriter(httpContext);
			var select;
			// where=((UPDDATTIM gt "2015-03-17T12:59:39.144Z"))
			if (qs.where) select = filterHelpers.sdataFilterToJson(qs.where);

			var fromInstanceToResource = function(_, instance) {
				return this.supervisor.new(_, 'Resource', factory, instance);
			}.bind(this);
			this.reader(_, null, select, Infinity).map(fromInstanceToResource).pipe(_, dst);
		},
	}),
};