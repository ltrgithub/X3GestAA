"use strict";


var ez = require("ez-streams");
var util = require("etna-supervisor/lib/util");
var glob = require('streamline/lib/globals');
var utilRuntime = require('etna-engine/lib/runtime/util');
var tuuid = require('etna-engine/lib/runtime/uuid');
var tdate = require('etna-engine/lib/runtime/tdate');
var tdatetime = require('etna-engine/lib/runtime/tdatetime');
var activ = require("etna-supervisor/lib/meta/activ");
var tracerJs = require("syracuse-trace/lib/helper").getTracer("etna.supervisor");

var stdMethods = {
	ASETERROR: function(_, path, msg, severity) {
		util.checkInstance(this);
		this.diagnoses.push(this.supervisor.new(_, 'Diagnosis', severity, path, msg));
		return severity;
	},
	AINIT: function(_) {
		util.checkInstance(this);
		return this.ainit(_);
	},
	AREAD: function(_) {
		util.checkInstance(this);
		var key = Array.prototype.slice.call(arguments, 1);
		return this.read(_, key);
	},
	AINSERT: function(_) {
		util.checkInstance(this);
		this.insert(_);
		return 0;
	},
	AUPDATE: function(_) {
		util.checkInstance(this);
		this.update(_);
		return 0;
	},
	ADELETE: function(_) {
		util.checkInstance(this);
		this.delete(_);
		return 0;
	},
};

module.exports = {
	collectionName: 'ACLASSE',
	keyName: 'CODCLA',
	constructor: util.defineClass(function(superv, data, group) {
		this.supervisor = superv;
		this.data = data;
		this.collections = {};
		this.methods = {};
		this.keyItems = data.KEYINT ? data.KEYINT.split('+') : [];
		this.group = group;
		this.reader = this.sqlReader;
	}, null, {
		init: function(_) {
			if (this.properties) return this;
			var tableCode = this.data.TABREF || this.data.CODCLA;
			tracerJs.debug && tracerJs.debug("class this.data.TYPCLA:" + this.data.TYPCLA);
			if (this.data.TYPCLA === 2) { // 2 for persistent class
				this.table = this.table || this.supervisor.load(_, 'Table', tableCode);
				if (!this.table) throw new Error("table not found: " + tableCode);
			} else if (this.data.TYPCLA === 5) {
				// TODO : cache des builtins comme runtime :
				try {
					var jsInterface = require("etna-supervisor/lib/builtins/C_" + this.data.CODCLA);
					if (jsInterface) {
						this.reader = this.jsReader;
						this.jsInterface = jsInterface;
					}
				} catch (e) {

				}
			} else if (this.data.table) {
				this.table = this.data.table;
			}
			this.properties = {};

			this.data.PROPERTIES.forEach_(_, function(_, propData) {
				if ((this.group || "") !== ((!propData.LNKCLA && propData.FLDGRP) || "")) return;
				var name = propData.FLDCLA;
				if (this.properties[name]) throw new Error("duplicate property " + name);
				this.properties[name] = this.supervisor.new(_, 'Property', this, propData);


				if (this.properties[name].isReference(_)) {
					// Add a property :
					tracerJs.debug && tracerJs.debug(name + " is a reference");
					this.properties[name + '_REF'] = this.supervisor.new(_, 'Property', this, propData);
					this.properties[name + '_REF'].isReference(_, true);
					this.properties[name + '_REF'].getSql = undefined;
				}

			}, this);
			this.addPropTech(_);
			this.collections = {};
			this.data.COLLECTIONS.forEach_(_, function(_, data) {
				tracerJs.debug && tracerJs.debug("Class collection:" + data.CODCOL);
				var coln = this.collections[data.CODCOL] = this.supervisor.new(_, 'Collection', this, data);
				var name = data.CODCOL;
				var p = this.properties[name];
				if (!p) {
					tracerJs.debug && tracerJs.debug("collection indexed properties:" + name);
					p = this.properties[name] = this.supervisor.new(_, 'Property', this, name);
					p.collection = coln;
					// generate synthetic class for group of indexed properties
					coln.class = this.supervisor.new(_, "Class", {
						CODCLA: this.data.CODCLA + "." + name,
						TYPCLA: 1, //5,
						PROPERTIES: this.data.PROPERTIES.filter(function(propData) {
							return propData.FLDGRP === name;
						}),
						PARAM_FLDS: this.data.PARAM_FLDS,
						COLLECTIONS: [],
						table: this.table
					}, name);
					if (coln.class.data.PROPERTIES) {
						coln.class.data.PROPERTIES.forEach_(_, function(_, prop) {
							if (coln.class.data.PARAM_FLDS) {
								coln.class.data.PARAM_FLDS.forEach_(_, function(_, fld) {
									if (fld.FLDCLA === prop.FLDCLA && fld.VALEUR) {
										if (name + "." === fld.VALEUR.substring(0, name.length + 1)) {
											fld.VALEUR = fld.VALEUR.substring(name.length + 1);
										}
									}
								}, name, prop);
							}
						}, name);
					}
				} else {
					tracerJs.debug && tracerJs.debug("collection is a collection:" + name);
					p.collection = coln;

					var mapping = util.find(this.data.LINKS, 'REFLNK', name);
					var targetName;
					if (mapping !== null) {
						coln.mappingData = mapping;
						if (coln.mappingData.TYPLNK === 3) {
							tracerJs.debug && tracerJs.debug("collection type 1x1:" + name);
						}

						targetName = mapping.CLALNK;
					} else {
						targetName = p.data.LNKCLA;
					}
					if (!targetName) throw new Error("cannot find target name for collection " + name);
					coln.class = this.supervisor.load(_, 'Class', targetName);
					if (!coln.class) throw new Error("target class missing for collection " + name);
				}
			}, this);
			return this;
		},
		scripts: function(_) {
			if (this._scripts) return this._scripts;
			if (this.data.CODTRT) {
				this._scripts = this.data.CODTRT.map_(_, function(_, codtrt) {
					return {
						name: codtrt,
						body: this.supervisor.loadScript(_, codtrt)
					};
				}, this);
			} else {
				this._scripts = [];
			}
			return this._scripts;
		},
		name: {
			get: function() {
				return this.data.CODCLA;
			}
		},
		method: function(name) {
			return this.methods[name] || stdMethods[name];
		},
		collection: function(name) {
			var coln = this.collections[name];
			if (!coln) throw new Error("collection not found: " + name);
			return coln;
		},
		property: function(name) {
			var prop = this.properties[name];
			if (!prop) throw new Error("prop not found: " + this.name + "." + name);
			return prop;
		},
		addPropTech: function(_) {
			var wprops = [{
				"FLDCLA": "ASTALIN",
				"CODTYP": "C",
				"LONG": 4
			}, {
				"FLDCLA": "_AFCRIGHT",
				"CODTYP": "A",
				"LONG": 30
			}];
			wprops.forEach_(_, function(_, wprop) {
				var name = wprop.FLDCLA;
				if (this.properties[name]) throw new Error("duplicate property " + name);
				this.properties[name] = this.supervisor.new(_, 'Property', this, wprop);
			}, this);
		},
		invokeScripts: function(_, instance, action, $curpro, $curpth, values) {
			// , instance, action, name
			//tracerJs.debug && tracerJs.debug("invokeScripts:" + action);
			var curpro = $curpro || "";
			var curpth = $curpth || "";

			var astatus = this.supervisor.constants.CST_AOK;

			this.scripts(_).forEach_(_, function(_, script) {
				var handler = (curpro === "") ? script.body.METHODS : script.body.PROPERTIES;

				if (!handler || astatus) return;
				var frame = glob.context.x3frame;

				var prev = frame;
				var cx = prev.context;
				glob.context.x3frame = frame = {
					values: {},
					types: {},
					context: cx,
					prev: prev,
					loopLevel: 0,
					name: script.name,
					loc: {
						file: script.name,
						line: 0
					}
				};
				// current sub is the prog itself
				frame.sub = frame;
				frame.dicts = [frame, cx.globals, cx.sys];
				try {
					util.declVar(frame, 'CURPRO', 'LS', curpro);
					util.declVar(frame, 'CURPTH', 'LS', curpth);
					util.declVar(frame, 'ACTION', 'LS', action);
					if (instance !== null) {
						util.declVar(frame, 'THIS', 'LY', instance);
					}
					util.declVar(frame, 'ASTATUS', 'LI', 0);

					for (var v = 0; values !== undefined && v < values.length; v++) {
						util.declVar(frame, values[v].name, 'L' + values[v].name, values[v].value);
					}

					try {
						handler(_);
					} catch (e) {
						tracerJs.debug && tracerJs.debug("exception in invokeScripts\n" + e.message);
						e.frames && e.frames.forEach(function(frame) {
							tracerJs.debug && tracerJs.debug('\tat ' + frame.name + " (" + frame.file + ')');
						});
					}
					astatus = frame.values.ASTATUS;
				} finally {
					glob.context.x3frame = prev;
				}
			}, this);
			return astatus;
		},
		check: function(_, facet) {
			if (this.data.CODACT && activ.getActiv(_, this.supervisor, this.data.CODACT) <= 0)
				throw new util.HttpError(406, this.supervisor.loadMess(_, 140, 31) + ' ' + this.data.CODCLA + " (" + this.data.CODACT + ")");
			if (facet) {
				switch (facet) {
					case "$search":
						var trouveR = false;
						this.data.STD_METHODS.forEach_(_, function(_, method) {
							if (method.CODMETSTD === "R" && method.ENAMETSTD === 2) {
								trouveR = true;
								if (method.ACTMETSTD && activ.getActiv(_, this.supervisor, method.ACTMETSTD) <= 0)
									throw new util.HttpError(406, this.supervisor.loadMessParams(_, 149, 31, this.supervisor.loadMess(_, 7983, 7), this.data.CODCLA));
							}
						});
						if (trouveR === false)
							throw new util.HttpError(406, this.supervisor.loadMessParams(_, 149, 31, this.supervisor.loadMess(_, 7983, 7), this.data.CODCLA));
						break;
					case "$bulk":
					case "$query":
					case "$lookup":
					case "$details":
					case "$summary":
						var trouveR = false;
						this.data.STD_METHODS.forEach_(_, function(_, method) {
							if (method.CODMETSTD === "R" && method.ENAMETSTD === 2) {
								trouveR = true;
								if (method.ACTMETSTD && activ.getActiv(_, this.supervisor, method.ACTMETSTD) <= 0)
									throw new util.HttpError(406, this.supervisor.loadMessParams(_, 149, 31, this.supervisor.loadMess(_, 7983, 7), this.data.CODCLA));
							}
						});
						if (trouveR === false)
							throw new util.HttpError(406, this.supervisor.loadMessParams(_, 149, 31, this.supervisor.loadMess(_, 7983, 7), this.data.CODCLA));
						break;
					case "$edit":
						var trouveR = false;
						var trouveU = false;
						var trouveC = false;
						var codactU, codactC;
						this.data.STD_METHODS.forEach_(_, function(_, method) {
							if (method.CODMETSTD === "R" && method.ENAMETSTD === 2) {
								trouveR = true;
								if (method.ACTMETSTD && activ.getActiv(_, this.supervisor, method.ACTMETSTD) <= 0)
									throw new util.HttpError(406, this.supervisor.loadMessParams(_, 149, 31, this.supervisor.loadMess(_, 7983, 7), this.data.CODCLA));
							} else if (method.CODMETSTD === "U" && method.ENAMETSTD === 2) {
								trouveU = true;
								if (method.ACTMETSTD) codactU = method.ACTMETSTD;
							} else if (method.CODMETSTD === "C" && method.ENAMETSTD === 2) {
								trouveC = true;
								if (method.ACTMETSTD) codactC = method.ACTMETSTD;
							}

						});
						if (trouveR === false)
							throw new util.HttpError(406, this.supervisor.loadMessParams(_, 149, 31, this.supervisor.loadMess(_, 7983, 7), this.data.CODCLA));

						if (trouveU === false || activ.getActiv(_, this.supervisor, codactU) <= 0)
							if (trouveC === false || activ.getActiv(_, this.supervisor, codactC) <= 0) {
								throw new util.HttpError(406, this.supervisor.loadMessParams(_, 149, 32, this.supervisor.loadMess(_, 7983, 1), this.supervisor.loadMess(_, 7983, 10), this.data.CODCLA));
							}

						break;
				}
			}
		},
		keyExpression: function(_) {
			var table = this.table;
			return table ? table.indexes[0].keyExpression(_) : "{" + this.data.KEYINT + "}";
		},
		createInstance: function(_, qs) {
			var now = new Date();
			var properties = {
				//TODO : AUUID: new tuuid.UUID(),
				UPDDATTIM: now,
				CREDATTIM: now,
				ACTX: this.supervisor.currentContext(_),
				AERROR: util.emptyArray(),
			};
			return this.supervisor.new(_, 'Instance', this, null, properties).afterCreate(_);
		},
		loadInstance: function(_, key, qs) {
			var table = this.table;
			var index = table.indexes[0];
			var instances = this.loadInstances(_, index, key.split('~'), 1);
			if (instances.length === 0) throw new util.HttpError(404, "instance not found: " + this.name + "('" + key + "')");
			return instances[0];
		},
		queryExpToSelect: function(_, exp, params, tableNames) {
			var _this = this;
			var map = {
				'$eq': '=',
				'$ne': '!=',
				'$gt': '>',
				'$gte': '>=',
				'$lt': '<',
				'$lte': '<=',
				'$regex': 'like'
			};
			var param = this.supervisor.sqlDriver.param;

			return Object.keys(exp).reduce_(_, function(_, r, prop) {
				var id = prop;
				var expColumn = function(column) {
					return column;
				};

				var match = id.match(/upper\((\w*)\)/);
				if (match) {
					id = match[1];
					expColumn = function(column) {
						return 'UPPER(' + column + ')';
					};
				}
				var column = _this.properties[id].column.sqlName();
				var propExp = exp[prop];

				var hasExp = (typeof propExp === 'object') && Object.keys(propExp).some(function(key) {
					return (key.charAt(0) === '$');
				}) || false;

				var operators = hasExp ? propExp : {
					$eq: propExp
				};

				r.push(Object.keys(operators).reduce(function(r, operator) {
					if (map[operator]) {
						var sqlOperator = map[operator];
						var value = operators[operator];
						var valueType = typeof value;

						if (valueType === 'boolean') {
							value = value ? 2 : 1;
						} else if (_this.properties[id].etnaType === 'D' && (valueType === 'string')) {
							var date = tdate.parse(value, "yyyy-MM-dd");
							value = new Date(date.year, date.month - 1, date.day);
						} else if (_this.properties[id].etnaType === 'E') {
							var dt = tdatetime.x3Parse(value).toJsDate();
							value = new Date(dt.getUTCFullYear(),
								dt.getUTCMonth(),
								dt.getUTCDate(),
								dt.getUTCHours(),
								dt.getUTCMinutes(),
								dt.getUTCSeconds());
						} else if (sqlOperator === 'like') {
							if (value.charAt(0) === '^') value = value.substring(1);
							else value = '%' + value;
							value = value.replace(/\.\*/g, '%');
						}
						params.push(value);
						r.push(expColumn(column) + ' ' + sqlOperator + ' ' + param(params.length - 1));
					}
					return r;
				}, []).join(" and "));
				return r;
			}, []).join(" and ");
		},
		queryToSelect: function(_, query, params) {
			var operator = (query.$or) ? "or" : (query.$and ? "and" : undefined);
			if (operator) {
				var _this = this;
				return query['$' + operator].reduce_(_, function(_, r, exp) {
					r.push('(' + _this.queryToSelect(_, exp, params) + ')');
					return r;
				}, []).join(' ' + operator + ' ');
			}
			return this.queryExpToSelect(_, query, params);
		},
		queryInstances: function(_, select, max, instanceMapper) {
			return this.reader(_, select, max, null, instanceMapper);
		},
		sqlReader: function(_, select, max, $recordMapper, instanceMapper) {
			tracerJs.debug && tracerJs.debug("class.sqlReader(" + max + "):" + JSON.stringify(select));
			var _this = this;
			var recordMapper = $recordMapper || function() {
					return function(_, record) {
						// var instance = _this.supervisor.new(_, 'Instance', _this, null);
						// return instance.fromRecord(_, record);
						return _this.supervisor.new(_, 'Instance', _this, null).fromRecord(_, record);
					};
				}();

			var orderBy;
			var descs = [];
			var columnNames = [];
			var wheres = [];
			var params = [];
			var properties = this.properties;
			var param = this.supervisor.sqlDriver.param;
			var tableNames = [this.table.name + ' T'];

			// add link with ACCES if ACCSTR is filled.
			if (this.data.ACCSTR) {
				tracerJs.debug && tracerJs.debug("add ACCSTR " + this.data.ACCSTR);
				tableNames.push("ACCES ACC");
				params.push(this.supervisor.currentContext(_).builtinProperties.USER().getValue(_));
				wheres.push("ACC.USR_0 = " + param(params.length - 1));
				wheres.push("ACC.CODACC_0 = T." + this.data.ACCSTR + "_0");
				wheres.push("ACC.CONSUL_0 = 2");
			}

			// clear the cache
			var cache = {};

			Object.keys(properties).forEach_(_, function(_, name) {
				tracerJs.debug && tracerJs.debug("getSql:" + name);
				properties[name].getSql && properties[name].getSql(_, columnNames, tableNames, wheres, params, descs, cache);
			});

			this.cache = cache;
			var cacheRecord;

			if ((this.cache.texts && this.cache.texts.properties) || this.cache.references) {
				cacheRecord = function(cache, _max) {
					// Cache records in order to improve the performance of the cache of 
					// texts and references :
					var recordset = [];
					var max = _max || 100;

					function flush(_, _writer) {
						recordset.forEach_(_, function(_, record) {
							_writer.write(_, record);
						});
						recordset = [];
					}

					var fcts = [];
					//if (cache.cacheTextKey) fcts.push(cache.cacheTextKey);
					if (cache.texts) {
						Object.keys(cache.texts.properties).forEach(function(prop) {
							fcts.push(cache.texts.properties[prop].cacheTextKey);
						});
					}
					if (cache.references) {
						Object.keys(cache.references).forEach(function(ref) {
							fcts.push(cache.references[ref].cacheReference);
						});
					}
					return function(_, _reader, _writer) {
						var record;
						while (record = _reader.read(_)) {
							for (var i = 0; i < fcts.length; i++) {
								record = fcts[i](cache, record);
							}
							recordset.push(record);
							if (recordset.length > max) {
								flush(_, _writer);
							}
						}
						flush(_, _writer);
					};
				};
			}

			if (select && select.$orderBy) {
				orderBy = [];
				Object.keys(select.$orderBy).forEach_(_, function(_, name) {
					tracerJs.debug && tracerJs.debug("orderBy:" + name);
					var column = properties[name].column.sqlName();
					orderBy.push(column + " " + ((select.$orderBy[name] === 1) ? "asc" : "desc"));
				});
			}
			if (select.$query || (!select.$query && !select.$orderBy)) {
				tracerJs.debug && tracerJs.debug("select.$query " + JSON.stringify(select.$query));
				wheres.push(this.queryToSelect(_, select.$query || select, params));
				tracerJs.debug && tracerJs.debug("wheres:" + wheres);
			}
			var i = 0;
			var sql = "select " + columnNames.join(',') + " from " + tableNames.join(',');

			if (wheres.length) sql += " where (" + wheres.join(') and (') + ')';
			if (orderBy) sql += " order by " + orderBy.join(',');

			tracerJs.debug && tracerJs.debug("sql:" + sql);
			tracerJs.debug && tracerJs.debug("params:" + params);

			return this.supervisor.sqlDriver.withConnection(_, function(_, cnx) {
				var reader = _this.supervisor.sqlReader(_, cnx, sql, params).limit(max);
				if (cacheRecord) reader = reader.transform(cacheRecord(_this.cache, max));
				reader = reader.map(recordMapper);
				if (instanceMapper) reader = reader.map(instanceMapper);
				return reader;
			});
		},
		jsReader: function(_, select, max, $recordMapper, instanceMapper) {
			tracerJs.debug && tracerJs.debug("class.jsReader(" + max + "):" + JSON.stringify(select));
			var _this = this;
			var recordMapper = $recordMapper || function() {
					return function(_, record) {
						return _this.supervisor.new(_, 'Instance', _this, null).fromRecord(_, record);
					};
				}();

			return this.rsReader(_, this.jsInterface.AQUERY(_, select), select)
				.limit(max)
				.map(recordMapper)
				.map(instanceMapper);
		},
		rsReader: function(_, recordset, select) {
			if (select.$orderBy) {
				var sort = function(orderBy) {
					var fcts = Object.keys(orderBy).reduce(function(r, property) {
						r.push(function(ascDesc) {
							return function(a, b) {
								var A = a[property];
								var B = b[property];
								if (A > B) return ascDesc;
								if (A < B) return -1 * ascDesc;
								return 0;
							};
						}(orderBy[property]));
						return r;
					}, []);
					return function(o1, o2) {
						var cmp = 0;
						for (var i = 0; i < fcts.length; i++) {
							cmp = fcts[i](o1, o2);
							if (cmp) break;
						}
						return cmp;
					};
				}(select.$orderBy);
				recordset = recordset.sort(sort);
			}
			var reader = ez.devices.generic.empty.reader.transform(function(_, reader, writer) {
				recordset.forEach_(_, function(_, record) {
					writer.write(_, record);
				});
			});
			if (select.$query || (!select.$query && !select.$orderBy)) {
				reader = reader.filter(select.$query || select);
			}
			return reader;
		},
		loadInstances: function(_, index, vals, max, select) {
			return this.reader(
				_,
				Object.keys(index.columns).reduce(function(o, c) {
					o[index.columns[c].name] = vals[c];
					return o;
				}, {}),
				1).toArray(_);
		},
		index: {
			get: function() {
				if (this._index === undefined) {
					if (this.table) {
						var index = this.table.indexes[0];
						this._index = [];
						var _this = this;
						Object.keys(index.columns).forEach(function(c) {
							_this._index.push(_this.properties[index.columns[c].name]);
						});
					} else {
						this._index = [];
						var descript = this.data.KEYINT;
						if (descript && descript.length) {
							var match = descript.match(/[-+]?\w+/g);
							if (match) {
								for (var i = 0; i < match.length; i++) {
									var name = match[i];
									switch (name.charAt(0)) {
										case '+':
											name = name.substring(1) + " asc";
											break;
										case '-':
											name = name.substring(1) + " desc";
											break;
									}
									this._index[i] = {
										name: name
									};
								}
							}
						}
					}
				}
				return this._index;
			}
		},
		fromRecordMapper: function(instance, params) {
			return function(_, record) {
				if (!instance) instance = this.supervisor.new(_, 'Instance', this, null);
				this.invokeScripts(_, instance, "AREAD_BEFORE", "", "", params);
				tracerJs.debug && tracerJs.debug("record:" + JSON.stringify(record));
				instance.fromRecord(_, record);
				var astatus = this.invokeScripts(_, instance, "AREAD_AFTER", "", "", params);
				// TODO: check astatus
				return instance;
			}.bind(this);
		},
		ainit: function(_, instance) {
			return this.invokeScripts(_, instance, "AINIT");
		},
		read: function(_, instance, key) {
			var _this = this;
			var table = this.table;
			var index = table.indexes[0];

			var select = {};
			var params = [];
			Object.keys(_this.index).forEach(function(i) {
				select[_this.index[i].name] = key[i];
				params.push({
					name: _this.index[i].name,
					type: _this.index[i].etnaType,
					value: key[i]
				});
			});
			//TODO : instance.properties.AUUID.set(_,tuuid.generate(),true);
			var mapper = this.fromRecordMapper(instance, params);
			var instances = this.reader(_, select, 1, mapper).toArray(_);
			if (!instances || !instances.length) return instance.supervisor.constants.CST_AERROR;
			return instance.supervisor.constants.CST_AOK;
		},
	}),
};