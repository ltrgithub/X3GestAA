"use strict";
/*
TODO : 
 - Operations for real
 - Add a transaction
*/

var glob = require('streamline/lib/globals');
var util = require("etna-supervisor/lib/util");
var constants = require("etna-supervisor/lib/constants");

//var debug = function(m) {console.error("tableLinks : "+m);}
var tracerJs = require("syracuse-trace/lib/helper").getTracer("etna.supervisor");


function sqlName(code, i) {
	return code + '_' + (i || 0);
};

var sqlValue = {
	string: function(i) {
		return function(key) {
			tracerJs.debug && tracerJs.debug("sqlValue(string) key:" + key + " i:" + i + " key[i]:" + key[i]);
			return key[i];
		};
	},
	number: function(i) {
		return function(key) {
			tracerJs.debug && tracerJs.debug("sqlValue(number) key:" + key + " i:" + i + " key[i]:" + key[i]);
			return parseInt(key[i]);
		};
	}
};


var linkOperations = {
	control: {
		type: 1,
		execute: function(_, instance, superv, sql) {
			var status = constants.CST_AOK;
			var names = sql.table.indexes[0].sqlNames();
			//if (sql.table.data.INTIT) names.push(sqlName(sql.table.data.INTIT));

			var cmd = "select " + names.join(',');
			cmd += " from " + sql.table.name + " where (" + sql.where + ")";

			tracerJs.debug && tracerJs.debug(cmd);
			var records = superv.sqlReader(_, cmd, sql.params).toArray(_);
			if (records.length) {
				records.forEach_(_, function(_, record) {
					// "The record is used by"
					var message = [superv.loadMess(_, 126, 101)];
					// Add the record's key :
					message.push(sql.table.indexes[0].columns.map(function(column) {
						return record[column.name];
					}).join('~'));
					// Add the record's description :
					var recordDescription = sql.table.getRecordDescription(_, records);
					if (recordDescription) message.push('(' + recordDescription + ')');
					// "is used in" 
					message.push(superv.loadMess(_, 133, 198));
					// Add the table's name
					message.push(sql.table.name);
					// Add the table's description
					var tableDescription = sql.table.description(_);
					if (tableDescription) message.push('(' + tableDescription + ')');
					status = Math.max(status, instance.addDiagnose(_, constants.CST_AERROR, message.join(' ')));
				});
			}
			return status;
		}
	},
	delete: {
		type: 2,
		execute: function(_, instance, superv, sql) {
			var cmd = "delete from " + sql.table.name + " where " + sql.where;
			tracerJs.debug && tracerJs.debug(cmd);
			tracerJs.debug && tracerJs.debug(sql.params);
			tracerJs.debug && tracerJs.debug("delete type2 :" + cmd);
			superv.executeSql(_, cmd, sql.params);
			return constants.CST_AOK;
		}
	},
	reset: {
		type: 3,
		execute: function(_, instance, superv, sql) {
			var param = superv.sqlDriver.param;

			var updateSets = Object.keys(sql.updateSets).map(function(key) {
				sql.params.push(sql.updateSets[key]);
				return key + " = " + param(sql.params.length - 1);
			}).join(' ');

			var cmd = "update " + sql.table.name + " set " + updateSets + " where " + sql.where;
			tracerJs.debug && tracerJs.debug("reset type3 :" + cmd);
			superv.executeSql(_, cmd, sql.params);
			return constants.CST_AOK;

		}
	}
};

exports.constructor = util.defineClass(function(superv, table) {
	this.supervisor = superv;
	this.table = table;
}, null, {
	init: function(_) {
		tracerJs.debug && tracerJs.debug(this.table + " tableLinks");
		var self = this;

		this.links = this.supervisor.mongoStore.collection('ATABLE', _)
			.find({
				"COLUMNS.LIEN": this.table
			})
			.sort({
				CODFIC: 1
			})
			.toArray(_)
			.filter(function(table) {
				return table.CODFIC !== self.table;
			})
			.reduce_(_, function(_, r, table) {
				//tracerJs.debug && tracerJs.debug("table:"+table.CODFIC);
				return table.COLUMNS
					.filter(function(column) {
						return column.LIEN && column.LIEN == self.table && column.ANNUL !== 4;
					})
					.reduce_(_, function(_, r, column) {
						try {
							var type = r[column.ANNUL] = r[column.ANNUL] || {};
							var group = type[table.CODFIC] = type[table.CODFIC] || {};
							group.table = group.table || self.supervisor.load(_, 'Table', table.CODFIC);
							group.links = group.links || [];
							if (column.ANNUL === 3) {
								group.updateSets = group.updateSets || {};
								group.updateSets[sqlName(column.CODZONE)] = group.table.columns[column.CODZONE].type.defaultValue;
							}
							var expressions = column.EXPLIEN && column.EXPLIEN.trim();
							if (expressions) {

								var indiceMax = 1;
								var statement = [];
								var expression = expressions.split(';');
								for (var e = 0; e < expression.length; e++) {
									tracerJs.debug && tracerJs.debug(table.CODFIC + " expression:" + expression[e]);
									statement[e] = function(expression) {
										return function(link, i) {
											throw new Error("Don't know what to do with expression:" + expression);
										};
									}(expression[e]);

									if (/^\w+\(indice\)$/.test(expression[e])) {
										indiceMax = parseInt(column.DIME);

										var colName = expression[e].substring(0, expression[e].indexOf('('));
										var colType = group.table.columns[colName].type.jsType;

										statement[e] = function(name, jsType, idx) {
											return function(link, i) {
												link.sql.push({
													name: sqlName(name, i),
													value: sqlValue[jsType](idx)
												});
											};
										}(colName, colType, e);

									} else if (/^indice$/.test(expression[e])) {
										statement[e] = function(idx) {
											return function(link, i) {
												link.statement = link.statement || [];
												link.statement.push(function(_, key) {
													return key[idx] = i;
												});
											};
										}(e);
									} else if (/^\[V\]\w+$/.test(expression[e])) {
										var x3Var = expression[e].substring(3);
										switch (x3Var) {
											case "GLANGUE":
												statement[e] = function(idx) {
													return function(link, i) {
														link.statement = link.statement || [];
														link.statement.push(function(_, key) {
															var actx = glob.context.x3session.actx;
															return key[idx] = actx.$LAN(_);
														});
													};
												}(e);
												break;
										}
									} else {
										var colName = expression[e];
										var colType = group.table.columns[colName].type.jsType;
										statement[e] = function(name, jsType, idx) {
											return function(link, i) {
												link.sql.push({
													name: sqlName(name, i),
													value: sqlValue[jsType](idx)
												});
											};
										}(colName, colType, e);
									}
								}

								// Add links:
								for (var indice = 0; indice < indiceMax; indice++) {
									var link = {
										sql: []
									};
									for (var i = 0; i < statement.length; i++) {
										statement[i](link, indice);
									}
									group.links.push(link);
								}
							} else {
								group.links.push({
									sql: [{
										name: sqlName(column.CODZONE),
										value: sqlValue[group.table.columns[column.CODZONE].type.jsType](0)
									}]
								});
							}

						} catch (exception) {
							tracerJs.error && tracerJs.error(exception);
						}
						return r;
					}, r, this);
				return r;
			}, {}, this);
		return this;
	},
	execute: function(_, instance, operation) {
		var self = this;
		var status = constants.CST_AOK;

		var $keys = instance.key;
		var keys = [$keys];
		tracerJs.debug && tracerJs.debug("tableLinks execute  operation type " + operation.type + " on " + keys);

		if (this.links && this.links[operation.type]) {
			var param = self.supervisor.sqlDriver.param;

			Object.keys(self.links[operation.type]).forEach_(_, function(_, groupKey) {
				var group = self.links[operation.type][groupKey];

				if (group.links) {

					// For each key stored in keys
					var sql = keys.reduce_(_, function(_, r, $key) {
						var key = typeof $key === 'string' ? $key.split('~') : $key;
						// Loop on links
						group.links
							.filter_(_, function(_, link) {
								// Keep links which abide with logical statements :
								if (link.statement) {
									for (var i = 0; i < link.statement.length; i++) {
										if (!link.statement[i](_, key)) return false;
									}
								}
								return true;
							})
							.reduce_(_, function(_, r, link) {
								r.wheres = r.wheres || [];
								var where = {};
								r.maxColumns = Math.max(r.maxColumns, link.sql.length);
								for (var i = 0; i < link.sql.length; i++) {
									where[link.sql[i].name] = link.sql[i].value(key);
								}
								r.wheres.push(where);
								return r;
							}, r);
						return r;
					}, {
						table: group.table,
						maxColumns: 0,
						updateSets: group.updateSets
					});

					if (sql.wheres) {
						// TODO : Split sql.wheres here if it contains to many elements (sql limits)
						sql.params = [];
						sql.where = sql.wheres.reduce(function(r, where) {
							r.push(Object.keys(where).map(function(condition) {
								sql.params.push(where[condition]);
								return condition + "=" + param(sql.params.length - 1);
							}).join(' and '));
							return r;
						}, []).join(' or ');
						status = Math.max(status, operation.execute(_, instance, self.supervisor, sql));
					}
				}
			});
		};
		return status;
	},
	control: function(_, instance) {
		return this.execute(_, instance, linkOperations.control);
	},
	delete: function(_, instance) {
		tracerJs.debug && tracerJs.debug("delete table:" + this.table);
		var status = this.execute(_, instance, linkOperations.delete);
		if (status === constants.CST_AERROR) return status;
		return this.execute(_, instance, linkOperations.reset);
	}
});