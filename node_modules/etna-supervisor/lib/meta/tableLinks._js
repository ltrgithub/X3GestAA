"use strict";
/*
TODO : 
 - Operations for real
 - Add a transaction
*/

var glob = require('streamline/lib/globals');
var util = require("etna-supervisor/lib/util");
var tracerJs = require("syracuse-trace/lib/helper").getTracer("etna.supervisor");

function sqlName(code, i) {
	return code + '_' + (i || 0);
};

var sqlValue = {
	string: function(e) {
		return function(key) {
			return key[e];
		};
	},
	number: function(e) {
		return function(key) {
			return parseInt(key[e]);
		};
	}
};


var linkOperations = {
	control: {
		type: 1,
		execute: function(_, superv, cnx, sql) {

			var names = sql.table.indexes[0].sqlNames(_);
			if (sql.table.data.INTIT) names.push(sqlName(sql.table.data.INTIT));

			var cmd = "select " + names.join(',');
			cmd += " from " + sql.table.name + " where (" + sql.where + ")";

			tracerJs.debug && tracerJs.debug(cmd);
			var records = superv.sqlReader(_, cnx, cmd, sql.params).toArray(_);
			if (records.length) {
				// "The record is used by"
				var message = [superv.loadMess(_, 126, 101)];
				// Add the record's key :
				message.push(sql.table.indexes[0].columns.map(function(column) {
					return records[0][column.name];
				}).join('~'));
				// Add the record's description :
				var recordDescription = sql.table.getRecordDescription(_, records[0]);
				if (recordDescription) message.push('(' + recordDescription + ')');
				// "is used in" 
				message.push(superv.loadMess(_, 133, 198));
				// Add the table's name
				message.push(sql.table.name);
				// Add the table's description
				var tableDescription = sql.table.description(_);
				if (tableDescription) message.push('(' + tableDescription + ')');
				throw new util.HttpError(403, message.join(' '));
			}
		}
	},
	delete: {
		type: 2,
		execute: function(_, superv, cnx, sql) {
			var cmd = "delete from " + sql.table.name + " where " + sql.where;
			tracerJs.debug && tracerJs.debug(cmd);
			//TODO : superv.executeSql(_, sql, sql.params);

		}
	},
	reset: {
		type: 3,
		execute: function(_, superv, cnx, sql) {
			console.log("updateSets:" + JSON.stringify(sql.updateSets));
			var param = superv.sqlDriver.param;

			var updateSets = Object.keys(sql.updateSets).map(function(key) {
				sql.params.push(sql.updateSets[key]);
				return key + " = " + param(sql.params.length - 1);
			}).join(' ');

			var cmd = "update " + sql.table.name + " set " + updateSets + " where " + sql.where;
			tracerJs.debug && tracerJs.debug(cmd);
			//TODO : superv.executeSql(_, sql, sql.params);
		}
	}
};

exports.constructor = util.defineClass(function(superv, table) {
	this.supervisor = superv;
	this.table = table;
}, null, {
	init: function(_) {
		tracerJs.debug && tracerJs.debug(this.table + " tableLinks");
		var _this = this;

		this.links = this.supervisor.mongoStore.collection('ATABLE', _)
			.find({
				"COLUMNS.LIEN": this.table
			})
			.sort({
				CODFIC: 1
			})
			.toArray(_)
			.reduce_(_, function(_, r, table) {
				//tracerJs.debug && tracerJs.debug("table:"+table.CODFIC);
				return table.COLUMNS
					.filter(function(column) {
						return column.LIEN && column.LIEN == _this.table && column.ANNUL !== 4;
					})
					.reduce_(_, function(_, r, column) {
						try {
							var type = r[column.ANNUL] = r[column.ANNUL] || {};
							var group = type[table.CODFIC] = type[table.CODFIC] || {};
							group.table = group.table || this.supervisor.load(_, 'Table', table.CODFIC);
							group.links = group.links || [];
							if (column.ANNUL === 3) {
								group.updateSets = group.updateSets || {};
								group.updateSets[sqlName(column.CODZONE)] = group.table.columns[column.CODZONE].type.defaultValue;
							}
							var expressions = column.EXPLIEN && column.EXPLIEN.trim();
							if (expressions) {
								var indiceMax = 1;
								var statement = [];
								var expression = expressions.split(';');
								for (var e = 0; e < expression.length; e++) {
									tracerJs.debug && tracerJs.debug(table.CODFIC + " expression:" + expression[e]);
									statement[e] = function(expression) {
										return function(link, i) {
											throw new Error("Don't know what to do with expression:" + expression);
										};
									}(expression[e]);

									if (/^\w+\(indice\)$/.test(expression[e])) {
										indiceMax = parseInt(column.DIME);
										statement[e] = function(name) {
											return function(link, i) {
												link.sql.push({
													name: sqlName(name, i),
													value: sqlValue[group.table.columns[column.CODZONE].type.jsType](e)
												});
											};
										}(expression[e].substring(0, expression[e].indexOf('(')));
									} else if (/^indice$/.test(expression[e])) {
										statement[e] = function(k) {
											return function(link, i) {
												link.statement = link.statement || [];
												link.statement.push(function(_, key) {
													return key[e] = i;
												});
											};
										}(e);
									} else if (/^\[V\]\w+$/.test(expression[e])) {
										var x3Var = expression[e].substring(3);
										switch (x3Var) {
											case "GLANGUE":
												statement[e] = function(k) {
													return function(link, i) {
														link.statement = link.statement || [];
														link.statement.push(function(_, key) {
															var actx = glob.context.x3session.actx;
															return key[e] = actx.$LAN(_);
														});
													};
												}(e);
												break;
										}
									} else {
										statement[e] = function(name) {
											return function(link, i) {
												link.sql.push({
													name: sqlName(name, i),
													value: sqlValue[group.table.columns[column.CODZONE].type.jsType](e)
												});
											};
										}(expression[e]);
									}
								}

								// Add links:
								for (var indice = 0; indice < indiceMax; indice++) {
									var link = {
										sql: []
									};
									for (var i = 0; i < statement.length; i++) {
										statement[i](link, indice);
									}
									group.links.push(link);
								}
							} else {
								group.links.push({
									sql: [{
										name: sqlName(column.CODZONE),
										value: sqlValue[group.table.columns[column.CODZONE].type.jsType](0)
									}]
								});
							}

						} catch (exception) {
							tracerJs.error && tracerJs.error(exception);
						}
						return r;
					}, r, this);
				return r;
			}, {}, this);
		return this;
	},
	execute: function(_, $keys, operation) {
		var _this = this;
		var keys = Array.isArray($keys) ? $keys : [$keys];

		tracerJs.debug && tracerJs.debug("execute  operation type " + operation.type + " on " + keys);
		if (this.links && this.links[operation.type]) {
			this.supervisor.sqlDriver.withConnection(_, function(_, cnx) {
				var param = _this.supervisor.sqlDriver.param;
				Object.keys(_this.links[operation.type]).forEach_(_, function(_, groupKey) {
					var group = _this.links[operation.type][groupKey];
					if (group.links) {

						// For each key stored in keys
						var sql = keys.reduce_(_, function(_, r, $key) {
							var key = typeof $key === 'string' ? $key.split('~') : $key;
							// Loop on links
							group.links
								.filter_(_, function(_, link) {
									// Keep links which abide with logical statements :
									if (link.statement) {
										for (var i = 0; i < link.statement.length; i++) {
											if (!link.statement[i](_, key)) return false;
										}
									}
									return true;
								})
								.reduce_(_, function(_, r, link) {
									r.wheres = r.wheres || [];
									var where = {};
									r.maxColumns = Math.max(r.maxColumns, link.sql.length);
									for (var i = 0; i < link.sql.length; i++) {
										where[link.sql[i].name] = link.sql[i].value(key);
									}
									r.wheres.push(where);
									return r;
								}, r);
							return r;
						}, {
							table: group.table,
							maxColumns: 0,
							updateSets: group.updateSets
						});

						if (sql.wheres) {
							// TODO : Split sql.wheres here if it contains to many elements (sql limits)
							sql.params = [];
							sql.where = sql.wheres.reduce(function(r, where) {
								r.push(Object.keys(where).map(function(condition) {
									sql.params.push(where[condition]);
									return condition + "=" + param(sql.params.length - 1);
								}).join(' and '));
								return r;
							}, []).join(' or ');
							operation.execute(_, _this.supervisor, cnx, sql);
						}
					}
				});
			});
		};
	},
	control: function(_, keys) {
		this.execute(_, keys, linkOperations.control);
	},
	delete: function(_, keys) {
		this.execute(_, keys, linkOperations.delete);
		this.execute(_, keys, linkOperations.reset);
	}
});