"use strict";

var util = require("etna-supervisor/lib/util");
var Sdata = require("etna-engine/lib/sdatagen");
var tuuid = require('etna-engine/lib/runtime/tuuid');
var activ = require("etna-supervisor/lib/meta/activ");
var glob = require('streamline/lib/globals');

var constants = require("etna-supervisor/lib/constants");
var extAttributesObject = require("etna-supervisor/lib/attributes").extAttributesObject;
var enumStdLinks = require("etna-supervisor/lib/meta/link").enumStdLinks;
var baseClass = require("etna-supervisor/lib/meta/baseClass");
var Cache = require("etna-supervisor/lib/cache").Cache;

var newInstanceProperty = require("etna-supervisor/lib/instanceProperty").newInstanceProperty;
var newInstanceReference = require("etna-supervisor/lib/InstanceReference").newInstanceReference;
var newInstanceCollection = require("etna-supervisor/lib/instanceCollection").newInstanceCollection;
var newInstance = require("etna-supervisor/lib/meta/instance").newInstance;

var tracerJs = require("syracuse-trace/lib/helper").getTracer("etna.supervisor");


// order of keys matches ENAFAC values so that we can fill FacetIds
var FACETS = {
	$details: {
		id: 0,
		prefix: "DET",
		mainMenu: "$edit"
	},
	$edit: {
		id: 1,
		prefix: "EDI",
		mainMenu: "$save"
	},
	$query: {
		id: 2,
		prefix: "QRY",
		mainMenu: "$create"
	},
	$lookup: {
		id: 3,
		prefix: "LOK",
	},
	$summary: {
		id: 4,
		prefix: "SUM",
	},
	$bulk: { // for now, same as query
		id: 2,
		prefix: "QRY",
	},
};


var enumDevices = {
	1: "desktop",
	2: "phone",
	3: "tablet"
};

function getDeviceCode(device) {
	var code;
	var codes = Object.keys(enumDevices);
	for (var i = 0; i < codes.length; i++) {
		if (enumDevices[codes[i]] === device) {
			return parseInt(codes[i]);
		}
	}
}

module.exports = {
	collectionName: 'ASHW',
	keyName: 'CODREP',
	constructor: baseClass.defineClass(function(superv, data) {
		this.curpath = "";
	}, null, {
		$$type: {
			get: function() {
				return "Representation";
			}
		},
		init: function(_) {
			if (this.resourceFactories) return;
			this.resourceFactories = {};
			var self = this;
			this.class = this.supervisor.load(_, 'Class', this.data.CODCLA, {
				codclaPath: this.data.CODREP + "." + this.data.CODCLA,
				curpath: (this.curpath) ? this.curpath + "." + this.data.ABRCLA : this.data.ABRCLA,
				parent: self
			});
			if (!this.class) throw new Error("class not found: " + this.data.CODCLA);

			this.properties = this.data.PROPERTIES
				.filter(function(prop) {
					return !prop.FLDGRP;
				})
				.reduce_(_, function(_, r, prop) {
					var name = prop.CODFLD;
					r[name] = self.supervisor.new(_, 'Property', self, prop, newInstanceProperty);
					return r;
				}, {}, this);

			this.relations = this.data.COLLECTIONS.reduce_(_, function(_, r, col) {
				if (col.CODCOL.indexOf('.') < 0) {
					r = r || {};
					var name = col.CODCOL;

					var coln = r[name] = this.supervisor.new(_, 'Collection', this, col);
					coln.class = this.supervisor.new(_, 'Class', {
						CODCLA: this.data.CODREP + "." + name,
						TYPCLA: 1, //5,
						PROPERTIES: this.data.PROPERTIES.reduce(function(r, propData) {
							if (propData.FLDGRP === name) {
								propData.FLDCLA = propData.CODFLD;
								r.push(propData);
							}
							return r;
						}, [], this),
						PARAM_FLDS: [],
						COLLECTIONS: [],
						table: this.table
					}, name);

					var prop = this.properties[name] = this.supervisor.new(_, 'Property', self, {
						CODFLD: name
					}, newInstanceCollection, coln);
				}
				return r;
			}, null, this);


			this.exportedProperties = this.data.EXPORTED_PROPERTIES.sort(function(ep1, ep2) {
				return ep1.ORDPRO - ep2.ORDPRO;
			}).map_(_, function(_, data) {
				return this.supervisor.new(_, 'ExportedProperty', this, data);
			}, this);
			if (!this.qdevice || this.qdevice === '') {
				this.qdevice = enumDevices[this.data.TYPMSKREP] || enumDevices[1];
			}
			// First filter on LINKS + sort
			function trierLink(a, b) { //must have FLGSTDLNK===2 first, and after FLGSTDLNK===1
				var info1 = 2;
				var info2 = 2;
				if (a.FLGSTDLNK === 2) info1 = 1;
				if (b.FLGSTDLNK === 2) info2 = 1;
				if ([a.AFFLNK, a.ANCLNK, info1, a.CODLNK].join("/") < [b.AFFLNK, b.ANCLNK, info2, b.CODLNK].join("/")) return -1;
				else if ([a.AFFLNK, a.ANCLNK, info1, a.CODLNK].join("/") == [b.AFFLNK, b.ANCLNK, info2, b.CODLNK].join("/")) return 0;
				else return 1;
			}
			this.data.LINKS = this.data.LINKS.filter(function(link) {
				return link.ENALNK === 2;
			}).sort(trierLink);
			return this;
		},
		prepareLinks: function(_) {
			if (this.links) return;
			var self = this;

			var comp = "44444444444444444444";
			// Get references of replacement links
			var linksRemRef = self.data.LINKS.filter(function(link) {
				return link.REMSTDLNK !== undefined && link.REMSTDLNK !== "" && link.FLGSTDLNK === 2;
			}).reduce(function(r, lk1) {
				var tablnk = self.data.LINKS.filter(function(lk2) {
					return lk2.CODLNK === lk1.REMSTDLNK && lk2.ANCLNK === lk1.ANCLNK && lk2.AFFLNK === lk1.AFFLNK;
				});
				if (tablnk && tablnk[0]) r[[lk1.AFFLNK, lk1.ANCLNK, lk1.REMSTDLNK].join("/")] = tablnk[0];
				return r;
			}, {});


			this.links = self.data.LINKS.filter(function(link) {
				//get all except linksRemRef
				return linksRemRef[[link.AFFLNK, link.ANCLNK, link.CODLNK].join("/")] === undefined;
			}).reduce_(_, function(_, r, lk1) {
				var link;
				if (lk1.REMSTDLNK && lk1.REMSTDLNK.length) {
					var codRem = [lk1.AFFLNK, lk1.ANCLNK, lk1.REMSTDLNK].join("/");
					if (linksRemRef[codRem]) link = util.clone(linksRemRef[codRem]);
					else return r;
					if (lk1.ATTLNK > 1 && link.ATTLNK === 1) link.ATTLNK = lk1.ATTLNK;
					if (lk1.FLGSTDLNK === 2) link.FLGSTDLNK = 2;
					if (lk1.MENLNK) link.MENLNK = lk1.MENLNK;
					if (lk1.ORDLNK) link.ORDLNK = lk1.ORDLNK;
				} else {
					link = lk1;
				}
				if (activ.getActiv(_, self.supervisor, link.ACVLNK) < 0) return r;

				if (link.ATTLNK > 1 && link.FLGSTDLNK === 2) {
					var tablnk = self.data.LINKS.filter(function(lk2) {
						return lk2.ATTLNK === link.ATTLNK && lk2.FLGSTDLNK === 1 && lk2.AFFLNK === link.AFFLNK && lk2.ANCLNK === link.ANCLNK && lk2.CODLNK !== link.CODLNK && lk2.CODLNK !== lk1.CODLNK;
					});
					if (tablnk && tablnk[0]) {
						link.ATTLNK = 1;
						link.FLGSTDLNK = 1;
					}
				}
				if (link.TYPLNK === 1) {
					var repr;
					repr = (link.REPLNK === self.name) ? self : self.supervisor.load(_, 'Representation', link.REPLNK);
					if (!repr || !repr.isActivated(_)) return r;
					if (repr.class) {
						if (!repr.class.isActivated(_)) return r;

						if (enumStdLinks[link.CMPLNK]) {
							if (enumStdLinks[link.CMPLNK].toFacet && !repr.isFacetEnabled(enumStdLinks[link.CMPLNK].toFacet)) return r;
							var behaviors = enumStdLinks[link.CMPLNK].requiredBehaviors;
							for (var i = 0; behaviors && i < behaviors.length; i++) {
								if (!repr.isBehaviourEnabled(behaviors[i])) return r;
							}
						}
					}
				}
				if (link.ATTLNK > 1) link.FLGSTDLNK = 2;
				link.oCODLNK = link.CODLNK;
				link.oAFFLNK = link.AFFLNK;
				link.CMPLNK = link.CMPLNK || 0;
				if (link.AFFLNK === 5 && (link.DETLNK === 2 || link.EDILNK === 2 || link.SUMLNK === 2)) {
					var newLink = util.clone(link);
					link.DETLNK = 1;
					link.EDILNK = 1;
					link.SUMLNK = 1;
					r.push(link);
					newLink.AFFLNK = 4;
					newLink.QRYLNK = 1;
					newLink.LOKLNK = 1;
					newLink.CODLNK = link.oCODLNK + "_LIG" + comp.substr(0, 12 - link.oCODLNK.length);
					r.push(newLink);
				} else {
					r.push(link);
				}
				return r;
			}, []);

		},
		name: {
			get: function() {
				return this.data.CODREP;
			}
		},
		title: function(_, lan) {
			return this.supervisor.loadText(_, this.data.INTREP, lan);
		},
		table: {
			get: function() {
				return this.class.table;
			}
		},
		index: {
			get: function() {
				if (this._index === undefined) {
					//By default:
					var descript = this.data.DESCRIPT;
					this._index = this.class.index;
					if (descript && descript.length) {
						var match = descript.match(/[-+]?\w+/g);
						if (match) {
							this._index = [];
							for (var i = 0; i < match.length; i++) {
								var name = match[i];
								switch (name.charAt(0)) {
									case '+':
										name = name.substring(1) + " asc";
										break;
									case '-':
										name = name.substring(1) + " desc";
										break;
								}
								this._index[i] = {
									name: name
								};
							}
						}
					}
				}
				return this._index;
			}
		},
		isFacetEnabled: function(facet) {
			return this.data.ENAFAC[FACETS[facet].id] === 2;
		},
		isBehaviourEnabled: function(no7968) {
			return this.data.ENACOM[no7968 - 1] === 2;
		},
		check: function(_, facet) {
			if (!this.isActivated(_))
				throw new util.HttpError(406, this.supervisor.loadMess(_, 140, 22) + ' ' + this.data.CODREP + " (" + this.data.CODACT + ")");
			if (facet && !this.isFacetEnabled(facet))
				throw new util.HttpError(406, this.supervisor.loadMessParams(_, 149, 14, facet, this.data.CODREP));
			this.class.check(_, facet);
		},
		checkDevice: function(device) {
			var code = getDeviceCode(device);
			if (code) {
				if (this.data.TYPMSKREP === 2) return; // keep unit test happy (mobile representation always accepted?)
				if (code !== this.data.TYPMSKREP) throw new util.HttpError(406, "device mismatch: " + device);
			} else if (device) throw new util.HttpError(415, "unknown device: " + device);
		},
		protoETag: function(_, facet) {
			var factory = this.resourceFactories[facet];
			return (factory !== undefined) ? factory.ETag : undefined;
		},
		resourceFactory: function(_, facet) {
			var factory = this.resourceFactories[facet];
			if (factory) return factory;
			this.prepareLinks(_);
			var self = this;
			factory = this.supervisor.new(_, 'ResourceFactory', this, facet, [], this.class);
			factory.ETag = this.data._etag + "-" + glob.context.x3session.actx.$LAN(_);

			this.resourceFactories[facet] = factory;
			this.resourceFactories[facet].keyItems = [];

			var facetFlagLNK = FACETS[facet].prefix + "LNK";
			var facetFlagPRO = FACETS[facet].prefix + "PRO";

			this.resourceFactories[facet].$uuid = function(_, instance) {
				return instance.class.properties['AUUID'] ? instance.get(_, 'AUUID') : tuuid.generate();
			};
			if (facet === "$edit") {
				this.resourceFactories[facet].$attributes = function(node, property, attributes) {
					// Manage attributes :
					Object.keys(attributes).forEach(function(attribute) {
						if (extAttributesObject[attribute] !== undefined) {
							// It's an object attribute :
							node[property] = node[property] || {};
							node[property][attribute] = attributes[attribute];
						} else {
							// It's a meta attribute ($isMandatory ...)
							node.$properties = node.$properties || {};
							node.$properties[property] = node.$properties[property] || {};
							node.$properties[property].$attributes = node.$properties[property].$attributes || {};
							node.$properties[property].$attributes[attribute] = attributes[attribute];
						}
					});
				};
				this.resourceFactories[facet].$diagnoses = function(node, property, diagnoses) {
					if (diagnoses === null || diagnoses.length) {
						var target = node;
						if (property) {
							node.$properties = node.$properties || {};
							target = node.$properties[property] = node.$properties[property] || {};
							target.$diagnoses = (diagnoses === null) ? null :
								diagnoses.map(function(diagnose) {
									return (diagnose && diagnose.dataNode()) || null;
								});
						} else {
							var diags = diagnoses
								.filter(function(diagnose) {
									return diagnose !== null && diagnose !== undefined;
								})
								.map(function(diagnose) {
									return diagnose.dataNode();
								});
							if (diags.length) target.$diagnoses = diags;
						}
					}
				};
			}

			var bindProperty = function(property, factory) {
				var factProperty;
				if (property) {
					factProperty = property.clone();
					factProperty.resourceFactory = factory;
				}
				return factProperty;
			};

			this.exportedProperties.filter(function(expprop) {
				return expprop.data[facetFlagPRO] === 2;
			}).forEach_(_, function(_, exppro) {
				var path = exppro.data.CODPRO.split('.');
				var container = this;
				var im = this.class;
				var f = factory,
					i = 0,
					prop;

				if (this.relations && this.relations[path[0]]) {
					if (!(prop = factory.properties[path[0]])) {
						prop = this.properties[path[0]];
						prop = bindProperty(prop, factory);
						prop.tag = path[0];
						prop.targetResourceFactory = this.supervisor.new(_,
							'ResourceFactory',
							this,
							facet,
							path[0],
							this.relations[path[0]].class);
						factory.properties[path[0]] = prop;
					}
					f = prop.targetResourceFactory;
					prop = this.relations[path[0]].class.properties[path[1]];
					prop = bindProperty(prop, factory);
					f.properties[path[i]] = prop;
				} else if (path[0] === this.data.ABRCLA) {
					container = this.class;
					i++;
					for (; i < path.length - 1; i++) {
						var coln = container.relations[path[i]];
						if (!coln) throw new Error("path does not match collection: " + path.slice(0, i + 1));
						if (!(prop = f.properties[path[i]])) {
							prop = bindProperty(container.property(path[i]), f);
							prop.tag = path.slice(0, i + 1).join('');
							f.properties[path[i]] = prop;
						}
						im = coln.class;
						if (!im) return console.error("ignoring collection " + path.slice(0, i + 1));
						container = im;
						f = prop.targetResourceFactory || (prop.targetResourceFactory = this.supervisor.new(_, 'ResourceFactory', this, facet, path.slice(0, i + 1), im));
					}

					prop = bindProperty(im.properties[path[i]], f);
				} else if (this.properties[path[0]]) {
					prop = bindProperty(this.properties[path[0]], factory);
				}

				if (!prop) throw new Error("property not found: " + path);

				prop.exportedProperty = exppro;
				prop.tag = exppro.data.ALIAS;
				exppro.tag = prop.tag;
				prop.belongsToKey = f.class.keyItems.indexOf(path[i]) >= 0;
				prop.isKey = (f.class.keyItems.length === 1 && prop.belongsToKey);
				if (prop.resourceFactory && prop.resourceFactory.keyItems && prop.belongsToKey === true) {
					//don't use push -> change the order of the items in the key
					//					prop.resourceFactory.keyItems.push({
					//						alias: prop.tag,
					//						prop: path[i]
					//					});
					prop.resourceFactory.keyItems[f.class.keyItems.indexOf(path[i])] = {
						alias: prop.tag,
						prop: path[i]
					};
				}
				prop.hasLookup = !! (prop.type && prop.type.data && prop.type.data.INDREF);
				if (!prop.hasLookup) {
					// looking into current facet is too restrictive. We have to look into all.
					// so we cannot use prop.links because it is filtered by facet
					//var self = this;
					prop.hasLookup = self.links.some(function(linkData) {
						//18/09/15
						//var hasLookup = (linkData.ANCLNK === prop.exportedProperty.data.CODPRO && linkData.AFFLNK === 1 && linkData.ATTLNK === 3 && linkData[facetFlagLNK] === 2 && !(prop.isKey && linkData.REPLNK === self.name)); // ignore if key property that points to current representation
						var hasLookup = (linkData.ANCLNK === prop.exportedProperty.data.CODPRO && linkData.AFFLNK === 1 && linkData.ATTLNK === 3 && !(prop.isKey && linkData.REPLNK === self.name)); // ignore if key property that points to current representation
						//		&& !(prop.isKey && linkData.REPLNK === self.name); // ignore if key property that points to current representation
						if (hasLookup === true) {
							self.data.PARAMS.forEach(function(paramData) {
								if (paramData.TYPPAR === 3 && paramData.TYPKEY === 2 && paramData.CODLNK === linkData.oCODLNK && paramData.AFFLNK === linkData.oAFFLNK && paramData.CODFLD === linkData.ANCLNK && paramData.VALEUR === prop.exportedProperty.data.CODPRO) {
									prop.destLookup = paramData.CODPAR;
									prop.repLookup = linkData.REPLNK;
								}
							});
						}
						return hasLookup;
					});
				}

				prop._isReference = prop.hasLookup && prop.isReference(_);

				if (prop._isReference === true && prop.repLookup) {
					var r;
					if (prop.repLookup === self.name) r = self;
					else r = self.supervisor.load(_, 'Representation', prop.repLookup);
					var dest = util.find(r.data.EXPORTED_PROPERTIES, "CODPRO", r.data.ABRCLA + "." + prop.destLookup);
					if (dest) prop.destLookup = dest.ALIAS;
				}

				tracerJs.debug && tracerJs.debug("representation." + prop.tag + " hasLookup  :" + prop.hasLookup);
				tracerJs.debug && tracerJs.debug("representation." + prop.tag + " isReference:" + prop._isReference + " (" + prop.tag + ")");

				f.properties[path[i]] = prop;
				if (prop.isExtra === true && prop.isReference(_)) {
					// Add a property :
					var prop2 = bindProperty(prop, factory);
					prop2.isExtraRef = true;
					prop2.isReference(_, true);
					f.properties[prop2.ref(path[i])] = prop2;
					f.cache = f.cache || new Cache();
					f.cache.addReference(_, prop);
				}
			}, this);

			if (facet === "$edit") {
				var linksSave = {};
				var linksAbort = {};
				this.links.filter(function(link) {
					return link.FLGSTDLNK === 2 && link.TYPLNK === 1 && link.AFFLNK > 3;
				}).forEach_(_, function(_, link) {
					var l;
					if (link.AFFLNK === 4 && link.TYPLNK === 1 && link.CMPLNK === 5) { //Query
						l = this.supervisor.new(_, 'Link', factory, link);
						//prepare keys+params
						l.prepareKeyparams(this);
						linksSave.$query = l;
						linksAbort.$query = l;
					} else if ((link.AFFLNK === 4 || link.AFFLNK === 5) && link.TYPLNK === 1 && link.CMPLNK === 2 && link.ATTLNK > 1) { //Detail
						l = this.supervisor.new(_, 'Link', factory, link);
						//prepare keys+params
						l.prepareKeyparams(this);
						linksSave.$details = l;
						linksAbort.$details = l;
					} else if ((link.AFFLNK === 4 || link.AFFLNK === 5) && link.TYPLNK === 1 && link.CMPLNK === 3) { //Edit
						l = this.supervisor.new(_, 'Link', factory, link);
						//prepare keys+params
						l.prepareKeyparams(this);
						linksSave.$edit = l;
					}
				}, this);
			}
			this.links.filter(function(link) {
				return link[facetFlagLNK] === 2;
			}).forEach_(_, function(_, link) {
				var path = (link.ANCLNK || "").split('.');
				var f = factory;
				var p = null;
				if (path[0] === this.data.ABRCLA) {
					path.shift();
				}
				for (var i = 0; i < path.length - 1; i++) {
					p = f.properties[path[i]];
					if (!p) {
						/* property is not exposed on the facet */
						return;
					}
					f = p.targetResourceFactory;
					if (!f) {
						throw new Error("bad anchor path: " + path.slice(0, i + 1));
					}
				}
				var anchor;
				switch (link.AFFLNK) {
					case 1:
						// property
						anchor = f.properties[path[i]];
						// anchor is null on ATYPE/NOLIB: query facet contains link but does not contain property!!!
						//if (!anchor) return console.log("*** BAD LINK ANCHOR: " + path), console.log(link);
						if (!anchor) return;
						break;
					case 2:
						// collection element
						anchor = f;
						break;
					case 3:
						// collection -- ???
						anchor = p;
						break;
					case 4:
						// page
						anchor = factory.page;
						break;
					case 5:
						// query row
						anchor = factory;
						break;
				}
				if (!anchor) throw new Error("bad anchor path: " + path);
				anchor.links = anchor.links || {};
				var l = this.supervisor.new(_, 'Link', anchor, link);
				anchor.links[l.name] = l;
				//links for actions save and abort
				if (facet === "$edit" && link.FLGSTDLNK === 2) {
					if (link.AFFLNK === 4 && link.TYPLNK === 1 && link.CMPLNK === 17) { //Save
						l.links = linksSave;
					} else if (link.AFFLNK === 4 && link.TYPLNK === 1 && link.CMPLNK === 18) { //Abort
						l.links = linksAbort;
					}
				}
				//prepare keys+params
				l.prepareKeyparams(this);
			}, this);
			return factory;
		},
		filtersProto: function(_, resourceFactory) {
			var tabcor = resourceFactory.filtersTabCor(_);

			var self = this;
			var myopt = {};
			this.data.OPTIONS.forEach_(_, function(_, opt) {
				var cond = true;
				var where;
				if (opt.OPTFLGCLA === 2) {
					var id = self.class.data.OPTIONS.indexOf(opt.OPTCOD);
					if (!id) cond = false;
					else {
						myopt[opt.OPTCOD] = {};
						myopt[opt.OPTCOD].$title = this.supervisor.loadText(_, self.class.data.OPTIONS.OPTLIB);
						where = Sdata.x3ToSdata(tabcor, self.class.data.OPTIONS.OPTCND);
						myopt[opt.OPTCOD].$where = where();
					}
				} else {
					myopt[opt.OPTCOD] = {};
					myopt[opt.OPTCOD].$title = this.supervisor.loadText(_, opt.OPTLIB);
					where = Sdata.x3ToSdata(tabcor, opt.OPTCND);
					myopt[opt.OPTCOD].$where = where();
				}
				if (cond === true) {
					if (opt.OPTDEF === 2) {
						myopt[opt.OPTCOD].$isDefault = true;
					}
					if (opt.OPTOBY === 2) {
						myopt[opt.OPTCOD].$isMandatory = true;
						myopt[opt.OPTCOD].$isHidden = true;
					}
					if (opt.OPTACT !== undefined && activ.getActiv(_, self.supervisor, opt.OPTACT) <= 0) { // GH 6167
						myopt[opt.OPTCOD].$isHidden = true; // GH 6167
					} // GH 6167
				}
			}, this);
			return myopt;
		},
		articleLayout: function(_, facet) {
			return {
				$layout: {
					$items: this.data.SECTIONS.sort(function(s1, s2) {
						return s1.NIVSEC - s2.NIVSEC;
					}).map_(_, function(_, section) {
						return {
							$category: "section",
							$title: this.supervisor.loadText(_, section.INTSEC),
							$layout: {
								$items: this.data.BLOCKS.filter(function(block) {
									return block.SECBLC === section.CODSEC;
								}).sort(function(b1, b2) {
									return b1.NIVBLC - b2.NIVBLC;
								}).map_(_, function(_, block) {
									//
									function findProp(prop, facet) {
										var condProp = false;
										if (prop.exportedProperty.data.BLCPRO === block.CODBLC) {
											condProp = (prop.exportedProperty.data[FACETS[facet].prefix + "PRO"] === 2 && prop.exportedProperty.data["STA" + FACETS[facet].prefix + "PRO"] !== 3);
											return {
												cond: condProp,
												ordre: prop.exportedProperty.data.ORDPRO
											};
										}
										return {
											cond: false,
											ordre: 0
										};
									}
									//
									function findCol(targetResourceFactory, facet) {
										var condCol = {
											cond: false,
											ordre: 0
										};
										Object.keys(targetResourceFactory.properties).some(function(prop) {
											if (targetResourceFactory.properties[prop].exportedProperty) {
												condCol = findProp(targetResourceFactory.properties[prop], facet);
												return condCol.cond === true;
											} else if (targetResourceFactory.properties[prop].targetResourceFactory) {
												condCol = findCol(targetResourceFactory.properties[prop].targetResourceFactory, facet);
												return condCol.cond === true;
											}

										});
										return condCol;
									}
									//
									//
									function getColTarget(targetResourceFactory, facet, r, condTarget) {
										Object.keys(targetResourceFactory.properties).forEach(function(prop) {
											var condBind = {
												cond: false,
												ordre: 0
											};
											if (targetResourceFactory.properties[prop].exportedProperty && condTarget.cond === false) {
												condBind = findProp(targetResourceFactory.properties[prop], facet);
												if (condBind.cond === true) {
													condTarget.cond = true;
													condTarget.ordre = condBind.ordre;
												}
											} else if (targetResourceFactory.properties[prop].collection && targetResourceFactory.properties[prop].collection.mappingData && targetResourceFactory.properties[prop].collection.mappingData.TYPLNK === 3) {
												//1-1 collection
												r = getCol(targetResourceFactory.properties[prop].targetResourceFactory, facet, r);
											} else if (targetResourceFactory.properties[prop].targetResourceFactory) {
												condBind = findCol(targetResourceFactory.properties[prop].targetResourceFactory, facet);
												if (condBind.cond === true) r[targetResourceFactory.properties[prop].tag] = condBind.ordre;
											}

										});
										return r;
									}

									function getCol(targetResourceFactory, facet, r) {
										Object.keys(targetResourceFactory.properties).forEach(function(prop) {
											var condBind = {
												cond: false,
												ordre: 0
											};
											if (targetResourceFactory.properties[prop].exportedProperty) {
												condBind = findProp(targetResourceFactory.properties[prop], facet);
												if (condBind.cond === true) {
													var tprop = targetResourceFactory.properties[prop];
													if (targetResourceFactory.properties[prop]._isReference) {
														r[tprop.ref(tprop.tag)] = condBind.ordre;
													} else {
														r[tprop.tag] = condBind.ordre;
													}
												}
											} else if (targetResourceFactory.properties[prop].collection && targetResourceFactory.properties[prop].collection.mappingData && targetResourceFactory.properties[prop].collection.mappingData.TYPLNK === 3) {
												//1-1 collection
												r = getCol(targetResourceFactory.properties[prop].targetResourceFactory, facet, r);
											} else if (targetResourceFactory.properties[prop].targetResourceFactory) {
												//condBind = findCol(targetResourceFactory.properties[prop].targetResourceFactory, facet);
												condBind.cond = false;
												condBind.ordre = 0;
												r = getColTarget(targetResourceFactory.properties[prop].targetResourceFactory, facet, r, condBind);
												if (condBind.cond === true) r[targetResourceFactory.properties[prop].tag] = condBind.ordre;
											}

										});
										return r;
									}

									//
									var resourceFactory = this.resourceFactory(_, facet);
									var items = getCol(resourceFactory, facet, {});

									items = Object.keys(items).sort(function(item1, item2) {
										return items[item1] - items[item2];
									});

									items = Object.keys(items).map(function(no) {
										return {
											$bind: items[no],
										};
									});
									return {
										$category: "block",
										$title: this.supervisor.loadText(_, block.INTBLC),
										$layout: {
											$items: items,
										},
									};
								}, this, facet),
							},
						};
					}, this, facet),
				},
			};
		},
		article: function(_, facet, f) {
			var article = {};
			//Layout
			if (/^\$(details|edit|summary)$/.test(facet)) article = this.articleLayout(_, facet);

			function trimLayout(obj) {
				var hasElt = false;
				var hasBind = false;
				var new_items = [];
				if (obj.$layout.$items.length > 0) {
					obj.$layout.$items.forEach(function(item) {
						if (item.$bind) hasBind = true;
						else hasBind = trimLayout(item);
						if (hasBind === true) {
							hasElt = true;
							new_items.push(item);
						}
					});
				}
				obj.$layout.$items = new_items;
				return hasElt;
			}
			if (article.$layout)
				trimLayout(article);

			//Menu
			function fillMenu(facet, self, tabLinks, curMenu, items) {
				var hasElt = false;
				if (tabLinks) {
					Object.keys(tabLinks).filter(function(name) {
						tabLinks[name].data.MENLNK = tabLinks[name].data.MENLNK || "";
						//#SAM 108421 no abort
						return tabLinks[name].data.MENLNK === curMenu && tabLinks[name].data.CMPLNK !== 18;
					}).forEach(function(name) {
						hasElt = true;
						var new_item = {
							$bind: name,
							$order: tabLinks[name].data.ORDTECLNK,
						};
						//#SAM 108421 $style -> $kind
						if (self.data.DEFLNKFAC[FACETS[facet].id] !== 2) {
							if (self.data.AFFLNKFAC[FACETS[facet].id] === tabLinks[name].data.oAFFLNK && self.data.LNKMENFAC[FACETS[facet].id] === tabLinks[name].data.oCODLNK) {
								new_item.$kind = "main";
							}
						} else if (self.data.FONCTION !== undefined && facet === "$query") {
							if (name === "$edit") new_item.$kind = "main";
						} else if (name === FACETS[facet].mainMenu) new_item.$kind = "main";
						items.push(new_item);
					});
				}
				return hasElt;
			}

			function fillMenuMen(_, facet, self, tabMenus, curMenu, links1, links2, items) {
				var hasElt = false;
				var selfItems = items;
				if (tabMenus) {
					tabMenus.filter_(_, function(_, menu) {
						var okMenu = 1;
						menu.PARMENU = menu.PARMENU || "";
						if (menu.PARMENU !== curMenu) okMenu = 0;
						if (okMenu === 1 && menu.ACTMENU && activ.getActiv(_, self.supervisor, menu.ACTMENU) <= 0)
							okMenu = 0;
						return okMenu === 1;
					}).forEach_(_, function(_, menu) {
						var hasBind = false;
						var new_item = {
							$title: self.supervisor.loadText(_, menu.LIBMENU),
							$CODMENU: menu.CODMENU,
							$PARMENU: menu.PARMENU,
							$category: "menus",
							$isBoxCollapsable: true,
							$opened: false,
							$layout: {
								$items: []
							}
						};
						var items = new_item.$layout.$items;
						var hasBind1 = fillMenu(facet, self, links1, menu.CODMENU, items);
						var hasBind2 = fillMenu(facet, self, links2, menu.CODMENU, items);
						items = items.sort(function(item1, item2) {
							return item1.$order - item2.$order;
						});
						items.forEach(function(item) {
							delete item.$order;
						});
						if (hasBind1 === true || hasBind2 === true) {
							hasElt = true;
						}
						hasBind = fillMenuMen(_, facet, self, tabMenus, menu.CODMENU, links1, links2, items);
						if (hasBind1 === true || hasBind2 === true || hasBind === true) {
							selfItems.push(new_item);
						}
					});
					return hasElt;
				}
			}

			article.$menus = {
				$layout: {
					$items: []
				}
			};
			if (facet !== '$bulk') {
				var items = article.$menus.$layout.$items;
				if (["$query", "$lookup"].indexOf(facet) < 0) fillMenu(facet, this, f.links, "", items);
				fillMenu(facet, this, f.page && f.page.links, "", items);
				items = items.sort(function(item1, item2) {
					return item1.$order - item2.$order;
				});
				items.forEach(function(item) {
					delete item.$order;
				});
				fillMenuMen(_, facet, this, this.data.MENUS, "", (["$query", "$lookup"].indexOf(facet) < 0 ? f.links : undefined), (f.page && f.page.links), items);
			}

			return article;
		},
		proto: function(_, facet) {
			var f = this.resourceFactory(_, facet);
			var proto = f.pageProto(_);
			if (/^\$(query|bulk|lookup)$/.test(facet)) proto.$filters = this.filtersProto(_, f);
			if (proto.$filters && Object.keys(proto.$filters).length === 0) proto.$filters = undefined;

			proto.$article = this.article(_, facet, f);

			return proto;
		},
		loadResource: function(_, key, facet, qs) {
			return this.resourceFactory(_, facet).loadResource(_, key, qs);
		},
		createResource: function(_, qs) {
			return this.resourceFactory(_, "$edit").createResource(_, qs);
		},
		deleteResource: function(_, httpContext, key, facet, qs) {
			return this.resourceFactory(_, facet).deleteResource(_, httpContext, key, qs);
		},
		query: function(_, httpContext, facet, qs) {
			return this.resourceFactory(_, facet).query(_, httpContext, qs);
		},
		action: function(_, action) {
			var astatus = this._action(_, action);
			if (astatus !== constants.CST_AERROR) {
				astatus = this.class._action(_, action);
			}
			return astatus;
		},
		beforeQuery: function(_) {
			return this.action(_, "AQUERY_OPEN");
		},
		afterQuery: function(_) {
			return this.action(_, "AQUERY_CLOSE");
		},
		service: function(_, keys, $service, facet, qs) {
			var reply = {};
			reply.$baseUrl = this.supervisor.baseUrl;
			reply.$prototype = "{$baseUrl}/$prototype('{$representation}.$thumb')",
			reply.$representation = this.name;
			reply.$url = "{$baseUrl}/" + this.data.CODCLA + "('" + keys + "')";
			reply.$url += "?representation=" + this.name + "." + facet;
			reply.$type = "application/json;vnd.sage=syracuse";
			reply.$etag = 1;
			reply.ETag = 0;
			reply.$uuid = tuuid.generate().x3ToString();
			reply.$actions = {};
			reply.$actions[$service] = {
				$diagnoses: [],
				$return: {}
			};
			var f = this.resourceFactory(_, facet);
			var links = this.links.filter(function(link) {
				return (link.AFFLNK == 5 || link.AFFLNK == 4) && link.TYPLNK == 3 && link.CODLNK === $service;
			});
			if (!links || !links[0]) throw new util.HttpError(400, this.name + ' : ' + this.supervisor.loadMessParams(_, 149, 40, $service));

			var service = links[0].CODOPELNK;
			var codcla = links[0].CLALNK;
			tracerJs.debug && tracerJs.debug("repr:" + this.name + " class:" + this.data.CODCLA + " service:" + service);
			this.deleteErrors(_);
			var cl = this.supervisor.load(_, 'Class', codcla);
			if (!cl) throw new util.HttpError(400, this.supervisor.loadMess(_, 140, 4) + " " + codcla);
			var ins = cl.createInstance(_);

			var meth = ins.xmet(service);
			if (!meth) throw new util.HttpError(400, this.data.CODCLA + " : " + this.supervisor.loadMess(_, 143, 172) + " " + service);
			var param = cl.methods[service].Service.getArgs(_, keys, qs);
			// Support methods with variables parameters:
			var res = meth.apply_(_, ins, param, 0);
			//var status = this.action(_, service);
			if (res === undefined) {
				reply.$actions[$service].$diagnoses = ins.diagnoses;
			} else {
				var diagnose = {
					$severity: "success",
					$message: this.supervisor.loadMessParams(_, 143, 221, service),
				};
				reply.$actions[$service].$diagnoses.push(diagnose);
				reply.$actions[$service].$return = cl.methods[service].Service.getReturn(_, res);
			}
			return reply;
		}
	}),
	FACETS: FACETS,
};