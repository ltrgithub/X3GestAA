"use strict";

var util = require("etna-supervisor/lib/util");

// order of keys matches ENAFAC values so that we can fill FacetIds
var FACETS = {
	$details: {
		id: 0,
		prefix: "DET",
	},
	$edit: {
		id: 1,
		prefix: "EDI",
	},
	$query: {
		id: 2,
		prefix: "QRY",
	},
	$lookup: {
		id: 3,
		prefix: "LOK",
	},
	$summary: {
		id: 4,
		prefix: "SUM",
	},
	$bulk: { // for now, same as query
		id: 2,
		prefix: "QRY",
	},
};

var deviceCodes = {
	desktop: 1,
	phone: 2,
	tablet: 3,
};

module.exports = {
	collectionName: 'ASHW',
	keyName: 'CODREP',
	constructor: util.defineClass(function(superv, data) {
		this.superv = superv;
		this.data = data;
	}, null, {
		init: function(_) {
			if (this.resourceFactories) return;
			this.resourceFactories = {};
			this.class = this.class || this.superv.load(_, 'Class', this.data.CODCLA);
			if (!this.class) throw new Error("class not found: " + this.data.CODCLA);
			this.exportedProperties = this.data.EXPORTED_PROPERTIES.map_(_, function(_, data) {
				return this.superv.new(_, 'ExportedProperty', this, data);
			}, this);
			return this;
		},
		name: {
			get: function() {
				return this.data.CODREP;
			}
		},
		title: function(_) {
			return this.superv.loadText(_, this.data.INTREP);
		},
		table: {
			get: function() {
				return this.class.table;
			}
		},
		isFacetEnabled: function(facet) {
			return this.data.ENAFAC[FACETS[facet].id] === 2;
		},
		checkDevice: function(device) {
			var code = deviceCodes[device];
			if (code != null) {
				if (this.data.TYPMSKREP === 2) return; // keep unit test happy (mobile representation always accepted?)
				if (code !== this.data.TYPMSKREP) throw new util.HttpError(406, "device mismatch: " + device);
			} else {
				if (device) throw new util.HttpError(415, "unknown device: " + device);
			}
		},
		resourceFactory: function(_, facet) {
			var factory = this.resourceFactories[facet];
			if (factory) return factory;
			var instanceFactory = this.class.instanceFactory;
			var factory = this.superv.new(_, 'ResourceFactory', this, facet, [], instanceFactory);
			this.resourceFactories[facet] = factory;

			var facetFlag = FACETS[facet].prefix + "PRO";
			this.exportedProperties.filter(function(expprop) {
				return expprop.data[facetFlag] === 2;
			}).forEach_(_, function(_, exppro) {
				var path = exppro.data.CODPRO.split('.');
				var container = this;
				var im = instanceFactory;
				var f = factory,
					i = 0,
					prop;
				if (path[0] === this.data.ABRCLA) {
					container = this.class;
					i++;
				}
				for (; i < path.length - 1; i++) {
					var coln = container.collection(path[i]);
					if (!coln) throw new Error("path does not match collection: " + path.slice(0, i + 1));
					if (!(prop = f.properties[path[i]])) {
						prop = container.property(path[i]).clone(this);
						prop.resourceFactory = f;
						prop.collection = coln;
						prop.tag = path.slice(0, i + 1).join('');
						f.properties[path[i]] = prop;
					}
					im = coln.instanceFactory;
					if (!im) return console.error("ignoring collection " + path.slice(0, i + 1));
					container = im.class;
					f = prop.targetResourceFactory || (prop.targetResourceFactory = this.superv.new(_, 'ResourceFactory', this, facet, path.slice(0, i + 1), im));
				}
				prop = im.properties[path[i]];
				if (prop) {
					prop = prop.clone(this);
					prop.resourceFactory = f;
				} else if (i === 0) {
					var propData = util.find(this.data.PROPERTIES, 'CODFLD', path[i]);
					if (!propData) throw new Error("representation property not found: " + path);
					prop = this.superv.new(_, 'Property', this, propData);
					prop.resourceFactory = factory;
					prop.isExtra = true;
				} else {
					throw new Error("property not found: " + path);
				}
				prop.exportedProperty = exppro;
				prop.tag = exppro.data.ALIAS;
				prop.belongsToKey = f.instanceFactory.class.keyItems.indexOf(path[i]) >= 0;
				f.properties[path[i]] = prop;
			}, this);

			facetFlag = FACETS[facet].prefix + "LNK";
			this.data.LINKS.filter(function(link) {
				return link[facetFlag] === 2;
			}).forEach_(_, function(_, link) {
				var path = (link.ANCLNK || "").split('.');
				var f = factory;
				if (path[0] === this.data.ABRCLA) {
					path.shift();
				}
				for (var i = 0; i < path.length - 1; i++) {
					var p = f.properties[path[i]];
					if (!p) throw new Error("bad anchor path: " + path.slice(0, i + 1));
					f = p.targetResourceFactory;
					if (!f) throw new Error("bad anchor path: " + path.slice(0, i + 1));
				}
				var anchor;
				switch (link.AFFLNK) {
				case 1:
					// property
					anchor = f.properties[path[i]];
					// anchor is null on ATYPE/NOLIB: query facet contains link but does not contain property!!!
					if (!anchor) return console.log("*** BAD LINK ANCHOR: " + path), console.log(link);
					break;
				case 2:
					// collection element
					anchor = f;
					break;
				case 3:
					// collection -- ???
					anchor = p;
					break;
				case 4:
					// page
					anchor = factory.page;
					break;
				case 5:
					// query row
					anchor = factory;
					break;
				}
				if (!anchor) throw console.log(link), new Error("bad anchor path: " + path);
				anchor.links = anchor.links || {};
				var l = this.superv.new(_, 'Link', anchor, link);
				anchor.links[l.name] = l;
			}, this);
			return factory;
		},
		links: function(_, facet) {
			var facetFlag = FACETS[facet].prefix + "LNK";
			return this.data.LINKS.filter(function(link) {
				return link[facetFlag] === 2;
			}).map_(_, function(_, link) {
				return this.link(_, link);
			}, this);
		},
		article: function(_) {
			return {
				$layout: {
					$items: this.data.SECTIONS.sort(function(s1, s2) {
						return s1.NIVSEC - s2.NIVSEC;
					}).map_(_, function(_, section) {
						return {
							$category: "section",
							$title: this.superv.loadText(_, section.INTSEC),
							$layout: {
								$items: this.data.BLOCKS.filter(function(block) {
									return block.SECBLC === section.CODSEC;
								}).sort(function(b1, b2) {
									return b1.NIVBLC - b2.NIVBLC;
								}).map_(_, function(_, block) {
									var items = this.data.EXPORTED_PROPERTIES.filter(function(prop) {
										return prop.BLCPRO === block.CODBLC;
									}).reduce(function(r, prop) {
										var names = prop.CODPRO.split('.');
										r[names[names.length > 1 ? 1 : 0]] = true;
										return r;
									}, {});
									items = Object.keys(items).map(function(name) {
										return {
											$bind: name,
										};
									});
									return {
										$category: "block",
										$title: this.superv.loadText(_, block.INTBLC),
										$layout: {
											$items: items,
										},
									};
								}, this),
							},
						};
					}, this),
				},
			};
		},
		proto: function(_, facet) {
			var f = this.resourceFactory(_, facet);
			var proto = f.pageProto(_);
			if (/^\$(details|edit)facet$/.test(facet)) proto.$article = this.article(_);
			else proto.$article = {};
			proto.$article.$menus = {
				$layout: {
					$items: []
				}
			};
			var items = proto.$article.$menus.$layout.$items;

			function fillMenu(links) {
				if (links) {
					Object.keys(links).forEach(function(name) {
						items.push({
							$bind: name,
							$order: links[name].data.ORDTECLNK,
						});
					});
				}
			}
			if (facet !== '$bulk') {
				if (facet !== '$query') fillMenu(f.links);
				fillMenu(f.page && f.page.links);
				items = items.sort(function(item1, item2) {
					return item1.$order - item2.$order;
				});
				items.forEach(function(item) {
					delete item.$order;
				});
				if (items.length) items[0].$style = "main";
			}
			return proto;
		},
		loadResource: function(_, key, facet, qs) {
			return this.resourceFactory(_, facet).loadResource(_, key, qs);
		},
		createResource: function(_, qs) {
			return this.resourceFactory(_, "$edit").createResource(_, qs);
		},
		query: function(_, facet, qs) {
			return this.resourceFactory(_, facet).query(_, qs);
		},
	}),
	FACETS: FACETS,
}