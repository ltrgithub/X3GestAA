"use strict";

var util = require("etna-supervisor/lib/util");

var parser = require('syracuse-sdata/lib/parser/parser');
var filterHelpers = require("syracuse-orm/lib/filters");
var ez = require("ez-streams");

function bulkWriter(httpContext) {
	var sep;
	return ez.devices.generic.writer(function(_, resource) {
		if (resource === undefined) {
			httpContext.response.end("]}");
		} else {
			if (!sep) {
				httpContext.response.writeHead(200, {
					"content-type": "application/json"
				});
				httpContext.response.write(_, '{"$resources":[');
			}
			httpContext.response.write(_, (sep || '') + JSON.stringify(resource.dataNode(_)), "utf8");
		}
		sep = ',';
	});
};

exports.constructor = util.defineClass(function(superv, repr, facet, path, clas) {
	this.supervisor = superv;
	this.representation = repr;
	this.facet = facet;
	this.path = path;
	this.class = clas;
	this.properties = {}; // exposed properties only
	this.links = {};
	this.page = {
		links: {},
		representation: repr,
		class: clas,
	};
}, null, {
	init: function(_) {
		return this;
	},
	fillTypeNode: function(_, node) {
		node.$type = "application/x-array"; //this.collection.data.MAXCOL > 1 ? "application/x-array" : "application/x-object";
		node.$item = this.itemProto(_);
	},
	isReference: function(prop) {
		if (prop.type.data.INDREF) return true;
		// looking into current facet is too restrictive. We have to look into all.
		// so we cannot use prop.links because it is filtered by facet
		var self = this;
		return self.representation.data.LINKS.some(function(linkData) {
			return linkData.CMPLNK === 9 && linkData.AFFLNK === 1 && linkData.ANCLNK === prop.exportedProperty.data.CODPRO //
			&& !(prop.belongsToKey && linkData.REPLNK === self.representation.name); // ignore if key property that points to current representation
		});
	},
	itemProto: function(_, facet) {
		var key = this.keyExpression(_);
		var proto = {
			$properties: {},
		};
		if (facet) {
			var repDotFacet = this.representation.name + "." + facet;
			proto.$url = "{$baseUrl}/" + this.representation.class.name + "('{$key}')?representation=" + repDotFacet;
			proto.$type = "{$baseType}." + repDotFacet;
			proto.$key = key;
			proto.$value = key;
			if (this.representation.class.table) {
				var title = this.representation.class.table.data.INTIT;
				proto.$description = proto.$title = title ? "{" + this.representation.class.table.data.INTIT + "}" : "";
			} else {
				proto.$description = proto.$title = "";
			}
		} else {
			proto.$type = "application/json";
			proto.$value = key;
		}
		var self = this;
		Object.keys(self.properties).forEach_(_, function(_, name) {
			// function isReference(prop) {
			// 	if (prop.type.data.INDREF) return true;
			// 	// looking into current facet is too restrictive. We have to look into all.
			// 	// so we cannot use prop.links because it is filtered by facet
			// 	return self.representation.data.LINKS.some(function(linkData) {
			// 		return linkData.CMPLNK === 9 && linkData.AFFLNK === 1 && linkData.ANCLNK === prop.exportedProperty.data.CODPRO //
			// 		&& !(prop.belongsToKey && linkData.REPLNK === self.representation.name); // ignore if key property that points to current representation
			// 	});
			// }
			var prop = self.properties[name];
			var p = proto.$properties[prop.tag || name] = prop.prototypeNode(_);
			if (p && prop.type && prop.type.data.CODCLA && self.isReference(prop)) {
				//  || prop.type.data.OBJLIEN
				//if (p && prop.type && prop.type.data.CODCLA && (prop.type.data.TYPSELSYR === 2)) {
				// don't treat primary key of master factory as a reference.
				proto.$properties[name + "_REF"] = prop.prototypeRefNode(_, p);
			}
		}, this);
		if (this.facet !== "$bulk") Object.keys(self.links).forEach_(_, function(_, name) {
			proto.$links = proto.$links || {};
			proto.$links[name] = self.links[name].prototypeNode(_);
		}, this);
		return proto;
	},
	pageProto: function(_) {
		var pageProto;
		var repDotFacet = this.representation.name + "." + this.facet;
		if (/^\$(query|lookup|bulk)$/.test(this.facet)) {
			pageProto = {
				$url: "{$baseUrl}/" + this.representation.class.name + "?representation=" + repDotFacet,
				$itemsPerPage: 300,
				$properties: {
					$resources: {
						$type: "application/x-array",
						$item: this.itemProto(_, "$queryItem"),
						// unit test fails with: this.facet + "Item"),
					}
				},
			};
		} else {
			pageProto = this.itemProto(_, this.facet);
		}
		// context
		var context = this.supervisor.currentContext(_);
		pageProto.$actxUser = context.builtinProperties.USER().getValue(_);
		pageProto.$actxLogin = context.builtinProperties.LOGIN().getValue(_);
		pageProto.$actxFolder = this.supervisor.folderName;
		pageProto.$actxSolution = this.supervisor.solutionName;
		pageProto.$actxLan = this.supervisor.LAN(_);
		//VVV pageProto.$actxLanIso = this.supervisor.LANISO(_);
		pageProto.$actxLegCur = context.get(_, "AFOLD").get(_, "ALEGCUR");
		pageProto.$actxNbLeg = context.get(_, "AFOLD").get(_, "ANBLEG");

		// $baseType needed for unit test but we could clean it up
		pageProto.$baseType = "application/json;vnd.sage=syracuse;vnd.sage.syracuse.representation=x3.erp.SUPERV";
		pageProto.$type = "{$baseType}." + repDotFacet;
		pageProto.$representation = this.representation.name;
		pageProto.$prototype = "{$baseUrl}/$prototype('{$representation}.$thumb')", pageProto.$device = "desktop"; // for now
		pageProto.$title = this.representation.title(_);
		pageProto.$collaborationUrl = this.supervisor.collaborationUrl;
		pageProto.$baseUrl = this.supervisor.baseUrl;
		pageProto.$repUrl = "{$baseUrl}/" + this.representation.name;
		pageProto.$instanceUrl = "{$repUrl}/" + this.representation.data.ABRCLA;

		if (this.facet !== '$bulk') Object.keys(this.page.links).forEach_(_, function(_, name) {
			pageProto.$links = pageProto.$links || {};
			pageProto.$links[name] = this.page.links[name].prototypeNode(_);
		}, this);
		pageProto.$localization = {}; // keep unit tests happy
		return pageProto;
	},
	loadResource: function(_, key, qs) {
		return this.supervisor.new(_, 'Resource', this, this.class.loadInstance(_, key, qs));
	},
	createResource: function(_, qs) {
		return this.supervisor.new(_, 'Resource', this, this.class.createInstance(_, qs));
	},
	tag2Property: function(tag) {
		if (this.tag2Property.tags === undefined) {
			var self = this;
			this.tag2Property.tags = Object.keys(self.properties).reduce(function(r, property) {
				if (property !== self.properties[property].tag) {
					// Keep memory of tags whose name is different of the property :
					r[tag] = property;
				}
				return r;
			}, {});
		}
		return this.tag2Property.tags[tag] || tag;
	},
	mapTags2Properties: function(o) {
		var _this = this;
		return Object.keys(o).reduce(function(r, tag) {
			var property = _this.tag2Property(tag);
			if (Array.isArray(o[tag])) {
				r[property] = o[tag].reduce(function(a, elt) {
					a.push(_this.mapTags2Properties(elt));
					return a;
				}, []);
			} else if (typeof o[tag] === 'object') {
				r[property] = _this.mapTags2Properties(o[tag]);
			} else {
				r[property] = o[tag];
			}
			return r;
		}, {});
	},
	sdataFilterToJson: function(filter) {
		return this.mapTags2Properties(filterHelpers.sdataFilterToJson(filter));
	},
	query: function(_, httpContext, qs) {
		console.log(this.facet + " " + JSON.stringify(qs));
		var itemsPerPage = qs.count ? parseInt(qs.count, 10) : 20;
		var _this = this;

		var firstPage = true;
		var orderBy;
		var qsOrderBy = [];
		var oAscDesc = ["", "desc", "asc"];
		var kAscDesc = ["", "lt", "gt"];
		var operators = ["eq", "gt", "lt"];

		// Decode the orderBy contained in the url:
		var qsOrderBy = qs.orderBy ? qs.orderBy.split(',') : [];

		// to which we add the representation index	
		var index = _this.representation.index;

		Object.keys(index).forEach(function(idx) {
			qsOrderBy.push(index[idx].name);
		});

		var properties = [];
		var ascDescDefault;
		orderBy = qsOrderBy.reduce(function(r, item) {
			var items = item.split(' ');
			var property = _this.tag2Property(items[0]);
			if (properties.indexOf(property) < 0) {
				var ascDesc = (items.length > 1) ? items[1] : (ascDescDefault || 'asc');
				ascDescDefault = ascDescDefault || ascDesc;
				r.push({
					property: property,
					ascDesc: ascDesc
				});
				properties.push(property);
			}
			return r;
		}, []);

		var wheres = [];
		if (qs.filter) wheres.push(this.representation.filter(qs.filter));
		if (qs.where) wheres.push(this.sdataFilterToJson(qs.where));

		if (qs.key) {
			// Decode the orderBy contained in the url:
			var keyItems = [qs.key];
			var io = qs.key.indexOf('.');
			if (io >= 0) {
				keyItems[0] = qs.key.substring(0, io++);
				keyItems[1] = qs.key.substring(io);
			}
			operators = ["eq", keyItems[0], (keyItems[0] === 'lt') ? 'gt' : 'lt'];

			if (keyItems.length > 1) {
				firstPage = false;
				var keyParts = keyItems[1].split('~');
				var k = 0;

				var tags;
				if (qs.orderBy) {
					tags = qs.orderBy.split(',').reduce(function(r, item) {
						r.push(item.split(' ')[0]);
						return r;
					}, []);
				} else {
					// By default the client doesn't send the orderBy 
					tags = Object.keys(index).reduce(function(r, idx) {
						r.push(index[idx].name);
						return r;
					}, []);
				}

				var args = tags.reduce(function(r, tag) {
					var property = _this.tag2Property(tag);
					r.push({
						property: property,
						value: keyParts[k++]
					});
					return r;
				}, []);

				var exps = [];
				for (var i = 0; i < args.length; i++) {
					var exp = {};
					for (var j = 0, maxJ = (args.length - i); j < maxJ; j++) {
						var k = 1 + (oAscDesc.indexOf(orderBy[0].ascDesc) + oAscDesc.indexOf(orderBy[j].ascDesc)) % 2;
						var operator = operators[Math.floor((j + 1) / maxJ) * k];
						if (operator === 'eq') {
							exp[args[j].property] = args[j].value;
						} else {
							exp[args[j].property] = exp[args[j].property] || {};
							exp[args[j].property]['$' + operator] = args[j].value;
						}
					}
					exps.push(exp);
				}
				wheres.push((exps.length === 1) ? exps[0] : {
					$or: exps
				});
			}
		} else {
			// operators depends on the order by :
			operators = (orderBy[0].ascDesc === 'asc') ? ["eq", "gt", "lt"] : ["eq", "lt", "gt"];
		}
		var ascend = (oAscDesc.indexOf(orderBy[0].ascDesc) + kAscDesc.indexOf(operators[1])) % 2;

		var select = {
			$orderBy: {}
		};
		orderBy.forEach(function(prop) {
			select.$orderBy[prop.property] = (ascend ? -1 : 1) * ((prop.ascDesc === 'asc') ? 1 : -1);
		});

		/*dbg*/ //console.log("wheres.length:" + wheres.length);
		/*dbg*/ //console.log("wheres:" + JSON.stringify(wheres));
		if (wheres.length) {
			select.$query = (wheres.length === 1) ? wheres[0] : {
				$and: wheres
			};
		}

		var fromInstanceToResource = function(_, instance) {
			return this.supervisor.new(_, 'Resource', this, instance);
		}.bind(this);

		// (require itemsPerPage+1 items to manage next link 
		if (/^\$(query|lookup)$/.test(this.facet)) {
			var resources = this.class.queryInstances(_, select, itemsPerPage + 1, fromInstanceToResource).toArray(_);

			// Prepare the feed		
			var feed = {
				$itemsPerPage: itemsPerPage,
				$resources: resources.slice(0, itemsPerPage).map_(_, function(_, res) {
					return res.dataNode(_);
				}),
			};
			if (ascend) feed.$resources = feed.$resources.reverse();

			// Add navigation links :
			if (resources.length) {
				var links = (orderBy[0].ascDesc === 'asc') ? {
					$first: ["gt"],
					$last: ["lt"]
				} : {
					$first: ["lt"],
					$last: ["gt"]
				};

				var names = ["$previous", "$next"];
				var keyNext = operators[1];
				var keyPrevious = keyNext === "lt" ? "gt" : "lt";
				if (ascend) names = names.reverse();

				var linkOrderBy = orderBy.reduce_(_, function(_, r, property) {
					if (!firstPage) {
						links[names[0]] = links[names[0]] || [keyPrevious];
						links[names[0]].push(resources[0].instance.get(_, property.property));
					}
					if (resources.length > itemsPerPage) {
						links[names[1]] = links[names[1]] || [keyNext];
						links[names[1]].push(resources[resources.length - 2].instance.get(_, property.property));
					}
					var item = property.property;
					if (property.ascDesc && property.ascDesc === "desc") item += ' ' + property.ascDesc;
					r.push(item);
					return r;
				}, []);

				Object.keys(links).forEach(function(link) {
					feed.$links = feed.$links || {};
					feed.$links[link] = {
						$url: _this.supervisor.baseUrl + "/" + _this.class.name + "?representation=" + _this.representation.name + ".$query",
						$type: "application/json;vnd.sage=syracuse",
					};
					feed.$links[link].$url += "&key=" + links[link][0];
					if (links[link].length > 1) feed.$links[link].$url += '.' + links[link].slice(1).join('~');
					feed.$links[link].$url += "&orderBy=" + linkOrderBy.join(',');
				});

			}
			return httpContext.jsonReply(_, 200, feed);
		} else if (this.facet === '$bulk') {
			var dst = bulkWriter(httpContext);
			this.class.queryInstances(_, select, qs.count || Infinity, fromInstanceToResource).pipe(_, dst);
		}
	},
	keyExpression: function(_) {
		return this.class.keyExpression(_);
	},
});