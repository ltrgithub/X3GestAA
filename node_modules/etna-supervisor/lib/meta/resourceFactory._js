"use strict";

var util = require("etna-supervisor/lib/util");

exports.constructor = util.defineClass(function(superv, repr, facet, path, clas) {
	this.supervisor = superv;
	this.representation = repr;
	this.facet = facet;
	this.path = path;
	this.class = clas;
	this.properties = {}; // exposed properties only
	this.links = {};
	this.page = {
		links: {},
		representation: repr,
		class: clas,
	};
}, null, {
	init: function(_) {
		return this;
	},
	fillTypeNode: function(_, node) {
		node.$type = "application/x-array"; //this.collection.data.MAXCOL > 1 ? "application/x-array" : "application/x-object";
		node.$item = this.itemProto(_);
	},
	itemProto: function(_, facet) {
		var key = this.keyExpression(_);
		var proto = {
			$properties: {},
		};
		if (facet) {
			var repDotFacet = this.representation.name + "." + facet;
			proto.$url = "{$baseUrl}/" + this.representation.class.name + "('{$key}')?representation=" + repDotFacet;
			proto.$type = "{$baseType}." + repDotFacet;
			proto.$key = key;
			proto.$value = key;
			if (this.representation.class.table) {
				var title = this.representation.class.table.data.INTIT;
				proto.$description = proto.$title = title ? "{" + this.representation.class.table.data.INTIT + "}" : "";
			} else {
				proto.$description = proto.$title = "";
			}
		} else {
			proto.$type = "application/json";
			proto.$value = key;
		}
		var self = this;
		Object.keys(self.properties).forEach_(_, function(_, name) {
			function isReference(prop) {
				if (prop.type.data.INDREF) return true;
				// looking into current facet is too restrictive. We have to look into all.
				// so we cannot use prop.links because it is filtered by facet
				return self.representation.data.LINKS.some(function(linkData) {
					return linkData.CMPLNK === 9 && linkData.AFFLNK === 1 && linkData.ANCLNK === prop.exportedProperty.data.CODPRO //
					&& !(prop.belongsToKey && linkData.REPLNK === self.representation.name); // ignore if key property that points to current representation
				});
			}
			var prop = self.properties[name];
			var p = proto.$properties[prop.tag || name] = prop.prototypeNode(_);
			if (p && prop.type && prop.type.data.CODCLA && isReference(prop)) {
				//  || prop.type.data.OBJLIEN
				//if (p && prop.type && prop.type.data.CODCLA && (prop.type.data.TYPSELSYR === 2)) {
				// don't treat primary key of master factory as a reference.
				proto.$properties[name + "_REF"] = prop.prototypeRefNode(_, p);
			}
		}, this);
		if (this.facet !== "$bulk") Object.keys(self.links).forEach_(_, function(_, name) {
			proto.$links = proto.$links || {};
			proto.$links[name] = self.links[name].prototypeNode(_);
		}, this);
		return proto;
	},
	pageProto: function(_) {
		var pageProto;
		var repDotFacet = this.representation.name + "." + this.facet;
		if (/^\$(query|lookup|bulk)$/.test(this.facet)) {
			pageProto = {
				$url: "{$baseUrl}/" + this.representation.class.name + "?representation=" + repDotFacet,
				$itemsPerPage: 300,
				$properties: {
					$resources: {
						$type: "application/x-array",
						$item: this.itemProto(_, "$queryItem"),
						// unit test fails with: this.facet + "Item"),
					}
				},
			};
		} else {
			pageProto = this.itemProto(_, this.facet);
		}
		// $baseType needed for unit test but we could clean it up
		pageProto.$baseType = "application/json;vnd.sage=syracuse;vnd.sage.syracuse.representation=x3.erp.SUPERV";
		pageProto.$type = "{$baseType}." + repDotFacet;
		pageProto.$representation = this.representation.name;
		pageProto.$prototype = "{$baseUrl}/$prototype('{$representation}.$thumb')", pageProto.$device = "desktop"; // for now
		pageProto.$title = this.representation.title(_);
		pageProto.$baseUrl = this.supervisor.baseUrl;

		if (this.facet !== '$bulk') Object.keys(this.page.links).forEach_(_, function(_, name) {
			pageProto.$links = pageProto.$links || {};
			pageProto.$links[name] = this.page.links[name].prototypeNode(_);
		}, this);
		pageProto.$localization = {}; // keep unit tests happy
		return pageProto;
	},
	loadResource: function(_, key, qs) {
		return this.supervisor.new(_, 'Resource', this, this.class.loadInstance(_, key, qs));
	},
	createResource: function(_, qs) {
		return this.supervisor.new(_, 'Resource', this, this.class.createInstance(_, qs));
	},
	query: function(_, qs) {
		var itemsPerPage = qs.count ? parseInt(qs.count, 10) : 20;
		var resources = this.class.loadInstances(_, null, null, itemsPerPage).map_(_, function(_, resource) {
			return this.supervisor.new(_, 'Resource', this, resource);
		}, this);
		return {
			$itemsPerPage: itemsPerPage,
			$resources: resources.map_(_, function(_, res) {
				return res.dataNode(_);
			}),
		};
	},
	keyExpression: function(_) {
		return this.class.keyExpression(_);
	},
});