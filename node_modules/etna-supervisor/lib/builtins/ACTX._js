"use strict";
var glob = require('streamline/lib/globals');
var util = require("etna-supervisor/lib/util");
var InstanceProperty = require("etna-supervisor/lib/instanceProperty").InstanceProperty;
var attributes = require("etna-supervisor/lib/attributes");
var ACTXCACHE = require("etna-supervisor/lib/builtins/ACTXCACHE");
var ACTXPARAM = require("etna-supervisor/lib/builtins/ACTXPARAM");
var variables = require('etna-engine/lib/runtime/variables');
var system = require('etna-engine/lib/runtime/system');
var X3Rights = require("etna-supervisor/lib/x3Rights._js").X3Rights;
var tracerJs = require("syracuse-trace/lib/helper").getTracer("etna.supervisor");

var locales = {
	' .': /^fr.*/i,
	',.': /^en.*/i
};

var builtinList = ["ASOLUTION", "AFOLDER", "LANISO", "LAN", "LANDEF", "USER", "LOGIN"];

var sessions = {};


// Store context ACTX per session in glob 
// Use cache of sessions
exports.init = function(_, session, superv) {
	tracerJs.debug && tracerJs.debug("ACTX.init session");

	var mysession;
	if (sessions[session.id]) {
		mysession = sessions[session.id];
		// controle + maj ou recreation
		glob.context.x3session = mysession;
		if (mysession.session.locale !== session.locale) {
			// set LANISO+LAN
			mysession.actx.ACTX_SET_LANISO(_, session.locale);
		}
		mysession.session = session;
	} else {
		mysession = {};
		mysession.session = session;
		mysession.supervisor = superv;
		glob.context.x3session = mysession;
		mysession.actx = new(exports.constructor)(superv).init(_);
		// set LOGIN+USER
		mysession.actx.$actxSetLOGIN(_, mysession.session.userName);
		// set LANISO+LAN
		mysession.actx.ACTX_SET_LANISO(_, mysession.session.locale);
		tracerJs.debug && tracerJs.debug("load rights " + mysession.actx.$LOGIN(_));
		mysession.actx._x3Rights.getJsonRights(_, mysession.actx.$LOGIN(_));

		sessions[session.id] = mysession;

	}
};


function _actxmember() {
	return {
		init: function(_) {
			return this;
		},
		set: function(_, name, val) {
			this[name].value = val;
			// TODO : set readonly throw new Error("SET ACTX property " + name);
		},
		get: function(_, name) {
			if (this.desactGet && this[name]) return this[name].value.getValue ? this[name].value.getValue(_) : this[name].value;

			if (name === "APARAM" && !this[name]) {
				this.APARAM = {
					value: new(ACTXPARAM.constructor)(this.supervisor).init(_)
				};
			} else if (name === "ACACHE" && !this[name]) {
				this.ACACHE = {
					value: new(ACTXCACHE.constructor)(this.supervisor).init(_)
				};
			} else {
				this[name] = this[name] || _actxLoadContextProp(_, this, name);
			}
			return this[name].value.getValue ? this[name].value.getValue(_) : this[name].value;
		},
		setPropertyAttribute: function(_, property, attribut, value) {
			return variables.x3Val(this[property].setAttribute(attribut, value));
		},
		getPropertyAttribute: function(_, property, attribut, value) {
			return this[property].getAttribute(attribut);
		},
		//keep this name ACTX_SET_LOGIN for X3 compatibility
		ACTX_SET_LANISO: function(_, laniso) {
			var self = this;
			var rTablan = self.supervisor.sqlDriver.withConnection(_, function(_, cnx) {
				return self.supervisor.sqlReader(_,
					cnx, "select LAN_0,LANISO_0 from TABLAN where (LOWER(LANISO_0)=" + self.supervisor.sqlDriver.param(0) + ")", [laniso.toLowerCase()]).limit(1).toArray(_);

			});
			if (rTablan[0] !== undefined) {
				this.$LANISO(_, rTablan[0].LANISO);
				this.$LAN(_, rTablan[0].LAN);

			} else {
				var rTablan = self.supervisor.sqlDriver.withConnection(_, function(_, cnx) {
					return self.supervisor.sqlReader(_,
						cnx, "select LAN_0,LANISO_0 from TABLAN where (LAN_0=" + self.supervisor.sqlDriver.param(0) + ")", [self.$LANDEF(_)]).limit(1).toArray(_);

				});
				this.$LANISO(_, rTablan[0].LANISO);
				this.$LAN(_, rTablan[0].LAN);
			}

			glob.context.x3frame.context.sys.values.MESSNAME = this.$LAN(_);

			var newlaniso = this.$LANISO(_);

			require('syracuse-core/lib/locale').setCurrent(_, newlaniso);
			(function($) {
				Object.keys(locales).some(function(key) {
					if (locales[key].test(newlaniso)) {
						$.ADXSCA = $.ADXSCA.substring(0, 2) + key + $.ADXSCA.substring(4);
						return;
					}
				});
			})(glob.context.x3frame.context.sys.values);


		},
		AGETCRITROLE: {
			params: ['ACTX', 'AOBJ', 'ABRFIC', 'ACRITROLE', 'AFLGERR'],
			body: function(_) {
				var frame = glob.context.x3frame;
				// Set ACRITROLE and mark it as variable for CallProg
				frame.types.ACRITROLE = "AS";
				frame.values.ACRITROLE = "(1=1)";
				// Set AFLGERR and mark it as variable for CallProg
				frame.types.AFLGERR = "AI";
				frame.values.AFLGERR = variables.constants.CST_ATRUE;

				frame.result = variables.constants.CST_ATRUE;
			}
		},
		$actxSetLOGIN: function(_, login) {
			var self = this;
			var rUser = self.supervisor.sqlDriver.withConnection(_, function(_, cnx) {
				return self.supervisor.sqlReader(_,
					cnx, "select USR_0 ,CODMET_0, PRFFCT_0 from AUTILIS where (LOGIN_0=" + self.supervisor.sqlDriver.param(0) + ")", [login.toUpperCase()]).limit(1).toArray(_);
			});
			if (rUser[0]) {
				this.$LOGIN(_, login);
				this.$USER(_, rUser[0].USR);

				//ADXUSR=LOGIN
				glob.context.x3frame.context.sys.values.ADXUSR = login;
			} else
				throw new util.HttpError(401, this.supervisor.loadMess(_, 130, 70));
		},
		ASETATTRPROP: function(_, property, attribut, value) {
			try {
				return this.setPropertyAttribute(_, property, attribut, value);
			} catch (ex) {
				return this.supervisor.constants.CST_AERROR;
			}
		},
		loadContextChapter: function(_, chap) {
			return this.supervisor.mongoStore.collection('ACONTEXT', _).find({
				CHAPTER: chap
			}, _).toArray(_)[0];
		},
		loadContextProp: function(_, prop) {
			var filter = {};
			filter["CODCTX"] = prop;
			var data = this.supervisor.mongoStore.collection('ACONTEXT', _).find(filter, _).toArray(_)[0];
			return data;
		}
	};
}


function _actxInvokeScript(_, ctx, instance) {
	var astatus = 0;
	var handler = ctx.script.METHODS;

	if (!handler) return;
	var frame = glob.context.x3frame;

	var prev = frame;
	var cx = prev.context;
	glob.context.x3frame = frame = {
		values: {},
		types: {},
		context: cx,
		prev: prev,
		loopLevel: 0,
		loc: {
			file: module.id,
			line: 0
		}
	};
	// current sub is the prog itself
	frame.sub = frame;
	frame.dicts = [frame, cx.globals, cx.sys];
	try {
		util.declVar(frame, 'THIS', 'LY', instance);
		handler(_);
	} finally {
		glob.context.x3frame = prev;
	}
}

// Not exposed by ACTX : 
function _setProtectedProperty(object, property, value) {
	if (object[property] !== undefined) {
		object[property].$_isReadOnly = false;
		object[property].$isReadOnly = false;
		object[property].value = value;
		object[property].$isReadOnly = true;
		object[property].$_isReadOnly = true;
	}
}

function _actxLoadContextProp(_, ctx, name) {
	tracerJs.debug && tracerJs.debug("_actxLoadContextProp name:" + name);
	ctx.desactGet = name;
	if (ctx.builtinProperties && ctx.builtinProperties[name]) {
		ctx[name] = new InstanceProperty(ctx, ctx.builtinProperties[name]());
	} else if (ctx.builtinChapters && ctx.builtinChapters[name]) {
		var chapter = new Chapter(ctx, ctx.builtinChapters[name]);
		ctx[name] = new InstanceProperty(ctx, chapter);
	} else {
		var recDb = glob.context.x3session.actx.loadContextProp(_, name);
		if (!recDb) {
			recDb = glob.context.x3session.actx.loadContextChapter(_, name);
			if (!recDb) throw new Error("NIY ACTX property " + name);

			ctx[name] = new InstanceProperty(ctx, chapter);
		}
		var wprop = {
			"FLDCLA": name,
			"CODTYP": recDb.CODTYP,
			"TYPCLA": 99,
			"LONG": recDb.LNGTYP,
		};
		ctx.class.properties[name] = ctx.supervisor.new(_, 'Property', ctx, wprop);
		var dime;
		if (recDb.FORDIM[0]) dime = recDb.FORDIM[0];

		if (dime) {
			ctx[name] = new InstanceProperty(ctx, [1, ctx.class.properties[name].type.engineType(), [], 1, dime - 1]);
		} else {
			ctx[name] = new InstanceProperty(ctx, ctx.class.properties[name].type.defaultValue());
		}
		var trtini;
		if (recDb.TRTINI) trtini = recDb.TRTINI;
		if (recDb.FORINI) trtini = "ctx." + name + " = " + recDb.FORINI;
		if (trtini) {
			var wcript = "\n$METHODS \n";
			wcript += trtini + '\n';
			wcript += "Return";
			//wcript = "$METHODS \n ctx.IRS(1) = 'TOTO' \n ctx.IRS(2) = 'TOTA' \n Return" ;
			//console.log("wcript " + wcript);
			ctx.script = ctx.supervisor.loadScriptBase(_, wcript, name);
			_actxInvokeScript(_, ctx, ctx);
		}
	}
	// Protect the property :
	ctx[name].$isReadOnly = true;
	ctx[name].$_isReadOnly = true;
	ctx.desactGet = null;
	return ctx[name];
}

var Chapter = util.defineClass(function(parent, builtinProperties) {
	this.parent = parent;
	this.$name = builtinProperties.$name || "Chapter";
	this.supervisor = parent.supervisor;
	this.$exported = true;
	this.class = {
		properties: {}
	};
	this.isContext = true;
	this.builtinProperties = builtinProperties;

}, null, {
	init: function(_) {
		return this;
	},
	set: function(_, name, val) {
		this[name].value = val;
		// TODO : set readonly throw new Error("SET ACTX property " + name);
	},
	get: function(_, name) {
		tracerJs.debug && tracerJs.debug(this.$name + " get:" + name);

		if (this.desactGet || this[name]) return this[name].value.getValue ? this[name].value.getValue(_) : this[name].value;

		this[name] = this[name] || _actxLoadContextProp(_, this, name);
		return this[name].value.getValue ? this[name].value.getValue(_) : this[name].value;
	},
	setPropertyAttribute: function(_, property, attribut, value) {
		return variables.x3Val(this[property].setAttribute(attribut, value));
	},
	getPropertyAttribute: function(_, property, attribut, value) {
		return this[property].getAttribute(attribut);
	}
}, {
	hasAttributes: true
});

exports.constructor = function() {
	var construct = util.defineClass(function(superv) {
		this.supervisor = superv;
		this.$exported = true;
		this.isContext = true;
		this.class = {
			properties: {}
		};
		this.builtinProperties = {
			ASOLUTION: function(solution) {
				if (solution !== undefined) {
					this.ASOLUTION.value = solution;
				}
				var self = this;
				return {
					getValue: function(_) {
						return self.ASOLUTION.value = self.ASOLUTION.value || glob.context.x3session.supervisor.solutionName;
					}
				};
			},
			AFOLDER: function(folder) {
				if (folder !== undefined) {
					this.AFOLDER.value = folder;
				}
				var self = this;
				return {
					getValue: function(_) {
						return self.AFOLDER.value = self.AFOLDER.value || glob.context.x3session.supervisor.folderName;
					}
				};
			},
			LANISO: function(laniso) {
				if (laniso !== undefined) {
					this.LANISO.value = laniso;
				}
				var self = this;
				return {
					getValue: function(_) {
						return self.LANISO.value;
					}
				};
			},
			LAN: function(lan) {
				if (lan !== undefined) {
					this.LAN.value = lan;
				}
				var self = this;
				return {
					getValue: function(_) {
						return self.LAN.value = self.LAN.value || self.LANDEF().getValue(_);
					}
				};
			},
			LANDEF: function(landef) {
				if (landef !== undefined) {
					this.LANDEF.value = landef;
				}
				var self = this;
				return {
					getValue: function(_) {
						if (self.LANDEF.value) return self.LANDEF.value;
						var rAdossier = glob.context.x3session.supervisor.sqlDriver.withConnection(_, function(_, cnx) {
							return glob.context.x3session.supervisor.sqlReader(_,
								cnx, "select LANDEF_0 from ADOSSIER where (DOSSIER_0=" + glob.context.x3session.supervisor.sqlDriver.param(0) + ")", [self.AFOLDER().getValue(_)]).limit(1).toArray(_);
						});
						return self.LANDEF.value = rAdossier[0].LANDEF;
					}
				};
			},
			USER: function(user) {
				if (user !== undefined) {
					this.USER.value = user;
				}
				var self = this;
				return {
					getValue: function(_) {
						return self.USER.value = self.USER.value || glob.context.x3frame.context.sys.values.ADXUSR.value.toUpperCase();
					}
				};
			},
			LOGIN: function(login) {
				if (login !== undefined) {
					this.LOGIN.value = login;
				}
				var self = this;
				return {
					getValue: function(_) {
						return self.LOGIN.value = self.LOGIN.value || glob.context.x3frame.context.sys.values.ADXUSR.value;
					}
				};
			},
			APARAM: function(name) {
				return this.APARAM;
			}

		};

		this._x3Rights = new X3Rights(superv);

		this.builtinChapters = {
			AFOLD: {
				$name: "AFOLD",
				AVERSION: function() {
					return {
						getValue: function(_) {
							return system.functions.VER$.fn(0);
						},
					};
				}
			},
			AINTL: {
				$name: "AINTL",
				TWODIGITYEAR: function() {
					return {
						getValue: function(_) {
							return glob.context.x3frame.context.sys.values.ADXDCS;
						}
					};
				}
			}
		};

		/*			SHORTDATE:function(){ return "";},
				LONGDATE:function(){ return "";},
				SHORTTIME:function(){ return "";},
				LONGTIME:function(){ return "";},
				SHORTDATETIM:function(){ return "";},
				LONGDATETIM:function(){ return "";},
				DECIMALSEP:function(){ return "";},
				THOUSANDSEP:function(){ return "";},
				FIRSTDAYWEEK:function(){ return "";},
				NBGROUPSEP:function(){ return "";},*/

	}, null, _actxmember(), {
		hasAttributes: true
	});
	//TODO prototype of function $USER.....
	var proto = construct.prototype;
	builtinList.forEach(function(name) {
		var lname = name.toLowerCase();
		Object.defineProperty(proto, "$" + name, {
			value: function(_, lname) {
				return this.builtinProperties[name](lname).getValue(_);
			},
			enumerable: true
		});
	});

	['APARAM'].forEach(function(name) {
		Object.defineProperty(proto, "$" + name, {
			value: function(_) {
				return this.get(_, name);
			},
			enumerable: true
		});
	});

	return construct;
}();