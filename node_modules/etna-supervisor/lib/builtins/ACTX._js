"use strict";
var glob = require('streamline/lib/globals');
var util = require("etna-supervisor/lib/util");
var InstanceProperty = require("etna-supervisor/lib/instanceProperty").InstanceProperty;
var attributes = require("etna-supervisor/lib/attributes");
var ACTXCACHE = require("etna-supervisor/lib/builtins/ACTXCACHE");
var ACTXPARAM = require("etna-supervisor/lib/builtins/ACTXPARAM");
var AVOID = require("etna-supervisor/lib/builtins/AVOID");

var variables = require('etna-engine/lib/runtime/variables');
var system = require('etna-engine/lib/runtime/system');
var X3Rights = require("etna-supervisor/lib/x3Rights").X3Rights;
var tracerJs = require("syracuse-trace/lib/helper").getTracer("etna.supervisor");
var constants = require("etna-supervisor/lib/constants");

var locales = {
	' .': /^fr.*/i,
	',.': /^en.*/i
};

var builtinList = ["ASOLUTION", "AFOLDER", "LANISO", "LAN", "LANDEF", "USER", "LOGIN"];
var sessions = {};
var avoid = new(AVOID.constructor)();


// Store context ACTX per session in glob 
// Use cache of sessions
exports.init = function(_, session, superv) {
	var mysession;
	if (sessions[session.id]) {
		mysession = sessions[session.id];
		// controle + maj ou recreation
		glob.context.x3session = mysession;
		if (mysession.session.locale !== session.locale) {
			// set LANISO+LAN
			mysession.actx.ACTX_SET_LANISO(_, session.locale);
		}
		mysession.session = session;
	} else {
		tracerJs.debug && tracerJs.debug("new session:" + session.id);
		mysession = {};
		mysession.session = session;
		mysession.supervisor = superv;
		glob.context.x3session = mysession;
		mysession.actx = new(exports.constructor)(superv).init(_);
		// set LOGIN+USER
		mysession.actx.$actxSetLOGIN(_, mysession.session.userName);
		// set LANISO+LAN
		mysession.actx.ACTX_SET_LANISO(_, mysession.session.locale);
		tracerJs.debug && tracerJs.debug("load rights " + mysession.actx.$LOGIN(_));
		mysession.actx._x3Rights.getJsonRights(_, mysession.actx.$LOGIN(_));

		// set system variables related to the context
		//dbg:console.error("************** actxInitSysVar ***************");
		mysession.actx.$actxInitSysVar(_, superv);
		mysession.dbConnection = null;
		sessions[session.id] = mysession;

	}

	var self = this;
	// Initialise system variables :
	Object.keys(superv.sys).forEach(function(v) {
		glob.context.x3frame.context.sys.values[v] = superv.sys[v];
	});

	//dbg:console.error("************** ACTX ***************");
	util.declVar(glob.context.x3frame.context.globals, 'GACTX', 'VY', glob.context.x3session.actx);
	util.declVar(glob.context.x3frame.context.globals, 'AVOID', 'VY', avoid);

	var adonix = mysession.actx.$APARAM(_).AGETVALNUM(_, 1, this.$actxFolder, "ADONIX");
	util.declVar(glob.context.x3frame.context.globals, 'GADONIX', 'VI', adonix);
	util.declVar(glob.context.x3frame.context.globals, 'GDIMFIC', 'VI', 250);
	var legfil = mysession.actx.$APARAM(_).AGETUSERVALCHAR(_, "LEGFIL") || "";
	util.declVar(glob.context.x3frame.context.globals, 'GLEGFIL', 'VS', legfil);
	util.declVar(glob.context.x3frame.context.globals, 'GPRODUIT', 'VI', -1);
	util.declVar(glob.context.x3frame.context.globals, 'GUTF8', 'VI', 0);
};


function _actxmember() {
	return {
		init: function(_) {
			return this;
		},
		set: function(_, name, val) {
			this[name].value = val;
			// TODO : set readonly throw new Error("SET ACTX property " + name);
		},
		get: function(_, name) {
			if (this.desactGet && this[name]) return this[name].value.getValue ? this[name].value.getValue(_) : this[name].value;

			if (name === "APARAM" && !this[name]) {
				this.APARAM = {
					value: new(ACTXPARAM.constructor)(this.supervisor).init(_)
				};
			} else if (name === "ACACHE" && !this[name]) {
				this.ACACHE = {
					value: new(ACTXCACHE.constructor)(this.supervisor).init(_)
				};
			} else {
				this[name] = this[name] || _actxLoadContextProp(_, this, name);
			}
			return this[name].value.getValue ? this[name].value.getValue(_) : this[name].value;
		},
		setPropertyAttribute: function(_, property, attribut, value) {
			return variables.x3Val(this[property].setAttribute(attribut, value));
		},
		getPropertyAttribute: function(_, property, attribut, value) {
			return this[property].getAttribute(attribut);
		},
		ASETERROR: function(_, path, msg, severity) {
			console.log("TODO ACTX.ASETERROR " + [path, msg, severity].join(','));
			this.diagnoses = this.diagnoses || []; // TODO 
			this.diagnoses.push(this.supervisor.new(_, 'Diagnosis', severity, path, msg));
			return severity;
		},
		//keep this name ACTX_SET_LOGIN for X3 compatibility
		ACTX_SET_LANISO: function(_, laniso) {
			var self = this;
			var rTablan = self.supervisor.sqlReader(_,
				"select LAN_0,LANISO_0 from TABLAN where (LOWER(LANISO_0)=" + self.supervisor.sqlDriver.param(0) + ")", [laniso.toLowerCase()]).limit(1).toArray(_);

			if (rTablan[0] !== undefined) {
				this.$LANISO(_, rTablan[0].LANISO);
				this.$LAN(_, rTablan[0].LAN);

			} else {
				var rTablan = self.supervisor.sqlReader(_,
					"select LAN_0,LANISO_0 from TABLAN where (LAN_0=" + self.supervisor.sqlDriver.param(0) + ")", [self.$LANDEF(_)]).limit(1).toArray(_);
				this.$LANISO(_, rTablan[0].LANISO);
				this.$LAN(_, rTablan[0].LAN);
			}

			glob.context.x3frame.context.sys.values.MESSNAME = this.$LAN(_);

			var newlaniso = this.$LANISO(_);

			require('syracuse-core/lib/locale').setCurrent(_, newlaniso);
			(function($) {
				Object.keys(locales).some(function(key) {
					if (locales[key].test(newlaniso)) {
						$.ADXSCA = $.ADXSCA.substring(0, 2) + key + $.ADXSCA.substring(4);
						return;
					}
				});
			})(glob.context.x3frame.context.sys.values);


		},
		AGETCRITROLE: {
			params: ['ACTX', 'AOBJ', 'ABRFIC', 'ACRITROLE', 'AFLGERR'],
			body: function(_) {
				var frame = glob.context.x3frame;
				// Set ACRITROLE and mark it as variable for CallProg
				frame.types.ACRITROLE = "AS";
				frame.values.ACRITROLE = "(1=1)";
				// Set AFLGERR and mark it as variable for CallProg
				frame.types.AFLGERR = "AI";
				frame.values.AFLGERR = variables.constants.CST_ATRUE;

				frame.result = variables.constants.CST_ATRUE;
			}
		},
		$actxSetLOGIN: function(_, login) {
			var self = this;
			var rUser = self.supervisor.sqlReader(_,
				"select USR_0 ,CODMET_0, PRFFCT_0, ENAFLG_0, USRCONNECT_0 from AUTILIS where (LOGIN_0=" + self.supervisor.sqlDriver.param(0) + ")", [login.toUpperCase()]).limit(1).toArray(_);

			if (rUser[0]) {
				if (rUser[0].ENAFLG !== 2) {
					throw new util.HttpError(401, this.supervisor.loadMess(_, 130, 70));
				} else if (rUser[0].USRCONNECT !== 2) {
					throw new util.HttpError(401, this.supervisor.loadMess(_, 123, 279));
				}
				this.$LOGIN(_, login);
				this.$USER(_, rUser[0].USR);

				//ADXUSR=LOGIN
				glob.context.x3frame.context.sys.values.ADXUSR = login;
			} else
				throw new util.HttpError(401, this.supervisor.loadMess(_, 130, 70));
		},
		$actxInitSysVar: function(_, superv) {
			if (!superv.sys) {
				var wparamTUL;
				var values = {
					ADXTUL: [],
					ADXTUC0: [],
					ADXTUT0: [],
					ADXTUC: [],
					ADXTUT: []
				};
				var parameters = [];

				for (var i = 1; i <= 30; i++) {
					parameters.push("TUL" + ("00" + i).slice(-2));
				}
				var tuls = this.$APARAM(_)._getParams(_, 1, this.$actxFolder, parameters);
				Object.keys(tuls).forEach(function(tul) {
					if (tuls[tul]) {
						var arTUL = tuls[tul].split(":");
						if (arTUL !== undefined && arTUL.length === 2) {
							var tul = arTUL[0][0];
							values.ADXTUL.push(tul);
							values.ADXTUT0.push(arTUL[0].substring(1));
							values.ADXTUT.push(arTUL[0].substring(1));
							values.ADXTUC0.push(arTUL[1]);
							values.ADXTUC.push(arTUL[1]);
						}
					}
				});
				for (var i = 0; i < values.ADXTUT.length; i++) {
					var j = values.ADXTUL.indexOf(values.ADXTUT[i]);
					if (j >= 0) {
						values.ADXTUC[i] = values.ADXTUC[j];
						values.ADXTUT[i] = values.ADXTUT[j];
					}
				}
				superv.sys = Object.keys(values).reduce(function(r, v) {
					r[v] = [1, variables.types["S"].def, values[v], 0, values[v].length];
					return r;
				}, {});
			}
		},
		ASETATTRPROP: function(_, property, attribut, value) {
			try {
				return this.setPropertyAttribute(_, property, attribut, value);
			} catch (ex) {
				return constants.CST_AERROR;
			}
		},
		loadContextChapter: function(_, chap) {
			return this.supervisor.mongoStore.collection('ACONTEXT', _).find({
				CHAPTER: chap
			}).toArray(_)[0];
		},
		loadContextProp: function(_, prop) {
			var filter = {};
			filter["CODCTX"] = prop;
			var data = this.supervisor.mongoStore.collection('ACONTEXT', _).find(filter).toArray(_)[0];
			return data;
		}
	};
}


function _actxInvokeScript(_, ctx, instance) {
	var astatus = 0;
	var handler = ctx.script.METHODS;

	if (!handler) return;
	var frame = glob.context.x3frame;

	var prev = frame;
	var cx = prev.context;
	var sl = prev ? prev.stackLevel + 1 : 0;
	glob.context.x3frame = frame = {
		values: {},
		types: {},
		context: cx,
		prev: prev,
		stackLevel: sl,
		loopLevel: 0,
		loc: {
			file: module.id,
			line: 0
		}
	};
	// current sub is the prog itself
	frame.sub = frame;
	frame.dicts = [frame, cx.globals, cx.sys];
	try {
		util.declVar(frame, 'THIS', 'LY', instance);
		handler(_);
	} finally {
		glob.context.x3frame = prev;
	}
}

// Not exposed by ACTX : 
function _setProtectedProperty(object, property, value) {
	if (object[property] !== undefined) {
		object[property].$_isReadOnly = false;
		object[property].$isReadOnly = false;
		object[property].value = value;
		object[property].$isReadOnly = true;
		object[property].$_isReadOnly = true;
	}
}

function _actxLoadContextProp(_, ctx, name) {
	tracerJs.debug && tracerJs.debug("_actxLoadContextProp name:" + name);
	ctx.desactGet = name;
	if (ctx.builtinProperties && ctx.builtinProperties[name]) {
		ctx[name] = new InstanceProperty(ctx, ctx.builtinProperties[name]());
	} else if (ctx.builtinChapters && ctx.builtinChapters[name]) {
		var chapter = new Chapter(ctx, ctx.builtinChapters[name]);
		ctx[name] = new InstanceProperty(ctx, chapter);
	} else {
		var recDb = glob.context.x3session.actx.loadContextProp(_, name);

		if (!recDb) {
			recDb = glob.context.x3session.actx.loadContextChapter(_, name);
			if (!recDb) throw new Error("NIY ACTX property " + name);

			ctx[name] = new InstanceProperty(ctx, chapter);
		}
		var wprop = {
			"FLDCLA": name,
			"CODTYP": recDb.CODTYP,
			"TYPCLA": 99,
			"LONG": recDb.LNGTYP,
		};
		ctx.class.properties[name] = ctx.supervisor.new(_, 'Property', ctx, wprop);
		var dime;
		if (recDb.FORDIM && recDb.FORDIM[0]) dime = recDb.FORDIM[0];

		if (dime) {
			ctx[name] = new InstanceProperty(ctx, [1, ctx.class.properties[name].type.engineType(), [], 1, dime - 1]);
		} else {
			ctx[name] = new InstanceProperty(ctx, ctx.class.properties[name].type.defaultValue);
		}
		var trtini;
		if (recDb.TRTINI) trtini = recDb.TRTINI;
		if (recDb.FORINI) trtini = "ctx." + name + " = " + recDb.FORINI;
		if (trtini) {
			var wcript = "\n$METHODS \n";
			wcript += trtini + '\n';
			wcript += "Return";
			//wcript = "$METHODS \n ctx.IRS(1) = 'TOTO' \n ctx.IRS(2) = 'TOTA' \n Return" ;
			//console.log("wcript " + wcript);
			try {
				ctx.script = ctx.supervisor.loadScriptBase(_, wcript, name);
				_actxInvokeScript(_, ctx, ctx);
			} catch (e) {
				console.error("exception in _actxInvokeScript:" + e.stack);
			}
		}
	}
	// Protect the property :
	ctx[name].$isReadOnly = true;
	ctx[name].$_isReadOnly = true;
	ctx.desactGet = null;
	return ctx[name];
}

var Chapter = util.defineClass(function(parent, builtinProperties) {
	this.parent = parent;
	this.$name = builtinProperties.$name || "Chapter";
	this.supervisor = parent.supervisor;
	this.$exported = true;
	this.class = {
		properties: {}
	};
	this.isContext = true;
	this.builtinProperties = builtinProperties;

}, null, {
	init: function(_) {
		return this;
	},
	set: function(_, name, val) {
		this[name].value = val;
		// TODO : set readonly throw new Error("SET ACTX property " + name);
	},
	get: function(_, name) {
		tracerJs.debug && tracerJs.debug(this.$name + " get:" + name);

		if (this.desactGet && this[name]) return this[name].value.getValue ? this[name].value.getValue(_) : this[name].value;

		this[name] = this[name] || _actxLoadContextProp(_, this, name);
		return this[name].value.getValue ? this[name].value.getValue(_) : this[name].value;
	},
	setPropertyAttribute: function(_, property, attribut, value) {
		return variables.x3Val(this[property].setAttribute(attribut, value));
	},
	getPropertyAttribute: function(_, property, attribut, value) {
		return this[property].getAttribute(attribut);
	}
}, {
	hasAttributes: true
});

exports.constructor = function() {
	var construct = util.defineClass(function(superv) {
		this.supervisor = superv;
		this.$exported = true;
		this.isContext = true;
		this.class = {
			properties: {}
		};
		this.builtinProperties = {
			ASOLUTION: function(solution) {
				if (solution !== undefined) {
					this.ASOLUTION.value = solution;
				}
				var self = this;
				return {
					getValue: function(_) {
						return self.ASOLUTION.value = self.ASOLUTION.value || glob.context.x3session.supervisor.solutionName;
					}
				};
			},
			AFOLDER: function(folder) {
				if (folder !== undefined) {
					this.AFOLDER.value = folder;
				}
				var self = this;
				return {
					getValue: function(_) {
						return self.AFOLDER.value = self.AFOLDER.value || glob.context.x3session.supervisor.folderName;
					}
				};
			},
			LANISO: function(laniso) {
				if (laniso !== undefined) {
					this.LANISO.value = laniso;
				}
				var self = this;
				return {
					getValue: function(_) {
						return self.LANISO.value;
					}
				};
			},
			LAN: function(lan) {
				if (lan !== undefined) {
					this.LAN.value = lan;
				}
				var self = this;
				return {
					getValue: function(_) {
						return self.LAN.value = self.LAN.value || self.LANDEF().getValue(_);
					}
				};
			},
			LANDEF: function(landef) {
				if (landef !== undefined) {
					this.LANDEF.value = landef;
				}
				var self = this;
				return {
					getValue: function(_) {
						if (self.LANDEF.value) return self.LANDEF.value;
						var rAdossier = glob.context.x3session.supervisor.sqlReader(_,
							"select LANDEF_0 from ADOSSIER where (DOSSIER_0=" + glob.context.x3session.supervisor.sqlDriver.param(0) + ")", [self.AFOLDER().getValue(_)]).limit(1).toArray(_);
						return self.LANDEF.value = rAdossier[0].LANDEF;
					}
				};
			},
			USER: function(user) {
				if (user !== undefined) {
					this.USER.value = user;
				}
				var self = this;
				return {
					getValue: function(_) {
						return self.USER.value = self.USER.value || glob.context.x3frame.context.sys.values.ADXUSR.value.toUpperCase();
					}
				};
			},
			LOGIN: function(login) {
				if (login !== undefined) {
					this.LOGIN.value = login;
				}
				var self = this;
				return {
					getValue: function(_) {
						return self.LOGIN.value = self.LOGIN.value || glob.context.x3frame.context.sys.values.ADXUSR.value;
					}
				};
			},
			APARAM: function(name) {
				return this.APARAM;
			}

		};

		this._x3Rights = new X3Rights(superv);

		this.builtinChapters = {
			AFOLD: {
				$name: "AFOLD",
				AVERSION: function() {
					return {
						getValue: function(_) {
							return system.functions.VER$.fn(0);
						},
					};
				}
			},
			AINTL: {
				$name: "AINTL",
				TWODIGITYEAR: function() {
					return {
						getValue: function(_) {
							return glob.context.x3frame.context.sys.values.ADXDCS;
						}
					};
				},
				SHORTDATE: function() {
					return {
						getValue: function(_) {
							return glob.context.x3frame.context.sys.values.ADXFMT2[2][0];
						}
					};
				},
				LONGDATE: function() {
					return {
						getValue: function(_) {
							return glob.context.x3frame.context.sys.values.ADXFMT2[2][1];
						}
					};
				},
				SHORTTIME: function() {
					return {
						getValue: function(_) {
							return glob.context.x3frame.context.sys.values.ADXFMT2[2][2];
						}
					};
				},
				LONGTIME: function() {
					return {
						getValue: function(_) {
							return glob.context.x3frame.context.sys.values.ADXFMT2[2][3];
						}
					};
				},
				SHORTDATETIM: function() {
					return {
						getValue: function(_) {
							return glob.context.x3frame.context.sys.values.ADXFMT2[2][4];
						}
					};
				},
				LONGDATETIM: function() {
					return {
						getValue: function(_) {
							return glob.context.x3frame.context.sys.values.ADXFMT2[2][5];
						}
					};
				},
				DECIMALSEP: function() {
					return {
						getValue: function(_) {
							return glob.context.x3frame.context.sys.values.ADXFMT2[2][6];
						}
					};
				},
				THOUSANDSEP: function() {
					return {
						getValue: function(_) {
							return glob.context.x3frame.context.sys.values.ADXFMT2[2][7];
						}
					};
				}
			}
		};

		// FIRSTDAYWEEK:function(){ return "";},
		// NBGROUPSEP:function(){ return "";},

	}, null, _actxmember(), {
		hasAttributes: true
	});
	//TODO prototype of function $USER.....
	var proto = construct.prototype;
	builtinList.forEach(function(name) {
		var lname = name.toLowerCase();
		proto["$" + name] = function(_, lname) {
			return this.builtinProperties[name](lname).getValue(_);
		};
	});

	['APARAM'].forEach(function(name) {
		proto["$" + name] = function(_) {
			return this.get(_, name);
		};
	});

	return construct;
}();