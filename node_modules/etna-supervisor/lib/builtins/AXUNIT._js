"use strict";
exports.$exported = true;
var glob = require('streamline/lib/globals');

var date = require('syracuse-core/lib/types/date');
var errors = require('etna-engine/lib/runtime/errors');
var flowControl = require('etna-engine/lib/runtime/flowControl');
var runtime = require('etna-engine/lib/runtime/runtime');
var config = require("etna-util/lib/nodeconfig").config;

var testCases = [];
var isLast;

var trace = config.etna.traceAXUNIT ? console.log : null;

function nanos(hr) {
	return hr[0] * 1e9 + hr[1];
}
var hrtime = process.hrtime();

exports.TESTSUITE_START = function(_, suite_id, suite_description) {
	//added for AXUNIT comptability
};

exports.ADD_TESTCASE = function(_, name, title, count) {
	testCases.push({
		name: name.valueOf(),
		title: title.valueOf(),
		count: count,
	});
};

exports.RUN_TESTSUITE = function(_, title, description) {
	trace && trace("AXUNIT RUN_TESTSUITE:" + title);

	/*	var recorder = require('streamline-flamegraph/lib/record').create({
	    // sampling rate, in milliseconds, 1 by default
	    rate: 1,
	    // root of source tree (will be trimmed from full file names to get relative paths)
	    // by default: ""
	    sourceRoot: __dirname,
	    // pattern for source link URLs
	    // by default: "file://{fullpath}#{line}"
	    //sourceUrl: "https://github.com/Sage/streamline-flamegraph/tree/master/{relpath}#L{line}",
	    sourceUrl: "file://{fullpath}",
	});
	recorder.start();*/

	var frame = glob.context.x3frame;
	var moduleId = errors.moduleName(frame.prev.loc);
	QUnit.module(moduleId, {
		teardown: function() {
			// kill process in next tick so that test of assertion counts is not shortcircuited.
			// Be carefull though to for the stdout to be drained before exiting !
			if (isLast) setTimeout(function() {
				//recorder.stop();
				var time = nanos(process.hrtime(hrtime));
				console.log("\nQLFAR '" + title + "' executed in " + (time / 1e6) + " ms");
				runtime.exit(0);
			}, 100);
		},
	});
	testCases.forEach(function(tc, i) {
		trace && trace("AXUNIT RUN:" + tc.name);
		asyncTest(tc.title, tc.count, function(_) {
			isLast = (i === testCases.length - 1);
			try {
				var prog = frame.prog.module[tc.name];
				if (!prog) throw new Error("test case missing: " + tc.name);
				flowControl.callProg(_, prog, [], [], glob.context.x3frame.sub.loc);
				start();
			} catch (ex) {
				//console.error(ex);
				throw ex;
			}
		});
	});
	return true;
};

exports.CHECK_EQUAL = function(_, v1, v2, title) {
	var v11 = (Array.isArray(v1) ? (v1[2][0] === undefined ? v1[1] : v1[2][0]) : v1);
	var v22 = (Array.isArray(v2) ? (v2[2][0] === undefined ? v2[1] : v2[2][0]) : v2);

	trace && trace("AXUNIT.CHECK_EQUAL:" + v11.constructor.name + ":'" + v11 + "' '" + v22.constructor.name + ":'" + v22 + "'");
	if (v11.x3Compare) deepEqual(v11.x3Compare(v22), 0, (title) ? title.valueOf() : undefined || "Expected '" + v22.x3ToString() + "' Got '" + v11.x3ToString() + "'");
	else deepEqual(1, 0, (title) ? title.valueOf() : undefined || "Expected " + v22.x3ToString() + " Got " + v11.x3ToString());
};

exports.CHECK_NOTEQUAL = function(_, v1, v2, title) {

	var v11 = (Array.isArray(v1) ? (v1[2][0] === undefined ? v1[1] : v1[2][0]) : v1);
	var v22 = (Array.isArray(v2) ? (v2[2][0] === undefined ? v2[1] : v2[2][0]) : v2);

	trace && trace("AXUNIT.CHECK_NOTEQUAL:" + v11.constructor.name + ":" + v11 + " " + v22.constructor.name + ":" + v22);
	ok(v11.x3Compare(v22) != 0, (title) ? title.valueOf() : undefined || "Expected " + v22.x3ToString() + " Got " + v11.x3ToString());
};

exports.CHECK_TRUE = function(_, v) {
	trace && trace("AXUNIT.CHECK_TRUE:" + v);
	ok(v);
};

exports.CHECK_FALSE = function(_, v) {
	trace && trace("AXUNIT.CHECK_FALSE:" + v);
	ok(!v);
};

exports.LOG_LINE = function(_, line) {
	trace && trace(line);
};

exports.APPEND_VALUE = function(_, v) {
	ok(v);
};