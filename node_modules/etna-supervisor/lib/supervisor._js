"use strict";
var mongodb = require('mongodb');
var glob = require('streamline-runtime').globals;

var constants = require("etna-supervisor/lib/constants");
var util = require("etna-supervisor/lib/util");
var fs = require("streamline-fs");
var bcd = require('etna-engine/lib/runtime/bcd');
var variables = require('etna-engine/lib/runtime/variables');
var ez = require("ez-streams");
var utilDriver = require("etna-engine/lib/drivers/util");
var runtime = require("etna-engine/lib/runtime/runtime");

var tracerJs = require('syracuse-core').getTracer("etna.supervisor");
var tracerDbms = require('syracuse-core').getTracer("etna.dbms");

var dbs = {};

var HttpError = util.HttpError;

function mongoConnect(_, config) {
	var mgConf = (config && config.mongo) || {};
	var dbName = mgConf.database || "etna";
	if (dbs[dbName]) return dbs[dbName];
	/*	var server = new mongodb.Server(mgConf.host || "localhost", mgConf.port || 27017, {});
	var db = new mongodb.Db(dbName, server, {
		w: 1 //"majority"
	});
	dbs[dbName] = db;
	db.open(_);*/
	var dbUrl = "mongodb://" + (mgConf.connectionString || (mgConf.host || "localhost") + ":" + (mgConf.port || 27017)) + "/" + dbName;
	var db = dbs[dbName] = mongodb.MongoClient.connect(dbUrl, mgConf.options || {
		db: {
			w: 1
		}
	}, _);

	fs.readdir(__dirname + "/meta", _).forEach_(_, function(_, name) {
		var sub = require(__dirname + "/meta/" + name);
		if (sub.keyName) {
			var index = {};
			index[sub.keyName] = 1;
			db.collection(sub.collectionName, _).ensureIndex(index, {
				background: true
			}, _);
		}
	});
	return db;
}

function loadErrorMessages(_, mongo, lan) {
	var found = {}; // we are getting duplicates - eliminate for now. Investigate later why.
	var mess = mongo.collection('APLSTD', _).find({
		LAN: lan,
		LANCHP: 9014
	}).sort({
		LANCHP: 1,
		LANNUM: 1
	}).toArray(_).filter(function(m) {
		var ok = m.LANNUM && !found[m.LANNUM];
		found[m.LANNUM] = true;
		return ok;
	}).map(function(m) {
		return m.LANMES;
	});
	mess.unshift("Message 0");
	return mess;
}


exports.create = function(_, config) {
	var mongoStore = mongoConnect(_, config);

	var cache = {
		LAN: {
			//ATEXTE: {},
			//APLSTD: {},
		},
	};
	var subModules = exports.subModules = {};

	var trim = utilDriver.trim;

	function executeSql(_, sql, args, opts) {
		//if (!/^select /.test(sql) && !conf.etnaSqlStore.writable) throw new Error("cannot modify: SQL store is read-only");
		//tracerDbms.debug && tracerDbms.debug("executeSql*: " + sql + ", args=" + args);

		var sqlargs = utilDriver.toSql(args || [], sqlDriver);
		var result = sqlDriver.execute(_, glob.context.x3session.dbConnection, sql, sqlargs, opts);
		if (opts && opts.typesmap) {
			var maptrim = utilDriver.maptrim(sqlDriver, opts.typesmap, opts.dispatch);

			return Array.isArray(result) ? result.map_(_, maptrim) : result;

		} else return Array.isArray(result) ? result.map(trim) : result;
	}

	function sqlReader(_, sql, args, opts) {
		opts = opts || {};
		tracerDbms.debug && tracerDbms.debug("sqlReader: " + sql + ", args=" + args);
		//if (!/^select /.test(sql) && !conf.etnaSqlStore.writable) throw new Error("cannot modify: SQL store is read-only");

		var maptrim = opts.typesmap ? utilDriver.maptrim(sqlDriver, opts.typesmap, opts.dispatch) : trim;
		var ftrim = function(_, record) {
			return opts.typesmap ? maptrim(_, record) : trim(record);
		};
		//debugger;
		return sqlDriver.reader(_, glob.context.x3session.dbConnection, sql, args || [], opts).map(ftrim);
	}

	function subModule(className) {
		return subModules[className] || (subModules[className] = require(__dirname + '/meta/' + className[0].toLowerCase() + className.slice(1)));
	}

	function compile(superv, source, name, filename) {
		var fn = new Function("module", "exports", "requireScript", "require", "'use strict';" + source);
		var module = {
			id: name,
			filename: filename,
			exports: {}
		};

		function req(_, name) {
			return superv.loadScript(_, name);
		}
		try {
			fn(module, module.exports, req, require);
		} catch (ex) {
			throw new Error(filename + ": module initialization failed: " + ex.stack.split('\n').slice(0, 2).join(': '));
		}
		return module.exports;
	}

	function _messSearch(chap, num) {
		var min = 0;
		var max = chap.length - 1;
		var cur;
		var cval;

		while (min <= max) {
			cur = ((min + max) >> 1);
			cval = chap[cur].$value;

			if (cval < num) {
				min = cur + 1;
			} else if (cval > num) {
				max = cur - 1;
			} else {
				return chap[cur].$title;
			}
		}
		return "";
	}

	var sqlDriver = require('etna-engine/lib/drivers/' + config.sql.driver)(config.sql);

	var superv = {
		// for now
		baseUrl: "http://localhost:8124" + "/sdata/x3/erp/" + config.endpointName,
		transUrl: "/trans/x3/erp/" + config.endpointName,
		collaborationUrl: "/sdata/syracuse/collaboration/syracuse",
		solutionName: config.solutionName,
		solutionPath: config.solutionPath,
		endpointName: config.endpointName,
		folderName: config.folderName,
		sqlDriver: sqlDriver,
		executeSql: executeSql,
		sqlReader: sqlReader,
		engineErrMess: loadErrorMessages(_, mongoStore, "FRA"),
		mongoStore: mongoStore,
		constants: constants,
		new: function(_, className) {
			var cl = subModule(className).constructor;
			var args = [cl, superv].concat(Array.prototype.slice.call(arguments, 2));
			return (new(cl.bind.apply(cl, args))).init(_);
		},
		load: function(_, className, keyValue, dataChildren) {
			//dbg:console.log("load:"+className+" "+keyValue);

			var loader = subModule(className);
			var instances = (cache[loader.collectionName] = cache[loader.collectionName] || {});

			var instance = instances[keyValue];

			var data, keys, relPath;
			if (keyValue !== undefined) {
				var filter = {};
				if (keyValue.indexOf('_') >= 0) { // Special case for 4GL scripts:
					keys = keyValue.split("_");
					filter[loader.keyName] = keys[0];
					relPath = keys.slice(1);
				} else {
					keys = keyValue.split(".");
					filter[loader.keyName] = keys[keys.length - 1];
				}
				data = mongoStore.collection(loader.collectionName, _).find(filter).toArray(_)[0];
			}

			if (instance && data && data._etag && instance._etag && data._etag === instance._etag) return instance;
			if (data) {
				data.dataChildren = dataChildren;
				instance = new loader.constructor(superv, data).init(_);
				instance._etag = data._etag;
				if (relPath) {
					for (var i = 0; i < relPath.length; i++) {
						var relation = instance.relations[relPath[i]];
						if (!relation) throw new X3Error(26, "invalid class name: " + keyValue);
						instance = relation.class;
					}
				}
			} else {
				var script = this.loadBuiltin(_, keyValue);
				instance = script ? new(script.constructor)(superv).init(_) : null;
			}
			return instances[keyValue] = instance;
		},
		reader: function(_, className, filter) {
			var loader = subModule(className);
			var coln = mongoStore.collection(loader.collectionName, _).find(filter || {});
			return ez.devices.generic.reader(function(_) {
				var data = coln.nextObject(_);
				return data ? new loader.constructor(superv, data).init(_) : undefined;
			});
		},
		loadText: function(_, num, lan) {
			lan = lan || glob.context.x3session.actx.$LAN(_);
			var s = (cache.LAN[lan] !== undefined ? cache.LAN[lan].ATEXTE[num] : undefined);
			if (s !== undefined) return s;

			mongoStore.collection('ATEXTE', _).ensureIndex({
				LAN: 1,
				TEXTE: 1
			}, {
				background: true
			}, _);

			var data = mongoStore.collection('ATEXTE', _).find({
				LAN: lan,
				NUMERO: num,
			}).toArray(_)[0];
			if (cache.LAN[lan] === undefined) cache.LAN[lan] = {
				ATEXTE: {},
				APLSTD: {}
			};
			return cache.LAN[lan].ATEXTE[num] = data ? data.TEXTE : "TEXT_" + num;
		},
		findText: function(_, text, lan) {
			lan = lan || glob.context.x3session.actx.$LAN(_);
			var data = mongoStore.collection('ATEXTE', _).find({
				LAN: lan,
				TEXTE: text,
			}).toArray(_)[0];
			if (data) {
				// Save it in the cache:
				if (cache.LAN[lan] === undefined) cache.LAN[lan] = {
					ATEXTE: {},
					APLSTD: {}
				};
				cache.LAN[lan].ATEXTE[data.NUMERO] = data.TEXTE;
				return data.NUMERO;
			}
			return 0;
		},
		loadEnum: function(_, lib, lan) {
			var lan = lan || glob.context.x3session.actx.$LAN(_);
			var menu = (cache.LAN[lan] !== undefined ? cache.LAN[lan].APLSTD[lib] : undefined);
			if (menu !== undefined) return menu;
			var found = {}; // we are getting duplicates - eliminate for now. Investigate later why.
			var menu = mongoStore.collection('APLSTD', _).find({
				LAN: lan,
				LANCHP: lib,
			}).sort({
				LANCHP: 1,
				LANNUM: 1
			}).toArray(_).filter(function(m) {
				var ok = m.LANNUM && !found[m.LANNUM];
				found[m.LANNUM] = true;
				return ok;
			}).map(function(m) {
				return {
					$value: m.LANNUM,
					$title: m.LANMES,
				};
			});
			if (cache.LAN[lan] === undefined) cache.LAN[lan] = {
				ATEXTE: {},
				APLSTD: {}
			};
			return (cache.LAN[lan].APLSTD[lib] = menu);
		},
		loadMess: function(_, lib, num, lan) {
			var list = this.loadEnum(_, lib, lan);
			if (list !== undefined) return _messSearch(list, num);
			return "";
		},
		loadMessParams: function(_, lib, num) {
			var mess = this.loadMess(_, lib, num);
			if (mess !== "") {
				var args = Array.prototype.slice.call(arguments);
				mess = mess.replace(/\$[\w~]\$/g, function(str) {
					return args[parseInt(str.replace(/\$/g, '')) + 2];
				});

			}
			return mess;
		},
		fillTypeNode: function(_, data, node) {
			return subModule('Type').fillTypeNode(_, superv, data, node);
		},
		razCacheScripts: function(_) {
			cache.scripts = undefined;
		},
		loadBuiltins: function(_, name) {
			if (cache.scripts === undefined) {
				if (cache.scriptBuitins === undefined) {
					cache.scriptBuitins = {};
					tracerJs.debug && tracerJs.debug("load Builtins");
					fs.readdir(__dirname + '/builtins', _).forEach(function(name) {
						if (/\._js$/.test(name)) {
							name = name.substring(0, name.length - 4);
							var script = require('etna-supervisor/lib/builtins/' + name);
							// set name on all entry points
							tracerJs.debug && tracerJs.debug("load Builtin:" + name);
							script.$isBuiltin = true;
							script.$name = name;
							/*							Object.keys(script).forEach(function(name) {
								script[name].name = name;
							});*/
							cache.scriptBuitins[name] = script;
						}
					});
				}
				cache.scripts = Object.keys(cache.scriptBuitins).reduce(function(r, name) {
					var v = cache.scriptBuitins[name];
					r[name] = v;
					return r;
				}, {});;
			}
		},
		loadBuiltin: function(_, name) {
			this.loadBuiltins(_);
			return cache.scriptBuitins[name];
		},
		loadScript: function(_, name) {
			this.loadBuiltins(_);
			var script = cache.scripts[name];
			if (!script) {
				var cache_scripts = cache.scripts;
				var path = config.solutionPath + "/" + config.folderName + "/TRT/" + name + ".src";
				tracerJs.debug && tracerJs.debug("Loading script: " + path);
				var source = fs.readFile(path, "utf8", _);
				var parsed = new(require("etna-engine/lib/parser").Parser)(source, path).parse();
				var transformed = require("etna-engine/lib/jsgen").generate(parsed.node, path);
				//fs.writeFile("C:\\"+name+"sc.js", transformed, "utf8", _); // for debugging
				cache.scripts = cache_scripts;
				cache.scripts[name] = compile(superv, transformed, name, path);
				script = cache.scripts[name];
				//tracerJs.debug && tracerJs.debug(script);
			}
			return script;
		},
		loadScripts: function(_, _this) {
			if (_this.data.CODTRT) {
				_this._scripts = _this.data.CODTRT.map_(_, function(_, codtrt) {
					return {
						name: codtrt,
						body: this.supervisor.loadScript(_, codtrt)
					};
				}, _this);
			} else {
				_this._scripts = [];
			}
			return _this._scripts;
		},
		loadScriptBase: function(_, wscript, name) {
			//fs.writeFile("C:\\" + name + "sc.js", wscript, "utf8", _); // for debugging
			var parsed = new(require("etna-engine/lib/parser").Parser)(wscript, "").parse();
			var transformed = require("etna-engine/lib/jsgen").generate(parsed.node, "");
			//fs.writeFile("C:\\" + "name" + "sc.js", transformed, "utf8", _); // for debugging
			var script = compile(superv, transformed, name, "");
			//tracerJs.debug && tracerJs.debug(script); 
			return script;
		},
		newInstance: function(_, className) {
			var cl = this.load(_, 'Class', className);
			return cl.createInstance(_);
		},
		about: function(_) {
			return {
				solutionName: config.solutionName,
				solutionHttpUrl: "TODO", //http://aws-x3-devsup.sagefr.adinternal.com:80/Adonix_SUPDVLP,
				processServer: "TODO", //AWS-X3-DEVSUP.sagefr.adinternal.com,
				applicationServer: "", //AWS-X3-DEVSUP.sagefr.adinternal.com,
				folder: config.folderName,
				port: "TODO",
				x3Version: "TODO",
				supervisorVersion: "TODO",
				runtimeVersion: "TODO",
				x3Release: "TODO",
				patchNumber: "TODO"
			};
		},
		languages: function(_) {
			if (!this._languages) {
				var self = this;
				var columns = new Array(20);
				for (var i = 0; i < columns.length; i++) columns[i] = "LAN_" + i;

				this._languages = this.sqlReader(_, "select " + columns.join(',') + " from ADOSSIER where (DOSSIER_0=" + this.sqlDriver.param(0) + ")", [this.folderName]).limit(1).toArray(_)
					.reduce_(_, function(_, r, record) {
						for (var i = 0; i < record.LAN.length; i++) {
							var tablan = self.newInstance(_, "TABLAN");
							var status = tablan.read(_, record.LAN[i]);
							if (status !== constants.CST_AERROR) {
								r[record.LAN[i]] = tablan;
							}
						}
						return r;
					}, {});
			}
			return this._languages;
		}
	};


	var types = mongoStore.collection('ATYPE', _).find({
		TYPTYP: 7
	}).toArray(_);
	for (var i = 0, len = types.length; i < len; i++) {
		if (types[i].LNGTYP && typeof types[i].LNGTYP === 'string') {
			if (!isNaN(types[i].LNGTYP) && bcd.toDouble(bcd.fromString(types[i].LNGTYP)) > 0) types[i].LNGTYP = bcd.toDouble(bcd.fromString(types[i].LNGTYP));
			else delete types[i].LNGTYP;
		}
		superv.constants["GLON" + types[i].CODTYP] = types[i].LNGTYP || 250;
	}
	return superv;
};