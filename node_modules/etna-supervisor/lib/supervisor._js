"use strict";
var mongodb = require("streamline-mongodb");
var sqlPool = require("etna-util/lib/connectionPool");
var util = require("etna-supervisor/lib/util");
var config = require("../../../nodelocal").config.etna;
if (!config) throw new Error("etna section missing in nodelocal.js");
var fs = require("streamline-fs");
var variables = require('etna-engine/lib/runtime/variables');
var ez = require("ez-streams");

var trace = console.log;
var dbs = {};

var HttpError = util.HttpError;

function mongoConnect(_, name) {
	if (dbs[name]) return dbs[name];
	var conf = config[name];
	if (!conf) throw new HttpError(404, "endpoint not found: " + name);
	conf = conf.mongoStore || {};
	var server = new mongodb.Server(conf.host || "localhost", conf.port || 27017, {});
	var db = new mongodb.Db(conf.database || name, server, {
		w: 1 //"majority"
	});
	dbs[name] = db;
	db.open(_);

	fs.readdir(__dirname + "/meta", _).forEach_(_, function(_, name) {
		var sub = require(__dirname + "/meta/" + name);
		if (sub.keyName) {
			var index = {};
			index[sub.keyName] = 1;
			db.collection(sub.collectionName, _).ensureIndex(index, {
				background: true
			}, _);
		}
	});
	return db;
}

exports.create = function(_, name) {
	var mongoStore = mongoConnect(_, name);
	var conf = config[name];
	var sqlStore = sqlPool.create(conf.etnaSqlStore);
	var cache = {
		ATEXTE: {},
		APLSTD: {},
		scripts: {},
	};
	var subModules = {};

	function trim(obj) {
		var result = Object.keys(obj).reduce(function(o, k) {
			var v = obj[k];
			/*if (v instanceof Date) {
				v = v.toISOString();
				if (/T00\:00\:00\.000Z$/.test(v)) {
					v = v.substring(0, v.length - 14);
					if (v === '1599-12-31') v = null;
				}
			}*/
			if (/^CAST\(AUUID_0/.test(k)) k = "AUUID_0";
			var kk = k.substring(0, k.lastIndexOf('_'));
			var isArray = (obj[kk + '_1'] !== undefined);
			if (isArray) {
				o[kk] = o[kk] || [];
				o[kk].push(v);
			} else {
				if (v && v !== ' ') o[kk] = v;
			}
			return o;
		}, {});
		Object.keys(result).forEach(function(k) {
			var v = result[k];
			if (Array.isArray(v)) {
				var len = v.length;
				while (len > 0 && !(v[len - 1] && v[len - 1] !== ' ')) len--;
				result[k] = v.slice(0, len);
			}
		});
		return result;
	}

	function executeSql(_, stmt, args) {
		//trace && trace("SQL: " + stmt + ", args=" + args);
		if (!/^select /.test(stmt) && !conf.etnaSqlStore.writable) throw new Error("cannot modify: SQL store is read-only");
		var result = sqlStore.withConnection(_, function(_, cnx) {
			return cnx.execute(stmt, args || [], ~_);
		});
		return Array.isArray(result) ? result.map(trim) : result;
	}

	function sqlReader(_, stmt, args) {
		//trace && trace("SQL: " + stmt + ", args=" + args);
		if (!/^select /.test(stmt) && !conf.etnaSqlStore.writable) throw new Error("cannot modify: SQL store is read-only");
		return sqlStore.withConnection(_, function(_, cnx) {
			var reader = cnx.reader(stmt, args || []);
			return ez.devices.generic.reader(function(_) {
				return reader.nextRow(_);
			}).map(function(_, record) {
				return trim(record);
			});
		});
		//return Array.isArray(result) ? result.map(trim) : result;
	}

	function subModule(className) {
		return subModules[className] || (subModules[className] = require(__dirname + '/meta/' + className[0].toLowerCase() + className.slice(1)));
	}

	function compile(superv, source, name, filename) {
		var fn = new Function("module", "exports", "requireScript", "require", "'use strict';" + source);
		var module = {
			id: name,
			filename: filename,
			exports: {}
		};

		function req(_, name) {
			return superv.loadScript(_, name);
		}
		try {
			fn(module, module.exports, req, require);
		} catch (ex) {
			throw new Error(filename + ": module initialization failed: " + ex.stack.split('\n').slice(0, 2).join(': '));
		}
		return module.exports;
	}

	var superv = {
		LAN: "FRA",
		// for now
		baseUrl: "/sdata/x3/erp/" + name,
		transUrl: "/trans/x3/erp/" + name,
		executeSql: executeSql,
		sqlReader: sqlReader,
		new: function(_, className) {
			var cl = subModule(className).constructor;
			var args = [cl, superv].concat(Array.prototype.slice.call(arguments, 2));
			return (new (cl.bind.apply(cl, args))).init(_);
		},
		load: function(_, className, keyValue) {
			var loader = subModule(className);
			var instances = (cache[loader.collectionName] = cache[loader.collectionName] || {});
			var instance = instances[keyValue];
			if (instance !== undefined) return instance;
			var filter = {};
			filter[loader.keyName] = keyValue;
			var data = mongoStore.collection(loader.collectionName, _).find(filter, _).toArray(_)[0];
			return instances[keyValue] = data ? new loader.constructor(superv, data).init(_) : null;
		},
		reader: function(_, className, filter) {
			var loader = subModule(className);
			var coln = mongoStore.collection(loader.collectionName, _).find(filter || {}, _);
			return ez.devices.generic.reader(function(_) {
				var data = coln.nextObject(_);
				return data ? new loader.constructor(superv, data).init(_) : undefined;
			});
		},
		loadText: function(_, num) {
			var s = cache.ATEXTE[num];
			if (s !== undefined) return s;
			var data = mongoStore.collection('ATEXTE', _).find({
				LAN: superv.LAN,
				NUMERO: num,
			}).toArray(_)[0];
			return cache.ATEXTE[num] = data ? data.TEXTE : "TEXT_" + num;
		},
		loadEnum: function(_, lib) {
			var menu = cache.APLSTD[lib];
			if (menu !== undefined) return menu;
			var found = {}; // we are getting duplicates - eliminate for now. Investigate later why.
			var menu = mongoStore.collection('APLSTD', _).find({
				LAN: superv.LAN,
				LANCHP: lib,
			}).toArray(_).filter(function(m) {
				var ok = m.LANNUM && !found[m.LANNUM];
				found[m.LANNUM] = true;
				return ok;
			}).map(function(m) {
				return {
					$value: m.LANNUM,
					$title: m.LANMES,
				};
			})
			return (cache.APLSTD[lib] = menu);
		},
		fillTypeNode: function(_, data, node) {
			return subModule('Type').fillTypeNode(_, superv, data, node);
		},
		loadScript: function(_, name) {
			var script = cache.scripts[name];
			if (!script) {
				var path = conf.scriptsRoot + "/" + name + ".src";
				console.log("Loading script: " + path);
				var source = fs.readFile(path, "utf8", _);
				var parsed = new(require("etna-engine/lib/parser").Parser)(source, path).parse();
				var transformed = require("etna-engine/lib/jsgen").generate(parsed.node, path);
				fs.writeFile(path.replace(/\.src$/, ".js"), transformed, "utf8", _); // for debugging
				script = cache.scripts[name] = compile(superv, transformed, name, path);
				//console.log(script);
			}
			return script;
		},
		newEngineFrame: function() {
			return variables.createStack({
				superv: superv,
			});
		},
		currentContext: function(_) {
			// TODO: this is session stuff
			return superv.context || (superv.context = (new(require('etna-supervisor/lib/builtins/ACTX').constructor)(superv)).init(_));
		},
	};
	fs.readdir(__dirname + '/builtins', _).forEach(function(name) {
		if (/\._js$/.test(name)) {
			name = name.substring(0, name.length - 4);
			var script = require('etna-supervisor/lib/builtins/' + name);
			// set name on all entry points
			Object.keys(script).forEach(function(name) {
				script[name].name = name;
			});
			cache.scripts[name] = script;
		}
	});
	return superv;
}