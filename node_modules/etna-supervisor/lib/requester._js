"use strict";

var glob = require('streamline/lib/globals');
var bcd = require("etna-engine/lib/runtime/bcd");
var runtime = require("etna-engine/lib/runtime/runtime");
var evalue = require("etna-engine/lib/runtime/evaluate").evalue;
var datetime = require('etna-engine/lib/runtime/tdatetime');
var date = require('etna-engine/lib/runtime/tdate');
var variables = require('etna-engine/lib/runtime/variables');
var Parser = require("etna-engine/lib/parser").Parser;

var type = require("etna-supervisor/lib/meta/type");
var util = require("etna-supervisor/lib/util");
var ASYR = require("etna-supervisor/lib/builtins/ASYR");
var ASYRRCV = require("etna-supervisor/lib/builtins/ASYRRCV");
var utilDriver = require("etna-supervisor/lib/drivers/util");

var filterHelpers = require("syracuse-orm/lib/filters");

var HttpError = util.HttpError;

var tracerJs = require("syracuse-trace/lib/helper").getTracer("etna.supervisor");

function loadScript(_, script) {
	try {
		return runtime.requireScript(_, "WF" + script);
	} catch (e) {
		throw new HttpError(404, "query not found: " + script);
	}
}

exports.proto = function(_, superv, script, query, facet) {
	var mod = loadScript(_, script);
	var psyr = new(ASYR.constructor)(superv);

	var args = {
		ACTX: {
			type: "AY",
			value: glob.context.x3session.actx
		},
		PSYR: {
			type: "AY",
			value: psyr
		},
		WCLOB: {
			type: "AT",
			value: ""
		},
		TIME_UPD: {
			type: "AN",
			value: bcd.fromDouble(0)
		},
		LEVEL_NUM: {
			type: "BS",
			value: query
		},
		TYPE_REPRES: {
			type: "BS",
			value: facet
		}
	};
	runtime.executeProg(_, mod, "PROTO_JSON", args);
	return args.WCLOB.value;
};

/*
Frequency of computation : 1=always, 2=every hour, 3=every day, 4=every week, 5=every month, 6=never
execution_time is assigned as a time stamp numeric value (if 0, recomputation is not required)
*/
function getExecutionTime(frq, forced_exec) {
	var execution_time = 0;
	if (!frq) {
		forced_exec = true;
		return execution_time;
	}

	var now = datetime.now();
	switch (frq) {
		case 1:
			forced_exec = true;
			break;
		case 2, 3, 4, 6:
			execution_time = (frq !== 6) * now - (frq === 2) * (3600 * 1000) - (frq === 3) * 24 * 3600 * 1000 - (frq === 4) * 7 * 24 * 3600 * 1000;
			break;
		case 5:
			execution_time = 24 * 3600 * 1000 * (now.x3Nday(date.make(1700, 1, 1))) - 1;
			break;
		case 7:
			execution_time = now - (60 * 10000);
			break;
		case 8:
			execution_time = now - (60 * 1000);
			break;
		case 9:
			execution_time = now - (10 * 1000);
			break;
	}
	return execution_time;
}

function getPortalValue(record, cod, fields) {
	var k = record.CMPPARCOD.indexOf(cod);
	if (k < 0) return;

	var formula = record.CMPPARFOR[k];
	var res = "";
	//Replace , per ; and remove ""
	formula = formula.replace(/,/g, ';').replace(/"/g, '');
	return formula.split(';').reduce(function(r, exp) {
		//transform the expression in a numeric value :
		var j = exp.x3Val();
		// if j : j= index of a field  
		if (j && j < fields.length) r.push('"' + fields(j) + '"')
		return r;
	}, []).join(',');
}

exports.query = function(_, httpContext, request_code, query) {
	tracerJs.debug && tracerJs.debug("query " + request_code + " " + query);
	var qs = httpContext.qs;

	// Define the program and check if it exists
	var mod = loadScript(_, request_code);
	var actx = glob.context.x3session.actx;
	var superv = httpContext.supervisor;
	var nomap = superv.folderName;
	var psyr = new(ASYR.constructor)(superv);
	var arcv = new(ASYRRCV.constructor)(httpContext.superv, httpContext.qs);


	//   Forced request id (only for batch computations)
	var calendarPrototype;
	var ifbulk = false;
	var uuireq = "";
	var nblig = [1, 0, [], 1, 20]; // NBLIG(1..20)
	var valbeg = [1, "", [], 1, 100]; // VALBEG(250)(1..100)
	var valend = [1, "", [], 1, 100]; // VALEND(250)(1..100)
	var strictbeg = [1, 0, [], 1, 100]; // STRICTBEG(1..100)
	var strictend = [1, 0, [], 1, 100]; // STRICTEND(1..100)

	// Let's analyze the parameters sent in the URL
	var limits = [1, 0, [], 1, 2]; // LIMITS(1..2)

	var args = {
		PARAM: {
			type: 'AS',
			value: [1, "", [], 1, null]
		},
		PARTYPE: {
			type: 'AI',
			value: [1, 0, [], 1, null]
		},
		MAXLEVEL: {
			type: 'AI',
			value: 0
		},
		IFSHARED: {
			type: 'AI',
			value: 0
		}
	};
	runtime.executeProg(_, mod, "GET_PARAMS", args);
	tracerJs.debug && tracerJs.debug("requester.GET_PARAMS return:" + JSON.stringify(args));

	var param = args.PARAM.value;
	var partype = args.PARTYPE.value;
	var maxlevel = args.MAXLEVEL.value;
	var ifshared = args.IFSHARED.value;

	var forced_exec = (qs.forcedExecution.toLowerCase() === "true");
	var where = qs.Where || "";
	var level = qs.level || 0;
	limits[2][0] = qs.linesLimit || 0;
	limits[2][1] = qs.timeLimit || 0;
	var requid = qs.requestID || "";
	var firstline = Math.max([qs.startRecord || 0, qs.startIndex || 0, 1]);
	var startind = qs.startIndex || 0;
	var nblines = qs.count || qs.recordsPerPage || 0;
	if (!nblines) {
		if (httpContext.facet === "$bulk") {
			nblines = actx.$APARAM(_).AGETUSERVALNUM(_, "NBRREQBLK") || 200;
			ifbulk = true;
		} else {
			nblines = actx.$APARAM(_).AGETUSERVALNUM(_, "NBRREQ") || 20;
		}
	}
	var frq = qs.frequency;
	var execution_time = getExecutionTime(frq, forced_exec);

	// Let's check the habilitations (added September 13, 2013)
	var superadmin = actx.$APARAM(_).AGETVALCHAR(_, "ALEVFOLD", nomap, 'ADMUSR')
	var rights = actx._x3Rights.getRights(_, actx.$LOGIN(_));
	tracerJs.debug && tracerJs.debug("CODMET:" + rights._CODMET);
	tracerJs.debug && tracerJs.debug("PRFFCT:" + rights._PRFFCT);
	tracerJs.debug && tracerJs.debug("PRFCOD:" + rights._PRFCOD);
	tracerJs.debug && tracerJs.debug("ALLACS:" + rights._ALLACS);


	var self = this;
	var sqlDriver = superv.sqlDriver;
	var param = sqlDriver.param;

	// Access control :
	if (rights._PRFCOD !== superadmin) {
		var alh = superv.load(_, 'Table', 'ALISTEH');
		var rs = alh.loadRecords(_, alh.indexes[0], [request_code]);
		tracerJs.debug && tracerJs.debug("ALISTEH rs:" + JSON.stringify(rs));
		if (!rs.length) throw new HttpError(404, superv.loadMessParams(_, 26, 149, request_code));

		if (rs[0].ACS && rs[0].ALLUSR !== 2) {
			if (rights._accessCodes.indexOf(rs[0].ACS) < 0) throw new HttpError(404, superv.loadMessParams(_, 29, 149, request_code)); //Access denied
		}
		// Access to the function : it must at least be available on a group
		if (rs[0].FCTLNK && rs[0].ALLUSR !== 2) {
			if (rights._authorizedFunctions.indexOf(rs[0].FCTLNK) < 0) throw new HttpError(404, superv.loadMessParams(_, 29, 149, request_code)); //Access denied
		}
	}

	// If a portal view set of parameters exists, we have to manage the execution time and the level
	if (qs.portview) {
		var apv = superv.load(_, 'Table', 'APTLVW');
		var rs = apv.loadRecords(_, apv.indexes[0], [qs.portview]);
		tracerJs.debug && tracerJs.debug("APTLVW rs:" + JSON.stringify(rs));

		if (apv.length) {
			var j = rs[0].SRCPARCOD.indexOf('FRQ');
			if (j) {
				// Frequency of computation : 1=always, 2=every hour, 3=every day, 4=every week, 5=every month, 6=never
				// EXECUTION_TIME is assigned as a time stamp numeric value (if 0, recomputation is not required)
				frq = evalue(_, apv[0].SRCPARFOR(j));
				execution_time = getExecutionTime(frq, forced_exec);
			}
			if (!level || level === 99) {
				j = rs[0].SRCPARCOD.indexOf('INITLEVEL');
				if (j) {
					level = evalue(_, apv[0].SRCPARFOR(j));
				}
			}

			// Dom October 14, 2014
			// If a calendar is used:
			//  - first, get the list of fields by calling a new subprogram (FIELDS) in the generated script
			//  - second, create the JSON prototype complement that maps the fields with the calendar
			if (["FCA", "FCC"].indexOf(apv[0].CMPCODTYP)) {
				var args = {
					FIELDS: {
						type: 'AS20',
						value: [1, "", [], 1, null]
					},
					NBFIELDS: {
						type: 'AI',
						value: 0
					}
				};
				runtime.executeProg(_, mod, "FIELDS", args);
				var fields = args.value.FIELDS;
				var nbfields = args.value.NBFIELDS;
				tracerJs.debug && tracerJs.debug("requester calendar fields:" + fields);

				var fcdatedeb = getPortalValue(apv[0], 'FCDATEDEB', fields);
				if (fcdatedeb) {
					calendarPrototype = calendarPrototype || {};
					calendarPrototype.start = [];
					calendarPrototype.start.push(fcdatedeb);

					var fcheurdeb = getPortalValue(apv[0], 'FCHEURDEB', fields);
					if (fcheurdeb) calendarPrototype.start.push(fcheurdeb);

					var fcheurfin = getPortalValue(apv[0], 'FCHEURFIN', fields);
					if (fcheurfin) {
						calendarPrototype.end = [fcdatedeb, fcheurfin];
					}
				}
				var fctitre = getPortalValue(apv[0], 'FCTITRE', fields);
				if (fctitre) {
					calendarPrototype = calendarPrototype || {};
					calendarPrototype.summary = [fctitre];
				}
				var fctexte = getPortalValue(apv[0], 'FCTEXTE', fields);
				if (fctexte) {
					calendarPrototype = calendarPrototype || {};
					calendarPrototype.description = [fctexte];
				}
			}
		}
	}

	// Set some default values
	level = Math.max(Math.min([level, maxlevel]), 1);

	if (qs.where) {
		//Analyze the where sentence
		// 1°) set default values:
		try {
			for (var i = 0; i < param[2].length; i++) {
				var etnaType = type.typTyp2EtnaType[partyp[2][i]];
				valbeg[2][i] = valend[2][i] = variables.types[etnaType].def;
				strictbeg[2][i] = strictend[2][i] = 0; // Value not set
			}
			// 2°) parse the sdata expression :
			var filter = filterHelpers.sdataFilterToJson(qs.where);

			// 2°) set values :
			//    STRICTBEG and STRICTEND) => (0=no value in VALBEG/END, 1=strict comparizon, 2=can be equal)
			var expressions = filter.$and ? filter.$and : [filter];
			expressions.forEach(function(exp) {
				var i = param[2].indexOf(exp);
				if (i) {
					if (typeof exp === 'object') {
						Object.keys(expressions[exp]).forEach(function(operator) {
							switch (operator) {
								case '$eq':
									valbeg[2][i] = valend[2][i] = expressions[exp];
									strictbeg[2][i] = strictend[2][i] = 2;
									break;
								case '$gt':
									valbeg[2][i] = expressions[exp][operator];
									strictbeg[2][i] = 1;
									break;
								case '$gte':
									valbeg[2][i] = expressions[exp][operator];
									strictbeg[2][i] = 2;
									break;
								case '$lt':
									valend[2][i] = expressions[exp][operator];
									strictend[2][i] = 1;
									break;
								case '$lte':
									break;
									valend[2][i] = expressions[exp][operator];
									strictend[2][i] = 2;
									break;
							}
						})
					} else {
						valbeg[2][i] = valend[2][i] = expressions[exp];
						strictbeg[2][i] = strictend[2][i] = 2;
					}
				}
			});
		} catch (e) {
			throw new HttpError(404, superv.loadMessParams(_, 27, 149, request_code)); //Access denied
		}
	} else {
		// Let's analyse first_xxx and last_xxx parameters if QWHERE is empty
		try {
			var args = {
				ARCV: {
					type: "LY",
					value: arcv
				},
				VALBEG: {
					type: "AS",
					value: valbeg
				},
				VALEND: {
					type: "AS",
					value: valend
				},
				STRICTBEG: {
					type: "AI",
					value: strictbeg
				},
				STRICTEND: {
					type: "AI",
					value: strictend
				}
			};
			runtime.executeProg(_, mod, "PARSE_PARAM", args);
		} catch (e) {
			// PARSE_PARAM doesn't always exist ...
		}
	}

	// Get the recomputation parameter
	var line_limit = actx.$APARAM(_).AGETVALNUM(_, 1, "", "SELWARN") || 10000;

	// If unique id not set, and ( forced execution requested, or request type = recalculated), execute first
	if (requid === "" && (forced_exec || ifshared === 3)) {

		var args = {
			TBSIZE: {
				type: "AI",
				value: 0
			}
		};

		if (actx.$APARAM(_).AGETVALNUM(_, 1, "", "TYPDBA") === 1) {
			runtime.executeProg(_, mod, "GET_NBREC_ORACLE", args);
		} else {
			runtime.executeProg(_, mod, "GET_NBREC_SQL", args);
		}
		if (args.TBSIZE.value > line_limit) {
			//TODO: Gosub RQTBATCH
			// cf CRERQT from ASYRMNGTREQ
		} else {
			var args = {
				ACTX: {
					type: "AY",
					value: actx
				},
				VALBEG: {
					type: "AS",
					value: valbeg
				},
				VALEND: {
					type: "AS",
					value: valend
				},
				STRICTBEG: {
					type: "AI",
					value: strictbeg
				},
				STRICTEND: {
					type: "AI",
					value: strictend
				},
				LIMITS: {
					type: 'BI',
					value: limits
				},
				NBLIG: {
					type: 'AI',
					value: nblig
				},
				REQUID: {
					type: 'AS',
					value: requid,
				},
				UUIREQ: {
					type: 'BS',
					value: uuireq
				}
			};
			Object.keys(args).filter(function(key) {
				return key !== 'ACTX';
			}).forEach(function(key) {
				tracerJs.debug && tracerJs.debug(">>requester.EXEC_RQT " + key + "=" + JSON.stringify(args[key]));
			});
			runtime.executeProg(_, mod, "EXEC_RQT", args);
			Object.keys(args).filter(function(key) {
				return key !== 'ACTX';
			}).forEach(function(key) {
				tracerJs.debug && tracerJs.debug("<<requester.EXEC_RQT " + key + "=" + JSON.stringify(args[key]));
			});

			//       Gosub GETRQT
			//     Endif
			// # Otherwise, try to read it first
			//   Else
			//     Gosub GETRQT

			//     # If the request was never executed, or if the parameter don't fit
			//     If indexOf(OK,3,5)
			//       If fmet Gactx.$APARAM(_).AGETVALNUM(1,"","TYPDBA")=1
			//         Call GET_NBREC_ORACLE(TBSIZE) From=PROGNAME
			//       Else
			//         Call GET_NBREC_SQL(TBSIZE) From=PROGNAME
			//       Endif
			//       If TBSIZE>LINE_LIMIT
			//         Gosub RQTBATCH
			//       Else
			//         OK=0
			//         # Added a reexecution Dec 10, 2012
			//         Call EXEC_RQT(GACTX,VALBEG,VALEND,STRICTBEG,STRICTEND,LIMITS,NBLIG,REQUID,UUIREQ) From =PROGNAME
			//         Gosub GETRQT
			//       Endif
			//     Endif
			//   Endif

			//   Case OK
			//     When 2 :
			//      Call SPLIT(KEYS,PSYR.SELREP,"~") From ASYRSUB
			//      ERROR = func ASYRSUB._ASETSTATUS(ACTX,"",0,[V]CST_AERROR,[V]CST_AHTTP_NOT_FOUND,func ASYRFNC.MES1(mess(27,149,1),KEYS(1)))
			//     When 4 :
			//      # Access rights error
			//      ERROR = func ASYRSUB._ASETSTATUS(ACTX,"",0,[V]CST_AERROR,[V]CST_AHTTP_FORBIDDEN,func ASYRFNC.MES1(mess(29,149,1),PSYR.CODREP))
			//     When 6 :
			//      ERROR = func ASYRSUB._ASETSTATUS(ACTX,"",0,[V]CST_AERROR,[V]CST_AHTTP_NOT_FOUND,func ASYRFNC.MES1(mess(28,149,1),PSYR.CODREP))
			//     When 7 :
			//       # TODO : error in transaction for posting the batch request
			//       ERROR = func ASYRSUB._ASETSTATUS(ACTX,"",0,[V]CST_AERROR,[V]CST_AHTTP_NOT_FOUND,func ASYRFNC.MES1(mess(28,149,1),PSYR.CODREP))
			//   Endcase

			//   If OK=0
			//     ERRNUM=0
			//     ASND.STAT     = 200
			//     ASND.URL      = PSYR.PREFIX+'/'+REPRESENTATION
			//     ASND.CONTTYPE = PSYR.CNTPRE+"."+nomap+"."+REPRESENTATION+"."+httpContext.facet
			//   Elsif OK=1
			//     ERRNUM=0
			//     ASND.STAT     = 202
			//     ASND.URL      = PSYR.PREFIX+'/'+REPRESENTATION
			//     ASND.CONTTYPE = PSYR.CNTPRE+"."+nomap+"."+REPRESENTATION+"."+httpContext.facet
			//     ASND.DATA     = '{"headerMessage":"'+func AFNC.MES1(func AJSONLIB.M(glob.context.x3session.actx.LAN(_),146,24),num$(BATCHID)-UUIREQ)+'"}'
			//    Endif
			// Return
		}
	}
	return {};
}