"use strict";
var X3Error = require("etna-engine/lib/runtime/errors").X3Error;
var attributes = require("etna-supervisor/lib/attributes");
var snapshots = require("etna-supervisor/lib/snapshots");
var variables = require('etna-engine/lib/runtime/variables');
var tracerJs = require("syracuse-trace/lib/helper").getTracer("etna.supervisor");
var util = require("etna-supervisor/lib/util");
var mapping = require("etna-supervisor/lib/mapping");
var constants = require("etna-supervisor/lib/constants");

// var debug = function(m) {
// 	console.error("collection - " + m);
// };


function InstanceCollection(parent, collection) {
	this.supervisor = parent.supervisor;
	this.collection = collection;
	if (collection.data.MAXCOL === 2) this.lines = [null];
	else if (collection.data.MINCOL === 3 && collection.data.MAXCOL > 0)
		this.lines = new Array(collection.data.MAXCOL);
	else this.lines = [];

	this.bindAttributes(parent);
}

InstanceCollection.prototype.deleteChildren = function() {
	this.lines = [];
	return this;
};

Object.defineProperty(InstanceCollection.prototype, "class", {
	get: function() {
		return this.collection.class;
	},
	enumerable: false
});

InstanceCollection.prototype.x3Maxtab = function() {
	tracerJs.debug && tracerJs.debug("instanceCollection x3Maxtab:" + this.lines.length);
	return this.lines.length;
};

InstanceCollection.prototype._get = function(_) {
	if (this.$lazyLoading) {
		this.lines = this.collection.class.loadInstances(_,
			this.$parent,
			mapping.getIndex(_, this.supervisor, this.collection.mappingData),
			this.relKeys)
			.map(function(_, instance) {
				instance.action(_, "AREAD_AFTER");
				return instance;
			})
			.toArray(_);
		this.$lazyLoading = false;
	}
	return this;
};

InstanceCollection.prototype.fromRecord = function(_, record) {
	tracerJs.debug && tracerJs.debug("InstanceCollection.fromRecord:" + JSON.stringify(record));

	if (this.collection.mappingData) {
		this.$lazyLoading = true;
		// Compute the collection keys for the lazy load :
		this.relKeys = mapping.getKeys(_, this.collection.mappingData, record);
	} else {
		// no mapping - denormalized
		var count;
		if (this.collection.data.PROCOL) {
			var procol = this.collection.data.PROCOL;
			count = record[procol];
		}
		if (count === undefined) {
			count = Math.max(0, this.collection.count);
		}

		if (!this.collection.class) return console.error("ignoring collection " + this.collection.name), [];

		for (var i = 0; i < count; i++) {
			var line = this.$parent.supervisor.new(_, 'Instance', this.collection.class, this).afterCreate(_, record, i);
			line.$astalin = 0;
			this.lines.push(line);
		}
	}
};

InstanceCollection.prototype.crud = function(_, fname, f) {
	var status;
	var crupro = this.collection.name;
	var curpth = crupro;
	try {
		// The BEFORE is managed by the parent:
		status = this.$parent.action(_, fname + "_BEFORE", null, crupro, curpth);
		if (status === constants.CST_AERROR) return status;

		var line = f(_, this);

		// The AFTER is managed by the line:
		return line.action(_, fname + "_AFTER");
	} catch (e) {
		console.error(e);
		var status = this.$parent.addDiagnose(_, constants.CST_AERROR, e.message);
		return Math.max(status, this.$parent.action(_, fname + "_ABORT", this.key));
	}
};


InstanceCollection.prototype.add = function(_, position) {
	var self = this;
	this.$lazyLoading && this.get(_);
	if (self.getAttribute("$isReadOnly") || (self.collection.data.MAXCOL && (self.lines.length === self.collection.data.MAXCOL))) return -1;

	// Let's take snaps of the collection if necessary : 
	self.snapshots();

	var insertedAt = 1;
	// Controled by the parent :
	self.crud(_, 'ADDLINE', function ADDLINE(_, col) {
		var line = col.$parent.supervisor.new(_, 'Instance', col.class, col.$parent).afterCreate(_);
		line.bindAttributes(col);
		line.AINIT(_);

		// Update properties defined by the parent :
		col.collection.mappingData && col.collection.mappingData.MAPS
			.filter(function(map) {
				return map.PROMAP !== undefined;
			})
			.forEach_(_, function(_, map) {
				line.set(_, map.KEYMAP, col.$parent.get(_, map.PROMAP));
			});

		// init
		if (position === variables.constants.CST_AFIRSTPOS) {
			col.lines.unshift(line);
		} else {
			col.lines.push(line);
			insertedAt = col.lines.length;
		}
		line.$astalin = constants.CST_ANEW;
		col.$astalin = constants.CST_AUPD;
		col.$parent.setASTALIN(col.$astalin);
		return line;
	});
	return insertedAt;
};

InstanceCollection.prototype.del = function(_, position) {
	var self = this;
	this.$lazyLoading && this.get(_);

	if (this.getAttribute("$isReadOnly") || !this.lines.length || (position !== -1) && (position < 1 || position > this.lines.length)) return -1;

	// Let's take snaps of the collection if necessary : 
	this.snapshots();

	// Controled by the parent :
	var deletedAt = -1;
	self.crud(_, 'ADELLINE', function ADELLINE(_, col) {
		deletedAt = ((position === constants.CST_ALASTPOS) ? col.lines.length : position) - 1;

		if (self.collection.mappingData) {
			// Mark the line as deleted :  
			col.lines[deletedAt].$astalin = (col.lines[deletedAt].$astalin === constants.CST_ANEW) ?
				constants.CST_ANEWDEL :
				constants.CST_ADEL;
		} else {
			// Remove the line :
			col.lines.splice(deletedAt, 1);
		}

		return col.lines[deletedAt];
	});
	return deletedAt;
};

InstanceCollection.prototype.index = function(_, position) {
	if (position > this.lines.length) throw new X3Error(8, "collection index out of range :" + position);
	return this.lines[position - 1];
};

InstanceCollection.prototype.clone = function() {
	var to = new InstanceCollection(this.$parent, this.collection);
	to.lines = this.lines.slice(0);

	attributes.clone(this, to);
	to.snapshotof = this;
	return to;
};

InstanceCollection.prototype.revertTo = function(input) {
	if (!this.snapshotof) return this;

	var to = this.snapshotof;
	to.lines = [];
	for (var i = 0, len = this.lines.length; i < len; i++) {
		var from = this.lines[i];
		to.lines[i] = from.revertTo();
		to.lines[i].releaseSnapshot(from);
	}
	attributes.revertTo(this, this.snapshotof);
	return to;
};

InstanceCollection.prototype.getChildren = function() {
	return this.lines;
};

InstanceCollection.prototype.updateProperty = function(from, to) {
	for (var i = 0, len = this.lines.length; i < len; i++) {
		if (this.lines[i] == from) {
			this.lines[i] = to;
			break;
		}
	}
};

InstanceCollection.prototype.setColumnAttribute = function(column, attribut, value) {
	this.snapshots();
	return this.setColAttribute(column, attribut, value);
};


InstanceCollection.prototype.applyToEach = function(_, f, operation) {

	var status = constants.CST_AOK;

	var operations = {
		2: "insert", //CST_ANEW
		4: "update", //CST_AUPD
		16: "delete" //CST_ADEL
	};

	var lines = this.lines;

	if (operation === undefined) {
		// Filter and sort the lines
		var self = this;
		lines = this.lines.filter(function(line) {
			return line.$astalin > constants.CST_ANEWDEL;
		}).sort(function(line1, line2) {
			return line2.$astalin - line1.$astalin;
		});
	}
	for (var i = 0, len = lines.length; i < len; i++) {
		var line = lines[i];
		var op = operation || operations[line.$astalin];
		if (op) {
			status = f(_, line, op);
			if (status === constants.CST_AERROR) return status;
		}
	}
	return status;
};


InstanceCollection.prototype.onMapChange = function(_, property, value) {
	return this.applyToEach(_, function(_, line, operation) {
		return line[operation](_, property, value);
	}, "onMapChange");
};



InstanceCollection.prototype.onControl = function(_, type, operation) {
	if (!/^Update$/.test(operation))
		return this.applyToEach(_, function(_, line, operation) {
			return line[type](_, operation);
		}, operation);

	// Update:
	return this.applyToEach(_, function(_, line, typeOperation) {
		return line[type](_, typeOperation.toUpperCase());
	});
};

InstanceCollection.prototype.executeControl = function(_, type) {
	return this.applyToEach(_, function(_, line, typeOperation) {
		return line[typeOperation](_, type);
	}, "executeControl");
};

InstanceCollection.prototype.insert = function(_) {
	return this.applyToEach(_, function(_, line, operation) {
		return line[operation](_);
	}, "insert");
};

InstanceCollection.prototype.update = function(_) {
	return this.applyToEach(_, function(_, line, typeOperation) {
		return line[typeOperation](_);
	});
};


InstanceCollection.prototype.delete = function(_) {
	return this.applyToEach(_, function(_, line, operation) {
		return line[operation](_);
	}, "delete");
};


InstanceCollection.prototype.getDiagnoses = function(path) {
	return undefined; //TODO
};

attributes.addAttributes(InstanceCollection.prototype);
attributes.addColAttributes(InstanceCollection.prototype);
snapshots.addSnapshots(InstanceCollection.prototype);
exports.InstanceCollection = InstanceCollection;

exports.newInstanceCollection = function(property) {
	return function(_, parent) {
		return new InstanceCollection(parent, property.collection);
	};
};