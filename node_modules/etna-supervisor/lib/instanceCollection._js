"use strict";
var X3Error = require("etna-engine/lib/runtime/errors").X3Error;
var attributes = require("etna-supervisor/lib/attributes");
var snapshots = require("etna-supervisor/lib/snapshots");
var variables = require('etna-engine/lib/runtime/variables');
var tuuid = require('etna-engine/lib/runtime/tuuid');

var tracerJs = require("syracuse-trace/lib/helper").getTracer("etna.supervisor");
var util = require("etna-supervisor/lib/util");
var mapping = require("etna-supervisor/lib/mapping");
var constants = require("etna-supervisor/lib/constants");
var Cache = require("etna-supervisor/lib/cache").Cache;
var Diagnosis = require("etna-supervisor/lib/meta/diagnosis");

var helpers = require("syracuse-core/lib/helpers");

// var debug = function(m) {
// 	console.error("collection - " + m);
// };


var InstanceCollection = helpers.defineClass(function(parent, collection) {
	this.supervisor = parent.supervisor;
	this.collection = collection;
	// Empty arrapy
	this.lines = [];
	/*if (collection.data.MINCOL === 2) {
		// At least one line
		this.lines = [null];
	} else if (collection.data.MINCOL === 3 && collection.data.MAXCOL > 0) {
		// Allocate collection.data.MAXCOL lines:
		this.lines = new Array(collection.data.MAXCOL);
	}*/
	this.bindAttributes(parent);
	this.proName = "";
	this.$uuid = tuuid.generate();
}, null, {
	$$type: {
		get: function() {
			return "InstanceCollection";
		}
	},
	name: {
		get: function() {
			return this.collection.name;
		},
		enumerable: false,
	},
	PROCOL: {
		get: function() {
			return this.collection.data.PROCOL;
		},
		enumerable: false,
	},
	deleteChildren: function() {
		this.lines = [];
		return this;
	},
	"class": {
		get: function() {
			return this.collection.class;
		}
	},
	x3Maxtab: function() {
		return this.lines.length;
	},
	_get: function(_) {
		var self = this;
		if (this.$lazyLoading) {
			this.lines = this.collection.class.loadInstances(_,
				self.$parent,
				mapping.getIndex(_, this.supervisor, this.collection.mappingData),
				this.relKeys)
				.map(function(_, instance) {
					instance.$parent = self;
					instance.APARENT = self.$parent;
					return instance;
				})
				.toArray(_);
			this.$lazyLoading = false;
		}
		return this;
	},
	// for X3Son :
	_set: function(_, lines) {
		if (Array.isArray(lines) && lines.length && lines[0].class && lines[0].class.name === this.class.name) {
			this.lines = lines;
			for (var i = 0; i < lines.length; i++) {
				this.lines[i].$parent = this;
				this.lines[i].APARENT = this.$parent;
			}
		}
	},
	fromRecord: function(_, record) {
		tracerJs.debug && tracerJs.debug("InstanceCollection.fromRecord:" + JSON.stringify(record));

		if (this.collection.mappingData) {
			this.$lazyLoading = true;
			// Compute the collection keys for the lazy load :
			this.relKeys = mapping.getKeys(_, this.collection.mappingData, record);
		} else {
			// no mapping - denormalized
			var count;
			if (this.collection.data.PROCOL) {
				var procol = this.collection.data.PROCOL;
				count = record[procol];
			}
			if (count === undefined) {
				count = Math.max(0, this.collection.count);
			}


			if (!this.collection.class) return console.error("ignoring collection " + this.collection.name), [];

			if (count) {
				var self = this;
				var cache = new Cache();

				Object.keys(this.collection.class.properties).forEach_(_, function(_, p) {
					var property = self.collection.class.properties[p];
					if (!/_REF$/.test(p)) {
						if (property.isAtextra)
							cache.addProperty(_, property);
						else if (property.isReference(_))
							cache.addReference(_, property);
					}
				});

				for (var i = 0; i < count; i++) {
					var line = this.$parent.supervisor.new(_, 'Instance', this.collection.class, this).afterCreate(_, record, i);
					line.$uuid = tuuid.generate(); // Don't reuse the uuid of the parent !
					line.$index = i;
					line.APARENT = this.$parent;
					line.$astalin = 0;
					this.lines[i] = line;
					cache.isActivated && cache.register(_, line);
				}
			}
		}
	},
	crud: function(_, fname, f) {
		var status;
		var crupro = this.collection.name;
		var curpth = crupro;
		try {
			// The BEFORE is managed by the parent:
			status = this.$parent.action(_, fname + "_BEFORE", null, crupro, curpth);
			if (status === constants.CST_AERROR) return status;

			var line = f(_, this);

			// The AFTER is managed by the line:
			return line.action(_, fname + "_AFTER");
		} catch (e) {
			console.error(e);
			console.error(e.stack);
			var status = this.$parent.addDiagnose(_, constants.CST_AERROR, e.message);
			return Math.max(status, this.$parent.action(_, fname + "_ABORT", this.key));
		}
	},
	AINIT: function(_) {
		tracerJs.debug && tracerJs.debug("InstanceCollection _ainit");
		if (this.collection.data.MINCOL === 2) {
			// At least one line
			var line = this.newline(_);
			this.lines[0] = line;
		} else if (this.collection.data.MINCOL === 3 && this.collection.data.MAXCOL > 0) {
			// Allocate collection.data.MAXCOL lines:
			//this.lines = new Array(collection.data.MAXCOL);
		}
		//line = this.newline(_);
		//this.lines[position - 1] = line;
		return constants.CST_AOK;
	},
	newline: function(_) {
		var line = this.$parent.supervisor.new(_, 'Instance', this.class, this).afterCreate(_);
		// Modify the APARENT of the line :
		line.APARENT = this.$parent;
		line.AINIT(_);

		// Update properties defined by the parent :
		var self = this;
		this.collection.mappingData && this.collection.mappingData.MAPS
			.filter(function(map) {
				return map.PROMAP !== undefined;
			})
			.forEach_(_, function(_, map) {
				line.set(_, map.KEYMAP, self.$parent.get(_, map.PROMAP));
			});

		// init
		line.$astalin = constants.CST_ANEW;
		return line;
	},
	add: function(_, position, uuid) {
		var self = this;
		this.$lazyLoading && this.get(_);
		if (self.getAttribute("$isReadOnly") || (self.collection.data.MAXCOL && (self.lines.length === self.collection.data.MAXCOL))) return -1;

		// Let's take snaps of the collection if necessary : 
		self.snapshots();

		var insertedAt = 1;
		// Controled by the parent :
		self.crud(_, 'ADDLINE', function ADDLINE(_, col) {
			var line = col.newline(_);
			if (uuid !== undefined) line.$uuid = uuid;

			if (position === variables.constants.CST_AFIRSTPOS) {
				col.lines.unshift(line);
			} else if (position === variables.constants.CST_ALASTPOS) {
				col.lines.push(line);
				insertedAt = col.lines.length;
			} else {
				// Insert the line in the collection
				col.lines.splice((position - 1), 0, line);
				insertedAt = position;
			}
			col.$astalin = constants.CST_AUPD;
			col.$parent.setASTALIN(col.$astalin);
			return line;
		});
		return insertedAt;
	},
	del: function(_, position) {
		var self = this;
		this.$lazyLoading && this.get(_);

		if (this.getAttribute("$isReadOnly") || !this.lines.length || (position !== -1) && (position < 1 || position > this.lines.length)) return -1;

		// Let's take snaps of the collection if necessary : 
		this.snapshots();

		// Controled by the parent :
		var deletedAt = -1;
		self.crud(_, 'ADELLINE', function ADELLINE(_, col) {
			deletedAt = ((position === constants.CST_ALASTPOS) ? col.lines.length : position) - 1;
			var deletedLine = col.lines[deletedAt];
			if (self.collection.mappingData) {
				// Mark the line as deleted :  
				col.lines[deletedAt].$astalin = (col.lines[deletedAt].$astalin === constants.CST_ANEW) ?
					constants.CST_ANEWDEL :
					constants.CST_ADEL;
			} else {
				// Remove the line :
				col.lines = col.lines.slice(0, deletedAt).concat(col.lines.slice(deletedAt + 1));
			}
			return deletedLine;
		});
		return deletedAt;
	},
	empty: function(_) {
		for (var i = 1, max = this.x3Maxtab(); i <= max; i++) {
			this.del(_, constants.CST_ALASTPOS);
		}
	},
	index: function(_, position) {
		if (position > this.lines.length) throw new X3Error(8, "collection index out of range :" + position);
		var line = this.lines[position - 1];
		if (!line) {
			// Create an empty line
			line = this.newline(_);
			this.lines[position - 1] = line;
		}
		return line;
	},
	find: function(key, val) {
		for (var i = 0, len = this.lines.length; i < len; i++) {
			var line = this.lines[i];
			if (line !== null && line[key].x3Compare(val) === 0) {
				return line;
			}
		}
		return null;
	},
	clone: function() {
		var to = new InstanceCollection(this.$parent, this.collection);
		to.lines = this.lines.slice(0);

		attributes.clone(this, to);
		to.snapshotof = this;
		return to;
	},

	revertTo: function(input) {
		if (!this.snapshotof) return this;

		var to = this.snapshotof;
		to.lines = [];
		for (var i = 0, len = this.lines.length; i < len; i++) {
			var from = this.lines[i];
			to.lines[i] = from.revertTo();
			to.lines[i].releaseSnapshot(from);
		}
		attributes.revertTo(this, this.snapshotof);
		return to;
	},
	getChildren: function() {
		return this.lines;
	},
	updateProperty: function(from, to) {
		for (var i = 0, len = this.lines.length; i < len; i++) {
			if (this.lines[i] == from) {
				this.lines[i] = to;
				break;
			}
		}
	},
	setColumnAttribute: function(column, attribut, value) {
		this.snapshots();
		return this.setColAttribute(column, attribut, value);
	},
	applyToEach: function(_, f, operation) {

		var status = constants.CST_AOK;

		var operations = {
			2: "insert", //CST_ANEW
			4: "update", //CST_AUPD
			16: "delete" //CST_ADEL
		};

		var lines = this.lines;

		if (operation === undefined) {
			// Filter and sort the lines
			var self = this;
			lines = this.lines.filter(function(line) {
				return line !== null && line.$astalin > constants.CST_ANEWDEL;
			}).sort(function(line1, line2) {
				return line2.$astalin - line1.$astalin;
			});
		}
		for (var i = 0, len = lines.length; i < len; i++) {
			var line = lines[i];
			if (line !== null) {
				var op = operation || operations[line.$astalin];
				if (op) {
					status = f(_, line, op, i + 1);
					if (status === constants.CST_AERROR) return status;
				}
			}
		}
		return status;
	},
	onMapChange: function(_, property, value) {
		return this.applyToEach(_, function(_, line, operation) {
			return line[operation](_, property, value);
		}, "onMapChange");
	},
	onControl: function(_, type, operation) {
		if (!/^Update$/.test(operation))
			return this.applyToEach(_, function(_, line, operation) {
				return line[type](_, operation);
			}, operation);

		// Update:
		return this.applyToEach(_, function(_, line, typeOperation) {
			return line[type](_, typeOperation.toUpperCase());
		});
	},
	executeControl: function(_, type) {
		return this.applyToEach(_, function(_, line, typeOperation) {
			return line[typeOperation](_, type);
		}, "executeControl");
	},
	insert: function(_) {
		return this.applyToEach(_, function(_, line, operation) {
			return line[operation](_);
		}, "insert");
	},
	update: function(_) {
		return this.applyToEach(_, function(_, line, typeOperation) {
			return line[typeOperation](_);
		});
	},
	delete: function(_) {
		return this.applyToEach(_, function(_, line, operation) {
			return line[operation](_);
		}, "delete");
	},
	addDiagnose: function(_, severity, message, category) {
		Diagnosis.trace(severity, this.name + " :'" + message + "'");
		this.diagnoses = this.diagnoses || [];
		this.diagnoses.push(this.$parent.supervisor.new(_, 'Diagnosis', severity, message, "", category));
		return severity;
	},
	getDiagnoses: function(_) {
		var res = [];
		var self = this;
		var idx = 1;

		this.applyToEach(_, function(_, line, operation, lineNo) {
			var lerr = line[operation](_);
			res = res.concat(lerr.map_(_, function(_, d) {
				var pro = d.get(_, "PRO");
				d.set(_, "PRO", self.name + '(' + lineNo + ')' + ((pro !== "") ? '.' + pro : ""));
				return d;
			}));
		}, "getDiagnoses");
		return res;
	},

	deleteDiagnoses: function(_) {
		this.applyToEach(_, function(_, line, operation) {
			line[operation](_);
		}, "deleteDiagnoses");
	},

	getDelta: function(_, snapshot) {
		var lines = this.lines;

		var isLineDeleted = false;
		// Compare the old and the new collection :
		if (lines.length < snapshot.lines.length) {
			// A line was deleted during the operation :
			isLineDeleted = true;
		} else {
			var diffLines = {};
			var lineIndex = 0;
			diffLines = snapshot.lines.reduce(function(r, line) {
				var uuid = line.$uuid.x3ToString();
				//dbg:console.error("snapshot line:"+uuid);
				r[uuid] = ++lineIndex;
				return r;
			}, {});

			lineIndex = 0;
			var dbg = 0;
			var self = this;
			lines.forEach_(_, function(_, line) {
				var uuid = line.$uuid.x3ToString();
				if (line.$astalin === constants.CST_ADEL || line.$astalin === constants.CST_ANEWDEL) {
					isLineDeleted = true;
				} else {
					++lineIndex;
					//dbg:console.error("collection line:"+uuid);
					if (diffLines[uuid] && line.$syssnapshot === undefined) {
						//dbg:console.error("remove "+uuid+" from diffLines");
						delete diffLines[uuid];
					} else {
						//dbg:console.error("keep line "+uuid+" from diffLines");
						var line = self.index(_, lineIndex);
						line.$index = (lineIndex - 1);
						diffLines[uuid] = line;
					}
				};
			});
		}

		if (isLineDeleted === false) {
			// The list to send = modified lines 
			lines = [];
			Object.keys(diffLines).forEach_(_, function(_, uuid) {
				//dbg:console.error("keep line "+uuid);
				lines.push(diffLines[uuid]);
			});
		}
		return lines;
	}
});

attributes.addAttributes(InstanceCollection.prototype);
attributes.addColAttributes(InstanceCollection.prototype);
snapshots.addSnapshots(InstanceCollection.prototype);
exports.InstanceCollection = InstanceCollection;

exports.newInstanceCollection = function(property) {
	return function(_, parent) {
		var instanceCollection = new InstanceCollection(parent, property.collection);
		instanceCollection.proName = property.name;
		if (instanceCollection.PROCOL) {
			var procol = parent.slot(_, instanceCollection.PROCOL);
			if (procol) {
				// Change the _get of the PROCOL property so that it automatically returns
				// The number of elements in the associated collection :
				procol._get = function(procol, propery) {
					return function(_, raw) {
						tracerJs.debug && tracerJs.debug(procol + "._get " + property.name + ".x3Maxtab()");
						var instance = this.$parent;
						var collection = instance.slot(_, property.name);
						return collection.x3Maxtab();
					};
				}(instanceCollection.PROCOL, property);
			}
		}
		return instanceCollection;
	};
};