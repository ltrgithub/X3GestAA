"use strict";
var X3Error = require("etna-engine/lib/runtime/errors").X3Error;
var attributes = require("etna-supervisor/lib/attributes");
var snapshots = require("etna-supervisor/lib/snapshots");
var variables = require('etna-engine/lib/runtime/variables');
var tracerJs = require("syracuse-trace/lib/helper").getTracer("etna.supervisor");
var util = require("etna-supervisor/lib/util");
var constants = require("etna-supervisor/lib/constants");

var debug = function(m) {
	console.error("collection - " + m);
};


function InstanceCollection(parent, collection) {
	this.supervisor = parent.supervisor;
	this.collection = collection;
	this.lines = [];
	//this.parent = parent;
	this.bindAttributes(parent);
}

Object.defineProperty(InstanceCollection.prototype, "deleteChildren", {
	value: function() {
		this.lines = [];
		return this;
	},
	enumerable: false,
});

Object.defineProperty(InstanceCollection.prototype, "class", {
	get: function() {
		return this.collection.class;
	},
	enumerable: false
});

Object.defineProperty(InstanceCollection.prototype, "x3Maxtab", {
	value: function() {
		tracerJs.debug && tracerJs.debug("instanceCollection x3Maxtab:" + this.lines.length);
		return this.lines.length;
	},
	enumerable: false
});

Object.defineProperty(InstanceCollection.prototype, "get", {
	value: function(_) {
		if (this.$lazyLoading) {

			tracerJs.debug && tracerJs.debug("this.collection.mappingData.TABLNK " + this.collection.mappingData.TABLNK);
			var childTable = this.supervisor.load(_, 'Table', this.collection.mappingData.TABLNK);
			var childIndex;
			if (this.collection.mappingData.CLELNK) {
				childIndex = util.find(childTable.indexes, 'name', this.collection.mappingData.CLELNK);
			}
			if (childIndex === undefined) childIndex = childTable.indexes[0];

			this.lines = this.collection.class.loadInstances(_,
				this.$parent,
				childIndex,
				this.colKeys)
				.map(function(_, instance) {
					instance.action(_, "AREAD_AFTER");
					return instance;
				})
				.toArray(_);
			this.$lazyLoading = false;
		}
		return this;
	},
	enumerable: false,
});

Object.defineProperty(InstanceCollection.prototype, "fromRecord", {

	value: function(_, record) {
		tracerJs.debug && tracerJs.debug("InstanceCollection.fromRecord:" + JSON.stringify(record));

		if (this.collection.mappingData) {
			this.$lazyLoading = true;
			tracerJs.debug && tracerJs.debug("this.collection.mappingData.EXPLNK " + this.collection.mappingData.EXPLNK);
			// Compute the collection keys for the lazy load :
			var exps = this.collection.mappingData.EXPLNK.split(';');

			this.colKeys = exps.map(function(exp) {
				// for now ignore [F:XXX] part - see later
				if (exp.indexOf(']') > 0) {
					var p = exp.substring(exp.indexOf(']') + 1);
					return record[p];
				} else {
					return (record[exp] !== undefined) ? record[exp] : exp;
				}
			}, this);
			tracerJs.debug && tracerJs.debug("this.colKeys " + JSON.stringify(this.colKeys));

		} else {
			// no mapping - denormalized
			var count;
			if (this.collection.data.PROCOL) {
				var procol = this.collection.data.PROCOL;
				count = record[procol];
			}
			if (count === undefined) {
				count = Math.max(0, this.collection.count);
			}

			if (!this.collection.class) return console.error("ignoring collection " + this.collection.name), [];

			for (var i = 0; i < count; i++) {
				var line = this.$parent.supervisor.new(_, 'Instance', this.collection.class, this).afterCreate(_);
				line.fromRecord(_, record, i);
				line.$astalin = 0;
				this.lines.push(line);
			}
		}
	},
	enumerable: false,
});

Object.defineProperty(InstanceCollection.prototype, "crud", {
	value: function(_, f) {
		var status;
		var crupro = this.collection.name;
		var curpth = crupro;
		try {
			// The BEFORE is managed by the parent:
			status = this.$parent.action(_, f.name + "_BEFORE", null, crupro, curpth);
			if (status === constants.CST_AERROR) return status;

			var line = f(_, this);

			// The AFTER is managed by the line:
			return line.action(_, f.name + "_AFTER");
		} catch (e) {
			console.error(e);
			var status = this.$parent.addDiagnose(_, constants.CST_AERROR, e.message);
			return Math.max(status, this.$parent.action(_, f.name + "_ABORT", this.key));
		}
	},
	enumerable: false,
});


Object.defineProperty(InstanceCollection.prototype, "add", {
	value: function(_, position) {
		var self = this;
		this.$lazyLoading && this.get(_);
		if (self.getAttribute("$isReadOnly") || self.lines.length === self.collection.data.MAXCOL) return -1;

		// Let's take snaps of the collection if necessary : 
		self.snapshots();

		var insertedAt = 0;
		// Controled by the parent :
		self.crud(_, function ADDLINE(_, col) {
			var line = col.$parent.supervisor.new(_, 'Instance', col.class, col.$parent).afterCreate(_);
			line.bindAttributes(col);
			line.AINIT(_);

			// Update properties defined by the parent :
			col.collection.mappingData && col.collection.mappingData.MAPS
				.filter(function(map) {
					return map.PROMAP !== undefined;
				})
				.forEach_(_, function(_, map) {
					line.set(_, map.KEYMAP, col.$parent.get(_, map.PROMAP));
				});

			// init
			if (position === variables.constants.CST_AFIRSTPOS) {
				col.lines.unshift(line);
			} else {
				col.lines.push(line);
				insertedAt = col.lines.length - 1;
			}
			line.$astalin = constants.CST_ANEW;
			col.$astalin = constants.CST_AUPD;
			col.$parent.setASTALIN(col.$astalin);
			return line;
		});
		return insertedAt;
	},
	enumerable: false
});

Object.defineProperty(InstanceCollection.prototype, "del", {
	value: function(_, position) {
		var self = this;
		this.$lazyLoading && this.get(_);

		if (this.getAttribute("$isReadOnly") || !this.lines.length || position < -1 || position >= this.lines.length) return -1;

		// Let's take snaps of the collection if necessary : 
		this.snapshots();

		// Controled by the parent :
		var deletedAt = -1;
		self.crud(_, function ADELLINE(_, col) {
			deletedAt = (position === constants.CST_ALASTPOS) ? col.lines.length - 1 : position;

			if (self.collection.mappingData) {
				// Mark the line as deleted :  
				col.lines[deletedAt].$astalin = (col.lines[deletedAt].$astalin === constants.CST_ANEW) ?
					constants.CST_ANEWDEL :
					constants.CST_ADEL;
			} else {
				// Remove the line :
				col.lines.splice(deletedAt, 1);
			}

			return col.lines[deletedAt];
		});
		return deletedAt;
	},
	enumerable: false
});

Object.defineProperty(InstanceCollection.prototype, "index", {
	value: function(_, position) {
		if (position >= this.lines.length) throw new X3Error(8, "collection index out of range :" + position);
		return this.lines[position];
	},
	enumerable: false
});

Object.defineProperty(InstanceCollection.prototype, "clone", {
	value: function() {
		var to = new InstanceCollection(this.$parent, this.collection);
		to.lines = this.lines.slice(0);

		attributes.clone(this, to);
		to.snapshotof = this;
		return to;
	},
	enumerable: false
});

Object.defineProperty(InstanceCollection.prototype, "revertTo", {
	value: function(input) {
		if (!this.snapshotof) return this;

		var to = this.snapshotof;
		to.lines = [];
		for (var i = 0, len = this.lines.length; i < len; i++) {
			var from = this.lines[i];
			to.lines[i] = from.revertTo();
			to.lines[i].releaseSnapshot(from);
		}
		attributes.revertTo(this, this.snapshotof);
		return to;
	},
	enumerable: false,
});

Object.defineProperty(InstanceCollection.prototype, "getChildren", {
	value: function() {
		return this.lines;
	},
	enumerable: false
});

Object.defineProperty(InstanceCollection.prototype, "updateProperty", {
	value: function(from, to) {
		for (var i = 0, len = this.lines.length; i < len; i++) {
			if (this.lines[i] == from) {
				this.lines[i] = to;
				break;
			}
		}
	},
	enumerable: false
});

Object.defineProperty(InstanceCollection.prototype, "setColumnAttribute", {
	value: function(column, attribut, value) {
		this.snapshots();
		return this.setColAttribute(column, attribut, value);
	},
	enumerable: false
});


Object.defineProperty(InstanceCollection.prototype, "applyToEach", {
	value: function(_, f, operation) {

		var status = constants.CST_AOK;

		var operations = {
			2: "insert", //CST_ANEW
			4: "update", //CST_AUPD
			16: "delete" //CST_ADEL
		};

		var lines = this.lines;

		if (operation === undefined) {
			// Filter and sort the lines
			var self = this;
			lines = this.lines.filter(function(line) {
				return line.$astalin > constants.CST_ANEWDEL;
			}).sort(function(line1, line2) {
				return line2.$astalin - line1.$astalin;
			});
		}
		for (var i = 0, len = lines.length; i < len; i++) {
			var line = lines[i];
			var op = operation || operations[line.$astalin];
			if (op) {
				status = f(_, line, op);
				if (status === constants.CST_AERROR) return status;
			}
		}
		return status;
	},
	enumerable: false
});


Object.defineProperty(InstanceCollection.prototype, "onPropagate", {
	value: function(_, property) {
		return this.applyToEach(_, function(_, line, operation) {
			return line.slot(_, property.name).set(_, property.get(_, true));
		}, "onPropagate");
	},
	enumerable: false
});



Object.defineProperty(InstanceCollection.prototype, "actionControlChildren", {
	value: function(_, type, operation) {
		if (!/^Update$/.test(operation))
			return this.applyToEach(_, function(_, line, operation) {
				return line[type](_, operation);
			}, operation);

		// Update:
		return this.applyToEach(_, function(_, line, typeOperation) {
			return line[type](_, typeOperation.toUpperCase());
		});
	},
	enumerable: false
});



Object.defineProperty(InstanceCollection.prototype, "insert", {
	value: function(_) {
		return this.applyToEach(_, function(_, line, operation) {
			return line[operation](_);
		}, "insert");
	},
	enumerable: false
});

Object.defineProperty(InstanceCollection.prototype, "update", {
	value: function(_) {
		return this.applyToEach(_, function(_, line, typeOperation) {
			return line[typeOperation](_);
		});
	},
	enumerable: false
});


Object.defineProperty(InstanceCollection.prototype, "delete", {
	value: function(_) {
		return this.applyToEach(_, function(_, line, operation) {
			return line[operation](_);
		}, "delete");
	},
	enumerable: false
});


Object.defineProperty(InstanceCollection.prototype, "getDiagnoses", {
	value: function(path) {
		return undefined; //TODO
	},
	enumerable: false,
});

/*
getProperty makes it possible to use the syntax 
INDEX = MY_INSTANCE6.REF.INDEX1
where REF is a 1x1 collection
*/
Object.defineProperty(InstanceCollection.prototype, "getProperty", {
	value: function(_, name, raw) {
		// TODO : check TYPLNK
		if (this.collection.mappingData.TYPLNK === 3) {
			if (!this.lines.length) this.add(_, constants.CST_ALASTPOS);
			return this.index(_, 0).get(_, name, raw);
		}
	},
	enumerable: false,
});

/*
setProperty makes it possible to use the syntax 
MY_INSTANCE6.REF.INDEX1 = "CASCADEDEL"
where REF is a 1x1 collection
*/
Object.defineProperty(InstanceCollection.prototype, "setProperty", {
	value: function(_, name, value, raw) {
		// TODO : check TYPLNK
		if (this.collection.mappingData.TYPLNK === 3) {
			if (!this.lines.length) this.add(_, constants.CST_ALASTPOS);
			this.index(_, 0).set(_, name, value, raw);
		}
	},
	enumerable: false,
});

attributes.addAttributes(InstanceCollection.prototype);
attributes.addColAttributes(InstanceCollection.prototype);
snapshots.addSnapshots(InstanceCollection.prototype);
exports.InstanceCollection = InstanceCollection;