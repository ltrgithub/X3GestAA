"use strict";
var helpers = require('syracuse-core').helpers;

var tracerJs = require("syracuse-trace/lib/helper").getTracer("etna.supervisor");

exports.Cache = helpers.defineClass(function() {
	//dbg:console.log("new cache");
	//dbg:var e = new Error("new");
	//dbg:console.error(e.stack);

	this.texts = {};
	this.references = {};
	this._isActivated = false;
	this.max = 100;
	this.instanceset = [];
}, null, {
	isActivated: {
		get: function() {
			return this._isActivated;
		}
	},
	clone: function() {
		var from = this;
		var to = new exports.Cache();
		Object.keys(from.texts).forEach(function(p) {
			to._isActivated = true;
			to.texts[p] = {
				ids: [],
				texts: null,
				register: from.texts[p].register,
			};
		});
		Object.keys(from.references).forEach(function(p) {
			to._isActivated = true;
			to.references[p] = {
				ids: [],
				texts: null,
				register: from.references[p].register,
			};
		});
	},
	addProperty: function(_, property) {
		//dbg:console.log("cache.addProperty "+property.name);
		//dbg:var e = new Error("property");
		//dbg:console.error(e.stack);
		this._isActivated = true;
		this.texts[property.name] = {
			ids: [],
			texts: null,
			register: function(_, property) {
				return function(_, instance) {
					var textId = property.getAtextraKey(_, instance);
					//dbg:console.error("=> register property:"+property.name+" textId:"+textId);
					instance.cache.texts[property.name].ids.push(textId);
					return instance;
				};
			}(_, property)
		};
		//dbg:console.log("cache.addProperty =>"+Object.keys(this.texts));

	},
	addReference: function(_, property) {
		//dbg:console.log("cache.addReference "+property.name);
		//dbg:var e = new Error("reference");
		//dbg:console.error(e.stack);
		this._isActivated = true;
		this.references[property.name] = {
			$name: property.name,
			$ids: {},
			register: function(_, property) {
				var getReferenceKey = property.makeGetReferenceKey(_);
				return function(_, instance) {
					//dbg:console.error("=> register reference:"+property.name);
					var id = getReferenceKey(_, instance);
					if (id) instance.cache.references[property.name].$ids[id] = null;
					return instance;
				};
			}(_, property)
		};
		//dbg:console.log("cache.addReference =>"+Object.keys(this.references));

	},
	register: function(_, instance) {
		//dbg:console.error("register texts:"+Object.keys(this.texts));

		instance.cache = this;
		var self = this;
		Object.keys(self.texts).forEach_(_, function(_, property) {
			if (instance.properties[property]) {
				self.texts[property].register(_, instance);
			}
		});
		//dbg:console.error("register references:"+Object.keys(this.references));
		Object.keys(self.references).forEach_(_, function(_, property) {
			if (instance.properties[property])
				self.references[property].register(_, instance);
		});
		this.instanceset.push(instance);
	},
	clean: function() {
		this.instanceset = [];
	},
	isFull: {
		get: function() {
			return this.instanceset.length > this.max;
		}
	},
	transform: function() {
		// Cache records in order to improve the performance of the cache of 
		// texts and references :
		var cache = this;
		cache.clean();

		function flush(_, _writer) {
			cache.instanceset.forEach_(_, function(_, instance) {
				_writer.write(_, instance);
			});
			cache.clean();
		}

		return function(_, _reader, _writer) {
			var instance;
			while ((instance = _reader.read(_)) !== undefined) {
				cache.register(_, instance);
				cache.isFull && flush(_, _writer);
			}
			flush(_, _writer);
		};
	}
});