"use strict";

var ez = require('ez-streams');
var eztedious = require('ez-tedious');
var tds = require('tedious');
var dru = require('etna-util/lib/drivers-util');
//var sbuf = require('etna-supervisor/lib/drivers/sqlbuffer') ;
var tuuid = require('etna-engine/lib/runtime/tuuid');
var date = require("syracuse-core/lib/types/date");
var datetime = require("syracuse-core/lib/types/datetime");

function tds_connect(cfg, callback) {
	var c;
	c = new tds.Connection(cfg);

	return c.on('connect', function(err) {
		if (err)
			return callback(err, null);

		cfg.trace && cfg.trace("connection callback ");
		return callback(null, c);
	});
}

function tds_param(i) {
	return "@p" + i;
}

function tds_query(cfg, cnx, sql, args, callback) {
	cfg.trace && cfg.trace("tds_query:" + sql + (args ? " with " + JSON.stringify(args) : ""));

	var records = [];

	var req = new tds.Request(sql, function(err, rowCount) {
		if (err)
			cfg.trace && cfg.trace("Request end error :" + err);
		else
			cfg.trace && cfg.trace("Request end rowcount :" + rowCount);

		return callback(err, records);
	});

	dru.tdsAddParameters(req, args);

	req.on("row", function(columns) {
		records.push(dru.tdsColumnsToRow(columns));
	});

	cnx.execSql(req);
	return req;
}

function tds_close(cnx, callback) {
	cnx.on("end", function() {
		callback(null, null);
	});
	cnx.close();
}

module.exports = function(config) {

	console.log("Create config...");
	var cfg = {};
	if (config) {
		var trace = config.trace;

		var srv = config.hostname.split("\\");
		console.log("Create " + srv[0] + ' ' + srv[1]);
		cfg = {
			userName: config.user,
			password: config.password,
			server: srv[0],
			options: {
				database: config.database,
				instanceName: srv[1],
				decimalsAsString: true,
				requestTimeout: config.requestTimeout || 0,
			},

			//trace: config.trace
		};

		var connections = [];
		console.log(cfg);
	}

	function popConnection(_) {
		var cnx = connections.pop();

		if (!cnx) {
			trace && trace("connecting on " + cfg.server + "...");
			trace && trace(cfg);

			cnx = tds_connect(cfg, ~_);
			trace && trace("connected");
		}
		return cnx;

	}

	function pushConnection(cnx) {
		connections.push(cnx);
	}

	function getFullTableName(tableDef) {
		if (tableDef.schemaName)
			return "[" + tableDef.schemaName + "].[" + tableDef.tableName + "]";
		else
			return "[" + tableDef.tableName + "]";
	}

	return {
		subString: function(arg, deb, fin) {
			return "substring(" + arg + ", " + deb + ", " + fin + ")";
		},
		toSqlLob: function(val) {
			return val;
		},
		toSqlUuid: function(val) {
			return val;
		},

		nullDate: function() {
			return new datetime.Datetime(Date.UTC(1753, 1, 1));
		},

		isNullDate: function(val) {
			return val && (val.getFullYear() === 1753) && (val.getMonth() === 1) && (val.getDay() === 1);
		},

		isNullUuid: function(val) {
			for (var i = 0; i < 16; i++) {
				if (val[i] !== 0) return false;
			}
			return true;
		},

		toSqlDate: function(val) {
			var date;
			if ('string' === typeof(val))
				date = Date.parse(val);
			else {
				// Assume the val is a Date object
				date = val;
			}
			return "'" + date.toISOString() + "'";
		},

		escape: function(name) {
			return '"' + name + '"';
		},
		param: function(i) {
			return tds_param(i);
		},

		withConnection: function(_, body) {
			var cnx = popConnection(_);
			var result = [];

			try {
				trace && trace("state" + cnx.state.name);
				return body(_, cnx);
			} finally {
				trace && trace("push connection");
				trace && trace("state" + cnx.state.name);
				pushConnection(cnx);
				connections.push(cnx);
			}

		},

		closeConnections: function(_) {
			connections.forEach_(_, function(_, cnx) {
				cnx && tds_close(cnx, ~_);
			});
		},

		execute: function(_, cnx, sql, args) {
			var result = tds_query(cfg, cnx, sql, args, ~_);
			return result;
		},

		reader: function(_, cnx, sql, args) {
			return eztedious.reader(_, cnx, sql, args);
		},
		writer: function(_, cnx, sql) {
			return eztedious.writer(cnx, sql);
		},

		dropIndexSql: function(indexName, tableName) {
			return 'drop index "' + tableName + '"."' + indexName + '"';
		},
		isIndexNotFound: function(ex) {
			//return /ORA-01418/.test(ex.message);
		},
		isTableNotFound: function(ex) {
			if (/it does not exist/.test(ex.message))
				return true;
			if (/Invalid object name/.test(ex.message)) {
				// sth like 'Invalid object name 'xxxx'
				return true;
			}
			return false;
		},
		blobType: function() {
			return "varbinary(max)";
		},
		blobType2: function() {
			return "varbinary(max)";
		},
		tinyIntType: function() {
			return "tinyint";
		},
		shortIntType: function() {
			return "smallint";
		},
		intType: function() {
			return "int";
		},
		stringType: function(len) {
			return "nvarchar(" + len + ")";
		},
		dateType: function() {
			return "datetime";
		},
		datetimeType: function() {
			return "datetime";
		},
		uuidType: function() {
			return "binary(16)";
		},
		decimalType: function() { // for now handle as char to keep full precision
			return "numeric";
		},

		/// Returns the definition of a table from its name.
		getTableDef: function(_, schemaName, tableName) {
			var tableDef = {
				schemaName: schemaName,
				tableName: tableName
			};
			this.readTableSchema(_, tableDef);
			return tableDef;
		},

		/// Enhance a table definition with its columns, indices, ...
		/// 'tableDef' is an object that have been created by readTables() / getTableDef()
		readTableSchema: function(_, tableDef) {
			var _this = this;
			this.withConnection(_, function(_, cnx) {

				// ----------------------------------------
				// Read the columns of the table
				// ----------------------------------------
				var sqlQuery = "SELECT c.object_id table_id, c.column_id col_id, c.name col_name, c.system_type_id col_type, c.max_length col_max_length," +
					" c.is_nullable col_is_nullable, c.precision col_precision, c.scale col_scale, c.default_object_id col_default_object_id," +
					" d.definition def_definition, o.schema_id schema_id" +
					" FROM sys.columns c" +
					" LEFT JOIN sys.objects o ON c.object_id = o.object_id" +
					" LEFT JOIN sys.schemas s ON o.schema_id = s.schema_id" +
					" LEFT JOIN sys.default_constraints d ON d.object_id = c.default_object_id" +
					" WHERE o.name='" + tableDef.tableName + "'" +
					" AND s.name='" + tableDef.schemaName + "'" +
					" AND c.name != 'ROWID'" +
					" ORDER BY col_name";

				var tableId, schemaId;
				var columnsById = [];
				tableDef.columns = _this.reader(_, cnx, sqlQuery).toArray(_).map(function(row) {
					if (!tableId) {
						// Note: all the rows have the same table_id
						tableId = row.table_id;
						schemaId = row.schema_id;
					}
					var column = {
						name: row.col_name,
						isNullable: row.col_is_nullable
					};

					switch (row.col_type) {
						case 48:
							column.type = "tinyint";
							break;
						case 52:
							column.type = "smallint";
							break;
						case 56:
							column.type = "int";
							break;
						case 61:
							column.type = "datetime";
							break;
						case 108: // numeric
							column.type = "decimal";
							column.decimalPrecision = row.col_precision;
							column.decimalScale = row.col_scale;
							break;
						case 165:
							column.type = "blob";
							break;
						case 167: // varchar(n)
							column.type = "varchar";
							column.maxLength = row.col_max_length;
							break;
						case 173: // binary(n)
							if (row.col_max_length == 16)
								column.type = "uuid";
							else {
								column.type = "binary";
								column.maxLength = row.col_max_length;
							}
							break;
						case 231: // nvarchar(n)
							column.type = "nvarchar";
							// Note : row.col_max_length <=> nvarchar(max)
							column.maxLength = row.col_max_length / 2; // utf8 encoding, the size must be divided by 2.
							break;
						default:
							throw new Error('unknown column type ' + row.col_xtype + ' for column ' + getFullTableName(tableDef) + '.' + row.col_name);
					}
					if (row.col_default_object_id) {
						// The columns has a default value
						column.default = row.def_definition;
					}
					columnsById[row.col_id] = column;
					return column;
				});


				// ----------------------------------------
				// Read the indices of the table
				// ----------------------------------------
				sqlQuery = "SELECT ic.index_id index_id, ic.index_column_id index_column_id, " +
					"i.is_unique index_unique, i.is_primary_key index_is_pk, " +
					"c.name column_name, i.name index_name, ic.is_descending_key column_descending " +
					"FROM sys.index_columns ic " +
					"LEFT JOIN sys.indexes i ON i.index_id = ic.index_id AND i.object_id = ic.object_id " +
					"LEFT JOIN sys.columns c ON c.column_id = ic.column_id AND c.object_id = ic.object_id " +
					"WHERE i.object_id = " + tableId + " AND i.type > 0 " +
					"AND c.name != 'ROWID' " +
					"ORDER BY ic.index_id, ic.index_column_id";


				var currentIndex;
				var currentIndexId;
				tableDef.indexes = [];
				_this.reader(_, cnx, sqlQuery).toArray(_).forEach(function(row) {
					if (row.index_id != currentIndexId) {
						// This is either the first index or a new index (rows are sorted by index)
						currentIndexId = row.index_id;
						currentIndex = {
							name: row.index_name,
							isPk: row.index_is_pk,
							isUnique: row.index_unique,
							columns: [],
						};
						tableDef.indexes.push(currentIndex);
					}
					var column = {
						name: row.column_name,
						ascending: !row.column_descending,
					};
					currentIndex.columns.push(column);
				});

				// ----------------------------------------
				// Read the sequence of the table
				// ----------------------------------------
				// Note the tedious driver does not support sql_variant, we have to use CAST
				sqlQuery = "SELECT TOP 1 CAST(current_value AS int) seq_value " +
					" FROM sys.sequences" +
					" WHERE name = 'SEQ_" + tableDef.tableName + "'" +
					" AND schema_id = " + schemaId;
				_this.reader(_, cnx, sqlQuery).toArray(_).forEach(function(row) {
					tableDef.sequence = row.seq_value;
				});

			});
		},

		createTableFromTableDefinition: function(_, tableDef, options) {
			options = options || {};
			options.showCommands = true;
			options.skipCommands = true;
			if (options.onlyIndexes) {
				options.skipDrop = true;
				options.skipCreate = true;
				options.skipSequences = true;
				options.skipIndexes = false;
			}
			this.withConnection(_, function(_, cnx) {
				// -------------------------------------
				// Drop the existing table
				// -------------------------------------
				if (!options.skipDrop) {
					// Drop the existing table
					try {
						var sql = "DROP TABLE " + getFullTableName(tableDef);
						options.showCommands && console.log(sql);
						!options.skipCommands && cnx.execSql(sql);
					} catch (err) {
						// Nothing to do : the table does not exist
					}
					// Drop the existing sequence
					try {
						var sql = "DROP SEQUENCE [" + tableDef.schemaName + "].[SEQ_" + tableDef.tableName + "]";
						options.showCommands && console.log(sql);
						!options.skipCommands && cnx.execSql(sql);
					} catch (err) {
						// Nothing to do : the sequence does not exist
					}
				}
				// -------------------------------------
				// Create the table and its columns
				// -------------------------------------
				if (!options.skipCreate) {
					// Create the table (and the columns)
					var sql = "CREATE TABLE " + getFullTableName(tableDef) + " ([ROWID] numeric(38, 0) IDENTITY(1,1) NOT NULL";
					tableDef.columns.forEach(function(colDef) {
						sql += ", [" + colDef.name + "] ";
						switch (colDef.type) {
							case "tinyint":
							case "smallint":
							case "int":
							case "datetime":
								sql += colDef.type;
								break;
							case "decimal":
								sql += "numeric(" + colDef.decimalPrecision + ", " + colDef.decimalScale + ")";
								break;
							case "blob":
								sql += "varbinary(max)";
								break;
							case "varchar":
								sql += "varchar(" + colDef.maxLength + ")";
								break;
							case "nvarchar":
								sql += "nvarchar(" + colDef.maxLength + ")";
								break;
							case "uuid":
								sql += "binary(16)";
								break;
							case "binary":
								sql += "binary(" + colDef.maxLength + ")";
								break;
							default:
								throw new Error('unknown column type ' + colDef.colType + ' for column ' + getFullTableName(tableDef) + '.' + colDef.name);
						}
						if (!colDef.isNullable)
							sql += " NOT NULL";
						if (colDef.default)
							sql += " DEFAULT " + colDef.default.value;
					});
					sql += ")";
					options.showCommands && console.log(sql);
					!options.skipCommands && cnx.execSql(sql);
				}
				// -------------------------------------
				// Create the indexes
				// -------------------------------------
				if (!options.skipIndexes) {
					console.log("Create indexes");
					tableDef.indexes.forEach(function(indexDef) {
						var sql = "CREATE ";
						if (tableDef.isUnique)
							sql += "UNIQUE ";
						sql += "INDEX [" + indexDef.name + "] ON " + getFullTableName(tableDef) + " (";
						indexDef.columns.forEach(function(column, colIdx) {
							if (colIdx > 0)
								sql += ", ";
							sql += "[" + column.name + "]";
							if (!column.ascending)
								sql += " DESC";
						});
						sql += ")";
						options.showCommands && console.log(sql);
						!options.skipCommands && cnx.execSql(sql);
					});
				}
				// -------------------------------------
				// Create (when needed) the sequence
				// -------------------------------------
				if (!options.skipSequences && tableDef.sequence) {
					console.log("Create sequence");
					var sql = "CREATE SEQUENCE [" + tableDef.schemaName + "].[SEQ_" + tableDef.tableName + "]";
					sql += " AS int";
					sql += " START WITH " + tableDef.sequence;
					options.showCommands && console.log(sql);
					!options.skipCommands && cnx.execSql(sql);
				}

			});
		},

		createPermissions: function(_, tableDef) {
			console.log("**************** CREATE PERMISSIONS");
		},

		/// Returns the list of all the tables defined in the database / schema
		readTables: function(_, schemaName) {
			var tables = [];
			var _this = this;
			this.withConnection(_, function(_, cnx) {
				var sql = "SELECT o.name name FROM sys.objects o";
				if (schemaName)
					sql += " LEFT JOIN sys.schemas s ON o.schema_id = s.schema_id";
				sql += " WHERE o.type = 'U'";
				if (schemaName)
					sql += " AND s.name = '" + schemaName + "'";
				sql += " ORDER BY o.name";
				var vals = _this.reader(_, cnx, sql).forEach(_, function(_, item) {
					tables.push({
						schemaName: schemaName,
						tableName: item.name
					});
				});
			});
			return tables;
		},

		/// Returns a reader that could be used to read all the records of the table
		/// 'tableDef' is an object that have been created by getTableDef() or readTables() and updated by readTableSchema()
		createTableReader: function(_, tableDef, filters) {
			if (!tableDef.columns)
				throw new Error('Must invoke readTableSchema() before.');
			var columnNames = tableDef.columns.map(function(column) {
				return "T." + column.name;
			});

			var sql = "SELECT " + columnNames.join(',') + " FROM " + getFullTableName(tableDef) + " T";

			if (filters) {
				// A list of 3-uplets {key, operator, value}
				var first = true;
				filters.forEach(function(filter) {
					if (first)
						sql += " WHERE ";
					else
						sql += " AND ";
					first = false;
					sql += "(T." + filter.key + " " + filter.operator + " " + filter.value + ")";
				});
			}

			var reader;
			var _this = this;
			this.withConnection(_, function(_, cnx) {
				reader = _this.reader(_, cnx, sql);
			});
			return reader;
		},

		createTableWriter: function(_, tableDef) {

			var columnNames = [];
			var paramNames = [];
			tableDef.columns.forEach(function(column, index) {
				if (column.name == "ROWID")
					return;
				columnNames.push(column.name);
				paramNames.push("@p" + index);
			});

			var sql = "INSERT INTO " + getFullTableName(tableDef) + " (" + columnNames.join(',') + ") VALUES (" + paramNames.join(',') + ")";
			var _this = this;
			var writer;
			this.withConnection(_, function(_, cnx) {
				writer = _this.writer(_, cnx, sql);
			});
			return writer;
		},

		clearTable: function(_, tableDef) {
			var _this = this;
			this.withConnection(_, function(_, cnx) {
				_this.execute(_, cnx, "DELETE FROM " + getFullTableName(tableDef));
			});
		}
	};
};