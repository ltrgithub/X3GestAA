"use strict";

var ez = require('ez-streams');
var eztedious = require('ez-tedious');
var tds = require('tedious');
var dru = require('etna-util/lib/drivers-util');
//var sbuf = require('etna-supervisor/lib/drivers/sqlbuffer') ;
var tuuid = require('etna-engine/lib/runtime/tuuid');
var date = require("syracuse-core/lib/types/date");
var datetime = require("syracuse-core/lib/types/datetime");

function tds_connect(cfg, callback) {
	var c;
	c = new tds.Connection(cfg);

	return c.on('connect', function(err) {
		if (err)
			return callback(err, null);

		cfg.trace && cfg.trace("connection callback ");
		return callback(null, c);
	});
}

function tds_param(i) {
	return "@p" + i;
}

function tds_query(cfg, cnx, sql, args, callback) {
	cfg.trace && cfg.trace("tds_query:" + sql + (args ? " with " + JSON.stringify(args) : ""));

	var records = [];

	var req = new tds.Request(sql, function(err, rowCount) {
		if (err)
			cfg.trace && cfg.trace("Request end error :" + err);
		else
			cfg.trace && cfg.trace("Request end rowcount :" + rowCount);

		return callback(err, records);
	});

	dru.tdsAddParameters(req, args);

	req.on("row", function(columns) {
		records.push(dru.tdsColumnsToRow(columns));
	});

	cnx.execSql(req);
	return req;
}

function tds_close(cnx, callback) {
	cnx.on("end", function() {
		callback(null, null);
	});
	cnx.close();
}

function columnDescr() {
	return {

	};
}

module.exports = function(config) {

	console.log("Create config...");
	var cfg = {};
	if (config) {
		var trace = config.trace;

		var srv = config.hostname.split("\\");
		console.log("Create " + srv[0] + ' ' + srv[1]);
		cfg = {
			userName: config.user,
			password: config.password,
			server: srv[0],
			options: {
				database: config.database,
				instanceName: srv[1]
			},
			trace: config.trace
		};
		var connections = [];
	}

	function popConnection(_) {
		var cnx = connections.pop();

		if (!cnx) {
			trace && trace("connecting on " + cfg.server + "...");
			trace && trace(cfg);

			cnx = tds_connect(cfg, ~_);
			trace && trace("connected");
		}
		return cnx;

	}

	function pushConnection(cnx) {
		connections.push(cnx);
	}

	return {

		decimalCast: function(name) {
			// select rtrim(replace(replace(rtrim(replace(cast(znum as char(11)),'0',' ')),' ','0') + ' ','. ','')) from ZETNA4
			return "convert( nvarchar(40), " + name + " ) As " + name;
		},

		uuidCast: function(name) {
			return name + " As U#" + name;
		},
		sqlUuid: function(val) {

			if (/,/.test(val)) {
				// A string that contains a guid formatted as : 'a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p'
				// This string comes from a array.toString();
				var bytes = new Buffer(16);
				var byteArray = val.split(',');
				for (var i = 0; i < 16; i++) bytes[i] = byteArray[i];
				return bytes;
			}

			/*return new sbuf.SQLBUFFER( sbuf.uuidType, new Buffer( val, 'hex') ) ;*/
			return tuuid.x3ToUuid(val);
		},
		sqlDate: function(val) {
			return new Date(val.valueOf() - 60000 * val.getTimezoneOffset());
		},
		fromSqlDate: function(val) {
			return this.isNullDate(val) ? date.fromJsDate(val) : null;
		},
		sqlDatetime: function(val) {
			return val;
		},
		fromSqlDatetime: function(val) {
			return this.isNullDate(val) ? datetime.fromJsDate(val) : null;
		},
		nullDate: function() {
			return new Datetime(1753, 1, 1, 0, 0, 0, 0);
		},
		isNullDate: function(val) {
			return val && (val.getFullYear() === 1753) && (val.getMonth() === 1) && (val.getDay() === 1);
		},
		isNullUuid: function(val) {
			return val === "00000000000000000000000000000000";
		},
		escape: function(name) {
			return '"' + name + '"';
		},
		param: function(i) {
			return tds_param(i);
		},

		withConnection: function(_, body) {
			var cnx = popConnection(_);
			var result = [];

			try {
				trace && trace("state" + cnx.state.name);
				return body(_, cnx);
			} finally {
				trace && trace("push connection");
				trace && trace("state" + cnx.state.name);
				pushConnection(cnx);
				connections.push(cnx);
			}

		},

		closeConnections: function(_) {
			connections.forEach_(_, function(_, cnx) {
				cnx && tds_close(cnx, ~_);
			});
		},

		execute: function(_, cnx, sql, args) {
			var result = tds_query(cfg, cnx, sql, args, ~_);
			return result;
		},

		reader: function(_, cnx, sql, args) {
			return eztedious.reader(_, cnx, sql, args);
		},
		writer: function(_, cnx, sql) {
			return eztedious.writer(cnx, sql);
		},

		dropIndexSql: function(indexName, tableName) {
			return 'drop index "' + tableName + '"."' + indexName + '"';
		},
		isIndexNotFound: function(ex) {
			//return /ORA-01418/.test(ex.message);
		},
		isTableNotFound: function(ex) {
			if (/it does not exist/.test(ex.message))
				return true;
			if (/Invalid object name/.test(ex.message)) {
				// sth like 'Invalid object name 'xxxx'
				return true;
			}
			return false;
		},
		blobType: function() {
			return "varbinary(max)";
		},
		blobType2: function() {
			return "varbinary(max)";
		},
		tinyIntType: function() {
			return "tinyint";
		},
		shortIntType: function() {
			return "smallint";
		},
		intType: function() {
			return "int";
		},
		stringType: function(len) {
			return "nvarchar(" + len + ")";
		},
		dateType: function() {
			return "datetime";
		},
		datetimeType: function() {
			return "datetime";
		},
		uuidType: function() {
			return "binary(16)";
		},
		decimalType: function() { // for now handle as char to keep full precision
			return "numeric";
		},

		/// Enhance a table definition with its columns, indices, ...
		/// 'table' is an object that have been created by readTables()
		readTableSchema: function(_, table) {
			var _this = this;
			// Read the columns of the table
			this.withConnection(_, function(_, cnx) {
				var sql = "select name, xtype, length, colid, isnullable, xprec, xscale, cdefault from syscolumns where id=" + table.id;
				table.columns = _this.reader(_, cnx, sql).toArray(_).map(function(sql) {
					var column = {
						name: sql.name,
						isNullable: sql.isnullable
					};
					switch (sql.xtype) {
						case 48:
							column.type = "tinyint";
							break;
						case 52:
							column.type = "smallint";
							break;
						case 56:
							column.type = "int";
							break;
						case 61:
							column.type = "datetime";
							break;
						case 108: // numeric
							column.type = "decimal";
							column.decimalPrecision = sql.xprec;
							column.decimalScale = sql.xscale;
							break;
						case 165:
							column.type = "blob";
							break;
						case 167: // varchar(n)
							column.type = "varchar";
							column.maxLength = sql.length;
							break;
						case 173: // binary(n)
							if (sql.length == 16)
								column.type = "uuid";
							else {
								column.type = "binary";
								column.maxLength = sql.length;
							}
							break;
						case 231: // nvarchar(n)
							column.type = "nvarchar";
							// Note : sql.length <=> nvarchar(max)
							column.maxLength = sql.length / 2; // utf8 encoding, the size must be divided by 2.
							break;
						default:
							throw new Error('unknown column type ' + sql.xtype + ' for column ' + table.name + '.' + sql.name);
					}
					return column;
				});
			});
		},

		/// Returns the list of all the tables defined in the database / schema
		readTables: function(_) {
			var tables = [];
			var _this = this;
			this.withConnection(_, function(_, cnx) {
				var sql = "select name, id, xtype from sysobjects where xtype = 'U' order by name";
				var vals = _this.reader(_, cnx, sql).forEach(_, function(_, item) {
					var table = {
						name: item.name,
						id: item.id,
					};
					tables.push(table);
				});
			});
			return tables;
		},

		/// Returns a reader that could be used to read all the records of the table
		/// 'table' is an object that have been created by readTables() and updated by readTableSchema()
		createTableReader: function(_, table) {
			if (!table.columns)
				throw new Error('Must invoke readTableSchema() before.');
			var columnNames = table.columns.map(function(column) {
				return "T." + column.name;
			});

			var sql = "SELECT " + columnNames.join(',') + " FROM " + table.name + " T";
			var reader;
			var _this = this;
			this.withConnection(_, function(_, cnx) {
				reader = _this.reader(_, cnx, sql);
			});
			return reader;
		},

		createTableWriter: function(_, table) {

			var columnNames = [];
			var paramNames = [];
			table.columns.forEach(function(column, index) {
				if (column.name == "ROWID")
					return;
				columnNames.push(column.name);
				paramNames.push("@p" + index);
			});

			var sql = "INSERT INTO " + table.name + " (" + columnNames.join(',') + ") VALUES (" + paramNames.join(',') + ")";
			var _this = this;
			console.log('RRRRRRRRRRRRRRRRRRR ' + sql);
			var writer;
			this.withConnection(_, function(_, cnx) {
				writer = _this.writer(_, cnx, sql);
			});
			return writer;
		},

		clearTable: function(_, table) {
			var _this = this;
			this.withConnection(_, function(_, cnx) {
				_this.execute(_, cnx, "DELETE FROM " + table.name);
			});
		}
	};
};