"use strict";

var ez = require('ez-streams');
var ezoracle = require('ez-oracle');
var oracle = require('oracle');
var date = require("syracuse-core/lib/types/date");
var datetime = require("syracuse-core/lib/types/datetime");
var tracerJs = require("syracuse-trace/lib/helper").getTracer("etna.supervisor");
var common = require("./drivers-common._js");

var _months = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];


function _toHex(b) {
	b = b & 0xff;
	return b < 16 ? "0" + b.toString(16) : b.toString(16);
}


module.exports = function(config) {
	var trace = config.trace;
	var connections = [];

	return {
		subString: function(arg, deb, fin) {
			return "substr(" + arg + ", " + deb + ", " + fin + ")";
		},
		toSqlLob: function(val) {
			var s = '';
			for (var i = 0; i < val.length; i++) {
				var b = val[i];
				s += _toHex(b);
			}
			return s;
		},
		toSqlUuid: function(val) {
			return val.x3ToSqlString();
		},
		toSqlDate: function(val) {
			var date;
			if ('string' === typeof(val))
				date = Date.parse(val);
			else {
				// Assume the val is a Date object
				date = val;
			}

			function pad(n, width) {
				n = n + '';
				return n.length >= width ? n : new Array(width - n.length + 1).join('0') + n;
			}
			return "TO_DATE('" + date.getUTCFullYear() +
				'-' + pad(date.getUTCMonth() + 1, 2) +
				'-' + pad(date.getUTCDate(), 2) +
				' ' + pad(date.getUTCHours(), 2) +
				':' + pad(date.getUTCMinutes(), 2) +
				':' + pad(date.getUTCSeconds(), 2) +
				"', 'YYYY-MM-DD HH24:MI:SS')";
		},

		isNullUuid: function(val) {
			return (val === null) || (val === undefined) || (val === "00000000000000000000000000000000");
		},
		nullDate: function() {
			return new Date(Date.UTC(1599, 11, 31));
		},
		isNullDate: function(val) {
			return (val === null) || (val === undefined) || (val && (val.getFullYear() === 1599) && (val.getMonth() === 11) && (val.getDate() === 31));
		},
		escape: function(name) {
			return '"' + name + '"';
		},
		param: function(i) {
			return ':' + (i + 1);
		},
		beginTransaction: function(_, cnx) {
			cnx.setAutoCommit(false);
			cnx.commit(_);
		},
		commitTransaction: function(_, cnx) {
			cnx.commit(_);
			cnx.setAutoCommit(true);
		},
		rollbackTransaction: function(_, cnx) {
			cnx.rollback(_);
			cnx.setAutoCommit(true);
		},
		driverPopConnection: function(_) {
			return connections.pop();
		},
		driverPushConnection: function(cnx) {
			connections.push(cnx);
		},
		withConnection: function(_, body) {
			var cnx = connections.pop();
			if (!cnx) {
				trace && trace("connecting ...");
				var cnx = oracle.connect(config, ~_);
				cnx.setPrefetchRowCount(config.setPrefetchRowCount || 50);
				cnx.setNumberStringFormat("99999999999999999999.99999999999999999999");
			}
			try {
				return body(_, cnx);
			} finally {
				connections.push(cnx);
			}
		},
		execute: function(_, cnx, sql, args) {
			tracerJs.debug && tracerJs.debug("SQL: " + sql + ", args=" + args);
			return cnx.execute(sql, args || [], ~_);
		},
		reader: function(_, cnx, sql, args) {
			return ezoracle.reader(cnx, sql, args || []);
		},
		writer: function(_, cnx, sql) {
			return ezoracle.writer(cnx, sql);
		},
		dropIndexSql: function(indexName, tableName) {
			return 'drop index "' + indexName + '"';
		},
		isIndexNotFound: function(ex) {
			return /ORA-01418/.test(ex.message);
		},
		isTableNotFound: function(ex) {
			return /ORA-00942/.test(ex.message);
		},
		isUniqueViolated: function(ex) {
			return /ORA-00001/.test(ex.message);
		},
		isLocked: function(ex) {
			return /ORA-00060/.test(ex.message);
		},
		isNoRecord: function(ex) {
			return /ORA-01403/.test(ex.message);
		},
		blobType: function() {
			return "VARCHAR2(1020)";
		},
		blobType2: function() {
			return "VARCHAR2(32)";
		},
		tinyIntType: function() {
			return "NUMBER(3)";
		},
		shortIntType: function() {
			return "NUMBER(5)";
		},
		intType: function() {
			return "NUMBER(10)";
		},
		stringType: function(len) {
			return "VARCHAR2(" + len + ")";
		},
		dateType: function() {
			return "DATE";
		},
		datetimeType: function() {
			return "DATE";
		},
		uuidType: function() {
			return "VARCHAR2(32)";
		},
		decimalType: function() { // for now handle as char to keep full precision
			return "VARCHAR2(32)";
		},
		backupDatabase: function(_, dbName, filename) {
			throw new Error("Not implemented !!!");
		},
		restoreDatabase: function(_, dbName, filename) {
			throw new Error("Not implemented !!!");
		},

		/// Returns the list of all the tables defined in the database / schema
		readTables: function(_, schemaName) {
			var _this = this;
			return this.withConnection(_, function(_, cnx) {
				var sql = "select TABLE_NAME from USER_TABLES order by TABLE_NAME";
				return _this.reader(_, cnx, sql).map(function(_, item) {
					return {
						schemaName: schemaName,
						tableName: item.TABLE_NAME,
					};
				}).toArray(_);
			});
		},

		/// Returns the definition of a table from its name.
		getTableDef: function(_, schemaName, tablename) {
			var tableDef = {
				schemaName: schemaName,
				tableName: tablename,
			};
			this.readTableSchema(_, tableDef);
			return tableDef;
		},

		/// Enhance a table definition with its columns, indices, ...
		/// 'tableDef' is an object that have been created by readTables() / getTableDef()
		readTableSchema: function(_, tableDef) {
			var _this = this;
			this.withConnection(_, function(_, cnx) {
				// ----------------------------------------
				// Read the columns of the table
				// ----------------------------------------
				var sqlQuery = "SELECT COLUMN_NAME, DATA_TYPE, DATA_LENGTH, CHAR_USED, CHAR_LENGTH, DATA_PRECISION, DATA_SCALE, NULLABLE FROM user_tab_cols WHERE table_name = :1 ORDER BY COLUMN_NAME";
				tableDef.columns = _this.reader(_, cnx, sqlQuery, [tableDef.tableName]).toArray(_).map(function(row) {
					var column = {
						name: row.COLUMN_NAME,
						isNullable: row.NULLABLE !== 'N',
					};
					switch (row.DATA_TYPE) {
						case 'DATE':
							column.type = "date";
							break;
						case 'TIMESTAMP(3)':
							column.type = "datetime";
							break;
						case 'NUMBER':
							var precision = parseInt(row.DATA_PRECISION);
							var scale = parseInt(row.DATA_SCALE);
							if (10 === precision && !scale) {
								column.type = "int";
							} else if (3 === precision && !scale) {
								column.type = "tinyint";
							} else if (5 === precision && !scale) {
								column.type = "smallint";
							} else {
								column.type = "decimal";
								column.decimalPrecision = precision;
								column.decimalScale = scale;
							}
							break;
						case 'BLOB':
							column.type = "blob";
							break;
						case 'CLOB':
							column.type = "clob";
							break;
						case 'VARCHAR':
							column.type = "varchar";
							column.maxLength = parseInt(row.DATA_LENGTH);
							break;
						case 'VARCHAR2':
							column.type = "nvarchar";
							if ('B' === row.CHAR_USED) {
								// The size of the string is defined in 'BYTES', we have to convert it to 'CHAR'
								column.maxLength = parseInt(row.DATA_LENGTH) / 3;
							} else {
								column.maxLength = parseInt(row.CHAR_LENGTH);
							}
							break;
						case 'RAW':
							if (row.DATA_LENGTH == 16)
								column.type = "uuid";
							else {
								column.type = "binary";
								column.maxLength = row.DATA_LENGTH;
							}
							break;
						default:
							throw new Error('unknown column type ' + row.DATA_TYPE + ' for column ' + tableDef.tableName + '.' + column.name);
					}
					return column;
				});

				// ----------------------------------------
				// Read the indices of the table
				// ----------------------------------------
				sqlQuery = "SELECT i.UNIQUENESS index_is_unique, ic.INDEX_NAME index_name, ic.COLUMN_NAME column_name, ic.DESCEND column_descending " +
					"FROM USER_IND_COLUMNS ic " +
					"LEFT JOIN USER_INDEXES i ON ic.INDEX_NAME = i.INDEX_NAME " +
					"WHERE ic.TABLE_NAME = :1 " +
					"ORDER BY ic.INDEX_NAME, ic.COLUMN_POSITION";


				var currentIndex;
				var currentIndexName;
				tableDef.indexes = [];
				_this.reader(_, cnx, sqlQuery, [tableDef.tableName]).toArray(_).forEach(function(row) {
					if (row.INDEX_NAME != currentIndexName) {
						currentIndexName = row.INDEX_NAME;
						// This is either the first index or a new index (rows are sorted by index)
						currentIndex = {
							name: row.INDEX_NAME,
							isPk: false /* row.index_is_pk*/ ,
							isUnique: (row.INDEX_IS_UNIQUE === "UNIQUE"),
							columns: [],
						};
						tableDef.indexes.push(currentIndex);
					}
					var column = {
						name: row.COLUMN_NAME,
						ascending: (row.COLUMN_DESCENDING === "ASC"),
					};
					currentIndex.columns.push(column);
				});

				// ----------------------------------------
				// Read the sequence of the table
				// ----------------------------------------
				sqlQuery = "SELECT LAST_NUMBER FROM USER_SEQUENCES WHERE SEQUENCE_NAME = :1  AND rownum < 2";
				_this.reader(_, cnx, sqlQuery, ["SEQ_" + tableDef.tableName]).toArray(_).forEach(function(row) {
					tableDef.sequence = parseInt(row.LAST_NUMBER);
				});

			});
		},

		createTableFromTableDefinition: function(_, tableDef, options) {
			options = options || {};
			options.showCommands = true;
			options.skipCommands = false;
			if (options.onlyIndexes) {
				options.skipDrop = true;
				options.skipCreate = true;
				options.skipSequences = true;
				options.skipIndexes = false;
			}
			var _this = this;
			this.withConnection(_, function(_, cnx) {
				// -------------------------------------
				// Drop the existing table
				// -------------------------------------
				if (!options.skipDrop) {
					// Drop the existing table and its sequence
					_this.dropTable(_, tableDef);
					_this.dropSequence(_, tableDef);
				}
				// -------------------------------------
				// Create the table and its columns
				// -------------------------------------
				if (!options.skipCreate) {
					// Create the table (and the columns)
					var sql = "CREATE TABLE " + _this.getFullTableDefName(tableDef) + " (";
					tableDef.columns.forEach(function(colDef, colIdx) {
						if (colIdx > 0)
							sql += ", ";
						sql += colDef.name + " ";
						switch (colDef.type) {
							case "tinyint":
								sql += "NUMBER(3)";
								break;
							case "smallint":
								sql += "NUMBER(5)";
								break;
							case "int":
								sql += "NUMBER(10)";
								break;
							case "date":
								sql += "DATE";
								break;
							case "datetime":
								sql += "TIMESTAMP(3)";
								break;
							case "decimal":
								sql += "NUMBER(" + colDef.decimalPrecision + ", " + colDef.decimalScale + ")";
								break;
							case "blob":
								sql += "BLOB";
								break;
							case "varchar":
								sql += "VARCHAR(" + colDef.maxLength + " CHAR)";
								break;
							case "nvarchar":
								sql += "VARCHAR2(" + colDef.maxLength + " CHAR)";
								break;
							case "uuid":
								sql += "RAW(16)";
								break;
							case "binary":
								sql += "RAW(" + colDef.maxLength + ")";
								break;
							default:
								throw new Error('unknown column type ' + colDef.colType + ' for column ' + _this.getFullTableDefName(tableDef) + '.' + colDef.name);
						}
						if (!colDef.isNullable)
							sql += " NOT NULL";
						if (colDef.default)
							sql += " DEFAULT " + colDef.default.value;
					});
					sql += ")";
					options.showCommands && console.log(sql);
					!options.skipCommands && _this.execute(_, cnx, sql);
				}

				// -------------------------------------
				// Create the indexes
				// -------------------------------------
				if (!options.skipIndexes) {
					console.log("Create indexes");
					tableDef.indexes.forEach_(_, function(_, indexDef) {
						var sql = "CREATE ";
						if (indexDef.isUnique)
							sql += "UNIQUE ";
						sql += "INDEX " + indexDef.name + " ON " + _this.getFullTableDefName(tableDef) + " (";
						indexDef.columns.forEach(function(column, colIdx) {
							if (colIdx > 0)
								sql += ", ";
							sql += column.name;
							if (!column.ascending)
								sql += " DESC";
						});
						sql += ")";
						options.showCommands && console.log(sql);
						!options.skipCommands && _this.execute(_, cnx, sql);
					});
				}
				// -------------------------------------
				// Create (when needed) the sequence
				// -------------------------------------
				if (!options.skipSequences && tableDef.sequence) {
					console.log("Create sequence");

					var sql = "CREATE SEQUENCE " + _this.getFullTableName(tableDef.schemaName, "SEQ_" + tableDef.tableName);
					sql += " START WITH " + tableDef.sequence;
					options.showCommands && console.log(sql);
					!options.skipCommands && _this.execute(_, cnx, sql);
				}
			});
		},

		/// Returns a reader that could be used to read all the records of the table
		/// 'tableDef' is an object that have been created by getTableDef() or readTables() and updated by readTableSchema()
		createTableReader: function(_, tableDef, filters) {
			return common.createTableReader(_, this, tableDef, filters);
		},

		createTableWriter: function(_, tableDef) {

			var columnNames = [];
			var paramNames = [];
			var _this = this;
			tableDef.columns.forEach(function(column, index) {
				if (column.name == "ROWID")
					return;
				columnNames.push(column.name);
				var paramName = _this.param(index);
				paramNames.push(paramName);
			});

			var sql = "INSERT INTO " + tableDef.tableName + " (" + columnNames.join(',') + ") VALUES (" + paramNames.join(',') + ")";
			var _this = this;
			return this.withConnection(_, function(_, cnx) {
				return _this.writer(_, cnx, sql);
			});
		},

		getFullTableDefName: function(tableDef) {
			return this.getFullTableName(tableDef.schemaName, tableDef.tableName);
		},

		getFullTableName: function(schemaName, tableName) {
			if (schemaName)
				return '"' + schemaName + '"."' + tableName + '"';
			else
				return '"' + tableName + '"';
		},

		clearTable: function(_, tableDef) {
			var _this = this;
			this.withConnection(_, function(_, cnx) {
				_this.execute(_, cnx, "DELETE FROM " + tableDef.tableName);
			});
		},

		/// Tries to drop a table and returns whether the drop succeeded
		dropTable: function(_, tableDef) {
			return common.dropTable(_, this, tableDef);
		},

		/// Tries to drop the sequence bound to a table and returns whether the drop succeeded
		dropSequence: function(_, tableDef) {
			return common.dropSequence(_, this, tableDef);
		},
		evalueRowCount: function(_, tableName) {
			var _this = this;
			var rs = this.withConnection(_, function(_, cnx) {
				return _this.reader(_, cnx, "select num_rows from user_tables where table_name =" + _this.param(0), [tableName]).toArray(_);
			});
			//console.log("rs:"+JSON.stringify(rs));
			return parseFloat(rs[0].NUM_ROWS);
		}
	};
};