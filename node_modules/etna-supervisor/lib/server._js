"use strict";

// TODO: select * from nls_database_parameters
// NLS_LANG=AMERICAN_AMERICA.AL32UTF8
var fs = require("streamline-fs");

var glob = require('streamline/lib/globals');
var supervisor = require("etna-supervisor/lib/supervisor");
var util = require("etna-supervisor/lib/util");
var bactx = require("etna-supervisor/lib/builtins/ACTX");
var HttpError = util.HttpError;
var tracerJs = require("syracuse-trace/lib/helper").getTracer("etna.supervisor");

function module(name) {
	if (!module.modules || !module.modules[name]) {
		module.modules = module.modules || {};
		try {
			tracerJs.debug && tracerJs.debug("require " + "etna-supervisor/lib/" + name);
			var mod = require("etna-supervisor/lib/" + name);
			module.modules[name] = mod;
		} catch (e) {
			throw new HttpError(404, name + " couldn't be loaded:" + JSON.stringify(e));
		}
	}
	return module.modules[name];
}


var HttpContext = util.defineClass(function(request, response, superv, qs) {
	this.request = request;
	this.response = response;
	this.supervisor = superv;
	this.qs = qs;
	if (qs && qs.representation) {
		var pair = qs.representation.split('.');
		this.codrep = pair[0];
		this.facet = pair[1];
	}
}, null, {
	getMethod: function() {
		return this.request._request.headers.method || this.request.method;
	},
	getHeaderField: function(field) {
		return this.request._request.headers[field];
	},
	checkMethod: function(method) {
		if (this.getMethod().toUpperCase() === method) return;
		else throw new HttpError(405, "bad method " + this.request.method);
	},
	private: {
		get: function() {
			if (!this.request.session) throw new HttpContext(500, "session missing");
			return this.request.session.private = this.request.session.private || {
				workingCopies: {}
			};
		}
	},
	reply: function(_, status, data, headers) {
		headers = headers || {};
		headers["content-type"] = headers["content-type"] || "application/json";
		this.response.writeHead(status, headers);
		console.log("reply:'" + data + "'");
		this.response.end(data, "utf8");
		return true;
	},
	jsonReply: function(_, status, data, headers) {
		headers = headers || {};
		headers["content-type"] = headers["content-type"] || "application/json";
		this.response.writeHead(status, headers);
		this.response.end(JSON.stringify(data, null, '  '), "utf8");
		return true;
	},
});

function parseQueryString(s) {
	return s ? s.split('&').reduce(function(r, sub) {
		var pair = sub.split('=');
		r[pair[0]] = pair[1];
		return r;
	}, {}) : {};
}

function parseKey(s) {
	return s && s.substring(2, s.length - 2);
}

var supervisors = {};

function postWorkingCopy(_, context, codcla, key) {
	var workingCopies = context.private.workingCopies;
	var qs = context.qs;

	var codrep = context.codrep,
		facet = context.facet;
	if (!codrep) throw new HttpError(400, "representation parameter missing");
	var repr = context.supervisor.load(_, 'Representation', codrep);
	if (!repr) throw new HttpError(404, "representation not found: " + codrep);
	if (facet !== '$edit') throw new HttpError(400, "bad facet for working copy: " + facet);
	//if (!key) throw new HttpError(400, "key value missing in " + facet + " facet");
	if (repr.data.CODCLA !== codcla) throw new HttpError(400, "class/representation mismatch: " + repr.data.CODCLA + " <> " + codcla);
	repr.check(_, facet);
	if (!qs.trackingId) throw new HttpError(400, "trackingId missing");
	var res = key ? repr.loadResource(_, key, facet, qs) : repr.createResource(_, qs);
	var wc = workingCopies[qs.trackingId] || (workingCopies[qs.trackingId] = context.supervisor.new(_, 'WorkingCopy', res, qs.trackingId));
	var node = wc.dataNode(_);
	context.jsonReply(_, 200, node, {
		location: node.$url,
	});
}

var FACETS = require("etna-supervisor/lib/meta/representation").FACETS;

var routes = [{
	pattern: /^(\$prototypes\(''\))?$/,
	handler: function(_, context, superv) {
		var lis = context.supervisor.sqlReader(_, "select R.MODULE_0, R.CODREP_0, R.CODCLA_0, R.INTREP_0, C.TYPCLA_0 " + //
			"from ASHW R, ACLASSE C where R.CODCLA_0 = C.CODCLA_0 and C.TYPCLA_0 = 2 order by CODREP_0").toArray(_).map_(_, function(_, rep) {
			return '<tr><td><a href="/syracuse-main/html/main.html?url=' + context.supervisor.baseUrl + '/' + //
			rep.CODCLA + '?representation=' + rep.CODREP + '.$query">' + rep.CODREP + '</td><td>' + //
			context.supervisor.loadText(_, parseInt(rep.INTREP, 10)) + '</a></td></tr>';
		}).join('\n');
		var html = '<html><head><title>Welcome to ETNA</title></head><body><table>\n' + lis + '\n</table></body></html>';
		context.response.writeHead(200, {
			"content-type": "text/html",
		});
		context.response.end(html);
	},
}, {
	pattern: /^\$prototypes\('([\w~]+)\~([\w~]+)\.([\w\$]+)'\)/,
	handler: function(_, context, keyword, keyvalue, facet) {
		context.checkMethod("GET");
		if (keyword.indexOf("QUERY~") === 0 && facet === "$query") {
			var script = keyword.substring(6);
			var proto = module("requester").proto(_, context, script, keyvalue, facet);
			if (!proto) throw new HttpError(404, "query not found: " + script);
			context.reply(_, 200, proto);
		} else if (keyword === "STATS" && facet === "$cube") {
			var proto = module("statistics").proto(_, context, keyvalue, facet);
			if (!proto) throw new HttpError(404, "statistics not found: " + keyword);
			context.reply(_, 200, proto);
		} else if (keyword === "PROCESS" && keyvalue === "UNKNOWN" && facet === "$details") {
			// todo handle ~ in codrep
			var proto = {};
			context.jsonReply(_, 200, proto);
		} else {
			throw new HttpError(404, keyword + " not yet managed: " + keyvalue + ' facet=' + facet);
		}
	},
}, {
	pattern: /^\$prototypes\('([\w~]+)\.([\w\$]+)'\)/,
	handler: function(_, context, codrep, facet) {
		context.checkMethod("GET");
		var proto;
		if (facet === "$search") {
			var clas = context.supervisor.load(_, 'Class', codrep);
			if (!clas) throw new HttpError(404, "Class not found: " + codrep);
			proto = clas.searchProto(_);
		} else {
			var repr = context.supervisor.load(_, 'Representation', codrep);
			if (!repr) throw new HttpError(404, "representation not found: " + codrep);
			if (!FACETS[facet]) throw new HttpError(400, "bad facet: " + facet);
			repr.check(_, facet);
			repr.checkDevice(context.qs.device);
			if (context.qs.device) repr.qdevice = context.qs.device;
			proto = repr.proto(_, facet);
			//fs.writeFile(__dirname + "/../../../results/etna/" +  codrep + "-" + facet + ".json", JSON.stringify(proto, null, 2), "utf8", _);
		}
		context.jsonReply(_, 200, proto);
	},
}, {
	///sdata/x3/erp/etnaOracle/BDOC('C_AUTILIS~¨~AUSPIC~¨~AUSPIC~¨~ERB~¨~~¨~')?salt=983&language=fr-FR
	pattern: /^BDOC\('C_(\w*)~(?:¨|%C2%A8)~(\w*)~(?:¨|%C2%A8)~(\w*)~(?:¨|%C2%A8)~(\w*)~(?:¨|%C2%A8)~(\w*)/,
	handler: function(_, context, codcla, property, ident1, ident2, ident3) {
		var clas = context.supervisor.load(_, 'Class', codcla);
		if (!clas) throw new HttpError(404, "class not found: " + codcla);
		var bdoc = clas.readBDOC(_, property, ident1, ident2, ident3);
		if (bdoc) {
			context.response.writeHead(200, {
				'content-type': 'image',
				'Transfer-Encoding': 'chunked',
				'X-FRAME-OPTIONS': 'DENY'
			});
			context.response.end(bdoc);
		} else {
			throw new HttpError(404, "image not found: " + [property, ident1, ident2, ident3].join('~'));
		}
	},
}, {
	//sdata/x3/erp/etnaOracle/BDOC('C_AVOLFIL~%C2%A8~CONTENTS~%C2%A8~TMP~%C2%A8~000002.jpg')
	pattern: /^BDOC\('C_(\w*)~(?:¨|%C2%A8)~(\w*)~(?:¨|%C2%A8)~(\w*)~(?:¨|%C2%A8)~([\w\.]*)/,
	handler: function(_, context, codcla, property, ident1, ident2) {
		var clas = context.supervisor.load(_, 'Class', codcla);
		if (!clas) throw new HttpError(404, "class not found: " + codcla);
		var bdoc = clas.readBDOC(_, property, ident1, ident2);
		if (bdoc) {
			context.response.writeHead(200, {
				'content-type': 'image',
				'Transfer-Encoding': 'chunked',
				'X-FRAME-OPTIONS': 'DENY'
			});
			context.response.end(bdoc);
		} else {
			throw new HttpError(404, "image not found: " + [property, ident1, ident2].join('~'));
		}
	},
}, {
	pattern: /^(\w*)(\('[^']*'\))?$/,
	handler: function(_, context, codcla, key) {
		key = parseKey(key);
		if (codcla === 'QUERY') {
			context.checkMethod("GET");
			return module("requester").query(_, context, key, context.codrep);
		} else if (codcla === 'STATS') {
			context.checkMethod("GET");
			var res = module("statistics").query(_, context, key, context.codrep);
			return context.reply(_, 200, res);
		}

		var codrep = context.codrep,
			facet = context.facet,
			qs = context.qs;
		if (!codrep) throw new HttpError(400, "representation parameter missing");
		if (facet !== "$search") {
			var repr = context.supervisor.load(_, 'Representation', codrep);
			if (!repr) throw new HttpError(404, "representation not found: " + codrep);
			if (repr.data.CODCLA !== codcla) throw new HttpError(400, "class/representation mismatch: " + repr.data.CODCLA + " <> " + codcla);
			repr.check(_, facet);

			var method = context.getMethod().toUpperCase();
			if (facet === '$query' && method === 'DELETE') {
				return repr.deleteResource(_, context, key, facet, qs);
			} else if (/^\$(query|lookup|bulk)$/.test(facet) && method === 'GET') {
				if (key) throw new HttpError(400, "key value not allowed in " + facet + " facet");
				return repr.query(_, context, facet, qs);
			} else if (/^\$(details|summary)$/.test(facet) && method === 'GET') {
				if (!key) throw new HttpError(400, "key value missing in " + facet + " facet");
				return context.jsonReply(_, 200, repr.loadResource(_, key, facet, qs).dataNode(_));
			}
			// In other cases :  
			throw new HttpError(405, "bad method " + method);

		} else {
			context.checkMethod("GET");
			var clas = context.supervisor.load(_, 'Class', codcla);
			if (!clas) throw new HttpError(404, "class not found: " + codcla);
			if (!clas.isSearchable) throw new HttpError(406, "search not available for class: " + codcla);
			return clas.search(_, context, qs);
		}
	},
}, {
	pattern: /^(\w+)(\('[^']*'\))?\/\$workingCopies$/,
	handler: function(_, context, codcla, key) {
		var method = context.request.method.toUpperCase();
		var qs = context.qs;

		if (method === "POST") {
			postWorkingCopy(_, context, codcla, parseKey(key));
		} else if (method === "DELETE") {
			var workingCopies = context.private.workingCopies;
			workingCopies[qs.trackingId] = undefined;
			context.jsonReply(_, 200, {});
		} else throw new HttpError(405, "bad method: " + method);
	},
}, {
	// {$baseUrl}/AVOLUME/$template?representation=AVOLUME.$edit&trackingId=41827f7b-c3df-483e-9e30-4131d3f6edaf
	pattern: /^(\w+)\/\$template\/\$workingCopies$/,
	handler: function(_, context, codcla) {
		context.checkMethod("POST");
		postWorkingCopy(_, context, codcla);
	},
}, {
	// sdata/x3/erp/etnaOracle/ARIGHTS('ADMIN')/$services/$rights
	pattern: /^ARIGHTS\('(\w*)'\)\/\$services\/\$rights$/,
	handler: function(_, context, user) {
		tracerJs.debug && tracerJs.debug('context.request._request.headers["if-none-match"] ' + context.request._request.headers["if-none-match"]);
		var res = glob.context.x3session.actx._x3Rights.getJsonRights(_, user);
		var rightsEtag = glob.context.x3session.actx._x3Rights._etag;
		var headers = {
			'content-type': 'application/json',
			'etag': rightsEtag
		};
		tracerJs.debug && tracerJs.debug("headers :" + JSON.stringify(headers));

		if (rightsEtag === context.request._request.headers["if-none-match"]) {
			context.jsonReply(_, 304, headers);
		} else if (res) {
			context.jsonReply(_, 200, util.unescapeJson(res), headers);
		} else {
			throw new HttpError(400, "rights error");
		}
	},
}, {
	pattern: /^\$workingCopies\('([^']*)'\)$/,
	handler: function(_, context, trackingId) {
		var workingCopies = context.private.workingCopies;
		var method = context.request.method.toUpperCase();
		if (method === "PUT") {
			var wc = workingCopies[trackingId];
			if (!wc) throw new HttpError(404, "working copy not found: " + trackingId);
			var data = JSON.parse(context.request.readAll(_));
			var delta = wc.update(_, context, data);
			context.jsonReply(_, 200, delta);
		} else if (method === "DELETE") {
			workingCopies[trackingId] = undefined;
			context.jsonReply(_, 200, {});
		} else throw new HttpError(405, "bad method: " + method);

	},
}, {
	// /$workingCopies('ffb5aee7-55a7-4030-9040-658f54def52f')/AQQ06/FIELD13
	pattern: /^\$workingCopies\('([^']*)'\)((\/\w*)*)$/,
	handler: function(_, context, trackingId, path) {
		var workingCopies = context.private.workingCopies;
		var wc = workingCopies[trackingId];
		if (!wc) throw new HttpError(404, "working copy not found: " + trackingId);

		var method = context.request.method.toUpperCase();
		if (method === "PUT") {
			var data = context.request.readAll(_);
			var delta = wc.update(_, context, data, path);
			context.jsonReply(_, 200, delta);
		} else if (method === "GET") {
			wc.read(_, context, path);
		} else throw new HttpError(405, "bad method: " + method);
	},
}, {
	pattern: /^(\w+)(\('[^']*'\))?\/\$services\/(\w+)/,
	handler: function(_, context, codcla, key, service) {
		key = parseKey(key);
		//var clas = context.supervisor.load(_, 'Class', codcla);
		//if (!clas) throw new HttpError(404, "class not found: " + codcla);
		var codrep = context.codrep,
			facet = context.facet,
			qs = context.qs;
		if (!codrep) throw new HttpError(400, "representation parameter missing");
		var repr = context.supervisor.load(_, 'Representation', codrep);
		if (!repr) throw new HttpError(404, "representation not found: " + codrep);
		if (!FACETS[facet]) throw new HttpError(400, "bad facet: " + facet);
		if (facet === '$edit') throw new HttpError(400, "bad facet: " + facet);
		if (repr.data.CODCLA !== codcla) throw new HttpError(400, "class/representation mismatch: " + repr.data.CODCLA + " <> " + codcla);
		repr.check(_, facet);

		var res = repr.service(_, key, service, facet, qs);
		context.jsonReply(_, 200, res);
	},
}, {
	pattern: /^\$service\/\ABOUT$/,
	handler: function(_, context) {
		context.jsonReply(_, 200, context.supervisor.about(_));
	},
}];

exports.httpDispatch = function(_, config, request, response) {
	try {
		request.url = decodeURIComponent(request.url);

		tracerJs.debug && tracerJs.debug([request.method, request.url].join(' '));

		//tracerJs.debug && tracerJs.debug("DBGSESSION=" + JSON.stringify(config.session));

		request.session.x3Info = config.session;
		var m = /^\/sdata\/(?:etna|x3)\/erp\/(\w+)\/([^?]*)\??(.*$)/.exec(request.url);
		if (!m) throw new HttpError(404, "resource not found.");
		var endpointName = m[1],
			path = m[2],
			qs = parseQueryString(m[3]);
		var key = config.endpointName;
		var superv = supervisors[key] || (supervisors[key] = supervisor.create(_, config));
		superv.razCacheScripts(_);
		var context = new HttpContext(request, response, superv, qs);
		require("etna-engine/lib/runtime/variables").initStack(superv);
		//tracerJs.debug && tracerJs.debug(JSON.stringify(config.session));
		bactx.init(_, config.session, superv);
		config.session = undefined;
		for (var i = 0; i < routes.length; i++) {
			var r = routes[i].pattern.exec(path);
			if (r) return routes[i].handler.apply_(_, null, [context].concat(r.slice(1)), 0);
		}
		throw new HttpError(400, "bad url format: " + request.url);
	} catch (ex) {
		console.error(ex.stack);
		if (!ex.statusCode) tracerJs.error && tracerJs.error(ex.stack);
		context = context || new HttpContext(request, response);
		context.jsonReply(_, ex.statusCode || 500, {
			$diagnoses: [{
				$severity: "error",
				$message: ex.message //,
				//$stackTrace: ex.stack // TO KEEP ?
			}]
		});
	}
};