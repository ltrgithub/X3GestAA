"use strict";

// TODO: select * from nls_database_parameters
// NLS_LANG=AMERICAN_AMERICA.AL32UTF8
var fs = require("streamline-fs");
var streams = require("streamline-streams");

var supervisor = require("etna-supervisor/lib/supervisor");
var util = require("etna-supervisor/lib/util");
var HttpError = util.HttpError;

var HttpContext = util.defineClass(function(request, response, superv, qs) {
	this.request = request;
	this.response = response;
	this.supervisor = superv;
	this.qs = qs;
	if (qs && qs.representation) {
		var pair = qs.representation.split('.');
		this.codrep = pair[0];
		this.facet = pair[1];
	}
}, null, {
	checkMethod: function(method) {
		if (this.request.method !== method) throw new HttpError(405, "bad method " + this.request.method);
	},
	private: {
		get: function() {
			if (!this.request.session) throw new HttpContext(500, "session missing");
			return this.request.session.private = this.request.session.private || {
				workingCopies: {}
			};
		}
	},
	jsonReply: function(_, status, data, headers) {
		headers = headers || {};
		headers["content-type"] = headers["content-type"] || "application/json";
		this.response.writeHead(status, headers);
		this.response.end(JSON.stringify(data, null, '  '), "utf8");
		return true;
	},
});

function parseQueryString(s) {
	return s ? s.split('&').reduce(function(r, sub) {
		var pair = sub.split('=');
		r[pair[0]] = pair[1];
		return r;
	}, {}) : {};
}

function parseKey(s) {
	return s && s.substring(2, s.length - 2);
}

var supervisors = {};

var FACETS = require("etna-supervisor/lib/meta/representation").FACETS;

var routes = [{
	pattern: /^(\$prototypes\(''\))?$/,
	handler: function(_, context, superv) {
		var lis = context.supervisor.executeSql(_, "select R.MODULE_0, R.CODREP_0, R.CODCLA_0, R.INTREP_0, C.TYPCLA_0 " + //
		"from ASHW R, ACLASSE C where R.CODCLA_0 = C.CODCLA_0 and C.TYPCLA_0 = 2 order by CODREP_0").map_(_, function(_, rep) {
			return '<tr><td><a href="/syracuse-main/html/main.html?url=' + context.supervisor.baseUrl + '/' + //
			rep.CODCLA + '?representation=' + rep.CODREP + '.$query">' + rep.CODREP + '</td><td>' + //
			context.supervisor.loadText(_, parseInt(rep.INTREP, 10)) + '</a></td></tr>';
		}).join('\n');
		var html = '<html><head><title>Welcome to ETNA</title></head><body><table>\n' + lis + '\n</table></body></html>';
		context.response.writeHead(200, {
			"content-type": "text/html",
		});
		context.response.end(html);
	},
}, {
	pattern: /^\$prototypes\('([\w~]+)\.([\w\$]+)'\)/,
	handler: function(_, context, codrep, facet) {
		context.checkMethod("GET");
		// todo handle ~ in codrep
		var repr = context.supervisor.load(_, 'Representation', codrep);
		if (!repr) throw new HttpError(404, "representation not found: " + codrep);
		if (!FACETS[facet]) throw new HttpError(400, "bad facet: " + facet);
		if (!repr.isFacetEnabled(facet)) throw new HttpError(406, "facet not enabled: " + facet);
		repr.checkDevice(context.qs.device);
		var proto = repr.proto(_, facet);
		//fs.writeFile(__dirname + "/../../../results/etna/" +  codrep + "-" + facet + ".json", JSON.stringify(proto, null, 2), "utf8", _);
		context.jsonReply(_, 200, proto);
	},
}, {
	pattern: /^(\w*)(\('[^']*'\))?$/,
	handler: function(_, context, codcla, key) {
		context.checkMethod("GET");
		key = parseKey(key);
		var clas = context.supervisor.load(_, 'Class', codcla);
		if (!clas) throw new HttpError(404, "class not found: " + codcla);
		var codrep = context.codrep,
			facet = context.facet,
			qs = context.qs;
		if (!codrep) throw new HttpError(400, "representation parameter missing");
		var repr = context.supervisor.load(_, 'Representation', codrep);
		if (!repr) throw new HttpError(404, "representation not found: " + codrep);
		if ((facet === '$query' || facet === '$lookup') && key) throw new HttpError(400, "key value not allowed in $query facet");
		if ((facet !== '$query' && facet !== '$lookup') && !key) throw new HttpError(400, "key value missing in " + facet + " facet");
		if (repr.data.CODCLA !== codcla) throw new HttpError(400, "class/representation mismatch: " + repr.data.CODCLA + " <> " + codcla);
		var res;
		if (key) res = repr.loadResource(_, key, facet, qs).dataNode(_);
		else res = repr.query(_, facet, qs);
		context.jsonReply(_, 200, res);
	},
}, {
	pattern: /^(\w+)(\('[^']*'\))?\/\$workingCopies$/,
	handler: function(_, context, codcla, key) {
		var workingCopies = context.private.workingCopies;
		context.checkMethod("POST");
		key = parseKey(key);
		var clas = context.supervisor.load(_, 'Class', codcla);
		if (!clas) throw new HttpError(404, "class not found: " + codcla);
		var codrep = context.codrep,
			facet = context.facet,
			qs = context.qs;
		if (!codrep) throw new HttpError(400, "representation parameter missing");
		var repr = context.supervisor.load(_, 'Representation', codrep);
		if (!repr) throw new HttpError(404, "representation not found: " + codrep);
		if (facet !== '$edit') throw new HttpError(400, "bad facet for working copy: " + facet);
		//if (!key) throw new HttpError(400, "key value missing in " + facet + " facet");
		if (repr.data.CODCLA !== codcla) throw new HttpError(400, "class/representation mismatch: " + repr.data.CODCLA + " <> " + codcla);
		if (!qs.trackingId) throw new HttpError(400, "trackingId missing");
		var res = key ? repr.loadResource(_, key, facet, qs) : repr.createResource(_, qs);
		var wc = workingCopies[qs.trackingId] || (workingCopies[qs.trackingId] = context.supervisor.new(_, 'WorkingCopy', res, qs.trackingId));
		var node = wc.dataNode(_);
		context.jsonReply(_, 201, node, {
			location: node.$url,
		});
	},
}, {
	pattern: /^\$workingCopies\('([^']*)'\)$/,
	handler: function(_, context, trackingId) {
		var workingCopies = context.private.workingCopies;
		var method = context.request.method;
		if (method === "PUT") {
			var wc = workingCopies[trackingId];
			if (!wc) throw new HttpError(404, "working copy not found: " + trackingId);
			var data = JSON.parse(context.request.readAll(_));
			var delta = wc.update(_, data);
			context.jsonReply(_, 200, delta);
		} else if (method === "DELETE") {
			delete workingCopies[trackingId];
			context.jsonReply(_, 200, {});
		} else throw new HttpError(405, "bad method: " + method);

	},
}];

exports.httpDispatch = function(_, config, request, response) {
	try {
		request.url = request.url.replace(/%27/g, "'");
		console.log("DBGURL=" + request.url);
		var m = /^\/sdata\/(?:etna|x3)\/erp\/(\w+)\/([^?]*)\??(.*$)/.exec(request.url);
		if (!m) throw new HttpError(404, "resource not found.");
		var endpointName = m[1],
			path = m[2],
			qs = parseQueryString(m[3]);
		var key = config.endpointName;
		var superv = supervisors[key] || (supervisors[key] = supervisor.create(_, config));
		var context = new HttpContext(request, response, superv, qs);
		require("etna-engine/lib/runtime/variables").initStack(superv);
		for (var i = 0; i < routes.length; i++) {
			var m = routes[i].pattern.exec(path);
			if (m) return routes[i].handler.apply_(_, null, [context].concat(m.slice(1)), 0);
		}
		throw new HttpError(400, "bad url format: " + request.url);
	} catch (ex) {
		if (!ex.statusCode) console.error(ex.stack);
		context = context || new HttpContext(request, response);
		context.jsonReply(_, ex.statusCode || 500, {
			$diagnoses: [{
				$severity: "error",
				$message: ex.message,
				$stackTrace: ex.stack,
			}]
		});
	}
}