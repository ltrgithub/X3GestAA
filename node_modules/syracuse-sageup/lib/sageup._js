"use strict";

/// # Sage EDI Commercial API  
/// ```javascript
/// var sageup = require('syracuse-sageup').sageup  
/// ```
/// This module is exported to be able to be call from X3

exports.$exported = true;


var sdataClient = require('./client'),
	sa = require('syracuse-orm/lib/storageArea'),
	fs = require('streamline-fs'),
	streams = require("streamline/lib/streams/server/streams"),
	pdfReader = require('syracuse-pdf').reader,
	pdfWriter = require('syracuse-pdf').writer,
	jsxml = require('jsxml'),
	helpers = require('syracuse-core/lib/helpers');

var tempDir =  __dirname + '/../data/temp/';

function getAuthentication(auth){
    return auth.emailSso;
}

/// -------------
/// ## sendToEDI function :
/// ``` javascript
/// var response = sageup.sendToEDI(_, options); 
/// ```
/// Read document from storage area.  
/// 
/// * The `options` parameter is a JSON object :  
/// 
/// ``` javascript
/// var options = {
///    host : "server_host_name",
///    url : "/sdata/edi/commercialsupplier/78973447/eInvoice",
///    method : "GET | POST | PUT | DELETE",
///    auth : {
///       emailSso : "emailsso@sage.com",
///    },
///    sdata : {
///       format : "xml | json",
///       payload : `sdata payload`
///    },
///    binaries : {
///       pdf : `storage area uuid for PDF document`,
///       ubl : `storage area uuid for UBL document`
///    }
/// }
/// ```
/// > `host` parameter is mandatory : it requires the server hostname or IP adress.  
/// > `url` parameter is mandatory : it requires the http url used to send request (partial url).  
/// > `method` parameter is mandatory : it requires the http method used to send request.  
/// > `auth` parameter is mandatory : it requires for instance the email sso used to connect to EDI.  
/// > `sdata` parameter is mandatory only for `POST` and `PUT` methods : it requires a `format` that can be `xml` or `json` and a `sdata payload` in specified format.  
/// > `binaries` parameter is optional : it requires two document UUIDS corresponding to PDF and UBL documents.  
/// 
/// Returns a JSON object :
/// 
/// ``` javascript
/// {
///    statusCode : "The HTTP Response status code",
///    header : "The HTTP Response header",
///    body : "The HTTP Response body"
/// }
/// ```
/// 
exports.sendToEDI = function(_, options){
	try{
		if (options != null){
			
			//console.log("options="+JSON.stringify(options,null,2));
			checkOptions(options);
			

			
			
			if (options.sdata != null && options.sdata.format !== "json"){
				if (options.sdata.format === "xml"){
					try{
						if (options.sdata.payload != null)
							options.sdata.payload = jsxml.parse(options.sdata.payload);	
					}catch(e){
						throw new Error("Payload format is not correct:\n"+e.stack);
					}
				}else{
					throw new Error("SDATA format must be 'json' or 'xml'.");
				}
			}

			// If binaries uuids are provided
			if (options != null && options.binaries != null){
				if (options.binaries.pdf == null)
					throw new Error("The document storage uuid for PDF is required in 'options' parameter.");
				if (options.binaries.ubl == null)
					throw new Error("The document storage uuid for UBL is required in 'options' parameter.");
				
				// Retrieve document reference from payload
				var reference = options.sdata.payload['sdata:payload']['ns0:eInvoice']['ns0:document']['ns0:reference']
				
				// Attach UBL to PDF and sign it in temporary file
				var pdf = preparePdf(_, options.binaries.pdf, options.binaries.ubl, reference);

				// Put binary content encoded in base64 in payload
				options.sdata.payload['sdata:payload']['ns0:eInvoice']['ns0:document']['ns0:binary'] = pdf.buffer.toString('base64');
				

			}
			var sdataXml;
			if (options.sdata != null && options.sdata.payload != null){
				sdataXml = jsxml.stringify(options.sdata.payload); 
			}
			

			var proxyServerHost = helpers.proxy && helpers.proxy.server != null ? helpers.proxy.server : null;
			var proxyServerPort = helpers.proxy && helpers.proxy.port != null ? helpers.proxy.port : null;

			var debug = helpers.sageup && helpers.sageup.debug != null ? helpers.sageup.debug : false;
			var format = helpers.sageup && helpers.sageup.format != null ? helpers.sageup.format : 'xml';
			var params = helpers.sageup && helpers.sageup.params != null ? helpers.sageup.params : {};
				
			var sdata_options = {

					debug: debug,
					format: format,
					params: params 
			}
			
			if (proxyServerHost != null && proxyServerPort != null){
				sdata_options.proxy = "http://"+proxyServerHost+":"+proxyServerPort;
			}
			// Put authentication information in header
			sdata_options.auth = getAuthentication(options.auth);
			// Put host information in header
			sdata_options.host = options.host;

			// Create Sdata client
			var cli = sdataClient.create(_, sdata_options);
			
			var resp = cli.execHttpRequest(_, options.method, options.url, sdataXml);
			//console.log("RESPONSE="+JSON.stringify(resp,null,2));
			
			
			
			// Store PDF document in storage area and replace binary content by uuid in http response
			if (options.method === "GET" && options.url.indexOf('eInvoice') !== -1 && resp.statusCode === 200){
				
				if (format === 'xml')
					resp.body = jsxml.parse(resp.body);
				
				var properties = {
				  description: resp.body.entry.payload.eInvoice.document.reference,
				  content: {
				    contentType: "application/pdf",
				    fileName: resp.body.entry.payload.eInvoice.document.reference + ".pdf",
				  }
				}
				var bin = new Buffer(resp.body.entry.payload.eInvoice.document.binary, 'base64').toString('binary');
				var document = sa.writeAll(_, properties, bin);
				resp.body.entry.payload.eInvoice.document.binary = document.$uuid;
				
				if (format === 'xml')
					resp.body = jsxml.stringify(resp.body);
			}
			
			
			return resp;
			
		}else{
			throw new Error("'options' parameter must not be null !");
		}
		
	}catch(e){
		console.log("error sendToEDI: "+e.stack);
		throw e;
	}
	
}

function checkOptions(options){
	if (options.host == null)
		throw new Error("The host server name or IP adress is required in 'options' parameter.");
	if (options.url == null)
		throw new Error("The http url is required in 'options' parameter.");
	if (options.method == null){
		throw new Error("The http method is required in 'options' parameter.");
	}else{
		if (options.sdata == null && (options.method === 'POST' || options.method === 'PUT'))
			throw new Error("SData information are required in 'options' parameter for 'POST' and 'PUT' requests.");
	}
	if (options.auth == null)
		throw new Error("Authentication information are required in 'options' parameter.");

}

function preparePdf(_, pdf, ubl, reference){

	reference = reference != null ? reference : "PDF with UBL signed for SageUp";
	var tmpPdfFile = tempDocument(_, pdf);
	
	try{
		var reader = pdfReader.create(_, tmpPdfFile);
		
		var writer = pdfWriter.create(_,reader);
	
		var tmpUblFile = tempDocument(_, ubl);
		var data = fs.readFile(tmpUblFile, _);
		writer.attach(_, 'facture.xml', 'UBL embedded file', data);
		
		// TODO : Manage certificate
		writer.sign(_, certificate, privateKey, passphrase);

	}finally{
		writer.close(_);
	}
	var options = {
		description: reference,
		content: {
			contentType: "application/pdf",
			fileName: "x3invoice.pdf",
		}
	}
	
	// Store final document to storage area
	var uuid = storeDocument(_, tmpPdfFile, options);
	var buf = fs.readFile(tmpPdfFile, _);
	
	
	// remove temporary pdf file
	fs.unlink(tmpPdfFile,_);
	// remove temporary ubl file
	fs.unlink(tmpUblFile,_);
	// remove original pdf file from storage area
	sa.remove(_,{jsonWhere:{$uuid: pdf}});
	// remove original ubl file from storage area
	sa.remove(_,{jsonWhere:{$uuid: ubl}});

	return {
		uuid : uuid,
		buffer : buf
	}
	
}

function storeDocument(_, fname, options){
	var dd = sa.open(_, null);

	
	var astream = new streams.ReadableStream(fs.createReadStream(fname));
	
	var buf;
	while (buf = astream.read(_,10000)){
		sa.write(_, dd, options, buf);
	}
	var document = sa.close(_, dd, true);
	return document.$uuid;
}

function tempDocument(_, uuid){

		var filter = {jsonWhere:{$uuid: uuid}};
		var dd = sa.open(_, filter);
	
		var fname = tempDir + 'tmp-' + uuid;
		var astream = new streams.WritableStream(fs.createWriteStream(fname));

		var buf;
		while (buf = sa.read(_,dd)){
			astream.write(_, buf);
		}
		astream.end();
	
		sa.close(_, dd);
		return fname;
}

var certificate = __dirname + '/../data/crypto/certinomis/certificate.pem',
	privateKey = __dirname + '/../data/crypto/certinomis/private.pem',
	passphrase = '000000';

