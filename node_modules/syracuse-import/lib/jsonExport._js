var fs = require('fs');
var fsp = require("path");
var sys = require("util");
var helpers = require("syracuse-core/lib/helpers");
var flows = require("streamline/lib/util/flows");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var resourceHelpers = require("syracuse-core/lib/resource/util");
var locale = require("syracuse-core/lib/locale");

//var tracer = null;
var tracer = console.log;


var _exportTargetsMap = {
	download: function(_, exportObj, options) {
		// TODO: need to reply the content, so override the default services execution behavior
	},
	file: function(_, exportObj, options) {
        if (!options.path) throw new Error(locale.format(module, "missingParameter", "path"));
	    fs.writeFile(fsp.join(__dirname, "../../../import", options.path + ".json"), JSON.stringify(exportObj));
	},
	db_file: function(_, exportObj, options) {
		// TODO: doc save diagnoses
        if (!options.storageDescription || !options.storageVolume) throw new Error(locale.format(module, "missingParameter", "storageDescription, storageVolume"));
		var db = adminHelper.getCollaborationOrm(_);
		var doc = db.getEntity(_, "document").createInstance(_, db);
		var vol = db.fetchInstance(_, db.getEntity(_, "document"), options.storageVolume);
		doc.description(_, options.storageDescription);
		doc.volume(_, vol);
		var s = doc.content(_).createWritableStream(_);
		s.write(_, JSON.stringify(exportObj));
		s.write(_, null);
		doc.save(_);
	},
	server: function(_, exportObj, options) {
		if(!options.friendServer)
			throw new Error(locale.format(module, "missingParameter", "friendServer"));
		var db = adminHelper.getCollaborationOrm(_);
		var server = db.fetchInstance(_, db.getEntity(_, "friendServer"), options.friendServer);
		if(!server) return;
		var s = server.createWritableStream(_, "$import");
		s.write(_, JSON.stringify(exportObj));
		var resp = s.end().response(_);
        tracer && tracer("jsonExport friend server transfer: got response: "+sys.inspect(resp));
        var respJson = resp.readAll(_);
        tracer && tracer("jsonExport friend server transfer: got response content: "+sys.inspect(respJson));
	}
}


exports.jsonExport = function (_, instance, options) {



    options = options || {};
    tracer = tracer || options.tracer || (require("syracuse-main/lib/nodeconfig").config.import || {}).tracer;

    if (!instance) {
        tracer && tracer("Export Profile is null");
        return ;
    }

    var opt = options || {};
    var db = instance.endpoint(_).getOrm(_);
    var model = db.model;
   
    var items = instance.exportProfileItem(_).toArray(_);
    var exportObj = {
        $prototypes: {},
        $items: []
    };

    items.forEach_(_, function (_, item, idx) {
        tracer && tracer("jsonExport exporting profile item :" + item.className(_));

        var allItems = this;

        var filter = item.filter(_);
        console.log("filter: " + filter);
        var propSelection = [];
        item.entityAttribute(_).toArray(_).forEach_(_, function (_, el) {
            propSelection.push(el.name(_));
        });
        console.log("hello");
        var keys = [];
        item.entityKeyAttribute(_).toArray(_).forEach_(_, function (_, el) {
            var ent = model.getEntity(model.singularize(item.className(_)));
            //console.log("ENTITY: "+ sys.inspect(ent)) ;
            var property = ent.$properties[el.name(_)];
            if (property && property.$isLocalized) {
                tracer && tracer("property is Localized " + el.name(_) + locale.current);
                keys.push(el.name(_) + '.' + locale.current);
            } else keys.push(el.name(_));
            propSelection.push(el.name(_)) ;
        });

        var profileIt = model.singularize(item.className(_));
        console.log("hello-" + profileIt);


        var entity = model.getEntity(_, profileIt);

        var itemProto = serializeProto(_, entity, propSelection, allItems, model, keys);
        tracer && tracer("jsonExport exporting itemProto :" + sys.inspect(itemProto));
        exportObj.$prototypes[profileIt] = itemProto;

        if (item.filter(_) && item.filter(_) !== "") {
            tracer && tracer("jsonExport filter: " + filter);

            //var objs=db.fetchInstances(_, entity, {jsonWhere: item.filter(_)});
            //consoel.log("Filtered instances: "+sys.inspect(objs) ) ;
        } else {
        var exportedObjs = item.exportedObjects(_).toArray(_);
            console.log("nb exported objects= " + exportedObjs.length);
            exportedObjs.forEach_(_, function (_, ob, idx) {
                tracer && tracer("exportedObject OB: " + ob.$uuid);

            var inst = db.fetchInstance(_, entity, ob.$uuid);
            var exportItem = {};
            //console.log("exportedObject: "+ sys.inspect(inst)) ; 
                console.log("selection to pass: " + sys.inspect(propSelection));
            exportItem = objSerialize(_, inst, propSelection, allItems, model, model.singularize(item.className(_)));
                tracer && tracer("jsonExport exporting item :" + sys.inspect(exportItem));

            exportObj.$items.push(exportItem);
        });
        }
    });

    _exportTargetsMap[opt.targetType || "download"](_, exportObj, opt);

}

function serializeProto(_, entity, selection, allItems, model, keys) {
    console.log("serialize relation proto");
    //console.log("entity.$relations: "+ sys.inspect(entity.$relations)) ;
    var proto = {};
    if (keys && keys.length === 1) proto["$key"] = keys[0];
    else if (keys && keys.length > 1) proto["$key"] = keys;

    flows.eachKey(_, entity.$relations, function (_, rel, relation) {
        console.log("RELATION: " + rel);
        if ( /*!relation.$isMandatory &&*/ selection.length > 0 && selection.indexOf(rel) == -1) {
            console.log("SELECTION " + sys.inspect(selection));
            return ;
        }
        //console.log("RELATION: " + sys.inspect(relation ));
        var name = relation.targetEntity.name;
        var j;
        for (j = 0; j < allItems.length; j++) {
            console.log("allItems : " + j + 'clnam : ' + allItems[j].className(_));
            //console.log("targetEntityname:  " + helpers.string.pluralize(relation.targetEntity.name));
            if (allItems[j].className(_) === helpers.string.pluralize(name)) {
                //relation.targetEntity.type ???
                tracer && tracer("exporting relation " + allItems[j].className(_));

                var propselNames = [];
                allItems[j].entityAttribute(_).toArray(_).forEach_(_, function (_, el) {
                    propselNames.push(el.name(_));
                });
                var relkeys = allItems[j].entityKeyAttribute(_).toArray(_);
                var relkeynames = [];
                relkeys.forEach_(_, function (_, k, idx) {
                    propselNames.push(k.name(_));
                    relkeynames.push(k.name(_));
                });

                break;
            }
        };
      

        if (relation.isChild) {
            tracer && tracer("Child relation");
            var entityRel = model.getEntity(_, name);
            proto[rel] = serializeProto(_, entityRel, propselNames, allItems, model, relkeynames);
            tracer && tracer("jsonExport: exporting relation proto: " + sys.inspect(proto[name]));
        }

    });

    console.log("PROTO: " + sys.inspect(proto));
    return proto;
}


function refSerialize(_, targetEntity, elt, propSelection, allItems, model, type) {
    var resource={} ;
    tracer && tracer("jsonExport: serializing reference ");
//console.log("propSelection: "+JSON.stringify(propSelection)) ;
    if (!targetEntity) {
         tracer && tracer("jsonExport:null target ");
        return null;
    }

    //console.log("obj serialize propSelection " + sys.inspect(propSelection));
    //console.log("obj serialize propSelection " + sys.inspect(instance));

    //flows.eachKey(_, instance._relMeta.targetEntity.$properties, function (_, prop, property) {
    
    flows.eachKey(_, targetEntity.$properties, function (_, prop, property) {
    console.log("PROP: "+prop) 

        if (/*!property.$isMandatory &&*/ propSelection.length > 0 && propSelection.indexOf(prop) == -1) {
            tracer && tracer("not exportable property:" + prop);
            return;
        }
        //if (property.isExternalStorage() && !(instance[prop](_) && instance[prop](_).fileExists(_))) {
            if (property.isExternalStorage() && !(elt[prop](_) && elt[prop](_).fileExists(_))) {
            tracer && tracer("property ExternalStorage:" + prop);
            return;
        }

        if (property.$isLazy || property.isExternalStorage()) {

            tracer && tracer("PROP lazy:" + prop);
        } else {
            tracer && tracer("property:" + prop);
            resource[prop] = resourceHelpers.formatValue(property, elt[prop](_));
        }
    });

    tracer && tracer("the  relation of the relation");

    flows.eachKey(_, targetEntity.$relations, function (_, rel, relation) {

        //console.log("dd:" +rel) ;
        console.log("RELATION de relation : "+rel) ;
        //console.log("dd: "+sys.inspect(relation));
        //console.log("coucou");
        //console.log("sss "+relation.$inv) ;
        var inv = relation.$inv && relation.targetEntity.$relations[relation.$inv];
        if (inv && inv.isChild) {
              console.log(" inv child rel ");
            return;
        }
        if (propSelection.length > 0 && propSelection.indexOf(rel) == -1) {
            console.log("rel not exportable");
            return;
        }
        console.log("on va chercher sa clé et ses attributs");
        //console.log("RELATION "+rel+' : ' + sys.inspect(relation  ));
        //console.log(allItems) ;
        //console.log("len="+allItems.length)  ;
        var i;
        for (i = 0; i < allItems.length; i++) {
            
           // console.log("allItems classname " + i + ' :' + allItems[i].className(_));
            if (allItems[i].className(_) === helpers.string.pluralize(relation.targetEntity.name)) {
                console.log("allItems relation found");
                var propselNames = [];
                var keysel = allItems[i].entityKeyAttribute(_).toArray(_);
                 allItems[i].entityAttribute(_).toArray(_).forEach_(_, function (_, el) {
            propselNames.push(el.name(_));
        });

       
                //var reltype = allItems[i].className(_);
                if (keysel.legth === 0) {
                    console.log("relation without key");
                    return;
                }
                break;
            }
        }
        if (keysel && keysel.length) {
            console.log("relation should be exported") ;
        } else {
            console.log("relation shouldn't be exported");
        console.log(' '+rel+keysel) ;
        return ;
        }
       
        if (relation.isPlural) {
            console.log("***plural******* ");
            var val = elt[rel](_);
            //console.log('VAL: '+ sys.inspect(val)) ;
            var collData = val.toArray(_, true);
            console.log("Collection length " + collData.length);
            if (collData.length) {
                console.log("Collection");
                resource[rel] = [];
                if (relation.isChild) {
                    console.log("Child relation");
                    collData.forEach_(_, function (_, elt) {
                        //console.log("PROPSEL: "+sys.inspect(propsel));
                        //console.log("reltype:"+reltype) ;
                        if (!val) console.log("val undefined") ;
                        console.log("on va serializer l'enfant"/*+ sys.inspect(val)*/) ;

                        //var serialized = objSerialize(_, val, propsel,  allItems,model);
                        console.log("SERIALIZE REFERENCE") ;
                        console.log("propselNames pour "+rel +' '+ sys.inspect(propselNames)) ;
                        var serialized = refSerialize(_, val._relMeta.targetEntity, elt, propselNames, allItems, model);
                        console.log("RELATION " + rel + " is serialized" + JSON.stringify(serialized, null, 2));
                        resource[rel].push(serialized);
                    });
                } else {
                    console.log("Not child:  ");
                    collData.forEach_(_, function (_, elt) {
                        // console.log("COLLDATA: "+ sys.inspect(elt));

                        if (keysel && keysel.length === 1) {

                            console.log("KEYSELECTION: " + keysel[0].name(_) + " : " + elt[keysel[0].name(_)](_));
                            resource[rel].push(elt[keysel[0].name(_)](_));
                            console.log("resource[" + rel + "]=" + elt[keysel[0].name(_)](_));
                        } else {
                            var it = {};
                            var proto = {};
                            keysel.forEach_(_, function (_, el) {
                                console.log("KEYSELECTION 2: " + el.name(_));
                                console.log("valuer: " + elt[el.name(_)](_));
                                it[el.name(_)] = elt[el.name(_)](_);
                            });
                            resource[rel].push(it);

                        }
                    });
                }
            }
        } else {
            console.log("Reference "+rel);
            var val = elt[rel](_);
            console.log("isCHILD: "+relation.isChild);
            //console.log("VAL:"+sys.inspect(val)) ;
            if (relation.isChild) {
                console.log("Child relation");
                resource[rel] = refSerialize(_, val._relMeta.targetEntity, elt, propselNames, allItems, model);
                console.log("RELATION " + rel + " is serialized" + JSON.stringify(serialized, null, 2));

            } else {
                console.log("Not child reference") ;
                if (keysel && keysel.length === 1) {
                    console.log("1 seule clé");
                    console.log("key: "+keysel[0].name(_)) ;
                    console.log("valeur: " +val[keysel[0].name(_)](_)) ;

                    resource[rel] = (val[keysel[0].name(_)](_)) ? val[keysel[0].name(_)](_) : null; //val[keysel[0].name(_)](_);
                } else if (keysel && keysel.length > 1) {
                    console.log("liste de clefs");
                    var it=resource[rel] = {};
                    keysel.forEach_(_, function (_, el) {
                        console.log("keysel: "+el.name(_)) ;
                         it[el.name(_)] = (val[el.name(_)](_))?val[el.name(_)](_):null;

                    });
                    //resource[rel].push(it);
                }
            }
        }
    });
    // console.log( "RESOURSE: " + JSON.stringify(resource,null,2)) ; 
    return resource;
}



function objSerialize(_, instance, propSelection,  allItems, model, type) {
    if (!instance) return null;
    var meta = instance._meta;
    var resource = {
       $type: type
    };
    
    tracer && tracer('props traversing');
    flows.eachKey(_, meta.$properties, //
    function (_, prop, property) {
        console.log("PROP:" + prop);

        if (propSelection.length > 0 && propSelection.indexOf(prop) == -1) {
            /*if property.$isMandatory -->addDiagnoses(warning, ) */
            return;
        }
        if (property.isExternalStorage() && !(instance[prop](_) && instance[prop](_).fileExists(_))) {
            tracer && tracer("property ExternalStorage:" + prop);
            return;
        }
        if (property.$isLazy || property.isExternalStorage()) {
            tracer && tracer("lazy property" + prop);
        } else if (property.$isLocalized) {
            resource[prop] = instance.getPropAllLocales(_, prop);
            tracer && tracer("localized property: " + JSON.stringify(resource[prop]));
        } else {
            resource[prop] = resourceHelpers.formatValue(property, instance[prop](_));
        }

    });

    tracer && tracer(' Relations traversing');
    flows.eachKey(_, meta.$relations, function (_, rel, relation) {
        console.log("REL: " + rel);
        if (propSelection.length > 0 && propSelection.indexOf(rel) == -1) {
            console.log("NOT selected");
            return;
        }
        var inv = relation.$inv && relation.targetEntity.$relations[relation.$inv];
        if (inv && inv.isChild) return;
        if (propSelection.length > 0 && propSelection.indexOf(rel) == -1) return;
        //console.log("RELATION: " + sys.inspect(relation /*instance[rel](_)*/ ));
        var name=relation.targetEntity.name ;
        var i;
        for (i = 0; i < allItems.length; i++) {
            console.log("allItems classname " + i + ' :' + allItems[i].className(_));
            if (allItems[i].className(_) === helpers.string.pluralize(name)) {
                console.log("allItems relation found"+allItems[i].className(_));
                var propselNames = [];
                var keyselNames =[] ;
                var keysel= allItems[i].entityKeyAttribute(_).toArray(_) ;
                keysel.forEach_(_, function (_, el) {
                keyselNames.push(el.name(_));
                propselNames.push(el.name(_));
            });
                allItems[i].entityAttribute(_).toArray(_).forEach_(_, function (_, el) {
                propselNames.push(el.name(_));
                });
                if (keysel.legth === 0) {
                    console.log("relation without key");
                    return;
                }
                break;
            }
        }
        if (!keysel || !keysel.length){
            console.log("relation shouldn't be exported") ;
            return ;
        }
   
        if (relation.isPlural) {
            console.log("plural ");
            var val = instance[rel](_) ;
            //var targ=val.targetEntity;
            var collData = val.toArray(_, true);
            console.log("Collection length " + collData.length);
            if (collData.length) {
                console.log("Collection");
                resource[rel] = [];
                if (relation.isChild) {
                    console.log("Child relation");
                    collData.forEach_(_, function (_, elt) {
                        var serialized = refSerialize(_, relation.targetEntity, elt, propselNames, allItems, model);
                        //console.log("RELATION "+rel+" is serialized"+ JSON.stringify(serialized,null,2)) ;
                        resource[rel].push(serialized);
                    });
                } else {
                    console.log("Not child");
                    collData.forEach_(_, function (_, elt) {
                        if (keysel && keysel.length === 1) {
                            //console.log("KEYSELECTION: " + keysel[0].name(_) + " : " + elt[keysel[0].name(_)](_));
                            resource[rel].push(elt[keysel[0].name(_)](_));
                            console.log("resource[" + rel + "]=" + elt[keysel[0].name(_)](_));
                        } else {
                            var it = {};
                            var proto = {};
                            keysel.forEach_(_, function (_, el) {
                                //console.log("KEYSELECTION 2: " + el.name(_));
                                console.log("value: " + elt[el.name(_)](_));
                                it[el.name(_)] = elt[el.name(_)](_);
                            });
                            resource[rel].push(it);
                        }
                    });
                }
        } else {
            console.log("Refrence " + rel);
            var val = instance[rel](_);
            if (relation.isChild) {
                console.log("Child relation");
                // console.log(sys.inspect(relation)) ;
                console.log("VAL: " + sys.inspect(val));
                console.log("RELATION: " + sys.inspect(relation));
                console.log("propselNames: " + JSON.stringify(propselNames, null, 2));

                var serialized = refSerialize(_, relation.targetEntity, val, propselNames, allItems, model);
                //console.log("RELATION "+rel+" is serialized"+ JSON.stringify(serialized,null,2)) ;
                resource[rel] = serialized;

                //resource[rel] = refSerialize(_, val,val, propselNames, allItems,model);
                //objSerialize(_, val, propselNames, relation.$type, allItems,model);
            } else if (keysel && keysel.legth === 1) resource[rel] = val[keysel[0].name(_)];
                else {
                    var it = resource[rel] = {};
                    keysel.forEach_(_, function (_, el) {
                        it[el.name(_)] = val[el.name(_)](_);

                    });
                    //resource[rel].push(it);
                }
            }
        }
    });

    //console.log( "RESOURSE: " + JSON.stringify(resource)) ; 
    return resource;
}
