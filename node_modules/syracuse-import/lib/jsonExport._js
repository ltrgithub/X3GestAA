var fs = require('fs');
var fsp = require("path");
var sys = require("util");
var helpers = require("syracuse-core/lib/helpers");
var flows = require("streamline/lib/util/flows");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var resourceHelpers = require("syracuse-core/lib/resource/util");
var locale = require("syracuse-core/lib/locale");

var _exportTargetsMap = {
	download: function(_, exportObj, options) {
		// TODO: need to reply the content, so override the default services execution behavior
	},
	file: function(_, exportObj, options) {
		if(!options.path)
			throw new Error(locale.format(module, "missingParameter", "path"));
	    fs.writeFile(fsp.join(__dirname, "../../../import", options.path + ".json"), JSON.stringify(exportObj));
	},
	db_file: function(_, exportObj, options) {
		// TODO: doc save diagnoses
		if(!options.storageDescription || !options.storageVolume)
			throw new Error(locale.format(module, "missingParameter", "storageDescription, storageVolume"));
		var db = adminHelper.getCollaborationOrm(_);
		var doc = db.getEntity(_, "document").createInstance(_, db);
		var vol = db.fetchInstance(_, db.getEntity(_, "document"), options.storageVolume);
		doc.description(_, options.storageDescription);
		doc.volume(_, vol);
		var s = doc.content(_).createWritableStream(_);
		s.write(_, JSON.stringify(exportObj));
		s.write(_, null);
		doc.save(_);
	},
	server: function(_, exportObj, options) {
		if(!options.friendServer)
			throw new Error(locale.format(module, "missingParameter", "friendServer"));
		var db = adminHelper.getCollaborationOrm(_);
		var server = db.fetchInstance(_, db.getEntity(_, "friendServer"), options.friendServer);
		if(!server) return;
		var s = server.createWritableStream(_, "$import");
		s.write(_, JSON.stringify(exportObj));
		s.write(_, null);
	}
}


exports.jsonExport = function (_, instance, options) {
    if (!instance) {
        console.log("Export Profile is null") ;
        return ;
    }
    console.log("EXPORTING.........") ;
     //console.log("INSTANCE ep: " + sys.inspect(instance.endpoint(_))) ;
    var opt = options || {};
    console.log("INSTANCE ep: " + sys.inspect(instance.endpoint(_))) ;
    var db = instance.endpoint(_).getOrm(_);
    var model = db.model;
   
    var items = instance.exportProfileItem(_).toArray(_);
    var exportObj = {
        $prototypes: {},
        $items: []
    };
     console.log("ITEMS") ;
    items.forEach_(_, function (_, item, idx) {
        console.log("PROFILE ITEM: " + item.className(_));
        //console.log(sys.inspect(item)) ;
        var allItems = this;

        var propSelection = [];
        item.entityAttribute(_).toArray(_).forEach_(_, function (_, el) {
            propSelection.push(el.name(_));
        });

        var keys = [];
        item.entityKeyAttribute(_).toArray(_).forEach_(_, function (_, el) {
            keys.push(el.name(_));
            propSelection.push(el.name(_)) ;
        });

        var profileIt = model.singularize(item.className(_));
        var proto = {};
        if (keys && keys.length === 1) proto["$key"] = keys[0];
        else if (keys && keys.length > 1) proto["$key"] = keys;

        var entity = model.getEntity(_, profileIt);
        serializeRelProto(_,entity, proto, propSelection,allItems,model);

        exportObj.$prototypes[profileIt] = proto;

        var exportedObjs = item.exportedObjects(_).toArray(_);
        console.log ("CLASS of the exported object :"+ profileIt) ;

        exportedObjs.forEach_(_, function (_, ob, idx) {
            console.log("exportedObject OB uuid: "+ ob.$uuid) ; 
            var inst = db.fetchInstance(_, entity, ob.$uuid);
            var exportItem = {};
            console.log("RECORD " + idx);
            //console.log("exportedObject: "+ sys.inspect(inst)) ; 
            exportItem = objSerialize(_, inst, propSelection, allItems, model, model.singularize(item.className(_)));
            exportObj.$items.push(exportItem);
        });

    });

    console.log("TOEXPORT: " + JSON.stringify(exportObj, null, 2));

    _exportTargetsMap[opt.targetType || "download"](_, exportObj, opt);
}

function serializeRelProto(_,entity, proto, selection,allItems,model) {
    flows.eachKey(_, entity.$relations, function (_, rel, relation) {
        if (/*!relation.$isMandatory &&*/ selection.length >0 && selection.indexOf(rel) == -1)
            return ;
        console.log("rel: " + rel);
        //console.log("RELATION: " + sys.inspect(relation /*instance[rel](_)*/ ));
        var j;
        for (j = 0; j < allItems.length; j++) {
            //console.log("allItems : " + j + 'clnam : ' + allItems[j].className(_));
            //console.log("targetEntityname:  " + helpers.string.pluralize(relation.targetEntity.name));
            if (allItems[j].className(_) === helpers.string.pluralize(relation.targetEntity.name)) {
                //relation.targetEntity.type ???
                console.log("allItems relation found "+allItems[j].className(_));
                var relkeys = allItems[j].entityKeyAttribute(_).toArray(_);
                var relkeynames = [];
                relkeys.forEach_(_, function (_, k, idx) {

                    relkeynames.push(k.name(_));
                });
                break;
            }
        }

      
        if (relkeynames && relkeynames.length === 1) proto[rel] = {
            $key: relkeynames[0]
        };
        else if (relkeynames && relkeynames.length > 1) proto[rel] = {
            $key: relkeynames
        };

        if (relation.isChild) {
            console.log("Child relation");
            var entityRel = model.getEntity(_, relation.targetEntity.name/*model.singularize(relation.targetEntity.type)*/);
            //console.log("THE CHILD RELATION ENTITY: " + sys.inspect(entityRel));
            serializeRelProto(_,entityRel, proto[rel], selection,allItems,model) ;
            
        }

    });
}


function refSerialize(_, instance,elt ,propSelection,  allItems, model, type) {
    var resource={} ;
console.log("serializing reference ");
//console.log("propSelection: "+JSON.stringify(propSelection)) ;
    if (!instance) {
        console.log("instance is null") ;
        return null;
    }

    //console.log("obj serialize propSelection " + sys.inspect(propSelection));
    //console.log("obj serialize propSelection " + sys.inspect(instance));

    flows.eachKey(_, instance._relMeta.targetEntity.$properties, function (_, prop, property) {
        console.log("PROP:" + prop);
        if (/*!property.$isMandatory &&*/ propSelection.length > 0 && propSelection.indexOf(prop) == -1) {
            console.log("prop not exportable") ;
            return;
        }
        //if (property.isExternalStorage() && !(instance[prop](_) && instance[prop](_).fileExists(_))) {
            if (property.isExternalStorage() && !(elt[prop](_) && elt[prop](_).fileExists(_))) {
            console.log("PROP ExternalStorage:" + prop);
            return;
        }

        if (property.$isLazy || property.isExternalStorage()) {

            console.log("PROP lazy:" + prop);
        } else {
            console.log("PROP simple:" + prop);
            resource[prop] = resourceHelpers.formatValue(property, elt[prop](_));
        }
    });

    console.log("maintenant les relations de la relation") ;
    flows.eachKey(_, instance._relMeta.targetEntity.$relations, function (_, rel, relation) {
        //console.log("dd:" +rel) ;
        console.log("RELATION de relation : "+rel) ;
        //console.log("dd: "+sys.inspect(relation));
        //console.log("coucou");
        //console.log("sss "+relation.$inv) ;
        var inv = relation.$inv && relation.targetEntity.$relations[relation.$inv];
        if (inv && inv.isChild) {
              console.log(" inv child rel ");
            return;
        }
        if (propSelection.length > 0 && propSelection.indexOf(rel) == -1) {
            console.log("rel not exportable");
            return;
        }
        console.log("on va chercher sa clé et ses attributs");
        //console.log("RELATION "+rel+' : ' + sys.inspect(relation  ));
        //console.log(allItems) ;
        //console.log("len="+allItems.length)  ;
        var i;
        for (i = 0; i < allItems.length; i++) {
            
           // console.log("allItems classname " + i + ' :' + allItems[i].className(_));
            if (allItems[i].className(_) === helpers.string.pluralize(relation.targetEntity.name)) {
                console.log("allItems relation found");
                var propselNames = [];
                var keysel = allItems[i].entityKeyAttribute(_).toArray(_);
                 allItems[i].entityAttribute(_).toArray(_).forEach_(_, function (_, el) {
            propselNames.push(el.name(_));
        });

       
                //var reltype = allItems[i].className(_);
                if (keysel.legth === 0) {
                    console.log("relation without key");
                    return;
                }
                break;
            }
        }
        if (keysel && keysel.length) {
            console.log("relation should be exported") ;
        }else {console.log("relation shouldn't be exported");
        console.log(' '+rel+keysel) ;
        return ;
        }
       
        if (relation.isPlural) {
            console.log("plural ");
            var val = elt[rel](_);
            //console.log('VAL: '+ sys.inspect(val)) ;
            var collData = val.toArray(_, true);
            if (collData.length) {
                console.log("Collection");
                resource[rel] = [];
                if (relation.isChild) {
                    console.log("Child relation");
                    collData.forEach_(_, function (_, elt) {
                        //console.log("PROPSEL: "+sys.inspect(propsel));
                        //console.log("reltype:"+reltype) ;
                        if (!val) console.log("val undefined") ;
                        console.log("on va serializer l'enfant"/*+ sys.inspect(val)*/) ;

                        //var serialized = objSerialize(_, val, propsel,  allItems,model);
                        console.log("SERIALIZE REFERENCE") ;
                        var serialized =refSerialize(_,val ,elt, propselNames, allItems,model);
                        resource[rel].push(serialized);
                    });
                } else {
                    console.log("Not child:  ");
                    collData.forEach_(_, function (_, elt) {
                        // console.log("COLLDATA: "+ sys.inspect(elt));

                        if (keysel && keysel.length === 1) {

                            console.log("KEYSELECTION: " + keysel[0].name(_) + " : " + elt[keysel[0].name(_)](_));
                            resource[rel].push(elt[keysel[0].name(_)](_));
                            console.log("resource[" + rel + "]=" + elt[keysel[0].name(_)](_));
                        } else {
                            var it = {};
                            var proto = {};
                            keysel.forEach_(_, function (_, el) {
                                console.log("KEYSELECTION 2: " + el.name(_));
                                console.log("valuer: " + elt[el.name(_)](_));
                                it[el.name(_)] = elt[el.name(_)](_);
                            });
                            resource[rel].push(it);

                        }
                    });
                }
            }
        } else {
            console.log("Reference "+rel);
            var val = elt[rel](_);
            console.log("isCHILD: "+relation.isChild);
            //console.log("VAL:"+sys.inspect(val)) ;
            if (relation.isChild) {
                console.log("Child relation");
                resource[rel] = refSerialize(_, val, elt, propselNames,  allItems,model);
            } else {
                console.log("Not child reference") ;
                if (keysel && keysel.length === 1) {
                    console.log("1 seule clé");
                    console.log("key: "+keysel[0].name(_)) ;
                    console.log("valeur: " +val[keysel[0].name(_)](_)) ;

                    resource[rel] = (val[keysel[0].name(_)](_))?val[keysel[0].name(_)](_):null ;"portlettest" ;//val[keysel[0].name(_)](_);
                }
                else if (keysel && keysel.length > 1){
                    console.log("liste de clefs");
                    var it=resource[rel] = {};
                    keysel.forEach_(_, function (_, el) {
                        console.log("keysel: "+el.name(_)) ;
                         it[el.name(_)] = (val[el.name(_)](_))?val[el.name(_)](_):null;

                    });
                    //resource[rel].push(it);
                }
            }
        }
    });
    console.log("return resource") ;
    //console.log( "RESOURSE: " + JSON.stringify(resource)) ; 
    return resource;
}



function objSerialize(_, instance, propSelection,  allItems, model, type) {

    if (!instance) return null;

    //console.log("obj serialize propSelection " + sys.inspect(propSelection));
    //console.log("OBJSERIALIZE "+sys.inspect(instance)) ;

    var meta = instance._meta;
    var resource = {
       $type: type
    };
    
    console.log('parcours des props') ;
    flows.eachKey(_, meta.$properties, function (_, prop, property) {
        console.log("PROP:" + prop);
        if (/*!property.$isMandatory &&*/ propSelection.length > 0 && propSelection.indexOf(prop) == -1) return;
        if (property.isExternalStorage() && !(instance[prop](_) && instance[prop](_).fileExists(_))) {
            console.log("PROP ExternalStorage:" + prop);
            return;
        }

        if (property.$isLazy || property.isExternalStorage()) {

            console.log("PROP lazy:" + prop);
        } else {
            console.log("PROP simple:" + prop);
            resource[prop] = resourceHelpers.formatValue(property, instance[prop](_));
        }
    });

    console.log('parcours des RELATIONS') ;
    flows.eachKey(_, meta.$relations, function (_, rel, relation) {
        if (propSelection.length > 0 && propSelection.indexOf(rel) == -1) return;
        var inv = relation.$inv && relation.targetEntity.$relations[relation.$inv];
        console.log("inv ok") ;
        if (inv && inv.isChild) {
            console.log("inv && inv.isChild") ;
            return;
        }
        if (propSelection.length > 0 && propSelection.indexOf(rel) == -1) 
            {
                console.log("rel not in propSelection") ;
                return;
            }

        //console.log("RELATION: " + sys.inspect(relation /*instance[rel](_)*/ ));

        var i;
        for (i = 0; i < allItems.length; i++) {
            console.log("allItems classname " + i + ' :' + allItems[i].className(_));
            if (allItems[i].className(_) === helpers.string.pluralize(relation.targetEntity.name)) {
                console.log("allItems relation found"+allItems[i].className(_));
                var propselNames = [];
                var keyselNames =[] ;
                var keysel= allItems[i].entityKeyAttribute(_).toArray(_) ;
                keysel.forEach_(_, function (_, el) {
                keyselNames.push(el.name(_));
                propselNames.push(el.name(_));
            });
                allItems[i].entityAttribute(_).toArray(_).forEach_(_, function (_, el) {
                propselNames.push(el.name(_));
                });
                //var reltype = allItems[i].className(_);
                if (keysel.legth === 0) {
                    console.log("relation without key");
                    return;
                }
                break;
            }
        }
        if (!keysel || !keysel.length){
            console.log("relation shouldn't be exported") ;
            return ;

        }


        
        if (relation.isPlural) {
            console.log("plural ");
            var val = instance[rel](_) ;
            //var targ=val.targetEntity;
            var collData = val.toArray(_, true);
            if (collData.length) {
                console.log("Collection");
                resource[rel] = [];
                if (relation.isChild) {
                    console.log("Child relation");
                    collData.forEach_(_, function (_, elt) {
                        //console.log("PROPSEL: "+sys.inspect(propsel));
                        //console.log("reltype:"+reltype) ;
                        //if (!val) console.log("val undefined") ;
                       //console.log("on va serializer l'enfant"+ sys.inspect(elt)) ;

                        //var serialized = objSerialize(_, val, propsel, /*reltype,*/ allItems,model);
                        //console.log("propSelection: "+JSON.stringify(propsel)) ;
                        var serialized =refSerialize(_, val,elt, propselNames, allItems,model);
                        console.log("ref serialize" ) ;
                        resource[rel].push(serialized);
                    });
                } else {
                    console.log("Not child:  ");
                    collData.forEach_(_, function (_, elt) {
                        // console.log("COLLDATA: "+ sys.inspect(elt));

                        if (keysel && keysel.length === 1) {

                            console.log("KEYSELECTION: " + keysel[0].name(_) + " : " + elt[keysel[0].name(_)](_));
                            resource[rel].push(elt[keysel[0].name(_)](_));
                            console.log("resource[" + rel + "]=" + elt[keysel[0].name(_)](_));
                        } else {
                            var it = {};
                            var proto = {};
                            keysel.forEach_(_, function (_, el) {
                                console.log("KEYSELECTION 2: " + el.name(_));
                                console.log("valuer: " + elt[el.name(_)](_));
                                it[el.name(_)] = elt[el.name(_)](_);
                            });
                            resource[rel].push(it);

                        }
                    });
                }
            }
        } else {
            console.log("Refrence");
            var val = instance[rel](_);
            if (relation.isChild) {
                console.log("Child relation");
                resource[rel] = objSerialize(_, val, val ,propsel, reltype, allItems,model);
            } else {
                if (keysel && keysel.legth === 1) resource[rel] = val[keysel[0].name(_)];
                else {
                    var it = resource[rel] = {};
                    keysel.forEach_(_, function (_, el) {
                        it[el.name(_)] = val[el.name(_)](_);

                    });
                    //resource[rel].push(it);
                }
            }
        }
    });

    //console.log( "RESOURSE: " + JSON.stringify(resource)) ; 
    return resource;
}
