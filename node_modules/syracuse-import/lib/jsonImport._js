"use strict";

var fs = require('fs');
var fsp = require("path");
var flows = require("streamline/lib/util/flows");
var helpers = require("syracuse-core/lib/helpers");
var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var resourceHelpers = require("syracuse-core/lib/resource/util");
var locale = require("syracuse-core/lib/locale");
var sys = require("util");

var tracer = null;
//var tracer = console.log;

function _getFilter(_, db, key, value, entity, proto) {
	tracer && tracer("jsonImport._getFilter for "+sys.inspect(key)+"="+sys.inspect(value)+"; entity: "+(entity && entity.name));
	var filter = {jsonWhere:{}};
	if(Array.isArray(key)) {
		// value should be object !!!
		if(typeof value != "object")
			throw new Error("Internal error: type of value should be object (key: '"+key+"'; value: '"+value+"')");
		key.forEach_(_, function(_, item) {
			if(Array.isArray(value[item])) {
				filter.jsonWhere[item] = value[item].map_(_, function(_, mapItem) {
					// lookup for the array values
					if(proto && proto[item] && proto[item].$key && entity && entity.$relations && entity.$relations[item] && entity.$relations[item].isPlural) {
						var mapFilter = {jsonWhere:{}};
						mapFilter.jsonWhere[proto[item].$key] = mapItem;
						return (db.fetchInstance(_, entity.$relations[item].targetEntity, mapFilter) || {}).$uuid;
					} else
						return mapItem;
				});
			} else
				filter.jsonWhere[item] = value[item];
		});
	} else
		if(typeof value == "object") {
			var simpleKey = key.split(".")[0];
			if(entity.$properties && entity.$properties[simpleKey] && entity.$properties[simpleKey].$isLocalized && (typeof value[simpleKey] == "object")) {
				// take the first value as default
				var parts = key.split(".");
				if(parts.length < 2)
					throw Error("Format error: localized type but one part key: "+entity.name+"."+key);
				filter.jsonWhere[key] = value[parts[0]][parts[1]];
			} else
				filter.jsonWhere[key] = value[simpleKey];
		} else
			filter.jsonWhere[key] = value;
	tracer && tracer("jsonImport get filter: "+sys.inspect(filter,null,4));
	return filter;
}
//
function _importCollection(_, inst, relName, relMeta, relProto, value) {
	var coll = inst[relName](_);
	var relKey = (relProto || {}).$key || "description";
	var db = inst._db;
	// TODO : delta algorithm to remove items
	if(Array.isArray(value))
		value.forEach_(_, function(_, relItemValue) {
			var relInst;
			if(relMeta.isChild) {
				// childrens
				var opt = {jsonWhere:{}};
				// create a filter from the relations key. If the key is composed from relations, found those relations meta to compose the filter
				var relKeys = Array.isArray(relKey) ? relKey.slice(0) : [relKey];
//				if(Array.isArray(relKey)) {
					relKeys.forEach(function(relKeyItem) { 
						var fullRelKey = (relProto[relKeyItem] ? relKeyItem + "." + relProto[relKeyItem].$key : relKeyItem);
						opt.jsonWhere[fullRelKey] = relItemValue[relKeyItem];
					});
//				}
				tracer && tracer("jsonImport._importCollection "+relMeta.name+" generate filter: "+sys.inspect(opt.jsonWhere, null, 4));
				relInst = coll.filter(_, opt)[0];
				if(!relInst) {
					tracer && tracer("jsonImport._importCollection not found, creating child");
					relInst = inst.createChild(_, relName);
					coll.set(_, relInst);
				}
				// import
				_importInstance(_, relInst, relItemValue, relProto);
			} else {
				//references
				relInst = db.fetchInstance(_, relMeta.targetEntity, _getFilter(_, db, relKey, relItemValue, relMeta.targetEntity, relProto));
				if(relInst && !coll.get(_, relInst.$uuid))
					coll.set(_, relInst);
			}
		});
}

function _importInstance(_, instance, data, itemProto) {
	tracer && tracer("jsonImport._importInstance enter: "+instance.$uuid+"; data="+sys.inspect(data));
	if(data && (typeof data !== "object"))
		throw new Error(locale.format(module, "objectExpected", data));
	var entity = instance._meta;
	var inst = instance;
	var db = instance._db;
	flows.eachKey(_, data, function(_, key, value) {
		// do we need to import $ properties ? see later
		if(key[0] === "$")
			return;
		var relMeta, propMeta;
		if(entity.$relations && (relMeta = entity.$relations[key])) {
			// lookup
			var relKey = (itemProto && itemProto[key] || {}).$key || "description";
			if(relMeta.isPlural) {
				_importCollection(_, inst, key, relMeta, itemProto[key], value);
			} else {
				if(relMeta.isChild || relMeta.$inlineStore) {
					var relInst = inst[key](_);
					if(!relInst) {
						relInst = inst.createChild(_, key);
						_importInstance(_, relInst, value, itemProto[key]);
						inst[key](_, relInst);
					} else
						_importInstance(_, relInst, value, itemProto[key]);
				} else {
					var filter = _getFilter(_, db, relKey, value, relMeta.targetEntity, itemProto);
					// is filter empty (should get null object) ?
					var isNull = Object.keys(filter.jsonWhere).every(function(k) {
						return (filter.jsonWhere[k] == null) && (filter.jsonWhere[k] == "");
					});
					var relInst = null;
					if(!isNull) {
						relInst = db.fetchInstance(_, relMeta.targetEntity, filter);
						if(!relInst)
							inst.$addDiagnose("warning", locale.format(module, "referenceMissing", inst._meta.name, relMeta.name, 
											relMeta.targetEntity.name, JSON.stringify(filter.jsonWhere || {})));
					}
					inst[key](_, relInst);
				}
			}
		} else
			if(entity.$properties && (propMeta = entity.$properties[key])) {
				inst[key](_, resourceHelpers.parseValue(propMeta, value));
			}
	});
	tracer && tracer("jsonImport._importInstance exit: "+instance.$uuid+"; exit data="+sys.inspect(instance._data));
}

function _addToSession(_, session, sessionTypesMap, instance, destination) {
	if(!session) return;
	if(!destination) return;
	if(!instance) return;
	//
	var eName = instance.getEntity().name;
	var st = sessionTypesMap[eName];
	if(!st) {
		st = session.importTypes(_).add(_);
		st.entityName(_, eName);
		sessionTypesMap[eName] = st;
	}
	st[destination](_).set(_, instance); 
}

function _import(_, db, proto, data, options){
	var importMode = options.importMode || "insert";
	//
	var model = db.model;
	// 
	var creCount = 0;
	var updCount = 0;
	var session = null;
	var sessionTypes = {};
	try {
		if(options.createSession) {
			var admDb = adminHelper.getCollaborationOrm(_);
			var e = admDb.getEntity(_, "importSession");
			session = e.factory.createInstance(_, null, admDb);
			session.description(_, options.sessionDescription || locale.format(module, "genericSessionLabel"));
		}
		data.forEach_(_, function(_, item) {
			tracer && tracer("jsonImport importing item :"+sys.inspect(item));
			// get 
			var entity = model.getEntity(item.$type);
			if(!entity) return;
			var itemProto = proto[item.$type] || {};
			tracer && tracer("jsonImport importing itemProto :"+sys.inspect(itemProto));
			var key = itemProto.$key || "description";
			var inst = db.fetchInstance(_, entity, _getFilter(_, db, key, item, entity, itemProto));
			if(inst && (importMode === "insert")) return;
			//
			var created = false;
			if(!inst) {
				// create
				inst = entity.factory.createInstance(_, null, db);
				created = true;
			}
			// update data
			_importInstance(_, inst, item, itemProto);
			//
			inst.save(_);
			//
			var hasErrors = false;
			var diags = [];
			inst.getAllDiagnoses(_, diags, { addPropName: true, addEntityName: true });
			diags.forEach_(_, function(_, d) {
				options && options.$diagnoses && options.$diagnoses.push(d);
				if(session && (d.severity === "error")) {
					hasErrors = true;
					if(!session.errorDiags(_))
						session.errorDiags(_, []);
					session.errorDiags(_).push(d.message);
				}
				if(session && (d.severity === "warning")) {
					if(!session.warnDiags(_))
						session.warnDiags(_, []);
					session.warnDiags(_).push(d.message);
				}
			});
			//
			if(!created || !hasErrors) {
				if(created) creCount++;
				else updCount++;
				_addToSession(_, session, sessionTypes, inst, created ? "createdObjects" : "updatedObjects");
			} 
			if(options && options.$diagnoses) {
				tracer && tracer("jsonImport importing item diagnoses: "+item.$type+"; "+sys.inspect(options.$diagnoses));
			} 
		});
		options && options.$diagnoses && options.$diagnoses.push({
			severity: "info",
			message: locale.format(module, "importDone", creCount, updCount)
		});
		//
		session && session.save(_);
	} catch(e) {
		// log error
		if(session) {
			if(!session.errorDiags(_))
				session.errorDiags(_, []);
			session.errorDiags(_).push(e.message);
			session.save(_);
		}
		throw e;
	}
	//
	return session;
}

exports.jsonImport = function(_, db, filename, options) {
	//
	options = options || {};
	tracer = tracer || options.tracer || (require("syracuse-main/lib/nodeconfig").config.import || {}).tracer;

	// filename is supposed to be located in "import" folder (same level as node_modules)
	var input = JSON.parse(fs.readFile(fsp.join(__dirname, "../../../import",filename), "utf8", _));
	var proto = input.$prototypes || {};
	var data = input.$items || [];
	// includes (only after, TODO before)
	if(input.$includeAfter) {
		input.$includeAfter.forEach_(_, function(_, includeFile) {
			var include = JSON.parse(fs.readFile(fsp.join(__dirname, "../../../import",includeFile+".json"), "utf8", _));
			if(include.$prototypes) 
				for(var p in include.$prototypes) proto[p] = include.$prototypes[p];
			(include.$items || []).forEach(function(item) { data.push(item); });
		});
	}

	//
	_import(_, db, proto, data, options);
}

exports.streamImport = function(_, db, stream, options) {
	//
	options = options || {};
	tracer = tracer || options.tracer || (require("syracuse-main/lib/nodeconfig").config.import || {}).tracer;
	options.$diagnoses = options.$diagnoses || [];

	// filename is supposed to be located in "import" folder (same level as node_modules)
	var input = JSON.parse(stream.readAll(_));
	var proto = input.$prototypes || {};
	var data = input.$items || [];
	//
	var s = _import(_, db, proto, data, options);
	//
	return {
		$url: s && "{$baseUrl}/importSessions('" + s.$uuid + "')?representation=importSession.$details",
		$uuid: s && s.$uuid,
		$diagnoses: options.$diagnoses
	}
}

exports.jsonImportFromJson = function(_, user, input, options) {
	tracer = tracer || options.tracer || (require("syracuse-main/lib/nodeconfig").config.import || {}).tracer;
	try{
		input = typeof input === "object" ? input : JSON.parse(input);
		var db = adminHelper.getCollaborationOrm(_);
		options.$diagnoses = options.$diagnoses || [];
		_import(_, db, input.$prototypes, input.$items, options);
		return options.$diagnoses;
	}catch(e){
		console.error(e.stack);
		throw e;
	}	
}

exports.$exported = true;
