"use strict";

var fs = require('fs');
var fsp = require("path");
var flows = require("streamline/lib/util/flows");
var helpers = require("syracuse-core/lib/helpers");
var resourceHelpers = require("syracuse-core/lib/resource/util");
var locale = require("syracuse-core/lib/locale");
var sys = require("util");

var tracer = null;
//var tracer = console.log;

function _getFilter(_, db, key, value, entity, proto) {
	tracer && tracer("jsonImport._getFilter for "+sys.inspect(key)+"="+sys.inspect(value)+"; entity: "+(entity && entity.name));
	var filter = {jsonWhere:{}};
	if(Array.isArray(key)) {
		// value should be object !!!
		if(typeof value != "object")
			throw new Error("Internal error: type of value should be object (key: '"+key+"'; value: '"+value+"')");
		key.forEach_(_, function(_, item) {
			if(Array.isArray(value[item])) {
				filter.jsonWhere[item] = value[item].map_(_, function(_, mapItem) {
					// lookup for the array values
					if(proto && proto[item] && proto[item].$key && entity && entity.$relations && entity.$relations[item] && entity.$relations[item].isPlural) {
						var mapFilter = {jsonWhere:{}};
						mapFilter.jsonWhere[proto[item].$key] = mapItem;
						return (db.fetchInstance(_, entity.$relations[item].targetEntity, mapFilter) || {}).$uuid;
					} else
						return mapItem;
				});
			} else
				filter.jsonWhere[item] = value[item];
		});
	} else
		if(typeof value == "object") {
			var simpleKey = key.split(".")[0];
			if(entity.$properties && entity.$properties[simpleKey] && entity.$properties[simpleKey].$isLocalized && (typeof value[simpleKey] == "object")) {
				// take the first value as default
				var parts = key.split(".");
				if(parts.length < 2)
					throw Error("Format error: localized type but one part key: "+entity.name+"."+key);
				filter.jsonWhere[key] = value[parts[0]][parts[1]];
			} else
				filter.jsonWhere[key] = value[simpleKey];
		} else
			filter.jsonWhere[key] = value;
	tracer && tracer("jsonImport get filter: "+sys.inspect(filter,null,4));
	return filter;
}
//
function _importCollection(_, inst, relName, relMeta, relProto, value) {
	var coll = inst[relName](_);
	var relKey = (relProto || {}).$key || "description";
	var db = inst._db;
	// TODO : delta algorithm to remove items
	if(Array.isArray(value))
		value.forEach_(_, function(_, relItemValue) {
			var relInst;
			if(relMeta.isChild) {
				// childrens
				var opt = {jsonWhere:{}};
				// create a filter from the relations key. If the key is composed from relations, found those relations meta to compose the filter
				var relKeys = Array.isArray(relKey) ? relKey.slice(0) : [relKey];
//				if(Array.isArray(relKey)) {
					relKeys.forEach(function(relKeyItem) { 
						var fullRelKey = (relProto[relKeyItem] ? relKeyItem + "." + relProto[relKeyItem].$key : relKeyItem);
						opt.jsonWhere[fullRelKey] = relItemValue[relKeyItem];
					});
//				}
				tracer && tracer("jsonImport._importCollection generate filter: "+sys.inspect(opt.jsonWhere, null, 4));
				relInst = coll.filter(_, opt)[0];
				if(!relInst) {
					tracer && tracer("jsonImport._importCollection not found, creating child");
					relInst = inst.createChild(_, relName);
					coll.set(_, relInst);
				}
				// import
				_importInstance(_, relInst, relItemValue, relProto);
			} else {
				//references
				relInst = db.fetchInstance(_, relMeta.targetEntity, _getFilter(_, db, relKey, relItemValue, relMeta.targetEntity, relProto));
				if(relInst && !coll.get(_, relInst.$uuid))
					coll.set(_, relInst);
			}
		});
}

function _importInstance(_, instance, data, itemProto) {
	tracer && tracer("jsonImport._importInstance enter: "+instance.$uuid);
	if(data && (typeof data !== "object"))
		throw new Error(locale.format(module, "objectExpected", data));
	var entity = instance._meta;
	var inst = instance;
	var db = instance._db;
	flows.eachKey(_, data, function(_, key, value) {
		// do we need to import $ properties ? see later
		if(key[0] === "$")
			return;
		var relMeta, propMeta;
		if(entity.$relations && (relMeta = entity.$relations[key])) {
			// lookup
			var relKey = (itemProto[key] || {}).$key || "description";
			if(relMeta.isPlural) {
				_importCollection(_, inst, key, relMeta, itemProto[key], value);
			} else {
				var filter = _getFilter(_, db, relKey, value, relMeta.targetEntity, itemProto);
				// is filter empty (should get null object) ?
				var isNull = Object.keys(filter.jsonWhere).every(function(k) {
					return (filter.jsonWhere[k] == null) && (filter.jsonWhere[k] == "");
				});
				var relInst = null;
				if(!isNull) {
					relInst = db.fetchInstance(_, relMeta.targetEntity, filter);
					if(!relInst)
						inst.$addDiagnose("warning", locale.format(module, "referenceMissing", inst._meta.name, relMeta.name, 
										relMeta.targetEntity.name, JSON.stringify(filter.jsonWhere || {})));
				}
				inst[key](_, relInst);
			}
		} else
			if(entity.$properties && (propMeta = entity.$properties[key])) {
				inst[key](_, resourceHelpers.parseValue(propMeta, value));
			}
	});
}

exports.jsonImport = function(_, db, filename, options) {
	//
	options = options || {};
	tracer = tracer || options.tracer || (require("syracuse-main/lib/nodeconfig").config.import || {}).tracer;
	var importMode = options.importMode || "insert";
	// filename is supposed to be located in "import" folder (same level as node_modules)
	var input = JSON.parse(fs.readFile(fsp.join(__dirname, "../../../import",filename), "utf8", _));
	var proto = input.$prototypes || {};
	var data = input.$items || [];
	// includes (only after, TODO before)
	if(input.$includeAfter) {
		input.$includeAfter.forEach_(_, function(_, includeFile) {
			var include = JSON.parse(fs.readFile(fsp.join(__dirname, "../../../import",includeFile+".json"), "utf8", _));
			if(include.$prototypes) 
				for(var p in include.$prototypes) proto[p] = include.$prototypes[p];
			(include.$items || []).forEach(function(item) { data.push(item); });
		});
	}
	//
	var model = db.model;
	//
	data.forEach_(_, function(_, item) {
		tracer && tracer("jsonImport importing item :"+sys.inspect(item));
		// get 
		var entity = model.getEntity(item.$type);
		if(!entity) return;
		var itemProto = proto[item.$type] || {};
		tracer && tracer("jsonImport importing itemProto :"+sys.inspect(itemProto));
		var key = itemProto.$key || "description";
		var inst = db.fetchInstance(_, entity, _getFilter(_, db, key, item, entity, itemProto));
		if(inst && (importMode === "insert")) return;
		//
		if(!inst) {
			// create
			inst = entity.factory.createInstance(_, null, db);
//			inst._initialize(_);
		}
		// update data
		_importInstance(_, inst, item, itemProto);
		//
		inst.save(_);
		//
		options && options.$diagnoses && inst.getAllDiagnoses(_, options.$diagnoses, { addPropName: true, addEntityName: true });
		//
		options && options.$diagnoses && tracer && tracer("jsonImport importing item diagnoses: "+item.$type+"; "+sys.inspect(options.$diagnoses));
	});
}