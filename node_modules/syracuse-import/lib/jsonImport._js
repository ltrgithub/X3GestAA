"use strict";

var fs = require('streamline-fs');
var fsp = require("path");
var crypto = require("crypto");
var config = require('config');
var flows = require('streamline-runtime').flows;
var helpers = require('syracuse-core').helpers;
var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var resourceHelpers = require('syracuse-core').resource.util;
var locale = require('streamline-locale');
var sys = require("util");
var tracer = require('syracuse-core').getTracer("imports");

function _normalizeDiag(diag) {
	return {
		$severity: diag.$severity || diag.severity,
		$message: diag.$message || diag.message,
		$stackTrace: diag.$stackTrace || diag.stackTrace
	};
}

function _trace(diags, prefix) {
	diags && diags.forEach(function(d, i) {
		var msg = (prefix || "") + "diagnose [" + i + "] : " + d.$message;
		switch (d.$severity) {
			case "error":
				tracer.error && tracer.error(msg, d.$stackTrace);
				break;
			case "warning":
				tracer.warn && tracer.warn(msg);
				break;
			default:
				tracer.info && tracer.info(msg);
				break;
		}
	});
}

// proto is prototype of the object proprietary of the instance, not relation's proto

function _getFilter(_, db, key, value, entity, proto, localization) {
	tracer.debug && tracer.debug("jsonImport._getFilter for " + sys.inspect(key) + "=" + sys.inspect(value) + "; entity: " + (entity && entity.name));
	var filter = {
		jsonWhere: {}
	};
	var parts;
	if (Array.isArray(key)) {
		// value should be object !!!
		if (typeof value != "object") throw new Error("Internal error: type of value should be object (key: '" + key + "'; value: '" + value + "')");
		key.forEach_(_, function(_, item) {
			if (Array.isArray(value[item])) {
				filter.jsonWhere[item] = value[item].map_(_, function(_, mapItem) {
					// lookup for the array values
					if (proto && proto[item] && proto[item].$key && entity && entity.$relations && entity.$relations[item] && entity.$relations[item].isPlural) {
						var mapFilter = {
							jsonWhere: {}
						};
						mapFilter.jsonWhere[proto[item].$key] = mapItem;
						return (db.fetchInstance(_, entity.$relations[item].targetEntity, mapFilter) || {}).$uuid;
					} else {
						return mapItem;
					}
				});
			} else {
				filter.jsonWhere[item] = value[item];
			}
		});
	} else if (typeof value == "object") {
		var simpleKey = key.split(".")[0];

		if (entity.$properties && entity.$properties[simpleKey] && entity.$properties[simpleKey].$isLocalized && //
			typeof value[simpleKey] == "string" && proto.$localized && (proto.$localized.indexOf(simpleKey) >= 0)) {
			// take the first value as default
			parts = key.split(".");
			if (parts.length < 2) throw new Error(locale.format(module, "formatError", entity.name, key));
			//throw Error("Format error: localized type but one part key: " + entity.name + "." + key);
			var loclang = localization[parts[1]] || localization[parts[1].toLowerCase()];
			if (!loclang) throw new Error(locale.format(module, "localizationError", parts[1]));
			//throw Error("Localization error: missing localization for language: " + parts[1]);
			var keyvalue = value[parts[0]];
			filter.jsonWhere[key] = localization[parts[1]][keyvalue];
		} else {
			filter.jsonWhere[key] = value[simpleKey];
		}
	} else {
		parts = key.split(".");
		if (parts.length > 1 && typeof value == "string" && proto.$localized && (proto.$localized.indexOf(parts[0]) >= 0)) {
			if (entity.$properties && entity.$properties[parts[0]] && entity.$properties[parts[0]].$isLocalized) {
				filter.jsonWhere[key] = localization[parts[1]][value];
			}
		} else {
			filter.jsonWhere[key] = value;
		}

	}
	tracer.debug && tracer.debug("jsonImport get filter: " + sys.inspect(filter, null, 4));
	return filter;
}
//

function _importCollection(_, inst, relName, relMeta, relProto, value, localization, _pointerTypes, options) {
	var coll = inst[relName](_);
	var db = inst._db;
	tracer.debug && tracer.debug("jsonImport._importCollection: relation: " + relName /* + "; relProto: " + sys.inspect(relProto, null, 4)*/ );
	// TODO : delta algorithm to remove items
	options = options || {};

	var solvedInstMap = {}; // instances after value resolution, in the exact same order as input
	if (Array.isArray(value)) value.forEach_(_, function(_, relItemValue, index) {
		var varType = relMeta.$variants && relItemValue && (relItemValue.$variantType || relItemValue.$type);
		//
		/*		if (relProto && relProto.$type === "pointer") {
			var parent = relProto.$parent;
			var tg = relProto.$target;
			while (parent && tg && (tg.indexOf("$parent.") >= 0)) {
				tg = tg.replace("$parent.", "");
				parent = parent.$parent;
			}
			if (parent && tg) relProto = parent[tg];
		}*/
		//
		var rp = varType ? relProto && relProto.$variants[varType] : relProto;
		if (rp.$type === "pointer") rp = _pointerTypes[rp.$id];
		//
		var relKey = (rp || {}).$key || "description";
		var te = relMeta.getTargetEntity(varType);
		var relInst;
		if (relMeta.getIsChild(varType)) {
			// childrens
			var opt = {
				jsonWhere: {}
			};
			// create a filter from the relations key. If the key is composed from relations, found those relations meta to compose the filter
			var relKeys = Array.isArray(relKey) ? relKey.slice(0) : [relKey];
			relKeys.forEach(function(relKeyItem) {
				var fullRelKey, parts;
				if (rp[relKeyItem]) { //relProto[parts[0]]
					//TODO relProto[relKeyItem].$key peut Ãªtre aussi un tableau
					parts = rp[relKeyItem].$key.split(".");
					if (parts.length > 1) {
						fullRelKey = relKeyItem + "." + rp[relKeyItem].$key; // parts[0];
						if (relItemValue[relKeyItem] && typeof relItemValue[relKeyItem] == "object") {
							opt.jsonWhere[fullRelKey] = localization[parts[1]][relItemValue[relKeyItem][parts[0]]];
						} else opt.jsonWhere[fullRelKey] = localization[parts[1]][relItemValue[relKeyItem]];
					} else {
						fullRelKey = relKeyItem;
						if (!relItemValue[relKeyItem] || typeof relItemValue[relKeyItem] !== "object") fullRelKey += "." + relProto[relKeyItem].$key;
						opt.jsonWhere[fullRelKey] = relItemValue[relKeyItem];
					}
				} else {
					fullRelKey = relKeyItem;
					parts = relKeyItem.split(".");
					if (parts.length > 1) {
						opt.jsonWhere[relKeyItem] = localization[parts[1]][relItemValue[parts[0]]];
					} else opt.jsonWhere[fullRelKey] = relItemValue[relKeyItem];
				}
			});
			//              }
			tracer.debug && tracer.debug("jsonImport._importCollection " + relMeta.name + " generate filter: " + sys.inspect(opt.jsonWhere, null, 4));
			relInst = coll.filter(_, opt)[0];
			if (!relInst) {
				tracer.debug && tracer.debug("jsonImport._importCollection not found, creating child");
				relInst = inst.createChild(_, relName, null, null, false, varType);
				coll.set(_, relInst);
			}
			// import
			_importInstance(_, relInst, relItemValue, rp, localization, _pointerTypes, options);
			//
			if (options.unmark) coll.unmark(_, relInst, options.unmark);
			//
			if (relInst) solvedInstMap[relInst.$uuid] = index;
		} else {
			//references
			relInst = relItemValue ? db.fetchInstance(_, te, _getFilter(_, db, relKey, relItemValue, te, rp, localization)) : null;
			if (relInst && !coll.get(_, relInst.$uuid)) {
				coll.set(_, relInst);
			}
			//
			if (options.unmark) coll.unmark(_, relInst, options.unmark);
			//
			if (relInst) solvedInstMap[relInst.$uuid] = index;
		}
	});
	//
	if (!relProto.$sorted) {
		// elements that are in the import list keep the import list order
		// elements that are not in the import list will try to stay after the element that preceded them before import
		var arr = coll.toArray(_);
		arr.forEach(function(it, index) {
			if (solvedInstMap[it.$uuid] != null) {
				it.$index = solvedInstMap[it.$uuid];
			} else {
				if (index > 0) it.$index = +arr[index - 1].$index + 0.00001;
				else it.$index = -1; // first element is not in import list, must be of index lower that first in index list
			}
		});
		coll.sort(_, function(_, a, b) {
			// compare a and b position against desired position in solvedInstances
			var idxA = a.$index;
			var idxB = b.$index;
			return idxA - idxB;
		});
	}
}

// instProto is import prototype of instance, not of the relation

function _importReference(_, inst, relName, variantName, relMeta, instProto, value, localization, _pointerTypes, options) {
	var key = relName;
	var db = inst._db;
	var rp = variantName ? instProto && instProto[key] && instProto[key].$variants[variantName] : instProto && instProto[key];
	//
	tracer.debug && tracer.debug("jsonImport._importReference: relation: " + key + "; variant: " + variantName + "; relProto: " + sys.inspect(rp));
	// lookup
	var relKey = (rp || {}).$key || "description";
	var relInst;
	if (relMeta.getIsChild(variantName) || relMeta.$inlineStore) {
		relInst = inst[key](_);
		if (!relInst) {
			relInst = inst.createChild(_, key, null, null, false, variantName);
			_importInstance(_, relInst, value, rp, localization, _pointerTypes, options);
			inst[key](_, relInst);
		} else _importInstance(_, relInst, value, rp, localization, _pointerTypes, options);
	} else {
		relInst = null;
		var te = relMeta.getTargetEntity(variantName);
		if (value) {
			var filter = _getFilter(_, db, relKey, value, te, instProto, localization);
			// is filter empty (should get null object) ?
			var isNull = Object.keys(filter.jsonWhere).every(function(k) {
				return (filter.jsonWhere[k] == null) || (filter.jsonWhere[k] === "");
			});
			if (!isNull) {
				relInst = db.fetchInstance(_, te, filter);
				if (!relInst) {
					inst.$addDiagnose("warning", locale.format(module, "referenceMissing", inst._meta.name, relMeta.name,
						te.name, JSON.stringify(filter.jsonWhere || {})));
				} else {
					// ???
				}
			}
		}
		inst[key](_, relInst);
	}
}

function _getLocaleValue(localization, lang, value) {
	return localization[lang] && localization[lang][value];
}

function _importInstance(_, instance, data, itemProto, localization, _pointerTypes, options) {
	tracer.debug && tracer.debug("jsonImport._importInstance enter: " + instance.$uuid + "; data=" + sys.inspect(data));
	if (data && (typeof data !== "object")) throw new Error(locale.format(module, "objectExpected", data));
	if (itemProto) {
		if (itemProto.$type === "pointer") {
			if (!_pointerTypes[itemProto.$id]) throw new Error(locale.format(module, "pointerTypeNotFound", itemProto.$id));
			itemProto = _pointerTypes[itemProto.$id];
		} else if (itemProto.$id) _pointerTypes[itemProto.$id] = itemProto;
	}
	var entity = instance._meta;
	var inst = instance;
	flows.eachKey(_, data, function(_, key, value) {

		// do we need to import $ properties ? see later
		if (key[0] === "$") {
			if (key === "$factory") inst.$factory = value;
			if (key === "$factoryOwner") inst.$factoryOwner = value;
			return;
		}
		var relMeta, propMeta;
		if (entity.$relations && (relMeta = entity.$relations[key])) {
			var relProto = itemProto && itemProto[key];
			if (relMeta.isPlural) {
				_importCollection(_, inst, key, relMeta, relProto, value, localization, _pointerTypes, options);
			} else {
				var varType = relMeta.$variants && value && (value.$variantType || value.$type);
				_importReference(_, inst, key, varType, relMeta, itemProto, value, localization, _pointerTypes, options);
			}
		} else //
		if (entity.$properties && (propMeta = entity.$properties[key])) {
			if ((typeof value == "string") && itemProto && itemProto.$localized && (itemProto.$localized.indexOf(key) >= 0)) {
				if (propMeta.$isLocalized) {
					var allLocales = {
						"default": _getLocaleValue(localization, "en-us", value) || _getLocaleValue(localization, "en-gb", value) || _getLocaleValue(localization, locale.current, value)
					};
					flows.eachKey(_, localization, function(_, lang, values) {
						allLocales[lang] = values[value];
					});
					inst[key](_, resourceHelpers.parseValue(propMeta, allLocales));
				}
			} else {
				if (propMeta.isExternalStorage() && (typeof value === "object") && value && value.$content) {
					var store = inst[key](_);
					var stream = store.createWritableStream(_, {
						contentType: value.contentType,
						fileName: value.fileName,
						uploadDate: value.uploadDate
					});
					var buf = new Buffer(value.$content, "base64");
					stream.write(_, buf.toString("binary"));
					// write (null) means end
					stream.write(_, null);
					store.uploadDone(_);
				} else inst[key](_, resourceHelpers.parseValue(propMeta, value));
			}
		}
	});
	if (instance.$onImportResource) instance.$onImportResource(_, data, itemProto, localization);
	//tracer.debug && tracer.debug("jsonImport._importInstance exit: "+instance.$uuid+"; exit data="+sys.inspect(instance._data));
}

function _addToSession(_, session, sessionTypesMap, instance, destination) {
	if (!session) return;
	if (!destination) return;
	if (!instance) return;
	//
	var eName = instance.getEntity(_).name;
	var st = sessionTypesMap[eName];
	if (!st) {
		st = session.importTypes(_).add(_);
		st.entityName(_, eName);
		sessionTypesMap[eName] = st;
	}
	st[destination](_).set(_, instance);
}

function _import(_, db, input, options) {
	function _track(phase, detail, progress) {
		var opt = options;
		if (!opt.tracker) return;
		opt.tracker.phase = phase;
		opt.tracker.phaseDetail = detail;
		opt.tracker.progress = progress;
	}

	/*	function _setParent(obj) {
		if (!obj) return;
		Object.keys(obj).forEach(function(kk) {
			var rel = obj[kk];
			if (kk === "$parent") return;
			if (typeof rel !== "object") return;
			if (rel.$variants) {
				Object.keys(rel.$variants).forEach(function(vv) {
					rel.$variants[vv].$parent = obj;
					_setParent(rel.$variants[vv]);
				});
			} else {
				rel.$parent = obj;
				_setParent(rel);
			}
		});
	}*/
	//
	var proto = input.$prototypes,
		data = input.$items,
		localization = input.$localization;
	options = helpers.object.extend(options, input.$options || {}, true, true);
	// scripts
	var importMode = options.importMode || "insert";
	//
	var model = db.model;
	//
	var creCount = 0;
	var updCount = 0;
	var errCount = 0;
	var session = null;
	var sessionTypes = {};
	// before scripts
	(input.$scriptsBefore || []).forEach_(_, function(_, scr) {
		try {
			var _preScript = require(scr.module);
			var opt = scr.options || {};
			opt.tracer = tracer;
			_preScript.execute(_, db, opt);
		} catch (e) {
			tracer.error && tracer.error("An error occured while executing preScript " + scr.module + ": " + e.safeStack);
			return true;
		}
	});
	// actual import
	try {
		if (options.createSession) {
			var admDb = adminHelper.getCollaborationOrm(_);
			var e = admDb.getEntity(_, "importSession");
			session = e.factory.createInstance(_, null, admDb);
			session.description(_, options.sessionDescription || locale.format(module, "genericSessionLabel"));
		}
		// build reverse navigation structure of proto, needed in case of "pointer" relations type
		// _setParent(proto);
		//
		// when options._filename is set, it is multiple import of different files, therefore the 
		// progress will be computed using options._lower (percentage at beginning of file) and options._step
		// (percentage at end minus percentage at beginning of file)
		var _pointerTypes = {};
		var idx = 0;
		var factor = (options._filename ? options._step : 100) / data.length;
		data.some_(_, function(_, item) {
			if (!item) return;
			tracer.debug && tracer.debug("jsonImport importing item :" + sys.inspect(item));
			if (!item) return;
			//
			if (options._filename) {
				_track(options._filename, item.$type, Math.ceil(options._lower + (idx++ * factor)));
			} else {
				_track(locale.format(module, "importing"), item.$type, Math.ceil(idx++ * factor));
			}
			// get 
			var entity = model.getEntity(_, item.$type);
			if (!entity) return;
			var itemProto = proto[item.$type] || {};
			tracer.debug && tracer.debug("jsonImport importing itemProto :" + sys.inspect(itemProto));
			var key = itemProto.$key || "description";
			var filter = _getFilter(_, db, key, item, entity, itemProto, localization);
			tracer.debug && tracer.debug("jsonImport fetchInstance filter :" + sys.inspect(filter));
			var inst = db.fetchInstance(_, entity, filter);
			if (inst && (importMode === "insert")) {
				return (tracer.warn && tracer.warn("jsonImport will not import because in insert only mode")) && false;
			}

			//
			var created = false;
			if (!inst) {
				// create
				inst = entity.factory.createInstance(_, null, db);
				created = true;
			}
			// update data
			_importInstance(_, inst, item, itemProto, localization, _pointerTypes, options);

			if (inst) {
				if (inst._data.description) {
					var alls = inst.getPropAllLocales(_, "description");
				}
			}
			//
			// special handling of badges: need to switch off start of license system during saving
			if (entity.name === "badge") {
				inst.noCheck(_, true);
			}

			inst.save(_, null, {
				shallowSerialize: true
			});
			//
			var hasErrors = false;
			var diags = [];
			inst.getAllDiagnoses(_, diags, {
				addPropName: true,
				addEntityName: true
			});

			diags.forEach_(_, function(_, d) {
				d = _normalizeDiag(d);
				// improuve error messages
				var p = itemProto.$value || (Array.isArray(itemProto.$key) ? itemProto.$key[0] : itemProto.$key) || "description";
				var path = p ? helpers.object.walkPath(item, p) : null;

				var lCode = "diagPrefix_" + d.$severity;
				if (path) d.$message = locale.format(module, lCode, item.$type, path.resource[path.property], d.$message);

				options && options.$diagnoses && options.$diagnoses.push(d);
				var isError = d.$severity === "error";
				if (isError) {
					hasErrors = true;
					tracer.error && tracer.error("Import error: " + d.$message);
					if (session) {
						if (!session.errorDiags(_)) session.errorDiags(_, []);
						session.errorDiags(_).push(d.$message);
					}
				}
				if (session && (d.$severity === "warning")) {
					if (!session.warnDiags(_)) session.warnDiags(_, []);
					session.warnDiags(_).push(d.$message);
				}
			});
			//
			if (hasErrors) {
				errCount++;
			} else {
				if (created) {
					creCount++;
					_addToSession(_, session, sessionTypes, inst, "createdObjects");
				} else {
					updCount++;
					_addToSession(_, session, sessionTypes, inst, "updatedObjects");
				}
			}
			if (options && options.$diagnoses) {
				//_trace(options.$diagnoses, "jsonImport importing item diagnose: " + item.$type + "; ");
				//tracer.debug && tracer.debug("jsonImport importing item diagnoses: " + item.$type + "; " + sys.inspect(options.$diagnoses));
			}
			//
			return options.tracker && options.tracker.abortRequested;
		});
		var resMsg = locale.format(module, "importDone", creCount, updCount, errCount);
		options && options.$diagnoses && options.$diagnoses.push({
			$severity: "info",
			$message: resMsg
		});
		tracer.info && tracer.info(resMsg);
		console.error(resMsg);
		//
		session && session.save(_, null, {
			shallowSerialize: true
		});
	} catch (e) {
		// log error
		console.error(e.stack);
		if (session) {
			if (!session.errorDiags(_)) session.errorDiags(_, []);
			session.errorDiags(_).push(e.message);
			session.save(_, null, {
				shallowSerialize: true
			});
		}
		throw e;
	}
	//
	(input.$scriptsAfter || []).forEach_(_, function(_, scr) {
		var ff = (function(_) {
			try {
				var _preScript = require(scr.module);
				var opt = scr.options || {};
				opt.tracer = tracer;
				_preScript.execute(_, db, opt);
			} catch (e) {
				tracer.error && tracer.error("An error occured while executing postScript " + scr.module + ": " + e.safeStack);
				return true;
			}
		});
		if (options.defferedPostScripts) options.defferedPostScripts.push(ff);
		else ff(_);
	});
	//
	return session;
}

function _simplify(_, db, proto, data, options) {
	var model = db.model;
	var _pointerTypes = {};
	var items = [];
	data.forEach_(_, function(_, item) {
		var entity = model.getEntity(_, item.$type);
		if (!entity) return;
		var itemProto = proto[item.$type] || {};
		var key = itemProto.$key || "description";
		var e = _simplifyItem(_, entity, item, itemProto, _pointerTypes);
		e && items.push(e);
	});

	return items;
}

function _simplifyItem(_, entity, item, itemProto, _pointerTypes) {
	var data = {};
	if (item && (typeof(item) !== "object")) throw new Error("Object expected");
	if (itemProto) {
		if (itemProto.$type === "pointer") {
			if (!_pointerTypes[itemProto.$id]) throw new Error("Pointer type not found: " + itemProto.$id);
			itemProto = _pointerTypes[itemProto.$id];
		} else if (itemProto.$id) _pointerTypes[itemProto.$id] = itemProto;
	}

	tracer.debug && tracer.debug("_simplifyItem: item=" + sys.inspect(item) + "\nentity=" + sys.inspect(entity));
	itemProto = itemProto || {};
	flows.eachKey(_, item, function(_, key, value) {
		if (key[0] === "$") {
			if (["$type", "$variantType"].indexOf(key) != -1) {
				data[key] = value;
			}
			return;
		}
		if (key === itemProto.$key) {
			data[key] = value;
			return;
		}
		tracer.debug && tracer.debug("_simplifyItem: key=" + key);

		var relMeta, propMeta;
		if (entity.$relations && (relMeta = entity.$relations[key])) {
			// relation
			tracer.debug && tracer.debug("_simplifyItem relation: key=" + key + ", value=" + sys.inspect(value));
			var relProto = itemProto[key];
			if (relMeta.isPlural) {
				tracer.debug && tracer.debug("_simplifyItem: key=" + key + ", value=" + sys.inspect(value));
				tracer.debug && tracer.debug("entity=" + sys.inspect(entity));
				tracer.debug && tracer.debug("itemProto=" + sys.inspect(itemProto));
				var items = _simplifyCollection(_, entity, key, relMeta, relProto, value, _pointerTypes);
				if (items && items.length > 0) {
					data[key] = items;
				} else if (relMeta.mandatory) {
					data[key] = value;
				}
			} else {
				var varType = relMeta.$variants && value && (value.$variantType || value.$type);
				if (relMeta.mandatory) {
					data[key] = value;
				}
			}
		} else if (entity.$properties && (propMeta = entity.$properties[key])) {
			// tracer.debug && tracer.debug("_simplifyItem: key=" + key + ", value=" + sys.inspect(value));
			// tracer.debug && tracer.debug("entity=" + sys.inspect(entity));
			// tracer.debug && tracer.debug("itemProto=" + sys.inspect(itemProto));
			// tracer.debug && tracer.debug("propMeta=" + sys.inspect(propMeta));
			if (propMeta.mandatory) {
				data[key] = value;
			} else if ((typeof(value) === "string") && itemProto.$localized && (itemProto.$localized.indexOf(key) >= 0)) {
				if (propMeta.$isLocalized) {
					data[key] = value;
				}
			} else if (value && typeof(value) === "object" && !propMeta.isExternalStorage()) {
				throw new Error("Object not managed: " + key + " in " + item.$type + "/" + item[itemProto.$key]);
			}
		}
	});

	return data;
}

function _simplifyCollection(_, entity, relName, relMeta, relProto, value, _pointerTypes) {
	if (!Array.isArray(value)) return;

	// tracer.debug && tracer.debug("_simplifyCollection: name=" + relName + ", relMeta=" + JSON.stringify(relMeta) + //
	// 	"\nrelProto=" + JSON.stringify(relProto) + //
	// 	"\nvalue=" + JSON.stringify(value));

	var items = [];
	value.forEach_(_, function(_, relItemValue) {
		var varType = relMeta.$variants && relItemValue && (relItemValue.$variantType || relItemValue.$type);

		var rp = varType ? relProto && relProto.$variants[varType] : relProto;
		if (rp.$type === "pointer") rp = _pointerTypes[rp.$id];

		var relKey = rp && rp.$key || "description";
		var te = relMeta.getTargetEntity(varType);

		if (relMeta.getIsChild(varType)) {
			var e = _simplifyItem(_, te, relItemValue, rp, _pointerTypes);
			e && items.push(e);
		} else if (relMeta.$isComputed) {
			// ignore
		} else if (relMeta.mandatory) {
			throw new Error("Mandatory reference not managed: " + relName + "/" + varType + "/" + relItemValue[relKey]);
		}
	});

	return items;
}
// just test whether this file should be imported because of file modification time
// result true: file should be imported
exports.importTest = function(_, filename, ifNoneMatch) {
	var fname = fsp.join(config.system.root, "import", filename);
	try {
		var modTime = fs.stat(fname, _).mtime.getTime();
		return !ifNoneMatch.updDate || (Math.abs(ifNoneMatch.updDate.getTime() - modTime) > 600000);
	} catch (e) {
		tracer.debug && tracer.debug("Cannot stat file " + filename + ": " + e);
		return false;
	}
};


exports.jsonImport = function(_, db, filename, options) {
	//
	options = options || {};
	var fname;
	try {
		// check if path is absolute
		fs.stat(filename, _);
		fname = filename;
	} catch (e) {
		// filename is supposed to be located in "import" folder (same level as node_modules)
		fname = fsp.join(config.system.root, "import", filename);
	}
	var input, modTime;
	if (options.ifNoneMatch) {
		// find out whether file really has to be integrated. Check modification time first, then checksum of content.
		// ifNoneMatch is an array which has the filename as element 0, the checksum of the contents as element 1
		// and then hostnames and modification times as further entries
		var automaticData = options.ifNoneMatch;
		try {
			modTime = fs.stat(fname, _).mtime;
		} catch (e) {
			tracer.error && tracer.error("Cannot stat the file " + fname + ": " + e);
			return true;
		}
		if (automaticData.updDate && (Math.abs(automaticData.updDate.getTime() - modTime.getTime()) < 600000)) {
			tracer.info && tracer.info("No modification " + fname);
			return true;
		}

		// update the modification time
		automaticData.updDate = modTime;
		// find checksum
		input = fs.readFile(fname, _);
		var hash = crypto.createHash('SHA1');
		hash.update(input);

		var h = hash.digest("hex");
		if (h === automaticData.contentHash) {
			// no modification
			tracer.info && tracer.info("No content modification " + fname);
			return true;
		}
		automaticData.contentHash = h;

		input = JSON.parse(input.toString("utf8"));
	} else {
		try {
			input = JSON.parse(fs.readFile(fname, "utf8", _));
		} catch (e) {
			throw new Error(locale.format(module, "cannotReadImport", fname));
		}
	}
	var proto = input.$prototypes || {};
	var data = input.$items || [];
	var localization = input.$localization || {};
	// includes (only after, TODO before)
	if (input.$includeAfter) {
		input.$includeAfter.forEach_(_, function(_, includeFile) {
			var include = JSON.parse(fs.readFile(fsp.join(config.system.root, "import", includeFile + ".json"), "utf8", _));
			if (include.$prototypes)
				for (var p in include.$prototypes) proto[p] = include.$prototypes[p];
			(include.$items || []).forEach(function(item) {
				data.push(item);
			});

			//localization["en-us"][l] = include.$localization["en-us"][l];

			//for each language
			flows.eachKey(_, localization, function(_, lang, values) {
				for (var l in include.$localization[lang]) {
					localization[lang][l] = include.$localization[lang][l];
				}
			});
		});
	}

	if (options.preScript) {
		try {
			var _preScript = require(options.preScript);
			_preScript.importHandler = this;
			_preScript.tracer = tracer;
			_preScript.dataUpdate(_, db);
		} catch (e) {
			tracer.error && tracer.error("An error occured while executing preScript " + options.preScript + ": " + e.safeStack);
			return true;
		}
	}

	_import(_, db, input, options);

	if (options.postScript) {
		try {
			var _postScript = require(options.postScript);
			_postScript.tracer = tracer;
			_postScript.dataUpdate(_, db);
		} catch (e) {
			tracer.error && tracer.error("An error occured while executing postScript " + options.postScript + ": " + e.safeStack);
			return true;
		}
	}
};

exports.streamImport = function(_, db, stream, options) {
	//
	options = options || {};
	options.$diagnoses = options.$diagnoses || [];
	// filename is supposed to be located in "import" folder (same level as node_modules)
	var input = JSON.parse(stream.readAll(_));
	var proto = input.$prototypes || {};
	var data = input.$items || [];
	var localization = input.$localization || {};
	//
	var s = _import(_, db, input, options);
	//
	return {
		$url: s && "{$baseUrl}/importSessions('" + s.$uuid + "')?representation=importSession.$details",
		$uuid: s && s.$uuid,
		$diagnoses: options.$diagnoses
	};

};

exports.jsonImportFromJson = function(_, user, input, options) {
	input = typeof input === "object" ? input : JSON.parse(input);
	var db = adminHelper.getCollaborationOrm(_);
	options.$diagnoses = options.$diagnoses || [];
	_import(_, db, input, options);
	return options.$diagnoses;
};

exports.simplifyItems = function(_, user, input, options) {
	options = options || {};
	input = typeof input === "object" ? input : JSON.parse(input);
	var db = adminHelper.getCollaborationOrm(_);
	var items;
	options.$diagnoses = options.$diagnoses || [];
	try {
		items = _simplify(_, db, input.$prototypes, input.$items, options);
	} catch (e) {
		options.$diagnoses.push({
			$severity: "error",
			$message: e.message + " at " + e.stack
		});
	}
	return {
		$items: items,
		$diagnoses: options.$diagnoses
	};
};

exports.$exported = true;