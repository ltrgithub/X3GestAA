"use strict";

var fs = require('streamline-fs');
var fsp = require("path");
var flows = require("streamline/lib/util/flows");
var helpers = require("syracuse-core/lib/helpers");
var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var resourceHelpers = require("syracuse-core/lib/resource/util");
var locale = require("syracuse-core/lib/locale");
var sys = require("util");

var tracer = null;
//var tracer = console.log;

function _normalizeDiag(diag) {
	return {
		$severity: diag.$severity || diag.severity,
		$message: diag.$message || diag.message
	};
}

function _getFilter(_, db, key, value, entity, proto, localization) {
	tracer && tracer("jsonImport._getFilter for " + sys.inspect(key) + "=" + sys.inspect(value) + "; entity: " + (entity && entity.name));
	var filter = {
		jsonWhere: {}
	};
	if (Array.isArray(key)) {
		// value should be object !!!
		if (typeof value != "object") throw new Error("Internal error: type of value should be object (key: '" + key + "'; value: '" + value + "')");
		key.forEach_(_, function(_, item) {
			if (Array.isArray(value[item])) {
				filter.jsonWhere[item] = value[item].map_(_, function(_, mapItem) {
					// lookup for the array values
					if (proto && proto[item] && proto[item].$key && entity && entity.$relations && entity.$relations[item] && entity.$relations[item].isPlural) {
						var mapFilter = {
							jsonWhere: {}
						};
						mapFilter.jsonWhere[proto[item].$key] = mapItem;
						return (db.fetchInstance(_, entity.$relations[item].targetEntity, mapFilter) || {}).$uuid;
					} else {
						return mapItem;
					}
				});
			} else {
				filter.jsonWhere[item] = value[item];
			}
		});
	} else if (typeof value == "object") {
		var simpleKey = key.split(".")[0];
		if (entity.$properties && entity.$properties[simpleKey] && entity.$properties[simpleKey].$isLocalized //
		&&
		typeof value[simpleKey] == "string" && value[simpleKey].match(new RegExp(simpleKey + "_[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}"))) {
			// take the first value as default
			var parts = key.split(".");
			if (parts.length < 2) inst.$addDiagnose("error", locale.format(module, "formatError", entity.name, key));
			return;
			//throw Error("Format error: localized type but one part key: " + entity.name + "." + key);
			var loclang = localization[parts[1]] || localization[parts[1].toLowerCase()];
			if (!loclang) inst.$addDiagnose("error", locale.format(module, "localizationError", parts[1]));
			//throw Error("Localization error: missing localization for language: " + parts[1]);
			var keyvalue = value[parts[0]];
			filter.jsonWhere[key] = localization[parts[1]][keyvalue];
		} else {
			filter.jsonWhere[key] = value[simpleKey];
		}
	} else {
		var parts = key.split(".");
		if (parts.length > 1 && typeof value == "string" && value.match(new RegExp(parts[0] + "_[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}"))) {
			if (entity.$properties && entity.$properties[parts[0]] && entity.$properties[parts[0]].$isLocalized) {
				filter.jsonWhere[key] = localization[parts[1]][value];
			}
		} else {
			filter.jsonWhere[key] = value;
		}

	}
	tracer && tracer("jsonImport get filter: " + sys.inspect(filter, null, 4));
	return filter;
}
//

function _importCollection(_, inst, relName, relMeta, relProto, value, localization) {
	var coll = inst[relName](_);
	////console.log("relProto: " + sys.inspect(relProto));
	var relKey = (relProto || {}).$key || "description";
	var db = inst._db;
	// TODO : delta algorithm to remove items

	////console.log(" value:"+sys.inspect(value)) ;
	if (Array.isArray(value)) value.forEach_(_, function(_, relItemValue) {
		////console.log("relItemValue: " + sys.inspect(relItemValue));
		var relInst;
		////console.log("relMeta: "+sys.inspect(relMeta)) ;
		if (relMeta.isChild) {
			// childrens
			var opt = {
				jsonWhere: {}
			};
			// create a filter from the relations key. If the key is composed from relations, found those relations meta to compose the filter
			var relKeys = Array.isArray(relKey) ? relKey.slice(0) : [relKey];
			////console.log("relproto: " + sys.inspect(relProto));
			//              if(Array.isArray(relKey)) {
			relKeys.forEach(function(relKeyItem) {
				if (relProto[relKeyItem]) { //relProto[parts[0]]
					//!!!!!!!!!!TODO relProto[relKeyItem].$key peut Ãªtre aussi un tableau
					var parts = relProto[relKeyItem].$key.split(".");
					if (parts.length > 1) {
						var fullRelKey = relKeyItem + "." + relProto[relKeyItem].$key; // parts[0];
						if (relItemValue[relKeyItem] && typeof relItemValue[relKeyItem] == "object") {
							opt.jsonWhere[fullRelKey] = localization[parts[1]][relItemValue[relKeyItem][parts[0]]];
						} else opt.jsonWhere[fullRelKey] = localization[parts[1]][relItemValue[relKeyItem]];
					} else {
						var fullRelKey = relKeyItem;
						if (!relItemValue[relKeyItem] || typeof relItemValue[relKeyItem] !== "object") fullRelKey += "." + relProto[relKeyItem].$key;
						opt.jsonWhere[fullRelKey] = relItemValue[relKeyItem];
					}
				} else {
					var fullRelKey = relKeyItem;
					var parts = relKeyItem.split(".");
					if (parts.length > 1) {
						opt.jsonWhere[relKeyItem] = localization[parts[1]][relItemValue[parts[0]]];
					} else opt.jsonWhere[fullRelKey] = relItemValue[relKeyItem];
				}
			});
			//              }
			tracer && tracer("jsonImport._importCollection " + relMeta.name + " generate filter: " + sys.inspect(opt.jsonWhere, null, 4));
			relInst = coll.filter(_, opt)[0];
			if (!relInst) {
				tracer && tracer("jsonImport._importCollection not found, creating child");
				relInst = inst.createChild(_, relName);
				coll.set(_, relInst);
			}
			// import
			_importInstance(_, relInst, relItemValue, relProto, localization);
		} else {
			//references
			relInst = relItemValue ? db.fetchInstance(_, relMeta.targetEntity, _getFilter(_, db, relKey, relItemValue, relMeta.targetEntity, relProto, localization)) : null;
			if (relInst && !coll.get(_, relInst.$uuid)) {
				coll.set(_, relInst);
			}
		}
	});
}

function _importInstance(_, instance, data, itemProto, localization) {
	tracer && tracer("jsonImport._importInstance enter: " + instance.$uuid + "; data=" + sys.inspect(data));
	if (data && (typeof data !== "object")) throw new Error(locale.format(module, "objectExpected", data));
	var entity = instance._meta;
	var inst = instance;
	var db = instance._db;
	flows.eachKey(_, data, function(_, key, value) {

		// do we need to import $ properties ? see later
		if (key[0] === "$") return;
		var relMeta, propMeta;
		if (entity.$relations && (relMeta = entity.$relations[key])) {
			// lookup
			var relKey = (itemProto && itemProto[key] || {}).$key || "description";
			if (relMeta.isPlural) {
				_importCollection(_, inst, key, relMeta, itemProto[key], value, localization);
			} else {
				if (relMeta.isChild || relMeta.$inlineStore) {
					var relInst = inst[key](_);
					if (!relInst) {
						relInst = inst.createChild(_, key);
						_importInstance(_, relInst, value, itemProto[key], localization);
						inst[key](_, relInst);
					} else _importInstance(_, relInst, value, itemProto[key], localization);
				} else {
					var relInst = null;
					if (value) {
						var filter = _getFilter(_, db, relKey, value, relMeta.targetEntity, itemProto, localization);
						// is filter empty (should get null object) ?
						var isNull = Object.keys(filter.jsonWhere).every(function(k) {
							return (filter.jsonWhere[k] == null) && (filter.jsonWhere[k] == "");
						});
						if (!isNull) {
							relInst = db.fetchInstance(_, relMeta.targetEntity, filter);
							if (!relInst) {
								//console.log("instance not found for filter " + JSON.stringify(filter, null, 2));
								inst.$addDiagnose("warning", locale.format(module, "referenceMissing", inst._meta.name, relMeta.name,
								relMeta.targetEntity.name, JSON.stringify(filter.jsonWhere || {})));
							} else {
								//console.log("instance fetched key "+key)

							}
						}
					}
					inst[key](_, relInst);
					var dia = [];
					inst.getAllDiagnoses(_, dia);
					//console.log("dia: "+sys.inspect(dia)) ;

				}
			}
		} else if (entity.$properties && (propMeta = entity.$properties[key])) {
			if ((typeof value == "string") && value.match(new RegExp(key + "_[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}"))) {
				if (propMeta.$isLocalized) {

					//throw Error("Format error: localized type but one part key: "+entity.name+"."+key);
					//For each language

					var allLocales = {
						"default": localization[locale.current] && localization[locale.current][value]
					};
					flows.eachKey(_, localization, function(_, lang, values) {
						////console.log("values: "+JSON.stringify(values,null,2)) ;
						////console.log("LOCALIZATION lang: " + lang);
						////console.log("LOCALIZATION value: " + values[value]);
						allLocales[lang] = values[value];
						inst[key](_, resourceHelpers.parseValue(propMeta, allLocales));
					});
				}
			} else inst[key](_, resourceHelpers.parseValue(propMeta, value));
		}
	});
	//tracer && tracer("jsonImport._importInstance exit: "+instance.$uuid+"; exit data="+sys.inspect(instance._data));
}

function _addToSession(_, session, sessionTypesMap, instance, destination) {
	if (!session) return;
	if (!destination) return;
	if (!instance) return;
	//
	var eName = instance.getEntity(_).name;
	var st = sessionTypesMap[eName];
	if (!st) {
		st = session.importTypes(_).add(_);
		st.entityName(_, eName);
		sessionTypesMap[eName] = st;
	}
	st[destination](_).set(_, instance);
}

function _import(_, db, proto, data, localization, options) {
	var importMode = options.importMode || "insert";
	//
	var model = db.model;
	// 
	var creCount = 0;
	var updCount = 0;
	var errCount = 0;
	var session = null;
	var sessionTypes = {};
	try {
		if (options.createSession) {
			var admDb = adminHelper.getCollaborationOrm(_);
			var e = admDb.getEntity(_, "importSession");
			session = e.factory.createInstance(_, null, admDb);
			session.description(_, options.sessionDescription || locale.format(module, "genericSessionLabel"));
		}
		data.forEach_(_, function(_, item) {
			tracer && tracer("jsonImport importing item :" + sys.inspect(item));
			// get 
			var entity = model.getEntity(_, item.$type);
			if (!entity) return;
			var itemProto = proto[item.$type] || {};
			tracer && tracer("jsonImport importing itemProto :" + sys.inspect(itemProto));
			var key = itemProto.$key || "description";
			var filter = _getFilter(_, db, key, item, entity, itemProto, localization);
			tracer && tracer("jsonImport fetchInstance filter :" + sys.inspect(filter));
			var inst = db.fetchInstance(_, entity, filter);

			if (inst && (importMode === "insert")) return;

			//
			var created = false;
			if (!inst) {
				// create
				inst = entity.factory.createInstance(_, null, db);
				created = true;
			}
			// update data
			_importInstance(_, inst, item, itemProto, localization);

			if (inst) {
				if (inst._data.description) {
					var alls = inst.getPropAllLocales(_, "description");
				}
			}
			//

			inst.save(_, null, {
				shallowSerialize: true
			});
			//
			var hasErrors = false;
			var diags = [];
			inst.getAllDiagnoses(_, diags, {
				addPropName: true,
				addEntityName: true
			});

			diags.forEach_(_, function(_, d) {
				d = _normalizeDiag(d);
				// improuve error messages
				var p = itemProto.$value || (Array.isArray(itemProto.$key) ? itemProto.$key[0] : itemProto.$key) || "description";
				var path = p ? helpers.object.walkPath(item, p) : null;

				var lCode = "diagPrefix_" + d.$severity;
				if (path) d.message = locale.format(module, lCode, item.$type, path.resource[path.property], d.$message);

				options && options.$diagnoses && options.$diagnoses.push(d);
				if (session && (d.$severity === "error")) {
					hasErrors = true;
					if (!session.errorDiags(_)) session.errorDiags(_, []);
					session.errorDiags(_).push(d.$message);
				}
				if (session && (d.$severity === "warning")) {
					if (!session.warnDiags(_)) session.warnDiags(_, []);
					session.warnDiags(_).push(d.$message);
				}
			});
			//
			if (hasErrors) {
				errCount++;
				//                tracer && tracer("jsonImport importing item diagnoses: " + item.$type + "; " + sys.inspect(options.$diagnoses));
			} else {
				if (created) {
					creCount++;
					_addToSession(_, session, sessionTypes, inst, "createdObjects");
				} else {
					updCount++;
					_addToSession(_, session, sessionTypes, inst, "updatedObjects");
				}
			}
			if (options && options.$diagnoses) {
				tracer && tracer("jsonImport importing item diagnoses: " + item.$type + "; " + sys.inspect(options.$diagnoses));
			}
		});
		options && options.$diagnoses && options.$diagnoses.push({
			$severity: "info",
			$message: locale.format(module, "importDone", creCount, updCount, errCount)
		});
		//
		session && session.save(_, null, {
			shallowSerialize: true
		});
	} catch (e) {
		// log error
		if (session) {
			if (!session.errorDiags(_)) session.errorDiags(_, []);
			session.errorDiags(_).push(e.message);
			session.save(_, null, {
				shallowSerialize: true
			});
		}
		throw e;
	}
	//
	return session;
}

exports.jsonImport = function(_, db, filename, options) {
	//
	options = options || {};
	tracer = tracer || options.tracer || (require("syracuse-main/lib/nodeconfig").config.import || {}).tracer;

	// filename is supposed to be located in "import" folder (same level as node_modules)
	var input = JSON.parse(fs.readFile(fsp.join(__dirname, "../../../import", filename), "utf8", _));
	var proto = input.$prototypes || {};
	var data = input.$items || [];
	var localization = input.$localization || {};
	// includes (only after, TODO before)
	if (input.$includeAfter) {
		input.$includeAfter.forEach_(_, function(_, includeFile) {
			var include = JSON.parse(fs.readFile(fsp.join(__dirname, "../../../import", includeFile + ".json"), "utf8", _));
			if (include.$prototypes) for (var p in include.$prototypes) proto[p] = include.$prototypes[p];
			(include.$items || []).forEach(function(item) {
				data.push(item);
			});

			//localization["en-us"][l] = include.$localization["en-us"][l];

			//for each language
			flows.eachKey(_, localization, function(_, lang, values) {
				for (var l in include.$localization[lang]) {
					localization[lang][l] = include.$localization[lang][l];
				}
			});
		});
	}

	_import(_, db, proto, data, localization, options);

};

exports.streamImport = function(_, db, stream, options) {
	//
	options = options || {};
	tracer = tracer || options.tracer || (require("syracuse-main/lib/nodeconfig").config.import || {}).tracer;
	options.$diagnoses = options.$diagnoses || [];
	// filename is supposed to be located in "import" folder (same level as node_modules)
	var input = JSON.parse(stream.readAll(_));
	var proto = input.$prototypes || {};
	var data = input.$items || [];
	var localization = input.$localization || {};
	//
	var s = _import(_, db, proto, data, localization, options);
	//
	return {
		$url: s && "{$baseUrl}/importSessions('" + s.$uuid + "')?representation=importSession.$details",
		$uuid: s && s.$uuid,
		$diagnoses: options.$diagnoses
	};

};

exports.jsonImportFromJson = function(_, user, input, options) {
	tracer = tracer || options.tracer || (require("syracuse-main/lib/nodeconfig").config.import || {}).tracer;
	try {
		input = typeof input === "object" ? input : JSON.parse(input);
		var db = adminHelper.getCollaborationOrm(_);
		options.$diagnoses = options.$diagnoses || [];
		_import(_, db, input.$prototypes, input.$items, input.$localization, options);
		////console.log("diagnoses: "+sys.inspect(options.$diagnoses)) ;
		return options.$diagnoses;
	} catch (e) {
		console.error(e.stack);
		throw e;
	}

};

exports.$exported = true;