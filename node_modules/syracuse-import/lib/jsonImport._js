"use strict";

var fs = require('streamline-fs');
var fsp = require("path");
var crypto = require("crypto");
var flows = require("streamline/lib/util/flows");
var helpers = require("syracuse-core/lib/helpers");
var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var resourceHelpers = require("syracuse-core/lib/resource/util");
var locale = require("syracuse-core/lib/locale");
var sys = require("util");
var hostname = require('os').hostname();
var tracer; // = console.log;

function _normalizeDiag(diag) {
	return {
		$severity: diag.$severity || diag.severity,
		$message: diag.$message || diag.message
	};
}

// proto is prototype of the object proprietary of the instance, not relation's proto

function _getFilter(_, db, key, value, entity, proto, localization) {
	tracer && tracer("jsonImport._getFilter for " + sys.inspect(key) + "=" + sys.inspect(value) + "; entity: " + (entity && entity.name));
	var filter = {
		jsonWhere: {}
	};
	if (Array.isArray(key)) {
		// value should be object !!!
		if (typeof value != "object") throw new Error("Internal error: type of value should be object (key: '" + key + "'; value: '" + value + "')");
		key.forEach_(_, function(_, item) {
			if (Array.isArray(value[item])) {
				filter.jsonWhere[item] = value[item].map_(_, function(_, mapItem) {
					// lookup for the array values
					if (proto && proto[item] && proto[item].$key && entity && entity.$relations && entity.$relations[item] && entity.$relations[item].isPlural) {
						var mapFilter = {
							jsonWhere: {}
						};
						mapFilter.jsonWhere[proto[item].$key] = mapItem;
						return (db.fetchInstance(_, entity.$relations[item].targetEntity, mapFilter) || {}).$uuid;
					} else {
						return mapItem;
					}
				});
			} else {
				filter.jsonWhere[item] = value[item];
			}
		});
	} else if (typeof value == "object") {
		var simpleKey = key.split(".")[0];
		if (entity.$properties && entity.$properties[simpleKey] && entity.$properties[simpleKey].$isLocalized //
			&&
			typeof value[simpleKey] == "string" && proto.$localized && (proto.$localized.indexOf(simpleKey) >= 0)) {
			// take the first value as default
			var parts = key.split(".");
			if (parts.length < 2) return inst.$addDiagnose("error", locale.format(module, "formatError", entity.name, key));
			//throw Error("Format error: localized type but one part key: " + entity.name + "." + key);
			var loclang = localization[parts[1]] || localization[parts[1].toLowerCase()];
			if (!loclang) inst.$addDiagnose("error", locale.format(module, "localizationError", parts[1]));
			//throw Error("Localization error: missing localization for language: " + parts[1]);
			var keyvalue = value[parts[0]];
			filter.jsonWhere[key] = localization[parts[1]][keyvalue];
		} else {
			filter.jsonWhere[key] = value[simpleKey];
		}
	} else {
		var parts = key.split(".");
		if (parts.length > 1 && typeof value == "string" && proto.$localized && (proto.$localized.indexOf(parts[0]) >= 0)) {
			if (entity.$properties && entity.$properties[parts[0]] && entity.$properties[parts[0]].$isLocalized) {
				filter.jsonWhere[key] = localization[parts[1]][value];
			}
		} else {
			filter.jsonWhere[key] = value;
		}

	}
	tracer && tracer("jsonImport get filter: " + sys.inspect(filter, null, 4));
	return filter;
}
//

function _importCollection(_, inst, relName, relMeta, relProto, value, localization, _pointerTypes) {
	var coll = inst[relName](_);
	var db = inst._db;
	tracer && tracer("jsonImport._importCollection: relation: " + relName /* + "; relProto: " + sys.inspect(relProto, null, 4)*/ );
	// TODO : delta algorithm to remove items

	if (Array.isArray(value)) value.forEach_(_, function(_, relItemValue) {
		var varType = relMeta.$variants && relItemValue && (relItemValue.$variantType || relItemValue.$type);
		//
		/*		if (relProto && relProto.$type === "pointer") {
			var parent = relProto.$parent;
			var tg = relProto.$target;
			while (parent && tg && (tg.indexOf("$parent.") >= 0)) {
				tg = tg.replace("$parent.", "");
				parent = parent.$parent;
			}
			if (parent && tg) relProto = parent[tg];
		}*/
		//
		var rp = varType ? relProto && relProto.$variants[varType] : relProto;
		if (rp.$type === "pointer") rp = _pointerTypes[rp.$id];
		//
		var relKey = (rp || {}).$key || "description";
		var te = relMeta.getTargetEntity(varType);
		var relInst;
		if (relMeta.getIsChild(varType)) {
			// childrens
			var opt = {
				jsonWhere: {}
			};
			// create a filter from the relations key. If the key is composed from relations, found those relations meta to compose the filter
			var relKeys = Array.isArray(relKey) ? relKey.slice(0) : [relKey];
			relKeys.forEach(function(relKeyItem) {
				if (rp[relKeyItem]) { //relProto[parts[0]]
					//TODO relProto[relKeyItem].$key peut Ãªtre aussi un tableau
					var parts = rp[relKeyItem].$key.split(".");
					if (parts.length > 1) {
						var fullRelKey = relKeyItem + "." + rp[relKeyItem].$key; // parts[0];
						if (relItemValue[relKeyItem] && typeof relItemValue[relKeyItem] == "object") {
							opt.jsonWhere[fullRelKey] = localization[parts[1]][relItemValue[relKeyItem][parts[0]]];
						} else opt.jsonWhere[fullRelKey] = localization[parts[1]][relItemValue[relKeyItem]];
					} else {
						var fullRelKey = relKeyItem;
						if (!relItemValue[relKeyItem] || typeof relItemValue[relKeyItem] !== "object") fullRelKey += "." + relProto[relKeyItem].$key;
						opt.jsonWhere[fullRelKey] = relItemValue[relKeyItem];
					}
				} else {
					var fullRelKey = relKeyItem;
					var parts = relKeyItem.split(".");
					if (parts.length > 1) {
						opt.jsonWhere[relKeyItem] = localization[parts[1]][relItemValue[parts[0]]];
					} else opt.jsonWhere[fullRelKey] = relItemValue[relKeyItem];
				}
			});
			//              }
			tracer && tracer("jsonImport._importCollection " + relMeta.name + " generate filter: " + sys.inspect(opt.jsonWhere, null, 4));
			relInst = coll.filter(_, opt)[0];
			if (!relInst) {
				tracer && tracer("jsonImport._importCollection not found, creating child");
				relInst = inst.createChild(_, relName, null, null, false, varType);
				coll.set(_, relInst);
			}
			// import
			_importInstance(_, relInst, relItemValue, rp, localization, _pointerTypes);
		} else {
			//references
			relInst = relItemValue ? db.fetchInstance(_, te, _getFilter(_, db, relKey, relItemValue, te, rp, localization)) : null;
			if (relInst && !coll.get(_, relInst.$uuid)) {
				coll.set(_, relInst);
			}
		}
	});
}

// instProto is import prototype of instance, not of the relation

function _importReference(_, inst, relName, variantName, relMeta, instProto, value, localization, _pointerTypes) {
	var key = relName;
	var db = inst._db;
	var rp = variantName ? instProto && instProto[key] && instProto[key].$variants[variantName] : instProto && instProto[key];
	//
	tracer && tracer("jsonImport._importReference: relation: " + key + "; variant: " + variantName + "; relProto: " + sys.inspect(rp));
	// lookup
	var relKey = (rp || {}).$key || "description";
	if (relMeta.getIsChild(variantName) || relMeta.$inlineStore) {
		var relInst = inst[key](_);
		if (!relInst) {
			relInst = inst.createChild(_, key, null, null, false, variantName);
			_importInstance(_, relInst, value, rp, localization, _pointerTypes);
			inst[key](_, relInst);
		} else _importInstance(_, relInst, value, rp, localization, _pointerTypes);
	} else {
		var relInst = null;
		var te = relMeta.getTargetEntity(variantName);
		if (value) {
			var filter = _getFilter(_, db, relKey, value, te, instProto, localization);
			// is filter empty (should get null object) ?
			var isNull = Object.keys(filter.jsonWhere).every(function(k) {
				return (filter.jsonWhere[k] == null) || (filter.jsonWhere[k] == "");
			});
			if (!isNull) {
				relInst = db.fetchInstance(_, te, filter);
				if (!relInst) {
					inst.$addDiagnose("warning", locale.format(module, "referenceMissing", inst._meta.name, relMeta.name,
						te.name, JSON.stringify(filter.jsonWhere || {})));
				} else {
					// ???
				}
			}
		}
		inst[key](_, relInst);
	}
}

function _getLocaleValue(localization, lang, value) {
	return localization[lang] && localization[lang][value];
}

function _importInstance(_, instance, data, itemProto, localization, _pointerTypes) {
	tracer && tracer("jsonImport._importInstance enter: " + instance.$uuid + "; data=" + sys.inspect(data));
	if (data && (typeof data !== "object")) throw new Error(locale.format(module, "objectExpected", data));
	if (itemProto) {
		if (itemProto.$type === "pointer") {
			if (!_pointerTypes[itemProto.$id]) throw new Error(locale.format(module, "pointerTypeNotFound", itemProto.$id));
			itemProto = _pointerTypes[itemProto.$id];
		} else if (itemProto.$id) _pointerTypes[itemProto.$id] = itemProto;
	}
	var entity = instance._meta;
	var inst = instance;
	var db = instance._db;
	flows.eachKey(_, data, function(_, key, value) {

		// do we need to import $ properties ? see later
		if (key[0] === "$") return;
		var relMeta, propMeta;
		if (entity.$relations && (relMeta = entity.$relations[key])) {
			var relProto = itemProto && itemProto[key];
			if (relMeta.isPlural) {
				_importCollection(_, inst, key, relMeta, relProto, value, localization, _pointerTypes);
			} else {
				var varType = relMeta.$variants && value && (value.$variantType || value.$type);
				_importReference(_, inst, key, varType, relMeta, itemProto, value, localization, _pointerTypes);
			}
		} else //
		if (entity.$properties && (propMeta = entity.$properties[key])) {
			if ((typeof value == "string") && itemProto && itemProto.$localized && (itemProto.$localized.indexOf(key) >= 0)) {
				if (propMeta.$isLocalized) {
					var allLocales = {
						"default": _getLocaleValue(localization, "en-us", value) || _getLocaleValue(localization, "en-gb", value) || _getLocaleValue(localization, locale.current, value)
					};
					flows.eachKey(_, localization, function(_, lang, values) {
						allLocales[lang] = values[value];
					});
					inst[key](_, resourceHelpers.parseValue(propMeta, allLocales));
				}
			} else {
				if (propMeta.isExternalStorage() && (typeof value === "object") && value && value.$content) {
					var store = inst[key](_);
					var stream = store.createWritableStream(_, {
						contentType: value.contentType,
						fileName: value.fileName,
						uploadDate: value.uploadDate
					});
					var buf = new Buffer(value.$content, "base64");
					stream.write(_, buf.toString("binary"));
					// write (null) means end
					stream.write(_, null);
					store.uploadDone(_);
				} else inst[key](_, resourceHelpers.parseValue(propMeta, value));
			}
		}
	});
	if (instance.$onImportResource) instance.$onImportResource(_, data, itemProto, localization);
	//tracer && tracer("jsonImport._importInstance exit: "+instance.$uuid+"; exit data="+sys.inspect(instance._data));
}

function _addToSession(_, session, sessionTypesMap, instance, destination) {
	if (!session) return;
	if (!destination) return;
	if (!instance) return;
	//
	var eName = instance.getEntity(_).name;
	var st = sessionTypesMap[eName];
	if (!st) {
		st = session.importTypes(_).add(_);
		st.entityName(_, eName);
		sessionTypesMap[eName] = st;
	}
	st[destination](_).set(_, instance);
}

function _import(_, db, proto, data, localization, options) {
	function _track(phase, detail, progress) {
		var opt = options;
		if (!opt.tracker) return;
		opt.tracker.phase = phase;
		opt.tracker.phaseDetail = detail;
		opt.tracker.progress = progress;
	}

	/*	function _setParent(obj) {
		if (!obj) return;
		Object.keys(obj).forEach(function(kk) {
			var rel = obj[kk];
			if (kk === "$parent") return;
			if (typeof rel !== "object") return;
			if (rel.$variants) {
				Object.keys(rel.$variants).forEach(function(vv) {
					rel.$variants[vv].$parent = obj;
					_setParent(rel.$variants[vv]);
				});
			} else {
				rel.$parent = obj;
				_setParent(rel);
			}
		});
	}*/
	var importMode = options.importMode || "insert";
	//
	var model = db.model;
	// 
	var creCount = 0;
	var updCount = 0;
	var errCount = 0;
	var session = null;
	var sessionTypes = {};
	try {
		if (options.createSession) {
			var admDb = adminHelper.getCollaborationOrm(_);
			var e = admDb.getEntity(_, "importSession");
			session = e.factory.createInstance(_, null, admDb);
			session.description(_, options.sessionDescription || locale.format(module, "genericSessionLabel"));
		}
		// build reverse navigation structure of proto, needed in case of "pointer" relations type
		// _setParent(proto);
		//
		var _pointerTypes = {};
		var idx = 0;
		var l = data.length;
		data.some_(_, function(_, item) {
			tracer && tracer("jsonImport importing item :" + sys.inspect(item));
			//
			_track(locale.format(module, "importing"), item.$type, Math.ceil(idx++ * 100 / l));
			// get 
			var entity = model.getEntity(_, item.$type);
			if (!entity) return;
			var itemProto = proto[item.$type] || {};
			tracer && tracer("jsonImport importing itemProto :" + sys.inspect(itemProto));
			var key = itemProto.$key || "description";
			var filter = _getFilter(_, db, key, item, entity, itemProto, localization);
			tracer && tracer("jsonImport fetchInstance filter :" + sys.inspect(filter));
			var inst = db.fetchInstance(_, entity, filter);

			if (inst && (importMode === "insert")) return (tracer && tracer("jsonImport will not import because in insert only mode")) && false;

			//
			var created = false;
			if (!inst) {
				// create
				inst = entity.factory.createInstance(_, null, db);
				created = true;
			}
			// update data
			_importInstance(_, inst, item, itemProto, localization, _pointerTypes);

			if (inst) {
				if (inst._data.description) {
					var alls = inst.getPropAllLocales(_, "description");
				}
			}
			//

			inst.save(_, null, {
				shallowSerialize: true
			});
			//
			var hasErrors = false;
			var diags = [];
			inst.getAllDiagnoses(_, diags, {
				addPropName: true,
				addEntityName: true
			});

			diags.forEach_(_, function(_, d) {
				d = _normalizeDiag(d);
				// improuve error messages
				var p = itemProto.$value || (Array.isArray(itemProto.$key) ? itemProto.$key[0] : itemProto.$key) || "description";
				var path = p ? helpers.object.walkPath(item, p) : null;

				var lCode = "diagPrefix_" + d.$severity;
				if (path) d.message = locale.format(module, lCode, item.$type, path.resource[path.property], d.$message);

				options && options.$diagnoses && options.$diagnoses.push(d);
				if (session && (d.$severity === "error")) {
					hasErrors = true;
					if (!session.errorDiags(_)) session.errorDiags(_, []);
					session.errorDiags(_).push(d.$message);
				}
				if (session && (d.$severity === "warning")) {
					if (!session.warnDiags(_)) session.warnDiags(_, []);
					session.warnDiags(_).push(d.$message);
				}
			});
			//
			if (hasErrors) {
				errCount++;
				//                tracer && tracer("jsonImport importing item diagnoses: " + item.$type + "; " + sys.inspect(options.$diagnoses));
			} else {
				if (created) {
					creCount++;
					_addToSession(_, session, sessionTypes, inst, "createdObjects");
				} else {
					updCount++;
					_addToSession(_, session, sessionTypes, inst, "updatedObjects");
				}
			}
			if (options && options.$diagnoses) {
				tracer && tracer("jsonImport importing item diagnoses: " + item.$type + "; " + sys.inspect(options.$diagnoses));
			}
			//
			return options.tracker && options.tracker.abortRequested;
		});
		options && options.$diagnoses && options.$diagnoses.push({
			$severity: "info",
			$message: locale.format(module, "importDone", creCount, updCount, errCount)
		});
		//
		session && session.save(_, null, {
			shallowSerialize: true
		});
	} catch (e) {
		// log error
		if (session) {
			if (!session.errorDiags(_)) session.errorDiags(_, []);
			session.errorDiags(_).push(e.message);
			session.save(_, null, {
				shallowSerialize: true
			});
		}
		throw e;
	}
	//
	return session;
}

// just test whether this file should be imported because of file modification time
// data is an array which has the filename as element 0, the checksum of the contents as element 1
// and then hostnames and modification times as further entries
exports.importTest = function(_, filename, data) {
	for (var i = 2; i < data.length; i += 2) {
		if (data[i] === hostname) {
			var fname = fsp.join(__dirname, "../../../import", filename);
			try {
				var modTime = fs.stat(fname, _).mtime.getTime();
				tracer && tracer("Time change in " + filename + ": " + (data[i + 1] !== modTime));
				return (data[i + 1] !== modTime);
			} catch (e) {
				tracer && tracer("Cannot stat file " + filename + ": " + e);
				return false;
			}
		}
	}
	return true;
};


exports.jsonImport = function(_, db, filename, options) {
	//
	options = options || {};
	tracer = tracer || options.tracer || (require("syracuse-main/lib/nodeconfig").config.import || {}).tracer;

	// filename is supposed to be located in "import" folder (same level as node_modules)
	var fname = fsp.join(__dirname, "../../../import", filename);
	if (options.data) {
		// find out whether file really has to be integrated. Check modification time first, then checksum of content.
		// data is an array which has the filename as element 0, the checksum of the contents as element 1
		// and then hostnames and modification times as further entries
		var automaticData = options.data;
		try {
			var modTime = fs.stat(fname, _).mtime.getTime();
		} catch (e) {
			tracer && tracer("Cannot stat the file " + fname + ": " + e);
			return true;
		}
		for (var i = 2; i < automaticData.length; i += 2) {
			if (automaticData[i] === hostname) {
				if (automaticData[i + 1] === modTime) {
					tracer && tracer("No modification " + fname);
					return true;
				}
				automaticData[i + 1] = modTime;
				break;
			}
		}
		if (i >= automaticData.length) { // host not found
			automaticData.push(hostname, modTime);
		}
		// remove old data of other hosts
		if (automaticData.length > 4) {
			var currentTime = Date.now();
			for (var i = 2; i < automaticData.length; i += 2) {
				if (automaticData[i] !== hostname && (currentTime - automaticData[i + 1]) > 8640000000) {
					tracer && tracer(filename + ": Remove host " + automaticData[i]);
					automaticData.splice(i, 2);
				}

			}

		}
		// find checksum
		var input = fs.readFile(fname, _);
		var hash = crypto.createHash('SHA1');
		hash.update(input);

		var h = hash.digest("hex");
		if (h === automaticData[1]) {
			// no modification
			tracer && tracer("No content modification " + fname);
			return;
		}
		automaticData[1] = h;

		var input = JSON.parse(input.toString("utf8"));
		console.log("File import " + fname);
	} else {
		var input = JSON.parse(fs.readFile(fname, "utf8", _));
	}
	var proto = input.$prototypes || {};
	var data = input.$items || [];
	var localization = input.$localization || {};
	// includes (only after, TODO before)
	if (input.$includeAfter) {
		input.$includeAfter.forEach_(_, function(_, includeFile) {
			var include = JSON.parse(fs.readFile(fsp.join(__dirname, "../../../import", includeFile + ".json"), "utf8", _));
			if (include.$prototypes)
				for (var p in include.$prototypes) proto[p] = include.$prototypes[p];
			(include.$items || []).forEach(function(item) {
				data.push(item);
			});

			//localization["en-us"][l] = include.$localization["en-us"][l];

			//for each language
			flows.eachKey(_, localization, function(_, lang, values) {
				for (var l in include.$localization[lang]) {
					localization[lang][l] = include.$localization[lang][l];
				}
			});
		});
	}

	_import(_, db, proto, data, localization, options);

	tracer && tracer("Import diagnoses: " + sys.inspect(options.$diagnoses));
};

exports.streamImport = function(_, db, stream, options) {
	//
	options = options || {};
	tracer = tracer || options.tracer || (require("syracuse-main/lib/nodeconfig").config.import || {}).tracer;
	options.$diagnoses = options.$diagnoses || [];
	// filename is supposed to be located in "import" folder (same level as node_modules)
	var input = JSON.parse(stream.readAll(_));
	var proto = input.$prototypes || {};
	var data = input.$items || [];
	var localization = input.$localization || {};
	//
	var s = _import(_, db, proto, data, localization, options);
	//
	return {
		$url: s && "{$baseUrl}/importSessions('" + s.$uuid + "')?representation=importSession.$details",
		$uuid: s && s.$uuid,
		$diagnoses: options.$diagnoses
	};

};

exports.jsonImportFromJson = function(_, user, input, options) {
	tracer = tracer || options.tracer || (require("syracuse-main/lib/nodeconfig").config.import || {}).tracer;
	input = typeof input === "object" ? input : JSON.parse(input);
	var db = adminHelper.getCollaborationOrm(_);
	options.$diagnoses = options.$diagnoses || [];
	_import(_, db, input.$prototypes, input.$items, input.$localization, options);
	return options.$diagnoses;
};

exports.$exported = true;