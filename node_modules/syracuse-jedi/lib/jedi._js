"use strict";

/*
  JEDI V 0.01

  TODO :
- Classe de gestion d'un AFB120 (read/write) prennant en paramètre le $type de flux (file/string)
 => read(new JediFile(....),....)
 l'exploiter pour
  - créer un json
  - visualiser le fichier (PDF !)
  - autre
  si OK => transformer tous les traitements !
- Bibliothèque de formats (conversion...): 
 - AFB
 - Edifact
 - Swift
 - Vérification du format
 - Contrôle sur propriété
 - Gestion de l’escape
- Tester le httpRequest de streams (conversions…) => gmail + vysaje (C:\Users\eboyard\Dropbox\dev\node_modules\streamline\examples\streams)
*/
var path    = require("path");
var config  = require('config');
var tracer  = (config.jedi && config.jedi.debug)?config.jedi.debug:null;

var fs = require('fs');
var streams  = require('streamline/lib/streams/server/streams');

function typeObject() {
  this.parse = function(_,_buffer,_reader) {
    /*dbg*/this.jedi.logBuffer("object.parse:",_buffer);
    var item = {}; // Creates a new object 
    var proVal;
    var proBuffer = _buffer;

    for(var property in this.$type.$properties) {
      // Add a data property to the object.
      /*dbg*/tracer && tracer.log("object property:",property);
      /*dbg*/this.jedi.logBuffer("object."+property+":",proBuffer);
      if((proVal  = this.jedi.parse(_,this.$type.$properties[property],proBuffer,_reader)) != null) {
        item[property] = proVal;
        this.$type.$next = this.$type.$properties[property].$next;
        proBuffer        = this.$type.$next;
        
        /*dbg*/this.jedi.logBuffer("object."+property+" next:",this.$type.$next);

      } else {
        /*dbg*/tracer && tracer.log("bad structure");
        return null;
      }
    }
    /*dbg*///!tracer && tracer.log("object.parsed:");
    /*dbg*///!tracer && tracer.log(item);
    return item;
  }
  
  this.write = function (_item) {
    /*dbg*/tracer && tracer.log("object.write:",_item);
    var buffer =""
    
    for(var property in this.$type.$properties) {
      /*dbg*/tracer && tracer.log("property:",property);
      buffer += this.jedi.write(_item[property],this.$type.$properties[property]);
    }   
    return buffer;
  }
}

function typeArray() {
  this.parse = function(_,_buffer,_reader) {
    /*dbg*/this.jedi.logBuffer("array.parse:",_buffer);
    var arr = []; // Creates a new array
    var item; 
    var proVal;
    var proBuffer = _buffer;
    var nbrItems  = 0;
    var maxItems  = this.$type.$maxItems || 0;
    if("$item" in this.$type) {
      this.jedi.logBuffer("array parse buffer:",proBuffer);
  
      while((item = this.jedi.parse(_,this.$type.$item,proBuffer,_reader)) != null) {
        arr.push(item);
        proBuffer = this.$type.$item.$next;
        this.jedi.logBuffer("array parse buffer:",proBuffer);
        this.$type.$next = this.$type.$item.$next;
        if((maxItems > 0) && (++nbrItems==maxItems)) {
          break;
        }
      }
    }
    tracer && tracer.log("end of array");
    return arr;
  }
  
  this.write = function (_item) {
    var buffer =""
    /*dbg*/tracer && tracer.log("array.write:",_item);
    if("$item" in this.$type) {
      for(var i in _item) {
        buffer += this.jedi.write(_item[i],this.$type.$item);
      }
    }
    return buffer;
  }
}

function typeString() {
  this.parse = function(_,_buffer,_reader) {
    /*dbg*/this.jedi.logBuffer("string.parse:",_buffer);
    return _buffer;
  }
  this.write = function(_item) {
    /*dbg*/tracer && tracer.log("string.write:",_item);
    if(_item == null) return "";
    
    if("$length" in this) {
        return _item.substring(0,this.$length);
      }
    return _item;
  }
}

function typeNumber(){
  this.parse = function(_,_buffer,_reader) {
    try {
      /*dbg*/tracer && tracer.log("number.parse(_,:",_buffer,")");
      if ("$format" in this.$type) {
        var decSep="";
        var thSep="";
        for(var i = this.$type.$format.length-1;i>=0;i--) {
          /*dbg*/tracer && tracer.log("f:",this.$type.$format[i],i);
          if(this.$type.$format[i] == '.' || this.$type.$format[i] == ',') {
            if(0 == decSep.length) {
             decSep = this.$type.$format[i];
            } else { 
             thSep = this.$type.$format[i];
            }
          }
        }
        /*dbg*/tracer && tracer.log("decSep:",decSep,"thSep",thSep);
        if (thSep.length) {
          _buffer = _buffer.replace(thSep ,"");
        }
        if (decSep.length) {
          _buffer = _buffer.replace(decSep,"."); 
        } 
      }
      /*dbg*/tracer && tracer.log("parse(_,Float:",_buffer);
      return parseFloat(_buffer); 
    
    } catch(e) {
      tracer && tracer.log("warning bad number:",_buffer,"e:",e);
    }
    return 0;
  }
  this.write = function (_number) {
    /*dbg*/tracer && tracer.log("writeNumber:",_number);
    
    if(!("$format" in this.$type)) {
      /*dbg*/tracer && tracer.log("$format not in",this);
      console.log(this);
      return _number.toString();
    }  
  
    var sep  = '';
    var seps = [",","."];
    var toFixed = 0;
    var aFormat = null;
    
    /*dbg*/tracer && tracer.log("separators ?");
    //1°) separator and number of decimals:
    for(var i in seps) {
      aFormat = this.$type.$format.split(seps[i]); 
      if(2 == aFormat.length) {
        sep = seps[i];
        toFixed = aFormat[1].length;
        break;
      }
    }
    var sBuffer = _number.toFixed(toFixed);
    /*dbg*/tracer && tracer.log("sep",sep,"toFixed",toFixed,":",sBuffer,aFormat);
    
    //2°) format:
    var aParts = sBuffer.toString().split('.');
    /*dbg*/tracer && tracer.log(aParts);
  
    function writeNumberPart(_part,_format) {
      /*dbg*/tracer && tracer.log("writeNumberPart",_part,_format);
      var s="";
      var j=0;
      for(var i in _format) {
        switch(_format[i]) {
          case '0':
            s += (j < _part.length)?_part[j++]:'0';
            break;
          case '#':
            s += (j < _part.length)?_part[j++]:' ';
            break;
          default:
            s += _format[i];
            break;    
        }
      }
      return s;
    }
    
    var sNumber="";
    var part0 = aParts[0].split('').reverse().join('');
    var format0 = aFormat[0].split('').reverse().join('');
    var sNumber = writeNumberPart(part0,format0);
    sNumber = sNumber.split('').reverse().join('');
    if(toFixed > 0){
      sNumber += sep + writeNumberPart(aParts[1],aFormat[1]);
    } 
   
    return sNumber.trim();
  }  
}

function typeDate(){
  this.parse = function(_,_buffer,_reader){
    var items = {"D":0,"M":0,"Y":0};
    var date = new Date();
  
    try {
      /*dbg*/tracer && tracer.log("date.parse(_,:",_buffer,this);
      if(null != _buffer && null != this.$type.$format) {
        for(var i=0,j=0;i <this.$type.$format.length;i++) {
          if(this.$type.$format[i] in items && _buffer[j].match(/[0-9]/))  {
           items[this.$type.$format[i]] = 10*items[this.$type.$format[i]]+ parseInt(_buffer[j++]);
          } else if(this.$type.$format[i] == _buffer[j] ) {
            j++;
          }
        }
        items.Y += (items.Y < 100)?2000:0;
        date = new Date(items.Y,items.M-1,items.D);
      }
    } catch(e) {
      tracer && tracer.log("warning bad date:",_buffer,", expected format:",this.$type.$format)
    }
    return date;
  }
  
  this.write = function (_date) {
    var date = _date;
    if(toString.call(date).indexOf("String") > -1) {
      date = new Date(Date.parse(_date));
    }
    
    var tokens = {
        "Y": {"value":null,"at":0},
        "M": {"value":null,"at":0},
        "D": {"value":null,"at":0}
    };
    tokens.Y.value = date.getFullYear().toString();
    tokens.M.value = "0"+(date.getMonth()+1).toString();
    tokens.D.value = "0"+date.getDate().toString();
    for(var i in tokens) {
      tokens[i].at = tokens[i].value.length -1;
    }
    var at = this.$type.$format.length;
    var buffer='';
    while(  --at >= 0) {
      var  c = this.$type.$format.substring(at,at+1);
      var nc = '';
      if(c in tokens && tokens[c].at > -1) {
        nc = tokens[c].value.substring(tokens[c].at,tokens[c].at+1);
        tokens[c].at--;
        c = nc;
      }
      buffer = c + buffer;
    }
    return buffer;
  }  
}

function typeCFONBAmount(){
  this.parse = function(_,_buffer,_reader) {
    var begin = _buffer.substring(0,_buffer.length-1);
    var end   = _buffer.substring(_buffer.length-1,_buffer.length);
    var sign=+1
    if(end == '{') {
      end = '0';
    }
    else if(end == '}') {
      sign = -1
      end = '0';
    }
    //'0'.charCodeAt(0) = 48
    //'J'.charCodeAt(0) = 74
    else if((end.charCodeAt(0)-74)>0) {
      sign = -1;
      end = String.fromCharCode(49+end.charCodeAt(0)-74);
    }
    //'A'.charCodeAt(0) = 65
    else if((end.charCodeAt(0)-65)>0) {
      end = String.fromCharCode(49+end.charCodeAt(0)-65);
    }
    return sign*parseFloat(begin+end);
  }
  
  this.write = function (_item) {
    console.log("***CFONBAmount.write***");
    return "TBI";
  }

}


var Jedi = function(_options){
  
  this.logBuffer  = function(_msg,_buffer) {
    if(tracer) {
      var buffer = _buffer;
      buffer += "..."
      tracer.log(_msg,buffer.substring(0,40));
    }
  }  
  
  tracer && tracer.log("new Jedi");
  
  this.getTypeHandler = function(_$type){
    /*dbg*/tracer && tracer.log("jedi.getTypeHandler(",_$type.$type,")");  
    if(_$type.$parser) return _$type.$parser;
    
    var typeHandler="";
    
    if(_$type.$type){
      typeHandler = _$type.$type;
    } else if(_$type.$properties) {
      typeHandler = "object";
    } else if(_$type.$item) {
      typeHandler = "array";
    } 
    /*dbg*/tracer && tracer.log("jedi.getTypeHandler typeHandler=",typeHandler);  
    var handler = null;
    if(typeHandler in this.types) { 
      handler = eval("new " + this.types[typeHandler] + "()");
     } else {
      /*dbg*/tracer && tracer.log("jedi.getTypeHandler require:",typeHandler);  
      //var module = require(typeHandler);
      var items = typeHandler.split('/');
      eval("var "+items[items.length-1]+" = require('"+typeHandler+"._js')");
      handler = eval("new " + items[items.length-1] + "()");
    } 
    if(handler != null) {
      handler.jedi   = this;
      handler.name   = typeHandler;
      handler.$type  = _$type;
    }
    return handler;
  }
 
  this.parse = function(_,_$type,_buffer,_reader) {
    var  nextPos = 0;
    var itemBuffer  = null; 
    if(_buffer == null){
      var rBuffer = _reader.readStream(_);
      if(!rBuffer.length){
       /*dbg*/tracer && tracer.log("jedi.parse empty buffer");  
        return null;
      }
      _buffer += rBuffer;
    }
     /*dbg*/tracer && tracer.log("->jedi.parse _$type:",_$type.$type);  
    /*dbg*/this.logBuffer("->jedi.parse _buffer:",_buffer);  
    
    //!if(!_buffer.length) return null;  
    
    if("$length" in _$type) {
      if(_$type.$length <= _buffer.length) {
        nextPos      = _$type.$length;
        itemBuffer   = _buffer.substring(0,_$type.$length);
        if("$after" in _$type) {
          if (toString.call(_$type.$after) != '[object Array]' ){
            var afters = new Array(_$type.$after)
          } else {
            var afters = _$type.$after
          } 
          for(var i in afters)  {
            /*dbg*///tracer && tracer.log("$after:",afters[i]);
            var t = _buffer.substring(nextPos,nextPos+afters[i].length);
            /*dbg*///tracer && tracer.log("t:",t);
            if(t == afters[i]) {
              nextPos    += afters[i].length;
              break;
            }
          }
        }
      }
    }
    else {
      if("$after" in _$type) {
        if (toString.call(_$type.$after) != '[object Array]' ){
          var afters = new Array(_$type.$after)
        } else {
          var afters = _$type.$after
        } 
        for(var i in afters)  {
          /*dbg*/tracer && tracer.log("$after:",afters[i]);
          if(afters[i] == null && _reader.eof) {
            itemBuffer = _buffer;
            nextPos    = _buffer.length;
            /*dbg*/tracer && tracer.log("$after=null nextPos=",nextPos);
            break; 
          } else {
            var pos   = _buffer.indexOf(afters[i],0);
            if(pos > -1) {
              itemBuffer = _buffer.substring(0,pos);
              nextPos     =  pos+afters[i].length; 
              /*dbg*/tracer && tracer.log("$after<>null nextPos=",nextPos);
              break;
            } 
          }
         } 
       } else {
        itemBuffer = _buffer;
        nextPos    = 0;//-1; 
      }
      if("$before" in _$type) {
        itemBuffer = itemBuffer.substring(_$type.$before.length);
      }   
    }
    var item = null;
    if(itemBuffer != null) {

      if("$regex" in _$type) {
        /*dbg*/tracer && tracer.log("$regex=",_$type.$regex);
        var regex = new RegExp(_$type.$regex);
        var items = regex.exec(itemBuffer);
        if(items == null || items.length != 1 || items[0] != itemBuffer) {
          /*dbg*/tracer && tracer.log(itemBuffer," doesn't match ",_$type.$regex);
          /*dbg*/tracer && tracer.log(_$type);
          return null;
        }
        /*dbg*/tracer && tracer.log(itemBuffer," matches ",_$type.$regex);
      }   

      if((item = this.getTypeHandler(_$type).parse(_,itemBuffer,_reader))!=  null) {
        /*dbg*/tracer && tracer.log("-> parse _$type.name:",this.getTypeHandler(_$type).name,"nextPos=",nextPos,"buffer.length=",_buffer.length);
        if(nextPos > 0 && _buffer.substring(nextPos).length) {   
          _$type.$next = _buffer.substring(nextPos); 
          /*dbg*/this.logBuffer("next >",_$type.$next);  
        } else if (nextPos == -1) {
          _$type.$next = null; 
          /*dbg*/tracer && tracer.log("next > null");  
        }
      }
    } else {
      /*dbg*/tracer && tracer.log("itemBuffer = null");  
      var rBuffer = _reader.readStream(_);
      if (rBuffer.length) {
        _buffer += rBuffer;
        item = this.parse(_,_$type,_buffer,_reader) ;
      }
    }
    if(item != null){
      tracer && tracer.log("jedi.parse=item"); 
    } else {
      tracer && tracer.log("jedi.parse=null"); 
    }   
    return item;
  }



  this.write = function(_item,_$type){
    /*dbg*/tracer && tracer.log("jedi.write:",_$type.$type,_item);
    var $typeBuffer = ""
    var itemBuffer = ""
    
    
    if("$before" in _$type) {
      $typeBuffer += _$type.$before;
    }
    
    if (_item) {
      itemBuffer = this.getTypeHandler(_$type).write(_item);
    } else {
      itemBuffer = "";
    }
    if("$length" in _$type) {
      itemBuffer =  (itemBuffer + Array(_$type.$length).join(" ")).substring(0,_$type.$length);
    }  
    $typeBuffer += itemBuffer;
    
    if("$after" in _$type) {
       $typeBuffer +=  _$type.$after; 
    }
    /*dbg*/tracer && tracer.log("jedi.write=",$typeBuffer);
    return $typeBuffer
  }
  
  this.map = function(_,_structure) {
    /*dbg*/tracer && tracer.log("jedi.map:",_structure);
  	return _structure.parse(_,this.buffer,true)
  }
  this.types=[];
  
  this.addType = function(_type,_typeHandler) {
    this.types[_type]= _typeHandler;
  }
  this.addType("object" ,"typeObject");
  this.addType("string" ,"typeString");
  this.addType("number" ,"typeNumber");
  this.addType("date"   ,"typeDate");
  this.addType("array"  ,"typeArray"); 
  this.addType("CFONBAmount"  ,"typeCFONBAmount"); 
  
  /*dbg*/tracer && tracer.log("new Jedi:",this) ;
}
 
module.exports = Jedi;

