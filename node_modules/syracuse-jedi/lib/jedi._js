"use strict";

/*
  JEDI V 0.01

  TODO :
- Classe de gestion d'un AFB120 (read/write) prennant en param�tre le $type de flux (file/string)
 => read(new JediFile(....),....)
 l'exploiter pour
  - cr�er un json
  - visualiser le fichier (PDF !)
  - autre
  si OK => transformer tous les traitements !
- Biblioth�que de formats (conversion...): 
 - AFB
 - Edifact
 - Swift
 - V�rification du format
 - Contr�le sur propri�t�
 - Gestion de l�escape
- Tester le httpRequest de streams (conversions�) => gmail + vysaje (C:\Users\eboyard\Dropbox\dev\node_modules\streamline\examples\streams)
*/
var path = require("path");
var config = require('config');
var tracer = (config.jedi && config.jedi.debug) ? config.jedi.debug : null;

var fs = require('fs');
var streams = require('streamline/lib/streams/server/streams');

function typeObject() {
	this.parse = function(_, _buffer, _reader) {
		/*dbg*/
		this.jedi.logBuffer("object.parse:", _buffer);
		var item = {}; // Creates a new object 
		var proVal;
		var proBuffer = _buffer;

		for (var property in this.$type.$properties) {
			// Add a data property to the object.
			/*dbg*/
			tracer && tracer.log("object property:", property);
			/*dbg*/
			this.jedi.logBuffer("object." + property + ":", proBuffer);
			if ((proVal = this.jedi.parse(_, this.$type.$properties[property], proBuffer, _reader)) != null) {
				item[property] = proVal;
				this.$type.$next = this.$type.$properties[property].$next;
				proBuffer = this.$type.$next;

				/*dbg*/
				this.jedi.logBuffer("object." + property + " next:", this.$type.$next);

			} else {
				/*dbg*/
				tracer && tracer.log("bad structure");
				return null;
			}
		}
		/*dbg*/ //!tracer && tracer.log("object.parsed:");
		/*dbg*/ //!tracer && tracer.log(item);
		return item;
	};

	this.write = function(_item) {
		/*dbg*/
		tracer && tracer.log("object.write:", _item);
		var buffer = "";

		for (var property in this.$type.$properties) {
			/*dbg*/
			tracer && tracer.log("property:", property);
			buffer += this.jedi.write(_item[property], this.$type.$properties[property]);
		}
		return buffer;
	};
}

function typeArray() {
	this.parse = function(_, _buffer, _reader) {
		/*dbg*/
		this.jedi.logBuffer("array.parse:", _buffer);
		var arr = []; // Creates a new array
		var item;
		var proVal;
		var proBuffer = _buffer;
		var nbrItems = 0;
		var maxItems = this.$type.$maxItems || 0;
		if ("$item" in this.$type) {
			this.jedi.logBuffer("array parse buffer:", proBuffer);

			while ((item = this.jedi.parse(_, this.$type.$item, proBuffer, _reader)) != null) {
				arr.push(item);
				proBuffer = this.$type.$item.$next;
				this.jedi.logBuffer("array parse buffer:", proBuffer);
				this.$type.$next = this.$type.$item.$next;
				if ((maxItems > 0) && (++nbrItems == maxItems)) {
					break;
				}
			}
		}
		tracer && tracer.log("end of array");
		return arr;
	};

	this.write = function(_item) {
		var buffer = "";
		/*dbg*/
		tracer && tracer.log("array.write:", _item);
		if ("$item" in this.$type) {
			for (var i in _item) {
				buffer += this.jedi.write(_item[i], this.$type.$item);
			}
		}
		return buffer;
	};
}

function typeString() {
	this.parse = function(_, _buffer, _reader) {
		/*dbg*/
		this.jedi.logBuffer("string.parse:", _buffer);
		return _buffer;
	};
	this.write = function(_item) {
		/*dbg*/
		tracer && tracer.log("string.write:", _item);
		if (_item == null) return "";

		if ("$length" in this) {
			return _item.substring(0, this.$length);
		}
		return _item;
	};
}

function typeNumber() {
	this.parse = function(_, _buffer, _reader) {
		try {
			/*dbg*/
			tracer && tracer.log("number.parse(_,:", _buffer, ")");
			if ("$format" in this.$type) {
				var decSep = "";
				var thSep = "";
				for (var i = this.$type.$format.length - 1; i >= 0; i--) {
					/*dbg*/
					tracer && tracer.log("f:", this.$type.$format[i], i);
					if (this.$type.$format[i] == '.' || this.$type.$format[i] == ',') {
						if (0 == decSep.length) {
							decSep = this.$type.$format[i];
						} else {
							thSep = this.$type.$format[i];
						}
					}
				}
				/*dbg*/
				tracer && tracer.log("decSep:", decSep, "thSep", thSep);
				if (thSep.length) {
					_buffer = _buffer.replace(thSep, "");
				}
				if (decSep.length) {
					_buffer = _buffer.replace(decSep, ".");
				}
			}
			/*dbg*/
			tracer && tracer.log("parse(_,Float:", _buffer);
			return parseFloat(_buffer);

		} catch (e) {
			tracer && tracer.log("warning bad number:", _buffer, "e:", e);
		}
		return 0;
	};
	this.write = function(_number) {
		/*dbg*/
		tracer && tracer.log("writeNumber:", _number);

		if (!("$format" in this.$type)) {
			/*dbg*/
			tracer && tracer.log("$format not in", this);
			console.log(this);
			return _number.toString();
		}

		var sep = '';
		var seps = [",", "."];
		var toFixed = 0;
		var aFormat = null;

		/*dbg*/
		tracer && tracer.log("separators ?");
		//1�) separator and number of decimals:
		for (var i in seps) {
			aFormat = this.$type.$format.split(seps[i]);
			if (2 == aFormat.length) {
				sep = seps[i];
				toFixed = aFormat[1].length;
				break;
			}
		}
		var sBuffer = _number.toFixed(toFixed);
		/*dbg*/
		tracer && tracer.log("sep", sep, "toFixed", toFixed, ":", sBuffer, aFormat);

		//2�) format:
		var aParts = sBuffer.toString().split('.');
		/*dbg*/
		tracer && tracer.log(aParts);

		function writeNumberPart(_part, _format) {
			/*dbg*/
			tracer && tracer.log("writeNumberPart", _part, _format);
			var s = "";
			var j = 0;
			for (var i in _format) {
				switch (_format[i]) {
					case '0':
						s += (j < _part.length) ? _part[j++] : '0';
						break;
					case '#':
						s += (j < _part.length) ? _part[j++] : ' ';
						break;
					default:
						s += _format[i];
						break;
				}
			}
			return s;
		}

		var sNumber = "";
		var part0 = aParts[0].split('').reverse().join('');
		var format0 = aFormat[0].split('').reverse().join('');
		var sNumber = writeNumberPart(part0, format0);
		sNumber = sNumber.split('').reverse().join('');
		if (toFixed > 0) {
			sNumber += sep + writeNumberPart(aParts[1], aFormat[1]);
		}

		return sNumber.trim();
	};
}

function typeDate() {
	this.parse = function(_, _buffer, _reader) {
		var items = {
			"D": 0,
			"M": 0,
			"Y": 0
		};
		var date = new Date();

		try {
			/*dbg*/
			tracer && tracer.log("date.parse(_,:", _buffer, this);
			if (null != _buffer && null != this.$type.$format) {
				for (var i = 0, j = 0; i < this.$type.$format.length; i++) {
					if (this.$type.$format[i] in items && _buffer[j].match(/[0-9]/)) {
						items[this.$type.$format[i]] = 10 * items[this.$type.$format[i]] + parseInt(_buffer[j++]);
					} else if (this.$type.$format[i] == _buffer[j]) {
						j++;
					}
				}
				items.Y += (items.Y < 100) ? 2000 : 0;
				date = new Date(items.Y, items.M - 1, items.D);
			}
		} catch (e) {
			tracer && tracer.log("warning bad date:", _buffer, ", expected format:", this.$type.$format);
		}
		return date;
	};

	this.write = function(_date) {
		var date = _date;
		if (toString.call(date).indexOf("String") > -1) {
			date = new Date(Date.parse(_date));
		}

		var tokens = {
			"Y": {
				"value": null,
				"at": 0
			},
			"M": {
				"value": null,
				"at": 0
			},
			"D": {
				"value": null,
				"at": 0
			}
		};
		tokens.Y.value = date.getFullYear().toString();
		tokens.M.value = "0" + (date.getMonth() + 1).toString();
		tokens.D.value = "0" + date.getDate().toString();
		for (var i in tokens) {
			tokens[i].at = tokens[i].value.length - 1;
		}
		var at = this.$type.$format.length;
		var buffer = '';
		while (--at >= 0) {
			var c = this.$type.$format.substring(at, at + 1);
			var nc = '';
			if (c in tokens && tokens[c].at > -1) {
				nc = tokens[c].value.substring(tokens[c].at, tokens[c].at + 1);
				tokens[c].at--;
				c = nc;
			}
			buffer = c + buffer;
		}
		return buffer;
	};
}

function typeCFONBAmount() {
	this.parse = function(_, _buffer, _reader) {
		var begin = _buffer.substring(0, _buffer.length - 1);
		var end = _buffer.substring(_buffer.length - 1, _buffer.length);
		var sign = +1;
		if (end == '{') {
			end = '0';
		} else if (end == '}') {
			sign = -1;
			end = '0';
		}
		//'0'.charCodeAt(0) = 48
		//'J'.charCodeAt(0) = 74
		else if ((end.charCodeAt(0) - 74) > 0) {
			sign = -1;
			end = String.fromCharCode(49 + end.charCodeAt(0) - 74);
		}
		//'A'.charCodeAt(0) = 65
		else if ((end.charCodeAt(0) - 65) > 0) {
			end = String.fromCharCode(49 + end.charCodeAt(0) - 65);
		}
		return sign * parseFloat(begin + end);
	};

	this.write = function(_item) {
		console.log("***CFONBAmount.write***");
		return "TBI";
	};

}


var Jedi = function(_options) {

	this.logBuffer = function(_msg, _buffer) {
		if (tracer) {
			var buffer = _buffer;
			buffer += "...";
			tracer.log(_msg, buffer.substring(0, 40));
		}
	};

	tracer && tracer.log("new Jedi");

	this.getTypeHandler = function(_$type) {
		/*dbg*/
		tracer && tracer.log("jedi.getTypeHandler(", _$type.$type, ")");
		if (_$type.$parser) return _$type.$parser;

		var typeHandler = "";

		if (_$type.$type) {
			typeHandler = _$type.$type;
		} else if (_$type.$properties) {
			typeHandler = "object";
		} else if (_$type.$item) {
			typeHandler = "array";
		}
		/*dbg*/
		tracer && tracer.log("jedi.getTypeHandler typeHandler=", typeHandler);
		var handler = null;
		if (typeHandler in this.types) {
			handler = eval("new " + this.types[typeHandler] + "()");
		} else {
			/*dbg*/
			tracer && tracer.log("jedi.getTypeHandler require:", typeHandler);
			//var module = require(typeHandler);
			var items = typeHandler.split('/');
			eval("var " + items[items.length - 1] + " = require('" + typeHandler + "._js')");
			handler = eval("new " + items[items.length - 1] + "()");
		}
		if (handler != null) {
			handler.jedi = this;
			handler.name = typeHandler;
			handler.$type = _$type;
		}
		return handler;
	};

	this.parse = function(_, _$type, _buffer, _reader) {
		var nextPos = 0;
		var itemBuffer = null;
		if (_buffer == null) {
			var rBuffer = _reader.readStream(_);
			if (!rBuffer.length) {
				/*dbg*/
				tracer && tracer.log("jedi.parse empty buffer");
				return null;
			}
			_buffer += rBuffer;
		}
		/*dbg*/
		tracer && tracer.log("->jedi.parse _$type:", _$type.$type);
		/*dbg*/
		this.logBuffer("->jedi.parse _buffer:", _buffer);

		//!if(!_buffer.length) return null;  

		if ("$length" in _$type) {
			if (_$type.$length <= _buffer.length) {
				nextPos = _$type.$length;
				itemBuffer = _buffer.substring(0, _$type.$length);
				if ("$after" in _$type) {
					if (toString.call(_$type.$after) != '[object Array]') {
						var afters = new Array(_$type.$after);
					} else {
						var afters = _$type.$after;
					}
					for (var i in afters) {
						/*dbg*/ //tracer && tracer.log("$after:",afters[i]);
						var t = _buffer.substring(nextPos, nextPos + afters[i].length);
						/*dbg*/ //tracer && tracer.log("t:",t);
						if (t == afters[i]) {
							nextPos += afters[i].length;
							break;
						}
					}
				}
			}
		} else {
			if ("$after" in _$type) {
				if (toString.call(_$type.$after) != '[object Array]') {
					var afters = new Array(_$type.$after);
				} else {
					var afters = _$type.$after;
				}
				for (var i in afters) {
					/*dbg*/
					tracer && tracer.log("$after:", afters[i]);
					if (afters[i] == null && _reader.eof) {
						itemBuffer = _buffer;
						nextPos = _buffer.length;
						/*dbg*/
						tracer && tracer.log("$after=null nextPos=", nextPos);
						break;
					} else {
						var pos = _buffer.indexOf(afters[i], 0);
						if (pos > -1) {
							itemBuffer = _buffer.substring(0, pos);
							nextPos = pos + afters[i].length;
							/*dbg*/
							tracer && tracer.log("$after<>null nextPos=", nextPos);
							break;
						}
					}
				}
			} else {
				itemBuffer = _buffer;
				nextPos = 0; //-1; 
			}
			if ("$before" in _$type) {
				itemBuffer = itemBuffer.substring(_$type.$before.length);
			}
		}
		var item = null;
		if (itemBuffer != null) {

			if ("$regex" in _$type) {
				/*dbg*/
				tracer && tracer.log("$regex=", _$type.$regex);
				var regex = new RegExp(_$type.$regex);
				var items = regex.exec(itemBuffer);
				if (items == null || items.length != 1 || items[0] != itemBuffer) {
					/*dbg*/
					tracer && tracer.log(itemBuffer, " doesn't match ", _$type.$regex);
					/*dbg*/
					tracer && tracer.log(_$type);
					return null;
				}
				/*dbg*/
				tracer && tracer.log(itemBuffer, " matches ", _$type.$regex);
			}

			if ((item = this.getTypeHandler(_$type).parse(_, itemBuffer, _reader)) != null) {
				/*dbg*/
				tracer && tracer.log("-> parse _$type.name:", this.getTypeHandler(_$type).name, "nextPos=", nextPos, "buffer.length=", _buffer.length);
				if (nextPos > 0 && _buffer.substring(nextPos).length) {
					_$type.$next = _buffer.substring(nextPos);
					/*dbg*/
					this.logBuffer("next >", _$type.$next);
				} else if (nextPos == -1) {
					_$type.$next = null;
					/*dbg*/
					tracer && tracer.log("next > null");
				}
			}
		} else {
			/*dbg*/
			tracer && tracer.log("itemBuffer = null");
			var rBuffer = _reader.readStream(_);
			if (rBuffer.length) {
				_buffer += rBuffer;
				item = this.parse(_, _$type, _buffer, _reader);
			}
		}
		if (item != null) {
			tracer && tracer.log("jedi.parse=item");
		} else {
			tracer && tracer.log("jedi.parse=null");
		}
		return item;
	};



	this.write = function(_item, _$type) {
		/*dbg*/
		tracer && tracer.log("jedi.write:", _$type.$type, _item);
		var $typeBuffer = "";
		var itemBuffer = "";


		if ("$before" in _$type) {
			$typeBuffer += _$type.$before;
		}

		if (_item) {
			itemBuffer = this.getTypeHandler(_$type).write(_item);
		} else {
			itemBuffer = "";
		}
		if ("$length" in _$type) {
			itemBuffer = (itemBuffer + Array(_$type.$length).join(" ")).substring(0, _$type.$length);
		}
		$typeBuffer += itemBuffer;

		if ("$after" in _$type) {
			$typeBuffer += _$type.$after;
		}
		/*dbg*/
		tracer && tracer.log("jedi.write=", $typeBuffer);
		return $typeBuffer;
	};

	this.map = function(_, _structure) {
		/*dbg*/
		tracer && tracer.log("jedi.map:", _structure);
		return _structure.parse(_, this.buffer, true);
	};
	this.types = [];

	this.addType = function(_type, _typeHandler) {
		this.types[_type] = _typeHandler;
	};
	this.addType("object", "typeObject");
	this.addType("string", "typeString");
	this.addType("number", "typeNumber");
	this.addType("date", "typeDate");
	this.addType("array", "typeArray");
	this.addType("CFONBAmount", "typeCFONBAmount");

	/*dbg*/
	tracer && tracer.log("new Jedi:", this);
};

module.exports = Jedi;