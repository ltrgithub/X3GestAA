"use strict";
var tools = require()
exports.parser = function(request) {
	var contentType = request.headers["content-type"],
		match;
	if (!(match = /^multipart\/(form-data|mixed)/.exec(contentType))) return;
	var subType = match[1];
	var atbs = contentType.split(/\s*;\s*/).reduce(function(r, s) {
		var kv = s.split(/\s*=\s*/);
		r[kv[0]] = kv[1];
		return r;
	}, {});
	var boundary = atbs.boundary;
	if (!boundary) throw new Error("multipart boundary missing");

	return function nextPart(_) {
		var buf = request.read(_, 2048);
		if (!buf) return null;
		var str = buf.toString("binary");;
		var i = str.indexOf(boundary);
		if (i < 0) throw new Error("first boundary not found");
		var lines = str.substring(0, i).split(/\r?\n/);
		var headers = lines.slice(0, lines.length - 2).reduce(function(h, l) {
			var kv = l.split(/\s*:\s*/);
			h[kv[0].toLowerCase()] = kv[1];
			return h;
		}, {});
		i = str.indexOf('\n', i);
		request.unread(buf.slice(i + 1));

		function read(_) {
			var len = Math.max(boundary.length, 256);
			var buf = request.read(_, 32 * len);
			if (!buf) return null;
			// would be nice if Buffer had an indexOf. Would avoid a conversion to string.
			// I could use node-buffertools but it introduces a dependency on a binary module.
			var s = buf.toString("binary");
			var i = s.indexOf(boundary);
			if (i >= 0) {
				i = s.lastIndexOf('\n', i);
				if (s[i - 1] === '\r') i--;
				if (subType === 'form-data') request.readAll(_); // discard any trailing data
				else {
					var j = s.indexOf('\n', i + boundary.length);
					request.unread(buf.slice(j + 1));
				}
				return buf.slice(0, i);
			} else {
				request.unread(buf.slice(31 * len));
				return buf.slice(0, 31 * len);
			}
		}

		return {
			headers: headers,
			read: read
		};
	}
}