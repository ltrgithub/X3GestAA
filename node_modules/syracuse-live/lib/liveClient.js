require('../../deps/socketIO/socket.io');

var helpers = require("syracuse-core/lib/helpers");
var forEachKey = helpers.object.forEachKey;
var hasKey = helpers.object.has;

function LiveClient() {
	var self = this;
	self._channelsOpen = {};
	self._socket = null;
	$(window).unload(function() {
		self._closeLiveConnection(true);
	});
}

LiveClient.prototype._parseMessage = function(result) {
	var self = this;
	result = JSON.parse(result);
	forEachKey(result, function(channel, messages) {
		if (hasKey(self._channelsOpen, channel)) {
			self._channelsOpen[channel].forEach(function(observer) {
				observer(messages);
			});
		} else {
			//TODO : Should do something when a message on a close channel
		}
	});
};

LiveClient.prototype._closeLiveConnection = function(force) {
	var self = this;
	if (self._socket)
		self._socket.disconnect();
	/*
	//fix parameters
	force = typeof force == "boolean" ? force : false;
	
	var self = this;
	$.ajax({
		async : !force, //Need this on unload event, can't make an async request on unload
		url : self._getLiveUrl() + "&close=true", //TODO : could do better...
		cache : false
	});
	*/
};

var regExpUrlParser = /((http[s]?|ftp):\/)?\/?([^:\/\s]+)(:([^\/]*))?((\/\w+)*\/)([\w\-\.]+[^#?\s]+)(\?([^#]*))?(#(.*))?$/;


LiveClient.prototype._ensureSocket = function() {
	var self = this;
	if (self._socket)
		return true;
	var url = regExpUrlParser.exec(document.location);
	self._socket = new io.Socket(url[3], {
		port : url[5] || 80,
		transports : ['websocket', 'xhr-multipart', 'xhr-polling']
	});
	self._socket.on('connect', function() {
		var channels = "+" + Object.keys(self._channelsOpen).join(",+");
		self._socket.send(channels);
	});
	self._socket.on('message', function(message) {
		self._parseMessage(message);
	});
};

LiveClient.prototype._ensureLiveConnection = function () {
	var self = this;
	self._ensureSocket();
	if (!self._socket.connected && !self._socket.connecting) {
		self._socket.connect();
		return false;
	}
	return true;
};

LiveClient.prototype._reset = function() {
	this._channelsOpen = {};
};

LiveClient.prototype._unregisterChannel = function(channel) {
	var self = this;
	self._registerChannel(channel, true)
};

LiveClient.prototype._registerChannel = function(channel, remove) {
	var self = this;
	if (self._ensureLiveConnection()) {
		var oper = remove ? "-" : "+";
		self._socket.send(oper + channel);
	}
};

LiveClient.prototype.unlive = function(resourceUrl, callback) {
	var self = this;
	if (Object.prototype.hasOwnProperty.call(this._channelsOpen, resourceUrl)) {
		var observers = self._channelsOpen[resourceUrl];
		var pos = observers.indexOf(callback);
		if (pos != -1) {
			observers.splice(pos, 1);
			if (!observers.length) {
				delete self._channelsOpen[resourceUrl];
				self._unregisterChannel(resourceUrl);
			}
		}
	}
};

LiveClient.prototype.live = function (resourceUrl, callback) {
	var self = this;
	var observers = null;
	if (hasKey(self._channelsOpen, resourceUrl)) {
		observers = self._channelsOpen[resourceUrl];
		if (observers.indexOf(callback) == -1) {
			observers.push(callback);
		}
	} else {
		observers = self._channelsOpen[resourceUrl] = [];
		observers.push(callback);
		self._registerChannel(resourceUrl);
	}
	
	return {
		unlive : self.unlive.bind(self, resourceUrl, callback)
	}
}

var liveClient = new LiveClient();

exports.liveClient = liveClient;

if (window) {
	window.$s = window.$s || {};
	window.$s.live = liveClient.live.bind(liveClient);
	window.$s.unlive = liveClient.unlive.bind(liveClient);
}