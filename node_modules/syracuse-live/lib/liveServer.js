var sys = require("util");
var helpers = require("syracuse-core/lib/helpers");
// TODO: NODE
var forEachKey = helpers.object.forEachKey;
var hasKey = helpers.object.has;
var ensureArray = helpers.array.ensureArray;
var io = require("socket.io");
var sessionManager = require('syracuse-session/lib/sessionManager').sessionManager;

function _ensureUser (client, then) {
	if (client.syraUser)
		then();
	sessionManager.sessionManagement( function(err, ok) {
		if (ok) {
			client.syraUser = request.session.getData("user");
			then();
		}
	}, request, response, {});
}

function Channel(name) {
	var self = this;
	self.name = name;
	self._clients = {};
}

Channel.prototype._createMessage = function(messages) {
	var self = this;
	messages = ensureArray(messages);
	var message = {};
	message[self.name] = messages;
	return message;
};
Channel.prototype._sendMessage = function(client, message) {
	var self = this;
	client.send(JSON.stringify(self._createMessage(message)));
};
Channel.prototype.isLive = function() {
	var self = this;
	return self.name.split("/")[1] == "$live";
};
Channel.prototype.innerName = function() {
	var self = this;
	if (!self.isLive())
		return null;
	return self.name.split("/")[0];
};
Channel.prototype.broadcast = function(message, except) {
	var self = this;
	except = ensureArray(except);
	forEachKey(self._clients, function(clientId, client) {
		if (except.indexOf(client.syraUser.$key) == -1) {
			self._sendMessage(client, message);
		}
	});
};
Channel.prototype.send = function(message, users) {
	var self = this;
	users = ensureArray(users);
	forEachKey(self._clients, function(clientId, client) {
		if (users.indexOf(client.syraUser.$key) != -1) {
			self._sendMessage(client, message);
		}
	});
};
Channel.prototype.hasUser = function(user) {
	var self = this;
	return self.getUsers()[user] ? true : false;
};
Channel.prototype.addClient = function(client) {
	var self = this;
	if (self._clients[client.sessionId])
		return false;
	self._clients[client.sessionId] = client;
	return true;
};
Channel.prototype.removeClient = function(client) {
	var self = this;
	delete self._clients[client.sessionId];
};
Channel.prototype.isEmpty = function() {
	var self = this;
	return Object.keys(self._clients).length == 0;
};
Channel.prototype.getUsers = function() {
	var self = this;
	var users = {};
	forEachKey(self._clients, function(clientId, client) {
		users[client.syraUser.$key] = client.syraUser;
	});
	return users;
};
function LiveServer() {

}

LiveServer.prototype.listen = function(server) {
	var self = this;
	self._channels = {};
	var socket = io.listen(server.emitter);
	socket.on('connection', function(client) {
		_ensureUser(client, function() {
			self._addClient(client);
		});
	});
}
LiveServer.prototype._addObserver = function (channel, client) {
	var self = this;
	if (!hasKey(self._channels, channel)) {
		self._channels[channel] = new Channel(channel);
	}
	channel = self._channels[channel];
	if (channel.addClient(client) && channel.isLive()) {
		client.syraUser.connected = true;
		channel.broadcast(client.syraUser, client.syraUser.$key);
		var users = [];
		forEachKey(channel.getUsers(), function(userId, user) {
			users.push(user);
		});
		channel.send(users, client.syraUser.$key);
	}
	//Check if live on it !
};
LiveServer.prototype._removeObserver = function (channelName, client) {
	var self = this;
	if (hasKey(self._channels, channelName)) {
		var channel = self._channels[channelName];
		channel.removeClient(client);
		if (channel.isEmpty()) {
			delete self._channels[channelName];
		} else {
			client.syraUser.connected = false;
			channel.broadcast(client.syraUser, client.syraUser.$key);
		}
	}
}
LiveServer.prototype._channelChange = function(channels, client) {
	var self = this;
	channels = channels.split(",");
	channels.forEach( function(channel) {
		var op = channel.substring(0, 1);
		var name = channel.substring(1, channel.length);
		if (op === "-") {
			self._removeObserver(name, client);
		} else {
			self._addObserver(name, client)
		}
	});
}
LiveServer.prototype._addClient = function (client) {
	var self = this;
	//pas de client...
	client.on('message', function(message) {
		_ensureUser(client, function() {
			self._channelChange(message, client);
		});
	});
	client.on('disconnect', function() {
		_ensureUser(client, function() {
			forEachKey(self._channels, function(name, channel) {
				self._removeObserver(name, client);
			});
		});
	});
};
LiveServer.prototype.channels = function (channel) {
	var self = this;
	channel = self._channels[channel];
	if (!channel) {
		//TODO : throw exception ???
	}
	return {
		exist : channel != null,
		broadcast : function(message, except) {
			if (channel)
				channel.broadcast(message, except);
		},
		send : function(message, users) {
			if (channel)
				channel.send(message, users);
		}
	}
};
exports.liveServer = new LiveServer();

/*
 var conn = new xmpp.Connection();
 conn.log = function (_, m) { sys.puts(m); };
 conn.connect("nodejs", "password", function (status, condition) {
 if(status == xmpp.Status.CONNECTED)
 conn.addHandler(onMessage, null, 'message', null, null,  null);
 else
 conn.log(xmpp.LogLevel.DEBUG, "New connection status: " + status + (condition?(" ("+condition+")"):""));
 });

 function onMessage(message) {
 conn.send(xmpp.message({
 to:message.getAttribute("from"),
 from:message.getAttribute("to"),
 type: "chat"})
 .c("body").t(message.getChild("body").getText()));
 }
 */