var module = QUnit.module;

module('liveClient');
test('LIVE CLIENT TEST DISABLED FOR NOW', 1, function() {
	ok(true, "hijack is broken")
});
if (false) {
	//var hijack = require("../../../runner/hijack").hijack; //Forcément à respecter !!!
	//hijack("socketIO/socket.io", "../fixtures/socketIOClientStub"); //IDEM !!!

	var helpers = require("syracuse-core/lib/helpers");
	var hasKey = helpers.object.has;
	// TODO: this require fails!
	//var liveClient = require('syracuse-live/lib/liveClient').liveClient;

	test('methods on $s object', 3, function() {
		ok($s, "$s should exist");
		ok($s.hasOwnProperty("live"), "live method should be added to $s");
		ok($s.hasOwnProperty("unlive"), "unlive method should be added to $s");
	});
	test("default state", function() {
		ok(liveClient._socket === null, "socket should be closed by default")
	})
	var resourceUrl = "chats";

	test('adding a live on a resource url', 5, function() {
		var h = $s.live(resourceUrl, function(results) {
		});
		ok(liveClient._channelsOpen[resourceUrl], "should register the channel");
		strictEqual(liveClient._socket._messagesSent.length, 1, "should send a message to the server");
		strictEqual(liveClient._socket._messagesSent[0], "+chats", "the message should be + with the url of the resource");
		ok(h, "the live method should return an handler");
		ok(hasKey(h, "unlive") && Object.keys(h).length === 1 && typeof h["unlive"] == "function", "the handler should have only one method named unlive");
		h.unlive();
	});
	test('unlive a callback with the handler', function() {
		liveClient._socket._reset();
		var h = $s.live(resourceUrl, function(results) {
		});
		ok(liveClient._channelsOpen[resourceUrl], "should register the channel");
		h.unlive();
		ok(liveClient._channelsOpen[resourceUrl] === undefined, "should delete the channel");
		strictEqual(liveClient._socket._messagesSent.length, 2, "should send a message to the server");
		strictEqual(liveClient._socket._messagesSent[1], "-chats", "the message should be - with the url of the resource");
	});
	test('unlive a callback with the liveClient method', function() {
		liveClient._socket._reset();
		var fn = function(results) {
		};
		$s.live(resourceUrl, fn);
		$s.unlive(resourceUrl, fn);
		ok(liveClient._channelsOpen[resourceUrl] === undefined, "should delete the channel");
		strictEqual(liveClient._socket._messagesSent.length, 2, "should send a message to the server");
		strictEqual(liveClient._socket._messagesSent[1], "-chats", "the message should be - with the url of the resource");
	});
	test('getting a message from the server', 1, function() {
		liveClient._socket._reset();
		var h = $s.live(resourceUrl, function(results) {
			same(results, ["coucou"], "should receive the message");
			h.unlive();
		});
		liveClient._socket._emit("message", '{"chats" : ["coucou"]}');
	});
	test('getting multiples messages for different channels from the server', 1, function() {
		liveClient._socket._reset();
		var h = $s.live(resourceUrl, function(results) {
			same(results, ["coucou"], "should receive only the message for the channel we are binded to");
			h.unlive();
		});
		liveClient._socket._emit("message", '{"chats" : ["coucou"], "events" : ["this is an event"]}');
		h.unlive();
	});
	test('loosing connection', 2, function() {
		liveClient._socket._reset();
		liveClient._socket.on("connect", function() {
			ok(true, "should reconnect");
		});
		liveClient._socket.connected = false;
		var h = $s.live(resourceUrl, function(results) {
			same(results, ["coucou"], "should keep intact the channels and callback");
			h.unlive();
		});
		liveClient._socket._emit("message", '{"chats" : ["coucou"], "events" : ["this is an event"]}');
	});
}