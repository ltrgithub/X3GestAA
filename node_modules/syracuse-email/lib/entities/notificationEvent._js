"use strict";

var locale = require("syracuse-core/lib/locale");
var datetime = require("syracuse-core/lib/types/datetime");
var date = require("syracuse-core/lib/types/date");
var adminHelpers = require('syracuse-collaboration/lib/helpers');
var scheduler = require('syracuse-event/lib/scheduler');
var globals = require('streamline-runtime').globals;

var tracer; // = console.error;

exports.entity = {
	$titleTemplate: "Notification event",
	$valueTemplate: "{code}",
	$allowFactory: true,
	$properties: {
		code: {
			$title: "Code",
			$isMandatory: true,
			$isUnique: true,
			$linksToDetails: true
		},
		description: {
			$title: "Description",
			$isLocalized: true
		},
		titleTemplate: {
			$title: "Title template",
			$isLocalized: true
		},
		textTemplate: {
			$title: "Text template",
			$isLocalized: true
		},
	},
	$relations: {
		notificationServers: {
			$title: "Notification servers",
			$type: "notificationServers"
		},
		recipients: {
			$title: "Recipients",
			$type: "users"
		}
	},
	$functions: {
		/// -------------
		/// ## schedule function 
		/// 
		/// ``` javascript
		/// event.schedule(_, key, executionTime, parameters, mode);
		/// ```
		/// 
		/// Schedule one instance of the given event.
		/// 
		/// 
		/// * The `key` parameter represents a key value for this instance. Scheduling a new event with the same key will replace 
		///   the previously scheduled event
		/// * The `executionTime` parameter contains the execution time. This can be a date string in ISO format or the number of milliseconds since 1 January 1970.
		/// * The `parameters` parameter contains a JSON structure which serves for placeholders within the event text
		/// * The `mode` parameter denotes how the event should be scheduled: "" without database change, "db" with database change, "cluster" schedule also on other servers in cluster.
		///  
		schedule: function(_, key, executionTime, parameters, mode) {
			return scheduler.schedule(_, this, key, executionTime, parameters, mode);
		},
		/// -------------
		/// ## scheduleAll function 
		/// 
		/// ``` javascript
		/// event.scheduleAll(_, data, mode);
		/// ```
		/// 
		/// Replace all scheduled instances for this event
		/// 
		/// * The `data` parameter contains an array of triples `[key, executionTime, parameters]`, where `key`, `executionTime`,
		///   `parameters` have the same meaning as in the `schedule` function. Elements in this list with same key will replace
		///   scheduled events. Scheduled events whose key does not appear any more in this list will be deleted. If the parameter
		///   is empty (really empty, not just empty array), the scheduler will just be initialized.
		/// * The `mode` parameter denotes how the event should be scheduled: "" without database change, "db" with database change, "cluster" schedule also on other servers in cluster.
		///
		scheduleAll: function(_, data, mode) {
			return scheduler.scheduleAll(_, this, data, mode);
		},
		fire: function(_, key, parameters) {
			tracer && tracer("FIRE" + this.code(_));
			var recipients = this.recipients(_).toArray(_);
			var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
			var servers = this.notificationServers(_).toArray(_);
			if (servers.length === 0) {
				var entity = db.model.getEntity(_, "setting");
				var settings = entity.fetchInstances(_, db)[0];
				var mailer = settings && settings.mailer(_);
				if (mailer) servers.push(mailer);
			}
			var self = this;
			var title = this.getPropAllLocales(_, "titleTemplate");
			var text = this.getPropAllLocales(_, "textTemplate");
			recipients.forEach_(_, function(_, recipient) {
				tracer && tracer("recipient " + recipient.login(_));
				var preferences = recipient.preferences(_);
				var localeCode = preferences ? preferences.lastLocaleCode(_) : "en-US";
				var whereClause = "(code eq \"" + localeCode + "\")";

				var localePreference = db.fetchInstance(_, db.model.getEntity(_, "localePreference"), {
					sdataWhere: whereClause
				});
				if (!localePreference) {
					console.error("Notification: Locale not found: " + localeCode);
					throw new Error(locale.format(module, "noLocale", localeCode));
				}

				tracer && tracer("Locale " + localeCode);
				var userText = _localize(_, text, parameters, recipient, localePreference);
				var userTitle = _localize(_, title, parameters, recipient, localePreference);
				servers.forEach_(_, function(_, server) {
					try {
						//console.error("Send email to '" + recipient.login(_) + "' - subject: '" + userTitle + "'");
						var link;
						// include the link only when the request is in the context
						if (globals.context.request) {
							link = {
								href: (globals.context.secure ? "https://" : "http://") + globals.context.request.headers.host + "/syracuse-main/html/main.html?url=/sdata/syracuse/collaboration/syracuse/notificationEvents('" + self.$uuid + "')?representation=notificationEvent.$details",
								label: locale.format(module, "mailLinkLabel")
							};
						}
						server.notify(_, {
							to: recipient.email(_),
							subject: userTitle,
							text: userText
						}, {
							title: userTitle,
							subtitle: locale.format(module, "testMailSubtitle"),
							content: userText,
							link: link,
							info: {
								date: {
									label: locale.format(module, "dateLabel"),
									value: new Date().toDateString()
								},
								time: {
									label: locale.format(module, "timeLabel"),
									value: new Date().toLocaleTimeString()
								}
							}
						});
					} catch (e) {
						console.error("Error during server notification: " + e + " " + e.stack);
					}
				});
			});
		}
	}
};

// 

function _resolveLocale(_, text, localePreference) {
	if (text && text instanceof Object) {
		var localeCode = localePreference.code(_).toLowerCase();
		if (localeCode in text) {
			text = text[localeCode];
		} else if ("default" in text) {
			text = text["default"];
		} else text = "???";
	}
	return text;
}



function _localize(_, text, properties, user, localePreference) {
	var index = 0;
	var reg;
	var i = 0;
	text = _resolveLocale(_, text, localePreference);
	while (reg = /\{(?:(date|datetime)\:)?(?:(user)\.)?(\w+)\}/.exec(text.substr(index))) {
		// at most 100 replacements
		// tracer && tracer(i+"TEXT "+text+ " "+util.format(reg))		
		if (i++ > 100) break;
		var replacement = undefined;
		try {
			if (reg[2] === "user") {
				replacement = user[reg[3]](_);
				if (replacement === undefined) replacement = "";
			} else {
				replacement = properties[reg[3]];
			}
		} catch (e) {
			tracer && tracer("Not found: " + reg[3]);
		}
		// tracer && tracer("replacement text "+util.format(replacement) )
		if (replacement === undefined) {
			index += reg.index + 1;
			continue;
		}
		var format = reg[1];
		if (replacement && (replacement instanceof Object)) {
			if (date.isDate(replacement)) {
				format = "date";
			} else if (datetime.isDatetime(replacement)) {
				format = "datetime";
			}
		}
		// no format
		if (!format) {
			replacement = _resolveLocale(_, replacement, localePreference);
		} else {
			switch (format) {
				case "date":
					if (replacement instanceof Date) {
						replacement = date.fromJsDate(replacement);
					} else if (!date.isDate(replacement)) {
						replacement = date.parse(replacement);
					}
					format = localePreference.shortDate(_);
					replacement = replacement.toString(format);
					break;
				case "datetime":
					if (replacement instanceof Date) {
						replacement = datetime.fromJsDate(replacement);
					} else if (!(datetime.isDatetime(replacement))) {
						replacement = datetime.parse(replacement);
					}
					format = localePreference.shortDatetime(_);
					replacement = replacement.toString(format);
					break;
				default:
					throw new Error("Wrong format " + reg[1]);
			}
		}
		index += reg.index;
		text = text.substr(0, index) + replacement + text.substr(index + reg[0].length);
	}
	tracer && tracer("text after replacements " + text);
	return text;
}

// for unit tests
exports._localize = _localize;