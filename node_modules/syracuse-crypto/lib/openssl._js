"use strict";

/// !doc
/// 
/// # Openssl runner
/// 
/// ```javascript
/// var openssl = require('syracuse-crypto').openssl  
/// ```
/// 

var openssl = require('syracuse-crypto').openssl,
	cp = require('child_process'),
	readers = require("streamline/lib/streams/readers"),
	fs = require('fs');

/// -------------
/// ## sign function :
/// 
/// ``` javascript
/// var signature = openssl.sign(_, data, privateKeyPath, passphrase, algorithm, encoding); 
/// ```
/// 
/// Sign data with given private key.  
/// 
/// * The `data` parameter represents data to sign.  
/// * The `privateKeyPath` parameter represents the full path of the private key (must be DER format).  
/// * The `passphrase` parameter represents the passphrase needed by the private key.
/// * The `algorithm` parameter represents the algorithm wanted to apply.
/// * The `encoding` parameter represents the encoding wanted for signature.
/// 
/// Returns the generated signature in given encoding.  
/// 
exports.sign = function(_,data, privateKeyPath, passphrase, algorithm, encoding){
	try{
		var tempDigestFile = __dirname + "/../temp/dgst";
		var tempSigFile = __dirname + "/../temp/sig";
		// Write temporary digest file
		fs.writeFile(tempDigestFile, data,'binary');

		var child = cp.spawn('openssl', ['dgst', '-'+algorithm, '-passin', 'pass:'+passphrase,'-out',tempSigFile, '-sign', privateKeyPath, tempDigestFile]);
		child.stdout.setEncoding('utf8');
		child.stderr.on('data',function(chunk){
			console.log("stderr: "+chunk);
		});
		
		// read stdout till the end to wait for child exit
		var stdout = new readers.Reader(child.stdout);
		var str;
		while ((str = stdout.readItem(_)) != null) {
			console.log("stdout: " + str);
		}
	
		var signature = fs.readFile(tempSigFile, 'binary', _);
		
		fs.unlink(tempDigestFile,_);
		fs.unlink(tempSigFile,_);
		
		var buf = new Buffer(signature,'binary');
		return buf.toString(encoding);

	}catch(e){
		throw new Error("Signature failed : "+e.stack);
	}
} 

/// -------------
/// ## encryptRsa function :
/// 
/// ``` javascript
/// var encrypted = openssl.encryptRsa(_, str, publicKeyPath);  
/// ```
/// 
/// Encrypt String with RSA.  
/// 
/// * The `str` parameter represents the string to encrypt.  
/// * The `publicKeyPath` parameter represents the path of the public key to use.
/// 
/// Returns the string encrypted.  
/// 
exports.encryptRsa = function(_,data, publicKeyPath){
	try{
		var tempDataFile = __dirname + "/../temp/data";
		var tempCryptedFile = __dirname + "/../temp/encrypted";
		// Write temporary data file
		fs.writeFile(tempDataFile, data,'binary');

		var child = cp.spawn('openssl', ['rsautl', '-encrypt', '-inkey', publicKeyPath, '-pubin', '-in', tempDataFile, '-out', tempCryptedFile]);
		child.stdout.setEncoding('utf8');
		child.stderr.on('data',function(chunk){
			console.log("stderr: "+chunk);
		});
		
		// read stdout till the end to wait for child exit
		var stdout = new readers.Reader(child.stdout);
		var str;
		while ((str = stdout.readItem(_)) != null) {
			console.log("stdout: " + str);
		}
	
		var crypted = fs.readFile(tempCryptedFile, 'binary', _);
		
		fs.unlink(tempDataFile,_);
		fs.unlink(tempCryptedFile,_);
		

		return crypted;

	}catch(e){
		throw new Error("RSA encryption failed : "+e.stack);
	}
} 

/// -------------
/// ## decryptRsa function :
/// 
/// ``` javascript
/// var decrypted = openssl.decryptRsa(_,data, privateKeyPath, passphrase);  
/// ```
/// 
/// Decrypt String with RSA.  
/// 
/// * The `data` parameter represents the encrypted data.  
/// * The `privateKeyPath` parameter represents the path of the private key to use.  
/// * The `passphrase` parameter represents the passphrase corresponding to the private key.  
/// 
/// Returns the string encrypted.  
/// 
exports.decryptRsa = function(_,data, privateKeyPath, passphrase){
	try{
		var tempCryptedFile = __dirname + "/../temp/crypted";
		var tempDecryptedFile = __dirname + "/../temp/decrypted";
		// Write temporary crypted file
		fs.writeFile(tempCryptedFile, data,'binary');

		var child = cp.spawn('openssl', ['rsautl', '-decrypt', '-inkey', privateKeyPath, '-passin', 'pass:'+passphrase, '-in', tempCryptedFile, '-out', tempDecryptedFile]);
		child.stdout.setEncoding('utf8');
		child.stderr.on('data',function(chunk){
			console.log("stderr: "+chunk);
		});
		
		// read stdout till the end to wait for child exit
		var stdout = new readers.Reader(child.stdout);
		var str;
		while ((str = stdout.readItem(_)) != null) {
			console.log("stdout: " + str);
		}
	
		var decrypted = fs.readFile(tempDecryptedFile, 'utf8', _);
		
		fs.unlink(tempCryptedFile,_);
		fs.unlink(tempDecryptedFile,_);
		
		var buf = new Buffer(decrypted,'utf8');
		return buf.toString('utf8');

	}catch(e){
		throw new Error("RSA decryption failed : "+e.stack);
	}
} 