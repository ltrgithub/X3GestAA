"use strict";

var helpers = require("syracuse-core/lib/helpers");
var Context = require("syracuse-sdata/lib/sdataContext").Context;
var proxy = require('syracuse-main/lib/proxy');
var registry = require("syracuse-sdata/lib/sdataRegistry");
var dataModel = require("syracuse-orm/lib/dataModel");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var locale = require("syracuse-core/lib/locale");
var globals = require("streamline/lib/globals");
var querystring = require('querystring');
var httpClient = require("syracuse-httpclient/lib/httpClient");
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var util = require('util');
var x3helpers = require('syracuse-x3/lib/helpers');
var flows = require("streamline/lib/util/flows");

var trace = nodeconfig.config && nodeconfig.config.xtend && nodeconfig.config.xtend.proxy && nodeconfig.config.xtend.proxy.trace;
var loadBalancer = {};

var balanceFunnel = flows.funnel(1);

function selectServer(_, queryparams, servers) {

	var res = null;
	balanceFunnel(_, function(_) {

		function getServer(_, uuid) {
			return servers.filter(function(s) {
				return s.$uuid === selectedUuid;
			})[0];
		}
		var solution = queryparams.SOL;
		var folder = queryparams.FLDR;
		var site = queryparams.SITE;
		loadBalancer[solution] = loadBalancer[solution] || {};
		loadBalancer[solution][folder] = loadBalancer[solution][folder] || {};
		var list = loadBalancer[solution][folder][site] = loadBalancer[solution][folder][site] || [];
		// remove banned servers and and create a map of uuids
		var bannedList = [];
		var realList = servers.filter_(_, function(_, s) {
			var isBanned = s.banned(_);
			if (isBanned) bannedList.push(s.$uuid);
			return !isBanned;
		}).map(function(s) {
			return s.$uuid;
		});
		//console.log("REAL LIST :"+JSON.stringify(realList,null,2));
		//console.log("BANNED LIST :"+JSON.stringify(bannedList,null,2));
		// ***
		// Synchronize list and real list
		// ***

		for (var i in list) {
			// Remove servers from list if there not configured anymore
			if (realList.indexOf(list[i]) === -1) delete list[i];
			// Remove servers from list if banned
			if (bannedList.indexOf(list[i]) === -1) delete list[i];
		}
		// Concatenate list and real list to be sure to handle all configured servers
		var both = list.concat(realList);
		// remove twins
		list = both.filter(function(item, pos) {
			return both.indexOf(item) == pos;
		});
		// 
		var idx = 0;
		if (queryparams.SRVHOST && queryparams.SRVPORT) {
			var srvUuid;
			for (var j in servers) {
				if (servers[j].host(_) === queryparams.SRVHOST && servers[j].port(_) === queryparams.SRVPORT) {
					srvUuid = servers[j].$uuid;
					break;
				}
			}
			if (!srvUuid) throw new Error(locale.format(module, "noServerMatchInConf", queryparams.SRVHOST + ":" + queryparams.SRVPORT));
			idx = list.indexOf(srvUuid);
			if (idx === -1) {
				// Check if banned
				if (bannedList.indexOf(srvUuid) !== -1)
					throw new Error(locale.format(module, "serverBanned", queryparams.SRVHOST + ":" + queryparams.SRVPORT));
				throw new Error(locale.format(module, "noServerMatchInLB", queryparams.SRVHOST + ":" + queryparams.SRVPORT));
			}
		}
		// ***
		// Select server to use and Apply round robin algorithm : the first become the last...
		// ***
		var selectedUuid = list[idx];
		//console.log("SELECTED UUID :"+JSON.stringify(selectedUuid,null,2));

		//console.log("LIST BEFORE ROUND ROBIN :"+JSON.stringify(list,null,2));
		if (list.length > 1) {
			list.splice(idx, 1);
			list.push(selectedUuid);
		}
		//console.log("LIST AFTER ROUND ROBIN :"+JSON.stringify(list,null,2));
		var server = getServer(_, selectedUuid);
		//console.log("SERVER SELECTED: "+server.$uuid);

		// check availability
		if (!server.isServerRunning(_)) {
			trace && trace(locale.format(module, "serverNotAvailable", queryparams.SRVHOST, queryparams.SRVPORT));
			if (queryparams.SRVHOST && queryparams.SRVPORT) {
				throw new Error(locale.format(module, "serverNotAvailable", queryparams.SRVHOST, queryparams.SRVPORT));
			}
			for (var k in list) {
				server = getServer(_, list[k]);
				if (server.isServerRunning(_)) {
					selectedUuid = list[k];
					list.splice(k, 1);
					list.push(selectedUuid);
					break;
				} else {
					trace && trace(locale.format(module, "serverNotAvailable", server.host(_), server.port(_)));
				}
			}

		}

		loadBalancer[solution][folder][site] = list;
		res = getServer(_, selectedUuid);
	});
	if (!res) throw new Error("Funnel failed");
	return res;
}

function getSite(_, options) {
	if (!options || !options.SITE || !options.SOL || !options.FLDR) return;
	var filter = {
		sdataWhere: "name eq '" + options.SITE + "' and endpoint.x3ServerFolder eq '" + options.FLDR + "' and endpoint.x3SolutionName eq '" + options.SOL + "'"
	};
	var db = adminHelper.getCollaborationOrm(_);
	return db.fetchInstance(_, db.model.getEntity(_, "siteHRM"), filter);
}

function initHrm(_, context, suburl) {
	function authenticate(_, context, baseUrl, solution, folder, siteName, certificate, suburl) {
		function getPortal(_) {
			var options = {
				method: context.method,
				url: baseUrl + "/xtend/page/" + context.toWalk() + "?" + context.rawQuery,
				headers: context.request.headers
			};
			trace && trace("get portal request: " + JSON.stringify(options, null, 2));
			var request = httpClient.httpRequest(_, options);
			var buf;
			while ((buf = context.request.read(_))) {
				request.write(_, buf, "binary");
			}
			var resp = request.end().response(_);
			trace && trace("get portal response:" + JSON.stringify({
				status: resp.statusCode,
				headers: resp.headers
			}, null, 2));
			return {
				id: proxy.getCookie(resp.headers['set-cookie'], "JSESSIONID") || proxy.getCookie(options.headers.cookie, "JSESSIONID"),
				resp: resp
			};
		}

		function connection(_) {
			var body = {
				"solution": solution,
				"folder": folder
			};
			var data = JSON.stringify(body);
			var header = {
				"content-type": "application/json",
				"accept": "application/json",
				"accept-language": selectedLocale,
				"content-length": data.length
			};
			var options = {
				method: "POST",
				url: ssoBaseUrl + "/$connection",
				headers: header
			};
			trace && trace("auth request ($connection): " + JSON.stringify(options, null, 2));
			var request = httpClient.httpRequest(_, options);
			var resp = request.end(data).response(_);
			// Connection cookies will be required by client
			connectSetCookie = resp.headers['set-cookie'];
			return {
				id: proxy.getCookie(resp.headers['set-cookie'], "JSESSIONID") || proxy.getCookie(options.headers.cookie, "JSESSIONID"),
				resp: resp
			};
		}

		function session(_, body, headers) {
			var pubkeyName = nodeconfig.config.sdata.pubkeyName;
			if (certificate) {
				pubkeyName = certificate.name(_).replace(/[\@\$\.]/g, "_");
			} else if (nodeconfig.config.x3key) { // use internal certificate of this server
				pubkeyName = require('os').hostname().toLowerCase().replace(/[\@\$\.]/g, "_");
			}
			var sess = {
				connectionId: body.id,
				auth: {
					method: body.auth && body.auth.method,
					pubkey: pubkeyName,
					user: x3login
				}
			};
			sess.auth.signature = x3helpers.getSignature(_, body.auth && body.auth.challenge, x3login, certificate);

			var data = JSON.stringify(sess);
			// Set $connection response cookies in $session request
			// Merge $connection response cookies with the proxy cookies map

			proxy.manageCookie(p.mapCookie, syrSessionId, headers);

			var header = {
				"content-type": "application/json",
				"accept": "application/json",
				"content-length": data.length,
				"content-encoding": "utf-8",
				"accept-language": selectedLocale,
				"cookie": p.mapCookie[syrSessionId], // Set $connection response cookies in $session request
				"referer": "http://ecchambard-001:8124" + suburl
			};
			var opt = {
				method: "POST",
				url: ssoBaseUrl + "/$session",
				headers: header
			};
			trace && trace("auth request ($session): " + JSON.stringify(opt, null, 2));
			var request = httpClient.httpRequest(_, opt);
			return request.end(data).response(_);
		}
		// BEGIN AUTHENTICATE CLOSURE
		var ssoBaseUrl = baseUrl + "/xtend/xtendsso/" + solution + "/" + folder + "/" + siteName;

		var up = context.getUserProfile(_);
		// Force selected user profile endpoint to get right X3 login
		if (up.selectedEndpoint(_).$uuid !== site.endpoint(_).$uuid)
			up.selectedEndpoint(_, site.endpoint(_));
		var x3login = up.user(_).getEndpointLogin(_, up.selectedEndpoint(_).$uuid);
		var selectedLocale = up.selectedLocale(_).code(_);

		try {
			// Send $connection request
			var result = connection(_);
			var resp = result.resp;
			var JSESSIONID = result.id;
			var connectBody = resp.readAll(_);
			connectBody = JSON.parse(connectBody);
			trace && trace("auth response ($connection):" + JSON.stringify({
				status: resp.statusCode,
				headers: resp.headers
			}, null, 2));

			if (resp.statusCode !== 201) {
				throw new Error(locale.format(module, "connectionFailed"));
			}
			// Send $session request
			resp = session(_, connectBody, resp.headers);
			trace && trace("auth response ($session):" + JSON.stringify({
				status: resp.statusCode,
				headers: resp.headers
			}, null, 2));
			// Return response as it is...
			return {
				auth: true,
				id: JSESSIONID,
				resp: resp
			};
		} catch (e) {
			trace && trace("An error occured while authentication :\n" + JSON.stringify(connectBody, null, 2) + "\n" + e.stack);
			return getPortal(_);
		}
	}
	// BEGIN INITHRM CLOSURE
	// syracuse.sid is used to handle properly cookies
	try {
		var syrport = context.request.connection.localPort;
		var syrSessionId = proxy.getCookie(context.request.headers.cookie, "syracuse.sid." + syrport);

		var params = querystring.parse(context.rawQuery);
		// Retrieve HRM Site instance
		var site = getSite(_, params);
		if (!site) throw new Error(locale.format(module, "hrmSiteNotFound", JSON.stringify(params, null, 2)));

		var servers = site.servers(_).toArray(_);
		if (servers.length === 0) throw new Error(locale.format(module, "noWebServerOnHrmSite", site.name(_)));
		// Apply load balancing (round robin)
		var server = selectServer(_, params, servers);

		// Force web server if querystring said it
		var host = server.host(_);
		var port = server.port(_);
		var webServerBaseUrl = "http://" + host + ":" + port;

		// Instanciate proxy
		var p = new proxy.Proxy(_, webServerBaseUrl, trace);

		// process authentication requests -> if fail request classic auth portal
		var result = authenticate(_, context, webServerBaseUrl, params.SOL, params.FLDR, params.SITE, null, suburl);
		var resp = result.resp;
		var JSESSIONID = result.id;

		// Store proxy in httpSession
		context.httpSession.hrmSessions = context.httpSession.hrmSessions || {};
		context.httpSession.hrmSessions[JSESSIONID] = p;

		// Set $connection + $session response cookies in first response sent to client
		if (result.auth) {
			resp.headers['x-challenge-auth'] = true;
			var connectSetCookie;
			if (!resp.headers['set-cookie'])
				resp.headers['set-cookie'] = [];
			resp.headers['set-cookie'].push(connectSetCookie);
		}
		// Decide what encoding to use...
		var encoding = resp.headers['content-type'] && resp.headers['content-type'].indexOf('charset=utf-8') !== -1 ? "utf-8" : "binary";
		// Send response (with custom cookies) to browser
		proxy.manageCookie(p.mapCookie, syrSessionId, resp.headers);
		context.response.writeHead(resp.statusCode, resp.headers);
		var buf;
		while ((buf = resp.read(_))) {
			context.response.write(_, buf, encoding);
		}
		context.response.end();
	} catch (e) {
		if (context.httpSession && context.httpSession.hrmSessions && context.httpSession.hrmSessions[JSESSIONID])
			delete context.httpSession.hrmSessions[JSESSIONID];
		throw e;
	}
}

function forward(_, context, path, JSESSIONID) {
	try {
		JSESSIONID = JSESSIONID || proxy.getCookie(context.request.headers.cookie, "JSESSIONID");
		//console.log("JSESSIONID found to forward: "+JSESSIONID);
		// Identify what proxy to use thanks to httpSession informations
		var p = context.httpSession.hrmSessions && context.httpSession.hrmSessions[JSESSIONID];
		if (p) {
			// If proxy found, forward request
			p.forward(_, context, path);
		} else {
			// Else, reinitialize connection
			initHrm(_, context, "/xtend/page/" + context.toWalk());
		}
	} catch (e) {
		if (context.httpSession && context.httpSession.hrmSessions && context.httpSession.hrmSessions[JSESSIONID])
			delete context.httpSession.hrmSessions[JSESSIONID];
		throw e;
	}
}

var _xtendMap = {
	walk: function(_, context, name, id) {
		switch (name) {
			case "page":
				var JSESSIONID = proxy.getCookie(context.request.headers.cookie, "JSESSIONID");
				if (JSESSIONID) {
					// The session exists (or maybe not and 'forward' method will do the job)
					return forward(_, context, "/xtend/page/" + context.toWalk() + "?" + context.rawQuery, JSESSIONID);
				} else {
					// initialize session and store proxy instance in httpSession
					initHrm(_, context, "/xtend/" + name + "/" + context.toWalk());
					return;
				}
				break;
			default:
				return _dispatch(_, context, _xtendMap);
		}
	},
	get: function(_, context, walkedUrl) {
		return forward(_, context, "/" + walkedUrl);
	},
	post: function(_, context, walkedUrl) {
		return forward(_, context, "/" + walkedUrl);
	},
	put: function(_, context, walkedUrl) {
		return forward(_, context, "/" + walkedUrl);
	},
	"delete": function(_, context, walkedUrl) {
		return forward(_, context, "/" + walkedUrl);
	}
};

function _parseSegment(segment) {
	var match = /^([^\/(]*)\('([^']*)'\)$/.exec(segment);
	return match ? {
		name: match[1],
		id: match[2]
	} : {
		name: segment
	};
}

function _dispatch(_, context, map) {
	//console.log("Walked: " + context.walked());
	var seg = context.walkUrl();
	if (seg == null) {
		// we reached the end of the URL, dispatch method
		//var method = context.request.method.toLowerCase();
		var method = context.method;
		if (map[method]) {
			var walkedUrl = context.walked().split("/").slice(3).join('/');
			return map[method](_, context, walkedUrl);
		} else throw context.badMethod(method);
	} else {
		var pair = _parseSegment(seg);
		if (pair.name[0] === '$') {
			var name = pair.name.substring(1);
			if (map[name]) {
				return map[name](_, context, pair.id);
			}
		} else if (map.walk) {
			return map.walk(_, context, pair.name, pair.id);
		}
		throw context.badRequest(locale.format(module, "unexpectedSegment", seg));
	}
}

function _logRequest(_, context) {
	if (!context.request.headers["x-history-title"]) return;
	//
	var db = adminHelper.getCollaborationOrm(_);
	var h = db.model.getEntity(_, "navHistory").factory.createInstance(_, null, db);
	h.title(_, context.request.headers["x-history-title"]);
	h.agent(_, context.request.headers["x-history-agent"]);
	h.url(_, context.request.url);
	h.save(_);
}

function _doIt(_, context) {
	try {
		var protocol = context.walkUrl();
		if (protocol !== "xtend") throw new Error(locale.format(module, "badUrl", protocol));
		context.request.hrm = context.request.hrm || {};
		// fire and forget log call
		_logRequest(!_, context);
		_dispatch(_, context, _xtendMap);
	} catch (ex) {
		if (ex.httpStatus) {
			return context.reply(_, ex.httpStatus, ex.message);
		} else if (ex.stack) {
			return context.reply(_, 500, ex.message + "\n" + ex.stack);
		} else {
			return context.reply(_, 500, ex.toString());
		}
	}
}

exports.dispatcher = function(config) {
	return function(_, request, response) {
		var context = new Context(request, response, config);
		request.context = context;
		try {
			_doIt(_, context);
		} catch (err) {
			helpers.log.exception(module, err);
			context.reply(_, 500, err.message + "\n" + err.stack);
		}
	};
};