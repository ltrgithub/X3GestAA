"use strict";

var helpers = require("syracuse-core/lib/helpers");
var Context = require("syracuse-sdata/lib/sdataContext").Context;
var proxy = require('syracuse-main/lib/proxy');
var registry = require("syracuse-sdata/lib/sdataRegistry");
var dataModel = require("syracuse-orm/lib/dataModel");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var locale = require("syracuse-core/lib/locale");
var globals = require("streamline/lib/globals");
var querystring = require('querystring');
var httpClient = require("syracuse-httpclient/lib/httpClient");
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var util = require('util');
var x3helpers = require('syracuse-x3/lib/helpers');
var flows = require("streamline/lib/util/flows");

var trace = nodeconfig.config && nodeconfig.config.xtend && nodeconfig.config.xtend.proxy && nodeconfig.config.xtend.proxy.trace;
var traceLB = null; //console.log;
var loadBalancer = {};

var balanceFunnel = flows.funnel(1);

function selectServer(_, queryparams) {

	var res = null;
	balanceFunnel(_, function(_) {

		function getServer(_, uuid) {
			return servers.filter(function(s) {
				return s.$uuid === uuid;
			})[0];
		}

		// Retrieve HRM Site instance
		var _site = getSite(_, queryparams);
		if (!_site) throw new Error(locale.format(module, "hrmSiteNotFound", JSON.stringify(queryparams, null, 2)));

		var servers = _site.servers(_).toArray(_);
		if (servers.length === 0) throw new Error(locale.format(module, "noWebServerOnHrmSite", _site.name(_)));

		var solution = queryparams.SOL;
		var folder = queryparams.FLDR;
		var site = queryparams.SITE;
		loadBalancer[solution] = loadBalancer[solution] || {};
		loadBalancer[solution][folder] = loadBalancer[solution][folder] || {};
		var list = loadBalancer[solution][folder][site] = loadBalancer[solution][folder][site] || [];
		// remove banned servers and and create a map of uuids
		var bannedList = [];
		var realList = servers.filter_(_, function(_, s) {
			var isBanned = s.banned(_);
			if (isBanned) bannedList.push(s.$uuid);
			return !isBanned;
		}).map(function(s) {
			return s.$uuid;
		});
		traceLB && traceLB("REAL LIST :" + JSON.stringify(realList, null, 2));
		traceLB && traceLB("BANNED LIST :" + JSON.stringify(bannedList, null, 2));
		// ***
		// Synchronize list and real list
		// ***

		for (var i in list) {
			// Remove servers from list if there not configured anymore
			if (realList.indexOf(list[i]) === -1) delete list[i];
			// Remove servers from list if banned
			if (bannedList.indexOf(list[i]) !== -1) delete list[i];
		}
		// Concatenate list and real list to be sure to handle all configured servers
		var both = list.concat(realList);
		// remove twins
		list = both.filter(function(item, pos) {
			return both.indexOf(item) == pos;
		});
		// 
		var idx = 0;
		if (queryparams.SRVHOST && queryparams.SRVPORT) {
			var srvUuid;
			for (var j in servers) {
				if (servers[j].host(_) === queryparams.SRVHOST && servers[j].port(_) === queryparams.SRVPORT) {
					srvUuid = servers[j].$uuid;
					break;
				}
			}
			if (!srvUuid) throw new Error(locale.format(module, "noServerMatchInConf", queryparams.SRVHOST + ":" + queryparams.SRVPORT));
			idx = list.indexOf(srvUuid);
			if (idx === -1) {
				// Check if banned
				if (bannedList.indexOf(srvUuid) !== -1)
					throw new Error(locale.format(module, "serverBanned", queryparams.SRVHOST + ":" + queryparams.SRVPORT));
				throw new Error(locale.format(module, "noServerMatchInLB", queryparams.SRVHOST + ":" + queryparams.SRVPORT));
			}
		}
		// ***
		// Select server to use and Apply round robin algorithm : the first become the last...
		// ***
		var selectedUuid = list[idx];
		traceLB && traceLB("SELECTED UUID :" + JSON.stringify(selectedUuid, null, 2));
		traceLB && traceLB("LIST BEFORE ROUND ROBIN :" + JSON.stringify(list, null, 2));
		if (list.length > 1) {
			list.splice(idx, 1);
			list.push(selectedUuid);
		}
		traceLB && traceLB("LIST AFTER ROUND ROBIN :" + JSON.stringify(list, null, 2));
		var server = getServer(_, selectedUuid);
		if (!server) throw new Error(locale.format(module, "noServerAvailable"));
		traceLB && traceLB("SERVER SELECTED: " + server.$uuid);

		// check availability
		if (!server.isServerRunning(_)) {
			trace && trace(locale.format(module, "serverNotAvailable", server.host(_), server.port(_)));
			if (queryparams.SRVHOST && queryparams.SRVPORT) {
				throw new Error(locale.format(module, "serverNotAvailable", server.host(_), server.port(_)));
			}
			for (var k in list) {
				server = getServer(_, list[k]);
				if (server.isServerRunning(_)) {
					trace && trace(locale.format(module, "serverAvailable", server.host(_), server.port(_)));
					selectedUuid = list[k];
					list.splice(k, 1);
					list.push(selectedUuid);
					break;
				} else {
					trace && trace(locale.format(module, "serverNotAvailable", server.host(_), server.port(_)));
				}
			}

		}
		loadBalancer[solution][folder][site] = list;
		res = getServer(_, selectedUuid);
	});
	if (!res) throw new Error("Funnel failed");
	return res;
}

function storeInHttpSession(context, options) {
	//console.log("Store new proxy: "+JSON.stringify(options,null,2));
	context.httpSession.hrm = context.httpSession.hrm || {};
	context.httpSession.hrm.sessions = context.httpSession.hrm.sessions || {};
	context.httpSession.hrm.sessions[options.solution] = context.httpSession.hrm.sessions[options.solution] || {};
	context.httpSession.hrm.sessions[options.solution][options.folder] = context.httpSession.hrm.sessions[options.solution][options.folder] || {};
	context.httpSession.hrm.sessions[options.solution][options.folder][options.site] = context.httpSession.hrm.sessions[options.solution][options.folder][options.site] || {};

	context.httpSession.hrm.sessions[options.solution][options.folder][options.site][options.jsid] = options.proxy;
	context.httpSession.hrm.lastProxyUsed = options.proxy;

	return options.proxy;
}

function getProxyInstance(context, solution, folder, site, host, port, JSESSIONID) {

	function findInSessionMap(proxies, _solution, _folder, _site) {
		if (proxies) {
			var keys = Object.keys(proxies);
			var match, _jsid;
			for (var i in keys) {
				_jsid = keys[i];
				trace && trace("Check proxy instance in : solution [" + (_solution || solution) + "] ; folder [" + (_folder || folder) + "] ; site [" + (_site || site) + "] ; jsession [" + _jsid + "]");
				if (proxies[_jsid].baseUrl === baseUrl) {
					match = proxies[_jsid];
					match.nextForcedHeader = {
						key: "set-cookie",
						value: match["original-set-cookie"]
					};
					break;
				}
			}
			if (match && _jsid) return {
				mess: "Matching proxy configuration found [" + _jsid + "] on current site",
				jsid: _jsid,
				proxy: match
			};
		}
	}

	function findInSiteMap(sites, isCurrent, _solution, _folder) {
		if (sites) {
			var keys = Object.keys(sites);
			var match, _site;
			for (var i in keys) {
				_site = keys[i];
				if (isCurrent || (_solution !== solution && _folder !== folder && _site !== site)) {
					match = findInSessionMap(sites[_site], _solution, _folder, _site);
					if (match) break;
				}
			}
			if (match && _site) return {
				mess: "Matching proxy configuration found [" + match.jsid + "] on current folder ; site [" + _site + "]",
				site: _site,
				jsid: match.jsid,
				proxy: match.proxy
			};
		}
	}

	function findInFolderMap(folders, isCurrent, _solution) {
		if (folders) {
			var keys = Object.keys(folders);
			var match, _folder;
			for (var i in keys) {
				_folder = keys[i];
				if (isCurrent || (_solution !== solution && _folder !== folder)) {
					match = findInSiteMap(folders[_folder], false, _solution, _folder);
					if (match) break;
				}
			}
			if (match && _folder) return {
				mess: "Matching proxy configuration found [" + match.jsid + "] on current solution ; folder [" + _folder + "] ; site [" + match.site + "]",
				folder: _folder,
				site: match.site,
				jsid: match.jsid,
				proxy: match.proxy
			};
		}
	}

	function findInSolutionMap(items, isCurrent) {
		if (items) {
			var keys = Object.keys(items);
			var match, _solution;
			for (var i in keys) {
				_solution = keys[i];
				if (isCurrent || (_solution !== solution)) {
					match = findInFolderMap(items[_solution], false, _solution);
					if (match) break;
				}
			}
			if (match && _solution) return {
				mess: "Matching proxy configuration found [" + match.jsid + "] on  solution [" + _solution + "] ; folder [" + match.folder + "] ; site [" + match.site + "]",
				solution: _solution,
				folder: match.folder,
				site: match.site,
				jsid: match.jsid,
				proxy: match.proxy
			};
		}
	}

	//console.log("GLOBAL PROXIES MAP: "+JSON.stringify(context.httpSession && context.httpSession.hrm && context.httpSession.hrm.sessions,null,2));
	var baseUrl, p;
	if (solution && folder && site) {
		var globalMap = context.httpSession && context.httpSession.hrm && context.httpSession.hrm.sessions;
		var solMap = globalMap && globalMap[solution];
		var folMap = solMap && solMap[folder];
		var sitMap = folMap && folMap[site];
		p = sitMap && sitMap[JSESSIONID];

		// if target is specifically wanted, we try to find a matching proxy instance
		// else the last used proxy is taken
		if (host && port) {

			baseUrl = "http://" + host + ":" + port;
			if (!p || p.baseUrl !== baseUrl) {
				// Try to find matching proxy previously instanciated for same site
				var res = findInSessionMap(sitMap);
				if (!(res && res.jsid && res.proxy)) res = findInSiteMap(folMap, true);
				if (!(res && res.jsid && res.proxy)) res = findInFolderMap(solMap, true);
				if (!(res && res.jsid && res.proxy)) res = findInSolutionMap(globalMap, true);


				if (res && res.jsid && res.proxy) {
					if (!res.jsid) return;
					res.solution = solution;
					res.folder = folder;
					res.site = site;
					p = storeInHttpSession(context, res);
					trace && trace(res.mess);
				} else {
					p = null;
				}
			} else {
				trace && trace("Keep current proxy configuration");
			}
		}
	} else {
		p = context.httpSession && context.httpSession.hrm && context.httpSession.hrm.lastProxyUsed;
		if (p) trace && trace("Select latest proxy configuration used because of special resource: " + context.request.url);
	}
	if (p) trace && trace("***\nSelected proxy configuration base url: " + p.baseUrl + "\n***");
	return p;
}

function getSite(_, options) {
	if (!options || !options.SITE || !options.SOL || !options.FLDR) return;
	var filter = {
		sdataWhere: "name eq '" + options.SITE + "' and endpoint.x3ServerFolder eq '" + options.FLDR + "' and endpoint.x3SolutionName eq '" + options.SOL + "'"
	};
	var db = adminHelper.getCollaborationOrm(_);
	return db.fetchInstance(_, db.model.getEntity(_, "siteHRM"), filter);
}

function initHrm(_, context, suburl) {
	function authenticate(_, context, webBaseUrl, solution, folder, siteName, certificate, suburl) {
		function getPortal(_) {
			var options = {
				method: context.method,
				url: webBaseUrl + "/xtend/page/" + context.toWalk() + "?" + context.rawQuery,
				headers: context.request.headers
			};
			trace && trace("get portal request: " + JSON.stringify(options, null, 2));
			var request = httpClient.httpRequest(_, options);
			var buf;
			while ((buf = context.request.read(_))) {
				request.write(_, buf, "binary");
			}
			var resp = request.end().response(_);
			trace && trace("get portal response:" + JSON.stringify({
				status: resp.statusCode,
				headers: resp.headers
			}, null, 2));
			return {
				id: proxy.getCookie(resp.headers['set-cookie'], "JSESSIONID") || proxy.getCookie(options.headers.cookie, "JSESSIONID"),
				resp: resp
			};
		}

		function connection(_) {
			var body = {
				"solution": solution,
				"folder": folder
			};
			var data = JSON.stringify(body);
			var header = {
				"content-type": "application/json",
				"accept": "application/json",
				"accept-language": selectedLocale,
				"content-length": data.length
			};
			var options = {
				method: "POST",
				url: ssoBaseUrl + "/$connections",
				headers: header
			};
			trace && trace("auth request ($connection): " + JSON.stringify(options, null, 2));
			var request = httpClient.httpRequest(_, options);
			var resp = request.end(data).response(_);
			// Connection cookies will be required by client
			connectSetCookie = resp.headers['set-cookie'];
			return {
				id: proxy.getCookie(resp.headers['set-cookie'], "JSESSIONID") || proxy.getCookie(options.headers.cookie, "JSESSIONID"),
				resp: resp
			};
		}

		function session(_, body, headers) {
			var pubkeyName = nodeconfig.config.sdata.pubkeyName;
			if (certificate) {
				pubkeyName = certificate.name(_).replace(/[\@\$\.]/g, "_");
			} else if (nodeconfig.config.x3key) { // use internal certificate of this server
				pubkeyName = require('os').hostname().toLowerCase().replace(/[\@\$\.]/g, "_");
			}
			var sess = {
				connectionId: body.id,
				auth: {
					method: body.auth && body.auth.method,
					pubkey: pubkeyName,
					user: x3login
				}
			};
			sess.auth.signature = x3helpers.getSignature(_, body.auth && body.auth.challenge, x3login, certificate);

			var data = JSON.stringify(sess);
			// Set $connection response cookies in $session request
			// Merge $connection response cookies with the proxy cookies map

			proxy.manageCookie(p.mapCookie, syrSessionId, headers);

			var header = {
				//"host": host + ":" + port,
				"content-type": "application/json",
				"accept": "application/json",
				"content-length": data.length,
				"content-encoding": "utf-8",
				"accept-language": selectedLocale,
				"cookie": p.mapCookie[syrSessionId], // Set $connection response cookies in $session request
				"referer": context.httpSession.host + suburl
			};
			var opt = {
				method: "POST",
				url: ssoBaseUrl + "/$sessions",
				headers: header
			};
			trace && trace("auth request ($session): " + JSON.stringify(opt, null, 2));
			var request = httpClient.httpRequest(_, opt);
			return request.end(data).response(_);
		}
		// BEGIN AUTHENTICATE CLOSURE
		var ssoBaseUrl = webBaseUrl + "/xtend/xtendsso/" + solution + "/" + folder + "/" + siteName;

		var up = context.getUserProfile(_);
		// Force selected user profile endpoint to get right X3 login
		if (up.selectedEndpoint(_).$uuid !== server._parent.endpoint(_).$uuid)
			up.selectedEndpoint(_, server._parent.endpoint(_));
		var x3login = up.user(_).getEndpointLogin(_, up.selectedEndpoint(_).$uuid);
		var selectedLocale = up.selectedLocale(_).code(_);

		try {
			// Send $connection request
			var result = connection(_);
			var resp = result.resp;
			var JSESSIONID = result.id;
			var connectBody = resp.readAll(_);
			connectBody = JSON.parse(connectBody);
			trace && trace("auth response ($connection):" + JSON.stringify({
				status: resp.statusCode,
				headers: resp.headers
			}, null, 2));

			if (resp.statusCode !== 201) {
				throw new Error(locale.format(module, "connectionFailed"));
			}
			// Send $session request
			resp = session(_, connectBody, resp.headers);
			trace && trace("auth response ($session):" + JSON.stringify({
				status: resp.statusCode,
				headers: resp.headers
			}, null, 2));
			// Return response as it is...
			return {
				auth: true,
				id: JSESSIONID,
				resp: resp
			};
		} catch (e) {
			trace && trace("An error occured while authentication :\n" + JSON.stringify(connectBody, null, 2) + "\n" + e.stack);
			return getPortal(_);
		}
	}
	// BEGIN INITHRM CLOSURE
	// syracuse.sid is used to handle properly cookies

	var params = querystring.parse(context.rawQuery);
	var solution = params.SOL;
	var folder = params.FLDR;
	var site = params.SITE;
	try {
		var syrport = context.request.connection.localPort;
		var syrSessionId = proxy.getCookie(context.request.headers.cookie, "syracuse.sid." + syrport);



		// Apply load balancing (round robin)
		var server = selectServer(_, params);

		// Force web server if querystring said it
		var host = server.host(_);
		var port = server.port(_);
		var webServerBaseUrl = "http://" + host + ":" + port;

		// Instanciate proxy
		var p = new proxy.Proxy(_, webServerBaseUrl, trace);

		// process authentication requests -> if fail request classic auth portal
		var result = authenticate(_, context, webServerBaseUrl, params.SOL, params.FLDR, params.SITE, null, suburl);
		var resp = result.resp;
		var JSESSIONID = result.id;

		// Store proxy in httpSession	
		p = storeInHttpSession(context, {
			solution: solution,
			folder: folder,
			site: site,
			jsid: JSESSIONID,
			proxy: p
		});

		// Set $connection + $session response cookies in first response sent to client
		if (result.auth) {
			resp.headers['x-challenge-auth'] = true;
			var connectSetCookie;
			if (!resp.headers['set-cookie'])
				resp.headers['set-cookie'] = [];
			resp.headers['set-cookie'].push(connectSetCookie);
		}

		// Store original set-cookie information in proxy instance to be able to reuse it.
		if (resp.headers['set-cookie']) {
			p["original-set-cookie"] = resp.headers['set-cookie'];
		}

		// Decide what encoding to use...
		var encoding = resp.headers['content-type'] && resp.headers['content-type'].indexOf('charset=utf-8') !== -1 ? "utf-8" : "binary";
		// Send response (with custom cookies) to browser
		proxy.manageCookie(p.mapCookie, syrSessionId, resp.headers);
		context.response.writeHead(resp.statusCode, resp.headers);
		var buf;
		while ((buf = resp.read(_))) {
			context.response.write(_, buf, encoding);
		}
		context.response.end();
	} catch (e) {
		if (context.httpSession && context.httpSession.hrm && context.httpSession.hrm.sessions && context.httpSession.hrm.sessions[solution] && context.httpSession.hrm.sessions[solution][folder] && context.httpSession.hrm.sessions[solution][folder][site] && context.httpSession.hrm.sessions[solution][folder][site][JSESSIONID])
			delete context.httpSession.hrm.sessions[solution][folder][site][JSESSIONID];
		throw e;
	}
}

function forward(_, context, path, solution, folder, site, JSESSIONID) {
	try {

		solution = solution || context.request.hrmSolution;
		folder = folder || context.request.hrmFolder;
		site = site || context.request.hrmSite;
		JSESSIONID = JSESSIONID || proxy.getCookie(context.request.headers.cookie, "JSESSIONID");

		var params = querystring.parse(context.rawQuery);
		var host = params.SRVHOST;
		var port = params.SRVPORT;


		//console.log("Searching context: "+JSON.stringify({JSESSIONID: JSESSIONID, solution: solution, folder: folder, site: site, host: host, port: port},null,2));
		// Identify what proxy to use thanks to httpSession informations
		var p = getProxyInstance(context, solution, folder, site, host, port, JSESSIONID);
		if (p) {
			// If proxy found, forward request
			p.forward(_, context, path);
		} else {
			// Else, reinitialize connection
			if (!p) trace && trace("No proxy found !!! New Tomcat session will be created.");
			initHrm(_, context, "/xtend/page/" + context.toWalk());
		}
	} catch (e) {
		console.error(e.stack);
		if (context.httpSession && context.httpSession.hrm && context.httpSession.hrm.sessions && context.httpSession.hrm.sessions[solution] && context.httpSession.hrm.sessions[solution][folder] && context.httpSession.hrm.sessions[solution][folder][site] && context.httpSession.hrm.sessions[solution][folder][site][JSESSIONID])
			delete context.httpSession.hrm.sessions[JSESSIONID];
		throw e;
	}
}

var _xtendMap = {
	walk: function(_, context, name, id) {
		switch (name) {
			case "page":
				var params = querystring.parse(context.rawQuery);
				var solution = params.SOL;
				var folder = params.FLDR;
				var site = params.SITE;

				// Set language
				params.LANG = locale.x3Language(context.getUserProfile(_).selectedLocale(_).code(_));
				context.rawQuery = querystring.stringify(params);

				var JSESSIONID = proxy.getCookie(context.request.headers.cookie, "JSESSIONID");
				if (JSESSIONID) {
					trace && trace("***\nTry to reuse tomcat session !!!\n***");
					// The session exists (or maybe not and 'forward' method will do the job)
					return forward(_, context, "/xtend/page/" + context.toWalk(), solution, folder, site, JSESSIONID);
				} else {
					// initialize session and store proxy instance in httpSession
					trace && trace("***\nFirst HRM site access !!! New Tomcat session will be created.\n***");
					initHrm(_, context, "/xtend/" + name + "/" + context.toWalk());
					return;
				}
				break;
			case "svc":
				context.request.rsrcKind = "svc";
				return _dispatch(_, context, _solutionMap);
			case "ajax":
				context.request.rsrcKind = "ajax";
				return _dispatch(_, context, _solutionMap);
			case "remote":
				context.request.rsrcKind = "static";
				return _dispatch(_, context, _solutionMap);
			case "X_HTML":
				return _dispatch(_, context, _siteMap);
			default:
				return _dispatch(_, context, _xtendMap);
		}
	},
	get: function(_, context, walkedUrl) {
		return forward(_, context, "/" + walkedUrl);
	},
	post: function(_, context, walkedUrl) {
		return forward(_, context, "/" + walkedUrl);
	},
	put: function(_, context, walkedUrl) {
		return forward(_, context, "/" + walkedUrl);
	},
	"delete": function(_, context, walkedUrl) {
		return forward(_, context, "/" + walkedUrl);
	}
};


var _solutionMap = {
	walk: function(_, context, name, id) {
		context.request.hrmSolution = name;
		return _dispatch(_, context, _folderMap);
	}
};

var _folderMap = {
	walk: function(_, context, name, id) {
		context.request.hrmFolder = name;
		switch (context.request.rsrcKind) {
			case "svc":
			case "ajax":
				return _dispatch(_, context, _siteMap);
			case "static":
				return _dispatch(_, context, _xtendMap);
			default:
				return _dispatch(_, context, _xtendMap);
		}
	}
};

var _siteMap = {
	walk: function(_, context, name, id) {
		context.request.hrmSite = name;
		return _dispatch(_, context, _xtendMap);
	}
};



function _parseSegment(segment) {
	var match = /^([^\/(]*)\('([^']*)'\)$/.exec(segment);
	return match ? {
		name: match[1],
		id: match[2]
	} : {
		name: segment
	};
}

function _dispatch(_, context, map) {
	//console.log("Walked: " + context.walked());
	var seg = context.walkUrl();
	if (seg == null) {
		// we reached the end of the URL, dispatch method
		//var method = context.request.method.toLowerCase();
		var method = context.method;
		if (map[method]) {
			var walkedUrl = context.walked().split("/").slice(3).join('/');
			return map[method](_, context, walkedUrl);
		} else throw context.badMethod(method);
	} else {
		var pair = _parseSegment(seg);
		if (pair.name[0] === '$') {
			var name = pair.name.substring(1);
			if (map[name]) {
				return map[name](_, context, pair.id);
			}
		} else if (map.walk) {
			return map.walk(_, context, pair.name, pair.id);
		}
		throw context.badRequest(locale.format(module, "unexpectedSegment", seg));
	}
}

function _logRequest(_, context) {
	if (!context.request.headers["x-history-title"]) return;
	//
	var db = adminHelper.getCollaborationOrm(_);
	var h = db.model.getEntity(_, "navHistory").factory.createInstance(_, null, db);
	h.title(_, context.request.headers["x-history-title"]);
	h.agent(_, context.request.headers["x-history-agent"]);
	h.url(_, context.request.url);
	h.save(_);
}

function _doIt(_, context) {
	try {
		var protocol = context.walkUrl();
		if (protocol !== "xtend") throw new Error(locale.format(module, "badUrl", protocol));
		context.request.hrm = context.request.hrm || {};
		// fire and forget log call
		_logRequest(!_, context);
		_dispatch(_, context, _xtendMap);
	} catch (ex) {
		if (ex.httpStatus) {
			return context.reply(_, ex.httpStatus, ex.message);
		} else if (ex.stack) {
			return context.reply(_, 500, ex.message + "\n" + ex.stack);
		} else {
			return context.reply(_, 500, ex.toString());
		}
	}
}

exports.dispatcher = function(config) {
	return function(_, request, response) {
		var context = new Context(request, response, config);
		request.context = context;
		try {
			_doIt(_, context);
		} catch (err) {
			helpers.log.exception(module, err);
			context.reply(_, 500, err.message + "\n" + err.stack);
		}
	};
};