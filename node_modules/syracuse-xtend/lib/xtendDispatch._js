"use strict";

var helpers = require("syracuse-core/lib/helpers");
var Context = require("syracuse-sdata/lib/sdataContext").Context;
var proxy = require('syracuse-main/lib/proxy');
var registry = require("syracuse-sdata/lib/sdataRegistry");
var dataModel = require("syracuse-orm/lib/dataModel");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var locale = require("syracuse-core/lib/locale");
var globals = require("streamline/lib/globals");
var querystring = require('querystring');
var httpClient = require("syracuse-httpclient/lib/httpClient");
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var util = require('util');
var x3helpers = require('syracuse-x3/lib/helpers');

var trace = nodeconfig.config && nodeconfig.config.xtend && nodeconfig.config.xtend.proxy && nodeconfig.config.xtend.proxy.trace;
var loadBalancer = {};

function selectServer(_, solution, folder, site, servers) {
	loadBalancer[solution] = loadBalancer[solution] || {};
	loadBalancer[solution][folder] = loadBalancer[solution][folder] || {};
	var list = loadBalancer[solution][folder][site] = loadBalancer[solution][folder][site] || [];
	var realList = servers.map(function(item) {
		return item.$uuid;
	});
	// Remove servers from list if there not configured anymore
	for (var i in list) {
		if (realList.indexOf(list[i]) === -1) delete list[i];
	}
	// Cancat list and real list to be sure to handle all configured servers
	var both = list.concat(realList);
	// remove twins
	list = both.filter(function(item, pos) {
		return both.indexOf(item) == pos;
	});
	var selectedUuid = list[0];
	// Apply round robin : the first become the last...
	list = list.slice(1);
	list.push(selectedUuid);
	loadBalancer[solution][folder][site] = list;
	return servers[realList.indexOf(selectedUuid)];
}

function getSite(_, options) {
	if (!options || !options.SITE || !options.SOL || !options.FLDR) return;
	var filter = {
		sdataWhere: "name eq '" + options.SITE + "' and endpoint.x3ServerFolder eq '" + options.FLDR + "' and endpoint.x3SolutionName eq '" + options.SOL + "'"
	};
	var db = adminHelper.getCollaborationOrm(_);
	return db.fetchInstance(_, db.model.getEntity(_, "siteHRM"), filter);
}

function initHrm(_, context, suburl) {
	function authenticate(_, context, baseUrl, solution, folder, siteName, certificate, suburl) {
		function getPortal(_) {
			var options = {
				method: context.method,
				url: baseUrl + "/xtend/page/" + context.toWalk() + "?" + context.rawQuery,
				headers: context.request.headers
			};
			trace && trace("get portal request: " + JSON.stringify(options, null, 2));
			var request = httpClient.httpRequest(_, options);
			var buf;
			while ((buf = context.request.read(_))) {
				request.write(_, buf, "binary");
			}
			var resp = request.end().response(_);
			trace && trace("get portal response:" + JSON.stringify({
				status: resp.statusCode,
				headers: resp.headers
			}, null, 2));
			return {
				id: proxy.getCookie(resp.headers['set-cookie'], "JSESSIONID") || proxy.getCookie(options.headers.cookie, "JSESSIONID"),
				resp: resp
			};
		}

		function connection(_) {
			var body = {
				"solution": solution,
				"folder": folder
			};
			var data = JSON.stringify(body);
			var header = {
				"content-type": "application/json",
				"accept": "application/json",
				"accept-language": selectedLocale,
				"content-length": data.length
			};
			var options = {
				method: "POST",
				url: ssoBaseUrl + "/$connection",
				headers: header
			};
			trace && trace("auth request ($connection): " + JSON.stringify(options, null, 2));
			var request = httpClient.httpRequest(_, options);
			var resp = request.end(data).response(_);
			// Connection cookies will be required by client
			connectSetCookie = resp.headers['set-cookie'];
			return {
				id: proxy.getCookie(resp.headers['set-cookie'], "JSESSIONID") || proxy.getCookie(options.headers.cookie, "JSESSIONID"),
				resp: resp
			};
		}

		function session(_, body, headers) {
			var pubkeyName = nodeconfig.config.sdata.pubkeyName;
			if (certificate) {
				pubkeyName = certificate.name(_).replace(/[\@\$\.]/g, "_");
			} else if (nodeconfig.config.x3key) { // use internal certificate of this server
				pubkeyName = require('os').hostname().toLowerCase().replace(/[\@\$\.]/g, "_");
			}
			var sess = {
				connectionId: body.id,
				auth: {
					method: body.auth && body.auth.method,
					pubkey: pubkeyName,
					user: x3login
				}
			};
			sess.auth.signature = x3helpers.getSignature(_, body.auth && body.auth.challenge, x3login, certificate);

			var data = JSON.stringify(sess);
			// Set $connection response cookies in $session request
			// Merge $connection response cookies with the proxy cookies map

			proxy.manageCookie(p.mapCookie, syrSessionId, headers);

			var header = {
				"content-type": "application/json",
				"accept": "application/json",
				"content-length": data.length,
				"content-encoding": "utf-8",
				"accept-language": selectedLocale,
				"cookie": p.mapCookie[syrSessionId], // Set $connection response cookies in $session request
				"referer": "http://ecchambard-001:8124" + suburl
			};
			var opt = {
				method: "POST",
				url: ssoBaseUrl + "/$session",
				headers: header
			};
			trace && trace("auth request ($session): " + JSON.stringify(opt, null, 2));
			var request = httpClient.httpRequest(_, opt);
			return request.end(data).response(_);
		}
		//

		var ssoBaseUrl = baseUrl + "/xtend/xtendsso/" + solution + "/" + folder + "/" + siteName;

		var up = context.getUserProfile(_);
		// Force selected user profile endpoint to get right X3 login
		if (up.selectedEndpoint(_).$uuid !== site.endpoint(_).$uuid)
			up.selectedEndpoint(_, site.endpoint(_));
		var x3login = up.user(_).getEndpointLogin(_, up.selectedEndpoint(_).$uuid);
		var selectedLocale = up.selectedLocale(_).code(_);

		try {
			// Send $connection request
			var result = connection(_);
			var resp = result.resp;
			var JSESSIONID = result.id;
			var connectBody = resp.readAll(_);
			connectBody = JSON.parse(connectBody);
			trace && trace("auth response ($connection):" + JSON.stringify({
				status: resp.statusCode,
				headers: resp.headers
			}, null, 2));

			if (resp.statusCode !== 201) {
				throw new Error("The request $connection failed");
			}
			// Send $session request
			resp = session(_, connectBody, resp.headers);
			trace && trace("auth response ($session):" + JSON.stringify({
				status: resp.statusCode,
				headers: resp.headers
			}, null, 2));
			// Return response as it is...
			return {
				auth: true,
				id: JSESSIONID,
				resp: resp
			};
		} catch (e) {
			trace && trace("An error occured while parsing connection response :\n" + JSON.stringify(connectBody, null, 2) + "\n" + e.stack);
			return getPortal(_);
		}
	}
	//
	// syracuse.sid is used to handle properly cookies
	var syrport = context.request.connection.localPort;
	var syrSessionId = proxy.getCookie(context.request.headers.cookie, "syracuse.sid." + syrport);

	var params = querystring.parse(context.rawQuery);
	// Retrieve HRM Site instance
	var site = getSite(_, params);
	if (!site) throw new Error("No HRM site found for parameters : " + JSON.stringify(params, null, 2));

	var servers = site.servers(_).toArray(_);
	if (servers.length === 0) throw new Error("No XTend web server defined on HRM site '" + site.name(_) + "'");
	// Apply load balancing (round robin)
	var server = selectServer(_, params.SOL, params.FLDR, params.SITE, servers);

	// Force web server if querystring said it
	var host = params.SRVHOST || server.host(_);
	var port = params.SRVPORT || server.port(_);
	var webServerBaseUrl = "http://" + host + ":" + port;

	// Instanciate proxy
	var p = new proxy.Proxy(_, webServerBaseUrl, trace);

	// process authentication requests -> if fail forward to auth portal
	var result = authenticate(_, context, webServerBaseUrl, params.SOL, params.FLDR, params.SITE, null, suburl);
	var resp = result.resp;
	var JSESSIONID = result.id;

	// Store proxy if not already exist
	context.httpSession.hrmSessions = context.httpSession.hrmSessions || {};
	context.httpSession.hrmSessions[JSESSIONID] = p;

	// Set $connection + $session response cookies in first response sent to client
	// Add first connection request cookies
	if (result.auth) {
		var connectSetCookie;
		if (!resp.headers['set-cookie'])
			resp.headers['set-cookie'] = [];
		resp.headers['set-cookie'].push(connectSetCookie);
	}
	proxy.manageCookie(p.mapCookie, syrSessionId, resp.headers);

	// Decide what encoding to use...
	var encoding = resp.headers['content-type'] && resp.headers['content-type'].indexOf('charset=utf-8') !== -1 ? "utf-8" : "binary";
	// Send custom response to browser
	context.response.writeHead(resp.statusCode, resp.headers);
	var buf;
	while ((buf = resp.read(_))) {
		context.response.write(_, buf, encoding);
	}
	context.response.end();
}

function forward(_, context, path, JSESSIONID) {
	JSESSIONID = JSESSIONID || proxy.getCookie(context.request.headers.cookie, "JSESSIONID");
	//console.log("JSESSIONID found to forward: "+JSESSIONID);
	// Identify what proxy to use thanks to httpSession informations
	var p = context.httpSession.hrmSessions && context.httpSession.hrmSessions[JSESSIONID];
	if (p) {
		// If proxy found, forward request
		p.forward(_, context, path);
	} else {
		// Else, reinitialize connection
		initHrm(_, context, "/xtend/page/" + context.toWalk());
	}
}

var _xtendMap = {
	walk: function(_, context, name, id) {
		switch (name) {
			case "page":
				var JSESSIONID = proxy.getCookie(context.request.headers.cookie, "JSESSIONID");
				if (JSESSIONID) {
					// The session exists (or maybe not and 'forward' method will do the job)
					return forward(_, context, "/xtend/page/" + context.toWalk() + "?" + context.rawQuery, JSESSIONID);
				} else {
					// initialize session and store proxy instance in httpSession
					initHrm(_, context, "/xtend/" + name + "/" + context.toWalk());
					return;
				}
				break;
			default:
				return _dispatch(_, context, _xtendMap);
		}
	},
	get: function(_, context, walkedUrl) {
		return forward(_, context, "/" + walkedUrl);
	},
	post: function(_, context, walkedUrl) {
		return forward(_, context, "/" + walkedUrl);
	},
	put: function(_, context, walkedUrl) {
		return forward(_, context, "/" + walkedUrl);
	},
	"delete": function(_, context, walkedUrl) {
		return forward(_, context, "/" + walkedUrl);
	}
};

function _parseSegment(segment) {
	var match = /^([^\/(]*)\('([^']*)'\)$/.exec(segment);
	return match ? {
		name: match[1],
		id: match[2]
	} : {
		name: segment
	};
}

function _dispatch(_, context, map) {
	//console.log("Walked: " + context.walked());
	var seg = context.walkUrl();
	if (seg == null) {
		// we reached the end of the URL, dispatch method
		//var method = context.request.method.toLowerCase();
		var method = context.method;
		if (map[method]) {
			var walkedUrl = context.walked().split("/").slice(3).join('/');
			return map[method](_, context, walkedUrl);
		} else throw context.badMethod(method);
	} else {
		var pair = _parseSegment(seg);
		if (pair.name[0] === '$') {
			var name = pair.name.substring(1);
			if (map[name]) {
				return map[name](_, context, pair.id);
			}
		} else if (map.walk) {
			return map.walk(_, context, pair.name, pair.id);
		}
		throw context.badRequest(locale.format(module, "unexpectedSegment", seg));
	}
}

function _logRequest(_, context) {
	if (!context.request.headers["x-history-title"]) return;
	//
	var db = adminHelper.getCollaborationOrm(_);
	var h = db.model.getEntity(_, "navHistory").factory.createInstance(_, null, db);
	h.title(_, context.request.headers["x-history-title"]);
	h.agent(_, context.request.headers["x-history-agent"]);
	h.url(_, context.request.url);
	h.save(_);
}

function _doIt(_, context) {
	try {
		var protocol = context.walkUrl();
		if (protocol !== "xtend") throw new Error(locale.format(module, "badUrl", protocol));
		context.request.hrm = context.request.hrm || {};
		// fire and forget log call
		_logRequest(!_, context);
		_dispatch(_, context, _xtendMap);
	} catch (ex) {
		console.log("ERROR: " + ex.stack);
		if (ex.httpStatus) {
			return context.reply(_, ex.httpStatus, ex.message);
		} else if (ex.stack) {
			return context.reply(_, 500, ex.message);
		} else {
			return context.reply(_, 500, ex.toString());
		}
	}
}

exports.dispatcher = function(config) {
	return function(_, request, response) {
		var context = new Context(request, response, config);
		request.context = context;
		try {
			_doIt(_, context);
		} catch (err) {
			helpers.log.exception(module, err);
			context.reply(_, 500, err.message + "\n" + err.stack);
		}
	};
};