"use strict";

var helpers = require("syracuse-core/lib/helpers");
var Context = require("syracuse-sdata/lib/sdataContext").Context;
var proxy = require('syracuse-main/lib/proxy');
var registry = require("syracuse-sdata/lib/sdataRegistry");
var dataModel = require("syracuse-orm/lib/dataModel");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var locale = require("syracuse-core/lib/locale");
var globals = require("streamline/lib/globals");
var querystring = require('querystring');
var httpClient = require("syracuse-httpclient/lib/httpClient");
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var util = require('util');
var x3helpers = require('syracuse-x3/lib/helpers');

var trace = nodeconfig.config && nodeconfig.config.xtend && nodeconfig.config.xtend.proxy && nodeconfig.config.xtend.proxy.trace;
var proxies = {};

function getSite(_, options) {
	if (!options || !options.SITE || !options.SOL || !options.FLDR) return;
	var filter = {
		sdataWhere: "name eq '" + options.SITE + "' and endpoint.x3ServerFolder eq '" + options.FLDR + "' and endpoint.x3SolutionName eq '" + options.SOL + "'"
	};
	var db = adminHelper.getCollaborationOrm(_);
	return db.fetchInstance(_, db.model.getEntity(_, "siteHRM"), filter);
}

function initHrm(_, context, suburl) {
	function authenticate(_, context, baseUrl, solution, folder, site, certificate, suburl) {
		function connection(_) {
			var body = {
				"solution": solution,
				"folder": folder
			};
			var data = JSON.stringify(body);
			var header = {
				"content-type": "application/json",
				"accept": "application/json",
				"accept-language": selectedLocale,
				"content-length": data.length
			};
			var opt = {
				method: "POST",
				url: baseUrl + "/$connection",
				headers: header
			};
			trace && trace("auth request ($connection): " + JSON.stringify(opt, null, 2));
			var request = httpClient.httpRequest(_, opt);
			return request.end(data).response(_);
		}

		function session(_, body, headers) {
			var pubkeyName = nodeconfig.config.sdata.pubkeyName;
			if (certificate) {
				pubkeyName = certificate.name(_).replace(/[\@\$\.]/g, "_");
			} else if (nodeconfig.config.x3key) { // use internal certificate of this server
				pubkeyName = require('os').hostname().toLowerCase().replace(/[\@\$\.]/g, "_");
			}
			var sess = {
				connectionId: body.id,
				auth: {
					method: body.auth && body.auth.method,
					pubkey: pubkeyName,
					user: x3login
				}
			};
			sess.auth.signature = x3helpers.getSignature(_, body.challenge, x3login, certificate);

			var data = JSON.stringify(sess);
			// Set $connection response cookies in $session request
			// Merge $connection response cookies with the proxy cookies map
			proxy.manageCookie(p.mapCookie, syrSessionId, headers);

			var header = {
				"content-type": "application/json",
				"accept": "application/json",
				"content-length": data.length,
				"content-encoding": "utf-8",
				"accept-language": selectedLocale,
				"cookie": p.mapCookie[syrSessionId], // Set $connection response cookies in $session request
				"referer": "http://ecchambard-001:8124" + suburl
			};
			var opt = {
				method: "POST",
				url: baseUrl + "/$session",
				headers: header
			};
			trace && trace("auth request ($session): " + JSON.stringify(opt, null, 2));
			var request = httpClient.httpRequest(_, opt);
			return request.end(data).response(_);
		}
		//
		baseUrl = baseUrl + "/xtend/xtendsso/" + solution + "/" + folder + "/" + site;

		var up = context.getUserProfile(_);
		var x3login = up.user(_).getEndpointLogin(_, up.selectedEndpoint(_).$uuid);
		var selectedLocale = up.selectedLocale(_).code(_);

		// Send $connection request
		var resp = connection(_);
		var connect = JSON.parse(resp.readAll(_));

		trace && trace("auth response ($connection):" + JSON.stringify({
			status: resp.statusCode,
			headers: resp.headers
		}, null, 2));

		if (resp.statusCode !== 201) {
			throw new Error("The request $connection failed");
		}
		// Send $session request
		resp = session(_, connect, resp.headers);
		trace && trace("auth response ($session):" + JSON.stringify({
			status: resp.statusCode,
			headers: resp.headers
		}, null, 2));
		if (resp.statusCode !== 200) {
			// DO NOTHING : Return response as it is...
		}
		// Merge response cookies with the proxy cookies map
		//proxy.manageCookie(p.mapCookie, syrSessionId, resp.headers);
		return resp;
	}
	//
	var params = querystring.parse(context.rawQuery);

	var site = getSite(_, params);
	if (!site) throw new Error("No HRM site found for parameters : " + JSON.stringify(params, null, 2));

	context.request.hrm.SOL = params.SOL;
	context.request.hrm.FLDR = params.FLDR;
	context.request.hrm.SITE = params.SITE;

	var servers = site.servers(_).toArray(_);
	if (servers.length === 0) throw new Error("No XTend web server defined on HRM site '" + site.name(_) + "'");

	var pId = params.SOL + "_" + params.FLDR + "_" + params.SITE;
	var host = params.SRVHOST || servers[0].host(_);
	var port = params.SRVPORT || servers[0].port(_);

	// TODO TCA: implement load balancing (round robin)
	var webServerUrl = "http://" + host + ":" + port;

	var syrport = context.request.connection.localPort;
	var syrSessionId = proxy.getCookie(context.request.headers.cookie, "syracuse.sid." + syrport);

	// Instanciate and store proxy if not already exist
	proxies[pId] = proxies[pId] || {};
	var p = proxies[pId][host + "_" + port] = proxies[pId][host + "_" + port] || new proxy.Proxy(_, webServerUrl, trace);

	// Store info in httpSession
	context.httpSession.hrm = context.httpSession.hrm || {};
	context.httpSession.hrm.latest = pId;
	context.httpSession.hrm[pId] = host + "_" + port;

	// process two authenticate requests
	var resp = authenticate(_, context, webServerUrl, params.SOL, params.FLDR, params.SITE, null, suburl);

	var encoding = resp.headers['content-type'] && resp.headers['content-type'].indexOf('charset=utf-8') !== -1 ? "utf-8" : "binary";
	// Set $session response cookies in first response sent to client
	context.response.writeHead(resp.statusCode, resp.headers);
	var buf;
	while ((buf = resp.read(_))) {
		context.response.write(_, buf, encoding);
	}
	context.response.end();
}

function forward(_, context, path) {
	var pId;
	if (context.request.hrm.SOL && context.request.hrm.FLDR && context.request.hrm.SITE) {
		pId = context.request.hrm.SOL + "_" + context.request.hrm.FLDR + "_" + context.request.hrm.SITE;
		// No other solution found. 
		// There is nothing in the URL that allow to identify what site and so what web server must to be reached.
		// This is potentially a bug...
		context.httpSession.hrm = context.httpSession.hrm || {};
		context.httpSession.hrm.latest = pId;
	} else {
		pId = context.httpSession.hrm.latest;
	}
	// Identify what proxy to use thanks to httpSession informations
	var p = pId && proxies[pId] && context.httpSession.hrm && context.httpSession.hrm[pId] && proxies[pId][context.httpSession.hrm[pId]];
	if (p) {
		p.forward(_, context, path);
	} else {
		throw new Error("The HRM proxy associated to your Http session was lost.");
	}
}

var _xtendMap = {
	walk: function(_, context, name, id) {
		switch (name) {
			case "page":
				try {
					var suburl = "/xtend/" + name + "/" + context.toWalk();
					// Call initHrm to store proxy instance in httpSession
					initHrm(_, context, suburl);
					return;
				} catch (e) {
					// If an error occured while authentication, we forward to authentication portal...
					console.error(e.stack);
					//return forward(_, context, suburl);
				}
				break;
			case "remote":
				return _dispatch(_, context, _solutionMap);
			case "X_HTML":
				return _dispatch(_, context, _siteMap);
			default:
				return _dispatch(_, context, _xtendMap);
		}
	},
	get: function(_, context, walkedUrl) {
		return forward(_, context, "/" + walkedUrl);
	},
	post: function(_, context, walkedUrl) {
		return forward(_, context, "/" + walkedUrl);
	},
	put: function(_, context, walkedUrl) {
		return forward(_, context, "/" + walkedUrl);
	},
	"delete": function(_, context, walkedUrl) {
		return forward(_, context, "/" + walkedUrl);
	}
};

var _solutionMap = {
	walk: function(_, context, name) {
		context.request.hrm.SOL = name;
		return _dispatch(_, context, _folderMap);
	}
};

var _folderMap = {
	walk: function(_, context, name) {
		context.request.hrm.FLDR = name;
		return _dispatch(_, context, _xtendMap);
	}
};

var _siteMap = {
	walk: function(_, context, name) {
		context.request.hrm.SITE = name;
		return _dispatch(_, context, _xtendMap);
	}
};

function _parseSegment(segment) {
	var match = /^([^\/(]*)\('([^']*)'\)$/.exec(segment);
	return match ? {
		name: match[1],
		id: match[2]
	} : {
		name: segment
	};
}

function _dispatch(_, context, map) {
	var seg = context.walkUrl();
	if (seg == null) {
		// we reached the end of the URL, dispatch method
		//var method = context.request.method.toLowerCase();
		var method = context.method;
		if (map[method]) {
			var walkedUrl = context.walked().split("/").slice(3).join('/');
			return map[method](_, context, walkedUrl);
		} else throw context.badMethod(method);
	} else {
		var pair = _parseSegment(seg);
		if (pair.name[0] === '$') {
			var name = pair.name.substring(1);
			if (map[name]) {
				return map[name](_, context, pair.id);
			}
		} else if (map.walk) {
			return map.walk(_, context, pair.name, pair.id);
		}
		throw context.badRequest(locale.format(module, "unexpectedSegment", seg));
	}
}

function _logRequest(_, context) {
	if (!context.request.headers["x-history-title"]) return;
	//
	var db = adminHelper.getCollaborationOrm(_);
	var h = db.model.getEntity(_, "navHistory").factory.createInstance(_, null, db);
	h.title(_, context.request.headers["x-history-title"]);
	h.agent(_, context.request.headers["x-history-agent"]);
	h.url(_, context.request.url);
	h.save(_);
}

function _doIt(_, context) {
	try {
		var protocol = context.walkUrl();
		if (protocol !== "xtend") throw new Error(locale.format(module, "badUrl", protocol));
		context.request.hrm = context.request.hrm || {};
		// fire and forget log call
		_logRequest(!_, context);
		_dispatch(_, context, _xtendMap);
	} catch (ex) {
		console.error("ERROR: " + ex.stack);
		if (ex.httpStatus) {
			return context.reply(_, ex.httpStatus, ex.message);
		} else if (ex.stack) {
			return context.reply(_, 500, ex.message);
		} else {
			return context.reply(_, 500, ex.toString());
		}
	}
}

exports.dispatcher = function(config) {
	return function(_, request, response) {
		var context = new Context(request, response, config);
		request.context = context;
		try {
			_doIt(_, context);
		} catch (err) {
			helpers.log.exception(module, err);
			context.reply(_, 500, err.message + "\n" + err.stack);
		}
	};
};