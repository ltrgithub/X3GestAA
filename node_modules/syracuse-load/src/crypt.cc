#include <node.h>
#include <node_buffer.h>
#include <v8.h>
#include <stdio.h>
#include <cstdlib>
#include <ctime>

using namespace v8;
using namespace node;

// Native module for passphrase encryption.
// Uses CryptProtectData under Windows and AES256 under Linux after making a key out of operating system ID (D-Bus machine ID) and user UID.


// convert buffer to local value
#define BUFFERCONV(ARG) Local<Value>::New((ARG)->handle_)

#ifdef WIN32
#pragma comment(lib, "crypt32.lib")
#include <windows.h>
#include <Wincrypt.h>

bool cryptWindows(char* input, Local<Value>* result)
{
	DATA_BLOB data_in;
	DATA_BLOB data_out;
	data_in.pbData = (BYTE *) input;    
	data_in.cbData = (DWORD) strlen(input);
	if (CryptProtectData(&data_in, NULL, NULL, NULL, NULL, CRYPTPROTECT_UI_FORBIDDEN, &data_out))
	{
		Buffer* resultb = Buffer::New((char*) data_out.pbData, (size_t) data_out.cbData);
		LocalFree(data_out.pbData);
		*result = BUFFERCONV(resultb);
		return true;
	}
	else
	{
		LocalFree(data_out.pbData);
		char errortext[30];
		sprintf(errortext, "Encryption error %d", GetLastError());
		ThrowException(Exception::Error(String::New(errortext)));
		return false;
	}
}

bool decryptWindows(Local<Object> input, Local<Value>* result)
{
	DATA_BLOB data_in;
	DATA_BLOB data_out;
	data_in.pbData = (BYTE*) Buffer::Data(input);    
	data_in.cbData = (DWORD) Buffer::Length(input);
	if (CryptUnprotectData(&data_in, NULL, NULL, NULL, NULL, CRYPTPROTECT_UI_FORBIDDEN, &data_out))
	{
		*result = String::New((char*) data_out.pbData, data_out.cbData);
		return true;
	}
	else
	{
		LocalFree(data_out.pbData);
		char errortext[30];
		sprintf(errortext, "Decryption error %d", GetLastError());
		ThrowException(Exception::Error(String::New(errortext)));
		return false;
	}
}
#else

#include <unistd.h>
#include <sys/types.h>

// JavaScript function for AES
static Persistent<Function> encryptFunction;
static bool encryptFunctionDefined = false;

// JavaScript code for AES encryption/decryption
char script[] = "(function (require) { "
	"var crypto = require('crypto');"
	"return function(key, code, enc, iv) {"
	"var c = (enc ? crypto.createCipheriv('aes256', key, iv) : crypto.createDecipheriv('aes256', key, iv));"
	"var r =  new Buffer(c.update(code, null, 'binary')+c.final('binary'), 'binary');"
	"return r;"
	"}"
	"})";

// read operating system ID
int getId(char* id, int size) 
{
	FILE* f;
	int result;
	f = fopen("/var/lib/dbus/machine-id", "r");
	if (!f) 
	    return 0;
	result = fread(id, 1, size, f);
	fclose(f);
	return result;
}


inline static void demangle(unsigned char* buffer, size_t length)
{
	if (length > 0)
	{
		for (size_t i = 0; i <= 3*length; i++)
			buffer[i % length] ^= (((43*i) % 256) ^ buffer[(i+1) % length] ^ (73*buffer[(i+3) % length])%256);
	}
}

inline static void mangle(unsigned char* buffer, size_t length)
{
	if (length > 0)
	{
		for (int i = (int) (3*length); i >= 0; i--)
			buffer[i % length] ^= (((43*i) % 256) ^ buffer[(i+1) % length] ^ (73*buffer[(i+3) % length])%256);
	}
}



// calls the JavaScript function and returns true if there is no exception. The return value will be placed within result. If the JavaScript function
// throws an exception, the result is false; in this case call scope.Close() immediately and exit the function.
static bool callSafe(Handle<Function> fkt, unsigned argc, Local<Value> argv[], Local<Value> * result) {
	TryCatch trycatch;
	*result = fkt->Call(Context::GetCurrent()->Global(), argc, argv);
	if (trycatch.HasCaught())
	{
		trycatch.ReThrow();
		return false;
	}
	return true;
}

/* executes the Javascript code in the first argument which must be a function with 1 parameter, then executes the function and returns the result */
static bool script_exec(const char* script, Local<Value>* result, Local<Value> arg0) 
{
	Local<Value> res = Script::New(String::New(script))->Run();
	if (res->IsNull() || res->IsUndefined())
		return false;
	const unsigned argc = 1;
	Local<Value> argv[argc] = {arg0};
	Local<Function> fkt = Local<Function>::Cast(res);
	return callSafe(fkt, argc, argv, result);
}


static bool makeEncryptFunction(Local<Value> req) 
{
	if (!encryptFunctionDefined)
	{
		Local<Value> result0;
		if (!script_exec(script, &result0, req))
			return false;
  		if (result0->IsNull())
			return false;
		encryptFunction = Persistent<Function>::New(Local<Function>::Cast(result0));
		encryptFunctionDefined = true;
	}
	return true;
}

// safe call to encrypt function: will return false when there is an error
static bool callEncryptFunction(Local<Value> input, Local<Value>* output, Buffer* key, Buffer* iv, bool encrypt)
{
	const unsigned argc = 4;
	Local<Value> argv[argc] = { BUFFERCONV(key), input, Boolean::New(encrypt)->ToBoolean(), BUFFERCONV(iv) };
	return callSafe(encryptFunction, argc, argv, output);
}

#define KEY_LENGTH 32
#define IV_LENGTH 16
// use D-Bus machine ID and user ID to create a 32 byte key
bool makeKey(Buffer** result, char* iv)
{
  char key[KEY_LENGTH];
  int length;
  int i;
  // initialize key;
  for (i=0; i<KEY_LENGTH; i++)
  {
	  key[i] = i;
  }
  // set machine-id
  length = getId(key, KEY_LENGTH);
  if (!length)
  {
	ThrowException(Exception::Error(String::New("No ID")));
    return false;
  }
  // some transformation ...
  demangle((unsigned char*) key, KEY_LENGTH);
  // set user ID
  sprintf(key, "%lx", (long unsigned) getuid());
  for (i=0; i<IV_LENGTH; i++)
  {
	  key[i] ^= iv[i];
  }
  // some transformation ...
  demangle((unsigned char*) key, KEY_LENGTH);
  *result = Buffer::New(key, KEY_LENGTH);
  return true;
}


bool cryptLinux(char* input, Local<Value>* result, Local<Value> req)
{
	char ch_iv[IV_LENGTH];
	srand((unsigned int) time(NULL));
	for (int i=0; i<16; i++)
		ch_iv[i] = rand() % 256;
	Buffer* iv = Buffer::New(ch_iv, 16);
	Buffer* key;
	// mangling only works when length is at least 4
	size_t inputlength1 = strlen(input)+1;
	size_t inputlength = inputlength1 < 4 ? 4 : inputlength1;
	if (!makeKey(&key, ch_iv))
		return false;
	Buffer* toEncrypt = Buffer::New(inputlength);
	char* data = Buffer::Data(toEncrypt); // changes to 'data' will change the bytes in the buffer
	memcpy(data, input, inputlength);
	// fill missing data with null bytes (will be stripped in the end of decryption)
	for (size_t i=inputlength1; i<4; i++)
		data[i] = 0;
	mangle((unsigned char*) (data), inputlength);
	if (!makeEncryptFunction(req))
		return false;
	Local<Value> encrypted;
	if (!callEncryptFunction(BUFFERCONV(toEncrypt), &encrypted, key, iv, true))
		return false;
	size_t encryptedLength = Buffer::Length(encrypted->ToObject());
	// add iv to encrypted data
	Buffer* encryptedIv = Buffer::New(encryptedLength+IV_LENGTH);
	char* encryptedIvData = Buffer::Data(encryptedIv); // changes in encryptedIvData will change buffer contents
	memcpy(encryptedIvData, ch_iv, IV_LENGTH);
	memcpy(encryptedIvData+IV_LENGTH, Buffer::Data(encrypted->ToObject()), encryptedLength);
	*result = BUFFERCONV(encryptedIv);
	return true;
}


bool decryptLinux(Local<Object> input, Local<Value>* result, Local<Value> req)
{
	Buffer* key;
	char* input_data = Buffer::Data(input);
	size_t input_length = Buffer::Length(input);
	if (input_length < IV_LENGTH)
	{
		ThrowException(String::New("Cannot decrypt data"));
		return false;
	}
	if (!makeKey(&key, input_data))
		return false;
	if (!makeEncryptFunction(req))
		return false;
	Local<Value> decrypted;
	// find out IV and strip IV from encrypted data
	Buffer* iv = Buffer::New(input_data, IV_LENGTH);
	Buffer* input1 = Buffer::New(input_data+IV_LENGTH, input_length-IV_LENGTH);
	if (!callEncryptFunction(BUFFERCONV(input1), &decrypted, key, iv, false))
		return false;
	Local<Object> decrypted1 = decrypted->ToObject();
	char* content = Buffer::Data(decrypted1);
	int length = (int) Buffer::Length(decrypted1);
	demangle((unsigned char*) content, length);
	if (content[length-1] != 0) // test whether string ends with null byte
	{
		ThrowException(String::New("Wrong result after decryption"));
		return false;
	}
	// this will strip all trailing null bytes
	*result = String::New(content);
	return true;
}
#endif


/* encrypt passphrases
 */
 
static Handle<Value> encrypt(const Arguments &args)
{
	HandleScope scope;
	if (args.Length() < 2) 
	{
		ThrowException(Exception::TypeError(String::New("Wrong number of arguments")));
		return scope.Close(Undefined());
	}
	if (args[0]->IsUndefined() || args[0]->IsNull()) 
	{
	    ThrowException(Exception::TypeError(String::New("Nothing to encrypt")));
		return scope.Close(Undefined());
	}
	if (!args[1]->IsObject())
	{
	    ThrowException(Exception::TypeError(String::New("Second argument no object")));
		return scope.Close(Undefined());
	}
	String::Utf8Value text(args[0]->ToString());
    Local<Value> result;
#ifdef WIN32
	if (!cryptWindows(*text, &result))
        return scope.Close(Undefined());
#else
	if (!cryptLinux(*text, &result, args[1]))
        return scope.Close(Undefined());
#endif
	return scope.Close(result);
}

/* decrypt passphrases
 */
static Handle<Value> decrypt(const Arguments &args)
{
	HandleScope scope;
	if (args.Length() < 2) 
	{
		ThrowException(Exception::TypeError(String::New("Wrong number of arguments")));
		return scope.Close(Undefined());
	}
	if (!Buffer::HasInstance(args[0])) 
	{
		ThrowException(Exception::TypeError(String::New("First argument is no buffer")));
		return scope.Close(Undefined());
	}
	if (!args[1]->IsObject())
	{
	    ThrowException(Exception::TypeError(String::New("Second argument no object")));
		return scope.Close(Undefined());
	}
    Local<Value> result;
#ifdef WIN32
	if (!decryptWindows(args[0]->ToObject(), &result))
		return scope.Close(Undefined());
#else
	if (!decryptLinux(args[0]->ToObject(), &result, args[1]))
		return scope.Close(Undefined());
#endif
	return scope.Close(result);
}

void init(Handle<Object> target)
{
	target->Set(String::NewSymbol("encrypt"), FunctionTemplate::New(encrypt)->GetFunction());
	target->Set(String::NewSymbol("decrypt"), FunctionTemplate::New(decrypt)->GetFunction());
}

NODE_MODULE(crypt, init)
