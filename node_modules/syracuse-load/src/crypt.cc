#include <node.h>
#include <node_buffer.h>
#include <v8.h>
#include <stdio.h>
#include <cstdlib>
#include <ctime>

using namespace v8;
using namespace node;

// convert buffer to local value
#define BUFFERCONV(ARG) Local<Value>::New((ARG)->handle_)


#ifdef WIN32
#pragma comment(lib, "crypt32.lib")
#include <windows.h>
#include <Wincrypt.h>

Local<Value> cryptWindows(char* input)
{
	DATA_BLOB data_in;
	DATA_BLOB data_out;
	data_in.pbData = (BYTE *) input;    
	data_in.cbData = (DWORD) strlen(input);
	if (CryptProtectData(&data_in, NULL, NULL, NULL, NULL, CRYPTPROTECT_LOCAL_MACHINE|| CRYPTPROTECT_UI_FORBIDDEN, &data_out))
	{
		Buffer* result = Buffer::New((char*) data_out.pbData, (size_t) data_out.cbData);
		LocalFree(data_out.pbData);
		return BUFFERCONV(result);
	}
	else
	{
		LocalFree(data_out.pbData);
		char errortext[30];
		sprintf(errortext, "Encryption error %d", GetLastError());
		ThrowException(Exception::Error(String::New(errortext)));
		return String::New("");
	}
}

Local<Value> decryptWindows(Local<Object> input)
{
	DATA_BLOB data_in;
	DATA_BLOB data_out;
	data_in.pbData = (BYTE*) Buffer::Data(input);    
	data_in.cbData = (DWORD) Buffer::Length(input);
	if (CryptUnprotectData(&data_in, NULL, NULL, NULL, NULL, CRYPTPROTECT_UI_FORBIDDEN, &data_out))
	{
		Local<String> result = String::New((char*) data_out.pbData, data_out.cbData);
		return result;
	}
	else
	{
		LocalFree(data_out.pbData);
		char errortext[30];
		sprintf(errortext, "Decryption error %d", GetLastError());
		ThrowException(Exception::Error(String::New(errortext)));
		return String::New("");
	}
}
#else

#include <unistd.h>
#include <sys/types.h>
int getId(char* id, int size) 
{
  FILE* f;
  int result;
  f = fopen("/var/lib/dbus/machine-id", "r");
  if (!f) 
    return 0;
  result = fread(id, 1, size, f);
  printf("GETUID %d", getuid(void));
  fclose(f);
  return result;
}

Local<Value> cryptLinux(char* input)
{
  char id[40];
  int length;
  int inputlength;
  int i;
  inputlength = strlen(input);
  length = getId(id, 40);
  if (!length)
  {
	ThrowException(Exception::Error(String::New("No ID")));
    return String::New("");
  }
  for (i=0; i<inputlength; i++)
  {
    input[i] ^= id[i % length];
  }
  Buffer* result = Buffer::New(input, (size_t) inputlength);
  return BUFFERCONV(result);
}

Local<Value> decryptLinux(Local<Object> input)
{
  char id[40];
  int length;
  int inputlength;
  int i;
  char* encrypted;
  encrypted = (char*) Buffer::Data(input);    
  inputlength = Buffer::Length(input);
  length = getId(id, 40);
  if (!length)
  {
	ThrowException(Exception::Error(String::New("No ID")));
    return String::New("");
  }
  for (i=0; i<inputlength; i++)
  {
    encrypted[i] ^= id[i % length];
  }
  Local<String> result = String::New((char*) encrypted, inputlength);
  return result;
}

#endif


/* encrypt passphrases
 */
 
static Handle<Value> encrypt(const Arguments &args)
{
	HandleScope scope;
	if (args.Length() < 1 || args[0]->IsUndefined() || args[0]->IsNull()) 
	{
	    ThrowException(Exception::TypeError(String::New("Nothing to encrypt")));
	}
	String::Utf8Value text(args[0]->ToString());
#ifdef WIN32
	Local<Value> result = cryptWindows(*text);
#else
    Local<Value> result = cryptLinux(*text);
#endif
	return scope.Close(result);
}

/* decrypt passphrases
 */
static Handle<Value> decrypt(const Arguments &args)
{
	HandleScope scope;
	if (args.Length() < 1 || !Buffer::HasInstance(args[0])) 
	{
		ThrowException(Exception::TypeError(String::New("Wrong number of arguments")));
	}
#ifdef WIN32
	Local<Value> result = decryptWindows(args[0]->ToObject());
#else
	Local<Value> result = decryptLinux(args[0]->ToObject());
#endif
	return scope.Close(result);
}

void init(Handle<Object> target)
{
	target->Set(String::NewSymbol("encrypt"), FunctionTemplate::New(encrypt)->GetFunction());
	target->Set(String::NewSymbol("decrypt"), FunctionTemplate::New(decrypt)->GetFunction());
}

NODE_MODULE(crypt, init)
