"use strict";
var util = require('util')
var stream = require('stream')
var mock = require('./mock')
var events = require('events');
// var tracer = console.log
var tracer = null;

/// ## StreamRecorder
/// The recorder stream is a readable stream which takes as many chunks as needed from the readable stream given in the argument
/// and can repeat it arbitrarily often.
function StreamRecorder(readableStream) {
	var self = this;
	// the chunks which have been recorded
	self.chunks = [];
	var _queue = [];
	// for 
	var callback = null;
	var paused = true; // is original stream paused?
	readableStream.pause();
	self.originalStream = readableStream;
	readableStream.on('data', function(data) {
		tracer && tracer("Recorder on data " + data.length)
		self.chunks.push(data);
		readableStream.pause();
		paused = true;
		while (_queue.length > 0) {
			_queue.shift()._processData();
		}
	})

	readableStream.on('end', function(chunk) {
		tracer && tracer("Recorder on end" + self.chunks.length)
		self.chunks.push(null);
		while (_queue.length > 0) {
			_queue.shift()._processData();
		}
	})

	self.queue = function(stream) {
		tracer && tracer("Queue")
		_queue.push(stream);
		if (paused) {
			tracer && tracer("Resume readable stream")
			readableStream.resume();
			paused = false;
		}
	}
	/// The method newStream() returns a readable stream. There can be an arbitrary number of readable streams. They all take their
	/// data from the recorded chunks of the original stream.
	self.newStream = function() {
		return new _RecorderStream(self);
	}

	/// Asynchronous function which loads fully the source stream so that it can be closed afterwards
	self.loadFully = function(callback) {
		// take dummy writable stream which just calls callback function on end and pipe stream to this stream
		function DummyWritableStream() {
			this.writable = true;
			this.write = function(data) {
				console.log("write" + data);
				return true;
			}
			this.end = function(data) {
				console.log("end" + data);
				return callback(null);
			}
		}
		DummyWritableStream.prototype = new events.EventEmitter();
		var dummy = new DummyWritableStream();
		self.newStream().pipe(dummy);
	}

}

// Internal class: get a readable stream
function _RecorderStream(mainStream) {
	var self = this;
	tracer && tracer("RECORDER STREAM")
	stream.Stream.call(this);
	/// The original stream is available as attribute `originalStream`
	self.headers = mainStream.originalStream.headers;
	self.url = mainStream.originalStream.url;
	self.method = mainStream.originalStream.method;
	var index = 0;
	var paused = false;
	var _remainingBytes = 0;
	var _remainingBuffer = null;
	var _encoding = null;
	self.readable = true;
	self.writable = false;

	self.pause = function() {
		tracer && tracer("Recorder pause")
		paused = true;
	}

	self.resume = function() {
		tracer && tracer("Recorder resume")
		paused = false;
		self._processData();
	}

	self._processData = function() {
		tracer && tracer("Recorder process data")
		process.nextTick(function() {
			tracer && tracer("Recorder Next tick")
			if (!paused) {
				tracer && tracer("Recorder fetch data " + index + " " + util.format(mainStream.chunks))
				if (index >= mainStream.chunks.length) {
					tracer && tracer("Recorder resume source")
					// get next chunk of data
					mainStream.queue(self);
					return;
				}
				var _chunk = mainStream.chunks[index++];
				if (_chunk) {
					tracer && tracer("Recorder emit data " + _chunk.length)
					if (_encoding) {
						// try whether buffer can be converted completely to string
						if (_remainingBuffer) {
							_chunk = Buffer.concat([_remainingBuffer, _chunk])
							_remainingBuffer = null;
						}
						var remaining = mock.bufferEncoding(_chunk, _encoding)
						if (remaining) {
							var start = _chunk.length - remaining
							if (start === 0) {
								_remainingBuffer = _chunk;
								// it does not make sense to send an empty string to the listeners - therefore no 'emit'
							} else {
								_remainingBuffer = _chunk.slice(_chunk.length - remaining);
								var text = _chunk.slice(0, _chunk.length - remaining).toString(_encoding);
								// transmit the data
								self.emit('data', text)
							}
						} else {
							var text = _chunk.toString(_encoding);
							self.emit('data', text);
						}
					} else self.emit('data', _chunk);
					if (!paused) {
						tracer && tracer("Recorder Process data again")
						return self._processData();
					}
				} else {
					tracer && tracer("Recorder emit end")
					self.emit('end');
				}
			}
		});
	}

	self.setEncoding = function(encoding) {
		// normalize the encoding
		_encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, '');
	}

	self._processData();

}

util.inherits(_RecorderStream, stream.Stream);

exports.StreamRecorder = StreamRecorder;