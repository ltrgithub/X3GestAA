"use strict"
var util = require('util')
var stream = require('stream')

// var tracer = console.log
var tracer = null;


/// ## RecorderStream
/// The recorder stream is a readable stream which takes as many chunks as needed from the readable stream given in the argument
/// It records the chunks and can replay them after reset() has been called. This means that the original stream can be read as
/// many times as necessary. It does not support `setEncoding` and only works with binary data.
function RecorderStream(readableStream) {
	var self = this;
	// the chunks which have been recorded
	self.chunks = [];
	var _queue = [];
	var paused = true; // is original stream paused?
	readableStream.pause();
	self.originalStream = readableStream;
	readableStream.on('data', function(data) {
		tracer && tracer("Recorder on data "+data.length)
		self.chunks.push(data);
		readableStream.pause();
		paused = true;
		while (_queue.length > 0) {
			_queue.shift()._processData();
		}
	})

	readableStream.on('end', function(chunk) {
		tracer && tracer("Recorder on end"+self.chunks.length)
		self.chunks.push(null);		
		while (_queue.length > 0) {
			_queue.shift()._processData();
		}
	})
	
	self.queue = function(stream) {
		tracer && tracer("Queue")
		_queue.push(stream);
		if (paused) {
			tracer && tracer("Resume readable stream")
			readableStream.resume();
			paused = false;
		}		
	}
	self.newStream = function() {
		return new _RecorderStream(self);
	}
	
		
} 



/// The constructor `ReadableStream(readableStream)` takes as its argument the original stream which should be replayed as often as necessary
function _RecorderStream(mainStream) {
	var self = this;
	tracer && tracer("RECORDER STREAM")
	stream.Stream.call(this);
/// The original stream is available as attribute `originalStream`
	self.headers = mainStream.originalStream.headers;
	self.url = mainStream.originalStream.url;
	self.method = mainStream.originalStream.method;
	var index = 0;
	var paused = false;
	self.readable = true;
	self.writable = false;

	self.pause = function() {
		tracer && tracer("2Recorder pause")
		paused = true;
	}
	
	self.resume = function() {
		tracer && tracer("2Recorder resume")
		paused = false;
		self._processData();
	}
	
	self._processData = function() {
		tracer && tracer("2Recorder process data")
		process.nextTick(function() {
			tracer && tracer("2recorder Next tick")
			if (!paused) {
				tracer && tracer("2Recorder fetch data "+index+" "+util.format(mainStream.chunks))
				if (index >= mainStream.chunks.length) {
					tracer && tracer("2recorder resume source")
					// get next chunk of data
					mainStream.queue(self);					
					return;
				}
				var chunk = mainStream.chunks[index++];
				if (chunk) {
					tracer && tracer("2Recorder emit data "+chunk.length)
					self.emit('data', chunk);
					if (!paused) {
						tracer && tracer("2Recorder Process data again")
						return self._processData();
					} 
				}
				else {
					tracer && tracer("Recorder emit end")
					self.emit('end');				
				}
			}
		});
	}

	self.setEncoding = function(value) {
		throw new Error("setEncoding not supported for recorder stream")
	}

	self._processData();
	
}

util.inherits(_RecorderStream, stream.Stream);

exports.RecorderStream = RecorderStream;