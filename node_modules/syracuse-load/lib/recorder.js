var util = require('util')
var stream = require('stream')

/// ## RecorderStream
/// The recorder stream is a readable stream which takes as many chunks as needed from the readable stream given in the argument
/// It records the chunks and can replay them after reset() has been called. This means that the original stream can be read as
/// many times as necessary. It does not support `setEncoding` and only works with binary data.

/// The constructor `ReadableStream(readableStream)` takes as its argument the original stream which should be replayed as often as necessary
function RecorderStream(readableStream) {
	var self = this;
	stream.Stream.call(this);
/// The original stream is available as attribute `originalStream`
	self.originalStream = readableStream
	// the chunks which have been recorded
	var chunks = [];
	var index = 0;
	var paused = false;
	self.readable = true;
	self.writable = false;
	readableStream.pause();
	
	readableStream.on('data', function(data) {
		// console.log("Recorder on data "+data.length)
		chunks.push(data);
		readableStream.pause();
		if (!paused) _processData();
	})

	readableStream.on('end', function(chunk) {
		// console.log("Recorder on end"+chunks.length)
		chunks.push(null);
		if (!paused) _processData();
	})

	self.pause = function() {
		// console.log("Recorder pause")
		paused = true;
	}
	
	self.resume = function() {
		// console.log("Recorder resume")
		paused = false;
		_processData();
	}
	
/// The `reset` function removes all listeners, and the stream can be used again 
	self.reset = function() {
		// console.log("-------------------------RESET")
		self.removeAllListeners('data')
		self.removeAllListeners('end')
		index = 0;
	}
	
	function _processData() {
		// console.log("Recorder process data")
		process.nextTick(function() {
			// console.log("recorder Next tick")
			if (!paused) {
				// console.log("Recorder fetch data "+index+" "+util.format(chunks))
				if (index >= chunks.length) {
					// console.log("recorder resume source")
					// get next chunk of data
					readableStream.resume();
					return;
				}
				var chunk = chunks[index++];
				if (chunk) {
					// console.log("Recorder emit data "+chunk.length)
					self.emit('data', chunk);
					if (!paused) {
						// console.log("Recorder Process data again")
						return _processData();
					} 
				}
				else {
					// console.log("Recorder emit end")
					self.emit('end');				
				}
			}
		});
	}
	
}

util.inherits(RecorderStream, stream.Stream);

exports.RecorderStream = RecorderStream;