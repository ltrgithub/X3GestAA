"use strict"
var util = require('util')
var stream = require('stream')
var mock = require('./mock')

// var tracer = console.log
var tracer = null;


/// ## StreamRecorder
/// The recorder stream is a readable stream which takes as many chunks as needed from the readable stream given in the argument
/// and can repeat it arbitrarily often.
function StreamRecorder(readableStream) {
	var self = this;
	// the chunks which have been recorded
	self.chunks = [];
	var _queue = [];
	var paused = true; // is original stream paused?
	readableStream.pause();
	self.originalStream = readableStream;
	readableStream.on('data', function(data) {
		tracer && tracer("Recorder on data "+data.length)
		self.chunks.push(data);
		readableStream.pause();
		paused = true;
		while (_queue.length > 0) {
			_queue.shift()._processData();
		}
	})

	readableStream.on('end', function(chunk) {
		tracer && tracer("Recorder on end"+self.chunks.length)
		self.chunks.push(null);		
		while (_queue.length > 0) {
			_queue.shift()._processData();
		}
	})
	
	self.queue = function(stream) {
		tracer && tracer("Queue")
		_queue.push(stream);
		if (paused) {
			tracer && tracer("Resume readable stream")
			readableStream.resume();
			paused = false;
		}		
	}
/// The method newStream() returns a readable stream. There can be an arbitrary number of readable streams. They all take their
/// data from the recorded chunks of the original stream.
	self.newStream = function() {
		return new _RecorderStream(self);
	}
	
		
} 


// Internal class: get a readable stream
function _RecorderStream(mainStream) {
	var self = this;
	tracer && tracer("RECORDER STREAM")
	stream.Stream.call(this);
/// The original stream is available as attribute `originalStream`
	self.headers = mainStream.originalStream.headers;
	self.url = mainStream.originalStream.url;
	self.method = mainStream.originalStream.method;
	var index = 0;
	var paused = false;
	var _remainingBytes = 0;
	var _remainingBuffer = null;
	var _encoding = null;
	self.readable = true;
	self.writable = false;

	self.pause = function() {
		tracer && tracer("2Recorder pause")
		paused = true;
	}
	
	self.resume = function() {
		tracer && tracer("2Recorder resume")
		paused = false;
		self._processData();
	}
	
	self._processData = function() {
		tracer && tracer("2Recorder process data")
		process.nextTick(function() {
			tracer && tracer("2recorder Next tick")
			if (!paused) {
				tracer && tracer("2Recorder fetch data "+index+" "+util.format(mainStream.chunks))
				if (index >= mainStream.chunks.length) {
					tracer && tracer("2recorder resume source")
					// get next chunk of data
					mainStream.queue(self);					
					return;
				}
				var _chunk = mainStream.chunks[index++];
				if (_chunk) {
					tracer && tracer("2Recorder emit data "+chunk.length)
					if (_encoding) {
						// try whether buffer can be converted completely to string
						if (_remainingBuffer) {
							_chunk = Buffer.concat([_remainingBuffer, _chunk])
							_remainingBuffer = null;
						}
						var remaining = mock.bufferEncoding(_chunk, _encoding)
						if (remaining) {
							var start = _chunk.length-remaining
							if (start === 0) {
								_remainingBuffer = _chunk;
								// it does not make sense to send an empty string to the listeners - therefore no 'emit'
							} else {
								_remainingBuffer = _chunk.slice(_chunk.length-remaining);
								var text = _chunk.slice(0, _chunk.length-remaining).toString(_encoding);
								// transmit the data
								self.emit('data', text)
							}
						} else {
							var text = _chunk.toString(_encoding);
							self.emit('data', text);	
						}
					} else self.emit('data', _chunk);
					if (!paused) {
						tracer && tracer("2Recorder Process data again")
						return self._processData();
					} 
				}
				else {
					tracer && tracer("Recorder emit end")
					self.emit('end');				
				}
			}
		});
	}

	self.setEncoding = function(encoding) {
		// normalize the encoding
		_encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, '');	
	}

	self._processData();
	
}

util.inherits(_RecorderStream, stream.Stream);

exports.StreamRecorder = StreamRecorder;