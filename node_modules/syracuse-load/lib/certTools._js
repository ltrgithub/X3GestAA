"use strict";
var locale = require("syracuse-core/lib/locale");
var fs = require('streamline-fs');
var os = require('os');
var util = require('util');
var jsx509 = require('jsx509');
var config = require(__dirname+"/../../../nodelocal").config || {};
var crypto = require('crypto');
var lcHostName = os.hostname().toLowerCase();

/// !doc
/// 
/// # Certificate tools in connection with certificate entity
/// # for use with load balancer and Syracuse
///
/// ```javascript
/// var certTools = require('syracuse-load/lib/certTools')  
/// ```
/// 
var tracer = null;
// var tracer = console.log

/// -------------
/// ## sign function :
/// 
/// ``` javascript
/// var signature = certTools.sign(_, cert, algorithm, data, options);
/// ```
/// 
/// Sign data with private key from the certificate entity
/// 
/// * The `cert` parameter gives the name of the certificate in the certificate entity. When it is `null`,
///   the locally installed base certificate key will be taken. For use from the load balancer, also the corresponding object
///   can be given there.
/// * The `algorithm` parameter represents the algorithm to apply, e. g. RSA-SHA1
/// * The `data` parameter represents data to sign (string or buffer)
/// * The `options` parameter is optional and an object with keys `data_encoding` (specifies the encoding of the data 
///   (binary as a default or utf8) when data is a string), `output_encoding` (represents the encoding wanted for signature),
///   `certdir` (alternative certificate directory: for unit tests only)
///
/// Example: the invocation
///   digest(_, 'bla', 'RSA-SHA1', 'a', {input_encoding: 'utf8'})
/// gives the same result as the standard output of the command
///  openssl dgst -sha1 -passin pass:pwd -sign bla.key input.txt
/// where bla.key is assumed to be the encrypted password file with passphrase 'pwd', which is stored in the instance 'bla' of the certificate entity.
function sign(_, cert, algorithm, data, options) {
	var key;
	if (cert && cert.key) {
		key = cert.key;
	} else {
		// get contents of key file
		var directory = _getDirectory(options);
		cert = cert || lcHostName;
		var keyfile = fs.readFile(directory+cert + ".key", "utf8", _);
		var passPhrases = readPassphrases(directory, _);
		key = jsx509.stripEncryption(keyfile, passPhrases[cert]);
	}
	var signRes = crypto.createSign(algorithm);
	signRes.update(data, options ? options.data_encoding : undefined);
	return signRes.sign(key, options ? options.output_encoding : undefined);	

}
exports.sign = sign;

// get certificate directory within sign and verify
function _getDirectory(options) {
	if (options && options.certdir) {
		return options.certdir + "/";
	} else {
		if (!config.collaboration || !config.collaboration.certdir) {
			throw new Error(locale.format(module, "noCertDir"));
		}
		return config.collaboration.certdir + "/" + lcHostName + "/";			
	}
}


/// -------------
/// ## verify function :
/// 
/// ``` javascript
/// var verify = certTools.verify(_, cert, algorithm, data, signature, data_encoding, signature_encoding)
/// ```
/// 
/// Verifies data with public certificate from the certificate entity
/// 
/// * The `cert` parameter gives the name of the certificate in the certificate entity. When it is `null`,
///   the locally installed base certificate key will be taken. For use from the load balancer, also the corresponding object
///   can be given there.
/// * The `algorithm` parameter represents the algorithm to apply, e. g. RSA-SHA1
/// * The `data` parameter represents data to verify (string or buffer).
/// * The `signature` parameter contains the previously generated signature
/// * The `options` parameter is optional and an object with keys `data_encoding` (specifies the encoding of the data 
///   (binary as a default or utf8) when data is a string), `signature_encoding` (represents the encoding used for signature),
///   `certdir` (alternative certificate directory: for unit tests only)
///
/// Result is `true` when the check is successful, `false` otherwise.
function verify(_, cert, algorithm, data, signature, options) {
	var certificate;
	if (cert && cert.cert) {
		certificate = cert.cert;
	} else {
		// get contents of key file
		var directory = _getDirectory(options);
		cert = cert || lcHostName;
		certificate = fs.readFile(directory+cert + ".crt", "utf8", _);
	}
	var verifyRes = crypto.createVerify(algorithm);
	verifyRes.update(data, options ? options.data_encoding : undefined);
	return verifyRes.verify(certificate, signature, options ? options.signature_encoding : undefined);
}
exports.verify = verify;

/// -------------
/// ## getPEMCertificate function :
/// 
/// ``` javascript
/// var verify = certTools.getPEMCertificate(_, name)
/// ```
/// 
/// Retrieves certificate in PEM format as a string
/// 
/// * The `cert` parameter gives the name of the certificate in the certificate entity. When it is `null`,
///   the locally installed base certificate key will be taken.
/// * The `ca` parameter tells whether it is the certificate of the caCertificate entity
function getPEMCertificate(_, name, ca) {
	var certificate;
	// get contents of key file
	var directory = _getDirectory();
	name = name || (ca ? "ca" : lcHostName);
	try {
		certificate = fs.readFile(directory+name+(ca ? ".cacrt" : ".crt"), "utf8", _);		
	} catch (e) {
		throw new Error(locale.format(module, "noCert", name));
	}
	return certificate;
}
exports.getPEMCertificate = getPEMCertificate;

/// -------------
/// ## search and update certificates
/// 
/// ``` javascript
/// var result = certTools.parseRequestCert(_, data, certificates, caCertificates, directory, host);
/// ```
/// 
/// Perform file operations in certificate directory and update entries in local arrays of certificates and CA certificates
///
/// * The `data` parameter contains an array of objects which describe what to do (details below)
/// * The `certificates` parameter contains an array of local certificate data which should also be updated
/// * The `caCertificates` parameter contains an array of local CA certificate data which should also be updated
/// * The `directory` parameter contains the directory of the certificates in the file system (subdirectory of `config.collaboration.certdir`). The directory name must end with '/'
/// * The `host` parameter (optional) contains the object with the data of the host, whose `missingCert` and `missingCA` arrays should be updated. 
///   The names of incoming certificates will reduce the entries in the arrays missingCert and missingCA of the `host` parameter
/// * The `changed` parameter (optional) should point to an object. Its `missing` property will be set to true, when `host.missingCA` or `host.missingCert` 
///   has been changed (tell this to other servers!). When a server certificate (or one of its CA certificates) for an active connection has 
///   been changed, the `start` property will be set to true, when the certificate data have been empty (so that it is good to try to start the connection again)
///   otherwise the `restart` property will be set to true (active connections have been changed, therefore restart the server).
/// 
/// Structure of objects within `data` parameter:
/// name: logical name of certificate (as in Certificate/CaCertificate entity, obligatory) 
/// ca: when true, then it is CA authority certificate
/// del: when true, delete the named entry
/// get: when true, ask for these data
/// cert: certificate in PEM format (string)
/// key: key in PEM format (string)
/// pass: passphrase for key (string)
/// keyTest: when true, test whether private key is available (it may have been deleted locally)
/// cas: when set, this is an array with the names of CA certificates which should be tested

/// When 'del'  attribute is not set, and 'cert' or 'key' is set, update the data. Otherwise ask for the data. Available data of 
/// responses will be put into the reponse array which is the result of the function
/// Responses array will get an additional attribute 'changes' when host data have changed

function parseRequestCert(_, data, certificates, caCertificates, directory, host, changed) {
	tracer && tracer("parse request cert DATA " + util.format(data));
	var response = [];
	var updatePassphrases;
	var passphrases = readPassphrases(directory, _);

	data.forEach_(_, function(_, part) {
		var list = part.ca ? caCertificates : certificates;
		var crtExtension = part.ca ? ".cacrt" : ".crt";
		var filename;
		var index;
		var array;
		var i;		
		if (part.del) {
			// delete
			if (list) {
				for (i = 0; i < list.length; i++) {
					if (part.name === list[i].name) { // entry found
						// delete local entry
						list.splice(i, 1);
						break;
					}
				}
			}
			// delete file
			try {
				fs.unlink(directory+part.name+crtExtension, _);						
			} catch (e) {
				console.log("Deletion error certificate " + e);
			}
			if (!part.ca) {
				try {
					fs.unlink(directory+part.name+".key", _);					
				} catch (e) {
					console.log("Deletion error key file " + e);
				}
				if (part.name in passphrases) {
					delete passphrases[part.name];				
					updatePassphrases = true;
				}
			}
			if (host) {
				array = part.ca ? host.missingCA : host.missingCert;
				index = array.indexOf(part.name);
				if (index >= 0) {
					array.splice(index, 1);
					// changes in list of missing certificates
					if (changed) {
						changed.missing = true;
					}
				}
			}
		} else {
			if (part.cert || part.key || part.cas) {
				// update
				// check data
				// TODO: CA certificates
				// find local data
				var localEntry;
				if (list) {
					list.some(function(cert) {
						if (cert.name === part.name) {
							cert.cert = part.cert;
							localEntry = cert;
							return true;
						}
					});
				}
				tracer && tracer("Save certificate data " + util.format(localEntry));
				var checkCert = part.cert || (localEntry ? localEntry.certificate : null);
				var checkKey = part.key || (localEntry ? localEntry.key : null);
				if (!list) { // for usage outside of cluster 
					if (!part.cert) {
						try {
							checkCert = fs.readFile(directory+part.name+crtExtension, "utf8", _);							
						} catch (e) {
						// ignore non existing file
						}
					}
					if (!part.key) {
						try {
							var keyfile = fs.readFile(directory+part.name+".key", "utf8", _);
							checkKey = jsx509.stripEncryption(keyfile, passphrases[part.name]);
						} catch (e) {
							if (part.keyTest) {
								throw new Error(locale.format(module, "keyCorrupt",part.name, ""+e));
							}
						// ignore non existing file
						}
					} 
				}
				if (part.keyTest && !checkKey) {
					throw new Error(locale.format(module, "keyMissing", part.name));
				}
				var caCerts = [];
				if (part.cas) {
					for (var i=0; i<part.cas.length; i++) {
						var name = part.cas[i];
						if (caCertificates) {
							caCertificates.some(function(caCert) {
								if (caCert.name === name) {
									caCerts.push(caCert.certificate);
									return true;
								}
							});
						} else {
							try {
								caCerts.push(fs.readFile(directory+name+".cacrt", "utf8", _));							
							} catch (e) {
							// ignore non existing file
							}							
						}
					}
				}
				var integ = jsx509.integrity(checkCert, checkKey, part.pass, caCerts);
				if (integ.error) {
					throw new Error(locale.format(module, "certError", part.name, integ.error));
				}
				if (!fs.exists(directory, _)) fs.mkdir(directory, _);
				// update file system
				try {
					if (part.cert) {
						filename = directory + part.name + crtExtension;
						fs.writeFile(filename, part.cert, "utf8", _);
						fs.chmod(filename, 0x180, _); // read and write permissions: 0600
					}
				} catch (e) {
					throw new Error(locale.format(module, "certUpd", part.name, e));
				}
				if (!part.ca) {
					try {
						if (part.key) {
							passphrases[part.name] = part.pass;
							updatePassphrases = true;
							filename = directory + part.name + ".key";
							fs.writeFile(filename, part.key, "utf8", _);
							fs.chmod(filename, 0x180, _); // read and write permissions: 0600
						}
					} catch (e) {
						throw new Error(locale.format(module, "keyUpd", part.name, e))
					}					
				}
				// update local data
				if (list) {
					if (!localEntry) {
						localEntry = {name: part.name};
						list.push(localEntry);						
					}
					var change = false;
					var newData = !localEntry.certificate || (!part.ca && !localEntry.key);
					if (part.cert && localEntry.certificate !== part.cert) {
						localEntry.certificate = part.cert;
						change = true;
					}
					if (part.key && localEntry.key !== integ.key) {
						localEntry.key = integ.key; // decrypted key
						change = true;
					}
					if (change && host && changed && host.connectionData) {
						host.connectionData.forEach(function(data) {
							if (data.active) {
								if (_changes(data.serverCert, part.name, part.ca)) {
									if (newData) {
										changed.start = true;
									}
									else 
									{
										changed.restart = true;
									}
								}									
							}
						});
					}
				}
				if (host) {
					array = part.ca ? host.missingCA : host.missingCert;
					index = array.indexOf(part.name);
					if (index >= 0) {
						array.splice(index, 1);
						// changes in list of missing certificates
						if (changed) {
							changed.missing = true;
						}
					}
				}
			} else { // request data
				if (!list.some_(_, function(_, cert) {
					if (cert.name === part.name) {
						var encryptedKey;
						if (!part.ca && cert.key) {
							encryptedKey = fs.readFile(directory+part.name+".key", "utf8", _);					
						}
						response.push({name: part.name, ca: part.ca, cert: cert.certificate, key: encryptedKey, pass: passphrases[part.name]});
					}
				})) { // no answer found
					tracer && tracer("parseRequestCert: No answer found for "+part.name);
				}
			}
		}
	})
	if (updatePassphrases) {
		writePassphrases(directory, passphrases, _);
	}
	return response;
}
exports.parseRequestCert = parseRequestCert;

function _changes(cert, name, ca) {
	tracer && tracer("_changes " + name + " " + ca + " " + util.format(cert));
	if (!cert) {
		return false;
	}
	if (!ca) {
		return cert.name === name;
	}
	// test CA certificates
	if (!cert.caCertificates) {
		return false;
	}
	return cert.caCertificates.some(function(cacert) {
		return cacert.name === name;
	});
}

// load native module for passphrase encryption
function _getCryptoModule() {
	var arch = os.platform() + '_' + os.arch();
	var v8 = 'v8-' + /[0-9]+\.[0-9]+/.exec(process.versions.v8)[0];
	var filename = __dirname + '/../' + arch + '/' + v8 + '/crypt.node';
	if (fs.existsSync(filename)) return require(filename);
	else {
		filename = __dirname + '/../' + arch + '/default/crypt.node';
		if (fs.existsSync(filename)) return require(filename);
	}	
	throw new Error("crypto add-on missing for " + arch);
}

function readPassphrases(directory, _) {
	try {
		var crypted = fs.readFile(directory + lcHostName + ".pwd", "utf8", _);
		var cr = _getCryptoModule();
		return JSON.parse(cr.decrypt(new Buffer(crypted, "base64"), require));
	} catch (e) {
		console.log("Error in read passphrases "+e);
		return {};
	}
}
exports.readPassphrases = readPassphrases;


//write file with passphrases (directory must end with '/')
function writePassphrases(directory, phrases, _) {
	var filename = directory + lcHostName + ".pwd";
	var clear = JSON.stringify(phrases)
	var cr = _getCryptoModule();
	fs.writeFile(filename, cr.encrypt(clear, require).toString("base64"), "utf8", _);
	fs.chmod(filename, 0x180, _); // read and write permissions: 0600
}

exports.writePassphrases = writePassphrases;


/// -------------
/// ## convert entries of `missingCA` and `missingCert` into input for `parseRequestCert`
/// 
/// ``` javascript
/// certTools.pushMissing(host, data)
/// ```
/// 
/// Parameter `host` take attributes `missingCA` and `missingCert` from this
/// Parameter `data` push resulting data to this array (which should be input for `parseRequestCert` 
function pushMissing(host, data) {
	tracer && tracer("PUSH MISSING " + host.hostname)
	host.missingCA.forEach(function(name) {
		data.push({name: name, ca: true});
	});
	host.missingCert.forEach(function(name) {
		data.push({name: name, ca: false});
	});						
}
exports.pushMissing = pushMissing;

