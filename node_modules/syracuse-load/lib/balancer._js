var http = require('http');
var mongodb = require('mongodb');
var util = require('util');
var os = require('os');
var fs = require('fs')
var child_process = require('child_process')
var mock = require('./mock')
var recorder = require('./recorder')
var config;	
var db = null; // MongoDB handle

var BALANCER_HEADER = "syracuseBalancerHeader"; // special Http header for passing load balancing information

//list of sessions known to this balancer
var sessions = {}; // keys are Syracuse session ID's, values are corresponding server names and ports (as an array)
var hosts = []; // list of different Syracuse hosts, with following information: hostname, nannyPort, children, 
                // ports (array of all ports, generated from children), active: generally available, started: currently started 
                // version: Syracuse version (system is only usable when all versions are equal
hosts.mainVersion = ""; // main version of the cluster (will be set upon first response of another server or when no server responds)
var children = {}; // ports and objects of child processes. children.terminate will prevent restarting child processes
var childrenStarted = false; // child processes will not be started until the version is correct

// function copied from syracuse-core/lib/uuid.js
function generateUUID(sep) {
	var randomHex = function(len, mask, offset) {
		var n = Math.floor(Math.random() * (1 << 24));
		if (mask)
			n = (n & mask) + offset;
		var s = n.toString(16);
		return s.length >= len ? s.substring(0, len) : ("00000000".substring(0, len - s.length) + s);
	};
	// Version 4 UUIDs have the form
	// xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx with hexadecimal digits x
	// and hexadecimal digits 8, 9, A, or B for y
	if (sep == null)
		sep = '-';
	return randomHex(4) + randomHex(4) + sep + randomHex(4) + sep +
		randomHex(4, 0x0fff, 0x4000) +
		sep +
		randomHex(4, 0x3fff, 0x8000) +
		sep +
		randomHex(6) +
		randomHex(6);
};



function killChildren() {
	var ports = Object.keys(children); 
	if (ports.length > 0) {
		children.terminate = true;
		ports.forEach(function(port) {
			console.log("Kill child "+port);
			if (children[port]) children[port].kill();			
		});		
	}
	// console.log("Child processes terminated");	
}


process.on('exit', function() {
	// console.log("Terminate nanny");
	if (db) {
		db.close();
	}
	killChildren();
})

/** internal function to pass meta-commands to nanny
 * host: in hosts array
 * command: command to send (within path '/nannyCommand/')
 * forget: when set, host will not be marked as unavailable when there is an error (host will be marked as started when request is successful any way) 
 * return: data of response.
 */
function getIntern(hostdata, command, callback, forget) {
	console.log("GET "+command+" "+util.format(hostdata))
	var result = "";
	var options = {method: 'GET', hostname: hostdata.local ? "localhost" : hostdata.hostname , port: hostdata.nannyPort, path: "/nannyCommand/"+command};
	console.log("OP "+util.format(options))
	var req = http.request(options, function(res) {
		res.setEncoding("utf8");
		res.on("data", function(chunk) {
			result += chunk;
		});
		res.on("end", function(chunk) {
			hostdata.started = true;
			console.log("MARKED STARTED"+util.format(hostdata))
			return callback(null, result);
		})
	});
	req.on("error", function(e,d) { 
		console.log("REQUESTERROR"+e+" "+command+" forget "+forget+" hostdata "+util.format(hostdata)); 
		if (!forget && index) hostdata.started = false; 
		return callback(e)
	});
	req.end();
}

function get(index, command, _, forget) {
	return getIntern(index, command, _, forget);
}

/// converts a port range description into an array of ports
function portArray(ports, nannyPort) {	
	if (/^\d\d?$/.test(ports)) {
		var max = ports*1;
		if (!max)
			throw new Error("There must be at least one child process")
		// shared memory
		var result = [];
		result.length = max;
		for (var i = 0; i<max; i++)
			result[i] = "N"+i;
		return result;
	}
	if (ports.substr(0, 1) === "P") {		
		ports = ports.substr(1);
	}
	var parts = ports.split(/\s*,\s*/);
	var portsMap = {};
	portsMap[nannyPort] = 0; 
	parts.forEach(function(part) {
		var r = /^\s*(\d+)(?:\s*\-\s*(\d+))?\s*$/.exec(part);
		if (!r)
			throw new Error("Wrong format of range "+part);		
		var lowerBound = 1*r[1];
		var upperBound = 1*r[2];
		if (upperBound) {
			if (lowerBound > upperBound)
				throw new Error("Upper bound less than lower bound in range "+part);
		} else upperBound = lowerBound;
		for (var i=lowerBound; i <= upperBound; i++) {
			if (i in portsMap)
				throw new Error("Port already used: "+i);
			portsMap[i] = 0;			
		}
	});
	delete portsMap[nannyPort];
	return Object.keys(portsMap);
}
exports.portArray = portArray;

/// main function
function start(conf, _) {
//	console.log("START function")
	switch (process.argv[2]) {
	case "?":
	case "help":
	case "--help":
		console.log("Valid commands: ")
		console.log("node nanny install <Port> N<Number> [force]\n  Install process with port <Port> for nanny process, <Number> child processes.\n  The optional 'force' argument allows to override an existing installation")
		console.log("node nanny\n  (or: node nanny run) start nanny process")
		console.log("node nanny start\n  start nanny process in background as a detached process")
		console.log("node nanny stop\n  ask running nanny process to stop")
		console.log("node nanny remove\n  Remove data for host process")
		console.log("node nanny help\n  This help text")
		return 0;
	case "start":
		console.log("Start detached node process. Output goes to ./out.log");
		var out = fs.openSync('./out.log', 'a'); 
		var err = fs.openSync('./out.log', 'a');
		var child = child_process.spawn(process.argv[0], ["nanny", "run" ], { detached: true, stdio: [ 'ignore', out, err] });
		child.unref();
		return 0;
	}
	config = conf;
	config.servername =  os.hostname();
	config.collaboration = config.collaboration || {};
	if (config.collaboration.domain) {
		config.servername += ("."+config.collaboration.domain);
	}
	console.log("Server name "+config.servername)
	// Establish connection to db
	db = new mongodb.Db(config.collaboration.dataset || "syracuse", new mongodb.Server(config.collaboration.hostname || "localhost", config.collaboration.port || 27017,
			{}), {});	
	db = db.open(_);
	var hostsCollection = db.createCollection('Host', _);
	hosts = hostsCollection.find().toArray(_);
	// data for local host
	hosts.unshift(null);
	var i = hosts.length;
	while (--i >= 1) {
		var host = hosts[i]
		host.ports = portArray(host.children, host.nannyPort);
		if (host.hostname === config.servername) {
			host.local = true;
			host.started = true;
			hosts[0] = host;			
			hosts.splice(i, 1);
		}
	}
	switch (process.argv[2]) {
	case "install":
		try {
			if (!/^\d+$/.test(process.argv[3]))
				throw "Invalid nanny port number "+process.argv[3];
			portArray(process.argv[4], process.argv[3]); // result not required, only error messages 
			var nannyPort = 1*process.argv[3];
			var ports = process.argv[4];
			// console.log("INSTALL "+nannyPort, ports)
			if (hosts[0]) {
				console.log("Host found");
				if (process.argv[5] === "force") {
					try {
						get(hosts[0],  "shutdown", _, true);
					} catch (e) {
						console.log("ERROR shutdown "+e);
					}
					console.log("update");
					hostsCollection.update({hostname: config.servername}, {$set:{ nannyPort: nannyPort, children: ports, _updDate: new Date(), started: false}}, {w: 1}, _);
					return 0;
				} else {
					throw "Already installed";
				}				
			} else {
				// new host
				var newHost = {_id: generateUUID(), hostname: config.servername, nannyPort: nannyPort, children: ports, _creUser: "setup", _updUser: "setup", _updDate: new Date(), active: true, started: false}
				console.log("insert "+util.format(newHost));
				hostsCollection.insert(newHost, {w:1}, _);				
				return 0;
			}
		} finally {
			db.close();
		}
		break;
	case "run":
	case undefined:
		// read version file
		try {
			var ver = JSON.parse(fs.readFile('version.txt', _));
			hosts[0].version = ver.relNumber+"_"+ver.patchNumber
		} catch (e) { console.log("ERROR VER "+e)
			hosts[0].version = "_";
		}
		console.log("Start nanny with code version "+ hosts[0].version)
		hostsCollection.update({hostname: config.servername}, {$set:{ started: true}}, {w: 1}, _);
		var sessionCollection = db.createCollection('SessionInfo', _);
		proxy(sessionCollection);
		// send signal (without waiting) to all active servers that this server is started.
		// also send version number so that versions can be compared
		firstStartSignal();
		break;
	case "stop":
		hostsCollection.update({hostname: config.servername}, {$set:{ started: false}}, {w: 1}, _);
		db.close();
		console.log("Send stop signal")
		var result = get(hosts[0], "stop", _, true);
		console.log("Result"+result);
		return 0;
	case "remove":
		try {
			hostsCollection.remove( { hostname: config.servername}, {w:1}, _);			
		} finally {
			db.close();			
		}		
		console.log("Host removed");		
		break;
	default:
		throw new Error("Wrong commmand line argument "+process.argv[2]+". Type node nanny help to get a list of all commands")
			
	} 
	return 1;
}
exports.start = start;

// send start signal to all nannies on active servers. This signal tells the other servers that this server is started and tells about
// code version of this server. The response tells this server about the code version of the other servers. When the versions differ,  
function startSignal(host, _) {
	if (!host.active || !host.started || host.local) return;
	host.started = false;
	console.log("Host with start signal "+util.format(host))
	data = get(host, "started/"+hosts[0].hostname+"/"+hosts[0].version, _, true);
	// check versions
	var infos = data.split(';');
	host.version = infos[1];
	if (!hosts.mainVersion) {
		hosts.mainVersion = infos[0];
		checkVersions();
	}
}	


function firstStartSignal(_) {
	var futures = [];
	hosts.forEach(function(host) {
		if (!host.local && host.active && host.started) {
			futures.push(startSignal(host));
		}
	})
	var i = futures.length;
	while (--i >= 0) {
		try {
			futures[i](_);
		} catch(e) {
			console.log("Error connecting host "+e);
		}
	}
	// maybe no host could be contacted
	checkVersions();
}


function checkVersions() {
	console.log("CHECK VERSIONS"+hosts.mainVersion+" "+hosts[0].version)
	if (childrenStarted) return;		
	var commonVersion = hosts[0].version;
	hosts.forEach(function(host) {
		if (host.active && host.started && !host.local) {
			if (commonVersion && commonVersion !== host.version) commonVersion = null;
		}
	})
	if (commonVersion) {
		hosts.mainVersion = commonVersion;
		// start child processes
		hosts[0].ports.forEach(function(port) {
			createProcess(undefined, port);
		})
		childrenStarted = true;
		
	}
}


/// createProcess(exitCode, port)
/// creates child process listening at the given port and puts its object into the `children` instance.
/// when the process finishes, the process will be restarted unless `children.terminate` is set.
function createProcess(code, port, out, err) {
	if (code == undefined)
		console.log("Start process on port "+port)
		else
			console.log("Exit code "+code+" restarting process on port "+port)

			if (!children.terminate) { // restart processes (unless terminating all processes is intended)
				// console.log("(re)start process")
				// if (!out) out = fs.openSync('./out'+port+'.log', 'a');
				// if (!err) err = fs.openSync('./out'+port+'.log', 'a');
				// var child = child_process.spawn(process.argv[0], ['.', port], {stdio: ['ignore', out, err]});
				var child = child_process.spawn(process.argv[0], ['.', port], {stdio: ['pipe', 'pipe', 'ignore']});
				children[port] = child;
				// attach mock client to child process
				child.mockClient = new mock.Mock(child.stdin, child.stdout, requestListener);
				// exit handler for restarting process
				child.on('exit', function(code) { return createProcess(code, port, out, err) });
			}
}




function proxy(sessionCollection) {
	http.createServer(function(request, response) { return requestListener(request, response, sessionCollection, function(error, data) {
		if (error)
			console.log("Error "+util.format(error)+(error.stack? " stack "+error.stack : ""));
	});		
	}).listen(hosts[0].nannyPort);
	console.log("Server running at "+hosts[0].nannyPort)	
}


function requestListener(request, response, sessionCollection, _) {
	console.log(">> "+request.url)
	request.pause();
	// special commands which will not be redirected
	if (request.url.substring(0, 14) === "/nannyCommand/") {
		request.resume();
		var command = request.url.substr(14).split('/');
		console.log(util.format(command));
		switch (command[0]) {
		case 'stop': // request to stop server
			var futures = [];
			hosts.forEach(function(host) {
				if (host && host.started && host.active && !host.local) {
					futures.push(get(host, "down/"+hosts[0].hostname, null, true));
				}
			})
			killChildren();
			response.end("OK1");
			console.log("Finish")
			for (var i = 0; i<futures.length; i++) {
				try {
					futures[i](_);					
				} catch (e) {
					console.log("Exception when informing host "+hosts[i].hostname+": "+e);
				}
			}
			process.nextTick(function() { console.log("KILL process"); process.kill(process.pid); });
			break;
		case 'test': // test request 
			response.end("OK2");
			break;
		case 'info': // info request
			response.end(util.format(hosts)+ " "+childrenStarted);
			break;
		case 'notifyAll': // notify all
			response.end("OK3");
			break;
		case 'started': // nanny has started
			var host = command[1];
			// remove port
			for (var i = 1; i<hosts.length; i++) {
				console.log("CMP "+host+" "+hosts[i].hostname)
				if (hosts[i].hostname === host) {
					hosts[i].started = true;
					hosts[i].version = command[2];
					console.log("Host started"+i+" "+host);
				}
			}
			checkVersions();
			response.end(hosts.mainVersion+";"+hosts[0].version); // send back local code version and main version
			break;
		case 'down': // nanny has stopped
			var host = command[1];
			// update host data
			for (var i = 1; i<hosts.length; i++) {
				if (hosts[i].hostname === host) {
					hosts[i].started = false;
					console.log("Host down"+i+" "+host);
				}
			}
			checkVersions();
			response.end("OK - down")
			break;
		default:
			response.end("OK");
		}
		return;
	}   
	var recorderStream = new recorder.RecorderStream(request);
	
	if (BALANCER_HEADER in request.headers) {
		var localPort = request.headers[BALANCER_HEADER];
		if (!(localPort in children)) {
			writeError(response, "Port "+localPort+" does not exist on "+hosts[0].hostname)
			return;
		}
		try {
			doRequest(recorderStream, response, [hosts[0], localPort], _);
			return;
		} catch (e) {
			console.log("Error in local call "+e);
			writeError(response, "Give up local load balancing")
		}						
		return;
	}
	var sid; // Syracuse session
	if (request.headers.cookie) {
		var r = /syracuse\.sid=([\w\-]+)/.exec(request.headers.cookie);
		if (r) {
			sid = r[1];
			console.log("Session: "+sid)
		}		
	}
	var data; // data from load balancing
	if (sid) { // session available
		if (sid in sessions) {
			var host = sessions[sid][0]
			if (!host.started || !host.active) {				
				deleteSession(sid, sessionCollection, _);
			} else {
				try {
					doRequest(recorderStream, response, sessions[sid], _, sid);
					return;
				} catch (e) {
					deleteSession(sid, sessionCollection, _);
					console.log("Host not available1 "+host.hostname)
				}				
			}
		}
		// refresh local session table and balance
		data = refreshSessions(sessionCollection, _);
		if (!data) return differentVersionError(response);
		console.log("Nach refresh 21" + util.format(data))
		// maybe session is now known
		if (sid in sessions) {
			var host = sessions[sid][0]
			if (!host.started || !host.active) {				
				deleteSession(sid, sessionCollection, _);
			} else {
				try {
					doRequest(recorderStream, response, sessions[sid], _, sid);
					return;
				} catch (e) {
					deleteSession(sid, sessionCollection, _);
					console.log("Host not available1 "+host.hostname)
				}				
			}
		}
	}
	// session not available any more
	for (var i = 0; i<2; i++) {
		if (!data) {
			data = refreshSessions(sessionCollection, _); // balance
			if (!data) return differentVersionError(response);
		}
		try {
			doRequest(recorderStream, response, data, _);
			return;
		} catch (e) {
			console.log(">>> "+e+" "+e.stack)
			console.log("Host not available3 "+data[0].hostname)
			data = null;
		}				
	}
	writeError(response, "Give up balancing")
	return;				
}


function deleteSession(session, sessionCollection, _) {
	delete sessions[session];
	sessionCollection.remove( { sid: session}, {w:1}, _);
	console.log("Session removed");
}

function writeError(response, reason) {
	console.log("---- write Error ---- ")
	response.writeHead(500, "Internal error", { "Content-Type": "text/plain" });
	response.end(reason);

}

function differentVersionError(response) {
	writeError(response, "Different code versions on servers "+hosts.map(function(host) { return host.hostname+"/"+host.version; }).join(", "))
}

//get sessions from database, count sessions per node.js process and do load balancing 
function refreshSessions(sessionCollection, _) {
	console.log("------------------ refresh --------------------------------------")
	// console.log("Refresh")
	var data = sessionCollection.find().toArray(_);
	sessions = {};
	var counts = {}; // number of sessions per node server
	data.forEach(function(sess) {
		console.log("Session "+util.format(sess))
		var r = /^(.*)\:(N?\d+)$/.exec(sess.serverName);
		if (r) {
			if (sess.serverName in counts) {
				counts[sess.serverName]++;
			} else {
				counts[sess.serverName] = 1;
			}
			hosts.forEach(function(host) {
				if (host.hostname === r[1]) {
					if (host.ports.indexOf(r[2]) >= 0) {
						sessions[sess.sid] = [host, r[2]];
					} else {
						console.log("Wrong port "+r[2]+" for "+host.hostname)
					}
					return;
				}
			})
			
		}
	});
	console.log("Balance")
	return balance(counts, hosts);	
}


//finds 
function balance(counts, hosts) {
	var result;
	var minCount = Number.MAX_VALUE;
	hosts.forEach(function(host) {
		if (!host.started || !host.active || host.version !== hosts.mainVersion) return;
		// console.log("Host "+util.format(host))
		var hostColon = host.hostname+":";
		host.ports.forEach(function(port) {
			var count = counts[hostColon+port] || 0;
			// console.log("CNT "+hostColon+port+" value "+counts[hostColon+port])
			if (count < minCount) { // condition is true when counts[...] really exists and is less than
				result = [host, port];
				minCount = count; 
			}
		})
	})
	console.log("Balance result "+util.format(result))
	return result;
}
exports.balance = balance;


 
function doRequest(recorderStream, response, hostPort, callback, sessionId) {
	var client;
	var options;
	var port = hostPort[1];
	if (port.substr(0, 1) === "N" && hostPort[0] === hosts[0]) {
		console.log("local request to "+hostPort[1])
		delete recorderStream.originalStream.headers.syracuseBalancerHeader;
		options = mock.extractDataFromRequest(recorderStream.originalStream);
		client = children[hostPort[1]].mockClient
	} else {
		if (port.substr(0, 1) === "N") {
			recorderStream.originalStream.headers.syracuseBalancerHeader = hostPort[1];
			port = hostPort[0].nannyPort;
			console.log("Set port to nanny port "+port)
		}
		client = http;		
		options = { connection: {}, hostname: hostPort[0].hostname , port: port, method: recorderStream.originalStream.method, path: recorderStream.originalStream.url, headers: recorderStream.originalStream.headers };
		if (recorderStream.originalStream.connection && "authorized" in recorderStream.originalStream.connection) {
			options.connection.authorized = recorderStream.originalStream.connection.authorized;
		}
	} 
	// console.log(options)
	var req = client.request(options, function(res) {
		res.pause();
		res.on('end', function() {
			callback(null);
		});
		var cookies = res.headers['set-cookie'];
		if (cookies) {
			var index = cookies.indexOf('syracuse.sid=');
			if (index >= 0) {
				var newSession = cookies.substr(index+13, 36);
				if (newSession !== sessionId) {
					if (sessionId) delete sessions[sessionId];
					sessions[newSession] = hostPort;
				}
			}			
		}
		// console.log("ZZZZZZZZZZZZZZZZZ "+res.statusCode+" "+util.format(res.headers))
		response.writeHead(res.statusCode, res.headers);
		res.resume();
		res.pipe(response);
	});
	req.on("error", function(err) {
		// mark server as down unavailable
		console.log("Error "+util.format(hostPort[0]))
		console.log("Mark as down - send start signal")
		startSignal(hostPort[0])
		// connection error - try to find other server
		console.log("CONNECTION ERROR"+err)
		return callback(err);
	});
	recorderStream.reset();
	recorderStream.resume();
	recorderStream.pipe(req);
}



