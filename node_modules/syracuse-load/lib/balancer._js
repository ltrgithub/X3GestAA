"use strict";
var http = require('http');
var dbDriver = require('./dbDriver')
var util = require('util');
var os = require('os');
var fs = require('fs')
var child_process = require('child_process')
var mock = require('./mock')
var recorder = require('./recorder')
var fut = require('streamline/lib/util/future')

// var tracer = null;
var tracer = console.log

// requests which are not in a session, are counted here. They will be regarded for load balancing in addition to the
// sessions according to the session table
var currentNewRequests = {};

// http server for nanny
var httpServer;

var config;	
var db = null; // Database handle
//file for version information at customer's site (redundant name - also in syracuse-patch/lib/patchtools._js)
var VERSION_FILE = "version.json";
// maximal allowed time difference between servers in milliseconds
var TIME_THRESHOLD = 600000
// maximal number of requests between database time checks (will be multiplied with number of hosts)
var REQUEST_THRESHOLD = 1000
// time in milliseconds for a child process to wait after it has started
var PING_TIMEOUT = 100000
// polling interval for looking into database during stopping sessions
var POLL_INTERVAL = 3000;
// time which will remain to stop sessions
var POLL_TIME = 60000;

// status values: >= 0: notify for database updates, >= STATUS_INIT: child processes are possible; === STATUS_READY: notify for normal requests; <0: host cannot be used because of errors
// this list must fit to the status property of the host entity
var STATUS_INACTIVE = 0; // nanny inactive
var STATUS_INIT = 1; // initial status
var STATUS_START = 2; // starting child processes
var STATUS_READY = 3; // ready OK
var STATUS_FINISHING = 4; // server will stop soon
var STATUS_WRONG_VERSION = -1; // host has wrong version
var STATUS_TIME_DIFFERENCE = -2; // host deactivated because of time difference
var STATUS_RESPAWN = -3; // respawn limit of child processes exceeded
var STATUS_FOREIGN = -4; // initial status for foreign server
var STATUS_NOT_REACHABLE = -5; // timeout when reaching server 
var STATUS_NOT_STARTED = -6; // server has not been started


var lastDatabaseCheck = { time: 0, requests: 0}; // time and number of requests since last database time comparison


//list of sessions known to this balancer
var sessions = {}; // keys are Syracuse session ID's, values are corresponding server names and ports (as an array)
var hosts = []; // list of different Syracuse hosts, with following information: hostname, nannyPort, children number,
// active: generally available, started: currently started 
// version: Syracuse version (system is only usable when all versions are equal)
// status: see STATUS_... constants above
var hostsByName = {};
var localHost = null; // local host within hosts array
hosts.mainVersion = ""; // main version of the cluster (will be set upon first response of another server or when no server responds)
var children = []; // child processes ("N"+ind will be logical port of child with index 'ind')


// taken from patchtools._js
// relNumberCmp: comparison of release numbers
// split release numbers in parts with dots as delimiters and numerically compare the parts
// result is negative, 0, positive if first release number is smaller, equal, bigger than second
function relNumberCmp(rel1, rel2) {
	var parts1 = rel1.split(/[\._]+/); 
	var parts2 = rel2.split(/[\._]+/);
	var bound = Math.min(parts1.length, parts2.length);
	for (var i = 0; i<bound; i++) {
		var diff = parts1[i] - parts2[i]; 
		if (diff != 0)
			return diff;		
	}
	return parts1.length-parts2.length;
}


function startServer(_) {
	console.log("START SERVER "+localHost.nannyPort+" "+(httpServer ? httpServer.syracusePortNumber: "-"))
	if (httpServer) {
		if (localHost.nannyPort*1 === httpServer.syracusePortNumber*1) return;
		httpServer.maxConnections = 0
		httpServer.close(_); // stop old server when port changes
		console.log("Stop server at "+httpServer.syracusePortNumber)
	}
	var sessionCollection = dbDriver.createCollection(db, 'SessionInfo', _);
	httpServer = http.createServer(function(request, response) { return requestListener(request, response, sessionCollection, function(error, data) {
		if (error)
			console.log("Error "+util.format(error)+(error.stack? " stack "+error.stack : ""));
		});		
	});
	httpServer.listen(localHost.nannyPort);
	httpServer.syracusePortNumber =  localHost.nannyPort;
	console.log("Server running at "+localHost.nannyPort)	
}


//function copied from syracuse-core/lib/uuid.js
function generateUUID(sep) {
	var randomHex = function(len, mask, offset) {
		var n = Math.floor(Math.random() * (1 << 24));
		if (mask)
			n = (n & mask) + offset;
		var s = n.toString(16);
		return s.length >= len ? s.substring(0, len) : ("00000000".substring(0, len - s.length) + s);
	};
	// Version 4 UUIDs have the form
	// xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx with hexadecimal digits x
	// and hexadecimal digits 8, 9, A, or B for y
	if (sep == null)
		sep = '-';
	return randomHex(4) + randomHex(4) + sep + randomHex(4) + sep +
	randomHex(4, 0x0fff, 0x4000) +
	sep +
	randomHex(4, 0x3fff, 0x8000) +
	sep +
	randomHex(6) +
	randomHex(6);
};


function killChildren() {	
	if (children.length > 0) {
		console.log("Kill child processes");
		children.forEach(function(child) {
			child.terminate = true;
			if (child) child.kill();
		})
		children.length = 0;
	}
	// console.log("Child processes terminated");	
}


process.on('exit', function() {
	// console.log("Terminate nanny");
	dbDriver.close(db);
	killChildren();
})

// send a http request to a host. 
// host: in hosts array
// command: command to send
// return: data of response.
function get(hostdata, method, path, data, _) {
	var address;
	if (hostdata.local) address = "localhost";
	else {
		address = hostdata.hostname;
		if (hostdata.domain) address += "."+hostdata.domain;
	}
	var options = {method: method || 'GET', hostname: address , port: hostdata.nannyPort, path: path};
	try {
		var foundHost = hostsByName[hostdata.hostname]; // set pending request (always get foundHost from hostsByName - there may have been an update request which
		                                                // has updated the hosts array
		if (foundHost) foundHost.pendingRequest = true;
		console.log("GET START "+foundHost.pendingRequest)
		var result = mock.simpleRequest(http, options, data, _);
		var foundHost = hostsByName[hostdata.hostname];
		if (foundHost) foundHost.pendingRequest = false;
		console.log("GET SUCCESSFUL")
		return result;
	} catch (e) {
		var foundHost = hostsByName[hostdata.hostname];
		if (foundHost && foundHost.pendingRequest) { // maybe the other host has sent a start signal inbetween (and therefore set 'pendingRequest' to false).
			                        // in this case the timeout should not make the server unreachable.
			foundHost.pendingRequest = false;
			foundHost.status = STATUS_NOT_REACHABLE;
			console.log("not reachable "+hostdata.hostname)						
		}
		console.log("GET ERROR "+hostdata.hostname+" "+e)
		throw e;		
	}
}

/// main function
function start(conf, _) {
	switch (process.argv[2]) {
	case "?":
	case "help":
	case "--help":
		console.log("Valid commands: ")
		console.log("node nanny install <Port> <Number> [license file]\n  Install process with port <Port> for nanny process, <Number> child processes.\n  The optional license file argument allows to include a license file into database")
		console.log("node nanny\n  (or: node nanny run) start nanny process")
		console.log("node nanny start\n  start nanny process in background as a detached process")
		console.log("node nanny stop\n  ask running nanny process to stop")
		console.log("node nanny remove\n  Remove data for host process")
		console.log("node nanny help\n  This help text")
		return 0;
	case "start":
		console.log("Start detached node process. Output goes to ./out.log");
		var out = fs.openSync('./out.log', 'a'); 
		var err = fs.openSync('./out.log', 'a');
		var child = child_process.spawn(process.argv[0], ["nanny", "run" ], { detached: true, stdio: [ 'ignore', out, err] });
		child.unref();
		return 0;
	}
	config = conf;
	config.servername =  os.hostname();
	config.collaboration = config.collaboration || {};
	if (config.collaboration.domain) {
		config.servername += ("."+config.collaboration.domain);
	}
	console.log("Server name "+config.servername)
	// Establish connection to db
	db = dbDriver.open(config.collaboration, _);
	var hostsCollection = dbDriver.createCollection(db, 'Host', _)
	if (process.argv[2] === "install") {
		try {
			if (!/^\d+$/.test(process.argv[3]))
				throw "Invalid nanny port number "+process.argv[3];
			if (!/^\d\d?$/.test(process.argv[4]))
				throw "Invalid child process count "+process.argv[4];
			var nannyPort = 1*process.argv[3];
			var ports = 1*process.argv[4];
			var localHosts = dbDriver.find(hostsCollection, {hostname: config.servername}, _)
			if (localHosts.length > 0) {
				throw "Nanny already installed";
			} else {
				// new host
				var newHost = {_id: generateUUID(), hostname: config.servername, nannyPort: nannyPort, children: ports, _creUser: "setup", _updUser: "setup", _updDate: new Date(), active: true, started: false, respawnCount: 10, respawnTime: 120, returnRequestTimeout: 30}
				dbDriver.insert(hostsCollection, newHost, _);
				console.log("Host inserted "+config.servername)
			}
			if (process.argv[5]) { // optional license file
				var content = fs.readFile(process.argv[5], "utf8", _)
				// the following code comes from syracuse-license/lib/check._js
				// remove beginning and end
				content = content.replace(/^[^\{\}]*\{/, "").replace(/\}[^\{\}]*$/, "");
				// split into parts and add curly braces (AND add text attribute)
				var parts = content.split(/\}[^\{\},]*[\n\r][^\{\},]*\{/).map(function(part){ return { text: "{"+part+"}"}; });
				var licenseCollection = dbDriver.createCollection(db, "license", _);
				dbDriver.insert(licenseCollection, parts, _);
			}
			return 0;
		} finally {
			dbDriver.close(db);
		}		
		return 0;
	}
	// updateHostData is not interesting for install
	updateHostData(false, _);
	switch (process.argv[2]) {
	case "run":
	case undefined:
		// read version file
		if (!localHost) {
			dbDriver.close(db);
			throw new Error("Service has not been installed")
		}
		try {
			var ver = JSON.parse(fs.readFile(VERSION_FILE, _));
			localHost.version = ver.relNumber+"_"+ver.patchNumber
		} catch (e) { console.log("Error in version file "+e)
			localHost.version = "_";
		}
		// find out whether there is newer server
		hosts.forEach(function(host) {
			var parts = (host.patchStatus || "0").split(";"); 
			if (relNumberCmp(parts[0], localHost.version) > 0) {
				// current version is not newest version 
				localHost.status = STATUS_WRONG_VERSION;
			}
		})
		console.log("Start nanny with code version "+ localHost.version)
		dbDriver.update(hostsCollection, {hostname: config.servername}, { started: true, pid: process.pid}, _);
		startServer(_);
		// send signal (without waiting) to all active servers that this server is started.
		// also send version number so that versions can be compared
		firstStartSignal();
		break;
	case "stop":
		dbDriver.update(hostsCollection, {hostname: config.servername}, { started: false}, _);
		dbDriver.close(db);
		try {
			var result = get(localHost, "PUT", "/nannyCommand/stop", null, _);
		} catch (e) { console.log("Could not stop nanny (PID "+localHost.pid+"), error "+e)
			// TODO: when unauthorized connection via HTTPS with missing client certificates, do not give up but send SIGINT, wait 2 seconds,
			//  try again connection, when the same error occurs, send SIGTERM
		}
 		return 0;
	case "remove":
		try {
			dbDriver.remove(hostsCollection, { hostname: config.servername}, _);			
		} finally {
			dbDriver.close(db);			
		}		
		console.log("Host removed");		
		break;
	default:
		throw new Error("Wrong commmand line argument "+process.argv[2]+". Type node nanny help to get a list of all commands")

	} 
	return 1;
}
exports.start = start;

// send start signal to all nannies on active servers. This signal tells the other servers that this server has been started and tells about
// code version of this server. The response tells this server about the code version of the other servers. When the versions differ,  
function startSignal(host, _, first) {
	if (host.local || host.status <= STATUS_NOT_REACHABLE || (!first && host.status <= STATUS_FOREIGN)) return;
	tracer && tracer("Host with start signal "+util.format(host))
	console.log("START SIGNAL "+util.format(host))
	var data = get(host, "POST", "/nannyCommand/started", JSON.stringify(localHost), _);
	// check versions
	var infos = data.split(';');
	console.log("INFOS "+data)
	host.version = infos[1];
	host.status = infos[2]*1;
	if (!hosts.mainVersion) {
		hosts.mainVersion = infos[0];
		checkVersions();
	}
}	

// send a start signal to all started nannies. This will also detect unreachable nannies.
function firstStartSignal(_) {
	var futures = [];
	hosts.forEach(function(host) {
		if (!host.local && host.started) {
			var signal = startSignal(host, undefined, true);
			if (host.active) futures.push(signal); // do not wait for answers of inactive servers!
		}
	})
	var i = futures.length;
	while (--i >= 0) {
		try {
			futures[i](_);
		} catch(e) {
			console.log("Error connecting host "+e+" "+e.stack);
		}
	}
	// maybe no host could be contacted
	checkVersions();
}


function checkVersions() {
	console.log("CHECK "+localHost.status+" "+hosts.mainVersion)
	if (localHost.status !== STATUS_INIT) return;
	var commonVersion;
	if (hosts.mainVersion) {
		if (hosts.mainVersion === localHost.version) commonVersion = hosts.mainVersion;
	} else { // no main version yet: test for common version
		commonVersion = localHost.version;
		hosts.forEach(function(host) {
			// only active hosts
			if (host.status > 0 && !host.local) {
				if (commonVersion && commonVersion !== host.version) commonVersion = null;
			}
		})
		if (commonVersion) hosts.mainVersion = commonVersion;
	}
	if (commonVersion) {
		startChildProcesses(true);
	} else {
		localHost.status = STATUS_WRONG_VERSION;
	}
}


function startChildProcesses(force) {
	if (localHost.status > STATUS_INIT || force) {
		// new number of children
		var newChildCount = (localHost.status >= STATUS_INIT) ? localHost.children : 0;
		// current number of children
		var oldChildCount = children.length;	
		tracer && tracer("Start child processes "+oldChildCount+" "+newChildCount)
		for (var i = newChildCount-1; i>= oldChildCount; i--) {
			createProcess(undefined, i);
		}
		while (children.length > newChildCount) {
			tracer && tracer("Kill child process"+children.length)
			var child = children.pop();
			child.terminate = true;
			child.kill();
		}
		if (newChildCount > 0 && localHost.status < STATUS_START) localHost.status = STATUS_START;
		if (localHost.status === STATUS_START) {
			// send ping signal to all child processes, then mark process ready
			var futures = [];
			children.forEach(function(child) {
				futures.push(child.mockClient.ping(undefined, PING_TIMEOUT));
			});
			// wait for results of child processes (collect results of futures). 
			// This function is called as a future!
			startedChildProcesses(futures);
		}
	}
}


function startedChildProcesses(futures, _) {
	var i = futures.length;
	var ok = true;
	while (--i >= 0) {
		try {
			futures[i](_);
		} catch (e) {
			ok = false;
			console.error("Error starting child process: "+e)
		}
	}
	if (ok) {
		localHost.status = STATUS_READY;
		console.log("Notify other servers about successful start of child processes")
		// send start signal again (as a future, because it is not necessary to wait for the result
		hosts.forEach(function(host) { return startSignal(host)});
	}
}

/// createProcess(exitCode, port)
/// creates child process listening at the given port and puts its object into the `children` instance.
/// when the process finishes, the process will be restarted unless `children.terminate` is set.
function createProcess(code, port) {
	var startTime = Date.now();
	var startCount = 0;
	var child = children[port];
	if (code == undefined)
		console.log("Start process on port N"+port)
		else {
			console.log("Exit code "+code+" restarting process on port N"+port)
			var respawnTime = 1000*localHost.respawnTime
			if (child && respawnTime && startTime-child.startTime < respawnTime) {
				startTime = child.startTime;
				startCount = (child.startCount || 0)+1;
				if (child.startCount > localHost.respawnCount) {
					// child processes unavailable
					console.log("RESPAWN COUNT")
					localHost.status = STATUS_RESPAWN;
					// tell other servers
					hosts.forEach(function(host) { return startSignal(host)});
					killChildren();
				}
			} 						
		}

	if (!child || !child.terminate) { // restart processes (unless terminating all processes is intended)
		// console.log("(re)start process")
		// if (!out) out = fs.openSync('./out'+port+'.log', 'a');
		// if (!err) err = fs.openSync('./out'+port+'.log', 'a');
		// var child = child_process.spawn(process.argv[0], ['.', port], {stdio: ['ignore', out, err]});
		var child = child_process.spawn(process.argv[0], ['.', "N"+port, localHost.returnRequestTimeout], {stdio: ['pipe', 'pipe', process.stderr]});
		child.startTime = startTime
		child.startCount = startCount;
		children[port] = child;
		// attach mock client to child process
		child.mockClient = new mock.Mock(child.stdin, child.stdout, requestListener);
		// exit handler for restarting process
		child.on('exit', function(code) { 
			if (child.terminate) { 
				console.log("Stop child")
			} else return createProcess(code, port) 
		});
	}
}

// returns an array of all status information
function statusString() {
	return hosts.map(function(host) { return host.status; }).join(',');
}

// read configuration data of hosts from database and update local configuration.
function updateHostData(startChildren, _) {
	var hostsCollection = dbDriver.createCollection(db, 'Host', _);
	var newHosts = dbDriver.find(hostsCollection, null, _);
	hosts = _updateHosts(hosts, newHosts, config.servername);
	if (!localHost) { // data for local host not available
		console.error("No data for local nanny")
		process.exit(2);		
	}
	if (startChildren) startServer(); // maybe restart server because of port change - start asynchronously because current request will block stopping of server
	startChildProcesses(startChildren);
}

function _updateHosts(oldHosts, hosts, name) {
	// sort host data by hostname
	hosts = hosts.sort(function(host1, host2) { 
		var h1 = host1.hostname; 
		var h2 = host2.hostname;
		return (h1 > h2 ? 1 : (h1 < h2 ? -1 : 0))
	});
	var i = hosts.length;
	localHost = null;
	hostsByName = {};
	LOOP: while (--i >= 0) {
		var host = hosts[i]
		hostsByName[host.hostname] = host;
		if (host.hostname === name) {
			host.local = true;
			localHost = host;
		}
		var j = oldHosts.length;
		while (--j >= 0) {
			var oldHost = oldHosts[j];
			if (!oldHost) continue;
			if (oldHost.hostname === host.hostname) {
				host.version = oldHost.version;
				host.status = oldHost.status;
				host.pendingRequest = oldHost.pendingRequest;
			}
		}
		// explicitly set certain status values
        if (!host.active && host.status > STATUS_INACTIVE) host.status = STATUS_INACTIVE;
		if (!host.local && !host.started) host.status = STATUS_NOT_STARTED;
		if (host.status === undefined || host.started && host.status === STATUS_NOT_STARTED || host.active && host.status === STATUS_INACTIVE) {
			// initialize status: a foreign host is not reachable unless it is known to be reachable
			host.status = (host.local ? (host.active ? STATUS_INIT : STATUS_INACTIVE) : STATUS_FOREIGN);			
		}
	}
	hosts.mainVersion = oldHosts.mainVersion || "";
	return hosts;
}


function requestListener(request, response, sessionCollection, _) {
	tracer && tracer(">> "+request.url)
	request.pause();
	var streamRecorder; 
	// testSessions(sessionCollection, _);
	// special commands which will not be redirected
	if (request.url.substring(0, 14) === "/nannyCommand/") {		
		var command = request.url.substr(14).split('/');		
		var resultText = localHost.hostname+":\n";
		var futures = []; // invocations of other processes
		var commandType = command[0];
		var syraBalancerHeader = request.headers[mock.BALANCER_HEADER];

		switch(command[0]) {
		case 'notifyAll': // notify all
			request.pause();
			var clientId = syraBalancerHeader;
			streamRecorder = new recorder.StreamRecorder(request);
			// Notify other servers (without waiting)
			if (clientId) {
				delete request.headers[mock.BALANCER_HEADER];				
				hosts.forEach(function(host) {
					if (!host.local && host.status === STATUS_READY) {
						tracer && tracer("Request to server "+i);
						futures.push(doRequestWithAnswer(streamRecorder, [host, host.nannyPort]));
					}
				});
			}
			request.url = request.url.replace(/^\/[^\/]+\/[^\/]+/, "")
			tracer && tracer("Local path "+request.url)
			for (var i=0; i<children.length; i++) {
				var port = "N"+i;
				if (port !== clientId) {
					tracer && tracer("Request to local app "+port)
					var future = doRequestWithAnswer(streamRecorder, [localHost, port])				
					future.extra = {port: port};
					futures.push(future);
				}
			}
			break;
		case "notifyOtherNannies": // send the command (without '/notifyOtherNannies' in URL) to other nannies which have status OK and finish the request
			request.pause();
			// console.log("CLIENT ID "+clientId)
			streamRecorder = new recorder.StreamRecorder(request);
			request.url = request.url.replace(/^(\/[^\/]+)\/[^\/]+/, "$1") // remove second part
			tracer && tracer("Notify all running "+clientId+" "+request.url)
			// Notify other servers (without waiting)
			delete request.headers[mock.BALANCER_HEADER];
			hosts.forEach(function(host) {
				if (!host.local && host.status >= STATUS_READY) {
					tracer && tracer("Request to server "+host.hostname)
					futures.push(doRequestWithAnswer(streamRecorder, [host, host.nannyPort]));
				}
			});	
			break;
		case "notifyNannies": // send the command (without '/notifyOtherNannies' in URL) to all nannies which have status at least inactive.
			command.shift();
			request.pause();
			// console.log("CLIENT ID "+clientId)
			streamRecorder = new recorder.StreamRecorder(request);
			request.url = request.url.replace(/^(\/[^\/]+)\/[^\/]+/, "$1") // remove second part
			tracer && tracer("Notify all started "+request.url)
			// Notify other servers (without waiting)
			delete request.headers[mock.BALANCER_HEADER];
			hosts.forEach(function(host) {
				if (!host.local && host.status >= STATUS_INACTIVE) {
					tracer && tracer("Request to server "+host.hostname)
					futures.push(doRequestWithAnswer(streamRecorder, [host, host.nannyPort]));
				}
			});	
			break;
		}

		switch (command[0]) {
		case 'stop': // request to stop server
			var futures = [];
			var i;
			for (i = 0; i<hosts.length; i++) {
				if (host && host.status >= STATUS_INACTIVE && !host.local) {
					futures[i] = get(host, "PUT", "/nannyCommand/down/"+localHost.hostname, null, undefined);
				}
			}
			killChildren();
			resultText = "OK1"
			// Exceptional case here: call futures here because otherwise process.nextTick function will not allow them to be executed
			for (var i = 0; i<futures.length; i++) {
				try {
					if (futures[i]) futures[i](_);					
				} catch (e) {
					console.log("Exception when informing host "+hosts[i].hostname+": "+e);
				}
			}
			futures = [];
			process.nextTick(function() { console.log("Exit process"); process.exit(0); });
			break;
		case 'notifyOne': // send request only to local server with lowest number of sessions (without '/nannyCommand/notifyOne')
			var sessionCollection = dbDriver.createCollection(db, 'SessionInfo', _);
			var data = refreshSessions(sessionCollection, true, _); // only local host
			if (!data) {
				data = [localHost, "N0"];
				tracer && tracer("No balancer result - set process N0");
			}
			if (!streamRecorder) {
				request.url = request.url.replace(/^\/[^\/]+\/[^\/]+/, "") // remove first two parts
				streamRecorder = new recorder.StreamRecorder(request);
			} else {
				streamRecorder.originalStream.url = streamRecorder.originalStream.url.replace(/^\/[^\/]+\/[^\/]+/, "") // remove first two parts 
			}
			try {
				console.log("VORHER12")
				var future = doRequestWithAnswer(streamRecorder, data)				
				future.extra = {port: data[1]};
				futures.push(future);
				console.log("NACH VORHER1");
			} catch (e) {
				tracer && tracer("Host not available "+data[0].hostname+ " Error "+e)
			}							
			break;
		case 'stopSessions':
			response.writeHead(200, {'Content-Type': 'text/plain'});
			var sessionCollection = dbDriver.createCollection(db, 'SessionInfo', _);
			stopSessions(sessionCollection, syraBalancerHeader, _);
			var hostsCollection = dbDriver.createCollection(db, 'Host', _);
			dbDriver.update(hostsCollection, {hostname: config.servername}, { started: false}, _);
			dbDriver.close(db);
			// httpServer.unref();
			console.log("END")
			process.nextTick(function() { console.log("Exit process"); process.exit(0); });			
			return;
		case 'update':
			updateHostData(true, _);
			resultText +="OK5"
			break;
		case 'test': // test request
			resultText += "OK2"
			break;
		case 'children': // ping to children
			if (localHost.status >= STATUS_START) {
				for (var i = children.length-1; i>=0; i--) {
					var future = children[i].mockClient.ping(undefined, 1000);
					future.extra = {hostname: localHost.hostname, port: "N"+i, requests: children[i].mockClient.numberRequests()};
					futures.push(future)
				}				
			} else {
				resultText += JSON.stringify({hostname: localHost.hostname, message: "Children not yet started"})+"\n";
			}
			if (commandType === "notifyNannies") { // extra information only from current host
				resultText += JSON.stringify(hosts)+"\n";
			}
			break;
		case 'details': // details information about children
			if (localHost.status === STATUS_READY) {
				for (var i = children.length-1; i>=0; i--) {
					var future = children[i].mockClient.detail(undefined, 1000);
					future.extra = {hostname: localHost.hostname, port: "N"+i};
					futures.push(future)
				}				
			} else {
				resultText += JSON.stringify({hostname: localHost.hostname, message: "Children not yet started"})+"\n";
			}
			if (commandType === "notifyNannies") { // extra information only from current host
				resultText += JSON.stringify(hosts)+"\n";
			}
			break;
		case 'info': // info request
			resultText += util.format(hosts);
			var childResults = [];
			for (var i=0; i<children.length; i++) {
				childResults.push("N"+i+": "+children[i].mockClient.numberRequests())
			}
			resultText += "\n"+childResults.join(", ");
			break;
		case 'infojson': // info request
			resultText = JSON.stringify(hosts);
			break;
		case 'started': // nanny has started
			try {
				var d = getData(streamRecorder ? streamRecorder.getStream() : request, _);
				console.log("DDDAAA "+d)
				var hostData = JSON.parse(d);
				var foundHost = null;
				for (var attempt = 0; attempt < 2; attempt++) {
					foundHost = hostsByName[hostData.hostname];
					if (foundHost && !foundHost.local) {
						foundHost.status = hostData.status;
						foundHost.started = true;
						foundHost.children = hostData.children;
						foundHost.version = hostData.version;
						foundHost.pendingRequest = false; // maybe there is a get() request pending which will result in a timeout. It should not mark the host as unavailable.
						tracer && tracer("Host started "+foundHost.hostname);
						break;
					}
					console.log("FOUND "+foundHost)
					if (!foundHost) updateHostData(false, _);					
				}
				if (!foundHost) {
					response.end("??;"+localHost.version+";"+localHost.status)
					return;
				}
				checkVersions();
				// maybe update status of other host
				console.log("HOST2 "+util.format(foundHost))
				if (foundHost && hosts.mainVersion !== foundHost.version) foundHost.status = STATUS_WRONG_VERSION;
				var returnValue = hosts.mainVersion+";"+localHost.version+";"+localHost.status
				tracer && tracer("return value on start request "+returnValue)
				response.end(returnValue); // send back local code version and main version				
			} catch (e) {
				writeError(response, "Error "+e);
			}			
			return;
		case 'down': // nanny has stopped
			var host = command[1];
			// update host data (nothing to do when host is not found)
			var foundHost = hostsByName[host];
			if (foundHost && !foundHost.local) {
				foundHost.started = false;
				foundHost.status = STATUS_NOT_STARTED;
				tracer && tracer("Host down "+foundHost.hostname);
			}
			checkVersions();
			resultText += "OK - down"
			break;
		default:
			resultText += "OK "+command[0];
		}
		
		for (var i=0; i<futures.length; i++) {
			var extra = futures[i].extra;
			try {
				var res = futures[i](_)
				if (extra instanceof Object) {
					extra.message = res;
					resultText+= JSON.stringify(extra)+"\n";						
				} else {
					resultText += (extra || "")+res+"\n";
				}
				tracer && tracer("result of future "+res+" ---- "+JSON.stringify(extra))
			} catch (e) {
				if (extra instanceof Object) {
					extra.message = ""+e;
					extra.failure = true;
					resultText+= JSON.stringify(extra)+"\n";						
				} else {
					resultText += (extra || "") +e+"\n";					
				}
				console.log("error of future "+e)
			}
		}
		response.writeHead(200, {'Content-Type': 'text/plain'});
		response.end(resultText);

		return;
	}

	console.log("==============================="+localHost.status)
	if (localHost.status < STATUS_READY) {
		var text;
		var temporary = false;
		switch (localHost.status) {
		case STATUS_START: temporary = true; text = "Application servers are being started. Try again later"; break;
		case STATUS_INIT: temporary = true; text = "Application servers not yet started. Try again later"; break;
		case STATUS_TIME_DIFFERENCE: text = "Host has been deactivated because of time difference"; break;
		case STATUS_WRONG_VERSION: text = "Version mismatch: main version "+hosts.mainVersion+", local version "+localHost.version; break;
		case STATUS_RESPAWN: text = "Respawn limit exceeded. Applications cannot be started"; break;
		case STATUS_INACTIVE: text = "Host is not active"; break;
		default: text= "Wrong status "+localHost.status;
		}
		writeError(response, text, temporary);
		return;
	}

	streamRecorder = new recorder.StreamRecorder(request);

	if (mock.BALANCER_HEADER in request.headers) {
		if (localHost.status < STATUS_READY) {
			writeError(response, "Host not yet ready", true)
			return;
		}
		var data = request.headers[mock.BALANCER_HEADER].split(",");		
		var localPort = data[0];
		for (var i = data.length-1; i > 0; i--) {
			if (!hosts[i-1].local) hosts[i-1].status = data[i];
		}
		tracer && tracer("balancer header "+localPort)
		var number = localPort.substr(1)*1;
		if (!(number in children)) {
			writeError(response, "Child number "+localPort+" does not exist on "+localHost.hostname)
			return;
		}
		try {
			doRequest(streamRecorder, response, [localHost, localPort], _);
			return;
		} catch (e) {
			tracer && tracer("Error in local call "+e);
			writeError(response, "Give up local load balancing")
		}						
		return;
	}
	var sid; // Syracuse session
	if (request.headers.cookie) {
		var r = /syracuse\.sid=([\w\-]+)/.exec(request.headers.cookie);
		if (r) {
			sid = r[1];
			tracer && tracer("Session: "+sid)
		}		
	}
	// check time with database time
	var now = Date.now();
	if (now < lastDatabaseCheck.time || now-lastDatabaseCheck.time > TIME_THRESHOLD || ++lastDatabaseCheck.requests > REQUEST_THRESHOLD*hosts.length) {		
		// avoid multiple database queries because of race conditions
		lastDatabaseCheck.time = now;
		lastDatabaseCheck.requests = 0;		
		// get time from database
		var dbTime = dbDriver.time(db, _);
		var diff = dbTime-now;
		tracer && tracer("database time check--"+dbTime+ " difference "+diff)
		if (diff > TIME_THRESHOLD || -diff > TIME_THRESHOLD) {
			localHost.status = STATUS_TIME_DIFFERENCE;
			writeError(response, "Time difference between "+localHost.hostname+" and database exceeds "+TIME_THRESHOLD/1000+" seconds. Host will be set inactive.")
			startChildProcesses(true);
			return;
		}
	}
	
	var data; // data from load balancing
	if (sid) { // session available
		if (sid in sessions) {
			var host = sessions[sid][0]
			if (host.status < STATUS_READY) {				
				tracer && tracer("Delete session1 "+sid+" "+util.format(host))
				deleteSession(sid, sessionCollection, _);
			} else {
				try {
					doRequest(streamRecorder, response, sessions[sid], _, sid);
					return;
				} catch (e) {
					tracer && tracer(""+e+"Delete session2 "+sid+" "+util.format(host))
					deleteSession(sid, sessionCollection, _);
					tracer && tracer("Host not available1 "+host.hostname)
				}				
			}
		}
		if (localHost.status === STATUS_FINISHING) {
			// no new sessions accepted during finish
			writeError(response, "No new sessions accepted when server is shutting down");
			return;
		}
		// refresh local session table and balance
		data = refreshSessions(sessionCollection, false, _);
		if (!data) return differentVersionError(response);
		// maybe session is now known
		if (sid in sessions) {
			var host = sessions[sid][0]
			if (host.status < STATUS_READY) {
				tracer && tracer("Delete session3 "+sid+" "+util.format(host))				
				deleteSession(sid, sessionCollection, _);
			} else {
				try {
					doRequest(streamRecorder, response, sessions[sid], _, sid);
					return;
				} catch (e) {tracer && tracer(""+e+"Delete session4 "+sid+" "+util.format(host))
					deleteSession(sid, sessionCollection, _);
				console.log("Host not available1 "+host.hostname)
				}				
			}
		}
	}
	// session not available any more
	if (localHost.status === STATUS_FINISHING) {
		// no new sessions accepted during finish
		writeError(response, "No new sessions accepted when server is shutting down");
		return;
	}
	for (var i = 0; i<2; i++) {
		if (!data) {
			data = refreshSessions(sessionCollection, false, _); // balance
			if (!data) return differentVersionError(response);
		}
		try {
			doRequest(streamRecorder, response, data, _);
			return;
		} catch (e) {
			tracer && tracer("Host not available "+data[0].hostname+ " Error "+e)
			data = null;
		}				
	}
	writeError(response, "Give up balancing")
	return;				
}


function stopSessions(sessionCollection, exclude, callback) {
	var remainingTime = POLL_TIME+POLL_INTERVAL;
	var count = 1;
	var answerSent = false;
	function pollfunction() {
		remainingTime -= POLL_INTERVAL;
		console.log("POLL function "+count+" "+remainingTime);
		if (count === 0 && !answerSent) {
			answerSent = true;
			return callback(null);			
		}
		if (remainingTime <= 0) {
			console.log("Remove sessions")
			answerSent = true;
			dbDriver.remove(sessionCollection, {}, callback);
			return;
		}
		if (!answerSent && (remainingTime <= 0 || count === 0)) {
			answerSent = true;
			return callback(null);
		}
		// start function again
		setTimeout(pollfunction, POLL_INTERVAL);
		// start database query
		console.log("Count start")
		dbDriver.count(sessionCollection, {}, function(error, cnt) {
			console.log("Session cnt "+error+" "+cnt);
			if (error && !answerSent) {
				answerSent = true;
				return callback(error);
			}
			count = cnt;
		});
	}
	pollfunction();
	if (localHost.status < STATUS_READY) {
		// just stop the child processes
		console.log("stopSessions: Stop all child processes")
		localHost.status = STATUS_NOT_STARTED;
		startChildProcesses(true);
	} else {
		// notification to all Syracuse processes that sessions will expire
		console.log("stopSessions: notify all child processes");
		var options = { path: "/notifyEnd", method: "GET"};
		var futures = [];
		for (var i = children.length-1; i>=0; i--) {
			console.log("Stop session "+i+" exclu "+exclude)
			if ("N"+i !== exclude) futures.push(mock.simpleRequest(children[i].mockClient, options, null));
			console.log("Nach stop session")		
		}							
	}
	localHost.status = STATUS_FINISHING;
}


function deleteSession(session, sessionCollection, _) {
	delete sessions[session];
	dbDriver.remove(sessionCollection, { sid: session}, _);
}

// writes an error response. When parameter 'temporary' is set, it will be a 503 response (service not available)
function writeError(response, reason, temporary) {
	tracer && tracer("write error "+reason)
	response.writeHead(temporary ? 503 : 500, temporary ? "Server temporarily not available" : "Internal error", { "Content-Type": "text/plain" });
	response.end(reason);
	console.log("WRITE ERROR "+reason)
}

function differentVersionError(response) {
	writeError(response, "Different code versions on servers "+hosts.map(function(host) { return host.hostname+"/"+host.version; }).join(", "))
}


function getData(stream, callback) {
	stream.setEncoding('utf8');
	stream.resume();
	var result = "";
	stream.on('data', function(chunk) {
		result += chunk;
	})
	stream.on('end', function() {
		return callback(null, result);
	})	
}

// function testSessions(sessionCollection, _) {
// 	var data = sessionCollection.find().toArray(_);	
// 	var s = data.map(function(sess){return sess.serverName})
//	console.log("SSSSSSSSSSs "+util.format(s));
// }


//get sessions from database, count sessions per node.js process and do load balancing
// parameter local: only consider sessions on local server
function refreshSessions(sessionCollection, local, _) {
	tracer && tracer("Refresh sessions")
	// console.log("Refresh")
	var data = dbDriver.find(sessionCollection, null, _);
	sessions = {};
	var counts = {}; // number of sessions per node server
	data.forEach(function(sess) {
		tracer && tracer("Session "+util.format(sess))
		var r = /^(.*)\:(N\d+)$/.exec(sess.serverName);
		if (r) {
			if (sess.serverName in counts) {
				counts[sess.serverName]++;
			} else {
				counts[sess.serverName] = 1;
			}
			hosts.forEach(function(host) {
				if (host.hostname === r[1]) {
					if (r[2].substr(1)*1 < host.children) {
						sessions[sess.sid] = [host, r[2]];
					} else {
						tracer && tracer("Wrong port "+r[2]+" for "+host.hostname)
					}
					return;
				}
			})

		}
	});
	// add current requests for new sessions
	Object.keys(currentNewRequests).forEach(function(key) {
		var value = currentNewRequests[key];
		if (value > 0) {
			tracer && tracer("Add current requests "+key+" value "+value)
			if (key in counts) {
				counts[key] += value;
			} else {
				counts[key] = value;
			}			
		} 
	});
	tracer && tracer("Balance");
	return balance(counts, local ? [localHost] : hosts, localHost.hostname);	
}


//finds host (and application server) with minimal number of sessions. The local host is preferred when there are several 
// applications with same minimal number of sessions.
function balance(counts, hosts, localhostname) {
	var result;
	var minCount = Number.MAX_VALUE;
	tracer && tracer("Hosts "+util.format(hosts))
	hosts.forEach(function(host) {
		if (host.status < STATUS_READY) return;
		tracer && tracer("Host "+util.format(host))
		var hostColon = host.hostname+":";
		for (var i=host.children-1; i>= 0; i--) {
			var port = "N"+i;
			var count = counts[hostColon+port] || 0;
			tracer && tracer("count "+hostColon+port+" value "+counts[hostColon+port])
			if (count < minCount || (count === minCount && host.hostname === localhostname)) { // condition is true when counts[...] really exists and is less than
				result = [host, port];
				minCount = count; 
			}
		}
	})
	tracer && tracer("Balance result "+util.format(result))
	return result;
}
exports.balance = balance;


function doRequestWithAnswer(streamRecorder, hostPort, _, sessionId) {
	tracer && tracer("Do req with answer to "+hostPort[0].hostname+":"+hostPort[1]+" "+streamRecorder.originalStream.url)
	var dummyResponse = new mock.MemoryStream();
	doRequest(streamRecorder, dummyResponse, hostPort, _);
	tracer && tracer("Answer from host "+dummyResponse.content);
	return dummyResponse.content;
}


function doRequest(streamRecorder, response, hostPort, callback, sessionId) {
	if (!callback) return fut.future(doRequest, arguments, 3);
	var client;
	var options;
	var sessionHostName 
	var port = ""+hostPort[1];
	var foundHost = hostsByName[hostPort[0].hostname];
	if (foundHost) {
		foundHost.pendingRequest = true;
		console.log("PENDING "+foundHost.hostname)
	}
	if (!sessionId) {
		sessionHostName = localHost.hostname+":"+port;
		if (sessionHostName in currentNewRequests) {
			currentNewRequests[sessionHostName]++;	
		} else currentNewRequests[sessionHostName] = 1;		
	}
	if (hostPort[0].hostname === localHost.hostname) {
		tracer && tracer("local request to "+hostPort[1])
		delete streamRecorder.originalStream.headers[mock.BALANCER_HEADER];
		options = mock.extractDataFromRequest(streamRecorder.originalStream);
		client = children[hostPort[1].substr(1)].mockClient
	} else {
		if (port.substr(0, 1) === "N") {
			streamRecorder.originalStream.headers[mock.BALANCER_HEADER] = hostPort[1]+","+statusString();
			port = hostPort[0].nannyPort;
			tracer && tracer("Set port to nanny port "+port)
		}
		client = http;		
		var address = hostPort[0].hostname;
		if (hostPort[0].domain) address += "."+hostPort[0].domain;
		options = { connection: {}, hostname: address , port: port, method: streamRecorder.originalStream.method, path: streamRecorder.originalStream.url, headers: streamRecorder.originalStream.headers };
		if (streamRecorder.originalStream.connection && "authorized" in streamRecorder.originalStream.connection) {
			options.connection.authorized = streamRecorder.originalStream.connection.authorized;
			if (options.connection.authorized) {
				options.connection._peerCertificate = streamRecorder.originalStream.connection.getPeerCertificate();
			}
		}

	} 
	var req = client.request(options, function(res) {
		if (sessionHostName) {
			currentNewRequests[sessionHostName]--;
			sessionHostName = null;
		}
		var foundHost = hostsByName[hostPort[0].hostname];
		if (foundHost) foundHost.pendingRequest = false;
		res.pause();
		res.on('end', function() {
			callback(null);
		});
		var date = res.headers['date'];
		if (date) {
			var diff = Date.now()-new Date(date).getTime();
			tracer && tracer("Time difference "+diff)
			if (diff > TIME_THRESHOLD || -diff > TIME_THRESHOLD) {
				hostPort[0].status = STATUS_TIME_DIFFERENCE;
				writeError(response, "Time between "+localHost.hostname+" and "+hostPort[0].hostname+" differs by more than "+(TIME_THRESHOLD/1000)+ " seconds");
				return;
			}
		}
		var cookies = res.headers['set-cookie'];
		if (cookies) {
			var index = cookies.indexOf('syracuse.sid=');
			if (index >= 0) {
				var newSession = cookies.substr(index+13, 36);
				if (newSession !== sessionId) {
					if (sessionId) delete sessions[sessionId];
					sessions[newSession] = hostPort;
				}
			}			
		}
		response.writeHead(res.statusCode, res.headers);
		res.resume();
		res.pipe(response);
	});
	req.on("error", function(err) {
		// mark server as down unavailable
		if (sessionHostName) {
			currentNewRequests[sessionHostName]--;
			sessionHostName = null;
		}
		tracer && tracer("Error "+util.format(hostPort[0]))
		tracer && tracer("Mark as down")
		var foundHost = hostsByName[hostPort[0].hostname];
		console.log("MARK "+util.format(foundHost))
		if (foundHost.pendingRequest) {
			foundHost.pendingRequest = false;
			foundHost.status = STATUS_NOT_REACHABLE;
		}
		// connection error - try to find other server
		tracer && tracer("Connection error "+err+" "+util.format(hostPort))
		return callback(err);
	});
	streamRecorder.newStream().pipe(req);
}

//for unit tests
exports._updateHosts = _updateHosts

