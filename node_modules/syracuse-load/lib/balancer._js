var http = require('http');
var mongodb = require('mongodb');
var util = require('util');
var os = require('os');
var fs = require('fs')
var child_process = require('child_process')

var balancerPort = 8111;
var balancerHost = '127.0.0.1'

	var directedPort = 8124;
var directedHost = '127.0.0.1';
var config;	

var db = null; // MongoDB handle

//list of sessions known to this balancer
var sessions = {}; // keys are Syracuse session ID's, values are corresponding server names and ports
var hosts = []; // list of different Syracuse hosts, with following information: hostname, nannyPort, portList, 
                // ports (array of all ports, generated from portList), active: currently available, 
                // version: Syracuse version (system is only usable when all versions are equal 
var children = {}; // ports and objects of child processes. children.terminate will prevent restarting child processes

function killChildren() {
	var ports = Object.keys(children); 
	if (ports.length > 0) {
		children.terminate = true;
		ports.forEach(function(port) {
			console.log("Kill child "+port);
			if (children[port]) children[port].kill();			
		});		
	}
	// console.log("Child processes terminated");	
}


process.on('exit', function() {
	// console.log("Terminate nanny");
	if (db) {
		db.close();
	}
	killChildren();
})

function get(hostdata, command, callback) {
	// console.log("GET "+command+" "+util.format(hostdata))
	var options = {method: 'GET', hostname: hostdata.local ? "localhost" : hostdata.hostname , port: hostdata.nannyPort, path: "/nannyCommand/"+command};
	// console.log("OP "+util.format(options))
	var req = http.request(options, function(res) {
		res.setEncoding("utf8");
		res.on("data", function(chunk) {
			// console.log("Chunk "+chunk)
		});
		res.on("end", function(chunk) {
			return callback(null, res.statusCode);
		})
	});
	req.on("error", function(e,d) { console.log("REQUESTERROR"+e); return callback(e)});
	req.end();
	// return callback(null, 1*res.statusCode == 200);
}

/// converts a port range description into an array of ports
function portArray(ports, nannyPort) {	
	/* functionality would be interesting only for IPC communication between servers
	  if (/^N\d\d?$/.test(ports)) {
		var max = ports.substr(1)*1;
		if (!max)
			throw new Error("There must be at least one child process")
		// shared memory
		var result = [];
		result.length = max;
		for (var i = 0; i<max; i++)
			result[i] = "N"+i;
		return result;
	} */
	var parts = ports.split(/\s*,\s*/);
	var portsMap = {};
	portsMap[nannyPort] = 0; 
	parts.forEach(function(part) {
		var r = /^\s*(\d+)(?:\s*\-\s*(\d+))?\s*$/.exec(part);
		if (!r)
			throw new Error("Wrong format of range "+part);		
		var lowerBound = 1*r[1];
		var upperBound = 1*r[2];
		if (upperBound) {
			if (lowerBound > upperBound)
				throw new Error("Upper bound less than lower bound in range "+part);
		} else upperBound = lowerBound;
		for (var i=lowerBound; i <= upperBound; i++) {
			if (i in portsMap)
				throw new Error("Port already used: "+i);
			portsMap[i] = 0;			
		}
	});
	delete portsMap[nannyPort];
	return Object.keys(portsMap);
}
exports.portArray = portArray;


/// main function
function start(conf, _) {
//	console.log("START function")
	if (process.argv[2] === "start") {
		console.log("Start detached node process");
		var out = fs.openSync('./out.log', 'a'); 
		var err = fs.openSync('./out.log', 'a');
		var child = child_process.spawn(process.argv[0], ["nanny", "run" ], { detached: true, stdio: [ 'ignore', out, err] });
		child.unref();
		return 0;
	} 
	config = conf;
	if (!config.license)
		throw "No database configuration";
	config.servername =  os.hostname();
	if (config.license && config.license.domain) {
		config.servername += ("."+config.license.domain);
	}
	console.log("Server name "+config.servername)
	// Establish connection to db
	db = new mongodb.Db(config.license.database, new mongodb.Server(config.license.hostname, config.license.port,
			{}), {});	
	db = db.open(_);
	var hostsCollection = db.createCollection('Host', _);
	hosts = hostsCollection.find().toArray(_);
	// data for local host
	hosts.unshift(null);
	var i = hosts.length;
	while (--i >= 1) {
		var host = hosts[i]
		host.ports = portArray(host.portList, host.nannyPort);
		if (host.hostname === config.servername) {
			host.local = true;
			hosts[0] = host;			
			hosts.splice(i, 1);
		}
	}
	if (process.argv[2] === "install") { // Install process
		try {
		if (!/^\d+$/.test(process.argv[3]))
			throw "Invalid nanny port number "+process.argv[3];
		portArray(process.argv[4], process.argv[3]); // result not required, only error messages 
		var nannyPort = 1*process.argv[3];
		var ports = process.argv[4];
		// console.log("INSTALL "+nannyPort, ports)
		if (hosts[0]) {
			console.log("Host found");
			if (process.argv[5] === "force") {
				try {
					get(hosts[0], "shutdown", _);
				} catch (e) {
					console.log("ERROR shutdown "+e);
				}
				console.log("update");
				hostsCollection.update({hostname: config.servername}, {$set:{ nannyPort: nannyPort, portList: ports, _updDate: new Date()}}, {w: 1}, _);
				return 0;
			} else {
				throw "Already installed";
			}				
		} else {
			// new host
			var newHost = {hostname: config.servername, nannyPort: nannyPort, portList: ports, _creUser: "setup", _updUser: "setup", _updDate: new Date(), active: true}
			console.log("insert "+util.format(newHost));
			hostsCollection.insert(newHost, {w:1}, _);				
			return 0;
		}
		} finally {
			db.close();
		}
	} else if (!process.argv[2] || process.argv[2] == "run") {
		hosts[0].ports.forEach(function(port) {
			createProcess(undefined, port);
		})
		var sessionCollection = db.createCollection('SessionInfo', _);
		proxy(sessionCollection);
	} else if (process.argv[2] === "stop") {
		db.close();
		console.log("Send stop signal")
		var result = get(hosts[0], "stop", _);
		console.log("Result"+result);
		return 0;
	} 
	return 1;
}
exports.start = start;


/// createProcess(exitCode, port)
/// creates child process listening at the given port and puts its object into the `children` instance.
/// when the process finishes, the process will be restarted unless `children.terminate` is set.
function createProcess(code, port, out, err) {
	if (code == undefined)
		console.log("Start process on port "+port)
		else
			console.log("Exit code "+code+" restarting process on port "+port)

			if (!children.terminate) { // restart processes (unless terminating all processes is intended)
				// console.log("(re)start process")
				if (!out) out = fs.openSync('./out'+port+'.log', 'a');
				if (!err) err = fs.openSync('./out'+port+'.log', 'a');
				children[port] = child_process.spawn(process.argv[0], ['.', port], {stdio: ['ignore', out, err]});
				// exit handler for restarting process
				children[port].on('exit', function(code) { return createProcess(code, port, out, err) });
			}
}




function proxy(sessionCollection) {
	http.createServer(function(request, response) { return requestListener(request, response, sessionCollection, function(error, data) {
		if (error)
			console.log("Error "+error+(error.stack? " stack "+error.stack : ""));
	});		
	}).listen(hosts[0].nannyPort);
	console.log("Server running at "+hosts[0].nannyPort)	
}


function requestListener(request, response, sessionCollection, _) {
	request.pause();
	// special commands which will not be redirected
	if (request.url.substring(0, 14) === "/nannyCommand/") {
		request.resume();
		var command = request.url.substr(14);
		console.log(command);
		switch (command) {
		case 'stop': // request to stop server
			killChildren();
			response.end("OK1");
			console.log("Finish")
			process.nextTick(function() { console.log("KILL process"); process.kill(process.pid); });
			break;
		case 'test': // test request 
			response.end("OK2");
			break;
		default:
			response.end("OK");
		}
		return;
	}    
	var cookies = request.headers.cookie;
	// console.log("Cookie "+cookies);
	var r;
	if (cookies) {
		var r = /syracuse\.sid=([\w\-]+)/.exec(cookies);
		if (r) {
			var session = r[1];
			console.log("Session: "+session)
			if (session in sessions) {
				console.log("Take session "+sessions[session]);
				doRequest(request, response, sessions[session], _);
				return;
			} else {
				// refresh local session table and balance
				var data = refreshSessions(sessionCollection, _);
				// console.log("Nach refresh 21" + util.format(data))
				// maybe session is now known
				if (session in sessions) {
					console.log("Take session2 "+sessions[session]);
					doRequest(request, response, sessions[session], _, session);
					return;
				}						
				// session does not exist: balance
				sessions[session] = data;
				doRequest(request, response, data, _, session);
				console.log("Nach do Request")
				return;
			}
		} else { // no session in cookie
			var data = refreshSessions(sessionCollection, _);
			console.log("Nach refresh 2"+ util.format(data))
			sessions[session] = data;
			doRequest(request, response, data, _);
			console.log("Nach do Request 2")
			return;				
		}
	}
}

//get sessions from database, count sessions per node.js process and 
function refreshSessions(sessionCollection, _) {
	// console.log("Refresh")
	var data = sessionCollection.find().toArray(_);
	sessions = {};
	var counts = {}; // number of sessions per node server
	data.forEach(function(sess) {
		var r = /^(.*)\:(\d+)$/.exec(sess.serverName);
		if (r) {
			if (sess.serverName in counts) {
				counts[sess.serverName]++;
			} else {
				counts[sess.serverName] = 1;
			}
			sessions[sess.sid] = [r[1], r[2]];
		}
	});
	console.log("Balance")
	return balance(counts, hosts);	
}


//finds 
function balance(counts, hosts) {
	var result;
	var minCount = Number.MAX_VALUE;
	hosts.forEach(function(host) {
		// console.log("Host "+util.format(host))
		var hostColon = host.hostname+":";
		host.ports.forEach(function(port) {
			var count = counts[hostColon+port] || 0;
			if (count < minCount) { // condition is true when counts[...] really exists and is less than
				result = [host.hostname, port];
				minCount = count; 
			}
		})
	})
	return result;
}
exports.balance = balance;


//low level http request to the server specified in `hostPort`. This must be an array with hostname in index 0 and port in index 1.
//the function is asynchronous and will finish the request.
function doRequest(request, response, hostPort, callback, sessionId) {
	// console.log("Do request "+util.format(hostPort))
	var ended = false;
	var full = false;
	var chunks = [];
	var options = { hostname: hostPort[0], port: hostPort[1], method: request.method, path: request.url, headers: request.headers };
	//console.log("options "+util.format(options))
	response.on("drain", function() {
		full = false;
		if (chunks.length > 0) {
			if (chunks.length > 1 || !ended) {
				full = !response.write(chunks.shift())
			//		console.log("write 1 "+full)			
			} else {
				response.end(chunks.shift());
				return callback(null);
			}
		} else {
		//	 console.log("drain end "+ended)
			if (ended) response.end();
			return callback(null);
		}

	})
	
	var req = http.request(options, function(res) {
// console.log("2 part res")
		full = false;
		ended = false;
		if (chunks.length > 0)
			throw new Error("Remaining chunks");
		response.writeHead(res.statusCode, res.headers);
		var cookies = res.headers['set-cookie'];
		if (cookies) {
			var index = cookies.indexOf('syracuse.sid=');
			if (index >= 0) {
				var newSession = cookies.substr(index+13, 36);
				if (newSession !== sessionId) {
					if (sessionId) delete sessions[sessionId];
					sessions[newSession] = hostPort;
				}
			}			
		}
		res.on("data", function(chunk) {
			// console.log("respo data");
			if (chunks.length > 0 || full) {
				// console.log("Add chunk")
				chunks.push(chunk);
			} else {
				full = !response.write(chunk)
				// console.log("write 2 "+full)
			}
		});
		res.on("end", function() {
			// console.log("end rspo");
			ended = true;
			if (!full) {
				switch (chunks.length) {
				case 0: response.end(); return callback(null); break;
				case 1: response.end(chunks.shift()); return callback(null); break;
				}
			}
		})
	});
	req.on("drain", function() {
		// console.log("req drain");
		full = false;
		if (chunks.length > 0) {
			if (chunks.length > 1 || !ended) {
				full = !req.write(chunks.shift())
				// console.log("write 1 "+full)			
			} else {
				req.end(chunks.shift());
			}
		} else {
			// console.log("drain end "+ended)
			if (ended) req.end();			
		}

	})
	req.on("error", function(err) {
		response.writeHead(500, "Internal error "+err);
		response.end();
		return callback(err);
	});
	request.on("data", function(chunk){
		// console.log("request data");
		if (chunks.length > 0 || full) {
			console.log("Add chunk")
			chunks.push(chunk);
		} else {
			full = !req.write(chunk)
			// console.log("write 2 "+full)
		}
	});
	
	request.on("end", function() {
		// console.log("req end");
		ended = true;
		if (!full) {
			switch (chunks.length) {
			case 0: req.end(); break;
			case 1: req.end(chunks.shift()); break;
			}
		}
	})
	request.resume();
	
}




