"use strict";
var locale = require("syracuse-core/lib/locale");
var http = require('http');
var https = require('https');
var dbDriver = require('./dbDriver')
var util = require('util');
var os = require('os');
var fs = require('fs')
var child_process = require('child_process')
var mock = require('./mock')
var recorder = require('./recorder')
var fut = require('streamline/lib/util/future')

// var tracer = null;
var tracer = console.log

// requests which are not in a session, are counted here. They will be regarded for load balancing in addition to the
// sessions according to the session table
var currentNewRequests = {};

// http server for nanny
var httpServer;
var httpServers = [];

var config;	
var db = null; // Database handle
//file for version information at customer's site (redundant name - also in syracuse-patch/lib/patchtools._js)
var VERSION_FILE = "version.json";
// special header for transporting client authorization information during load balancing
var SSL_HEADER = "syracusesslheader"; // special Http header for passing load balancing information (not used in this file)  


// maximal allowed time difference between servers in milliseconds
var TIME_THRESHOLD = 600000
// maximal number of requests between database time checks (will be multiplied with number of hosts)
var REQUEST_THRESHOLD = 1000
// time in milliseconds for a child process to wait after it has started
var PING_TIMEOUT = 100000
// polling interval for looking into database during stopping sessions
var POLL_INTERVAL = 3000;
// time which will remain to stop sessions
var POLL_TIME = 60000;

// status values: >= 0: notify for database updates, >= STATUS_INIT: child processes are possible; === STATUS_READY: notify for normal requests; <0: host cannot be used because of errors
// this list must fit to the status property of the host entity
var STATUS_INACTIVE = 0; // nanny inactive
var STATUS_INIT = 1; // initial status
var STATUS_START = 2; // starting child processes
var STATUS_READY = 3; // ready OK
var STATUS_FINISHING = 4; // server will stop soon
var STATUS_LOW_VERSION = -1; // host has low version compared to database entries
var STATUS_WRONG_VERSION = -2; // host has wrong version in cluster
var STATUS_TIME_DIFFERENCE = -3; // host deactivated because of time difference
var STATUS_RESPAWN = -4; // respawn limit of child processes exceeded
var STATUS_FOREIGN = -5; // initial status for foreign server
var STATUS_NOT_REACHABLE = -6; // timeout when reaching server 
var STATUS_NOT_STARTED = -7; // server has not been started


var lastDatabaseCheck = { time: 0, requests: 0}; // time and number of requests since last database time comparison


//list of sessions known to this balancer
var sessions = {}; // keys are Syracuse session ID's, values are corresponding server names and ports (as an array)
var hosts = []; // list of different Syracuse hosts, with following information: hostname, connection data, children number,
// active: generally available, started: currently started 
// version: Syracuse version (system is only usable when all versions are equal)
// status: see STATUS_... constants above
var hostsByName = {};
var localHost = null; // local host within hosts array
hosts.mainVersion = ""; // main version of the cluster (will be set upon first response of another server or when no server responds)
var children = []; // child processes ("N"+ind will be logical port of child with index 'ind')

// stringifies information for host array. Only stringifies the non-database fields and the hostname
function _stringifyHosts(h) {
	return JSON.stringify(h.map(_minifyHost));
}

function _minifyHost(h) {
	return { hostname: h.hostname, status: h.status, version: h.version };
}

// fills in SSL options
function sslOptions(connectionData, options) {
	if (connectionData.ssl) {
		options.ca = getCaCertificates(connectionData.serverCert); 
		if (connectionData.clientAuth) {
			options.cert = connectionData.clientCert.certificate;
			options.key = connectionData.clientCert.key;
			options.passphrase = connectionData.clientCert.pass;
			options.agent = false;
		}		
		tracer && tracer("Client https");
		return https;
	} else {
		tracer && tracer("Client http");
		return http;
	}
	
}


// taken from patchtools._js
// relNumberCmp: comparison of release numbers
// split release numbers in parts with dots as delimiters and numerically compare the parts
// result is negative, 0, positive if first release number is smaller, equal, bigger than second
// here also patch number will be considered (separator: '-')
function relNumberCmp(rel1, rel2) {
	var parts1 = rel1.split(/[\.\-]+/); 
	var parts2 = rel2.split(/[\.\-]+/);
	var bound = Math.min(parts1.length, parts2.length);
	for (var i = 0; i<bound; i++) {
		var diff = parts1[i] - parts2[i]; 
		if (diff != 0)
			return diff;		
	}
	return parts1.length-parts2.length;
}


function startServer(_) {
	var sessionCollection = dbDriver.createCollection(db, 'SessionInfo', _);
	for (var i = 0; i < localHost.connectionData.length; i++) {
		var connectionData = localHost.connectionData[i]
		if (!httpServers[i] && connectionData.active) {
			console.log("START SERVER "+connectionData.port)
			var listener = function(request, response) { return requestListener(request, response, sessionCollection, function(error, data) {
				if (error)
					console.log("Error "+util.format(error)+(error.stack? " stack "+error.stack : ""));
				});		
			}
			if (connectionData.ssl) {
				var cert = connectionData.serverCert;
				var ca = getCaCertificates(cert);
				var options = { key: cert.key, cert: cert.certificate, passphrase: cert.pass, ca: ca, requestCert: connectionData.clientAuth, rejectUnauthorized: connectionData.clientAuth};
				tracer && tracer("SSL options "+util.format(options))
				httpServers[i] = https.createServer(options, listener)
			} else {
				httpServers[i] = http.createServer(listener);				
			}
			httpServers[i].listen(connectionData.port);
		}
	}
}


function getCaCertificates(cert) {
	var cacerts = cert.caCertificates;
	var ca;
	if (cacerts && cacerts.length) {
		ca = cacerts.map(function(caCert) { if (caCert) 
			return caCert.certificate 
			else 
				return null;});
	}
	return ca;
}


//function copied from syracuse-core/lib/uuid.js
function generateUUID(sep) {
	var randomHex = function(len, mask, offset) {
		var n = Math.floor(Math.random() * (1 << 24));
		if (mask)
			n = (n & mask) + offset;
		var s = n.toString(16);
		return s.length >= len ? s.substring(0, len) : ("00000000".substring(0, len - s.length) + s);
	};
	// Version 4 UUIDs have the form
	// xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx with hexadecimal digits x
	// and hexadecimal digits 8, 9, A, or B for y
	if (sep == null)
		sep = '-';
	return randomHex(4) + randomHex(4) + sep + randomHex(4) + sep +
	randomHex(4, 0x0fff, 0x4000) +
	sep +
	randomHex(4, 0x3fff, 0x8000) +
	sep +
	randomHex(6) +
	randomHex(6);
};


function killChildren() {	
	if (children.length > 0) {
		console.log("Kill child processes");
		children.forEach(function(child) {
			child.terminate = true;
			if (child) child.kill();
		})
		children.length = 0;
	}
	// console.log("Child processes terminated");	
}


process.on('exit', function() {
	// console.log("Terminate nanny");
	dbDriver.close(db);
	killChildren();
})

// send a http request to a host. 
// host: in hosts array 
// command: command to send
// return: data of response.
function get(hostdata, method, path, data, _) {
	var address;
	if (hostdata.local) address = "localhost";
	else {
		address = hostdata.hostname;
		if (hostdata.tcpHostName) address = hostdata.tcpHostName;
	}
	var options = {method: method || 'GET', hostname: address , port: hostdata.connectionData[0].port, path: path};
	try {
		var foundHost = hostsByName[hostdata.hostname]; // set pending request (always get foundHost from hostsByName - there may have been an update request which
		                                                // has updated the hosts array
		if (foundHost) foundHost.pendingRequest = true;
		var client = sslOptions(hostdata.connectionData[0], options);
		var result = mock.simpleRequest(client, options, data, _);
		var foundHost = hostsByName[hostdata.hostname];
		if (foundHost) foundHost.pendingRequest = false;
		return result;
	} catch (e) {
		var foundHost = hostsByName[hostdata.hostname];
		if (foundHost && foundHost.pendingRequest) { // maybe the other host has sent a start signal inbetween (and therefore set 'pendingRequest' to false).
			                        // in this case the timeout should not make the server unreachable.
			foundHost.pendingRequest = false;
			foundHost.status = STATUS_NOT_REACHABLE;
			console.log("not reachable "+hostdata.hostname)						
		}
		console.log("GET ERROR "+hostdata.hostname+" "+e)
		throw e;		
	}
}

/// main function
function start(conf, _) {
	switch (process.argv[2]) {
	case "?":
	case "help": 
	case "--help":  
		console.log("Valid commands: ")
		console.log("node nanny install <Port> <Number> [license file]\n  Install process with port <Port> for nanny process, <Number> child processes.\n  The optional license file argument allows to include a license file into database")
		console.log("node nanny\n  (or: node nanny run) start nanny process")
		console.log("node nanny stop\n  ask running nanny process to stop")
		console.log("node nanny remove\n  Remove data for host process")
		console.log("node nanny help\n  This help text")
		return 0;
	}
	config = conf;
	config.servername =  os.hostname();
	config.collaboration = config.collaboration || {};
	console.log("Server name "+config.servername)
	// Establish connection to db
	db = dbDriver.open(config.collaboration, _);
	var hostsCollection = dbDriver.createCollection(db, 'Host', _)
	if (process.argv[2] === "install") {
		try {
			var tcpHostName = "";
			if (process.argv[3].substr(0, 3) === "-d=") {
				var tcpHostName = process.argv[3].substr(3);
				tcpHostName = tcpHostName.replace(/^["']/, "").replace(/["']$/, "");
				process.argv.splice(2, 1);
			}
			if (!/^\d+$/.test(process.argv[3]))
				throw "Invalid nanny port number "+process.argv[3];
			if (!/^\d\d?$/.test(process.argv[4]))
				throw "Invalid child process count "+process.argv[4];
			var port = 1*process.argv[3];
			var childCount = 1*process.argv[4];
			var localHosts = dbDriver.find(hostsCollection, {hostname: config.servername}, _)
			if (localHosts.length > 0) {
				throw "Nanny already installed";
			} else {
				// new host
				var newHost = {_id: generateUUID(), hostname: config.servername, nannyPort: 1, 
				        		connectionData: [{port: port, active: true, ssl: false, clientAuth: false, serverCert: null, clientCert: null, _uuid: generateUUID()}],
				        		children: childCount, _creUser: "setup", _updUser: "setup", _updDate: new Date(), deactivated: false, started: false, respawnCount: 10, respawnTime: 120, returnRequestTimeout: 30, tcpHostName: tcpHostName}
				dbDriver.insert(hostsCollection, newHost, _);
				console.log("Host inserted "+config.servername)
			}
			if (process.argv[5]) { // optional license file
				var content = fs.readFile(process.argv[5], "utf8", _)
				// the following code comes from syracuse-license/lib/check._js
				// remove beginning and end
				content = content.replace(/^[^\{\}]*\{/, "").replace(/\}[^\{\}]*$/, "");
				// split into parts and add curly braces (AND add text attribute)
				var parts = content.split(/\}[^\{\},]*[\n\r][^\{\},]*\{/).map(function(part){ return { text: "{"+part+"}"}; });
				var licenseCollection = dbDriver.createCollection(db, "license", _);
				dbDriver.insert(licenseCollection, parts, _);
			}
			return 0;
		} finally {
			dbDriver.close(db);
		}		
		return 0;
	}
	// updateHostData is not interesting for install
	updateHostData(false, _);
	switch (process.argv[2]) {
	case "run":
	case undefined:
		// read version file
		if (!localHost) {
			dbDriver.close(db);
			throw new Error("Service has not been installed")
		}
		try {
			var ver = JSON.parse(fs.readFile(VERSION_FILE, _));
			localHost.version = ver.relNumber+"-"+ver.patchNumber
		} catch (e) { console.log("Error in version file "+e)
			localHost.version = "-";
		}
		// find out whether there is newer server
		if (!process.argv[2]) {
			hosts.forEach(function(host) {
				var parts = (host.patchStatus || "0").split(";"); 
				if (host.hostname !== localHost.hostname && !host.deactivated && relNumberCmp(parts[0], localHost.version) > 0) {
					// current version is not newest version
					console.log("The host "+host.hostname+" has newer version "+parts[0]+" according to database");
					localHost.status = STATUS_LOW_VERSION;
				}
			})						
		} else {
			console.log("Avoid version test against database");
		}
			
		console.log("Start nanny with code version "+ localHost.version)
		dbDriver.update(hostsCollection, {hostname: config.servername}, { started: true, pid: process.pid}, _);
		startServer(_);
		// send signal (without waiting) to all active servers that this server is started.
		// also send version number so that versions can be compared
		firstStartSignal();
		break;
	case "stop":
		dbDriver.update(hostsCollection, {hostname: config.servername}, { started: false}, _);
		dbDriver.close(db);
		try {
			var result = get(localHost, "PUT", "/nannyCommand/stop", null, _);
		} catch (e) { console.log("Could not stop nanny (PID "+localHost.pid+"), error "+e);
			// TODO: when unauthorized connection via HTTPS with missing client certificates, do not give up but send SIGINT, wait 2 seconds,
			//  try again connection, when the same error occurs, send SIGTERM
		}
 		return 0;
	case "remove":
		try {
			dbDriver.remove(hostsCollection, { hostname: config.servername}, _);			
		} finally {
			dbDriver.close(db);			
		}		
		console.log("Host removed");		
		break;
	default:
		throw new Error("Wrong commmand line argument "+process.argv[2]+". Type node nanny help to get a list of all commands")

	} 
	return 1;
}
exports.start = start;




// send start signal to all nannies on active servers. This signal tells the other servers that this server has been started and tells about
// code version of this server. The response tells this server about the code version of the other servers. When the versions differ,  
function startSignal(host, _, first) {
	if (host.local || host.status <= STATUS_NOT_REACHABLE || (!first && host.status <= STATUS_FOREIGN)) return;
	tracer && tracer("Host with start signal "+util.format(host))
	console.log("START SIGNAL "+util.format(host))

	var data = get(host, "POST", "/nannyCommand/started", JSON.stringify(_minifyHost(localHost)), _);
	// check versions
	var infos = data.split(';');
	// console.log("INFOS "+data)
	host.version = infos[1];
	host.status = infos[2]*1;
	if (!hosts.mainVersion) {
		hosts.mainVersion = infos[0];
		checkVersions();
	}
}	

// send a start signal to all started nannies. This will also detect unreachable nannies.
function firstStartSignal(_) {
	var futures = [];
	hosts.forEach(function(host) {
		if (!host.local && host.started) {
			var signal = startSignal(host, undefined, true);
			if (!host.deactivated) futures.push(signal); // do not wait for answers of inactive servers!
		}
	})
	var i = futures.length;
	while (--i >= 0) {
		try {
			futures[i](_);
		} catch(e) {
			console.log("Error connecting host "+e+" "+e.stack);
		}
	}
	// maybe no host could be contacted
	checkVersions();
}


function checkVersions() {
	console.log("CHECK "+localHost.status+" "+hosts.mainVersion)
	if (localHost.status !== STATUS_INIT) return;
	var commonVersion;
	if (hosts.mainVersion) {
		if (hosts.mainVersion === localHost.version) commonVersion = hosts.mainVersion;
	} else { // no main version yet: test for common version
		commonVersion = localHost.version;
		hosts.forEach(function(host) {
			// only active hosts
			if (host.status > 0 && !host.local) {
				if (commonVersion && commonVersion !== host.version) commonVersion = null;
			}
		})
		if (commonVersion) hosts.mainVersion = commonVersion;
	}
	if (commonVersion) {
		startChildProcesses(true);
	} else {
		localHost.status = STATUS_WRONG_VERSION;
	}
}


function startChildProcesses(force) {
	if (localHost.status > STATUS_INIT || force) {
		// new number of children
		var newChildCount = (localHost.status >= STATUS_INIT) ? localHost.children : 0;
		// current number of children
		var oldChildCount = children.length;	
		tracer && tracer("Start child processes "+oldChildCount+" "+newChildCount)
		for (var i = newChildCount-1; i>= oldChildCount; i--) {
			createProcess(undefined, i);
		}
		while (children.length > newChildCount) {
			tracer && tracer("Kill child process"+children.length)
			var child = children.pop();
			child.terminate = true;
			child.kill();
		}
		if (newChildCount > 0 && localHost.status < STATUS_START) localHost.status = STATUS_START;
		if (localHost.status === STATUS_START) {
			// send ping signal to all child processes, then mark process ready
			var futures = [];
			children.forEach(function(child) {
				futures.push(child.mockClient.ping(undefined, PING_TIMEOUT));
			});
			// wait for results of child processes (collect results of futures). 
			// This function is called as a future!
			startedChildProcesses(futures);
		}
	}
}


function startedChildProcesses(futures, _) {
	var i = futures.length;
	var ok = true;
	while (--i >= 0) {
		try {
			futures[i](_);
		} catch (e) {
			ok = false;
			console.error("Error starting child process: "+e)
		}
	}
	if (ok) {
		localHost.status = STATUS_READY;
		console.log("Notify other servers about successful start of child processes")
		// send start signal again (as a future, because it is not necessary to wait for the result
		hosts.forEach(function(host) { return startSignal(host)});
	}
}

/// createProcess(exitCode, port)
/// creates child process listening at the given port and puts its object into the `children` instance.
/// when the process finishes, the process will be restarted unless `children.terminate` is set.
function createProcess(code, port) {
	var startTime = Date.now();
	var startCount = 0;
	var child = children[port];
	if (code == undefined)
		console.log("Start process on port N"+port)
		else {
			console.log("Exit code "+code+" restarting process on port N"+port)
			var respawnTime = 1000*localHost.respawnTime
			if (child && respawnTime && startTime-child.startTime < respawnTime) {
				startTime = child.startTime;
				startCount = (child.startCount || 0)+1;
				if (child.startCount > localHost.respawnCount) {
					// child processes unavailable
					console.log("RESPAWN COUNT")
					localHost.status = STATUS_RESPAWN;
					// tell other servers
					hosts.forEach(function(host) { return startSignal(host)});
					killChildren();
				}
			} 						
		}

	if (!child || !child.terminate) { // restart processes (unless terminating all processes is intended)
		// console.log("(re)start process")
		// if (!out) out = fs.openSync('./out'+port+'.log', 'a');
		// if (!err) err = fs.openSync('./out'+port+'.log', 'a');
		// var child = child_process.spawn(process.argv[0], ['.', port], {stdio: ['ignore', out, err]});
		var child = child_process.spawn(process.argv[0], ['.', "N"+port, localHost.returnRequestTimeout], {stdio: ['pipe', process.stdout, process.stderr, 'pipe']});
		child.startTime = startTime
		child.startCount = startCount;
		children[port] = child;
		// attach mock client to child process
		child.mockClient = new mock.Mock(child.stdin, child.stdio[3], requestListener);
		// exit handler for restarting process
		child.on('exit', function(code) { 
			if (child.terminate) { 
				console.log("Stop child")
			} else return createProcess(code, port) 
		});
	}
}

// returns an array of all status information
function statusString() {
	return hosts.map(function(host) { return host.status; }).join(',');
}



// read configuration data of hosts from database and update local configuration.
function updateHostData(startChildren, _) {
	var hostsCollection = dbDriver.createCollection(db, 'Host', _);
	var newHosts = dbDriver.find(hostsCollection, null, _);
	// add certificate information
	var certificateCollection = dbDriver.createCollection(db, 'Certificate', _);
	var certificates = dbDriver.find(certificateCollection, null, _);
	console.log()
	var caCertificateCollection = dbDriver.createCollection(db, 'CaCertificate', _);
	var caCertificates = dbDriver.find(caCertificateCollection, null, _);

	newHosts.forEach_(_, function(_, host) {
		host.connectionData.forEach_(_, function(_, conn) {
			if (conn.serverCert = dbDriver.findInstance(conn.serverCert, certificates)) {
				conn.serverCert.key = dbDriver.binaryContent(db, conn.serverCert.key, _);
				conn.serverCert.certificate = dbDriver.binaryContent(db, conn.serverCert.certificate, _);
                var cas = conn.serverCert.caCertificates;
				for (var i = cas.length-1; i >= 0; i--) {
					if (cas[i] = dbDriver.findInstance(cas[i], caCertificates)) {
						cas[i].certificate = dbDriver.binaryContent(db, cas[i].certificate, _);
					}
				}
			}
			if (conn.clientCert = dbDriver.findInstance(conn.clientCert, certificates)) {
				conn.clientCert.key = dbDriver.binaryContent(db, conn.clientCert.key, _);
				conn.clientCert.certificate = dbDriver.binaryContent(db, conn.clientCert.certificate, _);
                var cas = conn.clientCert.caCertificates; 
				for (var i = cas.length-1; i >= 0; i--) {
					if (cas[i] = dbDriver.findInstance(cas[i], caCertificates)) {
						cas[i].certificate = dbDriver.binaryContent(db, cas[i].certificate, _);
					}
				}
			}
		})
	})
	hosts = _updateHosts(hosts, newHosts, config.servername);
	if (!localHost) { // data for local host not available
		console.error("No data for local nanny")
		process.exit(2);		
	}
	if (localHost.stop) { // data for local host have changed
		console.log("Connection data changed - restart nanny")
		process.exit(10);		
	}
	if (startChildren) startServer(); // maybe restart server because of port change - start asynchronously because current request will block stopping of server
	startChildProcesses(startChildren);
}

function _updateHosts(oldHosts, hosts, name) {
	// sort host data by hostname
	hosts = hosts.sort(function(host1, host2) { 
		var h1 = host1.hostname; 
		var h2 = host2.hostname;
		return (h1 > h2 ? 1 : (h1 < h2 ? -1 : 0))
	});
	var i = hosts.length;
	localHost = null;
	hostsByName = {};
	LOOP: while (--i >= 0) {
		var host = hosts[i]
		// Is first connection of every host existent and active? 
		if (!host.connectionData || !host.connectionData.length || host.connectionData[0].deactivated) {
			throw locale.format(module, "errorConnectionData", host.hostname);
		}
		hostsByName[host.hostname] = host;
		if (host.hostname === name) {
			host.local = true;
			localHost = host;
		}
		var j = oldHosts.length;
		while (--j >= 0) {
			var oldHost = oldHosts[j];
			if (!oldHost) continue;
			if (oldHost.hostname === host.hostname) {
				host.version = oldHost.version;
				host.status = oldHost.status;
				host.pendingRequest = oldHost.pendingRequest;
				if (oldHost.hostname === name) {
					// have connection data of local host changed?
					var oldConnections = oldHost.connectionData;
					var connections = host.connectionData;
					for (var k = 0; k<oldConnections.length; k++) {
						var oldConn = oldConnections[k];
						if (oldConn.active && (!_deepEqual(oldConn, connections[k]))) {
							localHost.stop = true;
							break;
						}
					}					
				}
			};
		}
		// explicitly set certain status values
        if (host.deactivated && host.status > STATUS_INACTIVE) host.status = STATUS_INACTIVE;
		if (!host.local && !host.started) host.status = STATUS_NOT_STARTED;
		if (host.status === undefined || host.started && host.status === STATUS_NOT_STARTED || !host.deactivated && host.status === STATUS_INACTIVE) {
			// initialize status: a foreign host is not reachable unless it is known to be reachable
			host.status = (host.local ? (!host.deactivated ? STATUS_INIT : STATUS_INACTIVE) : STATUS_FOREIGN);			
		}
	}
	hosts.mainVersion = oldHosts.mainVersion || "";
	return hosts;
}
// tests whether arguments are equal. Empty array and empty object do not count as different
function _deepEqual(a, b) {
	// both are empty/null/undefined or really equal/identical
	console.log("DDEE "+util.format(a)+" "+util.format(b))
	if ((!a && !b) || a === b) return true;
	console.log(1)
	// one of them is empty/null/undefined
	if (!a || !b) return false;
	if (a instanceof Object && b instanceof Object) {
		console.log("Buffer");
		if (Buffer.isBuffer(a)) {
			if (!Buffer.isBuffer(b) || a.length !== b.length) return false;
			for (var i = a.length-1; i>=0; i--) {
				if (a[i] !== b[i]) return false;
			}
			return true;
		}
		console.log("Obj")
		if (Object.keys(a).some(function(key) {
			console.log("KEY "+key)
			if (!_deepEqual(a[key], b[key])) return true;
		})) return false;		
		if (Object.keys(b).some(function(key) {
			if (!(key in a)) return true;
		})) return false;
		return true;
	}
	return false;
}


function requestListener(request, response, sessionCollection, _) {
	tracer && tracer(">> "+request.url)
	request.pause();
	// exchange headers
	var headers = {};
	Object.keys(request.headers).forEach(function(head) {
		headers[head] = request.headers[head];
	})
	request.headers = headers;
	var streamRecorder; 
	// testSessions(sessionCollection, _);
	// special commands which will not be redirected
	if (request.url.substring(0, 14) === "/nannyCommand/") {		
		var command = request.url.substr(14).split('/');		
		var resultText = localHost.hostname+":\n";
		var futures = []; // invocations of other processes
		var commandType = command[0];
		var syraBalancerHeader = request.headers[mock.BALANCER_HEADER];

		switch(command[0]) {
		case 'notifyAll': // notify all
			request.pause();
			var clientId = syraBalancerHeader;
			streamRecorder = new recorder.StreamRecorder(request);
			// Notify other servers (without waiting)
			if (clientId) {
				delete request.headers[mock.BALANCER_HEADER];				
				hosts.forEach(function(host) {
					if (!host.local && host.status === STATUS_READY) {
						tracer && tracer("Request to server "+i);
						futures.push(doRequestWithAnswer(streamRecorder, [host, null]));
					}
				});
			}
			request.url = request.url.replace(/^\/[^\/]+\/[^\/]+/, "")
			tracer && tracer("Local path "+request.url)
			for (var i=0; i<children.length; i++) {
				var port = "N"+i;
				if (port !== clientId) {
					tracer && tracer("Request to local app "+port)
					var future = doRequestWithAnswer(streamRecorder, [localHost, port])				
					future.extra = {port: port};
					futures.push(future);
				}
			}
			break;
		case "notifyOtherNannies": // send the command (without '/notifyOtherNannies' in URL) to other nannies which have status OK and finish the request
			request.pause();
			// console.log("CLIENT ID "+clientId)
			streamRecorder = new recorder.StreamRecorder(request);
			request.url = request.url.replace(/^(\/[^\/]+)\/[^\/]+/, "$1") // remove second part
			tracer && tracer("Notify all running "+clientId+" "+request.url)
			// Notify other servers (without waiting)
			delete request.headers[mock.BALANCER_HEADER];
			hosts.forEach(function(host) {
				if (!host.local && host.status >= STATUS_READY) {
					tracer && tracer("Request to server "+host.hostname)
					futures.push(doRequestWithAnswer(streamRecorder, [host, null]));
				}
			});	
			break;
		case "notifyNannies": // send the command (without '/notifyOtherNannies' in URL) to all nannies which have status at least inactive.
			command.shift();
			request.pause();
			// console.log("CLIENT ID "+clientId)
			streamRecorder = new recorder.StreamRecorder(request);
			request.url = request.url.replace(/^(\/[^\/]+)\/[^\/]+/, "$1") // remove second part
			tracer && tracer("Notify all started "+request.url)
			// Notify other servers (without waiting)
			delete request.headers[mock.BALANCER_HEADER];
			hosts.forEach(function(host) {
				if (!host.local && host.status >= STATUS_INACTIVE) {
					tracer && tracer("Request to server "+host.hostname)
					var fut = doRequestWithAnswer(streamRecorder, [host, null]);
					fut.infoinfo = host.hostname;
					futures.push(fut);
				} else {
					futures.push(null);
				}
			});	
			break;
		}

		switch (command[0]) {
		case 'stop': // request to stop server
			var futures = [];
			var i;
			for (i = 0; i<hosts.length; i++) {
				if (host && host.status >= STATUS_INACTIVE && !host.local) {
					futures[i] = get(host, "PUT", "/nannyCommand/down/"+localHost.hostname, null, undefined);
				}
			}
			killChildren();
			resultText = "OK1"
			// Exceptional case here: call futures here because otherwise process.nextTick function will not allow them to be executed
			for (var i = 0; i<futures.length; i++) {
				try {
					if (futures[i]) futures[i](_);					
				} catch (e) {
					console.log("Exception when informing host "+hosts[i].hostname+": "+e);
				}
			}
			futures = [];
			process.nextTick(function() { console.log("Exit process"); process.exit(0); });
			break;
		case 'notifyOne': // send request only to local server with lowest number of sessions (without '/nannyCommand/notifyOne')
			var sessionCollection = dbDriver.createCollection(db, 'SessionInfo', _);
			var data = refreshSessions(sessionCollection, true, _); // only local host
			if (!data) {
				data = [localHost, "N0"];
				tracer && tracer("No balancer result - set process N0");
			}
			if (!streamRecorder) {
				request.url = request.url.replace(/^\/[^\/]+\/[^\/]+/, "") // remove first two parts
				streamRecorder = new recorder.StreamRecorder(request);
			} else {
				streamRecorder.originalStream.url = streamRecorder.originalStream.url.replace(/^\/[^\/]+\/[^\/]+/, "") // remove first two parts 
			}
			try {
				var future = doRequestWithAnswer(streamRecorder, data)				
				future.extra = {port: data[1]};
				futures.push(future);
			} catch (e) {
				tracer && tracer("Host not available "+data[0].hostname+ " Error "+e)
			}							
			break;
		case 'stopSessions':
			// read request data fully before answering request         
			if (streamRecorder) streamRecorder.loadFully(_);
			response.writeHead(200, {'Content-Type': 'text/plain'});
			response.end("OK"); // finish request
			console.log("STOP SESSIONS "+futures.length)
			// do not wait for answers of other servers
			// for (var i = 0; i<futures.length; i++) {
            //	try {					
			//		if (futures[i]) console.log(futures[i].infoinfo+" ----- "+futures[i](_));					
			//	} catch (e) {
			//		console.log("Exception when informing host "+hosts[i].hostname+": "+e+" "+e.stack+" "+e.trace);
			//	}
			// }
			var sessionCollection = dbDriver.createCollection(db, 'SessionInfo', _);
			try {
			stopSessions(sessionCollection, syraBalancerHeader, _);
			} catch (e) {
				console.log("Exception stopSessions "+e);
			}
			console.log("After stopSessions");
			var hostsCollection = dbDriver.createCollection(db, 'Host', _);
			dbDriver.update(hostsCollection, {hostname: config.servername}, { started: false}, _);
			dbDriver.close(db);
			// httpServer.unref();
			console.log("END")
			process.nextTick(function() { console.log("Exit process"); process.exit(10); });			
			return;
		case 'update':
			updateHostData(true, _);
			resultText +="OK5"
			break;
		case 'test': // test request
			resultText += "OK2"
			break;
		case 'children': // ping to children
			if (localHost.status >= STATUS_START) {
				for (var i = children.length-1; i>=0; i--) {
					var future = children[i].mockClient.ping(undefined, 1000);
					future.extra = {hostname: localHost.hostname, port: "N"+i, requests: children[i].mockClient.numberRequests()};
					futures.push(future)
				}				
			} else {
				resultText += JSON.stringify({hostname: localHost.hostname, message: "Children not yet started"})+"\n";
			}
			if (commandType === "notifyNannies") { // extra information only from current host
				resultText += _stringifyHosts(hosts)+"\n";
			}
			break;
		case 'details': // details information about children
			if (localHost.status === STATUS_READY) {
				for (var i = children.length-1; i>=0; i--) {
					var future = children[i].mockClient.detail(undefined, 1000);
					future.extra = {hostname: localHost.hostname, port: "N"+i};
					futures.push(future)
				}				
			} else {
				resultText += JSON.stringify({hostname: localHost.hostname, message: "Children not yet started"})+"\n";
			}
			if (commandType === "notifyNannies") { // extra information only from current host
				resultText += _stringifyHosts(hosts)+"\n";
			}
			break;
		case 'info': // info request
			resultText += util.format(hosts);
			var childResults = [];
			for (var i=0; i<children.length; i++) {
				childResults.push("N"+i+": "+children[i].mockClient.numberRequests())
			}
			resultText += "\n"+childResults.join(", ");
			break;
		case 'infojson': // info request
			resultText = _stringifyHosts(hosts);
			break;
		case 'started': // nanny has started
			try {
				var d = getData(streamRecorder ? streamRecorder.getStream() : request, _);
				var hostData = JSON.parse(d);
				var foundHost = null;
				for (var attempt = 0; attempt < 2; attempt++) {
					foundHost = hostsByName[hostData.hostname];
					if (foundHost && !foundHost.local) {
						foundHost.status = hostData.status;
						foundHost.started = true;
						foundHost.version = hostData.version;
						foundHost.pendingRequest = false; // maybe there is a get() request pending which will result in a timeout. It should not mark the host as unavailable.
						tracer && tracer("Host started "+foundHost.hostname);
						break;
					}
					console.log("FOUND "+foundHost)
					if (!foundHost) updateHostData(false, _);					
				}
				if (!foundHost) {
					response.end("??;"+localHost.version+";"+localHost.status)
					return;
				}
				checkVersions();
				// maybe update status of other host
				console.log("HOST2 "+util.format(foundHost))
				if (foundHost && hosts.mainVersion !== foundHost.version) foundHost.status = STATUS_WRONG_VERSION;
				var returnValue = hosts.mainVersion+";"+localHost.version+";"+localHost.status
				tracer && tracer("return value on start request "+returnValue)
				response.end(returnValue); // send back local code version and main version				
			} catch (e) {
				writeError(response, "Error "+e);
			}			
			return;
		case 'down': // nanny has stopped
			var host = command[1];
			// update host data (nothing to do when host is not found)
			var foundHost = hostsByName[host];
			if (foundHost && !foundHost.local) {
				foundHost.started = false;
				foundHost.status = STATUS_NOT_STARTED;
				tracer && tracer("Host down "+foundHost.hostname);
			}
			checkVersions();
			resultText += "OK - down"
			break;
		default:
			resultText += "OK "+command[0];
		}
		
		console.log("Futures")
		for (var i=0; i<futures.length; i++) {
			if (!futures[i]) continue;
			var extra = futures[i].extra;
			try {
				var res = futures[i](_)
				if (extra instanceof Object) {
					extra.message = res;
					resultText+= JSON.stringify(extra)+"\n";						
				} else {
					resultText += (extra || "")+res+"\n";
				}
				tracer && tracer("result of future "+res+" ---- "+JSON.stringify(extra))
			} catch (e) {
				if (extra instanceof Object) {
					extra.message = ""+e;
					extra.failure = true;
					resultText+= JSON.stringify(extra)+"\n";						
				} else {
					resultText += (extra || "") +e+"\n";					
				}
				console.log("error of future "+e)
			}
		}
		response.writeHead(200, {'Content-Type': 'text/plain'});
		response.end(resultText);
		console.log("ENDE")
		return;
	}

	// console.log("==============================="+localHost.status)
	if (localHost.status < STATUS_READY) {
		var text;
		var temporary = false;
		switch (localHost.status) {
		case STATUS_START: temporary = true; text = locale.format(module, "beingStarted"); break;
		case STATUS_INIT: temporary = true; text = locale.format(module, "notYetStarted"); break;
		case STATUS_TIME_DIFFERENCE: text = locale.format(module, "timeDifference"); break;
		case STATUS_WRONG_VERSION: text = locale.format(module, "wrongVersion", hosts.mainVersion, localHost.version); break;
		case STATUS_LOW_VERSION: text = locale.format(module, "lowVersion", localHost.version); break;
		case STATUS_RESPAWN: text = locale.format(module, "respawn"); break;
		case STATUS_INACTIVE: text = locale.format(module, "inactive"); break;
		case STATUS_NOT_REACHABLE: text = locale.format(module, "notReachable"); break; 
		case STATUS_NOT_STARTED: text = locale.format(module, "notStarted"); break;
		default: text = locale.format(module, "wrongStatus", localHost.status);
		}
		writeError(response, text, temporary);
		return;
	}

	streamRecorder = new recorder.StreamRecorder(request);

	if (mock.BALANCER_HEADER in request.headers) {
		if (localHost.status < STATUS_READY) {
			writeError(response, "Host not yet ready", true)
			return;
		}
		var data = request.headers[mock.BALANCER_HEADER].split(",");		
		var localPort = data[0];
		for (var i = data.length-1; i > 0; i--) {
			if (!hosts[i-1].local) hosts[i-1].status = data[i];
		}
		tracer && tracer("balancer header "+localPort)
		var number = localPort.substr(1)*1;
		if (!(number in children)) {
			writeError(response, locale.format(module, "noChildNumber", localPort, localHost.hostname))
			return;
		}
		try {
			doRequest(streamRecorder, response, [localHost, localPort], _);
			return;
		} catch (e) {
			tracer && tracer("Error in local call "+e);
			writeError(response, locale.format(module, "giveUpLocal"))
		}						
		return;
	}
	var sid; // Syracuse session
	if (request.headers.cookie) {
		var r = /syracuse\.sid=([\w\-]+)/.exec(request.headers.cookie);
		if (r) {
			sid = r[1];
			tracer && tracer("Session: "+sid)
		}		
	}
	// check time with database time
	// test comment
	var now = Date.now();
	if (now < lastDatabaseCheck.time || now-lastDatabaseCheck.time > TIME_THRESHOLD || ++lastDatabaseCheck.requests > REQUEST_THRESHOLD*hosts.length) {		
		// avoid multiple database queries because of race conditions
		lastDatabaseCheck.time = now;
		lastDatabaseCheck.requests = 0;		
		// get time from database
		var dbTime = dbDriver.time(db, _);
		var diff = dbTime-now;
		tracer && tracer("database time check--"+dbTime+ " difference "+diff)
		if (diff > TIME_THRESHOLD || -diff > TIME_THRESHOLD) {
			localHost.status = STATUS_TIME_DIFFERENCE;
			writeError(response, locale.format(module, "timeDiffDatabase", localHost.hostname, TIME_THRESHOLD/1000));
			startChildProcesses(true);
			return;
		}
	}
	
	var data; // data from load balancing
	if (sid) { // session available
		if (sid in sessions) {
			var host = sessions[sid][0]
			if (host.status < STATUS_READY) {				
				tracer && tracer("Delete session "+sid+" "+util.format(host))
				deleteSession(sid, sessionCollection, _);
			} else {
				try {
					doRequest(streamRecorder, response, sessions[sid], _, sid);
					console.log("Request finished");
					return;
				} catch (e) {
					tracer && tracer(""+e+"Delete session "+sid+" "+util.format(host))
					deleteSession(sid, sessionCollection, _);
					tracer && tracer("Host not available "+host.hostname)
				}				
			}
		}
		if (localHost.status === STATUS_FINISHING) {
			// no new sessions accepted during finish
			writeError(response, locale.format(module, "shuttingDown"));
			return;
		}
		// refresh local session table and balance
		data = refreshSessions(sessionCollection, false, _);
		if (!data) return differentVersionError(response);
		// maybe session is now known
		if (sid in sessions) {
			var host = sessions[sid][0]
			if (host.status < STATUS_READY) {
				tracer && tracer("Delete session3 "+sid+" "+util.format(host))				
				deleteSession(sid, sessionCollection, _);
			} else {
				try {
					doRequest(streamRecorder, response, sessions[sid], _, sid);
					return;
				} catch (e) {tracer && tracer(""+e+"Delete session4 "+sid+" "+util.format(host))
					deleteSession(sid, sessionCollection, _);
				console.log("Host not available1 "+host.hostname)
				}				
			}
		}
	}
	// session not available any more
	if (localHost.status === STATUS_FINISHING) {
		// no new sessions accepted during finish
		writeError(response, locale.format(module, "shuttingDown"));
		return;
	}
	for (var i = 0; i<2; i++) {
		if (!data) {
			data = refreshSessions(sessionCollection, false, _); // balance
			if (!data) return differentVersionError(response);
		}
		try {
			doRequest(streamRecorder, response, data, _);
			return;
		} catch (e) {
			tracer && tracer("Host not available "+data[0].hostname+ " Error "+e)
			data = null;
		}				
	}
	writeError(response, locale.format(module, "giveUp"))
	return;				
}


function stopSessions(sessionCollection, exclude, callback) {
	var remainingTime = POLL_TIME+POLL_INTERVAL;
	var count = 1; // number of sessions (will be set by database query)
	var answerSent = false;
	function pollfunction() {
		try {
		remainingTime -= POLL_INTERVAL;
		console.log(answerSent+"Poll for sessions, count "+count+", remaining "+remainingTime);
		if (count === 0 && !answerSent) {
			answerSent = true;
			return callback(null);			
		}
		if (remainingTime <= 0) {
			console.log("Remove sessions")
			answerSent = true;
			dbDriver.remove(sessionCollection, {}, callback);
			return;
		}
		if (!answerSent && (remainingTime <= 0 || count === 0)) {
			console.log("")
			answerSent = true;
			return callback(null);
		}
		// start function again
		setTimeout(pollfunction, POLL_INTERVAL);
		// start database query
		dbDriver.count(sessionCollection, {}, function(error, cnt) {
			console.log("Session cnt Error: "+error+" count: "+cnt);
			if (error && !answerSent) {
				answerSent = true;
				return callback(error);
			}
			count = cnt;
		});
		} catch (e) {
			console.log("Error in poll function "+e);
			if (!answerSent) {
				return callback(e);
			}
		}
	}
	
	try {
		pollfunction();
		if (localHost.status < STATUS_READY) {
			// just stop the starting child processes
			console.log("stopSessions: Stop all child processes")
			localHost.status = STATUS_NOT_STARTED;
			startChildProcesses(true);
		} else {
			// notification to all Syracuse processes that sessions will expire
			console.log("stopSessions: notify all child processes");
			var options = { path: "/notifyEnd", method: "GET"};
			var futures = [];
			for (var i = children.length-1; i>=0; i--) {
				console.log("Stop session N"+i+" exclude "+exclude)
				if ("N"+i !== exclude) futures.push(mock.simpleRequest(children[i].mockClient, options, null));
			}							
		}
		localHost.status = STATUS_FINISHING;		
	} catch (e) {
		console.log("Error in stop function "+e);
		if (!answerSent)
			return callback(e);
	}
}


function deleteSession(session, sessionCollection, _) {
	delete sessions[session];
	dbDriver.remove(sessionCollection, { sid: session}, _);
}

// writes an error response. When parameter 'temporary' is set, it will be a 503 response (service not available)
function writeError(response, reason, temporary) {
	tracer && tracer("write error "+reason)
	response.writeHead(temporary ? 503 : 500, temporary ? "Server temporarily not available" : "Internal error", { "Content-Type": "text/plain" });
	response.end(reason);
	console.log("WRITE ERROR "+reason)
}

function differentVersionError(response) {
	writeError(response, locale.format(module, "differentVersions", hosts.map(function(host) { return host.hostname+"/"+host.version; }).join(", ")))
}


function getData(stream, callback) {
	stream.setEncoding('utf8');
	stream.resume();
	var result = "";
	stream.on('data', function(chunk) {
		result += chunk;
	})
	stream.on('end', function() {
		return callback(null, result);
	})	
}

// function testSessions(sessionCollection, _) {
// 	var data = sessionCollection.find().toArray(_);	
// 	var s = data.map(function(sess){return sess.serverName})
//	console.log("SSSSSSSSSSs "+util.format(s));
// }


//get sessions from database, count sessions per node.js process and do load balancing
// parameter local: only consider sessions on local server
function refreshSessions(sessionCollection, local, _) {
	tracer && tracer("Refresh sessions")
	// console.log("Refresh")
	var data = dbDriver.find(sessionCollection, null, _);
	sessions = {};
	var counts = {}; // number of sessions per node server
	data.forEach(function(sess) {
		tracer && tracer("Session "+util.format(sess))
		var r = /^(.*)\:(N\d+)$/.exec(sess.serverName);
		if (r) {
			if (sess.serverName in counts) {
				counts[sess.serverName]++;
			} else {
				counts[sess.serverName] = 1;
			}
			hosts.forEach(function(host) {
				if (host.hostname === r[1]) {
					if (r[2].substr(1)*1 < host.children) {
						sessions[sess.sid] = [host, r[2]];
					} else {
						tracer && tracer("Wrong port "+r[2]+" for "+host.hostname)
					}
					return;
				}
			})

		}
	});
	// add current requests for new sessions
	Object.keys(currentNewRequests).forEach(function(key) {
		var value = currentNewRequests[key];
		if (value > 0) {
			tracer && tracer("Add current requests "+key+" value "+value)
			if (key in counts) {
				counts[key] += value;
			} else {
				counts[key] = value;
			}			
		} 
	});
	tracer && tracer("Balance");
	return balance(counts, local ? [localHost] : hosts, localHost.hostname);	
}


//finds host (and application server) with minimal number of sessions. The local host is preferred when there are several 
// applications with same minimal number of sessions.
function balance(counts, hosts, localhostname) {
	var result;
	var minCount = Number.MAX_VALUE;
	tracer && tracer("Hosts "+util.format(hosts))
	hosts.forEach(function(host) {
		if (host.status < STATUS_READY) return;
		tracer && tracer("Host "+util.format(host))
		var hostColon = host.hostname+":";
		for (var i=host.children-1; i>= 0; i--) {
			var port = "N"+i;
			var count = counts[hostColon+port] || 0;
			tracer && tracer("count "+hostColon+port+" value "+counts[hostColon+port])
			if (count < minCount || (count === minCount && host.hostname === localhostname)) { // condition is true when counts[...] really exists and is less than
				result = [host, port];
				minCount = count; 
			}
		}
	})
	tracer && tracer("Balance result "+util.format(result))
	return result;
}
exports.balance = balance;


function doRequestWithAnswer(streamRecorder, hostPort, _, sessionId) {
	tracer && tracer("Do req with answer to "+hostPort[0].hostname+":"+hostPort[1]+" "+streamRecorder.originalStream.url)
	console.log("Do req with answer to "+hostPort[0].hostname+":"+hostPort[1]+" "+streamRecorder.originalStream.url)
	var dummyResponse = new mock.MemoryStream();
	doRequest(streamRecorder, dummyResponse, hostPort, _);
	tracer && tracer("Answer from host "+dummyResponse.content);
	return dummyResponse.content;
}


function doRequest(streamRecorder, response, hostPort, callback, sessionId) {
	if (!callback) return fut.future(doRequest, arguments, 3);
	var client;
	var options;
	var sessionHostName
	var connectionData = hostPort[0].connectionData[0];
	var port = ""+(hostPort[1] ? hostPort[1] : connectionData.port);
	var foundHost = hostsByName[hostPort[0].hostname];
	if (foundHost) {
		foundHost.pendingRequest = true;
		// console.log("PENDING "+foundHost.hostname)
	}
	if (!sessionId) {
		sessionHostName = localHost.hostname+":"+port;
		if (sessionHostName in currentNewRequests) {
			currentNewRequests[sessionHostName]++;	
		} else currentNewRequests[sessionHostName] = 1;		
	}
	if (hostPort[0].hostname === localHost.hostname) {
		tracer && tracer("local request to "+hostPort[1])
		options = mock.extractDataFromRequest(streamRecorder.originalStream);
		if (mock.BALANCER_HEADER in streamRecorder.originalStream.headers) {
			delete streamRecorder.originalStream.headers[mock.BALANCER_HEADER];
			var sslHeader = streamRecorder.originalStream.headers[SSL_HEADER];
			console.log("BAL SSLHEADER "+util.format(sslHeader))
			if (sslHeader) {
				try {
				    var parsed = JSON.parse(sslHeader);
					options.connection = {authorized: parsed[0], _peerCertificate: parsed[1]};					
				} catch (e) {
					writeError(response, locale.format(module, "sslHeaderError", e, sslHeader));
				}
			} else {				
				options.connection = {};				
			}			
		}
		client = children[hostPort[1].substr(1)].mockClient
	} else {
		if (port.substr(0, 1) === "N") {
			streamRecorder.originalStream.headers[mock.BALANCER_HEADER] = hostPort[1]+","+statusString();
			var conn = streamRecorder.originalStream.connection
			if (conn && "authorized" in conn) {
				var sslHeader = JSON.stringify([conn.authorized, conn.getPeerCertificate()]);
				streamRecorder.originalStream.headers[SSL_HEADER] = sslHeader;
			}
			// syracusesslheader setzen aus connection
			port = connectionData.port;
			tracer && tracer("Set port to nanny port "+port)
		}
		var address = hostPort[0].hostname;
		if (hostPort[0].tcpHostName) address = hostPort[0].tcpHostName
		options = { connection: {}, hostname: address , port: port, method: streamRecorder.originalStream.method, path: streamRecorder.originalStream.url, headers: streamRecorder.originalStream.headers };
		client = sslOptions(connectionData, options);
		console.log("OPTIONS "+util.format(options))
	} 
	var req = client.request(options, function(res) {
		if (sessionHostName) {
			currentNewRequests[sessionHostName]--;
			sessionHostName = null;
		}
		var foundHost = hostsByName[hostPort[0].hostname];
		if (foundHost) foundHost.pendingRequest = false;
		res.pause();
		res.on('end', function() {
			callback(null);
		});
		var date = res.headers['date'];
		if (date) {
			var diff = Date.now()-new Date(date).getTime();
			tracer && tracer("Time difference "+diff)
			if (diff > TIME_THRESHOLD || -diff > TIME_THRESHOLD) {
				hostPort[0].status = STATUS_TIME_DIFFERENCE;
				writeError(response, locale.format(module, "timeDifference2", localHost.hostname, hostPort[0].hostname, (TIME_THRESHOLD/1000)));
				return;
			}
		}
		var cookies = res.headers['set-cookie'];
		if (cookies) {
			var index = cookies.indexOf('syracuse.sid=');
			if (index >= 0) {
				var newSession = cookies.substr(index+13, 36);
				if (newSession !== sessionId) {
					if (sessionId) delete sessions[sessionId];
					sessions[newSession] = hostPort;
				}
			}			
		}
		response.writeHead(res.statusCode, res.headers);
		res.resume();
		res.pipe(response);
	});
	req.on("error", function(err) {
		// mark server as down unavailable
		if (sessionHostName) {
			currentNewRequests[sessionHostName]--;
			sessionHostName = null;
		}
		tracer && tracer("Error "+util.format(hostPort[0]))
		tracer && tracer("Mark as down")
		var foundHost = hostsByName[hostPort[0].hostname];
		console.log("MARK "+util.format(foundHost))
		if (foundHost.pendingRequest) {
			foundHost.pendingRequest = false;
			foundHost.status = STATUS_NOT_REACHABLE;
		}
		// connection error - try to find other server
		tracer && tracer("Connection error "+err+" "+util.format(hostPort))
		return callback(err);
	});
	streamRecorder.newStream().pipe(req);
}

//for unit tests
exports._updateHosts = _updateHosts
exports._deepEqual = _deepEqual

