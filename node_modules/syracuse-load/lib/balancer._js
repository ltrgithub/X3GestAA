"use strict";
var locale = require("syracuse-core/lib/locale");
var uuid = require("syracuse-core/lib/uuid");
var http = require('http');
var https = require('https');
var dbDriver = require('./dbDriver');
var util = require('util');
var os = require('os');
var fs = require('streamline-fs');
var child_process = require('child_process');
var mock = require('./mock');
var recorder = require('./recorder');
var fut = require('streamline/lib/util/future');
var jsx509 = require('jsx509');
var crypto = require('crypto');
var certTools = require('./certTools');

var tracer = null;
// var tracer = console.log;

//requests which are not in a session, are counted here. They will be regarded for load balancing in addition to the
//sessions according to the session table
var currentNewRequests = {};

// redirects should be returned to the same server
var redirects = {};

//http servers for nanny
var httpServers = [];

//certificates for internal purpose
var ownCertificate = null;
//Diffie Hellman object (only initialized when there are certificates available)
var diffieHellman;
var caHash = null;
//list of certificates (from DB and from files)
var certificates;
var caCertificates;

//local directory with certificates
var certDirectory;
// local host name in lowercase
var lcHostName = os.hostname().toLowerCase();

var config;
var db = null; // Database handle
//file for version information at customer's site (redundant name - also in syracuse-patch/lib/patchtools._js)
var VERSION_FILE = "version.json";
//special header for transporting client authorization information during load balancing
var SSL_HEADER = "syracusesslheader"; // special Http header for passing load balancing information (not used in this file)  

// wait time between starting Syracuse instances
var STARTUP_WAIT_TIME = 100;

//maximal allowed time difference between servers in milliseconds
var TIME_THRESHOLD = 600000;
//maximal number of requests between database time checks (will be multiplied with number of hosts)
var REQUEST_THRESHOLD = 1000;
//time in milliseconds for a child process to wait after it has started
var PING_TIMEOUT = 100000;
//polling interval for looking into database during stopping sessions
var POLL_INTERVAL = 3000;
//time which will remain to stop sessions
var POLL_TIME = 60000;

//status values: >= 0: notify for database updates, >= STATUS_INIT: child processes are possible; === STATUS_READY: notify for normal requests; <0: host cannot be used because of errors
//this list must fit to the status property of the host entity
var STATUS_INACTIVE = 0; // nanny inactive
var STATUS_INIT = 1; // initial status
var STATUS_START = 2; // starting child processes
var STATUS_READY = 3; // ready OK
var STATUS_FINISHING = 4; // server will stop soon
var STATUS_LOW_VERSION = -1; // host has low version compared to database entries
var STATUS_WRONG_VERSION = -2; // host has wrong version in cluster
var STATUS_TIME_DIFFERENCE = -3; // host deactivated because of time difference
var STATUS_RESPAWN = -4; // respawn limit of child processes exceeded
var STATUS_FOREIGN = -5; // initial status for foreign server
var STATUS_NOT_REACHABLE = -6; // timeout when reaching server 
var STATUS_NOT_STARTED = -7; // server has not been started

//time and number of requests since last database time comparison, diff: is the database time minus the local time
//(this means that an approximation for database time can be obtained by Date.now()+diff)
var databaseTime = {
	time: 0,
	requests: 0,
	diff: 0,
	getTime: function(_, check) {
		var now = Date.now();
		if (now < this.time || now - this.time > TIME_THRESHOLD || ++this.requests > REQUEST_THRESHOLD * hosts.length) {
			// avoid multiple database queries because of race conditions
			this.time = now;
			this.requests = 0;
			// get time from database
			var dbTime = dbDriver.time(db, _);
			this.diff = dbTime - now;
			tracer && tracer("database time check--" + dbTime + " difference " + this.diff);
		}
		if (check && (this.diff > TIME_THRESHOLD || -this.diff > TIME_THRESHOLD)) {
			throw new Error(locale.format(module, "timeDiff"));
		}
		return now + this.diff;
	},
	getReducedTime: function(_) {
		return Math.floor(this.getTime(_) / 180000);
	}
};

//list of sessions known to this balancer
var sessions = {}; // keys are Syracuse session ID's, values are corresponding server names and ports (as an array)
var hosts = []; // list of different Syracuse hosts, with attributes from host entity and the following extra attributes:
//version: Syracuse version (system is only usable when all versions are equal)
//status: see STATUS_... constants above
//missingCert, missingCA: missing certificate data (contains the logical names of the instances of the (CA) certificate entity
//for which there are no files or corrupt files in the file system
var hostsByName = {};
var localHost = null; // local host within hosts array
hosts.mainVersion = ""; // main version of the cluster (will be set upon first response of another server or when no server responds)
var children = []; // child processes ("N"+ind will be logical port of child with index 'ind')

function _copyFluentData(target, source) {
	target.version = source.version;
	target.status = source.status;
	target.missingCert = source.missingCert;
	target.missingCA = source.missingCA;
	target.untrusted = source.untrusted;
}

//stringifies information for host array. Only stringifies the non-database fields and the hostname

function _stringifyHosts(h) {
	return JSON.stringify(h.map(function(host) {
		return _minifyHost(host);
	}));
}

function _minifyHost(h, extra) {
	var result = {
		hostname: h.hostname,
		extra: extra
	};
	_copyFluentData(result, h);
	tracer && tracer("Minify host " + util.format(result));
	return result;
}

//fills in SSL options

function sslOptions(connectionData, options) {
	if (connectionData.ssl) {
		options.ca = getCaCertificates(connectionData.serverCert);
		if (connectionData.clientAuth) {
			options.cert = connectionData.clientCert.certificate;
			options.key = connectionData.clientCert.key;
			options.passphrase = connectionData.clientCert.pass;
			options.agent = false;
		}
		// console.log("OPTIONS "+util.format(options))
		tracer && tracer("Client https");
		return https;
	} else {
		tracer && tracer("Client http");
		return http;
	}

}

//taken from patchtools._js
//relNumberCmp: comparison of release numbers
//split release numbers in parts with dots as delimiters and numerically compare the parts
//result is negative, 0, positive if first release number is smaller, equal, bigger than second
//here also patch number will be considered (separator: '-')

function relNumberCmp(rel1, rel2) {
	var parts1 = rel1.split(/[\.\-]+/);
	var parts2 = rel2.split(/[\.\-]+/);
	var bound = Math.min(parts1.length, parts2.length);
	var i;
	for (i = 0; i < bound; i++) {
		var diff = parts1[i] - parts2[i];
		if (diff !== 0) return diff;
	}
	return parts1.length - parts2.length;
}

function startServer(_) {
	var sessionCollection = dbDriver.createCollection(db, 'SessionInfo', _);
	var i;
	var listenerFunc = function(request, response) {
		return requestListener(request, response, /*sessionCollection,*/ _ >> function(error, data) {
			if (error) {
				console.error("Error " + util.format(error) + (error.stack ? " stack " + error.stack : ""));
			}
		});
	};
	for (i = 0; i < localHost.connectionData.length; i++) {
		var connectionData = localHost.connectionData[i];
		if (!httpServers[i] && connectionData.active) {
			var listener = listenerFunc;
			if (connectionData.ssl) {
				var cert = connectionData.serverCert;
				if (cert && cert.key && cert.certificate) {
					var ca = getCaCertificates(cert);
					var options = {
						key: cert.key,
						cert: cert.certificate,
						passphrase: cert.pass,
						ca: ca,
						requestCert: connectionData.clientAuth,
						rejectUnauthorized: connectionData.clientAuth
					};
					tracer && tracer("SSL options " + util.format(options));
					httpServers[i] = https.createServer(options, listener);
					console.log("SSL Server running at " + connectionData.port);
				} else {
					console.error("Not enough certificate information to start SSL connection on port " + connectionData.port);
					continue;
				}
			} else {
				httpServers[i] = http.createServer(listener);
				console.log("Server running at " + connectionData.port);
			}
			httpServers[i].listen(connectionData.port);
		}
	}
}

function getCaCertificates(cert) {
	if (cert && !cert.name && ownCertificate) { // internal certificate of other server is deliberately not available (see addCertificateData): set CA certificate of local server
		cert = ownCertificate;
	}
	var cacerts = cert.caCertificates;
	var ca;
	if (cacerts && cacerts.length) {
		ca = cacerts.map(function(caCert) {
			if (caCert) {
				return caCert.certificate;
			} else {
				return null;
			}
		});
	}
	return ca;
}

function killChildren() {
	if (children.length > 0) {
		tracer && tracer("Kill child processes");
		children.forEach(function(child) {
			child.terminate = true;
			if (child) {
				child.kill();
			}
		});
		children.length = 0;
	}
}

process.on('exit', function() {
	dbDriver.close(db);
	killChildren();
});

//send a http request to a host. 
//host: in hosts array 
//command: command to send
//return: data of response.

function get(hostdata, method, path, data, _, timeout) {
	var address;
	if (hostdata.local) {
		address = "localhost";
	} else {
		address = hostdata.hostname;
		if (hostdata.tcpHostName) {
			address = hostdata.tcpHostName;
		}
	}
	var options = {
		method: method || 'GET',
		hostname: address,
		port: hostdata.connectionData[0].port,
		path: path,
		timeout: timeout
	};
	try {
		var foundHost = hostsByName[hostdata.hostname]; // set pending request (always get foundHost from hostsByName - there may have been an update request which
		// has updated the hosts array
		if (foundHost) {
			foundHost.pendingRequest = true;
		}
		var client = sslOptions(hostdata.connectionData[0], options);
		var result = mock.simpleRequest(client, options, data, _);
		foundHost = hostsByName[hostdata.hostname];
		if (foundHost) {
			foundHost.pendingRequest = false;
		}
		return result;
	} catch (e) {
		if (!e.STATUS_CODE || e.STATUS_CODE >= 500) {
			var foundHost = hostsByName[hostdata.hostname];
			if (foundHost && foundHost.pendingRequest) { // maybe the other host has sent a start signal inbetween (and therefore set 'pendingRequest' to false).
				// in this case the timeout should not make the server unreachable.
				foundHost.pendingRequest = false;
				foundHost.status = STATUS_NOT_REACHABLE;
				_markTrusted(foundHost, true); // unreachable host cannot be untrusted
				console.log("not reachable " + hostdata.hostname);
			}
		}
		console.error("GET ERROR " + hostdata.hostname + " " + e);
		throw e;
	}
}

// mark a host as untrusted or trusted. Return code: has this resulted in changes?

function _markTrusted(host, trusted) {
	tracer && tracer("MARK TRUSTED " + host.hostname + " " + trusted);
	if (!localHost.untrusted) return false;
	var index = localHost.untrusted.indexOf(host.hostname);
	if (!trusted) {
		if (index < 0) {
			localHost.untrusted.push(host.hostname);
			return true;
		}
	} else {
		if (index >= 0) {
			localHost.untrusted.splice(index, 1);
			return true;
		}
	}
	return false;
}

//update certificate data

function _fillData(certInstance, certObject) {
	var changed = false;
	var value = certObject.issuer;
	if (!certTools.deepEqual(certInstance.issuer, value)) {
		certInstance.issuer = value;
		changed = true;
	}
	value = certObject.subject;
	if (!certTools.deepEqual(certInstance.subject, value)) {
		certInstance.subject = value;
		changed = true;
	}
	value = new Date(certObject.notBefore).toISOString();
	if (certInstance.notBefore !== value) {
		certInstance.notBefore = value;
		changed = true;
	}
	value = new Date(certObject.notAfter).toISOString();
	if (certInstance.notAfter !== value) {
		certInstance.notAfter = value;
		changed = true;
	}
	return changed;
}

/// main function

function start(conf, _) {
	switch (process.argv[2]) {
		case "?":
		case "help":
		case "--help":
			console.log("Valid commands: ");
			console.log("node nanny install <Port> <Number> [license file]\n  Install process with port <Port> for nanny process, <Number> child processes.\n  The optional license file argument allows to include a license file into database");
			console.log("node nanny\n (or: node nanny run) start nanny process");
			console.log("node nanny stop\n  ask running nanny process to stop");
			console.log("node nanny remove\n  Remove data for host process");
			console.log("node nanny help\n  This help text");
			return 0;
	}
	config = conf;
	config.servername = os.hostname();
	config.collaboration = config.collaboration || {};
	if (config.collaboration.startupWaitTime) {
		STARTUP_WAIT_TIME = config.collaboration.startupWaitTime;
	}
	console.log("Server name " + config.servername);
	// Establish connection to db
	db = dbDriver.open(config.collaboration, _);
	try {
		var hostsCollection = dbDriver.createCollection(db, 'Host', _);
		if (process.argv[2] === "adjust") {
			// disable database check for version (after manual patching)
			try {
				dbDriver.updateAll(hostsCollection, {}, {
					patchStatus: "0"
				}, _);
				return 0;
			} finally {
				dbDriver.close(db);
			}
		}
		if (process.argv[2] === "install") {
			try {
				var tcpHostName = "";
				if (process.argv.length < 5) {
					throw new Error("Usage node nanny install <Port> <Number of child processes>");
					//return 1;
				}
				if (process.argv[3].substr(0, 3) === "-d=") {
					tcpHostName = process.argv[3].substr(3);
					tcpHostName = tcpHostName.replace(/^["']/, "").replace(/["']$/, "");
					process.argv.splice(2, 1);
				}
				if (!/^\d+$/.test(process.argv[3])) throw new Error(locale.format(module, "invalidPort", process.argv[3]));
				if (!/^\d\d?$/.test(process.argv[4])) throw new Error(locale.format(module, "invalidChildCount", process.argv[4]));
				var port = 1 * process.argv[3];
				var childCount = 1 * process.argv[4];
				var localHosts = dbDriver.find(hostsCollection, {
					hostname: config.servername
				}, _);
				if (localHosts.length > 0) {
					throw new Error(locale.format(module, "alreadyInstalled"));
				} else {
					// new host
					var hostId = uuid.generate();
					var newHost = {
						_id: hostId,
						hostname: config.servername,
						connectionData: [{
							port: port,
							active: true,
							ssl: false,
							clientAuth: false,
							serverCert: null,
							clientCert: null,
							host: {
								_uuid: hostId
							},
							_uuid: uuid.generate()
						}],
						children: childCount,
						_creUser: "setup",
						_updUser: "setup",
						_updDate: new Date(),
						deactivated: false,
						started: false,
						respawnCount: 10,
						respawnTime: 120,
						returnRequestTimeout: 30,
						tcpHostName: tcpHostName
					};
					dbDriver.insert(hostsCollection, newHost, _);
					console.log("Host inserted " + config.servername);
				}
				if (process.argv[5]) { // optional license file
					var content = fs.readFile(process.argv[5], "utf8", _);
					// the following code comes from syracuse-license/lib/check._js
					// remove beginning and end
					content = content.replace(/^[^\{\}]*\{/, "").replace(/\}[^\{\}]*$/, "");
					// split into parts and add curly braces (AND add text attribute)
					var parts = content.split(/\}[^\{\},]*[\n\r][^\{\},]*\{/).map(function(part) {
						return {
							text: "{" + part + "}"
						};
					});
					var licenseCollection = dbDriver.createCollection(db, "license", _);
					dbDriver.insert(licenseCollection, parts, _);
				}
				return 0;
			} finally {
				dbDriver.close(db);
			}
		}
		//	updateHostData is not interesting for install
		updateHostData(false, _, true);
		var result;
		switch (process.argv[2]) {
			case "run":
			case undefined:
				// read version file
				if (!localHost) {
					dbDriver.close(db);
					throw new Error("Service has not been installed");
				}
				try {
					var ver = JSON.parse(fs.readFile(VERSION_FILE, _));
					localHost.version = ver.relNumber + "-" + ver.patchNumber;
				} catch (e) {
					console.log("Error in version file " + e);
					localHost.version = "-";
				}
				// read certificate data
				// find out whether there is newer server
				if (!process.argv[2]) {
					hosts.forEach(function(host) {
						var parts = (host.patchStatus || "0").split(";");
						if (host.hostname !== localHost.hostname && !host.deactivated && relNumberCmp(parts[0], localHost.version) > 0) {
							// current version is not newest version
							console.log("The host " + host.hostname + " has newer version " + parts[0] + " according to database");
							localHost.status = STATUS_LOW_VERSION;
						}
					});
				} else {
					console.log("Avoid version test against database");
				}
				var tcpName;
				if (config.collaboration.certdir) {
					tcpName = _loadCertificates(_);
				}

				console.log("Start nanny with code version " + localHost.version);
				var update = {
					started: true,
					pid: process.pid
				};
				if (tcpName) {
					update.tcpHostName = tcpName;
				}
				dbDriver.update(hostsCollection, {
					hostname: config.servername
				}, update, _);
				startServer(_);
				// send signal (without waiting) to all active servers that this server is started.
				// also send version number so that versions can be compared
				firstStartSignal(!_);
				break;
			case "stop":
				dbDriver.update(hostsCollection, {
					hostname: config.servername
				}, {
					started: false
				}, _);
				dbDriver.close(db);
				try {
					result = get(localHost, "PUT", "/nannyCommand/stop", null, _);
					console.log("Stopped " + result);
				} catch (e) {
					console.log("Could not stop nanny (PID " + localHost.pid + "), error " + e);
					// TODO: when unauthorized connection via HTTPS with missing client certificates, do not give up but send SIGINT, wait 2 seconds,
					//  try again connection, when the same error occurs, send SIGTERM
				}
				return 0;
			case "patch":
				var action = "batch";
				if (process.argv[3] === "--unlock") {
					action = "unlock";
				} else {
					// patch integration in batch mode
					if (!process.argv[3]) {
						console.error("No patch file given");
						return 1;
					}
					if (!fs.exists(process.argv[3])) {
						console.error("Patch file " + process.argv[3] + " does not exist");
						return 1;
					}
				}
				dbDriver.close(db);
				try {
					result = get(localHost, "PUT", "/nannyCommand/notifyOne/patchIntegration/" + action, process.argv[3], _);
					var lines = result.split(/[\r\n]+/);
					lines.forEach(function(line) {
						if (line.charAt(0) === '{') {
							var childData = JSON.parse(line);
							var message = childData.message;
							if (!message) throw new Error("No message in " + result);
							var index = message.indexOf(";");
							if (index >= 0) {
								console.log(message.substr(index + 1));
								process.exit(message.substr(0, index) * 1);
							} else {
								console.log(message);
								process.exit(0);
							}
						}
					});
					throw new Error("No answer in " + result);
				} catch (e) {
					console.log("Error in patch integration " + e);
					return 1;
				}
				return 0;
			case "passphrase":
				if (!config.collaboration.certdir) {
					console.error("No certificate directory");
					return 1;
				}
				try {
					certDirectory = config.collaboration.certdir + "/" + lcHostName + "/";
					var passphrases = {};
					try {
						passphrases = certTools.readPassphrases(certDirectory, _, true);
					} catch (e) {
						if (process.argv[3]) {
							console.log("No passphrase file yet");
						} else {
							if (e.code === 'ENOENT') console.error(locale.format(module, "noExPhrases"));
							else console.error(locale.format(module, "noPhrases", e));
							return 1;
						}
					}
					// CA certificate
					var caCert = checkFileCertificates(_, null, true);
					// normal certificate
					checkFileCertificates(_, null, false, passphrases, process.argv[3], [caCert.certificate]);
					if (!process.argv[3]) {
						console.log("Integrity check of local certificate OK");
						return 0;
					}
					passphrases[lcHostName] = process.argv[3];
					try {
						passphrases = certTools.writePassphrases(certDirectory, passphrases, _);
						console.log("Passphrase written successfully");
					} catch (e) {
						console.log("Exception when writing keys" + e);
					}
					// notify nanny process
					try {
						result = get(localHost, "PUT", "/nannyCommand/reloadCertificates", null, _);
						console.log("Certificates reloaded " + result);
					} catch (e) {
						console.log("Could not contact nanny " + e + " " + e.stack + " " + e.trace);
					}
					return 0;
				} catch (e) {
					console.error("Exception in certificate " + e);
					return 1;
				} finally {
					dbDriver.close(db);
				}
				break;
			case "remove":
				try {
					dbDriver.remove(hostsCollection, {
						hostname: config.servername
					}, _);
					var certificateCollection = dbDriver.createCollection(db, 'Certificate', _);
					dbDriver.remove(certificateCollection, {
						name: config.servername.toLowerCase()
					}, _);
				} finally {
					dbDriver.close(db);
				}
				console.log("Host removed");
				break;
			default:
				throw new Error("Wrong commmand line argument " + process.argv[2] + ". Type node nanny help to get a list of all commands");

		}
		return 1;
	} catch (e) {
		// close DB connection so that node can stop
		dbDriver.close(db);
		throw e;
	}
}

// this function takes a real callback, therefore streamline must be notified about this
exports.startCb = function(conf, cb) {
	return start(conf, _ >> cb);
};


//loads the certificates from the file system and returns the TCP hostname

function _loadCertificates(_) {
	var tcpName; // TCP hostname from own certificate (result)
	var passphrases = {};
	var lcHostName = os.hostname().toLowerCase();
	localHost.missingCert = [];
	localHost.missingCA = [];
	localHost.untrusted = [];
	ownCertificate = undefined;
	certDirectory = config.collaboration.certdir + "/" + lcHostName + "/";
	console.log("Certificate directory " + certDirectory);
	var files = fs.readdir(certDirectory, _);
	try {
		passphrases = certTools.readPassphrases(certDirectory, _);
	} catch (e) {
		console.log("Exception when reading keys" + e);
	}
	var ownCaCertificate, newCertificate;
	var certificateCollection = dbDriver.createCollection(db, 'Certificate', _);
	certificates = dbDriver.find(certificateCollection, null, _);
	var caCertificateCollection = dbDriver.createCollection(db, 'CaCertificate', _);
	caCertificates = dbDriver.find(caCertificateCollection, null, _);
	// check CA certificates
	// is there the internal CA certificate available?
	if (!caCertificates.some(function(certificate) {
		return (certificate.name.toLowerCase() === "ca");
	})) {
		console.log("Insert entry for CA cert");
		// no special instance available: generate it
		newCertificate = {
			_id: uuid.generate(),
			name: "ca",
			internal: true,
			_creUser: "setup",
			_updUser: "setup",
			_updDate: new Date()
		};
		dbDriver.insert(caCertificateCollection, newCertificate, _);
		caCertificates = dbDriver.find(caCertificateCollection, null, _);
	}
	var checked;
	caCertificates.forEach_(_, function(_, certificate) {
		var lcName = certificate.name.toLowerCase();
		if (lcName === "ca") {
			if (!certificate.internal) {
				console.error("CA Certificate " + lcName + " already exists as a user-defined certificate");
				return;
			}
		}
		certificate.certificate = null;
		try {
			checked = checkFileCertificates(_, certificate, true, null, null, null, files);
		} catch (e) {
			console.error("Error in CA certificate " + lcName + ": " + e);
			localHost.missingCA.push(lcName);
			return;
		}
		certificate.certificate = checked.certificate;
		if (certificate.internal) {
			ownCaCertificate = certificate;
			// fill data (issuer, dates)
			if (_fillData(certificate, checked.cert)) {
				dbDriver.update(caCertificateCollection, {
					name: "ca"
				}, {
					issuer: checked.cert.issuer,
					subject: checked.cert.subject,
					notBefore: certificate.notBefore,
					notAfter: certificate.notAfter
				}, _);
			}
			// console.log("JJJJ"+util.format(certificate))
			var hash = crypto.createHash("SHA256");
			hash.update(checked.cert.publicKey);
			caHash = new Buffer(hash.digest("binary").substr(0, 32), "binary");
		}
	});
	if (ownCaCertificate) {
		// maybe generate special instance
		if (!certificates.some(function(certificate) {
			return (certificate.name.toLowerCase() === lcHostName);
		})) {
			tracer && tracer("Create database entry for certificate");
			// no special instance available
			newCertificate = {
				_id: uuid.generate(),
				name: lcHostName,
				internal: true,
				keyExists: true,
				caCertificates: [dbDriver.setRelatedInstance(ownCaCertificate)],
				_creUser: "setup",
				_updUser: "setup",
				_updDate: new Date(),
				server: dbDriver.setRelatedInstance(localHost)
			};
			dbDriver.insert(certificateCollection, newCertificate, _);
			certificates = dbDriver.find(certificateCollection, null, _);
		}
		var i;
		// real loop because of 'splice' statement
		for (i = certificates.length - 1; i >= 0; i--) {
			var certificate = certificates[i];
			var lcName = certificate.name.toLowerCase();
			certificate.server = dbDriver.findInstance(certificate.server, hosts);
			certificate.certificate = null;
			certificate.key = null;
			// ignore server certificates of other servers
			if (certificate.server && certificate.server.hostname && certificate.server.hostname !== localHost.hostname) {
				certificates.splice(i, 1); // delete this instance
				continue;
			}
			//
			if (lcName === lcHostName && !certificate.internal) {
				console.error("Certificate " + lcName + " already exists as a user-defined certificate");
				continue;
			}
			var cas = certificate.caCertificates;
			if (certificate.internal && (!cas || !cas.length)) {
				tracer && tracer("Add user defined CA certificate");
				cas = certificate.caCertificates = [dbDriver.setRelatedInstance(ownCaCertificate)];
				dbDriver.update(certificateCollection, {
					name: certificate.name
				}, {
					caCertificates: cas
				}, _);
			}
			var j;
			if (cas) {
				for (j = cas.length - 1; j >= 0; j--) {
					cas[j] = dbDriver.findInstance(cas[j], caCertificates);
				}
			}
			try {
				checked = checkFileCertificates(_, certificate, false, passphrases, null, cas, files);
			} catch (e) {
				console.error("Error in certificate " + certificate.name + ": " + e);
				localHost.missingCert.push(lcName);
				continue;
			}
			certificate.certificate = checked.certificate;
			certificate.key = checked.key;
			if (certificate.internal) {
				ownCertificate = certificate;
				tcpName = checked.cert.subject.commonName;
				if (_fillData(certificate, checked.cert)) {
					dbDriver.update(certificateCollection, {
						name: lcHostName
					}, {
						issuer: checked.cert.issuer,
						subject: checked.cert.subject,
						notBefore: certificate.notBefore,
						notAfter: certificate.notAfter
					}, _);
				}
			}
		}
	}
	if (ownCertificate) {
		// delete remaining files
		files.forEach_(_, function(_, f) {
			if (/^[a-z0-9_\.]+\.(?:crt|cacrt|key)$/.test(f)) {
				try {
					fs.unlink(certDirectory + f);
					console.log("Delete " + f);
				} catch (e) {
					console.error("Error when deleting " + f + ": " + e);
				}
			}
		});
		// console.log("REMAINING "+util.format(files))
		diffieHellman = crypto.getDiffieHellman('modp14');
		diffieHellman.generateKeys();
		// add certificate data to connections
		addCertificateData(hosts);
	} else {
		localHost.untrusted.push(localHost.hostname);
	}
	return tcpName;
}

//send start signal to all nannies on active servers. This signal tells the other servers that this server has been started and tells about
//code version of this server. The response tells this server about the code version of the other servers. When the versions differ,  

function startSignal(host, _, first) {
	if (host.local || host.status <= STATUS_NOT_REACHABLE || (!first && host.status <= STATUS_FOREIGN)) return;
	tracer && tracer("Host with start signal " + util.format(_minifyHost(host)));
	var challenge;
	var extra; // will be not empty for first invocation - either containing certificate information or being empty object
	// for subsequent i
	// include certificate information
	if (first) {
		if (ownCertificate) {
			var time = databaseTime.getReducedTime(_);
			var ownChallenge = host.hostname + " " + time;
			challenge = uuid.generate();
			host.challenge = challenge;
			var signature = _signText(ownChallenge);
			extra = {
				time: time,
				sign: signature,
				challenge: challenge,
				cert: ownCertificate.certificate,
				dh: diffieHellman.getPublicKey('base64')
			};
			// encrypt it
			extra = _securePack(JSON.stringify(extra));
			_markTrusted(host, false); // mark host as untrusted first
		} else {
			// when own host is not trusted, do not mark other hosts as untrusted
			host.certificate = host.dhKey = undefined;
			extra = {};
		}
	}
	var data = get(host, "POST", "/nannyCommand/started", JSON.stringify(_minifyHost(localHost, extra)), _);
	tracer && tracer("Start signal sent");
	// check versions
	var infos = JSON.parse(data);
	// console.log("INFOS "+data)
	_copyFluentData(host, infos);
	if (host.status < STATUS_INIT) {
		_markTrusted(host, true); // when host cannot be used, mark it as trustworthy
	}
	if (!hosts.mainVersion) {
		hosts.mainVersion = infos.extra;
		checkVersions(_);
	}
}

//send a start signal to all started nannies. This will also detect unreachable nannies.

function firstStartSignal(_) {
	var futures = [];
	hosts.forEach(function(host) {
		if (!host.local && host.started) {
			var signal = startSignal(host, !_, true);
			if (!host.deactivated) futures.push(signal); // do not wait for answers of inactive servers!
		}
	});
	var i = futures.length;
	while (--i >= 0) {
		try {
			futures[i](_);
		} catch (e) {
			console.log("Error connecting host " + e + " " + e.stack);
		}
	}
	// maybe no host could be contacted
	checkVersions(_);
}

// check version with foreign host and start child processes if version matches; set new status

function checkVersions(_) {
	console.log("CHECK " + localHost.status + " " + hosts.mainVersion);
	if (localHost.status !== STATUS_INIT) return;
	var commonVersion;
	if (hosts.mainVersion) {
		if (hosts.mainVersion === localHost.version) {
			commonVersion = hosts.mainVersion;
		}
	} else { // no main version yet: test for common version
		commonVersion = localHost.version;
		hosts.forEach(function(host) {
			// only active hosts
			if (host.status > 0 && !host.local) {
				if (commonVersion && commonVersion !== host.version) {
					commonVersion = null;
				}
			}
		});
		if (commonVersion) {
			hosts.mainVersion = commonVersion;
		}
	}
	if (commonVersion) {
		startChildProcesses(true, _);
	} else {
		localHost.status = STATUS_WRONG_VERSION;
	}
}

function startChildProcesses(force, _) {
	if (localHost.status > STATUS_INIT || force) {
		// new number of children
		var newChildCount = (localHost.status >= STATUS_INIT) ? localHost.children : 0;
		// current number of children
		var oldChildCount = children.length;
		tracer && tracer("Start child processes " + oldChildCount + " " + newChildCount);
		if (oldChildCount === 0 && newChildCount > 1) {
			// first start one process, then other processes
			console.log("First process");
			createProcess(undefined, 0);
			children[0].mockClient.ping(_, PING_TIMEOUT);
			oldChildCount = 1;
			console.log("First process started");
		}
		var i;
		var init = true;
		for (i = newChildCount - 1; i >= oldChildCount; i--) {
			if (init) {
				init = false;
			} else {
				wait(STARTUP_WAIT_TIME, _);
			}
			createProcess(undefined, i);
		}
		while (children.length > newChildCount) {
			tracer && tracer("Kill child process" + children.length);
			var child = children.pop();
			child.terminate = true;
			child.kill();
		}
		if (newChildCount > 0 && localHost.status < STATUS_START) {
			localHost.status = STATUS_START;
		}
		if (localHost.status === STATUS_START) {
			// send ping signal to all child processes, then mark process ready
			var futures = [];
			children.forEach(function(child) {
				futures.push(child.mockClient.ping(!_, PING_TIMEOUT));
			});
			// wait for results of child processes (collect results of futures). 
			// This function is called as a future!
			startedChildProcesses(futures);
		}
	}
}

function startedChildProcesses(futures, _) {
	var i = futures.length;
	var ok = true;
	while (--i >= 0) {
		try {
			futures[i](_);
		} catch (e) {
			ok = false;
			console.error("Error starting child process: " + e.stack);
		}
	}
	if (ok) {
		localHost.status = STATUS_READY;
		console.log("Notify other servers about successful start of child processes");
		// send start signal again (as a future, because it is not necessary to wait for the result
		hosts.forEach(function(host) {
			return startSignal(host, !_);
		});
	}
}

/// createProcess(exitCode, port)
/// creates child process listening at the given port and puts its object into the `children` instance.
/// when the process finishes, the process will be restarted unless `children.terminate` is set.

function createProcess(code, port) {
	var startTime = Date.now();
	var startCount = 0;
	var child = children[port];
	if (code === undefined) {
		console.log("Start process on port N" + port);
	} else {
		console.log("Exit code " + code + " restarting process on port N" + port);
		var respawnTime = 1000 * localHost.respawnTime;
		if (child && respawnTime && startTime - child.startTime < respawnTime) {
			startTime = child.startTime;
			startCount = (child.startCount || 0) + 1;
			if (child.startCount > localHost.respawnCount) {
				// child processes unavailable
				console.log("RESPAWN COUNT");
				localHost.status = STATUS_RESPAWN;
				// tell other servers
				hosts.forEach(function(host) {
					return startSignal(host, !_);
				});
				killChildren();
			}
		}
	}

	if (!child || !child.terminate) { // restart processes (unless terminating all processes is intended)
		child = child_process.spawn(process.argv[0], ['.', "N" + port, localHost.returnRequestTimeout], {
			stdio: ['pipe', process.stdout, process.stderr, 'pipe']
		});
		child.startTime = startTime;
		child.startCount = startCount;
		children[port] = child;
		// attach mock client to child process
		child.mockClient = new mock.Mock(child.stdin, child.stdio[3], requestListener);
		// error handler
		child.on('error', function(error) {
			console.error("Child process could not be started " + error);
			localHost.status = STATUS_RESPAWN;
			// tell other servers
			hosts.forEach(function(host) {
				return startSignal(host, !_);
			});
			killChildren();
		});
		// exit handler for restarting process
		child.on('exit', function(code) {
			if (child.terminate) {
				console.log("Stop child");
			} else {
				return createProcess(code, port);
			}
		});
	}
}

//returns an array of all status information

function statusString() {
	return hosts.map(function(host) {
		return host.status;
	}).join(',');
}

//resolve references to certificate data

function addCertificateData(hosts) {
	// add certificate information
	if (certificates) {
		hosts.forEach(function(host) {
			host.connectionData.forEach(function(conn) {
				if (host.hostname === localHost.hostname) { // add only server certificates of localhost. This is deliberate (cf. getCaCertificates)
					conn.serverCert = dbDriver.findInstance(conn.serverCert, certificates);
				}
				conn.clientCert = dbDriver.findInstance(conn.clientCert, certificates);
			});
		});
	}
}

//read configuration data of hosts from database and update local configuration.
//startChildren: 

function updateHostData(startChildren, _, init) {
	var hostsCollection = dbDriver.createCollection(db, 'Host', _);
	var newHosts = dbDriver.find(hostsCollection, null, _);
	// add the references to certificates
	if (!init) {
		addCertificateData(newHosts);
	}
	hosts = _updateHosts(hosts, newHosts, config.servername);
	if (!localHost) { // data for local host not available
		console.error("No data for local nanny");
		process.exit(2);
	}
	if (localHost.stop) { // data for local host have changed
		console.log("Connection data changed - restart nanny");
		shutdown(!_, undefined, true, true);
	} else {
		startChildProcesses(startChildren, !_);
	}
}

function _updateHosts(oldHosts, hosts, name) {
	// sort host data by hostname
	hosts = hosts.sort(function(host1, host2) {
		var h1 = host1.hostname;
		var h2 = host2.hostname;
		return (h1 > h2 ? 1 : (h1 < h2 ? -1 : 0));
	});
	var i = hosts.length;
	localHost = null;
	hostsByName = {};
	LOOP: while (--i >= 0) {
		var host = hosts[i];
		// Is first connection of every host existent and active? 
		if (!host.connectionData || !host.connectionData.length || host.connectionData[0].deactivated) {
			throw new Error(locale.format(module, "errorConnectionData", host.hostname));
		}
		hostsByName[host.hostname] = host;
		if (host.hostname === name) {
			host.local = true;
			localHost = host;
		}
		var j = oldHosts.length;
		while (--j >= 0) {
			var oldHost = oldHosts[j];
			if (!oldHost) continue;
			if (oldHost.hostname === host.hostname) {
				_copyFluentData(host, oldHost);
				host.certificate = oldHost.certificate;
				host.challenge = oldHost.challenge;
				host.dhKey = oldHost.dhKey;
				host.pendingRequest = oldHost.pendingRequest;
				if (oldHost.hostname === name) {
					// have connection data of local host changed?
					var oldConnections = oldHost.connectionData;
					var connections = host.connectionData;
					var k;
					for (k = 0; k < oldConnections.length; k++) {
						var oldConn = oldConnections[k];
						if (oldConn.active && (!certTools.deepEqual(oldConn, connections[k]))) {
							localHost.stop = true;
							break;
						}
					}
				}
			}
		}
		// explicitly set certain status values
		if (host.deactivated && host.status > STATUS_INACTIVE) host.status = STATUS_INACTIVE;
		if (!host.local && !host.started) host.status = STATUS_NOT_STARTED;
		if (host.status === undefined || host.started && host.status === STATUS_NOT_STARTED || !host.deactivated && host.status === STATUS_INACTIVE) {
			// initialize status: a foreign host is not reachable unless it is known to be reachable
			host.status = (host.local ? (!host.deactivated ? STATUS_INIT : STATUS_INACTIVE) : STATUS_FOREIGN);
		}
	}
	hosts.mainVersion = oldHosts.mainVersion || "";
	return hosts;
}

function requestListener(request, response, _) {
	try {
		return requestListener0(request, response, _);
	} catch (e) {
		writeError(response, (e instanceof Error ? e.message : "" + e));
		if (e instanceof Error) {
			console.log("TRACE " + e.trace + " " + e.stack);
		}
	}
}

function requestListener0(request, response, _) {
	tracer && tracer(">> " + request.url);
	var sessionCollection;
	request.pause();
	// exchange headers
	var headers = {};
	Object.keys(request.headers).forEach(function(head) {
		headers[head] = request.headers[head];
	});
	request.headers = headers;
	var streamRecorder;
	var i, data, host;
	// testSessions(sessionCollection, _);
	// special commands which will not be redirected
	if (request.url.substring(0, 14) === "/nannyCommand/") {
		var command = request.url.substr(14).split('/');
		var resultText = localHost.hostname + ":\n";
		var futures = [],
			future; // invocations of other processes
		var commandType = command[0];
		var syraBalancerHeader = request.headers[mock.BALANCER_HEADER];

		switch (command[0]) {
			case 'notifyAll':
				// notify all
				request.pause();
				var clientId = syraBalancerHeader;
				streamRecorder = new recorder.StreamRecorder(request);
				// Notify other servers (without waiting)
				if (clientId) {
					delete request.headers[mock.BALANCER_HEADER];
					hosts.forEach(function(host) {
						if (!host.local && host.status === STATUS_READY) {
							tracer && tracer("Request to server " + i);
							futures.push(doRequestWithAnswer(streamRecorder, [host, null], !_));
						}
					});
				}
				request.url = request.url.replace(/^\/[^\/]+\/[^\/]+/, "");
				tracer && tracer("Local path " + request.url);

				for (i = 0; i < children.length; i++) {
					var port = "N" + i;
					if (port !== clientId) {
						tracer && tracer("Request to local app " + port);
						future = doRequestWithAnswer(streamRecorder, [localHost, port], !_);
						future.extra = {
							port: port
						};
						futures.push(future);
					}
				}
				break;
			case "notifyOtherNannies":
				// send the command (without '/notifyOtherNannies' in URL) to other nannies which have status OK and finish the request
				request.pause();
				// console.log("CLIENT ID "+clientId)
				streamRecorder = new recorder.StreamRecorder(request);
				request.url = request.url.replace(/^(\/[^\/]+)\/[^\/]+/, "$1"); // remove second part;
				tracer && tracer("Notify all running " + clientId + " " + request.url);
				// Notify other servers (without waiting)
				delete request.headers[mock.BALANCER_HEADER];
				hosts.forEach(function(host) {
					if (!host.local && host.status >= STATUS_READY) {
						tracer && tracer("Request to server " + host.hostname);
						futures.push(doRequestWithAnswer(streamRecorder, [host, null], !_));
					}
				});
				break;
			case "notifyNannies":
				// send the command (without '/notifyOtherNannies' in URL) to all nannies which have status at least inactive.
				command.shift();
				request.pause();
				// console.log("CLIENT ID "+clientId)
				streamRecorder = new recorder.StreamRecorder(request);
				request.url = request.url.replace(/^(\/[^\/]+)\/[^\/]+/, "$1"); // remove second part
				tracer && tracer("Notify all started " + request.url);
				// Notify other servers (without waiting)
				delete request.headers[mock.BALANCER_HEADER];
				hosts.forEach(function(host) {
					if (!host.local && host.status >= STATUS_INACTIVE) {
						tracer && tracer("Request to server " + host.hostname);
						var fut = doRequestWithAnswer(streamRecorder, [host, null], !_);
						fut.infoinfo = host.hostname;
						futures.push(fut);
					} else {
						futures.push(null);
					}
				});
				break;
		}
		var d, foundHost, changes;
		switch (command[0]) {
			case 'stop':
				// request to stop server
				futures = [];
				for (i = 0; i < hosts.length; i++) {
					var host = hosts[i];
					if (host && host.status >= STATUS_INACTIVE && !host.local) {
						futures[i] = get(host, "PUT", "/nannyCommand/down/" + localHost.hostname, null, !_);
					}
				}
				killChildren();
				resultText = "OK1";
				// Exceptional case here: call futures here because otherwise process.nextTick function will not allow them to be executed
				for (i = 0; i < futures.length; i++) {
					try {
						if (futures[i]) console.log("Answer from " + hosts[i].hostname + ": " + futures[i](_));
					} catch (e) {
						console.log("Exception when informing host " + hosts[i].hostname + ": " + e);
					}
				}
				futures = [];
				process.nextTick(function() {
					console.log("Exit process");
					process.exit(0);
				});
				break;
			case 'notifyOne':
				// send request only to local server with lowest number of sessions (without '/nannyCommand/notifyOne')
				sessionCollection = dbDriver.createCollection(db, 'SessionInfo', _);
				data = refreshSessions(sessionCollection, true, _); // only local host
				if (!data) {
					data = [localHost, "N0"];
					tracer && tracer("No balancer result - set process N0");
				}
				if (!streamRecorder) {
					request.url = request.url.replace(/^\/[^\/]+\/[^\/]+/, ""); // remove first two parts
					streamRecorder = new recorder.StreamRecorder(request);
				} else {
					streamRecorder.originalStream.url = streamRecorder.originalStream.url.replace(/^\/[^\/]+\/[^\/]+/, ""); // remove first two parts 
				}
				try {
					future = doRequestWithAnswer(streamRecorder, data, !_);
					future.extra = {
						port: data[1],
						hostname: localHost.hostname
					};
					futures.push(future);
				} catch (e) {
					tracer && tracer("Host not available " + data[0].hostname + " Error " + e);
				}
				break;

			case 'stopSessions':
				// read request data fully before answering request         
				if (streamRecorder) streamRecorder.loadFully(_);
				response.writeHead(200, {
					'Content-Type': 'text/plain'
				});
				response.end("OK"); // finish request
				console.log("STOP SESSIONS " + futures.length);
				// do not wait for answers of other servers
				// for (var i = 0; i<futures.length; i++) {
				//	try {					
				//		if (futures[i]) console.log(futures[i].infoinfo+" ----- "+futures[i](_));					
				//	} catch (e) {
				//		console.log("Exception when informing host "+hosts[i].hostname+": "+e+" "+e.stack+" "+e.trace);
				//	}
				// }
				// do not notify other hosts about status change
				shutdown(_, syraBalancerHeader);
				return;
			case 'update':
				updateHostData(true, _);
				// maybe start more connections
				startServer(_);
				resultText += "Host data updated";
				break;
			case 'adjust':
				var hostsCollection = dbDriver.createCollection(db, 'Host', _);
				dbDriver.updateAll(hostsCollection, {}, {
					patchStatus: "0"
				}, _);
				resultText += "Adjusted";
				break;
			case 'test':
				// test request
				resultText += "OK2";
				break;
			case 'children':
				// ping to children
				if (localHost.status >= STATUS_START) {
					for (i = children.length - 1; i >= 0; i--) {
						future = children[i].mockClient.ping(!_, 1000);
						future.extra = {
							hostname: localHost.hostname,
							port: "N" + i,
							requests: children[i].mockClient.numberRequests()
						};
						futures.push(future);
					}
				} else {
					resultText += JSON.stringify({
						hostname: localHost.hostname,
						message: "Children not yet started"
					}) + "\n";
				}
				if (commandType === "notifyNannies") { // extra information only from current host
					resultText += _stringifyHosts(hosts) + "\n";
				}
				break;
			case 'reloadCertificates':
				// reload local certificate data
				var tcpName = _loadCertificates(_);
				if (!localHost.tcpName) {
					tracer && tracer("Set tcpname " + tcpName);
					var update = {
						tcpHostName: tcpName,
					};
					var hostsCollection = dbDriver.createCollection(db, 'Host', _);
					dbDriver.update(hostsCollection, {
						hostname: config.servername
					}, update, _);
				}
				tracer && tracer("Update host data");
				updateHostData(false, _);
				firstStartSignal(_);
				break;
			case 'updateCertificate':
				// send/receive certificate information
				d = getData(streamRecorder ? streamRecorder.getStream() : request, _);
				if (!ownCertificate) {
					writeError(response, locale.format(module, "noBaseCert"));
					return;
				}
				var destination = request.headers[mock.BALANCER_HEADER];
				var sender;
				tracer && tracer("Update certificate for " + destination);
				if (destination) {
					if (destination === "*") { // send request to all servers
						delete request.headers[mock.BALANCER_HEADER];
						hosts.forEach(function(host) {
							if (!host.local && host.status >= STATUS_READY && host.dhKey) {
								tracer && tracer("Secure request to server " + host.hostname);
								futures.push(secureRequest(host, "POST", "/nannyCommand/updateCertificate", d, null, !_));
							}
						});
					} else {
						foundHost = hostsByName[destination];
						if (foundHost) {
							if (!foundHost.local) {
								if (foundHost.status >= STATUS_READY) {
									if (foundHost.dhKey) secureRequest(foundHost, "POST", "/nannyCommand/updateCertificate", d, null, _);
									else {
										writeError(response, locale.format(module, "notTrusted"));
									}
								} else {
									writeError(response, locale.format(module, "hostNotReady", destination));
									return;
								}
								d = null;
							}
						} else {
							d = null;
							writeError(response, locale.format(module, "hostNotFound", destination));
							return;
						}
					}
				} else {
					var unpacked = _secureUnpack(JSON.parse(d), _);
					d = unpacked[0];
					sender = hostsByName[unpacked[1]];
				}
				if (d) {
					changes = {};
					tracer && tracer("Request to parseRequestCert " + d);
					var answer;
					try {
						answer = certTools.parseRequestCert(_, JSON.parse(d), certificates, caCertificates, certDirectory, localHost, changes);
					} catch (e) {
						writeError(response, "" + e, 409); // conflict which can be resolved
						return;
					}
					tracer && tracer("Answer to parseRequestCert " + answer);
					var answerJson = JSON.stringify(answer);
					if (!destination) {
						response.end(JSON.stringify(_securePack(answerJson, sender)));
					}
					if (changes.restart) { // restart server
						console.log("Connection data changed - restart server");
						// notify other hosts about status change (asynchronously!)					
						shutdown(!_, undefined, true);
					} else {
						if (changes.missing && localHost.status === STATUS_READY) { // tell other hosts about changes in missing certificates
							hosts.forEach(function(host) {
								return startSignal(host, !_);
							});
						}
						if (changes.start) { // try to start connections anew
							console.log("Renew connections");
							startServer(_);
						}
					}
				}
				break;
			case 'details':
				// details information about children
				if (localHost.status === STATUS_READY) {
					for (i = children.length - 1; i >= 0; i--) {
						future = children[i].mockClient.detail(!_, 1000);
						future.extra = {
							hostname: localHost.hostname,
							port: "N" + i
						};
						futures.push(future);
					}
				} else {
					resultText += JSON.stringify({
						hostname: localHost.hostname,
						message: "Children not yet started"
					}) + "\n";
				}
				if (commandType === "notifyNannies") { // extra information only from current host
					resultText += _stringifyHosts(hosts) + "\n";
				}
				break;
			case 'info':
				// info request
				resultText += util.inspect(hosts.map(function(host) {
					var result = {};
					Object.keys(host).forEach(function(key) {
						if (key.substr(0, 1) !== "_") {
							if ((key === "dhKey" || key === "certificate") && host[key]) {
								result[key] = "***";
							} else {
								result[key] = host[key];
							}
						}
					});
					return result;
				}), {
					depth: 3
				});
				var childResults = [];
				for (i = 0; i < children.length; i++) {
					childResults.push("N" + i + ": " + children[i].mockClient.numberRequests());
				}
				resultText += "\n" + childResults.join(", ");
				break;
			case 'infojson':
				// info request
				resultText = _stringifyHosts(hosts);
				break;
			case 'started':
				// nanny has started
				try {
					d = getData(streamRecorder ? streamRecorder.getStream() : request, _);
					var hostData = JSON.parse(d);
					foundHost = null;
					for (var attempt = 0; attempt < 2; attempt++) {
						foundHost = hostsByName[hostData.hostname];
						if (foundHost && !foundHost.local) {
							_copyFluentData(foundHost, hostData);
							foundHost.started = true;
							foundHost.pendingRequest = false; // maybe there is a get() request pending which will result in a timeout. It should not mark the host as unavailable.
							tracer && tracer("Host started " + foundHost.hostname);
							break;
						}
						console.log("Host found " + foundHost);
						if (!foundHost) updateHostData(false, _);
					}
					if (!foundHost) {
						response.end(JSON.stringify(_minifyHost(localHost)));
						return;
					}
					checkVersions(_);
					// maybe update status of other host
					// console.log("HOST2 "+util.format(foundHost))
					if (foundHost && hosts.mainVersion !== foundHost.version) foundHost.status = STATUS_WRONG_VERSION;
					var returnValue = JSON.stringify(_minifyHost(localHost, hosts.mainVersion));
					tracer && tracer("return value on start request " + util.format(returnValue));
					response.end(returnValue); // send back local code version and main version
					var untrustedChange = false;
					// check security information				
					if (foundHost.status >= STATUS_INIT && hostData.extra) { // first invocation: important for security information
						var security = _checkFirstData(null, hostData.extra, foundHost, _);
						if (security && foundHost) {
							foundHost = hostsByName[foundHost.hostname]; // maybe foundHost instance has changed during _checkFirstData
							var certs = [];
							if (_markTrusted(foundHost, true)) // host has passed checks and is trustworthy
								untrustedChange = true;
							certTools.pushMissing(foundHost, certs);
							tracer && tracer("Missing foreign certificates " + util.format(certs));
							certs = certTools.parseRequestCert(_, certs, certificates, caCertificates, certDirectory, foundHost);
							tracer && tracer("Answer " + util.format(certs));
							// add missing own certificates
							certTools.pushMissing(localHost, certs);
							tracer && tracer("Answer2 " + util.format(certs));
							// encode data
							security = _securePack(JSON.stringify(security));
							data = secureRequest(foundHost, "POST", "/nannyCommand/updateCertificate", JSON.stringify(certs), security, _);
							tracer && tracer("Answer3 " + util.format(data));
							var parsed = JSON.parse(data);
							changes = {};
							certs = certTools.parseRequestCert(_, parsed, certificates, caCertificates, certDirectory, localHost, changes);
							if (changes.restart) { // restart server
								console.log("Connection data changed - restart server");
								setTimeout(function() {
									process.exit(10);
								}, 1000);
							} else {
								if (changes.missing && localHost.status === STATUS_READY) { // tell other hosts about changes in missing certificates
									untrustedChange = false; // do not send another start signal
									hosts.forEach(function(host) {
										return startSignal(host, !_);
									});
								}
								if (changes.start) { // try to start connections anew
									console.log("Renew connections");
									startServer(_);
								}
							}
						} else {
							// host has not passed checks and is not trustworthy
							if (foundHost && _markTrusted(foundHost, false)) untrustedChange = true;
						}
						if (untrustedChange && localHost.status === STATUS_READY) {
							hosts.forEach(function(host) {
								return startSignal(host, !_);
							});
						}
					}
				} catch (e) {
					writeError(response, "Error " + e);
				}
				return;
			case 'down':
				// nanny has stopped
				host = command[1];
				// update host data (nothing to do when host is not found)
				foundHost = hostsByName[host];
				if (foundHost && !foundHost.local) {
					foundHost.started = false;
					foundHost.status = STATUS_NOT_STARTED;
					tracer && tracer("Host down " + foundHost.hostname);
				}
				checkVersions(_);
				resultText += "OK - down\n";
				break;
			default:
				resultText += "OK " + command[0] + "\n";
		}

		tracer && tracer("Futures finished");
		for (i = 0; i < futures.length; i++) {
			if (!futures[i]) continue;
			var extra = futures[i].extra;
			try {
				var res = futures[i](_);
				if (extra instanceof Object) {
					extra.message = res;
					resultText += JSON.stringify(extra) + "\n";
				} else {
					resultText += (extra || "") + res + "\n";
				}
				tracer && tracer("result of future " + res + " ---- " + JSON.stringify(extra));
			} catch (e) {
				if (extra instanceof Object) {
					extra.message = "" + e;
					extra.failure = true;
					resultText += JSON.stringify(extra) + "\n";
				} else {
					resultText += (extra || "") + e + "\n";
				}
				console.log("error of future " + e);
			}
		}
		response.writeHead(200, {
			'Content-Type': 'text/plain'
		});
		response.end(resultText);
		return;
	}

	// console.log("==============================="+localHost.status)
	if (localHost.status < STATUS_READY) {
		var text;
		var temporary;
		switch (localHost.status) {
			case STATUS_START:
				temporary = 503;
				text = locale.format(module, "beingStarted");
				break;
			case STATUS_INIT:
				temporary = 503;
				text = locale.format(module, "notYetStarted");
				break;
			case STATUS_TIME_DIFFERENCE:
				text = locale.format(module, "timeDifference");
				break;
			case STATUS_WRONG_VERSION:
				text = locale.format(module, "wrongVersion", hosts.mainVersion, localHost.version);
				break;
			case STATUS_LOW_VERSION:
				text = locale.format(module, "lowVersion", localHost.version);
				break;
			case STATUS_RESPAWN:
				text = locale.format(module, "respawn");
				break;
			case STATUS_INACTIVE:
				text = locale.format(module, "inactive");
				break;
			case STATUS_NOT_REACHABLE:
				text = locale.format(module, "notReachable");
				break;
			case STATUS_NOT_STARTED:
				text = locale.format(module, "notStarted");
				break;
			default:
				text = locale.format(module, "wrongStatus", localHost.status);
		}
		writeError(response, text, temporary);
		return;
	}

	streamRecorder = new recorder.StreamRecorder(request);
	if (mock.BALANCER_HEADER in request.headers) {
		if (localHost.status < STATUS_READY) {
			writeError(response, "Host not yet ready", true);
			return;
		}
		data = request.headers[mock.BALANCER_HEADER].split(",");
		var localPort = data[0];
		for (i = data.length - 1; i > 0; i--) {
			if (!hosts[i - 1].local) hosts[i - 1].status = data[i];
		}
		tracer && tracer("balancer header " + localPort);
		var number = localPort.substr(1) * 1;
		if (!(number in children)) {
			writeError(response, locale.format(module, "noChildNumber", localPort, localHost.hostname));
			return;
		}
		try {
			doRequest(streamRecorder, response, [localHost, localPort], _);
			return;
		} catch (e) {
			tracer && tracer("Error in local call " + e);
			writeError(response, locale.format(module, "giveUpLocal"));
		}
		return;
	}
	var sid; // Syracuse session
	if (request.headers.cookie) {
		var r = /syracuse\.sid=([\w\-]+)/.exec(request.headers.cookie);
		if (r) {
			sid = r[1];
			tracer && tracer("Session: " + sid);
		}
	}
	// check time with database time
	try {
		databaseTime.getTime(_, true);
	} catch (e) {
		localHost.status = STATUS_TIME_DIFFERENCE;
		writeError(response, locale.format(module, "timeDiffDatabase", localHost.hostname, TIME_THRESHOLD / 1000));
		startChildProcesses(true, _);
		return;
	}

	var redir = redirects[request.url];
	if (redir) {
		tracer && tracer("Redirect request " + request.url + " to same server");
		var hostport = redir[0];
		// delete redirection unless it is for change password page (because its url is fetched with GET and POST)
		if (request.url.substr(0, 11) !== "/auth/pwd--") {
			delete redirects[request.url];
		}
		doRequest(streamRecorder, response, hostport, _);
		tracer && tracer("Request finished");
		return;
	}

	if (sid) { // session available
		if (sid in sessions) {
			host = sessions[sid][0];
			if (host.status < STATUS_READY) {
				tracer && tracer("Delete session " + sid + " " + util.format(host));
				if (!sessionCollection) sessionCollection = dbDriver.createCollection(db, 'SessionInfo', _);
				deleteSession(sid, sessionCollection, _);
			} else {
				try {
					doRequest(streamRecorder, response, sessions[sid], _, sid);
					tracer && tracer("Request finished");
					return;
				} catch (e) {
					tracer && tracer("" + e + "Delete session " + sid + " " + util.format(host));
					if (!sessionCollection) sessionCollection = dbDriver.createCollection(db, 'SessionInfo', _);
					deleteSession(sid, sessionCollection, _);
					tracer && tracer("Host not available " + host.hostname);
				}
			}
		}
		if (localHost.status === STATUS_FINISHING) {
			// no new sessions accepted during finish
			writeError(response, locale.format(module, "shuttingDown"));
			return;
		}
		// refresh local session table and balance
		if (!sessionCollection) sessionCollection = dbDriver.createCollection(db, 'SessionInfo', _);
		data = refreshSessions(sessionCollection, false, _);
		if (!data) return differentVersionError(response);
		// maybe session is now known
		if (sid in sessions) {
			host = sessions[sid][0];
			if (host.status < STATUS_READY) {
				tracer && tracer("Delete session3 " + sid + " " + util.format(host));
				deleteSession(sid, sessionCollection, _);
			} else {
				try {
					doRequest(streamRecorder, response, sessions[sid], _, sid);
					return;
				} catch (e) {
					tracer && tracer("" + e + "Delete session4 " + sid + " " + util.format(host));
					deleteSession(sid, sessionCollection, _);
					console.log("Host not available1 " + host.hostname);
				}
			}
		}
	}

	// session not available any more
	if (localHost.status === STATUS_FINISHING) {
		// no new sessions accepted during finish
		writeError(response, locale.format(module, "shuttingDown"));
		return;
	}
	for (i = 0; i < 2; i++) {
		if (!data) {
			if (!sessionCollection) sessionCollection = dbDriver.createCollection(db, 'SessionInfo', _);
			data = refreshSessions(sessionCollection, false, _); // balance
			if (!data) return differentVersionError(response);
		}
		try {
			doRequest(streamRecorder, response, data, _);
			return;
		} catch (e) {
			tracer && tracer("Host not available " + data[0].hostname + " Error " + e);
			data = null;
		}
	}
	writeError(response, locale.format(module, "giveUp"));
	return;
}

var wait = _(function(time, callback) {
	setTimeout(callback, time);
}, 1);

// shutdown: finish sessions, close DB connection and then exit with status 10
// Parameters:
// exclude: exclude this Syracuse server (e. g. N0) 
// notify: notify other hosts about status change
// local: only consider sessions on local host (under this nanny process)

function shutdown(_, exclude, notify, local) {
	var sessionCollection = dbDriver.createCollection(db, 'SessionInfo', _);
	try {
		stopSessions(sessionCollection, exclude, _, notify);
	} catch (e) {
		console.log("Exception stopSessions " + e);
	}
	console.log("After stopSessions");
	var hostsCollection = dbDriver.createCollection(db, 'Host', _);
	dbDriver.update(hostsCollection, {
		hostname: config.servername
	}, {
		started: false
	}, _);
	dbDriver.close(db);
	console.log("END");
	process.nextTick(function() {
		console.log("Exit process");
		process.exit(10);
	});
}

var stopSessions = _(function(sessionCollection, exclude, callback, notify) {
	var remainingTime = POLL_TIME + POLL_INTERVAL;
	var count = 1; // number of sessions (will be set by database query)
	var answerSent = false;
	// pattern for either all sessions on this host or for all sessions in the cluster
	var regexp = notify ? new RegExp("^" + config.servername + ":N".replace(/([\.\*\:\-\[\\\]\(\)])/g, "\\$1")) : /\:N\d+$/;
	tracer && tracer("Regexp for stopSessions " + regexp);

	function pollfunction() {
		try {
			remainingTime -= POLL_INTERVAL;
			console.log(answerSent + "Poll for sessions, count " + count + ", remaining " + remainingTime);
			if (count === 0 && !answerSent) {
				answerSent = true;
				return callback(null);
			}
			if (remainingTime <= 0) {
				console.log("Remove sessions");
				answerSent = true;
				dbDriver.remove(sessionCollection, {
					serverName: regexp
				}, _ >> callback);
				return;
			}
			if (!answerSent && (remainingTime <= 0 || count === 0)) {
				console.log("");
				answerSent = true;
				return callback(null);
			}
			// start function again
			setTimeout(pollfunction, POLL_INTERVAL);
			// start database query
			dbDriver.count(sessionCollection, {
				serverName: regexp
			}, _ >> function(error, cnt) {
				console.log("Session cnt Error: " + error + " count: " + cnt);
				if (error && !answerSent) {
					answerSent = true;
					return callback(error);
				}
				count = cnt;
			});
		} catch (e) {
			console.log("Error in poll function " + e + " " + e.stack);
			if (!answerSent) {
				answerSent = true;
				return callback(e);
			}
		}
	}

	try {
		pollfunction();
		if (localHost.status < STATUS_READY) {
			// just stop the starting child processes
			console.log("stopSessions: Stop all child processes");
			localHost.status = STATUS_NOT_STARTED;
			children.forEach(function(child) {
				child.terminate = true;
				child.kill();
			});
		} else {
			// notification to all Syracuse processes that sessions will expire
			console.log("stopSessions: notify all child processes");
			var options = {
				path: "/notifyEnd",
				method: "GET"
			};
			var futures = [];
			for (var i = children.length - 1; i >= 0; i--) {
				console.log("Stop session N" + i + " exclude " + exclude);
				if ("N" + i !== exclude) futures.push(mock.simpleRequest(children[i].mockClient, options, !_));
			}
		}
		localHost.status = STATUS_FINISHING;
		// notify other hosts about status change
		if (notify) hosts.forEach(function(host) {
			return startSignal(host, !_);
		});
	} catch (e) {
		console.log("Error in stop function " + e);
		if (!answerSent) {
			answerSent = true;
			return callback(e);
		}
	}
}, 2);

//check certificate etc. of other host
//when 'ownChallenge' is not set, a challenge (which has to do with the current time) will taken from data
//data is an object with fields: 
//- time (optional): when present, this will be taken as challenge and will be verified with current time
//- challenge (optional): challenge to sign with own key
//- sign: signature of the challenge
//- cert: certificate
//- dh: Diffie-Hellman key (will be taken when checks are OK)
//result is null when checks are not OK
//When checks are OK and a foreign challenge is given, the foreign challenge will be signed.

function _checkFirstData(ownChallenge, data, host, _) {
	try {
		tracer && tracer("Check first data" + ownChallenge + " " + util.format(data));
		host.dhKey = null;
		host.certificate = null;
		if (!data) return null;
		tracer && tracer("Data available");
		// decipher data
		if (data.iv) {
			data = _secureUnpack(data, _)[0];
			data = JSON.parse(data);
		}
		if (!ownCertificate) return null;
		// verify data
		var challenge;
		if (!ownChallenge) {
			if (!data.time) return null;
			// compare the time			
			var timediff = databaseTime.getReducedTime(_) - data.time;
			console.log("Compare time " + timediff);
			if (timediff < 0 || timediff > 1) return null;
			challenge = localHost.hostname + " " + data.time;
		} else {
			challenge = ownChallenge;
		}
		// verify the foreign challenge
		tracer && tracer("Verify challenge");
		if (!_verifyText(challenge, data.cert, data.sign)) return null;
		// verify the foreign certificate
		tracer && tracer("Verify certificate");
		if (host.certificate !== data.cert) {
			var certificate = new jsx509.Certificate(data.cert);
			if (!certificate.verify(ownCertificate.caCertificates[0].certificate)) return null;
			tracer && tracer("Store data locally");
			// check server name
			// !!! maybe recent database changes
			var tcpName = certificate.subject.commonName;
			tracer && tracer("Server name from Certificate " + tcpName + " known name " + host.tcpHostName);
			if (tcpName !== host.tcpHostName) { // maybe in the mean time, something has changed in the database 
				tracer && tracer("Reload host data to find TCP name from database");
				updateHostData(false, _);
				host = hostsByName[host.hostname];
				tracer && tracer("New host " + util.format(host));
			}
			if (tcpName !== host.tcpHostName) {
				tracer && tracer("Wrong hostname in DB: " + host.tcpHostName + ", expected " + tcpName);
				return null;
			}
			tracer && tracer("Correct server name");
			host.certificate = data.cert;
		}
		host.dhKey = new Buffer(diffieHellman.computeSecret(data.dh, "base64", "binary").substr(0, 32), "binary");
		var signature;
		if (data.challenge) {
			tracer && tracer("Sign the new challenge" + util.format(challenge));
			// sign the challenge
			signature = _signText(data.challenge);
		}
		return {
			sign: signature,
			cert: ownCertificate.certificate,
			dh: diffieHellman.getPublicKey("base64")
		};

	} catch (e) {
		console.log("Error in check data: " + e + " " + e.stack);
		return null;
	}
}

//sign text with own private key. Output: base64

function _signText(text) {
	var sign = crypto.createSign("RSA-SHA1");
	sign.update(text, "utf8");
	return sign.sign(ownCertificate.key, "base64");
}

//verify text with given certificate. Signature must be in base64
// may return an exception when verification is not OK (dependent on node.js version)

function _verifyText(text, certificate, sign) {
	var verify = crypto.createVerify("RSA-SHA1");
	verify.update(text, "utf8");
	return verify.verify(certificate, sign, "base64");
}

/// read certificates from file system and perform checks
/// 
/// Parameters:
/// * certificate: object of database content of that (CA) certificate. When empty: consider internal (CA) certificate of local host
/// * ca: when true: CA certificate
/// * passphrases: object with passphrases
/// * newPassphrase: take that passphrase instead of passphrase from passphrases object
/// * cas: object with CA certificates (only necessary when certificate parameter is empty
/// * files: content of directory
///
/// Result: object with attributes
/// * key: decrypted private key
/// * cert: certificate object
/// * certificate: certificate text (certificate file content) in PEM format

function checkFileCertificates(_, certificate, ca, passphrases, newPassphrase, cas, files) {
	if (!certificate) {
		certificate = {
			name: (ca ? "ca" : lcHostName),
			internal: true
		};
	}
	// read certificate from file
	var basename = certificate.name + (ca ? ".cacrt" : ".crt");
	var cert, index;
	if (files) {
		index = files.indexOf(basename);
		if (index < 0) {
			throw new Error(locale.format(module, "noExCertFile", certificate.name));
		} else {
			files.splice(index, 1); // remove entry
			tracer && tracer("Found " + basename);
		}
	}

	try {
		cert = fs.readFile(certDirectory + basename, "utf8", _);
	} catch (e) {
		if (e.code === 'ENOENT') throw new Error(locale.format(module, "noExCertFile", certificate.name));
		else throw new Error(locale.format(module, "noCertFile", certificate.name, e));
	}
	// check whether certificate fits to hash (not for internal certificates)
	if (!certificate.internal) {
		var hash = crypto.createHash('md5');
		hash.update(cert, "utf8");
		if (certificate.certificateHash !== hash.digest('hex')) {
			throw new Error(locale.format(module, "wrongHash", certificate.name));
		}
	}
	var key;
	if (!ca && (certificate.keyExists || certificate.internal)) {
		basename = certificate.name + ".key";
		if (files) {
			index = files.indexOf(basename);
			if (index < 0) {
				throw new Error(locale.format(module, "noExKeyFile", certificate.name));
			} else {
				files.splice(index, 1); // remove entry
				tracer && tracer("Found " + basename);
			}
		}
		try {
			key = fs.readFile(certDirectory + basename, "utf8", _);
		} catch (e) {
			if (e.code === 'ENOENT') throw new Error(locale.format(module, "noExKeyFile", certificate.name));
			else throw new Error(locale.format(module, "noKeyFile", certificate.name, e));
		}
	}
	// prepare CA certificates
	if (certificate.caCertificates) {
		cas = certificate.caCertificates.map(function(cert) {
			return cert.certificate;
		});
	}
	// integrity check
	var integ = jsx509.integrity(cert, key, newPassphrase || passphrases && passphrases[certificate.name] || "", cas);
	if (integ.error) {
		// Integrity check failed
		console.log("Integrity check " + certificate.name + ": " + integ.error);
		throw new Error(integ.error);
	}
	integ.certificate = cert;
	return integ;
}

//encrypts the data using the common Diffie-Hellman key, may include authentication information
//takes data (as string or buffer) and returns object

function _securePack(data, host, auth) {
	try {
		var iv = new Buffer(16);
		for (var i = 0; i < 4; i++) {
			var n = Math.floor(Math.random() * (1 << 31));
			iv.writeInt32LE(n, 4 * i);
		}
		var cipher = crypto.createCipheriv("AES256", host ? host.dhKey : caHash, iv);
		// console.log("EN "+data)
		var encrypted = cipher.update(data, "utf8", "base64");
		encrypted += cipher.final("base64");
		var signature;
		if (host) { // sign the data
			signature = _signText(encrypted);
		}
		return {
			data: encrypted,
			iv: iv.toString("base64"),
			sender: host ? localHost.hostname : undefined,
			auth: auth,
			sign: signature
		};
	} catch (e) {
		console.log("Error in _securePack " + e + " " + e.stack + " " + e.trace);
	}
}

//decrypts the data using the common Diffie-Hellman key
//takes data as object and returns array with content: decrypted data and host name of sender

function _secureUnpack(parsed, _) {
	if (!ownCertificate) throw new Error(locale.format(module, "noCertificate"));
	var key;
	if (parsed.sender) {
		var host = hostsByName[parsed.sender];
		// console.log("HOST "+host.hostname+" "+host.certificate);
		if (!host.certificate) {
			if (parsed.auth && _checkFirstData(host.challenge, parsed.auth, host, _)) {
				host = hostsByName[parsed.sender]; // maybe host has changed during checkFirstData
				console.log("Secure unpack auth OK");
				host.challenge = undefined;
				_markTrusted(host, true); // host has proved to be trusted
			} else {
				throw new Error(locale.format(module, "noAuth"));
			}
		}
		key = host.dhKey;
		// verify signature
		if (!_verifyText(parsed.data, host.certificate, parsed.sign)) throw new Error(locale.format(module, "wrongSign"));
	} else {
		key = caHash;
	}
	var iv = new Buffer(parsed.iv, "base64");
	var decrypted;
	try {
		var decipher = crypto.createDecipheriv("AES256", key, iv);
		decrypted = decipher.update(parsed.data, "base64", "utf8");
		decrypted += decipher.final("utf8");
	} catch (e) {
		throw new Error(parsed.sender ? locale.format(module, "dhMismatch") : locale.format(module, "baseCAMismatch"));
	}
	var result = [decrypted, parsed.sender];
	// console.log("RESULT "+util.format(result));
	return result;
}

//sends and receives the request with encrypted data

function secureRequest(hostdata, method, path, data, auth, _) {
	tracer && tracer("Secure request " + method + " " + path);
	if (!hostdata.dhKey) throw new Error(locale.format(module, "noTrust", hostdata.hostname));
	var encryptedData = _securePack(data, hostdata, auth);
	var result = get(hostdata, method, path, JSON.stringify(encryptedData), _);
	tracer && tracer("Result " + util.format(result));
	var parsed = JSON.parse(result);
	return _secureUnpack(parsed, _)[0];
}

// delete a single Syracuse session from database

function deleteSession(session, sessionCollection, _) {
	delete sessions[session];
	dbDriver.remove(sessionCollection, {
		sid: session
	}, _);
}

//writes an error response. When parameter 'temporary' is set, it will be a 503 response (service not available)

function writeError(response, reason, temporary) {
	console.log("write error " + reason);
	response.writeHead(temporary ? temporary : 500, "Error", {
		"Content-Type": "text/plain"
	});
	response.end(reason);
}

function differentVersionError(response) {
	writeError(response, locale.format(module, "differentVersions", hosts.map(function(host) {
		return host.hostname + "/" + host.version;
	}).join(", ")));
}

// read all data from a stream
var getData = _(function(stream, callback) {
	stream.setEncoding('utf8');
	stream.resume();
	var result = "";
	stream.on('data', function(chunk) {
		result += chunk;
	});
	stream.on('end', function() {
		return callback(null, result);
	});
}, 1);

//get sessions from database, count sessions per node.js process and do load balancing
//parameter local: only consider sessions on local server

function refreshSessions(sessionCollection, local, _) {
	tracer && tracer("Refresh sessions");
	// console.log("Refresh")
	var data = dbDriver.find(sessionCollection, null, _);
	sessions = {};
	var counts = {}; // number of sessions per node server
	data.forEach(function(sess) {
		tracer && tracer("Session " + util.format(sess));
		var r = /^(.*)\:(N\d+)$/.exec(sess.serverName);
		if (r) {
			if (sess.serverName in counts) {
				counts[sess.serverName]++;
			} else {
				counts[sess.serverName] = 1;
			}
			hosts.forEach(function(host) {
				if (host.hostname === r[1]) {
					if (r[2].substr(1) * 1 < host.children) {
						sessions[sess.sid] = [host, r[2]];
					} else {
						tracer && tracer("Wrong port " + r[2] + " for " + host.hostname);
					}
					return;
				}
			});

		}
	});
	// add current requests for new sessions
	Object.keys(currentNewRequests).forEach(function(key) {
		var value = currentNewRequests[key];
		if (value > 0) {
			tracer && tracer("Add current requests " + key + " value " + value);
			if (key in counts) {
				counts[key] += value;
			} else {
				counts[key] = value;
			}
		}
	});
	tracer && tracer("Balance");
	return balance(counts, local ? [localHost] : hosts, localHost.hostname);
}

//finds host (and application server) with minimal number of sessions. The local host is preferred when there are several 
//applications with same minimal number of sessions.

function balance(counts, hosts, localhostname) {
	var result;
	var minCount = Number.MAX_VALUE;
	tracer && tracer("Hosts " + util.format(hosts));
	hosts.forEach(function(host) {
		if (host.status < STATUS_READY) return;
		tracer && tracer("Host " + util.format(host));
		var hostColon = host.hostname + ":";
		var i;
		for (i = host.children - 1; i >= 0; i--) {
			var port = "N" + i;
			var count = counts[hostColon + port] || 0;
			tracer && tracer("count " + hostColon + port + " value " + counts[hostColon + port]);
			if (count < minCount || (count === minCount && host.hostname === localhostname)) { // condition is true when counts[...] really exists and is less than
				result = [host, port];
				minCount = count;
			}
		}
	});
	tracer && tracer("Balance result " + util.format(result));
	return result;
}
exports.balance = balance;

function doRequestWithAnswer(streamRecorder, hostPort, _, sessionId) {
	tracer && tracer("Do req with answer to " + hostPort[0].hostname + ":" + hostPort[1] + " " + streamRecorder.originalStream.url);
	var dummyResponse = new mock.MemoryStream();
	doRequest(streamRecorder, dummyResponse, hostPort, _);
	tracer && tracer("Answer from host " + dummyResponse.content);
	return dummyResponse.content;
}

var doRequest = _(function(streamRecorder, response, hostPort, callback, sessionId) {
	if (!callback) return fut.future(doRequest, arguments, 3);
	var client;
	var options;
	var sessionHostName;
	var connectionData = hostPort[0].connectionData[0];
	var port = "" + (hostPort[1] ? hostPort[1] : connectionData.port);
	var foundHost = hostsByName[hostPort[0].hostname];
	if (foundHost) {
		foundHost.pendingRequest = true;
		// console.log("PENDING "+foundHost.hostname)
	}
	if (!sessionId) {
		sessionHostName = localHost.hostname + ":" + port;
		if (sessionHostName in currentNewRequests) {
			currentNewRequests[sessionHostName]++;
		} else {
			currentNewRequests[sessionHostName] = 1;
		}
	}
	var sslHeader;
	if (hostPort[0].hostname === localHost.hostname) {
		tracer && tracer("local request to " + hostPort[1]);
		options = mock.extractDataFromRequest(streamRecorder.originalStream);
		if (mock.BALANCER_HEADER in streamRecorder.originalStream.headers) {
			delete streamRecorder.originalStream.headers[mock.BALANCER_HEADER];
			sslHeader = streamRecorder.originalStream.headers[SSL_HEADER];
			console.log("BAL SSLHEADER " + util.format(sslHeader));
			if (sslHeader) {
				try {
					var parsed = JSON.parse(sslHeader);
					options.connection = {
						authorized: parsed[0],
						_peerCertificate: parsed[1]
					};
				} catch (e) {
					writeError(response, locale.format(module, "sslHeaderError", e, sslHeader));
				}
			} else {
				options.connection = {};
			}
		}
		client = children[hostPort[1].substr(1)].mockClient;
	} else {
		if (port.substr(0, 1) === "N") {
			streamRecorder.originalStream.headers[mock.BALANCER_HEADER] = hostPort[1] + "," + statusString();
			var conn = streamRecorder.originalStream.connection;
			if (conn && "authorized" in conn) {
				sslHeader = JSON.stringify([conn.authorized, conn.getPeerCertificate()]);
				streamRecorder.originalStream.headers[SSL_HEADER] = sslHeader;
			}
			// syracusesslheader setzen aus connection
			port = connectionData.port;
			tracer && tracer("Set port to nanny port " + port);
		}
		var address = hostPort[0].hostname;
		if (hostPort[0].tcpHostName) address = hostPort[0].tcpHostName;
		options = {
			connection: {},
			hostname: address,
			port: port,
			method: streamRecorder.originalStream.method,
			path: streamRecorder.originalStream.url,
			headers: streamRecorder.originalStream.headers
		};
		client = sslOptions(connectionData, options);
	}
	var req = client.request(options, function(res) {
		if (sessionHostName) {
			currentNewRequests[sessionHostName]--;
			sessionHostName = null;
		}
		var foundHost = hostsByName[hostPort[0].hostname];
		if (foundHost) foundHost.pendingRequest = false;
		res.pause();
		res.on('end', function() {
			callback(null);
		});
		var date;
		if (hostPort[0].hostname !== localHost.hostname) {
			date = res.headers.date;
			if (date) {
				var diff = Date.now() - new Date(date).getTime();
				tracer && tracer("Time difference " + diff);
				if (diff > TIME_THRESHOLD || -diff > TIME_THRESHOLD) {
					hostPort[0].status = STATUS_TIME_DIFFERENCE;
					console.error("Time difference error. Date header " + date + " local time " + new Date() + " difference " + diff + " URL " + util.format(options));
					writeError(response, locale.format(module, "timeDifference2", localHost.hostname, hostPort[0].hostname, (TIME_THRESHOLD / 1000)));
					return;
				}
			}
		}
		//redirect certain requests to same host
		if (res.statusCode === 303) {
			console.log("HEAD " + util.format(res.headers));
			var redirectUrl = res.headers.Location || res.headers.location;
			date = _clearRedirects();
			if (redirectUrl && redirectUrl !== "/") {
				redirects[redirectUrl] = [hostPort, date];
				tracer && tracer("add redirect for " + redirectUrl + " " + sessionId);
			}
		}
		var cookies = res.headers['set-cookie'];
		if (cookies) {
			if (Array.isArray(cookies)) cookies = cookies.join(" ");
			var index = cookies.indexOf('syracuse.sid=');
			if (index >= 0) {
				var newSession = cookies.substr(index + 13, 36);
				if (newSession !== sessionId) {
					if (sessionId) delete sessions[sessionId];
					sessions[newSession] = hostPort;
				}
			}
		}
		var resHeaders = res.headers;
		if ("date" in resHeaders) {
			delete resHeaders.date;
			if ("date" in resHeaders) { // maybe headers object is write protected
				resHeaders = {};
				Object.keys(res.headers).forEach(function(head) {
					if (head !== 'date') resHeaders[head] = res.headers[head];
				});
			}
		}
		response.writeHead(res.statusCode, resHeaders);
		res.resume();
		res.pipe(response);
	});
	req.on("error", function(err) {
		// mark server as down unavailable
		if (sessionHostName) {
			currentNewRequests[sessionHostName]--;
			sessionHostName = null;
		}
		tracer && tracer("Error " + util.format(hostPort[0]));
		tracer && tracer("Mark as down");
		var foundHost = hostsByName[hostPort[0].hostname];
		console.log("MARK " + util.format(foundHost));
		if (foundHost.pendingRequest) {
			foundHost.pendingRequest = false;
			foundHost.status = STATUS_NOT_REACHABLE;
		}
		// connection error - try to find other server
		tracer && tracer("Connection error " + err + " " + util.format(hostPort));
		return callback(err);
	});
	streamRecorder.newStream().pipe(req);
}, 3);

// remove outdated redirect data

function _clearRedirects() {
	var date = Date.now();
	var dateComp = date - 600000;
	for (var id in redirects) {
		if (redirects[id][1] < dateComp) {
			delete redirects[id];
		}
	}
	return date;
}

//for unit tests
exports._updateHosts = _updateHosts;