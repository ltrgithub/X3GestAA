var http = require('http');
var mongodb = require('mongodb');
var util = require('util');
var os = require('os');
var fs = require('fs')
var child_process = require('child_process')
var mock = require('./mock')
var recorder = require('./recorder')
var fut = require('streamline/lib/util/future')

var config;	
var db = null; // MongoDB handle
var BALANCER_HEADER = "syracuseBalancerHeader"; // special Http header for passing load balancing information



//list of sessions known to this balancer
var sessions = {}; // keys are Syracuse session ID's, values are corresponding server names and ports (as an array)
var hosts = []; // list of different Syracuse hosts, with following information: hostname, nannyPort, children number, 
// active: generally available, started: currently started 
// version: Syracuse version (system is only usable when all versions are equal
hosts.mainVersion = ""; // main version of the cluster (will be set upon first response of another server or when no server responds)
var children = []; // child processes. children.terminate will prevent restarting child processes
var childrenStarted = false; // child processes will not be started until the version is correct

//function copied from syracuse-core/lib/uuid.js
function generateUUID(sep) {
	var randomHex = function(len, mask, offset) {
		var n = Math.floor(Math.random() * (1 << 24));
		if (mask)
			n = (n & mask) + offset;
		var s = n.toString(16);
		return s.length >= len ? s.substring(0, len) : ("00000000".substring(0, len - s.length) + s);
	};
	// Version 4 UUIDs have the form
	// xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx with hexadecimal digits x
	// and hexadecimal digits 8, 9, A, or B for y
	if (sep == null)
		sep = '-';
	return randomHex(4) + randomHex(4) + sep + randomHex(4) + sep +
	randomHex(4, 0x0fff, 0x4000) +
	sep +
	randomHex(4, 0x3fff, 0x8000) +
	sep +
	randomHex(6) +
	randomHex(6);
};



function killChildren() {
	if (children.length > 0) {
		console.log("Kill child processes");
		children.forEach(function(child) {
			if (child) child.kill();
		})
	}
	// console.log("Child processes terminated");	
}


process.on('exit', function() {
	// console.log("Terminate nanny");
	if (db) {
		db.close();
	}
	killChildren();
})

// host: in hosts array
// command: command to send
// forget: when set, host will not be marked as unavailable when there is an error (host will be marked as started when request is successful any way) 
// return: data of response.
function get(hostdata, method, path, data, _, forget) {
	var options = {method: method || 'GET', hostname: hostdata.local ? "localhost" : hostdata.hostname , port: hostdata.nannyPort, path: path};
	try {
		var result = mock.simpleRequest(http, options, data, _);
		hostdata.started = true;
		return result;
	} catch (e) {
		if (!forget && !hostdata.local) hostdata.started = false; 
		throw e;		
	}
}

/// main function
function start(conf, _) {
//	console.log("START function")
	switch (process.argv[2]) {
	case "?":
	case "help":
	case "--help":
		console.log("Valid commands: ")
		console.log("node nanny install <Port> <Number> [force]\n  Install process with port <Port> for nanny process, <Number> child processes.\n  The optional 'force' argument allows to override an existing installation")
		console.log("node nanny\n  (or: node nanny run) start nanny process")
		console.log("node nanny start\n  start nanny process in background as a detached process")
		console.log("node nanny stop\n  ask running nanny process to stop")
		console.log("node nanny remove\n  Remove data for host process")
		console.log("node nanny help\n  This help text")
		return 0;
	case "start":
		console.log("Start detached node process. Output goes to ./out.log");
		var out = fs.openSync('./out.log', 'a'); 
		var err = fs.openSync('./out.log', 'a');
		var child = child_process.spawn(process.argv[0], ["nanny", "run" ], { detached: true, stdio: [ 'ignore', out, err] });
		child.unref();
		return 0;
	}
	config = conf;
	config.servername =  os.hostname();
	config.collaboration = config.collaboration || {};
	if (config.collaboration.domain) {
		config.servername += ("."+config.collaboration.domain);
	}
	console.log("Server name "+config.servername)
	// Establish connection to db
	db = new mongodb.Db(config.collaboration.dataset || "syracuse", new mongodb.Server(config.collaboration.hostname || "localhost", config.collaboration.port || 27017,
			{}), {});	
	db = db.open(_);
	var hostsCollection = db.createCollection('Host', _)
	if (process.argv[2] === "install") {
		try {
			if (!/^\d+$/.test(process.argv[3]))
				throw "Invalid nanny port number "+process.argv[3];
			if (!/^\d\d?$/.test(process.argv[4]))
				throw "Invalid child process count "+process.argv[4];
			var nannyPort = 1*process.argv[3];
			var ports = 1*process.argv[4];
			// console.log("INSTALL "+nannyPort, ports)
			if (hosts[0]) {
				console.log("Host found");
				if (process.argv[5] === "force") {
					try {
						get(hosts[0], "PUT", "/nannyCommand/shutdown", null, _, true);
					} catch (e) {
						console.log("ERROR shutdown "+e);
					}
					console.log("update");
					hostsCollection.update({hostname: config.servername}, {$set:{ nannyPort: nannyPort, children: ports, _updDate: new Date(), started: false}}, {w: 1}, _);
					return 0;
				} else {
					throw "Already installed";
				}				
			} else {
				// new host
				var newHost = {_id: generateUUID(), hostname: config.servername, nannyPort: nannyPort, children: ports, _creUser: "setup", _updUser: "setup", _updDate: new Date(), active: true, started: false}
				// console.log("insert "+util.format(newHost));
				hostsCollection.insert(newHost, {w:1}, _);
				console.log("Host inserted "+config.servername)
				return 0;
			}
		} finally {
			db.close();
		}		
	}
	// updateHostData is not interesting for install
	updateHostData(_);
	switch (process.argv[2]) {
	case "run":
	case undefined:
		// read version file
		if (!hosts[0]) {
			db.close();
			throw new Error("Service has not been installed")
		}
		try {
			var ver = JSON.parse(fs.readFile('version.txt', _));
			hosts[0].version = ver.relNumber+"_"+ver.patchNumber
		} catch (e) { console.log("ERROR VER "+e)
			hosts[0].version = "_";
		}
		console.log("Start nanny with code version "+ hosts[0].version)
		hostsCollection.update({hostname: config.servername}, {$set:{ started: true, pid: process.pid}}, {w: 1}, _);
		var sessionCollection = db.createCollection('SessionInfo', _);
		http.createServer(function(request, response) { return requestListener(request, response, sessionCollection, function(error, data) {
			if (error)
				console.log("Error "+util.format(error)+(error.stack? " stack "+error.stack : ""));
		});		
		}).listen(hosts[0].nannyPort);
		console.log("Server running at "+hosts[0].nannyPort)	
		// send signal (without waiting) to all active servers that this server is started.
		// also send version number so that versions can be compared
		firstStartSignal();
		break;
	case "stop":
		hostsCollection.update({hostname: config.servername}, {$set:{ started: false}}, {w: 1}, _);
		db.close();
		try {
			var result = get(hosts[0], "PUT", "/nannyCommand/stop", null, _, true);
			console.log("Result"+result);			
		} catch (e) { console.log("Could not stop nanny (PID "+hosts[0].pid+"), error "+e)
			// TODO: when unauthorized connection via HTTPS with missing client certificates, do not give up but send SIGINT, wait 2 seconds,
			//  try again connection, when the same error occurs, send SIGTERM
		}
 		return 0;
	case "remove":
		try {
			hostsCollection.remove( { hostname: config.servername}, {w:1}, _);			
		} finally {
			db.close();			
		}		
		console.log("Host removed");		
		break;
	default:
		throw new Error("Wrong commmand line argument "+process.argv[2]+". Type node nanny help to get a list of all commands")

	} 
	return 1;
}
exports.start = start;

//send start signal to all nannies on active servers. This signal tells the other servers that this server is started and tells about
//code version of this server. The response tells this server about the code version of the other servers. When the versions differ,  
function startSignal(host, _) {
	if (!host.started || host.local) return;
	host.started = false;
	console.log("Host with start signal "+util.format(host))
	data = get(host, "POST", "/nannyCommand/started", JSON.stringify(hosts[0]), _, true);
	// check versions
	var infos = data.split(';');
	host.version = infos[1];
	if (!hosts.mainVersion) {
		hosts.mainVersion = infos[0];
		checkVersions();
	}
}	


function firstStartSignal(_) {
	var futures = [];
	hosts.forEach(function(host) {
		if (!host.local && host.started) {
			futures.push(startSignal(host));
		}
	})
	var i = futures.length;
	while (--i >= 0) {
		try {
			futures[i](_);
		} catch(e) {
			console.log("Error connecting host "+e);
		}
	}
	// maybe no host could be contacted
	checkVersions();
}


function checkVersions() {
	console.log("CHECK VERSIONS"+hosts.mainVersion+" "+hosts[0].version)
	if (childrenStarted) return;
	var commonVersion;
	if (hosts.mainVersion) {
		if (hosts.mainVersion === hosts[0].version) commonVersion = hosts.mainVersion;
	} else { // no main version yet: test for common version
		commonVersion = hosts[0].version;
		hosts.forEach(function(host) {
			if (host.active && host.started && !host.local) {
				if (commonVersion && commonVersion !== host.version) commonVersion = null;
			}
		})
		if (commonVersion) hosts.mainVersion = commonVersion;
	}
	if (commonVersion) {
		startChildProcesses(true);
	}
}


function startChildProcesses(force) {
	if (childrenStarted || force) {
		// new number of children
		var newChildCount = hosts[0].active ? hosts[0].children : 0;
		// current number of children
		var oldChildCount = children.length;	
		console.log("Start child processes "+oldChildCount+" "+newChildCount)
		for (var i = newChildCount-1; i>= oldChildCount; i--) {
			createProcess(undefined, i);
		}
		while (children.length > newChildCount) {
			console.log("Kill child process"+children.length)
			var child = children.pop();
			child.terminate = true;
			child.kill();
		}
		if (newChildCount > 0) childrenStarted = true;		
	}
}

/// createProcess(exitCode, port)
/// creates child process listening at the given port and puts its object into the `children` instance.
/// when the process finishes, the process will be restarted unless `children.terminate` is set.
function createProcess(code, port) {
	if (code == undefined)
		console.log("Start process on port N"+port)
		else
			console.log("Exit code "+code+" restarting process on port N"+port)

	if (!children.terminate) { // restart processes (unless terminating all processes is intended)
		// console.log("(re)start process")
		// if (!out) out = fs.openSync('./out'+port+'.log', 'a');
		// if (!err) err = fs.openSync('./out'+port+'.log', 'a');
		// var child = child_process.spawn(process.argv[0], ['.', port], {stdio: ['ignore', out, err]});
		var child = child_process.spawn(process.argv[0], ['.', "N"+port], {stdio: ['pipe', 'pipe', 'ignore']});
		children[port] = child;
		// attach mock client to child process
		child.mockClient = new mock.Mock(child.stdin, child.stdout, requestListener);
		// exit handler for restarting process
		child.on('exit', function(code) { 
			if (child.terminate) { 
				console.log("Stop child") 
			} else return createProcess(code, port) 
		});
	}
}



function updateHostData(_) {
	var hostsCollection = db.createCollection('Host', _);
	var newHosts = hostsCollection.find().toArray(_);
	console.log(">>>>"+util.format(newHosts)+" "+config.servername)
	hosts = _updateHosts(hosts, newHosts, config.servername);
	if (!hosts[0]) { // data for local host not available
		console.error("No data for local nanny")
		process.exit(2);		
	}
	startChildProcesses(false);
}

function _updateHosts(oldHosts, hosts, name) {
	// data for local host
	hosts.unshift(null);
	var i = hosts.length;
	while (--i >= 1) {
		var host = hosts[i]
		if (host.hostname === name) {
			host.local = true;
			host.started = true;
			hosts[0] = host;
			hosts.splice(i, 1);
		}
		var j = oldHosts.length;
		while (--j >= 0) {
			var oldHost = oldHosts[j];
			if (!oldHost) continue;
			if (oldHost.hostname === host.hostname) {
				if (!host.local) host.started = oldHost.started; // information about started may be not uptodate in database
				host.version = oldHost.version;
			}
		}
	}
	hosts.mainVersion = oldHosts.mainVersion || "";
	return hosts;
}


function requestListener(request, response, sessionCollection, _) {
	console.log(">> "+request.url)
	request.pause();
	var recorderStream; 
	// testSessions(sessionCollection, _);
	// special commands which will not be redirected
	if (request.url.substring(0, 14) === "/nannyCommand/") {
		var command = request.url.substr(14).split('/');
		var resultText = hosts[0].hostname+": ";
		console.log("SPLIT "+util.format(command));
		var futures = []; // invocations of other processes

		switch(command[0]) {
		case 'notifyAll': // notify all
			// console.log("Notify ALL"+util.format(request))
			request.pause();
			// console.log("Notify ALL2")
			var clientId = request.headers[BALANCER_HEADER];
			// console.log("CLIENT ID "+clientId)
			recorderStream = new recorder.RecorderStream(request);
			console.log("Notify all started "+clientId)
			// Notify other servers (without waiting)
			if (clientId) {
				delete request.headers[BALANCER_HEADER];				
				for (var i=1; i<hosts.length; i++) {
					var host = hosts[i];
					if (host.active && host.started && host.version === hosts.mainVersion) {
						console.log("Request to server "+i)
						futures.push(doRequestWithAnswer(recorderStream, [host, host.nannyPort]));
					}
				}
			}
			request.url = request.url.replace(/^\/[^\/]+\/[^\/]+/, "")
			console.log("Local path "+request.url)
			for (var i=0; i<children.length; i++) {
				var port = "N"+i;
				console.log("Contact "+port)
				if (port !== clientId) {
					console.log("Request to local app "+port)
					var future = doRequestWithAnswer(recorderStream, [hosts[0], port])				
					future.extraText = "Child "+port+": ";
					futures.push(future);
				}
			}
			break;
		case "notifyNannies": // send the command to other nannies but do not finish the request - execute it in the next switch statement
			command.shift();
			console.log("NACH SHIFT "+util.format(command))
			request.pause();
			// console.log("CLIENT ID "+clientId)
			recorderStream = new recorder.RecorderStream(request);
			request.url = request.url.replace(/^(\/[^\/]+)\/[^\/]+/, "$1") // remove second part
			console.log("Notify all started "+clientId+" "+request.url)
			// Notify other servers (without waiting)
			var futures = [];
			delete request.headers[BALANCER_HEADER];				
			for (var i=1; i<hosts.length; i++) {
				var host = hosts[i];
				if (host.started) {
					console.log("Request to server "+i)
					futures.push(doRequestWithAnswer(recorderStream, [host, host.nannyPort]));
				}
			}	
			break;
		}

		switch (command[0]) {
		case 'stop': // request to stop server
			var futures = [];
			hosts.forEach(function(host) {
				if (host && host.started && host.active && !host.local) {
					futures.push(get(host, "PUT", "/nannyCommand/down/"+hosts[0].hostname, null, undefined, true));
				}
			})
			killChildren();
			resultText = "OK1"
			console.log("Finish")
			// Exceptional case here: call futures here because otherwise process.nextTick function will not allow them to be executed
			for (var i = 0; i<futures.length; i++) {
				try {
					futures[i](_);					
				} catch (e) {
					console.log("Exception when informing host "+hosts[i].hostname+": "+e);
				}
			}
			futures = [];
			process.nextTick(function() { console.log("Exit process"); process.exit(0); });
			break;
		case 'update':
			updateHostData(_);
			resultText +="OK5"
			break;
		case 'test': // test request
			resultText += "OK2"
			break;
		case 'children': // ping to children
			console.log(" CCC "+util.format(children))
			if (childrenStarted) {
				for (var i = 0; i<children.length; i++) {
					futures[i] = children[i].mockClient.ping(undefined, 1000)
					futures[i].extraText = "Ping time for N"+i+": ";
				}
				
			} else {
				resultText = "Children not yet started"
			}
			break;
		case 'info': // info request
			resultText += util.format(hosts)+ " "+childrenStarted;
			break;
		case 'started': // nanny has started
			console.log("STARTEDDD")
			try {
				var d = getData(recorderStream ? recorderStream.getStream() : request, _);
				console.log("DATA FROM HOST "+d)
				var hostData = JSON.parse(d);
				var found = false;
				for (var attempt = 0; attempt < 2; attempt++) {
					for (var i = 1; i<hosts.length; i++) {
						console.log("CMP "+hostData.hostname+" "+hosts[i].hostname)
						if (hosts[i].hostname === hostData.hostname) {
							hosts[i].started = true;
							hosts[i].children = hostData.children;
							hosts[i].version = hostData.version;
							console.log("Host started"+i);
							found = true;
						}
					}
					console.log("FOUNDDD "+found)
					if (found) break;
					if (!found) updateHostData(_);					
				}
				if (!found) {
					console.log("ITITI")
					response.end("??;"+hosts[0].version)
					return;
				}
				checkVersions();
				console.log("RETURN VALUE "+hosts.mainVersion+";"+hosts[0].version)
				response.end(hosts.mainVersion+";"+hosts[0].version); // send back local code version and main version				
			} catch (e) {
				response.writeHead(500, {'Content-Type': 'text/plain'});
				response.end("Error "+e)
			}			
			return;
		case 'down': // nanny has stopped
			var host = command[1];
			// update host data (nothing to do when host is not found)
			for (var i = 1; i<hosts.length; i++) {
				if (hosts[i].hostname === host) {
					hosts[i].started = false;
					console.log("Host down"+i+" "+host);
				}
			}
			checkVersions();
			resultText += "OK - down"
			break;
		default:
			resultText += "OK "+command[0];
		}
		
		for (var i=0; i<futures.length; i++) {
			try {
				var res = futures[i](_)
				resultText += (futures[i].extraText || "") +res+"\n";
				console.log("RES "+res+" ---- "+futures[i].extraText)
			} catch (e) {
				resultText += (futures[i].extraText || "") +e+"\n";
				console.log("RET ERROR"+e)
			}
		}
		console.log("RESULT TEXT "+resultText)
		response.writeHead(200, {'Content-Type': 'text/plain'});
		response.end(resultText);

		return;
	}

	if (hosts.mainVersion && hosts.mainVersion !== hosts[0].version) {
		response.writeHead(500, {'Content-Type': 'text/plain'});
		response.end("Version mismatch: main version "+hosts.mainVersion+", local version "+hosts[0].version)
		return;
	}

	if (!hosts[0].active) {
		response.writeHead(500, {'Content-Type': 'text/plain'});
		response.end("Host is not active")
		return;
	}

	if (!childrenStarted) {
		response.writeHead(503, {'Content-Type': 'text/plain'});
		response.end("Application server not yet started. Try again later")
		return;
	}
	
	recorderStream = new recorder.RecorderStream(request);
	/*	var recorderStream = request;
	request.originalStream = request;
	request.reset = function() { console.log("RESET RESET")};
	 */

	if (BALANCER_HEADER in request.headers) {
		var localPort = request.headers[BALANCER_HEADER];
		var number = localPort.substr(1)*1;
		if (!(number in children)) {
			writeError(response, "Child number "+localPort+" does not exist on "+hosts[0].hostname)
			return;
		}
		try {
			doRequest(recorderStream, response, [hosts[0], localPort], _);
			return;
		} catch (e) {
			console.log("Error in local call "+e);
			writeError(response, "Give up local load balancing")
		}						
		return;
	}
	var sid; // Syracuse session
	if (request.headers.cookie) {
		var r = /syracuse\.sid=([\w\-]+)/.exec(request.headers.cookie);
		if (r) {
			sid = r[1];
			console.log("Session: "+sid)
		}		
	}
	var data; // data from load balancing
	if (sid) { // session available
		if (sid in sessions) {
			var host = sessions[sid][0]
			if (!host.started || !host.active) {				
				console.log("Delete session1 "+sid+" "+util.format(host))
				deleteSession(sid, sessionCollection, _);
			} else {
				try {
					doRequest(recorderStream, response, sessions[sid], _, sid);
					return;
				} catch (e) {
					console.log(""+e+"Delete session2 "+sid+" "+util.format(host))
					deleteSession(sid, sessionCollection, _);
					console.log("Host not available1 "+host.hostname)
				}				
			}
		}
		// refresh local session table and balance
		data = refreshSessions(sessionCollection, _);
		if (!data) return differentVersionError(response);
		// console.log("Nach refresh 21" + util.format(data))
		// maybe session is now known
		if (sid in sessions) {
			var host = sessions[sid][0]
			if (!host.started || !host.active) {
				console.log("Delete session3 "+sid+" "+util.format(host))				
				deleteSession(sid, sessionCollection, _);
			} else {
				try {
					doRequest(recorderStream, response, sessions[sid], _, sid);
					return;
				} catch (e) {console.log(""+e+"Delete session4 "+sid+" "+util.format(host))
					deleteSession(sid, sessionCollection, _);
				console.log("Host not available1 "+host.hostname)
				}				
			}
		}
	}
	// session not available any more
	for (var i = 0; i<2; i++) {
		if (!data) {
			data = refreshSessions(sessionCollection, _); // balance
			if (!data) return differentVersionError(response);
		}
		try {
			doRequest(recorderStream, response, data, _);
			return;
		} catch (e) {
			console.log(">>> "+e+" "+e.stack)
			console.log("Host not available3 "+data[0].hostname)
			data = null;
		}				
	}
	writeError(response, "Give up balancing")
	return;				
}



function deleteSession(session, sessionCollection, _) {
	delete sessions[session];
	console.log("Session1 removed");
	sessionCollection.remove( { sid: session}, {w:1}, _);
	console.log("Session removed");
}

function writeError(response, reason) {
	console.log("---- write Error ---- ")
	response.writeHead(500, "Internal error", { "Content-Type": "text/plain" });
	response.end(reason);

}

function differentVersionError(response) {
	writeError(response, "Different code versions on servers "+hosts.map(function(host) { return host.hostname+"/"+host.version; }).join(", "))
}


function getData(stream, callback) {
	console.log("STREAM")
	stream.setEncoding('utf8');
	console.log("STREAM2")
	stream.resume();
	var result = "";
	stream.on('data', function(chunk) {
		console.log("DATA GET "+chunk)
		result += chunk;
	})
	stream.on('end', function() {
		console.log("END GET ")
		return callback(null, result);
	})	
}

function testSessions(sessionCollection, _) {
	var data = sessionCollection.find().toArray(_);	
	var s = data.map(function(sess){return sess.serverName})
	console.log("SSSSSSSSSSs "+util.format(s));
}


//get sessions from database, count sessions per node.js process and do load balancing 
function refreshSessions(sessionCollection, _) {
	console.log("------------------ refresh --------------------------------------")
	// console.log("Refresh")
	var data = sessionCollection.find().toArray(_);
	sessions = {};
	var counts = {}; // number of sessions per node server
	data.forEach(function(sess) {
		console.log("Session "+util.format(sess))
		var r = /^(.*)\:(N\d+)$/.exec(sess.serverName);
		if (r) {
			if (sess.serverName in counts) {
				counts[sess.serverName]++;
			} else {
				counts[sess.serverName] = 1;
			}
			hosts.forEach(function(host) {
				if (host.hostname === r[1]) {
					if (r[2].substr(1) < host.children) {
						sessions[sess.sid] = [host, r[2]];
					} else {
						console.log("Wrong port "+r[2]+" for "+host.hostname)
					}
					return;
				}
			})

		}
	});
	console.log("Balance")
	return balance(counts, hosts);	
}


//finds 
function balance(counts, hosts) {
	var result;
	var minCount = Number.MAX_VALUE;
	hosts.forEach(function(host) {
		if (!host.started || !host.active || host.version !== hosts.mainVersion) return;
		console.log("Host "+util.format(host))
		var hostColon = host.hostname+":";
		for (var i=0; i<host.children; i++) {
			var port = "N"+i;
			var count = counts[hostColon+port] || 0;
			console.log("CNT "+hostColon+port+" value "+counts[hostColon+port])
			if (count < minCount) { // condition is true when counts[...] really exists and is less than
				result = [host, port];
				minCount = count; 
			}
		}
	})
	console.log("Balance result "+util.format(result))
	return result;
}
exports.balance = balance;


function doRequestWithAnswer(recorderStream, hostPort, _, sessionId) {
	console.log("Do req with answer")
	var dummyResponse = new mock.MemoryStream();
	doRequest(recorderStream, dummyResponse, hostPort, _);
	console.log("Answer from host "+dummyResponse.content);
	return dummyResponse.content;
}


function doRequest(recorderStream, response, hostPort, callback, sessionId) {
	console.log("Do request0")
	if (!callback) return fut.future(doRequest, arguments, 3);
	console.log("Do request "+hostPort[0].hostname+" "+hostPort[1])
	var client;
	var options;
	var port = ""+hostPort[1];
	if (hostPort[0].hostname === hosts[0].hostname) {
		console.log("local request to "+hostPort[1])
		delete recorderStream.originalStream.headers.syracuseBalancerHeader;
		options = mock.extractDataFromRequest(recorderStream.originalStream);
		client = children[hostPort[1].substr(1)].mockClient
	} else {
		if (port.substr(0, 1) === "N") {
			recorderStream.originalStream.headers.syracuseBalancerHeader = hostPort[1];
			port = hostPort[0].nannyPort;
			console.log("Set port to nanny port "+port)
		}
		client = http;		
		options = { connection: {}, hostname: hostPort[0].hostname , port: port, method: recorderStream.originalStream.method, path: recorderStream.originalStream.url, headers: recorderStream.originalStream.headers };
		if (recorderStream.originalStream.connection && "authorized" in recorderStream.originalStream.connection) {
			options.connection.authorized = recorderStream.originalStream.connection.authorized;
		}
	} 
	// console.log(options)
	var req = client.request(options, function(res) {
		res.pause();
		res.on('end', function() {
			callback(null);
		});
		var cookies = res.headers['set-cookie'];
		if (cookies) {
			var index = cookies.indexOf('syracuse.sid=');
			if (index >= 0) {
				var newSession = cookies.substr(index+13, 36);
				if (newSession !== sessionId) {
					if (sessionId) delete sessions[sessionId];
					sessions[newSession] = hostPort;
				}
			}			
		}
		// console.log("ZZZZZZZZZZZZZZZZZ "+res.statusCode+" "+util.format(res.headers))
		response.writeHead(res.statusCode, res.headers);
		res.resume();
		res.pipe(response);
	});
	req.on("error", function(err) {
		// mark server as down unavailable
		console.log("Error "+util.format(hostPort[0]))
		console.log("Mark as down - send start signal")
		startSignal(hostPort[0])
		// connection error - try to find other server
		console.log("CONNECTION ERROR"+err+" "+util.format(hostPort))
		return callback(err);
	});
	recorderStream.newStream().pipe(req);
}

//for unit tests
exports._updateHosts = _updateHosts

