var http = require('http');
var mongodb = require('mongodb');
var util = require('util');
var os = require('os');
var fs = require('fs')
var child_process = require('child_process')
var mock = require('./mock')
var recorder = require('./recorder')
var fut = require('streamline/lib/util/future')

var tracer = null;
// var tracer = console.log

// requests which are not in a session, are counted here. They will be regarded for load balancing in addition to the
// sessions according to the session table
var currentNewRequests = {};

var config;	
var db = null; // MongoDB handle
//file for version information at customer's site (redundant name - also in syracuse-patch/lib/write._js)
var VERSION_FILE = "version.json";
// maximal allowed time difference between servers in milliseconds
var TIME_THRESHOLD = 600000
// maximal number of requests between database time checks (will be multiplied with number of hosts)
var REQUEST_THRESHOLD = 1000
// time in milliseconds for a child process to wait after it has started
var PING_TIMEOUT = 100000

var lastDatabaseCheck = { time: 0, requests: 0}; // time and number of requests since last database time comparison


//list of sessions known to this balancer
var sessions = {}; // keys are Syracuse session ID's, values are corresponding server names and ports (as an array)
var hosts = []; // list of different Syracuse hosts, with following information: hostname, nannyPort, children number, 
// active: generally available, started: currently started 
// version: Syracuse version (system is only usable when all versions are equal)
// ready: 0: children not yet started, 1: ready, -1: host has been deactivated because of time difference
hosts.mainVersion = ""; // main version of the cluster (will be set upon first response of another server or when no server responds)
var children = []; // child processes ("N"+ind will be logical port of child with index 'ind')
var childrenStarted = false; // child processes will not be started until the version is correct
var childrenAvailable = true; // child processes are available. They will not be available any more when the respawn limit has exceeded

//function copied from syracuse-core/lib/uuid.js
function generateUUID(sep) {
	var randomHex = function(len, mask, offset) {
		var n = Math.floor(Math.random() * (1 << 24));
		if (mask)
			n = (n & mask) + offset;
		var s = n.toString(16);
		return s.length >= len ? s.substring(0, len) : ("00000000".substring(0, len - s.length) + s);
	};
	// Version 4 UUIDs have the form
	// xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx with hexadecimal digits x
	// and hexadecimal digits 8, 9, A, or B for y
	if (sep == null)
		sep = '-';
	return randomHex(4) + randomHex(4) + sep + randomHex(4) + sep +
	randomHex(4, 0x0fff, 0x4000) +
	sep +
	randomHex(4, 0x3fff, 0x8000) +
	sep +
	randomHex(6) +
	randomHex(6);
};



function killChildren() {
	
	if (children.length > 0) {
		console.log("Kill child processes");
		children.forEach(function(child) {
			child.terminate = true;
			if (child) child.kill();
		})
	}
	// console.log("Child processes terminated");	
}


process.on('exit', function() {
	// console.log("Terminate nanny");
	if (db) db.close();
	killChildren();
})

// host: in hosts array
// command: command to send
// forget: when set, host will not be marked as unavailable when there is an error (host will be marked as started when request is successful any way) 
// return: data of response.
function get(hostdata, method, path, data, _, forget) {
	var options = {method: method || 'GET', hostname: hostdata.local ? "localhost" : hostdata.hostname , port: hostdata.nannyPort, path: path};
	try {
		var result = mock.simpleRequest(http, options, data, _);
		hostdata.started = true;
		return result;
	} catch (e) {
		if (!forget && !hostdata.local) hostdata.started = false; 
		throw e;		
	}
}

/// main function
function start(conf, _) {
	switch (process.argv[2]) {
	case "?":
	case "help":
	case "--help":
		console.log("Valid commands: ")
		console.log("node nanny install <Port> <Number> [license file]\n  Install process with port <Port> for nanny process, <Number> child processes.\n  The optional license file argument allows to include a license file into database")
		console.log("node nanny\n  (or: node nanny run) start nanny process")
		console.log("node nanny start\n  start nanny process in background as a detached process")
		console.log("node nanny stop\n  ask running nanny process to stop")
		console.log("node nanny remove\n  Remove data for host process")
		console.log("node nanny help\n  This help text")
		return 0;
	case "start":
		console.log("Start detached node process. Output goes to ./out.log");
		var out = fs.openSync('./out.log', 'a'); 
		var err = fs.openSync('./out.log', 'a');
		var child = child_process.spawn(process.argv[0], ["nanny", "run" ], { detached: true, stdio: [ 'ignore', out, err] });
		child.unref();
		return 0;
	}
	config = conf;
	config.servername =  os.hostname();
	config.collaboration = config.collaboration || {};
	if (config.collaboration.domain) {
		config.servername += ("."+config.collaboration.domain);
	}
	console.log("Server name "+config.servername)
	// Establish connection to db
	db = new mongodb.Db(config.collaboration.dataset || "syracuse", new mongodb.Server(config.collaboration.hostname || "localhost", config.collaboration.port || 27017,
			{}), {});	
	db = db.open(_);
	var hostsCollection = db.createCollection('Host', _)
	if (process.argv[2] === "install") {
		try {
			if (!/^\d+$/.test(process.argv[3]))
				throw "Invalid nanny port number "+process.argv[3];
			if (!/^\d\d?$/.test(process.argv[4]))
				throw "Invalid child process count "+process.argv[4];
			var nannyPort = 1*process.argv[3];
			var ports = 1*process.argv[4];
			var localHosts = hostsCollection.find({hostname: config.servername}).toArray(_);
			if (localHosts.length > 0) {
				throw "Nanny already installed";
			} else {
				// new host
				var newHost = {_id: generateUUID(), hostname: config.servername, nannyPort: nannyPort, children: ports, _creUser: "setup", _updUser: "setup", _updDate: new Date(), active: true, started: false, respawnCount: 10, respawnTime: 120, returnRequestTimeout: 20}
				hostsCollection.insert(newHost, {w:1}, _);
				console.log("Host inserted "+config.servername)
			}
			if (process.argv[5]) { // optional license file
				var content = fs.readFile(process.argv[5], "utf8", _)
				// the following code comes from syracuse-license/lib/check._js
				// remove beginning and end
				content = content.replace(/^[^\{\}]*\{/, "").replace(/\}[^\{\}]*$/, "");
				// split into parts and add curly braces (AND add text attribute)
				var parts = content.split(/\}[^\{\},]*[\n\r][^\{\},]*\{/).map(function(part){ return { text: "{"+part+"}"}; });
				var licenseCollection = db.createCollection("license", _);
				licenseCollection.insert(parts, _);
			}
			return 0;
		} finally {
			db.close();
		}		
		return 0;
	}
	// updateHostData is not interesting for install
	updateHostData(_);
	switch (process.argv[2]) {
	case "run":
	case undefined:
		// read version file
		if (!hosts[0]) {
			db.close();
			throw new Error("Service has not been installed")
		}
		try {
			var ver = JSON.parse(fs.readFile(VERSION_FILE, _));
			hosts[0].version = ver.relNumber+"_"+ver.patchNumber
		} catch (e) { console.log("Error in version file "+e)
			hosts[0].version = "_";
		}
		console.log("Start nanny with code version "+ hosts[0].version)
		hostsCollection.update({hostname: config.servername}, {$set:{ started: true, pid: process.pid}}, {w: 1}, _);
		var sessionCollection = db.createCollection('SessionInfo', _);
		http.createServer(function(request, response) { return requestListener(request, response, sessionCollection, function(error, data) {
			if (error)
				console.log("Error "+util.format(error)+(error.stack? " stack "+error.stack : ""));
		});		
		}).listen(hosts[0].nannyPort);
		console.log("Server running at "+hosts[0].nannyPort)	
		// send signal (without waiting) to all active servers that this server is started.
		// also send version number so that versions can be compared
		firstStartSignal();
		break;
	case "stop":
		hostsCollection.update({hostname: config.servername}, {$set:{ started: false}}, {w: 1}, _);
		db.close();
		try {
			var result = get(hosts[0], "PUT", "/nannyCommand/stop", null, _, true);
		} catch (e) { console.log("Could not stop nanny (PID "+hosts[0].pid+"), error "+e)
			// TODO: when unauthorized connection via HTTPS with missing client certificates, do not give up but send SIGINT, wait 2 seconds,
			//  try again connection, when the same error occurs, send SIGTERM
		}
 		return 0;
	case "remove":
		try {
			hostsCollection.remove( { hostname: config.servername}, {w:1}, _);			
		} finally {
			db.close();			
		}		
		console.log("Host removed");		
		break;
	default:
		throw new Error("Wrong commmand line argument "+process.argv[2]+". Type node nanny help to get a list of all commands")

	} 
	return 1;
}
exports.start = start;

//send start signal to all nannies on active servers. This signal tells the other servers that this server is started and tells about
//code version of this server. The response tells this server about the code version of the other servers. When the versions differ,  
function startSignal(host, _) {
	if (!host.started || host.local) return;
	host.started = false;
	tracer && tracer("Host with start signal "+util.format(host))
	data = get(host, "POST", "/nannyCommand/started", JSON.stringify(hosts[0]), _, true);
	// check versions
	var infos = data.split(';');
	host.version = infos[1];
	host.ready = infos[2];
	if (!hosts.mainVersion) {
		hosts.mainVersion = infos[0];
		checkVersions();
	}
}	


function firstStartSignal(_) {
	var futures = [];
	hosts.forEach(function(host) {
		if (!host.local && host.started) {
			futures.push(startSignal(host));
		}
	})
	var i = futures.length;
	while (--i >= 0) {
		try {
			futures[i](_);
		} catch(e) {
			console.log("Error connecting host "+e);
		}
	}
	// maybe no host could be contacted
	checkVersions();
}


function checkVersions() {
	if (childrenStarted) return;
	var commonVersion;
	if (hosts.mainVersion) {
		if (hosts.mainVersion === hosts[0].version) commonVersion = hosts.mainVersion;
	} else { // no main version yet: test for common version
		commonVersion = hosts[0].version;
		hosts.forEach(function(host) {
			if (host.active && host.started && !host.local) {
				if (commonVersion && commonVersion !== host.version) commonVersion = null;
			}
		})
		if (commonVersion) hosts.mainVersion = commonVersion;
	}
	if (commonVersion) {
		startChildProcesses(true);
	}
}


function startChildProcesses(force) {
	if (childrenStarted || force) {
		// new number of children
		var newChildCount = (hosts[0].active || hosts[0].ready >= 0) ? hosts[0].children : 0;
		// current number of children
		var oldChildCount = children.length;	
		tracer && tracer("Start child processes "+oldChildCount+" "+newChildCount)
		for (var i = newChildCount-1; i>= oldChildCount; i--) {
			createProcess(undefined, i);
		}
		while (children.length > newChildCount) {
			tracer && tracer("Kill child process"+children.length)
			var child = children.pop();
			child.terminate = true;
			child.kill();
		}
		if (newChildCount > 0) childrenStarted = true;
		if (!hosts[0].ready) {
			// send ping signal to all child processes, then mark process ready
			var futures = [];
			children.forEach(function(child) {
				futures.push(child.mockClient.ping(undefined, PING_TIMEOUT));
			});
			// wait for results of child processes (collect results of futures). 
			// This function is called as a future!
			startedChildProcesses(futures);
		}
	}
}


function startedChildProcesses(futures, _) {
	var i = futures.length;
	var ok = true;
	while (--i >= 0) {
		try {
			futures[i](_);
		} catch (e) {
			ok = false;
			console.error("Error starting child process: "+e)
		}
	}
	if (ok) {
		hosts[0].ready = 1;
		console.log("Notify other servers about successful start of child processes")
		// send start signal again (as a future, because it is not necessary to wait for the result
		hosts.forEach(function(host) { return startSignal(host)});
	}
}

/// createProcess(exitCode, port)
/// creates child process listening at the given port and puts its object into the `children` instance.
/// when the process finishes, the process will be restarted unless `children.terminate` is set.
function createProcess(code, port) {
	var startTime = Date.now();
	var startCount = 0;
	var child = children[port];
	if (code == undefined)
		console.log("Start process on port N"+port)
		else {
			console.log("Exit code "+code+" restarting process on port N"+port)
			var respawnTime = 1000*hosts[0].respawnTime
			if (child && respawnTime && startTime-child.startTime < respawnTime) {
				startTime = child.startTime;
				startCount = (child.startCount || 0)+1;
				if (child.startCount > hosts[0].respawnCount) {
					// child processes unavailable
					childrenAvailable = false;
					hosts.forEach(function(host) {
						if (host && host.started && host.active && !host.local) {
							futures.push(get(host, "PUT", "/nannyCommand/down/"+hosts[0].hostname, null, undefined, true));
						}
					})
					hosts[0].available = false;
					killChildren();
				}
			} 						
		}

	if (!child || !child.terminate) { // restart processes (unless terminating all processes is intended)
		// console.log("(re)start process")
		// if (!out) out = fs.openSync('./out'+port+'.log', 'a');
		// if (!err) err = fs.openSync('./out'+port+'.log', 'a');
		// var child = child_process.spawn(process.argv[0], ['.', port], {stdio: ['ignore', out, err]});
		var child = child_process.spawn(process.argv[0], ['.', "N"+port, hosts[0].returnRequestTimeout], {stdio: ['pipe', 'pipe', process.stderr]});
		child.startTime = startTime
		child.startCount = startCount;
		children[port] = child;
		// attach mock client to child process
		child.mockClient = new mock.Mock(child.stdin, child.stdout, requestListener);
		// exit handler for restarting process
		child.on('exit', function(code) { 
			if (child.terminate) { 
				console.log("Stop child")
			} else return createProcess(code, port) 
		});
	}
}



function updateHostData(_) {
	var hostsCollection = db.createCollection('Host', _);
	var newHosts = hostsCollection.find().toArray(_);
	hosts = _updateHosts(hosts, newHosts, config.servername);
	if (!hosts[0]) { // data for local host not available
		console.error("No data for local nanny")
		process.exit(2);		
	}
	startChildProcesses(false);
}

function _updateHosts(oldHosts, hosts, name) {
	// data for local host
	hosts.unshift(null);
	var i = hosts.length;
	while (--i >= 1) {
		var host = hosts[i]
		if (host.hostname === name) {
			host.local = true;
			host.started = true;
			hosts[0] = host;
			hosts.splice(i, 1);
		}
		var j = oldHosts.length;
		while (--j >= 0) {
			var oldHost = oldHosts[j];
			if (!oldHost) continue;
			if (oldHost.hostname === host.hostname) {
				if (!host.local) host.started = oldHost.started; // information about started may be not uptodate in database
				host.version = oldHost.version;
				host.ready = oldHost.ready || 0;
			}
		}
	}
	hosts.mainVersion = oldHosts.mainVersion || "";
	return hosts;
}


function requestListener(request, response, sessionCollection, _) {
	tracer && tracer(">> "+request.url)
	request.pause();
	var streamRecorder; 
	// testSessions(sessionCollection, _);
	// special commands which will not be redirected
	if (request.url.substring(0, 14) === "/nannyCommand/") {
		var command = request.url.substr(14).split('/');
		var resultText = hosts[0].hostname+": ";
		var futures = []; // invocations of other processes

		switch(command[0]) {
		case 'notifyAll': // notify all
			request.pause();
			var clientId = request.headers[mock.BALANCER_HEADER];
			streamRecorder = new recorder.StreamRecorder(request);
			// Notify other servers (without waiting)
			if (clientId) {
				delete request.headers[mock.BALANCER_HEADER];				
				for (var i=1; i<hosts.length; i++) {
					var host = hosts[i];
					if (host.active && host.ready > 0 && host.started && host.version === hosts.mainVersion) {
						tracer && tracer("Request to server "+i)
						futures.push(doRequestWithAnswer(streamRecorder, [host, host.nannyPort]));
					}
				}
			}
			request.url = request.url.replace(/^\/[^\/]+\/[^\/]+/, "")
			tracer && tracer("Local path "+request.url)
			for (var i=0; i<children.length; i++) {
				var port = "N"+i;
				if (port !== clientId) {
					tracer && tracer("Request to local app "+port)
					var future = doRequestWithAnswer(streamRecorder, [hosts[0], port])				
					future.extraText = "Child "+port+": ";
					futures.push(future);
				}
			}
			break;
		case "notifyNannies": // send the command to other nannies but do not finish the request - execute it in the next switch statement
			command.shift();
			request.pause();
			// console.log("CLIENT ID "+clientId)
			streamRecorder = new recorder.StreamRecorder(request);
			request.url = request.url.replace(/^(\/[^\/]+)\/[^\/]+/, "$1") // remove second part
			tracer && tracer("Notify all started "+clientId+" "+request.url)
			// Notify other servers (without waiting)
			var futures = [];
			delete request.headers[mock.BALANCER_HEADER];				
			for (var i=1; i<hosts.length; i++) {
				var host = hosts[i];
				if (host.started) {
					tracer && tracer("Request to server "+i)
					futures.push(doRequestWithAnswer(streamRecorder, [host, host.nannyPort]));
				}
			}	
			break;
		}

		switch (command[0]) {
		case 'stop': // request to stop server
			var futures = [];
			hosts.forEach(function(host) {
				if (host && host.started && host.active && !host.local) {
					futures.push(get(host, "PUT", "/nannyCommand/down/"+hosts[0].hostname, null, undefined, true));
				}
			})
			killChildren();
			resultText = "OK1"
			// Exceptional case here: call futures here because otherwise process.nextTick function will not allow them to be executed
			for (var i = 0; i<futures.length; i++) {
				try {
					futures[i](_);					
				} catch (e) {
					console.log("Exception when informing host "+hosts[i].hostname+": "+e);
				}
			}
			futures = [];
			process.nextTick(function() { console.log("Exit process"); process.exit(0); });
			break;
		case 'update':
			updateHostData(_);
			resultText +="OK5"
			break;
		case 'test': // test request
			resultText += "OK2"
			break;
		case 'children': // ping to children
			if (childrenStarted) {
				for (var i = 0; i<children.length; i++) {
					futures[i] = children[i].mockClient.ping(undefined, 1000)
					futures[i].extraText = "Ping time for N"+i+": ";
				}
				
			} else {
				resultText = "Children not yet started"
			}
			break;
		case 'info': // info request
			resultText += util.format(hosts)+ " "+childrenStarted;
			break;
		case 'started': // nanny has started
			try {
				var d = getData(streamRecorder ? streamRecorder.getStream() : request, _);
				var hostData = JSON.parse(d);
				var found = false;
				for (var attempt = 0; attempt < 2; attempt++) {
					for (var i = 1; i<hosts.length; i++) {
						tracer && tracer("compare "+hostData.hostname+" "+hosts[i].hostname)
						if (hosts[i].hostname === hostData.hostname) {
							hosts[i].started = true;
							hosts[i].ready = hostData.ready;
							hosts[i].children = hostData.children;
							hosts[i].version = hostData.version;
							tracer && tracer("Host started"+i);
							found = true;
						}
					}
					if (found) break;
					if (!found) updateHostData(_);					
				}
				if (!found) {
					response.end("??;"+hosts[0].version+";"+hosts[0].ready)
					return;
				}
				checkVersions();
				var returnValue = hosts.mainVersion+";"+hosts[0].version+";"+hosts[0].ready
				tracer && tracer("return value on start request "+returnValue)
				response.end(returnValue); // send back local code version and main version				
			} catch (e) {
				writeError(response, "Error "+e);
			}			
			return;
		case 'down': // nanny has stopped
			var host = command[1];
			// update host data (nothing to do when host is not found)
			for (var i = 1; i<hosts.length; i++) {
				if (hosts[i].hostname === host) {
					hosts[i].started = false;
					tracer && tracer("Host down"+i+" "+host);
				}
			}
			checkVersions();
			resultText += "OK - down"
			break;
		default:
			resultText += "OK "+command[0];
		}
		
		for (var i=0; i<futures.length; i++) {
			try {
				var res = futures[i](_)
				resultText += (futures[i].extraText || "") +res+"\n";
				tracer && tracer("result of future "+res+" ---- "+futures[i].extraText)
			} catch (e) {
				resultText += (futures[i].extraText || "") +e+"\n";
				console.log("error of future "+e)
			}
		}
		response.writeHead(200, {'Content-Type': 'text/plain'});
		response.end(resultText);

		return;
	}

	if (hosts.mainVersion && hosts.mainVersion !== hosts[0].version) {
		writeError(response, "Version mismatch: main version "+hosts.mainVersion+", local version "+hosts[0].version)
		return;
	}

	if (!hosts[0].active) {
		writeError(response, "Host is not active")
		return;
	}

	else if (hosts[0].ready < 0) {
		writeError(response, "Host has been deactivated because of time difference")
		return;
	}

	if (!childrenStarted) {
		response.writeHead(503, {'Content-Type': 'text/plain'});
		response.end("Application server not yet started. Try again later")
		return;
	}
	
	if (!childrenAvailable) {
		writeError(response, "Respawn limit exceeded. Applications cannot be started")
		return;
	}

	streamRecorder = new recorder.StreamRecorder(request);

	if (mock.BALANCER_HEADER in request.headers) {
		if (!hosts[0].ready) {
			writeError(response, "Host not yet ready")
			return;
		}
		var localPort = request.headers[mock.BALANCER_HEADER];
		tracer && tracer("balancer header "+localPort)
		var number = localPort.substr(1)*1;
		if (!(number in children)) {
			writeError(response, "Child number "+localPort+" does not exist on "+hosts[0].hostname)
			return;
		}
		try {
			doRequest(streamRecorder, response, [hosts[0], localPort], _);
			return;
		} catch (e) {
			tracer && tracer("Error in local call "+e);
			writeError(response, "Give up local load balancing")
		}						
		return;
	}
	var sid; // Syracuse session
	if (request.headers.cookie) {
		var r = /syracuse\.sid=([\w\-]+)/.exec(request.headers.cookie);
		if (r) {
			sid = r[1];
			tracer && tracer("Session: "+sid)
		}		
	}
	// check time with database time
	var now = Date.now();
	if (now < lastDatabaseCheck.time || now-lastDatabaseCheck.time > TIME_THRESHOLD || ++lastDatabaseCheck.requests > REQUEST_THRESHOLD*hosts.length) {		
		// avoid multiple database queries because of race conditions
		lastDatabaseCheck.time = now;
		lastDatabaseCheck.requests = 0;		
		// get time from database
		if (!lastDatabaseCheck.finalCode) {
			lastDatabaseCheck.finalCode = new db.bsonLib.Code("Date.now()");
		}
		var dbTime = db.eval(lastDatabaseCheck.finalCode, null, {nolock: true}, _);
		var diff = dbTime-now;
		tracer && tracer("database time check--"+dbTime+ " difference "+diff)
		if (diff > TIME_THRESHOLD || -diff > TIME_THRESHOLD) {
			hosts[0].ready = -1;
			writeError(response, "Time difference between "+hosts[0].hostname+" and database exceeds "+TIME_THRESHOLD/1000+" seconds. Host will be set inactive.")
			startChildProcesses(true);
			return;
		}
	}
	
	var data; // data from load balancing
	if (sid) { // session available
		if (sid in sessions) {
			var host = sessions[sid][0]
			if (!host.started || !host.active || host.ready <= 0) {				
				tracer && tracer("Delete session1 "+sid+" "+util.format(host))
				deleteSession(sid, sessionCollection, _);
			} else {
				try {
					doRequest(streamRecorder, response, sessions[sid], _, sid);
					return;
				} catch (e) {
					tracer && tracer(""+e+"Delete session2 "+sid+" "+util.format(host))
					deleteSession(sid, sessionCollection, _);
					tracer && tracer("Host not available1 "+host.hostname)
				}				
			}
		}
		// refresh local session table and balance
		data = refreshSessions(sessionCollection, _);
		if (!data) return differentVersionError(response);
		// maybe session is now known
		if (sid in sessions) {
			var host = sessions[sid][0]
			if (!host.started || !host.active || host.ready <= 0) {
				tracer && tracer("Delete session3 "+sid+" "+util.format(host))				
				deleteSession(sid, sessionCollection, _);
			} else {
				try {
					doRequest(streamRecorder, response, sessions[sid], _, sid);
					return;
				} catch (e) {tracer && tracer(""+e+"Delete session4 "+sid+" "+util.format(host))
					deleteSession(sid, sessionCollection, _);
				console.log("Host not available1 "+host.hostname)
				}				
			}
		}
	}
	// session not available any more
	for (var i = 0; i<2; i++) {
		if (!data) {
			data = refreshSessions(sessionCollection, _); // balance
			if (!data) return differentVersionError(response);
		}
		try {
			doRequest(streamRecorder, response, data, _);
			return;
		} catch (e) {
			tracer && tracer("Host not available "+data[0].hostname+ " Error "+e)
			data = null;
		}				
	}
	writeError(response, "Give up balancing")
	return;				
}



function deleteSession(session, sessionCollection, _) {
	delete sessions[session];
	sessionCollection.remove( { sid: session}, {w:1}, _);
}

function writeError(response, reason) {
	tracer && tracer("write error "+reason)
	response.writeHead(500, "Internal error", { "Content-Type": "text/plain" });
	response.end(reason);
}

function differentVersionError(response) {
	writeError(response, "Different code versions on servers "+hosts.map(function(host) { return host.hostname+"/"+host.version; }).join(", "))
}


function getData(stream, callback) {
	stream.setEncoding('utf8');
	stream.resume();
	var result = "";
	stream.on('data', function(chunk) {
		result += chunk;
	})
	stream.on('end', function() {
		return callback(null, result);
	})	
}

// function testSessions(sessionCollection, _) {
// 	var data = sessionCollection.find().toArray(_);	
// 	var s = data.map(function(sess){return sess.serverName})
//	console.log("SSSSSSSSSSs "+util.format(s));
// }


//get sessions from database, count sessions per node.js process and do load balancing 
function refreshSessions(sessionCollection, _) {
	tracer && tracer("Refresh sessions")
	// console.log("Refresh")
	var data = sessionCollection.find().toArray(_);
	sessions = {};
	var counts = {}; // number of sessions per node server
	data.forEach(function(sess) {
		tracer && tracer("Session "+util.format(sess))
		var r = /^(.*)\:(N\d+)$/.exec(sess.serverName);
		if (r) {
			if (sess.serverName in counts) {
				counts[sess.serverName]++;
			} else {
				counts[sess.serverName] = 1;
			}
			hosts.forEach(function(host) {
				if (host.hostname === r[1]) {
					if (r[2].substr(1) < host.children) {
						sessions[sess.sid] = [host, r[2]];
					} else {
						tracer && tracer("Wrong port "+r[2]+" for "+host.hostname)
					}
					return;
				}
			})

		}
	});
	// add current requests for new sessions
	Object.keys(currentNewRequests).forEach(function(key) {
		var value = currentNewRequests[key];
		if (value > 0) {
			tracer && tracer("Add current requests "+key+" value "+value)
			if (key in counts) {
				counts[key] += value;
			} else {
				counts[key] = value;
			}			
		} 
	})
	tracer && tracer("Balance")
	return balance(counts, hosts);	
}


//finds 
function balance(counts, hosts) {
	var result;
	var minCount = Number.MAX_VALUE;
	hosts.forEach(function(host) {
		if (!host.started || !host.active || !host.ready || host.ready < 0 || host.version !== hosts.mainVersion) return;
		tracer && tracer("Host "+util.format(host))
		var hostColon = host.hostname+":";
		for (var i=0; i<host.children; i++) {
			var port = "N"+i;
			var count = counts[hostColon+port] || 0;
			tracer && tracer("count "+hostColon+port+" value "+counts[hostColon+port])
			if (count < minCount) { // condition is true when counts[...] really exists and is less than
				result = [host, port];
				minCount = count; 
			}
		}
	})
	tracer && tracer("Balance result "+util.format(result))
	return result;
}
exports.balance = balance;


function doRequestWithAnswer(streamRecorder, hostPort, _, sessionId) {
	tracer && tracer("Do req with answer")
	var dummyResponse = new mock.MemoryStream();
	doRequest(streamRecorder, dummyResponse, hostPort, _);
	tracer && tracer("Answer from host "+dummyResponse.content);
	return dummyResponse.content;
}


function doRequest(streamRecorder, response, hostPort, callback, sessionId) {
	if (!callback) return fut.future(doRequest, arguments, 3);
	var client;
	var options;
	var sessionHostName 
	var port = ""+hostPort[1];
	if (!sessionId) {
		sessionHostName = hosts[0].hostname+":"+port;
		if (sessionHostName in currentNewRequests) {
			currentNewRequests[sessionHostName]++;	
		} else currentNewRequests[sessionHostName] = 1;		
	}
	if (hostPort[0].hostname === hosts[0].hostname) {
		tracer && tracer("local request to "+hostPort[1])
		delete streamRecorder.originalStream.headers.syracuseBalancerHeader;
		options = mock.extractDataFromRequest(streamRecorder.originalStream);
		client = children[hostPort[1].substr(1)].mockClient
	} else {
		if (port.substr(0, 1) === "N") {
			streamRecorder.originalStream.headers.syracuseBalancerHeader = hostPort[1];
			port = hostPort[0].nannyPort;
			tracer && tracer("Set port to nanny port "+port)
		}
		client = http;		
		options = { connection: {}, hostname: hostPort[0].hostname , port: port, method: streamRecorder.originalStream.method, path: streamRecorder.originalStream.url, headers: streamRecorder.originalStream.headers };
		if (streamRecorder.originalStream.connection && "authorized" in streamRecorder.originalStream.connection) {
			options.connection.authorized = streamRecorder.originalStream.connection.authorized;
			if (options.connection.authorized) {
				options.connection._peerCertificate = streamRecorder.originalStream.connection.getPeerCertificate();
			}
		}
	} 
	var req = client.request(options, function(res) {
		if (sessionHostName) {
			currentNewRequests[sessionHostName]--;
			sessionHostName = null;
		}
		res.pause();
		res.on('end', function() {
			callback(null);
		});
		var date = res.headers['date'];
		if (date) {
			var diff = Date.now()-new Date(date).getTime();
			tracer && tracer("Time difference "+diff)
			if (diff > TIME_THRESHOLD || -diff > TIME_THRESHOLD) {
				hostPort[0].ready = -1;
				writeError(response, "Time between "+hosts[0].hostname+" and "+hostPort[0].hostname+" differs by more than "+(TIME_THRESHOLD/1000)+ "seconds");
				return;
			}
		}
		var cookies = res.headers['set-cookie'];
		if (cookies) {
			var index = cookies.indexOf('syracuse.sid=');
			if (index >= 0) {
				var newSession = cookies.substr(index+13, 36);
				if (newSession !== sessionId) {
					if (sessionId) delete sessions[sessionId];
					sessions[newSession] = hostPort;
				}
			}			
		}
		response.writeHead(res.statusCode, res.headers);
		res.resume();
		res.pipe(response);
	});
	req.on("error", function(err) {
		// mark server as down unavailable
		if (sessionHostName) {
			currentNewRequests[sessionHostName]--;
			sessionHostName = null;
		}
		tracer && tracer("Error "+util.format(hostPort[0]))
		tracer && tracer("Mark as down - send start signal")
		startSignal(hostPort[0])
		// connection error - try to find other server
		tracer && tracer("Connection error "+err+" "+util.format(hostPort))
		return callback(err);
	});
	streamRecorder.newStream().pipe(req);
}

//for unit tests
exports._updateHosts = _updateHosts

