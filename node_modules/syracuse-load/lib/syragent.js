"use strict";
/// Agent for restarting the Syracuse service and for handling patch integration
/// This file is completely independent of the other source files of the Syracuse installation
/// and will be copied to a separate place in the setup. 

var exec = require('child_process').exec;
var fs = require('fs');
var path = require('path');
var config = require('./parameters.js').config;
if (config.serviceName.charAt(0) == '$') config.serviceName = 'syracuse';

if (process.platform === 'win32') {
	var SHELL_EXT = '.cmd';
	var SVC_CTRL = 'net';
	var LIST_SERVICES = 'net start';
	var AGENT_NAME = 'Agent ' + config.serviceName;
	var STARTED_MESSAGE = '\r\n   ' + config.serviceName + '\r\n';
} else {
	var SHELL_EXT = '.sh';
	var SVC_CTRL = 'initctl';
	var LIST_SERVICES = 'initctl list';
	var AGENT_NAME = config.serviceName + "-agent";
	var STARTED_MESSAGE = '\n' + config.serviceName + ' start/running,';
}
var AGENT_FILE = path.join(config.basePath, config.temporaryPath, 'node_modules/syracuse-load/lib/agent.js');
var NODE_FILE = path.join(config.basePath, config.temporaryPath, config.nodePath, 'node');
var AUTOUPDATE = path.join(__dirname, 'autoupdate' + SHELL_EXT);
var SHUTDOWN_SEMAPHORE = path.join(__dirname, 'shutdown.txt');
var VERSION_FILE = path.join(config.basePath, 'version.json');
var TEMP_VERSION_FILE = path.join(config.basePath, config.temporaryPath, 'version.json');
var START_SYRACUSE = SVC_CTRL + ' start "' + config.serviceName + '"';
var STOP_SYRACUSE = SVC_CTRL + ' stop "' + config.serviceName + '"';


function debugTrace(error, stdout, stderr) {
	if (config.debugMode) {
		if (error !== null) {
			console.log('exec error: ' + error.toString());
		}
		console.log('stdout:');
		console.log(stdout);
		console.log('stderr:');
		console.log(stderr);
	}
}

function printError(error, stdout, stderr) {
	console.log('exec error: ' + error.toString());
	console.log('stdout:');
	console.log(stdout);
	console.log('stderr:');
	console.log(stderr);
}

function startService(error, stdout, stderr) {
	debugTrace(error, stdout, stderr);
	if (error !== null) {
		console.log('Could not start service "' + config.serviceName + '" !');
		printError(error, stdout, stderr);
		setTimeout(agentCallback, config.timeoutDelay);
	} else {
		console.log('Service started successfully !');
		setTimeout(agentCallback, config.timeoutDelay);
	}
}

function doPatch(error, stdout, stderr) {
	debugTrace(error, stdout, stderr);
	if (error !== null) {
		console.log('Error during patch integration !');
		printError(error, stdout, stderr);
		console.log('Emergency exit !');
		setTimeout(function(code) {
			process.exit(code);
		}, 5000);
	} else {
		console.log('Patch integration finished successfully !');
		console.log('Starting service "' + config.serviceName + '" ...');
		exec(START_SYRACUSE, startService);
	}
}

function checkService(error, stdout, stderr) {
	debugTrace(error, stdout, stderr);
	if (error !== null) {
		console.log('Could not check service "' + config.serviceName + '" !');
		printError(error, stdout, stderr);
		setTimeout(agentCallback, config.timeoutDelay);
	} else {
		if (stdout.indexOf(STARTED_MESSAGE) >= 0) {
			if (config.debugMode) {
				console.log('Service "' + config.serviceName + '" is up and running !');
			}
			setTimeout(agentCallback, config.timeoutDelay);
		} else {

			if (fs.existsSync(SHUTDOWN_SEMAPHORE)) {
				//shutdown in progress
				fs.unlinkSync(SHUTDOWN_SEMAPHORE);
				setTimeout(function() {
					process.exit(0);
				}, 5000);

			} else {

				console.log(new Date().toISOString() + ' Service "' + config.serviceName + '" is down !');
				console.log('Checking for patch integration before starting the service ...');

				if (fs.existsSync(VERSION_FILE) && fs.existsSync(TEMP_VERSION_FILE)) {
					var baseVersion = JSON.parse(fs.readFileSync(VERSION_FILE, "utf8"));
					var tempVersion = JSON.parse(fs.readFileSync(TEMP_VERSION_FILE, "utf8"));

					console.log('Base version: ' + baseVersion.relNumber + '.' + baseVersion.patchNumber);
					console.log('Patch version: ' + tempVersion.relNumber + '.' + tempVersion.patchNumber);

					//var data = { release: version.relNumber, patch: version.patchNumber };
					if (baseVersion.relNumber == tempVersion.relNumber && baseVersion.patchNumber == tempVersion.patchNumber) {
						console.log('No need to patch !');
						console.log('Starting service "' + config.serviceName + '" ...');
						exec(START_SYRACUSE, startService);
					} else {
						console.log('Need to patch !');
						// Agent should only restart itself when its source file has changed
						if (fs.existsSync(AGENT_FILE) && fs.readFileSync(AGENT_FILE, "utf8") !== fs.readFileSync(__filename)) {
							console.log('Agent patch found !');
							console.log('Need to auto-update ...');

							var content;
							if (process.platform === 'win32') {
								content = 'mv -f "' + agentPatch + '" "' + __dirname + '/syragent.js"\n' + 'cp -f "' + nodePatch + '" "' + __dirname + '/node"\n' + START_AGENT + '\n';
							} else {
								content = 'move /y "' + agentPatch + '" "' + __dirname + '\\syragent.js"\r\n' + 'copy /y "' + nodePatch + '.exe' + '" "' + __dirname + '\\node.exe"\r\n' + START_AGENT + '"\r\n';
							}
							fs.writeFileSync(AUTOUPDATE, content);

							exitFunction(0);

						} else {
							console.log('Applying patch ...');
							exec(NODE_EXE + ' index.js PATCH', {
								cwd: config.basePath + '\\' + config.temporaryPath,
								maxBuffer: 1024 * 1024
							}, doPatch);
							// EM: was soll 'dir' (unter Linux)?
							//exec('dir',{cwd: config.basePath+path.sep+config.temporaryPath}, doPatch);
						}
					}
				} else {
					console.log('File ' + versionFile + ' not found !');
					console.log('Could not check for patch integration !');
					console.log('Starting service "' + config.serviceName + '" ...');
					exec(START_SYRACUSE, startService);
				}
			}
		}
	}
}

function agentCallback() {
	if (config.debugMode) {
		console.log('');
		console.log(new Date().toISOString() + ' Checking service "' + config.serviceName + '" ...');
	}
	exec(LIST_SERVICES, checkService);
}

function exitFunction(code) {
	console.log('About to exit ...');

	var date = new Date(Date.now() + 120000);
	var hour = date.getHours();
	hour = (hour < 10 ? "0" : "") + hour;
	var min = date.getMinutes();
	min = (min < 10 ? "0" : "") + min;
	console.log('Scheduling autoupdate task ...');
	exec('at ' + hour + ':' + min + ((process.platform === 'win32') ? ' -f ' : ' ') + AUTOUPDATE, function(error, stdout, stderr) {});
	console.log('Exiting now.');

	//delaying exit to flush stdout
	setTimeout(function(code) {
		process.exit(code);
	}, 5000);
}

function startAgent() {
	if (fs.existsSync(__dirname + path.sep + 'autoupdate' + SHELL_EXT)) fs.unlinkSync(AUTOUPDATE);
	agentCallback();
}

if (process.argv.length >= 3) {
	if (process.argv[2] == 'stop') {
		console.log(new Date().toISOString() + ' About to exit ...');
		console.log('Stopping service "' + config.serviceName + '" ...');
		fs.writeFileSync(SHUTDOWN_SEMAPHORE, 'Shutting down "Agent ' + config.serviceName + '"\r\n');
		exec(STOP_SYRACUSE, function(error, stdout, stderr) {});
		//delaying exit to flush stdout
		setTimeout(function(code) {
			process.exit(code);
		}, config.timeoutDelay + 5000);
		console.log('Exiting now.');
	} else {
		// improper use
		// do nothing for now
		// TODO throw exception and exit
	}
} else startAgent();