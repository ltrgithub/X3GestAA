/// !doc
/// # Mock API  
"use strict"
var stream = require('stream')
var events = require('events')
var streams = require('streamline/lib/streams/streams');
var globals = require('streamline/lib/globals');
var util = require('util')
var fut = require('streamline/lib/util/future')
exports.BALANCER_HEADER = "syracusebalancerheader"; // special Http header for passing load balancing information (not used in this file  


// var tracer = console.log
var tracer = null;

/// Pass HTTP requests and responses through a pipe
// Two instances of this Mock class must be connected using two pipes so that bidirectional exchange is possible. Usually this
// is standard input and standard output of a child process. Each side can send a request to the other side which will be processed by
// the request handler on the other side. There is no check that a request handler is available! Since the situation is totally symmetric,
// in the sequel, the side which poses the request, will be called client, the other side server.
// Internal processing:
// Each request/response gets an sequence number so that parallel requests/responses can be distinguished.
// An HTTP request/response contains headers etc. - in the sequel this will be called "metadata" and a stream of data
// (In detail: relevant metadata are: headers, url, method, HTTP version, response code, connection.authorized, connection.getPeerCertificate() 
// (to find out SSL connections and the client certificate. The mocks cannot handle SSL but will transport these two details).
// Whenever metadata or a chunk of data is transferred, there is a header first which tells about the kind of data and
// the byte length and the sequence number.
// The client listens on a readable stream (usually an HTTP request). When the first data come, the metadata and the first chunk of data 
// will be transferred to the client and the requestListener on the server will be invoked. 
// For each chunk of data (except for the final chunk which contains an end marker), a confirmation header will be sent back.
// The writable stream of the client (and server) will not accept further data until the confirmation has been received.
// Upon the 'end' event of the readable stream on the client, the header will contain an end marker. Since no more data are to come, there
// will not be a confirmation for this.
// The last chunk of the response (from server to client) will delete the temporary storage for this sequence number on the server and then 
// on the client. When there is no temporary storage for a sequence number and the header is no start header, it will be ignored on the other side.
// The mock http request on the server tries to imitate the original http request: it contains its headers, url, method, http version and
// a readable stream, but the connection attribute is empty except for 'authorized' and getPeerCertificate() to detect SSL connections.
// the mock http response on the server tries to imitate the original http response. it contains its set/remove header methods, the writeHead
// method, statusCode, but the writeContinue() method is not implemented at the moment.
// There is an optional timeout. When the answer is not complete within the timeout, it will be closed. When there is a close event from
// any side (HTTP request/response), all streams will be finished and the temporary storage for this sequence number will be removed on both sides


// no more input after this 
var ENDMARKER = 0x02;
// special headers have this bit set
var SPECIAL = 0x40;
var CONFIRMATION = SPECIAL
// ping header for just testing whether server can be reached
var PING = SPECIAL+1
// header to inform that the connection has been closed on client side
var CLOSED = SPECIAL+2
// marks that this is a response header (originated from the server), can also be a confirmation header back to the server
var RESPONSE = 0x80; 
// length of header in bytes
var HEADERLENGTH = 9
// a non-special header with this bit set is the first header of the connection
var STARTFRAME = 0x01


// copies attributes from HttpServerRequest to the target (or to a newly created object) and returns the target
// reasonPhrase: not official attribute, but used to transfer reason phrase to client
// _writeHeadCalled: indicates that 
exports.extractDataFromRequest = function(source, target) {
	target = target || {};
	["sendDate", "_writeHeadCalled", "headers", "httpVersion", "httpVersionMajor", "httpVersionMinor", "url", "method", "reasonPhrase", "statusCode"].forEach(function(key) {
		if (key in source) target[key] = source[key];
	})
	if ("connection" in source) {
		target.connection = {};
		if ("authorized" in source.connection) {
			target.connection.authorized = source.connection.authorized;
			target.connection._peerCertificate = source.connection._peerCertificate
			target.connection.getPeerCertificate = function() { return target.connection._peerCertificate }
		}
	}
	return target;
}

/// ## Mock class
/// constructor parameters: outputStream, inputStream, requestHandler and clientOptions
/// clientOptions is an object with the following optional attributes: 
/// timeout: after this time (in seconds), the request data will be deleted
exports.Mock = Mock;
function Mock(outputStream, inputStream, requestHandler, clientOptions) {
	events.EventEmitter.call(this);
	tracer && tracer("MOCK start; client options "+util.format(clientOptions))
	var self = this;
	var _sequenceNumber = 0;
	var _registry = {}; // contains all data for the current request. Key is the request sequence number, values are arrays of readableStream, writableStream, call back function, ping call back function
	var _registryForeign = {}; // contains all data for the foreign request which is processed here.
	// contains the instances of writable stream which want to write data
	var _queue = [];
	// input stream of child: to this the data will be written
	var _outputStream = outputStream;
	// child stream is writable? 
	var _outputReady = true;
	// output stream of child: return data
	var _inputStream = inputStream;
	// has a global error occurred?
	var _globalError
	
	if (requestHandler) {
		 this.addListener('request', requestHandler);
	}
	
	// number of current requests
	self.numberRequests = function() {
		tracer && tracer("Open requests own "+util.format(Object.keys(_registry))+" foreign "+util.format(Object.keys(_registryForeign)))
		return Object.keys(_registry).length+Object.keys(_registryForeign).length
	}
	
	// increment sequence number of request
	function _step() {
		_sequenceNumber++;
		if (_sequenceNumber > 2000000000) _sequenceNumber = 0;
		return _sequenceNumber;
	}
	
	// queue a write request
	self._write = function(queueElements) {
		if (queueElements instanceof Array) _queue = _queue.concat(queueElements)
		else _queue.push(queueElements);
		if (_outputReady) _shift()
	}
		
	_outputStream.on('drain', function() {
		_outputReady = true;
		_shift();
	});
	
	// when one of the streams has been closed, close all other streams and remove data associated with the streams
	self.close = function(number, foreign, timeout) {
		var reg = (foreign ? _registryForeign : _registry);
		if (number in reg) {
			// notify other side
			self._write(_frameHeader(CLOSED+(foreign ? RESPONSE : 0), number, 0));
			var entry = reg[number]
			// delete registry
			tracer && tracer("Delete registry "+number+" foreign "+foreign)
			delete reg[number];					
			// destroy streams
			_destroyStreams(entry, timeout);
		}	

	}

	// destroy the two streams which are locally associated with this request.
	// For timeout send a small response.
	// The streams are destroyed in such a way that the self.close method of the client/server is not called any more
	function _destroyStreams(entry, timeout) {
		if (entry[0]) {
			entry[0]._destroyInt(true);
		} else {
			// add a dummy response
			var callback = entry[2];
			if (callback) {
				// construct dummy response with non existent number
				var readableStream = new ReadableMockStream({ statusCode: (timeout ? 408 : 500) }, -1, self, RESPONSE);
				tracer && tracer("Create readable stream on caller for dummy callback "+timeout)
				// dummy response
				if (timeout) {
					readableStream.frame("Timeout", true);							
					callback(readableStream);																	
				} else {
					callback(readableStream);
					process.nextTick(function() {
						readableStream._destroyInt(true); // destroy without calling close() function of mock again
					})
				}
			}
		}
		if (entry[1]) entry[1]._destroyInt(true); // destroy without calling close() function of mock again
	}
	
	// delete registry entry (to be invoked by the writable mock stream upon end)
	self._deleteRegistry = function(number, foreign) {
		tracer && tracer("Delete registry entry "+number+" "+foreign)
		if (foreign) delete _registryForeign[number];
		else delete _registry[number]; 
	}
	
	// mechanism will break when _inputStream/_outputStream does not work any more	
	function globalError(exception) {
		exception = exception || new Error("Stream finished")
		_globalError = exception;
		for (var number in _registry) {
			var entry = _registry[number];
			if (entry[0]) { // readableStream, writableStream, call back function
				entry[0].emit('error', exception);
			}
			if (entry[1]) { // readableStream, writableStream, call back function
				entry[1].emit('error', exception);
			}
			if (entry[3]) { // ping callback
				process.nextTick(function() { return entry[3](_globalError); });
			}
			_destroyStreams(entry)
		}
		for (var number in _registryForeign) {
			var entry = _registry[number];
			if (entry[0]) { // readableStream, writableStream, call back function
				entry[0].emit('error', exception);
			}
			if (entry[1]) { // readableStream, writableStream, call back function
				entry[1].emit('error', exception);
			}				
			_destroyStreams(entry)
		}
		_registry = {};
		_registryForeign = {};
	}
	
	_outputStream.on('error', globalError)
	_inputStream.on('error', globalError)
	_inputStream.on('end', globalError)
	_inputStream.on('close', globalError)

	// shift as much data to the output stream as possible
	function _shift() {
		tracer && tracer("SHIFT "+_queue.length)
		while (_outputReady && _queue.length > 0) {			
			var streamElement = _queue.shift();
			_outputReady = _outputStream.write(streamElement);				
		}
	}

	/// ### Mock.ping()
	/// Send a dummy request to the server with will be answered as fast as possible by the server.
	/// The result is the time in milliseconds for the whole request
	/// The optional timeout parameter gives a timeout after which the request will be aborted (with an error)
	/// This timeout does not have to do anything with the timeout in the Mock constructor.
	self.ping = function(callback, timeout) {
		if (!callback) return fut.future(self.ping, arguments, 0);
		if (_globalError) {
			return callback(_globalError);
		}
		var currentRequest = _step();
		
		_registry[currentRequest] = [null, null, null, callback, Date.now()];
		self._write(_frameHeader(PING, currentRequest, 0));
		if (timeout > 0) {
			setTimeout(function() {
				tracer && tracer("Timeout function")
				if (currentRequest in _registry) {
					tracer && tracer("Timeout reached")
					callback(new Error("Timeout after "+timeout+" milliseconds"))
					tracer && tracer("Delete registry on timeout "+currentRequest)
					delete _registry[currentRequest];
				}
			}, timeout);			
		}
	}
	
	// start a new client request. The options will be passed to the server
	// the responseCallback will be invoked with the corresponding readable stream with data from the server
	self.request = function(options, responseCallback) {		
		var currentRequest = _step(); // number used throughout the current request
		tracer && tracer("Start request for number "+currentRequest)
		// replace path with url
		if ('path' in options && !('url' in options)) {
			options.url = options.path
			delete options.path;
		}
		var writable = new WritableMockStream(options, currentRequest, self, 0);
		// registry content is array of readableStream, writableStream, call back function
		// readable stream not yet known (and important) at the moment - only on first response from server
		_registry[currentRequest] = [null, writable, responseCallback];
		// set timeout
		var timeout = (clientOptions && clientOptions.timeout) || 0; 
		tracer && tracer("Timeout in seconds "+timeout)
		if (timeout) {
			setTimeout(function() {
				self.close(currentRequest, false, true); // Timeout!
			}, timeout*1000)
		}
		return writable;
	}

	
	// process data of complete frame
	self._chunkProcessing = function(headerType, headerNumber, data) {
		// does this header belong to a request or to a response?
		var responseHeader = !!(headerType & RESPONSE);
		if (responseHeader) {
			tracer && tracer("Response header")
			headerType &= ~RESPONSE;
		}
		// special headers
		if (headerType & SPECIAL) {
			switch (headerType) {
			case CONFIRMATION: // return message header: data has been processed, more data can come
				tracer && tracer("Receive confirmation header for "+headerNumber+" response "+!!responseHeader)
				var reg = (responseHeader ? _registryForeign : _registry);
				if (headerNumber in reg) {
					var writable = reg[headerNumber][1];
					if (!writable) throw new Error ("No Writable stream");
					// stream can receive more data
					writable._markFree();					
				} else {
					tracer && tracer("Ignore confirmation header for "+headerNumber+" response "+!!responseHeader)
				}
				break;
			case PING: // ping request just to see whether server is reachable
				tracer && tracer("Receive confirmation header for "+headerNumber+" response "+!!responseHeader)
				if (responseHeader) {
					if (headerNumber in _registry) {
						var callback = _registry[headerNumber][3];
						var time = 1*_registry[headerNumber][4];
						if (!callback) throw new Error ("No callback available");
						if (_globalError) return callback(_globalError)
						tracer && tracer("Delete ping registry "+headerNumber)
						delete _registry[headerNumber];
						return callback(null, Date.now()-time);										
					} else {
						// entry has already been removed because of timeout
						tracer && tracer("Timeout for ping request "+headerNumber);						
					}
				} else { // just answer with ping response header
					self._write(_frameHeader(PING+RESPONSE, headerNumber, 0));
				}
				break;
			case CLOSED: // connection has been closed
				tracer && tracer("Receive close header for "+headerNumber+" response "+!!responseHeader)
				var reg = (responseHeader ? _registry : _registryForeign);
				if (headerNumber in reg) {
					var entry = reg[headerNumber]
					tracer && tracer("Delete registry on close "+headerNumber+" foreign "+!responseHeader)					
					delete reg[headerNumber];
					_destroyStreams(entry)
				}
				break;
			default:
				throw new Error("Wrong special header "+headerType)
			}
		} else {
			if (headerType & STARTFRAME) { // start frame
				var headerData = JSON.parse(data.toString("utf8"));
				if (!responseHeader) {// on server
					tracer && tracer("Receive header frame on callee for "+headerNumber)
					// registry contains readable stream, writable stream and call back function
					var readableStream = new ReadableMockStream(headerData, headerNumber, self, 0);
					var writableStream = new WritableMockStream(null, headerNumber, self, RESPONSE);
					_registryForeign[headerNumber] = [readableStream, writableStream]
					self.emit('request', readableStream, writableStream);					
				} else {
					// on client: call callback function
					if (headerNumber in _registry) {
						var readableStream = new ReadableMockStream(headerData, headerNumber, self, RESPONSE);
						tracer && tracer("Create readable stream on caller and call callback for "+headerNumber+" hdata "+util.format(headerData))
						var callback = _registry[headerNumber][2];
						_registry[headerNumber][0] = readableStream;
						if (!callback)
							throw new Error("No callback function on client")
						callback(readableStream);											
					} else {
						tracer && tracer("Ignore start frame from server for "+headerNumber+" hdata "+util.format(headerData))
					}
				}
			} else { // subsequent frame
				if (!data) data = new Buffer(0);
				tracer && tracer("Receive data frame for "+headerNumber+" response "+responseHeader)
				var reg = (responseHeader ? _registry : _registryForeign)
				if (headerNumber in reg) {
					var readableStream = reg[headerNumber][0];
					if (headerType & ENDMARKER) { // end frame
						tracer && tracer("End frame for "+headerNumber)
						readableStream.frame(data, true);
						// on caller there is nothing to do after this any more: delete data from registry
						if (responseHeader) {
							tracer && tracer("Delete registry on caller for "+headerNumber)
							delete _registry[headerNumber];
						}
					} else {
						readableStream.frame(data, false); 					
					}									
				} else {
					tracer && tracer("Ignore data frame for "+headerNumber+" response "+responseHeader)
				}
			}
		}
	}

	// these variables are only interesting for the following function
	var _currentHeaderType; // type of current header
	var _currentHeaderNumber; // request number of current header
	var _remainingBytes = HEADERLENGTH;
	var _partialChunks = []; // when input stream delivers short chunks which are only part of header or frame data, store the parts here temporarily
	var _header = true;      // header data expected 
	
	// read from stream
	_inputStream.on('data', function(chunk) {
		var chunkLength = chunk.length;
		var chunkRemaining = chunkLength;
		while (chunkRemaining > 0) {
			// not enough data
			if (chunkRemaining < _remainingBytes) {
				_partialChunks.push(chunk.slice(chunkLength-chunkRemaining));
				_remainingBytes -= chunkRemaining;
				return;				
			}
			// can complete header/data
			var b = chunk.slice(chunkLength-chunkRemaining, chunkLength-chunkRemaining+_remainingBytes);
			chunkRemaining -= _remainingBytes;
			_remainingBytes = 0;
			// add other chunks
			if (_partialChunks.length > 0) {
				_partialChunks.push(b);
				b = Buffer.concat(_partialChunks);
				_partialChunks.length = 0;
			}
			if (_header) { // end of new frame header
				_currentHeaderType = b[0];
				_currentHeaderNumber = b.readUInt32LE(5); 
				_remainingBytes = b.readUInt32LE(1);
				if (_remainingBytes > 0) {
					_header = false;					
				} else {
					self._chunkProcessing(_currentHeaderType, _currentHeaderNumber, null);
					_remainingBytes = HEADERLENGTH;
				}
			} else {
				_header = true; // data for next header
				_remainingBytes = HEADERLENGTH;
				self._chunkProcessing(_currentHeaderType, _currentHeaderNumber, b);
			}
		}
	});
	
}
util.inherits(Mock, events.EventEmitter);



function ReadableMockStream(options, number, mock, resp) {
	tracer && tracer("RMS "+util.format(options))
	var self = this;
	self.writable = false;
	self.readable = true;
	stream.Stream.call(this);
	// copy static information
	tracer && tracer("Options "+util.format(options))
	exports.extractDataFromRequest(options, self);
	self.headers = self.headers || {} 
	tracer && tracer("Attributes "+util.format(self))
	var _response = resp; // does this stream belong to a response?
	var _number = number; // sequence number
	var _encoding = null;
	var _remainingBytes = 0;
	var _remainingBuffer = null;
	var _paused = false; // 'pause' has been called, but not yet 'resume'
	var _chunk = null;
	var _ended = false; // if set, 'end' should be emitted. 
	var _mock = mock;
	self.socket = {};
	
	self.pause = function() {
		tracer && tracer(!!_response+"--- Stream pause "+_number)
		_paused = true;
	}

	self.resume = function() {
		tracer && tracer(!!_response+"--- Stream resume "+_number)
		_paused = false;
		if (_chunk)	_processData();
		else {
			if (_ended) _processEnd();
		}
	}

	self.destroy = function() {
		self._destroyInt();
	}

	self._destroyInt = function(local) {
		if (self.readable) {
			self.readable = false;
			if (!local) _mock.close(_number, !resp)
			
			self.emit('close');
			tracer && tracer(_number+" readstream destroy local "+local+ " response "+!!resp)
		}
	}

	function _processEnd() {
		process.nextTick(function() {
			if (!_paused && self.readable) {
				tracer && tracer("Process end event for "+_number)
				self.emit('end');				
			}
		})
		// no confirmation necessary for end event
	}
	
	function _processData() {
		process.nextTick(function() {
			if (!_paused && self.readable) {
				tracer && tracer(!!_response+"Process data event for "+_number+ " "+util.format(_chunk))
				if (_chunk.length > 0) {
					if (_encoding) {
						// try whether buffer can be converted completely to string
						if (_remainingBuffer) {
							_chunk = Buffer.concat([_remainingBuffer, _chunk])
							_remainingBuffer = null;
						}
						var remaining = exports.bufferEncoding(_chunk, _encoding)
						if (remaining) {
							var start = _chunk.length-remaining
							if (start === 0) {
								_remainingBuffer = _chunk;
								// it does not make sense to send an empty string to the listeners - therefore no 'emit'
							} else {
								_remainingBuffer = _chunk.slice(_chunk.length-remaining);
								var text = _chunk.slice(0, _chunk.length-remaining).toString(_encoding);
								// transmit the data
								self.emit('data', text)
							}
						} else {
							var text = _chunk.toString(_encoding);
							self.emit('data', text);	
						}
					} else self.emit('data', _chunk);
				}
				_chunk = null;							
			}
			if (!_ended) { // no confirmation with end event
				tracer && tracer("Data event with confirmation for "+_number)
				_mock._write(_frameHeader(CONFIRMATION+_response, _number, 0));			
			} else {
				_processEnd();
			}
		})
	}

	// write data of this frame to receiving stream (emit 'data' event)
	// end: also emit end event
	self.frame = function(data, end) 
	{
		tracer && tracer("Frame function "+end+" "+_paused)
		if (_chunk) throw new Error("Already chunk present "+_response+"--"+util.format(_chunk));
		_ended = end;
		_chunk = data;
		if (!_paused) {
			if (data) _processData()
			else {
				if (end) _processEnd();
			}
		}
	}

	self.setEncoding = function(encoding) {
		// normalize the encoding
		_encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, '');	
	}
	
}
util.inherits(ReadableMockStream, stream.Stream);



 
function WritableMockStream(options, number, mock, resp) {
	var self = this;
	self.writable = true;
	self.readable = false;
	stream.Stream.call(this);
	var _options = options || { headers: {}, statusCode: 200, sendDate: true };
	self._options = _options;
	var _response = resp; // does this stream belong to a response?
	var _number = number; // sequence number of request
	var _mock = mock; // mock client or mock server
	var _chunk = null;
	var _used = false; // currently no all data have been totally processed
	var _finished = 0; // 0: end has not yet been called, 1: end has been called, 2: end header has been sent
	

	self.write = function(data, enc, end) {
		tracer && tracer(_number+"---------- WRITE "+util.format(data)+" "+enc+" "+end+"--"+_used)
		if (!self.writable) {
			tracer && tracer(_number+" ignore write on closed stream")
			return;
		}
		if (_used) throw new Error(_number+"Data left");
		if (end) {
			if (!_finished) _finished = 1
		} else {
			if (_finished) throw new Error(_number+"No writes after end");
		}
		if (!data) data = new Buffer(0);		
		tracer && tracer(_number+"DATA ????? "+util.format(data))
		if (!Buffer.isBuffer(data)) {
			if (!enc) enc = "utf8";
			data = new Buffer(""+data, enc);
		}
		var list = [];
		if (_options) {
			tracer && tracer(_number+"Send frame header for "+_number)
			var content = new Buffer(JSON.stringify(_options), "utf8")
			list.push(_frameHeader(STARTFRAME+_response, _number, content.length), content);
			_options = null;
		}
		if (data.length > 0) {
			tracer && tracer("Send data frame for "+_number)
			list.push(_frameHeader(_response+ (end ? ENDMARKER : 0), _number, data.length), data);
		} else {
			list.push(_frameHeader(_response+ (end ? ENDMARKER : 0), _number, 0));
		}
		_mock._write(list);
		if (end && _response) { 
			_mock._deleteRegistry(_number, true);
		}
		_used = true;
		return false;
	}

	self.end = function(data, enc) {
		tracer && tracer(_number+"ENDDATA --- <"+data+">")
		if (_finished) {
			tracer && tracer("Ignore second end call")
			return; // ignore
		}
		_finished = 1;
		if (!_used) self.write(data, enc, true);
	}
	
	self.destroy = function() {
		self._destroyInt();
	}

	self._destroyInt = function(local) {
		if (self.writable) {
			self.writable = false;
			if (!local) _mock.close(_number, resp)
			self.emit('close');
			tracer && tracer(_number+" write stream destroy local "+local+" response "+!!resp)

		}
	}

	self._markFree = function() {
		tracer && tracer("Mark stream as free again "+_number)
		_used = false;
		tracer && tracer(_number+"USED "+_used+" fin "+_finished)
		if (!_finished) self.emit('drain'); // more data can come unless 'end' has already been called
		else {
			if (_finished === 1) self.write(null, null, true);
		}
	}
	
	// methods of HttpServerResponse
	self.writeHead = function(statusCode) {
		var reasonPhrase;
		var headers;
		switch (arguments.length) {
		case 3:
			reasonPhrase = arguments[1];
			headers = arguments[2];
			break;
		case 2:
			headers = arguments[1]
			break;
		default:
			break;
		}
		if (headers) {
			self._options.headers = headers;
			self._options.writeHeadCalled = true;
		}
		if (reasonPhrase) self._options.reasonPhrase = reasonPhrase;
		self._options.statusCode = statusCode;

	}
	
	
	// set/get the status code directly within the options property
	
	self.__defineSetter__("statusCode", function(code) { self._options.statusCode = code });	
	self.__defineGetter__("statusCode", function() { return self._options.statusCode });

	self.__defineSetter__("sendDate", function(val) { self._options.sendDate = val });	
	self.__defineGetter__("sendDate", function() { return self._options.sendDate });

	self.setHeader = function(name, value) {
		self._options.headers[name] = value;
	}
	
	self.getHeader = function(name) {
		return self._options.headers[name];
	}
	
	self.removeHeader = function(name) {
		delete self._options.headers[name];
	}
	
}

util.inherits(WritableMockStream, stream.Stream);


/// finds out whether the last multibyte character of this buffer is complete. If not, it returns the number of bytes of this 
/// incomplete character. The function assumes that the buffer contains a part of correctly encoded data.
/// the function assumes that the encoding is already normalized!
function bufferEncoding(buffer, enc) {
	var length = buffer.length;
	switch (enc) {
	case "utf8":
		if (!(buffer[length-1] & 0x80)) return 0; // single byte character at end
		var i = length-1;
		var testbyte = 0x40;
		for (var i=1; i<= length; i++) {
			var byte = buffer[length-i];
			// there cannot be a single byte character directly before a group of non-leading bytes of a multibyte character 
			if (!(byte & 0x80)) throw new Error("Invalid UTF8");
			if (byte & 0x40) { // leading byte
				return (byte & testbyte) ? i : 0; // incomplete sequence when test byte is also set
			} 
			testbyte >>= 1;	
		}
		// just sequence of non-leading bytes
		return length;
	case "utf16le":
	case "ucs2":
		return (length & 0x01); // number of bytes must be even
	case "hex":
	case "ascii":
		return 0;
	default:
		throw new Error("Wrong encoding "+enc);
	}
}


// builds the frame header out of type, number, length.
// for a frame header with end marker, the property "mockEndMarker" is set on the buffer.
function _frameHeader(type, number, length) {
	tracer && tracer("Header type "+type+" number "+number+" length "+length)
	var b = new Buffer(HEADERLENGTH);
	b[0] = type;
	b.writeUInt32LE(length, 1);
	b.writeUInt32LE(number, 5);
	if (type & ENDMARKER) b.mockEndMarker = true;
	return b;	
}

/// ## MockStreamServer
/// This class emulates Streamline's HttpServer. The requests and responses are taken from the mock mechanism but are wrapped within
/// Streamline's HttpServerRequest, HttpServerResponse.
/// parameters: 
/// - disp: request dispatcher function
/// - outputStream: stream to write data to other mock (e. g. process.stdout)
/// - inputStream: stream to get data from other mock (e. g. process.stdin)
/// - clientOptions: options for mock (mainly: timeout)
/// - options: options which will be passed to Streamline's HttpServerRequest, HttpServerResponse
exports.MockStreamServer = function(disp, outputStream, inputStream, clientOptions, options) { 
	var self = this;
	var dispatcher = function(request, response) {
		tracer && tracer("+++++++++++++++++++++++++++++Request")
		globals.context = {};
		return disp(new streams.HttpServerRequest(request, options), new streams.HttpServerResponse(response, options), function(err) {
			if (err) {
				response.writeHead(500, {
					"Content-Type": "text/plain"
				});
				response.end(err.message + "\n" + err.stack);
			}
		})
	};
/// The listen method will start the server and resume the input stream
/// Parameters: callback function
	self.listen = function(callback) {
		tracer && tracer("Listen")
		try {
			self.mockClient = new Mock(outputStream, inputStream, dispatcher, clientOptions);
			inputStream.resume();
			tracer && tracer("LISTEN start")
			return callback();
		} catch (e) {
			return callback(e);
		}
	} 
}

/// ## MemoryStream
/// this class is a writable stream which appends all data to a string (content field). It emulates the HttpResponse methods writeHead etc.
function MemoryStream() {
	var self = this;
	stream.Stream.call(this);
	self.writable = true;
	self.content = "";
	self._options = [];
	self.ended = false;
	self.write = function(data) {
		self.content += data;
		return true;
	}
	self.end = function(data) {
		if (data) self.content += data;
		self.ended = true;
	}
	self.writeHead = function(statusCode) {
		var reasonPhrase;
		var headers;
		switch (arguments.length) {
		case 3:
			reasonPhrase = arguments[1];
			headers = arguments[2];
			break;
		case 2:
			headers = arguments[1]
			break;
		default:
			break;
		}
		if (headers) {
			self._options.headers = headers;
			self._options.writeHeadCalled = true;
		}
		if (reasonPhrase) self._options.reasonPhrase = reasonPhrase;
		self._options.statusCode = statusCode;

	}
	
	return self;
	
	// set/get the status code directly within the options property
	
	self.__defineSetter__("statusCode", function(code) { self._options.statusCode = code });	
	self.__defineGetter__("statusCode", function() { return self._options.statusCode });

	self.__defineSetter__("sendDate", function(val) { self._options.sendDate = val });	
	self.__defineGetter__("sendDate", function() { return self._options.sendDate });

	self.setHeader = function(name, value) {
		self._options.headers[name] = value;
	}
	
	self.getHeader = function(name) {
		return self._options.headers[name];
	}
	
	self.removeHeader = function(name) {
		delete self._options.headers[name];
	}
}
util.inherits(MemoryStream, stream.Stream);

exports.MemoryStream = MemoryStream;


//convenience function: send a request to a server with same options as above self.request, but already as an asynchronous function.
//returns the content of the return stream or throws an exception in case of an error
function simpleRequest(client, options, content, callback) {
	if (!callback) return fut.future(simpleRequest, arguments, 3);
	var result = "";
	var answered = false;
	var req = client.request(options, function(res) {
		res.setEncoding("utf8");
		res.on("data", function(chunk) {
			result += chunk;
		});
		res.on("end", function(chunk) {
			if (!answered) {
				answered = true;
				if (res.statusCode === 200) {
					return callback(null, result);
				} else {
					return callback(result);				
				}				
			}
		});
		res.on('close', function() {
			if (!answered) {
				answered = true;
				return callback('Connection closed')
			}
		})
	});
	req.on("error", function(error) {
		if (!answered) {
			answered = true;
			return callback(error);
		}		
	});
	if (content) req.end(content);
	else req.end();
}
exports.simpleRequest = simpleRequest;


exports.bufferEncoding = bufferEncoding; 


// for unit tests
exports._frameHeader = _frameHeader;
exports._WritableMockStream = WritableMockStream; 


