//
var stream = require('stream')
var events = require('events')
var streams = require('streamline/lib/streams/streams');
var globals = require('streamline/lib/globals');
var util = require('util')
/// Pass HTTP requests and responses through a pipe
// Internal processing:
// Each request/response gets an sequence number so that parallel requests/responses can be distinguished.
// An HTTP request/response contains headers etc. - in the sequel this will be called "metadata" and a stream of data
// Whenever metadata or a chunk of data is transferred, there is a header first which tells about the kind of data and
// the byte length and the the sequence number.
// The client listens on a readable stream. When the first data come, the metadata and the first chunk of data will be transferred
// to the client and the requestListener on the server will be invoked. For each chunk of data, a confirmation header will be sent back.
// The writable stream of the client (and server) will not accept further data until the confirmation has been received.
// Upon the 'end' event of the readable stream on the client, the header will contain an end marker. Since no more data are to come, there
// will not be a confirmation for this.
// the mock http request on the server tries to imitate the original http request: it contains its headers, url, method, http version and
// a readable stream, but the connection attribute is empty except for an 'authorized' property to detect SSL connections.
// the mock http response on the server tries to imitate the original http response. it contains its set/remove header methods, the writeHead
// method, statusCode, but the writeContinue() method is not implemented at the moment.
// Indeed, 'client' and 'server' are just to make things clearer - the 'server' can also issue requests to the client (the client should have 
// a request handler for this), even within processing a request from the client.
// The only difference is that the client uses even request numbers and the server odd numbers.


var ENDMARKER = 0x02;
var SPECIAL = 0x40;
var CONFIRMATION = SPECIAL
var RESPONSE = 0x80; // marks that this is a response
var HEADERLENGTH = 9
var STARTFRAME = 0x01

// copies attributes from HttpServerRequest to the target (or to a newly created object) and returns the target
// reasonPhrase: not official attribute, but used to transfer reason phrase to client
// _writeHeadCalled: indicates that 
exports.extractDataFromRequest = function(source, target) {
	target = target || {};
	["sendDate", "_writeHeadCalled", "headers", "httpVersion", "httpVersionMajor", "httpVersionMinor", "url", "method", "reasonPhrase", "statusCode"].forEach(function(key) {
		if (key in source) target[key] = source[key];
	})
	if ("connection" in source) {
		target.connection = {};
		if ("authorized" in source.connection) target.connection.authorized = source.connection.authorized;		
	}
	return target;
}


exports.Mock = Mock;
function Mock(outputStream, inputStream, requestHandler) {
	events.EventEmitter.call(this);
	console.log("MOCKMOCK "+outputStream)
	var self = this;
	var _sequenceNumber = 0;
	var _registry = {}; // contains all data for the current request. Key is the request sequence number, values are arrays of readableStream, writableStream, call back function
	var _registryForeign = {}; // contains all data for the foreign request which is processed here.
	// contains the instances of writable stream which want to write data
	var _queue = [];
	// input stream of child: to this the data will be written
	var _outputStream = outputStream;
	// child stream is writable? 
	var _outputReady = true;
	// output stream of child: return data
	var _inputStream = inputStream;
	// has a global error occurred?
	var _globalError
	
	 if (requestHandler) {
		 this.addListener('request', requestHandler);
	}
	
	// increment sequence number of request
	function _step() {
		_sequenceNumber++;
		if (_sequenceNumber > 2000000000) _sequenceNumber = 0;
		return _sequenceNumber;
	}
	
	// queue a write request
	self._write = function(queueElements) {
		if (queueElements instanceof Array) _queue = _queue.concat(queueElements)
		else _queue.push(queueElements);
		if (_outputReady) _shift()
	}
		
	_outputStream.on('drain', function() {
		_outputReady = true;
		_shift();
	});
	
	// delete registry entry (to be invoked by the writable mock stream upon end)
	self._deleteRegistry = function(number, foreign) {
		console.log("Delete registry entry "+number+" "+foreign)
		if (foreign) delete _registryForeign[number];
		else delete _registry[number]; 
	}
	
	// mechanism will break when _inputStream/_outputStream does not work any more
	
	function globalError(exception) {
		exception = exception || new Error("Stream finished")
		_globalError = exception;
		for (var number in _registry) {
			var entry = _registry[number];
			if (entry[0]) { // readableStream, writableStream, call back function
				entry[0].emit('error', exception);
			}
			if (entry[1]) { // readableStream, writableStream, call back function
				entry[1].emit('error', exception);
			}				
		}
		for (var number in _registryForeign) {
			var entry = _registry[number];
			if (entry[0]) { // readableStream, writableStream, call back function
				entry[0].emit('error', exception);
			}
			if (entry[1]) { // readableStream, writableStream, call back function
				entry[1].emit('error', exception);
			}				
		}
	}
	
	_outputStream.on('error', globalError)
	_inputStream.on('error', globalError)
	_inputStream.on('end', globalError)

	// shift as much data to the output stream as possible
	function _shift() {
		console.log("SHIFT "+_queue.length)
		while (_outputReady && _queue.length > 0) {			
			var streamElement = _queue.shift();
			_outputReady = _outputStream.write(streamElement);				
		}
	}
	
	// start a new client request. The options will be passed to the server
	// the responseCallback will be invoked with the corresponding readable stream with data from the server
	self.request = function(options, responseCallback) {		
		var currentRequest = _step(); // number used throughout the current request
		console.log("Start request for number "+currentRequest)
		var writable = new WritableMockStream(options, currentRequest, self, 0);
		// registry content is array of readableStream, writableStream, call back function
		// readable stream not yet known (and important) at the moment - only on first response from server
		_registry[currentRequest] = [null, writable, responseCallback];
		// notify about connection start
		process.nextTick(function() { 
			if (_globalError) writable.emit('error', _globalError)
			else writable.emit('socket')
		})
		return writable;
	}
	
	
	// process data of complete frame
	self._chunkProcessing = function(headerType, headerNumber, data) {
		// does this header belong to a request or to a response?
		var responseHeader = !!(headerType & RESPONSE);
		if (responseHeader) {
			console.log("Response header")
			headerType &= ~RESPONSE;
		}
		// special headers
		if (headerType & SPECIAL) {
			switch (headerType) {
			case CONFIRMATION: // return message header: data has been processed, more data can come
				console.log("Receive confirmation header for "+headerNumber+" response "+responseHeader)
				var reg = (responseHeader ? _registryForeign : _registry);
				if (headerNumber in reg) {
					var writable = reg[headerNumber][1];
					if (!writable) throw new Error ("No Writable stream");
					// stream can receive more data
					writable._markFree();					
				} else {
					console.log("Ignore confirmation header for "+headerNumber+" response "+responseHeader)
				}
				break;
			default:
				throw new Error("Wrong special header "+headerType)
			}
		} else {
			if (headerType & STARTFRAME) { // start frame
				var headerData = JSON.parse(data.toString("utf8"));
				if (!responseHeader) {// on server
					console.log("Receive header frame on callee for "+headerNumber)
					// registry contains readable stream, writable stream and call back function
					var readableStream = new ReadableMockStream(headerData, headerNumber, self, 0);
					var writableStream = new WritableMockStream(null, headerNumber, self, RESPONSE);
					_registryForeign[headerNumber] = [readableStream, writableStream]
					self.emit('request', readableStream, writableStream);					
				} else {
					// on client: call callback function
					var readableStream = new ReadableMockStream(headerData, headerNumber, self, RESPONSE);
					console.log("Create readable stream on caller and call callback for "+headerNumber+" hdata "+util.format(headerData))
					var callback = _registry[headerNumber][2];
					_registry[headerNumber][0] = readableStream;
					if (!callback)
						throw new Error("No callback function on client")
					callback(readableStream);					
				}
			} else { // subsequent frame
				if (!data) data = new Buffer(0);
				console.log("Receive data frame for "+headerNumber+" response "+responseHeader)
				var reg = (responseHeader ? _registry : _registryForeign)
				if (headerNumber in reg) {
					var readableStream = reg[headerNumber][0];
					if (headerType & ENDMARKER) { // end frame
						console.log("End frame for "+headerNumber)
						readableStream.frame(data, true);
						// on caller there is nothing to do after this any more: delete data from registry
						if (responseHeader) {
							console.log("Delete registry on caller for "+headerNumber)
							delete _registry[headerNumber];
						}
					} else {
						readableStream.frame(data, false); 					
					}									
				} else {
					console.log("Ignore data frame for "+headerNumber+" response "+responseHeader)
				}
			}
		}
	}

	// these variables are only interesting for the following function
	var _currentHeaderType; // type of current header
	var _currentHeaderNumber; // request number of current header
	var _remainingBytes = HEADERLENGTH;
	var _partialChunks = []; // when input stream delivers short chunks which are only part of header or frame data, store the parts here temporarily
	var _header = true;      // header data expected 
	
	// read from stream
	_inputStream.on('data', function(chunk) {
		var chunkLength = chunk.length;
		var chunkRemaining = chunkLength;
		while (chunkRemaining > 0) {
			// not enough data
			if (chunkRemaining < _remainingBytes) {
				_partialChunks.push(chunk.slice(chunkLength-chunkRemaining));
				_remainingBytes -= chunkRemaining;
				return;				
			}
			// can complete header/data
			var b = chunk.slice(chunkLength-chunkRemaining, chunkLength-chunkRemaining+_remainingBytes);
			chunkRemaining -= _remainingBytes;
			_remainingBytes = 0;
			// add other chunks
			if (_partialChunks.length > 0) {
				_partialChunks.push(b);
				b = Buffer.concat(_partialChunks);
				_partialChunks.length = 0;
			}
			if (_header) { // end of new frame header
				_currentHeaderType = b[0];
				_currentHeaderNumber = b.readUInt32LE(5); 
				_remainingBytes = b.readUInt32LE(1);
				if (_remainingBytes > 0) {
					_header = false;					
				} else {
					self._chunkProcessing(_currentHeaderType, _currentHeaderNumber, null);
					_remainingBytes = HEADERLENGTH;
				}
			} else {
				_header = true; // data for next header
				_remainingBytes = HEADERLENGTH;
				self._chunkProcessing(_currentHeaderType, _currentHeaderNumber, b);
			}
		}
	});
	
}
util.inherits(Mock, events.EventEmitter);



function ReadableMockStream(options, number, mock, resp) {
	console.log("RMS "+util.format(options))
	var self = this;
	self.writable = false;
	self.readable = true;
	stream.Stream.call(this);
	// copy static information
	console.log("IIIIIIIIIIIII "+util.format(options))
	exports.extractDataFromRequest(options, self);
	console.log("<<<<<< "+self.statusCode)
	var _response = resp; // does this stream belong to a response?
	var _number = number; // sequence number
	var _encoding = null;
	var _remainingBytes = 0;
	var _remainingBuffer = null;
	var _paused = false; // 'pause' has been called, but not yet 'resume'
	var _chunk = null;
	var _ended = false; // if set, 'end' should be emitted. 
	var _mock = mock;
	self.socket = {};
	
	self.pause = function() {
		console.log(!!_response+"--- Stream pause "+_number)
		_paused = true;
	}

	self.resume = function() {
		console.log(!!_response+"--- Stream resume "+_number)
		_paused = false;
		if (_chunk)	_processData();
		else {
			if (_ended) _processEnd();
		}
	}

	function _processEnd() {
		process.nextTick(function() {
			if (!_paused) {
				console.log("Process end event for "+_number)
				self.emit('end');				
			}
		})
		// no confirmation necessary for end event
	}
	
	function _processData() {
		process.nextTick(function() {
			if (!_paused) {
				console.log(!!_response+"Process data event for "+_number+ " "+util.format(_chunk))
				if (_chunk.length > 0) {
					if (_encoding) {
						// try whether buffer can be converted completely to string
						if (_remainingBuffer) {
							_chunk = Buffer.concat([_remainingBuffer, _chunk])
							_remainingBuffer = null;
						}
						var remaining = exports._bufferEncoding(_chunk, _encoding)
						if (remaining) {
							var start = _chunk.length-remaining
							if (start === 0) {
								_remainingBuffer = _chunk;
								// it does not make sense to send an empty string to the listeners - therefore no 'emit'
							} else {
								_remainingBuffer = _chunk.slice(_chunk.length-remaining);
								var text = _chunk.slice(0, _chunk.length-remaining).toString(_encoding);
								// transmit the data
								self.emit('data', text)
							}
						} else {
							var text = _chunk.toString(_encoding);
							self.emit('data', text);	
						}
					} else self.emit('data', _chunk);
				}
				_chunk = null;							
			}
			if (!_ended) { // no confirmation with end event
				console.log("Data event with confirmation for "+_number)
				_mock._write(_frameHeader(CONFIRMATION+_response, _number, 0));			
			} else {
				_processEnd();
			}
		})
	}

	// write data of this frame to receiving stream (emit 'data' event)
	// end: also emit end event
	self.frame = function(data, end) 
	{
		console.log("Frame function "+end+" "+_paused)
		if (_chunk) throw new Error("Already chunk present "+_response+"--"+util.format(_chunk));
		_ended = end;
		_chunk = data;
		if (!_paused) {
			if (data) _processData()
			else {
				if (end) _processEnd();
			}
		}
	}

	self.setEncoding = function(encoding) {
		// normalize the encoding
		_encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, '');	
	}
	
}
util.inherits(ReadableMockStream, stream.Stream);



 
function WritableMockStream(options, number, mock, resp) {
	var self = this;
	self.writable = true;
	self.readable = false;
	stream.Stream.call(this);
	var _options = options || { headers: {}, statusCode: 200, sendDate: true };
	self._options = _options;
	var _response = resp; // does this stream belong to a response?
	var _number = number; // sequence number of request
	var _mock = mock; // mock client or mock server
	var _chunk = null;
	var _used = false; // currently no all data have been totally processed
	var _finished = false; // end has been called
	

	self.write = function(data, enc, end) {
		console.log("---------- WRITE "+util.format(data)+" "+enc+" "+end)
		if (_used) throw new Error("Data left");
		if (end) _finished = true
		else {
			if (_finished) throw new Error("No writes after end");
		}
		if (!data) data = new Buffer(0);		
		console.log("DATA ????? "+util.format(data))
		if (!Buffer.isBuffer(data)) {
			if (!enc) enc = "utf8";
			data = new Buffer(""+data, enc);
		}
		var list = [];
		if (_options) {
			console.log("Send frame header for "+_number)
			var content = new Buffer(JSON.stringify(_options), "utf8")
			list.push(_frameHeader(STARTFRAME+_response, _number, content.length), content);
			_options = null;
		}
		if (data.length > 0) {
			console.log("Send data frame for "+_number)
			list.push(_frameHeader(_response+ (end ? ENDMARKER : 0), _number, data.length), data);
		} else {
			list.push(_frameHeader(_response+ (end ? ENDMARKER : 0), _number, 0));
		}
		_mock._write(list);
		if (end && _response) { 
			_mock._deleteRegistry(_number, true);
		}
		_used = true;
		return false;
	}

	self.end = function(data, enc) {
		console.log("ENDDATA --- <"+data+">")
		if (_finished) {
			console.log("Ignore second end call")
			return; // ignore
		} 
		self.write(data, enc, true);
	}
	
	self._markFree = function() {
		console.log("Mark stream as free again "+_number)
		_used = false;
		if (!_finished) self.emit('drain'); // more data can come unless 'end' has already been called
	}
	
	// methods of HttpServerResponse
	self.writeHead = function(statusCode) {
		var reasonPhrase;
		var headers;
		switch (arguments.length) {
		case 3:
			reasonPhrase = arguments[1];
			headers = arguments[2];
			break;
		case 2:
			headers = arguments[1]
			break;
		default:
			break;
		}
		if (headers) {
			self._options.headers = headers;
			self._options.writeHeadCalled = true;
		}
		if (reasonPhrase) self._options.reasonPhrase = reasonPhrase;
		self._options.statusCode = statusCode;

	}
	
	
	// set/get the status code directly within the options property
	
	self.__defineSetter__("statusCode", function(code) { self._options.statusCode = code });	
	self.__defineGetter__("statusCode", function() { return self._options.statusCode });

	self.__defineSetter__("sendDate", function(val) { self._options.sendDate = val });	
	self.__defineGetter__("sendDate", function() { return self._options.sendDate });

	self.setHeader = function(name, value) {
		self._options.headers[name] = value;
	}
	
	self.getHeader = function(name) {
		return self._options.headers[name];
	}
	
	self.removeHeader = function(name) {
		delete self._options.headers[name];
	}
	
}

util.inherits(WritableMockStream, stream.Stream);


/// finds out whether the last multibyte character of this buffer is complete. If not, it returns the number of bytes of this 
/// incomplete character. The function assumes that the buffer contains a part of correctly encoded data.
/// the function assumes that the encoding is already normalized!
function _bufferEncoding(buffer, enc) {
	var length = buffer.length;
	switch (enc) {
	case "utf8":
		if (!(buffer[length-1] & 0x80)) return 0; // single byte character at end
		var i = length-1;
		var testbyte = 0x40;
		for (var i=1; i<= length; i++) {
			var byte = buffer[length-i];
			// there cannot be a single byte character directly before a group of non-leading bytes of a multibyte character 
			if (!(byte & 0x80)) throw new Error("Invalid UTF8");
			if (byte & 0x40) { // leading byte
				return (byte & testbyte) ? i : 0; // incomplete sequence when test byte is also set
			} 
			testbyte >>= 1;	
		}
		// just sequence of non-leading bytes
		return length;
	case "utf16le":
	case "ucs2":
		return (length & 0x01); // number of bytes must be even
	case "hex":
	case "ascii":
		return 0;
	default:
		throw new Error("Wrong encoding "+enc);
	}
}


// builds the frame header out of type, number, length.
// for a frame header with end marker, the property "mockEndMarker" is set on the buffer.
function _frameHeader(type, number, length) {
	console.log("Header typ "+type+" nr. "+number+" laenge "+length)
	var b = new Buffer(HEADERLENGTH);
	b[0] = type;
	b.writeUInt32LE(length, 1);
	b.writeUInt32LE(number, 5);
	if (type & ENDMARKER) b.mockEndMarker = true;
	return b;	
}

exports.MockStreamServer = function(disp, outputStream, inputStream, options) { 
	var self = this;
	var dispatcher = function(request, response) {
		console.log("+++++++++++++++++++++++++++++Request")
		globals.context = {};
		return disp(new streams.HttpServerRequest(request, options), new streams.HttpServerResponse(response, options), function(err) {
			if (err) {
				response.writeHead(500, {
					"Content-Type": "text/plain"
				});
				response.end(err.message + "\n" + err.stack);
			}
		})
	};
	self.listen = function(callback, port) {
		console.log("Listen")
		self.mockClient = new Mock(outputStream, inputStream, dispatcher);
		inputStream.resume();
		console.log("LISTEN start")
		return callback();		
	} 
}




// for unit tests
exports._frameHeader = _frameHeader;
exports._WritableMockStream = WritableMockStream; 
exports._bufferEncoding = _bufferEncoding; 
