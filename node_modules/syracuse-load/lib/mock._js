"use strict";
/// !doc
/// # Mock API  
var stream = require('stream');
var events = require('events');
var streams = require('streamline/lib/streams/streams');
var globals = require('streamline/lib/globals');
var util = require('util');
var fs = require('fs');
var fut = require('streamline/lib/util/future');
exports.BALANCER_HEADER = "syracusebalancerheader"; // special Http header for passing load balancing information (not used in this file  

//var tracer = console.log
var tracer = null;

/// Pass HTTP requests and responses through a pipe
// Two instances of this Mock class must be connected using two pipes so that bidirectional exchange is possible. Usually this
// is standard input and standard output of a child process. Each side can send a request to the other side which will be processed by
// the request handler on the other side. There is no check that a request handler is available! Since the situation is totally symmetric,
// in the sequel, the side which poses the request, will be called client, the other side server.
// Internal processing:
// Each request/response gets an sequence number so that parallel requests/responses can be distinguished.
// An HTTP request/response contains headers etc. - in the sequel this will be called "metadata" and a stream of data
// (In detail: relevant metadata are: headers, url, method, HTTP version, response code, connection.authorized, connection.getPeerCertificate() 
// (to find out SSL connections and the client certificate. The mocks cannot handle SSL but will transport these two details).
// Whenever metadata or a chunk of data is transferred, there is a header first which tells about the kind of data and
// the byte length and the sequence number.
// The client listens on a readable stream (usually an HTTP request). When the first data come, the metadata and the first chunk of data 
// will be transferred to the client and the requestListener on the server will be invoked. 
// For each chunk of data (except for the final chunk which contains an end marker), a confirmation header will be sent back.
// The writable stream of the client (and server) will not accept further data until the confirmation has been received.
// Upon the 'end' event of the readable stream on the client, the header will contain an end marker. Since no more data are to come, there
// will not be a confirmation for this.
// The last chunk of the response (from server to client) will delete the temporary storage for this sequence number on the server and then 
// on the client. When there is no temporary storage for a sequence number and the header is no start header, it will be ignored on the other side.
// The mock http request on the server tries to imitate the original http request: it contains its headers, url, method, http version and
// a readable stream, but the connection attribute is empty except for 'authorized' and getPeerCertificate() to detect SSL connections.
// the mock http response on the server tries to imitate the original http response. It contains its set/remove header methods, the writeHead
// method, statusCode, but the writeContinue() method is not implemented at the moment.
// There is an optional timeout. When the answer is not complete within the timeout, it will be closed. When there is a close event from
// any side (HTTP request/response), all streams will be finished and the temporary storage for this sequence number will be removed on both sides

// no more input after this 
var ENDMARKER = 0x02;
// special headers have this bit set
var SPECIAL = 0x40;
var CONFIRMATION = SPECIAL;
// ping header for just testing whether server can be reached
var PING = SPECIAL + 1;
// header to inform that the connection has been closed on client side
var CLOSED = SPECIAL + 2;
// header for retrieving detail information about current requests
var DETAILS = SPECIAL + 3;
// marks that this is a response header (originated from the server), can also be a confirmation header back to the server
var RESPONSE = 0x80;
// length of header in bytes
var HEADERLENGTH = 9;
// a non-special header with this bit set is the first header of the connection
var STARTFRAME = 0x01;

// copies attributes from HttpServerRequest to the target (or to a newly created object) and returns the target
// reasonPhrase: not official attribute, but used to transfer reason phrase to client
// _writeHeadCalled: indicates that 
exports.extractDataFromRequest = function(source, target) {
	target = target || {};
	["sendDate", "_writeHeadCalled", "headers", "httpVersion", "httpVersionMajor", "httpVersionMinor", "url", "method", "reasonPhrase", "statusCode"].forEach(function(key) {
		if (key in source) target[key] = source[key];
	});
	if ("connection" in source) {
		target.connection = {};
		if ("authorized" in source.connection) {
			target.connection.authorized = source.connection.authorized;
			target.connection._peerCertificate = source.connection.getPeerCertificate ? source.connection.getPeerCertificate() : source.connection._peerCertificate;
			target.connection.getPeerCertificate = function() {
				return this._peerCertificate;
			};
		}
	}
	return target;
};

/// ## Mock class
/// constructor parameters: outputStream, inputStream, requestHandler and clientOptions
/// clientOptions is an object with the following optional attributes: 
/// timeout: after this time (in seconds), the request data will be deleted
exports.Mock = Mock;

function Mock(outputStream, inputStream, requestHandler, clientOptions) {
	events.EventEmitter.call(this);
	tracer && tracer("MOCK start; client options " + util.format(clientOptions));
	var self = this;
	var _sequenceNumber = 0;
	var _registry = {}; // contains all data for the current request. Key is the request sequence number, values are arrays of readableStream, writableStream, call back function, ping call back function
	var _registryForeign = {}; // contains all data for the foreign request which is processed here.
	// contains the instances of writable stream which want to write data
	var _queue = [];
	// input stream of child: to this the data will be written
	var _outputStream = outputStream;
	// child stream is writable? 
	var _outputReady = true;
	// output stream of child: return data
	var _inputStream = inputStream;
	// has a global error occurred?
	var _globalError;

	if (requestHandler) {
		this.addListener('request', requestHandler);
	}

	// number of current requests
	self.numberRequests = function() {
		tracer && tracer("Open requests own " + util.format(Object.keys(_registry)) + " foreign " + util.format(Object.keys(_registryForeign)));
		return Object.keys(_registry).length + "/" + Object.keys(_registryForeign).length;
	};

	// increment sequence number of request
	function _step() {
		_sequenceNumber++;
		if (_sequenceNumber > 2000000000) _sequenceNumber = 0;
		return _sequenceNumber;
	}

	// queue a write request
	self._write = function(queueElements) {
		if (queueElements instanceof Array) _queue = _queue.concat(queueElements);
		else _queue.push(queueElements);
		if (_outputReady) _shift();
	};

	_outputStream.on('drain', function() {
		_outputReady = true;
		_shift();
	});

	// when one of the streams has been closed, close all other streams and remove data associated with the streams
	self.close = function(number, foreign, timeout) {
		var reg = (foreign ? _registryForeign : _registry);
		if (number in reg) {
			// notify other side
			self._write(_frameHeader(CLOSED + (foreign ? RESPONSE : 0), number, 0));
			var entry = reg[number];
			// delete registry
			tracer && tracer("Delete registry " + number + " foreign " + foreign)
			delete reg[number];
			// destroy streams
			_destroyStreams(entry, timeout);
		}

	};

	self.simpleRequest = function(options, content, callback) {
		return simpleRequest(self, options, content, callback);
	};

	// destroy the two streams which are locally associated with this request.
	// For timeout send a small response.
	// The streams are destroyed in such a way that the self.close method of the client/server is not called any more
	function _destroyStreams(entry, timeout) {
		if (entry[0]) {
			entry[0]._destroyInt(true);
		} else {
			// add a dummy response
			var callback = entry[2];
			if (callback) {
				// construct dummy response with non existent number
				var readableStream = new ReadableMockStream({
					statusCode: (timeout ? 408 : 500)
				}, -1, self, RESPONSE);
				tracer && tracer("Create readable stream on caller for dummy callback " + timeout);
				// dummy response
				if (timeout) {
					readableStream.frame("Timeout", true);
					callback(readableStream);
				} else {
					callback(readableStream);
					process.nextTick(function() {
						readableStream._destroyInt(true); // destroy without calling close() function of mock again
					});
				}
			}
		}
		if (entry[1]) entry[1]._destroyInt(true); // destroy without calling close() function of mock again
	}

	// delete registry entry (to be invoked by the writable mock stream upon end)
	self._deleteRegistry = function(number, foreign) {
		tracer && tracer("Delete registry entry " + number + " " + foreign);
		if (foreign) delete _registryForeign[number];
		else delete _registry[number];
	};

	// mechanism will break when _inputStream/_outputStream does not work any more	
	function globalError(exception) {
		exception = exception || new Error("Stream finished");
		_globalError = exception;
		for (var number in _registry) {
			var entry = _registry[number];
			if (!entry) continue;
			if (entry[0]) { // readableStream, writableStream, call back function
				entry[0].emit('error', exception);
			}
			if (entry[1]) { // readableStream, writableStream, call back function
				entry[1].emit('error', exception);
			}
			if (entry[3]) { // ping callback
				process.nextTick(function() {
					return entry[3](_globalError);
				});
			}
			_destroyStreams(entry);
		}
		for (var number in _registryForeign) {
			var entry = _registry[number];
			if (!entry) continue;
			if (entry[0]) { // readableStream, writableStream, call back function
				entry[0].emit('error', exception);
			}
			if (entry[1]) { // readableStream, writableStream, call back function
				entry[1].emit('error', exception);
			}
			_destroyStreams(entry);
		}
		_registry = {};
		_registryForeign = {};
	}

	_outputStream.on('error', globalError);
	_inputStream.on('error', globalError);
	_inputStream.on('end', globalError);
	_inputStream.on('close', globalError);

	// shift as much data to the output stream as possible
	function _shift() {
		tracer && tracer("SHIFT " + _queue.length);
		while (_outputReady && _queue.length > 0) {
			var streamElement = _queue.shift();
			_outputReady = _outputStream.write(streamElement);
		}
	}

	/// ### Mock.ping()
	/// Send a dummy request to the server with will be answered as fast as possible by the server.
	/// The result is the time in milliseconds for the whole request
	/// The optional timeout parameter gives a timeout after which the request will be aborted (with an error)
	/// This timeout does not have to do anything with the timeout in the Mock constructor.
	self.ping = function(_, timeout) {
		return (function(callback) {
			if (!callback) return fut.future(self.ping, arguments, 0);
			if (_globalError) {
				return callback(_globalError);
			}
			var currentRequest = _step();

			_registry[currentRequest] = [null, null, null, callback, Date.now()];
			self._write(_frameHeader(PING, currentRequest, 0));
			if (timeout > 0) {
				setTimeout(function() {
					tracer && tracer("Timeout function");
					if (currentRequest in _registry) {
						tracer && tracer("Timeout reached");
						callback(new Error("Timeout after " + timeout + " milliseconds"));
						tracer && tracer("Delete registry on timeout " + currentRequest)
						delete _registry[currentRequest];
					}
				}, timeout);
			}
		})(~_);
	};

	/// ### Mock.detail()
	/// Give detail information about all current requests on client and server side.
	/// The result is for each request the path and whether there is an entry on client side and on server side and whether there is a response on client side
	/// The optional timeout parameter gives a timeout after which the request will be aborted (with an error)
	/// This timeout does not have to do anything with the timeout in the Mock constructor.
	self.detail = function(_, timeout) {
		return (function(callback) {
			if (!callback) return fut.future(self.detail, arguments, 0);
			if (_globalError) {
				return callback(_globalError);
			}
			var currentRequest = _step();

			_registry[currentRequest] = [null, null, null, callback];
			self._write(_frameHeader(DETAILS, currentRequest, 0));
			if (timeout > 0) {
				setTimeout(function() {
					tracer && tracer("Timeout function");
					if (currentRequest in _registry) {
						tracer && tracer("Timeout reached");
						callback(new Error("Timeout after " + timeout + " milliseconds"));
						tracer && tracer("Delete registry on timeout " + currentRequest)
						delete _registry[currentRequest];
					}
				}, timeout);
			}
		})(~_);
	};

	// start a new client request. The options will be passed to the server
	// the responseCallback will be invoked with the corresponding readable stream with data from the server
	// an optional timeout overrides the client's global timeout when it is not 0.
	self.request = function(options, responseCallback) {
		var currentRequest = _step(); // number used throughout the current request
		tracer && tracer("Start request for number " + currentRequest);
		// replace path with url
		if ('path' in options && !('url' in options)) {
			options.url = options.path
			delete options.path;
		}
		var writable = new WritableMockStream(options, currentRequest, self, 0);
		// registry content is array of readableStream, writableStream, call back function
		// readable stream not yet known (and important) at the moment - only on first response from server
		_registry[currentRequest] = [null, writable, responseCallback];
		// set timeout
		var timeout = (options && options.timeout) || (clientOptions && clientOptions.timeout) || 0;
		tracer && tracer("Timeout in seconds " + timeout);
		if (timeout) {
			setTimeout(function() {
				self.close(currentRequest, false, true); // Timeout!
			}, timeout * 1000);
		}
		return writable;
	};

	// condenses contents of registry
	function _condenseRegistry(registry) {
		var result = {};
		for (var key in registry) {
			var entry = registry[key];
			var url = (entry[0] && entry[0].url) || (entry[1] && (entry[1].url || (entry[1]._options && entry[1]._options.url)));
			result[key] = [url, !! entry[0], !! entry[1]];
		}
		return result;
	}

	function _statusLetter(entryClient, entryServer) {
		if (entryClient) {
			return entryServer ? "B" : "C";
		} else {
			return entryServer ? "S" : "-";
		}
	}

	function _compareResults(client, server) {
		var key;
		var answer = "";
		var url;
		for (key in client) {
			var entry = client[key];
			var serverEntry = server[key] || [];
			url = entry[0] || serverEntry[0] || "-";
			answer += key + " " + url + " " + _statusLetter(entry, serverEntry.length) + _statusLetter(entry[1], serverEntry[1]) + _statusLetter(entry[2], serverEntry[2]) + ";\n";
		}
		for (key in server) {
			if (!(key in client)) {
				var serverEntry = server[key];
				answer += key + " " + url + " " + _statusLetter(null, serverEntry.length) + _statusLetter(null, serverEntry[1]) + _statusLetter(null, serverEntry[2]) + ";\n";
			}
		}
		return answer;
	}

	// process data of complete frame
	self._chunkProcessing = function(headerType, headerNumber, data) {
		// does this header belong to a request or to a response?
		var responseHeader = !! (headerType & RESPONSE);
		if (responseHeader) {
			tracer && tracer("Response header");
			headerType &= ~RESPONSE;
		}
		// special headers
		if (headerType & SPECIAL) {
			switch (headerType) {
				case CONFIRMATION:
					// return message header: data has been processed, more data can come
					tracer && tracer("Receive confirmation header for " + headerNumber + " response " + !! responseHeader);
					var reg = (responseHeader ? _registryForeign : _registry);
					if (headerNumber in reg) {
						var writable = reg[headerNumber][1];
						if (!writable) throw new Error("No Writable stream");
						// stream can receive more data
						writable._markFree();
					} else {
						tracer && tracer("Ignore confirmation header for " + headerNumber + " response " + !! responseHeader);
					}
					break;
				case DETAILS:
					// obtain detail information
					tracer && tracer("Receive details header for " + headerNumber + " response " + !! responseHeader);
					if (responseHeader) {
						if (headerNumber in _registry) {
							var callback = _registry[headerNumber][3];
							if (!callback) throw new Error("No callback available");
							var serverResult = JSON.parse(data.toString());
							var clientResult = [_condenseRegistry(_registry), _condenseRegistry(_registryForeign)];
							var answer = "Client ";
							answer += _compareResults(clientResult[0], serverResult[1]);
							var serverAnswer = _compareResults(serverResult[0], clientResult[1]);
							if (serverAnswer) answer += "Server " + serverAnswer;
							tracer && tracer("Delete details registry " + headerNumber)
							delete _registry[headerNumber];
							return callback(null, answer);
						} else {
							// entry has already been removed because of timeout
							tracer && tracer("Timeout for ping request " + headerNumber);
						}
					} else { // just answer with ping response header
						// collect data about current requests
						var result = [_condenseRegistry(_registry), _condenseRegistry(_registryForeign)];
						var buffer = JSON.stringify(result);
						self._write(_frameHeader(DETAILS + RESPONSE, headerNumber, buffer.length));
						self._write(buffer);
					}
				case PING:
					// ping request just to see whether server is reachable
					tracer && tracer("Receive ping header for " + headerNumber + " response " + !! responseHeader);
					if (responseHeader) {
						if (headerNumber in _registry) {
							var callback = _registry[headerNumber][3];
							var time = 1 * _registry[headerNumber][4];
							if (!callback) throw new Error("No callback available");
							if (_globalError) return callback(_globalError);
							tracer && tracer("Delete ping registry " + headerNumber)
							delete _registry[headerNumber];
							return callback(null, Date.now() - time);
						} else {
							// entry has already been removed because of timeout
							tracer && tracer("Timeout for ping request " + headerNumber);
						}
					} else { // just answer with ping response header
						self._write(_frameHeader(PING + RESPONSE, headerNumber, 0));
					}
					break;
				case CLOSED:
					// connection has been closed
					tracer && tracer("Receive close header for " + headerNumber + " response " + !! responseHeader);
					var reg = (responseHeader ? _registry : _registryForeign);
					if (headerNumber in reg) {
						var entry = reg[headerNumber];
						tracer && tracer("Delete registry on close " + headerNumber + " foreign " + !responseHeader)
						delete reg[headerNumber];
						_destroyStreams(entry);
					}
					break;
				default:
					throw new Error("Wrong special header " + headerType);
			}
		} else {
			if (headerType & STARTFRAME) { // start frame
				var headerData = JSON.parse(data.toString("utf8"));
				if (!responseHeader) { // on server
					tracer && tracer("Receive header frame on callee for " + headerNumber);
					// registry contains readable stream, writable stream and call back function
					var readableStream = new ReadableMockStream(headerData, headerNumber, self, 0);
					var writableStream = new WritableMockStream(null, headerNumber, self, RESPONSE);
					_registryForeign[headerNumber] = [readableStream, writableStream];
					process.nextTick(function() {
						self.emit('request', readableStream, writableStream);
					});
				} else {
					// on client: call callback function
					if (headerNumber in _registry) {
						var readableStream = new ReadableMockStream(headerData, headerNumber, self, RESPONSE);
						tracer && tracer("Create readable stream on caller and call callback for " + headerNumber + " hdata " + util.format(headerData));
						var callback = _registry[headerNumber][2];
						_registry[headerNumber][0] = readableStream;
						if (!callback) throw new Error("No callback function on client");
						callback(readableStream);
					} else {
						tracer && tracer("Ignore start frame from server for " + headerNumber + " hdata " + util.format(headerData));
					}
				}
			} else { // subsequent frame
				if (!data) data = new Buffer(0);
				tracer && tracer("Receive data frame for " + headerNumber + " response " + responseHeader);
				var reg = (responseHeader ? _registry : _registryForeign);
				if (headerNumber in reg) {
					var readableStream = reg[headerNumber][0];
					if (headerType & ENDMARKER) { // end frame
						tracer && tracer("End frame for " + headerNumber);
						readableStream.frame(data, true);
						// on caller there is nothing to do after this any more: delete data from registry
						if (responseHeader) {
							tracer && tracer("Delete registry on caller for " + headerNumber)
							delete _registry[headerNumber];
						}
					} else {
						readableStream.frame(data, false);
					}
				} else {
					tracer && tracer("Ignore data frame for " + headerNumber + " response " + responseHeader);
				}
			}
		}
	};

	// these variables are only interesting for the following function
	var _currentHeaderType; // type of current header
	var _currentHeaderNumber; // request number of current header
	var _remainingBytes = HEADERLENGTH;
	var _partialChunks = []; // when input stream delivers short chunks which are only part of header or frame data, store the parts here temporarily
	var _header = true; // header data expected 

	// read from stream
	_inputStream.on('data', function(chunk) {
		var chunkLength = chunk.length;
		var chunkRemaining = chunkLength;
		while (chunkRemaining > 0) {
			// not enough data
			if (chunkRemaining < _remainingBytes) {
				_partialChunks.push(chunk.slice(chunkLength - chunkRemaining));
				_remainingBytes -= chunkRemaining;
				return;
			}
			// can complete header/data
			var b = chunk.slice(chunkLength - chunkRemaining, chunkLength - chunkRemaining + _remainingBytes);
			chunkRemaining -= _remainingBytes;
			_remainingBytes = 0;
			// add other chunks
			if (_partialChunks.length > 0) {
				_partialChunks.push(b);
				b = Buffer.concat(_partialChunks);
				_partialChunks.length = 0;
			}
			if (_header) { // end of new frame header
				_currentHeaderType = b[0];
				_currentHeaderNumber = b.readUInt32LE(5);
				_remainingBytes = b.readUInt32LE(1);
				if (_remainingBytes > 0) {
					_header = false;
				} else {
					self._chunkProcessing(_currentHeaderType, _currentHeaderNumber, null);
					_remainingBytes = HEADERLENGTH;
				}
			} else {
				_header = true; // data for next header
				_remainingBytes = HEADERLENGTH;
				self._chunkProcessing(_currentHeaderType, _currentHeaderNumber, b);
			}
		}
	});

}
util.inherits(Mock, events.EventEmitter);

function ReadableMockStream(options, number, mock, resp) {
	tracer && tracer("RMS " + util.format(options));
	var self = this;
	self.writable = false;
	self.readable = true;
	stream.Stream.call(this);
	// copy static information
	tracer && tracer("Options " + util.format(options));
	exports.extractDataFromRequest(options, self);
	self.headers = self.headers || {};
	tracer && tracer("Attributes " + util.format(self));
	var _response = resp; // does this stream belong to a response?
	var _number = number; // sequence number
	var _encoding = null;
	var _remainingBytes = 0;
	var _remainingBuffer = null;
	var _paused = false; // 'pause' has been called, but not yet 'resume'
	var _chunk = null;
	var _ended = false; // if set, 'end' should be emitted.
	var _endEmitted = false; // has 'end' event already been emitted?
	var _mock = mock;
	self.socket = {};

	self.pause = function() {
		tracer && tracer( !! _response + "--- Stream pause " + _number);
		_paused = true;
	};

	self.resume = function() {
		tracer && tracer( !! _response + "--- Stream resume " + _number);
		_paused = false;
		if (_chunk) _processData();
		else {
			if (_ended) _processEnd();
		}
	};

	self.destroy = function() {
		self._destroyInt();
	};

	self._destroyInt = function(local) {
		if (self.readable) {
			self.readable = false;
			if (!local) _mock.close(_number, !resp);

			self.emit('close');
			tracer && tracer(_number + " readstream destroy local " + local + " response " + !! resp);
		}
	};

	function _processEnd() {
		process.nextTick(function() {
			if (!_paused && self.readable && !_endEmitted) {
				tracer && tracer("Process end event for " + _number);
				_endEmitted = true;
				self.emit('end');
			}
		});
		// no confirmation necessary for end event
	}

	function _processData() {
		process.nextTick(function() {
			if (!_paused && self.readable) {
				tracer && tracer( !! _response + "Process data event for " + _number + " " + util.format(_chunk));
				if (!_chunk) {
					console.log("PD " + util.format(_chunk) + ", " + resp + ", " + _number + ", " + _encoding + ", " + _remainingBytes + ", " + util.format(_remainingBuffer) + ", " + _ended);
				} else if (_chunk.length > 0) {
					if (_encoding) {
						// try whether buffer can be converted completely to string
						if (_remainingBuffer) {
							_chunk = Buffer.concat([_remainingBuffer, _chunk]);
							_remainingBuffer = null;
						}
						var remaining = exports.bufferEncoding(_chunk, _encoding);
						if (remaining) {
							var start = _chunk.length - remaining;
							if (start === 0) {
								_remainingBuffer = _chunk;
								// it does not make sense to send an empty string to the listeners - therefore no 'emit'
							} else {
								_remainingBuffer = _chunk.slice(_chunk.length - remaining);
								var text = _chunk.slice(0, _chunk.length - remaining).toString(_encoding);
								// transmit the data
								self.emit('data', text);
							}
						} else {
							var text = _chunk.toString(_encoding);
							self.emit('data', text);
						}
					} else self.emit('data', _chunk);
				}
				_chunk = null;
			}
			if (!_ended) { // no confirmation with end event
				tracer && tracer("Data event with confirmation for " + _number);
				_mock._write(_frameHeader(CONFIRMATION + _response, _number, 0));
			} else {
				_processEnd();
			}
		});
	}

	// write data of this frame to receiving stream (emit 'data' event)
	// end: also emit end event
	self.frame = function(data, end) {
		tracer && tracer("Frame function " + end + " " + _paused);
		if (_chunk) throw new Error("Already chunk present " + _response + "--" + util.format(_chunk));
		_ended = end;
		_chunk = data;
		if (!_paused) {
			if (data) _processData();
			else {
				if (end) _processEnd();
			}
		}
	};

	self.setEncoding = function(encoding) {
		// normalize the encoding
		_encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, '');
	};

}
util.inherits(ReadableMockStream, stream.Stream);

function WritableMockStream(options, number, mock, resp) {
	var self = this;
	self.writable = true;
	self.readable = false;
	stream.Stream.call(this);
	var _options = options || {
		headers: {},
		statusCode: 200,
		sendDate: true
	};
	self._options = _options;
	var _response = resp; // does this stream belong to a response?
	var _number = number; // sequence number of request
	var _mock = mock; // mock client or mock server
	var _chunk = null;
	var _used = false; // currently no all data have been totally processed
	var _finished = 0; // 0: end has not yet been called, 1: end has been called, 2: end header has been sent

	self.write = function(data, enc, end) {
		tracer && tracer(_number + "---------- WRITE " + util.format(data) + " " + enc + " " + end + "--" + _used);
		if (!self.writable || !_mock) {
			tracer && tracer(_number + " ignore write on closed stream");
			return;
		}
		if (_used) throw new Error(_number + "Data left");
		if (end) {
			if (!_finished) _finished = 1;
		} else {
			if (_finished) throw new Error(_number + "No writes after end");
		}
		if (!data) data = new Buffer(0);
		tracer && tracer(_number + "DATA ????? " + util.format(data));
		if (!Buffer.isBuffer(data)) {
			if (!enc) enc = "utf8";
			data = new Buffer("" + data, enc);
		}
		var list = [];
		if (_options) {
			tracer && tracer(_number + "Send frame header for " + _number);
			var content = new Buffer(JSON.stringify(_options), "utf8");
			list.push(_frameHeader(STARTFRAME + _response, _number, content.length), content);
			_options = null;
		}
		if (data.length > 0) {
			tracer && tracer("Send data frame for " + _number);
			list.push(_frameHeader(_response + (end ? ENDMARKER : 0), _number, data.length), data);
		} else {
			list.push(_frameHeader(_response + (end ? ENDMARKER : 0), _number, 0));
		}
		_mock._write(list);
		if (end && _response) {
			_mock._deleteRegistry(_number, true);
		}
		_used = true;
		return false;
	};

	self.end = function(data, enc) {
		tracer && tracer(_number + "ENDDATA --- <" + data + ">");
		if (_finished) {
			tracer && tracer("Ignore second end call");
			return; // ignore
		}
		_finished = 1;
		if (!_used) self.write(data, enc, true);
	};

	self.destroy = function() {
		self._destroyInt();
	};

	self._destroyInt = function(local) {
		if (self.writable) {
			self.writable = false;
			if (!local) _mock.close(_number, resp);
			self.emit('close');
			tracer && tracer(_number + " write stream destroy local " + local + " response " + !! resp);

		}
	};

	self._markFree = function() {
		tracer && tracer("Mark stream as free again " + _number);
		_used = false;
		tracer && tracer(_number + "USED " + _used + " fin " + _finished);
		if (!_finished) self.emit('drain'); // more data can come unless 'end' has already been called
		else {
			if (_finished === 1) self.write(null, null, true);
		}
	};

	// methods of HttpServerResponse
	self.writeHead = function(statusCode) {
		var reasonPhrase;
		var headers;
		switch (arguments.length) {
			case 3:
				reasonPhrase = arguments[1];
				headers = arguments[2];
				break;
			case 2:
				headers = arguments[1];
				break;
			default:
				break;
		}
		self._options = self._options || {}; // avoid null pointer exceptions 
		if (headers) {
			self._options.headers = headers;
			self._options.writeHeadCalled = true;
		}
		if (reasonPhrase) self._options.reasonPhrase = reasonPhrase;
		self._options.statusCode = statusCode;
		// write header data
		tracer && tracer(_number + " Write just header data");
		var content = new Buffer(JSON.stringify(self._options), "utf8");
		if (_mock) _mock._write([_frameHeader(STARTFRAME + _response, _number, content.length), content]);
		self._options = null;
	};

	// set/get the status code directly within the options property

	self.__defineSetter__("statusCode", function(code) {
		self._options = self._options || {}; // avoid null pointer exceptions 
		self._options.statusCode = code;
	});
	self.__defineGetter__("statusCode", function() {
		self._options = self._options || {}; // avoid null pointer exceptions 
		return self._options.statusCode;
	});

	self.__defineSetter__("sendDate", function(val) {
		self._options = self._options || {}; // avoid null pointer exceptions 
		self._options.sendDate = val;
	});
	self.__defineGetter__("sendDate", function() {
		self._options = self._options || {}; // avoid null pointer exceptions 
		return self._options.sendDate;
	});

	self.setHeader = function(name, value) {
		self._options = self._options || {}; // avoid null pointer exceptions 
		self._options.headers[name] = value;
	};

	self.getHeader = function(name) {
		self._options = self._options || {}; // avoid null pointer exceptions 
		return self._options.headers[name];
	};

	self.removeHeader = function(name) {
		self._options = self._options || {}; // avoid null pointer exceptions 
		delete self._options.headers[name];
	};

}

util.inherits(WritableMockStream, stream.Stream);

/// finds out whether the last multibyte character of this buffer is complete. If not, it returns the number of bytes of this 
/// incomplete character. The function assumes that the buffer contains a part of correctly encoded data.
/// the function assumes that the encoding is already normalized!
function bufferEncoding(buffer, enc) {
	var length = buffer.length;
	switch (enc) {
		case "utf8":
			if (!(buffer[length - 1] & 0x80)) return 0; // single byte character at end
			var i = length - 1;
			var testbyte = 0x40;
			for (var i = 1; i <= length; i++) {
				var byte = buffer[length - i];
				// there cannot be a single byte character directly before a group of non-leading bytes of a multibyte character 
				if (!(byte & 0x80)) throw new Error("Invalid UTF8");
				if (byte & 0x40) { // leading byte
					return (byte & testbyte) ? i : 0; // incomplete sequence when test byte is also set
				}
				testbyte >>= 1;
			}
			// just sequence of non-leading bytes
			return length;
		case "utf16le":
		case "ucs2":
			return (length & 0x01); // number of bytes must be even
		case "hex":
		case "ascii":
			return 0;
		default:
			throw new Error("Wrong encoding " + enc);
	}
}

// builds the frame header out of type, number, length.
// for a frame header with end marker, the property "mockEndMarker" is set on the buffer.
function _frameHeader(type, number, length) {
	tracer && tracer("Header type " + type + " number " + number + " length " + length)
	var b = new Buffer(HEADERLENGTH);
	b[0] = type;
	b.writeUInt32LE(length, 1);
	b.writeUInt32LE(number, 5);
	if (type & ENDMARKER) b.mockEndMarker = true;
	return b;
}

/// ## MockStreamServer
/// This class emulates Streamline's HttpServer. The requests and responses are taken from the mock mechanism but are wrapped within
/// Streamline's HttpServerRequest, HttpServerResponse.
/// parameters: 
/// - disp: request dispatcher function
/// - outputStream: stream to write data to other mock (e. g. process.stdout)
/// - inputStream: stream to get data from other mock (e. g. process.stdin)
/// - clientOptions: options for mock (mainly: timeout)
/// - options: options which will be passed to Streamline's HttpServerRequest, HttpServerResponse
exports.MockStreamServer = function(disp, outputStream, inputStream, clientOptions, options) {
	var self = this;
	var dispatcher = function(request, response) {
		tracer && tracer("+++++++++++++++++++++++++++++Request")
		globals.context = {};
		return disp(new streams.HttpServerRequest(request, options), new streams.HttpServerResponse(response, options), function(err) {
			if (err) {
				response.writeHead(500, {
					"Content-Type": "text/plain"
				});
				response.end(err.message + "\n" + err.stack);
			}
		})
	};
	/// The listen method will start the server and resume the input stream
	/// Parameters: callback function
	self.listen = function(_) {
		return (function(callback) {
			tracer && tracer("Listen")
			try {
				self.mockClient = new Mock(outputStream, inputStream, dispatcher, clientOptions);
				inputStream.resume();
				tracer && tracer("LISTEN start")
				return callback();
			} catch (e) {
				return callback(e);
			}
		})(~_);
	};
}

/// ## MemoryStream
/// this class is a writable stream which appends all data to a string (content field). It emulates the HttpResponse methods writeHead etc.
function MemoryStream() {
	var self = this;
	stream.Stream.call(this);
	self.writable = true;
	self.content = "";
	self._options = [];
	self.ended = false;
	self.write = function(data) {
		self.content += data;
		return true;
	}
	self.end = function(data) {
		if (data) self.content += data;
		self.ended = true;
	}
	self.writeHead = function(statusCode) {
		var reasonPhrase;
		var headers;
		switch (arguments.length) {
			case 3:
				reasonPhrase = arguments[1];
				headers = arguments[2];
				break;
			case 2:
				headers = arguments[1]
				break;
			default:
				break;
		}
		if (headers) {
			self._options.headers = headers;
			self._options.writeHeadCalled = true;
		}
		if (reasonPhrase) self._options.reasonPhrase = reasonPhrase;
		self._options.statusCode = statusCode;

	}

	return self;

	// set/get the status code directly within the options property

	self.__defineSetter__("statusCode", function(code) {
		self._options.statusCode = code
	});
	self.__defineGetter__("statusCode", function() {
		return self._options.statusCode
	});

	self.__defineSetter__("sendDate", function(val) {
		self._options.sendDate = val
	});
	self.__defineGetter__("sendDate", function() {
		return self._options.sendDate
	});

	self.setHeader = function(name, value) {
		self._options.headers[name] = value;
	}

	self.getHeader = function(name) {
		return self._options.headers[name];
	}

	self.removeHeader = function(name) {
		delete self._options.headers[name];
	}
}
util.inherits(MemoryStream, stream.Stream);

exports.MemoryStream = MemoryStream;

//convenience function: send a request to a server with same options as above self.request, but already as an asynchronous function.
//returns the content of the return stream or throws an exception in case of an error. When the status code is not 200, it also throws
// an error, but with STATUS_CODE set to the status code
function simpleRequest(client, options, content, _) {
	return (function(callback) {
		if (!callback) return fut.future(simpleRequest, arguments, 3);
		var result = "";
		var answered = false;
		var req = client.request(options, function(res) {
			res.setEncoding("utf8");
			res.on("data", function(chunk) {
				result += chunk;
			});
			res.on("end", function(chunk) {
				if (!answered) {
					answered = true;
					if (res.statusCode === 200) {
						return callback(null, result);
					} else {
						var error = new Error(result);
						error.STATUS_CODE = res.statusCode;
						return callback(error);
					}
				}
			});
			res.on('close', function() {
				if (!answered) {
					answered = true;
					return callback('Connection closed')
				}
			})
		});
		req.on("error", function(error) {
			if (!answered) {
				answered = true;
				return callback(error);
			}
		});
		if (content) req.end(content);
		else req.end();
	})(~_);
}
exports.simpleRequest = simpleRequest;

exports.bufferEncoding = bufferEncoding;

// for unit tests
exports._frameHeader = _frameHeader;
exports._WritableMockStream = WritableMockStream;

// very simple write stream which 
function DescriptorWriteStream(fd) {
	var self = this;
	self.writable = true;
	var ended = false;
	self.write = function(data, offset) {
		offset = offset || 0;
		if (!data) {
			if (ended) {
				self.writable = false;
				fs.close(fd);
			}
			return true;
		}
		fs.write(fd, data, offset, data.length - offset, null, function(err, written, buffer) {
			if (err) {
				self.writable = false;
				self.emit('error', err);
			} else {
				if (buffer && written < buffer.length) {
					self.write(buffer, written);
				} else {
					if (ended) {
						self.writable = false;
						fs.close(fd);
					} else {
						self.emit('drain');
					}
				}
			}
		});
		return false;
	};
	self.end = function(data) {
		ended = true;
		self.write(data);
	}
};
DescriptorWriteStream.prototype = new events.EventEmitter();
exports.DescriptorWriteStream = DescriptorWriteStream;