"use strict";
/// !doc
/// # Mock API  
var stream = require('stream');
var events = require('events');
var streams = require('streamline/lib/streams/streams');
var globals = require('streamline/lib/globals');
var util = require('util');
var fs = require('fs');
exports.BALANCER_HEADER = "syracusebalancerheader"; // special Http header for passing load balancing information (not used in this file
exports.TENANT_HEADER = "syracusetenantheader"; // special Http header for passing the tenant in multitenant mode

var tracer; // = console.log;

/// Pass HTTP requests and responses through a pipe
// Two instances of this Mock class must be connected using two pipes so that bidirectional exchange is possible. Usually this
// is standard input and standard output of a child process. Each side can send a request to the other side which will be processed by
// the request handler on the other side. There is no check that a request handler is available! Since the situation is totally symmetric,
// in the sequel, the side which poses the request, will be called client, the other side server.
// Internal processing:
// Each request/response gets an sequence number so that parallel requests/responses can be distinguished.
// An HTTP request/response contains headers etc. - in the sequel this will be called "metadata" and a stream of data
// (In detail: relevant metadata are: headers, url, method, HTTP version, response code, connection.authorized, connection.getPeerCertificate(), connection.localPort, connection.remoteAddress 
// (to find out SSL connections and the client certificate. The mocks cannot handle SSL but will transport these two details).
// Whenever metadata or a chunk of data is transferred, there is a header first which tells about the kind of data and
// the byte length and the sequence number.
// The client listens on a readable stream (usually an HTTP request). When the first data come, the metadata and the first chunk of data 
// will be transferred to the client and the requestListener on the server will be invoked. 
// For each chunk of data (except for the final chunk which contains an end marker), a confirmation header will be sent back.
// The writable stream of the client (and server) will not accept further data until the confirmation has been received.
// Upon the 'end' event of the readable stream on the client, the header will contain an end marker. Since no more data are to come, there
// will not be a confirmation for this.
// The last chunk of the response (from server to client) will delete the temporary storage for this sequence number on the server and then 
// on the client. When there is no temporary storage for a sequence number and the header is no start header, it will be ignored on the other side.
// The mock http request on the server tries to imitate the original http request: it contains its headers, url, method, http version and
// a readable stream, but the connection attribute is empty except for 'authorized' and getPeerCertificate() to detect SSL connections and remoteAddress and localPort.
// the mock http response on the server tries to imitate the original http response. It contains its set/remove header methods, the writeHead
// method, statusCode, but the writeContinue() method is not implemented at the moment.
// There is an optional timeout. When the answer is not complete within the timeout, it will be closed. When there is a close event from
// any side (HTTP request/response), all streams will be finished and the temporary storage for this sequence number will be removed on both sides

// no more input after this 
var ENDMARKER = 0x02;
// special headers have this bit set
var SPECIAL = 0x40;
var CONFIRMATION = SPECIAL;
// ping header for just testing whether server can be reached
var PING = SPECIAL + 1;
// header to inform that the connection has been closed on client side
var CLOSED = SPECIAL + 2;
// header for retrieving detail information about current requests
var DETAILS = SPECIAL + 3;
// marks that this is a response header (originated from the server), can also be a confirmation header back to the server
var RESPONSE = 0x80;
// length of header in bytes
var HEADERLENGTH = 9;
// a non-special header with this bit set is the first header of the connection
var STARTFRAME = 0x01;

// copies attributes from HttpServerRequest to the target (or to a newly created object) and returns the target
// reasonPhrase: not official attribute, but used to transfer reason phrase to client
// fromNanny: not official attribute, but used to indicate internal requests
// _writeHeadCalled: indicates that 
exports.extractDataFromRequest = function(source, target) {
	target = target || {};
	["sendDate", "_writeHeadCalled", "headers", "httpVersion", "httpVersionMajor", "httpVersionMinor", "url", "method", "reasonPhrase", "statusCode", "fromNanny"].forEach(function(key) {
		if (key in source) target[key] = source[key];
	});
	if ("connection" in source) {
		target.connection = {
			remoteAddress: source.connection.remoteAddress,
			localPort: source.connection.localPort
		};
		if ("authorized" in source.connection) {
			target.connection.authorized = source.connection.authorized;
			target.connection._peerCertificate = source.connection.getPeerCertificate ? source.connection.getPeerCertificate() : source.connection._peerCertificate;
			target.connection.getPeerCertificate = function() {
				return this._peerCertificate;
			};
		}
	}
	return target;
};

/// ## Mock class
/// constructor parameters: outputStream, inputStream, requestHandler and clientOptions
/// clientOptions is an object with the following optional attributes: 
/// timeout: after this time (in seconds), the request data will be deleted
exports.Mock = Mock;

function Mock(outputStream, inputStream, requestHandler, clientOptions) {
	events.EventEmitter.call(this);
	tracer && tracer("MOCK start; client options " + util.format(clientOptions));
	this._clientOptions = clientOptions;
	this._sequenceNumber = 0;
	this._registry = {}; // contains all data for the current request. Key is the request sequence number, values are arrays of readableStream, writableStream, call back function, ping call back function
	this._registryForeign = {}; // contains all data for the foreign request which is processed here.
	// contains the instances of writable stream which want to write data
	this._queue = [];
	// input stream of child: to this the data will be written
	this._outputStream = outputStream;
	// child stream is writable? 
	this._outputReady = true;
	// output stream of child: return data
	this._inputStream = inputStream;
	// has a global error occurred?
	this._globalError;


	if (requestHandler) {
		this.addListener('request', function(req, resp) {
			requestHandler(req, resp, _ >> function(err) {
				if (err) throw err;
			});
		});
	}

	var self = this;

	outputStream.on('drain', function() {
		self._outputReady = true;
		self._shift();
	});

	outputStream.on('error', self.globalError);
	inputStream.on('error', self.globalError);
	inputStream.on('end', self.globalError);
	inputStream.on('close', self.globalError);

	// these variables are only interesting for the following function
	var _currentHeaderType; // type of current header
	var _currentHeaderNumber; // request number of current header
	var _remainingBytes = HEADERLENGTH;
	var _partialChunks = []; // when input stream delivers short chunks which are only part of header or frame data, store the parts here temporarily
	var _header = true; // header data expected 

	// read from stream
	inputStream.on('data', function(chunk) {
		var chunkLength = chunk.length;
		var chunkRemaining = chunkLength;
		while (chunkRemaining > 0) {
			// not enough data
			if (chunkRemaining < _remainingBytes) {
				_partialChunks.push(chunk.slice(chunkLength - chunkRemaining));
				_remainingBytes -= chunkRemaining;
				return;
			}
			// can complete header/data
			var b = chunk.slice(chunkLength - chunkRemaining, chunkLength - chunkRemaining + _remainingBytes);
			chunkRemaining -= _remainingBytes;
			_remainingBytes = 0;
			// add other chunks
			if (_partialChunks.length > 0) {
				_partialChunks.push(b);
				b = Buffer.concat(_partialChunks);
				_partialChunks.length = 0;
			}
			if (_header) { // end of new frame header
				_currentHeaderType = b[0];
				_currentHeaderNumber = b.readUInt32LE(5);
				_remainingBytes = b.readUInt32LE(1);
				if (_remainingBytes > 0) {
					_header = false;
				} else {
					self._chunkProcessing(_currentHeaderType, _currentHeaderNumber, null);
					_remainingBytes = HEADERLENGTH;
				}
			} else {
				_header = true; // data for next header
				_remainingBytes = HEADERLENGTH;
				self._chunkProcessing(_currentHeaderType, _currentHeaderNumber, b);
			}
		}
	});

}

util.inherits(Mock, events.EventEmitter);

// number of current requests
Mock.prototype.numberRequests = function() {
	tracer && tracer("Open requests own " + util.format(Object.keys(this._registry)) + " foreign " + util.format(Object.keys(this._registryForeign)));
	return Object.keys(this._registry).length + "/" + Object.keys(this._registryForeign).length;
};

// increment sequence number of request
Mock.prototype._step = function() {
	this._sequenceNumber++;
	if (this._sequenceNumber > 2000000000) this._sequenceNumber = 0;
	return this._sequenceNumber;
};

// queue a write request
Mock.prototype._write = function(queueElements) {
	var self = this;
	if (queueElements instanceof Array) self._queue = self._queue.concat(queueElements);
	else self._queue.push(queueElements);
	if (self._outputReady) self._shift();
};


// when one of the streams has been closed, close all other streams and remove data associated with the streams
Mock.prototype.close = function(number, foreign, timeout) {
	var self = this;
	var reg = (foreign ? self._registryForeign : self._registry);
	if (number in reg) {
		// notify other side
		self._write(_frameHeader(CLOSED + (foreign ? RESPONSE : 0), number, 0));
		var entry = reg[number];
		// delete registry
		tracer && tracer("Delete registry " + number + " foreign " + foreign);
		delete reg[number];

		// destroy streams
		self._destroyStreams(entry, timeout);
	}

};

Mock.prototype.simpleRequest = function(options, content, callback) {
	return simpleRequest(this, options, content, callback);
};

// destroy the two streams which are locally associated with this request.
// For timeout send a small response.
// The streams are destroyed in such a way that the self.close method of the client/server is not called any more
Mock.prototype._destroyStreams = function(entry, timeout) {
	var self = this;
	if (entry[0]) {
		entry[0]._destroyInt(true);
	} else {
		// add a dummy response
		var callback = entry[2];
		if (callback) {
			// construct dummy response with non existent number
			var readableStream = new ReadableMockStream({
				statusCode: (timeout ? 408 : 500)
			}, -1, self, RESPONSE);
			tracer && tracer("Create readable stream on caller for dummy callback " + timeout);
			// dummy response
			if (timeout) {
				readableStream.frame("Timeout", true);
				callback(readableStream);
			} else {
				callback(readableStream);
				process.nextTick(function() {
					readableStream._destroyInt(true); // destroy without calling close() function of mock again
				});
			}
		}
	}
	if (entry[1]) entry[1]._destroyInt(true); // destroy without calling close() function of mock again
};

// delete registry entry (to be invoked by the writable mock stream upon end)
Mock.prototype._deleteRegistry = function(number, foreign) {
	tracer && tracer("Delete registry entry " + number + " " + foreign);
	if (foreign) delete this._registryForeign[number];
	else delete this._registry[number];
};

// mechanism will break when _inputStream/_outputStream does not work any more	
Mock.prototype.globalError = function(exception) {
	var self = this;
	exception = exception || new Error("Stream finished");
	self._globalError = exception;
	for (var number in self._registry) {
		var entry = self._registry[number];
		if (!entry) continue;
		if (entry[0]) { // readableStream, writableStream, call back function
			entry[0].emit('error', exception);
		}
		if (entry[1]) { // readableStream, writableStream, call back function
			entry[1].emit('error', exception);
		}
		if (entry[3]) { // ping callback
			process.nextTick(function() {
				return entry[3](self._globalError);
			});
		}
		self._destroyStreams(entry);
	}
	for (var number in self._registryForeign) {
		var entry = self._registry[number];
		if (!entry) continue;
		if (entry[0]) { // readableStream, writableStream, call back function
			entry[0].emit('error', exception);
		}
		if (entry[1]) { // readableStream, writableStream, call back function
			entry[1].emit('error', exception);
		}
		self._destroyStreams(entry);
	}
	self._registry = {};
	self._registryForeign = {};
};


// shift as much data to the output stream as possible
Mock.prototype._shift = function() {
	var self = this;
	tracer && tracer("SHIFT " + self._queue.length);
	while (self._outputReady && self._queue.length > 0) {
		var streamElement = self._queue.shift();
		self._outputReady = self._outputStream.write(streamElement);
	}
};


/// ### Mock.ping()
/// Send a dummy request to the server with will be answered as fast as possible by the server.
/// The result is the time in milliseconds for the whole request
/// The optional timeout parameter gives a timeout after which the request will be aborted (with an error)
/// This timeout does not have to do anything with the timeout in the Mock constructor.
Mock.prototype.ping = _(function(callback, timeout) {
	var self = this;
	if (self._globalError) {
		return callback(self._globalError);
	}
	var currentRequest = self._step();

	self._registry[currentRequest] = [null, null, null, callback, Date.now()];
	self._write(_frameHeader(PING, currentRequest, 0));
	if (timeout > 0) {
		setTimeout(function() {
			tracer && tracer("Timeout function");
			if (currentRequest in self._registry) {
				tracer && tracer("Timeout reached");
				callback(new Error("Timeout after " + timeout + " milliseconds"));
				tracer && tracer("Delete registry on timeout " + currentRequest);
				delete self._registry[currentRequest];
			}
		}, timeout);
	}
}, 0);


/// ### Mock.detail()
/// Give detail information about all current requests on client and server side.
/// The result is for each request the path and whether there is an entry on client side and on server side and whether there is a response on client side
/// The optional timeout parameter gives a timeout after which the request will be aborted (with an error)
/// This timeout does not have to do anything with the timeout in the Mock constructor.
Mock.prototype.detail = _(function(callback, timeout) {
	var self = this;
	if (self._globalError) {
		return callback(self._globalError);
	}
	var currentRequest = self._step();

	self._registry[currentRequest] = [null, null, null, callback];
	self._write(_frameHeader(DETAILS, currentRequest, 0));
	if (timeout > 0) {
		setTimeout(function() {
			tracer && tracer("Timeout function");
			if (currentRequest in self._registry) {
				tracer && tracer("Timeout reached");
				callback(new Error("Timeout after " + timeout + " milliseconds"));
				tracer && tracer("Delete registry on timeout " + currentRequest);
				delete self._registry[currentRequest];
			}
		}, timeout);
	}
}, 0);

// start a new client request. The options will be passed to the server
// the responseCallback will be invoked with the corresponding readable stream with data from the server
// an optional timeout overrides the client's global timeout when it is not 0.
// when 'options' contains an optional boolean attribute 'fromNanny', this will be transferred to the request on server side
// (used to mark internal calls)
Mock.prototype.request = function(options, responseCallback) {
	var self = this;
	var currentRequest = self._step(); // number used throughout the current request
	tracer && tracer("Start request for number " + currentRequest);
	// replace path with url
	if ('path' in options && !('url' in options)) {
		options.url = options.path;
		delete options.path;
	}
	var writable = new WritableMockStream(options, currentRequest, self, 0);
	// registry content is array of readableStream, writableStream, call back function
	// readable stream not yet known (and important) at the moment - only on first response from server
	self._registry[currentRequest] = [null, writable, responseCallback];
	// set timeout
	var timeout = (options && options.timeout) || (self.clientOptions && self.clientOptions.timeout) || 0;
	tracer && tracer("Timeout in seconds " + timeout);
	if (timeout) {
		setTimeout(function() {
			self.close(currentRequest, false, true); // Timeout!
		}, timeout * 1000);
	}
	return writable;
};




// process data of complete frame

Mock.prototype._chunkProcessing = function(headerType, headerNumber, data) {
	// condenses contents of registry
	function _condenseRegistry(registry) {
		var result = {};
		for (var key in registry) {
			var entry = registry[key];
			var url = (entry[0] && entry[0].url) || (entry[1] && (entry[1].url || (entry[1]._options && entry[1]._options.url)));
			result[key] = [url, !! entry[0], !! entry[1]];
		}
		return result;
	}

	function _compareResults(client, server) {
		function _statusLetter(entryClient, entryServer) {
			if (entryClient) {
				return entryServer ? "B" : "C";
			} else {
				return entryServer ? "S" : "-";
			}
		}

		var self = this;
		var key;
		var answer = "";
		var url;
		for (key in client) {
			var entry = client[key];
			var serverEntry = server[key] || [];
			url = entry[0] || serverEntry[0] || "-";
			answer += key + " " + url + " " + _statusLetter(entry, serverEntry.length) + _statusLetter(entry[1], serverEntry[1]) + _statusLetter(entry[2], serverEntry[2]) + ";\n";
		}
		for (key in server) {
			if (!(key in client)) {
				var serverEntry = server[key];
				answer += key + " " + url + " " + _statusLetter(null, serverEntry.length) + self._statusLetter(null, serverEntry[1]) + _statusLetter(null, serverEntry[2]) + ";\n";
			}
		}
		return answer;
	}

	var self = this;
	// does this header belong to a request or to a response?
	var responseHeader = !! (headerType & RESPONSE);
	if (responseHeader) {
		tracer && tracer("Response header");
		headerType &= ~RESPONSE;
	}
	// special headers
	if (headerType & SPECIAL) {
		switch (headerType) {
			case CONFIRMATION:
				// return message header: data has been processed, more data can come
				tracer && tracer("Receive confirmation header for " + headerNumber + " response " + !! responseHeader);
				var reg = (responseHeader ? self._registryForeign : self._registry);
				if (headerNumber in reg) {
					var writable = reg[headerNumber][1];
					if (!writable) throw new Error("No Writable stream");
					// stream can receive more data
					writable._markFree();
				} else {
					tracer && tracer("Ignore confirmation header for " + headerNumber + " response " + !! responseHeader);
				}
				break;
			case DETAILS:
				// obtain detail information
				tracer && tracer("Receive details header for " + headerNumber + " response " + !! responseHeader);
				if (responseHeader) {
					if (headerNumber in self._registry) {
						var callback = self._registry[headerNumber][3];
						if (!callback) throw new Error("No callback available");
						var serverResult = JSON.parse(data.toString());
						var clientResult = [_condenseRegistry(self._registry), _condenseRegistry(self._registryForeign)];
						var answer = "Client ";
						answer += _compareResults(clientResult[0], serverResult[1]);
						var serverAnswer = _compareResults(serverResult[0], clientResult[1]);
						if (serverAnswer) answer += "Server " + serverAnswer;
						tracer && tracer("Delete details registry " + headerNumber);
						delete self._registry[headerNumber];
						return callback(null, answer);
					} else {
						// entry has already been removed because of timeout
						tracer && tracer("Timeout for ping request " + headerNumber);
					}
				} else { // just answer with ping response header
					// collect data about current requests
					var result = [_condenseRegistry(self._registry), _condenseRegistry(self._registryForeign)];
					var buffer = JSON.stringify(result);
					self._write(_frameHeader(DETAILS + RESPONSE, headerNumber, buffer.length));
					self._write(new Buffer(buffer));
				}
			case PING:
				// ping request just to see whether server is reachable
				tracer && tracer("Receive ping header for " + headerNumber + " response " + !! responseHeader);
				if (responseHeader) {
					if (headerNumber in self._registry) {
						var callback = self._registry[headerNumber][3];
						var time = 1 * self._registry[headerNumber][4];
						if (!callback) throw new Error("No callback available");
						if (self._globalError) return callback(self._globalError);
						tracer && tracer("Delete ping registry " + headerNumber);
						delete self._registry[headerNumber];
						return callback(null, Date.now() - time);
					} else {
						// entry has already been removed because of timeout
						tracer && tracer("Timeout for ping request " + headerNumber);
					}
				} else { // just answer with ping response header
					self._write(_frameHeader(PING + RESPONSE, headerNumber, 0));
				}
				break;
			case CLOSED:
				// connection has been closed
				tracer && tracer("Receive close header for " + headerNumber + " response " + !! responseHeader);
				var reg = (responseHeader ? self._registry : self._registryForeign);
				if (headerNumber in reg) {
					var entry = reg[headerNumber];
					tracer && tracer("Delete registry on close " + headerNumber + " foreign " + !responseHeader);
					delete reg[headerNumber];
					self._destroyStreams(entry);
				}
				break;
			default:
				throw new Error("Wrong special header " + headerType);
		}
	} else {
		if (headerType & STARTFRAME) { // start frame
			var headerData = JSON.parse(data.toString("utf8"));
			if (!responseHeader) { // on server
				tracer && tracer("Receive header frame on callee for " + headerNumber);
				// registry contains readable stream, writable stream and call back function
				var readableStream = new ReadableMockStream(headerData, headerNumber, self, 0);
				var writableStream = new WritableMockStream(null, headerNumber, self, RESPONSE);
				self._registryForeign[headerNumber] = [readableStream, writableStream];
				process.nextTick(function() {
					self.emit('request', readableStream, writableStream);
				});
			} else {
				// on client: call callback function
				if (headerNumber in self._registry) {
					var readableStream = new ReadableMockStream(headerData, headerNumber, self, RESPONSE);
					tracer && tracer("Create readable stream on caller and call callback for " + headerNumber + " hdata " + util.format(headerData));
					var callback = self._registry[headerNumber][2];
					self._registry[headerNumber][0] = readableStream;
					if (!callback) throw new Error("No callback function on client");
					callback(readableStream);
				} else {
					tracer && tracer("Ignore start frame from server for " + headerNumber + " hdata " + util.format(headerData));
				}
			}
		} else { // subsequent frame
			if (!data) data = new Buffer(0);
			tracer && tracer("Receive data frame for " + headerNumber + " response " + responseHeader);
			var reg = (responseHeader ? self._registry : self._registryForeign);
			if (headerNumber in reg) {
				var readableStream = reg[headerNumber][0];
				if (headerType & ENDMARKER) { // end frame
					tracer && tracer("End frame for " + headerNumber);
					readableStream.frame(data, true);
					// on caller there is nothing to do after this any more: delete data from registry
					if (responseHeader) {
						tracer && tracer("Delete registry on caller for " + headerNumber);
						delete self._registry[headerNumber];
					}
				} else {
					readableStream.frame(data, false);
				}
			} else {
				tracer && tracer("Ignore data frame for " + headerNumber + " response " + responseHeader);
			}
		}
	}
};



function ReadableMockStream(options, number, mock, resp) {
	tracer && tracer("RMS " + util.format(options));
	this.writable = false;
	this.readable = true;
	stream.Stream.call(this);
	// copy static information
	tracer && tracer("Options " + util.format(options));
	exports.extractDataFromRequest(options, this);
	this.headers = this.headers || {};
	tracer && tracer("Attributes " + util.format(this));
	this._response = resp; // does this stream belong to a response?
	this._number = number; // sequence number
	this._encoding = null;
	this._remainingBytes = 0;
	this._remainingBuffer = null;
	this._paused = false; // 'pause' has been called, but not yet 'resume'
	this._chunk = null;
	this._ended = false; // if set, 'end' should be emitted.
	this._endEmitted = false; // has 'end' event already been emitted?
	this._mock = mock;
	this.socket = {};
}

util.inherits(ReadableMockStream, stream.Stream);

ReadableMockStream.prototype.pause = function() {
	tracer && tracer( !! this._response + "--- Stream pause " + this._number);
	this._paused = true;
};

ReadableMockStream.prototype.resume = function() {
	tracer && tracer( !! this._response + "--- Stream resume " + this._number);
	this._paused = false;
	if (this._chunk) this._processData();
	else {
		if (this._ended) this._processEnd();
	}
};

ReadableMockStream.prototype.destroy = function() {
	this._destroyInt();
};

ReadableMockStream.prototype._destroyInt = function(local) {
	var self = this;
	if (self.readable) {
		self.readable = false;
		if (!local) self._mock.close(self._number, !self.resp);

		self.emit('close');
		tracer && tracer(self._number + " readstream destroy local " + local + " response " + !! self.resp);
	}
};

ReadableMockStream.prototype._processEnd = function() {
	var self = this;
	process.nextTick(function() {
		if (!self._paused && self.readable && !self._endEmitted) {
			tracer && tracer("Process end event for " + self._number + "data " + !! self._chunk);
			if (self._chunk) {
				self._processData();
			} else {
				self._endEmitted = true;
				self.emit('end');
			}
		}
	});
	// no confirmation necessary for end event
};

ReadableMockStream.prototype._processData = function() {
	var self = this;
	process.nextTick(function() {
		if (!self._paused && self.readable) {
			tracer && tracer( !! self._response + "Process data event for " + self._number + " " + util.format(self._chunk));
			if (!self._chunk) {
				tracer && tracer("PD " + util.format(self._chunk) + ", " + self.resp + ", " + self._number + ", " + self._encoding + ", " + self._remainingBytes + ", " + util.format(self._remainingBuffer) + ", " + self._ended);
			} else if (self._chunk.length > 0) {
				if (self._encoding) {
					// try whether buffer can be converted completely to string
					if (self._remainingBuffer) {
						self._chunk = Buffer.concat([self._remainingBuffer, self._chunk]);
						self._remainingBuffer = null;
					}
					var remaining = exports.bufferEncoding(self._chunk, self._encoding);
					if (remaining) {
						var start = self._chunk.length - remaining;
						if (start === 0) {
							self._remainingBuffer = self._chunk;
							// it does not make sense to send an empty string to the listeners - therefore no 'emit'
						} else {
							self._remainingBuffer = self._chunk.slice(self._chunk.length - remaining);
							var text = self._chunk.slice(0, self._chunk.length - remaining).toString(self._encoding);
							// transmit the data
							self.emit('data', text);
						}
					} else {
						var text = self._chunk.toString(self._encoding);
						self.emit('data', text);
					}
				} else self.emit('data', self._chunk);
			}
			self._chunk = null;
		}
		if (!self._ended) { // no confirmation with end event
			tracer && tracer("Data event with confirmation for " + self._number);
			self._mock._write(_frameHeader(CONFIRMATION + self._response, self._number, 0));
		} else {
			self._processEnd();
		}
	});
};

// write data of this frame to receiving stream (emit 'data' event)
// end: also emit end event
ReadableMockStream.prototype.frame = function(data, end) {
	tracer && tracer("Frame function " + end + " " + this._paused);
	if (this._chunk) throw new Error("Already chunk present " + this._response + "--" + util.format(this._chunk));
	this._ended = end;
	this._chunk = data;
	if (!this._paused) {
		if (data) this._processData();
		else {
			if (end) this._processEnd();
		}
	}
};

ReadableMockStream.prototype.setEncoding = function(encoding) {
	// normalize the encoding
	this._encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, '');
};


function WritableMockStream(options, number, mock, resp) {
	this.writable = true;
	this.readable = false;
	stream.Stream.call(this);
	this._options = options || {
		headers: {},
		statusCode: 200,
		sendDate: true
	};
	this._response = resp; // does this stream belong to a response?
	this._number = number; // sequence number of request
	this._mock = mock; // mock client or mock server
	this._chunk = null;
	this._used = false; // currently no all data have been totally processed
	this._finished = 0; // 0: end has not yet been called, 1: end has been called, 2: end header has been sent
}

util.inherits(WritableMockStream, stream.Stream);

WritableMockStream.prototype.write = function(data, enc, end) {
	var self = this;
	tracer && tracer(self._number + "---------- WRITE " + util.format(data) + " " + enc + " " + end + "--" + self._used);
	if (!self.writable || !self._mock) {
		tracer && tracer(self._number + " ignore write on closed stream");
		return;
	}
	if (self._used) throw new Error(self._number + "Data left");
	if (end) {
		if (!self._finished) self._finished = 1;
	} else {
		if (self._finished) throw new Error(self._number + "No writes after end");
	}
	if (!data) data = new Buffer(0);
	tracer && tracer(self._number + "DATA ????? " + util.format(data));
	if (!Buffer.isBuffer(data)) {
		if (!enc) enc = "utf8";
		data = new Buffer("" + data, enc);
	}
	var list = [];
	if (self._options && !self._hs) {
		tracer && tracer(self._number + "Send frame header for " + self._number);
		var content = new Buffer(JSON.stringify(self._options), "utf8");
		list.push(_frameHeader(STARTFRAME + self._response, self._number, content.length), content);
		self._hs = true; // header sent!!!
		self._options.headers = null;
	}
	if (data.length > 0) {
		tracer && tracer("Send data frame for " + self._number);
		list.push(_frameHeader(self._response + (end ? ENDMARKER : 0), self._number, data.length), data);
	} else {
		list.push(_frameHeader(self._response + (end ? ENDMARKER : 0), self._number, 0));
	}
	self._mock._write(list);
	if (end && self._response) {
		self._mock._deleteRegistry(self._number, true);
	}
	self._used = true;
	return false;
};

WritableMockStream.prototype.end = function(data, enc) {
	var self = this;
	tracer && tracer(self._number + "ENDDATA --- <" + data + ">");
	if (self._finished) {
		tracer && tracer("Ignore second end call");
		return; // ignore
	}
	self._finished = 1;
	if (!self._used) self.write(data, enc, true);
};

WritableMockStream.prototype.destroy = function() {
	this._destroyInt();
};

WritableMockStream.prototype._destroyInt = function(local) {
	var self = this;
	if (self.writable) {
		self.writable = false;
		if (!local) self._mock.close(self._number, self.resp);
		self.emit('close');
		tracer && tracer(self._number + " write stream destroy local " + self.local + " response " + !! self.resp);

	}
};

WritableMockStream.prototype._markFree = function() {
	var self = this;
	tracer && tracer("Mark stream as free again " + self._number);
	self._used = false;
	tracer && tracer(self._number + "USED " + self._used + " fin " + self._finished);
	if (!self._finished) self.emit('drain'); // more data can come unless 'end' has already been called
	else {
		if (self._finished === 1) self.write(null, null, true);
	}
};

// methods of HttpServerResponse
WritableMockStream.prototype.writeHead = function(statusCode) {
	var reasonPhrase;
	var headers;
	var self = this;
	switch (arguments.length) {
		case 3:
			reasonPhrase = arguments[1];
			headers = arguments[2];
			break;
		case 2:
			headers = arguments[1];
			break;
		default:
			break;
	}
	self._options = self._options || {}; // avoid null pointer exceptions 
	if (headers) {
		self._options.headers = headers;
		self._options.writeHeadCalled = true;
	}
	if (reasonPhrase) self._options.reasonPhrase = reasonPhrase;
	self._options.statusCode = statusCode;
	// write header data
	tracer && tracer(self._number + " Write just header data");
	var content = new Buffer(JSON.stringify(self._options), "utf8");
	if (self._mock) self._mock._write([_frameHeader(STARTFRAME + self._response, self._number, content.length), content]);
	self._hs = true; // header sent!!!
	self._options.headers = undefined;
};

// set/get the status code directly within the options property

WritableMockStream.prototype.__defineSetter__("statusCode", function(code) {
	this._options = this._options || {}; // avoid null pointer exceptions 
	this._options.statusCode = code;
});
WritableMockStream.prototype.__defineGetter__("statusCode", function() {
	this._options = this._options || {}; // avoid null pointer exceptions 
	return this._options.statusCode;
});

WritableMockStream.prototype.__defineSetter__("sendDate", function(val) {
	this._options = this._options || {}; // avoid null pointer exceptions 
	this._options.sendDate = val;
});
WritableMockStream.prototype.__defineGetter__("sendDate", function() {
	this._options = this._options || {}; // avoid null pointer exceptions 
	return this._options.sendDate;
});

WritableMockStream.prototype.setHeader = function(name, value) {
	this._options = this._options || {}; // avoid null pointer exceptions
	if (this._hs) throw new Error("setHeader already called");
	try {
		this._options.headers[name] = value;
	} catch (e) {
		throw new Error("setHeader already called");
	}

};

WritableMockStream.prototype.getHeader = function(name) {
	this._options = this._options || {}; // avoid null pointer exceptions
	if (this._hs) throw new Error("setHeader already called");
	try {
		return this._options.headers[name];
	} catch (e) {
		throw new Error("setHeader already called");
	}
};

WritableMockStream.prototype.removeHeader = function(name) {
	if (this._options && this._options.headers) {
		delete this._options.headers[name];
	}
};




/// finds out whether the last multibyte character of this buffer is complete. If not, it returns the number of bytes of this 
/// incomplete character. The function assumes that the buffer contains a part of correctly encoded data.
/// the function assumes that the encoding is already normalized!

function bufferEncoding(buffer, enc) {
	var length = buffer.length;
	switch (enc) {
		case "utf8":
			if (!(buffer[length - 1] & 0x80)) return 0; // single byte character at end
			var i = length - 1;
			var testbyte = 0x40;
			for (var i = 1; i <= length; i++) {
				var byte = buffer[length - i];
				// there cannot be a single byte character directly before a group of non-leading bytes of a multibyte character 
				if (!(byte & 0x80)) throw new Error("Invalid UTF8");
				if (byte & 0x40) { // leading byte
					return (byte & testbyte) ? i : 0; // incomplete sequence when test byte is also set
				}
				testbyte >>= 1;
			}
			// just sequence of non-leading bytes
			return length;
		case "utf16le":
		case "ucs2":
			return (length & 0x01); // number of bytes must be even
		case "hex":
		case "ascii":
			return 0;
		default:
			throw new Error("Wrong encoding " + enc);
	}
}

// builds the frame header out of type, number, length.
// for a frame header with end marker, the property "mockEndMarker" is set on the buffer.

function _frameHeader(type, number, length) {
	tracer && tracer("Header type " + type + " number " + number + " length " + length);
	var b = new Buffer(HEADERLENGTH);
	b[0] = type;
	b.writeUInt32LE(length, 1);
	b.writeUInt32LE(number, 5);
	if (type & ENDMARKER) b.mockEndMarker = true;
	return b;
}

/// ## MockStreamServer
/// This class emulates Streamline's HttpServer. The requests and responses are taken from the mock mechanism but are wrapped within
/// Streamline's HttpServerRequest, HttpServerResponse.
/// parameters: 
/// - disp: request dispatcher function
/// - outputStream: stream to write data to other mock (e. g. process.stdout)
/// - inputStream: stream to get data from other mock (e. g. process.stdin)
/// - clientOptions: options for mock (mainly: timeout)
/// - options: options which will be passed to Streamline's HttpServerRequest, HttpServerResponse
exports.MockStreamServer = function(disp, outputStream, inputStream, clientOptions, options) {
	var self = this;
	var dispatcher = function(request, response) {
		tracer && tracer("+++++++++++++++++++++++++++++Request");
		globals.context = {};
		return disp(new streams.HttpServerRequest(request, options), new streams.HttpServerResponse(response, options), _ >> function(err) {
			if (err) {
				response.writeHead(500, {
					"Content-Type": "text/plain"
				});
				response.end(err.safeStack);
			}
		});
	};
	/// The listen method will start the server and resume the input stream
	/// Parameters: callback function
	self.listen = _(function(callback) {
		tracer && tracer("Listen");
		try {
			self.mockClient = new Mock(outputStream, inputStream, dispatcher, clientOptions);
			inputStream.resume();
			tracer && tracer("LISTEN start");
			return callback();
		} catch (e) {
			return callback(e);
		}
	}, 0);
};



/// ## MemoryStream
/// this class is a writable stream which appends all data to a string (content field). It emulates the HttpResponse methods writeHead etc.

function MemoryStream() {
	stream.Stream.call(this);
	this.writable = true;
	this.content = "";
	this._options = [];
	this.ended = false;
	return this;
}

util.inherits(MemoryStream, stream.Stream);

MemoryStream.prototype.write = function(data) {
	this.content += data;
	return true;
};
MemoryStream.prototype.end = function(data) {
	var self = this;
	if (data) self.content += data;
	self.ended = true;
};
MemoryStream.prototype.writeHead = function(statusCode) {
	var reasonPhrase;
	var headers;
	var self = this;
	switch (arguments.length) {
		case 3:
			reasonPhrase = arguments[1];
			headers = arguments[2];
			break;
		case 2:
			headers = arguments[1];
			break;
		default:
			break;
	}
	if (headers) {
		self._options.headers = headers;
		self._options.writeHeadCalled = true;
	}
	if (reasonPhrase) self._options.reasonPhrase = reasonPhrase;
	self._options.statusCode = statusCode;

};


// set/get the status code directly within the options property

MemoryStream.prototype.__defineSetter__("statusCode", function(code) {
	this._options.statusCode = code;
});
MemoryStream.prototype.__defineGetter__("statusCode", function() {
	return this._options.statusCode;
});

MemoryStream.prototype.__defineSetter__("sendDate", function(val) {
	this._options.sendDate = val;
});
MemoryStream.prototype.__defineGetter__("sendDate", function() {
	return this._options.sendDate;
});

MemoryStream.prototype.setHeader = function(name, value) {
	this._options.headers[name] = value;
};

MemoryStream.prototype.getHeader = function(name) {
	return this._options.headers[name];
};

MemoryStream.prototype.removeHeader = function(name) {
	delete this._options.headers[name];
};

exports.MemoryStream = MemoryStream;

//convenience function: send a request to a server with same options as above self.request, but already as an asynchronous function.
//returns the content of the return stream or throws an exception in case of an error. When the status code is not 200, it also throws
// an error, but with STATUS_CODE set to the status code
var simpleRequest = _(function(client, options, content, callback) {
	var result = "";
	var answered = false;
	var req = client.request(options, function(res) {
		res.setEncoding("utf8");
		res.on("data", function(chunk) {
			result += chunk;
		});
		res.on("end", function(chunk) {
			if (!answered) {
				answered = true;
				if (res.statusCode === 200) {
					return callback(null, result);
				} else {
					var error = new Error(result);
					error.STATUS_CODE = res.statusCode;
					return callback(error);
				}
			}
		});
		res.on('close', function() {
			if (!answered) {
				answered = true;
				return callback('Connection closed');
			}
		});
	});
	req.on("error", function(error) {
		if (!answered) {
			answered = true;
			return callback(error);
		}
	});
	if (content) req.end(content);
	else req.end();
}, 3);
exports.simpleRequest = simpleRequest;

exports.bufferEncoding = bufferEncoding;

// for unit tests
exports._frameHeader = _frameHeader;
exports._WritableMockStream = WritableMockStream;

// very simple write stream which 

function DescriptorWriteStream(fd) {
	var self = this;
	self.writable = true;
	var ended = false;
	self.write = function(data, offset) {
		offset = offset || 0;
		if (!data) {
			if (ended) {
				self.writable = false;
				fs.close(fd);
			}
			return true;
		}
		fs.write(fd, data, offset, data.length - offset, null, function(err, written, buffer) {
			if (err) {
				self.writable = false;
				self.emit('error', err);
			} else {
				if (buffer && written < buffer.length) {
					self.write(buffer, written);
				} else {
					if (ended) {
						self.writable = false;
						fs.close(fd);
					} else {
						self.emit('drain');
					}
				}
			}
		});
		return false;
	};
	self.end = function(data) {
		ended = true;
		self.write(data);
	};
};
DescriptorWriteStream.prototype = new events.EventEmitter();
exports.DescriptorWriteStream = DescriptorWriteStream;