"use strict";

var mocks = require('syracuse-load/lib/mock')
var util = require('util')
var stream = require('stream');

var qmodule = QUnit.module;
qmodule('mock');


// very simple pipe which just passes through everything without change
function SimplePipeStream() {
	var self = this;
	self.readable = true;
	self.writable = true;
	stream.Stream.call(this);
}

util.inherits(SimplePipeStream, stream.Stream);

SimplePipeStream.prototype.write = function(data) {
	console.log("SPS "+util.format(data))
	this.emit("data", data);
	return true;
}

// simple pipe which just passes through everything without change, but on next tick
function AsyncPipeStream() {
	var self = this;
	self.readable = true;
	self.writable = true;
	stream.Stream.call(this);
}

util.inherits(AsyncPipeStream, stream.Stream);

AsyncPipeStream.prototype.write = function(data) {
	console.log("SPS "+util.format(data))
	var self = this;
	process.nextTick(function() { self.emit("data", data); self.emit("drain")} );
	return false;
}

//simple pipe which just passes through everything without change, but after waiting for the number of milliseconds in the timeout
function WaitPipeStream(timeout) {
	var self = this;
	self.readable = true;
	self.writable = true;
	self.timeout = timeout;
	stream.Stream.call(this);
}

util.inherits(WaitPipeStream, stream.Stream);

WaitPipeStream.prototype.write = function(data) {
	var self = this;
	console.log("Wait PS "+util.format(data)+" timeout "+self.timeout)
	setTimeout(function() { self.emit("data", data); self.emit("drain")}, self.timeout );
	return false;
}

//pipe which divides input into 4byte chunks (it 'hashes' the input into pieces)
function HashPipeStream() {
	var self = this;
	self.readable = true;
	self.writable = true;
	stream.Stream.call(this);
}

util.inherits(HashPipeStream, stream.Stream);

HashPipeStream.prototype.write = function(data) {
	var i = 0;
	for (i=0; i+4 <= data.length; i+=4) {
		this.emit("data", data.slice(i, i+4));
	}
	if (i < data.length) this.emit("data", data.slice(i));
	return true;
}


asyncTest('mock read stream test', 20, function(_){
	var parts = [];
	
	parts.push(mocks._frameHeader(1, 5, 0));
	parts.push(mocks._frameHeader(2, 7, 4));
	parts.push(new Buffer("abcd"));
	parts.push(mocks._frameHeader(3, 5, 7));
	parts.push(new Buffer("abcdefg"));
	
	var expected = [[1, 5, null], [2,7, "abcd"], [3,5, "abcdefg"]];
	
	var total = Buffer.concat(parts);
	// console.log("TOTOAL"+util.format(total))
	
	
	var st = new SimplePipeStream();
	var output = new SimplePipeStream();
	var mock = new mocks.Mock(output, st);
	
	var results = []; 
	mock._chunkProcessing = function(type, number, data) { console.log(type+" "+number+" "+util.format(data)); results.push([type, number, data ? data.toString("utf8") : data]) };
	
	st.write(total);
	// compare results
	strictEqual(results.length, expected.length, "correct number")
	for (var i = 0; i < results.length; i++) {
		var res = results[i];
		var exp = expected[i];
		for (var j=0; j< res.length; j++) {
			strictEqual(res[j], exp[j], "Entry "+j+" of result "+i);
		}
	}

	var st2 = new HashPipeStream();
	mock = new mocks.Mock(output, st2);
	var results = []; 
	mock._chunkProcessing = function(type, number, data) { console.log(type+" "+number+" "+util.format(data)); results.push([type, number, data ? data.toString("utf8"): data]) };
	
	st2.write(total);
	// compare results
	strictEqual(results.length, expected.length, "correct number")
	for (var i = 0; i < results.length; i++) {
		var res = results[i];
		var exp = expected[i];
		for (var j=0; j< res.length; j++) {
			strictEqual(res[j], exp[j], "Entry "+j+" of result "+i);
		}
	}
	start();

});

asyncTest('ping test', 3, function(_) {
	var toServer = new WaitPipeStream(5);
	var toClient = new AsyncPipeStream();
	var client = new mocks.Mock(toServer, toClient);
	// server with request handler
	console.log("-----------------------------------------------------------")
	var server = new mocks.Mock(toClient, toServer, function(request, response) {
		response.end();
	});
	var result = client.ping(_);
	console.log(result)
	strictEqual(result >= 0, true, "Ping test with milliseconds: "+result)
	
	var result = client.ping(_, 2000);
	strictEqual(result >= 0, true, "Ping test with large timeout and milliseconds: "+result)
	
	toServer.timeout = 500;
	
	var text = "";
	try {
		result = client.ping(_, 400);
	} catch (e) {
		text = ""+e;
	}
	strictEqual(text, "Error: Timeout after 400 milliseconds", "Ping test with reached timeout")
	
});


asyncTest('copy test', 3, function(_) {
	var result = mocks.extractDataFromRequest({url: 5, method:"get", foo: 18});
	strictEqual(result.url, 5, "Correct url")
	strictEqual(result.method, "get", "Correct method")
	strictEqual(result.foo, undefined, "Do not copy foo")
	start();
});

asyncTest('encoding test', 14, function(_) {
	strictEqual(mocks._bufferEncoding(new Buffer([0xa0, 0x55]), "utf8"), 0, "Single character byte at the end")
	strictEqual(mocks._bufferEncoding(new Buffer([0x81, 0x81]), "utf8"), 2, "Sequence of following bytes")
	strictEqual(mocks._bufferEncoding(new Buffer([0xa0, 0xc0]), "utf8"), 1, "Leading byte of double byte character at end")
	strictEqual(mocks._bufferEncoding(new Buffer([0xc0, 0x81]), "utf8"), 0, "Double byte character at end")
	strictEqual(mocks._bufferEncoding(new Buffer([0x55, 0xe0]), "utf8"), 1, "Part of 3 byte character at end")
	strictEqual(mocks._bufferEncoding(new Buffer([0x55, 0xe0, 0x81]), "utf8"), 2, "Part of 3 byte character at end")
	strictEqual(mocks._bufferEncoding(new Buffer([0x55, 0xe0, 0x81, 0x81]), "utf8"), 0, "Complete 3 byte character at end")
	strictEqual(mocks._bufferEncoding(new Buffer([0x55, 0xf0, 0x81, 0x81]), "utf8"), 3, "Part of 4 byte character at end")
	strictEqual(mocks._bufferEncoding(new Buffer([0x55, 0xf0, 0x81]), "utf8"), 2, "Part of 4 byte character at end")
	strictEqual(mocks._bufferEncoding(new Buffer([0x55, 0xf0]), "utf8"), 1, "Part of 4 byte character at end")
	strictEqual(mocks._bufferEncoding(new Buffer([0x55, 0xf0, 0x81, 0x81, 0x81]), "utf8"), 0, "Complete of 4 byte character at end")
	strictEqual(mocks._bufferEncoding(new Buffer([0x55, 0xe0, 0x81]), "ucs2"), 1, "Odd length for ucs2 encoding")
	strictEqual(mocks._bufferEncoding(new Buffer([0xa0, 0x55]), "ucs2"), 0, "Even length for ucs2 encoding")
	strictEqual(mocks._bufferEncoding(new Buffer([0x55, 0xe0, 0x81]), "hex"), 0, "Odd length for hex encoding")
	start();
});

asyncTest('mock server test', 14, function(_){
	var toServer = new AsyncPipeStream();
	var toClient = new AsyncPipeStream();
	var client = new mocks.Mock(toServer, toClient);
	// server with request handler
	var server = new mocks.Mock(toClient, toServer, function(request, response) {
		var data = "";
		var number = 0;
		var type = 0
		response.statusCode = 555;
		if (type & 0x04) {
			request.pause();
			setTimeout(function() { request.resume();}, 300);
		}
		console.log(">>>>>>>>>>>>>>> "+util.format(request.headers))
		request.on('data', function(chunk) {
			console.log("DATA"+chunk)
			data += chunk.toString();
			number = data.substr(2, 1)*1;
			type = data.substr(3, 1)*1;
			console.log("Server config "+number+" "+type)
			if (type & 0x02) {
				request.pause();
				console.log("PAUSED")
				setTimeout(function() { request.resume();}, 200)
			}
		});
		request.on('end', function() {
			var output = data.length;
			console.log("END <"+output+">")
			if (--number >= 0) response.write(output);
			else {
				if (type & 0x01) response.end(output)
				else response.end();
			}
			response.on('drain', function() {
				if (--number >= 0) {
					response.write(output)
				} else {
					if (type & 0x01) response.end(output)
					else response.end();				
				}
			})			
		});
	});
	
	// test function for requests. input is a string of length 4 and has the following format: 
	// 1st/3rd digit: number of chunks sent by client/server not including end call 
	// 2nd/4th digit: odd: last chunk is end(), even: last chunk is end(...) with content, bit 0x02 set: use pause/resume, bit 0x04 set: use pause/resume in the beginning
	// 3rd/4th digit are only evaluated when at least one chunk of data is sent to the server (1st digit must be > 0 or 2nd digit odd)
	// return value: server computes total length of input (4* first digit) and send this as often as 3rd digit of input requires
	function performRequest(input, callback) {		
		var number = input.substr(0, 1)*1;
		var type = input.substr(1, 1)*1;
		var req = client.request({headers: {test: 1}}, function(res) {
			console.log("Client response")
			var resultData = "";
			if (type & 0x04) {
				res.pause();
				setTimeout(function() { res.resume();}, 2000);
			}
			res.on('data', function(chunk) {
				console.log("Client DATA"+chunk);
				resultData += chunk;
				if (type & 0x02) {
					res.pause();
					setTimeout(function() { res.resume();}, 250)
				}
			});
			res.on('end', function() {
				console.log("Client END "+resultData)
				return callback(null,[resultData, res]);
			})
		})
		if (--number >= 0) req.write(input);
		else {
			if (type & 0x01) req.end(input)
			else req.end();
		}
		req.on('drain', function() {
			if (--number >= 0) {
				req.write(input)
			} else {
				if (type & 0x01) req.end(input)
				else req.end();				
			}
		})			
	}

console.log("=============================================================")



  	var completeResult = performRequest("0000", _) 
	var result = completeResult[0].toString();
	console.log("RESULT <"+result+">")
	strictEqual("", result, "Request with empty response")
	strictEqual(completeResult[1].statusCode, 555, "Correct response status code")

	var result = performRequest("0100", _)[0].toString();
	strictEqual("", result, "Request with end() input and empty response")

	var result = performRequest("1000", _)[0].toString();
	strictEqual("", result, "Request with write() input and empty end() and empty response")
	
	var result = performRequest("1002", _)[0].toString();
	console.log("RESULT <"+result+">")
	strictEqual("", result, "Request with write() input and empty end() and empty response and pause/resume on server")
	
	var result = performRequest("1100", _)[0].toString();
	strictEqual("", result, "Request with write() input and non empty end() and empty response")
	var result = performRequest("1102", _)[0].toString();
	strictEqual("", result, "Request with write() input and non empty end() and empty response and pause/resume on server")
	
	var result = performRequest("3102", _)[0].toString();
	strictEqual("", result, "Request with write() input and non empty end() and empty response and pause/resume on server")
	
	var result = performRequest("1101", _)[0].toString();
	strictEqual("8", result, "Request with write() input and non empty end() and response with end()")
	
	var result = performRequest("1120", _)[0].toString();
	strictEqual("88", result, "Request with write() input and non empty end() and response with write()")
	
	 var result = performRequest("1320", _)[0].toString();
	strictEqual("88", result, "Request with write() input and non empty end() and response with write() and pause/resume on client")
	
	var result = performRequest("2322", _)[0].toString();
	strictEqual("1212", result, "Request with write() input and non empty end() and response with write() and pause/resume on client and server")
	
	var result = performRequest("2323", _)[0].toString();
	strictEqual("121212", result, "Request with write() input and non empty end() and response with write() and non empty end() and pause/resume on client and server")

		var result = performRequest("2723", _)[0].toString();
	strictEqual("121212", result, "Request with write() input and non empty end() and response with write() and non empty end() and pause/resume on client and server and pause/resume in the beginning")


	start();
})

asyncTest('mock server test with encoding', 3, function(_){
	console.log("=========================================================1====")
	var toServer = new AsyncPipeStream();
	var toClient = new AsyncPipeStream();
	var client = new mocks.Mock(toServer, toClient);
	// server with request handler
	console.log("-----------------------------------------------------------")
	var server = new mocks.Mock(toClient, toServer, function(request, response) {
		var data = "";
		var number = 0;
		var type = 0
		console.log(">>>>>>>>>>>>>>> "+util.format(request.headers))
		request.setEncoding('ucs2');
		request.on('data', function(chunk) {
			console.log("DATA"+chunk)
			data += chunk;
		});
		request.on('end', function() {
			console.log("uuuuuuuuuuuuuuuuuServer end")
			response.end(data);
		});
	});
	
	/// test for encoding: input bytes will be converted to output on server using ucs2 encoding
	/// input is an array of strings
	function performRequest(input, callback) {		
		var req = client.request({headers: {test: 1}}, function(res) {
			console.log("Client response")
			var resultData = "";
			res.on('data', function(chunk) {
				console.log("Client DATA"+chunk);
				resultData += chunk;
			});
			res.on('end', function() {
				console.log("Client END "+resultData)
				return callback(null, resultData);
			})
		})
		console.log("PERF "+util.format(input))
		if (input.length > 0) req.write(input.shift())
		else {
			console.log("------CLIENT END")
			req.end();
		}
		req.on('drain', function() {
			if (input.length > 0) {
				req.write(input.shift())
			} else {
				req.end();				
			}
		})			
	}


	strictEqual(performRequest(["a\0b\0", "c\0"], _), "abc", "Request with complete characters")
	strictEqual(performRequest(["a\0b", "\0c", "\0", "d", "\0"], _), "abcd", "Request with incomplete characters")
	strictEqual(performRequest([""], _), "", "Request with incomplete characters 2")

	start();
})


asyncTest('Mock HttpServerResponse metadata test', 16,  function(_) {
	var r = new mocks._WritableMockStream(null, 1, null);
	strictEqual(r._options.statusCode, 200, "Correct initial status code");
	r.statusCode = 205;
	strictEqual(r._options.statusCode, 205, "Correct setter status code");
	r._options.statusCode = 208
	strictEqual(r.statusCode, 208, "Correct getter status code");
	r.setHeader("test", "test1");
	strictEqual(r._options.headers.test, "test1", "Correct set header");
	strictEqual(r.getHeader("test"), "test1", "Correct get header");
	r.removeHeader("test");
	strictEqual("test" in r._options.headers, false, "Correct remove header");
	r.writeHead(333, "Reason", { test2: "test3"});
	strictEqual(r.getHeader("test2"), "test3", "Correct header after writeHead");
	strictEqual(r.statusCode, 333, "Correct statusCode after writeHead");
	strictEqual(r._options.reasonPhrase, "Reason", "Correct reason phrase after writeHead");
	r.writeHead(334);
	strictEqual(r.getHeader("test2"), "test3", "Correct header after writeHead (1 arg)");
	strictEqual(r.statusCode, 334, "Correct statusCode after writeHead (1 arg)");
	strictEqual(r._options.reasonPhrase, "Reason", "Correct reason phrase after writeHead (1 arg)");
	r.writeHead(335, { test5: "test6"});
	strictEqual(r.getHeader("test5"), "test6", "Correct header after writeHead (2 arg)");
	strictEqual("test6" in r._options.headers, false, "Correct new header after writeHead (2 arg)");
	strictEqual(r.statusCode, 335, "Correct statusCode after writeHead (2 arg)");
	strictEqual(r._options.reasonPhrase, "Reason", "Correct reason phrase after writeHead (2 arg)");
	start();
});

asyncTest('Double sided mock test', 1, function(_) {
	var toServer = new AsyncPipeStream();
	var toClient = new AsyncPipeStream();
	var client = new mocks.Mock(toServer, toClient, function(request, response) {
		console.log("ANSWER in client")
		var cliData = "";
		request.on('data', function(chunk) {
			cliData += chunk;
		})
		request.on('end', function() {
			response.end("CL"+cliData);
		})
		
	});
	// server with request handler
	var server = new mocks.Mock(toClient, toServer, function(request, response) {
		var data = "";
		response.statusCode = 555;
		console.log(">>>>>>>>>>>>>>> "+util.format(request.headers))
		request.on('data', function(chunk) {
			data += chunk.toString();
		});
		request.on('end', function() {
			// call back to client
			var intData = "";
			var internalRequest = server.request({header: {test:2}}, function(res) {
				res.on('data', function(chunk) {
					intData += chunk;
				})
				res.on('end', function() {
					response.end("SRV"+intData);
				});
			});
			internalRequest.end(data);
		});
	});
	
	function performRequest(input, callback) {		
		var req = client.request({headers: {test: 1}}, function(res) {
			console.log("Client response")
			var resultData = "";
			res.on('data', function(chunk) {
				console.log("Client DATA"+chunk);
				resultData += chunk;
			});
			res.on('end', function() {
				console.log("Client END "+resultData)
				return callback(null, resultData);
			})
		})
		req.end(input);
	}
	
	strictEqual(performRequest("D", _), "SRVCLD", "server calls client back");
	start();
})
