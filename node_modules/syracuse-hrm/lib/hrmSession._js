"use strict";

var helpers = require('syracuse-core/lib/helpers');
var config = require('config');
var httpClient = require("syracuse-httpclient/lib/httpClient");
var x3helpers = require('syracuse-x3/lib/helpers');
var locale = require("syracuse-core/lib/locale");
var proxy = require('syracuse-main/lib/proxy');

exports.getSession = function(_, context, trace, solution, folder, site, host, port) {
	var JSESSIONID = proxy.getCookie(context.request.headers.cookie, "JSESSIONID");
	trace.debug && trace.debug("Searching context: " + JSON.stringify({
		JSESSIONID: JSESSIONID,
		solution: solution,
		folder: folder,
		site: site,
		host: host,
		port: port
	}, null, 2));
	//console.log("GLOBAL SESSIONS MAP: " + JSON.stringify(context.httpSession && context.httpSession.hrm && context.httpSession.hrm.sessions, null, 2));

	var s;
	if (solution && folder && site) {
		var globalMap = context.httpSession && context.httpSession.hrm && context.httpSession.hrm.sessions;
		var solMap = globalMap && globalMap[solution];
		var folMap = solMap && solMap[folder];
		s = folMap && folMap[site];

		if (s) {
			if (host && port) {
				var baseUrl = "://" + host + ":" + port;
				if (s && s.baseUrl.indexOf(baseUrl) === -1) {
					throw new Error(locale.format(module, "sessionAlreadyExist", s.baseUrl));
				} else {
					trace.info && trace.info("Keep current session configuration");
				}
			}
			if (s.jsid !== JSESSIONID) {
				trace.info && trace.info("JSESSIONID is not corresponding !");
				s.resetCookie();
				return null;
			}
		}
	} else {
		s = context.httpSession && context.httpSession.hrm && context.httpSession.hrm.lastSessionUsed;
		if (s) trace.info && trace.info("Select latest session configuration used because of special resource: " + context.request.url);
	}
	if (s) trace.info && trace.info("***\nSelected session configuration base url: " + JSON.stringify(s, null, 2) + "\n***");
	return s;
};

exports.Session = helpers.defineClass(function(_, sid, site, server, trace) {
	this.sid = sid;

	this.solution = site.solution(_);
	this.folder = site.folder(_);
	this.site = site.name(_);
	this.server = server;
	this.host = server.host(_);

	this.secure = site.secure(_);
	this.port = this.secure ? server.https(_) : server.http(_);
	this.protocol = this.secure ? "https" : "http";

	this.canAuth = false;
	this.authenticated = false;

	var baseUrl = this.protocol + "://" + this.host + ":" + this.port;
	// Call super class
	proxy.Proxy.call(this, _, baseUrl, {
		trace: trace,
		secure: this.secure
	});
	// Set sso base url
	this.ssoBaseUrl = this.baseUrl + "/xtend/xtendsso/" + this.solution + "/" + this.folder + "/" + this.site;
}, proxy.Proxy, {
	connect: function(_, context, certificate, suburl) {

		function getCookie(name, respHead, reqHead) {
			return proxy.getCookie(respHead['set-cookie'], name) || proxy.getCookie(reqHead.cookie, name);
		}

		function getPortal(_) {
			var options = {
				method: context.method,
				url: self.baseUrl + "/xtend/page/" + context.toWalk() + "?" + context.rawQuery,
				headers: context.request.headers
			};
			if (self.secure) {
				options.rejectUnauthorized = false;
				options.strictSSL = false;
			}

			options.headers["xtd-syracuse"] = true;
			self.trace.info && self.trace.info("get portal request: " + JSON.stringify(options, null, 2));
			var request = httpClient.httpRequest(_, options);
			var buf;
			while ((buf = context.request.read(_))) {
				request.write(_, buf, "binary");
			}
			var portResp = request.end().response(_);
			self.trace.debug && self.trace.debug("get portal response:" + JSON.stringify({
				status: portResp.statusCode,
				headers: portResp.headers
			}, null, 2));

			self.jsid = getCookie("JSESSIONID", portResp.headers, options.headers);
			self.xadxid = getCookie("XADXID", portResp.headers, options.headers);
			self.xadxref = getCookie("XADXREF", portResp.headers, options.headers);
			return portResp;
		}

		function connection(_) {
			var body = {
				"solution": self.solution,
				"folder": self.folder
			};
			var data = JSON.stringify(body);
			var header = {
				"content-type": "application/json",
				"accept": "application/json",
				"accept-language": selectedLocale,
				"content-length": data.length,
				"xtd-syracuse": true
			};
			var options = {
				method: "POST",
				url: self.ssoBaseUrl + "/$connections",
				headers: header
			};
			if (self.secure) {
				options.rejectUnauthorized = false;
				options.strictSSL = false;
			}
			self.trace.debug && self.trace.debug("auth request ($connection): " + JSON.stringify(options, null, 2));
			var request = httpClient.httpRequest(_, options);
			var connectResp = request.end(data).response(_);
			// Connection cookies will be required by client
			self.connectSetCookie = connectResp.headers['set-cookie'];

			self.jsid = getCookie("JSESSIONID", connectResp.headers, options.headers);
			self.xadxid = getCookie("XADXID", connectResp.headers, options.headers);
			self.xadxref = getCookie("XADXREF", connectResp.headers, options.headers);

			return connectResp;
		}

		function session(_, body, headers) {
			var pubkeyName = config.sdata.pubkeyName;
			if (certificate) {
				pubkeyName = certificate.name(_).replace(/[\@\$\.]/g, "_");
			} else if (config.x3key) { // use internal certificate of this server
				pubkeyName = require('os').hostname().toLowerCase().replace(/[\@\$\.]/g, "_");
			}
			var sess = {
				connectionId: body.id,
				auth: {
					method: body.auth && body.auth.method,
					pubkey: pubkeyName,
					user: x3login
				}
			};
			sess.auth.signature = x3helpers.getSignature(_, body.auth && body.auth.challenge, x3login, certificate);

			var data = JSON.stringify(sess);

			// Set $connection response cookies in $session request
			// Merge $connection response cookies with the proxy cookies map
			proxy.manageCookie(self.mapCookie, self.sid, headers);

			var header = {
				//"host": host + ":" + port,
				"content-type": "application/json",
				"accept": "application/json",
				"content-length": data.length,
				"content-encoding": "utf-8",
				"accept-language": selectedLocale,
				"cookie": self.mapCookie[self.sid], // Set $connection response cookies in $session request
				"referer": context.httpSession.host + suburl,
				"xtd-syracuse": true
			};
			var opt = {
				method: "POST",
				url: self.ssoBaseUrl + "/$sessions",
				headers: header
			};
			if (self.secure) {
				opt.rejectUnauthorized = false;
				opt.strictSSL = false;
			}
			self.trace.debug && self.trace.debug("auth request ($session): " + JSON.stringify(opt, null, 2));
			var request = httpClient.httpRequest(_, opt);
			var sessResp = request.end(data).response(_);

			self.jsid = getCookie("JSESSIONID", sessResp.headers, opt.headers);
			self.xadxid = getCookie("XADXID", sessResp.headers, opt.headers);
			self.xadxref = getCookie("XADXREF", sessResp.headers, opt.headers);

			return sessResp;
		}
		// BEGIN AUTHENTICATE CLOSURE
		var self = this;
		var resp;


		this.referer = context.request.headers.referer;
		var up = context.getUserProfile(_);
		// Force selected user profile endpoint to get right X3 login
		if (up.selectedEndpoint(_).$uuid !== this.server._parent.endpoint(_).$uuid) {
			up.selectedEndpoint(_, this.server._parent.endpoint(_));
		}
		var x3login = up.user(_).getEndpointLogin(_, up.selectedEndpoint(_).$uuid);
		var selectedLocale = up.selectedLocale(_).code(_);

		try {
			// Send $connection request
			resp = connection(_);

			var connectBody = resp.readAll(_);
			this.trace.debug && this.trace.debug("auth response ($connection):" + JSON.stringify({
				status: resp.statusCode,
				headers: resp.headers
			}, null, 2));
			connectBody = JSON.parse(connectBody);

			if (resp.statusCode !== 201) {
				throw new Error(locale.format(module, "connectionFailed"));
			}
			// Send $session request
			resp = session(_, connectBody, resp.headers);
			this.trace.debug && this.trace.debug("auth response ($session):" + JSON.stringify({
				status: resp.statusCode,
				headers: resp.headers
			}, null, 2));

			if (resp.statusCode !== 200) {
				this.trace.error && this.trace.error("$session response: " + resp.readAll(_));
				throw new Error(locale.format(module, "sessionFailed"));
			}

			this.canAuth = true;
			this.authenticated = true;

			// Set $connection + $session response cookies in first response sent to client
			resp.headers['x-challenge-auth'] = true;
			if (!resp.headers['set-cookie']) resp.headers['set-cookie'] = [];
			resp.headers['set-cookie'] = this.connectSetCookie.concat(resp.headers['set-cookie']);

		} catch (e) {
			this.trace.error && this.trace.error("An error occured while authentication :\n" + JSON.stringify(connectBody, null, 2) + "\n" + e.stack);
			resp = getPortal(_);

		} finally {
			if (resp) {
				// Store original set-cookie information in proxy instance to be able to reuse it.
				if (resp.headers['set-cookie']) {
					this["original-set-cookie"] = resp.headers['set-cookie'];
				}
				// Set response headers (with custom cookies)
				proxy.manageCookie(this.mapCookie, this.sid, resp.headers);
				// Store proxy in httpSession	
				this.storeInHttpSession(context);
				return resp;
			}
		}
	},
	disconnect: function(_, context) {
		try {
			var header = {
				"cookie": this.mapCookie[this.sid],
				"xtd-syracuse": true
			};

			var opt = {
				method: "DELETE",
				url: this.ssoBaseUrl + "/$sessions",
				headers: header
			};
			if (this.secure) {
				opt.rejectUnauthorized = false;
				opt.strictSSL = false;
			}
			this.trace.debug && this.trace.debug("disconnect ($session): " + JSON.stringify(opt, null, 2));
			var request = httpClient.httpRequest(_, opt);
			var resp = request.end().response(_);
			this.trace.debug && this.trace.debug("auth response ($session):" + JSON.stringify({
				status: resp.statusCode,
				headers: resp.headers
			}, null, 2));

			opt = {
				method: "DELETE",
				url: this.ssoBaseUrl + "/$connections",
				headers: header
			};
			if (this.secure) {
				opt.rejectUnauthorized = false;
				opt.strictSSL = false;
			}
			this.trace.debug && this.trace.debug("disconnect ($connections): " + JSON.stringify(opt, null, 2));
			request = httpClient.httpRequest(_, opt);
			resp = request.end().response(_);
			this.trace.debug && this.trace.debug("auth response ($connections):" + JSON.stringify({
				status: resp.statusCode,
				headers: resp.headers
			}, null, 2));

			return resp;
		} catch (e) {
			console.error("Error while disconnecting session :" + this.jsid);
		} finally {
			delete context.httpSession.hrm.sessions[this.solution][this.folder][this.site];
		}
	},
	resetCookie: function() {
		proxy.manageCookie(this.mapCookie, this.sid, {
			"set-cookie": this["original-set-cookie"]
		});
	},
	storeInHttpSession: function(context) {
		//console.log("Store new session: "+JSON.stringify(this,null,2));
		context.httpSession.hrm = context.httpSession.hrm || {};
		context.httpSession.hrm.sessions = context.httpSession.hrm.sessions || {};
		context.httpSession.hrm.sessions[this.solution] = context.httpSession.hrm.sessions[this.solution] || {};
		context.httpSession.hrm.sessions[this.solution][this.folder] = context.httpSession.hrm.sessions[this.solution][this.folder] || {};
		context.httpSession.hrm.sessions[this.solution][this.folder][this.site] = context.httpSession.hrm.sessions[this.solution][this.folder][this.site] || {};

		context.httpSession.hrm.sessions[this.solution][this.folder][this.site] = this;
		context.httpSession.hrm.lastSessionUsed = this;
	},
	toJSON: function() {
		return {
			solution: this.solution,
			folder: this.folder,
			site: this.site,
			baseUrl: this.baseUrl,
			sid: this.sid,
			jsid: this.jsid,
			xadxref: this.xadxref,
			xadxid: this.xadxid,
			"original-set-cookie": this["original-set-cookie"],
			mapCookie: this.mapCookie
		};
	}
});