"use strict";

var flows = require('streamline-runtime').flows;
var locale = require('streamline-locale');
var tracer = require('syracuse-core/lib/trace').getTracer("hrm.loadBalancer");

var lbList = [];

var lbFunnel = flows.funnel(1);
exports.selectServer = function(_, context, site, options) {
	var startTime = new Date().getTime();
	var server;
	try {
		lbFunnel(_, function(_) {

			function getServer(uuid) {
				if (!uuid) return;
				return servers.filter(function(s) {
					return s.$uuid === uuid;
				})[0];
			}

			options = options || {};

			tracer.info && tracer.info("#######################################");
			tracer.info && tracer.info("Begin server selection for site [" + site.name(_) + "]");
			tracer.debug && tracer.debug("Selection options: " + JSON.stringify(options, null, 2));

			var servers = site.servers(_).toArray(_);
			if (servers.length === 0) throw new Error(locale.format(module, "noWebServerOnHrmSite", site.name(_)));

			// remove banned servers and create a map of uuids
			var bannedList = [];
			var realList = servers.filter_(_, function(_, s) {
				var isBanned = s.banned(_);
				if (isBanned) bannedList.push(s.$uuid);
				return !isBanned;
			}).filter_(_, function(_, s) {
				if (site.secure(_)) {
					return s.sslEnabled(_);
				}
				return true;
			}).map(function(s) {
				return s.$uuid;
			});
			tracer.info && tracer.info("Servers linked to site :" + JSON.stringify(realList, null, 2));
			tracer.info && tracer.info("Banned servers :" + JSON.stringify(bannedList, null, 2));
			// ***
			// Synchronize list and real list
			// ***
			// Remove servers from list if banned
			tracer.debug && tracer.debug("*** LB List before remove banned :" + JSON.stringify(lbList, null, 2));
			lbList = lbList.filter(function(item) {
				return bannedList.indexOf(item) === -1;
			});
			// Add never balanced servers
			tracer.debug && tracer.debug("*** LB List before add new servers :" + JSON.stringify(lbList, null, 2));
			lbList = realList.filter(function(item) {
				return lbList.indexOf(item) === -1;
			}).concat(lbList);
			// reorder realList
			realList = lbList.filter(function(item) {
				return realList.indexOf(item) !== -1;
			});
			//
			var port;
			var idx = 0;
			if (options.host && options.port) {
				var srvUuid;
				for (var j in servers) {
					port = site.secure(_) ? servers[j].https(_) : servers[j].http(_);
					if (servers[j].host(_) === options.host && port === options.port) {
						srvUuid = servers[j].$uuid;
						break;
					}
				}
				if (!srvUuid) throw new Error(locale.format(module, "noServerMatchInConf", options.host + ":" + options.port));
				idx = realList.indexOf(srvUuid);
				if (idx === -1) {
					// Check if banned
					if (bannedList.indexOf(srvUuid) !== -1) {
						throw new Error(locale.format(module, "serverBanned", options.host + ":" + options.port));
					}
					throw new Error(locale.format(module, "noServerMatchInLB", options.host + ":" + options.port));
				}
			}
			// ***
			// Select server to use and Apply round robin algorithm : the first become the last...
			// ***
			var selectedUuid = realList[idx];
			tracer.debug && tracer.debug("*** LB List before apply round robin :" + JSON.stringify(lbList, null, 2));

			server = getServer(selectedUuid);
			if (!server) throw new Error(locale.format(module, "noServerAvailable"));

			var lastIdx = idx;
			var lbIdx = lbList.indexOf(selectedUuid);

			if (!options.ignoreAvailability) {
				// check availability
				var msg;
				// Sync callback is needed for unit tests : I don't know why ? maybe streamline config is not the same in QUnit context
				if (!server.isServerRunning(_, site.secure(_)) && !options.host && !options.port) {
					var firstSelSrv = selectedUuid;
					// As not available, remove it from LB list
					lbIdx = lbList.indexOf(realList[lastIdx]);
					lbList.splice(lbIdx, 1);
					port = site.secure(_) ? server.https(_) : server.http(_);
					msg = locale.format(module, "serverNotAvailable", server.host(_), port);
					if (options.SRVHOST && options.SRVPORT) {
						throw new Error(msg);
					}
					server = null;
					for (var k in realList) {
						if (realList[k] !== firstSelSrv) {
							server = getServer(realList[k]);
							port = site.secure(_) ? server.https(_) : server.http(_);
							if (server.isServerRunning(_)) {
								msg += "\n" + locale.format(module, "serverAvailable", server.host(_), port);
								selectedUuid = realList[k];
								lbIdx = lbList.indexOf(selectedUuid);
								break;
							} else {
								// As not available, remove it from LB list
								lbIdx = lbList.indexOf(realList[k]);
								lbList.splice(lbIdx, 1);
								msg += "\n" + locale.format(module, "serverNotAvailable", server.host(_), port);
								server = null;
							}
						}
					}
				}
				if (!server) throw new Error(locale.format(module, "noServerAvailable") + (msg ? "\n" + msg : ""));
			}

			// Apply round robin
			if (lbList.length > 1) {
				lbList.splice(lbIdx, 1);
				lbList.push(selectedUuid);
			}
			tracer.debug && tracer.debug("*** LB List after apply round robin :" + JSON.stringify(lbList, null, 2));
			tracer.info && tracer.info("Selected server : " + server.$uuid);
			if (server.$uuid !== selectedUuid) server = getServer(selectedUuid);
		});
	} catch (e) {
		//helpers.log.error(module, e);
		tracer.error && tracer.error("HRM load balancer error: " + e.stack);
		throw e;
	}
	var endTime = new Date().getTime();
	tracer.info && tracer.info("Selection time: " + (endTime - startTime) + "ms");
	return server;
};