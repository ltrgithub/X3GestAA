"use strict";

var helpers = require("syracuse-core/lib/helpers");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var flows = require("streamline/lib/util/flows");
var locale = require("syracuse-core/lib/locale");
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var hrmHelper = require('syracuse-hrm/lib/hrmHelper');

var trace = nodeconfig.config && nodeconfig.config.hrm && nodeconfig.config.hrm.lb && nodeconfig.config.hrm.lb.trace;
var lbList = [];

var lbFunnel = flows.funnel(1);
exports.selectServer = function(_, siteOptions, options) {
	var startTime = new Date().getTime();
	var server;
	try {
		lbFunnel(_, function(_) {

			function getServer(uuid) {
				if (!uuid) return;
				return servers.filter(function(s) {
					return s.$uuid === uuid;
				})[0];
			}

			options = options || {};

			var db = adminHelper.getCollaborationOrm(_);
			// Retrieve HRM Site instance
			var _site = hrmHelper.getHrmSite(_, db, siteOptions);
			if (!_site) throw new Error(locale.format(module, "hrmSiteNotFound", JSON.stringify(siteOptions, null, 2)));

			trace && trace("#######################################");
			trace && trace("Begin server selection for site [" + _site.name(_) + "]");
			trace && trace("Selection options: " + JSON.stringify(options, null, 2));

			var servers = _site.servers(_).toArray(_);
			if (servers.length === 0) throw new Error(locale.format(module, "noWebServerOnHrmSite", _site.name(_)));

			// remove banned servers and and create a map of uuids
			var bannedList = [];
			var realList = servers.filter_(_, function(_, s) {
				var isBanned = s.banned(_);
				if (isBanned) bannedList.push(s.$uuid);
				return !isBanned;
			}).map(function(s) {
				return s.$uuid;
			});
			trace && trace("Servers linked to site :" + JSON.stringify(realList, null, 2));
			trace && trace("Banned servers :" + JSON.stringify(bannedList, null, 2));
			// ***
			// Synchronize list and real list
			// ***
			// Remove servers from list if banned
			trace && trace("*** LB List before remove banned :" + JSON.stringify(lbList, null, 2));
			lbList = lbList.filter(function(item) {
				return bannedList.indexOf(item) === -1;
			});
			// Add never balanced servers
			trace && trace("*** LB List before add new servers :" + JSON.stringify(lbList, null, 2));
			lbList = realList.filter(function(item) {
				return lbList.indexOf(item) === -1;
			}).concat(lbList);
			// reorder realList
			realList = lbList.filter(function(item) {
				return realList.indexOf(item) !== -1;
			});
			// 
			var idx = 0;
			if (options.host && options.port) {
				var srvUuid;
				for (var j in servers) {
					if (servers[j].host(_) === options.host && servers[j].port(_) === options.port) {
						srvUuid = servers[j].$uuid;
						break;
					}
				}
				if (!srvUuid) throw new Error(locale.format(module, "noServerMatchInConf", options.host + ":" + options.port));
				idx = realList.indexOf(srvUuid);
				if (idx === -1) {
					// Check if banned
					if (bannedList.indexOf(srvUuid) !== -1)
						throw new Error(locale.format(module, "serverBanned", options.host + ":" + options.port));
					throw new Error(locale.format(module, "noServerMatchInLB", options.host + ":" + options.port));
				}
			}
			// ***
			// Select server to use and Apply round robin algorithm : the first become the last...
			// ***
			var selectedUuid = realList[idx];
			trace && trace("*** LB List before apply round robin :" + JSON.stringify(lbList, null, 2));

			server = getServer(selectedUuid);
			if (!server) throw new Error(locale.format(module, "noServerAvailable"));

			var lastIdx = idx;
			var lbIdx = lbList.indexOf(selectedUuid);

			if (!options.ignoreAvailability) {
				// check availability
				var msg;
				// Sync callback is needed for unit tests : I don't know why ? maybe streamline config is not the same in QUnit context
				if (!server.isServerRunning(_)) {
					var firstSelSrv = selectedUuid;
					// As not available, remove it from LB list
					lbIdx = lbList.indexOf(realList[lastIdx]);
					lbList.splice(lbIdx, 1);
					msg = locale.format(module, "serverNotAvailable", server.host(_), server.port(_));
					if (options.SRVHOST && options.SRVPORT) {
						throw new Error(msg);
					}
					server = null;
					for (var k in realList) {
						if (realList[k] !== firstSelSrv) {
							server = getServer(realList[k]);
							if (server.isServerRunning(_)) {
								msg += "\n" + locale.format(module, "serverAvailable", server.host(_), server.port(_));
								selectedUuid = realList[k];
								lbIdx = lbList.indexOf(selectedUuid);
								break;
							} else {
								// As not available, remove it from LB list
								lbIdx = lbList.indexOf(realList[k]);
								lbList.splice(lbIdx, 1);
								msg += "\n" + locale.format(module, "serverNotAvailable", server.host(_), server.port(_));
								server = null;
							}
						}
					}
				}
				if (!server) throw new Error(locale.format(module, "noServerAvailable") + (msg ? "\n" + msg : ""));
			}

			// Apply round robin
			if (lbList.length > 1) {
				lbList.splice(lbIdx, 1);
				lbList.push(selectedUuid);
			}
			trace && trace("*** LB List after apply round robin :" + JSON.stringify(lbList, null, 2));
			trace && trace("Selected server : " + server.$uuid);
			if (server.$uuid !== selectedUuid) server = getServer(selectedUuid);
		});
	} catch (e) {
		//helpers.log.error(module, e);
		trace && trace("HRM load balancer error: " + e.stack);
		throw e;
	}
	var endTime = new Date().getTime();
	trace && trace("Selection time: " + (endTime - startTime) + "ms");
	return server;
};