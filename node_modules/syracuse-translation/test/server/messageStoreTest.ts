"use strict";
//
/* global QUnit: false, ok: false, it: false, equal: false, strictEqual: false, same: false, start: false, stop: false */
var fs = require('streamline-fs');
var fsp = require("path");
var sys = require("util");
var helpers = require('@sage/syracuse-core').helpers;
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var locale = require('streamline-locale');
var uuid = require('@sage/syracuse-core').uuid;
var sha1 = require("syracuse-translation/lib/helpers").sha1;
var messageStore = require("syracuse-translation/lib/messageStore");
var MessageSet = messageStore.MessageSet;

var tracer = console.log;

import { assert } from 'chai';
Object.keys(assert).forEach(key => {
	if (key !== 'isNaN') global[key] = assert[key];
});

describe(module.id, () => {

	var set = new MessageSet();
	var chp1 = 10031,
		chp2 = 10036,
		$lbound1 = 1,
		$ubound1 = 100,
		$lbound2 = $ubound1 + 1,
		$ubound2 = 1000,
		max = 1999;


	function filterKeys(k) {
		return k[0] != "$";
	}


	it('Message set init', function(_) {

		var set2 = new MessageSet();
		var key = sha1("10031/1/XXX");
		set2.init(10031, 1, "XXX", key);
		set2.init(10031, 1, "ENG", "10031/1/ENG");
		set2.init(10031, 1, "FRA", "10031/1/FRA");

		strictEqual(key, set2.getText(10031, 1, "XXX").text, "Init XXX with " + key + " ok");
		strictEqual("10031/1/ENG", set2.getText(10031, 1, "ENG").text, "Init ENG ok");
		strictEqual("10031/1/FRA", set2.getText(10031, 1, "FRA").text, "Init FRA ok");

		set2 = new MessageSet();
		set2.init(10031, 1, "ENG", "10031/1/ENG");
		set2.init(10031, 1, "FRA", "10031/1/FRA");
		set2.init(10031, 1, "XXX", key);

		strictEqual("10031/1/ENG", set2.getText(10031, 1, "ENG").text, "Init ENG ok");
		strictEqual("10031/1/FRA", set2.getText(10031, 1, "FRA").text, "Init FRA ok");
		strictEqual(key, set2.getText(10031, 1, "XXX").text, "Init XXX with " + key + " ok");

		set2 = new MessageSet();
		set2.init(10031, 1, "ENG", "10031/1/ENG");
		set2.init(10031, 1, "FRA", "10031/1/FRA");
		set2.init(10031, 1, "XXX", key);

		set2.init(10031, 2, "ENG", "10031/2/ENG");
		set2.init(10031, 2, "FRA", "10031/2/FRA");
		set2.init(10031, 2, "XXX", key);

		strictEqual("10031/1/ENG", set2.getText(10031, 1, "ENG").text, "Init ENG ok");
		strictEqual("10031/1/FRA", set2.getText(10031, 1, "FRA").text, "Init FRA ok");
		strictEqual(key, set2.getText(10031, 1, "XXX").text, "Init XXX ok");
		strictEqual("10031/2/ENG", set2.getText(10031, 2, "ENG").text, "Init ENG ok");
		strictEqual("10031/2/FRA", set2.getText(10031, 2, "FRA").text, "Init FRA ok");
		strictEqual(key, set2.getText(10031, 2, "XXX").text, "Init XXX ok");
		strictEqual(2, set2.getByKey(key).length, "2 entries for key " + key);

		set2 = null;

		var chp, id, langs = ["BRI", "ENG", "FRA"];

		function init(lan) {
			set.init(chp, id, lan, chp + " " + id + " " + lan);
		}

		for (chp = chp1; chp <= chp2; chp++) {
			for (id = $lbound1; id <= $ubound1; id++) {
				langs.forEach(init);
			}
		}

		var chpCount = 0,
			unitCount = 0,
			count = 0;

		var eq = true;
		var verified = true;
		var stateVerified = true;
		set.traverse(function(context, chp, id, lan, text, meta) {
			if (id === undefined) {
				chpCount++;
				return;
			}
			if (lan === undefined) {
				unitCount++;
			}
			if (lan == null || id == null) {
				return;
			}
			count++;
			var state = meta && meta.state;
			eq = text === (chp + " " + id + " " + lan);
			eq = eq && ((lan === messageStore.defaultLanguage.x3 && meta.lanori === "") || (meta.lanori === messageStore.defaultLanguage.x3));
			if (!eq) {
				strictEqual(text, chp + " " + id + " " + lan);
				strictEqual(meta.lanori, messageStore.defaultLanguage.x3);
			}
			stateVerified = stateVerified && (state == "clean");
		});

		strictEqual(chpCount, chp2 - chp1 + 1, "Chapter count ok ==> " + chpCount);
		strictEqual(unitCount, (chp2 - chp1 + 1) * ($ubound1 - $lbound1 + 1), "Unit count ok ==> " + unitCount);
		strictEqual(count, (chp2 - chp1 + 1) * ($ubound1 - $lbound1 + 1) * langs.length, "Text count ok ==> " + count);

		ok(verified, "all messages are verified");
		ok(stateVerified, "all messages state are verified");

	});

	it('Message creation', function(_) {
		var langs = ["BRI", "ENG", "FRA", "XXX"],
			chp = chp1,
			id;

		function create(lan) {
			var text = chp + " " + id + " " + lan;
			if (lan === "XXX")
				text = sha1(text);

			set.setText(chp, id, lan, text);
		}

		for (id = $lbound2; id <= $ubound2; id++) {
			langs.forEach(create);
		}

		var chpCount = 0,
			unitCount = 0,
			count = 0;

		var eq = true;
		var eq2 = true;
		var verified = true;
		var stateVerified = true;
		var notVerified;
		var expected;
		set.traverse(function(context, chp, id, lan, text, meta) {
			if (id === undefined) {
				chpCount++;
				return;
			}
			if (lan === undefined) {
				unitCount++;
			}
			if (text === undefined)
				return;

			count++;

			var state = meta && meta.state;
			expected = chp + " " + id + " " + lan;
			if (lan === "XXX") expected = sha1(expected);

			eq = text === expected;
			verified = verified && eq;
			if (!eq) {
				strictEqual(text, expected, "value equal");
			}
			expected = id > $ubound1 ? "created" : "clean";
			if (state != expected) {
				eq = false;
				strictEqual(state, expected, "Verify state of " + chp + " " + id + " " + lan);
			}
			stateVerified = stateVerified && eq;
		});

		// strictEqual(chpCount, chp2 - chp1 + 1, "Chapter count ok ==> " + chpCount);
		// strictEqual(unitCount, (chp2 - chp1 + 1) * ($ubound1 - $lbound1 + 1), "Unit count ok ==> " + unitCount);
		// strictEqual(count, (chp2 - chp1 + 1) * ($ubound1 - $lbound1 + 1) * langs.length, "Text count ok ==> " + count);

		ok(verified, "all messages are verified");
		ok(stateVerified, "all messages state are verified");

	});

	function EndpointMock() {

	}

	EndpointMock.prototype = {
		application: function(_) {
			return "test";
		},
		contract: function(_) {
			return "test";
		},
		dataset: function(_) {
			return "test";
		}
	};

	function fakeSubmit(_, url, body, opt) {
		tracer && tracer("fakeSubmit: url" + url + ", opt=" + opt + ", body:\n" + body);
	}

	function hackStore(mstore) {
		mstore.reader._old_submit = mstore.reader.submit;
		mstore.reader.submit = fakeSubmit;
		mstore.writer._old_submit = mstore.writer.submit;
		mstore.writer.submit = fakeSubmit;
	}

	function diagnosis() {
		var hasError = false;

		function report(severity, message) {
			if (severity === "error") hasError = true;
			tracer && tracer("[" + severity.toUpperCase() + "] " + message);
		}

		return {
			info: report.bind(undefined, "info"),
			warning: report.bind(undefined, "warning"),
			error: report.bind(undefined, "error"),
			add: report,
			addAll: report,
			fatal: report,
			logInfo: report.bind(undefined, "info"),
			logError: report.bind(undefined, "error"),
			logWarning: report.bind(undefined, "warning"),
			logClose: function() {},
			hasError: function() {
				return hasError;
			}
		};
	}

	it('Message loading', function(_) {
		// var file = __dirname + "/../fixtures/translation/messages-10031-10035-akira.txt",
		var file = __dirname + "/../fixtures/translation/messages-10031-10035-akira.txt",
			data = fs.exists(file, _) && fs.readFile(file, "utf8", _),
			lineCount = data && data.split("\n").filter(function(l) {
				return l.length;
			}).length || 0;

		// ===============================
		// Reading file...
		// ===============================
		ok(data != null, "data read, length=" + (data && data.length || 0));

		var context = {},
			endpointRead = new EndpointMock(),
			endpointWrite = new EndpointMock(),
			opts = {
				diagnosis: diagnosis()
			};
		var mstore = new messageStore.X3ClobMessageStore(context, endpointRead, endpointWrite, opts);

		mstore && mstore.init(_);
		hackStore(mstore);

		// ===============================
		// Loading contents...
		// ===============================
		var fetched = mstore.load(data);
		strictEqual(fetched, lineCount, "fetch count=" + lineCount);

		// ===============================
		// Verifying contents...
		// ===============================
		var mset = mstore.set;

		var count = 0;
		var missingKeys = [];
		mset.traverse(function(context, chp, id, lan, text, meta) {
			if (id == null || chp == null)
				return;
			if (lan == null) {
				!context.$id["XXX"] && missingKeys.push(chp + "/" + id);
				return;
			}
			if (text != null)
				count++;
		}, {
			sort: true
		});
		strictEqual(count, lineCount, "traverse count=" + lineCount);
		strictEqual(missingKeys.length, 0, "no missing keys ==> " + JSON.stringify(missingKeys));

		var v = mset.get(10031, 41, "FRA"),
			m = mset.getMeta(10031, 41, "FRA"),
			// e  =mset.getEntry(10031, 41, "FRA"),
			e = mset.getByKey("7A20636D48AD60721209BC6D5A9E89E1A9A67530"),
			e0 = e && e[0],
			e1, res;

		ok(e && e.length === 1, "Single entry returned");
		strictEqual(v, "Wrong authentication method {0}", "get text of 10031,41,FRA ==> '" + v + "'");
		strictEqual(m.lanori, "ENG", "lanori of 10031,41,FRA ==> " + m.lanori);
		strictEqual(e0.text["FRA"], "Wrong authentication method {0}", "get text by hash '7A20636D48AD60721209BC6D5A9E89E1A9A67530' ==> '" + e0.text["FRA"] + "'");
		strictEqual(e0.$origin, "10031/41", "get origin by hash '7A20636D48AD60721209BC6D5A9E89E1A9A67530' ==> " + e0.$origin);
		strictEqual(e0.$key, "7A20636D48AD60721209BC6D5A9E89E1A9A67530", "get key by hash '7A20636D48AD60721209BC6D5A9E89E1A9A67530' ==> " + e0.$key);
		strictEqual(e0.$meta["FRA"].lanori, "ENG", "get lanori by hash '7A20636D48AD60721209BC6D5A9E89E1A9A67530' ==> " + e0.$meta["FRA"].lanori);

		e = mset.getByKey("EFE91353E33FC2198577A048A4FB3DFF6FE67F4B");
		e0 = e && e[0];
		e1 = e && e[1];
		ok(e && e.length === 2, "2 entries returned");
		strictEqual(e0.text["CHI"], "由于许可证限制，对以下标记的访问已被拒绝：{0}. _", "get text[0] by hash 'EFE91353E33FC2198577A048A4FB3DFF6FE67F4B' ==> '" + e0.text["CHI"] + "'");
		strictEqual(e1.text["CHI"], "当用户较少时，您可以再试一次。", "get text[1] by hash 'EFE91353E33FC2198577A048A4FB3DFF6FE67F4B' ==> '" + e0.text["CHI"] + "'");
		strictEqual(e0.$origin, "10032/482", "get origin[0] by hash 'EFE91353E33FC2198577A048A4FB3DFF6FE67F4B' ==> " + e0.$origin);
		strictEqual(e1.$origin, "10032/483", "get origin[1] by hash 'EFE91353E33FC2198577A048A4FB3DFF6FE67F4B' ==> " + e1.$origin);

		res = mset.getMessageByKey("EFE91353E33FC2198577A048A4FB3DFF6FE67F4B", "CHI");
		ok(res && res.chunks && res.chunks.length === 2, "2 entries returned");
		strictEqual(res.message, "由于许可证限制，对以下标记的访问已被拒绝：{0}. 当用户较少时，您可以再试一次。", "get message by hash 'EFE91353E33FC2198577A048A4FB3DFF6FE67F4B' ==> '" + res.message + "'");
		strictEqual(res.chunks[0], "由于许可证限制，对以下标记的访问已被拒绝：{0}. _", "get message chunk[0] by hash 'EFE91353E33FC2198577A048A4FB3DFF6FE67F4B' ==> '" + res.chunks[0] + "'");
		strictEqual(res.chunks[1], "当用户较少时，您可以再试一次。", "get message chunk[1] by hash 'EFE91353E33FC2198577A048A4FB3DFF6FE67F4B' ==> '" + res.chunks[1] + "'");
		strictEqual(res.$entry[0].$origin, "10032/482", "get origin[0] by hash 'EFE91353E33FC2198577A048A4FB3DFF6FE67F4B' ==> " + res.$entry[0].$origin);
		strictEqual(res.$entry[1].$origin, "10032/483", "get origin[1] by hash 'EFE91353E33FC2198577A048A4FB3DFF6FE67F4B' ==> " + res.$entry[1].$origin);

		var key = sha1("abc/def/0001"),
			message = "Un nouveau message court en Français";

		mset.upsertMessage(message, {
			iso: "fr-fr",
			x3: "FRA"
		}, key);
		e = mset.getByKey(key);
		// console.log("  getByKey=" + JSON.stringify(e, null, "\t"));
		e0 = e && e[0];
		e1 = e && e[1];
		ok(e && e.length === 1, "1 entries returned");
		strictEqual(e0.text["FRA"], message, "set / get short French message ==> '" + e0.text["FRA"] + "'");
		strictEqual(e0.$key, key, "get key by hash '" + key + "' ==> " + e0.$key);
		strictEqual(e0.$origin, "10033/1095", "get origin[0] by hash '" + key + "' ==> " + e0.$origin);

		message = "A short message in English";
		mset.upsertMessage(message, {
			iso: "en-us",
			x3: "ENG"
		}, key);
		strictEqual(e0.text["ENG"], message, "set short English message ==> '" + e0.text["ENG"] + "'");
		strictEqual(e0.$key, key, "get key by hash '" + key + "' ==> " + e0.$key);
		strictEqual(e0.$origin, "10033/1095", "get origin[0] by hash '" + key + "' ==> " + e0.$origin);

		key = sha1("abc/def/0002"),
			message = "A long message long message long message long message long message long message long message long message long message long message long message in English";
		mset.upsertMessage(message, {
			iso: "en-us",
			x3: "ENG"
		}, key);
		e = mset.getByKey(key);
		e0 = e && e[0];
		e1 = e && e[1];
		ok(e && e.length === 2, "2 entries returned");
		equal(e0.text["ENG"], "A long message long message long message long message long message long message long message long message long message _", "long English message[0] ==> '" + e0.text["ENG"] + "'");
		strictEqual(e1.text["ENG"], "long message long message in English", "long English message[1] ==> '" + e1.text["ENG"] + "'");
		var str = mset.reassembleText(e, "ENG");
		strictEqual(str, message, "reassembleText ==> '" + str + "'");
		strictEqual(e0.$key, key, "get key by hash '" + key + "' ==> " + e0.$key);
		strictEqual(e0.$origin, "10033/1096", "get origin[0] by hash '" + key + "' ==> " + e0.$origin);
		strictEqual(e1.$origin, "10033/1097", "get origin[0] by hash '" + key + "' ==> " + e1.$origin);

		var rec = mset.reassembleEntry(e);
		str = rec.text["ENG"];
		strictEqual(str, message, "reassembleEntry text ==> '" + str + "'");
		strictEqual(rec.$key, key, "reassembleEntry key ==> '" + rec.$key + "'");
	});
});