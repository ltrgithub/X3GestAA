"use strict";
//
/* global QUnit: false, ok: false, asyncTest: false, test: false, equal: false, strictEqual: false, same: false, start: false, stop: false */
var fs = require('streamline-fs');
var fsp = require("path");
var sys = require("util");
var helpers = require('syracuse-core/lib/helpers');
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var locale = require('streamline-locale');
var uuid = require("syracuse-core/lib/uuid");
var sha1 = require("node-oauth/lib/sha1");
var messageStore = require("syracuse-translation/lib/messageStore");

var tracer = console.log;

var doStop = false;
QUnit.module(module.id, {
	setup: function() {},
	teardown: function() {
		if (doStop) {
			setTimeout(function() {
				process.kill(process.pid);
			}, 100);
		}
	}
});

var set = new messageStore.MessageSet();
var chp1 = 10031,
	chp2 = 10036,
	$lbound1 = 1,
	$ubound1 = 100,
	$lbound2 = $ubound1 + 1,
	$ubound2 = 1000,
	max = 1999;


function filterKeys(k) {
	return k[0] != "$";
}


asyncTest("Message set init", function(_) {
	var chp, id, langs = ["BRI", "ENG", "FRA"];

	function init(lan) {
		set.init(chp, id, lan, chp + " " + id + " " + lan);
	}

	for (chp = chp1; chp <= chp2; chp++) {
		for (id = $lbound1; id <= $ubound1; id++) {
			langs.forEach(init);
		}
	}

	var chpCount = 0,
		unitCount = 0,
		count = 0;

	var eq = true;
	var verified = true;
	var stateVerified = true;
	set.traverse(function(context, chp, id, lan, text, meta) {
		if (id === undefined) {
			chpCount++;
			return;
		}
		if (lan === undefined) {
			unitCount++;
		}
		if (lan == null || id == null) {
			return;
		}
		count++;
		var state = meta && meta.state;
		eq = text === (chp + " " + id + " " + lan);
		eq = text === (chp + " " + id + " " + lan);
		eq = eq && ((lan === messageStore.defaultLanguage.x3 && meta.lanori === "") || (meta.lanori === messageStore.defaultLanguage.x3));
		if (!eq) {
			strictEqual(text, chp + " " + id + " " + lan);
			strictEqual(meta.lanori, messageStore.defaultLanguage.x3);
		}
		stateVerified = stateVerified && (state == "clean");
	});

	strictEqual(chpCount, chp2 - chp1 + 1, "Chapter count ok ==> " + chpCount);
	strictEqual(unitCount, (chp2 - chp1 + 1) * ($ubound1 - $lbound1 + 1), "Unit count ok ==> " + unitCount);
	strictEqual(count, (chp2 - chp1 + 1) * ($ubound1 - $lbound1 + 1) * langs.length, "Text count ok ==> " + count);

	ok(verified, "all messages are verified");
	ok(stateVerified, "all messages state are verified");

	start();
});

asyncTest("Message creation", function(_) {
	var langs = ["BRI", "ENG", "FRA", "XXX"],
		chp = chp1,
		id;

	function create(lan) {
		var text = chp + " " + id + " " + lan;
		if (lan === "XXX")
			text = sha1.hex_sha1(text);

		set.setText(chp, id, lan, text);
	}

	for (id = $lbound2; id <= $ubound2; id++) {
		langs.forEach(create);
	}

	var chpCount = 0,
		unitCount = 0,
		count = 0;

	var eq = true;
	var eq2 = true;
	var verified = true;
	var stateVerified = true;
	var notVerified;
	var expected;
	set.traverse(function(context, chp, id, lan, text, meta) {
		if (id === undefined) {
			chpCount++;
			return;
		}
		if (lan === undefined) {
			unitCount++;
		}
		if (text === undefined)
			return;

		count++;

		var state = meta && meta.state;
		expected = chp + " " + id + " " + lan;
		if (lan === "XXX") expected = sha1.hex_sha1(expected);

		eq = text === expected;
		verified = verified && eq;
		if (!eq) {
			strictEqual(text, expected, "value equal");
		}
		expected = id > $ubound1 ? "created" : "clean";
		if (state != expected) {
			eq = false;
			strictEqual(state, expected, "Verify state of " + chp + " " + id + " " + lan);
		}
		stateVerified = stateVerified && eq;
	});

	// strictEqual(chpCount, chp2 - chp1 + 1, "Chapter count ok ==> " + chpCount);
	// strictEqual(unitCount, (chp2 - chp1 + 1) * ($ubound1 - $lbound1 + 1), "Unit count ok ==> " + unitCount);
	// strictEqual(count, (chp2 - chp1 + 1) * ($ubound1 - $lbound1 + 1) * langs.length, "Text count ok ==> " + count);

	ok(verified, "all messages are verified");
	ok(stateVerified, "all messages state are verified");

	start();
});

function EndpointMock() {

}

EndpointMock.prototype = {
	application: function(_) {
		return "test";
	},
	contract: function(_) {
		return "test";
	},
	dataset: function(_) {
		return "test";
	}
};

function fakeSubmit(_, url, body, opt) {
	tracer && tracer("fakeSubmit: url" + url + ", opt=" + opt + ", body:\n" + body);
}

function hackStore(mstore) {
	mstore.reader._old_submit = mstore.reader.submit;
	mstore.reader.submit = fakeSubmit;
	mstore.writer._old_submit = mstore.writer.submit;
	mstore.writer.submit = fakeSubmit;
}

function diagnosis() {
	var hasError = false;

	function report(severity, message) {
		if (severity === "error") hasError = true;
		tracer && tracer("[" + severity.toUpperCase() + "] " + message);
	}

	return {
		info: report.bind(undefined, "info"),
		warning: report.bind(undefined, "warning"),
		error: report.bind(undefined, "error"),
		add: report,
		addAll: report,
		fatal: report,
		logInfo: report.bind(undefined, "info"),
		logError: report.bind(undefined, "error"),
		logWarning: report.bind(undefined, "warning"),
		logClose: function() {},
		hasError: function() {
			return hasError;
		}
	};
}

asyncTest("Message loading", function(_) {
	// var file = __dirname + "/../fixtures/translation/messages-10031-10035-akira.txt",
	var file = __dirname + "/../fixtures/translation/messages-10031-10035-akira.txt",
		data = fs.exists(file, _) && fs.readFile(file, "utf8", _),
		lineCount = data && data.split("\n").filter(function(l) {
			return l.length;
		}).length || 0;

	// ===============================
	// Reading file...
	// ===============================
	ok(data != null, "data read, length=" + (data && data.length || 0));

	var context = {}, endpointRead = new EndpointMock(),
		endpointWrite = new EndpointMock(),
		opts = {
			diagnosis: diagnosis()
		};
	var mstore = new messageStore.X3ClobMessageStore(context, endpointRead, endpointWrite, opts);

	mstore && mstore.init(_);
	hackStore(mstore);

	// ===============================
	// Loading contents...
	// ===============================
	var fetched = mstore.load(data);
	strictEqual(fetched, lineCount, "fetch count=" + lineCount);

	// ===============================
	// Verifying contents...
	// ===============================
	var mset = mstore.set;

	var count = 0;
	var missingKeys = [];
	mset.traverse(function(context, chp, id, lan, text, meta) {
		if (id == null || chp == null)
			return;
		if (lan == null) {
			!context.$id["XXX"] && missingKeys.push(chp + "/" + id);
			return;
		}
		if (text != null)
			count++;
	}, {
		sort: true
	});
	strictEqual(count, lineCount, "traverse count=" + lineCount);
	strictEqual(missingKeys.length, 0, "no missing keys ==> " + JSON.stringify(missingKeys));

	var v = mset.get(10031, 41, "FRA"),
		m = mset.getMeta(10031, 41, "FRA"),
		// e  =mset.getEntry(10031, 41, "FRA"),
		e = mset.getByKey("7A20636D48AD60721209BC6D5A9E89E1A9A67530"),
		e0 = e && e[0],
		e1, res;

	ok(e && e.length === 1, "Single entry returned");
	strictEqual(v, "Wrong authentication method {0}", "get text of 10031,41,FRA ==> '" + v + "'");
	strictEqual(m.lanori, "ENG", "lanori of 10031,41,FRA ==> " + m.lanori);
	strictEqual(e0.text["FRA"], "Wrong authentication method {0}", "get text by hash '7A20636D48AD60721209BC6D5A9E89E1A9A67530' ==> '" + e0.text["FRA"] + "'");
	strictEqual(e0.$origin, "10031/41", "get origin by hash '7A20636D48AD60721209BC6D5A9E89E1A9A67530' ==> " + e0.$origin);
	strictEqual(e0.$key, "7A20636D48AD60721209BC6D5A9E89E1A9A67530", "get key by hash '7A20636D48AD60721209BC6D5A9E89E1A9A67530' ==> " + e0.$key);
	strictEqual(e0.$meta["FRA"].lanori, "ENG", "get lanori by hash '7A20636D48AD60721209BC6D5A9E89E1A9A67530' ==> " + e0.$meta["FRA"].lanori);

	e = mset.getByKey("EFE91353E33FC2198577A048A4FB3DFF6FE67F4B");
	e0 = e && e[0];
	e1 = e && e[1];
	ok(e && e.length === 2, "2 entries returned");
	strictEqual(e0.text["CHI"], "由于许可证限制，对以下标记的访问已被拒绝：{0}. _", "get text[0] by hash 'EFE91353E33FC2198577A048A4FB3DFF6FE67F4B' ==> '" + e0.text["CHI"] + "'");
	strictEqual(e1.text["CHI"], "当用户较少时，您可以再试一次。", "get text[1] by hash 'EFE91353E33FC2198577A048A4FB3DFF6FE67F4B' ==> '" + e0.text["CHI"] + "'");
	strictEqual(e0.$origin, "10032/482", "get origin[0] by hash 'EFE91353E33FC2198577A048A4FB3DFF6FE67F4B' ==> " + e0.$origin);
	strictEqual(e1.$origin, "10032/483", "get origin[1] by hash 'EFE91353E33FC2198577A048A4FB3DFF6FE67F4B' ==> " + e1.$origin);

	res = mset.getMessageByKey("EFE91353E33FC2198577A048A4FB3DFF6FE67F4B", "CHI");
	ok(res && res.chunks && res.chunks.length === 2, "2 entries returned");
	strictEqual(res.message, "由于许可证限制，对以下标记的访问已被拒绝：{0}. 当用户较少时，您可以再试一次。", "get message by hash 'EFE91353E33FC2198577A048A4FB3DFF6FE67F4B' ==> '" + res.message + "'");
	strictEqual(res.chunks[0], "由于许可证限制，对以下标记的访问已被拒绝：{0}. _", "get message chunk[0] by hash 'EFE91353E33FC2198577A048A4FB3DFF6FE67F4B' ==> '" + res.chunks[0] + "'");
	strictEqual(res.chunks[1], "当用户较少时，您可以再试一次。", "get message chunk[1] by hash 'EFE91353E33FC2198577A048A4FB3DFF6FE67F4B' ==> '" + res.chunks[1] + "'");
	strictEqual(res.$entry[0].$origin, "10032/482", "get origin[0] by hash 'EFE91353E33FC2198577A048A4FB3DFF6FE67F4B' ==> " + res.$entry[0].$origin);
	strictEqual(res.$entry[1].$origin, "10032/483", "get origin[1] by hash 'EFE91353E33FC2198577A048A4FB3DFF6FE67F4B' ==> " + res.$entry[1].$origin);

	var key = sha1.hex_sha1("abc/def/0001"),
		message = "Un nouveau message court en Français";

	mset.upsertMessage(message, {
		iso: "fr-fr",
		x3: "FRA"
	}, key);
	e = mset.getByKey(key);
	// console.log("  getByKey=" + JSON.stringify(e, null, "\t"));
	e0 = e && e[0];
	e1 = e && e[1];
	ok(e && e.length === 1, "1 entries returned");
	strictEqual(e0.text["FRA"], message, "set / get short French message ==> '" + e0.text["FRA"] + "'");
	strictEqual(e0.$key, key, "get key by hash '" + key + "' ==> " + e0.$key);
	strictEqual(e0.$origin, "10033/1095", "get origin[0] by hash '" + key + "' ==> " + e0.$origin);

	message = "A short message in English";
	mset.upsertMessage(message, {
		iso: "en-us",
		x3: "ENG"
	}, key);
	strictEqual(e0.text["ENG"], message, "set short English message ==> '" + e0.text["ENG"] + "'");
	strictEqual(e0.$key, key, "get key by hash '" + key + "' ==> " + e0.$key);
	strictEqual(e0.$origin, "10033/1095", "get origin[0] by hash '" + key + "' ==> " + e0.$origin);

	key = sha1.hex_sha1("abc/def/0002"),
	message = "A long message long message long message long message long message long message long message long message long message long message long message in English";
	mset.upsertMessage(message, {
		iso: "en-us",
		x3: "ENG"
	}, key);
	e = mset.getByKey(key);
	e0 = e && e[0];
	e1 = e && e[1];
	ok(e && e.length === 2, "2 entries returned");
	equal(e0.text["ENG"], "A long message long message long message long message long message long message long message long message long message _", "long English message[0] ==> '" + e0.text["ENG"] + "'");
	strictEqual(e1.text["ENG"], "long message long message in English", "long English message[1] ==> '" + e1.text["ENG"] + "'");
	var str = mset.reassembleText(e, "ENG");
	strictEqual(str, message, "reassembleText ==> '" + str + "'");
	strictEqual(e0.$key, key, "get key by hash '" + key + "' ==> " + e0.$key);
	strictEqual(e0.$origin, "10033/1096", "get origin[0] by hash '" + key + "' ==> " + e0.$origin);
	strictEqual(e1.$origin, "10033/1097", "get origin[0] by hash '" + key + "' ==> " + e1.$origin);

	var rec = mset.reassembleEntry(e);
	str = rec.text["ENG"];
	strictEqual(str, message, "reassembleEntry text ==> '" + str + "'");
	strictEqual(rec.$key, key, "reassembleEntry key ==> '" + rec.$key + "'");

	start();
});

asyncTest("Stop", function(_) {
	doStop = true;

	start();
});