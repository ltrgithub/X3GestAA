"use strict";

/// !doc
/// 
/// # Translation message storage providers
/// 

var fs = require('streamline-fs');
var sys = require("util");
var jsxml = require("jsxml/lib/jsxml");
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var streams = require('streamline/lib/streams/streams');
var helpers = require("syracuse-core/lib/helpers");
var locale = require("syracuse-core/lib/locale");
var datetime = require("syracuse-core/lib/types/datetime");
var uuid = require("syracuse-core/lib/uuid");
var x3pool = require("syracuse-x3/lib/pool");

var transCfg = config.translation || {};
var tracer = transCfg.trace;
var traceDiagnosis = transCfg.traceDiagnosis;
// var localizedText = locale.format.bind(undefined, module);
var transMod = require.cache[require.resolve("syracuse-translation/lib/translation")];
var localizedText = locale.format.bind(undefined, transMod || module);

var isoDateFormat = exports.isoDateFormat = "yyyy-MM-ddTHH:mm:ssZ";
var tmxDateFormat = "yyyyMMddTHHmmssZ";

var defaultLanguage = exports.defaultLanguage = {
	iso: "en-us",
	x3: locale.x3Language("en-us")
};
var aplStdMaxLength = exports.aplStdMaxLength = 123;

var _stringify = helpers.object.stringify;
var forEachKey = helpers.object.forEachKey;
var currentTime = process.hrtime;

function deltaTime(start) {
	var vals = process.hrtime(start);
	return (vals[0] * 1000) + Math.floor(vals[1] / 1000000);
}

function _getRefObj(refText) {
	var a = refText && refText.split(";") || [];
	return {
		key: a[0],
		tick: a[1]
	};
}
exports.getRefObj = _getRefObj;

function _getMessageFileName(prefix, chapter) {
	return prefix + "_" + chapter.$min + "-" + chapter.$max + ".txt";
}
exports.getMessageFileName = _getMessageFileName;

function _splitMessage(message, chunks) {
	var length = message.length;
	var end;
	var beg = 0;
	if (length <= aplStdMaxLength) {
		end = length;
		chunks.push(message);
	} else {
		end = aplStdMaxLength - 2;

		var substr = message.substring(beg, end);
		tracer && tracer("substr " + substr);
		var len = end - 1;

		while (!(/\s/.exec(substr[len])) && len > 0) len--;
		chunks.push(message.substring(beg, len + 1));
		if (len === 0 && (!(/\s/.exec(substr[len])))) tracer && tracer("Can not be splitted correctly. Long chunck without white spaces: " + message);
		substr = message.substring(len + 1, length);
		_splitMessage(substr, chunks);
	}
}
exports.splitMessage = _splitMessage;

/// ## MessageStore class
///   Base class of any message store provider.  
///   **DO NOT INSTANCIATE.**  
function MessageStore(context, endpointRead, endpointWrite, options) {
	this.context = context || {};
	this.endpointRead = endpointRead;
	this.endpointWrite = endpointWrite;
	this.options = options || {};
	this.diagnosis = this.options.diagnosis;
	this.ignoreChecksum = this.options.ignoreChecksum;
	this.set = new MessageSet();
	this.currentCategory = null;
}

exports.MessageStore = helpers.defineClass(MessageStore, null, {
	_super: function() {
		return Object.getPrototypeOf(Object.getPrototypeOf(this));
	},
	/// * `store.init(_);`  
	///   Initialize the store.  
	init: function(_) {},
	/// * `store.reset(_, category);`  
	///   Switch to a new message category abd reset the internal message state.  
	reset: function(_, frame) {
		this.frame = frame;
		this.currentCategory = frame.category;
		this.set = new MessageSet();
	},

	getOrmRead: function(_) {
		return this.endpointRead.getOrm(_);
	},
	getOrmWrite: function(_) {
		return this.endpointWrite.getOrm(_);
	},

	getLastUpdate: function(_, chapter) {},

	getX3Records: function(_, chapter, opt) {
		var set = this.getX3RecordSet(_, chapter, opt);
		return set && set.getAll() || {};
	},

	get: function(_, chp1, chp2, lan, stamp, opt) {
		return this.set;
	},
	getFullSet: function() {
		return this.set;
	},
	getX3RecordSet: function(_, chapter, opt) {
		var chp1, chp2;
		if (typeof(chapter) === "object") {
			chp1 = chapter.$min;
			chp2 = chapter.$max;
		} else {
			chp1 = chp2 = chapter;
		}
		return this.get(_, chp1, chp2, "", "", opt);
	},
	findMessage: function(_, lanchp, lannum, lang) {
		this._initChapter(_, lanchp);
		return this.set.findMessage(lanchp, lannum, lang);
	},
	_initChapter: function(_, chp) {
		if (!this.set.chapter(chp)) {
			this.getX3RecordSet(_, chp);
		}
	},
	_setText: function(chp, id, lan, t) {
		return this.set.setText(chp, id, lan, t);
	},

	_getText: function(chp, id, lan) {
		return this.set.getText(chp, id, lan);
	},

	createEntry: function(_, chp, id, message, language, refkey) {
		language = language || defaultLanguage;
		var x3Lang = language.x3,
			refObj, ref, t;

		this._initChapter(_, chp);
		tracer && tracer("_createEntry endpoint=" + this.endpointWrite.dataset(_) + ", language=" + JSON.stringify(language) + ", key=" + chp + ":" + id + ', text="' + message + '"');
		t = this._getText(chp, id, x3Lang);
		if (t.text) {
			return this.diagnosis.fatal(localizedText("duplicateKey", chp, id, x3Lang), null, _);
		}

		this._setText(chp, id, x3Lang, message);

		refObj = this.set.getRefObj(chp, id);
		ref = refObj.key;
		if (!this.ignoreChecksum && ref && ref !== refkey) {
			return this.diagnosis.fatal(localizedText("checksumMismatch", "create", chp, id, x3Lang, JSON.stringify(refkey), JSON.stringify(ref)), null, _);
		} else if (!ref) {
			// tracer && tracer("ref=" + JSON.stringify(ref));
			this._setText(chp, id, "XXX", refkey);
		}
		return true;
	},
	updateEntry: function(_, chp, lannum, language, text, chunks, refkey) {
		language = language || defaultLanguage;
		var x3Lang = language.x3,
			refObj, ref, t;

		this._initChapter(_, chp);
		tracer && tracer("_updateEntry: language=" + JSON.stringify(language) + ", num=" + lannum + ' new value=' + text);

		var msg, i, diags;
		var newChunks = [];
		if (text.length > aplStdMaxLength) {
			_splitMessage(text, newChunks);
			tracer && tracer("old chunks " + JSON.stringify(chunks, null, 2));
			tracer && tracer("new chunks " + JSON.stringify(newChunks, null, 2));
			if (newChunks.length > chunks.length) {
				tracer && tracer(localizedText("cannotExtend", chp, lannum, x3Lang));
				return this.diagnosis.error(localizedText("cannotExtend", chp, lannum, x3Lang), _);
			}
		} else {
			newChunks.push(text);
		}

		for (i = 0; i < newChunks.length; i++) {
			refObj = this.set.getRefObj(chp, i);
			ref = refObj.key;
			if (!this.ignoreChecksum && ref && ref !== refkey) {
				return this.diagnosis.fatal(localizedText("checksumMismatch", "update", chp, i, x3Lang, JSON.stringify(refkey), JSON.stringify(ref)), null, _);
			}
			t = this._getText(chp, i, x3Lang);
			this._setText(chp, lannum + i, x3Lang);
			// tracer && tracer("i: " + i + ", old value: " + msg.LANMES(_));
		}
	},

	flush: function(_) {
		var delta = this.set.sync();
		tracer && tracer("[MessageStore.flush] delta=" + _stringify(delta));
		this.dumpToPlainFile(_);
		this.dumpToTmxFile(_);
		this.updateAll(_);
	},
	initFromIndex: function(index) {
		var mstore = this.set,
			x3Lang;
		forEachKey(index, function(gk, gv) {
			if (gk[0] === "$") return;
			forEachKey(gv, function(mk, mv) {
				if (mk[0] === "$") return;
				mstore.init(mv.chp, mv.id, "XXX", mv.$key);
				forEachKey(mv.text, function(tk, tv) {
					x3Lang = locale.x3Language(tk, true);
					mstore.init(mv.chp, mv.id, x3Lang, tv);
				});
			});
		});
		return mstore.getAll();
	},
	dumpToPlainFile: function(_) {
		var all = this.set.getAll(),
			chapter = this.currentCategory,
			messagesFile = _getMessageFileName(this.options.file, chapter),
			c, n, e, txt = "",
			contents = "Language\tChapter\tNumber\tText\n";

		tracer && tracer("[MessageStore.dumpToPlainFile] " + messagesFile);

		Object.keys(all).sort(numSort).forEach(function(chp) {
			if (chp[0] === "$") return;
			c = all[chp];
			c && Object.keys(c).sort(numSort).forEach(function(id) {
				n = c[id];
				n && Object.keys(n).sort().forEach(function(lan) {
					txt = n[lan].replace(/\s+$/g, "\u00b7"); // utf-8 middle dot
					// txt = n[lan].replace(/"/g, '""').replace(/\s+$/g, "\u00b7"); // utf-8 middle dot
					// txt = txt.replace(/\n/g, "\u2424"); // utf-8 newline char
					// txt += lan + ";" + chp + ";" + id + ';"' + txt + '"\n';
					contents += lan + "\t" + chp + "\t" + id + '\t"' + txt + '"\n';
					// txt += "[" + lan + ":" + chp + ":" + id + "] " + escapeSpecialChars(n[lan]) + "\n";
				});
			});
		});
		fs.writeFile(messagesFile, contents, "utf8", _);
	},
	dumpToTmxFile: function(_) {
		var index = this.frame.index || {},
			conf = index.$config || {},
			chapter = conf.$chapter, //this.currentCategory,
			messagesFile = this.options.file + "_" + chapter.$name + ".tmx",
			c, n, e,
			x = {
				tmx: {
					$: {
						version: "1.4"
					},
					header: {
						$: {
							creationtool: "SyracuseTranslationTool",
							creationtoolversion: "1.00",
							datatype: "PlainText",
							segtype: "sentence",
							adminlang: "en-us",
							srclang: "en",
							"o-tmf": "ABCTransMem",
							creationdate: (conf.$createDate && datetime.parse(conf.$createDate) || datetime.now()).toString(tmxDateFormat),
							// creationid: (conf.$source || {}).user,
							changedate: (conf.$lastModified && datetime.parse(conf.$lastModified) || datetime.now()).toString(tmxDateFormat),
							changeid: ((conf.$source || {}).user || {}).login || ""
						},
						note: {
							$value: chapter.$description || ""
						}

					},
					body: {
						tu: []
					}
				}
			},
			tus = x.tmx.body.tu,
			tu,
			tuv,
			tuvs;

		tracer && tracer("[MessageStore.dumpToTmxFile] " + messagesFile);

		forEachKey(index, function(gk, gv) {
			if (gk[0] === "$") return;
			forEachKey(gv, function(mk, mv) {
				if (mk[0] === "$") return;
				tu = {
					$: {
						tuid: gk + "/" + mk,
						datatype: "Text"
					},
					prop: {
						$: {
							type: "x-id"
						},
						$value: mv.chp + ":" + mv.id
					},
					tuv: []
				};
				tus.push(tu);
				tuvs = tu.tuv;
				forEachKey(mv.text, function(tk, tv) {
					tuv = {
						$: {
							"xml:lang": tk
						},
						seg: {
							$value: tv
						}
					};
					tuvs.push(tuv);
				});
			});
		});

		fs.writeFile(messagesFile, '<?xml version="1.0"?>\n' + jsxml.stringify(x, "\t"), "utf8", _);
	},

	updateAll: function(_) {},
	deleteAll: function(_, chp1, chp2, lan, stamp) {}
});

/// ## FileMessageStore class
///   ```
///   var store = new FileMessageStore(context, endpointRead, endpointWrite, options);
///   store.init(_);
///   ```
function FileMessageStore(context, endpointRead, endpointWrite, options) {
	this._super().constructor(context, endpointRead, endpointWrite, options);
}

exports.FileMessageStore = helpers.defineClass(FileMessageStore, MessageStore, {
	init: function(_) {
		MessageStore.prototype.init.call(this);
	},
	getLastUpdate: function(_, chapter) {
		return "";
	},
	_getRecords: function(_, chapter, opt) {
		return [];
	},

	getX3RecordSet: function(_, chapter, opt) {
		var x3RecordSet = opt.set || this.set,
			options = this.options,
			file = _getMessageFileName(opt.file || options.file, this.messageStore.currentCategory),
			fetched = 0,
			txt = "",
			// regex = new RegExp(/\[(\w+):(\d+):(\d+)\]\s*\[([\d\-T:Z]*)\]\s*([^\n\r]*)/g),
			regex = new RegExp(/(\w+)\t(\d+)\t(\d+)\t"([\s\S]*?)"[\n\r]+/g),
			data = fs.exists(file, _) && fs.readFile(file, "utf8", _),
			match,
			// chp, grp, 
			lines, lastUpdate = "";

		fetched = _loadFromCvs(x3RecordSet, data, new RegExp(/(\w+)\t(\d+)\t(\d+)\t"([\s\S]*?)"[\n\r]+/g));

		tracer && tracer("loadFromFile count=" + fetched);
		this.diagnosis.info(localizedText("fetchRecords", fetched), _);
		return x3RecordSet;
	},
});

/// ## X3ClobMessageStore class
///   ```
///   var store = new X3ClobMessageStore(context, endpointRead, endpointWrite, options);
///   store.init(_);
///   ```
var _clobRep = transCfg.clobRepresentation || "ZZTRANS";

function X3ClobMessageStore(context, endpointRead, endpointWrite, options) {
	this._super().constructor(context, endpointRead, endpointWrite, options);
}

exports.X3ClobMessageStore = helpers.defineClass(X3ClobMessageStore, MessageStore, {
	init: function(_) {
		MessageStore.prototype.init.call(this);
	},
	getLastUpdate: function(_, chapter) {
		return "";
	},
	_getRecords: function(_, chapter, opt) {
		return [];
	},

	get: function(_, chp1, chp2, lan, stamp, opt) {
		opt = opt || {};
		var x3RecordSet = opt.set || this.set,
			fetched = 0,
			ep = this.endpointRead,
			epPath = ep.application(_) + "/" + ep.contract(_) + "/" + ep.dataset(_),
			session = this.context.request.session;

		var reply = this._send(_, cdoc(epPath, chp1, chp2, lan, stamp));
		this.set.initChapter(chp1, chp2);
		fetched = _loadFromCvs(x3RecordSet, reply && reply.body, new RegExp(/(\w+)\t(\d+)\t(\d+)\t([\d\-T:Z]*)\t([\s\S]*?)[\n\r]+/g), {
			withLastUpdateTime: true
		});

		this.diagnosis.info(localizedText("fetchRecords", fetched), _);
		return x3RecordSet;

	},

	_send: function(_, url, body, opt) {
		opt = opt || {};
		var ep = this.endpointWrite,
			epPath = ep.application(_) + "/" + ep.contract(_) + "/" + ep.dataset(_),
			session = this.context.request.session,
			params = {
				head: {
					"accept": "application/json;vnd.sage=syracuse; charset=utf-8",
					"accept-language": locale.current,
					"method": opt.method || "GET",
					"url": url
				},
				body: body || {},
				raw: true
			};
		if (opt.method === "PUT" || opt.method === "POST") {
			params.head["content-type"] = opt.contentType || "application/json;vnd.sage=syracuse; charset=utf-8";
			params.head["content-length"] = !body ? 0 : (typeof(body) === "string" ? body.length : JSON.stringify(body).length);
		}
		if (opt.debug) {
			params.head["pragma"] = "debug-immediate";
		}
		return x3pool.jsonSend(_, session, ep, params);
	},

	updateAll: function(_) {
		var ep = this.endpointWrite,
			epPath = ep && (ep.application(_) + "/" + ep.contract(_) + "/" + ep.dataset(_)),
			urlPrefix = "/sdata/" + epPath,
			chp1;

		if (!ep) {
			this.diagnosis.fatal("no endpoint", null, _);
			return;
		}
		var id = uuid.generate(),
			session = this.context.request.session,
			data = "",
			url, r;

		this.set.traverse(function(chp, id, lan, text, state) {
			chp1 = chp1 || chp;
			data += lan + "\t" + chp + "\t" + id + "\t" + text + "\n";
		});

		tracer && tracer("[X3ClobMessageStore.updateAll] create workingCopie");
		url = urlPrefix + "/" + _clobRep + "('" + chp1 + "~~')/$workingCopies?representation=" + _clobRep + ".$edit&trackingId=" + id;
		var reply = this._send(_, url, "", {
			contentType: "text/plain;charset=utf-8",
			method: "POST"
		});
		if (reply && reply.body && reply.body.charAt(0) === "{") {
			r = JSON.parse(reply.body);
			if (r && r.$diagnoses)
				this.diagnosis.addAll(r.$diagnoses, _);
		}
		// tracer && tracer("\n>>>>\n" + reply.body);

		tracer && tracer("[X3ClobMessageStore.updateAll] update workingCopie");
		// tracer && tracer("[X3ClobMessageStore.updateAll] update workingCopie with\n" + data);
		url = cdoc2(epPath, id);
		reply = this._send(_, url, data, {
			contentType: "text/plain;charset=utf-8",
			method: "PUT"
		});
		if (reply && reply.body && reply.body.charAt(0) === "{") {
			r = JSON.parse(reply.body);
			if (r && r.$diagnoses)
				this.diagnosis.addAll(r.$diagnoses, _);
		}
		// tracer && tracer("\n>>>>\n" + reply.body);

		tracer && tracer("[X3ClobMessageStore.updateAll] save workingCopie");
		url = urlPrefix + "/$workingCopies('" + id + "')?representation=" + _clobRep + ".$edit";
		reply = this._send(_, url, {
			"CHP1": chp1,
			"$actions": {
				"$save": {
					"$isRequested": true
				}
			}
		}, {
			method: "PUT",
		});
		if (reply && reply.body && reply.body.charAt(0) === "{") {
			r = JSON.parse(reply.body);
			if (r && r.$diagnoses)
				this.diagnosis.addAll(r.$diagnoses, _);
		}
		// tracer && tracer("\n>>>>\n" + reply.body);
	},
	deleteAll: function(_, chp1, chp2, lan, stamp) {
		var ep = this.endpointWrite,
			epPath = ep && (ep.application(_) + "/" + ep.contract(_) + "/" + ep.dataset(_)),
			urlPrefix = "/sdata/" + epPath,
			url, r;
		chp2 = chp2 || "";

		if (!ep) {
			this.diagnosis.fatal("no endpoint", null, _);
			return;
		}

		//http://localhost:8124/sdata/x3/erp/SUPERV/ZZTRANS('10043~~')?representation=ZZTRANS.$details
		tracer && tracer("[X3ClobMessageStore.deleteAll]");
		url = urlPrefix + "/" + _clobRep + "('" + chp1 + "~" + chp2 + "~')?representation=" + _clobRep + ".$details";
		var reply = this._send(_, url, "", {
			contentType: "text/plain;charset=utf-8",
			method: "DELETE"
		});
		if (reply && reply.body && reply.body.charAt(0) === "{") {
			r = JSON.parse(reply.body);
			if (r && r.$diagnoses)
				this.diagnosis.addAll(r.$diagnoses, _);
		}
	}
});

function cdoc(epPath, chp1, chp2, lan, stamp) {
	var key = ["C_" + _clobRep, "CONTENTS", chp1 || "", (chp2 || chp1 || ""), (lan || ""), stamp || ""].join("~%C2%A8~");
	return ["/sdata", epPath, "CDOC('" + key + "')"].join("/");
}

function cdoc2(epPath, id) {
	return ["/sdata", epPath, "$workingCopies('" + id + "')", _clobRep, "CONTENTS"].join("/");
}

function _loadFromCvs(x3RecordSet, data, regex, opt) {
	opt = opt || {};
	var fetched = 0,
		txt = "",
		match,
		lastUpdate = "",
		itxt = opt.withLastUpdateTime ? 5 : 4;
	if (data) {
		while ((match = regex.exec(data)) != null) {
			txt = (match[itxt] || "").replace(/\u00b7/g, " ").replace(/\"\"/g, '"').replace(/\\n/g, '\n');
			x3RecordSet.init(match[2], match[3], match[1], txt);
			fetched++;
		}
	}
	tracer && tracer("_loadFromCvs count=" + fetched);
	x3RecordSet.$count = fetched;
	return fetched;
}

/// ## MessageSet class
///   ```
///   var set = new MessageSet();
///   ```
///   Manage messages  
function MessageSet() {
	var col = {},
		meta = {};

	function _setText(chp, id, lan, t, defState, stamp) {
		col[chp] = col[chp] || {};
		col[chp][id] = col[chp][id] || {};
		col[chp][id][lan] = t || " ";

		var key = chp + "." + id + "." + lan,
			m = meta[key] || (meta[key] = {});
		m.state = (m.state == null ? defState || "created" : "modified");
		m.stamp = stamp;
		if (stamp > col.$lastUpdate) {
			col.$lastUpdate = stamp;
		}
	}

	this.initChapter = function(chp1, chp2) {
		for (var i = chp1; i <= chp2; i++) {
			col[i] = col[i] || {};
		}
	};

	this.init = function(chp, id, lan, t, stamp) {
		_setText(chp, id, lan, t, "clean");
	};

	this.setText = function(chp, id, lan, t, stamp) {
		_setText(chp, id, lan, t, stamp);
	};

	this.getText = function(chp, id, lan) {
		var t = col[chp] && col[chp][id] && col[chp][id][lan];
		return {
			text: t,
			$col: {
				data: col
			}
		};
	};

	this.getRefObj = function(chp, id) {
		var refText = this.getText(chp, id, "XXX").text,
			a = refText && refText.split(";") || [];
		return {
			key: a[0],
			tick: a[1]
		};
	};

	this.get = function(chp, id, lan) {
		var v = chp ? col[chp] : col;
		if (id === undefined) return v;
		v = v[id] || {};
		if (lan === undefined) return v;
		return v[lan] || "";
	};

	this.chapter = function(chp) {
		return col[chp];
	};

	this.findMessage = function(lanchp, lannum, lang) {
		var self = this,
			nums, i, msg, text, match, result;

		lang = lang || "ENG";
		if (Array.isArray(lannum)) {
			for (nums = [], i = lannum[0]; i <= lannum[1]; i++) {
				nums.push(i);
			}
		} else {
			nums = [lannum];
		}
		result = {
			message: "",
			chunks: []
		};

		result = nums.reduce(function(res, n) {
			text = self.getText(lanchp, n, lang).text;
			if (text) {
				res.chunks.push(text);
				res.message += text.replace(/(\s+_\s*)$/, " ");
			}
			return res;
		}, result);

		tracer && tracer("[MessageSet.findMessage] " + lanchp + ", " + lannum + ", " + lang + ", result='" + JSON.stringify(result, null, 2));
		return result;
	};

	this.getAll = function() {
		return col;
	};

	this.sync = function() {
		var ck, ik, lk, chp, id, lan, m, _chp, _id, delta = {};

		// removed deleted from created and updated
		forEachKey(col, function(ck) {
			if (ck[0] === "$") return;
			chp = col[ck];
			forEachKey(chp, function(ik) {
				if (ik[0] === "$") return;
				id = chp[ik];
				forEachKey(id, function(lk) {
					if (lk[0] === "$") return;
					var key = ck + "." + ik + "." + lk;
					m = meta[key] || (meta[key] = {});
					if (m.state === "deleted") {
						delete id[lk];
						delete meta[key];
					} else if (m.state != "clean") {
						_chp = delta[ck] || (delta[ck] = {});
						_id = _chp[ik] || (_chp[ik] = {});
						_id[lk] = id[lk];
						m.state = "clean";
					}
				});
			});
		});
		return delta;
	};

	this.traverse = function(cb) {
		if (!cb)
			return;

		forEachKey(col, function(k0, chp) {
			if (k0[0] === "$") return;
			forEachKey(chp, function(k1, id) {
				if (k1[0] === "$") return;
				forEachKey(id, function(k2, text) {
					var key = k0 + "." + k1 + "." + k2;
					cb(k0, k1, k2, text, (meta[key] || {}).state);
				});
			});
		});
	};
}

function numSort(a, b) {
	return a - b;
}

exports.MessageSet = MessageSet;

// function unescapeSpecialChars(s) {
// 	return s.replace(/\n/g, "\\n"). //
// 	replace(/\r/g, "\\r"). //
// 	replace(/\t/g, "\\t"). //
// 	replace(/\f/g, "\\f");
// }

// function escapeSpecialChars(s) {
// 	return s.replace(/\n/g, "\\n"). //
// 	replace(/\r/g, "\\r"). //
// 	replace(/\t/g, "\\t"). //
// 	replace(/\f/g, "\\f");
// }