"use strict";

/// !doc
/// 
/// # Translation message storage providers
/// 

var fs = require('streamline-fs');
var sys = require("util");
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var streams = require('streamline/lib/streams/streams');
var helpers = require("syracuse-core/lib/helpers");
var locale = require("syracuse-core/lib/locale");
var uuid = require("syracuse-core/lib/uuid");
var x3pool = require("syracuse-x3/lib/pool");

var transCfg = config.translation || {};
var tracer = transCfg.trace;
var traceDiagnosis = transCfg.traceDiagnosis;
// var localizedText = locale.format.bind(undefined, module);
var transMod = require.cache[require.resolve("syracuse-translation/lib/translation")];
var localizedText = locale.format.bind(undefined, transMod || module);

var isoDateFormat = exports.isoDateFormat = "yyyy-MM-ddTHH:mm:ssZ";
var defaultLanguage = exports.defaultLanguage = {
	iso: "en-us",
	x3: locale.x3Language("en-us")
};
var aplStdMaxLength = exports.aplStdMaxLength = 123;

var _stringify = helpers.object.stringify;
var forEachKey = helpers.object.forEachKey;
var currentTime = process.hrtime;

function deltaTime(start) {
	var vals = process.hrtime(start);
	return (vals[0] * 1000) + Math.floor(vals[1] / 1000000);
}

function _getRefObj(refText) {
	var a = refText && refText.split(";") || [];
	return {
		key: a[0],
		tick: a[1]
	};
}
exports.getRefObj = _getRefObj;

function _getMessageFileName(prefix, chapter) {
	return prefix + "_" + chapter.$min + "-" + chapter.$max + ".txt";
}
exports.getMessageFileName = _getMessageFileName;

function _splitMessage(message, chunks) {
	var length = message.length;
	var end;
	var beg = 0;
	if (length <= aplStdMaxLength) {
		end = length;
		chunks.push(message);
	} else {
		end = aplStdMaxLength - 2;

		var substr = message.substring(beg, end);
		tracer && tracer("substr " + substr);
		var len = end - 1;

		while (!(/\s/.exec(substr[len])) && len > 0) len--;
		chunks.push(message.substring(beg, len + 1));
		if (len === 0 && (!(/\s/.exec(substr[len])))) tracer && tracer("Can not be splitted correctly. Long chunck without white spaces: " + message);
		substr = message.substring(len + 1, length);
		_splitMessage(substr, chunks);
	}
}
exports.splitMessage = _splitMessage;

/// ## MessageStore class
///   Base class of any message store provider.  
///   **DO NOT INSTANCIATE.**  
function MessageStore(context, endpoint, options) {
	// this._init(context, endpoint, options);
	this.context = context || {};
	this.endpoint = endpoint;
	this.options = options || {};
	this.diagnosis = this.options.diagnosis;
	this.ignoreChecksum = this.options.ignoreChecksum;
	this.set = new MessageSet();
	this.currentCategory = null;
}

exports.MessageStore = helpers.defineClass(MessageStore, null, {
	// _init: function(context, endpoint, options) {
	// 	this.context = context || {};
	// 	this.endpoint = endpoint;
	// 	this.options = options || {};
	// 	this.diagnosis = this.options.diagnosis;
	// 	this.ignoreChecksum = this.options.ignoreChecksum;
	// 	this.set = new MessageSet();
	// 	this.currentCategory = null;
	// },
	_super: function() {
		return Object.getPrototypeOf(Object.getPrototypeOf(this));
	},
	/// * `store.init(_);`  
	///   Initialize the store.  
	init: function(_) {},
	/// * `store.reset(_, category);`  
	///   Switch to a new message category abd reset the internal message state.  
	reset: function(_, category) {
		this.currentCategory = category;
		this.set = new MessageSet();
	},
	getLastUpdate: function(_, chapter) {},

	getX3Records: function(_, chapter, opt) {
		var set = this.getX3RecordSet(_, chapter, opt);
		return set && set.getAll() || {};
	},

	get: function(_, chp1, chp2, lan, stamp, opt) {
		return this.set;
	},
	getFullSet: function() {
		return this.set;
	},
	getX3RecordSet: function(_, chapter, opt) {
		var chp1, chp2;
		if (typeof(chapter) === "object") {
			chp1 = chapter.$min;
			chp2 = chapter.$max;
		} else {
			chp1 = chp2 = chapter;
		}
		return this.get(_, chp1, chp2, "", "", opt);
	},
	findMessage: function(_, lanchp, lannum, lang) {
		this._initChapter(_, lanchp);
		return this.set.findMessage(lanchp, lannum, lang);
	},
	_initChapter: function(_, chp) {
		if (!this.set.chapter(chp)) {
			this.getX3RecordSet(_, chp);
		}
	},
	_setText: function(chp, id, lan, t) {
		return this.set.setText(chp, id, lan, t);
	},

	_getText: function(chp, id, lan) {
		return this.set.getText(chp, id, lan);
	},

	createEntry: function(_, chp, id, message, language, refkey) {
		language = language || defaultLanguage;
		var x3Lang = language.x3,
			refObj, ref, t;

		this._initChapter(_, chp);
		tracer && tracer("_createEntry endpoint=" + this.endpoint.dataset(_) + ", language=" + JSON.stringify(language) + ", key=" + chp + ":" + id + ', text="' + message + '"');
		t = this._getText(chp, id, x3Lang);
		if (t.text) {
			return this.diagnosis.fatal(localizedText("duplicateKey", chp, id, x3Lang), null, _);
		}

		this._setText(chp, id, x3Lang, message);

		refObj = this.set.getRefObj(chp, id);
		ref = refObj.key;
		if (!this.ignoreChecksum && ref && ref !== refkey) {
			return this.diagnosis.fatal(localizedText("checksumMismatch", "create", chp, id, x3Lang, JSON.stringify(refkey), JSON.stringify(ref)), null, _);
		} else if (!ref) {
			// tracer && tracer("ref=" + JSON.stringify(ref));
			this._setText(chp, id, "XXX", refkey);
		}
		return true;
	},
	updateEntry: function(_, chp, lannum, language, text, chunks, refkey) {
		language = language || defaultLanguage;
		var x3Lang = language.x3,
			refObj, ref, t;

		this._initChapter(_, chp);
		tracer && tracer("_updateEntry: language=" + JSON.stringify(language) + ", num=" + lannum + ' new value=' + text);

		var msg, i, diags;
		var newChunks = [];
		if (text.length > aplStdMaxLength) {
			_splitMessage(text, newChunks);
			tracer && tracer("old chunks " + JSON.stringify(chunks, null, 2));
			tracer && tracer("new chunks " + JSON.stringify(newChunks, null, 2));
			if (newChunks.length > chunks.length) {
				tracer && tracer(localizedText("cannotExtend", chp, lannum, x3Lang));
				return this.diagnosis.error(localizedText("cannotExtend", chp, lannum, x3Lang), _);
			}
		} else {
			newChunks.push(text);
		}

		for (i = 0; i < newChunks.length; i++) {
			refObj = this.set.getRefObj(chp, i);
			ref = refObj.key;
			if (!this.ignoreChecksum && ref && ref !== refkey) {
				return this.diagnosis.fatal(localizedText("checksumMismatch", "update", chp, i, x3Lang, JSON.stringify(refkey), JSON.stringify(ref)), null, _);
			}
			t = this._getText(chp, i, x3Lang);
			this._setText(chp, lannum + i, x3Lang);
			// tracer && tracer("i: " + i + ", old value: " + msg.LANMES(_));
		}
	},

	flush: function(_) {
		var delta = this.set.sync();
		tracer && tracer("(MessageStore.flush) delta=" + _stringify(delta));
		this.dumpTofile(_);
		this.updateAll(_);
	},
	initFromIndex: function(index) {
		var mstore = this.set,
			x3Lang;
		forEachKey(index, function(gk, gv) {
			if (gk[0] === "$") return;
			forEachKey(gv, function(mk, mv) {
				if (mk[0] === "$") return;
				mstore.init(mv.chp, mv.id, "XXX", mv.$key);
				forEachKey(mv.text, function(tk, tv) {
					x3Lang = locale.x3Language(tk, true);
					mstore.init(mv.chp, mv.id, x3Lang, tv);
				});
			});
		});
		return mstore.getAll();
	},
	dumpTofile: function(_) {
		var all = this.set.getAll(),
			chapter = this.currentCategory,
			messagesFile = _getMessageFileName(this.options.file, chapter),
			c, n, e, txt = "",
			contents = "Language\tChapter\tNumber\tText\n";

		tracer && tracer("(MessageStore.dumpTofile) " + messagesFile);

		function numSort(a, b) {
			return a - b;
		}

		Object.keys(all).sort(numSort).forEach(function(chp) {
			if (chp[0] === "$") return;
			c = all[chp];
			c && Object.keys(c).sort(numSort).forEach(function(id) {
				n = c[id];
				n && Object.keys(n).sort().forEach(function(lan) {
					txt = n[lan].replace(/"/g, '""').replace(/\s+$/g, "\u00b7"); // utf-8 middle dot
					// txt = txt.replace(/\n/g, "\u2424"); // utf-8 newline char
					// txt += lan + ";" + chp + ";" + id + ';"' + txt + '"\n';
					contents += lan + "\t" + chp + "\t" + id + '\t"' + txt + '"\n';
					// txt += "[" + lan + ":" + chp + ":" + id + "] " + escapeSpecialChars(n[lan]) + "\n";
				});
			});
		});
		fs.writeFile(messagesFile, contents, "utf8", _);
	},

	updateAll: function(_) {},
	deleteAll: function(_, chp1, chp2, lan, stamp) {}
});

/// ## AplStdMessageStore class
///   ```
///   var store = new AplStdMessageStore(context, endpoint, options);
///   store.init(_);
///   ```
function AplStdMessageStore(context, endpoint, options) {
	this._super().constructor(context, endpoint, options);
}

exports.AplStdMessageStore = helpers.defineClass(AplStdMessageStore, MessageStore, {
	init: function(_) {
		MessageStore.prototype.init.call(this);
		this.db = this.endpoint.getOrm(_);
		this.entity = this.db.getEntity(_, "APLSTD", "$edit");
		this.fetchCount = 2000;
		this.list = [];
	},
	getLastUpdate: function(_, chapter) {
		var rec = this._getRecords(_, chapter, {
			count: 1,
			orderBy: {
				name: "UPDDATTIM",
				descending: true
			}
		});
		return rec && rec[0] && rec[0].UPDDATTIM(_).toString(isoDateFormat) || "";
	},
	_addErrors: function(_, msg) {
		if (this.diagnosis) {
			var diags = [];
			msg.getAllDiagnoses(_, diags);
			diags = diags.filter(function(d) {
				return d.severity === "error";
			});
			diags.forEach_(_, function(_, d) {
				this.diagnosis.add(d.severity, d.message, _);
			});
			if (diags.length > 0) {
				tracer && tracer("diagnoses store op " + msg.LAN(_) + ":" + msg.LANCHP(_) + ":" + msg.LANNUM(_) + sys.inspect(diags));
				return true;
			}
		}
	},
	_getRecords: function(_, chapter, opt) {
		var query = this._getquery(_, chapter, opt);
		tracer && tracer("getRecords: params=" + JSON.stringify(query.params));
		return this.db.fetchInstances(_, query.entity, query.params) || [];
	},
	_sdataEqual: function(chp, num, lang) {
		return "LANCHP eq " + chp + " and LANNUM eq " + num + " and LAN eq '" + lang + "'";
	},

	_getquery: function(_, chapter, opt) {
		var entity = this.db.getEntity(_, "APLSTD", "$bulk"),
			// entity = db.getEntity(_, "APLSTD", "$query"),
			lang = opt.lang,
			params = {};
		opt = opt || {};
		if (typeof(chapter) === "object") {
			params.sdataWhere = "LANCHP ge " + chapter.$min + " and LANCHP le " + chapter.$max;
		} else {
			params.sdataWhere = "LANCHP eq " + chapter;
		}
		params.sdataWhere += " and LANNUM " + (opt.startNumber ? "ge " + opt.startNumber : "gt 0");
		if (opt.metaOnly) {
			params.sdataWhere += ' and LAN eq "XXX"';
		} else {
			params.sdataWhere += (opt.noMeta ? ' and LAN ne "XXX"' : "") + (lang ? ' and LAN eq "' + (locale.x3Language(lang) || lang) + '"' : "");
		}
		if (opt.lastModified) {
			params.sdataWhere += ' and UPDDATTIM gt @' + opt.lastModified + '@';
		}
		params.count = opt.count || this.fetchCount;
		params.orderBy = opt.orderBy;
		params.startIndex = opt.startIndex || 0;
		return {
			entity: entity,
			params: params
		};
	},

	getX3RecordSet: function(_, chapter, opt) {
		// return _loadFromX3(_, chapter, opt);
		var query, params, x3RecordSet = opt.set || this.set,
			records, count, fetched = 0,
			startNumber = 1;

		do {
			opt.startNumber = startNumber;
			query = this._getquery(_, chapter, opt);
			// tracer && tracer("getX3RecordSet: params=" + JSON.stringify(params));
			params = query.params;
			records = this.db.fetchInstances(_, query.entity, params) || [];
			if (records.$diagnoses) {
				if (records.$diagnoses) {
					this.diagnosis.error("loadFromX3: params=" + JSON.stringify(params) + "\n" + JSON.stringify(records.$diagnoses), _);
				}
			}
			count = isNaN(records.length) ? 0 : records.length || 0;
			count && records.forEach_(_, fillRecord);
			tracer && tracer("loadFromX3: length=" + count + ", params=" + JSON.stringify(params));
			fetched += count;
		} while (records.length === this.fetchCount);
		x3RecordSet.$count = fetched;

		tracer && tracer("loadFromX3 count=" + fetched + ", params=" + JSON.stringify(params));
		this.diagnosis.info(localizedText("fetchRecords", fetched), _);
		return x3RecordSet;

		function fillRecord(_, e) {
			x3RecordSet.init(e.LANCHP(_), e.LANNUM(_), e.LAN(_), e.LANMES(_));
			// x3Records[e.LANCHP(_)] = x3Records[e.LANCHP(_)] || {};
			// x3Records[e.LANCHP(_)][e.LANNUM(_)] = x3Records[e.LANCHP(_)][e.LANNUM(_)] || {};
			// x3Records[e.LANCHP(_)][e.LANNUM(_)][e.LAN(_)] = e.LANMES(_);
			startNumber = e.LANNUM(_);
		}
	},

	_dbFlush: function(_, force) {
		var start = currentTime();
		if (!transCfg.noBatch && this.db.batch && (force || this.list.length === 1000)) {
			tracer && tracer("(AplStdMessageStore._dbFlush) list=" + _stringify(this.list));
			this.db.batch(_, this.entity, this.list, this.options);
			this.list = [];
		}
		tracer && tracer("(AplStdMessageStore._dbFlush) end: " + deltaTime(start) + "ms");
	},

	_dbCreate: function(_, chp, id, t, lan) {
		t = t || " ";
		tracer && tracer("(AplStdMessageStore._dbCreate) " + chp + "/" + id + "/" + lan);
		if (!transCfg.noBatch && this.db.batch) {
			this.list.push({
				LANCHP: parseInt(chp, 10),
				LANNUM: parseInt(id, 10),
				LAN: lan,
				LANMES: t
			});
			this._dbFlush(_);
		} else {
			var msg = this.entity.createInstance(_, this.db);
			msg.LANCHP(_, parseInt(chp, 10));
			msg.LANNUM(_, parseInt(id, 10));
			msg.LAN(_, lan);
			// put at least a single space to create the record
			msg.LANMES(_, t);
			msg.save(_);
			this._addErrors(_, msg);
		}
	},

	_dbUpdate: function(_, chp, id, t, lan) {
		var msg = this.db.fetchInstance(_, this.entity, {
			sdataWhere: this._sdataEqual(chp, id, lan)
		});
		// tracer && tracer("i: " + i + ", old value: " + msg.LANMES(_));
		msg.LANMES(_, t || " ");
		msg.save(_);
		this._addErrors(_, msg);
	}

});

/// ## FileMessageStore class
///   ```
///   var store = new FileMessageStore(context, endpoint, options);
///   store.init(_);
///   ```
function FileMessageStore(context, endpoint, options) {
	this._super().constructor(context, endpoint, options);
}

exports.FileMessageStore = helpers.defineClass(FileMessageStore, MessageStore, {
	init: function(_) {
		MessageStore.prototype.init.call(this);
	},
	getLastUpdate: function(_, chapter) {
		return "";
	},
	_getRecords: function(_, chapter, opt) {
		return [];
	},

	getX3RecordSet: function(_, chapter, opt) {
		var x3RecordSet = opt.set || this.set,
			options = this.options,
			file = _getMessageFileName(opt.file || options.file, this.messageStore.currentCategory),
			fetched = 0,
			txt = "",
			// regex = new RegExp(/\[(\w+):(\d+):(\d+)\]\s*\[([\d\-T:Z]*)\]\s*([^\n\r]*)/g),
			regex = new RegExp(/(\w+)\t(\d+)\t(\d+)\t"([\s\S]*?)"[\n\r]+/g),
			data = fs.exists(file, _) && fs.readFile(file, "utf8", _),
			match,
			// chp, grp, 
			lines, lastUpdate = "";

		fetched = _loadFromCvs(x3RecordSet, data, new RegExp(/(\w+)\t(\d+)\t(\d+)\t"([\s\S]*?)"[\n\r]+/g));

		tracer && tracer("loadFromFile count=" + fetched);
		this.diagnosis.info(localizedText("fetchRecords", fetched), _);
		return x3RecordSet;
	},
});

/// ## X3ClobMessageStore class
///   ```
///   var store = new X3ClobMessageStore(context, endpoint, options);
///   store.init(_);
///   ```
var _clobRep = "ZZTRANS";

function X3ClobMessageStore(context, endpoint, options) {
	this._super().constructor(context, endpoint, options);
}

exports.X3ClobMessageStore = helpers.defineClass(X3ClobMessageStore, MessageStore, {
	init: function(_) {
		MessageStore.prototype.init.call(this);
	},
	getLastUpdate: function(_, chapter) {
		return "";
	},
	_getRecords: function(_, chapter, opt) {
		return [];
	},

	get: function(_, chp1, chp2, lan, stamp, opt) {
		opt = opt || {};
		var x3RecordSet = opt.set || this.set,
			fetched = 0,
			ep = this.endpoint,
			epPath = ep.application(_) + "/" + ep.contract(_) + "/" + ep.dataset(_),
			session = this.context.request.session;

		var reply = this._send(_, cdoc(epPath, chp1, chp2, lan, stamp));
		this.set.initChapter(chp1, chp2);
		fetched = _loadFromCvs(x3RecordSet, reply && reply.body, new RegExp(/(\w+)\t(\d+)\t(\d+)\t([\d\-T:Z]*)\t([\s\S]*?)[\n\r]+/g), {
			withLastUpdateTime: true
		});

		this.diagnosis.info(localizedText("fetchRecords", fetched), _);
		return x3RecordSet;

	},

	_send: function(_, url, body, opt) {
		opt = opt || {};
		var ep = this.endpoint,
			epPath = ep.application(_) + "/" + ep.contract(_) + "/" + ep.dataset(_),
			session = this.context.request.session,
			params = {
				head: {
					"accept": "application/json;vnd.sage=syracuse; charset=utf-8",
					"accept-language": locale.current,
					"method": opt.method || "GET",
					"url": url
				},
				body: body || {},
				raw: true
			};
		if (opt.method === "PUT" || opt.method === "POST") {
			params.head["content-type"] = opt.contentType || "application/json;vnd.sage=syracuse; charset=utf-8";
			params.head["content-length"] = !body ? 0 : (typeof(body) === "string" ? body.length : JSON.stringify(body).length);
		}
		if (opt.debug) {
			params.head["pragma"] = "debug-immediate";
		}
		return x3pool.jsonSend(_, session, ep, params);
	},

	updateAll: function(_) {
		var ep = this.endpoint,
			epPath = ep && (ep.application(_) + "/" + ep.contract(_) + "/" + ep.dataset(_)),
			urlPrefix = "/sdata/" + epPath,
			chp1;

		if (!ep) {
			this.diagnosis.fatal("no endpoint", null, _);
			return;
		}
		var id = uuid.generate(),
			session = this.context.request.session,
			data = "",
			url, r;

		this.set.traverse(function(chp, id, lan, text, state) {
			chp1 = chp1 || chp;
			data += lan + "\t" + chp + "\t" + id + "\t" + text + "\n";
		});

		tracer && tracer("(X3ClobMessageStore.updateAll) create workingCopie");
		url = urlPrefix + "/" + _clobRep + "('" + chp1 + "~~')/$workingCopies?representation=" + _clobRep + ".$edit&trackingId=" + id;
		var reply = this._send(_, url, "", {
			contentType: "text/plain;charset=utf-8",
			method: "POST"
		});
		if (reply && reply.body && reply.body.charAt(0) === "{") {
			r = JSON.parse(reply.body);
			if (r && r.$diagnoses)
				this.diagnosis.addAll(r.$diagnoses, _);
		}
		// tracer && tracer("\n>>>>\n" + reply.body);

		tracer && tracer("(X3ClobMessageStore.updateAll) update workingCopie");
		// tracer && tracer("(X3ClobMessageStore.updateAll) update workingCopie with\n" + data);
		url = cdoc2(epPath, id);
		reply = this._send(_, url, data, {
			contentType: "text/plain;charset=utf-8",
			method: "PUT"
		});
		if (reply && reply.body && reply.body.charAt(0) === "{") {
			r = JSON.parse(reply.body);
			if (r && r.$diagnoses)
				this.diagnosis.addAll(r.$diagnoses, _);
		}
		// tracer && tracer("\n>>>>\n" + reply.body);

		tracer && tracer("(X3ClobMessageStore.updateAll) save workingCopie");
		url = urlPrefix + "/$workingCopies('" + id + "')?representation=" + _clobRep + ".$edit";
		reply = this._send(_, url, {
			"CHP1": chp1,
			"$actions": {
				"$save": {
					"$isRequested": true
				}
			}
		}, {
			method: "PUT",
		});
		if (reply && reply.body && reply.body.charAt(0) === "{") {
			r = JSON.parse(reply.body);
			if (r && r.$diagnoses)
				this.diagnosis.addAll(r.$diagnoses, _);
		}
		// tracer && tracer("\n>>>>\n" + reply.body);
	},
	deleteAll: function(_, chp1, chp2, lan, stamp) {}
});

var argSep = "~%C2%A8~";

function cdoc(epPath, chp1, chp2, lan, stamp) {
	return "/sdata/" + epPath + "/CDOC('" + ["C_" + _clobRep, "CONTENTS", chp1 || "", (chp2 || chp1 || ""), (lan || ""), stamp || ""].join(argSep) + "')";
}

function cdoc2(epPath, id) {
	return "/sdata/" + epPath + "/CDOC('" + ["C_" + _clobRep, "CONTENTS", id || ""].join(argSep) + "')";
}

function _loadFromCvs(x3RecordSet, data, regex, opt) {
	opt = opt || {};
	var fetched = 0,
		txt = "",
		match,
		lastUpdate = "",
		itxt = opt.withLastUpdateTime ? 5 : 4;
	if (data) {
		while ((match = regex.exec(data)) != null) {
			txt = (match[itxt] || "").replace(/\u00b7/g, " ").replace(/\"\"/g, '"').replace(/\\n/g, '\n');
			x3RecordSet.init(match[2], match[3], match[1], txt);
			fetched++;
		}
	}
	tracer && tracer("_loadFromCvs count=" + fetched);
	x3RecordSet.$count = fetched;
	return fetched;
}

/// ## MessageSet class
///   ```
///   var set = new MessageSet();
///   ```
///   Manage messages  
function MessageSet() {
	var col = {},
		meta = {};

	function _setText(chp, id, lan, t, defState, stamp) {
		col[chp] = col[chp] || {};
		col[chp][id] = col[chp][id] || {};
		col[chp][id][lan] = t || " ";

		var key = chp + "." + id + "." + lan,
			m = meta[key] || (meta[key] = {});
		m.state = (m.state == null ? defState || "created" : "modified");
		m.stamp = stamp;
		if (stamp > col.$lastUpdate) {
			col.$lastUpdate = stamp;
		}
	}

	this.initChapter = function(chp1, chp2) {
		for (var i = chp1; i <= chp2; i++) {
			col[i] = col[i] || {};
		}
	};

	this.init = function(chp, id, lan, t, stamp) {
		_setText(chp, id, lan, t, "clean");
	};

	this.setText = function(chp, id, lan, t, stamp) {
		_setText(chp, id, lan, t, stamp);
	};

	this.getText = function(chp, id, lan) {
		var t = col[chp] && col[chp][id] && col[chp][id][lan];
		return {
			text: t,
			$col: {
				data: col
			}
		};
	};

	this.getRefObj = function(chp, id) {
		var refText = this.getText(chp, id, "XXX").text,
			a = refText && refText.split(";") || [];
		return {
			key: a[0],
			tick: a[1]
		};
	};

	this.get = function(chp, id, lan) {
		var v = chp ? col[chp] : col;
		if (id === undefined) return v;
		v = v[id] || {};
		if (lan === undefined) return v;
		return v[lan] || "";
	};

	this.chapter = function(chp) {
		return col[chp];
	};

	this.findMessage = function(lanchp, lannum, lang) {
		var self = this,
			nums, i, msg, text, match, result;

		lang = lang || "ENG";
		if (Array.isArray(lannum)) {
			for (nums = [], i = lannum[0]; i <= lannum[1]; i++) {
				nums.push(i);
			}
		} else {
			nums = [lannum];
		}
		result = {
			message: "",
			chunks: []
		};

		result = nums.reduce(function(res, n) {
			text = self.getText(lanchp, n, lang).text;
			if (text) {
				res.chunks.push(text);
				res.message += text.replace(/(\s+_\s*)$/, " ");
			}
			return res;
		}, result);

		tracer && tracer("(MessageSet.findMessage) " + lanchp + ", " + lannum + ", " + lang + ", result='" + JSON.stringify(result, null, 2));
		return result;
	};

	this.getAll = function() {
		return col;
	};

	this.sync = function() {
		var ck, ik, lk, chp, id, lan, m, _chp, _id, delta = {};

		// removed deleted from created and updated
		forEachKey(col, function(ck) {
			if (ck[0] === "$") return;
			chp = col[ck];
			forEachKey(chp, function(ik) {
				if (ik[0] === "$") return;
				id = chp[ik];
				forEachKey(id, function(lk) {
					if (lk[0] === "$") return;
					var key = ck + "." + ik + "." + lk;
					m = meta[key] || (meta[key] = {});
					if (m.state === "deleted") {
						delete id[lk];
						delete meta[key];
					} else if (m.state != "clean") {
						_chp = delta[ck] || (delta[ck] = {});
						_id = _chp[ik] || (_chp[ik] = {});
						_id[lk] = id[lk];
						m.state = "clean";
					}
				});
			});
		});
		return delta;
	};

	this.traverse = function(cb) {
		if (!cb)
			return;

		forEachKey(col, function(k0, chp) {
			if (k0[0] === "$") return;
			forEachKey(chp, function(k1, id) {
				if (k1[0] === "$") return;
				forEachKey(id, function(k2, text) {
					var key = k0 + "." + k1 + "." + k2;
					cb(k0, k1, k2, text, (meta[key] || {}).state);
				});
			});
		});
	};
}

exports.MessageSet = MessageSet;

// ===============================================================
// function store(_, endpoint, options) {
// 	var diagnosis = options.diagnosis,
// 		ignoreChecksum = options.ignoreChecksum,
// 		db = endpoint.getOrm(_),
// 		entity = db.getEntity(_, "APLSTD", "$edit"),
// 		fetchCount = 2000,
// 		list = [],
// 		set, currentCategory;

// 	function _addErrors(_, msg) {
// 		if (diagnosis) {
// 			var diags = [];
// 			msg.getAllDiagnoses(_, diags);
// 			diags = diags.filter(function(d) {
// 				return d.severity === "error";
// 			});
// 			diags.forEach_(_, function(_, d) {
// 				diagnosis.add(d.severity, d.message, _);
// 			});
// 			if (diags.length > 0) {
// 				tracer && tracer("diagnoses store op " + msg.LAN(_) + ":" + msg.LANCHP(_) + ":" + msg.LANNUM(_) + sys.inspect(diags));
// 				return true;
// 			}
// 		}
// 	}

// 	function _sdataEqual(chp, num, lang) {
// 		return "LANCHP eq " + chp + " and LANNUM eq " + num + " and LAN eq '" + lang + "'";
// 	}

// 	function _getquery(_, chapter, opt) {
// 		var entity = db.getEntity(_, "APLSTD", "$bulk"),
// 			// entity = db.getEntity(_, "APLSTD", "$query"),
// 			lang = opt.lang,
// 			params = {};
// 		opt = opt || {};
// 		if (typeof(chapter) === "object") {
// 			params.sdataWhere = "LANCHP ge " + chapter.$min + " and LANCHP le " + chapter.$max;
// 		} else {
// 			params.sdataWhere = "LANCHP eq " + chapter;
// 		}
// 		params.sdataWhere += " and LANNUM " + (opt.startNumber ? "ge " + opt.startNumber : "gt 0");
// 		if (opt.metaOnly) {
// 			params.sdataWhere += ' and LAN eq "XXX"';
// 		} else {
// 			params.sdataWhere += (opt.noMeta ? ' and LAN ne "XXX"' : "") + (lang ? ' and LAN eq "' + (locale.x3Language(lang) || lang) + '"' : "");
// 		}
// 		if (opt.lastModified) {
// 			params.sdataWhere += ' and UPDDATTIM gt @' + opt.lastModified + '@';
// 		}
// 		params.count = opt.count || fetchCount;
// 		params.orderBy = opt.orderBy;
// 		params.startIndex = opt.startIndex || 0;
// 		return {
// 			entity: entity,
// 			params: params
// 		};
// 	}

// 	function _getLastUpdate(_, chapter) {
// 		if (options.file) {
// 			return "";
// 		} else {
// 			var rec = _getRecords(_, chapter, {
// 				count: 1,
// 				orderBy: {
// 					name: "UPDDATTIM",
// 					descending: true
// 				}
// 			});
// 			return rec && rec[0] && rec[0].UPDDATTIM(_).toString(isoDateFormat) || "";
// 		}
// 	}

// 	function _getRecords(_, chapter, opt) {
// 		opt.file = opt.file || options.file;
// 		if (opt.file) {
// 			return [];
// 		} else {
// 			var query = _getquery(_, chapter, opt);
// 			tracer && tracer("getRecords: params=" + JSON.stringify(query.params));
// 			return db.fetchInstances(_, query.entity, query.params) || [];
// 		}
// 	}

// 	function _getX3Records(_, chapter, opt) {
// 		opt.file = opt.file || options.file;
// 		if (opt.file) {
// 			return _loadFromFile(_, chapter, opt);
// 		} else {
// 			return _loadFromX3(_, chapter, opt);
// 		}
// 	}

// 	function _loadFromFile(_, chapter, opt) {
// 		var x3Records = opt.obj || {},
// 			file = _getMessageFileName(opt.file || options.file, currentCategory),
// 			fetched = 0,
// 			txt = "",
// 			// regex = new RegExp(/\[(\w+):(\d+):(\d+)\]\s*\[([\d\-T:Z]*)\]\s*([^\n\r]*)/g),
// 			regex = new RegExp(/(\w+)\t(\d+)\t(\d+)\t"([\s\S]*?)"[\n\r]+/g),
// 			data = fs.exists(file, _) && fs.readFile(file, "utf8", _),
// 			match, chp, grp, lines, lastUpdate = "";
// 		if (data) {
// 			// data = data.replace(/\r\n/g, "\n");
// 			// data = data.replace(/\r/g, "\n");
// 			// lines = data.split("\n");
// 			// lines.forEach(function(l) {
// 			// if ((match = /\[(\w+):(\d+):(\d+)\]\s(.*)?/.exec(l))) {
// 			while ((match = regex.exec(data)) != null) {
// 				chp = x3Records[match[2]] = x3Records[match[2]] || {};
// 				grp = chp[match[3]] = chp[match[3]] || {};
// 				txt = (match[4] || "").replace(/\u00b7/g, " ").replace(/\"\"/g, '"').replace(/\\n/g, '\n');
// 				// txt = txt.replace(/\u2424/g, "\n");
// 				grp[match[1]] = txt;
// 				fetched++;
// 			}
// 			// });
// 		}
// 		tracer && tracer("loadFromFile count=" + fetched);
// 		diagnosis.info(localizedText("fetchRecords", fetched));
// 		set.x3Records.data = x3Records;
// 		return x3Records;
// 	}

// 	function _loadFromX3(_, chapter, opt) {
// 		if (!options.noDBStore) return;

// 		var query, params, x3Records = opt.obj || {},
// 			records, count, fetched = 0,
// 			startNumber = 1;

// 		do {
// 			opt.startNumber = startNumber;
// 			query = _getquery(_, chapter, opt);
// 			// tracer && tracer("getX3Records: params=" + JSON.stringify(params));
// 			params = query.params;
// 			records = db.fetchInstances(_, query.entity, params) || [];
// 			if (records.$diagnoses) {
// 				if (records.$diagnoses) {
// 					diagnosis.error("loadFromX3: params=" + JSON.stringify(params) + "\n" + JSON.stringify(records.$diagnoses));
// 				}
// 			}
// 			count = isNaN(records.length) ? 0 : records.length || 0;
// 			count && records.forEach_(_, fillRecord);
// 			tracer && tracer("loadFromX3: length=" + count + ", params=" + JSON.stringify(params));
// 			fetched += count;
// 		} while (records.length === fetchCount);
// 		x3Records.$count = fetched;
// 		tracer && tracer("loadFromX3 count=" + fetched + ", params=" + JSON.stringify(params));
// 		diagnosis.info(localizedText("fetchRecords", fetched));
// 		return x3Records;

// 		function fillRecord(_, e) {
// 			x3Records[e.LANCHP(_)] = x3Records[e.LANCHP(_)] || {};
// 			x3Records[e.LANCHP(_)][e.LANNUM(_)] = x3Records[e.LANCHP(_)][e.LANNUM(_)] || {};
// 			x3Records[e.LANCHP(_)][e.LANNUM(_)][e.LAN(_)] = e.LANMES(_);
// 			startNumber = e.LANNUM(_);
// 		}
// 	}

// 	function _findMessage(_, lanchp, lannum, lang) {
// 		var d = set.deleted.data,
// 			c = set.created.data,
// 			u = set.updated.data,
// 			r = set.x3Records.data,
// 			chapter, nums, i, msg, text, match, result;

// 		lang = lang || "ENG";
// 		if (Array.isArray(lannum)) {
// 			for (nums = [], i = lannum[0]; i <= lannum[1]; i++) {
// 				nums.push(i);
// 			}
// 		} else {
// 			nums = [lannum];
// 		}
// 		result = {
// 			message: "",
// 			chunks: []
// 		};
// 		_initChapter(_, lanchp);
// 		chapter = r[lanchp] || u[lanchp] || c[lanchp];
// 		if (chapter) {
// 			result = nums.reduce(function(res, n) {
// 				text = _getText(lanchp, n, lang).text;
// 				if (text) {
// 					res.chunks.push(text);
// 					res.message += text.replace(/(\s+_\s*)$/, " ");
// 				}
// 				return res;
// 			}, result);
// 		}

// 		tracer && tracer("_findMessage: " + lanchp + ", " + lannum + ", " + lang + ", result='" + JSON.stringify(result, null, 2));
// 		return result;
// 	}

// 	function _reset(_, category) {
// 		currentCategory = category;
// 		set = {
// 			x3Records: {
// 				$name: "origin",
// 				data: {}
// 			},
// 			created: {
// 				$name: "create",
// 				data: {}
// 			},
// 			updated: {
// 				$name: "update",
// 				data: {}
// 			},
// 			deleted: {
// 				$name: "delete",
// 				data: {}
// 			}
// 		};
// 	}

// 	function _initChapter(_, chp) {
// 		var data = set.x3Records.data;
// 		if (!data[chp]) {
// 			data[chp] = {};
// 			_getX3Records(_, chp, {
// 				obj: data
// 			});
// 		}
// 	}

// 	function _flush(_) {
// 		var created = set.created.data,
// 			updated = set.updated.data,
// 			deleted = set.deleted.data,
// 			merged = set.x3Records.data,
// 			c0, n0, c, u, m, ue, ce, me;

// 		tracer && tracer("_flush set=" + _stringify(set));

// 		// removed deleted from created and updated
// 		Object.keys(deleted).forEach_(_, function(_, chp) {
// 			if (chp[0] === "$") return;
// 			c0 = deleted[chp];
// 			u = updated[chp];
// 			c = created[chp];
// 			m = merged[chp];
// 			Object.keys(c0).forEach_(_, function(_, id) {
// 				n0 = c0[id];
// 				ue = u && u[id];
// 				ce = c && c[id];
// 				me = m && m[id];
// 				Object.keys(n0).forEach_(_, function(_, lan) {
// 					ue && delete ue[lan];
// 					ce && delete ce[lan];
// 					me && delete me[lan];
// 				});
// 			});
// 		});
// 		set.deleted.data = {};
// 		// created
// 		Object.keys(created).forEach_(_, function(_, chp) {
// 			if (chp[0] === "$") return;
// 			c0 = created[chp];
// 			m = merged[chp] = merged[chp] || {};
// 			Object.keys(c0).forEach_(_, function(_, id) {
// 				n0 = c0[id];
// 				me = m[id] = m[id] || {};
// 				Object.keys(n0).forEach_(_, function(_, lan) {
// 					_dbCreate(_, chp, id, n0[lan], lan);
// 					me[lan] = n0[lan];
// 				});
// 			});
// 		});
// 		_dbFlush(_, true);

// 		set.created.data = {};
// 		// updated
// 		Object.keys(updated).forEach_(_, function(_, chp) {
// 			if (chp[0] === "$") return;
// 			c0 = updated[chp];
// 			m = merged[chp] = merged[chp] || {};
// 			Object.keys(c0).forEach_(_, function(_, id) {
// 				n0 = c0[id];
// 				me = m[id] = m[id] || {};
// 				Object.keys(n0).forEach_(_, function(_, lan) {
// 					_dbUpdate(_, chp, id, n0[lan], lan);
// 					me[lan] = n0[lan];
// 				});
// 			});
// 		});
// 		set.updated.data = {};
// 	}

// 	function _appendTofile(_, chapter) {
// 		var all = set.x3Records.data || {},
// 			messagesFile = _getMessageFileName(options.file, chapter),
// 			c, n, e, txt = "",
// 			contents = "";

// 		tracer && tracer("_appendTofile " + messagesFile);

// 		function numSort(a, b) {
// 			return a - b;
// 		}
// 		// created
// 		Object.keys(all).sort(numSort).forEach_(_, function(_, chp) {
// 			if (chp[0] === "$") return;
// 			c = all[chp];
// 			c && Object.keys(c).sort(numSort).forEach_(_, function(_, id) {
// 				n = c[id];
// 				n && Object.keys(n).sort().forEach_(_, function(_, lan) {
// 					txt = n[lan].replace(/"/g, '""').replace(/\s+$/g, "\u00b7"); // utf-8 middle dot
// 					// txt = txt.replace(/\n/g, "\u2424"); // utf-8 newline char
// 					// txt += lan + ";" + chp + ";" + id + ';"' + txt + '"\n';
// 					contents += lan + "\t" + chp + "\t" + id + '\t"' + txt + '"\n';
// 					// txt += "[" + lan + ":" + chp + ":" + id + "] " + escapeSpecialChars(n[lan]) + "\n";
// 				});
// 			});
// 		});
// 		fs.appendFile(messagesFile, contents, "utf8", _);
// 	}

// 	function _dbFlush(_, force) {
// 		if (!options.noDBStore) return;
// 		var start = currentMillis();
// 		if (!transCfg.noBatch && db.batch && (force || list.length === 1000)) {
// 			tracer && tracer("_dbFlush list=" + _stringify(list));
// 			db.batch(_, entity, list, options);
// 			list = [];
// 		}
// 		tracer && tracer("translation._dbFlush end: " + (currentMillis() - start) + "ms");
// 	}

// 	function _dbCreate(_, chp, id, t, lan) {
// 		if (!options.noDBStore) return;

// 		t = t || " ";
// 		tracer && tracer("_dbCreate " + chp + "/" + id + "/" + lan);
// 		if (!transCfg.noBatch && db.batch) {
// 			list.push({
// 				LANCHP: parseInt(chp, 10),
// 				LANNUM: parseInt(id, 10),
// 				LAN: lan,
// 				LANMES: t
// 			});
// 			_dbFlush(_);
// 		} else {
// 			var msg = entity.createInstance(_, db);
// 			msg.LANCHP(_, parseInt(chp, 10));
// 			msg.LANNUM(_, parseInt(id, 10));
// 			msg.LAN(_, lan);
// 			// put at least a single space to create the record
// 			msg.LANMES(_, t);
// 			msg.save(_);
// 			_addErrors(_, msg);
// 		}
// 	}

// 	function _dbUpdate(_, chp, id, t, lan) {
// 		if (!options.noDBStore) return;

// 		var msg = db.fetchInstance(_, entity, {
// 			sdataWhere: _sdataEqual(chp, id, lan)
// 		});
// 		// tracer && tracer("i: " + i + ", old value: " + msg.LANMES(_));
// 		msg.LANMES(_, t || " ");
// 		msg.save(_);
// 		_addErrors(_, msg);
// 	}

// 	function _setText(col, chp, id, lan, t) {
// 		col = col.data;
// 		col[chp] = col[chp] || {};
// 		col[chp][id] = col[chp][id] || {};
// 		col[chp][id][lan] = t || " ";
// 	}

// 	function _getText(chp, id, lan) {
// 		var d = set.deleted.data,
// 			c = set.created.data,
// 			u = set.updated.data,
// 			r = set.x3Records.data;

// 		if (d[chp] && d[chp][id] && d[chp][id][lan]) {
// 			return {
// 				$col: set.deleted
// 			};
// 		}
// 		if (u[chp] && u[chp][id] && u[chp][id][lan]) {
// 			return {
// 				text: u[chp][id][lan],
// 				$col: set.updated
// 			};
// 		}
// 		if (c[chp] && c[chp][id] && c[chp][id][lan]) {
// 			return {
// 				text: c[chp][id][lan],
// 				$col: set.created
// 			};
// 		}
// 		return {
// 			text: r[chp] && r[chp][id] && r[chp][id][lan],
// 			$col: set.x3Records
// 		};
// 	}

// 	function _createEntry(_, chp, id, message, language, refkey) {
// 		language = language || defaultLanguage;
// 		var x3Lang = language.x3,
// 			refObj, ref, t;

// 		_initChapter(_, chp);
// 		tracer && tracer("_createEntry endpoint=" + endpoint.dataset(_) + ", language=" + JSON.stringify(language) + ", key=" + chp + ":" + id + ', text="' + message + '"');
// 		t = _getText(chp, id, x3Lang);
// 		if (t.text) {
// 			return diagnosis.fatal(localizedText("duplicateKey", chp, id, x3Lang), null, _);
// 		}

// 		_setText(set.created, chp, id, x3Lang, message);

// 		refObj = _getRefObj(_getText(chp, id, "XXX").text);
// 		ref = refObj.key;
// 		if (!ignoreChecksum && ref && ref !== refkey) {
// 			return diagnosis.fatal(localizedText("checksumMismatch", "create", chp, id, x3Lang, JSON.stringify(refkey), JSON.stringify(ref)), null, _);
// 		} else if (!ref) {
// 			// tracer && tracer("ref=" + JSON.stringify(ref));
// 			_setText(set.created, chp, id, "XXX", refkey);
// 		}
// 		return true;
// 	}

// 	function _updateEntry(_, chp, lannum, language, text, chunks, refkey) {
// 		language = language || defaultLanguage;
// 		var x3Lang = language.x3,
// 			refObj, ref, t;

// 		_initChapter(_, chp);
// 		tracer && tracer("_updateEntry: language=" + JSON.stringify(language) + ", num=" + lannum + ' new value=' + text);

// 		var msg, i, diags;
// 		var newChunks = [];
// 		if (text.length > aplStdMaxLength) {
// 			_splitMessage(text, newChunks);
// 			tracer && tracer("old chunks " + JSON.stringify(chunks, null, 2));
// 			tracer && tracer("new chunks " + JSON.stringify(newChunks, null, 2));
// 			if (newChunks.length > chunks.length) {
// 				tracer && tracer(localizedText("cannotExtend", chp, lannum, x3Lang));
// 				return diagnosis.error(localizedText("cannotExtend", chp, lannum, x3Lang), _);
// 			}
// 		} else {
// 			newChunks.push(text);
// 		}

// 		for (i = 0; i < newChunks.length; i++) {
// 			refObj = _getRefObj(_getText(chp, i, "XXX").text);
// 			ref = refObj.key;
// 			if (!ignoreChecksum && ref && ref !== refkey) {
// 				return diagnosis.fatal(localizedText("checksumMismatch", "update", chp, i, x3Lang, JSON.stringify(refkey), JSON.stringify(ref)), null, _);
// 			}
// 			t = _getText(chp, i, x3Lang);
// 			if (t.$col && t.$col.$name === "delete") {
// 				delete t.$col[chp][lannum + i][x3Lang];
// 				t.$col = set.updated;
// 			}
// 			_setText(t.$col || set.created, chp, lannum + i, x3Lang);
// 			// tracer && tracer("i: " + i + ", old value: " + msg.LANMES(_));
// 		}
// 	}

// 	function _initFromIndex(index) {
// 		var data = set.x3Records.data,
// 			d, e, x3Lang;
// 		forEachKey(index, function(gk, gv) {
// 			if (gk[0] === "$") return;
// 			forEachKey(gv, function(mk, mv) {
// 				if (mk[0] === "$") return;
// 				d = data[mv.chp] = data[mv.chp] || {};
// 				e = d[mv.id] = d[mv.id] || {};
// 				e["XXX"] = mv.$key;
// 				forEachKey(mv.text, function(tk, tv) {
// 					x3Lang = locale.x3Language(tk, true);
// 					e[x3Lang] = tv;
// 				});
// 			});
// 		});
// 		return data;
// 	}

// 	// db.resetCache && db.resetCache();
// 	return {
// 		reset: _reset,
// 		getLastUpdate: _getLastUpdate,
// 		getX3Records: _getX3Records,
// 		findMessage: _findMessage,
// 		createEntry: _createEntry,
// 		updateEntry: _updateEntry,
// 		flush: _flush,
// 		initFromIndex: _initFromIndex,
// 		appendTofile: _appendTofile
// 	};
// }

// exports.store = store;

// var hrOffset = 0;
// // first call to initialize hrOffset
// hrOffset = Date.now() - currentMillis();

// function currentMillis() {
// 	var vals = process.hrtime();
// 	return hrOffset + (vals[0] * 1000) + Math.floor(vals[1] / 1000000);
// }

// function unescapeSpecialChars(s) {
// 	return s.replace(/\n/g, "\\n"). //
// 	replace(/\r/g, "\\r"). //
// 	replace(/\t/g, "\\t"). //
// 	replace(/\f/g, "\\f");
// }

// function escapeSpecialChars(s) {
// 	return s.replace(/\n/g, "\\n"). //
// 	replace(/\r/g, "\\r"). //
// 	replace(/\t/g, "\\t"). //
// 	replace(/\f/g, "\\f");
// }