"use strict";

/// !doc
/// 
/// # Translation message storage providers
/// 

var fs = require('streamline-fs');
var sys = require("util");
var jsxml = require("jsxml/lib/jsxml");
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var streams = require('streamline/lib/streams/streams');
var helpers = require("syracuse-core/lib/helpers");
var locale = require("syracuse-core/lib/locale");
var datetime = require("syracuse-core/lib/types/datetime");
var uuid = require("syracuse-core/lib/uuid");
var x3pool = require("syracuse-x3/lib/pool");

var transCfg = config.translation || {};
var tracer = transCfg.trace;
var traceDiagnosis = transCfg.traceDiagnosis;
// var localizedText = locale.format.bind(undefined, module);
var transMod = require.cache[require.resolve("syracuse-translation/lib/translation")];
var localizedText = locale.format.bind(undefined, transMod || module);

var isoDateFormat = exports.isoDateFormat = "yyyy-MM-ddTHH:mm:ssZ";
var tmxDateFormat = "yyyyMMddTHHmmssZ";

var defaultLanguage = exports.defaultLanguage = {
	iso: "en-us",
	x3: locale.x3Language("en-us")
};
var aplStdMaxLength = exports.aplStdMaxLength = 123;
var placeholders = exports.placeholders = {
	equal: "===", // "=en-us=", "=-=", "=:="
	empty: "--" // "-", 
};

var _stringify = helpers.object.stringify;
var forEachKey = helpers.object.forEachKey;
var currentTime = process.hrtime;

function deltaTime(start) {
	var vals = process.hrtime(start);
	return (vals[0] * 1000) + Math.floor(vals[1] / 1000000);
}

function _getRefObj(refText) {
	var a = refText && refText.split(";") || [];
	return {
		key: a[0],
		tick: a[1]
	};
}
exports.getRefObj = _getRefObj;

function _getMessageFileName(prefix, chapter) {
	return prefix + "_" + chapter.$min + "-" + chapter.$max + ".txt";
}
exports.getMessageFileName = _getMessageFileName;

function _splitMessage(message, chunks) {
	var length = message.length;
	var beg = 0,
		end = aplStdMaxLength - 2;

	chunks = chunks || [];
	if (length <= aplStdMaxLength) {
		chunks.push(message);
		return chunks;
	}

	var substr = message.substring(beg, end);
	// tracer && tracer("substr " + substr);
	var pos = end - 1;
	while (pos > 0 && !(/\s/.exec(substr[pos]))) pos--;
	if (pos === 0 && (!(/\s/.exec(substr[pos])))) {
		pos = end - 1;
		tracer && tracer("Can not be splitted correctly. Long chunck without white spaces: " + message);
	}
	chunks.push(message.substring(beg, pos + 1) + " _");
	return _splitMessage(message.substring(pos + 1, length), chunks);
}

exports.splitMessage = _splitMessage;

/// ## MessageStore class
///   Base class of any message store provider.  
///   **DO NOT INSTANCIATE.**  
function MessageStore(context, endpointRead, endpointWrite, options) {
	this.context = context || {};
	this.endpointRead = endpointRead;
	this.endpointWrite = endpointWrite;
	this.options = options || {};
	this.diagnosis = this.options.diagnosis;
	this.ignoreChecksum = this.options.ignoreChecksum;
	this.set = new MessageSet();
	this.currentCategory = null;
}

exports.MessageStore = helpers.defineClass(MessageStore, null, {
	_super: function() {
		return Object.getPrototypeOf(Object.getPrototypeOf(this));
	},
	/// * `store.init(_);`  
	///   Initialize the store.  
	init: function(_) {},
	/// * `store.reset(_, category);`  
	///   Switch to a new message category abd reset the internal message state.  
	reset: function(_, frame) {
		this.frame = frame;
		this.currentCategory = frame.category;
		this.set = new MessageSet();
	},

	getOrmRead: function(_) {
		return this.endpointRead.getOrm(_);
	},
	getOrmWrite: function(_) {
		return this.endpointWrite.getOrm(_);
	},

	getLastUpdate: function(_, chapter) {},

	getX3Records: function(_, chapter, opt) {
		var set = this.getX3RecordSet(_, chapter, opt);
		return set && set.getAll() || {};
	},

	get: function(_, chp1, chp2, lan, stamp, opt) {
		return this.set;
	},
	set: function(chp, id, lan, text) {
		return this._setText(chp, id, lan, text);
	},
	setToDefault: function(chp, id, lan) {
		if (!Array.isArray(id)) {
			id = [id, id];
		}
		for (var i = id[0]; i <= id[1]; i++) {
			this._setText(chp, i, lan, placeholders.equal);
		}
	},

	getFullSet: function() {
		return this.set;
	},
	getX3RecordSet: function(_, chapter, opt) {
		var chp1, chp2;
		if (typeof(chapter) === "object") {
			chp1 = chapter.$min;
			chp2 = chapter.$max;
		} else {
			chp1 = chp2 = chapter;
		}
		return this.get(_, chp1, chp2, "", "", opt);
	},
	findMessage: function(_, lanchp, lannum, lang) {
		this._initChapter(_, lanchp);
		return this.set.findMessage(lanchp, lannum, lang);
	},
	_initChapter: function(_, chp) {
		if (!this.fullyLoaded && !this.set.chapter(chp)) {
			this.getX3RecordSet(_, chp);
		}
	},
	_setText: function(chp, id, lan, text) {
		return this.set.setText(chp, id, lan, text);
	},

	_getText: function(chp, id, lan) {
		return this.set.getText(chp, id, lan);
	},

	createEntry: function(_, chp, id, message, language, refkey) {
		language = language || defaultLanguage;
		var x3Lang = language.x3,
			refObj, ref, t;

		if (Array.isArray(id)) {
			return this.diagnosis.fatal("Cannot create entry for array of ids: " + chp + id + x3Lang, null, _);
		}
		this._initChapter(_, chp);
		tracer && tracer("_createEntry endpoint=" + this.endpointWrite.dataset(_) + ", language=" + JSON.stringify(language) + ", key=" + chp + ":" + id + ', text="' + message + '"');
		t = this._getText(chp, id, x3Lang);

		// if (t.text && t.text !== message && t.text !== placeHolders.equal) {
		if (t.text && t.text !== message) {
			return this.diagnosis.fatal(localizedText("duplicateKey", chp, id, x3Lang), null, _);
		}

		this._setText(chp, id, x3Lang, message);

		refObj = this.set.getRefObj(chp, id);
		ref = refObj.key;
		if (!this.ignoreChecksum && ref && ref !== refkey) {
			return this.diagnosis.fatal(localizedText("checksumMismatch", "create", chp, id, x3Lang, JSON.stringify(refkey), JSON.stringify(ref)), null, _);
		} else if (!ref) {
			// tracer && tracer("ref=" + JSON.stringify(ref));
			this._setText(chp, id, "XXX", refkey);
		}
		return true;
	},
	updateEntry: function(_, chp, lannum, language, text, chunks, refkey) {
		language = language || defaultLanguage;
		var x3Lang = language.x3,
			start = Array.isArray(lannum) ? lannum[0] : lannum,
			refObj, ref, t;

		this._initChapter(_, chp);

		tracer && tracer("_updateEntry: language=" + JSON.stringify(language) + ", num=" + lannum + ' new value=' + text);

		var msg, i, id,
			newChunks = _splitMessage(text);
		if (newChunks.length > 1) {
			tracer && tracer("old chunks " + JSON.stringify(chunks, null, 2));
			tracer && tracer("new chunks " + JSON.stringify(newChunks, null, 2));
			if (newChunks.length > chunks.length) {
				tracer && tracer(localizedText("cannotExtend", chp, lannum, x3Lang));
				return this.diagnosis.error(localizedText("cannotExtend", chp, lannum, x3Lang), _);
			}
		}

		for (i = 0; i < newChunks.length; i++) {
			id = start + i;
			if (!this.ignoreChecksum) {
				refObj = this.set.getRefObj(chp, id);
				ref = refObj.key;
				if (ref && ref !== refkey) {
					return this.diagnosis.fatal(localizedText("checksumMismatch", "update", chp, i, x3Lang, JSON.stringify(refkey), JSON.stringify(ref)), null, _);
				}
			}
			t = this._getText(chp, id, x3Lang);
			this._setText(chp, id, x3Lang, newChunks[i]);
		}
	},

	dupEntry: function(chp, id, srcCulture, destCulture) {
		if (!srcCulture.x3 || destCulture.x3)
			return;
		if (!Array.isArray(id)) {
			id = [id, id];
		}
		for (var i = id[0]; i <= id[1]; i++) {
			this.set.dup(chp, i, srcCulture.x3, destCulture.x3);
		}
	},

	ensureCulture: function(_, destCulture) {
		var tu;
		this.set.traverse(function(context, chp, id, lan, text, state) {
			if (chp == null || id == null || lan != null)
				return;
			tu = context.$id;
			if (tu[destCulture.x3] == null)
				tu[destCulture.x3] = tu[defaultLanguage.x3];
		});
	},

	flush: function(_) {
		var delta = this.set.sync();
		// tracer && tracer("[MessageStore.flush] delta=" + _stringify(delta));
		this.dumpToPlainFile(_, delta, this.options.file + "-delta");
		this.dumpToPlainFile(_, this.set.getAll(), this.options.file);
		this.dumpToTmxFile(_);
		this.updateAll(_);
	},
	initFromIndex: function(index) {
		var mstore = this.set,
			x3Lang;
		forEachKey(index, function(gk, gv) {
			if (gk[0] === "$") return;
			forEachKey(gv, function(mk, mv) {
				if (mk[0] === "$") return;
				mstore.init(mv.chp, mv.id, "XXX", mv.$key);
				forEachKey(mv.text, function(tk, tv) {
					x3Lang = locale.x3Language(tk, true);
					mstore.init(mv.chp, mv.id, x3Lang, tv);
				});
			});
		});
		this.fullyLoaded = true;
		return mstore.getAll();
	},
	dumpToPlainFile: function(_, all, filePrefix) {
		var messagesFile = _getMessageFileName(filePrefix, this.currentCategory),
			c, n, e, txt = "",
			contents = "Language\tChapter\tNumber\tText\n";

		tracer && tracer("[MessageStore.dumpToPlainFile] " + messagesFile);

		Object.keys(all).sort(numSort).forEach(function(chp) {
			if (chp[0] === "$") return;
			c = all[chp];
			c && Object.keys(c).sort(numSort).forEach(function(id) {
				n = c[id];
				n && Object.keys(n).sort().forEach(function(lan) {
					txt = normalizeString(n[lan], true);
					contents += lan + "\t" + chp + "\t" + id + '\t"' + txt + '"\n';
					// txt += "[" + lan + ":" + chp + ":" + id + "] " + escapeSpecialChars(n[lan]) + "\n";
				});
			});
		});
		fs.writeFile(messagesFile, contents, "utf8", _);
	},
	dumpToTmxFile: function(_) {
		var index = this.frame.index || {},
			conf = index.$config || {},
			chapter = conf.$chapter, //this.currentCategory,
			messagesFile = this.options.file + "_" + chapter.$name + ".tmx",
			c, n, e,
			x = {
				tmx: {
					$: {
						version: "1.4"
					},
					header: {
						$: {
							creationtool: "SyracuseTranslationTool",
							creationtoolversion: "1.00",
							datatype: "PlainText",
							segtype: "sentence",
							adminlang: "en-us",
							srclang: "en",
							"o-tmf": "ABCTransMem",
							creationdate: (conf.$createDate && datetime.parse(conf.$createDate) || datetime.now()).toString(tmxDateFormat),
							// creationid: (conf.$source || {}).user,
							changedate: (conf.$lastModified && datetime.parse(conf.$lastModified) || datetime.now()).toString(tmxDateFormat),
							changeid: ((conf.$source || {}).user || {}).login || ""
						},
						note: {
							$value: chapter.$description || ""
						}

					},
					body: {
						tu: []
					}
				}
			},
			tus = x.tmx.body.tu,
			tu,
			tuv,
			tuvs;

		tracer && tracer("[MessageStore.dumpToTmxFile] " + messagesFile);

		forEachKey(index, function(gk, gv) {
			if (gk[0] === "$") return;
			forEachKey(gv, function(mk, mv) {
				if (mk[0] === "$") return;
				tu = {
					$: {
						tuid: gk + "/" + mk,
						datatype: "Text"
					},
					prop: {
						$: {
							type: "x-id"
						},
						$value: mv.chp + ":" + mv.id
					},
					tuv: []
				};
				tus.push(tu);
				tuvs = tu.tuv;
				forEachKey(mv.text, function(tk, tv) {
					tuv = {
						$: {
							"xml:lang": tk
						},
						seg: {
							$value: normalizeString(tv)
						}
					};
					tuvs.push(tuv);
				});
			});
		});

		fs.writeFile(messagesFile, '<?xml version="1.0"?>\n' + jsxml.stringify(x, "\t"), "utf8", _);
	},

	updateAll: function(_) {},
	deleteAll: function(_, chp1, chp2, lan, stamp) {}
});

/// ## FileMessageStore class
///   ```
///   var store = new FileMessageStore(context, endpointRead, endpointWrite, options);
///   store.init(_);
///   ```
function FileMessageStore(context, endpointRead, endpointWrite, options) {
	this._super().constructor(context, endpointRead, endpointWrite, options);
}

exports.FileMessageStore = helpers.defineClass(FileMessageStore, MessageStore, {
	init: function(_) {
		MessageStore.prototype.init.call(this);
	},
	getLastUpdate: function(_, chapter) {
		return "";
	},
	_getRecords: function(_, chapter, opt) {
		return [];
	},

	getX3RecordSet: function(_, chapter, opt) {
		opt = opt || {};
		var x3RecordSet = opt.set || this.set,
			options = this.options,
			file = _getMessageFileName(opt.file || options.file, this.currentCategory),
			fetched = 0,
			txt = "",
			// regex = new RegExp(/\[(\w+):(\d+):(\d+)\]\s*\[([\d\-T:Z]*)\]\s*([^\n\r]*)/g),
			regex = new RegExp(/(\w+)\t(\d+)\t(\d+)\t"([\s\S]*?)"[\n\r]+/g),
			data = fs.exists(file, _) && fs.readFile(file, "utf8", _),
			match,
			// chp, grp, 
			lines, lastUpdate = "";

		fetched = _loadFromCvs(x3RecordSet, data, new RegExp(/(\w+)\t(\d+)\t(\d+)\t"([\s\S]*?)"[\n\r]+/g));

		tracer && tracer("loadFromFile count=" + fetched);
		this.diagnosis.info(localizedText("fetchRecords", fetched), _);
		return x3RecordSet;
	},
});

/// ## X3ClobMessageStore class
///   ```
///   var store = new X3ClobMessageStore(context, endpointRead, endpointWrite, options);
///   store.init(_);
///   ```
var _clobRep = transCfg.clobRepresentation || "ATRANS";

function X3ClobMessageStore(context, endpointRead, endpointWrite, options) {
	this._super().constructor(context, endpointRead, endpointWrite, options);
}

exports.X3ClobMessageStore = helpers.defineClass(X3ClobMessageStore, MessageStore, {
	init: function(_) {
		var self = this;

		function endpointIO(_, ep) {
			var epPath = ep.application(_) + "/" + ep.contract(_) + "/" + ep.dataset(_);

			function _cdoc(chp1, chp2, lan, stamp) {
				var key = ["C_" + _clobRep, "CONTENTS", chp1 || "", (chp2 || chp1 || ""), (lan || ""), stamp || ""].join("~%C2%A8~");
				return "CDOC('" + key + "')";
			}

			function _cdoc2(id) {
				return ["$workingCopies('" + id + "')", _clobRep, "CONTENTS"].join("/");
			}

			function _submit(_, url, body, opt) {
				opt = opt || {};
				url = ["/sdata", epPath, url].join("/");
				var session = self.context.request.session,
					params = {
						head: {
							"accept": "application/json;vnd.sage=syracuse; charset=utf-8",
							"accept-language": locale.current,
							"method": opt.method || "GET",
							"url": url
						},
						body: body || {},
						raw: true
					};
				if (opt.method === "PUT" || opt.method === "POST") {
					params.head["content-type"] = opt.contentType || "application/json;vnd.sage=syracuse; charset=utf-8";
					params.head["content-length"] = !body ? 0 : (typeof(body) === "string" ? body.length : JSON.stringify(body).length);
				}
				if (opt.debug) {
					params.head["pragma"] = "debug-immediate";
				}
				return x3pool.jsonSend(_, session, ep, params);
			}

			return {
				endpoint: ep,
				cdoc: _cdoc,
				cdoc2: _cdoc2,
				submit: _submit,
			};
		}

		MessageStore.prototype.init.call(this);

		this.reader = endpointIO(_, this.endpointRead);
		this.writer = endpointIO(_, this.endpointWrite);
	},
	getLastUpdate: function(_, chapter) {
		return "";
	},
	_getRecords: function(_, chapter, opt) {
		return [];
	},

	get: function(_, chp1, chp2, lan, stamp, opt) {
		opt = opt || {};
		var x3RecordSet = opt.set || this.set,
			fetched = 0,
			reader = this.reader,
			session = this.context.request.session;

		var reply = reader.submit(_, reader.cdoc(chp1, chp2, lan, stamp));
		this.set.initChapter(chp1, chp2);
		fetched = _loadFromCvs(x3RecordSet, reply && reply.body, new RegExp(/(\w+)\t(\d+)\t(\d+)\t([\d\-T:Z]*)\t([\s\S]*?)[\n\r]+/g), {
			withLastUpdateTime: true
		});

		this.diagnosis.info(localizedText("fetchRecords", fetched), _);
		return x3RecordSet;

	},

	updateAll: function(_) {
		var ep = this.endpointWrite,
			writer = this.writer,
			chp1;

		if (!ep) {
			this.diagnosis.fatal("no endpoint", null, _);
			return;
		}
		var id = uuid.generate(),
			data = "",
			url, r;

		this.set.traverse(function(context, chp, id, lan, text, state) {
			if (chp == null || id == null || lan == null)
				return;
			chp1 = chp1 || chp;
			text = normalizeString(text, true);
			data += lan + "\t" + chp + "\t" + id + "\t" + text + "\n";
		});

		tracer && tracer("[X3ClobMessageStore.updateAll] create workingCopie");
		url = _clobRep + "('" + chp1 + "~~')/$workingCopies?representation=" + _clobRep + ".$edit&trackingId=" + id;
		var reply = writer.submit(_, url, "", {
			contentType: "text/plain;charset=utf-8",
			method: "POST"
		});
		if (reply && reply.body && reply.body.charAt(0) === "{") {
			r = JSON.parse(reply.body);
			if (r && r.$diagnoses)
				this.diagnosis.addAll(r.$diagnoses, _);
		}
		// tracer && tracer("\n>>>>\n" + reply.body);

		tracer && tracer("[X3ClobMessageStore.updateAll] update workingCopie");
		// tracer && tracer("[X3ClobMessageStore.updateAll] update workingCopie with\n" + data);
		this.diagnosis.logInfo("Flush\n" + data, _);
		url = writer.cdoc2(id);
		reply = writer.submit(_, url, data, {
			contentType: "text/plain;charset=utf-8",
			method: "PUT"
		});
		if (reply && reply.body && reply.body.charAt(0) === "{") {
			r = JSON.parse(reply.body);
			if (r && r.$diagnoses)
				this.diagnosis.addAll(r.$diagnoses, _);
		}
		// tracer && tracer("\n>>>>\n" + reply.body);

		tracer && tracer("[X3ClobMessageStore.updateAll] save workingCopie");
		url = "$workingCopies('" + id + "')?representation=" + _clobRep + ".$edit";
		reply = writer.submit(_, url, {
			"CHP1": chp1,
			"$actions": {
				"$save": {
					"$isRequested": true
				}
			}
		}, {
			method: "PUT",
		});
		if (reply && reply.body && reply.body.charAt(0) === "{") {
			r = JSON.parse(reply.body);
			if (r && r.$diagnoses)
				this.diagnosis.addAll(r.$diagnoses, _);
		}
		// tracer && tracer("\n>>>>\n" + reply.body);
	},
	deleteAll: function(_, chp1, chp2, lan, stamp) {
		var ep = this.endpointWrite,
			writer = this.writer,
			url, r;
		chp2 = chp2 || "";

		if (!ep) {
			this.diagnosis.fatal("no endpoint", null, _);
			return;
		}

		//http://localhost:8124/sdata/x3/erp/SUPERV/ATRANS('10043~~')?representation=ATRANS.$details
		tracer && tracer("[X3ClobMessageStore.deleteAll]");
		url = _clobRep + "('" + chp1 + "~" + chp2 + "~')?representation=" + _clobRep + ".$details";
		var reply = writer.submit(_, url, "", {
			contentType: "text/plain;charset=utf-8",
			method: "DELETE"
		});
		if (reply && reply.body && reply.body.charAt(0) === "{") {
			r = JSON.parse(reply.body);
			if (r && r.$diagnoses)
				this.diagnosis.addAll(r.$diagnoses, _);
		}
	}
});

function _loadFromCvs(x3RecordSet, data, regex, opt) {
	opt = opt || {};
	var fetched = 0,
		txt = "",
		match,
		lastUpdate = "",
		itxt = opt.withLastUpdateTime ? 5 : 4,
		fixit = (transCfg.fix || {}).read || fixSpecialChars;

	if (data) {
		while ((match = regex.exec(data)) != null) {
			txt = fixit((match[itxt] || "").replace(/\u00b7/g, " ").replace(/\\n/g, '\n'));
			x3RecordSet.init(match[2], match[3], match[1], txt);
			fetched++;
		}
	}
	tracer && tracer("_loadFromCvs count=" + fetched);
	x3RecordSet.$count = fetched;
	return fetched;
}

/// ## MessageSet class
///   ```
///   var set = new MessageSet();
///   ```
///   Manage messages  
function MessageSet() {
	var col = {},
		meta = {};

	function _setText(chp, id, lan, text, defState, stamp) {
		if (!chp || !id || !lan) {
			throw new Error("Cannot set message. Invalid key " + chp + "/" + id + "/" + lan + " with '" + text + "'");
		}
		var chunks, i, ii;
		col[chp] = col[chp] || {};
		col[chp][id] = col[chp][id] || {};
		if (!text)
			tracer && tracer("MessageSet._setText: null or empty text for " + chp + "/" + id + "/" + lan + " with '" + text + "'");

		if (Array.isArray(id)) {
			tracer && tracer("MessageSet._setText: array of id for " + chp + "/" + id + "/" + lan + " with '" + text + "'");
			if (!Array.isArray(text)) {
				throw new Error("Cannot set a message array with a single text. Array of text expected for " + chp + "/" + id + "/" + lan + " with '" + text + "'");
			}
			for (i = id[0], ii = 0; i <= id[1]; i++, ii++) {
				_setText(chp, i, lan, text[ii], defState, stamp);
			}
			return;
		}

		col[chp][id][lan] = text;

		var key = chp + "." + id + "." + lan,
			m = meta[key] || (meta[key] = {});
		m.state = (m.state == null ? defState || "created" : "modified");
		m.stamp = stamp;
		if (stamp > col.$lastUpdate) {
			col.$lastUpdate = stamp;
		}
	}

	this.initChapter = function(chp1, chp2) {
		for (var i = chp1; i <= chp2; i++) {
			col[i] = col[i] || {};
		}
	};

	this.init = function(chp, id, lan, text, stamp) {
		_setText(chp, id, lan, text, "clean");
	};

	this.setText = function(chp, id, lan, text, stamp) {
		_setText(chp, id, lan, text, stamp);
	};

	this.getText = function(chp, id, lan) {
		var text = col[chp] && col[chp][id] && col[chp][id][lan];
		return {
			text: text,
			$col: {
				data: col
			}
		};
	};

	this.getRefObj = function(chp, id) {
		var refText = this.getText(chp, id, "XXX").text,
			a = refText && refText.split(";") || [];
		return {
			key: a[0],
			tick: a[1]
		};
	};

	this.get = function(chp, id, lan) {
		var v = chp ? col[chp] : col;
		if (id === undefined) return v;
		v = v[id] || {};
		if (lan === undefined) return v;
		return v[lan] || "";
	};

	this.dup = function(chp, id, lan1, lan2) {
		var v = col[chp];
		if (!v) return;
		v = v[id];
		if (!v || v[lan1] == null) return;
		v[lan2] = v[lan1];
	};

	this.chapter = function(chp) {
		return col[chp];
	};

	this.findMessage = function(lanchp, lannum, lang) {
		var self = this,
			nums, i, msg, text, match, result;

		lang = lang || "ENG";
		if (Array.isArray(lannum)) {
			for (nums = [], i = lannum[0]; i <= lannum[1]; i++) {
				nums.push(i);
			}
		} else {
			nums = [lannum];
		}
		result = {
			message: "",
			chunks: []
		};

		result = nums.reduce(function(res, n) {
			text = self.getText(lanchp, n, lang).text;
			if (text) {
				res.chunks.push(text);
				res.message += text.replace(/(\s*_\s*)$/, " ");
			}
			return res;
		}, result);

		tracer && tracer("[MessageSet.findMessage] " + lanchp + ", " + lannum + ", " + lang + ", result='" + JSON.stringify(result, null, 2));
		return result;
	};

	this.getAll = function() {
		return col;
	};

	this.sync = function() {
		var ck, ik, lk, chp, id, lan, m, _chp, _id, delta = {};

		// removed deleted from created and updated
		forEachKey(col, function(ck) {
			if (ck[0] === "$") return;
			chp = col[ck];
			forEachKey(chp, function(ik) {
				if (ik[0] === "$") return;
				id = chp[ik];
				forEachKey(id, function(lk) {
					if (lk[0] === "$") return;
					var key = ck + "." + ik + "." + lk;
					m = meta[key] || (meta[key] = {});
					if (m.state === "deleted") {
						_chp = delta[ck] || (delta[ck] = {});
						_id = _chp[ik] || (_chp[ik] = {});
						_id[lk] = null;
						delete id[lk];
						delete meta[key];
					} else if (m.state != "clean") {
						_chp = delta[ck] || (delta[ck] = {});
						_id = _chp[ik] || (_chp[ik] = {});
						_id[lk] = id[lk];
						m.state = "clean";
					}
				});
			});
		});
		return delta;
	};

	this.traverse = function(cb, context) {
		if (!cb)
			return;

		context = context || {};
		forEachKey(col, function(k0, chp) {
			if (k0[0] === "$") return;
			context.$chp = chp;
			cb(context, k0);
			forEachKey(chp, function(k1, id) {
				if (k1[0] === "$") return;
				context.$id = id;
				cb(context, k0, k1);
				forEachKey(id, function(k2, text) {
					var key = k0 + "." + k1 + "." + k2;
					cb(context, k0, k1, k2, text, (meta[key] || {}).state);
				});
			});
		});
	};
}

function numSort(a, b) {
	return a - b;
}

exports.MessageSet = MessageSet;

function fixSpecialChars(s) {
	return s. //
	replace(/\"\"/g, '"'). //
	replace(/\\ n/gi, '\n'). //
	replace(/\\/g, '');
}

function normalizeString(s, convertNewline) {
	if (Array.isArray(s)) {
		return reassembleStrings(s.map(function(t) {
			return normalizeString(t, convertNewline);
		}));
	}
	// replace spaces by a single utf-8 middle dot
	s = s && s.replace(/\s+$/g, "\u00b7") || "";
	return convertNewline ? s.replace(/\n/g, "\\n") : s;
}

function reassembleStrings(a) {
	return a.reduce(function(res, t) {
		res += t.replace(/(\s*_\s*)$/, " ");
	}, "");
}

exports.reassembleStrings = reassembleStrings;

// function unescapeSpecialChars(s) {
// 	return s.replace(/\n/g, "\\n"). //
// 	replace(/\r/g, "\\r"). //
// 	replace(/\t/g, "\\t"). //
// 	replace(/\f/g, "\\f");
// }

// function escapeSpecialChars(s) {
// 	return s.replace(/\n/g, "\\n"). //
// 	replace(/\r/g, "\\r"). //
// 	replace(/\t/g, "\\t"). //
// 	replace(/\f/g, "\\f");
// }