"use strict";

/// !doc
/// 
/// # Translation message storage providers
/// 

var fs = require('streamline-fs');
var fsp = require("path");
var sys = require("util");
var jsxml = require("jsxml/lib/jsxml");
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var streams = require('streamline/lib/streams/streams');
var helpers = require("syracuse-core/lib/helpers");
var locale = require("syracuse-core/lib/locale");
var datetime = require("syracuse-core/lib/types/datetime");
var uuid = require("syracuse-core/lib/uuid");
var x3pool = require("syracuse-x3/lib/pool");

var transCfg = config.translation || {};
var tracer = transCfg.trace;
var traceDiagnosis = transCfg.traceDiagnosis;
// var localizedText = locale.format.bind(undefined, module);
var transMod = require.cache[require.resolve("syracuse-translation/lib/translation")];
var localizedText = locale.format.bind(undefined, transMod || module);

var isoDateFormat = exports.isoDateFormat = "yyyy-MM-ddTHH:mm:ssZ";
var tmxDateFormat = "yyyyMMddTHHmmssZ";

var defaultLanguage = exports.defaultLanguage = {
	iso: "en-us",
	x3: locale.x3Language("en-us")
};
var aplStdMaxLength = exports.aplStdMaxLength = 123;
var placeholders = exports.placeholders = {
	equal: "===", // "=en-us=", "=-=", "=:="
	empty: "--" // "-", 
};

var _stringify = helpers.object.stringify;
var forEachKey = helpers.object.forEachKey;
var currentTime = process.hrtime;

function deltaTime(start) {
	var vals = process.hrtime(start);
	return (vals[0] * 1000) + Math.floor(vals[1] / 1000000);
}

function _getRefObj(refText) {
	var a = refText && refText.split(";") || [];
	return {
		key: a[0],
		tick: a[1]
	};
}
exports.getRefObj = _getRefObj;

function _getMessageFileName(prefix, chapter) {
	return prefix + "_" + chapter.$min + "-" + chapter.$max + ".txt";
}
exports.getMessageFileName = _getMessageFileName;

function _splitMessage(message, chunks) {
	var length = message.length;
	var beg = 0,
		end = aplStdMaxLength - 2;

	chunks = chunks || [];
	if (length <= aplStdMaxLength) {
		chunks.push(message);
		return chunks;
	}

	var substr = message.substring(beg, end);
	// tracer && tracer("substr " + substr);
	var pos = end - 1;
	while (pos > 0 && !(/\s/.exec(substr[pos]))) pos--;
	if (pos === 0 && (!(/\s/.exec(substr[pos])))) {
		pos = end - 1;
		tracer && tracer("Can not be splitted correctly. Long chunck without white spaces: " + message);
	}
	chunks.push(message.substring(beg, pos + 1) + " _");
	return _splitMessage(message.substring(pos + 1, length), chunks);
}

exports.splitMessage = _splitMessage;

/// ## MessageStore class
///   Base class of any message store provider.  
///   **DO NOT INSTANCIATE.**  
function MessageStore(context, endpointRead, endpointWrite, options) {
	this.context = context || {};
	this.endpointRead = endpointRead;
	this.endpointWrite = endpointWrite;
	this.options = options || {};
	this.diagnosis = this.options.diagnosis;
	this.ignoreChecksum = this.options.ignoreChecksum;
	this.set = new MessageSet();
	this.currentCategory = null;
}

exports.MessageStore = helpers.defineClass(MessageStore, null, {
	_super: function() {
		return Object.getPrototypeOf(Object.getPrototypeOf(this));
	},
	/// * `store.init(_);`  
	///   Initialize the store.  
	init: function(_) {},
	/// * `store.reset(_, category);`  
	///   Switch to a new message category abd reset the internal message state.  
	reset: function(_, frame) {
		this.frame = frame;
		this.currentCategory = frame.category;
		this.set = new MessageSet();
	},

	getOrmRead: function(_) {
		return this.endpointRead.getOrm(_);
	},
	getOrmWrite: function(_) {
		return this.endpointWrite.getOrm(_);
	},

	getLastUpdate: function(_, chapter) {},

	getX3Records: function(_, chapter, opt) {
		var set = this.getX3RecordSet(_, chapter, opt);
		return set && set.getAll() || {};
	},

	get: function(_, chp1, chp2, lan, stamp, opt) {
		return this.set;
	},
	set: function(chp, id, lan, text) {
		return this._setText(chp, id, lan, text);
	},
	setToDefault: function(chp, id, lan) {
		if (!Array.isArray(id)) {
			id = [id, id];
		}
		for (var i = id[0]; i <= id[1]; i++) {
			this._setText(chp, i, lan, placeholders.equal);
		}
	},

	getFullSet: function() {
		return this.set;
	},
	getX3RecordSet: function(_, chapter, opt) {
		var chp1, chp2;
		if (typeof(chapter) === "object") {
			chp1 = chapter.$min;
			chp2 = chapter.$max;
		} else {
			chp1 = chp2 = chapter;
		}
		return this.get(_, chp1, chp2, "", "", opt);
	},
	findMessage: function(_, lanchp, lannum, lang) {
		this._initChapter(_, lanchp);
		return this.set.findMessage(lanchp, lannum, lang);
	},
	_initChapter: function(_, chp) {
		if (!this.fullyLoaded && !this.set.chapter(chp)) {
			this.getX3RecordSet(_, chp);
		}
	},
	_setText: function(chp, id, lan, text) {
		return this.set.setText(chp, id, lan, text);
	},

	_getText: function(chp, id, lan) {
		return this.set.getText(chp, id, lan);
	},

	createEntry: function(_, chp, id, message, language, refkey) {
		language = language || defaultLanguage;
		var x3Lang = language.x3,
			refObj, ref, t;

		if (Array.isArray(id)) {
			return this.diagnosis.fatal("Cannot create entry for array of ids: " + chp + id + x3Lang, null, _);
		}
		this._initChapter(_, chp);
		tracer && tracer("_createEntry endpoint=" + this.endpointWrite.dataset(_) + ", language=" + JSON.stringify(language) + ", key=" + chp + ":" + id + ', text="' + message + '"');
		t = this._getText(chp, id, x3Lang);

		// if (t.text && t.text !== message && t.text !== placeHolders.equal) {
		if (t.text && t.text !== message) {
			return this.diagnosis.fatal(localizedText("duplicateKey", chp, id, x3Lang), null, _);
		}

		this._setText(chp, id, x3Lang, message);

		refObj = this.set.getRefObj(chp, id);
		ref = refObj.key;
		if (!this.ignoreChecksum && ref && ref !== refkey) {
			return this.diagnosis.fatal(localizedText("checksumMismatch", "create", chp, id, x3Lang, JSON.stringify(refkey), JSON.stringify(ref)), null, _);
		} else if (!ref) {
			// tracer && tracer("ref=" + JSON.stringify(ref));
			this._setText(chp, id, "XXX", refkey);
		}
		return true;
	},
	updateEntry: function(_, chp, lannum, language, text, chunks, refkey) {
		language = language || defaultLanguage;
		var x3Lang = language.x3,
			start = Array.isArray(lannum) ? lannum[0] : lannum,
			refObj, ref, t;

		this._initChapter(_, chp);

		tracer && tracer("_updateEntry: language=" + JSON.stringify(language) + ", num=" + lannum + ' new value=' + text);

		var msg, i, id,
			newChunks = _splitMessage(text);
		if (newChunks.length > 1) {
			tracer && tracer("old chunks " + JSON.stringify(chunks, null, 2));
			tracer && tracer("new chunks " + JSON.stringify(newChunks, null, 2));
			if (newChunks.length > chunks.length) {
				tracer && tracer(localizedText("cannotExtend", chp, lannum, x3Lang));
				return this.diagnosis.error(localizedText("cannotExtend", chp, lannum, x3Lang), _);
			}
		}

		for (i = 0; i < newChunks.length; i++) {
			id = start + i;
			if (!this.ignoreChecksum) {
				refObj = this.set.getRefObj(chp, id);
				ref = refObj.key;
				if (ref && ref !== refkey) {
					return this.diagnosis.fatal(localizedText("checksumMismatch", "update", chp, i, x3Lang, JSON.stringify(refkey), JSON.stringify(ref)), null, _);
				}
			}
			t = this._getText(chp, id, x3Lang);
			this._setText(chp, id, x3Lang, newChunks[i]);
		}
	},

	dupEntry: function(chp, id, srcCulture, destCulture) {
		if (!srcCulture.x3 || destCulture.x3)
			return;
		if (!Array.isArray(id)) {
			id = [id, id];
		}
		for (var i = id[0]; i <= id[1]; i++) {
			this.set.dup(chp, i, srcCulture.x3, destCulture.x3);
		}
	},

	ensureCulture: function(_, destCulture) {
		var tu;
		this.set.traverse(function(context, chp, id, lan, text, meta) {
			if (chp == null || id == null || lan != null)
				return;
			tu = context.$id;
			if (tu[destCulture.x3] == null)
				tu[destCulture.x3] = tu[defaultLanguage.x3];
		});
	},

	flush: function(_) {
		var delta = this.set.sync(),
			index = this.frame.index;
		if (this.options.renumber && index) {
			this.dumpToPlainFile(_, this.set.getAll(), this.options.file + "-before");
			this.renumberFromIndex(index);
			this.dumpToPlainFile(_, this.set.getAll(), this.options.file + "-after");
			_compare(_, this.getMessageFileName("-before"), //
				this.getMessageFileName("-after"), //
				this.getMessageFileName("-diff"));
			if (!this.options.noDBFlush) {
				this.diagnosis.logInfo("Delete messages from " + index.$config.$chapter.$min + " to " + index.$config.$chapter.$max);
				this.deleteAll(_, index.$config.$chapter.$min, index.$config.$chapter.$max);
			}
		}
		// tracer && tracer("[MessageStore.flush] delta=" + _stringify(delta));
		// this.dumpToPlainFile(_, delta, this.options.file + "-delta");

		this.dumpToPlainFile(_, this.set.getAll(), this.options.file);
		this.dumpToTmxFile(_);

		if (!this.options.noDBFlush)
			this.updateAll(_);
	},

	getMessageFileName: function(suffix) {
		return _getMessageFileName(this.options.file + suffix, this.currentCategory);
	},

	initFromIndex: function(index) {
		var mstore = this.set,
			x3Lang;
		forEachKey(index, function(gk, gv) {
			if (gk[0] === "$") return;
			forEachKey(gv, function(mk, mv) {
				if (mk[0] === "$") return;
				mstore.init(mv.chp, mv.id, "XXX", mv.$key);
				forEachKey(mv.text, function(tk, tv) {
					x3Lang = locale.x3Language(tk, true);
					mstore.init(mv.chp, mv.id, x3Lang, tv);
				});
			});
		});
		this.fullyLoaded = true;
		return mstore.getAll();
	},
	dumpToPlainFile: function(_, all, filePrefix) {
		var messagesFile = _getMessageFileName(filePrefix, this.currentCategory),
			meta, c, n, e, txt = "",
			self = this,
			contents = "Language\tChapter\tNumber\tText\n";

		tracer && tracer("[MessageStore.dumpToPlainFile] " + messagesFile);

		Object.keys(all).sort(numSort).forEach(function(chp) {
			if (chp[0] === "$") return;
			c = all[chp];
			c && Object.keys(c).sort(numSort).forEach(function(id) {
				if (id[0] === "$") return;
				n = c[id];
				n && Object.keys(n).sort().forEach(function(lan) {
					if (lan[0] === "$") return;
					txt = normalizeString(n[lan], true);
					// contents += lan + "\t" + chp + "\t" + id + '\t"' + txt + '"\n';
					meta = self.getMeta(chp, id, lan);
					contents += lan + "\t" + chp + "\t" + id + "\t" + (meta.lanori == null ? "" : meta.lanori) + '\t"' + txt + '"\n';

					// txt += "[" + lan + ":" + chp + ":" + id + "] " + escapeSpecialChars(n[lan]) + "\n";
				});
			});
		});
		fs.writeFile(messagesFile, contents, "utf8", _);
	},
	dumpToTmxFile: function(_) {
		var index = this.frame.index || {},
			conf = index.$config || {},
			chapter = conf.$chapter, //this.currentCategory,
			messagesFile = this.options.file + "_" + chapter.$name + ".tmx",
			c, n, e,
			x = {
				tmx: {
					$: {
						version: "1.4"
					},
					header: {
						$: {
							creationtool: "SyracuseTranslationTool",
							creationtoolversion: "1.00",
							datatype: "PlainText",
							segtype: "sentence",
							adminlang: "en-us",
							srclang: "en",
							"o-tmf": "ABCTransMem",
							creationdate: (conf.$createDate && datetime.parse(conf.$createDate) || datetime.now()).toString(tmxDateFormat),
							// creationid: (conf.$source || {}).user,
							changedate: (conf.$lastModified && datetime.parse(conf.$lastModified) || datetime.now()).toString(tmxDateFormat),
							changeid: ((conf.$source || {}).user || {}).login || ""
						},
						note: {
							$value: chapter.$description || ""
						}

					},
					body: {
						tu: []
					}
				}
			},
			tus = x.tmx.body.tu,
			tu,
			tuv,
			tuvs;

		tracer && tracer("[MessageStore.dumpToTmxFile] " + messagesFile);

		forEachKey(index, function(gk, gv) {
			if (gk[0] === "$") return;
			forEachKey(gv, function(mk, mv) {
				if (mk[0] === "$") return;
				tu = {
					$: {
						tuid: gk + "/" + mk,
						datatype: "Text"
					},
					prop: {
						$: {
							type: "x-id"
						},
						$value: mv.chp + ":" + mv.id
					},
					tuv: []
				};
				tus.push(tu);
				tuvs = tu.tuv;
				forEachKey(mv.text, function(tk, tv) {
					tuv = {
						$: {
							"xml:lang": tk
						},
						seg: {
							$value: normalizeString(tv)
						}
					};
					tuvs.push(tuv);
				});
			});
		});

		fs.writeFile(messagesFile, '<?xml version="1.0"?>\n' + jsxml.stringify(x, "\t"), "utf8", _);
	},

	renumberFromIndex: function(index) {
		var diagnosis = this.diagnosis,
			mset1 = this.set,
			mset2 = new MessageSet(),
			$chapter = index.$chapter || index.$config.$chapter,
			x3Lang,
			tu,
			ctx = {
				$min: $chapter.$min,
				$max: $chapter.$max,
				chp: $chapter.$min,
				id: 1
			}, count = 0,
			visited = {};

		function _visited(chp, id, gk, mk) {
			if (Array.isArray(id)) {
				for (var i = id[0]; i <= id[1]; i++) {
					_visited(chp, i, gk, mk);
				}
				return;
			}

			if (visited[chp + "/" + id]) {
				diagnosis.logWarning("Already exist: " + gk + "/" + mk + " ==> " + chp + "/" + id);
			} else {
				visited[chp + "/" + id] = gk + "/" + mk;
			}
		}

		$chapter.$count = 0;
		$chapter.$current = $chapter.$min;
		$chapter.$ = {};
		forEachKey(index, function(gk, gv) {
			if (gk[0] === "$") return;
			forEachKey(gv, function(mk, mv) {
				if (mk[0] === "$" || ctx.$failed || ctx.chp > $chapter.$max) return;
				if (mv.id[0] === "$") return;
				_visited(mv.chp, mv.id, gk, mk);
				ctx = mset2.append(mset1, mv.chp, mv.id, ctx);
				if (!ctx.$failed) {
					mv.chp = ctx.chp;
					mv.id = ctx.id;
					if (ctx.$deleted) {
						diagnosis.logInfo("Deleting key in index: " + gk + "/" + mk);
						delete gv[mk];
						delete ctx.$deleted;
					} else {
						count += Array.isArray(mv.id) ? mv.id[1] - mv.id[0] + 1 : 1;
						$chapter.$current = ctx.chp;
						$chapter.$[ctx.chp] = $chapter.$[ctx.chp] || {};
						$chapter.$[ctx.chp].$nextId = (ctx.id[1] || ctx.id) + 1;
					}
				}
			});
		});
		$chapter.$count = Object.keys($chapter.$).reduce(function(res, k) {
			return res + $chapter.$[k].$nextId - 1;
		}, 0);
		diagnosis.logInfo("Renumber count=" + count + ", $count=" + $chapter.$count);
		this.set = mset2;
	},
	updateAll: function(_) {},
	deleteAll: function(_, chp1, chp2, lan, stamp) {}
});

/// ## FileMessageStore class
///   ```
///   var store = new FileMessageStore(context, endpointRead, endpointWrite, options);
///   store.init(_);
///   ```
function FileMessageStore(context, endpointRead, endpointWrite, options) {
	this._super().constructor(context, endpointRead, endpointWrite, options);
}

exports.FileMessageStore = helpers.defineClass(FileMessageStore, MessageStore, {
	init: function(_) {
		MessageStore.prototype.init.call(this);
	},
	getLastUpdate: function(_, chapter) {
		return "";
	},
	_getRecords: function(_, chapter, opt) {
		return [];
	},

	getX3RecordSet: function(_, chapter, opt) {
		opt = opt || {};
		var x3RecordSet = opt.set || this.set,
			options = this.options,
			file = _getMessageFileName(opt.file || options.file, this.currentCategory),
			fetched = 0,
			txt = "",
			data = fs.exists(file, _) && fs.readFile(file, "utf8", _),
			match,
			// chp, grp, 
			lines, lastUpdate = "";

		fetched = _loadFromCvs(x3RecordSet, data, new RegExp(/(\w+)\t(\d+)\t(\d+)\t"([\s\S]*?)"[\n\r]+/g));

		tracer && tracer("loadFromFile count=" + fetched);
		this.diagnosis.info(localizedText("fetchRecords", fetched), _);
		return x3RecordSet;
	},
});

/// ## X3ClobMessageStore class
///   ```
///   var store = new X3ClobMessageStore(context, endpointRead, endpointWrite, options);
///   store.init(_);
///   ```
var _clobRep = transCfg.clobRepresentation || "ATRANS";
var _regexMessage = new RegExp(/(\w+)\t(\d+)\t(\d+)\t(\w+)?\t([\d\-T:Z]*)\t([\s\S]*?)[\n\r]+/g);

function X3ClobMessageStore(context, endpointRead, endpointWrite, options) {
	this._super().constructor(context, endpointRead, endpointWrite, options);
}

exports.X3ClobMessageStore = helpers.defineClass(X3ClobMessageStore, MessageStore, {
	init: function(_) {
		var self = this;

		function endpointIO(_, ep) {
			var epPath = ep.application(_) + "/" + ep.contract(_) + "/" + ep.dataset(_);

			function _cdoc(chp1, chp2, lan, stamp) {
				var key = ["C_" + _clobRep, "CONTENTS", chp1 || "", (chp2 || chp1 || ""), (lan || ""), stamp || ""].join("~%C2%A8~");
				return "CDOC('" + key + "')";
			}

			function _cdoc2(id) {
				return ["$workingCopies('" + id + "')", _clobRep, "CONTENTS"].join("/");
			}

			function _submit(_, url, body, opt) {
				opt = opt || {};
				url = ["/sdata", epPath, url].join("/");
				var session = self.context.request.session,
					params = {
						head: {
							"accept": "application/json;vnd.sage=syracuse; charset=utf-8",
							"accept-language": locale.current,
							"method": opt.method || "GET",
							"url": url
						},
						body: body || {},
						raw: true
					};
				if (opt.method === "PUT" || opt.method === "POST") {
					params.head["content-type"] = opt.contentType || "application/json;vnd.sage=syracuse; charset=utf-8";
					params.head["content-length"] = !body ? 0 : (typeof(body) === "string" ? body.length : JSON.stringify(body).length);
				}
				if (opt.debug) {
					params.head["pragma"] = "debug-immediate";
				}
				return x3pool.jsonSend(_, session, ep, params);
			}

			return {
				endpoint: ep,
				cdoc: _cdoc,
				cdoc2: _cdoc2,
				submit: _submit,
			};
		}

		MessageStore.prototype.init.call(this);

		this.reader = endpointIO(_, this.endpointRead);
		this.writer = endpointIO(_, this.endpointWrite);
	},
	getLastUpdate: function(_, chapter) {
		return "";
	},
	_getRecords: function(_, chapter, opt) {
		return [];
	},

	get: function(_, chp1, chp2, lan, stamp, opt) {
		opt = opt || {};
		var x3RecordSet = opt.set || this.set,
			fetched = 0,
			reader = this.reader,
			session = this.context.request.session;

		var reply = reader.submit(_, reader.cdoc(chp1, chp2, lan, stamp));
		this.set.initChapter(chp1, chp2);
		fetched = _loadFromCvs(x3RecordSet, reply && reply.body, _regexMessage);

		this.diagnosis.info(localizedText("fetchRecords", fetched), _);
		return x3RecordSet;

	},

	getMeta: function(chp, id, lan) {
		return this.set.getMeta(chp, id, lan);
	},

	updateAll: function(_) {
		var ep = this.endpointWrite,
			writer = this.writer,
			chp1;

		if (!ep) {
			this.diagnosis.fatal("no endpoint", null, _);
			return;
		}
		var id = uuid.generate(),
			data = "",
			url, r;

		this.set.traverse(function(context, chp, id, lan, text, meta) {
			if (chp == null || id == null || lan == null)
				return;
			chp1 = chp1 || chp;
			text = normalizeString(text, true);
			data += lan + "\t" + chp + "\t" + id + "\t" + meta.lanori + "\t" + text + "\n";
		});

		tracer && tracer("[X3ClobMessageStore.updateAll] create workingCopie");
		url = _clobRep + "('" + chp1 + "~~')/$workingCopies?representation=" + _clobRep + ".$edit&trackingId=" + id;
		var reply = writer.submit(_, url, "", {
			contentType: "text/plain;charset=utf-8",
			method: "POST"
		});
		if (reply && reply.body && reply.body.charAt(0) === "{") {
			r = JSON.parse(reply.body);
			if (r && r.$diagnoses)
				this.diagnosis.addAll(r.$diagnoses, _);
		}
		// tracer && tracer("\n>>>>\n" + reply.body);

		tracer && tracer("[X3ClobMessageStore.updateAll] update workingCopie");
		// tracer && tracer("[X3ClobMessageStore.updateAll] update workingCopie with\n" + data);
		this.diagnosis.logInfo("Flush\n" + data, _);
		url = writer.cdoc2(id);
		reply = writer.submit(_, url, data, {
			contentType: "text/plain;charset=utf-8",
			method: "PUT"
		});
		if (reply && reply.body && reply.body.charAt(0) === "{") {
			r = JSON.parse(reply.body);
			if (r && r.$diagnoses)
				this.diagnosis.addAll(r.$diagnoses, _);
		}
		// tracer && tracer("\n>>>>\n" + reply.body);

		tracer && tracer("[X3ClobMessageStore.updateAll] save workingCopie");
		url = "$workingCopies('" + id + "')?representation=" + _clobRep + ".$edit";
		reply = writer.submit(_, url, {
			"CHP1": chp1,
			"$actions": {
				"$save": {
					"$isRequested": true
				}
			}
		}, {
			method: "PUT",
		});
		if (reply && reply.body && reply.body.charAt(0) === "{") {
			r = JSON.parse(reply.body);
			if (r && r.$diagnoses)
				this.diagnosis.addAll(r.$diagnoses, _);
		}
		// tracer && tracer("\n>>>>\n" + reply.body);
	},
	deleteAll: function(_, chp1, chp2, lan, stamp) {
		var ep = this.endpointWrite,
			writer = this.writer,
			url, r;
		chp2 = chp2 || "";

		if (!ep) {
			this.diagnosis.fatal("no endpoint", null, _);
			return;
		}

		//http://localhost:8124/sdata/x3/erp/SUPERV/ATRANS('10043~~')?representation=ATRANS.$details
		tracer && tracer("[X3ClobMessageStore.deleteAll]");
		url = _clobRep + "('" + chp1 + "~" + chp2 + "~')?representation=" + _clobRep + ".$details";
		var reply = writer.submit(_, url, "", {
			contentType: "text/plain;charset=utf-8",
			method: "DELETE"
		});
		if (reply && reply.body && reply.body.charAt(0) === "{") {
			r = JSON.parse(reply.body);
			if (r && r.$diagnoses)
				this.diagnosis.addAll(r.$diagnoses, _);
		}
	}
});

function _parsePlainContents(data, regex, cb, opt) {
	if (!data) return;
	opt = opt || {};
	var txt = "",
		match,
		itxt,
		fixit = opt.fixChars || fixSpecialChars;

	while ((match = regex.exec(data)) != null) {
		itxt = match.length - 1;
		txt = fixit((match[itxt] || "").replace(/\u00b7/g, " ").replace(/\\n/g, '\n'));
		cb && cb(match[2], match[3], match[1], txt, match[itxt - 1], (itxt > 5) && match[itxt - 2]);
	}
}

function _loadFromCvs(x3RecordSet, data, regex) {
	var fetched = 0;

	function callback(chp, id, lan, text, stamp, lanori) {
		x3RecordSet.init(chp, id, lan, text, stamp, lanori || "");
		fetched++;
	}

	_parsePlainContents(data, regex, callback, {
		fixChars: (transCfg.fix || {}).read
	});
	tracer && tracer("_loadFromCvs count=" + fetched);
	x3RecordSet.$count = fetched;
	return fetched;
}

function _compare(_, file1, file2, dest) {
	var data1 = fs.exists(file1, _) && fs.readFile(file1, "utf8", _),
		data2 = fs.exists(file2, _) && fs.readFile(file2, "utf8", _),
		regex = new RegExp(/(\w+)\t(\d+)\t(\d+)\t(\w+)?\t"([\s\S]*?)"[\n\r]+/g),
		dir = fsp.basename(file1),
		map1 = {}, map2 = {}, key, match, contents = "";

	if (!data1 || !data2)
		return;

	function makeCallback(map, file) {
		return function(chp, id, lan, text, stamp, lanori) {
			if (text === "===") return;
			if (map[lan + "/" + text] == null)
				map[lan + "/" + text] = {
					key: chp + "/" + id + "/" + lan,
					lanori: lanori
				};
			else
				contents += "duplicate text in " + file + " - " + chp + "/" + id + "/" + lan + ": " + text + "\n";
		};
	}

	function cmp(m1, m2, file) {
		Object.keys(m1).forEach(function(k) {
			var v1 = m1[k],
				v2 = m2[k];
			if (v2 == null)
				contents += "missing in " + file + " - " + k + ": " + v1.key + "\n";
			else if (v1.lanori !== v2.lanori)
				contents += "lanori diff " + file + " - " + k + ": " + v1.key + " ==> " + v1.lanori + "vs. " + v2.lanori + "\n";
		});
	}

	_parsePlainContents(data1, regex, makeCallback(map1, file1));
	_parsePlainContents(data2, regex, makeCallback(map2, file2));
	cmp(map1, map2, file2);
	cmp(map2, map1, file1);

	fs.writeFile(dest || fsp.join(fsp.dirname(file1), "messages-diff.txt"), contents, "utf8", _);
}

exports.compare = _compare;

/// ## MessageSet class
///   ```
///   var set = new MessageSet();
///   ```
///   Manage messages  
function MessageSet() {
	var col = {},
		meta = {},
		_byKey = {},
		_tm = {},
		_maxId = 1999;

	function _setText(chp, id, lan, text, defState, stamp, lanori) {
		if (!chp || !id || !lan) {
			throw new Error("Cannot set message. Invalid key " + chp + "/" + id + "/" + lan + " with '" + text + "'");
		}
		var chapter, tu, chunks, i, ii, oldText, tmu;
		if (!text)
			tracer && tracer("MessageSet._setText: null or empty text for " + chp + "/" + id + "/" + lan + " with '" + text + "'");

		if (Array.isArray(id)) {
			tracer && tracer("MessageSet._setText: array of id for " + chp + "/" + id + "/" + lan + " with '" + text + "'");
			if (!Array.isArray(text)) {
				throw new Error("Cannot set a message array with a single text. Array of text expected for " + chp + "/" + id + "/" + lan + " with '" + text + "'");
			}
			for (i = id[0], ii = 0; i <= id[1]; i++, ii++) {
				_setText(chp, i, lan, text[ii], defState, stamp, lanori);
			}
			return;
		}

		if (id > _maxId) {
			throw new Error("Cannot set a message with id > " + _maxId + " for " + chp + "/" + id + "/" + lan + " with '" + text + "'");
		}
		col.$currentChapter = chp;
		chapter = col[chp] || (col[chp] = {});
		if (!chapter.$id) {
			chapter.$id = chp;
		}
		if (~~id > ~~chapter.$hwm) {
			chapter.$hwm = ~~id;
		}
		tu = chapter[id] || (chapter[id] = {});
		if (!tu.$id) {
			tu.$id = id;
		}
		oldText = tu[lan];
		tu[lan] = text;

		if (lan === "XXX") {
			_byKey[text] = tu;
		}
		// else if (lan === defaultLanguage.x3 && !_tm[text]) {
		// tmu = _tm[text] = {
		// 	$text: text
		// };
		// Object.keys(tu).forEach(function(k){
		// 	if (k === "XXX" || k === lan) return;
		// 	tmu[k] = tu[k];
		// });
		// }
		// tmu = _tm[defaultLanguage.x3];
		// if (tmu && tmu[lan] == null) {
		// 	tmu[lan] = text;
		// }

		var key = chp + "." + id + "." + lan,
			m = meta[key] || (meta[key] = {});

		if (m.stamp == null && stamp)
			m.stamp = stamp;
		if (m.lanori == null && lanori != null) {
			m.lanori = lanori;
			// console.log("init lanori of entry: " + key + " => " + m.lanori + " (" + lanori + ")");
		}
		if (m.state == null) {
			m.state = defState || "created";
			if (m.lanori == null) {
				m.lanori = defaultLanguage.x3;
				// console.log("set lanori of new entry: " + key + " => " + m.lanori + " (" + lanori + ")");
			}
		} else if (text != oldText) {
			m.state = "modified";
			m.lanori = defaultLanguage.x3;
			// console.log("set lanori of modified entry: " + key + " => " + m.lanori + " (" + lanori + ")");
		}
		if (text === placeholders.equal)
			m.lanori = "";

		if (stamp > col.$lastUpdate) {
			col.$lastUpdate = stamp;
		}
	}

	function _chapter(chp) {
		return col[chp] || (col[chp] = {});
	}

	this.initChapter = function(chp1, chp2) {
		for (var i = chp1; i <= chp2; i++) {
			col[i] = col[i] || {};
		}
	};

	this.init = function(chp, id, lan, text, stamp, lanori) {
		_setText(chp, id, lan, text, "clean", stamp, lanori);
	};

	this.setText = function(chp, id, lan, text, state, stamp, lanori) {
		_setText(chp, id, lan, text, state, stamp, lanori);
	};

	this.getText = function(chp, id, lan) {
		var text = col[chp] && col[chp][id] && col[chp][id][lan];
		return {
			text: text,
			$col: {
				data: col
			}
		};
	};

	this.getRefObj = function(chp, id) {
		var refText = this.getText(chp, id, "XXX").text,
			a = refText && refText.split(";") || [];
		return {
			key: a[0],
			tick: a[1]
		};
	};

	this.get = function(chp, id, lan) {
		var v = col;
		if (chp === undefined) return v;
		v = col && col[chp];
		if (id === undefined) return v;
		v = v && v[id];
		if (lan === undefined) return v;
		return v && v[lan] || "";
	};

	this.getByKey = function(key, lan) {
		var v = _byKey[key];
		if (lan === undefined) return v;
		return v && v[lan];
	};

	this.getMeta = function(chp, id, lan) {
		if (Array.isArray(id)) {
			var res = [];
			for (var i = id[0], ii = 0; i <= id[1]; i++, ii++) {
				res.push(this.getMeta(chp, i, lan));
			}
			return res;
		}

		return meta[chp + "." + id + "." + lan] || {};
	};

	this.dup = function(chp, id, lan1, lan2) {
		var v = col[chp];
		if (!v) return;
		v = v[id];
		if (!v || v[lan1] == null) return;
		v[lan2] = v[lan1];
	};

	this.append = function(src, chp, id, ctx) {
		var minId = id,
			maxId = id,
			wchp = col.$currentChapter || chp,
			chapter = _chapter(wchp),
			wid = ~~chapter.$hwm + 1,
			self = this,
			tu, m, dist,
			newctx = helpers.object.clone(ctx, true);

		if (wid > _maxId) {
			col.$currentChapter = ~~ (col.$currentChapter || chp) + 1;
			wchp = col.$currentChapter;
			chapter = _chapter(wchp);
			wid = ~~chapter.$hwm + 1;
		}

		if (Array.isArray(id)) {
			// debugger;
			dist = id[1] - id[0];
			if (wid + dist > _maxId) {
				col.$currentChapter = wchp + 1;
				chapter = _chapter(wchp);
				wid = ~~chapter.$hwm + 1;
			}
			for (var i = id[0]; i <= id[1]; i++) {
				ctx = this.append(src, chp, i, ctx);
			}
			newctx.chp = col.$currentChapter;
			newctx.id = [wid, wid + dist];
			return newctx;
		}

		if (chp > ctx.$max) {
			console.error("Chapter overflow");
			newctx.$failed = true;
			return newctx;
		}
		tu = src.get(chp, id);
		if (tu == null || Object.keys(tu).length === 0)
			newctx.$deleted = true;
		else {
			forEachKey(tu, function(lan) {
				if (lan[0] === "$") return;
				m = src.getMeta(chp, id, lan);
				_setText(wchp, wid, lan, tu[lan], m.state, m.stamp, m.lanori);
			});
		}
		newctx.chp = wchp;
		newctx.id = wid;
		return newctx;
	};

	this.chapter = function(chp) {
		return col[chp];
	};

	this.findMessage = function(lanchp, lannum, lang) {
		var self = this,
			nums, i, msg, text, match, result;

		lang = lang || "ENG";
		if (Array.isArray(lannum)) {
			for (nums = [], i = lannum[0]; i <= lannum[1]; i++) {
				nums.push(i);
			}
		} else {
			nums = [lannum];
		}
		result = {
			message: "",
			chunks: []
		};

		result = nums.reduce(function(res, n) {
			text = self.getText(lanchp, n, lang).text;
			if (text) {
				res.chunks.push(text);
				res.message += text.replace(/(\s*_\s*)$/, " ");
			}
			return res;
		}, result);

		tracer && tracer("[MessageSet.findMessage] " + lanchp + ", " + lannum + ", " + lang + ", result='" + JSON.stringify(result, null, 2));
		return result;
	};

	this.getAll = function() {
		return col;
	};

	this.sync = function() {
		var ck, ik, lk, chp, id, lan, m, _chp, _id, delta = {};

		// removed deleted from created and updated
		forEachKey(col, function(ck) {
			if (ck[0] === "$") return;
			chp = col[ck];
			forEachKey(chp, function(ik) {
				if (ik[0] === "$") return;
				id = chp[ik];
				forEachKey(id, function(lk) {
					if (lk[0] === "$") return;
					var key = ck + "." + ik + "." + lk;
					m = meta[key] || (meta[key] = {});
					if (m.state === "deleted") {
						_chp = delta[ck] || (delta[ck] = {});
						_id = _chp[ik] || (_chp[ik] = {});
						_id[lk] = null;
						delete id[lk];
						delete meta[key];
					} else if (m.state != "clean") {
						_chp = delta[ck] || (delta[ck] = {});
						_id = _chp[ik] || (_chp[ik] = {});
						_id[lk] = id[lk];
						m.state = "clean";
					}
				});
			});
		});
		return delta;
	};

	this.traverse = function(cb, context) {
		if (!cb)
			return;

		context = context || {};
		forEachKey(col, function(k0, chp) {
			if (k0[0] === "$") return;
			context.$chp = chp;
			cb(context, k0);
			forEachKey(chp, function(k1, id) {
				if (k1[0] === "$") return;
				context.$id = id;
				cb(context, k0, k1);
				forEachKey(id, function(k2, text) {
					if (k2[0] === "$") return;
					var key = k0 + "." + k1 + "." + k2;
					cb(context, k0, k1, k2, text, meta[key] || {});
				});
			});
		});
	};
}

function numSort(a, b) {
	return~~ a - ~~b;
}

exports.MessageSet = MessageSet;

function fixSpecialChars(s) {
	return s. //
	replace(/\"\"/g, '"'). //
	replace(/\\ n/gi, '\n'). //
	replace(/\\/g, '');
}

function normalizeString(s, convertNewline) {
	if (Array.isArray(s)) {
		return reassembleStrings(s.map(function(t) {
			return normalizeString(t, convertNewline);
		}));
	}
	// replace spaces by a single utf-8 middle dot
	s = s && s.replace(/\s+$/g, "\u00b7") || "";
	return convertNewline ? s.replace(/\n/g, "\\n") : s;
}

function reassembleStrings(a) {
	return a.reduce(function(res, t) {
		res += t.replace(/(\s*_\s*)$/, " ");
	}, "");
}

exports.reassembleStrings = reassembleStrings;

// function unescapeSpecialChars(s) {
// 	return s.replace(/\n/g, "\\n"). //
// 	replace(/\r/g, "\\r"). //
// 	replace(/\t/g, "\\t"). //
// 	replace(/\f/g, "\\f");
// }

// function escapeSpecialChars(s) {
// 	return s.replace(/\n/g, "\\n"). //
// 	replace(/\r/g, "\\r"). //
// 	replace(/\t/g, "\\t"). //
// 	replace(/\f/g, "\\f");
// }