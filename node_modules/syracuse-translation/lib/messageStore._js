"use strict";

/// !doc
/// 
/// # Translation message storage providers
/// 

var fs = require('streamline-fs');
var fsp = require("path");
var sys = require("util");
var jsxml = require("jsxml/lib/jsxml");
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var streams = require('streamline/lib/streams/streams');
var helpers = require("syracuse-core/lib/helpers");
var locale = require("syracuse-core/lib/locale");
var datetime = require("syracuse-core/lib/types/datetime");
var uuid = require("syracuse-core/lib/uuid");
var x3pool = require("syracuse-x3/lib/pool");

var transCfg = config.translation || {};
var tracer = transCfg.trace;
var traceDiagnosis = transCfg.traceDiagnosis;
// var localizedText = locale.format.bind(undefined, module);
var transMod = require.cache[require.resolve("syracuse-translation/lib/translation")];
var localizedText = locale.format.bind(undefined, transMod || module);

var isoDateFormat = exports.isoDateFormat = "yyyy-MM-ddTHH:mm:ssZ";
var tmxDateFormat = "yyyyMMddTHHmmssZ";

var defaultLanguage = exports.defaultLanguage = {
	iso: "en-us",
	x3: locale.x3Language("en-us")
};
var aplStdMaxLength = exports.aplStdMaxLength = 123;
var placeholders = exports.placeholders = {
	equal: "===", // "=en-us=", "=-=", "=:="
	empty: "--" // "-", 
};

var _stringify = helpers.object.stringify;
var forEachKey = helpers.object.forEachKey;
var currentTime = process.hrtime;

function deltaTime(start) {
	var vals = process.hrtime(start);
	return (vals[0] * 1000) + Math.floor(vals[1] / 1000000);
}

function _getRefObj(refText) {
	var a = refText && refText.split(";") || [];
	return {
		key: a[0],
		seg: a[1],
		tick: a[2]
	};
}
exports.getRefObj = _getRefObj;

function _getMessageFileName(prefix, chapter) {
	return prefix + (chapter ? "_" + chapter.$min + "-" + chapter.$max : "") + ".txt";
}
exports.getMessageFileName = _getMessageFileName;

function _splitMessage(message, chunks) {
	var length = message.length;
	var beg = 0,
		end = aplStdMaxLength - 1;

	chunks = chunks || [];
	if (length <= aplStdMaxLength) {
		chunks.push(message);
		return chunks;
	}

	var substr = message.substring(beg, end);
	// tracer && tracer("substr " + substr);
	var pos = end - 1;
	while (pos > 0 && !(/\s/.exec(substr[pos]))) pos--;
	if (pos === 0 && (!(/\s/.exec(substr[pos])))) {
		pos = end - 1;
		tracer && tracer("Can not be splitted correctly. Long chunck without white spaces: " + message);
	}
	chunks.push(message.substring(beg, pos + 1) + "_");
	return _splitMessage(message.substring(pos + 1, length), chunks);
}

exports.splitMessage = _splitMessage;

function _makeKey(a, b, c) {
	if (Array.isArray(b)) b = b[0];
	return a + "/" + b + (c === undefined ? "" : "/" + c);
}

/// ## MessageStore class
///   Base class of any message store provider.  
///   **DO NOT INSTANCIATE.**  
function MessageStore(context, endpointRead, endpointWrite, options) {
	this.context = context || {};
	this.endpointRead = endpointRead;
	this.endpointWrite = endpointWrite;
	this.options = options || {};
	this.diagnosis = this.options.diagnosis;
	this.ignoreChecksum = this.options.ignoreChecksum;
	this.set = new MessageSet();
	this.currentCategory = null;
}

exports.MessageStore = helpers.defineClass(MessageStore, null, {
	_super: function() {
		return Object.getPrototypeOf(Object.getPrototypeOf(this));
	},
	/// * `store.init(_);`  
	///   Initialize the store.  
	init: function(_) {},
	/// * `store.reset(_, category);`  
	///   Switch to a new message category abd reset the internal message state.  
	reset: function(_, frame) {
		this.frame = frame;
		this.currentCategory = frame.category;
		this.set = new MessageSet();
	},

	getOrmRead: function(_) {
		return this.endpointRead.getOrm(_);
	},
	getOrmWrite: function(_) {
		return this.endpointWrite.getOrm(_);
	},

	getLastUpdate: function(_, chapter) {},

	get: function(_, chp1, chp2, lan, stamp, opt) {
		return this.set;
	},
	set: function(chp, id, lan, text) {
		return this._setText(chp, id, lan, text);
	},

	setToDefault: function(language, key) {
		this.upsertMessage(placeholders.equal, language, key, {
			sameForAll: true
		});
	},

	getFullSet: function() {
		return this.set;
	},
	getX3RecordSet: function(_, chapter, opt) {
		var chp1, chp2;
		if (typeof(chapter) === "object") {
			chp1 = chapter.$min;
			chp2 = chapter.$max;
		} else {
			chp1 = chp2 = chapter;
		}
		return this.get(_, chp1, chp2, "", "", opt);
	},
	getMessageByKey: function(key, lang) {
		return this.set.getMessageByKey(key, lang);
	},
	_initChapter: function(_, chp) {
		if (!this.fullyLoaded && !this.set.chapter(chp)) {
			this.getX3RecordSet(_, chp);
		}
	},
	_setText: function(chp, id, lan, text) {
		return this.set.setText(chp, id, lan, text);
	},

	_getText: function(chp, id, lan) {
		return this.set.getText(chp, id, lan);
	},

	createEntry: function(_, chp, id, message, language, refkey) {
		language = language || defaultLanguage;
		var x3Lang = language.x3,
			refObj, ref, t;

		if (Array.isArray(id)) {
			return this.diagnosis.fatal("Cannot create entry for array of ids: " + chp + id + x3Lang, null);
		}
		this._initChapter(_, chp);
		tracer && tracer("_createEntry endpoint=" + this.endpointWrite.dataset(_) + ", language=" + JSON.stringify(language) + ", key=" + chp + ":" + id + ', text="' + message + '"');
		t = this._getText(chp, id, x3Lang);

		// if (t.text && t.text !== message && t.text !== placeHolders.equal) {
		if (t.text && t.text !== message) {
			return this.diagnosis.fatal(localizedText("duplicateKey", chp, id, x3Lang), null);
		}

		this._setText(chp, id, x3Lang, message);

		refObj = this.set.getRefObj(chp, id);
		ref = refObj.key;
		if (!this.ignoreChecksum && ref && ref !== refkey) {
			return this.diagnosis.fatal(localizedText("checksumMismatch", "create", chp, id, x3Lang, JSON.stringify(refkey), JSON.stringify(ref)), null);
		} else if (!ref) {
			// tracer && tracer("ref=" + JSON.stringify(ref));
			this._setText(chp, id, "XXX", refkey);
		}
		return true;
	},
	updateEntry: function(_, chp, lannum, language, text, chunks, refkey) {
		language = language || defaultLanguage;
		var x3Lang = language.x3,
			start = Array.isArray(lannum) ? lannum[0] : lannum,
			refObj, ref, t;

		this._initChapter(_, chp);

		tracer && tracer("_updateEntry: language=" + JSON.stringify(language) + ", num=" + lannum + ' new value=' + text);

		var msg, i, id,
			newChunks = _splitMessage(text);
		if (newChunks.length > 1) {
			tracer && tracer("old chunks " + JSON.stringify(chunks, null, 2));
			tracer && tracer("new chunks " + JSON.stringify(newChunks, null, 2));
			if (newChunks.length > chunks.length) {
				tracer && tracer(localizedText("cannotExtend", chp, lannum, x3Lang));
				return this.diagnosis.error(localizedText("cannotExtend", chp, lannum, x3Lang));
			}
		}

		for (i = 0; i < newChunks.length; i++) {
			id = start + i;
			if (!this.ignoreChecksum) {
				refObj = this.set.getRefObj(chp, id);
				ref = refObj.key;
				if (ref && ref !== refkey) {
					return this.diagnosis.fatal(localizedText("checksumMismatch", "update", chp, i, x3Lang, JSON.stringify(refkey), JSON.stringify(ref)), null);
				}
			}
			t = this._getText(chp, id, x3Lang);
			this._setText(chp, id, x3Lang, newChunks[i]);
		}
	},

	dupEntry: function(chp, id, srcCulture, destCulture) {
		if (!srcCulture.x3 || destCulture.x3)
			return;
		if (!Array.isArray(id)) {
			id = [id, id];
		}
		for (var i = id[0]; i <= id[1]; i++) {
			this.set.dup(chp, i, srcCulture.x3, destCulture.x3);
		}
	},

	upsertMessage: function(message, language, refkey, opt) {
		return this.set.upsertMessage(message, language, refkey, opt);
	},

	ensureCulture: function(_, destCulture) {
		var tu;
		this.set.traverse(function(context, chp, id, lan, text, meta) {
			if (chp == null || id == null || lan != null)
				return;
			tu = context.$id;
			if (tu[destCulture.x3] == null)
				tu[destCulture.x3] = tu[defaultLanguage.x3];
		});
	},

	flush: function(_) {
		var //delta = this.set.sync(),
		index = this.frame.index;
		if (this.options.renumber && index) {
			this.dumpToPlainFile(_, this.options.file + "-before");
			this.renumberFromIndex(index);
			this.dumpToPlainFile(_, this.options.file + "-after");
			_compare(_, this.getMessageFileName("-before"), //
				this.getMessageFileName("-after"), //
				this.getMessageFileName("-diff"));
			if (!this.options.noDBFlush) {
				this.diagnosis.logInfo("Delete messages from " + index.$config.$chapter.$min + " to " + index.$config.$chapter.$max);
				this.deleteAll(_, index.$config.$chapter.$min, index.$config.$chapter.$max);
			}
		}
		// tracer && tracer("[MessageStore.flush] delta=" + _stringify(delta));
		// this.dumpToPlainFile(_, this.options.file + "-delta", delta);

		this.dumpToPlainFile(_, this.options.file);
		this.dumpToTmxFile(_);

		if (!this.options.noDBFlush)
			this.updateAll(_);
	},

	getMessageFileName: function(suffix) {
		return _getMessageFileName(this.options.file + suffix, this.currentCategory);
	},

	load: function(data) {
		var fetched = _loadFromCvs(this.set, data, _regexMessage);
		if (fetched === 0) {
			fetched = _loadFromCvs(this.set, data, _regexMessageWithoutStamp);
		}
		this.diagnosis.logInfo("Load from data fetch " + fetched + " records");
		return fetched;
	},

	initFromIndex: function(index) {
		var mset = this.set,
			x3Lang;
		forEachKey(index, function(gk, gv) {
			if (gk[0] === "$") return;
			forEachKey(gv, function(mk, mv) {
				if (mk[0] === "$") return;
				mset.init(mv.chp, mv.id, "XXX", mv.$key);
				forEachKey(mv.text, function(tk, tv) {
					x3Lang = locale.x3Language(tk, true);
					mset.init(mv.chp, mv.id, x3Lang, tv);
				});
			});
		});
		this.fullyLoaded = true;
		return mset;
	},
	dumpToPlainFile: function(_, filePrefix, set, opt) {
		var messagesFile = _getMessageFileName(filePrefix, this.currentCategory);
		if (set === undefined) {
			set = this.set;
		}
		tracer && tracer("[MessageStore.dumpToPlainFile] " + messagesFile);
		set && set.dumpToPlainFile(_, messagesFile, opt);
	},
	dumpToTmxFile: function(_) {
		var index = this.frame.index || {},
			conf = index.$config || {},
			chapter = conf.$chapter, //this.currentCategory,
			messagesFile = this.options.file + "_" + chapter.$name + ".tmx",
			c, n, e,
			x = {
				tmx: {
					$: {
						version: "1.4"
					},
					header: {
						$: {
							creationtool: "SyracuseTranslationTool",
							creationtoolversion: "1.00",
							datatype: "PlainText",
							segtype: "sentence",
							adminlang: "en-us",
							srclang: "en",
							"o-tmf": "ABCTransMem",
							creationdate: (conf.$createDate && datetime.parse(conf.$createDate) || datetime.now()).toString(tmxDateFormat),
							// creationid: (conf.$source || {}).user,
							changedate: (conf.$lastModified && datetime.parse(conf.$lastModified) || datetime.now()).toString(tmxDateFormat),
							changeid: ((conf.$source || {}).user || {}).login || ""
						},
						note: {
							$value: chapter.$description || ""
						}

					},
					body: {
						tu: []
					}
				}
			},
			tus = x.tmx.body.tu,
			tu,
			tuv,
			tuvs;

		tracer && tracer("[MessageStore.dumpToTmxFile] " + messagesFile);

		forEachKey(index, function(gk, gv) {
			if (gk[0] === "$") return;
			forEachKey(gv, function(mk, mv) {
				if (mk[0] === "$") return;
				tu = {
					$: {
						tuid: gk + "/" + mk,
						datatype: "Text"
					},
					prop: {
						$: {
							type: "x-id"
						},
						$value: mv.chp + ":" + mv.id
					},
					tuv: []
				};
				tus.push(tu);
				tuvs = tu.tuv;
				forEachKey(mv.text, function(tk, tv) {
					tuv = {
						$: {
							"xml:lang": tk
						},
						seg: {
							$value: normalizeString(tv)
						}
					};
					tuvs.push(tuv);
				});
			});
		});

		fs.writeFile(messagesFile, '<?xml version="1.0"?>\n' + jsxml.stringify(x, "\t"), "utf8", _);
	},

	renumberFromIndex: function(index) {
		var diagnosis = this.diagnosis,
			mset1 = this.set,
			mset2 = new MessageSet(),
			$chapter = index.$chapter || index.$config.$chapter,
			x3Lang,
			tu,
			ctx = {
				$min: $chapter.$min,
				$max: $chapter.$max,
				chp: $chapter.$min,
				id: 1
			}, count = 0,
			visited = {};

		function _visited(chp, id, gk, mk) {
			if (Array.isArray(id)) {
				for (var i = id[0]; i <= id[1]; i++) {
					_visited(chp, i, gk, mk);
				}
				return;
			}

			if (visited[_makeKey(chp, id)]) {
				diagnosis.logWarning("Already exist: " + gk + "/" + mk + " ==> " + _makeKey(chp, id));
			} else {
				visited[_makeKey(chp, id)] = gk + "/" + mk;
			}
		}

		$chapter.$count = 0;
		$chapter.$current = $chapter.$min;
		$chapter.$ = {};
		forEachKey(index, function(gk, gv) {
			if (gk[0] === "$") return;
			forEachKey(gv, function(mk, mv) {
				if (mk[0] === "$" || ctx.$failed || ctx.chp > $chapter.$max) return;
				if (mv.id[0] === "$") return;
				_visited(mv.chp, mv.id, gk, mk);
				ctx = mset2.append(mset1, mv.chp, mv.id, ctx);
				if (!ctx.$failed) {
					mv.chp = ctx.chp;
					mv.id = ctx.id;
					if (ctx.$deleted) {
						diagnosis.logInfo("Deleting key in index: " + gk + "/" + mk);
						delete gv[mk];
						delete ctx.$deleted;
					} else {
						count += Array.isArray(mv.id) ? mv.id[1] - mv.id[0] + 1 : 1;
						$chapter.$current = ctx.chp;
						$chapter.$[ctx.chp] = $chapter.$[ctx.chp] || {};
						$chapter.$[ctx.chp].$nextId = (ctx.id[1] || ctx.id) + 1;
					}
				}
			});
		});
		$chapter.$count = Object.keys($chapter.$).reduce(function(res, k) {
			return res + $chapter.$[k].$nextId - 1;
		}, 0);
		diagnosis.logInfo("Renumber count=" + count + ", $count=" + $chapter.$count);
		this.set = mset2;
	},
	updateAll: function(_) {},
	deleteAll: function(_, chp1, chp2, lan, stamp) {}
});

/// ## FileMessageStore class
///   ```
///   var store = new FileMessageStore(context, endpointRead, endpointWrite, options);
///   store.init(_);
///   ```
function FileMessageStore(context, endpointRead, endpointWrite, options) {
	this._super().constructor(context, endpointRead, endpointWrite, options);
}

exports.FileMessageStore = helpers.defineClass(FileMessageStore, MessageStore, {
	init: function(_) {
		MessageStore.prototype.init.call(this);
	},
	getLastUpdate: function(_, chapter) {
		return "";
	},
	_getRecords: function(_, chapter, opt) {
		return [];
	},

	getX3RecordSet: function(_, chapter, opt) {
		opt = opt || {};
		var x3RecordSet = opt.set || this.set,
			options = this.options,
			file = _getMessageFileName(opt.file || options.file, this.currentCategory),
			fetched = 0,
			txt = "",
			data = fs.exists(file, _) && fs.readFile(file, "utf8", _),
			match,
			// chp, grp, 
			lines, regex,
			lastUpdate = "";

		if (opt.quoted)
			regex = new RegExp(/(\w+)\t(\d+)\t(\d+)\t"([\s\S]*?)"[\n\r]+/g);
		else
			regex = new RegExp(/(\w+)\t(\d+)\t(\d+)\t([\s\S]*?)[\n\r]+/g);

		fetched = _loadFromCvs(x3RecordSet, data, regex);

		tracer && tracer("loadFromFile count=" + fetched);
		this.diagnosis.info(localizedText("fetchRecords", fetched));
		return x3RecordSet;
	},
});

/// ## X3ClobMessageStore class
///   ```
///   var store = new X3ClobMessageStore(context, endpointRead, endpointWrite, options);
///   store.init(_);
///   ```
var _clobRep = transCfg.clobRepresentation || "ATRANS";
var _regexMessage = new RegExp(/(\w+)\t(\d+)\t(\d+)\t(\w+)?\t([\d\-T:Z]*)\t([\s\S]*?)[\n\r]+/g);
var _regexMessageWithoutStamp = new RegExp(/(\w+)\t(\d+)\t(\d+)\t(\w+)?\t([\s\S]*?)[\n\r]+/g);

function X3ClobMessageStore(context, endpointRead, endpointWrite, options) {
	this._super().constructor(context, endpointRead, endpointWrite, options);
}

exports.X3ClobMessageStore = helpers.defineClass(X3ClobMessageStore, MessageStore, {
	init: function(_) {
		var self = this;

		function endpointIO(_, ep) {
			var epPath = ep.application(_) + "/" + ep.contract(_) + "/" + ep.dataset(_);

			function _cdoc(chp1, chp2, lan, stamp) {
				var key = ["C_" + _clobRep, "CONTENTS", chp1 || "", (chp2 || chp1 || ""), (lan || ""), stamp || ""].join("~%C2%A8~");
				return "CDOC('" + key + "')";
			}

			function _cdoc2(id) {
				return ["$workingCopies('" + id + "')", _clobRep, "CONTENTS"].join("/");
			}

			function _submit(_, url, body, opt) {
				opt = opt || {};
				url = ["/sdata", epPath, url].join("/");
				var session = self.context.request.session,
					params = {
						head: {
							"accept": "application/json;vnd.sage=syracuse; charset=utf-8",
							"accept-language": locale.current,
							"method": opt.method || "GET",
							"url": url
						},
						body: body || {},
						raw: true
					};
				if (opt.method === "PUT" || opt.method === "POST") {
					params.head["content-type"] = opt.contentType || "application/json;vnd.sage=syracuse; charset=utf-8";
					params.head["content-length"] = !body ? 0 : (typeof(body) === "string" ? body.length : JSON.stringify(body).length);
				}
				if (opt.debug) {
					params.head["pragma"] = "debug-immediate";
				}
				return x3pool.jsonSend(_, session, ep, params);
			}

			return {
				endpoint: ep,
				cdoc: _cdoc,
				cdoc2: _cdoc2,
				submit: _submit,
			};
		}

		MessageStore.prototype.init.call(this);

		this.reader = endpointIO(_, this.endpointRead);
		this.writer = endpointIO(_, this.endpointWrite);
	},
	getLastUpdate: function(_, chapter) {
		return "";
	},
	_getRecords: function(_, chapter, opt) {
		return [];
	},

	get: function(_, chp1, chp2, lan, stamp, opt) {
		opt = opt || {};
		var x3RecordSet = opt.set || this.set,
			fetched = 0,
			reader = this.reader,
			session = this.context.request.session;

		var reply = reader.submit(_, reader.cdoc(chp1, chp2, lan, stamp));
		this.set.initChapter(chp1, chp2);
		fetched = _loadFromCvs(x3RecordSet, reply && reply.body, _regexMessage);

		this.diagnosis.info(localizedText("fetchRecords", fetched));
		return x3RecordSet;

	},

	getMeta: function(chp, id, lan) {
		return this.set.getMeta(chp, id, lan);
	},

	updateAll: function(_) {
		var self = this,
			ep = this.endpointWrite,
			writer = this.writer,
			chp1;

		function replyInError(reply) {
			var errors;
			if (reply && reply.body && reply.body.charAt(0) === "{") {
				r = JSON.parse(reply.body);
				if (r && r.$diagnoses) {
					self.diagnosis.addAll(r.$diagnoses);
					errors = r.$diagnoses.filter(function(d) {
						return d.$severity === "error";
					}) || [];
					if (errors.length > 0) {
						self.diagnosis.logError(JSON.stringify(errors));
						return true;
					}
				}
			}
			return false;
		}

		if (!ep) {
			this.diagnosis.fatal("no endpoint", null);
			return;
		}
		var id = uuid.generate(),
			data = "",
			url, r;

		this.set.traverse(function(context, chp, id, lan, text, meta) {
			var lanori = meta && meta.lanori || "";
			if (chp == null || id == null || lan == null)
				return;
			chp1 = chp1 || chp;
			text = normalizeString(text, true);
			data += lan + "\t" + chp + "\t" + id + "\t" + lanori + "\t" + text + "\n";
		});

		url = _clobRep + "('" + chp1 + "~~')/$workingCopies?representation=" + _clobRep + ".$edit&trackingId=" + id;
		this.diagnosis.logInfo("Creating workingCopie: " + url);
		var reply = writer.submit(_, url, "", {
			contentType: "text/plain;charset=utf-8",
			method: "POST"
		});
		if (replyInError(reply))
			return;
		// tracer && tracer("\n>>>>\n" + reply.body);

		url = writer.cdoc2(id);
		this.diagnosis.logInfo("Updating workingCopie: " + url + "\n" + data);
		reply = writer.submit(_, url, data, {
			contentType: "text/plain;charset=utf-8",
			method: "PUT"
		});
		if (replyInError(reply))
			return;
		// tracer && tracer("\n>>>>\n" + reply.body);

		this.diagnosis.logInfo("Saving workingCopie");
		url = "$workingCopies('" + id + "')?representation=" + _clobRep + ".$edit";
		reply = writer.submit(_, url, {
			"CHP1": chp1,
			"$actions": {
				"$save": {
					"$isRequested": true
				}
			}
		}, {
			method: "PUT",
		});
		if (replyInError(reply))
			return;
		this.diagnosis.logInfo("Reply:\n" + reply.body);
		// tracer && tracer("\n>>>>\n" + reply.body);
	},
	deleteAll: function(_, chp1, chp2, lan, stamp) {
		var ep = this.endpointWrite,
			writer = this.writer,
			url, r;
		chp2 = chp2 || "";

		if (!ep) {
			this.diagnosis.fatal("no endpoint", null);
			return;
		}

		//http://localhost:8124/sdata/x3/erp/SUPERV/ATRANS('10043~~')?representation=ATRANS.$details
		tracer && tracer("[X3ClobMessageStore.deleteAll]");
		url = _clobRep + "('" + chp1 + "~" + chp2 + "~')?representation=" + _clobRep + ".$details";
		var reply = writer.submit(_, url, "", {
			contentType: "text/plain;charset=utf-8",
			method: "DELETE"
		});
		if (reply && reply.body && reply.body.charAt(0) === "{") {
			r = JSON.parse(reply.body);
			if (r && r.$diagnoses)
				this.diagnosis.addAll(r.$diagnoses);
		}
	}
});

function _parsePlainContents(data, regex, cb, opt) {
	if (!data) return;
	opt = opt || {};
	var txt = "",
		match,
		itxt,
		fixit = opt.fixChars || fixSpecialChars;

	while ((match = regex.exec(data)) != null) {
		itxt = match.length - 1;
		txt = fixit((match[itxt] || "").replace(/\u00b7/g, " ").replace(/\\n/g, '\n'));
		cb && cb(match[2], match[3], match[1], txt, (itxt > 5) ? match[itxt - 1] : null, (itxt > 5) ? match[itxt - 2] : match[itxt - 1]);
	}
}

function _loadFromCvs(x3RecordSet, data, regex) {
	var fetched = 0;

	function callback(chp, id, lan, text, stamp, lanori) {
		x3RecordSet.init(chp, id, lan, text, stamp, lanori || "");
		fetched++;
	}

	_parsePlainContents(data, regex, callback, {
		fixChars: (transCfg.fix || {}).read
	});
	tracer && tracer("_loadFromCvs count=" + fetched);
	x3RecordSet.$count = fetched;
	return fetched;
}

function _compare(_, file1, file2, dest) {
	var data1 = fs.exists(file1, _) && fs.readFile(file1, "utf8", _),
		data2 = fs.exists(file2, _) && fs.readFile(file2, "utf8", _),
		// regex = new RegExp(/(\w+)\t(\d+)\t(\d+)\t(\w+)?\t"([\s\S]*?)"[\n\r]+/g),
		regex = new RegExp(/(\w+)\t(\d+)\t(\d+)\t(\w+)?\t([\s\S]*?)[\n\r]+/g),
		dir = fsp.basename(file1),
		map1 = {}, map2 = {}, key, match, contents = "";

	if (!data1 || !data2)
		return;

	function makeCallback(map, file) {
		return function(chp, id, lan, text, stamp, lanori) {
			if (text === "===") return;
			if (map[lan + "/" + text] == null)
				map[lan + "/" + text] = {
					key: chp + "/" + id + "/" + lan,
					lanori: lanori
				};
			else
				contents += "duplicate text in " + file + " - " + chp + "/" + id + "/" + lan + ": " + text + "\n";
		};
	}

	function cmp(m1, m2, file) {
		Object.keys(m1).forEach(function(k) {
			var v1 = m1[k],
				v2 = m2[k];
			if (v2 == null)
				contents += "missing in " + file + " - " + k + ": " + v1.key + "\n";
			// else if (v1.lanori !== v2.lanori)
			// 	contents += "lanori diff " + file + " - " + k + ": " + v1.key + " ==> " + v1.lanori + "vs. " + v2.lanori + "\n";
		});
	}

	_parsePlainContents(data1, regex, makeCallback(map1, file1));
	_parsePlainContents(data2, regex, makeCallback(map2, file2));
	cmp(map1, map2, file2);
	cmp(map2, map1, file1);

	fs.writeFile(dest || fsp.join(fsp.dirname(file1), "messages-diff.txt"), contents, "utf8", _);
}

exports.compare = _compare;

/// ## MessageSet class
///   ```
///   var set = new MessageSet();
///   ```
///   Manage messages  
function MessageSet() {
	var col = {},
		_byKey = {},
		_map = {},
		_unbound = {},
		_tm = {},
		// _cursor = {
		// 	$maxId: 1999,
		// 	init: function(chp) {
		// 		this.$currentChapter = ~~chp;
		// 	}
		// 	next: function(chp) {
		// 		this.$currentChapter = this.$currentChapter + 1;
		// 		this.$chapter = this.$chapter || {};
		// 		var chapter = this.$chapter(this.$currentChapter);
		// 		chapter.$hwm = ~~chapter.$hwm + 1;
		// 	}
		// },
		_maxId = 1999;

	function _setText(chp, id, lan, text, defState, stamp, lanori) {
		var ek = _makeKey(chp, id),
			mk = _map[ek],
			entry = (mk && _byKey[mk]) || _unbound[ek] || (_unbound[ek] = {});

		if (!chp || !id || !lan) {
			throw new Error("Cannot set message. Invalid key " + ek + "/" + lan + " with '" + text + "'");
		}
		var chapter, tu, e, chunks, i, ii, oldText, tmu;
		if (!text)
			tracer && tracer("MessageSet._setText: null or empty text for " + ek + "/" + lan + " with '" + text + "'");

		if (Array.isArray(id)) {
			tracer && tracer("MessageSet._setText: array of id for " + ek + "/" + lan + " with '" + text + "'");
			if (!Array.isArray(text)) {
				throw new Error("Cannot set a message array with a single text. Array of text expected for " + ek + "/" + lan + " with '" + text + "'");
			}
			for (i = id[0], ii = 0; i <= id[1]; i++, ii++) {
				_setText(chp, i, lan, text[ii], defState, stamp, lanori);
			}
			return;
		}

		if (id > _maxId) {
			throw new Error("Cannot set a message with id > " + _maxId + " for " + _makeKey(chp, id) + "/" + lan + " with '" + text + "'");
		}

		col.$currentChapter = chp;
		chapter = col[chp] || (col[chp] = {});
		if (!chapter.$id) {
			chapter.$id = chp;
		}
		if (~~id > ~~chapter.$hwm) {
			chapter.$hwm = ~~id;
		}

		entry.$origin = entry.$origin || ek;
		entry.$meta = entry.$meta || {};
		tu = entry.text = entry.text || {};

		if (!chapter[id]) {
			chapter[id] = tu;
		}

		if (lan === "XXX") {
			if (entry.$key && entry.$key != text) {
				throw new Error("Cannot change text entry hash: " + ek + "/" + lan + " - " + JSON.stringify(entry));
			} else {
				entry.$key = text;
			}

			e = _byKey[text] || (_byKey[text] = []);
			e.push(entry);
			if (_unbound[ek]) delete _unbound[ek];
			_map[ek] = text;
		}
		oldText = tu[lan];
		tu[lan] = text;

		// else if (lan === defaultLanguage.x3 && !_tm[text]) {
		// tmu = _tm[text] = {
		// 	$text: text
		// };
		// Object.keys(tu).forEach(function(k){
		// 	if (k === "XXX" || k === lan) return;
		// 	tmu[k] = tu[k];
		// });
		// }
		// tmu = _tm[defaultLanguage.x3];
		// if (tmu && tmu[lan] == null) {
		// 	tmu[lan] = text;
		// }

		var meta = entry.$meta,
			m = meta[lan] || (meta[lan] = {});

		if (m.stamp == null && stamp)
			m.stamp = stamp;
		if (m.lanori == null && lanori != null) {
			m.lanori = lanori;
			// console.log("init lanori of entry: " + key + " => " + m.lanori + " (" + lanori + ")");
		}
		if (m.state == null) {
			m.state = defState || "created";
			if (m.lanori == null) {
				m.lanori = defaultLanguage.x3;
				// console.log("set lanori of new entry: " + ek + "/" + lan + " => " + m.lanori + " (" + lanori + ")");
			}
		} else if (text != oldText) {
			m.state = "modified";
			m.lanori = defaultLanguage.x3;
			// console.log("set lanori of modified entry: " + key + " => " + m.lanori + " (" + lanori + ")");
		}
		if (lan === defaultLanguage.x3) {
			// console.log("reset lanori to empty: " + ek + "/" + lan + " => " + m.lanori);
			m.lanori = "";
		}

		if (stamp > col.$lastUpdate) {
			col.$lastUpdate = stamp;
		}

		// tracer && tracer
		// console.log("_setText: ek=" + ek + ", tu=" + JSON.stringify(tu) + "\nunbound=" + JSON.stringify(_unbound[ek]));

	}

	function _chapter(chp) {
		return col[chp] || (col[chp] = {});
	}

	this.initChapter = function(chp1, chp2) {
		for (var i = chp1; i <= chp2; i++) {
			col[i] = col[i] || {};
		}
		if (this.$currentChapter === undefined) {
			this.$currentChapter = ~~chp1;
		}
	};

	this.init = function(chp, id, lan, text, stamp, lanori) {
		_setText(chp, id, lan, text, "clean", stamp, lanori);
	};

	this.setText = function(chp, id, lan, text, state, stamp, lanori) {
		_setText(chp, id, lan, text, state, stamp, lanori);
	};

	this.getText = function(chp, id, lan) {
		var text = col[chp] && col[chp][id] && col[chp][id][lan];
		return {
			text: text,
			$col: {
				data: col
			}
		};
	};

	this.reassembleText = function(entry, lang) {
		if (!entry)
			return;
		var chunks = [];
		lang = (typeof(lang === "object") && lang.x3) || lang || defaultLanguage.x3;
		chunks = entry.map(function(e) {
			return e.text[lang];
		});
		return reassembleStrings(chunks);
	};

	this.reassembleEntry = function(key) {
		var entry;
		if (typeof(key) === "string") {
			entry = this.getByKey(key);
		} else {
			entry = key;
			key = entry[0] && entry[0].$key;
		}
		var res = {
			$entry: entry
		};
		if (!entry || !key)
			return res;

		res = entry.reduce(function(res, e) {
			forEachKey(e.text, function(lang, t) {
				if (lang === "XXX") {
					res.$key = res.$key || t;
				} else {
					res.text = res.text || {};
					res.text[lang] = (res.text[lang] || "") + replaceTerminator(t);
				}
			});
			return res;
		}, res);

		tracer && tracer("[MessageSet.reassembleEntry] key=" + key + ", res='" + JSON.stringify(res, null, 2));
		return res;
	};

	this.getRefObj = function(chp, id) {
		var refText = this.getText(chp, id, "XXX").text,
			a = refText && refText.split(";") || [];
		return {
			key: a[0],
			seg: a[1],
			tick: a[2]
		};
	};

	this.getMeta = function(chp, id, lan) {
		// console.log("set.getMeta: " + chp + "/" + id + "/" + lan);

		var ek = _makeKey(chp, id),
			mk = _map[ek],
			e0 = _byKey[mk],
			e = e0 || [_unbound[ek]];

		// tracer && tracer("getMeta: ek=" + ek + ", mk=" + mk + ", e=" + JSON.stringify(e));
		if (!Array.isArray(id)) {
			return e && e[0] && e[0].$meta && e[0].$meta[lan] || {};
		}

		if (!e0) {
			var res = [];
			for (var i = id[0], ii = 0; i <= id[1]; i++, ii++) {
				res.push(this.getMeta(chp, i, lan));
			}
			return res;
		}
		return e && e.map(function(v) {
			return v.$meta && v.$meta[lan] || {};
		});
	};

	this.get = function(chp, id, lan) {
		var v = col;
		if (chp === undefined) return v;
		v = col && col[chp];
		if (id === undefined) return v;
		v = v && v[id];
		if (lan === undefined) return v;
		return v && v[lan] || "";
	};

	this.getByKey = function(key) {
		var v = _byKey[key];
		if (v && v.length > 1) {
			return v.sort(function(a, b) {
				var x = a.$origin.split("/")[1],
					y = b.$origin.split("/")[1];
				return (~~x) - (~~y);
			});
		}
		return v;
	};

	this.newEntries = function(key, count) {
		var wchp = col.$currentChapter,
			chapter = _chapter(wchp),
			wid = ~~chapter.$hwm,
			entries = [],
			e;

		if (wid + count > _maxId) {
			col.$currentChapter = ++wchp;
			chapter = _chapter(wchp);
			wid = ~~chapter.$hwm;
		}
		for (var i = 0; i < count; i++) {
			e = {
				$key: key,
				$origin: wchp + "/" + (++wid),
				$meta: {},
				text: {
					"XXX": key
				}
			};
			entries.push(e);
			chapter[wid] = e.text;
		}
		chapter.$hwm = wid;
		_byKey[key] = entries;
		return entries;
	};

	this.upsertMessage = function(message, language, refkey, opt) {
		var entries = this.getByKey(refkey),
			chunks = _splitMessage(message);
		if (!entries || entries.length === 0) {
			entries = this.newEntries(refkey, chunks.length);
		}
		opt = opt || {};
		// console.log("upsertMessage: chunks=" + chunks)
		// console.log("      1     entries=" + JSON.stringify(entries, null, "\t"));
		entries.forEach(function(e, i) {
			var m = e.$meta[language.x3] || (e.$meta[language.x3] = {});
			m.lanori = (language.x3 === defaultLanguage.x3) ? "" : defaultLanguage.x3;
			if (opt.sameForAll) {
				e.text[language.x3] = chunks[0];
			} else {
				e.text[language.x3] = chunks[i];
			}
			if (!e.text["XXX"]) {
				e.text["XXX"] = e.$key = refkey;
			} else if (e.text["XXX"] != refkey || e.$key != refkey) {
				throw new Error("Hash key mismatch: " + "XXX=" + e.text["XXX"] + ", $key=" + e.$key + ", refkey=" + refkey);
			}
			if (!e.$meta["XXX"]) {
				e.$meta["XXX"] = {
					lanori: "",
					state: "clean"
				};
			}
		});
		// console.log("  entries=" + JSON.stringify(entries, null, "\t"));
		return entries;
	};

	this.dup = function(chp, id, lan1, lan2) {
		var v = col[chp];
		if (!v) return;
		v = v[id];
		if (!v || v[lan1] == null) return;
		v[lan2] = v[lan1];
	};

	this.remove = function(chp, id, lan) {
		var v = col[chp];
		if (!v) return;
		v = v[id];
		if (!v || v[lan] == null) return;
		delete v[lan];
	};

	this.append = function(src, chp, id, ctx) {
		var minId = id,
			maxId = id,
			wchp = col.$currentChapter || chp,
			chapter = _chapter(wchp),
			wid = ~~chapter.$hwm + 1,
			self = this,
			tu, m, dist,
			newctx = helpers.object.clone(ctx, true);

		if (wid > _maxId) {
			col.$currentChapter = ~~ (col.$currentChapter || chp) + 1;
			wchp = col.$currentChapter;
			chapter = _chapter(wchp);
			wid = ~~chapter.$hwm + 1;
		}

		if (Array.isArray(id)) {
			dist = id[1] - id[0];
			if (wid + dist > _maxId) {
				col.$currentChapter = ++wchp;
				chapter = _chapter(wchp);
				wid = ~~chapter.$hwm + 1;
			}
			for (var i = id[0]; i <= id[1]; i++) {
				ctx = this.append(src, chp, i, ctx);
			}
			newctx.chp = col.$currentChapter;
			newctx.id = [wid, wid + dist];
			return newctx;
		}

		if (chp > ctx.$max) {
			console.error("Chapter overflow");
			newctx.$failed = true;
			return newctx;
		}
		tu = src.get(chp, id);
		if (tu == null || Object.keys(tu).length === 0)
			newctx.$deleted = true;
		else {
			forEachKey(tu, function(lan) {
				if (lan[0] === "$") return;
				m = src.getMeta(chp, id, lan);
				_setText(wchp, wid, lan, tu[lan], m.state, m.stamp, m.lanori);
			});
		}
		newctx.chp = wchp;
		newctx.id = wid;
		return newctx;
	};

	this.chapter = function(chp) {
		return col[chp];
	};

	this.getMessageByKey = function(key, lang) {
		var entry = this.getByKey(key),
			result = {
				$entry: entry,
				chunks: []
			};
		if (!entry)
			return result;

		lang = lang || defaultLanguage.x3;
		result.chunks = entry.map(function(e) {
			return e.text[lang];
		});
		result.message = reassembleStrings(result.chunks);

		tracer && tracer("[MessageSet.getMessageByKey] key=" + key, ", lang=" + lang + ", result='" + JSON.stringify(result, null, 2));
		return result;
	};

	this.sync = function() {
		var m,
			self = this,
			delta = new MessageSet(),
			toAssign = [],
			max = {
				$chp: 1
			}, parts, chp = 1;

		// forEachKey(_byKey, function(key, entry) {
		// 	if (entry.$origin == null) {
		// 		toAssign.push(entry);
		// 	} else {
		// 		parts = entry.$origin.split("/");
		// 		chp = ~~parts[0];
		// 		if (chp > max.$chp) max.$chp = chp;
		// 		max[chp] = Math.max(~~max[chp], ~~parts[1]);
		// 	}
		// });

		// toAssign.forEach(function(e){

		// });

		forEachKey(col, function(ck, chp) {
			if (ck[0] === "$") return;
			forEachKey(chp, function(ik, id) {
				if (ik[0] === "$") return;
				var e = self.getByKey(id["XXX"]);
				e = e && e.filter(function(e0) {
					return e0.$origin === (ck + "/" + ik);
				})[0];
				e && forEachKey(id, function(lk) {
					if (lk[0] === "$") return;
					var m = e.$meta[lk];
					m = m || {
						state: "clean"
					};
					if (m.state === "deleted") {
						delta.remove(ck, ik, lk);
					} else if (m.state != "clean") {
						delta.init(ck, ik, lk, m.stamp, m.lanori);
						m.state = "clean";
					}
				});
			});
		});
		return delta;
	};

	this.traverse = function(cb, opt, context) {
		var self = this;
		if (!cb)
			return;
		opt = opt || {};
		context = opt.context || {};

		var colkeys = Object.keys(col);
		if (opt.sort) {
			colkeys = colkeys.sort(numSort);
		}
		colkeys.forEach(function(k0) {
			if (k0[0] === "$") return;
			var chp = col[k0],
				chpkeys = chp && Object.keys(chp);
			context.$chp = chp;
			cb(context, k0);
			if (opt.sort && chp) {
				chpkeys = chpkeys.sort(numSort);
			}
			chpkeys.forEach(function(k1) {
				if (k1[0] === "$") return;
				var id = chp[k1],
					idkeys = id && Object.keys(id);
				context.$id = id;
				cb(context, k0, k1);
				if (opt.sort && id) {
					idkeys = idkeys.sort();
				}
				var e = self.getByKey(id["XXX"]),
					mk = _makeKey(k0, k1);

				e = e && e.filter(function(e0) {
					return e0.$origin === mk;
				})[0];
				if (!e) {
					e = _unbound[mk];
				}
				e && idkeys.forEach(function(k2) {
					if (k2[0] === "$") return;
					var meta = e.$meta[k2];
					if (!meta)
						console.error("traverse - no meta for " + e.$key + " " + k0 + "/" + k1 + "/" + k2 + ", text='" + id[k2] + "'");
					// console.log("traverse getMeta: " + k0 + "/" + k1 + "/" + k2 + "\n" + JSON.stringify(meta));
					cb(context, k0, k1, k2, id[k2], meta);
				});
			});
		});
	};

	this.dumpToPlainFile = function(_, file, opt) {
		opt = opt || {};
		var meta, txt = "",
			self = this,
			contents = opt.headerLine ? "Language\tChapter\tNumber\tOriginal_Language\tText\n" : "";
		tracer && tracer("[MessageSet.dumpToPlainFile] " + file);

		this.traverse(function(context, chp, id, lan, text, meta) {
			if (chp == null || id == null || lan == null)
				return;
			txt = normalizeString(text, true);
			// contents += lan + "\t" + chp + "\t" + id + '\t"' + txt + '"\n';
			var lanori = meta ? (meta.lanori == null ? "" : meta.lanori) : (lan === defaultLanguage.x3 ? "" : defaultLanguage.x3);
			contents += lan + "\t" + chp + "\t" + id + "\t" + lanori + '\t' + (opt.quoted ? _quoted(txt) : txt) + '\n';
			// txt += "[" + lan + ":" + chp + ":" + id + "] " + escapeSpecialChars(n[lan]) + "\n";
		}, {
			sort: true
		});

		fs.writeFile(file, contents, "utf8", _);
	};

}

function numSort(a, b) {
	return (~~a) - (~~b);
}

exports.MessageSet = MessageSet;

function fixSpecialChars(s) {
	return s. //
	replace(/\"\"/g, '"'). //
	replace(/\\ n/gi, '\n'). //
	replace(/\\/g, '');
}

function normalizeString(s, convertNewline) {
	if (Array.isArray(s)) {
		return reassembleStrings(s.map(function(t) {
			return normalizeString(t, convertNewline);
		}));
	}
	// replace spaces by a single utf-8 middle dot
	s = s && s.replace(/\s+$/g, "\u00b7") || "";
	return convertNewline ? s.replace(/\n/g, "\\n") : s;
}

function replaceTerminator(t) {
	return (t || "").replace(/((\s|\u00b7)*_\s*)$/, " ");
}

function reassembleStrings(a) {
	return a.reduce(function(res, t) {
		if (t == null) return res;
		return (res || "") + replaceTerminator(t);
	}, null);
}

function _quoted(s) {
	return '"' + s + '"';
}

exports.reassembleStrings = reassembleStrings;

exports.isEqualPlaceHolder = function(t) {
	return (/====*/).exec(t);
};

// function unescapeSpecialChars(s) {
// 	return s.replace(/\n/g, "\\n"). //
// 	replace(/\r/g, "\\r"). //
// 	replace(/\t/g, "\\t"). //
// 	replace(/\f/g, "\\f");
// }

// function escapeSpecialChars(s) {
// 	return s.replace(/\n/g, "\\n"). //
// 	replace(/\r/g, "\\r"). //
// 	replace(/\t/g, "\\t"). //
// 	replace(/\f/g, "\\f");
// }