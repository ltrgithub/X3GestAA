"use strict";

/// !doc
/// 
/// # Translation message storage providers
/// 

var fs = require('streamline-fs');
var fsp = require("path");
var sys = require("util");
var jsxml = require('js-xml');
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var localizedText = require("syracuse-translation/lib/helpers").localizedText;
var helpers = require('syracuse-core').helpers;
var locale = require('syracuse-core').locale;
var datetime = require('syracuse-core').types.datetime;
var uuid = require('syracuse-core').uuid;

var transCfg = config.translation || {};
var tracer = transCfg.trace;
var traceDiagnosis = transCfg.traceDiagnosis;

var isoDateFormat = exports.isoDateFormat = "yyyy-MM-ddTHH:mm:ssZ";
var tmxDateFormat = "yyyyMMddTHHmmssZ";
var fileDateFormat = "yyyy-MM-dd-HHmm";

var defaultLanguage = exports.defaultLanguage = {
	iso: "en-us",
	x3: locale.x3Language("en-us")
};
var aplStdMaxLength = exports.aplStdMaxLength = 123;
var placeholders = exports.placeholders = {
	equal: "===", // "=en-us=", "=-=", "=:="
	empty: "--" // "-", 
};

var _stringify = helpers.object.stringify;
var forEachKey = helpers.object.forEachKey;
var currentTime = process.hrtime;

function deltaTime(start) {
	var vals = process.hrtime(start);
	return (vals[0] * 1000) + Math.floor(vals[1] / 1000000);
}

function _getRefObj(refText) {
	var a = refText && refText.split(";") || [];
	return {
		key: a[0],
		seg: a[1],
		tick: a[2]
	};
}
exports.getRefObj = _getRefObj;

function _getMessageFileName(prefix, chapter) {
	return prefix + (chapter ? "_" + chapter.$min + "-" + chapter.$max : "") + ".txt";
}
exports.getMessageFileName = _getMessageFileName;

function _splitMessage(message, chunks) {
	var length = message.length;
	var beg = 0,
		end = aplStdMaxLength - 1;

	chunks = chunks || [];
	if (length <= aplStdMaxLength) {
		chunks.push(message);
		return chunks;
	}

	var substr = message.substring(beg, end);
	// tracer && tracer("substr " + substr);
	var pos = end - 1;
	while (pos > 0 && !(/\s/.exec(substr[pos]))) pos--;
	if (pos === 0 && (!(/\s/.exec(substr[pos])))) {
		pos = end - 1;
		tracer && tracer("Can not be splitted correctly. Long chunck without white spaces: " + message);
	}
	chunks.push(message.substring(beg, pos + 1) + "_");
	return _splitMessage(message.substring(pos + 1, length), chunks);
}

exports.splitMessage = _splitMessage;

function _makeKey(a, b, c) {
	if (Array.isArray(b)) b = b[0];
	return a + "/" + b + (c === undefined ? "" : "/" + c);
}

/// ## MessageStore class
///   Base class of any message store provider.  
///   **DO NOT INSTANCIATE.**  
function MessageStore(world, endpointRead, endpointWrite, options) {
	this.world = world || {};
	this.context = world.context || {};
	this.endpointRead = endpointRead;
	this.endpointWrite = endpointWrite;
	this.options = options || {};
	this.diagnosis = this.options.diagnosis;
	this.ignoreChecksum = this.options.ignoreChecksum;
	this.set = new MessageSet();
	this.currentCategory = null;
}

exports.MessageStore = helpers.defineClass(MessageStore, null, {
	_super: function() {
		return Object.getPrototypeOf(Object.getPrototypeOf(this));
	},
	/// * `store.init(_);`  
	///   Initialize the store.  
	init: function(_) {},
	/// * `store.reset(_, category);`  
	///   Switch to a new message category abd reset the internal message state.  
	reset: function(_, frame) {
		this.frame = frame;
		this.currentCategory = frame.category;
		this.set = new MessageSet();
	},

	getOrmRead: function(_) {
		return this.endpointRead.getOrm(_);
	},
	getOrmWrite: function(_) {
		return this.endpointWrite.getOrm(_);
	},

	getLastUpdate: function(_, chapter) {},

	get: function(_, chp1, chp2, lan, stamp, opt) {
		return this.set;
	},
	set: function(chp, id, lan, text) {
		return this._setText(chp, id, lan, text);
	},

	setToDefault: function(language, key) {
		this.upsertMessage(placeholders.equal, language, key, {
			sameForAll: true
		});
	},

	getFullSet: function() {
		return this.set;
	},
	getX3RecordSet: function(_, chapter, opt) {
		var chp1, chp2;
		if (typeof(chapter) === "object") {
			chp1 = chapter.$min;
			chp2 = chapter.$max;
		} else {
			chp1 = chp2 = chapter;
		}
		return this.get(_, chp1, chp2, "", "", opt);
	},
	getMessageByKey: function(key, lang) {
		return this.set.getMessageByKey(key, lang);
	},
	_initChapter: function(_, chp) {
		if (!this.fullyLoaded && !this.set.chapter(chp)) {
			this.getX3RecordSet(_, chp);
		}
	},
	_setText: function(chp, id, lan, text) {
		return this.set.setText(chp, id, lan, text);
	},

	_getText: function(chp, id, lan) {
		return this.set.getText(chp, id, lan);
	},

	createEntry: function(_, chp, id, message, language, refkey) {
		language = language || defaultLanguage;
		var x3Lang = language.x3,
			refObj, ref, t;

		if (Array.isArray(id)) {
			return this.diagnosis.fatal("Cannot create entry for array of ids: " + chp + id + x3Lang, null);
		}
		this._initChapter(_, chp);
		tracer && tracer("_createEntry endpoint=" + this.endpointWrite.dataset(_) + ", language=" + JSON.stringify(language) + ", key=" + chp + ":" + id + ', text="' + message + '"');
		t = this._getText(chp, id, x3Lang);

		// if (t.text && t.text !== message && t.text !== placeHolders.equal) {
		if (t.text && t.text !== message) {
			return this.diagnosis.fatal(localizedText("duplicateKey", chp, id, x3Lang), null);
		}

		this._setText(chp, id, x3Lang, message);

		refObj = this.set.getRefObj(chp, id);
		ref = refObj.key;
		if (!this.ignoreChecksum && ref && ref !== refkey) {
			return this.diagnosis.fatal(localizedText("checksumMismatch", "create", chp, id, x3Lang, JSON.stringify(refkey), JSON.stringify(ref)), null);
		} else if (!ref) {
			// tracer && tracer("ref=" + JSON.stringify(ref));
			this._setText(chp, id, "XXX", refkey);
		}
		return true;
	},
	updateEntry: function(_, chp, lannum, language, text, chunks, refkey) {
		language = language || defaultLanguage;
		var x3Lang = language.x3,
			start = Array.isArray(lannum) ? lannum[0] : lannum,
			refObj, ref, t;

		this._initChapter(_, chp);

		tracer && tracer("_updateEntry: language=" + JSON.stringify(language) + ", num=" + lannum + ' new value=' + text);

		var msg, i, id,
			newChunks = _splitMessage(text);
		if (newChunks.length > 1) {
			tracer && tracer("old chunks " + JSON.stringify(chunks, null, 2));
			tracer && tracer("new chunks " + JSON.stringify(newChunks, null, 2));
			if (newChunks.length > chunks.length) {
				tracer && tracer(localizedText("cannotExtend", chp, lannum, x3Lang));
				return this.diagnosis.error(localizedText("cannotExtend", chp, lannum, x3Lang));
			}
		}

		for (i = 0; i < newChunks.length; i++) {
			id = start + i;
			if (!this.ignoreChecksum) {
				refObj = this.set.getRefObj(chp, id);
				ref = refObj.key;
				if (ref && ref !== refkey) {
					return this.diagnosis.fatal(localizedText("checksumMismatch", "update", chp, i, x3Lang, JSON.stringify(refkey), JSON.stringify(ref)), null);
				}
			}
			t = this._getText(chp, id, x3Lang);
			this._setText(chp, id, x3Lang, newChunks[i]);
		}
	},

	dupEntry: function(chp, id, srcCulture, destCulture) {
		if (!srcCulture.x3 || destCulture.x3)
			return;
		if (!Array.isArray(id)) {
			id = [id, id];
		}
		for (var i = id[0]; i <= id[1]; i++) {
			this.set.dup(chp, i, srcCulture.x3, destCulture.x3);
		}
	},

	upsertMessage: function(message, language, refkey, opt) {
		return this.set.upsertMessage(message, language, refkey, opt);
	},

	ensureCulture: function(_, destCulture) {
		var tu;
		this.set.traverse(function(context, chp, id, lan, text, meta) {
			if (chp == null || id == null || lan != null)
				return;
			tu = context.$id;
			if (tu[destCulture.x3] == null)
				tu[destCulture.x3] = tu[defaultLanguage.x3];
		});
	},

	flush: function(_) {
		// this.set.autoFix();
		var delta = this.set.sync(),
			index = this.frame.index;
		if (this.options.renumber && index) {
			this.dumpToPlainFile(_, this.options.file + "-before");
			this.renumberFromIndex(index);
			this.dumpToPlainFile(_, this.options.file + "-after");
			_compare(_, this.getMessageFileName("-before"), //
				this.getMessageFileName("-after"), //
				this.getMessageFileName("-diff"));
			if (!this.options.noDBFlush) {
				this.diagnosis.logInfo("Delete messages from " + index.$config.$chapter.$min + " to " + index.$config.$chapter.$max);
				this.deleteAll(_, index.$config.$chapter.$min, index.$config.$chapter.$max);
			}
		}
		// tracer && tracer("[MessageStore.flush] delta=" + _stringify(delta));
		this.dumpToPlainFile(_, this.options.file + "-delta", delta);

		this.dumpToPlainFile(_, this.options.file);
		// this.dumpToTmxFile(_);

		if (!this.options.noDBFlush)
			this.updateAll(_);
	},

	getMessageFileName: function(suffix) {
		return _getMessageFileName(this.options.file + suffix, this.currentCategory);
	},

	load: function(data) {
		var fetched = this.set.load(data);
		this.diagnosis.logInfo("Load from data fetch " + fetched + " records");
		return fetched;
	},

	initFromIndex: function(index) {
		var mset = this.set,
			x3Lang;
		forEachKey(index, function(gk, gv) {
			if (gk[0] === "$") return;
			forEachKey(gv, function(mk, mv) {
				if (mk[0] === "$") return;
				mset.init(mv.chp, mv.id, "XXX", mv.$key);
				forEachKey(mv.text, function(tk, tv) {
					x3Lang = locale.x3Language(tk, true);
					mset.init(mv.chp, mv.id, x3Lang, tv);
				});
			});
		});
		this.fullyLoaded = true;
		return mset;
	},
	dumpToPlainFile: function(_, filePrefix, set, opt) {
		var messagesFile = _getMessageFileName(filePrefix, this.currentCategory);
		if (set === undefined) {
			set = this.set;
		}
		tracer && tracer("[MessageStore.dumpToPlainFile] " + messagesFile);
		set && set.dumpToPlainFile(_, messagesFile, opt);
	},
	dumpToTmxFile: function(_) {
		var index = this.frame.index || {},
			conf = index.$config || {},
			chapter = conf.$chapter, //this.currentCategory,
			messagesFile = this.options.file + "_" + chapter.$name + ".tmx",
			c, n, e,
			x = {
				tmx: {
					$: {
						version: "1.4"
					},
					header: {
						$: {
							creationtool: "SyracuseTranslationTool",
							creationtoolversion: "1.00",
							datatype: "PlainText",
							segtype: "sentence",
							adminlang: "en-us",
							srclang: "en",
							"o-tmf": "ABCTransMem",
							creationdate: (conf.$createDate && datetime.parse(conf.$createDate) || datetime.now()).toString(tmxDateFormat),
							// creationid: (conf.$source || {}).user,
							changedate: (conf.$lastModified && datetime.parse(conf.$lastModified) || datetime.now()).toString(tmxDateFormat),
							changeid: ((conf.$source || {}).user || {}).login || ""
						},
						note: {
							$value: chapter.$description || ""
						}

					},
					body: {
						tu: []
					}
				}
			},
			tus = x.tmx.body.tu,
			tu,
			tuv,
			tuvs;

		tracer && tracer("[MessageStore.dumpToTmxFile] " + messagesFile);

		forEachKey(index, function(gk, gv) {
			if (gk[0] === "$") return;
			forEachKey(gv, function(mk, mv) {
				if (mk[0] === "$") return;
				tu = {
					$: {
						tuid: gk + "/" + mk,
						datatype: "Text"
					},
					prop: {
						$: {
							type: "x-id"
						},
						$value: mv.chp + ":" + mv.id
					},
					tuv: []
				};
				tus.push(tu);
				tuvs = tu.tuv;
				forEachKey(mv.text, function(tk, tv) {
					tuv = {
						$: {
							"xml:lang": tk
						},
						seg: {
							$value: normalizeString(tv)
						}
					};
					tuvs.push(tuv);
				});
			});
		});

		fs.writeFile(messagesFile, '<?xml version="1.0"?>\n' + jsxml.stringify(x, "\t"), "utf8", _);
	},

	renumberFromIndex: function(index) {
		var diagnosis = this.diagnosis,
			mset1 = this.set,
			mset2 = new MessageSet(),
			$chapter = index.$chapter || index.$config.$chapter,
			x3Lang,
			tu,
			ctx = {
				$min: $chapter.$min,
				$max: $chapter.$max,
				chp: $chapter.$min,
				id: 1
			},
			count = 0,
			visited = {};

		function _visited(chp, id, gk, mk) {
			if (Array.isArray(id)) {
				for (var i = id[0]; i <= id[1]; i++) {
					_visited(chp, i, gk, mk);
				}
				return;
			}

			if (visited[_makeKey(chp, id)]) {
				diagnosis.logWarning("Already exist: " + gk + "/" + mk + " ==> " + _makeKey(chp, id));
			} else {
				visited[_makeKey(chp, id)] = gk + "/" + mk;
			}
		}

		$chapter.$count = 0;
		$chapter.$current = $chapter.$min;
		$chapter.$ = {};
		forEachKey(index, function(gk, gv) {
			if (gk[0] === "$") return;
			forEachKey(gv, function(mk, mv) {
				if (mk[0] === "$" || ctx.$failed || ctx.chp > $chapter.$max) return;
				if (mv.id[0] === "$") return;
				_visited(mv.chp, mv.id, gk, mk);
				ctx = mset2.append(mset1, mv.chp, mv.id, ctx);
				if (!ctx.$failed) {
					mv.chp = ctx.chp;
					mv.id = ctx.id;
					if (ctx.$deleted) {
						diagnosis.logInfo("Deleting key in index: " + gk + "/" + mk);
						delete gv[mk];
						delete ctx.$deleted;
					} else {
						count += Array.isArray(mv.id) ? mv.id[1] - mv.id[0] + 1 : 1;
						$chapter.$current = ctx.chp;
						$chapter.$[ctx.chp] = $chapter.$[ctx.chp] || {};
						$chapter.$[ctx.chp].$nextId = (ctx.id[1] || ctx.id) + 1;
					}
				}
			});
		});
		$chapter.$count = Object.keys($chapter.$).reduce(function(res, k) {
			return res + $chapter.$[k].$nextId - 1;
		}, 0);
		diagnosis.logInfo("Renumber count=" + count + ", $count=" + $chapter.$count);
		this.set = mset2;
	},
	updateAll: function(_) {},
	deleteAll: function(_, chp1, chp2, lan, stamp) {}
});

/// ## FileMessageStore class
///   ```
///   var store = new FileMessageStore(world, endpointRead, endpointWrite, options);
///   store.init(_);
///   ```
function FileMessageStore(world, endpointRead, endpointWrite, options) {
	this._super().constructor(world, endpointRead, endpointWrite, options);
}

exports.FileMessageStore = helpers.defineClass(FileMessageStore, MessageStore, {
	init: function(_) {
		MessageStore.prototype.init.call(this, _);
	},
	getLastUpdate: function(_, chapter) {
		return "";
	},
	_getRecords: function(_, chapter, opt) {
		return [];
	},

	getX3RecordSet: function(_, chapter, opt) {
		opt = opt || {};
		var x3RecordSet = opt.set || this.set,
			options = this.options,
			file = _getMessageFileName(opt.file || options.file, this.currentCategory),
			fetched = 0,
			txt = "",
			data = fs.exists(file, _) && fs.readFile(file, "utf8", _),
			match,
			// chp, grp, 
			lines, regex,
			lastUpdate = "";

		if (opt.quoted)
			regex = /(\w+)\t(\d+)\t(\d+)\t"([\s\S]*?)"[\n\r]+/g;
		else
			regex = /(\w+)\t(\d+)\t(\d+)\t([\s\S]*?)[\n\r]+/g;

		fetched = x3RecordSet.loadFromCsv(data, regex);

		tracer && tracer("loadFromFile count=" + fetched);
		this.diagnosis.info(localizedText("fetchRecords", fetched));
		return x3RecordSet;
	},
});

/// ## X3ClobMessageStore class
///   ```
///   var store = new X3ClobMessageStore(world, endpointRead, endpointWrite, options);
///   store.init(_);
///   ```
var _clobRep = transCfg.clobRepresentation || "ATRANS";
var _regexMessage = /(\w+)\t(\d+)\t(\d+)\t(\w*)\t([\d\-T:Z]*)\t([\s\S]*?)[\n\r]+/g;
var _regexMessageWithoutStamp = /(\w+)\t(\d+)\t(\d+)\t(\w+)?\t([\s\S]*?)[\n\r]+/g;

function X3ClobMessageStore(world, endpointRead, endpointWrite, options) {
	this._super().constructor(world, endpointRead, endpointWrite, options);
}

exports.X3ClobMessageStore = helpers.defineClass(X3ClobMessageStore, MessageStore, {
	init: function(_) {
		var self = this;

		function endpointIO(_, ep) {
			var epPath = ep.application(_) + "/" + ep.contract(_) + "/" + ep.dataset(_);

			function _cdoc(chp1, chp2, lan, stamp) {
				var key = ["C_" + _clobRep, "CONTENTS", chp1 || "", (chp2 || chp1 || ""), (lan || ""), stamp || ""].join("~%C2%A8~");
				return "CDOC('" + key + "')";
			}

			function _cdoc2(id) {
				return ["$workingCopies('" + id + "')", _clobRep, "CONTENTS"].join("/");
			}

			function _submit(_, url, body, opt) {
				opt = opt || {};
				url = ["/sdata", epPath, url].join("/");
				var params = {
					head: {
						"accept": "application/json;vnd.sage=syracuse; charset=utf-8",
						"accept-language": opt.acceptLanguage || locale.current || "en-us",
						"method": opt.method || "GET",
						"url": url
					},
					body: body || {}
				};
				if (opt.method === "PUT" || opt.method === "POST") {
					params.head["content-type"] = opt.contentType || "application/json;vnd.sage=syracuse; charset=utf-8";
					params.head["content-length"] = !body ? 0 : (typeof(body) === "string" ? body.length : JSON.stringify(body).length);
				}
				if (opt.debug) {
					params.head["pragma"] = "debug-immediate";
				}
				return self.world.submit(_, ep, params);
			}

			function _fetchInstances(_, entityName, facet, opt) {
				return self.world.fetchInstances(_, ep, entityName, facet, opt);
			}
			return {
				endpoint: ep,
				cdoc: _cdoc,
				cdoc2: _cdoc2,
				submit: _submit,
				fetchInstances: _fetchInstances
			};
		}

		MessageStore.prototype.init.call(this, _);

		this.reader = endpointIO(_, this.endpointRead);
		this.writer = endpointIO(_, this.endpointWrite);
	},
	getLastUpdate: function(_, chapter) {
		return "";
	},
	_getRecords: function(_, chapter, opt) {
		return [];
	},

	get: function(_, chp1, chp2, lan, stamp, opt) {
		opt = opt || {};
		var x3RecordSet = opt.set || this.set,
			fetched = 0,
			reader = opt.reader || this.reader;

		var reply = reader.submit(_, reader.cdoc(chp1, chp2, lan, stamp));
		x3RecordSet.initChapter(chp1, chp2);
		fetched = x3RecordSet.loadFromCsv(reply && reply.body, _regexMessage);
		this.diagnosis.info(localizedText("fetchRecords", fetched));
		return x3RecordSet;
	},

	getMeta: function(chp, id, lan) {
		return this.set.getMeta(chp, id, lan);
	},

	updateAll: function(_) {
		var self = this,
			ep = this.endpointWrite,
			writer = this.writer,
			chp1;

		function replyInError(reply) {
			var errors;
			if (reply && reply.body) {
				if (typeof(reply.body) === "string" && reply.body.charAt(0) === "{")
					r = JSON.parse(reply.body);
				else {
					r = reply.body;
				}
				if (r && r.$diagnoses) {
					self.diagnosis.addAll(r.$diagnoses);
					errors = r.$diagnoses.filter(function(d) {
						return d.$severity === "error";
					}) || [];
					if (errors.length > 0) {
						self.diagnosis.logError(JSON.stringify(errors));
						return true;
					}
				}
			}
			return false;
		}

		if (!ep) {
			this.diagnosis.fatal("no endpoint", null);
			return;
		}
		var id = uuid.generate(),
			data = "",
			url, r;

		this.set.traverse(function(context, chp, id, lan, text, meta) {
			var lanori = meta && meta.lanori || "";
			if (chp == null || id == null || lan == null)
				return;
			chp1 = chp1 || chp;
			if (!lan || !chp || !id) {
				console.error("updateAll: bad key: " + _makeKey(lan, chp, id));
				return;
			}

			data += utils.formatLine(chp, id, lan, text, lanori) + "\n";
		});

		url = _clobRep + "('" + chp1 + "~~')/$workingCopies?representation=" + _clobRep + ".$edit&trackingId=" + id;
		this.diagnosis.logInfo("Creating workingCopie: " + url);
		var reply = writer.submit(_, url, "", {
			contentType: "text/plain;charset=utf-8",
			method: "POST"
		});
		if (replyInError(reply))
			return;
		// tracer && tracer("\n>>>>\n" + reply.body);

		url = writer.cdoc2(id);
		this.diagnosis.logInfo("Updating workingCopie: " + url + "\n" + data);
		reply = writer.submit(_, url, data, {
			contentType: "text/plain;charset=utf-8",
			method: "PUT"
		});
		if (replyInError(reply))
			return;
		// tracer && tracer("\n>>>>\n" + reply.body);

		this.diagnosis.logInfo("Saving workingCopie");
		url = "$workingCopies('" + id + "')?representation=" + _clobRep + ".$edit";
		reply = writer.submit(_, url, {
			"CHP1": chp1,
			"$actions": {
				"$save": {
					"$isRequested": true
				}
			}
		}, {
			method: "PUT",
		});
		if (replyInError(reply))
			return;
		this.diagnosis.logInfo("Reply:\n" + reply.body);
		// tracer && tracer("\n>>>>\n" + reply.body);
	},
	deleteAll: function(_, chp1, chp2, lan, stamp) {
		var ep = this.endpointWrite,
			writer = this.writer,
			url, r;
		chp2 = chp2 || "";

		if (!ep) {
			this.diagnosis.fatal("no endpoint", null);
			return;
		}

		//http://localhost:8124/sdata/x3/erp/SUPERV/ATRANS('10043~~')?representation=ATRANS.$details
		tracer && tracer("[X3ClobMessageStore.deleteAll]");
		url = _clobRep + "('" + chp1 + "~" + chp2 + "~')?representation=" + _clobRep + ".$details";
		var reply = writer.submit(_, url, "", {
			contentType: "text/plain;charset=utf-8",
			method: "DELETE"
		});
		if (reply && reply.body) {
			if (typeof(reply.body) === "string" && reply.body.charAt(0) === "{")
				r = JSON.parse(reply.body);
			else {
				r = reply.body;
			}
			if (r && r.$diagnoses)
				this.diagnosis.addAll(r.$diagnoses);
		}
	},

	smartCopy: function(_, chp1, chp2) {
		var exclude = ["3B6CB5EC760BBCF44243B5DFFCE2B9AFB0D833FA", "28AF008953B78BD7AA50ADBD7404A80A8B9DEB2D", "26085D305C8A6A1554DA5D481FE616B28D25C32E"];
		chp2 = chp2 || chp1;
		var inputFile = this.options.targetDir + "/output/messages-smart-input.txt";
		var outputFile = this.options.targetDir + "/output/messages-smart-" + chp1 + "-" + chp2 + "-" + (datetime.now().toString(fileDateFormat));
		var data = fs.exists(inputFile, _) && fs.readFile(inputFile, "utf8", _);

		var set2 = new MessageSet(),
			m, mt,
			tu1, tu2, e1, e2, t1, t2, c1, c2, origin, meta1, meta2;

		if (data) {
			console.error("WARNING: loading data from " + inputFile);
			this.load(data);
		} else {
			this.get(_, chp1, chp2, null, null, null);
		}
		this.get(_, chp1, chp2, null, null, {
			set: set2,
			reader: this.writer
		});

		set2.traverseKeys(function(key, entry) {
			if (exclude.indexOf(key) !== -1)
				return;

			entry.forEach(function(e, i) {
				tu2 = e.text || [];
				t2 = _cleanString(tu2["ENG"]);
				var tmu = dictionary.getEntry(t2),
					mtl;
				if (tmu) {
					Object.keys(tu2).forEach(function(l) {
						if (l === "XXX")
							return;
						mtl = tmu.getText(l);
						if (mtl != null) {
							meta2 = e.$meta || (e.$meta = {});
							meta2 = meta2[l] || (meta2[l] = {});
							if (mtl !== tu2[l]) {
								meta2.lanori = "";
								tu2[l] = mtl;
								// console.error("smartCopy from memory '" + m.$key + "' [" + l + "]" + "\n--- '" + tu2[l] + "'\n+++ '" + t1 + "'");
							}
						}
					});
				}
			});
		});

		this.set.traverseKeys(function(key, entry) {
			if (exclude.indexOf(key) !== -1)
				return;

			entry.forEach(function(e, i) {
				tu1 = e.text || [];
				// t1 = tu1["ENG"];
				e2 = set2.getByKey(e.$key);
				if (e2) {
					e2 = e2[i] || {};
					tu2 = e2.text || [];
					// t2 = tu2["ENG"];
					Object.keys(tu1).forEach(function(l) {
						if (l === "XXX")
							return;
						t1 = _cleanString(tu1[l]);
						if (t1 !== tu2[l]) {
							meta1 = e.$meta[l] || {
								lanori: ""
							};
							meta2 = e2.$meta || (e2.$meta = {});
							meta2 = meta2[l] || (meta2[l] = {});
							meta2.lanori = meta1.lanori || "";
							tu2[l] = tu1[l];
						}
					});
				}
				// if (t1 != t2 && t2 !== undefined) {
				// 	c1 = t1 && (t1.match(/\{\w+\}/g) || []).length;
				// 	c2 = t2 && (t2.match(/\{\w+\}/g) || []).length;
				// 	if (c1 !== c2) {
				// 		console.error("smartCopy: key(" + i + ")=" + key + ", ENG(1)=" + t1 + ", ENG(2)=" + t2);
				// 	}
				// }
			});
		});

		var delta = set2.sync();
		this.dumpToPlainFile(_, outputFile + "-delta", delta);
		this.dumpToPlainFile(_, outputFile, set2);
		// this.set.traverse(function(context, chp, id, lan, text, meta) {
		// 	if (chp == null || id == null || lan != null)
		// 		return;
		// 	tu1 = context.$id;
		// 	e1 = context.$entry;
		// 	e2 = set2.getByKey(e1.$key);
		// 	tu2 = set2.getByKey()
		// });
	}
});

function _parsePlainContents(data, regex, cb, opt) {
	if (!data) return;
	opt = opt || {};
	var txt = "",
		match,
		itxt,
		fixit = opt.fixChars || fixSpecialChars;

	if (typeof(regex) === "function") {
		cb = regex;
		opt = cb;
		regex = _regexMessage;
	} else {
		regex = regex || _regexMessage;
	}
	while ((match = regex.exec(data)) != null) {
		itxt = match.length - 1;
		txt = fixit((match[itxt] || "").replace(/\u00b7/g, " ").replace(/\\n/g, '\n'));
		txt = _fixBraces(txt);
		cb && cb(match[2], match[3], match[1], txt, (itxt > 5) ? match[itxt - 1] : null, (itxt > 5) ? match[itxt - 2] : match[itxt - 1]);
	}
}

function _compare(_, file1, file2, dest) {
	var data1 = fs.exists(file1, _) && fs.readFile(file1, "utf8", _),
		data2 = fs.exists(file2, _) && fs.readFile(file2, "utf8", _),
		// regex = new RegExp(/(\w+)\t(\d+)\t(\d+)\t(\w+)?\t"([\s\S]*?)"[\n\r]+/g),
		regex = new RegExp(/(\w+)\t(\d+)\t(\d+)\t(\w+)?\t([\s\S]*?)[\n\r]+/g),
		dir = fsp.basename(file1),
		map1 = {},
		map2 = {},
		key, match, contents = "";

	if (!data1 || !data2)
		return;

	function makeCallback(map, file) {
		return function(chp, id, lan, text, stamp, lanori) {
			if (text === "===") return;
			if (map[lan + "/" + text] == null)
				map[lan + "/" + text] = {
					key: chp + "/" + id + "/" + lan,
					lanori: lanori
				};
			else
				contents += "duplicate text in " + file + " - " + chp + "/" + id + "/" + lan + ": " + text + "\n";
		};
	}

	function cmp(m1, m2, file) {
		Object.keys(m1).forEach(function(k) {
			var v1 = m1[k],
				v2 = m2[k];
			if (v2 == null)
				contents += "missing in " + file + " - " + k + ": " + v1.key + "\n";
			// else if (v1.lanori !== v2.lanori)
			// 	contents += "lanori diff " + file + " - " + k + ": " + v1.key + " ==> " + v1.lanori + "vs. " + v2.lanori + "\n";
		});
	}

	_parsePlainContents(data1, regex, makeCallback(map1, file1));
	_parsePlainContents(data2, regex, makeCallback(map2, file2));
	cmp(map1, map2, file2);
	cmp(map2, map1, file1);

	fs.writeFile(dest || fsp.join(fsp.dirname(file1), "messages-diff.txt"), contents, "utf8", _);
}

exports.compare = _compare;

/// ## MessageSet class
///   ```
///   var set = new MessageSet();
///   ```
///   Manage messages  
function MessageSet() {
	var that = this,
		col = {},
		_byKey = {},
		_map = {},
		_unbound = {},
		// _cursor = {
		// 	$maxId: 1999,
		// 	init: function(chp) {
		// 		this.$currentChapter = ~~chp;
		// 	}
		// 	next: function(chp) {
		// 		this.$currentChapter = this.$currentChapter + 1;
		// 		this.$chapter = this.$chapter || {};
		// 		var chapter = this.$chapter(this.$currentChapter);
		// 		chapter.$hwm = ~~chapter.$hwm + 1;
		// 	}
		// },
		_maxId = 1999;

	function _getEntryItem(ek) {
		var mk = _map[ek];
		var entry = mk && _byKey[mk];
		if (entry) {
			var a = (entry || []),
				len = a.length;
			for (var i = 0; i < len; i++) {
				if (a[i].$origin === ek)
					return a[i];
			}
			var item = {
				$origin: ek
			};
			entry.push(item);
			return item;
		}
		return _unbound[ek] || (_unbound[ek] = {});
	}

	function _setText(chp, id, lan, text, defState, stamp, lanori) {
		var ek = _makeKey(chp, id),
			entry = _getEntryItem(ek);

		if (!~~chp || !~~id || !lan) {
			throw new Error("Cannot set message. Invalid key " + ek + "/" + lan + " with '" + text + "'");
		}

		var chapter, tu, e, chunks, i, ii, originalText = text,
			oldText;
		text = _cleanString(text);
		if (!text)
			tracer && tracer("MessageSet._setText: null or empty text for " + ek + "/" + lan + " with '" + text + "'");

		if (Array.isArray(id)) {
			tracer && tracer("MessageSet._setText: array of id for " + ek + "/" + lan + " with '" + text + "'");
			if (!Array.isArray(text)) {
				throw new Error("Cannot set a message array with a single text. Array of text expected for " + ek + "/" + lan + " with '" + text + "'");
			}
			for (i = id[0], ii = 0; i <= id[1]; i++, ii++) {
				_setText(chp, i, lan, text[ii], defState, stamp, lanori);
			}
			return;
		}

		if (id > _maxId) {
			throw new Error("Cannot set a message with id > " + _maxId + " for " + _makeKey(chp, id) + "/" + lan + " with '" + text + "'");
		}

		col.$currentChapter = chp;
		chapter = col[chp] || (col[chp] = {});
		if (!chapter.$id) {
			chapter.$id = chp;
		}
		if (~~id > ~~chapter.$hwm) {
			chapter.$hwm = ~~id;
		}

		entry.$origin = entry.$origin || ek;
		entry.$meta = entry.$meta || {};
		tu = entry.text || (entry.text = {});

		if (!chapter[id]) {
			chapter[id] = tu;
		}

		if (lan === "XXX") {
			if (entry.$key && entry.$key != text) {
				throw new Error("Cannot change text entry hash: " + ek + "/" + lan + " - " + JSON.stringify(entry));
			} else {
				entry.$key = text;
			}

			e = _byKey[text] || (_byKey[text] = []);
			if (_unbound[ek]) {
				e.push(entry);
				delete _unbound[ek];
			}
			_map[ek] = text;
		}
		oldText = tu[lan];
		tu[lan] = text;

		var mkey = tu[defaultLanguage.x3];
		// create translation memory to auto translate
		if (lan === defaultLanguage.x3) {
			Object.keys(tu).forEach(function(l) {
				if (l === "XXX" && l === defaultLanguage.x3)
					return;
				dictionary.smartAssign(mkey, l, tu[l], ek);
			});
		} else if (mkey && lan !== "XXX") {
			dictionary.smartAssign(mkey, lan, text, ek);
		}

		var meta = entry.$meta,
			m = meta[lan] || (meta[lan] = {});

		if (m.stamp == null && stamp)
			m.stamp = stamp;
		if (m.lanori == null && lanori != null) {
			m.lanori = lanori;
			// console.log("init lanori of entry: " + key + " => " + m.lanori + " (" + lanori + ")");
		}
		if (m.state == null) {
			m.state = originalText !== text ? "modified" : defState || "created";
			if (m.lanori == null) {
				m.lanori = defaultLanguage.x3;
				// console.error("_setText set lanori of new entry: " + mkey + ";" + ek + "/" + lan + " => " + m.lanori + " (" + lanori + ")");
			}
		} else if (text != oldText) {
			m.state = "modified";
			m.lanori = defaultLanguage.x3;
			// console.error("_setText: set lanori of modified entry: " + mkey + ";" + ek + "/" + lan + " => " + m.lanori + " (" + lanori + ") oldText=" + oldText + ", text=" + text);
		}
		if (lan === defaultLanguage.x3) {
			// console.log("_setText: reset lanori to empty: " + mkey + ";" + ek + "/" + lan + " => " + m.lanori);
			m.lanori = "";
		}
		if (stamp > col.$lastUpdate) {
			col.$lastUpdate = stamp;
		}

	}

	function _chapter(chp) {
		return col[chp] || (col[chp] = {});
	}

	this.loadFromCsv = function(data, regex) {
		var fetched = 0;
		var self = this;

		function callback(chp, id, lan, text, stamp, lanori) {
			self.init(chp, id, lan, text, stamp, lanori || "");
			fetched++;
		}

		_parsePlainContents(data, regex, callback, {
			fixChars: (transCfg.fix || {}).read
		});
		tracer && tracer("loadFromCsv count=" + fetched);
		that.$count = fetched;
		return fetched;
	};


	this.load = function(data) {
		var fetched = this.loadFromCsv(data, _regexMessage);
		if (fetched === 0) {
			fetched = this.loadFromCsv(data, _regexMessageWithoutStamp);
		}
		return fetched;
	};

	this.initChapter = function(chp1, chp2) {
		for (var i = chp1; i <= chp2; i++) {
			col[i] = col[i] || {};
		}
		if (col.$currentChapter === undefined) {
			col.$currentChapter = ~~chp1;
		}
	};

	this.init = function(chp, id, lan, text, stamp, lanori) {
		_setText(chp, id, lan, text, "clean", stamp, lanori);
	};

	this.setText = function(chp, id, lan, text, state, stamp, lanori) {
		_setText(chp, id, lan, text, state, stamp, lanori);
	};

	this.getText = function(chp, id, lan) {
		var text = col[chp] && col[chp][id] && col[chp][id][lan];
		return {
			text: text,
			$col: {
				data: col
			}
		};
	};

	this.autoFix = function(cb) {
		var tu, tref, tmu, mtl, meta;

		function _fix(entry, lan, tu, proposal) {
			if (lan == null) return;
			meta = entry.$meta || (entry.$meta = {});
			meta = meta[lan] || (meta[lan] = {});
			meta.lanori = "";
			meta.state = "modified";
			console.error("autoSet '" + meta.$key + "' [" + lan + "]" + "\n--- '" + tu[lan] + "'\n+++ '" + proposal + "'");
			tu[lan] = proposal;
		}

		cb = cb || _fix;
		this.traverseKeys(function(key, entry) {
			// if (exclude.indexOf(key) !== -1)
			// 	return;

			entry.forEach(function(e, i) {
				tu = e.text || [];
				tref = _cleanString(tu[defaultLanguage.x3]);
				var tmu = dictionary.getEntry(tref),
					mtl;
				if (tmu) {
					Object.keys(tu).forEach(function(l) {
						if (l === "XXX" || l === defaultLanguage.x3)
							return;
						mtl = tmu.getText(l);
						if (mtl != null) {
							if (mtl !== tu[l] && mtl !== tref) {
								cb(e, l, tu, mtl);
							}
						}
					});
					cb(e, null, tu, mtl);
				}
			});
		});
	};

	this.fixUntranslated = function(_, lang) {
		if (!lang) return;
		this.traverse(function(context, chp, id, lan) {
			if (chp == null || id == null || lan != null)
				return;
			var tu = context.$id;
			var e = context.$entry;
			var meta = e.$meta[lang] || (e.$meta[lang] = {});
			if (!meta.lanori && tu[lang] != null && (tu[lang] === tu[defaultLanguage.x3] || exports.isEqualPlaceHolder(tu[lang]))) {
				meta.lanori = defaultLanguage.x3;
				meta.state = "modified";
				console.error("Fixing " + _makeKey(lang, chp, id) + ": " + tu[lang]);
			}
		});
	};


	this.reassembleText = function(entry, lang) {
		if (!entry)
			return;
		var chunks = [];
		lang = (typeof(lang === "object") && lang.x3) || lang || defaultLanguage.x3;
		chunks = entry.map(function(e) {
			return e.text[lang];
		});
		return reassembleStrings(chunks);
	};

	this.reassembleEntry = function(key) {
		var entry;
		if (typeof(key) === "string") {
			entry = this.getByKey(key);
		} else if (key && typeof(key) == "object") {
			entry = key;
			key = entry[0] && entry[0].$key;
		}
		var res = {
			$entry: entry
		};
		if (!entry || !key)
			return res;

		res = entry.reduce(function(res, e) {
			forEachKey(e.text, function(lang, t) {
				var key = e.text[defaultLanguage.x3],
					tmu = dictionary.getEntry(key),
					mt = tmu && tmu.getText(lang);

				if (lang === "XXX") {
					res.$key = res.$key || t;
				} else {
					// if (mt && (!t || t === key) && mt !== t) {
					// 	// console.error("reassembleEntry change t=" + t + " to mt=" + mt + ",tmu=\n" + JSON.stringify(tmu, null, 2) + "");
					// 	t = mt;
					// }
					res.text = res.text || {};
					res.text[lang] = _appendChunk(res.text[lang], t);
				}
			});
			return res;
		}, res);

		tracer && tracer("[MessageSet.reassembleEntry] key=" + key + ", res='" + JSON.stringify(res, null, 2));
		return res;
	};

	this.getRefObj = function(chp, id) {
		var refText = this.getText(chp, id, "XXX").text,
			a = refText && refText.split(";") || [];
		return {
			key: a[0],
			seg: a[1],
			tick: a[2]
		};
	};

	this.getMeta = function(chp, id, lan) {
		// console.log("set.getMeta: " + chp + "/" + id + "/" + lan);

		var ek = _makeKey(chp, id),
			mk = _map[ek],
			e0 = _byKey[mk],
			e = e0 || [_unbound[ek]];

		// tracer && tracer("getMeta: ek=" + ek + ", mk=" + mk + ", e=" + JSON.stringify(e));
		if (!Array.isArray(id)) {
			return e && e[0] && e[0].$meta && e[0].$meta[lan] || {};
		}

		if (!e0) {
			var res = [];
			for (var i = id[0], ii = 0; i <= id[1]; i++, ii++) {
				res.push(this.getMeta(chp, i, lan));
			}
			return res;
		}
		return e && e.map(function(v) {
			return v.$meta && v.$meta[lan] || {};
		});
	};

	this.get = function(chp, id, lan) {
		var v = col;
		if (chp === undefined) return v;
		v = col && col[chp];
		if (id === undefined) return v;
		v = v && v[id];
		if (lan === undefined) return v;
		return v && v[lan] || "";
	};

	this.getByKey = function(key) {
		var v = _byKey[key];
		if (v && v.length > 1) {
			return v.sort(function(a, b) {
				var x = a.$origin.split("/")[1],
					y = b.$origin.split("/")[1];
				return (~~x) - (~~y);
			});
		}
		return v;
	};

	this.newEntries = function(key, count) {
		var wchp = col.$currentChapter,
			chapter = _chapter(wchp),
			wid = ~~chapter.$hwm,
			entries = [],
			e;

		if (wid + count > _maxId) {
			col.$currentChapter = ++wchp;
			chapter = _chapter(wchp);
			wid = ~~chapter.$hwm;
		}
		for (var i = 0; i < count; i++) {
			e = {
				$key: key,
				$origin: wchp + "/" + (++wid),
				$meta: {},
				text: {
					"XXX": key
				}
			};
			entries.push(e);
			chapter[wid] = e.text;
		}
		chapter.$hwm = wid;
		_byKey[key] = entries;
		return entries;
	};

	this.upsertMessage = function(message, language, refkey, opt) {
		var x3lang = typeof(language) === "object" ? language.x3 : language;
		message = _fixMisspelling(message, x3lang);

		var entries = this.getByKey(refkey),
			chunks = _splitMessage(message);

		if (!entries || entries.length === 0) {
			entries = this.newEntries(refkey, chunks.length);
		}
		opt = opt || {};
		if (!x3lang) {
			console.error("upsertMessage: bad x3 language " + JSON.stringify(language));
			return entries;
		}
		// console.log("upsertMessage: chunks=" + chunks)
		// console.log("      1     entries=" + JSON.stringify(entries, null, "\t"));
		entries.forEach(function(e, i) {
			var m = e.$meta[x3lang] || (e.$meta[x3lang] = {});
			m.lanori = (x3lang === defaultLanguage.x3) ? "" : (opt.lanori != null ? opt.lanori : defaultLanguage.x3);
			m.state = e.text[x3lang] == null ? "created" : "modified";
			if (opt.sameForAll) {
				e.text[x3lang] = chunks[0];
			} else {
				e.text[x3lang] = chunks[i];
			}
			if (!e.text["XXX"]) {
				e.text["XXX"] = e.$key = refkey;
			} else if (e.text["XXX"] != refkey || e.$key != refkey) {
				throw new Error("Hash key mismatch: " + "XXX=" + e.text["XXX"] + ", $key=" + e.$key + ", refkey=" + refkey);
			}
			if (!e.$meta["XXX"]) {
				e.$meta["XXX"] = {
					lanori: "",
					state: "clean"
				};
			}
		});
		// console.log("  entries=" + JSON.stringify(entries, null, "\t"));
		return entries;
	};

	this.dup = function(chp, id, lan1, lan2) {
		var v = col[chp];
		if (!v) return;
		v = v[id];
		if (!v || v[lan1] == null) return;
		v[lan2] = v[lan1];
	};

	this.remove = function(chp, id, lan) {
		var v = col[chp];
		if (!v) return;
		v = v[id];
		if (!v || v[lan] == null) return;
		delete v[lan];
	};

	this.append = function(src, chp, id, ctx) {
		var minId = id,
			maxId = id,
			wchp = col.$currentChapter || chp,
			chapter = _chapter(wchp),
			wid = ~~chapter.$hwm + 1,
			self = this,
			tu, m, dist,
			newctx = helpers.object.clone(ctx, true);

		if (wid > _maxId) {
			col.$currentChapter = ~~(col.$currentChapter || chp) + 1;
			wchp = col.$currentChapter;
			chapter = _chapter(wchp);
			wid = ~~chapter.$hwm + 1;
		}

		if (Array.isArray(id)) {
			dist = id[1] - id[0];
			if (wid + dist > _maxId) {
				col.$currentChapter = ++wchp;
				chapter = _chapter(wchp);
				wid = ~~chapter.$hwm + 1;
			}
			for (var i = id[0]; i <= id[1]; i++) {
				ctx = this.append(src, chp, i, ctx);
			}
			newctx.chp = col.$currentChapter;
			newctx.id = [wid, wid + dist];
			return newctx;
		}

		if (chp > ctx.$max) {
			console.error("Chapter overflow");
			newctx.$failed = true;
			return newctx;
		}
		tu = src.get(chp, id);
		if (tu == null || Object.keys(tu).length === 0)
			newctx.$deleted = true;
		else {
			forEachKey(tu, function(lan) {
				if (lan[0] === "$") return;
				m = src.getMeta(chp, id, lan);
				_setText(wchp, wid, lan, tu[lan], m.state, m.stamp, m.lanori);
			});
		}
		newctx.chp = wchp;
		newctx.id = wid;
		return newctx;
	};

	this.chapter = function(chp) {
		return col[chp];
	};

	this.getMessageByKey = function(key, lang) {
		var entry = this.getByKey(key),
			result = {
				$entry: entry,
				chunks: []
			};
		if (!entry)
			return result;

		lang = lang || defaultLanguage.x3;
		result.chunks = entry.map(function(e) {
			return e.text[lang];
		});
		result.message = reassembleStrings(result.chunks);

		tracer && tracer("[MessageSet.getMessageByKey] key=" + key, ", lang=" + lang + ", result='" + JSON.stringify(result, null, 2));
		return result;
	};

	this.sync = function() {
		var m,
			self = this,
			delta = new MessageSet(),
			toAssign = [],
			max = {
				$chp: 1
			},
			parts, chp = 1;

		// forEachKey(_byKey, function(key, entry) {
		// 	if (entry.$origin == null) {
		// 		toAssign.push(entry);
		// 	} else {
		// 		parts = entry.$origin.split("/");
		// 		chp = ~~parts[0];
		// 		if (chp > max.$chp) max.$chp = chp;
		// 		max[chp] = Math.max(~~max[chp], ~~parts[1]);
		// 	}
		// });

		// toAssign.forEach(function(e){

		// });
		forEachKey(col, function(ck, chp) {
			if (ck[0] === "$") return;
			forEachKey(chp, function(ik, id) {
				if (ik[0] === "$") return;
				var e = self.getByKey(id["XXX"]);
				e = e && e.filter(function(e0) {
					return e0.$origin === (ck + "/" + ik);
				})[0];
				var addRef = false;
				e && forEachKey(id, function(lk) {
					if (lk[0] === "$" || lk === "XXX") return;
					var m = e.$meta[lk] || {
						state: "clean"
					};
					if (m.state === "deleted") {
						delta.remove(ck, ik, lk);
					} else if (m.state != "clean" && !exports.isEqualPlaceHolder(id[lk])) {
						delta.init(ck, ik, lk, id[lk], m.stamp, m.lanori);
						m.state = "clean";
						addRef = true;
					}
				});
				if (addRef) {
					m = e.$meta["XXX"] || {
						state: "clean"
					};
					delta.init(ck, ik, "XXX", id["XXX"], m.stamp, m.lanori);
				}
			});
		});
		return delta;
	};

	this.traverseKeys = function(cb, context) {
		var self = this;
		if (!cb)
			return;
		forEachKey(_byKey, function(key, entry) {
			cb(key, entry);
		});
	};

	this.traverse = function(cb, opt, context) {
		var self = this;
		if (!cb)
			return;
		opt = opt || {};
		context = opt.context || {};

		var colkeys = Object.keys(col);
		if (opt.sort) {
			colkeys = colkeys.sort(numSort);
		}
		colkeys.forEach(function(k0) {
			if (k0[0] === "$") return;
			var chp = col[k0],
				chpkeys = chp && Object.keys(chp);
			context.$chp = chp;
			cb(context, k0);
			if (opt.sort && chp) {
				chpkeys = chpkeys.sort(numSort);
			}
			chpkeys.forEach(function(k1) {
				if (k1[0] === "$") return;
				var id = chp[k1],
					idkeys = id && Object.keys(id);
				context.$id = id;
				if (opt.sort && id) {
					idkeys = idkeys.sort();
				}
				var e = self.getByKey(id["XXX"]),
					mk = _makeKey(k0, k1);

				e = e && e.filter(function(e0) {
					return e0.$origin === mk;
				})[0];
				if (!e) {
					e = _unbound[mk];
				}
				context.$entry = e;
				cb(context, k0, k1);
				e && idkeys.forEach(function(k2) {
					if (k2[0] === "$") return;
					var meta = e.$meta[k2];
					if (!meta)
						console.error("traverse - no meta for " + e.$key + " " + k0 + "/" + k1 + "/" + k2 + ", text='" + id[k2] + "'");
					// console.log("traverse getMeta: " + k0 + "/" + k1 + "/" + k2 + "\n" + JSON.stringify(meta));
					cb(context, k0, k1, k2, id[k2], meta);
				});
			});
		});
	};

	this.dumpToPlainFile = function(_, file, opt) {
		opt = opt || {};
		var meta, txt = "",
			self = this,
			contents = opt.headerLine ? "Language\tChapter\tNumber\tOriginal_Language\tText\n" : "",
			varErrors = opt.headerLine ? "Language\tChapter\tNumber\tOriginal_Language\tText\n" : "",
			vars = [];
		tracer && tracer("[MessageSet.dumpToPlainFile] " + file);

		var errors = {};
		var res = {};
		this.traverse(function(context, chp, id, lan, text, meta) {
			if (chp == null || id == null || lan == null)
				return;
			txt = normalizeString(text, true);
			// contents += lan + "\t" + chp + "\t" + id + '\t"' + txt + '"\n';
			var lanori = meta ? (meta.lanori == null ? "" : meta.lanori) : (lan === defaultLanguage.x3 ? "" : defaultLanguage.x3);
			if (exports.isEqualPlaceHolder(txt)) {
				lanori = "";
				if (meta) meta.lanori = lanori;
			}

			var line = utils.formatLine(chp, id, lan, txt, lanori, {
				healthy: true
			});
			// if (txt) {
			contents += line + "\n";
			// }
			// txt += "[" + lan + ":" + chp + ":" + id + "] " + escapeSpecialChars(n[lan]) + "\n";
			if (txt && ["XXX", defaultLanguage.x3].indexOf(lan) === -1 && !exports.isEqualPlaceHolder(txt)) {
				var text0 = normalizeString(context.$id[defaultLanguage.x3], true);
				if (utils.varError(text0, txt)) {
					if (meta) meta.lanori = defaultLanguage.x3;
					var errk = _makeKey(chp, id),
						err = errors[errk];
					if (!err) {
						err = errors[errk] = [];
						err.push(utils.formatLine(chp, id, defaultLanguage.x3, text0, "", {
							healthy: true
						}));
					}
					err.push(line);
				}
			}
		}, {
			sort: true
		});
		fs.writeFile(file, contents, "utf8", _);
		var errorfile = fsp.join(fsp.dirname(file), "varerrors-" + fsp.basename(file));
		Object.keys(errors).forEach(function(k) {
			varErrors += errors[k].join("\n") + "\n";
		});
		fs.writeFile(errorfile, varErrors, "utf8", _);
	};

}

var utils = {
	varError: function(ref, text) {
		var re = /(\{[^\}]+\})/g,
			vars0 = [],
			vars1 = [],
			v;
		if (!text) return;
		while ((v = re.exec(ref)))
			vars0.push(v[1]);
		while ((v = re.exec(text)))
			vars1.push(v[1]);
		return vars0.some(function(v) {
			if (vars1.indexOf(v) === -1) {
				return true;
			}
		});
	},
	formatLine: function(chp, id, lan, text, lanori, opt) {
		opt = opt || {};
		var txt = text;
		if (!opt.healthy)
			txt = normalizeString(text, true);
		return lan + "\t" + chp + "\t" + id + "\t" + lanori + '\t' + (opt.quoted ? _quoted(txt) : txt);
	},
	parsePlainContents: _parsePlainContents,
	makeKey: _makeKey,
	cleanString: _cleanString,
	fixBraces: _fixBraces,
	quoted: _quoted,
};

exports.utils = utils;

function numSort(a, b) {
	return (~~a) - (~~b);
}

exports.MessageSet = MessageSet;

function fixSpecialChars(s) {
	return s. //
	replace(/\"\"/g, '"'). //
	replace(/\\ n/gi, '\n'). //
	replace(/\\/g, '');
}

function _cleanString(s) {
	return s && s.replace(/([^\s])[\s\u00b7]+$/g, "$1");
}

function normalizeString(s, convertNewline) {
	if (Array.isArray(s)) {
		return reassembleStrings(s.map(function(t) {
			return normalizeString(t, convertNewline);
		}));
	}
	// replace spaces by a single utf-8 middle dot
	s = s && s.replace(/[\s\u00b7]+$/g, "\u00b7") || "";
	return _fixBraces(_cleanString(convertNewline ? s.replace(/\n/g, "\\n") : s));
}

function _fixBraces(s) {
	var braces = [];
	var pos = 0,
		c, i = 0;
	while (s && (c = s.charAt(i)) && (pos = "{([".indexOf(c)) != -1) {
		braces.push(["{([".charAt(pos), "})]".charAt(pos), i++]);
		// console.error("_fixBraces: (" + i + ") " + s);
	}
	braces.reverse();
	braces.forEach(function(b) {
		var p = b[2] + 1;
		var closing = s.indexOf(b[1], p);
		var opening = s.indexOf(b[0], p);
		if (closing === -1 || (opening !== -1 && closing > s.indexOf(b[0], p))) {
			s = s.substring(1) + b[1];
		}
	});
	return s;
}

function _fixMisspelling(text, lan) {
	if (!text)
		return text;
	if (lan === "ENG" || lan === "BRI") {
		text = text.replace(/\b([t|T])itel(s?)\b/g, "$1itle$2");
		text = text.replace(/\b([l|L])i[c|s]ence(s?)\b/g, "$1icense$2");
	}
	if (lan === "GER" || lan === "ENG" || lan === "BRI") {
		text = text.replace(/\b([e|E])ndoint(s?)\b/g, "$1ndpoint$2");
	}
	return text;
}

function _fixTranslation(set, cb) {
	var tu, tref, tmu, mtl, meta;
	set.traverseKeys(function(key, entry) {
		entry.forEach(function(e, i) {
			tu = e.text || [];
			tref = tu["ENG"];
			var tmu = dictionary.getEntry(tref),
				mtl;
			if (tmu) {
				Object.keys(tu).forEach(function(l) {
					if (l === "XXX" || l === "ENG")
						return;
					mtl = tmu.getText(l);
					if (mtl != null) {
						if (mtl !== tu[l] && mtl !== tref) {
							cb(meta.$key, l, tu, mtl);
							meta = e.$meta || (e.$meta = {});
							meta = meta[l] || (meta[l] = {});
							meta.lanori = "";
							meta.state = "modified";
							console.error("autoSet '" + meta.$key + "' [" + l + "]" + "\n--- '" + tu[l] + "'\n+++ '" + mtl + "'");
							tu[l] = mtl;
						}
					}
				});
			}
		});
	});
}

function _replaceTerminator(t) {
	return (t || "").replace(/((\s|\u00b7)*_\s*)$/, "");
}

function _appendChunk(res, t) {
	return (res ? res + " " : "") + _replaceTerminator(t);
}

function reassembleStrings(a) {
	return a.reduce(function(res, t) {
		if (t == null) return res;
		return _appendChunk(res, t);
	}, null);
}

function _quoted(s) {
	return '"' + s + '"';
}

exports.reassembleStrings = reassembleStrings;

exports.isEqualPlaceHolder = function(t) {
	return (/====*/).exec(t);
};

exports.isSimilar = function(s1, s2) {
	return s1 === s2 || _cleanString(s1) === _cleanString(s2);
};


// function unescapeSpecialChars(s) {
// 	return s.replace(/\n/g, "\\n"). //
// 	replace(/\r/g, "\\r"). //
// 	replace(/\t/g, "\\t"). //
// 	replace(/\f/g, "\\f");
// }

// function escapeSpecialChars(s) {
// 	return s.replace(/\n/g, "\\n"). //
// 	replace(/\r/g, "\\r"). //
// 	replace(/\t/g, "\\t"). //
// 	replace(/\f/g, "\\f");
// }


function Dictionary() {
	var _tm = {};

	this.smartAssign = function(key, lan, text, ek) {
		if (!key || !(/\w\w/.test(key))) {
			return; // key is not relevant
		}
		text = _cleanString(text);
		text = _fixMisspelling(text, lan);

		if (!text || exports.isEqualPlaceHolder(text) || text === key || !(/\w\w/.test(text))) {
			return; // text is not relevant
		}
		var tmu = _tm[key] || (_tm[key] = new DictionaryEntry(key)),
			mtl = tmu.getText(lan);
		// tmu.$count++;
		tmu.setText(lan, text, ek);
	};

	this.getEntry = function(key) {
		return _tm[key];
	};
	this.getText = function(key, lan) {
		var tmu = _tm[key];
		return tmu && tmu.getText(lan);
	};
	this.get = function(key, lan) {
		var tmu = _tm[key];
		return tmu && tmu.get(lan);
	};
	this.traverse = function(cb) {
		cb && Object.keys(_tm).forEach(function(k) {
			cb(k, _tm[k]);
		});
	};
}

function DictionaryEntry(key) {
	this.$key = key;
	this.text = {};
}

DictionaryEntry.prototype = {
	getText: function(lan) {
		return this.text[lan] && this.text[lan][0][0];
	},
	getAllTexts: function(lan) {
		return this.text[lan] && this.text[lan].map(function(e) {
			return e[0];
		});
	},
	get: function(lan) {
		return this.text[lan] && this.text[lan].map(function(e) {
			return [e[0], e[1].length];
		});
	},
	setText: function(lan, text, ek) {
		text = _cleanString(text);
		var mtl = this.text[lan];
		var entry = [
			text, [ek]
		];
		if (mtl == null) {
			mtl = this.text[lan] = [entry];
		} else if (text !== this.$key) {
			var p, e0 = mtl[0];
			if (text === e0[0]) {
				e0[1].push(ek);
			} else if (mtl.slice(1).some(function(e, i) {
					if (e[0] === text) {
						e[1].push(ek);
						if (e[1].length > e0[1].length) {
							p = i;
						}
						return true;
					}
				})) {
				// move element to first place
				mtl.unshift(mtl.splice(p + 1, 1)[0]);
			} else {
				mtl.push(entry);
				// various translations for '" + this.$key + "' [" + l + "] count=" + this.$count + "\n--- " + text + "\n+++ " + mtl);
			}
			// console.error("  various translations for '" + this.$key + "' [" + lan + "] " + JSON.stringify(mtl));
		}
	}
};

var dictionary;
exports.resetDictionary = function() {
	var dic = dictionary;
	dictionary = exports.dictionary = new Dictionary();
	return dic;
};

exports.resetDictionary();