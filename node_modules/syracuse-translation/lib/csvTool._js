"use strict";
var fs = require('streamline-fs');
var fsp = require("path");
var sys = require("util");
var helpers = require("syracuse-core/lib/helpers");
var flows = require("streamline/lib/util/flows");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var locale = require("syracuse-core/lib/locale");
var config = require('config'); // must be first
var dev = (config.system || {}).enableDevelopmentFeatures;
var debug = dev && true;
var tracer = console.log;

var rootpath = fsp.dirname(process.cwd());

function makeDiagnosisCollectors(instance, options) {
	var collector;

	if (debug && tracer) {
		collector = function(severity, message) {
			tracer("Diagnosis - " + severity + ": " + message);
		};
	} else if (options && options.$diagnoses) {
		collector = function(severity, message) {
			options.$diagnoses.push({
				severity: severity,
				message: message
			});
		};
	} else {
		collector = function(severity, message) {
			instance.$addDiagnose(severity, message);
		};
	}
	return {
		info: collector.bind(undefined, "info"),
		warning: collector.bind(undefined, "warning"),
		error: collector.bind(undefined, "error"),
		add: collector
	};
}

function csvWriter(_, dir, file, enc) {
	var csvOut = fsp.join(dir, file);
	var fd = fs.open(csvOut, "w+", "0666", _);

	function _write(_, mod, res, trans, en) {
		var buf = new Buffer('"' + mod + '";"' + res + '";"' + trans + '";"' + en + '"\r\n', enc || "ucs2");
		fs.write(fd, buf, 0, buf.length, null, _);
	}

	_write(_, "Module", "Resource Name", "Translated Text", "English Text");
	return {
		write: _write,
		close: function(_) {
			fs.close(fd, _);
		}
	};
}

function TranslationProcess(_, instance, options, context) {
	this.instance = instance;
	this.options = options || {};
	this.context = context;
	this.diagnosis = makeDiagnosisCollectors(instance, options);
	this.endpoint = this.options.endpoint || (instance && instance.endpoint(_));
	if (!this.endpoint) {
		throw new Error(locale.format(module, "noSourceEndpoint"));
	}
	this.rootDir = fsp.join(__dirname, "../../", this.options.dir || "");
	this.targetDir = this.options.indexdir || fsp.join(__dirname, "../../../translation-resources");
	if (!fs.exists(this.targetDir, _)) {
		fs.mkdir(this.targetDir, undefined, _);
	}
}

exports.TranslationProcess = helpers.defineClass(TranslationProcess, null, {
	extractResources: function(_) {
		function walk(_, file) {
			var dir = this || "";
			var path = fsp.join(dir, file);
			tracer && tracer("walk path=" + path);
			var stat = fs.stat(path, _);
			var files;
			if (stat.isDirectory()) {
				if (file === "test") {
					// do not walk through the test folder
				} else if (file === "resources") {
					files = fs.readdir(path, _);
					files.forEach_(_, extract, dir);
				} else {
					files = fs.readdir(path, _);
					files.forEach_(_, walk, path);
				}
			}
		}

		function extract(_, file) {
			var dir = this;
			var pos = file.indexOf("-en.json");
			var parsed;
			if (pos === -1) return;

			var fpath = fsp.join(dir, "resources", file);
			tracer && tracer("extract " + fpath);
			var input = fs.readFile(fpath, "utf8", _);
			try {
				parsed = JSON.parse(input);
			} catch (e) {
				diagnosis.error(locale.format(module, "incorrectJsonFormat", fpath));
				return;
			}

			//tracer && tracer("PARSED: " + JSON.stringify(parsed,null,2));
			flows.eachKey(_, parsed, _addEntry);

			function _addEntry(_, key, message) {
				if (key[0] === "@") return;
				var relpath = fsp.relative(rootpath, fpath);
				var dirkey = relpath.replace(/\\/g, '\/');
				if (typeof message !== "string") {
					diagnosis.warning(locale.format(module, "incorrectType", dirkey, key));
					return;
				}
				var matches = dirkey.match("syracuse/node_modules/(.+)-en.json");
				var modkey = matches && matches[1] || dirkey;
				tracer && tracer("_addEntry dirkey=" + dirkey + ", modkey=" + modkey + ", key=" + key);
				writer.write(_, modkey, key, message, message);
				count++;
			}
		}

		var count = 0,
			diagnosis = this.diagnosis;

		tracer && tracer("Start extractResources");
		diagnosis.info(locale.format(module, "startExtractResources", this.endpoint.description(_)));

		var writer = csvWriter(_, this.targetDir, "resources.csv");
		walk(_, this.rootDir);
		writer.close(_);

		if (count > 0) {
			diagnosis.info(locale.format(module, "endExtractResources", count));
		} else {
			diagnosis.info(locale.format(module, "endExtractResourcesNoText"));
		}
		tracer && tracer("End extractResources: " + count + " text(s) added");
	},

	extractAdminResources: function(_) {
		var count = 0;

		function _extractAllLang(_, fpath, fname, fsModule) {
			tracer && tracer("_extract path: " + fpath);
			var contentStr = (fsModule || fs).readFile(fpath, "utf8", _),
				jsonContent, localizations;
			try {
				jsonContent = JSON.parse(contentStr);
				localizations = jsonContent.$localization || {};
				tracer && tracer("index data " + JSON.stringify(index, null, 2));
			} catch (e) {
				return diagnosis.error(locale.format(module, "incorrectJsonFormat", fpath));
			}

			function _extractLang(_, lang) {
				if (!localizations[lang]) {
					// diagnosis.error(locale.format(module, "noLocalization", fpath));
					return false;
				}
				var language = {
					iso: lang,
					x3: locale.x3Language(lang, true)
				};
				if (!language.x3) {
					diagnosis.error(locale.format(module, "unknownLangMap", lang));
					return false;
				}

				var entity = db.getEntity(_, "APLSTD", "$bulk");
				var whereClause = "LANCHP ge " + index.chapter.min + " and LANCHP le " + index.chapter.max + " and LANNUM ne 0 and LAN eq \"" + locale.x3Language(lang) + "\"";
				x3Records = db.fetchInstances(_, entity, {
					count: fetchCountX3,
					sdataWhere: whereClause
				});
				tracer && tracer("x3Records read: " + x3Records.length);
				if (x3Records.length >= fetchCountX3) {
					throw new Error("Error: Maximum records to read is " + fetchCountX3 + " and this amount of records has been fetched. Aborting since some records may not be processed otherwise!");
				}
				//
				return _extract(_, localizations[lang], fname, language);
			}

			// extract en-us as a reference for the index
			_extractLang(_, "en-us");

			// extract all other languages
			Object.keys(localizations).filter(function(lang) {
				return options.extractAllLanguages && (lang.toLowerCase() !== "en-us");
			}).forEach_(_, _extractLang);
		}

		// start process
		var writer = csvWriter(_, this.targetDir, "admin.csv");

		tracer && tracer("Start extractAdminResources");

		var path, dir;
		if (this.options.exportFile) {
			path = dir;
			_extractAllLang(_, fsp.join(path, options.exportFile), options.exportFile, options.inputFiler);
		} else {
			path = fsp.join(__dirname, "../../../import");
			var stat = fs.stat(path, _);
			if (stat.isDirectory()) {
				var files = fs.readdir(path, _);
				files.forEach_(_, function(_, fnam) {
					_extractAllLang(_, fsp.join(path, fnam), fnam, options.inputFiler);
				});
			}
		}

		tracer && tracer("End extractAdminResources: " + count + " text(s) added");
	},

	extractDotnetResources: function(_) {}
});