"use strict";
var config = require('config');
// var tracer = require('@sage/syracuse-core').getTracer("translation.text");
var http = require("ez-streams").devices.http;
var STATUS_CODES = require('http').STATUS_CODES;
var baseUrl = (config.textsServer || {}).url;
var httpSession;
var acceptLanguage = "en,en-us,fr,fr-fr";

exports.$exported = true;

baseUrl = baseUrl || "http://localhost:8999";
if (baseUrl.charAt(baseUrl.length - 1) === "/") {
	baseUrl = baseUrl.substr(0, baseUrl.length - 1);
}

// =================================================================
// = ATEXTE functions
// =================================================================
exports.deleteText = function(_, product, num, keep) {
	// console.log("deleteText:"+ [product, num].join(','));
	var resp = _del(_, _apiPath("ATEXTE", [product, num]) + "?keep=" + ((keep === false) ? "false" : "true"));
	return _wrapResult("", resp.status);
};

/* getTextInfo returns a set of textes for a given product and number
 */
exports.getTextInfo = function(_, product, num) {
	// console.log("getText:"+ [product, num].join(','));
	var resp = _get(_, _apiPath("ATEXTE", [product, num]));
	return _wrapResult(resp.body, resp.status);
};

/* getText returns the TEXT for a given product, number and language
 */
exports.getText = function(_, product, num, lan) {
	// console.log("getText:"+ [product, num, lan].join(','));
	var resp = _get(_, _apiPath("ATEXTE", [product, num, lan]));
	return _wrapResult((resp.body && resp.body[0] && resp.body[0].TEXTE) || resp.body, resp.status);
};

/* getTextOriginalLanguage returns the LANORI for a given product, number and language
- if the text doesn't exists in the selected language but exists in another language but with an empty 
LANORI (translated text!) it is this language which has to be returned
*/
exports.getTextOriginalLanguage = function(_, product, num, lan) {
	var resp = _get(_, _apiPath("ATEXTE", [product, num]));
	var lanori1, lanori2;
	if (resp.status === 200) {
		resp.body.some(function(text) {
			if (text.LAN === lan) {
				// Text found:
				lanori1 = text.LANORI;
				return true;
			}
			lanori2 = (!lanori2 && !text.LANORI.length) ? text.LAN : lanori2;
			return false;
		});
		if (lanori1 !== undefined) return _wrapResult(lanori1, resp.status);
		return _wrapResult(lanori2 || "", resp.status);
	}
	return _wrapResult("", 404);
};

exports.createText = function(_, product, lanori, languages, text, comment, legacy) {
	// console.log("createText:"+ [product, lanori, languages, text, comment, legacy].map(a => '"'+a+'"').join(','));
	var data = {
		"TEXTE": text,
		"COMMENT": comment,
		"LANORI": lanori,
		"LAN": languages.split(','),
		"product": product,
		"legacy": legacy
	};
	var resp = _post(_, _apiPath("ATEXTE"), data);
	return _wrapResult((resp.body && resp.body[0] && resp.body[0].NUMERO) || resp.body, resp.status);
};

exports.updateText = function(_, product, num, lanori, languages, text, comment) {
	// console.log("updateText:"+ [product, num, lanori, languages, text, comment].map(a => '"'+a+'"').join(','));
	var data = {
		"NUMERO": num,
		"LANORI": lanori,
		"LAN": languages.split(','),
		"product": product,
		"TEXTE": text,
		"COMMENT": comment
	};
	var resp = _put(_, _apiPath("ATEXTE"), data);
	return _wrapResult((resp.body && resp.body[0] && resp.body[0].NUMERO) || resp.body, resp.status);
};

exports.updateResource = function(_, product, num, lan, text, comment, lanori) {
	// console.log("updateResource:" + [product, num, lan, text, lanori, comment].map(a => '"' + a + '"').join(','));
	var resp = _put(_, _apiPath("RESOURCE", [product, num, lan]), {
		"TEXTE": text,
		"LANORI": lanori,
		"COMMENT": (comment || "")
	});
	return _wrapResult((resp.body && resp.body.NUMERO) || resp.body, resp.status);
};

/* returns texts from a lastModified date
 */
exports.getLastModifiedTexts = function(_, product, lastModified, count, position) {
	// console.log("getLastModifiedTexts:"+ [product, lastModified, count, position].join(','));
	var params = [];
	if (count) params.push("count=" + count);
	if (position) params.push("position=" + position);
	var query = [_apiPath("SYNC", [product, lastModified])];
	if (params.length) query.push(params.join('&'));
	var resp = _get(_, query.join('?'));
	return _wrapResult(resp.body, resp.status);
};

// =================================================================
// = APLSTD functions
// =================================================================
exports.deleteChapter = function(_, product, chapter) {
	// console.log("deleteMessagesChapter:"+ [product, chapter].join(','));
	var resp = _del(_, _apiPath("APLSTD", [product, chapter]));
	return _wrapResult("", resp.status);
};

exports.deleteMessage = function(_, product, chapter, num) {
	// console.log("deleteMessagesChapter:"+ [product, chapter].join(','));
	var resp = _del(_, _apiPath("APLSTD", [product, chapter, num]));
	return _wrapResult("", resp.status);
};

exports.getMessage = function(_, product, chapter, num, lan) {
	// console.log("getMessage:"+ [product, chapter].join(','));
	var resp = _get(_, _apiPath("APLSTD", [product, chapter, num, lan]));
	// return _wrapResult((resp.body && resp.body[0] && resp.body[0].LANMES) || resp.body, resp.status);
	return _wrapResult(resp.body, resp.status);
};

exports.getMessages = function(_, product, chapter, lan, from, to) {
	// console.log("getMessages:"+ [product, chapter].join(','));
	var resp = _get(_, _apiPath("APLSTD", [product, chapter]));
	if (resp.status >= 400) return _wrapResult(resp.body, resp.status);

	// First get all messages without between to and from
	var messages = resp.body.reduce(function(r, message) {
		if (message.LANNUM >= from && message.LANNUM <= to) {
			r[message.LANNUM] = r[message.LANNUM] || {
				messages: []
			};
			r[message.LANNUM].messages[message.LAN] = message.LANMES;
			r[message.LANNUM].CODE = message.CODE;
		}
		return r;
	}, {});

	// Second get messages that match the lan, "ENG" or the first available language
	var range = Object.keys(messages).reduce(function(r, menu) {
		var message = "";
		[lan, "ENG", Object.keys(messages[menu].messages)[1]].some(
			language => (message = messages[menu].messages[language]) !== undefined);
		r.push({
			LANNUM: parseInt(menu),
			LANMES: message,
			CODE: messages[menu].CODE
		});
		return r;
	}, []);
	// console.log(range);
	return _wrapResult(range, resp.status);
};

exports.createMessage = function(_, product, lanori, languages, chapter, text, code) {
	// console.log("createMessage:"+ [product, lanori,languages, chapter, text, code].join(','));
	var data = {
		"LANMES": text,
		"LANORI": lanori,
		"LAN": languages.split(','),
		"CODE": code
	};
	var resp = _post(_, _apiPath("APLSTD", [product, chapter]), data);
	return _wrapResult((resp.body && resp.body[0] && resp.body[0].LANNUM) || resp.body, resp.status);
};

exports.updateMessage = function(_, product, chp, num, lanori, lan, text, code) {
	// console.log("updateMessage:"+ [product, chp, num, lanori ,lan, text, code].join(','));
	var data = {
		"LANMES": text,
		"LANORI": lanori,
		"CODE": code
	};
	var resp = _put(_, _apiPath("APLSTD", [product, chp, num, lan]), data);
	// console.log(_apiPath("APLSTD", [product, chp, num, lan])+" => ",resp);
	return _wrapResult((resp.body && resp.body[0] && resp.body[0].LANNUM) || resp.body, resp.status);
};

exports.translateMessage = function(_, product, chp, num, lan, text) {
	var data = {
		"LANMES": text,
		"LANORI": ""
	};
	var resp = _put(_, _apiPath("APLSTD", [product, chp, num, lan]), data);
	return _wrapResult((resp.body && resp.body[0] && resp.body[0].LANNUM) || resp.body, resp.status);
};

/* returns texts from a lastModified date
 */
exports.getLastModifiedMessages = function(_, product, lastModified, count, position) {
	// console.log("getLastModifiedTexts:"+ [product, lastModified, count, position].join(','));
	var params = [];
	if (count) params.push("count=" + count);
	if (position) params.push("position=" + position);
	var query = [_apiPath("SYNC_APLSTD", [product, lastModified])];
	if (params.length) query.push(params.join('&'));
	var resp = _get(_, query.join('?'));
	return _wrapResult(resp.body, resp.status);
};

// =================================================================
// = Search similar texts
// =================================================================
exports.search = function(_, collec, selector, projection) {
	try {
		var data = {
			query: {
				collection: collec,
				selector: selector,
				projection: projection
			}
		};
		// console.error("search query=" + JSON.stringify(data, null, 2));
		var resp = _post(_, _apiPath("search"), data);

		var result = (resp.body || []);
		// console.error("search result=" + JSON.stringify(result, null, 2));
		return _wrapResult(result, result ? resp.status : 404);
	} catch (e) {
		// console.error("search ERROR: " + e.message);
		return _wrapResult(e.message + "\n" + e.stack, 500);
	}
};

// example of 4GL call: func atxtsvc.search_similar("ATEXTE", "FRA", "sauvegarde")
exports.searchSimilar = function(_, product, collec, lan, text) {
	let wheres = [];
	for (var len = text.length, i = len; i && (len - i) < 3; --i) {
		[product, ""].forEach(p => {
			wheres.push({
				"TEXTE": {
					"$regex": '^' + text.substring(0, i),
					"$options": "i"
				},
				"product": p,
				"LAN": lan
			});
		});
	}
	var projection = {
		"NUMERO": 1,
		"TEXTE": 1,
		"COMMENT": 1,
		"LAN": 1,
	};
	// console.log("searchSimilar:",JSON.stringify({$or:wheres},null,"\t"));
	return exports.search(_, collec, {
		$or: wheres
	}, projection);
};

function _apiPath(sub, segments) {
	segments = (segments || []).reverse();
	while (segments.length > 0 && !segments[0]) segments.shift();
	segments = segments.reverse().map(function(s) {
		s = s.toString();
		return s || "-";
	});
	return ["/api", sub].concat(segments).join("/");
}

function _wrapResult(result, status, message) {
	return {
		statusCode: "" + (status || 200),
		header: {
			"statusCode": "" + (status || 200),
			"message": message || STATUS_CODES[status || 200],
			"content-type": "application/json",
			"content-length": result && result.length ? result.length.toString() : "0"
		},
		body: result
	};
}

function _get(_, url, options) {
	// console.error("\nGET " + url + "\n");
	options = options || {};
	var response = http.client({
		method: "get",
		url: url.indexOf("http") === 0 ? url : baseUrl + url,
		headers: {
			"Accept-Language": acceptLanguage,
		}
	}).end().response(_);
	return _readResp(_, response);
}


function _post(_, url, data, options) {
	// console.error("\nPOST " + url + "\n");
	options = options || {};
	var ctype = "text/plain";
	if (data && typeof(data) === "object") {
		ctype = "application/json";
		data = JSON.stringify(data);
	}
	var resp = http.client({
		method: 'post',
		url: url.indexOf("http") === 0 ? url : baseUrl + url,
		headers: {
			'content-type': ctype
		}
	}).end(data).response(_);

	return _readResp(_, resp);
}

function _put(_, url, data, options) {
	options = options || {};
	// console.error("\nPUT " + url + "\n");
	// console.error(JSON.stringify(data) + "\n");
	var ctype = options.contentType || "text/plain;charset=UTF-8";
	if (data && typeof(data) === "object") {
		ctype = "application/json;vnd.sage=syracuse; charset=utf-8";
		data = JSON.stringify(data);
	}
	var headers = {
		"content-type": ctype,
		"accept": "application/json;vnd.sage=syracuse; charset=utf-8",
		"x-file-name": options.xfilename,
	};

	if (options.debug) {
		headers["pragma"] = "debug-immediate";
	}

	var response = http.client({
		method: "put",
		url: url.indexOf("http") === 0 ? url : baseUrl + url,
		headers: headers
	}).end(data).response(_);

	return _readResp(_, response);
}


function _del(_, url, options) {
	// console.error("\nDELETE " + url + "\n");
	var response = http.client({
		method: "delete",
		url: url.indexOf("http") === 0 ? url : baseUrl + url,

		headers: {
			"Accept-Language": acceptLanguage,
			accept: "application/json;vnd.sage=syracuse; charset=utf-8"
		}
	}).end().response(_);
	return _readResp(_, response);
}


function _readResp(_, response) {
	var resp = {
		status: response.statusCode,
		headers: response.headers,
		body: response.readAll(_)
	};
	// console.error("status=" + (resp && (resp.status + ", length=" + (resp.body && resp.body.length))));
	if (/application\/json/.test(response.headers["content-type"]))
		resp.body = JSON.parse(resp.body);
	return resp;
}



/*function testGetMessages(_) {
	exports.getMessages(_, "-", 123, "ENG", 1, 1000);
}

exports.test = function(config, cb) {
	testGetMessages(cb);
};*/