"use strict";
/// !doc
/// 
/// # X3 translation helper
/// 
/// Extract syracuse texts in order to be translated by translators.
/// 
/// Update syracuse texts with the new texts and new supported language.
/// 
var fs = require('streamline-fs');
var os = require('os');
var fsp = require("path");
var sys = require("util");
var helpers = require('syracuse-core').helpers;
var datetime = require('syracuse-core').types.datetime;
var uuid = require('syracuse-core').uuid;
var flows = require('streamline-runtime').flows;
var locale = require('syracuse-core').locale;
var config = require('config'); // must be first
var messageStore = require('syracuse-translation/lib/messageStore');
var sha1 = require("syracuse-translation/lib/helpers").sha1;
var perfmon = require('syracuse-perfmon');
var localizedText = require("syracuse-translation/lib/helpers").localizedText;

var forEachKey = helpers.object.forEachKey;

var dev = (config.system || {}).enableDevelopmentFeatures;

var transCfg = config.translation || {};
var tracer = transCfg.trace;
var traceDiagnosis = transCfg.traceDiagnosis;
var conflictFixes = (transCfg.fix || {}).conflicts || {};

var _extend = helpers.object.extend;
var _clone = helpers.object.clone;
var _stringify = helpers.object.stringify;

var isoDateFormat = messageStore.isoDateFormat;
var _splitMessage = messageStore.splitMessage;
var _getMessageFileName = messageStore.getMessageFileName;

function Category(name, description, minmax, opt) {
	this.$name = name;
	this.$description = description;
	this.$min = ~~minmax[0];
	this.$max = ~~(minmax[1] || minmax[0]);
	opt = opt || {};
	_extend(this, opt || {});
}

Category.prototype = {
	getCurrentState: function() {
		this.$current = this.$current || this.$min;
		this.$ = this.$ || {};
		this.$[this.$current] = this.$[this.$current] || {};
		var state = this.$[this.$current];
		state.$nextId = (state.$nextId || 1);
		return state;
	},

	inc: function() {
		// to review
		var categs = {};

		var state = this.getCurrentState(),
			id = state.$nextId++;

		if (state.$nextId > categs.$maxCount) {
			if (this.$current >= this.$max) {
				throw new Error("Chapter overflow");
			}
			this.$current++;
			state = this.getCurrentState();
			id = state.$nextId;
		}
		this.$count++;
		return id;
	},

	currentKey: function(n) {
		// to review
		var categs = {};

		var state = this.getCurrentState(),
			id;

		if (n && (state.$nextId + n - 1 > categs.$maxCount)) {
			if (this.$current >= this.$max) {
				throw new Error(localizedText("chapterOverflow", this.$current));
			}
			this.$current++;
			state = this.getCurrentState();
		}
		id = state.$nextId;
		if (n) {
			id = [id, id + n - 1];
		}
		return {
			chp: this.$current,
			id: id
		};
	},

	reset: function() {
		this.$current = this.$min;
		this.$ = {};
		this.$count = 0;
	},

	isExcluded: function(group) {
		return this.$exclude && this.$exclude.some(function(re) {
			return re.test(group);
		});
	}
};

var categories = {
	$maxCount: 1999,
	$maxLength: 123,
	syracuse: new Category("Syracuse", "Syracuse resources", [10031, 10035], {
		// $exclude: [/shadow-modules\//, /node_modules\/syracuse-core\/[^\/]+\/types\/resources\/(date|decimal)/, /node_modules\/etna/, /\/dist\//]
		$exclude: [/node_modules\/syracuse-core\/[^\/]+\/types\/resources\/(date|decimal)/, /node_modules\/etna/, /\/dist\//, /\/test/]
	}),
	admin: new Category("Admin", "Syracuse admin", [10036, 10043], {
		$exclude: [/syracuse-admin-demo\.json/]
	}),
	dotnet: new Category("DotNet", "Syracuse dotNet", [10044, 10045]),
};

// TODO:
// Manage deleted entries that are no longer in syracuse
// var categories = (function() {
// 	var categs = {
// 		$maxCount: 1999,
// 		$maxLength: 123,
// 		syracuse: {
// 			$name: "Syracuse",
// 			$description: "Syracuse resources",
// 			$min: 10031,
// 			$max: 10035,
// 			// Files that are already fully localized and/or that includes some other non string properties
// 			$exclude: [/node_modules\/syracuse-core\/[^/]+\/types\/resources\/(date|decimal)/]
// 		},
// 		admin: {
// 			$name: "Admin",
// 			$description: "Syracuse admin",
// 			$min: 10036,
// 			$max: 10043,
// 			$exclude: [/syracuse-admin-demo\.json/]
// 			// $exclude: ["syracuse-admin-demo.json", "x3-pages.json", "x3-dashboards-home.json", "x3-dashboards-user.json", "syracuse-admin-templates.json"]
// 		},
// 		dotnet: {
// 			$name: "DotNet",
// 			$description: "Syracuse dotNet",
// 			$min: 10044,
// 			$max: 10045
// 		}
// 	};

// 	function _getCurrentState() {
// 		this.$current = this.$current || this.$min;
// 		this.$ = this.$ || {};
// 		this.$[this.$current] = this.$[this.$current] || {};
// 		var state = this.$[this.$current];
// 		state.$nextId = (state.$nextId || 1);
// 		return state;
// 	}

// 	function _inc() {
// 		var state = this.getCurrentState(),
// 			id = state.$nextId++;

// 		if (state.$nextId > categs.$maxCount) {
// 			if (this.$current >= this.$max) {
// 				throw new Error("Chapter overflow");
// 			}
// 			this.$current++;
// 			state = this.getCurrentState();
// 			id = state.$nextId;
// 		}
// 		this.$count++;
// 		return id;
// 	}

// 	function _currentKey(n) {
// 		var state = this.getCurrentState(),
// 			id;

// 		if (n && (state.$nextId + n - 1 > categs.$maxCount)) {
// 			if (this.$current >= this.$max) {
// 				throw new Error(localizedText("chapterOverflow", this.$current));
// 			}
// 			this.$current++;
// 			state = this.getCurrentState();
// 		}
// 		id = state.$nextId;
// 		if (n) {
// 			id = [id, id + n - 1];
// 		}
// 		return {
// 			chp: this.$current,
// 			id: id
// 		};
// 	}

// 	function _reset() {
// 		this.$current = this.$min;
// 		this.$ = {};
// 		this.$count = 0;
// 	}

// 	function _isExcluded(group) {
// 		return this.$exclude && this.$exclude.some(function(re) {
// 			return re.test(group);
// 		});
// 	}

// 	Object.keys(categs).forEach(function(category) {
// 		if (typeof categs[category] !== "object") return;
// 		categs[category].$count = categs[category].$count || 0;
// 		categs[category].inc = _inc.bind(categs[category]);
// 		categs[category].getCurrentState = _getCurrentState.bind(categs[category]);
// 		categs[category].currentKey = _currentKey.bind(categs[category]);
// 		categs[category].reset = _reset.bind(categs[category]);
// 		categs[category].isExcluded = _isExcluded.bind(categs[category]);
// 		categs[category].$lastModified = categs[category].$lastModified || "";
// 	});
// 	return categs;
// })();

var defaultLanguage = messageStore.defaultLanguage;
var aplStdMaxLength = messageStore.aplStdMaxLength;
var placeholders = messageStore.placeholders;

config.session = config.session || {};
config.session.auth = config.session.auth || "basic";

helpers.pageFileStorage = false;

function refLangSorter(refLang) {
	return function(a, b) {
		return (a === refLang && -1) || (b === refLang && 1) || 0;
	};
}

exports.getCategory = function(name) {
	return categories[name];
};

var currentWorld;

/// ## TranslationProcess class
function TranslationProcess(_, world, options) {
	if (!world) {
		throw new Error("world provider is mandatory");
	}
	currentWorld = world;
	this.world = world;
	this.context = world.context;
	this.options = options || {};
	if (!this.options.endpointRead) {
		throw new Error("No source endpoint");
	}
	if (!this.options.endpointWrite) {
		throw new Error("No target endpoint");
	}
	this.rootpath = this.options.rootpath || fsp.join(__dirname, "../../..");
	this.options.indexdir = this.options.indexdir || fsp.join(this.rootpath, "translation-indexes");
	this.rootDir = fsp.join(this.rootpath, this.options.dir || "");
	this.targetDir = this.options.indexdir || fsp.join(this.rootpath, "translation-indexes");
	this.importDir = fsp.join(this.rootpath, "import/" + (this.options.filterAdmin ? "" : (transCfg.adminSubDir || "translation"))),
		this.destImportDir = fsp.join(this.importDir, "translations");
	this.messagesFilePrefix = options.messagesFilePrefix || fsp.join(this.targetDir, "messages");
	this.diagnosis = makeDiagnosisCollectors(this.options);
	if (!fs.exists(this.targetDir, _)) {
		fs.mkdir(this.targetDir, undefined, _);
	}
	if (!fs.exists(this.destImportDir, _)) {
		fs.mkdir(this.destImportDir, undefined, _);
	}
	this.store = this.createMessageStore(_, this.options.endpointRead, this.options.endpointWrite);
}

exports.TranslationProcess = helpers.defineClass(TranslationProcess, null, {
	createMessageStore: function(_, endpointRead, endpointWrite) {
		var options = this.options,
			mstore, opts = {
				diagnosis: this.diagnosis,
				ignoreChecksum: options.ignoreChecksum,
				noDBFlush: options.noDBFlush,
				renumber: options.renumber,
				file: this.messagesFilePrefix,
				filePrefix: this.messagesFilePrefix,
				targetDir: this.targetDir
			};
		if (options.noDBStore && this.messagesFilePrefix) {
			if (this.messagesFilePrefix) {
				mstore = new messageStore.FileMessageStore(this.world, endpointRead, endpointWrite, opts);
			}
			//
		} else {
			mstore = new messageStore.X3ClobMessageStore(this.world, endpointRead, endpointWrite, opts);
		}

		mstore && mstore.init(_);
		return mstore;
	},

	getAdminTranslationDestDir: function(fPath) {
		return fsp.join(this.destImportDir, fsp.basename(fPath));
	},

	///   
	/// ### getLanguages(_)
	/// return available X3 languages of the TABLAN table that match with the Syracuse locales
	getLanguages: function(_) {
		if (this.languages) return this.languages;
		var localePrefs = this.world.getLocales(_),
			x3langs = {},
			isolangs = {},
			i, m;

		var isoCodes = localePrefs.filter(function(e) {
			return e.name;
		}).map(function(e) {
			return e.name.toLowerCase();
		});
		tracer && tracer("getLanguages: locales=" + isoCodes);
		try {
			var db = this.store.getOrmWrite(_),
				entity = db.getEntity(_, 'TABLAN', "$query"),
				where = "LANISO ne '' and LANCON eq true",
				langs = db.fetchInstances(_, entity, {
					count: 1000,
					sdataWhere: where
				}),
				iso;
			tracer && tracer("getLanguages: where=" + where);
			// tracer && tracer("getLanguages: langs=" + sys.inspect(langs));
			langs.forEach_(_, function(_, e) {
				iso = e.LANISO(_).toLowerCase().replace('_', '-');
				tracer && tracer(e.LAN(_) + '  : ' + iso + " " + isoCodes.indexOf(iso));
				if (isoCodes.indexOf(iso) != -1) {
					m = (/(\w\w)-(\w\w)/).exec(iso);
					if (m) {
						x3langs[e.LAN(_)] = iso;
						isolangs[iso] = e.LAN(_);
						if (m[1] === m[2] || m[0] === "en-us")
							isolangs[m[1]] = e.LAN(_);
					}
				}
			});
		} catch (e) {
			this.diagnosis.logWarning("Cannot get language from endpoint. A default list has been set. " + e.message);
			x3langs = {
				"ARB": "ar-sa",
				"GER": "de-de",
				"ENG": "en-us",
				"BRI": "en-gb",
				"SPA": "es-es",
				"FRA": "fr-fr",
				"ITA": "it-it",
				"POL": "pl-pl",
				"POR": "pt-pt",
				"BRA": "pt-br",
				"RUS": "ru-ru",
				"CHI": "zh-cn"
			};
			isolangs = {
				"ar": "ARB",
				"ar-sa": "ARB",
				"de": "GER",
				"de-de": "GER",
				"en": "ENG",
				"en-us": "ENG",
				"en-gb": "BRI",
				"es": "SPA",
				"es-es": "SPA",
				"fr": "FRA",
				"fr-fr": "FRA",
				"it": "ITA",
				"it-it": "ITA",
				"pl": "POL",
				"pl-pl": "POL",
				"pt": "POR",
				"pt-pt": "POR",
				"pt-br": "BRA",
				"ru": "RUS",
				"ru-ru": "RUS",
				"zh": "CHI",
				"zh-cn": "CHI"
			};
		}
		if (Object.keys(x3langs).length === 0) {
			throw new Error(localizedText("emptyTABLAN"));
		}
		this.diagnosis.logInfo("Languages: x3ToIso=" + JSON.stringify(x3langs));
		this.diagnosis.logInfo("Languages: isoToX3=" + JSON.stringify(isolangs));
		this.languages = {
			x3ToIso: x3langs,
			isoToX3: isolangs
		};
		console.error("Languages: ", this.languages);
		return this.languages;
	},

	///   
	/// ### localeFile(_, base, lang)
	/// return the file name of the localization json file.
	localeFile: function(_, base, lang, extmgr) {
		var isoMap = this.getLanguages(_).x3ToIso,
			code = _defaultIso(lang) || isoMap[lang],
			rootpath = this.rootpath,
			file = code && fsp.join(rootpath, base + extmgr(code)),
			codes = [code, isoMap[lang], locale.longIso(_defaultIso(lang)), code];
		extmgr = extmgr || defaultLocaleExt;
		tracer && tracer("localeFile: base=" + base + ", lang=" + lang + ", code=" + code + ", file=" + file);
		codes.some_(_, function(_, key) {
			code = key;
			file = code && fsp.join(rootpath, base + extmgr(code));
			return file && fs.exists(file, _);
		});
		if (!file) {
			tracer && tracer("localeFile: undefined code for " + lang + ", defaultIso=" + locale.defaultIso(lang) + ", isoMap=" + isoMap[lang] + ", base=" + base);
		}
		return file || fsp.join(rootpath, base + extmgr(code || "__-__"));
	},

	// ******************* EXTRACT RESOURCES ********************
	extract: function(_, handler) {
		var diagnosis = this.diagnosis,
			opt = handler.opt,
			rootpath = this.rootpath,
			self = this;

		function _extractAllLang(_, file) {
			var resdir = file.fullName,
				files = fs.readdir(resdir, _),
				map = {},
				m, lang, e, fi;

			function _extractLang(_, lang) {
				var item = map[lang],
					refItem = map[defaultLanguage.iso];
				tracer && tracer("_extractLang " + lang);
				if (!item) {
					tracer && tracer("... noLocalization map=" + JSON.stringify(map, null, 2));
					return diagnosis.error(localizedText("noLocalization", lang));
				}
				var language = item.language;
				if (!language.x3) {
					return diagnosis.error(localizedText("unknownLangMap", lang));
				}
				item.files.forEach_(_, _extract);

				function _extract(_, finfo) {
					tracer && tracer("_extract: " + JSON.stringify(finfo, null, 2));
					diagnosis.logInfo(localizedText("extractTextsOf", handler.desc, finfo.filename));
					var group = finfo.group;
					if (!refItem || !refItem.files || refItem.files.length === 0 || !refItem.files.some(function(f) {
							return f.group === group;
						})) {
						// no file for ref language, we delete and skip it!
						console.error("No resources for '" + defaultLanguage.iso + "' so delete " + finfo.file);
						fs.unlink(finfo.file, _);
						return;
					}

					var data = handler.load(_, finfo.file, language),
						resources = data.resources,
						checkEntry = _checkEntry(_, self, resources, index, group, language);
					resources && Object.keys(resources).some_(_, checkEntry);
				}
			}

			files.forEach_(_, function(_, f) {
				var fi = _fileInfo(f, resdir, handler),
					lang = fi && fi.language.iso;
				if (lang && fi.language.x3 && !(handler.skipFile && handler.skipFile(fi))) {
					e = map[lang] = map[lang] || {
						language: fi.language,
						files: []
					};
					e.files.push(fi);
				}
			});
			if (Object.keys(map).length > 0) {
				_extractLang(_, defaultLanguage.iso);

				options.extractAllLanguages && Object.keys(map).filter(function(lang) {
					return (lang.toLowerCase() !== "en-us");
				}).forEach_(_, _extractLang);
			}
		}

		function walk(_, rootDirs) {
			var fullPath = [];
			if (!Array.isArray(rootDirs))
				rootDirs = [rootDirs];

			function _walk(_, path) {
				var fPath = fsp.join(fullPath.join("/"), path),
					stat = fs.stat(fPath, _),
					file, files;
				if (stat.isDirectory()) {
					file = {
						name: path,
						fullName: fPath,
						key: fsp.relative(rootpath, fPath).replace(/\\/g, '\/')
					};
					if (!handler.skipDir(file)) {
						fullPath.push(path);
						// do not walk through the test folder
						if (handler.match(file)) {
							_extractAllLang(_, file);
						}
						// walk subdir
						files = fs.readdir(fPath, _);
						files.forEach_(_, _walk);
						fullPath.pop();
					}
				}
			}
			rootDirs.forEach_(_, function(_, rootDir) {
				_walk(_, rootDir);
			});
		}

		var frame = this.initFrame(_, handler.category, "startExtractResources", opt),
			options = frame.options,
			index = this.frame.index;

		if (opt.loadFromIndex) {
			this.store.initFromIndex(index);
		}

		tracer && tracer("extract: handler.rootDirs=" + handler.rootDirs);
		walk(_, handler.rootDirs || this.rootDir);

		this.endExtract(_);
	},

	addNewEntry: function(_, entry) {
		var index = entry.index,
			// chp = index.$chapter,
			val = entry.val,
			group = entry.group,
			// state = chp.getCurrentState(),
			isoLang = entry.language && entry.language.iso,
			segment = entry.segment;

		tracer && tracer("addNewEntry isoLang=" + isoLang + ", group=" + group + ", length=" + val.length + ", val=" + val);
		// if (chp.$current > chp.$max) {
		// 	tracer && tracer("addNewEntry - chapterFull " + entry.ident);
		// 	this.diagnosis.error(localizedText("chapterFull", chp.$max, "admin resources"));
		// 	// stop progression
		// 	return {
		// 		fatal: true
		// 	};
		// }

		// if (!this.saveEntry(_, entry)) {
		var stored = this.upsertMessage(entry);
		if (!stored) {
			this.diagnosis.error(localizedText("createEntryfail", entry.ident, entry.group));
			return {
				fatal: false
			};
		}

		var el = segment[entry.ident] || (segment[entry.ident] = {});
		if (isoLang) {
			el.text = el.text || {};
			el.text[isoLang] = entry.val;
		} else {
			el.text = entry.val;
		}
		el.$key = entry.$key;
		return {
			fatal: false
		};
	},

	upsertMessage: function(message, language, refkey, opt) {
		opt = opt || {};
		if (message != null && typeof(message) === "object") {
			var entry = message;
			message = entry.val;
			language = entry.language;
			refkey = entry.$key;
		}
		if (this.options.rebuild)
			opt.lanori = opt.lanori || "";
		var placeHolder = message === placeholders.equal ? placeholders.equal : placeholders.empty;
		return this.store.upsertMessage(message || placeHolder, language, refkey, opt);
	},

	updateEntry: function(_, el, entry) {
		var diagnosis = this.diagnosis,
			index = entry.index,
			isoLang = entry.language && entry.language.iso,
			x3Lang = entry.language && entry.language.x3,
			message = entry.val,
			result = this.store.getMessageByKey(el.$key, x3Lang),
			x3message = result.message,
			indexText = el.text && el.text[isoLang],
			refText = el.text && el.text[defaultLanguage.iso],
			chunks = result.chunks,
			conflictFix = getConflictText(el.$key, isoLang);

		tracer && tracer("updateEntry     key=" + el.$key + ", id=" + entry.ident + ", lang=" + isoLang + "\n" + //
			"  db message='" + x3message + "'\n" + //
			"  source message='" + message + "'\n" + //
			"  index message=" + (indexText == null ? indexText : "'" + indexText + "'") + "\n" + //
			"  conflict fix='" + conflictFix + "'");

		if (x3message === message && indexText === message) {
			tracer && tracer("==> unchanged: '" + message + "' vs. '" + x3message + "'");
			return;
		}

		// Do not update text of existing translation to prevent overwriting
		if (indexText == null || x3message == null || x3message === placeholders.equal) {
			tracer && tracer("==> accepted: '" + message + "' vs. '" + x3message + "'");
		} else {
			tracer && tracer("==> rejected: '" + message + "' vs. '" + x3message + "'");
			// var mes1 = message.replace(/\s+$/, "");
			// var mes2 = message.replace(/\s+$/, "");

			this.rejectedUpdates = this.rejectedUpdates || [];
			this.rejectedUpdates.push({
				ident: entry.ident,
				message: message,
				x3message: x3message,
				language: entry.language,
				$key: entry.$key
			});
			return;
		}

		if (conflictFix) {
			entry.val = message = el.text[isoLang] = conflictFix;
		}
		if (message === placeholders.equal) {
			entry.val = message = indexText != null ? indexText : x3message;
		}
		if (chunks.length > 0) {
			el.text = el.text || {};
			// text has been modified since last extraction
			if (x3message !== message) {
				// tracer && tracer("modified since last extraction " + entry.ident + ": " + el.text[isoLang] + ' != ' + message);
				if (x3message == null) {
					// console.error("Use source for key=" + el.$key + ", id=" + entry.ident + "\n" + //
					// 	"  db message='" + x3message + "'\n" + //
					// 	"  source message='" + message + "'\n" + //
					// 	"  index message='" + indexText + "'\n"
					// );
					// text not in DB
					entry.val = message;
				} else if (x3message !== indexText && message !== indexText) {
					// Changed in DB and in source ==> conflict
					if (conflictFix == null) {
						this.addError(localizedText("updateConflict", entry.group + "/" + entry.ident, [el.$key, x3Lang].join(","), message, x3message, indexText));
						return;
					}
				}
				if (x3message && x3message != placeholders.equal && (message === el.text["en-us"] || message === el.text["fr-fr"])) {
					console.error("Use translation instead of source for key=" + el.$key + ", id=" + entry.ident + "\n" + //
						"  db message='" + x3message + "'\n" + //
						"  source message='" + message + "'\n" + //
						"  index message='" + (indexText || "") + "'\n"
					);
					entry.val = message = x3message;
				}
				this.upsertMessage(entry);
			}
		} else {
			// This situation should not happen. It means some records has been deleted from X3 since the last extraction
			// while testing it is better to delete the index file when emptying the X3 chapters
			this.upsertMessage(entry);
			diagnosis.logWarning(localizedText("indexMess", entry.group, entry.ident));
		}
		el.text[isoLang] = message;
	},

	addError: function(e) {
		var errors = this.frame.errors || (this.frame.errors = []);
		errors.push(e);
		this.diagnosis.error(e);
	},

	initFrame: function(_, category, msgkey, opt) {
		var endpoint = this.store.endpointWrite,
			diagnosis = this.diagnosis,
			// indexpath = fsp.join(this.targetDir, "index" + category.$name + "-syra.json"),
			indexpath = fsp.join(this.targetDir, "index" + category.$name + ".json"),
			frame = this.frame = {
				category: category,
				options: _extend(this.options, opt || {}, true)
			},
			endpointName = endpoint.application(_) + "/" + endpoint.contract(_) + "/" + endpoint.dataset(_),
			resetIndex = opt && opt.resetIndex || opt.rebuild,
			fetchOpt = {},
			index, g, e;

		opt = opt || {};
		tracer && tracer("initFrame: resetIndex=" + resetIndex);
		if (resetIndex) {
			diagnosis.info(localizedText("deleteIndex", "index" + category.$name + ".json"));
			deteteIndex(_, indexpath, category, frame.options);
			category.reset();
		}
		// frame.options.conflictPolicy = this.options.conflictPolicy;
		index = readIndex(_, indexpath, category, frame.options);
		// tracer && tracer("initFrame: indexpath=" + indexpath + "\n\tcategory=" + JSON.stringify(category, null, 2) + "\n\tindex=" + JSON.stringify(index, null, 2));
		tracer && tracer("initFrame: indexpath=" + indexpath + "\n\tcategory=" + JSON.stringify(category, null, 2));
		this.store.reset(_, frame);
		frame.langMap = this.getLanguages(_).x3ToIso;
		_isoToX3 = this.getLanguages(_).isoToX3;

		currentAdminIncludes = (currentWorld.getDeliveryFiles && currentWorld.getDeliveryFiles(_)) || adminIncludes;
		tracer && tracer("initFrame: currentAdminIncludes=" + currentAdminIncludes);
		frame.indexMap = {};
		Object.keys(index).forEach(function(gk) {
			if (gk[0] === "$") return;
			g = index[gk];
			Object.keys(g).forEach(function(ek) {
				if (ek[0] === "$") return;
				e = g[ek];
				frame.indexMap[e.$key] = e;
			});
		});

		if (!opt.loadFromIndex && !opt.ignoreIndexEndpoint) {
			if (index.$config.$target.endpoint && index.$config.$target.endpoint.$uuid !== endpoint.$uuid) {
				return diagnosis.fatal(localizedText("endpointMismatch", index.$config.$chapter.$name, index.$config.$target.endpoint.$uuid, index.$config.$target.endpoint.name, endpoint.$uuid, endpointName), null);
			}
			index.$config.$target = {
				endpoint: {
					$uuid: endpoint.$uuid,
					name: endpointName,
					description: endpoint.description(_)
				}
			};
		}

		index.$config.$source = {
			user: {
				login: this.context.getUser(_).login(_)
			},
			host: {
				name: os.hostname(),
				platform: os.platform() + "-" + os.arch()
			}
		};

		tracer && tracer(msgkey + " " + index.$chapter.$name + " to " + endpoint.$uuid + " (" + (endpoint.x3ServerFolder(_) || "") + " - " + endpoint.description(_) + ")");
		diagnosis.info(localizedText(msgkey, index.$chapter.$name, endpoint.description(_)));

		var $lastModified = index.$config.$chapter.$lastModified;
		fetchOpt.lastModified = opt.useLastModified && $lastModified && datetime.parse($lastModified).toString(isoDateFormat);
		frame.count = index.$chapter.$count;
		tracer && tracer("initFrame: opt=" + sys.inspect(opt) + ", fetchOpt=" + sys.inspect(fetchOpt));
		if (opt.fetchRecords) {
			if (opt.loadFromIndex) {
				frame.x3RecordSet = this.store.initFromIndex(index);
			} else {
				frame.x3RecordSet = this.store.getX3RecordSet(_, index.$chapter, fetchOpt);
				this.store.dumpToPlainFile(_, fsp.join(this.targetDir, "output", "messages-fetched"));
			}
		} else {
			frame.x3RecordSet = this.store.set;
			frame.x3RecordSet.initChapter(category.$min, category.$max);
			this.store.fullyLoaded = true;
		}
		delete index.$config.$chapter.$exclude; // no longer persist it		

		frame.index = index;
		frame.indexpath = indexpath;
		return this.frame;
	},

	endExtract: function(_) {
		var endpoint = this.store.endpointWrite,
			frame = this.frame,
			diagnosis = this.diagnosis,
			index = frame.index,
			count = frame.count,
			options = frame.options,
			afs = (options.indexFiler || fs),
			$chapter = index.$config.$chapter,
			added = $chapter.$count - count;

		this.fillDefault(_);

		delete index.$chapter;
		index.$config.$lastModified = datetime.now().toString();
		tracer && tracer("End extractResources at " + index.$config.$lastModified + ", " + added + " text(s) added");
		afs.writeFile(frame.indexpath + ".tmp", JSON.stringify(index, null, "\t"), "utf8", _);

		this.saveRejected(_);

		diagnosis.info(localizedText("flushRecords", $chapter.$name, added));
		this.store.flush(_);
		$chapter.$lastModified = this.store.getLastUpdate(_, $chapter);
		afs.writeFile(frame.indexpath, JSON.stringify(index, null, "\t"), "utf8", _);
		afs.unlink(frame.indexpath + ".tmp", _);
		if (added > 0) {
			diagnosis.info(localizedText("endExtractResources", $chapter.$name, endpoint.description(_), added));
		} else {
			diagnosis.info(localizedText("endExtractResourcesNoText", $chapter.$name, endpoint.description(_)));
		}
		diagnosis.logClose();
	},

	saveRejected: function(_) {
		if (!this.rejectedUpdates || this.rejectedUpdates.length === 0)
			return;
		var mset = this.store.set,
			contents = "";
		this.rejectedUpdates.forEach(function(elt) {
			var entry = mset.getByKey(elt.$key),
				x3lang = elt.language.x3;
			if (!entry || !x3lang) return;
			var chunks = _splitMessage(elt.message);
			entry.forEach(function(e, i) {
				var parts = e.$origin && e.$origin.split("/");
				if (!(parts && parts[0] && parts[1]))
					return;
				var meta = e.$meta[x3lang] || {},
					lanori = meta.lanori || defaultLanguage.x3;
				contents += x3lang + "\t" + parts[0] + "\t" + parts[1] + "\t" + lanori + '\t' + chunks[i] + "-/vs/-" + e.text[x3lang] + '\n';
			});
		});
		if (contents) {
			var stamp = new Date().toISOString().replace(/:/g, "").replace(/T/g, "-").replace(/\..*$/, "");
			fs.writeFile(fsp.join(this.targetDir, "output", "messages-rejected-" + stamp + ".txt"), contents, "utf8", _);
		}
	},

	terminate: function(_) {
		var diagnosis = this.diagnosis;
		if (diagnosis.hasError()) diagnosis.fatal(localizedText("endsWithError"), null);
	},

	tryParseJsonFile: function(_, file) {
		try {
			return JSON.parse(fs.readFile(file, "utf8", _));
		} catch (e) {
			return this.diagnosis.fatal(localizedText("incorrectJsonFormat", file), e.stack);
		}
	},

	///   
	/// ### extractAll(_)
	/// Extract all types of resources (Syracuse source, Administration space, Office add-ins)
	extractAll: function(_) {
		var opt = _extend(this.options, {
				operation: "extract",
				// if no dictionary is provided then fetch records
				fetchRecords: !this.options.dictionary,
				// longMessagesStrategy: "truncate",
				extractAllLanguages: true,
			}, true),
			resourcesOpts = opt.resources || {},
			skip = transCfg.skip || {};

		tracer && tracer("extractAll");

		resourcesOpts.syracuse && !skip.syracuse && this.extractRes(_, resourceHandler(_, "syracuse", this, opt));
		resourcesOpts.dotnet && !skip.dotnet && this.extractRes(_, resourceHandler(_, "dotnet", this, opt));
		resourcesOpts.admin && !skip.admin && this.extractAdminResources(_, resourceHandler(_, "admin", this, opt));
		// resourcesOpts.admin && !skip.admin && this.extractRes(_, resourceHandler(_, "admin", this, opt));
	},

	extractRes: function(_, handler) {
		try {
			this.clearMessagesFile(_, handler.category);
			this.extract(_, handler);
			if (this.options.verify) {
				this.verifyExtract(_);
			}
		} catch (e) {
			this.diagnosis.fatal(e.message || e, e.stack);
		}
	},

	clearMessagesFile: function(_, chapter) {
		tracer && tracer("clearMessagesFile of " + _getMessageFileName(this.messagesFilePrefix, chapter));
		fs.writeFile(_getMessageFileName(this.messagesFilePrefix, chapter), "Language\tChapter\tNumber\tText\n", "utf8", _);
	},

	fillDefault: function(_) {
		var self = this,
			options = this.options,
			store = this.store,
			frame = this.frame,
			diagnosis = this.diagnosis,
			index = frame.index,
			chapter = index.$chapter || index.$config.$chapter,
			langMaps = this.getLanguages(_),
			isoToX3 = langMaps.isoToX3,
			x3ToIso = langMaps.x3ToIso,
			frCulture = {
				iso: "fr-fr",
				x3: isoToX3["fr-fr"]
			},
			defopt = {
				lanori: ""
			};

		var dictionary = options.dictionary || messageStore.dictionary;
		diagnosis.info("Filling default values of " + chapter.$name);

		function _compatibleLang(code) {
			var l = x3ToIso[code].split("-")[0];
			return isoToX3[l];
		}

		// fill default values based on the index
		Object.keys(index).forEach(function(gk) {
			// group
			if (gk[0] === "$") return;
			var g = index[gk];
			Object.keys(g).forEach(function(ek) {
				// key
				if (ek[0] === "$") return;
				var e = g[ek];
				var texts = e.text;
				if (!texts) return;

				var refkey = e.$key;
				var refText = texts[defaultLanguage.iso];
				var curText;
				// if we provide a dictionary, get missing translations from it
				if (refText && dictionary) {
					Object.keys(x3ToIso).forEach(function(x3Lang) {
						if (x3Lang === defaultLanguage.x3) return;
						var iso = x3ToIso[x3Lang];
						var message;
						curText = texts[iso];
						if (curText == null || messageStore.isEqualPlaceHolder(curText)) {
							message = dictionary.getText(refText, x3Lang);
							// if (!message)
							// 	message = dictionary.getText(refText, _compatibleLang(x3Lang));
							if (message) {
								console.error("Fill missing: [" + [gk, ek, x3Lang, refText].join("/") + "] " + message);
								texts[iso] = message;
								self.upsertMessage(message, x3Lang, refkey, defopt);
							}
							// else {
							// 	message = placeholders.equal;
							// 	texts[iso] = message;
							// 	self.upsertMessage(message, x3Lang, refkey, defopt);
							// }
						} else if (options.rebuild && dictionary) {
							// change also existing message
							var proposals, fixes, fix;
							if (dictionary) {
								fix = null;
								self.autofixes = self.autofixes || {};
								fixes = self.autofixes[x3Lang] || (self.autofixes[x3Lang] = []);
								proposals = dictionary.get(refText, x3Lang);
								// have a proposal different from the current text
								if (proposals && proposals.length > 0 && (message = proposals[0][0]) !== curText) {
									var occurs = proposals.map(function(p) {
										return p[1];
									});
									fix = {
										original: curText,
										proposals: proposals,
										occurs: occurs,
										ref: refText
									};
									if (proposals.length === 1 || proposals[0][1] > proposals[1][1]) {
										// good confidence, use dic value without request verification
										texts[iso] = message;
										fix.applied = true;
										// console.error("Autofix mismatching translation: " + x3Lang + " index:[" + curText + "] vs. dic:[" + message + "](" + occurs + ") ref:[" + refText + "]");
									} else if (message.split(/\s/).length > 1) {
										// multiple proposals for a sentence, set lanori for requesting verification
										defopt.lanori = defaultLanguage.x3;
										texts[iso] = message;
										fix.applied = true;
										// console.error("Autofix mismatching translation: " + x3Lang + " index:[" + curText + "] vs. dic:[" + message + "](" + occurs + ") ref:[" + refText + "]");
									} else {
										defopt.lanori = defaultLanguage.x3;
										message = texts[iso];
										fix.applied = false;
										console.error("Multiple proposal for mismatching translation: " + x3Lang + " [" + fixes.length + "] index:[" + curText + "] vs. dic:[" + message + "](" + occurs + ") ref:[" + refText + "]");
									}
									fixes.push(fix);
									self.upsertMessage(message, x3Lang, refkey, defopt);
								}
								// reset lanori
								defopt.lanori = "";
							}
						}
					});
				}

				if (texts[frCulture.iso] == null) {
					texts[frCulture.iso] = refText;
					diagnosis.logInfo("Create default value in index for " + gk + "/" + ek + "/" + frCulture.iso);
				}
				Object.keys(texts).forEach(function(lk) {
					if (lk !== frCulture.iso && lk !== defaultLanguage.iso && texts[lk] === placeholders.equal) {
						store.setToDefault(_getLanguage(lk), e.$key);
						diagnosis.logInfo("Create default value in store for [" + e.chp + "/" + e.id + "/" + isoToX3[lk] + "] " + gk + "/" + ek + "/" + lk);
					}
				});
			});
		});

		console.error("Autofixes: " + sys.inspect(self.autofixes, {
			depth: 4
		}));
		store.ensureCulture(_, frCulture);
		diagnosis.info("End of filling default values of " + chapter.$name);
	},

	verifyExtract: function(_) {

		// To review
		return false;
		/*
		var frame = this.frame,
			diagnosis = this.diagnosis,
			index = frame.index,
			chapter = index.$chapter || index.$config.$chapter,
			x3RecordSet = this.store.getX3RecordSet(_, chapter, {
				noMeta: true
			}),
			meta = this.store.getX3RecordSet(_, chapter, {
				metaOnly: true
			}),
			count = 0,
			chp, id, i, txt, item, g, e, r, lan, values;

		diagnosis.info(localizedText("startVerifyExtraction", chapter.$name));
		diagnosis.info(localizedText("foundRecordRange", x3RecordSet.$count, chapter.$min, chapter.$max));

		function verify(_, vk) {
			txt = values[vk];
			lan = locale.x3Language(vk);
			r = item[lan];
			r && count++;

			!r && diagnosis.fatal(localizedText("entryNotFound", JSON.stringify(e), i, lan, JSON.stringify(item)), null);
		}

		Object.keys(index).forEach_(_, function(_, gk) {
			if (gk[0] === "$") return;
			g = index[gk];
			Object.keys(g).forEach_(_, function(_, ek) {
				if (ek[0] === "$") {
					// if (ek==="$key"){
					//	if (meta[e.chp] && meta[e.chp][id]
					// }
					// else
					return;
				}
				e = g[ek];
				chp = x3RecordSet[e.chp];
				id = e.id;
				if (!Array.isArray(id)) {
					id = [id, id];
				}
				for (i = id[0]; i <= id[1]; i++) {
					item = chp && chp[i];
					values = e.text;
					if (item) {
						values && Object.keys(values).forEach_(_, verify);
					} else {
						diagnosis.fatal(localizedText("noRecordFound", JSON.stringify(e), i), null);
					}
				}
			});
		});
		diagnosis.info(localizedText("endVerifyExtraction", chapter.$name, count));
		*/
	},


	///   
	/// ### extractAdminResources(_, handler)
	/// Extract admin resources from the resource pack export
	/// - The original json file is loaded, filtered and saved in the translations subdir
	extractAdminResources: function(_, handler) {
		// TODO: factorize with regular extract process

		var count = 0,
			diagnosis = this.diagnosis,
			endpoint = this.store.endpointWrite,
			rootpath = this.rootpath,
			self = this,
			refKeys,
			opt = handler.opt,
			isoToX3 = this.getLanguages(_).isoToX3;

		function _extractAllLang(_, fpath, fname, fsModule) {
			var destfile = self.getAdminTranslationDestDir(fpath),
				basename = fsp.basename(fpath),
				fullContent = self.tryParseJsonFile(_, fpath);

			var jsonContent = _filterJson(_, fullContent, _filterImport),
				filter = _filter(fpath),
				localizations = jsonContent.$localization = filter && filter(fullContent) || fullContent.$localization || {};

			if (!jsonContent)
				return;
			fs.writeFile(destfile, JSON.stringify(jsonContent, null, "\t"), "utf8", _);

			diagnosis.logInfo("extractAllLang fname=" + fname + ", path=" + fpath);
			refKeys = !filter && !transCfg.ignoreRefKeys && localizationKeys(fullContent);

			function _extractLang(_, lang) {
				tracer && tracer("_extractLang " + lang);
				if (!localizations[lang]) {
					diagnosis.error(localizedText("noLocalization", lang));
					return false;
				}
				var language = {
					iso: lang,
					x3: isoToX3[lang]
				};
				if (!language.x3) {
					diagnosis.error(localizedText("unknownLangMap", lang));
					return false;
				}
				return _extract(_, localizations[lang], fpath, language);
			}

			tracer && tracer("_extracting en-us " + fpath);
			// extract en-us as a reference for the index
			_extractLang(_, "en-us");

			// extract all other languages
			Object.keys(localizations).filter(function(lang) {
				return options.extractAllLanguages && (lang.toLowerCase() !== "en-us");
			}).forEach_(_, _extractLang);
		}

		function _groupKey(file) {
			var path = fsp.relative(rootpath, file);
			return path.replace(/\\/g, '\/');
		}

		function _extract(_, localizationRef, fpath, language) {
			var success = false,
				lang = language.iso,
				group = _groupKey(fpath),
				checkEntry = _checkEntry(_, self, localizationRef, index, group, language);
			diagnosis.logInfo(localizedText("extractTextsOf", "admin resource", group + ":" + lang));
			Object.keys(localizationRef).some_(_, function(_, key) {
				if (refKeys && !refKeys[key]) {
					return diagnosis.logWarning(localizedText("unusedText", localizationRef[key], key));
				}
				return checkEntry(_, key);
			});
		}

		var frame = this.initFrame(_, categories.admin, "startExtractResources", opt),
			index = frame.index,
			options = frame.options,
			category = categories.admin,
			include = currentAdminIncludes,
			path = options.exportFile ? options.dir || fsp.join(this.rootpath, "node_modules") : this.importDir;

		tracer && tracer("Start extraction " + index.$chapter.$name + " to " + endpoint.x3ServerFolder(_) + " (" + endpoint.description(_) + ")");
		tracer && tracer("\tinclude=" + include + "\n\texclude=" + category.$exclude);

		count = index.$chapter.$count;
		if (options.exportFile) {
			_extractAllLang(_, fsp.join(path, options.exportFile), options.exportFile, options.inputFiler);
		} else {
			var stat = fs.stat(path, _);
			if (stat.isDirectory()) {
				var dircontent = fs.readdir(path, _);
				tracer && tracer("dircontent: " + dircontent);
				dircontent = dircontent.filter(function(elt) {
					return (include && include.indexOf(elt) != -1 || !include) && !category.isExcluded(elt);
				});
				tracer && tracer("dircontent after filtering: " + dircontent);

				dircontent.forEach_(_, function(_, fnam) {
					_extractAllLang(_, fsp.join(path, fnam), fnam, options.inputFiler);
				});
			}
		}
		this.endExtract(_);
	},

	// *******************  UPDATE ********************
	///   
	/// ### updateAll(_)
	/// Update all types of resources (Syracuse source, Administration space, Office add-ins)
	updateAll: function(_) {
		var self = this,
			opt = _extend(this.options, {
				operation: "update",
				fetchRecords: true
					// useLastModified: true
			}, true),
			resourcesOpts = opt.resources || {},
			skip = transCfg.skip || {},
			handler;

		["syracuse", "dotnet", "admin"].forEach_(_, function(_, resType) {
			resourcesOpts[resType] && !skip[resType] && self.update(_, resourceHandler(_, resType, self, opt));
		});
	},

	endUpdate: function(_) {
		var endpoint = this.store.endpointWrite,
			frame = this.frame,
			diagnosis = this.diagnosis,
			index = frame.index,
			options = frame.options,
			afs = (options.indexFiler || fs),
			$chapter = index.$config.$chapter;

		delete index.$chapter;

		index.$config.$lastModified = datetime.now().toString();
		tracer && tracer("End updateResources lastModified=" + index.$config.$lastModified);
		$chapter.$lastModified = this.store.getLastUpdate(_, $chapter);

		if (frame.updated > 0) {
			afs.writeFile(frame.indexpath, JSON.stringify(index, null, "\t"), "utf8", _);
			diagnosis.info(localizedText("endUpdateResources", $chapter.$name, endpoint.description(_), frame.updated));
		} else {
			// save index modifications
			diagnosis.info(localizedText("endUpdateResourcesNoText", $chapter.$name, endpoint.description(_)));
		}
		diagnosis.logClose();
	},

	update: function(_, handler) {
		var diagnosis = this.diagnosis,
			opt = handler.opt,
			ignoreChecksum = opt.ignoreChecksum,
			self = this,
			useTheir = opt.useTheir;

		self.files = self.files || {};
		self.files.modified = self.files.modified || [];
		self.files.deleted = self.files.deleted || [];

		function updFile(_, k) {
			diagnosis.logInfo(localizedText("updateTextsOf", handler.desc, k));
			tracer && tracer("updFile: " + k);

			function saveData(_) {
				tracer && tracer("save data updateCtx=" + sys.inspect(updateCtx));
				flows.eachKey(_, updateCtx, function(_, lang, src) {
					tracer && tracer("save data src of lang " + lang + ": " + JSON.stringify(src, null, 2));
					if (!fs.exists(fsp.dirname(src.file), _)) {
						tracer && tracer("Folder : " + fsp.dirname(src.file) + " does not exist");
						return;
					}

					var data = src.data || {},
						resources = data && data.resources;

					if (src.dirty && !data.saved) {
						if (resources && Object.keys(resources).length > 0) {
							try {
								tracer && tracer("write to file: " + src.file + " content: " + JSON.stringify(data));
								self.files.modified.push(src.file);
								handler.save(src.file, data, base, {
									iso: langMap[lang],
									x3: lang
								}, _);
							} catch (ex) {
								diagnosis.fatal(localizedText("fileWritingError", src.file), ex.stack);
							}
						} else {
							tracer && tracer("delete file: " + src.file + " exists: " + src.exists);
							self.files.deleted.push(src.file);
							src.exists && fs.unlink(src.file, _);
						}
						src.dirty = false;
					}
					handler.close && handler.close(src.file);
				});
			}

			function updData(_, key) {
				var el = segment[key],
					content, resources;
				tracer && tracer("updData: " + key + ' ' + JSON.stringify(el, null, 2));

				function loadLocalData(_, langs) {
					langs.forEach_(_, function(_, lang) {
						if (lang === "XXX") return;
						var src = updateCtx[lang] = updateCtx[lang] || {};
						if (src.data) return;
						src.isolang = langMap[lang];
						if (!src.isolang) {
							src.data = {};
							return;
						}
						var file = self.localeFile(_, base, lang, handler.localeExt),
							language = {
								iso: src.isolang,
								x3: lang
							};
						src.file = file;
						src.exists = fs.exists(file, _);
						if (src.exists) {
							src.data = handler.load(_, file, language);
						} else {
							tracer && tracer("resources file deleted or moved: " + file);
							// diagnosis.logWarning(localizedText("missingFile", file, lang));
							src.isDefault = true;
							src.data = handler.loadDefault(_, file, language);
						}
					});
					// tracer && tracer("loadLocalData context: " + JSON.stringify(updateCtx, null, 2));
				}

				var rec = x3RecordSet.reassembleEntry(el.$key);

				tracer && tracer("loadLocalData for record " + sys.inspect(rec));
				if (rec && rec.text) {
					loadLocalData(_, Object.keys(rec.text));
					var refLang = defaultLanguage.x3,
						refObj = _getRefObj(rec.$key),
						ref = refObj.key,
						eRef = ref && frame.indexMap[ref];
					if (!ref && !ignoreChecksum) {
						return diagnosis.fatal(localizedText("missingReference", k, key), null);
					}
					Object.keys(langMap).sort(refLangSorter(refLang)).forEach_(_, function(_, lang) {
						if (lang === "XXX") return;
						var targetText = rec.text[lang];
						if (targetText) {
							var src = updateCtx[lang] || (updateCtx[lang] = {}),
								refRes = ((updateCtx[refLang] || {}).data || {}).resources,
								targetRefText = rec.text[refLang];
							if (!refRes) {
								tracer && tracer("No reference ressource for " + sys.inspect(rec));
								return;
							}
							var resources = src.data && src.data.resources,
								sourceText,
								refText = refRes[key],
								isolang = src.isolang || (src.isolang = langMap[lang]),
								indexText = el.text[isolang],
								conflictFix = getConflictText(el.$key, isolang),
								re, equalsToRefLang;

							tracer && tracer("refLangText=" + sys.inspect(refText));
							tracer && tracer("rec[" + lang + "]: " + sys.inspect(targetText));
							if (opt.loadFromIndex && (!refText || lang === refLang)) {
								(lang != refLang) && tracer && tracer("No reference ressource text");
								return;
							}
							if (!resources) {
								diagnosis.logWarning("File deleted or moved or text not in reference language: key=" + key + ", $key=" + el.$key + ", lang=" + lang + ", targetText=" + targetText + ", refText=" + refText + ", indexText=" + indexText);
								return;
							}
							var e0 = rec.$entry[0],
								ref0 = e0.text[refLang],
								text0 = e0.text[lang];

							if (text0 && text0 != placeholders.equal && /\s*_$/.exec(text0) && rec.$entry.length < 2) {
								diagnosis.logWarning("text is truncated for lang " + lang + " only one line exist for " + " $key " + rec.$key + " : key=" + key + "\nreftext=" + ref0 + "\n   text=" + text0);
								return;
							}

							sourceText = resources[key];
							src.file = src.file || self.localeFile(_, base, lang, handler.localeExt);
							if (lang !== refLang) {
								equalsToRefLang = messageStore.isEqualPlaceHolder(targetText) || targetText === refText;
								if (!equalsToRefLang) {
									re = new RegExp("^" + _escapeRegExp(refText) + "\\s+$");
									equalsToRefLang = re.exec(targetText);
								}
								if (equalsToRefLang) {
									tracer && tracer("Text equal to default ENG " + k + "/" + key + "[" + lang + "] value=" + targetText);
									// no longer delete when source is different to have a chance to push the translation
									if (sourceText != null) {
										// if (sourceText != null && sourceText === targetText) {
										if (handler.keepEqualToRef) {
											resources[key] = refText;
										} else {
											delete resources[key];
										}
										src.dirty = true;
									}
									el.text[isolang] = lang === "FRA" ? targetText : placeholders.equal;
									return;
								}
							}

							if (refText == null) {
								targetText = null;
								if (sourceText != null) {
									delete resources[key];
									src.dirty = true;
								}
							} else if (targetText != indexText || !src.exists) {
								tracer && tracer("Modified in X3 " + k + "/" + key + "[" + lang + "] old value=" + indexText + " new value=" + targetText);
								// tracer && tracer("src.data lang: " + lang + ' ' + JSON.stringify(src.data, null, 2));
								if (src.exists && indexText && sourceText) {
									if (!messageStore.isSimilar(sourceText, indexText) && !messageStore.isEqualPlaceHolder(indexText)) {
										if (messageStore.isSimilar(targetText, sourceText)) {
											tracer && tracer("update index " + k + "/" + key + ": '" + el.text[isolang] + "' => '" + targetText + "'");
										} else if (lang === refLang) {
											diagnosis.error("Reference language text has been modified: " + rec.$key + " - " + k + "/" + key + " - " +
												e0.$origin + "/" + lang + ", s=" + sourceText + ", t=" + targetText + ", i=" + indexText);
											targetText = null;
										} else {
											tracer && tracer("update conflict for " + k + "/" + key + "[" + lang + "]\ns=" + sourceText + "\nt=" + targetText + "\ni=" + indexText);
											if (conflictFix == null && !messageStore.isSimilar(targetText, indexText) && !useTheir) {
												diagnosis.error(localizedText("updateConflict", rec.$key + " - " + k + "/" + key, e0.$origin + "/" + lang, sourceText, targetText, indexText));
												targetText = null;
											}
										}
									}
								}
							}
							// else if (sourceText != indexText && targetText === indexText) {
							// 	if (sourceText === refText && lang != refLang)
							// 		diagnosis.logWarning("Priority has been given to the translation because the source text is equal to the reference text and the culture is not the default one: lang=" + //
							// 			lang + ", targetText=" + targetText + ", sourceText=" + sourceText + ", indexText=" + indexText + ", refText=" + refText);
							// 	else if (sourceText != null) {
							// 		targetText = sourceText;
							// 	}
							// }
							if (targetText) {
								if (conflictFix != null) {
									targetText = conflictFix;
									tracer && tracer("force value of " + k + "/" + key + "[" + isolang + "]' to '" + targetText + "'");
								}
								tracer && tracer("update record lang: " + lang + ", key: " + key);
								resources[key] = el.text[isolang] = targetText;
								src.dirty = src.dirty || (targetText != sourceText);
								if (targetText != sourceText) {
									// console.error("update " + k + "/" + key + "[" + isolang + "]'\n  from '" + sourceText + "'\n  to   '" + targetText + "'")
									frame.updated++;
								}
							}
						}
					});
				}
			} // updData
			var base = k.replace(/\//g, fsp.sep),
				updateCtx = {},
				segment = index[k];
			// tracer && tracer("index[" + k + "]=" + JSON.stringify(segment, null, 2));
			Object.keys(segment).filter(function(k) {
				return k[0] !== "$";
			}).forEach_(_, updData);

			saveData(_);
		}

		var frame = this.initFrame(_, handler.category, "startUpdateResources", opt),
			index = frame.index,
			langMap = frame.langMap,
			x3RecordSet = frame.x3RecordSet;
		frame.updated = 0;

		Object.keys(index).filter(function(k) {
			tracer && tracer("filter update k=" + k + ", " + (!(handler && handler.matchGroup) || handler.matchGroup(k)));
			return k[0] !== "$" && (!(handler && handler.matchGroup) || handler.matchGroup(k));
		}).forEach_(_, updFile);
		this.endUpdate(_);
	},

	updateFromFile: function(_, fileName) {
		var ext = fsp.extname(fileName),
			file = fsp.join(this.targetDir, fileName) + (!ext ? ".txt" : ""),
			data = fs.exists(file, _) && fs.readFile(file, "utf8", _);

		this.diagnosis.logInfo("updateFromFile " + file + " with data:\n" + data);
		if (data && this.store.load(data) > 0) {
			this.store.updateAll(_);
		}
	},

	updateIndexfromCsv: function(_, file) {
		var opt = _extend(this.options, {
				operation: "updateIndex",
			}, true),
			handler = resourceHandler(_, "syracuse", this, opt),
			category = handler.category;
		file = file || fsp.join(this.targetDir, "translated-fr-FR.csv");
		tracer && tracer("file = " + file);
		var indexpath = fsp.join(this.targetDir, "index" + category.$name + ".json");
		var index = readIndex(_, indexpath, category, opt);
		var data = fs.exists(file, _) && fs.readFile(file, "utf8", _),
			lines;
		if (data) {
			data = data.replace(/\r\n/g, "\n");
			data = data.replace(/\r/g, "\n");
			lines = data.split("\n");
			lines.forEach(function(l) {

			});
		}
		tracer && tracer("index = " + JSON.stringify(index, null, 2));
		tracer && tracer("lines = " + (lines || []).length);
	},

	smartCopy: function(_) {
		var opt = this.options || {},
			resOpt = opt.resources || {},
			skip = transCfg.skip || {};
		resOpt.syracuse && !skip.syracuse && this.store.smartCopy(_, categories.syracuse.$min, categories.syracuse.$max);
		resOpt.dotnet && !skip.dotnet && this.store.smartCopy(_, categories.dotnet.$min, categories.dotnet.$max);
		resOpt.admin && !skip.admin && this.store.smartCopy(_, categories.admin.$min, categories.admin.$max);
	},

	downloadToFile: function(_, parameters) {
		if (!parameters.fileName)
			return;

		var ext = fsp.extname(parameters.fileName),
			file = fsp.join(this.targetDir, parameters.fileName),
			deltaFile,
			set,
			opt = {};

		if (ext) {
			file = file.substring(0, file.length - ext.length);
		} else {
			ext = ".txt";
		}
		if (/-\d{5}-\d{5}$/.exec(file) == null) {
			file += parameters.chapterStart + "-" + parameters.chapterEnd;
		}
		file += "-" + new Date().toISOString().replace(/:/g, "").replace(/T/g, "-").replace(/\..*$/, "");
		deltaFile = file + "-delta" + ext;
		file += ext;
		this.diagnosis.logInfo("downloadToFile " + file);
		opt.set = new messageStore.MessageSet();
		set = this.store.get(_, parameters.chapterStart, parameters.chapterEnd || parameters.chapterStart, parameters.langFilter, parameters.stampFilter, opt);
		set.dumpToPlainFile(_, file);
		if (parameters.fixUntranslated) {
			set.fixUntranslated(_, parameters.fixUntranslated.toUpperCase());
			var delta = set.sync();
			delta.dumpToPlainFile(_, deltaFile);
		}
	},

	///   
	/// ### deleteAll(_)
	/// * options: options including diagnosis tracker
	/// Delete all entries in message storage
	deleteAll: function(_) {
		var count = 0,
			resourcesOpts = this.options.resources || {},
			skip = transCfg.skip || {},
			self = this,
			diagnosis = this.diagnosis,
			categ;

		tracer && tracer("deleteAll: ");
		Object.keys(categories).forEach_(_, function(_, k) {
			if (k.charAt(0) === "$" || !resourcesOpts[k] || skip[k]) return;
			categ = categories[k];
			diagnosis.info("Deleting " + categ.$min + ".." + categ.$max);
			self.store.deleteAll(_, categ.$min, categ.$max);
		});
		diagnosis.info(localizedText("deleteTotalRecords", count));
	}

});

function indexDir(options) {
	return options && options.indexdir || fsp.join(__dirname, "../../../translation-indexes");
}

function makeDiagnosisCollectors(options) {
	var collector, fatal;
	var logName = fsp.join(indexDir(options), "translation.log");
	var fd, hasError;
	var nfs = require("fs");
	var buf = [];
	fd = nfs.openSync(logName, "w+", "0666");
	nfs.closeSync(fd);

	function flush() {
		nfs.appendFile(logName, buf.join("\n"), "utf8", function(err) {
			if (err) return console.error(err);
		});
		buf = [];
	}

	function appendMessage(severity, message) {
		buf.push(datetime.now() + " [" + severity.toUpperCase() + "] " + message);
		if (buf.length > 500) {
			flush();
		}
		traceDiagnosis && tracer && tracer("Diagnosis - " + severity + ": " + message);
	}

	function logger(severity, message) {
		hasError = hasError || severity.toLowerCase() === "error";
		appendMessage(severity, message);
	}

	fatal = function(message, stack) {};

	if (options && options.$tracking) {
		tracer && tracer("makeDiagnosisCollectors with options.$tracking");
		collector = function(severity, message, phaseDetail) {
			hasError = hasError || severity.toLowerCase() === "error";
			options.$tracking.push({
				$severity: severity,
				$message: message,
				$phaseDetail: phaseDetail
			});
		};
		fatal = function(message, stack) {
			hasError = true;
			var d = {
				$severity: "error",
				$message: message
			};
			if (stack) d.$stackTrace = stack;
			options.$tracking.push(d);
			logger("error", message + (stack ? "\n" + stack : ""));
		};
	} else if (options.$addDiagnose) {
		tracer && tracer("makeDiagnosisCollectors with options.$addDiagnose");
		collector = function(severity, message) {
			hasError = hasError || severity.toLowerCase() === "error";
			options.$addDiagnose(severity, message);
		};
	} else {
		tracer && tracer("makeDiagnosisCollectors with tracer");
		traceDiagnosis = true;
		collector = function(severity, message) {
			hasError = hasError || severity.toLowerCase() === "error";
		};
	}

	function dualReportAll(diag) {
		diag && diag.forEach(function(d) {
			dualReport(d.$severity, d.$message);
		});
	}

	function dualReport(severity, message) {
		collector(severity, message);
		logger(severity, message);
	}

	return {
		info: dualReport.bind(undefined, "info"),
		warning: dualReport.bind(undefined, "warning"),
		error: dualReport.bind(undefined, "error"),
		add: dualReport,
		addAll: dualReportAll,
		fatal: fatal,
		logInfo: logger.bind(undefined, "info"),
		logError: logger.bind(undefined, "error"),
		logWarning: logger.bind(undefined, "warning"),
		logClose: function() {
			flush();
			// nfs.close(fd, function(err) {
			// 	fd = undefined;
			// 	if (err) return console.error(err);
			// });
		},
		hasError: function() {
			return hasError;
		}
	};
}

function deteteIndex(_, indexpath, chapter, options) {
	var fsModule = options && options.indexFiler || fs;
	fsModule.exists(indexpath, _) && fsModule.unlink(indexpath, _);
	tracer && tracer("deteteIndex: indexpath=" + indexpath);
	if (fsModule.exists(indexpath, _)) tracer && tracer("deteteIndex not deleted: indexpath=" + indexpath);
}

function readIndex(_, indexpath, chapter, options) {
	tracer && tracer("indexpath: " + indexpath);
	var fsModule = options && options.indexFiler || fs,
		diags = options && options.$tracking,
		index, data = fsModule.exists(indexpath, _) && fsModule.readFile(indexpath, "utf8", _);
	if (!data) {
		index = {};
		tracer && tracer("data is empty ");
	} else {
		try {
			index = JSON.parse(data);
			// tracer && tracer("index data " + JSON.stringify(index, null, 2));
		} catch (e) {
			throw new Error(localizedText("incorrectJsonFormat", indexpath));
		}
		_traverse(index, function(context, gv, ev, tv) {
			if (ev != null) {
				if (ev.chp != null) delete ev.chp;
				if (ev.id != null) delete ev.id;
				return false;
			}
		});
	}

	function _newEntry(index, group, ident, val, language) {
		var segment = index[group] || (index[group] = {}),
			e;
		segment.$key = segment.$key || sha1(group);

		e = {
			group: group,
			ident: ident,
			val: val || placeholders.equal,
			language: language || defaultLanguage,
			index: index,
			segment: segment,
			$key: sha1(segment.$key + "/" + ident),
		};
		e.keyString = e.group + "/" + e.ident + "['" + e.language.iso + "']";
		return e;
	}

	function _traverse(index, cb) {
		if (typeof(cb) != "function") return;
		var context = {};
		forEachKey(index, function(gk, gv) {
			context.groupKey = gk;
			if (gk[0] === "$") return;
			if (cb(context, gv) === false) return;
			forEachKey(gv, function(mk, mv) {
				context.entryKey = mk;
				if (mk[0] === "$") return;
				if (cb(context, gv, mv) === false) return;
				forEachKey(mv.text, function(tk, tv) {
					context.langKey = tk;
					cb(context, gv, mv, tv);
				});
			});
		});
	}


	index.newEntry = _newEntry.bind(null, index);
	index.traverse = _traverse.bind(null, index);

	return _initIndexChapter(index, chapter);
}

function _initIndexChapter(index, chapter) {
	chapter = _clone(chapter);
	index.$config = index.$config || {};
	index.$config.$createDate = index.$config.$createDate || datetime.now().toString();
	index.$config.$lastModified = index.$config.$lastModified || index.$config.$createDate;
	index.$config.$chapter = _extend(chapter, index.$config.$chapter, true, true);
	index.$config.$target = index.$config.$target || {};
	index.$config.$source = index.$config.$source || {};

	delete index.$config.$chapter.$current;
	delete index.$config.$chapter.$;

	index.$chapter = index.$config.$chapter;
	return index;
}

var langRegex = {
	".json": /^(.+?)(-(\w{2}(-\w{2})?))$/i,
	".resx": /^(.+?)(\.(\w{2}(-\w{2})?))?$/i
};
var languageMap = {};
var _isoToX3 = {};

function _getLanguage(isolang) {
	return languageMap[isolang] || (languageMap[isolang] = {
		iso: isolang,
		x3: _isoToX3[isolang] //locale.x3Language(isolang, true)
	});
}

function _fileInfo(file, basedir, handler) {
	var extFilter = handler.ext,
		ext = fsp.extname(file);
	if (extFilter && !(ext && ext.toLowerCase() === extFilter.toLowerCase())) {
		tracer && tracer("_fileInfo " + file + ", ext=" + ext + ", extFilter=" + extFilter + " does not match");
		return;
	}

	var fpath = fsp.join(basedir, file),
		rootpath = handler.rootpath,
		path = fsp.relative(rootpath, fpath),
		dirname = fsp.dirname(path),
		basename = fsp.basename(path, ext),
		m = langRegex[ext] && langRegex[ext].exec(basename),
		isoMap = handler.context.languages.isoToX3,
		lang, language;
	if (!m) {
		tracer && tracer("_fileInfo " + file + ", ext=" + ext + ", extFilter=" + extFilter + " does not match regex " + langRegex[ext]);
		return;
	}
	lang = (m && m[3] || "en").toLowerCase();
	lang = m && lang && !m[4] ? locale.longIso(lang) : lang;
	// if (!lang) {
	// 	tracer && tracer("_fileInfo " + file + ", ext=" + ext + ", extFilter=" + extFilter + " lang is null");
	// 	return;
	// }
	language = _getLanguage(lang);

	tracer && tracer("_fileInfo " + file + ", ext=" + ext + ", basename=" + basename + " matches: [" + m + "]");
	return {
		file: fpath,
		filename: file,
		group: m && fsp.join(dirname, m[1]).replace(/\\/g, '\/'),
		language: language
	};
}

function _checkEntry(_, translation, resources, index, grpkey, language) {
	language = language || defaultLanguage;

	var segment = grpkey && index[grpkey],
		options = translation.options,
		ignoreChecksum = options.ignoreChecksum,
		diagnosis = translation.diagnosis,
		isoLang = language.iso,
		isoDef = defaultLanguage.iso,
		dictionary = options.dictionary;

	return function(_, key) {
		if (!grpkey) return;

		var message = resources[key],
			el = segment && segment[key],
			texts = el && el.text || {};

		if (isoLang != isoDef) {
			if (texts[isoDef] == null) {
				console.error("Missing text for default language '" + isoDef + "', cannot add text: " + [grpkey, key, language.x3, message].join("/"));
				return;
			} else if (isoLang != "fr-fr" && texts[isoDef] === message)
				message = placeholders.equal;
		}
		var entry = index.newEntry(grpkey, key, message, language),
			status = null;

		tracer && tracer("_checkEntry: key=" + grpkey + ':' + key + ", language=" + [language.x3, language.iso].join(":") + "message='" + resources[key] + "', indexEntry=" + sys.inspect(el || {}));
		if (message === null) {
			message = "";
			diagnosis.logWarning(localizedText("nullValue", entry.keyString));
		} else if (typeof(message) !== "string") {
			return diagnosis.logWarning(localizedText("incorrectType", entry.keyString, typeof(message), JSON.stringify(message)));
		}
		if (message && (options.longMessagesStrategy === "truncate") && (message.length > aplStdMaxLength)) {
			message = message.substring(0, aplStdMaxLength);
			diagnosis.logWarning(localizedText("msgTooLong", grpkey, key, aplStdMaxLength, message));
		}
		if (/\ufffd/g.exec(message)) {
			console.error("Message containing invalid utf-8 char: " + message);
			return diagnosis.logWarning("Message containing invalid utf-8 char: " + message);
		}
		if (el) {
			// text entry is in the index
			if (!ignoreChecksum && el.$key !== entry.$key) {
				diagnosis.fatal(localizedText("checksumMismatch", "check", el.chp, el.id, isoLang, JSON.stringify(entry.$key), JSON.stringify(el.$key)), null);
				return true;
			}
			status = translation.updateEntry(_, el, entry);
		} else {
			status = translation.addNewEntry(_, entry);
		}
		return status && status.fatal;
	};
}

function _filterLocalizations(json) {

	var localization = json.$localization || {},
		langs = localization && Object.keys(localization),
		items = json.$items || [],
		res = {},
		keys = {},
		menuBlocks = {},
		submodules = {},
		e;

	function addKey(item) {
		if (item.title) keys[item.title] = item;
		if (item.description) keys[item.description] = item;
	}

	function collectBlocks(mb) {
		if (!mb || !mb.code)
			return;
		addKey(mb);
		(mb.items || []).forEach(function(e) {
			if (e.$variantType === "menuBlock") {
				collectBlocks(e);
			}
		});
	}

	// Collect 
	// - Modules and submodules with application == "syracuse/collaboration"
	// - Module where code == "Viewpages" or "STD_X3_ERP_EDI" and associated submodule/blocks
	// - PageDef device == "mobile" and associated pageData
	items.forEach(function(item) {
		var isAdmin = _isAdmin(item);
		// if (item.$type === "menuItem" && item.linkType === "$representation" && item.$factoryOwner === "SAGE") {
		if (["landingPage", "menuCategory", "portlet"].indexOf(item.$type) !== -1) {
			addKey(item);
		} else if (item.$type === "menuItem" && item.linkType === "$representation") {
			addKey(item);
		} else if (item.$type === "menuModule") {
			if (["STD_X3_HRM_SITES", "STD_X3_ERP_EDI", "STD_X3_ERP_CCM", "Viewpages"].indexOf(item.code) != -1 || isAdmin) {
				addKey(item);
				if (item.submodules && item.submodules.length > 0) {
					item.submodules.forEach(function(submodule) {
						submodules[submodule.code] = submodule;
					});
				}
			}
		} else if (item.$type === "menuBlock") {
			menuBlocks[item.code] = item;
		} else if (item.$type === "pageDef" && isAdmin && item.device === "mobile") {
			// title and description are not relevant
			item.variants && item.variants.forEach(function(v) {
				if (v.pageData && v.pageData.code) keys[v.pageData.code] = item;
			});
		} else if (item.$type === "dashboardDef" && item.mobile === true) {
			addKey(item);
			item.variants && item.variants.forEach(function(v) {
				addKey(v);
			});
		}
	});

	// Collect 
	// - MenuBlocks and subblocks of the collected modules
	forEachKey(submodules, function(mk, mv) {
		var mb = menuBlocks[mk];
		mb && collectBlocks(mb);
	});
	menuBlocks = null;
	submodules = null;

	// Keep only localization of the collected items
	langs && langs.forEach(function(lang) {
		res[lang] = res[lang] || {};
	});
	langs && langs.forEach(function(lang) {
		e = res[lang];
		var entries = localization[lang];
		entries && Object.keys(entries).forEach(function(key) {
			var m, lv;
			if (keys[key] || key.substring(0, 11) === "pageLayout." || ((m = /^pageData\.([\w\-]+)\./.exec(key)) && keys[m[1]])) {
				lv = entries[key];
				e[key] = lv;
				if (res["en-us"][key] == null) {
					var v = {};
					["en-us", "en-gb", "fr-fr", lang].some(function(l) {
						if (localization[l] && localization[l][key]) {
							v = {
								lang: l,
								value: localization[l][key]
							};
						}
						return !!v.value;
					}, {});
					console.error("missing [en-us] for " + key + ", use " + ("[" + v.lang + "] " + v.value));
					res["en-us"][key] = v.value;
				}
			}
		});
	});
	keys = null;

	return res;
}

function localizationKeys(json) {
	var proto = json && json.$prototypes,
		items = json && json.$items || [],
		localization = json && json.$localization && json.$localization["en-us"] || {},
		protoKeys = {},
		l10n = {},
		path = null,
		t, t0 = new Date().getTime();
	if (!proto || items.length === 0) return protoKeys;

	Object.keys(proto).forEach(function(type) {
		var t = protoKeys[type] = {};
		path = [];
		helpers.object.traverse(proto[type], {
			visit: function(key, val) {
				// tracer && tracer("visit path: " + path.join(".") + ", item: " + key + "=" + JSON.stringify(val));
				if (key[0] === "$") {
					if (key === "$localized" && Array.isArray(val)) {
						val.forEach(function(localized) {
							path.push(localized);
							// tracer && tracer("visit add protokey=" + path.join(".") + ", val=" + val);
							t[path.join(".")] = true;
							path.pop();
						});
					}
					return false;
				}
				path.push(key);
				return true;
			},
			leave: function(key, val) {
				// tracer && tracer("leave path: " + path.join(".") + ", item: " + key + "=" + JSON.stringify(val));
				path.pop();
			}
		});
	});
	// tracer && tracer("protoKeys=" + JSON.stringify(protoKeys));
	var prop;
	items.forEach(function(item) {
		t = item.$type && protoKeys[item.$type];
		// tracer && tracer("item type=" + item.$type);
		if (t) {
			path = [];
			helpers.object.traverse(item, {
				visit: function(key, val) {
					if (key[0] === "$") return false;
					path.push(key);
					// tracer && tracer("visit path: " + path.join(".") + ", item: " + key + "=" + JSON.stringify(val));
					if (t[path.join(".")]) {
						// tracer && tracer("visit add key=" + path.join(".") + ", val=" + val);
						l10n[val] = true;
					}
					return true;
				},
				visitLeaf: function(key, val) {
					// tracer && tracer("visitLeaf keys=" + key + ", val=" + val);
					if (typeof(val) === "string" && localization[val]) {
						// tracer && tracer("visitLeaf add key=" + key + ", val=" + val);
						l10n[val] = true;
					}
				},
				leave: function(key, val) {
					// tracer && tracer("leave path: " + path.join(".") + ", item: " + key + "=" + JSON.stringify(val));
					path.pop();
				}
			});
		}
	});
	tracer && tracer("localizationKeys elapsed=" + (new Date().getTime() - t0));
	return l10n;
}

exports.localizationKeys = localizationKeys;

function localizationExists(json, search) {
	var found;
	helpers.object.traverse(json, function(key, val) {
		if (found || key === "$localization") return false;

		if (typeof(val) === "string" && search === val) {
			found = key;
			return false;
		}
		return true;
	});

	return found;
}

var _getRefObj = messageStore.getRefObj;

function _getDotnetResources(input) {
	var xml = input.replace(/<!--([\s\S]*?)-->/gm, ""),
		regex = /<data*\sname="([\s\S]*?)"([\s\S]*?)>([\s\S]*?)<\/data>/gim,
		matches = {},
		match;

	while ((match = regex.exec(xml))) {
		var line = match[0],
			key = match[1],
			value = /<value>([\s\S]*?)<\/value>/gi.exec(match[3]),
			text = value && value[1] || "";

		// only string type information has to be processed
		if (!line.match(/<data[\s\S]*\s(type|mimetype)=[\s\S]*<\/data>/gi) && key.match(/^(?!&gt;&gt;).+\..+/)) {
			key = key.replace(/^\$(.*)/, "@$1");
			matches[key] = text;
			// tracer && tracer("key=" + key + ', text="' + text + '"');
		}
	}

	// tracer && tracer("_getDotnetResources: " + JSON.stringify(matches, null, 2));
	return matches;
}

function _updateProjectFile(_, iso, base, opt) {
	var diagnosis = opt && opt.diagnosis,
		file = fsp.basename(base),
		dirname = fsp.dirname(base),
		rootpath = opt.rootpath,
		module = fsp.basename(dirname),
		projPath = fsp.join(rootpath, dirname, module + ".csproj"),
		exists = fs.exists(projPath, _);
	if (!exists) {
		diagnosis && diagnosis.logWarning && diagnosis.logWarning(localizedText("fileNotFound", projPath));
		tracer && tracer("_updateProjectFile: base=" + base + ", Error: " + localizedText("fileNotFound", projPath));
		return;
	}
	var content = fs.readFile(projPath, "utf8", _),
		regex = _embeddedResourceRegEx(file, iso),
		match = regex.exec(content),
		regexNeutral, replacement;

	tracer && tracer("_updateProjectFile: base=" + base + ", file=" + file + ", proj=" + projPath + "\n\tmatch=" + match + ", regex=" + regex);
	if (!(match && match[0])) {
		regexNeutral = _embeddedResourceRegEx(file);
		content = content.replace(regexNeutral, function($0) {
			replacement = '';
			replacement += '\r\n    <EmbeddedResource Include="' + file + '.' + iso + '.resx">';
			replacement += '\r\n      <DependentUpon>' + file + '.cs</DependentUpon>';
			replacement += '\r\n      <SubType>Designer</SubType>';
			replacement += '\r\n    </EmbeddedResource>';
			return $0 + replacement;
		});

		replacement && fs.writeFile(projPath, content, "utf8", _);
	}
}

function _embeddedResourceRegEx(file, iso) {
	var s = '<EmbeddedResource\\s+Include="' + file + (iso ? '.' + iso : "") + '\\.resx">\\s*<DependentUpon>' + file + '\\.cs</DependentUpon>\\s*.*\\s*</EmbeddedResource>';
	//var s = '<EmbeddedResource[ ]+Include="' + file + '.resx">.*[^<]*<DependentUpon>[^<]*' + file + '.cs.*[^<]*' + '</DependentUpon>[\\s\\S]*?</EmbeddedResource>',
	return new RegExp(s);
}

function resourceHandler(_, type, context, opt) {
	var handlers = {
		"syracuse": {
			rootDirs: ["shadow-modules", "node_modules"].map(function(d) {
				return fsp.join(context.rootDir, d);
			}),
			ext: ".json",
			desc: "file",
			load: function(_, fullName, language) {
				// tracer && tracer("handler.load: " + JSON.stringify(fullName));
				var data = context.tryParseJsonFile(_, fullName);
				// todo later: generate uuid for the module
				// if (data && language.iso === defaultLanguage.iso && !data["$tuid"]) {
				// 	// generate a translation uid for the module
				// 	var old = data;
				// 	data = {
				// 		$tuid: uuid.generate()
				// 	};
				// 	data = _extend(data, old);
				// 	console.error("$uuid key not found: generating " + data["$tuid"]);
				// 	this.save(fullName, data, "", language, _);
				// }
				return {
					resources: data,
					raw: data
				};
			},
			loadDefault: function(_, fullName, language) {
				var data = {};
				return {
					resources: data,
					raw: data
				};
			},
			save: function(file, data, base, language, _) {
				fs.writeFile(file, JSON.stringify(data.raw || data, null, "\t"), "utf8", _);
			},
			localeExt: function(code) {
				return "-" + code + ".json";
			},
			skipDir: function(dir) {
				// tracer && tracer("handler.skip: " + JSON.stringify(file));
				return dir.name && (dir.name.charAt(0) === "." || dir.name === "test");
			},
			skipFile: function(fi) {
				// tracer && tracer("handler.skip: " + JSON.stringify(file));
				var skip;
				if (/^shadow-modules/.test(fi.group)) {
					// skip = !/^shadow-modules\/node_modules\/[^\/]+\/src\//.test(fi.group);
					skip = !/^shadow-modules\/win32-x64-v8-5\.0\/node_modules\/[^\/]+\/src\//.test(fi.group);
					if (!skip) {
						fi.group = fi.group.substring("shadow-modules/win32-x64-v8-5.0/".length);
					}
				}
				// skip && console.error("skipFile: " + fi.group);
				return skip || this.category.isExcluded(fi.group);
			},
			match: function(file) {
				// tracer && tracer("handler.match: " + JSON.stringify(file));
				return file.name && file.name === "resources";
			},
			matchGroup: function(group) {
				return !this.category.isExcluded(group);
			},
		},
		"dotnet": {
			rootDirs: [fsp.join(context.rootDir, "dotnet")],
			ext: ".resx",
			desc: "resx file",
			load: function(_, fullName, language) {
				tracer && tracer("dotnet.load: file=" + fullName);
				// tracer && tracer("handler.load: " + JSON.stringify(fullName));
				try {
					var xml = (opt.inputFiler || fs).readFile(fullName, _).toString("utf8");
					return {
						resources: _getDotnetResources(xml),
						raw: xml
					};
				} catch (e) {
					return {};
				}
			},
			loadDefault: function(_, fullName, language) {
				tracer && tracer("dotnet.loadDefault: file=" + fullName + ", language=" + JSON.stringify(language));
				var shortIso = _shortestLocale(language.iso, true);
				return this.load(_, fullName.replace(this.localeExt(shortIso), this.localeExt("en")), language);
			},
			save: function(file, data, base, language, _) {
				var langMap = context.getLanguages(_),
					resources = data.resources,
					input = data.raw,
					shortIso = _shortestLocale(language.iso, true);

				// never save en-gb
				if (shortIso === "en-gb")
					return;

				tracer && tracer("dotnet.save: file=" + file + ", data=" + JSON.stringify(data, null, 2));
				flows.eachKey(_, resources, function(_, key, value) {
					// Object.keys(data).forEach_(_, function(_, key) {
					// value = data[key];
					tracer && tracer("key: " + key + ", value: " + value);
					key = key.replace(/^@(.*)/, "$$$1");
					var s = '<data\\s+name="' + _escapeRegExp(key) + '".*>[^<]*<value>([^<]*)</value>[^<]*</data>',
						regex = new RegExp(s),
						block;
					if (regex.exec(input)) {
						input = input.replace(regex, function($0) {
							return ($0.replace(/<value>([\s\S]*?)<\/value>/, '<value>' + value + '<\/value>'));
						});
					} else {
						block = '\t<data name="' + key + '" xml:space="preserve">\n\t\t<value>' + value + '</value>\n</data>\n</root>'.replace(/\n/, os.EOL);
						input = input.replace(/<\/root>/, block);
					}
				});
				var exists = fs.exists(file, _);
				tracer && tracer("dotnet.save: File exists? " + exists);
				var fd = fs.open(file, "w+", "0666", _);
				fs.writeFile(file, input, "utf8", _);
				fs.close(fd, _);
				_updateProjectFile(_, shortIso, base, context);
			},

			localeExt: function(code) {
				return "." + code + ".resx";
			},
			skipDir: function(dir) {
				return dir.name && dir.name === "test";
			},
			match: function(file) {
				return true;
			},
		},

		// WARNING: Resources are loaded and saved from the import/translations folder and not from the original file
		"admin": {
			rootDirs: [fsp.join(context.rootDir, "import")],
			ext: ".json",
			desc: "admin ressource",
			keepEqualToRef: true,
			cache: {},
			saved: {},
			load: function(_, fullName, language) {
				var fullContent,
					data = this.cache[fullName],
					filter;
				if (!data) {
					// data = context.tryParseJsonFile(_, context.getAdminTranslationDestDir(fullName)) || {};
					fullContent = context.tryParseJsonFile(_, fullName) || {};
					data = _filterJson(_, fullContent, _filterImport),
						filter = _filter(fullName),
						data.$localization = filter && filter(fullContent) || fullContent.$localization || {},
						this.cache[fullName] = data;
				}
				tracer && tracer("admin.handler.load: " + JSON.stringify(fullName) + ", localization=" + sys.inspect(data.$localization[language.iso]));
				return {
					resources: data.$localization[language.iso] || {},
					raw: data
				};
			},
			loadDefault: function(_, fullName, language) {
				var data = {};
				return {
					resources: data,
					raw: data
				};
			},
			save: function(file, data, base, language, _) {
				if (this.saved[file])
					return;
				tracer && tracer("admin.handler.save: " + file + ", data=" + JSON.stringify(data));
				var destfile = context.getAdminTranslationDestDir(file);
				this.saved[file] = {
					dest: destfile,
					contents: contents
				};
				var contents = data.raw || data;
				data && fs.writeFile(destfile, JSON.stringify(contents, null, "\t"), "utf8", _);
			},
			close: function(file) {
				delete this.cache[file];
			},

			localeExt: function(code) {
				return "";
			},
			skipDir: function(dir) {
				var exclude = this.category.isExcluded(dir.name);
				tracer && tracer("admin.handler.skip: " + exclude + ", dir=" + JSON.stringify(dir));
				return exclude;
			},
			match: function(file) {
				var name = fsp.basename(file);
				return currentAdminIncludes.indexOf(name) >= 0;
			},
			matchGroup: function(group) {
				return this.match(group);
			},
		}
	};

	var h = handlers[type] || {};
	h.opt = opt;
	h.category = categories[type];
	h.context = context;
	h.rootpath = context.rootpath;
	return h;
}

function defaultLocaleExt(code) {
	return "-" + (code || "__-__") + ".json";
}

function _defaultIso(x3lang) {
	return _shortestLocale(locale.defaultIso(x3lang) || "");
}

function _shortestLocale(code, neutral) {
	code = code.toLowerCase();
	var parts = code.split("-");
	if (code === "en-us") return neutral ? "" : "en";
	// if (code === "zh-cn") return "zh";
	if (parts.length > 1 && parts[0] === parts[1]) return parts[0];
	return code;
}

function _escapeRegExp(s) {
	return s && s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') || "";
}

function getConflictText(key, isoLang) {
	var fix = conflictFixes[key] && conflictFixes[key].text[isoLang];
	return !Array.isArray(fix) ? fix : fix.reduce(function(r, e) {
		return r += e.replace(/(\s*_\s*)$/, " ");
	}, "");
}

// =====================================================================================

function _filterJson(_, data, filter) {
	var json = {},
		proto = data.$prototypes,
		items = data.$items;
	if (!data.$prototypes || !data.$localization || !data.$items || data.$items.length === 0)
		return null;
	json.$prototypes = proto;

	// filter items
	if (filter)
		items = filter(items, proto);
	json.$items = _simplifyImport(_, proto, items);
	json.$localization = data.$localization;
	return json;
}

function _filterImport(data, proto) {
	var itemsMap = {},
		items = [],
		menuBlocks = {},
		submodules = {},
		pageData = {},
		pageDef = [];

	function addItem(item) {
		if (itemsMap[item.code])
			return;
		itemsMap[item.code] = item;
		items.push(item);
	}

	function collectBlocks(v) {
		var mb = menuBlocks[v.code];
		if (!mb || !mb.code)
			return;
		addItem(mb);
		(mb.items || []).forEach(function(e) {
			if (e.$variantType === "menuBlock") {
				collectBlocks(e);
			}
		});
	}

	data.forEach(function(item) {
		var isAdmin = _isAdmin(item);
		// if (item.$type === "menuItem" && item.linkType === "$representation" && item.$factoryOwner === "SAGE") {
		if (["pageLayout", "landingPage", "menuCategory", "dashboardDef", "portlet"].indexOf(item.$type) !== -1) {
			addItem(item);
		} else if (item.$type === "pageData") {
			pageData[item.code] = item;
		} else if (item.$type === "pageDef" && item.device === "mobile") {
			pageDef.push(item);
		} else if (item.$type === "menuItem" && item.linkType === "$representation") {
			addItem(item);
		} else if (item.$type === "menuModule") {
			if (["STD_X3_ERP_EDI", "STD_X3_ERP_CCM", "Viewpages"].indexOf(item.code) != -1 || isAdmin) {
				addItem(item);
				if (item.submodules && item.submodules.length > 0) {
					item.submodules.forEach(function(submodule) {
						submodules[submodule.code] = submodule;
					});
				}
			}
		} else if (item.$type === "menuBlock") {
			menuBlocks[item.code] = item;
		}
	});

	forEachKey(submodules, function(mk, mv) {
		collectBlocks(mv);
	});
	menuBlocks = null;
	submodules = null;

	pageDef.forEach(function(p) {
		p.variants && p.variants.forEach(function(v) {
			var e = v.pageData && v.pageData.code && pageData[v.pageData.code];
			if (e) addItem(e);
		});
		// pageDef is not necessary because we won't translate title and description
		// addItem(p);
	});
	pageDef = null;
	pageData = null;
	return items;
}

function _isAdmin(item) {
	return item && item.application && (item.application.application === "syracuse" && item.application.contract === "collaboration");
}

var adminIncludes = transCfg.include || [ //
	"syracuse-security-init.json", //
	"syracuse-admin-template.json", //
	"syracuse-admin-categories.json", //
	"syracuse-admin-notifications.json", //
	"x3-erp-sitemap.json", //
	"x3-hrm-sitemap.json", //

	"x3-erp-homepages.json", //
	"syracuse-collaboration-sitemap.json", //
	"syracuse-support-sitemap.json", //
	"x3-mobile-dashboards.json",
	"x3-pages.json", // for mobile dashboards
];
var currentAdminIncludes = adminIncludes;

function _filter(fpath, opt) {
	opt = opt || {};
	var filterExtract = opt.filterExtract || _filterLocalizations,
		name = fsp.basename(fpath);
	return (transCfg.extractFilters && transCfg.extractFilters[name]) || filterExtract;
}

function _simplifyImport(_, proto, data) {
	return currentWorld.simplifyItems(_, {
		$prototypes: proto,
		$items: data
	});
}