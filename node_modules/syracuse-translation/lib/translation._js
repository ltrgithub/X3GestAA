"use strict";

/// !doc
///
/// # X3 translation helper
///
/// Extract syracuse texts in order to be translated by translators.
///
/// Update syracuse texts with the new texts and new supported language.
///
var fs = require('streamline-fs');
var os = require('os');
var streams = require('streamline/lib/streams/server/streams');
var fsp = require("path");
var sys = require("util");
var helpers = require("syracuse-core/lib/helpers");
var datetime = require("syracuse-core/lib/types/datetime");
var flows = require("streamline/lib/util/flows");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var locale = require("syracuse-core/lib/locale");
var config = require('syracuse-main/lib/nodeconfig').config; // must be first
var sha1 = require("node-oauth/lib/sha1");
var perfmon = require('syracuse-perfmon');
var forEachKey = helpers.object.forEachKey;

var dev = (config.system || {}).enableDevelopmentFeatures;

var transCfg = config.translation || {};
var tracer = transCfg.trace;
var traceDiagnosis = transCfg.traceDiagnosis;

var _extend = helpers.object.extend;
var _clone = helpers.object.clone;
var _stringify = helpers.object.stringify;

var isoDateFormat = "yyyy-MM-ddTHH:mm:ssZ";

// TODO:
// Manage deleted entries that are no longer in syracuse
var categories = (function() {
	var categs = {
		$maxCount: 1999,
		$maxLength: 123,
		syracuse: {
			$name: "Syracuse",
			$description: "Syracuse resources",
			$min: 10031,
			$max: 10035,
			// Date files are already fully localized and include some other other non string properties
			$exclude: ["node_modules/syracuse-core/lib/types/resources/date"]
		},
		admin: {
			$name: "Admin",
			$description: "Syracuse admin",
			$min: 10036,
			$max: 10043,
			$exclude: ["syracuse-admin-demo.json", "syracuse-sprint1-demo.json", "x3-pages.json"]
			// $exclude: ["syracuse-admin-demo.json", "syracuse-sprint1-demo.json", "x3-pages.json", "x3-dashboards-home.json", "x3-dashboards-user.json", "syracuse-admin-templates.json"]
		},
		dotnet: {
			$name: "DotNet",
			$description: "Syracuse dotNet",
			$min: 10044,
			$max: 10045
		}
	};

	function _getCurrentState(category) {
		category.$current = category.$current || category.$min;
		category.$ = category.$ || {};
		category.$[category.$current] = category.$[category.$current] || {};
		var state = category.$[category.$current];
		state.$nextId = (state.$nextId || 1);
		return state;
	}

	function _inc(category) {
		var state = category.getCurrentState(),
			id = state.$nextId++;

		if (state.$nextId > categs.$maxCount) {
			if (category.$current >= category.$max) {
				throw new Error("Chapter overflow");
			}
			category.$current++;
			state = category.getCurrentState();
			id = state.$nextId;
		}
		category.$count++;
		return id;
	}

	function _currentKey(category, n) {
		var state = category.getCurrentState(),
			id;

		if (n && (state.$nextId + n - 1 > categs.$maxCount)) {
			if (category.$current >= category.$max) {
				throw new Error(localizedText("chapterOverflow", category.$current));
			}
			category.$current++;
			state = category.getCurrentState();
		}
		id = state.$nextId;
		if (n) {
			id = [id, id + n - 1];
		}
		return {
			chp: category.$current,
			id: id
		};
	}

	function _reset(category) {
		category.$current = category.$min;
		category.$ = {};
		category.$count = 0;
	}

	Object.keys(categs).forEach(function(category) {
		categs[category].$count = categs[category].$count || 0;
		categs[category].inc = _inc.bind(null, categs[category]);
		categs[category].getCurrentState = _getCurrentState.bind(null, categs[category]);
		categs[category].currentKey = _currentKey.bind(null, categs[category]);
		categs[category].reset = _reset.bind(null, categs[category]);
		categs[category].$lastModified = categs[category].$lastModified || "";
	});
	return categs;
})();

var defaultLanguage = {
	iso: "en-us",
	x3: locale.x3Language("en-us")
};
var aplStdMaxLength = 123;

config.session = config.session || {};
config.session.auth = config.session.auth || "basic";

helpers.pageFileStorage = false;

var rootpath = fsp.resolve(fsp.join(__dirname, "../../.."));
var localizedText = locale.format.bind(undefined, module);

/// ## TranslationProcess class

function TranslationProcess(_, context, options) {
	this.context = context;
	this.options = options || {};
	this.diagnosis = makeDiagnosisCollectors(_, options);
	this.endpoint = this.options.endpoint;
	if (!this.endpoint) {
		throw new Error(localizedText("noSourceEndpoint"));
	}
	this.rootDir = fsp.join(__dirname, "../../..", this.options.dir || "");
	this.targetDir = this.options.indexdir || fsp.join(__dirname, "../../../translation-indexes");
	if (!fs.exists(this.targetDir, _)) {
		fs.mkdir(this.targetDir, undefined, _);
	}
	this.store = store(_, this.endpoint, {
		diagnosis: this.diagnosis,
		ignoreChecksum: options.ignoreChecksum,
		file: fsp.join(this.targetDir, "messages.txt"),
	});
}

exports.TranslationProcess = helpers.defineClass(TranslationProcess, null, {
	/// ### getLanguages(_)
	/// return available X3 languages of the TABLAN table that match with the Syracuse locale preferences
	getLanguages: function(_) {
		// tracer && tracer("getLanguages: " + JSON.stringify(this.languages));
		if (this.languages) return this.languages;
		var adminDb = adminHelper.getCollaborationOrm(_);
		var localePrefs = adminDb.fetchInstances(_, adminDb.model.getEntity(_, "localePreference"));
		var i;

		var isoCodes = localePrefs.map_(_, function(_, e) {
			return e.code(_).toLowerCase();
		});
		tracer && tracer("getLanguages: localePrefs=" + isoCodes);
		var db = this.endpoint.getOrm(_),
			entity = db.getEntity(_, 'TABLAN', "$query"),
			where = "LANISO ne ''",
			langs = db.fetchInstances(_, entity, {
				count: 1000,
				sdataWhere: where
			}),
			x3langs = {},
			iso;
		tracer && tracer("getLanguages: where=" + where);
		// tracer && tracer("getLanguages: langs=" + sys.inspect(langs));
		langs.forEach_(_, function(_, e) {
			iso = e.LANISO(_).toLowerCase().replace('_', '-');
			tracer && tracer(e.LAN(_) + '  : ' + iso + " " + isoCodes.indexOf(iso));
			if (isoCodes.indexOf(iso) != -1) {
				x3langs[e.LAN(_)] = iso;
			}
		});

		if (Object.keys(x3langs).length === 0) {
			throw new Error(localizedText("emptyTABLAN"));
		}
		tracer && tracer("getLanguages: x3langs=" + JSON.stringify(x3langs));
		this.languages = x3langs;
		return x3langs;
	},

	/// ### localeFile(_, base, lang)
	/// return the file name of the localization json file.
	localeFile: function(_, base, lang, extmgr) {
		var isoMap = this.getLanguages(_),
			code = locale.defaultIso(lang) || isoMap[lang],
			file = code && fsp.join(rootpath, base + extmgr(code)),
			codes = [code, isoMap[lang], locale.longIso(locale.defaultIso(lang)), code];
		extmgr = extmgr || defaultLocaleExt;
		tracer && tracer("localeFile: base=" + base + ", lang=" + lang + ", code=" + code + ", file=" + file);
		codes.some_(_, function(_, key) {
			code = key;
			file = code && fsp.join(rootpath, base + extmgr(code));
			return file && fs.exists(file, _);
		});
		if (file) {
			if (!fs.exists(file, _)) {
				code = isoMap[lang];
				file = code && fsp.join(rootpath, base + extmgr(code));
			}
			if (!file || !fs.exists(file, _)) {
				code = locale.longIso(locale.defaultIso(lang));
				file = code && fsp.join(rootpath, base + extmgr(code));
			}
			if (!file || !fs.exists(file, _)) {
				code = locale.defaultIso(lang) || isoMap[lang];
				file = code && fsp.join(rootpath, base + extmgr(code));
			}
		}
		if (!file) {
			tracer && tracer("localeFile: undefined code for " + lang + ", defaultIso=" + locale.defaultIso(lang) + ", isoMap=" + isoMap[lang] + ", base=" + base);
		}
		return file || fsp.join(rootpath, base + extmgr(code || "__-__"));
	},

	// ******************* EXTRACT RESOURCES ********************
	extract: function(_, handler) {
		var diagnosis = this.diagnosis,
			opt = handler.opt,
			self = this;

		function _extractAllLang(_, file) {
			var resdir = file.fullName,
				files = fs.readdir(resdir, _),
				map = {},
				m, lang, e, fi;

			function _extractLang(_, lang) {
				var item = map[lang];
				tracer && tracer("_extractLang " + lang);
				if (!item) {
					tracer && tracer("... noLocalization map=" + JSON.stringify(map, null, 2));
					return diagnosis.error(localizedText("noLocalization", lang), _);
				}
				var language = item.language;
				if (!language.x3) {
					return diagnosis.error(localizedText("unknownLangMap", lang), _);
				}
				item.files.forEach_(_, _extract);

				function _extract(_, finfo) {
					tracer && tracer("_extract: " + JSON.stringify(finfo, null, 2));
					diagnosis.logInfo(localizedText("extractTextsOf", handler.desc, finfo.filename), _);

					var data = handler.load(_, finfo.file, language),
						resources = data.resources,
						group = finfo.group,
						checkEntry = _checkEntry(_, self, resources, index, group, language);
					Object.keys(resources).some_(_, checkEntry);
				}
			}

			files.forEach_(_, function(_, f) {
				var fi = _fileInfo(f, resdir, handler),
					lang = fi && fi.language.iso;
				if (lang && fi.language.x3 && !(handler.skipFile && handler.skipFile(fi))) {
					e = map[lang] = map[lang] || {
						language: fi.language,
						files: []
					};
					e.files.push(fi);
				}
			});
			if (Object.keys(map).length > 0) {
				_extractLang(_, "en-us");

				Object.keys(map).filter(function(lang) {
					return options.extractAllLanguages && (lang.toLowerCase() !== "en-us");
				}).forEach_(_, _extractLang);
			}
		}


		function walk(_, rootDir) {
			var fullPath = [];

			function _walk(_, path) {
				var fPath = fsp.join(fullPath.join("/"), path),
					stat = fs.stat(fPath, _),
					file, files;
				if (stat.isDirectory()) {
					file = {
						name: path,
						fullName: fPath,
						key: fsp.relative(rootpath, fPath).replace(/\\/g, '\/')
					};
					if (!handler.skipDir(file)) {
						fullPath.push(path);
						// do not walk through the test folder
						if (handler.match(file)) {
							_extractAllLang(_, file);
						}
						// walk subdir
						files = fs.readdir(fPath, _);
						files.forEach_(_, _walk);
						fullPath.pop();
					}
				}
			}
			_walk(_, rootDir);
		}

		var frame = this.initFrame(_, handler.category, "startExtractResources", opt),
			options = frame.options,
			index = this.frame.index;

		tracer && tracer("extract: handler.rootDir=" + handler.rootDir);
		walk(_, handler.rootDir || this.rootDir);

		this.endExtract(_);
	},

	addEntry: function(_, entry) {
		var index = entry.index,
			chp = index.$chapter,
			val = entry.val,
			group = entry.group,
			state = chp.getCurrentState(),
			isoLang = entry.language && entry.language.iso,
			segment = entry.segment;

		tracer && tracer("addEntry isoLang=" + isoLang + ", group=" + group + ", length=" + val.length + ", val=" + val);
		if (chp.$current > chp.$max) {
			tracer && tracer("addEntry - chapterFull " + entry.ident);
			this.diagnosis.error(localizedText("chapterFull", chp.$max, "admin resources"), _);
			// stop progression
			return {
				fatal: true
			};
		}
		if (!this.saveEntry(_, entry)) {
			this.diagnosis.error(localizedText("createEntryfail", entry.ident, entry.group), _);
			return {
				fatal: false
			};
		}

		var el = segment[entry.ident] = entry.key;
		if (isoLang) {
			el.text = el.text || {};
			el.text[isoLang] = entry.val;
		} else {
			el.text = entry.val;
		}
		el.$key = entry.$key;
		return {
			fatal: false
		};
	},

	injectLongMessage: function(_, entry) {
		var language = (entry.language || defaultLanguage),
			message = entry.val,
			chapter = entry.index.$chapter;
		//
		tracer && tracer("injectLongMessage: chapter=" + JSON.stringify(chapter) + ", language=" + JSON.stringify(language) + ", message=" + message);
		var chunks = [];
		_splitMessage(message, chunks);
		if (chunks.length > 1 && (this.options.longMessagesStrategy === "truncate")) {
			chunks = [message.substring(0, aplStdMaxLength)];
			this.diagnosis.warning(localizedText("msgTooLong", entry.group, entry.ident, aplStdMaxLength, message), _);
		}

		tracer && tracer("Chunks: " + sys.inspect(chunks));
		var nbChunks = chunks.length,
			nbCreatedChuncks = 0,
			id = 0;

		// Put all chunks in the same chapter
		entry.key = chapter.currentKey(nbChunks);
		id = entry.key.id[0];
		for (var i = 0; i < nbChunks; i++) {
			chapter.inc();
			var chunk = chunks[i];

			// the last chunk does not contain marker
			if (i !== nbChunks - 1) {
				chunk += " _";
			}

			tracer && tracer("injectLongMessage: _createEntry chapter=" + entry.key.chp + ", id=" + id + ", chunk=" + chunk);
			var success = this.store.createEntry(_, entry.key.chp, id++, chunk, language, entry.$key);
			if (success) {
				nbCreatedChuncks++;
			} else {
				throw new Error("Cannot create entry!");
			}
		}

		tracer && tracer("injectLongMessage: nbCreatedChuncks: " + nbCreatedChuncks);
		return nbCreatedChuncks;
	},

	saveEntry: function(_, entry) {
		var index = entry.index,
			group = entry.group,
			chapter = entry.index.$chapter,
			state = chapter.getCurrentState(),
			val = entry.val;

		entry.key = chapter.currentKey();

		if (val && (val.length > categories.$maxLength)) {
			return this.injectLongMessage(_, entry);
		} else {
			if (this.store.createEntry(_, entry.key.chp, entry.key.id, entry.val, entry.language, entry.$key)) {
				return chapter.inc();
			}
		}
		return false;
	},

	updateEntry: function(_, el, entry) {
		var diagnosis = this.diagnosis,
			index = entry.index,
			isoLang = entry.language && entry.language.iso,
			x3Lang = entry.language && entry.language.x3,
			chapter = index.chapter,
			seg = index[entry.ident],
			message = entry.val,
			result = this.store.findMessage(_, el.chp, el.id, x3Lang),
			x3message = result.message,
			chunks = result.chunks;

		tracer && tracer("updateEntry     db message='" + x3message + "'");
		tracer && tracer("updateEntry source message='" + message + "'");
		tracer && tracer("updateEntry  index message='" + (el.text && el.text[isoLang] || "") + "'");
		if (chunks.length > 0) {
			el.text = el.text || {};
			// text has been modified since last extraction
			if (x3message !== message) {
				// tracer && tracer("modified since last extraction " + entry.ident + ": " + el.text[isoLang] + ' != ' + message);
				// Changed in DB and in source ==> conflict
				if (x3message !== el.text[isoLang] && message !== el.text[isoLang]) {
					diagnosis.error(localizedText("updateConflict", entry.group + "/" + entry.ident, el.chp + "," + el.id + "," + x3Lang, message, x3message, el.text[isoLang]), _);
					return;
				}
				this.store.updateEntry(_, el.chp, el.id, entry.language, message, chunks, entry.$key);
			}
			el.text[isoLang] = message;
		} else {
			// This situation should not happen. It means some records has been deleted from X3 since the last extraction
			// while testing it is better to delete the index file when emptying the X3 chapters
			_splitMessage(message, chunks);
			el.text[isoLang] = message;
			if (chunks.length > 1 && Array.isArray(el.id)) {
				for (var id = el.id[0], i = 0; id <= el.id[1]; id++, i++) {
					this.store.createEntry(_, el.chp, id, chunks[i], entry.language, entry.$key);
				}
			} else {
				this.store.createEntry(_, el.chp, el.id, message, entry.language, entry.$key);
			}
			diagnosis.warning(localizedText("indexMess", entry.group, entry.ident), _);
		}
	},

	initFrame: function(_, category, msgkey, opt) {
		var endpoint = this.endpoint,
			diagnosis = this.diagnosis,
			// indexpath = fsp.join(this.targetDir, "index" + category.$name + "-syra.json"),
			indexpath = fsp.join(this.targetDir, "index" + category.$name + ".json"),
			frame = this.frame = {
				category: category,
				options: _extend(this.options, opt || {}, true)
			},
			endpointName = endpoint.application(_) + "/" + endpoint.contract(_) + "/" + endpoint.dataset(_),
			resetIndex = opt && opt.resetIndex,
			fetchOpt = {},
			index, g, e;

		opt = opt || {};
		tracer && tracer("initFrame: resetIndex=" + resetIndex);
		if (resetIndex) {
			diagnosis.info(localizedText("deleteIndex", "index" + category.$name + ".json"), _);
			deteteIndex(_, indexpath, category, frame.options);
			category.reset();
		}
		// frame.options.conflictPolicy = this.options.conflictPolicy;
		index = readIndex(_, indexpath, category, frame.options);
		tracer && tracer("initFrame: indexpath=" + indexpath + "\n\tcategory=" + JSON.stringify(category, null, 2) + "\n\tindex=" + JSON.stringify(index, null, 2));
		this.store.reset(_);
		frame.langMap = this.getLanguages(_);
		frame.indexMap = {};
		Object.keys(index).forEach(function(gk) {
			if (gk[0] === "$") return;
			g = index[gk];
			Object.keys(g).forEach(function(ek) {
				if (ek[0] === "$") return;
				e = g[ek];
				frame.indexMap[e.$key] = e;
			});
		});

		if (!opt.loadFromIndex && !opt.ignoreIndexEndpoint) {
			if (index.$config.$target.endpoint && index.$config.$target.endpoint.$uuid !== endpoint.$uuid) {
				return diagnosis.fatal(localizedText("endpointMismatch", index.$config.$chapter.$name, index.$config.$target.endpoint.$uuid, index.$config.$target.endpoint.name, endpoint.$uuid, endpointName), null, _);
			}
			index.$config.$target = {
				endpoint: {
					$uuid: endpoint.$uuid,
					name: endpointName,
					description: endpoint.description(_)
				}
			};
		}

		index.$config.$source = {
			user: {
				login: this.context.getUser(_).login(_)
			},
			host: {
				name: os.hostname(),
				platform: os.platform() + "-" + os.arch()
			}
		};

		tracer && tracer(msgkey + " " + index.$chapter.$name + " to " + endpoint.$uuid + " (" + (endpoint.x3ServerFolder(_) || "") + " - " + endpoint.description(_) + ")");
		diagnosis.info(localizedText(msgkey, index.$chapter.$name, endpoint.description(_)), _);

		var $lastModified = index.$config.$chapter.$lastModified;
		fetchOpt.lastModified = opt.useLastModified && $lastModified && datetime.parse($lastModified).toString(isoDateFormat);
		frame.count = index.$chapter.$count;
		tracer && tracer("initFrame: opt=" + sys.inspect(opt) + ", fetchOpt=" + sys.inspect(fetchOpt));
		if (opt.loadFromIndex) {
			frame.x3Records = opt.fetchRecords && this.store.initFromIndex(index);
		} else {
			frame.x3Records = opt.fetchRecords && this.store.getX3Records(_, index.$chapter, fetchOpt);
		}
		frame.index = index;
		frame.indexpath = indexpath;
		return this.frame;
	},

	endExtract: function(_) {
		var endpoint = this.endpoint,
			frame = this.frame,
			diagnosis = this.diagnosis,
			index = frame.index,
			count = frame.count,
			options = frame.options,
			afs = (options.indexFiler || fs),
			$chapter = index.$config.$chapter,
			added = $chapter.$count - count,
			rec;

		delete index.$chapter;
		index.$config.$lastModified = datetime.now().toString();
		tracer && tracer("End extractResources at " + index.$config.$lastModified + ", " + added + " text(s) added");
		afs.writeFile(frame.indexpath + ".tmp", JSON.stringify(index, null, "\t"), "utf8", _);

		diagnosis.info(localizedText("flushRecords", $chapter.$name, added), _);
		this.store.flush(_);
		$chapter.$lastModified = this.store.getLastUpdate(_, $chapter);
		afs.writeFile(frame.indexpath, JSON.stringify(index, null, "\t"), "utf8", _);
		afs.unlink(frame.indexpath + ".tmp", _);
		if (added > 0) {
			diagnosis.info(localizedText("endExtractResources", $chapter.$name, endpoint.description(_), added), _);
		} else {
			diagnosis.info(localizedText("endExtractResourcesNoText", $chapter.$name, endpoint.description(_)), _);
		}
	},

	terminate: function(_) {
		var diagnosis = this.diagnosis;
		if (diagnosis.hasError()) diagnosis.fatal(localizedText("endsWithError"), null, _);
	},

	tryParseJsonFile: function(_, file, opt) {
		try {
			return JSON.parse((opt && opt.fsModule || fs).readFile(file, "utf8", _));
		} catch (e) {
			return this.diagnosis.fatal(localizedText("incorrectJsonFormat", file), e.stack, _);
		}
	},

	/// ### extractAll(_)
	/// Extract all types of resources (Syracuse source, Administration space, Office add-ins)
	extractAll: function(_) {
		var opt = _extend(this.options, {
			operation: "extract",
			// longMessagesStrategy: "truncate",
			extractAllLanguages: true,
		}, true),
			resourcesOpts = opt.resources || {},
			skip = transCfg.skip || {};

		tracer && tracer("extractAll");

		resourcesOpts.syracuse && !skip.syracuse && this.extractRes(_, resourceHandler(_, "syracuse", this, opt));
		resourcesOpts.dotnet && !skip.dotnet && this.extractRes(_, resourceHandler(_, "dotnet", this, opt));
		resourcesOpts.admin && !skip.admin && this.extractAdminResources(_, opt);
		// resourcesOpts.admin && !skip.admin && this.extractRes(_, resourceHandler(_, "admin", this, opt));
	},

	extractRes: function(_, handler) {
		try {
			this.extract(_, handler);
			if (this.options.verify) {
				this.verifyExtract(_);
			}
		} catch (e) {
			this.diagnosis.fatal(e.message || e, e.stack, _);
		}
	},

	verifyExtract: function(_) {
		var frame = this.frame,
			diagnosis = this.diagnosis,
			index = frame.index,
			chapter = index.$chapter || index.$config.$chapter,
			x3Records = this.store.getX3Records(_, chapter, {
				noMeta: true
			}),
			meta = this.store.getX3Records(_, chapter, {
				metaOnly: true
			}),
			count = 0,
			chp, id, i, txt, item, g, e, r, lan, values;

		diagnosis.info(localizedText("startVerifyExtraction", chapter.$name), _);
		diagnosis.info(localizedText("foundRecordRange", x3Records.$count, chapter.$min, chapter.$max), _);

		function verify(_, vk) {
			txt = values[vk];
			lan = locale.x3Language(vk);
			r = item[lan];
			r && count++;

			!r && diagnosis.fatal(localizedText("entryNotFound", JSON.stringify(e), i, lan, JSON.stringify(item)), null, _);
		}

		Object.keys(index).forEach_(_, function(_, gk) {
			if (gk[0] === "$") return;
			g = index[gk];
			Object.keys(g).forEach_(_, function(_, ek) {
				if (ek[0] === "$") {
					// if (ek==="$key"){
					//	if (meta[e.chp] && meta[e.chp][id]
					// }
					// else
					return;
				}
				e = g[ek];
				chp = x3Records[e.chp];
				id = e.id;
				if (!Array.isArray(id)) {
					id = [id, id];
				}
				for (i = id[0]; i <= id[1]; i++) {
					item = chp && chp[i];
					values = e.text;
					if (item) {
						values && Object.keys(values).forEach_(_, verify);
					} else {
						diagnosis.fatal(localizedText("noRecordFound", JSON.stringify(e), i), null, _);
					}
				}
			});
		});
		diagnosis.info(localizedText("endVerifyExtraction", chapter.$name, count), _);
	},

	extractAdminResources: function(_, opt) {
		// TODO: factorize with regular extract process
		var count = 0,
			diagnosis = this.diagnosis,
			endpoint = this.endpoint,
			refKeys = {},
			self = this;

		function _extractAllLang(_, fpath, fname, fsModule) {
			tracer && tracer("_extractAllLang fname=" + fname + ", path=" + fpath);
			var jsonContent = self.tryParseJsonFile(_, fpath, {
				fsModule: fsModule || fs
			}),
				localizations;
			localizations = jsonContent.$localization || {};
			refKeys = localizationKeys(jsonContent);

			function _extractLang(_, lang) {
				tracer && tracer("_extractLang " + lang);
				if (!localizations[lang]) {
					diagnosis.error(localizedText("noLocalization", lang), _);
					return false;
				}
				var language = {
					iso: lang,
					x3: locale.x3Language(lang, true)
				};
				if (!language.x3) {
					diagnosis.error(localizedText("unknownLangMap", lang), _);
					return false;
				}
				return _extract(_, localizations[lang], fpath, language);
			}

			tracer && tracer("_extracting en-us " + fpath);
			// extract en-us as a reference for the index
			_extractLang(_, "en-us");

			// extract all other languages
			Object.keys(localizations).filter(function(lang) {
				return options.extractAllLanguages && (lang.toLowerCase() !== "en-us");
			}).forEach_(_, _extractLang);
		}

		function _extract(_, localizationRef, fpath, language) {
			var success = false,
				lang = language.iso,
				group = _groupKey(fpath),
				checkEntry = _checkEntry(_, self, localizationRef, index, group, language);
			diagnosis.logInfo(localizedText("extractTextsOf", "admin resource", group + ":" + lang), _);
			Object.keys(localizationRef).some_(_, function(_, key) {
				if (!refKeys[key]) {
					return diagnosis.logWarning(localizedText("unusedText", localizationRef[key], key), _);
				}
				return checkEntry(_, key);
			});
		}

		var frame = this.initFrame(_, categories.admin, "startExtractResources", opt),
			index = frame.index,
			options = frame.options,
			x3Records = frame.x3Records,
			exclude = index.$chapter.$exclude || [],
			path = options.exportFile ? options.dir || fsp.join(__dirname, "../../") : fsp.join(__dirname, "../../../import");

		tracer && tracer("Start extraction " + index.$chapter.$name + " to " + endpoint.x3ServerFolder(_) + " (" + endpoint.description(_) + ")");

		count = index.$chapter.$count;
		if (options.exportFile) {
			_extractAllLang(_, fsp.join(path, options.exportFile), options.exportFile, options.inputFiler);
		} else {
			var stat = fs.stat(path, _);
			if (stat.isDirectory()) {
				var dircontent = fs.readdir(path, _);
				tracer && tracer("dircontent: " + dircontent);
				dircontent = dircontent.filter(function(elt) {
					return (exclude.indexOf(elt) === -1);
				});
				tracer && tracer("dircontent after filtering: " + dircontent);

				dircontent.forEach_(_, function(_, fnam) {
					_extractAllLang(_, fsp.join(path, fnam), fnam, options.inputFiler);
				});
			}
		}
		this.endExtract(_);
	},

	// *******************  UPDATE ********************
	/// ### updateAll(_)
	/// Update all types of resources (Syracuse source, Administration space, Office add-ins)
	updateAll: function(_) {
		var opt = _extend(this.options, {
			operation: "update",
			fetchRecords: true,
			// useLastModified: true
		}, true),
			resourcesOpts = opt.resources || {},
			skip = transCfg.skip || {},
			handler;

		resourcesOpts.syracuse && !skip.syracuse && this.update(_, resourceHandler(_, "syracuse", this, opt));
		resourcesOpts.dotnet && !skip.dotnet && this.update(_, resourceHandler(_, "dotnet", this, opt));
		resourcesOpts.admin && !skip.admin && this.update(_, resourceHandler(_, "admin", this, opt));
	},

	endUpdate: function(_) {
		var endpoint = this.endpoint,
			frame = this.frame,
			diagnosis = this.diagnosis,
			index = frame.index,
			options = frame.options,
			afs = (options.indexFiler || fs),
			$chapter = index.$config.$chapter,
			rec;

		delete index.$chapter;

		index.$config.$lastModified = datetime.now().toString();
		tracer && tracer("End updateResources lastModified=" + index.$config.$lastModified);
		$chapter.$lastModified = this.store.getLastUpdate(_, $chapter);
		// save index modifications
		afs.writeFile(frame.indexpath, JSON.stringify(index, null, "\t"), "utf8", _);

		if (frame.updated > 0) {
			diagnosis.info(localizedText("endUpdateResources", $chapter.$name, endpoint.description(_), frame.updated), _);
		} else {
			diagnosis.info(localizedText("endUpdateResourcesNoText", $chapter.$name, endpoint.description(_)), _);
		}
	},

	update: function(_, handler) {
		var diagnosis = this.diagnosis,
			endpoint = this.endpoint,
			opt = handler.opt,
			self = this;

		function updFile(_, k) {
			diagnosis.logInfo(localizedText("updateTextsOf", handler.desc, k), _);
			tracer && tracer("updFile: " + k);

			function saveData(_) {
				tracer && tracer("save data updateCtx=" + sys.inspect(updateCtx));
				flows.eachKey(_, updateCtx, function(_, lang, src) {
					tracer && tracer("save data src of lang " + lang + ": " + JSON.stringify(src, null, 2));
					if (!fs.exists(fsp.dirname(src.file), _)) {
						tracer && tracer("Folder : " + fsp.dirname(src.file) + " does not exist");
						return;
					}

					if (src.dirty) {
						try {
							tracer && tracer("write to file: " + src.file + " content: " + JSON.stringify(src.data));
							handler.save(src.file, src.data, base, {
								iso: langMap[lang],
								x3: lang
							}, _);
							src.dirty = false;
						} catch (ex) {
							diagnosis.fatal(localizedText("fileWritingError", src.file), ex.stack, _);
						}
					}
					handler.close && handler.close(src.file);
				});
			}

			function updData(_, key) {
				var el = segment[key],
					content, resources;
				tracer && tracer("updData: " + key + ' ' + JSON.stringify(el, null, 2));

				function loadLocalData(_, rec) {
					// tracer && tracer("loadLocalData for rec: " + JSON.stringify(rec, null, 2));
					Object.keys(rec).forEach_(_, function(_, lang) {
						if (lang === "XXX") return;
						var src = updateCtx[lang] = updateCtx[lang] || {};
						if (src.data) return;
						src.isolang = langMap[lang];
						var file = self.localeFile(_, base, lang, handler.localeExt),
							language = {
								iso: src.isolang,
								x3: lang
							};
						src.file = file;
						src.exists = fs.exists(file, _);
						if (src.exists) {
							src.data = handler.load(_, file, language);
						} else {
							tracer && tracer("resources file deleted or moved: " + file);
							diagnosis.warning(localizedText("missingFile", file, lang), _);
							src.data = handler.loadDefault(_, file, language);
						}
					});
					// tracer && tracer("loadLocalData context: " + JSON.stringify(updateCtx, null, 2));
				}
				var chapter = el.chp,
					rec = x3Records[chapter] && x3Records[chapter][el.id];
				if (rec) {
					tracer && tracer("loadLocalData for record " + sys.inspect(rec));
					loadLocalData(_, rec);
					var refObj = _getRefObj(rec["XXX"]),
						ref = refObj.key,
						eRef = ref && frame.indexMap[ref];
					if (eRef && ((eRef.chp !== chapter) || (eRef.id !== el.id))) {
						return diagnosis.fatal(localizedText("invalidBinding", ref, chapter, el.id, eRef.chp, eRef.id), null, _);
					}
					if (!ref) {
						return diagnosis.fatal(localizedText("missingReference", k, key), null, _);
					}
					Object.keys(langMap).forEach_(_, function(_, lang) {
						if (lang === "XXX") return;
						var targetText = rec[lang];
						if (targetText) {
							var src = updateCtx[lang] = updateCtx[lang] || {},
								resources = src.data && src.data.resources,
								sourceText = resources[key],
								isolang = src.isolang = src.isolang || langMap[lang],
								indexText = el.text[isolang];
							tracer && tracer("rec[" + lang + "]: " + sys.inspect(targetText));
							if (!resources) {
								// file deleted or moved
								return;
							}
							src.file = src.file || self.localeFile(_, base, lang, handler.localeExt);
							if (targetText !== indexText || !src.exists) {
								tracer && tracer("Modified in X3 " + k + "/" + key + "[" + lang + "] old value=" + indexText + " new value=" + targetText);
								// tracer && tracer("src.data lang: " + lang + ' ' + JSON.stringify(src.data, null, 2));
								if (src.exists && indexText && sourceText && sourceText !== indexText) {
									if (targetText === sourceText) {
										tracer && tracer("update index " + k + "/" + key + ": '" + el.text[isolang] + "' => '" + targetText + "'");
										el.text[isolang] = targetText;
										frame.updated++;
										// diagnosis.info(localizedText("updateConflict", k + "/" + key, el.chp + "," + el.id + "," + lang, sourceText, targetText, indexText), _);
									} else {
										tracer && tracer("update conflict for " + k + "/" + key + "[" + lang + "]\ns=" + sourceText + "\nt=" + targetText + "\ni=" + indexText);
										diagnosis.error(localizedText("updateConflict", k + "/" + key, el.chp + "," + el.id + "," + lang, sourceText, targetText, indexText), _);
									}
								} else {
									tracer && tracer("update record lang: " + lang + "key: " + key);
									resources[key] = el.text[isolang] = targetText;
									src.dirty = true;
									frame.updated++;
								}
							}
						}
					});
				}
			} // updData
			var base = k.replace(/\//g, fsp.sep),
				updateCtx = {},
				segment = index[k];
			// tracer && tracer("index[" + k + "]=" + JSON.stringify(segment, null, 2));
			Object.keys(segment).filter(function(k) {
				return k[0] !== "$";
			}).forEach_(_, updData);

			saveData(_);
		}

		var frame = this.initFrame(_, handler.category, "startUpdateResources", opt),
			index = frame.index,
			langMap = frame.langMap,
			x3Records = frame.x3Records;
		frame.updated = 0;

		Object.keys(index).filter(function(k) {
			return k[0] !== "$";
		}).forEach_(_, updFile);
		this.endUpdate(_);
	},


	updateIndexfromCsv: function(_, file) {
		var opt = _extend(this.options, {
			operation: "updateIndex",
		}, true),
			handler = resourceHandler(_, "syracuse", this, opt),
			category = handler.category;
		file = file || fsp.join(this.targetDir, "translated-fr-FR.csv");
		tracer && tracer("file = " + file);
		var indexpath = fsp.join(this.targetDir, "index" + category.$name + ".json");
		var index = readIndex(_, indexpath, category, opt);
		var data = fs.exists(file, _) && fs.readFile(file, "utf8", _),
			lines;
		if (data) {
			data = data.replace(/\r\n/g, "\n");
			data = data.replace(/\r/g, "\n");
			lines = data.split("\n");
			lines.forEach(function(l) {

			});
		}
		tracer && tracer("index = " + JSON.stringify(index, null, 2));
		tracer && tracer("lines = " + (lines || []).length);
	},
});

function getLogFile(options) {
	// console.log("getLogFile.this=" + sys.inspect(this, {
	//	showHidden: true,
	//	depth: 2
	// }));
	return fsp.join(indexDir(options), "translation.log");
}

exports.getLogFile = getLogFile;

function indexDir(options) {
	return options && options.indexdir || fsp.join(__dirname, "../../../translation-indexes");
}

function makeDiagnosisCollectors(_, options) {
	var collector, fatal, logger;
	var logName = fsp.join(indexDir(options), "translation.log");
	var fd, hasError;

	logger = function(severity, message, _) {
		hasError = hasError || severity.toLowerCase() === "error";
		if (!fd) {
			fd = fs.open(logName, "w+", "0666", _);
		}
		fs.appendFile(logName, datetime.now() + " [" + severity.toUpperCase() + "] " + message + "\n", "utf8", _);
		traceDiagnosis && tracer && tracer("Diagnosis - " + severity + ": " + message);

	};
	fatal = function(message, stack, _) {};

	if (options && options.$tracking) {
		tracer && tracer("makeDiagnosisCollectors with options.$tracking");
		collector = function(severity, message) {
			hasError = hasError || severity.toLowerCase() === "error";
			options.$tracking.push({
				severity: severity,
				message: message
			});
		};
		fatal = function(message, stack, _) {
			hasError = true;
			var d = {
				$severity: "error",
				$message: message
			};
			if (stack) d.$stackTrace = stack;
			options.$tracking.push(d);
			logger("error", message + (stack ? "\n" + stack : ""), _);
		};
	} else if (options.$addDiagnose) {
		tracer && tracer("makeDiagnosisCollectors with options.$addDiagnose");
		collector = function(severity, message) {
			hasError = hasError || severity.toLowerCase() === "error";
			options.$addDiagnose(severity, message);
		};
	} else {
		tracer && tracer("makeDiagnosisCollectors with tracer");
		traceDiagnosis = true;
		collector = function(severity, message) {
			hasError = hasError || severity.toLowerCase() === "error";
		};
	}

	function dualReport(severity, message, _) {
		collector(severity, message);
		logger(severity, message, _);
	}

	return {
		info: dualReport.bind(undefined, "info"),
		warning: dualReport.bind(undefined, "warning"),
		error: dualReport.bind(undefined, "error"),
		add: dualReport,
		fatal: fatal,
		logInfo: logger.bind(undefined, "info"),
		logError: logger.bind(undefined, "error"),
		logWarning: logger.bind(undefined, "warning"),
		logClose: function(_) {
			fs.close(fd, _);
			fd = undefined;
		},
		hasError: function() {
			return hasError;
		}
	};
}

function deteteIndex(_, indexpath, chapter, options) {
	var fsModule = options && options.indexFiler || fs;
	fsModule.exists(indexpath, _) && fsModule.unlink(indexpath, _);
	tracer && tracer("deteteIndex: indexpath=" + indexpath);
	if (fsModule.exists(indexpath, _)) tracer && tracer("deteteIndex not deleted: indexpath=" + indexpath);
}

function readIndex(_, indexpath, chapter, options) {
	tracer && tracer("indexpath: " + indexpath);
	var fsModule = options && options.indexFiler || fs,
		diags = options && options.$tracking,
		index, data = fsModule.exists(indexpath, _) && fsModule.readFile(indexpath, "utf8", _);
	if (!data) {
		index = {};
		tracer && tracer("data is empty ");
	} else {
		try {
			index = JSON.parse(data);
			// tracer && tracer("index data " + JSON.stringify(index, null, 2));
		} catch (e) {
			throw new Error(localizedText("incorrectJsonFormat", indexpath));
		}
	}

	function newEntry(index, group, ident, val, language) {
		var segment = index[group] = index[group] || {},
			e;
		segment.$key = segment.$key || sha1.hex_sha1(group);

		e = {
			group: group,
			ident: ident,
			val: val || " ",
			language: language || defaultLanguage,
			index: index,
			segment: segment,
			$key: sha1.hex_sha1(segment.$key + "/" + ident),
		};
		e.keyString = e.group + "/" + e.ident + "['" + e.language.iso + "']";
		return e;
	}

	index.newEntry = newEntry.bind(null, index);

	return _initIndexChapter(index, chapter);
}

function _initIndexChapter(index, chapter) {
	index.$config = index.$config || {};
	index.$config.$createDate = index.$config.$createDate || datetime.now().toString();
	index.$config.$lastModified = index.$config.$lastModified || index.$config.$createDate;
	index.$config.$chapter = _extend(chapter, index.$config.$chapter, true, true);
	index.$config.$target = index.$config.$target || {};
	index.$config.$source = index.$config.$source || {};

	index.$chapter = index.$config.$chapter;
	return index;
}

function _splitMessage(message, chunks) {
	var length = message.length;
	var end;
	var beg = 0;
	if (length <= aplStdMaxLength) {
		end = length;
		chunks.push(message);
	} else {
		end = aplStdMaxLength - 2;

		var substr = message.substring(beg, end);
		tracer && tracer("substr " + substr);
		var len = end - 1;

		while (!(/\s/.exec(substr[len])) && len > 0) len--;
		chunks.push(message.substring(beg, len + 1));
		if (len === 0 && (!(/\s/.exec(substr[len])))) tracer && tracer("Can not be splitted correctly. Long chunck without white spaces: " + message);
		substr = message.substring(len + 1, length);
		_splitMessage(substr, chunks);
	}
}

/// ## deleteAll(_, options)
/// * options: options including diagnosis tracker
/// Delete all entries in local menu table (APLSTD) for syracuse chapters
exports.deleteAll = function(_, options) {
	var endpoint = (options || {}).endpoint,
		diagnosis = makeDiagnosisCollectors(_, options),
		db = endpoint.getOrm(_),
		// entity = db.getEntity(_, "APLSTD", "$bulk"),
		entity = db.getEntity(_, "APLSTD", "$query"),
		chaptersToDelete = [],
		count = 0;
	for (var i = categories.syracuse.$min; i <= categories.dotnet.$max; i++) {
		chaptersToDelete.push(i);
	}
	tracer && tracer("deleteAll: " + chaptersToDelete);
	options = options || {};
	chaptersToDelete.forEach_(_, function(_, chapter) {
		diagnosis.info(localizedText("deletingChapterRecords", chapter), _);
		var x3Records = db.fetchInstances(_, entity, {
			sdataWhere: "LANCHP eq " + chapter + " and LANNUM gt 0"
		});
		count += x3Records.length;
		x3Records.forEach_(_, function(_, rec) {
			rec.deleteSelf(_);
		});
		diagnosis.info(localizedText("deleteChapterRecords", chapter, x3Records.length), _);
	});
	diagnosis.info(localizedText("deleteTotalRecords", count), _);
};

var langRegex = {
	".json": /^(.+?)(-(\w{2}(-\w{2})?))$/i,
	".resx": /^(.+?)(\.(\w{2}(-\w{2})?))?$/i
};
var languageMap = {};

function _fileInfo(file, basedir, handler) {
	var extFilter = handler.ext,
		ext = fsp.extname(file);
	if (extFilter && !(ext && ext.toLowerCase() === extFilter.toLowerCase())) {
		tracer && tracer("_fileInfo " + file + ", ext=" + ext + ", extFilter=" + extFilter + " does not match");
		return;
	}

	var fpath = fsp.join(basedir, file),
		path = fsp.relative(rootpath, fpath),
		dirname = fsp.dirname(path),
		basename = fsp.basename(path, ext),
		m = langRegex[ext] && langRegex[ext].exec(basename),
		lang, language;
	if (!m) {
		tracer && tracer("_fileInfo " + file + ", ext=" + ext + ", extFilter=" + extFilter + " does not match regex " + langRegex[ext]);
		return;
	}
	lang = (m && m[3] || "en").toLowerCase();
	lang = m && lang && !m[4] ? locale.longIso(lang) : lang;
	// if (!lang) {
	// 	tracer && tracer("_fileInfo " + file + ", ext=" + ext + ", extFilter=" + extFilter + " lang is null");
	// 	return;
	// }
	language = languageMap[lang] || {
		iso: lang,
		x3: locale.x3Language(lang, true)
	};

	tracer && tracer("_fileInfo " + file + ", ext=" + ext + ", basename=" + basename + " matches: [" + m + "]");
	return {
		file: fpath,
		filename: file,
		group: m && fsp.join(dirname, m[1]).replace(/\\/g, '\/'),
		language: language
	};
}

function _groupKey(file) {
	var path = fsp.relative(rootpath, file);
	return path.replace(/\\/g, '\/');
}

function _checkEntry(_, translation, resources, index, grpkey, language) {
	var segment = grpkey && index[grpkey],
		options = translation.options,
		ignoreChecksum = options.ignoreChecksum,
		diagnosis = translation.diagnosis;

	return function(_, key) {
		if (!grpkey) return;
		var message = resources[key],
			el = segment && segment[key],
			entry = index.newEntry(grpkey, key, message, language),
			isoLang = entry.language && entry.language.iso,
			status = null;

		tracer && tracer("_checkEntry: key=" + grpkey + ':' + key + ", indexEntry=" + sys.inspect(el || {}));

		if (message === null) {
			message = "";
			diagnosis.warning(localizedText("nullValue", entry.keyString), _);
		} else if (typeof(message) !== "string") {
			return diagnosis.warning(localizedText("incorrectType", entry.keyString, typeof(message), JSON.stringify(message)), _);
		}
		if (message && (options.longMessagesStrategy === "truncate") && (message.length > aplStdMaxLength)) {
			message = message.substring(0, aplStdMaxLength);
			diagnosis.warning(localizedText("msgTooLong", grpkey, key, aplStdMaxLength, message), _);
		}
		if (el) {
			if (!ignoreChecksum && el.$key !== entry.$key) {
				diagnosis.fatal(localizedText("checksumMismatch", "check", el.chp, el.id, isoLang, JSON.stringify(entry.$key), JSON.stringify(el.$key)), null, _);
				return true;
			}
			if (el.text && el.text[isoLang] == null) {
				tracer && tracer("add lang " + isoLang + ", text='" + el.text[isoLang] + "'");
				el.text[isoLang] = entry.val;
				translation.store.createEntry(_, el.chp, el.id, entry.val, entry.language, entry.$key);
			} else {
				status = translation.updateEntry(_, el, entry);
			}
		} else {
			status = translation.addEntry(_, entry);
		}
		return status && status.fatal;
	};
}

function localizationKeys(json) {
	var proto = json && json.$prototypes,
		items = json && json.$items || [],
		localization = json && json.$localization && json.$localization["en-us"] || {},
		protoKeys = {},
		l10n = {},
		path = null,
		t, t0 = new Date().getTime();
	if (!proto || items.length === 0) return protoKeys;

	Object.keys(proto).forEach(function(type) {
		var t = protoKeys[type] = {};
		path = [];
		helpers.object.traverse(proto[type], {
			visit: function(key, val) {
				// tracer && tracer("visit path: " + path.join(".") + ", item: " + key + "=" + JSON.stringify(val));
				if (key[0] === "$") {
					if (key === "$localized" && Array.isArray(val)) {
						val.forEach(function(localized) {
							path.push(localized);
							// tracer && tracer("visit add protokey=" + path.join(".") + ", val=" + val);
							t[path.join(".")] = true;
							path.pop();
						});
					}
					return false;
				}
				path.push(key);
				return true;
			},
			leave: function(key, val) {
				// tracer && tracer("leave path: " + path.join(".") + ", item: " + key + "=" + JSON.stringify(val));
				path.pop();
			}
		});
	});
	// tracer && tracer("protoKeys=" + JSON.stringify(protoKeys));
	var prop;
	items.forEach(function(item) {
		t = item.$type && protoKeys[item.$type];
		// tracer && tracer("item type=" + item.$type);
		if (t) {
			path = [];
			helpers.object.traverse(item, {
				visit: function(key, val) {
					if (key[0] === "$") return false;
					path.push(key);
					// tracer && tracer("visit path: " + path.join(".") + ", item: " + key + "=" + JSON.stringify(val));
					if (t[path.join(".")]) {
						// tracer && tracer("visit add key=" + path.join(".") + ", val=" + val);
						l10n[val] = true;
					}
					return true;
				},
				visitLeaf: function(key, val) {
					// tracer && tracer("visitLeaf keys=" + key + ", val=" + val);
					if (typeof(val) === "string" && localization[val]) {
						// tracer && tracer("visitLeaf add key=" + key + ", val=" + val);
						l10n[val] = true;
					}
				},
				leave: function(key, val) {
					// tracer && tracer("leave path: " + path.join(".") + ", item: " + key + "=" + JSON.stringify(val));
					path.pop();
				}
			});
		}
	});
	tracer && tracer("localizationKeys elapsed=" + (new Date().getTime() - t0));
	return l10n;
}

exports.localizationKeys = localizationKeys;

function localizationExists(json, search) {
	var found;
	helpers.object.traverse(json, function(key, val) {
		if (found || key === "$localization") return false;

		if (typeof(val) === "string" && search === val) {
			found = key;
			return false;
		}
		return true;
	});

	return found;
}

function _getRefObj(refText) {
	var a = refText && refText.split(";") || [];
	return {
		key: a[0],
		tick: a[1]
	};
}

function _getDotnetResources(input) {
	var xml = input.replace(/<!--([\s\S]*?)-->/gm, ""),
		regex = /<data*\sname="([\s\S]*?)"([\s\S]*?)>([\s\S]*?)<\/data>/gim,
		matches = {},
		match;

	while ((match = regex.exec(xml))) {
		var line = match[0],
			key = match[1],
			value = /<value>([\s\S]*?)<\/value>/gi.exec(match[3]),
			text = value && value[1] || "";

		// only string type information has to be processed
		if (!line.match(/<data[\s\S]*\s(type|mimetype)=[\s\S]*<\/data>/gi) && key.match(/^(?!&gt;&gt;).+\..+/)) {
			key = key.replace(/^\$(.*)/, "@$1");
			matches[key] = text;
			// tracer && tracer("key=" + key + ', text="' + text + '"');
		}
	}

	// tracer && tracer("_getDotnetResources: " + JSON.stringify(matches, null, 2));
	return matches;
}

function _updateProjectFile(_, iso, base, opt) {
	var diagnosis = opt && opt.diagnosis,
		file = fsp.basename(base),
		dirname = fsp.dirname(base),
		module = fsp.basename(dirname),
		projPath = fsp.join(rootpath, dirname, module + ".csproj"),
		exists = fs.exists(projPath, _);
	if (!exists) {
		diagnosis && diagnosis.warning && diagnosis.warning(localizedText("fileNotFound", projPath), _);
		tracer && tracer("_updateProjectFile: base=" + base + ", Error: " + localizedText("fileNotFound", projPath));
		return;
	}
	var content = fs.readFile(projPath, "utf8", _),
		regex = _embeddedResourceRegEx(file, iso),
		match = regex.exec(content),
		regexNeutral, replacement;

	tracer && tracer("_updateProjectFile: base=" + base + ", file=" + file + ", proj=" + projPath + "\n\tmatch=" + match + ", regex=" + regex);
	if (!(match && match[0])) {
		regexNeutral = _embeddedResourceRegEx(file);
		content = content.replace(regexNeutral, function($0) {
			replacement = '';
			replacement += '\r\n    <EmbeddedResource Include="' + file + '.' + iso + '.resx">';
			replacement += '\r\n      <DependentUpon>' + file + '.cs</DependentUpon>';
			replacement += '\r\n      <SubType>Designer</SubType>';
			replacement += '\r\n    </EmbeddedResource>';
			return $0 + replacement;
		});

		replacement && fs.writeFile(projPath, content, "utf8", _);
	}
}

function _embeddedResourceRegEx(file, iso) {
	var s = '<EmbeddedResource\\s+Include="' + file + (iso ? '.' + iso : "") + '\\.resx">\\s*<DependentUpon>' + file + '\\.cs</DependentUpon>\\s*.*\\s*</EmbeddedResource>';
	//var s = '<EmbeddedResource[ ]+Include="' + file + '.resx">.*[^<]*<DependentUpon>[^<]*' + file + '.cs.*[^<]*' + '</DependentUpon>[\\s\\S]*?</EmbeddedResource>',
	return new RegExp(s);
}

function resourceHandler(_, type, context, opt) {
	var handlers = {
		"syracuse": {
			rootDir: fsp.join(context.rootDir, "node_modules"),
			ext: ".json",
			desc: "file",
			load: function(_, fullName, language) {
				// tracer && tracer("handler.load: " + JSON.stringify(fullName));
				var data = context.tryParseJsonFile(_, fullName);
				return {
					resources: data,
					raw: data
				};
			},
			loadDefault: function(_, fullName, language) {
				var data = {};
				return {
					resources: data,
					raw: data
				};
			},
			save: function(file, data, base, language, _) {
				fs.writeFile(file, JSON.stringify(data.raw || data, null, "\t"), "utf8", _);
			},
			localeExt: function(code) {
				return "-" + code + ".json";
			},
			skipDir: function(dir) {
				// tracer && tracer("handler.skip: " + JSON.stringify(file));
				return dir.name && (dir.name.charAt(0) === "." || dir.name === "test");
			},
			skipFile: function(fi) {
				// tracer && tracer("handler.skip: " + JSON.stringify(file));
				return ((this.category.$exclude || []).indexOf(fi.group) != -1);
			},
			match: function(file) {
				// tracer && tracer("handler.match: " + JSON.stringify(file));
				return file.name && file.name === "resources";
			},
		},
		"dotnet": {
			rootDir: fsp.join(context.rootDir, "dotnet"),
			ext: ".resx",
			desc: "resx file",
			load: function(_, fullName, language) {
				tracer && tracer("dotnet.load: file=" + fullName);
				// tracer && tracer("handler.load: " + JSON.stringify(fullName));
				var xml = (opt.inputFiler || fs).readFile(fullName, _).toString("utf8");
				return {
					resources: _getDotnetResources(xml),
					raw: xml
				};
			},
			loadDefault: function(_, fullName, language) {
				tracer && tracer("dotnet.loadDefault: file=" + fullName + ", language=" + JSON.stringify(language));
				var shortIso = _shortestLocale(language.iso, true);
				return this.load(_, fullName.replace(this.localeExt(shortIso), this.localeExt("en")), language);
			},
			save: function(file, data, base, language, _) {
				var langMap = context.getLanguages(_),
					resources = data.resources,
					input = data.raw,
					shortIso = _shortestLocale(language.iso, true);
				tracer && tracer("dotnet.save: file=" + file + ", data=" + JSON.stringify(data, null, 2));
				flows.eachKey(_, resources, function(_, key, value) {
					// Object.keys(data).forEach_(_, function(_, key) {
					// value = data[key];
					tracer && tracer("key: " + key + ", value: " + value);
					key = key.replace(/^@(.*)/, "$$$1");
					var s = '<data\\s+name="' + key + '".*>[^<]*<value>([^<]*)</value>[^<]*</data>',
						regex = new RegExp(s);
					input = input.replace(regex, function($0) {
						return ($0.replace(/<value>([\s\S]*?)<\/value>/, '<value>' + value + '<\/value>'));
					});
				});
				var exists = fs.exists(file, _);
				tracer && tracer("dotnet.save: File exists? " + exists);
				var fd = fs.open(file, "w+", "0666", _);
				fs.writeFile(file, input, "utf8", _);
				fs.close(fd, _);
				_updateProjectFile(_, shortIso, base, context.diagnosis);
			},

			localeExt: function(code) {
				return (code === "en" ? "" : "." + code) + ".resx";
			},
			skipDir: function(dir) {
				return dir.name && dir.name === "test";
			},
			match: function(file) {
				return true;
			},
		},
		"admin": {
			rootDir: fsp.join(context.rootDir, "import"),
			ext: ".json",
			desc: "admin ressource",
			cache: {},
			load: function(_, fullName, language) {
				var data = this.cache[fullName] || context.tryParseJsonFile(_, fullName);
				this.cache[fullName] = data;
				tracer && tracer("admin.handler.load: " + JSON.stringify(fullName) + ", data=" + sys.inspect(data.$localization));
				return {
					resources: (data.$localization || {})[language.iso] || {},
					raw: data
				};
			},
			loadDefault: function(_, fullName, language) {
				var data = {};
				return {
					resources: data,
					raw: data
				};
			},
			save: function(file, data, base, language, _) {
				tracer && tracer("admin.handler.save: " + file + ", data=" + JSON.stringify(data));
				fs.writeFile(file, JSON.stringify(data.raw || data, null, "\t"), "utf8", _);
			},
			close: function(file) {
				delete this.cache[file];
			},

			localeExt: function(code) {
				return "";
			},
			skipDir: function(dir) {
				var exclude = ((this.category.$exclude || []).indexOf(dir.name) != -1);
				tracer && tracer("admin.handler.skip: " + exclude + ", dir=" + JSON.stringify(dir));
				return exclude;
			},
			match: function(file) {
				return true;
			},
		}
	};

	var h = handlers[type] || {};
	h.opt = opt;
	h.category = categories[type];
	return h;
}

function defaultLocaleExt(code) {
	return "-" + (code || "__-__") + ".json";
}

function _shortestLocale(code, neutral) {
	code = code.toLowerCase();
	var parts = code.split("-");
	if (code === "en-us") return neutral ? "" : "en";
	// if (code === "zh-cn") return "zh";
	if (parts.length > 1 && parts[0] === parts[1]) return parts[0];
	return code;
}


// =================================================================================

function store(_, endpoint, options) {
	var diagnosis = options.diagnosis,
		ignoreChecksum = options.ignoreChecksum,
		db = endpoint.getOrm(_),
		entity = db.getEntity(_, "APLSTD", "$edit"),
		fetchCount = 2000,
		list = [],
		set;

	function _addErrors(_, msg) {
		if (diagnosis) {
			var diags = [];
			msg.getAllDiagnoses(_, diags);
			diags = diags.filter(function(d) {
				return d.severity === "error";
			});
			diags.forEach_(_, function(_, d) {
				diagnosis.add(d.severity, d.message, _);
			});
			if (diags.length > 0) {
				tracer && tracer("diagnoses store op " + msg.LAN(_) + ":" + msg.LANCHP(_) + ":" + msg.LANNUM(_) + sys.inspect(diags));
				return true;
			}
		}
	}

	function _sdataEqual(chp, num, lang) {
		return "LANCHP eq " + chp + " and LANNUM eq " + num + " and LAN eq '" + lang + "'";
	}

	function _getquery(_, chapter, opt) {
		var entity = db.getEntity(_, "APLSTD", "$bulk"),
			// entity = db.getEntity(_, "APLSTD", "$query"),
			lang = opt.lang,
			params = {};
		opt = opt || {};
		if (typeof(chapter) === "object") {
			params.sdataWhere = "LANCHP ge " + chapter.$min + " and LANCHP le " + chapter.$max;
		} else {
			params.sdataWhere = "LANCHP eq " + chapter;
		}
		params.sdataWhere += " and LANNUM " + (opt.startNumber ? "ge " + opt.startNumber : "gt 0");
		if (opt.metaOnly) {
			params.sdataWhere += ' and LAN eq "XXX"';
		} else {
			params.sdataWhere += (opt.noMeta ? ' and LAN ne "XXX"' : "") + (lang ? ' and LAN eq "' + (locale.x3Language(lang) || lang) + '"' : "");
		}
		if (opt.lastModified) {
			params.sdataWhere += ' and UPDDATTIM gt @' + opt.lastModified + '@';
		}
		params.count = opt.count || fetchCount;
		params.orderBy = opt.orderBy;
		params.startIndex = opt.startIndex || 0;
		return {
			entity: entity,
			params: params
		};
	}

	function _getLastUpdate(_, chapter) {
		if (options.file) {
			return "";
		} else {
			var rec = _getRecords(_, chapter, {
				count: 1,
				orderBy: {
					name: "UPDDATTIM",
					descending: true
				}
			});
			return rec && rec[0] && rec[0].UPDDATTIM(_).toString(isoDateFormat) || "";
		}
	}

	function _getRecords(_, chapter, opt) {
		opt.file = opt.file || options.file;
		if (opt.file) {
			return [];
		} else {
			var query = _getquery(_, chapter, opt);
			tracer && tracer("getRecords: params=" + JSON.stringify(query.params));
			return db.fetchInstances(_, query.entity, query.params) || [];
		}
	}

	function _getX3Records(_, chapter, opt) {
		opt.file = opt.file || options.file;
		if (opt.file) {
			return _loadFromFile(_, chapter, opt);
		} else {
			return _loadFromX3(_, chapter, opt);
		}
	}

	function _loadFromFile(_, chapter, opt) {
		var x3Records = opt.obj || {},
			file = opt.file,
			fetched = 0,
			// regex = new RegExp(/\[(\w+):(\d+):(\d+)\]\s*\[([\d\-T:Z]*)\]\s*([^\n\r]*)/g),
			data = fs.exists(file, _) && fs.readFile(file, "utf8", _),
			match, chp, grp, lines, lastUpdate = "";
		if (data) {
			data = data.replace(/\r\n/g, "\n");
			data = data.replace(/\r/g, "\n");
			lines = data.split("\n");
			lines.forEach(function(l) {
				if ((match = /\[(\w+):(\d+):(\d+)\]\s(.*)?/.exec(l))) {
					chp = x3Records[match[2]] = x3Records[match[2]] || {};
					grp = chp[match[3]] = chp[match[3]] || {};
					grp[match[1]] = match[4] || "";
					fetched++;
				}
			});
		}
		tracer && tracer("loadFromFile count=" + fetched);
		diagnosis.info(localizedText("fetchRecords", fetched));
		set.x3Records.data = x3Records;
		return x3Records;
	}

	function _loadFromX3(_, chapter, opt) {
		var query, params, x3Records = opt.obj || {},
			records, count, fetched = 0,
			startNumber = 1;

		do {
			opt.startNumber = startNumber;
			query = _getquery(_, chapter, opt);
			// tracer && tracer("getX3Records: params=" + JSON.stringify(params));
			params = query.params;
			records = db.fetchInstances(_, query.entity, params) || [];
			if (records.$diagnoses) {
				if (records.$diagnoses) {
					diagnosis.error("loadFromX3: params=" + JSON.stringify(params) + "\n" + JSON.stringify(records.$diagnoses));
				}
			}
			count = isNaN(records.length) ? 0 : records.length || 0;
			count && records.forEach_(_, fillRecord);
			tracer && tracer("loadFromX3: length=" + count + ", params=" + JSON.stringify(params));
			fetched += count;
		} while (records.length === fetchCount);
		x3Records.$count = fetched;
		tracer && tracer("loadFromX3 count=" + fetched + ", params=" + JSON.stringify(params));
		diagnosis.info(localizedText("fetchRecords", fetched));
		return x3Records;

		function fillRecord(_, e) {
			x3Records[e.LANCHP(_)] = x3Records[e.LANCHP(_)] || {};
			x3Records[e.LANCHP(_)][e.LANNUM(_)] = x3Records[e.LANCHP(_)][e.LANNUM(_)] || {};
			x3Records[e.LANCHP(_)][e.LANNUM(_)][e.LAN(_)] = e.LANMES(_);
			startNumber = e.LANNUM(_);
		}
	}


	function _findMessage(_, lanchp, lannum, lang) {
		var d = set.deleted.data,
			c = set.created.data,
			u = set.updated.data,
			r = set.x3Records.data,
			chapter, nums, i, msg, text, match, result;

		lang = lang || "ENG";
		if (Array.isArray(lannum)) {
			for (nums = [], i = lannum[0]; i <= lannum[1]; i++) {
				nums.push(i);
			}
		} else {
			nums = [lannum];
		}
		result = {
			message: "",
			chunks: []
		};
		_initChapter(_, lanchp);
		chapter = r[lanchp] || u[lanchp] || c[lanchp];
		if (chapter) {
			result = nums.reduce(function(res, n) {
				text = _getText(lanchp, n, lang).text;
				if (text) {
					res.chunks.push(text);
					res.message += text.replace(/(\s+_\s*)$/, " ");
				}
				return res;
			}, result);
		}

		tracer && tracer("_findMessage: " + lanchp + ", " + lannum + ", " + lang + ", result='" + JSON.stringify(result, null, 2));
		return result;
	}


	function _reset(_) {
		set = {
			x3Records: {
				$name: "origin",
				data: {}
			},
			created: {
				$name: "create",
				data: {}
			},
			updated: {
				$name: "update",
				data: {}
			},
			deleted: {
				$name: "delete",
				data: {}
			}
		};
	}

	function _initChapter(_, chp) {
		var data = set.x3Records.data;
		if (!data[chp]) {
			data[chp] = {};
			_getX3Records(_, chp, {
				obj: data
			});
		}
	}

	function _flush(_) {
		var created = set.created.data,
			updated = set.updated.data,
			deleted = set.deleted.data,
			c, n, e, ue, ce;

		tracer && tracer("_flush set=" + _stringify(set));

		// removed deleted from created and updated
		Object.keys(deleted).forEach_(_, function(_, chp) {
			if (chp[0] === "$") return;
			c = deleted[chp];
			ue = updated[chp];
			ce = created[chp];
			Object.keys(c).forEach_(_, function(_, id) {
				n = c[id];
				ue = ue && ue[id];
				ce = ce && ce[id];
				Object.keys(n).forEach_(_, function(_, lan) {
					ue && delete ue[n];
					ce && delete ce[n];
				});
			});
		});
		set.deleted.data = {};
		// created
		Object.keys(created).forEach_(_, function(_, chp) {
			if (chp[0] === "$") return;
			c = created[chp];
			Object.keys(c).forEach_(_, function(_, id) {
				n = c[id];
				Object.keys(n).forEach_(_, function(_, lan) {
					_dbCreate(_, chp, id, n[lan], lan);
				});
			});
		});
		_dbFlush(_, true);

		set.created.data = {};
		// updated
		Object.keys(updated).forEach_(_, function(_, chp) {
			if (chp[0] === "$") return;
			c = updated[chp];
			Object.keys(c).forEach_(_, function(_, id) {
				n = c[id];
				Object.keys(n).forEach_(_, function(_, lan) {
					_dbUpdate(_, chp, id, n[lan], lan);
				});
			});
		});
		set.updated.data = {};
	}

	function _dbFlush(_, force) {
		var start = currentMillis();
		if (!transCfg.noBatch && db.batch && (force || list.length === 1000)) {
			tracer && tracer("_dbFlush list=" + _stringify(list));
			db.batch(_, entity, list, options);
			list = [];
		}
		tracer && tracer("translation._dbFlush end: " + (currentMillis() - start) + "ms");
	}

	function _dbCreate(_, chp, id, t, lan) {
		t = t || " ";
		tracer && tracer("_dbCreate " + chp + "/" + id + "/" + lan);
		if (!transCfg.noBatch && db.batch) {
			list.push({
				LANCHP: parseInt(chp, 10),
				LANNUM: parseInt(id, 10),
				LAN: lan,
				LANMES: t
			});
			_dbFlush(_);
		} else {
			var msg = entity.createInstance(_, db);
			msg.LANCHP(_, parseInt(chp, 10));
			msg.LANNUM(_, parseInt(id, 10));
			msg.LAN(_, lan);
			// put at least a single space to create the record
			msg.LANMES(_, t);
			msg.save(_);
			_addErrors(_, msg);
		}
	}

	function _dbUpdate(_, chp, id, t, lan) {
		var msg = db.fetchInstance(_, entity, {
			sdataWhere: _sdataEqual(chp, id, lan)
		});
		// tracer && tracer("i: " + i + ", old value: " + msg.LANMES(_));
		msg.LANMES(_, t || " ");
		msg.save(_);
		_addErrors(_, msg);
	}

	function _setText(col, chp, id, lan, t) {
		col = col.data;
		col[chp] = col[chp] || {};
		col[chp][id] = col[chp][id] || {};
		col[chp][id][lan] = t || " ";
	}

	function _getText(chp, id, lan) {
		var d = set.deleted.data,
			c = set.created.data,
			u = set.updated.data,
			r = set.x3Records.data;

		if (d[chp] && d[chp][id] && d[chp][id][lan]) {
			return {
				$col: set.deleted
			};
		}
		if (u[chp] && u[chp][id] && u[chp][id][lan]) {
			return {
				text: u[chp][id][lan],
				$col: set.updated
			};
		}
		if (c[chp] && c[chp][id] && c[chp][id][lan]) {
			return {
				text: c[chp][id][lan],
				$col: set.created
			};
		}
		return {
			text: r[chp] && r[chp][id] && r[chp][id][lan],
			$col: set.x3Records
		};
	}

	function _createEntry(_, chp, id, message, language, refkey) {
		language = language || defaultLanguage;
		var x3Lang = language.x3,
			refObj, ref, t;

		_initChapter(_, chp);
		tracer && tracer("_createEntry endpoint=" + endpoint.dataset(_) + ", language=" + JSON.stringify(language) + ", key=" + chp + ":" + id + ', text="' + message + '"');
		t = _getText(chp, id, x3Lang);
		if (t.text) {
			return diagnosis.fatal(localizedText("duplicateKey", chp, id, x3Lang), null, _);
		}

		_setText(set.created, chp, id, x3Lang, message);

		refObj = _getRefObj(_getText(chp, id, "XXX").text);
		ref = refObj.key;
		if (!ignoreChecksum && ref && ref !== refkey) {
			return diagnosis.fatal(localizedText("checksumMismatch", "create", chp, id, x3Lang, JSON.stringify(refkey), JSON.stringify(ref)), null, _);
		} else if (!ref) {
			// tracer && tracer("ref=" + JSON.stringify(ref));
			_setText(set.created, chp, id, "XXX", refkey);
		}
		return true;
	}

	function _updateEntry(_, chp, lannum, language, text, chunks, refkey) {
		language = language || defaultLanguage;
		var x3Lang = language.x3,
			refObj, ref, t;

		_initChapter(_, chp);
		tracer && tracer("_updateEntry: language=" + JSON.stringify(language) + ", num=" + lannum + ' new value=' + text);

		var msg, i, diags;
		var newChunks = [];
		if (text.length > aplStdMaxLength) {
			_splitMessage(text, newChunks);
			tracer && tracer("old chunks " + JSON.stringify(chunks, null, 2));
			tracer && tracer("new chunks " + JSON.stringify(newChunks, null, 2));
			if (newChunks.length > chunks.length) {
				tracer && tracer(localizedText("cannotExtend", chp, lannum, x3Lang));
				return diagnosis.error(localizedText("cannotExtend", chp, lannum, x3Lang), _);
			}
		} else {
			newChunks.push(text);
		}

		for (i = 0; i < newChunks.length; i++) {
			refObj = _getRefObj(_getText(chp, i, "XXX").text);
			ref = refObj.key;
			if (!ignoreChecksum && ref && ref !== refkey) {
				return diagnosis.fatal(localizedText("checksumMismatch", "update", chp, i, x3Lang, JSON.stringify(refkey), JSON.stringify(ref)), null, _);
			}
			t = _getText(chp, i, x3Lang);
			if (t.$col && t.$col.$name === "delete") {
				delete t.$col[chp][lannum + i][x3Lang];
				t.$col = set.updated;
			}
			_setText(t.$col || set.created, chp, lannum + i, x3Lang);
			// tracer && tracer("i: " + i + ", old value: " + msg.LANMES(_));
		}
	}

	function _initFromIndex(index) {
		var data = set.x3Records.data,
			d, e, x3Lang;
		forEachKey(index, function(gk, gv) {
			if (gk[0] === "$") return;
			forEachKey(gv, function(mk, mv) {
				if (mk[0] === "$") return;
				d = data[mv.chp] = data[mv.chp] || {};
				e = d[mv.id] = d[mv.id] || {};
				e["XXX"] = mv.$key;
				forEachKey(mv.text, function(tk, tv) {
					x3Lang = locale.x3Language(tk, true);
					e[x3Lang] = tv;
				});
			});
		});
		return data;
	}

	// db.resetCache && db.resetCache();
	return {
		reset: _reset,
		getLastUpdate: _getLastUpdate,
		getX3Records: _getX3Records,
		findMessage: _findMessage,
		createEntry: _createEntry,
		updateEntry: _updateEntry,
		flush: _flush,
		initFromIndex: _initFromIndex
	};
}

var hrOffset = 0;
// first call to initialize hrOffset
hrOffset = Date.now() - currentMillis();

function currentMillis() {
	var vals = process.hrtime();
	return hrOffset + (vals[0] * 1000) + Math.floor(vals[1] / 1000000);
}