"use strict";
/// !doc
/// 
/// # X3 translation helper
/// 
/// Extract syracuse texts in order to be translated by translators.
/// 
/// Update syracuse texts with the new texts and new supported language.
/// 
var fs = require('streamline-fs');
var os = require('os');
var streams = require('streamline/lib/streams/server/streams');
var fsp = require("path");
var sys = require("util");
var helpers = require("syracuse-core/lib/helpers");
var datetime = require("syracuse-core/lib/types/datetime");
var flows = require("streamline/lib/util/flows");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var locale = require("syracuse-core/lib/locale");
var config = require('syracuse-main/lib/nodeconfig').config; // must be first
var messageStore = require('syracuse-translation/lib/messageStore');
var sha1 = require("node-oauth/lib/sha1");
var perfmon = require('syracuse-perfmon');
var forEachKey = helpers.object.forEachKey;

var dev = (config.system || {}).enableDevelopmentFeatures;

var transCfg = config.translation || {};
var tracer = transCfg.trace;
var traceDiagnosis = transCfg.traceDiagnosis;

var _extend = helpers.object.extend;
var _clone = helpers.object.clone;
var _stringify = helpers.object.stringify;

var isoDateFormat = messageStore.isoDateFormat;

// TODO:
// Manage deleted entries that are no longer in syracuse
var categories = (function() {
	var categs = {
		$maxCount: 1999,
		$maxLength: 123,
		syracuse: {
			$name: "Syracuse",
			$description: "Syracuse resources",
			$min: 10031,
			$max: 10035,
			// Files that are already fully localized and/or that includes some other non string properties
			$exclude: ["node_modules/syracuse-core/lib/types/resources/date", "node_modules/syracuse-core/lib/types/resources/decimal"]
		},
		admin: {
			$name: "Admin",
			$description: "Syracuse admin",
			$min: 10036,
			$max: 10043,
			$exclude: ["syracuse-admin-demo.json", "syracuse-sprint1-demo.json", "x3-pages.json"]
			// $exclude: ["syracuse-admin-demo.json", "syracuse-sprint1-demo.json", "x3-pages.json", "x3-dashboards-home.json", "x3-dashboards-user.json", "syracuse-admin-templates.json"]
		},
		dotnet: {
			$name: "DotNet",
			$description: "Syracuse dotNet",
			$min: 10044,
			$max: 10045
		}
	};

	function _getCurrentState(category) {
		category.$current = category.$current || category.$min;
		category.$ = category.$ || {};
		category.$[category.$current] = category.$[category.$current] || {};
		var state = category.$[category.$current];
		state.$nextId = (state.$nextId || 1);
		return state;
	}

	function _inc(category) {
		var state = category.getCurrentState(),
			id = state.$nextId++;

		if (state.$nextId > categs.$maxCount) {
			if (category.$current >= category.$max) {
				throw new Error("Chapter overflow");
			}
			category.$current++;
			state = category.getCurrentState();
			id = state.$nextId;
		}
		category.$count++;
		return id;
	}

	function _currentKey(category, n) {
		var state = category.getCurrentState(),
			id;

		if (n && (state.$nextId + n - 1 > categs.$maxCount)) {
			if (category.$current >= category.$max) {
				throw new Error(localizedText("chapterOverflow", category.$current));
			}
			category.$current++;
			state = category.getCurrentState();
		}
		id = state.$nextId;
		if (n) {
			id = [id, id + n - 1];
		}
		return {
			chp: category.$current,
			id: id
		};
	}

	function _reset(category) {
		category.$current = category.$min;
		category.$ = {};
		category.$count = 0;
	}

	Object.keys(categs).forEach(function(category) {
		categs[category].$count = categs[category].$count || 0;
		categs[category].inc = _inc.bind(null, categs[category]);
		categs[category].getCurrentState = _getCurrentState.bind(null, categs[category]);
		categs[category].currentKey = _currentKey.bind(null, categs[category]);
		categs[category].reset = _reset.bind(null, categs[category]);
		categs[category].$lastModified = categs[category].$lastModified || "";
	});
	return categs;
})();

var defaultLanguage = messageStore.defaultLanguage;
var aplStdMaxLength = messageStore.aplStdMaxLength;

config.session = config.session || {};
config.session.auth = config.session.auth || "basic";

helpers.pageFileStorage = false;

var rootpath = fsp.resolve(fsp.join(__dirname, "../../.."));
var localizedText = locale.format.bind(undefined, module);

/// ## TranslationProcess class

function TranslationProcess(_, context, options) {
	this.context = context;
	this.options = options || {};
	this.diagnosis = makeDiagnosisCollectors(_, options);
	this.endpoint = this.options.endpoint;
	if (!this.endpoint) {
		throw new Error(localizedText("noSourceEndpoint"));
	}
	this.rootDir = fsp.join(__dirname, "../../..", this.options.dir || "");
	this.targetDir = this.options.indexdir || fsp.join(__dirname, "../../../translation-indexes");
	this.messagesFilePrefix = options.messagesFilePrefix || fsp.join(this.targetDir, "messages");
	if (!fs.exists(this.targetDir, _)) {
		fs.mkdir(this.targetDir, undefined, _);
	}
	this.store = this.createMessageStore(_);
}

exports.TranslationProcess = helpers.defineClass(TranslationProcess, null, {
	createMessageStore: function(_) {
		var options = this.options,
			mstore, opts = {
				diagnosis: this.diagnosis,
				ignoreChecksum: options.ignoreChecksum,
				file: this.messagesFilePrefix,
				filePrefix: this.messagesFilePrefix
			};
		if (options.noDBStore && this.messagesFilePrefix) {
			if (this.messagesFilePrefix) {
				mstore = new messageStore.FileMessageStore(this.context, this.endpoint, opts);
			}
			//
		} else {
			// provider = new messageStore.AplStdMessageStore(this.context, this.endpoint, opts);
			mstore = new messageStore.X3ClobMessageStore(this.context, this.endpoint, opts);
		}

		mstore && mstore.init(_);
		return mstore;
	},

	///   
	/// ### getLanguages(_)
	/// return available X3 languages of the TABLAN table that match with the Syracuse locale preferences
	getLanguages: function(_) {
		// tracer && tracer("getLanguages: " + JSON.stringify(this.languages));
		if (this.languages) return this.languages;
		var adminDb = adminHelper.getCollaborationOrm(_);
		var localePrefs = adminDb.fetchInstances(_, adminDb.model.getEntity(_, "localePreference"));
		var i;

		var isoCodes = localePrefs.map_(_, function(_, e) {
			return e.code(_).toLowerCase();
		});
		tracer && tracer("getLanguages: localePrefs=" + isoCodes);
		var db = this.endpoint.getOrm(_),
			entity = db.getEntity(_, 'TABLAN', "$query"),
			where = "LANISO ne ''",
			langs = db.fetchInstances(_, entity, {
				count: 1000,
				sdataWhere: where
			}),
			x3langs = {},
			iso;
		tracer && tracer("getLanguages: where=" + where);
		// tracer && tracer("getLanguages: langs=" + sys.inspect(langs));
		langs.forEach_(_, function(_, e) {
			iso = e.LANISO(_).toLowerCase().replace('_', '-');
			tracer && tracer(e.LAN(_) + '  : ' + iso + " " + isoCodes.indexOf(iso));
			if (isoCodes.indexOf(iso) != -1) {
				x3langs[e.LAN(_)] = iso;
			}
		});

		if (Object.keys(x3langs).length === 0) {
			throw new Error(localizedText("emptyTABLAN"));
		}
		tracer && tracer("getLanguages: x3langs=" + JSON.stringify(x3langs));
		this.languages = x3langs;
		return x3langs;
	},

	///   
	/// ### localeFile(_, base, lang)
	/// return the file name of the localization json file.
	localeFile: function(_, base, lang, extmgr) {
		var isoMap = this.getLanguages(_),
			code = locale.defaultIso(lang) || isoMap[lang],
			file = code && fsp.join(rootpath, base + extmgr(code)),
			codes = [code, isoMap[lang], locale.longIso(locale.defaultIso(lang)), code];
		extmgr = extmgr || defaultLocaleExt;
		tracer && tracer("localeFile: base=" + base + ", lang=" + lang + ", code=" + code + ", file=" + file);
		codes.some_(_, function(_, key) {
			code = key;
			file = code && fsp.join(rootpath, base + extmgr(code));
			return file && fs.exists(file, _);
		});
		if (file) {
			if (!fs.exists(file, _)) {
				code = isoMap[lang];
				file = code && fsp.join(rootpath, base + extmgr(code));
			}
			if (!file || !fs.exists(file, _)) {
				code = locale.longIso(locale.defaultIso(lang));
				file = code && fsp.join(rootpath, base + extmgr(code));
			}
			if (!file || !fs.exists(file, _)) {
				code = locale.defaultIso(lang) || isoMap[lang];
				file = code && fsp.join(rootpath, base + extmgr(code));
			}
		}
		if (!file) {
			tracer && tracer("localeFile: undefined code for " + lang + ", defaultIso=" + locale.defaultIso(lang) + ", isoMap=" + isoMap[lang] + ", base=" + base);
		}
		return file || fsp.join(rootpath, base + extmgr(code || "__-__"));
	},

	// ******************* EXTRACT RESOURCES ********************
	extract: function(_, handler) {
		var diagnosis = this.diagnosis,
			opt = handler.opt,
			self = this;

		function _extractAllLang(_, file) {
			var resdir = file.fullName,
				files = fs.readdir(resdir, _),
				map = {},
				m, lang, e, fi;

			function _extractLang(_, lang) {
				var item = map[lang];
				tracer && tracer("_extractLang " + lang);
				if (!item) {
					tracer && tracer("... noLocalization map=" + JSON.stringify(map, null, 2));
					return diagnosis.error(localizedText("noLocalization", lang), _);
				}
				var language = item.language;
				if (!language.x3) {
					return diagnosis.error(localizedText("unknownLangMap", lang), _);
				}
				item.files.forEach_(_, _extract);

				function _extract(_, finfo) {
					tracer && tracer("_extract: " + JSON.stringify(finfo, null, 2));
					diagnosis.logInfo(localizedText("extractTextsOf", handler.desc, finfo.filename), _);

					var data = handler.load(_, finfo.file, language),
						resources = data.resources,
						group = finfo.group,
						checkEntry = _checkEntry(_, self, resources, index, group, language);
					Object.keys(resources).some_(_, checkEntry);
				}
			}

			files.forEach_(_, function(_, f) {
				var fi = _fileInfo(f, resdir, handler),
					lang = fi && fi.language.iso;
				if (lang && fi.language.x3 && !(handler.skipFile && handler.skipFile(fi))) {
					e = map[lang] = map[lang] || {
						language: fi.language,
						files: []
					};
					e.files.push(fi);
				}
			});
			if (Object.keys(map).length > 0) {
				_extractLang(_, "en-us");

				Object.keys(map).filter(function(lang) {
					return options.extractAllLanguages && (lang.toLowerCase() !== "en-us");
				}).forEach_(_, _extractLang);
			}
		}

		function walk(_, rootDir) {
			var fullPath = [];

			function _walk(_, path) {
				var fPath = fsp.join(fullPath.join("/"), path),
					stat = fs.stat(fPath, _),
					file, files;
				if (stat.isDirectory()) {
					file = {
						name: path,
						fullName: fPath,
						key: fsp.relative(rootpath, fPath).replace(/\\/g, '\/')
					};
					if (!handler.skipDir(file)) {
						fullPath.push(path);
						// do not walk through the test folder
						if (handler.match(file)) {
							_extractAllLang(_, file);
						}
						// walk subdir
						files = fs.readdir(fPath, _);
						files.forEach_(_, _walk);
						fullPath.pop();
					}
				}
			}
			_walk(_, rootDir);
		}

		var frame = this.initFrame(_, handler.category, "startExtractResources", opt),
			options = frame.options,
			index = this.frame.index;

		tracer && tracer("extract: handler.rootDir=" + handler.rootDir);
		walk(_, handler.rootDir || this.rootDir);

		this.endExtract(_);
	},

	addEntry: function(_, entry) {
		var index = entry.index,
			chp = index.$chapter,
			val = entry.val,
			group = entry.group,
			state = chp.getCurrentState(),
			isoLang = entry.language && entry.language.iso,
			segment = entry.segment;

		tracer && tracer("addEntry isoLang=" + isoLang + ", group=" + group + ", length=" + val.length + ", val=" + val);
		if (chp.$current > chp.$max) {
			tracer && tracer("addEntry - chapterFull " + entry.ident);
			this.diagnosis.error(localizedText("chapterFull", chp.$max, "admin resources"), _);
			// stop progression
			return {
				fatal: true
			};
		}
		if (!this.saveEntry(_, entry)) {
			this.diagnosis.error(localizedText("createEntryfail", entry.ident, entry.group), _);
			return {
				fatal: false
			};
		}

		var el = segment[entry.ident] = entry.key;
		if (isoLang) {
			el.text = el.text || {};
			el.text[isoLang] = entry.val;
		} else {
			el.text = entry.val;
		}
		el.$key = entry.$key;
		return {
			fatal: false
		};
	},

	injectLongMessage: function(_, entry) {
		var language = (entry.language || defaultLanguage),
			message = entry.val,
			chapter = entry.index.$chapter;
		//
		tracer && tracer("injectLongMessage: chapter=" + JSON.stringify(chapter) + ", language=" + JSON.stringify(language) + ", message=" + message);
		var chunks = [];
		_splitMessage(message, chunks);
		if (chunks.length > 1 && (this.options.longMessagesStrategy === "truncate")) {
			chunks = [message.substring(0, aplStdMaxLength)];
			this.diagnosis.warning(localizedText("msgTooLong", entry.group, entry.ident, aplStdMaxLength, message), _);
		}

		tracer && tracer("Chunks: " + sys.inspect(chunks));
		var nbChunks = chunks.length,
			nbCreatedChuncks = 0,
			id = 0;

		// Put all chunks in the same chapter
		entry.key = chapter.currentKey(nbChunks);
		id = entry.key.id[0];
		for (var i = 0; i < nbChunks; i++) {
			chapter.inc();
			var chunk = chunks[i];

			// the last chunk does not contain marker
			if (i !== nbChunks - 1) {
				chunk += " _";
			}

			tracer && tracer("injectLongMessage: _createEntry chapter=" + entry.key.chp + ", id=" + id + ", chunk=" + chunk);
			var success = this.store.createEntry(_, entry.key.chp, id++, chunk, language, entry.$key);
			if (success) {
				nbCreatedChuncks++;
			} else {
				throw new Error("Cannot create entry!");
			}
		}

		tracer && tracer("injectLongMessage: nbCreatedChuncks: " + nbCreatedChuncks);
		return nbCreatedChuncks;
	},

	saveEntry: function(_, entry) {
		var index = entry.index,
			group = entry.group,
			chapter = entry.index.$chapter,
			state = chapter.getCurrentState(),
			val = entry.val;

		entry.key = chapter.currentKey();

		if (val && (val.length > categories.$maxLength)) {
			return this.injectLongMessage(_, entry);
		} else {
			if (this.store.createEntry(_, entry.key.chp, entry.key.id, entry.val, entry.language, entry.$key)) {
				return chapter.inc();
			}
		}
		return false;
	},

	updateEntry: function(_, el, entry) {
		var diagnosis = this.diagnosis,
			index = entry.index,
			isoLang = entry.language && entry.language.iso,
			x3Lang = entry.language && entry.language.x3,
			seg = index[entry.ident],
			message = entry.val,
			result = this.store.findMessage(_, el.chp, el.id, x3Lang),
			x3message = result.message,
			chunks = result.chunks;

		tracer && tracer("updateEntry     db message='" + x3message + "'");
		tracer && tracer("updateEntry source message='" + message + "'");
		tracer && tracer("updateEntry  index message='" + (el.text && el.text[isoLang] || "") + "'");
		if (chunks.length > 0) {
			el.text = el.text || {};
			// text has been modified since last extraction
			if (x3message !== message) {
				// tracer && tracer("modified since last extraction " + entry.ident + ": " + el.text[isoLang] + ' != ' + message);
				// Changed in DB and in source ==> conflict
				if (x3message !== el.text[isoLang] && message !== el.text[isoLang]) {
					diagnosis.error(localizedText("updateConflict", entry.group + "/" + entry.ident, el.chp + "," + el.id + "," + x3Lang, message, x3message, el.text[isoLang]), _);
					return;
				}
				this.store.updateEntry(_, el.chp, el.id, entry.language, message, chunks, entry.$key);
			}
			el.text[isoLang] = message;
		} else {
			// This situation should not happen. It means some records has been deleted from X3 since the last extraction
			// while testing it is better to delete the index file when emptying the X3 chapters
			_splitMessage(message, chunks);
			el.text[isoLang] = message;
			if (chunks.length > 1 && Array.isArray(el.id)) {
				for (var id = el.id[0], i = 0; id <= el.id[1]; id++, i++) {
					this.store.createEntry(_, el.chp, id, chunks[i], entry.language, entry.$key);
				}
			} else {
				this.store.createEntry(_, el.chp, el.id, message, entry.language, entry.$key);
			}
			diagnosis.warning(localizedText("indexMess", entry.group, entry.ident), _);
		}
	},

	initFrame: function(_, category, msgkey, opt) {
		var endpoint = this.endpoint,
			diagnosis = this.diagnosis,
			// indexpath = fsp.join(this.targetDir, "index" + category.$name + "-syra.json"),
			indexpath = fsp.join(this.targetDir, "index" + category.$name + ".json"),
			frame = this.frame = {
				category: category,
				options: _extend(this.options, opt || {}, true)
			},
			endpointName = endpoint.application(_) + "/" + endpoint.contract(_) + "/" + endpoint.dataset(_),
			resetIndex = opt && opt.resetIndex,
			fetchOpt = {},
			index, g, e;

		opt = opt || {};
		tracer && tracer("initFrame: resetIndex=" + resetIndex);
		if (resetIndex) {
			diagnosis.info(localizedText("deleteIndex", "index" + category.$name + ".json"), _);
			deteteIndex(_, indexpath, category, frame.options);
			category.reset();
		}
		// frame.options.conflictPolicy = this.options.conflictPolicy;
		index = readIndex(_, indexpath, category, frame.options);
		tracer && tracer("initFrame: indexpath=" + indexpath + "\n\tcategory=" + JSON.stringify(category, null, 2) + "\n\tindex=" + JSON.stringify(index, null, 2));
		this.store.reset(_, category);
		frame.langMap = this.getLanguages(_);
		frame.indexMap = {};
		Object.keys(index).forEach(function(gk) {
			if (gk[0] === "$") return;
			g = index[gk];
			Object.keys(g).forEach(function(ek) {
				if (ek[0] === "$") return;
				e = g[ek];
				frame.indexMap[e.$key] = e;
			});
		});

		if (!opt.loadFromIndex && !opt.ignoreIndexEndpoint) {
			if (index.$config.$target.endpoint && index.$config.$target.endpoint.$uuid !== endpoint.$uuid) {
				return diagnosis.fatal(localizedText("endpointMismatch", index.$config.$chapter.$name, index.$config.$target.endpoint.$uuid, index.$config.$target.endpoint.name, endpoint.$uuid, endpointName), null, _);
			}
			index.$config.$target = {
				endpoint: {
					$uuid: endpoint.$uuid,
					name: endpointName,
					description: endpoint.description(_)
				}
			};
		}

		index.$config.$source = {
			user: {
				login: this.context.getUser(_).login(_)
			},
			host: {
				name: os.hostname(),
				platform: os.platform() + "-" + os.arch()
			}
		};

		tracer && tracer(msgkey + " " + index.$chapter.$name + " to " + endpoint.$uuid + " (" + (endpoint.x3ServerFolder(_) || "") + " - " + endpoint.description(_) + ")");
		diagnosis.info(localizedText(msgkey, index.$chapter.$name, endpoint.description(_)), _);

		var $lastModified = index.$config.$chapter.$lastModified;
		fetchOpt.lastModified = opt.useLastModified && $lastModified && datetime.parse($lastModified).toString(isoDateFormat);
		frame.count = index.$chapter.$count;
		tracer && tracer("initFrame: opt=" + sys.inspect(opt) + ", fetchOpt=" + sys.inspect(fetchOpt));
		if (opt.fetchRecords) {
			if (opt.loadFromIndex) {
				frame.x3Records = this.store.initFromIndex(index);
			} else {
				frame.x3Records = this.store.getX3Records(_, index.$chapter, fetchOpt);
			}
		}
		frame.index = index;
		frame.indexpath = indexpath;
		return this.frame;
	},

	endExtract: function(_) {
		var endpoint = this.endpoint,
			frame = this.frame,
			diagnosis = this.diagnosis,
			index = frame.index,
			count = frame.count,
			options = frame.options,
			afs = (options.indexFiler || fs),
			$chapter = index.$config.$chapter,
			added = $chapter.$count - count,
			rec;

		delete index.$chapter;
		index.$config.$lastModified = datetime.now().toString();
		tracer && tracer("End extractResources at " + index.$config.$lastModified + ", " + added + " text(s) added");
		afs.writeFile(frame.indexpath + ".tmp", JSON.stringify(index, null, "\t"), "utf8", _);

		diagnosis.info(localizedText("flushRecords", $chapter.$name, added), _);
		this.store.flush(_);
		$chapter.$lastModified = this.store.getLastUpdate(_, $chapter);
		afs.writeFile(frame.indexpath, JSON.stringify(index, null, "\t"), "utf8", _);
		afs.unlink(frame.indexpath + ".tmp", _);
		if (added > 0) {
			diagnosis.info(localizedText("endExtractResources", $chapter.$name, endpoint.description(_), added), _);
		} else {
			diagnosis.info(localizedText("endExtractResourcesNoText", $chapter.$name, endpoint.description(_)), _);
		}
	},

	terminate: function(_) {
		var diagnosis = this.diagnosis;
		if (diagnosis.hasError()) diagnosis.fatal(localizedText("endsWithError"), null, _);
	},

	tryParseJsonFile: function(_, file, opt) {
		try {
			return JSON.parse((opt && opt.fsModule || fs).readFile(file, "utf8", _));
		} catch (e) {
			return this.diagnosis.fatal(localizedText("incorrectJsonFormat", file), e.stack, _);
		}
	},

	///   
	/// ### extractAll(_)
	/// Extract all types of resources (Syracuse source, Administration space, Office add-ins)
	extractAll: function(_) {
		var opt = _extend(this.options, {
			operation: "extract",
			// longMessagesStrategy: "truncate",
			extractAllLanguages: true,
		}, true),
			resourcesOpts = opt.resources || {},
			skip = transCfg.skip || {};

		tracer && tracer("extractAll");

		resourcesOpts.syracuse && !skip.syracuse && this.extractRes(_, resourceHandler(_, "syracuse", this, opt));
		resourcesOpts.dotnet && !skip.dotnet && this.extractRes(_, resourceHandler(_, "dotnet", this, opt));
		resourcesOpts.admin && !skip.admin && this.extractAdminResources(_, opt);
		// resourcesOpts.admin && !skip.admin && this.extractRes(_, resourceHandler(_, "admin", this, opt));
	},

	extractRes: function(_, handler) {
		try {
			this.clearMessagesFile(_, handler.category);
			this.extract(_, handler);
			if (this.options.verify) {
				this.verifyExtract(_);
			}
		} catch (e) {
			this.diagnosis.fatal(e.message || e, e.stack, _);
		}
	},

	clearMessagesFile: function(_, chapter) {
		tracer && tracer("clearMessagesFile of " + _getMessageFileName(this.messagesFilePrefix, chapter));
		fs.writeFile(_getMessageFileName(this.messagesFilePrefix, chapter), "Language\tChapter\tNumber\tText\n", "utf8", _);
	},

	verifyExtract: function(_) {
		var frame = this.frame,
			diagnosis = this.diagnosis,
			index = frame.index,
			chapter = index.$chapter || index.$config.$chapter,
			x3Records = this.store.getX3Records(_, chapter, {
				noMeta: true
			}),
			meta = this.store.getX3Records(_, chapter, {
				metaOnly: true
			}),
			count = 0,
			chp, id, i, txt, item, g, e, r, lan, values;

		diagnosis.info(localizedText("startVerifyExtraction", chapter.$name), _);
		diagnosis.info(localizedText("foundRecordRange", x3Records.$count, chapter.$min, chapter.$max), _);

		function verify(_, vk) {
			txt = values[vk];
			lan = locale.x3Language(vk);
			r = item[lan];
			r && count++;

			!r && diagnosis.fatal(localizedText("entryNotFound", JSON.stringify(e), i, lan, JSON.stringify(item)), null, _);
		}

		Object.keys(index).forEach_(_, function(_, gk) {
			if (gk[0] === "$") return;
			g = index[gk];
			Object.keys(g).forEach_(_, function(_, ek) {
				if (ek[0] === "$") {
					// if (ek==="$key"){
					//	if (meta[e.chp] && meta[e.chp][id]
					// }
					// else
					return;
				}
				e = g[ek];
				chp = x3Records[e.chp];
				id = e.id;
				if (!Array.isArray(id)) {
					id = [id, id];
				}
				for (i = id[0]; i <= id[1]; i++) {
					item = chp && chp[i];
					values = e.text;
					if (item) {
						values && Object.keys(values).forEach_(_, verify);
					} else {
						diagnosis.fatal(localizedText("noRecordFound", JSON.stringify(e), i), null, _);
					}
				}
			});
		});
		diagnosis.info(localizedText("endVerifyExtraction", chapter.$name, count), _);
	},

	extractAdminResources: function(_, opt) {
		// TODO: factorize with regular extract process
		var count = 0,
			diagnosis = this.diagnosis,
			endpoint = this.endpoint,
			self = this,
			refKeys;

		function _extractAllLang(_, fpath, fname, fsModule) {
			tracer && tracer("_extractAllLang fname=" + fname + ", path=" + fpath);
			var jsonContent = self.tryParseJsonFile(_, fpath, {
				fsModule: fsModule || fs
			}),
				filter = extractFilters[fsp.basename(fpath)] || extractFilters["*"],
				localizations = filter && filter(jsonContent) || jsonContent.$localization || {};

			refKeys = !filter && localizationKeys(jsonContent);

			function _extractLang(_, lang) {
				tracer && tracer("_extractLang " + lang);
				if (!localizations[lang]) {
					diagnosis.error(localizedText("noLocalization", lang), _);
					return false;
				}
				var language = {
					iso: lang,
					x3: locale.x3Language(lang, true)
				};
				if (!language.x3) {
					diagnosis.error(localizedText("unknownLangMap", lang), _);
					return false;
				}
				return _extract(_, localizations[lang], fpath, language);
			}

			tracer && tracer("_extracting en-us " + fpath);
			// extract en-us as a reference for the index
			_extractLang(_, "en-us");

			// extract all other languages
			Object.keys(localizations).filter(function(lang) {
				return options.extractAllLanguages && (lang.toLowerCase() !== "en-us");
			}).forEach_(_, _extractLang);
		}

		function _extract(_, localizationRef, fpath, language) {
			var success = false,
				lang = language.iso,
				group = _groupKey(fpath),
				checkEntry = _checkEntry(_, self, localizationRef, index, group, language);
			diagnosis.logInfo(localizedText("extractTextsOf", "admin resource", group + ":" + lang), _);
			Object.keys(localizationRef).some_(_, function(_, key) {
				if (refKeys && !refKeys[key]) {
					return diagnosis.logWarning(localizedText("unusedText", localizationRef[key], key), _);
				}
				return checkEntry(_, key);
			});
		}

		var adminDb = adminHelper.getCollaborationOrm(_);

		var frame = this.initFrame(_, categories.admin, "startExtractResources", opt),
			index = frame.index,
			options = frame.options,
			x3Records = frame.x3Records,
			exclude = index.$chapter.$exclude || [],
			include = adminDb.model.dbMeta.automaticImport,
			path = options.exportFile ? options.dir || fsp.join(__dirname, "../../") : fsp.join(__dirname, "../../../import"),
			extractFilters = {};

		if (opt.filterAdmin) {
			include = ["x3-erp-homepages.json", "x3-global-sitemap.json"];
			extractFilters = {
				"x3-erp-homepages.json": filters.pageLayout,
				"x3-global-sitemap.json": filters.syracuseMenuItem,
				"syracuse-admin-navi.json": filters.syracuseMenuItem,
				"*": filters.any
			};
			//  = function(file, key, lan, value) {
			// 	tracer && tracer("extractFilter: " + file + ", key=" + key.substring(0, 11));
			// 	return /syracuse\-admin\-navi\.json/g.exec(file) || key.substring(0, 11) === "pageLayout.";
			// };
		}
		tracer && tracer("Start extraction " + index.$chapter.$name + " to " + endpoint.x3ServerFolder(_) + " (" + endpoint.description(_) + ")");
		tracer && tracer("\tinclude=" + include + "\n\texclude=" + exclude);

		count = index.$chapter.$count;
		if (options.exportFile) {
			_extractAllLang(_, fsp.join(path, options.exportFile), options.exportFile, options.inputFiler);
		} else {
			var stat = fs.stat(path, _);
			if (stat.isDirectory()) {
				var dircontent = fs.readdir(path, _);
				tracer && tracer("dircontent: " + dircontent);
				dircontent = dircontent.filter(function(elt) {
					return (include && include.indexOf(elt) != -1 || !include) && (exclude && exclude.indexOf(elt) === -1 || !exclude);
				});
				tracer && tracer("dircontent after filtering: " + dircontent);

				dircontent.forEach_(_, function(_, fnam) {
					_extractAllLang(_, fsp.join(path, fnam), fnam, options.inputFiler);
				});
			}
		}
		this.endExtract(_);
	},

	// *******************  UPDATE ********************
	///   
	/// ### updateAll(_)
	/// Update all types of resources (Syracuse source, Administration space, Office add-ins)
	updateAll: function(_) {
		var opt = _extend(this.options, {
			operation: "update",
			fetchRecords: true,
			// useLastModified: true
		}, true),
			resourcesOpts = opt.resources || {},
			skip = transCfg.skip || {},
			handler;

		resourcesOpts.syracuse && !skip.syracuse && this.update(_, resourceHandler(_, "syracuse", this, opt));
		resourcesOpts.dotnet && !skip.dotnet && this.update(_, resourceHandler(_, "dotnet", this, opt));
		resourcesOpts.admin && !skip.admin && this.update(_, resourceHandler(_, "admin", this, opt));
	},

	endUpdate: function(_) {
		var endpoint = this.endpoint,
			frame = this.frame,
			diagnosis = this.diagnosis,
			index = frame.index,
			options = frame.options,
			afs = (options.indexFiler || fs),
			$chapter = index.$config.$chapter,
			rec;

		delete index.$chapter;

		index.$config.$lastModified = datetime.now().toString();
		tracer && tracer("End updateResources lastModified=" + index.$config.$lastModified);
		$chapter.$lastModified = this.store.getLastUpdate(_, $chapter);
		// save index modifications
		afs.writeFile(frame.indexpath, JSON.stringify(index, null, "\t"), "utf8", _);

		if (frame.updated > 0) {
			diagnosis.info(localizedText("endUpdateResources", $chapter.$name, endpoint.description(_), frame.updated), _);
		} else {
			diagnosis.info(localizedText("endUpdateResourcesNoText", $chapter.$name, endpoint.description(_)), _);
		}
	},

	update: function(_, handler) {
		var diagnosis = this.diagnosis,
			endpoint = this.endpoint,
			opt = handler.opt,
			ignoreChecksum = opt.ignoreChecksum,
			self = this;

		function updFile(_, k) {
			diagnosis.logInfo(localizedText("updateTextsOf", handler.desc, k), _);
			tracer && tracer("updFile: " + k);

			function saveData(_) {
				tracer && tracer("save data updateCtx=" + sys.inspect(updateCtx));
				flows.eachKey(_, updateCtx, function(_, lang, src) {
					tracer && tracer("save data src of lang " + lang + ": " + JSON.stringify(src, null, 2));
					if (!fs.exists(fsp.dirname(src.file), _)) {
						tracer && tracer("Folder : " + fsp.dirname(src.file) + " does not exist");
						return;
					}

					var resources = src.data && src.data.resources;

					if (src.dirty) {
						if (Object.keys(resources).length > 0) {
							try {
								tracer && tracer("write to file: " + src.file + " content: " + JSON.stringify(src.data));
								handler.save(src.file, src.data, base, {
									iso: langMap[lang],
									x3: lang
								}, _);
							} catch (ex) {
								diagnosis.fatal(localizedText("fileWritingError", src.file), ex.stack, _);
							}
						} else {
							tracer && tracer("delete file: " + src.file + " exists: " + src.exists);
							src.exists && fs.unlink(src.file, _);
						}
						src.dirty = false;
					}
					handler.close && handler.close(src.file);
				});
			}

			function updData(_, key) {
				var el = segment[key],
					content, resources;
				tracer && tracer("updData: " + key + ' ' + JSON.stringify(el, null, 2));

				function loadLocalData(_, rec) {
					// tracer && tracer("loadLocalData for rec: " + JSON.stringify(rec, null, 2));
					Object.keys(rec).forEach_(_, function(_, lang) {
						if (lang === "XXX") return;
						var src = updateCtx[lang] = updateCtx[lang] || {};
						if (src.data) return;
						src.isolang = langMap[lang];
						var file = self.localeFile(_, base, lang, handler.localeExt),
							language = {
								iso: src.isolang,
								x3: lang
							};
						src.file = file;
						src.exists = fs.exists(file, _);
						if (src.exists) {
							src.data = handler.load(_, file, language);
						} else {
							tracer && tracer("resources file deleted or moved: " + file);
							diagnosis.warning(localizedText("missingFile", file, lang), _);
							src.isDefault = true;
							src.data = handler.loadDefault(_, file, language);
						}
					});
					// tracer && tracer("loadLocalData context: " + JSON.stringify(updateCtx, null, 2));
				}
				var chapter = el.chp,
					rec = x3Records[chapter] && x3Records[chapter][el.id];
				if (rec) {
					tracer && tracer("loadLocalData for record " + sys.inspect(rec));
					loadLocalData(_, rec);
					var refObj = _getRefObj(rec["XXX"]),
						ref = refObj.key,
						eRef = ref && frame.indexMap[ref];
					if (eRef && ((eRef.chp !== chapter) || (eRef.id !== el.id))) {
						return diagnosis.fatal(localizedText("invalidBinding", ref, chapter, el.id, eRef.chp, eRef.id), null, _);
					}
					if (!ref && !ignoreChecksum) {
						return diagnosis.fatal(localizedText("missingReference", k, key), null, _);
					}
					Object.keys(langMap).sort(function(a, b) {
						return (a === "ENG" && -1) || (b === "ENG" && 1) || 0;
					}).forEach_(_, function(_, lang) {
						if (lang === "XXX") return;
						var targetText = rec[lang];
						if (targetText) {
							var src = updateCtx[lang] || (updateCtx[lang] = {}),
								refRes = ((updateCtx["ENG"] || {}).data || {}).resources,
								targetRefText = rec["ENG"];
							if (!refRes) {
								tracer && tracer("No reference ressource for " + sys.inspect(rec));
								return;
							}
							var resources = src.data && src.data.resources,
								sourceText = resources[key],
								refText = refRes[key],
								isolang = src.isolang || (src.isolang = langMap[lang]),
								indexText = el.text[isolang],
								re;

							tracer && tracer("refLangText=" + sys.inspect(refText));
							tracer && tracer("rec[" + lang + "]: " + sys.inspect(targetText));
							if (opt.loadFromIndex && (!refText || lang === "ENG")) {
								(lang != "ENG") && tracer && tracer("No reference ressource text");
								return;
							}
							if (!resources) {
								// file deleted or moved or text not in reference language
								return;
							}
							src.file = src.file || self.localeFile(_, base, lang, handler.localeExt);
							if (lang !== "ENG") {
								re = new RegExp(_escapeRegExp(refText) + "\\s*");
								if (targetText === equalPlaceholder || re.exec(targetText)) {
									tracer && tracer("Text equal to default ENG " + k + "/" + key + "[" + lang + "] value=" + targetText);
									delete resources[key];
									el.text[isolang] = equalPlaceholder;
									src.dirty = true;
									return;
								}
							}
							if (targetText != indexText || !src.exists) {
								tracer && tracer("Modified in X3 " + k + "/" + key + "[" + lang + "] old value=" + indexText + " new value=" + targetText);
								// tracer && tracer("src.data lang: " + lang + ' ' + JSON.stringify(src.data, null, 2));
								if (src.exists && indexText && sourceText && sourceText != indexText) {
									if (targetText === sourceText) {
										tracer && tracer("update index " + k + "/" + key + ": '" + el.text[isolang] + "' => '" + targetText + "'");
										el.text[isolang] = targetText;
										frame.updated++;
										// diagnosis.info(localizedText("updateConflict", k + "/" + key, el.chp + "," + el.id + "," + lang, sourceText, targetText, indexText), _);
									} else {
										tracer && tracer("update conflict for " + k + "/" + key + "[" + lang + "]\ns=" + sourceText + "\nt=" + targetText + "\ni=" + indexText);
										diagnosis.error(localizedText("updateConflict", k + "/" + key, el.chp + "," + el.id + "," + lang, sourceText, targetText, indexText), _);
									}
								} else {
									tracer && tracer("update record lang: " + lang + "key: " + key);
									resources[key] = el.text[isolang] = targetText;
									src.dirty = true;
									frame.updated++;
								}
							} else if (targetText === indexText && sourceText != indexText) {
								tracer && tracer("update record lang: " + lang + "key: " + key);
								resources[key] = el.text[isolang] = targetText;
								src.dirty = true;
								frame.updated++;
							}
						}
					});
				}
			} // updData
			var base = k.replace(/\//g, fsp.sep),
				updateCtx = {},
				segment = index[k];
			// tracer && tracer("index[" + k + "]=" + JSON.stringify(segment, null, 2));
			Object.keys(segment).filter(function(k) {
				return k[0] !== "$";
			}).forEach_(_, updData);

			saveData(_);
		}

		var frame = this.initFrame(_, handler.category, "startUpdateResources", opt),
			index = frame.index,
			langMap = frame.langMap,
			x3Records = frame.x3Records;
		frame.updated = 0;

		Object.keys(index).filter(function(k) {
			return k[0] !== "$";
		}).forEach_(_, updFile);
		this.endUpdate(_);
	},

	updateIndexfromCsv: function(_, file) {
		var opt = _extend(this.options, {
			operation: "updateIndex",
		}, true),
			handler = resourceHandler(_, "syracuse", this, opt),
			category = handler.category;
		file = file || fsp.join(this.targetDir, "translated-fr-FR.csv");
		tracer && tracer("file = " + file);
		var indexpath = fsp.join(this.targetDir, "index" + category.$name + ".json");
		var index = readIndex(_, indexpath, category, opt);
		var data = fs.exists(file, _) && fs.readFile(file, "utf8", _),
			lines;
		if (data) {
			data = data.replace(/\r\n/g, "\n");
			data = data.replace(/\r/g, "\n");
			lines = data.split("\n");
			lines.forEach(function(l) {

			});
		}
		tracer && tracer("index = " + JSON.stringify(index, null, 2));
		tracer && tracer("lines = " + (lines || []).length);
	},
});

function getLogFile(options) {
	// console.log("getLogFile.this=" + sys.inspect(this, {
	//	showHidden: true,
	//	depth: 2
	// }));
	return fsp.join(indexDir(options), "translation.log");
}

exports.getLogFile = getLogFile;

function indexDir(options) {
	return options && options.indexdir || fsp.join(__dirname, "../../../translation-indexes");
}

function makeDiagnosisCollectors(_, options) {
	var collector, fatal, logger;
	var logName = fsp.join(indexDir(options), "translation.log");
	var fd, hasError;

	logger = function(severity, message, _) {
		hasError = hasError || severity.toLowerCase() === "error";
		if (!fd) {
			fd = fs.open(logName, "w+", "0666", _);
		}
		fs.appendFile(logName, datetime.now() + " [" + severity.toUpperCase() + "] " + message + "\n", "utf8", _);
		traceDiagnosis && tracer && tracer("Diagnosis - " + severity + ": " + message);

	};
	fatal = function(message, stack, _) {};

	if (options && options.$tracking) {
		tracer && tracer("makeDiagnosisCollectors with options.$tracking");
		collector = function(severity, message) {
			hasError = hasError || severity.toLowerCase() === "error";
			options.$tracking.push({
				severity: severity,
				message: message
			});
		};
		fatal = function(message, stack, _) {
			hasError = true;
			var d = {
				$severity: "error",
				$message: message
			};
			if (stack) d.$stackTrace = stack;
			options.$tracking.push(d);
			logger("error", message + (stack ? "\n" + stack : ""), _);
		};
	} else if (options.$addDiagnose) {
		tracer && tracer("makeDiagnosisCollectors with options.$addDiagnose");
		collector = function(severity, message) {
			hasError = hasError || severity.toLowerCase() === "error";
			options.$addDiagnose(severity, message);
		};
	} else {
		tracer && tracer("makeDiagnosisCollectors with tracer");
		traceDiagnosis = true;
		collector = function(severity, message) {
			hasError = hasError || severity.toLowerCase() === "error";
		};
	}

	function dualReportAll(diag, _) {
		diag && diag.forEach_(_, function(_, d) {
			dualReport(d.$severity, d.$message, _);
		});
	}

	function dualReport(severity, message, _) {
		collector(severity, message);
		logger(severity, message, _);
	}

	return {
		info: dualReport.bind(undefined, "info"),
		warning: dualReport.bind(undefined, "warning"),
		error: dualReport.bind(undefined, "error"),
		add: dualReport,
		addAll: dualReportAll,
		fatal: fatal,
		logInfo: logger.bind(undefined, "info"),
		logError: logger.bind(undefined, "error"),
		logWarning: logger.bind(undefined, "warning"),
		logClose: function(_) {
			fs.close(fd, _);
			fd = undefined;
		},
		hasError: function() {
			return hasError;
		}
	};
}

function deteteIndex(_, indexpath, chapter, options) {
	var fsModule = options && options.indexFiler || fs;
	fsModule.exists(indexpath, _) && fsModule.unlink(indexpath, _);
	tracer && tracer("deteteIndex: indexpath=" + indexpath);
	if (fsModule.exists(indexpath, _)) tracer && tracer("deteteIndex not deleted: indexpath=" + indexpath);
}

function readIndex(_, indexpath, chapter, options) {
	tracer && tracer("indexpath: " + indexpath);
	var fsModule = options && options.indexFiler || fs,
		diags = options && options.$tracking,
		index, data = fsModule.exists(indexpath, _) && fsModule.readFile(indexpath, "utf8", _);
	if (!data) {
		index = {};
		tracer && tracer("data is empty ");
	} else {
		try {
			index = JSON.parse(data);
			// tracer && tracer("index data " + JSON.stringify(index, null, 2));
		} catch (e) {
			throw new Error(localizedText("incorrectJsonFormat", indexpath));
		}
	}

	function newEntry(index, group, ident, val, language) {
		var segment = index[group] = index[group] || {},
			e;
		segment.$key = segment.$key || sha1.hex_sha1(group);

		e = {
			group: group,
			ident: ident,
			val: val || " ",
			language: language || defaultLanguage,
			index: index,
			segment: segment,
			$key: sha1.hex_sha1(segment.$key + "/" + ident),
		};
		e.keyString = e.group + "/" + e.ident + "['" + e.language.iso + "']";
		return e;
	}

	index.newEntry = newEntry.bind(null, index);

	return _initIndexChapter(index, chapter);
}

function _initIndexChapter(index, chapter) {
	index.$config = index.$config || {};
	index.$config.$createDate = index.$config.$createDate || datetime.now().toString();
	index.$config.$lastModified = index.$config.$lastModified || index.$config.$createDate;
	index.$config.$chapter = _extend(chapter, index.$config.$chapter, true, true);
	index.$config.$target = index.$config.$target || {};
	index.$config.$source = index.$config.$source || {};

	index.$chapter = index.$config.$chapter;
	return index;
}

function _splitMessage(message, chunks) {
	var length = message.length;
	var end;
	var beg = 0;
	if (length <= aplStdMaxLength) {
		end = length;
		chunks.push(message);
	} else {
		end = aplStdMaxLength - 2;

		var substr = message.substring(beg, end);
		tracer && tracer("substr " + substr);
		var len = end - 1;

		while (!(/\s/.exec(substr[len])) && len > 0) len--;
		chunks.push(message.substring(beg, len + 1));
		if (len === 0 && (!(/\s/.exec(substr[len])))) tracer && tracer("Can not be splitted correctly. Long chunck without white spaces: " + message);
		substr = message.substring(len + 1, length);
		_splitMessage(substr, chunks);
	}
}

/// ## deleteAll(_, options)
/// * options: options including diagnosis tracker
/// Delete all entries in local menu table (APLSTD) for syracuse chapters
exports.deleteAll = function(_, options) {
	var endpoint = (options || {}).endpoint,
		diagnosis = makeDiagnosisCollectors(_, options),
		db = endpoint.getOrm(_),
		// entity = db.getEntity(_, "APLSTD", "$bulk"),
		entity = db.getEntity(_, "APLSTD", "$query"),
		chaptersToDelete = [],
		count = 0;
	for (var i = categories.syracuse.$min; i <= categories.dotnet.$max; i++) {
		chaptersToDelete.push(i);
	}
	tracer && tracer("deleteAll: " + chaptersToDelete);
	options = options || {};
	chaptersToDelete.forEach_(_, function(_, chapter) {
		diagnosis.info(localizedText("deletingChapterRecords", chapter), _);
		var x3Records = db.fetchInstances(_, entity, {
			sdataWhere: "LANCHP eq " + chapter + " and LANNUM gt 0"
		});
		count += x3Records.length;
		x3Records.forEach_(_, function(_, rec) {
			rec.deleteSelf(_);
		});
		diagnosis.info(localizedText("deleteChapterRecords", chapter, x3Records.length), _);
	});
	diagnosis.info(localizedText("deleteTotalRecords", count), _);
};

var langRegex = {
	".json": /^(.+?)(-(\w{2}(-\w{2})?))$/i,
	".resx": /^(.+?)(\.(\w{2}(-\w{2})?))?$/i
};
var languageMap = {};

function _fileInfo(file, basedir, handler) {
	var extFilter = handler.ext,
		ext = fsp.extname(file);
	if (extFilter && !(ext && ext.toLowerCase() === extFilter.toLowerCase())) {
		tracer && tracer("_fileInfo " + file + ", ext=" + ext + ", extFilter=" + extFilter + " does not match");
		return;
	}

	var fpath = fsp.join(basedir, file),
		path = fsp.relative(rootpath, fpath),
		dirname = fsp.dirname(path),
		basename = fsp.basename(path, ext),
		m = langRegex[ext] && langRegex[ext].exec(basename),
		lang, language;
	if (!m) {
		tracer && tracer("_fileInfo " + file + ", ext=" + ext + ", extFilter=" + extFilter + " does not match regex " + langRegex[ext]);
		return;
	}
	lang = (m && m[3] || "en").toLowerCase();
	lang = m && lang && !m[4] ? locale.longIso(lang) : lang;
	// if (!lang) {
	// 	tracer && tracer("_fileInfo " + file + ", ext=" + ext + ", extFilter=" + extFilter + " lang is null");
	// 	return;
	// }
	language = languageMap[lang] || {
		iso: lang,
		x3: locale.x3Language(lang, true)
	};

	tracer && tracer("_fileInfo " + file + ", ext=" + ext + ", basename=" + basename + " matches: [" + m + "]");
	return {
		file: fpath,
		filename: file,
		group: m && fsp.join(dirname, m[1]).replace(/\\/g, '\/'),
		language: language
	};
}

function _groupKey(file) {
	var path = fsp.relative(rootpath, file);
	return path.replace(/\\/g, '\/');
}

// var equalPlaceholder = "==="; // "--", "-", "=en-us=", "=-=", "=:="
var equalPlaceholder = "===";

function _checkEntry(_, translation, resources, index, grpkey, language) {
	language = language || defaultLanguage;

	var segment = grpkey && index[grpkey],
		options = translation.options,
		ignoreChecksum = options.ignoreChecksum,
		diagnosis = translation.diagnosis,
		isoLang = language.iso;

	return function(_, key) {
		if (!grpkey) return;
		var message = resources[key],
			el = segment && segment[key],
			texts = el && el.text || {};

		if (isoLang != "en-us" && texts["en-us"] === message) {
			message = equalPlaceholder;
		}
		var entry = index.newEntry(grpkey, key, message, language),
			status = null;

		tracer && tracer("_checkEntry: key=" + grpkey + ':' + key + ", indexEntry=" + sys.inspect(el || {}));

		if (message === null) {
			message = "";
			diagnosis.warning(localizedText("nullValue", entry.keyString), _);
		} else if (typeof(message) !== "string") {
			return diagnosis.warning(localizedText("incorrectType", entry.keyString, typeof(message), JSON.stringify(message)), _);
		}
		if (message && (options.longMessagesStrategy === "truncate") && (message.length > aplStdMaxLength)) {
			message = message.substring(0, aplStdMaxLength);
			diagnosis.warning(localizedText("msgTooLong", grpkey, key, aplStdMaxLength, message), _);
		}
		if (el) {
			if (!ignoreChecksum && el.$key !== entry.$key) {
				diagnosis.fatal(localizedText("checksumMismatch", "check", el.chp, el.id, isoLang, JSON.stringify(entry.$key), JSON.stringify(el.$key)), null, _);
				return true;
			}
			if (texts[isoLang] == null) {
				tracer && tracer("add lang " + isoLang + ", text='" + texts[isoLang] + "'");
				texts[isoLang] = entry.val;
				translation.store.createEntry(_, el.chp, el.id, entry.val, entry.language, entry.$key);
			} else {
				status = translation.updateEntry(_, el, entry);
			}
		} else {
			status = translation.addEntry(_, entry);
		}
		return status && status.fatal;
	};
}

var filters = {
	pageLayout: function(json) {
		var localization = json.$localization || {},
			langs = Object.keys(json.$localization || {}),
			res = {},
			entries,
			e;
		langs.forEach(function(lang) {
			e = res[lang] || (res[lang] = {});
			entries = localization[lang];
			Object.keys(entries).forEach(function(key) {
				if (key.substring(0, 11) === "pageLayout.")
					e[key] = entries[key];
			});
		});
		return res;
	},
	syracuseMenuItem: function(json) {
		var localization = json.$localization || {},
			items = json.$items || [],
			langs = Object.keys(json.$localization || {}),
			res = {},
			keys = {},
			entries,
			e;
		items.forEach(function(item) {
			if (item.$type === "menuItem" && (item.application || {}).application === "syracuse") {
				keys[item.title] = item;
				keys[item.description] = item;
			}
		});
		langs.forEach(function(lang) {
			e = res[lang] || (res[lang] = {});
			entries = localization[lang];
			Object.keys(entries).forEach(function(key) {
				if (keys[key])
					e[key] = entries[key];
			});
		});
		return res;
	},
	any: function(json) {
		return {};
	}
};


function localizationKeys(json) {
	var proto = json && json.$prototypes,
		items = json && json.$items || [],
		localization = json && json.$localization && json.$localization["en-us"] || {},
		protoKeys = {},
		l10n = {},
		path = null,
		t, t0 = new Date().getTime();
	if (!proto || items.length === 0) return protoKeys;

	Object.keys(proto).forEach(function(type) {
		var t = protoKeys[type] = {};
		path = [];
		helpers.object.traverse(proto[type], {
			visit: function(key, val) {
				// tracer && tracer("visit path: " + path.join(".") + ", item: " + key + "=" + JSON.stringify(val));
				if (key[0] === "$") {
					if (key === "$localized" && Array.isArray(val)) {
						val.forEach(function(localized) {
							path.push(localized);
							// tracer && tracer("visit add protokey=" + path.join(".") + ", val=" + val);
							t[path.join(".")] = true;
							path.pop();
						});
					}
					return false;
				}
				path.push(key);
				return true;
			},
			leave: function(key, val) {
				// tracer && tracer("leave path: " + path.join(".") + ", item: " + key + "=" + JSON.stringify(val));
				path.pop();
			}
		});
	});
	// tracer && tracer("protoKeys=" + JSON.stringify(protoKeys));
	var prop;
	items.forEach(function(item) {
		t = item.$type && protoKeys[item.$type];
		// tracer && tracer("item type=" + item.$type);
		if (t) {
			path = [];
			helpers.object.traverse(item, {
				visit: function(key, val) {
					if (key[0] === "$") return false;
					path.push(key);
					// tracer && tracer("visit path: " + path.join(".") + ", item: " + key + "=" + JSON.stringify(val));
					if (t[path.join(".")]) {
						// tracer && tracer("visit add key=" + path.join(".") + ", val=" + val);
						l10n[val] = true;
					}
					return true;
				},
				visitLeaf: function(key, val) {
					// tracer && tracer("visitLeaf keys=" + key + ", val=" + val);
					if (typeof(val) === "string" && localization[val]) {
						// tracer && tracer("visitLeaf add key=" + key + ", val=" + val);
						l10n[val] = true;
					}
				},
				leave: function(key, val) {
					// tracer && tracer("leave path: " + path.join(".") + ", item: " + key + "=" + JSON.stringify(val));
					path.pop();
				}
			});
		}
	});
	tracer && tracer("localizationKeys elapsed=" + (new Date().getTime() - t0));
	return l10n;
}

exports.localizationKeys = localizationKeys;

function localizationExists(json, search) {
	var found;
	helpers.object.traverse(json, function(key, val) {
		if (found || key === "$localization") return false;

		if (typeof(val) === "string" && search === val) {
			found = key;
			return false;
		}
		return true;
	});

	return found;
}

var _getRefObj = messageStore.getRefObj;

function _getDotnetResources(input) {
	var xml = input.replace(/<!--([\s\S]*?)-->/gm, ""),
		regex = /<data*\sname="([\s\S]*?)"([\s\S]*?)>([\s\S]*?)<\/data>/gim,
		matches = {},
		match;

	while ((match = regex.exec(xml))) {
		var line = match[0],
			key = match[1],
			value = /<value>([\s\S]*?)<\/value>/gi.exec(match[3]),
			text = value && value[1] || "";

		// only string type information has to be processed
		if (!line.match(/<data[\s\S]*\s(type|mimetype)=[\s\S]*<\/data>/gi) && key.match(/^(?!&gt;&gt;).+\..+/)) {
			key = key.replace(/^\$(.*)/, "@$1");
			matches[key] = text;
			// tracer && tracer("key=" + key + ', text="' + text + '"');
		}
	}

	// tracer && tracer("_getDotnetResources: " + JSON.stringify(matches, null, 2));
	return matches;
}

function _updateProjectFile(_, iso, base, opt) {
	var diagnosis = opt && opt.diagnosis,
		file = fsp.basename(base),
		dirname = fsp.dirname(base),
		module = fsp.basename(dirname),
		projPath = fsp.join(rootpath, dirname, module + ".csproj"),
		exists = fs.exists(projPath, _);
	if (!exists) {
		diagnosis && diagnosis.warning && diagnosis.warning(localizedText("fileNotFound", projPath), _);
		tracer && tracer("_updateProjectFile: base=" + base + ", Error: " + localizedText("fileNotFound", projPath));
		return;
	}
	var content = fs.readFile(projPath, "utf8", _),
		regex = _embeddedResourceRegEx(file, iso),
		match = regex.exec(content),
		regexNeutral, replacement;

	tracer && tracer("_updateProjectFile: base=" + base + ", file=" + file + ", proj=" + projPath + "\n\tmatch=" + match + ", regex=" + regex);
	if (!(match && match[0])) {
		regexNeutral = _embeddedResourceRegEx(file);
		content = content.replace(regexNeutral, function($0) {
			replacement = '';
			replacement += '\r\n    <EmbeddedResource Include="' + file + '.' + iso + '.resx">';
			replacement += '\r\n      <DependentUpon>' + file + '.cs</DependentUpon>';
			replacement += '\r\n      <SubType>Designer</SubType>';
			replacement += '\r\n    </EmbeddedResource>';
			return $0 + replacement;
		});

		replacement && fs.writeFile(projPath, content, "utf8", _);
	}
}

function _embeddedResourceRegEx(file, iso) {
	var s = '<EmbeddedResource\\s+Include="' + file + (iso ? '.' + iso : "") + '\\.resx">\\s*<DependentUpon>' + file + '\\.cs</DependentUpon>\\s*.*\\s*</EmbeddedResource>';
	//var s = '<EmbeddedResource[ ]+Include="' + file + '.resx">.*[^<]*<DependentUpon>[^<]*' + file + '.cs.*[^<]*' + '</DependentUpon>[\\s\\S]*?</EmbeddedResource>',
	return new RegExp(s);
}

function resourceHandler(_, type, context, opt) {
	var handlers = {
		"syracuse": {
			rootDir: fsp.join(context.rootDir, "node_modules"),
			ext: ".json",
			desc: "file",
			load: function(_, fullName, language) {
				// tracer && tracer("handler.load: " + JSON.stringify(fullName));
				var data = context.tryParseJsonFile(_, fullName);
				return {
					resources: data,
					raw: data
				};
			},
			loadDefault: function(_, fullName, language) {
				var data = {};
				return {
					resources: data,
					raw: data
				};
			},
			save: function(file, data, base, language, _) {
				fs.writeFile(file, JSON.stringify(data.raw || data, null, "\t"), "utf8", _);
			},
			localeExt: function(code) {
				return "-" + code + ".json";
			},
			skipDir: function(dir) {
				// tracer && tracer("handler.skip: " + JSON.stringify(file));
				return dir.name && (dir.name.charAt(0) === "." || dir.name === "test");
			},
			skipFile: function(fi) {
				// tracer && tracer("handler.skip: " + JSON.stringify(file));
				return ((this.category.$exclude || []).indexOf(fi.group) != -1);
			},
			match: function(file) {
				// tracer && tracer("handler.match: " + JSON.stringify(file));
				return file.name && file.name === "resources";
			},
		},
		"dotnet": {
			rootDir: fsp.join(context.rootDir, "dotnet"),
			ext: ".resx",
			desc: "resx file",
			load: function(_, fullName, language) {
				tracer && tracer("dotnet.load: file=" + fullName);
				// tracer && tracer("handler.load: " + JSON.stringify(fullName));
				var xml = (opt.inputFiler || fs).readFile(fullName, _).toString("utf8");
				return {
					resources: _getDotnetResources(xml),
					raw: xml
				};
			},
			loadDefault: function(_, fullName, language) {
				tracer && tracer("dotnet.loadDefault: file=" + fullName + ", language=" + JSON.stringify(language));
				var shortIso = _shortestLocale(language.iso, true);
				return this.load(_, fullName.replace(this.localeExt(shortIso), this.localeExt("en")), language);
			},
			save: function(file, data, base, language, _) {
				var langMap = context.getLanguages(_),
					resources = data.resources,
					input = data.raw,
					shortIso = _shortestLocale(language.iso, true);
				tracer && tracer("dotnet.save: file=" + file + ", data=" + JSON.stringify(data, null, 2));
				flows.eachKey(_, resources, function(_, key, value) {
					// Object.keys(data).forEach_(_, function(_, key) {
					// value = data[key];
					tracer && tracer("key: " + key + ", value: " + value);
					key = key.replace(/^@(.*)/, "$$$1");
					var s = '<data\\s+name="' + key + '".*>[^<]*<value>([^<]*)</value>[^<]*</data>',
						regex = new RegExp(s);
					input = input.replace(regex, function($0) {
						return ($0.replace(/<value>([\s\S]*?)<\/value>/, '<value>' + value + '<\/value>'));
					});
				});
				var exists = fs.exists(file, _);
				tracer && tracer("dotnet.save: File exists? " + exists);
				var fd = fs.open(file, "w+", "0666", _);
				fs.writeFile(file, input, "utf8", _);
				fs.close(fd, _);
				_updateProjectFile(_, shortIso, base, context.diagnosis);
			},

			localeExt: function(code) {
				return (code === "en" ? "" : "." + code) + ".resx";
			},
			skipDir: function(dir) {
				return dir.name && dir.name === "test";
			},
			match: function(file) {
				return true;
			},
		},
		"admin": {
			rootDir: fsp.join(context.rootDir, "import"),
			ext: ".json",
			desc: "admin ressource",
			cache: {},
			load: function(_, fullName, language) {
				var data = this.cache[fullName] || context.tryParseJsonFile(_, fullName);
				this.cache[fullName] = data;
				tracer && tracer("admin.handler.load: " + JSON.stringify(fullName) + ", data=" + sys.inspect(data.$localization));
				return {
					resources: (data.$localization || {})[language.iso] || {},
					raw: data
				};
			},
			loadDefault: function(_, fullName, language) {
				var data = {};
				return {
					resources: data,
					raw: data
				};
			},
			save: function(file, data, base, language, _) {
				tracer && tracer("admin.handler.save: " + file + ", data=" + JSON.stringify(data));
				fs.writeFile(file, JSON.stringify(data.raw || data, null, "\t"), "utf8", _);
			},
			close: function(file) {
				delete this.cache[file];
			},

			localeExt: function(code) {
				return "";
			},
			skipDir: function(dir) {
				var exclude = ((this.category.$exclude || []).indexOf(dir.name) != -1);
				tracer && tracer("admin.handler.skip: " + exclude + ", dir=" + JSON.stringify(dir));
				return exclude;
			},
			match: function(file) {
				return true;
			},
		}
	};

	var h = handlers[type] || {};
	h.opt = opt;
	h.category = categories[type];
	return h;
}

function defaultLocaleExt(code) {
	return "-" + (code || "__-__") + ".json";
}

function _shortestLocale(code, neutral) {
	code = code.toLowerCase();
	var parts = code.split("-");
	if (code === "en-us") return neutral ? "" : "en";
	// if (code === "zh-cn") return "zh";
	if (parts.length > 1 && parts[0] === parts[1]) return parts[0];
	return code;
}

function _escapeRegExp(s) {
	return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

// =================================================================================

var _getMessageFileName = messageStore.getMessageFileName;