"use strict";
var fs = require('fs');
var fsp = require("path");
var sys = require("util");
var helpers = require("syracuse-core/lib/helpers");
var flows = require("streamline/lib/util/flows");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var resourceHelpers = require("syracuse-core/lib/resource/util");
var locale = require("syracuse-core/lib/locale");
var httpHelper = require("syracuse-sdata/lib/httpHelper");
var uuid = helpers.uuid;
var streams = require('streamline/lib/streams/streams');
var config = require('syracuse-main/lib/nodeconfig').config; // must be first

var traceFilePrefix = "C:\\trace\\";
var chapterDotnet = 10040;
var chapterAdmin = 10036;
var chapterSyracuse = 10031;
var fetchCountX3 = 10000;
var maxLength = 123 - 13 ;
var maxNbRecords = 1999 ;

function trace(str) {
	var f = traceFilePrefix + "trace_client.log";
	var strn = str + "\n";
	var options = {
		flag : 'a+'
	};
	fs.appendFileSync(f, new Buffer(strn, 'utf8'), options);
}
/*
function trace_update(str) {
	var f = traceFilePrefix + "trace_update.log";
	var strn = str + "\n";
	var options = {
		flag : 'a+'
	};
	fs.appendFileSync(f, new Buffer(strn, 'utf8'), options);
}*/

function trace_update_admin(str) {
	var f = traceFilePrefix + "trace_update_admin.log";
	var strn = str + "\n";
	var options = {
		flag : 'a+'
	};
	fs.appendFileSync(f, new Buffer(strn, 'utf8'), options);
}

function trace_extract_admin(str) {
	var f = traceFilePrefix + "trace_extract_admin.log";
	var strn = str + "\n";
	var options = {
		flag : 'a+'
	};
	fs.appendFileSync(f, new Buffer(strn, 'utf8'), options);
}

/*function trace_dotnet_extract(str) {
	var f = traceFilePrefix + "trace_dotnet_extract.log";
	var strn = str + "\n";
	var options = {
		flag : 'a+'
	};
	fs.appendFileSync(f, new Buffer(strn, 'utf8'), options);
}

function trace_update_dotnet(str) {
	var f = traceFilePrefix + "trace_update_dotnet.log";
	var strn = str + "\n";
	var options = {
		flag : 'a+'
	};
	fs.appendFileSync(f, new Buffer(strn, 'utf8'), options);
}*/

var tracer = null;

//var tracer = console.log;
config.session = config.session || {};
config.session.auth = "basic";

helpers.pageFileStorage = false;

var rootpath = fsp.dirname(process.cwd());

function _splitMessage(message,parts){
	var length=message.length ;
	var end ;
	var beg=0 ;
	if (length<maxLength ){
		end=length ;
		parts.push(message) ;
	}
	else 
	{
		end=maxLength ;
	
		var substr=message.substring(beg,end);
		console.log("substr "+substr) 
		var len=end-1 ;
		
		while (! (/\s/.exec(substr[len])) ) len--;
		parts.push(message.substring(beg,len+1));
		substr=message.substring(len+1,length);
			_splitMessage(substr,parts);

	}	

}

function _findMessage(_, coll, searchProp, searchVal) {
	var msg = null;
	//console.log("_findMessage: " + searchVal);
	coll.some_(_, function(_, item) {
		var pval = item[searchProp](_);
		if (pval && pval == searchVal) {
			msg = item.LANMES(_);
			return true;
		}
		return false;
	});
	return msg;
}

function _findItem(_, coll, searchProp, searchVal) {
	var it = null;

	coll.some_(_, function(_, item) {
		if (item[searchProp](_) == searchVal) {
			it = item;
			return true;
		}
		return false;
	});
	return it;
}

//provisoire
exports.deleteAll = function(_, instance, options, context) {
	var chaptersToDelete = [chapterDotnet, chapterAdmin, chapterSyracuse];

	var endPoint = instance.endpoint(_);
	var index;
	options = options || {};

	var db = endPoint.getOrm(_);
	var entity = db.getEntity(_, "APLSTD", "$bulk");
	
	chaptersToDelete.forEach_(_, function(_, chapter) {
		var x3Records = db.fetchInstances(_, entity, {
			sdataWhere : "lanchp eq " + chapter + " and LANNUM ne 0 and LANNUM gt 81"
		}); //and LAN eq 'ENG'
	
		console.log("x3Records: " + x3Records.length);
		x3Records.forEach_(_, function(_, rec) {
			rec.deleteSelf(_);
		});
	});
};

function _getLanguages(_, instance) {
	tracer && tracer("_getLanguages");
	var db = adminHelper.getCollaborationOrm(_);
	var localePrefs = db.fetchInstances(_, db.model.getEntity("localePreference"));
	var isoCodesStr = "";
	localePrefs.forEach_(_, function(_, e, idx) {
		isoCodesStr += " '" + e.code(_);
		if (idx < localePrefs.length - 1)
			isoCodesStr += "', ";
		else
			isoCodesStr += "' ";
	});

	var isoCodes = localePrefs.map_(_, function(_, e) {
		return e.code(_);
	});
	tracer && tracer("ISO CODES: " + sys.inspect(isoCodes));

	var entity = db.getEntity(_, 'TABLAN', "$query");
	var where = "LANISO in  (";
	isoCodes.forEach_(_, function(_, code, idx) {
		if (idx === 0)
			where += '"' + code + '"';
		else {
			where += ', ';
			where += '"' + code + '"';
		}

	});
	where += ")";

	tracer && tracer("WHERE: " + where);

	var dbX3 = instance.endpoint(_).getOrm(_);
	var langs = dbX3.fetchInstances(_, entity, {
		sdataWhere : where
	});
	var x3langs = {};
	langs.forEach_(_, function(_, e) {
		tracer && tracer(e.LAN(_) + '  : ' + e.LANISO(_));
		x3langs[e.LAN(_)] = e.LANISO(_).toLowerCase();
	});

	tracer && tracer("X3LANGS: " + sys.inspect(x3langs));

	return x3langs;
}

function _hasErrors(_, inst) {
	return inst.getAllDiagnoses(_).some(function(d) {
		return d.severity === "error";
	});
}

function _createEntry(_, endpoint, chapter, id, message) {

	tracer && tracer("_createEntry chapter:" + chapter + " id:" + id + ' text:' + message);
	tracer && tracer("endpoint "+endpoint.dataset(_)) ;
	try {
		var db = endpoint.getOrm(_);
		var entity = db.getEntity(_, "APLSTD", "$edit");

		var msg = entity.createInstance(_, db);
		msg.LANCHP(_, chapter);
		msg.LANNUM(_, id);
		msg.LAN(_, "ENG");
		msg.LANMES(_, message);
		var diags = [];
		msg.save(_);

		msg.getAllDiagnoses(_, diags);
		if (_hasErrors(_, msg)) {
			tracer && tracer("id: " + id);
			tracer && tracer("diagnose after save : " + sys.inspect(diags));
			return false;
		}
		tracer && tracer("success");

		var inst=db.fetchInstance(_,entity,{
        sdataWhere: "LANCHP eq 10032 and LAN eq 'ENG' and LANNUM eq 1"
    }) ;
		tracer && tracer ("fetched: "+JSON.stringify(inst.serializeInstance(_)) ) ;

	} catch (e) {
		tracer && tracer(e.message ? e.message : e)
	}
	return true;
}

function _updateEntry(_, endPoint, key, text, chapter, lannum) {
	tracer && tracer("_updateEntry " + lannum + ' new value: ' + text);
	var db = endPoint.getOrm(_);

	var entity = db.getEntity(_, "APLSTD", "$query");
	var msg = db.fetchInstance(_, entity, {
		sdataWhere : "LANCHP eq " + chapter + " and LAN eq 'ENG' and LANNUM eq " + lannum
	});
	tracer && tracer("old value: " + msg.LANMES(_));
	msg.LANMES(_, text);

	msg.save(_);
	var diags = [];
	msg.getAllDiagnoses(_, diags);
	if (_hasErrors(_, msg)) {
		tracer && tracer("id: " + lannum);
		tracer && tracer("updateEntry: diagnose after save : " + sys.inspect(diags));
		// return false;
	} else
		tracer && tracer("success");
	//ckeckDiagnoses(result) ;
}


/**************************TRANSLATION OF TEXTS IN JSON FILES IN THE RESOURCE FOLDERS********************/

//Syracuse->X3
exports.extractResources = function(_, instance, options, context) {
	var self = this;
	self.context = context;
	tracer=trace ;
	//tracer && tracer("parameters: " + sys.inspect(options));

	function extract(_, file) {
		
		function _checkEntry(_, key, message) {
			tracer && tracer ("_checkEntry key: "+key) ;
			var relpath = fsp.relative(rootpath, fpath);
			var dirkey = relpath.replace(/\\/g, '\/');
			tracer && tracer ("_checkEntry dirkey: "+dirkey) ;
			tracer && tracer("index: "+JSON.stringify(index,null,2)) ;
			var success = false;
			var seg = index[dirkey];

			if (index[dirkey] && index[dirkey][key]) {
				tracer && tracer("index[" + dirkey + "][" + key + "]=" + index[dirkey][key]);
				tracer && tracer("looking for id: "+index[dirkey][key].id);
				var x3message = _findMessage(_, x3Records, "LANNUM", index[dirkey][key].id);
				if (x3message) {
					tracer && tracer("x3message " + x3message)
					if (parsed[key] !== seg[key].text) {
						tracer && tracer("modifyed in Syracuse" + index[dirkey] + ' ' + index[dirkey][key]);
						if (x3message !== index[dirkey][key].text) {
							tracer && tracer(" update conflict for " + dirkey + ":" + key);
							if (options && options.$diagnoses)
								options.$diagnoses.push({ severity: "warning", message: locale.format(module, "updateConflict", dirkey + ":" + key,  x3message) });
							else{
								tracer && tracer ("WARNING: "+locale.format(module, "updateConflict", dirkey + ":" + key,  x3message));
								if (options && options.$diagnoses)
									options.$diagnoses.push({ severity: "warning", message: locale.format(module, "updateConflict", dirkey + ":" + key,  x3message) });
								else
									instance.$addDiagnose("warning", locale.format(module, "updateConflict", dirkey + ":" + key,  x3message));
							}
						} else {
							tracer && tracer("update entry");
							index[dirkey][key].text = message ;
							_updateEntry(_, endPoint, key,message, chapterSyracuse, seg[key].id);
						}
					}
				} else {
					tracer && tracer("inject message " + dirkey + ":" + key);

					try {
						success = _createEntry(_, instance.endpoint(_), chapterSyracuse, index[dirkey][key].id, message);
					} catch (ex) {
						console.log(" exception in createEntry: " + ex.stack);
					
						var fd = fs.open(indexpath, "w", "0666", _);
						fs.writeFile(indexpath, JSON.stringify(index, null, "\t"), "utf8", _);
						fs.close(fd, _);
					}
				}

			} else {

				if (!(typeof message == "string")) {
					if (options && options.$diagnoses)
						options.$diagnoses.push({ severity: 'error', message: locale.format(module, "incorrectType", dirkey, key) });
					else
						instance.$addDiagnose('error', locale.format(module, "incorrectType", dirkey, key));

					tracer && tracer("Value is not a string ; Christie should fix the format");
					tracer && tracer(sys.inspect(message));
					return;
				}
				tracer && tracer("new message: "+message) ;
				tracer && tracer("length: "+message.length) ;
				//TODO split the message
				var id ;
				if (message.length > maxLength) {
					tracer && tracer("Splitting long message");
					var chunks=[] ;
					_splitMessage(message,chunks) ;
					tracer && tracer("Chunks: "+sys.inspect(chunks)) ;

					var i;
					

					for (i=0; i<chunks.length;i++){
						id = index.count+1+i ;
						/*if ((index.count+1+i)<=maxNbRecords) ;
							id = index.count+1+i ;
						else
							id = ((index.count+1+i)%maxNbRecords) ;*/
						tracer && tracer("((index.count+1+i)%maxNbRecords): "+((index.count+1+i)%maxNbRecords)) ;
						var chunk;
						
						if (id<maxNbRecords){
							if (i==chunks.length-1 )// the last chunk does not contain marker
								chunk=chunks[i] ;
							else
						 		chunk=chunks[i]+"&>"+(id+1) ;
						}
						else if (id==maxNbRecords){
							if (i==chunks.length-1 )// the last chunk does not contain marker
								chunk=chunks[i] ;
							else
								chunk=chunks[i]+"&>"+(currentChapter+1)+'.1' ;		
						}
						else{ //id>maxNbRecords
							if (i==chunks.length-1 )// the last chunk does not contain marker
								chunk=chunks[i] ;
							id = ((index.count+1+i)%maxNbRecords) ;
						}
						tracer && tracer("_createEntry chunk: "+chunk) ;
						tracer && tracer("_createEntry id: "+id) ;
						tracer && tracer("_createEntry chapter: "+currentChapter) ;
						success = _createEntry(_, instance.endpoint(_), currentChapter, id, chunk);
						if (id==maxNbRecords)
							currentChapter++ ;
						tracer && tracer("success: "+success) ;
					}
					
					//instance.$addDiagnose('error', locale.format(module, "msgTooLong", dirkey, key, message));
					//return;
				}
				else{

				 tracer && tracer("**inject message " + dirkey + ":" + key);

				try {
					id = index.count%maxNbRecords + 1;
					success = _createEntry(_, instance.endpoint(_), chapterSyracuse, id, message);
				} catch (ex) {
					if (options && options.$diagnoses)
						options.$diagnoses.push({ severity: 'error', message: locale.format(module, "x3error")});
					 
					tracer && tracer(_, "exception in createEntry: " + ex.stack);
				}
			}
				if (success) {
					if (!index[dirkey])
						index[dirkey] = {};

					if (!index[dirkey][key]) { //add to the index
						index[dirkey][key] = {
							id : index.count%maxNbRecords + 1,
							text : message
						};
						if (chunks)
							index.count+=chunks.length ;
						else	
							index.count++;
					}
				}

			}
		}
		;

		var pos = file.indexOf("-en.json");
		if (pos != -1) {
			var name = file.substring(0, pos);
			var fpath = fsp.join(dir, "resources", file);
			// console.log("fpath: " + fpath);
			var input = fs.readFile(fpath, "utf8", _);
			try {
				var parsed = JSON.parse(input);
			} catch (e) {
				instance.$addDiagnose(module, "incorrectJsonFormat", fpath);
			}
			//console.log("PARSED: " + JSON.stringify(parsed,null,2));
			flows.eachKey(_, parsed, _checkEntry);
		}
	}

	function walk(_, file) {
		var path = fsp.join(dir, file); // dir + '\\' + file;
		//console.log("PATH "+path) ;
		var stat = fs.stat(path, _);

		if (stat.isDirectory()) {
			if (file === "resources") {

				var dircontent = fs.readdir(path, _);
				//console.log("call extract " + sys.inspect(dircontent));
				dircontent.forEach_(_, extract);
			} else {
				var dircontent = fs.readdir(path, _);
				var temp = dir;
				dir = path;
				dircontent.forEach_(_, walk);
				dir = temp;
			}
		}
	}

	tracer && tracer("extract texts");

	var endPoint = instance.endpoint(_);
	var index;
	options = options || {};
	maxNbRecords=options.maxNbRecords || maxNbRecords ;

	tracer && tracer("endPoint: " + JSON.stringify(endPoint.serializeInstance(_), null, 2));
	var db = endPoint.getOrm(_);
	//tracer && tracer("db: "+sys.inspect(db));

	var entity;
	entity = db.getEntity(_, "APLSTD", "$bulk");
	var x3Records = db.fetchInstances(_, entity, {
		count: fetchCountX3,
		sdataWhere : "LANCHP eq " + chapterSyracuse + " and LAN eq 'ENG' and LANNUM ne 0"
	});
	if (x3Records.length >= fetchCountX3)
	{
		throw new Error("Error: Maximum records to read is " + fetchCountX3 + " and this amount of records has been fetched. Aborting since some records may not be processed otherwise!");
	}
	tracer && tracer("x3Records read: " + x3Records.length);
	var dir;
	var indexdir;
	if (options.dir)
		dir = fsp.join(__dirname, "../../", options.dir);
	else
		dir = fsp.join(__dirname, "../../", "");

	if (options.indexdir)
		indexdir = fsp.join(__dirname, "../../", options.indexdir);
	else
		indexdir = fsp.join(__dirname, "../lib");
	tracer && tracer("INDEXDIR: " + indexdir);

	var indexpath = fsp.join(indexdir, "/index.json");
	tracer && tracer("indexpath: " + indexpath);
	var exists = fs.existsSync(indexpath);
	var data = "";
	if (exists) {
		var fd = fs.open(indexpath, "r", "0666", _);
		data = fs.readFile(indexpath, "utf8", _);
		fs.close(fd, _);
	}
	if (data == "") {
		index = {
			count : 0
		};
		tracer && tracer("data is empty ");
	} else{
	try{
		index = JSON.parse(data);
	} catch (e) {
		if (options && options.$diagnoses)
						options.$diagnoses.push({ severity: 'error', message: locale.format(module,"incorrectJsonFormat", indexpath) });
		else
				instance.$addDiagnose( 'error',locale.format(module,"incorrectJsonFormat", indexpath));
			}
	}
	var currentChapter=chapterSyracuse+ Math.floor(index.count / maxNbRecords )  ;
	var dircontent = fs.readdir(dir, _);
	dircontent.forEach_(_, walk);
	fd = fs.open(indexpath, "w+", "0666", _);

	fs.writeFile(indexpath, JSON.stringify(index, null, "\t"), "utf8", _);
	fs.close(fd, _);
}

//X3->Syracuse
exports.updateResources = function(_, instance, options, context) {
	//tracer=trace_update ;
	tracer && tracer("update resources");
	var self = this;
	self.context = context;
	options = options || {};

	var endPoint = instance.endpoint(_);
	var db = endPoint.getOrm(_);

	tracer && tracer("endPoint name " + endPoint.dataset(_));

	var langFname = _getLanguages(_, instance);
	tracer && tracer("languages: " + JSON.stringify(langFname));
	var index;

	var entity = db.getEntity(_, "APLSTD", "$query");

	var x3Records = [];
	var cursor = db.createCursor(_, entity, {
		sdataWhere : "LANCHP eq " + chapterSyracuse + " and LANNUM ne 0"
	});
	var inst;
	while (inst = cursor.next(_)) {
		if (!inst.LANNUM(_))
			tracer && tracer("ERROR: incorrect record,lannum is missing");
		//TODO instance.addDiagnose() ;
		if (!x3Records[inst.LANNUM(_)])
			var rec = x3Records[inst.LANNUM(_)] = {};
		rec[inst.LAN(_)] = inst.LANMES(_);
		tracer && tracer("x3Records[" + inst.LANNUM(_) + "]=" + inst.LANMES(_));
	}

	tracer && tracer("X3RECORDS: " + sys.inspect(x3Records));
	var dir;
	var indexdir;
	if (options.dir)
		dir = fsp.join(__dirname, "../../", options.dir);
	else
		dir = fsp.join(__dirname, "../../", "");

	if (options.indexdir)
		indexdir = fsp.join(__dirname, "../../", options.indexdir);
	else
		indexdir = fsp.join(__dirname, "../lib");

	var indexpath = fsp.join(indexdir, "/index.json");
	tracer && tracer("indexpath: " + indexpath);

	var fd = fs.open(indexpath, "a+", "0666", _);
	var data = fs.readFile(indexpath, "utf8", _);

	fs.close(fd, _);

	if (data == "") {
		index = {
			count : 0
		};
		tracer && tracer("data is empty");
	} else
	{
		try{
		index = JSON.parse(data);
		} catch (e) {
				instance.$addDiagnose(module, "incorrectJsonFormat", indexpath);
			}
	}
	flows.eachKey(_, index, function(_, k) {

		function loadLocalData(_, rec, dataBuffers) {
			//console.log("B dataBuffers" + sys.inspect(dataBuffers));
			flows.eachKey(_, rec, function(_, lang, txt) {

				var fd = fileHandlers[lang];
				if (!fd) {
					var file;
					var exists;
					var data;

					if (langFname[lang] === "en-us")
						file = fsp.join(rootpath, dirname, base + "-en" + ".json");
					else
						file = fsp.join(rootpath, dirname, base + "-" + langFname[lang] + ".json");
					//console.log("FILE: "+file) ;

					exists = fs.existsSync(file);
					if (exists) {
						filePaths[lang] = file;
						fd = fileHandlers[lang] = fs.open(file, "r", "0666", _);
						data = fs.readFile(file, "utf8", _);
						try{
						dataBuffers[lang] = JSON.parse(data);
						} catch (e) {
							instance.$addDiagnose(module, "incorrectJsonFormat", file);
							console.log("incorrectJsonFormat "+file) ;
						}
					} else {
						//ChRISTIE : NE PAS SUPPRIMER AVANT DE VALIDER LA DOC
						/*var parts = langFname[lang].split('-');
						file = fsp.join(rootpath, dirname, base + "-" + parts[0] + ".json");
						exists = fs.existsSync(file);
						if (exists) {
						    fd = fileHandlers[lang] = fs.open(file, "r", "0666", _);
						    data = fs.readFile(file, "utf8", _);
						    dataBuffers[lang] = JSON.parse(data);
						} else */
						if (lang == "ENG") {
							tracer && tracer("resources file deleted or moved: " + file);
							if (options && options.$diagnoses)
								options.$diagnoses.push({ severity: "warning", message: locale.format(module, "missingFile", file) });
							else
								instance.$addDiagnose("warning", locale.format(module, "missingFile", file));
							dataBuffers[lang]=null; 
							//return;
						} else
							dataBuffers[lang] = {};
					}
				}
			});
		}

		function saveData(_, rec, dataBuffers, filePaths, fileHandlers) {
			var fileHandlers = {};
			tracer && tracer("save data filePaths: " + JSON.stringify(filePaths));
			flows.eachKey(_, filePaths, function(_, lang, file) {
				var fd = fileHandlers[lang];
				if (fd)
					fs.close(fd, _);

				fd = fileHandlers[lang] = fs.open(file, "w+", "0666", _);

				if (fd) {
					tracer && tracer("write to file: " + file + " content: " + JSON.stringify(dataBuffers[lang]));
					fs.writeFile(file, JSON.stringify(dataBuffers[lang], null, "\t"), "utf8", _);
					fs.close(fd, _);
				} else {
					tracer && tracer("Error open file " + file);
				}
			});
		}

		var base = fsp.basename(k, "-en.json").replace(/\//g, fsp.sep);
		var dirname = fsp.dirname(k).replace(/\//g, fsp.sep);
		var fileHandlers = {};
		var filePaths = {};
		var dataBuffers = {};
		//tracer && tracer("index[" + k + "]=" + JSON.stringify(index[k], null, 2));
		if (k === "count")
			return;
		flows.eachKey(_, index[k], function(_, key, el) {

			var rec = x3Records[el.id]
			if (rec) {
				loadLocalData(_, rec, dataBuffers);
				flows.eachKey(_, langFname, function(_, lang, ext) {
					if (rec[lang]) {
						tracer && tracer("rec["+lang+"]: " + sys.inspect(rec[lang]));
						if (!dataBuffers[lang]) // file delete or moved
							return ;
						if (!filePaths[lang]) {
							var file;
							if (lang === 'ENG')
								file = fsp.join(rootpath, dirname, base + "-en" + ".json");
							else
								file = fsp.join(rootpath, dirname, base + "-" + langFname[lang] + ".json");

							filePaths[lang] = file;
							tracer && tracer("filePaths[" + lang + "]=" + filePaths[lang]);
						}
						if (lang != 'ENG')
							dataBuffers[lang][key] = rec[lang];
						else if (rec[lang] !== index[k][key].text) {
							tracer && tracer("modifyed in X3 " + k + ' ' + key + ' old value: ' + index[k][key].text + //
							" new value: " + k + ' ' + key + ' txt: ' + rec[lang]);
							if (!dataBuffers[lang][key]){
								instance.$addDiagnose("error", locale.format(module, "missingReference", k + ":" + key));
								return ;
							}

							if (dataBuffers[lang][key] !== index[k][key].text) {
								tracer && tracer(" update conflict for " + k + ":" + key);
								if (options && options.$diagnoses)
									options.$diagnoses.push({ severity: "warning", message: locale.format(module, "updateConflict", dirkey + ":" + key,  rec[lang]) });
								else
									instance.$addDiagnose("warning", locale.format(module, "updateConflict", dirkey + ":" + key,  rec[lang]));
							} else {
								tracer && tracer("update record lang: " + lang + "key: " + key);
								dataBuffers[lang][key] = rec[lang];
							}
						}
					}
				});
				//tracer && tracer("data buffers: " + sys.inspect(dataBuffers));
			}
		});

		saveData(_, rec, dataBuffers, filePaths, fileHandlers);
	});
}

/**************************TRANSLATION OF SYRACUSE ADMIN RESSOURCES********************/

//Syracuse->X3
exports.extractAdminResources = function(_, instance, options, context) {
 //tracer=trace_extract_admin ;

	function _extract(_, fpath, fname) {
		var success = false;
		
		tracer && tracer("_extract path: " + fpath);
		console.log("_extract path: " + fpath) ;
		var fd = fs.open(fpath, "a+", "0666", _);
		var contentStr = fs.readFile(fpath, "utf8", _);
		fs.close(fd, _);
		var jsonContent = JSON.parse(contentStr);
		var localization = jsonContent["$localization"];
		if (localization)
			var localizationRef = localization['en-us'];
		if (!localizationRef) {
			if (options && options.$diagnoses){
				options.$diagnoses.push({ severity: "error", message: locale.format(module, "noLocalizationRef", fname) });
			
			}
			else
				instance.$addDiagnose('error', locale.format(module, "noLocalizationRef", fname));
			return;
		}

		

		flows.eachKey(_, localizationRef, function(_, key, val) {
			if (index[fname] && index[fname][key]) {
				var x3message = _findMessage(_, x3Records, "LANNUM", index[fname][key].id);
				if (x3message) {
					 console.log("_checkEntry message " + x3message);
					 console.log("localizationRef[key] :" + localizationRef[key]);
					 console.log("index["+fname+"]["+key+"].text :"+index[fname][key].text) ;
					if (localizationRef[key] !== index[fname][key].text) {
						tracer && tracer("modifyed in Syracuse " + index[fname][key].text + ' ' + localizationRef[key]);
						if (x3message !== index[fname][key].text) {
							tracer && tracer(" update conflict for " + key);
							if (options && options.$diagnoses)
								options.$diagnoses.push({ severity: "warning", message: locale.format(module, "updateConflict", fname + ":" + key, x3message) });
							else
								instance.$addDiagnose("warning", locale.format(module, "updateConflict", fname + ":" + key, x3message));
						} else {
							tracer && tracer("update entry");
							index[fname][key].text = localizationRef[key];
							_updateEntry(_, endPoint, key, localizationRef[key], chapterAdmin, index[fname][key].id);
						}
					}
				} else {
					tracer && tracer("inject message " + key);
					_createEntry(_, instance.endpoint(_), chapterAdmin, index[fname][key].id, val);
				}
			} else {
				tracer && tracer("inject message " + key);
				var id = index.count + 1;
				success = _createEntry(_, instance.endpoint(_), chapterAdmin, id, val);
				if (!success)
					if (options && options.$diagnoses){
				options.$diagnoses.push({ severity: "error", message: locale.format(module, "createEntryfail", key, fname) });
			
				}
				else
					instance.$addDiagnose('error', locale.format(module, "createEntryfail", key, fname));
				if (!index[fname] && success)
					index[fname] = {};
				if (!index[fname][key] && success) {
					index[fname][key] = {};
					index[fname][key].text = val;
					index[fname][key].id = id;
					index.count++;
				}

			}

		});
	}

	var self = this;
	self.context = context;

	var endPoint = instance.endpoint(_);
	var db = endPoint.getOrm(_);

	var index;
	options = options || {};
	

	var entity = db.getEntity(_, "APLSTD", "$bulk");
	var x3Records = db.fetchInstances(_, entity, {
		count: fetchCountX3,
		sdataWhere : "LANCHP eq " + chapterAdmin + " and LAN eq 'ENG' and LANNUM ne 0"
	});
	tracer && tracer("x3Records read: " + x3Records.length);
	if (x3Records.length >= fetchCountX3)
	{
		throw new Error("Error: Maximum records to read is " + fetchCountX3 + " and this amount of records has been fetched. Aborting since some records may not be processed otherwise!");
	}

	tracer && tracer("extract admin resources: ");
	//console.log("X3RECORDS: " + sys.inspect(x3Records));
	var dir;
	var indexdir;
	if (options.dir)
		dir = options.dir;
	else
		dir = fsp.join(__dirname, "../../", "");
	
	if (options.indexdir)
		indexdir = fsp.join(__dirname, "../../", options.indexdir);
	else
		indexdir = fsp.join(__dirname, "../lib");

	var indexpath = fsp.join(indexdir, "indexAdmin.json");
	tracer && tracer("indexpath: " + indexpath);

	var fd = fs.open(indexpath, "a+", "0666", _);
	var data = fs.readFile(indexpath, "utf8", _);

	fs.close(fd, _);

	if (data == "") {
		index = {
			count : 0
		};
		tracer && tracer("data is empty ");
	} else
		index = JSON.parse(data);

	

	if (options.exportFile) {
		var path = dir;

		_extract(_, fsp.join(path, options.exportFile) ,options.exportFile);
	} else {
		var path = fsp.join(__dirname, "../../../import");
		var stat = fs.stat(path, _);
		if (stat.isDirectory()) {
			var dircontent = fs.readdir(path, _);

			dircontent.forEach_(_, function(_, fnam) {
				_extract(_, fsp.join(path, fnam), fnam);

			});
		}
	}
	fd = fs.open(indexpath, "w", "0666", _);
	fs.writeFile(indexpath, JSON.stringify(index, null, "\t"), "utf8", _);
	fs.close(fd, _);
}

//X3->Syracuse
exports.updateAdminResources = function(_, instance, options, context) {
	//tracer = trace_update_admin;

	function _update(_, fname) {

		var fpath = fsp.join(path, fname);
		tracer && tracer("-update fpath: " + fpath);
		var fd = fs.open(fpath, "a+", "0666", _);
		var contentStr = fs.readFile(fpath, "utf8", _);

		fs.close(fd, _);
		var jsonContent = JSON.parse(contentStr);
		var localization = jsonContent["$localization"];

		var langFname = _getLanguages(_, instance);
		tracer && tracer("LANGS: " + sys.inspect(langFname));

		flows.eachKey(_, index[fname], function(_, locCode, el) {

			if (locCode === 'count')
				return;
			var rec = x3Records[el.id];
			if (rec) {
				flows.eachKey(_, langFname, function(_, lang, isolang) {
					if (rec[lang]) {
						tracer && tracer("update " + localization[isolang][locCode] + " with " + rec[lang]);
						if (!localization[isolang])
							localization[isolang] = {};
						localization[isolang][locCode] = rec[lang];
					}
				});
			}
		});
		fs.writeFile(fpath, JSON.stringify(jsonContent, null, "\t"), "utf8", _);
	}

	tracer && tracer("update Admin resources");
	var self = this;
	self.context = context;
	options = options || {};
	

	var endPoint = instance.endpoint(_);
	var db = endPoint.getOrm(_);
	var entity = db.getEntity(_, "APLSTD", "$query");

	var x3Records = [];
	var cursor = db.createCursor(_, entity, {
		sdataWhere : "LANCHP eq " + chapterAdmin + " and LANNUM ne 0"
	});

	var inst;
	while (inst = cursor.next(_)) {
		if (!inst.LANNUM(_)) {
			tracer && tracer("ERROR: incorrect record,lannum is missing");
				if (options && options.$diagnoses){
				options.$diagnoses.push({ severity: "error", message: locale.format(module, "incorrectRecord", inst.LANCHP(_), inst.LAN(_), inst.LANMES(_)) });
			
				}
			instance.$addDiagnose('error', locale.format(module, "incorrectRecord", inst.LANCHP(_), inst.LAN(_), inst.LANMES(_)));
		}

		// tracer && tracer("x3 record " + inst.LANNUM(_) + '-' + inst.LAN(_) + '-' + inst.LANMES(_));
		if (!x3Records[inst.LANNUM(_)])
			var rec = x3Records[inst.LANNUM(_)] = {};
		rec[inst.LAN(_)] = inst.LANMES(_);
	}

	tracer && tracer("X3RECORDS: " + sys.inspect(x3Records));
	var exclude = [ "syracuse-admin-demo.json", "syracuse-sprint1-demo.json" ];
	var dir;
	var indexdir;
	var index;
	if (options.dir)
		dir = options.dir;
	else
		dir = fsp.join(__dirname, "../../", "");

	if (options.indexdir)
		indexdir = fsp.join(__dirname, "../../", options.indexdir);
	else
		indexdir = fsp.join(__dirname, "../lib");

	var indexpath = fsp.join(indexdir, "/indexAdmin.json");
	tracer && tracer("indexpath: " + indexpath);

	var fd = fs.open(indexpath, "a+", "0666", _);

	var data = fs.readFile(indexpath, "utf8", _);
	//tracer && tracer("index file content: " + sys.inspect(data));
	fs.close(fd, _);

	if (data == "") {
		index = {
			count : 0
		};
		tracer && tracer("empty data ");
	} else
		index = JSON.parse(data);

	if (options.exportFile) {
		//var fname = fsp.join(dir, options.exportFile);
		//tracer && tracer("exportFile: " + options.exportFile);
		var path = dir;

		_update(_, options.exportFile);
	} else {

		var path = fsp.join(__dirname, "../../../import");
		
		var stat = fs.stat(path, _);

		if (stat.isDirectory()) {
			var dircontent = fs.readdir(path, _);
			dircontent.filter(function(elt) {
				if (exclude.indexOf(elt) == -1)
					return true;
				else
					return false;
			});
			dircontent.forEach_(_, _update);
		}
	}
};

/**************************TRANSLATION OF DOTNET RESSOURCES ********************/

//Syracuse->X3
exports.extractDotnetResources = function(_, instance, options, context) {
	var self = this;
	self.context = context;
	//tracer = trace_dotnet_extract;
	tracer && tracer("parameters: " + sys.inspect(options));
	function extract(_, file) {

		function _checkEntry(_, key, message, fpath) {
			var relpath = fsp.relative(rootpath, fpath);
			var dirkey = relpath.replace(/\\/g, '\/');
			var success = false;
			var seg = index[dirkey];

			if (index[dirkey] && index[dirkey][key]) {
				tracer && tracer("index[" + dirkey + "][" + key + "]=" + index[dirkey][key].id);

				var x3message = _findMessage(_, x3Records, "LANNUM", index[dirkey][key].id);
				if (x3message) {
					tracer && tracer("index message: " + seg[key].text);
					tracer && tracer("x3message:     " + x3message);
					tracer && tracer("syra message:  " + message);
					//  
					if (message !== seg[key].text) {
						tracer && tracer("modifyed in Syracuse" + index[dirkey] + ' ' + index[dirkey][key]);
						if (x3message != index[dirkey][key].text ) {
							tracer && tracer("conflict for " + dirkey + ":" + key);
							if (options && options.$diagnoses)
								options.$diagnoses.push({ severity: "warning", message: locale.format(module, "updateConflict", dirkey + ":" + key,  x3message) });
							else
								instance.$addDiagnose("warning", locale.format(module, "updateConflict", dirkey + ":" + key,  x3message));
						} else {
							index[dirkey][key].text = message;
							_updateEntry(_, endPoint, key, message, chapterDotnet, seg[key].id);
						}
					}
				} else {
					tracer && tracer("inject message " + dirkey + ":" + key);
					try {
						success = _createEntry(_, instance.endpoint(_), chapterDotnet, index[dirkey][key].id, message);
					} catch (ex) {
						console.log(" exception in createEntry: " + ex.stack);
						// console.log("index: "+JSON.stringify(index,null,2)) ;
						var fd = fs.open(indexpath, "w", "0666", _);
						fs.writeFile(indexpath, JSON.stringify(index, null, "\t"), "utf8", _);
						fs.close(fd, _);
					}
				}
			} else {
				if (!(typeof message == "string")) {
					instance.$addDiagnose('error', locale.format(module, "incorrectType", dirkey, key));

					tracer && tracer("Value is not a string ; Christie should fix the format");
					tracer && tracer(sys.inspect(message));
					return;
				}
				if (message.length > maxLength) {
					tracer && tracer("Message too long");
					instance.$addDiagnose('error', locale.format(module, "msgTooLong", dirkey, key, message));
					return;
				}

				tracer && tracer("inject message " + dirkey + ":" + key);
				try {
					var id = ++index.minIdx;
					success = _createEntry(_, instance.endpoint(_), chapterDotnet, id, message);
				} catch (ex) {
					tracer && tracer(_, "exception in createEntry: " + ex.stack);
				}
				if (success) {
					if (!index[dirkey])
						index[dirkey] = {};

					if (!index[dirkey][key]) { //add to the index
						index[dirkey][key] = {
							id : id,
							text : message
						};
						index.count++;
					}
				}
			}
		}

		if (fsp.extname(file) != ".resx")
			return;
		
		tracer && tracer("testing file : " + file);
		var basename = fsp.basename(file, ".resx");
		var langext = fsp.extname(basename);
		if (langext != "")
		{
			tracer && tracer("rejected file : " + file);
			return;
		}

		var fpath = fsp.join(dir, file);
		tracer && tracer("process file : " + fpath);
		var xml = fs.readFile(fpath, _).toString("utf8"); //fs.readFile(fpath, "utf8", _);

		// remove xml comments
		var xml = xml.replace(/<!--([\s\S]*?)-->/gm, "");

		var regex = /<data*\sname="([\s\S]*?)"([\s\S]*?)<value>([\s\S]*?)<\/value>([\s\S]*?)<\/data>/gm
		var matches = [];
		var match;
		while (match = regex.exec(xml)) {
			var line = match[0];
			var key = match[1];
			var text = match[3];

			// only string type information has to be processed
			if (!(line.match(/<data[\s\S]*\stype=[\s\S]*<\/data>/) || //
			line.match(/<data[\s\S]*\smimetype=[\s\S]*<\/data>/) || //
			key.match(/^&gt;&gt;/))) {
				var obj = {
					key : key,
					text : text
				}
				tracer && tracer("OBJ: " + JSON.stringify(obj, null, 2));
				matches.push(obj);

				_checkEntry(_, key, text, fpath);

			}
		}
		tracer && tracer("matches: "+JSON.stringify(matches,null,2));

	}

	function walk(_, file) {
		var path = fsp.join(dir, file); // dir + '\\' + file;
		//console.log("PATH "+path) ;
		var stat = fs.stat(path, _);

		if (stat.isDirectory()) {
			var dircontent = fs.readdir(path, _);
			var temp = dir;
			dir = path;
			dircontent.forEach_(_, walk);
			dir = temp;
		} else {
			extract(_, file);
		}
	}

	var endPoint = instance.endpoint(_);
	var index;
	options = options || {};
	var db = endPoint.getOrm(_);

	var entity;
	entity = db.getEntity(_, "APLSTD", "$bulk");
	tracer && tracer("extract dotnet ressources ");
	var x3Records = db.fetchInstances(_, entity, {
		count: fetchCountX3,
		sdataWhere : "LANCHP eq " + chapterDotnet + " and LAN eq 'ENG' and LANNUM ne 0"
	});
	tracer && tracer("x3Records read: " + x3Records.length);
	x3Records.forEach_(_,function(_,r){
	tracer && tracer("x3Record: " + JSON.stringify(r.serializeInstance(_),null,2));
});
	if (x3Records.length >= fetchCountX3)
	{
		throw new Error("Error: Maximum records to read is " + fetchCountX3 + " and this amount of records has been fetched. Aborting since some records may not be processed otherwise!");
	}

	var dir;
	var indexdir;
	if (options.dir)
		dir = fsp.join(__dirname, "../../", options.dir);
	else
		dir = fsp.join(__dirname, "../../../dotnet");

	if (options.indexdir)
		indexdir = fsp.join(__dirname, "../../", options.indexdir);
	else
		indexdir = fsp.join(__dirname, "../lib");
	tracer && tracer("INDEXDIR: " + indexdir);

	var indexpath = fsp.join(indexdir, "/indexDotnet.json");
	tracer && tracer("indexpath: " + indexpath);
	var exists = fs.existsSync(indexpath);
	var data = "";
	if (exists) {
		var fd = fs.open(indexpath, "r", "0666", _);
		data = fs.readFile(indexpath, "utf8", _);
		fs.close(fd, _);
	}
	if (data == "") {
		index = {
			count : 0,
			minIdx: 0
		};
		tracer && tracer("data is empty ");
	} else {
		index = JSON.parse(data);
	}

	var dircontent = fs.readdir(dir, _);
	dircontent.forEach_(_, walk);
	fd = fs.open(indexpath, "w+", "0666", _);

	fs.writeFile(indexpath, JSON.stringify(index, null, "\t"), "utf8", _);
	fs.close(fd, _);
};

//X3->Syracuse
exports.updateDotnetResources = function(_, instance, options, context) {
	function _getReference(input) {
		var xml = input.replace(/<!--([\s\S]*?)-->/gm, "");
		var regex = /<data*\sname="([\s\S]*?)"([\s\S]*?)<value>([\s\S]*?)<\/value>([\s\S]*?)<\/data>/gm
		var matches = {};
		var match;
		while (match = regex.exec(xml)) {
			var line = match[0];
			var key = match[1];
			var text = match[3];

			// only string type information has to be processed
			if (!(line.match(/<data[\s\S]*\stype=[\s\S]*<\/data>/) || //
			line.match(/<data[\s\S]*\smimetype=[\s\S]*<\/data>/) || //
			key.match(/^&gt;&gt;/))) {
				matches[key] = text;
				//tracer && tracer("OBJ: "+JSON.stringify(obj,null,2)) ;   
			}
		}
		return matches;
		tracer && tracer("matches: " + JSON.stringify(matches, null, 2));
	}

	//tracer = trace_update_dotnet;
	tracer && tracer("update dotnet resources");
	var self = this;
	self.context = context;
	options = options || {};

	var endPoint = instance.endpoint(_);
	var db = endPoint.getOrm(_);

	tracer && tracer("endPoint name " + endPoint.dataset(_));

	var langFname = _getLanguages(_, instance);
	tracer && tracer("languages: " + JSON.stringify(langFname));
	var index;

	var entity = db.getEntity(_, "APLSTD", "$query");

	var x3Records = [];
	var cursor = db.createCursor(_, entity, {
		sdataWhere : "LANCHP eq " + chapterDotnet + " and LANNUM ne 0"
	});
	var inst;
	while (inst = cursor.next(_)) {
		if (!inst.LANNUM(_))
			tracer && tracer("ERROR: incorrect record,lannum is missing");
		//TODO instance.addDiagnose() ;
		if (!x3Records[inst.LANNUM(_)])
			var rec = x3Records[inst.LANNUM(_)] = {};
		rec[inst.LAN(_)] = inst.LANMES(_);
		if (inst.LAN(_) === 'ENG')
			rec["global"] = inst.LANMES(_);

		tracer && tracer("x3Records[" + inst.LANNUM(_) + "]=" + inst.LANMES(_));
	}

	tracer && tracer("X3RECORDS: " + sys.inspect(x3Records));
	var dir;
	var indexdir;
	if (options.dir)
		dir = fsp.join(__dirname, "../../", options.dir);
	else
		dir = fsp.join(__dirname, "../../", "");

	if (options.indexdir)
		indexdir = fsp.join(__dirname, "../../", options.indexdir);
	else
		indexdir = fsp.join(__dirname, "../lib");

	var indexpath = fsp.join(indexdir, "/indexDotnet.json");
	tracer && tracer("indexpath: " + indexpath);

	var fd = fs.open(indexpath, "a+", "0666", _);
	var data = fs.readFile(indexpath, "utf8", _);

	fs.close(fd, _);

	if (data == "") {
		index = {
			count : 0,
			minIdx : 0
		};
		tracer && tracer("data is empty");
	} else {
		index = JSON.parse(data);
		index.minIdx = index.minIdx || index.count;
	}

	flows.eachKey(_, index, function(_, k) {
		function loadLocalData(_, key) {
			var exists;
			var file;
			file = fsp.join(rootpath, dirname, base + ".resx");
			exists = fs.existsSync(file);
			if (!exists) {
				tracer && tracer("global resources file deleted or moved: " + file);
				if (options && options.$diagnoses)
					options.$diagnoses.push({ severity: "warning", message: llocale.format(module, "missingFile", file) });
				else
					instance.$addDiagnose("warning", locale.format(module, "missingFile", file));
				return;
			}
			var input = fs.readFile(file, "utf8", _);
			return input;
		}

		function _updateProjectFile(_, langExt, base, dirname) {
			var module = fsp.basename(dirname);
			var projPath = fsp.join(rootpath, dirname, module + ".csproj");
			var exists = fs.existsSync(projPath);
			if (!exists)
				return;
			var content = fs.readFile(projPath, "utf8", _);
			var toAdd = '<EmbeddedResource Include="' + base + '.' + langExt + '.resx"><DependentUpon>' + base + '.cs</DependentUpon></EmbeddedResource>';
			var s = '<EmbeddedResource[ ]+Include="' + base + '.resx">.*[^<]*<DependentUpon>[^<]*' + base + '.cs.*[^<]*' + '</DependentUpon>[\\s\\S]*?</EmbeddedResource>';

			var regex = new RegExp(s);
			var match = regex.exec(content);
			var txt = match[0] + toAdd;

			if (match[0]) {
				content = content.replace(match[0], txt);

				fs.writeFile(projPath, content, "utf8", _);
			}
		}

		function _saveChanges(_, dataBuffers, input, base, dirname) {
			var file;
			flows.eachKey(_, dataBuffers, function(_, lang, replacevalues) {

				tracer && tracer("lang: " + lang);
				tracer && tracer("BUFFER: " + JSON.stringify(replacevalues, null, 2));
				if (lang == "global") {
					file = fsp.join(rootpath, dirname, base + ".resx");
					tracer && tracer("global ressource file : " + file);
				} else {
					file = fsp.join(rootpath, dirname, base + "." + langFname[lang] + ".resx");
					tracer && tracer(" file to update : " + file);
					var parts = langFname[lang].split('-');
					var mainfile = fsp.join(rootpath, dirname, base + "." + parts[0] + ".resx");
					tracer && tracer(" main file to update : " + mainfile);
				}

				var xml = input.replace(/<!--([\s\S]*?)-->/gm, "");

				flows.eachKey(_, replacevalues, function(_, key, value) {
					tracer && tracer("KEY: " + key);
					tracer && tracer("value: " + value);
					key = key.replace('$', '[$]');
					var s = '<data[ ]+name="' + key + '".*>[^<]*<value>([^<]*)</value>[^<]*</data>';

					var regex = new RegExp(s);

					var match = regex.exec(input, "gm");
					tracer && tracer("MATCH: " + sys.inspect(match));

					input = input.replace(regex, function($0, $1) {
						return ($0.replace(/<value>([\s\S]*?)<\/value>/, '<value>' + value + '<\/value>'));
					});
					tracer && tracer("INPUT: " + input);
				});
				var exists = fs.existsSync(file);

				var fd = fs.open(file, "w+", "0666", _);

				fs.writeFile(file, input, "utf8", _);
				fs.close(fd, _);
				if (!exists && lang != "global")
					_updateProjectFile(_, langFname[lang], base, dirname);

				exists = fs.existsSync(mainfile);
				fd = fs.open(mainfile, "w+", "0666", _);
				fs.writeFile(mainfile, input, "utf8", _);
				fs.close(fd, _);
				if (!exists && lang != "global")
					_updateProjectFile(_, parts[0], base, dirname);

			});
		}

		var base = fsp.basename(k, ".resx").replace(/\//g, fsp.sep);
		var dirname = fsp.dirname(k).replace(/\//g, fsp.sep);

		var dataBuffers = {};
		tracer && tracer("index[" + k + "]=" + JSON.stringify(index[k], null, 2));
		if (k === "count" || k === "minIdx")
			return;

		flows.eachKey(_, index[k], function(_, key, el) {
			tracer && tracer("KEY: " + key);
			var rec = x3Records[el.id];
			if (!rec) {
				tracer && tracer("no x3  record");
				return;
			}
			var locData = loadLocalData(_, rec, dataBuffers);
			var reference = _getReference(locData);

			flows.eachKey(_, langFname, function(_, lang) {
				if (!rec[lang]) {
					return;
				}
				tracer && tracer("rec[" + lang + "]= " + sys.inspect(rec[lang]));

				if (lang == 'ENG') {
					tracer && tracer("index[" + k + "[" + key + "]=" + index[k][key].text);
					if (rec[lang] !== index[k][key].text) {
						tracer && tracer("modifyed in X3 " + k + ' ' + key + ' old value: ' + index[k][key].text + //
						" new value: " + k + ' ' + key + ' txt: ' + rec[lang]);
						//return;
					}
					if (reference[key] !== index[k][key].text) {
						tracer && tracer(" update conflict for " + k + ":" + key);
						if (options && options.$diagnoses)
							options.$diagnoses.push({ severity: "warning", message: locale.format(module, "updateConflict", k + ":" + key,  rec[lang]) });
						else
							instance.$addDiagnose("warning", locale.format(module, "updateConflict", k + ":" + key,  rec[lang]));
						return;
					}
					tracer && tracer("update record lang: " + lang + "key: " + key);
					dataBuffers["global"] = {};
					dataBuffers["global"][key] = rec[lang];
				}
				if (!dataBuffers[lang])
					dataBuffers[lang] = {};
				dataBuffers[lang][key] = rec[lang];
			});
			tracer && tracer("data buffers: " + sys.inspect(dataBuffers));
			_saveChanges(_, dataBuffers, locData, base, dirname);
			tracer && tracer("saved");
		});

	});
};
