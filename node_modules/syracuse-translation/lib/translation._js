"use strict";

/// !doc
///
/// # X3 translation helper
///
/// Extract syracuse texts in order to be translated by translators.
///
/// Update syracuse texts with the new texts and new supported language.
///
var fs = require('streamline-fs');
var os = require('os');
var streams = require('streamline/lib/streams/server/streams');
var fsp = require("path");
var sys = require("util");
var helpers = require("syracuse-core/lib/helpers");
var datetime = require("syracuse-core/lib/types/datetime");
var flows = require("streamline/lib/util/flows");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var locale = require("syracuse-core/lib/locale");
var config = require('syracuse-main/lib/nodeconfig').config; // must be first
var sha1 = require("node-oauth/lib/sha1");

var dev = (config.system || {}).enableDevelopmentFeatures;

var debug = dev && true;
var tracer; // = debug ? console.log : null;

var _extend = helpers.object.extend;

// TODO:
// Manage deleted entries that are no longer in syracuse
var categories = (function() {
	var categs = {
		$maxCount: 1999,
		$maxLength: 123,
		syracuse: {
			$name: "Syracuse",
			$description: "Syracuse resources",
			$min: 10031,
			$max: 10035
		},
		admin: {
			$name: "Admin",
			$description: "Syracuse admin",
			$min: 10036,
			$max: 10043,
			$exclude: ["syracuse-admin-demo.json", "syracuse-sprint1-demo.json", "x3-pages.json"]
		},
		dotNet: {
			$name: "DotNet",
			$description: "Syracuse dotNet",
			$min: 10044,
			$max: 10045
		}
	};

	function _getCurrentState(category) {
		category.$current = category.$current || category.$min;
		category.$ = category.$ || {};
		category.$[category.$current] = category.$[category.$current] || {};
		var state = category.$[category.$current];
		state.$nextId = (state.$nextId || 1);
		return state;
	}

	function _inc(category) {
		var state = category.getCurrentState(),
			id = state.$nextId++;

		if (state.$nextId > categs.$maxCount) {
			// tracer && tracer("switch chapter: " + category.$current + ", nextId=" + state.$nextId);
			if (category.$current >= category.$max) {
				// tracer && tracer("*** Chapter overflow: " + category.$current + ", nextId=" + state.$nextId);
				throw new Error("Chapter overflow");
			}
			category.$current++;
			state = category.getCurrentState();
			id = state.$nextId;
			// tracer && tracer("   after switching: " + category.$current + ", nextId=" + state.$nextId);
			// state.$nextId = (state.$nextId || 0) + 1;
		}
		category.$count++;
		return id;
	}

	function _currentKey(category, n) {
		var state = category.getCurrentState(),
			id;

		if (n && (state.$nextId + n - 1 > categs.$maxCount)) {
			if (category.$current >= category.$max) {
				// tracer && tracer("*** Chapter overflow: " + category.$current + ", nextId=" + state.$nextId);
				throw new Error(localizedText("chapterOverflow", category.$current));
			}
			category.$current++;
			state = category.getCurrentState();
		}
		id = state.$nextId;
		if (n) {
			id = [id, id + n - 1];
		}
		return {
			chp: category.$current,
			id: id
		};
	}

	Object.keys(categs).forEach(function(category) {
		categs[category].$count = 0;
		categs[category].inc = _inc.bind(null, categs[category]);
		categs[category].getCurrentState = _getCurrentState.bind(null, categs[category]);
		categs[category].currentKey = _currentKey.bind(null, categs[category]);
	});
	return categs;
})();

var defaultLanguage = {
	iso: "en-us",
	x3: locale.x3Language("en-us")
};
var fetchCountX3 = 16000;
var aplStdMaxLength = 123;
// var maxLength = aplStdMaxLength - 13;
var maxLength = aplStdMaxLength - 2;

config.session = config.session || {};
config.session.auth = config.session.auth || "basic";

helpers.pageFileStorage = false;

var rootpath = fsp.dirname(process.cwd());
var localizedText = locale.format.bind(undefined, module);

/// ## TranslationProcess class

function TranslationProcess(_, instance, options, context) {
	this.instance = instance;
	this.options = options || {};
	this.context = context;
	this.diagnosis = makeDiagnosisCollectors(_, instance, options);
	this.endpoint = this.options.endpoint || (instance && instance.endpoint(_));
	if (!this.endpoint) {
		throw new Error(localizedText("noSourceEndpoint"));
	}
	this.rootDir = fsp.join(__dirname, "../../", this.options.dir || "");
	this.targetDir = this.options.indexdir || fsp.join(__dirname, "../../../translation-indexes");
	if (!fs.exists(this.targetDir, _)) {
		fs.mkdir(this.targetDir, undefined, _);
	}
	this.store = store(_, this.endpoint, {
		diagnosis: this.diagnosis
	});
}

exports.TranslationProcess = helpers.defineClass(TranslationProcess, null, {
	/// ### getLanguages(_)
	/// return available X3 languages of the TABLAN table
	getLanguages: function(_) {
		tracer && tracer("getLanguages");
		if (this.languages) return this.languages;
		var db = adminHelper.getCollaborationOrm(_);
		var localePrefs = db.fetchInstances(_, db.model.getEntity(_, "localePreference"));
		var i;

		var isoCodes = localePrefs.map_(_, function(_, e) {
			return e.code(_);
		});
		// add for each isoCodes the same with _ because x3 store iso with _ instead of -
		var isoCodesFull = [];
		for (i = 0; i < isoCodes.length; i++) {
			isoCodesFull.push(isoCodes[i]);
			isoCodesFull.push(isoCodes[i].replace('-', '_'));
		}

		tracer && tracer("ISO CODES: " + sys.inspect(isoCodes));
		tracer && tracer("ISO CODES for X3: " + sys.inspect(isoCodesFull));

		var entity = db.getEntity(_, 'TABLAN', "$query");
		var where = "LANISO in  (";
		isoCodesFull.forEach_(_, function(_, code, idx) {
			if (idx === 0) where += '"' + code + '"';
			else {
				where += ', ';
				where += '"' + code + '"';
			}
		});
		where += ")";

		tracer && tracer("WHERE: " + where);

		var dbX3 = this.endpoint.getOrm(_);
		var langs = dbX3.fetchInstances(_, entity, {
			sdataWhere: where
		});
		var x3langs = {};
		langs.forEach_(_, function(_, e) {
			tracer && tracer(e.LAN(_) + '  : ' + e.LANISO(_));
			x3langs[e.LAN(_)] = e.LANISO(_).toLowerCase();
		});

		tracer && tracer("X3LANGS: " + sys.inspect(x3langs));
		var tabkey = Object.keys(x3langs);
		if (tabkey.length === 0) {
			throw new Error(localizedText("emptyTABLAN"));
		} else {
			for (i = 0; i < tabkey.length; i++) {
				if (x3langs[tabkey[i]].indexOf('_') !== -1) {
					x3langs[tabkey[i]] = x3langs[tabkey[i]].replace('_', '-');
				}
			}
		}
		this.languages = x3langs;
		return x3langs;
	},

	/// ### localeFile(_, base, lang)
	/// return the file name of the localization json file.
	localeFile: function(_, base, lang) {
		var isoMap = this.getLanguages(_),
			code = locale.defaultIso(lang) || isoMap[lang],
			file = code && fsp.join(rootpath, base + "-" + code + ".json");
		if (file) {
			if (!fs.exists(file, _)) {
				code = isoMap[lang];
				file = code && fsp.join(rootpath, base + "-" + code + ".json");
			}
			if (!file || !fs.exists(file, _)) {
				code = locale.longIso(locale.defaultIso(lang));
				file = code && fsp.join(rootpath, base + "-" + code + ".json");
			}
		}
		if (!file) {
			tracer && tracer("localeFile: undefined code for " + lang + ", defaultIso=" + locale.defaultIso(lang) + ", isoMap=" + isoMap[lang] + ", base=" + base);
		}
		return file || fsp.join(rootpath, base + "-__-__.json");
	},

	addEntry: function(_, entry) {
		var index = entry.index,
			chp = index.$chapter,
			val = entry.val,
			group = entry.group,
			state = chp.getCurrentState(),
			isoLang = entry.language && entry.language.iso,
			segment = entry.segment;

		tracer && tracer("addEntry isoLang=" + isoLang + ", group=" + group + ", length=" + val.length + ", val=" + val);
		// try {
		if (chp.$current > chp.$max) {
			tracer && tracer("addEntry - chapterFull " + entry.ident);
			this.diagnosis.error(localizedText("chapterFull", chp.$max, "admin resources"), _);
			// stop progression
			return {
				fatal: true
			};
		}
		if (!this.saveEntry(_, entry)) {
			this.diagnosis.error(localizedText("createEntryfail", entry.ident, entry.group), _);
			return {
				fatal: false
			};
		}

		var el = segment[entry.ident] = entry.key;
		if (isoLang) {
			el.text = el.text || {};
			el.text[isoLang] = entry.val;
		} else {
			el.text = entry.val;
		}
		el.$key = entry.$key;
		// } catch (ex) {
		//	this.diagnosis.error(localizedText("createEntryfail", entry.ident, entry.group), _);
		//	tracer && tracer(_, "exception in createEntry: " + ex.stack);
		//	return {
		//		fatal: true
		//	};
		// }
		return {
			fatal: false
		};
	},

	injectLongMessage: function(_, entry) {
		var language = (entry.language || defaultLanguage),
			message = entry.val,
			chapter = entry.index.$chapter;
		//
		tracer && tracer("injectLongMessage: chapter=" + JSON.stringify(chapter) + ", language=" + JSON.stringify(language) + ", message=" + message);
		var chunks = [];
		_splitMessage(message, chunks);
		if (chunks.length > 1 && (this.options.longMessagesStrategy === "truncate")) {
			chunks = [message.substring(0, aplStdMaxLength)];
			this.diagnosis.warning(localizedText("msgTooLong", entry.group, entry.ident, aplStdMaxLength, message), _);
		}

		tracer && tracer("Chunks: " + sys.inspect(chunks));
		var nbChunks = chunks.length,
			nbCreatedChuncks = 0,
			id = 0;

		// Put all chunks in the same chapter
		entry.key = chapter.currentKey(nbChunks);
		id = entry.key.id[0];
		for (var i = 0; i < nbChunks; i++) {
			chapter.inc();
			var chunk = chunks[i];

			// the last chunk does not contain marker
			if (i !== nbChunks - 1) {
				// chunk += "&>" + (entry.key.id + i);
				chunk += " _";
			}

			tracer && tracer("injectLongMessage: _createEntry chapter=" + entry.key.chp + ", id=" + id + ", chunk=" + chunk);
			var success = this.store.createEntry(_, entry.key.chp, id++, chunk, language, entry.$key);
			if (success) {
				nbCreatedChuncks++;
			} else {
				throw new Error("Cannot create entry!");
			}
		}

		tracer && tracer("injectLongMessage: nbCreatedChuncks: " + nbCreatedChuncks);
		return nbCreatedChuncks;
	},

	saveEntry: function(_, entry) {
		var index = entry.index,
			group = entry.group,
			chapter = entry.index.$chapter,
			state = chapter.getCurrentState(),
			val = entry.val;

		entry.key = chapter.currentKey();

		if (val && (val.length > categories.$maxLength)) {
			return this.injectLongMessage(_, entry);
		} else {
			if (this.store.createEntry(_, entry.key.chp, entry.key.id, entry.val, entry.language, entry.$key)) {
				return chapter.inc();
			}
		}
		return false;
	},

	updateEntry: function(_, el, entry) {
		var diagnosis = this.diagnosis,
			index = entry.index,
			isoLang = entry.language && entry.language.iso,
			x3Lang = entry.language && entry.language.x3,
			chapter = index.chapter,
			seg = index[entry.ident],
			message = entry.val,
			result = this.store.findMessage(_, el.chp, el.id, x3Lang),
			x3message = result.message,
			chunks = result.chunks;

		tracer && tracer("updateEntry     db message='" + x3message + "'");
		tracer && tracer("updateEntry source message='" + message + "'");
		tracer && tracer("updateEntry  index message='" + (el.text && el.text[isoLang] || "") + "'");
		if (chunks.length > 0) {
			el.text = el.text || {};
			// text has been modified since last extraction
			if (x3message !== message) {
				// tracer && tracer("modified since last extraction " + entry.ident + ": " + el.text[isoLang] + ' != ' + message);
				// Changed in DB and in source ==> conflict
				if (x3message !== el.text[isoLang] && message !== el.text[isoLang]) {
					diagnosis.error(localizedText("updateConflict", entry.group + "/" + entry.ident, el.chp + "," + el.id + "," + x3Lang, message, x3message, el.text[isoLang]), _);
					return;
				}
				this.store.updateEntry(_, el.chp, el.id, entry.language, message, chunks, entry.$key);
			}
			el.text[isoLang] = message;
		} else {
			// this situation should not happen. It means some records has been deleted from X3 since the last extraction
			// while testing it is better to delete the index file when emptiing the X3 chapters
			diagnosis.error(localizedText("indexMess", entry.group, entry.ident), _);
		}
	},

	initFrame: function(_, category, msgkey, opt) {
		var endpoint = this.endpoint,
			diagnosis = this.diagnosis,
			// indexpath = fsp.join(this.targetDir, "index" + category.$name + "-syra.json"),
			indexpath = fsp.join(this.targetDir, "index" + category.$name + ".json"),
			frame = this.frame = {
				category: category,
				options: _extend(this.options, opt || {}, true)
			},
			endpointName = endpoint.application(_) + "/" + endpoint.contract(_) + "/" + endpoint.dataset(_),
			index, g, e;

		if (this.instance.resetIndex(_)) {
			diagnosis.info(localizedText("deleteIndex", "index" + category.$name + ".json"), _);
			deteteIndex(_, indexpath, category, frame.options);
		}
		// frame.options.conflictPolicy = this.instance.conflictPolicy(_);
		index = readIndex(_, indexpath, category, frame.options);
		this.store.reset(_);
		frame.langMap = this.getLanguages(_);
		frame.indexMap = {};
		Object.keys(index).forEach(function(gk) {
			if (gk[0] === "$") return;
			g = index[gk];
			Object.keys(g).forEach(function(ek) {
				if (ek[0] === "$") return;
				e = g[ek];
				frame.indexMap[e.$key] = e;
			});
		});

		if (index.$config.$target.endpoint && index.$config.$target.endpoint.$uuid !== endpoint.$uuid) {
			return diagnosis.fatal(localizedText("endpointMismatch", index.$config.$target.endpoint.$uuid, index.$config.$target.endpoint.name, endpoint.$uuid, endpointName), null, _);
		}
		index.$config.$target = {
			endpoint: {
				$uuid: endpoint.$uuid,
				name: endpointName,
				description: endpoint.description(_)
			}
		};
		index.$config.$source = {
			user: {
				login: this.context.getUser(_).login(_)
			},
			host: {
				name: os.hostname(),
				platform: os.platform() + "-" + os.arch()
			}
		};

		tracer && tracer(msgkey + " " + index.$chapter.$name + " to " + endpoint.$uuid + " (" + (endpoint.x3ServerFolder(_) || "") + " - " + endpoint.description(_) + ")");
		diagnosis.info(localizedText(msgkey, index.$chapter.$name, endpoint.description(_)), _);

		frame.count = index.$chapter.$count;
		frame.x3Records = opt && opt.fetchRecords && this.store.getX3Records(_, index.$chapter);
		frame.index = index;
		frame.indexpath = indexpath;
		return this.frame;
	},

	endExtract: function(_) {
		var endpoint = this.endpoint,
			frame = this.frame,
			diagnosis = this.diagnosis,
			index = frame.index,
			count = frame.count,
			options = frame.options,
			afs = (options.indexFiler || fs),
			fd = afs.open(frame.indexpath, "w+", "0666", _);

		if (index.$chapter.$count - count > 0) {
			diagnosis.info(localizedText("endExtractResources", index.$chapter.$name, endpoint.description(_), (index.$chapter.$count - count)), _);
		} else {
			diagnosis.info(localizedText("endExtractResourcesNoText", index.$chapter.$name, endpoint.description(_)), _);
		}
		tracer && tracer("End extractResources: " + (index.$chapter.$count - count) + " text(s) added");

		delete index.$chapter;
		index.$config.$endTime = datetime.now().toString();
		afs.writeFile(frame.indexpath, JSON.stringify(index, null, "\t"), "utf8", _);

		afs.close(fd, _);

		this.store.flush(_);
	},

	terminate: function(_) {
		var diagnosis = this.diagnosis;
		if (diagnosis.hasError()) diagnosis.fatal(localizedText("endsWithError"), null, _);
	},

	tryParseJsonFile: function(_, file, opt) {
		try {
			return JSON.parse((opt && opt.fsModule || fs).readFile(file, "utf8", _));
		} catch (e) {
			return this.diagnosis.fatal(localizedText("incorrectJsonFormat", file), e.stack, _);
		}
	},

	/// ### extractAll(_)
	/// Extract all type of resources (Syracuse source, Administration space, Office add-ins)
	extractAll: function(_) {
		var opt = {
			// longMessagesStrategy: "truncate",
			extractAllLanguages: true
		};
		this.extractResources(_, opt);
		this.extractAdminResources(_, opt);
		this.extractDotnetResources(_);
	},

	extractResources: function(_, opt) {
		try {
			this.extractResources_(_, opt);
			if (this.instance.verify(_)) {
				this.verifyExtract(_);
			}
		} catch (e) {
			this.diagnosis.fatal(e.message || e, e.stack, _);
		}
	},

	extractResources_: function(_, opt) {
		var diagnosis = this.diagnosis,
			self = this;

		function _extractAllLang(_, file, dir) {
			var files = fs.readdir(fsp.join(dir, file), _),
				map = {},
				m, lang, e;

			function _extractLang(_, lang) {
				tracer && tracer("_extractLang " + lang);
				if (!map[lang]) {
					return diagnosis.error(localizedText("noLocalization", lang), _);
				}
				var language = {
					iso: lang,
					x3: locale.x3Language(lang, true)
				};
				if (!language.x3) {
					return diagnosis.error(localizedText("unknownLangMap", lang), _);
				}

				map[lang].forEach_(_, _extract);

				function _extract(_, file) {
					// var pos = file.indexOf("-en.json");
					// if (pos === -1) return;
					diagnosis.logInfo(localizedText("extractTextsOf", "file", file), _);

					var fpath = fsp.join(dir, "resources", file),
						parsed = self.tryParseJsonFile(_, fpath),
						m = /(.*?)-(\w{2}(-\w{2})?\.json)/gi.exec(fpath),
						checkEntry = _checkEntry(_, self, parsed, index, _groupKey(m && m[1] || "unmatched"), language);

					Object.keys(parsed).some_(_, checkEntry);
					// stop = true;
				}
			}

			files.forEach_(_, function(_, f) {
				m = /\w*-(\w{2}(-\w{2})?)\.json/gi.exec(f);
				lang = m && m[1];
				lang = lang && !m[2] ? locale.longIso(lang) : lang;
				if (lang && locale.x3Language(lang, true)) {
					lang = lang.toLowerCase();
					e = map[lang] = map[lang] || [];
					e.push(f);
				}
			});
			_extractLang(_, "en-us");

			Object.keys(map).filter(function(lang) {
				return options.extractAllLanguages && (lang.toLowerCase() !== "en-us");
			}).forEach_(_, _extractLang);
		}

		function walk(_, file) {
			var dir = this || "",
				path = fsp.join(dir, file),
				stat = fs.stat(path, _),
				files;
			// tracer && tracer("walk path=" + path);
			if (stat.isDirectory()) {
				if (file === "test") {
					// do not walk through the test folder
				} else if (file === "resources") {
					_extractAllLang(_, file, dir);
				} else {
					files = fs.readdir(path, _);
					files.forEach_(_, walk, path);
				}
			}
		}

		var frame = this.initFrame(_, categories.syracuse, "startExtractResources", opt),
			options = frame.options,
			index = this.frame.index;

		walk(_, this.rootDir);

		this.endExtract(_);
	},

	verifyExtract: function(_) {
		var frame = this.frame,
			diagnosis = this.diagnosis,
			index = frame.index,
			chapter = index.$chapter || index.$config.$chapter,
			x3Records = this.store.getX3Records(_, chapter, {
				noMeta: true
			}),
			meta = this.store.getX3Records(_, chapter, {
				metaOnly: true
			}),
			count = 0,
			chp, id, i, txt, item, g, e, r, lan, values;

		diagnosis.info(localizedText("startVerifyExtraction", chapter.$name), _);
		diagnosis.info(localizedText("foundRecordRange", x3Records.$count, chapter.$min, chapter.$max), _);

		function verify(_, vk) {
			txt = values[vk];
			lan = locale.x3Language(vk);
			r = item[lan];
			r && count++;

			!r && diagnosis.fatal(localizedText("entryNotFound", JSON.stringify(e), i, lan, JSON.stringify(item)), null, _);
		}

		Object.keys(index).forEach_(_, function(_, gk) {
			if (gk[0] === "$") return;
			g = index[gk];
			Object.keys(g).forEach_(_, function(_, ek) {
				if (ek[0] === "$") {
					// if (ek==="$key"){
					//	if (meta[e.chp] && meta[e.chp][id]
					// }
					// else
					return;
				}
				e = g[ek];
				chp = x3Records[e.chp];
				id = e.id;
				if (!Array.isArray(id)) {
					id = [id, id];
				}
				for (i = id[0]; i <= id[1]; i++) {
					item = chp && chp[i];
					values = e.text;
					if (item) {
						values && Object.keys(values).forEach_(_, verify);
					} else {
						diagnosis.fatal(localizedText("noRecordFound", JSON.stringify(e), i), null, _);
					}
				}
			});
		});
		diagnosis.info(localizedText("endVerifyExtraction", chapter.$name, count), _);
	},


	// ******************* ADMIN RESSOURCES ********************
	extractAdminResources: function(_, opt) {
		var count = 0,
			diagnosis = this.diagnosis,
			endpoint = this.endpoint,
			refKeys = {},
			self = this;

		function _extractAllLang(_, fpath, fname, fsModule) {
			tracer && tracer("_extractAllLang path: " + fpath);
			var jsonContent = self.tryParseJsonFile(_, fpath, {
				fsModule: fsModule || fs
			}),
				localizations;
			localizations = jsonContent.$localization || {};
			refKeys = localizationKeys(jsonContent);
			// tracer && tracer("localizationKeys=" + JSON.stringify(refKeys));

			function _extractLang(_, lang) {
				tracer && tracer("_extractLang " + lang);
				if (!localizations[lang]) {
					diagnosis.error(localizedText("noLocalization", lang), _);
					return false;
				}
				var language = {
					iso: lang,
					x3: locale.x3Language(lang, true)
				};
				if (!language.x3) {
					diagnosis.error(localizedText("unknownLangMap", lang), _);
					return false;
				}

				// var whereClause = "LANCHP ge " + index.$chapter.$min + " and LANCHP le " + index.$chapter.$max + " and LANNUM ne 0 and LAN eq \"" + locale.x3Language(lang) + "\"";
				return _extract(_, localizations[lang], fname, language);
			}

			tracer && tracer("_extracting en-us " + fpath);
			// extract en-us as a reference for the index
			_extractLang(_, "en-us");

			// extract all other languages
			Object.keys(localizations).filter(function(lang) {
				return options.extractAllLanguages && (lang.toLowerCase() !== "en-us");
			}).forEach_(_, _extractLang);
		}

		function _extract(_, localizationRef, fname, language) {
			var success = false,
				lang = language.iso,
				checkEntry = _checkEntry(_, self, localizationRef, index, _groupKey(fname), language);

			diagnosis.logInfo(localizedText("extractTextsOf", "admin resource", fname + ":" + lang), _);
			Object.keys(localizationRef).some_(_, function(_, key) {
				if (!refKeys[key]) {
					return diagnosis.logWarning(localizedText("unusedText", localizationRef[key], key), _);
				}
				return checkEntry(_, key);
			});
		}

		var frame = this.initFrame(_, categories.admin, "startExtractResources", opt),
			index = frame.index,
			options = frame.options,
			x3Records = frame.x3Records;

		var exclude = index.$chapter.$exclude || [],
			dir = options.dir || fsp.join(__dirname, "../../");

		tracer && tracer("Start extraction " + index.$chapter.$name + " to " + endpoint.x3ServerFolder(_) + " (" + endpoint.description(_) + ")");


		var path;
		count = index.$chapter.$count;
		if (options.exportFile) {
			path = dir;
			_extractAllLang(_, fsp.join(path, options.exportFile), options.exportFile, options.inputFiler);
		} else {
			path = fsp.join(__dirname, "../../../import");
			var stat = fs.stat(path, _);
			if (stat.isDirectory()) {
				var dircontent = fs.readdir(path, _);
				tracer && tracer("dircontent: " + dircontent);
				dircontent = dircontent.filter(function(elt) {
					return (exclude.indexOf(elt) === -1);
				});
				tracer && tracer("dircontent: " + dircontent);

				dircontent.forEach_(_, function(_, fnam) {
					_extractAllLang(_, fsp.join(path, fnam), fnam, options.inputFiler);
				});
			}
		}
		this.endExtract(_);
	},

	// *******************  DOTNET RESSOURCES ********************
	extractDotnetResources: function(_, opt) {
		var self = this,
			diagnosis = this.diagnosis;

		function extract(_, file) {

			if (fsp.extname(file) !== ".resx") return;

			var fpath = fsp.join(dir, file),
				basename = fsp.basename(file, ".resx"),
				langext = fsp.extname(basename);
			if (langext !== "") {
				diagnosis.logInfo(localizedText("rejectResource", "resx file", fpath), _);
				return;
			}

			diagnosis.logInfo(localizedText("extractTextsOf", "resx file", fpath), _);
			var xml = (options.inputFiler || fs).readFile(fpath, _).toString("utf8"),
				checkEntry = null;
			// remove xml comments
			xml = xml.replace(/<!--([\s\S]*?)-->/gm, "");

			var regex = /<data*\sname="([\s\S]*?)"([\s\S]*?)>([\s\S]*?)<\/data>/gim;

			var match, resources = {};
			while (match = regex.exec(xml)) {
				var line = match[0],
					key = match[1],
					value = /<value>([\s\S]*?)<\/value>/gi.exec(match[3]),
					text = value && value[1] || "";

				// only string type information has to be processed
				if (!line.match(/<data[\s\S]*\s(type|mimetype)=[\s\S]*<\/data>/gi) && key.match(/^(?!&gt;&gt;).+\..+/)) {
					key = key.replace(/\$(.*)/, "@$1");
					resources[key] = text;
					tracer && tracer("key=" + key + ', text="' + text + '"');
				}
			}
			checkEntry = _checkEntry(_, self, resources, index, _groupKey(fpath));
			Object.keys(resources).some_(_, checkEntry);
		}

		function walk(_, file) {
			var path = fsp.join(dir, file); // dir + '\\' + file;
			var stat = fs.stat(path, _);

			if (stat.isDirectory()) {
				var dircontent = fs.readdir(path, _);
				var temp = dir;
				dir = path;
				dircontent.forEach_(_, walk);
				dir = temp;
			} else {
				extract(_, file);
			}
		}

		var frame = this.initFrame(_, categories.dotNet, "startExtractResources", opt),
			index = frame.index,
			options = frame.options,
			x3Records = frame.x3Records;

		var dir = options.dir || fsp.join(__dirname, "../../../dotnet");

		if (options.exportFile) {
			extract(_, options.exportFile);
		} else {
			fs.readdir(dir, _).forEach_(_, walk);
		}

		this.endExtract(_);
	},

	updateAll: function(_) {
		var opt = {
			fetchRecords: true
		};

		this.updateResources(_, opt);
		// this.updateAdminResources(_, opt);
		// this.updateDotnetResources(_, opt);
	},

	endUpdate: function(_) {
		var endpoint = this.endpoint,
			frame = this.frame,
			diagnosis = this.diagnosis,
			index = frame.index,
			count = frame.count,
			options = frame.options,
			afs = (options.indexFiler || fs),
			fd = afs.open(frame.indexpath, "w+", "0666", _);

		// save index modifications
		afs.writeFile(frame.indexpath, JSON.stringify(index, null, "\t"), "utf8", _);

		afs.close(fd, _);

		if (index.$chapter.$count - count > 0) {
			diagnosis.info(localizedText("endUpdateResources", index.$chapter.$name, endpoint.description(_), (index.$chapter.$count - count)), _);
		} else {
			diagnosis.info(localizedText("endUpdateResourcesNoText", index.$chapter.$name, endpoint.description(_)), _);
		}
	},

	updateResources: function(_, opt) {
		var diagnosis = this.diagnosis,
			endpoint = this.endpoint,
			self = this;

		function updFile(_, k) {
			diagnosis.logInfo(localizedText("updateTextsOf", "file", k), _);
			tracer && tracer("updFile: " + k);

			function saveData(_, rec) {
				tracer && tracer("save data src: " + JSON.stringify(updateCtx));
				flows.eachKey(_, updateCtx, function(_, lang, src) {
					tracer && tracer("save data src of lang " + lang + ": " + JSON.stringify(src, null, 2));
					if (!src.dirty) return;
					try {
						tracer && tracer("write to file: " + src.file + " content: " + JSON.stringify(src.data));
						fs.writeFile(src.file, JSON.stringify(src.data, null, "\t"), "utf8", _);
					} catch (ex) {
						diagnosis.fatal(localizedText("fileWritingError", src.file), ex.stack, _);
					}
				});
			}

			function updData(_, key) {
				var el = segment[key],
					langMap = frame.langMap;
				tracer && tracer("updData: " + key + ' ' + JSON.stringify(el, null, 2));

				function loadLocalData(_, rec) {
					// tracer && tracer("loadLocalData for rec: " + JSON.stringify(rec, null, 2));
					Object.keys(rec).forEach_(_, function(_, lang) {
						if (lang === "XXX") return;
						var src = updateCtx[lang] = updateCtx[lang] || {};

						if (src.data) return;
						src.isolang = langMap[lang];
						var file = self.localeFile(_, base, lang);

						if (fs.exists(file, _)) {
							src.file = file;
							src.data = self.tryParseJsonFile(_, file);
						} else {
							tracer && tracer("resources file deleted or moved: " + file);
							diagnosis.warning(localizedText("missingFile", file, lang), _);
							src.data = {};
						}
					});
					// tracer && tracer("loadLocalData context: " + JSON.stringify(updateCtx, null, 2));
				}

				var chapter = el.chp,
					rec = x3Records[chapter] && x3Records[chapter][el.id];
				if (rec) {
					tracer && tracer("loadLocalData for record " + sys.inspect(rec));
					loadLocalData(_, rec);
					var refObj = _getRefObj(rec["XXX"]),
						ref = refObj.key,
						eRef = ref && frame.indexMap[ref];
					if (eRef && (eRef.chp !== chapter) || (eRef.id !== el.id)) {
						return diagnosis.fatal(localizedText("invalidBinding", ref, chapter, el.id, eRef.chp, eRef.id), null, _);
					}
					if (!ref) {
						return diagnosis.fatal(localizedText("missingReference", k, key), null, _);
					}
					Object.keys(langMap).forEach_(_, function(_, lang) {
						if (lang === "XXX") return;
						var targetText = rec[lang];
						if (targetText) {
							var src = updateCtx[lang] = updateCtx[lang] || {},
								isolang = src.isolang = src.isolang || langMap[lang],
								indexText = el.text[isolang];
							tracer && tracer("rec[" + lang + "]: " + sys.inspect(targetText));

							if (!src.data) {
								// file deleted or moved
								return;
							}

							src.file = src.file || self.localeFile(_, base, lang);
							if (targetText !== indexText) {
								tracer && tracer("Modified in X3 " + k + "/" + key + "[" + lang + "] old value=" + indexText + " new value=" + targetText);
								// tracer && tracer("src.data lang: " + lang + ' ' + JSON.stringify(src.data, null, 2));
								if (indexText && src.data[key] !== indexText) {
									if (targetText === src.data[key]) {
										tracer && tracer("update index " + k + "/" + key + ": '" + el.text[isolang] + "' => '" + targetText + "'");
										el.text[isolang] = targetText;
										// diagnosis.info(localizedText("updateConflict", k + "/" + key, el.chp + "," + el.id + "," + lang, src.data[key], targetText, indexText), _);
									} else {
										tracer && tracer("update conflict for " + k + "/" + key + "[" + lang + "]\ns=" + src.data[key] + "\nt=" + targetText + "\ni=" + indexText);
										diagnosis.error(localizedText("updateConflict", k + "/" + key, el.chp + "," + el.id + "," + lang, src.data[key], targetText, indexText), _);
									}
								} else {
									tracer && tracer("update record lang: " + lang + "key: " + key);
									src.data[key] = el.text[isolang] = targetText;
									src.dirty = true;
								}
							}
						}
					});
					tracer && tracer("updateCtx=" + sys.inspect(updateCtx));
					saveData(_, rec);
				}
			} // updData
			var base = k.replace(/\//g, fsp.sep),
				updateCtx = {},
				segment = index[k];
			// tracer && tracer("index[" + k + "]=" + JSON.stringify(segment, null, 2));
			Object.keys(segment).filter(function(k) {
				return k[0] !== "$";
			}).forEach_(_, updData);
		}

		var frame = this.initFrame(_, categories.syracuse, "startUpdateResources", opt),
			index = frame.index,
			x3Records = frame.x3Records;

		Object.keys(index).filter(function(k) {
			return k[0] !== "$";
		}).forEach_(_, updFile);
		this.endUpdate(_);
	},

	updateAdminResources: function(_, opt) {
		var diagnosis = this.diagnosis,
			endpoint = this.endpoint,
			self = this;

		function _update(_, fname) {
			var fpath = fsp.join(path, fname);
			tracer && tracer("-update fpath: " + fpath);
			var fsModule = (options.dataFiler || fs),
				jsonContent = self.tryParseJsonFile(_, fpath, {
					fsModule: fsModule
				}),
				localization = jsonContent.$localization,
				langMap = self.getLanguages(_);

			tracer && tracer("LANGS: " + sys.inspect(langMap));

			flows.eachKey(_, index[fname], function(_, locCode, el) {
				// Object.keys(index[fname]).forEach_(_, function(_, locCode, el) {
				if (locCode[0] === '$') return;
				var rec = x3Records[el.chp][el.id];
				if (rec) {
					flows.eachKey(_, langMap, function(_, lang, isolang) {
						// Object.keys(langMap).forEach_(_, function(_, lang, isolang) {
						if (rec[lang]) {
							tracer && tracer("update " + localization[isolang][locCode] + " with " + rec[lang]);
							if (!localization[isolang]) localization[isolang] = {};
							localization[isolang][locCode] = rec[lang];
						}
					});
				}
			});
			fsModule.writeFile(fpath, JSON.stringify(jsonContent, null, "\t"), "utf8", _);
		}

		var frame = this.initFrame(_, categories.admin, "startUpdateResources", opt),
			index = frame.index,
			options = frame.options,
			x3Records = frame.x3Records;


		var walker = (function(_) {
			return {
				proceed: _update,
				exclude: function(elt) {
					return (excludes.indexOf(elt) === -1);
				}
			};
		})();

		walk(_, options.dir || fsp.join(__dirname, "../../"), walker);

		var excludes = index.$chapter.$exclude || [],
			path = options.exportFile ? options.dir || fsp.join(__dirname, "../../") : fsp.join(__dirname, "../../../import");

		if (options.exportFile) {
			_update(_, options.exportFile);
		} else {
			if (fs.stat(path, _).isDirectory()) {
				var dircontent = fs.readdir(path, _);
				dircontent = dircontent.filter(function(elt) {
					return (excludes.indexOf(elt) === -1);
				});
				dircontent.forEach_(_, _update);
			}
		}
	},

	updateDotnetResources: function(_, opt) {
		var diagnosis = this.diagnosis,
			options = _extend(this.options, opt || {}, true),
			endpoint = this.endpoint;

		function _getReference(input) {
			var xml = input.replace(/<!--([\s\S]*?)-->/gm, "");
			var regex = /<data*\sname="([\s\S]*?)"([\s\S]*?)<value>([\s\S]*?)<\/value>([\s\S]*?)<\/data>/gm;
			var matches = {};
			var match;
			while (match = regex.exec(xml)) {
				var line = match[0],
					key = match[1],
					text = match[3];

				// only string type information has to be processed
				if (!(line.match(/<data[\s\S]*\stype=[\s\S]*<\/data>/) || //
					line.match(/<data[\s\S]*\smimetype=[\s\S]*<\/data>/) || //
					key.match(/^&gt;&gt;/))) {
					matches[key] = text;
					//tracer && tracer("OBJ: "+JSON.stringify(obj,null,2)) ;
				}
			}
			tracer && tracer("matches: " + JSON.stringify(matches, null, 2));
			return matches;
		}

		var indexpath = fsp.join(this.targetDir, "/indexDotnet.json");
		tracer && tracer("indexpath: " + indexpath);
		index = readIndex(_, indexpath, categories.dotNet, options);

		tracer && tracer("update dotnet resources: endpoint_name=" + endpoint.dataset(_));

		var langMap = this.getLanguages(_);
		tracer && tracer("languages: " + JSON.stringify(langMap));
		var index;

		var x3Records = this.store.getX3Records(_, index.$chapter);

		var dir;
		if (options.dir) dir = fsp.join(__dirname, "../../", options.dir);
		else dir = fsp.join(__dirname, "../../", "");

		flows.eachKey(_, index, function(_, k) {
			// Object.keys(index).forEach_(_, function(_, k) {

			function loadLocalData(_) {
				var exists;
				var file;
				file = fsp.join(rootpath, dirname, base + ".resx");
				exists = fs.exists(file, _);
				if (!exists) {
					tracer && tracer("global resources file deleted or moved: " + file);
					diagnosis.warning(localizedText("missingFile", file), _);
					return;
				}
				var input = fs.readFile(file, "utf8", _);
				return input;
			}

			function _updateProjectFile(_, langExt, base, dirname) {
				var module = fsp.basename(dirname);
				var projPath = fsp.join(rootpath, dirname, module + ".csproj");
				var exists = fs.exists(projPath, _);
				if (!exists) return;
				var content = fs.readFile(projPath, "utf8", _);
				var toAdd = '<EmbeddedResource Include="' + base + '.' + langExt + '.resx"><DependentUpon>' + base + '.cs</DependentUpon></EmbeddedResource>';
				var s = '<EmbeddedResource[ ]+Include="' + base + '.resx">.*[^<]*<DependentUpon>[^<]*' + base + '.cs.*[^<]*' + '</DependentUpon>[\\s\\S]*?</EmbeddedResource>';

				var regex = new RegExp(s);
				var match = regex.exec(content);
				var txt = match[0] + toAdd;

				if (match[0]) {
					content = content.replace(match[0], txt);

					fs.writeFile(projPath, content, "utf8", _);
				}
			}

			function _saveChanges(_, dataBuffers, input, base, dirname) {
				var file;

				// If there is not a single translation for a language,
				// add an empty object to dataBuffer for the language to have the
				// resource file generated.
				flows.eachKey(_, langMap, function(_, lang) {
					// Object.keys(langMap).forEach_(_, function(_, lang) {
					if (!dataBuffers[lang]) dataBuffers[lang] = {};
				});
				flows.eachKey(_, dataBuffers, function(_, lang, replacevalues) {
					// Object.keys(dataBuffers).forEach_(_, function(_, lang, replacevalues) {
					tracer && tracer("lang: " + lang);
					//tracer && tracer("BUFFER: " + JSON.stringify(replacevalues, null, 2));
					var mainfile;
					var parts;
					if (lang === "global") {
						file = fsp.join(rootpath, dirname, base + ".resx");
						tracer && tracer("global ressource file : " + file);
					} else {
						file = fsp.join(rootpath, dirname, base + "." + langMap[lang] + ".resx");
						tracer && tracer(" file to update : " + file);
						parts = langMap[lang].split('-');
						mainfile = fsp.join(rootpath, dirname, base + "." + parts[0] + ".resx");
						tracer && tracer(" main file to update : " + mainfile);
					}

					flows.eachKey(_, replacevalues, function(_, key, value) {
						// Object.keys(replacevalues).forEach_(_, function(_, key, value) {
						tracer && tracer("KEY: " + key);
						tracer && tracer("value: " + value);
						key = key.replace('$', '[$]');
						var s = '<data[ ]+name="' + key + '".*>[^<]*<value>([^<]*)</value>[^<]*</data>';

						var regex = new RegExp(s);

						//var match = regex.exec(input, "gm");
						//tracer && tracer("MATCH: " + sys.inspect(match));
						input = input.replace(regex, function($0) {
							return ($0.replace(/<value>([\s\S]*?)<\/value>/, '<value>' + value + '<\/value>'));
						});
						//tracer && tracer("INPUT: " + input);
					});
					var exists = fs.exists(file, _);
					tracer && tracer("File exists: " + file + ": " + file);
					var fd = fs.open(file, "w+", "0666", _);

					fs.writeFile(file, input, "utf8", _);
					fs.close(fd, _);
					if (!exists && lang !== "global") _updateProjectFile(_, langMap[lang], base, dirname);

					if (mainfile) {
						exists = fs.exists(mainfile, _);

						fd = fs.open(mainfile, "w+", "0666", _);
						fs.writeFile(mainfile, input, "utf8", _);
						fs.close(fd, _);
						if (!exists && lang !== "global") _updateProjectFile(_, parts[0], base, dirname);
					}

				});
			}

			var base = fsp.basename(k, ".resx").replace(/\//g, fsp.sep);
			var dirname = fsp.dirname(k).replace(/\//g, fsp.sep);

			var dataBuffers = {};
			tracer && tracer("index[" + k + "]=" + JSON.stringify(index[k], null, 2));
			if (k === "count" || k === "minIdx") return;

			var fileObj = index[k];

			flows.eachKey(_, fileObj, function(_, key, el) {
				// Object.keys(fileObj).forEach_(_, function(_, key, el) {
				tracer && tracer("KEY: " + key);
				var rec = x3Records[el.chp] && x3Records[el.chp][el.id];
				if (!rec) {
					tracer && tracer("no x3  record:" + el.chp + "/" + el.id);
					return;
				}
				tracer && tracer("x3 record: " + JSON.stringify(rec, null, 2));
				var locData = loadLocalData(_, rec, dataBuffers);
				var reference = _getReference(locData);

				flows.eachKey(_, langMap, function(_, lang) {
					// Object.keys(langMap).forEach_(_, function(_, lang) {
					if (!rec[lang]) {
						return;
					}
					tracer && tracer("rec[" + lang + "]= " + sys.inspect(rec[lang]));

					if (lang === 'ENG') {
						tracer && tracer("index[" + k + "[" + key + "]=" + el.text);
						if (rec[lang] !== el.text) {
							tracer && tracer("modifyed in X3 " + k + ' ' + key + ' old value: ' + el.text + //
								" new value: " + k + ' ' + key + ' txt: ' + rec[lang]);
							//return;
						}
						if (reference[key] !== el.text) {
							tracer && tracer(" update conflict for " + k + ":" + key);
							diagnosis.warning(localizedText("updateConflict", k, key, rec[lang]), _);
							return;
						}
						tracer && tracer("update record lang: " + lang + "key: " + key);
						dataBuffers.global = {};
						dataBuffers.global[key] = rec[lang];
					}
					if (!dataBuffers[lang]) dataBuffers[lang] = {};
					dataBuffers[lang][key] = rec[lang];
				});
				tracer && tracer("data buffers: " + sys.inspect(dataBuffers));
				_saveChanges(_, dataBuffers, locData, base, dirname);
				tracer && tracer("saved");
			});

		});
	}
});

//===============================================================================================

function store(_, endpoint, options) {
	var diagnosis = options.diagnosis,
		db = endpoint.getOrm(_),
		entity = db.getEntity(_, "APLSTD", "$edit"),
		set;

	function _addErrors(_, msg) {
		if (diagnosis) {
			var diags = [];
			msg.getAllDiagnoses(_, diags);
			diags = diags.filter(function(d) {
				return d.severity === "error";
			});
			diags.forEach_(_, function(_, d) {
				diagnosis.add(d.severity, d.message, _);
			});
			if (diags.length > 0) {
				tracer && tracer("diagnoses store op " + msg.LAN(_) + ":" + msg.LANCHP(_) + ":" + msg.LANNUM(_) + sys.inspect(diags));
				return true;
			}
		}
	}

	function _sdataEqual(chp, num, lang) {
		return "LANCHP eq " + chp + " and LANNUM eq " + num + " and LAN eq '" + lang + "'";
	}

	function _getX3Records(_, chapter, opt) {
		var entity = db.getEntity(_, "APLSTD", "$bulk"),
			lang = opt && opt.lang,
			x3Records = opt && opt.obj || {},
			whereClause, records;
		if (typeof(chapter) === "object") {
			whereClause = "LANCHP ge " + chapter.$min + " and LANCHP le " + chapter.$max + " and LANNUM ne 0";
		} else {
			whereClause = "LANCHP eq " + chapter + " and LANNUM ne 0";
		}
		if (opt && opt.metaOnly) {
			whereClause += ' and LAN eq "XXX"';
		} else {
			whereClause += (opt && opt.noMeta ? ' and LAN ne "XXX"' : "") + (lang ? ' and LAN eq "' + (locale.x3Language(lang) || lang) + '"' : "");
		}

		tracer && tracer("getX3Records: whereClause=" + whereClause);
		// var entity = db.getEntity(_, "APLSTD", "$query");
		records = db.fetchInstances(_, entity, {
			count: fetchCountX3,
			sdataWhere: whereClause
		}) || [];
		if (records.length >= fetchCountX3) {
			throw new Error("Error: Maximum records to read is " + fetchCountX3 + " and this amount of records has been fetched. Aborting since some records may not be processed otherwise!");
		}
		x3Records.$count = records.length;
		tracer && tracer("getX3Records count=" + records.length);
		records.forEach_(_, function(_, e) {
			x3Records[e.LANCHP(_)] = x3Records[e.LANCHP(_)] || {};
			x3Records[e.LANCHP(_)][e.LANNUM(_)] = x3Records[e.LANCHP(_)][e.LANNUM(_)] || {};
			x3Records[e.LANCHP(_)][e.LANNUM(_)][e.LAN(_)] = e.LANMES(_);
		});
		return x3Records;
	}

	function _findMessage(_, lanchp, lannum, lang) {
		var d = set.deleted.data,
			c = set.created.data,
			u = set.updated.data,
			r = set.x3Records.data,
			chapter, nums, i, msg, text, match, result;

		lang = lang || "ENG";
		if (Array.isArray(lannum)) {
			for (nums = [], i = lannum[0]; i <= lannum[1]; i++) {
				nums.push(i);
			}
		} else {
			nums = [lannum];
		}
		result = {
			message: "",
			chunks: []
		};
		_initChapter(_, lanchp);
		chapter = r[lanchp] || u[lanchp] || c[lanchp];
		if (chapter) {
			result = nums.reduce(function(r, n) {
				text = _getText(lanchp, n, lang).text;
				if (text) {
					r.chunks.push(text);
					r.message += text.replace(/(\s+_\s*)$/, " ");
				}
				// if (chapter[n]) {
				//	text = chapter[n][lang];
				//	r.chunks.push(text);
				//	r.message += text.replace(/(\s+_\s*)$/, " ");
				// }
				return r;
			}, result);
		}

		tracer && tracer("_findMessage: " + lanchp + ", " + lannum + ", " + lang + ", result='" + JSON.stringify(result, null, 2));
		return result;
	}


	function _reset(_) {
		set = {
			x3Records: {
				$name: "origin",
				data: {}
			},
			created: {
				$name: "create",
				data: {}
			},
			updated: {
				$name: "update",
				data: {}
			},
			deleted: {
				$name: "delete",
				data: {}
			}
		};
	}

	function _initChapter(_, chp) {
		var data = set.x3Records.data;
		if (!data[chp]) {
			data[chp] = {};
			_getX3Records(_, chp, {
				obj: data
			});
		}
	}

	function _flush(_) {
		var created = set.created.data,
			updated = set.updated.data,
			deleted = set.deleted.data,
			c, n, e, ue, ce;

		tracer && tracer("_flush set=" + JSON.stringify(set, null, 2));

		// removed deleted from created and updated
		Object.keys(deleted).forEach_(_, function(_, chp) {
			if (chp[0] === "$") return;
			c = deleted[chp];
			ue = updated[chp];
			ce = created[chp];
			Object.keys(c).forEach_(_, function(_, id) {
				n = c[id];
				ue = ue && ue[id];
				ce = ce && ce[id];
				Object.keys(n).forEach_(_, function(_, lan) {
					ue && delete ue[n];
					ce && delete ce[n];
				});
			});
		});
		set.deleted.data = {};
		// created
		Object.keys(created).forEach_(_, function(_, chp) {
			if (chp[0] === "$") return;
			c = created[chp];
			Object.keys(c).forEach_(_, function(_, id) {
				n = c[id];
				Object.keys(n).forEach_(_, function(_, lan) {
					_dbCreate(_, chp, id, n[lan], lan);
				});
			});
		});
		set.created.data = {};
		// updated
		Object.keys(updated).forEach_(_, function(_, chp) {
			if (chp[0] === "$") return;
			c = updated[chp];
			Object.keys(c).forEach_(_, function(_, id) {
				n = c[id];
				Object.keys(n).forEach_(_, function(_, lan) {
					_dbUpdate(_, chp, id, n[lan], lan);
				});
			});
		});
		set.updated.data = {};
	}

	function _dbCreate(_, chp, id, t, lan) {
		var msg = entity.createInstance(_, db);
		msg.LANCHP(_, parseInt(chp, 10));
		msg.LANNUM(_, parseInt(id, 10));
		msg.LAN(_, lan);
		// put at least a single space to create the record
		msg.LANMES(_, t || " ");
		msg.save(_);
		_addErrors(_, msg);
	}

	function _dbUpdate(_, chp, id, t, lan) {
		var msg = db.fetchInstance(_, entity, {
			sdataWhere: _sdataEqual(chp, id, lan)
		});
		// tracer && tracer("i: " + i + ", old value: " + msg.LANMES(_));
		msg.LANMES(_, t || " ");
		msg.save(_);
		_addErrors(_, msg);
	}

	function _setText(col, chp, id, lan, t) {
		col = col.data;
		col[chp] = col[chp] || {};
		col[chp][id] = col[chp][id] || {};
		col[chp][id][lan] = t || " ";
	}

	function _getText(chp, id, lan) {
		var d = set.deleted.data,
			c = set.created.data,
			u = set.updated.data,
			r = set.x3Records.data;

		if (d[chp] && d[chp][id] && d[chp][id][lan]) {
			return {
				$col: d
			};
		}

		if (u[chp] && u[chp][id] && u[chp][id][lan]) {
			return {
				text: u[chp] && u[chp][id] && u[chp][id][lan],
				$col: u
			};
		}
		if (c[chp] && c[chp][id] && c[chp][id][lan]) {
			return {
				text: u[chp] && u[chp][id] && u[chp][id][lan],
				$col: c
			};
		}
		return {
			text: r[chp] && r[chp][id] && r[chp][id][lan],
			$col: r
		};
	}

	function _createEntry(_, chp, id, message, language, refkey) {
		language = language || defaultLanguage;
		var x3Lang = language.x3,
			refObj, ref, t;

		_initChapter(_, chp);
		tracer && tracer("_createEntry endpoint=" + endpoint.dataset(_) + ", language=" + JSON.stringify(language) + ", key=" + chp + ":" + id + ', text="' + message + '"');
		t = _getText(chp, id, x3Lang);
		if (t.text) {
			return diagnosis.fatal(localizedText("duplicateKey", chp, id, x3Lang), null, _);
		}

		_setText(set.created, chp, id, x3Lang, message);

		refObj = _getRefObj(_getText(chp, id, "XXX").text);
		ref = refObj.key;
		if (ref && ref !== refkey) {
			return diagnosis.fatal(localizedText("checksumMismatch", "create", chp, id, x3Lang, JSON.stringify(refkey), JSON.stringify(ref)), null, _);
		} else if (!ref) {
			// tracer && tracer("ref=" + JSON.stringify(ref));
			_setText(set.created, chp, id, "XXX", refkey);
		}
		return true;
	}

	function _updateEntry(_, chp, lannum, language, text, chunks, refkey) {
		language = language || defaultLanguage;
		var x3Lang = language.x3,
			refObj, ref, t;

		_initChapter(_, chp);
		tracer && tracer("_updateEntry: language=" + JSON.stringify(language) + ", num=" + lannum + ' new value=' + text);

		var msg, i, diags;
		var newChunks = [];
		if (text.length > aplStdMaxLength) {
			_splitMessage(text, newChunks);
			tracer && tracer("old chunks " + JSON.stringify(chunks, null, 2));
			tracer && tracer("new chunks " + JSON.stringify(newChunks, null, 2));
			if (newChunks.length > chunks.length) {
				tracer && tracer(localizedText("cannotExtend", chp, lannum, x3Lang));
				return diagnosis.error(localizedText("cannotExtend", chp, lannum, x3Lang), _);
			}
		} else {
			newChunks.push(text);
		}

		for (i = 0; i < newChunks.length; i++) {
			refObj = _getRefObj(_getText(chp, i, "XXX").text);
			ref = refObj.key;
			if (ref && ref !== refkey) {
				return diagnosis.fatal(localizedText("checksumMismatch", "update", chp, i, x3Lang, JSON.stringify(refkey), JSON.stringify(ref)), null, _);
			}

			t = _getText(chp, i, x3Lang);
			if (t.$col && t.$col.$name === "delete") {
				delete t.$col[chp][lannum + i][x3Lang];
				t.$col = set.updated;
			}
			_setText(t.$col || set.created, chp, lannum + i, x3Lang);
			// tracer && tracer("i: " + i + ", old value: " + msg.LANMES(_));
		}
	}

	// db.resetCache && db.resetCache();
	return {
		reset: _reset,
		getX3Records: _getX3Records,
		findMessage: _findMessage,
		createEntry: _createEntry,
		updateEntry: _updateEntry,
		flush: _flush
	};
}

function getLogFile(options) {
	// console.log("getLogFile.this=" + sys.inspect(this, {
	//	showHidden: true,
	//	depth: 2
	// }));
	return fsp.join(indexDir(options), "translation.log");
}

exports.getLogFile = getLogFile;

function indexDir(options) {
	return options && options.indexdir || fsp.join(__dirname, "../../../translation-indexes");
}

function makeDiagnosisCollectors(_, instance, options) {
	var collector, fatal, logger, ws;
	var redirectDiagnosis = debug && false;
	var logName = fsp.join(indexDir(options), "translation.log");
	var fd, hasError;

	logger = function(severity, message, _) {
		hasError = hasError || severity.toLowerCase() === "error";
		if (!fd) {
			fd = fs.open(logName, "w+", "0666", _);
		}
		fs.appendFile(logName, datetime.now() + " [" + severity.toUpperCase() + "] " + message + "\n", "utf8", _);
		redirectDiagnosis && tracer && tracer("Diagnosis - " + severity + ": " + message);

	};
	fatal = function(message, stack, _) {};

	if (options && options.$diagnoses) {
		tracer("makeDiagnosisCollectors with options.$diagnoses");
		collector = function(severity, message) {
			hasError = hasError || severity.toLowerCase() === "error";
			options.$diagnoses.push({
				severity: severity,
				message: message
			});
		};
		fatal = function(message, stack, _) {
			hasError = true;
			var d = {
				$severity: "error",
				$message: message
			};
			if (stack) d.$stackTrace = stack;
			options.$diagnoses.push(d);
			logger("error", message + (stack ? "\n" + stack : ""), _);
		};
	} else {
		tracer("makeDiagnosisCollectors without options.$diagnoses");
		collector = function(severity, message) {
			hasError = hasError || severity.toLowerCase() === "error";
			instance.$addDiagnose(severity, message);
		};
	}

	function dualReport(severity, message, _) {
		collector(severity, message);
		logger(severity, message, _);
	}

	return {
		info: dualReport.bind(undefined, "info"),
		warning: dualReport.bind(undefined, "warning"),
		error: dualReport.bind(undefined, "error"),
		add: dualReport,
		fatal: fatal,
		logInfo: logger.bind(undefined, "info"),
		logError: logger.bind(undefined, "error"),
		logWarning: logger.bind(undefined, "warning"),
		logClose: function(_) {
			fs.close(fd, _);
			fd = undefined;
		},
		hasError: function() {
			return hasError;
		}
	};
}

function deteteIndex(_, indexpath, chapter, options) {
	var fsModule = options && options.indexFiler || fs;
	fsModule.exists(indexpath, _) && fsModule.unlink(indexpath, _);
}

function readIndex(_, indexpath, chapter, options) {
	tracer && tracer("indexpath: " + indexpath);
	var fsModule = options && options.indexFiler || fs,
		diags = options && options.$diagnoses,
		index, data = fsModule.exists(indexpath, _) && fsModule.readFile(indexpath, "utf8", _);
	if (!data) {
		index = {};
		tracer && tracer("data is empty ");
	} else {
		try {
			index = JSON.parse(data);
			// tracer && tracer("index data " + JSON.stringify(index, null, 2));
		} catch (e) {
			throw new Error(localizedText("incorrectJsonFormat", indexpath));
		}
	}

	function newEntry(index, group, ident, val, language) {
		var segment = index[group] = index[group] || {},
			e;
		segment.$key = segment.$key || sha1.hex_sha1(group);

		e = {
			group: group,
			ident: ident,
			val: val || " ",
			language: language || defaultLanguage,
			index: index,
			segment: segment,
			$key: sha1.hex_sha1(segment.$key + "/" + ident),
		};
		e.keyString = e.group + "/" + e.ident + "['" + e.language.iso + "']";
		return e;
	}

	index.newEntry = newEntry.bind(null, index);

	return _initIndexChapter(index, chapter);
}

function _initIndexChapter(index, chapter) {
	index.$config = index.$config || {};
	index.$config.$startTime = datetime.now().toString();
	index.$config.$endTime = "";
	index.$config.$chapter = _extend(chapter, index.$config.$chapter, true, true);
	index.$config.$target = index.$config.$target || {};
	index.$config.$source = index.$config.$source || {};

	index.$chapter = index.$config.$chapter;
	return index;
}

function _splitMessage(message, chunks) {
	var length = message.length;
	var end;
	var beg = 0;
	if (length <= aplStdMaxLength) {
		end = length;
		chunks.push(message);
	} else {
		end = maxLength;

		var substr = message.substring(beg, end);
		tracer && tracer("substr " + substr);
		var len = end - 1;

		while (!(/\s/.exec(substr[len])) && len > 0) len--;
		chunks.push(message.substring(beg, len + 1));
		if (len === 0 && (!(/\s/.exec(substr[len])))) tracer && tracer("Can not be splitted correctly. Long chunck without white spaces: " + message);
		substr = message.substring(len + 1, length);
		_splitMessage(substr, chunks);
	}
}

exports.deleteAll = function(_, instance, options) {
	var endpoint = instance && instance.endpoint(_),
		diagnosis = makeDiagnosisCollectors(_, instance, options),
		db = endpoint.getOrm(_),
		// entity = db.getEntity(_, "APLSTD", "$bulk"),
		entity = db.getEntity(_, "APLSTD", "$query"),
		chaptersToDelete = [],
		count = 0;
	for (var i = categories.syracuse.$min; i <= categories.dotNet.$max; i++) {
		chaptersToDelete.push(i);
	}
	tracer && tracer("deleteAll: " + chaptersToDelete);
	options = options || {};
	chaptersToDelete.forEach_(_, function(_, chapter) {
		var x3Records = db.fetchInstances(_, entity, {
			sdataWhere: "LANCHP eq " + chapter + " and LANNUM ne 0 and LANNUM gt 0"
			// sdataWhere: "LANCHP eq " + chapter
		}); //and LAN eq 'ENG'
		diagnosis.info(localizedText("deleteChapterRecords", chapter, x3Records.length), _);
		count += x3Records.length;
		x3Records.forEach_(_, function(_, rec) {
			rec.deleteSelf(_);
		});
	});
	diagnosis.info(localizedText("deleteTotalRecords", count), _);
};


function _groupKey(file) {
	var path = fsp.relative(rootpath, file);
	return path.replace(/\\/g, '\/');
}

function _checkEntry(_, translation, resources, index, grpkey, language) {
	var segment = index[grpkey],
		options = translation.options,
		diagnosis = translation.diagnosis;

	return function(_, key) {
		var message = resources[key],
			el = segment && segment[key],
			entry = index.newEntry(grpkey, key, message, language),
			isoLang = entry.language && entry.language.iso,
			status = null;

		tracer && tracer("_checkEntry: key=" + grpkey + ':' + key + ", indexEntry=" + sys.inspect(el || {}));

		if (message === null) {
			return diagnosis.warning(localizedText("nullValue", entry.keyString), _);
		} else if (typeof(message) !== "string") {
			return diagnosis.warning(localizedText("incorrectType", entry.keyString, typeof(message), JSON.stringify(message)), _);
		}
		if (message && (options.longMessagesStrategy === "truncate") && (message.length > aplStdMaxLength)) {
			message = message.substring(0, aplStdMaxLength);
			diagnosis.warning(localizedText("msgTooLong", grpkey, key, aplStdMaxLength, message), _);
		}
		if (el) {
			if (el.$key !== entry.$key) {
				diagnosis.fatal(localizedText("checksumMismatch", "check", el.chp, el.id, isoLang, JSON.stringify(entry.$key), JSON.stringify(el.$key)), null, _);
				return true;
			}
			if (el.text && el.text[isoLang] == null) {
				tracer && tracer("add lang " + isoLang + ", text='" + el.text[isoLang] + "'");
				el.text[isoLang] = entry.val;
				translation.store.createEntry(_, el.chp, el.id, entry.val, entry.language, entry.$key);
			} else {
				status = translation.updateEntry(_, el, entry);
			}
		} else {
			status = translation.addEntry(_, entry);
		}
		return status && status.fatal;
	};
}

function localizationKeys(json) {
	var proto = json && json.$prototypes,
		items = json && json.$items || [],
		localization = json && json.$localization && json.$localization["en-us"] || {},
		protoKeys = {},
		l10n = {},
		path = null,
		t, t0 = new Date().getTime();
	if (!proto || items.length === 0) return protoKeys;

	Object.keys(proto).forEach(function(type) {
		var t = protoKeys[type] = {};
		path = [];
		helpers.object.traverse(proto[type], {
			visit: function(key, val) {
				// tracer && tracer("visit path: " + path.join(".") + ", item: " + key + "=" + JSON.stringify(val));
				if (key[0] === "$") {
					if (key === "$localized" && Array.isArray(val)) {
						val.forEach(function(localized) {
							path.push(localized);
							// tracer && tracer("visit add protokey=" + path.join(".") + ", val=" + val);
							t[path.join(".")] = true;
							path.pop();
						});
					}
					return false;
				}
				path.push(key);
				return true;
			},
			leave: function(key, val) {
				// tracer && tracer("leave path: " + path.join(".") + ", item: " + key + "=" + JSON.stringify(val));
				path.pop();
			}
		});
	});
	// tracer && tracer("protoKeys=" + JSON.stringify(protoKeys));
	var prop;
	items.forEach(function(item) {
		t = item.$type && protoKeys[item.$type];
		// tracer && tracer("item type=" + item.$type);
		if (t) {
			path = [];
			helpers.object.traverse(item, {
				visit: function(key, val) {
					if (key[0] === "$") return false;
					path.push(key);
					// tracer && tracer("visit path: " + path.join(".") + ", item: " + key + "=" + JSON.stringify(val));
					if (t[path.join(".")]) {
						// tracer && tracer("visit add key=" + path.join(".") + ", val=" + val);
						l10n[val] = true;
					}
					return true;
				},
				visitLeaf: function(key, val) {
					// tracer && tracer("visitLeaf keys=" + key + ", val=" + val);
					if (typeof(val) === "string" && localization[val]) {
						// tracer && tracer("visitLeaf add key=" + key + ", val=" + val);
						l10n[val] = true;
					}
				},
				leave: function(key, val) {
					// tracer && tracer("leave path: " + path.join(".") + ", item: " + key + "=" + JSON.stringify(val));
					path.pop();
				}
			});
		}
	});
	tracer && tracer("localizationKeys elapsed=" + (new Date().getTime() - t0));
	return l10n;
}

exports.localizationKeys = localizationKeys;

function localizationExists(json, search) {
	var found;
	helpers.object.traverse(json, function(key, val) {
		if (found || key === "$localization") return false;

		if (typeof(val) === "string" && search === val) {
			found = key;
			return false;
		}
		return true;
	});

	return found;
}

function _getRefObj(refText) {
	var a = refText && refText.split(";") || [];
	return {
		key: a[0],
		tick: a[1]
	};
}

function walk(_, dir, walker) {
	var path;
	if (walker.single) {
		walker.proceed(_, dir);
	} else {
		path = walker.initialPath;
		// path = fsp.join(__dirname, "../../../import");
		var stat = fs.stat(path, _);

		if (stat.isDirectory()) {
			var dircontent = fs.readdir(path, _);
			dircontent = dircontent.filter(function(elt) {
				return walker.exclude(elt);
				// return (exclude.indexOf(elt) === -1);
			});
			dircontent.forEach_(_, walker.proceed);
		}
	}
}