"use strict";

var sys = require("util");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var t9n = require("syracuse-translation/lib/translation");
var World = require("syracuse-translation/lib/inprocWorld");
var TranslationProcess = t9n.TranslationProcess;
var jsurl = require("jsurl");
var helpers = require('@sage/syracuse-core').helpers;

var fs = require('streamline-fs');
var fsp = require("path");
var flows = require('streamline-runtime').flows;

var locked = false;

exports.entity = {
	$isPersistent: false,
	$canSave: false,

	$titleTemplate: "Translation",
	$descriptionTemplate: "Translation of syracuse messages and administration data",
	$valueTemplate: "{description}",
	$properties: {
		syracuse: {
			$title: "Syracuse resources",
			$type: "boolean",
			$default: true
		},
		dotnet: {
			$title: "DotNet resources",
			$type: "boolean",
			$default: true
		},
		admin: {
			$title: "Admin resources",
			$type: "boolean",
			$default: true
		},
		advancedOptions: {
			$title: "Advanced options",
			$type: "boolean",
			$default: false,
			$isHidden: false
		},
		filterAdmin: {
			$title: "Filter admin resources",
			$type: "boolean",
			$default: true
		},
		resetIndex: {
			$title: "Reset index",
			$type: "boolean",
			$default: false
		},
		ignoreIndexEndpoint: {
			$title: "Ignore index endpoint",
			$type: "boolean",
			$default: true
				// $isHidden:false
		},
		ignoreChecksum: {
			$title: "Ignore checksum",
			$type: "boolean",
			$default: true
				// $isHidden:false
		},
		loadFromIndex: {
			$title: "Load from index (reinject only)",
			$type: "boolean",
			$isHidden: false
		},
		noDBStore: {
			$title: "No DB Store",
			$type: "boolean",
			$default: false
		},
		noDBFlush: {
			$title: "Do not write to target endpoint",
			$type: "boolean",
			$default: false
		},
		renumber: {
			$title: "Renumber messages",
			$type: "boolean",
			$default: false
		},
		verify: {
			$title: "Verify (extract only)",
			$type: "boolean",
			$isHidden: true
		},
	},
	$relations: {
		endpointWrite: {
			$title: "Target endpoint",
			$description: "Select the endpoint used to write text translations (should be SUPERV)",
			$type: "endPoint",
			// $isMandatory: true,
			$isDefined: true,
			$isHidden: advancedOptionsIsHidden,
			$lookupFilter: {
				// for testing purposes, comment filter
				//protocol: "x3"
			}
		},
		endpointRead: {
			$title: "Source endpoint",
			$description: "Select the endpoint used to read text translations (should be SUPERV7)",
			$type: "endPoint",
			// $isMandatory: true,
			$isDefined: true,
			$lookupFilter: {
				// for testing purposes, comment filter
				//protocol: "x3"
			},
			$propagate: function(_, instance, val) {
				instance.endpointWrite(_, val);
			}
		}
	},
	$services: {
		downloadLog: {
			$method: "GET",
			$isMethod: true,
			$title: "Download log",
			$type: "application/x-file",
			$execute: function(_, context, instance) {
				return {
					headers: {
						"content-type": "text/plain"
					},
					body: fs.readFile(t9n.getLogFile(), "utf8", _)
				};
			}
		},

		toSyracuse: {
			$method: "POST",
			$isMethod: true,
			$title: "1: Get translations (from source EP)",
			$invocationMode: "async",
			$isDisabled: function(_, instance) {
				return !(instance.noDBStore(_) || instance.endpointRead(_)) || locked;
			},
			$execute: function(_, context, instance, parameters) {
				try {
					instance.$diagnoses = instance.$diagnoses || [];
					if (locked) {
						throw new Error("Translation process is in progress on another session");
					}
					locked = true;
					var translation = createTranslationProcess(_, context, instance, parameters);
					translation.updateAll(_);
				} catch (e) {
					console.error("exception: " + (e.message || e) + "\n" + e.stack);
					instance.$diagnoses.push({
						$severity: "error",
						$message: e.message || e,
						$stackTrace: e.stack
					});
				}
				locked = false;
			}
		},

		fromSyracuse: {
			$method: "POST",
			$isMethod: true,
			$title: "2: Update translations (to target EP)",
			$invocationMode: "async",
			$isDisabled: function(_, instance) {
				return !(instance.noDBStore(_) || instance.endpointRead(_)) || locked;
			},
			$execute: function(_, context, instance, parameters) {
				try {
					instance.$diagnoses = instance.$diagnoses || [];
					if (locked) {
						throw new Error("Translation process is in progress on another session");
					}
					locked = true;
					var translation = createTranslationProcess(_, context, instance, parameters);
					translation.extractAll(_);
					// p.init(_, fsp.join(__dirname, "../../../translation-indexes", "translation.log"));
				} catch (e) {
					console.error("exception: " + (e.message || e) + "\n" + e.stack);
					instance.$diagnoses.push({
						$severity: "error",
						$message: e.message || e
					});
				}
				locked = false;
			}
		},

		updateFromFile: {
			$method: "POST",
			$isMethod: true,
			$parameters: {
				fileName: "",
				$properties: {
					fileName: {
						$title: "File to load (in translation-indexes folder)",
						$description: "Indicate a file to load",
						$type: "application/x-string"
					}
				}
			},
			$title: "Push translation from file contents",
			$invocationMode: "async",
			$isDisabled: function(_, instance) {
				return !(instance.noDBStore(_) || instance.endpointRead(_)) || locked;
			},
			$execute: function(_, context, instance, parameters) {
				try {
					instance.$diagnoses = instance.$diagnoses || [];
					if (locked) {
						throw new Error("Translation process is in progress on another session");
					}
					locked = true;
					var translation = createTranslationProcess(_, context, instance, parameters);
					translation.updateFromFile(_, parameters.fileName);
					// p.init(_, fsp.join(__dirname, "../../../translation-indexes", "translation.log"));
				} catch (e) {
					console.error("exception: " + (e.message || e) + "\n" + e.stack);
					instance.$diagnoses.push({
						$severity: "error",
						$message: e.message || e
					});
				}
				locked = false;
			},
			$isHidden: advancedOptionsIsHidden
		},

		smartCopy: {
			$method: "POST",
			$isMethod: true,
			$title: "Smart copy of translations from source endpoint to target",
			$invocationMode: "async",
			$isDisabled: function(_, instance) {
				return !(instance.noDBStore(_) || instance.endpointRead(_) && instance.endpointWrite(_)) || locked;
			},
			$execute: function(_, context, instance, parameters) {
				try {
					instance.$diagnoses = instance.$diagnoses || [];
					if (locked) {
						throw new Error("Translation process is in progress on another session");
					}
					locked = true;
					var translation = createTranslationProcess(_, context, instance, parameters);
					translation.smartCopy(_);
				} catch (e) {
					console.error("exception: " + (e.message || e) + "\n" + e.stack);
					instance.$diagnoses.push({
						$severity: "error",
						$message: e.message || e
					});
				}
				locked = false;
			},
			$isHidden: advancedOptionsIsHidden
		},

		downloadFile: {
			$method: "POST",
			$isMethod: true,
			$parameters: {
				fileName: "output/messages-",
				chapterStart: "10031",
				chapterEnd: "10045",
				$properties: {
					fileName: {
						$title: "File name without extension (saved as .txt in translation-indexes folder)",
						$description: "Indicate a file name for the destination",
						$type: "application/x-string"
					},
					chapterStart: {
						$title: "Start from chapter",
						$type: "application/x-string",
						$isMandatory: true
					},
					chapterEnd: {
						$title: "End to chapter (included)",
						$type: "application/x-string"
					},
					langFilter: {
						$title: "Filter for language",
						$type: "application/x-string"
					},
					stampFilter: {
						$title: "Message modified from (format yyyy-MM-ddThh-mm-ssZ)",
						$type: "application/x-string"
					},
					keepTimestamp: {
						$title: "Keep timestamp in the saved contents",
						$type: "application/x-boolean",
						$default: false
					},
					fixUntranslated: {
						$title: "Fix untranslated message for specified language",
						$type: "application/x-string"
					}
				}
			},
			$title: "Download translation contents to a file",
			$invocationMode: "async",
			$isDisabled: function(_, instance) {
				return !(instance.noDBStore(_) || instance.endpointRead(_)) || locked;
			},
			$execute: function(_, context, instance, parameters) {
				try {
					instance.$diagnoses = instance.$diagnoses || [];
					if (locked) {
						throw new Error("Translation process is in progress on another session");
					}
					locked = true;
					var translation = createTranslationProcess(_, context, instance, parameters);
					translation.downloadToFile(_, parameters);
					// p.init(_, fsp.join(__dirname, "../../../translation-indexes", "translation.log"));
				} catch (e) {
					console.error("exception: " + (e.message || e) + "\n" + e.stack);
					instance.$diagnoses.push({
						$severity: "error",
						$message: e.message || e
					});
				}
				locked = false;
			},
			$isHidden: advancedOptionsIsHidden
		},

		updateIndexfromCsv: {
			$method: "POST",
			$isMethod: true,
			$title: "Update index from csv",
			$invocationMode: "async",
			$isDisabled: function(_, instance) {
				return !(instance.noDBStore(_) || instance.endpointRead(_)) || locked;
			},
			$execute: function(_, context, instance, parameters) {
				try {
					instance.$diagnoses = instance.$diagnoses || [];
					if (locked) {
						throw new Error("Translation process is in progress on another session");
					}
					locked = true;
					var translation = createTranslationProcess(_, context, instance, parameters);
					translation.updateIndexfromCsv(_);
					// p.init(_, fsp.join(__dirname, "../../../translation-indexes", "translation.log"));
				} catch (e) {
					console.error("exception: " + (e.message || e) + "\n" + e.stack);
					instance.$diagnoses.push({
						$severity: "error",
						$message: e.message || e
					});
				}
				locked = false;
			},
			$isHidden: advancedOptionsIsHidden
		},

		deleteAll: {
			$method: "POST",
			$isMethod: true,
			$confirm: "You are about to delete all messages in the target endpoint for the selected resource types from the translation storage.\n\nDo you confirm the deletion?",
			$title: "Delete all target messages",
			$invocationMode: "async",
			$isDisabled: function(_, instance) {
				return !(instance.noDBStore(_) || instance.endpointRead(_)) || locked;
			},
			$execute: function(_, context, instance, parameters) {
				try {
					instance.$diagnoses = instance.$diagnoses || [];
					if (locked) {
						throw new Error("Translation process is in progress on another session");
					}
					locked = true;
					var translation = createTranslationProcess(_, context, instance, parameters);
					translation.deleteAll(_);
				} catch (e) {
					console.error("exception: " + (e.message || e) + "\n" + e.stack);
					instance.$diagnoses.push({
						$severity: "error",
						$message: e.message || e
					});
				}
				locked = false;
			}
		},
	}
};

function createTranslationProcess(_, context, instance, parameters) {
	return new TranslationProcess(_, new World(context), makeOptions(_, context, instance, parameters));
}

var advancedOptions = ["noDBFlush", "noDBStore", "renumber", "resetIndex", "loadFromIndex", "ignoreIndexEndpoint", "verify", "ignoreChecksum", "filterAdmin"];

function advancedOptionsIsHidden(_, instance) {
	var opt = instance.advancedOptions(_);
	return !opt;
}

advancedOptions.forEach(function(opt) {
	exports.entity.$properties[opt].$isHidden = advancedOptionsIsHidden;
});

function makeOptions(_, context, instance, parameters) {
	var t = context && context.tracker,
		options = parameters || {};
	options.$tracking = t ? (t.$diagnoses = t.$diagnoses || []) : null;
	options.$addDiagnosis = instance.$addDiagnose;
	options.resources = {
		syracuse: instance.syracuse(_),
		dotnet: instance.dotnet(_),
		admin: instance.admin(_)
	};
	advancedOptions.concat("advancedOptions").forEach_(_, function(_, opt) {
		options[opt] = instance[opt](_);
	});

	options.endpointRead = (options.noDBStore && adminHelper.getCollaborationEndpoint(_)) || instance.endpointRead(_);
	options.endpointWrite = (options.noDBStore && adminHelper.getCollaborationEndpoint(_)) || instance.endpointWrite(_) || options.endpointRead;
	return options;
}