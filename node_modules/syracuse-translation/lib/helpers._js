"use strict";

var fs = require('streamline-fs');
var fsp = require("path");
var sys = require("util");
var locale = require("syracuse-core/lib/locale");
var helpers = require("syracuse-core/lib/helpers");
var config = require('syracuse-main/lib/nodeconfig').config; // must be first
var transCfg = config.translation || {};
var tracer = transCfg.trace;
var forEachKey = helpers.object.forEachKey;

var localizedText = locale.format.bind(undefined, module);
var indexDir = fsp.join(__dirname, "../../../translation-indexes");
var importDir = fsp.join(__dirname, "../../../import");

var SEP = "\t";
var MIDDLE_DOT = "\u00b7";
var languages = ["fr-fr", "en-us", "en-gb", "de-de"];

exports.autoFillIndexes = function(_) {
	autoCorrect(_, indexDir, "Syracuse");
	autoCorrect(_, indexDir, "Dotnet");
};

exports.exportToText = function(_) {
	_exportToText(_, "Syracuse");
	_exportToText(_, "Dotnet");
};

exports.extractAdmin = function(_) {
	_extractAdminToText(_, ["x3-dashboards-home", "x3-erp-homepages", "x3-erp-menus", "x3-global-modules", "x3-global-sitemap", "x3-mobile-dashboards"]);
};

function _exportToText(_, name) {
	var index = readJson(_, fsp.join(indexDir, "index" + name + ".json")),
		units = [],
		chapter, unit, lan, txt, contents, tuv;

	forEachKey(index, function(gk, gv) {
		if (gk[0] === "$") return;
		forEachKey(gv, function(mk, mv) {
			if (mk[0] === "$") return;
			forEachKey(mv.text, function(tk, tv) {
				if (languages.indexOf(tk) === -1) {
					return;
				}
				lan = locale.x3Language(tk);
				chapter = units[mv.chp] = units[mv.chp] || [];
				unit = chapter[mv.id] = chapter[mv.id] || {};
				unit[lan] = tv || "-";
				// tracer && tracer(lan + ";" + mv.chp + ";" + mv.id + ";" + (tv || "-"));
			});
			unit["XXX"] = mv.$key;
			// tracer && tracer("XXX;" + mv.chp + ";" + mv.id + ";" + mv.$key);
		});
	});

	var file = fsp.join(indexDir, "messages_" + index.$config.$chapter.$min + "-" + index.$config.$chapter.$max + ".txt");
	contents = "Language" + SEP + "Chapter" + SEP + "Number" + SEP + "Text\n";
	units.forEach(function(c, chp) {
		// tracer && tracer("chapter: " + chp);
		c.forEach(function(tu, id) {
			// tracer && tracer("  id: " + id);
			// tracer && tracer("    tu: " + JSON.stringify(tu));
			Object.keys(tu).sort().forEach(function(lan) {
				tuv = tu[lan];
				// tracer && tracer("    tuv[" + lan +"]: " + tuv);
				txt = formatForExcel(tuv);
				contents += lan + SEP + chp + SEP + id + SEP + '"' + txt + '"\n';
				// tracer && tracer(lan + ";" + chp + ";" + id + ";");
			});
		});
	});
	fs.writeFile(file, contents, "utf8", _);
}

function _extractAdminToText(_, file) {
	var index = {},
		contents, match;
	_generateAdminIndex(_, file, index);

	contents = "File" + SEP + "Key" + SEP + "type" + SEP + "Language" + SEP + "Text\n";

	forEachKey(index, function(file, vfile) {
		forEachKey(vfile, function(key, unit) {
			forEachKey(unit, function(lan, txt) {
				txt = formatForExcel(txt);
				match = /(title|description)_(.*)/ig.exec(key);
				contents += file + SEP + match[2] + SEP + match[1] + SEP + lan + SEP + '"' + txt + '"\n';
			});
		});
	});
	// var messagesFile = fsp.join(indexDir, "messages_10036-10043.txt");
	var messagesFile = fsp.join(indexDir, "messages_admin.txt");
	fs.writeFile(messagesFile, contents, "utf8", _);
}

/// Generated an index in the form
/// ```json
/// {
/// 	"filename": {
/// 		"key1":{
/// 			"en-us":"value en-us",
/// 			"fr-fr":"value fr-fr",
/// 			"en-gb":"value en-gb"
/// 		},
/// 		"key2":{
/// 			"en-us":"value en-us",
/// 			"fr-fr":"value fr-fr",
/// 			"en-gb":"value en-gb"
/// 		}
/// 	}
/// }
/// ```
///


function _generateAdminIndex(_, file, index) {
	if (Array.isArray(file)) {
		file.forEach_(_, function(_, f) {
			_generateAdminIndex(_, f, index);
		});
		return;
	}

	tracer && tracer("_generateAdminIndex " + file);
	var fname = fsp.join(importDir, file + ".json"),
		data = readJson(_, fname),
		loc = data && data.$localization,
		lan, contents, txt;

	// tracer && tracer("data=" + JSON.stringify(data, null, "\t"));
	if (!loc) return;

	var unit = index[file] = index[file] || {},
		tu, x3lan;

	var reflan = loc["en-us"],
		refkeys = {};
	forEachKey(reflan, function(key, txt) {
		tu = unit[key] = unit[key] || {};
		tu["en-us"] = txt;
		refkeys[key] = txt;
	});

	forEachKey(loc, function(lan, vlan) {
		lan = lan.toLowerCase();
		if (lan === "en-us") return;
		// forEachKey(vlan, function(key, txt) {
		forEachKey(refkeys, function(key) {
			txt = vlan[key] || "-";
			tu = unit[key];
			tu[lan] = txt;
		});
	});
}

exports.exportToTmx = function(_, file) {
	throw new Error("NIY");
};

function autoCorrect(_, indexDir, name) {
	var index = readJson(_, fsp.join(indexDir, "index" + name + ".json")),
		textIndex = indexTexts(index);

	fs.writeFile(fsp.join(indexDir, "textIndex" + name + ".json"), JSON.stringify(textIndex, null, "\t"), "utf8", _);
	fillIndex(index, textIndex);
	fs.writeFile(fsp.join(indexDir, "Index" + name + ".json"), JSON.stringify(index, null, "\t"), "utf8", _);
}

function fillIndex(index, textIndex) {
	var d, e, val, key, txt;
	forEachKey(index, function(gk, gv) {
		if (gk[0] === "$") return;
		forEachKey(gv, function(mk, mv) {
			if (mk[0] === "$") return;
			txt = (mv.text || {})["en-us"];
			key = txt && txt.toLowerCase();
			if (!key) {
				return;
			}
			val = textIndex[key];
			forEachKey(val, function(tk, tv) {
				if (tk != "fr-fr") {
					return;
				}
				if (!mv.text[tk]) {
					// tracer && tracer("set " + mk + "/" + tk + " to " + tv);
					mv.text[tk] = tv;
				}
			});
		});
	});
}

function readJson(_, filename) {
	var data = fs.exists(filename, _) && fs.readFile(filename, "utf8", _);
	if (!data) {
		tracer && tracer("data is empty ");
		return {};
	} else {
		try {
			return JSON.parse(data);
			// tracer && tracer("index data " + JSON.stringify(index, null, 2));
		} catch (e) {
			throw new Error(localizedText("incorrectJsonFormat", filename));
		}
	}
}

function indexTexts(index) {
	var d, e, val, key, txt, textIndex = {};
	forEachKey(index, function(gk, gv) {
		if (gk[0] === "$") return;
		forEachKey(gv, function(mk, mv) {
			if (mk[0] === "$") return;
			txt = (mv.text || {})["en-us"];
			key = txt && txt.toLowerCase();
			if (!key) {
				return;
			}
			val = textIndex[key] = textIndex[key] || {};
			val["en-us"] = val["en-us"] || txt;
			forEachKey(mv.text, function(tk, tv) {
				if (tk === "en-us") {
					return;
				}
				val[tk] = val[tk] || tv;
			});
		});
	});
	return textIndex;
}

function numSort(a, b) {
	return a - b;
}

function formatForExcel(txt) {
	return txt.replace(/"/g, '""').replace(/\s+$/g, MIDDLE_DOT); // utf-8 middle dot
	// txt = txt.replace(/\n/g, "\u2424"); // utf-8 newline char
}