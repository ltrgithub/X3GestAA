"use strict";

var fs = require('streamline-fs');
var fsp = require("path");
var sys = require("util");
var locale = require("syracuse-core/lib/locale");
var helpers = require("syracuse-core/lib/helpers");
var config = require('syracuse-main/lib/nodeconfig').config; // must be first
var transCfg = config.translation || {};
var tracer = transCfg.trace;
var forEachKey = helpers.object.forEachKey;

var localizedText = locale.format.bind(undefined, module);

exports.autoFillIndexes = function(_) {
	var indexDir = fsp.join(__dirname, "../../../translation-indexes");
	autoCorrect(_, indexDir, "Syracuse");
	autoCorrect(_, indexDir, "Dotnet");
};

function autoCorrect(_, indexDir, name) {
	var index = readIndex(_, fsp.join(indexDir, "index" + name + ".json")),
		textIndex = indexTexts(index);

	fs.writeFile(fsp.join(indexDir, "textIndex" + name + ".json"), JSON.stringify(textIndex, null, "\t"), "utf8", _);
	fillIndex(index, textIndex);
	fs.writeFile(fsp.join(indexDir, "Index" + name + ".json"), JSON.stringify(index, null, "\t"), "utf8", _);
}

function fillIndex(index, textIndex) {
	var d, e, val, key, txt;
	forEachKey(index, function(gk, gv) {
		if (gk[0] === "$") return;
		forEachKey(gv, function(mk, mv) {
			if (mk[0] === "$") return;
			txt = (mv.text || {})["en-us"];
			key = txt && txt.toLowerCase();
			if (!key) {
				return;
			}
			val = textIndex[key];
			forEachKey(val, function(tk, tv) {
				if (tk != "fr-fr") {
					return;
				}
				if (!mv.text[tk]) {
					// tracer && tracer("set " + mk + "/" + tk + " to " + tv);
					mv.text[tk] = tv;
				}
			});
		});
	});
}

function readIndex(_, indexpath) {
	var index, data = fs.exists(indexpath, _) && fs.readFile(indexpath, "utf8", _);
	if (!data) {
		tracer && tracer("data is empty ");
		return {};
	} else {
		try {
			return JSON.parse(data);
			// tracer && tracer("index data " + JSON.stringify(index, null, 2));
		} catch (e) {
			throw new Error(localizedText("incorrectJsonFormat", indexpath));
		}
	}
}

function indexTexts(index) {
	var d, e, val, key, txt, textIndex = {};
	forEachKey(index, function(gk, gv) {
		if (gk[0] === "$") return;
		forEachKey(gv, function(mk, mv) {
			if (mk[0] === "$") return;
			txt = (mv.text || {})["en-us"];
			key = txt && txt.toLowerCase();
			if (!key) {
				return;
			}
			val = textIndex[key] = textIndex[key] || {};
			val["en-us"] = val["en-us"] || txt;
			forEachKey(mv.text, function(tk, tv) {
				if (tk === "en-us") {
					return;
				}
				val[tk] = val[tk] || tv;
			});
		});
	});
	return textIndex;
}