"use strict";

var fs = require('streamline-fs');
var fsp = require("path");
var sys = require("util");
var locale = require("syracuse-core/lib/locale");
var helpers = require("syracuse-core/lib/helpers");
var config = require('config'); // must be first
var transCfg = config.translation || {};
var tracer = transCfg.trace;
var forEachKey = helpers.object.forEachKey;

var localizedText = locale.format.bind(undefined, module);
var indexDir = fsp.join(config.system.root, "translation-indexes");
var importDir = fsp.join(config.system.root, "import");
var rootDir = config.system.root;

var SEP = "\t";
var MIDDLE_DOT = "\u00b7";
var languages = ["fr-fr", "en-us", "en-gb", "de-de"];

exports.processCmd = function(argv) {
	_processCmd(_ >> function(err) {
		if (err) throw err;
	}, argv);
};

exports.autoFillIndexes = function(_) {
	autoCorrect(_, indexDir, "Syracuse");
	autoCorrect(_, indexDir, "Dotnet");
};

exports.exportToText = function(_) {
	_exportToText(_, "Syracuse");
	_exportToText(_, "Dotnet");
};

exports.extractAdmin = function(_) {
	_extractAdminToText(_, ["x3-dashboards-home", "x3-erp-homepages", "x3-erp-menus", "x3-global-modules", "x3-global-sitemap", "x3-mobile-dashboards"]);
};

exports.cleanup = function(_) {
	cleanup(_, indexDir, "Syracuse");
	// cleanup(_, indexDir, "Dotnet");
};

function _processCmd(_, argv) {
	var cmd = {},
		param, arg;
	console.log(argv);
	for (var i = 0, len = argv.length; i < len; i++) {
		arg = argv[i];
		if (arg.substr(0, 2) === '--') {
			arg = arg.substr(2).toLowerCase();
			switch (arg) {
				case "autofill":
					return exports.autoFillIndexes(_);
				case "cleanup":
					return exports.cleanup(_);
				case "export":
					param = argv[i + 1];
					param = param.charAt(0).toUpperCase() + param.substr(1).toLowerCase();
					return exports["exportTo" + param](_);
				case "extract":
					param = argv[i + 1];
					param = param.charAt(0).toUpperCase() + param.substr(1).toLowerCase();
					return exports["extract" + param](_);
				case "verify":
					return exports.verify(_);
				case "tmx":
					return exports.exportToTmx(_, fsp.join(__dirname, argv[i + 1]));
				case "help":
					console.log("\nTranslation tool");
					console.log("Options:");
					console.log("  --autofill");
					console.log("  --cleanup");
					console.log("  --export text");
					console.log("  --extract text");
					console.log("  --verify");
					console.log("  --tmx");
					console.log("  --help");
					return;
			}
		}
	}
}

function _exportToText(_, name) {
	var index = readJson(_, fsp.join(indexDir, "index" + name + ".json")),
		units = [],
		chapter, unit, lan, txt, contents, tuv;

	forEachKey(index, function(gk, gv) {
		if (gk[0] === "$") return;
		forEachKey(gv, function(mk, mv) {
			if (mk[0] === "$") return;
			forEachKey(mv.text, function(tk, tv) {
				if (languages.indexOf(tk) === -1) {
					return;
				}
				lan = locale.x3Language(tk);
				chapter = units[mv.chp] = units[mv.chp] || [];
				unit = chapter[mv.id] = chapter[mv.id] || {};
				unit[lan] = tv || "-";
				// tracer && tracer(lan + ";" + mv.chp + ";" + mv.id + ";" + (tv || "-"));
			});
			unit["XXX"] = mv.$key;
			// tracer && tracer("XXX;" + mv.chp + ";" + mv.id + ";" + mv.$key);
		});
	});

	var file = fsp.join(indexDir, "messages_" + index.$config.$chapter.$min + "-" + index.$config.$chapter.$max + ".txt");
	contents = "Language" + SEP + "Chapter" + SEP + "Number" + SEP + "Text\n";
	units.forEach(function(c, chp) {
		// tracer && tracer("chapter: " + chp);
		c.forEach(function(tu, id) {
			// tracer && tracer("  id: " + id);
			// tracer && tracer("    tu: " + JSON.stringify(tu));
			Object.keys(tu).sort().forEach(function(lan) {
				tuv = tu[lan];
				// tracer && tracer("    tuv[" + lan +"]: " + tuv);
				txt = formatForExcel(tuv);
				contents += lan + SEP + chp + SEP + id + SEP + '"' + txt + '"\n';
				// tracer && tracer(lan + ";" + chp + ";" + id + ";");
			});
		});
	});
	fs.writeFile(file, contents, "utf8", _);
}

function _extractAdminToText(_, file) {
	var index = {},
		contents, match;
	_generateAdminIndex(_, file, index);

	contents = "File" + SEP + "Key" + SEP + "type" + SEP + "Language" + SEP + "Text\n";

	forEachKey(index, function(file, vfile) {
		forEachKey(vfile, function(key, unit) {
			forEachKey(unit, function(lan, txt) {
				txt = formatForExcel(txt);
				match = /(title|description)_(.*)/ig.exec(key);
				contents += file + SEP + match[2] + SEP + match[1] + SEP + lan + SEP + '"' + txt + '"\n';
			});
		});
	});
	// var messagesFile = fsp.join(indexDir, "messages_10036-10043.txt");
	var messagesFile = fsp.join(indexDir, "messages_admin.txt");
	fs.writeFile(messagesFile, contents, "utf8", _);
}

/// Generated an index in the form
/// ```json
/// {
/// 	"filename": {
/// 		"key1":{
/// 			"en-us":"value en-us",
/// 			"fr-fr":"value fr-fr",
/// 			"en-gb":"value en-gb"
/// 		},
/// 		"key2":{
/// 			"en-us":"value en-us",
/// 			"fr-fr":"value fr-fr",
/// 			"en-gb":"value en-gb"
/// 		}
/// 	}
/// }
/// ```
///
function _generateAdminIndex(_, file, index) {
	if (Array.isArray(file)) {
		file.forEach_(_, function(_, f) {
			_generateAdminIndex(_, f, index);
		});
		return;
	}

	tracer && tracer("_generateAdminIndex " + file);
	var fname = fsp.join(importDir, file + ".json"),
		data = readJson(_, fname),
		loc = data && data.$localization,
		lan, contents, txt;

	// tracer && tracer("data=" + JSON.stringify(data, null, "\t"));
	if (!loc) return;

	var unit = index[file] = index[file] || {},
		tu, x3lan;

	var reflan = loc["en-us"],
		refkeys = {};
	forEachKey(reflan, function(key, txt) {
		tu = unit[key] = unit[key] || {};
		tu["en-us"] = txt;
		refkeys[key] = txt;
	});

	forEachKey(loc, function(lan, vlan) {
		lan = lan.toLowerCase();
		if (lan === "en-us") return;
		// forEachKey(vlan, function(key, txt) {
		forEachKey(refkeys, function(key) {
			txt = vlan[key] || "-";
			tu = unit[key];
			tu[lan] = txt;
		});
	});
}

exports.exportToTmx = function(_, file) {
	throw new Error("NIY");
};

function autoCorrect(_, indexDir, name) {
	var index = readJson(_, fsp.join(indexDir, "index" + name + ".json")),
		textIndex = indexTexts(index);

	fs.writeFile(fsp.join(indexDir, "textIndex" + name + ".json"), JSON.stringify(textIndex, null, "\t"), "utf8", _);
	fillIndex(index, textIndex);
	fs.writeFile(fsp.join(indexDir, "Index" + name + ".json"), JSON.stringify(index, null, "\t"), "utf8", _);
}

function fillIndex(index, textIndex) {
	var d, e, val, key, txt;
	forEachKey(index, function(gk, gv) {
		if (gk[0] === "$") return;
		forEachKey(gv, function(mk, mv) {
			if (mk[0] === "$") return;
			txt = (mv.text || {})["en-us"];
			key = txt && txt.toLowerCase();
			if (!key) {
				return;
			}
			val = textIndex[key];
			forEachKey(val, function(tk, tv) {
				if (tk != "fr-fr") {
					return;
				}
				if (!mv.text[tk]) {
					// tracer && tracer("set " + mk + "/" + tk + " to " + tv);
					mv.text[tk] = tv;
				}
			});
		});
	});
}

function readJson(_, filename) {
	var data = fs.exists(filename, _) && fs.readFile(filename, "utf8", _);
	if (!data) {
		tracer && tracer("data is empty ");
		return {};
	} else {
		try {
			return JSON.parse(data);
			// tracer && tracer("index data " + JSON.stringify(index, null, 2));
		} catch (e) {
			throw new Error(localizedText("incorrectJsonFormat", filename));
		}
	}
}

function indexTexts(index) {
	var d, e, val, key, txt, textIndex = {};
	forEachKey(index, function(gk, gv) {
		if (gk[0] === "$") return;
		forEachKey(gv, function(mk, mv) {
			if (mk[0] === "$") return;
			txt = (mv.text || {})["en-us"];
			key = txt && txt.toLowerCase();
			if (!key) {
				return;
			}
			val = textIndex[key] = textIndex[key] || {};
			val["en-us"] = val["en-us"] || txt;
			forEachKey(mv.text, function(tk, tv) {
				if (tk === "en-us") {
					return;
				}
				val[tk] = val[tk] || tv;
			});
		});
	});
	return textIndex;
}

function numSort(a, b) {
	return a - b;
}

function formatForExcel(txt) {
	return txt.replace(/"/g, '""').replace(/\s+$/g, MIDDLE_DOT); // utf-8 middle dot
	// txt = txt.replace(/\n/g, "\u2424"); // utf-8 newline char
}

function cleanup(_, indexDir, name) {
	var indexFile = fsp.join(indexDir, "index" + name + ".json"),
		index = readJson(_, indexFile),
		files = {},
		gv, mv, tv, fgroup, f, refRes, resources, unit;

	tracer && tracer(indexFile);
	Object.keys(index).forEach_(_, function(_, gk) {
		if (gk[0] === "$") return;
		gv = index[gk];
		fgroup = files[gk] = files[gk] || {};
		refRes = new LocaleResource(gk, "en-us", _);
		if (refRes && !fs.exists(refRes.name, _)) {
			if (!fs.exists(refRes.full, _)) {
				tracer && tracer("Ref file does not exist for " + gk);
				delete index[gk];
				return;
			}
		}
		resources = {};
		Object.keys(gv).forEach_(_, function(_, mk) {
			if (mk[0] === "$") return;
			mv = gv[mk];
			Object.keys(mv.text).forEach_(_, function(_, lang) {
				tv = mv.text[lang];
				f = fgroup[lang] = fgroup[lang] || {};
				f.res = f.res || new LocaleResource(gk, lang, _);
				if (f.res.deleted) {
					// tracer && tracer("Delete " + lang + ": " + mv.text[lang]);
					delete mv.text[lang];
					return;
				}
				// resources[lang] = resources[lang] || readResource(_, f.res);
				// tracer && tracer(JSON.stringify(f));
			});
		});

		// Object.keys(resources).forEach(function(lang) {
		// 	resources
		// });
	});

	fs.writeFile(indexFile, JSON.stringify(index, null, "\t"), "utf8", _);
}

exports.verify = function(_) {
	verifyChecksum(_, indexDir, "Syracuse");
	verifyChecksum(_, indexDir, "Dotnet");
};

function LocaleResource(base, lang, _) {
	lang = lang.toLowerCase();
	var m = /(\w+)-(\w+)/i.exec(lang);
	if (!m) {
		tracer && tracer(base + " " + lang + " no match");
		this.deleted = true;
		return;
	}
	var name = fsp.resolve(rootDir + "/" + base + "-" + lang + ".json");
	if (!fs.exists(name, _)) {
		name = fsp.resolve(rootDir + "/" + base + "-" + m[1] + ".json");
		if (!fs.exists(name, _)) {
			this.deleted = true;
		}
	}
	this.name = name;
}

helpers.defineClass(LocaleResource, null, {
	read: function(_) {
		return fs.exists(this.name, _) && readJson(_, this.name);
	}
});

function verifyChecksum(_, indexDir, name) {
	var index = readJson(_, fsp.join(indexDir, "index" + name + ".json")),
		rec = _loadFromFile(_, index.$config.$chapter, {
			file: fsp.join(indexDir, "messages")
		});

	Object.keys(rec).forEach(function(kc) {
		var chp = rec[kc];
		Object.keys(chp).forEach(function(kg) {
			var grp = chp[kg];
			if (!grp["XXX"]) {
				console.log("Missing checksum for " + kc + "/" + kg);
			}
		});
	});
}

function _loadFromFile(_, chapter, opt) {
	var x3Records = {},
		file = _getMessageFileName(opt.file, chapter),
		fetched = 0,
		txt = "",
		regex = new RegExp(/(\w+)\t(\d+)\t(\d+)\t"([\s\S]*?)"[\n\r]+/g),
		data = fs.exists(file, _) && fs.readFile(file, "utf8", _),
		match, chp, grp, lines, lastUpdate = "";
	if (data) {
		while ((match = regex.exec(data)) != null) {
			chp = x3Records[match[2]] || (x3Records[match[2]] = {});
			grp = chp[match[3]] || (chp[match[3]] = {});
			txt = (match[4] || "").replace(/\u00b7/g, " ").replace(/\"\"/g, '"').replace(/\\n/g, '\n');
			grp[match[1]] = txt;
			fetched++;
		}
	}
	tracer && tracer("loadFromFile " + file + ", count=" + fetched);
	return x3Records;
}

function _getMessageFileName(prefix, chapter) {
	return prefix + "_" + chapter.$min + "-" + chapter.$max + ".txt";
}
