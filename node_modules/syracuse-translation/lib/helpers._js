"use strict";

var fs = require('streamline-fs');
var fsp = require("path");
var sys = require("util");
var crypto = require('crypto');
var locale = require('@sage/syracuse-core').locale;
var helpers = require('@sage/syracuse-core').helpers;
var config = require('config'); // must be first
var transCfg = config.translation || {};
var tracer = transCfg.trace;
var forEachKey = helpers.object.forEachKey;

var indexDir = fsp.join(config.system.root, "translation-indexes");
var importDir = fsp.join(config.system.root, "import");
var rootDir = config.system.root;

var SEP = "\t";
var MIDDLE_DOT = "\u00b7";
var languages = ["fr-fr", "en-us", "en-gb", "de-de"];

var strings = {
	"emptyTABLAN": "TABLAN entity is empty, please fill it by associating the X3 language code to the ISO code (ex: FRA, fr-FR)",
	"startExtractResources": "Start the {0} text extraction to {1} endpoint",
	"startUpdateResources": "Start the {0} text updating to {1} endpoint",
	"endExtractResourcesNoText": "End {0} text extraction to {1}: 0 text added",
	"endUpdateResourcesNoText": "End {0} text updating to {1}: 0 text updated",
	"endExtractResources": "End {0} text extraction to {1}: {2} added",
	"endUpdateResources": "End {0} text updating to {1}: {2} text updated",
	"extractTextsOf": "Extract texts of {0} {1}",
	"updateTextsOf": "Update texts of {0} {1}",
	"updateConflict": "Conflict {0}: {1} \ns='{2}' \nt='{3}' \ni='{4}'",
	"createEntryfail": "Record {0} from file {1} not created in X3",
	"incorrectRecord": "Incorrect X3 record {0}.  LANNUM is unknown",
	"msgTooLong": "Message (file: {0}, key: {1}) is more than {2} characters and will be truncated to '{3}'.",
	"incorrectJsonFormat": "Json content for file {0} can not be parsed",
	"incorrectType": "Resource {0}: Expected 'string', got '{1}'. Value={2}",
	"nullValue": "Resource {0} value is null.",
	"updateCompleted": "Update completed, {0} resource updated",
	"noLocalizationRef": "Missing English language localization section: {0}",
	"noLocalization": "No localization for {0}",
	"missingFile": "File {0} is present in index for language '{1}' but deleted or moved.",
	"missingReference": "Resource {0}/{1} is not referenced",
	"x3error": "Error reported from X3",
	"chapterFull": "Chapter {0} is full. Book another chapter for {1}",
	"indexMess": "The record {0}/{1} is in the index but not in X3",
	"unknownLangMap": "Language mapping undefined for: {0}",
	"noSourceEndpoint": "Internal error: translation endpoint is not defined",
	"chapterOverflow": "Chapter overflow: {0}",
	"unusedText": "Unused text '{0}' with key '{1}' not added",
	"cannotExtend": "Cannot extend the number of entries for the existing message {2},{0},{1}",
	"endsWithError": "Ends with errors!",
	"startVerifyExtraction": "Start verify extraction of {0} texts",
	"endVerifyExtraction": "End verify extraction of {0} texts: {1} matched",
	"rejectResource": "Rejected {0} {1}",
	"checksumMismatch": "Checksum mismatch during step '{0}' for {1},{2},{3}: Expected {4} got {5}.",
	"invalidBinding": "Key binding does not match for {0}: Expected {1},{2} got {3},{4}.",
	"duplicateKey": "Duplicate key: {0},{1},{2}",
	"foundRecordRange": "Found {0} records for chapter range [{1},{2}]",
	"deletingChapterRecords": "Deleting chapter {0}",
	"deleteChapterRecords": "Chapter {0}: {1} deleted",
	"deleteTotalRecords": "Total: {0} deleted",
	"endpointMismatch": "Endpoint does not match index of {0}: Expected {1} ({2}) got {3} ({4})",
	"entryNotFound": "Entry not found: {0}, id={1}, lan={2}, value={3}",
	"noRecordFound": "No records found for {0} id={1}",
	"fileWritingError": "Error writing in file {0}",
	"deleteIndex": "Delete index {0}",
	"fileNotFound": "File '{0}' not found",
	"fetchRecords": "{0} records fetched.",
	"fetchOverflow": "Record count ({0}) exceeds the maximum of {1}. Aborting since some records may not be processed otherwise!",
	"flushRecords": "Flush {1} record changes of {0} text extraction"
};

function _localizedText(s) {
	if (typeof(s) !== "string")
		throw new Error("Expecting a string as first argument");

	var args = [strings[s] || s].concat(Array.prototype.slice.call(arguments, 1));
	return locale.format.apply(null, args);
}

exports.localizedText = _localizedText;

exports.autoFillIndexes = function(_) {
	autoCorrect(_, indexDir, "Syracuse");
	autoCorrect(_, indexDir, "Dotnet");
};

exports.exportToText = function(_) {
	_exportToText(_, "Syracuse");
	_exportToText(_, "Dotnet");
};

exports.extractAdmin = function(_) {
	_extractAdminToText(_, ["x3-dashboards-home", "x3-erp-homepages", "x3-erp-menus", "x3-global-modules", "x3-global-sitemap", "x3-mobile-dashboards"]);
};

exports.cleanup = function(_) {
	cleanup(_, indexDir, "Syracuse");
	// cleanup(_, indexDir, "Dotnet");
};

function _exportToText(_, name) {
	var index = readJson(_, fsp.join(indexDir, "index" + name + ".json")),
		units = [],
		chapter, unit, lan, txt, contents, tuv;

	forEachKey(index, function(gk, gv) {
		if (gk[0] === "$") return;
		forEachKey(gv, function(mk, mv) {
			if (mk[0] === "$") return;
			forEachKey(mv.text, function(tk, tv) {
				if (languages.indexOf(tk) === -1) {
					return;
				}
				lan = locale.x3Language(tk);
				chapter = units[mv.chp] = units[mv.chp] || [];
				unit = chapter[mv.id] = chapter[mv.id] || {};
				unit[lan] = tv || "-";
				// tracer && tracer(lan + ";" + mv.chp + ";" + mv.id + ";" + (tv || "-"));
			});
			unit["XXX"] = mv.$key;
			// tracer && tracer("XXX;" + mv.chp + ";" + mv.id + ";" + mv.$key);
		});
	});

	var file = fsp.join(indexDir, "messages_" + index.$config.$chapter.$min + "-" + index.$config.$chapter.$max + ".txt");
	contents = "Language" + SEP + "Chapter" + SEP + "Number" + SEP + "Text\n";
	units.forEach(function(c, chp) {
		// tracer && tracer("chapter: " + chp);
		c.forEach(function(tu, id) {
			// tracer && tracer("  id: " + id);
			// tracer && tracer("    tu: " + JSON.stringify(tu));
			Object.keys(tu).sort().forEach(function(lan) {
				tuv = tu[lan];
				// tracer && tracer("    tuv[" + lan +"]: " + tuv);
				txt = formatForExcel(tuv);
				contents += lan + SEP + chp + SEP + id + SEP + '"' + txt + '"\n';
				// tracer && tracer(lan + ";" + chp + ";" + id + ";");
			});
		});
	});
	fs.writeFile(file, contents, "utf8", _);
}

function _extractAdminToText(_, file) {
	var index = {},
		contents, match;
	_generateAdminIndex(_, file, index);

	contents = "File" + SEP + "Key" + SEP + "type" + SEP + "Language" + SEP + "Text\n";

	forEachKey(index, function(file, vfile) {
		forEachKey(vfile, function(key, unit) {
			forEachKey(unit, function(lan, txt) {
				txt = formatForExcel(txt);
				match = /(title|description)_(.*)/ig.exec(key);
				contents += file + SEP + match[2] + SEP + match[1] + SEP + lan + SEP + '"' + txt + '"\n';
			});
		});
	});
	// var messagesFile = fsp.join(indexDir, "messages_10036-10043.txt");
	var messagesFile = fsp.join(indexDir, "messages_admin.txt");
	fs.writeFile(messagesFile, contents, "utf8", _);
}

function _traverseIndex(index, cb) {
	forEachKey(index, function(file, vfile) {
		cb([file, vfile]);
		if (file[0] === "$") return;
		forEachKey(vfile, function(key, unit) {
			cb([file, vfile], [key, unit]);
			if (key[0] === "$") return;
			forEachKey(unit.text, function(lan, txt) {
				cb([file, vfile], [key, unit], [lan, txt]);
			});
		});
	});
}

exports.traverseIndex = _traverseIndex;

/// Generated an index in the form
/// ```json
/// {
/// 	"filename": {
/// 		"key1":{
/// 			"en-us":"value en-us",
/// 			"fr-fr":"value fr-fr",
/// 			"en-gb":"value en-gb"
/// 		},
/// 		"key2":{
/// 			"en-us":"value en-us",
/// 			"fr-fr":"value fr-fr",
/// 			"en-gb":"value en-gb"
/// 		}
/// 	}
/// }
/// ```
///
function _generateAdminIndex(_, file, index) {
	if (Array.isArray(file)) {
		file.forEach_(_, function(_, f) {
			_generateAdminIndex(_, f, index);
		});
		return;
	}

	tracer && tracer("_generateAdminIndex " + file);
	var fname = fsp.join(importDir, file + ".json"),
		data = readJson(_, fname),
		loc = data && data.$localization,
		lan, contents, txt;

	// tracer && tracer("data=" + JSON.stringify(data, null, "\t"));
	if (!loc) return;

	var unit = index[file] = index[file] || {},
		tu, x3lan;

	var reflan = loc["en-us"],
		refkeys = {};
	forEachKey(reflan, function(key, txt) {
		tu = unit[key] = unit[key] || {};
		tu["en-us"] = txt;
		refkeys[key] = txt;
	});

	forEachKey(loc, function(lan, vlan) {
		lan = lan.toLowerCase();
		if (lan === "en-us") return;
		// forEachKey(vlan, function(key, txt) {
		forEachKey(refkeys, function(key) {
			txt = vlan[key] || "-";
			tu = unit[key];
			tu[lan] = txt;
		});
	});
}

exports.exportToTmx = function(_, file) {
	throw new Error("NIY");
};

function autoCorrect(_, indexDir, name) {
	var index = readJson(_, fsp.join(indexDir, "index" + name + ".json")),
		textIndex = indexTexts(index);

	fs.writeFile(fsp.join(indexDir, "textIndex" + name + ".json"), JSON.stringify(textIndex, null, "\t"), "utf8", _);
	fillIndex(index, textIndex);
	fs.writeFile(fsp.join(indexDir, "Index" + name + ".json"), JSON.stringify(index, null, "\t"), "utf8", _);
}

function fillIndex(index, textIndex) {
	var d, e, val, key, txt;
	forEachKey(index, function(gk, gv) {
		if (gk[0] === "$") return;
		forEachKey(gv, function(mk, mv) {
			if (mk[0] === "$") return;
			txt = (mv.text || {})["en-us"];
			key = txt && txt.toLowerCase();
			if (!key) {
				return;
			}
			val = textIndex[key];
			forEachKey(val, function(tk, tv) {
				if (tk != "fr-fr") {
					return;
				}
				if (!mv.text[tk]) {
					// tracer && tracer("set " + mk + "/" + tk + " to " + tv);
					mv.text[tk] = tv;
				}
			});
		});
	});
}

function readJson(_, filename) {
	var data = fs.exists(filename, _) && fs.readFile(filename, "utf8", _);
	if (!data) {
		tracer && tracer("data is empty ");
		return {};
	} else {
		try {
			return JSON.parse(data);
			// tracer && tracer("index data " + JSON.stringify(index, null, 2));
		} catch (e) {
			throw new Error(_localizedText("incorrectJsonFormat", filename));
		}
	}
}

function indexTexts(index) {
	var d, e, val, key, txt, textIndex = {};
	forEachKey(index, function(gk, gv) {
		if (gk[0] === "$") return;
		forEachKey(gv, function(mk, mv) {
			if (mk[0] === "$") return;
			txt = (mv.text || {})["en-us"];
			key = txt && txt.toLowerCase();
			if (!key) {
				return;
			}
			val = textIndex[key] = textIndex[key] || {};
			val["en-us"] = val["en-us"] || txt;
			forEachKey(mv.text, function(tk, tv) {
				if (tk === "en-us") {
					return;
				}
				val[tk] = val[tk] || tv;
			});
		});
	});
	return textIndex;
}

function numSort(a, b) {
	return a - b;
}

function formatForExcel(txt) {
	return txt.replace(/"/g, '""').replace(/\s+$/g, MIDDLE_DOT); // utf-8 middle dot
	// txt = txt.replace(/\n/g, "\u2424"); // utf-8 newline char
}

function cleanup(_, indexDir, name) {
	var indexFile = fsp.join(indexDir, "index" + name + ".json"),
		index = readJson(_, indexFile),
		files = {},
		gv, mv, tv, fgroup, f, refRes, resources, unit;

	tracer && tracer(indexFile);
	Object.keys(index).forEach_(_, function(_, gk) {
		if (gk[0] === "$") return;
		gv = index[gk];
		fgroup = files[gk] = files[gk] || {};
		refRes = new LocaleResource(gk, "en-us", _);
		if (refRes && !fs.exists(refRes.name, _)) {
			if (!fs.exists(refRes.full, _)) {
				tracer && tracer("Ref file does not exist for " + gk);
				delete index[gk];
				return;
			}
		}
		resources = {};
		Object.keys(gv).forEach_(_, function(_, mk) {
			if (mk[0] === "$") return;
			mv = gv[mk];
			Object.keys(mv.text).forEach_(_, function(_, lang) {
				tv = mv.text[lang];
				f = fgroup[lang] = fgroup[lang] || {};
				f.res = f.res || new LocaleResource(gk, lang, _);
				if (f.res.deleted) {
					// tracer && tracer("Delete " + lang + ": " + mv.text[lang]);
					delete mv.text[lang];
					return;
				}
				// resources[lang] = resources[lang] || readResource(_, f.res);
				// tracer && tracer(JSON.stringify(f));
			});
		});

		// Object.keys(resources).forEach(function(lang) {
		// 	resources
		// });
	});

	fs.writeFile(indexFile, JSON.stringify(index, null, "\t"), "utf8", _);
}

exports.verify = function(_) {
	verifyChecksum(_, indexDir, "Syracuse");
	verifyChecksum(_, indexDir, "Dotnet");
};

function LocaleResource(base, lang, _) {
	lang = lang.toLowerCase();
	var m = /(\w+)-(\w+)/i.exec(lang);
	if (!m) {
		tracer && tracer(base + " " + lang + " no match");
		this.deleted = true;
		return;
	}
	var name = fsp.resolve(rootDir + "/" + base + "-" + lang + ".json");
	if (!fs.exists(name, _)) {
		name = fsp.resolve(rootDir + "/" + base + "-" + m[1] + ".json");
		if (!fs.exists(name, _)) {
			this.deleted = true;
		}
	}
	this.name = name;
}

helpers.defineClass(LocaleResource, null, {
	read: function(_) {
		return fs.exists(this.name, _) && readJson(_, this.name);
	}
});

function verifyChecksum(_, indexDir, name) {
	var index = readJson(_, fsp.join(indexDir, "index" + name + ".json")),
		rec = _loadFromFile(_, index.$config.$chapter, {
			file: fsp.join(indexDir, "messages")
		});

	Object.keys(rec).forEach(function(kc) {
		var chp = rec[kc];
		Object.keys(chp).forEach(function(kg) {
			var grp = chp[kg];
			if (!grp["XXX"]) {
				console.log("Missing checksum for " + kc + "/" + kg);
			}
		});
	});
}

function _loadFromFile(_, chapter, opt) {
	var x3Records = {},
		file = _getMessageFileName(opt.file, chapter),
		fetched = 0,
		txt = "",
		regex = new RegExp(/(\w+)\t(\d+)\t(\d+)\t"([\s\S]*?)"[\n\r]+/g),
		data = fs.exists(file, _) && fs.readFile(file, "utf8", _),
		match, chp, grp, lines, lastUpdate = "";
	if (data) {
		while ((match = regex.exec(data)) != null) {
			chp = x3Records[match[2]] || (x3Records[match[2]] = {});
			grp = chp[match[3]] || (chp[match[3]] = {});
			txt = (match[4] || "").replace(/\u00b7/g, " ").replace(/\"\"/g, '"').replace(/\\n/g, '\n');
			grp[match[1]] = txt;
			fetched++;
		}
	}
	tracer && tracer("loadFromFile " + file + ", count=" + fetched);
	return x3Records;
}

function _getMessageFileName(prefix, chapter) {
	return prefix + "_" + chapter.$min + "-" + chapter.$max + ".txt";
}

exports.walk = function(_, rootDir, visitor) {
	visitor = visitor || {};

	function _walk(dir, _, file) {
		var path = fsp.join(dir, file || ""),
			fileInfo;
		tracer && tracer("walk PATH " + path);
		var stat = fs.stat(path, _);
		var dircontent;
		if (stat.isDirectory()) {
			if (visitor.visitDir && visitor.visitDir(file, path, rootDir) || !visitor.visitDir) {
				fs.readdir(path, _).forEach_(_, _walk.bind(this, path));
			}
			visitor.leaveDir && visitor.leaveDir(file, path, rootDir);
		} else {
			visitor.visitFile && visitor.visitFile(file, path, rootDir);
		}
	}
	_walk(rootDir, _);
};

exports.sha1 = function(text) {
	var hash = crypto.createHash('sha1');
	hash.update(new Buffer(text, 'utf8'));
	return hash.digest('hex').toUpperCase();
};