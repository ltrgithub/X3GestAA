"use strict";

const glob = require('streamline/lib/globals');
const util = require('util');
const Slot = require("etna/lib/supervisor/slot").Slot;

export class SlotAtextra extends Slot {
	constructor(parent, property) {
		super(parent, property);
	}

	get(_: _,  raw) {
		if (this.property && this.property.data && this._value === undefined) {
			this._value = this.property.loadAtextra(_, this.$parent);
			this.$wasRead = true;
		}
		return super.get(_, raw);
	}

	set(_: _,  value, raw) {
		super.set(_, value, raw);
		this.$wasUpdated = this.$wasRead && value !== this._value || true;
	}

	fromRecord(_: _,  record, colnIndex) {
		this._value = undefined;
	}

	clone(parent) {
		const to = super.clone(parent);

		if (this._atextra) {
			to._atextra = Object.keys(this._atextra).reduce((r, lan) => {
				r[lan] = this[lan];
				return r;
			}, {});
		}
		return to;
	}

	insertSlot(_: _) {
		this.$wasUpdated && this.property.updateAtextra(_, this.$parent, this._value);

		if (this._atextra) {
			Object.keys(this._atextra).forEach_(_, (_, lan) => {
				this.property.updateAtextra(_, this.$parent, this._atextra[lan], lan);
			});
			this._atextra = undefined;
		}
	}
	updateSlot(_: _) {
		return this.insertSlot(_);
	}

	deleteSlot(_: _) {
		return this.property.deleteAtextra(_, this.$parent);
	}

	getAtextra(_: _,  lan) {
		if (this._atextra && this._atextra[lan]) return this._atextra[lan];

		this._atextra = this._atextra || {};
		return this._atextra[lan] = lan === glob.context.x3session.actx.$LAN(_) ? this.get(_) : this.property.getAtextra(_, this.$parent, lan);
	}

	setAtextra(_: _,  text, lan) {
		// Store it for later used (update!)
		this._atextra = this._atextra || {};
		this._atextra[lan] = text;
		if (lan === glob.context.x3session.actx.$LAN(_)) {
			this.set(_, text);
		}
	}
}

;

export function newSlotAtextra(property) { return (parent => new SlotAtextra(parent, property)); }
