"use strict";
/*
http://localhost:8124/sdata/x3/erp/etnaOracle/QUERY('TESTREQ1')?representation=QUERY~TESTREQ1~1.$query&forcedExecution=true&portview=TESTREQ1&cube=false&count=10
*/

const glob = require('streamline/lib/globals');
const bcd = require("etna/lib/engine/runtime/bcd");
const runtime = require("etna/lib/engine/runtime/runtime");
const evalue = require("etna/lib/engine/runtime/evaluate").evalue;
const datetime = require('etna/lib/engine/runtime/tdatetime');
const date = require('etna/lib/engine/runtime/tdate');
const dates = require('etna/lib/engine/runtime/dates');
const Clbfile = require('etna/lib/engine/runtime/tclbfile').Clbfile;
const variables = require('etna/lib/engine/runtime/variables');
const Parser = require("etna/lib/engine/parser").Parser;
const type = require("etna/lib/supervisor/meta/type");
const util = require("etna/lib/supervisor/util");
const ASYR = require("etna/lib/supervisor/builtins/ASYR");
const ASYRSND = require("etna/lib/supervisor/builtins/ASYRSND");
const ASYRRCV = require("etna/lib/supervisor/builtins/ASYRRCV");
const utilDriver = require("etna/lib/engine/drivers/util");

var asyrmngtreq;

const filterHelpers = require("syracuse-sdata-parser/lib/json-converter");
const HttpError = util.HttpError;
const tracerJs = require('syracuse-core').getTracer("etna.supervisor");

function loadScript(_, script) {
	try {
		var mod = runtime.requireScript(_, "WF" + script);
		mod.$4gl = true;
		return mod;
	} catch (e) {
		tracerJs.error && tracerJs.error("Failed to load:" + ("WF" + script) + " error:" + JSON.stringify(e));
		throw new HttpError(404, "query not found: " + script);
	}
}

exports.proto = function (_, httpContext, script, query, facet) {
	const mod = loadScript(_, script);
	const psyr = new ASYR.constructor(httpContext);
	const args = {
		ACTX: {
			type: "AY",
			value: glob.context.x3session.actx
		},
		PSYR: {
			type: "AY",
			value: psyr
		},
		WCLOB: {
			type: "AT",
			value: new Clbfile("")
		},
		TIME_UPD: {
			type: "AN",
			value: bcd.fromDouble(0)
		},
		LEVEL_NUM: {
			type: "BS",
			value: query
		},
		TYPE_REPRES: {
			type: "BS",
			value: facet
		}
	};

	runtime.executeProg(_, mod, "PROTO_JSON", args);
	return args.WCLOB.value.x3ToString();
};

exports.query = function (_, httpContext, request_code, query) {
	tracerJs.debug && tracerJs.debug("query " + request_code + " " + query);

	/*
 Frequency of computation : 1=always, 2=every hour, 3=every day, 4=every week, 5=every month, 6=never
 execution_time is assigned as a time stamp numeric value (if 0, recomputation is not required)
 */

	const getExecutionTime = function (frq, forced_exec) {
		var execution_time = 0;
		if (!frq) {
			forced_exec = true;
			return execution_time;
		}

		const now = datetime.now();

		switch (frq) {
			case 1:
				forced_exec = true;
				break;
			case 2:
			case 3:
			case 4:
			case 6:
				execution_time = (frq !== 6) * now - (frq === 2) * (3600 * 1000) - (frq === 3) * 24 * 3600 * 1000 - (frq === 4) * 7 * 24 * 3600 * 1000;
				break;
			case 5:
				execution_time = 24 * 3600 * 1000 * now.x3Nday(date.make(1700, 1, 1)) - 1;
				break;
			case 7:
				execution_time = now - 60 * 10000;
				break;
			case 8:
				execution_time = now - 60 * 1000;
				break;
			case 9:
				execution_time = now - 10 * 1000;
				break;
		}
		return execution_time;
	};

	const getPortalValue = function (record, cod, fields) {
		const k = record.CMPPARCOD.indexOf(cod);

		if (k < 0) return;

		var formula = record.CMPPARFOR[k];
		const res = "";
		//Replace , per ; and remove ""

		formula = formula.replace(/,/g, ';').replace(/"/g, '');
		return formula.split(';').reduce(function (r, exp) {
			//transform the expression in a numeric value :
			const j = exp.x3Val();
			// if j : j= index of a field 

			if (j && j < fields.length) r.push('"' + fields(j) + '"');
			return r;
		}, []).join(',');
	};

	const executeProg = function (_, fct, args) {
		args && tracerJs.debug && Object.keys(args).filter(function (key) {
			return args[key].type[1] !== 'Y';
		}).forEach(function (key) {
			tracerJs.debug("> " + fct + " " + key + "=" + JSON.stringify(args[key]));
		});

		const result = runtime.executeProg(_, mod, fct, args);


		args && tracerJs.debug && Object.keys(args).filter(function (key) {
			return args[key].type[1] !== 'Y';
		}).forEach(function (key) {
			tracerJs.debug("< " + fct + " " + key + "=" + JSON.stringify(args[key]));
		});

		return result;
	};

	const getRqt = function (_) {
		ifbulk = 1;

		const args = {
			ACTX: {
				type: "AY",
				value: actx
			},
			LEVEL: {
				type: 'AI',
				value: level
			},
			REQUID: {
				type: 'AS',
				value: requid
			},
			VALBEG: {
				type: "AS",
				value: valbeg
			},
			VALEND: {
				type: "AS",
				value: valend
			},
			STRICTBEG: {
				type: "AI",
				value: strictbeg
			},
			STRICTEND: {
				type: "AI",
				value: strictend
			},
			FIRSTLINE: {
				type: 'AI',
				value: firstline
			},
			NBLINES: {
				type: 'AI',
				value: nblines
			},
			COMPDATETIME: {
				type: 'AN',
				value: execution_time
			},
			IFLINE: {
				type: 'AI',
				value: ifline
			},
			IFBULK: {
				type: 'AI',
				value: ifbulk
			},
			IFCUBE: {
				type: 'AI',
				value: ifcube
			},
			STARTIND: {
				type: 'AI',
				value: startIndex
			},
			ASND: {
				type: "AY",
				value: asnd
			},
			PORTVIEW: {
				type: "AS",
				value: qs.portview || ""
			},
			OK: {
				type: 'AI',
				value: 0
			}
		};

		// Dom October 14, 2014 Calendar widget adaptation

		if (calendarPrototype !== undefined) {
			args.CALEND = {
				type: "AS",
				value: JSON.stringify(calendarPrototype)
			};
			executeProg(_, "GET_CAL", args);
		} else {
			executeProg(_, "GET_RQT", args);
		}

		return args.OK.value;
	};

	// cf CRERQT from ASYRMNGTREQ


	const rqtBatch = function (_) {
		asyrmngtreq = asyrmngtreq || runtime.requireScript(_, "ASYRMNGTREQ");
		if (!asyrmngtreq) return;
		const today = dates.functions.DATE$.fn();
		const time = dates.functions.TIME$.fn().substring(0, 5);
		const args = {
			ACTX: {
				type: "AY",
				value: actx
			},
			FOLD: {
				type: 'BS',
				value: nomap
			},
			USER: {
				type: 'BS',
				value: actx.$USER(_)
			},
			TASK: {
				type: 'BS',
				value: "SYRAREP"
			},
			DAT: {
				type: 'BS',
				value: today.toString("yyyy-MM-dd")
			},
			TIM: {
				type: 'BS',
				value: time
			},
			ARYPAR: {
				type: 'AS',
				value: [1, "", [], 1, null]
			},
			ARYVAL: {
				type: 'AS',
				value: [1, "", [], 1, null]
			},
			NBPAR: {
				type: 'AI',
				value: 0
			},
			REQUEST: {
				type: 'AI',
				value: 0
			},
			MESSAGE: {
				type: 'AS',
				value: ""
			}
		};


		runtime.executeProg(_, asyrmngtreq, "CRERQT");
		tracerJs.debug && tracerJs.debug(args.MESSAGE.value);
	};

	const getTblSize = function (_) {
		const sqlDriver = superv.sqlDriver;
		const param = sqlDriver.param;
		const tableName = executeProg(_, "GET_MAINTABLE");
		const tblSize = sqlDriver.evalueRowCount(_, tableName);

		tracerJs.debug && tracerJs.debug("tblSize:" + tblSize);
		return tblSize;
	};

	function execRqt(_) {
		const args = {
			ACTX: {
				type: "AY",
				value: actx
			},
			VALBEG: {
				type: "AS",
				value: valbeg
			},
			VALEND: {
				type: "AS",
				value: valend
			},
			STRICTBEG: {
				type: "AI",
				value: strictbeg
			},
			STRICTEND: {
				type: "AI",
				value: strictend
			},
			LIMITS: {
				type: 'BI',
				value: limits
			},
			NBLIG: {
				type: 'AI',
				value: nblig
			},
			REQUID: {
				type: 'AS',
				value: requid
			},
			UUIREQ: {
				type: 'BS',
				value: uuireq
			}
		};

		executeProg(_, "EXEC_RQT", args);
	};

	const qs = httpContext.qs;

	// Define the program and check if it exists

	const mod = loadScript(_, request_code);
	const actx = glob.context.x3session.actx;
	const superv = httpContext.supervisor;
	const nomap = superv.folderName;
	const psyr = new ASYR.constructor(httpContext);
	const asnd = new ASYRSND.constructor(httpContext);
	const arcv = new ASYRRCV.constructor(httpContext.superv, httpContext.qs);

	//   Forced request id (only for batch computations)

	var calendarPrototype;
	var ifbulk = 0;
	const ifcube = qs.cube && qs.cube === "true" ? 1 : 0;
	const uuireq = "";
	const nblig = [1, 0, [], 1, 20]; // NBLIG(1..20)

	const valbeg = [1, "", [], 1, 100]; // VALBEG(250)(1..100)

	const valend = [1, "", [], 1, 100]; // VALEND(250)(1..100)

	const strictbeg = [1, 0, [], 1, 100]; // STRICTBEG(1..100)

	const strictend = [1, 0, [], 1, 100]; // STRICTEND(1..100)

	const ifline = [1, 0, [], 1, 2]; //IFLINE(1..2)

	// Let's analyze the parameters sent in the URL

	const limits = [1, 0, [], 1, 2]; // LIMITS(1..2)

	var args = {
		PARAM: {
			type: 'AS',
			value: [1, "", [], 1, null]
		},
		PARTYPE: {
			type: 'AI',
			value: [1, 0, [], 1, null]
		},
		MAXLEVEL: {
			type: 'AI',
			value: 0
		},
		IFSHARED: {
			type: 'AI',
			value: 0
		}
	};

	executeProg(_, "GET_PARAMS", args);
	tracerJs.debug && tracerJs.debug("requester.GET_PARAMS return:" + JSON.stringify(args));

	const param = args.PARAM.value;
	const partype = args.PARTYPE.value;
	const maxlevel = args.MAXLEVEL.value;
	const ifshared = args.IFSHARED.value;
	const forced_exec = qs.forcedExecution && qs.forcedExecution.toLowerCase() === "true" || false;
	const where = qs.Where || "";

	var level = qs.level || 0;
	limits[2][0] = qs.linesLimit || 0;
	limits[2][1] = qs.timeLimit || 0;

	ifline[2][0] = qs.displayLineNum && qs.displayLineNum.toLowerCase() === "true" ? 2 : 1;
	ifline[2][1] = qs.displayHeader && qs.displayHeader.toLowerCase() === "true" ? 1 : 2;

	const requid = qs.requestID ? qs.requestID.substring(1, qs.requestID.length - 1) : "";
	const startIndex = qs.startIndex ? parseInt(qs.startIndex) : 0;
	const startRecord = qs.startRecord ? parseInt(qs.startRecord) : 0;
	const firstline = Math.max(startRecord, startIndex, 1);


	var nblines = qs.count || qs.recordsPerPage;
	nblines = nblines ? parseInt(nblines) : 0;

	if (!nblines) {
		if (httpContext.facet === "$bulk") {
			nblines = actx.$APARAM(_).AGETUSERVALNUM(_, "NBRREQBLK") || 200;
			ifbulk = 1;
		} else {
			nblines = actx.$APARAM(_).AGETUSERVALNUM(_, "NBRREQ") || 20;
		}
	}
	var frq = qs.frequency;
	var execution_time = getExecutionTime(frq, forced_exec);

	// Let's check the habilitations (added September 13, 2013)
	const superadmin = actx.$APARAM(_).AGETVALCHAR(_, "ALEVFOLD", nomap, 'ADMUSR');
	const rights = actx.getRights(_);

	tracerJs.debug && tracerJs.debug("CODMET:" + rights._CODMET);
	tracerJs.debug && tracerJs.debug("PRFFCT:" + rights._PRFFCT);
	tracerJs.debug && tracerJs.debug("PRFCOD:" + rights._PRFCOD);
	tracerJs.debug && tracerJs.debug("ALLACS:" + rights._ALLACS);

	const self = this;

	// Access control :
	if (rights._PRFCOD !== superadmin) {
		var alh = superv.load(_, 'Table', 'ALISTEH');
		var rs = alh.loadRecords(_, alh.indexes[0], [request_code]);
		tracerJs.debug && tracerJs.debug("ALISTEH rs:" + JSON.stringify(rs));
		if (!rs.length) throw new HttpError(404, superv.loadMessParams(_, 26, 149, request_code));

		if (rs[0].ACS && rs[0].ALLUSR !== 2) {
			if (rights._accessCodes.indexOf(rs[0].ACS) < 0) throw new HttpError(404, superv.loadMessParams(_, 29, 149, request_code)); //Access denied
		}
		// Access to the function : it must at least be available on a group
		if (rs[0].FCTLNK && rs[0].ALLUSR !== 2) {
			if (rights._authorizedFunctions.indexOf(rs[0].FCTLNK) < 0) throw new HttpError(404, superv.loadMessParams(_, 29, 149, request_code)); //Access denied
		}
	}

	// If a portal view set of parameters exists, we have to manage the execution time and the level
	if (qs.portview) {
		var apv = superv.load(_, 'Table', 'APTLVW');
		var rs = apv.loadRecords(_, apv.indexes[0], [qs.portview]);
		tracerJs.debug && tracerJs.debug("APTLVW rs:" + JSON.stringify(rs));

		if (rs.length) {
			portView = rs[0];
			var j = portView.SRCPARCOD.indexOf('FRQ');
			if (j) {
				// Frequency of computation : 1=always, 2=every hour, 3=every day, 4=every week, 5=every month, 6=never
				// EXECUTION_TIME is assigned as a time stamp numeric value (if 0, recomputation is not required)
				frq = evalue(_, portView.SRCPARFOR(j));
				execution_time = getExecutionTime(frq, forced_exec);
			}
			if (!level || level === 99) {
				j = portView.SRCPARCOD.indexOf('INITLEVEL');
				if (j) {
					level = evalue(_, portView.SRCPARFOR(j));
				}
			}

			// Dom October 14, 2014
			// If a calendar is used:
			//  - first, get the list of fields by calling a new subprogram (FIELDS) in the generated script
			//  - second, create the JSON prototype complement that maps the fields with the calendar
			if (["FCA", "FCC"].indexOf(portView.CMPCODTYP)) {
				//  clobbers earlier definition!
				var args = {
					FIELDS: {
						type: 'AS20',
						value: [1, "", [], 1, null]
					},
					NBFIELDS: {
						type: 'AI',
						value: 0
					}
				};
				executeProg(_, "FIELDS", args);
				var fields = args.value.FIELDS;
				var nbfields = args.value.NBFIELDS;
				tracerJs.debug && tracerJs.debug("requester calendar fields:" + fields);

				var fcdatedeb = getPortalValue(portView, 'FCDATEDEB', fields);
				if (fcdatedeb) {
					calendarPrototype = calendarPrototype || {};
					calendarPrototype.start = [];
					calendarPrototype.start.push(fcdatedeb);

					var fcheurdeb = getPortalValue(portView, 'FCHEURDEB', fields);
					if (fcheurdeb) calendarPrototype.start.push(fcheurdeb);

					var fcheurfin = getPortalValue(portView, 'FCHEURFIN', fields);
					if (fcheurfin) {
						calendarPrototype.end = [fcdatedeb, fcheurfin];
					}
				}
				var fctitre = getPortalValue(portView, 'FCTITRE', fields);
				if (fctitre) {
					calendarPrototype = calendarPrototype || {};
					calendarPrototype.summary = [fctitre];
				}
				var fctexte = getPortalValue(portView, 'FCTEXTE', fields);
				if (fctexte) {
					calendarPrototype = calendarPrototype || {};
					calendarPrototype.description = [fctexte];
				}
			}
		}
	}

	// Set some default values
	level = Math.max(Math.min(level, maxlevel), 1);

	if (qs.where) {
		//Analyze the where sentence
		// 1°) set default values:
		try {
			for (var i = 0; i < param[2].length; i++) {
				var etnaType = type.typTyp2EtnaType[partyp[2][i]];
				valbeg[2][i] = valend[2][i] = variables.types[etnaType].default;
				strictbeg[2][i] = strictend[2][i] = 0; // Value not set
			}
			// 2°) parse the sdata expression :
			var filter = filterHelpers.sdataToJson(qs.where);

			// 2°) set values :
			//    STRICTBEG and STRICTEND) => (0=no value in VALBEG/END, 1=strict comparizon, 2=can be equal)
			var expressions = filter.$and ? filter.$and : [filter];
			expressions.forEach(function (exp) {
				const i = param[2].indexOf(exp);

				if (i) {
					if (typeof exp === 'object') {
						Object.keys(expressions[exp]).forEach(function (operator) {
							switch (operator) {
								case '$eq':
									valbeg[2][i] = valend[2][i] = expressions[exp];
									strictbeg[2][i] = strictend[2][i] = 2;
									break;
								case '$gt':
									valbeg[2][i] = expressions[exp][operator];
									strictbeg[2][i] = 1;
									break;
								case '$gte':
									valbeg[2][i] = expressions[exp][operator];
									strictbeg[2][i] = 2;
									break;
								case '$lt':
									valend[2][i] = expressions[exp][operator];
									strictend[2][i] = 1;
									break;
								case '$lte':
									break;
									valend[2][i] = expressions[exp][operator];
									strictend[2][i] = 2;
									break;
							}
						});
					} else {
						valbeg[2][i] = valend[2][i] = expressions[exp];
						strictbeg[2][i] = strictend[2][i] = 2;
					}
				}
			});
		} catch (e) {
			throw new HttpError(404, superv.loadMessParams(_, 27, 149, request_code)); //Access denied
		}
	} else {
			// Let's analyse first_xxx and last_xxx parameters if QWHERE is empty
			try {
				var args = {
					ARCV: {
						type: "LY",
						value: arcv
					},
					VALBEG: {
						type: "AS",
						value: valbeg
					},
					VALEND: {
						type: "AS",
						value: valend
					},
					STRICTBEG: {
						type: "AI",
						value: strictbeg
					},
					STRICTEND: {
						type: "AI",
						value: strictend
					}
				};
				executeProg(_, "PARSE_PARAM", args);
			} catch (e) {
				// PARSE_PARAM doesn't always exist ...
			}
		}

	// Get the recomputation parameter
	const line_limit = actx.$APARAM(_).AGETVALNUM(_, 1, "", "SELWARN") || 10000;


	var ok = 0;
	// If unique id not set, and ( forced execution requested, or request type = recalculated), execute first
	if (requid === "" && (forced_exec || ifshared === 3)) {
		var tblSize = getTblSize(_);

		if (tblSize > line_limit) {
			rqtBatch(_);
		} else {
			execRqt(_);
			ok = getRqt(_);
		}
	} else {
		// Otherwise, try to read it first
		ok = getRqt(_);

		// Ii the request was never executed, or if the parameter don't fit
		if ([3, 5].indexOf(ok) >= 0) {
			var tblSize = getTblSize(_);
			if (tblSize > line_limit) {
				rqtBatch(_);
			} else {
				execRqt(_);
				ok = getRqt(_);
			}
		}
	}
	switch (ok) {
		case 0:
			return asnd.$send(_);
		case 1:
			var batchId = "batchId";
			return httpContext.reply(_, 202, {
				headerMessage: superv.loadMessParams(_, 146, 24, batchId, uuireq)
			});
		case 2:
			throw new HttpError(404, superv.loadMessParams(_, 26, 149, request_code));
		case 3:
			throw new HttpError(404, "No result available");
		case 4:
			// Access rights error
			throw new HttpError(403, superv.loadMessParams(_, 29, 149, request_code));
		case 6:
			throw new HttpError(403, superv.loadMessParams(_, 28, 149, request_code));
		case 7:
			// TODO : error in transaction for posting the batch request
			throw new HttpError(403, superv.loadMessParams(_, 28, 149, request_code));
	}
	return {};
};