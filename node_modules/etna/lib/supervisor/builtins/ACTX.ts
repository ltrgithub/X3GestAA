import { _ } from 'streamline-runtime';
import * as core from 'syracuse-core';
const glob = require('streamline/lib/globals');
const flows = require('streamline-runtime').flows;
import { TypedRecord } from '../../engine/drivers/types';
import { Dict, X3Prog, X3Session } from '../../engine/runtime/types';
import * as util from '../../supervisor/util';
import { Property } from '../meta/types';
import { Slot } from '../dyn/types';
import * as attributes from '../../supervisor/attributes';
import { X3Error } from '../../engine/runtime/errors';
import { ACTXCACHE } from './ACTXCACHE';
import { ACTXPARAM } from './ACTXPARAM';
import { AVOID } from './AVOID';
import * as variables from '../../engine/runtime/variables';
import * as system from '../../engine/runtime/system';
import { X3Rights } from '../../supervisor/X3Rights';
import { Diagnosis } from '../dyn/types';
const tracerJs = core.getTracer("etna.supervisor");
import * as constants from '../../supervisor/constants';
import { Supervisor } from '../../supervisor/supervisor';

// Store context ACTX per session in glob
// Use cache of sessions

export function init(_: _,  session: X3Session, superv: Supervisor) {
	glob.context.session = glob.context.session || {
		// for unit tests
		userName: "AQCORE",
		locale: "fr-FR"
	};
	glob.context.session.etnaContexts = glob.context.session.etnaContexts || {};
	var x3Session = glob.context.session.etnaContexts[superv.endpointName];
	if (!x3Session) {
		glob.context.session.etnaContexts[superv.endpointName] = x3Session = {
			dbConnection: null,
			supervisor: superv,
			funnel: flows.funnel(1)
		};
	}
	glob.context.x3session = x3Session;

	// Initialize glob.context.x3frame
	variables.initStack(superv);
	x3Session.funnel(_,  (_: _) => {
		if (!x3Session.actx) {
			x3Session.actx = new ACTX(superv).init(_, session.userName, session.locale);
		} else {
			x3Session.actx.$LANISO(_, session.locale);
		}
	});
	x3Session.actx.initSession(_);
};

class SlotBuiltIn extends Slot {
	fct: string;
	constructor(parent: util.Helper, fct: string) {
		super(parent, null);
		this.fct = fct;
	}

	get(_: _) {
		return this.$parent[this.fct](_);
	}

	set(_: _,  value: any) {
		if (this.getAttribute("$isReadOnly")) {
			throw new X3Error(147, (this.name ? this.name : '') + " is readonly");
		}

		return this.$parent[this.fct](_, value);
	}
}

class SlotActxProperty extends Slot {
	constructor(parent: util.Helper) {
		super(parent, null);
		this.value = null;;
	}

	get(_: _) {
		return this.value;
	}

	set(_: _,  value: any) {
		if (this.getAttribute("$isReadOnly")) {
			throw new X3Error(147, (this.name ? this.name : '') + " is readonly");
		}
		return this.value = value;
	}
}

class SlotChapter extends Slot {
	chapter: any;
	$isReadOnly: boolean;
	$_isReadOnly: boolean;
	constructor(parent: util.Helper, chapter: any) {
		super(parent, null);
		this.chapter = chapter;
	}

	get(_: _) {
		return this.chapter;
	}

	set(_: _,  value: any) {
		throw new X3Error(147, (this.name ? this.name : '') + " is readonly");
	}
}

class Chapter extends util.Helper {
	supervisor: Supervisor;
	parent: util.Helper;
	$name: string;
	builtinProperties: string[];
	$exported: boolean;
	isContext: boolean;
	slots: { [name: string]: Slot };
	constructor(superv: Supervisor, parent: util.Helper, name: string, builtinProperties?: string[]) {
		super();
		this.supervisor = superv;
		this.parent = parent;
		this.$name = name;
		this.builtinProperties = builtinProperties || [];
		this.$exported = true;
		this.isContext = true;
		this.slots = {};
	}
	init(_: _) {
		return this;
	}

	// Lazy loading of slots:
	slot(_: _,  name: string) {
		//dbg:console.log("Chapter.slot("+name+") builtinProperties:"+this.builtinProperties)
		if (this.slots[name]) return this.slots[name];
		if (name === undefined) throw new X3Error(6, "ACTX undefined property");

		tracerJs.debug && tracerJs.debug("loadProperty name:" + name);

		if (this.builtinProperties.indexOf(name) >= 0) {
			//dbg:console.log("loadProperty builtin:" + name);
			this.slots[name] = new SlotBuiltIn(this, "$" + name);
		} else {
			var recDb = this.supervisor.mongoStore.collection('ACONTEXT').find({
				CODCTX: name
			}).toArray().then(_, _)[0];

			if (recDb) {
				//dbg:console.log("ACTX => Slot:"+name);
				var wprop = {
					"FLDCLA": name,
					"CODTYP": recDb.CODTYP,
					"TYPCLA": 99,
					"LONG": recDb.LNGTYP
				};
				var property: Property = this.supervisor.new<Property>(_, 'Property', this, wprop);
				this.slots[name] = new SlotActxProperty(this);

				var dime: number;
				if (recDb.FORDIM && recDb.FORDIM[0]) dime = recDb.FORDIM[0];

				var trtini: string;
				if (recDb.TRTINI) trtini = recDb.TRTINI;
				if (recDb.FORINI) trtini = "this." + name + " = " + recDb.FORINI;
				if (trtini) {
					var wcript = "\n$METHODS \n";
					wcript += trtini + '\n';
					wcript += "Return";
					//wcript = "$METHODS \n this.IRS(1) = 'TOTO' \n this.IRS(2) = 'TOTA' \n Return" ;
					//console.log("wcript " + wcript);
					try {
						//dbg:console.log("ACTX loadScriptBase");
						var script = this.supervisor.loadScriptBase(_, wcript, name);
						var astatus = 0;
						var handler = script.METHODS;
						var frame = glob.context.x3frame;

						var prev = frame;
						var cx = prev.context;
						var sl = prev ? prev.stackLevel + 1 : 0;
						glob.context.x3frame = frame = {
							values: {},
							types: {},
							context: cx,
							prev: prev,
							stackLevel: sl,
							loopLevel: 0,
							loc: {
								file: module.id,
								line: 0
							}
						};
						// current sub is the prog itself
						try {
							frame.sub = frame;
							frame.dicts = [frame, cx.globals, cx.sys];
							util.declVar(frame, 'THIS', 'LY', this);
							//dbg:console.log("ACTX execute script");
							handler(_);
						} finally {
							glob.context.x3frame = prev;
						}
					} catch (e) {
						console.error("exception in script " + script, e.message);
						throw e;
					}
				}
			} else {
				recDb = this.supervisor.mongoStore.collection('ACONTEXT').find({
					CHAPTER: name
				}).toArray().then(_, _)[0];
				if (recDb) throw new Error("NIY ACTX property " + name);
				// was new Chapter???
				this.slots[name] = new SlotActxProperty(new Chapter(this.supervisor, this, name));
				//this.slots[name] = new Chapter(this.supervisor, this, name);
			}
		}
		// Protect the property :
		this.slots[name].$isReadOnly = true;
		this.slots[name].$_isReadOnly = true;
		return this.slots[name];
	}

	set(_: _,  name: string, value: any) {
		tracerJs.debug && tracerJs.debug(this.$name + " set:" + name);
		this.slot(_, name).set(_, value);
	}
	get(_: _,  name: string) {
		tracerJs.debug && tracerJs.debug(this.$name + " get:" + name);
		return this.slot(_, name).get(_);
	}

	setPropertyAttribute(_: _,  property: string, attribute: string, value: any) {
		return this.slot(_, property).setAttribute(attribute, value);
	}

	getPropertyAttribute(_: _,  property: string, attribute: string) {
		return this.slot(_, property).getAttribute(attribute);
	}
};
attributes.addAttributes(Chapter.prototype);

class AFOLD extends Chapter {
	parent: ACTX;
	amodule: any[];
	alegcur: string;
	alistleg: string;
	constructor(parent: ACTX) {
		super(parent.supervisor, parent, "AFOLD", ["ALANGDEF", "AMODULE", "ALEGCUR", "ALISTLEG", "ANBLEG", "AVERSION", "AHISTO"]);
	}

	$ALANGDEF(_: _) {
		return this.parent.$LANDEF(_);
	}

	$AMODULE(_: _) {
		const flags = new Array(11).join('2');

		if (!this.amodule) {
			var actx = this.parent;
			var wadoval = actx.supervisor.sqlReader<{
				PARAM: string;
				VALEUR: string;
			}>(_, "select A.PARAM_0, A.VALEUR_0 from ADOVAL A Where A.CMP_0=' ' and A.FCY_0=' ' and A.PARAM_0 in ('MODULE1','MODULE2')").toArray(_);
			var values = wadoval.reduce((r, record) => {
				if (record.VALEUR) r[record.PARAM] = record.VALEUR;
				return r;
			}, {
				MODULE1: flags,
				MODULE2: flags
			} as TypedRecord<{
				MODULE1: string;
				MODULE2: string;
			}>);
			var modules = (values.MODULE1 + values.MODULE2).split('').map((c: string) => parseInt(c));
			this.amodule = [1, 0, modules, 1, modules.length];
		}
		return this.amodule;
	}

	$ALEGCUR(_: _) {
		return this.alegcur = this.alegcur || (this.$ALISTLEG(_).length === 1 ? this.$ALISTLEG(_)[0] : "");
	}

	$ALISTLEG(_: _) {
		return this.alistleg = this.alistleg || this.supervisor.$LEGISLATIONS(_, this.parent);
	}

	$ANBLEG(_: _) {
		return this.$ALISTLEG(_).length;
	}

	$AVERSION(_: _) {
		return system.functions.VER$.fn(0);
	}

	$AHISTO(_: _) {
		return 1; //1 = false
	}
}

class AINTL extends Chapter {
	constructor(parent: ACTX) {
		super(parent.supervisor, parent, "AINTL", ["TWODIGITYEAR", "SHORTDATE", "LONGDATE", "SHORTTIME", "LONGTIME", "SHORTDATETIM", "LONGDATETIM", "DECIMALSEP", "THOUSANDSEP"]);
	}

	adxfmt(idx: number) {
		return glob.context.x3frame.context.sys.values.ADXFMT2[2][idx];
	}
	$TWODIGITYEAR(_: _) {
		return glob.context.x3frame.context.sys.values.ADXDCS;
	}
	$SHORTDATE(_: _) {
		return this.adxfmt(0);
	}
	$LONGDATE(_: _) {
		return this.adxfmt(1);
	}
	$SHORTTIME(_: _) {
		return this.adxfmt(2);
	}
	$LONGTIME(_: _) {
		return this.adxfmt(3);
	}
	$SHORTDATETIM(_: _) {
		return this.adxfmt(4);
	}
	$LONGDATETIM(_: _) {
		return this.adxfmt(5);
	}
	$DECIMALSEP(_: _) {
		return this.adxfmt(6);
	}
	$THOUSANDSEP(_: _) {
		return this.adxfmt(7);
	}
}

export class ACTX extends Chapter {
	_x3Rights: X3Rights;
	AGETCRITROLE: X3Prog<void>;
	rights: any;
	solution: string;
	folder: string;
	landef: string;
	lan: string;
	laniso: string;
	user: string;
	login: string;
	adonix: number;
	legfil: string;
	aparam: ACTXPARAM;
	acache: ACTXCACHE;
	constructor(superv: Supervisor) {
		super(superv, null, "ACTX", ["ASOLUTION", "AFOLDER", "LANISO", "LAN", "LANDEF", "USER", "LOGIN"]);
		this._x3Rights = new X3Rights(superv);
		this.AGETCRITROLE = {
			params: ['ACTX', 'AOBJ', 'ABRFIC', 'ACRITROLE', 'AFLGERR'],
			body(_: _) {
				const frame = glob.context.x3frame;
				// Set ACRITROLE and mark it as variable for CallProg

				frame.types.ACRITROLE = "AS";
				frame.values.ACRITROLE = "(1=1)";
				// Set AFLGERR and mark it as variable for CallProg
				frame.types.AFLGERR = "AI";
				frame.values.AFLGERR = variables.constants.CST_ATRUE;

				frame.result = variables.constants.CST_ATRUE;
			}
		};
		// TODO FIRSTDAYWEEK:function(){ return "";},
		// TODO NBGROUPSEP:function(){ return "";},
	}

	init(_: _,  userName?: string, locale?: string) {
		// set LOGIN+USER
		this.$LOGIN(_, userName);
		// set LANISO+LAN
		this.$LANISO(_, locale);

		// set system variables related to the context
		this.supervisor.initSysVar(_, this);
		return this;
	}

	initSession(_: _) {
		// Add supervisor system variables
		const context = glob.context.x3frame.context;
		const sys = this.supervisor.sys;

		Object.keys(sys).forEach(p => util.declVar(context.sys, p, 'CS', sys[p].slice()));

		// Add supervisor global variables
		const globals = context.globals;

		util.declVar(globals, 'GACTX', 'VY', this);
		util.declVar(globals, 'AVOID', 'VY', new AVOID());
		util.declVar(globals, 'GADONIX', 'VI', this.$ADONIX(_));
		util.declVar(globals, 'GDIMFIC', 'VI', 250);
		util.declVar(globals, 'GPRODUIT', 'VI', -1);
		util.declVar(globals, 'GUTF8', 'VI', 0);
		util.declVar(globals, 'GADOVERS', 'VS', "L");
		util.declVar(globals, 'GSILENCE', 'VI', 0);
		util.declVar(globals, 'GSERVEUR', 'VI', 0);
		util.declVar(globals, 'GWEBSERV', 'VI', 0);
		util.declVar(globals, 'GIMPORT', 'VI', 1); // For test ?
		util.declVar(globals, 'GTRACE', 'VS', "");
		//util.declVar(globals, 'GLEGFIL', 'VS', this.$LEGFIL(_));
	}

	// Lazy loading of slots:
	slot(_: _,  name: string) {
		//dbg:console.log("ACTX.slot("+name+")")
		if (this.slots[name]) return this.slots[name];
		// Special treatments for ACTX :
		switch (name) {
			case "APARAM":
				return this.slots['APARAM'] = new SlotChapter(this, this.$APARAM(_));
			case "ACACHE":
				return this.slots['ACACHE'] = new SlotChapter(this, this.$ACACHE(_));
			case "AFOLD":
				return this.slots['AFOLD'] = new SlotChapter(this, new AFOLD(this));
			case "AINTL":
				return this.slots['AINTL'] = new SlotChapter(this, new AINTL(this));
		}
		return super.slot(_, name);
	}

	getRights(_: _) {
		return this.rights = this.rights || this._x3Rights.getRights(_, this.$LOGIN(_));
	}

	getRightsEtag(_: _) {
		return this._x3Rights._etag;
	}

	getJsonRights(_: _) {
		const toJson = function (res: any) {
			return Object.keys(res).reduce((r, p) => {
				if (Array.isArray(res[p])) {
					r[p] = res[p].join(',');
				} else if (typeof res[p] === 'object') {
					r[p] = toJson(res[p]);
				} else {
					r[p] = res[p];
				}
				return r;
			}, {} as Dict<any>);
		};

		const res = this.getRights(_);

		return res ? toJson(res) : {};
	}

	$ASOLUTION(_: _,  solution: string) {
		return this.solution = solution !== undefined ? solution : this.solution || glob.context.x3session.supervisor.solutionName;
	}

	$AFOLDER(_: _,  folder: string) {
		return this.folder = folder !== undefined ? folder : this.folder || glob.context.x3session.supervisor.folderName;
	}

	$LANISO(_: _,  laniso?: string) {
		if (laniso !== undefined && (!this.laniso || this.laniso.toLowerCase() !== laniso.toLowerCase())) {
			var rTablan = this.supervisor.sqlReader<{
				LANISO: string;
				LAN: string;
			}>(_, "select LAN_0,LANISO_0 from TABLAN where (LOWER(LANISO_0)=" + this.supervisor.sqlDriver.param(0) + ")", [laniso.toLowerCase()]).limit(1).toArray(_);

			if (rTablan[0] !== undefined) {
				this.laniso = rTablan[0].LANISO;
				this.$LAN(_, rTablan[0].LAN);
			} else {
				var rTablan = this.supervisor.sqlReader<{
					LANISO: string;
					LAN: string;
				}>(_, "select LAN_0,LANISO_0 from TABLAN where (LAN_0=" + this.supervisor.sqlDriver.param(0) + ")", [this.$LANDEF(_)]).limit(1).toArray(_);
				this.laniso = rTablan[0].LANISO;
				this.$LAN(_, rTablan[0].LAN);
			}
			glob.context.x3frame.context.sys.values.MESSNAME = this.$LAN(_);
			var newlaniso = this.$LANISO(_);

			require('streamline-locale').setCurrent(_, newlaniso);
			const values = glob.context.x3frame.context.sys.values;
			const locales: { [key: string]: RegExp } = {
				' .': /^fr.*/i,
				',.': /^en.*/i
			};
			Object.keys(locales).some(key => {
				if (locales[key].test(newlaniso)) {
					values.ADXSCA = values.ADXSCA.substring(0, 2) + key + values.ADXSCA.substring(4);
					return true;
				}
			});
		} else {
			this.laniso = this.laniso || "";
		}
		return this.laniso;
	}

	$LANDEF(_: _,  landef?: string) {
		//dbg:console.log("ACTX.LANDEF:"+!!this.supervisor);
		if (landef !== undefined) {
			this.landef = landef;
		} else if (this.landef === undefined) {
			this.landef = this.landef || this.supervisor.$LANDEF(_);
		};
		return this.landef;
	}

	$LAN(_: _,  lan?: string) {
		return this.lan = lan !== undefined ? lan : this.lan || this.$LANDEF(_);
	}

	$USER(_: _,  user?: string) {
		return this.user = user !== undefined ? user : this.user || glob.context.x3frame.context.sys.values.ADXUSR.toUpperCase();
	}

	$LOGIN(_: _,  login?: string) {
		if (login !== undefined) {
			this.login = login;
			var rUser = this.supervisor.sqlReader<{
				USR: string;
				ENAFLG: number;
				USRCONNECT: number;
			}>(_, "select USR_0 ,CODMET_0, PRFFCT_0, ENAFLG_0, USRCONNECT_0 from AUTILIS where (LOGIN_0=" + this.supervisor.sqlDriver.param(0) + ")", [login.toUpperCase()]).limit(1).toArray(_);

			if (rUser[0]) {

				if (rUser[0].ENAFLG !== 2) {
					throw new util.HttpError(401, this.supervisor.loadMess(_, 130, 70));
				} else if (rUser[0].USRCONNECT !== 2) {
					throw new util.HttpError(401, this.supervisor.loadMess(_, 123, 279));
				}
				this.$USER(_, rUser[0].USR);

				//ADXUSR=LOGIN
				glob.context.x3frame.context.sys.values.ADXUSR = login;

				this.getRights(_);
			} else throw new util.HttpError(401, this.supervisor.loadMess(_, 130, 70));
		} else {
			this.login = this.login || glob.context.x3frame.context.sys.values.ADXUSR.toUpperCase();
		}
		return this.login;
	}

	$ADONIX(_: _) {
		return this.adonix = this.adonix || this.supervisor.$ADONIX(_, this);
	}

	$LEGFIL(_: _) {
		return this.legfil = this.legfil || this.$APARAM(_).AGETUSERVALCHAR(_, "LEGFIL") || "";
	}

	$APARAM(_: _) {
		return this.aparam = this.aparam || new ACTXPARAM(this.supervisor).init(_);
	}

	$ACACHE(_: _) {
		return this.acache = this.acache || new ACTXCACHE(this.supervisor).init(_);
	}

	//keep this name ACTX_SET_LOGIN for X3 compatibility
	ACTX_SET_LANISO(_: _,  laniso: string) {
		return this.$LANISO(_, laniso);
	}

	ASETERROR(_: _,  path: string, msg: string, severity: number) {
		this.diagnoses = this.diagnoses || [];
		this.diagnoses.push(this.supervisor.new<Diagnosis>(_, 'Diagnosis', severity, path, msg));
		return severity;
	}

	ASETATTRPROP(_: _,  property: string, attribute: string, value: any) {
		try {
			return this.setPropertyAttribute(_, property, attribute, value);
		} catch (ex) {
			util.traceException(ex);
			return constants.CST_AERROR;
		}
	}
};

attributes.addAttributes(ACTX.prototype);
