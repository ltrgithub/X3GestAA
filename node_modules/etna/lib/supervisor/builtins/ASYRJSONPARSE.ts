"use strict";

exports.$exported = true;

const glob = require('streamline/lib/globals');
const variables = require('etna/lib/engine/runtime/variables');
const Clbfile = require('etna/lib/engine/runtime/tclbfile').Clbfile;
const constants = require("etna/lib/supervisor/constants");
const util = require("etna/lib/supervisor/util");
const trace = require('syracuse-core').getTracer("etna.supervisor");

// # NODES TYPES:
// #    1: object
// #    2: array
// #    3: string
// #    4: number
// #    5: word

class ASYJSO {
	constructor(typ, pro, cnt, father) {
		this.$exported = true;
		this.TYP = typ;
		this.PRO = pro;
		this.CNT = cnt;
		if (typ === 3 && cnt.length > 255) {
			this.CLB = {
				CLB: new Clbfile(cnt)
			};
		}
		this.FAT = father;
		this.NEX = null;
	}
};

function walkJson(object, nodes, father) {
	var prev;

	const add = function (typ, pro, cnt, father) {
		const node = new ASYJSO(typ, pro, cnt, father);

		if (prev) {
			prev.NEX = node;
		}
		father.SUB = father.SUB || node;
		prev = node;
		nodes.push(node);
		return node;
	};

	const stringOrWord = function (cnt) {
		return (/true|false|null/.test(cnt) ? 5 : 3
		);
	};

	if (object === null) {
		add(1, "", null, father);
	} else if (typeof object === 'object') {
		Object.keys(object).forEach(child => {
			switch (typeof object[child]) {
				case "string":
					add(stringOrWord(object[child]), child, object[child], father);
					break;
				case "number":
					add(4, child, object[child], father);
					break;
				case "object":
					if (Array.isArray(object[child])) {
						var nodeArray = add(2, child, null, father);
						object[child].forEach(arrElt => {
							walkJson(arrElt, nodes, nodeArray);
						});
					} else {
						walkJson(object[child], nodes, add(1, child, null, father));
					}
					break;
			}
		});
	} else {
		switch (typeof object) {
			case "string":
				add(stringOrWord(object), "", object, father);
				break;
			case "number":
				add(4, "", object, father);
				break;
		}
	}
}

module.exports = {
	PARSEJSON: {
		params: ['ACTX', 'JSON', 'NODES', 'NODE'],
		body(_: _) {
			const frame = glob.context.x3frame;

			frame.result = constants.CST_AERROR;
			frame.types.NODES = 'AX';
			frame.types.NODE = 'AY';
			frame.values.NODE = null;
			frame.values.NODES[2] = null;
			frame.values.NODES[4] = 0;

			try {
				var nodes = [];
				nodes.push(new ASYJSO(1, ""));
				var node = nodes[0];
				var json = frame.values.JSON.x3ToString();
				if (json.length) {
					var root = JSON.parse(json);
					walkJson(root, nodes, node);
				}
				frame.values.NODES[2] = nodes;
				frame.values.NODES[4] = nodes.length;
				frame.values.NODE = nodes[0];
				frame.result = constants.CST_AOK;
			} catch (e) {
				trace.error && trace.error(e);
			}
		}
	}
};