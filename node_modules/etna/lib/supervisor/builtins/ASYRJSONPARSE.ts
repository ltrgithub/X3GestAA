exports.$exported = true;
import { _ } from 'streamline-runtime';
import * as core from 'syracuse-core';
import * as runtimeUtil from '../../engine/runtime/util';
import * as variables from '../../engine/runtime/variables';
import { Clbfile } from '../../engine/runtime/tclbfile';
import * as constants from '../../supervisor/constants';
import * as util from '../../supervisor/util';
const trace = core.getTracer("etna.supervisor");

// # NODES TYPES:
// #    1: object
// #    2: array
// #    3: string
// #    4: number
// #    5: word

class ASYJSO {
	TYP: number;
	PRO: string;
	CNT: string;
	FAT: any;
	NEX: any;
	CLB: { CLB: Clbfile; };
	$exported: boolean;

	constructor(typ: number, pro: string, cnt?: string, father?: any) {
		this.$exported = true;
		this.TYP = typ;
		this.PRO = pro;
		this.CNT = cnt;
		if (typ === 3 && cnt.length > 255) {
			this.CLB = {
				CLB: new Clbfile(cnt)
			};
		}
		this.FAT = father;
		this.NEX = null;
	}
};

function walkJson(object: any, nodes: any[], father: any) {
	var prev: any;

	const add = function (typ: number, pro: string, cnt: string, father: any) {
		const node = new ASYJSO(typ, pro, cnt, father);

		if (prev) {
			prev.NEX = node;
		}
		father.SUB = father.SUB || node;
		prev = node;
		nodes.push(node);
		return node;
	};

	const stringOrWord = function (cnt: string) {
		return (/true|false|null/.test(cnt) ? 5 : 3
		);
	};

	if (object === null) {
		add(1, "", null, father);
	} else if (typeof object === 'object') {
		Object.keys(object).forEach(child => {
			switch (typeof object[child]) {
				case "string":
					add(stringOrWord(object[child]), child, object[child], father);
					break;
				case "number":
					add(4, child, object[child], father);
					break;
				case "object":
					if (Array.isArray(object[child])) {
						var nodeArray = add(2, child, null, father);
						object[child].forEach((arrElt: any) => {
							walkJson(arrElt, nodes, nodeArray);
						});
					} else {
						walkJson(object[child], nodes, add(1, child, null, father));
					}
					break;
			}
		});
	} else {
		switch (typeof object) {
			case "string":
				add(stringOrWord(object), "", object, father);
				break;
			case "number":
				add(4, "", object, father);
				break;
		}
	}
}

module.exports = {
	PARSEJSON: {
		params: ['ACTX', 'JSON', 'NODES', 'NODE'],
		body(_: _) {
			const frame = runtimeUtil.currentContext().x3frame;

			frame.types['NODES'] = 'AX';
			frame.types['NODE'] = 'AY';
			frame.values['NODE'] = null;
			frame.values['NODES'][2] = null;
			frame.values['NODES'][4] = 0;

			try {
				var nodes: any[] = [];
				nodes.push(new ASYJSO(1, ""));
				var node = nodes[0];
				var json = frame.values['JSON'].x3ToString();
				if (json.length) {
					var root = JSON.parse(json);
					walkJson(root, nodes, node);
				}
				frame.values['NODES'][2] = nodes;
				frame.values['NODES'][4] = nodes.length;
				frame.values['NODE'] = nodes[0];
				frame.result = constants.CST_AOK;
			} catch (e) {
				trace.error && trace.error(e);
				frame.result = constants.CST_AERROR;
			}
		}
	}
};