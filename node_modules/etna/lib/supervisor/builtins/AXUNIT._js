"use strict";

exports.$exported = true;

const glob = require('streamline-runtime').globals;
const date = require('syracuse-core').types.date;
const errors = require('etna/lib/engine/runtime/errors');
const flowControl = require('etna/lib/engine/runtime/flowControl');
const runtime = require('etna/lib/engine/runtime/runtime');
const config = require("etna/lib/util/nodeconfig").config;
const testCases = [];
const tracerJs = require('syracuse-core').getTracer("etna.supervisor");

function nanos(hr) {
	return hr[0] * 1e9 + hr[1];
}
const hrtime = process.hrtime();

exports.TESTSUITE_START = function (_, suite_id, suite_description) {
	//added for AXUNIT comptability
};

exports.ADD_TESTCASE = function (_, name, title, count) {
	testCases.push({
		name: name.valueOf(),
		title: title.valueOf(),
		count: count
	});
};

exports.RUN_TESTSUITE = function (_, title, description) {
	tracerJs.debug && tracerJs.debug("AXUNIT RUN_TESTSUITE:" + title);

	/*	var recorder = require('streamline-flamegraph/lib/record').create({
     // sampling rate, in milliseconds, 1 by default
     rate: 1,
     // root of source tree (will be trimmed from full file names to get relative paths)
     // by default: ""
     sourceRoot: __dirname,
     // pattern for source link URLs
     // by default: "file://{fullpath}#{line}"
     //sourceUrl: "https://github.com/Sage/streamline-flamegraph/tree/master/{relpath}#L{line}",
     sourceUrl: "file://{fullpath}",
 });
 recorder.start();*/

	const frame = glob.context.x3frame;
	const moduleId = errors.moduleName(frame.prev.loc);

	QUnit.module(moduleId, {
		teardown() {}
	});

	QUnit.done = function () {
		const time = nanos(process.hrtime(hrtime));

		console.log(JSON.stringify({
			shutdown: true,
			xqz: "t@)$",
			log: "QLFAR '" + title + "' executed in " + time / 1e6 + " ms"
		}) + "");
	};

	testCases.forEach((tc, i) => {
		tracerJs.debug && tracerJs.debug("AXUNIT RUN:" + tc.name);
		asyncTest(tc.title, tc.count, function (_) {
			try {
				var prog;
				if (!i && (prog = frame.prog.module["SETUP"])) // First element
					flowControl.callProg(_, prog, [], [], glob.context.x3frame.sub.loc);

				prog = frame.prog.module[tc.name];
				if (!prog) throw new Error("test case missing: " + tc.name);

				console.error("AXUNIT:" + tc.name);
				flowControl.callProg(_, prog, [], [], glob.context.x3frame.sub.loc);

				if (i === testCases.length - 1 && (prog = frame.prog.module["TEARDOWN"])) // Last element
					flowControl.callProg(_, prog, [], [], glob.context.x3frame.sub.loc);

				start();
			} catch (ex) {
				console.error("AXUNIT CAUGHT: " + ex.stack);
				throw ex;
			}
		});
	});
	return "";
};

exports.CHECK_EQUAL = function (_, v1, v2, title) {
	if (v1 === undefined) {
		return deepEqual(-1, 0, "CHECK_EQUAL : GOT is undefined");
	}
	if (v2 === undefined) {
		return deepEqual(-1, 0, "CHECK_EQUAL : EXPECTED is undefined");
	}
	const v11 = Array.isArray(v1) ? v1[2][0] === undefined ? v1[1] : v1[2][0] : v1;
	const v22 = Array.isArray(v2) ? v2[2][0] === undefined ? v2[1] : v2[2][0] : v2;

	if (typeof v11.x3ToString !== 'function') return console.error(v11), deepEqual(-1, 0, `CHECK_EQUAL: EXPECTED ${ v22 }, GOT invalid value: typeof=${ typeof v11 }, val=${ v11 }`);
	if (v11.x3ToString() === "NaN") {
		return deepEqual(-1, 0, "CHECK_EQUAL : GOT is NaN");
	}
	if (typeof v22.x3ToString !== 'function') return deepEqual(-1, 0, `CHECK_EQUAL: EXPECTED invalid value: typeof=${ typeof v22 }, val=${ v22 }`);
	if (v22.x3ToString() === "NaN") {
		return deepEqual(-1, 0, "CHECK_EQUAL : EXPECTED is NaN");
	}

	tracerJs.debug && tracerJs.debug("AXUNIT.CHECK_EQUAL:" + v11.constructor.name + ":'" + v11 + "' '" + v22.constructor.name + ":'" + v22 + "'");
	if (v11.x3Compare) deepEqual(v11.x3Compare(v22), 0, title ? title.valueOf() : undefined || "Expected '" + v22.x3ToString() + "' Got '" + v11.x3ToString() + "'");
	else deepEqual(1, 0, title ? title.valueOf() : undefined || "Expected " + v22.x3ToString() + " Got " + v11.x3ToString());
};

exports.CHECK_NOTEQUAL = function (_, v1, v2, title) {
	const v11 = Array.isArray(v1) ? v1[2][0] === undefined ? v1[1] : v1[2][0] : v1;
	const v22 = Array.isArray(v2) ? v2[2][0] === undefined ? v2[1] : v2[2][0] : v2;

	tracerJs.debug && tracerJs.debug("AXUNIT.CHECK_NOTEQUAL:" + v11.constructor.name + ":" + v11 + " " + v22.constructor.name + ":" + v22);
	ok(v11.x3Compare(v22) != 0, title ? title.valueOf() : undefined || "Expected " + v22.x3ToString() + " notEqual " + v11.x3ToString());
};

exports.CHECK_TRUE = function (_, v) {
	tracerJs.debug && tracerJs.debug("AXUNIT.CHECK_TRUE:" + v);
	exports.CHECK_EQUAL(_, v, 1);
};

exports.CHECK_FALSE = function (_, v) {
	tracerJs.debug && tracerJs.debug("AXUNIT.CHECK_FALSE:" + v);
	exports.CHECK_EQUAL(_, v, 0);
};

exports.LOG_LINE = function (_, line) {
	tracerJs.debug && tracerJs.debug(line);
};

exports.APPEND_VALUE = function (_, v) {
	ok(v);
};