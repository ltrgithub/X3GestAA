import { _ } from 'streamline-runtime';
import * as core from 'syracuse-core';
import { Dict } from '../../engine/runtime/types';
import * as date from '../../engine/runtime/tdate';
import { X3Error } from '../../engine/runtime/errors';
import * as utilDriver from '../../engine/drivers/util';
import * as runtimeUtil from '../../engine/runtime/util';
import * as util from '../../supervisor/util';
const Helper = util.Helper;
const traceSup = core.getTracer("etna.supervisor");
import * as constants from '../../supervisor/constants';
import * as tdate from '../../engine/runtime/tdate';
import { Supervisor } from '../../supervisor/supervisor';

const HttpError = util.HttpError;

export interface JsParam {
	value: any;
	typval: number;
	nolib: number;
}

export interface AdoParameter {
	TYPVAL: number;
	NOLIB: number;
}

export class ACTXPARAM extends Helper {
	supervisor: Supervisor;
	$exported: boolean;
	cache: {
		levcod: {
			code: Dict<{
				parameter: Dict<JsParam>;
			}>;
		}[];
	};
	userCache: any;
	tableg: string[];
	tabcpy: string[];
	tabfcy: string[];
	constructor(superv: Supervisor) {
		super();
		this.supervisor = superv;
		this.$exported = true;
		this.cache = {
			levcod: []
		};
		this.userCache = {
			parameter: {}
		};
		this.tableg = [];
		this.tabcpy = [];
		this.tabfcy = [];
	}
	init(_: _) {
		this.class = null;
		return this;
	}
	get(_: _,  name: string) {
		switch (name) {
			case "LIST_FCY":
				var fcy = this._fcy(_);
				return [1, "", fcy, 1, fcy.length];
			case "LIST_CPY":
				var cpy = this._cpy(_);
				return [1, "", cpy, 1, cpy.length];
		}
	}
	AGETVALNUM(_: _,  levcod: number, code: string, parameter: string): number {
		//dbg:console.log("PARAM.AGETVALNUM:", levcod, code, parameter)
		return parseInt(this._getParam(_, levcod, code, parameter, "NUM").value);
	}
	AGETVALCHAR(_: _,  levcod: number, code: string, parameter: string): string {
		return this._getParam(_, levcod, code, parameter, "CHAR").value;
	}
	AGETVALDATE(_: _,  levcod: number, code: string, parameter: string): tdate.Date {
		return this._getParam(_, levcod, code, parameter, "DATE").value;
	}
	AGETUSERVALNUM(_: _,  parameter: string): number {
		return parseInt(this._getParamUser(_, parameter, "NUM").value);
	}
	AGETUSERVALCHAR(_: _,  parameter: string): string {
		//dbg:console.log("PARAM.AGETUSERVALCHAR:"+parameter)
		return this._getParamUser(_, parameter, "CHAR").value;
	}
	AGETUSERVALDATE(_: _,  parameter: string): tdate.Date {
		return this._getParamUser(_, parameter, "DATE").value;
	}
	jsParamValue(param: JsParam) {
		var val = param.value;
		if (val == null) return val;
		switch (param.typval) {
			case 1:
				// string
				return val;
			case 2:
				// numeric
				return parseFloat(val);
			case 3:
				// date
				val = val == '00000000' ? null : tdate.parse(val, 'yyyyMMdd');
				return val;
			case 4:
				// menu
				val = parseInt(val);
				if (param.nolib === 1) return val === 2 ? true : val === 1 ? false : null;
				else {
					if (val !== (val & 0xff)) throw new Error('tiny int' + val);
					return val;
				}
			default:
				throw new Error(`invalid parameter type code: ${ param.typval }`);
		}
	}
	getJsValue(_: _,  levcod: number, code: string, parameter: string) {
		var param: JsParam;
		if (levcod === constants.CST_ALEVUSR) param = this._getParamUser(_, parameter, "AUTO");
		else param = this._getParam(_, levcod, code, parameter, "AUTO");
		if (param == null) throw new Error(`parameter not found: ${ parameter }`);
		return this.jsParamValue(param);
	}
	_addParamUserCache(parameter: string, value: any, adopar: AdoParameter) {
		var param = this.userCache.parameter[parameter];
		if (!param) {
			param = this.userCache.parameter[parameter] = {
				value: value,
				typval: adopar.TYPVAL,
				nolib: adopar.NOLIB
			};
		}
		return param;
	}
	_addParamCache(levcod: number, code: string, parameter: string, value: any, adopar: AdoParameter) {
		if (!this.cache.levcod[levcod]) {
			this.cache.levcod[levcod] = {
				code: {}
			};
		}
		if (!this.cache.levcod[levcod].code[code]) {
			this.cache.levcod[levcod].code[code] = {
				parameter: {}
			};
		}
		var param = this.cache.levcod[levcod].code[code].parameter[parameter];
		if (!param) {
			param = this.cache.levcod[levcod].code[code].parameter[parameter] = {
				value: value,
				typval: adopar.TYPVAL,
				nolib: adopar.NOLIB
			};
		}
		return param;
	}
	_leg(_: _) {
		if (this.tableg.length > 0) return this.tableg;
		const sqlDriver = this.supervisor.sqlDriver;
		const wadoval = this.supervisor.sqlReader<{
			VALEUR: string;
		}>(_, "select A.VALEUR_0 from ADOVAL A Where A.CMP_0=' ' and A.FCY_0=' ' and A.PARAM_0='DOSLEG'").toArray(_);

		if (wadoval[0] === undefined) throw new HttpError(404, "Incorrect param DOSLEG");
		this.tableg = wadoval[0].VALEUR.split("~");
		return this.tableg;
	}
	_cpy(_: _) {
		if (this.tabcpy.length > 0) return this.tabcpy;
		const sqlDriver = this.supervisor.sqlDriver;

		this.tabcpy = this.supervisor.sqlReader<{
			CPY: string;
		}>(_, "select C.CPY_0 from COMPANY C").toArray(_).map(cpy => cpy.CPY);
		return this.tabcpy;
	}
	_fcy(_: _) {
		if (this.tabfcy.length > 0) return this.tabfcy;
		const sqlDriver = this.supervisor.sqlDriver;

		this.tabfcy = this.supervisor.sqlReader<{
			FCY: string;
		}>(_, "select F.FCY_0 from FACILITY F").toArray(_).map(fcy => fcy.FCY);
		return this.tabfcy;
	}
	_getLegFromCpy(_: _,  folder: string, cpy: string) {
		const sqlDriver = this.supervisor.sqlDriver;
		const param = sqlDriver.param;

		var value = "";
		var params = [cpy];
		const wparam = this.supervisor.sqlReader<{
			LEG: string;
		}>(_, "select A.LEG_0 from COMPANY A Where A.CPY_0=" + param(0), params).toArray(_);

		if (wparam[0]) {
			value = wparam[0].LEG;
		}
		return value;
	}
	_getCpyFromSite(_: _,  folder: string, site: string) {
		const sqlDriver = this.supervisor.sqlDriver;
		const param = sqlDriver.param;

		var value = "";
		var params = [site];
		const wparam = this.supervisor.sqlReader<{
			LEGCPY: string;
		}>(_, "select A.LEGCPY_0 from FACILITY A Where A.FCY_0=" + param(0), params).toArray(_);

		if (wparam[0]) {
			value = wparam[0].LEGCPY;
		}
		return value;
	}
	_getLegFromSite(_: _,  folder: string, site: string) {
		var cpy = "";
		var leg = "";
		cpy = this._getCpyFromSite(_, folder, site);
		if (cpy !== "") {
			leg = this._getLegFromCpy(_, folder, cpy);
		}
		return leg;
	}
	_requestAdovalBase(_: _,  levcod: string, code: string, parameter: string) {
		const sqlDriver = this.supervisor.sqlDriver;
		const param = sqlDriver.param;

		var value: any;
		var params = [levcod, code, parameter];
		const wparam = this.supervisor.sqlReader<{
			VALEUR: string;
		}>(_, "select A.VALEUR_0 from ADOVAL A Where A.CMP_0=" + param(0) + " and A.FCY_0=" + param(1) + " and A.PARAM_0=" + param(2), params).toArray(_);

		if (wparam[0]) {
			value = wparam[0].VALEUR;
		}
		return value;
	}
	_getParam(_: _,  levcod: number, code: string, parameter: string, action: string) {
		if (this.cache.levcod[levcod] !== undefined && this.cache.levcod[levcod].code[code] !== undefined && this.cache.levcod[levcod].code[code].parameter[parameter] !== undefined) {
			return this.cache.levcod[levcod].code[code].parameter[parameter];
		}
		return this._getParams(_, levcod, code, [parameter], action)[parameter];
	}
	_getParams(_: _,  levcod: number, code: string, parameters: string[], action: string): { [param: string]: any } {
		if (!parameters) throw new HttpError(404, "Incorrect param");
		var values: any = {};
		if (this.cache.levcod[levcod] !== undefined && this.cache.levcod[levcod].code[code] !== undefined) {
			var ok = true;
			var cache = this.cache.levcod[levcod].code[code].parameter;
			values = parameters.reduce((r, p) => {
				if (cache[p] === undefined) ok = false;
				else r[p] = cache[p] ? {
					value: cache[p].value,
					typval: cache[p].typval,
					nolib: cache[p].nolib
				} : {} as JsParam;
				return r;
			}, {} as Dict<JsParam>);
			if (ok) return values;
		}

		//manage CACHE

		// not found in chache , search in database		
		const sqlDriver = this.supervisor.sqlDriver;
		const param = sqlDriver.param;
		const actx = runtimeUtil.currentContext().x3session.actx;

		var value: any;
		var leg: string;
		var cpy: string;

		// read param in ADOPAR to have the definiton
		var select = "select A.VALDEF_0,A.NIVDEF_0,A.PARAM_0,A.TYPVAL_0,A.NOLIB_0 from ADOPAR A Where A.PARAM_0";
		if (parameters.length === 1) {
			select += "=" + param(0);
		} else {
			select += " in (" + parameters.map((val, i) => param(i)).join(',') + ") order by A.PARAM_0";
		}
		//dbg:console.error("select:"+select+":",parameters);
		const wadopar = this.supervisor.sqlReader<{
			PARAM: string;
			NIVDEF: number;
			VALDEF: number;
			TYPVAL: number;
			NOLIB: number;
		}>(_, select, parameters).toArray(_);

		for (var i = 0; i < wadopar.length; i++) {
			var parameter = wadopar[i].PARAM;
			if (action !== undefined) this.controlType(action, wadopar[i]);

			if (wadopar[i].NIVDEF === 4 && wadopar[i].VALDEF !== 2) throw new HttpError(400, parameter + " parameter can only be defined at User level");

			switch (levcod) {
				case 1:
					//  looking for value at "Dossier" level
					value = this._requestAdovalBase(_, " ", " ", parameter);
					break;
				case 5:
					// looking for value at "L�gislation" level
					if (code !== "" && this._leg(_).indexOf(code) < 0) throw new HttpError(404, code + " Legislation code does not exist");

					if (wadopar[i].NIVDEF === 1) {
						// case 1 : Parameter defined at "Dossier" level
						value = this._requestAdovalBase(_, " ", " ", parameter);
					} else {
						// Parameter defined at "Leg/Soc/Site/User" level
						value = this._requestAdovalBase(_, "*", code, parameter);
						if (value !== undefined) break;
						value = this._requestAdovalBase(_, " ", " ", parameter);
						break;
					}
					break;
				case 2:
					// looking for value at "Soci�t�" level
					if (code !== "" && this._cpy(_).indexOf(code) < 0) throw new HttpError(404, code + " Company code does not exist");

					if (wadopar[i].NIVDEF === 1) {
						// case 1 : Parameter defined at "Dossier" level
						value = this._requestAdovalBase(_, " ", " ", parameter);
						if (value !== undefined) break;
					} else if (wadopar[i].NIVDEF === 5) {
						//Parameter defined at "L�gislation" level						
						leg = this._getLegFromCpy(_, actx.$AFOLDER(_), code);
						if (leg !== "") {
							value = this._requestAdovalBase(_, "*", leg, parameter);
							if (value !== undefined) break;
							value = this._requestAdovalBase(_, " ", " ", parameter);
							if (value !== undefined) break;
						}
					} else {
						//case 3 : Parameter defined at "Soc/Site/User" level					
						value = this._requestAdovalBase(_, code, " ", parameter);
						if (value !== undefined) break;
						leg = this._getLegFromCpy(_, actx.$AFOLDER(_), code);
						value = this._requestAdovalBase(_, "*", leg, parameter);
						if (value !== undefined) break;
						value = this._requestAdovalBase(_, " ", " ", parameter);
						if (value !== undefined) break;
					}
					break;
				case 3:
					//looking for value at "Site" level
					if (code !== "" && this._fcy(_).indexOf(code) < 0) throw new HttpError(404, code + " Site code does not exist");

					if (wadopar[i].NIVDEF === 1) {
						// case 1 : Parameter defined at "Dossier" level
						value = this._requestAdovalBase(_, " ", " ", parameter);
						if (value !== undefined) break;
					} else if (wadopar[i].NIVDEF === 5) {
						// case 2Parameter defined at "L�gislation" level
						leg = this._getLegFromSite(_, actx.$AFOLDER(_), code);
						if (leg !== "") {
							value = this._requestAdovalBase(_, "*", leg, parameter);
							if (value !== undefined) break;
							value = this._requestAdovalBase(_, " ", " ", parameter);
							if (value !== undefined) break;
						}
					} else if (wadopar[i].NIVDEF === 2) {
						// case 3 : Parameter defined at "Soci�t�" level
						cpy = this._getCpyFromSite(_, actx.$AFOLDER(_), code);
						if (cpy !== "") {
							value = this._requestAdovalBase(_, cpy, " ", parameter);
							if (value !== undefined) break;
							leg = this._getLegFromCpy(_, actx.$AFOLDER(_), cpy);
							if (leg !== "") {
								value = this._requestAdovalBase(_, "*", leg, parameter);
								if (value !== undefined) break;
							}
						}
						value = this._requestAdovalBase(_, " ", " ", parameter);
						if (value !== undefined) break;
					} else {
						// case 4 : Parameter defined at "Site/User" level
						value = this._requestAdovalBase(_, " ", code, parameter);
						if (value !== undefined) break;
						cpy = this._getCpyFromSite(_, actx.$AFOLDER(_), code);
						if (cpy !== "") {
							value = this._requestAdovalBase(_, cpy, " ", parameter);
							if (value !== undefined) break;
							leg = this._getLegFromCpy(_, actx.$AFOLDER(_), code);
							if (leg !== "") {
								value = this._requestAdovalBase(_, "*", leg, parameter);
								if (value !== undefined) break;
							}
						}
						value = this._requestAdovalBase(_, " ", " ", parameter);
						if (value !== undefined) break;
					}
					break;
			}
			if (value === undefined) {
				switch (action) {
					case "CHAR":
						value = "";
						break;
					case "NUM":
						value = 0;
						break;
					case "DATE":
						value = 0;
						break;
					case "AUTO":
						switch (wadopar[i].TYPVAL) {
							case 1:
								value = '';break; // string
							case 2:
								value = 0;break; //
							case 3:
								value = 0;break; // date
							case 4:
								value = 0;break;
							default:
								throw new Error(`invalid TYPVAL: ${ wadopar[i].TYPVAL }`);
						}
						break;
					default:
						throw new Error(`invalid data type conversion: ${ action }`);
				}
			}
			traceSup.debug && traceSup.debug([parameter, levcod, code].join(',') + "=" + value);
			values[parameter] = this._addParamCache(levcod, code, parameter, value, wadopar[i]);
		}
		return values;
	}
	controlType(action: string, record: any) {
		switch (action) {
			case "CHAR":
				//1:alpha 4:local menu
				if ([1, 4].indexOf(record.TYPVAL) < 0) throw new HttpError(400, record.PARAM + " parameter is not of the right type : alpha (" + record.TYPVAL + ")");
				break;
			case "NUM":
				if (record.TYPVAL !== 2 && record.TYPVAL !== 4) throw new HttpError(400, record.PARAM + " parameter is not of the right type : numeric (" + record.TYPVAL + ")");
				break;
			case "DATE":
				if (record.TYPVAL !== 3) throw new HttpError(400, record.PARAM + " parameter is not of the right type : date (" + record.TYPVAL + ")");
				break;
		}
	}
	_getParamUser(_: _,  parameter: string, action: string) {
		if (!parameter) throw new HttpError(404, "Incorrect param");

		//manage CACHE
		if (this.userCache.parameter[parameter]) return this.userCache.parameter[parameter];

		// not found in chache , search in database		
		const sqlDriver = this.supervisor.sqlDriver;
		const param = sqlDriver.param;
		const actx = runtimeUtil.currentContext().x3session.actx;

		var value: any;
		// read param in ADOPAR to have the definiton

		var params: any[] = [parameter];
		const wadopar = this.supervisor.sqlReader<{
			NIVDEF: number;
			VALDEF: number;
			TYPVAL: number;
			NOLIB: number;
			CHAPITRE: number;
		}>(_, "select A.CHAPITRE_0,A.VALDEF_0,A.NIVDEF_0,A.PARAM_0,A.TYPVAL_0,A.NOLIB_0 from ADOPAR A Where A.PARAM_0=" + param(0), params).toArray(_);
		const values = {};

		if (wadopar[0] === undefined) throw new HttpError(404, `Invalid parameter ${ parameter }`);

		if (wadopar[0].NIVDEF !== 4) throw new HttpError(400, parameter + " is not defined at User level");

		this.controlType(action, wadopar[0]);

		params = [actx.$USER(_), parameter];
		var wadovalaus = this.supervisor.sqlReader<{
			VALEUR: string;
		}>(_, "select A.CODUSR_0,A.PARAM_0,A.VALEUR_0 from ADOVALAUS A Where A.CODUSR_0=" + param(0) + " and A.PARAM_0=" + param(1), params).toArray(_);
		if (wadovalaus[0] !== undefined) {
			value = wadovalaus[0].VALEUR;
			this._addParamUserCache(parameter, value, wadopar[0]);
		}

		if (wadopar[0].VALDEF === 2) {
			var profil = "";
			params = [actx.$USER(_)];
			var waus = this.supervisor.sqlReader<{
				CODMET: string;
				PRFFCT: string;
			}>(_, "select A.CODMET_0,A.PRFFCT_0 from AUTILIS A Where A.USR_0=" + param(0), params).toArray(_);
			if (waus[0] === undefined) throw new HttpError(404, "Incorrect user");
			profil = waus[0].PRFFCT;
			if (profil === "") {
				params = [waus[0].CODMET];
				var wame = this.supervisor.sqlReader(_, "select A.PRFFCT_0 from AMETUTI A Where A.CODMET_0=" + param(0), params).toArray(_);
				if (wame[0] === undefined) throw new HttpError(404, "Incorrect profile");
			}
			if (profil) {
				var module = 0;
				params = [wadopar[0].CHAPITRE];
				var wadi = this.supervisor.sqlReader<{
					N1: number;
				}>(_, "select A.N1_0 from ATABDIV A Where A.NUMTAB_0=901 and A.CODE_0=" + param(0), params).toArray(_);
				if (wadi[0] === undefined) throw new HttpError(404, "Incorrect module");

				params = [profil];
				if (wadi[0].N1 > 0 && wadi[0].N1 <= 20) {
					var nummdl = wadi[0].N1 - 1;

					params = [profil];
					var waft = this.supervisor.sqlReader<{
						FCYDEF: string;
					}>(_, "select A.FCYDEF_" + nummdl + " from AFCTFCT A Where A.PRFCOD_0=" + param(0), params).toArray(_);
					if (waft[0] !== undefined) {
						value = this._getParam(_, 3, waft[0].FCYDEF, parameter, action).value;
						if (value !== undefined) this._addParamUserCache(parameter, value, wadopar[0]);
					}
					value = this._getParam(_, 1, "", parameter, action).value;
				}
			}
		}
		return this._addParamUserCache(parameter, value, wadopar[0]);
	}
};
