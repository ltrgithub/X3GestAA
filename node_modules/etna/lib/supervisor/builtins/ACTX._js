"use strict";
var glob = require('streamline/lib/globals');
var util = require("etna/lib/supervisor/util");
var Helper = util.Helper;
var Slot = require("etna/lib/supervisor/slot").Slot;
var attributes = require("etna/lib/supervisor/attributes");
var X3Error = require("etna/lib/engine/runtime/errors").X3Error;
var ACTXCACHE = require("etna/lib/supervisor/builtins/ACTXCACHE").constructor;
var ACTXPARAM = require("etna/lib/supervisor/builtins/ACTXPARAM").constructor;
var AVOID = require("etna/lib/supervisor/builtins/AVOID").constructor;

var variables = require('etna/lib/engine/runtime/variables');
var system = require('etna/lib/engine/runtime/system');
var X3Rights = require("etna/lib/supervisor/X3Rights").X3Rights;
var tracerJs = require('syracuse-core').getTracer("etna.supervisor");
var constants = require("etna/lib/supervisor/constants");

var locales = {
	' .': /^fr.*/i,
	',.': /^en.*/i
};

var sessions = {};
var avoid = new AVOID();


// Store context ACTX per session in glob 
// Use cache of sessions
exports.init = function(_, session, superv) {
	var mysession;
	if (sessions[session.id]) {
		mysession = sessions[session.id];
		// controle + maj ou recreation
		glob.context.x3session = mysession;
		if (mysession.session.locale !== session.locale) {
			// set LANISO+LAN
			mysession.actx.$LANISO(_, session.locale);
		}
		mysession.session = session;
	} else {
		tracerJs.debug && tracerJs.debug("new session:" + session.id);
		mysession = {};
		mysession.session = session;
		mysession.supervisor = superv;
		glob.context.x3session = mysession;
		mysession.actx = new(exports.constructor)(superv).init(_);
		// set LOGIN+USER
		mysession.actx.$LOGIN(_, mysession.session.userName);
		// set LANISO+LAN
		mysession.actx.$LANISO(_, mysession.session.locale);
		tracerJs.debug && tracerJs.debug("load rights " + mysession.actx.$LOGIN(_));
		mysession.actx._x3Rights.getJsonRights(_, mysession.actx.$LOGIN(_));

		// set system variables related to the context
		//dbg:console.error("************** actxInitSysVar ***************");
		mysession.actx.$actxInitSysVar(_, superv);
		mysession.dbConnection = null;
		sessions[session.id] = mysession;

	}

	var self = this;
	// Initialise system variables :
	Object.keys(superv.sys).forEach(function(v) {
		glob.context.x3frame.context.sys.values[v] = superv.sys[v];
	});

	//dbg:console.error("************** ACTX ***************");
	var globals = glob.context.x3frame.context.globals;
	util.declVar(globals, 'GACTX', 'VY', glob.context.x3session.actx);
	util.declVar(globals, 'AVOID', 'VY', avoid);

	var adonix = mysession.actx.$APARAM(_).AGETVALNUM(_, 1, mysession.actx.$AFOLDER(_), "ADONIX");
	util.declVar(globals, 'GADONIX', 'VI', adonix);
	util.declVar(globals, 'GDIMFIC', 'VI', 250);
	var legfil = mysession.actx.$APARAM(_).AGETUSERVALCHAR(_, "LEGFIL") || "";
	util.declVar(globals, 'GLEGFIL', 'VS', legfil);
	util.declVar(globals, 'GPRODUIT', 'VI', -1);
	util.declVar(globals, 'GUTF8', 'VI', 0);

	util.declVar(globals, 'GADOVERS', 'VS', "L");
	util.declVar(globals, 'GSILENCE', 'VI', 0);
	util.declVar(globals, 'GSERVEUR', 'VI', 0);
	util.declVar(globals, 'GWEBSERV', 'VI', 0);
	util.declVar(globals, 'GIMPORT', 'VI', 1);// For test ?
	util.declVar(globals, 'GTRACE', 'VS', "");
};

class SlotBuiltIn extends Slot {
	constructor(parent, fct) {
		super(parent,null);
		this.fct = fct;
	}

	_get(_) {
		return this.$parent[this.fct](_);
	}

	_set(_, value) {
		if (this.getAttribute("$isReadOnly")) {
			throw new X3Error(147, (this.name ? this.name : '') + " is readonly");
		}

		return this.$parent[this.fct](_,value);
	}
}

class SlotActxProperty extends Slot {
	constructor(parent) {
		super(parent,null);
		this.value = null;;
	}

	_get(_) {
		return this.value;
	}

	_set(_, value) {
		if (this.getAttribute("$isReadOnly")) {
			throw new X3Error(147, (this.name ? this.name : '') + " is readonly");
		}
		return this.value = value;
	}
}
class SlotChapter extends Slot {
	constructor(parent, chapter) {
		super(parent,null);
		this.chapter = chapter;
	}

	_get(_) {
		return this.chapter;
	}

	_set(_, value) {
		throw new X3Error(147, (this.name ? this.name : '') + " is readonly");
	}
}



class Chapter extends Helper {
	constructor(superv , parent ,name, builtinProperties) {
		super();
		this.supervisor = superv;
		this.parent = parent;
		this.$name = name;
		this.builtinProperties = builtinProperties || [];
		this.$exported = true;
		this.isContext = true;
		this.slots = {};
	}
	init(_) {
		return this;
	}


	// Lazy loading of slots:
	slot(_, name) {
		//dbg:console.log("Chapter.slot("+name+") builtinProperties:"+this.builtinProperties)

		if (this.slots[name]) return this.slots[name];
		tracerJs.debug && tracerJs.debug("loadProperty name:" + name);
		this.desactGet = name;

		if (this.builtinProperties.indexOf(name) >= 0) {
			//dbg:console.log("loadProperty builtin:" + name);
			this.slots[name] = new SlotBuiltIn(this, "$"+name);
		} else {
			var recDb = this.supervisor.mongoStore.collection('ACONTEXT', _).find({
					CODCTX:name
				}).toArray(_)[0];

			if (recDb) {
				//dbg:console.log("ACTX => Slot:"+name);
				var wprop = {
					"FLDCLA": name,
					"CODTYP": recDb.CODTYP,
					"TYPCLA": 99,
					"LONG": recDb.LNGTYP,
				};
				var property = this.supervisor.new(_, 'Property', this, wprop);
				this.slots[name] = new SlotActxProperty(this,property);

				var dime;
				if (recDb.FORDIM && recDb.FORDIM[0]) dime = recDb.FORDIM[0];
				
				var trtini;
				if (recDb.TRTINI) trtini = recDb.TRTINI;
				if (recDb.FORINI) trtini = "this." + name + " = " + recDb.FORINI;
				if (trtini) {
					var wcript = "\n$METHODS \n";
					wcript += trtini + '\n';
					wcript += "Return";
					//wcript = "$METHODS \n this.IRS(1) = 'TOTO' \n this.IRS(2) = 'TOTA' \n Return" ;
					//console.log("wcript " + wcript);
					try {
						//dbg:console.log("ACTX loadScriptBase");

						var script = this.supervisor.loadScriptBase(_, wcript, name);
						
						var astatus = 0;
						var handler = script.METHODS;
						var frame = glob.context.x3frame;

						var prev = frame;
						var cx = prev.context;
						var sl = prev ? prev.stackLevel + 1 : 0;
						glob.context.x3frame = frame = {
							values: {},
							types: {},
							context: cx,
							prev: prev,
							stackLevel: sl,
							loopLevel: 0,
							loc: {
								file: module.id,
								line: 0
							}
						};
						// current sub is the prog itself
						frame.sub = frame;
						frame.dicts = [frame, cx.globals, cx.sys];
						try {
							util.declVar(frame, 'THIS', 'LY', this);
							//dbg:console.log("ACTX execute script");
							handler(_);
						} finally {
							glob.context.x3frame = prev;
						}
					
					} catch (e) {
						console.error("exception in script "+ script , e.stack);
					}
				}	
			} else {
				recDb = this.supervisor.mongoStore.collection('ACONTEXT', _).find({
					CHAPTER: name
				}).toArray(_)[0];
				if (recDb) throw new Error("NIY ACTX property " + name);
				this.slots[name] = new Chapter(this.supervisor , this ,name)				
			}
		}
		// Protect the property :
		this.slots[name].$isReadOnly = true;
		this.slots[name].$_isReadOnly = true;

		this.desactGet = null;
		//dbg:console.log("ACTX end slot:"+name);
		return this.slots[name];
	}	

	set(_, name, value) {
		tracerJs.debug && tracerJs.debug(this.$name + " set:" + name);
		this.slot(_, name)._set(_,value);
	}
	get(_, name) {
		tracerJs.debug && tracerJs.debug(this.$name + " get:" + name);
		return this.slot(_, name)._get(_);
	}

	setPropertyAttribute(_, property, attribut, value) {
		return this.slot(_, property).setAttribute(attribut, value);
	}

	getPropertyAttribute(_, property, attribut) {
		return this.slot(_, property).getAttribute(attribut);
	}
};
attributes.addAttributes(Chapter.prototype);

class AFOLD extends Chapter {
	constructor(parent) {
		super(parent.supervisor, parent ,"AFOLD", ["ALANGDEF","AMODULE","ALEGCUR","ALISTLEG","ANBLEG","AVERSION","AHISTO"]);
	}

	$ALANGDEF(_) {
		return this.parent.$LANDEF(_);
	}

	$AMODULE(_) {
		var flags = new Array(11).join('2');
		if (!this.amodule) {
			var actx = this.parent;
			var wadoval = actx.supervisor.sqlReader(_, "select A.PARAM_0, A.VALEUR_0 from ADOVAL A Where A.CMP_0=' ' and A.FCY_0=' ' and A.PARAM_0 in ('MODULE1','MODULE2')").toArray(_);
			var values = wadoval.reduce(function(r, record) {
				if (record.VALEUR) r[record.PARAM] = record.VALEUR;
				return r;
			}, {
				MODULE1: flags,
				MODULE2: flags
			});
			var modules = (values.MODULE1 + values.MODULE2).split('').map(function(c) {
				return parseInt(c);
			});
			this.amodule = [1, 0, modules, 1, modules.length];
		}
		return this.amodule;
	}

	$ALEGCUR(_) {
		// TODO voir ASYRCTLFOLDER
		return;
	}

	$ALISTLEG(_) {
		// TODO voir ASYRCTLFOLDER
		return;
	}

	$ANBLEG(_) {
		// TODO voir ASYRCTLFOLDER
		return;
	}

	$AVERSION(_) {
		return system.functions.VER$.fn(0);
	}

	$AHISTO(_) {
		// TODO
		return;
	}
}

class AINTL extends Chapter {
	constructor(parent) {
		super(parent.supervisor, parent ,"AINTL", ["TWODIGITYEAR","SHORTDATE","LONGDATE","SHORTTIME","LONGTIME","SHORTDATETIM","LONGDATETIM","DECIMALSEP","THOUSANDSEP"]);
	}

	adxfmt(idx) {
		return glob.context.x3frame.context.sys.values.ADXFMT2[2][idx];
	}
	$TWODIGITYEAR(_) {
		return glob.context.x3frame.context.sys.values.ADXDCS;
	}
	$SHORTDATE(_) {
		return this.adxfmt(0);
	}
	$LONGDATE(_) {
		return this.adxfmt(1);
	}
	$SHORTTIME(_) {
		return this.adxfmt(2);
	}
	$LONGTIME(_) {
		return this.adxfmt(3);
	}
	$SHORTDATETIM(_) {
		return this.adxfmt(4);
	}
	$LONGDATETIM(_) {
		return this.adxfmt(5);
	}
	$DECIMALSEP(_) {
		return this.adxfmt(6);
	}
	$THOUSANDSEP(_) {
		return this.adxfmt(7);
	}
}


class ACTX extends Chapter {
	constructor(superv) {
		super(superv, null, "ACTX", ["ASOLUTION", "AFOLDER", "LANISO", "LAN", "LANDEF", "USER", "LOGIN"]);
		this._x3Rights = new X3Rights(superv);


		this.AGETCRITROLE = {
			params: ['ACTX', 'AOBJ', 'ABRFIC', 'ACRITROLE', 'AFLGERR'],
			body: function(_) {
				var frame = glob.context.x3frame;
				// Set ACRITROLE and mark it as variable for CallProg
				frame.types.ACRITROLE = "AS";
				frame.values.ACRITROLE = "(1=1)";
				// Set AFLGERR and mark it as variable for CallProg
				frame.types.AFLGERR = "AI";
				frame.values.AFLGERR = variables.constants.CST_ATRUE;

				frame.result = variables.constants.CST_ATRUE;
			}
		};
		// TODO FIRSTDAYWEEK:function(){ return "";},
		// TODO NBGROUPSEP:function(){ return "";},
	}

	init(_) {
		return this;
	}
	
	// Lazy loading of slots:
	slot(_, name) {
		//dbg:console.log("ACTX.slot("+name+")")
		if (this.slots[name]) return this.slots[name];
		// Special treatments for ACTX :
		switch(name) {
			case "APARAM": return this.slots.APARAM = new SlotChapter(this,this.$APARAM(_));
			case "ACACHE": return this.slots.ACACHE = new SlotChapter(this,this.$ACACHE(_));
			case "AFOLD" : return this.slots.AFOLD  = new SlotChapter(this,new AFOLD(this));
			case "AINTL" : return this.slots.AINTL  = new SlotChapter(this,new AINTL(this));
		}
		return super.slot(_,name);
	}		

	$ASOLUTION(_ , solution) {
		return this.solution = (solution !== undefined) ? solution : (this.solution  || glob.context.x3session.supervisor.solutionName);
	}

	$AFOLDER(_ , folder) {
		return this.folder = (folder !== undefined) ? folder : (this.folder  || glob.context.x3session.supervisor.folderName);
	}

	$LANISO(_, laniso) {
		if(laniso !== undefined) {
			var self = this;
			var rTablan = self.supervisor.sqlReader(_,
				"select LAN_0,LANISO_0 from TABLAN where (LOWER(LANISO_0)=" + self.supervisor.sqlDriver.param(0) + ")", [laniso.toLowerCase()]).limit(1).toArray(_);

			if (rTablan[0] !== undefined) {
				this.laniso = rTablan[0].LANISO;
				this.$LAN(_, rTablan[0].LAN);

			} else {
				var rTablan = self.supervisor.sqlReader(_,
					"select LAN_0,LANISO_0 from TABLAN where (LAN_0=" + self.supervisor.sqlDriver.param(0) + ")", [self.$LANDEF(_)]).limit(1).toArray(_);
				this.laniso = rTablan[0].LANISO;
				this.$LAN(_, rTablan[0].LAN);
			}

			glob.context.x3frame.context.sys.values.MESSNAME = this.$LAN(_);

			var newlaniso = this.$LANISO(_);

			require('streamline-locale').setCurrent(_, newlaniso);
			(function($) {
				Object.keys(locales).some(function(key) {
					if (locales[key].test(newlaniso)) {
						$.ADXSCA = $.ADXSCA.substring(0, 2) + key + $.ADXSCA.substring(4);
						return;
					}
				});
			})(glob.context.x3frame.context.sys.values);			
		} else {
			this.laniso = this.laniso || "";
		}
		return this.laniso;
	}

	$LANDEF(_, landef) {
		//dbg:console.log("ACTX.LANDEF:"+!!this.supervisor);
		if (landef !== undefined) {
			this.landef = landef;
		} else if(this.landef === undefined) {
			var param = this.supervisor.sqlDriver.param;
			var rAdossier = this.supervisor.sqlReader(_,
				"select LANDEF_0 from ADOSSIER where (DOSSIER_0=" + param(0) + ")", [this.$AFOLDER(_)]).limit(1).toArray(_);
			this.landef = rAdossier[0].LANDEF;
		};
		return this.landef;
	}

	$LAN(_, lan) {
		return this.lan = (lan !== undefined) ? lan : (this.lan || this.$LANDEF(_));
	}

	$USER(_, user) {
		//dbg:console.log("ACTX.$USER:"+user);
		return this.user = (user !== undefined) ? user : (this.user || glob.context.x3frame.context.sys.values.ADXUSR.toUpperCase());
	}

	$LOGIN(_, login) {
		if(login !== undefined) {
			this.login = login;
			var rUser = this.supervisor.sqlReader(_,
				"select USR_0 ,CODMET_0, PRFFCT_0, ENAFLG_0, USRCONNECT_0 from AUTILIS where (LOGIN_0=" + this.supervisor.sqlDriver.param(0) + ")", [login.toUpperCase()]).limit(1).toArray(_);

			if (rUser[0]) {
				if (rUser[0].ENAFLG !== 2) {
					throw new util.HttpError(401, this.supervisor.loadMess(_, 130, 70));
				} else if (rUser[0].USRCONNECT !== 2) {
					throw new util.HttpError(401, this.supervisor.loadMess(_, 123, 279));
				}
				this.$USER(_, rUser[0].USR);

				//ADXUSR=LOGIN
				glob.context.x3frame.context.sys.values.ADXUSR = login;
			} else
				throw new util.HttpError(401, this.supervisor.loadMess(_, 130, 70));
		} else {
			this.login = this.login || glob.context.x3frame.context.sys.values.ADXUSR.toUpperCase();
		}		
		return this.login; 
	}

	$APARAM(_) {
		return this.aparam = this.aparam || new ACTXPARAM(this.supervisor).init(_)
	}

	$ACACHE(_) {
		return this.acache = this.acache || new ACTXCACHE(this.supervisor).init(_)
	}

	//keep this name ACTX_SET_LOGIN for X3 compatibility
	ACTX_SET_LANISO(_, laniso) {
		return this.$LANISO(_, laniso)
	}

	ASETERROR(_, path, msg, severity) {
		//dbg:console.log("TODO ACTX.ASETERROR " + [path, msg, severity].join(','));
		this.diagnoses = this.diagnoses || []; // TODO 
		this.diagnoses.push(this.supervisor.new(_, 'Diagnosis', severity, path, msg));
		return severity;
	}

	$actxInitSysVar(_, superv) {
		if (!superv.sys) {
			var wparamTUL;
			var values = {
				ADXTUL: [],
				ADXTUC0: [],
				ADXTUT0: [],
				ADXTUC: [],
				ADXTUT: []
			};
			var parameters = [];

			for (var i = 1; i <= 30; i++) {
				parameters.push("TUL" + ("00" + i).slice(-2));
			}
			var tuls = this.$APARAM(_)._getParams(_, 1, this.$AFOLDER(_), parameters);
			Object.keys(tuls).forEach(function(tul) {
				if (tuls[tul]) {
					var arTUL = tuls[tul].split(":");
					if (arTUL !== undefined && arTUL.length === 2) {
						var tul = arTUL[0][0];
						values.ADXTUL.push(tul);
						values.ADXTUT0.push(arTUL[0].substring(1));
						values.ADXTUT.push(arTUL[0].substring(1));
						values.ADXTUC0.push(arTUL[1]);
						values.ADXTUC.push(arTUL[1]);
					}
				}
			});
			for (var i = 0; i < values.ADXTUT.length; i++) {
				var j = values.ADXTUL.indexOf(values.ADXTUT[i]);
				if (j >= 0) {
					values.ADXTUC[i] = values.ADXTUC[j];
					values.ADXTUT[i] = values.ADXTUT[j];
				}
			}
			superv.sys = Object.keys(values).reduce(function(r, v) {
				r[v] = [1, variables.types["S"].def, values[v], 0, values[v].length];
				return r;
			}, {});
		}
	}

	ASETATTRPROP(_, property, attribut, value) {
		try {
			return this.setPropertyAttribute(_, property, attribut, value);
		} catch (ex) {
			return constants.CST_AERROR;
		}
	}
};

attributes.addAttributes(ACTX.prototype);

exports.constructor = ACTX;
