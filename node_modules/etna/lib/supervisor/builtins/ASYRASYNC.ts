"use strict";

exports.$exported = true;

const jsRunner = require('syracuse-x3/lib/jsRunner');
const glob = require('streamline/lib/globals');
const tracerJs = require('syracuse-core').getTracer("etna.supervisor");

function exexJs(_: _,  actx, fct, args) {
	const data = {
		"function": fct,
		"mode": "wait",
		"args": args,
		"callbackIndex": 0,
		"returning_code": 0
	};

	return jsRunner.execute(_, "syracuse-sdata/lib/asyncTrack", data).body;
}

exports.ASYNCTRACK = function (_: _,  actx, phase, detail, progress) {
	exexJs(_, actx, "asyncTrack", [phase, detail, progress]);
};

exports.ADDDIAGNOSE = function (_: _,  actx, message, severity) {
	switch (severity) {
		case 0:
		case 1:
			severity = "success";
			break;
		case 2:
			severity = "info";
			break;
		default:
			severity = "error";
			break;
	}
	exexJs(_, actx, "addDiagnose", [severity, message]);
};

exports.ABORTREQUESTED = function (_: _,  actx) {
	const res = exexJs(_, actx, "abortRequested");

	return res == "true" ? 1 : 0;
};

exports.ADDLINKDOWNLOAD = function (_: _,  actx, type, filename) {
	const superv = glob.context.x3frame.context.superv;
	const typepro = superv.load(_, 'Typepro', type);
	const link = {
		$title: "Download",
		$filename: filename,
		$type: typepro ? typepro.data.PROTYP : ""
	};
	const match = filename.match(/\[(\w+)\]\/(.*)/);

	if (match) {
		var keys = ["C_AVOLFIL", "CONTENTS", match[1], match[2]];
		link.$url = superv.baseUrl + "/BDOC('" + keys.join("~%C2%A8~") + "')";
		exexJs(_, actx, "addLink", ["$download", link]);
	}
};