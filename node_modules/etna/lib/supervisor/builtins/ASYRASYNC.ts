import { _ } from 'streamline-runtime';
import * as core from 'syracuse-core';
import * as runtimeUtil from '../../engine/runtime/util';
import { TypePro } from '../meta/types';
import { ACTX } from './ACTX';
export const $exported = true;
const jsRunner = require('syracuse-x3/lib/jsRunner');
const tracerJs = core.getTracer("etna.supervisor");

function exexJs(_: _,  actx: ACTX, fct: string, args?: any[]) {
	const data = {
		"function": fct,
		"mode": "wait",
		"args": args,
		"callbackIndex": 0,
		"returning_code": 0
	};

	return jsRunner.execute(_, "syracuse-sdata/lib/asyncTrack", data).body;
}

exports.ASYNCTRACK = function (_: _,  actx: ACTX, phase: string, detail: string, progress: string) {
	exexJs(_, actx, "asyncTrack", [phase, detail, progress]);
};

exports.ADDDIAGNOSE = function (_: _,  actx: ACTX, message: string, severity: number) {
	var sev: string;
	switch (severity) {
		case 0:
		case 1:
			sev = "success";
			break;
		case 2:
			sev = "info";
			break;
		default:
			sev = "error";
			break;
	}
	exexJs(_, actx, "addDiagnose", [sev, message]);
};

exports.ABORTREQUESTED = function (_: _,  actx: ACTX) {
	const res = exexJs(_, actx, "abortRequested");

	return res == "true" ? 1 : 0;
};

export interface Link {
	$title: string;
	$filename: string;
	$type: string;
	$url?: string;
}

exports.ADDLINKDOWNLOAD = function (_: _,  actx: ACTX, type: string, filename: string) {
	const superv = runtimeUtil.currentContext().x3frame.context.superv;
	const typepro = superv.load<TypePro>(_, 'Typepro', type);
	const link: Link = {
		$title: "Download",
		$filename: filename,
		$type: typepro ? typepro.data.PROTYP : ""
	};
	const match = filename.match(/\[(\w+)\]\/(.*)/);

	if (match) {
		var keys = ["C_AVOLFIL", "CONTENTS", match[1], match[2]];
		link.$url = superv.baseUrl + "/BDOC('" + keys.join("~%C2%A8~") + "')";
		exexJs(_, actx, "addLink", ["$download", link]);
	}
};