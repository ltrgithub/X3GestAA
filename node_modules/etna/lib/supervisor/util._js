"use strict";

const glob = require('streamline/lib/globals');
const helpers = require('syracuse-core').helpers;
const constants = require("etna/lib/supervisor/constants");
const attributes = require("etna/lib/supervisor/attributes");
const snapshots = require("etna/lib/supervisor/snapshots");
const forEachKey = helpers.object.forEachKey;
const runtime = require('etna/lib/engine/runtime/runtime');
const ez = require("ez-streams");
const bcd = require('etna/lib/engine/runtime/bcd');
const db = require('etna/lib/engine/runtime/db');
const tracerJs = require('syracuse-core').getTracer("etna.supervisor");
const tracerEvents = require('syracuse-core').getTracer("etna.events");
const util = exports;

class Helper {
	constructor() {}

	getActionArgs(_, type, action, key, member) {
		var args = {
			THIS: {
				type: "LY",
				value: this
			},
			ASTATUS: {
				type: "LI",
				value: 0
			},
			CURPRO: {
				type: "LS",
				value: member && member.name || ""
			},
			CURPTH: {
				type: "LS",
				value: member && member.name || ""
			},
			member: member,
			path: member && member.jsName ? [member.jsName] : []
		};
		args[type] = {
			type: "LS",
			value: action
		};
		if (key) {
			var index = this.index;

			args = Object.keys(index).reduce_(_, (_, args, i) => {
				const name = index[i].name.split(' ')[0];

				if (!Array.isArray(key)) key = key.split("~");
				args[name] = {
					type: index[i].etnaType,
					value: key[i]
				};
				//dbg:console.error(name+":",args[name]);
				return args;
			}, args);
		}
		return args;
	}

	_action(_, action, frame) {
		tracerEvents.debug && tracerEvents.debug("action:" + action);
		return this.runScripts(_, "$EVENTS", this.getActionArgs(_, "AEVENT", action), frame);
	}
		
	jsDispatch(_, handler, args, _frame) {
		//console.error("JSDISPATCH", handler, "ARGS", Object.keys(args));
		this.class.jsModules.forEach_(_, (_, def) => {
			return require('../x3js/js-invoke')(_, def, handler.substring(1).toLowerCase(), args, _frame);
			/*
			switch (handler) {
				case '$PROPERTIES':
					return this.jsPropertyEvent(_, def, args);
				case '$EVENTS':
					return this.jsInstanceEvent(_, def, args);
				default:
					throw new Error("bad script handler: " + handler);
			}*/		
		});
	}
	
	runScripts(_, handler, args, _frame) {
		if (this.class.jsModules && this.class.jsModules.length > 0) return this.jsDispatch(_, handler, args, _frame);
		var astatus = constants.CST_AOK;
		const scripts = this.scripts(_);
		//tracerJs.debug && tracerJs.debug("runScripts:"+handler);

		if (!scripts) return astatus;

		scripts.forEach_(_, (_, script) => {
			// Doesn't execute the next script if status !== CST_AOK
			if (astatus > constants.CST_AOK) return;

			//tracerJs.debug && tracerJs.debug("invoke ");
			try {
				if (script.body.$isBuiltin) {
					try {
						//  Save the current context and create a new one:
						var frame = glob.context.x3frame;
						var prev = frame;
						var cx = prev.context;

						var sl = prev ? prev.stackLevel + 1 : 0;

						glob.context.x3frame = frame = {
							values: {},
							types: {},
							context: cx,
							prev: prev,
							loopLevel: 0,
							stackLevel: sl,
							name: script.name,
							loc: {
								file: script.name,
								line: 0
							}
						};
						// current sub is the prog itself
						frame.sub = frame;
						frame.dicts = [frame, cx.globals, cx.sys];
						astatus = script.body[handler](_, action, this) || 0;
					} finally {
						// Restore the previous context
						db.closeFiles([], sl);
						glob.context.x3frame = prev;
					}
				} else {
					if (typeof args === 'function') {
						args = args(_);
					}
					if (args.CURPTH && !args.CURPTH.value.length) {
						// FOR AREAD_AFTER !
						args.THIS.value = this;
					}
					var actx = glob.context.x3session.actx;
					if (["$METHODS", "$OPERATIONS"].indexOf(handler) >= 0) {
						var frame = glob.context.x3frame;
						//var prevtableSlots=frame.context.tableSlots;
						var prevtables = frame.context.tables;
						var prevgclass = frame.context.gclass;
						var prevabbrev = frame.abbrev;
						//***
						//frame.context.tableSlots={};
						frame.context.tables = {};
						frame.context.gclass = {};
						frame.abbrev = "";
					}
					actx.$$dbgScriptLevel = (actx.$$dbgScriptLevel || 0) + 1;
					tracerEvents.debug && tracerEvents.debug(new Array(actx.$$dbgScriptLevel).join(' ') + "-> " + script.name + '.' + handler + ' ' + (args.CURPRO !== undefined ? " CURPRO:" + (args.CURPRO.value || "") : "") + (args.CURPTH !== undefined ? " CURPTH:" + (args.CURPTH.value || "") : ""));
					try {
						astatus = runtime.executeProg(_, script, handler, args, _frame);
					} finally {
						tracerEvents.debug && tracerEvents.debug(new Array(actx.$$dbgScriptLevel).join(' ') + "<- " + script.name);
						actx.$$dbgScriptLevel -= 1;
						if (handler === "$METHODS") {
							var frame = glob.context.x3frame;
							//frame.context.tableSlots=prevtableSlots;
							frame.context.tables = prevtables;
							frame.context.gclass = prevgclass;
							frame.abbrev = prevabbrev;
						}
					}
				}
			} catch (e) {
				tracerJs.error && tracerJs.error("exception in util.runScripts(" + handler + "):" + e.message);
				tracerJs.error && tracerJs.error(e.stack);
				this.addDiagnose(_, constants.CST_AERROR, e.message);
				astatus = constants.CST_AERROR;
				throw e;
			}
		});
		return astatus;
	}

	deleteErrors(_, group, property) {
		this.diagnoses = [];
		this.errors = undefined;
	}

	toJSON() {
		if (super.toJSON) return super.toJSON();
		throw new Error("cannot serialize " + constructor);
	}
};

exports.Helper = Helper;

class HttpError extends Error {
	constructor(statusCode, message) {
		super(message);
		this.statusCode = statusCode;
	}
};

exports.HttpError = HttpError;

exports.find = function (arr, key, val) {
	for (var i = 0, len = arr.length; i < len; i++) {
		var elt = arr[i];
		if (elt[key] === val) return elt;
	}
	return null;
};

exports.declVar = function (dict, name, type, value) {
	dict.values[name] = value;
	dict.types[name] = type;
};

exports.uuid = helpers.uuid.generate;

exports.clone = function clone(obj, shallow) {
	return Object.keys(obj).reduce((r, name) => {
		var v = obj[name];
		if (v && typeof v === "object") {
			if (Array.isArray(v)) {
				v = v.slice(0);
				if (!shallow) v = v.map(clone);
			} else {
				v = clone(v);
			}
		}
		r[name] = v;
		return r;
	}, {});
};

exports.isInstance = function (instance) {
	return !!(instance && instance.class && instance.slots);
};

exports.isCollection = function (instance) {
	return !!(instance && instance.collection && Array.isArray(instance.lines));
};

exports.path = function (instance, name) {
	if (instance.APARENT) return util.path(instance.APARENT, instance.proName + '.' + name);
	else return name;
};

exports.checkInstance = function (instance) {
	if (!exports.isInstance(instance)) throw new Error("value is not an instance");
};

exports.emptyArray = function (base, def) {
	// array layout is [ndims, def, data, base1, size1, base2, size2, ...
	// variable arrays impose ndims = 1
	return [1, def === undefined ? def : null, [], base === undefined ? 1 : base, 32767];
};

//escape :
//$ by \u007F

exports.escapeArray = function (input) {
	return input.map(item => {
		switch (typeof item) {
			case "object":
				return exports.escapeJson(item);
			case "string":
				return item[0] === "$" ? "_" + item.substring(1) : item;
			default:
				return item;
		}
	});
};

exports.escapeJson = function (input) {
	// must clone as original object might be used later unescaped
	if (Array.isArray(input)) return exports.escapeArray(input);
	//
	const out = {};

	forEachKey(input, function (key, value) {
		var escKey = key;
		var escVal = value;
		if (value !== null) {
			if (Array.isArray(value)) {
				escVal = exports.escapeArray(value);
			} else if (typeof value === "object") escVal = exports.escapeJson(value);

			if (key[0] === "$") {
				escKey = "_" + key.substring(1);
				//			escKey = "Ã©"+key.substring(1);
			}
		}
		out[escKey] = escVal;
	});
	//
	return out;
};
//unescape :
// _ by $

exports.unescapeJson = function (input) {
	forEachKey(input, function (key, value) {
		var escKey = key;
		var escVal = value;
		if (Array.isArray(value)) {
			escVal = [];
			value.forEach(item => {
				if (typeof item === "object") escVal.push(exports.unescapeJson(item));
				else if (typeof item === "string") escVal.push(item[0] === "_" ? "$" + item.substring(1) : item);
				else escVal.push(item);
			});
		} else if (typeof value === "object") escVal = exports.unescapeJson(value);

		if (key[0] === "_") {
			escKey = "$" + key.substring(1);
			delete input[key];
		}

		input[escKey] = escVal;
	});
	//	console.log("unescaped json: "+sys.inspect(input,null,4));
	return input;
};

exports.checkDataProperty = function (data, property) {
	if (data[property] && typeof data[property] === 'string') {
		data[property] = !isNaN(data[property]) && bcd.toDouble(bcd.fromString(data[property])) > 0 ? bcd.toDouble(bcd.fromString(data[property])) : undefined;
	}
};

exports.decodeValueMongoString = function (s) {
	return s.replace(new RegExp(String.fromCharCode(255), 'g'), ',');
};

exports.traceException = function (e) {
	tracerJs.error && tracerJs.error(e.message);
	tracerJs.error && tracerJs.error(e.stack);
};

exports.inverseMap = map => Object.keys(map).reduce((r, k) => {
	r[map[k]] = k;
	return r;
}, {});

exports.camelToKebab = function (str, sep) {
	sep = sep || '-';
	const s = str.replace(/[A-Z]/g, ch => sep + ch.toLowerCase());
	return s[0] === sep ? s.substring(1) : s;
};

exports.kebabify = function (str) {
	return exports.camelToKebab(exports.camelize(str));
};

exports.pascalize = function (str) {
	// if all upper, lowercase it first otherwise keep it (if it is camel)
	if (str === str.toUpperCase()) str = str.toLowerCase();
	return str[0].toUpperCase() + str.substring(1);
};

exports.camelize = function (name, capitalize) {
	name = name.split('(')[0]; // discard parenthesized part
	if (!/^[a-zA-Z]/.test(name)) name = 'todo' + name; // make sure result is camel
	return name.split(/[\W]/).map((s, i) => {
		if (i === 0 && !capitalize) return s[0].toLowerCase() + (/[a-z]/.test(s) ? s.substring(1) : s.substring(1).toLowerCase());
		else if (s) return s[0].toUpperCase() + (/[a-z]/.test(s) ? s.substring(1) : s.substring(1).toLowerCase());
		else return '';
	}).join('');
};

// smart variant of toUpperCase
exports.upcase = function (str, sep) {
	sep = sep || '_';
	const s = exports.camelize(str).replace(/[A-Z]/g, ch => sep + ch);
	return (s[0] === sep ? s.substring(1) : s).toUpperCase();
};

exports.debug = function (message, x) {
	console.error(message, x);
	return x;
};