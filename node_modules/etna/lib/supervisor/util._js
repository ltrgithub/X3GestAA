"use strict";

var glob = require('streamline/lib/globals');
var helpers = require('syracuse-core').helpers;
var constants = require("etna/lib/supervisor/constants");
var attributes = require("etna/lib/supervisor/attributes");
var snapshots = require("etna/lib/supervisor/snapshots");
var forEachKey = helpers.object.forEachKey;
var runtime = require('etna/lib/engine/runtime/runtime');
var ez = require("ez-streams");
var bcd = require('etna/lib/engine/runtime/bcd');
var constants = require("etna/lib/supervisor/constants");
var db = require('etna/lib/engine/runtime/db');

var tracerJs = require('syracuse-core').getTracer("etna.supervisor");
var tracerEvents = require('syracuse-core').getTracer("etna.events");
const util = exports;

exports.defineClass = function(constructor, parent, members, options) {

	members.getActionArgs = function(_, type, action, key, member) {
		var args = {
			THIS: {
				type: "LY",
				value: this
			},
			ASTATUS: {
				type: "LI",
				value: 0
			},
			CURPRO: {
				type: "LS",
				value: (member && member.name) || ""
			},
			CURPTH: {
				type: "LS",
				value: (member && member.name) || ""
			},
			path: (member && member.jsName) ? [member.jsName] : [],
		};
		args[type] = {
			type: "LS",
			value: action
		};
		if (key) {
			var self = this;
			var index = this.index;

			args = Object.keys(index).reduce_(_, function(_, args, i) {
				var name = index[i].name.split(' ')[0];
				if (!Array.isArray(key)) key = key.split("~");
				args[name] = {
					type: index[i].etnaType,
					value: key[i]
				};
				//dbg:console.error(name+":",args[name]);
				return args;
			}, args);

		}
		return args;
	};

	members._action = function(_, action, frame) {
		tracerEvents.debug && tracerEvents.debug("action:" + action);
		return this.runScripts(_, "$EVENTS", this.getActionArgs(_, "AEVENT", action), frame);
	};


	members.runScripts = function(_, handler, args, _frame) {
		var self = this;
		var astatus = constants.CST_AOK;
		var scripts = self.scripts(_);
		//tracerJs.debug && tracerJs.debug("runScripts:"+handler);

		if (!scripts) return astatus;

		scripts.forEach_(_, function(_, script) {
			// Doesn't execute the next script if status !== CST_AOK
			if (astatus > constants.CST_AOK) return;

			//tracerJs.debug && tracerJs.debug("invoke ");
			try {
				if (script.body.$isBuiltin) {
					try {
						//  Save the current context and create a new one:
						var frame = glob.context.x3frame;
						var prev = frame;
						var cx = prev.context;

						var sl = (prev) ? prev.stackLevel + 1 : 0;

						glob.context.x3frame = frame = {
							values: {},
							types: {},
							context: cx,
							prev: prev,
							loopLevel: 0,
							stackLevel: sl,
							name: script.name,
							loc: {
								file: script.name,
								line: 0
							}
						};
						// current sub is the prog itself
						frame.sub = frame;
						frame.dicts = [frame, cx.globals, cx.sys];
						astatus = script.body[handler](_, action, self) || 0;

					} finally {
						// Restore the previous context
						db.closeFiles([], sl);
						glob.context.x3frame = prev;
					}
				} else {
					if (typeof args === 'function') {
						args = args(_);
					}
					if (args.CURPTH && !args.CURPTH.value.length) { // FOR AREAD_AFTER !
						args.THIS.value = self;
					}
					var actx = glob.context.x3session.actx;
					if (["$METHODS","$OPERATIONS"].indexOf(handler)>=0) {
						var frame = glob.context.x3frame;
						//var prevtableSlots=frame.context.tableSlots;
						var prevtables = frame.context.tables;
						var prevgclass = frame.context.gclass;
						var prevabbrev = frame.abbrev;
						//***
						//frame.context.tableSlots={};
						frame.context.tables = {};
						frame.context.gclass = {};
						frame.abbrev = "";
					}
					actx.$$dbgScriptLevel = (actx.$$dbgScriptLevel || 0) + 1;
					tracerEvents.debug && tracerEvents.debug(new Array(actx.$$dbgScriptLevel).join(' ') + "-> " + script.name +'.'+handler+' '+ (args.CURPRO !== undefined ? (" CURPRO:" + (args.CURPRO.value || "")) : "") + (args.CURPTH !== undefined ? (" CURPTH:" + (args.CURPTH.value || "")) : ""));
					try {
						astatus = runtime.executeProg(_, script, handler, args, _frame);
					} finally {
						tracerEvents.debug && tracerEvents.debug(new Array(actx.$$dbgScriptLevel).join(' ') + "<- " + script.name);
						actx.$$dbgScriptLevel -= 1;
						if (handler === "$METHODS") {
							var frame = glob.context.x3frame;
							//frame.context.tableSlots=prevtableSlots;
							frame.context.tables = prevtables;
							frame.context.gclass = prevgclass;
							frame.abbrev = prevabbrev;
						}
					}
				}
			} catch (e) {
				tracerJs.error && tracerJs.error("exception in util.runScripts("+handler+"):" + e.message);
				tracerJs.error && tracerJs.error(e.stack);
				self.addDiagnose(_, constants.CST_AERROR, e.message);
				astatus = constants.CST_AERROR;
				throw e;
			}
		}, self);
		return astatus;
	};

	members.deleteErrors = function(_, group, property) {
		this.diagnoses = [];
		this.errors = undefined;
	};



	var construct = helpers.defineClass(constructor, parent, members);
	if (options) {
		if (options.hasAttributes) {
			attributes.addAttributes(construct.prototype);
		}
		if (options.hasSnapshots) {
			snapshots.addSnapshots(construct.prototype);
		}

	}
	construct.prototype.toJSON = construct.prototype.toJSON || function() {
		throw new Error("cannot serialize " + constructor);
	};
	return construct;
};

exports.HttpError = helpers.defineClass(function(statusCode, message) {
	var err = new Error(message);
	err.statusCode = statusCode;
	return err;
}, Error, {});

exports.find = function(arr, key, val) {
	for (var i = 0, len = arr.length; i < len; i++) {
		var elt = arr[i];
		if (elt[key] === val) return elt;
	}
	return null;
};

exports.declVar = function(dict, name, type, value) {
	dict.values[name] = value;
	dict.types[name] = type;
};

exports.uuid = helpers.uuid.generate;

exports.clone = function clone(obj, shallow) {
	return Object.keys(obj).reduce(function(r, name) {
		var v = obj[name];
		if (v && typeof v === "object") {
			if (Array.isArray(v)) {
				v = v.slice(0);
				if (!shallow) v = v.map(clone);
			} else {
				v = clone(v);
			}
		}
		r[name] = v;
		return r;
	}, {});
};

exports.isInstance = function(instance) {
	return !!(instance.class && instance.slots);
};

exports.isCollection = function(instance) {
	return !!(instance.collection && Array.isArray(instance.lines));
};

exports.path = function(instance, name) {
	if (instance.APARENT) return util.path(instance.APARENT, instance.proName + '.' + name);
	else return name;
}

exports.checkInstance = function(instance) {
	if (!exports.isInstance(instance)) throw new Error("value is not an instance");
};

exports.emptyArray = function(base, def) {
	// array layout is [ndims, def, data, base1, size1, base2, size2, ...
	// variable arrays impose ndims = 1
	return [1, def === undefined ? def : null, [], base === undefined ? 1 : base, 32767];
};

//escape :
//$ by \u007F

exports.escapeArray = function(input) {
	return input.map(function(item) {
		switch (typeof item) {
			case "object":
				return exports.escapeJson(item);
			case "string":
				return (item[0] === "$") ? ("_" + item.substring(1)) : item;
			default:
				return item;
		}
	});
};

exports.escapeJson = function(input) {
	// must clone as original object might be used later unescaped
	if (Array.isArray(input)) return exports.escapeArray(input);
	//
	var out = {};
	forEachKey(input, function(key, value) {
		var escKey = key;
		var escVal = value;
		if (value !== null) {
			if (Array.isArray(value)) {
				escVal = exports.escapeArray(value);
			} else if (typeof value === "object") escVal = exports.escapeJson(value);

			if (key[0] === "$") {
				escKey = "_" + key.substring(1);
				//			escKey = "Ã©"+key.substring(1);
			}

		}
		out[escKey] = escVal;
	});
	//
	return out;
};
//unescape :
// _ by $

exports.unescapeJson = function(input) {
	forEachKey(input, function(key, value) {
		var escKey = key;
		var escVal = value;
		if (Array.isArray(value)) {
			escVal = [];
			value.forEach(function(item) {
				if (typeof item === "object") escVal.push(exports.unescapeJson(item));
				else if (typeof item === "string") escVal.push((item[0] === "_") ? ("$" + item.substring(1)) : item);
				else escVal.push(item);
			});
		} else if (typeof value === "object") escVal = exports.unescapeJson(value);

		if (key[0] === "_") {
			escKey = "$" + key.substring(1);
			delete input[key];
		}

		input[escKey] = escVal;
	});
	//	console.log("unescaped json: "+sys.inspect(input,null,4));
	return input;
};



exports.checkDataProperty = function(data, property) {
	if (data[property] && typeof data[property] === 'string') {
		data[property] = (!isNaN(data[property]) && bcd.toDouble(bcd.fromString(data[property])) > 0) ? bcd.toDouble(bcd.fromString(data[property])) : undefined;
	}
};

exports.decodeValueMongoString = function(s) {
	return s.replace(new RegExp(String.fromCharCode(255),'g'),',');
}

exports.traceException= function(e) {
	tracerJs.error && tracerJs.error(e.message);
	tracerJs.error && tracerJs.error(e.stack);
}

// Temporary hack to map codes to JS names
const jsMappings = require('etna/lib/x3js/name-mappings.json'); 
exports.fixJsName = function(s1, s2, def) {
	if (s2) return (jsMappings[s1] && jsMappings[s1][1] && jsMappings[s1][1][s2]) || def;
	else return (jsMappings[s1] && jsMappings[s1][0]) || def;
}
