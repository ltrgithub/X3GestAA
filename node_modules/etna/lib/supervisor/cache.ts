import { _ } from 'streamline-runtime';
import * as ez from 'ez-streams';
import { Instance } from './meta/instance';
import { Property } from './meta/property';

const tracerJs = require('syracuse-core').getTracer("etna.supervisor");

interface TextEntry {
	$name?: string;
	$ids?: any;
	ids?: number[];
	texts?: string[];
	register?: any;
}

export class Cache {
	texts: { [name: string]: TextEntry; };
	references: { [name: string]: TextEntry; };
	_isActivated: boolean;
	max: number;
	instanceset: Instance[];
	
	constructor() {
		//dbg:console.log("new cache");
		//dbg:var e = new Error("new");
		//dbg:console.error(e.stack);

		this.texts = {};
		this.references = {};
		this._isActivated = false;
		this.max = 100;
		this.instanceset = [];
	}

	get isActivated() {
		return this._isActivated;
	}

	clone() {
		const from = this;
		const to = new Cache();

		Object.keys(from.texts).forEach(p => {
			to._isActivated = true;
			to.texts[p] = {
				ids: [],
				texts: null,
				register: from.texts[p].register
			};
		});
		Object.keys(from.references).forEach(p => {
			to._isActivated = true;
			to.references[p] = {
				ids: [],
				texts: null,
				register: from.references[p].register
			};
		});
		return to;
	}

	addProperty(_: _,  property: Property) {
		//dbg:console.log("cache.addProperty "+property.name);
		//dbg:var e = new Error("property");
		//dbg:console.error(e.stack);
		this._isActivated = true;
		this.texts[property.name] = {
			ids: [],
			texts: null,
			register(_: _,  instance: Instance) {
				const textId = property.getAtextraKey(_, instance);
				//dbg:console.error("=> register property:"+property.name+" textId:"+textId);

				instance.cache.texts[property.name].ids.push(textId);
				return instance;
			},
		};
		//dbg:console.log("cache.addProperty =>"+Object.keys(this.texts));
	}

	addReference(_: _,  property: Property) {
		//dbg:console.log("cache.addReference "+property.name);
		//dbg:var e = new Error("reference");
		//dbg:console.error(e.stack);
		this._isActivated = true;
		const getReferenceKey = property.makeGetReferenceKey(_);
		this.references[property.name] = {
			$name: property.name,
			$ids: {},
			register(_: _,  instance: Instance) {
				//dbg:console.error("=> register reference:"+property.name);
				const id = getReferenceKey(_, instance);

				if (id) instance.cache.references[property.name].$ids[id] = null;
				return instance;
			},
		};
		//dbg:console.log("cache.addReference =>"+Object.keys(this.references));
	}

	register(_: _,  instance: Instance) {
		//dbg:console.error("register texts:"+Object.keys(this.texts));

		instance.cache = this;
		Object.keys(this.texts).forEach_(_, (_, property) => {
			if (instance.properties[property]) {
				this.texts[property].register(_, instance);
			}
		});
		//dbg:console.error("register references:"+Object.keys(this.references));
		Object.keys(this.references).forEach_(_, (_, property) => {
			if (instance.properties[property]) this.references[property].register(_, instance);
		});
		this.instanceset.push(instance);
	}

	clean() {
		this.instanceset = [];
	}

	get isFull() {
		return this.instanceset.length > this.max;
	}

	transform() {
		// Cache records in order to improve the performance of the cache of
		// texts and references :
		const cache = this;

		cache.clean();

		function flush(_: _,  _writer: ez.Writer<Instance>) {
			cache.instanceset.forEach_(_, (_, instance) => {
				_writer.write(_, instance);
			});
			cache.clean();
		}

		return function (_: _,  _reader: ez.Reader<Instance>, _writer: ez.Writer<Instance>) {
			var instance: Instance;
			while ((instance = _reader.read(_)) !== undefined) {
				cache.register(_, instance);
				cache.isFull && flush(_, _writer);
			}
			flush(_, _writer);
		};
	}
};

;