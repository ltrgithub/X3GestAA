"use strict";
var attributes = require("etna/lib/supervisor/attributes");
var X3Error = require("etna/lib/engine/runtime/errors").X3Error;
var constants = require("etna/lib/supervisor/constants");

var helpers = require('syracuse-core').helpers;
var tracerJs = require('syracuse-core').getTracer("etna.supervisor");


class SlotReference {
	constructor(parent, property) {
		// care of the name if and only if the property belongs to 
		// an instance which which belongs to a collection : 
		if (property.type) {
			this.property = property;
		} else {
			this.property = {
				name: ""
			};
		}
		this.referenceName = property.name;
		this.reference = null;
		this._value = null;
		this.bindAttributes(parent);
	}

	get name(){
		return this.property.name;
	}
	get column() {
		return;
	}


	get value() {
		return this._value || {};
	}

	set value(value) {
		throw new X3Error(147, (this.name ? this.name : '') + "is readonly");
	}
	
	targetClass(_) {
		if(!this._targetClass) {
			var type = this.$parent.supervisor.load(_, 'Type', this.property.data.CODTYP).init(_);
			this._targetClass = type.targetClass(_)
		}
		return this._targetClass;
	}

	_get(_) {
		var reference = this.$parent._get(_, this.referenceName);
		if (reference != this.reference) {
			// Load reference's attributes:
			this._value = this.$parent.properties[this.name].loadReference(_, this.$parent);

			if (!this._value) this._value = {
				"$title": ""
			};
			else if (!this._value.$title) this._value.$title = "";

			if (this._value) {
				var _this = this;
				Object.keys(_this._value).forEach_(_, function(_, attribute) {
					var value = _this._value[attribute];
					if (/^\$(description|title|symbol)$/.test(attribute))
						_this.$attributes.setResource(_, attribute, value);
					else
						_this.setAttribute(attribute, value);
				});
			}
		}
		return this._value || {};
	}

	_set(_, value, raw) {
		//dbg:console.log("SlotReference set:",value);
		var keyParams = this.property.keyParams;
		var refKeys = Object.keys(value).filter(function(key) {
			return key[0] !== '$';
		});
		for (var i = 0; i < keyParams.length; i++) {
			//dbg:console.error("SlotReference set parent."+keyParams[i].FLDCLA+" with:"+value[refKeys[i]]);
			this.$parent.set(_, keyParams[i].FLDCLA, value[refKeys[i]]);
		}

	}

	fromRecord(_, record, colnIndex) {}
	toRecord(record) {}
	clone(parent) {}
	revertTo() {}
	deleteDiagnoses(_) {}
	controlOthers(_) {
		//dbg:console.error("SlotReference.controlOthers:"+this.property.name);
		// Get the class of the referenced type :
		var cl = this.targetClass(_);

		// look for the root parent
		var parent = this;
		while (parent=parent.$parent) {
			if(!parent.$parent) {
				if(parent.meta.name === cl.name) return constants.CST_AOK; // No circular controls:
				break;
			}
		}

		var instance = this.$parent;
		var keyMaps = this.property.keyMaps(_);
		var refKey = Object.keys(keyMaps).map_(_, function(_, key) {
			return keyMaps[key](_, instance);
		}).join('~');
		if(!refKey) return constants.CST_AOK;// the key is undefined

		//dbg:console.error("SlotReference.controlOthers refKey:'"+refKey+"'");
		var ref = cl.createInstance(_);
		// Try to read the reference :
		var status = ref.read(_, refKey,{crud: false});
		//dbg:console.error("SlotReference.controlOthers status:"+status);
		if(status === constants.CST_AERROR) {
			tracerJs.error && tracerJs.error("Reference "+cl.name+"('"+refKey+"') not found");
		}
		return status;
	}
};

attributes.addAttributes(SlotReference.prototype);
exports.SlotReference = SlotReference;
exports.newSlotReference = function(propery) {
	return function(_, parent) {
		return new SlotReference(parent, propery);
	};
};