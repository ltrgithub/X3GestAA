import { _ } from 'streamline-runtime';
import { X3Error } from '../engine/runtime/errors';
import * as types from '../engine/runtime/types';
import * as attributes from '../supervisor/attributes';
import * as snapshots from '../supervisor/snapshots';
import * as variables from '../engine/runtime/variables';
import * as tuuid from '../engine/runtime/tuuid';
const tracerJs = require('syracuse-core').getTracer("etna.supervisor");
import * as util from '../supervisor/util';
import * as mapping from '../supervisor/mapping';
import * as constants from '../supervisor/constants';
import { Cache } from '../supervisor/cache';
import { Diagnosis, trace as diagTrace } from '../supervisor/meta/diagnosis';
import { Property } from './meta/property';
import { Collection } from './meta/collection';
import { Class } from './meta/class';
import { Instance } from './meta/instance';
import { Supervisor } from './supervisor';

export class SlotCollection {
	supervisor: Supervisor;
	collection: Collection;
	lines: Instance[];
	proName: string;
	proJsName: string;
	$uuid: Buffer;
	$snapshot: SlotCollection;
	$lazyLoading: boolean;
	$parent: any;
	relKeys: any; // refine later
	key: any; // refine later
	$astalin: number;
	snapshotof: SlotCollection;
	diagnoses: Diagnosis[];

	getAttribute: (name: string) => any;
	setAttribute: (name: string, value: any) => void;
	setColAttribute: (column: string, attribute: string, value: any) => void;
	bindAttributes: (parent: any) => void;
	snapshots: () => void;

	constructor(parent: any, collection: Collection) {
		this.supervisor = parent.supervisor;
		this.collection = collection;

		// Empty array
		this.lines = [];
		this.bindAttributes(parent);
		this.proName = "";
		this.$uuid = tuuid.generate();
		const bindOperation = (flag: string, fct: string) => {
			util.any(this)[fct] = !this.collection.mappingData || this.collection.mappingData[flag] === 2 
			? util.any(this)['_' + fct] 
			: (_: _) => constants.CST_AOK;
		}
		bindOperation("FLGD", "delete");
		bindOperation("FLGC", "insert");
		bindOperation("FLGU", "update");
	}

	get $$type() {
		return "SlotCollection";
	}

	get name() {
		return this.collection.name;
	}

	get PROCOL() {
		return this.collection.data.PROCOL;
	}

	get class() {
		return this.collection.class;
	}

	get deletedLines() {
		const snapshot = this.$snapshot;

		return snapshot ? snapshot.lines.filter(line => line.$astalin === constants.CST_ADEL) : [];
	}

	deleteChildren() {
		this.lines = [];
		return this;
	}

	x3Maxtab() {
		return this.lines.length;
	}

	get(_: _) {
		if (this.$lazyLoading) {
			this.lines = Class.cast(this.collection.class)
			.loadInstances(_, this.$parent, mapping.getIndex(_, this.supervisor, this.collection.mappingData), this.relKeys)
			.map((_, instance) => {
				instance.$parent = this;
				instance.APARENT = this.$parent;
				return instance;
			}).toArray(_);
			this.$lazyLoading = false;
		}
		return this;
	}

	// for X3Son :
	set(_: _,  lines: Instance[]) {
		if (lines && Array.isArray(lines) && lines.length && lines[0].class && lines[0].class.name === this.class.name) {
			this.lines = lines;
			for (var i = 0; i < lines.length; i++) {
				this.lines[i].$parent = this;
				this.lines[i].APARENT = this.$parent;
			}
		}
		return this;
	}

	fromRecord(_: _,  record: types.Row) {
		tracerJs.debug && tracerJs.debug("col " + this.name + ".fromRecord:" + JSON.stringify(record));

		if (this.collection.mappingData) {
			this.$lazyLoading = true;
			// Compute the collection keys for the lazy load :
			this.relKeys = mapping.getKeys(_, this.collection.mappingData, record);
		} else {
			// no mapping - denormalized
			var count: number;
			if (this.collection.data.PROCOL) {
				var procol = this.collection.data.PROCOL;
				count = record[procol];
			}
			if (count === undefined) {
				count = Math.max(0, this.collection.count);
			}

			if (!this.collection.class) {
				console.error("ignoring collection " + this.collection.name), [];
				return;
			}

			if (count) {
				var cache = new Cache();

				Object.keys(this.collection.class.properties).forEach_(_, (_, p) => {
					const property = this.collection.class.properties[p];

					if (!/_REF$/.test(p)) {
						if (property.isAtextra) cache.addProperty(_, property);
						else if (property.isReference()) cache.addReference(_, property);
					}
				});

				for (var i = 0; i < count; i++) {
					var line = this.$parent.supervisor.new(_, 'Instance', this.collection.class, this).afterCreate(_, record, i);
					line.$uuid = tuuid.generate(); // Don't reuse the uuid of the parent !
					line.$index = i;
					line.APARENT = this.$parent;
					line.$astalin = 0;
					this.lines[i] = line;
					cache.isActivated && cache.register(_, line);
				}
			}
		}
	}

	crud(_: _,  fname: string, f: (_: _, slot: SlotCollection) => any) {
		var status: number;
		try {
			// The BEFORE is managed by the parent:
			status = this.$parent.action(_, fname + "_BEFORE", null, this.collection);
			if (status === constants.CST_AERROR) return status;

			var line = f(_, this);

			// The AFTER is managed by the line:
			return line.action(_, fname + "_AFTER");
		} catch (e) {
			console.error(e.message);
			status = this.$parent.addDiagnose(_, constants.CST_AERROR, e.message);
			return Math.max(status, this.$parent.action(_, fname + "_ABORT", this.key));
		}
	}

	AINIT(_: _) {
		tracerJs.debug && tracerJs.debug("col " + this.name + " _ainit");
		return constants.CST_AOK;
	}

	newline(_: _) {
		const line = this.$parent.supervisor.new(_, 'Instance', this.class, this).afterCreate(_);
		// Modify the APARENT of the line :
		line.APARENT = this.$parent;
		line.AINIT(_);

		// Update properties defined by the parent :
		this.collection.mappingData && this.collection.mappingData.MAPS
		.filter(map => !!map.PROMAP)
		.forEach_(_, (_, map) => {
			line.set(_, map.KEYMAP, this.$parent.get(_, map.PROMAP));
		});

		// init
		line.$astalin = constants.CST_ANEW;
		return line;
	}

	setASTALIN(status: number) {
		this.$astalin = constants.CST_AUPD;
		this.$parent.setASTALIN(this.$astalin);
	}

	add(_: _,  position: number, uuid?: string) {
		tracerJs.debug && tracerJs.debug("col " + this.name + " add:" + position);

		this.$lazyLoading && this.get(_);
		if (this.getAttribute("$isReadOnly") || this.collection.data.MAXCOL && this.lines.length === this.collection.data.MAXCOL) return -1;

		// Let's take snaps of the collection if necessary :
		this.snapshots();

		var insertedAt = 1;
		// Controled by the parent :
		this.crud(_, 'ADDLINE', (_, col) => {
			const line = col.newline(_);

			if (uuid !== undefined) line.$uuid = uuid;

			if (position === variables.constants.CST_AFIRSTPOS) {
				col.lines.unshift(line);
			} else if (position === variables.constants.CST_ALASTPOS) {
				col.lines.push(line);
				insertedAt = col.lines.length;
			} else {
				// Insert the line in the collection
				col.lines.splice(position - 1, 0, line);
				insertedAt = position;
			}
			col.setASTALIN(constants.CST_AUPD);
			return line;
		});
		return insertedAt;
	}

	del(_: _,  position: number) {
		tracerJs.debug && tracerJs.debug("col " + this.name + " del:" + position);

		this.$lazyLoading && this.get(_);

		if (this.getAttribute("$isReadOnly") || !this.lines.length || position !== -1 && (position < 1 || position > this.lines.length)) {
			tracerJs.error && tracerJs.error("SlotCollection " + this.name + " del refused");
			return -1;
		}

		const deleteAt = (position === constants.CST_ALASTPOS ? this.lines.length : position) - 1;
		const deletedLine = this.lines[deleteAt];

		deletedLine.activeLoading && deletedLine.activeLoading(_);

		// Let's take snaps of the collection if necessary :
		this.snapshots();

		// Controled by the parent :
		var deletedAt = -1;
		this.crud(_, 'ADELLINE', (_, col) => {
			deletedAt = deleteAt;
			// Mark the line as deleted : 
			col.lines[deletedAt].$astalin = constants.CST_ADEL;
			// Remove the line :
			col.lines = col.lines.slice(0, deletedAt).concat(col.lines.slice(deletedAt + 1));
			col.setASTALIN(constants.CST_AUPD);
			return deletedLine;
		});
		return deletedAt;
	}
	empty(_: _) {
		for (var i = 1, max = this.x3Maxtab(); i <= max; i++) {
			this.del(_, constants.CST_ALASTPOS);
		}
	}

	index(_: _,  position: number) {
		// MINCOL=2 : At least one line:
		if (position > this.lines.length && !(position == 1 && !this.lines.length && this.collection.data.MINCOL === 2)) {
			throw new X3Error(8, "collection index out of range: " + position);
		}
		var line = this.lines[position - 1];
		if (!line) {
			// Create an empty line
			line = this.newline(_);
			this.lines[position - 1] = line;
		}
		return line;
	}

	find(key: any, val: any) {
		for (var i = 0, len = this.lines.length; i < len; i++) {
			var line = this.lines[i];
			if (line !== null && util.any(line)[key].x3Compare(val) === 0) {
				return line;
			}
		}
		return null;
	}

	clone() {
		const to = new SlotCollection(this.$parent, this.collection);

		to.lines = this.lines.slice(0);

		attributes.clone(this, to);
		to.snapshotof = this;
		return to;
	}

	revertTo() {
		if (!this.snapshotof) return this;

		const to = this.snapshotof;

		to.lines = [];
		for (var i = 0, len = this.lines.length; i < len; i++) {
			var from = this.lines[i];
			to.lines[i] = from.revertTo();
			to.lines[i].releaseSnapshot(from);
		}
		attributes.revertTo(this, this.snapshotof);
		return to;
	}

	getChildren() {
		return this.lines;
	}

	updateProperty(from: Instance, to: Instance) {
		for (var i = 0, len = this.lines.length; i < len; i++) {
			if (this.lines[i] == from) {
				this.lines[i] = to;
				break;
			}
		}
	}

	setColumnAttribute(column: string, attribute: string, value: any) {
		this.snapshots();
		return this.setColAttribute(column, attribute, value);
	}

	applyToEach(_: _,  f: (_: _, line: Instance, op: string, i: number) => number, operation?: string) {

		var status = constants.CST_AOK;

		const operations: { [id: number]: string; } = {
			2: "insert", //CST_ANEW
			4: "update", //CST_AUPD
			16: "delete" //CST_ADEL
		};

		// applyToEach is to be applied on all lines + deleted lines

		var lines = this.lines.concat(this.deletedLines);

		if (operation === undefined) {
			// Sort the lines (insert/update/delete)
			lines = lines.sort((line1, line2) => line2.$astalin - line1.$astalin);
		}
		// tracerJs.debug && tracerJs.debug("col "+ this.name+ (operation?"."+operation:"")+ "      lines:"+lines.length);

		for (var i = 0, len = lines.length; i < len; i++) {
			var line = lines[i];
			if (line !== null) {
				var op = operation || operations[line.$astalin];
				if (op) {
					tracerJs.debug && tracerJs.debug("col " + this.name + ".apply " + op + " on line " + (i + 1));
					status = f(_, line, op, i + 1);
					if (status === constants.CST_AERROR) return status;
				}
			}
		}
		return status;
	}

	onMapChange(_: _,  property: string, value: any) {
		return this.applyToEach(_, (_, line, operation) => util.any(line)[operation](_, property, value), "onMapChange");
	}

	onControl(_: _,  type: string, operation: string) {
		if (!/^Update$/.test(operation)) return this.applyToEach(_, (_, line, operation) => util.any(line)[type](_, operation), operation);

		// Update:
		return this.applyToEach(_, (_, line, typeOperation) => util.any(line)[type](_, typeOperation.toUpperCase()));
	}

	executeControl(_: _,  type: string) {
		return this.applyToEach(_, (_, line, typeOperation) => util.any(line)[typeOperation](_, type), "executeControl");
	}

	_insert(_: _) {
		return this.applyToEach(_, (_, line, operation) => util.any(line)[operation](_), "insert");
	}

	_update(_: _) {
		return this.applyToEach(_, (_, line, operation) => util.any(line)[operation](_));
	}

	_delete(_: _) {
		return this.applyToEach(_, (_, line, operation) => util.any(line)[operation](_), "delete");
	}

	_activeLoading(_: _) {
		return this.applyToEach(_, (_, line, operation) => util.any(line)[operation] && util.any(line)[operation](_), "activeLoading");
		// weird way of executing only once!
		// anyway: this code was not reached!!!
		//this._activeLoading = undefined;
	}

	addDiagnose(_: _,  severity: number, message: string, category?: string) {
		diagTrace(severity, this.name + " :'" + message + "'");
		this.diagnoses = this.diagnoses || [];
		this.diagnoses.push(this.$parent.supervisor.new(_, 'Diagnosis', severity, message, "", category));
		return severity;
	}

	getDiagnoses(_: _) {
		var res: Diagnosis[] = [];

		this.lines.forEach_(_, (_, line, lineNo) => {
			const lerr = line.getDiagnoses(_);

			res = res.concat(lerr.map_(_, (_, d) => {
				const pro = d.get(_, "PRO");

				d.set(_, "PRO", this.name + '(' + (lineNo + 1) + ')' + (pro !== "" ? '.' + pro : ""));
				return d;
			}));
		});
		return res;
	}

	deleteDiagnoses(_: _) {
		this.lines.forEach_(_, (_, line) => {
			line.deleteDiagnoses(_);
		});
	}

	getDelta(_: _,  snapshot: SlotCollection) {
		var lines = this.lines;
		if (this.deletedLines.length) return lines; // Return the whole collection

		var lineIndex = 0;
		const diffLines = snapshot.lines.reduce((r, line) => {
			const uuid = line.$uuid.x3ToString();
			//dbg:console.error("snapshot line:"+uuid);

			r[uuid] = ++lineIndex;
			return r;
		}, util.any({}));

		lineIndex = 0;

		lines.forEach_(_, (_, line) => {
			const uuid = line.$uuid.x3ToString();

			++lineIndex;
			//dbg:console.error("collection line:"+uuid);
			if (diffLines[uuid] && line.$syssnapshot === undefined) {
				//dbg:console.error("remove "+uuid+" from diffLines");
				delete diffLines[uuid];
			} else {
				//dbg:console.error("keep line "+uuid+" from diffLines");
				var line = this.index(_, lineIndex);
				line.$index = lineIndex - 1;
				diffLines[uuid] = line;
			}
		});

		// The list to send = modified lines
		lines = [];
		Object.keys(diffLines).forEach_(_, (_, uuid) => {
			//dbg:console.error("keep line "+uuid);
			if (typeof diffLines[uuid] !== 'number') {
				lines.push(diffLines[uuid]);
			}
		});
		return lines;
	}

	x3Compare(b: any) {
		return this === b;
	}

	pluck(_: _,  property: string) {
		this.$lazyLoading && this.get(_);
		return this.lines.map_(_, (_, line) => line.get(_, property));
	}

	initFromParent(_: _,  parent: any) {
		const instanceCollection = this;
		if (instanceCollection.PROCOL) {
			var procol = parent.slot(_, instanceCollection.PROCOL);
			if (procol) {
				// Change the get of the PROCOL property so that it automatically returns
				// The number of elements in the associated collection :
				procol.get = function (_: _,  raw: boolean) {
					tracerJs.debug && tracerJs.debug(instanceCollection.PROCOL + ".get " + instanceCollection.proName + ".x3Maxtab()");
					const instance = this.$parent;
					const collection = instance.slot(_, instanceCollection.proName);

					return collection.x3Maxtab();
				};
			}
		}
	}
};

attributes.addAttributes(SlotCollection.prototype);
attributes.addColAttributes(SlotCollection.prototype);
snapshots.addSnapshots(SlotCollection.prototype);
;

export function newSlotCollection(property: Property) { 
	return ((parent: any) => {
		const instanceCollection = new SlotCollection(parent, property.collection);
		instanceCollection.proName = property.name;
		instanceCollection.proJsName = property.jsName;
		return instanceCollection;
	});
}
