"use strict";
var glob = require('streamline/lib/globals');

var X3Error = require("etna/lib/engine/runtime/errors").X3Error;
var format = require('etna/lib/engine/runtime/format');
var util = require('etna/lib/engine/runtime/util');

var constants = require("etna/lib/supervisor/constants");
var attributes = require("etna/lib/supervisor/attributes");
var Diagnosis = require("etna/lib/supervisor/meta/diagnosis");

var tracerSup = require('syracuse-core').getTracer("etna.supervisor");
var helpers = require('syracuse-core').helpers;


var InstanceProperty = exports.InstanceProperty = helpers.defineClass(function(parent, property) {
	// care of the name if and only if the property belongs to 
	// an instance which which belongs to a collection : 
	if (property.type) {
		this.property = property;
		this._value = this.property.type.defaultValue;
	} else {
		this.property = {
			name: ""
		};
		this._value = property;
	}
	this.bindAttributes(parent);
	if (this.property.$x3Format) this.$x3Format = this.property.$x3Format;
}, null, {
	name: {
		get: function() {
			return this.property.name;
		},
		enumerable: false,
	},
	column: {
		get: function() {
			return (this.property.column) ? this.property.column.name : undefined;
		},
		enumerable: false,
	},
	value: {
		set: function(value) {
			if (!this.getAttribute("$isReadOnly")) this._value = value;
			else throw new X3Error(147, (this.name ? this.name : '') + "is readonly");
		},
		get: function() {
			return this._value;
		},
		enumerable: false,
	},
	isUndefined: {
		get: function() {
			return this._value === undefined || (this._value.x3IsUndefined && this._value.x3IsUndefined());
		},
		enumerable: false,
	},
	deleteDiagnoses: function(_) {
		this.diagnoses = undefined;
	},
	isAtextra: {
		get: function() {
			return this.property.isAtextra;
		},
		enumerable: false,
	},
	isText: {
		get: function() {
			return this.property.isText;
		},
		enumerable: false,
	},
	isClob: {
		get: function() {
			return this.property.type.isClob;
		},
		enumerable: false,
	},
	isBlob: {
		get: function() {
			return this.property.type.isBlob;
		},
		enumerable: false,
	},
	isLob: {
		get: function() {
			return this.property.type.isLob;
		},
		enumerable: false,
	},
	getAtextra: function(_, lan) {
		if (this.isAtextra) {
			if (this._atextra && this._atextra[lan]) return this._atextra[lan];

			this._atextra = this._atextra || {};
			return this._atextra[lan] = (lan === glob.context.x3session.actx.$LAN(_)) ?
				this._get(_) : this.property.getAtextra(_, this.$parent, lan);

		}
		return undefined;
	},
	setAtextra: function(_, text, lan) {
		if (this.isAtextra) {
			// Store it for later used (update!)
			this._atextra = this._atextra || {};
			this._atextra[lan] = text;
			if (lan === glob.context.x3session.actx.$LAN(_)) {
				this._set(_, text);
			}
		}
	},
	beforeUpdate: function(_) {
		if (this.isAtextra) this.updateAtextra(_);
		else if (this.isText) this.updateText(_);
	},
	updateAtextra: function(_) {
		this.$wasUpdated && this.property.updateAtextra(_, this.$parent, this._value);
		if (this._atextra) {
			var self = this;
			Object.keys(this._atextra).forEach_(_, function(_, lan) {
				self.property.updateAtextra(_, self.$parent, self._atextra[lan], lan);
			});
			this._atextra = undefined;
		}
	},
	deleteAtextra: function(_) {
		return this.property.deleteAtextra(_, this.$parent);
	},
	updateText: function(_) {
		if (typeof this._value === 'string') {
			this._value = this.$parent.supervisor.findText(_, this._value) || 0;
			//TODO this.$parent.supervisor.addText(_, this._value);
		}
	},
	getDiagnoses: function(_) {
		if (this.diagnoses) {
			var self = this;
			return this.diagnoses.map_(_, function(_, d) {
				d.set(_, "PRO", self.name);
				d.set(_, "LAB", self.getLabel(_));
				return d;
			});
		} else return [];
	},
	addDiagnose: function(_, severity, message, category) {
		Diagnosis.trace(severity, this.name + " :'" + message + "'");
		this.diagnoses = this.diagnoses || [];
		this.diagnoses.push(this.$parent.supervisor.new(_, 'Diagnosis', severity, message, "", category));
		return severity;
	},

	getLabel: function(_) {
		return (this.property.data.INTFLD) ? this.property.supervisor.loadText(_, this.property.data.INTFLD) : "";
	},
	controlFormat: function(_) {
		var isFormatInvalid = false;

		if (this.property.regex) {
			isFormatInvalid = !this.property.regex.test(this._value);
			//dbg:console.log("'"+this._value+"' format:"+this.$x3Format+ " isFormatInvalid:"+isFormatInvalid);
		} else if (this.property.type.data.TYPTYP === 1 && this.property.data.NOLIB) {
			// local menu
			var menu = this.$parent.supervisor.loadEnum(_, this.property.data.NOLIB);
			//isFormatInvalid = menu && menu.length && (this._value < menu[0].$value || this._value > menu[menu.length - 1].$value);
			isFormatInvalid = menu && menu.length && (this._value < 0 || this._value > menu[menu.length - 1].$value);
		}
		if (isFormatInvalid)
			return this.addDiagnose(_, constants.CST_AERROR, this.$parent.supervisor.loadMess(_, 100, 149));

		return constants.CST_AOK;
	},
	controlOthers: function(_) {
		return constants.CST_AOK; // TODO
	},
	_get: function(_, raw) {
		if (this.property && this.property.data) {
			if (this.property.isAtextra && this._value === undefined) {
				this._value = this.property.loadAtextra(_, this.$parent);
				this.$wasRead = true;
			} else if (this.property.isText && typeof this._value !== 'string') {
				// The texte is cached by the supervisor:
				this._value = this.$parent.supervisor.loadText(_, this._value || 0) || "";
			}
		}
		// Call the GET accessor if and only if is set in the dictionary
		if (!raw && this.property.data && this.property.data.FLGACCGET === 2) {
			//  Add a _getCalls member if and only if the GET event has to be supported
			this._getCalls = (this._getCalls || 0) + 1;
			//dbg:console.error("DBG property " + this.name + " GET -> this._getCalls:" + this._getCalls);
			if (this._getCalls === 1) this.$parent.propertyGetValue(_, this);
			this._getCalls -= 1;
		}
		//dbg:console.error("DBG property " + this.name + " GET = " + this._value + " (" + typeof this._value + "):"+this._value);
		return this._value;
	},
	/*
	_get cannot be used for database operations because it returns a string instread of an id
	for text
	*/
	_getSql: function(_) {
		//dbg:console.log("_getSql:"+this.property.name);
		if (this.property.isText) {
			// Insert a number instead of a string in the database !
			return  (typeof this._value === 'string') ? this.$parent.supervisor.findText(_, this._value) : this._value;
		}
		return this._get(_, true);
	},
	_set: function(_, value, raw) {
		//dbg:console.error("property " + this.name + " SET -> (type :"+ this.property.type.etnaType+ "):"+value);

		if (this.getAttribute("$isReadOnly")) {
			throw new X3Error(147, (this.name ? this.name : '') + " is readonly");
		}
		// get the current value
		if (!raw) var oldValue = {
			type: "L" + this.property.type.etnaType,
			value: (this._value !== undefined) ? this._value : this.property.type.defaultValue
		};

		if (value === undefined || value === null) {
			// undefined = RAZ of the property !
			// null = value set by the delta:
			raw = true;
			value = this.property.type.defaultValue;
		} else if (this.isText && typeof value === 'string') {
			// replace the string by a number
			if (value !== this._get(_, true)) {
				// new text
				value = this.$parent.supervisor.findText(_, value) || this.$parent.supervisor.findText(_, this._value);
			}
		} else if (this.isAtextra) {
			this.$wasUpdated = (this.$wasRead && value !== this._value) || true;
		}
		this._value = this.property.set(value);

		if (!raw) {
			// Protect the set from infinite loops:  
			this._setCalls = (this._setCalls || 0) + 1;
			//dbg:console.error(this._setCalls+".property " + this.name + ":"+this._value);
			if (this._setCalls === 1) {
				// Control the new value:
				this.deleteDiagnoses(_);
				var status = this.controlFormat(_);
				//dbg:console.error(this._setCalls+".property controlFormat:" + status);
				if (status !== constants.CST_AERROR) {
					status = this.controlOthers(_);
					//dbg:console.error(this._setCalls+".property controlOthers:" + status);
					if (status !== constants.CST_AERROR) {
						status = this.$parent.propertyControlValue(_, this, oldValue);
						if (status !== constants.CST_AERROR) {
							// Propagate the value : 
							this.propagateValue(_, oldValue);
						}
					}
				}
			}
			//dbg:console.error(this._setCalls+".property " + this.name + "<");
			this._setCalls -= 1;
		}
	},
	fromRecord: function(_, record, colnIndex) {
		//dbg:console.error("InstanceProperty.fromRecord:",record);
		if (this.property.isAtextra) {
			this._value = undefined;
		} else if (this.column) {
			if (record[this.column] !== undefined) {
				if (colnIndex !== undefined) this._value = record[this.column][colnIndex];
				else this._value = record[this.column];
				this._value = this._value ? this.property.type.fromSql(_, this._value) : this.property.type.defaultValue;
			} else {
				this._value = this.property.type.defaultValue;
			}
		} else {
			// interfaces :
			if (record[this.name]) this._value = record[this.name];
		}
	},
	clone: function(parent) {
		var from = this;
		var to = new InstanceProperty(parent, this.property);
		to._value = from._value;
		to.$parent = from.$parent;
		attributes.clone(from, to);
		to.snapshotof = from;
		if (this._atextra) {
			to._atextra = Object.keys(this._atextra).reduce(function(r, lan) {
				r[lan] = from[lan];
				return r;
			}, {});
		}
		//!to._get = this._get;
		// Clone the diagnoses :
		if (this.diagnoses) to.diagnoses = this.diagnoses.slice();
		return to;
	},
	revertTo: function() {
		if (!this.snapshotof) return;
		this.snapshotof._value = this._value;
		attributes.revertTo(this, this.snapshotof);
	},
	propagateValue: function(_, oldValue) {
		//dbg:console.error(this.name + " propagate old:'"+oldValue.value+"' new:'"+this._value+"'");
		// 1. bonds ?
		if (this.property.proMaps) {
			var self = this;
			this.property.proMaps.forEach_(_, function(_, map) {
				var slot = self.$parent.slot(_, map.REFLNK);
				slot && slot.onMapChange(_, map.KEYMAP, self._value);
			});
		}
		// 2. Call scripts :
		//if(this.$parent.propertyPropagateValue && (oldValue.value === undefined || oldValue.value.x3Compare(this._value) !== 0)){
		if (this.$parent.propertyPropagateValue && oldValue.value.x3Compare(this._value) !== 0) {
			this.$parent.propertyPropagateValue(_, this, oldValue);
		}

	},
	setAsMandatory: function(_) {
		this.$isMandatory = true;
		if (this.property.type && this.property.type.data.TYPTYP === 1 && this.property.data.NOLIB) {
			// local menu => set a default value
			var menu = this.$parent.supervisor.loadEnum(_, this.property.data.NOLIB);
			if (menu && menu.length && (this._value < menu[0].$value || this._value > menu[menu.length - 1].$value)) {
				this._value = menu[0].$value;
			}
		}
	}
});

attributes.addAttributes(InstanceProperty.prototype);
exports.InstanceProperty = InstanceProperty;
exports.newInstanceProperty = function(property) {
	return function(_, parent) {
		return new InstanceProperty(parent, property);
	};
};