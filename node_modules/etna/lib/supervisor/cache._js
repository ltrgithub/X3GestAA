"use strict";

const tracerJs = require('syracuse-core').getTracer("etna.supervisor");

class Cache {
	constructor() {
		//dbg:console.log("new cache");
		//dbg:var e = new Error("new");
		//dbg:console.error(e.stack);

		this.texts = {};
		this.references = {};
		this._isActivated = false;
		this.max = 100;
		this.instanceset = [];
	}

	get isActivated() {
		return this._isActivated;
	}

	clone() {
		const from = this;
		const to = new exports.Cache();

		Object.keys(from.texts).forEach(p => {
			to._isActivated = true;
			to.texts[p] = {
				ids: [],
				texts: null,
				register: from.texts[p].register
			};
		});
		Object.keys(from.references).forEach(p => {
			to._isActivated = true;
			to.references[p] = {
				ids: [],
				texts: null,
				register: from.references[p].register
			};
		});
	}

	addProperty(_, property) {
		//dbg:console.log("cache.addProperty "+property.name);
		//dbg:var e = new Error("property");
		//dbg:console.error(e.stack);
		this._isActivated = true;
		this.texts[property.name] = {
			ids: [],
			texts: null,
			register(_, instance) {
				const textId = property.getAtextraKey(_, instance);
				//dbg:console.error("=> register property:"+property.name+" textId:"+textId);

				instance.cache.texts[property.name].ids.push(textId);
				return instance;
			},
		};
		//dbg:console.log("cache.addProperty =>"+Object.keys(this.texts));
	}

	addReference(_, property) {
		//dbg:console.log("cache.addReference "+property.name);
		//dbg:var e = new Error("reference");
		//dbg:console.error(e.stack);
		this._isActivated = true;
		const getReferenceKey = property.makeGetReferenceKey(_);
		this.references[property.name] = {
			$name: property.name,
			$ids: {},
			register(_, instance) {
				//dbg:console.error("=> register reference:"+property.name);
				const id = getReferenceKey(_, instance);

				if (id) instance.cache.references[property.name].$ids[id] = null;
				return instance;
			},
		};
		//dbg:console.log("cache.addReference =>"+Object.keys(this.references));
	}

	register(_, instance) {
		//dbg:console.error("register texts:"+Object.keys(this.texts));

		instance.cache = this;
		const self = this;

		Object.keys(self.texts).forEach_(_, (_, property) => {
			if (instance.properties[property]) {
				self.texts[property].register(_, instance);
			}
		});
		//dbg:console.error("register references:"+Object.keys(this.references));
		Object.keys(self.references).forEach_(_, (_, property) => {
			if (instance.properties[property]) self.references[property].register(_, instance);
		});
		this.instanceset.push(instance);
	}

	clean() {
		this.instanceset = [];
	}

	get isFull() {
		return this.instanceset.length > this.max;
	}

	transform() {
		// Cache records in order to improve the performance of the cache of
		// texts and references :
		const cache = this;

		cache.clean();

		function flush(_, _writer) {
			cache.instanceset.forEach_(_, (_, instance) => {
				_writer.write(_, instance);
			});
			cache.clean();
		}

		return function (_, _reader, _writer) {
			var instance;
			while ((instance = _reader.read(_)) !== undefined) {
				cache.register(_, instance);
				cache.isFull && flush(_, _writer);
			}
			flush(_, _writer);
		};
	}
};

exports.Cache = Cache;