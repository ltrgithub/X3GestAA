import { _ } from 'streamline-runtime';
const glob = require('streamline/lib/globals');
import { helpers } from'syracuse-core';
import * as types from '../engine/runtime/types';
import * as constants from '../supervisor/constants';
import * as attributes from '../supervisor/attributes';
import * as snapshots from '../supervisor/snapshots';
import * as runtime from '../engine/runtime/runtime';
import * as ez from 'ez-streams';
import * as bcd from '../engine/runtime/bcd';
import * as db from '../engine/runtime/db';

const tracerJs = require('syracuse-core').getTracer("etna.supervisor");
const tracerEvents = require('syracuse-core').getTracer("etna.events");
const util = exports;

export class Helper {
	class: {
		jsModules: string[];
	}
	index: {
		name: string;
		etnaType?: string;
	}[];
	diagnoses: any[];
	errors: any;

	constructor() {}

	addDiagnose(_: _, severity: number, message: string, category?: number) {
		throw new Error("invalid call: abstract method");
	}
	scripts(_: _): types.Prog[] {
		throw new Error("invalid call: abstract method");
	}

	getActionArgs(_: _,  type: string, action: string, key?: any, member?: types.ProgArgMember) {
		var args: types.ProgArgs = {
			THIS: {
				type: "LY",
				value: this
			},
			ASTATUS: {
				type: "LI",
				value: 0
			},
			CURPRO: {
				type: "LS",
				value: member && member.name || ""
			},
			CURPTH: {
				type: "LS",
				value: member && member.name || ""
			},
			member: member,
			path: member && member.jsName ? [member.jsName] : []
		};
		args[type] = {
			type: "LS",
			value: action
		};
		if (key) {
			var index = this.index;
			args = index.reduce_(_, (_, args, ind, i) => {
				const name = ind.name.split(' ')[0];
				if (!Array.isArray(key)) key = key.split("~");
				args[name] = {
					type: ind.etnaType,
					value: key[i]
				};
				//dbg:console.error(name+":",args[name]);
				return args;
			}, args);
		}
		return args;
	}

	_action(_: _,  action: string, frame: types.Frame) {
		tracerEvents.debug && tracerEvents.debug("action:" + action);
		return this.runScripts(_, "$EVENTS", this.getActionArgs(_, "AEVENT", action), frame);
	}
		
	jsDispatch(_: _,  handler: string, args: types.ProgArgs, _frame: types.Frame) {
		//console.error("JSDISPATCH", handler, "ARGS", Object.keys(args));
		var status = constants.CST_AOK;
		this.class.jsModules.forEach_(_, (_, def) => {
			if (status >= constants.CST_AERROR) return;
			status = Math.max(status, require('../x3js/js-invoke')(_, def, handler.substring(1).toLowerCase(), args, _frame));
		});
		return status;
	}
	
	runScripts(_: _,  handler: string, args: types.ProgArgs, _frame?: types.Frame) {
		if (this.class && this.class.jsModules && this.class.jsModules.length > 0) return this.jsDispatch(_, handler, args, _frame);
		var astatus = constants.CST_AOK;
		const scripts = this.scripts(_);
		//tracerJs.debug && tracerJs.debug("runScripts:"+handler);

		if (!scripts) return astatus;

		scripts.forEach_(_, (_, script) => {
			// Doesn't execute the next script if status !== CST_AOK
			if (astatus > constants.CST_AOK) return;

			//tracerJs.debug && tracerJs.debug("invoke ");
			try {
				if (script.body.$isBuiltin) {
					try {
						//  Save the current context and create a new one:
						var frame = glob.context.x3frame;
						var prev = frame;
						var cx = prev.context;

						var sl = prev ? prev.stackLevel + 1 : 0;

						glob.context.x3frame = frame = {
							values: {},
							types: {},
							context: cx,
							prev: prev,
							loopLevel: 0,
							stackLevel: sl,
							name: script.name,
							loc: {
								file: script.name,
								line: 0
							}
						};
						// current sub is the prog itself
						frame.sub = frame;
						frame.dicts = [frame, cx.globals, cx.sys];
						astatus = script.body[handler](_, handler, this) || 0;
					} finally {
						// Restore the previous context
						db.closeFiles([], sl);
						glob.context.x3frame = prev;
					}
				} else {
					if (typeof args === 'function') {
						args = util.any(args)(_);
					}
					if (args.CURPTH && !args.CURPTH.value.length) {
						// FOR AREAD_AFTER !
						args.THIS.value = this;
					}
					var actx = glob.context.x3session.actx;
					if (["$METHODS", "$OPERATIONS"].indexOf(handler) >= 0) {
						var frame = glob.context.x3frame;
						//var prevtableSlots=frame.context.tableSlots;
						var prevtables = frame.context.tables;
						var prevgclass = frame.context.gclass;
						var prevabbrev = frame.abbrev;
						//***
						//frame.context.tableSlots={};
						frame.context.tables = {};
						frame.context.gclass = {};
						frame.abbrev = "";
					}
					actx.$$dbgScriptLevel = (actx.$$dbgScriptLevel || 0) + 1;
					tracerEvents.debug && tracerEvents.debug(new Array(actx.$$dbgScriptLevel).join(' ') + "-> " + 
					script.name + '.' + handler + ' ' + (args.CURPRO !== undefined 
					? " CURPRO:" + (args.CURPRO.value || "") 
					: "") + (args.CURPTH !== undefined ? " CURPTH:" + (args.CURPTH.value || "") : ""));
					try {
						astatus = runtime.executeProg(_, script, handler, args, _frame);
					} finally {
						tracerEvents.debug && tracerEvents.debug(new Array(actx.$$dbgScriptLevel).join(' ') + "<- " + script.name);
						actx.$$dbgScriptLevel -= 1;
						if (handler === "$METHODS") {
							var frame = glob.context.x3frame;
							//frame.context.tableSlots=prevtableSlots;
							frame.context.tables = prevtables;
							frame.context.gclass = prevgclass;
							frame.abbrev = prevabbrev;
						}
					}
				}
			} catch (e) {
				tracerJs.error && tracerJs.error("exception in util.runScripts(" + handler + "):" + e.message);
				tracerJs.error && tracerJs.error(e.stack);
				this.addDiagnose(_, constants.CST_AERROR, e.message);
				astatus = constants.CST_AERROR;
				throw e;
			}
		});
		return astatus;
	}

	deleteErrors(_: _,  group: void, property: void) {
		this.diagnoses = [];
		this.errors = undefined;
	}
	toJSON() {
		if (super.toJSON) return super.toJSON();
		throw new Error("cannot serialize " + constructor);
	}
}

export class HttpError extends Error {
	statusCode: number;
	constructor(statusCode: number, message: string) {
		super(message);
		this.statusCode = statusCode;
	}
};

;

export function find<T>(arr: T[], key: string, val: any): T {
	for (var i = 0, len = arr.length; i < len; i++) {
		var elt = arr[i];
		if (util.any(elt)[key] === val) return elt;
	}
	return null;
};

export function declVar(dict: types.VariableDict, name: string, type: string, value: any) {
	dict.values[name] = value;
	dict.types[name] = type;
};

exports.uuid = helpers.uuid.generate;

exports.clone = function clone<T>(obj: T, shallow?: boolean): T {
	return Object.keys(obj).reduce((r, name) => {
		var v = util.any(obj)[name];
		if (v && typeof v === "object") {
			if (Array.isArray(v)) {
				v = v.slice(0);
				if (!shallow) v = v.map(clone);
			} else {
				v = clone(v);
			}
		}
		r[name] = v;
		return r;
	}, util.any({}));
};

export function isInstance(instance: any) {
	return !!(instance && instance.class && instance.slots);
};

export function isCollection(instance: any) {
	return !!(instance && instance.collection && Array.isArray(instance.lines));
};

export function path(instance: any, name: string) {
	if (instance.APARENT) return util.path(instance.APARENT, instance.proName + '.' + name);
	else return name;
};

export function checkInstance(instance: any) {
	if (!isInstance(instance)) throw new Error("value is not an instance");
};

export function emptyArray(base: number, def: any) {
	// array layout is [ndims, def, data, base1, size1, base2, size2, ...
	// variable arrays impose ndims = 1
	return [1, def === undefined ? def : null, [], base === undefined ? 1 : base, 32767];
};

//escape :
//$ by \u007F

export function escapeArray(input: any[]) {
	return input.map(item => {
		switch (typeof item) {
			case "object":
				return escapeJson(item);
			case "string":
				return item[0] === "$" ? "_" + item.substring(1) : item;
			default:
				return item;
		}
	});
};

export function escapeJson(input: any): any {
	// must clone as original object might be used later unescaped
	if (Array.isArray(input)) return escapeArray(input);
	//
	const out = util.any({});

	helpers.object.forEachKey(input, function (key, value) {
		var escKey = key;
		var escVal = value;
		if (value !== null) {
			if (Array.isArray(value)) {
				escVal = exports.escapeArray(value);
			} else if (typeof value === "object") escVal = exports.escapeJson(value);

			if (key[0] === "$") {
				escKey = "_" + key.substring(1);
				//			escKey = "Ã©"+key.substring(1);
			}
		}
		out[escKey] = escVal;
	});
	//
	return out;
};
//unescape :
// _ by $

export function unescapeJson(input: any): any {
	helpers.object.forEachKey(input, function (key, value) {
		var escKey = key;
		var escVal = value;
		if (Array.isArray(value)) {
			escVal = [];
			value.forEach((item: any) => {
				if (typeof item === "object") escVal.push(exports.unescapeJson(item));
				else if (typeof item === "string") escVal.push(item[0] === "_" ? "$" + item.substring(1) : item);
				else escVal.push(item);
			});
		} else if (typeof value === "object") escVal = exports.unescapeJson(value);

		if (key[0] === "_") {
			escKey = "$" + key.substring(1);
			delete input[key];
		}

		input[escKey] = escVal;
	});
	//	console.log("unescaped json: "+sys.inspect(input,null,4));
	return input;
};

export function checkDataProperty(data: any, property: string) {
	if (data[property] && typeof data[property] === 'string') {
		data[property] = !isNaN(data[property]) && bcd.toDouble(bcd.fromString(data[property])) > 0 ? bcd.toDouble(bcd.fromString(data[property])) : undefined;
	}
};

export function decodeValueMongoString(s: string) {
	return s.replace(new RegExp(String.fromCharCode(255), 'g'), ',');
};

export function traceException(e: Error) {
	tracerJs.error && tracerJs.error(e.message);
	tracerJs.error && tracerJs.error(e.stack);
};

export function inverseMap(map: any) {
	return Object.keys(map).reduce((r, k) => {
		r[map[k]] = k;
		return r;
	}, util.any({}));
}

export function camelToKebab(str: string, sep?: string) {
	sep = sep || '-';
	const s = str.replace(/[A-Z]/g, ch => sep + ch.toLowerCase());
	return s[0] === sep ? s.substring(1) : s;
};

export function kebabify(str: string) {
	return exports.camelToKebab(exports.camelize(str));
};

export function pascalize(str: string) {
	// if all upper, lowercase it first otherwise keep it (if it is camel)
	if (str === str.toUpperCase()) str = str.toLowerCase();
	return str[0].toUpperCase() + str.substring(1);
};

export function camelize(name: string, capitalize?: boolean) {
	name = name.split('(')[0]; // discard parenthesized part
	if (!/^[a-zA-Z]/.test(name)) name = 'todo' + name; // make sure result is camel
	return name.split(/[\W]/).map((s, i) => {
		if (i === 0 && !capitalize) return s[0].toLowerCase() + (/[a-z]/.test(s) ? s.substring(1) : s.substring(1).toLowerCase());
		else if (s) return s[0].toUpperCase() + (/[a-z]/.test(s) ? s.substring(1) : s.substring(1).toLowerCase());
		else return '';
	}).join('');
};

// smart variant of toUpperCase
export function upcase(str: string, sep?: string) {
	sep = sep || '_';
	const s = camelize(str).replace(/[A-Z]/g, (ch: string) => sep + ch);
	return (s[0] === sep ? s.substring(1) : s).toUpperCase();
};

export function debug(message: string, x: any) {
	console.error(message, x);
	return x;
};

export function any(x: any) { return x; }
export function arrayOfAny(x: any[]) { return x; }
