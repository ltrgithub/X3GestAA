"use strict";
/*
TODO : 
 - Operations for real
 - Add a transaction
*/

const glob = require('streamline/lib/globals');
const util = require("etna/lib/supervisor/util");
const Helper = util.Helper;
const constants = require("etna/lib/supervisor/constants");

//var debug = function(m) {console.error("tableLinks : "+m);}

const tracerJs = require('syracuse-core').getTracer("etna.supervisor");

function sqlName(code, i) {
	return code + '_' + (i || 0);
};

const sqlValue = {
	string(i) {
		return function (key) {
			tracerJs.debug && tracerJs.debug("sqlValue(string) key:" + key + " i:" + i + " key[i]:" + key[i]);
			return key[i];
		};
	},
	number(i) {
		return function (key) {
			tracerJs.debug && tracerJs.debug("sqlValue(number) key:" + key + " i:" + i + " key[i]:" + key[i]);
			return parseInt(key[i]);
		};
	}
};
const linkOperations = {
	control: {
		type: 1,
		execute(_, instance, superv, sql) {
			var status = constants.CST_AOK;
			const names = sql.table.indexes[0].sqlNames();
			//if (sql.table.data.INTIT) names.push(sqlName(sql.table.data.INTIT));

			var cmd = "select " + names.join(',');
			cmd += " from " + sql.table.name + " where (" + sql.where + ")";

			tracerJs.debug && tracerJs.debug(cmd);
			const records = superv.sqlReader(_, cmd, sql.params).toArray(_);

			if (records.length) {
				records.forEach_(_, (_, record) => {
					// "The record is used by"
					const message = [superv.loadMess(_, 126, 101)];
					// Add the record's key :
					message.push(sql.table.indexes[0].columns.map(column => record[column.name]).join('~'));
					// Add the record's description :
					const recordDescription = sql.table.getRecordDescription(_, records);

					if (recordDescription) message.push('(' + recordDescription + ')');
					// "is used in"
					message.push(superv.loadMess(_, 133, 198));
					// Add the table's name
					message.push(sql.table.name);
					// Add the table's description
					const tableDescription = sql.table.description(_);

					if (tableDescription) message.push('(' + tableDescription + ')');
					status = Math.max(status, instance.addDiagnose(_, constants.CST_AERROR, message.join(' ')));
				});
			}
			return status;
		}
	},
	delete: {
		type: 2,
		execute(_, instance, superv, sql) {
			const cmd = "delete from " + sql.table.name + " where " + sql.where;

			tracerJs.debug && tracerJs.debug(cmd);
			tracerJs.debug && tracerJs.debug(sql.params);
			tracerJs.debug && tracerJs.debug("delete type2: " + cmd);
			superv.executeSql(_, cmd, sql.params);
			return constants.CST_AOK;
		}
	},
	reset: {
		type: 3,
		execute(_, instance, superv, sql) {
			const param = superv.sqlDriver.param;
			const updateSets = Object.keys(sql.updateSets).map(key => {
				sql.params.push(sql.updateSets[key]);
				return key + " = " + param(sql.params.length - 1);
			}).join(' ');
			const cmd = "update " + sql.table.name + " set " + updateSets + " where " + sql.where;

			tracerJs.debug && tracerJs.debug("reset type3: " + cmd);
			superv.executeSql(_, cmd, sql.params);
			return constants.CST_AOK;
		}
	}
};

class TableLinks extends Helper {
	constructor(superv, table) {
		super();
		this.supervisor = superv;
		this.table = table;
	}
	init(_) {
		tracerJs.debug && tracerJs.debug(this.table + " tableLinks");

		this.links = this.supervisor.mongoStore.collection('ATABLE', _).find({
			"COLUMNS.LIEN": this.table
		}).sort({
			CODFIC: 1
		}).toArray(_).filter(table => table.CODFIC !== this.table).reduce_(_, (_, r, table) => {
			//tracerJs.debug && tracerJs.debug("table:"+table.CODFIC);
			return table.COLUMNS.filter(column => column.LIEN && column.LIEN == this.table && column.ANNUL !== 4).reduce_(_, (_, r, column) => {
				try {
					var type = r[column.ANNUL] = r[column.ANNUL] || {};
					var group = type[table.CODFIC] = type[table.CODFIC] || {};
					group.table = group.table || this.supervisor.load(_, 'Table', table.CODFIC);
					group.links = group.links || [];
					if (column.ANNUL === 3) {
						group.updateSets = group.updateSets || {};
						group.updateSets[sqlName(column.CODZONE)] = group.table.columns[column.CODZONE].type.defaultValue;
					}
					var expressions = column.EXPLIEN && column.EXPLIEN.trim();
					if (expressions) {

						var indiceMax = 1;
						var statement = [];
						var expression = expressions.split(';');
						for (var e = 0; e < expression.length; e++) {
							tracerJs.debug && tracerJs.debug(table.CODFIC + " expression:" + expression[e]);
							statement[e] = function (expression) {
								return function (link, i) {
									throw new Error("Don't know what to do with expression:" + expression);
								};
							}(expression[e]);

							if (/^\w+\(indice\)$/.test(expression[e])) {
								indiceMax = parseInt(column.DIME);

								var colName = expression[e].substring(0, expression[e].indexOf('('));
								var colType = group.table.columns[colName].type.jsType;

								statement[e] = function (name, jsType, idx) {
									return function (link, i) {
										link.sql.push({
											name: sqlName(name, i),
											value: sqlValue[jsType](idx)
										});
									};
								}(colName, colType, e);
							} else if (/^indice$/.test(expression[e])) {
								statement[e] = function (idx) {
									return function (link, i) {
										link.statement = link.statement || [];
										link.statement.push(function (_, key) {
											return key[idx] = i;
										});
									};
								}(e);
							} else if (/^indice\s*([+-])\s*(\d*)$/.test(expression[e])) {
								let match = expression[e].match(/^indice\s*([+-])\s*(\d*)$/);
								let delta = (match[1] === '+' ? 1 : -1) * parseInt(match[2]);
								let idx = e;
								statement[e] = function (link, i) {
									link.statement = link.statement || [];
									link.statement.push(function (_, key) {
										return key[idx] = i + delta;
									});
								};
							} else if (/^\[V\]\w+$/.test(expression[e])) {
								var x3Var = expression[e].substring(3);
								switch (x3Var) {
									case "GLANGUE":
										statement[e] = function (idx) {
											return function (link, i) {
												link.statement = link.statement || [];
												link.statement.push(function (_, key) {
													const actx = glob.context.x3session.actx;

													return key[idx] = actx.$LAN(_);
												});
											};
										}(e);
										break;
								}
							} else {
								var colName = expression[e];
								if (group.table.columns[colName]) {
									var colType = group.table.columns[colName].type.jsType;
									statement[e] = function (name, jsType, idx) {
										return function (link, i) {
											link.sql.push({
												name: sqlName(name, i),
												value: sqlValue[jsType](idx)
											});
										};
									}(colName, colType, e);
								} else {
									statement[e] = function (idx) {
										return function (link, i) {
											link.statement = link.statement || [];
											link.statement.push(function (_, key) {
												return key[idx] = idx;
											});
										};
									}(e);
								}
							}
						}

						// Add links:
						for (var indice = 0; indice < indiceMax; indice++) {
							var link = {
								sql: []
							};
							for (var i = 0; i < statement.length; i++) {
								statement[i](link, indice);
							}
							group.links.push(link);
						}
					} else {
						group.links.push({
							sql: [{
								name: sqlName(column.CODZONE),
								value: sqlValue[group.table.columns[column.CODZONE].type.jsType](0)
							}]
						});
					}
				} catch (e) {
					util.traceException(e);
				}
				return r;
			}, r, this);
			return r;
		}, {}, this);
		return this;
	}
	execute(_, instance, operation) {
		var status = constants.CST_AOK;

		const $keys = instance.key;
		const keys = [$keys];

		tracerJs.debug && tracerJs.debug("tableLinks execute  operation type " + operation.type + " on " + keys);

		if (this.links && this.links[operation.type]) {
			var param = this.supervisor.sqlDriver.param;

			Object.keys(this.links[operation.type]).forEach_(_, (_, groupKey) => {
				const group = this.links[operation.type][groupKey];

				if (group.links) {

					// For each key stored in keys
					var sql = keys.reduce_(_, (_, r, $key) => {
						const key = typeof $key === 'string' ? $key.split('~') : $key;
						// Loop on links

						group.links.filter_(_, (_, link) => {
							// Keep links which abide with logical statements :
							if (link.statement) {
								for (var i = 0; i < link.statement.length; i++) {
									if (!link.statement[i](_, key)) return false;
								}
							}
							return true;
						}).reduce_(_, (_, r, link) => {
							r.wheres = r.wheres || [];
							const where = {};

							r.maxColumns = Math.max(r.maxColumns, link.sql.length);
							for (var i = 0; i < link.sql.length; i++) {
								where[link.sql[i].name] = link.sql[i].value(key);
							}
							r.wheres.push(where);
							return r;
						}, r);
						return r;
					}, {
						table: group.table,
						maxColumns: 0,
						updateSets: group.updateSets
					});

					if (sql.wheres) {
						// TODO : Split sql.wheres here if it contains to many elements (sql limits)
						sql.params = [];
						sql.where = sql.wheres.reduce((r, where) => {
							r.push(Object.keys(where).map(condition => {
								sql.params.push(where[condition]);
								return condition + "=" + param(sql.params.length - 1);
							}).join(' and '));
							return r;
						}, []).join(' or ');
						status = Math.max(status, operation.execute(_, instance, this.supervisor, sql));
					}
				}
			});
		};
		return status;
	}
	control(_, instance) {
		return this.execute(_, instance, linkOperations.control);
	}
	delete(_, instance) {
		tracerJs.debug && tracerJs.debug("delete table:" + this.table);
		const status = this.execute(_, instance, linkOperations.delete);

		if (status === constants.CST_AERROR) return status;
		return this.execute(_, instance, linkOperations.reset);
	}
}

exports.constructor = TableLinks;