"use strict";

const generic = require("ez-streams").devices.generic;
const bcd = require('etna/lib/engine/runtime/bcd');
const glob = require('streamline/lib/globals');
const tdatetime = require('etna/lib/engine/runtime/tdatetime');
const util = require("etna/lib/supervisor/util");
const Helper = util.Helper;
const constants = require("etna/lib/supervisor/constants");
const tracerDbms = require('syracuse-core').getTracer("etna.dbms");

class Table extends Helper {
	constructor(superv, data) {
		super();
		this.supervisor = superv;
		this.data = data;
		this.sql = {};
		this.abrev = 'T';
	}
	init(_) {
		this.columns = {};
		this.data.COLUMNS.filter(data => !/^AX[123X]/.test(data.CODTYP)).forEach_(_, (_, data) => {
			this.columns[data.CODZONE] = this.supervisor.new(_, 'Column', this, data);
		}, this);

		this.indexes = this.data.INDEXES.map_(_, (_, data) => this.supervisor.new(_, 'Index', this, data), this);
		return this;
	}
	get name() {
		return this.data.CODFIC;
	}
	get abbrev() {
		return this.data.ABRFIC;
	}
	column(name) {
		return this.columns[name];
	}
	index(name) {
		return this.indexes.filter(ind => ind.name === name)[0];
	}
	reader(_, index, vals, where, raw, options) {
		const columns = this.columns;

		options = options || [];

		const param = this.supervisor.sqlDriver.param;
		const tableNames = [this.name + ' T'];
		const columnNames = [];
		const wheres = where && where.sql ? [where.sql] : [];
		const params = where && where.sql ? where.params.slice(0) : [];
		const sqlOpts = {};

		Object.keys(columns).forEach_(_, (_, name) => {
			columns[name].getSql(_, columnNames, tableNames, wheres, params, null, null, raw, sqlOpts);
		});
		var indexColNames;
		if (index) {
			indexColNames = index.sqlNames();
			var indexCols = indexColNames.slice(0, vals.length);
			indexCols.forEach((name, i) => {
				params.push(vals[i]);
				wheres.push(name + "=" + param(params.length - 1));
			});
		} else if (vals && vals.length > 0) {
			// JS API only
			var cols = Object.keys(vals);
			cols.forEach((name, i) => {
				params.push(vals[name]);
				wheres.push(name + "=" + param(params.length - 1));
			});
		}
		var sql = "select ";
		if (options.limit) sql += "top " + options.limit + " ";
		sql += columnNames.join(',') + " from " + tableNames.join(',');
		if (wheres.length) sql += " where (" + wheres.join(') and (') + ')';
		if (index) sql += " order by " + indexColNames;

		return this.supervisor.sqlReader(_, sql, params, sqlOpts);
	}
	deleteIndexes(_, ifExists) {
		this.indexes.forEach_(_, (_, index) => {
			try {
				var sql = this.supervisor.sqlDriver.dropIndexSql(this.name + "_" + index.name, this.name);
				this.supervisor.executeSql(_, sql);
			} catch (ex) {
				// do not fail, just report error
				if (ifExists && this.supervisor.sqlDriver.isIndexNotFound(ex)) return;
				tracerDbms.error && tracerDbms.error(index.name + ": " + ex.message);
				//else throw ex;
			}
		}, this);
	}
	createIndexes(_) {
		this.indexes.forEach_(_, (_, index) => {
			const sql = "create index " + this.name + "_" + index.name + //
			" on " + this.name + " (" + index.columns.map(col => col.name + '_0') + ")";

			this.supervisor.executeSql(_, sql);
		}, this);
	}
	clear(_) {
		this.supervisor.executeSql(_, "delete from " + this.name);
	}
	computeColumnNames(_) {
		if (!this.sql.columnNames) {
			var names = [];
			var descs = [];
			var primKey = this.indexes[0];
			var param = this.supervisor.sqlDriver.param;

			// Add primKey first (in the correct order)...
			var columns = primKey.columns.map(column => column.name);
			// ... and add other columns
			Object.keys(this.columns).forEach(column => {
				if (!primKey.hasColumn(column)) {
					columns.push(column);
				}
			});
			//console.error("columns:"+columns);

			columns.forEach_(_, (_, name) => {
				const column = this.columns[name];

				column.getSql(_, names, null, null, null, descs, true);
			}, this);

			this.sql.columnNames = names.map(name => {
				return name.replace(/T\./g, ''); // remove leading T.
			});
			this.sql.columnDescs = descs;
			var insertVars = [],
			    updateSets = [],
			    updateWheres = [];

			var offset_u = 0;
			var offset_d = 0;
			descs.forEach((desc, i) => {
				insertVars.push(param(i));
				if (!primKey.hasColumn(desc.name)) {
					updateSets.push(desc.name + "_" + (desc.index || 0) + "=" + param(offset_u++));
				}
			}, this);
			this.sql.insertVars = insertVars.join(',');
			this.sql.updateSets = updateSets.join(',');
			this.sql.deleteWheres = primKey.columns.map(column => "(" + column.name + "_0=" + param(offset_d++) + ")", this).join(' and ');
			this.sql.updateWheres = primKey.columns.map(column => "(" + column.name + "_0=" + param(offset_u++) + ")", this).join(' and ');
			this.sql.updtickWhere_u = "(UPDTICK_0 = " + param(offset_u++) + ')';
			this.sql.updtickWhere_d = "(UPDTICK_0 = " + param(offset_d++) + ')';
		}
	}
	getInstanceKey(_, instance) {
		return this.indexes[0].columns.map_(_, (_, column) => instance.slot(_, column.name).get(_, true), this).join('~');
	}
	insertRecord(_, record) {
		tracerDbms.debug && tracerDbms.debug("table.insert for " + instance.class.name);
		this.computeColumnNames(_);

		const values = this.sql.columnDescs.reduce_(_, (_, r, desc) => {
			const val = record[desc.name];

			r.push(val !== undefined ? val : desc.type.defaultValue);
			return r;
		}, []);
		const sql = "insert into " + this.name + " (" + this.sql.columnNames.join(',') + //
		") values (" + this.sql.insertVars + ")";

		try {
			return this.supervisor.executeSql(_, sql, values);
		} catch (e) {
			tracerDbms.error && tracerDbms.error("Exception in table.insertRecord:" + e.stack);

			throw new Error(this.supervisor.loadMessParams(_, 140, 65, " n/a ", // " " for unit tests only !
			this.name, this.supervisor.sqlDriver.isUniqueViolated && this.supervisor.sqlDriver.isUniqueViolated(e) ? this.supervisor.loadMessParams(_, 100, 22) : e.message));
		}
	}
	insert(_, instance) {
		tracerDbms.debug && tracerDbms.debug("table.insert for " + instance.class.name);
		this.computeColumnNames(_);
		const values = this.sql.columnDescs.reduce_(_, (_, r, desc) => {
			r.push(instance.getSql(_, desc));
			return r;
		}, [], this);
		const sql = "insert into " + this.name + " (" + this.sql.columnNames.join(',') + //
		") values (" + this.sql.insertVars + ")";

		try {
			return this.supervisor.executeSql(_, sql, values);
		} catch (e) {
			tracerDbms.error && tracerDbms.error("Exception in table.insert:" + e.stack);

			throw new Error(this.supervisor.loadMessParams(_, 140, 65, " " + this.getInstanceKey(_, instance), // " " for unit tests only !
			this.name, this.supervisor.sqlDriver.isUniqueViolated && this.supervisor.sqlDriver.isUniqueViolated(e) ? this.supervisor.loadMessParams(_, 100, 22) : e.message));
		}
	}
	update(_, instance) {
		tracerDbms.debug && tracerDbms.debug("table.update for " + instance.class.name);
		this.computeColumnNames(_);
		const primKey = this.indexes[0];
		var values = [];
		const valuesWhere = [];

		this.sql.columnDescs.forEach_(_, (_, desc) => {
			const dest = primKey.hasColumn(desc.name) ? valuesWhere : values;

			dest.push(instance.getSql(_, desc));
		});
		// + updtick
		valuesWhere.push(instance.get(_, "UPDTICK", true));

		values = values.concat(valuesWhere);
		const sql = "update " + this.name + " T set " + this.sql.updateSets + //
		" where " + this.sql.updateWheres + ' and ' + this.sql.updtickWhere_u;

		return this.supervisor.executeSql(_, sql, values);
	}
	delete(_, instance) {
		this.computeColumnNames(_);
		const values = this.indexes[0].columns.map_(_, (_, column) => instance.slot(_, column.name).getSql(_), this);

		// + updtick

		values.push(instance.get(_, "UPDTICK", true));

		const sql = "delete from " + this.name + " where " + this.sql.deleteWheres + ' and ' + this.sql.updtickWhere_d;

		return this.supervisor.executeSql(_, sql, values);
	}
	loadRecords(_, index, vals, max, where, raw) {
		if (max == null || max < 0) max = Infinity;
		const self = this;

		return self.reader(_, index, vals, where, raw).limit(max).toArray(_);
	}
	convertIn(data) {
		Object.keys(this.columns).forEach(name => {
			const col = this.columns[name];

			data[name] = col.convertIn(data[name]);
		}, this);
	}
	writer(_, cnx) {
		this.computeColumnNames(_);
		const sql = "insert into " + this.name + " (" + this.sql.columnNames.join(',') + //
		") values (" + this.sql.insertVars + ")";
		const writer = this.supervisor.sqlDriver.writer(_, cnx, sql);
		const self = this;
		const wr = writer.pre.map((_, data) => {
			wr.count++;
			return self.sql.columnDescs.map((name, i) => {
				const desc = self.sql.columnDescs[i];
				const v = desc.index == null ? data[desc.name] : data[desc.name][desc.index];

				return v === undefined ? null : desc.type ? desc.type.toSql(v) : v;
			});
		});

		wr.count = 0;
		return wr;
	}
	exists(_) {
		return this.supervisor.sqlDriver.tableExists(_, this.name, this.supervisor.folderName);
	}
	drop(_, ifExists) {
		try {
			return this.supervisor.executeSql(_, "drop table " + this.name);
		} catch (ex) {
			if (ifExists && this.supervisor.sqlDriver.isTableNotFound(ex)) return;
			else throw ex;
		}
	}
	create(_, exists) {
		//trace && trace("creating table " + table.CODFIC);
		if (exists) this.drop(_);
		const sql = "create table " + this.name + " (UPDTICK_0 NUMBER(10) DEFAULT 0," + Object.keys(this.columns).map(name => {
			const col = this.columns[name];

			return col.sqlDef();
		}, this).filter(def => def).join(',') + ")";

		this.supervisor.executeSql(_, sql);
	}
	links(_) {
		this._links = this._links || this.supervisor.new(_, 'tableLinks', this.name);
		return this._links;
	}
	description(_) {
		return this.supervisor.loadText(_, this.data.INTITFIC);
	}
	getRecordDescription(_, record) {
		// Set a default value *
		var description = "";
		if (this.data.INTIT) {
			description = record[this.data.INTIT] || description;
			if (this.data.INTITTYPE) {
				if (this.data.INTITTYPE === "ATX") {
					description = this.supervisor.loadText(_, this.data.INTIT);
				} else if (/^AX[123X]/.test(this.data.INTITTYPE)) {
					//    Read [AXX_]AXX0  = LS(0).TABLE;LS(0).INTIT;POBJ.ACTX.LAN;RECORDKEYS(1);RECORDKEYS(2)
					//    If !fstat : RECORDDESC = [F:AXX_]TEXTE : Endif
					var actx = glob.context.x3session.actx;
					var columns = this.table.indexes[0].columns;
					var param = _this.supervisor.sqlDriver.param;
					var params = [];
					var wheres = [];

					params.push(this.name);
					wheres.push("CODFIC_0=" + param(params.length - 1));
					params.push(this.data.INTIT);
					wheres.push("ZONE_0=" + param(params.length - 1));
					params.push(actx.$LAN(_));
					wheres.push("LANGUE_0=" + param(params.length - 1));
					params.push(record[columns[0]]);
					wheres.push("IDENT1_0=" + param(params.length - 1));
					params.push(record[columns[1]]);
					wheres.push("IDENT2_0=" + param(params.length - 1));
					var sql = "select TEXTE_0 from ATEXTRA  where (" + wheres.join(" and ") + ")";

					rs = self.supervisor.sqlReader(_, sql, params).toArray(_);
					description = rs && rs.length ? rs[0].TEXTE : "";
				}
			}
		}
		return description;
	}
}

module.exports = {
	collectionName: 'ATABLE',
	keyName: 'CODFIC',
	constructor: Table
};