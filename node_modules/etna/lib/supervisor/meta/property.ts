"use strict";

const glob = require('streamline/lib/globals');
const ez = require("ez-streams");
const tuuid = require('etna/lib/engine/runtime/tuuid');
const tdatetime = require('etna/lib/engine/runtime/tdatetime');
const variables = require('etna/lib/engine/runtime/variables');
const util = require("etna/lib/supervisor/util");
const Helper = util.Helper;
const constants = require("etna/lib/supervisor/constants");
const FACETS = require("etna/lib/supervisor/meta/representation").FACETS;
const type = require("etna/lib/supervisor/meta/type");
const newSlot = require("etna/lib/supervisor/slot").newSlot;
const newSlotText = require("etna/lib/supervisor/slotText").newSlotText;
const newSlotClob = require("etna/lib/supervisor/slotClob").newSlotClob;
const newSlotBlob = require("etna/lib/supervisor/slotBlob").newSlotBlob;
const newSlotAtextra = require("etna/lib/supervisor/slotAtextra").newSlotAtextra;
const newSlotReference = require("etna/lib/supervisor/slotReference").newSlotReference;
const newSlotCollection = require("etna/lib/supervisor/slotCollection").newSlotCollection;
const tracerJs = require('syracuse-core').getTracer("etna.supervisor");

function alias(alias) {
	return '{' + alias + '}';
}

function ident(value) {
	return value === "" ? " " : value;
}

/*
 - superv, clas, data are mandatory arguments of the constructor
 - newMaker, collection are optionals
*/
export class Property extends Helper {
	constructor(superv, clas, data, newMaker, collection) {
		super();
		this.supervisor = superv;
		this.data = data;
		util.checkDataProperty(this.data, "NUMFLD");
		util.checkDataProperty(this.data, "LONG");

		// class can be a representation !
		this.class = clas;
		this.collection = collection;

		this.newMaker = undefined;
		this.newSlot = undefined;
		if (newMaker) {
			this.newMaker = newMaker;
			this.newSlot = this.newMaker(this);
		}

		// Properties defined in init :
		this.type = undefined;
		this.$x3Format = undefined;
	}
	init(_) {
		if (this.type) return this;
		if (this.data.CODTYP) {
			this.type = this.supervisor.load(_, 'Type', this.data.CODTYP);
			if (!this.type) throw new Error('type not found: ' + this.data.CODTYP);
			if (this.type.data.NOLIB > 0) {
				this.data.NOLIB = this.type.data.NOLIB;
			}
			this.$x3Format = this.type.getX3Format(_, this);
		}

		if (!this.newMaker) {
			if (this.isAtextra) {
				this.newMaker = newSlotAtextra;
			} else if (this.isText) {
				this.newMaker = newSlotText;
			} else if (this.type && this.type.isClob) {
				this.newMaker = newSlotClob;
			} else if (this.type && this.type.isBlob) {
				this.newMaker = newSlotBlob;
			} else {
				this.newMaker = newSlot;
			}
			this.newSlot = this.newMaker(this);
		}
		return this;
	}
	get name() {
		return this.data.FLDCLA || this.data.CODFLD;
	}
	get isExtra() {
		return !!this.data.CODFLD;
	}
	get etnaType() {
		return this.type.etnaType;
	}
	get column() {
		//dbg:tracerJs.debug && tracerJs.debug("column ? "+(!!this.class.table));
		return this.class.table && this.class.table.column(this.data.FLDCLA) || undefined;
	}
	get params() {
		//return this.class.data.PARAM_FLDS || this.class.data.PARAMS;
		if (this._params === undefined) {
			this._params = (this.data.PARAM_FLDS || this.data.PARAMS || []).sort((p1, p2) => p1.NUMPAR - p2.NUMPAR);
		}
		return this._params;
	}
	get keyParams() {
		return this.params ? this.params.filter(p => p.TYPPAR === 1 && (p.FLDCLA === this.name || p.CODFLD === this.name) && p.TYPKEY === 2, this) : [];
	}
	get propertyLength() {
		return this.data.LONG;
	}
	get regex() {
		return this.type.regex;
	}
	get lobTable() {
		return this.data.LOBTAB || this.type.lobTable;
	}
	get lobField() {
		return this.data.LOBFLD || this.type.lobField;
	}

	keyMaps(_) {
		if (!this._keyMaps) {
			this._keyMaps = this.keyParams.reduce_(_, (_, r, paramData) => {
				r[paramData.CODPAR] = this.addFieldTransform(_, paramData.VALEUR);
				return r;
			}, {});
		}
		return this._keyMaps;
	}
	get typeParams() {
		return this.params ? this.params.filter(p => p.TYPPAR === 2 && (p.FLDCLA === this.name || p.CODFLD === this.name)) : [];
	}
	typeRulesMaps(_) {
		return this._typeRulesMaps = this._typeRulesMaps || this.params.filter(p => p.TYPPAR === 1 && p.TYPKEY === 1).reduce_(_, (_, r, p) => {
			r[p.CODPAR] = {
				type: "B" + type.typTyp2EtnaType[p.TYPINT],
				value: this.addFieldTransform(_, p.VALEUR)
			};
			return r;
		}, {});
	}
	get isSearchable() {
		return this.data.FLDSEARCH === 2;
	}
	get isAtextra() {
		return (/^AX[123X]/.test(this.data.CODTYP));
	}
	get isText() {
		return this.data.CODTYP === "ATX";
	}
	get isArray() {
		return this.collection && !this.collection.mappingData && this.collection.nbrPro === 1;
	}
	get isInstance() {
		return this.collection && this.collection.isInstance;
	}
	instance(resource) {
		return resource.instance ? this.isExtra ? resource : resource.instance : resource;
	}
	ref(tag) {
		return tag + '_REF';
	}
	setAtextra(_, instance) {
		const atextra = this.supervisor.newInstance(_, "ATEXTRA");
		// Set atextra properties
		const keyMaps = this.keyMaps(_);

		Object.keys(keyMaps).forEach_(_, (_, key) => {
			var keyVal = keyMaps[key](_, instance);
			keyVal = keyVal ? keyVal : " ";
			atextra.set(_, key, keyVal, true);
		});
		return atextra;
	}
	getAtextra(_, instance, lan) {
		// Little trick
		// Save the current language:
		const saveLan = glob.context.x3session.actx.$LAN(_);

		glob.context.x3session.actx.$LAN(_, lan);
		// Read the text:
		var text = "";
		const atextra = this.setAtextra(_, instance);
		const status = atextra.read(_, atextra.getKeyTab(_), {
			crud: false,
			raw: true
		});

		if (status !== constants.CST_AERROR) text = atextra.get(_, "TEXTE");

		// Restore the current language:
		glob.context.x3session.actx.$LAN(_, saveLan);
		return text;
	}
	updateAtextra(_, instance, value, lan) {
		// Save the current language:
		var saveLan;
		if (lan) {
			saveLan = glob.context.x3session.actx.$LAN(_);
			glob.context.x3session.actx.$LAN(_, lan);
		}

		// Create an instance of atextra
		const atextra = this.setAtextra(_, instance);
		// Add the text:

		const options = {
			crud: false,
			raw: true
		};

		//Try to read the instance of atextra

		const st = atextra.read(_, atextra.getKeyTab(_), options);

		atextra.set(_, "TEXTE", value, true);

		if (st === constants.CST_AOK) atextra.update(_, options);
		else atextra.insert(_, options);

		// Restore the current language:
		if (saveLan) glob.context.x3session.actx.$LAN(_, saveLan);
	}
	deleteAtextra(_, instance) {
		// Create an instance of atextra
		const atextra = this.setAtextra(_, instance);

		// Delete the instance of atextra

		atextra.delete(_, {
			crud: false,
			raw: true
		});
	}
	set(value) {
		this._key = this._key || "L" + this.etnaType + (this.etnaType === 'S' ? this.data.LONG || this.type.data.LNGTYP || 250 : '');
		//dbg:console.log("set "+this.name+ " type:"+this.etnaType+" key:"+this._key+" value:'"+value+"'");
		return variables.types[this.etnaType].set(this.name, this._key, value);
	}
	clone() {
		const p = new Property(this.supervisor, this.class, this.data, this.newMaker, this.collection);
		// + set properties initialize in init (aynschronous function)

		p.type = this.type;
		p.$x3Format = this.$x3Format;
		// p.regex = p.regex; // ??????????
		p.jsName = this.jsName;
		return p;
	}
	targetClass(_) {
		if (!this.data.LNKCLA) return null;
		return this.supervisor.load(_, 'Class', this.data.LNKCLA);
	}
	findExportedProperty(name) {
		const exportedProperties = this.resourceFactory ? this.resourceFactory.representation.data.EXPORTED_PROPERTIES : undefined;

		return exportedProperties ? util.find(exportedProperties, 'CODPRO', name) : undefined;
	}
	title(_, lan) {
		const expProData = this.exportedProperty ? this.exportedProperty.data : {};

		if (expProData.INTPRO) return this.supervisor.loadText(_, this.exportedProperty.data.INTPRO, lan);
		else if (this.data.INTFLD) return this.supervisor.loadText(_, this.data.INTFLD, lan);

		else if (this.collection && this.collection.data.INTCOL) return this.supervisor.loadText(_, this.collection.data.INTCOL, lan);
		return "";
	}
	prototypeNode(_) {
		// this.resourceFactory is normaly set !
		const factoryFacet = this.resourceFactory.facet;
		const isFactoryEditFacet = factoryFacet === '$edit';
		const expProData = this.exportedProperty ? this.exportedProperty.data : {};
		const node = {};
		const title = this.title(_);

		node.$title = title;

		if (expProData.INTSHTPRO) node.$shortTitle = this.supervisor.loadText(_, this.exportedProperty.data.INTSHTPRO);
		else if (this.data.INTSHTFLD) node.$shortTitle = this.supervisor.loadText(_, this.data.INTSHTFLD);
		node.$shortTitle = title;

		if (expProData.TYPAFFPRO !== undefined && expProData.TYPAFFPRO !== 2) node.$isReadOnly = true;
		if (this.data.OBLIG === 2) node.$isMandatory = true;

		const prefix = FACETS[factoryFacet] && FACETS[factoryFacet].prefix;

		if (prefix) {
			var staPro = expProData["STA" + FACETS[factoryFacet].prefix + "PRO"];
			if (staPro === 2) node.$isHidden = true;
			else if (staPro === 3) node.$isExcluded = true;
		}
		if (this.targetResourceFactory && this.collection) {
			if (!(this.collection.data.MAXCOL === 1 && this.collection.data.MINCOL === 2)) {
				node.$capabilities = [];
				if (this.collection.data.FLGAPDCOL === 2) node.$capabilities.push("append");
				if (this.collection.data.FLGINSCOL === 2) node.$capabilities.push("insert");
				if (this.collection.data.FLGSUPCOL === 2) node.$capabilities.push("delete");
				if (this.collection.data.FLGTRICOL === 2) node.$capabilities.push("reorder");
				node.$capabilities = node.$capabilities.join(',');

				if (this.collection.data.MAXCOL > 0) {
					node.$maxItems = this.collection.data.MAXCOL;
					if (this.collection.data.MINCOL === 3) node.$minItems = node.$maxItems;
				}
			}
			this.targetResourceFactory.fillTypeNode(_, node);
			if (this.collection.mappingData && [2, 4].indexOf(this.collection.mappingData.TYPLNK) >= 0 || this.collection.class.data && (this.collection.class.data.TYPCLA === 5 || this.collection.ofIndexedProperties === true)) {
				if (node.$item.$properties) node.$item.$instanceUrl = "{$instanceUrl}/" + this.name + "('{$uuid}')";
			}
		} else if (this.data.CODTYP != null) {
			if (isFactoryEditFacet) node.$x3Format = this.$x3Format; // value or undefined !

			if (!this.isExtra && this.column !== undefined || this.class.data.TYPCLA && this.class.data.TYPCLA !== 2 || this.type.data.CODCLA === 'ATEXTRA') {
				//#102160 : filter and filter_upper capabilities not supported in $edit facets
				//except for ATEXTRA
				if (this.type.data.CODCLA === 'ATEXTRA') {
					node.$capabilities = ["sort", "filter", "filter_upper"];
				} else if (this.type.data.TYPTYP === 7 || this.data.CODTYP === "ATX") {
					node.$capabilities = isFactoryEditFacet ? ["sort"] : ["sort", "filter", "filter_upper"];
				} else if ([9, 10].indexOf(this.type.data.TYPTYP) < 0) {
					node.$capabilities = isFactoryEditFacet ? ["sort"] : ["sort", "filter"];
				}
				if (this.type.data.CODCLA === 'ATEXTRA' && isFactoryEditFacet) {
					node.$capabilities.push("localize");
				}
				node.$capabilities = (node.$capabilities || []).join(',');
			}
			this.supervisor.fillTypeNode(_, this.data, node);
			if (expProData.UOMPRO) {
				node.$value = ["$type", "$precision", "$scale", "$format"].reduce((r, a) => {
					r[a] = node[a];
					node[a] = a == "$type" ? "application/x-quantity" : undefined;
					return r;
				}, {
					$title: "{$value} {$unit}"
				});

				var propData = this.findExportedProperty(this.exportedProperty.data.UOMPRO);
				node.$unit = this.ref(propData.ALIAS);
			}
			if (this.links && this.links.ALOB) {
				var acceptedTypes = this.type.atypepro.lisflg !== 2 ? [this.type.atypepro.protyp] : this.typeParams.reduce_(_, (_, r, paramData) => {
					const typpro = this.supervisor.load(_, 'Typepro', paramData.VALEUR);

					if (typpro) r.push(typpro.data.PROTYP);
					return r;
				}, []);
				if (acceptedTypes.length > 0) node.$acceptedTypes = acceptedTypes;

				if (isFactoryEditFacet) node.$url = "{$instanceUrl}/" + this.name;
				else {
					var urlKey = this.class.data.CODREP ? ["R_" + this.class.data.CODREP] : ["C_" + this.class.data.CODCLA];
					urlKey.push(this.name);
					urlKey = urlKey.concat(this.links.ALOB.keys.map(paramData => paramData.alias ? alias(paramData.alias) : paramData.value, this));

					if (this.links.ALOB.params) urlKey = urlKey.concat(this.links.ALOB.params.map(paramData => paramData.alias ? alias(paramData.alias) : paramData.value, this));

					node.$url = "{$baseUrl}/" + (this.type.data.TYPTYP === 10 ? 'C' : 'B') + "DOC('" + urlKey.join("~%C2%A8~") + "')";
				}
			}
		} else {
			return tracerJs.debug("ignoring prototype property " + this.name), undefined;
		}

		if (factoryFacet !== '$bulk' && this.links) {
			Object.keys(this.links).forEach_(_, (_, name) => {
				if (this.links[name].data.CMPLNK !== 19) {
					node.$links = node.$links || {};
					node.$links[name] = this.links[name].prototypeNode(_);
				}
			});
		}
		if (this.type && this.type.data.CODCLA === 'ATEXTRA' && isFactoryEditFacet) {
			node.$links = node.$links || {};
			node.$links.$localize = {
				$type: 'application/json;vnd.sage=syracuse',
				$title: this.supervisor.loadMess(_, 124, 232),
				$url: ''
			};
			node.$links.$localize.$url = (this.exportedProperty.data.CODPRO.indexOf('.') >= 0 ? '{$instanceUrl}/' : '{$repUrl}/') + this.exportedProperty.data.ALIAS + '/$localize';
		}
		return node;
	}
	calculateRef(_, item) {
		//Get target representation
		var codrep = "";
		const typmskrep = this.class.data.TYPMSKREP;

		switch (typmskrep) {
			case 2:
				codrep = this.type.data.DEFREPMOB;
				break;
			case 3:
				codrep = this.type.data.DEFREPTAB;
				break;
			default:
				codrep = this.type.data.DEFREPDES;
				break;
		}
		const repr = this.supervisor.load(_, 'Representation', codrep);

		if (!repr) throw new util.HttpError(404, "representation not found: " + codrep);

		var facet = '$lookup';
		if (!repr.isFacetEnabled(facet)) {
			facet = '$details';
			if (!repr.isFacetEnabled(facet)) {
				throw new util.HttpError(406, repr.name + " facet not enabled: $lookup");
			}
		}
		const reprResFact = repr.resourceFactory(_, facet);
		//Get target Class

		const targetClass = this.type.targetClass(_);

		if (targetClass == null) throw new Error("target class missing for reference: " + this.name);
		var keyParams = [];

		var path = "";
		if (!this.isExtra) {
			var tabpath = this.exportedProperty.data.CODPRO.split('.');
			path = tabpath.slice(0, tabpath.length - 1).join('.') + ".";
		}

		// EXPORTED_PROPERTIES est défini au niveau du root !
		keyParams = this.keyParams.reduce((r, paramData) => {
			const propData = this.findExportedProperty(path + paramData.VALEUR);

			if (propData) paramData.alias = propData.ALIAS;
			r.push(paramData);
			return r;
		}, []);

		item.$url = "{$baseUrl}/" + targetClass.name + "('{$key}" + "')?representation=" + codrep + "." + facet;

		item.$value = reprResFact.keyItems.map(keyitem => alias(keyitem.alias), this).join('~');

		item.$properties = {};
		reprResFact.keyItems.forEach_(_, (_, keyitem) => {
			item.$properties[keyitem.alias] = {};
			item.$key = [];
			keyParams.forEach_(_, (_, paramData) => {
				if (keyitem.prop === paramData.CODPAR) {
					var targetProp = targetClass.property(paramData.CODPAR);
					// TODO: next line could cause infinite recursion??
					this.supervisor.fillTypeNode(_, targetProp.data, item.$properties[keyitem.alias]);
					item.$properties[keyitem.alias].$maxLength = undefined;

					if (paramData.alias) {
						item[keyitem.alias] = alias(paramData.alias);
						item.$key.push(alias(keyitem.alias));
					} else {
						item[keyitem.alias] = paramData.value;
						item.$key.push(paramData.value);
					}
				}
			}, this, keyitem);
			item.$key = item.$key.join('~');
		}, this);
	}
	/* prototypeRefNode generate a 'xxx_REF' node
 for info, typical result
 "C06P02_REF": {
 	"$title": "{@28440}",
 	"$shortTitle": "{@28440}",
 	"$type": "application/x-reference",
 	"$capabilities": "sort,filter",
 	"$item": {
 		"$url": "{$baseUrl}/AQCPROR02('{$key}')?representation=AQCPROR02.$lookup",
 		"$value": "{R02P01}",
 		"$key": "{R02P01}~{R02P02}",
 		"$properties": {
 			"R02P01": {
 				"$type": "application/x-string"
 			},
 			"R02P02": {
 				"$type": "application/x-integer"
 			}
 		},
 		"R02P01": "{C06P02}",
 		"R02P02": "{C06P03}",
 		"$links": {
 			"$details": {
 				"$title": "{@28123}",
 				"$target": "",
 				"$type": "application/json;vnd.sage=syracuse",
 				"$url": "{$baseUrl}/AQCPROR02('{C06P02}~{C06P03}')?representation=AQCPROR02.$details"
 			},
 			"$lookup": {
 				"$title": "{@6109}",
 				"$type": "application/json;vnd.sage=syracuse",
 				"$url": "{$baseUrl}/AQCPROR02?representation=AQCPROR02.$lookup"
 			},
 			"$summary": {
 				"$title": "{@25036}",
 				"$target": "",
 				"$type": "application/json;vnd.sage=syracuse",
 				"$url": "{$baseUrl}/AQCPROR02('{C06P02}~{C06P03}')?representation=AQCPROR02.$summary"
 			},
 			"$query": {
 				"$title": "{@27982}",
 				"$target": "",
 				"$type": "application/json;vnd.sage=syracuse",
 				"$url": "{$baseUrl}/AQCPROR02?representation=AQCPROR02.$query"
 			}
 		}
 	}
 },*/

	prototypeRefNode(_, simpleNode) {
		const factoryFacet = this.resourceFactory.facet;
		const isFactoryEditFacet = factoryFacet === '$edit';
		const node = ["$title", "$shortTitle", "$capabilities", "$isReadOnly", "$isHidden", "$isMandatory", "$isExcluded"].reduce((r, a) => {
			// Transfert attribute from the simpleNode to the new refNode
			r[a] = simpleNode[a];
			simpleNode[a] = a == "$isExcluded" ? true : undefined;
			return r;
		}, {
			$type: "application/x-reference",
			$item: {}
		});

		if (isFactoryEditFacet) node.$maxLength = simpleNode.$maxLength;

		const item = node.$item;

		var link;
		var facet = '$lookup';
		if (this.links) {
			if (this.links.$lookup) {
				link = this.links.$lookup;
			} else if (this.links.$details) {
				link = this.links.$details;
				facet = '$details';
			}
		}

		if (link === undefined) {
			//We should not go there but still leaves the code
			// is it possible to have a reference with out lookup or details ??
			this.calculateRef(_, item);
		} else {
			item.$url = "{$baseUrl}/" + link.data.CLALNK + "('{$key}" + "')?representation=" + link.data.REPLNK + "." + '$lookup';
			var repr = this.resourceFactory.representation;

			if (link.data.REPLNK !== repr.name) {
				repr = this.supervisor.load(_, 'Representation', link.data.REPLNK);
				if (!repr) throw new util.HttpError(404, "representation not found: " + link.data.REPLNK);
			}
			var f = repr.resourceFactory(_, facet);

			item.$properties = {};

			if (f.keyItems) item.$key = [];
			item.$value = [];
			f.keyItems.forEach_(_, (_, keyitem) => {
				item.$properties[keyitem.alias] = {};
				link.keys.forEach_(_, (_, paramData) => {
					if (keyitem.prop === paramData.CODPAR) {
						if (paramData.alias === this.tag) {
							item.$value.push(alias(keyitem.alias));
						}

						var targetProp = f.class.property(paramData.CODPAR);
						this.supervisor.fillTypeNode(_, targetProp.data, item.$properties[keyitem.alias]);
						item.$properties[keyitem.alias].$maxLength = undefined;
						if (item.$properties[keyitem.alias].$value && item.$properties[keyitem.alias].$value.$type) {
							item.$properties[keyitem.alias].$type = item.$properties[keyitem.alias].$value.$type;
							item.$properties[keyitem.alias].$value = undefined;
						}
						if (paramData.ADRVAL > 1 && link.keys.length !== 1) item.$properties[keyitem.alias].$isReadOnly = true;

						if (paramData.alias) {
							item[keyitem.alias] = alias(paramData.alias);
							item.$key.push(alias(keyitem.alias));
						} else {
							item[keyitem.alias] = paramData.TYPINT === 1 ? paramData.VALEUR : paramData.value; //pb sur SAT_REF/TYP="2" et non TYP=2
							item.$key.push(paramData.value);
						}
					}
				}, this, keyitem);
			}, this);
			item.$key = item.$key.join('~');
			item.$value = item.$value.join('~');
		}
		node.$item.$links = simpleNode.$links;
		simpleNode.$links = undefined;
		return node;
	}
	makeGetReferenceKey(_) {
		const name = this.name;
		const refKeys = this.keyParams.reduce_(_, (_, r, paramData) => {
			r[paramData.CODPAR] = this.addFieldTransform(_, paramData.VALEUR);
			return r;
		}, {});

		return (_, record) => Object.keys(refKeys).map_(_, (_, k) => refKeys[k](_, record) || "").join('~');
	}
	getAtextraKey(_, instance) {
		const keyMaps = this.keyMaps(_);

		return [ident(keyMaps.IDENT1(_, instance)), ident(keyMaps.IDENT2(_, instance))].join('~');
	}
	getSql(_, colNames, tableNames, wheres, params, descs, cache, raw, sqlOpts) {
		if (!this.name) return null;
		const column = this.column;

		if (this.isAtextra) {
			cache.addProperty(_, this);
		} else if (!this.collection) {
			if (column) column.getSql(_, colNames, tableNames, wheres, params, descs, raw, sqlOpts);

			if (this.isReference()) {
				cache.addReference(_, this);
			}
		} else if (this.collection && this.collection.ofIndexedProperties) {
			// tracerJs.debug && tracerJs.debug("property.getSql " + this.name + " =>collection");
			// it's a denormalized collection :
			this.collection.getSql(_, colNames, tableNames, wheres, params, descs, cache, raw, sqlOpts);
		}
	}
	isReference(value) {
		if (value === undefined) {
			if (this.isAtextra) return false;
			if (this.type === undefined) return false; // type isn't defined for classes and representations :

			//var reference = (this.type.data.CODCLA && this.type.data.DEFREPDES); //this.type.data.CODCLA.length);
			var reference = this.type.data.TYPSELSYR === 2;

			if (reference && this.class.table) {
				// A instance cannot be a reference of itself:
				//can't be a reference if class=current main class and property in indexkeys
				if (this.class.parent && this.class.parent.curpath === "") {
					reference = !(this.class.name === this.type.data.CODCLA && this.class.keyItems.indexOf(this.name) >= 0);
				}
			}
			reference = !!reference;
			return reference;
		} else if (value = true) this.getSql = undefined; // Deactivate getSql in this case
		this.reference = value;
		return;
	}
	addFieldTransform(_, value, index, refReader) {
		const regNum$ = /=num\$\(([\w\.]*)\)/;
		const regVal$ = /=val\(([\w\.]*)\)/;

		if (value === '""' || value === 'AVOID.ACHAR') {
			return _ => "";
		} else if (value.charAt(0) === '"') {
			var result = value.substring(1, value.length - 1);
			return _ => result;
		} else if (typeof value === 'number' || /^\d+$/.test(value)) {
			var constant = parseInt(value);
			return _ => constant;
		} else if (value.substring(0, 5) === 'ACTX.') {
			var property = value.substring(5);
			return _ => glob.context.x3session.actx.get(_, property);
		} else if (regNum$.test(value) || regVal$.test(value)) {
			var match = regNum$.exec(value);
			var fct = this.addFieldTransform(_, match[1], index, refReader);
			return (_, instance) => {
				const value = fct(_, instance);
				return value ? value.toString() : "";
			};
		} else {
			if (index && refReader && index.indexOf(value) < 0) {
				refReader.columns = refReader.columns || [];
				refReader.columns.push(value);
			}
			var property = value;
			return (_, instance) => {
				var value;
				if (instance.properties && instance.properties[property]) {
					value = instance.get(_, property, true);
				} else if (instance.class && instance.class.codclaPath.indexOf('.') > 0) {
					// Class associated to a collection
					var path = property.split('.');
					if (path.length > 1) {
						property = path[path.length - 1];
						if (instance.class.properties[property]) {
							value = instance.get(_, property, true);
						}
					} else if (instance.$parent && instance.$parent.$parent) {
						var instance = instance.$parent.$parent;
						var slot = instance.slot(_, property);
						if (slot) value = slot.get(_);
					}
				} else {
					// HACK
					value = instance[property];
				}
				//dbg:console.error("field "+property+"="+ value);
				return value;
			};
		}
	}
	loadAtextra(_, instance) {
		const textId = this.getAtextraKey(_, instance);
		const zone = this.name;
		//dbg:console.log("loadAtextra "+zone+":'"+textId+"'");

		//dbg:console.log("loadAtextra ("+zone+"):"+textId);

		var ids = [textId];
		const cache = instance.cache;

		if (cache && cache.texts && cache.texts[zone]) {
			if (cache.texts[zone].texts) {
				//dbg:console.log("loadAtextra (cache) "+textId+"="+cache.texts[zone].texts[textId]);
				return cache.texts[zone].texts[textId];
			}
			ids = ids.concat(cache.texts[zone].ids);
		}
		//dbg:console.log("loadAtextra ids:"+ids);

		const param = this.supervisor.sqlDriver.param;
		const params = [];
		const wheres = [];
		const atextra = this.keyMaps(_);

		params.push(atextra.CODFIC(_, instance));
		wheres.push("CODFIC_0=" + param(params.length - 1));
		params.push(atextra.ZONE(_, instance));
		wheres.push("ZONE_0=" + param(params.length - 1));
		params.push(atextra.LANGUE(_, instance));
		wheres.push("LANGUE_0=" + param(params.length - 1));

		const gIds = ids.reduce((r, id) => {
			const parts = id.split('~');

			r[parts[0]] = r[parts[0]] || [];
			r[parts[0]].push(parts[1]);
			return r;
		}, {});

		wheres.push("((" + Object.keys(gIds).reduce((r, ident1) => {
			params.push(ident1);
			var select = "IDENT1_0=" + param(params.length - 1) + " and ";

			if (gIds[ident1].length === 1) {
				params.push(gIds[ident1][0]);
				select += "IDENT2_0=" + param(params.length - 1);
			} else {
				select += "IDENT2_0 in (" + gIds[ident1].reduce((r, ident2) => {
					params.push(ident2);
					r.push(param(params.length - 1));
					return r;
				}, []).join(',') + ")";
			}
			r.push(select);
			return r;
		}, []).join(") or (") + "))");

		//dbg:console.error("sql:" + sql);
		//dbg:console.error("params:" + params.map(p => "'"+p+"'"));

		const getTextId = record => record.IDENT1 + '~' + (record.IDENT2 || " ");

		const sql = "select IDENT1_0, IDENT2_0, ZONE_0, TEXTE_0 from ATEXTRA  where (" + wheres.join(" and ") + ")";

		//dbg:console.log("loadAtextra sql="+sql+" args=",params);	

		const texts = this.supervisor.sqlReader(_, sql, params).toArray(_).reduce((r, record) => {
			//tracerJs.debug && tracerJs.debug("record	:" + JSON.stringify(record));
			r[getTextId(record)] = record.TEXTE || "";
			return r;
		}, {});

		//dbg:console.log("loadAtextra texts=",texts);	

		if (cache && cache.texts && cache.texts[zone]) {
			// clear the list of text ids
			cache.texts[zone].ids = [];
			// Keep texts for next call
			cache.texts[zone].texts = texts;
		}
		return texts[textId] || "";
	}
	loadReference(_, instance) {
		this.loadReferenceData = this.loadReferenceData || function (_, id, instance) {
			tracerJs.debug && tracerJs.debug("loadReferenceData(" + this.name + "):" + id);

			//dbg:console.error("loadReferenceData(" + this.name + "):" + id);

			const addTextTransform = (_, superv, attribute, reference, column, refReader) => {

				if (!column) return;

				if (reference.properties[column].isAtextra) {
					var index = reference.tableIndex.sqlNames().map(key => key.substring(0, key.length - 2));
					var property = util.find(reference.data.PROPERTIES, 'FLDCLA', column);
					var atextra = property.PARAM_FLDS.filter(paramData => paramData.TYPPAR === 1 && paramData.TYPKEY === 2).reduce_(_, (_, r, paramData) => {
						r[paramData.CODPAR] = this.addFieldTransform(_, paramData.VALEUR, index, refReader);
						return r;
					}, {});

					return (_, reader, writer) => {
						const param = superv.sqlDriver.param;
						const params = [];
						const wheres = [];
						const rs = reader.readAll(_);

						if (rs && rs.length) {
							params.push(atextra.CODFIC(_, rs[0]));
							wheres.push("CODFIC_0=" + param(params.length - 1));
							params.push(atextra.ZONE(_, rs[0]));
							wheres.push("ZONE_0=" + param(params.length - 1));
							params.push(atextra.LANGUE(_, rs[0]));
							wheres.push("LANGUE_0=" + param(params.length - 1));

							var getTextId = function (record) {
								return record.IDENT1 + '~' + (record.IDENT2 || " ");
							};
							wheres.push("((" + rs.reduce_(_, (_, r, record) => {
								const id1 = ident(atextra.IDENT1(_, record.record));
								const id2 = ident(atextra.IDENT2(_, record.record));

								params.push(id1);
								params.push(id2);
								record.reference[attribute] = id1 + '~' + id2;
								r.push("IDENT1_0=" + param(params.length - 2) + " and " + "IDENT2_0=" + param(params.length - 1));
								return r;
							}, []).join(") or (") + "))");

							var sql = "select IDENT1_0, IDENT2_0, ZONE_0, TEXTE_0 from ATEXTRA  where (" + wheres.join(" and ") + ")";

							var texts = superv.sqlReader(_, sql, params).toArray(_).reduce((r, text) => {
								r[getTextId(text)] = text.TEXTE;
								return r;
							}, {});

							rs.forEach_(_, (_, record) => {
								// update the reference:
								record.reference[attribute] = texts[record.reference[attribute]];
								//pipe the record
								writer.write(_, record);
							});
						}
					};
				} else {
					refReader.columns = refReader.columns || [];
					refReader.columns.push(column);

					return (_, reader, writer) => {
						var record;
						while (record = reader.read(_)) {
							record.reference[attribute] = record.record[column];
							writer.write(_, record);
						}
					};
				}
				return;
			}

			try {
				var ids = {};
				ids[id] = null;
				if (instance.cache && instance.cache.references) {
					ids = Object.keys(instance.cache.references[this.name].$ids).reduce((r, id) => {
						r[id] = instance.cache.references[this.name].$ids[id];
						return r;
					}, ids);
				}
				var reference = this.supervisor.load(_, 'Class', this.type.data.CODCLA);
				if (!reference) return;

				//TODO : "COLDEC", "COLLNG"
				var refMaps = {
					SYMBOL(column) {
						return item => item.reference.$symbol = item.record[column] || "";
					},
					COLFMT(column) {
						return item => {
							var colfmt = item.record[column];
							if (colfmt) {
								colfmt = colfmt.split('.');
								item.reference.$precision = parseInt(colfmt[0], 10);
								item.reference.$scale = colfmt.length > 1 ? parseInt(colfmt[1], 10) : 0;
							}
						};
					}
				};
				var refReader = Object.keys(refMaps).reduce((r, field) => {
					if (reference.table.data[field]) {
						r.columns = r.columns || [];
						var column = reference.table.data[field];
						r.columns.push(column);
						r.maps = r.maps || [];
						if (refMaps[field]) {
							r.maps.push(refMaps[field](column));
						}
					}
					return r;
				}, {});

				var titleTransform = addTextTransform(_, this.supervisor, "$title", reference, reference.table.data.INTITC, refReader);
				var descTransform = addTextTransform(_, this.supervisor, "$description", reference, reference.table.data.INTIT, refReader);

				var reader;
				if (refReader.columns) {
					// The reference table has to be read first :
					var param = this.supervisor.sqlDriver.param;
					var params = [];
					var wheres = [];

					var names = reference.tableIndex.sqlNames();

					const fields = names.map(name => name.substring(0, name.length - 2));
					var getRecordId = record => fields.map(field => record[field]).join('~');

					var idsKeys = Object.keys(ids);
					if (names.length === 1) {
						wheres.push(names[0] + " in (" + idsKeys.map(id => {
							params.push(id);
							return param(params.length - 1);
						}) + ")");
					} else {
						wheres.push("(" + idsKeys.map(id => {
							var n = 0;
							return id.split('~').reduce((r, part) => {
								params.push(part);
								r.push(names[n++] + "=" + param(params.length - 1));
								return r;
							}, []).join(" and ");
						}).join(") or (") + ")");
					}
					// add other colums :
					names = names.concat(refReader.columns.map(column => column + '_0'));
					var sql = "select " + names.join(',') + " from " + reference.table.name + " where (" + wheres.join(" and ") + ")";

					//dbg:console.error("ref sql:" + sql);
					//dbg:console.error("ref params:" + params);

					// create the reader :
					reader = this.supervisor.sqlReader(_, sql, params) //
					.map((_, record) => {
						const item = {
							id: getRecordId(record),
							record: record,
							reference: {}
						};
						//apply reference maps:
						refReader.maps && refReader.maps.forEach(map => {
							map(item);
						});
						return item;
					});
				}
				if (titleTransform || descTransform) {
					if (!reader) {
						//We need reader
						//dbg:console.log("932 ids:"+Object.keys(ids));
						const keys =  Object.keys(ids);
						const index = reference.tableIndex.sqlNames().map(key => key.substring(0, key.length - 2));
						reader = ez.devices.generic.empty.reader.transform((_, reader, writer) => {
							keys.forEach_(_, (_, id) => {
								const keys = id.split('~');
								const record = {
									id: id,
									record: {},
									reference: {}
								};

								for (var i = 0; i < index.length; i++) {
									record.record[index[i]] = keys[i];
								}
								writer.write(_, record);
							});
						});
					}

					if (titleTransform) reader = reader.transform(titleTransform);
					if (descTransform) reader = reader.transform(descTransform);
				}
				if (!reader) return;

				// Pipe elements in the table of references :
				var references = instance.cache && instance.cache.references ? instance.cache.references[this.name] : {};
				reader.pipe(_, ez.devices.generic.writer((_, record) => {
					if (record) references[record.id] = record.reference;
				}));

				// clear the list of $ids:
				references.$ids = {};
			} catch (e) {
				util.traceException(e);
			} finally {
				tracerJs.debug && tracerJs.debug("loadReferenceData:" + JSON.stringify(references[id]));
				return references[id];
			}
		};

		const getReferenceKey = this.makeGetReferenceKey(_);
		const refId = typeof getReferenceKey === "function" && getReferenceKey(_, instance) || "";

		tracerJs.debug && tracerJs.debug("loadReference " + this.name + " id:" + refId);

		//dbg:console.error("loadReference " + this.name + " id:" + refId);
		if (!refId.length) return {};

		var reference = instance.cache && instance.cache.references ? instance.cache.references[this.name][refId] : undefined;
		reference = reference || this.loadReferenceData(_, refId, instance);
		if (instance.cache && instance.cache.references) instance.cache.references[this.name][refId] = reference;
		return reference;
	}
};

export const Constructor = Property;