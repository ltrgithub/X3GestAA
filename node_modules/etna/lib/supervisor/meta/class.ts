import { _ } from 'streamline-runtime';
import * as fs from 'fs';
import * as fsp from 'path';
import * as ez from 'ez-streams';
import { Record } from '../../engine/drivers/types';
import * as util from '../util';
const glob = require('streamline-runtime').globals;
import * as types from '../../engine/runtime/types';
import * as db from '../../engine/runtime/db';
import * as utilRuntime from '../../engine/runtime/util';
import * as basic from '../../engine/runtime/basic';
import * as tuuid from '../../engine/runtime/uuid';
import * as tdate from '../../engine/runtime/tdate';
import * as tdatetime from '../../engine/runtime/tdatetime';
import * as variables from '../../engine/runtime/variables';
import * as activ from './activ';
const filterHelpers = require("syracuse-sdata-parser/lib/json-converter");
import * as constants from '../constants';
import { Helper } from '../util';
import { Cache } from '../cache';
import * as utilDriver from '../../engine/drivers/util';
import { BaseClass } from './baseClass';
import { Property } from './property';
import { Collection } from './collection';
import { Resource } from '../dyn/resource';
import { Column, ColumnDesc } from './column';
import { Table } from './table';
import { Index } from './index';
import * as type from '../meta/type';
import { newSlotReference } from '../dyn/slotReference';
import { newSlotCollection } from '../dyn/slotCollection';
import { newSlotInstance, Instance } from '../dyn/instance';
import { X3Error } from '../../engine/runtime/errors';
const trim = utilDriver.trim;
const tracerJs = require('syracuse-core').getTracer("etna.supervisor");
import { cacheMethods } from '../builtins/ACTXCACHE';
import { MappingData } from '../mapping';
import { Supervisor } from '../supervisor';
import { Type, TypeLob } from './type';
import * as http from '../http';

import { ClassMeta, PropertyMeta, ClassLinkMeta, StdMethodMeta } from '../metadata/class';
import { ColumnMeta } from '../metadata/table';

function asTypeLob(x: Type): TypeLob { return util.any(x); }

function bulkWriter(httpContext: http.HttpContext) {
	var sep: string;
	return ez.devices.generic.writer((_: _, resource: Resource) => {
		if (!sep) {
			httpContext.response.writeHead(200, {
				"content-type": "application/json"
			});
			httpContext.response.write(_, '[');
		}
		if (resource === undefined) {
			httpContext.response.end("]");
		} else {
			httpContext.response.write(_, (sep || '') + JSON.stringify(resource.dataNode(_)), "utf8");
		}
		sep = ',';
		return this;
	});
};

const typDonmet2EtnaType: { [id: number]: string } = {
	1: "D",
	2: "S",
	3: "I",
	4: "N",
	5: "T",
	6: "B"
};

export const systemProperties: PropertyMeta[] = [{
	FLDCLA: "ASTALIN",
	CODTYP: "C",
	LONG: 4
}, {
	FLDCLA: "AORDER",
	CODTYP: "C",
	LONG: 4
}, {
	FLDCLA: "AUUID",
	CODTYP: "AUUID"
}, {
	FLDCLA: "CREUSR",
	CODTYP: "AUS"
}, {
	FLDCLA: "UPDUSR",
	CODTYP: "AUS"
}, {
	FLDCLA: "CREDATTIM",
	CODTYP: "ADATIM"
}, {
	FLDCLA: "UPDDATTIM",
	CODTYP: "ADATIM"
}, {
	FLDCLA: "_AFCRIGHT",
	CODTYP: "A",
	LONG: 30
}, {
	FLDCLA: "UPDTICK",
	CODTYP: "L",
	LONG: 0
}];

export interface ClassDataChildren {
	ownMapping: MappingData;
	LINKS: ClassLinkMeta[];
	MAPS: ClassMap[];
	codclaPath: string;
	parent: Class;
	curpath: string;
}

export interface ClassMap {

}

export type TypeMapper = (_: _, row: Record) => any;

export interface Select {
	$query?: any;
	$orderBy?: any;
	$params?: any;
}

// this interface is implemented by builtin classes
export interface JsInterface {
	AQUERY: (_: _,  select: Select) => Record[];
	//[name: string]: (_: _,  select: Select) => Row[];
}

export interface StdMethods {
	AREAD?: StdMethodMeta;
	AINSERT?: StdMethodMeta;
	AUPDATE?: StdMethodMeta;
	ADELETE?: StdMethodMeta;
}

export interface MethodParam {
	type: string; //??
	index(args: any[]): number;
	get(args: any[]): any;
	set(_: _, args: types.Expression<any>[], value: any): types.Expression<any>;
}

export interface Method {
	type: "$OPERATIONS" | "$METHODS";
	params: { [name: string]: MethodParam };
	buildArgs(_: _,  instance: Instance): types.ProgArgs;
	getServiceArgs(_: _,  key: string, qs: any): any;
}

export interface Methods {
	[name: string]: Method;
}

export class Class extends BaseClass {
	supervisor: Supervisor;
	class: Class;
	parent: Class;
	relations: { [name: string]: Collection };
	table: Table;
	keyItems: string[];
	group: string;
	curpath: string;
	codclaPath: string;
	data: ClassMeta;
	reader: (_: _, parent: Class, select: Select, max: number, mapper?: TypeMapper) => ez.Reader<Instance>;
	read: (_: _, instance: Instance, key: string) => number;
	jsModules: any[];
	jsInterface: JsInterface;
	jsName: string;
	isInterface: boolean;
	queryInstances: (_: _, select: Select, max: number) => ez.Reader<Instance>;
	_scripts: any[];
	mandatoryProperties: string[];
	stdMethods: StdMethods;
	methods: Methods;
	
	static cast(clas: BaseClass): Class { return util.any(clas); }

	constructor(superv: Supervisor, data: ClassMeta, group: string) {
		super(superv, data);

		this.relations = {};
		this.parent = null;
		this.keyItems = data.KEYINT ? data.KEYINT.split('+') : [];
		this.group = group;
		this.cache = {};
		this.curpath = "";
		this.codclaPath = this.data.CODCLA;
		this.class = this;
		if (this.data.PARAM_DEFS) {
			this.data.PARAM_DEFS = this.data.PARAM_DEFS.sort((ep1, ep2) => {
				const info1 = ep1.CODE + "_" + (ep1.TYPKEY === 2 ? "A" : "B") + ep1.NOPAR;
				const info2 = ep2.CODE + "_" + (ep2.TYPKEY === 2 ? "A" : "B") + ep2.NOPAR;

				if (info1 < info2) return -1;
				if (info1 > info2) return 1;
				return 0;
			});
		}

		// Default behaviors
		this.reader = this.sqlReader;
		this.read = this.sqlRead;
		this.membersByJsName = {};
		this.jsModules = [];
	}
	get $$type() {
		return "Class";
	}
	get isSearchable() {
		return this.data && this.data.FLGSEARCH && this.data.FLGSEARCH === 2;
	}
	get name() {
		return this.data.CODCLA;
	}
	get index() {
		return this._index;
	}
	get tableIndex() {
		return this.table && this.data.INDREF ? this.table.index(this.data.INDREF) : null;
	}
	title(_: _, lan: string) {
		return this.supervisor.loadText(_, this.data.INTCLA, lan);
	}
	init(_: _) {
		if (this.properties) return this;
		if (this.data.dataChildren) {
			if (this.data.dataChildren.ownMapping) {
				// WHAT??
				// this.data is what we read from mongo - don't use it to track table
				this.data.table = this.supervisor.load(_, 'Table', this.data.dataChildren.ownMapping.TABLNK);
				this.data.LINKS = this.data.dataChildren.LINKS ? this.data.LINKS.concat(this.data.dataChildren.LINKS) : this.data.LINKS;
				this.data.MAPS = this.data.dataChildren.MAPS ? this.data.MAPS.concat(this.data.dataChildren.MAPS) : this.data.MAPS;
			}
			this.data.codclaPath = this.data.dataChildren.codclaPath;
			this.parent = this.data.dataChildren.parent;
			this.curpath = this.data.dataChildren.curpath;
		}
		tracerJs.debug && tracerJs.debug("Init de  C_" + this.data.CODCLA + " " + this.curpath);
		if (this.parent) tracerJs.debug && tracerJs.debug(" parent = '" + this.parent.data.CODCLA + "'");
		const tableCode = this.data.TABREF || this.data.CODCLA;

		tracerJs.debug && tracerJs.debug("class this.data.TYPCLA:" + this.data.TYPCLA + "--" + this.data.CODCLA);
		var jsInterface: JsInterface;
		this.isInterface = false;
		this.queryInstances = this.queryInstancesSql;

		if (fs.exists(fsp.join(__dirname, '../builtins/' + this.data.CODCLA + '.ts'), _, _)) {
			jsInterface = require("etna/lib/supervisor/builtins/" + this.data.CODCLA);
			if (jsInterface.AQUERY) {
				this.reader = this.jsReader;
				this.jsInterface = jsInterface;
			}
		}
		if (this.data.TYPCLA === 2) {
			// 2 for persistent class
			this.table = this.table || this.supervisor.load(_, 'Table', tableCode);
			if (!this.table) throw new Error("table not found: " + tableCode);
		} else if (this.data.table) {
			this.table = this.data.table;
		}

		if (this.data.TYPCLA === 5) {
			// This class is an interface
			this.read = this.intRead;
			this.insert = this.intInsert;
			this.update = this.intUpdate;
			this.delete = this.intDelete;
			this.isInterface = true;
			if (!this.jsInterface) this.queryInstances = this.queryInstancesInt;
		}

		this.jsName = this.data._proxyName || this.name;

		const supervPropertiesFields = systemProperties.reduce((r, property) => {
			r.push(property.FLDCLA);
			return r;
		}, []);

		var supervProperties = systemProperties;
		// if(this.data.PROPERTIES) supervProperties = supervProperties.concat(this.data.PROPERTIES);
		if (this.data.PROPERTIES) supervProperties = this.data.PROPERTIES.concat(supervProperties);
		this.properties = supervProperties.reduce_(_, (_, r, propData) => {
			var name = propData.FLDCLA;
			if (!((this.group || "") !== (!propData.LNKCLA && propData.FLDGRP || "")) || supervPropertiesFields.indexOf(name) >= 0) {

				tracerJs.debug && tracerJs.debug("+" + this.data.CODCLA + "." + name);

				if (r[name] && supervPropertiesFields.indexOf(name) < 0) throw new Error("duplicate property " + name);

				r[name] = this.supervisor.new(_, 'Property', this, propData);

				r[name].toControl = ["ASTALIN", "AORDER", "_AFCRIGHT", "UPDTICK"].indexOf(name) < 0;
				r[name].jsName = propData._proxyName || name;
				this.membersByJsName[r[name].jsName] = r[name];

				if (propData.OBLIG === 2) {
					this.mandatoryProperties = this.mandatoryProperties || [];
					this.mandatoryProperties.push(name);
				}
				if (r[name].isReference()) {
					// Add a property :
					tracerJs.debug && tracerJs.debug(" " + this.data.CODCLA + "." + name + " is a reference");
					name = r[name].ref(name);
					r[name] = this.supervisor.new(_, 'Property', this, propData, newSlotReference);
					r[name].isReference(true);
					r[name].jsName = r[name].data._proxyName + 'Ref';
				}
			}
			return r;
		}, util.any({}));

		this.relations = {};
		this.data.COLLECTIONS && this.data.COLLECTIONS.forEach_(_, (_, data) => {
			tracerJs.debug && tracerJs.debug("Class collection:" + data.CODCOL);
			const coln: Collection = this.relations[data.CODCOL] = this.supervisor.new(_, 'Collection', this, data);
			const name = data.CODCOL;

			var p = this.properties[name];
			if (!p) {
				this.relations[name] = coln;
				p = this.properties[name] = this.supervisor.new(_, 'Property', this, {
					FLDCLA: name
				}, newSlotCollection, coln);

				// generate synthetic class for group of indexed properties
				coln.ofIndexedProperties = true;
				coln.class = this.supervisor.new(_, 'Class', {
					CODCLA: this.data.CODCLA + "." + name,
					TYPCLA: 1, //5,
					PROPERTIES: this.data.PROPERTIES.filter(propData => propData.FLDGRP === name),
					PARAM_FLDS: this.data.PARAM_FLDS,
					COLLECTIONS: [],
					table: this.table
				}, name);
				//Calculate count
				if (data.ACTGRP && data.ACTGRP !== "") {
					var activ = this.supervisor.load(_, 'Activ', data.ACTGRP);
					coln.count = activ.dimension;
				} else if (data.MAXCOL > 0) {
					coln.count = data.MAXCOL;
				}
				const colnClass: Class = util.any(coln.class);
				if (!coln.count) {
					coln.count = 1;
					colnClass.data.PROPERTIES.forEach_(_, (_, propData) => {
						if (coln.class.table) {
							var col: ColumnMeta = util.find(coln.class.table.data.COLUMNS, 'CODZONE', propData.FLDCLA);
							if (col) {
								var dime = 0;
								if (col.CODACT && col.CODACT !== "") {
									var activcol = this.supervisor.load(_, 'Activ', col.CODACT);
									dime = activcol.dimension;
								}
								dime = Math.max(dime, col.DIME);
								coln.count = Math.max(dime, coln.count);
							}
						}
					});
				}
				//
				//coln.class.parent = this;
				if (colnClass.data.PROPERTIES) {
					colnClass.data.PROPERTIES.forEach_(_, (_, prop) => {
						if (colnClass.data.PARAM_FLDS) {
							colnClass.data.PARAM_FLDS.forEach_(_, (_, fld) => {
								if (fld.FLDCLA === prop.FLDCLA && fld.VALEUR) {
									if (name + "." === fld.VALEUR.substring(0, name.length + 1)) {
										fld.VALEUR = fld.VALEUR.substring(name.length + 1);
									}
								}
							});
						}
					});
				}
			} else {
				//mapping can be on main class
				var wcurpath = name;
				var wcurcla: Class = this;
				while (wcurcla.data.TYPCLA !== 2 && wcurcla.parent) {
					wcurpath = this.curpath + "." + wcurpath;
					wcurcla = wcurcla.parent;
				}
				var mapping = wcurcla.data.LINKS && util.find(wcurcla.data.LINKS, 'REFLNK', wcurpath);
				//console.error(this.name+" col:"+data.CODCOL+ " wcurpath:"+wcurpath+" mapping:"+!!mapping);

				var targetName: string;
				if (mapping && mapping.MAPS) {

					// Memorize maps at the propeties level
					mapping.MAPS.filter(map => !!map.PROMAP && !!map.KEYMAP).forEach(map => {
						this.properties[map.PROMAP].proMaps = this.properties[map.PROMAP].proMaps || [];
						this.properties[map.PROMAP].proMaps.push(map);
					});

					coln.mappingData = mapping;

					targetName = mapping.CLALNK;
				} else {
					targetName = p.data.LNKCLA;
				}

				if (!targetName) throw new Error("cannot find target name for collection " + name);
				tracerJs.debug && tracerJs.debug("coln.mappingData  " + JSON.stringify(coln.mappingData));

				var clas = this.supervisor.load(_, 'Class', this.codclaPath + "." + targetName, {
					ownMapping: coln.mappingData,
					//normally not needed LINKS: this.data.LINKS, // inherith from LINKS defined at the top level
					//normallynot needed MAPS: this.data.MAPS, // inherith from MAPS defined at the top level
					codclaPath: this.codclaPath + "." + targetName,
					curpath: name, //(this.curpath) ? this.curpath + "." + name : name
					parent: this
				});
				if (!clas) throw new Error("target class missing for collection " + name);

				coln.class = clas;
				if (coln.mappingData && coln.mappingData.TYPLNK === 3) {
					// relation = class <-> class (replace p:)
					tracerJs.debug && tracerJs.debug(this.codclaPath + "." + name + " is a class");

					this.properties[name] = this.supervisor.new(_, 'Property', this, {
						FLDCLA: name
					}, newSlotInstance, coln);
				} else {
					this.properties[name] = this.supervisor.new(_, 'Property', this, {
						FLDCLA: name
					}, newSlotCollection, coln);
				}
			}
			//if (!data._proxyName) throw new Error("_proxyName missing: " + name);
			this.properties[name].jsName = data._proxyName;
			this.membersByJsName[this.properties[name].jsName] = this.properties[name];
		}, this);

		this.stdMethods = this.data.STD_METHODS ? this.data.STD_METHODS.reduce_(_, (_, r, method) => {
			if (method.ENAMETSTD === 2 && activ.getActiv(_, this.supervisor, method.ACTMETSTD) > 0) {
				switch (method.CODMETSTD) {
					case 'C':
						r.AINSERT = method;
						break;
					case 'R':
						r.AREAD = method;
						break;
					case 'U':
						r.AUPDATE = method;
						break;
					case 'D':
						r.ADELETE = method;
						break;
				}
			}
			return r;
		}, util.any({})) : {};

		this.methods = this.data.METHODS ? this.data.METHODS.reduce_(_, (_, r, method) => {
			var noPar = 0;
			r[method.CODMET] = {
				type: method.FLGOPE === 2 ? "$OPERATIONS" : "$METHODS",
				params: method.PARAM_DEFS ? method.PARAM_DEFS.reduce_(_, (_, r, param) => {
					const np = noPar;
					param.NOPAR = noPar++;
					r[param.CODPAR] = {
						type: "L" + type.typTyp2EtnaType[param.TYPINTPAR],
						index(args: any[]) {
							return args && args.length >= np ? np : -1;
						},
						get(args: any[]) {
							return args && args[np] ? args[np] : variables.types[type.typTyp2EtnaType[param.TYPINTPAR]].default;
						},
					};
					if (param.MODPAR === 1) {
						///1:variable arg 2:value arg 3:constant
						r[param.CODPAR].set = (_: _, args: types.Expression<any>[], value: any) => {
							const arg = args[np];

							arg(_, variables.vOperations.SET, value);
							return args[np];
						};
					}
					return r;
				}, util.any({})) : {},
				buildArgs(_: _,  instance: Instance) {
					const args: types.ProgArgsVars = {
						CURPTH: {
							type: "LS",
							value: ""
						},
						THIS: {
							type: "LY",
							value: instance
						}
					};

					args[method.FLGOPE === 2 ? "AOPERATION" : "AMETHOD"] = {
						type: "LS",
						value: method.CODMET
					};

					// add keys
					if (method.FLGOPE && method.PARAM_DEFS) {
						method.PARAM_DEFS.filter(param => param.TYPKEY === 2).forEach_(_, (_, param) => {
							args[param.CODPAR] = {
								value: instance.get(_, param.CODPAR),
								type: "L" + type.typTyp2EtnaType[param.TYPINTPAR],
								typ: param.TYPINTPAR
							};
						});
					}

					if (method.DONMET) {
						args.ARET_VALUE = {
							type: "L" + typDonmet2EtnaType[method.DONMET],
							value: variables.types[typDonmet2EtnaType[method.DONMET]].default,
							set(_: _,  value: any) {}
						};
					}
					// TODO: improve typing: pass path as a variable
					util.any(args).path = [];
					// set path for x3js
					// TODO: improve typing: inst should not be any
					for (var inst: any = instance; inst.$parent; inst = inst.$parent.$parent) {
						util.any(args).path.unshift(inst.$parent.jsName);
					}
					return args;
				},
				getServiceArgs(_: _,  key: string, qs: any) {
					const keyValues = key.split('~');

					var noKey = 0;

					const newArgs = method.PARAM_DEFS ? method.PARAM_DEFS.reduce_(_, (_, r, param) => {
						const defaultValue = variables.types[type.typTyp2EtnaType[param.TYPINTPAR]].default;

						if (param.TYPKEY === 2) {
							r.push({ value: keyValues[noKey++] || defaultValue });
						} else {
							var varObj = defaultValue;
							if (qs[param.CODPAR]) {
								var val = qs[param.CODPAR];
								if (val === '""') val = defaultValue;
								varObj = variables.types[type.typTyp2EtnaType[param.TYPINTPAR]].set(param.CODPAR, param.CODPAR, val);
							}
							r.push({ value: varObj, noset: true });
						}
						return r;
					}, []) : [];
					//dbg:console.log("getServiceArgs:",newArgs);

					return newArgs;
				},
				getServiceReturn(_: _,  res: any) {
					const newReturn = util.any({});

					newReturn.$type = variables.types[typDonmet2EtnaType[method.DONMET]].jsonDefaultType;
					if (method.DONMET === 6) {
						newReturn.$value = res.x3IsEmpty() === true ? "" : res.x3ToBase64();
					} else if (method.DONMET === 3 || method.DONMET === 4) {
						newReturn.$value = res.x3ToDouble().valueOf();
					} else {
						newReturn.$value = res.x3IsZero() ? "" : res.x3ToJson && res.x3ToJson() || res.x3ToString && res.x3ToString() || res.toString();
					}
					return newReturn;
				},
			};
			return r;
		}, util.any({})) : {};

		// Add cache methods to the class if necessary
		if (this.data.FLGBUFFER === 2) {
			Object.keys(cacheMethods).forEach(method => {
				util.any(this)[method] = util.any(cacheMethods)[method];
			});
		}
		return this;
	}
	fixJsNames(_: _,  js: any) {
		if (js.properties) Object.keys(js.properties).forEach_(_, (_, name) => {
			const jsProp = js.properties[name];
			if (jsProp.dictCode) {
				const prop = this.properties[jsProp.dictCode];
				if (prop == null) throw new Error(`${ name }: invalid dictCode: ${ jsProp.dictCode }`);
				prop.jsName = name;
				this.membersByJsName[name] = prop;
			}
		});
		if (js.relations) Object.keys(js.relations).forEach_(_, (_, name) => {
			const jsRel = js.relations[name];
			if (jsRel.dictCode) {
				const rel = this.relations[jsRel.dictCode];
				if (rel == null) throw new Error(`${ name }: invalid dictCode: ${ jsRel.dictCode }`);
				rel.data._proxyName = name;
				this.membersByJsName[name] = rel;
			}
		});
	}

	get jsPath() {
		return this.supervisor.jsPath(this.data.MODULE, this.jsName);
	}
	get moduleName() {
		return this.supervisor.moduleName(this.data.MODULE);
	}
	/* 
 Add methods to an instance
 */
	addMethods(instance: Instance) {
		Object.keys(this.stdMethods).forEach(stdMethod => {
			util.any(instance)[stdMethod] = util.any(instance)["$" + stdMethod];
		});

		const xmeth = (clas: Class, method: string, methodType: string) => {
			methodType = methodType || "$METHODS";
			return function (_: _) {
				const args = Array.prototype.slice.call(arguments).length > 0 ? Array.prototype.slice.call(arguments).slice(1) : [];
				const meth = clas.methods[method];
				const xmethName = "xmet" + method;
				const instance = this;

				if (instance[xmethName]) {
					return instance["xmethMethods"](_, xmethName, args);
				}

				// Get arguments values :
				const vals = basic.instructions.A(args)(_);
				//dbg:console.log("vals:",vals);

				if (vals.length > 0 && Object.keys(meth.params).length > vals.length) {
					throw new X3Error(69, "parameter count mismatch: expected " + (Object.keys(meth).length - 1) + ", got " + vals.length);
				}

				var methArgs = meth.buildArgs(_, instance);

				// add parameters:
				methArgs = Object.keys(meth.params).reduce((r, p) => {
					if (meth.params[p].type) {
						r[p] = {
							type: meth.params[p].type,
							value: meth.params[p].get(vals),
							isParam: true
						};
						if (meth.params[p].set) r[p].set = meth.params[p].set;
					}
					return r;
				}, methArgs);

				//dbg:console.log("1.methArgs:",methArgs);
				const status = this.runScripts(_, methodType, methArgs);

				// Manage variable arguments :

				Object.keys(meth.params).filter(arg => !!meth.params[arg].set).forEach_(_, (_, arg) => {
					const index = meth.params[arg].index(args);
					const noset = index >= 0 && args[index].noset === true;

					if (noset === false) {
						meth.params[arg].set(_, args, methArgs[arg].value);
					}
				});
				//dbg:console.log("methArgs.2:",methArgs);
				return methArgs.ARET_VALUE ? methArgs.ARET_VALUE.value : status;
			};
		};

		instance.methods["xmetAGETMAXERRORTXT"] = xmeth(this, "AGETMAXERRORTXT", "$OPERATIONS");
		instance.methods["xmetAGETNEXTINFOS"] = xmeth(this, "AGETNEXTINFOS", "$OPERATIONS");

		Object.keys(this.methods).forEach(method => {
			instance.methods = instance.methods || {};
			instance.methods["xmet" + method] = xmeth(this, method, this.methods[method].type);
		});
	}

	check(_: _,  facet: string) {
		if (!this.isActivated(_)) throw new util.HttpError(406, this.supervisor.loadMess(_, 140, 31) + ' ' + this.data.CODCLA + " (" + this.data.CODACT + ")");
		if (facet && /^\$(search|bulk|query|lookup|details|summary|edit)$/.test(facet)) {
			if (!this.stdMethods.AREAD) throw new util.HttpError(406, this.supervisor.loadMessParams(_, 149, 31, this.supervisor.loadMess(_, 7983, 7), this.data.CODCLA));
			if (facet === "$edit" && !this.stdMethods.AINSERT && !this.stdMethods.AUPDATE) {
				throw new util.HttpError(406, this.supervisor.loadMessParams(_, 149, 32, this.supervisor.loadMess(_, 7983, 1), this.supervisor.loadMess(_, 7983, 10), this.data.CODCLA));
			}
		}
	}
	keyExpression() {
		return this.table ? this.tableIndex.keyExpression() : "{" + this.data.KEYINT + "}";
	}

	createInstance(_: _,  qs?: void) {
		return this.supervisor.new(_, 'Instance', this).afterCreate(_);
	}

	readInstance(_: _,  parent: Class, key: Select) {
		// x3js API, key is value, array or object
		const instances = this.reader(_, parent, key, 1).toArray(_);

		return instances[0];
	}

	queryExpToSelect(_: _,  exp: any, params: any[], forJs?: boolean) {
		const map: { [name: string]: string; } = {
			'$eq': '=',
			'$ne': '!=',
			'$gt': '>',
			'$gte': '>=',
			'$lt': '<',
			'$lte': '<=',
			'$regex': 'like',
			'$like': 'like'
		};
		const param = this.supervisor.sqlDriver.param;

		return Object.keys(exp).reduce_(_, (_, r, k) => {
			const propExp = exp[k];

			var expColumn: (column: string) => string = column => column;

			const match = k.match(/upper\((\w*)\)/);

			if (match) {
				k = match[1];
				expColumn = column => 'UPPER(' + column + ')';
			}
			const prop = forJs ? this.membersByJsName[k] : this.properties[k];

			if (!prop) throw new Error("Missing property " + this.name + '.' + k);
			const column = prop.column.sqlName();
			const hasExp = typeof propExp === 'object' && propExp !== null && Object.keys(propExp).some(key => key.charAt(0) === '$') || false;
			const operators = hasExp ? propExp : {
				$eq: propExp
			};

			r.push(Object.keys(operators).reduce((r, operator) => {
				if (map[operator]) {
					var sqlOperator = map[operator];
					var value = operators[operator];
					var valueType = typeof value;

					if (value === null || Array.isArray(value) && !value.length) return r;

					if (valueType === 'boolean') {
						value = value ? 2 : 1;
					} else if (prop.etnaType === 'D' && valueType === 'string') {
						value = new Date(value);
					} else if (prop.etnaType === 'E') {
						value = tdatetime.x3Parse(value).toJsDate();
					} else if (operator === '$regex') {
						if (value.charAt(0) === '^') value = value.substring(1);
						else value = '%' + value;
						value = value.replace(/\.\*/g, '%');
						if (!value.endsWith('%')) value += '%';
					}
					params.push(value);
					r.push(expColumn(column) + ' ' + sqlOperator + ' ' + param(params.length - 1));
				} else if (operator !== "$options") {
					throw new Error('invalid query operator: ' + operator);
				}
				return r;
			}, []).join(" and "));
			return r;
		}, []).join(" and ");
	}

	queryToSelect(_: _,  query: any, params: any[], forJs?: boolean) {
		const operator = query.$or ? "or" : query.$and ? "and" : undefined;

		if (operator) {
			return query['$' + operator].reduce_(_, (_: _, r: any[], exp: any) => {
				const select = this.queryToSelect(_, exp, params, forJs);

				if (select.length) r.push('(' + select + ')');
				return r;
			}, []).join(' ' + operator + ' ');
		}
		return this.queryExpToSelect(_, query, params, forJs);
	}

	queryInstancesSql(_: _,  select: Select, max: number) {
		return this.reader(_, null, select, max, null);
	}

	queryInstancesInt(_: _,  select: Select, max: number) {
		const z = db.instructions;
		const expToWhere = (exp: any) => {
			// console.log("expToWhere:",exp);
			const wheres = Object.keys(exp).reduce((r, prop) => {
				const propExp = exp[prop];
				const hasExp = typeof propExp === 'object' && propExp !== null && Object.keys(propExp).some(key => key.charAt(0) === '$') || false;
				const operators = hasExp ? propExp : { $eq: propExp };

				r.push(Object.keys(operators).reduce((r, operator) => {
					var sqlOp = z.SQLEQ;
					switch (operator) {
						case '$eq':
							sqlOp = z.SQLEQ;break;
						case '$ne':
							sqlOp = z.SQLNE;break;
						case '$gt':
							sqlOp = z.SQLGT;break;
						case '$gte':
							sqlOp = z.SQLGE;break;
						case '$lt':
							sqlOp = z.SQLLT;break;
						case '$lte':
							sqlOp = z.SQLLE;break;
					}
					return sqlOp(z.SQLCV('?', 'LNK_', prop), basic.instructions.C(propExp[operator]));
				}, {}));
				return r;
			}, []);

			return wheres;
		};

		const selectToWhere = (select: Select) => {
			if (!select || !select.$query) return;
			return z.WHERE(expToWhere(select.$query));
		};

		const selectToOrder = (select: Select) => {
			if (!select || !select.$orderBy) return;
			return z.ORDER(null, Object.keys(select.$orderBy).reduce((r, key) => {
				r.push(z.ORDERITEM(z.SQLCV('?', 'LNK_', key), select.$orderBy[key] === 1 ? '+' : '-'));
				return r;
			}, []), null, null, basic.instructions.C(null));
		};

		var reader: ez.Reader<Instance>;
		const lnk = glob.context.queryFrame.context.tables.LNK_;

		if (lnk) {
			//ORDER('KEY1',[ORDERITEM(SQLCV('F','BPAZ','CRY'),'+')],null, null, C(null))
			var frame = glob.context.x3frame;
			glob.context.x3frame = glob.context.queryFrame;

			var where = selectToWhere(select);
			var order = selectToOrder(select);
			var filter = z.FILTER("LNK_", where, order);
			filter && filter(_);
			glob.context.x3frame = frame;

			const cursor = lnk.x3OpenFor(_, lnk.findKey(""), 0, 0, 0);
			reader = ez.devices.generic.reader(_ => {
				const frame = glob.context.x3frame;

				glob.context.x3frame = glob.context.queryFrame;
				const record = cursor.x3GetRecord(_);

				glob.context.x3frame = frame;
				if (!record) cursor.x3CloseDBReader(_);
				return record;
			});
		} else {
			reader = ez.devices.generic.reader(_ => undefined);
		}
		return reader.limit(max).map(this.class.fromRecordMapper(_));
	}
	sqlReader(_: _,  parent: Class, select: Select, max: number, $recordMapper: TypeMapper) {
		tracerJs.debug && tracerJs.debug("class.sqlReader:" + JSON.stringify(select));
		tracerJs.debug && tracerJs.debug(this.table.name + "   " + "class.sqlReader(" + max + "):" + JSON.stringify(select));
		const recordMapper = $recordMapper || ((_, record) => {
			return this.supervisor.new(_, 'Instance', this, parent).afterCreate(_, record);
		});

		const descs: ColumnDesc[] = [];
		const columnNames: string[] = [];
		const wheres: string[] = [];
		const params: string[] = [];
		const properties = this.properties;
		const param = this.supervisor.sqlDriver.param;

		tracerJs.debug && tracerJs.debug("this.table = " + JSON.stringify(this.table.name));
		const tableNames = [this.table.name + ' T'];
		const sqlOpts = {};

		// add link with ACCES if ACCSTR is filled.

		if (this.data.ACCSTR) {
			tracerJs.debug && tracerJs.debug("add ACCSTR " + this.data.ACCSTR);
			tableNames.push("ACCES ACC");

			params.push(glob.context.x3session.actx.$USER(_));
			wheres.push("ACC.USR_0 = " + param(params.length - 1));
			wheres.push("ACC.CODACC_0 = T." + this.data.ACCSTR + "_0");
			wheres.push("ACC.CONSUL_0 = 2");
		}

		// clear the cache
		const cache = new Cache();

		Object.keys(properties).forEach_(_, (_, name) => {
			properties[name].getSql && properties[name].getSql(_, columnNames, tableNames, wheres, params, descs, cache, false, sqlOpts);
		});

		var orderBy: string[] = [];
		if (select && select.$orderBy) {
			Object.keys(select.$orderBy).forEach_(_, (_, name) => {
				const column = properties[name].column.sqlName();

				orderBy.push(column + " " + (select.$orderBy[name] === 1 ? "asc" : "desc"));
			});
		} else {
			var index = this.tableIndex;
			index && index.sqlNames().forEach(column => {
				orderBy.push(column + " asc");
			});
		}
		if (select && (select.$query || !select.$query && !select.$orderBy)) {
			var qsel = this.queryToSelect(_, select.$query || select, params);
			if (qsel !== "") wheres.push(qsel);
			tracerJs.debug && tracerJs.debug("wheres:" + wheres);
		}
		const i = 0;

		var sql = "select T.UPDTICK_0, " + columnNames.join(',') + " from " + tableNames.join(',');

		if (wheres.length) sql += " where (" + wheres.join(') and (') + ')';
		if (orderBy.length) sql += " order by " + orderBy.join(',');
		var reader = this.supervisor.sqlReader(_, sql, params, sqlOpts).limit(max);
		reader = reader.map(recordMapper);
		if (cache.isActivated) reader = reader.transform(cache.transform());
		return reader;
	}
	jsReader(_: _,  parent: Class, select: Select, max: number, $recordMapper: TypeMapper): ez.Reader<Instance> {
		tracerJs.debug && tracerJs.debug("class.jsReader(" + max + "):" + JSON.stringify(select));
		const recordMapper = $recordMapper || ((_: _, record: any): Instance => {
			return this.supervisor.new(_, 'Instance', this, null).afterCreate(_, record);
		});
		// TODO investigate this AQUERY typing hack
		var reader: any = this.jsInterface.AQUERY(_, select);
		if (!reader.read) reader = this.rsReader(_, this.jsInterface.AQUERY(_, select), select);
		return reader.limit(max).map(recordMapper);
	}
	cleanFilter(filter: any) {
		const keys = Object.keys(filter);

		if (!keys.length) return;

		return keys.reduce((r, k) => {
			const match = k.match(/upper\((\w*)\)/);
			const p = match ? match[1] : k;

			r[p] = filter[k];
			if (Array.isArray(r[p])) {
				for (var i = 0; i < r[p].length; i++) {
					r[p][i] = this.cleanFilter(r[p][i]);
				}
			} else if (typeof r[p] === 'object') r[p] = this.cleanFilter(r[p]);
			return r;
		}, util.any({}));
	}
	rsReader(_: _,  recordset: Record[], select: Select) {
		if (select && select.$orderBy) {
			const orderBy = select.$orderBy;
			const fcts = Object.keys(orderBy).reduce((r, property) => {
				const ascDesc = orderBy[property];
				r.push((a: Record, b: Record) => {
					const A = a[property];
					const B = b[property];

					if (A > B) return ascDesc;
					if (A < B) return -1 * ascDesc;
					return 0;
				});
				return r;
			}, []);

			var sort = (o1: Record, o2: Record) => {
				var cmp = 0;
				for (var i = 0; i < fcts.length; i++) {
					cmp = fcts[i](o1, o2);
					if (cmp) break;
				}
				return cmp;
			};
			recordset = recordset.sort(sort);
		}
		var reader = ez.devices.generic.empty.reader.transform((_, reader, writer) => {
			recordset.forEach_(_, (_, record) => {
				writer.write(_, record);
			});
		});
		if (select && (select.$query || !select.$query && !select.$orderBy)) {
			var filter = this.cleanFilter(select.$query || select);
			if (filter) reader = reader.filter(filter);
		}
		return reader;
	}
	// TODO: fix typing of index
	loadInstances(_: _,  parent: Class, index: any, vals: any, max?: number, $recordMapper?: TypeMapper) {
		return this.reader(_, parent, Object.keys(vals).reduce((o, c) => {
			if (index.columns[c]) {
				if (vals[c] !== undefined) {
					o[index.columns[c].name] = vals[c];
				} else {
					o[index.columns[c].name] = index.columns[c].type.defaultValue;
				}
			}
			return o;
		}, util.any({})), max, $recordMapper);
	}
	fromRecordMapper(_: _,  instance?: Instance) {
		return (_: _, record: Record) => {
			tracerJs.debug && tracerJs.debug("fromRecordMapper:" + JSON.stringify(record));
			const ins = instance ? instance : this.supervisor.new(_, 'Instance', this, null);
			return ins.afterCreate(_, record);
		};
	}

	keyToSelect(key: string | any[]) {
		const index = this.tableIndex;
		let k: any[];
		if (!Array.isArray(key)) k = key.split("~");
		else k = key;

		return this.index.reduce((r, elt, i) => {
			r[elt.name] = k[i];
			return r;
		}, util.any({}));
	}
	sqlRead(_: _,  instance: Instance, key: any) {
		const mapper = this.fromRecordMapper(_, instance);

		instance.snap && instance.snap.enable();
		// TODO: investigate parent type here
		const instances = this.reader(_, util.any(instance).parent, this.keyToSelect(key), 1, mapper).toArray(_);

		if (!instances || !instances.length) {
			var status = instance.addDiagnose(_, constants.CST_AERROR, this.name + "('" + key + "') : " + this.supervisor.loadMess(_, 100, 23));
			return constants.CST_AERROR;
		}
		instance.key = key;
		return constants.CST_AOK;
	}
	intInsert(_: _,  instance: Instance) {
		return this.intCrud(_, 'AINSERT', instance);
	}
	intUpdate(_: _,  instance: Instance) {
		return this.intCrud(_, 'AUPDATE', instance);
	}
	intDelete(_: _,  instance: Instance) {
		return this.intCrud(_, 'ADELETE', instance);
	}
	intRead(_: _,  instance: Instance, key: any) {
		return this.intCrud(_, 'AREAD', instance, key);
	}
	intCrud(_: _,  f_name: string, instance: Instance, key?: any) {
		var status = constants.CST_AOK;
		const args = {
			AEVENT: {
				type: "LS",
				value: f_name
			},
			THIS: {
				type: "LY",
				value: instance
			}
		};

		if (key === undefined) {
			// AINSERT, AUPDATE, ADELETE
			status = instance.action(_, f_name, key);
		} else {
			var index = this.data.KEYINT.split('+');
			var keys = key.toString().split('~');
			var i = 0;

			index.forEach_(_, (_, property) => {
				instance.set(_, property, keys[i++], true);
			});
			instance.snap && instance.snap.enable();
			status = instance.action(_, f_name, key);
		}
		instance.$astalin = constants.CST_ALL;
		return status;
	}
	insert(_: _,  instance: Instance) {
		tracerJs.debug && tracerJs.debug("class " + this.name + ".insert");

		if (instance && !instance.supportsTable("insert")) return constants.CST_AOK;
		const result = this.table.insert(_, instance);

		return result && result.updateCount ? constants.CST_AOK : constants.CST_AERROR;
	}
	update(_: _,  instance: Instance) {
		tracerJs.debug && tracerJs.debug("class " + this.name + ".update");
		if (!instance.supportsTable("update")) return constants.CST_AOK;
		const result = this.table.update(_, instance);

		return result && result.updateCount ? constants.CST_AOK : constants.CST_AERROR;
	}
	delete(_: _,  instance: Instance) {
		var status = constants.CST_AOK;
		if (instance.supportsTable("delete")) {
			var result = this.table.delete(_, instance);
			if (!result || result.updateCount === 0) {
				status = instance.addDiagnose(_, constants.CST_AERROR, this.name + "('" + instance.key + "') : " + this.supervisor.loadMess(_, 100, 23));
			}
			tracerJs.debug && tracerJs.debug("class " + this.name + ".delete result:" + JSON.stringify(result));
		}
		return status;
	}
	searchResourceFactory(_: _) {
		return this.supervisor.new(_, 'SearchResourceFactory', this);
	}
	searchProto(_: _) {
		const factory = this.searchResourceFactory(_);

		return factory.searchProto(_);
	}
	search(_: _,  httpContext: http.HttpContext, qs: any) {
		const factory = this.searchResourceFactory(_);
		const dst = bulkWriter(httpContext);

		var select: any;
		// where=((UPDDATTIM gt "2015-03-17T12:59:39.144Z"))
		if (qs.where) select = filterHelpers.sdataToJson(qs.where);

		const fromInstanceToResource = (_: _, instance: Instance) => {
			return this.supervisor.new(_, 'Resource', factory, instance).bindInstance(instance);
		};

		this.reader(_, null, select, Infinity).map(fromInstanceToResource).pipe(_, dst);
	}
	readLob(_: _,  context: http.HttpContext, property: string, codblb: string, ident1: string, ident2: string, ident3: string) {
		const ident = (s: string) => s || " ";

		const keys = {
			CODBLB: ident(codblb),
			IDENT1: ident(ident1),
			IDENT2: ident(ident2),
			IDENT3: ident(ident2)
		};

		const lob = this.properties[property];
		if (lob) {
			if (lob.type.readMediaLazy) {
				let value = lob.type.readMediaLazy(_, lob, [codblb, ident1, ident2, ident3]);
				// TODO: investigate: readMediaCntLazy does not exist!!!
				let contentType: string = undefined; //lob.type.readMediaCntLazy ? lob.type.readMediaCntLazy(_, lob, [codblb, ident1, ident2, ident3]) : "text/plain";
				context.response.writeHead(200, {
					'content-type': contentType,
					'Transfer-Encoding': 'chunked',
					'X-FRAME-OPTIONS': 'DENY',
					'content-disposition': 'attachement;filename=' + keys.IDENT1
				});
				return context.response.end(value.value);
			} else {
				const param = this.supervisor.sqlDriver.param;
				var i = 0;
				var rs = this.supervisor.sqlReader(_, "select " + lob.lobField + "_0 From " + lob.lobTable + " Where " + 
				Object.keys(keys).map(p => p + '_0=' + param(i++)).join(' and '), 
				Object.keys(keys).map(p => util.any(keys)[p])).toArray(_);

				if (rs.length) {
					let lobType = asTypeLob(lob.type);
					context.response.writeHead(200, {
						'content-type': lobType.contentType(_),
						'Transfer-Encoding': 'chunked',
						'X-FRAME-OPTIONS': 'DENY',
						'content-disposition': 'attachement;filename=' + keys.IDENT1
					});
					// Pipe the data to HTTTP:
					return lobType.reader(_, rs[0][lob.lobField]).pipe(_, context.response.writer);
				}
			}
		}
		throw new util.HttpError(404, this.name + '.' + property + '(' + Object.keys(keys).join('~') + ") couldn't be loaded");
	}
};

export const collectionName = 'ACLASSE';
export const keyName = 'CODCLA';
export const Constructor = Class;
