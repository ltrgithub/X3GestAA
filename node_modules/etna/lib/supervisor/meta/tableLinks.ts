/*
TODO : 
 - Operations for real
 - Add a transaction
*/

import { _ } from 'streamline-runtime';
import { Record } from '../../engine/drivers/types';
import { Dict } from '../../engine/runtime/types';
import { Helper, traceException } from '../util';
import * as util from '../util';
const glob = require('streamline/lib/globals');
import * as constants from '../constants';
import { Table } from './table';
import { Column } from './column';
import { Supervisor } from '../supervisor';
import { Instance } from '../dyn/instance';

import { TableMeta, ColumnMeta } from '../metadata/table';

//var debug = function(m) {console.error("tableLinks : "+m);}

const tracerJs = require('syracuse-core').getTracer("etna.supervisor");

function sqlName(code: string, i?: number) {
	return code + '_' + (i || 0);
};

const sqlValue: { [type: string]: (i: number) => (key: any[]) => any } = {
	string(i: number) {
		return (key: any[]) => {
			tracerJs.debug && tracerJs.debug("sqlValue(string) key:" + key + " i:" + i + " key[i]:" + key[i]);
			return key[i];
		};
	},
	number(i: number) {
		return (key: any[]) => {
			tracerJs.debug && tracerJs.debug("sqlValue(number) key:" + key + " i:" + i + " key[i]:" + key[i]);
			return parseInt(key[i]);
		};
	}
};

export interface LinkSql {
	table: Table;
	maxColumns: number;
	where?: string;
	wheres?: any[];
	params?: any[];
	updateSets: { [name: string]: any };
}

export interface LinkOperation {
	type: number;
	execute(_: _,  instance: Instance, superv: Supervisor, sql: LinkSql): number;
}

const linkOperations = {
	control: {
		type: 1,
		execute(_: _,  instance: Instance, superv: Supervisor, sql: LinkSql) {
			var status = constants.CST_AOK;
			const names = sql.table.indexes[0].sqlNames();
			//if (sql.table.data.INTIT) names.push(sqlName(sql.table.data.INTIT));

			var cmd = "select " + names.join(',');
			cmd += " from " + sql.table.name + " where (" + sql.where + ")";

			tracerJs.debug && tracerJs.debug(cmd);
			const records = superv.sqlReader<Record>(_, cmd, sql.params).toArray(_);

			if (records.length) {
				records.forEach_(_, (_, record) => {
					// "The record is used by"
					const message = [superv.loadMess(_, 126, 101)];
					// Add the record's key :
					message.push(sql.table.indexes[0].columns.map(column => record[column.name]).join('~'));
					// Add the record's description :
					const recordDescription = sql.table.getRecordDescription(_, records);

					if (recordDescription) message.push('(' + recordDescription + ')');
					// "is used in"
					message.push(superv.loadMess(_, 133, 198));
					// Add the table's name
					message.push(sql.table.name);
					// Add the table's description
					const tableDescription = sql.table.description(_);

					if (tableDescription) message.push('(' + tableDescription + ')');
					status = Math.max(status, instance.addDiagnose(_, constants.CST_AERROR, message.join(' ')));
				});
			}
			return status;
		}
	},
	delete: {
		type: 2,
		execute(_: _,  instance: Instance, superv: Supervisor, sql: LinkSql) {
			const cmd = "delete from " + sql.table.name + " where " + sql.where;

			tracerJs.debug && tracerJs.debug(cmd);
			tracerJs.debug && tracerJs.debug(sql.params);
			tracerJs.debug && tracerJs.debug("delete type2: " + cmd);
			superv.executeSql(_, cmd, sql.params);
			return constants.CST_AOK;
		}
	},
	reset: {
		type: 3,
		execute(_: _,  instance: Instance, superv: Supervisor, sql: LinkSql) {
			const param = superv.sqlDriver.param;
			const updateSets = Object.keys(sql.updateSets).map(key => {
				sql.params.push(sql.updateSets[key]);
				return key + " = " + param(sql.params.length - 1);
			}).join(' ');
			const cmd = "update " + sql.table.name + " set " + updateSets + " where " + sql.where;

			tracerJs.debug && tracerJs.debug("reset type3: " + cmd);
			superv.executeSql(_, cmd, sql.params);
			return constants.CST_AOK;
		}
	}
};

export interface SqlLink {
	name: string;
	value: any;
}

export interface LinkStatement1 {
	sql: SqlLink[];
	statement?: ((link: LinkStatement2, key: number[]) => void)[];
}

export interface LinkStatement2 {
	sql: SqlLink[];
	statement?: ((_: _, key: number[]) => void)[];
}

export interface LinkGroup {
	table?: Table;
	links?: LinkStatement2[];
	updateSets?: { [name: string]: any };
}


export class TableLinks extends Helper {
	supervisor: Supervisor;
	table: string;
	links: { [type: number]: { [name: string]: LinkGroup } };
	constructor(superv: Supervisor, table: string) {
		super();
		this.supervisor = superv;
		this.table = table;
	}
	init(_: _) {
		tracerJs.debug && tracerJs.debug(this.table + " tableLinks");

		this.links = this.supervisor.mongoStore.collection('ATABLE').find({
			"COLUMNS.LIEN": this.table
		}).sort({
			CODFIC: 1
		}).toArray().then(_, _).filter((table: TableMeta) => table.CODFIC !== this.table)
		.reduce_(_, (_: _, r: { [id: number]: Dict<LinkGroup> }, table: TableMeta) => {
			//tracerJs.debug && tracerJs.debug("table:"+table.CODFIC);
			return table.COLUMNS.filter(column => column.LIEN && column.LIEN == this.table && column.ANNUL !== 4).reduce_(_, (_, r, column) => {
					var type: Dict<LinkGroup>  = r[column.ANNUL] = r[column.ANNUL] || {};
					var group: LinkGroup = type[table.CODFIC] = type[table.CODFIC] || {};
					group.table = group.table || this.supervisor.load(_, 'Table', table.CODFIC);
					group.links = group.links || [];
					if (column.ANNUL === 3) {
						group.updateSets = group.updateSets || {};
						group.updateSets[sqlName(column.CODZONE)] = group.table.columns[column.CODZONE].type.defaultValue;
					}
					var expressions = column.EXPLIEN && column.EXPLIEN.trim();
					if (expressions) {

						var indiceMax = 1;
						var statement: ((link: LinkStatement1, i: number) => void)[] = [];
						var expression = expressions.split(';');
						expression.forEach_(_, (_, dummy, e) => {
							tracerJs.debug && tracerJs.debug(table.CODFIC + " expression:" + expression[e]);
							statement[e] = (link, i) => {
								throw new Error("Don't know what to do with expression:" + expression[e]);
							};

							if (/^\w+\(indice\)$/.test(expression[e])) {
								indiceMax = column.DIME;

								var colName = expression[e].substring(0, expression[e].indexOf('('));
								var colType = group.table.columns[colName].type.jsType;

								statement[e] = (link, i) => {
									link.sql.push({
										name: sqlName(colName, i),
										value: sqlValue[colType](e)
									});
								};
							} else if (/^indice$/.test(expression[e])) {
								statement[e] = (link, i) => {
									link.statement = link.statement || [];
									link.statement.push((_, key) => key[e] = i);
								};
							} else if (/^indice\s*([+-])\s*(\d*)$/.test(expression[e])) {
								let match = expression[e].match(/^indice\s*([+-])\s*(\d*)$/);
								let delta = (match[1] === '+' ? 1 : -1) * parseInt(match[2]);
								statement[e] = (link, i) => {
									link.statement = link.statement || [];
									link.statement.push((_, key) => key[e] = i + delta);
								};
							} else if (/^\[V\]\w+$/.test(expression[e])) {
								var x3Var = expression[e].substring(3);
								switch (x3Var) {
									case "GLANGUE":
										statement[e] = (link, i) => {
											link.statement = link.statement || [];
											link.statement.push((_, key) => {
												const actx = glob.context.x3session.actx;
												return key[e] = actx.$LAN(_);
											});
										};
										break;
								}
							} else {
								var colName = expression[e];
								if (group.table.columns[colName]) {
									var colType = group.table.columns[colName].type.jsType;
									statement[e] = (link, i) => {
										link.sql.push({
											name: sqlName(colName, i),
											value: sqlValue[colType](e)
										});
									};
								} else {
									statement[e] = (link, i) => {
										link.statement = link.statement || [];
										link.statement.push((_, key) => key[e] = e);
									};
								}
							}
						});

						// Add links:
						for (var indice = 0; indice < indiceMax; indice++) {
							var link = {
								sql: util.any([])
							};
							for (var i = 0; i < statement.length; i++) {
								statement[i](link, indice);
							}
							group.links.push(link);
						}
					} else {
						group.links.push({
							sql: [{
								name: sqlName(column.CODZONE),
								value: sqlValue[group.table.columns[column.CODZONE].type.jsType](0)
							}]
						});
					}
				return r;
			}, r);
		}, {} as { [id: number]: Dict<LinkGroup> });
		return this;
	}
	execute(_: _,  instance:Instance, operation: LinkOperation) {
		var status = constants.CST_AOK;

		const $keys = instance.key;
		const keys = [$keys];

		tracerJs.debug && tracerJs.debug("tableLinks execute  operation type " + operation.type + " on " + keys);

		if (this.links && this.links[operation.type]) {
			var param = this.supervisor.sqlDriver.param;

			Object.keys(this.links[operation.type]).forEach_(_, (_, groupKey) => {
				const group = this.links[operation.type][groupKey];

				if (group.links) {
					const res: LinkSql = {
						table: group.table,
						maxColumns: 0,
						updateSets: group.updateSets,
					}
					// For each key stored in keys
					var sql = keys.reduce_(_, (_, r, $key) => {
						// TODO: review typing here
						const key: any = typeof $key === 'string' ? $key.split('~') : $key;
						// Loop on links

						group.links.filter_(_, (_, link) => {
							// Keep links which abide with logical statements :
							if (link.statement) {
								for (var i = 0; i < link.statement.length; i++) {
									if (!link.statement[i](_, key)) return false;
								}
							}
							return true;
						}).reduce_(_, (_, r, link) => {
							r.wheres = r.wheres || [];
							const where: Dict<any> = {};

							r.maxColumns = Math.max(r.maxColumns, link.sql.length);
							for (var i = 0; i < link.sql.length; i++) {
								where[link.sql[i].name] = link.sql[i].value(key);
							}
							r.wheres.push(where);
							return r;
						}, r);
						return r;
					}, res);

					if (sql.wheres) {
						// TODO : Split sql.wheres here if it contains to many elements (sql limits)
						sql.params = [];
						sql.where = sql.wheres.reduce((r, where) => {
							r.push(Object.keys(where).map(condition => {
								sql.params.push(where[condition]);
								return condition + "=" + param(sql.params.length - 1);
							}).join(' and '));
							return r;
						}, []).join(' or ');
						status = Math.max(status, operation.execute(_, instance, this.supervisor, sql));
					}
				}
			});
		};
		return status;
	}
	control(_: _,  instance: Instance) {
		return this.execute(_, instance, linkOperations.control);
	}
	delete(_: _,  instance: Instance) {
		tracerJs.debug && tracerJs.debug("delete table:" + this.table);
		const status = this.execute(_, instance, linkOperations.delete);

		if (status === constants.CST_AERROR) return status;
		return this.execute(_, instance, linkOperations.reset);
	}
}

export const Constructor = TableLinks;