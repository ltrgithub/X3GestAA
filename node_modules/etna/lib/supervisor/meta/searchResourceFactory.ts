import { _ } from 'streamline-runtime';
import { NodeProto, PropertyProto } from '../protocol/prototype';
import { Dict } from '../../engine/runtime/types';
import * as util from '../util';
import { ResourceFactory } from './resourceFactory';
import { Class, Collection, Property } from './types';
import { Instance } from '../dyn/types';
import { Supervisor } from '../supervisor';

export class SearchResourceFactory extends ResourceFactory {
	supervisor: Supervisor;
	class: Class;
	properties: { [name: string]: Property; };
	$access: (_: _, instance: Instance) => string;

	constructor(superv: Supervisor, clas: Class) {
		super(superv, clas);
		//this.supervisor = superv;
		//this.class = clas;
		this.properties = {}; // exposed properties only
	}

	init(_: _) {
		if (this.class.data.ACCSTR) {
			this.$access = (_, instance) => instance.get(_, this.class.data.ACCSTR);
		}

		this.properties = Object.keys(this.class.properties)
		.filter(property => this.class.properties[property].isSearchable && !/.*_REF$/.test(property) || !!this.class.properties[property].collection)
		.reduce_(_, (_, r, property) => {
			const prop = this.class.properties[property];
			const rProp = r[property] = prop.clone();

			rProp.resourceFactory = this;
			rProp.tag = property;

			if (prop.collection) {
				var targetResourceFactory = Class.cast(prop.collection.class).searchResourceFactory(_);
				if (targetResourceFactory) {
					rProp.collection = prop.collection;
					rProp.targetResourceFactory = targetResourceFactory;
				}
			}
			return r;
		}, {} as Dict<Property>);
		return this;
	}

	fillTypeNode(_: _,  node: PropertyProto) {
		node.$type = "application/x-array"; //this.collection.data.MAXCOL > 1 ? "application/x-array" : "application/x-object";
		node.$item = this.searchItemProto(_);
	}

	searchItemProto(_: _,  facet?: string) {
		const proto: NodeProto = {
			$title: this.supervisor.loadText(_, this.class.data.INTCLA) + " {$key}"
		};

		if (facet) {
			proto.$key = this.class.keyExpression();
			proto.$url = "{$baseUrl}/" + this.class.name + "('{$key}')?representation=" + this.class.name + ".searchItem";
		}
		proto.$properties = {};

		Object.keys(this.properties).forEach_(_, (_, name) => {
			proto.$properties[name] = this.properties[name].prototypeNode(_);
		});
		return proto;
	}

	searchProto(_: _) {
		const actx = util.currentContext().x3session.actx;

		return {
			$baseUrl: "{$baseUrl}",
			$baseType: "application/json;vnd.sage=syracuse;vnd.sage.syracuse.representation=x3.erp." + actx.$AFOLDER(_),
			$classTitle: this.supervisor.loadText(_, this.class.data.INTCLA),
			$url: "{$baseUrl}/" + this.class.name + "?representation=" + this.class.name + ".$search",
			$prototype: "{$baseUrl}/$prototypes('{$representation}.$thumb')",
			$type: "{$baseType}." + this.class.name + ".$search",
			$properties: {
				$resources: {
					$type: "application/x-array",
					$item: this.searchItemProto(_, "$searchItem")
				}
			},
			$links: {
				$search$details: {
					$title: "Detail",
					$default: true,
					$url: "{$baseUrl}/" + this.class.name + "('{$key}')?representation=" + this.class.name + ".$details",
					$devices: "desktop"
				}
			}
		};
	}
};

export const Constructor = SearchResourceFactory;