import { _ } from 'streamline-runtime';
const glob = require('streamline/lib/globals');
import * as ez from 'ez-streams';
import * as types from '../../engine/runtime/types';
import * as util from '../util';
import * as Sdata from '../../engine/sdatagen';
import * as tuuid from '../../engine/runtime/tuuid';
import { DBTableVAR } from '../../engine/runtime/dbtablevar';
import * as activ from '../meta/activ';
import * as constants from '../constants';
import { extAttributesObject } from '../attributes';
import { enumStdLinks } from '../meta/link';
import { BaseClass } from './baseClass';
import { Property } from './property';
import { Class } from './class';
import { ExportedProperty } from './exportedProperty';
import { ResourceFactory } from './resourceFactory';
import { Link } from './link';
import { Diagnosis } from '../dyn/diagnosis';
import { FACETS } from './facets';
//import { Class } from '../meta/class';
import { Cache } from '../cache';
import { newSlotCollection } from '../dyn/slotCollection';
import { Supervisor } from '../supervisor';
import * as http from '../http';
const tracerJs = require('syracuse-core').getTracer("etna.supervisor");
import { RepresentationMeta, ExportedPropertyMeta, LinkMeta, MenuMeta } from '../metadata/representation';

// order of keys matches ENAFAC values so that we can fill FacetIds

const enumDevices: { [id: number]: string; } = {
	1: "desktop",
	2: "phone",
	3: "tablet"
};

function getDeviceCode(device: string) {
	const codes = Object.keys(enumDevices);

	for (var i = 0; i < codes.length; i++) {
		if (enumDevices[+codes[i]] === device) {
			return parseInt(codes[i]);
		}
	}
}

export interface CondTarget {
	cond: boolean;
	ordre: number;
}

export class Representation extends BaseClass {
	supervisor: Supervisor;
	class: Class;
	data: RepresentationMeta;
	curpath: string;
	resourceFactories: { [name: string]: ResourceFactory; };
	exportedProperties: ExportedProperty[];
	qdevice: string;
	links: LinkMeta[];
	_filters: { [name: string]: any }; // used by ResourceFactory

	constructor(superv: Supervisor, data: RepresentationMeta) {
		super(superv, data);
		this.curpath = "";
	}

	get $$type() {
		return "Representation";
	}
	get name() {
		return this.data.CODREP;
	}
	get table() {
		return this.class.table;
	}
	get index() {
		return this._index || this.class._index;
	}

	init(_: _) {
		if (this.resourceFactories) return;
		this.resourceFactories = {};

		this.class = this.supervisor.load(_, 'Class', this.data.CODCLA, {
			codclaPath: this.data.CODREP + "." + this.data.CODCLA,
			curpath: this.curpath ? this.curpath + "." + this.data.ABRCLA : this.data.ABRCLA,
			parent: this
		});
		if (!this.class) throw new Error("class not found: " + this.data.CODCLA);

		this.properties = this.data.PROPERTIES ? this.data.PROPERTIES.filter(prop => !prop.FLDGRP).reduce_(_, (_, r, prop) => {
			const name = prop.CODFLD;

			r[name] = this.supervisor.new(_, 'Property', this, prop);
			return r;
		}, util.any({})) : {};

		this.relations = this.data.COLLECTIONS && this.data.COLLECTIONS.reduce_(_, (_, r, col) => {
			if (col.CODCOL.indexOf('.') < 0) {
				r = r || {};
				var name = col.CODCOL;

				var coln = r[name] = this.supervisor.new(_, 'Collection', this, col);
				coln.class = this.supervisor.new(_, 'Class', {
					CODCLA: this.data.CODREP + "." + name,
					TYPCLA: 1, //5,
					PROPERTIES: this.data.PROPERTIES && this.data.PROPERTIES
					.filter(propData => propData.FLDGRP === name)
					.map(propData => {
						propData.FLDCLA = propData.CODFLD;
						return propData;
					}),
					PARAM_FLDS: [],
					COLLECTIONS: [],
					table: this.table
				}, name);

				var prop = this.properties[name] = this.supervisor.new(_, 'Property', this, {
					CODFLD: name
				}, newSlotCollection, coln);
			}
			return r;
		}, null);

		this.exportedProperties = this.data.EXPORTED_PROPERTIES ? this.data.EXPORTED_PROPERTIES
		.sort((ep1, ep2) => ep1.ORDPRO - ep2.ORDPRO)
		.map_(_, (_, data) => this.supervisor.new(_, 'ExportedProperty', this, data), this)
		 : [];
		if (!this.qdevice || this.qdevice === '') {
			this.qdevice = enumDevices[this.data.TYPMSKREP] || enumDevices[1];
		}
		// First filter on LINKS + sort
		const sortLink = (a: LinkMeta, b: LinkMeta) => {
			//must have FLGSTDLNK===2 first, and after FLGSTDLNK===1
			var info1 = 2;
			var info2 = 2;
			if (a.FLGSTDLNK === 2) info1 = 1;
			if (b.FLGSTDLNK === 2) info2 = 1;
			if ([a.AFFLNK, a.ANCLNK, info1, a.CODLNK].join("/") < [b.AFFLNK, b.ANCLNK, info2, b.CODLNK].join("/")) return -1;
			else if ([a.AFFLNK, a.ANCLNK, info1, a.CODLNK].join("/") == [b.AFFLNK, b.ANCLNK, info2, b.CODLNK].join("/")) return 0;
			else return 1;
		}
		this.data.LINKS = this.data.LINKS.filter(link => link.ENALNK === 2).sort(sortLink);
		return this;
	}
	prepareLinks(_: _) {
		if (this.links) return;
		const comp = "44444444444444444444";
		// Get references of replacement links

		const linksRemRef = this.data.LINKS.filter(link => link.REMSTDLNK !== undefined && link.REMSTDLNK !== "" && link.FLGSTDLNK === 2).reduce((r, lk1) => {
			const tablnk = this.data.LINKS.filter(lk2 => lk2.CODLNK === lk1.REMSTDLNK && lk2.ANCLNK === lk1.ANCLNK && lk2.AFFLNK === lk1.AFFLNK);

			if (tablnk && tablnk[0]) r[[lk1.AFFLNK, lk1.ANCLNK, lk1.REMSTDLNK].join("/")] = tablnk[0];
			return r;
		}, util.any({}));

		this.links = this.data.LINKS.filter(link => {
			//get all except linksRemRef
			return linksRemRef[[link.AFFLNK, link.ANCLNK, link.CODLNK].join("/")] === undefined;
		}).reduce_(_, (_, r, lk1) => {
			var link: LinkMeta;
			if (lk1.REMSTDLNK && lk1.REMSTDLNK.length) {
				var codRem = [lk1.AFFLNK, lk1.ANCLNK, lk1.REMSTDLNK].join("/");
				if (linksRemRef[codRem]) link = util.clone(linksRemRef[codRem]);
				else return r;
				if (lk1.ATTLNK > 1 && link.ATTLNK === 1) link.ATTLNK = lk1.ATTLNK;
				if (lk1.FLGSTDLNK === 2) link.FLGSTDLNK = 2;
				if (lk1.MENLNK) link.MENLNK = lk1.MENLNK;
				if (lk1.ORDLNK) link.ORDLNK = lk1.ORDLNK;
			} else {
				link = lk1;
			}
			if (activ.getActiv(_, this.supervisor, link.ACVLNK) < 0) return r;

			if (link.ATTLNK > 1 && link.FLGSTDLNK === 2) {
				var tablnk = this.data.LINKS.filter(lk2 => lk2.ATTLNK === link.ATTLNK && lk2.FLGSTDLNK === 1 && lk2.AFFLNK === link.AFFLNK && lk2.ANCLNK === link.ANCLNK && lk2.CODLNK !== link.CODLNK && lk2.CODLNK !== lk1.CODLNK);
				if (tablnk && tablnk[0]) {
					link.ATTLNK = 1;
					link.FLGSTDLNK = 1;
				}
			}
			if (link.TYPLNK === 1) {
				var repr: Representation;
				repr = link.REPLNK === this.name ? this : this.supervisor.load(_, 'Representation', link.REPLNK);
				if (!repr || !repr.isActivated(_)) return r;
				if (repr.class) {
					if (!repr.class.isActivated(_)) return r;

					if (enumStdLinks[link.CMPLNK]) {
						if (enumStdLinks[link.CMPLNK].toFacet && !repr.isFacetEnabled(enumStdLinks[link.CMPLNK].toFacet)) return r;
						var behaviors = enumStdLinks[link.CMPLNK].requiredBehaviors;
						for (var i = 0; behaviors && i < behaviors.length; i++) {
							if (!repr.isBehaviourEnabled(behaviors[i])) return r;
						}
					}
				}
			}
			if (link.ATTLNK > 1) link.FLGSTDLNK = 2;
			link.oCODLNK = link.CODLNK;
			link.oAFFLNK = link.AFFLNK;
			link.CMPLNK = link.CMPLNK || 0;
			if (link.AFFLNK === 5 && (link.DETLNK === 2 || link.EDILNK === 2 || link.SUMLNK === 2)) {
				var newLink = util.clone(link);
				link.DETLNK = 1;
				link.EDILNK = 1;
				link.SUMLNK = 1;
				r.push(link);
				newLink.AFFLNK = 4;
				newLink.QRYLNK = 1;
				newLink.LOKLNK = 1;
				newLink.CODLNK = link.oCODLNK + "_LIG" + comp.substr(0, 12 - link.oCODLNK.length);
				r.push(newLink);
			} else {
				r.push(link);
			}
			return r;
		}, []);
	}
	title(_: _,  lan?: string) {
		return this.supervisor.loadText(_, this.data.INTREP, lan);
	}
	isFacetEnabled(facet: string) {
		return this.data.ENAFAC[FACETS[facet].id] === 2;
	}
	isBehaviourEnabled(no7968: number) {
		return this.data.ENACOM[no7968 - 1] === 2;
	}
	check(_: _,  facet: string) {
		if (!this.isActivated(_)) throw new util.HttpError(406, this.supervisor.loadMess(_, 140, 22) + ' ' + this.data.CODREP + " (" + this.data.CODACT + ")");
		if (facet && !this.isFacetEnabled(facet)) throw new util.HttpError(406, this.supervisor.loadMessParams(_, 149, 14, facet, this.data.CODREP));
		this.class.check(_, facet);
	}
	checkDevice(device: string) {
		const code = getDeviceCode(device);

		if (code) {
			if (this.data.TYPMSKREP === 2) return; // keep unit test happy (mobile representation always accepted?)
			if (code !== this.data.TYPMSKREP) throw new util.HttpError(406, "device mismatch: " + device);
		} else if (device) throw new util.HttpError(415, "unknown device: " + device);
	}
	protoETag(_: _,  facet: string) {
		const factory = this.resourceFactories[facet];

		return factory !== undefined ? factory.ETag : undefined;
	}
	resourceFactory(_: _,  facet: string) {
		var factory = this.resourceFactories[facet];
		if (factory) return factory;
		this.prepareLinks(_);

		factory = this.supervisor.new(_, 'ResourceFactory', this.class, this, facet, []);
		factory.ETag = this.data._etag + "-" + glob.context.x3session.actx.$LAN(_);

		this.resourceFactories[facet] = factory;
		this.resourceFactories[facet].keyItems = [];

		const facetFlagLNK = FACETS[facet].prefix + "LNK";
		const facetFlagPRO = FACETS[facet].prefix + "PRO";

		this.resourceFactories[facet].$uuid = (_, instance) => {
			return instance.class.properties['AUUID'] ? instance.get(_, 'AUUID') : tuuid.generate();
		};
		if (facet === "$edit") {
			this.resourceFactories[facet].$attributes = (node: any, property: string, attributes: any) => {
				// Manage attributes :
				Object.keys(attributes).forEach(attribute => {
					if (extAttributesObject[attribute] !== undefined) {
						// It's an object attribute :
						node[property] = node[property] || {};
						node[property][attribute] = attributes[attribute];
					} else {
						// It's a meta attribute ($isMandatory ...)
						node.$properties = node.$properties || {};
						node.$properties[property] = node.$properties[property] || {};
						node.$properties[property].$attributes = node.$properties[property].$attributes || {};
						node.$properties[property].$attributes[attribute] = attributes[attribute];
					}
				});
			};
			this.resourceFactories[facet].$diagnoses = (node: any, property: string, diagnoses: Diagnosis[]) => {
				if (diagnoses === null || diagnoses.length) {
					var target = node;
					if (property) {
						node.$properties = node.$properties || {};
						target = node.$properties[property] = node.$properties[property] || {};
						target.$diagnoses = diagnoses === null ? null : diagnoses.map(diagnose => diagnose && diagnose.dataNode() || null);
					} else {
						var diags = diagnoses.filter(diagnose => diagnose !== null && diagnose !== undefined).map(diagnose => diagnose.dataNode());
						if (diags.length) target.$diagnoses = diags;
					}
				}
			};
		}

		const bindProperty = (property: Property, factory: ResourceFactory) => {
			var factProperty: Property;
			if (property) {
				factProperty = property.clone();
				factProperty.resourceFactory = factory;
			}
			return factProperty;
		};

		this.exportedProperties.filter(expprop => expprop.data[facetFlagPRO] === 2).forEach_(_, (_, exppro) => {
			const path = exppro.data.CODPRO.split('.');

			var container: BaseClass = this;
			var im = this.class;
			var f = factory,
			    i = 0,
			    prop: Property;

			if (this.relations && this.relations[path[0]]) {
				if (!(prop = factory.properties[path[0]])) {
					prop = this.properties[path[0]];
					prop = bindProperty(prop, factory);
					prop.tag = path[0];
					prop.targetResourceFactory = this.supervisor.new(_, 'ResourceFactory', this.relations[path[0]].class, this, facet, path[0]);
					factory.properties[path[0]] = prop;
				}
				f = prop.targetResourceFactory;
				prop = this.relations[path[0]].class.properties[path[1]];
				prop = bindProperty(prop, factory);
				f.properties[path[i]] = prop;
			} else if (path[0] === this.data.ABRCLA) {
				container = this.class;
				i++;
				for (; i < path.length - 1; i++) {
					var coln = container.relations[path[i]];
					if (!coln) throw new Error("path does not match collection: " + path.slice(0, i + 1));
					if (!(prop = f.properties[path[i]])) {
						prop = bindProperty(container.property(path[i]), f);
						prop.tag = path.slice(0, i + 1).join('');
						f.properties[path[i]] = prop;
					}
					im = coln.class;
					if (!im) return console.error("ignoring collection " + path.slice(0, i + 1));
					container = im;
					f = prop.targetResourceFactory || (prop.targetResourceFactory = this.supervisor.new(_, 'ResourceFactory', im, this, facet, path.slice(0, i + 1)));
				}

				prop = bindProperty(im.properties[path[i]], f);
			} else if (this.properties[path[0]]) {
				prop = bindProperty(this.properties[path[0]], factory);
			}

			if (!prop) throw new Error("property not found: " + path);

			prop.exportedProperty = exppro;
			prop.tag = exppro.data.ALIAS;
			exppro.tag = prop.tag;
			prop.belongsToKey = f.class.keyItems.indexOf(path[i]) >= 0;
			prop.isKey = f.class.keyItems.length === 1 && prop.belongsToKey;
			if (prop.resourceFactory && prop.resourceFactory.keyItems && prop.belongsToKey === true) {
				//don't use push -> change the order of the items in the key
				//					prop.resourceFactory.keyItems.push({
				//						alias: prop.tag,
				//						prop: path[i]
				//					});
				prop.resourceFactory.keyItems[f.class.keyItems.indexOf(path[i])] = {
					alias: prop.tag,
					prop: path[i]
				};
			}
			prop.hasLookup = !!(prop.type && prop.type.data && prop.type.data.INDREF);
			if (!prop.hasLookup) {
				// looking into current facet is too restrictive. We have to look into all.
				// so we cannot use prop.links because it is filtered by facet

				// TODO META (links)
				prop.hasLookup = this.links.filter(linkData => linkData.ANCLNK === prop.exportedProperty.data.CODPRO && linkData.AFFLNK === 1 && linkData.ATTLNK === 3 && !(prop.isKey && linkData.REPLNK === this.name)).some(linkData => {
					linkData.PARAMS && linkData.PARAMS.forEach(paramData => {
						if (paramData.TYPPAR === 3 && paramData.TYPKEY === 2 && paramData.VALEUR === prop.exportedProperty.data.CODPRO) {
							prop.destLookup = paramData.CODPAR;
							prop.repLookup = linkData.REPLNK;
						}
					});
					return true;
				});
			}
			prop._isReference = prop.hasLookup && prop.isReference();

			if (prop._isReference === true && prop.repLookup) {
				var r: Representation;
				if (prop.repLookup === this.name) r = this;
				else r = this.supervisor.load(_, 'Representation', prop.repLookup);
				var dest: ExportedPropertyMeta = util.find(r.data.EXPORTED_PROPERTIES, "CODPRO", r.data.ABRCLA + "." + prop.destLookup);
				if (dest) prop.destLookup = dest.ALIAS;
			}

			tracerJs.debug && tracerJs.debug("representation." + prop.tag + " hasLookup: " + prop.hasLookup);
			tracerJs.debug && tracerJs.debug("representation." + prop.tag + " isReference:" + prop._isReference + " (" + prop.tag + ")");

			f.properties[path[i]] = prop;
			if (prop.isExtra === true && prop.isReference()) {
				// Add a property :
				var prop2 = bindProperty(prop, factory);
				prop2.isExtraRef = true;
				prop2.isReference(true);
				f.properties[prop2.ref(path[i])] = prop2;
				f.cache = f.cache || new Cache();
				f.cache.addReference(_, prop);
			}
		}, this);

		if (facet === "$edit") {
			var linksSave: any = {};
			var linksAbort: any = {};
			this.links.filter(link => link.FLGSTDLNK === 2 && link.TYPLNK === 1 && link.AFFLNK > 3).forEach_(_, (_, link) => {
				var l: Link;
				if (link.AFFLNK === 4 && link.TYPLNK === 1 && link.CMPLNK === 5) {
					//Query
					l = this.supervisor.new(_, 'Link', factory, link);
					//prepare keys+params
					l.prepareKeyparams(this);
					linksSave.$query = l;
					linksAbort.$query = l;
				} else if ((link.AFFLNK === 4 || link.AFFLNK === 5) && link.TYPLNK === 1 && link.CMPLNK === 2 && link.ATTLNK > 1) {
					//Detail
					l = this.supervisor.new(_, 'Link', factory, link);
					//prepare keys+params
					l.prepareKeyparams(this);
					linksSave.$details = l;
					linksAbort.$details = l;
				} else if ((link.AFFLNK === 4 || link.AFFLNK === 5) && link.TYPLNK === 1 && link.CMPLNK === 3) {
					//Edit
					l = this.supervisor.new(_, 'Link', factory, link);
					//prepare keys+params
					l.prepareKeyparams(this);
					linksSave.$edit = l;
				}
			}, this);
		}
		this.links.filter(link => link[facetFlagLNK] === 2).forEach_(_, (_, link) => {
			const path = (link.ANCLNK || "").split('.');

			var f = factory;
			var p: Property = null;
			if (path[0] === this.data.ABRCLA) {
				path.shift();
			}
			for (var i = 0; i < path.length - 1; i++) {
				p = f.properties[path[i]];
				if (!p) {
					/* property is not exposed on the facet */
					return;
				}
				f = p.targetResourceFactory;
				if (!f) {
					throw new Error("bad anchor path: " + path.slice(0, i + 1));
				}
			}
			var anchor: any;
			switch (link.AFFLNK) {
				case 1:
					// property
					anchor = f.properties[path[i]];
					// anchor is null on ATYPE/NOLIB: query facet contains link but does not contain property!!!
					//if (!anchor) return console.log("*** BAD LINK ANCHOR: " + path), console.log(link);
					if (!anchor) return;
					break;
				case 2:
					// collection element
					anchor = f;
					break;
				case 3:
					// collection -- ???
					anchor = p;
					break;
				case 4:
					// page
					anchor = factory.page;
					break;
				case 5:
					// query row
					anchor = factory;
					break;
			}
			if (!anchor) throw new Error("bad anchor path: " + path);
			anchor.links = anchor.links || {};
			const l = this.supervisor.new(_, 'Link', anchor, link);
			//prepare keys+params

			l.prepareKeyparams(this);
			anchor.links[l.name] = l;
			//links for actions save and abort
			if (facet === "$edit" && link.FLGSTDLNK === 2) {
				if (link.AFFLNK === 4 && link.TYPLNK === 1 && link.CMPLNK === 17) {
					//Save
					l.links = linksSave;
				} else if (link.AFFLNK === 4 && link.TYPLNK === 1 && link.CMPLNK === 18) {
					//Abort
					l.links = linksAbort;
				}
			}
		}, this);
		return factory;
	}
	filtersProto(_: _,  resourceFactory: ResourceFactory) {
		const tabcor = resourceFactory.filtersTabCor(_);
		const myopt: any = {};

		this.data.FILTERS && this.data.FILTERS.forEach_(_, (_, opt) => {
			var cond = true;
			var where: any;
			if (opt.OPTFLGCLA === 2) {
				var id = this.class.data.FILTERS.indexOf(opt.OPTCOD);
				if (!id) cond = false;
				else {
					myopt[opt.OPTCOD] = {};
					myopt[opt.OPTCOD].$title = this.supervisor.loadText(_, opt.OPTLIB);
					where = Sdata.x3ToSdata(tabcor, util.decodeValueMongoString(opt.OPTCND));
					myopt[opt.OPTCOD].$where = where();
				}
			} else {
				myopt[opt.OPTCOD] = {};
				myopt[opt.OPTCOD].$title = this.supervisor.loadText(_, opt.OPTLIB);
				where = Sdata.x3ToSdata(tabcor, util.decodeValueMongoString(opt.OPTCND));
				myopt[opt.OPTCOD].$where = where();
			}
			if (cond === true) {
				if (opt.OPTDEF === 2) {
					myopt[opt.OPTCOD].$isDefault = true;
				}
				if (opt.OPTOBY === 2) {
					myopt[opt.OPTCOD].$isMandatory = true;
					myopt[opt.OPTCOD].$isHidden = true;
				}
				if (opt.OPTACT !== undefined && activ.getActiv(_, this.supervisor, opt.OPTACT) <= 0) {
					// GH 6167
					myopt[opt.OPTCOD].$isHidden = true; // GH 6167
				} // GH 6167
			}
		}, this);
		return myopt;
	}
	articleLayout(_: _,  facet: string): types.Article {
		return {
			$layout: {
				$items: this.data.SECTIONS.sort((s1, s2) => s1.NIVSEC - s2.NIVSEC).map_(_, (_, section) => {
					return {
						$category: "section",
						$title: this.supervisor.loadText(_, section.INTSEC),
						$layout: {
							$items: section.BLOCKS ? section.BLOCKS.sort((b1, b2) => b1.NIVBLC - b2.NIVBLC).map_(_, (_, block) => {
								//
								const findProp = (prop: Property, facet: string) => {
									var condProp = false;
									if (prop.exportedProperty.data.BLCPRO === block.CODBLC) {
										condProp = prop.exportedProperty.data[FACETS[facet].prefix + "PRO"] === 2 && prop.exportedProperty.data["STA" + FACETS[facet].prefix + "PRO"] !== 3;
										return {
											cond: condProp,
											ordre: prop.exportedProperty.data.ORDPRO
										};
									}
									return {
										cond: false,
										ordre: 0
									};
								}
								//
								const findCol = (targetResourceFactory: ResourceFactory, facet: string) => {
									var condCol = {
										cond: false,
										ordre: 0
									};
									Object.keys(targetResourceFactory.properties).some(prop => {
										if (targetResourceFactory.properties[prop].exportedProperty) {
											condCol = findProp(targetResourceFactory.properties[prop], facet);
											return condCol.cond === true;
										} else if (targetResourceFactory.properties[prop].targetResourceFactory) {
											condCol = findCol(targetResourceFactory.properties[prop].targetResourceFactory, facet);
											return condCol.cond === true;
										}
									});
									return condCol;
								}
								//
								//
								const getColTarget = (targetResourceFactory: ResourceFactory, facet: string, r: any, condTarget: CondTarget) => {
									Object.keys(targetResourceFactory.properties).forEach(prop => {
										var condBind = {
											cond: false,
											ordre: 0
										};
										if (targetResourceFactory.properties[prop].exportedProperty && condTarget.cond === false) {
											condBind = findProp(targetResourceFactory.properties[prop], facet);
											if (condBind.cond === true) {
												condTarget.cond = true;
												condTarget.ordre = condBind.ordre;
											}
										} else if (targetResourceFactory.properties[prop].isInstance) {
											//1-1 collection
											r = getCol(targetResourceFactory.properties[prop].targetResourceFactory, facet, r);
										} else if (targetResourceFactory.properties[prop].targetResourceFactory) {
											condBind = findCol(targetResourceFactory.properties[prop].targetResourceFactory, facet);
											if (condBind.cond === true) r[targetResourceFactory.properties[prop].tag] = condBind.ordre;
										}
									});
									return r;
								}

								const getCol = (targetResourceFactory: ResourceFactory, facet: string, r: any) => {
									Object.keys(targetResourceFactory.properties).forEach(prop => {
										var condBind = {
											cond: false,
											ordre: 0
										};
										if (targetResourceFactory.properties[prop].exportedProperty) {
											condBind = findProp(targetResourceFactory.properties[prop], facet);
											if (condBind.cond === true) {
												var tprop = targetResourceFactory.properties[prop];
												if (targetResourceFactory.properties[prop]._isReference) {
													r[tprop.ref(tprop.tag)] = condBind.ordre;
												} else {
													r[tprop.tag] = condBind.ordre;
												}
											}
										} else if (targetResourceFactory.properties[prop].isInstance) {
											//1-1 collection
											r = getCol(targetResourceFactory.properties[prop].targetResourceFactory, facet, r);
										} else if (targetResourceFactory.properties[prop].targetResourceFactory) {
											//condBind = findCol(targetResourceFactory.properties[prop].targetResourceFactory, facet);
											condBind.cond = false;
											condBind.ordre = 0;
											r = getColTarget(targetResourceFactory.properties[prop].targetResourceFactory, facet, r, condBind);
											if (condBind.cond === true) r[targetResourceFactory.properties[prop].tag] = condBind.ordre;
										}
									});
									return r;
								}

								//
								const resourceFactory = this.resourceFactory(_, facet);

								var items = getCol(resourceFactory, facet, {});

								items = Object.keys(items).sort((item1, item2) => items[item1] - items[item2]);

								items = Object.keys(items).map(no => {
									return {
										$bind: items[no]
									};
								});
								return {
									$category: "block",
									$title: this.supervisor.loadText(_, block.INTBLC),
									$layout: {
										$items: items
									}
								};
							}) : undefined
						}
					};
				})
			}
		};
	}
	article(_: _,  facet: string, f: ResourceFactory) {
		var article: types.Article = {};
		//Layout
		if (/^\$(details|edit|summary)$/.test(facet)) article = this.articleLayout(_, facet);

		const trimLayout = (obj: types.Article) => {
			var hasElt = false;
			var hasBind = false;
			const new_items: types.Article[] = [];

			if (obj.$layout.$items.length > 0) {
				obj.$layout.$items.forEach(item => {
					if (item.$bind) hasBind = true;
					else hasBind = trimLayout(item);
					if (hasBind === true) {
						hasElt = true;
						new_items.push(item);
					}
				});
			}
			obj.$layout.$items = new_items;
			return hasElt;
		}
		if (article.$layout) trimLayout(article);

		//Menu
		const fillMenu = (facet: string, tabLinks: { [name: string]: Link; }, curMenu: string, items: types.Article[]) => {
			var hasElt = false;
			if (tabLinks) {
				Object.keys(tabLinks).filter(name => {
					tabLinks[name].data.MENLNK = tabLinks[name].data.MENLNK || "";
					//#SAM 108421 no abort
					return tabLinks[name].data.MENLNK === curMenu && tabLinks[name].data.CMPLNK !== 18;
				}).forEach(name => {
					hasElt = true;
					const new_item: types.Article = {
						$bind: name,
						$order: tabLinks[name].data.ORDTECLNK
					};
					//#SAM 108421 $style -> $kind

					if (this.data.DEFLNKFAC[FACETS[facet].id] !== 2) {
						if (this.data.AFFLNKFAC[FACETS[facet].id] === tabLinks[name].data.oAFFLNK && 
							this.data.LNKMENFAC[FACETS[facet].id] === tabLinks[name].data.oCODLNK) {
							new_item.$kind = "main";
						}
					} else if (this.data.FONCTION !== undefined && facet === "$query") {
						if (name === "$edit") new_item.$kind = "main";
					} else if (name === FACETS[facet].mainMenu) new_item.$kind = "main";
					items.push(new_item);
				});
			}
			return hasElt;
		}

		const fillMenuMen = (_: _, facet: string, tabMenus: MenuMeta[], curMenu: string, 
			links1: { [name: string]: Link; }, links2: { [name: string]: Link; }, items: types.Menu[]) => {
			var hasElt = false;
			const selfItems = items;

			if (tabMenus) {
				tabMenus.filter_(_, (_, menu) => {
					var okMenu = 1;
					menu.PARMENU = menu.PARMENU || "";
					if (menu.PARMENU !== curMenu) okMenu = 0;
					if (okMenu === 1 && menu.ACTMENU && activ.getActiv(_, this.supervisor, menu.ACTMENU) <= 0) okMenu = 0;
					return okMenu === 1;
				}).forEach_(_, (_, menu) => {
					var hasBind = false;
					const new_item: types.Menu = {
						$title: this.supervisor.loadText(_, menu.LIBMENU),
						$CODMENU: menu.CODMENU,
						$PARMENU: menu.PARMENU,
						$category: "menus",
						$isBoxCollapsable: true,
						$opened: false,
						$layout: {
							$items: []
						}
					};

					var items = new_item.$layout.$items;
					const hasBind1 = fillMenu(facet, links1, menu.CODMENU, items);
					const hasBind2 = fillMenu(facet, links2, menu.CODMENU, items);

					items = items.sort((item1, item2) => item1.$order - item2.$order);
					items.forEach(item => {
						delete item.$order;
					});
					if (hasBind1 === true || hasBind2 === true) {
						hasElt = true;
					}
					hasBind = fillMenuMen(_, facet, tabMenus, menu.CODMENU, links1, links2, items);
					if (hasBind1 === true || hasBind2 === true || hasBind === true) {
						selfItems.push(new_item);
					}
				});
				return hasElt;
			}
		}

		article.$menus = {
			$layout: {
				$items: []
			}
		};
		if (facet !== '$bulk') {
			var items = article.$menus.$layout.$items;
			if (["$query", "$lookup"].indexOf(facet) < 0) fillMenu(facet, f.links, "", items);
			fillMenu(facet, f.page && f.page.links, "", items);
			items = items.sort((item1, item2) => item1.$order - item2.$order);
			items.forEach(item => {
				delete item.$order;
			});
			fillMenuMen(_, facet, this.data.MENUS, "", ["$query", "$lookup"].indexOf(facet) < 0 ? f.links : undefined, f.page && f.page.links, items);
		}

		return article;
	}
	proto(_: _,  facet: string) {
		const f = this.resourceFactory(_, facet);
		const proto = f.pageProto(_);

		if (/^\$(query|bulk|lookup)$/.test(facet)) proto.$filters = this.filtersProto(_, f);
		if (proto.$filters && Object.keys(proto.$filters).length === 0) proto.$filters = undefined;

		proto.$article = this.article(_, facet, f);

		return proto;
	}
	loadResource(_: _,  key: any, facet: string, qs: any) {
		return this.resourceFactory(_, facet).loadResource(_, key, qs);
	}
	createResource(_: _,  qs: any) {
		return this.resourceFactory(_, "$edit").createResource(_, qs);
	}
	deleteResource(_: _,  httpContext: http.HttpContext, key: any, facet: string, qs: any) {
		return this.resourceFactory(_, facet).deleteResource(_, httpContext, key, qs);
	}
	query(_: _,  httpContext: http.HttpContext, facet: string, qs: any) {
		return this.resourceFactory(_, facet).query(_, httpContext, qs);
	}
	action(_: _,  action: string, frame?: types.Frame) {
		var astatus = this._action(_, action, frame);
		if (astatus !== constants.CST_AERROR) {
			astatus = this.class._action(_, action, frame);
		}
		return astatus;
	}
	beforeQuery(_: _) {
		const status = this.action(_, "AQUERY_OPEN");

		if (status === constants.CST_AERROR) return status;
		const prev = glob.context.x3frame;

		glob.context.queryFrame = {
			values: {},
			types: {},
			context: prev.context,
			prev: prev,
			loopLevel: 0,
			stackLevel: 0,
			name: "",
			loc: {
				file: "",
				line: 0
			}
		};
		return this.action(_, "AQUERY_OPEN_AFTER", glob.context.queryFrame);
	}
	afterQuery(_: _) {
		const status = this.action(_, "AQUERY_CLOSE");

		glob.context.queryFrame = undefined;
		return status;
	}
	service(_: _,  keys: string, $service: string, facet: string, qs: any) {
		const reply: types.ServiceProto = {};

		reply.$baseUrl = this.supervisor.baseUrl;
		reply.$prototype = "{$baseUrl}/$prototype('{$representation}.$thumb')", reply.$representation = this.name;
		reply.$url = "{$baseUrl}/" + this.data.CODCLA + "('" + keys + "')";
		reply.$url += "?representation=" + this.name + "." + facet;
		reply.$type = "application/json;vnd.sage=syracuse";
		reply.$etag = 1;
		reply.ETag = 0;
		reply.$uuid = tuuid.generate().x3ToString();
		reply.$actions = {};
		reply.$actions[$service] = {
			$diagnoses: [],
			$return: {}
		};
		const f = this.resourceFactory(_, facet);
		const links = this.links.filter(link => (link.AFFLNK == 5 || link.AFFLNK == 4) && link.TYPLNK == 3 && link.CODLNK === $service);

		if (!links || !links[0]) throw new util.HttpError(400, this.name + ' : ' + this.supervisor.loadMessParams(_, 149, 40, $service));

		const service = links[0].CODOPELNK;
		const codcla = links[0].CLALNK;

		tracerJs.debug && tracerJs.debug("repr:" + this.name + " class:" + this.data.CODCLA + " service:" + service);
		this.deleteErrors(_);
		const cl = this.supervisor.load(_, 'Class', codcla);

		if (!cl) throw new util.HttpError(400, this.supervisor.loadMess(_, 140, 4) + " " + codcla);
		const ins = cl.createInstance(_);
		const meth = ins.xmet(service);

		if (!meth) throw new util.HttpError(400, this.data.CODCLA + " : " + this.supervisor.loadMess(_, 143, 172) + " " + service);

		const param = cl.methods[service].getServiceArgs(_, keys, qs);
		// Support methods with variables parameters:
		const res = meth.apply_(_, ins, param, 0);
		//var status = this.action(_, service);

		reply.$diagnoses = ins.getDiagnoses(_).map((diagnose: Diagnosis) => diagnose && diagnose.dataNode() || null);

		if (res !== undefined) {
			var diagnose = {
				$severity: "success",
				$message: this.supervisor.loadMessParams(_, 143, 221, service)
			};
			reply.$actions[$service].$diagnoses.push(diagnose);
			reply.$actions[$service].$return = cl.methods[service].getServiceReturn(_, res);
		}
		return reply;
	}
};

export const collectionName = 'ASHW';
export const keyName = 'CODREP';
export const Constructor = Representation;
