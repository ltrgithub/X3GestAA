import { _ } from 'streamline-runtime';
const glob = require('streamline/lib/globals');
import * as types from '../../engine/runtime/types';
import * as util from '../util';
import * as basic from '../../engine/runtime/basic';
const Helper = util.Helper;
import * as activ from '../meta/activ';
import * as runtime from '../../engine/runtime/runtime';
import * as variables from '../../engine/runtime/variables';
import { X3Error } from '../../engine/runtime/errors';
import * as tuuid from '../../engine/runtime/tuuid';
import * as utilRuntime from '../../engine/runtime/util';
import * as X3SON from '../../engine/x3son';
import * as mapping from '../mapping';
import * as constants from '../constants';
import { Errors } from '../errors';
import { Transaction } from '../transaction';
import * as snapshots from '../snapshots';
import { Snapshot } from '../snapshot';
import * as attributes from '../attributes';
import { Diagnosis, trace } from './diagnosis';
import { Slot } from '../slot';
import { BaseClass } from './baseClass';
import { Instance } from './instance';
import { Property } from './property';
import { SlotCollection } from '../slotCollection';
import { Supervisor } from '../supervisor';
const traceSup = require('syracuse-core').getTracer("etna.supervisor");
const traceGET = require('syracuse-core').getTracer("etna.accessorsGet");
const traceSET = require('syracuse-core').getTracer("etna.accessorsSet");
const tracerEvents = require('syracuse-core').getTracer("etna.events");

var dbgId = 0;

type IInstance = Instance;

interface SysProperty {
	get: (_: _, raw?: boolean) => any;
	set?: (_: _, val: any, raw?: boolean) => void;
}

interface SysProperties {
	AERROR?: SysProperty;
	ACTX?: SysProperty;
	APARENT?: SysProperty;
	ASTALIN?: SysProperty;
	OBJECTTYPE?: SysProperty;
	OBJECTNBS?: SysProperty;
	OBJECTVAR?: SysProperty;
	[name: string]: SysProperty;
}

type PropertyWalker = (_: _, instance: BaseInstance, property: string) => void;

interface EventProperty {
	name: string;
	type: { [action: string]: (_: _, slot: Slot) => number };
	property: Property;
}

export class BaseInstance extends Helper {
	supervisor: Supervisor;
	data: any;
	key: string;
	diagnoses: Diagnosis[];
	maxSeverity: number;
	proName: string;
	proJsName: string;
	$uuid: Buffer;
	$$dbgId: number;
	$astalin: number;
	activeLoading: (_: _) => void;
	_$id: Buffer;
	slots: { [name: string]: Slot };
	properties: { [name: string]: Property };
	sysProperties: SysProperties;
	record: types.Row;
	colnIndex: number;
	errors: Errors;
	APARENT: BaseInstance;
	$parent: any; // TODO: refine
	class: BaseClass;
	meta: BaseClass;
	clasName: string;
	instance: IInstance;
	$$type: string;
	snap: Snapshot;
	transaction: Transaction;
	getAttribute: (name: string) => any;
	setAttribute: (name: string, value: any) => void;
	snapshots: () => void;
	enableSnapshot: () => void;
	disableSnapshot: () => void;
	atabinfos: any;

	index: types.InstanceIndex;

	constructor(superv: Supervisor) {
		super();
		this.supervisor = superv;
		this.data = null;
		this.key = null;
		this.diagnoses = [];
		this.maxSeverity = constants.CST_AOK;
		this.proName = "";
		this.proJsName = "";
		this.$uuid = tuuid.generate();
		this.$$dbgId = ++dbgId;
		this.$astalin = 0;
		this.activeLoading = this._activeLoading;
	}

	get $id() {
		this._$id = this._$id || tuuid.generate();
		return this._$id;
	}

	init(_: _) {
		return this;
	}

	ensureSlot(name: string) {
		var slot = this.slots[name];
		if (slot) return slot;
		if (this.properties[name]) {
			slot = this.slots[name] = this.properties[name].newSlot(this);
			slot.initialized = false;
			return slot;
		}
	}

	// Lazy loading of slots:
	slot(_: _, name: string) {
		var slot = this.slots[name];
		if (!slot) slot = this.ensureSlot(name);
		if (slot && !slot.initialized) {
			if (slot.initFromParent) slot.initFromParent(_, this);
			if (this.record !== undefined) {
				slot.fromRecord(_, this.record, this.colnIndex);
			}
			slot.initialized = true;
		}
		return slot;
	}

	sysProperty(name: string) {
		this.sysProperties = this.sysProperties || {};
		name = name.toUpperCase();
		if (!this.sysProperties[name]) {
			if (name === 'AERROR') {
				this.sysProperties.AERROR = {
					get: (_) => {
						this.errors = this.errors || new Errors(_, this);
						return this.errors;
					},
					set: (_, val) => {
						throw new Error("Cannot set AERROR");
					},
				};
			} else if (name === 'ACTX') {
				this.sysProperties.ACTX = {
					get: (_) => {
						return glob.context.x3session.actx;
					},
					set: (_, val) => {
						throw new Error("Cannot set ACTX");
					},
				};
			} else if (name === 'APARENT') {
				this.sysProperties.APARENT = {
					get: (_) => {
						return this.APARENT || null;
					},
					set: (_, val) => {
						throw new Error("Cannot set APARENT");
					}
				};
			} else if (name === 'ASTALIN') {
				this.sysProperties.ASTALIN = {
					get: (_) => {
						return this.$astalin;
					},
					set: (_, astalin) => {
						// ASTALIN can be modified if and only if the instance belongs to a collection
						// Which isn't mapped to its parent :
						if (this.$parent && util.any(this.$parent).collection && !util.any(this.$parent).collection.mappingData) {
							// Restricted set of possible values:
							switch (astalin) {
								case constants.CST_ALL:
									this.$astalin = astalin;
							}
						}
					}
				};
			} else if (name === 'OBJECTTYPE') {
				this.sysProperties.OBJECTTYPE = {
					get: (_) => {
						return "C_" + this.class.name;
					},
					set: (_, val) => {
						throw new Error("Cannot set ObjectType");
					}
				};
			} else if (name === 'OBJECTNBS') {
				this.sysProperties.OBJECTNBS = {
					get: (_) => {
						return this.meta.data.PROPERTIES.length;
					}
				};
			} else if (name === 'OBJECTVAR') {
				this.sysProperties.OBJECTVAR = {
					get: (_) => {
						// fake collection: we only need to support indexing on it
						return {
							collection: true,
							index: (_: _, i: number) => {
								if (i >= 1 && i <= this.meta.data.PROPERTIES.length) return this.meta.data.PROPERTIES[i - 1].FLDCLA;
								else throw new X3Error(10, "bad objectvar index: " + i);
							}
						};
					}
				};
			} else if (this.clasName && name === this.clasName) {
				this.sysProperties[this.clasName] = {
					get: (_) => {
						return this.instance;
					},
					set: (_, val) => {
						throw new Error("Cannot set " + this.clasName);
					}
				};
			}
		}
		return this.sysProperties[name];
	}
	get(_: _, name: string, raw?: boolean) {
		traceGET.debug && traceGET.debug(this.$$type + ".get " + name);
		const s = this.sysProperty(name) || this.slot(_, name);

		if (s) {
			return s.get(_, raw);
		} else {
			//External attributes ?
			var valattr = this.getAttribute("$" + name);
			if (valattr !== undefined) return variables.x3Val(valattr);
			throw new Error(this.$$type + ".get property not found: " + name);
		}
	}

	set(_: _, name: string, value: any, raw?: boolean) {
		traceSET.debug && traceSET.debug(this.$$type + ".set " + name + " value:" + value);

		if (!raw) this.snapshots();
		// Lazy loading of slots:
		const s = this.sysProperty(name) || this.slot(_, name);

		if (s) {
			s.set(_, value, raw === undefined ? false : raw);
			return s;
		} else {
			try {
				//External attributes ?
				this.setAttribute("$" + name, value);
			} catch (e) {
				util.traceException(e);
				throw new Error("Cannot set property: " + name);
			}
		}
	}
	walkToProperty(_: _, path: string, f: PropertyWalker) {
		const properties = path.split("/");

		var instance = this;
		for (var i = 1; i < properties.length; i++) {
			// Element 0 is empty
			if (i === properties.length - 1) {
				// Last part of the path  :
				f(_, instance, properties[i]);
			} else {
				// Get the next element :
				instance = instance.get(_, properties[i], true);
			}
		}
	}
	updateProperty(from: Slot, to: Slot) {
		const _this = this;

		Object.keys(_this.slots).some(property => {
			if (_this.slots[property] == from) {
				_this.slots[property] = to;
				return true;
			}
			return false;
		});
	}

	getPropertyAttribute(_: _, property: string, attribute: string) {
		return this.slot(_, property).getAttribute(attribute);
	}

	ASETATTRPROP(_: _, property: string, attribute: string, value: any) {
		try {
			return this.setPropertyAttribute(_, property, attribute, value);
		} catch (ex) {
			util.traceException(ex);
			return constants.CST_AERROR;
		}
	}

	AGETATTRIBUTE(_: _, property: string, attribute: string) {
		//Must return a string
		if (attributes.isAttributeBoolean(attribute)) return this.getPropertyAttribute(_, property, attribute) === true ? "true" : "false";
		const value = variables.x3Val(this.getPropertyAttribute(_, property, attribute));

		return value.toString();
	}

	setPropertyAttribute(_: _, property: string, attribute: string, value: any) {
		this.snapshots();
		return this.slot(_, property).setAttribute(attribute, value);
	}

	ASETATTRIBUTE(_: _, property: string, attribute: string, value: any) {
		//X3 value is always string
		if (typeof value !== "string") throw new X3Error(10, "invalid attribute value");
		if (attributes.isAttributeBoolean(attribute)) return variables.x3Val(this.setPropertyAttribute(_, property, attribute, value === "true"));
		if (attributes.isAttributeNumber(attribute)) return variables.x3Val(this.setPropertyAttribute(_, property, attribute, value.x3ToInteger()));
		return variables.x3Val(this.setPropertyAttribute(_, property, attribute, value));
	}

	AGETTEXTRA(_: _, property: string) {
		return this.get(_, property);
	}

	AGETTEXT(_: _, property: string) {
		return this.AGETTEXTRA(_, property);
	}

	AGETTEXTRALAN(_: _, property: string, lan: string) {
		const slot = this.slot(_, property);

		if (slot) return slot.getAtextra(_, lan);
		return "";
	}

	AGETTEXTLAN(_: _, property: string, lan: string) {
		return this.AGETTEXTRALAN(_, property, lan);
	}

	ASETTEXT(_: _, property: string, text: string) {
		this.set(_, property, text);
		return constants.CST_AOK;
	}
	ASETTEXTLAN(_: _, property: string, text: string, lan: string) {
		const slot = this.slot(_, property);

		if (slot) slot.setAtextra(_, text, lan);
		return constants.CST_AOK;
	}

	ASETTEXTRALAN(_: _, property: string, text: string, lan: string) {
		this.ASETTEXTLAN(_, property, text, lan);
		return constants.CST_AOK;
	}

	setColumnAttribute(_: _, collection: string, column: string, attribute: string, value: any) {
		const slot = this.slot(_, collection);
		// instanceOf creates circular dependency here
		if ((slot as any).setColumnAttribute) return (slot as any).setColumnAttribute(column, attribute, value);
	}

	getColumnAttribute(_: _, collection: string, column: string, attribute: string) {
		const slot = this.slot(_, collection);

		if (slot && slot.getColAttribute) return slot.getColAttribute(column, attribute);
	}

	scripts(_: _) {
		return this.meta.scripts(_);
	}

	action(_: _, name: string): number {
		throw new Error('invalid call: abstract method');
	}

	actionControl(_: _, operation: string, type: string) {
		return this.action(_, ("A" + [operation, "CONTROL", type].join('_')).toUpperCase());
	}

	actionBeforeControl(_: _, operation: string) {
		return this.actionControl(_, operation, "BEFORE");
	}

	actionAfterControl(_: _, operation: string) {
		return this.actionControl(_, operation, "AFTER");
	}

	assertDeleteAllowed(_: _) {
		if (0) {
			// TODO AGETWRIGHTD
			throw new util.HttpError(403, this.supervisor.loadMess(_, 139, 327) + " " + this.supervisor.loadMess(_, 139, 328));
		}
	}

	withSnapshots<R>(_: _, f: (_: _) => R) {
		this.snap = new Snapshot(this);
		return f.call(this, _);
	}

	withTransaction<R>(_: _, f: (_: _) => R) {
		var status: number;
		try {
			this.transaction = new Transaction();
			status = f.call(this, _);
		} finally {
			// Rollback the transaction if something goes wrong
			this.transaction.rollback(_);
			this.transaction = undefined;
		}
		return status;
	}

	beforeControl(_: _, fname: string): number {
		throw new Error("invalid call: abstract method");
	}
	executeControl(_: _, fname: string): number {
		throw new Error("invalid call: abstract method");
	}
	afterControl(_: _, fname: string): number {
		throw new Error("invalid call: abstract method");
	}
	withControl(_: _, fname: string, f: (_: _) => number) {
		try {
			var status: number;

			util.checkInstance(this);

			var isAllowed = util.any(this)["assert" + fname + "Allowed"];

			isAllowed && isAllowed(_);

			// Propagate the before  to all elements
			status = this.beforeControl(_, fname);
			if (status === constants.CST_AERROR) return status;

			// Execute the control
			status = this.executeControl(_, fname);
			if (status === constants.CST_AERROR) return status;

			// Propagate the after event to all elements
			status = this.afterControl(_, fname);
			if (status === constants.CST_AERROR) return status;

			// Execute the operation:
			status = f.call(this, _);
		} catch (e) {
			// Something went wrong :
			util.traceException(e);
			status = constants.CST_AERROR;
		}
		return status;
	}

	AINIT(_: _) {
		traceSup.debug && traceSup.debug(this.meta.name + ".AINIT");
		var status = constants.CST_AOK;

		// Raz diagnosis:
		this.deleteDiagnoses(_);

		if (this.snap === undefined) {
			this.snap = new Snapshot(this);
			this.snap && this.snap.enable();
		}
		// create instance collection for 1...n, or 1..1		
		if (this.class.relations) {
			Object.keys(this.class.relations).forEach_(_, (_, relation) => {
				if (this.get(_, relation).AINIT) this.get(_, relation).AINIT(_);
			});
		}
		// init properties :

		status = this.propertyInitValues(_);
		if (status === constants.CST_AERROR) return status;
		if (this.instance) {
			status = this.instance.propertyInitValues(_);
			if (status === constants.CST_AERROR) return status;
		}
		// call AINIT event
		status = Math.max(status, this.action(_, "AINIT"));

		this.snap && this.snap.disable();
		this.snap && this.snap.enable();

		return status;
	}

	propertyInitValues(_: _) {
		var status = constants.CST_AOK;
		if (!this.scripts(_)) return status;

		// Temporary disable propagete:
		const properties = this.meta.data.PROPERTIES;

		if (properties) {
			for (var i = 0; i < properties.length; i++) {
				if (!properties[i].FLDGRP) {
					status = Math.max(status, this.propertyInitValue(_, this.properties[properties[i].FLDCLA || properties[i].CODFLD]));
				}
			}
		}
		return status;
	}
	propertyEvent(action: string) {
		return (_: _, prop: Slot | Property, oldValue: any, newValue: any) => {
			tracerEvents.debug && tracerEvents.debug(action + " on " + prop.name + " " + this.$$type + " (" + (this.meta.name + " ") + this.$$dbgId + ")");

			var status = constants.CST_AOK;
			if (prop.type && util.any(prop.type)[action]) {
				// The slot has to be created in this case :
				var slot = util.any(prop).property ? prop : this.slot(_, prop.name);
				status = util.any(prop.type)[action](_, slot);
				if (status === constants.CST_AERROR) return status;
			}

			// TODO: cleanup util.any hack
			const args = this.getActionArgs(_, "ARULE", action, null, util.any(prop));

			if (oldValue) {
				args._AOLDVAL = oldValue;
			}
			if (newValue !== undefined) {
				args._ANEWVAL = newValue;
			}
			var instance: any = this;
			while (instance !== undefined) {
				if (instance.runScripts) {
					status = Math.max(status, instance.runScripts(_, "$PROPERTIES", args));
				}
				var name = instance.proName ? instance.proName + "." : "";
				args.CURPRO.value = name + args.CURPRO.value;
				if (name) args.path.unshift(instance.proJsName);
				instance = instance.$parent;
			}
			return status;
		};
	}

	propertyInitValue(_: _, prop: Property, oldValue?: any) {
		const status = this.propertyEvent("INIT")(_, prop, oldValue, undefined);
		// Set FORMAT if necessary

		prop.type.FORMAT && prop.type.FORMAT(_, this.slot(_, prop.name));
		return status;
	}

	propertyGetValue(_: _, slot: Slot, oldValue: any) {
		return this.propertyEvent("GET")(_, slot, oldValue, undefined);
	}

	propertyControlValue(_: _, slot: Slot, oldValue?: any, newValue?: any) {
		return this.propertyEvent("CONTROL")(_, slot, oldValue, newValue);
	}

	propertyPropagateValueEvent(_: _, slot: Slot, oldValue: any, newValue: any) {
		return this.propertyEvent("PROPAGATE")(_, slot, oldValue, newValue);
	}

	setASTALIN(status: number) {

		var parent: any = this;
		//dbg:console.log("setASTALIN:"+ status+" parent.$astalin:"+parent.$astalin);
		while (parent && !parent.$astalin) {
			//dbg:console.error("************ DBG - updated");
			parent.$astalin = status;
			parent = parent.$parent;
		}
	}

	propertyPropagateValue(_: _, slot: Slot, oldValue: any, newValue: any) {
		// Mark the instance as changed :
		this.setASTALIN(constants.CST_AUPD);
		return this.propertyPropagateValueEvent(_, slot, oldValue, newValue);
	}

	deleteDiagnoses(_: _, etype?: number) {
		this.diagnoses = undefined;
		this.errors = undefined;

		switch (etype) {
			case constants.CST_ACURRENT:
				this.diagnoses = [];
				Object.keys(this.slots).filter(pro => this.slots[pro].collection === undefined)
				.forEach_(_, (_, property) => {
					const diags = this.slots[property].deleteDiagnoses(_);
				});
				break;
			case constants.CST_ALL:
			default:
				Object.keys(this.slots)
				.forEach_(_, (_, property) => {
					const diags = this.slots[property].deleteDiagnoses(_);
				});
		}
		this.diagnoses = undefined;
	}

	addDiagnose(_: _, severity: number, message: string, category?: number) {
		this.diagnoses = this.diagnoses || [];
		trace(severity, message);
		this.diagnoses.push(this.supervisor.new(_, 'Diagnosis', severity, message, "", category));
		return severity;
	}

	getDiagnoses(_: _, sort?: string) {
		const sortMethod = sort || "sortOnTime";
		const local: Diagnosis[] = (this.diagnoses || []).map_(_, (_, d) => {
			if (d.get(_, "CPY") === 0) d.set(_, "PRO", "");
			return d;
		});

		return Object.keys(this.slots).reduce_(_, (_, r, property) => {
			const diags = this.slots[property].getDiagnoses(_);

			if (diags) r = r.concat(diags);
			return r;
		}, local).sort((d0, d1) => util.any(d0)[sortMethod](d1));
	}
	$AREAD(_: _) {
		var key = Array.prototype.slice.call(arguments, 1);
		key = key.join('~');
		traceSup.debug && traceSup.debug(this.meta.name + ".AREAD(" + key + ")");
		util.checkInstance(this);
		return this.withSnapshots(_,  function Read(_: _) {
			//?:this.deleteErrors(_);
			return this.read(_, key);
		});
	}
	$AINSERT(_: _) {
		traceSup.debug && traceSup.debug(this.meta.name + ".AINSERT(" + this.key + ")");
		return this.withControl(_,  'Insert', function Insert(_: _) {
			return this.withTransaction(_,  function (_: _) {
				traceSup.debug && traceSup.debug("Insert " + this.key);
				return this.insert(_);
			});
		});
	}
	$AUPDATE(_: _) {
		traceSup.debug && traceSup.debug(this.meta.name + ".AUPDATE(" + this.key + ")");
		return this.withControl(_,  'Update', function Update(_: _) {
			return this.withTransaction(_,  function (_: _) {
				traceSup.debug && traceSup.debug("Update " + this.key);
				return this.update(_);
			});
		});
	}
	$ADELETE(_: _) {
		traceSup.debug && traceSup.debug(this.meta.name + ".ADELETE(" + this.key + ")");
		return this.withControl(_,  'Delete', function Delete(_: _) {
			return this.withTransaction(_,  function (_: _) {
				traceSup.debug && traceSup.debug("Delete " + this.key);
				return this.delete(_);
			});
		});
	}

	manageSlots(_: _, operation: string) {
		Object.keys(this.slots).forEach_(_, (_, name) => {
			util.any(this.slots[name])[operation] && util.any(this.slots)[name][operation](_);
		});
		const parent: any = this.$parent;

		parent && parent.manageSlots && parent.manageSlots(_, operation);
	}

	collectionSlot(_: _, collection: string): SlotCollection {
		return util.any(this.slot(_, collection));
	}
	/* 
 ADDLINE makes it possible to support the legacy syntax :
   [L]LINE = fmet INS1.ADDLINE("AQCORDL",[V]CST_ALASTPOS)
 which should be replaced now by 
   [L]LINE = fmet INS1.AQCORDL.AADD([V]CST_ALASTPOS)
 */
	
	ADDLINE(_: _, collection: string, position: number) {
		// add only exists on SlotCollection
		return this.collectionSlot(_, collection).add(_, position);
	}

	/* 
 ADELLINE makes it possible to support the legacy syntax :
   [L]STATUS = fmet INS1.ADELLINE("AQCORDL",[V]CST_ALASTPOS)
 which should be replaced now by 
   [L]STATUS = fmet INS1.AQCORDL.ADEL([V]CST_ALASTPOS)
 */

	getSortedDiagnoses(_: _, etype: number, sort: string) {
		sort = sort || "sortOnTime";

		switch (etype) {
			case constants.CST_ACURRENT:
				return Object.keys(this.slots).filter(pro => this.slots[pro].collection === undefined)
				.reduce_(_, (_, r, property) => {
					const diags = this.slots[property].getDiagnoses(_);

					if (diags) r = r.concat(diags);
					return r;
				}, this.diagnoses || []).sort((d0, d1) => util.any(d0)[sort](d1));
			case constants.CST_ALL:
			default:
				return this.getDiagnoses(_, sort);
		}
	}

	ADELLINE(_: _, collection: string, position: number) {
		const deletedAt = this.collectionSlot(_, collection).del(_, position);

		return constants.CST_AOK;
	}

	ADELETEERROR(_: _, property: string) {
		if (property === constants.CST_ALLERRORS) return this.ADELETEERRORALL(_);
		else {
			var owner: any = property && this.slots[property] ? this.slots[property] : this;
			owner.deleteDiagnoses(_, constants.CST_ACURRENT);
			return constants.CST_AOK;
		}
	}

	ADELETEERRORALL(_: _) {
		this.deleteDiagnoses(_, constants.CST_ALL);
		return constants.CST_AOK;
	}

	isThrowing() {
		for (var p: any = this; p; p = p.$parent) {
			if (p.throwing) return true;
		}
		return false;
	}

	ASETERROR(_: _, path: string, message: string, severity: number) {
		if (this.isThrowing() && severity == constants.CST_AERROR) throw new Error(message);
		// HACK : each time an error is added this.AERRORS is recomputed
		this.errors = undefined;
		const owner: any = path && this.properties[path] ? this.slot(_, path) : this;

		return owner.addDiagnose(_, severity, message);
	}

	onMapChange(_: _, property: string, value: any) {
		return this.slot(_, property).set(_, value);
	}

	ASETERRORCAT(_: _, path: string, message: string, severity: number, category: string) {
		// HACK : each time an error is added this.AERRORS is recomputed
		this.errors = undefined;
		// TODO : rechercher pointeur...
		const owner: any = path && this.properties[path] ? this.slot(_, path) : this;
		return owner.addDiagnose(_, severity, message, category);
	}

	AGETMAXERROR(_: _) {
		const err = this.getSortedDiagnoses(_, constants.CST_ACURRENT, "sortOnSeverity")[0];
		return err ? err.severity : 0;
	}

	AGETMAXERRORALL(_: _) {
		const err = this.getSortedDiagnoses(_, constants.CST_ALL, "sortOnSeverity")[0];
		return err ? err.severity : 0;
	}

	AGETERRORSFROM(_: _, iorigin: any, env: any) {
		const errc = iorigin.getSortedDiagnoses(_).map_(_, (_: _, e: any) => e.clone(_, env));
		this.diagnoses = (this.diagnoses || []).concat(errc);
		return constants.CST_AOK;
	}

	ASEARCHINFOS(_: _, local: number, property: string, status: number, selstatus: number) {
		const errt = util.any(this).getSortedDiagnoses(_, local).filter_(_, (_: _, e: any) => {
			var ftr = true;
			if (local === constants.CST_ACURRENT && property) ftr = ftr && e.get(_, "PRO") === property;

			switch (selstatus) {
				case 0:
					ftr = ftr && e.get(_, "STA") <= status;
					break;
				case 1:
					ftr = ftr && e.get(_, "STA") === status;
					break;
				case 2:
					ftr = ftr && e.get(_, "STA") > status;
					break;
			}
			return ftr;
		}).map_(_, (_: _, e: any) => {
			//dbg:console.log("!  "+e.message);
			return e.clone(_);
		});

		this.atabinfos = errt && errt.length > 0 ? errt : undefined;
		return constants.CST_AOK;
	}

	xmetAGETNEXTINFOS(_: _, args: any[]) {

		if (this.atabinfos && this.atabinfos.length > 0) {
			var e = this.atabinfos.shift();
			args[0] = e.get(_, "STA"); // ASTATUS
			args[1] = e.get(_, "PRO"); // PROPERTY
			args[2] = e.get(_, "LAB"); // LABEL
			args[3] = e.get(_, "MES"); // MESSAGE
			args[4] = e.get(_, "CAT"); // CATEGORY
			args[5] = e.get(_, "ENV"); // ENVIRONMENT
		} else {
				this.atabinfos = undefined;
				return constants.CST_ANOREC;
			}

		return constants.CST_AOK;
	}

	xmetAGETMAXERRORTXT(_: _, args: any[]) {

		// args[0] : err_type
		if ([constants.CST_ALL, constants.CST_ACURRENT].indexOf(args[0]) < 0) throw new X3Error(69, "ERR_TYPE");

		const err = this.getSortedDiagnoses(_, args[0], "sortOnSeverity")[0];

		if (!err) return constants.CST_ANOREC;

		args[1] = err.get(_, "PRO"); // PROPERTY
		args[2] = err.get(_, "STA"); // ASTATUS
		args[3] = err.get(_, "LAB"); // LABEL
		args[4] = err.get(_, "MES"); // MESSAGE
		args[5] = err.get(_, "CAT"); // CATEGORY
		args[6] = err.get(_, "ENV"); // ENVIRONMENT
		return constants.CST_AOK;
	}

	xmethMethods(_: _, name: string, args: types.Expression<any>[]) {
		const vals = basic.instructions.A(args)(_);
		const r = util.any(this)[name](_, vals);

		for (var i = 0; i < args.length; i++) {
			try {
				// we try on every parameter
				if (Array.isArray(vals[i])) {
					// to do or not to do ?				
				} else args[i](_, variables.vOperations['SET'], vals[i]);
			} catch (e) {
				if (e.errn !== 62) throw e;
			}
		}
		return r;
	}

	toX3son(_: _) {
		return "!C_" + this.class.name.replace(/\./g, '_') + "{" + Object.keys(this.slots).map_(_, (_, name) => {
			var v = this.slots[name].get(_);
			v = v.x3Maxtab ? v.lines : v;
			return name + ':' + X3SON.stringify(_, v);
		}).join('') + "};";
	}

	_activeLoading(_: _) {
		this.class.relations && Object.keys(this.class.relations).forEach_(_, (_, relation) => {
			const slot = this.slot(_, relation);

			if (slot) {
				var col = slot.get(_);
				col.activeLoading && col.activeLoading(_);
			}
		});
		// Do this only once :
		this.activeLoading = undefined;
	}
}

attributes.addAttributes(BaseInstance.prototype);
snapshots.addSnapshots(BaseInstance.prototype);