"use strict";

var glob = require('streamline/lib/globals');
var util = require("etna/lib/supervisor/util");
var Helper = util.Helper;

var activ = require("etna/lib/supervisor/meta/activ");
var runtime = require('etna/lib/engine/runtime/runtime');
var variables = require('etna/lib/engine/runtime/variables');
var X3Error = require("etna/lib/engine/runtime/errors").X3Error;
var tuuid = require('etna/lib/engine/runtime/tuuid');
var utilRuntime = require('etna/lib/engine/runtime/util');
var X3SON = require("etna/lib/engine/x3son");

var mapping = require("etna/lib/supervisor/mapping");
var constants = require("etna/lib/supervisor/constants");
var Errors = require("etna/lib/supervisor/errors").Errors;
var Transaction = require("etna/lib/supervisor/transaction").Transaction;
var snapshots = require("etna/lib/supervisor/snapshots");
var Snapshot = require("etna/lib/supervisor/snapshot").Snapshot;
var Diagnosis = require("etna/lib/supervisor/meta/diagnosis");
var attributes = require("etna/lib/supervisor/attributes");

var traceSup = require('syracuse-core').getTracer("etna.supervisor");
var traceGET = require('syracuse-core').getTracer("etna.accessorsGet");
var traceSET = require('syracuse-core').getTracer("etna.accessorsSet");
var tracerEvents = require('syracuse-core').getTracer("etna.events");

var dbgId = 0;

class BaseInstance extends Helper {
	constructor(superv) {
		super();
		this.supervisor = superv;
		this.data = null;
		this.key = null;
		this.diagnoses = [];
		this.proName = "";
		this.proJsName = "";
		this.$uuid = tuuid.generate();
		this.$$dbgId = ++dbgId;
		this.$astalin = 0;
		this.activeLoading = this._activeLoading;
	}

	get $id(){
		this._$id = this._$id || tuuid.generate();
		return this._$id;
	}
	
	init(_) {
		return this;
	}

	// Lazy loading of slots:
	slot(_, name) {
		if (this.slots[name]) return this.slots[name];

		if (this.properties[name]) {
			this.slots[name] = this.properties[name].newSlot(_, this);

			if (this.record !== undefined) {
				this.slots[name].fromRecord(_, this.record, this.colnIndex);
			}
			return this.slots[name];
		}
	}

	sysProperty(name) {
		this.sysProperties = this.sysProperties || {};
		name = name.toUpperCase();
		if (!this.sysProperties[name]) {
			if (name === 'AERROR') {
				this.sysProperties.AERROR = function(self) {
					return {
						_get: function(_) {
							self.errors = self.errors || new Errors(_, self);
							return self.errors;
						},
						_set: function(_, val) {
							throw new Error("Cannot set AERROR");
						}

					};
				}(this);
			} else if (name === 'ACTX') {
				this.sysProperties.ACTX = {
					_get: function(_) {
						return glob.context.x3session.actx;
					},
					_set: function(_, val) {
						throw new Error("Cannot set ACTX");
					}
				};
			} else if (name === 'APARENT') {
				this.sysProperties.APARENT = function(self) {
					return {
						_get: function(_) {
							return self.APARENT || null;
						},
						_set: function(_, val) {
							throw new Error("Cannot set APARENT");
						}
					};
				}(this);
			} else if (name === 'ASTALIN') {
				this.sysProperties.ASTALIN = function(self) {
					return {
						_get: function(_) {
							return self.$astalin;
						},
						_set: function(_, astalin) {
							// ASTALIN can be modified if and only if the instance belongs to a collection
							// Which isn't mapped to its parent :
							if (self.$parent && self.$parent.collection && !self.$parent.collection.mappingData) {
								// Restricted set of possible values:
								switch (astalin) {
									case constants.CST_ALL:
										self.$astalin = astalin;
								}
							}
						}
					};
				}(this);
			} else if (name === 'OBJECTTYPE') {
				this.sysProperties.OBJECTTYPE = function(self) {
					return {
						_get: function(_) {
							return "C_" + self.class.name;
						},
						_set: function(_, val) {
							throw new Error("Cannot set ObjectType");
						}
					};
				}(this);
			} else if (name === 'OBJECTNBS') {
				this.sysProperties.OBJECTNBS = function(self) {
					return {
						_get: function(_) {
							return self.meta.data.PROPERTIES.length;
						}
					};
				}(this);
			} else if (name === 'OBJECTVAR') {
				this.sysProperties.OBJECTVAR = function(self) {
					return {
						_get: function(_) {
							// fake collection: we only need to support indexing on it
							return {
								collection: true,
								index: function(_, i) {
									if (i >= 1 && i <= self.meta.data.PROPERTIES.length)
										return self.meta.data.PROPERTIES[i - 1].FLDCLA;
									else
										throw new X3Error(10, "bad objectvar index: " + i);
								},
							};
						},
					};
				}(this);
			} else if (this.clasName && name === this.clasName) {
				this.sysProperties[this.clasName] = function(self) {
					return {
						_get: function(_) {
							return self.instance;
						},
						_set: function(_, val) {
							throw new Error("Cannot set " + self.clasName);
						}
					};
				}(this);
			}
		}
		return this.sysProperties[name];
	};
	_get(_, raw) {
		if (this.$lazyLoading) {
			var self = this;
			this.class.loadInstances(_,
				this.$parent,
				mapping.getIndex(_, this.supervisor, this.class.data.dataChildren.ownMapping),
				this.relKeys,
				1,
				function(_, record) {
					self.record = record;
				}).toArray(_);
			this.afterCreate(_,this.record);
			this.$lazyLoading = false;
		}
		return this;
	};
	get(_, name, raw) {
		traceGET.debug && traceGET.debug(this.$$type + ".get " + name);
		var s = this.sysProperty(name) || this.slot(_, name);
		if (s) {
			return s._get(_, raw);
		} else {
			//External attributes ?
			var valattr = this.getAttribute("$" + name);
			if (valattr !== undefined) return variables.x3Val(valattr);
			throw new Error(this.$$type + ".get property not found: " + name);
		}
	}

	set(_, name, value, raw) {
		traceSET.debug && traceSET.debug(this.$$type + ".set " + name + " value:" + value);

		if (!raw) this.snapshots();
		// Lazy loading of slots:
		var s = this.sysProperty(name) || this.slot(_, name);
		if (s) {
			s._set(_, value, (raw === undefined) ? false : raw);
			return s;
		} else {
			try {
				//External attributes ?
				this.setAttribute("$" + name, value);
			} catch (e) {
				throw new Error("Cannot set property: " + name);
			}
		}
	};
	walkToProperty(_, path, f) {
		var properties = path.split("/");
		var instance = this;
		for (var i = 1; i < properties.length; i++) { // Element 0 is empty
			if (i === (properties.length - 1)) {
				// Last part of the path  :
				f(_, instance, properties[i]);
			} else {
				// Get the next element :
				instance = instance.get(_, properties[i], true);
			}
		}
	};
	updateProperty(from, to) {
		var _this = this;
		Object.keys(_this.slots).some(function(property) {
			if (_this.slots[property] == from) {
				_this.slots[property] = to;
				return true;
			}
			return false;
		});
	}

	getPropertyAttribute(_, property, attribut) {
		return this.slot(_, property).getAttribute(attribut);
	}

	ASETATTRPROP(_, property, attribut, value) {
		try {
			return this.setPropertyAttribute(_, property, attribut, value);
		} catch (ex) {
			return constants.CST_AERROR;
		}
	}

	AGETATTRIBUTE(_, property, attribut) {
		//Must return a string
		if (attributes.isAttributeBoolean(attribut))
			return (this.getPropertyAttribute(_, property, attribut) === true ? "true" : "false");
		var value = variables.x3Val(this.getPropertyAttribute(_, property, attribut));
		return value.toString();
	}

	setPropertyAttribute(_, property, attribut, value) {
		this.snapshots();
		return this.slot(_, property).setAttribute(attribut, value);
	}

	ASETATTRIBUTE(_, property, attribut, value) {
		//X3 value is always string
		if (typeof value !== "string") throw new X3Error(10, "invalid attribute value");
		if (attributes.isAttributeBoolean(attribut))
			return variables.x3Val(this.setPropertyAttribute(_, property, attribut, (value === "true")));
		if (attributes.isAttributeNumber(attribut))
			return variables.x3Val(this.setPropertyAttribute(_, property, attribut, value.x3ToInteger()));
		return variables.x3Val(this.setPropertyAttribute(_, property, attribut, value));
	}

	AGETTEXTRA(_, property) {
		return this.get(_, property);
	}

	AGETTEXT(_, property) {
		return this.AGETTEXTRA(_, property);
	}

	AGETTEXTRALAN(_, property, lan) {
		var slot = this.slot(_, property);
		if (slot) return slot.getAtextra(_, lan);
		return "";
	}

	AGETTEXTLAN(_, property, lan) {
		return this.AGETTEXTRALAN(_, property, lan);
	}

	ASETTEXT(_, property, text) {
		this.set(_,property,text);
		return constants.CST_AOK;
	};
	ASETTEXTLAN(_, property, text, lan) {
		var slot = this.slot(_, property);
		if (slot) slot.setAtextra(_, text, lan);
		return constants.CST_AOK;
	}

	ASETTEXTRALAN(_, property, text, lan) {
		this.ASETTEXTLAN(_, property, text, lan);
		return constants.CST_AOK;
	}

	setColumnAttribute(_, collection, column, attribut, value) {
		var slot = this.slot(_, collection);
		if (slot && slot.setColumnAttribute) return slot.setColumnAttribute(column, attribut, value);
	}

	getColumnAttribute(_, collection, column, attribut) {
		var slot = this.slot(_, collection);
		if (slot && slot.getColAttribute) return slot.getColAttribute(column, attribut);
	}

	scripts(_) {
		return this.meta.scripts(_);
	}

	actionControl(_, operation, type) {
		return this.action(_, ("A" + [operation, "CONTROL", type].join('_')).toUpperCase());
	}

	actionBeforeControl(_, operation) {
		return this.actionControl(_, operation, "BEFORE");
	}

	actionAfterControl(_, operation) {
		return this.actionControl(_, operation, "AFTER");
	}

	assertDeleteAllowed(_) {
		if (0) {
			// TODO AGETWRIGHTD
			throw new util.HttpError(403, this.supervisor.loadMess(_, 139, 327) + " " + this.supervisor.loadMess(_, 139, 328));
		}
	}

	withSnapshots(_, f) {
		this.snap = new Snapshot(this);
		return f.call(this, _);
	}

	withTransaction(_, f) {
		var status;
		try {
			this.transaction = new Transaction();
			status = f.call(this, _);
		} finally {
			// Rollback the transaction if something goes wrong
			this.transaction.rollback(_);
			this.transaction = undefined;
		}
		return status;
	}

	withControl(_, fname, f) {
		try {
			var status;

			util.checkInstance(this);

			var isAllowed = this["assert" + fname + "Allowed"];

			isAllowed && isAllowed(_);

			// Propagate the before  to all elements
			status = this.beforeControl(_, fname);
			if (status === constants.CST_AERROR) return status;

			// Execute the control
			status = this.executeControl(_, fname);
			if (status === constants.CST_AERROR) return status;

			// Propagate the after event to all elements
			status = this.afterControl(_, fname);
			if (status === constants.CST_AERROR) return status;

			// Execute the operation:
			status = f.call(this, _);
		} catch(e) {
			// Something went wrong :
			util.traceException(e);
			status = constants.CST_AERROR; 
		}
		return status;
	};


	AINIT(_) {
		traceSup.debug && traceSup.debug(this.meta.name+".AINIT");
		var self = this;
		var status = constants.CST_AOK;

		// Raz diagnosis:
		this.deleteDiagnoses(_);

		if (this.snap === undefined) {
			this.snap = new Snapshot(this);
			this.snap && this.snap.enable();
		}
		// create instance collection for 1...n, or 1..1		
		if (this.class.relations) {
			Object.keys(this.class.relations).forEach_(_, function(_, relation) {
				if (self.get(_, relation).AINIT) self.get(_, relation).AINIT(_);
			});
		}
		// init properties :

		status = this.propertyInitValues(_)
		if(status === constants.CST_AERROR) return status;
		if (this.instance) {
			status = this.instance.propertyInitValues(_);
			if(status === constants.CST_AERROR) return status;
		}
		// call AINIT event 
		status = Math.max(status, this.action(_, "AINIT"));

		this.snap && this.snap.disable();
		this.snap && this.snap.enable();

		return status;
	}

	propertyInitValues(_) {
		var status = constants.CST_AOK;
		if (!this.scripts(_)) return status;

		// Temporary disable propagete:
		var properties = this.meta.data.PROPERTIES;
		if(properties) {
			for (var i = 0; i < properties.length; i++) {
				if (!properties[i].FLDGRP) {
					status = Math.max(status, this.propertyInitValue(_, this.properties[properties[i].FLDCLA || properties[i].CODFLD]));
				}
			}
		}
		return status;
	}

	propertyEvent(action) {
		var self = this;
		return function(_, prop, oldValue) {
			tracerEvents.debug && tracerEvents.debug(action + " on " + prop.name + " " + self.$$type + " (" + (self.meta.name+" ") + self.$$dbgId + ")");

			var status = constants.CST_AOK;
			if(prop.type && prop.type[action]) {
				// The slot has to be created in this case : 
				var slot = prop.property ? prop : self.slot(_,prop.name); 
				status = prop.type[action](_,slot);
				if(status === constants.CST_AERROR) return status;
			}

			var args = self.getActionArgs(_, "ARULE", action, null, prop);
			if (oldValue) {
				args._AOLDVAL = oldValue;
			}
			var instance = self;
			while (instance !== undefined) {
				if (instance.runScripts) {
					status = Math.max(status,instance.runScripts(_, "$PROPERTIES", args));
				}
				var name = instance.proName ? (instance.proName + ".") : "";
				args.CURPRO.value = name + args.CURPRO.value;
				if (name) args.path.unshift(instance.proJsName);
				instance = instance.$parent;
			}
			return status;
		};
	}

	propertyInitValue(_, prop, oldValue) { 
		var status = this.propertyEvent("INIT")(_, prop, oldValue);
		// Set FORMAT if necessary
		prop.type.FORMAT && prop.type.FORMAT(_,this.slot(_,prop.name));
		return status;
	}

	propertyGetValue(_, slot, oldValue) { 
		return this.propertyEvent("GET")(_, slot, oldValue);
	}

	propertyControlValue(_, slot, oldValue) {
		return this.propertyEvent("CONTROL")(_, slot, oldValue);
	}

	propertyPropagateValueEvent(_, slot, oldValue) {
		return this.propertyEvent("PROPAGATE")(_, slot, oldValue);
	}

	setASTALIN(status) {

		var parent = this;
		//dbg:console.log("setASTALIN:"+ status+" parent.$astalin:"+parent.$astalin);
		while (parent && !parent.$astalin) {
			//dbg:console.error("************ DBG - updated");
			parent.$astalin = status;
			parent = parent.$parent;
		}
	}

	propertyPropagateValue(_, slot, oldValue) {
		// Mark the instance as changed :
		this.setASTALIN(constants.CST_AUPD);
		return this.propertyPropagateValueEvent(_, slot, oldValue);
	}

	deleteDiagnoses(_, etype) {
		var self = this;
		this.diagnoses = undefined;
		this.errors = undefined;

		switch (etype) {
			case constants.CST_ACURRENT:
				this.diagnoses = [];
				Object.keys(self.slots).filter(function(pro) {
					return self.slots[pro].collection === undefined;
				}).forEach_(_, function(_, property) {
					var diags = self.slots[property].deleteDiagnoses(_);
				});
				break;
			case constants.CST_ALL:
			default:
				Object.keys(self.slots).forEach_(_, function(_, property) {
					var diags = self.slots[property].deleteDiagnoses(_);
				});
		}
		this.diagnoses = undefined;
	}

	addDiagnose(_, severity, message, category) {
		this.diagnoses = this.diagnoses || [];
		Diagnosis.trace(severity, message);
		this.diagnoses.push(this.supervisor.new(_, 'Diagnosis', severity, message, "", category));
		return severity;
	}

	getDiagnoses(_, sort) {
		var self = this;
		var sortMethod = (sort || "sortOnTime");

		var local = (this.diagnoses || []).map_(_, function(_, d) {
			if (d.get(_, "CPY") === 0) d.set(_, "PRO", "");
			return d;
		});

		return Object.keys(this.slots).reduce_(_, function(_, r, property) {
			var diags = self.slots[property].getDiagnoses(_);
			if (diags) r = r.concat(diags);
			return r;
		}, local).sort(function(d0, d1) {
			return d0[sortMethod](d1);
		});
	};
	$AREAD(_) {
		var key = Array.prototype.slice.call(arguments, 1);
		key = key.join('~');
		traceSup.debug && traceSup.debug(this.meta.name+".AREAD(" + key + ")");
		util.checkInstance(this);
		return this.withSnapshots(_, function Read(_) {
			//?:this.deleteErrors(_);
			return this.read(_, key);
		});
	};
	$AINSERT(_) {
		traceSup.debug && traceSup.debug(this.meta.name+".AINSERT(" + this.key + ")");
		return this.withControl(_, 'Insert', function Insert(_) {
			return this.withTransaction(_, function(_) {
				traceSup.debug && traceSup.debug("Insert " + this.key);
				return this.insert(_);
			});
		});
	};
	$AUPDATE(_) {
		traceSup.debug && traceSup.debug(this.meta.name+".AUPDATE(" + this.key + ")");
		return this.withControl(_, 'Update', function Update(_) {
			return this.withTransaction(_, function(_) {
				traceSup.debug && traceSup.debug("Update " + this.key);
				return this.update(_);
			});
		});
	}
	$ADELETE(_) {
		traceSup.debug && traceSup.debug(this.meta.name+".ADELETE(" + this.key + ")");
		return this.withControl(_, 'Delete', function Delete(_) {
			return this.withTransaction(_, function(_) {
				traceSup.debug && traceSup.debug("Delete " + this.key);
				return this.delete(_);
			});
		});
	}

	manageSlots(_,operation) {
		Object.keys(this.slots).forEach_(_, (_, name) => {
			this.slots[name][operation] && this.slots[name][operation](_);
		});
		var parent = this.$parent;
		parent && parent.manageSlots && parent.manageSlots(_,operation);
	}

	/* 
	ADDLINE makes it possible to support the legacy syntax :
	  [L]LINE = fmet INS1.ADDLINE("AQCORDL",[V]CST_ALASTPOS)
	which should be replaced now by 
	  [L]LINE = fmet INS1.AQCORDL.AADD([V]CST_ALASTPOS)
	*/
	ADDLINE(_, collection, position) {
		return this.slot(_, collection).add(_, position);
	}

	/* 
	ADELLINE makes it possible to support the legacy syntax :
	  [L]STATUS = fmet INS1.ADELLINE("AQCORDL",[V]CST_ALASTPOS)
	which should be replaced now by 
	  [L]STATUS = fmet INS1.AQCORDL.ADEL([V]CST_ALASTPOS)
	*/

	getSortedDiagnoses(_, etype, sort) {

		var self = this;
		sort = sort || "sortOnTime";

		switch (etype) {
			case constants.CST_ACURRENT:
				return Object.keys(self.slots).filter(function(pro) {
					return self.slots[pro].collection === undefined;
				}).reduce_(_, function(_, r, property) {
					var diags = self.slots[property].getDiagnoses(_, sort);
					if (diags) r = r.concat(diags);
					return r;
				}, (self.diagnoses || [])).sort(function(d0, d1) {
					return d0[sort](d1);
				});
			case constants.CST_ALL:
			default:
				return self.getDiagnoses(_, sort);

		}
	}
	
	ADELLINE(_, collection, position) {
		var deletedAt = this.slot(_, collection).del(_, position);
		return constants.CST_AOK;
	}

	ADELETEERROR(_, property) {
		if (property === constants.CST_ALLERRORS) return this.ADELETEERRORALL(_);
		else {
			var owner = (property && this.slots[property]) ? this.slots[property] : this;
			owner.deleteDiagnoses(_, constants.CST_ACURRENT);
			return constants.CST_AOK;
		}
	}

	ADELETEERRORALL(_) {
		var self = this;
		this.deleteDiagnoses(_, constants.CST_ALL);
		return constants.CST_AOK;
	}

	ASETERROR(_, path, message, severity) {
		// HACK : each time an error is added this.AERRORS is recomputed
		this.errors = undefined;
		var owner = (path && this.properties[path]) ? this.slot(_, path) : this;
		return owner.addDiagnose(_, severity, message);
	}


	onMapChange(_, property, value) {
		return this.slot(_, property)._set(_, value);
	}

	ASETERRORCAT(_, path, message, severity, category) {
		// HACK : each time an error is added this.AERRORS is recomputed
		this.errors = undefined;
		// TODO : rechercher pointeur...
		var owner = (path && this.properties[path]) ? this.slot(_, path) : this;
		return owner.addDiagnose(_, severity, message, category);
	}

	AGETMAXERROR(_) {
		var err = this.getSortedDiagnoses(_, constants.CST_ACURRENT, "sortOnSeverity")[0];
		return err ? err.severity : 0;
	}

	AGETMAXERRORALL(_) {

		var err = this.getSortedDiagnoses(_, constants.CST_ALL, "sortOnSeverity")[0];
		return err ? err.severity : 0;
	}

	AGETERRORSFROM(_, iorigin, env) {

		var errc = iorigin.getSortedDiagnoses(_).map_(_, function(_, e) {
			return e.clone(_, env);
		});
		this.diagnoses = (this.diagnoses || []).concat(errc);
		return constants.CST_AOK;
	}


	ASEARCHINFOS(_, local, property, status, selstatus) {
		var errt = this.getSortedDiagnoses(_, local).filter_(_, function(_, e) {
			var ftr = true;	
			if ((local === constants.CST_ACURRENT) && property)
				ftr = ftr && (e.get(_, "PRO") === property);

			switch (selstatus) {
				case 0:
					ftr = ftr && (e.get(_, "STA") <= status);
					break;
				case 1:
					ftr = ftr && (e.get(_, "STA") === status);
					break;
				case 2:
					ftr = ftr && (e.get(_, "STA") > status);
					break;

			}
			return ftr;
		}).map_(_, function(_, e) {
			//dbg:console.log("!  "+e.message);
			return e.clone(_);
		});

		this.atabinfos = (errt && errt.length > 0) ? errt : undefined;
		return constants.CST_AOK;
	}

	xmetAGETNEXTINFOS(_, args) {

		if (this.atabinfos && this.atabinfos.length > 0) {
			var e = this.atabinfos.shift();
			args[0] = e.get(_, "STA"); // ASTATUS
			args[1] = e.get(_, "PRO"); // PROPERTY
			args[2] = e.get(_, "LAB"); // LABEL
			args[3] = e.get(_, "MES"); // MESSAGE
			args[4] = e.get(_, "CAT"); // CATEGORY
			args[5] = e.get(_, "ENV"); // ENVIRONMENT
	
		} else {
			this.atabinfos = undefined;
			return constants.CST_ANOREC;
		}

		return constants.CST_AOK;
	}

	xmetAGETMAXERRORTXT(_, args) {

		// args[0] : err_type
		if ([constants.CST_ALL, constants.CST_ACURRENT].indexOf(args[0]) < 0) return new X3Error(69, "ERR_TYPE");

		var err = this.getSortedDiagnoses(_, args[0], "sortOnSeverity")[0];

		if (!err) return constants.CST_ANOREC;

		args[1] = err.get(_, "PRO"); // PROPERTY
		args[2] = err.get(_, "STA"); // ASTATUS
		args[3] = err.get(_, "LAB"); // LABEL
		args[4] = err.get(_, "MES"); // MESSAGE
		args[5] = err.get(_, "CAT"); // CATEGORY
		args[6] = err.get(_, "ENV"); // ENVIRONMENT
		return constants.CST_AOK;
	}

	xmethMethods(_, name, args) {

		var vals = utilRuntime.instructions.A(args)(_);
		var r = this[name](_, vals);
		for (var i = 0; i < args.length; i++) {
			try {
				// we try on every parameter
				if (Array.isArray(vals[i])) {
					// to do or not to do ?				
				} else
					args[i](_, variables.vOperations.SET, vals[i]);
			} catch (e) {
				if (e.errn !== 62) throw e;
			}
		}
		return r;
	}

	toX3son(_) {
		var self = this;
		return "!C_" + this.class.name.replace(/\./g, '_') + "{" + Object.keys(this.slots).map_(_, function(_, name) {
			var v = self.slots[name]._get(_);
			v = v.x3Maxtab ? v.lines : v;
			return name + ':' + X3SON.stringify(_, v);
		}).join('') + "};";
	}

	_activeLoading(_) {
		var self = this;
		this.class.relations && Object.keys(this.class.relations).forEach_(_, function(_, relation) {
			var slot = self.slot(_, relation);
			if (slot) {
				var col = slot._get(_);
				col.activeLoading && col.activeLoading(_);
			}
		});
		// Do this only once :
		this.activeLoading = undefined;
	}

}

attributes.addAttributes(BaseInstance.prototype);
snapshots.addSnapshots(BaseInstance.prototype);

exports.BaseInstance = BaseInstance;
