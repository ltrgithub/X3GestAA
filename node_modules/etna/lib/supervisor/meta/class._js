"use strict";

var ez = require("ez-streams");
var util = require("etna/lib/supervisor/util");
var glob = require('streamline-runtime').globals;
var utilRuntime = require('etna/lib/engine/runtime/util');
var tuuid = require('etna/lib/engine/runtime/uuid');
var tdate = require('etna/lib/engine/runtime/tdate');
var tdatetime = require('etna/lib/engine/runtime/tdatetime');
var variables = require('etna/lib/engine/runtime/variables');
var activ = require("etna/lib/supervisor/meta/activ");
var filterHelpers = require("syracuse-sdata-parser/lib/json-converter");
var constants = require("etna/lib/supervisor/constants");
var Cache = require("etna/lib/supervisor/cache").Cache;
var utilDriver = require("etna/lib/engine/drivers/util");
var BaseClass = require("etna/lib/supervisor/meta/baseClass").BaseClass;
var type = require("etna/lib/supervisor/meta/type");
var newSlotReference = require("etna/lib/supervisor/slotReference").newSlotReference;
var newSlotCollection = require("etna/lib/supervisor/slotCollection").newSlotCollection;
var newInstance = require("etna/lib/supervisor/meta/instance").newInstance;
var X3Error = require('etna/lib/engine/runtime/errors').X3Error;

var trim = utilDriver.trim;

var tracerJs = require('syracuse-core').getTracer("etna.supervisor");
var cacheMethods = require('etna/lib/supervisor/builtins/ACTXCACHE').cacheMethods;

function bulkWriter(httpContext) {
	var sep;
	return ez.devices.generic.writer(function(_, resource) {
		if (!sep) {
			httpContext.response.writeHead(200, {
				"content-type": "application/json"
			});
			httpContext.response.write(_, '[');
		}
		if (resource === undefined) {
			httpContext.response.end("]");
		} else {
			httpContext.response.write(_, (sep || '') + JSON.stringify(resource.dataNode(_)), "utf8");
		}
		sep = ',';
	});
};

var typDonmet2EtnaType = {
	1: "D",
	2: "S",
	3: "I",
	4: "N",
	5: "T",
	6: "B"
};

const _supervProperties = [{
	FLDCLA: "ASTALIN",
	CODTYP: "C",
	LONG: 4
}, {
	FLDCLA: "AORDER",
	CODTYP: "C",
	LONG: 4
}, {
	FLDCLA: "AUUID",
	CODTYP: "AUUID",
}, {
	FLDCLA: "CREUSR",
	CODTYP: "AUS",
}, {
	FLDCLA: "UPDUSR",
	CODTYP: "AUS",
}, {
	FLDCLA: "CREDATTIM",
	CODTYP: "ADATIM",
}, {
	FLDCLA: "UPDDATTIM",
	CODTYP: "ADATIM",
}, {
	FLDCLA: "_AFCRIGHT",
	CODTYP: "A",
	LONG: 30
}, {
	FLDCLA: "UPDTICK",
	CODTYP: "L",
	LONG: 0
}];

class Class extends BaseClass {
	constructor(superv, data, group) {
		super(superv, data);

		this.relations = {};
		this.parent = null;
		this.keyItems = data.KEYINT ? data.KEYINT.split('+') : [];
		this.group = group;
		this.cache = {};
		this.curpath = "";
		this.codclaPath = this.data.CODCLA;
		this.class = this;
		if (this.data.PARAM_DEFS) {
			this.data.PARAM_DEFS = this.data.PARAM_DEFS.sort(function(ep1, ep2) {
				var info1 = ep1.CODE + "_" + (ep1.TYPKEY === 2 ? "A" : "B") + ep1.NOPAR;
				var info2 = ep2.CODE + "_" + (ep2.TYPKEY === 2 ? "A" : "B") + ep2.NOPAR;
				if (info1 < info2) return -1;
				if (info1 > info2) return 1;
				return 0;
			});
		}

		// Default behaviors
		this.reader = this.sqlReader;
		this.read = this.sqlRead;
		this.membersByJsName = {};
		this.jsModules = [];
		superv.classesByJsName[data.jsName || data.CODCLA] = this;
	}
	get $$type() {
		return "Class";
	}
	get isSearchable() {
		return this.data && this.data.FLGSEARCH && (this.data.FLGSEARCH === 2);
	}
	get name() {
		return this.data.CODCLA;
	}	
	get index() {
		return this._index;
	}	
	get tableIndex() {
		return (this.table && this.data.INDREF) ? this.table.index(this.data.INDREF) : null;
	}	
	init(_) {
		var self = this;

		if (this.properties) return this;
		if (this.data.dataChildren) {
			if (this.data.dataChildren.ownMapping) {
				this.data.table = this.supervisor.load(_, 'Table', this.data.dataChildren.ownMapping.TABLNK);
				this.data.LINKS = this.data.dataChildren.LINKS ? this.data.LINKS.concat(this.data.dataChildren.LINKS) : this.data.LINKS;
				this.data.MAPS  = this.data.dataChildren.MAPS ? this.data.MAPS.concat(this.data.dataChildren.MAPS) : this.data.MAPS;
			}
			this.data.codclaPath = this.data.dataChildren.codclaPath;
			this.parent = this.data.dataChildren.parent;
			this.curpath = this.data.dataChildren.curpath;
		}
		tracerJs.debug && tracerJs.debug("Init de  C_" + this.data.CODCLA + " " + this.curpath);
		if (this.parent) tracerJs.debug && tracerJs.debug(" parent = '" + this.parent.data.CODCLA + "'");
		var tableCode = this.data.TABREF || this.data.CODCLA;
		tracerJs.debug && tracerJs.debug("class this.data.TYPCLA:" + this.data.TYPCLA + "--" + this.data.CODCLA);
		var jsInterface;
		this.isInterface = false;
		this.queryInstances = this.queryInstancesSql;

		try {
			jsInterface = require("etna/lib/supervisor/builtins/" + this.data.CODCLA);
		} catch (e) {} finally {}

		if (jsInterface && jsInterface.AQUERY) {
			this.reader = this.jsReader;
			this.jsInterface = jsInterface;
		}
		if (this.data.TYPCLA === 2) { // 2 for persistent class
			this.table = this.table || this.supervisor.load(_, 'Table', tableCode);
			if (!this.table) throw new Error("table not found: " + tableCode);
		} else if (this.data.table) {
			this.table = this.data.table;
		}

		if (this.data.TYPCLA === 5) {
			// This class is an interface
			this.read   = this.intRead;
			this.insert = this.intInsert;
			this.update = this.intUpdate;
			this.delete = this.intDelete;
			this.isInterface = true;
			if(!this.jsInterface) this.queryInstances = this.queryInstancesInt;
		}

		this.jsName = this.data._proxyName || this.name;
		var supervPropertiesFields = _supervProperties.reduce(function(r, property) {
			r.push(property.FLDCLA);
			return r;
		}, []);

		var supervProperties = _supervProperties;
		// if(this.data.PROPERTIES) supervProperties = supervProperties.concat(this.data.PROPERTIES);
		if(this.data.PROPERTIES) supervProperties = this.data.PROPERTIES.concat(supervProperties);
		this.properties = supervProperties.reduce_(_, (_, r, propData) => {
				var name = propData.FLDCLA;
				if (!((self.group || "") !== ((!propData.LNKCLA && propData.FLDGRP) || "")) || supervPropertiesFields.indexOf(name) >= 0) {

					tracerJs.debug && tracerJs.debug("+" + self.data.CODCLA + "." + name);

					if (r[name] && supervPropertiesFields.indexOf(name) < 0) throw new Error("duplicate property " + name);

					r[name] = self.supervisor.new(_, 'Property', self, propData);

					r[name].toControl = ["ASTALIN","AORDER","_AFCRIGHT","UPDTICK"].indexOf(name) < 0;
					r[name].jsName = propData._proxyName;
					this.membersByJsName[r[name].jsName || name] = r[name];

					if (propData.OBLIG === 2) {
						self.mandatoryProperties = self.mandatoryProperties || [];
						self.mandatoryProperties.push(name);
					}
					if (r[name].isReference()) {
						// Add a property :
						tracerJs.debug && tracerJs.debug(" " + self.data.CODCLA + "." + name + " is a reference");
						name = r[name].ref(name);
						r[name] = self.supervisor.new(_, 'Property', self, propData, newSlotReference);
						r[name].isReference(true);
						r[name].jsName = r[name].data._proxyName + 'Ref';
					}
				}
				return r;
			}, {}, this);

		this.relations = {};
		this.data.COLLECTIONS && this.data.COLLECTIONS.forEach_(_, function(_, data) {
			tracerJs.debug && tracerJs.debug("Class collection:" + data.CODCOL);
			var coln = self.relations[data.CODCOL] = self.supervisor.new(_, 'Collection', this, data);

			var name = data.CODCOL;
			var p = self.properties[name];
			if (!p) {
				self.relations[name] = coln;
				p = self.properties[name] = self.supervisor.new(_, 'Property', self, {
					FLDCLA: name
				}, newSlotCollection, coln);

				// generate synthetic class for group of indexed properties
				coln.ofIndexedProperties = true;
				coln.class = self.supervisor.new(_, 'Class', {
					CODCLA: self.data.CODCLA + "." + name,
					TYPCLA: 1, //5,
					PROPERTIES: self.data.PROPERTIES.filter(function(propData) {
						return propData.FLDGRP === name;
					}),
					PARAM_FLDS: self.data.PARAM_FLDS,
					COLLECTIONS: [],
					table: self.table
				}, name);
				//Calculate count
				if (data.ACTGRP & data.ACTGRP !== "") {
					var activ = self.supervisor.load(_, 'Activ', data.ACTGRP);
					coln.count = activ.dimension;
				} else if (data.MAXCOL > 0) {
					coln.count = data.MAXCOL;
				}
				if (!coln.count) {
					coln.count = 1;
					coln.class.data.PROPERTIES.forEach_(_, function(_, propData) {
						if (coln.class.table) {
							var col = util.find(coln.class.table.data.COLUMNS, 'CODZONE', propData.FLDCLA);
							if (col) {
								var dime = 0;
								if (col.CODACT & col.CODACT !== "") {
									var activcol = self.supervisor.load(_, 'Activ', col.CODACT);
									dime = activcol.dimension;
								}
								dime = Math.max(dime, col.DIME);
								coln.count = Math.max(dime, coln.count);
							}
						}
					});
				}
				//
				coln.class.parent = this;
				if (coln.class.data.PROPERTIES) {
					coln.class.data.PROPERTIES.forEach_(_, function(_, prop) {
						if (coln.class.data.PARAM_FLDS) {
							coln.class.data.PARAM_FLDS.forEach_(_, function(_, fld) {
								if (fld.FLDCLA === prop.FLDCLA && fld.VALEUR) {
									if (name + "." === fld.VALEUR.substring(0, name.length + 1)) {
										fld.VALEUR = fld.VALEUR.substring(name.length + 1);
									}
								}
							}, name, prop);
						}
					}, name);
				}
			} else {
				//mapping can be on main class
				var wcurpath = name;
				var wcurcla = this;
				while (wcurcla.data.TYPCLA !== 2 && wcurcla.parent) {
					wcurpath = self.curpath + "." + wcurpath;
					wcurcla = wcurcla.parent;
				}
				var mapping = wcurcla.data.LINKS && util.find(wcurcla.data.LINKS, 'REFLNK', wcurpath);
				//console.error(this.name+" col:"+data.CODCOL+ " wcurpath:"+wcurpath+" mapping:"+!!mapping);

				var targetName;
				var targetTable;
				if (mapping && mapping.MAPS) {

					// Memorize maps at the propeties level
					mapping.MAPS
						.filter(function(map) {return map.PROMAP && map.KEYMAP;})
						.forEach(function(map) {
							self.properties[map.PROMAP].proMaps = self.properties[map.PROMAP].proMaps || [];
							self.properties[map.PROMAP].proMaps.push(map);
						});

					coln.mappingData = mapping;

					targetName = mapping.CLALNK;
				} else {
					targetName = p.data.LNKCLA;
				}

				if (!targetName) throw new Error("cannot find target name for collection " + name);
				tracerJs.debug && tracerJs.debug("coln.mappingData  " + JSON.stringify(coln.mappingData));

				var clas = self.supervisor.load(_, 'Class', self.codclaPath + "." + targetName, {
					ownMapping: coln.mappingData,
					//normally not needed LINKS: self.data.LINKS, // inherith from LINKS defined at the top level
					//normallynot needed MAPS: self.data.MAPS, // inherith from MAPS defined at the top level
					codclaPath: self.codclaPath + "." + targetName,
					curpath: name, //(self.curpath) ? self.curpath + "." + name : name
					parent: self,
				});
				if (!clas) throw new Error("target class missing for collection " + name);

				coln.class = clas;
				if (coln.mappingData && coln.mappingData.TYPLNK === 3) {
					// relation = class <-> class (replace p:)
					tracerJs.debug && tracerJs.debug(self.codclaPath + "." + name + " is a class");

					self.properties[name] = self.supervisor.new(_, 'Property', self, {
						FLDCLA: name
					}, newInstance, coln);
				} else {
					self.properties[name] = self.supervisor.new(_, 'Property', self, {
						FLDCLA: name
					}, newSlotCollection, coln);
				}
			}
			//if (!data._proxyName) throw new Error("_proxyName missing: " + name);
			self.properties[name].jsName = data._proxyName,
			self.membersByJsName[data._proxyName] = self.properties[name];
		}, this);

		this.stdMethods = this.data.STD_METHODS ? this.data.STD_METHODS.reduce_(_, function(_, r, method) {
			if (method.ENAMETSTD === 2 && activ.getActiv(_, self.supervisor, method.ACTMETSTD) > 0) {
				switch (method.CODMETSTD) {
					case 'C':
						r.AINSERT = method;
						break;
					case 'R':
						r.AREAD = method;
						break;
					case 'U':
						r.AUPDATE = method;
						break;
					case 'D':
						r.ADELETE = method;
						break;
				}
			}
			return r;
		}, {}) : {};

		this.methods = this.data.METHODS ? this.data.METHODS.reduce_(_, function(_, r, method) {
			var noPar=0;
			r[method.CODMET] = {
				type: (method.FLGOPE===2) ? "$OPERATIONS":"$METHODS",
				params: method.PARAM_DEFS ? method.PARAM_DEFS
					.reduce_(_, function(_, r, param) {
						param.NOPAR = noPar++;
						r[param.CODPAR] = {
							type: "L" + type.typTyp2EtnaType[param.TYPINTPAR],
							index: function(nopar) {
								return function(args) {
									return ((args && args.length >= nopar) ? nopar : -1);
								};
							}(param.NOPAR),
							get: function(nopar) {
								return function(args) {
									return ((args && args[nopar]) ? args[nopar] : variables.types[type.typTyp2EtnaType[param.TYPINTPAR]].default);
								};
							}(param.NOPAR),
						};
						if (param.MODPAR === 1) { ///1:variable arg 2:value arg 3:constant
							r[param.CODPAR].set = function(nopar) {
								return function(_, args, value) {
									var arg = args[nopar];
									arg(_, variables.vOperations.SET, value);
									return arg[nopar];
								};

							}(param.NOPAR);
						}
						return r;
					}, {}) : {},
				buildArgs : function($method) {
						return function(_,instance) {
							var args = {
								CURPTH: {
									type: "LS",
									value: ""
								},
								THIS: {
									type: "LY",
									value: instance
								},
								
							};
							args[($method.FLGOPE===2) ? "AOPERATION" :"AMETHOD"] = {
								type: "LS",
								value: $method.CODMET
							};		

							// add keys
							if($method.FLGOPE && $method.PARAM_DEFS) {
							  $method.PARAM_DEFS
								.filter(function(param) { return  param.TYPKEY === 2;})
								.forEach_(_,function(_,param) {
									args[param.CODPAR] = {
										value: instance.get(_,param.CODPAR),
										type: "L"+type.typTyp2EtnaType[param.TYPINTPAR]
									}
								});
							}

							if($method.DONMET) {
								args.ARET_VALUE = {
									type: "L" + typDonmet2EtnaType[$method.DONMET],
									value:variables.types[typDonmet2EtnaType[$method.DONMET]].default,
									set:function(_, args, value){}
								};
							}
							return args;
						}
					}(method),
				getServiceArgs: function($method) {
					return function(_, key , qs) {
						var keyValues = key.split('~');
						var noKey=0;

						var newArgs = $method.PARAM_DEFS ? $method.PARAM_DEFS
							.reduce_(_, function(_, r, param) {
								var defaultValue = variables.types[type.typTyp2EtnaType[param.TYPINTPAR]].default;
								if(param.TYPKEY === 2) {
									r.push({ value: keyValues[noKey++] || defaultValue});
								} else {
									var varObj = defaultValue;
									if (qs[param.CODPAR]) {
										var val = qs[param.CODPAR];
										if (val === '""') val = defaultValue;
										varObj = variables.types[type.typTyp2EtnaType[param.TYPINTPAR]].set(param.CODPAR, param.CODPAR, val);
									} 
									r.push({ value: varObj, noset: true});
								}
								return r;
							}, []) : [];
							//dbg:console.log("getServiceArgs:",newArgs);
							return newArgs;
						};
					}(method),
				getServiceReturn:function() {
					return function(_, res) {
						var newReturn = {};
						newReturn.$type = variables.types[typDonmet2EtnaType[method.DONMET]].jsonDefaultType;
						if (method.DONMET === 6) {
							newReturn.$value = (res.x3IsEmpty() === true ? "" : res.x3ToBase64());
						} else if (method.DONMET === 3 || method.DONMET === 4) {
							newReturn.$value = res.x3ToDouble().valueOf();
						} else {
							newReturn.$value = (res.x3IsZero() ? "" : (res.x3ToJson && res.x3ToJson()) ||
								(res.x3ToString && res.x3ToString()) ||
								res.toString());
						}
						return newReturn;
					};
				}()
			};
			return r;
		}, {}) : {};

		// Add cache methods to the class if necessary 
		if (this.data.FLGBUFFER === 2) {
			Object.keys(cacheMethods).forEach(function(method) {
				self[method] = cacheMethods[method];
			});
		}
		return this;
	}
	/* 
	Add methods to an instance
	*/
	addMethods(instance) {
		var self = this;
		Object.keys(this.stdMethods).forEach(function(stdMethod) {
			instance[stdMethod] = instance["$" + stdMethod];
		});

		var xmeth = function(clas, method, methodType) {
			methodType = methodType || "$METHODS";
			return function(_) {
				var args = (Array.prototype.slice.call(arguments).length > 0) ? Array.prototype.slice.call(arguments).slice(1) : [];

				var meth = self.methods[method];
				var xmethName = "xmet" + method;

				var instance = this;
				if (instance[xmethName]) {
					return instance["xmethMethods"](_, xmethName, args);
				}

				// Get arguments values :
				var vals = utilRuntime.instructions.A(args)(_);
				//dbg:console.log("vals:",vals);

				if (vals.length > 0 && Object.keys(meth.params).length  > vals.length) {
					throw new X3Error(69, "parameter count mismatch: expected " + (Object.keys(meth).length - 1) + ", got " + vals.length);
				}

				var methArgs = meth.buildArgs(_,instance);

				// add parameters:
				methArgs = Object.keys(meth.params).reduce(function(r, p) {
					if (meth.params[p].type) {
						r[p] = {
							type: meth.params[p].type,
							value: meth.params[p].get(vals),
							isParam: true,
						};
						if (meth.params[p].set) r[p].set = meth.params[p].set;
					}
					return r;
				}, methArgs );

				//dbg:console.log("1.methArgs:",methArgs);
				var status = this.runScripts(_, methodType, methArgs);

				// Manage variable arguments :
				var retValue;
				Object.keys(meth.params).filter(function(arg) {
					return meth.params[arg].set;
				}).forEach_(_, function(_, arg) {
					var index = meth.params[arg].index(args);
					var noset = (index >= 0 && args[index].noset === true);
					if (noset === false) {
						meth.params[arg].set(_, args, methArgs[arg].value);
					}
				});
				//dbg:console.log("methArgs.2:",methArgs);
				return  methArgs.ARET_VALUE ? methArgs.ARET_VALUE.value : status;
			};
		};

		instance.methods["xmetAGETMAXERRORTXT"] = xmeth(self,"AGETMAXERRORTXT", "$OPERATIONS");
		instance.methods["xmetAGETNEXTINFOS"] = xmeth(self,"AGETNEXTINFOS", "$OPERATIONS");

		Object.keys(this.methods).forEach(function(method) {
			instance.methods = instance.methods || {};
			instance.methods["xmet" + method] = 
				xmeth(self,method,self.methods[method].type);
		});
	}

	property(name) {
		var prop = this.properties[name];
		if (!prop) throw new Error("prop not found: " + this.name + "." + name);
		return prop;
	}

	check(_, facet) {
		if (!this.isActivated(_))
			throw new util.HttpError(406, this.supervisor.loadMess(_, 140, 31) + ' ' + this.data.CODCLA + " (" + this.data.CODACT + ")");
		if (facet && /^\$(search|bulk|query|lookup|details|summary|edit)$/.test(facet)) {
			if (!this.stdMethods.AREAD) throw new util.HttpError(406, this.supervisor.loadMessParams(_, 149, 31, this.supervisor.loadMess(_, 7983, 7), this.data.CODCLA));
			if (facet === "$edit" && !this.stdMethods.AINSERT && !this.stdMethods.AUPDATE) {
				throw new util.HttpError(406, this.supervisor.loadMessParams(_, 149, 32, this.supervisor.loadMess(_, 7983, 1), this.supervisor.loadMess(_, 7983, 10), this.data.CODCLA));
			}
		}
	}
	keyExpression(_) {
		return this.table ? this.tableIndex.keyExpression(_) : "{" + this.data.KEYINT + "}";
	}

	createInstance(_, qs) {
		return this.supervisor.new(_, 'Instance', this).afterCreate(_);
	}

	readInstance(_, parent, key, qs) { // x3js API, key is array
		var index = this.tableIndex;
		var instances = this.loadInstances(_, parent, index, key, 1).toArray(_);
		return instances[0];
	}
	
	queryExpToSelect(_, exp, params, tableNames) {
		var self = this;
		var map = {
			'$eq': '=',
			'$ne': '!=',
			'$gt': '>',
			'$gte': '>=',
			'$lt': '<',
			'$lte': '<=',
			'$regex': 'like'
		};

		var param = this.supervisor.sqlDriver.param;

		return Object.keys(exp).reduce_(_, function(_, r, prop) {
			var id = prop;
			var expColumn = function(column) {
				return column;
			};

			var match = id.match(/upper\((\w*)\)/);
			if (match) {
				id = match[1];
				expColumn = function(column) {
					return 'UPPER(' + column + ')';
				};
			}
			if (!self.properties[id]) throw new Error("Property " + id + " missing for class " + self.name);
			var column = self.properties[id].column.sqlName();

			var propExp = exp[prop];

			var hasExp = (typeof propExp === 'object' && propExp !== null) && Object.keys(propExp).some(function(key) {
				return (key.charAt(0) === '$');
			}) || false;

			var operators = hasExp ? propExp : {
				$eq: propExp
			};
			r.push(Object.keys(operators).reduce(function(r, operator) {
				if (map[operator]) {
					var sqlOperator = map[operator];
					var value = operators[operator];
					var valueType = typeof value;

					if (value === null || (Array.isArray(value) && !value.length)) return r;

					if (valueType === 'boolean') {
						value = value ? 2 : 1;
					} else if (self.properties[id].etnaType === 'D' && (valueType === 'string')) {
						value = new Date(value);
					} else if (self.properties[id].etnaType === 'E') {
						value = tdatetime.x3Parse(value).toJsDate();
					} else if (sqlOperator === 'like') {
						if (value.charAt(0) === '^') value = value.substring(1);
						else value = '%' + value;
						value = value.replace(/\.\*/g, '%');
					}
					params.push(value);
					r.push(expColumn(column) + ' ' + sqlOperator + ' ' + param(params.length - 1));
				}
				return r;
			}, []).join(" and "));
			return r;
		}, []).join(" and ");
	}
	
	queryToSelect(_, query, params) {
		var operator = (query.$or) ? "or" : (query.$and ? "and" : undefined);
		if (operator) {

			var self = this;
			return query['$' + operator].reduce_(_, function(_, r, exp) {
				var select = self.queryToSelect(_, exp, params);
				if (select.length) r.push('(' + select + ')');
				return r;
			}, []).join(' ' + operator + ' ');
		}
		return this.queryExpToSelect(_, query, params);
	}

	queryInstancesSql(_, select, max) {
		return this.reader(_, null, select, max, null);
	}

	queryInstancesInt(_, select, max) {
		var rt = require('etna/lib/engine/runtime');
		var z=rt.instructions;

		var expToWhere = function(exp) {
			// console.log("expToWhere:",exp);
			var wheres = Object.keys(exp).reduce(function(r, prop){
				var propExp = exp[prop];
					var hasExp = (typeof propExp === 'object' && propExp !== null) && Object.keys(propExp).some(function(key) {
					return (key.charAt(0) === '$');
				}) || false;

				var operators = hasExp ? propExp : {$eq: propExp};		
				r.push(Object.keys(operators).reduce(function(r, operator) {
					var sqlOp=z.SQLEQ;
					switch(operator) {
						case '$eq' : sqlOp = z.SQLEQ; break;
						case '$ne' : sqlOp = z.SQLNE; break;
						case '$gt' : sqlOp = z.SQLGT; break;
						case '$gte': sqlOp = z.SQLGE; break;
						case '$lt' : sqlOp = z.SQLLT; break;
						case '$lte': sqlOp = z.SQLLE; break;
					}
					return sqlOp(z.SQLCV('?','LNK_',prop),z.C(propExp[operator]));
				},{}));
				return r;
			},[]);
			return wheres;
		}
		
		var selectToWhere  = function(select) {
			if(!select || !select.$query) return;
			return z.WHERE(expToWhere(select.$query));
		}

		var selectToOrder  = function(select) {
			if(!select || !select.$orderBy) return;
			return z.ORDER(null, Object.keys(select.$orderBy).reduce(function(r,key) {
				r.push(z.ORDERITEM(z.SQLCV('?','LNK_',key),select.$orderBy[key] === 1 ? '+' : '-'));
				return r;
			},[]), null, null, z.C(null));
		}

		var reader ;
		var lnk = glob.context.queryFrame.context.tables.LNK_;
		if(lnk) {
			//ORDER('KEY1',[ORDERITEM(SQLCV('F','BPAZ','CRY'),'+')],null, null, C(null))
			var frame = glob.context.x3frame;
			glob.context.x3frame = glob.context.queryFrame;

			var where  = selectToWhere(select);
			var order  = selectToOrder(select);
			var filter = z.FILTER("LNK_", where, order);
			filter && filter(_);
			glob.context.x3frame = frame;

			reader = function(_,cursor) {
				return ez.devices.generic.reader(function(_) {
					var frame = glob.context.x3frame;
					glob.context.x3frame = glob.context.queryFrame;
					var record = cursor.x3GetRecord(_);
					glob.context.x3frame = frame;
					if(!record) cursor.x3CloseDBReader(_);
					return record; 
				});
			}(_, lnk.x3OpenFor(_, lnk.findKey(""), 0, 0, 0));
		} else {
			reader = ez.devices.generic.reader(function(_) {return;});
		}
		return reader.limit(max).map(this.class.fromRecordMapper(_));
	}
	sqlReader(_, parent, select, max, $recordMapper) {
		tracerJs.debug && tracerJs.debug("class.sqlReader:" + JSON.stringify(select));
		tracerJs.debug && tracerJs.debug(this.table.name + "   " + "class.sqlReader(" + max + "):" + JSON.stringify(select));
		var self = this;
		var recordMapper = $recordMapper || function() {
				return function(_, record) {
					var astatus;
					var instance = self.supervisor.new(_, 'Instance', self, parent).afterCreate(_, record);
					return instance;
				};
			}();

		var orderBy;
		var descs = [];
		var columnNames = [];
		var wheres = [];
		var params = [];
		var properties = this.properties;
		var param = this.supervisor.sqlDriver.param;
		tracerJs.debug && tracerJs.debug("this.table = " + JSON.stringify(this.table.name));
		var tableNames = [this.table.name + ' T'];
		var sqlOpts = {};

		// add link with ACCES if ACCSTR is filled.
		if (this.data.ACCSTR) {
			tracerJs.debug && tracerJs.debug("add ACCSTR " + this.data.ACCSTR);
			tableNames.push("ACCES ACC");

			params.push(glob.context.x3session.actx.$USER(_));
			wheres.push("ACC.USR_0 = " + param(params.length - 1));
			wheres.push("ACC.CODACC_0 = T." + this.data.ACCSTR + "_0");
			wheres.push("ACC.CONSUL_0 = 2");
		}

		// clear the cache
		var cache = new Cache();

		Object.keys(properties).forEach_(_, function(_, name) {
			properties[name].getSql && properties[name].getSql(_, columnNames, tableNames, wheres, params, descs, cache, false, sqlOpts);
		});

		orderBy = [];
		if (select && select.$orderBy) {
			Object.keys(select.$orderBy).forEach_(_, function(_, name) {
				var column = properties[name].column.sqlName();
				orderBy.push(column + " " + ((select.$orderBy[name] === 1) ? "asc" : "desc"));
			});
		} else {
			var index = this.tableIndex;
			index && index.sqlNames().forEach(function(column) {
				orderBy.push(column + " asc");
			});
		}
		if (select && (select.$query || (!select.$query && !select.$orderBy))) {
			var qsel = this.queryToSelect(_, select.$query || select, params);
			if (qsel !== "") wheres.push(qsel);
			tracerJs.debug && tracerJs.debug("wheres:" + wheres);
		}
		var i = 0;
		var sql = "select T.UPDTICK_0, " + columnNames.join(',') + " from " + tableNames.join(',');

		if (wheres.length) sql += " where (" + wheres.join(') and (') + ')';
		if (orderBy.length) sql += " order by " + orderBy.join(',');
		var reader = self.supervisor.sqlReader(_, sql, params, sqlOpts).limit(max);
		reader = reader.map(recordMapper);
		if (cache.isActivated) reader = reader.transform(cache.transform());
		return reader;
	}
	jsReader(_, parent, select, max, $recordMapper) {
		tracerJs.debug && tracerJs.debug("class.jsReader(" + max + "):" + JSON.stringify(select));
		var self = this;
		var recordMapper = $recordMapper || function() {
				return function(_, record) {
					return self.supervisor.new(_, 'Instance', self, null).afterCreate(_, record);
				};
			}();
		var reader = this.jsInterface.AQUERY(_, select);
		if (!reader.read) reader = this.rsReader(_, this.jsInterface.AQUERY(_, select), select);
		return reader.limit(max).map(recordMapper);
	}
	cleanFilter(filter) {
		var self = this;
		var keys = Object.keys(filter);
		if (!keys.length) return;

		return keys.reduce(function(r, k) {
			var match = k.match(/upper\((\w*)\)/);
			var p = match ? match[1] : k;
			r[p] = filter[k];
			if (Array.isArray(r[p])) {
				for (var i = 0; i < r[p].length; i++) {
					r[p][i] = self.cleanFilter(r[p][i]);
				}
			} else if (typeof r[p] === 'object') r[p] = self.cleanFilter(r[p]);
			return r;
		}, {});
	}
	rsReader(_, recordset, select) {
		if (select && select.$orderBy) {
			var sort = function(orderBy) {
				var fcts = Object.keys(orderBy).reduce(function(r, property) {
					r.push(function(ascDesc) {
						return function(a, b) {
							var A = a[property];
							var B = b[property];
							if (A > B) return ascDesc;
							if (A < B) return -1 * ascDesc;
							return 0;
						};
					}(orderBy[property]));
					return r;
				}, []);
				return function(o1, o2) {
					var cmp = 0;
					for (var i = 0; i < fcts.length; i++) {
						cmp = fcts[i](o1, o2);
						if (cmp) break;
					}
					return cmp;
				};
			}(select.$orderBy);
			recordset = recordset.sort(sort);
		}
		var reader = ez.devices.generic.empty.reader.transform(function(_, reader, writer) {
			recordset.forEach_(_, function(_, record) {
				writer.write(_, record);
			});
		});
		if (select && (select.$query || (!select.$query && !select.$orderBy))) {
			var filter = this.cleanFilter(select.$query || select);
			if (filter) reader = reader.filter(filter);
		}
		return reader;
	}
	loadInstances(_, parent, index, vals, max, $recordMapper) {
		return this.reader(
			_,
			parent,
			Object.keys(vals).reduce(function(o, c) {
				if (index.columns[c]) {
					if (vals[c] !== undefined) {
						o[index.columns[c].name] = vals[c];
					} else {
						o[index.columns[c].name] = index.columns[c].type.defaultValue;
					}
				}
				return o;
			}, {}),
			max,
			$recordMapper);
	}
	fromRecordMapper(_, instance) {
		return function(_, record) {
			tracerJs.debug && tracerJs.debug("fromRecordMapper:" + JSON.stringify(record));
			var ins = instance ? instance : this.supervisor.new(_, 'Instance', this, null);
			// // TODO: check astatus
			return ins.afterCreate(_, record);
		}.bind(this);
	}

	keyToSelect(key) {
		var index = this.tableIndex;
		var self = this;
		if (!Array.isArray(key)) key = key.split("~");

		return Object.keys(this.index).reduce(function(r, i) {
			r[self.index[i].name] = key[i];
			return r;
		}, {});
	}
	sqlRead(_, instance, key) {
		var mapper = this.fromRecordMapper(_, instance);
		instance.snap && instance.snap.enable();
		var instances = this.reader(_, instance.parent, this.keyToSelect(key), 1, mapper).toArray(_);
		if (!instances || !instances.length) {
			tracerJs.error && tracerJs.error("class.read " + key + " not found");
			var status = instance.addDiagnose(_, constants.CST_AERROR, key + " : " + this.supervisor.loadMess(_, 100, 23));
			return constants.CST_AERROR;
		}
		instance.key = key;
		return constants.CST_AOK;
	}
	intInsert(_, instance) {
		return this.intCrud(_, 'AINSERT', instance);
	}
	intUpdate(_, instance) {
		return this.intCrud(_, 'AUPDATE', instance);
	}
	intDelete(_, instance) {
		return this.intCrud(_, 'ADELETE', instance);
	}
	intRead(_, instance, key) {
		return this.intCrud(_, 'AREAD', instance, key);
	}
	intCrud(_, f_name, instance, key) {
		var status = constants.CST_AOK;
		var args = {
			AEVENT: {
				type: "LS",
				value: f_name
			},
			THIS: {
				type: "LY",
				value: instance
			}
		};
		if (key === undefined) {
			// AINSERT, AUPDATE, ADELETE
			var status = instance.action(_, f_name, key);
		} else {
			var index = this.data.KEYINT.split('+');
			var keys = key.toString().split('~');
			var i = 0;

			index.forEach_(_, function(_, property) {
				instance.set(_, property, keys[i++], true);
			});
			instance.snap && instance.snap.enable();
			var status = instance.action(_, f_name, key);
		}
		instance.$astalin = constants.CST_ALL;
		return status;

	}
	insert(_, instance) {
		tracerJs.debug && tracerJs.debug("class "+this.name+".insert");
		
		if (instance && !instance.supportsTable("insert")) return constants.CST_AOK;
		var result = this.table.insert(_, instance);
		return (result && result.updateCount) ? constants.CST_AOK : constants.CST_AERROR;
	}
	update(_, instance) {
		tracerJs.debug && tracerJs.debug("class "+this.name+".update");
		if (!instance.supportsTable("update")) return constants.CST_AOK;
		var result = this.table.update(_, instance);
		return (result && result.updateCount) ? constants.CST_AOK : constants.CST_AERROR;
	}
	delete(_, instance) {
		var status = constants.CST_AOK;
		if (instance.supportsTable("delete")) {
			var result = this.table.delete(_, instance);
			status = (result && result.updateCount) ? constants.CST_AOK : constants.CST_AERROR;
			tracerJs.debug && tracerJs.debug("class "+this.name+".delete result:" + JSON.stringify(result));
		}
		return status;
	}
	searchResourceFactory(_) {
		return this.supervisor.new(_, 'SearchResourceFactory', this);
	}
	searchProto(_) {
		var factory = this.searchResourceFactory(_);
		return factory.searchProto(_);
	}
	search(_, httpContext, qs) {
		var factory = this.searchResourceFactory(_);
		var dst = bulkWriter(httpContext);
		var select;
		// where=((UPDDATTIM gt "2015-03-17T12:59:39.144Z"))
		if (qs.where) select = filterHelpers.sdataToJson(qs.where);

		var fromInstanceToResource = function(_, instance) {
			return this.supervisor.new(_, 'Resource', factory, instance).bindInstance(instance);
		}.bind(this);
		this.reader(_, null, select, Infinity).map(fromInstanceToResource).pipe(_, dst);
	}
	readLob(_, context, property, ident1, ident2, ident3) {
		var key =[ident1];
		if(ident2) key.push(ident2);
		if(ident3) key.push(ident3);

		var instance = this.createInstance(_);
		var status = instance.read(_,key.join('~'));
		
		if(status !== constants.CST_AERROR) {
			var slot = instance.slot(_, property);
			if (slot) {
				var contentType = slot.contentType(_);
				var data = slot.read(_);
				context.response.writeHead(200, {
					'content-type': contentType,
					'Transfer-Encoding': 'chunked',
					'X-FRAME-OPTIONS': 'DENY'
				});
				return context.response.end(data);
			}
		} 		
		throw new HttpError(404, this.name+'.'+property + '('+key.join('~')+ ") couldn't be loaded");
	}
};

module.exports = {
	collectionName: 'ACLASSE',
	keyName: 'CODCLA',
	systemProperties: _supervProperties,
	constructor: Class,
};