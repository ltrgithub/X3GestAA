"use strict";

import { _ } from 'streamline-runtime';
import * as types from '../../engine/runtime/types';
import * as util from '../util';
import { Table } from './table';
import { Type } from './type';
import { Supervisor } from '../supervisor';
import { ColumnMeta } from '../metadata/table';
const tracerJs = require('syracuse-core').getTracer("etna.supervisor");

export interface ColumnDesc {
	name: string;
	index: number;
	offset: number;
	type: Type;
}

export class Column {
	supervisor: Supervisor;
	table: Table;
	data: ColumnMeta;
	type: Type;
	index: number;
	dim: number;
	constructor(superv: Supervisor, table: Table, data: ColumnMeta) {
		this.supervisor = superv;
		this.table = table;
		this.data = data;
		util.checkDataProperty(this.data, "LONG");
	}
	init(_: _) {
		//dbg:console.log("column:",this.data);
		this.type = this.supervisor.load(_, 'Type', this.data.CODTYP);
		if (!this.type) {
			throw new Error("Table " + this.table.name + " column " + this.name + " missing type:" + this.data.CODTYP);
		}

		const activ = this.data.CODACT ? this.supervisor.load(_, 'Activ', this.data.CODACT) : undefined;

		this.dim = activ ? activ.data.DIME : this.data.DIME;
		this.dim = this.dim || 1;
		return this;
	}
	get name() {
		return this.data.CODZONE;
	}
	sqlNames(prefix: string, alias?: string, sqlOpts?: types.SqlQueryOptions) {
		prefix = prefix || '';

		const wrap =  (name: string) => prefix + name + (alias ? " As " + alias + "$" + name : "");

		var s = '';
		for (var i = 0, dim = this.dim; i < dim; i++) {
			var colName = this.data.CODZONE + '_' + i;
			s += (i > 0 ? ',' : '') + wrap(colName);
			if (sqlOpts && this.type.data.TYPTYP === 4) {
				sqlOpts.decimalColumns = sqlOpts.decimalColumns || [];
				sqlOpts.decimalColumns.push(alias ? alias + "$" + colName : colName);
			}
		}
		return s;
	}

	sqlNamesAssign() {
		var s = "";
		for (var i = 0, dim = this.dim; i < dim; i++) {
			var colName = this.data.CODZONE + '_' + i;
			s += (i > 0 ? ',' : '') + colName + " = @?";
		}
		return s;
	}

	sqlDescs(descs: ColumnDesc[]) {
		for (var i = 0, dim = this.dim; i < dim; i++) {
			if (!this.type.sqlType()) continue;
			descs.push({
				name: this.data.CODZONE,
				index: dim > 1 ? i : null,
				offset: descs.length,
				type: this.type
			});
		}
	}
	sqlTypesMap(typesmap: number[]) {
		for (var i = 0, dim = this.dim; i < dim; i++) {
			if (!this.type.sqlType()) continue;
			typesmap.push(this.type.data.TYPTYP);
		}
	}
	sqlDef() {
		const typeStr = this.type.sqlType(this.data);

		if (!typeStr) return null;
		var s = "";
		const dim = this.dim; // TODO get dim from activity code if missing here

		for (var i = 0; i < dim; i++) s += (s ? "," : "") + this.data.CODZONE + "_" + i + " " + typeStr;
		return s;
	}
	getSql(_: _,  colNames: string[], tableNames: string[], wheres: string[], params: string[], descs: ColumnDesc[], raw?: boolean, sqlOpts?: types.DriverReaderOptions) {
		// tracerJs.debug && tracerJs.debug("column.getSql:" + this.name);
		if (!this.type.sqlType()) return;
		colNames.push(this.sqlNames(this.table.abrev + '.', '', sqlOpts));
		descs && this.sqlDescs(descs);
	}
	sqlName() {
		return this.table.abrev + '.' + this.name + "_0";
	}
	convertIn(val: any) {
		return this.type ? this.type.convertIn(val) : val;
	}
};

export const Constructor = Column;