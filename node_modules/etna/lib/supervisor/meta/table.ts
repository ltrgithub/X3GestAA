import { _ } from 'streamline-runtime';
import * as ez from 'ez-streams';
import * as util from '../util';
import { Record, Connection, SqlQueryOptions, SqlExecuteOptions } from '../../engine/drivers/types';
import * as types from '../../engine/runtime/types';
import * as bcd from '../../engine/runtime/bcd';
import * as tdatetime from '../../engine/runtime/tdatetime';
import * as constants from '../constants';
const glob = require('streamline/lib/globals');
import { Helper } from '../util';
import { Column, ColumnDesc } from './column';
import { Type } from './type';
import { Index } from './index';
import { TableLinks } from './tableLinks';
import { Instance } from '../dyn/instance';
import { Supervisor } from '../supervisor';

import { TableMeta } from '../metadata/table';

const tracerDbms = require('syracuse-core').getTracer("etna.dbms");

export interface TableSql {
	columnNames?: string[];
	columnDescs?: ColumnDesc[];
	insertVars?: string;
	updateSets?: string;
	deleteWheres?: string;
	updateWheres?: string;
	updtickWhere_u?: string;
	updtickWhere_d?: string;
}

export interface TableWhere {
	sql: string;
	params: string[];
}

export interface LobVar {
	name: string;
	type: Type;
}
export class Table extends Helper {
	supervisor: Supervisor;
	data: TableMeta;
	sql: TableSql;
	abrev: string;
	columns: { [name: string]: Column }
	indexes: Index[];
	_links: TableLinks;
	constructor(superv: Supervisor, data: TableMeta) {
		super();
		this.supervisor = superv;
		this.data = data;
		this.sql = {};
		this.abrev = 'T';
	}
	init(_: _) {
		this.columns = {};
		this.data.COLUMNS.filter(data => !/^AX[123X]/.test(data.CODTYP)).forEach_(_, (_, data) => {
			this.columns[data.CODZONE] = this.supervisor.new<Column>(_, 'Column', this, data);
		}, this);

		this.indexes = this.data.INDEXES.map_(_, (_, data) => this.supervisor.new<Index>(_, 'Index', this, data), this);
		return this;
	}
	get name() {
		return this.data.CODFIC;
	}
	get abbrev() {
		return this.data.ABRFIC;
	}
	column(name: string) {
		return this.columns[name];
	}
	index(name: string) {
		return this.indexes.filter(ind => ind.name === name)[0];
	}
	reader<T extends Record>(_: _,  index: Index, vals: any[], where?: TableWhere, raw?: boolean, options?: SqlQueryOptions) {
		const columns = this.columns;

		options = options || [];

		const param = this.supervisor.sqlDriver.param;
		const tableNames = [this.name + ' T'];
		const columnNames: string[] = [];
		const wheres = where && where.sql ? [where.sql] : [];
		const params = where && where.sql ? where.params.slice(0) : [];
		const sqlOpts = {};

		Object.keys(columns).forEach_(_, (_, name) => {
			columns[name].getSql(_, columnNames, tableNames, wheres, params, null, raw, sqlOpts);
		});
		var indexColNames: string[];
		if (index) {
			indexColNames = index.sqlNames();
			var indexCols = indexColNames.slice(0, vals.length);
			indexCols.forEach((name, i) => {
				params.push(vals[i]);
				wheres.push(name + "=" + param(params.length - 1));
			});
		} else if (vals && vals.length > 0) {
			// JS API only
			var cols = Object.keys(vals);
			cols.forEach((name, i) => {
				params.push(util.any(vals)[name]);
				wheres.push(name + "=" + param(params.length - 1));
			});
		}
		var sql = "select ";
		if (options.limit) sql += "top " + options.limit + " ";
		sql += columnNames.join(',') + " from " + tableNames.join(',');
		if (wheres.length) sql += " where (" + wheres.join(') and (') + ')';
		if (index) sql += " order by " + indexColNames;

		return this.supervisor.sqlReader<T>(_, sql, params, sqlOpts);
	}
	deleteIndexes(_: _,  ifExists?: boolean) {
		this.indexes.forEach_(_, (_, index) => {
			try {
				var sql = this.supervisor.sqlDriver.dropIndexSql(this.name + "_" + index.name, this.name);
				this.supervisor.executeSql(_, sql);
			} catch (ex) {
				// do not fail, just report error
				if (ifExists && this.supervisor.sqlDriver.isIndexNotFound(ex)) return;
				//tracerDbms.error && tracerDbms.error(index.name + ": " + ex.message);
				else throw ex;
			}
		}, this);
	}
	createIndexes(_: _) {
		this.indexes.forEach_(_, (_, index) => {
			const sql = "create index " + this.name + "_" + index.name + //
			" on " + this.name + " (" + index.columns.map(col => col.name + '_0') + ")";

			this.supervisor.executeSql(_, sql);
		}, this);
	}
	clear(_: _) {
		this.supervisor.executeSql(_, "delete from " + this.name);
	}
	computeColumnNames(_: _) {
		if (!this.sql.columnNames) {
			var names: string[] = [];
			var descs: ColumnDesc[] = [];
			var primKey = this.indexes[0];
			var param = this.supervisor.sqlDriver.param;

			// Add primKey first (in the correct order)...
			var columns = primKey.columns.map(column => column.name);
			// ... and add other columns
			Object.keys(this.columns).forEach(column => {
				if (!primKey.hasColumn(column)) {
					columns.push(column);
				}
			});
			//console.error("columns:"+columns);

			columns.forEach_(_, (_, name) => {
				const column = this.columns[name];
				column.getSql(_, names, null, null, null, descs, true);
			}, this);

			this.sql.columnNames = names.map(name => {
				return name.replace(/T\./g, ''); // remove leading T.
			});
			this.sql.columnDescs = descs;
			var insertVars: string[] = [],
			    updateSets: string[] = [],
			    updateWheres: string[] = [];

			const lobPlaceholder = this.supervisor.sqlDriver.lobPlaceholder;
			let offset_i = 0;
			let offset_u = 0;
			let offset_d = 0;
			descs.forEach((desc, i) => {
				insertVars.push(lobPlaceholder && desc.type.isLob ? lobPlaceholder(desc.type.sqlType()) : param(offset_i++));
				if (!primKey.hasColumn(desc.name)) {
					updateSets.push(desc.name + "_" + (desc.index || 0) + "=" + (lobPlaceholder && desc.type.isLob ? lobPlaceholder(desc.type.sqlType()) : param(offset_u++)));
				}
			}, this);

			this.sql.insertVars = insertVars.join(',');
			this.sql.updateSets = updateSets.join(',');
			this.sql.deleteWheres = primKey.columns.map(column => "(" + column.name + "_0=" + param(offset_d++) + ")", this).join(' and ');
			this.sql.updateWheres = primKey.columns.map(column => "(" + column.name + "_0=" + param(offset_u++) + ")", this).join(' and ');
			this.sql.updtickWhere_u = "(UPDTICK_0 = " + param(offset_u++) + ')';
			this.sql.updtickWhere_d = "(UPDTICK_0 = " + param(offset_d++) + ')';
		}
	}
	getInstanceKey(_: _,  instance: Instance) {
		return this.indexes[0].columns.map_(_, (_, column) => instance.slot(_, column.name).get(_, true), this).join('~');
	}
	insertRecord(_: _,  record: Record) {
		tracerDbms.debug && tracerDbms.debug("table.insert for " + this.name);
		this.computeColumnNames(_);

		const values = this.sql.columnDescs.reduce_(_, (_, r, desc) => {
			const val = record[desc.name];

			r.push(val !== undefined ? val : desc.type.defaultValue);
			return r;
		}, []);
		const sql = "insert into " + this.name + " (" + this.sql.columnNames.join(',') + //
		") values (" + this.sql.insertVars + ")";

		try {
			return this.supervisor.executeSql(_, sql, values);
		} catch (e) {
			tracerDbms.error && tracerDbms.error("Exception in table.insertRecord:" + e.stack);

			throw new Error(this.supervisor.loadMessParams(_, 140, 65, " n/a ", // " " for unit tests only !
			this.name, this.supervisor.sqlDriver.isUniqueViolated(e) ? this.supervisor.loadMessParams(_, 100, 22) : e.message));
		}
	}
	updateRecord(_: _,  key: any, record: Record) {
		throw new Error("NIY");
	}
	deleteRecord(_: _,  key: any) {
		throw new Error("NIY");
	}
	executeSql(_: _, instance: Instance, sql: string, values: any[], lobVars: LobVar[]) {
		let output: SqlExecuteOptions;
		if(lobVars.length) {
			const param = this.supervisor.sqlDriver.param;
			let offset_vars=values.length;
			output = {outputVars: []};
			sql += " returning "+lobVars.map(v => {
				const name = param(offset_vars++);
				output.outputVars.push({
					name: name.substring(1),
					type: v.type.sqlType()
				});
				return v.name + "_0 into " + name;
			}).join(',');
		}
		var result = this.supervisor.executeSql(_, sql, values, output);
		if (result.updateCount) {
			for(let i=0; i < lobVars.length; i++) {
				let lob = instance.get(_,lobVars[i].name);
				const reader: ez.Reader<any> = lobVars[i].type.sqlType() === "CLOB" 
				? ez.devices.string.reader(lob.value) 
				: ez.devices.buffer.reader(lob.value);
				reader.pipe(_, result.outputVars[i]);
			}
		}

		return result;
	}
	insert(_: _,  instance: Instance) {
		tracerDbms.debug && tracerDbms.debug("table.insert for " + instance.class.name);
		this.computeColumnNames(_);

		const lobVars: LobVar[] = [];
		const values = this.sql.columnDescs.reduce_(_, (_, r, desc) => {
			if (desc.type.isLob) lobVars.push(desc)
			else r.push(instance.getSql(_, desc));
			return r;
		}, []);
		
		const sql = "insert into " + this.name + " (" + this.sql.columnNames.join(',') + //
		") values (" + this.sql.insertVars + ")";

		try {
			return this.executeSql(_, instance, sql, values, lobVars);
		} catch (e) {
			tracerDbms.error && tracerDbms.error("Exception in table.insert:" + e.message);

			throw new Error(this.supervisor.loadMessParams(_, 140, 65, " " + this.getInstanceKey(_, instance), // " " for unit tests only !
			this.name, this.supervisor.sqlDriver.isUniqueViolated(e) ? this.supervisor.loadMessParams(_, 100, 22) : e.message));
		}
	}
	update(_: _,  instance: Instance) {
		tracerDbms.debug && tracerDbms.debug("table.update for " + instance.class.name);
		this.computeColumnNames(_);
		const primKey = this.indexes[0];
		var values: any[] = [];
		const valuesWhere: any[] = [];

		const lobVars: LobVar[] = [];
		this.sql.columnDescs.forEach_(_, (_, desc) => {
			const dest = primKey.hasColumn(desc.name) ? valuesWhere : values;
			if(desc.type.isLob) lobVars.push(desc)
			else dest.push(instance.getSql(_, desc));
		});
		// + updtick
		valuesWhere.push(instance.get(_, "UPDTICK", true));

		values = values.concat(valuesWhere);
		const sql = "update " + this.name + " T set " + this.sql.updateSets + //
		" where " + this.sql.updateWheres + ' and ' + this.sql.updtickWhere_u;

		return this.executeSql(_, instance, sql, values, lobVars);
	}
	delete(_: _,  instance: Instance) {
		this.computeColumnNames(_);
		const values = this.indexes[0].columns.map_(_, (_, column) => instance.slot(_, column.name).getSql(_), this);

		// + updtick

		values.push(instance.get(_, "UPDTICK", true));

		const sql = "delete from " + this.name + " where " + this.sql.deleteWheres + ' and ' + this.sql.updtickWhere_d;

		return this.supervisor.executeSql(_, sql, values);
	}
	loadRecords(_: _,  index: Index, vals: any[], max: number, where: TableWhere, raw?: boolean) {
		if (max == null || max < 0) max = Infinity;
		return this.reader(_, index, vals, where, raw).limit(max).toArray(_);
	}
	convertIn(data: Record) {
		Object.keys(this.columns).forEach(name => {
			const col = this.columns[name];

			data[name] = col.convertIn(data[name]);
		}, this);
	}
	writer(_: _,  cnx: Connection) {
		this.computeColumnNames(_);
		const sql = "insert into " + this.name + " (" + this.sql.columnNames.join(',') + //
		") values (" + this.sql.insertVars + ")";
		const writer = this.supervisor.sqlDriver.writer(_, cnx, sql);
		// TODO: fix writer.pre in ez-streams.d.ts
		const wr = util.any(writer.pre).map((_: _, data: any) => {
			wr.count++;
			return this.sql.columnDescs.map((name, i) => {
				const desc = this.sql.columnDescs[i];
				const v = desc.index == null ? data[desc.name] : data[desc.name][desc.index];

				return v === undefined ? null : desc.type ? desc.type.toSql(v) : v;
			});
		});

		wr.count = 0;
		return wr;
	}
	exists(_: _) {
		return this.supervisor.sqlDriver.tableExists(_, this.name, this.supervisor.folderName);
	}
	drop(_: _,  ifExists?: boolean) {
		try {
			return this.supervisor.executeSql(_, "drop table " + this.name);
		} catch (ex) {
			if (ifExists && this.supervisor.sqlDriver.isTableNotFound(ex)) return;
			else throw ex;
		}
	}
	create(_: _,  exists?: boolean) {
		//trace && trace("creating table " + table.CODFIC);
		if (exists) this.drop(_);
		const sql = "create table " + this.name + " (UPDTICK_0 NUMBER(10) DEFAULT 0," + Object.keys(this.columns).map(name => {
			const col = this.columns[name];

			return col.sqlDef();
		}, this).filter(def => !!def).join(',') + ")";

		this.supervisor.executeSql(_, sql);
	}
	links(_: _) {
		this._links = this._links || this.supervisor.new<TableLinks>(_, 'TableLinks', this.name);
		return this._links;
	}
	description(_: _) {
		return this.supervisor.loadText(_, this.data.INTITFIC);
	}
	getRecordDescription(_: _,  record: Record) {
		// Set a default value *
		var description = "";
		if (this.data.INTIT) {
			description = record[this.data.INTIT] || description;
			if (this.data.INTITTYPE) {
				if (this.data.INTITTYPE === "ATX") {
					description = this.supervisor.loadText(_, this.data.INTIT);
				} else if (/^AX[123X]/.test(this.data.INTITTYPE)) {
					//    Read [AXX_]AXX0  = LS(0).TABLE;LS(0).INTIT;POBJ.ACTX.LAN;RECORDKEYS(1);RECORDKEYS(2)
					//    If !fstat : RECORDDESC = [F:AXX_]TEXTE : Endif
					var actx = glob.context.x3session.actx;
					var columns = this.indexes[0].columns;
					var param = this.supervisor.sqlDriver.param;
					var params: any[] = [];
					var wheres: string[] = [];

					params.push(this.name);
					wheres.push("CODFIC_0=" + param(params.length - 1));
					params.push(this.data.INTIT);
					wheres.push("ZONE_0=" + param(params.length - 1));
					params.push(actx.$LAN(_));
					wheres.push("LANGUE_0=" + param(params.length - 1));
					params.push(record[columns[0].name]);
					wheres.push("IDENT1_0=" + param(params.length - 1));
					params.push(record[columns[1].name]);
					wheres.push("IDENT2_0=" + param(params.length - 1));
					var sql = "select TEXTE_0 from ATEXTRA  where (" + wheres.join(" and ") + ")";

					const rs = this.supervisor.sqlReader<{
						TEXTE: string;
					}>(_, sql, params).toArray(_);
					description = rs && rs.length ? rs[0].TEXTE : "";
				}
			}
		}
		return description;
	}
}

export const collectionName = 'ATABLE';
export const keyName = 'CODFIC';
export const Constructor = Table;
