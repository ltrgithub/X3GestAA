"use strict";

import { _ } from 'streamline-runtime';
import * as util from '../util';
import * as utilDriver from '../../engine/drivers/util';
import * as types from '../../engine/runtime/types';
const date = require('syracuse-core').types.date;
import * as bcd from '../../engine/runtime/bcd';
import * as uuid from '../../engine/runtime/uuid';
import * as tuuid from '../../engine/runtime/tuuid';
import * as tdate from '../../engine/runtime/tdate';
import * as tdatetime from '../../engine/runtime/tdatetime';
const datetime = require('syracuse-core').types.datetime;
import * as variables from '../../engine/runtime/variables';
import * as runtime from '../../engine/runtime/runtime';
import * as format from '../../engine/runtime/format';
import * as activ from './activ';
import * as constants from '../constants';
import { ColumnData } from './column';
import { Property, PropertyData } from './property';
import { TypePro } from './typepro';
import { Slot } from '../slot';
import { Supervisor } from '../supervisor';
const tracerJs = require('syracuse-core').getTracer("etna.supervisor");
const tracerDbms = require('syracuse-core').getTracer("etna.dbms");
export const typTyp2EtnaType: { [id: number]: string } = {
	1: "J",
	2: "I",
	3: "I",
	4: "N",
	6: "W",
	7: "S",
	8: "D",
	9: "B",
	10: "T",
	11: "Z",
	12: "E",
	13: "Y"
};

export const etnaType2TypTyp = Object.keys(typTyp2EtnaType).reduce((r, k) => (r[typTyp2EtnaType[util.any(k)]] = k, r), util.any({}));
const mapTypeRule: { [id: number]: string } = {
	1: "INIT",
	2: "CONTROL",
	3: "PROPAGATE",
	4: "GET",
	5: "FORMAT",
	6: "READ_MEDIA",
	7: "UPDATE_MEDIA",
	8: "DELETE_MEDIA",
	9: "INSERT_MEDIA",
	10: "READ_MEDIA_CNT",
	11: "EXIST_MEDIA"
};

export type TypeRule = (_: _,  slot: Slot) => number;
export type MediaRule = (_: _,  slot: Slot, value: any) => number;
export type MediaLazyRule = (_: _,  property: Property, value: any) => number;

export interface TypeRuleDesc {
	script: types.Prog;
	scriptName: string;
	prog: string;

}
export interface TypeRules {
	INIT: TypeRuleDesc;
	CONTROL: TypeRuleDesc;
	PROPAGATE: TypeRuleDesc;
	GET: TypeRuleDesc;
	FORMAT: TypeRuleDesc;
	READ_MEDIA: TypeRuleDesc;
	READ_MEDIA_CNT: TypeRuleDesc;
	INSERT_MEDIA: TypeRuleDesc;
	UPDATE_MEDIA: TypeRuleDesc;
	DELETE_MEDIA: TypeRuleDesc;
	[name: string]: TypeRuleDesc;
}

export interface TypeRulesParameterData {
	PARCOD: string;
	PARMOD: number;
	PARTYP: number;
}
export interface TypeRulesData {
	TYPRUL: number;
	TRTRUL: string;
	ENARUL: number;
	ACTRUL: string;
	PRGRUL: string;
	PARAMETERS: TypeRulesParameterData[];
}

export interface TypeData {
	TYPTYP: number;
	LNGTYP: number;
	TYPPROSYR: string;
	FMTPROSYR: number;
	LONG: number;
	RULES: TypeRulesData[];
	CODCLA: string;
	FORTYP: string;
	OPTION: string;
	NOLIB: number;
}

export interface ATypePro {
	protyp: string;
	preflg: number;
	lisflg: number;
}

export class Type {
	supervisor: Supervisor;
	data: TypeData;
	INIT: TypeRule;
	CONTROL: TypeRule;
	PROPAGATE: TypeRule;
	GET: TypeRule;
	FORMAT: TypeRule;
	readMedia: MediaRule;
	insertMedia: MediaRule;
	updateMedia: MediaRule;
	deleteMedia: MediaRule;
	readMediaLazy: MediaLazyRule;
	readMediaCnt: MediaRule;
	rules: TypeRules;
	protyp: TypePro;
	$x3Format: string;
	atypepro: ATypePro; 

	constructor(superv: Supervisor, data: TypeData) {
		this.supervisor = superv;
		if (data.LNGTYP && typeof data.LNGTYP === 'string') {
			if (!isNaN(data.LNGTYP) && bcd.toDouble(bcd.fromString(util.any(data.LNGTYP))) > 0) {
				data.LNGTYP = bcd.toDouble(bcd.fromString(util.any(data.LNGTYP)));
			}
			else delete data.LNGTYP;
		}
		this.data = data;
		this.INIT = null;
		this.CONTROL = null;
		this.PROPAGATE = null;
		this.GET = null;

		this.readMedia = null;
		this.insertMedia = null;
		this.updateMedia = null;
		this.deleteMedia = null;
	}

	init(_: _) {
		const makeTypeRule = (type: Type, name: string) => {
			const rule = type.rules[name];

			return function (_: _,  slot: Slot) {
				const instance = slot.$parent;
				const value = slot.get(_, true);
				const maps = slot.property.typeRulesMaps(_);
				///dbg:console.log("execute rule "+name+" on "+slot.name+" maps:",maps);

				const args = Object.keys(maps).reduce_(_, (_, r, p) => {
					r[p] = {
						type: maps[p].type,
						value: maps[p].value(_, instance)
					};
					return r;
				}, util.any({
					AINSTANCE: {
						type: "LY",
						value: instance
					},
					APRONAME: {
						type: "BS",
						value: slot.property.name
					},
					AVALUE: {
						type: "A" + type.etnaType,
						value: value !== undefined ? value : type.defaultValue
					}
				}));
				// Let's add the AFORMAT parameter if necessary

				if (name === "FORMAT") args.AFORMAT = { type: "AS", value: "" };

				const status = type.applyRule(_, rule, args);
				//dbg:console.log("execute rule "+name+" =>");//,args);

				if (status != constants.CST_AERROR) {
					//dbg:console.log("execute rule "+name+" set "+args.AVALUE.value);
					slot.set(_, args.AVALUE.value, true);
					//dbg:console.log("execute rule "+name+" check set "+slot.get(_,true));
					if (name === "FORMAT") {
						this.$x3Format = args.AFORMAT.value;
						this.regex = format.fromX3FormatToRegex(this.$x3Format);
					}
				}
				return status;
			};
		};

		const makeMediaRule = (rule: TypeRuleDesc) => {
			return function (_: _,  slot: Slot, value: any) {
				const args = this.mediaArgs(_, slot);

				args.AVALUE = {
					type: "AT",
					value: value || ""
				};
				const status = this.applyRule(_, rule, args);

				return value !== undefined ? status : args.AVALUE.value; // Value = undefined for the read
			};
		};

		const makeMediaLazyRule = (rule: TypeRuleDesc) => {
			return function (_: _,  property: Property, keys: any[]) {
				// console.log("lazyRule:",keys);
				let maps = property.typeRulesMaps(_);
				let i = 0;
				const args = Object.keys(maps).reduce_(_, (_, r, p) => {
					r[p] = {
						type: maps[p].type,
						value: keys[i++]
					};
					return r;
				}, util.any({
					AINSTANCE: {
						type: "LY",
						value: null
					},
					APRONAME: {
						type: "BS",
						value: property.name
					},
					AVALUE: {
						type: "A" + this.etnaType,
						value: this.defaultValue
					}
				}));
				const status = this.applyRule(_, rule, args);
				// console.log("makeMediaLazyRule =>",args)

				return status === constants.CST_AOK ? args.AVALUE.value : "";
			};
		};

		this.protyp = this.data.TYPPROSYR ? this.supervisor.load(_, 'Typepro', this.data.TYPPROSYR) : undefined;
		if (this.data.RULES) {
			this.rules = this.data.RULES.filter_(_, (_, rule) => !/^WMTYP/.test(rule.TRTRUL) && rule.ENARUL === 2 && activ.getActiv(_, this.supervisor, rule.ACTRUL) > 0).reduce_(_, (_, r, rule) => {
				r[mapTypeRule[rule.TYPRUL]] = {
					scriptName: rule.TRTRUL,
					prog: rule.PRGRUL,
					params: rule.PARAMETERS ? rule.PARAMETERS.reduce_(_, (_, r, param) => {
						r[param.PARCOD] = {
							type: (param.PARMOD === 1 ? "A" : "L") + typTyp2EtnaType[param.PARTYP]
						};
						return r;
					}, util.any({})) : {}
				};
				return r;
			}, util.any({}));
			// console.log("type "+this.data.CODTYP+" rules:",this.rules);	

			if (this.rules.INIT) this.INIT = makeTypeRule(this, "INIT");
			if (this.rules.CONTROL) this.CONTROL = makeTypeRule(this, "CONTROL");
			if (this.rules.PROPAGATE) this.PROPAGATE = makeTypeRule(this, "PROPAGATE");
			if (this.rules.FORMAT) this.FORMAT = makeTypeRule(this, "FORMAT");
			if (this.rules.GET) this.GET = makeTypeRule(this, "GET");
			if (this.rules.READ_MEDIA) {
				this.readMedia = makeMediaRule(this.rules.READ_MEDIA);
				this.readMediaLazy = makeMediaLazyRule(this.rules.READ_MEDIA);
			}
			if (this.rules.READ_MEDIA_CNT) {
				this.readMediaCnt = makeMediaRule(this.rules.READ_MEDIA_CNT);
			}
			if (this.rules.INSERT_MEDIA) this.insertMedia = makeMediaRule(this.rules.INSERT_MEDIA);
			if (this.rules.UPDATE_MEDIA) this.updateMedia = makeMediaRule(this.rules.UPDATE_MEDIA);
			if (this.rules.DELETE_MEDIA) this.deleteMedia = makeMediaRule(this.rules.DELETE_MEDIA);
		}
		return this;
	}
	get defaultValue() {
		return variables.types[this.etnaType].default;
	}

	get maxLength() {
		return this.data.LNGTYP;
	}

	get etnaType() {
		if (typTyp2EtnaType[this.data.TYPTYP]) {
			return typTyp2EtnaType[this.data.TYPTYP];
		}
		throw new Error("NIY type: " + this.data.TYPTYP);
	}

	get isClob() {
		return false;
	}

	get isBlob() {
		return false;
	}

	get isLob() {
		return this.isBlob || this.isClob;
	}

	get jsType(): string {
		throw new Error("NIY type: " + this.data.TYPTYP);
	}

	targetClass(_: _) {
		if (this.data.CODCLA) return this.supervisor.load(_, 'Class', this.data.CODCLA);
	}

	/*
 the $x3Format attribute is only set for strings. In orther cases it should be undefined
 */
	getX3Format(_: _,  property: Property): string {
		return this.$x3Format = undefined;
	}

	sqlType(colData?: ColumnData): string {
		throw new Error("unsupported datatype: " + this.data.TYPTYP + " (" + typeof this.data.TYPTYP + ")");
	}

	convertIn(val: any) {
		return val;
	}

	toSql(val: any) {
		return val.x3ToSql(this.supervisor.sqlDriver);
	}

	fromSql(_: _,  val: any) {
		return utilDriver.fromSql(_, val, this.data.TYPTYP, this.supervisor.sqlDriver);
	}

	toSqlQuery(val: any) {
		return val;
	}

	applyRule(_: _,  rule: TypeRuleDesc, args: types.ProgArg[]) {
		rule.script = rule.script || this.supervisor.loadScript(_, rule.scriptName);
		return runtime.executeProg(_, rule.script, rule.prog, args);
	}

	toJson(_: _,  slot: Slot, val: any) {
		return val;
	}

	precisionAndScale(long: number) {
		if (this.data.TYPTYP !== 4) return null;
		const l = long || (this.data.LNGTYP > 0 ? this.data.LNGTYP : undefined);
		if (l == null) return null;
		const parts = ('' + l).split('.');
		const int = parseInt(parts[0]);
		// scale is limited to 1 digit.

		const scale = parts[1] ? Math.round(10 * parseFloat('0.' + parts[1])) : 0;

		return {
			precision: int + scale,
			scale: scale
		};
	}

	fillNode(_: _,  data: PropertyData, node: types.NodeProto) {
		if (this.atypepro === undefined) {
			var typpro: TypePro = this.supervisor.load(_, 'Typepro', this.data.TYPPROSYR);
			if (!typpro) throw new Error("content type not found: " + this.data.TYPPROSYR);
			this.atypepro = {
				protyp: typpro.data.PROTYP,
				preflg: typpro.data.PREFLG,
				lisflg: typpro.data.LISFLG
			};
		}
		node.$type = this.atypepro.protyp;

		if (this.data.FMTPROSYR > 1) {
			var fmt: string;
			switch (this.data.FMTPROSYR) {
				case 2:
					fmt = "$email";
					break;
				case 3:
					fmt = "$phone";
					break;
				case 6:
					fmt = "TT"; // Time format hh:mm:ss
					break;
				default:
					fmt = this.supervisor.loadMess(_, 7880, this.data.FMTPROSYR);
					break;
			}
			if (fmt !== "") node.$format = fmt;
		}
		switch (this.data.TYPTYP) {
			case 2:
			case 3:
			case 4:
				var lon = data.LONG > 0 ? data.LONG : this.data.LNGTYP > 0 ? this.data.LNGTYP : undefined;
				if (lon !== undefined) node.$maxLength = Math.floor(lon);

				if (this.data.TYPTYP === 4 && lon >= 0) {
					node.$precision = parseInt('' + lon);
					var l = ("" + Math.round(lon * 1e6) / 1e6).split('.');
					node.$scale = parseInt('' + (l[1] || 0));
					if (node.$scale === 0) node.$format = "0";
					else {
						var zero = "0000000000000000000000000000000000000000000";
						node.$format = "0." + zero.substring(0, node.$scale);
					}
				}
				break;
			case 7:
				var lon = this.data.LNGTYP > 0 ? this.data.LNGTYP : data.LONG > 0 ? data.LONG : undefined;
				if (lon !== undefined) node.$maxLength = Math.floor(lon);
				break;
		}
	}
}

//TYPTYP = 1
class TypeJ extends Type {
	constructor(superv: Supervisor, data: TypeData) {
		super(superv, data);
	}
	get jsType() {
		return "number";
	}

	sqlType(colData?: ColumnData) {
		return this.supervisor.sqlDriver.tinyIntType();
	}
	toJson(_: _,  slot: Slot, val: any) {
		return slot.property.data.NOLIB !== 1 ? val : val === 2 ? true : false;
	}
}

//TYPTYP = 2
class TypeI2 extends Type {
	constructor(superv: Supervisor, data: TypeData) {
		super(superv, data);
	}
	get jsType() {
		return "number";
	}
	sqlType(colData?: ColumnData) {
		return this.supervisor.sqlDriver.shortIntType();
	}
}

//TYPTYP = 3 (translatable text (no column))
class TypeI3 extends Type {
	constructor(superv: Supervisor, data: TypeData) {
		super(superv, data);
	}
	get jsType() {
		return "number";
	}
	sqlType(colData?: ColumnData) {
		return this.supervisor.sqlDriver.intType();
	}
}

//TYPTYP = 4
class TypeN extends Type {
	constructor(superv: Supervisor, data: TypeData) {
		super(superv, data);
	}
	get jsType() {
		return "string";
	}
	sqlType(colData?: ColumnData) {
		return this.supervisor.sqlDriver.decimalType();
	}
	toJson(_: _,  slot: Slot, val: any) {
		return val ? val.x3ToString() : 0;
	}
}

//TYPTYP = 6
class TypeW extends Type {
	constructor(superv: Supervisor, data: TypeData) {
		super(superv, data);
	}
	get jsType() {
		return "number";
	}
	sqlType(colData?: ColumnData) {
		return this.supervisor.sqlDriver.doubleType();
	}
}

//TYPTYP = 7
class TypeS extends Type {
	regex: RegExp;
	constructor(superv: Supervisor, data: TypeData) {
		super(superv, data);
	}
	get jsType() {
		return "string";
	}
	sqlType(colData?: ColumnData) {
		return this.supervisor.sqlDriver.stringType(this.data.LNGTYP || colData && colData.LONG || 1020);
	}
	toSqlQuery(val: any) {
		return "'" + ('' + val).replace(/'/g, "''") + "'";
	}

	/*
 Let's set the $x3Format attribute for strings
 */
	getX3Format(_: _,  property: Property) {
		this.$x3Format = super.getX3Format(_, property);
		if (this.$x3Format !== undefined) return this.$x3Format;

		if (this.data.FORTYP || this.data.OPTION || this.data.LNGTYP) {
			// type string : initialize $x3Format
			var x3Format = "K";
			var chfmt = this.data.FORTYP || "";
			var optsai = this.data.OPTION || "";
			var carfmt = "";
			var optfmt = "";

			var propertyLength = property.propertyLength || this.data.LNGTYP;

			if (/^=|\[+|>/.test(chfmt)) chfmt = "";

			if (/C+/.test(optsai)) carfmt = "c";
			else if (/A+/.test(optsai)) carfmt = /\#+/.test(optsai) ? "B" : "A";

			else if (/\#+/.test(optsai)) carfmt = "#";

			else carfmt = "X";

			if (/T+/.test(optsai)) optfmt += "T";
			else if (/D+/.test(optsai)) optfmt += "TD";

			if (/\*+/.test(optsai)) optfmt += "*+";
			if (/1+/.test(optsai)) optfmt += "1";
			if (/z+/.test(optsai)) optfmt += "z";

			if (/=+/.test(optsai)) optfmt += "=";
			else if (/<+/.test(optsai)) optfmt += "<";

			else if (/>+/.test(optsai)) optfmt += ">";

			if (/W+/.test(optsai)) optfmt += "W";

			if (chfmt.length && !/^=/.test(chfmt)) {
				if (optsai == "" && /X+/.test(chfmt)) x3Format = undefined;
			} else chfmt = propertyLength.toString() + carfmt;
			if (/T+/.test(optfmt) && !/TD+/.test(optfmt)) x3Format = undefined;

			this.$x3Format = x3Format ? x3Format + optfmt + ":" + chfmt : "";
			this.regex = format.fromX3FormatToRegex(this.$x3Format);
		}
		return this.$x3Format;
	}
}
//TYPTYP = 8
class TypeD extends Type {
	constructor(superv: Supervisor, data: TypeData) {
		super(superv, data);
	}
	get jsType() {
		return "date";
	}

	sqlType(colData?: ColumnData) {
		return this.supervisor.sqlDriver.dateType();
	}
	convertIn(val: any) {
		return val ? date.fromJsDate(new Date(val)) : null;
	}
	toSqlQuery(val: any) {
		this.supervisor.sqlDriver.sqlDate(val);
	}
	toJson(_: _,  slot: Slot, val: any) {
		return val ? val.x3ToJson() : null;
	}
}

interface TypeValue {
	type: string;
	value: any;
}

interface MediaArgs {
	AINSTANCE: TypeValue;
	APRONAME: TypeValue;
	CLE: TypeValue;
	AVALUE?: TypeValue;
	AVALCNT?: TypeValue;
}

class TypeLob extends Type {
	constructor(superv: Supervisor, data: TypeData) {
		super(superv, data);
	}

	mediaArgs(_: _,  slot: Slot): MediaArgs {
		const instance = slot.$parent;

		var key = instance.getKey(_);
		key = key && Array.isArray(key) ? key.join('~') : key;
		return {
			AINSTANCE: {
				type: "LY",
				value: instance
			},
			APRONAME: {
				type: "LY",
				value: slot.name
			},
			CLE: {
				type: "LS",
				value: key
			}
		};
	}
	contentType(_: _,  slot: Slot) {
		var contentType = this.protyp ? this.protyp.data.PROTYP : "text/plain";
		if (slot !== undefined && this.rules && this.rules.READ_MEDIA_CNT) {
			var rule = this.rules.READ_MEDIA_CNT;
			var args = this.mediaArgs(_, slot);
			args.AVALCNT = {
				type: "AS",
				value: ""
			};
			var astatus = this.applyRule(_, rule, args);
			contentType = args.AVALCNT.value;
		}
		return contentType || "";
	}
}

//TYPTYP = 9
class TypeB extends TypeLob {
	constructor(superv: Supervisor, data: TypeData) {
		super(superv, data);
	}
	get isBlob() {
		return true;
	}
	sqlType(colData?: ColumnData) {
		return this.supervisor.sqlDriver.blobType();
	}
	toJson(_: _,  slot: Slot, val: any) {
		return {};
	}
	get lobTable() {
		return "ABLOB";
	}
	get lobField() {
		return "BLOB";
	}
	reader(_: _,  val: any) {
		return this.supervisor.sqlDriver.blobReader(_, val);
	}
}

//TYPTYP = 10
class TypeT extends TypeLob {
	constructor(superv: Supervisor, data: TypeData) {
		super(superv, data);
	}
	get isClob() {
		return true;
	}
	get jsType() {
		return "object";
	}
	sqlType(colData?: ColumnData) {
		return this.supervisor.sqlDriver.clobType();
	}
	toJson(_: _,  slot: Slot, val: any) {
		return { $contentType: this.contentType(_, slot) };
	}
	get lobTable() {
		return "ACLOB";
	}
	get lobField() {
		return "CLOB";
	}
	reader(_: _,  val: any) {
		return this.supervisor.sqlDriver.clobReader(_, val);
	}
}

//TYPTYP = 11
class TypeZ extends Type {
	constructor(superv: Supervisor, data: TypeData) {
		super(superv, data);
	}
	get jsType() {
		return "binary";
	}
	sqlType(colData?: ColumnData) {
		return this.supervisor.sqlDriver.uuidType();
	}
	toJson(_: _,  slot: Slot, val: any) {
		return val.x3ToString();
	}
}

//TYPTYP = 12
class TypeE extends Type {
	constructor(superv: Supervisor, data: TypeData) {
		super(superv, data);
	}
	get jsType() {
		return "date";
	}
	sqlType(colData?: ColumnData) {
		return this.supervisor.sqlDriver.datetimeType();
	}
	convertIn(val: any) {
		return val ? datetime.fromJsDate(new Date(val)) : null;
	}
	toJson(_: _,  slot: Slot, val: any) {
		return val.x3ToString();
	}
}

//TYPTYP = 13
class TypeY extends Type {
	constructor(superv: Supervisor, data: TypeData) {
		super(superv, data);
	}
}

export const collectionName = 'ATYPE';
export const keyName = 'CODTYP';
export function	getConstructor(data: TypeData) {
	switch (data.TYPTYP) {
		case 1:
			return TypeJ;
		case 2:
			return TypeI2;
		case 3:
			return TypeI3;
		case 4:
			return TypeN;
		case 6:
			return TypeW;
		case 7:
			return TypeS;
		case 8:
			return TypeD;
		case 9:
			return TypeB;
		case 10:
			return TypeT;
		case 11:
			return TypeZ;
		case 12:
			return TypeE;
		case 13:
			return TypeY;
	}
	return Type;
}
export const Constructor = Type;

export function	fillTypeNode(_: _,  superv: Supervisor, data: ColumnData, node: types.NodeProto) {
	const typ = superv.load(_, 'Type', data.CODTYP);

	if (!typ) throw new Error("type not found: " + data.CODTYP);
	if (data.NOLIB === 1) {
		node.$type = 'application/x-boolean';
	}
	//Elsif len(ASHW.ASWR(I).UOMPRO)
	// #It's a unit
	//  PROTYPE =func ASYRJSO.TYP('quantity')
	else if (data.CODTYP === 'ATX') {
			node.$type = 'application/x-string';
			node.$maxLength = 30;
		} else {
			typ.fillNode(_, data, node);
		}
	if (data.NOLIB >= 2) {
		node.$value = {
			$type: 'application/x-integer',
			$enum: superv.loadEnum(_, data.NOLIB).filter(entry => {
				return entry.$title !== '#'; // remove bogus entries in module list
			})
		};
	}
}