"use strict";

var util = require("etna/lib/supervisor/util");
var Helper = util.Helper;
var constants = require("etna/lib/supervisor/constants");

var tracerJs = require('syracuse-core').getTracer("etna.supervisor");

var ETag = 0;
class WorkingCopy extends Helper {
	constructor(superv, res, trackingId) {
		super();
		this.supervisor = superv;
		this.trackingId = (typeof(trackingId) === 'string') ? trackingId:trackingId.x3ToString();
		this.snapshot = res;
		this.save = res.key ? "update" : "insert";
		//this.current = res.clone(); is it necessary ? it's error prone (snapshots...)
		this.current = res;
		this.representation = res.resourceFactory.representation.name;
		this.url = "{$baseUrl}/$workingCopies('" + this.trackingId + "')" + //
		"?representation=" + this.representation + '.$edit';
		this.etag = 0;
		this.ETag = (++ETag);
		var clas = res.resourceFactory.representation.class.name;
		this.actions = {
			$save: {
				$isHidden: false,
				$isDisabled: false,
				$links: {
					$redirect: {
						$url: "{$baseUrl}/" + clas + "('{$key}')?representation=" + this.representation + ".$details",
						$isHidden: false
					}
				}
			}
		};

	}
	init(_) {
		return this;
	}
	delta(_) {
		return {};
	}
	addAttributes(node) {
		node.$trackingId = this.trackingId;
		node.$baseUrl = this.supervisor.baseUrl;
		node.$prototype = "{$baseUrl}/$prototype('{$representation}.$thumb')";
		node.$representation = this.$representation;
		node.$url = this.url;
		node.$type = "application/json;vnd.sage=syracuse";
		node.$etag = this.etag;
		node.ETag = this.ETag;
		node.$actions = this.actions;
		return node;
	}
	dataNode(_) {
		var node = this.previous ? this.delta(_) : this.current.dataNode(_);
		return this.addAttributes(node);
	}
	update(_, context, delta, path) {
		tracerJs.debug && tracerJs.debug("updating working copy:", delta, path);
		this.actions.$save.$isDisabled = false;
		this.etag += 1;


		//dbg:console.error("DELTA:\n",delta);
		var debug = function(_, message, self) {
			console.error(message + ":" + self.current.instance.get(_, "COL").lines.length);
		};

		this.current.enableSyssnapshot();

		//dbg:debug(_,"before delta",this);
		if (path !== undefined) {
			this.current.walkToProperty(_, path, function(_, instance, property) {
				var slot = instance.set(_, property, delta);
				if (slot.isLob) {
					// Set attributes :
					slot.$isLoaded = true;
					slot.$contentType = context.getHeaderField("content-type");
					slot.$filename = context.getHeaderField("x-file-name");
				}
			});
		} else
			this.current.applyDelta(_, delta);

		//dbg:debug(_,"after delta",this);

		var diagnoses;
		tracerJs.debug && tracerJs.debug("delta.$actions:" + JSON.stringify(delta.$actions));
		if (delta && delta.$actions && delta.$actions.$save && delta.$actions.$save.$isRequested === true) {
			tracerJs.debug && tracerJs.debug("resource." + this.save);
			var status = this.current[this.save](_);
			if (status !== constants.CST_AERROR) {
				// The resource was successfully saved in the database
				diagnoses = [{
					$severity: "success",
					$message: this.supervisor.loadMess(_, 124, 192)
				}];
				this.actions.$save.$isDisabled = true;
				this.actions.$save.$isRequested = false;
				this.save = "update";
			}
		}
		var node = this.current.dataNode(_, false);

		this.current.disableSyssnapshot();

		//Add diagnoses
		if (diagnoses) node.$diagnoses = node.$diagnoses ? node.$diagnoses.concat(diagnoses) : diagnoses;
		return this.addAttributes(node);
	}
	read(_, context, path) {
		tracerJs.debug && tracerJs.debug("reading working copy:", path);
		this.current.walkToProperty(_, path, function(_, instance, property) {
			var slot = instance.slot(_, property);
			var data = slot._get(_, true);
			if (data !== undefined) {
				if (slot.isClob) {
					data = data.x3ToString();
				} else if (slot.isBlob && data) {
					data = data.valueOf(); // Get the actual value of data
				}
				var headers = {
					"content-length": data.length
				};
				//SAM 109102 :
				if (slot.$filename && slot.isClob)
					headers["content-disposition"] = "attachement;filename=" + slot.$filename;
				if (slot.$contentType)
					headers["content-type"] = slot.$contentType;
				context.response.writeHead(200, headers);
				context.response.end(data);
			}
		});
	}
	initLocalizeData(context) {
		return {
			$type: "application/x-localization",
			$url: this.url,
			$links: {
				$save: {
					$url: context.request.url,
					$method: "PUT",
					$title: "Enregistrer"
				}
			},
			$values: []
		};
	}
	readLocalization(_, context, path) {
		tracerJs.debug && tracerJs.debug("reading working copy localization:", path);
		var data = this.initLocalizeData(context);
		var self = this;
		this.current.walkToProperty(_, path, function(_, instance, property) {
			var languages = self.supervisor.languages(_);
			Object.keys(languages).forEach_(_, function(_, lan) {
				data.$values.push({
					$code: lan,
					$title: languages[lan].get(_, "INTDES"),
					$locale: languages[lan].get(_, "LANISO"),
					$value: instance.AGETTEXTRALAN(_, property, lan)
				});
			});
			context.jsonReply(_, 200, data);
		});
	}
	updateLocalization(_, context, delta, path) {
		if (typeof delta === 'string') delta = JSON.parse(delta); // ????
		var data = this.initLocalizeData(context);

		var self = this;
		if (delta.$values) {
			this.current.walkToProperty(_, path, function(_, instance, property) {
				delta.$values.forEach_(_, function(_, locale) {
					instance.ASETTEXTRALAN(_, property, locale.$value, locale.$code);
					data.$values.push({
						$code: locale.$code,
						$title: locale.$title,
						$locale: locale.$locale,
						$value: locale.$value
					});
				});
				context.jsonReply(_, 200, data);
			});
		}
	}
};
exports.constructor = WorkingCopy;