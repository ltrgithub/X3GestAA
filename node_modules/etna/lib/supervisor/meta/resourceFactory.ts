import { _ } from 'streamline-runtime';
import * as types from '../../engine/runtime/types';
import * as util from '../util';
const Helper = util.Helper;
const glob = require('streamline/lib/globals');
import * as Jmql from '../../engine/jmqlgen';
const filterHelpers = require("syracuse-sdata-parser/lib/json-converter");
import * as constants from '../constants';
import { Cache } from '../cache';
import { Class, Select } from './class';
import { Property } from './property';
import { Instance } from './instance';
import { Diagnosis } from './diagnosis';
import { Link } from './link';
import { Representation } from './representation';
import { Resource } from './resource';
import * as activ from '../meta/activ'; // GH 6167
import * as http from '../http';
import { Supervisor } from '../supervisor';

import * as ez from 'ez-streams';
const tracerJs = require('syracuse-core').getTracer("etna.supervisor");

function bulkWriter(httpContext: http.HttpContext) {
	var sep: string;
	return ez.devices.generic.writer((_: _, resource: Resource) => {
		if (!sep) {
			httpContext.response.writeHead(200, {
				"content-type": "application/json"
			});
			httpContext.response.write(_, '{"$resources":[');
		}
		if (resource === undefined) {
			httpContext.response.end("]}");
		} else {
			httpContext.response.write(_, (sep || '') + JSON.stringify(resource.dataNode(_)), "utf8");
		}
		sep = ',';
		return this;
	});
};

export interface Page {
	facet: string,
	links: { [name: string]: Link };
	representation: Representation;
	class: Class;
}

export interface KeyItem {
	alias?: string;
	prop?: string;
}

export class ResourceFactory extends Helper {
	supervisor: Supervisor;
	representation: Representation;
	facet: string;
	path: string;
	class: Class;
	properties: { [name: string]: Property }
	links: { [name: string]: Link }
	page: Page;
	ETag: string;
	keyItems: KeyItem[];
	$uuid: (_: _, instance: Instance) => Buffer;
	$attributes: (node: any, property: string, attributes: any) => void;
	$diagnoses: (node: any, property: string, diagnoses: Diagnosis[]) => void;
	cache: Cache;
	_tag2PropertyName: { [tag: string]: string; };
	// $access is always null but we need it here
	$access: (_: _, instance: Instance) => string;


	constructor(superv: Supervisor, clas: Class, repr?: Representation, facet?: string, path?: string) {
		super();
		this.supervisor = superv;
		this.representation = repr;
		this.facet = facet;
		this.path = path;
		this.class = clas;
		this.properties = {}; // exposed properties only
		this.links = {};
		this.page = {
			facet: facet,
			links: {},
			representation: repr,
			class: clas
		};
	}
	init(_: _) {
		return this;
	}
	fillTypeNode(_: _, node: types.NodeProto) {
		node.$type = "application/x-array"; //this.collection.data.MAXCOL > 1 ? "application/x-array" : "application/x-object";
		node.$item = this.itemProto(_, {});
	}
	itemProto(_: _, proto: types.NodeProto, facet?: string) {
		const key = this.keyExpression();

		if (facet) {
			var repDotFacet = this.representation.name + "." + facet;
			proto.$url = "{$baseUrl}/" + this.representation.class.name + "('{$key}')?representation=" + repDotFacet;
			if (facet === "$queryItem") proto.$type = "application/json;vnd.sage=syracuse";
			else proto.$type = "{$baseType}." + repDotFacet;
			proto.$key = key;
			proto.$value = key;
			if (!proto.$title) {
				if (this.representation.class.table) {
					var title = this.representation.class.table.data.INTIT;
					proto.$description = proto.$title = title ? "{" + this.representation.class.table.data.INTIT + "}" : "";
				} else {
					proto.$description = proto.$title = "";
				}
			}
		} else {
			proto.$type = "application/json";
			proto.$value = key;
		}

		var hasToBeSorted = false;
		proto.$properties = {};
		Object.keys(this.properties).filter(name => !this.properties[name].isExtraRef).forEach_(_, (_, name) => {
			const prop = this.properties[name];
			const prototypeNode = prop.prototypeNode(_);

			if (prop.isInstance) {
				// Collection 1-1 Merge properties
				let properties = prototypeNode.$item.$properties;
				proto.$properties = Object.keys(properties).reduce((r, p) => {
					proto.$properties[p] = properties[p];
					return r;
				}, proto.$properties);
				hasToBeSorted = true;
			} else if (prop.isArray) {
				// Collection of property with only one property : Merge property with item
				var childProp: string;
				var childDest: string;
				let properties = Object.keys(prototypeNode.$item.$properties).map(name => {
					if (!childProp) childProp = name;
					return prototypeNode.$item.$properties[name];
				});
				//delete prototypeNode.$item;
				if (properties.length) {
					properties[properties.length - 1].$title = undefined;
					properties[properties.length - 1].$shortTitle = undefined;
				}
				if (childProp && properties[properties.length - 1].$item) {
					//Example :
					//                  "$value": "{POSCOD}",
					//                  "POSCOD": "{POSCOD2}",
					//                  "$url": "{$baseUrl}/POSCOD('{CRY}~{POSCOD2}~{POSCTY}~{POSCTYCOD}')?representation=POSCOD.$details"
					//delete key POSCOD2 and replace POSCOD2 by POSCOD in all URL
					Object.keys(properties[properties.length - 1].$item).filter(name => !/^\$(key|value|links|properties|url)$/.test(name)).forEach(name => {
						if (properties[properties.length - 1].$item[name] === "{" + childProp + "}") {
							if (!childDest) childDest = name;
							delete properties[properties.length - 1].$item[name];
						}
					});
					if (childDest && properties[properties.length - 1].$item.$links) {
						Object.keys(properties[properties.length - 1].$item.$links).forEach(name => {
							var url = properties[properties.length - 1].$item.$links[name].$url;
							if (url) {
								url = url.replace(new RegExp("{" + childProp + "}", 'g'), "{" + childDest + "}");
								properties[properties.length - 1].$item.$links[name].$url = url;
							}
						});
					}
				}
				prototypeNode.$item = properties[properties.length - 1];
				proto.$properties[prop.tag || name] = prototypeNode;
			} else {
				var p = proto.$properties[prop.tag || name] = prototypeNode;
				if (p && prop._isReference) {
					//  || prop.type.data.OBJLIEN
					//if (p && prop.type && prop.type.data.CODCLA && (prop.type.data.TYPSELSYR === 2)) {
					// don't treat primary key of master factory as a reference.
					proto.$properties[prop.ref(prop.tag || name)] = prop.prototypeRefNode(_, p);
				}
			}
		}, this);
		if (hasToBeSorted) {
			//Happens after merging prototypeNodes TYPLNK=3
			proto.$properties = this.representation.exportedProperties.reduce((r, ep) => {
				r[ep.tag] = proto.$properties[ep.tag];
				return r;
			}, util.any({}));
		}
		if (this.facet !== "$bulk") Object.keys(this.links).forEach_(_, (_, name) => {
			proto.$links = proto.$links || {};
			proto.$links[name] = this.links[name].prototypeNode(_);
		}, this);
		return proto;
	}
	pageProto(_: _) {
		var pageProto: types.PageProto = {};
		const repDotFacet = this.representation.name + "." + this.facet;

		// context

		const actx = glob.context.x3session.actx;

		pageProto.$actxUser = actx.$USER(_);
		pageProto.$actxLogin = actx.$LOGIN(_);
		pageProto.$actxFolder = actx.$AFOLDER(_);
		pageProto.$actxSolution = actx.$ASOLUTION(_);
		pageProto.$actxLan = actx.$LAN(_);
		pageProto.$actxLanDef = actx.$LANDEF(_);
		pageProto.$actxLanIso = actx.$LANISO(_);
		pageProto.$actxLegCur = actx.get(_, "AFOLD").get(_, "ALEGCUR");
		pageProto.$actxNbLeg = "" + actx.get(_, "AFOLD").get(_, "ANBLEG");

		// $baseType needed for unit test but we could clean it up
		pageProto.$baseType = "application/json;vnd.sage=syracuse;vnd.sage.syracuse.representation=x3.erp." + actx.$AFOLDER(_);
		pageProto.$type = "{$baseType}." + repDotFacet;
		pageProto.$representation = this.representation.name;
		pageProto.$prototype = "{$baseUrl}/$prototype('{$representation}.$thumb')";
		pageProto.$device = this.representation.qdevice;
		pageProto.$title = this.representation.title(_);
		pageProto.$collaborationUrl = this.supervisor.collaborationUrl;
		pageProto.$baseUrl = this.supervisor.baseUrl;
		if (this.facet === "$edit") pageProto.$repUrl = "{$baseUrl}/$workingCopies('{$trackingId}')";
		else pageProto.$repUrl = "{$baseUrl}/" + this.representation.name;
		pageProto.$instanceUrl = "{$repUrl}/" + this.representation.data.ABRCLA;

		if (this.facet === "$edit") {
			var sysValues = glob.context.x3frame.context.sys.values;
			var adxtul = sysValues.ADXTUL ? sysValues.ADXTUL[2] : [];
			var adxtuc = sysValues.ADXTUC0 ? sysValues.ADXTUC0[2] : [];
			var adxtut = sysValues.ADXTUT0 ? sysValues.ADXTUT0[2] : [];

			pageProto.$x3FormatExt = adxtul.reduce((r: { [name: string]: types.X3FormatProto; }, tul: string, i: number) => {
				r[tul] = {
					stdType: adxtuc[i].split(''),
					chars: adxtut[i].split('')
				};
				return r;
			}, util.any({}));
		}

		if (/^\$(query|lookup|bulk)$/.test(this.facet)) {
			pageProto.$url = "{$baseUrl}/" + this.representation.class.name + "?representation=" + repDotFacet;
			pageProto.$itemsPerPage = 300;
			pageProto.$properties = {
				$resources: {
					$type: "application/x-array",
					$item: this.itemProto(_, {}, "$queryItem")
				}
			};
			// unit test fails with: this.facet + "Item"),
			if (this.facet === "$query" && this.representation.isBehaviourEnabled(8) && this.representation.isFacetEnabled("$edit")) 
				pageProto.$properties.$resources.$capabilities = "quickedit";
		} else {
			pageProto = this.itemProto(_, pageProto, this.facet);
		}

		if (this.facet !== '$bulk') {
			//links
			Object.keys(this.page.links).filter_(_, (_, name) => {
				const isLink = ~[1, 3, 4, 5].indexOf(this.page.links[name].data.TYPLNK) && this.page.links[name].data.CMPLNK < 17;

				return isLink;
			}, this).forEach_(_, (_, name) => {
				pageProto.$links = pageProto.$links || {};
				pageProto.$links[name] = this.page.links[name].prototypeNode(_);
			}, this);
			//actions
			Object.keys(this.page.links).filter_(_, (_, name) => {
				const isLink = ~[1, 3, 4, 5].indexOf(this.page.links[name].data.TYPLNK) && this.page.links[name].data.CMPLNK < 17;
				//#SAM 108421 no abort

				return isLink === false && this.page.links[name].data.CMPLNK !== 19 && this.page.links[name].data.CMPLNK !== 18;
			}, this).forEach_(_, (_, name) => {
				pageProto.$actions = pageProto.$actions || {};
				pageProto.$actions[name] = this.page.links[name].prototypeNode(_);
			}, this);
		}
		// unused pageProto.$localization = {};
		return pageProto;
	}
	loadResource(_: _,  key: string, qs: any) {
		// TODO qs ?
		const k = key.split('~');
		const resource = this.supervisor.new(_, 'Resource', this, null);
		const status = resource.read(_, k);

		if (status === constants.CST_AERROR) {
			throw new util.HttpError(404, key + ":" + this.supervisor.loadMess(_, 100, 23));
		}

		return resource;
	}
	createResource(_: _,  qs: any) {
		const instance = this.class.createInstance(_, qs);
		// Call AINIT in order to enable snapshots:
		const resource = this.supervisor.new(_, 'Resource', this, instance).bindInstance(instance);

		instance.AINIT(_);
		return resource;
	}
	deleteResource(_: _,  httpContext: http.HttpContext, $key: string, qs: any) {
		const key = $key.split('~');
		const resource = this.supervisor.new(_, 'Resource', this, null);

		var status = resource.read(_, key);
		if (status === constants.CST_AERROR) {
			throw new util.HttpError(404, key + ":" + this.supervisor.loadMess(_, 100, 23));
		}
		status = resource.delete(_);
		if (status === constants.CST_AERROR) {
			resource.addDiagnose(_, constants.CST_AOK, this.supervisor.loadMessParams(_, 149, 61, $key));
		}
		const reply = {
			$diagnoses: resource.instance.getDiagnoses(_).map((diag: Diagnosis) => diag.dataNode()),
		};

		return httpContext.jsonReply(_, 200, reply);
	}
	get tag2PropertyName() {
		if (this._tag2PropertyName === undefined) {
			this._tag2PropertyName = Object.keys(this.properties).reduce((r, property) => {
				if (property !== this.properties[property].tag) {
					// Keep memory of tags whose name is different of the property :
					r[this.properties[property].tag] = property;
				}
				return r;
			}, util.any({}));
		}
		return this._tag2PropertyName;
	}
	tag2Property(tag: string): string {
		tracerJs.debug && tracerJs.debug("tag2Property:" + tag);
		const match = tag.match(/upper\((\w*)\)/);

		if (match) {
			return "upper(" + this.tag2Property(match[1]) + ")";
		}
		return this.tag2PropertyName[tag] || tag;
	}
	mapTags2Properties(o: any) {
		const _this = this;

		return Object.keys(o).reduce((r, tag) => {
			const property = _this.tag2Property(tag);

			if (Array.isArray(o[tag])) {
				r[property] = o[tag].map((elt: any) => _this.mapTags2Properties(elt));
			} else if (typeof o[tag] === 'object' && o[tag] != null) {
				r[property] = _this.mapTags2Properties(o[tag]);
			} else {
				r[property] = o[tag];
			}
			return r;
		}, util.any({}));
	}
	sdataFilterToJson(filter: any) {
		return this.mapTags2Properties(filterHelpers.sdataToJson(filter));
	}
	filtersTabCor(_: _) {
		const list = Object.keys(this.properties).reduce((r, property) => {
			if (this.properties[property].tag && this.properties[property].data.FLDCLA && this.properties[property].class && this.properties[property].class.table) {
				r["[F:" + this.properties[property].class.table.data.ABRFIC + "]" + this.properties[property].data.FLDCLA] = this.properties[property].tag;
			}
			return r;
		}, util.any({}));
		const tabcor = list || {};
		const actx = glob.context.x3session.actx;

		tabcor["GACTX.USER"] = '"' + actx.$USER(_) + '"';
		tabcor["GACTX.LAN"] = '"' + actx.$LAN(_) + '"';
		tabcor["[V]CST_ANO"] = "false";
		tabcor["[V]CST_AYES"] = "true";
		return tabcor;
	}

	filterRep(_: _,  name: string) {
		if (this.representation._filters === undefined || this.representation._filters[name] === undefined) {
			var option: any;
			var defaut: any;
			var setdefaut: number;;
			this.representation._filters = {};
			this.representation.data.FILTERS && this.representation.data.FILTERS.forEach_(_, (_, elt) => {
				// GH 6167		
				if (elt.OPTCOD === name) option = elt;
				if (name == undefined) {
					if (elt.OPTDEF === 2) {
						if (elt.OPTACT !== undefined && activ.getActiv(_, this.supervisor, elt.OPTACT) <= 0) {
							// GH 6167																		
							setdefaut = 1; // GH 6167
						} // GH 6167
						else {
								// GH 6167						   
								defaut = elt;
								setdefaut = 2;
							}; // GH 6167
					};
				}
			});
			if (setdefaut == 2) option = defaut;
			if (option) {
				var tabcor = this.filtersTabCor(_);
				this.representation._filters[name] = Jmql.x3ToJmql(tabcor, util.decodeValueMongoString(option.OPTCND));
			}
		}
		return this.representation._filters[name] && this.representation._filters[name]();
	}

	loadResources(_: _,  select: Select, max: number) {
		const fromInstanceToResource = (_: _, reader: ez.Reader<Instance>, writer: ez.Writer<Resource>) => {
			var instance: Instance;
			var astatus: number;
			const cache = this.cache ? this.cache.clone() : undefined;

			while (instance = reader.read(_)) {
				var resource = this.supervisor.new(_, 'Resource', this, instance).bindInstance(instance);

				cache && cache.register(_, resource);
				astatus = resource.afterQuery(_);
				if (astatus !== constants.CST_AERROR) {
					writer.write(_, resource);
				}
			}
			this.representation.afterQuery(_);
		};

		this.representation.beforeQuery(_);
		return this.class.queryInstances(_, select, max).transform(fromInstanceToResource);
	}

	query(_: _,  httpContext: http.HttpContext, qs: any) {
		tracerJs.debug && tracerJs.debug(this.facet + " " + JSON.stringify(qs));
		const itemsPerPage = qs.count ? parseInt(qs.count, 10) : 20;
		const _this = this;

		var firstPage = true;
		var qsOrderBy: string[] = [];
		const oAscDesc = ["", "desc", "asc"];
		const kAscDesc = ["", "lt", "gt"];

		var operators = ["eq", "gt", "lt"];

		// Decode the orderBy contained in the url:
		qsOrderBy = qs.orderBy ? qs.orderBy.split(',') : [];

		// to which we add the representation index	

		const index = _this.representation.index;

		index.forEach((ind, idx) => {
			tracerJs.debug && tracerJs.debug("index[" + idx + "]=" + ind.name);
			qsOrderBy.push(ind.name);
		});

		const properties: string[] = [];

		var ascDescDefault: string;

		var orderBy = qsOrderBy.reduce((r, item) => {
			const items = item.split(' ');
			const property = _this.tag2Property(items[0]);

			if (properties.indexOf(property) < 0) {
				var ascDesc = items.length > 1 ? items[1] : ascDescDefault || 'asc';
				ascDescDefault = ascDescDefault || ascDesc;
				r.push({
					property: property,
					ascDesc: ascDesc
				});
				properties.push(property);
			}
			return r;
		}, []);

		const wheres: string[] = [];
		//if (qs.filter) {
		const filterRep = this.filterRep(_, qs.filter);

		if (filterRep) {
			var filter = this.mapTags2Properties(filterRep);
			if (filter) wheres.push(filter);
		}
		//}

		if (qs.where) wheres.push(this.sdataFilterToJson(qs.where));

		const actx = glob.context.x3session.actx;
		const rights = actx.getRights(_);

		if (rights._authorizedRepresentations[this.representation.data.CODREP] && rights._authorizedRepresentations[this.representation.data.CODREP]._conditions) {
			if (rights._authorizedRepresentations[this.representation.data.CODREP]._conditions._type = "authorization") {
				tracerJs.debug && tracerJs.debug("add rights where" + JSON.stringify(rights._authorizedRepresentations[this.representation.data.CODREP]._conditions[0]._where));
				wheres.push(this.sdataFilterToJson(rights._authorizedRepresentations[this.representation.data.CODREP]._conditions[0]._where));
			}
		}

		if (qs.key) {
			// Decode the orderBy contained in the url:
			var keyItems = [qs.key];
			var io = qs.key.indexOf('.');
			if (io >= 0) {
				keyItems[0] = qs.key.substring(0, io++);
				keyItems[1] = qs.key.substring(io);
			}
			operators = ["eq", keyItems[0], keyItems[0] === 'lt' ? 'gt' : 'lt'];

			if (keyItems.length > 1) {
				firstPage = false;
				var keyParts = keyItems[1].split('~');
				var k = 0;

				var tags: any[];
				if (qs.orderBy) {
					tags = qs.orderBy.split(',').map((item: string) => item.split(' ')[0]);
				} else {
					// By default the client doesn't send the orderBy
					tags = index.map((ind) => ind.name.split(' ')[0]);
				}

				var args = tags.map((tag) => {
					const property = _this.tag2Property(tag);
					return {
						property: property,
						value: keyParts[k++]
					};
				});

				var exps: any[] = [];
				for (var i = 0; i < args.length; i++) {
					var exp: any = {};
					for (var j = 0, maxJ = args.length - i; j < maxJ; j++) {
						var k = 1 + (oAscDesc.indexOf(orderBy[0].ascDesc) + oAscDesc.indexOf(orderBy[j].ascDesc)) % 2;
						var operator = operators[Math.floor((j + 1) / maxJ) * k];
						if (operator === 'eq') {
							exp[args[j].property] = args[j].value;
						} else {
							exp[args[j].property] = exp[args[j].property] || {};
							exp[args[j].property]['$' + operator] = args[j].value;
						}
					}
					exps.push(exp);
				}
				wheres.push(exps.length === 1 ? exps[0] : {
					$or: exps
				});
			}
		} else {
			// operators depends on the order by :
			operators = orderBy[0].ascDesc === 'asc' ? ["eq", "gt", "lt"] : ["eq", "lt", "gt"];
		}
		const ascend = (oAscDesc.indexOf(orderBy[0].ascDesc) + kAscDesc.indexOf(operators[1])) % 2;
		const select: Select = {
			$orderBy: {}
		};

		orderBy.forEach(prop => {
			select.$orderBy[prop.property] = (ascend ? -1 : 1) * (prop.ascDesc === 'asc' ? 1 : -1);
		});

		select.$params = Object.keys(qs).reduce((r, tag) => {
			const property = this.tag2PropertyName[tag] || this.properties[tag] && this.properties[tag].tag;

			if (property) {
				r[property] = qs[tag];
			}
			return r;
		}, util.any({}));

		if (wheres.length) {
			select.$query = wheres.length === 1 ? wheres[0] : {
				$and: wheres
			};
		}

		// (require itemsPerPage+1 items to manage next link
		if (/^\$(query|lookup)$/.test(this.facet)) {
			var resources = this.loadResources(_, select, itemsPerPage + 1).toArray(_);

			var feed: types.Feed = {
				$itemsPerPage: itemsPerPage,
				$resources: resources.slice(0, itemsPerPage).map_(_, (_, res) => res.dataNode(_))
			};
			if (ascend) feed.$resources = feed.$resources.reverse();

			// Add navigation links :
			if (resources.length) {
				var keyFirst = orderBy[0].ascDesc === 'asc' ? "gt" : "lt";
				var keyLast = orderBy[0].ascDesc === 'asc' ? "lt" : "gt";
				var links: { [key: string]: string[]; } = {
					$first: [keyFirst],
					$last: [keyLast]
				};

				var names = ["$previous", "$next"];
				var keyNext = operators[1];
				var keyPrevious = keyNext === "lt" ? "gt" : "lt";
				if (ascend) names = names.reverse();

				var linkOrderBy = orderBy.reduce_(_, (_, r, property) => {
					if (!firstPage) {
						links[names[0]] = links[names[0]] || [keyPrevious];
						links[names[0]].push(resources[0].instance.get(_, property.property));
					}
					if (resources.length > itemsPerPage) {
						links[names[1]] = links[names[1]] || [keyNext];
						links[names[1]].push(resources[resources.length - 2].instance.get(_, property.property));
					}
					var item = property.property;
					if (property.ascDesc && property.ascDesc === "desc") item += ' ' + property.ascDesc;
					r.push(item);
					return r;
				}, []);

				Object.keys(links).forEach(link => {
					feed.$links = feed.$links || {};
					feed.$links[link] = {
						$url: _this.supervisor.baseUrl + "/" + _this.class.name + "?representation=" + _this.representation.name + ".$query",
						$type: "application/json;vnd.sage=syracuse"
					};
					if (!(link === "$first" && links[link][0] === keyFirst)) {
						feed.$links[link].$url += "&key=" + links[link][0];
						if (links[link].length > 1) feed.$links[link].$url += '.' + links[link].slice(1).join('~');
					}

					feed.$links[link].$url += "&orderBy=" + linkOrderBy.join(',');

					if (qs.where) {
						feed.$links[link].$url += "&where=" + encodeURIComponent(qs.where);
					}
				});
			}
			return httpContext.jsonReply(_, 200, feed);
		} else if (this.facet === '$bulk') {
			var dst = bulkWriter(httpContext);
			this.loadResources(_, null, qs.count || Infinity).pipe(_, dst);
		}
	}
	keyExpression() {
		//return this.class.keyExpression();
		if (this.keyItems) return this.keyItems.map(keyitem => {
			return '{' + keyitem.alias + '}';
		}, this).join('~');
	}
};

export const Constructor = ResourceFactory;