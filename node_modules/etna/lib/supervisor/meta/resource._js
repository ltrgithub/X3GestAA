"use strict";

const util = require("etna/lib/supervisor/util");
const tuuid = require('etna/lib/engine/runtime/uuid');
const variables = require('etna/lib/engine/runtime/variables');
const tracerJs = require('syracuse-core').getTracer("etna.supervisor");
const constants = require("etna/lib/supervisor/constants");
const attributes = require("etna/lib/supervisor/attributes");
const BaseInstance = require("etna/lib/supervisor/meta/baseInstance").BaseInstance;
const Slot = require("etna/lib/supervisor/slot").Slot;
const SlotCollection = require("etna/lib/supervisor/slotCollection").SlotCollection;

class Resource extends BaseInstance {
	constructor(superv, resourceFactory, instance, slots) {
		super(superv);
		this.supervisor = superv;
		this.resourceFactory = resourceFactory;

		this.meta = this.resourceFactory.representation;

		if (this.meta) {
			this.clasName = this.meta.data.ABRCLA;
			this.index = this.resourceFactory.representation.class.index;
		}
		this.properties = this.resourceFactory.properties;
		if (instance) this.instance = instance;
		this.$exported = true;
		this.slots = slots || {};
	}

	get $$type() {
		return "Resource";
	}
	// Use bindInstance in order to set the instance.$parent !
	bindInstance(instance) {
		this.instance = instance;
		this.instance.$parent = this;
		this.instance.proName = this.clasName || "";
		this.instance.proJsName = this.jsClassName;
		return this;
	}
	dataNode(_, full) {
		full = full !== undefined ? full : true; // Default behavior = full generation
		var result = {};
		if (this.instance && this.instance.class && this.instance.class.group == null) {
			if (this.instance.class.properties['UPDDATTIM']) {
				this.instance.get(_, 'UPDDATTIM') ? this.instance.get(_, 'UPDDATTIM').toString() : "0000-00-00T00:00:00Z";
			}
		}
		const uuid = this.instance ? this.instance.$uuid : this.$uuid;

		if (uuid) result.$uuid = uuid.x3ToString();

		if (this.resourceFactory.$access) result.$access = this.resourceFactory.$access(_, this.instance);

		Object.keys(this.properties).filter(name => !this.resourceFactory.properties[name].isExtraRef).forEach_(_, (_, name) => {
			const prop = this.properties[name];
			const instance = prop.instance(this);

			if (prop.collection) {
				if (prop.isInstance) {
					// Special treatment for 1x1 tables :
					var child = instance.get(_, name);
					var rChild = this.supervisor.new(_, 'Resource', prop.targetResourceFactory, child).dataNode(_, full);

					result = Object.keys(rChild).filter(p => p.charAt(0) !== '$').reduce((r, p) => {
						r[p] = rChild[p];
						return r;
					}, result);
				} else {
					var collection = instance.get(_, name);
					var snapshot = instance.$syssnapshot ? instance.$syssnapshot.get(_, name) : undefined;
					var delta = !full && !prop.isArray && snapshot !== undefined && snapshot !== collection;
					var lines = delta ? collection.getDelta(_, snapshot) : collection.lines;

					var lineIndex = 0;

					var rChild = lines.filter(line => {
						// Filter line null or deleted :
						return line !== null && line.$astalin !== constants.CST_ADEL && line.$astalin !== constants.CST_ANEWDEL;
					}).map_(_, (_, child) => {
						// If the collection is an array then full = TRUE!
						const resLine = this.supervisor.new(_, 'Resource', prop.targetResourceFactory, child).dataNode(_, prop.isArray ? true : full);

						// -the attribute $index must be present in the resource when the server sends a delta
						// -the attribute $index must not be present in the resource when the server sends the full collection

						if (!full) resLine.$index = child.$index !== undefined ? child.$index : lineIndex++;
						return resLine;
					}, this);

					//dbg:console.error("rChild length:"+rChild.length);
					if (prop.isArray) {
						//dbg:console.log("dataNode "+name+ " isArray");
						// Special treatment for collection with only 1 property :
						result[prop.tag] = Object.keys(rChild).reduce((r, p) => {
							var childDest;
							//dbg:console.log("dataNode prop.isArray p:"+p+" rChild[p]:",rChild[p]);
							const val = Object.keys(rChild[p]).reduce((v, name) => {
								if (name[0] !== '$') {
									// Exclude $uid, $index...
									//dbg:console.log("dataNode prop.isArray p:"+p+" name:"+name+" push:"+rChild[p][name]);
									v.push(rChild[p][name]);
									if (!childDest) childDest = name;
								}
								return v;
							}, []);
							//dbg:console.log("dataNode val:",val);

							if (val.length === 1) r[p] = val[0];
							else if (val.length > 1) {
								r[p] = {};
								//dbg:console.log("dataNode childDest:"+childDest+" val:",val);
								if (prop.targetResourceFactory.properties[childDest] !== undefined) {
									r[p][prop.targetResourceFactory.properties[childDest].destLookup] = val[0];
									r[p] = Object.keys(val[1]).reduce((o, name) => {
										o[name] = val[1][name];
										return o;
									}, r[p]);
								}
							}
							return r;
						}, []);
					} else {
						result[prop.tag] = rChild;
					}
					if (result[prop.tag].length === 0) result[prop.tag] = undefined;
				}
			} else {
				//dbg:console.error(name+ " instance:"+!!instance)
				var slot = instance.slot(_, name);
				var value = slot.get(_, true);

				var snapshot = instance.$syssnapshot;
				var delta = !full && snapshot !== undefined;
				if (delta) {
					// Compare value and old value :
					var oldValue = snapshot.get(_, name, true);
					value = oldValue === undefined || oldValue.x3Compare(value) !== 0 ? value : undefined;
				}

				// Manage the value
				if (value !== undefined) {
					// Compute the value to be stored in the JSON:
					// can be undefined for CLOBs andd BLOBs
					value = slot.toJson(_, value);
					if (value !== undefined) {
						result[prop.tag] = value;
						if (prop._isReference) {
							result[prop.ref(prop.tag)] = instance.get(_, prop.ref(name));
						} else if (prop.hasLookup) {
							result[prop.ref(prop.tag)] = {
								$title: ""
							};
						}
					}
				}
				if (this.resourceFactory.$attributes) {
					// Fetch attributes :
					var attributes = delta ? slot.getDeltaAttributes(_, snapshot.slot(_, name)) : slot.getAttributes(_);
					// Store them in the node											
					this.resourceFactory.$attributes(result, prop.tag, attributes);
				}
				if (this.resourceFactory.$diagnoses) {
					// Manage the errors :
					var diagnoses = slot.getDiagnoses(_);
					if (delta) {
						// Compare old and current diagnoses
						var snapSlot = snapshot.slot(_, name);
						var oldDiagnoses = snapSlot.getDiagnoses(_);
						// set diagnoses to null if diagnoses were deleted:
						diagnoses = oldDiagnoses.length && !diagnoses.length ? null : diagnoses;
					}
					// Store them in the node											
					this.resourceFactory.$diagnoses(result, prop.tag, diagnoses);
				}
			}
		}, this);
		if (this.resourceFactory.$diagnoses) {
			var diagnoses = this.diagnoses;
			if (this.instance) diagnoses = diagnoses.concat(this.instance.diagnoses);
			if (diagnoses.length) this.resourceFactory.$diagnoses(result, null, diagnoses);
		}
		return result;
	}
	applyDelta(_, delta) {
		// take snapshot before assigning
		//dbg:console.error("applyDelta on "+this.$$type+" "+this.$id.x3ToString())
		const resourceFactory = this.resourceFactory;

		Object.keys(delta).forEach_(_, (_, tag) => {
			//dbg:console.log("applyDelta properties:" + Object.keys(this.properties));
			//dbg:console.log("applyDelta tag:" + tag);
			var name = resourceFactory.tag2Property(tag);
			//dbg:console.log("applyDelta name:" + name);
			var prop = this.properties[name];
			if (!prop) {
				if (tag[0] !== '$') {
					var keys = Object.keys(this.properties);
					for (var i = 0, len = keys.length; i < len; i++) {
						if (this.properties[keys[i]].isInstance) {
							name = keys[i];
							//dbg:console.error("isInstance "+name+" isInstance");
							prop = this.properties[name];
							var child = prop.instance(this).get(_, name);
							var rChild = this.supervisor.new(_, 'Resource', prop.targetResourceFactory, child);
							rChild.applyDelta(_, delta);
							return;
						}
					}
				}
				//dbg:console.error("ignoring " + tag + " from delta");
				return;
			}

			const v = delta[tag];

			if (v === undefined) return;

			const instance = prop.instance(this);

			if (prop.collection) {
				var collection = instance.get(_, name);
				if (prop.isArray) {
					//dbg:console.log("applyDelta on an Array");
					// Special treatement for collection of 1 property :
					// Empty the collection
					collection.empty(_);
					// Recreate the collection:
					v.forEach_(_, (_, deltaLine) => {
						// Add a line :
						//dbg:console.log("applyDelta array add element");
						const i = collection.add(_, constants.CST_ALASTPOS);
						const line = collection.index(_, i);
						const propCol = prop.collection.class.data.PROPERTIES[0];

						var proName = propCol.FLDCLA || propCol.CODFLD;
						if (prop.collection.class.properties[proName].isReference()) {
							// Deltaline is an object which describe the reference
							proName += "_REF";
						}
						//dbg:console.error("array."+i+" set "+proName+" with:",deltaLine);
						line.set(_, proName, deltaLine);
					});
				} else {
					v.forEach_(_, (_, deltaLine) => {
						const uuid = deltaLine.$uuid.x3ToUuid();

						//dbg:console.log("applyDelta line uuid:" + uuid);

						var line = collection.find("$uuid", uuid);

						if (line !== null) {
							//dbg:console.log("applyDelta to Line " + line.$uuid.x3ToString()+" parent type:"+line.$parent.$$type);
							if (deltaLine.$isDeleted) {
								// Delete the line :
								collection.del(_, deltaLine.$index + 1);
							} else {
								var rChild = this.supervisor.new(_, 'Resource', prop.targetResourceFactory, line);
								rChild.applyDelta(_, deltaLine);
							}
						} else if (!deltaLine.$isDeleted) {
							// don't add a line is $isDeleted = true
							var i = collection.add(_, deltaLine.$index ? deltaLine.$index + 1 : constants.CST_ALASTPOS, uuid);
							line = collection.index(_, i);
							//dbg:console.log("applydDelta added Line "+line.$uuid.x3ToString()+" parent type:"+line.$parent.$$type);
							var rChild = this.supervisor.new(_, 'Resource', prop.targetResourceFactory, line);
							rChild.applyDelta(_, deltaLine);
						}
					});
				}
			} else if (!/.*_REF$/.test(name)) {
				// See later for references :
				//dbg:console.error("applyDelta instance.set " + name + " parent type:" + instance.$parent.$$type);
				instance.set(_, name, v);
			}
		});
	}
	clone() {
		const instance = this.instance.clone();

		return new Resource(this.supervisor, this.resourceFactory, instance).bindInstance(instance);
	}
	getChildren() {
		return [this.instance];
	}
	afterQuery(_) {
		// First call AQUERY_TRANS_AFTER on the class's instance
		return this.instance.afterQuery(_);
	}
	beforeControl(_, operation) {
		const status = this.actionBeforeControl(_, operation);

		return status || this.instance.beforeControl(_, operation);
	}
	afterControl(_, operation) {
		const status = this.instance.afterControl(_, operation);

		return status || this.actionAfterControl(_, operation);
	}
	insert(_) {
		return this.instance.$AINSERT(_);
	}
	update(_) {
		return this.instance.$AUPDATE(_);
	}
	read(_, key) {
		this.key = key;
		tracerJs.debug && tracerJs.debug("resource.load " + key);
		this.instance = this.supervisor.new(_, 'Instance', this.resourceFactory.representation.class, this);
		this.bindInstance(this.instance); // Set instance.$parent !
		// Call AINIT in order to enable snapshots:
		this.instance.AINIT(_);
		const status = this.instance.read(_, key);

		return status;
	}
	delete(_) {
		return this.instance.$ADELETE(_);
	}
};

exports.Constructor = Resource;