"use strict";

var util = require("etna/lib/supervisor/util");
var utilDriver = require("etna/lib/engine/drivers/util");
var date = require('syracuse-core').types.date;
var bcd = require('etna/lib/engine/runtime/bcd');
var uuid = require('etna/lib/engine/runtime/uuid');
var tuuid = require('etna/lib/engine/runtime/tuuid');
var tdate = require('etna/lib/engine/runtime/tdate');
var tdatetime = require('etna/lib/engine/runtime/tdatetime');
var datetime = require('syracuse-core').types.datetime;
var variables = require('etna/lib/engine/runtime/variables');
var runtime = require('etna/lib/engine/runtime/runtime');

var activ = require("etna/lib/supervisor/meta/activ");

var tracerJs = require('syracuse-core').getTracer("etna.supervisor");

var typTyp2EtnaType = {
	1: "J",
	2: "I",
	3: "I",
	4: "N",
	7: "S",
	8: "D",
	9: "B",
	10: "T",
	11: "Z",
	12: "E",
	13: "Y"
};

var mapTypeRule = {
	1:"INIT",
	2:"CONTROL",
	3:"PROPAGATE",
	4:"GETVALUE",
	5:"FORMAT",
	6:"READ_MEDIA",
	7:"UPDATE_MEDIA",
	8:"DELETE_MEDIA",
	9:"INSERT_MEDIA",
	10:"READ_MEDIA_CNT",
	11:"EXIST_MEDIA"
}

class Type {
	constructor(superv, data) {
		this.supervisor = superv;
		if (data.LNGTYP && typeof data.LNGTYP === 'string') {
			if (!isNaN(data.LNGTYP) && bcd.toDouble(bcd.fromString(data.LNGTYP)) > 0) data.LNGTYP = bcd.toDouble(bcd.fromString(data.LNGTYP));
			else delete data.LNGTYP;
		}
		this.data = data;
	}

	init(_) {
		this.protyp = this.data.TYPPROSYR ? this.supervisor.load(_, 'Typepro', this.data.TYPPROSYR) : undefined;
		if(this.data.RULES) {
			this.rules = this.data.RULES.filter_( _, (_,rule) => {
					return rule.ENARUL === 2 && activ.getActiv(_, this.supervisor, rule.ACTRUL) > 0;
				}).reduce_(_ ,(_, r, rule) =>  {
					r[mapTypeRule[rule.TYPRUL]] = {
						scriptName:rule.TRTRUL,
						prog:rule.PRGRUL,
						params: rule.PARAMETERS ? rule.PARAMETERS
						.reduce_(_, function(_, r, param) {
							r[param.PARCOD] = {
								type: (param.PARMOD === 1?"A":"L") + typTyp2EtnaType[param.PARTYP]
							};
							return r;
						}, {}) : {},
					}
					return r;
				},{});
		}		 
		return this;
	}

	applyRule(_, rule,args) {
		rule.script = rule.script || this.supervisor.loadScript(_, rule.scriptName);
		//dbg:console.log("applyRule:"+[rule.script, rule.prog].join(','));
		return runtime.executeProg(_, rule.script, rule.prog, args);
	}

	mediaArgs(_,slot) {
		var instance = slot.$parent;
		var key = instance.getKey(_);
		key = (key && Array.isArray(key)) ? key.join('~') : key;
		return {
			AINSTANCE: {
				type: "LY",
				value: instance
			},
			APRONAME: {
				type: "LY",
				value: slot.name
			},
			CLE: {
				type: "LS",
				value: key
			}
		};			
	}
	contentType(_, slot) {
		var contentType =  this.protyp ? this.protyp.data.PROTYP : "text/plain";
		if(this.rules && this.rules.READ_MEDIA_CNT) {
			var rule = this.rules.READ_MEDIA_CNT;
			var args = this.mediaArgs(_,slot);
			args.AVALCNT =  {
				type: "AS",
				value: ""
			};
			var astatus = this.applyRule(_, rule, args);
			contentType = args.AVALCNT.value;
		}
		return {$contentType:contentType};
	}

	readLob(_, slot) {
		var lob;
		if(this.rules && this.rules.READ_MEDIA) {
			var rule = this.rules.READ_MEDIA;
			var args = this.mediaArgs(_,slot);

			args.AVALUE = {
				type: "AT",
				value: ""
			};			
			var astatus = this.applyRule(_, rule, args);
			lob = args.AVALUE.value;
			//dbg:console.log("readLob args:",args);
			//dbg:console.log("readLob lob:"+lob);
		} else {
			var sqlDriver = this.supervisor.sqlDriver;
			var param = sqlDriver.param;
			var instance = slot.$parent;
			var key = instance.getKey(_);
			var params = [key[0], (key[1]|| ' '), ' ', ' '];

			var field = this.data.LOBFLD || "BLOB";
			var table = this.data.LOBTAB || "ABLOB";

			try {
				var i = 0;
				var rs = this.supervisor.sqlReader(_, "select C." + field + "_0 From " + table + " C Where" +
					" C.CODBLB_0=" + param(i++) + " and C.IDENT1_0=" + param(i++) + " and C.IDENT2_0=" + param(i++) + " and C.IDENT3_0=" + param(i++), params).toArray(_);
				lob =  rs.length ? rs[0][field] :undefined;
			} catch (e) {
				util.traceException(e);
			}
		} 
		return lob;
	}	

	insertLob(_,slot, value) {
		//dbg:console.log("insertLob")
		if(this.rules && this.rules.INSERT_MEDIA) {
			var rule = this.rules.INSERT_MEDIA;
			var args = this.mediaArgs(_,slot);

			args.AVALUE = {
				type: "AT",
				value: value
			};			
			return this.applyRule(_, rule, args);
			//dbg:console.log("readLob args:",args);
			//dbg:console.log("readLob lob:"+lob);
		} else {}
	}

	updateLob(_,slot,value) {
		//dbg:console.log("updateLob")
		if(this.rules && this.rules.UPDATE_MEDIA) {
			var rule = this.rules.UPDATE_MEDIA;
			var args = this.mediaArgs(_,slot);

			args.AVALUE = {
				type: "AT",
				value: value
			};			
			return this.applyRule(_, rule, args);
		} else {}
	}

	deleteLob(_,slot, value) {
		//dbg:console.log("deleteLob")
		if(this.rules && this.rules.DELETE_MEDIA) {
			var rule = this.rules.DELETE_MEDIA;
			var args = this.mediaArgs(_,slot);

			args.AVALUE = {
				type: "AT",
				value: value
			};			
			return this.applyRule(_, rule, args);
		} else {}

	}


	get defaultValue() {
		return variables.types[this.etnaType].default;
	}

	get maxLength() {
		return this.data.LNGTYP;
	}

	get jsType() {
		switch (this.data.TYPTYP) {
			case 1:
				// tiny int
				return "number";
			case 2:
				// short integer
				return "number";
			case 3:
				// long integer - was translatable text ???
				return "number";
			case 4:
				return "string";
			case 7:
				return "string";
			case 8:
				// date
				return "date";
			case 10:
				// documnet
				return "object";
			case 11:
				// uuid
				return "binary";
			case 12:
				// datetime
				return "date";
			default:
				throw new Error("NIY type: " + this.data.TYPTYP);
		}
	}

	get etnaType() {
		if (typTyp2EtnaType[this.data.TYPTYP]) {
			return typTyp2EtnaType[this.data.TYPTYP];
		}
		throw new Error("NIY type: " + this.data.TYPTYP);
	}

	get isBlob() {
		return this.data.TYPTYP === 9;
	}

	get isClob() {
		return this.data.TYPTYP === 10;
	}
	get isLob() {
		return this.isBlob || this.isClob;
	}

	targetClass(_) {
		if (this.data.CODCLA) return this.supervisor.load(_, 'Class', this.data.CODCLA);
	}


	getX3Format(propertyLength) {
		this.$x3Format = undefined;
		if (this.data.TYPTYP === 7 && (this.data.FORTYP || this.data.OPTION || this.data.LNGTYP)) {
			// type string : initialize $x3Format
			var x3Format = "K";
			var chfmt = this.data.FORTYP || "";
			var optsai = this.data.OPTION || "";
			var carfmt = "";
			var optfmt = "";

			propertyLength = propertyLength || this.data.LNGTYP;

			if (/^=|\[+|>/.test(chfmt)) chfmt = "";

			if (/C+/.test(optsai)) carfmt = "c";
			else if (/A+/.test(optsai)) carfmt = /\#+/.test(optsai) ? "B" : "A";
			else if (/\#+/.test(optsai)) carfmt = "#";
			else carfmt = "X";

			if (/T+/.test(optsai)) optfmt += "T";
			else if (/D+/.test(optsai)) optfmt += "TD";

			if (/\*+/.test(optsai)) optfmt += "*+";
			if (/1+/.test(optsai)) optfmt += "1";
			if (/z+/.test(optsai)) optfmt += "z";

			if (/=+/.test(optsai)) optfmt += "=";
			else if (/<+/.test(optsai)) optfmt += "<";
			else if (/>+/.test(optsai)) optfmt += ">";

			if (/W+/.test(optsai)) optfmt += "W";

			if (chfmt.length && !/^=/.test(chfmt)) {
				if (optsai = "" && /X+/.test(chfmt)) x3Format = undefined;
			} else chfmt = propertyLength.toString() + carfmt;
			if (/T+/.test(optfmt) && !/TD+/.test(optfmt)) x3Format = undefined;

			this.$x3Format = x3Format ? x3Format + optfmt + ":" + chfmt : "";
		}
		return this.$x3Format;
	}

	sqlType(colData) {
		var driver = this.supervisor.sqlDriver;
		switch (this.data.TYPTYP) {
			case 1:
				return driver.tinyIntType();
			case 2:
				return driver.shortIntType();
			case 3:
				// translatable text (no column)
				return driver.intType();
			case 4:
				return driver.decimalType();
			case 7:
				return driver.stringType(this.data.LNGTYP || (colData && colData.LONG) || 1020);
			case 8:
				return driver.dateType();
			case 9:
				return driver.blobType();
			case 10:
				return driver.clobType();
			case 11:
				return driver.uuidType();
			case 12:
				return driver.datetimeType();
			default:
				throw new Error("unsupported datatype: " + this.data.TYPTYP + " (" + typeof this.data.TYPTYP + ")");
		}
	}

	convertIn(val) {
		switch (this.data.TYPTYP) {
			case 8:
				// date
				return val ? date.fromJsDate(new Date(val)) : null;
			case 12:
				// datetime
				return val ? datetime.fromJsDate(new Date(val)) : null;
			default:
				return val;
		}
	}

	toSql(val) {
		return val.x3ToSql(this.supervisor.sqlDriver);
	}

	fromSql(_, val) {
		return utilDriver.fromSql(_, val, this.data.TYPTYP, this.supervisor.sqlDriver);
	}

	toSqlQuery(val) {
		var driver = this.supervisor.sqlDriver;
		switch (this.data.TYPTYP) {
			case 7:
				return "'" + val + "'";
			case 8:
				return driver.sqlDate(val);
			default:
				return val;
		}
	}


	toJson(_, slot , val) {
		switch (this.data.TYPTYP) {
			case 1:
				return (slot.property.data.NOLIB !== 1) ? val : (val === 2 ? true : false);
			case 4:
				return val ? val.x3ToString() : 0; // val ? bcd.toString(val) : "0";
			case 8: // date
				return val ? val.x3ToJson() : null;
			case 9: // blob = DO NOTHING
				return undefined;
			case 10: // clob = DO NOTHING
				return this.contentType(_,slot, val);
			case 11: // uuid
			case 12: // datetime
				return val.x3ToString(); //val.toString();
			default:
				return val;
		}
	}

	fillNode(_, data, node) {
		if (this.atypepro === undefined) {
			var typpro = this.supervisor.load(_, 'Typepro', this.data.TYPPROSYR);
			if (!typpro) throw new Error("content type not found: " + this.data.TYPPROSYR);
			this.atypepro = {
				protyp: typpro.data.PROTYP,
				preflg: typpro.data.PREFLG,
				lisflg: typpro.data.LISFLG
			};
		}
		node.$type = this.atypepro.protyp;

		if (this.data.FMTPROSYR > 1) {
			var fmt;
			switch (this.data.FMTPROSYR) {
				case 2:
					fmt = "$email";
					break;
				case 3:
					fmt = "$phone";
					break;
				case 6:
					fmt = "TT"; // Time format hh:mm:ss
					break;
				default:
					fmt = this.supervisor.loadMess(_, 7880, this.data.FMTPROSYR);
					break;
			}
			if (fmt !== "") node.$format = fmt;

		}
		switch (this.data.TYPTYP) {
			case 2:
			case 3:
			case 4:
				var lon = (data.LONG > 0) ? data.LONG : ((this.data.LNGTYP > 0) ? this.data.LNGTYP : undefined);
				if (lon !== undefined) node.$maxLength = Math.floor(lon);

				if (this.data.TYPTYP === 4 && lon >= 0) {
					node.$precision = parseInt(lon);
					var l = ("" + Math.round(lon * 1e6) / 1e6).split('.');
					node.$scale = parseInt(l[1] || 0);
					if (node.$scale === 0) node.$format = "0";
					else {
						var zero = "0000000000000000000000000000000000000000000";
						node.$format = "0." + zero.substring(0, node.$scale);
					}
				}
				break;
			case 7:
				var lon = (this.data.LNGTYP > 0) ? this.data.LNGTYP : ((data.LONG > 0) ? data.LONG : undefined);
				if (lon !== undefined) node.$maxLength = Math.floor(lon);
				break;
		}
	}

}

module.exports = {
	collectionName: 'ATYPE',
	keyName: 'CODTYP',
	typTyp2EtnaType: typTyp2EtnaType,
	constructor: Type,
	fillTypeNode: function(_, superv, data, node) {
		var typ = superv.load(_, 'Type', data.CODTYP);
		if (!typ) throw new Error("type not found: " + data.CODTYP);
		if (data.NOLIB === 1) {
			node.$type = 'application/x-boolean';
		}
		//Elsif len(ASHW.ASWR(I).UOMPRO)
		// #It's a unit
		//  PROTYPE =func ASYRJSO.TYP('quantity')
		else if (data.CODTYP === 'ATX') {
			node.$type = 'application/x-string';
			node.$maxLength = 30;
		} else {
			typ.fillNode(_, data, node);
		}
		if (data.NOLIB >= 2) {
			node.$value = {
				$type: 'application/x-integer',
				$enum: superv.loadEnum(_, data.NOLIB).filter(function(entry) {
					return entry.$title !== '#'; // remove bogus entries in module list
				}),
			};
		}
	}
};