"use strict";

var util = require("etna/lib/supervisor/util");
var utilDriver = require("etna/lib/engine/drivers/util");
var date = require('syracuse-core').types.date;
var bcd = require('etna/lib/engine/runtime/bcd');
var uuid = require('etna/lib/engine/runtime/uuid');
var tuuid = require('etna/lib/engine/runtime/tuuid');
var tdate = require('etna/lib/engine/runtime/tdate');
var tdatetime = require('etna/lib/engine/runtime/tdatetime');
var datetime = require('syracuse-core').types.datetime;
var variables = require('etna/lib/engine/runtime/variables');
var runtime = require('etna/lib/engine/runtime/runtime');
var format = require('etna/lib/engine/runtime/format');

var activ = require("etna/lib/supervisor/meta/activ");
var constants = require("etna/lib/supervisor/constants");

var tracerJs = require('syracuse-core').getTracer("etna.supervisor");
var tracerDbms = require('syracuse-core').getTracer("etna.dbms");

var typTyp2EtnaType = {
	1: "J",
	2: "I",
	3: "I",
	4: "N",
	6: "W",
	7: "S",
	8: "D",
	9: "B",
	10: "T",
	11: "Z",
	12: "E",
	13: "Y"
};
const etnaType2TypTyp = Object.keys(typTyp2EtnaType).reduce((r, k) => (r[typTyp2EtnaType[k]] = k, r), {});



var mapTypeRule = {
	1:"INIT",
	2:"CONTROL",
	3:"PROPAGATE",
	4:"GET",
	5:"FORMAT",
	6:"READ_MEDIA",
	7:"UPDATE_MEDIA",
	8:"DELETE_MEDIA",
	9:"INSERT_MEDIA",
	10:"READ_MEDIA_CNT",
	11:"EXIST_MEDIA"
}

class Type {
	constructor(superv, data) {
		this.supervisor = superv;
		if (data.LNGTYP && typeof data.LNGTYP === 'string') {
			if (!isNaN(data.LNGTYP) && bcd.toDouble(bcd.fromString(data.LNGTYP)) > 0) data.LNGTYP = bcd.toDouble(bcd.fromString(data.LNGTYP));
			else delete data.LNGTYP;
		}
		this.data = data;
		this.INIT = null;
		this.CONTROL = null;
		this.PROPAGATE = null;
		this.GET = null;

		this.readMedia = null;
		this.insertMedia = null;
		this.updateMedia = null;
		this.deleteMedia = null;
	}

	init(_) {
		var makeTypeRule = function(type, name) {
			var rule = type.rules[name];
			return function(_, slot) {
				var instance = slot.$parent;
				var value = slot.get(_,true);
				var maps = slot.property.typeRulesMaps(_);
				///dbg:console.log("execute rule "+name+" on "+slot.name+" maps:",maps);
				var args = Object.keys(maps).reduce_(_, (_,r, p) => {
					r[p] = {
						type:maps[p].type,
						value:maps[p].value(_, instance)
					};
					return r;
				},{
					AINSTANCE: {
						type: "LY",
						value: instance
					},
					APRONAME:{
						type: "BS",
						value: slot.property.name
					},
					AVALUE: {
						type: "A"+type.etnaType,
						value: (value !== undefined) ? value : type.defaultValue
					}
				});
				// Let's add the AFORMAT parameter if necessary
				if(name === "FORMAT") args.AFORMAT = {type:"AS",value: ""};

				var status = type.applyRule(_, rule, args);
				//dbg:console.log("execute rule "+name+" =>");//,args);
				if(status != constants.CST_AERROR) {
					//dbg:console.log("execute rule "+name+" set "+args.AVALUE.value);
					slot.set(_,args.AVALUE.value,true);
					//dbg:console.log("execute rule "+name+" check set "+slot.get(_,true));
					if(name === "FORMAT") {
						this.$x3Format = args.AFORMAT.value;
						this.regex = format.fromX3FormatToRegex(this.$x3Format);
					}
				}
				return status;
			}
		}

		var makeMediaRule = function(rule) {
			return function(_,slot, value) {
				var args = this.mediaArgs(_,slot);
				args.AVALUE = {
					type: "AT",
					value: value || ""
				};			
				var status =  this.applyRule(_, rule, args);
				return (value !== undefined) ? status : args.AVALUE.value; // Value = undefined for the read
			}
		}

		var makeMediaLazyRule = function(rule) {
			return function(_, property, keys) {
				// console.log("lazyRule:",keys);
				let maps = property.typeRulesMaps(_);
				let i=0;
				var args = Object.keys(maps).reduce_(_, (_,r, p) => {
					r[p] = {
						type:maps[p].type,
						value:keys[i++]
					};
					return r;
				},{
					AINSTANCE: {
						type: "LY",
						value: null
					},
					APRONAME:{
						type: "BS",
						value: property.name
					},
					AVALUE: {
						type: "A"+this.etnaType,
						value: this.defaultValue
					}
				});
				var status =  this.applyRule(_, rule, args);
				// console.log("makeMediaLazyRule =>",args)
				return status === constants.CST_AOK ? args.AVALUE.value : ""; 
			}
		}

		this.protyp = this.data.TYPPROSYR ? this.supervisor.load(_, 'Typepro', this.data.TYPPROSYR) : undefined;
		if(this.data.RULES) {
			this.rules = this.data.RULES.filter_( _, (_,rule) => {
					return !/^WMTYP/.test(rule.TRTRUL) &&  rule.ENARUL === 2 && activ.getActiv(_, this.supervisor, rule.ACTRUL) > 0;
				}).reduce_(_ ,(_, r, rule) =>  {
					r[mapTypeRule[rule.TYPRUL]] = {
						scriptName:rule.TRTRUL,
						prog:rule.PRGRUL,
						params: rule.PARAMETERS ? rule.PARAMETERS
						.reduce_(_, function(_, r, param) {
							r[param.PARCOD] = {
								type: (param.PARMOD === 1?"A":"L") + typTyp2EtnaType[param.PARTYP]
							};
							return r;
						}, {}) : {},
					}
					return r;
				},{});
			// console.log("type "+this.data.CODTYP+" rules:",this.rules);	

			if(this.rules.INIT) 		this.INIT 		 = makeTypeRule(this,"INIT");
			if(this.rules.CONTROL)		this.CONTROL	 = makeTypeRule(this,"CONTROL");
			if(this.rules.PROPAGATE)	this.PROPAGATE	 = makeTypeRule(this,"PROPAGATE");
			if(this.rules.FORMAT)		this.FORMAT 	 = makeTypeRule(this,"FORMAT");
			if(this.rules.GET)			this.GET 		 = makeTypeRule(this,"GET");
			if(this.rules.READ_MEDIA)   {
				this.readMedia     = makeMediaRule(this.rules.READ_MEDIA);
				this.readMediaLazy = makeMediaLazyRule(this.rules.READ_MEDIA);
			} 
			if(this.rules.READ_MEDIA_CNT)   {
				this.readMediaCnt     = makeMediaRule(this.rules.READ_MEDIA_CNT);
			}
			if(this.rules.INSERT_MEDIA) this.insertMedia = makeMediaRule(this.rules.INSERT_MEDIA); 
			if(this.rules.UPDATE_MEDIA) this.updateMedia = makeMediaRule(this.rules.UPDATE_MEDIA); 
			if(this.rules.DELETE_MEDIA) this.deleteMedia = makeMediaRule(this.rules.DELETE_MEDIA); 
		}		 
		return this;
	}
	get defaultValue() { return variables.types[this.etnaType].default;}

	get maxLength()  { return this.data.LNGTYP;}

	get etnaType() {
		if (typTyp2EtnaType[this.data.TYPTYP]) {
			return typTyp2EtnaType[this.data.TYPTYP];
		}
		throw new Error("NIY type: " + this.data.TYPTYP);
	}

	get isClob() { return false;}

	get isBlob() { return false;}

	get isLob()  { return this.isBlob || this.isClob;}

	get jsType() { throw new Error("NIY type: " + this.data.TYPTYP);}

	targetClass(_) {
		if (this.data.CODCLA) return this.supervisor.load(_, 'Class', this.data.CODCLA);
	}

	/*
	the $x3Format attribute is only set for strings. In orther cases it should be undefined
	*/
	getX3Format(_,property) { 
		return this.$x3Format = undefined;
	}

	sqlType(colData) {
		throw new Error("unsupported datatype: " + this.data.TYPTYP + " (" + typeof this.data.TYPTYP + ")");
	}

	convertIn(val) { return val;}

	toSql(val) {
		return val.x3ToSql(this.supervisor.sqlDriver);
	}

	fromSql(_, val) {
		return utilDriver.fromSql(_, val, this.data.TYPTYP, this.supervisor.sqlDriver);
	}

	toSqlQuery(val) { return val; }

	applyRule(_, rule,args) {
		rule.script = rule.script || this.supervisor.loadScript(_, rule.scriptName);
		return runtime.executeProg(_, rule.script, rule.prog, args);
	}

	toJson(_, slot , val) {  return val;};

	precisionAndScale(data = {}) {
		if (this.data.TYPTYP !== 4) return null;
		const lon = (data.LONG > 0) ? data.LONG : ((this.data.LNGTYP > 0) ? this.data.LNGTYP : undefined);
		const [int, scale] = ('' + lon).split('.').map(x => parseInt(x || '0'));
		return {
			precision: int + scale,
			scale: scale,
		};
	}

	fillNode(_, data, node) {
		if (this.atypepro === undefined) {
			var typpro = this.supervisor.load(_, 'Typepro', this.data.TYPPROSYR);
			if (!typpro) throw new Error("content type not found: " + this.data.TYPPROSYR);
			this.atypepro = {
				protyp: typpro.data.PROTYP,
				preflg: typpro.data.PREFLG,
				lisflg: typpro.data.LISFLG
			};
		}
		node.$type = this.atypepro.protyp;

		if (this.data.FMTPROSYR > 1) {
			var fmt;
			switch (this.data.FMTPROSYR) {
				case 2:
					fmt = "$email";
					break;
				case 3:
					fmt = "$phone";
					break;
				case 6:
					fmt = "TT"; // Time format hh:mm:ss
					break;
				default:
					fmt = this.supervisor.loadMess(_, 7880, this.data.FMTPROSYR);
					break;
			}
			if (fmt !== "") node.$format = fmt;

		}
		switch (this.data.TYPTYP) {
			case 2:
			case 3:
			case 4:
				var lon = (data.LONG > 0) ? data.LONG : ((this.data.LNGTYP > 0) ? this.data.LNGTYP : undefined);
				if (lon !== undefined) node.$maxLength = Math.floor(lon);

				if (this.data.TYPTYP === 4 && lon >= 0) {
					node.$precision = parseInt(lon);
					var l = ("" + Math.round(lon * 1e6) / 1e6).split('.');
					node.$scale = parseInt(l[1] || 0);
					if (node.$scale === 0) node.$format = "0";
					else {
						var zero = "0000000000000000000000000000000000000000000";
						node.$format = "0." + zero.substring(0, node.$scale);
					}
				}
				break;
			case 7:
				var lon = (this.data.LNGTYP > 0) ? this.data.LNGTYP : ((data.LONG > 0) ? data.LONG : undefined);
				if (lon !== undefined) node.$maxLength = Math.floor(lon);
				break;
		}
	}


}

//TYPTYP = 1 
class TypeJ extends Type {
	constructor(superv,data) {
		super(superv,data);
	}
	get jsType() { return "number";}

	sqlType(colData) { return this.supervisor.sqlDriver.tinyIntType();}
	toJson(_, slot , val) {  return (slot.property.data.NOLIB !== 1) ? val : (val === 2 ? true : false);}



}

//TYPTYP = 2
class TypeI2 extends Type {
	constructor(superv,data) {
		super(superv,data);
	}
	get jsType() { return "number";}
	sqlType(colData) { return this.supervisor.sqlDriver.shortIntType();}
}

//TYPTYP = 3 (translatable text (no column))
class TypeI3 extends Type {
	constructor(superv,data) {
		super(superv,data);
	}
	get jsType() { return "number";}
	sqlType(colData) { return this.supervisor.sqlDriver.intType();}
}

//TYPTYP = 4
class TypeN extends Type {
	constructor(superv,data) {
		super(superv,data);
	}
	get jsType() { return "string";}
	sqlType(colData) { return this.supervisor.sqlDriver.decimalType();}
	toJson(_, slot , val) { return val ? val.x3ToString() : 0;}
}

//TYPTYP = 6
class TypeW extends Type {
	constructor(superv,data) {
		super(superv,data);
	}
	get jsType() { return "number";}
	sqlType(colData) { return this.supervisor.sqlDriver.doubleType();}
}

//TYPTYP = 7
class TypeS extends Type {
	constructor(superv,data) {
		super(superv,data);
	}
	get jsType() { return "string";}
	sqlType(colData) { return this.supervisor.sqlDriver.stringType(this.data.LNGTYP || (colData && colData.LONG) || 1020);}
	toSqlQuery(val) { return "'" + val + "'";}

 	/*
	Let's set the $x3Format attribute for strings
	*/
	getX3Format(_,property) {
		this.$x3Format = super.getX3Format(_,property);
		if(this.$x3Format !== undefined) return this.$x3Format;

		if (this.data.FORTYP || this.data.OPTION || this.data.LNGTYP) {
			// type string : initialize $x3Format
			var x3Format = "K";
			var chfmt = this.data.FORTYP || "";
			var optsai = this.data.OPTION || "";
			var carfmt = "";
			var optfmt = "";

			var propertyLength = property.propertyLength || this.data.LNGTYP;

			if (/^=|\[+|>/.test(chfmt)) chfmt = "";

			if (/C+/.test(optsai)) carfmt = "c";
			else if (/A+/.test(optsai)) carfmt = /\#+/.test(optsai) ? "B" : "A";
			else if (/\#+/.test(optsai)) carfmt = "#";
			else carfmt = "X";

			if (/T+/.test(optsai)) optfmt += "T";
			else if (/D+/.test(optsai)) optfmt += "TD";

			if (/\*+/.test(optsai)) optfmt += "*+";
			if (/1+/.test(optsai)) optfmt += "1";
			if (/z+/.test(optsai)) optfmt += "z";

			if (/=+/.test(optsai)) optfmt += "=";
			else if (/<+/.test(optsai)) optfmt += "<";
			else if (/>+/.test(optsai)) optfmt += ">";

			if (/W+/.test(optsai)) optfmt += "W";

			if (chfmt.length && !/^=/.test(chfmt)) {
				if (optsai = "" && /X+/.test(chfmt)) x3Format = undefined;
			} else chfmt = propertyLength.toString() + carfmt;
			if (/T+/.test(optfmt) && !/TD+/.test(optfmt)) x3Format = undefined;

			this.$x3Format = x3Format ? x3Format + optfmt + ":" + chfmt : "";
			this.regex = format.fromX3FormatToRegex(this.$x3Format);
		}
		return this.$x3Format;
	}

}
//TYPTYP = 8 
class TypeD extends Type {
	constructor(superv,data) {
		super(superv,data);
	}
	get jsType() { return "date";}
	
	sqlType(colData) { return this.supervisor.sqlDriver.dateType();}
	convertIn(val) { return val ? date.fromJsDate(new Date(val)) : null};
	toSqlQuery(val) { this.supervisor.sqlDriver.sqlDate(val);}
	toJson(_, slot , val) { return val ? val.x3ToJson() : null;}
}

class TypeLob extends Type {
	constructor(superv,data) {
		super(superv,data);
	}

	mediaArgs(_,slot) {
		var instance = slot.$parent;
		var key = instance.getKey(_);
		key = (key && Array.isArray(key)) ? key.join('~') : key;
		return {
			AINSTANCE: {
				type: "LY",
				value: instance
			},
			APRONAME: {
				type: "LY",
				value: slot.name
			},
			CLE: {
				type: "LS",
				value: key
			}
		};			
	}	
	contentType(_, slot) {
		var contentType =  this.protyp ? this.protyp.data.PROTYP : "text/plain";
		if(slot !== undefined && this.rules && this.rules.READ_MEDIA_CNT) {
			var rule = this.rules.READ_MEDIA_CNT;
			var args = this.mediaArgs(_,slot);
			args.AVALCNT =  {
				type: "AS",
				value: ""
			};
			var astatus = this.applyRule(_, rule, args);
			contentType = args.AVALCNT.value;
		}
		return contentType || "";
	}
}

//TYPTYP = 9 
class TypeB extends TypeLob {
	constructor(superv,data) {
		super(superv,data);
	}
	get isBlob() { return true;}
	sqlType(colData) { return this.supervisor.sqlDriver.blobType();}
	toJson(_, slot , val) { return {};}
	get lobTable() { return "ABLOB";}
	get lobField() { return "BLOB";}
	reader(_,val)  { return this.supervisor.sqlDriver.blobReader(_,val);}
}

//TYPTYP = 10
class TypeT extends TypeLob {
	constructor(superv,data) {
		super(superv,data);
	}
	get isClob() { return true;}
	get jsType() { return "object";}
	sqlType(colData) { return this.supervisor.sqlDriver.clobType();}
	toJson(_, slot , val) { return {$contentType:this.contentType(_,slot)};}
	get lobTable() { return "ACLOB";}
	get lobField() { return "CLOB";}
	reader(_,val)  { return this.supervisor.sqlDriver.clobReader(_,val);}
}

//TYPTYP = 11 
class TypeZ extends Type {
	constructor(superv,data) {
		super(superv,data);
	}
	get jsType() { return "binary";}
	sqlType(colData) { return this.supervisor.sqlDriver.uuidType();}
	toJson(_, slot , val) { return val.x3ToString();}
}

//TYPTYP = 12
class TypeE extends Type {
	constructor(superv,data) {
		super(superv,data);
	}
	get jsType() { return "date";}
	sqlType(colData) { return this.supervisor.sqlDriver.datetimeType();}
	convertIn(val) { return val ? datetime.fromJsDate(new Date(val)) : null};
	toJson(_, slot , val) { return val.x3ToString();}
}

//TYPTYP = 13 
class TypeY extends Type {
	constructor(superv,data) {
		super(superv,data);
	}
}	

module.exports = {
	collectionName: 'ATYPE',
	keyName: 'CODTYP',
	typTyp2EtnaType: typTyp2EtnaType,
	etnaType2TypTyp: etnaType2TypTyp,
	getConstructor:function(data) {
		switch(data.TYPTYP){
			case 1: return TypeJ;
			case 2: return TypeI2;
			case 3: return TypeI3;
			case 4: return TypeN;
			case 6: return TypeW;
			case 7: return TypeS;
			case 8: return TypeD;
			case 9: return TypeB;
			case 10: return TypeT;
			case 11: return TypeZ;
			case 12: return TypeE;
			case 13: return TypeY;	
		}
		return Type;
	},
	constructor: Type,
	fillTypeNode: function(_, superv, data, node) {
		var typ = superv.load(_, 'Type', data.CODTYP);
		if (!typ) throw new Error("type not found: " + data.CODTYP);
		if (data.NOLIB === 1) {
			node.$type = 'application/x-boolean';
		}
		//Elsif len(ASHW.ASWR(I).UOMPRO)
		// #It's a unit
		//  PROTYPE =func ASYRJSO.TYP('quantity')
		else if (data.CODTYP === 'ATX') {
			node.$type = 'application/x-string';
			node.$maxLength = 30;
		} else {
			typ.fillNode(_, data, node);
		}
		if (data.NOLIB >= 2) {
			node.$value = {
				$type: 'application/x-integer',
				$enum: superv.loadEnum(_, data.NOLIB).filter(function(entry) {
					return entry.$title !== '#'; // remove bogus entries in module list
				}),
			};
		}
	}
};