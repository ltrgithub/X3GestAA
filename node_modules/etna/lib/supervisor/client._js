"use strict";

var glob = require('streamline-runtime').globals;
var ez = require("ez-streams");
var etnaServer = require("etna/lib/supervisor/server");
var check = require("syracuse-license/lib/check");

var tracerJs = require('syracuse-core').getTracer("etna.supervisor");


class Client {
	constructor(session, endpoint) {
		this.endpoint = endpoint;
		this.session = session;
	}

	init(_) {
		if(!glob.context.session.x3license && true) { // ASYRLIC.CTLLIC
			let diags = [];
			const product="1";  // TODO
			const version="10"; // TODO
			glob.context.session.x3license = check.getX3LicenseInfo(_, product, version, glob.context.session, diags);
		}
		return this;
	}

	getSessionServiceLink(_, link) {
		var config = this.endpoint.getEtnaConfig(_, this.session);

		switch (link) {
			case "$rights":
				return {
					$url: "/sdata/x3/erp/" + this.endpoint.dataset(_) + "/ARIGHTS('" + config.session.userName + "')/$services/$rights"
				};
		}
		return null;
	}
	jsonSend(_, options) {
		var config = this.endpoint.getEtnaConfig(_, this.session);
		var request = {
			url: options.head.url,
			session: config.session,
			_request: {},
			method: options.method || "GET",
			readAll: function(payload) {
				return function(_) {
					return payload;
				};
			}(options.payload || "")
		};

		request._request.headers = Object.keys(options.head).reduce(function(r, p) {
			r[p] = options.head[p];
			return r;
		}, {});

		var resp = {};
		var response = {
			writeHead: function(status, head) {
				tracerJs.debug && tracerJs.debug("STUB writeHead");
				resp.head = head;
				resp.head.status = status;
			},
			end: function(body, options) {
				tracerJs.debug && tracerJs.debug("STUB end");
				if (body.indexOf("{") === 0) resp.body = JSON.parse(body);
				else resp.body = body;
			}
		};

		etnaServer.httpDispatch(_, config, request, response);
		//console.log("JSONSEND resp:"+JSON.stringify(resp));
		return resp;
	}
	createBulkReader(_, params) {
		//dbg:console.log("etna.createBulkReader:"+JSON.stringify(params));

		var config = this.endpoint.getEtnaConfig(_, this.session);
		var request = {
			url: params.url,
			session: config.session,
			_request: {
				headers: {
					method: "GET"
				}
			}
		};

		var queue;
		var response = {
			writeHead: function(status, head) {},
			write: function(_, body, options) {
				var start = body.indexOf("{");
				if (start >= 0 && body[body.length - 1] === '}') {
					//dbg:console.log("bulk.data:"+body.substring(start));
					queue.write(_, JSON.parse(body.substring(start)));
				}
			},
			end: function(body, options) {
				//dbg:console.log("bulk.end");
				queue.write(function(err) {
					if (err) throw err;
				}, undefined);
			}
		};


		return {
			next: function(_) {
				if (!queue) {
					queue = ez.devices.queue({});
					setTimeout(function() {
						etnaServer.httpDispatch(function(err, data) {}, config, request, response);
					}, 1);
				}
				return queue.read(_);
			}
		};
	}
	disconnect(_) {
		
	}
};

exports.getClient = function(_, session, endpoint) {
	var client = new Client(session, endpoint).init(_);
	return client;
};