import { _ } from 'streamline-runtime';
import * as ez from 'ez-streams';
import * as util from '../engine/runtime/util';
import { Dict, EtnaConfig, X3Session } from '../engine/runtime/types';
import * as etnaServer from '../supervisor/server';
const tracerJs = require('syracuse-core').getTracer("etna.supervisor");

interface ClientContext {
	userName?: string;
}

interface JsonSendOptions {
	method?: string;
	head?: {
		url?: string;
		[name: string]: string;
	};
	payload: any;
}

export interface BulkReaderParams {
	url: string;
}

interface Endpoint {
	getEtnaConfig(_: _, session: X3Session): EtnaConfig;
	dataset(_: _): string;
}

class Client {
	endpoint: Endpoint;
	session: X3Session;
	context: ClientContext;

	constructor(session: X3Session, endpoint: Endpoint) {
		this.endpoint = endpoint;
		this.session = session;
		this.context = this.context || {};

	}

	getSessionServiceLink(_: _,  link: string) {
		const config = this.endpoint.getEtnaConfig(_, this.session);

		switch (link) {
			case "$rights":
				return {
					$url: "/sdata/x3/erp/" + this.endpoint.dataset(_) + "/ARIGHTS('" + config.session.userName + "')/$services/$rights"
				};
		}
		return null;
	}
	jsonSend(_: _,  options?: JsonSendOptions) {
		const config = this.endpoint.getEtnaConfig(_, this.session);
		const payload = options.payload || '';
		const request = {
			url: options.head.url,
			session: config.session,
			_request: {} as {
				headers: Dict<string>
			},
			method: options.method || "GET",
			readAll: (_: _) => payload,
		};

		request._request.headers = Object.keys(options.head).reduce((r, p) => {
			r[p] = options.head[p];
			return r;
		}, {} as Dict<string>);

		const resp: any = {};
		const response = {
			writeHead(status: number, head: any) {
				tracerJs.debug && tracerJs.debug("STUB writeHead");
				resp.head = head;
				resp.head.status = status;
			},
			end(body: any) {
				tracerJs.debug && tracerJs.debug("STUB end");
				if (body.indexOf("{") === 0) resp.body = JSON.parse(body);
				else resp.body = body;
			}
		};

		etnaServer.httpDispatch(_, config, request, response);
		//console.log("JSONSEND resp:"+JSON.stringify(resp));
		return resp;
	}
	createBulkReader(_: _,  params: BulkReaderParams) {
		//dbg:console.log("etna.createBulkReader:"+JSON.stringify(params));

		const config = this.endpoint.getEtnaConfig(_, this.session);
		const request = {
			url: params.url,
			session: config.session,
			_request: {
				headers: {
					method: "GET"
				}
			}
		};

		var queue: any; // todo: improve ez-streams.d.ts
		const response = {
			writeHead(status: number, head: any) {},
			write(_: _,  body: any) {
				const start = body.indexOf("{");

				if (start >= 0 && body[body.length - 1] === '}') {
					//dbg:console.log("bulk.data:"+body.substring(start));
					queue.write(_, JSON.parse(body.substring(start)));
				}
			},
			end(body: any) {
				//dbg:console.log("bulk.end");
				_.run(_ => queue.write(_, undefined));
			}
		};

		return {
			next(_: _) {
				if (!queue) {
					queue = ez.devices.queue.create();
					setTimeout(function () {
						_.run(_ => etnaServer.httpDispatch(_, config, request, response));
					}, 1);
				}
				return queue.read(_);
			}
		};
	}
	disconnect(_: _) {}
};

export function getClient(_: _,  session: X3Session, endpoint: Endpoint) {
	const client = new Client(session, endpoint);
	const config = endpoint.getEtnaConfig(_, session);
	client.context.userName = config.session.userName;
	return client;
};