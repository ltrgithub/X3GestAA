import { _ } from 'streamline-runtime';
import * as ez from 'ez-streams';
const glob = require('streamline/lib/globals');
import * as util from './util';
import * as types from '../engine/runtime/types';
import * as tdate from '../engine/runtime/tdate';
import * as tdatetime from '../engine/runtime/tdatetime';
import * as tuuid from '../engine/runtime/tuuid';
import * as constants from '../supervisor/constants';
import { TypeLob } from './meta/type';
import { Slot } from '../supervisor/slot';
import { Property } from './meta/property';

export class SlotLob extends Slot {
	$wasUpdated: boolean;
	_value: any;
	constructor(parent: any, property: Property) {
		super(parent, property);
		this._value = undefined;
	}

	contentType(_: _) {
		return TypeLob.promote(this.property.type).contentType(_, this);
	}

	getKeys(_: _) {
		const instance = this.$parent;
		const keyMaps = this.property.keyMaps(_);
		const keys = Object.keys(keyMaps).reduce_(_, (_, r, key) => {
			const val = keyMaps[key](_, instance);
			r[key] = val === "" ? " " : val;
			return r;
		}, util.any({}));
		//dbg:console.log("SlotLob keys:",keys);

		return keys;
	}

	insertSlot(_: _) {
		if (!this._value) return constants.CST_AOK;
		if (this.property.type.insertMedia) return this.property.type.insertMedia(_, this, this._value);
		return this.insertSlotExtended(_); //Else
	}

	updateSlot(_: _) {
		if (!this._value) return constants.CST_AOK;
		if (this.property.type.updateMedia) return this.property.type.updateMedia(_, this, this._value);
		return this.updateSlotExtended(_); //Else
	}

	deleteSlot(_: _) {
		if (!this._value) return constants.CST_AOK;
		if (this.property.type.deleteMedia) return this.property.type.deleteMedia(_, this, this._value);
		return this.deleteSlotExtended(_); //Else
	}

	readRecord(_: _,  lobTable: string, lobField: string) {
		if (this.property.data.LOBTAB !== lobTable) return;
		const keys = this.getKeys(_);

		var i = 0;
		const param = this.$parent.supervisor.sqlDriver.param;
		const rs = this.$parent.supervisor.sqlReader(_, "select " + lobField + "_0 From " + lobTable + " Where " + Object.keys(keys).map(p => p + '_0=' + param(i++)).join(' and '), Object.keys(keys).map(p => keys[p])).toArray(_);

		return rs.length ? this.property.type.fromSql(_, rs[0][lobField]) : undefined;
	}

	updateRecord(_: _,  lobTable: string, lobField: string, record: any, reader: (val: any) => ez.Reader<any>) {
		const actx = glob.context.x3session.actx;
		const driver = this.$parent.supervisor.sqlDriver;
		const param = driver.param;

		record[lobField] = this._value;
		record.CREUSR = actx.$USER(_);
		record.CREDAT = tdate.today();
		record.UPDUSR = actx.$USER(_);
		record.CREDATTIM = tdatetime.now();
		record.UPDDATTIM = tdatetime.now();
		record.AUUID = tuuid.generate();

		const executeSql = (_: _, sql: string, i: number, values: any[]) => {
			const name = param(i++);

			sql += " returning " + lobField + "_0 into " + name;
			const result = this.$parent.supervisor.executeSql(_, sql, values, {
				outputVars: [{
					name: name.substring(1),
					type: this.property.type.sqlType()
				}]
			});
			//dbg:console.log("executeSql result:",result);

			if (result.updateCount) {
				//dbg:console.log("executeSql pipe:",result.outputVars[0]);
				reader(this._value.value).pipe(_, result.outputVars[0]);
			}
			return result;
		};
		// Does the lob exist ?

		var i = 0;
		const lobPlaceholder = driver.lobPlaceholder(this.property.type.sqlType());
		const columns = Object.keys(record);
		const columns2 = columns.filter(k => k !== lobField);
		const rs = this.$parent.supervisor.sqlReader(_, "select " + columns2.map(p => p + '_0').join(',') + " From " + lobTable + " Where " + columns2.slice(0, 4).map(p => p + '_0=' + param(i++)).join(" and "), columns2.slice(0, 4).map(p => record[p])).toArray(_);

		var sql: string;
		if (!rs.length) {
			i = 0;
			sql = "insert into " + lobTable + " (" + columns.map(p => p + '_0').join(',') + ") values (" + columns.map(p => p === lobField ? lobPlaceholder : param(i++)).join(',') + ")";
			return executeSql(_, sql, i, columns2.map(p => record[p]));
		}
		columns2.forEach(p => {
			if (rs[0][p]) record[p] = rs[0][p];
		});
		record.UPDUSR = actx.$USER(_);
		record.UPDDATTIM = tdatetime.now();

		// Update record with data stored in the database :
		i = 0;
		var values = columns2.slice(4).map(p => record[p]);
		values = values.concat(columns.slice(0, 4).map(p => record[p]));

		sql = "update " + lobTable + " SET " + columns.slice(4).map(p => p + '_0=' + (p === lobField ? lobPlaceholder : param(i++))).join(',') + " where " + columns.slice(0, 4).map(p => p + '_0=' + param(i++)).join(" and ");

		return executeSql(_, sql, i, values);
	}

	insertSlotExtended(_: _): any {
		throw new Error('invalid call: abstract method');
	}
	updateSlotExtended(_: _): any {
		throw new Error('invalid call: abstract method');
	}
	deleteSlotExtended(_: _): any {
		throw new Error('invalid call: abstract method');
	}

}

export function newSlotLob(property: Property) {
	return ((parent: any) => new SlotLob(parent, property));
}
