"use strict";

require('harmony-reflect'); // to get ES6 Proxy API
const ez = require('ez-streams');
const ezmongo = require('ez-mongodb');
const instanceProxy = require('etna/lib/supervisor/proxies/instanceProxy');

function camelize(name, capitalize) {
	name = name.split('(')[0]; // discard parenthesized part
	return name.split(/[\W]/).map(function(s, i) {
		if (i === 0 && !capitalize) return s.toLowerCase();
		else if (s) return s[0].toUpperCase() + s.substring(1).toLowerCase();
		else return '';
	}).join('');
}

function fixNames(_, supervisor, colnName, codeProp, titleProp, capitalize, relations) {
	const coln = supervisor.mongoStore.collection(colnName, _);

	ezmongo.reader(coln.find({
		_proxyName: {
			$exists: false
		}
	})).map(function(_, elt) {
		const title = supervisor.loadText(_, elt[titleProp], "ENG") || elt[codeProp];
		var name = camelize(title, capitalize);
		const existing = ezmongo.reader(coln.find({
			_proxyName: name,
		})).toArray(_)[0];
		if (existing) {
			console.error("DUPLICATE PROXY NAME: " + name + ": " + existing[codeProp] + " and " + elt[codeProp]);
			name = elt[codeProp];
		}
		console.error("PROXY NAME: " + colnName + "/" + elt[codeProp] + ": " + name);
		elt._proxyName = name;
		relations.forEach_(_, function(_, rel) {
			if (!elt[rel.name]) return;
			var subNames = {};
			console.error("RELATION", rel.name, elt[rel.name]);
			elt[rel.name].forEach_(_, function(_, sub) {
				const subTitle = supervisor.loadText(_, sub[rel.title], "ENG") || sub[rel.code];
				var subName = camelize(subTitle);
				if (subNames[subName]) {
					console.error("DUPLICATE PROPERTY NAME: " + subName + ": " + subNames[subName] + " and " + sub[rel.code]);
					subName = sub[rel.code];
				} else {
					subNames[subName] = sub[rel.code];
				}
				sub._proxyName = subName;
			});
		});
		return elt;
	}).pipe(_, ezmongo.writer(coln, {
		upsert: true
	}));
}

class ClassWrapper {
	constructor(clas) {
		this.class = clas;
	}
	create(_, values) {
		console.error("CREATING " + this.class.name);
		var instance = this.class.supervisor.new(_, 'Instance', this.class).afterCreate(_);
		var proxy = instanceProxy(instance);
		Object.keys(values).forEach_(_, function(_, name) {
			proxy[name](_, values[name]);
		});
		return proxy;
	}
	query(_) {
		return this.class.queryInstances(_).map((_, instance) => instanceProxy(instance));
	}
}

class ClassesHandler {
	constructor(supervisor) {
		this.supervisor = supervisor;
		this.getters = {};
	}
	get(name) {
		const self = this;
		return self.getters[name] ||
			function(_) {
				var filter = /^[A-Z_]*$/.test(name) ? { CODCLA: name } : { _proxyName: name };
				const clas = self.supervisor.mongoStore.collection("ACLASSE", _).find(filter).toArray(_)[0];
				if (!clas) throw new Error("class not found: " + name);
				var wrapper = new ClassWrapper(self.supervisor.load(_, 'Class', clas.CODCLA));
				// create fast getter
				self.getters[name] = function(_) {
					return wrapper;
				};
				return wrapper;
		};
	}
}

class SaveError extends Error {
	constructor(message, errors) {
		super(message);
		this.errors = errors;
	}
}

class Dataset {
	constructor(supervisor) {
		this.supervisor = supervisor;
		this.classes = Proxy(supervisor, {
			get: function(supervisor, name) {
				//console.error("PROXY GET", name);
				supervisor.classesHandler = supervisor.classesHandler || new ClassesHandler(supervisor);
				return supervisor.classesHandler.get(name);
			},
		});
	}
	init(_) {
		fixNames(_, this.supervisor, "ACLASSE", "CODCLA", "INTCLA", true, [{
			name: "PROPERTIES",
			code: "FLDCLA",
			title: "INTFLD"
		}]);
		return this;
	}
	save(_, instance) {
		var inst = instance.$instance;
		if (inst.$uuid) inst.update(_);
		else inst.insert(_);
		var errors = inst.diagnoses.filter((diag) => diag.severity === 'error');
		if (errors.length > 0) throw new SaveError("save failed: " + errors.length + " errors", errors);
	}
}

exports.create = function(_, supervisor) {
	return new Dataset(supervisor).init(_);
};