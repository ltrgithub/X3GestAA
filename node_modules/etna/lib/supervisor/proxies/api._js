"use strict";

(function() {
	if (typeof Proxy === 'undefined') {
		console.warn("!!! Proxy undefined -- JS API NOT AVAILABLE !!!");
		exports.create = function(_, supervisor) { return null; };
		return;
	}
	require('harmony-reflect'); // to get ES6 Proxy API
	const ez = require('ez-streams');
	const ezmongo = require('ez-mongodb');

	function camelize(name, capitalize) {
		name = name.split('(')[0]; // discard parenthesized part
		return name.split(/[\W]/).map(function(s, i) {
			if (i === 0 && !capitalize) return s.toLowerCase();
			else if (s) return s[0].toUpperCase() + s.substring(1).toLowerCase();
			else return '';
		}).join('');
	}

	function fixNames(_, supervisor, colnName, codeProp, titleProp, capitalize, relations) {
		const coln = supervisor.mongoStore.collection(colnName, _);

		ezmongo.reader(coln.find({
			_proxyName: {
				$exists: false
			}
		})).map(function(_, elt) {
			const title = supervisor.loadText(_, elt[titleProp], "ENG") || elt[codeProp];
			var name = camelize(title, capitalize);
			const existing = ezmongo.reader(coln.find({
				_proxyName: name,
			})).toArray(_)[0];
			if (existing) {
				console.error("DUPLICATE PROXY NAME: " + name + ": " + existing[codeProp] + " and " + elt[codeProp]);
				name = elt[codeProp];
			}
			console.error("PROXY NAME: " + colnName + "/" + elt[codeProp] + ": " + name);
			elt._proxyName = name;
			relations.forEach_(_, function(_, rel) {
				if (!elt[rel.name]) return;
				var subNames = {};
				console.error("RELATION", rel.name, elt[rel.name]);
				elt[rel.name].forEach_(_, function(_, sub) {
					const subTitle = supervisor.loadText(_, sub[rel.title], "ENG") || sub[rel.code];
					var subName = camelize(subTitle);
					if (subNames[subName]) {
						console.error("DUPLICATE PROPERTY NAME: " + subName + ": " + subNames[subName] + " and " + sub[rel.code]);
						subName = sub[rel.code];
					} else {
						subNames[subName] = sub[rel.code];
					}
					sub._proxyName = subName;
				});
			});
			return elt;
		}).pipe(_, ezmongo.writer(coln, {
			upsert: true
		}));
	}

	class SaveError extends Error {
		constructor(message, errors) {
			super(message);
			this.errors = errors;
		}
	}

	class Api {
		constructor(supervisor) {
			this.supervisor = supervisor;
			this.classes = require('./classProxy').create(supervisor);
		}
		init(_) {
			fixNames(_, this.supervisor, "ACLASSE", "CODCLA", "INTCLA", true, [{
				name: "PROPERTIES",
				code: "FLDCLA",
				title: "INTFLD"
			}]);
			return this;
		}
		save(_, instance) {
			var inst = instance.$instance;
			if (inst.$uuid) inst.update(_);
			else inst.insert(_);
			var errors = inst.diagnoses.filter((diag) => diag.severity === 'error');
			if (errors.length > 0) throw new SaveError("save failed: " + errors.length + " errors", errors);
		}
	}

	exports.create = function(_, supervisor) {
		return new Api(supervisor).init(_);
	};

	exports.jsInvoke = require('./jsInvoke');
})();