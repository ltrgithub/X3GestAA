"use strict";

const util = require('etna/lib/supervisor/util');
const classModule = require('etna/lib/supervisor/meta/class');

const sysProperties = classModule.systemProperties.reduce(function(names, prop) {
	names[prop.FLDCLA] = prop;
	return names;
}, {});

class ClassHandler {
	constructor(clas) {
		const self = this;
		this.class = clas;
		this.accessors = Object.keys(this.class.properties).reduce(function(accessors, key) {
			if (!sysProperties[key]) {
				const prop = self.class.properties[key];
				console.error("ACCESSOR", prop.proxyName);
				accessors[prop.proxyName] = function(_, val) {
					var instance = this;
					if (arguments.length === 2) {
						if (val && val.$instance) val = val.$instance;
						console.error("BEFORE SET", key, val, util.isInstance(instance));
						instance.set(_, key, val);
						console.error("AFTER SET", key, val);
					} else {
						val = instance.get(_, key);
						if (util.isInstance(val)) val = instanceProxy(val);
						return val;
					}
				};
			}
			return accessors;
		}, {});
	}
	get(name) {
		const accessor = this.accessors[name];
		if (!accessor) throw new Error("accessor not found: " + this.class.name + "." + name);
		return accessor;
	}
	ownKeys() {
		const self = this;
		return self.proxyKeys || (self.proxyKeys = Object.keys(this.class.properties) //
			.filter((code) => !sysProperties[code])
			.map((code) => self.class.properties[code].proxyName));
	}
}

function instanceProxy(instance) {
	return Proxy(instance, {
		get: function(instance, name) {
			if (name === '$instance') return instance;
			instance.meta.handler = instance.meta.handler || new ClassHandler(instance.meta);
			return instance.meta.handler.get(name).bind(instance);
		},
		ownKeys: function(instance) {
			instance.meta.handler = instance.meta.handler || new ClassHandler(instance.meta);
			return instance.meta.handler.ownKeys();

		}
	});
}

module.exports = instanceProxy;