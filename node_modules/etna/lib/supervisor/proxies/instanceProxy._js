"use strict";

require('harmony-reflect'); // to get ES6 Proxy API
const glob = require('streamline-runtime').globals;
const runtime = require('etna/lib/engine/runtime/runtime');
const util = require('etna/lib/supervisor/util');
const classModule = require('etna/lib/supervisor/meta/class');

const instructions = {
	TRBEGIN: runtime.instructions.TRBEGIN(),
	COMMIT: runtime.instructions.COMMIT(),
	ROLLBACK: runtime.instructions.ROLLBACK(),
}


class Invoker {
	constructor(instance) {
		this.instance = instance;
	}
	get $classes() {
		return this.instance.supervisor.api.classes;
	}
	get $tables() {
		return this.instance.supervisor.api.tables;
	}
	$cache(_, jsClassName, key, jsPropName) {
		// load class by js name to get its 4GL name
		var clas = this.instance.supervisor.loadClassByJsName(_, jsClassName);
		if (!clas) throw new Error('cache class not found: ' + jsClassName);
		// lookup prop by js name to get its 4GL name
		var prop = clas.membersByJsName[jsPropName];
		if (!prop) throw new Error('cache property not found: ' + jsClassName + '.' + jsPropName);

		var acache = glob.context.x3session.actx.get(_, 'ACACHE');
		var cl = acache.get(_, clas.name);
		//console.error("CACHE LOOKUP", clas.name, key, prop.name);
		return cl.AGETVALNUM(_, key, prop.name);
	}
	$error(_, text) {
		this.instance.ASETERROR(_, this.args.CURPTH, text, 4); // CST_AERROR == 4
		// todo: set astatus
	}
	// following API are not tied to THIS. Move to helper?
	$message(_, id, chapter, swtch) {
		return runtime.functions.MESS.fn(_, id, chapter, swtch);
	}
	$withTransaction(_, body) {
		instructions.TRBEGIN(_);
		try {
			body(_);
			instructions.COMMIT(_);
		} catch (ex) {
			instructions.ROLLBACK(_);
			throw ex;
		}
	}
	$user(_) {
		return glob.context.x3session.actx.$USER(_);
	}
};

const sysProperties = classModule.systemProperties.reduce(function(names, prop) {
	names[prop.FLDCLA] = prop;
	return names;
}, {});

function path(instance, prop) {
	if (instance.APARENT) return path(instance.APARENT, instance.proName + '.' + prop);
	else return prop;
}

class PropertyHandler {
	constructor(instance, key) {
		this.instance = instance;
		this.key = key;
	}
	get(_) {
		var val = this.instance.get(_, this.key);
		if (util.isInstance(val)) val = instanceProxy(val);
		return val;
	}
	set(_, val) {
		if (val && val.$instance) val = val.$instance;
		this.instance.set(_, this.key, val);
	}
	$error(_, text) {
		this.instance.ASETERROR(_, path(this.instance, this.key), text, 4); // CST_AERROR == 4
		// todo: set astatus
	}
}

class ClassHandler {
	constructor(clas) {
		const self = this;
		this.class = clas;
	}
	get(instance, name) {
		const prop = this.class.membersByJsName[name];
		if (!prop) console.error(name, Object.keys(this.class.membersByJsName));
		if (!prop) throw new Error("accessor not found: " + this.class.name + "." + name);
		return new PropertyHandler(instance, prop.name);
	}
	ownKeys() {
		const self = this;
		return self.proxyKeys || (self.proxyKeys = Object.keys(this.class.properties) //
			.filter((code) => !sysProperties[code])
			.map((code) => self.class.properties[code].jsName));
	}
}

function instanceProxy(instance) {
	if (!instance) return null;
	return Proxy(instance, {
		get: function(instance, name) {
			//console.error("INSTANCE GET", name);
			if (name[0] === '$') {
				if (name === '$instance') return instance;
				if (name === '$snapshot') return instanceProxy(instance.snapshot());
				var invoker = new Invoker(instance);
				var member = invoker[name];
				if (!member) throw new Error("invalid member: " + name);
				return typeof member === 'function' ? member.bind(invoker) : member;
			}
			// TODO: hook up sys members
			instance.meta.handler = instance.meta.handler || new ClassHandler(instance.meta);
			return instance.meta.handler.get(instance, name);
		},
		ownKeys: function(instance) {
			instance.meta.handler = instance.meta.handler || new ClassHandler(instance.meta);
			return instance.meta.handler.ownKeys();

		}
	});
}

module.exports = instanceProxy;