import { _ } from 'streamline-runtime';
import { X3Error } from '../engine/runtime/errors';
import * as util from '../supervisor/util';
import * as variables from '../engine/runtime/variables';
import * as constants from '../supervisor/constants';

export const extAttributesMeta: any = {
	$isReadOnly: false,
	$isHidden: false,
	$isDisabled: false,
	$isMandatory: false,
	$symbol: "",
	$label: "",
	$style: "",
	$index: 0,
	$scale: 0,
	$precision: 0
};
export const extAttributesObject: any = {
	$isLoaded: false,
	$contentType: "",
	$filename: ""
};
// External attributes
// build by merging extAttributesMeta and extAttributesObject

export const extAttributes = Object.keys(extAttributesObject).reduce((r, name) => {
	r[name] = extAttributesObject[name];
	return r;
}, Object.keys(extAttributesMeta).reduce((r, name) => {
	r[name] = extAttributesMeta[name];
	return r;
}, util.any({})));

// Upper casse name of externale attributes

const uExtAttributes = Object.keys(extAttributes).reduce((r, name) => {
	r[name.toUpperCase()] = name;
	return r;
}, util.any({}));

// Internal attributes

// this one is hacked so we have to type it as any
const intAttributes: any = {
	$_isReadOnly: false,
	$isLobFound: false,
	$isRequested: false,
	$isEditMode: false,
	$isExcluded: false,
	$isDeleted: false,
	$lazyLoading: false,
	$_rightAccess: false,
	$isSnapshotEnabled: false,
	$isSyssnapshotEnabled: false,
	$wasRead: false,
	$wasUpdated: false,
	$x3Format: "",
	$acceptedTypes: ""
};
const inheritedAttributes = ["$isReadOnly", "$isHidden", "$isExcluded", "$isDisabled", "$isSnapshotEnabled", "$isSyssnapshotEnabled"];
const resAttributes: any = {
	$title: "",
	$description: ""
};
const attNames = util.any({});

var position = 0;

[extAttributes, intAttributes].forEach(attributes => {
	Object.keys(attributes).forEach(key => {
		attNames[position] = key;
		const mask = 1 << position;
		const def = attributes[key];
		const attType = typeof attributes[key];

		if (attType === "boolean") {
			attributes[key] = {
				position: position,
				get(data: Attributes) {
					if (!(data._fUsed & mask)) {
						if (!def) data._fAttributes &= ~mask; // clear the bit
						else data._fAttributes |= mask; // set the bit
						data._fUsed |= mask; // bit used
					}
					return !!(data._fAttributes & mask);
				},
				set(data: Attributes, value: any) {
					if (!value) data._fAttributes &= ~mask; // clear the bit
					else data._fAttributes |= mask; // set the bit
					data._fUsed |= mask; // bit used
					return value;
				},
			};
		} else {
			attributes[key] = {
				position: position,
				get(data: Attributes) {
					if (!(data._fUsed & mask)) {
						data._attributes[key] = def;
						data._fUsed |= mask; // bit used
					}
					return data._attributes[key];
				},
				set(data: Attributes, value: any) {
					data._attributes[key] = value;
					data._fUsed |= mask; // bit used
					return true;
				},
			};
		}
		attributes[key].attType = attType;
		position++;
	});
});

Object.keys(resAttributes).forEach(key => {
	attNames[position] = key;
	const mask = 1 << position;
	const def = resAttributes[key];

	resAttributes[key] = {
		position: position,
		get(_: _,  data: Attributes, lan: string) {
			if (!(data._fUsed & mask) || lan) {
				// reload if lan is defined
				data._attributes[key] = data._resources && data._resources[key] && data._resources[key](_, lan) || def;
				data._fUsed |= mask; // bit used
			}
			return data._attributes[key];
		},
		set(_: _,  data: Attributes, value: any, lan: string) {
			data._attributes[key] = value;
			data._fUsed |= mask; // bit used
			return value;
		},
	};
	position++;
});

export interface AttributesHolder {
	$attributes: Attributes;
	$isSnapshotEnabled: boolean;
	$isSyssnapshotEnabled: boolean;
}

export function clone(src: AttributesHolder, dst: AttributesHolder) {
	dst.$attributes._fUsed = src.$attributes._fUsed;
	dst.$attributes._fAttributes = src.$attributes._fAttributes;
	typeof src.$attributes._attributes === 'object' && src.$attributes._attributes && Object.keys(src.$attributes._attributes).map(name => {
		dst.$attributes._attributes[name] = src.$attributes._attributes[name];
	});

	typeof src.$attributes._resources === 'object' && src.$attributes._resources && Object.keys(src.$attributes._resources).map(name => {
		dst.$attributes._resources[name] = src.$attributes._resources[name];
	});
}

export function revertTo(src: AttributesHolder, dst: AttributesHolder) {
	// clean attributes :
	dst.$attributes._fUsed = 0;
	dst.$attributes._fAttributes = 0;
	dst.$attributes._attributes = src.$attributes._attributes ? {} : null;
	dst.$attributes._resources = src.$attributes._resources ? {} : null;
	// clone attributes :
	clone(src, dst);
	// except :
	dst.$isSnapshotEnabled = false;
	dst.$isSyssnapshotEnabled = false;
}

type Resource = any; // refine later

export class Attributes {
	_fUsed: number;
	_fAttributes: number;
	_attributes: any;
	_resources: any;
	constructor() {
		this._fUsed = 0;
		this._fAttributes = 0;
		this._attributes = {};
		this._resources = {};
		return this;
	}
	setResources(resources: any) {
		this._resources = resources;
	}
	setAttribute($attribute: string, value: any): any {
		var attribute = $attribute;

		if (extAttributes[attribute]) {
			if (attribute === "$isReadOnly" && intAttributes.$_isReadOnly.get(this) === true) {
				return extAttributes[attribute].get(this);
			}
			return extAttributes[attribute].set(this, value);
		}
		// second chance for casse issue:
		attribute = uExtAttributes[attribute.toUpperCase()];

		if (attribute !== undefined) {
			return this.setAttribute(attribute, value);
		}
		throw new X3Error(147, "unknown attribute " + $attribute);
	}
	getAttribute(attribute: string) {
		// direct access if the casse of the attribute is correct :
		if (extAttributes[attribute]) return extAttributes[attribute].get(this);
		// second chance :
		attribute = uExtAttributes[attribute.toUpperCase()];

		if (extAttributes[attribute]) return extAttributes[attribute].get(this);
		throw new X3Error(50, "unknown attribute " + attribute);
	}
	setIntAttribute(attribute: string, value: any) {
		if (intAttributes[attribute]) return intAttributes[attribute].set(this, value);
	}
	getIntAttribute(attribute: string) {
		if (intAttributes[attribute]) return intAttributes[attribute].get(this);
	}
	setResource(_: _,  resource: Resource, value: any, lan: string) {
		if (resAttributes[resource]) return resAttributes[resource].set(_, this, value, lan);
	}
	getResource(_: _,  resource: Resource, lan: string) {
		if (resAttributes[resource]) return resAttributes[resource].get(_, this, lan);
	}

	// getAttributes doesn't expose internal attributes :
	getAttributes(_: _) {
		const result: any = {};

		var fUsed = this._fUsed;
		var position = 0;
		while (fUsed) {
			if (fUsed & 1) {
				var name = attNames[position];
				if (extAttributes[name]) result[name] = extAttributes[name].get(this);
				else if (resAttributes[name]) result[name] = resAttributes[name].get(_, this);
			}
			fUsed = fUsed >> 1;
			position++;
		}
		return result;
	}

	getDeltaAttributes(_: _,  from: Attributes) {
		const result: any = {};

		var fThisUsed = this._fUsed;
		var fFromUsed = from._fUsed;
		var position = 0;
		while (fThisUsed) {
			if (fThisUsed & 1) {
				var name = attNames[position];
				if ((fFromUsed & 1) === 0) {
					// The attribute wasn't set in from :
					if (extAttributes[name]) result[name] = extAttributes[name].get(this);
					else if (resAttributes[name]) result[name] = resAttributes[name].get(_, this);
				} else {
					// Compare values :
					if (extAttributes[name]) {
						var value = extAttributes[name].get(this);
						if (extAttributes[name].get(from) !== value) result[name] = value;
					} else if (resAttributes[name]) {
						var value = resAttributes[name].get(_, this);
						if (resAttributes[name].get(_, from) !== value) result[name] = value;
					}
				}
			}
			// Shift flags:
			fThisUsed = fThisUsed >> 1;
			fFromUsed = fFromUsed >> 1;
			position++;
		}
		return result;
	}
}

type Prototype = any; // refine later

export function addIntAttributes(_prototype: Prototype) {
	Object.defineProperty(_prototype, "$attributes", {
		get() {
			this.$$attributes = this.$$attributes || new Attributes();
			return this.$$attributes;
		},
		enumerable: false
	});

	_prototype.bindAttributes = function (parent: any, resources: any) {
		this.$parent = parent;
		this.$$attributes = undefined;
		if (resources) this.$attributes.setResources(resources);

		this.initColAttributes && this.initColAttributes();
	};

	_prototype.setAttribute = function (attribute: string, value: any) {
		return variables.x3Val(this.$attributes.setAttribute(attribute, value));
	};

	_prototype.ASETATTR = function (attribute: string, value: any) {
		try {
			return this.setAttribute(attribute, value);
		} catch (ex) {
			return constants.CST_AERROR;
		}
	};

	_prototype.getAttribute = function (attribute: string, $name: string) {
		// Let's try the first level
		var value = this.$attributes.getAttribute(attribute);

		if (!value && inheritedAttributes.indexOf(attribute) >= 0) {
			var name = $name || this.name;
			//dbg:console.log("\tname:"+name);
			if (name && this.$colAttributes && this.$colAttributes[name]) {
				//dbg:console.log("\tgetAttribute "+attribute+" 2");
				value = this.$colAttributes[name].getAttribute(attribute);
			}
			if (!value && this.$parent) {
				// Value can be equal to false!
				//dbg:console.log("\tgetAttribute "+attribute+" 3 name:"+name);
				value = this.$parent.getAttribute(attribute, name);
			}
		}
		return value;
	};

	_prototype.setResources = function (resources: any) {
		return this.$attributes.setResources(resources);
	};

	_prototype.getAttributes = function (_: _) {
		return this.$attributes.getAttributes(_);
	};
	_prototype.getDeltaAttributes = function (_: _,  from: AttributesHolder) {
		return this.$attributes.getDeltaAttributes(_, from.$attributes);
	};

	_prototype.setIntAttribute = function (attribute: string, value: any) {
		return this.$attributes.setIntAttribute(attribute, value);
	};

	_prototype.getIntAttribute = function (attribute: string) {
		var value = this.$attributes.getIntAttribute(attribute);
		if (!value && this.$parent && inheritedAttributes.indexOf(attribute) >= 0) {
			value = this.$parent.getIntAttribute(attribute);
		}
		return value;
	};

	Object.keys(intAttributes).forEach(attribute => {
		Object.defineProperty(_prototype, attribute, {
			set(value) {
				return this.setIntAttribute(attribute, value);
			},
			get() {
				return this.getIntAttribute(attribute);
			},
			enumerable: false
		});
	});
}

export function addExtAttributes(_prototype: Prototype) {
	Object.keys(extAttributes).forEach(attribute => {
		Object.defineProperty(_prototype, attribute, {
			set(value) {
				return this.setAttribute(attribute, value);
			},
			get() {
				return this.getAttribute(attribute);
			},
			enumerable: false
		});
	});
}

export function addResources(_prototype: Prototype) {
	Object.keys(resAttributes).forEach(resource => {
		_prototype["set" + resource] = function (_: _,  value: any, lan: string) {
			this.$attributes.setResource(_, resource, value, lan);
		};
		_prototype["get" + resource] = function (_: _,  lan: string) {
			return this.$attributes.getResource(_, resource, lan);
		};
	});
}

export function addColAttributes(_prototype: Prototype) {
	_prototype.initColAttributes = function () {
		this.$colAttributes = [];
	};
	_prototype.setColAttribute = function (column: string, attribute: string, value: any) {
		if (this.$colAttributes[column] === undefined) {
			this.$colAttributes[column] = new Attributes();
		}
		return this.$colAttributes[column].setAttribute(attribute, value);
	};

	_prototype.getColAttribute = function (column: string, attribute: string) {
		if (this.$colAttributes[column] === undefined) {
			this.$colAttributes[column] = new Attributes();
		}
		var value = this.$colAttributes[column].getAttribute(attribute);
		if (!value && inheritedAttributes.indexOf(attribute) >= 0) {
			value = this.getAttribute(attribute);
		}
		return value;
	};
}

export function addAttributes(_prototype: Prototype) {
	addIntAttributes(_prototype);
	addExtAttributes(_prototype);
	addResources(_prototype);
}

export function isAttributeBoolean($attribute: string) {
	var attribute = $attribute;
	// direct access if the casse of the attribute is correct :
	if (extAttributes[attribute]) return extAttributes[attribute].attType === "boolean";
	if (intAttributes[attribute]) return intAttributes[attribute].attType === "boolean";
	// second chance :
	attribute = uExtAttributes[attribute.toUpperCase()];

	if (extAttributes[attribute]) return extAttributes[attribute].attType === "boolean";
	return false;
}

export function isAttributeNumber($attribute: string) {
	var attribute = $attribute;
	// direct access if the casse of the attribute is correct :
	if (extAttributes[attribute]) return extAttributes[attribute].attType === "number";
	if (intAttributes[attribute]) return intAttributes[attribute].attType === "number";
	// second chance :
	attribute = uExtAttributes[attribute.toUpperCase()];

	if (extAttributes[attribute]) return extAttributes[attribute].attType === "number";
	return false;
}
