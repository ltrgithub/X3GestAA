import { _ } from 'streamline-runtime';

const glob = require('streamline/lib/globals');
import { X3Error } from '../engine/runtime/errors';
import * as format from '../engine/runtime/format';
import * as util from '../engine/runtime/util';
import * as constants from '../supervisor/constants';
import * as attributes from '../supervisor/attributes';
import { Diagnosis, trace } from './meta/diagnosis';
import { Property } from './meta/property';
const tracerSup = require('syracuse-core').getTracer("etna.supervisor");

export class Slot {
	initialized: boolean;
	property: Property;
	parent: any; // refine later
	_value: any;
	diagnoses: Diagnosis[];
	$parent: any; // refine later
	_getCalls: number;
	getAttribute: (name: string) => any;
	setAttribute: (name: string, value: any) => any;
	getAtextra: (_: _, lan: string) => string;
	setAtextra: (_: _, text: string, lan: string) => string;
	getColAttribute: (column: string, attribute: string) => void;
	setColumnAttribute: (column: string, attribute: string, value: any) => void;
	collection: any; // refine later
	constructor(parent: any, property: Property) {
		// care of the name if and only if the property belongs to
		// an instance which which belongs to a collection :
		if (property && property.type) {
			this.property = property;
			this._value = this.property.type.defaultValue;
		} else {
			this.property = {
				name: ""
			};
			this._value = property;
		}
		this.bindAttributes(parent);
	}
	initFromParent(_: _, parent: any) {
		// abstract placeholder
	}
	get name() {
		return this.property.name;
	}

	get jsName() {
		return this.property.jsName;
	}

	get column() {
		return this.property.column ? this.property.column.name : undefined;
	}

	set value(value: any) {
		if (!this.getAttribute("$isReadOnly")) this._value = value;
		else throw new X3Error(147, (this.name ? this.name : '') + "is readonly");
	}
	get value() {
		return this._value;
	}

	get isUndefined() {
		return this._value === undefined || this._value.x3IsUndefined && this._value.x3IsUndefined();
	}

	get type() {
		return this.property.type;
	}

	get isClob() {
		return this.property.type.isClob;
	}

	get isBlob() {
		return this.property.type.isBlob;
	}

	get isLob() {
		return this.property.type.isLob;
	}

	deleteDiagnoses(_: _) {
		this.diagnoses = undefined;
	}

	getDiagnoses(_: _) {
		if (this.diagnoses) {
			return this.diagnoses.map_(_, (_, d) => {
				d.set(_, "PRO", this.name);
				d.set(_, "LAB", this.getLabel(_));
				return d;
			});
		} else return [];
	}

	addDiagnose(_: _, severity: number, message: string, category?: string) {
		trace(severity, this.name + " :'" + message + "'");
		this.diagnoses = this.diagnoses || [];
		this.diagnoses.push(this.$parent.supervisor.new(_, 'Diagnosis', severity, message, "", category));
		return severity;
	}

	getLabel(_: _) {
		return this.property.data.INTFLD ? this.property.supervisor.loadText(_, this.property.data.INTFLD) : "";
	}

	controlFormat(_: _) {
		var isFormatInvalid = false;

		if (this.property.regex) {
			isFormatInvalid = !this.property.regex.test(this._value);
			//dbg:console.log("'"+this._value+"' format:"+this.$x3Format+ " isFormatInvalid:"+isFormatInvalid);
		} else if (this.property.type.data.TYPTYP === 1 && this.property.data.NOLIB) {
				// local menu
				var menu = this.$parent.supervisor.loadEnum(_, this.property.data.NOLIB);
				//isFormatInvalid = menu && menu.length && (this._value < menu[0].$value || this._value > menu[menu.length - 1].$value);
				isFormatInvalid = menu && menu.length && (this._value < 0 || this._value > menu[menu.length - 1].$value);
			}
		if (isFormatInvalid) return this.addDiagnose(_, constants.CST_AERROR, this.$parent.supervisor.loadMess(_, 100, 149));

		return constants.CST_AOK;
	}

	controlOthers(_: _) {
		return constants.CST_AOK;
	}

	get(_: _, raw?: boolean) {
		// Call the GET accessor if and only if is set in the dictionary
		if (!raw && this.property.data && this.property.data.FLGACCGET === 2) {
			//  Add a _getCalls member if and only if the GET event has to be supported
			this._getCalls = (this._getCalls || 0) + 1;
			//dbg:console.error("DBG property " + this.name + " GET -> this._getCalls:" + this._getCalls);
			if (this._getCalls === 1) this.$parent.propertyGetValue(_, this);
			this._getCalls -= 1;
		}
		//dbg:console.error("DBG property " + this.name + " GET = " + this._value + " (" + typeof this._value + "):"+this._value);
		return this._value;
	}

	getSql(_: _) {
		//dbg:console.log("getSql:"+this.property.name);
		return this.get(_, true);
	}

	oldValue(_: _) {
		return this._value !== undefined ? this._value : this.property.type.defaultValue;
	}

	set(_: _, value: any, raw?: boolean) {
		//dbg:console.error("property " + this.name + " SET -> (type: " + this.property.type.etnaType+ "):"+value);
		if (this.getAttribute("$isReadOnly")) {
			throw new X3Error(147, (this.name ? this.name : '') + " is readonly");
		}
		// get the current value
		var oldValue;
		if (!raw) oldValue = {
				type: "L" + this.property.type.etnaType,
				value: this.oldValue(_)
			};

		if (value === undefined || value === null) {
			// undefined = RAZ of the property !
			// null = value set by the delta:
			raw = true;
			value = this.property.type.defaultValue;
		}

		this._value = this.property.set(value);

		if (!raw) {
			try {
				// Protect the set from infinite loops: 
				this._setCalls = (this._setCalls || 0) + 1;
				//dbg:console.error(this._setCalls+".property " + this.name + ":"+this._value);
				if (this._setCalls === 1) {
					// Control the new value:
					this.deleteDiagnoses(_);
					var status = this.controlFormat(_);
					//dbg:console.error(this._setCalls+".property controlFormat:" + status);
					if (status !== constants.CST_AERROR) {
						status = this.controlOthers(_);
						//dbg:console.error(this._setCalls+".property controlOthers:" + status);
						if (status !== constants.CST_AERROR) {
							status = this.$parent.propertyControlValue(_, this, oldValue, this._value);
							if (status !== constants.CST_AERROR) {
								// Propagate the value :
								this.propagateValue(_, oldValue);
							}
						}
					}
				}
			//} catch (ex) {
			// restore old value if this is a JS call.
			// if (oldValue && this.$parent.isThrowing()) this._value = this.property.set(oldValue.value);
			// throw ex;
			} finally {
				//dbg:console.error(this._setCalls+".property " + this.name + "<");
				this._setCalls -= 1;
			}
		}
	}

	fromRecord(_: _, record, colnIndex) {
		//dbg:console.error(this.$parent.meta.name+"."+this.name+".fromRecord:",record);
		if (this.column) {
			if (record[this.column] !== undefined) {
				if (colnIndex !== undefined) this._value = record[this.column][colnIndex];
				else this._value = record[this.column];

				if (this.property.type.readMedia) {
					this._value = this.property.type.readMedia(_, this);
				} else {
					this._value = this._value ? this.property.type.fromSql(_, this._value) : this.property.type.defaultValue;
				}
			} else {
				this._value = this.property.type.defaultValue;
			}
		} else {
			// interfaces :
			if (record[this.name]) this._value = record[this.name];
		}
	}
	clone(parent) {
		const from = this;
		const to = new Slot(parent, this.property);

		to._value = from._value;
		to.$parent = from.$parent;
		attributes.clone(from, to);
		to.snapshotof = from;

		// Clone the diagnoses :
		if (this.diagnoses) to.diagnoses = this.diagnoses.slice();
		return to;
	}

	revertTo() {
		if (!this.snapshotof) return;
		this.snapshotof._value = this._value;
		attributes.revertTo(this, this.snapshotof);
	}

	propagateValue(_: _, oldValue: any) {
		//dbg:console.error(this.name + " propagate old:'"+oldValue.value+"' new:'"+this._value+"'");
		// 1. bonds ?
		if (this.property.proMaps) {
			this.property.proMaps.forEach_(_, (_, map) => {
				const slot = this.$parent.slot(_, map.REFLNK);

				slot && slot.onMapChange(_, map.KEYMAP, this._value);
			});
		}
		// 2. Call scripts :
		//if(this.$parent.propertyPropagateValue && (oldValue.value === undefined || oldValue.value.x3Compare(this._value) !== 0)){
		if (this.$parent.propertyPropagateValue && oldValue.value.x3Compare(this._value) !== 0) {
			this.$parent.propertyPropagateValue(_, this, oldValue, this._value);
		}
	}
	setAsMandatory(_: _) {
		this.$isMandatory = true;
		if (this.property.type && this.property.type.data.TYPTYP === 1 && this.property.data.NOLIB) {
			// local menu => set a default value
			var menu = this.$parent.supervisor.loadEnum(_, this.property.data.NOLIB);
			if (menu && menu.length && (this._value < menu[0].$value || this._value > menu[menu.length - 1].$value)) {
				this._value = menu[0].$value;
			}
		}
	}

	toJson(_: _, value: any) {
		return this.property.type.toJson(_, this, value);
	}
};

attributes.addAttributes(Slot.prototype);

export function newSlot(property) { return (parent => new Slot(parent, property)); };
