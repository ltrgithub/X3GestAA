"use strict";

// TODO: select * from nls_database_parameters
// NLS_LANG=AMERICAN_AMERICA.AL32UTF8

const fs = require("streamline-fs");
const glob = require('streamline/lib/globals');
const tuuid = require('etna/lib/engine/runtime/tuuid');
const supervisor = require("etna/lib/supervisor/supervisor");
const util = require("etna/lib/supervisor/util");
const Helper = util.Helper;
const bactx = require("etna/lib/supervisor/builtins/ACTX");
const constants = require("etna/lib/supervisor/constants");
const tracerJs = require('syracuse-core').getTracer("etna.supervisor");

function loadModule(name) {
	if (!module.modules || !module.modules[name]) {
		module.modules = module.modules || {};
		try {
			tracerJs.debug && tracerJs.debug("require " + "etna/lib/supervisor/" + name);
			var mod = require("etna/lib/supervisor/" + name);
			module.modules[name] = mod;
		} catch (e) {
			console.error("loadModule error:" + e.message);
			throw new util.HttpError(404, name + " couldn't be loaded:" + JSON.stringify(e));
		}
	}
	return module.modules[name];
}

function loadType(_, context, type, code) {
	if (!code) throw new util.HttpError(400, type + " parameter missing");

	const clas = context.supervisor.load(_, type, code);

	if (!clas) throw new util.HttpError(404, type + " not found: " + code);
	return clas;
}

function loadClass(_, context, codcla) {
	return loadType(_, context, 'Class', codcla);
}

function loadRepresentation(_, context, codrep) {
	return loadType(_, context, 'Representation', codrep);
}

class HttpContext extends Helper {
	constructor(request, response, superv, qs) {
		super();
		this.request = request;
		this.response = response;
		this.supervisor = superv;
		this.qs = qs;
		if (qs && qs.representation) {
			var pair = qs.representation.split('.');
			this.codrep = pair[0];
			this.facet = pair[1];
		}
	}
	getMethod() {
		return (this.request._request.headers.method || this.request.method).toUpperCase();
	}
	getHeaderField(field) {
		return this.request._request.headers[field];
	}
	checkMethod(method) {
		if (this.getMethod() === method) return;
		else throw new util.HttpError(405, "bad method " + this.request.method);
	}
	get private() {
		if (!this.request.session) throw new HttpContext(500, "session missing");
		return this.request.session.private = this.request.session.private || {
			workingCopies: {}
		};
	}
	workingCopy(trackingId) {
		const workingCopies = this.private.workingCopies;
		const wc = workingCopies[trackingId];

		if (!wc) throw new util.HttpError(404, "working copy not found: " + trackingId);
		return wc;
	}
	reply(_, status, data, headers) {
		headers = headers || {};
		headers["content-type"] = headers["content-type"] || "application/json";
		this.response.writeHead(status, headers);
		this.response.end(data, "utf8");
		return true;
	}
	jsonReply(_, status, data, headers) {
		headers = headers || {};
		headers["content-type"] = headers["content-type"] || "application/json";
		this.response.writeHead(status, headers);
		this.response.end(JSON.stringify(data, null, '  '), "utf8");
		return true;
	}
};

class BatchContext extends Helper {
	constructor(resource, superv, qs) {
		super();
		this.resource = resource;
		this.request = {
			method: resource.$httpMethod,
			readAll: (_) => JSON.stringify(resource),
		};

		this.supervisor = superv;
		this.qs = qs;
		if (qs && qs.representation) {
			var pair = qs.representation.split('.');
			this.codrep = pair[0];
			this.facet = pair[1];
		}
	}
	getMethod() {
		return this.request.method.toUpperCase();
	}
	getHeaderField(field) {
		return "";
	}
	checkMethod(method) {
		if (this.getMethod() === method) return;
		else throw new util.HttpError(405, "bad method " + this.method);
	}
	get private() {
		if (!this.request.session) throw new HttpContext(500, "session missing");
		return this.request.session.private = this.request.session.private || {
			workingCopies: {}
		};
	}
	reply(_, status, data, headers) {
		this.$httpStatus = status;
		this.response = data;
		return true;
	}
	jsonReply(_, status, data, headers) {
		this.$httpStatus = status;
		this.response = data;
		return true;
	}
};

function parseQueryString(s) {
	return s ? s.split('&').reduce((r, sub) => {
		const pair = sub.split('=');

		r[pair[0]] = pair[1];
		return r;
	}, {}) : {};
}

function parseKey(s) {
	return s && s.substring(2, s.length - 2);
}

const supervisors = {};


function postWorkingCopy(_, context, codcla, key) {
	const workingCopies = context.private.workingCopies;
	const qs = context.qs;
	const codrep = context.codrep,
	      facet = context.facet;
	const repr = loadRepresentation(_, context, codrep);

	if (facet !== '$edit') throw new util.HttpError(400, "bad facet for working copy: " + facet);
	if (repr.data.CODCLA !== codcla) throw new util.HttpError(400, "class/representation mismatch: " + repr.data.CODCLA + " <> " + codcla);
	repr.check(_, facet);
	qs.trackingId = qs.trackingId || tuuid.generate();
	const res = key ? repr.loadResource(_, key, facet, qs) : repr.createResource(_, qs);
	const wc = workingCopies[qs.trackingId] || (workingCopies[qs.trackingId] = context.supervisor.new(_, 'WorkingCopy', res, qs.trackingId));
	const node = wc.dataNode(_);

	context.jsonReply(_, 200, node, {
		location: node.$url
	});
}

const FACETS = require("etna/lib/supervisor/meta/representation").FACETS;
const routes = [{
	pattern: /^(\$prototypes\(''\))?$/,
	handler(_, context, superv) {
		const lis = context.supervisor.sqlReader(_, "select R.MODULE_0, R.CODREP_0, R.CODCLA_0, R.INTREP_0, C.TYPCLA_0 " + //
		"from ASHW R, ACLASSE C where R.CODCLA_0 = C.CODCLA_0 and C.TYPCLA_0 = 2 order by CODREP_0").toArray(_).map_(_, (_, rep) => '<tr><td><a href="/syracuse-main/html/main.html?url=' + context.supervisor.baseUrl + '/' + //
			rep.CODCLA + '?representation=' + rep.CODREP + '.$query">' + rep.CODREP + '</td><td>' + //
			context.supervisor.loadText(_, parseInt(rep.INTREP, 10)) + '</a></td></tr>').join('\n');
		const html = '<html><head><title>Welcome to ETNA</title></head><body><table>\n' + lis + '\n</table></body></html>';

		context.response.writeHead(200, {
			"content-type": "text/html"
		});
		context.response.end(html);
	}
}, {
	pattern: /^\$prototypes\('([\w~]+)\~([\w~]+)\.([\w\$]+)'\)/,
	handler(_, context, keyword, keyvalue, facet) {
		context.checkMethod("GET");
		if (keyword.indexOf("QUERY~") === 0 && facet === "$query") {
			var script = keyword.substring(6);
			var proto = loadModule("requester").proto(_, context, script, keyvalue, facet);
			if (!proto) throw new util.HttpError(404, "query not found: " + script);
			context.reply(_, 200, proto);
		} else if (keyword === "STATS" && facet === "$cube") {
			var proto = loadModule("statistics").proto(_, context, keyvalue, facet);
			if (!proto) throw new util.HttpError(404, "statistics not found: " + keyword);
			context.reply(_, 200, proto);
		} else if (keyword === "PROCESS" && keyvalue === "UNKNOWN" && facet === "$details") {
			// todo handle ~ in codrep
			var proto = {};
			context.jsonReply(_, 200, proto);
		} else {
			throw new util.HttpError(404, keyword + " not yet managed: " + keyvalue + ' facet=' + facet);
		}
	}
}, {
	pattern: /^\$prototypes\('([\w~]+)\.([\w\$]+)'\)/,
	handler(_, context, codrep, facet) {
		context.checkMethod("GET");
		var proto = {};
		const headers = {};

		var httpStatus = 200;
		if (facet === "$search") {
			var clas = loadClass(_, context, codrep);
			proto = clas.searchProto(_);
		} else {
			if (!FACETS[facet]) throw new util.HttpError(400, "bad facet: " + facet);
			var repr = loadRepresentation(_, context, codrep);
			repr.check(_, facet);
			repr.checkDevice(context.qs.device);
			if (context.qs.device) repr.qdevice = context.qs.device;

			var etag = context.getHeaderField("if-none-match");
			if (etag && etag === repr.protoETag(_, facet)) {
				httpStatus = 304;
			} else {
				// Load the prototype
				proto = repr.proto(_, facet);
				headers.ETag = repr.protoETag(_, facet);
				//fs.writeFile(__dirname + "/../../../results/etna/" +  codrep + "-" + facet + ".json", JSON.stringify(proto, null, 2), "utf8", _);
			}
		}
		context.jsonReply(_, httpStatus, proto, headers);
	}
}, {
	///sdata/x3/erp/etnaOracle/BDOC('C_AUTILIS~¨~AUSPIC~¨~AUSPIC~¨~ERB~¨~~¨~')?salt=983&language=fr-FR
	pattern: /^(?:B|C)DOC\('C_(\w*)~(?:¨|%C2%A8)~(\w*)~(?:¨|%C2%A8)~(\w*)~(?:¨|%C2%A8)~(\w*)~(?:¨|%C2%A8)~(\w*)/,
	handler(_, context, codcla, property, codblb, ident1, ident2) {
		const cl = loadClass(_, context, codcla);

		return cl.readLob(_, context, property, codblb, ident1, ident2);
	}
}, {
	//sdata/x3/erp/etnaOracle/BDOC('C_AVOLFIL~%C2%A8~CONTENTS~%C2%A8~TMP~%C2%A8~000002.jpg')
	pattern: /^(?:B|C)DOC\('C_(\w*)~(?:¨|%C2%A8)~(\w*)~(?:¨|%C2%A8)~(\w*)~(?:¨|%C2%A8)~([\w\.]*)/,
	handler(_, context, codcla, property, codblb, ident1) {
		const cl = loadClass(_, context, codcla);

		return cl.readLob(_, context, property, codblb, ident1);
	}
}, {
	//sdata/x3/erp/etnaOracle/BDOC('C_AVOLFIL~%C2%A8~CONTENTS~%C2%A8~TMP~%C2%A8~000002.jpg')
	pattern: /^(?:B|C)DOC\('C_(\w*)~(?:¨|%C2%A8)~(\w*)~(?:¨|%C2%A8)~(\w*)/,
	handler(_, context, codcla, property, codblb) {
		const cl = loadClass(_, context, codcla);

		return cl.readLob(_, context, property, codblb);
	}
}, {
	pattern: /^(\w*)(\('[^']*'\))?$/,
	handler(_, context, codcla, key) {
		key = parseKey(key);
		if (codcla === 'QUERY') {
			context.checkMethod("GET");
			return loadModule("requester").query(_, context, key, context.codrep);
		} else if (codcla === 'STATS') {
			context.checkMethod("GET");
			var res = loadModule("statistics").query(_, context, key, context.codrep);
			return context.reply(_, 200, res);
		}

		const codrep = context.codrep,
		      facet = context.facet,
		      qs = context.qs;

		if (facet !== "$search") {
			var repr = loadRepresentation(_, context, codrep);
			if (repr.data.CODCLA !== codcla) throw new util.HttpError(400, "class/representation mismatch: " + repr.data.CODCLA + " <> " + codcla);
			repr.check(_, facet);

			var method = context.getMethod();
			if (['$query', '$edit'].indexOf(facet) >= 0 && method === 'DELETE') {
				return repr.deleteResource(_, context, key, facet, qs);
			} else if (facet === "$edit") {
				if (method === 'POST') {
					var res = repr.createResource(_, qs);
					var wc = context.supervisor.new(_, 'WorkingCopy', res, tuuid.generate());
					var data = JSON.parse(context.request.readAll(_));
					data.$actions = { $save: { $isRequested: true } };
					var delta = wc.update(_, context, data);
					return context.jsonReply(_, 201, delta);
				} else if (method === 'PUT') {
					var res = repr.loadResource(_, key, facet, qs);
					var wc = context.supervisor.new(_, 'WorkingCopy', res, tuuid.generate());
					var data = JSON.parse(context.request.readAll(_));
					data.$actions = { $save: { $isRequested: true } };
					var delta = wc.update(_, context, data);
					return context.jsonReply(_, 200, delta);
				} else if (method === 'GET') {
					var res = repr.createResource(_, qs);
					var wc = context.supervisor.new(_, 'WorkingCopy', res, tuuid.generate());
					return context.jsonReply(_, 200, wc.dataNode(_));
				}
			} else if (/^\$(query|lookup|bulk)$/.test(facet) && method === 'GET') {
				if (key) throw new util.HttpError(400, "key value not allowed in " + facet + " facet");
				return repr.query(_, context, facet, qs);
			} else if (/^\$(details|summary)$/.test(facet) && method === 'GET') {
				if (!key) throw new util.HttpError(400, "key value missing in " + facet + " facet");
				return context.jsonReply(_, 200, repr.loadResource(_, key, facet, qs).dataNode(_));
			}
			// In other cases : 
			throw new util.HttpError(405, "bad method " + method);
		} else {
			context.checkMethod("GET");
			var clas = loadClass(_, context, codcla);
			if (!clas.isSearchable) throw new util.HttpError(406, "search not available for class: " + codcla);
			return clas.search(_, context, qs);
		}
	}
}, {
	pattern: /^(\w+)(\('[^']*'\))?\/\$workingCopies$/,
	handler(_, context, codcla, key) {
		const method = context.getMethod();
		const qs = context.qs;


		if (method === "POST") {
			postWorkingCopy(_, context, codcla, parseKey(key));
		} else if (method === "DELETE") {
			var workingCopies = context.private.workingCopies;
			workingCopies[qs.trackingId] = undefined;
			context.jsonReply(_, 200, {});
		} else throw new util.HttpError(405, "bad method: " + method);
	}
}, {
	// {$baseUrl}/AVOLUME/$template?representation=AVOLUME.$edit&trackingId=41827f7b-c3df-483e-9e30-4131d3f6edaf
	pattern: /^(\w+)\/\$template\/\$workingCopies$/,
	handler(_, context, codcla) {
		context.checkMethod("POST");
		postWorkingCopy(_, context, codcla);
	}
}, {
	// sdata/x3/erp/etnaOracle/ARIGHTS('ADMIN')/$services/$rights
	pattern: /^ARIGHTS\('(\w*)'\)\/\$services\/\$rights$/,
	handler(_, context, user) {
		tracerJs.debug && tracerJs.debug('context.getHeaderField("if-none-match") ' + context.getHeaderField["if-none-match"]);
		const actx = glob.context.x3session.actx;
		const rightsEtag = actx.getRightsEtag(_);
		const res = actx.getJsonRights(_);
		//dbg:console.log("rightsEtag:"+rightsEtag);
		//dbg:console.log("res:",res);

		const headers = {
			'content-type': 'application/json',
			'ETag': rightsEtag
		};

		tracerJs.debug && tracerJs.debug("headers: " + JSON.stringify(headers));

		if (rightsEtag === context.request._request.headers["if-none-match"]) {
			context.jsonReply(_, 304, headers);
		} else if (res) {
			context.jsonReply(_, 200, util.unescapeJson(res), headers);
		} else {
			throw new util.HttpError(400, "rights error");
		}
	}
}, {
	pattern: /^\$workingCopies\('([^']*)'\)$/,
	handler(_, context, trackingId) {
		const method = context.getMethod();

		if (method === "PUT") {
			var wc = context.workingCopy(trackingId);
			var data = JSON.parse(context.request.readAll(_));
			var delta = wc.update(_, context, data);
			context.jsonReply(_, 200, delta);
		} else if (method === "DELETE") {
			var workingCopies = context.private.workingCopies;
			workingCopies[trackingId] = undefined;
			context.jsonReply(_, 200, {});
		} else throw new util.HttpError(405, "bad method: " + method);
	}
}, {
	// /$workingCopies('ffb5aee7-55a7-4030-9040-658f54def52f')/AQQ06/FIELD13
	pattern: /^\$workingCopies\('([^']*)'\)((\/\w*)*)$/,
	handler(_, context, trackingId, path) {
		const wc = context.workingCopy(trackingId);
		const method = context.getMethod();

		if (method === "PUT") {
			var data = context.request.readAll(_);
			var delta = wc.update(_, context, data, path);
			context.jsonReply(_, 200, delta);
		} else if (method === "DELETE") {
			var delta = wc.update(_, context, undefined, path);
			context.jsonReply(_, 200, delta);
		} else if (method === "GET") {
			wc.read(_, context, path);
		} else throw new util.HttpError(405, "bad method: " + method);
	}
}, {
	// /$workingCopies('33e876e6-1036-40d9-a959-80e9be32f350')/AQCP01/DESCRIPTION/$localize
	pattern: /^\$workingCopies\('([^']*)'\)((\/\w*)*)\/\$localize$/,
	handler(_, context, trackingId, path) {
		const wc = context.workingCopy(trackingId);
		const method = context.getMethod();

		if (method === "PUT") {
			var data = context.request.readAll(_);
			wc.updateLocalization(_, context, data, path);
		} else if (method === "GET") {
			wc.readLocalization(_, context, path);
		} else throw new util.HttpError(405, "bad method: " + method);
	}
}, {
	pattern: /^(\w+)(\('[^']*'\))?\/\$services\/(\w+)/,
	handler(_, context, codcla, key, service) {
		key = parseKey(key);
		const codrep = context.codrep,
		      facet = context.facet,
		      qs = context.qs;
		const repr = loadRepresentation(_, context, codrep);

		if (!FACETS[facet] || facet === '$edit') throw new util.HttpError(400, "bad facet: " + facet);
		if (repr.data.CODCLA !== codcla) throw new util.HttpError(400, "class/representation mismatch: " + repr.data.CODCLA + " <> " + codcla);
		repr.check(_, facet);

		const res = repr.service(_, key, service, facet, qs);

		context.jsonReply(_, 200, res);
	}
}, {
	pattern: /^\$service\/ABOUT$/,
	handler(_, context) {
		context.jsonReply(_, 200, context.supervisor.about(_));
	}
}, {
	pattern: /^\$service\/rpc$/,
	handler(_, context) {
		return loadModule("gateway").rpc(_, context);
	}
}, {
	// {$baseUrl}/AQCQRY02/$batch?representation=AQCQRY02.$edit
	pattern: /^(\w+)\/\$batch$/,
	handler(_, context, codcla) {
		context.checkMethod("POST");
		const clas = loadClass(_, context, codcla);
		const repr = loadRepresentation(_, context, context.codrep);
		const data = JSON.parse(context.request.readAll(_));
		const batchResponse = { $resources: [] };

		data.$resources && data.$resources.forEach_(_, (_, resource) => {
			const m = /^\/sdata\/(?:etna|x3)\/erp\/(\w+)\/([^?]*)\??(.*$)/.exec(resource.$url);

			var endpointName = m[1],
			    path = m[2],
			    qs = parseQueryString(m[3]);

			for (var i = 0; i < routes.length; i++) {
				path = path.replace("{$baseUrl}", context.supervisor.baseUrl).replace(/^http[s]{0,1}:\/\/\w*(?::\d+)/, "");

				var r = routes[i].pattern.exec(path);
				if (r) {
					try {
						var batchContext = new BatchContext(resource, context.supervisor, qs);
						routes[i].handler.apply_(_, null, [batchContext].concat(r.slice(1)), 0);
						var response = batchContext.response;
						response.$url = resource.$url;
						response.$httpStatus = batchContext.$httpStatus;
						batchResponse.$resources.push(response);
					} catch (e) {
						batchResponse.$resources.push({ $url: resource.$url, $httpStatus: e.statusCode || 500,
							$diagnoses: [{ $severity: "error", $message: e.message }] });
					}
					break;
				}
			}
		});
		context.jsonReply(_, 200, batchResponse);
	}
}];


exports.httpDispatch = function (_, config, request, response) {
	try {
		request.url = decodeURIComponent(request.url);

		tracerJs.debug && tracerJs.debug([request.method, request.url].join(' '));
		//dbg:console.error([request.method, request.url].join(' '));

		request.session.x3Info = config.session;
		var m = /^\/sdata\/(?:etna|x3)\/erp\/(\w+)\/([^?]*)\??(.*$)/.exec(request.url);
		if (!m) throw new util.HttpError(404, "resource not found.");
		var endpointName = m[1],
		    path = m[2],
		    qs = parseQueryString(m[3]);
		var key = config.endpointName;
		var superv = supervisors[key] || (supervisors[key] = supervisor.create(_, config));
		superv.razCacheScripts(_);
		var context = new HttpContext(request, response, superv, qs);
		bactx.init(_, config.session, superv);

		config.session = undefined;
		for (var i = 0; i < routes.length; i++) {
			var r = routes[i].pattern.exec(path);
			if (r) return routes[i].handler.apply_(_, null, [context].concat(r.slice(1)), 0);
		}
		throw new util.HttpError(400, "bad url format: " + request.url);
	} catch (ex) {
		console.error(ex.stack);
		if (!ex.statusCode) tracerJs.error && tracerJs.error(ex.stack);
		context = context || new HttpContext(request, response);
		context.jsonReply(_, ex.statusCode || 500, {
			$diagnoses: [{
				$severity: "error",
				$message: ex.message //,
				//$stackTrace: ex.stack // TO KEEP ?
			}]
		});
	}
};