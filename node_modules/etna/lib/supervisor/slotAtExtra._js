"use strict";

var glob = require('streamline/lib/globals');

var util = require('util');
var Slot = require("etna/lib/supervisor/slot").Slot;


class SlotAtextra extends Slot {
	constructor(parent, property) {
		super(parent, property);
	}

	get(_, raw) {
		if (this.property && this.property.data && this._value === undefined) {
			this._value = this.property.loadAtextra(_, this.$parent);
			this.$wasRead = true;
		}
		return super.get(_,raw);
	}

	set(_, value, raw) {
		super.set(_,value,raw);
		this.$wasUpdated = (this.$wasRead && value !== this._value) || true;
	}	

	fromRecord(_, record, colnIndex) {
		this._value = undefined;
	}

	clone(parent) {
		var to = super.clone(parent);
		if(this._atextra) {
			to._atextra = Object.keys(this._atextra).reduce((r, lan) => {
				r[lan] = this[lan];
				return r;
			}, {});
		}
		return to;
	}	

	insertSlot(_) {
		this.$wasUpdated && this.property.updateAtextra(_, this.$parent, this._value);

		if (this._atextra) {
			Object.keys(this._atextra).forEach_(_, (_, lan) => {
				this.property.updateAtextra(_, this.$parent, this._atextra[lan], lan);
			});
			this._atextra = undefined;
		}
	}
	updateSlot(_) { return this.insertSlot(_);}

	deleteSlot(_) {
		return this.property.deleteAtextra(_, this.$parent);
	}	
	
	getAtextra(_, lan) {
		if (this._atextra && this._atextra[lan]) return this._atextra[lan];

		this._atextra = this._atextra || {};
		return this._atextra[lan] = (lan === glob.context.x3session.actx.$LAN(_)) ?
			this.get(_) : this.property.getAtextra(_, this.$parent, lan);

	}

	setAtextra(_, text, lan) {
		// Store it for later used (update!)
		this._atextra = this._atextra || {};
		this._atextra[lan] = text;
		if (lan === glob.context.x3session.actx.$LAN(_)) {
			this.set(_, text);
		}
	}
}

exports.SlotAtextra = SlotAtextra;

exports.newSlotAtextra = function(property) {
	return function(parent) {
		return new SlotAtextra(parent, property);
	};
};
