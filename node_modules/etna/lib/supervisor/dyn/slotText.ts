import { _ } from 'streamline-runtime';
const util = require('util');
import { Property } from '../meta/property';
import { Slot } from './slot';

export class SlotText extends Slot {
	constructor(parent: any, property: Property) {
		super(parent, property);
	}

	get(_: _,  raw?: boolean) {
		if (this.property && this.property.data && typeof this._value !== 'string') {
			// The texte is cached by the supervisor:
			this._value = this.$parent.supervisor.loadText(_, this._value || 0) || "";
		}
		return super.get(_, raw);
	}

	oldValue(_: _) {
		return this._value !== undefined ? this.$parent.supervisor.findText(_, this._value) : this.property.type.defaultValue;
	}

	set(_: _,  value: any, raw?: boolean) {
		if (value && typeof value === 'string') {
			// replace the string by a number
			if (value !== this.get(_, true)) {
				// new text
				value = this.$parent.supervisor.findText(_, value) || this.$parent.supervisor.findText(_, this._value);
			}
		}
		return super.set(_, value, raw);
	}

	/*
 get cannot be used for database operations because it returns a string instread of an id
 for text
 */
	getSql(_: _) {
		// Insert a number instead of a string in the database !
		return typeof this._value === 'string' ? this.$parent.supervisor.findText(_, this._value) : this._value;
	}

	insertSlot(_: _) {
		if (typeof this._value === 'string') {
			this._value = this.$parent.supervisor.findText(_, this._value) || 0;
			//TODO this.$parent.supervisor.addText(_, this._value);
		}
	}
	updateSlot(_: _) {
		return this.insertSlot(_);
	}
}
