import { _ } from 'streamline-runtime';
import * as types from '../../engine/runtime/types';
import { ActionsProto } from '../protocol/prototype';
import { DataNode, ResourceNode, DiagnosisProto } from '../protocol/data';
import * as util from '../util';
const Helper = util.Helper;
import * as constants from '../constants';
import { Resource, SlotLob } from './types';
import { HttpContext } from '../http';
import { Supervisor } from '../supervisor';
const tracerJs = require('syracuse-core').getTracer("etna.supervisor");

var ETag = 0;
export class WorkingCopy extends Helper {
	supervisor: Supervisor;
	snapshot: Resource;
	trackingId: string;
	save: string;
	current: Resource;
	representation: string;
	url: string;
	etag: number;
	ETag: number;
	actions: ActionsProto;
	$representation: string;
	previous: Resource;

	constructor(superv: Supervisor, res: Resource, trackingId: string) {
		super();
		this.supervisor = superv;
		this.trackingId = typeof trackingId === 'string' ? trackingId : trackingId.x3ToString();
		this.snapshot = res;
		this.save = res.key ? "update" : "insert";
		//this.current = res.clone(); is it necessary ? it's error prone (snapshots...)
		this.current = res;
		this.representation = res.resourceFactory.representation.name;
		this.url = "{$baseUrl}/$workingCopies('" + this.trackingId + "')" + //
		"?representation=" + this.representation + '.$edit';
		this.etag = 0;
		this.ETag = ++ETag;
		const clas = res.resourceFactory.representation.class.name;

		this.actions = {
			$save: {
				$isHidden: false,
				$isDisabled: false,
				$links: {
					$redirect: {
						$url: "{$baseUrl}/" + clas + "('{$key}')?representation=" + this.representation + ".$details",
						$isHidden: false
					}
				}
			}
		};
	}
	init(_: _) {
		return this;
	}
	delta(_: _) {
		return {};
	}
	addAttributes(node: ResourceNode) {
		node.$trackingId = this.trackingId;
		node.$baseUrl = this.supervisor.baseUrl;
		node.$prototype = "{$baseUrl}/$prototype('{$representation}.$thumb')";
		node.$representation = this.$representation;
		node.$url = this.url;
		node.$type = "application/json;vnd.sage=syracuse";
		node.$etag = this.etag;
		node.ETag = this.ETag;
		node.$actions = this.actions;
		return node;
	}
	dataNode(_: _) {
		const node = this.previous ? this.delta(_) : this.current.dataNode(_);

		return this.addAttributes(node);
	}
	update(_: _,  context: HttpContext, delta: ResourceNode, path?: string) {
		tracerJs.debug && tracerJs.debug("updating working copy:", delta, path);
		this.actions.$save.$isDisabled = false;
		this.etag += 1;

		//dbg:console.error("DELTA:\n",delta);
		this.current.enableSyssnapshot();
		try {

			//dbg:debug(_,"before delta",this);
			if (path !== undefined) {
				this.current.walkToProperty(_, path, (_, instance, property) => {
					// TODO: clarify typing
					const slot: any = instance.set(_, property, delta);
					if (slot.isLob) {
						// Set attributes :
						slot.$isLoaded = true;
						slot.$contentType = context.getHeaderField("content-type");
						slot.$filename = context.getHeaderField("x-file-name");
					}
				});
			} else this.current.applyDelta(_, delta);

			//dbg:debug(_,"after delta",this);

			var diagnoses: DiagnosisProto[];
			tracerJs.debug && tracerJs.debug("delta.$actions:" + JSON.stringify(delta.$actions));
			if (delta && delta.$actions && delta.$actions.$save && delta.$actions.$save.$isRequested === true) {
				tracerJs.debug && tracerJs.debug("resource." + this.save);
				var status = (this.current as any)[this.save](_);
				if (status !== constants.CST_AERROR) {
					// The resource was successfully saved in the database
					diagnoses = [{
						$severity: "success",
						$message: this.supervisor.loadMess(_, 124, 192)
					}];
					this.actions.$save.$isDisabled = true;
					this.actions.$save.$isRequested = false;
					this.save = "update";
				}
			}
			const node = this.current.dataNode(_, false);
			//Add diagnoses
			if (diagnoses) node.$diagnoses = node.$diagnoses ? node.$diagnoses.concat(diagnoses) : diagnoses;
			return this.addAttributes(node);
		} finally {
			this.current.disableSyssnapshot();
		}

	}
	read(_: _,  context: HttpContext, path: string) {
		tracerJs.debug && tracerJs.debug("reading working copy:", path);
		this.current.walkToProperty(_, path, (_, instance, property) => {
			const slot: any = instance.slot(_, property);

			var data = slot.get(_, true);
			if (data !== undefined) {
				if (slot.isClob) {
					data = data.x3ToString();
				} else if (slot.isBlob && data) {
					data = data.valueOf(); // Get the actual value of data
				}
				var headers: any = {
					"content-length": data.length
				};
				//SAM 109102 :
				if (slot.$filename && slot.isClob) headers["content-disposition"] = "attachement;filename=" + slot.$filename;
				if (slot.$contentType) headers["content-type"] = slot.$contentType;
				context.response.writeHead(200, headers);
				context.response.end(data);
			}
		});
	}
	initLocalizeData(context: HttpContext): DataNode {
		return {
			$type: "application/x-localization",
			$url: this.url,
			$links: {
				$save: {
					$url: context.request.url,
					$method: "PUT",
					$title: "Save"
				}
			},
			$values: []
		};
	}
	readLocalization(_: _,  context: HttpContext, path: string) {
		tracerJs.debug && tracerJs.debug("reading working copy localization:", path);
		const data = this.initLocalizeData(context);

		this.current.walkToProperty(_, path, (_, instance, property) => {
			const languages = this.supervisor.languages(_);

			Object.keys(languages).forEach_(_, (_, lan) => {
				data.$values.push({
					$code: lan,
					$title: languages[lan].get(_, "INTDES"),
					$locale: languages[lan].get(_, "LANISO"),
					$value: instance.AGETTEXTRALAN(_, property, lan)
				});
			});
			context.jsonReply(_, 200, data);
		});
	}
	updateLocalization(_: _,  context: HttpContext, delta: DataNode, path: string) {
		if (typeof delta === 'string') delta = JSON.parse(delta as any); // ????
		const data = this.initLocalizeData(context);

		if (delta.$values) {
			this.current.walkToProperty(_, path, (_, instance, property) => {
				delta.$values.forEach_(_, (_, locale) => {
					instance.ASETTEXTRALAN(_, property, locale.$value, locale.$code);
					data.$values.push({
						$code: locale.$code,
						$title: locale.$title,
						$locale: locale.$locale,
						$value: locale.$value
					});
				});
				context.jsonReply(_, 200, data);
			});
		}
	}
};
export const Constructor = WorkingCopy;