import { _ } from 'streamline-runtime';
import * as core from 'syracuse-core';
import * as util from '../util';
import * as constants from '../constants';
import { Supervisor } from '../supervisor';
const btime = core.types.datetime;
const traceSup = core.getTracer("etna.supervisor");

var errorcounter = 0;

const enumSeverity: { [id: number]: string } = {
	0: "success",
	1: "success",
	2: "info",
	3: "warning",
	4: "error"
};

export function severity(code: number) {
	const e = new Error("debug");

	return enumSeverity[code] || ('' + code);
};

export function trace(code: number, message: string) {
	const sev = severity(code);
	const toLog = function (sev: string, message: string) {
		return sev + ": " + message;
	};
	//dbg:console.log("+ "+toLog(severity, message));

	switch (sev) {
		case "error":
			traceSup.error && traceSup.error(toLog(sev, message));
			break;
		case "info":
		case "warning":
			traceSup.info && traceSup.info(toLog(sev, message));
			break;
		case "success":
			traceSup.debug && traceSup.debug(toLog(sev, message));
			break;
		default:
			break;
	}
};

export class Diagnosis extends util.Helper {
	supervisor: Supervisor;
	severity: number;
	message: string;
	stackTrace: string;
	category: number;
	counter: number;
	environment: string;
	copy: number;
	label: string;
	PRO: string;
	$exported: boolean;
	
	constructor(superv: Supervisor, severity: number, message: string, stackTrace?: string, category?: number) {
		super();

		// basic property
		this.$exported = true;
		this.supervisor = superv;
		this.severity = severity;
		this.message = message;
		this.stackTrace = stackTrace;
		this.category = category || 0;
		this.counter = errorcounter++;
		// assign in cloning
		this.environment = "";
		this.copy = 0;

		// asssign in getDiagnoses
		this.label = "";
		this.PRO = "";
	}
	init(_: _) {
		return this;
	}
	dataNode() {
		return {
			$severity: exports.severity(this.severity),
			$message: this.message,
			$stackTrace: this.stackTrace
		};
	}
	get(_: _,  name: string): any {
		switch (name) {
			case 'DEL':
				return 1; // 1 stands for CST_ANO
			case 'MES':
				return this.message;
			case 'PRO':
				return this.PRO;
			case 'STA':
				return this.severity;
			case 'LAB':
				return this.label;
			case 'CAT':
				return this.category;
			case 'CPY':
				return this.copy;
			case 'ENV':
				return this.environment;
		}
	}

	set(_: _,  name: string, value: any) {
		switch (name) {
			case 'DEL':
				return 1; // 1 stands for CST_ANO
			case 'MES':
				return this.message = value;
			case 'PRO':
				return this.PRO = value;
			case 'STA':
				return this.severity = value;
			case 'LAB':
				return this.label = value;
			case 'CAT':
				return this.category = value;
			case 'CPY':
				return this.copy = value;
			case 'ENV':
				return this.environment = value;
		}
	}
	x3Compare(b: any) {
		return this === b;
	}
	sortOnTime(d: Diagnosis) {
		return this.counter - d.counter;
	}
	sortOnSeverity(d: Diagnosis) {
		return d.severity - this.severity;
	}
	clone(_: _,  env: string) {
		const cpy = this.supervisor.new<Diagnosis>(_, 'Diagnosis', this.severity, this.message, this.stackTrace, this.category);

		cpy.label = this.label;
		cpy.counter = this.counter;
		cpy.PRO = this.PRO;
		if (env !== undefined) {
			cpy.copy = 1;
			cpy.environment = env;
		} else {
			cpy.copy = this.copy;
			cpy.environment = this.environment;
		}
		return cpy;
	}
};
export const Constructor = Diagnosis;