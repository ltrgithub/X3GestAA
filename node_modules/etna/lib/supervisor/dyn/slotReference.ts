import { _ } from 'streamline-runtime';
import * as types from '../../engine/runtime/types';
import * as attributes from '../attributes';
import * as util from '../util';
import { X3Error } from '../../engine/runtime/errors';
import * as constants from '../constants';
import { Class } from '../meta/class';
import { Property } from '../meta/property';
import { Instance } from './instance';
const tracerJs = require('syracuse-core').getTracer("etna.supervisor");

export class SlotReference {
	parent: Instance;
	property: Property;
	referenceName: string;
	reference: Instance;
	_targetClass: Class;
	_value: any;
	$parent: Instance;

	bindAttributes: (parent: any) => void;
	$attributes: any; // fix later
	setAttribute: (name: string, value: any) => any;


	constructor(parent: Instance, property: Property) {
		// care of the name if and only if the property belongs to
		// an instance which which belongs to a collection :
		if (property.type) {
			this.property = property;
		} else {
			// TODO: clean this hack
			util.any(this).property = {
				name: ""
			};
		}
		this.referenceName = property.name;
		this.reference = null;
		this._value = null;
		this.bindAttributes(parent);
	}

	get name() {
		return this.property.name;
	}
	get column() {
		return;
	}

	get value() {
		return this._value || {};
	}

	set value(value) {
		throw new X3Error(147, (this.name ? this.name : '') + "is readonly");
	}

	targetClass(_: _) {
		if (!this._targetClass) {
			var type = this.$parent.supervisor.load(_, 'Type', this.property.data.CODTYP);
			this._targetClass = type.targetClass(_);
		}
		return this._targetClass;
	}

	get(_: _) {
		const reference = this.$parent.get(_, this.referenceName);

		if (reference != this.reference) {
			// Load reference's attributes:
			this._value = this.$parent.properties[this.name].loadReference(_, this.$parent);

			if (!this._value) this._value = {
				"$title": ""
			};else if (!this._value.$title) this._value.$title = "";

			if (this._value) {
				var _this = this;
				Object.keys(_this._value).forEach_(_, (_, attribute) => {
					const value = _this._value[attribute];

					if (/^\$(description|title|symbol)$/.test(attribute)) _this.$attributes.setResource(_, attribute, value);
					else _this.setAttribute(attribute, value);
				});
			}
		}
		return this._value || {};
	}

	set(_: _,  value: any, raw?: boolean) {
		//dbg:console.log("SlotReference set:",value);
		const keyParams = this.property.keyParams;
		const refKeys = Object.keys(value).filter(key => key[0] !== '$');

		for (var i = 0; i < keyParams.length; i++) {
			//dbg:console.error("SlotReference set parent."+keyParams[i].FLDCLA+" with:"+value[refKeys[i]]);
			this.$parent.set(_, keyParams[i].FLDCLA, value[refKeys[i]]);
		}
	}

	fromRecord(_: _,  record: types.Row, colnIndex?: number) {}
	toRecord(record: types.Row) {}
	clone(parent: any) {}
	revertTo() {}
	deleteDiagnoses(_: _) {}
	controlOthers(_: _) {
		//dbg:console.error("SlotReference.controlOthers:"+this.property.name);
		// Get the class of the referenced type :
		const cl = this.targetClass(_);

		// look for the root parent

		var parent: any = this;
		while (parent = parent.$parent) {
			if (!parent.$parent) {
				if (parent.meta.name === cl.name) return constants.CST_AOK; // No circular controls:
				break;
			}
		}

		const instance = this.$parent;
		const keyMaps = this.property.keyMaps(_);
		const refKey = Object.keys(keyMaps).map_(_, (_, key) => keyMaps[key](_, instance)).join('~');

		if (!refKey) return constants.CST_AOK; // the key is undefined

		//dbg:console.error("SlotReference.controlOthers refKey:'"+refKey+"'");
		const ref = cl.createInstance(_);
		// Try to read the reference :
		const status = ref.read(_, refKey, { crud: false });
		//dbg:console.error("SlotReference.controlOthers status:"+status);

		if (status === constants.CST_AERROR) {
			tracerJs.error && tracerJs.error("Reference " + cl.name + "('" + refKey + "') not found");
		}
		return status;
	}
};

attributes.addAttributes(SlotReference.prototype);
export function newSlotReference(property: Property) { return (parent: any) => new SlotReference(parent, property); }
