import { _ } from 'streamline-runtime';
import * as types from '../../engine/runtime/types';
import * as util from '../util';
const glob = require('streamline/lib/globals');
import * as tuuid from '../../engine/runtime/tuuid';
import { X3Error } from '../../engine/runtime/errors';
import * as tdatetime from '../../engine/runtime/tdatetime';
import * as utilRuntime from '../../engine/runtime/util';
import * as db from '../../engine/runtime/db';
import * as mapping from '../mapping';
import * as constants from '../constants';
import * as attributes from '../attributes';
import { BaseInstance } from './baseInstance';
import { Class } from '../meta/class';
import { Slot } from './slot';
import { SlotInstance } from './slotInstance';
import { SlotCollection } from './slotCollection';
import { Collection } from '../meta//collection';
import { ColumnDesc } from '../meta/column';
import { Property } from '../meta/property';
import { Index } from '../meta/index';
import { Supervisor } from '../supervisor';
import { MappingData } from '../mapping';
import { Attributes, AttributesHolder } from '../attributes';

import { ClassLinkMapMeta } from '../metadata/class';

const tracerJs = require('syracuse-core').getTracer("etna.supervisor");
const traceCRUD = require('syracuse-core').getTracer("etna.crud");
const tracerEvents = require('syracuse-core').getTracer("etna.events");

export interface CrudOptions {
	crud?: boolean;
	raw?: boolean;
}

export interface ReferenceNode {
	$symbol?: string;
	$precision?: number;
	$scale?: number;
	[name: string]: any;
}

export class Instance extends BaseInstance implements AttributesHolder {
	methods: { [name: string]: {}}
	class: Class;
	name: string;
	$aparent: Instance;
	$lazyLoading: boolean;
	relKeys: any[];
	$updtick: number;
	cache: any; // todo: refine type

	snapshotof: Instance;
	releaseSnapshot: (from: Instance) => void;
	$syssnapshot: Instance;
	snapshot: () => Instance;
	$index: number; // ??? index in SlotCollection
	x3jsClass: any; // refine type later
	_insideInit: boolean; // TODO: cleanup
	throwing: boolean; // TODO: cleanup
	reference: ReferenceNode;
	tableIndex: Index;
	$attributes: Attributes;
	$isSnapshotEnabled: boolean;
	$isSyssnapshotEnabled: boolean;


	constructor(superv: Supervisor, clas: Class, parent: SlotCollection | BaseInstance, slots?: { [name: string]: Slot }) {
		super(superv);
		this.meta = this.class = clas;
		this.$parent = parent;
		this.methods = {};
		if (this.class) {
			this.index = this.class.index;
			this.class.addMethods(this);
		} else {
			this.index = util.any({}); // investigate typing
		}
		this.properties = clas ? clas.properties : {};
		this.slots = slots || {};
		this.record;
		this.colnIndex;
		this.name = "";
	}
	get $$type() {
		return "Instance";
	}
	get APARENT(): Instance {
		return this.$aparent || util.any(this.$parent);
	}
	set APARENT(parent: Instance) {
		this.$aparent = parent;
	}
	incrementUpdtick(_: _) {
		const v = this.get(_, "UPDTICK", true);

		this.set(_, "UPDTICK", v === 999999999 ? 1 : v + 1, true);
	}
	afterCreate(_: _,  record: types.Row, colnIndex?: number) {
		// for $create action, not $edit
		const instance = this;

		this.record = record;
		this.colnIndex = colnIndex;
		// Set mandatory properties
		this.class.mandatoryProperties && this.class.mandatoryProperties.forEach_(_, (_, property) => {
			instance.slot(_, property).setAsMandatory(_);
		});
		if (record) {
			if (record.AUUID) this.$uuid = record.AUUID;
			Object.keys(this.slots).forEach_(_, (_, p) => {
				if (this.slots[p] && this.slots[p].fromRecord) this.slots[p].fromRecord(_, record, colnIndex);
			}, this);
		}
		return this;
	}
	setInstance(_: _,  record: types.Row) {
		// Manages instruction setInstance
		const instance = this;

		if (record) {
			if (record.AUUID) this.$uuid = record.AUUID;
			Object.keys(this.properties).forEach_(_, (_, p) => {
				if (record[p]) {
					var slot = this.slot(_, p);
					slot && slot.set(_, record[p]);
				}
			}, this);
		}
		return this;
	}
	fromRecord(_: _,  record: types.Row, colnIndex: number) {
		// load keys with
		const dataChildren = this.class.data.dataChildren;

		if (this.$parent && dataChildren && dataChildren.ownMapping) {
			this.$lazyLoading = true;
			this.relKeys = mapping.getKeys(_, dataChildren.ownMapping, record);
		}
	}
	clone() {
		const from = this;
		const to = new Instance(from.supervisor, from.class, from.$parent);

		to.properties = from.properties;
		// required when being called by the constructor of workingCopy
		to.record = from.record;

		to.slots = Object.keys(from.slots).reduce((r, name) => {
			const p = from.slots[name];

			if (p.snapshots) {
				r[name] = p;
			} else {
				r[name] = p.clone && p.clone(this) || p;
			}
			return r;
		}, util.any({}));

		to.$updtick = from.$updtick;
		if (from.$aparent) to.$aparent = from.$aparent;
		to.diagnoses = [];
		to.proName = from.proName;
		to.proJsName = from.proJsName;
		to.$$dbgId = from.$$dbgId; // For debug only:
		to.$uuid = from.$uuid;
		to.cache = from.cache;
		// todo fix so that Instance extends AttributesHolder
		attributes.clone(from, to);
		return to;
	}
	getChildren() {
		return this.slots;
	}
	revertTo() {
		if (!this.snapshotof) return this;
		const to = this.snapshotof;
		const from = this;

		Object.keys(from.slots).filter(property => !!from.slots[property] && !!from.slots[property].revertTo).forEach(property => {
			const fromChild = from.slots[property];
			const toChild = fromChild.revertTo();

			if (toChild) {
				// Release the snapshot :
				toChild.releaseSnapshot(fromChild);
			} else {
				from.slots[property] = undefined;
			}
		});
		attributes.revertTo(util.any(this), util.any(to));
		return to;
	}
	getProKeys(_: _) {
		const dataChildren = this.class.data.dataChildren;

		if (this.$parent && dataChildren && dataChildren.ownMapping) {
			var instance = this;
			dataChildren.ownMapping.MAPS.filter(map => !!map.PROMAP && !!map.KEYMAP).forEach_(_, (_, map) => {
				instance.set(_, map.KEYMAP, instance.APARENT.get(_, map.PROMAP), true);
			});
		}
	}
	getKey(_: _): any {
		if (this.key) return this.key;
		// Compute the key
		return this.class.data.KEYINT ? this.class.data.KEYINT.match(/(\w+)/g).map_(_, (_, p) => this.get(_, p, true)) : undefined;
	}
	getKeyTab(_: _): any {
		if (this.key) return this.key;
		// Compute the key
		return this.class.data.KEYINT ? this.class.data.KEYINT.match(/(\w+)/g).map_(_, (_, p) => this.get(_, p, true)) : undefined;
	}
	AREAD(_: _) {
		throw new Error("AREAD not supported");
	}
	AINSERT(_: _) {
		throw new Error("AINSERT not supported");
	}
	AUPDATE(_: _) {
		throw new Error("AUPDATE not supported");
	}
	ADELETE(_: _) {
		throw new Error("ADELETE not supported");
	}
	xmet(name: string) {
		return this.methods["xmet" + name];
	}
	crud(_: _,  fname: string, f: (_: _, instance: Instance) => number, key?: any) {
		traceCRUD.debug && traceCRUD.debug(this.class.name + "." + fname, key);

		var execute: (_: _, event: string) => number;
		const instance = this;

		var status = constants.CST_AOK;

		const checkStatus = (status: number) => {
			if (status === constants.CST_AERROR) {
				var e = new Error("abort"); // to handle abort actions carefully
				//dbg:traceCRUD.error && traceCRUD.error("CRUD ERROR: " + e.stack);
				throw e;
			}
			return status;
		};

		this.transaction && this.transaction.begin(_);
		try {
			if (glob.context.x3session._crudActions === undefined) {
				glob.context.x3session._crudActions = [];
				//Define execute at the top level only
				execute = (_, event) => {
					var status = constants.CST_AOK;
					glob.context.x3session._crudActions.reverse().forEach_(_, (_: _, f: (_: _, ev: string) => number) => {
						status = Math.max(status, f(_, event));
					});
					return status;
				};
			}
			// Register a delayed action :
			glob.context.x3session._crudActions.push((_: _, event: string) => this.action(_, fname + "_" + event, this.key));

			if (key) this.key = key;
			status = checkStatus(this.action(_, fname + "_BEFORE", this.key));

			status = Math.max(checkStatus(f(_, this)));

			if (key === undefined && this.class.isInterface === false) {
				// AINSERT, AUPDATE, ADELETE
				var fct = fname.substring(1).toLowerCase();
				Object.keys(this.class.relations).forEach_(_, (_, name) => {
					traceCRUD.debug && traceCRUD.debug(instance.class.name + " " + name + "." + fct);
					status = Math.max(checkStatus(instance.get(_, name)[fct](_)));
				});
			}
			// Execute after actions before commit :
			status = execute ? Math.max(status, execute(_, "AFTER")) : status;
			this.transaction && this.transaction.commit(_);
		} catch (e) {
			status = constants.CST_AERROR;
			if (execute) {
				if (e.message !== "abort") {
					status = this.addDiagnose(_, constants.CST_AERROR, e.message);
					util.traceException(e);
				}
				if (key === undefined) {
					// No abort for AREAD
					status = execute ? Math.max(status, execute(_, "ABORT")) : status;
				}
			} else {
				// Let give an opportunity to the parent to run the ABORT event if AINSERT or AUPDATE:
				if (fname != "AREAD") throw e;
			}
			this.transaction && this.transaction.rollback(_);
		} finally {
			if (execute) glob.context.x3session._crudActions = undefined;
		}
		traceCRUD.debug && traceCRUD.debug(this.class.name + "." + fname + " status=" + status);
		return status;
	}
	read(_: _,  key: any, options?: CrudOptions) {
		const crud = options && options.crud !== undefined ? options.crud : true;
		const AREAD = (_: _, instance: Instance) => {
			return instance.class.read(_, instance, key);
		};

		return crud ? this.crud(_, 'AREAD', AREAD, key) : AREAD(_, this);
	}
	insert(_: _,  options?: CrudOptions) {
		const raw = options && options.raw !== undefined ? options.raw : false;
		const crud = options && options.crud !== undefined ? options.crud : true;

		this.getProKeys(_);

		const AINSERT = (_: _, instance: Instance) => {
			const actx = glob.context.x3session.actx;
			//TODO instance.set(_, "AUUID", tuuid.generate(), true);

			instance.set(_, "AUUID", instance.$uuid, true);
			instance.set(_, "CREUSR", actx.$USER(_), raw);

			const expnum = instance.slot(_, "EXPNUM");

			if (expnum) expnum.set(_, 8, raw); // TODO EXPNUM

			instance.set(_, "UPDUSR", "", raw);
			if (instance.get(_, "CREDATTIM").x3IsZero()) instance.set(_, "CREDATTIM", tdatetime.now(), raw);
			instance.set(_, "UPDDATTIM", tdatetime.NULL, raw);

			instance.manageSlots(_, 'insertSlot');
			const status = instance.class.insert(_, instance);

			if (status === constants.CST_AOK) instance.set(_, "UPDTICK", 1, true);
			return status;
		};

		return crud ? this.crud(_, 'AINSERT', AINSERT) : AINSERT(_, this);
	}
	update(_: _,  options?: CrudOptions) {
		const raw = options && options.raw !== undefined ? options.raw : false;
		const crud = options && options.crud !== undefined ? options.crud : true;

		this.getProKeys(_);

		const AUPDATE = (_: _, instance: Instance) => {
			const actx = glob.context.x3session.actx;

			instance.set(_, "UPDUSR", actx.$USER(_), raw);

			const expnum = instance.slot(_, "EXPNUM");

			if (expnum) expnum.set(_, 8, raw); // TODO EXPNUM

			instance.set(_, "UPDDATTIM", tdatetime.now(), raw);
			instance.manageSlots(_, 'updateSlot');
			const status = instance.class.update(_, instance);

			if (status === constants.CST_AOK) instance.incrementUpdtick(_);
			return status;
		};

		return crud ? this.crud(_, 'AUPDATE', AUPDATE) : AUPDATE(_, this);
	}
	delete(_: _,  options?: CrudOptions) {
		const raw = options && options.raw !== undefined ? options.raw : false;
		const crud = options && options.crud !== undefined ? options.crud : true;

		this.key = this.getKey(_);

		this.activeLoading && this.activeLoading(_);

		const ADELETE = (_: _, instance: Instance) => {
			// non controle for interfaces
			if (!instance.class.isInterface === true) {
				// Control blocking links :
				var tableLinks = instance.class.table.links(_);
				// control throws an exception if the instance cannot be deleted
				tableLinks && tableLinks.delete(_, instance);
			}
			instance.manageSlots(_, 'deleteSlot');

			const status = instance.class.delete(_, instance);
			//Just take into consideration errors at the first level

			return instance.transaction ? status : constants.CST_AOK;
		};

		return crud ? this.crud(_, 'ADELETE', ADELETE) : ADELETE(_, this);
	}
	x3Compare(b: any) {
		return this === b;
	}
	method(name: string) {
		return this.methods[name];
	}
	action(_: _,  action: string, key?: any, member?: any, frame?: types.Frame) {
		const newCurPth =  (p1: string, p2: string) => [p1, p2].filter(p => !!p).join('.');

		tracerEvents.debug && tracerEvents.debug("$EVENTS:" + action + " KEY:" + (key || "") + " (" + (this.meta.name + " ") + this.$$dbgId + ")");
		// Compute the arguments for the scripts :
		const dargs = this.getActionArgs(_, "AEVENT", action, key, member);

		var status = constants.CST_AOK;
		var instance = this;
		while (instance != null) {
			if (instance.runScripts) {
				status = Math.max(status, instance.runScripts(_, "$EVENTS", dargs, frame));
			}
			//if(action === "AINIT") return status;
			if (["AQUERY_TRANS_AFTER"].indexOf(action) < 0) {

				var baseCurpth = instance.proName || "";
				if (typeof dargs !== 'function') {
					// dargs.CURPTH.value = baseCurpth + (dargs.CURPTH.value ? ("." + dargs.CURPTH.value) : "");
					dargs.CURPTH.value = newCurPth(baseCurpth, dargs.CURPTH.value);
					dargs.path.unshift(instance.proJsName);
				}
			}
			instance = util.any(instance.$parent);
		}
		return status;
	}
	afterQuery(_: _) {
		return this.action(_, "AQUERY_TRANS_AFTER", null, null, glob.context.queryFrame);
	}
	onControl(_: _,  type: string, operation: DOMStringMap) {
		return util.any(this)[type](_, operation);
	}
	propagateControl(_: _,  type: string, operation: string) {
		tracerJs.debug && tracerJs.debug("propagateControl:" + [type, operation].join(','));
		const instance = this;

		var status = constants.CST_AOK;
		Object.keys(this.class.relations).forEach_(_, (_, name) => {
			status = Math.max(status, instance.get(_, name).onControl(_, type, operation));
		});
		return status;
	}
	beforeControl(_: _,  operation: string) {
		// 1. control the instance
		const status = this.actionBeforeControl(_, operation);

		if (status === constants.CST_AERROR) return status;
		// 2. control the instance
		return this.propagateControl(_, "beforeControl", operation);
	}
	propagateControlExecution(_: _,  type: string) {
		var status = constants.CST_AOK;
		if (this.class.isInterface === true) return status;
		const instance = this;

		Object.keys(this.class.relations).forEach_(_, (_, name) => {
			status = Math.max(status, instance.get(_, name).executeControl(_, type));
		});
		return status;
	}
	executeControl(_: _,  type: string) {
		const control = "executeControl" + type;
		// 1.Control the instance

		const status = util.any(this)[control] && util.any(this)[control](_, type) || constants.CST_AOK;

		tracerJs.debug && tracerJs.debug("executeControl " + type + " return=" + status);
		return status;
	}
	executeControlInsert(_: _) {
		// First control ALL mandatory fields

		var status = this.executeControl(_, "Mandatory");

		if (status === constants.CST_AERROR) return status;

		// First control ALL formats
		status = this.executeControl(_, "Format");

		if (status === constants.CST_AERROR) return status;

		// Control Others
		return this.executeControl(_, "Others");
	}
	executeControlUpdate(_: _) {
		return this.executeControlInsert(_);
	}
	executeControlDelete(_: _) {
		if (this.class.isInterface === true) return constants.CST_AOK;
		// First check that the class supports DELETE operations:
		if (!this.ADELETE) throw new util.HttpError(406, this.supervisor.loadMessParams(_, 149, 31, this.supervisor.loadMess(_, 7983, 2), this.class.data.CODCLA));

		// Control blocking links :
		const tableLinks = this.class.table.links(_);

		tracerJs.debug && tracerJs.debug("Control links on: " + this.key);
		// control throws an exception if the instance cannot be deleted
		if (tableLinks) return tableLinks.control(_, this);
		return constants.CST_AOK;
	}
	executeControlMandatory(_: _,  type: string) {
		const instance = this;

		var status = constants.CST_AOK;

		// Control mandatory fields
		Object.keys(this.slots).forEach_(_, (_, property) => {
			const slot = instance.slots[property];

			if (slot.$isMandatory) {
				// Force the GET operator (as in 4GL)
				var value = slot.get(_);
				if (slot.isUndefined) {
					tracerJs.error && tracerJs.error("Mandatory property " + property + " is undefined");
					//  Mandatory property :
					status = Math.max(status, slot.addDiagnose(_, constants.CST_AERROR, instance.supervisor.loadMess(_, 123, 10)));
				}
			}
		});
		return status === constants.CST_AERROR ? status : this.propagateControlExecution(_, type);
	}
	executeControlFormat(_: _,  type: string) {
		const instance = this;

		var status = constants.CST_AOK;

		// Control the format of properties set (slots)
		Object.keys(this.slots).forEach_(_, (_, property) => {
			const slot = instance.slots[property];

			if (slot.controlFormat) {
				// Force the GET operator (as in 4GL)
				var value = slot.get(_);
				status = Math.max(status, slot.controlFormat(_));
			}
		});
		return status === constants.CST_AERROR ? status : this.propagateControlExecution(_, type);
	}
	executeControlOthers(_: _,  type: string) {
		const instance = this;

		var status = constants.CST_AOK;

		// Temporary disable propagete:
		var propagate = this.propertyPropagateValue;
		this.propertyPropagateValue = undefined;
		try {

			// Control on all properties :
			Object.keys(this.properties).filter(property => !!this.properties[property].toControl).forEach_(_, (_, property) => {
				var slot = this.slots[property];
				if (slot) {
					if (slot.controlOthers) status = Math.max(status, slot.controlOthers(_));
					if (this.properties[property].isReference()) {
						// Add control on the reference :
						slot = this.properties[property + "_REF"].newSlot(this);
						status = Math.max(status, slot.controlOthers(_));
					}
				}
				// Send "CONTROL"
				status = Math.max(status, this.propertyControlValue(_, this.class.properties[property].newSlot(this)));
			});
			if (status === constants.CST_AERROR) return status;

			//Control the children
			status = this.propagateControlExecution(_, type);
			if (status === constants.CST_AERROR) return status;

			// Control the instance
			return this.action(_, "ACONTROL");
		} finally {
			// Restore propertyPropagateValue whatever happens
			this.propertyPropagateValue = propagate;
		}
	}
	afterControl(_: _,  operation: string) {
		// 1. children
		const status = this.propagateControl(_, "afterControl", operation);

		if (status === constants.CST_AERROR) return status;

		// 2. the instance
		return this.actionAfterControl(_, operation);
	}
	getSql(_: _,  desc: ColumnDesc) {
		// Set a default value :
		var value = desc.type.defaultValue;

		if (desc.index === null || desc.index === undefined) {
			var slot = this.slot(_, desc.name);
			if (slot) {
				if (slot instanceof SlotInstance) {
					value = slot.get(_, true);
					slot = value.slot(_, desc.name);
				}
				value = slot.getSql(_);
			}
		} else {
			Object.keys(this.class.relations).forEach_(_, (_, name) => {
				if (this.class.relations[name].class.properties[desc.name]) {
					var slot: any = this.slot(_, name);
					let collection: SlotCollection = slot;
					var position = desc.index + 1;
					if (position <= collection.x3Maxtab()) {
						var line = collection.index(_, position);
						slot = line.slot(_, desc.name);
						value = slot.getSql(_);
					}
					return;
				}
			});
		}
		//tracerJs.debug && tracerJs.debug("getField:" + property + " index:" + index + " =" + value);
		return value;
	}
	supportsTable(operation: string) {
		if (this.$aparent && this.$aparent.class.isInterface === true) return true;
		const collection = this.$parent && util.any(this.$parent).collection;
		//if (collection && !collection.mappingData) {
		if (collection && collection.ofIndexedProperties) {
			// The instance belongs to a denormalized collection :
			//traceCRUD.debug && traceCRUD.debug(instance.class.name + "doesn't support table." + operation);
			return false;
		}
		return true;
	}
	x3Type() {
		return 524;
	}
	initMaps(_: _,  collection: Collection, parent: any) {
		const defMap = (_: _, map: ClassLinkMapMeta) => {
			var value = "";
			const lVALDEFMAP = map.VALDEFMAP.toUpperCase();

			if (map.VALDEFMAP.toUpperCase().substring(0, 10) === "THIS.ACTX.") {
				value = glob.context.x3session.actx.get(_, lVALDEFMAP.substring(10));
			}
			// console.log("defMap="+value);
			return value;
		};
		const instance = this;

		if (collection.mappingData && collection.mappingData.MAPS) {
			collection.mappingData.MAPS.forEach_(_, (_, map) => {
				instance.set(_, map.KEYMAP, map.PROMAP ? parent.get(_, map.PROMAP) : defMap(_, map));
			});
		}
	}
};

export const Constructor = Instance;
export const newSlotInstance = (property: Property) => ((parent: any) => new SlotInstance(parent, property));
