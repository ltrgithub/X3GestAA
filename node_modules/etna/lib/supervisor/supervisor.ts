"use strict";

const mongodb = require('mongodb');
const glob = require('streamline-runtime').globals;
const constants = require("etna/lib/supervisor/constants");
const util = require("etna/lib/supervisor/util");
const fs = require("fs");
const fsp = require("path");
const bcd = require('etna/lib/engine/runtime/bcd');
const variables = require('etna/lib/engine/runtime/variables');
import * as ez from 'ez-streams';
const utilDriver = require("etna/lib/engine/drivers/util");
const runtime = require("etna/lib/engine/runtime/runtime");
const tracerJs = require('syracuse-core').getTracer("etna.supervisor");
const tracerDbms = require('syracuse-core').getTracer("etna.dbms");
const dbs = {};
const HttpError = util.HttpError;

function mongoConnect(_, config) {
	const mgConf = config && config.mongo || {};
	const dbName = mgConf.database || "etna";

	if (dbs[dbName]) return dbs[dbName];
	/*	var server = new mongodb.Server(mgConf.host || "localhost", mgConf.port || 27017, {});
 var db = new mongodb.Db(dbName, server, {
 	w: 1 //"majority"
 });
 dbs[dbName] = db;
 db.open(_);*/
	const dbUrl = "mongodb://" + (mgConf.connectionString || (mgConf.host || "localhost") + ":" + (mgConf.port || 27017)) + "/" + dbName;
	// console.log("dbUrl:"+dbUrl)

	const db = dbs[dbName] = mongodb.MongoClient.connect(dbUrl, mgConf.options || {
		db: {
			w: 1
		}
	}, _);

	fs.readdir(__dirname + "/meta", _).forEach_(_, (_, name) => {
		const sub = require(__dirname + "/meta/" + name);

		if (sub.keyName) {
			var index = {};
			index[sub.keyName] = 1;
			db.collection(sub.collectionName, _).ensureIndex(index, {
				background: true
			}, _);
		}
	});
	return db;
}

function loadErrorMessages(_, mongo, lan) {
	const found = {}; // we are getting duplicates - eliminate for now. Investigate later why.

	const mess = mongo.collection('APLSTD', _).find({
		LAN: lan,
		LANCHP: 9014
	}).sort({
		LANCHP: 1,
		LANNUM: 1
	}).toArray(_).filter(m => {
		const ok = m.LANNUM && !found[m.LANNUM];

		found[m.LANNUM] = true;
		return ok;
	}).map(m => m.LANMES);

	mess.unshift("Message 0");
	return mess;
}

const x3Modules = {
	system: Object.keys(require('../x3js/system-enums').Module).map(k => k ? k[0].toLowerCase() + k.substring(1) : 'unknown'),
	erp: [/* see later*/],
	hrm: [/* see later*/]
};

const supervisors = {};

export function create(_, config) {
	return supervisors[config.endpointName] || (supervisors[config.endpointName] = create(_, config));
}
	
function create(_, config) {
	const mongoStore = mongoConnect(_, config);
	const cache = {
		LAN: {
			//ATEXTE: {},
			//APLSTD: {},
		}
	};
	const subModules = exports.subModules = {};
	const trim = utilDriver.trim;

	function executeSql(_, sql, args, opts) {
		//if (!/^select /.test(sql) && !conf.etnaSqlStore.writable) throw new Error("cannot modify: SQL store is read-only");
		//tracerDbms.debug && tracerDbms.debug("executeSql*: " + sql + ", args=" + args);

		const sqlargs = utilDriver.toSql(args || [], sqlDriver);
		const result = sqlDriver.execute(_, glob.context.x3session.dbConnection, sql, sqlargs, opts);

		if (opts && opts.typesmap) {
			var maptrim = utilDriver.maptrim(sqlDriver, opts.typesmap, opts.dispatch);

			return Array.isArray(result) ? result.map_(_, maptrim) : result;
		} else return Array.isArray(result) ? result.map(trim) : result;
	}

	function sqlReader(_, sql, args, opts) {
		opts = opts || {};
		tracerDbms.debug && tracerDbms.debug("sqlReader: " + sql + ", args=" + args);
		//if (!/^select /.test(sql) && !conf.etnaSqlStore.writable) throw new Error("cannot modify: SQL store is read-only");

		const maptrim = opts.typesmap ? utilDriver.maptrim(sqlDriver, opts.typesmap, opts.dispatch) : trim;
		const ftrim = function (_, record) {
			return opts.typesmap ? maptrim(_, record) : trim(record);
		};
		//debugger;

		return sqlDriver.reader(_, glob.context.x3session.dbConnection, sql, args || [], opts).map(ftrim);
	}

	function subModule(className) {
		return subModules[className] || (subModules[className] = require(__dirname + '/meta/' + className[0].toLowerCase() + className.slice(1)));
	}

	function compile(superv, source, name, filename) {
		const fn = new Function("module", "exports", "requireScript", "require", "'use strict';" + source);
		const module = {
			id: name,
			filename: filename,
			exports: {}
		};

		function req(_, name) {
			return superv.loadScript(_, name);
		}
		try {
			fn(module, module.exports, req, require);
		} catch (ex) {
			throw new Error(filename + ": module initialization failed: " + ex.stack.split('\n').slice(0, 2).join(': '));
		}
		return module.exports;
	}

	function _messSearch(chap, num) {
		var min = 0;
		var max = chap.length - 1;
		var cur;
		var cval;

		while (min <= max) {
			cur = min + max >> 1;
			cval = chap[cur].$value;

			if (cval < num) {
				min = cur + 1;
			} else if (cval > num) {
				max = cur - 1;
			} else {
				return chap[cur].$title;
			}
		}
		return "";
	}

	const sqlDriver = require('etna/lib/engine/drivers/' + config.sql.driver)(config.sql);
	const superv = {
		// for now
		baseUrl: "http://localhost:8124" + "/sdata/x3/erp/" + config.endpointName,
		transUrl: "/trans/x3/erp/" + config.endpointName,
		collaborationUrl: "/sdata/syracuse/collaboration/syracuse",
		solutionName: config.solutionName,
		solutionPath: config.solutionPath,
		endpointName: config.endpointName,
		folderName: config.folderName,
		sqlDriver: sqlDriver,
		executeSql: executeSql,
		sqlReader: sqlReader,
		engineErrMess: loadErrorMessages(_, mongoStore, "FRA"),
		mongoStore: mongoStore,
		constants: constants,
		classesByJsName: {},
		directories: {
			jsShared: config.solutionPath + "/" + config.folderName + '/x3-erp',
			jsLocal: null
		},
		product: 'system', // for now

		new(_, className) {
			//dbg:console.log("new "+className)
			const cl = subModule(className).Constructor;
			//dbg:console.log("new cl:"+!!cl)

			const args = [cl, superv].concat(Array.prototype.slice.call(arguments, 2));
			//dbg:console.log("new new")

			return new (cl.bind.apply(cl, args))().init(_);
		},
		cacheMeta(className, keyValue, instance) {
			const loader = subModule(className);
			const instances = cache[loader.collectionName] = cache[loader.collectionName] || {};

			instances[keyValue] = instance;
		},
		load(_, className, keyValue, dataChildren) {
			//dbg:console.log("load:"+className+" "+keyValue);

			const loader = subModule(className);
			const instances = cache[loader.collectionName] = cache[loader.collectionName] || {};

			var instance = instances[keyValue];

			var data, keys, relPath;
			if (keyValue !== undefined) {
				var filter = {};
				if (keyValue.indexOf('_') >= 0) {
					// Special case for 4GL scripts:
					keys = keyValue.split("_");
					filter[loader.keyName] = keys[0];
					relPath = keys.slice(1);
				} else {
					keys = keyValue.split(".");
					filter[loader.keyName] = keys[keys.length - 1];
				}
				data = mongoStore.collection(loader.collectionName, _).find(filter).toArray(_)[0];
			}

			if (instance && data && data._etag && instance._etag && data._etag === instance._etag) return instance;

			if (!data && className === 'Class') {
				var script = this.loadBuiltin(_, keyValue);
				if (script && script.Constructor) {
					instance = new script.Constructor(superv);
					// shouldn't we cache exported???
					if (instance.$exported) return instance.init(_);
					else instance = undefined;
				}
			}
			if (data) {
				data.dataChildren = dataChildren;
				var ctor = loader.getConstructor ? loader.getConstructor(data) : loader.Constructor;
				instance = new ctor(superv, data);
				instance._etag = data._etag;
				instances[keyValue] = instance; // to avoid infinite recursion in init
				instance.init(_);
				//dbg:console.log("load:"+className+" ("+keyValue+") :"+!!instance);
				if (relPath) {
					for (var i = 0; i < relPath.length; i++) {
						var relation = instance.relations[relPath[i]];
						if (!relation) throw new X3Error(26, "invalid class name: " + keyValue);
						instance = relation.class;
					}
				}
			}
			return instances[keyValue] = instance;
		},
		defineClass(_, def) {
			const key = def.module + '.' + def.name;
			if (this.classesByJsName[key]) return this.classesByJsName[key];
			const data = require('../x3js/class-meta').loadData(_, this, def);
			//console.error("DEFINECLASS", data);
			def.jsName = key;
			const clas = this.new(_, 'Class', data);
			if (def.CODCLA) this.cacheMeta('Class', def.CODCLA, clas);
			clas.jsModules.push(def);
			this.classesByJsName[key] = clas;
			return clas;
		},
		/*
		loadClassByJsName(_, jsName) {
			if (this.classesByJsName[jsName]) return this.classesByJsName[jsName];
			const script = this.loadJsScript(_, 'classes', jsName);
			//console.error("LOADCLASSBYJSNAME: ", jsName, script && script.default.dictCode);
			if (!script) throw new Error(`class ${ jsName } not found`);
			var clas;
			if (script.default.dictCode) {
				clas = this.load(_, 'Class', script.default.dictCode);
				clas.fixJsNames(_, script.default);
			} else {
				const data = require('../x3js/class-meta').loadData(_, this, script.default);
				//console.error("LOADCLASSBYJSNAME", data);
				data.jsName = jsName;
				clas = this.new(_, 'Class', data);
				this.cacheMeta('Class', data.CODCLA, clas);
			}
			clas.jsModules.push(script.default);
			this.classesByJsName[jsName] = clas;
			return clas;
		},
		*/
		reader(_, className, filter) {
			const loader = subModule(className);
			const coln = mongoStore.collection(loader.collectionName, _).find(filter || {});

			return ez.devices.generic.reader(_ => {
				while (true) {
					var data = coln.nextObject(_);
					if (!data) return undefined;
					try {
						return new loader.Constructor(superv, data).init(_);
					} catch (ex) {
						// ignore it but print error
						console.error(ex.stack);
					}
				}
			});
		},
		loadText(_, num, lan) {
			lan = lan || glob.context.x3session.actx.$LAN(_);
			const s = cache.LAN[lan] !== undefined ? cache.LAN[lan].ATEXTE[num] : undefined;

			if (s !== undefined) return s;

			mongoStore.collection('ATEXTE', _).ensureIndex({
				LAN: 1,
				TEXTE: 1
			}, {
				background: true
			}, _);

			const data = mongoStore.collection('ATEXTE', _).find({
				LAN: lan,
				NUMERO: num
			}).toArray(_)[0];

			if (cache.LAN[lan] === undefined) cache.LAN[lan] = {
				ATEXTE: {},
				APLSTD: {}
			};
			return cache.LAN[lan].ATEXTE[num] = data ? data.TEXTE : "TEXT_" + num;
		},
		findText(_, text, lan) {
			lan = lan || glob.context.x3session.actx.$LAN(_);
			const data = mongoStore.collection('ATEXTE', _).find({
				LAN: lan,
				TEXTE: text
			}).toArray(_)[0];

			if (data) {
				// Save it in the cache:
				if (cache.LAN[lan] === undefined) cache.LAN[lan] = {
					ATEXTE: {},
					APLSTD: {}
				};
				cache.LAN[lan].ATEXTE[data.NUMERO] = data.TEXTE;
				return data.NUMERO;
			}
			return 0;
		},
		loadEnum(_, lib, lan) {
			lan = lan || (glob.context.x3session.actx ? glob.context.x3session.actx.$LAN(_) : "ENG");
			var menu = cache.LAN[lan] !== undefined ? cache.LAN[lan].APLSTD[lib] : undefined;

			if (menu !== undefined) return menu;
			const found = {}; // we are getting duplicates - eliminate for now. Investigate later why.

			menu = mongoStore.collection('APLSTD', _).find({
				LAN: lan,
				LANCHP: lib
			}).sort({
				LANCHP: 1,
				LANNUM: 1
			}).toArray(_).filter(m => {
				const ok = m.LANNUM && !found[m.LANNUM];

				found[m.LANNUM] = true;
				return ok;
			}).map(m => {
				return {
					$value: m.LANNUM,
					$title: m.LANMES
				};
			});

			if (cache.LAN[lan] === undefined) cache.LAN[lan] = {
				ATEXTE: {},
				APLSTD: {}
			};
			return cache.LAN[lan].APLSTD[lib] = menu;
		},
		loadMess(_, lib, num, lan) {
			const list = this.loadEnum(_, lib, lan);

			if (list !== undefined) return _messSearch(list, num);
			return "";
		},
		loadMessParams(_, lib, num) {
			var mess = this.loadMess(_, lib, num);
			if (mess !== "") {
				var args = Array.prototype.slice.call(arguments);
				mess = mess.replace(/\$[\w~]\$/g,  str => args[parseInt(str.replace(/\$/g, '')) + 2]);
			}
			return mess;
		},
		fillTypeNode(_, data, node) {
			return subModule('Type').fillTypeNode(_, superv, data, node);
		},
		razCacheScripts(_) {
			cache.scripts = undefined;
		},
		loadBuiltins(_, name) {
			if (cache.scripts === undefined) {
				if (cache.scriptBuitins === undefined) {
					cache.scriptBuitins = {};
					tracerJs.debug && tracerJs.debug("load Builtins");
					fs.readdir(__dirname + '/builtins', _).forEach(name => {
						if (/\.ts$/.test(name)) {
							name = name.substring(0, name.length - 3);
							var script = require('etna/lib/supervisor/builtins/' + name);
							// set name on all entry points
							tracerJs.debug && tracerJs.debug("load Builtin:" + name);
							script.$isBuiltin = true;
							script.$name = name;
							/*							Object.keys(script).forEach(name => {
       	script[name].name = name;
       });*/
							cache.scriptBuitins[name] = script;
						}
					});
				}
				cache.scripts = Object.keys(cache.scriptBuitins).reduce((r, name) => {
					const v = cache.scriptBuitins[name];

					r[name] = v;
					return r;
				}, {});;
			}
		},
		loadBuiltin(_, name) {
			this.loadBuiltins(_);
			return cache.scriptBuitins[name];
		},
		loadJsEnum(_, name, chapter) {
			if (name) {
				const script = this.loadJsScript(_, 'enums', name);
				if (!script) throw new Error(`enum ${ name } not found`);
				if (!script.default.values) throw new Error(`enum ${ name }: script does not define values`);
				return script.default;
			} else {
				console.warn(`enum chapter ${ chapter }: JavaScript mapping not available`);
			}
		},
		findJsScript(_, subdir, jsName, canCreate) {
			const segs = jsName.split('.');
			segs.splice(segs.length - 1, 0, subdir);
			const path = segs.map(s => util.camelToKebab(s)).join(fsp.sep);
			var file = null;
			const tryX3js = (_, path) => {
				//console.error("TRYING", path);
				return this.api && (canCreate || fs.exists(path, _, _)) ? path : null;
			};
			if (superv.directories.jsLocal) file = tryX3js(_, fsp.join(superv.directories.jsLocal, path + '.x3js'));
			//if (!file && typeof QUnit !== 'undefined')
			//	file = tryX3js(_, fsp.join(__dirname, '../../test/x3js/fixtures', path + ".x3js"));
			if (!file) file = tryX3js(_, fsp.join(superv.directories.jsShared, path + '.x3js'));
			return file;
		},
		jsPath(mod, jsName) {
			return this.moduleName(mod) + '.' + jsName;
		},
		moduleName(mod) {
			return x3Modules[this.product][mod];
		},
		/*
		loadJsScript(_, subdir, jsName) {
			const path = this.findJsScript(_, subdir, jsName);
			if (!path) return null;
			const script = require(path);
			if (script && !script.default) throw new Error(`script ${ subdir }.${ jsName } does not export default`);
			return script;
		},
		// we use this one for enums and messages
		loadJsScriptSync(subdir, jsName) {
			const segs = jsName.split('.');
			segs.splice(segs.length - 1, 0, subdir);
			const path = segs.map(s => util.camelToKebab(s)).join(fsp.sep);
			var script = null;
			const tryX3js = path => {
				//console.error("TRYING", path);
				if (this.api && fs.existsSync(path)) {
					var script = require(path);
					return script;
				} else {
					return null;
				}
			};
			console.error("loadJsScriptSync", path);
			if (superv.directories.jsLocal) script = tryX3js(fsp.join(superv.directories.jsLocal, path + '.x3js'));
			//if (!script)
			//	script = tryX3js(fsp.join(__dirname, '../../test/x3js/fixtures', path + ".x3js"));
			if (!script) script = tryX3js(fsp.join(superv.directories.jsShared, path + '.x3js'));
			if (script && !script.default) throw new Error(`script ${ subdir }.${ jsName } does not export default`);
			return script;
		},
		*/
		loadScript(_, name, clas) {
			this.loadBuiltins(_);
			var script = cache.scripts[name];
			if (!script) {
				// for now, hardcode product name to 'superv' -- see later how we can get it from db.
				/*
				if (name.indexOf(':') >= 0) {
					const [sub, jsName] = name.split(':');
					script = this.loadJsScript(_, sub, jsName);
					if (clas) {
						clas.jsModules.push(script.default);
						clas.fixJsNames(_, script.default);
					}
				} else {*/
					const path = fsp.join(config.solutionPath, config.folderName, "TRT", name + ".src");
					tracerJs.debug && tracerJs.debug("Loading script: " + path);
					const source = fs.readFile(path, "utf8", _);
					const parsed = new (require("etna/lib/engine/parser").Parser)(source, path).parse();
					const transformed = require("etna/lib/engine/jsgen").generate(parsed.node, path);
					script = compile(superv, transformed, name, path);
					script.$4gl = true;
					//fs.writeFile("C:\\"+name+"sc.js", transformed, "utf8", _); // for debugging
				/*}*/
				cache.scripts[name] = script;
				//tracerJs.debug && tracerJs.debug(script);
			}
			return script;
		},
		loadScripts(_, clas) {
			if (clas.data.CODTRT) {
				clas._scripts = clas.data.CODTRT.map_(_, (_, codtrt) => {
					return {
						name: codtrt,
						body: this.loadScript(_, codtrt, clas)
					};
				});
			} else {
				clas._scripts = [];
			}
			return clas._scripts;
		},
		loadScriptBase(_, wscript, name) {
			//fs.writeFile("C:\\" + name + "sc.js", wscript, "utf8", _); // for debugging
			const parsed = new (require("etna/lib/engine/parser").Parser)(wscript, "").parse();
			const transformed = require("etna/lib/engine/jsgen").generate(parsed.node, "");
			//fs.writeFile("C:\\" + "name" + "sc.js", transformed, "utf8", _); // for debugging

			const script = compile(superv, transformed, name, "");
			//tracerJs.debug && tracerJs.debug(script);

			return script;
		},
		newInstance(_, className) {
			const cl = this.load(_, 'Class', className);

			return cl.createInstance(_);
		},
		about(_) {
			return {
				solutionName: config.solutionName,
				solutionHttpUrl: "TODO", //http://aws-x3-devsup.sagefr.adinternal.com:80/Adonix_SUPDVLP,
				processServer: "TODO", //AWS-X3-DEVSUP.sagefr.adinternal.com,
				applicationServer: "", //AWS-X3-DEVSUP.sagefr.adinternal.com,
				folder: config.folderName,
				port: "TODO",
				x3Version: "TODO",
				supervisorVersion: "TODO",
				runtimeVersion: "TODO",
				x3Release: "TODO",
				patchNumber: "TODO"
			};
		},
		moduleCode(name) {
			const i = x3Modules[this.product].indexOf(name);
			if (i < 0) throw new Error("bad module name: " + name);
			return i;
		},
		languages(_) {
			if (!this._languages) {
				var columns = new Array(20);
				for (var i = 0; i < columns.length; i++) columns[i] = "LAN_" + i;

				this._languages = this.sqlReader(_, "select " + columns.join(',') + " from ADOSSIER where (DOSSIER_0=" + this.sqlDriver.param(0) + ")", [this.folderName]).limit(1).toArray(_).reduce_(_, (_, r, record) => {
					for (var i = 0; i < record.LAN.length; i++) {
						var tablan = this.newInstance(_, "TABLAN");
						var status = tablan.read(_, record.LAN[i]);
						if (status !== constants.CST_AERROR) {
							r[record.LAN[i]] = tablan;
						}
					}
					return r;
				}, {});
			}
			return this._languages;
		},
		loadFolderCache(_) {
			var data;
			if (!this.folderCacheEtag) {
				data = this.sqlReader(_, "Select A.VALEUR_0 From ADOVAL A where A.CMP_0=' ' and A.FCY_0=' ' and A.PARAM_0='FOLDERETAG'").toArray(_);
				if (data[0] && data[0].VALEUR > "") {
					this.folderCacheEtag = data[0].VALEUR;
				}
				this.folderCacheEtag = this.folderCacheEtag || "etag";
			}
			data = this.mongoStore.collection('X3FoldersCache', _).find({ folderName: this.folderName }).toArray(_)[0];

			if (data && data.etag === this.folderCacheEtag) {
				tracerJs.debug && tracerJs.debug("find in mongo folder: " + this.folderName + "  " + data.etag);
				return this.folderCache = data.folder;
			}
			return {};
		},
		updateFolderCache(_, folder) {
			const col = this.mongoStore.createCollection('X3FoldersCache', _);

			this.mongoStore.collection('X3FoldersCache', _).ensureIndex({
				folderName: 1
			}, {
				background: true
			}, _);

			const cache = { folderName: {} };

			cache.folderName = this.folderName;
			cache.etag = this.folderCacheEtag;
			cache.folder = folder;

			const filter = {};

			filter["folderName"] = this.efolderName;
			const r = this.mongoStore.collection("X3FoldersCache", _).update({
				folderName: this.folderName
			}, cache, {
				upsert: true
			}, _);
		},
		initSysVar(_, actx) {
			if (this.sys && this.sys.ADXTUL) return;

			const values = {
				ADXTUL: [],
				ADXTUC0: [],
				ADXTUT0: [],
				ADXTUC: [],
				ADXTUT: []
			};
			const folder = this.loadFolderCache(_);

			if (folder.sys && folder.sys.ADXTUL) {
				// Load sys from mongodb
				this.sys = Object.keys(values).reduce((r, v) => {
					r[v] = folder.sys[v];
					return r;
				}, {});
				return; // sys loaded from mongodb
			}

			// Compute sys
			const parameters = [];

			for (var i = 1; i <= 30; i++) {
				parameters.push("TUL" + ("00" + i).slice(-2));
			}
			// Use the contexte to load parameters:
			const tuls = actx.$APARAM(_)._getParams(_, 1, this.folderName, parameters, "AUTO");

			Object.keys(tuls).forEach(tul => {
				if (tuls[tul].value) {
					var arTUL = tuls[tul].value.split(":");
					if (arTUL !== undefined && arTUL.length === 2) {
						var tul = arTUL[0][0];
						values.ADXTUL.push(tul);
						values.ADXTUT0.push(arTUL[0].substring(1));
						values.ADXTUT.push(arTUL[0].substring(1));
						values.ADXTUC0.push(arTUL[1]);
						values.ADXTUC.push(arTUL[1]);
					}
				}
			});
			for (var i = 0; i < values.ADXTUT.length; i++) {
				var j = values.ADXTUL.indexOf(values.ADXTUT[i]);
				if (j >= 0) {
					values.ADXTUC[i] = values.ADXTUC[j];
					values.ADXTUT[i] = values.ADXTUT[j];
				}
			}
			folder.sys = {};
			this.sys = Object.keys(values).reduce((r, v) => {
				r[v] = [1, variables.types["S"].def, values[v], 0, values[v].length];
				folder.sys[v] = r[v];
				return r;
			}, {});
			// Update the cache:
			this.updateFolderCache(_, folder);
			// Save sys variables in the cache
		},
		$ADONIX(_, actx) {
			const folder = this.loadFolderCache(_);

			if (folder.adonix) return folder.adonix;
			folder.adonix = actx.$APARAM(_).AGETVALNUM(_, 1, this.folderName, "ADONIX");
			// Update the cache:
			this.updateFolderCache(_, folder);
			return folder.adonix;
		},
		$LANDEF(_) {
			const folder = this.loadFolderCache(_);

			if (!folder.landef) {
				var param = this.sqlDriver.param;
				var rAdossier = this.sqlReader(_, "select LANDEF_0 from ADOSSIER where (DOSSIER_0=" + param(0) + ")", [this.folderName]).limit(1).toArray(_);
				folder.landef = rAdossier[0].LANDEF;
				this.updateFolderCache(_, folder);
			}
			return folder.landef;
		},
		$LEGISLATIONS(_, actx) {
			const folder = this.loadFolderCache(_);

			if (folder.legislations) return folder.legislations;
			folder.legislations = actx.$APARAM(_).AGETVALCHAR(_, 1, this.folderName, "DOSLEG");
			// Update the cache:
			this.updateFolderCache(_, folder);
			return folder.legislations;
		},
		release(_) {
			this.sqlDriver && this.sqlDriver.release(_);
		}
	};
	const types = mongoStore.collection('ATYPE', _).find({
		TYPTYP: 7
	}).toArray(_);

	for (var i = 0, len = types.length; i < len; i++) {
		if (types[i].LNGTYP && typeof types[i].LNGTYP === 'string') {
			if (!isNaN(types[i].LNGTYP) && bcd.toDouble(bcd.fromString(types[i].LNGTYP)) > 0) types[i].LNGTYP = bcd.toDouble(bcd.fromString(types[i].LNGTYP));
			else delete types[i].LNGTYP;
		}
		superv.constants["GLON" + types[i].CODTYP] = types[i].LNGTYP || 250;
	}

	function mkdirp(_, path) {
		if (!fs.exists(path, _, _)) {
			mkdirp(_, fsp.join(path, '..'));
			fs.mkdir(path, _);
		}
	}

	function _createLocalFolder(_) {
		const globConfig = require('config');
		const root = globConfig.etna && globConfig.etna.localRoot;
		if (!root) return;
		if (!superv.solutionName) throw new Error("solution name is missing");
		if (!superv.folderName) throw new Error("folder name is missing");
		superv.directories.jsLocal = fsp.join(root, superv.solutionName, 'folders', superv.folderName, 'x3-erp');
		mkdirp(_, superv.directories.jsLocal);
	}

	_createLocalFolder(_);

	superv.api = require('etna/lib/x3js/folder').create(_, superv);
	return superv;
};