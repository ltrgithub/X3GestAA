(Error as any).stackTraceLimit = 100;
import { _ } from 'streamline-runtime';
import * as core from 'syracuse-core';
import * as mongodb from 'mongodb';
import { Driver, Record, SqlReaderOptions, SqlQueryOptions } from '../engine/drivers/types';
import { NodeProto } from './protocol/prototype';
import { Dict, Prog, SysValues } from '../engine/runtime/types';
import * as constants from './constants';
import * as util from './util';
import * as fs from 'fs';
import * as fsp from 'path';
import * as bcd from '../engine/runtime/bcd';
import * as  variables from '../engine/runtime/variables';
import * as ez from 'ez-streams';
import * as utilDriver from '../engine/drivers/util';
import * as runtime  from '../engine/runtime/runtime';
import { X3Error } from '../engine/runtime/errors';
import { BaseClass, Class } from './meta/types';
import { Instance } from './dyn/types';
import { ClassDef } from '../x3js/class-proxy';

const tracerJs = core.getTracer("etna.supervisor");
const tracerDbms = core.getTracer("etna.dbms");
const HttpError = util.HttpError;

export interface MongoConfig {
	database?: string;
	connectionString? : string;
	host?: string;
	port?: number;
	options?: mongodb.MongoClientOptions;
}

export interface SqlConfig {
	driver: string;
}

export interface Config {
	mongo?: MongoConfig;
	solutionName?: string;
	solutionPath?: string;
	endpointName?: string;
	folderName?: string;
	sql?: SqlConfig;
}

interface TABLAN extends Instance {
	LAN?: string;
}

interface ACTX {
	$APARAM(_: _): any; // refine later
}

const dbs: { [name: string]: mongodb.Db } = {};

function mongoConnect(_: _, config: Config) {
	const mgConf = config && config.mongo || {};
	const dbName = mgConf.database || "etna";

	if (dbs[dbName]) return dbs[dbName];
	/*	var server = new mongodb.Server(mgConf.host || "localhost", mgConf.port || 27017, {});
 var db = new mongodb.Db(dbName, server, {
 	w: 1 //"majority"
 });
 dbs[dbName] = db;
 db.open(_);*/
	const dbUrl = "mongodb://" + (mgConf.connectionString || (mgConf.host || "localhost") + ":" + (mgConf.port || 27017)) + "/" + dbName;
	// console.log("dbUrl:"+dbUrl)

	const db = dbs[dbName] = mongodb.MongoClient.connect(dbUrl, mgConf.options || {
		db: {
			w: 1
		}
	}).then(_, _);

	fs.readdir(__dirname + "/meta", _).forEach_(_, (_, name) => {
		const sub = require(__dirname + "/meta/" + name);

		if (sub.keyName) {
			var index: any = {};
			index[sub.keyName] = 1;
			db.collection(sub.collectionName).createIndex(index, {
				background: true
			});
		}
	});
	return db;
}

export interface EnumData {
	LANCHP: number;
	LANNUM: number;
	LAN: string;
	LANMES: string;
}
function loadErrorMessages(_: _, mongo: mongodb.Db, lan: string) {
	const found: { [name: string]: boolean } = {}; // we are getting duplicates - eliminate for now. Investigate later why.

	const mess = mongo.collection('APLSTD').find({
		LAN: lan,
		LANCHP: 9014
	}).sort({
		LANCHP: 1,
		LANNUM: 1
	}).toArray().then(_, _).filter((m: EnumData) => {
		const ok = m.LANNUM && !found[m.LANNUM];

		found[m.LANNUM] = true;
		return ok;
	}).map((m: EnumData) => m.LANMES);

	mess.unshift("Message 0");
	return mess;
}

const x3Modules = {
	system: Object.keys(require('../x3js/system-enums').Module).map(k => k ? k[0].toLowerCase() + k.substring(1) : 'unknown'),
	erp: [/* see later*/] as any[],
	hrm: [/* see later*/] as any[],
};

export const subModules: { [name: string]: any } = {};

function subModule(className: string) {
	try {
		return subModules[className] || (subModules[className] = require(__dirname + '/meta/' + className[0].toLowerCase() + className.slice(1)));
	} catch (ex) {
		if (ex.code === 'MODULE_NOT_FOUND') {
			// TODO: dyn objects should be instantiated directly
			return subModules[className] || (subModules[className] = require(__dirname + '/dyn/' + className[0].toLowerCase() + className.slice(1)));		
		} else {
			throw ex;
		}
	}
}

function compile(superv: Supervisor, source: string, name: string, filename: string): any {
	const fn = new Function("module", "exports", "requireScript", "require", "'use strict';" + source);
	const module = {
		id: name,
		filename: filename,
		exports: {}
	};

	function req(_: _, name: string) {
		return superv.loadScript(_, name);
	}
	try {
		fn(module, module.exports, req, require);
	} catch (ex) {
		throw new Error(filename + ": module initialization failed: " + ex.stack.split('\n').slice(0, 2).join(': '));
	}
	return module.exports;
}

export interface Message {
	$value: number;
	$title: string;
}

function _messSearch(chap: Message[], num: number) {
	var min = 0;
	var max = chap.length - 1;

	while (min <= max) {
		var cur = min + max >> 1;
		var cval = chap[cur].$value;

		if (cval < num) {
			min = cur + 1;
		} else if (cval > num) {
			max = cur - 1;
		} else {
			return chap[cur].$title;
		}
	}
	return "";
}

const supervisors: { [name: string]: Supervisor } = {};

export function create(_: _, config: Config) {
	return supervisors[config.endpointName] || (supervisors[config.endpointName] = new Supervisor(_, config));
}

export interface Directories {
	jsShared: string;
	jsLocal: string;
}

export interface Cache {
	LAN: { [key: string]: any; };
	scripts: { [key: string]: any; };
	scriptBuiltins: { [key: string]: any; };
	[key: string]: any;
}
export class Supervisor {
	baseUrl: string;
	transUrl: string;
	collaborationUrl: string;
	solutionName: string;
	solutionPath: string;
	endpointName: string;
	folderName: string;
	sqlDriver: Driver;
	engineErrMess: string[];
	mongoStore: mongodb.Db;
	constants: {
		CST_AOK?: number;
		CST_AERROR?: number;
		[name: string]: number;
	};
	classesByJsName: { [name: string]: Class };
	directories: Directories;
	product: string;
	api: any;
	cache: Cache;
	_languages: { [lan: string]: TABLAN };
	folderCacheEtag: string;
	folderCache: any;
	sys: SysValues;

	constructor(_: _, config: Config) {
		this.baseUrl = "http://localhost:8124" + "/sdata/x3/erp/" + config.endpointName;
		this.transUrl = "/trans/x3/erp/" + config.endpointName;
		this.collaborationUrl = "/sdata/syracuse/collaboration/syracuse";
		this.solutionName = config.solutionName;
		this.solutionPath = config.solutionPath;
		this.endpointName = config.endpointName;
		this.folderName=  config.folderName;
		this.classesByJsName = {};
		this.cache = {
			LAN: {},
			scripts: null,
			scriptBuiltins: null,
			instances: {},
		};
		this.directories = {
			jsShared: config.solutionPath + "/" + config.folderName + '/x3-erp',
			jsLocal: null
		};
		this.product = 'system'; // for now
		
		this.mongoStore = mongoConnect(_, config);
		const cache = {
			LAN: {
				//ATEXTE: {},
				//APLSTD: {},
			}
		};
		this.engineErrMess = loadErrorMessages(_, this.mongoStore, "FRA");
		this.sqlDriver = require('etna/lib/engine/drivers/' + config.sql.driver)(config.sql);

		const types = this.mongoStore.collection('ATYPE').find({
			TYPTYP: 7
		}).toArray().then(_, _);

		this.constants = Object.assign({} as Dict<any>, constants);
		for (var i = 0, len = types.length; i < len; i++) {
			if (types[i].LNGTYP && typeof types[i].LNGTYP === 'string') {
				if (!isNaN(types[i].LNGTYP) && bcd.toDouble(bcd.fromString(types[i].LNGTYP)) > 0) types[i].LNGTYP = bcd.toDouble(bcd.fromString(types[i].LNGTYP));
				else delete types[i].LNGTYP;
			}
			this.constants["GLON" + types[i].CODTYP] = types[i].LNGTYP || 250;
		}

		function mkdirp(_: _, path: string) {
			if (!fs.exists(path, _, _)) {
				mkdirp(_, fsp.join(path, '..'));
				fs.mkdir(path, _);
			}
		}

		function _createLocalFolder(_: _) {
			const globConfig = require('config');
			const root = globConfig.etna && globConfig.etna.localRoot;
			if (!root) return;
			if (!this.solutionName) throw new Error("solution name is missing");
			if (!this.folderName) throw new Error("folder name is missing");
			this.directories.jsLocal = fsp.join(root, this.solutionName, 'folders', this.folderName, 'x3-erp');
			mkdirp(_, this.directories.jsLocal);
		}

		_createLocalFolder(_);

		this.api = require('etna/lib/x3js/folder').create(_, this);
	}

	executeSql(_: _, sql: string, args?: any[], opts?: SqlQueryOptions) {
		//if (!/^select /.test(sql) && !conf.etnaSqlStore.writable) throw new Error("cannot modify: SQL store is read-only");
		//tracerDbms.debug && tracerDbms.debug("executeSql*: " + sql + ", args=" + args);

		const sqlargs = utilDriver.toSql(args || [], this.sqlDriver);
		const result = this.sqlDriver.execute(_, util.currentContext().x3session.dbConnection, sql, sqlargs, opts);

		if (opts && opts.typesmap) {
			var maptrim = utilDriver.maptrim(this.sqlDriver, opts.typesmap, opts.dispatch);

			return Array.isArray(result) ? result.map_(_, maptrim) : result;
		} else return Array.isArray(result) ? result.map(utilDriver.trim) : result;
	}

	sqlReader<T>(_: _, sql: string, args?: any[], opts?: SqlReaderOptions): ez.Reader<T> {
		opts = opts || {};
		tracerDbms.debug && tracerDbms.debug("sqlReader: " + sql + ", args=" + args);
		//if (!/^select /.test(sql) && !conf.etnaSqlStore.writable) throw new Error("cannot modify: SQL store is read-only");
		const maptrim = opts.typesmap ? utilDriver.maptrim<Record, T>(this.sqlDriver, opts.typesmap, opts.dispatch) : 
			(_: _, record: Record) => utilDriver.trim<Record, T>(record);
		//debugger;

		return this.sqlDriver.reader(_, util.currentContext().x3session.dbConnection, sql, args || [], opts).map(maptrim);
	}

	new<T>(_: _, className: string, ...args: any[]): T {
		//dbg:console.log("new "+className)
		const cl = subModule(className).Constructor;
		//dbg:console.log("new cl:"+!!cl)

		args = [cl, this].concat(Array.prototype.slice.call(arguments, 2));
		//dbg:console.log("new new")

		return new (cl.bind.apply(cl, args))().init(_);
	}
	cacheMeta(className: string, keyValue: string, instance: any) {
		const loader = subModule(className);
		const instances = this.cache[loader.collectionName] = this.cache[loader.collectionName] || {};

		instances[keyValue] = instance;
	}
	load<T>(_: _, className: string, keyValue: string, dataChildren?: any): T {
		//dbg:console.log("load:"+className+" "+keyValue);

		const loader = subModule(className);
		const instances = this.cache[loader.collectionName] = this.cache[loader.collectionName] || {};

		var instance = instances[keyValue];

		var data: any, keys: string[], relPath: string[];
		if (keyValue !== undefined) {
			var filter: { [name: string]: string } = {};
			if (keyValue.indexOf('_') >= 0) {
				// Special case for 4GL scripts:
				keys = keyValue.split("_");
				filter[loader.keyName] = keys[0];
				relPath = keys.slice(1);
			} else {
				keys = keyValue.split(".");
				filter[loader.keyName] = keys[keys.length - 1];
			}
			data = this.mongoStore.collection(loader.collectionName).find(filter).toArray().then(_, _)[0];
		}

		if (instance && data && data._etag && instance._etag && data._etag === instance._etag) return instance;

		if (!data && className === 'Class') {
			var script = this.loadBuiltin(_, keyValue);
			if (script && script[keyValue]) {
				instance = new script[keyValue](this);
				// shouldn't we cache exported???
				if (instance.$exported) return instance.init(_);
				else instance = undefined;
			}
		}
		if (data) {
			data.dataChildren = dataChildren;
			var ctor = loader.getConstructor ? loader.getConstructor(data) : loader.Constructor;
			instance = new ctor(this, data);
			instance._etag = data._etag;
			instances[keyValue] = instance; // to avoid infinite recursion in init
			instance.init(_);
			//dbg:console.log("load:"+className+" ("+keyValue+") :"+!!instance);
			if (relPath) {
				for (var i = 0; i < relPath.length; i++) {
					var relation = instance.relations[relPath[i]];
					if (!relation) throw new X3Error(26, "invalid relation name: " + keyValue);
					instance = relation.class;
				}
			}
		}
		return instances[keyValue] = instance;
	}
	defineClass(_: _, def: ClassDef) {
		const key = def.module + '.' + def.name;
		if (this.classesByJsName[key]) return this.classesByJsName[key];
		const data = require('../x3js/class-meta').loadData(_, this, def);
		//console.error("DEFINECLASS", data);
		def.jsName = key;
		const clas = this.new<Class>(_, 'Class', data);
		if (def.CODCLA) this.cacheMeta('Class', def.CODCLA, clas);
		clas.jsModules.push(def);
		this.classesByJsName[key] = clas;
		return clas;
	}
	/*
	loadClassByJsName(_: _,  jsName) {
		if (this.classesByJsName[jsName]) return this.classesByJsName[jsName];
		const script = this.loadJsScript(_, 'classes', jsName);
		//console.error("LOADCLASSBYJSNAME: ", jsName, script && script.default.dictCode);
		if (!script) throw new Error(`class ${ jsName } not found`);
		var clas;
		if (script.default.dictCode) {
			clas = this.load(_, 'Class', script.default.dictCode);
			clas.fixJsNames(_, script.default);
		} else {
			const data = require('../x3js/class-meta').loadData(_, this, script.default);
			//console.error("LOADCLASSBYJSNAME", data);
			data.jsName = jsName;
			clas = this.new<Class>(_, 'Class', data);
			this.cacheMeta('Class', data.CODCLA, clas);
		}
		clas.jsModules.push(script.default);
		this.classesByJsName[jsName] = clas;
		return clas;
	},
	*/
	reader(_: _, className: string, filter: any) {
		const loader = subModule(className);
		const coln = this.mongoStore.collection(loader.collectionName).find(filter || {});

		return ez.devices.generic.reader(_ => {
			while (true) {
				var data = coln.next().then(_, _);
				if (!data) return undefined;
				//try {
				return new loader.Constructor(this, data).init(_);
				//} catch (ex) {
					// ignore it but print error
				//	console.error(ex.stack);
				//}
			}
		});
	}
	loadText(_: _, num: number, lan?: string) {
		lan = lan || util.currentContext().x3session.actx.$LAN(_);
		const s = this.cache.LAN[lan] !== undefined ? this.cache.LAN[lan].ATEXTE[num] : undefined;

		if (s !== undefined) return s;

		this.mongoStore.collection('ATEXTE').createIndex({
			LAN: 1,
			TEXTE: 1
		}, {
			background: true
		});

		const data = this.mongoStore.collection('ATEXTE').find({
			LAN: lan,
			NUMERO: num
		}).toArray().then(_, _)[0];

		if (this.cache.LAN[lan] === undefined) this.cache.LAN[lan] = {
			ATEXTE: {},
			APLSTD: {}
		};
		return this.cache.LAN[lan].ATEXTE[num] = data ? data.TEXTE : "TEXT_" + num;
	}
	findText(_: _, text: number, lan?: string) {
		lan = lan || util.currentContext().x3session.actx.$LAN(_);
		const data = this.mongoStore.collection('ATEXTE').find({
			LAN: lan,
			TEXTE: text
		}).toArray().then(_, _)[0];

		if (data) {
			// Save it in the cache:
			if (this.cache.LAN[lan] === undefined) this.cache.LAN[lan] = {
				ATEXTE: {},
				APLSTD: {}
			};
			this.cache.LAN[lan].ATEXTE[data.NUMERO] = data.TEXTE;
			return data.NUMERO;
		}
		return 0;
	}
	loadEnum(_: _, lib: number, lan?: string) {
		lan = lan || (util.currentContext().x3session.actx ? util.currentContext().x3session.actx.$LAN(_) : "ENG");
		var menu: Message[] = this.cache.LAN[lan] !== undefined ? this.cache.LAN[lan].APLSTD[lib] : undefined;

		if (menu !== undefined) return menu;
		const found: { [id: number]: boolean } = {}; // we are getting duplicates - eliminate for now. Investigate later why.

		menu = this.mongoStore.collection('APLSTD').find({
			LAN: lan,
			LANCHP: lib
		}).sort({
			LANCHP: 1,
			LANNUM: 1
		}).toArray().then(_, _).filter(m => {
			const ok = m.LANNUM && !found[m.LANNUM];

			found[m.LANNUM] = true;
			return ok;
		}).map(m => {
			return {
				$value: m.LANNUM,
				$title: m.LANMES
			};
		});

		if (this.cache.LAN[lan] === undefined) this.cache.LAN[lan] = {
			ATEXTE: {},
			APLSTD: {}
		};
		return this.cache.LAN[lan].APLSTD[lib] = menu;
	}
	loadMess(_: _, lib: number, num: number, lan?: string) {
		const list = this.loadEnum(_, lib, lan);

		if (list !== undefined) return _messSearch(list, num);
		return "";
	}
	loadMessParams(_: _, lib: number, num: number, ...args: any[]) {
		var mess = this.loadMess(_, lib, num);
		if (mess !== "") {
			mess = mess.replace(/\$[\w~]\$/g,  str => args[parseInt(str.replace(/\$/g, '')) - 1]);
		}
		return mess;
	}
	fillTypeNode(_: _, data: any, node: NodeProto) {
		return subModule('Type').fillTypeNode(_, this, data, node);
	}
	razCacheScripts(_: _) {
		this.cache.scripts = null;
	}
	loadBuiltins(_: _) {
		if (this.cache.scripts == null) {
			if (this.cache.scriptBuiltins == null) {
				this.cache.scriptBuiltins = {};
				tracerJs.debug && tracerJs.debug("load Builtins");
				fs.readdir(__dirname + '/builtins', _).forEach(name => {
					if (/\.ts$/.test(name)) {
						name = name.substring(0, name.length - 3);
						var script = require('etna/lib/supervisor/builtins/' + name);
						// set name on all entry points
						tracerJs.debug && tracerJs.debug("load Builtin:" + name);
						script.$isBuiltin = true;
						script.$name = name;
						/*							Object.keys(script).forEach(name => {
	script[name].name = name;
	});*/
						this.cache.scriptBuiltins[name] = script;
					}
				});
			}
			this.cache.scripts = Object.keys(this.cache.scriptBuiltins).reduce((r, name) => {
				const v = this.cache.scriptBuiltins[name];
				r[name] = v;
				return r;
			}, {} as Dict<any>);
		}
	}
	loadBuiltin(_: _, name: string) {
		this.loadBuiltins(_);
		return this.cache.scriptBuiltins[name];
	}
	/*
	loadJsEnum(_: _, name: string, chapter: number) {
		if (name) {
			const script = this.loadJsScript(_, 'enums', name);
			if (!script) throw new Error(`enum ${ name } not found`);
			if (!script.default.values) throw new Error(`enum ${ name }: script does not define values`);
			return script.default;
		} else {
			console.warn(`enum chapter ${ chapter }: JavaScript mapping not available`);
		}
	}
	*/
	findJsScript(_: _, subdir: string, jsName: string, canCreate: boolean) {
		const segs = jsName.split('.');
		segs.splice(segs.length - 1, 0, subdir);
		const path = segs.map(s => util.camelToKebab(s)).join(fsp.sep);
		var file: string = null;
		const tryX3js = (_: _, path: string) => {
			//console.error("TRYING", path);
			return this.api && (canCreate || fs.exists(path, _, _)) ? path : null;
		};
		if (this.directories.jsLocal) file = tryX3js(_, fsp.join(this.directories.jsLocal, path + '.x3js'));
		//if (!file && typeof QUnit !== 'undefined')
		//	file = tryX3js(_, fsp.join(__dirname, '../../test/x3js/fixtures', path + ".x3js"));
		if (!file) file = tryX3js(_, fsp.join(this.directories.jsShared, path + '.x3js'));
		return file;
	}
	jsPath(mod: any, jsName: string) {
		return this.moduleName(mod) + '.' + jsName;
	}
	moduleName(mod: number) {
		return (x3Modules as any)[this.product][mod];
	}
	/*
	loadJsScript(_: _,  subdir, jsName) {
		const path = this.findJsScript(_, subdir, jsName);
		if (!path) return null;
		const script = require(path);
		if (script && !script.default) throw new Error(`script ${ subdir }.${ jsName } does not export default`);
		return script;
	},
	// we use this one for enums and messages
	loadJsScriptSync(subdir, jsName) {
		const segs = jsName.split('.');
		segs.splice(segs.length - 1, 0, subdir);
		const path = segs.map(s => util.camelToKebab(s)).join(fsp.sep);
		var script = null;
		const tryX3js = path => {
			//console.error("TRYING", path);
			if (this.api && fs.existsSync(path)) {
				var script = require(path);
				return script;
			} else {
				return null;
			}
		};
		console.error("loadJsScriptSync", path);
		if (superv.directories.jsLocal) script = tryX3js(fsp.join(superv.directories.jsLocal, path + '.x3js'));
		//if (!script)
		//	script = tryX3js(fsp.join(__dirname, '../../test/x3js/fixtures', path + ".x3js"));
		if (!script) script = tryX3js(fsp.join(superv.directories.jsShared, path + '.x3js'));
		if (script && !script.default) throw new Error(`script ${ subdir }.${ jsName } does not export default`);
		return script;
	},
	*/
	loadScript(_: _, name: string, clas?: BaseClass): Prog {
		this.loadBuiltins(_);
		var script = this.cache.scripts[name];
		if (!script) {
			// for now, hardcode product name to 'superv' -- see later how we can get it from db.
			/*
			if (name.indexOf(':') >= 0) {
				const [sub, jsName] = name.split(':');
				script = this.loadJsScript(_, sub, jsName);
				if (clas) {
					clas.jsModules.push(script.default);
					clas.fixJsNames(_, script.default);
				}
			} else {*/
				const path = fsp.join(this.solutionPath, this.folderName, "TRT", name + ".src");
				tracerJs.debug && tracerJs.debug("Loading script: " + path);
				const source = fs.readFile(path, "utf8", _);
				const parsed = new (require("etna/lib/engine/compilers/parser").Parser)(source, path).parse();
				const transformed = require("etna/lib/engine/compilers/jsgen").generate(parsed.node, path);
				script = compile(this, transformed, name, path);
				script.$4gl = true;
				//fs.writeFile("C:\\"+name+"sc.js", transformed, "utf8", _); // for debugging
			/*}*/
			this.cache.scripts[name] = script;
			//tracerJs.debug && tracerJs.debug(script);
		}
		return script;
	}
	loadScripts(_: _, clas: BaseClass):  Prog[] {
		if (clas.data.CODTRT) {
			clas._scripts = clas.data.CODTRT.map_(_, (_, codtrt) => {
				return {
					name: codtrt,
					body: this.loadScript(_, codtrt, clas)
				};
			});
		} else {
			clas._scripts = [];
		}
		return clas._scripts;
	}
	loadScriptBase(_: _, wscript: string, name: string) {
		//fs.writeFile("C:\\" + name + "sc.js", wscript, "utf8", _); // for debugging
		const parsed = new (require("etna/lib/engine/compilers/parser").Parser)(wscript, "").parse();
		const transformed = require("etna/lib/engine/compilers/jsgen").generate(parsed.node, "");
		//fs.writeFile("C:\\" + "name" + "sc.js", transformed, "utf8", _); // for debugging

		const script = compile(this, transformed, name, "");
		//tracerJs.debug && tracerJs.debug(script);

		return script;
	}
	newInstance(_: _, className: string) {
		const cl: Class = this.load<Class>(_, 'Class', className);

		return cl.createInstance(_);
	}
	about(_: _) {
		return {
			solutionName: this.solutionName,
			solutionHttpUrl: "TODO", //http://aws-x3-devsup.sagefr.adinternal.com:80/Adonix_SUPDVLP,
			processServer: "TODO", //AWS-X3-DEVSUP.sagefr.adinternal.com,
			applicationServer: "", //AWS-X3-DEVSUP.sagefr.adinternal.com,
			folder: this.folderName,
			port: "TODO",
			x3Version: "TODO",
			supervisorVersion: "TODO",
			runtimeVersion: "TODO",
			x3Release: "TODO",
			patchNumber: "TODO"
		};
	}
	moduleCode(name: string) {
		const i = (x3Modules as any)[this.product].indexOf(name);
		if (i < 0) throw new Error("bad module name: " + name);
		return i;
	}
	languages(_: _) {
		if (!this._languages) {
			var columns = new Array(20);
			for (var i = 0; i < columns.length; i++) columns[i] = "LAN_" + i;

			this._languages = this.sqlReader<{
				LAN: string;
			}>(_, "select " + columns.join(',') + " from ADOSSIER where (DOSSIER_0=" + this.sqlDriver.param(0) + ")", [this.folderName])
			.limit(1).toArray(_).reduce_(_, (_, r, record) => {
				for (var i = 0; i < record.LAN.length; i++) {
					var tablan = this.newInstance(_, "TABLAN");
					var status = tablan.read(_, record.LAN[i]);
					if (status !== constants.CST_AERROR) {
						r[record.LAN[i]] = tablan;
					}
				}
				return r;
			}, {} as Dict<Instance>);
		}
		return this._languages;
	}
	loadFolderCache(_: _): {
		// TODO: review
		sys?: SysValues;
		adonix?: number;
		landef?: string;
		legislations?: string;
	} {
		var data: any;
		if (!this.folderCacheEtag) {
			data = this.sqlReader<{
				VALEUR: string;
			}>(_, "Select A.VALEUR_0 From ADOVAL A where A.CMP_0=' ' and A.FCY_0=' ' and A.PARAM_0='FOLDERETAG'").toArray(_);
			if (data[0] && data[0].VALEUR > "") {
				this.folderCacheEtag = data[0].VALEUR;
			}
			this.folderCacheEtag = this.folderCacheEtag || "etag";
		}
		data = this.mongoStore.collection('X3FoldersCache').find({ folderName: this.folderName }).toArray().then(_, _)[0];

		if (data && data.etag === this.folderCacheEtag) {
			tracerJs.debug && tracerJs.debug("find in mongo folder: " + this.folderName + "  " + data.etag);
			return this.folderCache = data.folder;
		}
		return {};
	}
	updateFolderCache(_: _, folder: any) {
		const col = this.mongoStore.createCollection('X3FoldersCache', _);

		this.mongoStore.collection('X3FoldersCache').createIndex({
			folderName: 1
		}, {
			background: true
		});

		const cache = { 
			folderName: this.folderName,
			etag: this.folderCacheEtag,
			folder: folder,
		};

		cache.folderName = this.folderName;
		cache.etag = this.folderCacheEtag;
		cache.folder = folder;

		const r = this.mongoStore.collection("X3FoldersCache").update({
			folderName: this.folderName
		}, cache, {
			upsert: true
		}).then(_, _);
	}
	initSysVar(_: _, actx: ACTX) {
		if (this.sys && this.sys['ADXTUL']) return;

		const values: SysValues = {
			ADXTUL: [],
			ADXTUC0: [],
			ADXTUT0: [],
			ADXTUC: [],
			ADXTUT: [],
		};
		const folder = this.loadFolderCache(_);

		if (folder.sys && folder.sys.ADXTUL) {
			// Load sys from mongodb
			this.sys = Object.keys(values).reduce((r, v) => {
				r[v] = folder.sys[v];
				return r;
			}, {} as SysValues);
			return; // sys loaded from mongodb
		}

		// Compute sys
		const parameters = [] as any;

		for (var i = 1; i <= 30; i++) {
			parameters.push("TUL" + ("00" + i).slice(-2));
		}
		// Use the contexte to load parameters:
		const tuls = actx.$APARAM(_)._getParams(_, 1, this.folderName, parameters, "AUTO");

		Object.keys(tuls).forEach(tul => {
			if (tuls[tul].value) {
				var arTUL = tuls[tul].value.split(":");
				if (arTUL !== undefined && arTUL.length === 2) {
					values.ADXTUL.push(arTUL[0][0]);
					values.ADXTUT0.push(arTUL[0].substring(1));
					values.ADXTUT.push(arTUL[0].substring(1));
					values.ADXTUC0.push(arTUL[1]);
					values.ADXTUC.push(arTUL[1]);
				}
			}
		});
		for (var i = 0; i < values.ADXTUT.length; i++) {
			var j = values.ADXTUL.indexOf(values.ADXTUT[i]);
			if (j >= 0) {
				values.ADXTUC[i] = values.ADXTUC[j];
				values.ADXTUT[i] = values.ADXTUT[j];
			}
		}
		folder.sys = {};
		this.sys = Object.keys(values).reduce((r, v) => {
			r[v] = [1, variables.types["S"].def, values[v], 0, values[v].length];
			folder.sys[v] = r[v];
			return r;
		}, {} as SysValues);
		// Update the cache:
		this.updateFolderCache(_, folder);
		// Save sys variables in the cache
	}
	$ADONIX(_: _, actx: ACTX) {
		const folder = this.loadFolderCache(_);

		if (folder.adonix) return folder.adonix;
		folder.adonix = actx.$APARAM(_).AGETVALNUM(_, 1, this.folderName, "ADONIX");
		// Update the cache:
		this.updateFolderCache(_, folder);
		return folder.adonix;
	}
	$LANDEF(_: _) {
		const folder = this.loadFolderCache(_);

		if (!folder.landef) {
			var param = this.sqlDriver.param;
			var rAdossier = this.sqlReader<{
				LANDEF: string;
			}>(_, "select LANDEF_0 from ADOSSIER where (DOSSIER_0=" + param(0) + ")", [this.folderName]).limit(1).toArray(_);
			folder.landef = rAdossier[0].LANDEF;
			this.updateFolderCache(_, folder);
		}
		return folder.landef;
	}
	$LEGISLATIONS(_: _, actx: ACTX) {
		const folder = this.loadFolderCache(_);

		if (folder.legislations) return folder.legislations;
		folder.legislations = actx.$APARAM(_).AGETVALCHAR(_, 1, this.folderName, "DOSLEG");
		// Update the cache:
		this.updateFolderCache(_, folder);
		return folder.legislations;
	}
	release(_: _) {
		this.sqlDriver && this.sqlDriver.release(_);
	}
}
