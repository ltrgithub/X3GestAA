"use strict";

const inspect = require('util').inspect;
import * as variables from '../runtime/variables';
import * as db from '../runtime/db';
import * as bcd from '../runtime/bcd';
import { ParseNode } from './parser';
import { X3Error } from '../runtime/errors';
import { config } from '../../util/nodeconfig';

export function generate(node: ParseNode, fname?: string) {
	const used: any = {};

	var scopeName = ""; // for errors

	const warn = function (node: ParseNode, message: string) {
		console.error(node.line + ": " + message);
	};

	function error(node: ParseNode, message: string) {
		//dbg:console.log("error:"+message+" scopeName:"+scopeName+" node:",node);
		return new X3Error(26, fname + ':' + scopeName + ':' + node.line + ': ' + message);
	}

	function unreachable(node: ParseNode) {
		warn(node, node.tag + " is not reachable");
		return "";
	}

	function id(node: ParseNode) {
		return node._id || (node._id = ++lastId);
	}

	// etna: disable main
	var result = "/*z.MAIN(e);*/e.MAIN=B(";
	var line = 1,
	    lastLine = 1;
	var tail = ");";
	var lastId = 0;
	var comma = "";
	var skipping = false;

	function omitComma(res: string) {
		// check if result + res ends with an open paren followed by optional spaces
		// don't concat result and res, to be efficent.
		var i = res.length - 1;
		while (i >= 0 && (res[i] === ' ' || res[i] === '\n')) i--;
		if (i >= 0) return res[i] === '(';
		var i = result.length - 1;
		while (i >= 0 && (result[i] === ' ' || result[i] === '\n')) i--;
		return result[i] === '(';
	}

	function insert(node: ParseNode, arg: string, beg?: string, end?: string) {
		if (node && arg && !tail) {
			if (skipping) return "";
			skipping = true;
			return unreachable(node);
		} else {
			skipping = false;
		}

		var res = "";
		if (node && arg && line > lastLine) {
			arg = "NL(" + (line - lastLine) + ")," + arg;
			lastLine = line;
		}

		if (tail && arg) {
			res = comma + arg;
			comma = ",";
		}

		if (beg) {
			if (omitComma(res) && tail[0] === ',') tail = tail.slice(1); // fix for empty WHEN clause
			res += tail + beg;
			tail = "";
		}

		if (end) {
			comma = "";
			tail = end + tail;
		}
		return res;
	}

	function genArray(arr: ParseNode[]) {
		used.A = true;
		return "A([" + arr.map(gen0).join(',') + "])";
	}

	function genClosing(node: ParseNode) {
		return insert(node, "", "p[" + id(node) + "]=B(", ");");
	}

	const types: { [name: string]: string; } = {};

	for (var key in variables.types) types[variables.types[key].name] = key;

	function leaf(node: ParseNode): ParseNode {
		return node.branch ? leaf(node.branch) : node;
	}

	var tmp: (node: ParseNode, variant?: string) => string;

	const generators: { 
		[name: string]: (node: ParseNode, variant?: string) => string; 
		WHERE: (node: ParseNode) => string;
	} = {
		IDENT(node, variant) {
			const inst = (variant || '') + "V";

			used[inst] = true;
			if (!node.value) {
				var e = new Error("dummy");
				console.log(e.stack);
				throw error(node, "IDENT : value undefined");
			}
			return inst + "('" + node.value.toUpperCase() + "')";
		},
		CLAS(node, variant) {
			var inst: string;
			if (node.field && node.field.length) {
				inst = (variant || '') + "CV";
				used[inst] = true;
				return inst + "('" + node.letter + "','" + (node.abbrev || "") + "'," + genDefNull(node.field.toUpperCase()) + ")";
			}
			inst = (variant || '') + "CLA";

			used[inst] = true;
			return inst + "('" + node.letter + "', '" + node.abbrev + "')";
		},

		STRING(node) {
			used.C = true;
			const val = node.value.replace(/\\/g, "\\\\");

			return node.value.indexOf("'") >= 0 ? 'C("' + val + '")' : "C('" + val + "')";
		},
		INTEGER(node) {
			used.C = true;
			return "C(" + node.value + ")";
		},
		DECIMAL(node) {
			used.DECIMAL = true;
			return 'DECIMAL("' + node.value + '")';
		},
		DATE(node) {
			used.DATE = true;
			return "DATE(" + node.year + "," + node.month + "," + node.day + ")";
		},

		OP(node, variant) {
			if (variant && (db.instructions as any)[variant + node.op]) {
				used[variant + node.op] = true;
				return variant + node.op + "(" + node.args.map(genVariant(variant)).join(',') + ")";
			} else {
				used[node.op] = true;
				return node.op + "(" + node.args.map(gen0).join(',') + ")";
			}
		},
		NBRECORD: tmp = function(node: ParseNode) {
			used[node.tag] = true;
			return node.tag + "('" + node.clas.abbrev + "')";
		},
		UNIQID: tmp,
		ROWCOUNT: tmp,
		DIM: tmp = function (node: ParseNode) {
			if (node.args[0].field != null || node.args[0].value != null) {
				used[node.tag] = true;
				var args = [node.args[0].letter || '', node.args[0].field || node.args[0].value].concat(node.args.slice(1));
				return node.tag + "(" + args.map(gen0).join(",") + ")";
			} else {
				used.DYNDIM = true;
				return "DYNDIM(" + node.args.map(gen0).join(",") + ")";
			}
		},
		TYPE(node) {
			if (node.field != null) {
				used.TYPE = true;
				return "TYPE('" + (node.letter || '') + "','" + node.field + "')";
			} else {
				used.DYNTYPE = true;
				return "DYNTYPE(" + gen0(node.exp) + ")";
			}
		},
		FCALL(node, variant) {
			const inst = (variant || '') + "F";

			used[inst] = true;
			if (node.name === 'TYPE') variant = "TYPE";

			if (node.name === 'PARSE' && node.args.length == 1) {
				// Special treatment for managing parse last optional parameter
				let n = new ParseNode('INTEGER', node.args[0].line, node.args[0].col);
				n.value = 0;
				node.args.push(n);
			}
			if (node.name === "MAX" && node.args && node.args.length === 1 && node.args[0].tag === "PROP") {
				return inst + "('MAXCOL',[" + gen(node.args[0].target.target) + ",C('" + node.args[0].name + "')," + gen(node.args[0].target.args) + "])";
			}
			if (node.name === "FIND" && node.args && node.args[1] && node.args[1].tag === "PROP") {
				return inst + "('FINDOBJ',[" + gen(node.args[0]) + "," + gen(node.args[1].target.target) + ",C('" + node.args[1].name + "')," + gen(node.args[1].target.args) + "])";
			}
			return inst + "('" + node.name + "'" + (node.args ? ",[" + node.args.map(genVariant(variant)).join(",") + "]" : "") + ")";
		},
		EVALUE(node, variant) {
			const inst = (variant || '') + "EVALUE";

			used[inst] = true;
			return inst + "(r, e, " + gen(node.arg) + ")";
		},
		SIGMA(node) {
			used.SIGMA = true;
			return "SIGMA('" + node.field + "',[" + node.args.map(gen0).join(",") + "])";
		},
		SORTA(node) {
			used.SORTA = true;
			return insert(node, "SORTA(" + gen(node.rep) + ",[" + (node.vars || []).map(gen0) + "],[" + (node.order && node.order.exps || []).map(gen0) + "]" + ",C(" + (node.order && node.order.direction ? node.order.direction : 1) + "))");
		},
		INSA: tmp = function (node) {
			used[node.tag] = true;
			return insert(node, node.tag + "([" + node.intExps.map(gen0) + "],[" + node.vars.map(gen0) + "])");
		},
		DELA: tmp,
		INDEX(node, variant) {
			const inst = (variant || '') + "INDEX";

			used[inst] = true;
			return (variant || '') + "INDEX(" + gen(node.target, variant) + ",[" + node.args.map(gen0) + "])";
		},
		DECL(node) {
			//dbg:console.log("DECL node:",node);

			const fctRANGE = ["CHAR", "CLBFILE", "BLBFILE"];

			used.DECL = true;
			const charDefaultLens = fctRANGE.indexOf(node.type) === 0 ? 30 : 1;
			//var charDefaultLens = 30;

			return node.items.map(decl => {
				//dbg:console.log("DECL decl:",decl);
				// TODO: dims, using and sized
				var key = (variables.dictClasses[node.mode] || '?') + (types[node.type] || '?');
				if (key.indexOf('?') >= 0) warn && warn(node, "unsupported decl: mode=" + node.mode + ", type=" + node.type);
				if (decl.tag === 'PARAM') {
					if (fctRANGE.indexOf(node.type) >= 0 && decl.ranges && decl.ranges.length === 1 && !decl.ranges[0]) {
						// Value Char A()() is equivalent to Value Char A()(0..)
						decl.ranges = [{
							tag: "OP",
							line: decl.line,
							col: decl.col + 3,
							op: "RANGE",
							isAssign: false,
							args: [{
								tag: "INTEGER",
								line: decl.line,
								col: decl.col + 2,
								value: 0
							}]
						}];
					} else if (fctRANGE.indexOf(node.type) < 0 && decl.lens && !decl.lens[0] && !decl.lens[1]) {
						// Value Integer A() is equivalent to Value Integer A(0..)
						decl.lens = null;
						decl.ranges = [{
							tag: "OP",
							line: decl.line,
							col: decl.col + 3,
							op: "RANGE",
							isAssign: false,
							args: [{
								tag: "INTEGER",
								line: decl.line,
								col: decl.col + 2,
								value: 0
							}]
						}];
					}
				} else if (decl.tag === 'ITEM') {
					if (config.etna.optimize && node.type == "CHAR" && decl.ranges === null) {
						//DECL('LS20','A1','')
						//is faster than
						//DECL('LS','A1','',A([C(20)]))
						if (decl.lens === null) {
							return insert(decl, "DECL('" + key + charDefaultLens + "','" + decl.name + "'" + ( //
							decl.using ? "," + gen(decl.using) : ",''") + //
							")");
						}
						if (decl.lens.length === 1 && decl.lens[0].tag === "INTEGER") {
							key += decl.lens[0].value || charDefaultLens;
							return insert(decl, "DECL('" + key + "','" + decl.name + "'" + ( //
							decl.using ? "," + gen(decl.using) : ",''") + //
							")");
						}
					}
					if (fctRANGE.indexOf(node.type) >= 0 && decl.ranges && decl.ranges.length === 1 && !decl.ranges[0].args) {
						// Local Char A(10)(6) is equivalent to Local Char A(10)(0..5)
						decl.ranges = [{
							tag: "OP",
							line: decl.ranges[0].line,
							col: decl.ranges[0].col,
							op: "RANGE",
							isAssign: false,
							args: [{
								tag: "INTEGER",
								line: decl.ranges[0].line,
								col: decl.ranges[0].col,
								value: 0
							}, {
								tag: "INTEGER",
								line: decl.ranges[0].line,
								col: decl.ranges[0].col,
								value: decl.ranges[0].value - 1
							}]
						}];
					} else if (fctRANGE.indexOf(node.type) >= 0 && !decl.ranges && (!decl.lens || !decl.lens[0] || decl.lens[0].value === 0)) {
						decl.lens = [{
							tag: "INTEGER",
							line: 0,
							col: 0,
							value: charDefaultLens
						}];
					} else if (fctRANGE.indexOf(node.type) < 0 && decl.lens && decl.lens.length === 1 && !decl.lens[0].args) {
						// Local Integer A(6) is equivalent to Local Integer A(0..5)
						decl.ranges = [{
							tag: "OP",
							line: decl.lens[0].line,
							col: decl.lens[0].col,
							op: "RANGE",
							isAssign: false,
							args: [{
								tag: "INTEGER",
								line: decl.lens[0].line,
								col: decl.lens[0].col,
								value: 0
							}]
						}];
						if (typeof decl.lens[0].value == 'number') {
							decl.ranges[0].args[1] = {
								tag: "INTEGER",
								line: decl.lens[0].line,
								col: decl.lens[0].col,
								value: decl.lens[0].value - 1
							};
						} else {
							decl.ranges[0].args[1] = {
								tag: "OP",
								line: decl.ranges[0].line,
								col: decl.ranges[0].col,
								op: "SUB",
								isAssign: false,
								args: [{}, {
									tag: "INTEGER",
									line: decl.ranges[0].line,
									col: decl.ranges[0].col,
									value: 1
								}]
							};
							Object.keys(decl.lens[0]).forEach(k => {
								decl.ranges[0].args[1].args[0][k] = decl.lens[0][k];
							});
							//dbg:console.log("DECL args=>",decl.ranges[0].args);
						}
						decl.lens = null;
					}
				}
				//dbg:console.log("DECL decl=>",decl);

				return insert(decl, "DECL('" + key + "','" + decl.name + "'" + ( //
				decl.using ? "," + gen(decl.using) : ",''") + ( //
				decl.lens ? "," + gen(decl.lens) : "") + ( //
				decl.ranges ? "," + gen(decl.ranges) : "") + //
				")");
			}).join("");
		},
		STATEMENT(node) {
			used[node.op] = true;

			if (config.etna.optimize && node.op === "SET" && node.lhs.tag == "IDENT") {
				var val: string;
				if (node.rhs.tag == "INTEGER") val = node.rhs.value;
				else if (node.rhs.tag == "STRING") {
					val = node.rhs.value.replace(/\\/g, "\\\\");
					val = val.indexOf("'") >= 0 ? '"' + val + '"' : "'" + val + "'";
				}
				if (val !== undefined) return insert(node, node.op + "(" + gen(node.lhs) + "," + val + ")");
			}

			return insert(node, node.op + "(" + gen(node.lhs) + "," + gen(node.rhs) + ")");
		},
		DEFAULT(node) {
			used[node.tag] = true;
			if (node.classes) return insert(node, "DEFAULT(" + ")");
			else return insert(node, "DEFAULT('" + node.scope + "', " + gen(node.file) + ")");
		},
		ASSIGN(node) {
			used.ASSIGN = true;
			return insert(node, "ASSIGN(" + gen(node.lhs) + "," + gen(node.rhs) + ")");
		},
		SETLOB(node) {
			used.SET = true;
			return insert(node, "SET(" + gen(node.lhs) + "," + gen(node.rhs) + ")");
		},
		RAZ(node) {
			used.RAZ = true;
			return insert(node, "RAZ([" + node.expressions.map(gen0) + "])");
		},
		KILL(node) {
			used.KILL = true;
			return insert(node, "KILL([" + node.expressions.map(gen0) + "])");
		},
		DYN(node) {
			return gen(node.exp);
		},
		GOSUB: tmp = function (node) {
			used.REQ = true;
			used.C = true;
			const from = node.from ? "REQ(r," + gen(node.from) + ")" : "C(e)";

			used[node.tag] = true;
			if (!node.label && node.tag != "ONERRGO") throw error(node, "label missing");
			return insert(node, node.tag + "(" + from + (node.label ? ",'" + node.label + "'" : "") + ")");
		},
		ONERRGO: tmp,
		GOTO: tmp,
		LABEL(node) {
			used.GO = true;
			scopeName = node.name;
			return insert(null, "GO(e,'" + node.name + "')", "e." + node.name + "=B(", ");");
		},
		RETURN(node) {
			used.RET = true;
			return insert(node, "RET(" + (node.result ? gen(node.result) : "") + ")", " ", ""); // beg is space to force close
		},
		RESUME(node) {
			used.RESUME = true;
			return insert(node, "RESUME()", " ", ""); // beg is space to force close
		},
		SUBPROG: tmp = function (node) {
			used.PROG = true;
			scopeName = node.name;
			return insert(null, "", "PROG(e,'" + node.name + "',[" + node.items.map(quote) + "],B(", "));");
		},
		FUNPROG: tmp,
		END(node) {
			used.END = true;
			return insert(node, "END(" + (node.result ? gen(node.result) : "") + ")", " ", ""); // beg is space to force close
		},

		CALL(node) {
			used.REQ = true;
			const from = node.from ? "REQ(r," + gen(node.from) + ")" : "C(e)";

			used.CALL = true;
			return insert(node, "CALL(" + from + "," + gen(node.name) + ",[" + (node.args || []).map(gen0) + "])");
		},
		FUNC(node) {
			used.REQ = true;
			const from = node.from ? "REQ(r," + gen(node.from) + ")" : "C(e)";

			used.CALL = true;
			return "CALL(" + from + "," + gen(node.name) + ",[" + (node.args || []).map(gen0) + "])";
		},
		PROP(node) {
			if (node.name.toUpperCase() !== "SNAPSHOT") {
				used.PROP = true;
				return "PROP(" + gen(node.target) + ",'" + node.name + "')";
			} else {
				used.SNAP = true;
				return "SNAP(" + gen(node.target) + ")";
			}
		},
		ATT(node) {
			used.ATT = true;
			if (!node.target.target || node.target.tag === 'INDEX') return "ATT(" + gen(node.target) + ",null,'" + node.name + "')";

			return "ATT(" + gen(node.target.target) + "," + ("'" + node.target.name + "'") + ",'" + node.name + "')";
		},
		FMET(node) {
			used.XMET = true;
			if (node.name === 'AGETATTR') {
				used.AGETATTR = true;

				if (!node.target.target || node.target.tag === 'INDEX') return "AGETATTR(" + gen(node.target) + "," + "null" + "," + gen(node.args[0]) + ")";
				//else
				return "AGETATTR(" + gen(node.target.target) + "," + ("'" + node.target.name + "'") + "," + gen(node.args[0]) + ")";
			}
			if (node.name === 'ASETATTR') {
				used.ASETATTR = true;

				if (!node.target.target || node.target.tag === 'INDEX') return "ASETATTR(" + gen(node.target) + "," + "null" + "," + gen(node.args[0]) + "," + gen(node.args[1]) + ")";
				//else
				return "ASETATTR(" + gen(node.target.target) + "," + ("'" + node.target.name + "'") + "," + gen(node.args[0]) + "," + gen(node.args[1]) + ")";
			}
			if (node.name === 'AGETCOLUMNATTR') {
				used.AGETCOLUMNATTR = true;
				return "AGETCOLUMNATTR(" + gen(node.target.target) + ",'" + node.target.name + "'," + gen(node.args[0]) + "," + gen(node.args[1]) + ")";
			}
			if (node.name === 'ASETCOLUMNATTR') {
				used.ASETCOLUMNATTR = true;
				return "ASETCOLUMNATTR(" + gen(node.target.target) + ",'" + node.target.name + "'," + gen(node.args[0]) + "," + gen(node.args[1]) + "," + gen(node.args[2]) + ")";
			}
			if (['AADD', 'ADEL'].indexOf(node.name) >= 0) {
				used[node.name] = true;
				return node.name + "(" + gen(node.target) + "," + gen(node.args[0]) + ")";
			}
			if (['AGETTEXT', 'ASETTEXT', 'AGETTEXTLAN', 'ASETTEXTLAN', 'AGETTEXTRA', 'AGETTEXTRALAN', 'ASETTEXTRALAN'].indexOf(node.name) >= 0 && node.target.target) {
				used[node.name] = true;
				return node.name + "(" + gen(node.target.target) + ",'" + node.target.name + "'," + gen(node.args[0]) + "," + gen(node.args[1]) + ")";
			}
			return "XMET(" + gen(node.target) + ",'" + node.name + "',[" + node.args.map(gen0) + "])";
		},
		CALLMET(node) {
			used.XMET = true;
			if (node.name === 'ASETATTR') {
				used.ASETATTR = true;
				if (!node.target.target || node.target.tag === 'INDEX') return insert(node, "ASETATTR(" + gen(node.target) + "," + null + "," + gen(node.args[0]) + "," + gen(node.args[1]) + ")");
				//else
				return insert(node, "ASETATTR(" + gen(node.target.target) + "," + "'" + node.target.name + "'" + "," + gen(node.args[0]) + "," + gen(node.args[1]) + ")");
			}
			if (node.name === 'ASETCOLUMNATTR') {
				used.ASETCOLUMNATTR = true;
				return insert(node, "ASETCOLUMNATTR(" + gen(node.target.target) + ",'" + node.target.name + "'," + gen(node.args[0]) + "," + gen(node.args[1]) + "," + gen(node.args[2]) + ")");
			}
			if (['AADD', 'ADEL'].indexOf(node.name) >= 0) {
				used[node.name] = true;
				return insert(node, node.name + "(" + gen(node.target) + "," + gen(node.args[0]) + ")");
			}
			return insert(node, "XMET(" + gen(node.target) + ",'" + node.name + "',[" + node.args.map(gen0) + "])");
		},

		IF(node) {
			used.IF = used.GO = true;
			return insert(node, "IF(" + gen(node.condition) + ",p," + id(node.branch) + ",B(", "", ",GO(p," + id(leaf(node)) + ")))");
		},
		ELSIF(node) {
			return insert(node, "", "p[" + id(node) + "]=IF(" + gen(node.condition) + ",p," + id(node.branch) + ",B(", ",GO(p," + id(leaf(node)) + ")));");
		},
		ELSE(node) {
			used.GO = true;
			return insert(node, "", "p[" + id(node) + "]=B(", ",GO(p," + id(leaf(node)) + "));");
		},
		ENDIF: genClosing,

		CASE(node) {
			used.CASE = true;
			return insert(node, "CASE(" + gen(node.expression) + ",p," + id(node.branch) + "," + id(leaf(node)) + ")", "", "");
		},
		WHEN(node) {
			used.WHEN = used.GO = true;
			return insert(node, "", "p[" + id(node) + "]=WHEN([" + node.expressions.map(gen0) + "],p," + id(node.branch) + ",B(", ",GO(p," + id(leaf(node)) + ")));");
		},
		ENDCASE: genClosing,

		KEY(node) {
			used.KEY = true;
			return "KEY('" + (node.letter || '') + "','" + (node.abbrev || '') + "','" + (node.field || '') + "'" + (node.indices ? ",[" + node.indices.map(gen0) + "]" : "") + ")";
		},
		HINT(node) {
			used.HINT = true;
			return "HINT(" + node.nohint + ", " + (node.nohint ? "null" : gen(node.key)) + ")";
		},
		WHEREKEY(node) {
			used.SQLKEY = true;
			return "SQLKEY('" + node.keyName + "','" + node.op + "'," + gen(node.keyIndice) + ",[" + node.keyValues.map(genVariant("SQL")) + "])";
		},
		SQLDECL(node) {
			used.SQLDECL = true;
			var key = ' ' + (types[node.type] || '?');
			if (node.lens && node.lens.length === 1) key += node.lens[0].value;
			return "SQLDECL('" + key + "', '" + node.name + "'" + (node.ranges ? "," + gen(node.ranges) : "") + ")";
		},
		FOR(node) {
			used.GO = used.DECL = used.SET = used.WHILE = used.V = true;

			if (node.key) {
				used.FORF = true;
				return insert(node, "FORF(" + gen(node.key) + "," + (node.hint ? gen(node.hint) : "null") + "," + 
				(node.lock ? "true" : "false") + "," + generators.WHERE(node.where) + ", [" + 
				(node.from || []).map(gen0) + "], [" + (node.to || []).map(gen0) + "],p," + id(node.branch) + ",B(", "", "))");
			} else if (node.from) {
				used.FORV = true;
				return insert(node, "FORV('" + node.varName + "'," + gen(node.from) + "," + gen(node.to) + "," + genDefNull(node.step) + ",p," + id(node.branch) + ",B(", "", "))");
			} else if (node.ins) {
				used.FORIN = true;
				return insert(node, "FORIN('" + node.varName + "',[" + node.ins.map(gen0) + "],p," + id(node.branch) + ",B(", "", "))");
			} else if (node.sql) {
				used.FORSQL = true;
				return insert(node, "FORSQL(" + gen(node.sql.sql) + ", '" + node.sql.as.abbrev + "', [" + node.sql.vars.map(gen0) + "] ,p," + id(node.branch) + ",B(", "", "))");
			} else {
				return genNiy(node, true);
			}
		},
		NEXT: genClosing,
		WHILE(node) {
			used.GO = used.WHILE = true;
			//return insert(node, "GO(p," + id(node) + ")", "p[" + id(node) + "]=WHILE(" + gen(node.condition) + ",p," + id(node.branch) + ",B(", "));");
			return insert(node, "WHILE(" + gen(node.condition) + ",p," + id(node.branch) + ",B(", "", "))");
		},
		WEND: genClosing,
		REPEAT(node) {
			used.GO = used.WHILE = true;
			return insert(node, "WHILE(" + gen(node.branch.condition) + ",p," + id(node.branch) + ",B(", "", "),true)");
		},
		UNTIL: genClosing,
		BREAK(node) {
			used.BREAK = true;
			return insert(node, "BREAK(p," + (node.level ? gen(node.level) : "C(1)") + ')');
		},
		EXECSQL(node) {
			used.EXECSQL = true;
			return insert(node, "EXECSQL(" + gen(node.sql) + ")");
		},
		ANASQL(node) {
			used.ANASQL = true;
			return insert(node, "ANASQL(" + gen(node.sql) + "," + gen(node.using) + ")");
		},
		VAR(node) {
			used.VAR = true;
			const key = types[node.type];

			return "VAR('" + key + "','" + node.name + "', " + (node.lens ? gen(node.lens[0]) : "null") + ")";
		},
		FILES(node) {
			// TODO: worry about node.scope
			return node.files.map(node => {
				const abbrev = node.clas && node.clas.abbrev;

				if (node.vars) {
					var tag = node.fromVar ? "FILEVAL" : "FILESYS";
					used[tag] = true;
					return insert(node, tag + "('" + node.as.abbrev + "',[" + node.vars.map(gen0) + "],[" + (node.fromVar || [node.fromSys]).map(genVariant("VTB")).join(',') + "]," + generators.WHERE(node.where) + "," + genDefNull(node.order) + ")");
					//throw error(node, "unsupported FILE syntax");
				} else {
						used.FILESQL = true;
						return insert(node, "FILESQL(" + genDefNull(abbrev) + "," + gen(node.name) + "," + generators.WHERE(node.where) + "," + genDefNull(node.order) + ")");
					}
			}).join("");
		},
		FILTER(node) {
			used.FILTER = true;
			const abbrev = node.clas && node.clas.abbrev;

			return insert(node, "FILTER(" + genDefNull(abbrev) + "," + genDefNull(node.where) + "," + genDefNull(node.order) + ")");
		},
		WHERE(node) {
			if (!node) return "null";
			if (!node.exps || node.exps.length !== 1) throw error(node, "unsupported where clause: " + node.exps);
			var exp = node.exps[0];
			const ands: ParseNode[] = [];

			while (exp.tag === 'OP' && exp.op === 'AND') {
				ands.push(exp.args[0]);
				exp = exp.args[1];
			}
			ands.push(exp);
			used.WHERE = true;
			return "WHERE([" + ands.map(genVariant("SQL")) + "])";
		},
		ORDER(node) {
			used.ORDER = true;
			const name = node.keyName ? "'" + node.keyName + "'" : "null";

			return "ORDER(" + name + ",[" + (node.keyBy || []).map(genVariant("SQL")) + "]," + genDefNull(node.keyWith) + ", " + (node.dir || "null") + ', ' + gen(node.keyIndices) + ")";
		},
		ORDERITEM(node, variant) {
			used.ORDERITEM = true;
			return "ORDERITEM(" + gen(node.exp, variant) + ',' + (node.dir < 0 ? "'-'" : "'+'") + ")";
			//return "'" + (node.dir < 0 ? '-' : '+') + node.name + "'";
		},
		COLUMN(node) {
			used.COLUMNSITEM = true;
			return "COLUMNSITEM( '" + (node.abbrev || '') + "'," + (node.field ? "'" + node.field + "'" : "null") + "," + (node.nodeOpt ? node.nodeOpt.map(gen0) : "null") + ")";
		},
		COLUMNS(node) {
			used.COLUMNS = true;
			const a = insert(node, "COLUMNS('" + (node.clas.abbrev || '') + "'" + (node.columns ? ", [" + node.columns.map(gen0) + "]," + (node.isExtended ? "true" : "false") : '') + ")");

			return a;
		},
		LINK(node) {
			used.LINK = true;
			return insert(node, "LINK('" + node.clas.abbrev + "','" + node.as.abbrev + "',[" + node.items.map(gen0) + "]," //
			 + genDefNull(node.where) + "," + genDefNull(node.order) + ")");
		},
		LINKITEM(node) {
			used.LINKITEM = true;
			return "LINKITEM(" + gen(node.key, "SQL") + "," + node.outer + ",[" + node.values.map(genVariant("SQL")) + "])";
		},
		READLOCK(node) {
			used.READ = true;
			const abbrev = node.clas && node.clas.abbrev;
			// todo: hint and lockWait

			return insert(node, "READ(" + gen(node.key, "SQL") + ", '" + (node.op || '') + "',[" + (node.values || []).map(gen0) + "], true, " + (node.hint ? gen(node.hint) : "null") + ")");
		},
		READ: tmp = function (node) {
			used[node.tag] = true;
			const abbrev = node.clas && node.clas.abbrev;

			return insert(node, node.tag + "(" + gen(node.key, "SQL") + ", '" + (node.op || '') + "',[" + (node.values || []).map(gen0) + "], false, " + (node.hint ? gen(node.hint) : "null") + ")");
		},
		LOOK: tmp,
		WRITE(node) {
			used.WRITE = true;
			const abbrev = node.clas && node.clas.abbrev;

			return insert(node, "WRITE(" + (abbrev ? "'" + abbrev + "'" : "undefined") + ")");
		},
		REWRITE: tmp = function (node) {
			used[node.tag] = true;
			return insert(node, node.tag + "(" + gen(node.key, "SQL") + ", '" + (node.op || '') + "',[" + (node.values || []).map(gen0) + "])");
		},
		REWRITEBYKEY: tmp,
		DELETE(node) {
			used.DELETE = true;
			if (!node.key || !node.key.abbrev && !node.key.letter) {
				//throw error(node, "Delete not followed by [ABREV]");
				return insert(node, "DELETE(null, " + generators.WHERE(node.where) + ", '" + (node.op || '') + "',[" + (node.values || []).map(gen0) + "])");
			}
			return insert(node, "DELETE(" + gen(node.key, "SQL") + ", " + generators.WHERE(node.where) + ", '" + (node.op || '') + "',[" + (node.values || []).map(gen0) + "])");
		},
		ASSIGNUPDATE(node, variant) {
			used.ASSIGNUPDATE = true;
			return "ASSIGNUPDATE(" + gen(node.lhs, variant) + ", " + gen(node.rhs, variant) + ")";
		},
		UPDATE(node) {
			used.UPDATE = true;
			return insert(node, "UPDATE('" + (node.clas.abbrev || "") + "', " + generators.WHERE(node.where) + ", [" + (node.assignments || []).map(genVariant("SQL")) + "])");
		},
		TRBEGIN(node) {
			used.TRBEGIN = true;
			return insert(node, "TRBEGIN()"); //[" + node.vcs.map(gen0) + "])");
		},
		COMMIT(node) {
			used.COMMIT = true;
			return insert(node, "COMMIT()");
		},
		ROLLBACK(node) {
			used.ROLLBACK = true;
			return insert(node, "ROLLBACK()");
		},
		LOGICCLOSE(node) {
			const instr = 'LOGICCLOSE';

			used[instr] = true;
			const abbrevs = (node.classes || []).map(cl => "'" + cl.abbrev + "'").join(',');

			return insert(node, instr + "('" + node.scope + "',[" + abbrevs + "])");
		},
		OPEN(node) {
			used.OPEN = used.CLOSE = true;
			const abbrev = node.using ? node.using.abbrev : '';

			if (node.name) return insert(node, "OPEN('" + abbrev + "'," + gen(node.name) + ",'" + node.mode + "'" + (node.seek ? "," + gen(node.seek) : "") + ")");
			else return insert(node, "CLOSE('" + abbrev + "')");
		},
		CLOSE(node) {
			const instr = 'CLOSE' + node.target;

			used[instr] = true;
			const abbrevs = (node.classes || []).map(cl => "'" + cl.abbrev + "'").join(',');

			if (["MASK", "INPBOX"].indexOf(node.target) >= 0) return genNiy(node, true);
			if (node.scope) return insert(node, instr + "('" + node.scope + "',[" + abbrevs + "])");
			else return insert(node, instr + "(null, " + (abbrevs.length > 0 ? "[" + abbrevs + "])" : "[])"));
		},
		IOMODE(node) {
			used.IOMODE = true;
			const abbrev = node.using ? node.using.abbrev : '';

			return insert(node, "IOMODE('" + abbrev + "','" + node.mode + "'," + gen(node.value) + ")");
		},
		WRSEQ(node) {
			used.WRSEQ = true;
			const abbrev = node.using ? node.using.abbrev : '';

			return insert(node, "WRSEQ('" + abbrev + "'," + gen(node.values) + (node.sep ? "," + gen(node.sep) : "") + ")");
		},
		RDSEQ(node) {
			used.RDSEQ = true;
			const abbrev = node.using ? node.using.abbrev : '';
			//return insert(node, "RDSEQ('" + abbrev + "'," + gen(node.exps) + ")");

			return insert(node, "RDSEQ('" + abbrev + "'," + "[" + node.exps.map(gen0).join(',') + "]" + ")");
		},
		PUTSEQ(node) {
			used.PUTSEQ = true;
			const abbrev = node.using ? node.using.abbrev : '';
			//var sized = node.sized ? node.using.abbrev : 0;
			//if (sized) return insert(node, "PUTSEQ('" + abbrev + "'," + gen(node.count) + ",[" + node.exps.map(gen0).join(',') + "]," + gen(node.sized) + ")");

			return insert(node, "PUTSEQ('" + abbrev + "'," + gen(node.count) + ",[" + node.exps.map(gen0).join(',') + "])");
		},
		GETSEQ(node) {
			used.GETSEQ = true;
			const abbrev = node.using ? node.using.abbrev : '';
			const sized = node.sized ? node.sized : 0;

			return insert(node, "GETSEQ('" + abbrev + "'," + gen(node.count) + ",[" + node.exps.map(gen0).join(',') + "]," + gen(node.sized) + ")");
		},
		SEEK(node) {
			used.SEEK = true;
			const abbrev = node.using ? node.using.abbrev : '';

			return insert(node, "SEEK('" + abbrev + "','" + node.mode + "'," + gen(node.direction) + "," + gen(node.value) + ")");
		},
		CALLJS(node) {
			used.CALLJS = true;
			return insert(node, "CALLJS(" + gen(node.mode) + "," + gen(node.from) + ",'" + node.name + "'" + (node.args ? ',' + genArray(node.args) : "") + ")");
		},
		ERRBOX(node) {
			used.BOX = true;
			// worry about titled, using, etc. later (if ever)
			return insert(node, "BOX('error',[" + gen(node.arg) + "])");
		},
		INFBOX(node) {
			used.BOX = true;
			// worry about titled, using, etc. later (if ever)
			return insert(node, "BOX('info',[" + node.args.map(gen0) + "])");
		},
		DBGETNA(node) {
			used.DBGETNA = true;
			// worry about titled, using, etc. later (if ever)
			return insert(node, "DBGETNA([" + gen(node.arg) + "])");
		},
		SLEEP(node) {
			used.SLEEP = true;
			// worry about titled, using, etc. later (if ever)
			return insert(node, "SLEEP([" + gen(node.arg) + "])");
		},
		NEWINSTANCE(node) {
			used.NEW = true;
			return "NEW(" + gen(node.clas) + ")";
		},
		FREEINSTANCE(node) {
			used.FREE = true;
			// we could omit it completely!
			return ""; //insert(node, "FREE(" + gen(node.arg) + ", false)");
		},
		FREEZEINSTANCE(node) {
			used.FREEZE = true;
			return insert(node, "FREEZE(" + gen(node.arg) + ")");
		},
		FREEGROUP(node) {
			used.FREE = true;
			// we could omit it completely!
			return ""; //insert(node, "FREE(" + gen(node.arg) + ", true)");
		},
		APPEND(node) {
			used.APPEND = true;
			return insert(node, "APPEND(" + gen(node.args[0]) + "," + gen(node.args[1]) + ")");
		},
		LOCK(node) {
			used.LOCK = true;
			return insert(node, "LOCK([" + (node.classs ? node.classs.map(gen0) : node.symbols.map(gen0)) + "]," + (node.args ? gen(node.args) : "-1") + ")");
		},
		UNLOCK(node) {
			used.UNLOCK = true;
			return insert(node, "UNLOCK([" + (node.classs ? node.classs.map(gen0) : node.symbols.map(gen0)) + "])");
		},
		SYMBOL(node) {
			used.SYMBOL = true;
			return "SYMBOL(" + gen(node.exp) + ', ' + ((node.application ? gen(node.application) : '""') + ")");
		},
		NULL(node) {
			used.C = true;
			return "C(null)";
		},
		PRAGMA(node) {
			used.PRAGMA = true;
			return insert(node, "PRAGMA(" + JSON.stringify(node.data) + ")");
		},
		SETINSTANCE(node) {
			used.SETINSTANCE = true;
			const abbrev = node.arg && node.arg.abbrev;

			return insert(node, "SETINSTANCE(" + gen(node.target) + ",'" + (abbrev ? abbrev : "") + "')");
		}
	};

	function genNiy(node: ParseNode, topLevel?: boolean) {
		used.NIY = true;
		var str = "NIY({";
		var comma = "";
		for (var key in node) {
			if (node.hasOwnProperty(key) && key !== 'line' && key !== 'col' && key !== 'parentLoop' && key !== 'chainType' && key !== 'branch') {
				var val = (node as any)[key];
				str += comma + key + ":" + gen0(val);
				comma = ",";
			}
		}
		str += "})";
		//dbg:console.log("skipping " + node.tag)
		return topLevel ? insert(node, str) : str;
	}

	function gen(node: any, variant?: string, topLevel?: boolean): string {
		used.A = true;
		if (node == null) {
			used.C = true;
			return "C(null)"; // for now
		}
		if (Array.isArray(node)) return "A([" + node.map(gen0).join(',') + "])";
		else {
			if (node.tag == null) return "'" + node.toString() + "'";
			const fn = generators[node.tag];

			if (fn) return fn(node, variant);
			else {
				return genNiy(node, topLevel);
			}
		}
	}

	function genDefNull(node: any) {
		return node ? gen(node) : "null";
	}

	function gen0(node: ParseNode) {
		// for map, etc.
		return gen(node);
	}

	function quote(s: string) {
		return "'" + s + "'";
	}

	function genVariant(variant: string) {
		return function (node: ParseNode) {
			return gen(node, variant);
		};
	}
	//dbg:console.log(node);
	const statements = node.statements;
	//var returns = false;

	for (var i = 0, len = statements.length; i < len; i++) {
		var statement = statements[i];
		while (line < statement.line) {
			result += "\n";
			line++;
		}
		result += gen(statement, '', true);
		//returns = statement.returns;
	}
	result += insert(node, "", "\n", "");

	// stub for standalone evaluation
	var head = "var rt = require('etna/lib/engine/runtime'),z=rt.instructions";
	//var head = "var rt = require('"+require("path").join(__dirname, '../..').replace(/\\/g, '/')+ "/etna/lib/engine/runtime'),z=rt.instructions";
	head += ",r=typeof(requireScript)==='undefined'?rt.requireScript:requireScript";
	head += ",e=exports,p=[],B=z.B,NL=z.NL";
	for (var key in used) {
		head += "," + key + "=z." + key;
	}
	return head + ";z.BEGIN(module);NL(0);" + result;
};