"use strict";
var Parser = require("etna/lib/engine/parser").Parser;
var dates = require('etna/lib/engine/runtime/dates');
var tdate = require('etna/lib/engine/runtime/tdate');

exports.generate = function(tabcor, node) {
	//console.log("jmqlgen:" + JSON.stringify(node));

	var VALUES = ["STRING"];

	var eqValue = function(ident, fct) {
		return function(filter) {
			filter = filter || {};
			var op1 = fct(filter);
			if (op1 instanceof Date) {
				if (op1.toString() === tdate.make(0, 0, 0).toJsDate().toString()) op1 = "";
				else
					op1 = tdate.fromJsDate(op1).toString("yyyy-MM-dd");
			}
			filter[ident] = op1;
			return filter;
		};

	};
	var opValue = function(operator, ident, fct) {
		return function(filter) {
			filter = filter || {};
			filter[ident] = filter[ident] || {};
			var op1 = fct(filter);
			if (op1 instanceof Date) {
				if (op1.toString() === tdate.make(0, 0, 0).toJsDate().toString()) op1 = "";
				else
					op1 = tdate.fromJsDate(op1).toString("yyyy-MM-dd");
			}
			filter[ident][operator] = op1;
			return filter;
		};

	};

	function likeValue(ident, value) {
		return function(filter) {
			filter = filter || {};
			filter[ident] = filter[ident] || {};
			filter[ident].$regex = value;
			filter[ident].$options = "i";
			return filter;
		};
	}

	var addOpValue = function(op, rop) {
		return function(node) {
			var ident;
			if (node.args[0].tag === 'IDENT') return opValue(op, node.args[0].value, gen(node.args[1]));
			else if (node.args[1].tag === 'IDENT') return opValue(rop, node.args[1].value, gen(node.args[0]));

			return opValue(op, gen(node.args[0])(), gen(node.args[1]));
		};
	};

	var tmp;
	var operators = {
		EQ(node) {
			var ident;
			if (node.args[0].tag === 'IDENT') return eqValue(node.args[0].value, gen(node.args[1]));
			else if (node.args[1].tag === 'IDENT') return eqValue(node.args[1].value, gen(node.args[0]));

			if (node.args[0].tag === 'FCALL') {
				switch (node.args[0].name) {
					case 'LEFT$':
						return likeValue(gen(node.args[0].args[0])(), node.args[1].value + ".*");
					case 'RIGHT$':
						return likeValue(gen(node.args[0].args[0].value)(), ".*" + node.args[1].value);
				}
			}
			return eqValue(gen(node.args[0])(), gen(node.args[1]));
			//if (!ident) throw error("bad expression");

		},
		NE: addOpValue("$ne", "$ne"),
		GE: addOpValue("$gte", "$lte"),
		LE: addOpValue("$lte", "$gte"),
		GT: addOpValue("$gt", "$lt"),
		LT: addOpValue("$lt", "$gt"),
		AND(node) {
			var exps = node.args.reduce((r, arg) => {
				r.push(gen(arg));
				return r;
			}, []);
			return function(filter) {
				return exps.reduce((r, exp) => {
					exp(r);
					return r;
				}, filter || {});
			};

		},
		OR(node) {
			var exps = node.args.reduce((r, arg) => {
				r.push(gen(arg));
				return r;
			}, []);

			return function(filter) {
				filter = filter || {};
				filter.$or = [];
				return exps.reduce((r, exp) => {
					r.$or.push(exp());
					return r;
				}, filter);
			};
		},
		SUB(node) {
			var lhs = gen(node.args[0]);
			var rhs = gen(node.args[1]);
			return function() {
				var l = lhs();
				var r = rhs();
				if (l instanceof Date) {
					var d = tdate.fromJsDate(l);
					d = d.x3Sub(r);
					return d.toJsDate();
				}
				return l - r;
			};

		},
		ADD(node) {
			var lhs = gen(node.args[0]);
			var rhs = gen(node.args[1]);
			return function() {
				var l = lhs();
				var r = rhs();
				if (l instanceof Date) {
					var d = tdate.fromJsDate(l);
					d = d.x3Add(r);
					return d.toJsDate();
				}
				return l + r;
			};

		},
		STRING: tmp = function(node) {
			return function() {
				return node.value;
			};
		},
		INTEGER: tmp,
		DATE$: function(node) {
			return function() {
				return dates.functions.DATE$.fn().toJsDate();
			};
		},
		DATE(node) {
			return function() {
				return new Date(node.year, node.month - 1, node.day); //  GO ??		 	
			};
		},
		IDENT(node) {
			return function() {
				return node.value;
			};
		},
		CLAS(node) {
			return function() {
				var res = '[' + node.letter + ((node.abbrev === undefined) ? ']' : ':' + node.abbrev + ']') + node.field;
				if (tabcor && tabcor[res]) {
					if (tabcor[res] === "true") return true;
					else if (tabcor[res] === "false") return false;
					else return tabcor[res].replace(/\"/g, '');
				}
				return res;
			};
		},
		PROP(node) {
			return function() {
				var lhs = gen(node.target)();
				var res = lhs + '.' + node.name;
				if (tabcor && tabcor[res]) {
					if (tabcor[res] === "true") return true;
					else if (tabcor[res] === "false") return false;
					else return tabcor[res].replace(/\"/g, '');
				}
				return res;
			};
		},
	};

	function gen(node) {
		var fn = (node.tag === 'FCALL') ? operators[node.name] : (operators[node.op] || operators[node.tag]);
		if (fn) return fn(node);
	}
	return gen(node);
};

exports.x3ToJmql = function(tabcor, expression) {
	var parsed = new Parser("CONDITION=(" + expression + ")").parse();
	return exports.generate(tabcor, parsed.node.statements[0].rhs);
};