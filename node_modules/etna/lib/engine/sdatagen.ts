"use strict";

import { Parser } from '../engine/parser';
import * as dates from '../engine/runtime/dates';
import * as tdate from '../engine/runtime/tdate';

export function generate(tabcor, node) {
	//console.log("sdatagen:" + JSON.stringify(node));

	const VALUES = ["STRING"];
	const opValue = function (operator, op0, op1) {
		return function (filter) {
			var l, r;
			if (op0 instanceof Date) {
				if (op0.toString() === tdate.make(0, 0, 0).toJsDate().toString()) l = "@@";
				else l = "@" + tdate.fromJsDate(op0).toString("yyyy-MM-dd") + "@";
			} else l = op0;
			if (op1 instanceof Date) {
				if (op1.toString() === tdate.make(0, 0, 0).toJsDate().toString()) r = "@@";
				else r = "@" + tdate.fromJsDate(op1).toString("yyyy-MM-dd") + "@";
			} else r = op1;

			filter = '(' + l + ' ' + operator + ' ' + r + ')';
			return filter;
		};
	};

	const addOpValue = function (op) {
		return function (node) {

			if (node.args[0].tag === 'FCALL' & node.args[0].name === 'FIND') return findValues(op, node.args[0], node.args[1]);

			const op0 = gen(node.args[0])();
			const op1 = gen(node.args[1])();

			return opValue(op, op0, op1);
		};
	};

	function findValues(operator, find, value) {
		return function (filter) {
			const l = gen(find.args[0])();
			const vals = Array.prototype.slice.call(find.args, 1);
			// not used var r = gen(value)();

			const values = '(' + vals.map(val => gen(val)()).join(', ') + ')';

			switch (operator) {
				case "ne":
				case "gt":
					var op = "in";
					break;
				case "eq":
				case "ge":
				case "le":
				case "lt":
				default:
					var op = "not in";
					break;
			}
			filter = '(' + l + ' ' + op + ' ' + values + ')';
			return filter;
		};
	}

	const operators = {
		EQ: addOpValue("eq"),
		NE: addOpValue("ne"),
		GE: addOpValue("ge"),
		LE: addOpValue("le"),
		GT: addOpValue("gt"),
		LT: addOpValue("lt"),
		OR: addOpValue("or"),
		AND: addOpValue("and"),
		LEN(node) {
			const lhs = gen(node.args[0]);

			return function () {
				const l = lhs();

				return 'length(' + l + ')';
			};
		},
		MID$(node) {
			const lhs = gen(node.args[0]);
			const r1hs = gen(node.args[1]);
			const r2hs = gen(node.args[2]);

			return function () {
				const l = lhs();
				const r1 = r1hs();
				const r2 = r2hs();

				if (r1 === 1) return 'left(' + l + ', ' + r2 + ')';
				else return 'substring(' + l + ', ' + r1 + ', ' + r2 + ')';
			};
		},
		LEFT$(node) {
			const lhs = gen(node.args[0]);
			const rhs = gen(node.args[1]);

			return function () {
				const l = lhs();
				const r = rhs();

				return 'left(' + l + ', ' + r + ')';
			};
		},
		RIGHT$(node) {
			const lhs = gen(node.args[0]);
			const rhs = gen(node.args[1]);

			return function () {
				const l = lhs();
				const r = rhs();

				return 'right(' + l + ', ' + r + ')';
			};
		},
		SUB(node) {
			const lhs = gen(node.args[0]);
			const rhs = gen(node.args[1]);

			return function () {
				const l = lhs();
				const r = rhs();

				if (l instanceof Date) {
					var d = tdate.fromJsDate(l);
					d = d.x3Sub(r);
					return d.toJsDate();
				}
				return l - r;
			};
		},
		ADD(node) {
			const lhs = gen(node.args[0]);
			const rhs = gen(node.args[1]);

			return function () {
				const l = lhs();
				const r = rhs();

				if (l instanceof Date) {
					var d = tdate.fromJsDate(l);
					d = d.x3Add(r);
					return d.toJsDate();
				}
				return l + r;
			};
		},
		STRING(node) {
			return function () {
				return '"' + node.value + '"';
			};
		},
		INTEGER(node) {
			return function () {
				return node.value;
			};
		},
		DATE(node) {
			return function () {
				return tdate.make(node.year, node.month, node.day).toJsDate();
			};
		},
		DATE$(node) {
			return function () {
				return dates.functions.DATE$.fn().toJsDate();
			};
		},
		IDENT(node) {
			return function () {
				return node.value;
			};
		},
		CLAS(node) {
			return function () {
				const res = '[' + node.letter + (node.abbrev === undefined ? ']' : ':' + node.abbrev + ']') + node.field;

				if (tabcor && tabcor[res]) return tabcor[res];
				return res;
			};
		},
		PROP(node) {
			return function () {
				const lhs = gen(node.target)();
				const res = lhs + '.' + node.name;

				if (tabcor && tabcor[res]) return tabcor[res];
				return res;
			};
		}
	};

	function gen(node) {
		const fn = node.tag === 'FCALL' ? operators[node.name] : operators[node.op] || operators[node.tag];

		if (fn) return fn(node);
	}
	return gen(node);
};

export function x3ToSdata(tabcor, expression) {
	const parsed = new Parser("CONDITION=(" + expression + ")").parse();

	return generate(tabcor, parsed.node.statements[0].rhs);
};