import * as core from 'syracuse-core';
const nodeCompile = require('module').prototype._compile;
import { config } from '../util/nodeconfig';

config.streamline.fast = false;

if (config.streamline.fast && config.streamline.fibers) config.streamline.aggressive = true;
require('streamline').register(config.streamline);

// compat hacks to get unit tests ok on node 0.12
// temporary and very naive -- this code is not supposed to run on 0.12 anyway
if (!String.prototype.endsWith) String.prototype.endsWith = function(s) { return this.substring(this.length - s.length) === s };
if (!Object.assign) Object.assign = function(d: any, s: any) { Object.keys(s || {}).forEach(function(k) { d[k] = s[k] }); return d; };

import * as fs from 'fs';
import * as fsp from 'path';
import { Parser } from "./compilers/parser";
import * as jsgen from './compilers/jsgen';
import { version } from './version';

const dirMode = parseInt('777', 8);

export function mkdirsSync(path: string) {
	if (fs.existsSync(path)) return;
	mkdirsSync(fsp.join(path, '..'));
	fs.mkdirSync(path);
};

export interface Options {
	cacheDir?: string;
	extension?: string;
	force?: boolean;
	verbose?: boolean;
}

export function cachedPath(path: string, options: Options) {
	const cacheRoot = options.cacheDir || (process.env.HOME || (process.env.HOMEDRIVE + process.env.HOMEPATH).replace(/\\/g, '/')) + "/.etna";

	var i = path.indexOf('node_modules/');
	if (i < 0) i = path.lastIndexOf('/');
	else i += 'node_modules'.length;

	var dir = cacheRoot + '/' + path.substring(0, i).replace(/[\/\\:]/g, '__');
	dir = dir + path.substring(i, path.length - 4);
	if (options.extension) return dir + "." + options.extension;
	return dir + '.js';
};

function mtimeSync(fname: string) {
	try {
		return +fs.statSync(fname).mtime;
	} catch (ex) {
		return 0;
	}
}

function transformSync(path: string, options: Options) {
	const banner = "/* Generated by etna " + version + " -- DO NOT EDIT */";

	var transformed: string;
	path = path.replace(/\\/g, '/');

	const cpath = exports.cachedPath(path, options);

	exports.mkdirsSync(fsp.dirname(cpath));
	if (!options.force) {
		if (mtimeSync(cpath) > mtimeSync(path)) {
			transformed = fs.readFileSync(cpath, "utf8");
			if (transformed.substring(0, banner.length) === banner) return transformed;
		}
	}
	// no luck in cache
	if (options.verbose) console.log("etna: transforming: " + path);

	const source = fs.readFileSync(path, 'utf8');
	const parsed = new Parser(source, path).parse();

	transformed = banner + jsgen.generate(parsed.node, path);
	fs.writeFileSync(cpath, transformed, "utf8");
	return transformed;
}

export const options: Options = {
	verbose: true,
	force: false,
};

// for now
require.extensions['.src'] = function (module: any, filename: string) {
	const transformed = transformSync(filename, options);

	nodeCompile.call(module, transformed, filename);
};

function registerX3js() {
	if (/^v0\.1/.test(process.version)) {
		console.error("node 0.12 is supported in degraded mode - skipping X3JS registration");
		return;
	}
	// hack Module._nodeModulePaths so that x3js scripts can find etna runtime modules.

	const Module = require('module');
	const original = Module._nodeModulePaths;
	var shadowRoot = fsp.join(fsp.dirname(require.resolve('streamline-runtime/package.json')), '..');


	Module._nodeModulePaths = function () {
		const paths = original.apply(this, arguments);

		paths.push(fsp.join(__dirname, '../../../../node_modules'));
		// also include shadow-modules/node_modules to get streamline-runtime
		paths.push(shadowRoot);
		return paths;
	};

	const babelOptions: any = {
		plugins: [require("babel-plugin-flow-comments"), require("babel-plugin-x3js"), 
		// TODO: investigate why language unit test does not pass if we remove streamline!!
		[require("babel-plugin-streamline"), {
			runtime: 'fibers',
			forceTransform: true, // because of different extension
			verbose: true
		}], require("babel-plugin-transform-es2015-modules-commonjs"), require("babel-plugin-transform-strict-mode")],
		compact: false,
		sourceMaps: true
	};
	// reuse streamline cache

	const cache = require('streamline/lib/cacheSync');

	function isX3js(filename: string) {
		const pkgPath = fsp.join(fsp.dirname(filename), '../../package.json');
		if (fs.existsSync(pkgPath)) {
			const pkg = require(pkgPath);
			return pkg.engines && Object.keys(pkg.engines).indexOf('x3') >= 0;
		}
		return false;
	}

	const tsHandler = require.extensions['.ts'];
	require.extensions['.ts'] = function (module: any, filename: string) {
		if (isX3js(filename)) {
			const transformed = cache.get(filename, {
				cache: true,
				sourceMaps: true,
				// include x3js plugin version into cache dir root
				runtime: 'x3js-' + require("babel-plugin-x3js/package").version
			}, () => {
				babelOptions.filename = filename;
				babelOptions.sourceFileName = filename;
				const source = fs.readFileSync(filename, 'utf8');
				if (!/(^|\n)\s*import\s+x3js\b/.test(source)) throw new Error(`${filename} is not an X3JS file`);
				const transformed = require('babel-core').transform(source, babelOptions);

				return {
					code: transformed.code,
					map: transformed.map
				};
			});
			nodeCompile.call(module, transformed.code, filename);
		} else {
			return tsHandler(module, filename);
		}

	};

	// fix QUnit
	if (typeof QUnit !== 'undefined') {
		const equals = QUnit.equal;
		const date = core.types.date;
		const datetime = core.types.datetime;
		const tbcd = require('./runtime/tbcd');
		const glob: any = global;
		glob.equals = glob.equal = QUnit.equal = function (x, y, message) {
			if (date.isDate(x) && date.isDate(y) && x.x3Compare(y) === 0) y = x;
			if (datetime.isDatetime(x) && datetime.isDatetime(y) && x.x3Compare(y) === 0) y = x;
			if (x instanceof tbcd.BCD && y instanceof tbcd.BCD && x.x3Compare(y) === 0) y = x;
			equals(x, y, message);
		};
		glob.throws = QUnit.throws = function (fn: () => any, expect: any, message?: string) {
			try {
				const result = fn();
				ok(false, `returned ${ result } instead of throwing: ${ message }`);
			} catch (ex) {
				ok(expect.test(ex.message), `exception: ${ ex.message }`);
			}
		};
		type Callback = (err?: Error, result?: any) => void;
		glob.asyncThrows = function (cb: Callback, fn: (cb: Callback) => void, expect: any, message: string) {
			fn((err, result) => {
				QUnit.throws(() => {
					if (err) throw err;
					else return result;
				}, expect, message);
				cb();
			});
		};
	}
}

registerX3js();