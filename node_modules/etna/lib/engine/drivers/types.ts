import { _ } from 'streamline-runtime';
import * as ez from 'ez-streams';

export type Connection = any; // oracle or tedious

export interface SqlQueryOptions{
	limit?: boolean;
	typesmap?: any; // refine later
	dispatch?: any; // refine later
	decimalColumns?: string[];
}

export interface DriverReaderOptions {
}

export interface SqlReaderOptions {
	typesmap?: any; // refine later
	dispatch?: any; // refine later
}

export interface SqlExecuteOptions {
	decimalColumns?: string[];
	fetchInfo?: any; // refine later (driver dependent?)
	outputVars?: SqlColumnDesc[];
}

export interface SqlColumnDesc {
	name?: string;
	type?: string;
	typtyp?: number;
}

// special one for driver describe: type is number!
export interface SqlColumnInfo {
	name?: string;
	type?: number;
	typtyp?: number;
}

export type SqlColumnsDesc = { [name: string]: SqlColumnDesc };

// driver types
export interface ColumnDefinition {
	name: string;
	maxLength?: number;
	isNullable?: boolean;
	default?: any;
	colType?: string;
	type?: string;
	// following ones only in SQL server
	decimalPrecision?: number;
	decimalScale?: number;
	useFloatingPointFormat?: boolean;
}

export interface Hint {
	tname: string;
	abbrev: string;
	revert: boolean;
	name?: string;
	nohint?: boolean;
}

export type Record = {
	AUUID?: Buffer;
	[name: string]: any 
};

export interface IndexColumn {
	name: string;
	ascending?: boolean;
}

export interface IndexDefinition {
	name: string;
	isUnique: boolean;
	columns: IndexColumn[];
	// following ones only in SQL Server
	isPk?: boolean;
}

export interface TableDefinition {
	schemaName: string;
	tableName: string;
	columns?: ColumnDefinition[];
	indexes?: IndexDefinition[];
	isOpenAccess?: boolean;
	sequence?: number;
	lastUpdate?: Date;
}

export interface TableFilter {
	key: string;
	operator: string;
	value: any;
}

export interface PermissionsConfig {
	rootFolderName: string;
}

export interface DriverConfig {
	connectString?: string;
	hostname?: string;
	port?: number;
	database?: string;
	trace?: (...args: any[]) => void;
	// for sql server
	user?: string;
	password?: string;
	requestTimeout?: number;
};

export interface Driver extends BaseDriver {
	reader(_: _, cnx: Connection, sql: string, args: any[], opts?: DriverReaderOptions): ez.Reader<Record>;
	reader(_: _, sql: string, args: any[], opts?: DriverReaderOptions): ez.Reader<Record>;
	writer(_: _, cnx: Connection, sql: string): ez.Writer<Record>;
	writer(_: _, sql: string): ez.Writer<Record>;
	execute(_: _, cnx: Connection, sql: string, args?: any[], opts?: SqlExecuteOptions): any;
	execute(_: _, sql: string, args?: any[], opts?: SqlExecuteOptions): any;
}

export interface BaseDriver {
	nullDate(): Date; //core.types.date.DateValue;
	lockClause0(): string;
	param(i: number): string;
	reader(_: _, cnx: Connection, sql: string, args: any[], opts?: DriverReaderOptions): ez.Reader<Record>;
	writer(_: _, cnx: Connection, sql: string): ez.Writer<Record>;
	isUniqueViolated(err: any): boolean;
	isLocked(err: any): boolean; 
	isIndexNotFound(err: any): boolean; 
	isTableNotFound(err: any): boolean; 
	isNoRecord(err: any): boolean;
	dropIndexSql(indexName: string, tableName: string): string;
	lobPlaceholder(type: string): string;
	tableExists(_: _, name: string, schema: string): boolean;
	tinyIntType(): string;
	shortIntType(): string;
	intType(): string;
	decimalType(): string;
	doubleType(): string;
	stringType(len: number): string;
	dateType(): string;
	//sqlDate(val: any): string; // strange
	blobType(): string;
	blobReader(_: _, val: any): ez.Reader<Buffer>;
	clobType(): string;
	clobReader(_: _, val: any): ez.Reader<String>;
	datetimeType(): string;
	uuidType(): string;
	execute(_: _, cnx: Connection, sql: string, args?: any[], opts?: SqlExecuteOptions): any;
	release(_: _): void;
	hintClause0(hint: Hint, def: boolean): string;
	hintClause1(hint: Hint, def: boolean): string;
	lockClause1(): string;
	rowIdGet(str: string): string;
	isNullDate(value: any): boolean;
	isNullUuid(value: any): boolean;
	readBlob(_: _, value: any): any;
	readClob(_: _, value: any): any;
	lengthString(): string;
	subString(arg: string, beg: string, end: string): string;
	rowIdPut(arg: string): string;
	uniqid(arg: string): string;
	describeQuery(_: _, sql: string, folder: string): SqlColumnInfo[];
	withConnection<T>(_: _, body: (_: _, cnx: Connection) => T): T;
	getFullTableDefName(def: TableDefinition): string;
	getFullTableName(schemaName: string, tableName: string): string;
	beginTransaction(_: _,  cnx: Connection): void;
	commitTransaction(_: _,  cnx: Connection): void;
	rollbackTransaction(_: _,  cnx: Connection): void;
	escape(name: string): string;
	toSqlLob(lob: { value: any }): any;
	toSqlUuid(uuid: Buffer): any;
	toSqlDate(date: any): any;
	allocConnection(_: _): Connection;
	releaseConnection(cnx: Connection, err?: Error): void;
	backupDatabase(_: _, dbName: string, filename: string): void;
	restoreDatabase(_: _, dbName: string, filename: string): void;
	readTables(_: _,  schemaName: string): TableDefinition[];
	createPermissions(_: _, tableDef: TableDefinition, config: PermissionsConfig): void;
	getTableDef(_: _,  schemaName: string, tablename: string): TableDefinition;
	createTableReader(_: _,  tableDef: TableDefinition, filters: TableFilter[]): ez.Reader<Record>;
	createTableWriter(_: _,  tableDef: TableDefinition): ez.Writer<Record>;
	clearTable(_: _,  tableDef: TableDefinition): void;
	dropTable(_: _,  tableDef: TableDefinition): void;
	dropSequence(_: _,  tableDef: TableDefinition): void;
	evalueRowCount(_: _,  tableDef: TableDefinition): number;
	readTableSchema(_: _,  tableDef: TableDefinition, tracker: any): void;
	createTableFromTableDefinition(_: _,  tableDef: TableDefinition, options: any): void;

	// only in SQL server??
	closeConnections?: (_: _) => void;
}

