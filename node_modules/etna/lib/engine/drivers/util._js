"use strict";

var attributes = require("etna/lib/supervisor/attributes");
var snapshots = require("etna/lib/supervisor/snapshots");

var tdate = require('etna/lib/engine/runtime/tdate');
var tuuid = require('etna/lib/engine/runtime/tuuid');
var variables = require('etna/lib/engine/runtime/variables');
var tdatetime = require('etna/lib/engine/runtime/tdatetime');
var bcd = require('etna/lib/engine/runtime/tbcd');

var Blbfile = require('etna/lib/engine/runtime/tblbfile').Blbfile;

var util = require('etna/lib/engine/runtime/util');

var datetime = require('syracuse-core').types.datetime;


var _typTyp2EtnaType = {
	1: "J",
	2: "I",
	3: "I",
	4: "N",
	6: "W",
	7: "S",
	8: "D",
	9: "B",
	10: "T",
	11: "Z",
	12: "E"
};

exports.trim = function(obj) {
	//trace && trace("trim:"+JSON.stringify(obj));
	var result = Object.keys(obj).reduce((o, k) => {
		var v = obj[k];


		var kk = (k == "ROWID") ? k : k.substring(0, k.lastIndexOf('_'));
		var isArray = (obj[kk + '_1'] !== undefined);
		if (isArray) {
			o[kk] = o[kk] || [];
			o[kk].push(v);
		} else {
			if ((v && v !== ' ') || (v === 0)) o[kk] = v;
		}
		return o;
	}, {});
	Object.keys(result).forEach(k => {
		var v = result[k];
		if (Array.isArray(v)) {
			var len = v.length;
			while (len > 0 && !(v[len - 1] && v[len - 1] !== ' ')) len--;
			result[k] = v.slice(0, len);
		}
	});
	return result;
};


exports.fromSql = function(_, val, type, driver) {
	//dbg:console.log("fromSql type:"+type);

	switch (type) {
		case 1:
		case 2:
		case 3:
			return (val !== null) ? (val.x3ToInteger ? val.x3ToInteger() : val) : 0;
		case 4:
			return (val !== null) ? val.x3ToBCD() : bcd.fromDouble(0);
		case 6:
			return (val !== null) ?  (val.x3ToDouble ? val.x3ToDouble() : val) : 0;
		case 7:
			return ((val !== null) && (val !== ' ')) ? val.x3ToString() : "";
		case 8:
			return (driver.isNullDate(val)) ? tdate.make(0, 0, 0) : tdate.fromJsDate(val, true);
		case 9:
			return (val !== null) ? new Blbfile(driver.readBlob(_, val)) : new Blbfile(new Buffer(0));
		case 10:
			return (val !== null) ? driver.readClob(_, val).x3ToString() : "";
		case 11:
			return (driver.isNullUuid(val)) ? tuuid.NULL : val.x3ToUuid();
		case 12:
			return (driver.isNullDate(val)) ? datetime.NULL : datetime.fromJsDate(val);
		default:
			return val;
	}
};

exports.toSql = function(params, driver) {
	return params.map(val => {
		//var v = (val && val.x3ToSql && val.x3ToSql(driver)) || val;
		var v = (val.x3ToSql && val.x3ToSql(driver)) || val;
		//console.log("value converted : "+v) ;
		return v;
	});
};

exports.maptrim = function(driver, typesmap, dispatch) {

	return function(_, obj) {
		if (dispatch) {
			var result = Object.keys(obj).reduce_(_, (_, record, k, idx) => {
				var fromSql = exports.fromSql;
				var v = fromSql(_, obj[k], typesmap[idx], driver);
				var def;
				if (typesmap[idx]) def = _typTyp2EtnaType[typesmap[idx]];

				var pos = k.lastIndexOf('$');
				if (pos >= 0) {
					var abv = k.substring(0, pos);
					var rec = record[abv] || (record[abv] = {});
					var kk = k.substring(pos + 1);
					var cmp1 = k.substring(0, k.lastIndexOf('_')) + "_1";
				} else {
					abv = " ";
					var rec = record[abv] || (record[abv] = {});
					var cmp1 = k.substring(0, k.lastIndexOf('_')) + "_1";
					kk = k;
				}

				//console.log("val:"+v+" idx : "+idx+ " key: "+k);
				var kk = (kk == "ROWID") ? kk : kk.substring(0, kk.lastIndexOf('_'));
				var isArray = (obj[cmp1] !== undefined);
				if (isArray) {
					rec[kk + "_default"] = def;
					rec[kk] = rec[kk] || [];
					rec[kk].push(v);
				} else {
					rec[kk] = v;
				}
				return record;
			}, []);

			Object.keys(result).forEach(k => {
				var row = result[k];
				Object.keys(row).forEach(ky => {
					var v = row[ky];
					if (Array.isArray(v)) {
						var len = v.length;
						var dim = len - 1;
						while (len > 0 && !(v[len - 1] !== "")) len--;
						row[ky] = [1, row[ky + "_default"], v.slice(0, len), 0, dim];
						delete row[ky + "_default"];
					}
				});
			});

		} else {
			var result = Object.keys(obj).reduce_(_, (_, o, k, idx) => {

				var fromSql = exports.fromSql;

				var v = fromSql(_, obj[k], typesmap[idx], driver);
				//console.log("val:"+v+" idx : "+idx+ " key: "+k);
				var kk = (k == "ROWID") ? k : k.substring(0, k.lastIndexOf('_'));
				var isArray = (obj[kk + '_1'] !== undefined);
				if (isArray) {
					o[kk] = o[kk] || [];
					o[kk].push(v);
				} else {
					o[kk] = v;
				}
				return o;
			}, {});

			Object.keys(result).forEach(k => {
				var v = result[k];
				if (Array.isArray(v)) {
					var len = v.length;
					while (len > 0 && !(v[len - 1] !== "")) len--;
					result[k] = v.slice(0, len);
				}
			});
		}
		return result;
	};
};

exports.mapFromSql = function(driver, abv, mapsql) {
	return function(_, obj) {
		var result = {};
		result[abv] = Object.keys(obj).reduce_(_, (_, o, k, idx) => {
			var fromSql = exports.fromSql;
			var v = fromSql(_, obj[k], mapsql[k].typtyp, driver);
			o[mapsql[k].name] = v;
			return o;
		}, {});

		return result;
	};
};