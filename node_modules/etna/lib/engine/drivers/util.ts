import { _ } from 'streamline-runtime';
import { Record, Driver, SqlColumnsDesc } from '../../engine/drivers/types';
import * as attributes from '../../supervisor/attributes';
import * as snapshots from '../../supervisor/meta/snapshots';
import * as tdate from '../runtime/tdate';
import * as tuuid from '../runtime/tuuid';
import * as variables from '../runtime/variables';
import * as tdatetime from '../runtime/tdatetime';
import * as bcd from '../runtime/tbcd';
import { Blbfile } from '../../engine/runtime/tblbfile';
import * as util from '../runtime/util';
const datetime = require('syracuse-core').types.datetime;
const _typTyp2EtnaType: { [id: number]: string } = {
	1: "J",
	2: "I",
	3: "I",
	4: "N",
	6: "W",
	7: "S",
	8: "D",
	9: "B",
	10: "T",
	11: "Z",
	12: "E"
};

export function trim<T1 extends Record, T2 extends Record>(obj: T1) {
	//trace && trace("trim:"+JSON.stringify(obj));
	const result = Object.keys(obj).reduce((o, k) => {
		const v = obj[k];
		const kk = k == "ROWID" ? k : k.substring(0, k.lastIndexOf('_'));
		const isArray = obj[kk + '_1'] !== undefined;

		if (isArray) {
			o[kk] = o[kk] || [];
			o[kk].push(v);
		} else {
			if (v && v !== ' ' || v === 0) o[kk] = v;
		}
		return o;
	}, {} as T2);

	Object.keys(result).forEach(k => {
		const v = result[k];

		if (Array.isArray(v)) {
			var len = v.length;
			while (len > 0 && !(v[len - 1] && v[len - 1] !== ' ')) len--;
			result[k] = v.slice(0, len);
		}
	});
	return result;
};

export function fromSql(_: _,  val: any, type: number, driver: Driver) {
	//dbg:console.log("fromSql type:"+type);

	switch (type) {
		case 1:
		case 2:
		case 3:
			return val !== null ? val.x3ToInteger ? val.x3ToInteger() : val : 0;
		case 4:
			return val !== null ? val.x3ToBCD() : bcd.fromDouble(0);
		case 6:
			return val !== null ? val.x3ToDouble ? val.x3ToDouble() : val : 0;
		case 7:
			return val !== null && val !== ' ' ? val.x3ToString() : "";
		case 8:
			return driver.isNullDate(val) ? tdate.make(0, 0, 0) : tdate.fromJsDate(val, true);
		case 9:
			return val !== null ? new Blbfile(driver.readBlob(_, val)) : new Blbfile(new Buffer(0));
		case 10:
			return val !== null ? driver.readClob(_, val).x3ToString() : "";
		case 11:
			return driver.isNullUuid(val) ? tuuid.NULL : val.x3ToUuid();
		case 12:
			return driver.isNullDate(val) ? datetime.NULL : datetime.fromJsDate(val);
		default:
			return val;
	}
};

export function toSql(params: any[], driver: Driver) {
	return params.map(val => {
		//var v = (val && val.x3ToSql && val.x3ToSql(driver)) || val;
		const v = val.x3ToSql && val.x3ToSql(driver) || val;
		//console.log("value converted : "+v) ;

		return v;
	});
};

export function maptrim<T1 extends Record, T2 extends Record>(driver: Driver, typesmap: number[], dispatch: boolean) {

	return function (_: _,  obj: T1) {
		if (dispatch) {
			var result = Object.keys(obj).reduce_(_, (_, record, k, idx) => {
				const v = fromSql(_, obj[k], typesmap[idx], driver);

				var def: string;
				if (typesmap[idx]) def = _typTyp2EtnaType[typesmap[idx]];

				const pos = k.lastIndexOf('$');

				if (pos >= 0) {
					var abv = k.substring(0, pos);
					var rec = record[abv] || (record[abv] = {});
					var kk = k.substring(pos + 1);
					var cmp1 = k.substring(0, k.lastIndexOf('_')) + "_1";
				} else {
					abv = " ";
					var rec = record[abv] || (record[abv] = {});
					var cmp1 = k.substring(0, k.lastIndexOf('_')) + "_1";
					kk = k;
				}

				//console.log("val:"+v+" idx : "+idx+ " key: "+k);
				var kk = kk == "ROWID" ? kk : kk.substring(0, kk.lastIndexOf('_'));
				const isArray = obj[cmp1] !== undefined;

				if (isArray) {
					rec[kk + "_default"] = def;
					rec[kk] = rec[kk] || [];
					rec[kk].push(v);
				} else {
					rec[kk] = v;
				}
				return record;
			}, {} as T2);

			Object.keys(result).forEach(k => {
				const row = result[k];

				Object.keys(row).forEach(ky => {
					const v = row[ky];

					if (Array.isArray(v)) {
						var len = v.length;
						var dim = len - 1;
						while (len > 0 && !(v[len - 1] !== "")) len--;
						row[ky] = [1, row[ky + "_default"], v.slice(0, len), 0, dim];
						delete row[ky + "_default"];
					}
				});
			});
		} else {
			var result = Object.keys(obj).reduce_(_, (_, o, k, idx) => {
				const v = fromSql(_, obj[k], typesmap[idx], driver);
				//console.log("val:"+v+" idx : "+idx+ " key: "+k);

				const kk = k == "ROWID" ? k : k.substring(0, k.lastIndexOf('_'));
				const isArray = obj[kk + '_1'] !== undefined;

				if (isArray) {
					o[kk] = o[kk] || [];
					o[kk].push(v);
				} else {
					o[kk] = v;
				}
				return o;
			}, {} as T2);

			Object.keys(result).forEach(k => {
				const v = result[k];

				if (Array.isArray(v)) {
					var len = v.length;
					while (len > 0 && !(v[len - 1] !== "")) len--;
					result[k] = v.slice(0, len);
				}
			});
		}
		return result;
	};
};

export function mapFromSql(driver: Driver, abv: string, mapsql: SqlColumnsDesc) {
	return function (_: _,  obj: Record) {
		const result: Record = {};

		result[abv] = Object.keys(obj).reduce_(_, (_, o, k, idx) => {
			const v = fromSql(_, obj[k], mapsql[k].typtyp, driver);
			o[mapsql[k].name] = v;
			return o;
		}, {} as Record);

		return result;
	};
};