import { _ } from 'streamline-runtime';
import * as ez from 'ez-streams';
import { Connection, Driver, TableDefinition, TableFilter, SqlExecuteOptions, DriverReaderOptions, PermissionsConfig } from './types';

/// Returns a reader that could be used to read all the records of the table
/// 'tableDef' is an object that have been created by getTableDef() or readTables() and updated by readTableSchema()

export function createTableReader(_: _,  driver: Driver, tableDef: TableDefinition, filters: TableFilter[]) {
	if (!tableDef.columns) throw new Error('Must call readTableSchema() before.');
	const columnNames = tableDef.columns.map(column => "T." + column.name);

	var sql = "SELECT " + columnNames.join(',') + " FROM " + driver.getFullTableDefName(tableDef) + " T";
	var filterValues: any[];

	if (filters) {
		// A list of 3-uplets {key, operator, value}
		filterValues = [];
		filters.forEach((filter, index) => {
			if (index == 0) sql += " WHERE ";
			else sql += " AND ";
			sql += "(T." + filter.key + " " + filter.operator + " " + driver.param(index) + ")";
			filterValues.push(filter.value);
		});
	}

	// Sort the rows by the first unique index
	const firstUniqueIndex = tableDef.indexes.filter(indexDef => indexDef.isUnique)[0];

	if (firstUniqueIndex) {
		firstUniqueIndex.columns.forEach((column, index) => {

			if (index == 0) sql += " ORDER BY ";
			else sql += ", ";
			sql += "T." + column.name;
		});
	}

	return driver.reader(_, sql, filterValues);
};

/// Tries to drop a table and returns whether the drop succeeded
export function dropTable(_: _,  driver: Driver, tableDef: TableDefinition) {
	try {
		// console.log("DROP TABLE " + driver.getFullTableDefName(tableDef));
		driver.execute(_, "DROP TABLE " + driver.getFullTableDefName(tableDef));
		return true;
	} catch (err) {
		// The table does not exist
		return false;
	}
};

/// Tries to drop the sequence bound to a table and returns whether the drop succeeded
export function dropSequence(_: _,  driver: Driver, tableDef: TableDefinition) {
	try {
		// console.log("DROP SEQUENCE " + driver.getFullTableName(tableDef.schemaName, "SEQ_" + tableDef.tableName));
		driver.execute(_, "DROP SEQUENCE " + driver.getFullTableName(tableDef.schemaName, "SEQ_" + tableDef.tableName));
		return true;
	} catch (err) {
		// The sequence does not exist
		return false;
	}
};

export function createPermissions(_: _,  driver: Driver, tableDef: TableDefinition, config: PermissionsConfig) {
	const PERMISSION_UPDATE = "UPDATE";
	const PERMISSION_SELECT = "SELECT";
	const PERMISSION_INSERT = "INSERT";
	const PERMISSION_DELETE = "DELETE";

	function grantPermission(_: _,  cnx: Connection, roleName: string, permission: string, fullTableName: string) {
		const sql = "GRANT " + permission + " ON " + fullTableName + " TO " + roleName;
		//console.log(">>>>>>>> " + sql);

		try {
			driver.execute(_, cnx, sql);
			return true;
		} catch (err) {
			return false;
		}
	}

	function grantPermissions(_: _,  cnx: Connection, roleName: string, permissions?: string[]) {
		var result = true;
		// By default, all the permissions are used
		permissions = permissions || [PERMISSION_UPDATE, PERMISSION_SELECT, PERMISSION_INSERT, PERMISSION_DELETE];

		// Grant permissions to the table
		permissions.forEach_(_, (_, perm) => {
			result = result && grantPermission(_, cnx, roleName, perm, driver.getFullTableDefName(tableDef));
		});
		return result;
	}

	driver.withConnection(_, (_, cnx) => {
		const folderName = tableDef.schemaName;

		if (tableDef.isOpenAccess) {
			// We only have to create 1 permission for the role FolderName_ADX_SYS
			grantPermissions(_, cnx, folderName + "_ADX_SYS");
		} else {
			// A little bit tricky ...

			// - give all permissions to FolderName_ADX_H
			grantPermissions(_, cnx, folderName + "_ADX_H");

			// - give only 'select' permission to FolderName_ADX_R
			grantPermissions(_, cnx, folderName + "_ADX_R", [PERMISSION_SELECT]);

			// - give only 'select' permission to FolderName_ADX_RH
			grantPermissions(_, cnx, folderName + "_ADX_RH", [PERMISSION_SELECT]);

			// - give only 'select' permission to FolderNameH
			grantPermissions(_, cnx, folderName + "H", [PERMISSION_SELECT]);

			// - give only 'update' permission to FolderName_ADX_SYS for the sequence
			grantPermission(_, cnx, folderName + "_ADX_SYS", PERMISSION_UPDATE, driver.getFullTableName(tableDef.schemaName, "SEQ_" + tableDef.tableName));

			// Now, we have to parse the folders chain to allow the current user to read in the tables from the parent folders
			// for instance, if a SEED folder is a child of a X3 folder, the SEED user must be able to read the tables from the X3 schema
			// (some tables such as ADOSSIER, ... only exist in the root folder)

			var loopCount = 0; // just a security to avoid endless loops (corrupted database)
			var sqlQuery = "SELECT DOSREF_0 FROM " + driver.getFullTableName(config.rootFolderName, 'ADOSSIER') + " WHERE DOSSIER_0 = " + driver.param(0);
			var schemaName = folderName;
			while (loopCount < 20) {
				// - give all permissions to FolderName_ADX
				grantPermissions(_, cnx, folderName + "_ADX");

				// - allow folderName_ADX_R to read the table in the 'parent' schema (i.e. the schema of the parent folder)
				grantPermission(_, cnx, folderName + "_ADX_R", PERMISSION_SELECT, driver.getFullTableName(schemaName, tableDef.tableName));

				var row = driver.reader<{
					DOSREF_0: string;
				}>(_, cnx, sqlQuery, [schemaName]).toArray(_)[0];
				if (!row) break;
				if (row['DOSREF_0'] == folderName) {
					// We have reach the root folder
					break;
				}
				schemaName = row['DOSREF_0'];
				loopCount++;
			}
		}
	});
};

export type Reader<T> = (_: _, cnx: Connection, sql: string, args: any[], opts?: DriverReaderOptions) => ez.Reader<T>;
export type Writer<T> = (_: _, cnx: Connection, sql: string, opts?: SqlExecuteOptions) => ez.Writer<T>;

export function reader<T>(creator: Reader<T>): Reader<T> {
	return function (_,  cnx, sql, args, opts) {
		if (typeof cnx === "string") {
			opts = args;
			args = sql as any;
			sql = cnx as any;
			cnx = null;
		}
		opts = opts || {};
		if (cnx != null) return creator.call(this, _, cnx, sql, args, opts);
		cnx = this.allocConnection(_);
		const reader = creator.call(this, _, cnx, sql, args, opts);

		return ez.devices.generic.reader(_ => {
			try {
				var val = reader.read(_);
				if (val === undefined && cnx) cnx = this.releaseConnection(cnx);
				return val;
			} catch (ex) {
				if (cnx) cnx = this.releaseConnection(cnx, ex);
				throw ex;
			}
		}, _ => {
			reader.stop(_);
			if (cnx) cnx = this.releaseConnection(cnx);
		});
	};
};

export function writer<T>(creator: Writer<T>): Writer<T> {
	return function (_,  cnx, sql, opts) {
		if (typeof cnx === "string") {
			opts = sql;
			sql = cnx as any;
			cnx = null;
		}
		opts = opts || {};
		if (cnx != null) return creator.call(this, _, cnx, sql, opts);
		cnx = this.allocConnection(_);
		const writer = creator.call(this, _, cnx, sql, opts);

		return ez.devices.generic.writer((_, val) => {
			try {
				writer.write(_, val);
				if (val === undefined && cnx) cnx = this.releaseConnection(cnx);
				return this;
			} catch (ex) {
				if (cnx) cnx = this.releaseConnection(cnx, ex);
				throw ex;
			}
		}, _ => {
			writer.stop(_);
			if (cnx) cnx = this.releaseConnection(cnx);
			return this;
		});
	};
};