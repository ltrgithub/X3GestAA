import { _ } from 'streamline-runtime';
import { Driver, DriverConfig, Record } from '../drivers/types';
import * as types from './types';
import * as ez from 'ez-streams';
const eztedious = require('ez-tedious');
import * as tds from 'tedious';

import * as tuuid from '../runtime/tuuid';
import { Blbfile } from '../../engine/runtime/tblbfile';
const date = require('syracuse-core').types.date;
const datetime = require('syracuse-core').types.datetime;
const common = require("./drivers-common");
const tracer = require('syracuse-core').getTracer("etna.engine");

function any(x: any) { return x; } 

function rowIn(columns: tds.ColumnValue[]) {

	if (!columns) return null;

	const row: Record = {};
	for (let i = 0, len = columns.length; i < len; i++) {
		const col = columns[i];
		let colName: string, colValue: any;

		//  uuid  driver format
		if (/^U#/.test(col.metadata.colName)) {
			colName = col.metadata.colName.substring(2);
			colValue = col.value.toString('hex').toUpperCase();
		} else {
			colName = col.metadata.colName;
			colValue = col.value;
		}

		// modify row format
		var exi = row[colName];
		if (exi != null) {
			if (Array.isArray(exi)) {
				exi.push(colValue);
			} else {
				row[colName] = [exi, colValue];
			}
		} else {
			row[colName] = colValue;
		}
	}
	return row;
}

function fillParameters(req: tds.Request, args: any[]) {
	function processParam(name: any, type: tds.TediousType, value: any) {
		const param = any(req).parametersByName[name];

		if (param) param.value = value;
		else req.addParameter(name, type, value);
	}

	for (var i = 0; args && i < args.length; i++) {
		if (args[i] instanceof Buffer) processParam("p" + i, tds.TYPES.Binary, args[i]);
		else if (args[i] instanceof Blbfile) processParam("p" + i, tds.TYPES.VarBinary, args[i].value);
		else if (args[i] instanceof Date) processParam("p" + i, tds.TYPES.DateTime, args[i]);
		else if (typeof args[i] === "number") processParam("p" + i, tds.TYPES.Int, args[i]);
		else processParam("p" + i, tds.TYPES.NVarChar, args[i]);
	}
}

function describeColumns(request: tds.Request, columnDefs: { [name: string]: types.ColumnDefinition }) {
	Object.keys(columnDefs).forEach(paramName => {
		const columnDef = columnDefs[paramName];

		if (paramName[0] = '@') paramName = paramName.substring(1);
		switch (columnDef.type) {
			case "tinyint":
				request.addParameter(paramName, tds.TYPES.TinyInt, 0);
				break;
			case "smallint":
				request.addParameter(paramName, tds.TYPES.SmallInt, 0);
				break;
			case "int":
				request.addParameter(paramName, tds.TYPES.Int, 0);
				break;
			case "date":
			case "datetime":
				request.addParameter(paramName, tds.TYPES.DateTime, new Date());
				break;
			case "decimal":
				request.addParameter(paramName, tds.TYPES.VarChar, '');
				break;
			case "blob":
				request.addParameter(paramName, tds.TYPES.VarBinary, new Buffer(0));
				break;
			case "varchar":
				request.addParameter(paramName, tds.TYPES.VarChar, '');
				break;
			case "uuid":
			case "binary":
				request.addParameter(paramName, tds.TYPES.Binary, new Buffer(0));
				break;
			case "clob":
				request.addParameter(paramName, tds.TYPES.Text, '');
				break;
			case "nvarchar":
				request.addParameter(paramName, tds.TYPES.NVarChar, '');
				break;
			default:
				throw new Error('unknown column type ' + columnDef.type + ' for parameter ' + paramName);
		}
	});
}

const tds_connect = _.cast(function(callback: (err: Error, cnx?: tds.Connection) => void, cfg: tds.ConnectionConfig) {
	const c = new tds.Connection(cfg);

	c.on('connect', (err: Error) => {
		callback(err, !err && c);
	});
	c.on('debug', (text: string) => {
		tracer.debug && tracer.debug("DEBUG : " + text);
	});
});

function tds_param(i: number) {
	return "@p" + i;
}

const tds_query = _.cast(function(callback: (err: Error, records: any) => void, cfg: tds.ConnectionConfig, cnx: tds.Connection, sql: string, args: any[]) {
	tracer.debug && tracer.debug("tds_query:" + sql + (args ? " with " + JSON.stringify(args) : ""));
	const records: any = [];
	const req = new tds.Request(sql, (err: Error, rowCount: number) => {
		tracer.debug && tracer.debug("Request end: err=" + err + ", rowCount=" + rowCount);
		if (!err) records.updateCount = rowCount;
		req.removeAllListeners();
		return callback(err, !err && records);
	});

	fillParameters(req, args);
	req.on("row", (columns: tds.ColumnValue[]) => {
		records.push(rowIn(columns));
	});
	cnx.execSql(req);
	return req;
});

const tds_close = _.cast(function(callback: (err: Error, result: void) => void, cnx: tds.Connection) {
	cnx.on("end", () => {
		callback(null, null);
	});
	cnx.close();
});

/*
 * Returns the precision/scale of the format to apply to a decimal column, from its definition in ATABZON
 * This function is a based on script DOSTAB.src, label $ECRIZONE
 */

interface DecimalFormat {
	precision: number;
	scale: number;
}

function getDecimalFormat(atabzonPrecision?: number, atabzonScale?: number, options?: any) {
	options = options || {};
	// Warning : atabzonPrecision does not include the decimal part.
	// atabzonPrecision = 7 / atabzonScale = 2 means 9999999.99
	// This function will return a format where the precision will include the scale (precision = 7 / scale = 2 means 99999.99)
	var precision: number, scale: number;
	if (isNaN(atabzonPrecision) || isNaN(atabzonScale)) {
		precision = 4;
		scale = 3;
	} else {
		precision = Math.min(atabzonPrecision, 28);
		scale = atabzonScale;

		if (options.useFloatingPointFormat) {
			if (scale > 0) {
				precision = Math.min(14, precision + scale);
			}
			scale = Math.min(precision - 1, 28 - scale);
		} else {
			precision += Math.max(Math.min(scale, 28 - precision - scale), 0);
			scale++;
		}
		if (precision + scale > 28) scale = 28 - precision;
	}

	//console.log("RRRR " + atabzonPrecision + ":" + atabzonScale + " -> " + precision + ":" + scale);
	return {
		precision: precision + scale,
		scale: scale
	};
}

function getConfig(config: types.DriverConfig): tds.ConnectionConfig {
	var cfg: any /*tds.ConnectionConfig*/ = {};
	if (config) {
		var srv = config.hostname.split("\\");
		console.log("Create " + srv[0] + ' ' + srv[1]);
		cfg = {
			userName: config.user || 'X3',
			password: config.password,
			server: srv[0],
			options: {
				database: config.database,
				instanceName: srv[1],
				decimalsAsString: true,
				requestTimeout: config.requestTimeout || 0,
				isolationLevel: tds.ISOLATION_LEVEL.SNAPSHOT
			}
		};

		//trace: config.trace
		cfg.options.debug = {
			//packet: true,
			//data: true,
			//payload: true,
			//token: true,
			log: true
		};

		console.log(cfg);
	}
	return cfg;
}

module.exports = function (config: DriverConfig): Driver {
	console.log("Create config...");
	const cfg = getConfig(config);
	const trace = config.trace;
	const connections: tds.Connection[] = [];

	const driver: types.BaseDriver = {
		uniqid(name) {
			return "select NEXT VALUE FOR SEQ_" + name + " As A$RESULT_0";
		},
		lockClause0() {
			return " With (UPDLOCK HOLDLOCK)";
		},
		lockClause1() {
			return "";
		},
		hintClause0(hnt, def) {
			return "";
		},
		hintClause1(hnt, def) {
			if (hnt) {
				if (hnt.nohint || hnt.name === "") return "";

				return " Option (FAST 1)";
			} else if (def) {
				return " Option (FAST 1)";
			} else return "";
		},
		lengthString() {
			return "len";
		},
		subString(arg, deb, fin) {
			return "substring(" + arg + ", " + deb + ", " + fin + ")";
		},
		toSqlLob(val) {
			return val;
		},
		toSqlUuid(val) {
			return val;
		},

		nullDate() {
			return new datetime.fromMillis(Date.UTC(1753, 0, 1));
		},

		isNullDate(val) {
			return val === null || val === undefined || val && val.getFullYear() === 1753 && val.getMonth() === 0 && val.getDay() === 1;
		},

		isNullUuid(val) {
			if (val === null || val === undefined) return true;

			for (var i = 0; i < 16; i++) {
				if (val[i] !== 0) return false;
			}
			return true;
		},

		toSqlDate(val) {
			var date: any;
			// very strange: Date.parse returns integer!
			if ('string' === typeof val) date = Date.parse(val);
			else {
				// Assume the val is a Date object
				date = val;
			}
			return "'" + date.toISOString() + "'";
		},
		blobReader(_,  val) {
			return ez.devices.buffer.reader(val);
		},
		clobReader(_,  val) {
			return ez.devices.string.reader(val);
		},
		readBlob(_,  val) {
			return val;
		},
		readClob(_,  val) {
			return val;
		},
		escape(name) {
			return '"' + name + '"';
		},
		param(i) {
			return tds_param(i);
		},
		rowIdGet(v) {
			return v;
		},
		rowIdPut(v) {
			return v;
		},
		beginTransaction(_,  cnx) {
			cnx.beginTransaction(_);
		},
		commitTransaction(_,  cnx) {
			cnx.commitTransaction(_);
		},
		rollbackTransaction(_,  cnx) {
			cnx.rollbackTransaction(_);
		},
		allocConnection(_: _) {
			var cnx = connections.pop();
			if (!cnx) {
				trace && trace("connecting on " + cfg.server + "...");
				cnx = tds_connect(_, cfg);
				trace && trace("connected");
			}
			return cnx;
		},
		releaseConnection(cnx) {
			connections.push(cnx);
		},
		withConnection<T>(_: _,  body: (_: _, cnx: types.Connection) => T): T {
			const cnx = this.allocConnection(_);
			try {
				return body(_, cnx);
			} finally {
				this.releaseConnection(cnx);
			}
		},

		closeConnections(_) {
			connections.forEach_(_, (_, cnx) => {
				cnx && tds_close(_, cnx);
			});
		},

		execute(_: _,  cnx: types.Connection, sql: string, args?: any[], opts?: types.SqlExecuteOptions) {
			if (typeof cnx === "string") {
				opts = args;
				args = any(sql);
				sql = cnx;
				cnx = null;
			}
			if (cnx == null) {
				return this.withConnection(_, (_: _, cnx: types.Connection) => this.execute(_, cnx, sql, args, opts));
			}
			console.error("EXECUTE", sql, args && args.map(arg => typeof arg + " isbuf=" + Buffer.isBuffer(arg) + " len=" + (arg && arg.length) + ': ' + (arg && (arg.length > 100 ? arg.slice(0, 100) + "..." : Buffer.isBuffer(arg) ? arg.toString('hex') : arg)) + "\n"));
			const result = tds_query(_, cfg, cnx, sql, args);

			return result;
		},

		reader: common.reader((_: _, cnx: types.Connection, sql: string, args: any[], opts: types.DriverReaderOptions) => {
			return eztedious.reader(cnx, sql, args, {
				fillParameters: fillParameters
			}).map((_: _, row: any) => rowIn(row));
		}),
		// opts parameter is strange here...
		writer: common.writer((_: _, cnx: types.Connection, sql: string, opts: any) => {
			return eztedious.writer(cnx, sql, {
				describeColumns(request: tds.Request) {
					describeColumns(request, opts);
				}
			});
		}),
		dropIndexSql(indexName, tableName) {
			return 'drop index "' + tableName + '"."' + indexName + '"';
		},
		isIndexNotFound(ex) {
			console.error("ISINDEXNOTFOUND", ex.code, ex.message);
			//return /ORA-01418/.test(ex.message);
			return false;
		},
		isUniqueViolated(ex) {
			return ex.code === 'EREQUEST' && /^Cannot insert duplicate key row in object/.test(ex.message);
		},
		isLocked(ex) {
			console.error("ISLOCKED", ex.code, ex.message);
			//return /ORA-01418/.test(ex.message);
			return false;
		},
		isNoRecord(ex) {
			console.error("ISNORECORD", ex.code, ex.message);
			//return /ORA-01418/.test(ex.message);
			return false;
		},
		isTableNotFound(ex) {
			console.error("ISTABLENOTFOUND", ex.code, ex.message);
			if (/it does not exist/.test(ex.message)) return true;
			if (/Invalid object name/.test(ex.message)) {
				// sth like 'Invalid object name 'xxxx'
				return true;
			}
			return false;
		},
		blobType() {
			return "varbinary(max)";
		},
		clobType() {
			return "varchar(max)";
		},
		tinyIntType() {
			return "tinyint";
		},
		shortIntType() {
			return "smallint";
		},
		intType() {
			return "int";
		},
		stringType(len) {
			return "nvarchar(" + len + ")";
		},
		dateType() {
			return "datetime";
		},
		datetimeType() {
			return "datetime";
		},
		uuidType() {
			return "binary(16)";
		},
		decimalType() {
			// for now handle as char to keep full precision
			return "numeric";
		},
		doubleType() {
			// for now handle as char to keep full precision
			return "float"; // float is double (8 bytes), and real is single (4 bytes)
		},

		tableExists(_,  tableName, schemaName) {
			return !!this.reader(_, "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = ? AND TABLE_NAME = ?", [schemaName, tableName]).toArray(_)[0];
		},
		/// Returns the definition of a table from its name.
		getTableDef(_,  schemaName, tableName) {
			const tableDef = {
				schemaName: schemaName,
				tableName: tableName
			};

			this.readTableSchema(_, tableDef);
			return tableDef;
		},

		/// Enhance a table definition with its columns, indices, ...
		/// 'tableDef' is an object that have been created by readTables() / getTableDef()
		readTableSchema(_,  tableDef, tracker) {
			// ----------------------------------------
			// Read the columns of the table
			// ----------------------------------------
			var sqlQuery = "SELECT c.object_id table_id, c.column_id col_id, c.name col_name, c.system_type_id col_type, c.max_length col_max_length," + " c.is_nullable col_is_nullable, c.precision col_precision, c.scale col_scale, c.default_object_id col_default_object_id," + " d.definition def_definition," + " o.schema_id schema_id," + " t.TYPTYP_0 type_type, t.OPTION_0 type_option, t.LNGTYP_0 type_length," + " tbl.UPDDATTIM_0 tbl_updateDateTime," + " z.LONG_0 zone_length, z.OPTION_0 zone_option" + " FROM sys.columns c" + " LEFT JOIN sys.objects o ON c.object_id = o.object_id" + " LEFT JOIN sys.schemas s ON o.schema_id = s.schema_id" + " LEFT JOIN sys.default_constraints d ON d.object_id = c.default_object_id" +
			// Note : we have to escape the underscore in the following LIKE with [_], otherwise, the _ would be treated as a char joker
			" LEFT JOIN " + this.getFullTableName(tableDef.schemaName, "ATABZON") + " z ON z.CODFIC_0 = o.name AND c.name LIKE CONCAT(z.CODZONE_0, '[_]%')" + " LEFT JOIN " + this.getFullTableName(tableDef.schemaName, "ATYPE") + " t ON z.CODTYP_0 = t.CODTYP_0" + " LEFT JOIN " + this.getFullTableName(tableDef.schemaName, "ATABLE") + " tbl ON z.CODFIC_0 = tbl.CODFIC_0" + " WHERE o.name='" + tableDef.tableName + "'" + " AND s.name='" + tableDef.schemaName + "'" + " AND c.name != 'ROWID'" + " ORDER BY col_name";

			//console.log(sqlQuery);
			var tableId: string, schemaId: string;
			//const columnsById = [];

			tableDef.columns = this.reader(_, sqlQuery).toArray(_).map((row: any) => {
				if (!tableId) {
					// This is the first row
					// Note: all the rows have the same table_id
					tableId = row.table_id;
					schemaId = row.schema_id;
					tableDef.lastUpdate = row.tbl_updateDateTime;
					//	console.log("W>>>>>>> " + row.col_name + " / " + row.tbl_updateDateTime);
				}
				const column: types.ColumnDefinition = {
					name: row.col_name,
					isNullable: row.col_is_nullable
				};

				switch (row.col_type) {
					case 48:
						column.type = "tinyint";
						break;
					case 52:
						column.type = "smallint";
						break;
					case 56:
						column.type = "int";
						break;
					case 61:
						column.type = "datetime";
						if (row.type_type) {
							// A metadata could be found from X3 (ATABZON/ATYPE)
							// we can use it to distinguish dates from datetimes (in SQL server, both are declared as datetimes)
							if (row.type_type == 8) {
								// This datetime is a date ...
								column.type = "date";
							}
						}
						break;
					case 108:
						// numeric
						column.type = "decimal";
						if (row.type_type != 4) {
							var msg = "Inconsistent metadata for column " + tableDef.tableName + "." + column.name + " : types mismatch (expected 4 but got " + row.type_type + ")";
							if (tracker) {
								(tracker.$diagnoses = tracker.$diagnoses || []).push({
									$severity: "warning",
									$message: msg
								});
							}
							console.log("WARNING : " + msg);
						}
						// precision/scale must not be extracted from sys.columns; instead we have to extract the format from ATYPE table
						var precision = row.zone_length;
						if (precision == 0) {
							// No format is specified in ATABZON, it's inherited from the type of the column (ATYPE)
							precision = row.type_length;
						}
						column.decimalPrecision = Math.floor(precision);
						column.decimalScale = Math.round((precision - column.decimalPrecision) * 10);

						// Determine whether the column uses the floating point notation
						// i.e. ATABZON.OPTION_0 ou ATYPE.OPTION_0 contains the character 'F'
						var useFloatingPointFormat = row.zone_option && row.zone_option.indexOf('F') != -1 || row.type_option && row.type_option.indexOf('F') != -1;

						var fmt = getDecimalFormat(column.decimalPrecision, column.decimalScale, {
							useFloatingPointFormat: useFloatingPointFormat
						});
						if (fmt.precision != row.col_precision || fmt.scale != row.col_scale) {
							var msg = "Inconsistent metadata for column " + tableDef.tableName + "." + column.name + " : format mismatch (computed " + fmt.precision + ":" + fmt.scale + " but got from db " + row.col_precision + ":" + row.col_scale + ")";
							if (tracker) {
								(tracker.$diagnoses = tracker.$diagnoses || []).push({
									$severity: "warning",
									$message: msg
								});
							}
							console.log("WARNING : " + msg);
						}
						column.useFloatingPointFormat = useFloatingPointFormat;
						// Note : in X3, 999.99 is described as 3.2 but for us, the precision includes the scale so 3.2 -> 5.2
						column.decimalPrecision += column.decimalScale;
						break;
					case 165:
						column.type = "blob";
						break;
					case 167:
						// varchar(n)
						column.type = "varchar";
						column.maxLength = row.col_max_length;
						break;
					case 173:
						// binary(n)
						if (row.col_max_length == 16) column.type = "uuid";
						else {
							column.type = "binary";
							column.maxLength = row.col_max_length;
						}
						break;
					case 231:
						// nvarchar(n)
						if (row.col_max_length == -1) column.type = "clob";
						else {
							// Note : row.col_max_length <=> nvarchar(max)
							column.type = "nvarchar";
							column.maxLength = row.col_max_length / 2; // utf8 encoding, the size must be divided by 2.
						}
						break;
					default:
						throw new Error('unknown column type ' + row.col_xtype + ' for column ' + this.getFullTableDefName(tableDef) + '.' + row.col_name);
				}
				if (row.col_default_object_id) {
					// The columns has a default value
					//	column.default = row.def_definition;
				}
				//columnsById[row.col_id] = column;
				return column;
			});

			// ----------------------------------------
			// Read some properties of the table
			// ----------------------------------------
			sqlQuery = "SELECT TOP 1 SECURE_0 FROM " + this.getFullTableName(tableDef.schemaName, "ATABLE") + " WHERE CODFIC_0 = " + this.param(0);
			const row = this.reader(_, sqlQuery, [tableDef.tableName]).toArray(_)[0];

			tableDef.isOpenAccess = !row || row["SECURE_0"] == 2;

			// ----------------------------------------
			// Read the indices of the table
			// ----------------------------------------
			sqlQuery = "SELECT ic.index_id index_id, ic.index_column_id index_column_id, " + "i.is_unique index_unique, i.is_primary_key index_is_pk, " + "c.name column_name, i.name index_name, ic.is_descending_key column_descending " + "FROM sys.index_columns ic " + "LEFT JOIN sys.indexes i ON i.index_id = ic.index_id AND i.object_id = ic.object_id " + "LEFT JOIN sys.columns c ON c.column_id = ic.column_id AND c.object_id = ic.object_id " + "WHERE i.object_id = " + tableId + " AND i.type > 0 " + "AND c.name != 'ROWID' " + "ORDER BY i.name, ic.index_column_id";

			var currentIndex: types.IndexDefinition;
			var currentIndexId: any;
			tableDef.indexes = [];
			this.reader(_, sqlQuery).toArray(_).forEach((row: any) => {
				if (row.index_id != currentIndexId) {
					// This is either the first index or a new index (rows are sorted by index)
					currentIndexId = row.index_id;
					currentIndex = {
						name: row.index_name,
						isPk: row.index_is_pk,
						isUnique: row.index_unique,
						columns: []
					};
					tableDef.indexes.push(currentIndex);
				}
				const column = {
					name: row.column_name,
					ascending: !row.column_descending
				};

				currentIndex.columns.push(column);
			});

			// ----------------------------------------
			// Read the sequence of the table
			// ----------------------------------------
			// Note the tedious driver does not support sql_variant, we have to use CAST
			sqlQuery = "SELECT TOP 1 CAST(current_value AS int) seq_value " + " FROM sys.sequences" + " WHERE name = '" + "SEQ_" + tableDef.tableName + "'" + " AND schema_id = " + schemaId;
			this.reader(_, sqlQuery).toArray(_).forEach((row: any) => {
				tableDef.sequence = row.seq_value;
			});
		},

		createTableFromTableDefinition(_,  tableDef, options) {
			options = options || {};
			options.showCommands = false;
			options.skipCommands = false;
			if (options.onlyIndexes) {
				options.skipDrop = true;
				options.skipCreate = true;
				options.skipSequences = true;
				options.skipIndexes = false;
			}
			// -------------------------------------
			// Drop the existing table
			// -------------------------------------
			if (!options.skipDrop) {
				// Drop the existing table and its sequence
				this.dropTable(_, tableDef);
				this.dropSequence(_, tableDef);
			}
			// -------------------------------------
			// Create the table and its columns
			// -------------------------------------
			if (!options.skipCreate) {
				// Create the table (and the columns)
				var sql = "CREATE TABLE " + this.getFullTableDefName(tableDef) + " ([ROWID] numeric(38, 0) IDENTITY(1,1) NOT NULL";
				tableDef.columns.forEach(colDef => {
					sql += ", [" + colDef.name + "] ";
					switch (colDef.type) {
						case "tinyint":
							sql += "tinyint";
							break;
						case "smallint":
							sql += "smallint";
							break;
						case "int":
							sql += "int";
							break;
						case "datetime":
						case "date":
							// In SqlServer, dates are declared as datetimes
							sql += "datetime";
							break;
						case "decimal":
							var fmt: DecimalFormat;
							if (colDef.decimalPrecision && colDef.decimalScale) fmt = getDecimalFormat(colDef.decimalPrecision - colDef.decimalScale, colDef.decimalScale, colDef.useFloatingPointFormat);
							else fmt = getDecimalFormat();
							sql += "numeric(" + fmt.precision + ", " + fmt.scale + ")";
							break;
						case "blob":
							sql += "varbinary(max)";
							break;
						case "varchar":
							sql += "varchar(" + colDef.maxLength + ")";
							break;
						case "clob":
							sql += "nvarchar(max)";
							break;
						case "nvarchar":
							sql += "nvarchar(" + colDef.maxLength + ")";
							break;
						case "uuid":
							sql += "binary(16)";
							break;
						case "binary":
							sql += "binary(" + colDef.maxLength + ")";
							break;
						default:
							throw new Error('unknown column type ' + colDef.colType + ' for column ' + this.getFullTableDefName(tableDef) + '.' + colDef.name);
					}
					if (!colDef.isNullable) sql += " NOT NULL";
					if (colDef.default) sql += " DEFAULT " + colDef.default;
				});
				sql += ", CONSTRAINT [" + tableDef.tableName + "_ROWID] PRIMARY KEY NONCLUSTERED ([ROWID] ASC)";
				sql += ")";
				options.showCommands && console.log(sql);
				!options.skipCommands && this.execute(_, sql);
			}
			// -------------------------------------
			// Create the indexes
			// -------------------------------------
			if (!options.skipIndexes) {
				tableDef.indexes.forEach_(_, (_, indexDef) => {
					var sql = "CREATE ";
					if (indexDef.isUnique) sql += "UNIQUE ";
					sql += "INDEX [" + indexDef.name + "] ON " + this.getFullTableDefName(tableDef) + " (";
					indexDef.columns.forEach((column, colIdx) => {
						if (colIdx > 0) sql += ", ";
						sql += "[" + column.name + "]";
						if (!column.ascending) sql += " DESC";
					});
					sql += ")";
					options.showCommands && console.log(sql);
					!options.skipCommands && this.execute(_, sql);
				});
			}
			// -------------------------------------
			// Create (when needed) the sequence
			// -------------------------------------
			if (!options.skipSequences && tableDef.sequence) {
				var sql = "CREATE SEQUENCE [" + tableDef.schemaName + "].[SEQ_" + tableDef.tableName + "]";
				sql += " AS int";
				sql += " START WITH " + tableDef.sequence;
				options.showCommands && console.log(sql);
				!options.skipCommands && this.execute(_, sql);
			}
		},

		createPermissions(_,  tableDef, config) {
			return common.createPermissions(_, this, tableDef, config);
		},

		/// Returns the list of all the tables defined in the database / schema
		readTables(_,  schemaName) {
			const tables: types.TableDefinition[] = [];

			// We only return the tables that exist in the db AND are described in ATABLE.
			// - a table might exist in ATABLE but not in the db (when the bound activity code is not enabled)
			// - a table might exist in the db but not in ATABLE (temp tables, manually created tables, ...)

			var sql = "SELECT o.name name, t.CODFIC_0 FROM sys.objects o";
			if (schemaName) sql += " LEFT JOIN sys.schemas s ON o.schema_id = s.schema_id";
			sql += " LEFT JOIN ATABLE t ON t.CODFIC_0 = o.name";
			sql += " WHERE o.type = 'U' AND NOT(t.CODFIC_0 IS NULL)";
			if (schemaName) sql += " AND s.name = '" + schemaName + "'";
			sql += " ORDER BY o.name";

			this.reader(_, sql).forEach(_, (_: _, item: any) => {
				tables.push({
					schemaName: schemaName,
					tableName: item.name
				});
			});
			return tables;
		},

		/// Returns a reader that could be used to read all the records of the table
		/// 'tableDef' is an object that have been created by getTableDef() or readTables() and updated by readTableSchema()
		createTableReader(_,  tableDef, filters) {
			return common.createTableReader(_, this, tableDef, filters);
		},

		createTableWriter(_,  tableDef) {
			const columnNames: string[] = [];
			const paramNames: string[] = [];
			const columnDefs: { [name: string]: types.ColumnDefinition } = {};

			tableDef.columns.forEach((column, index) => {
				if (column.name == "ROWID") return;
				columnNames.push(column.name);
				const paramName = this.param(index);

				paramNames.push(paramName);
				columnDefs[paramName] = column;
			});

			const sql = "INSERT INTO " + this.getFullTableDefName(tableDef) + " (" + columnNames.join(',') + ") VALUES (" + paramNames.join(',') + ")";

			return this.withConnection(_, (_: _, cnx: types.Connection) => {
				return this.writer(_, cnx, sql, columnDefs);
			});
		},

		getFullTableDefName(tableDef) {
			return this.getFullTableName(tableDef.schemaName, tableDef.tableName);
		},

		getFullTableName(schemaName, tableName) {
			if (schemaName) return "[" + schemaName + "].[" + tableName + "]";
			else return "[" + tableName + "]";
		},

		clearTable(_,  tableDef) {
			this.execute(_, "DELETE FROM " + this.getFullTableDefName(tableDef));
		},

		/// Tries to drop a table and returns whether the drop succeeded
		dropTable(_,  tableDef) {
			return common.dropTable(_, this, tableDef);
		},

		/// Tries to drop the sequence bound to a table and returns whether the drop succeeded
		dropSequence(_,  tableDef) {
			return common.dropSequence(_, this, tableDef);
		},
		evalueRowCount(_,  tableName) {
			this.reader(_, "select top 1 rows from sysindexes where id = object_id('" + this.param(0) + "') and indid < 2", [tableName]).toArray(_);
			return 0 / 0; //TODO ?
		},
		release(_: _) {},
		lobPlaceholder: null,
		describeQuery: null,
		backupDatabase: null,
		restoreDatabase: null,
	};
	return any(driver);
};