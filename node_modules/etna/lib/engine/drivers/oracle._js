"use strict";

const ez = require('ez-streams');
const crypto = require('crypto');
const ezoracle = require('ez-oracle');
const oracle = require('oracledb');
const date = require('syracuse-core').types.date;
const datetime = require('syracuse-core').types.datetime;
const common = require("./drivers-common");
const tracerJs = require('syracuse-core').getTracer("etna.dbms");

//tracerJs = { debug: console.error }

const _months = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];

function setFetchInfo(opts) {
	if (opts && opts.decimalColumns && opts.decimalColumns.length) {
		var asString = {
			type: oracle.STRING
		};
		opts.fetchInfo = {};
		for (var i = 0; i < opts.decimalColumns.length; i++) {
			opts.fetchInfo[opts.decimalColumns[i]] = asString;
		}
	}
}

module.exports = function (config) {
	config.connectString = config.hostname + (config.port ? ':' + config.port : '') + '/' + config.database;
	const trace = config.trace;
	const connections = [];
	const counters = {
		alloc: 0,
		used: 0,
		discarded: 0,
		warned: 5
	};

	return {
		uniqid(name) {
			return "Select SEQ_" + name + ".nextval As A$RESULT_0 from dual";
		},
		lockClause0() {
			return "";
		},
		lockClause1() {
			return " For Update";
		},
		hintClause0(hnt, def) {
			// rf : read or for
			if (hnt) {
				if (hnt.nohint || hnt.name === "") return "";

				return "/*+ INDEX" + (hnt.revert ? "_DESC" : "") + "(" + hnt.abbrev + " " + hnt.tname + "_" + hnt.name + ") */";
			} else if (def) return "/*+ FIRST_ROWS ( 1 ) */";else return "";
		},
		hintClause1(hnt, def) {
			return "";
		},
		lengthString() {
			return "length";
		},
		subString(arg, deb, fin) {
			return "substr(" + arg + ", " + deb + ", " + fin + ")";
		},
		toSqlLob(val) {
			return "" + val.value.toString('hex');
		},
		blobReader(_, val) {
			return ezoracle.lob.reader(val);
		},
		clobReader(_, val) {
			return ezoracle.lob.reader(val);
		},
		readBlob(_, val) {
			return ezoracle.lob.reader(val).readAll(_);
		},
		readClob(_, val) {
			return ezoracle.lob.reader(val).readAll(_);
		},
		toSqlUuid(val) {
			return val.x3ToSqlString();
		},
		toSqlDate(val) {
			var date;
			if ('string' === typeof val) date = Date.parse(val);
			else {
				// Assume the val is a Date object
				date = val;
			}

			function pad(n, width) {
				n = n + '';
				return n.length >= width ? n : new Array(width - n.length + 1).join('0') + n;
			}
			// return "TO_DATE('" + date.getUTCFullYear() +
			// 	'-' + pad(date.getUTCMonth() + 1, 2) +
			// 	'-' + pad(date.getUTCDate(), 2) +
			// 	' ' + pad(date.getUTCHours(), 2) +
			// 	':' + pad(date.getUTCMinutes(), 2) +
			// 	':' + pad(date.getUTCSeconds(), 2) +
			// 	"', 'YYYY-MM-DD HH24:MI:SS')";
			return date;
		},

		isNullUuid(val) {
			return val === null || val === undefined || val === "00000000000000000000000000000000";
		},
		nullDate() {
			return new Date(Date.UTC(1599, 11, 31));
		},
		isNullDate(val) {
			return val === null || val === undefined || val && val.getUTCFullYear() === 1599 && val.getUTCMonth() === 11 && val.getUTCDate() === 31;
		},
		escape(name) {
			return '"' + name + '"';
		},
		param(i) {
			return ':' + (i + 1);
		},
		rowIdGet(v) {
			return "ROWIDTOCHAR(" + v + ")";
		},
		rowIdPut(v) {
			return "CHARTOROWID(" + v + ")";
		},
		beginTransaction(_, cnx) {
			cnx.executeOptions.autoCommit = false;
			cnx.commit(_);
		},
		commitTransaction(_, cnx) {
			cnx.commit(_);
			cnx.executeOptions.autoCommit = true;
		},
		rollbackTransaction(_, cnx) {
			cnx.rollback(_);
			cnx.executeOptions.autoCommit = true;
		},
		allocConnection(_) {
			var cnx = connections.pop();
			if (!cnx) {
				counters.alloc++;
				// temporary debugging to test code sanity
				if (counters.alloc > counters.warned) {
					counters.warned++;
					console.error('CONCURRENT CONNECTIONS', counters.alloc);
					if (counters.alloc > 100) throw new Error("Too many Oracle connections!!!");
				}
				trace && trace("connecting ...");
				cnx = oracle.getConnection(config, _);
				// driver returns values in local time so we set our session timezone to UTC to avoid offsets.
				cnx.execute("ALTER SESSION SET TIME_ZONE='00:00'", _);

				// prefetch row count should be set in execute
				//cnx.setPrefetchRowCount(config.setPrefetchRowCount || 50);
				//cnx.setPrefetchRowCount(1);
				//cnx.setNumberStringFormat("99999999999999999999.99999999999999999999");
				cnx.executeOptions = {
					autoCommit: true,
					outFormat: oracle.OBJECT
				};
			}
			counters.used++;
			return cnx;
		},
		releaseConnection(cnx, err) {
			counters.used--;
			if (err) {
				console.error(err);
				// don't reuse it
				counters.discarded++;
			} else {
				connections.push(cnx);
			}
		},
		withConnection(_, body) {
			const cnx = this.allocConnection(_);

			try {
				return body(_, cnx);
			} finally {
				this.releaseConnection(cnx);
			}
		},
		execute(_, cnx, sql, args, opts) {
			if (typeof cnx === "string") {
				opts = args;
				args = sql;
				sql = cnx;
				cnx = null;
			}
			if (cnx == null) {
				return this.withConnection(_, (_, cnx) => this.execute(_, cnx, sql, args, opts));
			}
			tracerJs.debug && tracerJs.debug("execute " + sql + ",args=\n" + (args || []).map((arg, i) => ":" + (i + 1) + "=" + arg).join('\n'));
			const oraOpts = {
				outFormat: cnx.executeOptions.outFormat,
				autoCommit: cnx.executeOptions.autoCommit
			};

			opts = opts || {};
			if (opts.outputVars && opts.outputVars.length > 0) {
				// convert args array to an object
				args = (args || []).reduce((r, v, i) => {
					r[i + 1] = v;
					return r;
				}, {});
				// add output vars to the args object.
				opts.outputVars.forEach(v => {
					const type = oracle[v.type];

					if (typeof type !== "number") throw new Error("invalid type: " + v.type);
					args[v.name] = {
						dir: oracle.BIND_OUT,
						type: type
					};
				});
			}
			if (opts.decimalColumns) {
				oraOpts.decimalColumns = opts.decimalColumns;
				setFetchInfo(oraOpts);
			}

			// console.error("ORACLE EXECUTE: ", sql, args);
			const result = cnx.execute(sql, args || [], oraOpts, _);

			if (result.rows) return result.rows;
			else {
				return {
					updateCount: result.rowsAffected,
					outputVars: opts.outputVars && opts.outputVars.map(v => {
						const os = result.outBinds[v.name][0];

						return ez.devices.generic.writer((_, data) => data === undefined ? os.end() : os.write(data, _));
					})
				};
			}
		},
		reader: common.reader((_, cnx, sql, args, opts) => {
			//tracerJs.debug && tracerJs.debug("ORACLE READER " + sql + ",args="+ (args ? args.join(',') : ""));
			setFetchInfo(opts);
			// console.error("ORACLE READER: ", sql, args);
			return ezoracle.reader(cnx, sql, args || [], opts);
		}),
		writer: common.writer((_, cnx, sql, opts) => {
			tracerJs.debug && tracerJs.debug("ORACLE WRITER " + sql);
			return ezoracle.writer(cnx, sql);
		}),
		dropIndexSql(indexName, tableName) {
			return 'drop index "' + indexName + '"';
		},
		isIndexNotFound(ex) {
			return (/ORA-01418/.test(ex.message));
		},
		isTableNotFound(ex) {
			return (/ORA-00942/.test(ex.message));
		},
		isUniqueViolated(ex) {
			return (/ORA-00001/.test(ex.message));
		},
		isLocked(ex) {
			return (/ORA-00060/.test(ex.message));
		},
		isNoRecord(ex) {
			return (/ORA-01403/.test(ex.message));
		},
		blobType() {
			return "BLOB";
		},
		clobType() {
			return "CLOB";
		},
		tinyIntType() {
			return "NUMBER(3)";
		},
		shortIntType() {
			return "NUMBER(5)";
		},
		intType() {
			return "NUMBER(10)";
		},
		stringType(len) {
			return "VARCHAR2(" + len + ")";
		},
		dateType() {
			return "DATE";
		},
		datetimeType() {
			return "DATE";
		},
		uuidType() {
			return "VARCHAR2(32)";
		},
		decimalType() {
			// for now handle as char to keep full precision
			return "VARCHAR2(32)";
		},
		doubleType() {
			// for now handle as char to keep full precision
			return "BINARY_DOUBLE";
		},
		backupDatabase(_, dbName, filename) {
			throw new Error("Not implemented !!!");
		},
		restoreDatabase(_, dbName, filename) {
			throw new Error("Not implemented !!!");
		},
		tableExists(_, tableName, schemaName) {
			return !!this.reader(_, "SELECT * FROM USER_TABLES WHERE TABLE_NAME = :1", [tableName]).toArray(_)[0];
		},

		describeQuery(_, qry, folder) {
			const _tmpname = "TMPVIEW" + crypto.randomBytes(4).readUInt32LE(0);
			/* first create view */

			this.execute(_, "Create view " + _tmpname + " as " + qry);

			try {
				var sql = "SELECT COLUMN_NAME, DATA_TYPE, DATA_LENGTH, DATA_PRECISION, DATA_SCALE, CHAR_LENGTH, CHAR_USED ";
				sql += "FROM ALL_TAB_COLUMNS ";
				sql += "WHERE OWNER='" + folder + "' AND TABLE_NAME = '" + _tmpname + "'";
				sql += "ORDER BY TABLE_NAME, COLUMN_ID";
				return this.reader(_, sql).toArray(_).map(row => {
					const col = {};

					col.name = row.COLUMN_NAME;
					switch (row.DATA_TYPE) {
						case 'BLOB':
							col.type = 522;
							col.typtyp = 9;
							break;
						case 'CLOB':
							col.type = 523;
							col.typtyp = 10;
							break;
						case 'DATE':
							col.type = 3;
							col.typtyp = 8;
							break;
						case 'TIMESTAMP(3)':
							col.type = 526;
							col.typtyp = 12;
							break;
						case 'VARCHAR':
							col.type = 10 + parseInt(row.DATA_LENGTH);
							col.typtyp = 7;
							break;
						case 'VARCHAR2':
							col.type = "varchar";
							/*if ('B' !== row.CHAR_USED) {
       		col.type = 10 + Math.floor((parseInt(row.DATA_LENGTH) / 3));
       	} else {*/
							col.type = 10 + parseInt(row.CHAR_LENGTH);
							//}
							col.typtyp = 7;
							break;
						case 'RAW':
							if (row.DATA_LENGTH == 16) {
								col.type = 525;
								col.typtyp = 11;
							} else {
								throw new Error('Unsupported column type ' + row.DATA_TYPE + ' for column ' + row.COLUMN_NAME);
							}
							break;
						case 'NUMBER':
							var precision = parseInt(row.DATA_PRECISION);
							var scale = parseInt(row.DATA_SCALE);

							if (10 === precision && !scale) {
								col.typtyp = 3;
								col.type = 4;
							} else if (3 === precision && !scale) {
								col.type = 1;
								col.typtyp = 1;
							} else if (5 === precision && !scale) {
								col.typtyp = 2;
								col.type = 2;
							} else {
								col.typtyp = 4;
								col.type = 7;
							}
							break;
						default:
							throw new Error('Unsupported column type ' + row.DATA_TYPE + ' for column ' + row.COLUMN_NAME);
					}

					return col;
				});
			} catch (e) {
				console.error(e.message + "\n", e.stack);
			} finally {
				/* delete view*/
				this.execute(_, "Drop view " + _tmpname);
			}
		},

		/// Returns the list of all the tables defined in the database / schema
		readTables(_, schemaName) {
			const sql = "select TABLE_NAME from USER_TABLES order by TABLE_NAME";

			return this.reader(_, sql).map((_, item) => {
				return {
					schemaName: schemaName,
					tableName: item.TABLE_NAME
				};
			}).toArray(_);
		},

		createPermissions(_, tableDef, config) {
			return common.createPermissions(_, this, tableDef, config);
		},

		/// Returns the definition of a table from its name.
		getTableDef(_, schemaName, tablename) {
			const tableDef = {
				schemaName: schemaName,
				tableName: tablename
			};

			this.readTableSchema(_, tableDef);
			return tableDef;
		},

		/// Enhance a table definition with its columns, indices, ...
		/// 'tableDef' is an object that have been created by readTables() / getTableDef()
		readTableSchema(_, tableDef, tracker) {
			// ----------------------------------------
			// Read the columns of the table
			// ----------------------------------------
			var sqlQuery = "SELECT c.COLUMN_NAME, c.DATA_TYPE, c.DATA_LENGTH, c.CHAR_USED, c.CHAR_LENGTH, c.DATA_PRECISION, c.DATA_SCALE, c.NULLABLE," + " t.TYPTYP_0 TYPE_TYPE, t.OPTION_0 TYPE_OPTION, t.LNGTYP_0 TYPE_LENGTH," + " z.LONG_0 ZONE_LENGTH, z.OPTION_0 ZONE_OPTION" + " FROM user_tab_cols c" + " LEFT JOIN " + this.getFullTableName(tableDef.schemaName, "ATABZON") + " z ON z.CODFIC_0 = c.TABLE_NAME AND c.COLUMN_NAME LIKE CONCAT(z.CODZONE_0, '\\_%') ESCAPE '\\'" + " LEFT JOIN " + this.getFullTableName(tableDef.schemaName, "ATYPE") + " t ON z.CODTYP_0 = t.CODTYP_0" + " WHERE table_name = :1" + " ORDER BY COLUMN_NAME";

			//console.log(sqlQuery);process.exit(0);
			tableDef.columns = this.reader(_, sqlQuery, [tableDef.tableName]).toArray(_).map(row => {
				const column = {
					name: row.COLUMN_NAME,
					isNullable: row.NULLABLE !== 'N'
				};

				switch (row.DATA_TYPE) {
					case 'DATE':
						column.type = "date";
						break;
					case 'TIMESTAMP(3)':
						column.type = "datetime";
						break;
					case 'NUMBER':
						var precision = parseInt(row.DATA_PRECISION);
						var scale = parseInt(row.DATA_SCALE);
						if (10 === precision && !scale) {
							column.type = "int";
						} else if (3 === precision && !scale) {
							column.type = "tinyint";
						} else if (5 === precision && !scale) {
							column.type = "smallint";
						} else {
							column.type = "decimal";
							if (row.TYPE_TYPE != 4) {
								var msg = "Inconsistent metadata for column " + tableDef.tableName + "." + column.name + " : types mismatch (expected 4 but got " + row.TYPE_TYPE + ")";
								if (tracker) {
									(tracker.$diagnoses = tracker.$diagnoses || []).push({
										$severity: "warning",
										$message: msg
									});
								}
								console.log("WARNING : " + msg);
							}

							// precision/scale must not be extracted from user_tab_cols; instead we have to extract the format from ATYPE table
							var precision = row.ZONE_LENGTH;
							if (precision == 0) {
								// No format is specified in ATABZON, it's inherited from the type of the column (ATYPE)
								precision = row.TYPE_LENGTH;
							}

							column.decimalPrecision = Math.floor(precision);
							column.decimalScale = Math.round((precision - column.decimalPrecision) * 10);

							// Determine whether the column uses the floating point notation
							// i.e. ATABZON.OPTION_0 ou ATYPE.OPTION_0 contains the character 'F'
							column.useFloatingPointFormat = row.ZONE_OPTION && row.ZONE_OPTION.indexOf('F') != -1 || row.TYPE_OPTION && row.TYPE_OPTION.indexOf('F') != -1;

							// Note : in X3, 999.99 is described as 3.2 but for us, the precision includes the scale so 3.2 -> 5.2
							column.decimalPrecision += column.decimalScale;
						}
						break;
					case 'BLOB':
						column.type = "blob";
						break;
					case 'CLOB':
						column.type = "clob";
						break;
					case 'VARCHAR':
						column.type = "varchar";
						column.maxLength = parseInt(row.DATA_LENGTH);
						break;
					case 'VARCHAR2':
						column.type = "nvarchar";
						if ('B' === row.CHAR_USED) {
							// The size of the string is defined in 'BYTES', we have to convert it to 'CHAR'
							column.maxLength = parseInt(row.DATA_LENGTH) / 3;
						} else {
							column.maxLength = parseInt(row.CHAR_LENGTH);
						}
						break;
					case 'RAW':
						if (row.DATA_LENGTH == 16) column.type = "uuid";
						else {
							column.type = "binary";
							column.maxLength = row.DATA_LENGTH;
						}
						break;
					default:
						throw new Error('unknown column type ' + row.DATA_TYPE + ' for column ' + tableDef.tableName + '.' + column.name);
				}
				return column;
			});

			// ----------------------------------------
			// Read some properties of the table
			// ----------------------------------------
			sqlQuery = "SELECT SECURE_0 FROM " + this.getFullTableName(tableDef.schemaName, "ATABLE") + " WHERE CODFIC_0 = " + this.param(0) + " AND rownum=1";
			const row = this.reader(_, sqlQuery, [tableDef.tableName]).toArray(_)[0];

			tableDef.isOpenAccess = !row || row["SECURE_0"] == 2;

			// ----------------------------------------
			// Read the indices of the table
			// ----------------------------------------
			sqlQuery = "SELECT i.UNIQUENESS index_is_unique, ic.INDEX_NAME index_name, ic.COLUMN_NAME column_name, ic.DESCEND column_descending " + "FROM USER_IND_COLUMNS ic " + "LEFT JOIN USER_INDEXES i ON ic.INDEX_NAME = i.INDEX_NAME " + "WHERE ic.TABLE_NAME = :1 " + "ORDER BY ic.INDEX_NAME, ic.COLUMN_POSITION";

			var currentIndex;
			var currentIndexName;
			tableDef.indexes = [];
			this.reader(_, sqlQuery, [tableDef.tableName]).toArray(_).forEach(row => {
				if (row.INDEX_NAME != currentIndexName) {
					currentIndexName = row.INDEX_NAME;
					// This is either the first index or a new index (rows are sorted by index)
					currentIndex = {
						name: row.INDEX_NAME,
						isPk: false /* row.index_is_pk*/
						, isUnique: row.INDEX_IS_UNIQUE === "UNIQUE",
						columns: []
					};
					tableDef.indexes.push(currentIndex);
				}
				const column = {
					name: row.COLUMN_NAME,
					ascending: row.COLUMN_DESCENDING === "ASC"
				};

				currentIndex.columns.push(column);
			});

			// ----------------------------------------
			// Read the sequence of the table
			// ----------------------------------------
			sqlQuery = "SELECT LAST_NUMBER FROM USER_SEQUENCES WHERE SEQUENCE_NAME = :1  AND rownum < 2";
			this.reader(_, sqlQuery, ["SEQ_" + tableDef.tableName]).toArray(_).forEach(row => {
				tableDef.sequence = parseInt(row.LAST_NUMBER);
			});
		},

		createTableFromTableDefinition(_, tableDef, options) {
			options = options || {};
			options.showCommands = true;
			options.skipCommands = false;
			if (options.onlyIndexes) {
				options.skipDrop = true;
				options.skipCreate = true;
				options.skipSequences = true;
				options.skipIndexes = false;
			}
			// -------------------------------------
			// Drop the existing table
			// -------------------------------------
			if (!options.skipDrop) {
				// Drop the existing table and its sequence
				this.dropTable(_, tableDef);
				this.dropSequence(_, tableDef);
			}
			// -------------------------------------
			// Create the table and its columns
			// -------------------------------------
			if (!options.skipCreate) {
				// Create the table (and the columns)
				var sql = "CREATE TABLE " + this.getFullTableDefName(tableDef) + " (";
				tableDef.columns.forEach((colDef, colIdx) => {
					if (colIdx > 0) sql += ", ";
					sql += colDef.name + " ";
					switch (colDef.type) {
						case "tinyint":
							sql += "NUMBER(3)";
							break;
						case "smallint":
							sql += "NUMBER(5)";
							break;
						case "int":
							sql += "NUMBER(10)";
							break;
						case "date":
							sql += "DATE";
							break;
						case "datetime":
							sql += "TIMESTAMP(3)";
							break;
						case "decimal":
							// STDEN : for now, always create decimal as NUMERIC, without any precision/scale
							// sql += "NUMBER(" + colDef.decimalPrecision + ", " + colDef.decimalScale + ")";
							sql += "NUMBER";
							break;
						case "blob":
							sql += "BLOB";
							break;
						case "varchar":
							sql += "VARCHAR(" + colDef.maxLength + " CHAR)";
							break;
						case "nvarchar":
							sql += "VARCHAR2(" + colDef.maxLength + " CHAR)";
							break;
						case "uuid":
							sql += "RAW(16)";
							break;
						case "binary":
							sql += "RAW(" + colDef.maxLength + ")";
							break;
						default:
							throw new Error('unknown column type ' + colDef.colType + ' for column ' + this.getFullTableDefName(tableDef) + '.' + colDef.name);
					}
					if (!colDef.isNullable) sql += " NOT NULL";
					if (colDef.default) sql += " DEFAULT " + colDef.default.value;
				});
				sql += ")";
				options.showCommands && console.log(sql);
				!options.skipCommands && this.execute(_, sql);
			}

			// -------------------------------------
			// Create the indexes
			// -------------------------------------
			if (!options.skipIndexes) {
				console.log("Create indexes");
				tableDef.indexes.forEach_(_, (_, indexDef) => {
					var sql = "CREATE ";
					if (indexDef.isUnique) sql += "UNIQUE ";
					sql += "INDEX " + indexDef.name + " ON " + this.getFullTableDefName(tableDef) + " (";
					indexDef.columns.forEach((column, colIdx) => {
						if (colIdx > 0) sql += ", ";
						sql += column.name;
						if (!column.ascending) sql += " DESC";
					});
					sql += ")";
					options.showCommands && console.log(sql);
					!options.skipCommands && this.execute(_, sql);
				});
			}
			// -------------------------------------
			// Create (when needed) the sequence
			// -------------------------------------
			if (!options.skipSequences && tableDef.sequence) {
				console.log("Create sequence");

				var sql = "CREATE SEQUENCE " + this.getFullTableName(tableDef.schemaName, "SEQ_" + tableDef.tableName);
				sql += " START WITH " + tableDef.sequence;
				options.showCommands && console.log(sql);
				!options.skipCommands && this.execute(_, sql);
			}
		},

		/// Returns a reader that could be used to read all the records of the table
		/// 'tableDef' is an object that have been created by getTableDef() or readTables() and updated by readTableSchema()
		createTableReader(_, tableDef, filters) {
			return common.createTableReader(_, this, tableDef, filters);
		},

		createTableWriter(_, tableDef) {
			const columnNames = [];
			const paramNames = [];

			tableDef.columns.forEach((column, index) => {
				if (column.name == "ROWID") return;
				columnNames.push(column.name);
				const paramName = this.param(index);

				paramNames.push(paramName);
			});

			const sql = "INSERT INTO " + this.getFullTableDefName(tableDef) + " (" + columnNames.join(',') + ") VALUES (" + paramNames.join(',') + ")";

			return this.withConnection(_, (_, cnx) => this.writer(_, cnx, sql));
		},

		getFullTableDefName(tableDef) {
			return this.getFullTableName(tableDef.schemaName, tableDef.tableName);
		},

		getFullTableName(schemaName, tableName) {
			if (schemaName) return '"' + schemaName + '"."' + tableName + '"';
			else return '"' + tableName + '"';
		},

		clearTable(_, tableDef) {
			this.execute(_, "DELETE FROM " + tableDef.tableName);
		},

		/// Tries to drop a table and returns whether the drop succeeded
		dropTable(_, tableDef) {
			return common.dropTable(_, this, tableDef);
		},

		/// Tries to drop the sequence bound to a table and returns whether the drop succeeded
		dropSequence(_, tableDef) {
			return common.dropSequence(_, this, tableDef);
		},
		evalueRowCount(_, tableName) {
			const rs = this.reader(_, "select num_rows from user_tables where table_name =" + this.param(0), [tableName]).toArray(_);
			//console.log("rs:"+JSON.stringify(rs));

			return parseFloat(rs[0].NUM_ROWS);
		},
		lobPlaceholder(type) {
			return "EMPTY_" + type + "()";
		},
		release(_) {
			let cnx;
			while (cnx = connections.pop()) {
				cnx.release(_);
				counters.used--;
			}
		}

	};
};