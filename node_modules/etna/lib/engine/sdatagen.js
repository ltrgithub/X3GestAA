"use strict";
var Parser = require("etna/lib/engine/parser").Parser;
var dates = require('etna/lib/engine/runtime/dates');
var tdate = require('etna/lib/engine/runtime/tdate');

exports.generate = function(tabcor, node) {
	//console.log("sdatagen:" + JSON.stringify(node));

	var VALUES = ["STRING"];

	var opValue = function(operator, op0, op1) {
		return function(filter) {
			if (op0 instanceof Date) {
				if (op0.toString() === tdate.make(0, 0, 0).toJsDate().toString()) var l = "@@";
				else
					var l = "@" + tdate.fromJsDate(op0).toString("yyyy-MM-dd") + "@";
			} else var l = op0;
			if (op1 instanceof Date) {
				if (op1.toString() === tdate.make(0, 0, 0).toJsDate().toString()) var r = "@@";
				else
					var r = "@" + tdate.fromJsDate(op1).toString("yyyy-MM-dd") + "@";
			} else var r = op1;

			filter = '(' + l + ' ' + operator + ' ' + r + ')';
			return filter;
		};

	};

	var addOpValue = function(op) {
		return function(node) {

			if (node.args[0].tag === 'FCALL' & node.args[0].name === 'FIND')
				return findValues(op, node.args[0], node.args[1]);

			var op0 = gen(node.args[0])();
			var op1 = gen(node.args[1])();
			return opValue(op, op0, op1);
		};
	};

	function findValues(operator, find, value) {
		return function(filter) {
			var l = gen(find.args[0])();
			var vals = Array.prototype.slice.call(find.args, 1);
			// not used var r = gen(value)();
			var values = '(' + vals.map(function(val) {
				return gen(val)();
			}).join(', ') + ')';
			switch (operator) {
				case "ne":
				case "gt":
					var op = "in";
					break;
				case "eq":
				case "ge":
				case "le":
				case "lt":
				default:
					var op = "not in";
					break;
			}
			filter = '(' + l + ' ' + op + ' ' + values + ')';
			return filter;
		};
	}

	var operators = {
		EQ: addOpValue("eq"),
		NE: addOpValue("ne"),
		GE: addOpValue("ge"),
		LE: addOpValue("le"),
		GT: addOpValue("gt"),
		LT: addOpValue("lt"),
		OR: addOpValue("or"),
		AND: addOpValue("and"),
		LEN: function(node) {
			var lhs = gen(node.args[0]);
			return function() {
				var l = lhs();
				return 'length(' + l + ')';
			};

		},
		MID$: function(node) {
			var lhs = gen(node.args[0]);
			var r1hs = gen(node.args[1]);
			var r2hs = gen(node.args[2]);
			return function() {
				var l = lhs();
				var r1 = r1hs();
				var r2 = r2hs();
				if (r1 === 1)
					return 'left(' + l + ', ' + r2 + ')';
				else
					return 'substring(' + l + ', ' + r1 + ', ' + r2 + ')';
			};

		},
		LEFT$: function(node) {
			var lhs = gen(node.args[0]);
			var rhs = gen(node.args[1]);
			return function() {
				var l = lhs();
				var r = rhs();
				return 'left(' + l + ', ' + r + ')';
			};

		},
		RIGHT$: function(node) {
			var lhs = gen(node.args[0]);
			var rhs = gen(node.args[1]);
			return function() {
				var l = lhs();
				var r = rhs();
				return 'right(' + l + ', ' + r + ')';
			};

		},
		SUB: function(node) {
			var lhs = gen(node.args[0]);
			var rhs = gen(node.args[1]);
			return function() {
				var l = lhs();
				var r = rhs();
				if (l instanceof Date) {
					var d = tdate.fromJsDate(l);
					d = d.x3Sub(r);
					return d.toJsDate();
				}
				return l - r;
			};

		},
		ADD: function(node) {
			var lhs = gen(node.args[0]);
			var rhs = gen(node.args[1]);
			return function() {
				var l = lhs();
				var r = rhs();
				if (l instanceof Date) {
					var d = tdate.fromJsDate(l);
					d = d.x3Add(r);
					return d.toJsDate();
				}
				return l + r;
			};

		},
		STRING: function(node) {
			return function() {
				return '"' + node.value + '"';
			};
		},
		INTEGER: function(node) {
			return function() {
				return node.value;
			};
		},
		DATE: function(node) {
			return function() {
				return tdate.make(node.year, node.month, node.day).toJsDate();
			};
		},
		DATE$: function(node) {
			return function() {
				return dates.functions.DATE$.fn().toJsDate();
			};
		},
		IDENT: function(node) {
			return function() {
				return node.value;
			};
		},
		CLAS: function(node) {
			return function() {
				var res = '[' + node.letter + ((node.abbrev === undefined) ? ']' : ':' + node.abbrev + ']') + node.field;
				if (tabcor && tabcor[res]) return tabcor[res];
				return res;
			};
		},
		PROP: function(node) {
			return function() {
				var lhs = gen(node.target)();
				var res = lhs + '.' + node.name;
				if (tabcor && tabcor[res]) return tabcor[res];
				return res;
			};
		},
	};

	function gen(node) {
		var fn = (node.tag === 'FCALL') ? operators[node.name] : (operators[node.op] || operators[node.tag]);
		if (fn) return fn(node);
	}
	return gen(node);
};

exports.x3ToSdata = function(tabcor, expression) {
	var parsed = new Parser("CONDITION=(" + expression + ")").parse();
	return exports.generate(tabcor, parsed.node.statements[0].rhs);
};