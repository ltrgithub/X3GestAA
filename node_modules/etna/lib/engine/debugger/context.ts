import { _ } from 'streamline-runtime';
import * as core from 'syracuse-core';
import * as sys from 'util';
import * as url from 'url';
import * as fs from 'fs';
import { Socket } from 'net';
import * as ez from 'ez-streams';
const jsxml = require("js-xml");
import { helpers } from 'syracuse-core';
import * as util from '../runtime/util';
import { Frame, Location } from '../runtime/types';
const sessionManager = require('syracuse-session/lib/sessionManager').sessionManager;
const config = require("config");
import * as breakpoint from './breakpoint';
import { evalue } from '../runtime/evaluate';

const tracer = core.getTracer("etna.debugger");
const log = {
	info(s: any) {
		// console.error("[INFO] DebugContext." + s);
	},
	debug(s: any) {
		// console.error("[DEBUG] DebugContext." + s);
	},
	error(s: any, e: Error) {
		console.error("[ERROR] DebugContext." + s + (e ? ": " + e.message + ((config.system || {}).exposeStacktrace ? "\n  at " + e.stack : "") : ""));
	}
};
// Status are:
// starting - State prior to execution of any code
// stopping - State after completion of code execution. This typically happens at the end of code execution, allowing the IDE to further interact with the debugger engine (for example, to collect performance data, or use other extended commands).
// stopped  - IDE is detached from process, no further interaction is possible.
// running  - code is currently executing. Note that this state would only be seen with async support turned on, otherwise the typical state during IDE/debugger interaction would be 'break'
// break    - code execution is paused, for whatever reason (see below), and the IDE/debugger can pass information back and forth.

type DebugRequest = any; // refine later
type DebugResponse = any; // refine later

export class DebugContext {
	// very weakly typed for now...
	readCommand: (_: _) => string;
	write: (_: _, data: any, opts?: any) => void;
	close: () => void;
	getDescription: () => string;
	features: { [name: string]: any; }
	breakpointsById: any;
	breakpointsByKey: any;
	stepMark: number;
	session: any;
	state: string;
	status: string;
	frame: Frame;
	request: DebugRequest;
	leave: boolean;

	constructor(socket: any) {

		this.readCommand = function (_: _) {
			var seg: number[] = [],
				c: Buffer,
				cmd: string;
			while (c = socket.read(_, 1)) {
				if (c[0] === 0) break;
				seg.push(c[0]);
			}

			cmd = new Buffer(seg).toString('utf8');
			tracer.debug && tracer.debug("readCommand cmd= " + cmd);
			return cmd;
		};

		this.write = function (_: _,  data: any, opts: any) {
			opts = opts || {};
			if (opts.json) {
				data = JSON.stringify(data);
			} else if (data instanceof DbgpResponse) {
				data = data.toXmlString(this.indent);
			} else if (typeof data === "object") {
				data = jsxml.stringify(data, this.indent);
			}
			tracer.debug && tracer.debug("write: " + data);
			socket.write(_, [Buffer.byteLength(data, 'utf8'), data, ""].join("\0"));
		};

		this.close = function () {
			socket.end();
			socket.destroy();
			socket = null;
		};

		this.getDescription = function () {
			return socket.localAddress + ":" + socket.localPort;
		};

		Object.defineProperty(this, 'isActive', {
			get() {
				return socket && !socket.closed;
			}
		});

		this.features = {
			"language_supports_threads": "0",
			"language_name": "x3-etna",
			"language_version": "9.0",
			"encoding": "UTF-8",
			"data_encoding": "base64",
			"protocol_version": "1",
			"supports_async": "0",
			// seems not to be called by Eclipse DLTK framework
			"breakpoint_types": "line conditional exception watch",
			"multiple_sessions": "0",
			// max number of array or object children to initially retrieve
			"max_children": 100,
			// max amount of variable data to initially retrieve
			"max_data": 8192,
			// maximum depth that the debugger engine may return when sending arrays, hashs or object structures to the IDE.
			"max_depth": 2
		};

		this.breakpointsById = {};
		this.breakpointsByKey = {};
		this.stepMark = 0;
	}
	listen(_: _) {
		try {
			var cmd: string;
			while (!this.session && (cmd = this.readCommand(_))) {
				this.interpret(_, cmd);
			}
		} catch (e) {
			this.abort("Debug listening aborted", e);
		}
	}
	hit(_: _,  frame: Frame, request: DebugRequest) {
		const sub = frame && frame.sub,
		      debug = sub && (sub.debug || (sub.debug = {})),
		      debugStepMark = ~ ~sub.debugStepMark,
		      mod = _getModuleName(debug);

		if (debug == null) return;

		tracer.debug && tracer.debug(new Array(~ ~frame.stackLevel + 1).join("+") + "hit: state=" + this.state + "/" + this.status + " - " + debug.instruction + " at " + mod + ":" + debug.location.line + ", stepMark=" + this.stepMark + ", debugMark=" + sub.debugStepMark + ", stackLevel=" + frame.stackLevel);
		if (this.stepMark > 0 && debugStepMark >= this.stepMark) {
			this.suspend();
		}
		this.frame = frame;
		this.request = request;
		// tracer.debug && tracer.debug("hit: state=" + this.state + ", request=" + sys.inspect(request));
		// tracer.debug && tracer.debug("hit: state=" + this.state);
		try {
			if (this.state === "init") {
				this.state = "attached";
				this.write(_, getInitMessage({
					baseurl: (request.session && request.session.host || request.headers["host"]) + request.url
				}));
			}
			if (this.status === "running" && this.breakOn(frame)) {
				tracer.debug && tracer.debug("hit breakOn");
				this.suspend();
			}
			if (this.status === "break") {
				var cmd: string;
				// tracer.debug && tracer.debug("hit: " + debug.instruction + " in " + mod + ":" + debug.location.line + ", status=" + this.status);
				this.leave = false;
				while (!this.leave && this.status === "break" && (cmd = this.readCommand(_))) {
					this.interpret(_, cmd);
				}
			}
		} catch (e) {
			this.abort("Debug session aborted", e);
		}
	}
	interpret(_: _,  commandLine: string) {
		var parts = commandLine.split(" "),
		    cmd = parts[0] && parts[0].toLowerCase().replace(/-/g, "_"),
		    command = _commandsMap[cmd],
		    options: any = {},
		    resp: DebugResponse;
		for (var i = 1, len = parts.length; i < len; i++) {
			if (parts[i][0] === "-") {
				options[parts[i].substring(1)] = parts[++i];
			}
		}
		resp = newResponse(cmd, options);
		tracer.debug && tracer.debug("interpret: '" + commandLine + "' parts=" + parts + " => command=" + typeof command + ", resp=" + JSON.stringify(resp));
		if (command) {
			try {
				command.call(this, _, resp, options);
			} catch (e) {
				resp.error = {
					$: {
						code: 500,
						apperr: 0
					},
					message: {
						$value: e.message + ((config.system || {}).exposeStacktrace ? e.stack : "")
					}
				};
			}
		} else {
			resp.error = {
				$: {
					code: 500,
					apperr: 0
				},
				message: {
					$value: "invalid command: " + commandLine
				}
			};
		}

		if (resp) this.write(_, resp, {
			json: options.j == 1
		});
	}
	setStatus(resp: DebugResponse, status: string, reason: string) {
		this.status = status || this.status;
		resp.$.status = this.status;
		resp.$.reason = reason || "ok";
	}
	abort(m: string, e: Error) {
		this.state = "detached";
		this.status = "stopped";
		log.error(m, e);
		// log.error(m, e);
	}
	breakOn(frame: Frame) {
		const debug = frame.sub.debug,
		      superv = frame.context.superv,
		      mod = [superv.folderName, _getModule(debug)].join("/");

		if (!debug) return;
		// tracer.debug && tracer.debug("breakOn: " + debug.instruction + " in " + mod + ":" + debug.location.line + ", status=" + this.status + ", bp=" + sys.inspect(this.breakpointsByKey));
		// line breakpoints
		if (mod) {
			var bpkey = mod + ":" + debug.location.line;
			var bp = this.getBreakpointByKey(bpkey);
			if (bp && bp.isEnabled()) return true;
		}
	}
	_getFrame(depth: number) {
		var frame = this.frame;
		depth = ~ ~depth;
		while (depth-- && frame.prev) {
			frame = frame.prev;
		}
		return frame;
	}
	addBreakpoint(options: any) {
		const bp = breakpoint.createFromDbgpOptions(options),
		      bp2 = this.getBreakpointByKey(bp.$key);

		if (bp2) {
			throw new Error("Duplicate breakpoint: " + bp.$key);
		}
		this.breakpointsById[bp.$id] = bp;
		this.breakpointsByKey[bp.$key] = bp;
		return bp;
	}
	getBreakpointById(id: number) {
		return this.breakpointsById[id];
	}

	getBreakpointByKey(key: string) {
		return this.breakpointsByKey[key];
	}

	suspend(argument?: any) {
		this.status = "break";
	}

	markFrame(prev: Frame) {
		var stepMark = ++this.stepMark,
		    sub = this.frame.sub;
		if (prev) sub = _previousSub(sub);
		while (sub) {
			// console.error("markFrame: " + stepMark + " at " + (sub.debug && sub.debug.instruction) + ", sub=" + sub.name);
			sub.debugStepMark = stepMark;
			sub = _previousSub(sub);
		}
	}
}

var tmp: (_: _, resp: DebugResponse, options?: any) => any;

const _commandsMap: { [name: string]: (_: _, resp: DebugResponse, options?: any) => any; } = {
	list(_,  resp, options) {
		const sessions = sessionManager.getTenantSessions();
		// tracer.debug && tracer.debug("list: sessions\n" + Object.keys(sessions).join("\n"));

		resp.session = Object.keys(sessions).map(s => {
			return {
				$: {
					id: s
				}
			};
		});
	},
	options(_,  resp, options) {
		const beautify = /s(\d*)/.exec(options.b);

		if (beautify) this.indent = new Array(~ ~beautify[1] + 1).join(" ");
		else this.indent = options.b === "t" ? "\t" : null;
	},
	attach(_,  resp, options) {
		const id = options.s,
		      session = id && sessionManager.sessionById(id);

		tracer.debug && tracer.debug("attach: id=" + id + ", session=" + sys.inspect(session, {
			depth: 1
		}));
		if (session) {
			this.suspend();
			this.state = "init";
			session.debugContext = this;
			this.session = session;
		}
		// tracer.debug && tracer.debug("attach: id=" + id + ", session=" + typeof(session));
		resp.$.session = id || "";
		this.setStatus(resp);
	},

	// ====================================================
	// DGBP protocol standard commands
	// see http://xdebug.org/docs-dbgp.php
	// ====================================================

	// status
	status(_,  resp, options) {
		this.setStatus(resp);
		// resp.$value = "message....";
	},

	// feature_get
	// -n	feature_name
	feature_get(_,  resp, options) {
		const name = options.n || "",
		      value = this.features[name];

		resp.$.feature_name = name;
		resp.$.supported = ~ ~(value != null);
		resp.$value = value;
	},

	// feature_set
	// -n	feature_name
	// -v	value to be set
	feature_set(_,  resp, options) {
		const name = options.n;
		// max_depth cannot be set to a different value because of an issue in Eclipse DLTK framework

		if (name && name != "max_depth") this.features[name] = options.v;
		resp.$.feature = name;
		resp.$.success = ~ ~(this.features[name] != null);
	},

	// run
	run(_,  resp, options) {
		// in sync mode status is always "break"
		this.setStatus(resp, "break");
		this.status = "running";
	},

	// step_into
	step_into(_,  resp, options) {
		this.leave = true;
		this.setStatus(resp);
	},

	// step_over
	step_over(_,  resp, options) {
		// this.leave = true;
		this.markFrame();
		this.setStatus(resp, "break");
		this.status = "running";
	},

	// step_out
	step_out(_,  resp, options) {
		// this.leave = true;
		this.markFrame(true);
		this.setStatus(resp, "break");
		this.status = "running";
	},

	// stop
	stop: tmp = function (_,  resp, options) {
		this.leave = true;
		this.session.debugContext = null;
		// TODO
		this.status = "stopped";
		this.setStatus(resp);
	},

	// detach
	detach: tmp,

	// BREAKPOINTS
	// Type			Req'd Attrs				Description
	// line			filename, lineno		break on the given lineno in the given file
	// call			function				break on entry into new stack for function name
	// return		function				break on exit from stack for function name
	// exception	exception				break on exception of the given name
	// conditional	expression, filename	break when the given expression is true at the given filename and line number or just in given filename
	// watch		expression				break on write of the variable or address defined by the expression argument

	// breakpoint_set
	// -t TYPE			breakpoint type, see above for valid values [required]
	// -s STATE			breakpoint state [optional, defaults to "enabled"]
	// -f FILENAME		the filename to which the breakpoint belongs [optional]
	// -n LINENO		the line number (lineno) of the breakpoint [optional]
	// -m FUNCTION		function name [required for call or return breakpoint types]
	// -x EXCEPTION		exception name [required for exception breakpoint types]
	// -h HIT_VALUE		hit value (hit_value) used with the hit condition to determine if should break; a value of zero indicates hit count processing is disabled for this breakpoint [optional, defaults to zero (i.e. disabled)]
	// -o HIT_CONDITION	hit condition string (hit_condition); see hit_condition documentation above; BTW 'o' stands for 'operator' [optional, defaults to '>=']
	// -r 0|1			Boolean value indicating if this breakpoint is temporary. [optional, defaults to false]
	// -- EXPRESSION	code expression, in the language of the debugger engine. The breakpoint should activate when the evaluated code evaluates to true. [required for conditional breakpoint types]
	breakpoint_set(_,  resp, options) {
		const bp = this.addBreakpoint(options);

		resp.$.state = bp.$state;
		resp.$.id = bp.$id;
	},

	// breakpoint_get
	// -d BREAKPOINT_ID	the unique session breakpoint id returned by breakpoint_set.
	// returns:
	// <response command="breakpoint_get"
	//           transaction_id="TRANSACTION_ID">
	//     <breakpoint id="BREAKPOINT_ID"
	//                 type="TYPE"
	//                 state="STATE"
	//                 filename="FILENAME"
	//                 lineno="LINENO"
	//                 function="FUNCTION"
	//                 exception="EXCEPTION"
	//                 expression="EXPRESSION"
	//                 hit_value="HIT_VALUE"
	//                 hit_condition="HIT_CONDITION"
	//                 hit_count="HIT_COUNT">
	//         <expression>EXPRESSION</expression>
	//     </breakpoint>
	// </response>	
	breakpoint_get(_,  resp, options) {
		const bp = this.getBreakpointById(options.d);

		if (!bp) return;
		resp.breakpoint = bp.getDbgpInfo();
	},

	// breakpoint_update
	// -d	BREAKPOINT_ID	the unique session breakpoint id returned by breakpoint_set.
	// -s	STATE
	// -n	LINENO
	// -h	HIT_VALUE
	// -o	HIT_CONDITION	
	breakpoint_update(_,  resp, options) {
		const bp = this.getBreakpointById(options.d);

		if (bp) {
			bp.updateFromDbgpOptions(options);
		}
	},

	// breakpoint_remove
	// -d BREAKPOINT_ID	the unique session breakpoint id returned by breakpoint_set.
	breakpoint_remove(_,  resp, options) {
		const bp = this.getBreakpointById(options.d);

		if (bp) {
			delete this.breakpointsById[bp.$id];
			delete this.breakpointsByKey[bp.$key];
		}
	},

	// breakpoint_list
	breakpoint_list(_,  resp, options) {
		const bps = this.breakpointsById,
		      list: any[] = resp.breakpoint = [];

		Object.keys(bps).forEach(k => {
			list.push(bps[k].getDbgpInfo());
		});
	},

	// stack_depth
	// Returns the maximum stack depth that can be returned by the debugger
	stack_depth(_,  resp, options) {
		// TODO
		resp.$.depth = 10;
	},

	// stack_get
	// -d	stack depth (optional)
	stack_get(_,  resp, options) {
		resp.stack = [];
		var request = this.request,
		    host = request.session && request.session.host || request.headers["host"],
		    frame = this.frame,
		    sub = frame && frame.sub,
		    superv = frame.context.superv,
		    dataset = request.session.sessionInfo.dataset(_);
		tracer.debug && tracer.debug("stack_get: dataset=" + dataset);
		if (sub) {
			var loc: Location,
			    stackinfo: any,
			    debug: any,
			    level = 0;
			while (sub) {
				debug = sub.debug || (sub.debug = {});
				loc = debug && debug.location || {};
				stackinfo = {
					level: level++,
					type: debug.module ? "file" : "builtin",
					// x3://AWS-X3-DEVSUP.sagefr.adinternal.com:17000/SUPERV/GOBJSUB.src
					// filename: ["x3etna:/", host, superv.folderName,mod].join("/"),
					// filename: [host, request.session.sessionInfo.dataset(_), mod].join("/"),
					filename: debug.module ? [host, "$etna", superv.folderName, _getModule(debug)].join("/") : "<builtin>",
					lineno: loc.line || 0,
					// todo: add function name
					where: _getModuleName(debug) };
				// + (debug.instruction ? || ""),
				// cmdbegin: "line_number:offset",
				// cmdend: "line_number:offset"
				resp.stack.push({
					$: stackinfo
				});
				sub = _previousSub(sub);
			}
		}
	},

	// context_names
	// -d	stack depth (optional)
	context_names(_,  resp, options) {
		resp.context = [{
			name: "Local",
			id: 0
		}
		// , {
		// 	name: "Global",
		// 	id: 1
		// }, {
		// 	name: "Class",
		// 	id: 2
		// }
		];
	},

	// context_get
	// -d	stack depth (optional)
	// -c	context id (optional, retrieved by context-names)
	context_get(_,  resp, options) {
		const ctxid = ~ ~options.c,
		      frame = this._getFrame(options.d),
		      values = frame.values;

		resp.$.context = ctxid;
		// tracer.debug && tracer.debug("context_get: frame=" + sys.inspect(this.frame));
		// tracer.debug && tracer.debug("context_get: values=" + sys.inspect(values));
		switch (ctxid) {
			// Local
			case 0:
				resp.property = _getProperty(_, null, "", values, {
					sub: frame.sub,
					features: this.features
				});
				break;

			// Global: NIY
			case 1:
				throw new Error("NIY");
			// Class: NIY
			case 2:
				throw new Error("NIY");
		}
	},

	// property_get
	// -d	stack depth (optional, debugger engine should assume zero if not provided)
	// -c	context id (optional, retrieved by context-names, debugger engine should assume zero if not provided)
	// -n	property long name (required)
	// -m	max data size to retrieve (optional, defaults to the length as negotiated through feature_set with max_data). 0 means unlimited data.
	// -p	data page (property_get, property_value: optional for arrays, hashes, objects, etc.; property_set: not required; debugger engine should assume zero if not provided)
	// -k	property key as retrieved in a property element, optional, used for property_get of children and property_value, required if it was provided by the debugger engine.
	// -a	property address as retrieved in a property element, optional, used for property_set/value
	property_get(_,  resp, options) {
		const ctxid = ~ ~options.c,
		      longName = options.n,
		      maxsize = ~ ~(options.m || this.features.max_data),
		      page = ~ ~options.p,

		// Address and key are not supported
		// propKey = options.k,
		// propAddr = options.a,
		frame = this._getFrame(options.d),
		      values = frame.values;

		if (!longName) throw new Error("Missing options -n");

		const value = evalue(_, longName);

		tracer.debug && tracer.debug("property_get name='" + longName + "', value=" + sys.inspect(value));
		const parts = longName.split(".");
		const name = parts.pop();
		const parents = [{
			$: {
				fullname: parts.join(".")
			}
		}];

		resp.property = _getProperty(_, parents, name, value, {
			sub: frame.sub,
			features: this.features
		});
	},

	// property_set
	// -d	stack depth (optional, debugger engine should assume zero if not provided)
	// -c	context id (optional, retrieved by context-names, debugger engine should assume zero if not provided)
	// -n	property long name (required)
	// -t	data type (optional)
	// -p	data page (property_get, property_value: optional for arrays, hashes, objects, etc.; property_set: not required; debugger engine should assume zero if not provided)
	// -k	property key as retrieved in a property element, optional, used for property_get of children and property_value, required if it was provided by the debugger engine.
	// -a	property address as retrieved in a property element, optional, used for property_set/value
	property_set(_,  resp, options) {
		const ctxid = ~ ~options.c,
		      longName = options.n,
		      page = ~ ~options.p,

		// Address and key are not supported
		// propKey = options.k,
		// propAddr = options.a,
		frame = this._getFrame(options.d),
		      values = frame.values;

		const parts = longName.split(".");

		throw new Error("NIY");
	},

	// source
	// -b	begin line (optional)
	// -e	end line (optional)
	// -f	file URI
	// In the legacy version uri is in the form "x3://AWS-X3-DEVSUP.sagefr.adinternal.com:17000/SUPERV/GOBJSUB.src"
	source(_,  resp, options) {
		tracer.debug && tracer.debug("source: options=" + sys.inspect(options));
		const uri = url.parse(options.f),
		      segments = uri.pathname.split("/"),
		      file = segments[segments.length - 1],
		      ext = file && file.substring(file.lastIndexOf('.') + 1),
		      frame = this.frame,
		      superv = frame.context.superv,
		      fullpath = [superv.solutionPath.replace(/\\/g, '/'), superv.folderName, segments[1] || _folderMap[ext], file].join("/"),
		      source = getSource(fullpath, options.b, options.e);

		tracer.debug && tracer.debug("source: fullpath=" + fullpath + ", uri=" + sys.inspect(uri));
		resp.$.success = ~ ~(source != null);
		resp.$value = source;
	},

	// stdout
	// -c	[0|1|2] 0 - disable, 1 - copy data, 2 - redirection
	stdout(_,  resp, options) {
		resp.$.success = 1;
	},

	// stderr
	// -c	[0|1|2] 0 - disable, 1 - copy data, 2 - redirection
	stderr(_,  resp, options) {
		resp.$.success = 1;
	},

	// ====================================================
	// DGBP protocol Extended Commands
	// ====================================================

	// stdin
	stdin(_,  resp, options) {
		resp.$.success = 1;
	},

	// break
	break(_,  resp, options) {
		throw new Error("NIY");
	},

	// eval
	eval(_,  resp, options) {
		var expr = options["-"],
		    frame = this.frame;
		expr = new Buffer(expr, 'base64').toString("utf8");
		const value = evalue(_, expr);
		const parents: any[] = [];

		tracer.debug && tracer.debug("eval expr='" + expr + "', value=" + sys.inspect(value));
		resp.property = _getProperty(_, parents, expr, value, {
			sub: frame.sub,
			features: this.features
		});
	},

	// interact
	interact(_,  resp, options) {
		throw new Error("NIY");
	}
};

const _folderMap: { [name: string]: string; } = {
	"src": "TRT",
	"adx": "TRT",
	"stc": "STC"
};

function _previousSub(sub: any) {
	return sub && sub.prevSub || sub.prev && sub.prev.sub;
}

function _getModule(debug: any) {
	return debug && typeof debug.module === "string" ? debug.module : "";
}

function _getModuleName(debug: any) {
	const mod = _getModule(debug);

	return mod.substring(0, mod.lastIndexOf("."));
}

function _getProperty(_: _,  parents: any, name: any, value: any, context: any) {
	parents = parents || [];
	var parent = parents[0],
	    descendents: any[],
	    depth = parents.length,
	    sub = context.sub,
	    features = context.features;

	if (depth > features.max_depth) return;

	const vtype = value === null ? "null" : typeof value;
	const type = dbgpType(value) || vtype,
	      prop: any = {
		$: {
			name: name,
			fullname: (parent && parent.$.fullname ? parent.$.fullname + "." : "") + (typeof name === "string" ? name : "(" + name + ")"),
			type: type,
			// classname:"name_of_object_class",
			// constant: "0|1",
			children: 0
		}
	};

	// if (parent == null)
	// 	tracer.debug && tracer.debug("_getProperty: property=" + sys.inspect(value, {
	// 		depth: 3
	// 	}));
	// tracer.debug && tracer.debug("_getProperty: parent=" + parent + ", name=" + name + ", value=" + value + ", type=" + type);

	// size: "{NUM}",
	// page: "{NUM}",
	// pagesize: "{NUM}",
	// address: "{NUM}",
	// key: "language_dependent_key",
	// encoding: "none",
	// numchildren: "{NUM}",
	descendents = [prop].concat(parents);
	if (type === "Array") {
		prop.$.type = "array";
		prop.$.children = 1;
		prop.$.numchildren = value.length;
		prop.$.pagesize = features.max_children;
		if (context.pageNumber) prop.$.page = context.pageNumber;
		prop.$.size = value.length;

		prop.property = value.map_(_, (_: _, e: any, i: number) => _getProperty(_, descendents, i, e, context));
	} else if (type === "Blbfile") {
		prop.$.encoding = "base64";
		prop.$value = value.x3ToBase64();
	} else if (value && typeof value.x3ToString === "function") {
		prop.$value = value.x3ToString();
	} else if (type === "Object") {
		var x3Obj = typeof value.get === "function";

		var keys = Object.keys(x3Obj && value.properties || value);
		prop.$.type = "object";
		if (x3Obj) prop.$.classname = value.class && value.class.codclaPath;
		prop.$.children = 1;
		prop.$.numchildren = keys.length;
		prop.$.pagesize = features.max_children;
		if (context.pageNumber) prop.$.page = context.pageNumber;
		prop.$.size = keys.length;

		prop.property = keys.map_(_, (_, k) => _getProperty(_, descendents, k, x3Obj ? value.get(_, k, true) : value[k], context));
		if (parent == null) {
			return prop.property;
		}
	} else {
		if (value instanceof Buffer) {
			prop.$.encoding = "base64";
			prop.$value = value.toString('base64');
		} else {
			prop.$value = "" + value;
		}
	}

	return prop;
}

function newResponse(cmd: string, options: any) {
	var constr: any = DbgpResponse;
	return new constr(cmd, options);
}

function DbgpResponse(cmd: string, options: any) {
	this.$ = {
		command: cmd,
		transaction_id: options.i
	};
}

DbgpResponse.prototype = {
	toXmlString(indent: any) {
		return jsxml.stringify({
			response: this
		}, indent);
	}
};

function getInitMessage(options: any) {
	options = options || {};
	const idekey = options.idekey || "com.sage.x3.xdt.dltk.debugger.etna";

	return {
		init: {
			$: {
				idekey: idekey,
				session: options.baseurl + "/$debug?idekey=" + idekey + "&rtm=" + (options.rtm || "etna.9.0"),
				fileuri: "",
				thread: 0,
				parent: "",
				server: options.server || "", //"AWS-X3-DEVSUP.sagefr.adinternal.com:17000/SUPERV/erbou/101007375",
				language: "x3-etna",
				protocol_version: "1.0"
			},
			engine: {
				$: {
					version: options.rtm || "etna.9.0"
				}
			},
			author: {
				$value: "Sage"
			},
			url: {
				$cdata: "http://www.sage.com"
			},
			copyright: {
				$cdata: "Copyright (c) 2000-2015 Sage"
			}
		}
	};
}

function dbgpType(value: any) {
	return util.x3Typename(value);
}

const _sourceCache: any = {};

function getSource(path: string, begin: number, end: number) {
	path = path.replace(/\\/g, '/');
	// Basic source cache for testing. Need improvement
	var source = _sourceCache[path];
	if (source == null && fs.existsSync(path)) {
		source = _sourceCache[path] = fs.readFileSync(path, 'utf8');
	}
	if (source != null) {
		var lines = source.split(/\n/);
		begin = ~ ~begin;
		end = end != null ? end : lines.length - 1;
		return lines.splice(begin - 1, end - begin + 1).join("\n");
	}
	return source;
}