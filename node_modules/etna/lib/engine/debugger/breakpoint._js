"use strict";

const sys = require("util");
const url = require("url");
const fs = require("fs");
const ez = require('ez-streams');
const helpers = require('syracuse-core').helpers;
const uuid = require('syracuse-core').uuid;
const util = require('etna/lib/engine/runtime/util');
const config = require("config");
const _typeMap = {
	"line": BreakpointLine,
	"call": BreakpointCall,
	"return": BreakpointReturn,
	"exception": BreakpointException,
	"conditional": BreakpointConditional,
	"watch": BreakpointWatch
};
const _bpOptionMap = {
	"t": "type", //	breakpoint type, see above for valid values [required]
	"s": "state", //	breakpoint state [optional, defaults to "enabled"]
	"f": "filename", //	the filename to which the breakpoint belongs [optional]
	"n": "lineno", // the line number (lineno) of the breakpoint [optional]
	"m": "function", //	function name [required for call or return breakpoint types]
	"x": "exception", // exception name [required for exception breakpoint types]
	"h": "hit_value", // hit value (hit_value) used with the hit condition to determine if should break; a value of zero indicates hit count processing is disabled for this breakpoint [optional, defaults to zero (i.e. disabled)]
	"o": "hit_condition", //hit condition string (hit_condition); see hit_condition documentation above; BTW 'o' stands for 'operator' [optional, defaults to '>=']
	"r": "temporary", // 0|1 Boolean value indicating if this breakpoint is temporary. [optional, defaults to false]
	"-": "expression" //	code expression, in the language of the debugger engine. The breakpoint should activate when the evaluated code evaluates to true. [required for conditional breakpoint types]
};
const _bpProperties = ["id", "type", "state", "filename", "lineno", "function", "exception", "hit_value", "hit_condition", "temporary"];

function _convertOptions(options) {
	return Object.keys(options).reduce((r, k) => {
		if (_bpOptionMap[k]) r[_bpOptionMap[k]] = options[k];
		return r;
	}, {});
}

exports.createFromDbgpOptions = function (options) {
	const bpOptions = _convertOptions(options);
	const clazz = _typeMap[bpOptions.type];

	return clazz && new clazz(bpOptions);
};

function Breakpoint(options) {
	const id = uuid.generate();

	Object.defineProperty(this, '$id', {
		get() {
			return id;
		}
	});

	this.$state = "enabled"; // default state
	Object.keys(options).forEach(k => {
		this["$" + k] = options[k];
	});
};

helpers.defineClass(Breakpoint, null, {
	getProperties() {
		return _bpProperties.reduce((r, p) => {
			r[p] = this["$" + p];
			return r;
		}, {});
	},

	getDbgpInfo() {
		const info = {
			$: this.getProperties()
		};

		if (this.$expression) {
			info.expression = {
				$value: this.$expression
			};
		}
		return info;
	},

	updateFromDbgpOptions(options) {
		Object.keys(options).forEach(k => {
			this["$" + _bpOptionMap[k]] = options[k];
		}, {});
	},

	isEnabled() {
		return this.$state === "enabled";
	}
});

// line: break on the given lineno in the given file
// require: filename, lineno
function BreakpointLine(options) {
	Breakpoint.call(this, options);
	const fname = this.$filename.split('/').slice(-2).join('/');

	this.$key = fname + ":" + this.$lineno;
};

helpers.defineClass(BreakpointLine, Breakpoint, {
	//
});

// call: break on entry into new stack for function name
// require: function
function BreakpointCall(options) {
	Breakpoint.call(this, options);
};

helpers.defineClass(BreakpointCall, Breakpoint, {
	//
});

// return: break on exit from stack for function name
// require:	function
function BreakpointReturn(options) {
	Breakpoint.call(this, options);
};

helpers.defineClass(BreakpointReturn, Breakpoint, {
	//
});

// exception: break on exception of the given name
// require: exception
function BreakpointException(options) {
	Breakpoint.call(this, options);
};

helpers.defineClass(BreakpointException, Breakpoint, {
	//
});

// conditional:  filename	break when the given expression is true at the given filename and line number or just in given filename
// require: expression
function BreakpointConditional(options) {
	Breakpoint.call(this, options);
};

helpers.defineClass(BreakpointConditional, Breakpoint, {
	//
});

// watch: break on write of the variable or address defined by the expression argument
// require: 	expression
function BreakpointWatch(options) {
	Breakpoint.call(this, options);
};

helpers.defineClass(BreakpointWatch, Breakpoint, {
	//
});