import * as sys from 'util';
import * as url from 'url';
import * as fs from 'fs';
import * as ez from 'ez-streams';
import { helpers, uuid } from 'syracuse-core';
import * as util from '../runtime/util';
import { Dict } from '../runtime/types';

const config = require("config");
const _typeMap: { [name: string]: any } = {
	"line": BreakpointLine,
	"call": BreakpointCall,
	"return": BreakpointReturn,
	"exception": BreakpointException,
	"conditional": BreakpointConditional,
	"watch": BreakpointWatch
};
const _bpOptionMap: { [letter: string]: string; } = {
	"t": "type", //	breakpoint type, see above for valid values [required]
	"s": "state", //	breakpoint state [optional, defaults to "enabled"]
	"f": "filename", //	the filename to which the breakpoint belongs [optional]
	"n": "lineno", // the line number (lineno) of the breakpoint [optional]
	"m": "function", //	function name [required for call or return breakpoint types]
	"x": "exception", // exception name [required for exception breakpoint types]
	"h": "hit_value", // hit value (hit_value) used with the hit condition to determine if should break; a value of zero indicates hit count processing is disabled for this breakpoint [optional, defaults to zero (i.e. disabled)]
	"o": "hit_condition", //hit condition string (hit_condition); see hit_condition documentation above; BTW 'o' stands for 'operator' [optional, defaults to '>=']
	"r": "temporary", // 0|1 Boolean value indicating if this breakpoint is temporary. [optional, defaults to false]
	"-": "expression" //	code expression, in the language of the debugger engine. The breakpoint should activate when the evaluated code evaluates to true. [required for conditional breakpoint types]
};
const _bpProperties = ["id", "type", "state", "filename", "lineno", "function", "exception", "hit_value", "hit_condition", "temporary"];

type Options = any;

function _convertOptions(options: Options) {
	return Object.keys(options).reduce((r, k) => {
		if (_bpOptionMap[k]) r[_bpOptionMap[k]] = options[k];
		return r;
	}, {} as Options);
}

export function createFromDbgpOptions(options: Options) {
	const bpOptions = _convertOptions(options);
	const clazz = _typeMap[bpOptions.type];

	return clazz && new clazz(bpOptions);
};

interface BreakpointInfo {
	$: any;
	expression?: any;
}

class Breakpoint {
	$state: string;
	$expression: string;

	constructor(options: Options) {
		const id = uuid.generate();

		Object.defineProperty(this, '$id', {
			get() {
				return id;
			}
		});

		this.$state = "enabled"; // default state
		Object.keys(options).forEach(k => {
			(this as any)["$" + k] = options[k];
		});
	}
	getProperties() {
		return _bpProperties.reduce((r, p) => {
			r[p] = (this as any)["$" + p];
			return r;
		}, {} as Dict<any>);
	}

	getDbgpInfo() {
		const info: BreakpointInfo = {
			$: this.getProperties()
		};

		if (this.$expression) {
			info.expression = {
				$value: this.$expression
			};
		}
		return info;
	}

	updateFromDbgpOptions(options: Options) {
		Object.keys(options).forEach(k => {
			(this as any)["$" + _bpOptionMap[k]] = options[k];
		}, {});
	}

	isEnabled() {
		return this.$state === "enabled";
	}
}

// line: break on the given lineno in the given file
// require: filename, lineno
class BreakpointLine extends Breakpoint {
	$filename: string;
	$lineno: number;
	$key: string;
	constructor(options: Options) {
		super(options);
		const fname = this.$filename.split('/').slice(-2).join('/');

		this.$key = fname + ":" + this.$lineno;
	}
}

// call: break on entry into new stack for function name
// require: function
class BreakpointCall extends Breakpoint {
	constructor(options: Options) {
		super(options);
	}
}

// return: break on exit from stack for function name
// require:	function
class BreakpointReturn extends Breakpoint {
	constructor(options: Options) {
		super(options);
	}
}

// exception: break on exception of the given name
// require: exception
class BreakpointException extends Breakpoint {
	constructor(options: Options) {
		super(options);
	}
}

// conditional:  filename	break when the given expression is true at the given filename and line number or just in given filename
// require: expression
class BreakpointConditional extends Breakpoint {
	constructor(options: Options) {
		super(options);
	}
}


// watch: break on write of the variable or address defined by the expression argument
// require: 	expression
class BreakpointWatch extends Breakpoint {
	constructor(options: Options) {
		super(options);
	}
}

