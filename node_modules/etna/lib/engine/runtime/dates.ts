"use strict";

import { _ } from "streamline-runtime";
import * as util from './util';
import * as basic from './basic';
import { types as coreTypes }  from 'syracuse-core';
import { DateValue } from 'syracuse-core/types/date';
import { Datetime } from 'syracuse-core/types/datetime';
import { Expression } from './types';
import { X3Error } from './errors';
import * as date from './tdate';
import * as datetime from './tdatetime';
import * as tinteger from './tinteger';
import * as variables from './variables';
import * as flowControl from './flowControl';

export const functions = {
	DAY: {
		count: 1,
		fn(d: any) {
			if (util.x3IsDatetime(d)) {
				var dd = d._x3ToDate();
				return dd.day;
			}
			if (d.day) return d.day;
			throw util.badArgumentType(d);
		}
	},
	DAYN: {
		count: 1,
		fn(d: date.Date) {
			if (util.x3IsDatetime(d)) throw util.badArgumentType(d); // why?
			// shift sunday from 0 to 7, others unchanged
			return 1 + (d.weekDay + 6) % 7;
		}
	},
	MONTH: {
		count: 1,
		fn(d: any) {
			if (util.x3IsDatetime(d)) {
				var dd = d._x3ToDate();
				return dd.month;
			}
			if (d.month) return d.month;
			throw util.badArgumentType(d);
		}
	},
	NDAY: {
		count: 1,
		fn(d: any) {
			if (d.x3Nday) return d.x3Nday(date.MIN);
			throw util.badArgumentType(d);
		}
	},
	WEEK: {
		count: 1,
		fn(d: any) {
			// re-create the original x3 week bug on week 53
			if (d.week) return d.month == 12 && d.week == 1 ? 53 : d.week;
			if (util.x3IsDatetime(d)) {
				var dd = d._x3ToDate();
				return dd.month == 12 && dd.week == 1 ? 53 : dd.week;
			}
			throw util.badArgumentType(d);
		}
	},
	YEAR: {
		count: 1,
		fn(d: any) {
			if (util.x3IsDate(d)) return d.x3Year;
			if (util.x3IsDatetime(d)) {
				var dd = d._x3ToDate();
				return dd.x3Year;
			}
			throw util.badArgumentType(d);
		}
	},
	DAY$: {
		async: true,
		count: 1,
		fn(_: _, d: any) {
			const frame = util.currentContext().x3frame;

			if (util.x3IsDate(d)) d = d.weekDay;
			else if (util.x3IsInteger(d)) d = d % 7;

			else throw util.badArgumentType(d);
			return flowControl.functions.MESS.fn(_, d || 7, 742, 1);
		}
	},
	MONTH$: {
		async: true,
		count: 1,
		fn(_: _, m: any) {
			const frame = util.currentContext().x3frame;

			if (util.x3IsDate(m)) m = m.month;
			else if (util.x3IsInteger(m)) m = 1 + (m + 11) % 12;

			else throw util.badArgumentType(m);
			return flowControl.functions.MESS.fn(_, m, 9001, 1);
		}
	},
	TIME$: {
		count: 0,
		fn() {
			return coreTypes.time.now().toString();
		}
	},
	ADDMONTH: {
		count: 2,
		fn(d: any, dm: number) {
			if (d.x3AddMonths) return d.x3AddMonths(dm);
			throw util.badArgumentType(d);
		}
	},
	AWEEK: {
		count: 2,
		fn(w: number, y: number) {
			util.checkInteger(w);
			util.checkInteger(y);
			if (y < 1600) throw new X3Error(56, "out off limit");
			return date.makeInWeek(y, w, 1);
		}
	},
	DATE$: {
		count: 0,
		fn() {
			return date.today();
		}
	},
	DATETIME$: {
		count: 0,
		fn() {
			return datetime.now();
		}
	},
	GDATETIME$: {
		count: 1,
		fn(s: string) {
			return datetime.x3Parse(s);
		}
	},
	EOMONTH: {
		count: 1,
		fn(d: any) {
			if (d.endOfMonth) return d.endOfMonth();
			if (util.x3IsDatetime(d)) return d.x3EndOfMonth();
			throw util.badArgumentType(d);
		}
	},
	GDAT$: {
		//count: 3, -- sometimes used with 1 - see AFNC line 588
		fn(d: number, m: number, y: number) {
			util.checkInteger(d);
			util.checkInteger(m);
			util.checkInteger(y);
			if (!d && !m && !y) return date.NULL;

			if (y < 100) {
				var frame = util.currentContext().x3frame;
				y = 1900 + y < frame.context.sys.values.ADXDCS ? 2000 + y : 1900 + y;
			}

			var dd = 0,
			    dy = 0;
			if (d <= 0) dd = d - 1, d = 1;
			if (m <= 0 || m > 12) dy = Math.floor((m - 1) / 12), y += dy, m -= dy * 12;
			const d2 = date.make(y, m, d);

			return dd ? d2.addDays(dd) : d2;
		}
	},
	NDAY$: {
		count: 1,
		fn(n: number) {
			if (n < -1) throw new X3Error(56, "");
			return (date.MIN as any).x3AddDays(n);
		}
	},
	TIME: {
		count: 0,
		fn() {
			return coreTypes.time.now().value % (24 * 3600);
		}
	},
	TIMESTAMP$: {
		count: 0,
		fn() {
			return datetime.now().toString();
		}
	}
};

export const instructions = {
	DATE(year: number, month: number, day: number) {
		return basic.instructions.C(date.make(year, month, day));
	}
};