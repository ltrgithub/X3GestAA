import { _ } from 'streamline-runtime';
import { Expression } from './types';
import * as util from './util';
import * as variables from './variables';
import { X3Error } from './errors';

export type UnaryOp = (val: any) => any;
export type BinaryOp = (val1: any, val2: any) => any;

const _unaryOps: { [name: string]: UnaryOp; } = {
	USUB: function minus(a: any) {
		if (a.x3IsNumeric()) return a.x3Minus();
		else throw util.badOperand(a);
	},

	UADD: function plus(a: any) {
		if (a.x3IsNumeric()) return a;
		else throw util.badOperand(a);
	},

	NOT: function not(a: any) {
		if (util.x3IsDate(a)) throw util.badOperand(a);

		if (a.x3IsNumeric()) return a.x3IsZero() ? 1 : 0;
		else throw util.badOperand(a);
	}
};

export function round(val: number) {
	return Math.round(val * 1e6) / 1e6;
};

export const binaryOps: { [name: string]: BinaryOp; }  = {
	ADD: function add(a: any, b: any) {
		return a.x3Add(b);
	},
	SUB: function sub(a: any, b: any) {
		return a.x3Sub(b);
	},
	MUL: function mul(a: any, b: any) {
		return a.x3Mul(b);
	},
	DIV: function div(a: any, b: any) {
		return a.x3Div(b);
	},
	MOD: function mod(a: any, b: any) {
		return a.x3Mod(b);
	},
	POW: function pow(a: any, b: any) {
		return a.x3Pow(b);
	},
	XOR: function xor(a: any, b: any) {
		return a.x3Xor(b);
	},
	EQ: function eq(a: any, b: any) {
		if (a && !a.x3Compare) throw new X3Error(10, "");
		return a !== null ? a.x3Compare(b) === 0 ? 1 : 0 : b === null;
	},
	NE: function ne(a: any, b: any) {
		if (a && !a.x3Compare) throw new X3Error(10, "");
		return a !== null ? a.x3Compare(b) === 0 ? 0 : 1 : b !== null;
	},
	LT: function lt(a: any, b: any) {
		if (a && !a.x3Compare) throw new X3Error(10, "");
		return a.x3Compare(b) < 0 ? 1 : 0;
	},
	LE: function le(a: any, b: any) {
		if (a && !a.x3Compare) throw new X3Error(10, "");
		return a.x3Compare(b) <= 0 ? 1 : 0;
	},
	GT: function gt(a: any, b: any) {
		if (a && !a.x3Compare) throw new X3Error(10, "");
		return a.x3Compare(b) > 0 ? 1 : 0;
	},
	GE: function ge(a: any, b: any) {
		if (a && !a.x3Compare) throw new X3Error(10, "");
		return a.x3Compare(b) >= 0 ? 1 : 0;
	}
};

/* 
 * Operators
 */

function op1(f: UnaryOp) {
	return function (f1: Expression<any>) {
		return function op1$do(_: _) {
			//return f(f1.value !== undefined ? f1.value : f1(_));
			const v1 = f1.value !== undefined ? f1.value : f1(_);
			const v11 = Array.isArray(v1) ? v1[2][0] === undefined ? v1[1] : v1[2][0] : v1;

			return f(v11);
		};
	};
}

function op2(f: BinaryOp) {
	return function (f1: Expression<any>, f2: Expression<any>) {
		return function op2$do(_: _) {
			//return f(f1.value !== undefined ? f1.value : f1(_), f2.value !== undefined ? f2.value : f2(_));
			const v1 = f1.value !== undefined ? f1.value : f1(_);
			const v2 = f2.value !== undefined ? f2.value : f2(_);
			const v11 = Array.isArray(v1) ? v1[2][0] === undefined ? v1[1] : v1[2][0] : v1;
			const v22 = Array.isArray(v2) ? v2[2][0] === undefined ? v2[1] : v2[2][0] : v2;

			return f(v11, v22);
		};
	};
}

export const instructions = {
	AND(f1: Expression<any>, f2: Expression<any>) {
		return function and$do(_: _) {
			const op1 = f1(_);

			if (util.x3IsDate(op1)) throw util.badOperand(op1);
			if (!op1.x3IsNumeric()) throw util.badOperand(op1);
			if (op1.x3IsZero()) return 0; // Don't evaluate op2 if op1 is false !
			// Example : dim([L]DOS)<=0 or (dim([L]DOS) >= 0 & [L]DOS="")

			const op2 = f2(_);

			if (util.x3IsDate(op2)) throw util.badOperand(op2);
			if (!op2.x3IsNumeric()) throw util.badOperand(op2);
			return op2.x3IsZero() ? 0 : 1;
		};
	},
	OR(f1: Expression<any>, f2: Expression<any>) {
		return function or$do(_: _) {
			const op1 = f1(_);
			const op2 = f2(_);

			if (util.x3IsDate(op1)) throw util.badOperand(op1);
			if (util.x3IsDate(op2)) throw util.badOperand(op2);
			if (!op1.x3IsNumeric()) throw util.badOperand(op1);
			if (!op2.x3IsNumeric()) throw util.badOperand(op2);

			return !op1.x3IsZero() || !op2.x3IsZero() ? 1 : 0;
		};
	},
	PLUSEQ(lhs: Expression<any>, rhs: Expression<any>) {
		return variables.instructions.SET(lhs, exports.instructions.ADD(lhs, rhs));
	},
	MINUSEQ(lhs: Expression<any>, rhs: Expression<any>) {
		return variables.instructions.SET(lhs, exports.instructions.SUB(lhs, rhs));
	},
	MULEQ(lhs: Expression<any>, rhs: Expression<any>) {
		return variables.instructions.SET(lhs, exports.instructions.MUL(lhs, rhs));
	},
	DIVEQ(lhs: Expression<any>, rhs: Expression<any>) {
		return variables.instructions.SET(lhs, exports.instructions.DIV(lhs, rhs));
	}
};

for (var op in _unaryOps) exports.instructions[op] = op1(_unaryOps[op]);
for (var op in exports.binaryOps) exports.instructions[op] = op2(exports.binaryOps[op]);
//for (var op in _binaryOps) exports.binaryOps[op] = _binaryOps[op] ;
//for (var op in _unaryOps) exports.unaryOps[op] = _unaryOps[op];