import { _ } from 'streamline-runtime';
import * as basic from './basic';
import * as bcd from './tbcd';
import * as types from './types';
import * as arrays from './arrays';
import * as variables from './variables';
import * as dates from './dates';
import * as flowControl from './flowControl';
import * as stats from './stats';
import * as operators from './operators';
/*
 * Eval
 */

import { Parser } from '../parser';

//var insts: { [name: string]: types.Instruction<any> };

import * as util from './util';
import * as errors from './errors';
const trace = require('syracuse-core').getTracer("etna.engine");

function buildLiteral(node: types.ParseValueNode) {
	return basic.instructions.C(node.value);
}

function buildDecimal(node: types.ParseValueNode) {
	return basic.instructions.C(bcd.fromString(node.value));
}

var _buildExports: any;
var _buildRequire: (_: _, name: string) => any;

type Builder = (Node: types.ParseNode) => types.Expression<any>;
const builders: { [name: string]:  Builder } = {
	STRING: buildLiteral,
	DECIMAL: buildDecimal,
	INTEGER: buildLiteral,
	IDENT(node: types.ParseValueNode) {
		return variables.instructions.V(node.value);
	},
	PROP(node: types.ParseMemberNode) {
		if (node.name.toUpperCase() !== "SNAPSHOT") {
			return variables.instructions.PROP(_build(node.target), node.name);
		} else {
			return variables.instructions.SNAP(_build(node.target));
		}
	},
	CLAS(node: types.ParseDictNode) {
		if (node.field && node.field.length) {
			return variables.instructions.CV(node.letter, node.abbrev, node.field.toUpperCase());
		} else {
			return variables.instructions.CLA(node.letter, node.abbrev);
		}
	},
	OP(node: types.ParseOpNode) {
		return util.any(operators.instructions)[node.op].apply(null, node.args.map(_build));
	},
	FCALL(node: types.ParseFCallNode) {
		return flowControl.instructions.F(node.name, (node.args || []).map(_build));
	},
	EVALUE(node: types.ParseArgNode) {
		return instructions.EVALUE(_buildRequire, _buildExports, _build(node.arg));
	},
	SIGMA(node: types.ParseFieldArgsNode) {
		return stats.instructions.SIGMA(node.field, node.args.map(_build));
	},
	FUNC(node: types.ParseFuncNode) {
		//dbg:console.error("FUNC node.from:",node.from)
		//dbg:console.error("FUNC node.name:",node.name)
		if (node.from) {
			return flowControl.instructions.CALL(flowControl.instructions.REQ(_buildRequire, _build(node.from)), util.any(node.name), (node.args || []).map(_build));
		} else {
			return flowControl.instructions.CALL(basic.instructions.C(_buildExports), _build(node.name), (node.args || []).map(_build));
		}
	},
	INDEX(node: types.ParseIndexNode) {
		return arrays.instructions.INDEX(_build(node.target), node.args.map(_build));
	},
	DATE(node: types.ParseDateNode) {
		return dates.instructions.DATE(node.year, node.month, node.day);
	},
	DIM(node: types.ParseArgsNode) {
		var letter: string, field: string, rhs: types.Expression<any>;
		for (var i = 0; i < node.args.length; i++) {
			const argNode: any = node.args[i];
			switch (node.args[i].tag) {
				case "CLAS":
					letter = argNode.letter;
					field = argNode.field;
					break;
				case "IDENT":
					field = argNode.value;
					break;
				case "INTEGER":
					rhs = basic.instructions.C(argNode.value);
					break;
			}
		}
		if (field != null) return variables.instructions.DIM(letter || "", field || "", rhs);
		else return variables.instructions.DYNDIM.apply(null, node.args.map(_build));
	},
	TYPE(node: types.ParseTypeNode) {
		if (node.field != null) return variables.instructions.TYPE(node.letter, node.field);
		else return variables.instructions.DYNTYPE(_build(node.exp));
	}
};

function _build(node: types.ParseNode) {
	const builder = builders[node.tag];

	if (!builder) {
		throw new errors.X3Error(200, "unsupported eval construct: " + node.tag);
	}
	return builder(node);
}

export const functions = {
	EVALUE: { // parser needs it in this table but fn will never be called
		count: -1
	}
};

export const instructions = {
	EVALUE(req: (_: _, name: string) => any, ns: any, arg: any) {
		return function evalue$do(_: _) {
			//insts = insts || require('./index').instructions;
			var argVal = arg(_);
			if (Array.isArray(argVal) && argVal[0] == 1) {
				var exp = "";
				for (var i = 0; i < argVal[2].length; i++) {
					exp += argVal[2][i];
				}
				argVal = exp;
			}
			argVal = util.x3ToString(argVal, true);
			if (!argVal.length) return ""; // Nothing to evaluate
			try {
				var node = new Parser(argVal, "eval").parseExp(true);
				_buildRequire = req;
				_buildExports = ns;
				var fn = _build(node);
				return fn(_);
			} catch (e) {
				trace.error && trace.error("EVALUE:" + argVal);
				if (e.errn === 200) throw new errors.X3Error(5, "Illegal character:" + JSON.stringify(e));
				else if (e.errn === 13) throw new errors.X3Error(26, "Internal error");
				else throw e;
			}
		};
	}
};

export function compile(expression: string) {
	//insts = insts || require('./index').instructions;
	const node = new Parser(expression, "eval").parseExp(true);

	return _build(node);
};

export function evalue(_: _,  expression: string) {
	return compile(expression)(_);
};