"use strict";

import * as util from './util';
const Parser = require("../parser").Parser;
import * as format from './format';
const _latin1_192_255 = ["A", "A", "A", "A", "A", "A", "AE", "C", "E", "E", "E", "E", "I", "I", "I", "I", "D", "N", "O", "O", "O", "O", "O", "x", "O", "U", "U", "U", "U", "Y", "P", "B", "a", "a", "a", "a", "a", "a", "ae", "c", "e", "e", "e", "e", "i", "i", "i", "i", "d", "n", "o", "o", "o", "o", "o", "-", "o", "u", "u", "u", "u", "y", "p", "y"];

function _toAscii(ch) {
	if (ch >= 0x20 && ch <= 0x7e) return String.fromCharCode(ch);
	else if (ch == 140) return "OE";
	else if (ch == 156) return "oe";
	else if (ch >= 192 && ch <= 255) return _latin1_192_255[ch - 192];
	else return "?";
}

function repeat(ch, n) {
	var s = "";
	for (var i = 0; i < n; i++) s += ch;
	return s;
}

export const functions = {
	ASCII: {
		count: 1,
		fn(expression) {
			expression = util.x3ToString(expression, true);
			return expression.charCodeAt(0);
		}
	},
	LEN: {
		count: 1,
		fn(expression) {
			if (expression.x3Length) return expression.x3Length();
			throw util.badOperand(expression);
		}
	},
	PARSE: {
		count: 2,
		fn(expression) {
			expression = util.x3ToString(expression, true);
			try {
				var prs = new Parser(expression, "eval");
				var node = prs.parseExp(true);
			} catch (e) {
				return 5;
			}
			return 0;
		}
	},
	PAT: {
		count: 2,
		fn(s1, s2) {
			s1 = util.x3ToString(s1, true);
			s2 = util.x3ToString(s2, true);

			const regex = new RegExp("^" + s2.replace(/\*/g, ".*").replace(/#/g, "\\d{1}").replace(/!/g, "[a-zA-Z]{1}").replace(/\?/g, ".{1}") + "$");

			return regex.test(s1) ? 1 : 0;
		}
	},
	VAL: {
		count: 1,
		fn(s) {
			if (s.x3Val) return s.x3Val();
			throw util.badOperand(s);
		}
	},
	LEFT$: {
		count: 2,
		fn(s, i) {
			s = util.x3ToString(s, true);
			return s.substring(0, i);
		}
	},
	MID$: {
		count: 3,
		fn(s, i, l) {
			s = util.x3ToString(s, true);
			return s.substring(i - 1, i - 1 + l);
		}
	},
	RIGHT$: {
		count: 2,
		fn(s, i) {
			s = util.x3ToString(s, true);
			return s.substring(i - 1);
		}
	},
	SEG$: {
		count: 3,
		fn(s, i, j) {
			s = util.x3ToString(s, true);
			return s.substring(i - 1, j);
		}
	},
	SEG2$: {
		count: 3,
		fn(s, i, j) {
			s = util.x3ToString(s, true);
			return s.substring(i - 1, j);
		}
	},
	CTRANS: {
		count: -1,
		fn(src, from, to) {
			var dst = "",
			    ch;
			src = util.x3ToString(src, true);
			if (from) {
				from = util.x3ToString(from, true);
				to = util.x3ToString(to, true);
				if (from.length < src.length) {
					var map = {};
					for (var i = 0, l = from.length; i < l; i++) map[from.charCodeAt(i)] = to.charCodeAt(i) || -1;

					for (var i = 0, l = src.length; i < l; i++) {
						var tch = map[ch = src.charCodeAt(i)];
						if (tch !== -1) dst += String.fromCharCode(tch === undefined ? ch : tch);
					}
				} else {
					for (var i = 0, l = src.length; i < l; i++) {
						var off = from.indexOf(ch = src[i]);
						if (off >= 0) {
							if (off < to.length) dst += to[off];
						} else dst += ch;
					}
				}
			} else {
				for (var i = 0, l = src.length; i < l; i++) dst += _toAscii(src.charCodeAt(i));
			}
			//console.error("ctrans: src=" + src + " dst=" + dst);
			return dst;
		}
	},
	TOLOWER: {
		count: 1,
		fn(s) {
			return s.toLowerCase();
		}
	},
	TOUPPER: {
		count: 1,
		fn(s) {
			return s.toUpperCase();
		}
	},
	VIREBLC: {
		//count: 2,
		// 2nd arg seems optional (see AVOLUME_CSTD line 523)
		fn(s, mode) {
			/*var fn = trimFuncs[mode || 0];
   if (!fn) throw new X3Error(50, "bad mode: " + mode);*/
			s = util.x3ToString(s, true);
			return util.x3Trim(s, mode);
		}
	},
	CHR$: {
		count: 1,
		fn(n) {
			return String.fromCharCode(n);
		}
	},
	GRAPH$: {
		count: -1,
		fn(nb, n) {
			if (n == null) n = nb, nb = 1;
			return repeat(String.fromCharCode(149 + n), nb);
		}
	},
	SPACE$: {
		count: 1,
		fn(n) {
			return repeat(' ', n);
		}
	},
	STRING$: {
		count: 2,
		fn(n, ch) {
			return repeat(typeof ch === "number" ? String.fromCharCode(ch) : ch, n);
		}
	},
	FORMAT$: {
		count: 2,
		fn(fmt, val) {
			fmt = util.x3ToString(fmt, true);
			return format.format(fmt, val);
		}
	},
	NUM$: {
		count: 1,
		fn(x) {
			if (x.x3NumDollar) return x.x3NumDollar();
			const v = typeof x === 'boolean' ? x ? 1 : 0 : x;

			if (!v.x3ToString) throw util.badOperand(x);
			return v.x3ToString();
		}
	},
	INSTR: {
		count: 3,
		fn(start, str, s) {
			util.checkInteger(start);
			str = util.x3ToString(str, true);
			s = util.x3ToString(s, true);
			return start <= 0 ? 0 : str.indexOf(s, start - 1) + 1;
		}
	},
	XGETCHAR: {
		count: 2,
		fn(s, pos) {
			s = util.x3ToString(s, true);
			return s.charAt(pos - 1);
		}
	},
	ESCJSON: {
		count: 1,
		fn(s) {
			var rs = Array.isArray(s) ? s[2][0] : s;
			rs = util.x3ToString(rs, true);
			return rs.replace(/[\"\\\/\b\f\n\r\t]/g, "\\$&");
		}
	}
};