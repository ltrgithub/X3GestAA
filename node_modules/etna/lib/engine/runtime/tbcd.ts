"use strict";

import * as util from './util';
import * as bcd from './bcd';
import * as basic from './basic';
import * as tdouble from './tdouble';
import { Expression } from './types';
import { Blbfile } from './tblbfile';

export class BCD {
	value: number[];
	constructor(mantissa: number[]) {
		this.value = mantissa;
	}
	x3AssertOverflow(type: string) {
		return true;
	}
	x3Minus() {
		return new BCD(bcd.minus(this.value));
	}
	x3ToBCD() {
		return this;
	}
	x3ToString() {
		return bcd.toString(this.value);
	}
	toString() {
		return bcd.toString(this.value);
	}
	x3ToInteger() {
		return bcd.toInt32(this.value);
	}
	x3ToDouble() {
		return new tdouble.Double(bcd.toDouble(this.value));
	}
	x3ToDate() {
		throw util.badOperand(this);
	}
	x3ToDatetime() {
		throw util.badOperand(this);
	}
	x3Serialize(l: any) {
		return bcd.toBuffer(this.value);
	}
	x3IsNumeric() {
		return true;
	}
	x3IsZero() {
		return bcd.isZero(this.value);
	}
	x3IsUndefined() {
		return bcd.isZero(this.value);
	}
	isInt32(opt?: any) {
		return bcd.isInt32(this.value, opt);
	}
	x3IsEmpty() {
		throw util.badOperand(this);
	}
	x3Add(b: any): any {
		if (b instanceof BCD) return new BCD(bcd.add(this.value, b.value));
		if (util.x3IsDate(b) || util.x3IsDatetime(b)) return b.x3Add(this.x3ToInteger());

		if (b.x3ToBCD) return this.x3Add(b.x3ToBCD());
		throw util.badOperand(b);
	}
	x3Sub(b: any): any {
		if (b instanceof BCD) return new BCD(bcd.sub(this.value, b.value));
		if (b.x3ToBCD) return this.x3Sub(b.x3ToBCD());
		throw util.badOperand(b);
	}
	x3Mul(b: any): any {
		if (b instanceof BCD) return new BCD(bcd.multiply(this.value, b.value));
		if (b.x3ToBCD) return this.x3Mul(b.x3ToBCD());
		throw util.badOperand(b);
	}
	x3Div(b: any): any {
		if (b instanceof BCD) return new BCD(bcd.divide(this.value, b.value));
		if (b.x3ToBCD) return this.x3Div(b.x3ToBCD());
		throw util.badOperand(b);
	}
	x3Mod(b: any): any {
		if (b instanceof BCD) {
			if (b.x3IsZero()) return this;

			const dv = bcd.divide(this.value, b.value);
			const fx = bcd.toInt32(dv);
			const ml = bcd.multiply(bcd.fromInt32(fx), b.value);
			return new BCD(bcd.sub(this.value, ml));
		}
		if (b.x3ToBCD) return this.x3Mod(b.x3ToBCD());
		throw util.badOperand(b);
	}
	x3Pow(b: any): any {
		if (b instanceof BCD) {
			if (b.x3IsZero()) return 1;

			var r = bcd.fromInt32(1);
			const n = b.x3ToInteger();

			for (var i = n; i > 0; i--) {
				r = bcd.multiply(r, this.value);
			}

			return new BCD(r);
		}
		if (b.x3ToBCD) return this.x3Pow(b.x3ToBCD());

		throw util.badOperand(b);
	}
	x3Compare(b: any): any {
		if (b instanceof BCD) return bcd.compare(this.value, b.value);
		if (b.x3ToBCD) return this.x3Compare(b.x3ToBCD());
		throw util.badOperand(b);
	}
	x3Xor(b: any): any {
		if (b.x3IsNumeric()) {
			const i = this.x3IsZero() ? 1 : 0;
			const j = b.x3IsZero() ? 1 : 0;

			return i ^ j;
		} else throw util.badOperand(b);
	}
	x3Abs() {
		return new BCD(bcd.abs(this.value));
	}
	x3Truncate(v: any): any {
		return new BCD(bcd.truncate(this.value, 0));
	}
	x3ToSql(v: any): any {
		return this.x3ToString();
	}
	x3Clone() {
		return new BCD(this.value.slice());
	}
	x3Type() {
		return 7;
	}
}

export function fromString(s: string): BCD {
	return new BCD(bcd.fromString(s));
};

export function fromInt32(i: number): BCD {
	return new BCD(bcd.fromInt32(i));
};

export function fromDouble(i: number): BCD {
	return new BCD(bcd.fromDouble(i));
};

export function fromBlbfile(i: any): BCD {
	return new BCD(bcd.fromBuffer(i.valueOf()));
};
export const instructions = {
	DECIMAL(v: string) {
		return basic.instructions.C(fromString(v));
	}
};