import { _ } from 'streamline-runtime';
import * as types from './types';
import * as nodes from '../compilers/nodes';
import * as bcd from './tbcd';
import * as db from './db';
import * as dates from './dates';
const glob = require('streamline/lib/globals');
import { Parser } from '../compilers/parser';

import * as util from './util';
import * as basic from './basic';
import * as errors from './errors';

function buildLiteral(node: nodes.ParseValueNode) {
	return basic.instructions.C(node.value);
}

function buildDecimal(node: nodes.ParseValueNode) {
	return basic.instructions.C(bcd.fromString(node.value));
}

var _buildExports: any;
var _buildRequire: (name: string) => any;

const builders: { [name: string]: (Node: nodes.ParseNode) => types.Expression<any> } = {
	STRING: buildLiteral,
	DECIMAL: buildDecimal,
	INTEGER: buildLiteral,
	IDENT(node: nodes.ParseValueNode) {
		return db.instructions.SQLV(node.value);
	},
	CLAS(node: nodes.ParseDictNode) {
		return db.instructions.SQLCV(node.letter, node.abbrev, node.field.toUpperCase());
	},
	OP(node: nodes.ParseOpNode) {
		return util.any(db.instructions)["SQL" + node.op].apply(null, node.args.map(_build));
	},
	FCALL(node: nodes.ParseFCallNode) {
		return db.instructions.SQLF(node.name, (node.args || []).map(_build));
	},
	EVALUE(node: nodes.ParseArgNode) {
		return db.instructions.SQLEVALUE(_buildRequire, _buildExports, _build(node.arg));
	},
	INDEX(node: nodes.ParseIndexNode) {
		return db.instructions.SQLINDEX(_build(node.target), node.args.map(_build));
	},
	DATE(node: nodes.ParseDateNode) {
		return dates.instructions.DATE(node.year, node.month, node.day);
	}
};

function _build(node: nodes.ParseNode) {
	const builder = builders[node.tag];

	if (!builder) throw new errors.X3Error(200, "unsupported eval construct: " + node.tag);
	return builder(node);
}

export const functions = {
	EVALUE: { // parser needs it in this table but fn will never be called
		count: -1
	}
};

export const instructions = {
	EVALUE(req: (name: string) => any, ns: any, arg: types.Expression<any>) {
		return function evalue$do(_: _) {
			const frame = glob.context.x3frame;
			const ctx = frame.whereContext;

			var argVal = arg(_);
			if (Array.isArray(argVal) && argVal[0] == 1) {
				var exp = "";
				for (var i = 0; i < argVal[2].length; i++) {
					exp += argVal[2][i];
				}
				argVal = exp;
			}
			argVal = util.x3ToString(argVal, true);
			try {
				var node = new Parser(argVal, "eval").parseExp(true);
				_buildRequire = req;
				_buildExports = ns;
				var fn = _build(node);
				return fn(_, ctx);
			} catch (e) {
				if (e.errn === 200) throw new errors.X3Error(5, "Illegal character");
				else if (e.errn === 13) throw new errors.X3Error(26, "Internal error");
				throw e;
			}
		};
	}
};