import { _ } from 'streamline-runtime';
import * as ez from 'ez-streams';
import * as types from './types';
const tracer = require('syracuse-core').getTracer("etna.engine");
import { X3Error } from './errors';

function _extended(abv: string) {
	return abv !== "extended";
}

function _save(tables, columns) {
	const rec = {};

	if (columns) {
		Object.keys(columns).filter(_extended).forEach(abv => {
			if (columns[abv] !== null) {
				var cdef = columns[abv];
				var cpy = {};
				for (var i = 0; i < cdef.length; i++) {
					var nm = cdef[i].field.data.CODZONE;
					cpy[nm] = tables[abv].values[nm];
				}
				rec[abv] = cpy;
			} else rec[abv] = tables[abv].values;
		});
	} else {
		Object.keys(tables).forEach(abv => {
			rec[abv] = tables[abv].values;
		});
	}
	return rec;
}

function _dispatch(tables, row, columns) {
	// console.log("_dispatch:",row);
	if (columns) {
		Object.keys(columns).filter(_extended).forEach(abv => {
			const cdef = columns[abv];

			if (cdef === null) tables[abv].values = row[abv];
			else {
				// assign just values from columns
				for (var i = 0; i < cdef.length; i++) {
					var nm = cdef[i].field.data.CODZONE;
					tables[abv].values[nm] = row[abv][nm];
				}
			}
		});
	} else {
		Object.keys(row).forEach(abv => {
			tables[abv].values = row[abv];
		});
	}
}

export class DBCursor {
	reader: ez.Reader<types.Row>;

	constructor(reader: ez.Reader<types.Row>, tables: { [name: string]: DBTable }, maptrim, pwhere, key, lvl, typ, columns) {
		this.reader = reader;
		this.tables = tables;
		this.maptrim = maptrim;
		this.pwhere = pwhere;
		this.key = key;
		this.klvl = lvl;
		this.level = 0;
		this.currkeyValues = [];
		this.pocket = undefined;
		this.lastRecord = undefined;
		this.finished = false;
		this.typecursor = typ;
		this.columns = columns;
	}

	x3GetRecord(_: _,  sv?: boolean) {
		const maptrim = this.maptrim;
		const pwhere = this.pwhere;
		const tables = this.tables;

		var vsave;
		var wok = 1;

		// I have  anything in my pocket ?
		if (this.pocket) {
			_dispatch(tables, this.pocket);
			var r = this.pocket;
			this.pocket = undefined;
			return r;
		}

		// save last record
		vsave = _save(tables, this.columns);

		// let's go dancing with records
		tracer.debug && tracer.debug("Cursor Read....");
		var rec = this.reader.read(_);
		tracer.debug && tracer.debug("Cursor read ok");
		while (rec) {
			var row = maptrim(_, rec);
			_dispatch(tables, row, this.columns);

			tracer.debug && tracer.debug(row);

			// post evaluations have to be ok
			wok = 1;
			for (var i = 0; i < pwhere.length; i++) {
				var w = pwhere[i](_);
				var r = w.reduce((r, c) => r && c, 1);
				wok = wok && r;
			}
			if (!wok) {
				rec = this.reader.read(_);
			} else {
				break;
			}
		}

		if (!wok && !rec) _dispatch(tables, vsave, this.columns);
		if (sv) this.lastRecord = vsave;
		if (rec === undefined) this.finished = true;
		return rec;
	}

	x3DiscardCurrent() {
		if (this.lastRecord === undefined) throw new X3Error(26, "x3DiscardCurrent without save");

		this.pocket = _save(this.tables);
		_dispatch(this.tables, this.lastRecord);
		this.lastRecord = undefined;
	}
	x3CloseDBReader(_: _) {
		tracer.debug && tracer.debug("Reader stop....");
		this.reader.stop(_);
	}
	x3HasNoMoreRecord() {
		return this.finished;
	}
	x3FreeLast() {
		this.lastRecord = undefined;
	}
}