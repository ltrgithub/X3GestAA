import * as types from './types';
import * as util from './util';
import * as tdate from './tdate';
import * as tdatetime from './tdatetime';
const datetime = require('syracuse-core').types.datetime;
import * as tbcd from './tbcd';
import { Clbfile } from './tclbfile';
import { X3Error } from './errors';

export class Blbfile {
	value: Buffer;
	constructor(v?: Buffer) {
		if (v instanceof Buffer) {
			this.value = v;
		} else if (v === undefined) {
			this.value = new Buffer(0);
		} else throw util.badOperand(v);
	}
	valueOf() {
		return this.value;
	}
	x3IsNumeric() {
		return false;
	}
	x3AssertOverflow(type: string) {
		return true;
	}
	x3Minus(v: any) {
		throw util.badOperand(v);
	}
	x3ToDouble(v: any) {
		throw util.badOperand(v);
	}
	x3ToString(t?: number) {
		if (t !== undefined) return this.value.toString(t === 50 ? 'binary' : 'utf8');
		else {
			const b0 = this.valueOf();
			const b1 = new Buffer(b0.length);
			var v: number,
			    i = 0;

			// to BE and trailling 0
			while (v = b0.readUInt16BE(i)) {
				b1.writeUInt16LE(v, i);
				i += 2;
			}
			return b1.toString("ucs2", 0, i);
		}
	}
	x3ToBase64() {
		return this.value.toString('base64');
	}
	x3ToBCD(v: any) {
		return tbcd.fromBlbfile(this);
	}
	x3ToClbfile(): Clbfile {
		const b0 = this.valueOf();
		const len = b0.readUInt32BE(0);
		var v: number,
		    i = 4;
		if (len === 0) return new Clbfile("");
		const b1 = new Buffer(len);

		// to BE and trailling 0
		while (v = b0.readUInt16BE(i)) {
			b1.writeUInt16LE(v, i - 4);
			i += 2;
		}
		return new Clbfile(b1.toString("ucs2", 0, i - 4));
	}
	x3ToInteger() {
		const b = this.value;
		const uint8 = function (v: number) {
			return v < 0 ? v + 256 : v;
		};
		const int32 = function (v: number) {
			return v >= Math.pow(2, 31) ? v - Math.pow(2, 32) : v;
		};
		const int16 = function (v: number) {
			return v >= Math.pow(2, 15) ? v - Math.pow(2, 16) : v;
		};

		switch (b.length) {
			case 8:
				const hi = b.readUInt32BE(0);
				const lo = b.readUInt32BE(4);
				return hi * 0x100000000 + lo;
			case 4:
				return b.readUInt32BE(0);
			case 3:
				return int32((uint8(b.readInt8(0)) << 16) + (uint8(b.readInt8(1)) << 8) + uint8(b.readInt8(2)));
			case 2:
				return b.readInt16BE(0);
			case 1:
				return b.readUInt8(0);
			default:
				throw new X3Error(26, "Bad size conversion to Integer");
		}
	}
	x3ToDate() {
		const o: any = tdate.MIN;
		return o.x3Add(this.x3ToInteger() - 1);
	}
	x3ToUuid() {
		return this.value;
	}
	x3ToDatetime(v: any) {
		const n = this.x3ToInteger();
		const sec = n % 60;
		const m = Math.floor(n / 60);
		const min = m % 60;
		const h = Math.floor(m / 60);
		const ho = h % 24;
		const d = Math.floor(h / 24);
		const o: any = tdate.MIN;
		const dt = o.x3Add(d - 1);
		return datetime.make(dt.year, dt.month, dt.day, ho, min, sec, 0);
	}
	x3Serialize(v: any) {
		return this.value;
	}
	x3IsZero() {
		throw util.badOperand(this);
	}
	x3IsEmpty() {
		return this.value.length === 0;
	}
	x3IsUndefined() {
		throw util.badOperand(this);
	}
	x3Length() {
		return this.value.length;
	}
	x3Compare(b: any) {
		if (!util.x3IsBlbfile(b)) throw util.badOperand(b);

		if (this.value.length < b.value.length) return -1;
		else if (this.value.length > b.value.length) return 1;

		else {
			for (var i = 0; i < this.value.length; i++) {
				if (this.value[i] < b.value[i]) return -1;
				else if (this.value[i] > b.value[i]) return 1;
			}
			return 0;
		}
	}
	x3Add(b: any) {
		throw util.badOperand(b);
	}
	x3Sub(b: any) {
		throw util.badOperand(b);
	}
	x3Mul(b: any) {
		throw util.badOperand(b);
	}
	x3Div(b: any) {
		throw util.badOperand(b);
	}
	x3Mod(b: any) {
		throw util.badOperand(b);
	}
	x3Pow(b: any) {
		throw util.badOperand(b);
	}
	x3Xor(b: any) {
		throw util.badOperand(b);
	}
	x3Abs() {
		throw util.badTypeConversion(typeof this + ' to Blbfile');
	}
	x3Truncate(v: any) {
		throw util.badOperand(v);
	}
	x3ToSql(driver: types.Driver) {
		return driver.toSqlLob(this);
	}
	x3Clone() {
		return new Blbfile(this.value);
	}
	x3Type() {
		return 522;
	}
}

/*function fromString(s, t) {
	return new Blbfile(new Buffer(s, t === 50 ? 'binary' : 'utf8'));
}*/

export function fromBase64(s: string) {
	return new Blbfile(new Buffer(s, 'base64'));
}

export const functions = {
	TOBLBFILE: {
		count: 2,
		fn(c: any, t: any) {
			c = util.x3ToString(c, true);
			if (typeof t !== 'number') throw util.badOperand(t);
			return new Blbfile(new Buffer(c, t === 50 ? 'binary' : 'utf8'));
		}
	},
	TOCLBFILE: {
		count: 2,
		fn(b: any, t: any) {
			if (!util.x3IsBlbfile(b)) throw util.badOperand(b);
			if (typeof t !== 'number') throw util.badOperand(t);
			return new Clbfile(b.value.toString(t === 50 ? 'binary' : 'utf8'));
		}
	},
	/*
 TOBASE64: {
 	count: 1,
 	fn(b) {
 		if (util.x3IsBlbfile(b)) return b.x3ToBase64();
 		b = util.x3ToString(b, true);
 		return fromString(b).x3ToBase64();
 	}
 },
 FROMBASE64: {
 	count: 1,
 	fn(c) {
 		c = util.x3ToString(c, true);
 		return fromBase64(c);
 	}
 },
 */
	B64DECODE: {
		count: 2,
		fn(clb: any, blb: any) {
			const str = util.x3ToString(clb, true);
			if (!util.x3IsBlbfile(blb)) throw util.badOperand(blb);
			blb.value = new Buffer(str, 'base64');
			return blb.value.length;
		}
	},
	B64ENCODE: {
		count: 2,
		fn(blb: any, clb: any) {
			if (!util.x3IsBlbfile(blb)) throw util.badOperand(blb);
			if (!util.x3IsClbfile(clb)) throw util.badOperand(clb);
			clb.value = blb.value.toString('base64');
			return clb.value.length;
		}
	}
};
