import { _ } from 'streamline-runtime';
import { config } from '../../util/nodeconfig';
import * as tpes from './types';
import * as util from './util';
import * as basic from './basic';
import * as tinteger from './tinteger';
import * as bcd from './tbcd';
import * as date from './tdate';
import * as datetime from './tdatetime';
import * as flowControl from './flowControl';
import * as tuuid from './tuuid';
import { Blbfile } from './tblbfile';
import { Clbfile } from './tclbfile';
import { X3Error } from './errors';
import * as tdouble from './tdouble';
import { Supervisor } from '../../supervisor/supervisor';
const glob = require('streamline-runtime').globals;
const tracerJs = require('syracuse-core').getTracer("etna.engine");
export const constants = {
	CST_ATRUE: 1,
	CST_AFALSE: 0,
	CST_ALASTPOS: -1,
	CST_AFIRSTPOS: 0,
	CST_ANOTDEFINED: -1,
	CST_UTF8: 0,
	CST_ASCII: 50,
	CST_UCS2: 122
};

export function clone(v: any) {
	return v !== null && v.x3Clone && v.x3Clone() || v;
};

export function initStack(superv: Supervisor) {
	const cx = {
		globals: {
			values: util.any({
				$exported: true,
			}),
			types: {} as any
		},
		sys: {
			values: {} as any,
			types: {} as any,
		},
		tables: {} as any,
		gclass: {} as any,
		superv: superv,
		loginName: process.env.USER || "<unknown>",
		// for now
		// seq file stuff
		files: {} as any,
		messages: superv.engineErrMess
	};

	function declVar(dict: tpes.VariableDict, name: string, type: string, value: any) {
		dict.values[name] = value;
		dict.types[name] = type;
	}

	superv && superv.constants && Object.keys(superv.constants).forEach(constant => {
		var type: string;
		const v = superv.constants[constant];

		if (typeof v == "number") type = "CI";
		else if (typeof v == "string") type = "CS";

		else if (util.x3IsDate(v)) type = "CD";

		else if (util.x3IsDatetime(v)) type = "CE";

		else if (util.x3IsBCD(v)) type = "CN";

		else if (util.x3IsUuid(v)) type = "CZ";
		if (type) declVar(cx.globals, constant, type, superv.constants[constant]);
	});

	declVar(cx.sys, 'ADXCPW', 'CS64', 'CRYPT:tgrseQksgrTxure');
	declVar(cx.sys, 'ADXCTX', 'CS', '');
	declVar(cx.sys, 'ADXCUS', 'CS24', 'user');
	declVar(cx.sys, 'ADXDBC', 'CS127', 'INPDBG');
	declVar(cx.sys, 'ADXDBO', 'CS127', 'INIDBG');
	declVar(cx.sys, 'ADXDBX', 'CS127', 'ENDDBG');
	declVar(cx.sys, 'ADXDCS', 'VI', 1950); // Pivot date
	declVar(cx.sys, 'ADXDIR', 'CS254', __dirname);
	declVar(cx.sys, 'ADXDLREC', 'CI', 0);
	declVar(cx.sys, 'ADXSQLREC', 'CI', 0);
	declVar(cx.sys, 'ADXDPG', 'CS127', 'DEBUGGER');
	declVar(cx.sys, 'ADXDWEEK', 'CI', 0);
	declVar(cx.sys, 'ADXFMT', 'CS', [1, exports.types["S"].def, ['##', '5#', '9#', '9.2', '5.2', '9.2', 'X', 'DD[/]MM[/]YYYYYY[-]MM[-]DD[T]hh[:]mm[:]ss[Z]'], 0, 7]);
	declVar(cx.sys, 'ADXFMT2', 'CS', [1, exports.types["S"].def, ['D:DD[/]MM[/]YYYY', 'D:DD[ ]DD[ ]MMMMMMMMMM[ ]YYYY', 'D:hh[:]mm', 'D:hh[:]mm[:]ss', 'D:DD[/]MM[/]YYYY[ ]hh[:]mm', 'D:DD[ ]MMMMMMMMMM[ ]YYYY[ ]hh[:]mm[:]ss', '.', ' '], 0, 7]);
	declVar(cx.sys, 'ADXFTL', 'CI', 20);
	declVar(cx.sys, 'ADXGTB', 'CJ', 0);
	declVar(cx.sys, 'ADXIFS', 'VS', ''); //Field separator
	declVar(cx.sys, 'tab$', 'VS', '\t');
	declVar(cx.sys, 'ADXIRS', 'VS2', '\n'); //Record separator
	declVar(cx.sys, 'ADXIUM', 'VI', 0); //Character set
	declVar(cx.sys, 'ADXKPG', 'CS', 'CALCULETTE');
	declVar(cx.sys, 'ADXKSP', 'CS', 'CALCULETTE');
	declVar(cx.sys, 'ADXLIG', 'CJ', 200);
	declVar(cx.sys, 'ADXLOG', 'CI', 0);
	declVar(cx.sys, 'ADXMBM', 'CI', 512);
	declVar(cx.sys, 'ADXMDA', 'VI', 0); //Angular mode
	declVar(cx.sys, 'ADXMOTHER', 'CS13 ', superv.folderName);
	declVar(cx.sys, 'ADXMPGPRO', 'CS127', 'ACTLMASKFOL');
	declVar(cx.sys, 'ADXMPGTRT', 'CS127', 'GESECRAN');
	declVar(cx.sys, 'ADXMPR', 'CI', 200);
	declVar(cx.sys, 'ADXMSO', 'VI', 10);
	declVar(cx.sys, 'ADXMTO', 'CI', 200);
	declVar(cx.sys, 'ADXMUA', 'CI', 2047);
	declVar(cx.sys, 'ADXMXL', 'CJ', 250);
	declVar(cx.sys, 'ADXOVF', 'CS', 'VALID_ONDEMAND');
	declVar(cx.sys, 'ADXOVS', 'CS', 'ACLAVAL');
	declVar(cx.sys, 'ADXROB', 'CS254', 'ECR');
	declVar(cx.sys, 'ADXSAX', 'CS254', '');
	declVar(cx.sys, 'ADXSCA', 'VS', '?? .#*???');
	declVar(cx.sys, 'ADXSES', 'CI', 1);
	// declVar(cx.sys,'ADXSQLREC','CI',0);
	declVar(cx.sys, 'ADXTCT', 'CS254', 'APLCOM');
	declVar(cx.sys, 'ADXTLK', 'CS254', 'APLLCK');
	declVar(cx.sys, 'ADXTMS', 'CS254', 'APLSTD');
	declVar(cx.sys, 'ADXTRL', 'CS', 'ATRIOPE');
	declVar(cx.sys, 'ADXTRO', 'CS2', '');
	declVar(cx.sys, 'ADXTRP', 'CS254', 'ATRIFIL');
	// declVar(cx.sys, 'ADXTUL', 'CS', superv.ADXTUL);
	// declVar(cx.sys, 'ADXTUT', 'CS', superv.ADXTUT);
	// declVar(cx.sys, 'ADXTUC', 'CS', superv.ADXTUC);
	declVar(cx.sys, 'ADXUPREC', 'CI', 0);
	declVar(cx.sys, 'ADXUSR', 'CS', process.env.USER || "AQCORE");
	declVar(cx.sys, 'ADXWRB', 'CI', 1);
	declVar(cx.sys, 'DATESYST', 'VD', date.today(false));
	declVar(cx.sys, 'LOCKWAIT', 'VI', 0);
	declVar(cx.sys, 'FSTAT', 'VI', 0);
	declVar(cx.sys, 'INDCUM', 'CI', 0);
	declVar(cx.sys, 'INDICE', 'VI', 0);
	declVar(cx.sys, 'MESSNAME', 'VS', "FRA");
	declVar(cx.sys, 'BASEURL', 'VS', superv.baseUrl);
	declVar(cx.sys, 'COLLABORATIONBASEURL', 'VS', superv.collaborationUrl);

	const frame: tpes.Frame = {
		values: {},
		types: {},
		context: cx,
		loc: {
			file: module.id,
			line: 0
		},
		prog: {} as any,
		stackLevel: 0,
		loopLevel: 0
	};

	frame.sub = frame;
	// TODO: investigate how data (F class) is managed - global for now
	frame.dicts = [frame, cx.globals, cx.sys, cx.tables];
	frame.tablePos = 2;

	glob.context.x3frame = frame;
};

export function x3Val(val: any) {
	if (val !== undefined) return typeof val === 'boolean' ? val ? constants.CST_ATRUE : constants.CST_AFALSE : val;
}

export const functions = {
	VARMODE: {
		count: 0
	}
};

export interface VariableType {
	name: string;
	value: number;
	jsonDefaultType: string;
	default: any;
	def?: any; // investigate later ??
	set(field: string, type: string, val: any): any;
};

export const types: { [letter: string]: VariableType } = {
	B: {
		name: 'BLBFILE',
		value: 522,
		jsonDefaultType: "application/x-binary",
		get default() { return new Blbfile(new Buffer(0)) },
		set(field, type, val) {
			return val = util.x3IsBlbfile(val) ? val : new Blbfile(val);
		}
	},
	D: {
		name: 'DATE',
		value: 3,
		jsonDefaultType: "application/x-date",
		default: date.make(0, 0, 0),
		set(field, type, val) {
			try {
				return val.x3ToDate();
			} catch (e) {
				throw e.errn ? e : new X3Error(10, "invalid value '" + val + "' assigned to '" + field + "'");
			}
		}
	},
	E: {
		name: 'DATETIME',
		value: 526,
		jsonDefaultType: "application/x-datetime",
		default: datetime.NULL,
		set(field, key, val) {
			try {
				return val.x3ToDatetime();
			} catch (e) {
				throw e.errn ? e : new X3Error(10, "invalid value '" + val + "' assigned to '" + field + "'");
			}
		}
	},
	I: {
		name: 'INTEGER',
		value: 4,
		jsonDefaultType: "application/x-integer",
		default: 0,
		set(field, key, val) {
			try {
				val = val.x3ToInteger();
			} catch (e) {
				throw e.errn ? e : new X3Error(10, "invalid value '" + val + "' assigned to '" + field + "'");
			}
			if (Math.abs(val) >= tinteger.MAX_INT) throw new X3Error(50, "invalid value '" + val + "' assigned to '" + field + "'");
			return val;
		}
	},
	J: {
		name: 'SHORTINT',
		value: 2,
		jsonDefaultType: "application/x-integer",
		default: 0,
		set(field, key, val) {
			try {
				val = val.x3ToInteger();
			} catch (e) {
				if (typeof val === 'boolean') {
					val = val ? constants.CST_ATRUE : constants.CST_AFALSE;
				} else {
					throw e.errn ? e : new X3Error(10, "invalid value '" + val + "' assigned to '" + field + "'");
				}
			}
			if (val < tinteger.MIN_SHORTINT || val > tinteger.MAX_SHORTINT) throw new X3Error(13, "invalid value '" + val + "' assigned to '" + field + "'");
			return val;
		}
	},
	N: {
		name: 'DECIMAL',
		value: 7,
		jsonDefaultType: "application/x-decimal",
		get default() { return bcd.fromDouble(0) },
		set(field, type, val) {
			try {
				return val.x3ToBCD();
			} catch (e) {
				throw e.errn ? e : new X3Error(10, "invalid value '" + val + "' assigned to '" + field + "'");
			}
		}
	},
	S: {
		name: 'CHAR',
		value: 10,
		jsonDefaultType: "application/x-string",
		default: "",
		set(field, type, val) {
			try {
				val = val.x3ToString();
			} catch (e) {
				throw e.errn ? e : new X3Error(10, "invalid value '" + val + "' assigned to '" + field + "'");
			}
			return type.length > 2 ? val.substring(0, parseInt(type.substring(2))) : val;
		}
	},
	T: {
		name: 'CLBFILE',
		value: 523,
		jsonDefaultType: "text",
		get default() { return new Clbfile("") },
		set(field, key, val) {
			try {
				return val.x3ToClbfile();
			} catch (e) {
				throw e.errn ? e : new X3Error(10, "invalid value '" + val + "' assigned to '" + field + "'");
			}
		}
	},
	/*	U: {
 	name: 'SCHAR',
 	value: 10,
 	def: ""
 },*/
	V: {
		name: 'TINYINT',
		value: 1,
		jsonDefaultType: "application/x-integer",
		default: 0,
		set(field, key, val) {
			try {
				val = val.x3ToInteger();
			} catch (e) {
				throw e.errn ? e : new X3Error(10, "invalid value '" + val + "' assigned to '" + field + "'");
			}
			if (val < tinteger.MIN_TINYINT || val > tinteger.MAX_TINYINT) throw new X3Error(13, "invalid value '" + val + "' assigned to '" + field + "'");
			return val;
		}
	},
	W: {
		name: 'DOUBLE',
		jsonDefaultType: "application/x-number",
		value: 6,
		get default() { return new tdouble.Double(0) },
		set(field, type, val) {
			try {
				return val.x3ToDouble();
			} catch (e) {
				throw e.errn ? e : new X3Error(10, "invalid value '" + val + "' assigned to '" + field + "'");
			}
		}
	},
	X: {
		name: 'ANY',
		value: -1,
		jsonDefaultType: "",
		default: null,
		set(field, key, val) {
			return val;
		}
	},
	Y: {
		name: 'INSTANCE',
		value: 524,
		jsonDefaultType: "",
		default: null,
		set(field, key, val) {
			return val;
		}
	},
	Z: {
		name: 'UUIDENT',
		value: 525,
		jsonDefaultType: "application/x-string",
		get default() { return tuuid.NULL },
		set(field, key, val) {
			try {
				return val.x3ToUuid();
			} catch (e) {
				throw e.errn ? e : new X3Error(10, "invalid value '" + val + "' assigned to '" + field + "'");
			}
		}
	}
};

exports.typeLetters = Object.keys(exports.types).reduce((r, l) => {
	r[types[l].value] = l;
	return r;
}, {} as any);
(function () {
	for (var i = 1; i <= 255; i++) exports.typeLetters[10 + i] = 'S';
})();

// storage classes
export const dictClasses: { [name: string]: string } = {
	VARIABLE: 'A',
	VALUE: 'B',
	CONST: 'C',
	DEFAULT: 'D',
	GLOBAL: 'V',
	LOCAL: 'L'
};

type Range = number[];

// + F (table), M (mask) and S (sequential) that don't have keywords
function autoType(dict: tpes.VariableDict, field: string, v: any) {
	// Let's resolve the proper type :
	if (Array.isArray(v)) v = v[1];
	if (typeof v == "number") dict.types[field] = "BI";
	else if (typeof v == "string") dict.types[field] = "BS";
	else if (util.x3IsDate(v)) dict.types[field] = "BD";
	else if (util.x3IsDatetime(v)) dict.types[field] = "BE";
	else if (util.x3IsBCD(v)) dict.types[field] = "BN";
	else if (util.x3IsUuid(v)) dict.types[field] = "BZ";
	else if (util.x3IsDouble(v)) dict.types[field] = "BW";
	else if (util.x3IsBlbfile(v)) dict.types[field] = "BB";
	else if (util.x3IsClbfile(v)) dict.types[field] = "BT";
	else if (util.x3IsInstance(v)) dict.types[field] = "BY";
}

export const vOperations: {
	GET: tpes.VariableOp;
	SET: tpes.VariableOp;
	GETINFO: tpes.VariableOp;
	RAZ: tpes.VariableOp;
	[name: string]: tpes.VariableOp 
} = {
	GET: {
		fn(frame, dict, field, val, silent, strict) {
			//tracerJs.debug && tracerJs.debug("GET " + field + " type:" + dict.types[field]);
			if (dict.types[field] != "CX") {
				var key = dict.types[field];
				if (key && /^[cb]$/.test(key[0])) {
					// Let's copy data of the array :
					var prevArr = dict.values[field][2];
					var newArr: any[] = [];
					for (var i = 0; i < prevArr.length; i++) {
						newArr[i] = prevArr[i];
					}
					dict.values[field][2] = newArr;
					dict.types[field] = key[0].toUpperCase() + key.substring(1);
					tracerJs.debug && tracerJs.debug("dict.values[field] " + dict.values[field]);
				}
				return dict.values[field];
			}
			var v = dict.values[field];
			autoType(dict, field, v);
			if (Array.isArray(v)) {
				//make a copy for Values and Const and not declared
				var newtab: any[] = [];
				for (var n = 0; n < v.length; n++) {
					// copy arrays of object passed
					if (Array.isArray(v[n])) {
						var newtab2: any[] = [];
						for (var k = 0; k < v[n].length; k++) {
							newtab2[k] = v[n][k];
						}
						newtab[n] = newtab2;
					} else {
						newtab[n] = v[n];
					}
				}
				if (newtab[4] !== null) newtab[4] = newtab[4] - newtab[3];
				newtab[3] = 0;
				dict.values[field] = v = newtab;
			}
			return v;
		},
		error(_,  frame, field, val, silent, strict) {
			if (silent) return;
			tracerJs.debug && tracerJs.debug("frame:" + JSON.stringify(frame.values));
			throw new X3Error(6, "undefined variable: " + field);
		}
	},
	SET: {
		fn(frame, dict, field, val, silent, strict) {
			tracerJs.debug && tracerJs.debug("SET " + field + " type:" + dict.types[field] + " val:" + val);
			const type = dict.types[field];

			if (type === undefined) {
				throw new X3Error(62, frame.prog.name + ": '" + field + "' not declared");
			} else if (type[0] === 'C') {
				throw new X3Error(62, frame.prog.name + ": '" + field + "' Variable not modifiable");
			} else if (!Array.isArray(dict.values[field]) && !Array.isArray(val)) {
				return dict.values[field] = exports.types[type[1]].set(field, type, val);
			} else if (util.x3IsClbfile(val) && type[1] === 'S' && Array.isArray(dict.values[field])) {
				// Special treatment for SetLob Array with Clob
				var len = type.length > 2 ? parseInt(type.substring(2)) : 255;
				var clob = val.x3ToString();
				var arr = dict.values[field][2];
				var end = clob.length;
				var pos = 0;

				while (pos < end) {
					arr.push(clob.substring(pos, pos + len));
					pos += len;
				}
				return dict.values[field];
			}
			return dict.values[field] = val;
		},
		error(_,  frame, field, val, silent, strict) {
			if (strict || frame.loc.strict) {
				throw new X3Error(6, "undefined variable: " + field);
			} else {
				frame.values[field] = val;
				frame.types[field] = "L" + (typeof val == 'number' ? 'I' : 'S');
			}
		}
	},
	GETINFO: {
		fn(frame, dict, field) {
			const type = dict.types[field];
			const vsz = function () {

				switch (type[1]) {
					case "I":
						return 4;
					case "J":
						return 2;
					case "V":
						return 1;
					case "S":
						var l = parseInt(type.substr(2)) + 1;
						return l * 2;
					case "B":
					case "T":
						var l = parseInt(type.substr(2));
						l = 1 << 10 + l;
						return l;
					case "D":
						return type[0] === " " && dict !== glob.context.x3frame.context.sys ? 3 : 4;
					case "Z":
						return 16;
					case "E":
						return 8;
					case "N":
						return 20;
					case "W":
						return 8;
					default:
						return undefined;
				}
			};

			return {
				"dictionnary": dict,
				"vdeclaration": type[0],
				"vtype": type[1],
				"vlength": "STB".lastIndexOf(type[1]) >= 0 ? parseInt(type.substr(2)) : undefined,
				"vstring": type,
				"vsize": vsz(),
				"vname": field
			};
		},
		error(_, frame, field) {
			throw new X3Error(6, "undefined variable: " + field);
		}
	},
	RAZ: {
		fn(frame, dict, field, val, silent, strict) {
			if (Array.isArray(dict.values[field])) {
				var arr = dict.values[field];
				arr[2] = [];
				dict.values[field] = arr;
			} else if (dict.types[field]) {
				dict.values[field] = exports.clone(exports.types[dict.types[field][1]].default);
				// console.log("RAZ "+field+" value:"+dict.values[field]);
			}
			return 0;
		},
		error(_,  frame, field, val, silent, strict) {
			throw new X3Error(6, "undefined variable: " + field);
		}
	},
	TYPE: {
		fn(frame, dict, field, val, silent, strict) {
			if (dict.types[field] === "CX") autoType(dict, field, dict.values[field]);
			var type = exports.types[dict.types[field][1]].value;
			if (dict.types[field][1] == 'S' && dict.types[field].length > 2) type += parseInt(dict.types[field].substring(2), 10);
			return type;
		},
		error(_,  frame, field, val, silent, strict) {
			return -1;
		}
	},
	DIM: {
		fn(frame, dict, field, dim, silent, strict) {
			//!console.log("DIM:"+field+" type:"+dict.types[field]+" dim:"+dim);
			if (dict.types[field] === "CX") autoType(dict, field, dict.values[field]);
			const a = dict.values[field];

			if (a === undefined) return -1;
			const d = dim !== undefined ? dim : 1;
			//tracerJs.debug && tracerJs.debug("DIM: " + JSON.stringify(a) + " dim=" + dim);
			// basic values are considered to be arrays of 1 elt.

			if (!Array.isArray(a)) return d === -1 ? 0 : 1;
			const ndims = a[0];

			if (d === 0) return ndims;
			if (!(d >= -ndims && d <= ndims)) throw new X3Error(50, d);
			const sliced = a.length === 3 + 4 * a[0];
			//tracerJs.debug && tracerJs.debug("DIM: " + JSON.stringify(a) + " ndims=" + ndims + " sliced=" + sliced);

			if (sliced) {
				if (d > 0) return a[4 + 2 * (ndims + (d - 1))];
				else return a[3 + 2 * -(d + 1)];
			} else {
				if (d > 0) {
					if (a[4 + 2 * (d - 1)] === null) {
						return dict.types[field][0] === 'B' && a[2].length ? a[2].length : 32767;
					} else {
						return a[4 + 2 * (d - 1)] - a[3 + 2 * (d - 1)] + 1;
					}
				} else return a[3 + 2 * -(d + 1)];
			}
		},
		error(_,  frame, field, val, silent, strict) {
			return -1;
		}
	},
	KILL: {
		fn(frame, dict, field, val, silent, strict) {
			dict.values[field] = undefined;
			dict.types[field] = undefined;
			return 0;
		},
		error(_,  frame, field, val, silent, strict) {
			throw new X3Error(6, "undefined variable: " + field);
		}
	}
};

function handleError(ex: Error) {
	if (ex instanceof X3Error) throw ex;
	throw new X3Error(26, ex.message, ex.stack);
}

export const instructions = {
	DEFAULT(scope: void, exp: void) {
		return function defaultfn$do(_: _) {};
	},
	CLALEV(arg: tpes.Expression<any>) {
		return function clalev$do(_: _): any {
			const a = arg(_, null, undefined, true);
			const frame = glob.context.x3frame;

			if (!a) return 0;
			if (typeof a === "number") {
				var abbr = Object.keys(frame.context.table)[a - 1];
				if (abbr) return abbr;
				else throw new X3Error(10, "clalev number out of range: " + a);
			} else {
				if (!a.values) throw new X3Error(10, "clalev argument is not a class");
				return 1;
			}
		};
	},
	V(field: string): tpes.Expression<any> {
		const consts = util.any(constants);
		if (typeof consts[field] !== 'undefined') {
			var fn: tpes.Expression<number> = function v$do(_: _) {
				return consts[field];
			};
			fn.value = consts[field];
			return fn;
		}
		return function v$do(_,  operation, val, silent, strict) {
			const frame = glob.context.x3frame;
			const fdo = operation ? operation : vOperations.GET;
			// optimize read of local variable
			//if (!operation && (v = frame.values[field]) !== undefined) return v;

			const dicts = frame.dicts;

			for (var i = 0, len = dicts.length; i < len; i++) {
				var dict = dicts[i];
				if (dict === frame.context.tables) {

					var keys = Object.keys(dict);
					//for (var j = 0; !found && j < keys.length; j++) {
					for (var j = 0; j < keys.length; j++) {
						var abb = keys[j];
						var values = dict[abb].values;
						if (dict[abb].values[field]) {
							dict = dict[abb];
							return fdo.fn(frame, dict[abb], field, val, silent, strict);
						}
					}
				} else if (dict.values[field] !== undefined) {
					return fdo.fn(frame, dict, field, val, silent, strict);
				}
			}
			return fdo.error(_, frame, field, val, silent, strict);
		};
	},
	TYPE(letter: string, field: string) {
		var fv: tpes.Expression<any>;
		if (letter.length) fv = instructions.CV(letter, '', field);
		else fv = instructions.V(field);
		return function typev$do(_: _) {
			return fv(_, exports.vOperations.TYPE);
		};
	},
	DIM(letter: string, field: string, rhs: tpes.Expression<number>) {
		var fv: tpes.Expression<number>;
		if (letter.length) fv = exports.instructions.CV(letter, '', field);
		else fv = exports.instructions.V(field);
		return function dim$do(_: _) {
			if (rhs !== undefined) return fv(_, exports.vOperations.DIM, rhs.value !== undefined ? rhs.value : rhs(_));
			return fv(_, exports.vOperations.DIM);
		};
	},
	DYNTYPE(arg: tpes.Expression<any>) {
		return function dyntype$do(_: _) {
			const val = arg(_);

			return val && val.x3Type ? val.x3Type() : -1;
		};
	},
	DYNDIM(arg: tpes.Expression<any>) {
		return function dyndim$do(_: _) {
			try {
				var val = arg(_);
				return val && val.x3Dim ? val.x3Dim() : 1;
			} catch (e) {
				// Has to support syntanx like DIM(AINSTANCE.ACTX.LAN) where ACTX doesn't exist
				console.error(e.message);
			}
			return 0;
		};
	},
	CV(letter: string, abbrev: string, field: string, silent?: boolean): tpes.Expression<any> {
		const consts = util.any(constants);
		if (typeof consts[field] !== 'undefined') {
			var fn: tpes.Expression<any> = function v$do(_: _) {
				return consts[field];
			};
			fn.value = consts[field];
			return fn;
		}

		letter = letter == 'D' ? 'L' : letter;
		if (config.etna.optimize) {
			if (letter == 'L') {
				return function cv$do(_,  operation, val, silent, strict) {
					const frame = glob.context.x3frame;
					const fdo = operation ? operation : exports.vOperations.GET;

					if (frame.values[field] !== undefined) return fdo.fn(frame, frame, field, val, silent, strict);
					else return fdo.error(_, frame, field, val, silent, strict);
				};
			} else if (letter == 'V') {
				return function cv$do(_,  operation, val, silent, strict) {
					const frame = glob.context.x3frame;
					const fdo = operation ? operation : exports.vOperations.GET;

					if (frame.context.globals.values[field] !== undefined) return fdo.fn(frame, frame.context.globals, field, val, silent, strict);
					else return fdo.error(_, frame, field, val, silent, strict);
				};
			} else if (letter == 'S') {
				return function cv$do(_,  operation, val, silent, strict) {
					const frame = glob.context.x3frame;
					const fdo = operation ? operation : exports.vOperations.GET;

					if (frame.context.sys.values[field] !== undefined) return fdo.fn(frame, frame.context.sys, field, val, silent, strict);
					else return fdo.error(_, frame, field, val, silent, strict);
				};
			}
		}
		return function cv$do(_,  operation, val, silent, strict) {
			const frame = glob.context.x3frame;
			const fdo = operation ? operation : exports.vOperations.GET;

			var dict: tpes.VariableDict;

			switch (letter) {
				case 'L':
					dict = frame;
					break;
				case 'V':
					dict = frame.context.globals;
					break;
				case 'S':
					dict = frame.context.sys;
					break;
				case 'G':
					dict = frame.context.gclass[abbrev || frame.abbrev];
					if (!dict) throw new X3Error(7, 'unknown class: [G:' + (abbrev || frame.abbrev) + ']');
					break;
				case 'F':
				case '?':
					dict = frame.context.tables;

					if (abbrev) {
						dict = util.any(dict)[abbrev];
						if (!dict) {
							if (operation) {
								val.abbrev = abbrev;
								return frame.context.tables[abbrev] = val;
							} else if (silent) return null;else throw new X3Error(7, 'unknown class: [' + letter + ':' + abbrev + ']');
						}
					} else {
						var found: boolean;
						var keys = Object.keys(dict);
						for (var i = 0; !found && i < keys.length; i++) {
							var abb = keys[i];
							var d = util.any(dict)[abb];
							found = d.values[field] !== undefined;
							if (found) dict = d;
						}
						if (!found) {
							if (silent) return null;
							else throw new X3Error(7, 'unknown class: [' + letter + ':' + abbrev + ']');
						}
					}
					break;
				default:
					throw new X3Error(26, 'unknown class letter: [' + letter + ']');
			}

			if (!dict) {
				if (false && frame.tryingSql) {
					// REVIEW!!!
					var err = new Error("trying sql (ignore)");
					util.any(err).tooComplexForSql = true;
					throw err;
				}
			} else {
				if (dict.values[field] !== undefined) return fdo.fn(frame, dict, field, val, silent, strict);
				else return fdo.error(_, frame, field, val, silent, strict);
			}
		};
	},
	DECL(key: string, field: string, using: string, lens0: tpes.Expression<number[]>, ranges0: tpes.Expression<Range[]>) {
		key = key[0] == 'D' ? 'L' + key.substring(1) : key;
		const letter = key[0];
		const t = key[1];
		const def = exports.types[t].default;

		if (config.etna.optimize && lens0 === undefined && ranges0 === undefined) {
			if (letter === "V") return function decl$do(_: _) {
				glob.context.x3frame.context.globals.values[field] = exports.clone(def);
				glob.context.x3frame.context.globals.types[field] = key;
			};else if (letter === "L") return function decl$do(_: _) {
				glob.context.x3frame.values[field] = exports.clone(def);
				glob.context.x3frame.types[field] = key;
			};
		}

		return function decl$do(_: _) {
			const frame = glob.context.x3frame;

			var lens = lens0,
			    ranges = ranges0;
			const letter = key[0];
			const dict = letter === 'V' ? frame.context.globals : frame;
			const values = dict.values;

			if (lens) {
				if (!/^[STB]$/.test(t)) {
					ranges = util.any(lens);
					lens = undefined;
				} else {
					key += lens(_)[0] || "";
				}
			}
			// Set the proper type :
			dict.types[field] = key;

			var arr: any[];
			if (/^[LV]$/.test(letter)) values[field] = undefined; // Kill : the value		
			else arr = values[field]; // for arrays :	

			var rangesVals: Range[];
			if (ranges) {
				rangesVals = ranges(_);
			} else if (arr && Array.isArray(arr)) {
				rangesVals = [[0, null]];
			}

			if (rangesVals && values[field] && values[field].lines) {
				// case instanceCollection				
				arr = [rangesVals.length, def, values[field].lines];
			}

			// ignore using (for now)
			if (rangesVals) {
				var ndims = rangesVals.length;
				var dim: number;
				var range: any;
				if (arr === undefined) {
					// Create an empty array
					arr = [ndims, def, []];

					for (dim = 0; dim < ndims; dim++) {
						range = rangesVals[dim];
						if (typeof range === 'number') range = [0, range - 1]; // for Value Integer A(6) -> A(0..5)
						arr = arr.concat(range);
					}
					values[field] = arr;
				} else {
					if (ndims != arr[0]) {
						throw new X3Error(26, "dimensions mismatch for '" + field + "': expected " + ndims + ", got " + arr[0]);
					}

					// note: array's dimensions were copied when parameter was assigned - so we can modify them :
					var sliced = arr.length === 3 + 4 * ndims;
					for (dim = 0; dim < ndims; dim++) {
						range = rangesVals[dim];
						if (range) {
							if (typeof range === 'number') range = [0, range - 1]; // for Value Integer A(6) -> A(0..5)
							var decal = range[0] - arr[3 + 2 * dim];
							arr[3 + 2 * dim] = range[0];
							if (arr[4 + 2 * dim] !== null) {
								arr[4 + 2 * dim] = arr[4 + 2 * dim] + decal;
							}
							//
							if (range[1]) {
								var count = sliced ? arr[4 + 2 * (ndims + dim)] : arr[4 + 2 * dim];
								if (count !== range[1]) throw new X3Error(26, "range mismatch for '" + field + "': expected " + count + ", got " + range[1]);
							}
						}
					}
					// Make a copy of array's data for Values and Const
					if (/^[CB]$/.test(key[0]) && arr && Array.isArray(arr)) {
						// mark the field as 'has to be copied' is any instruction try access to it:
						// B => b !
						// C => c !
						// Be carefull that INDEX performs a GET first...
						dict.types[field] = key[0].toLowerCase() + key.substring(1);
					}
				}
			} else if (/^[LV]$/.test(letter)) {
				// Set the type's default value
				values[field] = exports.clone(def);
			}
		};
	},
	CA(field: string, exps: tpes.Expression<any>[]) {
		const decl = exports.instructions.DECL('LX', field, basic.instructions.A([basic.instructions.C(exps.length)]));
		const aexps = basic.instructions.A(exps);

		return function ca$do(_: _) {
			const frame = glob.context.x3frame;

			decl(_);
			const val = frame.values[field];
			const vals = aexps(_);

			val[2] = vals;
		};
	},
	GET(obj: any, prop: string) {
		return function get$do(_: _) {
			//console.error("GET " + prop);
			//console.error(obj);
			return obj[prop];
		};
	},
	SET(lhs: tpes.Expression<any>, rhs: tpes.Expression<any>, silent?: boolean) {
		if (config.etna.optimize && typeof rhs != "function") return function set$do(_: _) {
			lhs(_, exports.vOperations.SET, rhs, silent);
		};
		return function set$do(_: _) {
			lhs(_, exports.vOperations.SET, rhs.value !== undefined ? rhs.value : rhs(_), silent);
		};
	},
	APPEND(lhs: tpes.Expression<any>, rhs: tpes.Expression<any>, silent?: boolean) {
		return function append$do(_: _) {
			lhs(_, exports.vOperations.SET, lhs(_).x3Add(rhs.value !== undefined ? rhs.value : rhs(_)), silent);
		};
	},
	ASSIGN(lhs: tpes.Expression<any>, rhs: tpes.Expression<any>, silent?: boolean) {
		return function assign$do(_: _) {
			const str = util.x3ToString(lhs(_), true);
			const lhs2 = require('./evaluate').compile(str);

			lhs2(_, exports.vOperations.SET, rhs.value !== undefined ? rhs.value : rhs(_), silent, true);
			/*
   var target = lhs(_).toUpperCase();
   var value = rhs.value !== undefined ? rhs.value : rhs(_);
   var args;
   var beg = target.indexOf('(');
   if (beg > 0) {
   	args = target.substring(beg + 1, target.lastIndexOf(')')).split(',').reduce((result, arg) => {
   		result.push(basic.instructions.C(parseInt(arg)));
   		return result;
   	}, []);
   	target = target.substring(0, beg);
   }
   var fV = exports.instructions.V(target);
   if (args) {
   	var fINDEX = require('./arrays').instructions.INDEX(fV, args);
   	fINDEX(_, true, value);
   } else {
   	//strict = true
   	fV(_, exports.vOperations.SET, value, silent, true);
   }
   */
		};
	},
	RAZ(exps: tpes.Expression<any>[]) {
		return function raz$do(_: _) {
			exps.forEach_(_, (_, exp) => {
				exp(_, exports.vOperations.RAZ);
			});
		};
	},
	SNAP(target: tpes.Expression<any>): tpes.Expression<void> {
		return function dot$do(_,  assign, val, silent) {
			const t = target(_);

			if (assign) throw new X3Error(155, "");
			else {
				return t.snapshot();
			}
		};
	},
	PROP(target: tpes.Expression<any>, name: string): tpes.Expression<any> {
		return function dot$do(_,  assign, val, silent) {
			const t = target(_);

			tracerJs.debug && tracerJs.debug("PROP:" + name + " assign:" + assign + " val:" + val);

			if (!t || !(t.class || t.$exported)) {
				tracerJs.error && tracerJs.error("PROP:" + name + " assign:" + assign + " val:" + val);
				throw new X3Error(26, "invalid property target: " + JSON.stringify(t));
			}
			try {
				if (assign) {
					if (typeof t.set === "function") return x3Val(t.set(_, name, val));
					else return t[name] = val;
				} else {
					if (typeof t.get === "function") return x3Val(t.get(_, name, glob.context.debug));
					else {
						var v = t[name];
						if (v === undefined) {
							Object.keys(t).forEach(p => {
								console.error("t." + p);
							});
							throw new X3Error(26, "missing property in built-in object: " + name);
						}
						return v;
					}
				}
			} catch (ex) {
				tracerJs.error && tracerJs.error("PROP exception:" + JSON.stringify(ex));
				handleError(ex);
			}
		};
	},
	ATT(target: tpes.Expression<any>, property: string, attribute: string): tpes.Expression<any> {
		if (property) return function att$do(_,  assign, val, silent) {
			const t = target(_);

			tracerJs.debug && tracerJs.debug("ATT attribut:" + attribute + " property:" + property + " assign:" + assign + " val:" + val);

			if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid property target: " + t);
			try {
				if (assign) {
					if (typeof t.setPropertyAttribute === "function") {
						return x3Val(t.setPropertyAttribute(_, property, attribute, val));
					}
				} else {
					if (typeof t.getPropertyAttribute === "function") {
						return x3Val(t.getPropertyAttribute(_, property, attribute));
					}
				}
			} catch (ex) {
				handleError(ex);
			}
		};else return function att$do(_,  assign, val, silent) {
			const t = target(_);

			tracerJs.debug && tracerJs.debug("ATT attribut:" + attribute + " property:" + property + " assign:" + assign + " val:" + val);

			if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid target: " + t);
			try {
				if (assign) {
					if (typeof t.setAttribute === "function") return t.setAttribute(attribute, val);
				} else {
					if (typeof t.getAttribute === "function") {
						return x3Val(t.getAttribute(attribute));
					}
				}
			} catch (ex) {
				handleError(ex);
			}
		};
	},
	AGETATTR(target: tpes.Expression<any>, property: string, attribute: tpes.Expression<string>): tpes.Expression<any> {
		if (property) return function agetattr$do(_,  silent) {
			const t = target(_);

			if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid attribute target: " + t);
			try {
				if (typeof t.getPropertyAttribute === "function") {
					return x3Val(t.getPropertyAttribute(_, property, attribute(_)));
				}
			} catch (ex) {
				handleError(ex);
			}
		};else return function agetattr$do(_,  silent) {
			const t = target(_);

			if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid attribute target: " + t);
			try {
				if (typeof t.getAttribute === "function") {
					return x3Val(t.getAttribute(attribute(_)));
				}
			} catch (ex) {
				handleError(ex);
			}
		};
	},
	ASETATTR(target: tpes.Expression<any>, property: string, attribute: tpes.Expression<string>, val: tpes.Expression<any>): tpes.Expression<void> {
		if (property) return function asetattr$do(_,  silent) {
			const t = target(_);

			if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid attribute target: " + t);
			try {
				if (typeof t.setPropertyAttribute === "function") return x3Val(t.ASETATTRPROP(_, property, attribute(_), val(_)));
			} catch (ex) {
				handleError(ex);
			}
		};else return function asetattr$do(_,  silent) {
			const t = target(_);

			if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid attribute target: " + t);
			try {
				if (typeof t.setAttribute === "function") return x3Val(t.ASETATTR(attribute(_), val(_)));
			} catch (ex) {
				handleError(ex);
			}
		};
	},
	XMET(target: tpes.Expression<any>, name: string, args: tpes.Expression<any>[]): tpes.Expression<any> {
		// fmet and callmet
		const aargs = basic.instructions.A(args);

		return function dot$do(_) {
			const t = target(_);
			// todo: review error numbers
			// if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid method target: " + t);

			if (!t) throw new X3Error(26, "invalid method target: " + t);
			try {
				var meth = t[name];
				if (t.class || t.$exported) {
					if (meth && typeof meth === "function") {
						return x3Val(meth.apply_(_, t, aargs(_), 0));
					}
					meth = t.xmet(name);
					if (meth) {
						// Support methods with variables parameters:
						return x3Val(meth.apply_(_, t, args, 0));
					}
					throw new X3Error(26, "method not found: " + name + (t.class ? " in class " + t.class.name : ""));
				} else {
					if (meth && meth.params && meth.body && typeof meth.body === 'function') {
						var frame = glob.context.x3frame;
						return x3Val(flowControl.callProg(_, meth, args, aargs(_), frame.sub.loc));
					} else throw new X3Error(26, "missing method in built-in object: " + name + " t:" + Object.keys(t));
				}
			} catch (ex) {
				handleError(ex);
			}
		};
	},
	NEW(clas: tpes.Expression<string>) {
		return function new$do(_: _) {
			const frame = glob.context.x3frame;
			const name = clas(_);

			if (!/^C_/.test(name)) throw new X3Error(33, "Invalid class name: " + name);
			const cl = frame.context.superv.load(_, 'Class', name.substring(2));

			if (!cl) throw new X3Error(26, "invalid class name: " + name); // TODO check errnum
			return cl.createInstance ? cl.createInstance(_) : cl;
		};
	},
	FREE(allocGroup: tpes.Expression<void>, isGroup: boolean) {
		return function free$do(_: _) {};
	},
	FREEZE(target: tpes.Expression<any>) {
		return function freeze$do(_: _) {
			const t = target(_);

			if (!t) throw new X3Error(26, "invalid method target: " + t);
			try {
				t.$isReadOnly = true;
			} catch (ex) {
				handleError(ex);
			}
		};
	},
	KILL(exps: tpes.Expression<any>[]) {
		return function raz$do(_: _) {
			exps.forEach_(_, (_, exp) => {
				exp(_, exports.vOperations.KILL);
			});
		};
	},
	CLA(letter: string, abbrev: string): tpes.Expression<void> {
		return function cla$do(_,  operation, val, silent, strict) {
			const frame = glob.context.x3frame;

			var dict: tpes.VariableDict;

			switch (letter) {
				case 'L':
					dict = frame;
					break;
				case 'V':
					dict = frame.context.globals;
					break;
				case 'F':
					dict = frame.context.tables[abbrev || frame.abbrev];
					break;
			}
			if (dict) {
				if (operation == exports.vOperations.KILL || operation == exports.vOperations.RAZ) {
					Object.keys(dict.values).forEach(field => {
						if (!(letter === 'F' && field === 'ROWID')) operation.fn(frame, dict, field);
					});
				} else if (letter === 'F' && operation == exports.vOperations.SET) {
					Object.keys(dict.values).forEach(field => {
						if (val.values[field] !== undefined) operation.fn(frame, dict, field, val.values[field]);
					});
				}
			} else if (!dict && operation == exports.vOperations.RAZ) {
				throw new X3Error(7, "Raz non-existent class");
			}
			return dict;
		};
	},
	AADD(target: tpes.Expression<any>, position: tpes.Expression<number>): tpes.Expression<any> {
		return function aadd$do(_) {
			const t = target(_);

			if (!t || !(t.collection || t.$exported)) throw new X3Error(26, "invalid collection : " + t);
			try {
				if (typeof t.add === "function") return t.add(_, position(_));
			} catch (ex) {
				handleError(ex);
			}
		};
	},
	ADEL(target: tpes.Expression<any>, position: tpes.Expression<number>): tpes.Expression<any> {
		return function adel$do(_) {
			const t = target(_);

			if (!t || !(t.collection || t.$exported)) throw new X3Error(26, "invalid collection : " + t);
			try {
				if (typeof t.del === "function") return t.del(_, position(_));
			} catch (ex) {
				handleError(ex);
			}
		};
	},
	ASETCOLUMNATTR(target: tpes.Expression<any>, collection: string, column: tpes.Expression<string>, 
	attribute: tpes.Expression<string>, val: tpes.Expression<any>): tpes.Expression<any> {
		return function asetcolumnattr$do(_) {
			const t = target(_);

			if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid class : " + t);
			try {
				if (typeof t.setColumnAttribute === "function") return t.setColumnAttribute(_, collection, column(_), attribute(_), val(_));
			} catch (ex) {
				handleError(ex);
			}
		};
	},
	AGETCOLUMNATTR(target: tpes.Expression<any>, collection: string, column: tpes.Expression<string>, attribute: tpes.Expression<any>): tpes.Expression<any> {
		return function agetcolumnattr$do(_) {
			const t = target(_);

			if (!t || !(t.class || t.$exported)) throw new X3Error(26, "invalid class : " + t);
			try {
				if (typeof t.getColumnAttribute === "function") {
					return x3Val(t.getColumnAttribute(_, collection, column(_), attribute(_)));
				}
			} catch (ex) {
				handleError(ex);
			}
		};
	},
	AGETTEXT(target: tpes.Expression<any>, property: string): tpes.Expression<string> {
		return function agettext$do(_) {
			const t = target(_);
			return t.AGETTEXT(_, property);
		};
	},
	ASETTEXT(target: tpes.Expression<any>, property: string, intit: tpes.Expression<string>): tpes.Expression<void> {
		return function asettext$do(_) {
			const t = target(_);
			return t.ASETTEXT(_, property, intit(_));
		};
	},
	AGETTEXTLAN(target: tpes.Expression<any>, property: string, lan: string): tpes.Expression<string> {
		return function agettextlan$do(_) {
			const t = target(_);
			return t.AGETTEXTLAN(_, property, lan);
		};
	},
	ASETTEXTLAN(target: tpes.Expression<any>, property: string, intit: string, lan: string): tpes.Expression<void> {
		return function asettextlan$do(_) {
			const t = target(_);
			return t.ASETTEXTLAN(_, property, intit, lan);
		};
	},
	AGETTEXTRA(target: tpes.Expression<any>, property: string): tpes.Expression<string> {
		return function agettextra$do(_) {
			const t = target(_);
			return t.AGETTEXTRA(_, property);
		};
	},
	AGETTEXTRALAN(target: tpes.Expression<any>, property: string, lan: string): tpes.Expression<string> {
		return function agettextralan$do(_) {
			const t = target(_);
			return t.AGETTEXTRALAN(_, property, lan);
		};
	},
	ASETTEXTRALAN(target: tpes.Expression<any>, property: string, intit: string, lan: string): tpes.Expression<void> {
		return function asettextralan$do(_) {
			const t = target(_);
			return t.ASETTEXTRALAN(_, property, intit, lan);
		};
	},
	SETINSTANCE(target: tpes.Expression<any>, abbrev: string): tpes.Expression<void> {
		return function setinstance$do(_) {
			const t = target(_);
			const frame = glob.context.x3frame;
			const table = frame.context.tables[abbrev];

			if (!table) throw new X3Error(7, "bad table abbrev: " + abbrev);
			t.setInstance(_, table.values);
		};
	}
};