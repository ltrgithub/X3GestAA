"use strict";
const X3Error = require('./errors').X3Error;
const util = require('./util');
const bcd = require('./tbcd');

class Double {
	constructor(v) {
		if (typeof v === 'number') {
			this.value = v;
		} else if (v.x3IsNumeric && v.x3IsNumeric()) {
			this.value = v.x3ToDouble().valueOf();
		} else throw util.badOperand(v);
	}
	valueOf() {
		return this.value;
	}
	x3IsNumeric() {
		return true;
	}
	x3IsEmpty() {
		throw util.badOperand(this);
	}
	x3AssertOverflow(type) {
		return true;
	}
	x3Minus() {
		return new Double(-this.value);
	}
	x3ToDouble() {
		return this;
	}
	x3ToString() {
		return "" + this.value;
	}
	x3ToBCD() {
		return new bcd.fromDouble(this.value);
	}
	x3ToInteger() {
		const sign = (this.value < 0) ? -1 : 1;
		return Math.floor(Math.abs(this.value)) * sign;
	}
	x3ToDate() {
		throw util.badOperand(this);
	}
	x3ToDatetime() {
		throw util.badOperand(this);
	}
	x3IsZero() {
		return (this.value === 0) ? true : false;
	}
	x3Compare(b) {
		if (!b.x3IsNumeric()) throw util.badOperand(b);

		const bb = b.x3ToDouble();
		var e = Math.abs(this.value);
		var d = Math.abs(bb.value);

		// compute precision  min(a, b)/10000000 or 1/100000000
		if (d < e) e = d;
		if (e === 0) e = 1;
		e /= 1000000000;
		d = this.value - bb.value;

		if ((-e < d) && (d < e)) return 0;
		else if (d >= e) return 1;
		else return -1;
	}
	x3Add(b) {
		if (b.x3IsNumeric()) {
			const bb = b.x3ToDouble();
			return new Double(this.value + bb.value);
		} else if (util.x3IsDate(b) || util.x3IsDatetime(b)) {
			return b.x3Add(this);
		} else throw util.badOperand(b);

	}
	x3Sub(b) {
		if (!b.x3IsNumeric()) throw util.badOperand(b);

		const bb = b.x3ToDouble();
		return new Double(this.value - bb.value);

	}
	x3Mul(b) {
		if (!b.x3IsNumeric()) throw util.badOperand(b);

		const bb = b.x3ToDouble();
		return new Double(this.value * bb.value);

	}
	x3Div(b) {
		if (!b.x3IsNumeric()) throw util.badOperand(b);
		if (b.x3IsZero()) throw new X3Error(53, "division by zero");
		const bb = b.x3ToDouble();
		return new Double(this.value / bb.value);

	}
	x3Mod(b) {
		if (!b.x3IsNumeric()) throw util.badOperand(b);

		const bb = b.x3ToDouble();
		return new Double(this.value % bb.value);

	}
	x3Pow(b) {
		if (!b.x3IsNumeric()) throw util.badOperand(b);

		const bb = b.x3ToDouble();
		return new Double(Math.pow(this.value, bb.value));

	}
	x3Xor(b) {
		if (!b.x3IsNumeric()) throw util.badOperand(b);

		const i = (this.x3IsZero()) ? 1 : 0;
		const j = (b.x3IsZero()) ? 1 : 0;

		return i ^ j;
	}
	x3Abs() {
		return new Double(Math.abs(this.value));
	}
	x3Truncate() {
		const sign = (this.value < 0) ? -1 : 1;
		return new Double(Math.floor(Math.abs(this.value)) * sign);
	}
	x3ToSql(driver) {
		throw new X3Error(26, "Double is an illegal type to insert");
	}
	x3Type() {
		return 6;
	}
}

exports.Double = Double;