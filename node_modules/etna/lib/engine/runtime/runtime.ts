import { _ } from 'streamline-runtime';
import * as core from 'syracuse-core';
const sys = require('util');
import { config } from '../../util/nodeconfig';
const assert = require('assert');
import * as fs from 'fs';
import { Dict, Frame, X3Function, Instruction, ProgArgs } from './types';
import * as register from '../register';
import { Parser } from '../compilers/parser';
import * as jsgen from '../compilers/jsgen';
import { version } from '../version';
import * as scriptDebugger from '../debugger/server';
import * as basic from './basic';
import * as db from './db';
import { X3Error } from './errors';
const tracer = core.getTracer("etna.engine");
const debugTracer = core.getTracer("etna.debugger");
// require jsInvoke lazily to avoid circular dependency bug
var jsInvoke : (_: _, mod: any, name: string, args: ProgArgs) => any;

const modules = ['arrays', 'basic', 'dates', 'db', 'evaluate', 'fileio', 'flowControl', 'misc', 'numbers', //
'operators', 'stats', 'strings', 'system', 'util', 'variables', //
'tbcd', 'uuid', 'tblbfile', 'tclbfile'];
import * as util from './util';
import * as variables from './variables';
const trueInst = ['ANASQL', 'ASSIGN', 'BOX', 'BREAK', 'CALL', 'CALLJS', 'CASE', 'CLOSE', 'COLUMNS', 'COMMIT', 'DBGETNA', 'DECL', 'DEFAULT', 'DELA', 'DELETE', 'END', 'EXECSQL', 'FILESQL', 'FILESYS', 'FILEVAL', 'FILTER', 'FORF', 'FORIN', 'FORSQL', 'FORV', 'FREE', 'FUNC', 'GETSEQ', 'GOSUB', 'GOTO', 'IF', 'INSA', 'IOMODE', 'KILL', 'LINK', 'LOGICCLOSE', 'LOOK', 'ONERRGO', 'OPEN', 'PROG', 'PUTSEQ', 'RAZ', 'RDSEQ', 'READ', 'RESUME', 'RET', 'REWRITE', 'ROLLBACK', 'SEEK', 'SET', 'SLEEP', 'SORTA', 'TRBEGIN', 'UPDATE', 'WHILE', 'WRITE', 'WRSEQ', 'XMET'];

function collect(key: string) {
	const api = exports['_' + key] = {} as Dict<any>;
	modules.map(name => require('./' + name)).forEach(mod => {
		mod[key] && Object.keys(mod[key]).forEach(k => {
			if (api[k]) throw new Error("duplicate definition of " + key + " " + k);
			//console.log(key + "/" + k)
			api[k] = mod[key][k];
		});
	});
}

function compile(source: string, name: string, filename: string) {
	tracer.debug && tracer.debug("compile src:" + name);

	const fn = new Function("module", "exports", "requireScript", "require", "'use strict';" + source);
	const module = {
		id: name,
		filename: filename,
		exports: {}
	};

	function req(_: _,  name: string) {
		return exports.requireScript(_, name);
	}
	try {
		fn(module, module.exports, req, require);
	} catch (ex) {
		tracer.error && tracer.error("compile exception:" + JSON.stringify(ex));
		throw new Error(filename + ": module initialization failed: " + ex.stack.split('\n').slice(0, 2).join(': '));
	}
	return module.exports;
}

export function requireScript(_: _,  name: string) {
	//console.log("requireScript:"+name);

	const frame = util.currentContext().x3frame;

	if (!exports.requireScript.builtins) {
		exports.requireScript.builtins = {};

		const files = fs.readdir(__dirname + "/../../supervisor/builtins/", _);
		files.filter(file => file.endsWith(".ts")).forEach_(_, (_, file, i) => {
			exports.requireScript.builtins[file.replace(/\.ts$/, '')] = __dirname + "/../../supervisor/builtins/" + file;
		});
	}

	if (!exports.requireScript.nodeScript) {
		exports.requireScript.nodeScript = {};

		const files = fs.readdir(__dirname + "/../../../test/engine/server/", _);
		files.filter(file => file.endsWith(".src")).forEach_(_, (_, file, i) => {
			exports.requireScript.nodeScript[file.replace(/\.src$/, '')] = __dirname + "/../../../test/engine/server/" + file;
		});
	}

	exports.requireScript.scripts = exports.requireScript.scripts || {};

	if (exports.requireScript.scripts[name]) return exports.requireScript.scripts[name];

	if (exports.requireScript.builtins[name]) {
		//console.log("require builtin:"+name);
		exports.requireScript.scripts[name] = require(exports.requireScript.builtins[name]);
		return exports.requireScript.scripts[name];
	}

	if (exports.requireScript.nodeScript[name]) {
		//console.log("require nodeScript:"+name);
		exports.requireScript.scripts[name] = require(exports.requireScript.nodeScript[name]);
		return exports.requireScript.scripts[name];
	}

	// Is it a script stored on the shared folder ?
	const trtdir = (frame.context.superv.solutionPath + '/' + frame.context.superv.folderName + "/TRT/").replace(/\\/g, '/');
	//console.log("trtdir:"+trtdir);

	const path = trtdir + name + ".src";

	if (fs.exists(path, _, _)) {
		// Yes, it is :
		//console.log("require src:" + name);
		tracer.debug && tracer.debug("require src:" + name);

		var banner = "/* Generated by etna " + version + " -- DO NOT EDIT */";
		var source = fs.readFileSync(path, 'utf8');
		var parsed = new Parser(source, path).parse();
		var transformed = banner + jsgen.generate(parsed.node, path);

		exports.requireScript.scripts[name] = compile(transformed, name, path);

		if (tracer.debug) {
			var cpath = require('os').tmpdir() + "/etna/" + name + ".js";
			tracer.debug("local copy:" + cpath);
			register.mkdirsSync(cpath);
			fs.writeFileSync(cpath, transformed, "utf8");
		}
		return exports.requireScript.scripts[name];
	} else {
		throw new X3Error(20, `script not found: ${name}`);
	}

	//exports.requireScript.scripts[name] = require(name);
	//return exports.requireScript.scripts[name];
};

// TODO: improve - we need to wrap to trace instructions but we don't need it to trace calls/funcs

function initTraces() {
	var indent = "";

	function traceCall(_: _,  action: string, arg: any) {
		const frame = util.currentContext().x3frame;
		const loc = frame.prev.sub.loc;

		if (!config.etna.traceCallRE.test(loc.module + (frame.prog && ':' + frame.prog.name || ""))) return;
		if (action === "exit") indent = indent.substring(0, indent.length - 2);
		//console.log(indent + loc.file.substring(loc.file.lastIndexOf("\\") + 1) + ':' + loc.line + ': ' + action + ' ' + frame.prog.name + (arg ? ": " + arg : ""));
		if (action === "enter") indent += "  ";
	}

	function traceFunc(_: _,  action: string, arg: any) {
		const frame = util.currentContext().x3frame;
		const loc = frame.sub.loc;

		if (!config.etna.traceFuncRE.test(loc.module + (frame.prog && ':' + frame.prog.name || "") + ':' + frame.fcall)) return;
		//console.log(indent + loc.file.substring(loc.file.lastIndexOf("\\") + 1) + ':' + loc.line + ': ' + action + ' ' + frame.fcall + (arg ? ": " + arg : ""));
	}

	Object.keys(exports._instructions).forEach(k => {
		const instruction = exports._instructions[k];

		exports._instructions[k] = function traceWrapper() {
			const instArgs = Array.prototype.slice.call(arguments);
			const fn = instruction.apply(this, arguments);

			if (typeof fn !== "function") return;
			const loc = basic.sourceLoc;

			return function () {
				const frame = util.currentContext().x3frame;

				if (config.etna.traceCallRE) frame.context.traceCall = traceCall;
				if (config.etna.traceFuncRE) frame.context.traceFunc = traceFunc;
				frame.sub.loc = loc;
				// streamline's apply_ introduces too much overhead - we can directly apply as this is a tail call
				return fn.apply(this, arguments);
			};
		};
	});
}

function initStackLines() {
	Object.keys(exports._instructions).forEach(k => {
		const instruction = exports._instructions[k];

		exports._instructions[k] = function () {
			const fn = instruction.apply(this, arguments);

			if (typeof fn !== "function") return;
			const loc = basic.sourceLoc;

			return _.cast(function (cb) {
				const frame = util.currentContext().x3frame;
				//console.error(loc.file + ':' + loc.line + ":" + k);

				frame.sub.loc = loc;
				fn.apply(this, arguments);
			});
		};
	});
}

function millis(nanos: number) {
	return nanos / 1000000;
}

function nanos(hr: number[]) {
	return hr[0] * 1e9 + hr[1];
}

interface Counter {
	name: string;
	hits: number;
	hr: number[];
	nanos: number;
	selfNanos?: number;
}

var instCounters: { [name: string]: Counter } = {};
var curInstCounter = {
	hr: process.hrtime(),
	nanos: 0,
	hits: 0,
};

function initInstructionMonitoring() {
	Object.keys(exports._instructions).forEach(k => {
		const instruction = exports._instructions[k];
		const counter: Counter = instCounters[k] = {
			name: k,
			hits: 0,
			hr: null,
			nanos: 0
		};

		exports._instructions[k] = function perfmonWrapper() {
			const fn = instruction.apply(this, arguments);

			if (typeof fn !== "function") return;
			const instName = fn.instName;

			if (instName) {
				instCounters[instName] = {
					name: "F(" + instName + ")",
					hits: 0,
					hr: null,
					nanos: 0
				};
			}
			return function () {
				const prevCounter = curInstCounter;

				prevCounter.nanos += nanos(process.hrtime(prevCounter.hr));
				curInstCounter = counter;
				counter.hits++;
				counter.hr = process.hrtime();
				// streamline's apply_ introduces too much overhead - we can directly apply as this is a tail call
				try {
					return fn.apply(this, arguments);
				} finally {
					var time = nanos(process.hrtime(counter.hr));
					curInstCounter = prevCounter;
					prevCounter.hr = process.hrtime();
					if (instName) {
						instCounters[instName].hits += 1;
						instCounters[instName].nanos += time;
					} else {
						counter.nanos += time;
					}
				}
			};
		};
	});
}

function _dumpInstructionCounters() {
	function padL(a: number, b: number) {
		return (new Array(b + 1).join(" ") + a).slice(-b);
	}

	const counters = Object.keys(instCounters).map(k => instCounters[k])
	.filter(c => !!c.hits).sort((c1, c2) => c2.nanos - c1.nanos)
	.map(c => 'total (ms): ' + millis(c.nanos) + '\thits: ' + padL(c.hits, 9) + '\tcost (ns):' + padL(Math.round(c.nanos / c.hits), 9) + '\t' + c.name);
	//console.log(counters.join('\n'));

	instCounters = {};
}

function _razInstructionCounters() {
	Object.keys(instCounters).forEach(c => {
		instCounters[c].nanos = 0;
		instCounters[c].hits = 0;
	});
}

const callCounters: { [name: string]: Counter } = {};

var curCallCounter: Counter = null;

function initCallMonitoring() {
	require('./flowControl').monitorCall = function (frame: Frame, action: string) {
		const key = frame.loc.file + ':' + frame.prog.name;
		const counter = callCounters[key] = callCounters[key] || {
			name: key,
			hits: 0,
			hr: null,
			nanos: 0,
			selfNanos: 0
		};

		if (action === "enter") {
			if (curCallCounter) curCallCounter.selfNanos += nanos(process.hrtime(curCallCounter.hr));
			curCallCounter = counter;
			counter.hits++;
			counter.hr = process.hrtime();
		} else if (action === "exit") {
			counter.nanos += nanos(process.hrtime(counter.hr));
			counter.hr = process.hrtime(); // in case we got reentered.
		}
	};
}

function dumpCallCounters() {
	const counters = Object.keys(callCounters).map(k => callCounters[k]).filter(c => !!c.hits).sort((c1, c2) => c2.selfNanos - c1.selfNanos).map(c => 'self (ms): ' + millis(c.selfNanos) + '\ttotal (ms): ' + millis(c.nanos) + '\thits: ' + c.hits + //
		'\tcost (ns):' + Math.round(c.selfNanos / c.hits) + '\t' + c.name);
	//console.log(counters.join('\n'));
}

const hr0 = process.hrtime();

function dumpTotalTime() {
	//console.log("Total millis: " + millis(nanos(process.hrtime(hr0))));
}

export function exit(code: number) {
	if (config.etna.monitorInstructions) {
		_dumpInstructionCounters();
		_razInstructionCounters();
	}
	if (config.etna.monitorCalls) dumpCallCounters();

	if (config.etna.monitorInstructions || config.etna.monitorCalls) dumpTotalTime();

	if (process.stdout.write("")) {
		//process.exit(0);
		setTimeout(function () {
			process.exit(0);
		}, 100);
	} else {
		process.stdout.on('drain', function () {
			process.exit(0);
		});
		process.stdout.write("");
	}
};

export function executeProg(_: _,  mod: any, prog: string, args: ProgArgs, _frame?: Frame) {
	var frame = util.currentContext().x3frame;
	const prev = frame;
	const cx = prev.context;

	var result: number;
	const sl = prev ? prev.stackLevel + 1 : 0;

	util.currentContext().x3frame = frame = _frame || {
		values: {},
		types: {},
		context: cx,
		prev: prev,
		loopLevel: 0,
		stackLevel: sl,
		name: mod.name,
		loc: {
			file: mod.name,
			line: 0
		}
	};

	// current sub is the prog itself
	frame.sub = frame;
	frame.dicts = [frame, cx.globals, cx.sys];

	try {
		if (prog[0] === '$' && !mod.$4gl && !mod.body.$4gl) {
			jsInvoke = jsInvoke || require('etna/lib/x3js/js-invoke').default;
			result = jsInvoke(_, mod, prog.substring(1).toLowerCase(), args);
		} else {
			args && args && Object.keys(args).forEach_(_, (_, name) => {
				// test type only on args that start with upper case, to avoid pb with member
				// TODO: isolate real args into a separate object.
				if (!/^[A-Z]/.test(name)) return;
				if (args[name].abrev) {
					if (frame.context.tables === undefined) {
						frame.context.tables = {};
						frame.tables = frame.context.tables;
					}
					frame.context.tables[args[name].abrev] = args[name].value;
				} else {
					frame.values[name] = args[name].value;
					frame.types[name] = args[name].type;
				}
			});
			if (prog[0] !== '$') {
				// TODO: use X3Error to set error code
				if (!mod[prog]) throw new Error("Subprog not found: " + mod.name + '.' + prog);
				mod[prog].body(_);
				result = frame.result;
			} else {
				//ACTION must have $in the name
				//SUBPROG
				var label = prog.substring(1);
				var fn = mod[label] || mod.body[label];
				fn(_);
				result = frame.values['ASTATUS'] || 0;
			}
			args && args && Object.keys(args).forEach(name => {
				if (!/^[A-Z]/.test(name)) return;
				if (args[name].type && (args[name].type.charAt(0) === 'A' || args[name].set)) {
					args[name].value = frame.values[name];
				}
			});
		}
	} finally {
		db.closeFiles([], sl);
		util.currentContext().x3frame = prev;
	}
	return result || 0;
};

function _initDebugger(_: _) {
	const first = true;

	scriptDebugger.start(_);
	Object.keys(exports._instructions).filter(k => trueInst.indexOf(k) != -1).forEach(k => {
		const instruction = exports._instructions[k];

		exports._instructions[k] = function debugWrapper() {
			const instArgs = Array.prototype.slice.call(arguments);
			const fn = instruction.apply(this, arguments);

			if (typeof fn !== "function") return;
			const loc = core.helpers.object.clone(basic.sourceLoc);

			loc.file = loc.file.replace(/\\/g, "/");
			const module = loc.file.substring(loc.file.lastIndexOf("/") + 1);

			debugTracer.debug && debugTracer.debug("wrap debug: " + k + " in " + module + ':' + loc.line + ", loc=" + sys.inspect(loc));
			// debugTracer.debug && debugTracer.debug("wrap debug: " + k + " in " + module + ':' + loc.line + ' - ' + sys.inspect(arguments, {
			// 	depth: 3
			// }));
			return function () {
				const frame = util.currentContext().x3frame,
				      request = util.currentContext().request,
				      session = request && request.session,
				      debugContext = session && session.debugContext || {},
				      args = arguments;

				// prevent entering in debugger when the debugger need to evaluate properties
				// debugTracer.debug("call debug: active=" + debugContext.isActive + ", status=" + debugContext.status + ", hit " + k + " in " + module + ':' + loc.line);

				if (debugContext.isActive && !util.currentContext().debug) {
					util.currentContext().debug = true;
					frame.sub.debug = {
						instruction: k,
						module: module,
						location: loc
					};
					_.run(_ => debugContext.hit(_, frame, request), function (err, result) {
						if (err) return args[0](err);
						util.currentContext().debug = false;
						return fn.apply(this, args);
					});
					// debugTracer.debug("call debug: " + k + " in " + module + ':' + loc.line + '\nargs=' + sys.inspect(arguments, {
					// 	depth: 3
					// }) + "\nframe=" + sys.inspect(frame));
					// streamline's apply_ introduces too much overhead - we can directly apply as this is a tail call
				} else {
						return fn.apply(this, args);
					}
			};
		};
	});
}

exports.dumpInstructionCounters = _dumpInstructionCounters;
exports.razInstructionCounters = _razInstructionCounters;

function init() {
	collect('functions');
	collect('instructions');
	const runtime = _.runtime;
	if (config.etna.traceCallRE || config.etna.traceFuncRE) initTraces();

	else initStackLines();

	if (config.etna.debug && config.etna.debug.enabled) _.run(_ => _initDebugger(_));
	if (config.etna.monitorCalls) {
		initCallMonitoring();
		process.on('exit', dumpCallCounters);
	}

	if (config.etna.monitorInstructions) {
		initInstructionMonitoring();
		process.on('exit', _dumpInstructionCounters);
	}
	if (config.etna.monitorInstructions || config.etna.monitorCalls) process.on('exit', dumpTotalTime);
}

export var instructions: { [name: string]: Instruction<any> };
export var functions: { [name: string]: X3Function };

Object.defineProperty(exports, 'instructions', {
	get() {
		if (!exports._instructions) init();
		return exports._instructions;

	}
});
Object.defineProperty(exports, 'functions', {
	get() {
		if (!exports._functions) init();
		return exports._functions;

	}
});
