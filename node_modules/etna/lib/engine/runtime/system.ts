"use strict";

import * as errors from './errors';
const X3Error = errors.X3Error;
import * as util from './util';
import * as basic from './basic';
const glob = require('streamline-runtime').globals;

export const functions = {
	FILELEV: {
		count: 1
	},
	ADXSEEK: {
		count: 1,
		fn(ab) {
			const frame = glob.context.x3frame;

			if (typeof ab === 'string') {
				var file = frame.context.files[ab];
				if (file) return file.x3adxseek();
				else return -1;
			}
			switch (ab) {
				case 0:
					var file = frame.context.files["###"] || frame.context.files["#"];
					if (file) return file.x3adxseek();
					else return -1;
				case 1:
					var file = frame.context.files["###"] || frame.context.files["##"];
					if (file) return file.x3adxseek();
					else return -1;
				default:
					var file = frame.context.files[ab];
					if (file) return file.x3adxseek();
					else return -1;
			}
		}
	},
	INPMODE: {
		count: 0,
		fn() {
			return 0;
		}
	},
	VARINIT: {
		count: 1
	},
	MASKLEV: {
		count: 1
	},
	MASKNBF: {
		count: 1
	},
	MASKRK: {
		count: 1
	},
	MASKSIZ: {
		count: 1
	},
	ADXPID: {
		count: 0
	},
	ADXTCP: {
		count: 0
	},
	ADXUID: {
		count: 1,
		fn(indice) {
			return 1;
		}
	},
	FREEMEM: {
		count: 0,
		fn() {
			return 0;
		}
	},
	NBRUSER: {
		count: 0
	},
	MASKABR: {
		count: 1
	},
	MASKCOU: {
		count: 0
	},
	MASKNAM: {
		count: 1
	},
	ADXMAC: {
		count: 1,
		fn() {
			return "";
		}
	},
	ADXPAM: {
		count: 0
	},
	ADXUSR: {
		count: 0,
		fn() {
			const frame = glob.context.x3frame;

			return frame.context.loginName;
		}
	},
	ADXPNO: {
		count: 1,
		fn(level) {
			var frame = glob.context.x3frame;
			while (frame && level-- > 0) frame = frame.prev;
			if (!frame) return "";
			const modname = errors.moduleName(frame.sub.loc);
			// for now hard code folder, subfolder and extension
			// TODO: improve this

			return "@SUPERV.TRT/" + modname + "$adx";
		}
	},
	DBGCALLSTACK: {
		count: 2,
		fn(depth, result) {
			// TODO: handle it differently because we cannot return a value through result.
			return 0;
		}
	},
	COP$: {
		count: 0,
		fn() {
			return "ADONIX Copyright ADONIX Paris 1996";
		}
	},
	GETENV$: {
		count: 1,
		fn(s) {
			s = util.x3ToString(s, true);
			return process.env[s] || "";
		}
	},
	TRTCOU: {
		count: 0,
		fn() {
			const frame = glob.context.x3frame;

			return "@" + frame.context.superv.folderName + ".TRT/" + errors.moduleName(frame.sub.loc) + "$adx";
		}
	},
	VER$: {
		count: 1,
		fn(exp_num) {
			if (exp_num === 0) return "etna 7.0.2";
			else if (exp_num == 1) return "";
			throw new X3Error(50, "Function not defined for the given value");
		}
	},
	NOMAP: {
		count: 0,
		fn() {
			const frame = glob.context.x3frame;

			return frame.context.superv.folderName;
		}
	},
	ADXCIO: {
		count: 1,
		fn() {
			// deprecated
			// normally, give an arbitrary slot a file used (old debugger)
			return 0;
		}
	},
	ADXIOA: {
		count: 1,
		fn() {
			// deprecated
			// normally, give the abreviation of a slot (old debugger)
			return "";
		}
	},
	ADXNFS: {
		count: 0
	},
	MASKCLA: {
		count: 0
	},
	PROGCAN: {
		count: 0
	},
	PROGLDD: {
		count: 0
	},
	PROGSIZ: {
		count: 0
	},
	PROGUSD: {
		count: 0
	}
};

function sysFor(_, where, p, end, block) {
	console.error("System FOR loop - skipping for now");
	p[end](_);
}

export const instructions = {
	FILESYS(abbrev, vars, from) {
		const avars = basic.instructions.A(vars);

		return function dot$do(_) {
			const table = abbrev(_, true, {
				types: {},
				values: {},
				doFor: sysFor
			});
		};
	}
};