"use strict";

const X3Error = require('./errors').X3Error;
const util = require('./util');
const Double = require('./tdouble').Double;
const bcd = require('./tbcd');
const Blbfile = require('./tblbfile').Blbfile;

exports.MAX_INT = Math.pow(2, 31);
exports.MIN_SHORTINT = -Math.pow(2, 15);
exports.MAX_SHORTINT = Math.pow(2, 15) - 1;
exports.MIN_TINYINT = 0;
exports.MAX_TINYINT = 255;

Object.defineProperty(Number.prototype, "x3AssertOverflow", {
	value(type) {
		/* whatever the type, error 50 in this case*/

		if (Math.abs(this) >= Math.pow(2, 31)) throw new X3Error(50, "");

		if (type === 'J') return Math.abs(this) < Math.pow(2, 15) + (this >= 0 ? 0 : 1) ? true : false;

		else if (type === 'V') return this >= 0 && this < Math.pow(2, 8) ? true : false;

		return true;
	},
	enumerable: false
});

Object.defineProperty(Number.prototype, "x3Minus", {
	value() {
		return -this;
	},
	enumerable: false
});

Object.defineProperty(Number.prototype, "x3ToInteger", {
	value() {
		return this;
	},
	enumerable: false
});

Object.defineProperty(Number.prototype, "x3ToString", {
	value(v) {
		return "" + this;
	},
	enumerable: false
});

Object.defineProperty(Number.prototype, "x3ToDouble", {
	value() {
		return new Double(this);
	},
	enumerable: false
});

Object.defineProperty(Number.prototype, "x3ToBCD", {
	value() {
		// be carefull that x3ToBCD applies to numbers (see flowcontrol)
		//return bcd.fromInt32( this ) ;
		return bcd.fromDouble(this);
	},
	enumerable: false
});

Object.defineProperty(Number.prototype, "x3ToDate", {
	value() {
		throw util.badOperand(this);
	},
	enumerable: false
});

Object.defineProperty(Number.prototype, "x3ToDatetime", {
	value() {
		throw util.badOperand(this);
	},
	enumerable: false
});

Object.defineProperty(Number.prototype, "x3IsNumeric", {
	value() {
		return true;
	},
	enumerable: false
});

Object.defineProperty(Number.prototype, "x3IsZero", {
	value() {
		return this === 0 ? true : false;
	},
	enumerable: false
});
Number.prototype.x3IsUndefined = Number.prototype.x3IsZero;

Object.defineProperty(Number.prototype, "x3IsEmpty", {
	value() {
		throw util.badOperand(this);
	},
	enumerable: false
});

Object.defineProperty(Number.prototype, "x3Compare", {
	value(b) {
		if (util.x3IsInteger(b)) {
			var diff = this - b;
			return !diff ? 0 : diff > 0 ? 1 : -1;
		} else if (util.x3IsDouble(b)) {
			return this.x3ToDouble().x3Compare(b);
		} else if (util.x3IsBCD(b)) {
			return this.x3ToBCD().x3Compare(b);
		} else throw util.badOperand(b);
	},
	enumerable: false
});

Object.defineProperty(Number.prototype, "x3Add", {
	value(b) {
		if (util.x3IsInteger(b)) {
			return this + b;
		} else if (util.x3IsDate(b)) {
			return b.x3Add(this);
		} else if (util.x3IsDatetime(b)) {
			return b.x3Add(this);
		} else if (b.x3IsNumeric()) {
			return b.x3Add(this);
		} else throw util.badOperand(b);
	},
	enumerable: false
});

Object.defineProperty(Number.prototype, "x3Sub", {
	value(b) {
		if (util.x3IsInteger(b)) {
			return this - b;
		} else if (util.x3IsDouble(b)) {
			return this.x3ToDouble.x3Sub(b);
		} else if (util.x3IsBCD(b)) {
			return this.x3ToBCD().x3Sub(b);
		} else throw util.badOperand(b);
	},
	enumerable: false
});

Object.defineProperty(Number.prototype, "x3Mul", {
	value(b) {
		if (util.x3IsInteger(b)) {
			return this * b;
		} else if (b.x3IsNumeric && b.x3IsNumeric()) {
			return b.x3Mul(this);
		} else throw util.badOperand(b);
	},
	enumerable: false
});

Object.defineProperty(Number.prototype, "x3Div", {
	value(b) {
		if (util.x3IsDouble(b)) {
			return this.x3ToDouble().x3Div(b);
		} else if (util.x3IsBCD(b)) {
			return this.x3ToBCD().x3Div(b);
		} else if (util.x3IsInteger(b)) {
			if (b.x3IsZero()) throw new X3Error(53, "division by zero");

			if (this % b === 0) return this / b;

			else return this.x3ToBCD().x3Div(b.x3ToBCD());
		} else throw util.badOperand(b);
	},
	enumerable: false
});

Object.defineProperty(Number.prototype, "x3Mod", {
	value(b) {
		if (util.x3IsInteger(b)) {
			if (b.x3IsZero()) return this;
			return this % b;
		} else if (util.x3IsDouble(b)) {
			return this.x3ToDouble.x3Mod(b);
		} else if (util.x3IsBCD(b)) {
			return this.x3ToBCD().x3Mod(b);
		} else throw util.badOperand(b);
	},
	enumerable: false
});

Object.defineProperty(Number.prototype, "x3Pow", {
	value(b) {
		if (util.x3IsInteger(b)) {
			if (this === 0) {
				if (b >= 0) return 0;
				throw new X3Error(53, "division by zero");
			}
			if (b >= 0) return Math.pow(this, b);
			else return this.x3ToDouble().x3Pow(b);
		} else if (util.x3IsDouble(b)) {
			return this.x3ToDouble().x3Pow(b);
		} else if (util.x3IsBCD(b)) {
			return this.x3ToBCD().x3Pow(b);
		} else throw util.badOperand(b);
	},
	enumerable: false
});

Object.defineProperty(Number.prototype, "x3Xor", {
	value(b) {
		if (b.x3IsNumeric()) {
			var i = this.x3IsZero() ? 1 : 0;
			var j = b.x3IsZero() ? 1 : 0;

			return i ^ j;
		} else throw util.badOperand(b);
	},
	enumerable: false
});

Object.defineProperty(Number.prototype, "x3Abs", {
	value() {
		return Math.abs(this);
	},
	enumerable: false
});

Object.defineProperty(Number.prototype, "x3Truncate", {
	value(v) {
		return this;
	},
	enumerable: false
});

Object.defineProperty(Number.prototype, "x3Serialize", {
	value(size) {
		const b = new Buffer(size);
		const int8 = function (v) {
			return v >= 128 ? v - 256 : v;
		};

		switch (size) {
			case 8:
				var lo = this % 0x100000000;
				var hi = Math.floor(this / 0x100000000);

				b.writeInt32BE(hi, 0);
				b.writeInt32BE(lo, 4);
				break;
			case 4:
				b.writeInt32BE(this, 0);
				break;
			case 3:
				b.writeInt8(int8(this >> 16 & 0xff), 0);
				b.writeInt8(int8(this >> 8 & 0xff), 1);
				b.writeInt8(int8(this & 0xff), 2);
			case 2:
				b.writeInt16BE(this, 0);
				break;
			case 1:
				b.writeUInt8(this, 0);
				break;
			default:
				throw X3Error(26, "Illegal Number size");
		}
		return b;
	},
	enumerable: false
});

Object.defineProperty(Number.prototype, "x3ToSql", {
	value(driver) {
		return this;
	},
	enumerable: false
});

Object.defineProperty(Number.prototype, "x3Type", {
	value(v) {
		return 4;
	},
	enumerable: false
});