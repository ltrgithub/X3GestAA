"use strict";

var tracer = require('syracuse-core').getTracer("etna.engine");
var X3Error = require('./errors').X3Error;


function _extended(abv) {
	return abv !== "extended";
}

function _save(tables, columns) {
	var rec = {};
	if (columns) {
		Object.keys(columns).filter(_extended).forEach(
			function(abv) {
				if (columns[abv] !== null) {
					var cdef = columns[abv];
					var cpy = {};
					for (var i = 0; i < cdef.length; i++) {
						var nm = cdef[i].field.data.CODZONE;
						cpy[nm] = tables[abv].values[nm];
					}
					rec[abv] = cpy;
				} else
					rec[abv] = tables[abv].values;
			});
	} else {
		Object.keys(tables).forEach(abv => {
			rec[abv] = tables[abv].values;
		});
	}
	return rec;
}

function _dispatch(tables, row, columns) {
	// console.log("_dispatch:",row);
	if (columns) {
		Object.keys(columns).filter(_extended).forEach(abv => {
			var cdef = columns[abv];
			if (cdef === null) tables[abv].values = row[abv];
			else {
				// assign just values from columns
				for (var i = 0; i < cdef.length; i++) {
					var nm = cdef[i].field.data.CODZONE;
					tables[abv].values[nm] = row[abv][nm];
				}
			}
		});
	} else {
		Object.keys(row).forEach(abv => {
			tables[abv].values = row[abv];
		});
	}
}

class DBCursor {
	constructor(reader, tables, maptrim, pwhere, key, lvl, typ, columns ) {
		this.reader = reader;
		this.tables = tables;
		this.maptrim = maptrim;
		this.pwhere = pwhere;
		this.key = key;
		this.klvl = lvl;
		this.level = 0;
		this.currkeyValues = [];
		this.pocket = undefined;
		this.lastRecord = undefined;
		this.finished = false;
		this.typecursor = typ;
		this.columns = columns;
	}

	x3GetRecord(_, sv) {
		var maptrim = this.maptrim;
		var pwhere = this.pwhere;
		var tables = this.tables;
		var vsave;
		var wok = 1;

		// I have  anything in my pocket ?
		if (this.pocket) {
			_dispatch(tables, this.pocket);
			var r = this.pocket;
			this.pocket = undefined;
			return r;
		}

		// save last record
		vsave = _save(tables, this.columns);

		// let's go dancing with records
		tracer.debug && tracer.debug("Cursor Read....");
		var rec = this.reader.read(_);
		tracer.debug && tracer.debug("Cursor read ok");
		while (rec) {
			var row = maptrim(_, rec);
			_dispatch(tables, row, this.columns);

			tracer.debug && tracer.debug(row);

			// post evaluations have to be ok
			wok = 1;
			for (var i = 0; i < pwhere.length; i++) {
				var w = pwhere[i](_);
				var r = w.reduce((r, c) => r && c, 1);
				wok = wok && r;
			}
			if (!wok) {
				rec = this.reader.read(_);
			} else {
				break;
			}
		}

		if ((!wok) && (!rec)) _dispatch(tables, vsave, this.columns);
		if (sv) this.lastRecord = vsave;
		if (rec === undefined) this.finished = true;
		return rec;
	}

	x3DiscardCurrent() {
		if (this.lastRecord === undefined) throw new X3Error(26, "x3DiscardCurrent without save");

		this.pocket = _save(this.tables);
		_dispatch(this.tables, this.lastRecord);
		this.lastRecord = undefined;
	}
	x3CloseDBReader(_) {
		tracer.debug && tracer.debug("Reader stop....");
		this.reader.stop(_);
	}
	x3HasNoMoreRecord() {
		return this.finished;
	}
	x3FreeLast() {
		this.lastRecord = undefined;
	}
}

exports.DBCursor = DBCursor;