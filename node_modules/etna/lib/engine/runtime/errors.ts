"use strict";

import * as types from './types';
import { config, trace } from '../../util/nodeconfig';
import * as util from './util';
const glob = require('streamline/lib/globals');
export function errmes$(errn: number) {
	try {
		return glob.context.x3frame.context.messages[errn];
	} catch (e) {
		// necessary for unit tests
		return errn;
	}
};

export function moduleName(loc: types.Location) {
	if (!loc.file) return "unknown";
	const file = loc.file;
	const s = file.substring(Math.max(file.lastIndexOf('/'), file.lastIndexOf('\\')) + 1);
	//console.log("moduleName: " + s);

	const dot = s.lastIndexOf('.');

	return (/*"x3://host:port/folder/" +*/dot >= 0 ? s.substring(0, dot) : s
	);
};

export class X3ErrorFrame {
	file: string;
	line: number;
	name: string;
	constructor(file: string, line: number, name: string) {
		this.file = file;
		this.line = line;
		this.name = name;
	}
	toString() {
		return "  at " + (this.name || '<script>') + " (" + this.file + (this.line ? ":" + this.line : "") + ")";
	}
}

export class X3Error {
	errn: number;
	message: string;
	jsStack: string;
	frames: X3ErrorFrame[];
	constructor(errn: number | Error, message?: string, jsStack?: string) {
		//Error.captureStackTrace(this, X3Error);
		function cut(s: string) {
			return s.substring(s.indexOf('\n') + 1);
		}
		if (arguments.length === 1) {
			// errn is an Error object
			const anyErr: any = errn;
			this.message = anyErr.message;
			this.errn = anyErr.errn;
			jsStack = anyErr.jsStack;
		} else {
			const errno: any = errn;
			this.message = "[" + errn + "] " + errmes$(errno) + (message ? " [" + message + "]" : "");
			this.errn = errn as any;
		}
		if (arguments.length > 3) {
			this.frames = [new X3ErrorFrame(arguments[2], arguments[3], arguments[4])];
			this.jsStack = cut(new Error('').stack);
		} else {
			this.frames = [];
			this.jsStack = jsStack || cut(new Error().stack);
		}
		if (trace) {
			trace("\nX3Error(" + errn + "):" + message);
			var root: string;
			var keep = 0;
			this.jsStack.split(")\n").some(line => {
				if (!root) {
					var node_modules = "node_modules";
					root = line.substring(line.indexOf("(") + 1, line.indexOf(node_modules) + node_modules.length);
				}
				trace(line.replace(root, "."));
				return !(keep++ < 2);
			});
		}
	}
	fill(frame: types.Frame) {
		for (; frame; frame = frame.prev) {
			if (frame.fcall) this.frames.push(new X3ErrorFrame("<built-in functions>", 0, frame.fcall));
			for (var sub = frame.sub; sub; sub = sub.prevSub) {
				this.frames.push(new X3ErrorFrame(sub.loc.file, sub.loc.line, sub.name || frame.prog && frame.prog.name || ""));
			}
		}
		this.fill = null; // fill only once	
	}
	toString() {
		return this.message;
	}
	get stack() {
		//console.log(this);
		return this.message + //
		"\n  <<< X3 stack >>>\n" + this.frames.join("\n") + //
		"\n  <<< JS stack >>>\n" + this.jsStack;
	}
}