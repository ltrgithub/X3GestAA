import { _ } from 'streamline-runtime';
import * as types from './types';
import * as util from './util';
import * as basic from './basic';
import { X3Error } from './errors';
import * as variables from './variables';

// not used for now

function _lookup<T>(array: T[], len: number, elt: T, comparator: (a: T, b: T) => number) {
	if (len === 0) return -1;

	var l = 0;
	var r = len - 1;
	while (true) {
		var m = Math.floor((l + r) / 2);
		var c = comparator(elt, array[m]);
		if (c === 0) return m;
		if (m == l && c < 0) return -(m + 1);
		if (m == r && c > 0) return -(m + 2);

		if (l == m) l++;
		else if (r == m) r--;

		else if (c > 0) l = m;

		else r = m;
	}
}

// nb value in one dimension table
function getOneDimNbValues(arr: any[]) {
	//sub or not
}

function _sort(compare: (a: number, b: number) => number, swap: (a: number, b: number) => void, beg: number, end: number) {
	function _qsort(beg: number, end: number) {
		//dbg:console.log("_qsort beg="+beg+", end="+end);
		if (beg >= end) return;

		if (end == beg + 1) {
			if (compare(beg, end) > 0) {
				swap(beg, end);
			}
			return;
		}

		var mid = Math.floor((beg + end) / 2);
		var nbeg = beg;
		var nend = end;
		//dbg:console.log("    1- midmid="+mid+", nbeg="+nbeg+", nend="+nend);

		while (nbeg <= nend) {
			while (nbeg < end && compare(nbeg, mid) < 0) nbeg++;
			while (beg < nend && compare(mid, nend) < 0) nend--;

			//dbg:console.log("    X- mid="+mid+", nbeg="+nbeg+", nend="+nend);
			if (nbeg <= nend) {
				if (nbeg !== nend) swap(nbeg, nend);
				if (mid === nbeg) mid = nend;
				else if (mid === nend) mid = nbeg;
				nbeg++;
				nend--;
			}
			//dbg:console.log("    2- mid="+mid+", nbeg="+nbeg+", nend="+nend);
		}

		if (nbeg < end) _qsort(nbeg, end);
		if (beg < nend) _qsort(beg, nend);
	}
	_qsort(beg, end);
}

// Array layout:
// [ndims, def, data, base1, size1, base2, size2, ... offset1, count1, offset2, count2, ...]
//
// ndims: number of dimensions (1 or more)
// def: default value for entries ("", 0, or date(0))
// data: the array of values
// baseN: index of first valid entry for dimension N (if slice, this is index of the first slice entry, not of the first data entry)
// sizeN: number of data entries for dimension N
// offsetN: offset of first slice entry in data for dimension N
// countN: number of entries in slice for dimension N
//
// offsetN, countN part is only present if a slice is active.
// size of the array is 3 + 4 * ndims is a slice is active, 3 + 2 *  ndims otherwise.
// size of the data is size1 * size2 * ... regardless of whether there is a slice or not.

export function isSliced(arr: any[]) {
	return arr.length === 3 + 4 * arr[0];
};

function _offset(arr: any[], args: number[], forOrderBy: boolean) {
	const ndims = arr[0];

	if (ndims !== args.length) throw new X3Error(8, "expected " + ndims + " dimensions, got " + args.length);
	var result = 0;
	var result1 = 0;
	const sliced = arr.length === 3 + 4 * ndims;

	var sliceSize = 1;
	for (var i = ndims - 1; i >= 0; i--) {
		var arg = args[i];
		if (Array.isArray(arg)) return null; // get will branch to _slice
		//result = result * size;
		var base = forOrderBy ? 0 : arr[3 + 2 * i];

		var size = arr[4 + 2 * i] != null ? arr[4 + 2 * i] - arr[3 + 2 * i] + 1 : null;
		//dbg:console.log("sliced=" + sliced +" size="+size+" sliceSize="+sliceSize+" result="+result);
		if (sliced) {
			var offset = arr[3 + 2 * (ndims + i)];
			var count = arr[4 + 2 * (ndims + i)];
			if (!(arg >= base && arg < base + count)) throw new X3Error(8, "index out of range: " + arg + " not in [" + base + "," + (base + count - 1) + "]");
			//result += arg - base + offset;
			result += (arg - base + offset) * sliceSize;
		} else {
			if (!(arg >= base && (size === null && i === 0 || arg < base + size))) throw new X3Error(8, "index out of range: " + arg + " not in [" + base + "," + (base + size - 1) + "]");
			//dbg:console.log("i=" + i + ", size=" + size + " base=" + base + ", before=" + result + ", after=" + (result + arg - base));
			// result += arg - base;
			result += (arg - base) * sliceSize;
			if (size !== null) result1 += size * sliceSize;
			else result1 += (arg - base) * sliceSize;
		}
		sliceSize *= size;
	}
	//special case for MAXTAB on multi-dimension X3 array
	if (!sliced && arr[0] > 1 && arr[4] === null && result1 > arr[2].length) {
		// set maximun index with default value
		arr[2][result1] = arr[1];
	}
	return result;
}

function _slice(arr: any[], args: (number| number[])[]) {
	const ndims = arr[0];
	const result = arr.slice(0);
	const sliced = arr.length === 3 + 4 * ndims;

	for (var i = ndims - 1; i >= 0; i--) {
		var arg = args[i],
		    lo: number,
		    hi: number;
		var base = sliced ? arr[3 + 2 * i] : arr[3];
		var size = sliced ? arr[4 + 2 * i] : arr[4] === null ? arr[2].length : arr[4] - arr[3] + 1;
		var offset = sliced ? arr[3 + 2 * (ndims + i)] : 0;
		var count = sliced ? arr[4 + 2 * (ndims + i)] : size;

		if (Array.isArray(arg)) {
			lo = arg[0];
			hi = arg[1];
			if (hi === null) hi = base + count - 1;
			//console.error("slice: lo=" + lo + ", hi=" + hi + ", sliced=" + sliced)
		} else {
				lo = hi = arg;
			}
		if (!(lo >= base && lo <= hi && hi < base + count)) throw new X3Error(8, "invalid subrange: [" + [lo, hi] + "] not in [" + [base, base + count - 1] + "]");

		result[3 + 2 * i] = lo;
		if (sliced) result[3 + 2 * (ndims + i)] += lo - base;
		else result[3 + 2 * (ndims + i)] = lo - base;
		result[4 + 2 * (ndims + i)] = hi + 1 - lo;
	}
	//dbg:console.error("_slice returns: " + JSON.stringify(result))
	return result;
}

function _evalOrder(order: (_: _) => any) {
	return function evalOrder$do(_: _) {
		const frame = util.currentFrame();
		const values: any[] = [];

		frame.values['INDICE'] = 0 - frame.orderBase;
		frame.types['INDICE'] = 'LI';
		//dbg:console.log("frame.orderCount= "+frame.orderCount+" frame.values.INDICE="+frame.values.INDICE);
		while (frame.values['INDICE'] + frame.orderBase < frame.orderCount) {
			values.push(order(_));
			//dbg:console.log("values ="+values+"  indice ="+frame.values.INDICE);

			frame.values['INDICE']++;
		}
		//dbg:console.log("Return _evalOrder");

		//return [1, null, values, frame.orderBase, frame.orderCount];
		return [1, null, values, frame.orderBase, frame.orderBase === 0 ? frame.orderCount - 1 : frame.orderCount];
	};
}

function _insDela(isDel: boolean) {
	return function (ints: types.Expression<number>[], vars: types.Expression<any>[]) {
		const aints = basic.instructions.A(ints);
		const avars = basic.instructions.A(vars);

		return function insa$do(_: _) {
			const intVals = aints(_);

			intVals.map(util.checkInteger);
			const lo = intVals[0];
			const num = intVals.length > 1 ? intVals[1] : 1;

			var hi = intVals[2];
			if (num <= 0) throw new X3Error(8, "bad num parameter: " + num);
			const varVals = avars(_);

			varVals.forEach(util.checkMonoArray);
			varVals.forEach(arr => {
				//dbg:console.log("_insDela: " + JSON.stringify(arr));
				//dbg:console.log("_insDela: lo=" + lo + " hi=" + hi + " num=" + num);
				const base = arr[3];

				var i: number;
				var offset: number, count: number;
				if (arr.length === 3 + 4 * arr[0]) {
					offset = arr[3 + 2];
					count = arr[4 + 2];
				} else {
					offset = 0;
					count = arr[4] === null ? arr[2].length : arr[4] - arr[3] + 1;
				}
				if (lo < base) throw new X3Error(8, "bad low bound: " + lo + " < " + base);
				if (hi != null && hi >= base + count) throw new X3Error(8, "bad high bound: " + hi + " >= " + base + count);
				if (hi == null && count === 0) hi = -1;
				else if (hi == null) hi = base + count - 1;
				const data = arr[2];
				const def = arr[1];

				if (isDel) {
					//dbg:console.log("DELA: lo=" +lo+" hi="+hi+" num="+num+" base="+base);
					i = lo - base;
					while (i + num <= hi - base) {
						data[i] = data[i + num];
						i++;
					}
					while (i <= hi - base) {
						data[i++] = def;
					}
					//dbg:console.log("DELA: apres=" + JSON.stringify(arr));
				} else {
						//dbg:console.log("INSA: lo=" +lo+" hi="+hi+" num="+num+" base="+base);
						i = hi - base;
						if (arr[4] !== null) {
							while (i - num >= lo - base) {
								data[i] = data[i - num];
								i--;
							}
							while (i >= lo - base) {
								data[i--] = def;
							}
						} else {
							while (i >= lo - base) {
								data[i + num] = data[i];
								i--;
							}
							if (hi < 0) i += base; // special case for add first element in array(base..)
							while (i + num >= lo - base) {
								data[i + num] = def;
								i--;
							}
						}
						//dbg:console.log("INSA: apres=" + JSON.stringify(arr));
					}
			});
		};
	};
}

export const functions = {
	MAXTAB: {
		count: 1,
		fn(arr: any[]) {
			if (arr === null) return 1;
			if (Array.isArray(arr)) {
				// arr[2] is base and arr[3] is the array
				var sliced = arr.length === 3 + 4 * arr[0];
				if (sliced) throw new X3Error(26, "maxtab not allowed on sliced array: " + arr[0]);
				//maxtab gives the maximum index defined in the array : it's not  the array's count

				if (arr[4] === null) {
					if (arr[0] === 1) return arr[2].length + arr[3] - 1;
					if (!arr[2].length) return arr[3] - 1;

					var sliceSize = 1;
					var result = 0;
					for (var i = arr[0] - 1; i > 0; i--) {
						var size = arr[4 + 2 * i] != null ? arr[4 + 2 * i] - arr[3 + 2 * i] + 1 : null;
						result += size * sliceSize;
						sliceSize *= size;
					}
					return (arr[2].length - 1 - result) / sliceSize + arr[3];
				} else {
					//return arr[4] - arr[3] + 1;
					return arr[4];
				}
			} else if (arr.x3Maxtab) return arr.x3Maxtab();
			return 1;
		}
	}
};

export const instructions = {
	RANGE(lo: types.Expression<number>, hi: types.Expression<number>) {
		hi = hi || basic.instructions.C(null);
		return function range$do(_: _) {
			return [lo(_), hi(_)];
		};
	},
	INDEX(target: types.Expression<any>, args: types.Expression<number>[]) {
		const aargs = basic.instructions.A(args);

		return function index$do(_: _, assign?: boolean, val?: any) {
			const frame = util.currentFrame();
			const targetVal = target(_);

			if (targetVal == null) throw new X3Error(10, "invalid array or collection: " + targetVal);

			const argVals = aargs(_);
			;
			if (Array.isArray(targetVal)) {
				var data = targetVal[2];
				//dbg:console.log("index targetVal:" + JSON.stringify(targetVal));
				//dbg:console.log("index argVals:" + JSON.stringify(argVals));
				if (!Array.isArray(data)) return targetVal[argVals[0]]; //:It's a table's indexed property

				var offset = _offset(targetVal, argVals, frame.orderCount > 0);
				//dbg:console.log("index offset:" + offset+ " assign:"+!!assign);
				if (assign) {
					if (offset === null && val !== undefined) throw new X3Error(8, "range not allowed in lhs");
					var vinfo = target(_, variables.vOperations.GETINFO);

					if (val !== undefined) {
						if (vinfo.vtype === 'C') throw new X3Error(62, frame.prog.name + ": '" + vinfo.vname + "' Variable not modifiable");
						data[offset] = variables.types[vinfo.vtype].set(vinfo.vname, vinfo.vstring, val);
					} else return vinfo; // only for GETINFO
				} else {
						//dbg:console.log("data[offset]:"+data[offset]);
						//dbg:console.log("targetVal[1]:"+targetVal[1]);
						//return offset !== null ? (data[offset] || targetVal[1]) : _slice(targetVal, argVals);
						if (offset == null) return _slice(targetVal, argVals);
						if (data[offset] == null) {
							var def = targetVal[1];
							data[offset] = variables.clone(def);
						}
						return data[offset];
					}
			} else if (targetVal.collection) {
				return targetVal.index(_, argVals[0]);
			} else if (argVals[0] === 0) {
				return targetVal;
			} else {
				throw new X3Error(8, "Index incorrect:", targetVal);
			}
		};
	},
	SORTA(rep: types.Expression<number>, vars: types.Expression<any>[], orders: types.Expression<any>[], direction: types.Expression<number>) {
		const avars = basic.instructions.A(vars);
		const aorders = basic.instructions.A((orders || []).map(_evalOrder));

		return function sorta$do(_: _) {
			const frame = util.currentFrame();

			var repVal = rep(_);
			if (repVal === null) repVal = -1;
			util.checkInteger(repVal);

			var dirVal = direction(_);
			if (dirVal === null) dirVal = 1;
			util.checkInteger(dirVal);

			// TODO: handle repVal
			const varVals = avars(_);

			varVals.forEach(util.checkArray);

			const arr = varVals[0];
			const ndims = arr[0];
			// sorta ignores base and uses zero-based index
			// so we only care about slice offset here

			var offset: number, count: number;
			if (arr.length === 3 + 4 * ndims) {
				offset = arr[3 + 2 * ndims];
				count = arr[4 + 2 * ndims];
			} else {
				offset = 0;
				count = arr[4] === null ? arr[2].length : arr[4] - arr[3] + 1;
			}
			// warning: indexing works differently when frame.orderCount is set
			frame.orderCount = count;
			frame.orderBase = arr[3];
			//dbg:console.log("arr = "+JSON.stringify(arr));
			var orderVals = aorders(_);
			frame.orderCount = 0;
			//dbg:console.log("orderVals = "+JSON.stringify(orderVals));

			orderVals.forEach(util.checkArray);
			const swapVals = varVals.concat(orderVals);

			if (orderVals.length === 0) orderVals = varVals;

			const swapDepth = swapVals.length;

			function swap(i: number, j: number) {
				//dbg:console.log("swap entrée.......");
				for (var k = 0; k < swapDepth; k++) {
					var arrk = swapVals[k][2];
					var tmp = arrk[i];

					//dbg:console.log("     k="+k+", swapDepth="+swapDepth+", swapVals[k][2]="+swapVals[k][2]);
					//dbg:console.log("     i="+i+", arrk[i]="+arrk[i]+",j="+j+", arrk[j]="+arrk[j]);

					arrk[i] = arrk[j];
					arrk[j] = tmp;
					//dbg:console.log("                                 arrk=" + arrk);
				}
				//dbg:console.log("swap sortie.......");
			}
			const orderDepth = orderVals.length;

			function compare(i: number, j: number) {
				var delta = 0;
				for (var k = 0; k < orderDepth && !delta; k++) {
					var arrk = orderVals[k][2],
					    elt1 = arrk[i],
					    elt2 = arrk[j];
					//dbg:console.log("arrk=" + JSON.stringify(arrk));
					//!console.log("Compare k=" + k + ", i=" + i + ", j=" + j);
					var t = typeof elt1;
					if (t === "number") delta = elt1 - elt2;
					else if (t === "string") delta = elt1 < elt2 ? -1 : elt1 > elt2 ? +1 : 0;
					/*					else if (util.x3IsDate(elt1)) delta = elt1.daysDiff(elt2);
     else if (util.x3IsBCD(elt1))  delta = elt1.x3Compare(elt2);*/
					else if (util.x3IsDate(elt1) || util.x3IsBCD(elt1)) delta = elt1.x3Compare(elt2);
					else throw util.badArgumentType(elt1);
				}
				return delta * dirVal;
			}

			_sort(compare, swap, offset, offset + count - 1);
			//dbg:console.log(" ap -- orderVals = "+JSON.stringify(orderVals));
		};
	},
	INSA: _insDela(false),
	DELA: _insDela(true)
};

Object.defineProperty(Array.prototype, 'getOneDimNbValues', {
	value() {
		if (this[0] > 1) throw new X3Error(55, "");
		if (this[5] !== undefined) // sub table
			var nl = this[6];else {
			if (this[4]) nl = this[4] - this[3] + 1; // fix table
			else nl = this[2].length; // dyn table		
		}
		return nl;
	},
	enumerable: false
});

Object.defineProperty(Array.prototype, 'getOneDimBase', {
	value() {

		if (this[0] > 1) throw new X3Error(55, "");
		return this[3];
	},
	enumerable: false
});

Object.defineProperty(Array.prototype, 'x3NumDollar', {
	value() {
		if (this[2] && this[2][0]) return this[2][0].x3NumDollar();
		return "";
	},
	enumerable: false
});

Object.defineProperty(Array.prototype, 'x3Type', {
	value() {
		return this[1] != null && this[1].x3Type ? this[1].x3Type() : -1;
	},
	enumerable: false
});

Object.defineProperty(Array.prototype, 'x3Dim', {
	value() {
		return this[0];
	},
	enumerable: false
});