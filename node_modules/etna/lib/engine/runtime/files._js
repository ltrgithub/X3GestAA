"use strict";

const fs = require('streamline-fs');
const X3Error = require('./errors').X3Error;
const Blbfile = require('./tblbfile').Blbfile;
const _ium = {
	0: "utf8",
	1: "utf8",
	50: "ascii"
};
const _fium = {
	"utf8": fromUTF8,
	"ascii": from8Bits
};

function op_error(ex) {
	switch (ex.code) {
		case "ENOENT":
			throw new X3Error(20, ex.message);
		case "EPERM":
		case "EACCES":
			throw new X3Error(27, ex.message);
		default:
			throw new X3Error(26, ex.message);
	}
}

function byteLength(str) {
	// returns the byte length of an utf8 string
	var s = str.length;
	for (var i = str.length - 1; i >= 0; i--) {
		var code = str.charCodeAt(i);
		if (code > 0x7f && code <= 0x7ff) s++;
		else if (code > 0x7ff && code <= 0xffff) s += 2;
		if (code >= 0xDC00 && code <= 0xDFFF) i--; //trail surrogate
	}
	return s;
}

function from8Bits(buf, len) {
	var str = "";
	for (var i = 0; i < len; i++) str += String.fromCharCode(buf[i]);

	return str;
}

function fromUTF8(buf, len) {
	return buf.toString('utf8', 0, len);
}

function isTrailer(byte) {
	return (byte & 0xc0) === 0x80;
}

function UT8Backward(buf) {
	var i = buf.length - 1;

	while (isTrailer(buf[i]) && i-- >= 0);
	return buf.length - i;
}

class File {
	constructor(ctx) {
		const self = this;

		self.ctx = ctx;
		self.fd = null;
		self.mode = "";
		self.offset = 0;
		return self;
	}

	x3open(_, xfil, seekVal, mode) {
		const self = this;
		//dbg:console.log("x3open " +xfil.toString(_)+ " seekVal:"+seekVal+" mode:"+ mode);

		if (mode === "w" && seekVal === -1) mode = "r+";
		else if (!mode) mode = "r";

		try {
			var fd = fs.open(xfil.toString(_), mode, _);
		} catch (ex) {
			if (mode === "r+") {
				// Try again with w+
				mode = "w+";
				try {
					fd = fs.open(xfil.toString(_), mode, _);
				} catch (ex) {
					op_error(ex);
				}
			} else op_error(ex);
		}
		self.fd = fd;
		self.mode = mode;
		if (seekVal === -1) {
			var stat = fs.fstat(self.fd, _);
			self.offset = stat.size;
		} else {
			self.offset = 0;
		}
		self.mda = 0;
		self.bom = 0;
	}
	x3seek(_, mode, direction, value) {
		const self = this;
		//console.log("Seek " + mode + " " + value + " " + direction+ " typeof value:"+(typeof value));

		switch (mode) {
			case 'FIRST':
				self.offset = value;
				break;
			case 'LAST':
				var stat = fs.fstat(self.fd, _);
				self.offset = stat.size - value;
				break;
			case "CURR":
				self.offset += direction * value; //direction = -1 / 1
				break;
			default:
		}
		//console.log("Result offset " + self.offset);
	}
	x3write(_, vals, nl) {
		const self = this;
		const ifs = self.adxifs || self.ctx.values["ADXIFS"];
		const irs = self.adxirs || self.ctx.values["ADXIRS"];
		const vium = self.adxium || self.ctx.values["ADXIUM"];
		const ium = _ium[vium];

		// bom management

		if (self.mda === 0) {
			self.mda = 2;
			if (vium === 1) {
				var bom = new Buffer([0xef, 0xbb, 0xbf]);
				fs.write(self.fd, bom, 0, bom.length, 0, _);
				self.bom = 3;
			}
		}

		// value to write management
		const newvals = vals.map(v => {
			if (Array.isArray(v)) {
				var t = v[2];
				var r = "";
				if (v[1] > 1) throw new X3Error(26, "More than 1 dimension is not supported");
				var min = v[5] ? v[3] - v[5] : 0;
				var max = v[6] ? v[3] + v[6] - v[5] - 1 : v[4] - v[3];

				for (var i = min; i <= max; i++) {
					if (i !== min) r += ifs;
					r += t[i] ? t[i].x3ToString() : "";
				}
				return r;
			} else return v.x3ToString();
		});
		const str = newvals.join(ifs);

		// write it
		// 2 conditions have to be met in order to make the position parameter work :
		// 1°/ Use a Buffer instead of a string
		// 2°/ Open the file with r+ instead of a

		const buffer = new Buffer(str + (nl ? irs : ifs), ium || "utf8");

		//dbg:console.log("x3write fs.write fd:"+self.fd+" position:"+ self.offset + self.bom);

		const len = fs.write(self.fd, buffer, 0, buffer.length, self.offset + self.bom, _);

		self.offset += len;
		return len;
	}
	x3read(_) {
		const self = this;

		// read parameters

		const ifs = self.adxifs || self.ctx.values["ADXIFS"];
		const irs = self.adxirs || self.ctx.values["ADXIRS"];
		const ium = _ium[self.adxium || self.ctx.values["ADXIUM"]];
		const fium = _fium[ium];

		// tool variables

		var curr = self.offset;
		const cache = new Buffer(500);
		const bom = new Buffer(3);

		var lines;
		var str = "";
		var bck;

		if (self.mda === 0) {
			self.mda = 2;

			if (ium === "utf8") {

				var len = fs.read(self.fd, bom, 0, bom.length, 0, _);
				self.bom = bom[0] === 0xef && bom[1] === 0xbb && bom[2] === 0xbf ? 3 : 0;
			}
		}

		// algo
		var len = fs.read(self.fd, cache, 0, cache.length, curr + self.bom, _);
		if (len === 0) return [];

		while (len > 0) {
			bck = ium === "utf8" ? UT8Backward(cache) : 0;

			str += fium(cache, cache.length - bck);
			lines = str.split(irs);
			if (lines.length > 1) break;
			else {
				curr += len - bck;
				len = fs.read(self.fd, cache, 0, cache.length, curr + self.bom, _);
			}
		}
		// end

		self.offset += ium === "ascii" ? lines[0].length + 1 : byteLength(lines[0] + 1);

		return ifs.length ? lines[0].split(ifs) : [lines[0]];
	}
	x3get(_, size) {
		const self = this;

		self.mda = 1;
		const curr = self.offset;
		const bf = new Buffer(size);
		const len = fs.read(self.fd, bf, 0, bf.length, curr, _);

		if (len === 0) return null;
		self.offset += len;

		return new Blbfile(bf);
	}
	x3put(_, nbr, vals, size) {
		const self = this;

		var i = 0,
		    nbv = 0;
		const vlist = [];

		var tsize = 0;
		const curr = self.offset;

		self.mda = 1;

		// build buffer to write
		while (vals[i]) {
			var v = vals[i];
			if (Array.isArray(v)) {
				var t = v[2];
				if (v[1] > 1) throw new X3Error(26, "More than 1 dimension is not supported");
				var min = v[5] ? v[3] - v[5] : 0;
				var max = v[6] ? v[3] + v[6] - v[5] - 1 : v[4] - v[3];

				for (var j = min; j <= max; j++) {
					var val = (t[j] !== undefined ? t[j] : v[1]).x3Serialize(size[i]);

					tsize += val.length;
					vlist.push(val);
					if (++nbv >= nbr) break;
				}
				if (nbv >= nbr) break;
			} else {
				var val = v.x3Serialize(size[i]);
				tsize += val.length;
				vlist.push(val);
				if (++nbv >= nbr) break;
			}
			i++;
		}
		const bf = Buffer.concat(vlist, tsize);

		// write buffer in file
		//dbg:console.log("x3put fs.write fd:"+self.fd+" position:"+ curr);

		const len = fs.write(self.fd, bf, 0, bf.length, curr, _);

		self.offset += len;
		return len;
	}
	x3close(_) {
		const self = this;

		try {
			fs.close(self.fd, _);
		} catch (ex) {
			throw new X3Error(20, ex.message);
		}
	}
	x3adxseek() {
		const self = this;

		return self.offset;
	}
};

exports.File = File;