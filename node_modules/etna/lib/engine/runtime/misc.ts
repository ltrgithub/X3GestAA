"use strict";

const flows = require('streamline-runtime').flows;
import * as util from './util';
import * as errors from './errors';
const X3Error = errors.X3Error;

export const instructions = {
	CALLJS(mode, ns, name, args) {
		return function calljs$do(_) {
			const nsVal = ns(_);

			var mod, fn;
			try {
				mod = require(nsVal);
			} catch (ex) {
				throw ex.errn ? ex : new X3Error(20, ex.message);
			}
			fn = mod[name];
			if (!fn) throw new X3Error(4, "unknown JS function: " + nsVal + "." + name);
			const vals = args(_);

			switch (mode) {
				case "sync":
					return fn.apply(this, vals);
				case "async":
					return flows.apply(_, fn, this, vals, 0);
				default:
					throw new X3Error(26, "invalid Calljs mode: " + mode);
			}
		};
	},
	BOX(kind, args) {
		const aargs = util.instructions.A(args);

		return function log$do(_) {
			const message = aargs(_).join('\t');
			const logger = kind === 'error' ? console.error : console.log;

			logger(message);
		};
	},

	CLOSEMESBOX() {
		return function closemesbox$do(_) {
			//compilation compatibility
		};
	},

	DBGETNA(args) {
		const aargs = args ? util.instructions.A(args) : null;

		return function dbg$do(_) {
			const val = aargs(_);

			setTimeout(_, val[0] ? val[0] : 5000);
			if ("keep me") debugger;
		};
	},

	SLEEP(args) {
		const aargs = args ? util.instructions.A(args) : null;

		return function sleep$do(_) {
			const val = aargs(_);

			setTimeout(_, 1000 * (val[0] ? val[0] : 1));
		};
	}
};

export const functions = {
	XCRYPT: {
		count: 1,
		fn(key) {
			throw new X3Error(33, "NIY: XCRYPT");
		}
	},
	LEN2: {
		count: 1,
		fn(key) {
			throw new X3Error(33, "NIY: LEN2");
		}
	},
	APPX3: {
		count: 1,
		fn(key) {
			throw new X3Error(33, "NIY: APPX3");
		}
	}
};