import { _ } from 'streamline-runtime';
import * as types from './types';
import * as util from './util';
import { DBTable } from './dbtable';
import { Column } from '../../supervisor/meta/column'
const tracer = require('syracuse-core').getTracer("etna.engine");

export interface QueryKey {
	abbrev: string;
	field: Column;
	index: number;
}

export interface KeyModified {
	length: number;
	direction: number;
}

export interface TableKey {
	func?: string;
	name: string;
	columns?: QueryKey[];
	directions?: number[];
	items?: string[];
	hidden?: boolean;
	unique?: boolean;
	sql?: string;
	constants: any[]; // refine later
	kslot?: number;
	modified?: KeyModified;
}

export interface RowId {} // opaque

export interface KeyExpression { 
	func: ((_: _) => any)[];
	directions: number[];
	items?: string[];
	hidden?: boolean;
}

export class DBTableParent {
	local: number;
	superv: any; // see later
	driver: types.Driver;
	abbrev: string;
	slot: number;
	types: { [name: string]: string };
	values: { [name: string]: any };
	inFrontOf: DBTable;
	sisters: string[]; // abrevs
	currkey: number;
	currlen: number;
	curpos: RowId;
	constructor(driver: types.Driver, abbrev: string, superv: any, loc: number) {
		this.local = loc;
		this.superv = superv;
		this.driver = driver;
		this.abbrev = abbrev;
		this.slot = 0;
		this.types = util.any({});
		this.values = util.any({});
		this.inFrontOf = undefined;
	}

	init(_: _) {
		return this;
	}

	declVar(type: string, name: string) {
		throw new Error("invalid call: abstract method");
	}
	findKey(name: string): TableKey {
		throw new Error("invalid call: abstract method");
	}
	getKeyValues(_: _, k: KeyExpression, lvl: number): any[] {
		throw new Error("invalid call: abstract method");
	}


}
