import { _ } from 'streamline-runtime';
import { Driver } from '../drivers/types';
import * as util from './util';
// quick hack to get around circular dependency issue
import { DBCursor } from './dbcursor';
import { Table } from '../../supervisor/meta/table'
import { Column } from '../../supervisor/meta/column'

const tracer = require('syracuse-core').getTracer("etna.engine");

export interface QueryKey {
	abbrev: string;
	field: Column;
	index: number;
}

export type QueryKeys = util.Dict<QueryKey[]>

export interface KeyModified {
	length: number;
	direction: number;
}

export interface TableKey {
	func?: string;
	name?: string;
	columns?: QueryKey[];
	directions?: number[];
	items?: string[];
	hidden?: boolean;
	unique?: boolean;
	sql?: string;
	constants: any[]; // refine later
	kslot?: number;
	modified?: KeyModified;
}

export interface WKey {
	sql: string;
	type?: string;
	constants?: any[];
	func?: any; // todo refine
	tooComplex?: boolean;
	rowid?: boolean;
	splitable?: boolean;
	columns?: QueryKey[];
	postEvaluation?: boolean;
	isConstant?: boolean;
	field?: string;
	dir?: number;
	item?: string;
}

export interface TableJoin {
	table: DBTableParent;
	constants: any[];
	sql?: string;
}

export interface RowId {} // opaque

export interface KeyExpression { 
	name?: string;
	func?: ((_: _) => any)[];
	directions?: number[];
	items?: string[];
	hidden?: boolean;
	kslot?: number; 
	sql?: string;
	unique?: boolean;
	constants?: any[];
	modified?: KeyModified;
	guide?: number[];
}

interface TableFilter {
	where?: WKey[];
	key?: number; //?
}

export type TableColumns = QueryKeys;

export class DBTableParent {
	local: number;
	superv: any; // see later
	driver: Driver;
	abbrev: string;
	slot: number;
	types: { [name: string]: string };
	values: { [name: string]: any };
	inFrontOf: DBTableParent;
	sisters: string[]; // abrevs
	currkey: number;
	currlen: number;
	curpos: RowId;
	keys: KeyExpression[];
	desc: Table;
	where: WKey[];
	filter: TableFilter;
	joins: TableJoin[];
	columns: QueryKeys;
	master: DBTableParent; /* was DBTable in DBTable */
	currentFor: DBCursor;


	constructor(driver: Driver, abbrev: string, superv: any, loc: number) {
		this.local = loc;
		this.superv = superv;
		this.driver = driver;
		this.abbrev = abbrev;
		this.slot = 0;
		this.types = {};
		this.values = {};
		this.inFrontOf = undefined;
	}

	init(_: _): DBTableParent {
		return this;
	}

	declVar(type: string, name: string) {
		throw new Error("invalid call: abstract method");
	}
	findKey(name: string): KeyExpression {
		throw new Error("invalid call: abstract method");
	}
	getKeyValues(_: _, k: KeyExpression, lvl: number): any[] {
		throw new Error("invalid call: abstract method");
	}
	x3SetNewKey(_: _, newkey: KeyExpression) {
		throw new Error("invalid call: abstract method");
	}
}
