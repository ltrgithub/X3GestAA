import { _ } from 'streamline-runtime';
import * as core from 'syracuse-core';
import { Driver, Hint } from '../drivers/types';
import { RowId, KeyExpression, WKey, TableJoin, TableFilter, QueryKeys } from './types';
import * as util from './util';
import { DBCursor } from './dbcursor';
import { Table } from '../../supervisor/meta/table';
import { Column } from '../../supervisor/meta/column';
import { ContextFn } from './types';

const tracer = core.getTracer("etna.engine");

export class DBTableParent {
	local: number;
	superv: any; // see later
	driver: Driver;
	abbrev: string;
	slot: number;
	types: { [name: string]: string };
	values: { [name: string]: any };
	inFrontOf: DBTableParent;
	sisters: string[]; // abrevs
	currkey: number;
	currlen: number;
	curpos: RowId;
	keys: KeyExpression[];
	desc: Table;
	where: WKey[];
	filter: TableFilter;
	joins: TableJoin[];
	columns: QueryKeys;
	master: DBTableParent; /* was DBTable in DBTable */
	currentFor: DBCursor;


	constructor(driver: Driver, abbrev: string, superv: any, loc: number) {
		this.local = loc;
		this.superv = superv;
		this.driver = driver;
		this.abbrev = abbrev;
		this.slot = 0;
		this.types = {};
		this.values = {};
		this.inFrontOf = undefined;
	}

	init(_: _): DBTableParent {
		return this;
	}

	declVar(type: string, name: string) {
		throw new Error("invalid call: abstract method");
	}
	findKey(name: string): KeyExpression {
		throw new Error("invalid call: abstract method");
	}
	getKeyValues(_: _, k: KeyExpression, lvl: number): any[] {
		throw new Error("invalid call: abstract method");
	}
	x3SetNewKey(_: _, key: KeyExpression, lvl: number) {
		throw new Error("invalid call: abstract method");
	}
	x3OpenFor(_: _, key: KeyExpression, lvl: number, hint: Hint, lock: boolean, where?: ContextFn<WKey[]>, wfrom?: ContextFn<WKey[]>, wto?: ContextFn<WKey[]>): DBCursor {
		throw new Error("invalid call: abstract method");		
	}
}
