import { _ } from 'streamline-runtime';

import * as types from './types';
import * as errors from './errors';
import { ParseNode } from '../compilers/nodes';

/* 
 * Line numbers
 */
// _sourceLoc and _sourceFile are set at 'require' time
// _sourceLoc is incremented as we load statements

var _sourceFile: string = null;
var _moduleName: string = null;
export var sourceLoc = {
	module: _moduleName,
	file: _sourceFile,
	line: 0,
	strict: false
};

export const instructions = {
	C(x: any): types.Expression<any> {
		const fn: any = function c$do(_: _) {
			//console.log(x);
			return x;
		};

		fn.value = x;
		return fn;
	},
	A(items: types.Expression<any>[], forget?: boolean) {
		return function a$do(_: _) {
			const results: any[] = !forget && [];

			for (var i = 0; i < items.length; i++) {
				var item = items[i];
				var v = item.value !== undefined ? item.value : item(_);
				results && results.push(v);
			}
			return results;
		};
	},
	NIY(node: ParseNode): types.Expression<any> {
		return function niy$do(_: _) {
			throw new errors.X3Error(33, "NIY: " + (node && node.tag));
		};
	},
	BEGIN(mod: NodeModule) {
		_sourceFile = mod.filename.replace(/\.js$/, ".src");
		_moduleName = mod.filename.replace(/[\/\/]([^\/\/]*).js$/, "$1");
	},
	NL(delta: number): any {
		sourceLoc = {
			file: _sourceFile,
			module: _moduleName,
			line: delta ? sourceLoc.line + delta : 1,
			strict: sourceLoc.strict
		};
		return null;
	}
};
