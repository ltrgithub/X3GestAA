"use strict";

const glob = require('streamline/lib/globals');
const errors = require('./errors');
const X3Error = errors.X3Error;
const date = require('etna/lib/engine/runtime/tdate');
const datetime = require('etna/lib/engine/runtime/tdatetime');
const x3Trim = require('etna/lib/engine/runtime/util').x3Trim;
const util = require('./util');
const locale = require('streamline-locale');
const resources = locale.resources(module);


function _isLower(ch) {
	return ch >= 'a' && ch <= 'z';
}

function _isUpper(ch) {
	return ch >= 'A' && ch <= 'Z' || ch == ' ';
}

function _isDigit(ch) {
	return ch >= '0' && ch <= '9';
}

function _isHexa(ch) {
	return ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f' || ch >= '0' && ch <= '9';
}

function _fmtInt(val, rep) {
	var s = val.toString();
	while (s.length < rep) s = "0" + s;
	return s;
}

/*
function _year( val ) {
	return val.utcYear || val.year ;
}

function _day( val ) {
	return val.utcDay || val.day ;
}

function _month( val ) {
	return val.utcMonth || val.month ;
}

function _hour( val ) {
	return val.utcHour || val.hour ;
}

function _minute( val ) {
	return val.utcMinute || val.minute ;	
}

function _second( val ) {
	return val.utcSecond || val.second ;	
}

function _millisecond( val ) {
	return val.utcMillisecond || val.millisecond ;
}
*/

const _months3 = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];


function _monthName(month, rep) {
	// for now, get it from JS resource and capitalize (wrong for French!)
	var s = date.monthName(month) || ' ';
	s = s[0].toUpperCase() + s.substring(1);
	while (s.length < rep) s += ' ';
	return s.length > rep ? s.substring(0, rep) : s;
}

exports.format = function ($fmt, $val) {
	//dbg:console.error("format fmt:"+$fmt+" val:"+$val);
	var val = $val; //local copy for making it possible to write val = '';
	var fmt = $fmt;
	if (fmt.indexOf(':') < 0) {
		if (util.x3IsDate(val) || util.x3IsDatetime(val)) {
			fmt = resources()[fmt] || fmt;
		} else {
			fmt = "K:" + fmt;
		}
	}

	var options = {},
	    i = 0,
	    ch,
	    rep;
	var valid = true,
	    bad = ' ';
	var len = fmt.length,
	    j = 0,
	    result = "",
	    pwc,
	    now,
	    integ,
	    decim = "",
	    tail = "",
	    cur,
	    n3 = 0;

	var isDigit;
	const values = glob.context.x3frame.context.sys.values;
	const special = values.ADXSCA;
	const adxtul = values.ADXTUL ? values.ADXTUL[2] : "";
	const adxtuc = values.ADXTUC ? values.ADXTUC[2] : "";
	const adxtut = values.ADXTUC ? values.ADXTUT[2] : "";
	const Kformatters = {
		'X': function (vch) {
			return vch;
		},
		'A': function (vch) {
			if (!_isUpper(vch)) {
				if (_isLower(vch) && !options.A) vch = vch.toUpperCase();
				else valid = false;
			}
			return vch;
		},
		'a': function (vch) {
			if (!_isLower(vch)) {
				if (_isUpper(vch) && !options.A) vch = vch.toLowerCase();
				else valid = false;
			}
			return vch;
		},
		'B': function (vch) {
			if (!_isUpper(vch) && !_isDigit(vch)) {
				if (_isLower(vch) && !options.A) vch = vch.toUpperCase();
				else valid = false;
			}
			return vch;
		},
		'b': function (vch) {
			if (!_isLower(vch) && !_isDigit(vch)) {
				if (_isUpper(vch) && !options.A) vch = vch.toLowerCase();
				else valid = false;
			}
			return vch;
		},
		'C': function (vch) {
			if (!_isLower(vch) && !_isUpper(vch) && !_isDigit(vch)) {
				valid = false;
			}
			return vch;
		},
		'L': function (vch) {
			if (!_isLower(vch) && !_isUpper(vch)) {
				valid = false;
			}
			return vch;
		},
		'H': function (vch) {
			if (!_isHexa(vch)) {
				valid = false;
			}
			return vch;
		},
		' ': function (vch) {
			if (ch !== ' ') {
				valid = false;
			}
			return vch;
		},
		'#': function (vch) {
			isDigit = isDigit || _isDigit(vch);
			if (!isDigit) {
				valid = false;
			}
			return vch;
		}

	};
	const formatters = {
		K() {
			if (util.x3IsClbfile(val)) val = val.value;
			if (!util.x3IsString(val)) val = "";

			for (; rep > 0; rep--) {
				var vch = val[j++];
				var defined = vch != null;
				vch = vch || ' ';
				//dbg:console.error("Kformatters "+ch);
				var fk = Kformatters[ch];
				if (fk) vch = fk.call(this, vch);
				else {
					// search ch in adxtul
					var pos = adxtul.indexOf(ch);
					if (pos >= 0) {
						// backup valid:
						var validSvg = valid;
						for (var i = 0; i < adxtut[pos].length; i++) {
							var tut = adxtut[pos][i];
							fk = Kformatters[tut];
							if (fk) {
								// backup valid:
								valid = true;
								vch = fk.call(this, vch);
								if (valid) {
									break;
								}
							}
						}
						if (!valid) {
							// search in adxtuc
							valid = false;
							for (var i = 0; i < adxtuc[pos].length; i++) {
								if (vch == adxtuc[pos][i]) {
									valid = true;
									break;
								}
							}
						}
						valid = valid ? validSvg : valid;
					} else throw new X3Error(5, $fmt + " (215) bad format character: " + ch);
				}
				if (pwc && defined) vch = pwc;
				result += vch;
			}
		},
		N() {
			if (!val.x3IsNumeric()) return;
			if (cur !== null && '#F'.indexOf(ch) < 0) {
				ch = '#';
				i--; // backtrack
			}
			switch (ch) {
				case '#':
					if (cur === integ) {
						// allow thousand seps can overflow (weird!)
						rep += n3;
						if (cur.length < rep) {
							var fill = options['*'] ? special[5] : options['0'] ? '0' : ' ';
							if (fill === '0' && cur[0] === '-') {
								result += '-';
								cur = cur.substring(1);
								rep--;
							}
							while (cur.length < rep--) result += fill;
							result += cur;
						} else if (cur.length === rep) {
							result += cur;
						} else {
							result += cur.substring(0, rep);
							valid = false;
						}
						cur = null;
					} else if (cur === decim) {
						if (cur.length < rep) {
							// X3 engine does not follow spec: Z option is now set by default
							var fill = '0'; //options['Z'] ? '0' : ' ';
							result += cur;
							while (cur.length < rep--) result += fill;
						} else {
							result += cur.substring(0, rep);
						}
						cur = null;
					} else {
						throw new X3Error(5, "too many # directives in format");
					}
					break;
				case '.':
					result += special[3];
					cur = decim;
					break;

				default:
					throw new X3Error(5, $fmt + " (271) bad format character: " + ch);

			}
		},
		D() {
			const _year = val.utcYear || val.year;
			const _month = val.utcMonth || val.month;
			const _day = val.utcDay || val.day;
			const _hour = val.utcHour || val.hour;
			const _minute = val.utcMinute || val.minute;
			const _second = val.utcSecond || val.second;

			switch (ch) {
				case 'D':
					result += _fmtInt(_day, rep);
					break;
				case 'M':
					if (rep <= 2) {
						result += _fmtInt(_month, rep);
					} else if (rep === 3) {
						result += _months3[_month - 1];
					} else {
						result += _monthName(_month, rep);
					}
					break;
				case 'Y':
					result += _fmtInt(rep <= 2 ? _year % 100 : _year, rep);
					break;
				case 'h':
					result += _fmtInt(_hour || (now = now || datetime.now()).hour, rep);
					break;
				case 'm':
					result += _fmtInt(_minute || (now = now || datetime.now()).minute, rep);
					break;
				case 's':
					result += _fmtInt(_second || (now = now || datetime.now()).second, rep);
					break;
				default:
					throw new X3Error(5, $fmt + ": (309) bad format character: " + ch);
			}
		},
		L() {
			result += "?";
		}
	};
	const tch = fmt[0];

	var fn = formatters[tch];
	if (fn) {
		for (i = 1; i < fmt.length && (ch = fmt[i]) !== ':'; i++) {
			switch (ch) {
				case 'v':
					// 0 is the default value
					options.v = /[0-5]/.test(fmt[i + 1]) ? parseInt(fmt[++i]) : 0;
					break;
				default:
					options[ch] = true;
					break;
			}
		}
		i++;
	} else {
		fn = formatters.K;
	}
	if (tch === 'N') {
		if (options['+'] && val < 0) val = 0;
		integ = val.x3ToString();
		// TODO: handle scientific format
		var dot = integ.indexOf('.');
		if (dot >= 0) {
			decim = integ.substring(dot + 1);
			integ = integ.substring(0, dot);
		}
		if (integ[0] === '-' || integ[0] === '+') {
			if (options.D) {
				tail = integ[0];
				integ = integ.substring(1);
			}
		} else {
			if (options['-']) {
				if (options.D) tail = '+';
				else integ = '+' + integ;
			}
		}
		var savInteg = integ;
		if (options["3"]) {
			// insert thousand separators
			n3 = Math.floor((integ.length - (/\d/.test(integ[0]) ? 0 : 1) - 1) / 3);
			for (var k = 0; k < n3; k++) {
				var l = integ.length - 4 * k - 3;
				integ = integ.substring(0, l) + special[2] + integ.substring(l);
			}
		}
		cur = integ;
		bad = special[4];
	}
	pwc = options.X && special[5];
	while (i < len) {
		var beg = i,
		    ch;
		if ((ch = fmt[i]) === '[') {
			i = fmt.indexOf(']', i + 1);
			if (i < 0) i = len;
			var comment = fmt.substring(beg + 1, i);
			result += options.B ? comment.replace(/./g, ' ') : comment;
			i++;
			continue;
		}
		while ((ch = fmt[i]) >= '0' && ch <= '9') i++;
		rep = i > beg ? parseInt(fmt.substring(beg, i), 10) : 1;
		while (ch && ch === fmt[i + 1]) {
			i++;
			rep++;
		}
		i++;
		if (ch == 'F') {
			// Recompute the format if ch='F' in order to reuse the n.m# syntax :
			var _fmt = '';
			if (!decim.length && options["3"]) {
				// Th option '3' isn't supported by integer values:
				integ = savInteg;
				cur = integ;
				n3 = 0;
				options["3"] = null;
			}
			if (!decim.length || integ.length >= rep) {
				_fmt = rep + '#';
			} else if (integ.length + 1 + decim.length >= rep) {
				_fmt = integ.length + '.' + (rep - 1 - integ.length);
			} else {
				_fmt = rep - 1 - decim.length + '.' + decim.length;
			}

			len += _fmt.length;
			fmt = fmt.substring(0, i) + _fmt + fmt.substring(i + 1);
			continue;
		}
		fn.call(this);
	}
	if (tail) result += tail;

	//dbg:console.error("val:"+$val+" fmt:"+$fmt+ " result:'"+result + "' valid:"+valid);

	if (valid) {
		if (options.z && val.x3IsZero && val.x3IsZero()) result = result.replace(/./g, ' ');
		if (fmt[0] == 'N' && options["3"]) result = result.replace(/^(?:\s*)(\.{1})/, match => match.substring(0, match.length - 1));
		if (fmt[0] == 'D' && val.x3IsZero && val.x3IsZero()) result = result.replace(/0/g, ' ');
	} else {
		if (fmt[0] == 'N') {
			if (options.z) {
				// remove thousand separators (weird!)
				if (options["3"]) result = result.substring(0, result.length - n3);
				result = result.replace(/./g, ' ');
			} else result = result.replace(/[0-9]/g, bad);
		} else result = result.replace(/./g, bad);
	}
	//dbg:console.error("format fmt:"+$fmt+" val:"+$val+" result:'"+result + "' options:"+JSON.stringify(options));
	return x3Trim(result, options.v);
};

const mapFormat = {
	K: {
		X: ".",
		a: "a-z",
		A: "A-Z",
		B: "A-Z0-9",
		b: "a-z0-9",
		C: "a-zA-Z0-9",
		L: "a-zA-Z",
		H: "0-9A-Fa-f",
		' ': "\\\s",
		'#': "0-9"
	}
};


exports.fromX3FormatToRegex = function (format) {
	const parts = format.split(':');
	const map = mapFormat[parts[0][0]];
	const values = glob.context.x3frame.context.sys.values;
	const adxtul = values.ADXTUL ? values.ADXTUL[2] : "";
	const adxtuc = values.ADXTUC ? values.ADXTUC[2] : "";
	const adxtut = values.ADXTUC ? values.ADXTUT[2] : "";
	// console.log("fromX3FormatToRegex:",values.ADXTUL)

	for (var i = 0; i < adxtul.length; i++) {
		mapFormat.K[adxtul[i]] = adxtut[i].split('').reduce((r, c) => {
			r.push(mapFormat.K[c]);
			return r;
		}, []).join('');
		mapFormat.K[adxtul[i]] += adxtuc[i];
	}
	var exp = "";
	if (map) {
		var rep = 0;
		exp = '^' + parts[1].split('').reduce((r, ch) => {
			if (_isDigit(ch)) {
				rep = 10 * rep + parseInt(ch);
			} else {
				var e = map[ch];
				if (!e) {
					console.error("fromX3FormatToRegex ch:" + ch + " map", map);
					r.push(".*");
					return r;
				}
				if (e.indexOf('-') >= 0) e = '[' + e + ']';
				r.push(e + '{0,' + (rep || 1) + '}');
				rep = 0;
			}
			return r;
		}, []).join('') + "\\\s*$";
	}
	//dbg:console.log(format+" => "+exp);
	return new RegExp(exp);
};