"use strict";

import { X3Error } from './errors';
import * as util from './util';
const SIGN = 0; // 0 if negative, 1 if positive

const LEN = 1; // number of elements in mantissa

const POW100 = 2; // number of digit pairs (100s) in scale offset by 64.

const BASE = 3; // base index of mantissa

const MAX00 = 16;
const SIZE = BASE + MAX00;
const MAXDBL = 1e80;
const MINDBL = 1e-79;
const SPREC = 6;
const DPREC = 10;
const FLOATPREC = 1000000000.0;
const EPSILON = 0.0000000001;
const MAXESG4 = 0x7fffffff;
const MINESG4 = -0x80000000;
const TypedArray = Uint8Array;
//var TypedArray = Buffer;

export function isBCD(val: any) {
	return val instanceof TypedArray;
};

const ZEROES = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

export type BCD = number[];

function alloc(size: number) {
	return ZEROES.slice(0, size);
	//@ var arr = new TypedArray(size);
	//@ //for (var i = 0; i < size; i++) arr[i] = 0xfe;
	//@ return arr;
}

function getSign(bcd: BCD) {
	if (bcd[LEN] == 0) return 0;

	return bcd[SIGN] == 0 ? -1 : 1;
}

function toggleSign(bcd: BCD) {
	if (bcd[LEN] != 0) bcd[SIGN] ^= 1;
}

// can bcd be coerced to int32 without loss

export function isInt32(bcd: BCD, opt?: number) {
	//	Test Overflow
	if (bcd[POW100] > 64 + 5) return false;
	if (bcd[POW100] == 64 + 5) {
		if (compare(bcd, MAX_INT32) > 0) return false;
		if (compare(bcd, MIN_INT32) < 0) return false;
	}

	//	Is it integer?
	return opt == 0 || bcd[POW100] - 64 >= bcd[LEN] || bcd[LEN] == 0;
};

function isSpace(s: string) {
	return (/^\s$/.test(s));
}

function isDigit(s: string) {
	return (/^\d$/.test(s));
}

const ASCII_0 = '0'.charCodeAt(0);

function fillMantissa(digits: string, mantissa: number[], odd: number) {
	var i = 0,
	    j = 0;
	var dgt = 0;

	while (i < digits.length || dgt !== 0) {
		if (i < digits.length) dgt += digits.charCodeAt(i++) - ASCII_0;
		if ((odd & 1) != 0) {
			mantissa[j++] = dgt;
			dgt = 0;
		} else dgt *= 10;
		odd++;
	}
	return Math.floor(odd / 2);
}

function mantissaString(mantissa: number[], cnt: number) {
	var str = '';
	for (var i = 0; i < cnt; i++) {
		var d = mantissa[i];
		str += d < 10 ? '0' + d : d;
	}
	return str;
}

function memcopy(src: number[], i: number, dst: number[], j: number, len: number) {
	while (len-- > 0) dst[j++] = src[i++];
}

function memcompare(s1: number[], i1: number, s2: number[], i2: number, len: number) {
	var diff = 0;
	while (len-- > 0 && diff === 0) diff = s1[i1++] - s2[i2++];
	return diff;
}

function make(sign: boolean, pow100: number, mantissa: number[], len: number) {
	//	Virer les 0 de Trop
	var i = len;
	while (len > 0 && mantissa[--i] === 0) --len;
	var beg = 0;
	while (len > 0 && mantissa[beg] === 0) --pow100, --len, ++beg;

	if (len > MAX00) {
		i = beg + MAX00;
		if (mantissa[i] >= 50) {
			// Round up
			while (++mantissa[--i] >= 100 && i >= beg) mantissa[i] = 0;
		}
		if (i < beg) ++pow100, mantissa[beg] = 1; // ??
		len = MAX00;
	}

	//	Test numeric overflow
	if (pow100 > 63 && len > 0) throw new X3Error(13, "decimal overflow");

	if (len === 0 || pow100 < -64) pow100 = 0, sign = true, len = 0; //	 Zero
	const bcd = alloc(BASE + len);

	bcd[SIGN] = sign ? 1 : 0;
	bcd[LEN] = len;
	bcd[POW100] = pow100 + 64;
	if (len > 0) memcopy(mantissa, beg, bcd, BASE, len);
	return bcd;
}

export function abs(bcd: BCD) {
	if (bcd[SIGN] === 1) return bcd;
	else {
		var result = clone(bcd);
		result[SIGN] = 1;
		return result;
	}
};

export function minus(bcd: BCD) {
	const result = clone(bcd);

	result[SIGN] = bcd[SIGN] ? 0 : 1;
	return result;
};

// Transforme une Chaine en bcd
//int fromString(s_bcd bcd[], char str[]) //	Chaine a Analyser

export function toBuffer(bcd: BCD) {
	const b = new Buffer(20);

	b.writeUInt16BE(bcd[POW100], 0);
	b.writeUInt8(bcd[SIGN], 2);
	b.writeUInt8(bcd[LEN], 3);
	for (var i = 0; i < SIZE - BASE; i++) b.writeUInt8(bcd[i + BASE] !== undefined ? bcd[i + BASE] : 0, i + 4);
	return b;
};

export function fromBuffer(bf: Buffer) {
	const pow = bf.readUInt16BE(0);
	const sign = bf.readUInt8(2);
	const len = bf.readUInt8(3);
	const bcd = alloc(BASE + len);

	bcd[SIGN] = sign;
	bcd[LEN] = len;
	bcd[POW100] = pow;
	for (var i = 0; i < len; i++) bcd[i + BASE] = bf.readUInt8(4 + i);
	return bcd;
};

export function fromString(str: string) {
	var i = 0;
	var sign = '+';

	// skip leading spaces
	while (isSpace(str[i])) i++;
	var beg = i;

	// handle sign
	if (str[i] === '-' || str[i] === '+') sign = str[i++];

	// mantissa
	var buf = '',
	    gotDot = false,
	    pow10 = 0;
	for (; isDigit(str[i]) || str[i] === '.'; i++) {
		if (str[i] === '.') {
			if (gotDot) break;
			gotDot = true;
			continue;
		}

		//	zeros after dot matter
		if (str[i] === '0' && buf.length === 0) {
			if (gotDot) --pow10;
			continue;
		}

		//	store the digit
		if (buf.length < 2 * MAX00) buf += str[i];

		//	increment pow10
		if (!gotDot) ++pow10;
	}

	// optional exponent
	if (i != beg && (str[i] == 'e' || str[i] == 'E')) {
		++i;
		pow10 += parseInt(str.substring(i), 10);
	}

	// empty string
	if (i == beg) return ZERO;

	const mantissa = alloc(17);
	const len = fillMantissa(buf, mantissa, pow10 & 1);

	return make(sign !== '-', (pow10 + 1 & ~1) / 2, mantissa, len);
};

export function fromDouble(dbl: number) {
	return fromString("" + dbl.toFixed(10));
};

export function isZero(val: BCD) {
	return compare(fromInt32(0), val) === 0 ? 1 : 0;
};

function clone(bcd: BCD) {
	const cl = alloc(SIZE);

	memcopy(bcd, 0, cl, 0, SIZE);
	return cl;
}

export function truncate(bcd: BCD, scale: number) {
	scale = scale || 0;
	var len = Math.floor((scale + 1) / 2) + (bcd[POW100] - 64);
	if (len > bcd[LEN]) return bcd;
	bcd = clone(bcd);
	if (len > 0 && (scale & 1) !== 0) bcd[BASE + len - 1] = Math.floor(bcd[BASE + len - 1] / 10) * 10;

	// remove trailing zeros
	while (len > 0 && bcd[BASE + len - 1] === 0) len--;

	if (len <= 0) {
		bcd[POW100] = 64;
		bcd[LEN] = 0;
	} else bcd[LEN] = len;
	return bcd;
};

//		Comparaison de 2 bcd
// int compare(s_bcd bcd1[], s_bcd bcd2[])

export function compare(bcd1: BCD, bcd2: BCD) {
	var res = 0;
	const len1 = bcd1[LEN],
	      len2 = bcd2[LEN];

	if (len2 == 0) res = len1 == 0 ? 0 : 1;
	else if (bcd1[SIGN] != bcd2[SIGN]) res = 1;

	else if (len1 == 0) res = -1;

	else if (bcd1[POW100] < bcd2[POW100]) res = -1;

	else if (bcd1[POW100] > bcd2[POW100]) res = 1;

	else {
		var st = len1 - len2;
		res = memcompare(bcd1, BASE, bcd2, BASE, st < 0 ? len1 : len2);
		if (res === 0 && st !== 0) res = st > 0 ? 1 : -1;
	}
	return bcd1[SIGN] ? res : -res;
};

function expString(bcd: BCD, pow100: number, len: number): string {
	bcd = clone(bcd);
	var exp = 2 * (pow100 - 1);
	bcd[POW100] = 1 + 64;
	var s = toString(bcd);
	if (bcd[LEN] === 1) s += '.0';
	if (bcd[BASE] >= 10) {
		// leave only one digit before decimal point.
		s = s.replace(/^(-?\d)(\d)\.?/, (all: string, s1: string, s2: string) => s1 + '.' + s2);
		exp++;
	}
	var l = s.length;
	while (s[l - 1] === '0' && s[l - 2] !== '.') l--;
	if (s[l - 1] === '0' && s[l - 2] === '.') l -= 2;
	if (l < s.length) s = s.substring(0, l);
	return s + "e" + exp;
}

export function toString(bcd: BCD) {
	if (bcd[LEN] === 0) return '0';

	var s = bcd[SIGN] ? '' : '-';
	var len = bcd[LEN],
	    pow100 = bcd[POW100] - 64;

	// switch to exponential notation when abs value is >= 1e32 or < 1e-12
	// the low bound (1e-12) may need review
	if (pow100 > 16 || pow100 <= -6) return expString(bcd, pow100, len);

	if (pow100 > 0) {
		s += bcd[BASE];
		for (var i = 1; i < pow100; i++) {
			if (i < len) {
				var v = bcd[BASE + i];
				s += v < 10 ? '0' + v : v;
			} else {
				s += "00";
			}
		}
	} else {
		s += '0';
	}
	if (pow100 >= len) return s;
	s += '.';
	while (pow100 < 0) {
		s += '00';
		pow100++;
	}
	var v: number;
	for (var i = pow100; i < len - 1; i++) {
		v = bcd[BASE + i];
		s += v < 10 ? '0' + v : v;
	}
	v = bcd[BASE + len - 1];

	s += v % 10 === 0 ? v / 10 : v < 10 ? '0' + v : v;

	return s;
};

export function toInt32(bcd: BCD) {
	//	Differents Test d'Overflow
	if (!isInt32(bcd, 0)) throw new X3Error(50, "toInt32");

	var l = 0,
	    pow100 = bcd[POW100] - 64,
	    len = bcd[LEN];
	for (var i = 0; i < pow100; i++) {
		l *= 100;
		if (i < len) l += bcd[BASE + i];
	}
	return bcd[SIGN] === 0 ? -l : l;
};

export function fromInt32(val: number) {
	var sign = true;

	if (val < 0) {
		val = -val;
		sign = false;
	}

	const dgt = alloc(6);

	dgt[5] = 0;
	for (var i = 4; i >= 0; --i) {
		dgt[i] = val % 100;
		val = Math.floor(val / 100);
	}

	return make(sign, 5, dgt, 5);
};

export function toDouble(bcd: BCD) {
	const str = toString(bcd);
	const val = parseFloat(str);

	if (val === Infinity || val === -Infinity) throw new X3Error(13, "toDouble: " + val);
	return val;
};

function addOrSub(bcd1: BCD, bcd2: BCD, sub: number) {
	// compare absolute values
	// save and restore sign around compare op
	const sign1 = bcd1[SIGN];

	var sign2 = bcd2[SIGN];
	bcd1[SIGN] = bcd2[SIGN] = 1;
	const cmp = compare(bcd1, bcd2);

	bcd1[SIGN] = sign1;
	bcd2[SIGN] = sign2;

	sign2 ^= sub;

	var sign: number, big: BCD, small: BCD;
	if (cmp < 0) sign = sign2, small = bcd1, big = bcd2;
	else sign = sign1, small = bcd2, big = bcd1;

	if (sign1 != sign2) return internalSub(sign === 1, big, small);
	else return internalAdd(sign === 1, big, small);
}

export function add(bcd1: BCD, bcd2: BCD) {
	return addOrSub(bcd1, bcd2, 0);
};

export function sub(bcd1: BCD, bcd2: BCD) {
	return addOrSub(bcd1, bcd2, 1);
};

// bcd1 et bcd2 have same sign and abs(bcd1) > abs(bcd2)

function internalAdd(sign: boolean, bcd1: BCD, bcd2: BCD) {
	const sum = alloc(MAX00 + 2); // 2 for overflow and guard

	const len1 = bcd1[LEN],
	      len2 = bcd2[LEN];

	// shift mantissa of smaller one

	const dif = bcd1[POW100] - bcd2[POW100];

	var len = dif + len2;
	if (len < len1) len = len1;
	if (len > MAX00 + 1) len = MAX00 + 1;
	len++; // for the carry
	sum[0] = 0;
	memcopy(bcd1, BASE, sum, 1, len1);
	for (var i = 1 + len1; i < sum.length; i++) sum[i] = 0;

	// recompute the relevant part of bcd2
	//	   (if len2 > MAX00, len-dif < len2) we should round
	var i = len - dif - 1;
	if (i > len2) i = len2;

	var j = i + dif; // sum index
	var k = BASE + i - 1; // bcd2 index
	var carry = 0;

	while (k >= BASE) {
		var dgt = sum[j] + bcd2[k] + carry;
		carry = 0;
		if (dgt >= 100) ++carry, dgt -= 100;
		sum[j--] = dgt;
		k--;
	}

	if (carry) {
		while (++sum[j] >= 100) sum[j--] = 0;
	}

	return make(sign, bcd1[POW100] - 64 + 1, sum, len);
}

// bcd1 et bcd2 have same sign and abs(bcd1) > abs(bcd2)

function internalSub(sign: boolean, bcd1: BCD, bcd2: BCD) {
	const sum = alloc(MAX00 + 2); // 2 for overflow and guard

	const len1 = bcd1[LEN],
	      len2 = bcd2[LEN];

	// shift mantissa of smaller one

	const dif = bcd1[POW100] - bcd2[POW100];

	var len = dif + len2;
	if (len < len1) len = len1;
	if (len > MAX00 + 1) len = MAX00 + 1;

	memcopy(bcd1, BASE, sum, 0, len1);
	for (var i = len1; i < sum.length; i++) sum[i] = 0;

	// recompute the relevant part of bcd2
	//	   (if len2 > MAX00, len-dif < len2) we should round
	i = len - dif;
	if (i > len2) i = len2;

	var j = i + dif - 1; // sum index
	var k = BASE + i - 1; // bcd2 index
	var carry = 0;

	while (k >= BASE) {
		var dgt = sum[j] - bcd2[k] + carry;
		if (dgt < 0) carry = -1, dgt += 100;
		else carry = 0;

		sum[j--] = dgt;
		k--;
	}

	if (carry != 0) {
		while (sum[j]-- == 0) sum[j--] = 99;
	}

	return make(sign, bcd1[POW100] - 64, sum, len);
}

export function multiply(bcd1: BCD, bcd2: BCD) {
	const prod = alloc(MAX00 + MAX00);

	for (var i = 0; i < prod.length; i++) prod[i] = 0;
	const len1 = bcd1[LEN],
	      len2 = bcd2[LEN];
	const len = len1 + len2; // max length

	for (var i = len1 - 1; i >= 0; i--) {
		for (var j = len2 - 1; j >= 0; j--) {
			var dgt = bcd1[BASE + i] * bcd2[BASE + j];
			for (var k = i + j + 1; dgt != 0; k--) {
				dgt += prod[k];
				prod[k] = dgt % 100;
				dgt = Math.floor(dgt / 100); //	store carry into dgt
			}
		}
	}
	return make(bcd1[SIGN] == bcd2[SIGN], bcd1[POW100] - 64 + bcd2[POW100] - 64, prod, len);
};

function raz(arr: BCD) {
	for (var i = 0; i < arr.length; i++) arr[i] = 0;
}

export function divide(bcd1: BCD, bcd2: BCD) {
	const len1 = bcd1[LEN],
	      len2 = bcd2[LEN];
	const numer = alloc(MAX00 + MAX00 + 2);
	const quotient = alloc(MAX00 + 2); // includes guarad

	const denom = alloc(MAX00 + 2);

	// divide by 0

	if (len2 == 0) throw new X3Error(53, "division by zero");

	// leave one leading digit
	raz(numer);
	raz(denom);
	memcopy(bcd1, BASE, numer, 1, len1);
	memcopy(bcd2, BASE, denom, 1, len2);

	//	Take 2 numbers from denom to limit error on quotient to 1
	var divor = bcd2[BASE] * 100;
	if (len2 > 1) divor += bcd2[BASE + 1];

	for (var i = 0; i < MAX00 + 2; i++) {
		// 3 numbers from numer are necessary and sufficient to estimate quotient
		var num = numer[i] * 100 + numer[i + 1];
		num = num * 100 + numer[i + 2];
		var quo = Math.floor(num / divor);
		quotient[i] = quo;
		if (quo === 0) continue;

		//	subtract denom * quotient from numer
		var dgt = 0;
		var k = i + len2;
		for (var j = len2; j >= 0; j--, k--) {
			dgt += 10000 + numer[k] - quo * denom[j];
			numer[k] = dgt % 100;
			dgt = Math.floor(dgt / 100); //	propagate negative carry
			dgt -= 100;
		}

		// wasn't dgt too big
		if (dgt < 0) {
			// add one denom
			--quotient[i];
			dgt = 0;
			k = i + len2;
			for (j = len2; j >= 0; j--, k--) {
				dgt += numer[k] + denom[j];
				numer[k] = dgt % 100;
				dgt = Math.floor(dgt / 100);
			}
		}
	}

	return make(bcd1[SIGN] == bcd2[SIGN], bcd1[POW100] - bcd2[POW100] + 1, quotient, i);
};
/*
//		Emule ecvt/fcvt selon la valeur de flg (0/1)
//static int bcdcvt(
//	char		dbf[],			//	Buffer Resultat
//	s_bcd		*bcd,			//	bcd a Convertir
//	int			ndg,			//	Nombre de Digit
//	int			*dpt,			//	Renvoi du Point Decimal
//	int			*sign)			//	Renvoi du Signe

function bcdcvt(dbf, bcd, ndg, dpt, sign) {
	char * pt; //	Pointeur de Travail
	char * ep;
	int mlg; //	Num digits in decimal
	//	S'allouer la Taille
	if (ndg > 200) return err_adx(ERDOM, "");
	if (ndg < 0) ndg = 0;

	pt = dbf;

	//	Retourner l'Information sur le Signe
	sign[0] = (bcd[SIGN] == 0);

	//	Position du Point Decimal
	if (iszbcd(bcd)) dpt[0] = 0;
	else dpt[0] = (bcd[POW100] - 64) * 2;

	//	Unpack de la valeur Decimale
	ep = mantissaString(bcd - > bcd_mn, bcd[LEN], dbf);
	mlg = bcd[LEN] * 2;

	//	Reajustement des Differentes Valeurs
	if ( * pt == '0')++pt, --mlg, --(dpt[0]);

	if (ndg > mlg) memset(ep, '0', ndg - mlg); //	Pad avec des 0
	else if (ndg < mlg) {
		//	Arrondi
		ep = pt + ndg;
		for ( * ep += 5;
		( * ep > '9') && (ep > pt); ++( * (--ep))) * ep = '0';
		if ( * ep > '9') { * ep = '1';
			(dpt[0])++;
		}
	}

	pt[ndg] = 0; // terminate string
	return (int)(pt - dbf);
} */

export const ZERO: BCD = fromString('0');
export const ONE_HALF = fromString('0.5');
export const ONE = fromString('1');
export const MAX = fromDouble(MAXDBL * (1 - 1 / FLOATPREC));
export const MIN = fromDouble(-MAXDBL * (1 - 1 / FLOATPREC));
export const MAX_INT32 = fromInt32(MAXESG4);
export const MIN_INT32 = fromInt32(MINESG4);

/*
export const instructions = {
	DECIMAL( v ) {
		return util.instructions.C(fromString(v)) ;
	}
};
*/