import { _ } from 'streamline-runtime';
import * as fs from 'fs';
import * as types from './types';
import { X3Error } from './errors';
import { Blbfile } from './tblbfile';
const _ium: { [ium: number]: string } = {
	0: "utf8",
	1: "utf8",
	50: "ascii"
};
const _fium: { [ium: string]: (buf: Buffer, len: number) => string } = {
	"utf8": fromUTF8,
	"ascii": from8Bits
};

function op_error(ex: NodeJS.ErrnoException) {
	switch (ex.code) {
		case "ENOENT":
			return new X3Error(20, ex.message);
		case "EPERM":
		case "EACCES":
			return new X3Error(27, ex.message);
		default:
			return new X3Error(26, ex.message);
	}
}

function byteLength(str: string) {
	// returns the byte length of an utf8 string
	var s = str.length;
	for (var i = str.length - 1; i >= 0; i--) {
		var code = str.charCodeAt(i);
		if (code > 0x7f && code <= 0x7ff) s++;
		else if (code > 0x7ff && code <= 0xffff) s += 2;
		if (code >= 0xDC00 && code <= 0xDFFF) i--; //trail surrogate
	}
	return s;
}

function from8Bits(buf: Buffer, len: number) {
	var str = "";
	for (var i = 0; i < len; i++) str += String.fromCharCode(buf[i]);

	return str;
}

function fromUTF8(buf: Buffer, len: number) {
	return buf.toString('utf8', 0, len);
}

function isTrailer(byte: number) {
	return (byte & 0xc0) === 0x80;
}

function UT8Backward(buf: Buffer) {
	var i = buf.length - 1;

	while (isTrailer(buf[i]) && i-- >= 0);
	return buf.length - i;
}

export class File {
	ctx: types.Sys;
	fd: number;
	mode: string;
	offset: number;
	mda: number;
	bom: number;
	adxifs: string;
	adxirs: string;
	adxium: number;
	constructor(ctx: types.Sys) {
		this.ctx = ctx;
		this.fd = null;
		this.mode = "";
		this.offset = 0;
	}

	x3open(_: _,  xfil: { toString(_: _): string }, seekVal: number, mode: string) {
		//dbg:console.log("x3open " +xfil.toString(_)+ " seekVal:"+seekVal+" mode:"+ mode);

		if (mode === "w" && seekVal === -1) mode = "r+";
		else if (!mode) mode = "r";

		try {
			var fd = fs.open(xfil.toString(_), mode, _);
		} catch (ex) {
			if (mode === "r+") {
				// Try again with w+
				mode = "w+";
				try {
					fd = fs.open(xfil.toString(_), mode, _);
				} catch (ex) {
					throw op_error(ex);
				}
			} else {
				throw op_error(ex);
			}
		}
		this.fd = fd;
		this.mode = mode;
		if (seekVal === -1) {
			var stat = fs.fstat(this.fd, _);
			this.offset = stat.size;
		} else {
			this.offset = 0;
		}
		this.mda = 0;
		this.bom = 0;
	}
	x3seek(_: _,  mode: string, direction: number, value: number) {
		//console.log("Seek " + mode + " " + value + " " + direction+ " typeof value:"+(typeof value));

		switch (mode) {
			case 'FIRST':
				this.offset = value;
				break;
			case 'LAST':
				var stat = fs.fstat(this.fd, _);
				this.offset = stat.size - value;
				break;
			case "CURR":
				this.offset += direction * value; //direction = -1 / 1
				break;
			default:
		}
		//console.log("Result offset " + this.offset);
	}
	x3write(_: _,  vals: any[], nl: boolean) {
		const ifs = this.adxifs || this.ctx.values.ADXIFS;
		const irs = this.adxirs || this.ctx.values.ADXIRS;
		const vium = this.adxium || this.ctx.values.ADXIUM;
		const ium = _ium[vium];

		// bom management

		if (this.mda === 0) {
			this.mda = 2;
			if (vium === 1) {
				var bom = new Buffer([0xef, 0xbb, 0xbf]);
				fs.write(this.fd, bom, 0, bom.length, 0, _);
				this.bom = 3;
			}
		}

		// value to write management
		const newvals = vals.map(v => {
			if (Array.isArray(v)) {
				var t = v[2];
				var r = "";
				if (v[1] > 1) throw new X3Error(26, "More than 1 dimension is not supported");
				var min = v[5] ? v[3] - v[5] : 0;
				var max = v[6] ? v[3] + v[6] - v[5] - 1 : v[4] - v[3];

				for (var i = min; i <= max; i++) {
					if (i !== min) r += ifs;
					r += t[i] ? t[i].x3ToString() : "";
				}
				return r;
			} else return v.x3ToString();
		});
		const str = newvals.join(ifs);

		// write it
		// 2 conditions have to be met in order to make the position parameter work :
		// 1°/ Use a Buffer instead of a string
		// 2°/ Open the file with r+ instead of a

		const buffer = new Buffer(str + (nl ? irs : ifs), ium || "utf8");

		//dbg:console.log("x3write fs.write fd:"+this.fd+" position:"+ this.offset + this.bom);

		const len = fs.write(this.fd, buffer, 0, buffer.length, this.offset + this.bom, _);

		this.offset += len;
		return len;
	}
	x3read(_: _) {
		// read parameters

		const ifs = this.adxifs || this.ctx.values.ADXIFS;
		const irs = this.adxirs || this.ctx.values.ADXIRS;
		const ium = _ium[this.adxium || this.ctx.values.ADXIUM];
		const fium = _fium[ium];

		// tool variables

		var curr = this.offset;
		const cache = new Buffer(500);
		const bom = new Buffer(3);

		var lines: string[];
		var str = "";

		if (this.mda === 0) {
			this.mda = 2;

			if (ium === "utf8") {

				var len = fs.read(this.fd, bom, 0, bom.length, 0, _);
				this.bom = bom[0] === 0xef && bom[1] === 0xbb && bom[2] === 0xbf ? 3 : 0;
			}
		}

		// algo
		var len = fs.read(this.fd, cache, 0, cache.length, curr + this.bom, _);
		if (len === 0) return [];

		while (len > 0) {
			var bck = ium === "utf8" ? UT8Backward(cache) : 0;

			str += fium(cache, cache.length - bck);
			lines = str.split(irs);
			if (lines.length > 1) break;
			else {
				curr += len - bck;
				len = fs.read(this.fd, cache, 0, cache.length, curr + this.bom, _);
			}
		}
		// end

		this.offset += ium === "ascii" ? lines[0].length + 1 : byteLength(lines[0] + 1);

		return ifs.length ? lines[0].split(ifs) : [lines[0]];
	}
	x3get(_: _,  size: number) {
		this.mda = 1;
		const curr = this.offset;
		const bf = new Buffer(size);
		const len = fs.read(this.fd, bf, 0, bf.length, curr, _);

		if (len === 0) return null;
		this.offset += len;

		return new Blbfile(bf);
	}
	x3put(_: _,  nbr: number, vals: any[], size: number[]) {
		var i = 0,
		    nbv = 0;
		const vlist: any[] = [];

		var tsize = 0;
		const curr = this.offset;

		this.mda = 1;

		// build buffer to write
		while (vals[i]) {
			var v = vals[i];
			if (Array.isArray(v)) {
				var t = v[2];
				if (v[1] > 1) throw new X3Error(26, "More than 1 dimension is not supported");
				var min = v[5] ? v[3] - v[5] : 0;
				var max = v[6] ? v[3] + v[6] - v[5] - 1 : v[4] - v[3];

				for (var j = min; j <= max; j++) {
					var val = (t[j] !== undefined ? t[j] : v[1]).x3Serialize(size[i]);

					tsize += val.length;
					vlist.push(val);
					if (++nbv >= nbr) break;
				}
				if (nbv >= nbr) break;
			} else {
				var val = v.x3Serialize(size[i]);
				tsize += val.length;
				vlist.push(val);
				if (++nbv >= nbr) break;
			}
			i++;
		}
		const bf = Buffer.concat(vlist, tsize);

		// write buffer in file
		//dbg:console.log("x3put fs.write fd:"+this.fd+" position:"+ curr);

		const len = fs.write(this.fd, bf, 0, bf.length, curr, _);

		this.offset += len;
		return len;
	}
	x3close(_: _) {
		try {
			fs.close(this.fd, _);
		} catch (ex) {
			throw new X3Error(20, ex.message);
		}
	}
	x3adxseek() {
		return this.offset;
	}
};

;