import { _ } from 'streamline-runtime';
import * as core from 'syracuse-core';
import * as ez from 'ez-streams';
import { Record, Hint } from '../drivers/types';
import { ContextFn, Expression, QueryContext } from './types'
import * as util from './util';
import * as basic from './basic';
import * as vtb from './vtbreader';
const tracer = core.getTracer("etna.engine");
import * as variables from './variables';
import { X3Error } from './errors';
import { DBCursor } from './dbcursor';
import { DBTableParent, KeyExpression, WKey, KeyModified } from './dbtableparent';
import { Supervisor } from '../../supervisor/supervisor'
import * as arrays from './arrays';

// -----------------------------------------------------------------------

function _transformKey(orik: KeyExpression, mod: KeyModified) {
	//copy key
	const newk: KeyExpression = {
		name: "",
		sql: "",
		hidden: false,
		unique: mod.length ? false : orik.unique,
		constants: orik.constants,
		kslot: -1
	};

	const len = mod.length || orik.items.length;

	// treat items and sql
	newk.directions = orik.directions.map(d => d * mod.direction).slice(0, len);

	newk.items = orik.items.slice(0, len).map((itm, idx) => {
		const p = itm.lastIndexOf(' ');
		if (p > 0) itm = itm.substring(0, p);
		//if (newk.directions[idx] < 0) itm += " Desc";
		return itm;
	});

	newk.func = orik.func.slice(0, len);
	newk.guide = orik.guide.slice().reverse();

	return newk;
}

function _identity(x: any) {
	return x;
}

// get number of lines and verify consistancy
function _getlimit(arrays: NumberArray[]) {
	var nlines = 0;
	for (var i = 0; i < arrays.length; i++) {

		var arr = arrays[i];
		var nl = arr.getOneDimNbValues();

		if (nlines != 0 && nl != nlines) throw new X3Error(55, "Table " + (i + 1));
		else nlines = nl;
	}
	return nlines;
}

type NumberArray = number[];

function _getbases(arrays: NumberArray[]) {
	return arrays.map(arr => arr.getOneDimBase());
}

function _buildWhere(_: _,  dbtable: DBTableParent, wkey: WKey[], 
fwhere?: ContextFn<WKey[]>, fwfrom?: ContextFn<WKey[]>, fwto?: ContextFn<WKey[]>) {
	const tpwhere: ((_: _) => any)[] = [];
	const ctx: QueryContext = {};

	if (wkey && wkey[0].rowid) return tpwhere;

	ctx.tables = [dbtable.abbrev];

	var wheres = (wkey || []).concat(dbtable.where, dbtable.filter.where);
	wheres = wheres.concat(fwhere && fwhere(_, ctx));
	wheres = wheres.concat(fwfrom && fwfrom(_, ctx));
	wheres = wheres.concat(fwto && fwto(_, ctx));

	wheres.filter(_identity).forEach(w => {
		w.func && tpwhere.push(w.func);
	});

	return tpwhere;
}

function _buildKeyGuide(_: _,  dbtable: DBTableVAR, key: KeyExpression) {
	const base: number[] = [];
	const names = Object.keys(dbtable.values);

	for (var i = 0; i < dbtable.lines; i++) base[i] = i;

	key.guide = base.sort_(_, (_, l0, l1) => {
		const row0: Record = {};
		const row1: Record = {};

		// load lines

		for (var i = 0; i < names.length; i++) {
			row0[names[i]] = arrays.instructions.INDEX(dbtable.tables[i], [basic.instructions.C(l0 + dbtable.bases[i])])(_);
			row1[names[i]] = arrays.instructions.INDEX(dbtable.tables[i], [basic.instructions.C(l1 + dbtable.bases[i])])(_);
		}
		const sav = dbtable.values;

		dbtable.values = row0;
		const kvals = dbtable.getKeyValues(_, key, key.func.length);

		dbtable.values = row1;
		const r = dbtable.keyCompare(_, key, kvals);
		// restore data

		dbtable.values = sav;

		return r;
	});
}

export class DBTableVAR extends DBTableParent {
	currkey: number;
	reader: ez.Reader<Record>;
	tables: Expression<DBTableParent>[]; //{ [name: string]: DBTableParent };
	bases: number[];
	lines: number;
	curpos: { [name: string]: any };
	constructor(abbrev: string, superv: Supervisor, loc: number, tbvar: Expression<DBTableParent>[], tbvalues: any[]) {
		super(null, abbrev, superv, loc);
		this.keys = [{
			constants: [],
			func: [],
			name: null,
			directions: [1],
			items: [""]
		}];

		this.currkey = 0;
		this.reader = undefined;

		this.tables = tbvar;
		this.bases = _getbases(tbvalues);
		this.lines = _getlimit(tbvalues);
		this.curpos = { "read": -1, "for": -1, "curr": "" };

		// build guide line for default key
		const guide: number[] = [];
		for (var i = 0; i < this.lines; i++) guide[i] = i;
		this.keys[0].guide = guide;
	}
	init(_: _) {
		return this;
	}

	declVar(type: string, name: string) {
		this.values[name] = variables.types[type[0]].default;
		this.types[name] = " " + type;
	}

	// ------------------------------------------------------------------------------
	// ------------------------------------------------------------------------------

	x3OpenFor(_: _,  key: KeyExpression, lvl: number, hint: Hint, lock: boolean, 
	fwhere: ContextFn<WKey[]>, wfrom: ContextFn<WKey[]>, wto: ContextFn<WKey[]>) {
		const maptrim = (_: _, row: Record) => {
			const rec: Record = {};
			const row1 = Object.keys(row).reduce((r: Record, name: string) => {
				var type = this.types[name];
				if (type[1] === 'S') type = type.substring(0, 2) + "250"; // HACK

				r[name] = variables.types[type[1]].set(name, type, row[name]);
				return r;
			}, {});

			rec[this.abbrev] = row1;
			return rec;
		};

		const pwhere = _buildWhere(_, this, undefined, fwhere, wfrom, wto);
		const tables: { [name: string]: DBTableParent } = {};

		tables[this.abbrev] = this;

		this.curpos["for"] = 0;
		const rdr = vtb.reader(this, key, "for");

		this.currentFor = new DBCursor(rdr, tables, maptrim, pwhere, key, lvl, "for", undefined);
		return this.currentFor;
	}

	// ------------------------------------------------------------------------------
	// ------------------------------------------------------------------------------

	x3Read(_: _,  key: KeyExpression, lvl: number, wkey: WKey[], krevert: boolean, lock: boolean, hint: Hint) {
		const maptrim = (_: _, row: Record) => {
			const rec: Record = {};
			const row1 = Object.keys(row).reduce((r, name) => {
				const type = this.types[name];

				r[name] = variables.types[type[1]].set(name, type, row[name]);
				return r;
			}, {} as Record);

			rec[this.abbrev] = row1;
			return rec;
		};
		var rkey: KeyExpression;

		if (krevert) {
			rkey = _transformKey(key, {
				direction: -1,
				length: 0
			});
			if (hint) hint.revert = true;
		} else rkey = key;

		const pwhere = _buildWhere(_, this, wkey);
		const tables: { [name: string]: DBTableParent } = {};

		tables[this.abbrev] = this;

		//console.log("--"+JSON.stringify(this.curpos)+"--");

		if (wkey && wkey[0].rowid) this.curpos["read"] = this.curpos[this.curpos['curr']];
		else this.curpos["read"] = 0;

		const rdr = vtb.reader(this, rkey, "read");
		const cf = new DBCursor(rdr, tables, maptrim, pwhere, key, undefined, "read", undefined);

		var fstat = 5;
		if (cf.x3GetRecord(_)) {
			fstat = 0;
			// if krevert, revert the position
			if (krevert) {
				this.curpos["read"] = this.lines - (this.curpos["read"] - 1) - 1;
			}
		}

		return fstat;
	}

	// misc ----------------------------------------------------
	// ---------------------------------------------------------
	x3SetNewKey(_: _,  newkey: KeyExpression) {
		if (newkey.sql) {
			this.keys.forEach(ky => {
				ky.hidden = true;
			});

			newkey.kslot = this.keys.push(newkey) - 1;
			this.currkey = newkey.kslot;
			this.currlen = newkey.items.length;

			_buildKeyGuide(_, this, newkey);
		} else {
			const mk = this.findKey(newkey.name);

			this.keys.forEach(ky => {
				ky.hidden = true;
			});

			if (newkey.modified) {
				newkey = _transformKey(mk, newkey.modified);
				newkey.kslot = this.keys.push(newkey) - 1;
				this.currkey = newkey.kslot;
				this.currlen = newkey.items.length;
			} else {
				mk.hidden = false;
				this.currkey = mk.kslot;
				this.currlen = mk.items.length;
			}
		}
	}

	keyCompare(_: _,  k: KeyExpression, values: any[]) {
		var cmp = 0,
		    lvl = 0;

		while (cmp === 0 && values[lvl] !== undefined) {
			cmp = values[lvl].x3Compare(k.func[lvl](_)) * k.directions[lvl];
			lvl++;
		}
		return cmp;
	}
	getKeyValues(_: _,  k: KeyExpression, lvl: number) {
		const res: any[] = [];
		for (var i = 0; i < lvl; i++) {
			res.push(k.func[i] && k.func[i](_));
		}
		return res;
	}

	x3GetCurrentFor() {
		return this.currentFor;
	}

	x3CloseFor() {
		this.currentFor = null;
	}

	findKey(name: string): KeyExpression {
		if (name === "reckey") return this.keys[0];
		if (!name) return this.keys[this.currkey];

		const k = this.keys.filter(k => k.name === name && k.hidden === false);
		if (!k[0]) throw new X3Error(21, "bad key: " + name);
		return k[0];
	}
}