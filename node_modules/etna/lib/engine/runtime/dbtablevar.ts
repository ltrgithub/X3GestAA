"use strict";

const util = require('./util');
const vtb = require('./vtbreader');
const tracer = require('syracuse-core').getTracer("etna.engine");
const variables = require('./variables');
const X3Error = require('./errors').X3Error;
const DBCursor = require('./dbcursor').DBCursor;
const DBTableParent = require('./dbtableparent').DBTableParent;
const arrays = require('./arrays');

// -----------------------------------------------------------------------

function _transformKey(orik, mod) {
	//copy key
	const newk = {
		name: "",
		sqk: "",
		hidden: false,
		unique: mod.length ? false : orik.unique,
		constants: orik.constants,
		kslot: -1
	};

	const len = mod.length || orik.items.length;

	// treat items and sql
	newk.directions = orik.directions.map(d => d * mod.direction).slice(0, len);

	newk.items = orik.items.slice(0, len).map((itm, idx) => {
		const p = itm.lastIndexOf(' ');
		if (p > 0) itm = itm.substring(0, p);
		//if (newk.directions[idx] < 0) itm += " Desc";
		return itm;
	});

	newk.func = orik.func.slice(0, len);
	newk.guide = orik.guide.slice().reverse();

	return newk;
}

function _identity(x) {
	return x;
}

// get number of lines and verify consistancy
function _getlimit(arrays) {
	var nlines = 0;
	for (var i = 0; i < arrays.length; i++) {

		var arr = arrays[i];
		var nl = arr.getOneDimNbValues();

		if (nlines != 0 && nl != nlines) throw new X3Error(55, "Table " + (i + 1));
		else nlines = nl;
	}
	return nlines;
}

function _getbases(arrays) {
	return arrays.map(arr => arr.getOneDimBase());
}

function _buildWhere(_, dbtable, wkey, fwhere, fwfrom, fwto) {
	const tpwhere = [];
	const ctx = {};

	if (wkey && wkey[0].rowid) return tpwhere;

	ctx.tables = [dbtable.abbrev];

	var wheres = (wkey || []).concat(dbtable.where, dbtable.filter.where);
	wheres = wheres.concat(fwhere && fwhere(_, ctx));
	wheres = wheres.concat(fwfrom && fwfrom(_, ctx));
	wheres = wheres.concat(fwto && fwto(_, ctx));

	wheres.filter(_identity).forEach(w => {
		w.func && tpwhere.push(w.func);
	});

	return tpwhere;
}

function _buildKeyGuide(_, dbtable, key) {
	const base = [];
	const names = Object.keys(dbtable.values);

	for (var i = 0; i < dbtable.lines; i++) base[i] = i;

	key.guide = base.sort_(_, (_, l0, l1) => {
		const row0 = {};
		const row1 = {};

		// load lines

		for (var i = 0; i < names.length; i++) {
			row0[names[i]] = arrays.instructions.INDEX(dbtable.tables[i], [util.instructions.C(l0 + dbtable.bases[i])])(_);
			row1[names[i]] = arrays.instructions.INDEX(dbtable.tables[i], [util.instructions.C(l1 + dbtable.bases[i])])(_);
		}
		const sav = dbtable.values;

		dbtable.values = row0;
		const kvals = dbtable.getKeyValues(_, key, key.func.length);

		dbtable.values = row1;
		const r = dbtable.keyCompare(_, key, kvals);
		// restore data

		dbtable.values = sav;

		return r;
	});
}

class DBTableVAR extends DBTableParent {
	constructor(abbrev, superv, loc, tbvar, tbvalues) {
		super(null, abbrev, superv, loc);
		this.keys = [{
			constants: [],
			func: [],
			name: null,
			directions: [1],
			items: [""]
		}];

		this.currkey = 0;
		this.reader = undefined;

		this.tables = tbvar;
		this.bases = _getbases(tbvalues);
		this.lines = _getlimit(tbvalues);
		this.curpos = { "read": -1, "for": -1, "curr": "" };

		// build guide line for default key
		const guide = [];

		for (var i = 0; i < this.lines; i++) guide[i] = i;
		this.keys[0].guide = guide;
	}
	init(_) {
		return this;
	}

	declVar(type, name) {
		this.values[name] = variables.types[type[0]].default;
		this.types[name] = " " + type;
	}

	// ------------------------------------------------------------------------------
	// ------------------------------------------------------------------------------

	x3OpenFor(_, key, lvl, hint, lock, fwhere, wfrom, wto) {
		const maptrim = (_, row) => {
			const rec = {};
			const row1 = Object.keys(row).reduce((r, name) => {
				var type = this.types[name];
				if (type[1] === 'S') type = type.substring(0, 2) + "250"; // HACK

				r[name] = variables.types[type[1]].set(name, type, row[name]);
				return r;
			}, {});

			rec[this.abbrev] = row1;
			return rec;
		};

		const pwhere = _buildWhere(_, this, undefined, fwhere, wfrom, wto);
		const tables = {};

		tables[this.abbrev] = this;

		this.curpos["for"] = 0;
		const rdr = vtb.reader(this, key, "for");

		this.currentFor = new DBCursor(rdr, tables, maptrim, pwhere, key, lvl, "for", undefined);
		return this.currentFor;
	}

	// ------------------------------------------------------------------------------
	// ------------------------------------------------------------------------------

	x3Read(_, key, lvl, wkey, krevert, lock, hint) {
		const maptrim = (_, row) => {
			const rec = {};
			const row1 = Object.keys(row).reduce((r, name) => {
				const type = this.types[name];

				r[name] = variables.types[type[1]].set(name, type, row[name]);
				return r;
			}, {});

			rec[this.abbrev] = row1;
			return rec;
		};
		var rkey;

		if (krevert) {
			rkey = _transformKey(key, {
				direction: -1,
				length: 0
			});
			if (hint) hint.revert = true;
		} else rkey = key;

		const pwhere = _buildWhere(_, this, wkey);
		const tables = {};

		tables[this.abbrev] = this;

		//console.log("--"+JSON.stringify(this.curpos)+"--");

		if (wkey && wkey[0].rowid) this.curpos["read"] = this.curpos[this.curpos.curr];
		else this.curpos["read"] = 0;

		const rdr = vtb.reader(this, rkey, "read");
		const cf = new DBCursor(rdr, tables, maptrim, pwhere, key, undefined, "read", undefined);

		var fstat = 5;
		if (cf.x3GetRecord(_)) {
			fstat = 0;
			// if krevert, revert the position
			if (krevert) {
				this.curpos["read"] = this.lines - (this.curpos["read"] - 1) - 1;
			}
		}

		return fstat;
	}

	// misc ----------------------------------------------------
	// ---------------------------------------------------------
	x3SetNewKey(_, newkey) {
		if (newkey.sql) {
			this.keys.forEach(ky => {
				ky.hidden = true;
			});

			newkey.kslot = this.keys.push(newkey) - 1;
			this.currkey = newkey.kslot;
			this.currlen = newkey.items.length;

			_buildKeyGuide(_, this, newkey);
		} else {
			const mk = this.findKey(newkey.name);

			this.keys.forEach(ky => {
				ky.hidden = true;
			});

			if (newkey.modified) {
				newkey = _transformKey(mk, newkey.modified);
				newkey.kslot = this.keys.push(newkey) - 1;
				this.currkey = newkey.kslot;
				this.currlen = newkey.items.length;
			} else {
				mk.hidden = false;
				this.currkey = mk.kslot;
				this.currlen = mk.items.length;
			}
		}
	}

	keyCompare(_, k, values) {
		var cmp = 0,
		    lvl = 0;

		while (cmp === 0 && values[lvl] !== undefined) {
			cmp = values[lvl].x3Compare(k.func[lvl](_)) * k.directions[lvl];
			lvl++;
		}
		return cmp;
	}
	getKeyValues(_, k, lvl) {
		const res = [];
		for (var i = 0; i < lvl; i++) {
			res.push(k.func[i] && k.func[i](_));
		}
		return res;
	}

	x3GetCurrentFor() {
		return this.currentFor;
	}

	x3CloseFor() {
		this.currentFor = null;
	}

	findKey(name) {
		if (name === "reckey") return this.keys[0];
		if (!name) return this.keys[this.currkey];

		const k = this.keys.filter(k => k.name === name && k.hidden === false);
		if (!k[0]) throw new X3Error(21, "bad key: " + name);
		return k[0];
	}
}

exports.DBTableVAR = DBTableVAR;