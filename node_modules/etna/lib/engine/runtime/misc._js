"use strict";
var flows = require('streamline-runtime').flows;

var util = require('./util');
var errors = require('./errors');
var X3Error = errors.X3Error;

exports.instructions = {
	CALLJS: function(mode, ns, name, args) {
		return function calljs$do(_) {
			var nsVal = ns(_);
			var mod, fn;
			try {
				mod = require(nsVal);
			} catch (ex) {
				throw ex.errn ? ex : new X3Error(20, ex.message);
			}
			fn = mod[name];
			if (!fn) throw new X3Error(4, "unknown JS function: " + nsVal + "." + name);
			var vals = args(_);
			switch (mode) {
				case "sync":
					return fn.apply(this, vals);
				case "async":
					return flows.apply(_, fn, this, vals, 0);
				default:
					throw new X3Error(26, "invalid Calljs mode: " + mode);
			}
		};
	},
	BOX: function(kind, args) {
		var aargs = util.instructions.A(args);
		return function log$do(_) {
			var message = aargs(_).join('\t');
			var logger = kind === 'error' ? console.error : console.log;
			logger(message);
		};
	},

	DBGETNA: function(args) {
		var aargs = (args) ? util.instructions.A(args) : null;
		return function dbg$do(_) {

			var val = aargs(_);
			setTimeout(_, (val[0]) ? val[0] : 5000);
			if ("keep me") debugger;
		};
	},

	SLEEP: function(args) {
		var aargs = (args) ? util.instructions.A(args) : null;
		return function sleep$do(_) {
			var val = aargs(_);
			setTimeout(_, 1000 * ((val[0]) ? val[0] : 1));
		};
	}
};

exports.functions = {
	XCRYPT: {
		count: 1,
		fn: function(key) {
			throw new X3Error(33, "NIY: XCRYPT");
		}
	},
	LEN2: {
		count: 1,
		fn: function(key) {
			throw new X3Error(33, "NIY: LEN2");
		}
	},
	APPX3: {
		count: 1,
		fn: function(key) {
			throw new X3Error(33, "NIY: APPX3");
		}
	}
};