"use strict";

const util = require('./util');
const vtb = require('./vtbreader');
const helpers = require('syracuse-core').helpers;
const tracer = require('syracuse-core').getTracer("etna.engine");
const variables = require('./variables');
const X3Error = require('./errors').X3Error;
const DBCursor = require('./dbcursor').DBCursor;
const DBTableParent = require('./dbtableparent').DBTableParent;
const arrays = require('./arrays');

// -----------------------------------------------------------------------

function _transformKey(orik, mod) {
	//copy key
	const newk = {
		name: "",
		sqk: "",
		hidden: false,
		unique: (mod.length) ? false : orik.unique,
		constants: orik.constants,
		kslot: -1,
	};

	const len = (mod.length || orik.items.length);

	// treat items and sql
	newk.directions = orik.directions.map(function(d) {
		return d * mod.direction;
	}).slice(0, len);

	newk.items = orik.items.slice(0, len).map(function(itm, idx) {
		const p = itm.lastIndexOf(' ');
		if (p > 0) itm = itm.substring(0, p);
		//if (newk.directions[idx] < 0) itm += " Desc";
		return itm;
	});

	newk.func = orik.func.slice(0, len);

	newk.sql = newk.items.map(function(it, idx) {
		return it + ((newk.directions[idx] < 0) ? " Desc" : "");
	}).join(", ");
	return newk;
}

function _identity(x) {
	return x;
}

// get number of lines and verify consistancy
function _getlimit( arrays ) {
	var nlines = 0;
	for (var i = 0; i < arrays.length; i++) {
				
		var arr = arrays[i];
		var nl = arr.getOneDimNbValues( ) ;
		
		if ((nlines != 0) && (nl != nlines)) throw new X3Error(55, "Table "+(i+1)) ;
		else nlines = nl ;
	}
	return nlines ;
}

function _getbases( arrays ) {
	return arrays.map( function( arr ) {
		return arr.getOneDimBase( ) ;
	}) ;
}

function _buildWhere(_, self, fwhere, fwfrom, fwto ) {

	var tpwhere = [];
	const ctx = {};

	ctx.tables = [self.abbrev] ;

	var wheres = [].concat(self.where, self.filter.where);
	wheres = wheres.concat(fwhere && fwhere(_, ctx));
	wheres = wheres.concat(fwfrom && fwfrom(_, ctx));
	wheres = wheres.concat(fwto && fwto(_, ctx));

	wheres.filter(_identity).forEach(function(w) {
		w.func && tpwhere.push(w.func);
	});

	return tpwhere ;
}

function _buildKeyGuide(_, self, key ) {

	var base = [] ;
	var names = Object.keys(self.values) ;
	for (var i = 0; i < self.lines; i++)
		base[i] = i ;

	key.guide = base.sort_(_, function(_, l0, l1) {
		var row0 = {};
		var row1 = {};

		// load lines
		for (var i = 0; i < names.length; i++) {
			row0[names[i]] = arrays.instructions.INDEX(self.tables[i], [util.instructions.C( l0+self.bases[i])])(_);
			row1[names[i]] = arrays.instructions.INDEX(self.tables[i], [util.instructions.C( l1+self.bases[i])])(_);		
		}
		var sav = self.values ;
		self.values = row0 ;
		var kvals = self.getKeyValues(_, key, key.func.length ) ;

		self.values = row1 ;
		var r = self.keyCompare(_, key, kvals )
		// restore data
		self.values = sav;

		return r ;
	}) ;
}

class DBTableVAR extends DBTableParent {
	constructor( abbrev, superv, loc, tbvar, tbvalues ) {
		super(null, abbrev, superv, loc);
		this.keys = [{
			constants: [],
			func: [],
			name: null,
			directions: [1],
			items: [""],
		}];
		
		this.currkey = 0;
		this.reader = undefined;

		this.arrays = tbvalues ;

		this.tables = tbvar ;
		this.bases = _getbases(tbvalues)
		this.lines = _getlimit(tbvalues) ;

		// build guide line for default key
		var guide = [] ;
		for (var i = 0; i < this.lines; i++) guide[i] = i ;
		this.keys[0].guide = guide ;
	}
	init(_) {
		return this;
	}
	declVar(type, name) {
		const self = this;

		self.values[name] = variables.types[type[0]].default;
		self.types[name] = " "+type;
	}

	x3OpenFor(_, key, lvl, hint, lock, fwhere, wfrom, wto) {
		const self = this;
		const maptrim = function(_, row) {
			var rec = { } ;
			rec[self.abbrev] = row;
			return rec ;
		};
		
		var pwhere =_buildWhere(_, self, fwhere, wfrom, wto );
		var tables = {};
		tables[self.abbrev] = self ;

		//console.log(self.arrays[0]);
		//console.log(self.arrays[1]);
		const rdr = vtb.reader( self, key );

		self.currentFor = new DBCursor(rdr, tables, maptrim, pwhere, key, lvl, "for", undefined);
		return self.currentFor;				
	}


	// misc ----------------------------------------------------
	// ---------------------------------------------------------
	x3SetNewKey(_, newkey) {
		const self = this;

		if (newkey.sql) {
			self.keys.forEach(function(ky) {
				ky.hidden = true;
			});

			newkey.kslot = self.keys.push(newkey) - 1;
			self.currkey = newkey.kslot;
			self.currlen = newkey.items.length;

			_buildKeyGuide(_, self, newkey ) ;

		} else {
			const mk = self.findKey(newkey.name);

			self.keys.forEach(function(ky) {
				ky.hidden = true;
			});

			if (newkey.modified) {
				newkey = _transformKey(mk, newkey.modified);
				newkey.kslot = self.keys.push(newkey) - 1;
				self.currkey = newkey.kslot;
				self.currlen = newkey.items.length;
			} else {
				mk.hidden = false;
				self.currkey = mk.kslot;
				self.currlen = mk.items.length;
			}
		}
	}	

	keyCompare(_, k, values) {
		const self = this;
		var cmp = 0,
			lvl = 0;

		while ((cmp === 0) && (values[lvl] !== undefined)) {
			cmp = values[lvl].x3Compare(k.func[lvl](_)) * k.directions[lvl];
			lvl++;
		}
		return cmp;
	}
	getKeyValues(_, k, lvl) {
		const res = [];
		for (var i = 0; i < lvl; i++) {
			res.push(k.func[i] && k.func[i](_));
		}
		return res;
	}

	x3GetCurrentFor() {
		const self = this;
		return self.currentFor;
	}
	
	x3CloseFor( ) {
		const self = this;
		self.currentFor = null ;
	}

	findKey( name ) {
		const self = this;
		if (name === "reckey") return self.keys[0];
		if (!(name)) return self.keys[self.currkey];

		const k = self.keys.filter(function(k) {
			return ((k.name === name) && (k.hidden === false));
		});
		if (!k[0]) throw new X3Error(21, "bad key: " + name);
		return k[0];
	}
}

exports.DBTableVAR = DBTableVAR;