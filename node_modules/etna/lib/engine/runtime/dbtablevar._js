"use strict";

const util = require('./util');
const vtb = require('./vtbreader');
const helpers = require('syracuse-core').helpers;
const tracer = require('syracuse-core').getTracer("etna.engine");
const variables = require('./variables');
const X3Error = require('./errors').X3Error;
const DBCursor = require('./dbcursor').DBCursor;
const DBTableParent = require('./dbtableparent').DBTableParent;


// get number of lines and verify consistancy
function _getlimit( arrays ) {
	var nlines = 0;
	for (var i = 0; i < arrays.length; i++) {
				
		var arr = arrays[i];
		var nl = arr.getOneDimNbValues( ) ;
		
		if ((nlines != 0) && (nl != nlines)) throw new X3Error(55, "Table "+(i+1)) ;
		else nlines = nl ;
	}
	return nlines ;
}

function _getbases( arrays ) {
	return arrays.map( function( arr ) {
		return arr.getOneDimBase( ) ;
	}) ;
}

class DBTableVAR extends DBTableParent {
	constructor( abbrev, superv, loc, tbvar, tbvalues ) {
		super(null, abbrev, superv, loc);
		this.keys = [{
			constants: [],
			func: [],
			name: null,
			directions: [1],
			items: [""],
		}];
		this.currkey = 0;

		this.arrays = tbvalues ;

		this.tables = tbvar ;
		this.bases = _getbases(tbvalues)
		this.lines = _getlimit(tbvalues) ;
		
		// build guide line for default key
		var guide = [] ;
		for (var i = 0; i < this.lines; i++) guide[i] = i ;
		this.keys[0].key = guide ;
	}
	init(_) {
		return this;
	}
	declVar(type, name) {
		const self = this;

		self.values[name] = variables.types[type[0]].def;
		self.types[name] = " "+type;
	}

	x3OpenFor(_, key, lvl, hint, lock, where, wfrom, wto) {
		const self = this;
		const maptrim = function(_, row) {
			var rec = { } ;
			rec[self.abbrev] = row;
			return rec ;
		};
		var tables = {};
		var pwhere = [];
		tables[self.abbrev] = self ;

		//console.log(self.arrays[0]);
		//console.log(self.arrays[1]);

		const rdr = vtb.reader( self, 0 );

		self.currentFor = new DBCursor(rdr, tables, maptrim, pwhere, key, lvl, "for", undefined);
		return self.currentFor;				
	}

	x3GetCurrentFor() {
		const self = this;
		return self.currentFor;
	}
	
	x3CloseFor( ) {
		const self = this;
		self.currentFor = null ;
	}

	findKey( name ) {
		const self = this;
		if (name === "reckey") return self.keys[0];
		if (!(name)) return self.keys[self.currkey];

		const k = self.keys.filter(function(k) {
			return ((k.name === name) && (k.hidden === false));
		});
		if (!k[0]) throw new X3Error(21, "bad key: " + name);
		return k[0];
	}
}

exports.DBTableVAR = DBTableVAR;