"use strict";

const util = require('./util');
const vtb = require('./vtbreader');
const helpers = require('syracuse-core').helpers;
const tracer = require('syracuse-core').getTracer("etna.engine");
const variables = require('./variables');

const DBCursor = require('./dbcursor').DBCursor;
const DBTableParent = require('./dbtableparent').DBTableParent;

class DBTableVAR extends DBTableParent {
	constructor( abbrev, superv, loc, arrays ) {
		super(null, abbrev, superv, loc);
		this.keys = [{
			constants: [],
			func: [],
			name: null,
			directions: [1],
			items: [""],
		}];
		this.currkey = 0;
	}
	init(_) {
		return this;
	}
	declVar(type, name) {
		const self = this;

		self.values[name] = variables.types[type[0]].def;
		self.types[name] = " "+type;
	}

	x3OpenFor(_, key, lvl, hint, lock, where, wfrom, wto) {
		const self = this;
		const maptrim = function(_, row) {
			var rec = { } ;
			rec[self.abbrev] = row;
			return rec ;
		};
		var tables = {};
		var pwhere = [];
		tables[self.abbrev] = self ;

		const rdr = vtb.reader(null, Object.keys(self.values));

		self.currentFor = new DBCursor(rdr, tables, maptrim, pwhere, key, lvl, "for", undefined);
		return self.currentFor;				
	}

	x3GetCurrentFor() {
		const self = this;
		return self.currentFor;
	}
	
	x3CloseFor( ) {
		const self = this;
		self.currentFor = null ;
	}

	findKey( name ) {
		const self = this;
		if (name === "reckey") return self.keys[0];
		if (!(name)) return self.keys[self.currkey];

		const k = self.keys.filter(function(k) {
			return ((k.name === name) && (k.hidden === false));
		});
		if (!k[0]) throw new X3Error(21, "bad key: " + name);
		return k[0];
	}
}

exports.DBTableVAR = DBTableVAR;