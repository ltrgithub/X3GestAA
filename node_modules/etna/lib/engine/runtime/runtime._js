"use strict";

var sys = require('util');
var config = require("etna/lib/util/nodeconfig").config.etna;

config = config || {};
var assert = require('assert');
var glob = require('streamline-runtime').globals;
var flows = require('streamline-runtime').flows;
var fs = require('streamline-fs');
var helpers = require('syracuse-core').helpers;
var register = require("etna/lib/engine/register");

var Parser = require("etna/lib/engine/parser").Parser;
var jsgen = require('etna/lib/engine/jsgen');
var version = require('etna/lib/engine/version').version;
var scriptDebugger = require("etna/lib/engine/debugger/server");
var db = require('./db');

var tracer = require('syracuse-core').getTracer("etna.engine");
var debugTracer = require('syracuse-core').getTracer("etna.debugger");

var modules = ['arrays', 'dates', 'db', 'evaluate', 'fileio', 'flowControl', 'misc', 'numbers', //
	'operators', 'stats', 'strings', 'system', 'util', 'variables', //
	'tbcd', 'uuid', 'tblbfile', 'tclbfile'
].map(function(name) {
	return require('./' + name);
});
var util = require('./util');
var variables = require('./variables');

var trueInst = ['ANASQL', 'ASSIGN', 'BOX', 'BREAK', 'CALL', 'CALLJS', 'CASE', 'CLOSE', 'COLUMNS', 'COMMIT', 'DBGETNA',
	'DECL', 'DEFAULT', 'DELA', 'DELETE', 'END', 'EXECSQL', 'FILESQL', 'FILESYS', 'FILEVAL', 'FILTER', 'FORF', 'FORIN',
	'FORSQL', 'FORV', 'FREE', 'FUNC', 'GETSEQ', 'GOSUB', 'GOTO', 'IF', 'INSA', 'IOMODE', 'KILL', 'LINK', 'LOGICCLOSE', 'LOOK',
	'ONERRGO', 'OPEN', 'PROG', 'PUTSEQ', 'RAZ', 'RDSEQ', 'READ', 'RESUME', 'RET', 'REWRITE', 'ROLLBACK', 'SEEK', 'SET',
	'SLEEP', 'SORTA', 'TRBEGIN', 'UPDATE', 'WHILE', 'WRITE', 'WRSEQ', 'XMET'
];

function collect(key) {
	exports[key] = {};
	modules.forEach(function(mod) {
		mod[key] && Object.keys(mod[key]).forEach(function(k) {
			if (exports[key][k]) throw new Error("duplicate definition of " + key + " " + k);
			//console.log(key + "/" + k)
			exports[key][k] = mod[key][k];
		});
	});
}

collect('functions');
collect('instructions');

function compile(source, name, filename) {
	tracer.debug && tracer.debug("compile src:" + name);

	var fn = new Function("module", "exports", "requireScript", "require", "'use strict';" + source);
	var module = {
		id: name,
		filename: filename,
		exports: {}
	};

	function req(_, name) {
		return exports.requireScript(_, name);
	}
	try {
		fn(module, module.exports, req, require);
	} catch (ex) {
		tracer.error && tracer.error("compile exception:" + JSON.stringify(ex));
		throw new Error(filename + ": module initialization failed: " + ex.stack.split('\n').slice(0, 2).join(': '));
	}
	return module.exports;
}

exports.requireScript = function(_, name) {
	//console.log("requireScript:"+name);

	var frame = glob.context.x3frame;
	var files;
	if (!exports.requireScript.builtins) {
		exports.requireScript.builtins = {};

		files = fs.readdir(__dirname + "/../../supervisor/builtins/", _);
		files.filter(function(file) {
			return file.length == (4 + file.lastIndexOf("._js"));
		}).forEach_(_, function(_, file, i) {
			exports.requireScript.builtins[file.substring(0, file.lastIndexOf("._js"))] = __dirname + "/../../supervisor/builtins/" + file;

		});
	}

	if (!exports.requireScript.nodeScript) {
		exports.requireScript.nodeScript = {};

		files = fs.readdir(__dirname + "/../../../test/engine/server/", _);
		files.filter(function(file) {
			return file.length == (4 + file.lastIndexOf(".src"));
		}).forEach_(_, function(_, file, i) {
			exports.requireScript.nodeScript[file.substring(0, file.lastIndexOf(".src"))] = __dirname + "/../../../test/engine/server/" + file;
		});
	}

	//console.log("config " + config.folderName+"  ")+config.solutionPath;
	exports.requireScript.scripts = exports.requireScript.scripts || {};

	if (exports.requireScript.scripts[name]) return exports.requireScript.scripts[name];

	if (exports.requireScript.builtins[name]) {
		//console.log("require builtin:"+name);
		exports.requireScript.scripts[name] = require(exports.requireScript.builtins[name]);
		return exports.requireScript.scripts[name];
	}

	if (exports.requireScript.nodeScript[name]) {
		//console.log("require nodeScript:"+name);
		exports.requireScript.scripts[name] = require(exports.requireScript.nodeScript[name]);
		return exports.requireScript.scripts[name];
	}

	// Is it a script stored on the shared folder ?
	var trtdir = (frame.context.superv.solutionPath + '/' + frame.context.superv.folderName + "/TRT/").replace(/\\/g, '/');
	//console.log("trtdir:"+trtdir);
	var path = trtdir + name + ".src";

	if (fs.exists(path, _)) {
		// Yes, it is :
		//console.log("require src:" + name);
		tracer.debug && tracer.debug("require src:" + name);

		var banner = "/* Generated by etna " + version + " -- DO NOT EDIT */";
		var source = fs.readFileSync(path, 'utf8');
		var parsed = new Parser(source, path).parse();
		var transformed = banner + jsgen.generate(parsed.node, path);

		exports.requireScript.scripts[name] = compile(transformed, name, path);

		if (tracer.debug) {
			var cpath = require('os').tmpdir() + "/etna/" + name + ".js";
			tracer.debug("local copy:" + cpath);
			register.mkdirsSync(cpath);
			fs.writeFileSync(cpath, transformed, "utf8");
		}
		return exports.requireScript.scripts[name];
	}

	exports.requireScript.scripts[name] = require(name);
	return exports.requireScript.scripts[name];
};

var runtime = require('streamline-runtime').globals.runtime;

// TODO: improve - we need to wrap to trace instructions but we don't need it to trace calls/funcs
function initTraces() {
	var indent = "";

	function traceCall(_, action, arg) {
		var frame = glob.context.x3frame;
		var loc = frame.prev.sub.loc;
		if (!config.traceCallRE.test(loc.module + ((frame.prog && (':' + frame.prog.name)) || ""))) return;
		if (action === "exit") indent = indent.substring(0, indent.length - 2);
		//console.log(indent + loc.file.substring(loc.file.lastIndexOf("\\") + 1) + ':' + loc.line + ': ' + action + ' ' + frame.prog.name + (arg ? ": " + arg : ""));
		if (action === "enter") indent += "  ";
	}

	function traceFunc(_, action, arg) {
		var frame = glob.context.x3frame;
		var loc = frame.sub.loc;
		if (!config.traceFuncRE.test(loc.module + ((frame.prog && (':' + frame.prog.name)) || "") + ':' + frame.fcall)) return;
		//console.log(indent + loc.file.substring(loc.file.lastIndexOf("\\") + 1) + ':' + loc.line + ': ' + action + ' ' + frame.fcall + (arg ? ": " + arg : ""));
	}

	Object.keys(exports.instructions).forEach(function(k) {
		var instruction = exports.instructions[k];
		exports.instructions[k] = function traceWrapper() {
			var instArgs = Array.prototype.slice.call(arguments);
			var fn = instruction.apply(this, arguments);
			if (typeof fn !== "function") return;
			var loc = util.sourceLoc;
			return function() {
				var frame = glob.context.x3frame;
				if (config.traceCallRE) frame.context.traceCall = traceCall;
				if (config.traceFuncRE) frame.context.traceFunc = traceFunc;
				frame.sub.loc = loc;
				// streamline's apply_ introduces too much overhead - we can directly apply as this is a tail call
				return fn.apply(this, arguments);
			};
		};
	});
}

function initStackLines() {
	Object.keys(exports.instructions).forEach(function(k) {
		var instruction = exports.instructions[k];
		exports.instructions[k] = function() {
			var fn = instruction.apply(this, arguments);
			if (typeof fn !== "function") return;
			var loc = util.sourceLoc;
			return function(cb) {
				var frame = glob.context.x3frame;
				//console.error(loc.file + ':' + loc.line + ":" + k);
				frame.sub.loc = loc;
				fn.apply(this, arguments);
			};
		};
	});
}

if (config.traceCallRE || config.traceFuncRE) initTraces();
else initStackLines();

if (config.debug && config.debug.enabled) _initDebugger(flows.check);

function millis(nanos) {
	return nanos / 1000000;
}

function nanos(hr) {
	return hr[0] * 1e9 + hr[1];
}

var instCounters = {};
var curInstCounter = {
	hr: process.hrtime()
};

function initInstructionMonitoring() {
	Object.keys(exports.instructions).forEach(function(k) {
		var instruction = exports.instructions[k];
		var counter = instCounters[k] = {
			name: k,
			hits: 0,
			hr: null,
			nanos: 0,
		};
		exports.instructions[k] = function perfmonWrapper() {
			var fn = instruction.apply(this, arguments);
			if (typeof fn !== "function") return;
			var instName = fn.instName;
			if (instName) {
				instCounters[instName] = {
					name: "F(" + instName + ")",
					hits: 0,
					hr: null,
					nanos: 0,
				};
			}
			return function() {
				var prevCounter = curInstCounter;
				prevCounter.nanos += nanos(process.hrtime(prevCounter.hr));
				curInstCounter = counter;
				counter.hits++;
				counter.hr = process.hrtime();
				// streamline's apply_ introduces too much overhead - we can directly apply as this is a tail call
				try {
					return fn.apply(this, arguments);
				} finally {
					var time = nanos(process.hrtime(counter.hr));
					curInstCounter = prevCounter;
					prevCounter.hr = process.hrtime();
					if (instName) {
						instCounters[instName].hits += 1;
						instCounters[instName].nanos += time;
					} else {
						counter.nanos += time;
					}

				}
			};
		};
	});
}

function _dumpInstructionCounters() {
	function padL(a, b) {
		return (new Array(b + 1).join(" ") + a).slice(-b);
	}

	var counters = Object.keys(instCounters).map(function(k) {
		return instCounters[k];
	}).filter(function(c) {
		return c.hits;
	}).sort(function(c1, c2) {
		return c2.nanos - c1.nanos;
	}).map(function(c) {
		return 'total (ms): ' + millis(c.nanos) + '\thits: ' + padL(c.hits, 9) + '\tcost (ns):' + padL(Math.round(c.nanos / c.hits, 2), 9) + '\t' + c.name;
	});
	//console.log(counters.join('\n'));
	instCounters = {};
}

function _razInstructionCounters() {
	Object.keys(instCounters).forEach(function(c) {
		instCounters[c].nanos = 0;
		instCounters[c].hits = 0;
	});
}

if (config.monitorInstructions) {
	initInstructionMonitoring();
	process.on('exit', _dumpInstructionCounters);
}

var callCounters = {};
var curCallCounter = null;

function initCallMonitoring() {
	require('./flowControl').monitorCall = function(frame, action) {
		var key = frame.loc.file + ':' + frame.prog.name;
		var counter = callCounters[key] = callCounters[key] || {
			name: key,
			hits: 0,
			hr: null,
			nanos: 0,
			selfNanos: 0,
		};
		if (action === "enter") {
			if (curCallCounter) curCallCounter.selfNanos += nanos(process.hrtime(curCallCounter.hr));
			curCallCounter = counter;
			counter.hits++;
			counter.hr = process.hrtime();
		} else if (action === "exit") {
			counter.nanos += nanos(process.hrtime(counter.hr));
			counter.hr = process.hrtime(); // in case we got reentered.
		}
	};
}

function dumpCallCounters() {
	var counters = Object.keys(callCounters).map(function(k) {
		return callCounters[k];
	}).filter(function(c) {
		return c.hits;
	}).sort(function(c1, c2) {
		return c2.selfNanos - c1.selfNanos;
	}).map(function(c) {
		return 'self (ms): ' + millis(c.selfNanos) + '\ttotal (ms): ' + millis(c.nanos) + '\thits: ' + c.hits + //
		'\tcost (ns):' + Math.round(c.selfNanos / c.hits, 2) + '\t' + c.name;
	});
	//console.log(counters.join('\n'));
}

if (config.monitorCalls) {
	initCallMonitoring();
	process.on('exit', dumpCallCounters);
}

var hr0 = process.hrtime();

function dumpTotalTime() {
	//console.log("Total millis: " + millis(nanos(process.hrtime(hr0))));
}

if (config.monitorInstructions || config.monitorCalls) process.on('exit', dumpTotalTime);

exports.exit = function(code) {
	if (config.monitorInstructions) {
		_dumpInstructionCounters();
		_razInstructionCounters();
	}
	if (config.monitorCalls) dumpCallCounters();

	if (config.monitorInstructions || config.monitorCalls) dumpTotalTime();

	if (process.stdout.write("")) {
		//process.exit(0);
		setTimeout(function() {
			process.exit(0);
		}, 100);
	} else {
		process.stdout.on('drain', function() {
			process.exit(0);
		});
		process.stdout.write("");
	}
};

const PREDICATES = {
	startsWith: function(str, ignoreCase) {
		return {
			$regex: "^" + str,
			$options: ignoreCase ? 'i' : undefined,
		};
	}
}
class JsContext {
	constructor(args) {
		this.args = args;
	}
	cache(_, jsClassName, key, jsPropName) {
		// load class by js name to get its 4GL name
		var clas = this.args.THIS.value.supervisor.loadClassByJsName(_, jsClassName);
		if (!clas) throw new Error('cache class not found: ' + jsClassName);
		// lookup prop by js name to get its 4GL name
		var prop = clas.membersByJsName[jsPropName];
		if (!prop) throw new Error('cache property not found: ' + jsClassName + '.' + jsPropName);

		var acache = glob.context.x3session.actx.get(_, 'ACACHE');
		var cl = acache.get(_, clas.name);
		//console.error("CACHE LOOKUP", clas.name, key, prop.name);
		return cl.AGETVALNUM(_, key, prop.name);
	}
	message(_, id, chapter, swtch) {
		return exports.functions.MESS.fn(_, id, chapter, swtch);
	}
	error(_, text) {
		this.args.THIS.value.ASETERROR(_, this.args.CURPTH, text, 4); // CST_AERROR == 4
	}
	get predicates() {
		return PREDICATES;
	}
	get classes() {
		return this.args.THIS.value.supervisor.proxy.classes;
	}
}

var camelCache = {}

function camelify(name) {
	return camelCache[name] || (camelCache[name] = name.split('_').map(function(s, i) {
		return i === 0 ? s.toLowerCase() : s[0] + s.substring(1).toLowerCase();
	}).join(''));
}

var instanceProxy;

function invokeJs(_, mod, label, args) {
	instanceProxy = instanceProxy || require('etna/lib/supervisor/proxies/instanceProxy');
	const fns = mod.body[label];
	if (!fns) return 0;
	const member = args.path.length > 0 
		? args.path.reduce((r, p) => r && r[label] && r[label][p], mod.body) 
		: mod.body[label];
	if (!member) return 0;
	const action = label === 'properties' ? args.ARULE.value : args.AEVENT.value.substring(1);
	const fn = member[camelify(action)];
	if (!fn) return 0;
	const proxy = instanceProxy(args.THIS.value);
	//console.error("INVOKEJS", label, args.path, action);
	const arg1 = /^(CONTROL|PROPAGATE)$/.test(action) 
		? args.path.reduce_(_, (_, r, p) => r && r[p](_), proxy) 
		: undefined;
	try {
		fn.call(proxy, _, new JsContext(args), arg1);
		return 0; // ASTATUS OK
	} catch (ex) {
		console.error(ex.stack);
		return 4; // ASTATUS ERROR - see later
	}
}

exports.executeProg = function(_, mod, prog, args) {
	var frame = glob.context.x3frame;
	var prev = frame;
	var cx = prev.context;
	var result;
	var sl = (prev) ? prev.stackLevel + 1 : 0;
	glob.context.x3frame = frame = {
		values: {},
		types: {},
		context: cx,
		prev: prev,
		loopLevel: 0,
		stackLevel: sl,
		name: mod.name,
		loc: {
			file: mod.name,
			line: 0
		}
	};

	// current sub is the prog itself
	frame.sub = frame;
	frame.dicts = [frame, cx.globals, cx.sys];

	try {
		args && Object.keys(args).forEach_(_, function(_, name) {
			if (args[name].abrev) {
				if (frame.context.tables === undefined) {
					frame.context.tables = {};
					frame.dicts.push(frame.context.tables);
				}
				frame.context.tables[args[name].abrev] = args[name].value;
			} else {
				frame.values[name] = args[name].value;
				frame.types[name] = args[name].type;
			}
		});
		if (prog[0] !== '$') {
			// TODO: use X3Error to set error code
			if (!mod[prog]) throw new Error("Subprog not found: " + mod.name + '.' + prog);
			mod[prog].body(_);
			result = frame.result;
		} else { //ACTION must have $in the name
			var label = prog.substr(1);
			if (mod.$4gl || mod.body.$4gl) {
				//SUBPROG
				var ex = mod[label] || mod.body[label];
				ex(_);
				result = frame.values.ASTATUS || 0;
			} else {
				result = invokeJs(_, mod, label.toLowerCase(), args);
			}
		}
		args && Object.keys(args).forEach(function(name) {
			if (args[name].type && (args[name].type.charAt(0) === 'A' || args[name].set)) {
				args[name].value = frame.values[name];
			}
		});
	} finally {
		db.closeFiles([], sl);
		glob.context.x3frame = prev;
	}

	return result || 0;
};

function _initDebugger(_) {
	var first = true;
	scriptDebugger.start(_);
	Object.keys(exports.instructions).filter(function(k) {
		return trueInst.indexOf(k) != -1;
	}).forEach(function(k) {
		var instruction = exports.instructions[k];
		exports.instructions[k] = function debugWrapper() {
			var instArgs = Array.prototype.slice.call(arguments);
			var fn = instruction.apply(this, arguments);
			if (typeof fn !== "function") return;
			var loc = helpers.object.clone(util.sourceLoc);
			loc.file = loc.file.replace(/\\/, "/");
			var module = loc.file.substring(loc.file.lastIndexOf("/") + 1);
			debugTracer.debug && debugTracer.debug("wrap debug: " + k + " in " + module + ':' + loc.line + ", loc=" + sys.inspect(loc));
			// debugTracer.debug && debugTracer.debug("wrap debug: " + k + " in " + module + ':' + loc.line + ' - ' + sys.inspect(arguments, {
			// 	depth: 3
			// }));
			return function() {
				var frame = glob.context.x3frame,
					request = glob.context.request,
					session = request && request.session,
					debugContext = session && session.debugContext || {},
					args = arguments;

				// prevent entering in debugger when the debugger need to evaluate properties
				// debugTracer.debug("call debug: active=" + debugContext.isActive + ", status=" + debugContext.status + ", hit " + k + " in " + module + ':' + loc.line);
				if (debugContext.isActive && !glob.context.debug) {
					glob.context.debug = true;
					frame.sub.debug = {
						instruction: k,
						module: module,
						location: loc
					};
					debugContext.hit(function(err, result) {
						if (err) return args[0](err);
						glob.context.debug = false;
						return fn.apply(this, args);
					}, frame, request);
					// debugTracer.debug("call debug: " + k + " in " + module + ':' + loc.line + '\nargs=' + sys.inspect(arguments, {
					// 	depth: 3
					// }) + "\nframe=" + sys.inspect(frame));
					// streamline's apply_ introduces too much overhead - we can directly apply as this is a tail call
				} else {
					return fn.apply(this, args);
				}
			};
		};
	});
}

exports.dumpInstructionCounters = _dumpInstructionCounters;
exports.razInstructionCounters = _razInstructionCounters;