import { _ } from 'streamline-runtime';
import { Record, Hint, SqlColumnDesc } from '../drivers/types'
import * as types from './types';
import * as util from './util';
import * as basic from './basic';
import * as variables from './variables';
import * as operators from './operators';
import * as array from './arrays';
import * as dates from './dates';
import * as dbevaluate from './dbevaluate';
import { DBTableParent, WKey, TableKey, QueryKey, TableJoin, KeyExpression, KeyModified } from './dbtableparent';
import { DBTable, ContextFn } from './dbtable';
import { DBTableSQL } from './dbtablesql';
import { DBTableVAR } from './dbtablevar';
import { Table } from '../../supervisor/meta/table';
import { GClass } from './gclass';
import * as tdate from './tdate';
import * as tdatetime from './tdatetime';
import * as flowControl from './flowControl';
import { X3Error } from './errors';
const glob = require('streamline-runtime').globals;
import { Slots } from './slots';
const tracer = require('syracuse-core').getTracer("etna.engine");

interface LinkItem {
	name: string;
	abbrev: string;
}

export const functions = {
	FILECLA: {
		count: 0
	},
	FILEABRE: {
		count: 1,
		fn(n: number) {
			const frame = util.currentFrame();
			const tb = frame.context.tableSlots ? frame.context.tableSlots.get(n) : undefined;

			if (tb) return tb.getAbbrev();
			else return "";
		}
	},
	FILENAME: {
		count: 1,
		fn(n: number) {
			const frame = util.currentFrame();
			const tb = frame.context.tableSlots ? frame.context.tableSlots.get(n) : undefined;

			if (tb) return tb.getName();
			else return "";
		}
	},
	FILETYP: {
		count: 0,
		fn() {
			return 3;
		}
	},
	CLANBS: {
		count: 2,
		fn(cla: types.VariableDict, kind: number) {
			if (!cla) throw new X3Error(7, "invalid class");
			switch (kind) {
				case 1:
					return Object.keys(cla.types).length;
				case 2:
					return Object.keys(cla.values).length;
				default:
					throw new X3Error(10, "invalid value for clanbs parameter: " + typeof kind);
			}
		}
	},
	CLASIZ: {
		count: 2,
		fn(dict: types.VariableDict, exp_buf: void) {
			return 16;
		}
	},
	CLANAM: {
		count: 1,
		fn(dict: types.VariableDict) {
			return 0;
		}
	},
	CLAVAR: {
		count: 2,
		fn(dict: types.VariableDict, n: number) {
			var i = 1;
			var name = "";
			Object.keys(dict.types).forEach(field => {
				if (i === n) name = field;
				i++;
			});
			return name;
		}
	},
	CLALEV: {
		count: 1,
		fn(dict: types.VariableDict) {
			return dict ? 1 : 0;
		}
	}
};

const _etnaTypeToTyptyp: { [letter: string]: number } = {
	"J": 1,
	"I": 3,
	"N": 4,
	"W": 6,
	"S": 7,
	"D": 8,
	"B": 9,
	"T": 10,
	"Z": 11,
	"E": 12
};

function concat<T>(a1: T[], a2: T[]): T[] {
	return a1 && a2 ? a1.concat(a2) : a1 || a2;
}

function genSql(_: _, exp: any): WKey {
	const frame = util.currentFrame();
	const driver = frame.context.superv.sqlDriver;
	const val = typeof exp === 'function' ? exp(_) : exp;

	if (val && val.sql) return val;

	//special case
	if (Array.isArray(val)) {
		var t = val[2];
		if (val[1] > 1) throw new X3Error(26, "More than 1 dimension is not supported");
		var min = val[5] ? val[3] - val[5] : 0;
		var max = val[6] ? val[3] + val[6] - val[5] - 1 : val[4] - val[3];

		var r = {
			sql: "",
			type: typeof t[min],
			constants: util.arrayOfAny([]),
			func: util.arrayOfAny([]),
			isConstant: true
		};

		for (var i = min; i <= max; i++) {
			if (t[i]) {
				r.constants.push(t[i]);
				r.func.push(basic.instructions.C(t[i]));
				r.sql += i > min ? ',' : '';
				r.sql += "@?";
			}
		}
		return r;
	} else return {
		sql: "@?",
		type: typeof val,
		constants: [val.x3ToSql(driver) || val],
		isConstant: true,
		func: basic.instructions.C(val)
	};
}

function binaryOp(op: string, sqlOp: string, type: string, numOp?: string, numType?: string) {
	return function (op1: any, op2: any) {
		return function binaryOp$do(_: _) {
			const frame = util.currentFrame();
			const ctx = frame.whereContext;

			if (!frame.tryingSql) return util.any(operators.instructions)[op](op1, op2)(_);
			var v1 = genSql(_, op1);
			const v2 = genSql(_, op2);

			var unary = false;

			if (v1.tooComplex || v2.tooComplex) return {
				sql: "(1 = 1)",
				tooComplex: true,
				func: binaryOp(op, sqlOp, type, numOp, numType)(v1.func, v2.func),
				constants: [],
				columns: (v1.columns || []).concat(v2.columns || [])
			};

			// the killing death hack for pat and find			
			if (v1.field && ["PAT", "FIND"].indexOf(v1.field) >= 0) {
				var v = v2.constants[0];
				if (!(v === 0 && op === "NE" || v !== 0 && op === "EQ" || v > 0 && op === "GE" || v >= 0 && op === "GT" || v < 0 && op === "LE" || v <= 0 && op === "LT")) {
					ctx.revert = true;
					v1 = genSql(_, op1);
					ctx.revert = false;
				}
				unary = true;
			}

			if (numOp && v1.type === v2.type && v1.type === "number") sqlOp = numOp, type = numType;
			var sql: string;
			if (sqlOp === "CONCAT") {
				if (numOp === '-') {
					v1.sql = "RTRIM(" + v1.sql + "),' '";
					v2.sql = "' ',LTRIM(" + v2.sql + ")";
				}
				sql = "CONCAT(" + v1.sql + "," + v2.sql + ")";
			} else {
				sql = unary ? "(" + v1.sql + ")" : "(" + v1.sql + " " + sqlOp + " " + v2.sql + ")";
			}
			const vals = unary ? v1.constants || [] : (v1.constants || []).concat(v2.constants || []);
			const colu = unary ? v1.columns || [] : (v1.columns || []).concat(v2.columns || []);

			return {
				sql: sql,
				type: type,
				constants: vals,
				columns: colu,
				tooComplex: false,
				func: binaryOp(op, sqlOp, type, numOp, numType)(v1.func, v2.func)
			};
		};
	};
}

function _closeFile(frame: types.Frame, abbrev: string) {
	(frame.context.tables[abbrev].sisters || []).forEach(absister => {
		if (frame.context.tables[absister]) {
			_closeFile(frame, absister);
		}
	});

	frame.context.tableSlots.freeSlot(frame.context.tables[abbrev].slot);

	if (frame.context.tables[abbrev].inFrontOf) {
		frame.context.tables[abbrev] = frame.context.tables[abbrev].inFrontOf;
		if (frame.context.gclass[abbrev].inFrontOf) frame.context.gclass[abbrev] = frame.context.gclass[abbrev].inFrontOf;
	} else {
		delete frame.context.tables[abbrev];
		delete frame.context.gclass[abbrev];
	}

	if (abbrev === frame.abbrev) frame.abbrev = null;
}

export function closeFiles(abbrevs: string[], local: number) {
	const frame: types.Frame = util.currentFrame();
	const ttab = abbrevs.length ? abbrevs : Object.keys(frame.context.tables);

	ttab.forEach(abbrev => {
		if (frame.context.tables[abbrev] && frame.context.tables[abbrev].local >= local) {
			_closeFile(frame, abbrev);
		}
	});
}

function rowIn(_: _, row: Record, descs: types.RowDesc[]) {
	const result: Record = {};
	return descs.reduce_(_, (_, obj, desc) => {
		obj[desc.name] = desc.type.fromSql(_, row[desc.name]); // for now!
		return obj;
	}, result);
}

interface SqlFunction {
	sql: string;
	type: string;
	constants: string[];
	tooComplex?: boolean;
}

function sqlFn(name: string, type: string) {
	return function () {
		const thesql = name + "(" + Array.prototype.map.call(arguments, (arg: SqlFunction) => arg.sql).join(',') + ")";

		return {
			sql: thesql,
			type: type,
			tooComplex: false
		};
	};
}

function tooComplex() {
	return {
		sql: "(1 = 1)",
		tooComplex: true
	};
}

function defVal(type: string): any {
	switch (type) {
		case 'string':
			return '';
		case 'number':
			return 0;
		case 'date':
			return null; //TODO : dates.MIN;
		case 'binary':
			return null;
		default:
			throw new Error('unsupported column type: ' + type);
	}
}

const sqlCmpOps: { [name: string]: { op: string; combine: string; }; } = {
	EQ: {
		op: '=',
		combine: 'and'
	},
	NE: {
		op: '<>',
		combine: 'or'
	},
	LT: {
		op: '<',
		combine: 'lexi'
	},
	LE: {
		op: '<=',
		combine: 'lexi'
	},
	GT: {
		op: '>',
		combine: 'lexi'
	},
	GE: {
		op: '>=',
		combine: 'lexi'
	}
};
const sqlFunctions: { [name: string]: Function } = {
	// string functions
	LEN() {
		const frame: types.Frame = util.currentFrame();
		const driver = frame.context.superv.sqlDriver;

		var thesql = driver.lengthString();
		thesql += "(" + Array.prototype.map.call(arguments, (arg: SqlFunction) => arg.sql).join(',') + ")";
		return {
			sql: thesql,
			type: "number",
			tooComplex: false
		};
	},
	//RIGHT$: sqlFn("RIGHT", "string"),
	//MID$: sqlFn("SUBSTRING", "string"),
	TOUPPER: sqlFn("UPPER", "string"),
	TOLOWER: sqlFn("LOWER", "string"),
	CHR$: sqlFn("CHAR", "string"),
	LEFT$(arg: SqlFunction, len: SqlFunction) {
		const frame = util.currentFrame();
		const driver = frame.context.superv.sqlDriver;

		return {
			sql: driver.subString(arg.sql, "1", len.sql),
			type: "string",
			tooComplex: false
		};
	},
	MID$(arg: SqlFunction, first: SqlFunction, len: SqlFunction) {
		const frame = util.currentFrame();
		const driver = frame.context.superv.sqlDriver;

		return {
			sql: driver.subString(arg.sql, first.sql, len.sql),
			type: "string",
			tooComplex: false
		};
	},
	/*
 // have to repeat twice one paramter, can t do it
 SEG$(arg, first, last) {
 	var frame = util.currentFrame();
 	var driver = frame.context.superv.sqlDriver;
 		return {
 		sql: driver.subString(arg.sql, first.sql, len.sql),
 		sql: "SUBSTRING(" + arg.sql + "," + first.sql + "," + last.sql + " + 1 - " + first.sql + ")",
 		type: "string",
 		tooComplex: false
 	};
 },
 */
	CTRANS(arg: SqlFunction) {
		//if (arguments.length > 1) throw tooComplex();
		return {
			sql: "CONVERT(" + arg.sql + " USING ASCII)",
			type: "string",
			tooComplex: false
		};
	},
	PAT(str: SqlFunction, pat: SqlFunction, revert: SqlFunction) {
		const not = revert ? " NOT" : "";

		return {
			sql: "(" + str.sql + not + " LIKE '" + pat.constants[0].replace(/%/g, '%%').replace(/\*/g, '%' + "'") + ")",
			type: "string",
			constants: util.arrayOfAny([]),
			tooComplex: false
		};
	},

	// Numeric functions
	ABS: sqlFn("ABS", "number"),
	MOD: sqlFn("MOD", "number"),
	// investigate neg values
	ARR2(arg: SqlFunction) {
		return {
			sql: "ROUND(" + arg.sql + ",2)",
			type: "number",
			tooComplex: false
		};
	},

	ARR: sqlFn("ROUND", "number"),
	FIX: sqlFn("TRUNCATE", "number"),
	INT: sqlFn("FLOOR", "number"),
	SQR: sqlFn("SQRT", "number"),
	COS: sqlFn("COS", "number"),
	SIN: sqlFn("SIN", "number"),
	TAN: sqlFn("TAN", "number"),
	ACOS: sqlFn("ACOS", "number"),
	ASIN: sqlFn("ASIN", "number"),
	ATAN: sqlFn("ATAN", "number"),
	PI: sqlFn("PI", "number"),
	EXP: sqlFn("EXP", "number"),
	LN: sqlFn("LOG", "number"),
	LOG: sqlFn("LOG10", "number"),

	// Find
	FIND(arg: SqlFunction) {
		var not = '';
		const vals: SqlFunction[] = Array.prototype.slice.call(arguments, 1);

		if (!vals[vals.length - 1].sql) {
			vals.pop();
			not = " NOT";
		}
		return {
			sql: "(" + arg.sql + not + " IN (" + vals.map(val => val.sql).join(',') + "))",
			type: "number"
		};
	}

	// see later about date functions
};

type SqlPatFn = (_: _, args: types.Expression<any>[], ctx: types.QueryContext) => WKey;

const sqlFindPat: { [name: string]: SqlPatFn } = {
	FIND(_, args, ctx) {
		const sqlFunc = sqlFunctions["FIND"];
		const frame = util.currentFrame();

		if (!frame.tryingSql) return flowControl.instructions.F('FIND', args)(_);

		var cst = true;
		var params: types.Expression<any>[] = [];
		var consts: string[] = [];
		var columns: QueryKey[] = [];

		const argSqls = args.map_(_, (_, arg) => {
			const s = genSql(_, arg);

			if (!s.isConstant) cst = false;
			if (Array.isArray(s.func)) params = params.concat(s.func);
			else params.push(s.func);
			consts = consts.concat(s.constants || []);
			columns = columns.concat(s.columns || []);
			return s;
		});

		if (cst) return flowControl.instructions.F('FIND', args)(_);
		else {
			if (ctx.revert) {
				// Typing is very confusing here - how can we push true into a WKey[]
				argSqls.push(util.any(true));
				ctx.revert = false;
			}
			var r = sqlFunc.apply(this, argSqls);
			r.func = instructions.SQLF("FIND", params);
			r.field = "FIND";
			if (!r.constants) r.constants = consts;
			if (!r.conlumns) r.columns = columns;
			return r;
		}
	},

	PAT(_, args, ctx) {
		const sqlFunc = sqlFunctions["PAT"];
		const frame = util.currentFrame();

		if (!frame.tryingSql) return flowControl.instructions.F('PAT', args)(_);

		var cst = true;
		const params: types.Expression<any>[] = [];

		var consts: string[] = [];
		var columns: QueryKey[] = [];

		const argSqls = args.map_(_, (_, arg) => {
			const s = genSql(_, arg);

			if (!s.isConstant) cst = false;
			params.push(s.func);
			consts = consts.concat(s.constants || []);
			columns = columns.concat(s.columns || []);
			return s;
		});

		if (cst) return flowControl.instructions.F('PAT', args)(_);
		else {
			if (ctx.revert) {
				// Typing is very confusing here - how can we push true into a WKey[]
				argSqls.push(util.any(true));
				ctx.revert = false;
			}
			var r = sqlFunc.apply(this, argSqls);
			r.func = instructions.SQLF("PAT", params);
			r.field = "PAT";
			if (!r.constants) r.constants = consts;
			if (!r.conlumns) r.columns = columns;
			return r;
		}
	}
};

function findTable(frame: types.Frame, abbrev: string) {
	// use frame's default abbrev by default
	//debugger;
	const table: DBTable = util.any(frame.context.tables[abbrev || frame.abbrev]);

	if (!table) throw new X3Error(7, "bad table abbrev: " + abbrev);
	//dbg:console.error("findTable "+abbrev+" test:"+ (table instanceof DBTable) );
	return table;
}

function keyAnalysis(_: _, cmd: string, key: types.Expression<any>, op: string, vals: any[]) {
	const frame = util.currentFrame();
	const session = util.currentSession();
	const driver = frame.context.superv.sqlDriver;
	const k = key(_);

	if (k && k.indices && k.indices.length > 1) {
		throw new X3Error(26, "Illegal number of indice");
	}

	//var vals = avalues(_);
	const table = findTable(frame, k ? k.abbrev : "");
	// Typing problem here: findKey returns TableKey but nkey needs to be a KeyExpression???
	const nkey: any = table.findKey(k ? k.name : "");

	var kln = k && k.indices && k.indices[0] || nkey.items.length;
	const direction = 1;

	// update current key if specified

	if (["read", "for"].indexOf(cmd) >= 0) {
		if (k.name) {
			table.currkey = nkey.kslot;
			table.currlen = kln;
		} else kln = table.currlen; // we get allready currkey
	}

	var wkey: WKey[];
	var krevert = false;
	op = op || 'CURR';
	switch (op) {
		case 'CURR':
			if (cmd !== "wdelete") {
				if (!table.values["ROWID"] && !table.curpos) throw new X3Error(26, "No Current rowid");

				if (cmd === "read") {
					//var rsql = table.abbrev + ".ROWID = " + driver.param(0);
					var rsql = table.abbrev + ".ROWID = ";
				} else {
					//var rsql = "ROWID = " + driver.param(0);
					var rsql = "ROWID = ";
				}
				rsql += driver.rowIdPut("@?");

				wkey = [{
					rowid: true,
					sql: rsql,
					constants: [table.values["ROWID"]],
					tooComplex: false,
					isConstant: false
				}];
			}
			break;
		case 'LT':
		case 'LE':
			krevert = true;
		case 'GT':
		case 'GE':
		case 'EQ':
			if (vals.length === 0) vals = table.getKeyValues(_, nkey, kln);
			var keyw = instructions.SQLKEY(k.name, op, k.indice ? basic.instructions.A([basic.instructions.C(k.indices)]) : basic.instructions.C(null), vals);
			break;
		case 'FIRST':
			break;
		case 'LAST':
			krevert = true;
			break;
		case 'PREV':
		case 'NEXT':
		case 'NXT':
			throw new X3Error(26, "Deprecated functionnnality");
		default:
			throw new X3Error(26, "Illegal read operator");
	}
	if (keyw) {
		var ctx: types.QueryContext = {};
		ctx.tables = [table.abbrev];
		wkey = instructions.WHERE([keyw])(_, ctx);
	}

	return {
		table: table,
		nkey: nkey,
		wkey: wkey,
		kln: kln,
		krevert: krevert
	};
}

function _littleFieldAnalysis(s: string) {
	var letter: string, abbrev: string, field: string;
	const p0 = s.indexOf('[');
	const p1 = s.indexOf(':');
	const p2 = s.indexOf(']');

	if (p0 >= 0 && p2 >= 0) {
		if (p1 < 0) abbrev = s.slice(p0 + 1, p2);
		else abbrev = s.slice(p1 + 1, p2);

		field = s.slice(p2 + 1);
	} else if (p0 < 0 && p2 < 0) {
		field = s;
	} else throw new X3Error(50, s);

	return {
		letter: 'F',
		abbrev: abbrev,
		field: field
	};
}

function identity(x: any) {
	return x;
}

function asDBTable(table: DBTableParent) : DBTable {
	return util.any(table);
}

export const instructions = {
	SYMBOL(symb: void, app: void) {
		return function symbol$do(_: _) {};
	},
	LOCK(args: void, lw: void) {
		return function lock$do(_: _) {
			const frame = util.currentFrame();

			frame.context.sys.values.FSTAT = 0;
		};
	},
	UNLOCK(args: void, lw: void) {
		return function lock$do(_: _) {
			const frame = util.currentFrame();

			frame.context.sys.values.FSTAT = 0;
		};
	},
	NBRECORD(abbrev: string) {
		return function nbrecord$do(_: _) {
			const frame = util.currentFrame();
			const table = asDBTable(findTable(frame, abbrev));
			const qry = "Select Count(*) as A$RESULT_0 From " + table.desc.name + " A";
			const res = frame.context.superv.executeSql(_, qry, [], {
				typesmap: [3],
				dispatch: true
			});

			return res[0]["A"].RESULT;
		};
	},
	UNIQID(abbrev: string) {
		return function uniqid$do(_: _) {
			const frame = util.currentFrame();
			const table = asDBTable(findTable(frame, abbrev));
			const driver = frame.context.superv.sqlDriver;
			const qry = driver.uniqid(table.desc.name);
			const res = frame.context.superv.executeSql(_, qry, [], {
				typesmap: [3],
				dispatch: true
			});

			return res[0]["A"].RESULT;
		};
	},
	ROWCOUNT(abbrev: string) {
		return function rowcount$do(_: _) {
			const frame = util.currentFrame();
			const session = util.currentSession();
			const table = asDBTable(findTable(frame, abbrev));

			return table.x3Rowcount(_);
		};
	},

	KEY(letter: string, abbrev: string, name: string, indices: types.Expression<any>[]) {
		return function key$do(_: _) {
			return {
				letter: letter,
				abbrev: abbrev,
				name: name,
				indices: indices && indices.map_(_, (_, exp) => exp(_))
			};
		};
	},
	EXECSQL(fsql: types.Expression<string>) {
		return function execsql$do(_: _) {
			const frame = util.currentFrame();
			const session = util.currentSession();
			const driver = frame.context.superv.sqlDriver;
			const sql = fsql(_);

			var rs: any;
			try {
				rs = driver.execute(_, session.dbConnection, sql, []);
			} catch (e) {
				if (driver.isTableNotFound(e)) throw new X3Error(106, e.message);
				else throw e;
			}
			if (rs) {
				var v = rs.updateCount || rs.deleteCount;
				frame.context.sys.values.ADXSQLREC = v !== undefined ? v : 0;
			} else frame.context.sys.values.ADXSQLREC = 0;
		};
	},
	ANASQL(fsql: types.Expression<string>, fvar: types.Expression<number[]>) {
		return function anasql$do(_: _) {
			const frame = util.currentFrame();
			const session = util.currentSession();
			const driver = frame.context.superv.sqlDriver;
			const folder = frame.context.superv.folderName;
			const sql = fsql(_);
			const tab = driver.describeQuery(_, sql, folder);
			const s = fvar(_);
			const min = s[3];
			const max = s[6] ? s[3] + s[6] - 1 : s[4];

			// 0 indice

			var fidx = array.instructions.INDEX(fvar, [basic.instructions.C(min)]);
			fidx(_, true, tab.length);

			for (var i = 0, j = min + 1; i < tab.length; i++) {
				fidx = array.instructions.INDEX(fvar, [basic.instructions.C(j)]);
				fidx(_, true, tab[i].type);
				j++;
			}
		};
	},
	SQLDECL(type: string, name: string, ranges: void) {
		return function sqldecl$do(_: _,  abv: string): SqlColumnDesc {
			const frame = util.currentFrame();
			const table = frame.context.tables[abv];

			table.declVar(type, name);
			return {
				name: name,
				typtyp: _etnaTypeToTyptyp[type[1]]
			};
		};
	},
	FORSQL(fsql: types.Expression<string>, abv: string, vars: ((_: _, abv: string) => SqlColumnDesc)[], 
	p: types.Expression<any>[], end: number, block: types.Expression<any>) {
		return function forsql$do(_: _) {
			const frame = util.currentFrame();
			const session = util.currentSession();
			const driver = frame.context.superv.sqlDriver;
			const table = frame.context.tables[abv] = new DBTableSQL(driver, abv, frame.context.superv, frame.stackLevel, fsql(_));
			const fieldList: SqlColumnDesc[] = []; /* declare field */

			for (var i = 0; i < vars.length; i++) {
				fieldList[i] = vars[i](_, abv);
			}

			const cf = table.x3OpenFor(_, fieldList);

			var rec = cf.x3GetRecord(_);

			const level = ++frame.loopLevel;

			while (frame.loopLevel === level) {
				if (rec) {
					// execution du block
					block(_);

					if (frame.loopLevel !== level) {
						cf.x3CloseDBReader(_);
						continue;
					}

					// classic for
					rec = cf.x3GetRecord(_);
				} else {
					frame.loopLevel = level - 1;
				}
			}
			if (frame.loopLevel === level - 1) {
				if (cf.level === 0) {
					table.x3CloseFor();
				} else cf.level--;
				p[end](_);
			}
			delete frame.context.tables[abv];
		};
	},
	VAR(type: string, name: string, len: types.Expression<number>) {
		return function var$do(_: _, abv: string) {
			const frame = util.currentFrame();
			const table = frame.context.tables[abv];
			const vlen = len ? "" + len(_) : "";

			table.declVar(type + vlen, name);
		};
	},
	VTBINDEX(target: types.Expression<any>, args: types.Expression<number>[]) {
		return function vtbindex$do(_: _, analyse: any) {
			if (analyse) return target(_, analyse);
			else return array.instructions.INDEX(target, args)(_);
		};
	},
	VTBCV(letter: string, abbrev: string, field: string, silent: boolean) {
		return function vtbcv$do(_: _, analyse: any) {
			if (analyse) return variables.instructions.CV(letter, abbrev, field, silent);
			else return variables.instructions.CV(letter, abbrev, field, silent)(_);
		};
	},
	VTBV(field: string): any {
		return function vtbv$do(_: _, analyse: any) {
			if (analyse) return variables.instructions.V(field);
			else return variables.instructions.V(field)(_);
		};
	},
	FILEVAL(abb: string, vars: ContextFn<any>[], frv: ContextFn<any>[], 
	where: ContextFn<any>, order: ContextFn<any>) {
		return function dot$do(_: _) {
			const frame = util.currentFrame();
			const session = util.currentSession();

			frame.context.tableSlots = frame.context.tableSlots || new Slots();
			const nslt = frame.context.tableSlots.getSlot();

			// extracting values

			const tbvalues = basic.instructions.A(frv)(_);
			// extracting table var

			const tbvar = frv.map_(_, (_, e) => e(_, 1));

			if (tbvar.length !== vars.length) throw new X3Error(69, abb);

			const table = new DBTableVAR(abb, frame.context.superv, frame.stackLevel, tbvar, tbvalues);
			const gclas = new GClass(table);

			table.slot = nslt;
			frame.context.tableSlots.set(nslt, table);
			if (frame.context.tables[abb]) {
				table.inFrontOf = frame.context.tables[abb];
				gclas.inFrontOf = frame.context.gclass[abb];
				frame.context.tables[abb] = table;
				frame.context.gclass[abb] = gclas;
			} else {
				frame.context.gclass[abb] = gclas;
				frame.context.tables[abb] = table;
			}

			// new the other parameters
			for (var i = 0; i < vars.length; i++) {
				vars[i](_, abb);
			}

			const ctx: types.QueryContext = {};

			ctx.tables = [table.abbrev];
			table.where = where && where(_, ctx);

			// order by
			const newkey = order && order(_, ctx);

			if (newkey) {
				table.x3SetNewKey(_, newkey);
			}

			// init filter
			table.filter = {};

			// default table
			frame.abbrev = abb;
		};
	},
	FILESQL(abbrev: string, name: types.Expression<string>, where: ContextFn<any>, order: ContextFn<any>): types.Expression<DBTable> {
		return function file$do(_) {
			const frame = util.currentFrame();
			const driver = frame.context.superv.sqlDriver;
			const nameVal = name(_);
			const desc: Table = frame.context.superv.load(_, 'Table', nameVal);

			if (!desc) throw new X3Error(7, "unknown table or unsupport FILE syntax: " + nameVal);
			const abb = abbrev || desc.abbrev;
			const ctx: types.QueryContext = {};

			if (frame.context.tables[abb] && frame.context.tables[abb].local === frame.stackLevel) throw new X3Error(28, abb);

			frame.context.tableSlots = frame.context.tableSlots || new Slots();
			const nslt = frame.context.tableSlots.getSlot();

			ctx.tables = [abb];

			// init keys
			var kslot = -1;
			//const tkeys = desc.indexes.map(idx => {
			const tkeys = desc.indexes.map(idx => {
				var sql = "";
				const funcs: types.Expression<WKey[]>[] = [];
				const dir: number[] = [];
				const items: string[] = [];
				const colu: QueryKey[] = [];

				kslot++;
				for (var i = 0; i < idx.columns.length; i++) {
					dir.push(idx.direction[i]);
					funcs.push(instructions.SQLCV('F', abb, idx.columns[i].name));
					if (i > 0) sql += ", ";
					sql += idx.columns[i].sqlNames(abb + ".") + (idx.direction[i] < 0 ? " Desc" : "");
					items.push(idx.columns[i].sqlNames(abb + "."));
					colu.push({
						abbrev: abb,
						field: idx.columns[i],
						index: 0
					});
				}
				return {
					name: idx.name,
					unique: idx.unique,
					hidden: false,
					constants: [],
					func: funcs,
					sql: sql,
					directions: dir,
					items: items,
					index: idx,
					kslot: kslot,
					columns: colu
				};
			});

			// where

			const table = new DBTable(driver, abb, frame.context.superv, desc, tkeys, frame.stackLevel).init(_);
			const gclas = new GClass(table);

			table.slot = nslt;
			frame.context.tableSlots.set(nslt, table);
			if (frame.context.tables[abb]) {
				table.inFrontOf = frame.context.tables[abb];
				gclas.inFrontOf = frame.context.gclass[abb];
				frame.context.tables[abb] = table;
				frame.context.gclass[abb] = gclas;
			} else {
				frame.context.gclass[abb] = gclas;
				frame.context.tables[abb] = table;
			}

			table.where = where && where(_, ctx);

			// order by
			const newkey = order && order(_, ctx);

			if (newkey) {
				table.x3SetNewKey(_, newkey);
			}

			// init filter
			table.filter = {},

			// default table
			frame.abbrev = abb;

			// For the supervisor :
			return table;
		};
	},
	CLOSEFILE(scope: string, abbrevs: string[]) {
		return function closefile$do(_: _) {
			closeFiles(abbrevs, scope === 'LOCAL' ? util.currentFrame().stackLevel : 0);
		};
	},
	LOGICCLOSE(scope: string, abbrevs: string[]) {
		return function logicclose$do(_: _) {
			closeFiles(abbrevs, util.currentFrame().stackLevel);
		};
	},
	FILTER(abbrev: string, where: ContextFn<any>, order: ContextFn<any>) {
		return function filter$do(_: _) {
			const frame = util.currentFrame();
			const table = findTable(frame, abbrev);

			// delete old filter

			if (table.filter) {
				if (table.filter.key) {
					// Typing pb: there is no `index`field in TableKey - so I commented out next line.
					//if (!table.keys[table.filter.key].index) delete table.keys[table.filter.key];
					table.keys.forEach(ky => {
						ky.hidden = false;
					});
				}
				if (table.currkey === table.filter.key) {
					table.currkey = 0;
					table.currlen = table.keys[0].items.length;
				}
				table.filter = {};
			}

			if (!where && !order) return 0;

			// table in views
			const ctx: types.QueryContext = {};

			ctx.tables = [table.abbrev];
			if (table.joins) {
				table.joins.forEach(join => {
					ctx.tables.push(join.table.abbrev);
				});
			}

			const newkey = order && order(_, ctx);

			if (newkey) {
				table.x3SetNewKey(_, newkey);
			}

			table.filter = {
				where: where && where(_, ctx),
				key: newkey ? table.currkey : undefined
			};
		};
	},

	COLUMNSITEM(abbrev: string, field: string, index: types.Expression<number>): types.Expression<QueryKey> {
		return function columnsitem$do(_, def) {
			const frame = util.currentFrame();
			const abv = abbrev || util.any(def); // weird typing for def paramater!

			if (field != null) {
				return {
					abbrev: abv,
					field: findTable(frame, abv).desc.columns[field],
					index: index ? index(_) : 0
				};
			} else {
				/* complete table */
				var t = findTable(frame, abbrev);
				return {
					abbrev: abbrev,
					field: null,
					index: null
				};
			}
		};
	},
	COLUMNS(abbrev: string, columns: ContextFn<QueryKey>[], ext: any): types.Expression<void> {
		return function columns$do(_) {
			//debugger ;
			const frame = util.currentFrame();
			const table = findTable(frame, abbrev);
			const master = util.any(table).master || table;

			if (columns) {

				var _addColumn = function(r: QueryKey[], t: QueryKey) {
					const n = r.length;

					for (var i = 0; i < n; i++) {
						if (r[i].field === t.field && r[i].index === t.index) break;
					}
					//if (t.abbrev) delete t.abbrev;
					if (i === n) r.push(t);
				};
				// columns is an array of [abbrev, field] pairs
				table.columns = columns.reduce_(_, (_, r, citem) => {
					const t = citem(_, master.abbrev);

					if (t.field === null) r[t.abbrev] = null;
					else {
						if (r[t.abbrev] !== null) {
							r[t.abbrev] = r[t.abbrev] || [];
							_addColumn(r[t.abbrev], t);
						}
					}
					return r;
				}, {} as util.Dict<QueryKey[]>);
				// typing??
				util.any(table.columns).extended = ext;
			} else {
				// erase the column filter
				table.columns = undefined;
			}
		};
	},
	HINT(nohint: any, key: types.Expression<any>) {
		return function hint$do(_: _) {
			const k = key && key(_);

			return {
				nohint: nohint,
				abbrev: k ? k.abbrev : "",
				name: k ? k.name : ""
			};
		};
	},
	LINKITEM(key: types.Expression<LinkItem>, outer: boolean, values: types.Expression<any>[]): ContextFn<TableKey> {
		return function linkitem$do(_, ctx) {
			const frame = util.currentFrame();
			const k = key(_);
			const abv = k.abbrev || frame.abbrev;
			const table = findTable(frame, k.abbrev);
			const joink = table.findKey(k.name);

			var consts: string[] = [];

			ctx.tables.push(abv);

			if (table.master) throw new X3Error(26, "Alread linked");

			const sql = (outer ? " LEFT OUTER " : " ") + " JOIN " + table.desc.name + " " + k.abbrev //
			 + " ON " + values.map_(_, (_, val, i) => {
				frame.tryingSql = true;
				frame.whereContext = ctx;
				const v = genSql(_, val);
				frame.tryingSql = false;
				frame.whereContext = undefined;

				if (v.tooComplex) throw new X3Error(26, "Unable to build the link because of comlexity");
				consts = consts.concat(v.constants || []);

				//return index.columns[i].sqlNames(abv + ".") + " = " + val.sql;
				return joink.items[i] + " = " + v.sql;
			}).join(" AND ");

			return {
				table: table,
				sql: sql,
				constants: consts
			};
		};
	},
	LINK(abbrev: string, as: string, joins: ContextFn<TableJoin>[], where: ContextFn<WKey[]>, order: ContextFn<KeyExpression>) {
		return function link$do(_: _) {
			const frame = util.currentFrame();
			const table = findTable(frame, abbrev);
			const ctx: types.QueryContext = {};

			//debugger;

			ctx.tables = [table.abbrev];
			if (table.master) throw new X3Error(26, "Link on a Link");
			if (frame.context.tables[as]) throw new X3Error(28, as);
			table.sisters = table.sisters || [];
			table.sisters.push(as);

			// TODO: fix DBTable constructor overload
			const lktable = frame.context.tables[as] = new DBTable(util.any(table), table.abbrev).init(_);

			frame.context.gclass[as] = new GClass(lktable);

			const nslt = frame.context.tableSlots.getSlot();

			lktable.slot = nslt;
			frame.context.tableSlots.set(nslt, lktable);

			lktable.joins = joins.map_(_, (_, jitm) => jitm(_, ctx));

			lktable.filter = {};
			lktable.where = where && where(_, ctx);
			const newkey = order && order(_, ctx);

			if (newkey) {
				lktable.x3SetNewKey(_, newkey);
			}
		};
	},
	LOOK(key: types.Expression<any>, op: string, values: types.Expression<any>[], lock: boolean, hint: Hint) {
		const avalues = basic.instructions.A(values);

		return function look$do(_: _) {
			const frame = util.currentFrame();
			const session = util.currentSession();
			const vals = avalues(_);
			const ka = keyAnalysis(_, 'read', key, op, vals);
			const table = asDBTable(ka.table);

			//save record :
			const rec: Record = {};

			Object.keys(ka.table.values).forEach(field => {
				rec[field] = ka.table.values[field];
			});

			const fst = table.x3Read(_, ka.nkey, ka.kln, ka.wkey, ka.krevert, lock, hint);

			if (fst === 0 && (op === 'GE' || op === 'LE')) {
				if (table.keyCompare(_, ka.nkey, vals) === 0) frame.context.sys.values.FSTAT = 0;
				else frame.context.sys.values.FSTAT = 2;
			} else frame.context.sys.values.FSTAT = fst;
			rec["ROWID"] = table.values["ROWID"];
			table.values = rec;
		};
	},

	READ(key: types.Expression<any>, op: string, values: types.Expression<any>[], lock: boolean, hint: types.Expression<Hint>) {
		const avalues = basic.instructions.A(values);

		return function read$do(_: _) {
			const frame = util.currentFrame();
			const session = util.currentSession();
			const vals = avalues(_);
			const hnt = hint ? hint(_) : null;
			const ka = keyAnalysis(_, 'read', key, op, vals);
			const table = asDBTable(ka.table);
			const fst = table.x3Read(_, ka.nkey, ka.kln, ka.wkey, ka.krevert, lock, hnt);

			if (fst === 0 && (op === 'GE' || op === 'LE')) {
				if (table.keyCompare(_, ka.nkey, vals) === 0) frame.context.sys.values.FSTAT = 0;
				else frame.context.sys.values.FSTAT = 2;
			} else frame.context.sys.values.FSTAT = fst;
		};
	},
	WRITE(abbrev: string) {
		return function write$do(_: _) {
			const frame = util.currentFrame();
			const table = asDBTable(findTable(frame, abbrev));

			table.setCurrentLogin(frame.loginName || "USER");

			frame.context.sys.values.FSTAT = table.x3Write(_);
		};
	},
	REWRITEBYKEY(key: void, op: void, values: types.Expression<any>[]) {
		const avalues = basic.instructions.A(values);

		return function rewritebykey$do(_: _) {
			//TODO ??????
		};
	},
	REWRITE(key: types.Expression<any>, op: string, values: types.Expression<any>[]) {
		const avalues = basic.instructions.A(values);

		return function rewrite$do(_: _) {
			const frame = util.currentFrame();
			const driver = frame.context.superv.sqlDriver;
			const vals = avalues(_);
			const ka = keyAnalysis(_, 'rewrite', key, op, vals);
			const table = asDBTable(ka.table);

			// build values tables assignation
			// ----------------------------------------------------------

			const vassig: any[] = [];
			const abv = (table.master || table).abbrev;
			const lst = table.columns && table.columns[abv];

			if (lst) {
				for (var i = 0; i < lst.length; i++) {
					var cname = lst[i].field.data.CODZONE;
					if (Array.isArray(table.values[cname])) {
						var tb = table.values[cname][2];
						if (tb[lst[i].index] !== undefined) vassig.push(tb[i].x3ToSql(driver));
						else {
							throw new Error("invalid code path");
							// nuked following statement because col is undefined.
							//vassig.push(col.type.defaultValue.x3ToSql(driver));
						}
					} else {
						vassig.push(table.values[cname].x3ToSql(driver));
					}
				}
			} else {
				Object.keys(table.desc.columns).forEach(cname => {
					if (cname === "ROWID") return;
					if (Array.isArray(table.values[cname])) {
						var col = table.desc.columns[cname];
						for (var i = 0; i < col.data.DIME; i++) {
							var tb = table.values[cname][2];
							if (tb[i] !== undefined) vassig.push(tb[i].x3ToSql(driver));
							else {
								vassig.push(col.type.defaultValue.x3ToSql(driver));
							}
						}
					} else {
						tracer.debug && tracer.debug("Assig " + cname + ":" + table.values[cname]);
						vassig.push(table.values[cname].x3ToSql(driver));
					}
				});
			}

			// guive the hand to the table for query and execution
			const fs = table.x3Rewrite(_, ka.wkey, vassig);

			frame.context.sys.values.FSTAT = fs;
		};
	},
	DELETE(key: types.Expression<any>, where: ContextFn<WKey[]>, op: string, values: types.Expression<any>[]) {
		const avalues = basic.instructions.A(values);

		return function delete$do(_: _) {
			//debugger;
			const frame = util.currentFrame();
			const session = util.currentSession();
			const vals = avalues(_);
			const ka = keyAnalysis(_, where ? "wdelete" : "kdelete", key, op, vals);
			const table = asDBTable(ka.table);

			//debugger;

			if (!session.dbConnection) throw new X3Error(26, "Try to delete whithout transaction");

			const rs = table.x3Delete(_, ka.nkey, ka.wkey, where);

			if (rs < 0) {
				frame.context.sys.values.FSTAT = -rs;
				frame.context.sys.values.ADXDLREC = 0;
			} else {
				frame.context.sys.values.FSTAT = 0;
				frame.context.sys.values.ADXDLREC = rs;
			}
		};
	},
	ASSIGNUPDATE(lhs: types.Expression<any>, rhs: types.Expression<any>): ContextFn<any> {
		return function assignupdate$do(_,  ctx) {
			const frame = util.currentFrame();

			frame.tryingSql = true;
			frame.whereContext = ctx;

			const mbl = genSql(_, lhs);
			const mbr = genSql(_, rhs);

			frame.tryingSql = false;
			frame.whereContext = undefined;

			if (mbl.tooComplex || mbr.tooComplex) throw new X3Error(26, "Invalid assignment");

			return {
				sql: mbl.sql + " = " + mbr.sql,
				constants: mbr.constants
			};
		};
	},
	UPDATE(abbrev: string, where: ContextFn<WKey[]>, assign: ContextFn<WKey>[]) {
		return function update$do(_: _) {
			const frame = util.currentFrame();
			const session = util.currentSession();
			const table: DBTable = util.any(findTable(frame, abbrev));
			const ctx: types.QueryContext = {};

			// compute the clause

			ctx.tables = [table.abbrev];
			ctx.noabbrev = true;

			// compute assign clause
			var consts: string[] = [];
			const asssql = "" + assign.map_(_, (_, ass) => {
				const asg = ass(_, ctx);
				consts = consts.concat(asg.constants || []);
				return asg.sql;
			}).join(",");
			const rs = table.x3Update(_, where, asssql, consts);

			if (rs < 0) {
				frame.context.sys.values.FSTAT = -rs;
				frame.context.sys.values.ADXUPREC = 0;
			} else {
				frame.context.sys.values.FSTAT = 0;
				frame.context.sys.values.ADXUPREC = rs;
			}
		};
	},
	TRBEGIN(abbrevs?: string[]) {
		//var aabrevs = basic.instructions.A(abbrevs);
		return function trbegin$do(_: _) {
			const frame = util.currentFrame();
			const session = util.currentSession();

			if (session.dbConnection !== null && session.dbConnection !== undefined) throw new X3Error(49, "");

			session.dbConnection = frame.context.superv.sqlDriver.allocConnection(_);
			session.transactionLevel = frame.stackLevel;

			frame.context.superv.sqlDriver.beginTransaction(_, session.dbConnection);
			frame.context.sys.values.ADXLOG = 1;
		};
	},
	COMMIT() {
		return function commit$do(_: _) {
			const frame = util.currentFrame();
			const session = util.currentSession();

			if (!session.dbConnection) throw new X3Error(48, "");
			if (session.transactionLevel !== frame.stackLevel) throw new X3Error(32, "");

			frame.context.superv.sqlDriver.commitTransaction(_, session.dbConnection);
			frame.context.superv.sqlDriver.releaseConnection(session.dbConnection);
			session.dbConnection = null;
			session.transactionLevel = -1;
			frame.context.sys.values.ADXLOG = 0;
		};
	},
	ROLLBACK() {
		return function rollback$do(_: _) {
			const frame = util.currentFrame();
			const session = util.currentSession();

			if (!session.dbConnection) throw new X3Error(48, "");
			if (session.transactionLevel !== frame.stackLevel) throw new X3Error(32, "");

			frame.context.superv.sqlDriver.rollbackTransaction(_, session.dbConnection);
			frame.context.superv.sqlDriver.releaseConnection(session.dbConnection);
			session.dbConnection = null;
			session.transactionLevel = -1;
			frame.context.sys.values.ADXLOG = 0;
			//frame.context.superv.executeSql(_, "rollback");
		};
	},
	FORF(key: types.Expression<any>, hint: types.Expression<Hint>, lock: boolean, where: ContextFn<WKey[]>, 
	from: types.Expression<any>[], to: types.Expression<any>[], p: types.Expression<any>[], 
	end: number, block: types.Expression<any>) {
		const frmfv = basic.instructions.A(from);
		const tofv = basic.instructions.A(to);

		return function forf$do(_: _) {
			const frame = util.currentFrame();
			const session = util.currentSession();
			const driver = frame.context.superv.sqlDriver;
			const k = key(_);
			const frmv = frmfv(_);
			const tov = tofv(_);

			var klvl = k && k.indices && k.indices[0];
			const hnt = hint ? hint(_) : null;
			const table = findTable(frame, k.abbrev);

			try {
				var ky = table.findKey(k.name);
				var rec = {};
				var cf = table.x3GetCurrentFor();
				var kvalues: any[];

				if (cf && cf.klvl === undefined) throw new X3Error(26, "Bad nested loop");
			} catch (e) {
				flowControl.handleError(_, frame, e);
				p[end](_);
				return;
			}

			if (!cf) {
				// update current key if specified
				if (k.name) {
					if (ky.kslot) {
						// it be could be reckey
						table.currkey = ky.kslot;
						table.currlen = klvl || ky.items.length;
					}
				} else if (table.currlen < ky.items.length) klvl = table.currlen;

				var wfrm0 = frmv.length !== 0 ? instructions.SQLKEY(k.name, 'GE', basic.instructions.A([basic.instructions.C(table.currlen)]), frmv) : undefined;
				var wto0 = tov.length !== 0 ? instructions.SQLKEY(k.name, 'LE', basic.instructions.A([basic.instructions.C(table.currlen)]), tov) : undefined;
				var wfrm = wfrm0 && instructions.WHERE([wfrm0]);
				var wto = wto0 && instructions.WHERE([wto0]);

				// we can open the for
				cf = table.x3OpenFor(_, ky, klvl, hnt, lock, where, wfrm, wto);
				rec = cf.x3GetRecord(_);
				if (klvl) {
					cf.klvl = klvl;
					kvalues = table.getKeyValues(_, ky, klvl);
				}
			} else {
				if (ky.name !== cf.key.name) throw new X3Error(26, "Inconsitent nested loop key");

				cf.level++;
				if (klvl) cf.klvl = klvl;
				kvalues = table.getKeyValues(_, ky, klvl || cf.klvl);
			}

			// loop
			const level = ++frame.loopLevel;

			var exit = false;
			while (frame.loopLevel === level) {
				if (rec) {
					// execution du block
					block(_);

					if (frame.loopLevel !== level) {
						cf.x3CloseDBReader(_);
						continue;
					}

					//next (did you take your pills ?)
					if (!klvl && !cf.klvl) {
						// classic for
						rec = cf.x3GetRecord(_);
					} else if (klvl && cf.klvl) {
						// nested loop intermedirary
						if (klvl === ky.items.length && ky.items.length > 1) {
							exit = true;
						} else {
							if (cf.x3HasNoMoreRecord()) rec = undefined;
							while (rec && table.keyCompare(_, ky, kvalues) === 0) {
								rec = cf.x3GetRecord(_);
							}
							if (rec) {
								kvalues = table.getKeyValues(_, ky, klvl);
							}
						}
					} else {
						// nested loop final
						rec = cf.x3GetRecord(_, true);
						if (rec && table.keyCompare(_, ky, kvalues) < 0) {
							cf.x3DiscardCurrent();
							exit = true;
						} else cf.x3FreeLast();
					}
				} else {
					frame.loopLevel = level - 1;
				}

				// special exit loop
				if (exit) {
					frame.loopLevel = level - 1;
					break;
				}
			}
			if (frame.loopLevel === level - 1) {
				if (cf.level === 0) {
					table.x3CloseFor();
				} else cf.level--;
				p[end](_);
			}
		};
	},
	WHERE(wheres: types.Expression<WKey>[]) {
		return function (_: _,  ctx: types.QueryContext) {
			const frame = util.currentFrame();
			const sqls: string[] = [];

			var exps: any[] = [];
			var colu: QueryKey[] = [];
			const funcs: ((_: _) => any)[] = [];
			const wtab: WKey[] = [];

			var pe = false;

			wheres.forEach_(_, (_, exp) => {
				frame.tryingSql = true;
				frame.whereContext = ctx;

				const r = genSql(_, exp);

				// Strange: WKey does not have a key field
				if (util.any(r).key !== undefined) {
					// key criteria
					r.func = instructions.WHERE2([r.func]);
					r.postEvaluation = false;
					wtab.push(r);
				} else {
					// borne criteria
					sqls.push(r.sql);
					exps = exps.concat(r.constants || []);
					colu = colu.concat(r.columns || []);
					if (r.tooComplex) pe = true;
					funcs.push(r.func);
				}
				frame.tryingSql = false;
				frame.whereContext = undefined;
			});

			if (funcs.length) {
				wtab.push({
					sql: sqls.join(" AND "),
					constants: exps,
					columns: colu,
					postEvaluation: pe,
					func: instructions.WHERE2(funcs)
				});
			}
			return wtab;
		};
	},
	WHERE2(wheres: types.Expression<WKey[]>[]) {
		return function (_: _) {
			const frame = util.currentFrame();
			const res: any[] = [];

			wheres.forEach_(_, (_, exp) => {
				const r = exp(_);

				res.push(r);
			});
			return res;
		};
	},
	ORDERITEM(exp: any, dir: string): ContextFn<WKey> {
		return function (_,  ctx) {
			const frame = util.currentFrame();

			frame.tryingSql = true;
			frame.whereContext = ctx;
			const val = genSql(_, exp);
			const sql = val.sql; //+ ((dir === "-") ? " Desc" : "");

			frame.tryingSql = false;
			frame.whereContext = undefined;

			return {
				sql: sql,
				isConstant: val.isConstant,
				constants: val.constants,
				columns: val.columns,
				func: val.func,
				item: val.sql,
				dir: dir === "-" ? -1 : 1
			};
		};
	},
	ORDER(keyName: string, by: ContextFn<WKey>[], withExp: types.Expression<string>, direct: number, klen: types.Expression<number[]>): ContextFn<WKey> {
		return function (_,  ctx) {
			//debugger;
			const frame = util.currentFrame();

			var mod: KeyModified;
			var consts: any[] = [];
			const funcs: types.Expression<WKey[]>[] = [];
			const dir: number[] = [];

			var items: string[] = [];
			var colu: QueryKey[]  = [];

			// With expression
			if (withExp) {
				items = withExp(_).split(';').map_(_, (_, s) => {
					const pair = s.split(' ');

					var kf: types.Expression<WKey[]>;

					const ki = _littleFieldAnalysis(pair[0]);

					if (ki.abbrev) kf = instructions.SQLCV('F', ki.abbrev, ki.field);
					else kf = instructions.SQLV(ki.field);

					frame.tryingSql = true;
					frame.whereContext = ctx;
					const val = genSql(_, kf);
					const sql = val.sql;

					frame.tryingSql = false;

					// build field
					if (pair[1] && pair[1].toLowerCase() === 'desc') {
						//sql += " Desc";
						dir.push(-1);
					} else dir.push(1);
					funcs.push(kf);
					return sql;
				});
				sql = items.map((itm, idx) => itm + (dir[idx] < 0 ? " Desc" : "")).join(', ');
			} else {
				var sql = "" + by.map_(_, (_, kitem) => {
					const sk = kitem(_, ctx);
					consts = consts.concat(sk.constants || []);
					colu = colu.concat(sk.columns || []);
					funcs.push(sk.func);
					dir.push(sk.dir);
					items.push(sk.item);
					return sk.item + (sk.dir < 0 ? " Desc" : "");
				}).join(",");

				// it a modified key case (no sql items)
				if (!sql) {
					const kklen = klen && klen(_);
					if (direct || kklen) {
						mod = {
							direction: direct || 1,
							length: kklen ? kklen[0] : 0
						};
					} else mod = undefined;
				}
			}
			return {
				name: keyName,
				modified: mod,
				sql: sql,
				hidden: false,
				unique: false,
				constants: consts,
				func: funcs,
				directions: dir,
				items: items,
				kslot: -1,
				columns: colu
			};
		};
	},
	SQLV(field: string) {
		return function sqlv$do(_: _) {
			const frame = util.currentFrame();
			const ctx = frame.whereContext;

			if (!frame.tryingSql) return variables.instructions.V(field)(_);
			//throw new X3Error(26, "NIY");
			const tables = frame.context.tables;
			const abbrevs = ctx.tables; //Object.keys(tables);
			const dicts = frame.dicts;

			for (var j = 0, len = dicts.length; j < len; j++) {
				var dict = dicts[j];
				if (dict.values[field] !== undefined) {
					return variables.instructions.V(field)(_);
				}
			}
			for (var i = 0; i < abbrevs.length; i++) {
				var abbrev = abbrevs[i];
				var abv = ctx.noabbrev ? "" : abbrev + '.';
				var table = tables[abbrev];
				if (table.values && table.values[field] !== undefined) {
					var col = table.desc && table.desc.columns[field];
					return {
						sql: abv + field + '_0',
						type: table.types[field],
						func: instructions.SQLCV("F", abbrev, field),
						tooComplex: false,
						columns: [{
							abbrev: abbrev,
							field: col,
							index: 0
						}]
					};
				}
			}
			throw new X3Error(6, field);
		};
	},
	SQLINDEX(field: types.Expression<string>, args: types.Expression<any>[]) {
		const aargs = basic.instructions.A(args);

		return function sqlindex$do(_: _): WKey {
			const frame = util.currentFrame();
			const driver = frame.context.superv.sqlDriver;
			const ctx = frame.whereContext;

			if (!frame.tryingSql) return array.instructions.INDEX(field, args)(_);
			const f = genSql(_, field);
			const i = aargs(_);

			if (f.isConstant) {
				var tryingSql = frame.tryingSql;
				frame.tryingSql = false;
				var val = array.instructions.INDEX(field, args)(_);
				frame.tryingSql = tryingSql;
				return {
					sql: "@?",
					type: typeof val,
					constants: [val.x3ToSql(driver) || val],
					isConstant: true,
					func: basic.instructions.C(val)
				};
			}

			return {
				columns: [{
					abbrev: f.columns[0].abbrev,
					field: f.columns[0].field,
					index: i[0]
				}],
				sql: f.sql.replace("_0", "_" + i[0]),
				type: f.type,
				func: instructions.SQLINDEX(field, args),
				tooComplex: false
			};
		};
	},
	SQLCV(letter: string, abbrev: string, field: string): types.Expression<WKey[]> {
		return function sqlcv$do(_: _) {
			const frame = util.currentFrame();
			const ctx = frame.whereContext;
			//console.log("Letter : " + letter + " abbrev:" + abbrev + " field:" + field);

			if (!frame.tryingSql || letter === 'L' || letter === 'V' || letter === 'S') return variables.instructions.CV(letter, abbrev, field)(_);
			if (abbrev) {
				if (ctx.tables.indexOf(abbrev) >= 0) {
					var abv = ctx.noabbrev ? "" : abbrev + '.';
					var table = frame.context.tables[abbrev];
					var col = table && table.desc && table.desc.columns[field];
					return {
						columns: [{
							abbrev: abbrev,
							field: col,
							index: 0
						}],
						sql: abv + field + '_0',
						type: col && col.type,
						func: instructions.SQLCV(letter, abbrev, field),
						tooComplex: false
					};
				} else return variables.instructions.CV(letter, abbrev, field)(_);
			} else {
				for (var i = 0; i < ctx.tables.length; i++) {
					var table = frame.context.tables[ctx.tables[i]];
					var abv = ctx.noabbrev ? "" : abbrev + '.';

					if (table.desc.columns[field]) {
						var col = table.desc.columns[field];
						return {
							columns: [{
								abbrev: abbrev,
								field: col,
								index: 0
							}],
							sql: abv + '.' + field + '_0',
							type: col && col.type,
							func: instructions.SQLCV(letter, abbrev, field),
							tooComplex: false
						};
					}
				}
				return variables.instructions.CV(letter, abbrev, field)(_);
			}
		};
	},
	SQLF(field: string, args: types.Expression<any>[]) {
		const sqlFunc = sqlFunctions[field];
		//if (!sqlFunc) return flowControl.instructions.F(field, args);

		return function sqlf$do(_: _): WKey {
			const frame = util.currentFrame();
			const ctx = frame.whereContext;

			if (!frame.tryingSql) return flowControl.instructions.F(field, args)(_);
			if (sqlFindPat[field]) return sqlFindPat[field](_, args, ctx);

			var cst = true;
			const params: types.Expression<any>[] = [];

			var consts: any[] = [];
			var columns: QueryKey[] = [];

			const argSqls = args.map_(_, (_, arg) => {
				const s = genSql(_, arg);

				if (!s.isConstant) cst = false;
				params.push(s.func);
				consts = consts.concat(s.constants || []);
				columns = columns.concat(s.columns || []);
				return s;
			});

			var r: WKey;
			if (cst) {
				frame.tryingSql = false;
				var rs = flowControl.instructions.F(field, args)(_);
				frame.tryingSql = true;
				return rs;
			} else if (sqlFunc) {
				r = sqlFunc.apply(this, argSqls);
				r.func = instructions.SQLF(field, params);
				if (!r.constants) r.constants = consts;
				if (!r.columns) r.columns = columns;
				return r;
			} else {
				r = tooComplex();
				r.func = instructions.SQLF(field, params);
				r.constants = consts;
				r.columns = columns;
				return r;
			}
		};
	},

	SQLEVALUE(req: (name: string) => any, ns: any, arg: types.Expression<any>) {
		return function sqlevalue$do(_: _) {
			const frame = util.currentFrame();
			const ctx = frame.whereContext;
			const ev = dbevaluate.instructions.EVALUE(req, ns, arg)(_);

			return ev;
		};
	},
	SQLKEY(kyname: string, op: string, np: types.Expression<any>, args: types.Expression<any>[]): types.Expression<WKey> {
		//
		return function sqlsql$do(_) {
			// find key
			const frame = util.currentFrame();
			const ctx = frame.whereContext;
			const abbrev = ctx.tables[0];
			const table = frame.context.tables[abbrev];
			const key = table.findKey(kyname);
			const kln = key.items.length;

			// find right length

			var npk = np && np(_);
			npk = npk ? npk[0] : kln;
			npk = npk > args.length ? args.length : npk;

			// get arguments key
			var consts: any[] = [];
			var afunc: types.Expression<any>;

			if (op === 'EQ' || op === "NE" || npk === 1) {
				// simple case
				var sql = "(";
				for (var i = 0; i < npk; i++) {
					if (i) sql += " AND ";
					var s = genSql(_, args[i]);
					sql += "(" + key.items[i] + " " + sqlCmpOps[op].op + " " + s.sql + ")";
					consts = consts.concat(s.constants || []);
					var fequal = util.any(instructions)['SQL' + op](key.func[i], s.func);
					if (afunc) afunc = instructions.SQLAND(afunc, fequal);
					else afunc = fequal;
				}
				sql += ")";
				return {
					key: key.kslot,
					operation: op,
					splitable: false,
					sql: sql,
					type: 'boolean',
					func: afunc,
					constants: consts,
					//columns: key.columns,
					tooComplex: false
				};
			} else {
				// should be replace by a multi-query
				var kp = npk;
				var ofunc: types.Expression<any>;
				switch (op) {
					case 'GT':
					case 'GE':
						var op2 = 'GT';
						break;
					case 'LT':
					case 'LE':
						var op2 = 'LT';
						break;
					default:
						throw new X3Error(26, "Illegal operator " + op);
				}

				var sql = "(";
				for (var i = 0; i < npk; i++) {
					afunc = null;
					if (i) sql += " OR ";
					sql += "(";
					for (var j = 0; j < kp; j++) {
						var f: types.Expression<boolean>;
						var s = genSql(_, args[j]);
						if (j) sql += " AND ";
						if (j < kp - 1) {
							sql += "(" + key.items[j] + " = " + s.sql + ")";
							f = instructions.SQLEQ(key.func[j], s.func);
						} else {
							var ope = i === 0 ? op : op2;
							sql += "(" + key.items[j] + " " + sqlCmpOps[ope].op + " " + s.sql + ")";
							f = util.any(instructions)['SQL' + op](key.func[j], s.func);
						}
						consts = consts.concat(s.constants || []);

						if (afunc) afunc = instructions.SQLAND(afunc, f);
						else afunc = f;
					}
					sql += ")";
					kp -= 1;
					if (ofunc) ofunc = instructions.SQLOR(ofunc, afunc);
					else ofunc = afunc;
				}
				sql += ")";
				return {
					key: key.kslot,
					operation: op,
					splitable: true,
					sql: sql,
					constants: consts,
					tooComplex: false,
					type: 'boolean',
					func: ofunc,
					//columns: key.columns
				};
			}
		};
	},

	SQLAND: binaryOp('AND', 'AND', 'boolean'),
	SQLOR: binaryOp('OR', 'OR', 'boolean'),
	SQLEQ: binaryOp('EQ', '=', 'boolean'),
	SQLNE: binaryOp('NE', '<>', 'boolean'),
	SQLLT: binaryOp('LT', '<', 'boolean'),
	SQLLE: binaryOp('LE', '<=', 'boolean'),
	SQLGT: binaryOp('GT', '>', 'boolean'),
	SQLGE: binaryOp('GE', '>=', 'boolean'),
	SQLADD: binaryOp('ADD', 'CONCAT', 'string', '+', 'number'),
	SQLSUB: binaryOp('SUB', 'CONCAT', 'string', '-', 'number'),
	SQLMUL: binaryOp('MUL', '*', 'number'),
	SQLDIV: binaryOp('DIV', '/', 'number')
};