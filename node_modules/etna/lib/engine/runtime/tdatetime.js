"use strict";
var X3Error = require('./errors').X3Error;
var util = require('./util');
var base = require('syracuse-core').types.datetime;
var tdate = require('./tdate');

var _prototype = Object.getPrototypeOf(base.now());

var baseToString = _prototype.toString;

// override toString to handle NULL value
_prototype.toString = function(format) {
	if (this._value == null) return "0000-00-00T00:00:00Z";
	return baseToString.call(this, format);
};

_prototype.x3ToString = function() {
	return this.x3IsZero() ?
		"0000-00-00T00:00:00Z" :
		this.toString("yyyy-MM-ddTHH:mm:ssZ");
};

_prototype.x3NumDollar = function() {
	return this.x3IsZero() ?
		"0000-00-00T00:00:00Z" :
		this.x3ToString();
};

_prototype.x3ToInteger = function() {
	throw util.badOperand();
};

_prototype.x3ToDouble = function() {
	throw util.badOperand();
};

_prototype.x3ToDate = function() {
	throw util.badOperand();
};

_prototype._x3ToDate = function() {
	return this.x3IsZero() ?
		tdate.make(0, 0, 0) :
		tdate.make(this.utcYear, this.utcMonth, this.utcDay);
};

_prototype.x3ToBCD = function() {
	throw util.badOperand();
};

_prototype.x3ToDatetime = function() {
	return this;
};

_prototype.x3AddMonths = function(months) {
	if (months.x3IsNumeric()) {
		//not ok for 31/01 +2
		//return this.addMonths(months.valueOf());
		var strTime = this.x3ToString().substring(10);
		var strDate = this._x3ToDate().x3AddMonths(months).x3ToJson();
		return exports.x3Parse(strDate + strTime);
	}
};

_prototype.x3EndOfMonth = function() {
	var strTime = this.x3ToString().substring(10);
	var strDate = this._x3ToDate().endOfMonth().x3ToJson();
	return exports.x3Parse(strDate + strTime);
};

_prototype.x3Serialize = function() {
	var dd = tdate.make(this.year, this.month, this.day);
	var dif = dd.x3Sub(tdate.MIN) + 1;
	var n = (((dif * 24 + this.hour)) * 60 + this.minute) * 60 + this.second;

	return n.x3Serialize(8);
};

_prototype.x3IsNumeric = function() {
	return false;
};

_prototype.x3IsZero = function() {
	// TODO: why the (costly) extra checks on year, month and day?
	return this._value == null || this._value === 0 || !this.year || !this.month || !this.day;
};

_prototype.x3IsUndefined = _prototype.x3IsZero;

_prototype.x3IsEmpty = function() {
	throw util.badOperand(this);
};

_prototype.x3Compare = function(v) {
	if (!util.x3IsDatetime(v)) throw util.badOperand();
	return this.compare(v) || 0;

};

_prototype.x3Add = function(v) {
	throw util.badOperand(v);
};

_prototype.x3Sub = function(v) {
	throw util.badOperand(v);
};

_prototype.x3Mul = function(v) {
	throw util.badOperand(v);
};

_prototype.x3Div = function(v) {
	throw util.badOperand(v);
};

_prototype.x3Mod = function(v) {
	throw util.badOperand(v);
};

_prototype.x3Pow = function(v) {
	throw util.badOperand(v);
};

_prototype.x3Xor = function(v) {
	throw util.badOperand(v);
};

_prototype.x3Abs = function(v) {
	throw util.badOperand(v);
};

_prototype.x3Truncate = function(v) {
	return this.value;
};

_prototype.x3ToSql = function(driver) {
	return (this.x3IsZero()) ? driver.nullDate() : this.toJsDate();
};


_prototype.x3Clone = function() {
	return base.fromMillis(this._value);
};

_prototype.x3Type = function() {
	return 526;
};

exports.x3Parse = function(str) {
	if (/^\d{4}-(?:1[0-2]|0\d{1})-\d{2}T\d{2}\:\d{2}\:\d{2}\.\d{3}Z$/.test(str.toString())) {
		if (str === "0000-00-00T00:00:00.000Z")
			return base.NULL;
		return base.parse(str.toString());
	} else if (/^\d{4}-(?:1[0-2]|0\d{1})-\d{2}T\d{2}\:\d{2}\:\d{2}Z$/.test(str.toString())) {
		str = str.replace("Z", ".000Z");
		if (str === "0000-00-00T00:00:00.000Z")
			return base.NULL;
		return base.parse(str.toString());
	} else if (/^\d{4}-\d{2}-\d{2}Z$/.test(str.toString())) {
		str = str.replace("Z", "T00:00:00.000Z");
		if (str === "0000-00-00T00:00:00.000Z")
			return base.NULL;
		return base.parse(str.toString());
	} else if (/^\d{4}-\d{2}-\d{2}$/.test(str.toString())) { //'2015-05-31'
		str = str + "T00:00:00.000Z";
		if (str === "0000-00-00T00:00:00.000Z")
			return base.NULL;
		return base.parse(str.toString());
	}
	/* else if (/^\d{2}:\d{2}:\d{2}Z$/.test(str.toString())) {
		return base.parse(str.toString(), "HH:mm:ssZ");
	}*/
	return base.NULL;
};

exports.now = function() {
	return base.now(true);
};

exports.toJsDate = base.toJsDate;
exports.fromJsDate = base.fromJsDate;
exports.fromMillis = base.fromMillis;
exports.make = base.make;
exports.makeUtc = base.makeUtc;
exports.NULL = base.NULL = base.fromMillis(null);