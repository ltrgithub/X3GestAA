"use strict";

const util = require('./util');
const errors = require('./errors');
const X3Error = errors.X3Error;
const glob = require('streamline/lib/globals');
const tdouble = require('./tdouble');
const tinteger = require('./tinteger');
const bcd = require('./tbcd');

function fac(n) {
	return n > 1 ? n * fac(n - 1) : 1;
}

function anp(n, p) {
	return fac(n) / fac(n - p);
}

function toRadians(angle) {
	const frame = glob.context.x3frame;

	switch (frame.context.sys.values.ADXMDA) {
		case 0:
			return angle * (Math.PI / 180); //Degrees => Radians
		case 2:
			return angle * (Math.PI / 200); //Grades => Radians
	}
	return angle;
}

exports.functions = {
	ABS: {
		count: 1,
		fn(x) {
			if (x.x3Abs) return x.x3Abs();
			throw util.badOperand(x);
		}
	},
	MOD: {
		count: 2,
		fn: function mod(x, y) {
			if (!x.x3IsNumeric()) throw util.badOperand(x);
			if (!y.x3IsNumeric()) throw util.badOperand(y);
			return x.x3Mod(y);
		}
	},
	RND: {
		count: 1,
		fn(x) {
			if (!x.x3IsNumeric()) throw util.badOperand(x);

			return new tdouble.Double(x.x3ToDouble().valueOf() * Math.random());
		}
	},
	SGN: {
		count: 1,
		fn(x) {
			if (!x.x3IsNumeric()) throw util.badOperand(x);
			return x.x3Compare(0);
		}
	},
	SQR: {
		count: 1,
		fn(x) {
			if (!x.x3IsNumeric()) throw util.badOperand(x);
			const d = x.x3ToDouble().valueOf();

			if (d < 0) throw new X3Error(11, "Negative root for a number");
			return new tdouble.Double(Math.sqrt(d));
		}
	},
	AR2: {
		count: 1,
		fn(x) {
			if (!x.x3IsNumeric()) throw util.badOperand(x);
			if (util.x3IsInteger(x)) return x;

			const b = x.x3Abs().x3Mul(bcd.fromInt32(100)).x3Add(bcd.fromDouble(0.5));
			const sign = x.x3ToDouble().valueOf() < 0 ? -1 : 1;

			return b.x3Truncate().x3Div(bcd.fromInt32(100)).x3Mul(sign);
		}
	},
	ARR: {
		count: 2,
		fn(x, y) {
			if (!x.x3IsNumeric()) throw util.badOperand(x);
			if (!y.x3IsNumeric()) throw util.badOperand(y);
			if (y.x3IsZero()) return x;

			const val = x.x3Div(y);
			const sign = val.x3ToDouble().valueOf() < 0 ? -1 : 1;


			return y.x3Mul(val.x3Abs().x3Add(bcd.fromDouble(0.5)).x3Truncate().x3Mul(sign));
		}
	},
	FIX: {
		count: 1,
		fn(x) {
			if (!x.x3IsNumeric()) throw util.badOperand(x);
			if (util.x3IsInteger(x)) return x;

			return x.x3Truncate().x3ToDouble().valueOf();
		}
	},
	INT: {
		count: 1,
		fn(x) {
			if (!x.x3IsNumeric()) throw util.badOperand(x);

			const v = new tdouble.Double(Math.floor(x.x3ToDouble().valueOf()));
			const vi = v.valueOf();

			if (vi > tinteger.MAX_INT || vi <= -tinteger.MAX_INT) return v;

			else return vi;
		}
	},
	ANP: {
		count: 2,
		fn(n, p) {
			if (!n.x3IsNumeric()) throw util.badOperand(n);
			if (!p.x3IsNumeric()) throw util.badOperand(p);

			n = n.x3ToInteger();
			p = p.x3ToInteger();

			const result = anp(n, p);
			const bcdResult = bcd.fromInt32(result);

			return bcdResult.isInt32() ? result : bcdResult;
		}
	},
	CNP: {
		count: 2,
		fn(n, p) {
			if (!n.x3IsNumeric()) throw util.badOperand(n);
			if (!p.x3IsNumeric()) throw util.badOperand(p);

			n = n.x3ToInteger();
			p = p.x3ToInteger();

			const result = anp(n, p) / anp(p);
			const bcdResult = bcd.fromInt32(result);

			return bcdResult.isInt32() ? result : bcdResult;
		}
	},
	FAC: {
		count: 1,
		fn(x) {
			if (!x.x3IsNumeric()) throw util.badOperand(x);
			return new tdouble.Double(fac(x.x3ToDouble().valueOf()));
		}
	},
	COS: {
		count: 1,
		fn(angle) {
			if (!angle.x3IsNumeric()) throw util.badOperand(angle);
			return new tdouble.Double(Math.cos(toRadians(angle.x3ToDouble().valueOf())));
		}
	},
	SIN: {
		count: 1,
		fn(angle) {
			if (!angle.x3IsNumeric()) throw util.badOperand(angle);
			return new tdouble.Double(Math.sin(toRadians(angle.x3ToDouble().valueOf())));
		}
	},
	TAN: {
		count: 1,
		fn(angle) {
			if (!angle.x3IsNumeric()) throw util.badOperand(angle);
			return new tdouble.Double(Math.tan(toRadians(angle.x3ToDouble().valueOf())));
		}
	},
	ACOS: {
		count: 1,
		fn(x) {
			if (!x.x3IsNumeric()) throw util.badOperand(x);
			return new tdouble.Double(Math.acos(x.x3ToDouble().valueOf()));
		}
	},
	ASIN: {
		count: 1,
		fn(x) {
			if (!x.x3IsNumeric()) throw util.badOperand(x);
			return new tdouble.Double(Math.asin(x.x3ToDouble().valueOf()));
		}
	},
	ATAN: {
		count: 1,
		fn(x) {
			if (!x.x3IsNumeric()) throw util.badOperand(x);
			return new tdouble.Double(Math.atan(x.x3ToDouble().valueOf()));
		}
	},
	ACH: {
		count: 1,
		fn(x) {
			if (!x.x3IsNumeric()) throw util.badOperand(x);
			return new tdouble.Double(Math.log(x.x3ToDouble().valueOf() + Math.sqrt(x.x3ToDouble().valueOf() * x.x3ToDouble().valueOf() - 1)));
		}
	},
	ASH: {
		count: 1,
		fn(x) {
			if (!x.x3IsNumeric()) throw util.badOperand(x);
			return new tdouble.Double(Math.log(x.x3ToDouble().valueOf() + Math.sqrt(x.x3ToDouble().valueOf() * x.x3ToDouble().valueOf() + 1)));
		}
	},
	ATH: {
		count: 1,
		fn(x) {
			if (!x.x3IsNumeric()) throw util.badOperand(x);
			return new tdouble.Double(Math.log((1 + x.x3ToDouble().valueOf()) / (1 - x.x3ToDouble().valueOf())) / 2);
		}
	},
	CH: {
		count: 1,
		fn(x) {
			if (!x.x3IsNumeric()) throw util.badOperand(x);
			return new tdouble.Double((Math.exp(x.x3ToDouble().valueOf()) + Math.exp(-x.x3ToDouble().valueOf())) / 2);
		}
	},
	SH: {
		count: 1,
		fn(x) {
			if (!x.x3IsNumeric()) throw util.badOperand(x);
			return new tdouble.Double((Math.exp(x.x3ToDouble().valueOf()) - Math.exp(-x.x3ToDouble().valueOf())) / 2);
		}
	},
	TH: {
		count: 1,
		fn(x) {
			if (!x.x3IsNumeric()) throw util.badOperand(x);
			return new tdouble.Double((Math.exp(2 * x.x3ToDouble().valueOf()) - 1) / (Math.exp(2 * x.x3ToDouble().valueOf()) + 1));
		}
	},
	EXP: {
		count: 1,
		fn(x) {
			if (!x.x3IsNumeric()) throw util.badOperand(x);
			return new tdouble.Double(Math.exp(x.x3ToDouble().valueOf()));
		}
	},
	LN: {
		count: 1,
		fn(x) {
			if (!x.x3IsNumeric()) throw util.badOperand(x);
			return new tdouble.Double(Math.log(x.x3ToDouble().valueOf()));
		}
	},
	LOG: {
		count: 1,
		fn(x) {
			if (!x.x3IsNumeric()) throw util.badOperand(x);
			const d = x.x3ToDouble().valueOf();

			if (d <= 0) {
				if (d === 0) throw new X3Error(52, "ERROR log(0)");
				throw new X3Error(14, "Logarithm for a negative number");
			}
			return new tdouble.Double(parseFloat((Math.log(d) / Math.LN10).toFixed(10)));
		}
	},
	PI: {
		count: 0,
		fn() {
			return new tdouble.Double(Math.PI);
		}
	},
	SETBIT: {
		count: 3,
		fn(val, pos, bit) {
			return bit == 1 ? val | 1 << pos - 1 : val & ~(1 << pos - 1);
		}
	},
	GETBIT: {
		count: 2,
		fn(val, pos) {
			return val & 1 << pos - 1 ? 1 : 0;
		}
	}
};