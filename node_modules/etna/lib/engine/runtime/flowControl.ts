import { _ } from 'streamline-runtime';
import * as types from './types';
import * as util from './util';
import * as basic from './basic';
import * as variables from './variables';
import { WKey } from './dbtableparent';
//var tdouble  = require('./tdouble') ;

import * as errors from './errors';
const glob = require('streamline-runtime').globals;
import { config, trace } from '../../util/nodeconfig';
import * as db from './db';

/* 
 * Error handling
 */

export function handleError(_: _,  frame: types.Frame, e: any) {
	//!console.log("_handleError:"+e);
	// unwind stack
	util.any(_.context).frame = frame;
	if (e.fill) {
		e = new errors.X3Error(e);
		e.fill(frame);
	}

	//console.error(e.stack);
	const cx = frame.context;
	//console.error("HANDLE ERROR: " + typeof frame.errgo);

	if (!frame) throw new errors.X3Error(26, "empty stack: " + e.stack);

	if (!frame.errgo) {
		//console.error("HANDLE ERROR RETHROWS");
		throw e;
	}

	if (cx.err) {
		// error while processing error!
		//console.error("Error during error handling: " + e);
		console.error("Error during error handling: " + e.stack);
		process.exit(2);
		//cx.err = null;
		//throw new errors.X3Error(26, "error while processing error: " + e.stack);
	}
	if (!(e && e instanceof errors.X3Error)) console.error(`EXCEPTION: ${e && e.stack}`);
	//!console.error("HANDLE ERROR CALLS ERRGO " + e)
	cx.err = e;
	frame.errgo(_);
	cx.err = null; // if we reach end
}

function _locPrefix(loc: types.Location) {
	return errors.moduleName(loc) + ":" + loc.line + ": ";
}

var indentLevel = 0;

function indent(delta: number) {
	if (delta < 0) indentLevel += delta;
	const str = Array(indentLevel + 1).join('    ');

	if (delta > 0) indentLevel += delta;
	return str;
}

export function callProg(_: _,  prog: types.Prog, args: types.Expression<any>[], argVals: any[], loc: types.Location) {
	//console.log(prog.name + ": args=" + JSON.stringify(argVals));
	var frame = glob.context.x3frame;

	const prev = frame;
	const cx = prev.context;

	glob.context.x3frame = frame = {
		values: {},
		types: {},
		context: cx,
		prev: prev,
		stackLevel: (prev && prev.stackLevel || 0) + 1,
		loopLevel: 0,
		loc: prog.loc || {
			file: module.id,
			line: 0
		},
		prog: prog
	};
	cx.traceCall && cx.traceCall(_, "enter", argVals);
	exports.monitorCall && exports.monitorCall(frame, "enter");
	// current sub is the prog itself
	frame.sub = frame;
	frame.dicts = [frame, cx.globals, cx.sys];
	const params = prog.params;

	var i: number, j: number;
	for (i = 0; i < params.length; i++) {
		var argVal = argVals[i];
		if (Array.isArray(argVal)) {

			// arrays passed by reference :
			// Save dimensions and default value . The actual "array" is saved in variables
			var newtab: any[] = [];
			for (var j = 0; j < argVal.length; j++) {
				newtab[j] = argVal[j];
			}
			//save copy in argVals[i]
			argVals[i] = newtab;
		}
		// By default the parameter is a constant of type ANY
		frame.types[params[i]] = "CX";
		frame.values[params[i]] = argVals[i];
	}
	try {
		prog.body(_);
	} finally {

		db.closeFiles([], frame.stackLevel);

		exports.monitorCall && exports.monitorCall(frame, "exit");
		cx.traceCall && cx.traceCall(_, "exit", frame.result);

		// pop frame
		glob.context.x3frame = prev;
	}

	for (i = 0; i < params.length; i++) {
		var param = params[i];
		var arg = args[i];
		var key = frame.types[param];
		// assign variable parameters back (in prev frame scope)

		if (key && key[0] === 'A' && arg) {
			var val = frame.values[param];
			if (Array.isArray(val)) {
				// Get the callee's array
				var arrArg = arg(_, variables.vOperations.GET);
				// Update the content of the callee's array
				if (Array.isArray(arrArg)) arrArg[2] = val[2];
			} else {
				arg(_, variables.vOperations.SET, frame.values[param]);
			}
		}
	}
	return frame.result;
}

export function labelProg(ns: string, name: string) {
	return instructions.PROG({}, "stub", [], instructions.GOSUB(basic.instructions.C(ns), name));
};

function callJS(_: _,  prog: (_: _) => any, argVals: any[], frame: types.Frame) {
	if (typeof prog !== "function") throw new errors.X3Error(113, "not a function: " + prog);
	try {
		return prog.apply_(_, null, argVals, 0);
	} catch (ex) {
		handleError(_, frame, ex);
	}
}

function getSetter(field: string, val?: any) {
	const frame = glob.context.x3frame;
	const dicts = frame.dicts;

	for (var i = 0, len = dicts.length; i < len; i++) {
		if (dicts[i].values && dicts[i].values[field] !== undefined) {
			let k = dicts[i].types[field];
			let setter = variables.types[k[1]].set;
			return (val: any) => {
				dicts[i].values[field] = setter(field, k, val);
			};
		}
	}
	// Declare a local variable ;
	var key = "LI";
	var def = 0;
	if (val !== undefined) {
		def = val;
		if (typeof val !== "number") {
			if (typeof val === "string") key = "LS";
			else if (util.x3IsDate(val)) key = "LD";
		}
	}

	frame.values[field] = def;
	frame.types[field] = key;

	let setter = variables.types[key[1]].set;
	return (val: any) => {
		frame.values[field] = setter(field, key, val);
	};
};

var gotMain: boolean;

export const functions = {
	ERRL: {
		count: 0,
		fn() {
			const cx = this.context;

			return cx.err && cx.err.frames && cx.err.frames[0] ? cx.err.frames[0].line : 0;
		}
	},
	ERRN: {
		count: 0,
		fn() {
			const cx = this.context;

			return cx.err ? cx.err.errn || 26 : 0;
		}
	},
	ERRP: {
		count: 0,
		fn() {
			const cx = this.context;

			return cx.err && cx.err.frames && cx.err.frames[0] ? cx.err.frames[0].file : "";
		}
	},
	ERRM: {
		count: 0,
		fn() {
			const cx = this.context;

			return "" + cx.err;
		}
	},
	ERRMES$: {
		count: 1,
		fn: errors.errmes$
	},

	MESS: {
		async: true,
		count: 3,
		fn(_: _,  id: number, chapter: number, swtch?: number) {
			const frame = glob.context.x3frame;

			if (!util.x3IsInteger(chapter)) throw util.badOperand(chapter);
			if (!util.x3IsInteger(id)) throw util.badOperand(id);
			if (!util.x3IsInteger(swtch)) throw util.badOperand(swtch);

			if (id < 0 || chapter < 0 || swtch < 0) throw new errors.X3Error(50, "");
			if (swtch === 0 && chapter > 149) return "";

			// hack in order to test other languages, has to be deleted later !!
			// --------------------------------------------------------------------------
			if (frame.context.sys.values["MESSNAME"] !== glob.context.x3session.actx.$LAN(_)) return frame.context.superv.loadMess(_, swtch !== 0 ? chapter : chapter + 9001, id, frame.context.sys.values["MESSNAME"]);
			else return frame.context.superv.loadMess(_, swtch !== 0 ? chapter : chapter + 9001, id);
		}
	}
};

export const instructions = {
	REQ(req: (_: _, name: string) => any, v: types.Expression<string>) {
		return function req$do(_: _) {
			const r = v(_);

			try {
				return req(_, r);
			} catch (ex) {
				//throw ex.errn ? ex : new errors.X3Error(20, ex.message, ex.stack);
				throw new errors.X3Error(20, ex.message, ex.stack);
			}
		};
	},
	// utility to delay resolution of p[i] branch
	GO(p: types.Expression<any>[], i: number) {
		return function go$do(_: _) {
			return p[i](_);
		};
	},

	// block
	B(...fns: types.Expression<any>[]) {
		if (fns.length == 1) return fns[0];
		fns = fns.filter(fn => {
			// eliminate NL(n) instructions
			return fn != null;
		});
		return function b$do(_: _) {
			const frame = glob.context.x3frame;
			const sub = frame.sub;
			const level = frame.loopLevel;

			for (var i = 0; i < fns.length && !sub.done && !frame.done && frame.loopLevel >= level; i++) {
				try {
					fns[i](_);
				} catch (e) {
					handleError(_, frame, e);
				}
			}
		};
	},
	GOSUB(ns: types.Expression<any>, label: string) {
		return function gosub$do(_: _) {
			const frame = glob.context.x3frame;
			const nsVal = ns(_);

			if (!nsVal || !nsVal[label]) throw new errors.X3Error(20, "invalid gosub target: " + label);
			const prevSub = frame.sub;

			try {
				frame.sub = {
					prevSub: prevSub,
					name: label,
					loc: prevSub.loc
				};
				//console.error("GOSUB: " + label)
				nsVal[label](_);
				return frame.sub.ret;
			} finally {
				frame.sub = prevSub;
			}
		};
	},
	GOTO(ns: types.Expression<any>, label: string) {
		return function gosub$do(_: _) {
			const frame = glob.context.x3frame;
			// warning: ok for debug but eats memory!!!

			frame.sub.name = frame.sub.name + '/' + label;
			const nsVal = ns(_);

			if (!nsVal || !nsVal[label]) throw new errors.X3Error(20, "invalid gosub target: " + label);
			nsVal[label](_);
			return frame.sub.ret;
		};
	},
	RET(arg: types.Expression<any>) {
		return function ret$do(_: _) {
			const frame = glob.context.x3frame;

			frame.sub.result = arg && arg(_);
			frame.sub.done = true;
		};
	},
	ONERRGO(ns: types.Expression<any>, label: string) {
		const target = label && instructions.GOSUB(ns, label);

		return function onerrgo$do(_: _) {
			const frame = glob.context.x3frame;

			frame.errgo = target;
		};
	},
	RESUME() {
		return function resume$do(_: _) {
			//console.error("BEGIN RESUME ",cx.err);
			const frame = glob.context.x3frame;
			const cx = frame.context;

			if (!cx.err) {
				//console.error("FATAL"); process.exit();
				throw new errors.X3Error(32, "invalid attempt to resume without error");
			}
			frame.sub.done = true;
			//console.error("END RESUME")
		};
	},
	PROG(e: { [name: string]: types.Prog }, name: string, params: string[], body: types.Expression<any>) {
		return e[name] = {
			name: name,
			params: params,
			body: body,
			module: e,
			loc: basic.sourceLoc
		};
	},
	CALL(ns: types.Expression<any>, name: types.Expression<string> | string, args: types.Expression<any>[]) {
		const aargs = basic.instructions.A(args);

		return function call$do(_: _) {
			const frame = glob.context.x3frame;
			const nsVal = ns.value !== undefined ? ns.value : ns(_);
			// TODO: pass literals as direct strings 'xxx' rather than C('xxx')

			const nameVal = typeof name === 'string' ? name : name.value !== undefined ? name.value.toString() : name(_);

			if (!nsVal) throw new errors.X3Error(20, "bad script name: " + nsVal);
			const prog = nsVal[nameVal];

			if (!prog) throw new errors.X3Error(39, "bad prog name: " + nameVal);
			// eval params before pushing stack

			const argVals = aargs(_);

			if (nsVal.$exported) return callJS(_, prog, argVals, frame);
			if (!prog.params) throw new errors.X3Error(113, "call target is not a prog: " + nameVal);
			// don't bark on extra parameters -- AXUNIT has some -- will just be ignored
			if (prog.params.length > args.length) throw new errors.X3Error(69, "parameter count mismatch: expected " + prog.params.length + ", got " + args.length);
			return callProg(_, prog, args, argVals, frame.sub.loc);
		};
	},
	END(arg: types.Expression<any>) {
		return function end$do(_: _) {
			const frame = glob.context.x3frame;

			if (!frame) throw new errors.X3Error(32, "unexpected return or end");
			frame.result = arg && arg(_);
			frame.sub.done = true;
			frame.done = true;
		};
	},
	F(name: string, args: types.Expression<any>[]): types.Expression<WKey> {
		const fn = require('./index').functions[name];

		if (fn == null) throw new errors.X3Error(4, "bad function name: " + name);
		const argc = args ? args.length : 0;

		if (fn.count >= 0 && fn.count != argc) throw new errors.X3Error(69, _locPrefix(basic.sourceLoc) + "bad arg count: function'" + name + "' expected " + fn.count + ", got " + argc);
		const aargs = args ? basic.instructions.A(args) : basic.instructions.C(undefined);

		if (fn.fn == null) {
			console.error("NIY function : " + name);
			return basic.instructions.NIY({
				tag: name
			});
		}

		const fdo = function f$do(_: _) {
			const frame = glob.context.x3frame;
			const fcall = frame.fcall;

			frame.fcall = name;
			const vals = aargs(_);
			const traceFunc = frame.context.traceFunc;

			try {
				traceFunc && traceFunc(_, "enter", vals);
				var result: any;
				if (fn.async) result = fn.fn.apply_(_, null, vals, 0);
				else result = fn.fn.apply(frame, vals);
				traceFunc && traceFunc(_, "exit", result);
				return result;
			} finally {
				frame.fcall = fcall;
			}
		};

		util.any(fdo).instName = name;
		return fdo;
	},
	IF(cond: types.Expression<boolean>, p: types.Expression<any>[], branch: number, block: types.Expression<any>) {
		return function if$do(_: _) {
			const val = cond(_);

			return (val ? block : p[branch])(_);
		};
	},
	CASE(exp: types.Expression<any>, p: types.Expression<any>[], branch: number) {
		return function case$do(_: _) {
			const val = exp(_);

			p[branch](_, val);
		};
	},
	WHEN(exps: types.Expression<any>[], p: types.Expression<any>[], branch: number, block: types.Expression<any>) {
		return function when$do(_: _,  val: any) {
			if (exps.length === 0) // When Default
				return block(_);
			for (var i = 0; i < exps.length; i++) {
				var exp = exps[i];
				if ((exp.value !== undefined ? exp.value : exp(_)).x3Compare(val) == 0) return block(_);
			}
			p[branch](_, val);
		};
	},
	WHILE(cond: types.Expression<boolean>, p: types.Expression<any>[], end: number, block: types.Expression<any>, isRepeat: boolean) {
		return function while$do(_: _) {
			const frame = glob.context.x3frame;
			const level = ++frame.loopLevel;

			var beenHere = false;
			while (frame.loopLevel === level) {
				var condVal = isRepeat && !beenHere ? false : cond(_);
				beenHere = true;
				if (isRepeat) condVal = !condVal;
				if (condVal) block(_);
				else frame.loopLevel = level - 1;
			}
			if (frame.loopLevel === level - 1) p[end](_);
		};
	},
	FORV(varName: string, from: types.Expression<number>, to: types.Expression<number>, step: types.Expression<number>, 
	p: types.Expression<any>[], end: number, block: types.Expression<any>) {
		return function forv$do(_: _) {
			const frame = glob.context.x3frame;

			function toNumber(v: any) {
				if (typeof v === "number") return v;
				if (util.x3IsDouble(v)) return v.valueOf();
				if (util.x3IsBCD(v)) return v.x3ToDouble().valueOf();
				return v;
			}
			const fromI = toNumber(from(_));
			const toI = toNumber(to(_));
			const stepI = toNumber(step ? step(_) : 1);

			if (stepI === 0) {
				//If the error is 'handled' the next statement after a FORV is
				// p[end] :
				handleError(_, frame, new errors.X3Error(41, "invalid step value: " + stepI));
				p[end](_);
				return;
			}

			const condition = stepI >= 0 ? () => {
				return idx <= toI && frame.loopLevel === level;
			} : () => {
				return idx >= toI && frame.loopLevel === level;
			};

			const setValue = getSetter(varName);
			const setIndex = (val: any) => {
				setValue(val);
			};

			const level = ++frame.loopLevel;

			for (var idx = fromI; condition(); idx += stepI) {
				setIndex(idx);
				block(_);
			}
			const fend = level - frame.loopLevel <= 1 ? p[end] : null;

			if (frame.loopLevel === level) {
				setIndex(idx);
				frame.loopLevel--;
			}
			if (fend) fend(_);
		};
	},
	FORIN(varName: string, items: types.Expression<any>[], p: types.Expression<any>[], end: number, block: types.Expression<any>) {
		return function forv$do(_: _) {
			const frame = glob.context.x3frame;
			const level = ++frame.loopLevel;

			var setValue: (val: any) => void;

			for (var i = 0, l = items.length; i < l && frame.loopLevel === level; i++) {
				var val = items[i](_);
				setValue = setValue || getSetter(varName, val);
				setValue(val);
				block(_);
			}
			const fend = level - frame.loopLevel <= 1 ? p[end] : null;

			if (frame.loopLevel === level) {
				frame.loopLevel--;
			}
			if (fend) fend(_);
		};
	},
	BREAK(p: void, level: types.Expression<number>) {
		return function break$do(_: _) {
			const frame = glob.context.x3frame;
			const l = level(_);

			if (l < 0) throw new errors.X3Error(50, "invalid break level: " + l);
			if (frame.loopLevel === null || frame.loopLevel < l) throw new errors.X3Error(50, "invalid break level: " + l + " frame.loopLevel:" + frame.loopLevel);
			frame.loopLevel -= l;
		};
	},
	MAIN(e: types.Expression<any>, _: _) {
		if (gotMain) return;
		gotMain = true;
		const frame = glob.context.x3frame = variables.createStack(config);
		// desynchronize execution to load rest of module and dependencies
		_.sleep(_, 0);
		const t0 = Date.now();

		try {
			var r = instructions.GOSUB(basic.instructions.C(e), 'MAIN')(_);
			console.log("OK: " + r);
		} catch (e) {
			console.log("FAILED: " + e + "\njs stack=" + e.stack);
		}
		console.log("completed in: " + (Date.now() - t0) / 1000 + " s");
		console.log(Math.floor(process.memoryUsage().heapUsed / (1024 * 1024)) + " MB heap used");
		require('./index').dumpCounters();
	},
	PRAGMA(data: any) {
		const loc = basic.sourceLoc;

		Object.keys(data).forEach(k => {
			util.any(loc)[k] = data[k];
		});
	}
};