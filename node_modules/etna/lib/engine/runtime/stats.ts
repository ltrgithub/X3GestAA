"use strict";

const glob = require('streamline-runtime').globals;
import * as util from './util';
import { X3Error } from './errors';

function _iter(args, fn) {
	for (var i = 0; i < args.length; i++) {
		var val = args[i];
		//dbg:console.error("iter " + i +" = ", val)
		if (Array.isArray(val)) {
			var ndims = val[0];
			//dbg:console.error("iter: ndims=" + ndims)
			var data = val[2];
			var sliced = val.length === 3 + 4 * ndims;
			if (sliced) {
				var _doSlice = function (dim, off, mult) {
					const size = val[4 + 2 * dim];
					const offset = val[3 + 2 * (ndims + dim)];
					const count = val[4 + 2 * (ndims + dim)];

					if (dim < ndims - 1) {
						for (var j = 0; j < count; j++) _doSlice(dim + 1, (off + offset + j) * mult, size);
					} else {
						//dbg:console.error("25 - ITER slice: off=" + off + " offset=" + offset + ", count=" + count)
						for (var j = 0; j < count; j++) {
							var v = data[off + offset + j];
							if (fn(v)) return;
						}
					}
				};
				_doSlice(0, 0, 1);
			} else {
				var size = 1;
				for (var j = 0; j < ndims; j++) {
					if (val[4 + 2 * j] == null) {
						size = val[2].length;
						break;
					} else {
						size *= val[4 + 2 * j] - val[3 + 2 * j] + 1;
					}
				}
				//dbg:console.error("44 - ITER size=" + size)
				for (var j = 0; j < size; j++) {
					var v = data[j];
					if (fn(v)) return;
				}
			}
		} else {
			//dbg:console.error("50 - ITER");
			if (fn(val)) return;
		}
	}
}

exports.functions = {
	AVG: {
		count: -1,
		fn() {
			var total = 0;
			var count = 0;
			_iter(arguments, function (v) {
				total = total.x3Add(v);
				count++;
			});
			return count === 0 ? 0 : total.x3Div(count);
		}
	},
	FIND: {
		count: -1,
		fn(val, args) {
			args = Array.prototype.slice.call(arguments, 1);
			var i = 0,
			    result = 0;
			_iter(args, function (v) {
				++i;
				if (v.x3Compare(val) === 0) {
					result = i;
					return true;
				}
			});
			return result;
		}
	},
	FINDOBJ: {
		async: true,
		count: -1,
		fn(_, val, target, property, range) {
			if (Array.isArray(target)) {
				var arr = target;
				var base = arr[3];
				for (var i = range[0][0]; i <= range[0][1]; i++) {
					var instance = arr[2][i - base];
					if (!instance) return 0;
					if (instance.get(_, property).x3Compare(val) === 0) return i;
				}
				return 0;
			} else if (target.collection) {
				for (var i = 1, max = target.x3Maxtab(); i <= max; i++) {
					if (target.index(_, i).get(_, property).x3Compare(val) === 0) return i;
				}
			}
			return 0;
		}
	},
	MAX: {
		count: -1,
		fn() {
			var result;
			_iter(arguments, function (v) {
				if (util.x3IsDatetime(v)) throw new X3Error(50, "");
				result = result === undefined || result.x3Compare(v) < 0 ? v : result;
			});
			return result;
		}
	},
	MAXCOL: {
		async: true,
		count: -1,
		fn(_, target, property, range) {
			return Math.max(target.pluck(_, property).slice(range[0][0] - 1, range[0][1]));
		}
	},
	MIN: {
		count: -1,
		fn() {
			var result;
			_iter(arguments, function (v) {
				if (util.x3IsDatetime(v)) throw new X3Error(50, "");
				result = result === undefined || result.x3Compare(v) > 0 ? v : result;
			});
			return result;
		}
	},
	SUM: {
		count: -1,
		fn() {
			var result;
			_iter(arguments, function (v) {
				if (v !== null && v !== undefined) result = result === undefined ? v : result.x3Add(v);
			});

			if (result === undefined) {
				var data = arguments[0];
				result = data[1]; // Default value of the first array:
			}
			return result;
		}
	},
	PRD: {
		count: -1,
		fn() {
			var result = 1;
			_iter(arguments, function (v) {
				result = result.x3Mul(v);
			});
			return result;
		}
	},
	UNI: {
		count: -1,
		fn() {
			const map = {};

			var result = 0;
			var i = 0;
			_iter(arguments, function (v) {
				++i;
				v = v.x3ToString();
				if (map[v]) {
					result = i;
					return true;
				}
				map[v] = true;
			});
			return result;
		}
	},
	VAR: {
		count: -1,
		fn() {
			var sum = 0,
			    sum2 = 0,
			    count = 0;
			_iter(arguments, function (v) {
				sum = sum.x3Add(v);
				sum2 = sum2.x3Add(v.x3Mul(v));
				count++;
			});
			//return count === 0 ? 0 : (sum2 - (sum * sum) / count)/count;
			return count === 0 ? 0 : sum2.x3Sub(sum.x3Mul(sum).x3Div(count)).x3Div(count);
			//( sx2 - ( sx * sx / n ) ) / n
		}
	},
	SIGMA: { // parser needs it in this table but fn will never be called
		count: -1
	}
};

exports.instructions = {
	SIGMA(field, args) {
		return function sigma$do(_) {
			const frame = glob.context.x3frame;

			var result = null;
			//var lhs = exports.V(field);
			const first = args[0](_).x3ToInteger();
			const last = args[1](_).x3ToInteger();
			const values = frame.values;

			for (var i = first; i <= last; i++) {
				//lhs(_, i);
				values[field] = i;
				frame.context.sys.values.INDCUM = i;
				var val = args[2](_);
				result = result == null ? val : result.x3Add(val);
			}
			return result;
		};
	}
};