import { Driver } from '../drivers/types';
import { X3Error } from './errors';
import * as util from './util';
import * as bcd from './tbcd';

export class Double {
	value: number;
	constructor(v: any) {
		if (typeof v === 'number') {
			this.value = v;
		} else if (v.x3IsNumeric && v.x3IsNumeric()) {
			this.value = v.x3ToDouble().valueOf();
		} else throw util.badOperand(v);
	}
	valueOf() {
		return this.value;
	}
	x3IsNumeric() {
		return true;
	}
	x3IsEmpty() {
		throw util.badOperand(this);
	}
	x3AssertOverflow(type: string) {
		return true;
	}
	x3Minus() {
		return new Double(-this.value);
	}
	x3ToDouble() {
		return this;
	}
	x3ToString() {
		return "" + this.value;
	}
	x3ToBCD() {
		return bcd.fromDouble(this.value);
	}
	x3ToInteger() {
		const sign = this.value < 0 ? -1 : 1;
		return Math.floor(Math.abs(this.value)) * sign;
	}
	x3ToDate() {
		throw util.badOperand(this);
	}
	x3ToDatetime() {
		throw util.badOperand(this);
	}
	x3IsZero() {
		return this.value === 0 ? true : false;
	}
	x3Compare(b: any) {
		if (!b.x3IsNumeric()) throw util.badOperand(b);

		const bb = b.x3ToDouble();
		var e = Math.abs(this.value);
		var d = Math.abs(bb.value);

		// compute precision  min(a, b)/10000000 or 1/100000000
		if (d < e) e = d;
		if (e === 0) e = 1;
		e /= 1000000000;
		d = this.value - bb.value;

		if (-e < d && d < e) return 0;
		else if (d >= e) return 1;

		else return -1;
	}
	x3Add(b: any) {
		if (b.x3IsNumeric()) {
			const bb = b.x3ToDouble();
			return new Double(this.value + bb.value);
		} else if (util.x3IsDate(b) || util.x3IsDatetime(b)) {
			return b.x3Add(this);
		} else throw util.badOperand(b);
	}
	x3Sub(b: any) {
		if (!b.x3IsNumeric()) throw util.badOperand(b);

		const bb = b.x3ToDouble();
		return new Double(this.value - bb.value);
	}
	x3Mul(b: any) {
		if (!b.x3IsNumeric()) throw util.badOperand(b);

		const bb = b.x3ToDouble();
		return new Double(this.value * bb.value);
	}
	x3Div(b: any) {
		if (!b.x3IsNumeric()) throw util.badOperand(b);
		if (b.x3IsZero()) throw new X3Error(53, "division by zero");
		const bb = b.x3ToDouble();
		return new Double(this.value / bb.value);
	}
	x3Mod(b: any) {
		if (!b.x3IsNumeric()) throw util.badOperand(b);

		const bb = b.x3ToDouble();
		return new Double(this.value % bb.value);
	}
	x3Pow(b: any) {
		if (!b.x3IsNumeric()) throw util.badOperand(b);

		const bb = b.x3ToDouble();
		return new Double(Math.pow(this.value, bb.value));
	}
	x3Xor(b: any) {
		if (!b.x3IsNumeric()) throw util.badOperand(b);

		const i = this.x3IsZero() ? 1 : 0;
		const j = b.x3IsZero() ? 1 : 0;

		return i ^ j;
	}
	x3Abs() {
		return new Double(Math.abs(this.value));
	}
	x3Truncate() {
		const sign = this.value < 0 ? -1 : 1;
		return new Double(Math.floor(Math.abs(this.value)) * sign);
	}
	x3ToSql(driver: Driver) {
		return this.value;
	}
	x3Type() {
		return 6;
	}
}
