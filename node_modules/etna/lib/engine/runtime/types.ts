import { _ } from "streamline-runtime";
import * as ez from "ez-streams";
import * as core from 'syracuse-core';
import { File } from './files';
import { GClass } from './gclass';
import { Slots } from './slots';
import { DBTableParent } from './dbtableparent';
import { Supervisor } from '../../supervisor/supervisor';

export interface FrameWhereContext {
	revert: boolean;
}

export interface SysValues {
	ADXDCS: number;
	FSTAT: number;
	ADXSQLREC: number;
	ADXIFS: string;
	ADXIRS: string;
	ADXIUM: number;
	ADXTUL: string;
	ADXTUC: string;
	ADXTUT: string;
}
export interface Sys {
	values: SysValues;
}

export interface FrameContext {
	globals: VariableDict;
	tables: { [abbrev: string]: DBTableParent };
	gclass: { [abbrev: string]: GClass };
	files: { [abbrev: string]: File };
	tableSlots?: Slots;
	superv: Supervisor;
	sys: Sys;
	err?: any;
}

export interface Location {
	file?: string;
	module?: string;
	line?: number;
	strict?: boolean;
}

export interface ProgArg {
	abrev?: string;
	type: string;
	typ?: number; // optional typtyp
	value: any;
	set?: (_: _, val: any) => void;
}

export interface ProgArgMembers {
	name: string;
	path: string[];
	jsName?: string;
}

export interface ProgArgsVars {
	THIS?: ProgArg;
	ASTATUS?: ProgArg;
	CURPRO?: ProgArg;
	CURPTH?: ProgArg;
	_AOLDVAL?: ProgArg;
	_ANEWVAL?: ProgArg;
	ARET_VALUE: ProgArg;
	[name: string]: any; // should be ProgArg - fix later
}

export type ProgArgs = ProgArgsVars & ProgArgMembers;

export interface Prog {
	name: string;
	loc?: Location;
	body: any;
	params: string[];
	module: any;
}

export interface Frame {
	context: FrameContext;
	sub?: Frame;
	abbrev?: string;
	whereContext?: FrameWhereContext;
	tryingSql?: boolean;
	values: { [name: string]: any };
	types: { [name: string]: string };
	orderBase?: number;
	orderCount?: number;
	prog?: Prog;
	loc: Location;
	stackLevel: number;
	loopLevel: number;
	errgo?: (_: _) => void;
	dicts?: VariableDict[];
	tablePos?: number;
}

export interface VariableDict {
	types: { [name: string]: string };
	values: { [name: string]: any };
}

export interface VariableType {	
}
export type VariableOp = {
	fn: (frame: Frame, dict: VariableDict, field: string, val?: any, silent?: boolean, strict?: boolean) => any;
	error: (_: _, frame: Frame, field: string, val?: any, silent?: boolean, strict?: boolean) => void;
}

export interface Expression<T> {
	(_: _, op?: VariableOp, val?: any, silent?: boolean, strict?: boolean): T;
	value?: T;
}

export interface Instruction<T> {
	(): Expression<T>;
}

export interface Function {
	count: number;
	fn(): any;
}

export interface ParseNode {
	tag: string;
}

export interface Connection {

}


export interface SqlQueryOptions{
	limit?: boolean;
	typesmap?: any; // refine later
	dispatch?: any; // refine later
	decimalColumns?: string[];
}

export interface DriverReaderOptions {
}

export interface SqlReaderOptions {
	typesmap?: any; // refine later
	dispatch?: any; // refine later
}

export interface SqlExecuteOptions {
}

export interface Hint {
	tname: string;
	abbrev: string;
	revert: boolean;
}

export interface SqlColumnDesc {
	name?: string;
	type?: string;
	typtyp?: number;
}

export type SqlColumnsDesc = { [name: string]: SqlColumnDesc };

export interface Driver {
	nullDate(): core.types.date.DateValue;
	lockClause0(): string;
	param(i: number): string;
	reader(_: _, cnx: Connection, sql: string, args: any[], opts?: DriverReaderOptions): ez.Reader<Row>;
	reader(_: _, sql: string, args: any[], opts?: DriverReaderOptions): ez.Reader<Row>;
	writer(_: _, cnx: Connection, sql: string): ez.Writer<Row>;
	writer(_: _, sql: string): ez.Writer<Row>;
	isUniqueViolated(err: any): boolean;
	isLocked(err: any): boolean; 
	isIndexNotFound(err: any): boolean; 
	isTableNotFound(err: any): boolean; 
	dropIndexSql(indexName: string, tableName: string): string;
	lobPlaceholder(type: string): string;
	tableExists(_: _, name: string, schema: string): boolean;
	tinyIntType(): string;
	shortIntType(): string;
	intType(): string;
	decimalType(): string;
	doubleType(): string;
	stringType(len: number): string;
	dateType(): string;
	sqlDate(val: any): string; // strange
	blobType(): string;
	blobReader(_: _, val: any): ez.Reader<Buffer>;
	clobType(): string;
	clobReader(_: _, val: any): ez.Reader<String>;
	datetimeType(): string;
	uuidType(): string;
	execute(_: _, cnx: Connection, sql: string, args?: any[], opts?: SqlExecuteOptions): any;
	release(_: _): void;
	hintClause0(hint: Hint, def: boolean): string;
	hintClause1(hint: Hint, def: boolean): string;
	lockClause1(): string;
	rowIdGet(str: string): string;
	isNullDate(value: any): boolean;
	isNullUuid(value: any): boolean;
	readBlob(_: _, value: any): any;
	readClob(_: _, value: any): any;
	lengthString(): string;
	subString(arg: string, beg: string, end: string): string;
	rowIdPut(arg: string): string;
	uniqid(arg: string): string;
	describeQuery(_: _, sql: string, folder: string): SqlColumnDesc[];
}

export type Row = { [name: string]: any };

export interface RowDescType {
	fromSql(_: _, val: any): any;
}
export interface RowDesc {
	name: string;
	type: RowDescType;
}

export interface NodeData {
	$type: string;
	$item: NodeProto;
}

export interface NodeLink {
	$type?: string;
	$title?: string;
	$url?: string;
	$target?: string;
}

export interface NodeProto {
	$url?: string;
	$type?: string;
	$key?: string;
	$value?: any;
	$title?: string;
	$shortTitle?: string;
	$description?: string;
	$isReadOnly?: boolean;
	$isMandatory?: boolean;
	$isHidden?: boolean;
	$isExcluded?: boolean;
	$isDisabled?: boolean;
	$capabilities?: string;
	$format?: string;
	$maxLength?: number;
	$precision?: number;
	$scale?: number;
	$minItems?: number;
	$maxItems?: number;
	$item?: NodeProto;
	$properties?: { [name: string]: NodeProto };
	$instanceUrl?: string;
	$x3Format?: string;
	$unit?: string;
	$acceptedTypes?: string[];
	[name: string]: any;
	$links?: {
		$localize?: NodeLink;
		[name: string]: NodeLink; 
	};
}

