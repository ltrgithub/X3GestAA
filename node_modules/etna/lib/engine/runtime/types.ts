import { _ } from "streamline-runtime";
import * as ez from "ez-streams";
import * as core from 'syracuse-core';
import { File } from './files';
import { GClass } from './gclass';
import { Slots } from './slots';
import { DBTableParent } from './dbtableparent';
import { Supervisor } from '../../supervisor/supervisor';
import { Connection } from '../drivers/types';

export type Dict<T> = { [name: string]: T; };

export interface EtnaConfig {
	session?: {
		userName?: string;
	}
}

export interface QueryContext {
	tables?: string[];
	noabbrev?: boolean;
	revert?: boolean;
}

export interface SysValues {
	ADXDCS?: number;
	FSTAT?: number;
	ADXSQLREC?: number;
	ADXIFS?: string;
	ADXIRS?: string;
	ADXIUM?: number;
	ADXTUL?: string[];
	ADXTUC?: string[];
	ADXTUC0?: string[];
	ADXTUT?: string[];
	ADXTUT0?: string[];
	ADXDLREC?: number;
	ADXUPREC?: number;
	ADXLOG?: number;
	[name: string]: any;
}
export interface Sys {
	values: SysValues;
	types: Dict<string>
}

export interface FrameContext {
	globals: VariableDict;
	tables: Dict<DBTableParent>;
	gclass: Dict<GClass>;
	files: Dict<File>;
	tableSlots?: Slots;
	superv: Supervisor;
	sys: Sys;
	err?: any;
	loginName: string;
	messages: string[];
}

export interface Location {
	file?: string;
	module?: string;
	line?: number;
	strict?: boolean;
}

export type InstanceIndex = {
	name?: string;
	etnaType?: string;
}[];

export interface ProgArg {
	abrev?: string;
	type: string;
	typ?: number; // optional typtyp
	value: any;
	set?: (_: _, val: any) => void;
}

export interface ProgArgMembers {
	name?: string;
	path?: string[];
	jsName?: string;
}

export interface ProgArgsVars {
	THIS?: ProgArg;
	ASTATUS?: ProgArg;
	CURPRO?: ProgArg;
	CURPTH?: ProgArg;
	_AOLDVAL?: ProgArg;
	_ANEWVAL?: ProgArg;
	ARET_VALUE?: ProgArg;
	WCLOB?: ProgArg;
	ARULE?: ProgArg;
	AEVENT?: ProgArg;
	AOPERATION?: ProgArg;
	AMETHOD?: ProgArg;
	[name: string]: any; // should be ProgArg - fix later
}

export type ProgArgs = ProgArgsVars & ProgArgMembers;

export interface Prog {
	module: Dict<any>;
	name: string;
	loc?: Location;
	body?: any;
	params?: string[];
}

export interface SubFrame {
	prevSub?: SubFrame;
	name?: string;
	loc?: Location;
	debug?: any;
	debugStepMark?: number;
}

export interface Frame extends SubFrame {
	context: FrameContext;
	prev?: Frame;
	sub?: SubFrame | Frame;
	abbrev?: string;
	whereContext?: QueryContext;
	tryingSql?: boolean;
	values: { [name: string]: any };
	types: { [name: string]: string };
	orderBase?: number;
	orderCount?: number;
	prog?: Prog;
	stackLevel: number;
	loopLevel: number;
	errgo?: (_: _) => void;
	dicts?: VariableDict[];
	tablePos?: number;
	loginName?: string;
	fcall?: string;
}

export interface VariableDict {
	types: { [name: string]: string };
	values: { [name: string]: any };
}

export interface VariableType {	
}
export type VariableOp = {
	fn: (frame: Frame, dict: VariableDict, field: string, val?: any, silent?: boolean, strict?: boolean) => any;
	error: (_: _, frame: Frame, field: string, val?: any, silent?: boolean, strict?: boolean) => void;
}

export interface Expression<T> {
	(_: _, op?: VariableOp, val?: any, silent?: boolean, strict?: boolean): T;
	value?: T;
}

export interface Instruction<T> {
	(): Expression<T>;
}

export interface Function {
	count: number;
	fn(): any;
}

export interface RowDescType {
	fromSql(_: _, val: any): any;
}
export interface RowDesc {
	name: string;
	type: RowDescType;
}

export interface QueryParams {
	$orderBy: string;
	$query: string;
	$params: any;
}

export interface X3Session {
	dbConnection: Connection;
	transactionLevel: number;
	userName: string;
	locale: string;
}

export interface X3Prog<T> {
	name?: string;
	params: string[];
	body: (_: _) => T;
}
