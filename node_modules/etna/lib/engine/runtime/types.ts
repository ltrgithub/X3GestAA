import { _ } from "streamline-runtime";
import * as ez from "ez-streams";
import * as core from 'syracuse-core';
import { File } from './files';
import { GClass } from './gclass';
import { Slots } from './slots';
import { DBTableParent } from './dbtableparent';
import { Supervisor } from '../../supervisor/supervisor';

export interface EtnaConfig {
	session?: {
		userName?: string;
	}
}

export interface QueryContext {
	tables?: string[];
	noabbrev?: boolean;
	revert?: boolean;
}

export interface SysValues {
	ADXDCS: number;
	FSTAT: number;
	ADXSQLREC: number;
	ADXIFS: string;
	ADXIRS: string;
	ADXIUM: number;
	ADXTUL: string;
	ADXTUC: string;
	ADXTUT: string;
	ADXDLREC: number;
	ADXUPREC: number;
	ADXLOG: number;
}
export interface Sys {
	values: SysValues;
}

export interface FrameContext {
	globals: VariableDict;
	tables: { [abbrev: string]: DBTableParent };
	gclass: { [abbrev: string]: GClass };
	files: { [abbrev: string]: File };
	tableSlots?: Slots;
	superv: Supervisor;
	sys: Sys;
	err?: any;
}

export interface Location {
	file?: string;
	module?: string;
	line?: number;
	strict?: boolean;
}

export interface ProgArg {
	abrev?: string;
	type: string;
	typ?: number; // optional typtyp
	value: any;
	set?: (_: _, val: any) => void;
}

export interface ProgArgMembers {
	name: string;
	path: string[];
	jsName?: string;
}

export interface ProgArgsVars {
	THIS?: ProgArg;
	ASTATUS?: ProgArg;
	CURPRO?: ProgArg;
	CURPTH?: ProgArg;
	_AOLDVAL?: ProgArg;
	_ANEWVAL?: ProgArg;
	ARET_VALUE?: ProgArg;
	[name: string]: any; // should be ProgArg - fix later
}

export type ProgArgs = ProgArgsVars & ProgArgMembers;

export interface Prog {
	name: string;
	loc?: Location;
	body: any;
	params: string[];
	module: any;
}

export interface SubFrame {
	prevSub?: SubFrame;
	name?: string;
	loc?: Location;
	debug?: any;
	debugStepMark?: number;
}

export interface Frame extends SubFrame {
	context: FrameContext;
	prev?: Frame;
	sub?: SubFrame | Frame;
	abbrev?: string;
	whereContext?: QueryContext;
	tryingSql?: boolean;
	values: { [name: string]: any };
	types: { [name: string]: string };
	orderBase?: number;
	orderCount?: number;
	prog?: Prog;
	stackLevel: number;
	loopLevel: number;
	errgo?: (_: _) => void;
	dicts?: VariableDict[];
	tablePos?: number;
	loginName?: string;
	fcall?: string;
}

export interface VariableDict {
	types: { [name: string]: string };
	values: { [name: string]: any };
}

export interface VariableType {	
}
export type VariableOp = {
	fn: (frame: Frame, dict: VariableDict, field: string, val?: any, silent?: boolean, strict?: boolean) => any;
	error: (_: _, frame: Frame, field: string, val?: any, silent?: boolean, strict?: boolean) => void;
}

export interface Expression<T> {
	(_: _, op?: VariableOp, val?: any, silent?: boolean, strict?: boolean): T;
	value?: T;
}

export interface Instruction<T> {
	(): Expression<T>;
}

export interface Function {
	count: number;
	fn(): any;
}

export interface ParseNode {
	tag: string;
}

export interface ParseValueNode extends ParseNode {
	value: any;	
}

export interface ParseMemberNode extends ParseNode {
	target: ParseNode;
	name: string;
}

export interface ParseDictNode extends ParseNode {
	field: string;
	letter: string;
	abbrev: string;
}

export interface ParseTypeNode extends ParseNode {
	field: string;
	letter: string;
	exp: ParseNode;
}

export interface ParseOpNode extends ParseNode {
	op: string;
	args: ParseNode[];
}

export interface ParseFCallNode extends ParseNode {
	name: string;
	args: ParseNode[];
}

export interface ParseFuncNode extends ParseNode {
	from: ParseNode;
	name: ParseNode;
	args: ParseNode[];
}

export interface ParseIndexNode extends ParseNode {
	target: ParseNode;
	args: ParseNode[];
}

export interface ParseArgNode extends ParseNode {
	arg: ParseNode;
}

export interface ParseArgsNode extends ParseNode {
	args: ParseNode[];
}

export interface ParseFieldArgsNode extends ParseNode {
	field: string;
	args: ParseNode[];
}

export interface ParseDateNode extends ParseNode {
	year: number;
	month: number;
	day: number;
}

export type Connection = any; // oracle or tedious

export interface SqlQueryOptions{
	limit?: boolean;
	typesmap?: any; // refine later
	dispatch?: any; // refine later
	decimalColumns?: string[];
}

export interface DriverReaderOptions {
}

export interface SqlReaderOptions {
	typesmap?: any; // refine later
	dispatch?: any; // refine later
}

export interface SqlExecuteOptions {
	decimalColumns?: string[];
	fetchInfo?: any; // refine later (driver dependent?)
	outputVars?: SqlColumnDesc[];
}

export interface Hint {
	tname: string;
	abbrev: string;
	revert: boolean;
	name?: string;
	nohint?: boolean;
}

export interface SqlColumnDesc {
	name?: string;
	type?: string;
	typtyp?: number;
}

export type SqlColumnsDesc = { [name: string]: SqlColumnDesc };

// driver types
export interface ColumnDefinition {
	name: string;
	maxLength?: number;
	isNullable?: boolean;
	default?: any;
	colType?: string;
	type?: string;
	// following ones only in SQL server
	decimalPrecision?: number;
	decimalScale?: number;
	useFloatingPointFormat?: boolean;
}

export interface IndexColumn {
	name: string;
	ascending?: boolean;
}

export interface IndexDefinition {
	name: string;
	isUnique: boolean;
	columns: IndexColumn[];
	// following ones only in SQL Server
	isPk?: boolean;
}

export interface TableDefinition {
	schemaName: string;
	tableName: string;
	columns?: ColumnDefinition[];
	indexes?: IndexDefinition[];
	isOpenAccess?: boolean;
	sequence?: number;
	lastUpdate?: Date;
}

export interface TableFilter {
	key: string;
	operator: string;
	value: any;
}

export interface DriverConfig {
	connectString?: string;
	hostname?: string;
	port?: number;
	database?: string;
	trace?: (...args: any[]) => void;
	// for sql server
	user?: string;
	password?: string;
	requestTimeout?: number;
};

export interface Driver extends BaseDriver {
	reader(_: _, cnx: Connection, sql: string, args: any[], opts?: DriverReaderOptions): ez.Reader<Row>;
	reader(_: _, sql: string, args: any[], opts?: DriverReaderOptions): ez.Reader<Row>;
	writer(_: _, cnx: Connection, sql: string): ez.Writer<Row>;
	writer(_: _, sql: string): ez.Writer<Row>;
	execute(_: _, cnx: Connection, sql: string, args?: any[], opts?: SqlExecuteOptions): any;
	execute(_: _, sql: string, args?: any[], opts?: SqlExecuteOptions): any;
}

export interface BaseDriver {
	nullDate(): Date; //core.types.date.DateValue;
	lockClause0(): string;
	param(i: number): string;
	reader(_: _, cnx: Connection, sql: string, args: any[], opts?: DriverReaderOptions): ez.Reader<Row>;
	writer(_: _, cnx: Connection, sql: string): ez.Writer<Row>;
	isUniqueViolated(err: any): boolean;
	isLocked(err: any): boolean; 
	isIndexNotFound(err: any): boolean; 
	isTableNotFound(err: any): boolean; 
	isNoRecord(err: any): boolean;
	dropIndexSql(indexName: string, tableName: string): string;
	lobPlaceholder(type: string): string;
	tableExists(_: _, name: string, schema: string): boolean;
	tinyIntType(): string;
	shortIntType(): string;
	intType(): string;
	decimalType(): string;
	doubleType(): string;
	stringType(len: number): string;
	dateType(): string;
	//sqlDate(val: any): string; // strange
	blobType(): string;
	blobReader(_: _, val: any): ez.Reader<Buffer>;
	clobType(): string;
	clobReader(_: _, val: any): ez.Reader<String>;
	datetimeType(): string;
	uuidType(): string;
	execute(_: _, cnx: Connection, sql: string, args?: any[], opts?: SqlExecuteOptions): any;
	release(_: _): void;
	hintClause0(hint: Hint, def: boolean): string;
	hintClause1(hint: Hint, def: boolean): string;
	lockClause1(): string;
	rowIdGet(str: string): string;
	isNullDate(value: any): boolean;
	isNullUuid(value: any): boolean;
	readBlob(_: _, value: any): any;
	readClob(_: _, value: any): any;
	lengthString(): string;
	subString(arg: string, beg: string, end: string): string;
	rowIdPut(arg: string): string;
	uniqid(arg: string): string;
	describeQuery(_: _, sql: string, folder: string): SqlColumnDesc[];
	withConnection<T>(_: _, body: (_: _, cnx: Connection) => T): T;
	getFullTableDefName(def: TableDefinition): string;
	getFullTableName(schemaName: string, tableName: string): string;
	beginTransaction(_: _,  cnx: Connection): void;
	commitTransaction(_: _,  cnx: Connection): void;
	rollbackTransaction(_: _,  cnx: Connection): void;
	escape(name: string): string;
	toSqlLob(lob: { value: any }): any;
	toSqlUuid(uuid: Buffer): any;
	toSqlDate(date: any): any;
	allocConnection(_: _): Connection;
	releaseConnection(cnx: Connection, err?: Error): void;
	backupDatabase(_: _, dbName: string, filename: string): void;
	restoreDatabase(_: _, dbName: string, filename: string): void;
	readTables(_: _,  schemaName: string): TableDefinition[];
	createPermissions(_: _, tableDef: TableDefinition, config: PermissionsConfig): void;
	getTableDef(_: _,  schemaName: string, tablename: string): TableDefinition;
	createTableReader(_: _,  tableDef: TableDefinition, filters: TableFilter[]): ez.Reader<Row>;
	createTableWriter(_: _,  tableDef: TableDefinition): ez.Writer<Row>;
	clearTable(_: _,  tableDef: TableDefinition): void;
	dropTable(_: _,  tableDef: TableDefinition): void;
	dropSequence(_: _,  tableDef: TableDefinition): void;
	evalueRowCount(_: _,  tableDef: TableDefinition): number;
	readTableSchema(_: _,  tableDef: TableDefinition, tracker: any): void;
	createTableFromTableDefinition(_: _,  tableDef: TableDefinition, options: any): void;

	// only in SQL server??
	closeConnections?: (_: _) => void;
}

export interface PermissionsConfig {
	rootFolderName: string;
}

export type Row = {
	AUUID?: Buffer;
	[name: string]: any 
};

export interface RowDescType {
	fromSql(_: _, val: any): any;
}
export interface RowDesc {
	name: string;
	type: RowDescType;
}

export interface NodeData {
	$type: string;
	$item: NodeProto;
}

export interface NodeLink {
	$type?: string;
	$title?: string;
	$url?: string;
	$target?: string;
}

export interface LinkNodeProto {
	$target?: string;
	$method?: string;
	$url?: string;
	$title?: string;
	$type?: string;
	$confirm?: string;
	$officeAddinSetup?: string;
	$parameters?: LinkParamsNodeProto;
	$kind?: string;
	$isHidden?: boolean;
	$isDisabled?: boolean;
	$links?: { [name: string]: LinkNodeProto; };
	$debug?: any;
	$invocationMode?: string;
	$capabilities?: string;
}

export interface ParamPropertiesNodeProto {
	$type?: string;
	$title?: string;
	dummy?: any; // $ missing !!
}

export interface LinkParamsNodeProto {
	$method?: string;
	$url?: string;
	$properties?: ParamPropertiesNodeProto;
	msoCurrentRepresentation?: string; // $ missing!!
}

export interface PropertyRefProto {
	$url: string;
	$value: any;
	$key: string;
	$properties: { [name: string]: NodeProto }
}

export interface NodeProto {
	$url?: string;
	$type?: string;
	$key?: string;
	$value?: any;
	$title?: string;
	$shortTitle?: string;
	$description?: string;
	$isReadOnly?: boolean;
	$isMandatory?: boolean;
	$isHidden?: boolean;
	$isExcluded?: boolean;
	$isDisabled?: boolean;
	$capabilities?: string;
	$format?: string;
	$maxLength?: number;
	$precision?: number;
	$scale?: number;
	$minItems?: number;
	$maxItems?: number;
	$item?: NodeProto;
	$properties?: { [name: string]: NodeProto };
	$instanceUrl?: string;
	$x3Format?: string;
	$unit?: string;
	$acceptedTypes?: string[];
	$links?: {
		$localize?: NodeLink;
		[name: string]: NodeLink; 
	};
	[name: string]: any;
}

export interface PropertyProto {
	$item?: any;
	$type?: string;
	$capabilities?: string;
}

export interface PropertiesProto {
	$resources?: PropertyProto;
	[name: string]: PropertyProto;
}

export interface LinkProto {
	$url?: string;
	$type?: string;
	$method?: string;
	$title?: string;
	$target?: string;
	$isHidden?: boolean;
	$isDisabled?: boolean;
}

export interface LinksProto {
	[name: string]: LinkProto; 
}

export interface Layout {
	$items?: Article[];
}

export interface Article {
	$layout?: Layout;
	$category?: string;
	$title?: string;
	$bind?: string;
	$order?: number;
	$kind?: string;
	$menus?: Menu;
}

export interface Menu extends Article {
	$CODMENU?: string;
	$PARMENU?: string;
	$isBoxCollapsable?: boolean;
	$opened?: boolean;
}

export interface FilterProto {
}

export interface DiagnosisProto {
}

export interface ReturnProto {
}

export interface ActionProto {
	$diagnoses?: DiagnosisProto[];
	$return?: ReturnProto;
	$isDisabled?: boolean;
	$isHidden?: boolean;
	$isRequested?: boolean;
	$links?: LinksProto;
}

export interface ActionsProto {
	$save?: ActionProto;
	[name: string]: ActionProto;
}

export interface ServiceProto {
	$baseUrl?: string;
	$prototype?: string;
	$representation?: string;
	$url?: string;
	$type?: string;
	$etag?: number;
	ETag?: number;
	$uuid?: string;
	$actions?: ActionsProto;
	$diagnoses?: DiagnosisProto[];
}

export interface X3FormatProto {
	stdType: string;
	chars: string;
}
export interface PageProto {
	$article?: Article;
	$filters?: { [name: string]: FilterProto; };
	$actxUser?: string;
	$actxLogin?: string;
	$actxFolder?: string;
	$actxSolution?: string;
	$actxLan?: string;
	$actxLanDef?: string;
	$actxLanIso?: string;
	$actxLegCur?: string;
	$actxNbLeg?: string;
	$baseType?: string;
	$type?: string;
	$representation?: string;
	$prototype?: string;
	$device?: string;
	$title?: string;
	$collaborationUrl?: string;
	$baseUrl?: string;
	$repUrl?: string;
	$instanceUrl?: string;
	$x3FormatExt?: { [name: string]: X3FormatProto; };
	$url?: string;
	$itemsPerPage?: number;
	$properties?: PropertiesProto;
	$links?: LinksProto;
	$actions?:  { [name: string]: ActionProto; };
}

export interface ValueNode {
	$code: string;
	$value: string;
	$title: string;
	$locale: string;
}

export interface DataNode {
	$uuid?: string;
	$links?: LinksProto;
	$diagnoses?: DiagnosisProto[];
	$values?: ValueNode[];
	$access?: string;
	$isDeleted?: boolean;
	$index?: number;
	$url?: string;
	[name: string]: any;
}

export interface Feed {
	$itemsPerPage?: number;
	$resources?: DataNode[];
	$links?: LinksProto;
}

export interface ResourceNode {
	$trackingId?: string;
	$baseUrl?: string;
	$prototype?: string;
	$representation?: string;
	$url?: string;
	$type?: string;
	$etag?: any;
	ETag?: any;
	$actions?: ActionsProto;
	$httpMethod?: string;
}

export interface QueryParams {
	$orderBy: string;
	$query: string;
	$params: any;
}

export interface X3Session {
	dbConnection: Connection;
	transactionLevel: number;
	userName: string;
	locale: string;
}

export interface X3Prog<T> {
	name?: string;
	params: string[];
	body: (_: _) => T;
}
