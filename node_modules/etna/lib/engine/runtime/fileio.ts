import { _ } from 'streamline-runtime';
import * as fs from 'fs';
import { X3path } from './x3path';
import { File } from './files';
import * as types from './types';
import * as util from './util';
import * as basic from './basic';
import * as variables from './variables';
import * as arrays from './arrays';
import { X3Error } from './errors';
import { config } from '../../util/nodeconfig';
const glob = require('streamline/lib/globals');
/* 
 * Sequential I/0
 */

const defabv: { [mode: string]: string } = {
	"r+": "###",
	"w": "##",
	"r": "#"
};

export const functions = {
	DIR$: {
		count: 0,
		fn() {
			return process.cwd();
		}
	},
	FILEXIST: {
		count: 3,
		async: true,
		fn(_: _,  machine: string, folder: string, name: string) {
			const frame = util.currentFrame();
			const xp = new X3path(_, frame.context.superv, "TRT", name, "adx", frame.context.superv.folderName, "", machine);

			try {
				var stat = fs.stat(xp.toString(_), _);
				return 1;
			} catch (ex) {
				if (ex.code === 'ENOENT') return 0;
				else throw ex;
			}
		}
	},
	FILINFO: {
		count: 2,
		async: true,
		fn(_: _,  path: string, what: number): any {
			const frame = util.currentFrame();

			var stat: fs.Stats;

			const xp = new X3path(_, frame.context.superv, path, "", "", "", "");

			try {
				stat = fs.stat(xp.toString(_), _);
			} catch (ex) {
				if (ex.code === 'ENOENT') return -20;
				else throw ex;
			}
			//console.log("FILINFO: " + path + ": " + require("sys").inspect(stat));
			switch (what) {
				case 0:
					// mode
					return stat.mode;
				case 1:
					return stat.ino;
				case 2:
				// device id,
				case 3:
					// device id, char or block mode (who cares?)
					return stat.dev;
				case 4:
					// link number
					return stat.nlink;
				case 5:
					return stat.uid;
				case 6:
					return stat.gid;
				case 7:
					return stat.size;
				case 8:
					return stat.uid;
				case 9:
					return stat.atime;
				case 10:
					return stat.mtime;
				case 11:
					return stat.ctime;
				default:
					// cannot find
					throw new X3Error(10, "bad filinfo action: " + what);
			}
		}
	},
	FILCOM: {
		//count: 6,
		// some args are optional (for ex only 4 in AVOLUME_CSTD line 665)
		fn(folder: string, name: string, ext: string, app?: string, drive?: string, host?: string) {
			folder = util.x3ToString(folder, true);
			name = util.x3ToString(name, true);
			ext = util.x3ToString(ext, true);
			app = app || "test";
			return config.etna.tmpRoot + "/" + app + (folder ? "/" + folder : "") + "/" + name + (ext ? "." + ext : "");
		}
	},
	FILPATH: {
		async: true,
		count: -1,
		fn(_: _,  dir: string, nam: string, ext: string, app?: string, vol?: string, hst?: string) {
			const frame = util.currentFrame();

			// app, vol and hst are optionnals

			dir = util.x3ToString(dir, true);
			nam = util.x3ToString(nam, true);
			ext = util.x3ToString(ext, true);

			if (app) app = util.x3ToString(app);
			if (vol) vol = util.x3ToString(vol, true);
			if (hst) hst = util.x3ToString(hst, true);

			// see later
			const xp = new X3path(_, frame.context.superv, dir, nam, ext, app || "", vol || "", hst || "");

			return xp.toString(_);
		}
	},
	DELFILE: {
		async: true,
		count: 1,
		fn(_: _,  name: string) {
			const frame = util.currentFrame();

			name = util.x3ToString(name, true);

			const xp = new X3path(_, frame.context.superv, name, "", "", "", "");

			try {
				fs.unlink(xp.toString(_), _);
				return 0;
			} catch (ex) {
				return -20;
			}
		}
	},
	RENAMEFILE: {
		async: true,
		count: 2,
		fn(_: _,  oldf: string, newf: string) {
			const frame = util.currentFrame();

			oldf = util.x3ToString(oldf, true);
			newf = util.x3ToString(newf, true);

			const xpo = new X3path(_, frame.context.superv, oldf, "", "", "", "");
			const xpn = new X3path(_, frame.context.superv, newf, "", "", "", "");

			try {
				fs.rename(xpo.toString(_), xpn.toString(_), _);
				return 0;
			} catch (ex) {
				return -20;
			}
		}
	}
};

function findFile(frame: types.Frame, abbrev: string) {
	const file = frame.context.files[abbrev];

	if (!file) throw new X3Error(7, "Sequential file abbrev not found: " + abbrev);
	return file;
}

function closeFile(frame: types.Frame, abbrev: string) {
	if (abbrev === "") {
		if (frame.context.files["###"]) frame.context.files["###"] = null;
		else if (frame.context.files["##"]) frame.context.files["##"] = null;
		else frame.context.files["#"] = null;
	} else frame.context.files[abbrev] = null;
}

function findFileS(frame: types.Frame, abbrev: string) {
	var file;
	if (abbrev === "") file = frame.context.files["###"] || frame.context.files["##"] || frame.context.files["#"];
	else file = frame.context.files[abbrev];

	if (!file) throw new X3Error(7, "Sequential file abbrev not found: " + abbrev);
	return file;
}

function findFileW(frame: types.Frame, abbrev: string) {
	var file;
	if (abbrev === "") file = frame.context.files["###"] || frame.context.files["##"];
	else file = frame.context.files[abbrev];

	if (!file) throw new X3Error(7, "Sequential file abbrev not found: " + abbrev);
	return file;
}

function findFileR(frame: types.Frame, abbrev: string) {
	var file;
	if (abbrev === "") file = frame.context.files["###"] || frame.context.files["#"];
	else file = frame.context.files[abbrev];

	if (!file) throw new X3Error(7, "Sequential file abbrev not found: " + abbrev);
	return file;
}

export const instructions = {
	OPEN(abbrev: string, name: types.Expression<string>, mode: number, seek: types.Expression<number>) {
		seek = seek || basic.instructions.C(0);
		return function open$do(_: _) {
			const frame = util.currentFrame();
			const nameVal = name(_);
			const seekVal = seek(_);
			const xp = new X3path(_, frame.context.superv, nameVal, "", "", "", "");
			const fl = new File(frame.context.sys);

			fl.x3open(_, xp, seekVal, mode);

			// abbrev management
			if (abbrev === "") abbrev = defabv[mode];

			frame.context.files[abbrev] = fl;
		};
	},
	CLOSE(abbrev) {
		return function close$do(_: _) {
			const frame = util.currentFrame();
			const file = findFileS(frame, abbrev, 1);

			file.x3close(_);
			closeFile(frame, abbrev);
		};
	},
	IOMODE(abbrev, mode, value) {
		mode = mode.toLowerCase();
		return function iomode$do(_: _) {
			const frame = util.currentFrame();
			const file = findFile(frame, abbrev);
			const val = value(_);

			file[mode] = val === "" || val === 0 ? undefined : val;
		};
	},
	SEEK(abbrev, mode, _direction, value) {
		return function seek$do(_: _) {
			const frame = util.currentFrame();
			const file = findFileS(frame, abbrev);

			var direction = typeof _direction === "function" ? _direction(_) : parseInt(_direction);
			if (direction === null) direction = 0;
			const val = typeof value === "function" ? value(_) : parseInt(value);

			file.x3seek(_, mode, direction, val);
		};
	},
	WRSEQ(abbrev, exps) {
		return function wrseq$do(_: _) {
			const frame = util.currentFrame();
			const file = findFileW(frame, abbrev);
			const vals = exps(_);
			var newline;

			if (vals[vals.length - 1] !== null) newline = 1;
			else {
				vals.pop();
				newline = 0;
			}
			return file.x3write(_, vals, newline);
		};
	},
	RDSEQ(abbrev, vars) {
		return function rdseq$do(_: _) {
			const frame = util.currentFrame();
			const file = findFileR(frame, abbrev);

			var f,
			    s,
			    i = 0,
			    index = 0;

			// read the line
			const vals = file.x3read(_);

			if (vals.length === 0) {
				util.currentFrame().context.sys.values.FSTAT = 1;
				while (vars[i]) {
					f = vars[i++];
					f(_, variables.vOperations.RAZ);
				}

				return 0;
			} else util.currentFrame().context.sys.values.FSTAT = 0;

			// loop on all variables and values
			while (vars[i]) {
				f = vars[i++];
				s = f(_);

				//console.log(s);
				if (Array.isArray(s)) {
					var fidx;
					if (s[1] > 1) throw new X3Error(26, "More than 1 dimension is not supported");
					var min = s[3];
					var max = s[6] ? s[3] + s[6] - 1 : s[4];

					for (var j = min; j <= max; j++) {
						fidx = arrays.instructions.INDEX(vars[i - 1], [basic.instructions.C(j)]);
						fidx(_, true, vals[index++]);
						if (index >= vals.length) break;
					}
				} else {

					f(_, variables.vOperations.SET, vals[index++], 0);
					if (index >= vals.length) break;
				}
			}
			return 0;
		};
	},
	PUTSEQ(abbrev, nbr, vars) {
		return function putseq$do(_: _) {
			const frame = util.currentFrame();
			const file = findFileW(frame, abbrev);
			const vals = [];
			const size = [];
			const vnbr = nbr(_);

			var f,
			    s,
			    inf,
			    i = 0;

			// prepare values and length
			while (vars[i]) {
				f = vars[i++];
				vals.push(f(_));

				inf = f(_, variables.vOperations.GETINFO);
				if (inf.vsize) size.push(inf.vsize);
				else size.push(0);
			}

			return file.x3put(_, vnbr, vals, size);
		};
	},
	GETSEQ(abbrev, nbr, vars, sized) {
		return function putseq$do(_: _) {
			const frame = util.currentFrame();
			const file = findFileR(frame, abbrev);
			const size = [];
			const vsized = sized ? sized(_) : undefined;

			var f,
			    inf,
			    v,
			    i = 0,
			    n = 0;

			// set variables loop
			while (vars[i]) {
				f = vars[i++];
				v = f(_);
				inf = f(_, variables.vOperations.GETINFO);

				if (Array.isArray(v)) {
					var fidx;
					if (v[1] > 1) throw new X3Error(26, "More than 1 dimension is not supported");
					var min = v[3];
					var max = v[6] ? v[3] + v[6] - 1 : v[4];

					for (var j = min; j <= max; j++) {
						// get value
						var val = file.x3get(_, inf.vsize);
						if (!val) {
							util.currentFrame().context.sys.values.FSTAT = 1;
							return 0;
						}
						// set value in table variable
						fidx = arrays.instructions.INDEX(vars[i - 1], [basic.instructions.C(j)]);
						fidx(_, true, val);
						if (++n >= nbr) break;
					}
					if (n >= nbr) break;
				} else {
					// get value
					// hack on sized
					var val = file.x3get(_, i === 1 && vsized ? vsized : inf.vsize);
					if (!val) {
						util.currentFrame().context.sys.values.FSTAT = 1;
						return 0;
					}
					// set value
					f(_, variables.vOperations.SET, val, 0);
					if (++n >= nbr) break;
				}
			}
			util.currentFrame().context.sys.values.FSTAT = 0;
			return 0;
		};
	}
};