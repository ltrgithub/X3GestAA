import { _ } from 'streamline-runtime';
import * as types from './types';
import * as util from './util';
import * as variables from './variables';
import * as operators from './operators';
import * as array from './arrays';
import * as dates from './dates';
import * as evaluate from './dbevaluate';
import * as tdate from './tdate';
import * as tdatetime from './tdatetime';
import * as flowControl from './flowControl';
import { X3Error } from './errors';
const glob = require('streamline/lib/globals');
import { DBCursor } from './dbcursor';
import { DBTableParent, QueryKey, KeyModified, TableKey, KeyExpression, WKey, TableColumn } from './dbtableparent';
import { Table } from '../../supervisor/meta/table';
import { Column } from '../../supervisor/meta/column';
import * as activ from '../../supervisor/meta/activ';
import { Supervisor } from '../../supervisor/supervisor';
import * as utilDriver from '../drivers/util';


import * as ez from 'ez-streams';
const tracer = require('syracuse-core').getTracer("etna.dbms");

const _reckey: KeyExpression = {
	sql: "",
	constants: [],
	func: [],
	name: null,
	directions: [1],
	items: [""]
};

interface Type {
	etnaType: string;
}

function _identity(x: any) {
	return x;
}

function _extended(abv: string) {
	return abv !== "extended";
}

function _addColumn(r: TableColumn[], t: QueryKey) {
	const n = r.length;
	for (var i = 0; i < n; i++) {
		if (r[i].field === t.field && r[i].index === t.index) break;
	}
	//if (t.abbrev) delete t.abbrev; // we don't need it anymore
	if (i === n) r.push(t);
}

type TableColumns = { [name: string]: QueryKey[] }

function _addColumns(dest: TableColumns, origin: { columns?: QueryKey[]}) {
	for (var ki = 0; ki < origin.columns.length; ki++) {
		const ci = origin.columns[ki];

		// don't initialyse if null, we retriece complete table in this case				
		if (dest[ci.abbrev]) {
			_addColumn(dest[ci.abbrev], ci);
		} else if (dest[ci.abbrev] === undefined) {
			dest[ci.abbrev] = [];
			_addColumn(dest[ci.abbrev], ci);
		}
	}
}

// split a key where;

function _splitKeyWhere(kw: WKey) {
	const tsql = kw.sql.split("OR");
	const nbq = tsql.length;
	tsql[0] = tsql[0].slice(1);
	tsql[nbq - 1] = tsql[nbq - 1].slice(0, tsql[nbq - 1].length - 1);

	const kws: WKey[] = [];
	for (var i = 0; i < nbq; i++) {
		kws[i] = {
			sql: tsql[i],
			tooComplex: false,
			type: 'boolean',
			constants: kw.constants.slice(0, nbq - i),
			func: kw.func
		};
	}
	return kws;
}

// tab criteria contains post evaluated
// -----------------------------------------------------------------------

function _isPostEvaluated(wh: WKey[]) {
	for (var i = 0; i < wh.length; i++) {
		if (wh[i].postEvaluation) return true;
	}
	return false;
}

// build Read and for Query
// -----------------------------------------------------------------------

export type Predicates = types.Expression<boolean[]>[];
export type ContextFn<T> = (_: _, cx: types.QueryContext) => T;

function _buildQuery(_: _, clause: string, dbtable: DBTable, key: KeyExpression, wkey: WKey[], 
fwhere?: ContextFn<WKey[]>, 
fwfrom?: ContextFn<WKey[]>, 
fwto?: ContextFn<WKey[]>, lock?: boolean, hint?: types.Hint) {
	// buikld query
	const master = dbtable.master || dbtable;
	var tablesSql = master.desc.name + " " + master.abbrev;
	const tables: { [name: string]: DBTableParent } = {};
	const abbrevs = [master.abbrev];
	var constants: string[] = [];
	const ctx: types.QueryContext = {};

	if (lock && clause === "read") tablesSql += dbtable.driver.lockClause0();

	// table from --------------------------
	tables[master.abbrev] = master;
	(dbtable.joins || []).forEach(join => {
		abbrevs.push(join.table.abbrev);
		tables[join.table.abbrev] = join.table;
		constants = constants.concat(join.constants || []);
		tablesSql += " " + join.sql;
	});
	ctx.tables = abbrevs;

	// where -----------------------------------
	// -----------------------------------------
	type StringArray = string[];

	const twhere: string[] = [],
	      tconstants: StringArray[] = [],
	      tpwhere: Predicates[] = [];

	// columns is too weird - will sort out typing later
	var columns: any = dbtable.columns;
	// read particular case
	if (clause === "read") columns = columns && columns.extended ? columns : undefined;

	if (wkey && wkey[0].rowid) {
		constants = constants.concat(wkey[0].constants || []);
		twhere[0] = wkey[0].sql;
		tconstants[0] = constants;
		tpwhere[0] = []; /* we don post evaluate rowid */
	} else {
			var wheres: WKey[];

			// we gonna modify the columns list, so we clone it	
			if (columns) columns = Object.assign({}, columns);
			var twkey: WKey[];

			if (wkey) {
				twkey = clause === "read" && wkey[0].splitable ? _splitKeyWhere(wkey[0]) : wkey;
			} else {
				twkey = [null];
			}

			// add key columns if needned
			if (columns && key) _addColumns(columns, key);

			for (var i = 0; i < twkey.length; i++) {
				var tsql: string[] = [];
				tconstants[i] = constants.slice();
				tpwhere[i] = [];

				wheres = [twkey[i]].concat(dbtable.where, dbtable.filter.where);
				if (dbtable.master) {
					wheres = wheres.concat(master.where, master.filter.where);
				}
				wheres = wheres.concat(fwhere && fwhere(_, ctx));
				wheres = wheres.concat(fwfrom && fwfrom(_, ctx));
				wheres = wheres.concat(fwto && fwto(_, ctx));

				wheres.filter(_identity).forEach(w => {
					w.sql && tsql.push(w.sql);
					w.func && tpwhere[i].push(w.func);
					if (!w.tooComplex) tconstants[i] = tconstants[i].concat(w.constants || []);
					if (columns && w.columns) _addColumns(columns, w);
				});
				twhere[i] = tsql.join(' AND ');
			}
		}

	// select ----------------------------------
	// -----------------------------------------
	var typesmap: number[];
	var columnsSql: string;

	const sqlOpts: types.SqlQueryOptions = {};
	if (clause === "rowcount") {
		columnsSql = "Count(*) As A$RESULT_0";
		typesmap = [3];
	} else {
		typesmap = [0];
		columnsSql = (columns ? Object.keys(columns).filter(_extended).reduce((result, a) => {
			//debugger ;
			const cdef = columns[a];
			if (cdef !== null) {

				for (var cnum = 0; cnum < cdef.length; cnum++) {
					const typtyp = cdef[cnum].field.type.data.TYPTYP;
					typesmap.push(typtyp);
					const nm = cdef[cnum].field.data.CODZONE + '_' + cdef[cnum].index;
					result.push(a + "." + nm + " As " + a + "$" + nm);
					if (typtyp === 4) {
						sqlOpts.decimalColumns = sqlOpts.decimalColumns || [];
						sqlOpts.decimalColumns.push(nm);
					}
				}
			} else {
				const tab = tables[a];
				Object.keys(tab.desc.columns).forEach(name => {
					const col = tab.desc.columns[name];
					col.sqlTypesMap(typesmap);
					throw new Error("invalid code path: abbrev was not defined here");
					//result.push(col.sqlNames(abbrev + ".", abbrev, sqlOpts));
				});
			}
			return result;
		}, []) : abbrevs.reduce((result, abbrev) => {
			const tab = tables[abbrev];
			Object.keys(tab.desc.columns).forEach(name => {
				const col = tab.desc.columns[name];
				col.sqlTypesMap(typesmap);
				result.push(col.sqlNames(abbrev + ".", abbrev, sqlOpts));
			});

			result.push(abbrev + ".UPDTICK_0 As " + abbrev + "$UPDTICK_0");
			typesmap.push(3);

			return result;
		}, [])).join(', ');
	}

	// complete queries --------------------------------	
	const tqry = twhere.map((whereSqls, idx) => {
		var currtag = 0;
		const whereSql = whereSqls ? " WHERE " + whereSqls : ' ';
		const middleSql = (tablesSql + whereSql).replace(/@\?/g, val => dbtable.driver.param(currtag++));
		var orderBySql = "";
		if ((!wkey || !wkey[0].rowid) && key && key.sql) orderBySql = " ORDER BY " + key.sql;

		var sql: string;
		if (hint) {
			hint.tname = master.desc.name;
			hint.abbrev = hint.abbrev || master.abbrev;
		}

		//if (clause === "rowcount") sql = "Select ";
		//else sql = "Select " + dbtable.abbrev + ".ROWID As " + dbtable.abbrev + "$ROWID, ";
		switch (clause) {
			case 'rowcount':
				sql = "Select ";
				break;
			case 'read':
				sql = "Select " + dbtable.driver.hintClause0(hint, true) + " " + dbtable.driver.rowIdGet(dbtable.abbrev + ".ROWID") + " As " + dbtable.abbrev + "$ROWID, ";
				break;
			case 'for':
				sql = "Select " + dbtable.driver.hintClause0(hint, false) + " " + dbtable.driver.rowIdGet(dbtable.abbrev + ".ROWID") + " As " + dbtable.abbrev + "$ROWID, ";
				break;
			default:
				throw new X3Error(26, "invalid query type: " + clause + " in buildQurery");
		}

		sql += columnsSql + " From " + middleSql + orderBySql;
		if (lock && clause === "read") sql += dbtable.driver.lockClause1();

		switch (clause) {
			case 'read':
				sql += dbtable.driver.hintClause1(hint, true);
				break;
			case 'for':
				sql += dbtable.driver.hintClause1(hint, false);
				break;
			default:
		}

		return {
			sql: sql,
			maptrim: utilDriver.maptrim(dbtable.driver, typesmap, true),
			typesmap: typesmap,
			tables: tables,
			pwhere: tpwhere[idx],
			constants: tconstants[idx],
			columns: columns,
			sqlOpts: sqlOpts
		};
	});
	return tqry;
}
// -----------------------------------------------------------------------

function _transformKey(orik: KeyExpression, mod: KeyModified) {
	//copy key
	const newk: KeyExpression = {
		name: "",
		sql: "",
		hidden: false,
		unique: mod.length ? false : orik.unique,
		constants: orik.constants,
		kslot: -1
	};

	const len = mod.length || orik.items.length;

	// treat items and sql
	newk.directions = orik.directions.map(d => d * mod.direction).slice(0, len);

	newk.items = orik.items.slice(0, len).map((itm, idx) => {
		const p = itm.lastIndexOf(' ');
		if (p > 0) itm = itm.substring(0, p);
		//if (newk.directions[idx] < 0) itm += " Desc";
		return itm;
	});

	newk.func = orik.func.slice(0, len);

	newk.sql = newk.items.map((it, idx) => it + (newk.directions[idx] < 0 ? " Desc" : "")).join(", ");
	return newk;
}

interface LobVar {
	name: string;
	type: string;
	ind: number;
	column: Column;
}

type OutputVars = ez.Writer<any>[];

function _writeLobs(_: _,  row: types.Row, lobVars: LobVar[], outputVars: OutputVars) {
	lobVars.forEach_(_, (_, lobVar, i) => {
		const col = lobVar.column;
		const val = row[col.name];
		const isClob = col.type.isClob;
		const reader: (v: any) => ez.Reader<any> = isClob ? ez.devices.string.reader : ez.devices.buffer.reader;
		const v = isClob ? val : val && val.value;
		if (isClob && typeof v !== "string") throw new X3Error(26, col.name + ": bad CLOB: " + typeof v);
		if (!isClob && !Buffer.isBuffer(v)) throw new X3Error(26, col.name + ": bad BLOB: " + typeof v);
		reader(v).pipe(_, outputVars[i]);
	});
}

function _lobsReturningClause(driver: types.Driver, lobColumns: Column[], lobVars: LobVar[], currind: number) {
	var sql = " RETURNING ";
	lobColumns.forEach((col, i) => {
		const sqlType = col.type.sqlType();
		for (var j = 0; j < col.data.DIME; j++) {
			if (i > 0 || j > 0) sql += ',';
			const colName = col.name + '_' + j;
			const param = driver.param(currind++);
			lobVars.push({
				name: param.substring(1),
				// remove leading :
				type: col.type.sqlType(),
				column: col,
				// for us below, not for driver
				ind: j
			});
			// idem
			sql += colName + " INTO " + param;
		}
	});
	return sql;
}

// object DBTable classe
// --------------------------------------------------------------------------------
// --------------------------------------------------------------------------------

export class DBTable extends DBTableParent {
	driver: types.Driver;
	sisters: string[];
	reader: ez.Reader<types.Row>;
	values: { [colName: string]: any };
	qrewrite: string;
	qinsert: string;
	defaultLogin: string;

	constructor(driver: types.Driver, abbrev: string, superv?: Supervisor, desc?: Table, keys?: KeyExpression[] | TableKey[], loc?: number) {
		if (driver instanceof DBTable) {
			const tbl: DBTable = util.any(driver);
			super(tbl.driver, abbrev, tbl.superv, tbl.local);
			this.master = tbl;
			this.currkey = 0;
			this.reader = undefined;
			this.desc = tbl.desc;
			this.keys = tbl.keys;

			this.types = tbl.types;
			this.values = tbl.values;
			this.columns = undefined;
		} else {
			super(driver, abbrev, superv, loc);

			this.currkey = 0;
			this.currlen = keys[0].items.length;

			this.reader = undefined;
			this.desc = desc;
			this.keys = util.any(keys); // todo: clean this up
		}
	}
	init(_: _) {
		const table = this;
		const columns = this.desc.columns;

		Object.keys(columns).forEach_(_, (_, colName) => {
			const etnaType = columns[colName].type.etnaType;
			if (columns[colName].data.DIME <= 1) {
				table.values[colName] = variables.types[etnaType].default;
			} else if (columns[colName].data.CODACT) {
				const dime = activ.getActiv(_, this.superv, columns[colName].data.CODACT);
				if (dime) columns[colName].data.DIME = dime;
				table.values[colName] = []; //[1, variables.types[etnaType].default, [], 0, dim-1];
			} else {
					table.values[colName] = [1, variables.types[etnaType].default, [], 0, columns[colName].data.DIME - 1];
				}
			table.types[colName] = ' ' + etnaType;
		});
		return this;
	}

	// operation on table --------------------------------------
	// ---------------------------------------------------------
	x3Read(_: _, key: KeyExpression, lvl: number, wkey: WKey[], krevert: boolean, lock: boolean, hint: types.Hint) {
		var rkey: KeyExpression;
		const cnx = glob.context.x3session.dbConnection;
		if (lock && !cnx) throw new X3Error(26, "Lock without transaction");

		//debugger;
		if (krevert) {
			rkey = _transformKey(key, {
				direction: -1,
				length: 0
			});
			if (hint) hint.revert = true;
		} else rkey = key;

		const tqry = _buildQuery(_, 'read', this, rkey, wkey, undefined, undefined, undefined, lock, hint);
		var fstat = 5; // not found
		for (var idx = 0; idx < tqry.length; idx++) {
			const q = tqry[idx];

			tracer.debug && tracer.debug("Read SQL(" + idx + ")" + this.abbrev + ":" + q.sql);
			tracer.debug && tracer.debug("Constants " + this.abbrev + ":" + q.constants);
			const rdr = this.driver.reader(_, cnx, q.sql, q.constants, q.sqlOpts);
			tracer.debug && tracer.debug("Cursor declaration....");
			const cf = new DBCursor(rdr, q.tables, q.maptrim, q.pwhere, undefined, undefined, "read", q.columns);
			tracer.debug && tracer.debug("Call x3GetRecord....");

			if (cf.x3GetRecord(_)) fstat = 0; // found
			tracer.debug && tracer.debug("Get record Ok : " + JSON.stringify(this.values));
			cf.x3CloseDBReader(_);
			tracer.debug && tracer.debug("Close reader done ");

			if (fstat === 0) break;
		}
		return fstat;
	}

	x3Rewrite(_: _, wkey: WKey[], values: any[]) {
		const abv = (this.master || this).abbrev;
		const lst = this.columns && this.columns[abv];

		if (lst) {

			var sql = "Update " + this.desc.name + " set ";
			for (var i = 0; i < lst.length; i++) {
				sql += (i === 0 ? "" : ", ") + lst[i].field.sqlNamesAssign();
			}

			sql += " Where " + wkey[0].sql;

			// complete query
			var currtag = 0;
			sql = sql.replace(/@\?/g, val => this.driver.param(currtag++));
			if (!wkey[0].rowid) sql = sql.replace(new RegExp(this.abbrev + "\\.", "g"), "");
		} else {
			const colNames = Object.keys(this.desc.columns);
			if (wkey[0].rowid && this.qrewrite) {
				var sql = this.qrewrite;
			} else {

				var sql = "Update " + this.desc.name + " set " + colNames.map(name => {
					const col = this.desc.columns[name];
					return col.sqlNamesAssign();
				}) + " Where " + wkey[0].sql;

				// complete query
				var currtag = 0;
				sql = sql.replace(/@\?/g, val => this.driver.param(currtag++));
				if (!wkey[0].rowid) sql = sql.replace(new RegExp(this.abbrev + "\\.", "g"), "");
			}
		}

		const constants = values.concat(wkey[0].constants || []);

		try {
			tracer.debug && tracer.debug("REWRITE:" + sql);
			tracer.debug && tracer.debug("Constants: " + constants);

			const result = this.superv.executeSql(_, sql, constants);
			if (result.updateCount === 0) return 5;
			return 0;
		} catch (e) {
			if (this.driver.isUniqueViolated(e)) return 3;
			else if (this.driver.isLocked(e)) return 1;
			else throw e;
		}
	}

	x3Write(_: _) {
		var currind = 0;
		const colNames = Object.keys(this.desc.columns);
		const row = this.values;
		const lobColumns: Column[] = [];
		const lobVars: LobVar[] = [];
		const param = (col: Column, i: number) => {
			if (this.driver.lobPlaceholder && col.type.isLob) {
				if (i === 0) lobColumns.push(col);
				return this.driver.lobPlaceholder(col.type.sqlType());
			} else {
				return this.driver.param(currind++);
			}
		};

		// Build query if necessary
		var sql = this.qinsert || (this.qinsert = "Insert into " + this.desc.name + " (" + colNames.map(name => {
			const col = this.desc.columns[name];
			return col.sqlNames("");
		}) + ") VALUES (" + colNames.map(name => {
			var s = "";
			const col = this.desc.columns[name];
			for (var i = 0; i < col.data.DIME; i++) {
				if (i > 0) s += ',';
				s += param(col, i);
			}
			return s;
		}) + ")");

		if (lobColumns.length > 0) {
			sql += _lobsReturningClause(this.driver, lobColumns, lobVars, currind);
		}

		// build values table
		const values: any[] = [];
		colNames.forEach(colName => {
			var val = row[colName];
			const col = this.desc.columns[colName];
			if (this.driver.lobPlaceholder && col.type.isLob) return;
			const etnaType = col.type.etnaType;

			if (col.data.DIME > 1) {
				const tb = val[2];
				for (var i = 0; i < col.data.DIME; i++) {
					if (tb[i] !== undefined) values.push(tb[i]);
					else values.push(variables.types[etnaType].default);
				}
			} else {

				if (/^(CREDATTIM|UPDDATTIM)$/.test(colName) && (val === undefined || val === null || val.x3IsZero && val.x3IsZero())) {
					val = tdatetime.now();
					//val.setMilliseconds(0); // bug tds ??? insertion error with milliseconds
					//val = tdate.fromJsDate(now);
				} else if (/^(CREUSR|UPDUSR)$/.test(colName) && (!val || !val.length)) {
						val = this.defaultLogin;
					} else if (val === undefined) {
						throw new X3Error(26, colName + ": bad value: " + val);
					}
				values.push(val);
			}
		});
		tracer.debug && tracer.debug("WRITE sql:" + sql);
		tracer.debug && tracer.debug("WRITE values:" + values);
		try {
			const result = this.superv.executeSql(_, sql, values, {
				outputVars: lobVars
			});
			if (lobVars.length > 0) {
				_writeLobs(_, row, lobVars, result.outputVars);
			}
			return 0;
		} catch (e) {
			if (this.driver.isUniqueViolated(e)) return 3;
			else if (this.driver.isLocked(e)) return 1;
			else throw e;
		}
	}

	x3OpenFor(_: _, key: KeyExpression, lvl: number, hint: types.Hint, lock: boolean, where: ContextFn<WKey[]>, wfrom: ContextFn<WKey[]>, wto: ContextFn<WKey[]>) {
		const master: DBTable = util.any(this.master) || this;
		const qry = _buildQuery(_, 'for', this, key, undefined, where, wfrom, wto, lock, hint);
		const q = qry[0];

		tracer.debug && tracer.debug("FORF:" + q.sql);
		tracer.debug && tracer.debug("Constants: " + q.constants);

		// execution ---------------------------------------
		const rdr = this.driver.reader(_, q.sql, q.constants, q.sqlOpts);
		master.currentFor = new DBCursor(rdr, q.tables, q.maptrim, q.pwhere, key, lvl, "for", q.columns);
		return master.currentFor;
	}

	x3Delete(_: _, key: KeyExpression, wkey:WKey[], fwhere: ContextFn<WKey[]>) {
		const ctx: types.QueryContext = {};
		ctx.tables = [this.abbrev];

		const dwhere = fwhere && fwhere(_, ctx);

		if (dwhere && _isPostEvaluated(dwhere) || this.where && _isPostEvaluated(this.where) || this.filter.where && _isPostEvaluated(this.filter.where)) {
			// need to build a query ------------------------------
			var nrecord = 0;
			const qry = _buildQuery(_, "for", this, key, wkey, fwhere, undefined, undefined, true, null);
			const q = qry[0];
			const dqry = "Delete " + this.desc.name + " Where ROWID = " + this.driver.param(0);

			// execution ---------------------------------------			
			const rdr = this.driver.reader(_, q.sql, q.constants, q.sqlOpts);
			const cf = new DBCursor(rdr, q.tables, q.maptrim, q.pwhere, key, key.items.length, "for", q.columns);
			const row_save = this.values;

			// loop on record -----------------------------------
			var rec = cf.x3GetRecord(_);
			while (rec) {

				tracer.debug && tracer.debug("DELETE:" + dqry);
				tracer.debug && tracer.debug("Constants: " + [this.values["ROWID"]]);

				const rs = this.superv.executeSql(_, dqry, [this.values["ROWID"]]);
				nrecord += 1;
				rec = cf.x3GetRecord(_);
			}
			this.values = row_save;
			return nrecord;
		} else {
			// classie delete
			if (this.master) throw new X3Error(26, "Table can't be a link");
			const abbrevs = [this.abbrev];
			var constants: string[] = [];

			const whereSqls: string[] = [];
			const wheres = (wkey || []).concat(this.where, this.filter.where, dwhere);

			wheres.filter(_identity).forEach(w => {
				w.sql && whereSqls.push(w.sql);
				constants = constants.concat(w.constants || []);
			});
			const whereSql = whereSqls.length ? " WHERE " + whereSqls.join(' AND ') : '';

			var currtag = 0;
			var sql = ("Delete " + this.desc.name + whereSql).replace(/@\?/g, val => this.driver.param(currtag++));;
			sql = sql.replace(new RegExp(this.abbrev + "\\.", "g"), "");

			tracer.debug && tracer.debug("DELETE:" + sql);
			tracer.debug && tracer.debug("Constants: " + constants);

			try {
				const result = this.superv.executeSql(_, sql, constants);
				return result.updateCount;
			} catch (e) {
				if (this.driver.isLocked(e)) return -1;
				else throw e;
			}
		}
	}

	x3Update(_: _, fwhere: ContextFn<WKey[]>, asssql: string, consts: string[]) {
		const ctx: types.QueryContext = {};
		ctx.tables = [this.abbrev];
		ctx.noabbrev = true;
		const dwhere = fwhere && fwhere(_, ctx);
		if (dwhere && _isPostEvaluated(dwhere) || this.where && _isPostEvaluated(this.where) || this.filter.where && _isPostEvaluated(this.filter.where)) {

			// need to build a query ------------------------------
			var nrecord = 0;
			// BRJOU: changed lock to false
			const qry = _buildQuery(_, "for", this, undefined, undefined, fwhere, undefined, undefined, false, null);
			const q = qry[0];

			var currtag = 0;
			const dqry = ("Update " + this.desc.name + " Set " + asssql + " Where ROWID = @?").replace(/@\?/g, val => this.driver.param(currtag++));
			const row_save = this.values;
			// execution ---------------------------------------			
			const rdr = this.driver.reader(_, q.sql, q.constants, q.sqlOpts);
			const cf = new DBCursor(rdr, q.tables, q.maptrim, q.pwhere, undefined, 0, "for", q.columns);

			// loop on record -----------------------------------
			var rec = cf.x3GetRecord(_);
			while (rec) {

				tracer.debug && tracer.debug("UPDATE:" + dqry);
				tracer.debug && tracer.debug("Constants: " + consts.concat([this.values["ROWID"]]));

				const rs = this.superv.executeSql(_, dqry, consts.concat([this.values["ROWID"]]));
				nrecord += 1;
				rec = cf.x3GetRecord(_);
			}
			this.values = row_save;
			return nrecord;
		} else {
			if (this.master) throw new X3Error(26, "Table can't be a link");
			const abbrevs = [this.abbrev];
			var constants: string[] = [];

			const whereSqls: string[] = [];
			const wheres = [].concat(this.where, this.filter.where, dwhere);

			wheres.filter(_identity).forEach(w => {
				w.sql && whereSqls.push(w.sql);
				constants = constants.concat(w.constants || []);
			});
			const whereSql = whereSqls.length ? " WHERE " + whereSqls.join(' AND ') : '';
			constants = consts.concat(constants);

			var currtag = 0;
			var sql = ("Update " + this.desc.name + " Set " + asssql + whereSql).replace(/@\?/g, val => this.driver.param(currtag++));;
			sql = sql.replace(new RegExp(this.abbrev + "\\.", "g"), "");

			tracer.debug && tracer.debug("UPDATE:" + sql);
			tracer.debug && tracer.debug("Constants: " + constants);

			try {
				const result = this.superv.executeSql(_, sql, constants);
				return result.updateCount;
			} catch (e) {
				if (this.driver.isUniqueViolated(e)) return -3;
				else if (this.driver.isLocked(e)) return -1;
				else throw e;
			}
		}
	}
	x3Rowcount(_: _) {
		const master = this.master || this;
		var loop = false;
		if (this.where && _isPostEvaluated(this.where) || this.filter.where && _isPostEvaluated(this.filter.where)) loop = true;
		if (!loop && this.master && (this.master.where && _isPostEvaluated(this.master.where) || this.master.filter.where && _isPostEvaluated(this.master.filter.where))) loop = true;

		if (loop) {
			const qry = _buildQuery(_, "for", this, undefined, undefined, undefined, undefined, undefined, false, null);
			const q = qry[0];
			// execution ---------------------------------------			
			const row_save = this.values;
			var nrecord = 0;
			const rdr = this.driver.reader(_, q.sql, q.constants, q.sqlOpts);
			const cf = new DBCursor(rdr, q.tables, q.maptrim, q.pwhere, undefined, 0, "for", undefined);

			// loop on record -----------------------------------
			var rec = cf.x3GetRecord(_);
			while (rec) {
				nrecord += 1;
				rec = cf.x3GetRecord(_);
			}
			this.values = row_save;
			return nrecord;
		} else {
			const qry = _buildQuery(_, "rowcount", this, undefined, undefined, undefined, undefined);
			const q = qry[0];
			q.sqlOpts.typesmap = q.typesmap;
			q.sqlOpts.dispatch = true;
			const result = this.superv.executeSql(_, q.sql, q.constants, q.sqlOpts);
			return result[0]["A"].RESULT;
		}
	}

	// misc ----------------------------------------------------
	// ---------------------------------------------------------
	x3SetNewKey(_: _, newkey: KeyExpression) {
		if (newkey.sql) {
			this.keys.forEach(ky => {
				ky.hidden = true;
			});

			newkey.kslot = this.keys.push(newkey) - 1;
			this.currkey = newkey.kslot;
			this.currlen = newkey.items.length;
			delete newkey.modified;
		} else {
			const mk = this.findKey(newkey.name);

			this.keys.forEach(ky => {
				ky.hidden = true;
			});

			if (newkey.modified) {
				newkey = _transformKey(mk, newkey.modified);
				newkey.kslot = this.keys.push(newkey) - 1;
				this.currkey = newkey.kslot;
				this.currlen = newkey.items.length;
			} else {
				mk.hidden = false;
				this.currkey = mk.kslot;
				this.currlen = mk.items.length;
			}
		}
	}
	x3CloseFor() {
		const master = this.master || this;
		master.currentFor = undefined;
	}
	x3GetCurrentFor() {
		const master = this.master || this;
		return master.currentFor;
	}
	findIndex(name: string) {
		const index = this.desc.index(name);
		if (!index) throw new X3Error(21, "bad index: " + name);
		return index;
	}
	findKey(name: string): KeyExpression {
		if (name === "reckey") return _reckey;

		if (!name) return this.keys[this.currkey];

		const k = this.keys.filter(k => k.name === name && k.hidden === false);
		if (!k[0]) throw new X3Error(21, "bad key: " + name);
		return k[0];
	}
	keyCompare(_: _, k: KeyExpression, values: any[]) {
		var cmp = 0,
		    lvl = 0;

		while (cmp === 0 && values[lvl] !== undefined) {
			cmp = values[lvl].x3Compare(k.func[lvl](_)) * k.directions[lvl];
			lvl++;
		}
		return cmp;
	}
	getKeyValues(_: _, k: KeyExpression, lvl: number) {
		const res: any[] = [];
		for (var i = 0; i < lvl; i++) {
			res.push(k.func[i] && k.func[i](_));
		}
		return res;
	}
	setCurrentLogin(login: string) {
		this.defaultLogin = login;
	}
	getName() {
		const master = this.master || this;

		return master.desc.name;
	}
	getAbbrev() {
		return this.abbrev;
	}
}