import * as runtime from './runtime/index';
import * as tbcd from './runtime/tbcd';
import * as bcd from './runtime/bcd';
import { BCD } from './runtime/tbcd';
import { types } from 'syracuse-core';
const date = types.date;
const time = types.time;
const datetime = types.datetime;

function any(x: any) { return x; }

function eq(a: any, b: any) {
	if (a == null) return b == null;
	if (b == null) return false;
	if (a.x3Compare) return a.x3Compare(b) === 0;
	if (b.x3Compare) return b.x3Compare(a) === 0;
	return a === b;
}

function compare(a: any, b: any) {
	if (a == null || b == null) throw new Error("cannot compare " + a + " and " + b);
	if (a.x3Compare) return a.x3Compare(b);
	if (b.x3Compare) return -b.x3Compare(a);
	throw new Error("cannot compare " + typeof a + " and " + typeof b);
}

function classify(x: any) {
	if (x == null) return "null";
	else if (typeof x !== "object") return typeof x;
	else if (x instanceof BCD) return "decimal";
	else if (date.isDate(x)) return "date";
	//else if (time.isTime(x)) return "time";
	else if (datetime.isDatetime(x)) return "datetime";
	else if (Array.isArray(x)) return "array";
	else return "object";
}

function badOperand(x: any, expected: string) {
	return new Error("bad operand: expected " + expected + ", got " + classify(x));
}

function notZero(x: any) {
	if (x === 0) throw new Error("division by zero");
	return x;
}

function notBcdZero(x: any) {
	if (bcd.isZero(x.value)) throw new Error("division by zero");
	return x.value;
}

module.exports = {
	bcd: (s: string) => tbcd.fromString(s),
	add(a: any, b: any) {
		if (typeof a === 'number') {
			if (typeof b === 'number') return a + b;
			else if (b instanceof BCD) return new BCD(bcd.add(bcd.fromDouble(a), b.value));
			else throw badOperand(b, 'numeric');
		} else if (a instanceof BCD) {
			if (typeof b === 'number') return new BCD(bcd.add(a.value, bcd.fromDouble(b)));
			else if (b instanceof BCD) return new BCD(bcd.add(a.value, b.value));
			else throw badOperand(b, 'numeric');
		} else if (typeof a === 'string') {
			return a + (b == null ? b : b.toString());
		} else if (date.isDate(a)) {
			if (b === any(b | 0)) return a.addDays(b);
			else throw badOperand(b, 'integer');
		} else {
			throw badOperand(a, 'numeric, string or date');
		}
	},
	sub(a: any, b: any) {
		if (typeof a === 'number') {
			if (typeof b === 'number') return a - b;
			else if (b instanceof BCD) return new BCD(bcd.sub(bcd.fromDouble(a), b.value));
			else throw badOperand(b, 'numeric');
		} else if (a instanceof BCD) {
			if (typeof b === 'number') return new BCD(bcd.sub(a.value, bcd.fromDouble(b)));
			else if (b instanceof BCD) return new BCD(bcd.sub(a.value, b.value));
			else throw badOperand(b, 'numeric');
		} else if (date.isDate(a)) {
			if (b === any(b | 0)) return a.addDays(-b);
			else if (date.isDate(b)) return a.daysDiff(b);
			else throw badOperand(b, 'integer or date');
		} else {
			throw badOperand(a, 'numeric or date');
		}
	},
	mul(a: any, b: any): any {
		if (typeof a === 'number') {
			if (typeof b === 'number') return a * b;
			else if (b instanceof BCD) return new BCD(bcd.multiply(bcd.fromDouble(a), b.value));
			else throw badOperand(b, 'numeric');
		} else if (a instanceof BCD) {
			if (typeof b === 'number') return new BCD(bcd.multiply(a.value, bcd.fromDouble(b)));
			else if (b instanceof BCD) return new BCD(bcd.multiply(a.value, b.value));
			else throw badOperand(b, 'numeric');
		} else {
			throw badOperand(a, 'numeric');
		}
	},
	div(a: any, b: any): any {
		if (typeof a === 'number') {
			if (typeof b === 'number') return a / notZero(b);
			else if (b instanceof BCD) return new BCD(bcd.divide(bcd.fromDouble(a), notBcdZero(b)));
			else throw badOperand(b, 'numeric');
		} else if (a instanceof BCD) {
			if (typeof b === 'number') return new BCD(bcd.divide(a.value, bcd.fromDouble(notZero(b))));
			else if (b instanceof BCD) return new BCD(bcd.divide(a.value, notBcdZero(b)));
			else throw badOperand(b, 'numeric');
		} else {
			throw badOperand(a, 'numeric');
		}
	},
	plus(a: any) {
		if (typeof a === 'number') return a;
		else if (a instanceof BCD) return a;
		else throw badOperand(a, 'numeric');
	},
	minus(a: any): any {
		if (typeof a === 'number') return -a;
		else if (a instanceof BCD) return new BCD(bcd.minus(a.value));
		else throw badOperand(a, 'numeric');
	},
	eq: eq,
	ne: (a: any, b: any) => !eq(a, b),
	lt: (a: any, b: any) => compare(a, b) < 0,
	le: (a: any, b: any) => compare(a, b) <= 0,
	gt: (a: any, b: any) => compare(a, b) > 0,
	ge: (a: any, b: any) => compare(a, b) >= 0
};