"use strict";

import { Parser, ParseNode } from '../engine/parser';
import * as dates from '../engine/runtime/dates';
import * as tdate from '../engine/runtime/tdate';


export function generate(tabcor: { [name: string]: string; }, node: ParseNode) {
	//console.log("jmqlgen:" + JSON.stringify(node));

	const VALUES = ["STRING"];
	const eqValue = function (ident: string, fct: (filter: any) => any) {
		return function (filter: any) {
			filter = filter || {};
			var op1 = fct(filter);
			if (op1 instanceof Date) {
				if (op1.toString() === tdate.make(0, 0, 0).toJsDate().toString()) op1 = "";
				else op1 = tdate.fromJsDate(op1).toString("yyyy-MM-dd");
			}
			filter[ident] = op1;
			return filter;
		};
	};

	const opValue = function (operator: string, ident: string, fct: (filter: any) => any) {
		return function (filter: any) {
			filter = filter || {};
			filter[ident] = filter[ident] || {};
			var op1 = fct(filter);
			if (op1 instanceof Date) {
				if (op1.toString() === tdate.make(0, 0, 0).toJsDate().toString()) op1 = "";
				else op1 = tdate.fromJsDate(op1).toString("yyyy-MM-dd");
			}
			filter[ident][operator] = op1;
			return filter;
		};
	};

	function likeValue(ident: string, value: any) {
		return function (filter: any) {
			filter = filter || {};
			filter[ident] = filter[ident] || {};
			filter[ident].$regex = value;
			filter[ident].$options = "i";
			return filter;
		};
	}

	const addOpValue = function (op: string, rop: string) {
		return function (node: ParseNode) {

			if (node.args[0].tag === 'IDENT') return opValue(op, node.args[0].value, gen(node.args[1]));
			else if (node.args[1].tag === 'IDENT') return opValue(rop, node.args[1].value, gen(node.args[0]));

			return opValue(op, gen(node.args[0])(), gen(node.args[1]));
		};
	};

	var tmp: (node: ParseNode) => any;
	const operators: { [name: string]: (node: ParseNode) => (filter: any) => any; } = {
		EQ(node) {

			if (node.args[0].tag === 'IDENT') return eqValue(node.args[0].value, gen(node.args[1]));
			else if (node.args[1].tag === 'IDENT') return eqValue(node.args[1].value, gen(node.args[0]));

			if (node.args[0].tag === 'FCALL') {
				switch (node.args[0].name) {
					case 'LEFT$':
						return likeValue(gen(node.args[0].args[0])(), node.args[1].value + ".*");
					case 'RIGHT$':
						return likeValue(gen(node.args[0].args[0].value)(), ".*" + node.args[1].value);
				}
			}
			return eqValue(gen(node.args[0])(), gen(node.args[1]));
			//if (!ident) throw error("bad expression");
		},
		NE: addOpValue("$ne", "$ne"),
		GE: addOpValue("$gte", "$lte"),
		LE: addOpValue("$lte", "$gte"),
		GT: addOpValue("$gt", "$lt"),
		LT: addOpValue("$lt", "$gt"),
		AND(node) {
			const exps = node.args.reduce((r, arg) => {
				r.push(gen(arg));
				return r;
			}, []);

			return function (filter) {
				return exps.reduce((r, exp) => {
					exp(r);
					return r;
				}, filter || {});
			};
		},
		OR(node) {
			const exps = node.args.reduce((r, arg) => {
				r.push(gen(arg));
				return r;
			}, []);

			return function (filter) {
				filter = filter || {};
				filter.$or = [];
				return exps.reduce((r, exp) => {
					r.$or.push(exp());
					return r;
				}, filter);
			};
		},
		SUB(node) {
			const lhs = gen(node.args[0]);
			const rhs = gen(node.args[1]);

			return function () {
				const l = lhs();
				const r = rhs();

				if (l instanceof Date) {
					var d = tdate.fromJsDate(l);
					d = d.x3Sub(r);
					return d.toJsDate();
				}
				return l - r;
			};
		},
		ADD(node) {
			const lhs = gen(node.args[0]);
			const rhs = gen(node.args[1]);

			return function () {
				const l = lhs();
				const r = rhs();

				if (l instanceof Date) {
					var d = tdate.fromJsDate(l);
					d = d.x3Add(r);
					return d.toJsDate();
				}
				return l + r;
			};
		},
		STRING: tmp = function (node) {
			return function () {
				return node.value;
			};
		},
		INTEGER: tmp,
		DATE$(node) {
			return function () {
				return dates.functions.DATE$.fn().toJsDate();
			};
		},
		DATE(node) {
			return function () {
				return new Date(node.year, node.month - 1, node.day); //  GO ??		 	
			};
		},
		IDENT(node) {
			return function () {
				return node.value;
			};
		},
		CLAS(node) {
			return function () {
				const res = '[' + node.letter + (node.abbrev === undefined ? ']' : ':' + node.abbrev + ']') + node.field;

				if (tabcor && tabcor[res]) {
					if (tabcor[res] === "true") return true;
					else if (tabcor[res] === "false") return false;
					else return tabcor[res].replace(/\"/g, '');
				}
				return res;
			};
		},
		PROP(node) {
			return function () {
				const lhs = gen(node.target)();
				const res = lhs + '.' + node.name;

				if (tabcor && tabcor[res]) {
					if (tabcor[res] === "true") return true;
					else if (tabcor[res] === "false") return false;
					else return tabcor[res].replace(/\"/g, '');
				}
				return res;
			};
		}
	};

	function gen(node: ParseNode): (node?: ParseNode) => any {
		const fn = node.tag === 'FCALL' ? operators[node.name] : operators[node.op] || operators[node.tag];

		if (fn) return fn(node);
	}
	return gen(node);
};

export function x3ToJmql(tabcor: { [name: string]: string; }, expression: string) {
	const parsed = new Parser("CONDITION=(" + expression + ")").parse();

	return generate(tabcor, parsed.node.statements[0].rhs);
};