"use strict";

const glob = require('streamline/lib/globals');
const util = require('etna/lib/engine/runtime/util');
const bcd = require('etna/lib/engine/runtime/tbcd');
const date = require('etna/lib/engine/runtime/tdate');
const datetime = require('etna/lib/engine/runtime/tdatetime');
const Clbfile = require('etna/lib/engine/runtime/tclbfile').Clbfile;
const Blbfile = require('etna/lib/engine/runtime/tblbfile').Blbfile;
const uuid = require('etna/lib/engine/runtime/tuuid');
const variables = require('etna/lib/engine/runtime/variables');
const X3Error = require('etna/lib/engine/runtime/errors').X3Error;

function x3sonLetter(v) {
	// Let's resolve the proper type :
	if (typeof v == "number") return "I";
	else if (typeof v == "string") return "S";
	else if (util.x3IsDate(v)) return "D";
	else if (util.x3IsDatetime(v)) return "T";
	else if (util.x3IsBCD(v)) return "N";
	else if (util.x3IsUuid(v)) return "U";
	else if (util.x3IsDouble(v)) return "W";
	else if (util.x3IsBlbfile(v)) return "B";
	else if (util.x3IsClbfile(v)) return "C";
	else if (util.x3IsInstance(v) || typeof v === 'object') return "O";
	return "";
}

function format(t, v) {
	switch (t.substring(0, 1)) {
		case "D":
			return v.x3ToJson() + ';';
		case "B":
			return v.value.toString('base64') + ';';
		case "U":
			return v.x3ToSqlString() + ';';
		default:
			return v.x3ToString() + ';';
	}
}

function len(t, v) {
	switch (t.substring(0, 1)) {
		case "S":
			return v.length + "!";
		case "B":
			return "!";
		case "C":
			return v.x3Length() + "!";
		case "O":
			return "!";
		default:
			return "";
	}
}

function fail(message) {
	throw new Error(message);
}
exports.parse = function (_, s) {

	function extractVar(c) {
		const pos = s.indexOf(c);

		if (pos < 0) fail("expected " + c);
		const sub = s.substring(0, pos);

		s = s.substring(pos + 1);
		return sub;
	}

	function extractFix(l) {
		const sub = s.substring(0, l);

		s = s.substring(l + 1);
		return sub;
	}

	function eat(c) {
		if (s[0] !== c) fail("expected " + c + " got " + s[0]);
		s = s.substring(1);
	}

	function parse_one(_) {
		const t = s.substring(0, 1);

		eat(t);

		var result;
		var v;
		if (!s) return 0;

		var isArray = false;
		if (s[0] === '[') {
			isArray = true;
			eat('[');
			result = [];
		}
		while (true) {
			switch (t) {
				case "I":
				case "V":
				case "J":
					v = parseInt(extractVar(';'));
					break;
				case "W":
					v = parseFloat(extractVar(';'));
					break;
				case "N":
					v = bcd.fromString(extractVar(';'));
					break;
				case "S":
					var len = parseInt(extractVar('!'));
					v = extractFix(len);
					break;
				case "C":
					var len = parseInt(extractVar('!'));
					v = new Clbfile(extractFix(len));
					break;
				case "B":
					eat('!');
					v = new Blbfile(new Buffer(extractVar(';'), 'base64'));
					break;
				case "D":
					v = date.parse(extractVar(';'), "yyyy-MM-dd");
					break;
				case "T":
					v = datetime.x3Parse(extractVar(';'));
					break;
				case "U":
					v = uuid.x3ToUuid(extractVar(';'));
					break;
				case "O":
					eat('!');
					var clas = extractVar('{');
					v = {};
					if (clas.length > 0) {
						//dbg:console.log("parse clas:"+clas);
						var frame = glob.context.x3frame;
						if (!/^C_/.test(clas)) throw new X3Error(33, "Invalid class name: " + clas);
						var cl = frame.context.superv.load(_, 'Class', clas.substring(2));
						if (!cl) throw new X3Error(26, "invalid class name: " + clas); // TODO check errnum
						v = cl.createInstance(_);
					}
					while (s && s[0] !== '}') {
						//dbg:console.log("parse parameters");
						var pro = extractVar(':');
						var value = parse_one(_);
						//dbg:console.log("parse pro:"+pro+" value:"+value);
						if (v.set) v.set(_, pro, value, true);
						else v[pro] = value;
					}
					if (s) {
						eat('}');
						eat(';');
					}
					break;
			}
			if (isArray) {
				result.push(v);
				if (!s || s[0] === ']') {
					eat(']');
					eat(';');
					break;
				}
			} else {
				result = v;
				break;
			}
		}
		//dbg:console.log("parse return: " +result);
		return result;
	}
	var parsed;
	try {
		//dbg:console.error("parse: " +s);
		parsed = parse_one(_);
	} catch (e) {
		console.error("X3SON.parse:" + e.message);
		console.error(e.stack);
	}
	//dbg:console.error("parsed :",parsed);
	return parsed;
};

exports.stringify = function (_, v) {
	var s = "";
	if (Array.isArray(v)) {
		if (!v.length) return "[];";
		var t = x3sonLetter(v[0]);
		s = t + "[" + v.map_(_, (_, e) => e.toX3son ? e.toX3son(_) : len(t, e) + format(t, e)).join('') + "];";
	} else if (x3sonLetter(v) === 'O') {
		if (v.toX3son) {
			//dbg:console.log("call v.toX3son");
			s = "O" + v.toX3son(_);
			//dbg:console.log("class.stringify:"+s);
		} else {
				s = "O!{" + Object.keys(v).map(k => {
					const t = x3sonLetter(v[k]);

					return k + ':' + t + len(t, v[k]) + format(t, v[k]);
				}).join('') + "};";
			}
	} else {
		var t = x3sonLetter(v);
		s = t + len(t, v) + format(t, v);
	}
	//dbg:console.error("stringify ",v,"=",s);
	return s;
};