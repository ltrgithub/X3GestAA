"use strict";
// get original node compile function before registering streamline
var nodeCompile = require('module').prototype._compile;
var config = require("etna/lib/util/nodeconfig").config;
config.streamline.fast = false;

if (config.streamline.fast && config.streamline.fibers) config.streamline.aggressive = true;
require('streamline').register(config.streamline);
var fs = require("fs");
var fsp = require("path");
var Parser = require("./parser").Parser;
var jsgen = require('./jsgen');
var version = require('./version').version;

var dirMode = parseInt('777', 8);

exports.mkdirsSync = function(path) {
	var p = "",
		i = 0;
	path.split('/').slice(0, -1).forEach(function(seg) {
		p += (i++ ? '/' : '') + seg;
		if (!(fs.existsSync || fspath.existsSync)(p)) {
			try {
				fs.mkdirSync(p, dirMode);
			} catch (err) {
				if (i > 1 && err.code !== 'EEXIST') {
					throw err;
				}
			}
		}
	});
};

exports.cachedPath = function(path, options) {
	var cacheRoot = options.cacheDir || ((process.env.HOME || (process.env.HOMEDRIVE + process.env.HOMEPATH).replace(/\\/g, '/')) + "/.etna");

	var i = path.indexOf('node_modules/');
	if (i < 0) i = path.lastIndexOf('/');
	else i += 'node_modules'.length;

	var dir = cacheRoot + '/' + path.substring(0, i).replace(/[\/\\:]/g, '__');
	dir = dir + path.substring(i, path.length - 4);
	if (options.extension) return dir + "." + options.extension;
	return dir + '.js';
};

function mtimeSync(fname) {
	try {
		return fs.statSync(fname).mtime;
	} catch (ex) {
		return 0;
	}
}

function transformSync(path, options) {
	var banner = "/* Generated by etna " + version + " -- DO NOT EDIT */";
	var transformed;
	path = path.replace(/\\/g, '/');

	var cpath = exports.cachedPath(path, options);
	exports.mkdirsSync(cpath);
	if (!options.force) {
		if (mtimeSync(cpath) > mtimeSync(path)) {
			transformed = fs.readFileSync(cpath, "utf8");
			if (transformed.substring(0, banner.length) === banner) return transformed;
		}
	}
	// no luck in cache
	if (options.verbose) console.log("etna: transforming: " + path);

	var source = fs.readFileSync(path, 'utf8');
	var parsed = new Parser(source, path).parse();
	transformed = banner + jsgen.generate(parsed.node, path);
	fs.writeFileSync(cpath, transformed, "utf8");
	return transformed;
}

exports.options = {
	verbose: true,
	force: false, // for now
};

require.extensions['.src'] = function(module, filename) {
	var transformed = transformSync(filename, exports.options);
	nodeCompile.call(module, transformed, filename);
};

function registerX3js() {
	if (/^v0\.1/.test(process.version)) {
		console.error("node 0.12 is supported in degraded mode - skipping X3JS registration");
		return;
	}
	// hack Module._nodeModulePaths so that x3js scripts can find etna runtime modules.
	var Module = require('module');
	var original = Module._nodeModulePaths;
	Module._nodeModulePaths = function() {
		var paths = original.apply(this, arguments);
		paths.push(fsp.join(__dirname, '../../../../node_modules'));
		// also include shadow-modules/node_modules to get streamline-runtime
		paths.push(fsp.join(__dirname, '../../../../shadow-modules/node_modules'));
		return paths;
	}	

	var babelOptions = {
		plugins: [
			require("babel-plugin-flow-comments"), 
			require("babel-plugin-x3js"),
			[require("babel-plugin-streamline"), {
				runtime: 'fibers',
				forceTransform: true, // because of different extension
				verbose: true,		
			}],
			require("babel-plugin-transform-es2015-modules-commonjs"),
			require("babel-plugin-transform-strict-mode")],
		//presets: [require("babel-preset-es2015")],
		compact: false,
		sourceMaps: true,
	};
	// reuse streamline cache
	var cache = require('streamline/lib/cacheSync');
	require.extensions['.x3js'] = function(module, filename) {
		var transformed = cache.get(filename, {
			cache: true,
			sourceMaps: true,
			// include x3js plugin version into cache dir root
			runtime: 'x3js-' + require("babel-plugin-x3js/package").version,
		}, function() {
			babelOptions.filename = filename;
			babelOptions.sourceFileName = filename;
			var source = fs.readFileSync(filename, 'utf8');
			var transformed =  require('babel-core').transform(source, babelOptions);
			return {
				code: transformed.code + '\n//# sourceMappingURL=' + fsp.basename(filename, '.x3js') +'.map',
				map: transformed.map,
			}
		});
		nodeCompile.call(module, transformed.code, filename);
	}

	// fix QUnit
	if (typeof QUnit !== 'undefined') {
		const equals = QUnit.equals;
		const date = require('syracuse-core').types.date; 
		const datetime = require('syracuse-core').types.datetime; 
		const tbcd = require('./runtime/tbcd');
		global.equals = global.equal = QUnit.equals = QUnit.equal = function(x, y, message) {
			if (date.isDate(x) && date.isDate(y) && x.x3Compare(y) === 0) y = x;
			if (datetime.isDatetime(x) && datetime.isDatetime(y) && x.x3Compare(y) === 0) y = x;
			if (x instanceof tbcd.BCD && y instanceof tbcd.BCD && x.x3Compare(y) === 0) y = x;
			equals(x, y, message);
		}
	}
}

registerX3js();
