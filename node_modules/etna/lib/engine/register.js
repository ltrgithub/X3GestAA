"use strict";
// get original node compile function before registering streamline

const nodeCompile = require('module').prototype._compile;
const config = require("etna/lib/util/nodeconfig").config;

config.streamline.fast = false;

if (config.streamline.fast && config.streamline.fibers) config.streamline.aggressive = true;
require('streamline').register(config.streamline);

const fs = require("fs");
const fsp = require("path");
const Parser = require("./parser").Parser;
const jsgen = require('./jsgen');
const version = require('./version').version;
const dirMode = parseInt('777', 8);

exports.mkdirsSync = function (path) {
	var p = "",
	    i = 0;
	path.split('/').slice(0, -1).forEach(seg => {
		p += (i++ ? '/' : '') + seg;
		if (!(fs.existsSync || fspath.existsSync)(p)) {
			try {
				fs.mkdirSync(p, dirMode);
			} catch (err) {
				if (i > 1 && err.code !== 'EEXIST') {
					throw err;
				}
			}
		}
	});
};

exports.cachedPath = function (path, options) {
	const cacheRoot = options.cacheDir || (process.env.HOME || (process.env.HOMEDRIVE + process.env.HOMEPATH).replace(/\\/g, '/')) + "/.etna";

	var i = path.indexOf('node_modules/');
	if (i < 0) i = path.lastIndexOf('/');
	else i += 'node_modules'.length;

	var dir = cacheRoot + '/' + path.substring(0, i).replace(/[\/\\:]/g, '__');
	dir = dir + path.substring(i, path.length - 4);
	if (options.extension) return dir + "." + options.extension;
	return dir + '.js';
};

function mtimeSync(fname) {
	try {
		return fs.statSync(fname).mtime;
	} catch (ex) {
		return 0;
	}
}

function transformSync(path, options) {
	const banner = "/* Generated by etna " + version + " -- DO NOT EDIT */";

	var transformed;
	path = path.replace(/\\/g, '/');

	const cpath = exports.cachedPath(path, options);

	exports.mkdirsSync(cpath);
	if (!options.force) {
		if (mtimeSync(cpath) > mtimeSync(path)) {
			transformed = fs.readFileSync(cpath, "utf8");
			if (transformed.substring(0, banner.length) === banner) return transformed;
		}
	}
	// no luck in cache
	if (options.verbose) console.log("etna: transforming: " + path);

	const source = fs.readFileSync(path, 'utf8');
	const parsed = new Parser(source, path).parse();

	transformed = banner + jsgen.generate(parsed.node, path);
	fs.writeFileSync(cpath, transformed, "utf8");
	return transformed;
}

exports.options = {
	verbose: true,
	force: false };

// for now
require.extensions['.src'] = function (module, filename) {
	const transformed = transformSync(filename, exports.options);

	nodeCompile.call(module, transformed, filename);
};

function registerX3js() {
	if (/^v0\.1/.test(process.version)) {
		console.error("node 0.12 is supported in degraded mode - skipping X3JS registration");
		return;
	}
	// hack Module._nodeModulePaths so that x3js scripts can find etna runtime modules.

	const Module = require('module');
	const original = Module._nodeModulePaths;
	var shadowRoot = fsp.join(fsp.dirname(require.resolve('streamline-runtime/package.json')), '..');


	Module._nodeModulePaths = function () {
		const paths = original.apply(this, arguments);

		paths.push(fsp.join(__dirname, '../../../../node_modules'));
		// also include shadow-modules/node_modules to get streamline-runtime
		paths.push(shadowRoot);
		return paths;
	};

	const babelOptions = {
		plugins: [require("babel-plugin-flow-comments"), require("babel-plugin-x3js"), [require("babel-plugin-streamline"), {
			runtime: 'fibers',
			forceTransform: true, // because of different extension
			verbose: true
		}], require("babel-plugin-transform-es2015-modules-commonjs"), require("babel-plugin-transform-strict-mode")],
		compact: false,
		sourceMaps: true
	};
	// reuse streamline cache

	const cache = require('streamline/lib/cacheSync');

	require.extensions['.x3js'] = function (module, filename) {
		const transformed = cache.get(filename, {
			cache: true,
			sourceMaps: true,
			// include x3js plugin version into cache dir root
			runtime: 'x3js-' + require("babel-plugin-x3js/package").version
		}, () => {
			babelOptions.filename = filename;
			babelOptions.sourceFileName = filename;
			const source = fs.readFileSync(filename, 'utf8');
			const transformed = require('babel-core').transform(source, babelOptions);

			return {
				code: transformed.code + '\n//# sourceMappingURL=' + fsp.basename(filename, '.x3js') + '.map',
				map: transformed.map
			};
		});

		nodeCompile.call(module, transformed.code, filename);
	};

	// fix QUnit
	if (typeof QUnit !== 'undefined') {
		const equals = QUnit.equals;
		const date = require('syracuse-core').types.date;
		const datetime = require('syracuse-core').types.datetime;
		const tbcd = require('./runtime/tbcd');
		global.equals = global.equal = QUnit.equals = QUnit.equal = function (x, y, message) {
			if (date.isDate(x) && date.isDate(y) && x.x3Compare(y) === 0) y = x;
			if (datetime.isDatetime(x) && datetime.isDatetime(y) && x.x3Compare(y) === 0) y = x;
			if (x instanceof tbcd.BCD && y instanceof tbcd.BCD && x.x3Compare(y) === 0) y = x;
			equals(x, y, message);
		};
		global.throws = QUnit.throws = function (fn, expect, message) {
			try {
				const result = fn();
				ok(false, `returned ${ result } instead of throwing: ${ message }`);
			} catch (ex) {
				ok(expect.test(ex.message), `exception: ${ ex.message }`);
			}
		};
		global.asyncThrows = QUnit.asyncThrows = function (cb, fn, expect, message) {
			fn((err, result) => {
				QUnit.throws(() => {
					if (err) throw err;
					else return result;
				}, expect, message);
				cb();
			});
		};
	}
}

registerX3js();