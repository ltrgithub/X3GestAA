"use strict";
// get original node compile function before registering streamline
var nodeCompile = require('module').prototype._compile;
var config = require("etna/lib/util/nodeconfig").config;
config.streamline.fast = false;

if (config.streamline.fast && config.streamline.fibers) config.streamline.aggressive = true;
require('streamline').register(config.streamline);
var fs = require("fs");
var fsp = require("path");
var Parser = require("./parser").Parser;
var jsgen = require('./jsgen');
var version = require('./version').version;

var dirMode = parseInt('777', 8);

exports.mkdirsSync = function(path) {
	var p = "",
		i = 0;
	path.split('/').slice(0, -1).forEach(function(seg) {
		p += (i++ ? '/' : '') + seg;
		if (!(fs.existsSync || fspath.existsSync)(p)) {
			try {
				fs.mkdirSync(p, dirMode);
			} catch (err) {
				if (i > 1 && err.code !== 'EEXIST') {
					throw err;
				}
			}
		}
	});
};

exports.cachedPath = function(path, options) {
	var cacheRoot = options.cacheDir || ((process.env.HOME || (process.env.HOMEDRIVE + process.env.HOMEPATH).replace(/\\/g, '/')) + "/.etna");

	var i = path.indexOf('node_modules/');
	if (i < 0) i = path.lastIndexOf('/');
	else i += 'node_modules'.length;

	var dir = cacheRoot + '/' + path.substring(0, i).replace(/[\/\\:]/g, '__');
	dir = dir + path.substring(i, path.length - 4);
	if (options.extension) return dir + "." + options.extension;
	return dir + '.js';
};

function mtimeSync(fname) {
	try {
		return fs.statSync(fname).mtime;
	} catch (ex) {
		return 0;
	}
}

function transformSync(path, options) {
	var banner = "/* Generated by etna " + version + " -- DO NOT EDIT */";
	var transformed;
	path = path.replace(/\\/g, '/');

	var cpath = exports.cachedPath(path, options);
	exports.mkdirsSync(cpath);
	if (!options.force) {
		if (mtimeSync(cpath) > mtimeSync(path)) {
			transformed = fs.readFileSync(cpath, "utf8");
			if (transformed.substring(0, banner.length) === banner) return transformed;
		}
	}
	// no luck in cache
	if (options.verbose) console.log("etna: transforming: " + path);

	var source = fs.readFileSync(path, 'utf8');
	var parsed = new Parser(source, path).parse();
	transformed = banner + jsgen.generate(parsed.node, path);
	fs.writeFileSync(cpath, transformed, "utf8");
	return transformed;
}

exports.options = {
	verbose: true,
	force: false, // for now
};

require.extensions['.src'] = function(module, filename) {
	var transformed = transformSync(filename, exports.options);
	nodeCompile.call(module, transformed, filename);
};

function registerX3js() {
	// hack Module._nodeModulePaths so that x3js scripts can find etna runtime modules.
	var Module = require('module');
	var original = Module._nodeModulePaths;
	Module._nodeModulePaths = function() {
		var paths = original.apply(this, arguments);
		paths.push(fsp.join(__dirname, '../../../../node_modules'));
		return paths;
	}	

	var babelOptions = {
		plugins: [
			require("babel-plugin-flow-comments"), 
			require("babel-plugin-x3js"),
			[require("babel-plugin-streamline"), {
				runtime: 'fibers',
				forceTransform: true, // because of different extension
				verbose: true,		
			}],
			require("babel-plugin-transform-strict-mode")],
		//presets: [require("babel-preset-es2015")],
		compact: false,
		sourceMaps: true,
	};
	// reuse streamline cache
	var cache = require('streamline/lib/cacheSync');
	require.extensions['.x3js'] = function(module, filename) {
		var transformed = cache.get(filename, {
			cache: true,
			sourceMaps: true,
			// include x3js plugin version into cache dir root
			runtime: 'x3js-' + require("babel-plugin-x3js/package").version,
		}, function() {
			babelOptions.filename = filename;
			babelOptions.sourceFileName = filename;
			var source = fs.readFileSync(filename, 'utf8');
			var transformed =  require('babel-core').transform(source, babelOptions);
			return {
				code: transformed.code + '\n//# sourceMappingURL=' + fsp.basename(filename, '.x3js') +'.map',
				map: transformed.map,
			}
		});
		nodeCompile.call(module, transformed.code, filename);
	}
}

registerX3js();
