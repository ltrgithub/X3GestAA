"use strict";
const camelCache = {}
const x3jsUtil = require('./util');
const etnaType2TypTyp = require('etna/lib/supervisor/meta/type').etnaType2TypTyp;
const instanceProxy = require('./instanceProxy');

function camelify(name) {
	return camelCache[name] || (camelCache[name] = name.split('_').map(function(s, i) {
		return i === 0 ? s.toLowerCase() : s[0] + s.substring(1).toLowerCase();
	}).join(''));
}


function eventName(str) {
	return /^ADD/.test(str) ? 'ADD_' + str.substring(3) : str.substring(1);
}

function labelValue(label, args) {
	switch (label) {
		case 'properties': return camelify(args.ARULE.value);
		case 'events': return camelify(eventName(args.AEVENT.value));
		case 'operations': return camelify(args.AOPERATION.value);
		case 'methods': return camelify(args.AMETHOD.value);
		default: throw new Error("bad label: " + label);
	}
}

function notFound(label, name) {
	if (/^(properties|events)$/.test(label)) return 0;
	throw new Error(label + " not found: name=" + name);
}

module.exports = function(_, mod, label, args) {
	if (!mod.body || !mod.body.default) throw new Error("invalid script, no default export");
	const fns = mod.body.default[label];
	if (!fns) return notFound(label);
	var member = mod.body.default;
	while (args.path.length > 1) {
		const name = args.path.shift();
		member = member.relations[name];
		if (!member) return notFound(label, name);
	};
	member = member[label];
	if (!member) return notFound(label);
	if (args.path.length === 1) member = member[args.path[0]];
	if (!member) return notFound(label, args.path[0]);
	var action = labelValue(label, args);
	const fn = member[action];
	if (!fn) return notFound(label, action);
	const proxy = instanceProxy.create(args.THIS.value);
	//console.error("INVOKEJS", label, args.path, action);
	const arg1 = args.path.length > 0
		? args.path.reduce_(_, (_, r, p) => r && r[p].get(_), proxy) 
		: undefined;
	try {
		const jsKeys = Object.keys(args).filter(k => args[k].isParam);
		const jsArgs = jsKeys.map(k => {
			const arg = args[k];
			return x3jsUtil.toJs(arg.value, {
				type: {
					data: {
						TYPTYP: arg.typ,
						// TODO: set NOLIB when arg.typ === 1, for boolean
					}
				}
			});
		});
		var result;
		if (jsArgs.length === 0) {
			result = fn.call(proxy, _, arg1);
		} else {
			var result = fn.apply_(_, proxy, jsArgs, 0);
			if (!Array.isArray(result)) result = [result];
			jsKeys.forEach_(_, (_, k) => {
				if (args[k].set && result.length > 0) args[k].value = result.shift(); 
			});
			if (result.length > 1) throw new Error("function " + label + " returns too many results");
			result = result[0];
		}
		if (args.ARET_VALUE && result !== undefined) {
			const typ = etnaType2TypTyp[args.ARET_VALUE.type[1]];
			if (typ == null) throw new Error("bad type: " +  args.ARET_VALUE.type);
			args.ARET_VALUE.value = x3jsUtil.fromJs(result, {
				type: {
					data: {
						TYPTYP: typ,
					}
				}
			});
			return undefined;
		} else {
			// ??
			return result;
		}
	} catch (ex) {
		console.error("JSINVOKE FAILED1", ex);
		console.error("JSINVOKE FAILED", ex.stack);
		return 4;
	}
}

