"use strict";
/// !doc
/// [x3js dev guide](x3js-development-guide) > [x3js APIs](x3js-apis) > x3js class manager
/// 
/// # x3js class manager
/// 
/// Every X3 application folder has a class manager, which give access to the folder's classes.
///
/// The class manager is usually obtained from an existing instance, as `instance.$classes`.
/// 
/// The classes themselves can be obtained with:
/// 
/// ```javascript
///  const MyClass = instance.$classes.MyClass$;
/// ```
/// where _MyClass_ is the name of a class. For example: `const Bank = instance.$classes.Bank$`.
/// 
/// Once you have a handle to a class, you can use it to create instances of the class, query the class, etc., 
/// with the API described below.
/// 
/// Note: you should never store a reference to a class in a global script variable because classes are specific to 
/// a folder. You should always retrieve classes via the `$classes` property of another object.

require('harmony-reflect'); // to get ES6 Proxy API
const instanceProxy = require('./instanceProxy');
const ClassQuery = require('./classQuery').ClassQuery;
var glob = require('streamline-runtime').globals;
const ACTXCACHE = require('etna/lib/supervisor/builtins/ACTXCACHE');
const constants = require('etna/lib/supervisor/constants');

const util = require('../supervisor/util');
const x3jsUtil = require('./util');

function resolveKey(clas, key) {
	if (typeof key !== 'object') key = [key];
	if (Array.isArray(key)) {
		if (clas.tableIndex == null) throw new Error("cannot read, class is not persistent: " + clas.jsName);
		return key.reduce((r, v, i) => {
			if (i >= clas.tableIndex.columns.length) throw new Error("too many values in key: " + key.length);
			const col = clas.tableIndex.columns[i];
			r[col.name] = x3jsUtil.fromJs(v, col);
			return r;
		}, {});
	} else {
		throw new Error("NIY: key passed as object");
	}
}

class ClassWrapper {
	constructor(supervisor, name) {
		this.supervisor = supervisor;
		this.name = name;
	}
	handle(_) {
		if (this._handle) return this._handle;
		this._handle = this.supervisor.loadClassByJsName(_, this.name);
		if (!this._handle) throw new Error("class not found: " + this.name);
		// load scripts
		this._handle.scripts(_);
		return this._handle;
	}
	/// 
	/// #### Creating an instance
	/// 
	/// * `MyClass.create(_, values = {})`: returns a new instance of `MyClass`.  
	///   `values` provides initial values for the properties of the new instance.
	create(_, values) {
		const clas = this.handle(_);
		const instance = clas.supervisor.new(_, 'Instance', clas).afterCreate(_);
		instance.$astalin = constants.CST_ANEW;
		const proxy = instanceProxy.create(instance);
		if (values) Object.keys(values).forEach_(_, (_, name) => {
			const member = proxy[name];
			if (!member) throw new Error("invalid class member: " + clas.jsName + '.' + name);
			member.set(_, values[name]);
		});
		return proxy;
	}
	/// 
	/// #### Query and read
	/// 
	/// * `MyClass.query()`:  creates a query on `MyClass`.  
	///   See the [class query API](x3js-class-query) for details on the query object returned by this call.
	query(_) {
		const clas = this.handle(_);
		//if (arguments.length > 0) throw new Error("query: bad arg count");
		return new ClassQuery(clas);
	}
	/// * `MyClass.read(_, key)`:  reads an instance of `MyClass`, given a key value.  
	/// `key` may be:
	///   * a single value (simple primary key)
	///   * an array (composite primary key)
	///   * a JS object which will give the column names and their values.
	read(_, key) {
		const clas = this.handle(_);
		return instanceProxy.create(clas.readInstance(_, null, resolveKey(clas, key)));
	}
	/// * `MyClass.cache(_, key)`:  reads an instance of `MyClass` from the folder's cache.  
	///   Similar to `MyClass.read` but going through the folder's cache.  
	///   `key`  must be the primary key value.  
	///   Throws if key value does not match any record.  
	///   Only classes that are marked as cacheable in the dictionary can be read with this call.
	cache(_, key) {
		const clas = this.handle(_);
		const acache = glob.context.x3session.actx.get(_, 'ACACHE');
		const cl = acache.get(_, clas.name);
		const instance = ACTXCACHE.getInstance(_, cl, Array.isArray(key) ? key.join('~') : key);
		if (!instance) throw new Error("cached lookup failed: " + clas.jsName + '/' + key);
		return instanceProxy.create(instance);
	}
}

// internal - don't document
class ClassesHandler {
	constructor(supervisor) {
		this.supervisor = supervisor;
		this.getters = {};
	}
	get(name) {
		return this.getters[name] || new ClassWrapper(this.supervisor, name);
	}
}

// internal - don't document
exports.create = function(supervisor) {
	return new Proxy(supervisor, {
		get: function(supervisor, name) {
			//console.error("PROXY GET", name);
			supervisor.classesHandler = supervisor.classesHandler || new ClassesHandler(supervisor);
			return supervisor.classesHandler.get(name);
		},
	});
}
