/// !doc
/// [x3js dev guide](x3js-development-guide) > [x3js APIs](x3js-apis) > x3js table manager
///
/// # x3js table manager
///
/// Table artifacts are obtained with:
///
/// ```javascript
///  const MYTABLE = x3js.table('myModule.MYTABLE');
/// ```
/// where _MYTABLE_ is the name of a table. For example:
///
/// ```javascript
/// const TABCOUNTRY = x3js.table('system.TABCOUNTRY');
/// ```
///
/// By convention, table variables are in UPPERCASE and match the names of the SQL tables.
///
/// Once you have a handle to a table, you can use it to perform SQL operations on the table
/// with the API described below.

require('harmony-reflect'); // to get ES6 Proxy API
import { _ } from 'streamline-runtime';
import * as ez from 'ez-streams';
import { Record } from '../engine/drivers/types';
const glob = require('streamline-runtime').globals;
const datetime = require('syracuse-core').types.datetime;
import { Column } from '../supervisor/meta/types';
import { Table } from '../supervisor/meta/types';
import { TableQuery } from './table-query';
import * as x3jsUtil from '../x3js/util';

type Dict<T> = { [name: string]: T; };

const any = (x: any) => x; 

class ColumnWrapper {
	column: Column;
	
	constructor(column: Column) {
		this.column = column;
	}
	get name() {
		return this.column.name;
	}
}

export interface TableDef {
	name: string;
}

export interface TableReadOptions {
	notFound?: any;
}

class TableHandler {
	_path: string;
	_handle: Table;
	constructor(path: string) {
		this._path = path;
		this._handle = null;
	}

	table(_: _) {
		if (this._handle) return this._handle;
		const supervisor = glob.context.x3session.supervisor;
		if (!supervisor) throw new Error("internal error: no supervisor");
		if (this._handle) {
			if (this._handle.supervisor !== supervisor) throw new Error("internal error: supervisor mismatch");
			return this._handle;
		}

		const segs = this._path.split('.');
		if (segs.length !== 2) throw new Error(`invalid table path syntax: ${ this._path }`);
		this._handle = supervisor.load(_, 'Table', segs[1]);
		if (!this._handle) throw new Error(`table not found: ${ this._path }`);
		return this._handle;
	}
	///
	/// #### Query and read
	///
	/// * `MYTABLE.query(_, alias = '')`: creates a query on the table. 
	///    See the [table query API](x3js-table-query) for details on the query object returned by this call.
	query(_: _,  alias: string) {
		const table = this.table(_);
		return new TableQuery(table, alias);
	}
	/// * `MYTABLE.readRecord(_, key)`: reads a record from the table. 
	///   `key` may be:
	///   * a single value (simple primary key)
	///   * an array (composite primary key)
	///   * a JS object which will give the column names and their values.
	readRecord<T extends Record>(_: _,  key: any, opts?: TableReadOptions) {
		if (key == null) throw new Error("null key!");
		opts = Object.assign({
			// limit: 1,
		}, opts || {});
		const table = this.table(_);
		var reader: ez.Reader<T>;
		if (Array.isArray(key)) {
			reader = table.reader<T>(_, table.indexes[0], key, null, null, opts);
		} else if (typeof key !== 'object') {
			reader = table.reader<T>(_, table.indexes[0], [key], null, null, opts);
		} else {
			reader = table.reader<T>(_, null, key, null, null, opts);
		}
		const rec = reader.read(_);

		if (rec) {
			reader.stop(_);
			// convert to X3 types
			Object.keys(rec).forEach_(_, (_, name) => {
				any(rec)[name] = table.columns[name].type.fromSql(_, any(rec)[name]);
			});
		} else if ('notFound' in opts) return opts.notFound;
		return rec;
	}
	///
	/// #### Insert, update, delete
	///
	/// * `MYTABLE.insertRecord(_, values)`: inserts a record into the table. 
	///   `values` contain the record's column values.
	insertRecord(_: _,  values: any) {
		const table = this.table(_);
		const actx = glob.context.x3session.actx;
		const user = actx.$USER(_);
		values.CREDATTIM = values.CREDATTIM || datetime.now();
		values.CREUSR = values.CREUSR || user;
		values.UPDUSR = user;
		values.UPDDATTIM = datetime.now();
		return table.insertRecord(_, values);
	}
	/// * `MYTABLE.updateRecord(_, key, values)`: updates a record from the table. 
	///   `key`  is the record's key value (see `readRecord`  above). 
	///   `values` contain the record's column values. 
	///   Note: you only need to provide the columns that have been modified in `values`.
	updateRecord(_: _,  key: any, values: any) {
		const table = this.table(_);
		const actx = glob.context.x3session.actx;
		const user = actx.$USER(_);
		values.CREDATTIM = values.CREDATTIM || datetime.now();
		values.CREUSR = values.CREUSR || user;
		values.UPDUSR = user;
		values.UPDDATTIM = datetime.now();
		return table.updateRecord(_, key, values);
	}
	/// * `MYTABLE.deleteRecord(_, key)`: deletes a record from the table. 
	///   `key`  is the record's key value (see `readRecord`  above). 
	deleteRecord(_: _,  key: any) {
		const table = this.table(_);
		const actx = glob.context.x3session.actx;
		const user = actx.$USER(_);
		return table.deleteRecord(_, key);
	}
	/// * `MYTABLE.deleteAllRecords(_)`: removes all the table's records. 
	///   _Use with care_. 
	deleteAllRecords(_: _) {
		const table = this.table(_);
		return table.clear(_);
	}

	// internal??
	column(_: _,  name: string) {
		const table = this.table(_);
		const column = table.columns[name];
		if (!column) throw new Error("column not found: " + table.name + '.' + name);
		return new ColumnWrapper(column);
	}
}

const handlers: Dict<TableHandler> = {};

// internal - don't document
export function load(path: string) {
	if (!handlers[path]) handlers[path] = new TableHandler(path);
	return handlers[path];
};

export function define(def: TableDef) {
	if (!def.name) throw new Error(`table name missing`);
	return def;
};