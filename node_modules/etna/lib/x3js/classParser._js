"use strict";

const babylon = require('babylon');
const generate = require('babel-generator').default;
const traverse = require('babel-traverse').default;
const types = require('babel-types');
const fs = require('fs');
const fsp = require('path');
const util = require('etna/lib/supervisor/util');
const x3jsUtil = require('./util');
const classDescriptor = require('etna/lib/x3js/classDescriptor');


function error(filePath, node, message) {
	return new Error(`${filePath}:${node && node.loc && node.loc.start.line}: ${message}`);
}

function propNode(node, key) {
	return node.properties.filter(p => p.key.name === key)[0]
}

class Parser {
	constructor(filePath) {
		this.filePath = filePath;
	}
	parse(desc, dest, parent, name, node) {
		switch (desc.type) {
			case 'string':
				if (!types.isStringLiteral(node)) throw error(this.filePath, node, `${name} value is not a string literal`);
				dest[name] = node.value;
				break;
			case 'boolean':
			case 'addressOrValue':
				if (!types.isBooleanLiteral(node)) throw error(this.filePath, node, `${name} value is not a boolean literal`);
				dest[name] = node.value;
				break;
			case 'enum':
				if (!types.isStringLiteral(node)) throw error(this.filePath, node, `${name} value is not a string literal`);
				// todo; check validity
				dest[name] = node.value;
				break;
			case 'object':
				if (!types.isObjectExpression(node)) throw error(this.filePath, node, `${name} is not an object literal`);
				dest[name] = Object.keys(desc.properties).reduce((obj, key) => {
					const n = propNode(node, key);
					if (!n) {
						if (desc.isMandatory) throw error(this.filePath, node, `${name}: mandatory attribute missing`);
					} else {
						this.parse(desc.properties[key], obj, node, n.key.name, n.value);
					}
					return obj;
				}, {});
				break;
			case 'type':
				if (!types.isStringLiteral(node)) throw error(this.filePath, node, `${name} value is not a string literal`);
				dest[name] = node.value;
				['enum', 'typeCode', 'maxLength', 'precision', 'scale'].forEach(k => {
					const n = propNode(parent, k);
					if (n) dest[k] = n.value;
				});
				// todo; check validity
				break;
			case 'flags':
				if (!types.isStringLiteral(node)) throw error(this.filePath, node, `${name} value is not a string literal`);
				node.value.split(',').forEach(flag => {
					const key = flag.trim();
					if (!desc.dictCodes[key]) throw error(this.filePath, node, `${name} invalid flag value: ${key}`);
					dest[name + util.pascalize(flag.trim())] = true;
				});
				break;
			default:
				throw new Error(`${name}: unhandled type ${desc.type}`);
		}
	}
}

exports.parseFile = function(_, filePath) {
	const source = fs.readFile(filePath, 'utf8', _);
	return exports.parseSource(_, source, filePath);
}

exports.parseSource = function(_, source, filePath) {
	const ast = babylon.parse(source, { sourceType: 'module' });
	var found = false;
	var result = {
		file: filePath,
		ast: ast,
	}
	traverse(ast, {
		ExportDefaultDeclaration(path) {
			path.stop();
			const declaration = path.node.declaration;
			if (!types.isCallExpression(declaration) || 
				!types.isMemberExpression(declaration.callee) || 
				!types.isIdentifier(declaration.callee.property, { name: 'defineClass' })) {
				throw error(filePath, declaration, `default export is not an 'x3js.defineClass' call`);				
			}
			const def = declaration.arguments[0];
			result.root = def;
			if (!types.isObjectExpression(def)) throw error(filePath, def, `class definition is not an object literal`);
			new Parser(filePath).parse(classDescriptor, result, null, 'data', def);
		},
	});
	if (!result.root) throw new Error(`${path}: invalid class source file: export default not found`);
	return result;
}
