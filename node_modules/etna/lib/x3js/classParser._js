"use strict";

const babylon = require('babylon');
const generate = require('babel-generator').default;
const traverse = require('babel-traverse').default;
const types = require('babel-types');
const fs = require('fs');
const fsp = require('path');
const x3jsUtil = require('./util');

function error(filePath, node, message) {
	return new Error(`${filePath}:${node.loc && node.loc.start.line}: ${message}`);
}

const propertyMembers = {
	dictCode: stringLiteralMember('dictCode'),
	title: stringLiteralMember('title'),
}

function parseProperty(filePath, node, result) {
	var key = node.key.name;
	if (!key) throw error(filePath, node, `empty key`);
	if (result.properties[key]) throw error(filePath, node, `duplicate key: ${key}`);
	if (!types.isObjectExpression(node.value)) throw error(filePath, node, `property block is not an object literal`);
	var r = result.properties[key] = {};
	node.value.properties.forEach(prop => {
		if (!propertyMembers[prop.key.name]) throw error(filePath, prop, `unexpected class member: ${prop.key.name}`);
		propertyMembers[prop.key.name](filePath, prop.value, r);
	});
}

function stringLiteralMember(name) {
	return function(filePath, node, result) {
		if (!types.isStringLiteral(node)) throw error(filePath, node, `${name} value is not a string literal`);
		result[name] = node.value;
	};
}
const classMembers = {
	name: stringLiteralMember('name'),
	module: stringLiteralMember('module'),
	title: stringLiteralMember('title'),
	dictCode: stringLiteralMember('dictCode'),
	properties(filePath, node, result) {
		if (!types.isObjectExpression(node)) throw error(filePath, node, `properties block is not an object literal`);
		result.properties = {};
		node.properties.forEach(prop => parseProperty(filePath, prop, result));
	},
	events(filePath, node, result) {
	},
}

exports.parseFile = function(_, filePath) {
	const source = fs.readFile(filePath, 'utf8', _);
	const ast = babylon.parse(source, { sourceType: 'module' });
	var found = false;
	var result = {
		file: filePath,
		ast: ast,
	}
	traverse(ast, {
		ExportDefaultDeclaration(path) {
			found = true;
			path.stop();
			const declaration = path.node.declaration;
			if (!types.isCallExpression(declaration) || 
				!types.isMemberExpression(declaration.callee) || 
				!types.isIdentifier(declaration.callee.property, { name: 'defineClass' })) {
				throw error(filePath, declaration, `default export is not an 'x3js.defineClass' call`);				
			}
			const def = declaration.arguments[0];
			if (!types.isObjectExpression(def)) throw error(filePath, def, `class definition is not an object literal`);
			def.properties.forEach(prop => {
				if (!classMembers[prop.key.name]) throw error(filePath, prop, `unexpected class member: ${prop.key.name}`);
				classMembers[prop.key.name](filePath, prop.value, result);
			});
		},
	});
	if (!found) throw new Error(`${path}: invalid class source file: export default not found`);
	return result;
}
