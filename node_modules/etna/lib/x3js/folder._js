"use strict";
// internal

(function () {
	if (typeof Proxy === 'undefined') {
		console.warn("!!! Proxy undefined -- JS API NOT AVAILABLE !!!");
		exports.create = function (_, supervisor) {
			return null;
		};
		return;
	}
	require('harmony-reflect'); // to get ES6 Proxy API
	const glob = require('streamline-runtime').globals;
	const flows = require('streamline-runtime').flows;
	const ez = require('ez-streams');
	const ezmongo = require('ez-mongodb');
	const fs = require('fs');
	const fsp = require('path');
	const config = require('config');
	const constants = require('etna/lib/supervisor/constants');
	const util = require('etna/lib/supervisor/util');
	const uuid = require('syracuse-core').uuid; // don't use tuuid - we want strings not buffers

	const sysProps = {
		CREDATTIM: 'create stamp',
		UPDDATTIM: 'update stamp',
		CREUSR: 'create user',
		UPDUSR: 'update user',
		AUUID: 'uuid'
	};
	function fixNames(_, supervisor, colnName, codeProp, titleProp, capitalize, relations) {
		const coln = supervisor.mongoStore.collection(colnName, _);

		ezmongo.reader(coln.find({
			_proxyName: {
				$exists: false
			}
		})).map((_, elt) => {
			//console.error('FIXING NAMES: ' + elt[codeProp]);
			const title = supervisor.loadText(_, elt[titleProp], "ENG") || elt[codeProp];
			var name = util.camelize(title, capitalize);
			const existing = ezmongo.reader(coln.find({
				_proxyName: name
			})).toArray(_)[0];
			if (existing) {
				console.error("DUPLICATE PROXY NAME: " + name + ": " + existing[codeProp] + " and " + elt[codeProp]);
				name = util.camelize(elt[codeProp], capitalize);
			}
			console.error("PROXY NAME: " + colnName + "/" + elt[codeProp] + ": " + name);
			elt._proxyName = name;
			const subNames = {}; // same namespace for properties and collections!

			relations.forEach_(_, (_, rel) => {
				if (!elt[rel.name]) return;
				//console.error("RELATION", rel.name, elt[rel.name]);
				elt[rel.name].forEach_(_, (_, sub) => {
					var subTitle = sysProps[sub[rel.code]];
					subTitle = subTitle || supervisor.loadText(_, sub[rel.title], "ENG");
					if (!subTitle || /^TEXT_/.test(subTitle)) subTitle = sub[rel.code];
					var subName = util.camelize(subTitle);
					if (!subName) subName = util.camelize(sub[rel.code]); // in case no letters in subTitle
					if (subNames[subName]) {
						console.error("DUPLICATE PROPERTY NAME: " + subName + ": " + subNames[subName] + " and " + sub[rel.code]);
						subName = util.camelize(sub[rel.code]);
					} else {
						subNames[subName] = sub[rel.code];
					}
					sub._proxyName = subName;
				});
			});
			return elt;
		}).pipe(_, ezmongo.writer(coln, {
			upsert: true
		}));
	}

	class SaveError extends Error {
		constructor(message, errors) {
			super(message);
			this.errors = errors;
		}
	}

	function checkContext(supervisor) {
		if (glob.context.x3frame.context.superv !== supervisor) throw new Error("internal error: supervisor mismatch");
	}

	function testSession() {
		return Object.assign({}, {
			id: uuid.generate(),
			login: "admin",
			userName: "AQCORE",
			locale: "en-US",
			localePreferences: {
				_id: "9b648750-8925-4f28-afed-10aebf3d66c2",
				code: "en-US",
				description: {
					default: "English (United States)",
					"en-us": "English (United States)"
				},
				enabled: true,
				firstDayOfWeek: 0,
				longDate: "dddd, MMMM dd, yyyy",
				longDatetime: "dddd, MMMM dd, yyyy h:mm:ss tt",
				longTime: "h:mm:ss tt",
				numberDecimalSeparator: ".",
				numberGroupSeparator: " ",
				numberGroupSize: 3,
				shortDate: "M/d/yyyy",
				shortDatetime: "M/d/yyyy h:mm tt",
				shortTime: "h:mm tt"
			}
		});
	}

	class Folder {
		constructor(supervisor) {
			this.supervisor = supervisor;
		}
		init(_) {
			fixNames(_, this.supervisor, "ACLASSE", "CODCLA", "INTCLA", true, [{
				name: "PROPERTIES",
				code: "FLDCLA",
				title: "INTFLD"
			}, {
				name: "COLLECTIONS",
				code: "CODCOL",
				title: "INTCOL"
			}]);
			return this;
		}
		runUnitTest(cb, file) {
			return flows.withContext(() => {
				require("etna/lib/supervisor/builtins/ACTX").init(err => {
					if (err) return cb(err);
					// TODO: implement our own JSON reporter to avoid console output.
					const mocha = new (require('mocha'))({
						reporter: 'json'
					});
					mocha.addFile(file);
					// for now we execute in-process
					// this module cache hack does the trick but it will break if we execute other x3js code while test is running.
					// will re-implement with child_process, or with low-level mocha API later.
					const moduleCache = require('module')._cache;
					// force the reload of all x3-erp sources
					require('module')._cache = Object.keys(moduleCache).reduce((r, k) => {
						if (!/\bx3-erp\b/.test(k)) r[k] = moduleCache[k];
						return r;
					}, {});
					try {
						// mocha.run() will throw if source has a syntax error
						mocha.run().on('end', function() {
							// restore the module cache so that all test files will be reloaded next time
							require('module')._cache = moduleCache;
							if (cb) cb(null, this.testResults);
							cb = null;
						});
					} catch (ex) {
						console.error(ex.stack);
						if (!cb) return;
						if (ex.loc) cb(new Error(`${file}:${ex.loc.line}:${ex.loc.column}: ${ex.message}`));
						else cb(ex);
						cb = null;
					}
				}, testSession(), this.supervisor);
			}, {
				session: {
					getUserLogin(_) {
						return "test-user";
					},
					getSecurityProfile(_) {
						return null;
					},
					getData(key) {
						return null;
					}
				}
			})();
		}
	}

	exports.create = function (_, supervisor) {
		return new Folder(supervisor).init(_);
	};

	exports.jsInvoke = require('./js-invoke');
})();