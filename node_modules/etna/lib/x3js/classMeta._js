"use strict";
const util = require('etna/lib/supervisor/util');
const x3jsUtil = require('./util');
const typeMeta = require('./typeMeta');
const fs = require('fs');
const fsp = require('path');

const jsClassKind2TypCla = {
	standard: 1,
	interface: 5,
};

function paramFromColumn(colParam) {

}

exports.fromClassScript = (_, supervisor, script, table) => {
	if (!script.module) throw new Error(script.name + ": module missing");
	const clas = script;
	if (!clas.properties) throw new Error(script.name + ": properties element missing");
	const CODCLA = (clas.code || clas.name || script.name).toUpperCase();
	function CODTYP(prop) {
		switch (prop.type) {
			case 'enum': return 'M';
			case 'short': return 'C';
			case 'integer': return 'L';
			case 'decimal': return 'DCB';
			case 'double': return 'CTD';
			case 'string': return prop.maxLength != null ? 'A' : 'AC0';
			case 'date': return 'D';
			case 'datetime': return 'ADATIM';
			case 'uuid': return 'AUUID';
			case 'binary': return 'AB0';
			default: throw new Error("bad type: " + prop.sqlType);
		}
	}
	const scripts = clas.scripts || [{
		name: CODCLA + '_CSTD'
	}];
	const TABREF = table ? table.name : '';
	var INDREF = '';
	var KEYINT = '';
	if (script.tableRef) {
		INDREF = script.tableRef.indexName || table.indexes[0].name;
		KEYINT = script.tableRef.key || table.indexes[0].columns.map(c => c.name).join('~');
	} else if (script.tableDef) {
		INDREF = table.indexes[0].name;
		KEYINT = table.indexes[0].columns.map(c => c.name).join('~');
	}
	const columns = table && table.data.COLUMNS.reduce((r, c) => (r[c.CODZONE] = c, r), {});

	return {
		_proxyName: script.name,
		// header
		CODCLA: CODCLA,
		TYPCLA: jsClassKind2TypCla[clas.kind] || 2, // persistent by default
		INTCLA: 0,

		// general tab - characteristics
		MODULE: supervisor.moduleCode(script.module),
		CODACT: script.activityCode || '',

		// scripts
		NBRTRT: scripts.length,
		CODTRT: scripts.map(sc => sc.name ),
		TYPTRT: scripts.map(sc => sc.kind || 1),
		ACTTRT: scripts.map(sc => sc.activityCode || ''),
		RANTRT: scripts.map((sc, i) => i + 1), // TODO: order should come from script annotation.

		// table mapping
		TABREF: TABREF,
		INDREF: INDREF,
		KEYINT: KEYINT, 
		FLTREF: (table && table.filter) || '',

		// flags
		FLGRREF: x3jsUtil.boolIn(!!clas.canRead),
		FLGCREF: x3jsUtil.boolIn(!!clas.canCreate),
		FLGUREF: x3jsUtil.boolIn(!!clas.canUpdate),
		FLGDREF: x3jsUtil.boolIn(!!clas.canDelete),
		FLGSEARCH: x3jsUtil.boolIn(!!clas.canSearch),
		FLGCONSULT: x3jsUtil.boolIn(!!clas.canQuery),
		RAW: x3jsUtil.boolIn(!!clas.isTechnical),
		FLGACTX: x3jsUtil.boolIn(!!clas.isContextual),
		FLGSYSTEM: x3jsUtil.boolIn(!!clas.isSystem),
		//
		FCYSTR: clas.site || '',
		LEGSTR: clas.legislation || '',
		CPYSTR: clas.company || '',
		ACCCSTR: clas.accessCode || '',
		LNKOBJ: clas.linkedObject || '',

		FLGBUFFER: x3jsUtil.boolIn(!!clas.isBuffer),
		FLGTR: x3jsUtil.boolIn(!!clas.isTransacted),

		PROPERTIES: Object.keys(clas.properties).map((name, i) => {
			const prop = clas.properties[name];
			const FLDCLA = prop.columnName || name.toUpperCase();
			var col;
			var type;
			if (prop.columnName) {
				col = columns[prop.columnName];
				if (!col) console.error(columns);
				if (!col) throw new Error("column not found: " + prop.columnName);
				type = col; // column carries type info
				//console.error("CLASS META COLUMN", col)
			} else {
				type = typeMeta.fromProperty(prop);
			}
			// TODO: how do we valorize parameters???
			var PARAM_FLDS = (col && col.PARAMETERS && col.PARAMETERS.map(param => {
				return {
					CODCLA: CODCLA,
					FLDCLA: FLDCLA,
					CODPAR: param.CODPAR,
					NUMPAR: param.NUMPAR,
					ADRVAL: 2, // ??
					AWMAJTYP: 0, // ??
					TYPINT: 7,
					TYPKEY: 2, 
					TYPPAR: 1,
					VALEUR: '',
				}
			})) || [];
			return {
				_proxyName: name,
				CODCLA: CODCLA,
				FLDCLA: FLDCLA,
				NUMFLD: i + 1,
				INTFLD: 0,
				INTSHTFLD: 0,
				ACTFLD: prop.activityCode || '',

				CODTYP: type.CODTYP,
				LNKCLA: type.LNKCLA || '', // fix later.
				LONG: type.LONG || 0,
				NOLIB: type.NOLIB || 0,
				PARAM_FLDS: PARAM_FLDS,

				OBLIG: x3jsUtil.boolIn(!!prop.isMandatory),
				ACS: prop.accessCode || '',
				CODCTL: prop.controlTable || '',
				TABCONT: prop.dependency || '',
				FLDGRP: prop.group || '',

				FLGSEARCH: x3jsUtil.boolIn(!!prop.canSearch),
				CATSEARCH: prop.searchCategory || '',

				FLGACCGET: x3jsUtil.boolIn(!!prop.get),
				INTEVAL: '', // evaluated title: will be a function
				LOBTAB: prop.lobTable || '',
				LOBFLD: prop.lobColumn || '',
				LOBCNT: prop.contentType || '',
			};
		}),
		STD_METHODS: [],
	};
}

exports.createClassScript = data => {
	const babylon = require('babylon');
	const generate = require('babel-generator').default;

	const code = 'class Example {}';
	const ast = babylon.parse(code);
	 
	const output = generate(ast, {}, code);
	return output.code;
}

exports.loadData = (_, supervisor, name) => {
	const mappings = require('etna/test/x3js/fixtures/name-mappings');
	var jsName = mappings[name] && mappings[name][0];
	if (!jsName) jsName = util.pascalize(name);
	const kebabName = util.camelToKebab(jsName);
	const fname = fsp.join(__dirname, '../../test/x3js/fixtures/classes', kebabName + '.x3js');
	//console.error("LOADDATA", fs.exists(fname, _, _), jsName, fname);
	if (!fs.exists(fname, _, _)) return null;
	const script = require(fname).default;
	//console.error(script);
	if (!script || !script.module) {
		console.error("MODULE MISSING FROM SCRIPT: ", fname);
		return null;
	}

	var table = null;
	if (script.tableRef) {
		table = supervisor.load(_, 'Table', script.tableRef.name);
		if (!table) throw new Error('table not found: ' + script.tableRef);
	} else if (script.tableDef) {
		const tableData = require('./tableMeta').fromClassScript(_, supervisor, script);
		//console.error("TABLE DATA", tableData);
		table = supervisor.new(_, 'Table', tableData);
		// TODO: improve management of temporary tables
		if (script.tableDef.isTemporary) table.drop(_, true);
		if (!table.exists(_)) table.create(_);
		supervisor.cacheMeta('Table', tableData.CODFIC, table);
	}
	return exports.fromClassScript(_, supervisor, script, table);
}
