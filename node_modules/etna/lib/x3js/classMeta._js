"use strict";
const util = require('etna/lib/supervisor/util');
const x3jsUtil = require('./util');
const typeMeta = require('./typeMeta');
const fs = require('fs');
const fsp = require('path');

const jsClassKind2TypCla = {
	standard: 1,
	interface: 5,
};

exports.fromClassScript = (supervisor, script) => {
	if (!script.module) throw new Error(script.name + ": module missing");
	const clas = script;
	if (!clas.properties) throw new Error(script.name + ": properties element missing");
	const CODCLA = (clas.code || clas.name || script.name).toUpperCase();
	function CODTYP(prop) {
		switch (prop.type) {
			case 'enum': return 'M';
			case 'short': return 'C';
			case 'integer': return 'L';
			case 'decimal': return 'DCB';
			case 'double': return 'CTD';
			case 'string': return prop.maxLength != null ? 'A' : 'AC0';
			case 'date': return 'D';
			case 'datetime': return 'ADATIM';
			case 'uuid': return 'AUUID';
			case 'binary': return 'AB0';
			default: throw new Error("bad type: " + prop.sqlType);
		}
	}
	const scripts = clas.scripts || [{
		name: CODCLA + '_CSTD'
	}];
	const table = clas.table;
	const indexes = table && table.indexes;

	return {
		_proxyName: script.name,
		// header
		CODCLA: CODCLA,
		TYPCLA: jsClassKind2TypCla[clas.kind] || 2, // persistent by default
		INTCLA: 0,

		// general tab - characteristics
		MODULE: supervisor.moduleCode(script.module),
		CODACT: script.activityCode || '',

		// scripts
		NBRTRT: scripts.length,
		CODTRT: scripts.map(sc => sc.name ),
		TYPTRT: scripts.map(sc => sc.kind || 1),
		ACTTRT: scripts.map(sc => sc.activityCode || ''),
		RANTRT: scripts.map((sc, i) => i + 1), // TODO: order should come from script annotation.

		// table mapping
		TABREF: (table && table.name) || clas.tableName || '',
		INDREF: (indexes && indexes.length > 0 && indexes[0].name) || '',
		FLTREF: (table && table.filter) || '',

		// flags
		FLGRREF: x3jsUtil.boolIn(!!clas.canRead),
		FLGCREF: x3jsUtil.boolIn(!!clas.canCreate),
		FLGUREF: x3jsUtil.boolIn(!!clas.canUpdate),
		FLGDREF: x3jsUtil.boolIn(!!clas.canDelete),
		FLGSEARCH: x3jsUtil.boolIn(!!clas.canSearch),
		FLGCONSULT: x3jsUtil.boolIn(!!clas.canQuery),
		RAW: x3jsUtil.boolIn(!!clas.isTechnical),
		FLGACTX: x3jsUtil.boolIn(!!clas.isContextual),
		FLGSYSTEM: x3jsUtil.boolIn(!!clas.isSystem),
		//
		FCYSTR: clas.site || '',
		LEGSTR: clas.legislation || '',
		CPYSTR: clas.company || '',
		ACCCSTR: clas.accessCode || '',
		LNKOBJ: clas.linkedObject || '',

		KEYINT: clas.key || '', // ??
		FLGBUFFER: x3jsUtil.boolIn(!!clas.isBuffer),
		FLGTR: x3jsUtil.boolIn(!!clas.isTransacted),

		PROPERTIES: Object.keys(clas.properties).map((name, i) => {
			const prop = clas.properties[name];
			const type = typeMeta.fromProperty(prop);
			const FLDCLA = (prop.code || name).toUpperCase();
			return {
				_proxyName: name,
				CODCLA: CODCLA,
				FLDCLA: FLDCLA,
				NUMFLD: i + 1,
				INTFLD: 0,
				INTSHTFLD: 0,
				ACTFLD: prop.activityCode || '',

				CODTYP: type.CODTYP,
				LNKCLA: type.LNKCLA || '', // fix later.
				LONG: type.LONG || 0,
				NOLIB: type.NOLIB || 0,

				OBLIG: x3jsUtil.boolIn(!!prop.isMandatory),
				ACS: prop.accessCode || '',
				CODCTL: prop.controlTable || '',
				TABCONT: prop.dependency || '',
				FLDGRP: prop.group || '',

				FLGSEARCH: x3jsUtil.boolIn(!!prop.canSearch),
				CATSEARCH: prop.searchCategory || '',

				FLGACCGET: x3jsUtil.boolIn(!!prop.get),
				INTEVAL: '', // evaluated title: will be a function
				LOBTAB: prop.lobTable || '',
				LOBFLD: prop.lobColumn || '',
				LOBCNT: prop.contentType || '',
			};
		}),
		STD_METHODS: [],
	};
}

exports.createClassScript = data => {
	const babylon = require('babylon');
	const generate = require('babel-generator').default;

	const code = 'class Example {}';
	const ast = babylon.parse(code);
	 
	const output = generate(ast, {}, code);
	return output.code;
}

exports.loadData = (_, supervisor, name) => {
	const mappings = require('etna/test/x3js/fixtures/name-mappings');
	var jsName = mappings[name] && mappings[name][0];
	if (!jsName) jsName = util.pascalize(name.toLowerCase());
	const kebabName = util.camelToKebab(jsName);
	const fname = fsp.join(__dirname, '../../test/x3js/fixtures/classes', kebabName + '.x3js');
	//console.error("LOADDATA", fs.exists(fname, _, _), fname);
	if (!fs.exists(fname, _, _)) return null;
	const script = require(fname).default;
	//console.error(script);
	if (!script || !script.module) {
		console.error("NO METADATA IN SCRIPT: ", fname);
		return null;
	}

	const tableData = require('./tableMeta').fromClassScript(supervisor, script);
	if (tableData) {
		console.error("TABLE DATA", tableData);
		const table = supervisor.new(_, 'Table', tableData);
		// DANGER - TMP HACK - DELETE UNTIL WE HAVE ALTER
		//table.drop(_, true);
		if (!table.exists(_)) table.create(_);
		supervisor.cacheMeta('Table', tableData.CODFIC, table);
	}
	return exports.fromClassScript(supervisor, script);
}
