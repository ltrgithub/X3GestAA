"use strict";
const util = require('etna/lib/supervisor/util');
const x3jsUtil = require('./util');
const typeMeta = require('./typeMeta');

const jsClassKind2TypCla = {
	standard: 1,
	interface: 5,
};

exports.fromClassScript = function(supervisor, script) {
	if (!script.module) throw new Error("scripts module missing: " + script.name);
	const clas = script.class || {};
	const CODCLA = (clas.code || clas.name || script.name).toUpperCase();
	function CODTYP(prop) {
		switch (prop.type) {
			case 'enum': return 'M';
			case 'short': return 'C';
			case 'integer': return 'L';
			case 'decimal': return 'DCB';
			case 'double': return 'CTD';
			case 'string': return prop.maxLength != null ? 'A' : 'AC0';
			case 'date': return 'D';
			case 'datetime': return 'ADATIM';
			case 'uuid': return 'AUUID';
			case 'binary': return 'AB0';
			default: throw new Error("bad type: " + prop.sqlType);
		}
	}
	const scripts = clas.scripts || [{
		name: CODCLA + 'CSTD'
	}];
	const table = clas.table;
	const indexes = table && table.indexes;

	return {
		// header
		CODCLA: CODCLA,
		TYPCLA: jsClassType2TypCla[clas.kind] || 1,
		INTCLA: 0,

		// general tab - characteristics
		MODULE: supervisor.moduleCode(script.module),
		CODACT: script.activityCode || '',

		// scripts
		NBRTRT: scripts.length,
		CODTRT: scripts.map(sc => sc.name ),
		TYPTRT: scripts.map(sc => sc.kind || 1),
		ACTTRT: scripts.map(sc => sc.activityCode || ''),
		RANTRT: scripts.map((sc, i) => i + 1), // TODO: order should come from script annotation.

		// table mapping
		TABREF: (table && table.name) || clas.tableName || '',
		INDREF: (indexes && indexes.length > 0 && indexes[0].name) || '',
		FLTREF: (table && table.filter) || '',

		// flags
		FLGRREF: x3jsUtil.boolIn(!!clas.canRead);
		FLGCREF: x3jsUtil.boolIn(!!clas.canCreate),
		FLGUREF: x3jsUtil.boolIn(!!clas.canUpdate),
		FLGDREF: x3jsUtil.boolIn(!!clas.canDelete),
		FLGSEARCH: x3jsUtil.boolIn(!!clas.canSearch),
		FLGCONSULT: x3jsUtil.boolIn(!!clas.canQuery),
		RAW: x3jsUtil.boolIn(!!clas.isTechnical),
		FLGACTX: x3jsUtil.boolIn(!!clas.isContextual),
		FLGSYSTEM: x3jsUtil.boolIn(!!clas.isSystem),
		//
		FCYSTR: clas.site || '',
		LEGSTR: clas.legislation || '',
		CPYSTR: clas.company || '',
		ACCCSTR: clas.accessCode || '',
		LNKOBJ: clas.linkedObject || '',

		KEYINT: clas.key || '', // ??
		FLGBUFFER: x3jsUtil.boolIn(!!clas.isBuffer),
		FLGTR: x3jsUtil.boolIn(!!clas.isTransacted),

		PROPERTIES: Object.keys(clas.properties).map((name, i) => {
			const prop = clas.properties[name];
			const type = typeMeta.fromProperty(prop);
			const FLDCLA = (prop.code || name).toUpperCase();
			return {
				CODCLA: CODCLA,
				FLDCLA: FLDCLA,
				NUMFLD: i + 1,
				INTFLD: 0,
				INTSHTFLD: 0,
				ACTFLD: prop.activityCode || '',

				CODTYP: type.CODTYP,
				LNKCLA: type.LNKCLA || '', // fix later.
				LONG: type.LONG || 0,
				NOLIB: type.NOLIB || 0,

				OBLIG: x3jsUtil.boolIn(!!prop.isMandatory),
				ACS: prop.accessCode || '',
				CODCTL: prop.controlTable || '',
				TABCONT: prop.dependency || '',
				FLDGRP: prop.group || '',

				FLGSEARCH: x3jsUtil.boolIn(!!prop.canSearch),
				CATSEARCH: prop.searchCategory || '',

				FLGACCGET: x3jsUtil.boolIn(!!prop.get),
				INTEVAL: '', // evaluated title: will be a function
				LOBTAB: prop.lobTable || '',
				LOBFLD: prop.lobColumn || '',
				LOBCNT: prop.contentType || '',
			};
		}),
		STD_METHODS: [],
	};
}

exports.loadData(_, supervisor, name) {
	const mappings = require('etna/test/x3js/fixtures/name-mappings');
	const jsName = mappings[name];
	if (!jsName) return null;
	const kebabName = util.camelToKebab(jsName);
	const script = require('etna/test/x3js/fixtures/classes/' + kebabName);
	const tableData = require('./tableMeta').fromClassScript(supervisor, script.default);
	if (tableData) {
		const table = supervisor.new(_, 'Table', tableData);
		if (!table.exists(_)) table.create(_);
		supervisor.cacheMeta('Table', name, table);
	}
	return exports.fromClassScript(supervisor, script.default);
}
