"use strict";
const x3jsUtil = require('./util');

function isReadOnly(_, instance) {
	if (instance._parent) return isReadOnly(_, instance._parent);
	else return /^(4gl|incomplete)$/.test(instance.status(_));
}

module.exports = {
	type: 'object',
	defineMethod: 'defineClass',
	hasSourceFile: true,
	singular: 'class',
	plural: 'classes',
	subdir: 'classes',
	dictKey: 'CODCLA',
	entityName: 'x3jsClass',
	metaName: 'ACLASSE',
	properties: {
		module: {
			type: 'enum',
			enum: 'system.Module',
			dictCode: 'MODULE',
			isMandatory: true,
		},
		name: {
			type: 'string',
			// don't make it mandatory so that we can synchronize
			//isMandatory: true,
		},
		dictCode: {
			type: 'string',
			dictCode: 'CODCLA',
		},
		kind: {
			type: 'enum',
			enum: 'system.ClassKind',
			dictCode: 'TYPCLA',
			isMandatory: true,
		},
		title: {
			type: 'string',
			localization: 'system',
			dictCode: 'INTCLA',
		},
		activityCode: {
			type: 'string',
			dictCode: 'CODACT',
		},
		can: {
			type: 'flags',
			dictCodes: {
				read: 'FLGRREF',
				create: 'FLGCREF',
				update: 'FLGUREF',
				delete: 'FLGDREF',
				search: 'FLGSEARCH',
				query: 'FLGCONSULT',
			},
		},
		is: {
			type: 'flags',
			dictCodes: {
				technical: 'RAW',
				contextual: 'FLGACTX',
				system: 'FLGSYSTEM',
				cache: 'FLGBUFFER',
				transacted: 'FLGTR',
			},
		},
		table: {
			type: 'object',
			properties: {
				name: {
					type: 'string',	
					dictCode: 'TABREF',
				},
				index: {
					type: 'string',	
					dictCode: 'INDREF',
				},
				key: {
					type: 'string',	
					dictCode: 'KEYINT',
				},
				filter: {
					type: 'string',
					dictCode: 'FLTREF',
				},
			},
			rules: {
				readOnlyProperty: isReadOnly,
			},
		},
		contextProperties: {
			type: 'object',
			properties: {
				site: {
					type: 'string',
					dictCode: 'FCYSTR',
				},
				legislation: {
					type: 'string',
					dictCode: 'LEGSTR',
				},
				company: {
					type: 'string',
					dictCode: 'CPYSTR',
				},
				accessCode: {
					type: 'string',
					dictCode: 'ACCSTR',
				},
			},
			rules: {
				readOnlyProperty: isReadOnly,
			},
		},
		linkedObject: {
			type: 'string',
			dictCode: 'LNKOBJ',
		},
		events: {
			type: 'object',
			properties: {
				init: {
					type: 'event',
				},
				read: {
					type: 'event',
				},
				control: {
					type: 'event',
				},
				insert: {
					type: 'event',
				},
				insertBefore: {
					type: 'event',
				},
				insertAfter: {
					type: 'event',
				},
				insertControlBefore: {
					type: 'event',
				},
				insertControlAfter: {
					type: 'event',
				},
				insertRollback: {
					type: 'event',
				},
				update: {
					type: 'event',
				},
				updateBefore: {
					type: 'event',
				},
				updateAfter: {
					type: 'event',
				},
				updateControlBefore: {
					type: 'event',
				},
				updateControlAfter: {
					type: 'event',
				},
				updateRollback: {
					type: 'event',
				},
				delete: {
					type: 'event',
				},
				deleteBefore: {
					type: 'event',
				},
				deleteAfter: {
					type: 'event',
				},
				deleteControlBefore: {
					type: 'event',
				},
				deleteControlAfter: {
					type: 'event',
				},
				deleteRollback: {
					type: 'event',
				},
			},
		},
	},
	collections: {
		properties: {
			type: 'object',
			key: 'name',
			metaCode: 'PROPERTIES',
			dictKey: 'FLDCLA',
			parentCodes: {
				CODCLA: 'CODCLA',
			},
			dictIgnore(meta) {
				return x3jsUtil.isSysProperty(meta.FLDCLA);
			},
			orderCode: 'NUMLIG',
			dictFinish(meta) { 
				// NUMFLD is discarded in source so we re-generate it.
				meta.NUMFLD = meta.NUMLIG * 10;
			},
			properties: {
				dictCode: {
					type: 'string',
					dictCode: 'FLDCLA',
				},
				title: {
					type: 'string',
					localization: 'system',
					dictCode: 'INTFLD',
				},
				shortTitle: {
					type: 'string',
					localization: 'system',
					dictCode: 'INTSHTFLD',
				},
				activityCode: {
					type: 'string',
					dictCode: 'ACTFLD',
				},
				type: {
					type: 'type',
					dict: {
						typeCode: 'CODTYP',
						enum: 'NOLIB',
						classCode: 'LNKCLA',
						maxLength: 'LONG',
					},
					defaultValue: 'string',
				},
				collectionDictCode: {
					type: 'string',
					dictCode: 'FLDGRP',
					// TODO: remap to a collection name
				},
				isMandatory: {
					type: 'boolean',
					dictCode: 'OBLIG',
				},
				accessCode: {
					type: 'string',
					dictCode: 'ACS',
				},
				can: {
					type: 'flags',
					dictCodes: {
						search: 'FLDSEARCH',
						get: 'FLGACCGET',
					},
					forMeta(data) {
						// special rule to activate FLGACCGET automatically if there is a get event.
						const flags = [];
						if (/search/.test(data.can)) flags.push('search');
						else if (/get/.test(data.can) || (data.events && data.events.get)) flags.push('get');
						return flags.join(',');
					}
				},
				searchCategory: {
					type: 'string',
					dictCode: 'CATSEARCH',
				},
				// review below
				controlTable: {
					type: 'string',
					dictCode: 'CODCTL',
				},
				dependency: {
					type: 'string',
					dictCode: 'TABCONT',
				},
				lob: {
					type: 'object',
					properties: {
						table: {
							type: 'string',
							dictCode: 'LOBTAB',
						},
						column: {
							type: 'string',
							dictCode: 'LOBFLD',
						},
						contentType: {
							type: 'string',
							dictCode: 'LOBCNT',
						},
					},
					rules: {
						readOnlyProperty: isReadOnly,
					},
				},
				events: {
					type: 'object',
					properties: {
						init: {
							type: 'event',
						},
						get: {
							type: 'event',
						},
						control: {
							type: 'event',
						},
						propagate: {
							type: 'event',
						},
					},
				},
				evalTitle: {
					type: 'string',
					dictCode: 'INTEVAL',
				},
			},
			collections: {
				parameters: {
					type: 'object',
					metaCode: 'PARAM_FLDS',
					orderCode: 'NUMPAR',
					parentCodes: {
						CODCLA: 'CODCLA',
						FLDCLA: 'FLDCLA',
					},
					dictConstants: {
						TYPPAR: 1, // enum 59: property: 1, displayed property: 2, link: 3
					},
					properties: {
						dictCode: {
							type: 'string',
							dictCode: 'CODPAR',
						},
						dataType: {
							type: 'enum',
							enum: 'system.X3jsType',
							mapping: 'typtyp',
							dictCode: 'TYPINT',
						},
						belongsToKey: {
							type: 'boolean',
							dictCode: 'TYPKEY',
						},
						isOutput: {
							type: 'boolean',
							mapping: 'addressOrValue',
							dictCode: 'ADRVAL',
						},
						value: {
							type: 'string',
							dictCode: 'VALEUR',
						},
						// AWMAJTYP ????
					},		
					rules: {
						readOnlyProperty: isReadOnly,
					},
				},
			},
			rules: {
				readOnlyProperty: isReadOnly,
			},
		},
		collections: {
			type: 'object',
			key: 'name',
			metaCode: 'COLLECTIONS',
			parentCodes: {
				CODCLA: 'CODCLA',
			},
			properties: {
				dictCode: {
					type: 'string',
					dictCode: 'PROCOL',
				},
				itemClassCode: {
					type: 'string',
					dictCode: 'CODCOL',
				},
				title: {
					type: 'string',
					localization: 'system',
					dictCode: 'INTCOL',
				},
				activityCode: {
					type: 'string',
					dictCode: 'ACTCOL',
				},
				can: {
					type: 'flags',
					dictCodes: {
						append: 'FLGAPDCOL',
						insert: 'FLGINSCOL',
						delete: 'FLGSUPCOL',
						reorder: 'FLGTRICOL',
					},
				},
				min: {
					type: 'integer',
					dictCode: 'MINCOL',
				},
				max: {
					type: 'integer',
					dictCode: 'MAXCOL',
				},
				events: {
					type: 'object',
					properties: {
						addLineBefore: {
							type: 'event',
						},
						addLineAfter: {
							type: 'event',
						},
						deleteLineBefore: {
							type: 'event',
						},
						deleteLineAfter: {
							type: 'event',
						},
					},
				},
			},
		},
		joins: {
			type: 'object',
			metaCode: 'LINKS',
			parentCodes: {
				CODCLA: 'CODCLA',
			},
			orderCode: 'NUMLIG',
			properties: {
				cardinality: {
					type: 'enum',
					enum: 'system.Cardinality',
					dictCode: 'TYPLNK',
				},
				from: {
					type: 'object',
					properties: {
						table: {
							type: 'string',
							dictCode: 'TABORI',
						},
						alias: {
							type: 'string',
							dictCode: 'ABRORI',
						},
					},
				},
				to: {
					type: 'object',
					properties: {
						table: {
							type: 'string',
							dictCode: 'TABLNK',
						},
						alias: {
							type: 'string',
							dictCode: 'ABRLNK',
						},
						index: {
							type: 'string',
							dictCode: 'CLELNK',
						},
						sortKey: {
							type: 'string',
							dictCode: 'CLESORT',
						},
						classDictCode: {
							type: 'string',
							dictCode: 'CLALNK',
						},
						titleDictCode: { // ???
							type: 'string',
							dictCode: 'REFLNK',
						},
					},
				},
				condition4gl: {
					type: 'string',
					dictCode: 'EXPLNK',
				},
				filter4gl: {
					type: 'string',
					dictCode: 'EXPSEL',
				},
				activityCode: {
					type: 'string',
					dictCode: 'ACVLNK',
				},
				can: {
					type: 'flags',
					dictCodes: {
						'read': 'FLGR',
						'insert': 'FLGC',
						'update': 'FLGU',
						'delete': 'FLGD',
						'a': 'FLGA', // ???
						'v': 'FLGV', // ???
					}
				}
			},
		},
		behaviors: {
			type: 'object',
			metaCode: 'STD_METHODS',
			parentCodes: {
				CODCLA: 'CODCLA',
			},
			orderCode: 'NOMETSTD',
			specialKey: "CODMETSTD",
			properties: {
				isEnabled: {
					type: 'boolean',
					dictCode: 'ENAMETSTD',
				},
				activityCode: {
					type: 'string',
					dictCode: 'ACTMETSTD',
				},
				accessCode: {
					type: 'string',
					dictCode: 'ACSMETSTD',
				},
			},
		},
		scripts: {
			type: 'object',
			mapping: 'denormalized',
			countCode: 'NBRTRT',
			properties: {
				name: {
					type: 'string',
					dictCode: 'CODTRT',
				},
				kind: {
					type: 'enum',
					enum: 'system.ScriptType',
					dictCode: 'TYPTRT',
				},
				activityCode: {
					type: 'string',
					dictCode: 'ACTTRT',
				},
				rank: {
					type: 'integer',
					dictCode: 'RANTRT',
				},
			},
		},
		tableDef: {
			type: 'object',
			cardinality: 1,
			properties: {
				name: {
					type: 'string',
				},
				// X3JS-only properties
				is: {
					type: 'flags',
					flags: ['temporary']
				},
			},
			collections: {
				indexes: {
					type: 'object',
					properties: {
						name: {
							type: 'string',
						},
						properties: {
							type: 'string',
						},
						is: {
							type: 'flags',
							flags: ['unique', 'clustered'],
						},
					},
				},
			},
		},
	},
	rules: {
		readOnlyProperty: isReadOnly,
	}
};
