"use strict";
const x3jsUtil = require('./util');

function isReadOnly(_, instance) {
	if (instance._parent) return isReadOnly(_, instance._parent);
	else return /^(4gl|incomplete)$/.test(instance.status(_));
}

module.exports = {
	type: 'object',
	defineMethod: 'defineClass',
	properties: {
		module: {
			type: 'enum',
			enum: 'system.Module',
			dictCode: 'MODULE',
		},
		name: {
			type: 'string',
		},
		dictCode: {
			type: 'string',
			dictCode: 'CODCLA',
		},
		kind: {
			type: 'enum',
			enum: 'system.ClassKind',
			dictCode: 'TYPCLA',
		},
		title: {
			type: 'string',
			localization: 'system',
			dictCode: 'INTCLA',
		},
		activityCode: {
			type: 'string',
			dictCode: 'CODACT',
		},
		can: {
			type: 'flags',
			dictCodes: {
				read: 'FLGRREF',
				create: 'FLGCREF',
				update: 'FLGUREF',
				delete: 'FLGDREF',
				search: 'FLGSEARCH',
				query: 'FLGCONSULT',
			},
		},
		is: {
			type: 'flags',
			dictCodes: {
				technical: 'RAW',
				contextual: 'FLGACTX',
				system: 'FLGSYSTEM',
				cache: 'FLGBUFFER',
				transacted: 'FLGTR',
			},
		},
		table: {
			type: 'object',
			properties: {
				name: {
					type: 'string',	
					dictCode: 'TABREF',
				},
				index: {
					type: 'string',	
					dictCode: 'INDREF',
				},
				key: {
					type: 'string',	
					dictCode: 'KEYINT',
				},
				filter: {
					type: 'string',
					dictCode: 'FLTREF',
				}
			},
			rules: {
				readOnlyProperty: isReadOnly,
			},
		},
		contextProperties: {
			type: 'object',
			properties: {
				site: {
					type: 'string',
					dictCode: 'FCYSTR',
				},
				legislation: {
					type: 'string',
					dictCode: 'LEGSTR',
				},
				company: {
					type: 'string',
					dictCode: 'CPYSTR',
				},
				accessCode: {
					type: 'string',
					dictCode: 'ACCCSTR',
				},
			},
			rules: {
				readOnlyProperty: isReadOnly,
			},
		},
		linkedObject: {
			type: 'string',
			dictCode: 'LNKOBJ',
		},
		events: {
			type: 'object',
			properties: {
				init: {
					type: 'event',
				},
				read: {
					type: 'event',
				},
				control: {
					type: 'event',
				},
				insert: {
					type: 'event',
				},
				insertBefore: {
					type: 'event',
				},
				insertAfter: {
					type: 'event',
				},
				insertControlBefore: {
					type: 'event',
				},
				insertControlAfter: {
					type: 'event',
				},
				insertRollback: {
					type: 'event',
				},
				update: {
					type: 'event',
				},
				updateBefore: {
					type: 'event',
				},
				updateAfter: {
					type: 'event',
				},
				updateControlBefore: {
					type: 'event',
				},
				updateControlAfter: {
					type: 'event',
				},
				updateRollback: {
					type: 'event',
				},
				delete: {
					type: 'event',
				},
				deleteBefore: {
					type: 'event',
				},
				deleteAfter: {
					type: 'event',
				},
				deleteControlBefore: {
					type: 'event',
				},
				deleteControlAfter: {
					type: 'event',
				},
				deleteRollback: {
					type: 'event',
				},
			},
		},
	},
	collections: {
		/*
		scripts: {
			type: 'object',
			denormalized: true,
			dictCode: 'NBRTRT',
			orderCode: 'RANTRT',
			properties: {
				name: {
					type: 'string',
					dictCode: 'CODTRT',
				},
				kind: {
					type: 'enum',
					enum: 'system.ScriptType',
					dictCode: 'TYPTRT',
				},
				activityCode: {
					type: 'string',
					dictCode: 'ACTTRT',
				},
			},
		},*/
		properties: {
			type: 'object',
			key: 'name',
			metaCode: 'PROPERTIES',
			dictIgnore(meta) {
				return x3jsUtil.isSysProperty(meta.FLDCLA);
			},
			orderCode: 'NUMFLD',
			properties: {
				dictCode: {
					type: 'string',
					dictCode: 'FLDCLA',
				},
				title: {
					type: 'string',
					localization: 'system',
					dictCode: 'INTFLD',
				},
				shortTitle: {
					type: 'string',
					localization: 'system',
					dictCode: 'INTSHTFLD',
				},
				activityCode: {
					type: 'string',
					dictCode: 'ACTFLD',
				},
				type: {
					type: 'type',
					dict: {
						typeCode: 'CODTYP',
						enum: 'NOLIB',
						classCode: 'LNKCLA',
						maxLength: 'LONG',
					},
				},
				isMandatory: {
					type: 'boolean',
					dictCode: 'OBLIG',
				},
				accessCode: {
					type: 'string',
					dictCode: 'ACS',
				},
				can: {
					type: 'flags',
					dictCodes: {
						search: 'FLGSEARCH',
						get: 'FLGACCGET',
					},
				},
				searchCategory: {
					type: 'string',
					dictCode: 'CATSEARCH',
				},
				// review below
				controlTable: {
					type: 'string',
					dictCode: 'CODCTL',
				},
				dependency: {
					type: 'string',
					dictCode: 'TABCONT',
				},
				lob: {
					type: 'object',
					properties: {
						table: {
							type: 'string',
							dictCode: 'LOBTAB',
						},
						column: {
							type: 'string',
							dictCode: 'LOBFLD',
						},
						contentType: {
							type: 'string',
							dictCode: 'LOBCNT',
						},
					},
					rules: {
						readOnlyProperty: isReadOnly,
					},
				},
				events: {
					type: 'object',
					properties: {
						init: {
							type: 'event',
						},
						get: {
							type: 'event',
						},
						control: {
							type: 'event',
						},
						propagate: {
							type: 'event',
						},
					},
				},
				evalTitle: {
					type: 'string',
					dictCode: 'INTEVAL',
				},
			},
			collections: {
				parameters: {
					type: 'object',
					metaCode: 'PARAM_FLDS',
					properties: {
						dictCode: {
							type: 'string',
							dictCode: 'CODPAR',
						},
						dataType: {
							type: 'enum',
							enum: 'system.X3jsType',
							mapping: 'typtyp',
							dictCode: 'TYPINT',
						},

						// redundant with TYPINT - M-34 - see later
						// maybe we should use it if TYPINT in 0 (4 occurrences of this in REPOSUPERV)
						//parameterType: {
						//	type: 'string',
						//	dictCode: 'TYPPAR',
						//},
						belongsToKey: {
							type: 'boolean',
							dictCode: 'TYPKEY',
						},
						isOutput: {
							type: 'boolean',
							mapping: 'addressOrValue',
							dictCode: 'ADRVAL',
						},
						value: {
							type: 'string',
							dictCode: 'VALEUR',
						},
						alias: {
							type: 'string',
							dictCode: 'ALIAS',
						},
						// AWMAJTYP ????
					},		
					rules: {
						readOnlyProperty: isReadOnly,
					},
				},
			},
			rules: {
				readOnlyProperty: isReadOnly,
			},
		},
	},
	rules: {
		readOnlyProperty: isReadOnly,
	}
};
