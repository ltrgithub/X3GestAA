"use strict";

const types = require('babel-types');
import { _ } from 'streamline-runtime';
import * as fs from 'fs';
import * as fsp from 'path';
import * as util from '../supervisor/util';
import * as x3jsUtil from './util';
import { FullDescriptor, Descriptor, PropertyDescriptor, CollectionDescriptor } from './descriptor';
const jsEscape = x3jsUtil.jsEscape;

type AstNode = x3jsUtil.AstNode;

const templateString = function (desc: FullDescriptor<any>) {
	return `import x3js from 'x3js';
	${ desc.sourceDeclarations || '' }

	export default x3js.${ desc.defineMethod }({});`;
};

export function template(desc: FullDescriptor<any>) {
	const source = templateString(desc);
	// roundtrip though parser/formatter to get nice fomatting.
	const ast = require('babylon').parse(source, { sourceType: 'module' });
	const generator = new (require('babel-generator').CodeGenerator)(ast, {}, '');
	generator.format.indent.style = '\t';
	const output = generator.generate();
	return output.code;
}

function genProp(dest: any, name: string) {
	var prop = dest.filter((n: AstNode) => n.key.name === name)[0];
	if (!prop) {
		prop = types.objectProperty(name[0] === '#' ? types.stringLiteral(name) : types.identifier(name), types.identifier('undefined'));
		dest.push(prop);
	}
	return prop;
}

const specials: { [name: string]: (node: AstNode, data: any) => any; } = {
	property(node, data) {
		node.properties = node.properties.filter((n: AstNode) => n.key.name !== 'type');
		return types.callExpression(
			types.memberExpression(types.identifier('x3js'), types.identifier(data.type + 'Property')), 
			[node]);
	},
	enum(node, data) {
		if (typeof data.dictId !== 'number') throw new Error(`expected numeric dictId, got ${ typeof data.dictId }`);
		return types.numericLiteral(data.dictId);
	},
	message(node, data) {
		return types.callExpression(
			types.memberExpression(types.identifier('x3js'), types.identifier('message')), 
			[types.numericLiteral(data.dictId)]);
	},
}

type Dict<T> = { [name: string]: T; };

interface Collect {
	imports: Dict<string>;
	events: any[];
}

const enumNode = (val: string, collect: Collect) => {
	const pair = val.split('.');
	if (pair.length !== 2) {
		//throw new Error(`invalid enum specification: ${val}`);
		return types.identifier('TODO_' + val);
	} else {
		collect.imports[pair[1]] = '../../' + util.kebabify(pair[0]) + '/enums/' + util.kebabify(pair[1]);
		return types.identifier(pair[1]);
	}
}

function asPropertyDescriptor(desc: Descriptor): PropertyDescriptor { return desc as any; };
function asCollectionDescriptor(desc: Descriptor): CollectionDescriptor { return desc as any; };

function genAst(desc: PropertyDescriptor | CollectionDescriptor, name: string, data: any, dest: AstNode, collect: Collect) {
	//console.error("GENAST", name, data[name]);
	switch (desc.type) {
		case 'string':
			if (!data[name]) return false;
			if (asPropertyDescriptor(desc).localization) return false; // TODO generate localization files
			genProp(dest, name).value = types.stringLiteral(data[name]);
			break;
		case 'boolean':
			if (!data[name]) return false;
			genProp(dest, name).value = types.booleanLiteral(data[name]);
			break;
		case 'integer':
			if (!data[name]) return false;
			genProp(dest, name).value = types.numericLiteral(data[name]);
			break;
		case 'enum':
			if (!data[name]) return false;
			genProp(dest, name).value = types.stringLiteral(data[name]);
			// todo; check validity
			break;
		case 'event':
			if (!data[name]) return false;
			genProp(dest, name).value = types.identifier(data[name]);
			collect.events.push(data[name]);
			break;
		case 'object':
			const obj = data[name];
			if (!obj || Object.keys(obj).length === 0) return false;
			const objExp = types.objectExpression([]);
			const asColnDesc = asCollectionDescriptor(desc);
			if (asColnDesc.codeGen !== 'enum' && asColnDesc.codeGen !== 'message') {
				var empty = true;
				Object.keys(desc.properties).forEach(k => {
					const prop = desc.properties[k];
					if (genAst(prop, k, obj, objExp.properties, collect)) empty = false;
				});
				Object.keys(desc.collections || {}).forEach(k => {
					const coln = desc.collections[k];
					if (coln.key || coln.specialKey) {
						if (obj[k] != null) {
							const colnExp = types.objectExpression([]);
							genProp(objExp.properties, k).value = colnExp;
							Object.keys(obj[k]).forEach(key => {
								if (genAst(coln, key, obj[k], colnExp.properties, collect)) empty = false;
							});
						}
					} else if (coln.cardinality === 1) {
						if (obj[k] != null) {
							if (genAst(coln, k, obj, objExp.properties, collect)) empty = false;
						}
					} else {
						if (obj[k] != null && obj[k].length > 0) {
							const array = types.arrayExpression(obj[k].map((elt: any, i: number) => {
								const tmpDest: any[] = [];

								if (genAst(coln, '' + i, obj[k], tmpDest, collect)) empty = false;
								return tmpDest[0] && tmpDest[0].value;
							}).filter((x: any) => !!x));
							genProp(objExp.properties, k).value = array;
						}
					}
				});
				if (empty && !asColnDesc.key && !asColnDesc.specialKey) return false;
			}
			genProp(dest, name).value = asColnDesc.codeGen 
				? specials[asColnDesc.codeGen](objExp, obj)
				: objExp;
			break;
		case 'type':
			if (!data[name]) return false;
			genProp(dest, name).value = types.stringLiteral(data[name]);
			if (data.enum) genProp(dest, 'enum').value = enumNode(data.enum, collect);
			if (data.typeCode && data.typeCode !== 'M') genProp(dest, 'typeCode').value = types.stringLiteral(data.typeCode);
			if (data.classCode) genProp(dest, 'classCode').value = types.stringLiteral(data.classCode);
			if (data.maxLength) genProp(dest, 'maxLength').value = types.numericLiteral(data.maxLength);
			if (data.precision) genProp(dest, 'precision').value = types.numericLiteral(data.precision);
			if (data.scale) genProp(dest, 'scale').value = types.numericLiteral(data.scale);
			// todo; check validity
			break;
		case 'flags':
			if (!data[name]) return false;
			genProp(dest, name).value = types.stringLiteral(data[name]);
			break;
		default:
			throw new Error(`${ name }: unhandled type ${ desc.type }`);
	}
	return true;
}

function addMissingEventHandlers(ast: AstNode, events: any[]) {
	var idef = -1;
	const found: { [name: string]: boolean } = {};

	ast.program.body.forEach((node: AstNode, i: number) => {
		if (types.isFunctionDeclaration(node)) {
			found[node.id.name] = true;
		} else if (types.isExportDefaultDeclaration(node)) {
			idef = i;
		}
	});
	if (idef === -1) throw new Error(`missing export default`);
	ast.program.body.splice(idef, 0, ...events.filter(name => !found[name]).map(name => types.functionDeclaration(types.identifier(name), [types.identifier('_')], types.blockStatement([]))));
}

function addMissingImports(ast: AstNode, imports: Dict<string>) {
	var last = -1;
	const found: { [name: string]: boolean } = {};

	ast.program.body.forEach((node: AstNode, i: number) => {
		if (types.isImportDeclaration(node)) {
			last = i;
			node.specifiers.filter(types.isImportDefaultSpecifier).forEach((specifier: AstNode) => {
				found[specifier.local.name] = node.source.value;
			});
		} 
	});
	Object.keys(imports).filter(k => !found[k]).forEach(k => {
		ast.program.body.splice(last++, 0, types.importDeclaration(
			[types.importDefaultSpecifier(types.identifier(name))],
			types.stringLiteral(imports[k])));
	});
}

export function generateSourceCode<T>(_: _,  parsed: x3jsUtil.Parsed, descriptor: FullDescriptor<T>) {
	const properties: any[] = [];
	const collect: Collect = {
		events: [],
		imports: {},
	};
	genAst(descriptor, 'data', parsed, properties, collect);
	parsed.root.properties = properties[0].value.properties;
	if (Object.keys(collect.imports).length > 0) addMissingImports(parsed.ast, collect.imports);
	if (collect.events.length > 0) addMissingEventHandlers(parsed.ast, collect.events);
	// lazy require for babel
	// reset ignore flag on AST comments - otherwise we lose them
	parsed.ast.comments.forEach((c: AstNode) => c.ignore = false);
	// require('babel-generator').generate(ast, opts, filename) does not let us set tab char :-(.
	const generator = new (require('babel-generator').CodeGenerator)(parsed.ast, {}, '');
	generator.format.indent.style = '\t';
	const output: { code: string; } = generator.generate();
	return output;
};