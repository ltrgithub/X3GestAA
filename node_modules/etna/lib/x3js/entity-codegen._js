"use strict";

const babylon = require('babylon');
const generate = require('babel-generator').default;
const traverse = require('babel-traverse').default;
const types = require('babel-types');
const fs = require('fs');
const fsp = require('path');
const util = require('etna/lib/supervisor/util');
const x3jsUtil = require('./util');
const jsEscape = x3jsUtil.jsEscape;

exports.template = function(_, desc) {
	return `import * as x3js from 'x3js';

	export default x3js.${desc.defineMethod}({});`;
}

function genProp(dest, name) {
	var prop = dest.filter(n => n.key.name === name)[0];
	if (!prop) {
		prop = types.objectProperty(types.identifier(name), types.identifier('undefined'));
		dest.push(prop);
	}
	return prop;
}

function genAst(desc, dest, name, data) {
	//console.error("GENAST", name, data[name]);
	switch (desc.type) {
		case 'string':
			if (!data[name]) return;
			if (desc.localization) return; // TODO generate localization files
			genProp(dest, name).value = types.stringLiteral(data[name]);
			break;
		case 'boolean':
			if (!data[name]) return;
			genProp(dest, name).value = types.booleanLiteral(data[name]);
			break;
		case 'integer':
			if (!data[name]) return;
			genProp(dest, name).value = types.numericLiteral(data[name]);
			break;
		case 'enum':
			if (!data[name]) return;
			genProp(dest, name).value = types.stringLiteral(data[name]);
			// todo; check validity
			break;
		case 'object':
			const obj = data[name];
			if (!obj || Object.keys(obj).length === 0) return;
			const objExp = types.objectExpression([]);
			Object.keys(desc.properties).forEach(k => {
				const prop = desc.properties[k];
				genAst(prop, objExp.properties, k, obj);
			});
			Object.keys(desc.collections || {}).forEach(k => {
				const coln = desc.collections[k];
				if (!coln.key) {
					if (obj[k] != null && obj[k].length > 0) {
						const array = types.arrayExpression(obj[k].map((elt, i) => {
							var tmpDest = [];
							genAst(coln, tmpDest, i, obj[k]);
							return tmpDest[0].value;
						}));
						genProp(objExp.properties, k).value = array;
					}
				} else {
					if (obj[k] != null) {
						const colnExp = types.objectExpression([]);
						genProp(objExp.properties, k).value = colnExp;
						Object.keys(obj[k]).forEach(key => {
							genAst(coln, colnExp.properties, key, obj[k]);
						});
					}
				}
			});
			genProp(dest, name).value = objExp;
			break;
		case 'type':
			if (!data[name]) return;
			genProp(dest, name).value = types.stringLiteral(data[name]);
			if (data.enum) genProp(dest, 'enum').value = types.stringLiteral(data.enum);
			if (data.typeCode && data.typeCode !== 'M') genProp(dest, 'typeCode').value = types.stringLiteral(data.typeCode);
			if (data.maxLength) genProp(dest, 'maxLength').value = types.numericLiteral(data.maxLength);
			if (data.precision) genProp(dest, 'precision').value = types.numericLiteral(data.precision);
			if (data.scale) genProp(dest, 'scale').value = types.numericLiteral(data.scale);
			// todo; check validity
			break;
		case 'flags':
			if (!data[name]) return;
			genProp(dest, name).value = types.stringLiteral(data[name]);
			break;
		default:
			throw new Error(`${name}: unhandled type ${desc.type}`);
	}
}

function mkdirp(_, path) {
	if (fs.exists(path, _, _)) return;
	mkdirp(_, fsp.join(path, '..'));
	console.error(`creating directory ${path}`);
	fs.mkdir(path, _);
}

function removeSourceInfo(ast) {
	traverse(ast, {
  		enter(path) {
  			delete path.node.loc;
  		}
	});
	delete ast.loc;
	ast.tokens = [];
}

exports.generateSourceFile = function(_, file, code) {
	mkdirp(_, fsp.dirname(file));
	fs.writeFile(file, code, 'utf8', _);	
}

exports.generateSourceCode = function(_, parsed, descriptor) {
	const properties = [];
	genAst(descriptor, properties, 'data', parsed);
	parsed.root.properties = properties[0].value.properties;
	removeSourceInfo(parsed.ast);
	const output = generate(parsed.ast, {}, '');
	return output;
}

