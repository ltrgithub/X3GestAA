"use strict";

const types = require('babel-types');
const fs = require('fs');
const fsp = require('path');
const util = require('etna/lib/supervisor/util');
const x3jsUtil = require('./util');
const jsEscape = x3jsUtil.jsEscape;

exports.template = function(desc) {
	return `import * as x3js from 'x3js';
	${desc.sourceDeclarations || ''}

	export default x3js.${desc.defineMethod}({});`;
}

function genProp(dest, name) {
	var prop = dest.filter(n => n.key.name === name)[0];
	if (!prop) {
		prop = types.objectProperty(name[0] === '#' ? types.stringLiteral(name) : types.identifier(name), types.identifier('undefined'));
		dest.push(prop);
	}
	return prop;
}

function genAst(desc, name, data, dest, events) {
	//console.error("GENAST", name, data[name]);
	switch (desc.type) {
		case 'string':
			if (!data[name]) return false;
			if (desc.localization) return false; // TODO generate localization files
			genProp(dest, name).value = types.stringLiteral(data[name]);
			break;
		case 'boolean':
			if (!data[name]) return false;
			genProp(dest, name).value = types.booleanLiteral(data[name]);
			break;
		case 'integer':
			if (!data[name]) return false;
			genProp(dest, name).value = types.numericLiteral(data[name]);
			break;
		case 'enum':
			if (!data[name]) return false;
			genProp(dest, name).value = types.stringLiteral(data[name]);
			// todo; check validity
			break;
		case 'event':
			if (!data[name]) return false;
			genProp(dest, name).value = types.identifier(data[name]);
			events.push(data[name]);
			break;
		case 'object':
			const obj = data[name];
			if (!obj || Object.keys(obj).length === 0) return false;
			if (desc.codeGen === 'dictIdOnly') {
				if (typeof obj.dictId !== 'number') throw new Error(`expected numeric dictId, got ${typeof obj.dictId}`);
				genProp(dest, name).value = types.numericLiteral(obj.dictId);
				break;
			}
			const objExp = types.objectExpression([]);
			var empty = true;
			Object.keys(desc.properties).forEach(k => {
				const prop = desc.properties[k];
				if (genAst(prop, k, obj, objExp.properties, events)) empty = false;
			});
			Object.keys(desc.collections || {}).forEach(k => {
				const coln = desc.collections[k];
				if (coln.key || coln.specialKey) {
					if (obj[k] != null) {
						const colnExp = types.objectExpression([]);
						genProp(objExp.properties, k).value = colnExp;
						Object.keys(obj[k]).forEach(key => {
							if (genAst(coln, key, obj[k], colnExp.properties, events)) empty = false;
						});
					}
				} else if (coln.cardinality === 1) {
					if (obj[k] != null) {
						if (genAst(coln, k, obj, objExp.properties, events)) empty = false;
					}
				} else {
					if (obj[k] != null && obj[k].length > 0) {
						const array = types.arrayExpression(obj[k].map((elt, i) => {
							var tmpDest = [];
							if (genAst(coln, i, obj[k], tmpDest, events)) empty = false;
							return tmpDest[0] && tmpDest[0].value;
						}).filter(x => !!x));
						genProp(objExp.properties, k).value = array;
					}
				}
			});
			if (empty && !desc.key && !desc.specialKey) return false;
			genProp(dest, name).value = objExp;
			break;
		case 'type':
			if (!data[name]) return false;
			genProp(dest, name).value = types.stringLiteral(data[name]);
			if (data.enum) genProp(dest, 'enum').value = types.stringLiteral(data.enum);
			if (data.typeCode && data.typeCode !== 'M') genProp(dest, 'typeCode').value = types.stringLiteral(data.typeCode);
			if (data.classCode) genProp(dest, 'classCode').value = types.stringLiteral(data.classCode);
			if (data.maxLength) genProp(dest, 'maxLength').value = types.numericLiteral(data.maxLength);
			if (data.precision) genProp(dest, 'precision').value = types.numericLiteral(data.precision);
			if (data.scale) genProp(dest, 'scale').value = types.numericLiteral(data.scale);
			// todo; check validity
			break;
		case 'flags':
			if (!data[name]) return false;
			genProp(dest, name).value = types.stringLiteral(data[name]);
			break;
		default:
			throw new Error(`${name}: unhandled type ${desc.type}`);
	}
	return true;
}

function addMissingEventHandlers(ast, events) {
	var idef = -1;
	var found = {};
	ast.program.body.forEach((node, i) => {
		if (types.isFunctionDeclaration(node)) {
			found[node.id.name] = true;
		} else if (types.isExportDefaultDeclaration(node)) {
			idef = i;
		}
	});
	if (idef === -1) throw new Error(`missing export default`);
	ast.program.body.splice(idef, 0, ...events.filter(name => !found[name]).map(name => {
		return types.functionDeclaration(types.identifier(name), [types.identifier('_')], types.blockStatement([]));
	}));
}

function mkdirp(_, path) {
	if (fs.exists(path, _, _)) return;
	mkdirp(_, fsp.join(path, '..'));
	console.error(`creating directory ${path}`);
	fs.mkdir(path, _);
}

function removeSourceInfo(ast) {
	// lazy require for babel
	const traverse = require('babel-traverse').default;
	traverse(ast, {
  		enter(path) {
  			delete path.node.loc;
  		}
	});
	delete ast.loc;
	ast.tokens = [];
}

exports.generateSourceFile = function(_, file, code) {
	mkdirp(_, fsp.dirname(file));
	fs.writeFile(file, code, 'utf8', _);	
}

exports.generateSourceCode = function(_, parsed, descriptor) {
	const properties = [];
	const events = [];
	//console.error("GENSOURCE", parsed.data);
	genAst(descriptor, 'data', parsed, properties, events);
	parsed.root.properties = properties[0].value.properties;
	addMissingEventHandlers(parsed.ast, events);
	removeSourceInfo(parsed.ast);
	// lazy require for babel
	const generator = new (require('babel-generator').CodeGenerator)(parsed.ast, {}, '');
	generator.format.indent.style = '\t';
	const output = generator.generate();
	return output;
}

