import { _ } from 'streamline-runtime';
import * as util from '../supervisor/util';
import * as x3jsUtil from './util';
import * as typeMeta from './type-meta';
import * as fs from 'fs';
import * as fsp from 'path';
import * as entityHelper from './entity-helper';
import { Table } from '../supervisor/meta/table'
import { descriptor as classDescriptor, ClassDef } from './class-descriptor';
import { Supervisor } from '../supervisor/supervisor';

export function fromClassScript(_: _, supervisor: Supervisor, script: ClassDef, table: Table) {
	//console.error("METAFROMSCRIPT", script);
	if (!script.module) throw new Error(script.name + ": module missing");
	const clas = script;
	if (!clas.properties) throw new Error(script.name + ": properties element missing");
	const meta = entityHelper.create(supervisor, classDescriptor).canonicalToMeta(_, script, script.name);
	//console.error("META", meta);
	if (script.tableDef) {
		// adjust table mapping
		if (meta.TABREF && meta.TABREF !== script.tableDef.name) throw new Error(`${ script.name }: mismatch between 4GL and X3JS table names`);
		meta.TABREF = script.tableDef.name;
		meta.INDREF = script.tableDef.indexes[0].name;
		// derive kEYINT from first index columns
		meta.KEYINT = table.data.INDEXES[0].DESCRIPT.replace(/^\W/, '').replace(/[\+\-]/g, '~');
	}
	const scripts = clas.scripts || [];
	// huge hack to enable X3JS script through _CSTD hack - CLEAN THIS UP!
	//[{name: 'classes:' + script.module + '.' + script.name}];
	Object.assign(meta, {
		NBRTRT: scripts.length,
		CODTRT: scripts.map(sc => sc.name),
		TYPTRT: scripts.map(sc => sc.kind || 1),
		ACTTRT: scripts.map(sc => sc.activityCode || ''),
		RANTRT: scripts.map((sc, i) => i + 1) });

	//console.error("META", meta);
	// TODO: order should come from script annotation.
	return meta;
};

export function loadData(_: _, supervisor: Supervisor, script: ClassDef) {
	var table: Table = null;
	if (script.tableRef) {
		table = supervisor.load(_, 'Table', script.tableRef.name);
		if (!table) throw new Error('table not found: ' + script.tableRef.name);
	} else if (script.tableDef) {
		// we need at least one index and we have to generate index names
		if (!script.tableDef.indexes || !script.tableDef.indexes.length) throw new Error(`${ script.name }: tableDef has no index`);
		script.tableDef.indexes.forEach((index, i) => {
			index.name = script.tableDef.name + "_IDX" + i;
		});
		const tableMeta = require('./table-meta').fromClassScript(_, supervisor, script);
		//console.error("TABLE META", tableMeta);
		table = supervisor.new(_, 'Table', tableMeta);
		// TODO: improve management of temporary tables
		if (/temporary/.test(script.tableDef.is)) table.drop(_, true);
		if (!table.exists(_)) table.create(_);
		supervisor.cacheMeta('Table', tableMeta.CODFIC, table);
	}
	return fromClassScript(_, supervisor, script, table);
};