import { _ } from 'streamline-runtime';
import * as fsp from 'path';
import * as fs from 'fs';
import * as util from '../supervisor/util';
import { Double } from '../engine/runtime/tdouble';
import * as tbcd from '../engine/runtime/tbcd';
import * as tdate from '../engine/runtime/tdate';
import * as tdatetime from '../engine/runtime/tdatetime';
import * as tblbfile from '../engine/runtime/tblbfile';
import * as tclbfile from '../engine/runtime/tclbfile';
import * as tuuid from '../engine/runtime/tuuid';
import { Column } from '../supervisor/meta/column';
import { Property } from '../supervisor/meta/property';
import { Type } from '../supervisor/meta/type';
import { Diagnosis } from '../supervisor/meta/diagnosis';
import { OrmInstance } from './orm';
import * as ACTX from '../supervisor/builtins/ACTX';
const globals = require('streamline-runtime').globals;
import * as supervisor from '../supervisor/supervisor';

// TODO: add typing to babel APIs
export type AstNode = any;

export interface Parsed {
	ast: AstNode; // refine later
	map?: any; // refine later
	file: string;
	data?: any;
	root?: AstNode;
}

let instanceProxy: any;

export function any(x: any) { return x; }

export function jsEscape(str: string) {
	return str.replace(/[\\\n\r\t"']/g, ch => '\\' + util.any({
		'\n': 'n',
		'\r': 'r',
		'\t': 't'
	})[ch] || ch);
};

export function isSysProperty(code: string) {
	return (/^(CREUSR|CREDATTIM|UPDTICK|UPDUSR|UPDDATTIM|AUUID|ASTALIN|AORDER|_AFCRIGHT)$/.test(code));
};

export function boolOut(val: number, def: boolean) {
	if (def !== undefined && val === 0) return def;
	if (val !== 2 && val !== 1) throw new Error("invalid boolean: " + val);
	return val === 2;
};

export function boolIn(val: boolean) {
	return val == null ? 0 : val ? 2 : 1;
};

const NFT = [null, false, true];

export function toJs(val: any, t: Property) {
	if (val == null) return val;
	switch (t.type.data.TYPTYP) {
		case 1:
			// menu
			if (t.data.NOLIB === 1) return NFT[val];
			else {
				if (val !== (val & 0xff)) throw convertError('tiny int', val);
				return val;
			}
		case 2:
		case 3:
			// integers
			return val;
		case 4:
			// decimal
			return val;
		case 5: // float (unused)
		case 6:
			// double
			if (typeof val.value !== 'number') throw new Error("bad double: " + val);
			return val.value;
		case 7:
			// string
			return val;
		case 8:
			// date
			return val.x3IsZero() ? null : val;
		case 9: // blob
		case 10:
			// clob
			return val.value;
		case 11:
			// uuid
			return val.x3IsZero() ? null : val.x3ToString();
		case 12:
			// datetime
			return val.x3IsZero() ? null : val;
		case 13:
			// instance
			 instanceProxy = instanceProxy || require('./instance-proxy'); // circular-dependency
			return instanceProxy.create(val);
		default:
			throw new Error("invalid type code: " + t.type.data.TYPTYP);
	}
};

function convertError(target: string, val: any) {
	return new Error("cannot convert to " + target + ": " + val + " (type " + typeof val + ')');
}

export function fromJs(val: any, t: Column) {
	switch (t.type.data.TYPTYP) {
		case 1:
			// menu
			if (t.data.NOLIB === 1) {
				// don't test type, just truthiness
				return val == null ? 0 : val ? 2 : 1;
			} else {
				if (val !== (val & 0xff)) throw convertError('tiny int', val);
				return val;
			}
		case 2:
		case 3:
			// integers
			if (util.any(val | 0) === val) return val;
			throw convertError('integer', val);
		case 4:
			// decimal
			if (typeof val === 'number') return tbcd.fromDouble(val);
			else if (val instanceof tbcd.BCD) return val;
			throw convertError('decimal', val);
		case 5: // float (unused)
		case 6:
			// double
			if (typeof val === 'number') return val;
			else if (val instanceof tbcd.BCD) return val.x3ToDouble();
			throw convertError('double', val);
		case 7:
			// string
			if (typeof val === 'string') return val;
			throw convertError('string', val);
		case 8:
			// date
			if (val == null) return tdate.NULL;
			else if (tdate.isDate(val)) return val;
			throw convertError('date', val);
		case 9:
			// blob
			if (Buffer.isBuffer(val)) return new tblbfile.Blbfile(val);
			throw convertError('blob', val);
		case 10:
			// clob
			if (typeof val === 'string') return new tclbfile.Clbfile(val);
			throw convertError('clob', val);
		case 11:
			// uuid
			if (val == null) return tuuid.NULL;
			else if (typeof val === 'string') return new Buffer(val.replace(/-/g, ''), 'hex');
			throw convertError('uuid', val);
		case 12:
			// datetime
			if (val == null) return tdatetime.NULL;
			else if (tdatetime.isDatetime(val)) return val;
			throw convertError('datetime', val);
		case 13:
			// instance
			if (val == null) return null;
			const instance = val.$instance;
			if (instance) return instance;
			throw convertError('instance', val);
		default:
			throw new Error("invalid type code: " + t.type.data.TYPTYP);
	}
};

const JsSeverities: { [id: number]: string } = {
	0: "success",
	1: "success",
	2: 'info',
	3: 'warning',
	4: 'error'
};

function toJsSeverity(severity: number) {
	const jsSeverity = JsSeverities[severity];
	if (!jsSeverity) throw new Error(`invalid severity code: ${ severity }`);
	return jsSeverity;
}

export function toJsDiagnose(diag: Diagnosis) {
	return {
		severity: toJsSeverity(diag.severity),
		message: diag.message,
		stack: diag.stackTrace
	};
};

export const x3jsTypeNames: { [id: number]: string } = {
	1: 'enum',
	2: 'integer',
	3: 'integer',
	4: 'decimal',
	5: 'double',
	6: 'double',
	7: 'string',
	8: 'date',
	9: 'blob',
	10: 'clob',
	11: 'uuid',
	12: 'datetime',
	13: 'instance'
};

export const x3jsTypeIds = Object.keys(x3jsTypeNames).reduce((r, id) => (r[x3jsTypeNames[+id]] = +id, r), util.any({}));

export interface TypeDef {
	name: string;
	typeCode?: string;
	classCode?: string;
	maxLength?: number;
	precision?: number;
	scale?: number;
	enum?: string;
	[name: string]: string | number;
}

export function x3jsType(type: Type, nolib: number, long: number): TypeDef {
	const result: TypeDef = {
		name: x3jsTypeNames[type.data.TYPTYP],
		typeCode: type.data.CODTYP,
		maxLength: 0
	};
	if (!result.name) throw new Error(`${ type.data.CODTYP }: bad TYPTYP: ${ type.data.TYPTYP }`);
	switch (type.data.TYPTYP) {
		case 1:
			if (nolib === 1) result.name = 'boolean';
			else result.enum = '' + nolib; // see later
			break;
		case 4:
			Object.assign(result, type.precisionAndScale(long));
			break;
		case 7:
			result.maxLength = type.data.LNGTYP || 0;
			break;
	}
	return result;
};

export function controlCamelCase(propName: string) {
	return function (_: _,  instance: OrmInstance, value: string) {
		if (value && !/^[a-z_]\w*$/.test(value)) {
			instance.$addError(`invalid name: camelCase expected`, propName);
		}
	};
};

export function controlPascalCase(propName: string) {
	return function (_: _,  instance: OrmInstance, value: string) {
		if (value && (!/^[A-Z]\w+$/.test(value) || value === value.toUpperCase())) {
			instance.$addError(`invalid name: PascalCase expected`, propName);
		}
	};
};

export function controlKebabCase(propName: string) {
	return function (_: _,  instance: OrmInstance, value: string) {
		if (value && !/^[a-z][a-z0-9\-]*[a-z0-9]$/.test(value)) {
			instance.$addError(`invalid name: kebab-case expected`, propName);
		}
	};
};

export function controlUpperCase(propName: string) {
	return function (_: _,  instance: OrmInstance, value: string) {
		if (value !== value.toUpperCase()) {
			instance.$addError(`invalid name name: UPPER_CASE expected`, propName);
		}
	};
};

export function truncUpcase(str: string, maxlen: number) {
	const all = util.upcase(str || '').split('_');
	var len = -1;
	return all.filter((s, i) => (len += 1 + s.length) <= maxlen || i === 0) //
	.join('_').substring(0, maxlen);
}

export function truncCamelize(str: string, maxlen: number) {
	const all = util.upcase(str || '').split('_');
	var len = -1;
	return all.filter((s, i) => (len += 1 + s.length) <= maxlen || i === 0) //
	.map((s, i) => i == 0 ? s.toLowerCase() : s.substring(0, 1).toUpperCase() + s.substring(1).toLowerCase()) //
	.join('').substring(0, maxlen);
}

const enumRanges = [
[0, 99],
[175, 175],
[201, 4999],
[5200, 5999],
[6200, 6999],
[7600, 7600],
[7800, 7899],
[7910, 7999],
[8000, 8799],
[9001, 9002],
[9025, 9199],
[9966, 10030],
[11200, 29999]];

const enumExceptions = [75, 7837, 7980, 7981, 7982, 7999, 9097, 9119, 9119, 9120, 9126, 9129, 9130, 9137, 9138, 9139];

export function isEnum(data: any) {
	const id = data.LANCHP;
	var ok = enumRanges.some(r => r[0] <= id && id <= r[1]);
	ok = ok && enumExceptions.indexOf(id) < 0;
	const likelyMessage = data.ENTRIES.some((e: any) => e.LANMES && e.LANMES.split(' ').length > 5);
	//if (ok && data.ENTRIES.length > 5 && likelyMessage) console.error(id + ': LIKELY MESSAGE');
	//if (!ok && data.ENTRIES.length > 0 && !likelyMessage) console.error(id + ': LIKELY ENUM');
	return ok;
}

export function mkdirp(_: _,  path: string) {
	if (fs.exists(path, _, _)) return;
	exports.mkdirp(_, fsp.join(path, '..'));
	console.error(`creating directory ${ path }`);
	fs.mkdir(path, _);
}

export function wait<T>(fn: (_: _) => T) {
	const fiberized = any(fn)['fiberized-0'];
	return fiberized.apply(this, [true]);
}

/*
export function fiberize(api) {
	if (typeof api === 'function') {
		const fiberized = api['fiberized-0'];
		return fiberized ? function(...args) {
			return fiberized.apply(this, [true].concat(args));
		} : api;
	}
	
	// ES2015 methods are not enumerable. Use Object.getOwnPropertyNames rather than Objectkeys
	const wrapper = Object.create(api);
	Object.getOwnPropertyNames(api).forEach(k => {
		// get descriptor to avoid evaluation of property members
		const desc = Object.getOwnPropertyDescriptor(api, k);
		//console.error(typeof desc.value, desc);
		if (typeof desc.value === 'function') {
			wrapper[k] = exports.fiberize(api[k]);
		}
	});
	return wrapper;
}*/

export function currentSupervisor(_: _) {
	const session = globals.context.session;
	if (!session) throw new Error("invalid context: no session");
	//console.error("SESSION", session);
	const endpoint = session.getUserProfile(_).selectedEndpoint(_);
	if (!endpoint.useEtna(_)) throw new Error("operation not available on current endpoint");
	//console.error("ENDPOINT", endpoint);
	const conf = endpoint.getEtnaConfig(_, session);
	//console.error("SUPERVISOR CONF", conf);
	const superv = supervisor.create(_, conf);
	ACTX.init(_, conf.session, superv);
	return superv;
};
