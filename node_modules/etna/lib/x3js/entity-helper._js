"use strict";
const util = require('etna/lib/supervisor/util');
const x3jsUtil = require('etna/lib/x3js/util');
const systemEnums = require('./system-enums');

function rawEnum(name) {
	const [enumModule, enumName] = name.split('.');
	if (enumModule !== 'system') throw new Error(`bad enum module: ${enumModule}`);
	const enu = systemEnums[enumName];
	if (!enu) throw new Error(`system enum not found: ${enumName}`);
	return enu;
}

function entityEnum(name) {
	const enu = rawEnum(name);
	return Object.keys(enu).map(k => ({
		$value: k[0].toLowerCase() + k.substring(1),
		$title: util.camelToKebab(k, ' '),
	}));
}

function enumValueFromMeta(name, val) {
	const enu = rawEnum(name);
	const key = Object.keys(enu).filter(k => enu[k] === val)[0];
	if (!key) throw new Error(`${name}: bad enum value: ${val}`);
	return key[0].toLowerCase() + key.substring(1);
}

function updateSource(_, instance) {
	if (instance.updateSource) return instance.updateSource(_);
	else if (instance._parent) return updateSource(_, instance._parent);
}

exports.addProperties = function(entity, descriptor, prefix) {
	descriptor.rules = descriptor.rules || {};
	Object.keys(descriptor.properties).forEach(k => {
		const name = prefix ? prefix + util.pascalize(k) : k;
		const descProp = descriptor.properties[k];
		if (entity.$properties[name]) {
			if (descProp) descProp.$propagate = updateSource;
			return;
		}
		if (descProp.type === 'flags') {
			Object.keys(descProp.dictCodes).forEach(flag => {
				entity.$properties[k + util.pascalize(flag)] = {
					$title: util.camelToKebab(flag, ' '),
					$type: 'boolean',
					$isReadOnly: descriptor.rules.readOnlyProperty,
					$propagate: updateSource,
				};
			});
		} else if (descProp.type === 'object') {
			exports.addProperties(entity, descProp, name);
		} else {
			const entityProp = entity.$properties[name] = {
				$title: descProp.title || util.camelToKebab(name, ' '),
			};
			switch (descProp.type) {
				case 'string':
				case 'boolean':
					entityProp.$type = descProp.type;
					break;
				case 'enum':
					entityProp.$type = 'string';
					entityProp.$enum = entityEnum(descProp.enum);
					break;
				case 'type':
					entityProp.$type = 'string';
					entityProp.$enum = entityEnum('system.X3jsType');
					if (entity.$properties.enum) throw new Error('enum property already exists');
					entity.$properties.enum = {
						$title: 'enumeration',
						$type: 'string',
						$isReadOnly: descriptor.rules.readOnlyProperty,
						$propagate: updateSource,
					};
					if (entity.$properties.typeCode) throw new Error('typeCode property already exists');
					entity.$properties.typeCode = {
						$title: 'type code',
						$type: 'string',
						$isReadOnly: descriptor.rules.readOnlyProperty,
						$propagate: updateSource,
					};
					if (entity.$properties.maxLength) throw new Error('maxLength property already exists');
					entity.$properties.maxLength = {
						$title: 'max length',
						$type: 'integer',
						$isNullable: true, 
						$isReadOnly: descriptor.rules.readOnlyProperty,
						$propagate: updateSource,
					};
					// class code is used to build reference.
					break;

				// sepcial types
				case 'addressOrValue':
					entityProp.$type = 'boolean';
					break;
				case 'x3TypTyp': // special case: value is an X3 TYPTYP value
					entityProp.$type = 'string';
					entityProp.$enum = 'system.X3jsType';
					break;
				default:
					throw new Error(`${name}: invalid type: ${descProp.type}`);
			}
			entityProp.$isReadOnly = descriptor.rules.readOnlyProperty;
			entityProp.$propagate = updateSource;
		}
	});
}

exports.fillFromMeta = function(_, instance, descriptor, superv, meta, prefix) {
	Object.keys(descriptor.properties).forEach_(_, (_, k) => {
		const name = prefix ? prefix + util.pascalize(k) : k;
		try {
			const descProp = descriptor.properties[k];
			var value = descProp.dictCode && meta[descProp.dictCode];
			switch (descProp.type) {
				case 'string':
					switch (descProp.localization) {
						case 'system':
							instance[name](_, superv.loadText(_, value, 'ENG'));
							break;
						case undefined:
							instance[name](_, value);
							break;
						default:
							throw new Error(`${name}: invalid localization: ${descProp.localization}`);
					}
					break;
				case 'boolean':
					instance[name](_, x3jsUtil.boolOut(value, false));
					break;
				case 'enum':
					instance[name](_, enumValueFromMeta(descProp.enum, value));
					break;
				case 'flags':
					Object.keys(descProp.dictCodes).forEach_(_, (_, flag) => {
						const dictCode = descProp.dictCodes[flag];
						instance[name + util.pascalize(flag)](_, x3jsUtil.boolOut(meta[dictCode] || 0, false));
					});
					break;
				case 'object':
					exports.fillFromMeta(_, instance, descProp, superv, meta, name);
					break;
				case 'type':
					const typeCode = meta[descProp.dict.typeCode];
					var x3jsType;
					if (!typeCode) {
						const classCode = meta[descProp.dict.classCode];
						if (!classCode) throw new Error(`invalid type code: ${JSON.stringify(meta)}`);
						x3jsType = {
							name: 'instance',
							classCode: classCode,
							maxLength: 0,
						};
					} else {
						const metaType = superv.load(_, 'Type', typeCode);
						if (!metaType) throw new Error(`type not found ${typeCode}`)
						x3jsType = x3jsUtil.x3jsType(metaType, meta[descProp.dict.enum]);
					}
					instance[name](_, x3jsType.name);
					Object.keys(descProp.dict).forEach_(_, (_, typeProp) => {
						if (x3jsType[typeProp] != null && instance[typeProp]) instance[typeProp](_, x3jsType[typeProp]);
					})
					break;

					// special types
				case 'addressOrValue':
					// 1: byAddress => true
					// 2: byValue => false
					instance[name](_, value === 1);
					break;
				case 'x3TypTyp': {// special case: value is an X3 TYPTYP value
					const x3jsType = x3jsUtil.x3jsTypeNames[value];
					if (x3jsType == null) throw new Error(`${name}: invalid type value: ${JSON.stringify(meta)}`);
					instance[name](_, x3jsType);
				}
					break;
				default:
					throw new Error(`${k}: invalid type: ${descProp.type}`);
			}
		} catch (ex) {
			console.error(`error while setting property ${name}: ${ex.message}`);
			// for now, just ignore property
			//throw ex;
		}
	});
	Object.keys(descriptor.collections || {}).forEach_(_, (_, k) => {
		const name = prefix ? prefix + util.pascalize(k) : k;
		const descCol = descriptor.collections[k];
		const instCol = instance[name](_);
		(meta[descCol.metaCode] || []).forEach_(_, (_, row) => {
			if (descCol.dictIgnore && descCol.dictIgnore(row)) return;
			const rowInst = instCol.add(_);
			exports.fillFromMeta(_, rowInst, descCol, superv, row);
		});	
	});
}
