"use strict";
const supervisor = require("etna/lib/supervisor/supervisor");
const util = require('etna/lib/supervisor/util');
const x3jsUtil = require('etna/lib/x3js/util');
const systemEnums = require('./system-enums');
const fsp = require('path');
const fs = require('fs');
const ACTX = require("etna/lib/supervisor/builtins/ACTX");
const globals = require('streamline-runtime').globals;


function rawEnum(name) {
	const [enumModule, enumName] = name.split('.');
	if (enumModule !== 'system') throw new Error(`bad enum module: ${enumModule}`);
	const enu = systemEnums[enumName];
	if (!enu) throw new Error(`system enum not found: ${enumName}`);
	return enu;
}

function entityEnum(name) {
	const enu = rawEnum(name);
	return Object.keys(enu).map(k => ({
		$value: k[0].toLowerCase() + k.substring(1),
		$title: util.camelToKebab(k, ' '),
	}));
}

function enumValueFromMeta(name, val) {
	const enu = rawEnum(name);
	const key = Object.keys(enu).filter(k => enu[k] === val)[0];
	if (!key) throw new Error(`${name}: bad enum value: ${val}`);
	return key[0].toLowerCase() + key.substring(1);
}

function updateSource(_, instance) {
	if (instance.updateSource) return instance.updateSource(_);
	else if (instance._parent) return updateSource(_, instance._parent);
}

exports.updateSource = updateSource;

exports.addProperties = function(entity, descriptor, prefix) {
	descriptor.rules = descriptor.rules || {};
	Object.keys(descriptor.properties).forEach(k => {
		const name = prefix ? prefix + util.pascalize(k) : k;
		const descProp = descriptor.properties[k];
		if (entity.$properties[name]) {
			if (descProp) descProp.$propagate = updateSource;
			return;
		}
		if (descProp.type === 'flags') {
			Object.keys(descProp.dictCodes).forEach(flag => {
				entity.$properties[k + util.pascalize(flag)] = {
					$title: util.camelToKebab(flag, ' '),
					$type: 'boolean',
					$isReadOnly: descriptor.rules.readOnlyProperty,
					$propagate: updateSource,
				};
			});
		} else if (descProp.type === 'object') {
			exports.addProperties(entity, descProp, name);
		} else {
			const entityProp = entity.$properties[name] = {
				$title: descProp.title || util.camelToKebab(name, ' '),
			};
			switch (descProp.type) {
				case 'string':
				case 'boolean':
				case 'integer':
					entityProp.$type = descProp.type;
					break;
				case 'enum':
					entityProp.$type = 'string';
					entityProp.$enum = entityEnum(descProp.enum);
					break;
				case 'type':
					entityProp.$type = 'string';
					entityProp.$enum = entityEnum('system.X3jsType');
					if (entity.$properties.enum) throw new Error('enum property already exists');
					entity.$properties.enum = {
						$title: 'enumeration',
						$type: 'string',
						$isReadOnly: descriptor.rules.readOnlyProperty,
						$propagate: updateSource,
					};
					if (entity.$properties.typeCode) throw new Error('typeCode property already exists');
					entity.$properties.typeCode = {
						$title: 'type code',
						$type: 'string',
						$isReadOnly: descriptor.rules.readOnlyProperty,
						$propagate: updateSource,
					};
					if (entity.$properties.maxLength) throw new Error('maxLength property already exists');
					entity.$properties.maxLength = {
						$title: 'max length',
						$type: 'integer',
						$isNullable: true, 
						$isReadOnly: descriptor.rules.readOnlyProperty,
						$propagate: updateSource,
					};
					if (entity.$properties.precision) throw new Error('precision property already exists');
					entity.$properties.precision = {
						$title: 'precision',
						$type: 'integer',
						$isNullable: true, 
						$isReadOnly: descriptor.rules.readOnlyProperty,
						$propagate: updateSource,
					};
					if (entity.$properties.scale) throw new Error('scale property already exists');
					entity.$properties.scale = {
						$title: 'scale',
						$type: 'integer',
						$isNullable: true, 
						$isReadOnly: descriptor.rules.readOnlyProperty,
						$propagate: updateSource,
					};
					// class code is used to build reference.
					break;
				default:
					throw new Error(`${name}: invalid type: ${descProp.type}`);
			}
			entityProp.$isReadOnly = descriptor.rules.readOnlyProperty;
			entityProp.$propagate = updateSource;
		}
	});
}

exports.fillFromMeta = function(_, instance, descriptor, superv, meta, prefix) {
	Object.keys(descriptor.properties).forEach_(_, (_, k) => {
		const name = prefix ? prefix + util.pascalize(k) : k;
		try {
			const descProp = descriptor.properties[k];
			var value = descProp.dictCode && meta[descProp.dictCode];
			switch (descProp.type) {
				case 'string':
					if (!descProp.dictCode) return;
					switch (descProp.localization) {
						case 'system':
							instance[name](_, superv.loadText(_, value, 'ENG'));
							break;
						case undefined:
							instance[name](_, value);
							break;
						default:
							throw new Error(`${name}: invalid localization: ${descProp.localization}`);
					}
					break;
				case 'boolean':
					if (!descProp.dictCode) return;
					switch (descProp.mapping) {
						case 'addressOrValue':
							// 1: byAddress => true
							// 2: byValue => false
							instance[name](_, value === 1);
							break;
						default:
							instance[name](_, x3jsUtil.boolOut(value, false));
							break;
					}
					break;
				case 'integer':
					if (!descProp.dictCode) return;
					instance[name](_, value);
					break;
				case 'enum':
					if (!descProp.dictCode) return;
					switch (descProp.mapping) {
						case 'typtyp':
							const x3jsType = x3jsUtil.x3jsTypeNames[value];
							if (x3jsType == null) throw new Error(`${name}: invalid type value: ${JSON.stringify(meta)}`);
							instance[name](_, x3jsType);
							break;
						default:
							instance[name](_, enumValueFromMeta(descProp.enum, value));
							break;
					}
					break;
				case 'flags':
					Object.keys(descProp.dictCodes).forEach_(_, (_, flag) => {
						const dictCode = descProp.dictCodes[flag];
						instance[name + util.pascalize(flag)](_, x3jsUtil.boolOut(meta[dictCode] || 0, false));
					});
					break;
				case 'object':
					exports.fillFromMeta(_, instance, descProp, superv, meta, name);
					break;
				case 'type':
					const typeCode = meta[descProp.dict.typeCode];
					var x3jsType;
					if (!typeCode) {
						const classCode = meta[descProp.dict.classCode];
						if (!classCode) throw new Error(`invalid type code: ${JSON.stringify(meta)}`);
						x3jsType = {
							name: 'instance',
							classCode: classCode,
							maxLength: 0,
						};
					} else {
						const metaType = superv.load(_, 'Type', typeCode);
						if (!metaType) throw new Error(`type not found ${typeCode}`)
						x3jsType = x3jsUtil.x3jsType(metaType, meta[descProp.dict.enum], meta[descProp.dict.maxLength]);
					}
					instance[name](_, x3jsType.name);
					Object.keys(x3jsType).forEach_(_, (_, typeProp) => {
						if (typeProp !== 'name' && x3jsType[typeProp] != null && instance[typeProp]) instance[typeProp](_, x3jsType[typeProp]);
					});
					break;
				default:
					throw new Error(`${k}: invalid type: ${descProp.type}`);
			}
		} catch (ex) {
			console.error(`error while setting property ${name}: ${ex.message}`);
			// for now, just ignore property
			//throw ex;
		}
	});
	Object.keys(descriptor.collections || {}).forEach_(_, (_, k) => {
		const name = prefix ? prefix + util.pascalize(k) : k;
		const descCol = descriptor.collections[k];
		const instCol = instance[name](_);
		(meta[descCol.metaCode] || []).forEach_(_, (_, row) => {
			if (descCol.dictIgnore && descCol.dictIgnore(row)) return;
			const rowInst = instCol.add(_);
			exports.fillFromMeta(_, rowInst, descCol, superv, row);
		});	
	});
}

exports.fillFromFileData = function(_, instance, descriptor, superv, data, prefix) {
	Object.keys(descriptor.properties).forEach_(_, (_, k) => {
		const name = prefix ? prefix + util.pascalize(k) : k;
		try {
			const descProp = descriptor.properties[k];
			var value = data[k];
			switch (descProp.type) {
				case 'string':
				case 'boolean':
				case 'integer':
				case 'enum':
					if (value === undefined) return;
					instance[name](_, value);
					break;
				case 'flags':
					if (value === undefined) return;
					value = value.split(',')
					Object.keys(descProp.dictCodes).forEach_(_, (_, flag) => {
						instance[name + util.pascalize(flag)](_, value.indexOf(flag) >= 0);
					});
					break;
				case 'object':
					exports.fillFromFileData(_, instance, descProp, superv, data, name);
					break;
				case 'type':
					if (value === undefined) return;
					instance[name](_, value);
					['enum', 'typeCode', 'maxLength', 'precision', 'scale'].forEach_(_, (_, atb) => {
						if (data[atb] !== undefined) instance[atb](_, data[atb]);
					});
					break;
				default:
					throw new Error(`${k}: invalid type: ${descProp.type}`);
			}
		} catch (ex) {
			console.error(`error while setting property ${name}: ${ex.message}`);
			// for now, just ignore property
			//throw ex;
		}
	});
	Object.keys(descriptor.collections || {}).forEach_(_, (_, k) => {
		const name = prefix ? prefix + util.pascalize(k) : k;
		const descCol = descriptor.collections[k];
		const instCol = instance[name](_);
		if (descCol.key) {
			Object.keys(data[k]).forEach_(_, (_, kk) => {
				var row = data[k][kk];
				const rowInst = instCol.add(_);
				rowInst[descCol.key](_, kk);
				exports.fillFromFileData(_, rowInst, descCol, superv, row);			
			});
		} else {
			console.error("FILLFROMFILEDATA NIY", name);
		}
	});
}

exports.sourceFilename = function(_, instance, subdir, superv) {
	const root = superv.directories.jsLocal || superv.directories.jsShared;
	return fsp.join(root, instance.module(_) || 'undefined', subdir, instance.name(_) + '.x3js');
}

exports.getSupervisor = function(_, endpoint) {
	if (!endpoint.useEtna(_)) throw new Error("operation not available on current endpoint");
	const conf = endpoint.getEtnaConfig(_, globals.context.request.session);
	//console.error("SUPERVISOR CONF", conf);
	const superv = supervisor.create(_, conf);
	ACTX.init(_, conf.session, superv);
	return superv;
}

exports.mergeData = function(d1, desc, d2, prefix) {
	const merged = Object.assign({}, d1);
	if (d2 === undefined) return merged;
	Object.keys(desc.properties).forEach(k => {
		const prop = desc.properties[k];
		switch (prop.type) {
			case 'string':
			case 'boolean':
			case 'integer':
			case 'enum':
				const v1 = d1[k];
				const v2 = d2[k];
				merged[k] = v2 != undefined ? v2 : v1;
				break;
			case 'object':
				exports.mergeData(d1, prop, d2, prefix ? prefix + util.pascalize(k) : k);
				break;
			case 'flags':
				merged[k] = Object.keys(prop.dictCodes).filter(flag => {
					const name = k + util.pascalize(flag);
					return d2[name] === true;
				}).join(',');
				break;
			case 'type':
				{
					const v1 = d1[k];
					const v2 = d2[k];
					merged[k] = v2 !== undefined ? v2 : v1;
					if (d2.enum) merged.enum = d2.enum;
					if (d2.typeCode) merged.typeCode = d2.typeCode;
					if (d2.maxLength) merged.maxLength = d2.maxLength;
					if (d2.precision) merged.precision = d2.precision;
					if (d2.scale) merged.scale = d2.scale;
					// see later about other attribues
				}
				break;
			default:
				throw new Error(`${k}: invalid type ${prop.type}`);
		}
	});
	Object.keys(desc.collections || {}).forEach(k => {
		const coln = desc.collections[k];
		if (!d2[k]) return;
		if (!coln.key) {
			// do not try to match old elements, replace whole list
			merged[k] = d2[k].map(elt => exports.mergeData({}, coln, elt, ''));
		} else {
			d2[k].forEach(elt => {
				const key = elt[coln.key];
				if (key) {
					merged[k] = merged[k] || {};
					merged[k][key] = exports.mergeData(merged[key] || {}, coln, elt, '');
				}
			});
		}
	});
	return merged;
}


