"use strict";
const supervisor = require("etna/lib/supervisor/supervisor");
const util = require('etna/lib/supervisor/util');
const x3jsUtil = require('etna/lib/x3js/util');
const entityParser = require('etna/lib/x3js/entity-parser');
const codeGen = require('etna/lib/x3js/entity-codegen');
const systemEnums = require('./system-enums');
const fsp = require('path');
const fs = require('fs');
const ACTX = require("etna/lib/supervisor/builtins/ACTX");
const globals = require('streamline-runtime').globals;
const crypto = require('crypto');
const entityHelper = exports;


function rawEnum(name) {
	const [enumModule, enumName] = name.split('.');
	if (enumModule !== 'system') throw new Error(`bad enum module: ${enumModule}`);
	const enu = systemEnums[enumName];
	if (!enu) throw new Error(`system enum not found: ${enumName}`);
	return enu;
}

function entityEnum(name) {
	const enu = rawEnum(name);
	return Object.keys(enu).map(k => ({
		$value: k[0].toLowerCase() + k.substring(1),
		$title: util.camelToKebab(k, ' '),
	}));
}

function enumValueFromMeta(name, val) {
	const enu = rawEnum(name);
	const key = Object.keys(enu).filter(k => enu[k] === val)[0];
	if (!key) throw new Error(`${name}: bad enum value: ${val}`);
	return key[0].toLowerCase() + key.substring(1);
}

function enumValueToMeta(name, val) {
	const enu = rawEnum(name);
	if (typeof val !== 'string') throw new Error(`${name}: bad enum value type: ${val && typeof val}`);
	const key = val[0].toUpperCase() + val.substring(1) 
	if (!enu[key]) throw new Error(`${name}: bad enum value: ${val}`);
	return enu[key];
}

function eventName(_, instance, name) {
	if (typeof instance.name !== 'function') throw new Error(`${instance._meta.name}: name property missing`);
	return instance._parent ? instance.name(_) + util.pascalize(name) : name;
}

const TYPE_PROPS = ['enum', 'typeCode', 'maxLength', 'precision', 'scale'];

entityHelper.addProperties = function(entity, descriptor, prefix) {
	descriptor.rules = descriptor.rules || {};
	Object.keys(descriptor.properties).forEach(k => {
		const name = prefix ? prefix + util.pascalize(k) : k;
		const descProp = descriptor.properties[k];
		if (entity.$properties[name]) {
			return;
		}
		if (descProp.type === 'flags') {
			Object.keys(descProp.dictCodes).forEach(flag => {
				entity.$properties[k + util.pascalize(flag)] = {
					$title: util.camelToKebab(flag, ' '),
					$type: 'boolean',
					$isReadOnly: descriptor.rules.readOnlyProperty,
				};
			});
		} else if (descProp.type === 'event') {
			const title = util.camelToKebab(k, ' ');
			entity.$properties[name + 'Enabled'] = {
				$type: 'boolean',
				$title: title,
				$default: false,
				$isDisabled(_, instance) {
					return !instance.name(_);
				},
				$propagate(_, instance, value) {
					if (value && !instance[name](_)) {
						instance[name](_, eventName(_, instance, k));
					} else if (!value) {						
						instance[name](_, '');
					}
				},
			};
			entity.$properties[name] = {
				$type: 'string',
				$title: title,
				$default: '',
				$isDisabled(_, instance) {
					return !instance.name(_) || !instance[name + 'Enabled'](_);
				},
			};
		} else if (descProp.type === 'object') {
			entityHelper.addProperties(entity, descProp, name);
		} else {
			const entityProp = entity.$properties[name] = {
				$title: descProp.title || util.camelToKebab(name, ' '),
			};
			switch (descProp.type) {
				case 'string':
				case 'boolean':
				case 'integer':
					entityProp.$type = descProp.type;
					break;
				case 'enum':
					entityProp.$type = 'string';
					entityProp.$enum = entityEnum(descProp.enum);
					break;
				case 'type':
					entityProp.$type = 'string';
					entityProp.$enum = entityEnum('system.X3jsType');
					if (entity.$properties.enum) throw new Error('enum property already exists');
					entity.$properties.enum = {
						$title: 'enumeration',
						$type: 'string',
					};
					if (entity.$properties.typeCode) throw new Error('typeCode property already exists');
					entity.$properties.typeCode = {
						$title: 'type code',
						$type: 'string',
						$isReadOnly: descriptor.rules.readOnlyProperty,
					};
					if (entity.$properties.maxLength) throw new Error('maxLength property already exists');
					entity.$properties.maxLength = {
						$title: 'max length',
						$type: 'integer',
						$isNullable: true, 
						$isReadOnly: descriptor.rules.readOnlyProperty,
					};
					if (entity.$properties.precision) throw new Error('precision property already exists');
					entity.$properties.precision = {
						$title: 'precision',
						$type: 'integer',
						$isNullable: true, 
						$isReadOnly: descriptor.rules.readOnlyProperty,
					};
					if (entity.$properties.scale) throw new Error('scale property already exists');
					entity.$properties.scale = {
						$title: 'scale',
						$type: 'integer',
						$isNullable: true, 
						$isReadOnly: descriptor.rules.readOnlyProperty,
					};
					// class code is used to build reference.
					break;
				default:
					throw new Error(`${name}: invalid type: ${descProp.type}`);
			}
			entityProp.$isReadOnly = descriptor.rules.readOnlyProperty;
		}
	});
}


entityHelper.fillEntity = function(entity, descriptor, prefix) {
	entityHelper.addProperties(entity, descriptor, prefix);
	if (descriptor.hasSourceFile) {
		entity.$services.reloadSource = {
			$method: "POST",
			$isMethod: true,
			$facets: ["$edit"],
			$title: "Reload source",
			$permanent: true,
			$confirm: "You source edits will be lost. Do you want to continue?",
			$execute(_, context, instance) {
				entityHelper.reloadSource(_, descriptor, instance);
			},
		};
		entity.$services.saveSource = {
			$method: "POST",
			$isMethod: true,
			$facets: ["$edit"],
			$title: "Save source",
			$permanent: true,
			$confirm:  "Source file will be overwritten. Do you want to continue?",
			$execute(_, context, instance) {
				entityHelper.saveSource(_, descriptor, instance);
			},
		};
	}
};

entityHelper.metaToCanonical = function(_, superv, descriptor, meta) {
	const dest = {};
	Object.keys(descriptor.properties).forEach_(_, (_, name) => {
		try {
			const descProp = descriptor.properties[name];
			var value = descProp.dictCode && meta[descProp.dictCode];
			switch (descProp.type) {
				case 'string':
					if (!descProp.dictCode) return;
					switch (descProp.localization) {
						case 'system':
							dest[name] = superv.loadText(_, value, 'ENG');
							break;
						case undefined:
							dest[name] = value;
							break;
						default:
							throw new Error(`${name}: invalid localization: ${descProp.localization}`);
					}
					break;
				case 'boolean':
					if (!descProp.dictCode) return;
					switch (descProp.mapping) {
						case 'addressOrValue':
							// 1: byAddress => true
							// 2: byValue => false
							dest[name] = value === 1;
							break;
						default:
							dest[name] = x3jsUtil.boolOut(value, false);
							break;
					}
					break;
				case 'integer':
					if (!descProp.dictCode) return;
					dest[name] = value;
					break;
				case 'enum':
					if (!descProp.dictCode) return;
					switch (descProp.mapping) {
						case 'typtyp':
							const x3jsType = x3jsUtil.x3jsTypeNames[value];
							if (x3jsType == null) throw new Error(`${name}: invalid type value: ${JSON.stringify(meta)}`);
							dest[name] = x3jsType;
							break;
						default:
							dest[name] = enumValueFromMeta(descProp.enum, value);
							break;
					}
					break;
				case 'flags':
					dest[name] = Object.keys(descProp.dictCodes).filter(flag => meta[descProp.dictCodes[flag]] === 2).join(','); 
					break;
				case 'object':
					dest[name] = entityHelper.metaToCanonical(_, superv, descProp, meta);
					break;
				case 'event':
					break;
				case 'type':
					const typeCode = meta[descProp.dict.typeCode];
					var x3jsType;
					if (!typeCode) {
						const classCode = meta[descProp.dict.classCode];
						if (!classCode) throw new Error(`invalid type code: ${JSON.stringify(meta)}`);
						x3jsType = {
							name: 'instance',
							classCode: classCode,
							maxLength: 0,
						};
					} else {
						const metaType = superv.load(_, 'Type', typeCode);
						if (!metaType) throw new Error(`type not found ${typeCode}`)
						x3jsType = x3jsUtil.x3jsType(metaType, meta[descProp.dict.enum], meta[descProp.dict.maxLength]);
						// dont get length from type if string. Otherwise we won't roundtrip correctly.
						if (x3jsType.name === 'string') x3jsType.maxLength = meta[descProp.dict.maxLength];
					}
					dest[name] = x3jsType.name;
					Object.keys(x3jsType).forEach_(_, (_, typeProp) => {
						if (typeProp !== 'name' && x3jsType[typeProp] != null) dest[typeProp] = x3jsType[typeProp];
					});
					break;
				default:
					throw new Error(`${k}: invalid type: ${descProp.type}`);
			}
		} catch (ex) {
			console.error(`error while setting property ${name}: ${ex.message}`);
			// for now, just ignore property
			//throw ex;
		}
	});
	Object.keys(descriptor.collections || {}).forEach_(_, (_, name) => {
		const descCol = descriptor.collections[name];
		if (descCol.mapping === 'denormalized') {
			dest[name] = [];
			const count = meta[descCol.countCode];
			if (count === 0) return;
			for (var i = 0; i < count; i++) {
				const row = Object.keys(descCol.properties).reduce((r, k) => {
					const prop = descCol.properties[k];
					r[prop.dictCode] = meta[prop.dictCode][i];
					return r;
				}, []);
				dest[name][i] = entityHelper.metaToCanonical(_, superv, descCol, row);
			}
		} else {
			const items = meta[descCol.metaCode] || [];
			if (descCol.orderCode) items.sort((it1, it2) => (it1[descCol.orderCode] || 0) - (it2[descCol.orderCode] || 0));
			items.forEach_(_, (_, row, i) => {
				if (descCol.dictIgnore && descCol.dictIgnore(row)) return;
				if (descCol.key) {
					const key = row[key] || ('#' + i);
					dest[name] = dest[name] || {};
					dest[name][key] = entityHelper.metaToCanonical(_, superv, descCol, row);
				} else {
					dest[name] = dest[name] || [];
					dest[name].push(entityHelper.metaToCanonical(_, superv, descCol, row));
				}
			});	
		}
	});
	return dest;
}

function defaultTypeCode(type) {
	switch ('' + type) {
		case 'boolean': return 'M';
		case 'enum': return 'M';
		case 'decimal': return 'DCB';
		case 'date': return 'D';
		case 'instance': return '';
		default: return '' + type;
	}
}

function defaultTypeLength(code) {
	switch (code) {
		case 'ABIMG': return 1;
		case 'C': return 4;
		case 'M': return 4;
		case 'L': return 5; // integer
		default: return 0;
	}
}

entityHelper.canonicalToMeta = function(_, superv, descriptor, data, parent) {
	const dest = {};
	if (descriptor.parentCodes) {
		Object.keys(descriptor.parentCodes).forEach(pc =>  dest[pc] = parent[descriptor.parentCodes[pc]]);
	}

	Object.keys(descriptor.properties).forEach_(_, (_, name) => {
		try {
			const descProp = descriptor.properties[name];
			const dictCode = descProp.dictCode;
			var value = data[name];
			switch (descProp.type) {
				case 'string':
					if (!dictCode) return;
					switch (descProp.localization) {
						case 'system':
							dest[dictCode] = -1; // id was lost
							break;
						case undefined:
							dest[dictCode] = value;
							break;
						default:
							throw new Error(`${name}: invalid localization: ${descProp.localization}`);
					}
					break;
				case 'boolean':
					if (!dictCode) return;
					switch (descProp.mapping) {
						case 'addressOrValue':
							// 1: byAddress => true
							// 2: byValue => false
							dest[dictCode] = value === 2 ? 1 : 2;
							break;
						default:
							dest[dictCode] = x3jsUtil.boolIn(value);
							break;
					}
					break;
				case 'integer':
					if (!dictCode) return;
					dest[dictCode] = value;
					break;
				case 'enum':
					if (!dictCode) return;
					switch (descProp.mapping) {
						case 'typtyp':
							const x3jsType = x3jsUtil.x3jsTypeIds[value];
							if (x3jsType == null) throw new Error(`${name}: invalid type value: ${JSON.stringify(data)}`);
							dest[dictCode] = parseInt(x3jsType);
							break;
						default:
							dest[dictCode] = enumValueToMeta(descProp.enum, value);
							break;
					}
					break;
				case 'flags':
					const flags = value ? value.split(',') : [];
					Object.keys(descProp.dictCodes).forEach(flag => {
						dest[descProp.dictCodes[flag]] = flags.indexOf(flag) >= 0 ? 2 : 1;
					});
					break;
				case 'object':
					Object.assign(dest, entityHelper.canonicalToMeta(_, superv, descProp, value));
					break;
				case 'event':
					break;
				case 'type':
					dest[descProp.dict.typeCode] = data.typeCode || defaultTypeCode(value);
					dest[descProp.dict.classCode] = data.classCode || '';
					dest[descProp.dict.enum] = value === 'boolean' ? 1: data.enum || 0;
					dest[descProp.dict.maxLength] = value === 'decimal' 
					? data.precision + (data.scale ? '.' + data.scale : '') 
					: (data.maxLength || defaultTypeLength(data.typeCode));
					break;
				default:
					throw new Error(`${k}: invalid type: ${descProp.type}`);
			}
		} catch (ex) {
			console.error(`error while setting property ${name}: ${ex.message}`);
			// for now, just ignore property
			//throw ex;
		}
	});
	Object.keys(descriptor.collections || {}).forEach_(_, (_, name) => {
		const descCol = descriptor.collections[name];
		if (descCol.mapping === 'denormalized') {
			if (!data[name] || data[name].length === 0) return;
			dest[descCol.countCode] = data[name].length;
			const mapped = data[name].map_(_, (_, row) => entityHelper.canonicalToMeta(_, superv, descCol, row));
			Object.keys(descCol.properties).forEach_(_, (_, k) => {
				const prop = descCol.properties[k];
				dest[prop.dictCode] = mapped.map(row => row[prop.dictCode]);
			});	
		} else {
			if (descCol.key) {
				dest[descCol.metaCode] = Object.keys(data[name] || {}).map_(_, (_, k, i) => {
					const row = data[name][k];
					const obj = entityHelper.canonicalToMeta(_, superv, descCol, row, dest);
					if (descCol.orderCode) obj[descCol.orderCode] = i + 1;
					if (k[0] !== '#') obj._proxyName = k;
					return obj;

				});
			} else {
				if (!data[name] || data[name].length === 0) return;
				dest[descCol.metaCode] = data[name].map_(_, (_, row, i) => {
					const obj = entityHelper.canonicalToMeta(_, superv, descCol, row, dest);
					if (descCol.orderCode) obj[descCol.orderCode] = i + 1;
					return obj;
				});
			}
		}
	});
	return dest;
}


entityHelper.fillFromMeta = function(_, instance, descriptor, superv, meta) {
	const obj = entityHelper.metaToCanonical(_, superv, descriptor, meta);
	entityHelper.fillFromFileData(_, instance, descriptor, superv, obj);
}

entityHelper.fillFromFileData = function(_, instance, descriptor, superv, data, prefix) {
	Object.keys(descriptor.properties).forEach_(_, (_, k) => {
		const name = prefix ? prefix + util.pascalize(k) : k;
		try {
			const descProp = descriptor.properties[k];
			var value = data[k];
			switch (descProp.type) {
				case 'string':
				case 'boolean':
				case 'integer':
				case 'enum':
					if (value === undefined) return;
					instance[name](_, value);
					break;
				case 'flags':
					if (value === undefined) return;
					value = value.split(',')
					Object.keys(descProp.dictCodes).forEach_(_, (_, flag) => {
						instance[name + util.pascalize(flag)](_, value.indexOf(flag) >= 0);
					});
					break;
				case 'object':
					entityHelper.fillFromFileData(_, instance, descProp, superv, data, name);
					break;
				case 'event':
					instance[name + 'Enabled'](_, !!value);
					instance[name](_, value);
					break;
				case 'type':
					if (value === undefined) return;
					instance[name](_, value);
					TYPE_PROPS.forEach_(_, (_, atb) => {
						if (data[atb] !== undefined) instance[atb](_, data[atb]);
					});
					break;
				default:
					throw new Error(`${k}: invalid type: ${descProp.type}`);
			}
		} catch (ex) {
			console.error(`error while setting property ${name}: ${ex.message}`);
			// for now, just ignore property
			//throw ex;
		}
	});
	Object.keys(descriptor.collections || {}).forEach_(_, (_, k) => {
		const name = prefix ? prefix + util.pascalize(k) : k;
		const descCol = descriptor.collections[k];
		const instCol = instance[name](_);
		if (descCol.key) {
			Object.keys(data[k] || {}).forEach_(_, (_, kk) => {
				var row = data[k][kk];
				const rowInst = instCol.add(_);
				if (kk[0] !== '#') rowInst[descCol.key](_, kk);
				entityHelper.fillFromFileData(_, rowInst, descCol, superv, row);			
			});
		} else {
			if (data[k]) data[k].forEach_(_, (_, row) => {
				const rowInst = instCol.add(_);
				entityHelper.fillFromFileData(_, rowInst, descCol, superv, row);
			});
		}
	});
}

entityHelper.sourceFilename = function(_, instance, subdir, superv) {
	const root = superv.directories.jsLocal || superv.directories.jsShared;
	return fsp.join(root, instance.module(_) || 'undefined', subdir, instance.name(_) + '.x3js');
}

entityHelper.getSupervisor = function(_, endpoint) {
	if (!endpoint.useEtna(_)) throw new Error("operation not available on current endpoint");
	const conf = endpoint.getEtnaConfig(_, globals.context.request.session);
	//console.error("SUPERVISOR CONF", conf);
	const superv = supervisor.create(_, conf);
	ACTX.init(_, conf.session, superv);
	return superv;
}

entityHelper.deserializedToData = function(desc, d2, prefix = '') {
	const merged = {};
	if (d2 === undefined) return merged;
	Object.keys(desc.properties).forEach(k => {
		const name = prefix ? prefix + util.pascalize(k) : k		
		const prop = desc.properties[k];
		switch (prop.type) {
			case 'object':
				merged[k] = entityHelper.deserializedToData(prop, d2, name);
				break;
			case 'type':
				if (k !== name) throw new Error(`internal error: type not allowed in subobject`);
				merged[k] = d2[name];
				TYPE_PROPS.forEach(tk => merged[tk] = d2[tk]);
				break;
			default:
				merged[k] = d2[name];
				break;
		}
	});
	Object.keys(desc.collections || {}).forEach(k => {
		const coln = desc.collections[k];
		if (!d2[k]) return;
		if (!coln.key) {
			// do not try to match old elements, replace whole list
			merged[k] = d2[k].map(elt => entityHelper.deserializedToData(coln, elt));
		} else {
			d2[k].forEach(elt => {
				const key = elt[coln.key];
				if (key) {
					merged[k] = merged[k] || {};
					merged[k][key] = entityHelper.deserializedToData(coln, elt);
				}
			});
		}
	});
	return merged;
}

entityHelper.mergeData = function(d1, desc, d2) {
	const merged = Object.assign({}, d1);
	if (d2 === undefined) return merged;
	Object.keys(desc.properties).forEach(k => {
		const prop = desc.properties[k];
		switch (prop.type) {
			case 'string':
			case 'boolean':
			case 'integer':
			case 'enum':
			case 'event':
				const v1 = d1[k];
				const v2 = d2[k];
				merged[k] = v2 !== undefined ? v2 : v1;
				break;
			case 'object':
				merged[k] = entityHelper.mergeData(d1[k] || {}, prop, d2[k]);
				break;
			case 'flags':
				merged[k] = Object.keys(prop.dictCodes).filter(flag => {
					const flagName = k + util.pascalize(flag);
					return d2[flagName] === true;
				}).join(',');
				break;
			case 'type':
				{
					const v1 = d1[k];
					const v2 = d2[k];
					merged[k] = v2 !== undefined ? v2 : v1;
					if (d2.enum) merged.enum = d2.enum;
					if (d2.typeCode) merged.typeCode = d2.typeCode;
					if (d2.maxLength) merged.maxLength = d2.maxLength;
					if (d2.precision) merged.precision = d2.precision;
					if (d2.scale) merged.scale = d2.scale;
					// see later about other attribues
				}
				break;
			default:
				throw new Error(`${k}: invalid type ${prop.type}`);
		}
	});
	Object.keys(desc.collections || {}).forEach(k => {
		const coln = desc.collections[k];
		if (!d2[k]) return;
		if (!coln.key) {
			// do not try to match old elements, replace whole list
			merged[k] = d2[k].map(elt => entityHelper.mergeData({}, coln, elt));
		} else {
			merged[k] = {};
			Object.keys(d2[k]).forEach(key => {
				merged[k][key] = entityHelper.mergeData(merged[k][key] || {}, coln, d2[k][key]);
			});
		}
	});
	return merged;
}

function computeHash(code) {
	return crypto.createHash('sha1').update(code, 'utf8').digest('hex');
}

entityHelper.reloadSource = function(_, desc, instance) {
	instance.sourceState(_, '');
}

entityHelper.saveSource = function(_, desc, instance) {
	const superv = entityHelper.getSupervisor(_, instance.endpoint(_));
	const filePath = entityHelper.sourceFilename(_, instance, desc.subdir, superv);
	const source = instance.source(_);	
	fs.writeFile(filePath, instance.source(_), 'utf8', _);
	instance.sourceState(_, computeHash(source));
	instance.$addDiagnose("success", `${filePath} has been saved.`);
}

entityHelper.sourceFileHasChanged = function(_, desc, instance) {
	const superv = entityHelper.getSupervisor(_, instance.endpoint(_));
	const filePath = entityHelper.sourceFilename(_, instance,  desc.subdir, superv);
	if (!fs.exists(filePath, _, _)) return false;
	const source = fs.readFile(filePath, 'utf8', _);
	return computeHash(source) != instance.sourceState(_);
}

entityHelper.updateAll = function(_, desc, instance, saving) {
	if (instance.name(_) === '') {
		instance.status(_, '4gl');
	} else if (instance.status(_) === '4gl') {
		instance.status(_, 'incomplete');
	}
	if (instance.status(_) === '4gl') {
		instance.source(_, `// Source not generated. X3JS name has not been set.`);
		// do not save to file.
		return;
	}

	// don't go further when synchronizing
	if (globals.context.dontGenerateX3jsSource) return;

	const superv = entityHelper.getSupervisor(_, instance.endpoint(_));
	const filePath = entityHelper.sourceFilename(_, instance, desc.subdir, superv);

	const missing = instance.missingMappings(_);
	const conflicts = instance.conflictingMappings(_);
	if (missing.length > 0 || conflicts.length > 0) instance.status(_, 'incomplete');
	else if (instance.status(_) === 'incomplete') instance.status(_, 'mapped');
	if (saving) conflicts.forEach(conflict => instance.$addError(conflict));

	var parsed;
	const state = instance.sourceState(_);
	var source;
	if (fs.exists(filePath, _, _)) {
		source = fs.readFile(filePath, 'utf8', _);
		const hash = computeHash(source);
		if (!state) {
			instance.sourceState(_, hash);
			instance.source(_, source);
		} else {
			if (state !== hash) {
				instance.$addError(`${filePath}: file was modified on disk. Use "reload source" or "save source" to resolve conflict`);
			}
			source = instance.source(_);
		}
	} else {
		if (!state) {
			source = codeGen.template(_, desc);
			instance.sourceState(_, computeHash(source));
			instance.source(_, source);
		} else {
			source = instance.source(_);
		}
	}
	try {
		parsed = entityParser.parseSource(_, source, filePath, desc);
	} catch (ex) {
		console.error(ex.stack);
		throw ex.isParseError ? ex : new Error(`${filePath}: ${ex.message}`);
	}
	const instanceData = entityHelper.deserializedToData(desc, instance.serializeInstance(_));
	//console.error("INSTANCEDATA", instanceData);
	parsed.data = entityHelper.mergeData(parsed.data, desc, instanceData);
	//console.error("MERGEDDATA", parsed.data);
	const output = codeGen.generateSourceCode(_, parsed, desc);
	var source = output.code;
	// remove old comments
	source = source.replace(/\/\/.*: source is incomplete.*\r?\n(\/\/.*\r?\n)*?\/\/ \d+ elements missing\.(\r?\n)*/, '');
	// insert new comments
	if (instance.status(_) === 'incomplete') {
		const messages = missing.concat(conflicts);
		source = `// ${instance.name(_)}: source is incomplete and cannot be saved to file. Following mapping information is missing: ${
			'\n' + messages.map(s => '// * ' + s).join('\n') + 
			'\n' + `// ${messages.length} elements missing.` + '\n\n'
		}` + source;
	}
	instance.source(_, source);

	if (saving && instance.status(_) !== 'incomplete') {
		codeGen.generateSourceFile(_, parsed.file, source);
		instance.sourceState(_, computeHash(source));
	}
}


