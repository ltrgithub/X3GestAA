"use strict";

const supervisor = require("etna/lib/supervisor/supervisor");
const util = require('etna/lib/supervisor/util');
const x3jsUtil = require('etna/lib/x3js/util');
const entityParser = require('etna/lib/x3js/entity-parser');
const codeGen = require('etna/lib/x3js/entity-codegen');
const localeGen = require('etna/lib/x3js/entity-locale-gen');
const systemEnums = require('./system-enums');
const fsp = require('path');
const fs = require('fs');
const ezm = require('ez-mongodb');
const ACTX = require("etna/lib/supervisor/builtins/ACTX");
const globals = require('streamline-runtime').globals;
const crypto = require('crypto');
const entityHelper = exports;

function rawEnum(name) {
	const [enumModule, enumName] = name.split('.');
	if (enumModule !== 'system') throw new Error(`bad enum module: ${ enumModule }`);
	const enu = systemEnums[enumName];
	if (!enu) throw new Error(`system enum not found: ${ enumName }`);
	return enu;
}

function entityEnum(name) {
	const enu = rawEnum(name);
	return Object.keys(enu).map(k => ({
		$value: k[0].toLowerCase() + k.substring(1),
		$title: util.camelToKebab(k, ' ')
	}));
}

function enumValueFromMeta(name, val) {
	const enu = rawEnum(name);
	const key = Object.keys(enu).filter(k => enu[k] === val)[0];
	if (!key) throw new Error(`${ name }: bad enum value: ${ val }`);
	return key[0].toLowerCase() + key.substring(1);
}

function enumValueToMeta(name, val) {
	const enu = rawEnum(name);
	if (typeof val !== 'string') throw new Error(`${ name }: bad enum value type: ${ val && typeof val }`);
	const key = val[0].toUpperCase() + val.substring(1);
	if (!enu[key]) throw new Error(`${ name }: bad enum value: ${ val }`);
	return enu[key];
}

function eventName(_, instance, name) {
	if (typeof instance.name !== 'function') throw new Error(`${ instance._meta.name }: name property missing`);
	return instance._parent ? instance.name(_) + util.pascalize(name) : name;
}

const TYPE_PROPS_STRING = ['enum', 'typeCode', 'classCode'];
const TYPE_PROPS_INT = ['maxLength', 'precision', 'scale'];
const TYPE_PROPS = TYPE_PROPS_STRING.concat(TYPE_PROPS_INT);

function addProperties(entity, descriptor, prefix) {
	descriptor.rules = descriptor.rules || {};
	entity.$properties = entity.$properties || {};
	Object.keys(descriptor.properties).forEach(k => {
		const name = prefix ? prefix + util.pascalize(k) : k;
		const descProp = descriptor.properties[k];
		if (entity.$properties[name]) {
			return;
		}
		if (descProp.type === 'flags') {
			(descProp.flags || Object.keys(descProp.dictCodes)).forEach(flag => {
				entity.$properties[k + util.pascalize(flag)] = {
					$title: util.camelToKebab(flag, ' '),
					$type: 'boolean',
					$isReadOnly: descriptor.rules.readOnlyProperty
				};
			});
		} else if (descProp.type === 'event') {
			const title = util.camelToKebab(k, ' ');
			entity.$properties[name + 'Enabled'] = {
				$type: 'boolean',
				$title: title,
				$default: false,
				$isDisabled(_, instance) {
					return !instance.name(_);
				},
				$propagate(_, instance, value) {
					if (value && !instance[name](_)) {
						instance[name](_, eventName(_, instance, k));
					} else if (!value) {
						instance[name](_, '');
					}
				}
			};
			entity.$properties[name] = {
				$type: 'string',
				$title: title,
				$default: '',
				$isDisabled(_, instance) {
					return !instance.name(_) || !instance[name + 'Enabled'](_);
				}
			};
		} else if (descProp.type === 'object') {
			addProperties(entity, descProp, name);
		} else {
			const entityProp = entity.$properties[name] = {
				$title: descProp.title || util.camelToKebab(name, ' ')
			};
			switch (descProp.type) {
				case 'string':
				case 'boolean':
				case 'integer':
					entityProp.$type = descProp.type;
					break;
				case 'enum':
					entityProp.$type = 'string';
					entityProp.$enum = entityEnum(descProp.enum);
					break;
				case 'type':
					entityProp.$type = 'string';
					entityProp.$enum = entityEnum('system.X3jsType');
					if (entity.$properties.enum) throw new Error('enum property already exists');
					entity.$properties.enum = {
						$title: 'enumeration',
						$type: 'string'
					};
					if (entity.$properties.typeCode) throw new Error('typeCode property already exists');
					entity.$properties.typeCode = {
						$title: 'type code',
						$type: 'string',
						$isReadOnly: descriptor.rules.readOnlyProperty
					};
					if (entity.$properties.maxLength) throw new Error('maxLength property already exists');
					entity.$properties.maxLength = {
						$title: 'max length',
						$type: 'integer',
						$isNullable: true,
						$isReadOnly: descriptor.rules.readOnlyProperty
					};
					if (entity.$properties.precision) throw new Error('precision property already exists');
					entity.$properties.precision = {
						$title: 'precision',
						$type: 'integer',
						$isNullable: true,
						$isReadOnly: descriptor.rules.readOnlyProperty
					};
					if (entity.$properties.scale) throw new Error('scale property already exists');
					entity.$properties.scale = {
						$title: 'scale',
						$type: 'integer',
						$isNullable: true,
						$isReadOnly: descriptor.rules.readOnlyProperty
					};
					if (entity.$properties.classCode) throw new Error('scale property already exists');
					entity.$properties.classCode = {
						$title: 'class code',
						$type: 'string',
						$isNullable: true,
						$isReadOnly: descriptor.rules.readOnlyProperty
					};
					// class code is used to build reference.
					break;
				default:
					throw new Error(`${ name }: invalid type: ${ descProp.type }`);
			}
			if (descProp.defaultValue !== undefined) entityProp.$default = descProp.defaultValue;
			if (descProp.isMandatory) entityProp.$isMandatory = descProp.isMandatory;
			entityProp.$isReadOnly = descriptor.rules.readOnlyProperty;
		}
	});
}

entityHelper.fillEntity = function (entity, descriptor, prefix) {
	addProperties(entity, descriptor, prefix);
	if (descriptor.hasSourceFile) {
		entity.$services.reloadSource = {
			$method: "POST",
			$isMethod: true,
			$facets: ["$edit"],
			$title: "Reload source",
			$permanent: true,
			$confirm: "You source edits will be lost. Do you want to continue?",
			$execute(_, context, instance) {
				instance.sourceState(_, '');
				// updateAll will trigger reload
			}
		};
		entity.$services.saveSource = {
			$method: "POST",
			$isMethod: true,
			$facets: ["$edit"],
			$title: "Save source",
			$permanent: true,
			$confirm: "Source file will be overwritten. Do you want to continue?",
			$execute(_, context, instance) {
				entityHelper.fromCurrentSession(_, descriptor).saveInstanceSource(_, instance);
			}
		};
	}
	// add this one systematically, to simplify create
	entity.$init = function (_, wc, context) {
		if (context) wc.$fillFromParameters(_, context.query);
	};
};

const crudNames = {
	'C': 'create',
	'R': 'read',
	'U': 'update',
	'D': 'delete',
	'P': 'print',
	'T': 'duplicate'
};
const crudCodes = Object.keys(crudNames).reduce((r, k) => (r[crudNames[k]] = k, r), {});

function specialKeyToCanonical(row, keyCode) {
	const key = row[keyCode];
	switch (keyCode) {
		case 'CODMETSTD':
			if (!crudNames[key]) throw new Error(`invalid CRUD method code: ${ key }`);
			return crudNames[key];
		default:
			throw new Error(`invalid special key: ${ keyCode }`);
	}
}

function specialKeyFromCanonical(name, keyCode) {
	switch (keyCode) {
		case 'CODMETSTD':
			if (!crudCodes[name]) throw new Error(`invalid CRUD method name: ${ name }`);
			return crudCodes[name];
		default:
			throw new Error(`invalid special key: ${ keyCode }`);
	}
}

function defaultTypeCode(type) {
	switch ('' + type) {
		case 'boolean':
			return 'M';
		case 'enum':
			return 'M';
		case 'string':
			return 'A';
		case 'short':
			return 'C';
		case 'integer':
			return 'L';
		case 'decimal':
			return 'DCB';
		case 'date':
			return 'D';
		case 'datetime':
			return 'ADATIM';
		case 'uuid':
			return 'AUUID';
		case 'instance':
			return '';
		default:
			return '' + type;
	}
}

function defaultTypeLength(code) {
	switch (code) {
		case 'ABIMG':
			return 1;
		case 'C':
			return 4;
		case 'M':
			return 4;
		case 'L':
			return 5; // integer
		default:
			return 0;
	}
}

function genName(name, obj, allNames) {
	if (!name && obj.title) name = util.camelize(obj.title);
	if (!name) name = 'todo';
	const base = name;
	var i = 0;
	while (allNames[name]) name = base + ++i;
	allNames[name] = true;
	return name;
}

function metaToCanonical(_, superv, descriptor, meta) {
	const dest = {};
	Object.keys(descriptor.dictConstants || {}).forEach(k => {
		if (meta[k] !== descriptor.dictConstants[k]) throw new Error(`${ k }: invalid value: ${ meta[k] }`);
	});
	Object.keys(descriptor.properties).forEach_(_, (_, name) => {
		try {
			const descProp = descriptor.properties[name];
			var value = descProp.dictCode && meta[descProp.dictCode];
			switch (descProp.type) {
				case 'string':
					if (!descProp.dictCode) return;
					switch (descProp.localization) {
						case 'system':
							dest[name] = superv.loadText(_, value, 'ENG');
							break;
						case undefined:
							dest[name] = value;
							break;
						default:
							throw new Error(`${ name }: invalid localization: ${ descProp.localization }`);
					}
					break;
				case 'boolean':
					if (!descProp.dictCode) return;
					switch (descProp.mapping) {
						case 'addressOrValue':
							// 1: byAddress => true
							// 2: byValue => false
							dest[name] = value === 1;
							break;
						default:
							dest[name] = x3jsUtil.boolOut(value, false);
							break;
					}
					break;
				case 'integer':
					if (!descProp.dictCode) return;
					dest[name] = value;
					break;
				case 'enum':
					if (!descProp.dictCode) return;
					switch (descProp.mapping) {
						case 'typtyp':
							const x3jsType = x3jsUtil.x3jsTypeNames[value];
							if (x3jsType == null) throw new Error(`${ name }: invalid type value: ${ JSON.stringify(meta) }`);
							dest[name] = x3jsType;
							break;
						default:
							dest[name] = enumValueFromMeta(descProp.enum, value);
							break;
					}
					break;
				case 'flags':
					if (!descProp.dictCodes) return;
					dest[name] = Object.keys(descProp.dictCodes).filter(flag => meta[descProp.dictCodes[flag]] === 2).join(',');
					break;
				case 'object':
					dest[name] = metaToCanonical(_, superv, descProp, meta);
					break;
				case 'event':
					break;
				case 'type':
					const typeCode = meta[descProp.dict.typeCode];
					var x3jsType;
					if (!typeCode) {
						const classCode = meta[descProp.dict.classCode];
						if (!classCode) throw new Error(`invalid type code: ${ JSON.stringify(meta) }`);
						x3jsType = {
							name: 'instance',
							classCode: classCode,
							maxLength: 0
						};
					} else {
						const metaType = superv.load(_, 'Type', typeCode);
						if (!metaType) throw new Error(`type not found ${ typeCode }`);
						x3jsType = x3jsUtil.x3jsType(metaType, meta[descProp.dict.enum], meta[descProp.dict.maxLength]);
						// dont get length from type if string. Otherwise we won't roundtrip correctly.
						if (x3jsType.name === 'string') x3jsType.maxLength = meta[descProp.dict.maxLength];
					}
					dest[name] = x3jsType.name;
					TYPE_PROPS_STRING.forEach_(_, (_, typeProp) => {
						dest[typeProp] = x3jsType[typeProp] || '';
					});
					TYPE_PROPS_INT.forEach_(_, (_, typeProp) => {
						dest[typeProp] = x3jsType[typeProp] || 0;
					});
					break;
				default:
					throw new Error(`${ k }: invalid type: ${ descProp.type }`);
			}
		} catch (ex) {
			console.error(`error while setting property ${ name }: ${ ex.stack }`);
			// for now, just ignore property
			//throw ex;
		}
	});
	Object.keys(descriptor.collections || {}).forEach_(_, (_, name) => {
		const descCol = descriptor.collections[name];
		if (descCol.mapping === 'denormalized') {
			dest[name] = [];
			const count = meta[descCol.countCode];
			if (count === 0) return;
			for (var i = 0; i < count; i++) {
				const row = Object.keys(descCol.properties).reduce((r, k) => {
					const prop = descCol.properties[k];
					r[prop.dictCode] = meta[prop.dictCode][i];
					return r;
				}, []);
				dest[name][i] = metaToCanonical(_, superv, descCol, row);
			}
		} else if (descCol.metaCode) {
			if (!descCol.metaCode) return;
			const items = meta[descCol.metaCode] || [];
			if (descCol.orderCode) items.sort((it1, it2) => (it1[descCol.orderCode] || 0) - (it2[descCol.orderCode] || 0));
			const allNames = {};
			items.forEach_(_, (_, row, i) => {
				if (descCol.dictIgnore && descCol.dictIgnore(row)) return;
				if (descCol.key || descCol.specialKey) {
					const obj = metaToCanonical(_, superv, descCol, row);
					const key = descCol.key ? descCol.genName ? descCol.genName(row) : genName(row[descCol.key], obj, allNames) : specialKeyToCanonical(row, descCol.specialKey);
					dest[name] = dest[name] || {};
					dest[name][key] = obj;
				} else {
					dest[name] = dest[name] || [];
					dest[name].push(metaToCanonical(_, superv, descCol, row));
				}
			});
		}
	});
	return dest;
}

function canonicalToMeta(_, superv, descriptor, data, parent, jsName) {
	const dest = {};

	Object.keys(descriptor.parentCodes || {}).forEach(pc => dest[pc] = parent[descriptor.parentCodes[pc]]);
	Object.keys(descriptor.dictConstants || {}).forEach(k => dest[k] = descriptor.dictConstants[k]);

	Object.keys(descriptor.properties).forEach_(_, (_, name) => {
		try {
			const descProp = descriptor.properties[name];
			const dictCode = descProp.dictCode;
			var value = descProp.forMeta ? descProp.forMeta(data) : data[name];
			switch (descProp.type) {
				case 'string':
					if (!dictCode) return;
					switch (descProp.localization) {
						case 'system':
							dest[dictCode] = -1; // id was lost
							break;
						case undefined:
							dest[dictCode] = value || '';
							break;
						default:
							throw new Error(`${ name }: invalid localization: ${ descProp.localization }`);
					}
					break;
				case 'boolean':
					if (!dictCode) return;
					switch (descProp.mapping) {
						case 'addressOrValue':
							// 1: byAddress => true
							// 2: byValue => false
							dest[dictCode] = value === 2 ? 1 : 2;
							break;
						default:
							dest[dictCode] = x3jsUtil.boolIn(value);
							break;
					}
					break;
				case 'integer':
					if (!dictCode) return;
					dest[dictCode] = value || 0;
					break;
				case 'enum':
					if (!dictCode) return;
					switch (descProp.mapping) {
						case 'typtyp':
							const x3jsType = x3jsUtil.x3jsTypeIds[value];
							if (x3jsType == null) throw new Error(`${ name }: invalid type value: ${ JSON.stringify(data) }`);
							dest[dictCode] = parseInt(x3jsType);
							break;
						default:
							dest[dictCode] = enumValueToMeta(descProp.enum, value);
							break;
					}
					break;
				case 'flags':
					if (!descProp.dictCodes) return;
					const flags = value ? value.split(',') : [];
					Object.keys(descProp.dictCodes).forEach(flag => {
						dest[descProp.dictCodes[flag]] = flags.indexOf(flag) >= 0 ? 2 : 1;
					});
					break;
				case 'object':
					Object.assign(dest, canonicalToMeta(_, superv, descProp, value || {}));
					break;
				case 'event':
					break;
				case 'type':
					dest[descProp.dict.typeCode] = data.typeCode || defaultTypeCode(value);
					dest[descProp.dict.classCode] = data.classCode || '';
					dest[descProp.dict.enum] = value === 'boolean' ? 1 : data.enum || 0;
					dest[descProp.dict.maxLength] = value === 'decimal' ? data.precision + (data.scale ? '.' + data.scale : '') : data.maxLength || defaultTypeLength(data.typeCode);
					break;
				default:
					throw new Error(`${ k }: invalid type: ${ descProp.type }`);
			}
		} catch (ex) {
			console.error(`error while setting property ${ name }: ${ ex.message }`);
			// for now, just ignore property
			//throw ex;
		}
	});
	// generate a dictionary key if the data is pure X3JS
	if (descriptor.dictKey && !dest[descriptor.dictKey] && jsName) {
		dest[descriptor.dictKey] = 'X3JS_' + jsName.toUpperCase();
	}
	Object.keys(descriptor.collections || {}).forEach_(_, (_, name) => {
		const descCol = descriptor.collections[name];
		if (descCol.mapping === 'denormalized') {
			if (!data[name] || data[name].length === 0) return;
			dest[descCol.countCode] = data[name].length;
			const mapped = data[name].map_(_, (_, row) => canonicalToMeta(_, superv, descCol, row));
			Object.keys(descCol.properties).forEach_(_, (_, k) => {
				const prop = descCol.properties[k];
				dest[prop.dictCode] = mapped.map(row => row[prop.dictCode]);
			});
		} else {
			if (!descCol.metaCode) return;
			if (descCol.key || descCol.specialKey) {
				dest[descCol.metaCode] = Object.keys(data[name] || {}).map_(_, (_, k, i) => {
					const row = data[name][k];
					const obj = canonicalToMeta(_, superv, descCol, row, dest, k);
					if (descCol.orderCode) obj[descCol.orderCode] = i + 1;
					if (descCol.key && k[0] !== '#') obj._proxyName = k;
					if (descCol.specialKey) obj[descCol.specialKey] = specialKeyFromCanonical(k, descCol.specialKey);
					if (descCol.dictFinish) descCol.dictFinish(obj);
					return obj;
				});
			} else {
				if (!data[name] || data[name].length === 0) return;
				dest[descCol.metaCode] = data[name].map_(_, (_, row, i) => {
					const obj = canonicalToMeta(_, superv, descCol, row, dest);
					if (descCol.orderCode) obj[descCol.orderCode] = i + 1;
					if (descCol.dictFinish) descCol.dictFinish(obj);
					return obj;
				});
			}
		}
	});
	return dest;
}
function serializedToCanonical(desc, d2, prefix = '') {
	const merged = {};
	if (d2 === undefined) return merged;
	Object.keys(desc.properties).forEach(k => {
		const name = prefix ? prefix + util.pascalize(k) : k;
		const prop = desc.properties[k];
		switch (prop.type) {
			case 'object':
				merged[k] = serializedToCanonical(prop, d2, name);
				break;
			case 'type':
				if (k !== name) throw new Error(`internal error: type not allowed in subobject`);
				merged[k] = d2[name];
				TYPE_PROPS.forEach(tk => {
					if (d2[tk] !== undefined) merged[tk] = d2[tk];
				});
				break;
			case 'flags':
				merged[k] = (prop.flags || Object.keys(prop.dictCodes)).filter(flag => {
					const flagName = name + util.pascalize(flag);
					return d2[flagName] === true;
				}).join(',');
				break;
			default:
				if (d2[name] !== undefined) merged[k] = d2[name];
				break;
		}
	});
	Object.keys(desc.collections || {}).forEach(k => {
		const coln = desc.collections[k];
		if (coln.cardinality === 1) {
			if (d2[k]) merged[k] = serializedToCanonical(coln, d2[k]);
			return;
		}
		if (!d2[k] || !d2[k].length) return;
		if (coln.key || coln.specialKey) {
			d2[k].forEach((elt, i) => {
				const key = elt[coln.key || 'name'] || '#' + (i + 1);
				merged[k] = merged[k] || {};
				merged[k][key] = serializedToCanonical(coln, elt);
			});
		} else {
			// do not try to match old elements, replace whole list
			merged[k] = d2[k].map(elt => serializedToCanonical(coln, elt));
		}
	});
	return merged;
}

function mergeData(d1, desc, d2) {
	const merged = Object.assign({}, d1);
	if (d2 === undefined) return merged;
	Object.keys(desc.properties).forEach(k => {
		const prop = desc.properties[k];
		switch (prop.type) {
			case 'string':
			case 'boolean':
			case 'integer':
			case 'enum':
			case 'event':
			case 'flags':
				const v1 = d1[k];
				const v2 = d2[k];
				merged[k] = v2 !== undefined ? v2 : v1;
				break;
			case 'object':
				merged[k] = mergeData(d1[k] || {}, prop, d2[k]);
				break;
			/*
   case 'flags':
   merged[k] = (prop.flags || Object.keys(prop.dictCodes)).filter(flag => {
   	const flagName = k + util.pascalize(flag);
   	return d2[flagName] === true;
   }).join(',');
   break;*/
			case 'type':
				{
					const v1 = d1[k];
					const v2 = d2[k];
					merged[k] = v2 !== undefined ? v2 : v1;
					TYPE_PROPS.forEach(tp => {
						if (d2[tp]) merged[tp] = d2[tp];
					});
				}
				break;
			default:
				throw new Error(`${ k }: invalid type ${ prop.type }`);
		}
	});
	Object.keys(desc.collections || {}).forEach(k => {
		const coln = desc.collections[k];
		if (!d2[k]) return;
		if (coln.cardinality === 1) {
			merged[k] = mergeData({}, coln, d2[k]);
			return;
		}
		if (coln.key || coln.specialKey) {
			merged[k] = {};
			Object.keys(d2[k]).forEach(key => {
				merged[k][key] = mergeData(merged[k][key] || {}, coln, d2[k][key]);
			});
		} else {
			// do not try to match old elements, replace whole list
			merged[k] = d2[k].map(elt => mergeData({}, coln, elt));
		}
	});
	return merged;
}

function fillInstance(_, superv, descriptor, instance, data, prefix = '') {
	Object.keys(descriptor.properties).forEach_(_, (_, k) => {
		const name = prefix ? prefix + util.pascalize(k) : k;
		try {
			const descProp = descriptor.properties[k];
			var value = data[k];
			switch (descProp.type) {
				case 'string':
				case 'boolean':
				case 'integer':
				case 'enum':
					if (value === undefined) return;
					instance[name](_, value);
					break;
				case 'flags':
					if (value === undefined) return;
					value = value.split(',');
					(descProp.flags || Object.keys(descProp.dictCodes)).forEach_(_, (_, flag) => {
						instance[name + util.pascalize(flag)](_, value.indexOf(flag) >= 0);
					});
					break;
				case 'object':
					if (data[k]) fillInstance(_, superv, descProp, instance, data[k], name);
					break;
				case 'event':
					instance[name + 'Enabled'](_, !!value);
					instance[name](_, value);
					break;
				case 'type':
					if (value === undefined) return;
					instance[name](_, value);
					TYPE_PROPS.forEach_(_, (_, atb) => {
						if (data[atb] !== undefined) instance[atb](_, data[atb]);
					});
					break;
				default:
					throw new Error(`${ k }: invalid type: ${ descProp.type }`);
			}
		} catch (ex) {
			console.error(`error while setting property ${ name }: ${ ex.stack }`);
			// for now, just ignore property
			//throw ex;
		}
	});
	Object.keys(descriptor.collections || {}).forEach_(_, (_, k) => {
		const name = prefix ? prefix + util.pascalize(k) : k;
		const descCol = descriptor.collections[k];
		if (typeof instance[name] !== 'function') throw new Error(`${ name }: invalid entity member: ${ instance[name] && typeof instance[name] }`);
		if (descCol.cardinality === 1) {
			if (!data[k]) return;
			const child = instance._meta.$relations[k].targetEntity.createInstance(_, instance._db, null);
			instance[name](_, child);
			fillInstance(_, superv, descCol, child, data[k]);
			return;
		}
		const instCol = instance[name](_);
		if (descCol.key || descCol.specialKey) {
			Object.keys(data[k] || {}).forEach_(_, (_, kk) => {
				const row = data[k][kk];
				const rowInst = instCol.add(_);
				// key property defaults to 'name' with specialKey
				rowInst[descCol.key || 'name'](_, kk);
				fillInstance(_, superv, descCol, rowInst, row);
			});
		} else {
			if (data[k]) data[k].forEach_(_, (_, row) => {
				const rowInst = instCol.add(_);
				fillInstance(_, superv, descCol, rowInst, row);
			});
		}
	});
}

class Helper {
	constructor(superv, descriptor) {
		this.supervisor = superv;
		this.descriptor = descriptor;
	}
	metaToCanonical(_, meta) {
		return metaToCanonical(_, this.supervisor, this.descriptor, meta);
	}
	canonicalToMeta(_, data, jsName) {
		// jsName if we need to generated dict code
		return canonicalToMeta(_, this.supervisor, this.descriptor, data, null, jsName);
	}
	instanceToCanonical(_, instance) {
		return serializedToCanonical(this.descriptor, instance.serializeInstance(_));
	}
	parseSource(_, source, filePath) {
		return entityParser.parseSource(_, source, filePath, this.descriptor);
	}
	parseSourceFiles(_, tracker) {
		return entityParser.parseSourceFiles(_, this.descriptor.subdir, this.descriptor, this.supervisor, tracker);
	}
	generateSource(_, parsed) {
		return codeGen.generateSourceCode(_, parsed, this.descriptor);
	}
	template() {
		return codeGen.template(this.descriptor);
	}
	sourceFilename(module, name) {
		const root = this.supervisor.directories.jsLocal || this.supervisor.directories.jsShared;
		return fsp.join(root, util.kebabify(module || 'undefined'), this.descriptor.subdir, util.kebabify(name) + '.ts');
	}
	saveInstanceSource(_, instance) {
		const filePath = this.sourceFilename(instance.module(_), instance.name(_));
		const source = instance.source(_);
		fs.writeFile(filePath, source, 'utf8', _);
		instance.sourceState(_, computeHash(source));
		instance.$addDiagnose("success", `${ filePath } has been saved.`);
	}
	updateAll(_, instance, saving) {
		const desc = this.descriptor;
		const superv = this.supervisor;
		if (instance.status) {
			if (!instance.module(_) || !instance.name(_)) {
				instance.status(_, '4gl');
			} else if (instance.status(_) === '4gl') {
				instance.status(_, 'incomplete');
			}
			if (instance.status(_) === '4gl') {
				instance.source(_, `// Source not generated. Module or name has not been set.`);
				// do not save to file.
				return;
			}
		} else {
			if (!instance.module(_) || !instance.name(_)) {
				instance.source(_, `// Source not generated. Module or name has not been set.`);
				return;
			}
		}
		const filePath = this.sourceFilename(instance.module(_), instance.name(_));
		const missing = instance.missingMappings(_);
		const conflicts = instance.conflictingMappings(_);
		if (instance.status) {
			if (missing.length > 0 || conflicts.length > 0) instance.status(_, 'incomplete');
			else if (instance.status(_) === 'incomplete') instance.status(_, 'mapped');
		}
		if (saving) conflicts.forEach(conflict => instance.$addError(conflict));

		var parsed;
		const state = instance.sourceState(_);
		var source;
		if (fs.exists(filePath, _, _)) {
			source = fs.readFile(filePath, 'utf8', _);
			const hash = computeHash(source);
			if (!state) {
				instance.sourceState(_, hash);
				instance.source(_, source);
			} else {
				if (state !== hash) {
					instance.$addError(`${ filePath }: file was modified on disk. Use "reload source" or "save source" to resolve conflict`);
				}
				source = instance.source(_);
			}
		} else {
			if (!state) {
				source = this.template();
				instance.sourceState(_, computeHash(source));
				instance.source(_, source);
			} else {
				source = instance.source(_);
			}
		}
		try {
			parsed = entityParser.parseSource(_, source, filePath, desc);
		} catch (ex) {
			console.error(ex.stack);
			throw ex.isParseError ? ex : new Error(`${ filePath }: ${ ex.message }`);
		}
		const instanceData = this.instanceToCanonical(_, instance);
		//console.error("INSTANCEDATA", instanceData);
		parsed.data = mergeData(parsed.data, desc, instanceData);
		//console.error("MERGEDDATA", parsed.data);
		const output = codeGen.generateSourceCode(_, parsed, desc);
		var source = output.code;
		// remove old comments
		source = source.replace(/\/\/.*: source is incomplete.*\r?\n(\/\/.*\r?\n)*?\/\/ \d+ elements missing\.(\r?\n)*/, '');
		// insert new comments
		if (instance.status && instance.status(_) === 'incomplete') {
			const messages = missing.concat(conflicts);
			source = `// ${ instance.name(_) }: source is incomplete and cannot be saved to file. Following mapping information is missing: ${ '\n' + messages.map(s => '// * ' + s).join('\n') + '\n' + `// ${ messages.length } elements missing.` + '\n\n' }` + source;
		}
		instance.source(_, source);

		if (saving && (!instance.status || instance.status(_) !== 'incomplete')) {
			const dirname = fsp.dirname(parsed.file);
			x3jsUtil.mkdirp(_, dirname);
			fs.writeFile(parsed.file, source, 'utf8', _);
			instance.sourceState(_, computeHash(source));

			const localized = localeGen.generateJson(_, parsed.data, desc);
			if (localized) {
				const subdirname = fsp.join(dirname, 'resources');
				x3jsUtil.mkdirp(_, subdirname);
				const localizedPath = fsp.join(subdirname, fsp.basename(filePath, '.x3js') + '-en.json');
				fs.writeFile(localizedPath, JSON.stringify(localized, null, '\t'), 'utf8', _);
			}
		}
	}
	fillInstance(_, instance, metaData, parsed) {
		var data;
		if (parsed) {
			data = parsed.data;
			if (!data.module) throw new Error(`${ data.file }: no module`);
			//if (!data.properties) throw new Error(`${data.file}: no properties`);
		} else {
				instance.name(_, '');
				instance.status(_, '4gl');
				instance.comment(_, '');
				instance.source(_, '');
				data = this.metaToCanonical(_, metaData);
			}
		return fillInstance(_, this.supervisor, this.descriptor, instance, data);
	}
	synchronize(_, context, opts) {
		const options = Object.assign({}, opts);
		const tracker = context.tracker;
		tracker.$diagnoses = tracker.$diagnoses || [];
		const userProfile = globals.context.session.getUserProfile(_);
		const desc = this.descriptor;
		const superv = this.supervisor;
		const dictKey = desc.dictKey;
		const entity = context.db.model.getEntity(_, desc.entityName);
		const dictCodeOrId = entity.$properties.dictId ? 'dictId' : 'dictCode';
		const allParsed = this.parseSourceFiles(_, tracker);
		const byDictCode = allParsed.reduce((r, parsed) => {
			//console.error("PARSEDFILES", parsed.file, parsed.data.properties);
			parsed.ast = null;
			if (parsed.data[dictCodeOrId]) {
				const old = r[parsed.data[dictCodeOrId]];
				if (old) throw new Error(`${ parsed.file }: duplicate dictCode, already found in ${ old.file }`);
				r[parsed.data[dictCodeOrId]] = parsed;
			}
			return r;
		}, {});

		const save = (_, instance) => {
			instance.save(_);
			if (instance.hasErrors(_)) {
				const oldLen = tracker.$diagnoses.length;
				instance.getAllDiagnoses(_, tracker.$diagnoses, {
					addEntityName: true,
					addPropName: true
				});
				console.error("SAVE FAILED", tracker.$diagnoses.slice(oldLen));
			}
		};

		const processed = {};
		if (desc.metaName) {
			tracker.phase = 'processing metadata';
			var cursor = superv.mongoStore.collection(desc.metaName, _).find(desc.metaFilter || {});
			if (desc.metaSort) cursor = cursor.sort(desc.metaSort);
			var reader = ezm.reader(cursor);
			if (desc.metaTransform) reader = reader.transform(desc.metaTransform);
			reader.filter((_, metaData) => !options.onlyFiles || byDictCode[metaData[dictKey]])
			.forEach(_, (_, metaData) => {
				tracker.phaseDetail = `${ desc.singular } ${ metaData[dictKey] }`;
				const oldData = context.db.db.collection(util.pascalize(desc.entityName), _).find({
					[dictCodeOrId]: metaData[dictKey]
				}).toArray(_)[0];

				const instance = entity.factory.createInstance(_, null, context.db, null, oldData && oldData._id);
				try {
					this.fillInstance(_, instance, metaData, byDictCode[metaData[dictKey]]);
					// preserve mapping data.
					if (oldData) {
						instance.status(_, oldData.status);
						instance.name(_, oldData.name);
						instance.comment(_, oldData.comment);
						// class-only stuff
						if (instance.properties) instance.properties(_).toArray(_).forEach_(_, (_, prop) => {
							const dictCode = prop[dictCodeOrId](_);
							if (!dictCode) return;
							const oldProp = oldData.properties.filter_(_, (_, oldProp) => oldProp[dictCodeOrId] === dictCode)[0];
							if (oldProp) {
								prop.name(_, oldProp.name);
								prop.comment(_, oldProp.comment);
							}
						});
					} else {
						instance.status(_, '4gl');
					}
					save(_, instance);
				} catch (ex) {
					console.error(`${ desc.singular } ${ metaData[dictKey] }: synchronization failed: ${ ex.stack }`);
					tracker.$diagnoses.push({
						$severity: 'error',
						$message: `${ desc.singular } ${ metaData[dictKey] }: synchronization failed: ${ ex.message }`
					});
				}
				processed[metaData[dictKey]] = true;
			});
		}

		if (!options.onlyFiles) {
			tracker.phase = 'purging metadata';
			context.db.db.collection(util.pascalize(desc.entityName), _).remove({
				[dictCodeOrId]: {
					$nin: entity.$properties.dictId ? Object.keys(processed).map(x => parseInt(x)) : Object.keys(processed)
				}
			}, _);
		}

		tracker.phase = `inserting pure x3js ${ desc.plural }`;
		const byName = ezm.reader(context.db.db.collection(util.pascalize(desc.entityName), _).find({})) //
		.reduce(_, (_, r, data) => (r[data.name] = data._id, r), {});

		allParsed.forEach_(_, (_, parsed) => {
			const fileData = parsed.data;
			const oldId = byName && fileData.name && byName[fileData.name];

			if (fileData[dictCodeOrId]) {
				if (processed[fileData[dictCodeOrId]]) return;
				else if (!options.onlyFiles) throw new Error(`${ fileData.name }: invalid dictCode: ${ fileData[dictCodeOrId] }`);
			}
			//console.error("INSERTING PURE ", parsed.file)
			const instance = entity.factory.createInstance(_, null, context.db, null, oldId);
			this.fillInstance(_, instance, null, parsed);
			save(_, instance);
		});
		context.response.writeHead(200, {});
		context.response.write(_);
		tracker.progress = 100;
	}
}

entityHelper.getSupervisor = function (_, endpoint) {
	if (!endpoint.useEtna(_)) throw new Error("operation not available on current endpoint");
	const conf = endpoint.getEtnaConfig(_, globals.context.request.session);
	//console.error("SUPERVISOR CONF", conf);
	const superv = supervisor.create(_, conf);
	ACTX.init(_, conf.session, superv);
	return superv;
};

function computeHash(code) {
	return crypto.createHash('sha1').update(code, 'utf8').digest('hex');
}

entityHelper.fromEndpoint = function (_, endpoint, descriptor) {
	const superv = entityHelper.getSupervisor(_, endpoint);
	return new Helper(superv, descriptor);
};

entityHelper.fromCurrentSession = function (_, descriptor) {
	const endpoint = globals.context.session.getUserProfile(_).selectedEndpoint(_);
	return entityHelper.fromEndpoint(_, endpoint, descriptor);
};

entityHelper.create = function (superv, descriptor) {
	return new Helper(superv, descriptor);
};