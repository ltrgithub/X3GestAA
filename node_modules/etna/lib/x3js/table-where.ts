import { _ } from 'streamline-runtime';
import { Table, Column } from '../supervisor/meta/types';
import { Supervisor } from '../supervisor/supervisor';
import { TableDesc } from './table-query';

type Dict<T> = { [name: string]: T; };

const ops1: Dict<(_: _, converter: WhereConverter, arg: any) => string> = {
	$and(_,  converter, clauses) {
		if (!Array.isArray(clauses)) throw new Error('$and operand must be an array');
		if (clauses.length === 0) return '(1=1)'; // empty and is true
		return '(' + clauses.map_(_, (_: _, clause: any) => converter.toSql(_, clause)).join(') and (') + ')';
	},
	$or(_,  converter, clauses) {
		if (!Array.isArray(clauses)) throw new Error('$or operand must be an array');
		if (clauses.length === 0) return '(1=0)'; // empty or is false
		return '(' + clauses.map_(_, (_: _, clause: any) => converter.toSql(_, clause)).join(') or (') + ')';
	},
	$not(_,  converter, clause) {
		return 'not ' + converter.toSql(_, clause);
	}
};

function escape(s: string) {
	return "'" + s.replace(/'/g, "''") + "'";
}

function getColumn(converter:WhereConverter, key: string) {
	const column = converter.findColumn(key);
	if (column.meta.dim !== 1) throw new Error("cannot compare on column " + key + ": dim=" + column.meta.dim);
	return {
		sqlName: column.alias + '.' + column.meta.name + '_0',
		meta: column.meta
	};
}

function convertLiteral(converter: WhereConverter, str: string) {
	const parts = str.split('{{');
	var s = '';
	if (parts.length === 1) {
		s = converter.param(converter.args.length);
		converter.args.push(parts[0]);
	} else {
		if (parts[0]) s += escape(parts[0]) + ' + ';
		for (var i = 1; i < parts.length; i++) {
			if (i > 1) s += " + '' + ";
			const pair = parts[i].split('}}');
			if (pair.length !== 2) throw new Error("invalid reference syntax: " + str);
			s += getColumn(converter, pair[0]).sqlName;
			if (pair[1]) s += " + " + escape(pair[1]);
		}
	}
	return s;
}

function comparisonOp(sqlOp: string) {
	return function (_: _,  converter: WhereConverter, key: string, exp: any) {
		const column = getColumn(converter, key);
		var sqlExp: string;
		if (typeof exp === 'string') {
			sqlExp = convertLiteral(converter, exp);
		} else {
			sqlExp = converter.param(converter.args.length);
			converter.args.push(column.meta.type.toSql(exp));
		}
		return [column.sqlName, sqlOp, sqlExp].join(' ');
	};
}

const ops2: Dict<(_: _, converter: WhereConverter, key: string, expect: any) => string> = {
	$eq: comparisonOp('='),
	$ne: comparisonOp('<>'),
	$lt: comparisonOp('<'),
	$lte: comparisonOp('<='),
	$gt: comparisonOp('>'),
	$gte: comparisonOp('>=')
};

function invalidOperator(op: string, ops: any) {
	return new Error("invalid operator. Expected one of " + Object.keys(ops) + ", got " + op);
}

export class WhereConverter {
	tables: TableDesc[];
	args: any[];

	constructor(tables: TableDesc[], args: any[]) {
		this.tables = tables;
		this.args = args;
	}
	get supervisor() {
		return this.tables[0].meta.supervisor;
	}
	param(i: number) {
		return this.supervisor.sqlDriver.param(i);
	}
	findTable(alias: string) {
		for (var i = 0; i < this.tables.length; i++) {
			if (this.tables[i].alias === alias) return this.tables[i].meta;
		}
		throw new Error('table alias not found: ' + alias);
	}
	findColumn(key: string) {
		const parts = key.split('.');
		if (parts.length > 2) throw new Error('invalid column syntax: ' + key);
		const alias = parts.length > 1 ? parts[0] : '';
		const table = this.findTable(alias);
		const column = table.column(parts[parts.length - 1]);
		if (!column) throw new Error('column not found: ' + key);
		return {
			alias: alias,
			meta: column,
			sqlName: (alias ? alias + '.' + column.name : column.name) + '_0'
		};
	}
	toSql(_: _,  cond: any) {
		if (cond == null) throw new Error("invalid where criteria: " + cond);
		if (cond === true) return "1=1";
		if (cond === false) return "1=0";
		if (typeof cond === 'string') return cond;
		if (typeof cond !== 'object') throw new Error("unsupported where criteria: " + typeof cond + ', ' + cond);
		const $and = ops1['$and'];
		if (Array.isArray(cond)) return $and(_, this, cond);
		return $and(_, this, Object.keys(cond).map_(_, (_, k) => {
			if (k[0] === '$') {
				if (!ops1[k]) throw invalidOperator(k, ops1);
				return ops1[k](_, this, cond[k]);
			} else {
				const arg = cond[k];
				if (arg != null && typeof arg === 'object') {
					return $and(_, this, Object.keys(arg).map_(_, (_, kk) => {
						if (!ops2[kk]) throw invalidOperator(kk, ops2);
						return ops2[kk](_, this, k, arg[kk]);
					}));
				} else {
					return ops2['$eq'](_, this, k, arg);
				}
			}
		}));
	}
}