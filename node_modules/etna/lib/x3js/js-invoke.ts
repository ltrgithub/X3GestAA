import { _ } from 'streamline-runtime';
import * as util from '../engine/runtime/util';
import { ProgArgs } from '../engine/runtime/types';
import * as x3jsUtil from './util';
import { Type, etnaType2TypTyp } from '../supervisor/meta/type';
import * as instanceProxy from './instance-proxy';

type Dict<T> = { [name: string]: T; };

const camelCache: Dict<string> = {};

function camelify(name: string) {
	return camelCache[name] || (camelCache[name] = name.split('_').map((s, i) => i === 0 ? s.toLowerCase() : s[0] + s.substring(1).toLowerCase()).join(''));
}

function eventName(str: string) {
	return (/^ADD/.test(str) ? 'ADD_' + str.substring(3) : str.substring(1));
}

function labelValue(label: string, args: ProgArgs) {
	switch (label) {
		case 'properties':
			return camelify(args.ARULE.value);
		case 'events':
			return camelify(eventName(args.AEVENT.value));
		case 'operations':
			return camelify(args.AOPERATION.value);
		case 'methods':
			return camelify(args.AMETHOD.value);
		default:
			throw new Error("bad label: " + label);
	}
}

function notFound(label: string, name?: string) {
	if (/^(properties|events)$/.test(label)) return 0;
	throw new Error(label + " not found: name=" + name);
}

export default function (_: _,  def: any, label: string, args: ProgArgs) {
	//console.error("JSINVOKE", def, label);
	const fns = def[label];
	if (!fns) return notFound(label);
	var member = def;
	while (args.path.length > 1) {
		const name = args.path.shift();
		member = member.relations[name];
		if (!member) return notFound(label, name);
	};
	member = member[label];
	if (!member) return notFound(label);
	if (args.path.length === 1) member = member[args.path[0]];
	if (!member) return notFound(label, args.path[0]);
	if (label === 'properties') member = member.events;
	if (!member) return notFound(label, args.path[0]);
	const action = labelValue(label, args);
	const fn = member[action];
	if (!fn) return notFound(label, action);
	const proxy = instanceProxy.create(args.THIS.value);
	// TODO: cleanup args typing
	const arg1 = args._ANEWVAL !== undefined && (args as any).member ? x3jsUtil.toJs(args._ANEWVAL, (args as any).member.type.data.TYPTYP) : undefined;
		const supervisor = util.currentContext().x3frame.context.superv;

	const jsKeys = Object.keys(args).filter(k => args[k] && args[k].isParam);
	const jsArgs = jsKeys.map(k => {
		const arg = args[k];
		return x3jsUtil.toJs(arg.value, arg.typ);
	});
	// TODO: set NOLIB when arg.typ === 1, for boolean
	var result: any;
	if (jsArgs.length === 0) {
		//result = fn.call(proxy, _, arg1);
		result = fn.call(proxy, arg1);
	} else {
		//var result = fn.apply_(_, proxy, jsArgs, 0);
		var result = fn.apply(proxy, jsArgs);
		if (!Array.isArray(result)) result = [result];
		jsKeys.forEach_(_, (_, k) => {
			if (args[k].set && result.length > 0) args[k].value = result.shift();
		});
		if (result.length > 1) throw new Error("function " + label + " returns too many results");
		result = result[0];
	}
	if (args.ARET_VALUE && result !== undefined) {
		const typ = etnaType2TypTyp[args.ARET_VALUE.type[1]];
		if (typ == null) throw new Error("bad type: " + args.ARET_VALUE.type);
		args.ARET_VALUE.value = x3jsUtil.fromJs(result, typ, null);
		return undefined;
	} else {
		// ??
		return result;
	}
};