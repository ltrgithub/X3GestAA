"use strict";
const util = require('etna/lib/supervisor/util');
const x3jsUtil = require('./util');
const typeMeta = require('./type-meta');
const fs = require('fs');
const fsp = require('path');
const entityHelper = require('etna/lib/x3js/entity-helper');
const classDescriptor = require('etna/lib/x3js/class-descriptor');

const jsClassKind2TypCla = {
	standard: 1,
	interface: 5,
};

exports.fromClassScript = (_, supervisor, script, table) => {
	//console.error("METAFROMSCRIPT", script);
	if (!script.module) throw new Error(script.name + ": module missing");
	const clas = script;
	if (!clas.properties) throw new Error(script.name + ": properties element missing");
	const meta = entityHelper.create(supervisor, classDescriptor).canonicalToMeta(_, script, script.name);
	//console.error("META", meta);
	if (script.tableDef) {
		// adjust table mapping
		if (meta.TABREF && meta.TABREF !== script.tableDef.name) throw new Error(`${script.name}: mismatch between 4GL and X3JS table names`);
		meta.TABREF = script.tableDef.name;
		meta.INDREF = script.tableDef.indexes[0].name;
		// derive kEYINT from first index columns
		meta.KEYINT = table.data.INDEXES[0].DESCRIPT.replace(/^\W/, '').replace(/[\+\-]/g, '~');
	}
	// huge hack to enable X3JS script through _CSTD hack - CLEAN THIS UP!
	const scripts = clas.scripts || [{
		name: 'classes:' + script.module + '.' + script.name,
	}];
	Object.assign(meta, {
		NBRTRT: scripts.length,
		CODTRT: scripts.map(sc => sc.name ),
		TYPTRT: scripts.map(sc => sc.kind || 1),
		ACTTRT: scripts.map(sc => sc.activityCode || ''),
		RANTRT: scripts.map((sc, i) => i + 1), // TODO: order should come from script annotation.
	});

	//console.error("META", meta);
	return meta;
	/*
	const CODCLA = (clas.code || clas.name || script.name).toUpperCase();
	const scripts = clas.scripts || [{
		name: CODCLA + '_CSTD'
	}];
	const TABREF = table ? table.name : '';
	var INDREF = '';
	var KEYINT = '';
	if (script.tableRef) {
		INDREF = script.tableRef.indexName || table.indexes[0].name;
		KEYINT = script.tableRef.key || table.indexes[0].columns.map(c => c.name).join('~');
	} else if (script.tableDef && script.tableDef.indexes) {
		INDREF = script.tableDef.indexes[0].name;
		// substring(1) to drop asc/desc sign
		KEYINT = script.tableDef.indexes[0].columns.split(',').map(c => c.substring(1)).join('~');
	}
	const columns = table && table.data.COLUMNS.reduce((r, c) => (r[c.CODZONE] = c, r), {});

	return {
		_proxyName: script.name,
		// header
		CODCLA: CODCLA,
		TYPCLA: jsClassKind2TypCla[clas.kind] || 2, // persistent by default
		INTCLA: 0,

		// general tab - characteristics
		MODULE: supervisor.moduleCode(script.module),
		CODACT: script.activityCode || '',

		// scripts
		NBRTRT: scripts.length,
		CODTRT: scripts.map(sc => sc.name ),
		TYPTRT: scripts.map(sc => sc.kind || 1),
		ACTTRT: scripts.map(sc => sc.activityCode || ''),
		RANTRT: scripts.map((sc, i) => i + 1), // TODO: order should come from script annotation.

		// table mapping
		TABREF: TABREF,
		INDREF: INDREF,
		KEYINT: KEYINT, 
		FLTREF: (table && table.filter) || '',

		// flags
		FLGRREF: x3jsUtil.boolIn(!!clas.canRead),
		FLGCREF: x3jsUtil.boolIn(!!clas.canCreate),
		FLGUREF: x3jsUtil.boolIn(!!clas.canUpdate),
		FLGDREF: x3jsUtil.boolIn(!!clas.canDelete),
		FLGSEARCH: x3jsUtil.boolIn(!!clas.canSearch),
		FLGCONSULT: x3jsUtil.boolIn(!!clas.canQuery),
		RAW: x3jsUtil.boolIn(!!clas.isTechnical),
		FLGACTX: x3jsUtil.boolIn(!!clas.isContextual),
		FLGSYSTEM: x3jsUtil.boolIn(!!clas.isSystem),
		//
		FCYSTR: clas.site || '',
		LEGSTR: clas.legislation || '',
		CPYSTR: clas.company || '',
		ACCCSTR: clas.accessCode || '',
		LNKOBJ: clas.linkedObject || '',

		FLGBUFFER: x3jsUtil.boolIn(!!clas.isBuffer),
		FLGTR: x3jsUtil.boolIn(!!clas.isTransacted),

		PROPERTIES: Object.keys(clas.properties).map((name, i) => {
			const prop = clas.properties[name];
			if (prop.name && prop.name !== name) throw new Error(`invalid name attribute on property ${name}`);
			prop.name = name;
			const FLDCLA = prop.columnName || name.toUpperCase();
			var col;
			var type;
			if (prop.columnName) {
				col = columns[prop.columnName];
				if (!col) console.error(columns);
				if (!col) throw new Error("column not found: " + prop.columnName);
				type = col; // column carries type info
				//console.error("CLASS META COLUMN", col)
			} else {
				type = typeMeta.fromProperty(supervisor, prop);
			}
			// TODO: how do we valorize parameters???
			var PARAM_FLDS = (col && col.PARAMETERS && col.PARAMETERS.map(param => {
				return {
					CODCLA: CODCLA,
					FLDCLA: FLDCLA,
					CODPAR: param.CODPAR,
					NUMPAR: param.NUMPAR,
					ADRVAL: 2, // ??
					AWMAJTYP: 0, // ??
					TYPINT: 7,
					TYPKEY: 2, 
					TYPPAR: 1,
					VALEUR: '',
				}
			})) || [];
			return {
				_proxyName: name,
				CODCLA: CODCLA,
				FLDCLA: FLDCLA,
				NUMFLD: i + 1,
				INTFLD: 0,
				INTSHTFLD: 0,
				ACTFLD: prop.activityCode || '',

				CODTYP: type.CODTYP,
				LNKCLA: type.LNKCLA || '', // fix later.
				LONG: type.LONG || 0,
				NOLIB: type.NOLIB || 0,
				ENUM: type.ENUM,
				PARAM_FLDS: PARAM_FLDS,

				OBLIG: x3jsUtil.boolIn(!!prop.isMandatory),
				ACS: prop.accessCode || '',
				CODCTL: prop.controlTable || '',
				TABCONT: prop.dependency || '',
				FLDGRP: prop.group || '',

				FLGSEARCH: x3jsUtil.boolIn(!!prop.canSearch),
				CATSEARCH: prop.searchCategory || '',

				FLGACCGET: x3jsUtil.boolIn(!!prop.get),
				INTEVAL: '', // evaluated title: will be a function
				LOBTAB: prop.lobTable || '',
				LOBFLD: prop.lobColumn || '',
				LOBCNT: prop.contentType || '',
			};
		}),
		STD_METHODS: [],
	};
	*/
}

exports.loadData = (_, supervisor, script) => {
	var table = null;
	if (script.tableRef) {
		table = supervisor.load(_, 'Table', script.tableRef.name);
		if (!table) throw new Error('table not found: ' + script.tableRef);
	} else if (script.tableDef) {
		// we need at least one index and we have to generate index names
		if (!script.tableDef.indexes || !script.tableDef.indexes.length) throw new Error(`${script.name}: tableDef has no index`);
		script.tableDef.indexes.forEach((index, i) => {
			index.name = script.tableDef.name + "_IDX" + i;
		});
		const tableMeta = require('./table-meta').fromClassScript(_, supervisor, script);
		//console.error("TABLE META", tableMeta);
		table = supervisor.new(_, 'Table', tableMeta);
		// TODO: improve management of temporary tables
		if (/temporary/.test(script.tableDef.is)) table.drop(_, true);
		if (!table.exists(_)) table.create(_);
		supervisor.cacheMeta('Table', tableMeta.CODFIC, table);
	}
	return exports.fromClassScript(_, supervisor, script, table);
}
