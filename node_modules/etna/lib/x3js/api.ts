/// !doc
/// [x3js dev guide](x3js-development-guide) > [x3js APIs](x3js-apis) > x3js module
///
/// # x3js module
///
/// The `x3js` module is the module that you should import at the top of all `.x3js` source files:
///
/// ```javascript
/// import * as x3js from 'x3js';
/// ```
import { _ } from 'streamline-runtime';
import * as core from 'syracuse-core';
import { Dict } from '../engine/runtime/types';
import * as runtime from '../engine/runtime/runtime';
import * as strings from '../engine/runtime/strings';
import * as tdate from '../engine/runtime/tdate';
import * as tdatetime from '../engine/runtime/tdatetime';
import * as tblbfile from '../engine/runtime/tblbfile';
import * as constants from '../supervisor/constants';
import * as classProxy from './class-proxy';
import * as tableProxy from './table-proxy';
import * as enumProxy from './enum-proxy';
import * as messageProxy from './message-proxy';
import * as parameters from './parameters';
import * as util from '../supervisor/util';
import * as uuidModule from 'syracuse-core/uuid'
const uuid = core.uuid; // don't use tuuid - we want strings not buffers
import * as x3jsUtil from './util';
import { ClassDef, PropertyDef } from './class-proxy';
import { EnumDef } from './enum-proxy';
import { MessagesDef } from './message-proxy';
import { UnitTestDef } from './unit-test';

const STRING_API = {
	format: (fmt: string, val: any) => strings.functions.FORMAT$.fn(fmt, val)
};

const BLOB_API = {
	fromBase64: (str: string) => new tblbfile.Blbfile(new Buffer(str, 'base64'))
};

const PREDICATES = {
	startsWith(str: string, ignoreCase?: boolean) {
		return {
			$regex: "^" + str,
			$options: ignoreCase ? 'i' : undefined
		};
	}
};

const CONSTANTS = Object.keys(constants).filter(k => /^CST_A/.test(k)).reduce((r, k) => {
	r[k.substring(5)] = (constants as any)[k];
	return r;
}, {} as Dict<any>);

const addType = (t: string) => (obj: PropertyDef) => (obj = obj || {}, obj.type = t, obj);

const Api = {
	///
	/// #### Data types
	///
	/// * `x3js.string` 
	///   [string utilities](x3js-string).
	get string() {
		return STRING_API;
	},
	/// * `x3js.date` 
	///   [date utilities](x3js-date).
	get date() {
		return tdate;
	},
	/// * `x3js.datetime` 
	///   [datetime utilities](x3js-datetime).
	get datetime() {
		return tdatetime;
	},
	/// * `x3js.uuid`
	///   [UUID utilities](x3js-uuid).
	get uuid() {
		return uuid;
	},
	// TODO: review
	get blob() {
		return BLOB_API;
	},
	// TODO: review
	get predicates() {
		return PREDICATES;
	},
	// meta helpers
	booleanProperty: addType('boolean'),
	integerProperty: addType('integer'),
	shortProperty: addType('short'),
	decimalProperty: addType('decimal'),
	dateProperty: addType('date'),
	datetimeProperty: addType('datetime'),
	uuidProperty: addType('uuid'),	
	stringProperty: addType('string'),
	enumProperty: addType('enum'),
	
	message: (arg: any) => arg,
	// TODO: do we really need this one?
	constants: CONSTANTS,
	///
	/// #### Defining dictionary artifacts
	///
	/// * `x3js.defineClass(def)` 
	///   defines a [class](x3js-class-manager).
	defineClass(def: ClassDef) {
		return x3jsUtil.wait(_ =>  classProxy.define(_, def));
	},
	/// * `x3js.defineEnum(def)` 
	///   defines an [enum](x3js-enums).
	defineEnum(def: EnumDef) {
		return enumProxy.define(def);
	},
	/// * `x3js.defineMessages(def)` 
	///   defines a [message list](x3js-user-messages).
	defineMessages(def: MessagesDef) {
		return messageProxy.define(def);
	},
	/// * `x3js.defineUnitTest(def)` 
	///   defines a [unit test](x3js-unit-test).
	defineUnitTest(def: UnitTestDef) {
		return require('./unit-test').define(def);
	},
	///
	/// #### Accessing metadata artifacts
	///
	/// * `x3js.legacyClass(code)` 
	///   returns a [class artifact](x3js-class-manager).
	legacyClass(code: string) {
		return x3jsUtil.wait(_ => classProxy.legacyClass(_, code));
	},
	
	legacyMessage(chapter: number, id: number) {
		return x3jsUtil.wait(_ => messageProxy.legacyMessage(_, chapter, id));	
	},
	/// * `x3js.table('moduleName.TABLENAME')` 
	///   returns a [table artifact](x3js-table-manager).
	table(path: string) {
		return tableProxy.load(path);
	},
	///
	/// #### Accessing parameters API
	///
	/// * `x3js.parameters`
	///   [parameters API](x3js-parameters) 
	get parameters() {
		return parameters;
	},

	///
	/// #### Unit tests assertions
	///
	/// * `x3js.assert` 
	///   Returns assert API for unit tests 
	get assert() {
		return require('./unit-test').assert;
	},

	tryCatch<T>(fn: () => T): [Error, T] {
		try {
			return [null, fn.call(this)];
		} catch (ex) {
			return [ex, undefined];
		}
	},
}

export default Api;