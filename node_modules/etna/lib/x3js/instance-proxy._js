"use strict";
/// !doc
/// [x3js dev guide](x3js-development-guide) > [x3js APIs](x3js-apis) > x3js instance
///
/// # x3js instance
///

require('harmony-reflect'); // to get ES6 Proxy API
const glob = require('streamline-runtime').globals;
const runtime = require('etna/lib/engine/runtime/runtime');
const util = require('etna/lib/supervisor/util');
const x3jsUtil = require('etna/lib/x3js/util');
const classModule = require('etna/lib/supervisor/meta/class');
const constants = require("etna/lib/supervisor/constants");
const SlotCollection = require("etna/lib/supervisor/slotCollection").SlotCollection;
const collectionProxy = require('etna/lib/x3js/collection-proxy');
const attributes = require("etna/lib/supervisor/attributes");
const instanceProxy = exports;
const instructions = {
	TRBEGIN: runtime.instructions.TRBEGIN(),
	COMMIT: runtime.instructions.COMMIT(),
	ROLLBACK: runtime.instructions.ROLLBACK()
};

const STATUSES = {
	0: "original",
	[constants.CST_ANEW]: "new",
	[constants.CST_AUPD]: "modified",
	[constants.CST_ADEL]: "deleted",
	[constants.CST_ANEWDEL]: null
};

function instanceError(message, instance) {
	const error = new Error(message);
	error.diagnoses = instance.diagnoses;
	return error;
}

class InstanceHandler {
	constructor(instance) {
		this.instance = instance;
	}
	get $proxyType() { return 'instance'; }
	/// ## Properties
	///
	/// * `instance.$class`: the instance's class.
	get $class() {
		return this.instance.x3jsClass;
	}
	/// * `instance.$parent`: parent instance.
	get $parent() {
		return instanceProxy.create(this.instance.APARENT);
	}
	/// * `instance.$snapshot`: the instance's snapshot.
	get $snapshot() {
		return this.instance._insideInit ? null: instanceProxy.create(this.instance.snapshot());
	}
	/// * `instance.$status`: the instance's modification status, one of `original`, `modified`, `new`, `deleted`
	get $status() {
		const status = STATUSES[this.instance.$astalin];
		if (!status) throw new Error("bad instance status: " + this.instance.$astalin);
		return status;
	}
	/// * `instance.$diagnoses`: the instance's diagnoses.
	get $diagnoses() {
		return (this.instance.diagnoses || []).map(x3jsUtil.toJsDiagnose);
	}
	///
	/// ## Methods
	///
	/// * `instance.$data(_, full = false)`: returns the instance's properties and their values as a plain JavaScript object.
	///   If `full` is false, only the properties are returned. If true, the collections are also returned, as
	///   arrays of plain JavaScript objects (recursively if several levels of collections).
	$data(_, full) {
		return Object.keys(this.slots).reduce_(_, (_, r, name) => {
			const slot = this.slots[name];
			if (slot instanceof SlotCollection) {
				if (full) r[name] = slot.lines.map_(_, (_, child) => child.$data(_, full));
			} else {
				if (slot.property == null) throw new Error("invalid slot: no property");
				r[name] = x3jsUtil.toJs(slot.value, slot.property);
			}
			return r;
		}, {});
	}

	///
	/// #### Instance level error, warning and info messages
	///
	/// * `instance.$error(_, text)`:  adds an error to the instance.
	$error(_, text) {
		this.instance.ASETERROR(_, '', text, constants.CST_AERROR);
	}
	/// * `instance.$warn(_, text)`:  adds a warning to the instance.
	$warn(_, text) {
		this.instance.ASETERROR(_, '', text, constants.CST_AWARNING);
	}
	/// * `instance.$info(_, text)`:  adds an information message to the instance.
	$info(_, text) {
		this.instance.ASETERROR(_, '', text, constants.CST_AINFO);
	}
	/// * `instance.$withTransaction(_, body)` executes `body(_)` inside a transation.
	///   The transaction will be committed if `body` returns normally and rollbacked if `body` throws
	///   an exception.
	$withTransaction(_, body) {
		instructions.TRBEGIN(_);
		try {
			body(_);
			instructions.COMMIT(_);
		} catch (ex) {
			instructions.ROLLBACK(_);
			throw ex;
		}
	}
	// user is now handled by context manager
	$user(_) {
		return glob.context.x3session.actx.$USER(_);
	}
	// deprecated, use $save instead
	$insert(_) {
		return this.instance.$AINSERT(_);
	}
	///
	/// #### CRUD methods
	///
	/// * `instance.$save(_)`: saves the instance to the database.
	///    The instance is inserted if its `$status` is `'new'`, updated otherwise.  
	///    Throws if the save operation fails.
	$save(_) {
		// FIBERIZE HACK: don't pass _ to $trySave!
		if (!this.$trySave()) throw instanceError("save failed", this.instance);
	}
	/// * `instance.$trySave(_)`: saves the instance to the database. 
	///    same as `$save` but returns true if the operation succeeds, false otherwise.
	$trySave(_) {
		if (this.instance.$astalin === constants.CST_ANEW) return this.instance.$AINSERT(_) !== constants.CST_AERROR;
		else return this.instance.$AUPDATE(_) !== constants.CST_AERROR;
	}
	/// * `instance.$delete(_)`: deletes the instance from the database.
	///    Throws if the delete operation fails.
	$delete(_) {
		// FIBERIZE HACK: don't pass _ to $tryDelete!
		if (!this.$tryDelete()) throw instanceError("delete failed", this.instance);
	}
	/// * `instance.$tryDelete(_)`: deletes the instance from the database.
	///    same as `$delete` but returns true if the operation succeeds, false otherwise.
	$tryDelete(_) {
		return this.instance.$ADELETE(_) !== constants.CST_AERROR;
	}
	/// Note: instances are read via the [class manager](x3js-class-manager).
	$property(_, name) {
		const prop = this.instance.class.membersByJsName[name];
		if (prop == null) throw new Error("property not found: " + name);
		const slot = this.instance.slot(_, prop.name);
		return propertyProxy(this.instance, prop, slot);
	}
	/// Note: instances are read via the [class manager](x3js-class-manager).
};

x3jsUtil.fiberize(InstanceHandler.prototype);

const sysProperties = classModule.systemProperties.reduce((names, prop) => {
	names[prop.FLDCLA] = prop;
	return names;
}, {});

class PropertyHandler {
	constructor(instance, prop, slot) {
		this.instance = instance;
		this.prop = prop;
		this.slot = slot;
		this._path = null;
	}
	get path() {
		return this._path || (this._path = util.path(this.instance, this.prop.name));
	}
	// this one must be defined to avoid exceptions when formatting stacktraces.
	get name() {
		return this.jsName;
	}
	///
	/// #### Property level level error, warning and info messages
	///
	/// * `val = instance.prop.error(_, text)`: adds error `text` to the instance's property _prop_.
	error(_, text) {
		this.instance.ASETERROR(_, this.path, text, constants.CST_AERROR);
	}
	/// * `val = instance.prop.warn(_, text)`: adds warning `text` to the instance's property _prop_.
	warn(_, text) {
		this.instance.ASETERROR(_, this.path, text, constants.CST_AWARNING);
	}
	/// * `val = instance.prop.info(_, text)`: adds info `text` to the instance's property _prop_.
	info(_, text) {
		this.instance.ASETERROR(_, this.path, text, constants.CST_AINFO);
	}
}

///
/// #### Property attributes
///
/// * `val = instance.prop.atb` 
/// * `instance.prop.atb = val` 
///   gets and sets the _atb_ attribute on an instance property
///
/// This API can be used with the following attributes:
///
/// * `isReadOnly`: boolean
/// * `isMandatory`: boolean
/// * `isHidden`: boolean
/// * `isDisabled`: boolean
/// * `symbol`: string
/// * `label`: string
/// * `style`: string
/// * `index`: integer
/// * `scale`: integer
/// * `precision`: integer
///
/// Note: the following (contextual) attributes are not handled yet:
///
/// * `isLoaded`: boolean
/// * `contentType`: string
/// * `filename`: string
/// * `title`: string
/// * `description`: string
function addAttributeAccessors(atb, type) {
	Object.defineProperty(PropertyHandler.prototype, atb, {
		get() {
			const slot = this.instance.ensureSlot(this.prop.name);
			return slot.getAttribute('$' + atb);
		},
		set(val) {
			const slot = this.instance.ensureSlot(this.prop.name);
			if (typeof val !== type) throw new Error("invalid attribute type: expected " + type + ", got " + typeof val);
			return slot.setAttribute('$' + atb, val);
		}
	});
}

Object.keys(attributes.extAttributesMeta).forEach(k => {
	addAttributeAccessors(k.substring(1), typeof attributes.extAttributesMeta[k]);
});

// This proxy makes the API more robust in dev mode
// TODO: short-circuit in production mode
function propertyProxy(instance, prop, slot) {
	const handler = new PropertyHandler(instance, prop, slot);
	return new Proxy(handler, {
		get(handler, name) {
			if (!(name in PropertyHandler.prototype)) throw new Error("invalid property method or attribute: " + name);
			const member = handler[name];
			return typeof member === 'function' ? member.bind(handler) : member;
		},
		set(handler, name, value, receiver) {
			if (!(name in PropertyHandler.prototype)) throw new Error("invalid property method or attribute: " + name);
			handler[name] = value;
			return true;
		}
	});
}
// TODO extAttributesObject (lazy loaded properties)
// TODO resAttributes (references)

function lookupJsMembers(instance, key, name) {
	const bases = instance.APARENT ? lookupJsMembers(instance.APARENT, 'relations', instance.$parent.proJsName) // instance.$parent is the collection!
	: instance.class.jsModules;
	return bases.map(base => base[key] && base[key][name]).filter(base => !!base);
}

// internal class - don't document
class ClassHandler {
	constructor(clas) {
		this.class = clas;
	}
	get(_, instance, name) {
		const prop = this.class.membersByJsName[name];
		if (prop) {
			const slot = instance.ensureSlot(prop.name);
			const val = slot.get(_);
			//console.error("PROPERTY GET", this.key, val);
			if (util.isCollection(val)) return collectionProxy.create(val);
			else return x3jsUtil.toJs(val, slot.property);
		}
		const methods = lookupJsMembers(instance, 'methods', name);
		if (methods.length > 0) return methods.pop().bind(instanceProxy.create(instance)); // todo: reuse proxy
		if (/^(inspect|toString|stack)$/.test(name)) return typeof instance[name] === 'function' ? instance[name].bind(instance) : instance[name];
		throw new Error("member not found: " + this.class.name + "." + name);

	}
	set(_, instance, name, val) {
		const prop = this.class.membersByJsName[name];
		if (!prop) throw new Error("property not found: " + name);
		const slot = instance.ensureSlot(prop.name);
		if (slot == null) throw new Error("property not found: " + name);
		//console.error("PROPERTY SET", this.key, val);
		// we bypass baseInstance.set because we set on the slot.
		// so we have to create the snapshots ourselves.
		instance.snapshots();
		var throwing = instance.throwing;
		instance.throwing = true;
		try {
			slot.set(_, x3jsUtil.fromJs(val, slot.property));
		} finally {
			instance.throwing = throwing;
		}
	}

	ownKeys() {
		return this.proxyKeys || (this.proxyKeys = Object.keys(this.class.properties) //
		.filter(code => !sysProperties[code]).map(code => this.class.properties[code].jsName));
	}
}

x3jsUtil.fiberize(ClassHandler.prototype);

// internal
instanceProxy.create = instance => {
	if (!instance) return null;
	return new Proxy(instance, {
		get(instance, name) {
			if (name[0] === '$') {
				if (name === '$instance') return instance;
				var instanceHandler = new InstanceHandler(instance);
				var member = instanceHandler[name];
				if (member === undefined) throw new Error("invalid member: " + name);
				return typeof member === 'function' ? member.bind(instanceHandler) : member;
			}
			return new ClassHandler(instance.meta).get(instance, name);
		},
		set(instance, name, value) {
			if (name[0] === '$') throw new Error("cannot set member: " + name);
			// TODO: hook up sys members
			new ClassHandler(instance.meta).set(instance, name, value);
			return true;
		},
		ownKeys(instance) {
			instance.meta.handler = instance.meta.handler || new ClassHandler(instance.meta);
			return instance.meta.handler.ownKeys();
		}
	});
};
