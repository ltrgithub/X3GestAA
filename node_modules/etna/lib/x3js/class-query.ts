"use strict";
/// !doc
/// [x3js dev guide](x3js-development-guide) > [x3js APIs](x3js-apis) > x3js class query
///
/// # x3js class query
///
/// _class query_ objects are returned by a `query` call on a class:
///
/// ```javascript
///  const MyClass = x3js.class('myModule.MyClass');
/// 
///  const query = MyClass.query(_); // query object
///  ```
///
/// Class query objects have an `execute(_)`  method which produces an `ez-streams`  _reader_ on which
/// you can chain methods to filter, transform, pipe, iterate, etc.
/// See [ez-streams documentation](https://github.com/Sage/ez-streams/blob/master/README.md) for details.
///
/// For example, you can read a class, transform the instances returned by the query
/// and write the result to a JSON file in a single statement:
///
/// ```javascript
/// MyClass.query(_)
/// .where({ user: 'ME' }) // select only my instances
/// .orderBy({ createdDate: +1 }) // order by ascending creation date
/// .execute(_) // execute the query to get an ez-streams reader
/// .map(myInstanceMapper)
/// .transform(ez.transforms.json.formatter()) // convert records to JSON
/// .pipe(_, ez.devices.file.text.writer('myfile.json')); // pipe to the output file
/// ```

import { _ } from 'streamline-runtime';
import { Record } from '../engine/drivers/types';
import * as util from '../engine/runtime/util';
import * as ez from 'ez-streams';
import { Cache } from '../supervisor/cache';
import { Class } from '../supervisor/meta/types';
import { ColumnDesc } from '../supervisor/meta/types';
import { Instance } from '../supervisor/dyn/types';
import * as instanceProxy from './instance-proxy';
import readerProxy from './reader-proxy';
import * as x3jsUtil from './util';

function combineFilters(f1: any, f2: any) {
	return Object.keys(f2).reduce((r, k) => {
		if (r[k]) {}
	}, Object.assign({}, f1));
}

export interface ClassQueryOptions {
	where?: any;
	orderBy?: any;	
}

export interface OrderBy {
	[name: string]: number;
}

export class ClassQuery {
	_class: Class;
	_wheres: any[];
	_orderBy: OrderBy; 

	constructor(clas: Class, options?: ClassQueryOptions) {
		this._class = clas;
		this._wheres = [];
		this.where(options && options.where);
		this._orderBy = options && options.orderBy;
	}
	///
	/// #### Building a query
	///
	/// * `query.where(condition)`: adds a _where_ clause to the query. 
	///    `condition` is described in [instance filters](x3js-instance-filters). 
	///    Returns `this` for chaining.
	where(condition: any) {
		if (condition) this._wheres.push(condition);
		return this;
	}
	/// * `query.orderBy(order)`: specifies the _order by_ clause of the query. 
	///   `order`  is an object with column names as keys and +1 / -1 values (asc / desc respectively). 
	///    Returns `this` for chaining.
	orderBy(order: OrderBy) {
		this._orderBy = order;
	}
	///
	/// #### Executing a query
	///
	/// * `query.execute(_)`:  executes the query and returns an ez-streams reader on
	///   which other methods can be chained.
	execute() {
		return x3jsUtil.wait(_ => {
			const clas = this._class;
			if (!clas.table) throw new Error(clas.name + ": cannot query: no table mapping");
			const recordMapper = (_: _, record: Record) => instanceProxy.create(clas.supervisor.new<Instance>(_, 'Instance', clas).afterCreate(_, record));

			const properties = clas.properties;
			const param = clas.supervisor.sqlDriver.param;
			const tableNames = [clas.table.name + ' T'];
			const columnNames: string[] = [];
			const wheres: any[] = [];
			var orderBy: string[];
			const descs: ColumnDesc[] = [];
			const params: string[] = [];
			const sqlOpts = {};
			const cache = new Cache();

			// add link with ACCES if ACCSTR is filled.
			if (clas.data.ACCSTR) {
				tableNames.push("ACCES ACC");
				params.push(util.currentContext().x3session.userName);
				wheres.push("ACC.USR_0 = " + param(params.length - 1));
				wheres.push("ACC.CODACC_0 = T." + clas.data.ACCSTR + "_0");
				wheres.push("ACC.CONSUL_0 = 2");
			}

			Object.keys(properties).forEach_(_, (_, name) => {
				if (properties[name].getSql) properties[name].getSql(_, columnNames, tableNames, wheres, params, descs, cache, false, sqlOpts);
			});
			if (columnNames.length === 0) throw new Error(`${ clas.name }: cannot query: empty columns list`);

			if (this._orderBy) {
				orderBy = Object.keys(this._orderBy).map(k => {
					const prop = clas.membersByJsName[k];
					if (!prop) throw new Error("sort property not found: " + clas.jsName + '.' + k);
					return prop.column.sqlName() + (this._orderBy[k] < 0 ? ' desc' : ' asc');
				});
			} else {
				// sort by primary key
				orderBy = clas.tableIndex && clas.tableIndex.sqlNames().map(name => name + ' asc');
			}
			if (this._wheres.length > 0) {
				const filters = this._wheres.length === 1 ? this._wheres[0] : {
					$and: this._wheres
				};
				var qsel = clas.queryToSelect(_, filters, params, true);
				if (qsel !== "") wheres.push(qsel);
			}
			var sql = "select T.UPDTICK_0, " + columnNames.join(',') + " from " + tableNames.join(',');
			if (wheres.length) sql += " where (" + wheres.join(') and (') + ')';
			if (orderBy && orderBy.length) sql += " order by " + orderBy.join(',');
			const reader = this._class.supervisor.sqlReader(_, sql, params, sqlOpts).map(recordMapper);
			// investigate cache later
			// if (cache.isActivated) reader = reader.transform(cache.transform());

			return readerProxy(reader);
		});
	}
}
