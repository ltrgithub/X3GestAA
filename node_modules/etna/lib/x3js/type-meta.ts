import { _ } from 'streamline-runtime';
import { Supervisor } from '../supervisor/supervisor';
import { PropertyDef, EnumPropertyDef, DecimalPropertyDef, StringPropertyDef  } from './class-proxy';
import { TypeMeta } from '../supervisor/metadata/type';

type Dict<T> = { [name: string]: T; };

function cast<T>(x: any): T { return x; };

const fromName: Dict<(prop: PropertyDef, supervisor?: Supervisor) => TypeMeta> = {
	boolean(prop) {
		return {
			CODTYP: 'M',
			LONG: '4',
			NOLIB: 1
		};
	},
	enum(prop, supervisor) {
		//if (!prop.dictCode && !prop.enum) throw new Error(`property ${prop.name}: missing dictCode`)
		const enumProp: EnumPropertyDef = cast(prop);
		return {
			CODTYP: 'M',
			LONG: 4,
			NOLIB: enumProp.chapter,
			ENUM: enumProp.enum
		};
	},
	short(prop) {
		return {
			CODTYP: 'C',
			LONG: 4
		};
	},
	integer(prop) {
		return {
			CODTYP: 'L',
			LONG: 8
		};
	},
	decimal(prop) {
		const decimalProp: DecimalPropertyDef = cast(prop);
		const precision = decimalProp.precision;
		if (precision == null) throw new Error("precision missing: " + prop.name);
		const scale = decimalProp.scale || 0;
		return {
			CODTYP: 'DCB',
			LONG: precision - scale + scale / 10
		};
	},
	double(prop): TypeMeta {
		throw new Error("Double type disabled - no type in dictionary");
		/*return {
			CODTYP: 'CTD'
		};*/
	},
	string(prop) {
		const stringProp: StringPropertyDef = cast(prop);
		return {
			CODTYP: stringProp.maxLength > 0 ? 'A' : 'AC0',
			LONG: stringProp.maxLength || '1' };
	},
	// weird for blob
	date(prop) {
		return {
			CODTYP: 'D'
		};
	},
	datetime(prop) {
		return {
			CODTYP: 'ADATIM'
		};
	},
	uuid(prop) {
		return {
			CODTYP: 'AUUID'
		};
	},
	binary(prop) {
		return {
			CODTYP: 'AB0',
			LONG: 1
		};
	}
};

export function fromProperty(supervisor: Supervisor, prop: PropertyDef) {
	const typefn = fromName[prop.type];
	if (typefn == null) throw new Error(prop.name + ': bad property type: ' + prop.type);
	return typefn(prop, supervisor);
};