"use strict";

const runtime = require('etna/lib/engine/runtime/runtime');
const tdate = require('etna/lib/engine/runtime/tdate');
const tdatetime = require('etna/lib/engine/runtime/tdatetime');
const tblbfile = require('etna/lib/engine/runtime/tblbfile');
const constants = require('etna/lib/supervisor/constants');
const classProxy = require('./classProxy');
const enumProxy = require('./enumProxy');
const messageProxy = require('./messageProxy');
const util = require('../supervisor/util');
const uuid = require('syracuse-core').uuid; // don't use tuuid - we want strings not buffers

const STRING_API = {
	format: (fmt, val) => {
		return runtime.functions.FORMAT$.fn(fmt, val);
	}
}

const BLOB_API = {
	fromBase64: str => new tblbfile.Blbfile(new Buffer(str, 'base64')),
};

const PREDICATES = {
	startsWith: function(str, ignoreCase) {
		return {
			$regex: "^" + str,
			$options: ignoreCase ? 'i' : undefined,
		};
	}
}

const CONSTANTS = Object.keys(constants).filter(k => /^CST_A/.test(k)).reduce((r, k) => {
	r[k.substring(5)] = constants[k];
	return r;
}, {});

module.exports = {
	get string() {
		return STRING_API;
	},
	get date() {
		return tdate;
	},
	get datetime() {
		return tdatetime;
	},
	get uuid() {
		return uuid;
	},
	get blob() {
		return BLOB_API;
	},
	get predicates() {
		return PREDICATES;
	},
	constants: CONSTANTS,
	defineClass(def) {
		// see later if we need to do something here...
		return def;
	},
	defineEnum(def) {
		return enumProxy.create(def);
	},
	defineMessages(def) {
		return messageProxy.create(def);
	},
	/// #### Accessing metadata artifacts
	/// 
	/// * `x3js.class('moduleName.ClassName')`  
	///   returns a class artifact
	class(path) {
		return classProxy.load(path);
	},
	/// * `x3js.enum('moduleName.EnumName')`  
	///   returns an enum artifact
	enum(path) {
		return enumProxy.load(path);
	},
	/// * `x3js.messages('moduleName.MessagesName')`  
	///   returns a message list artifact
	messages(path) {
		return messageProxy.load(path);
	},
};

