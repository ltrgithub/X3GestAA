"use strict";
/// !doc
/// [x3js dev guide](x3js-development-guide) > [x3js APIs](x3js-apis) > x3js table manager
/// 
/// # x3js table manager
/// 
/// Table artifacts are obtained with:
/// 
/// ```javascript
///  const MYTABLE = x3js.table('myModule.MYTABLE');
/// ```
/// where _MYTABLE_ is the name of a table. For example: 
/// 
/// ```javascript
/// const TABCOUNTRY = x3js.table('system.TABCOUNTRY');
/// ```
/// 
/// By convention, table variables are in UPPERCASE and match the names of the SQL tables.
/// 
/// Once you have a handle to a table, you can use it to perform SQL operations on the table 
/// with the API described below.

require('harmony-reflect'); // to get ES6 Proxy API
const glob = require('streamline-runtime').globals;
const datetime = require('syracuse-core').types.datetime;
const TableQuery = require('./tableQuery').TableQuery;
const x3jsUtil = require('etna/lib/x3js/util');

class ColumnWrapper {
	constructor(column) {
		this.column = column;
	}
	get name() {
		return this.column.name;
	}
}

class TableHandler {
	constructor(path) {
		this._path = path;
		this._handle = null;
	}

	table(_) {
		if (this._handle) return this._handle;
		const supervisor = glob.context.x3session.supervisor;
		if (!supervisor) throw new Error("internal error: no supervisor");
		if (this._handle) {
			if (this._handle.supervisor !== supervisor) throw new Error("internal error: supervisor mismatch");
			return this._handle;
		}

		const segs = this._path.split('.');
		if (segs.length !== 2) throw new Error(`invalid table path syntax: ${this._path}`);
		this._handle = supervisor.load(_, 'Table', segs[1]);
		if (!this._handle) throw new Error(`table not found: ${this._path}`);
		return this._handle;
	}
	/// 
	/// #### Query and read
	/// 
	/// * `MYTABLE.query(_, alias = '')`: creates a query on the table.  
	///    See the [table query API](x3js-table-query) for details on the query object returned by this call.
	query(_, alias) {
		const table = this.table(_);
		return new TableQuery(table, alias);
	}
	/// * `MYTABLE.readRecord(_, key)`: reads a record from the table.  
	///   `key` may be:
	///   * a single value (simple primary key)
	///   * an array (composite primary key)
	///   * a JS object which will give the column names and their values.
	readRecord(_, key, opts) {
		if (key == null) throw new Error("null key!");
		opts = Object.assign({
			// limit: 1,
		}, opts || {});
		const table = this.table(_);
		var reader;
		if (Array.isArray(key)) {
			reader = table.reader(_, table.indexes[0], key, null, null, opts);
		} else if (typeof key !== 'object') {
			reader = table.reader(_, table.indexes[0], [key], null, null, opts);			
		} else {
			reader = table.reader(_, null, key, null, null, opts);
		}
		var rec = reader.read(_);
		if (rec) {
			reader.stop(_);
			// convert to X3 types
			Object.keys(rec).forEach_(_, (_, name) => {
				rec[name] = table.columns[name].type.fromSql(_, rec[name]);
			});
		}
		else if ('notFound' in opts) return opts.notFound;
		return rec;
	}
	/// 
	/// #### Insert, update, delete
	/// 
	/// * `MYTABLE.insertRecord(_, values)`: inserts a record into the table.  
	///   `values` contain the record's column values.
	insertRecord(_, values) {
		const table = this.table(_);
		const actx = glob.context.x3session.actx;
		const user = actx.$USER(_);
		values.CREDATTIM = values.CREDATTIM || datetime.now();
		values.CREUSR = values.CREUSR || user;
		values.UPDUSR = user;
		values.UPDDATTIM = datetime.now();
		return table.insertRecord(_, values);
	}
	/// * `MYTABLE.updateRecord(_, key, values)`: updates a record from the table.  
	///   `key`  is the record's key value (see `readRecord`  above).  
	///   `values` contain the record's column values.  
	///   Note: you only need to provide the columns that have been modified in `values`.
	updateRecord(_, key, values) {
		const actx = glob.context.x3session.actx;
		const user = actx.$USER(_);
		values.CREDATTIM = values.CREDATTIM || datetime.now();
		values.CREUSR = values.CREUSR || user;
		values.UPDUSR = user;
		values.UPDDATTIM = datetime.now();
		return this.table.updateRecord(_, key, values);
	}
	/// * `MYTABLE.deleteRecord(_, key)`: deletes a record from the table.  
	///   `key`  is the record's key value (see `readRecord`  above).  
	deleteRecord(_, key) {
		const table = this.table(_);
		const actx = glob.context.x3session.actx;
		const user = actx.$USER(_);
		return table.deleteRecord(_, key);
	}
	/// * `MYTABLE.deleteAllRecords(_)`: removes all the table's records.  
	///   _Use with care_.  
	deleteAllRecords(_) {
		const table = this.table(_);
		return table.clear(_);
	}

	// internal??
	column(_, name) {
		const table = this.table(_);
		const column = table.columns[name];
		if (!column) throw new Error("column not found: " + table.name + '.' + name);
		return new ColumnWrapper(column);
	}
}

const handlers = {};

// internal - don't document
exports.load = function(path) {
	if (!handlers[path]) handlers[path] = new TableHandler(path);
	return handlers[path];
}

exports.define = function(def) {
	if (!def.name) throw new Error(`table name missing`);
	return def;
}
