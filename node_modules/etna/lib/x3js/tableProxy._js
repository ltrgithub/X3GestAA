"use strict";

require('harmony-reflect'); // to get ES6 Proxy API
const glob = require('streamline-runtime').globals;
const datetime = require('syracuse-core').types.datetime;
const TableQuery = require('./tableQuery').TableQuery;

class ColumnWrapper {
	constructor(column) {
		this.column = column;
	}
	get name() {
		return this.column.name;
	}
}

class TableWrapper {
	constructor(table) {
		this.table = table;
	}
	$clear(_) {
		return this.table.clear(_);
	}
	$insertRecord(_, values) {
		const actx = glob.context.x3session.actx;
		const user = actx.$USER(_);
		values.CREDATTIM = values.CREDATTIM || datetime.now();
		values.CREUSR = values.CREUSR || user;
		values.UPDUSR = user;
		values.UPDDATTIM = datetime.now();
		return this.table.insertRecord(_, values);
	}
	/// `table.readRecord(_, key)`: reads a record.  
	/// `key` may be:
	/// 
	/// * a single value (simple primary key)
	/// * an array (composite primary key)
	/// * a JS object which will give the column names and their values.
	$readRecord(_, key, opts) {
		if (key == null) throw new Error("null key!");
		opts = Object.assign({
			// limit: 1,
		}, opts || {});
		var reader;
		if (Array.isArray(key)) {
			reader = this.table.reader(_, this.table.indexes[0], key, null, null, opts);
		} else if (typeof key !== 'object') {
			reader = this.table.reader(_, this.table.indexes[0], [key], null, null, opts);			
		} else {
			reader = this.table.reader(_, null, key, null, null, opts);
		}
		var rec = reader.read(_);
		if (rec) {
			reader.stop(_);
			// convert to X3 types
			Object.keys(rec).forEach_(_, (_, name) => {
				rec[name] = this.table.columns[name].type.fromSql(_, rec[name]);
			});
		}
		else if ('notFound' in opts) return opts.notFound;
		return rec;
	}
	$column(name) {
		const column = this.table.columns[name];
		if (!column) throw new Error("column not found: " + this.table.name + '.' + name);
		return new ColumnWrapper(column);
	}
}

class TablesHandler {
	constructor(supervisor) {
		this.supervisor = supervisor;
		this.getters = {};
	}
	get(name) {
		if (name[0] === '$') {
			if (this[name] == null) throw new Error("invalid table factory method: " + name);
			return this[name].bind(this);
		}
		return this.getters[name] || { get : (_) => {
			var wrapper = new TableWrapper(this.supervisor.load(_, 'Table', name));
			// create fast getter
			this.getters[name] =  { get: (_) => wrapper };
			return wrapper;
		}};
	}
	$query(tableName, alias) {
		return new TableQuery(this.supervisor, tableName, alias);
	}
}

exports.create = function(supervisor) {
	return new Proxy(supervisor, {
		get: function(supervisor, name) {
			//console.error("PROXY GET", name);
			supervisor.tablesHandler = supervisor.tablesHandler || new TablesHandler(supervisor);
			return supervisor.tablesHandler.get(name);
		},
	});
}