"use strict";
/// !doc
/// [x3js dev guide](x3js-development-guide) > [x3js APIs](x3js-apis) > x3js table manager
/// 
/// # x3js table manager
/// 
/// Every X3 application folder has a table manager, which give access to the folder's tables.
///
/// The table manager is usually obtained from an existing instance, as `instance.$tables`.
/// 
/// The tables themselves can be obtained with:
/// 
/// ```javascript
///  const MYTABLE = instance.$tables.MYTABLE$;
/// ```
/// where _MYTABLE_ is the name of a table. For example: `const ABANK = instance.$tables.ABANK$`.
/// 
/// By convention, table variables are in UPPERCASE and match the names of the SQL tables.
/// 
/// Once you have a handle to a table, you can use it to perform SQL operations on the table 
/// with the API described below.
/// 
/// Note: you should never store a reference to a table in a global script variable because table definitions are specific to 
/// a folder. You should always retrieve tables via the `$tables` property of another object.

require('harmony-reflect'); // to get ES6 Proxy API
const glob = require('streamline-runtime').globals;
const datetime = require('syracuse-core').types.datetime;
const TableQuery = require('./tableQuery').TableQuery;
const x3jsUtil = require('etna/lib/x3js/util');

class ColumnWrapper {
	constructor(column) {
		this.column = column;
	}
	get name() {
		return this.column.name;
	}
}

class TableWrapper {
	constructor(table) {
		this.table = table;
	}
	/// 
	/// #### Query and read
	/// 
	/// * `MYTABLE.query(alias = '')`: creates a query on the table.  
	///    See the [table query API](x3js-table-query) for details on the query object returned by this call.
	query(alias) {
		return new TableQuery(this.supervisor, this.table.name, alias);
	}
	/// * `MYTABLE.readRecord(_, key)`: reads a record from the table.  
	///   `key` may be:
	///   * a single value (simple primary key)
	///   * an array (composite primary key)
	///   * a JS object which will give the column names and their values.
	readRecord(_, key, opts) {
		if (key == null) throw new Error("null key!");
		opts = Object.assign({
			// limit: 1,
		}, opts || {});
		var reader;
		if (Array.isArray(key)) {
			reader = this.table.reader(_, this.table.indexes[0], key, null, null, opts);
		} else if (typeof key !== 'object') {
			reader = this.table.reader(_, this.table.indexes[0], [key], null, null, opts);			
		} else {
			reader = this.table.reader(_, null, key, null, null, opts);
		}
		var rec = reader.read(_);
		if (rec) {
			reader.stop(_);
			// convert to X3 types
			Object.keys(rec).forEach_(_, (_, name) => {
				rec[name] = this.table.columns[name].type.fromSql(_, rec[name]);
			});
		}
		else if ('notFound' in opts) return opts.notFound;
		return rec;
	}
	/// 
	/// #### Insert, update, delete
	/// 
	/// * `MYTABLE.insertRecord(_, values)`: inserts a record into the table.  
	///   `values` contain the record's column values.
	insertRecord(_, values) {
		const actx = glob.context.x3session.actx;
		const user = actx.$USER(_);
		values.CREDATTIM = values.CREDATTIM || datetime.now();
		values.CREUSR = values.CREUSR || user;
		values.UPDUSR = user;
		values.UPDDATTIM = datetime.now();
		return this.table.insertRecord(_, values);
	}
	/// * `MYTABLE.updateRecord(_, key, values)`: updates a record from the table.  
	///   `key`  is the record's key value (see `readRecord`  above).  
	///   `values` contain the record's column values.  
	///   Note: you only need to provide the columns that have been modified in `values`.
	updateRecord(_, key, values) {
		const actx = glob.context.x3session.actx;
		const user = actx.$USER(_);
		values.CREDATTIM = values.CREDATTIM || datetime.now();
		values.CREUSR = values.CREUSR || user;
		values.UPDUSR = user;
		values.UPDDATTIM = datetime.now();
		return this.table.updateRecord(_, key, values);
	}
	/// * `MYTABLE.deleteRecord(_, key)`: deletes a record from the table.  
	///   `key`  is the record's key value (see `readRecord`  above).  
	deleteRecord(_, key) {
		const actx = glob.context.x3session.actx;
		const user = actx.$USER(_);
		return this.table.deleteRecord(_, key);
	}
	/// * `MYTABLE.deleteAllRecords(_)`: removes all the table's records.  
	///   _Use with care_.  
	deleteAllRecords(_) {
		return this.table.clear(_);
	}

	// internal??
	column(name) {
		const column = this.table.columns[name];
		if (!column) throw new Error("column not found: " + this.table.name + '.' + name);
		return new ColumnWrapper(column);
	}
}

class TablesHandler {
	constructor(supervisor) {
		this.supervisor = supervisor;
		this.getters = {};
	}
	get(name) {
		if (name[0] === '$') {
			if (this[name] == null) throw new Error("invalid table factory method: " + name);
			return this[name].bind(this);
		}
		return this.getters[name] || { get : (_) => {
			var wrapper = new TableWrapper(this.supervisor.load(_, 'Table', name));
			// create fast getter
			this.getters[name] =  { get: (_) => wrapper };
			return wrapper;
		}};
	}
}

exports.create = function(supervisor) {
	return new Proxy(supervisor, {
		get: function(supervisor, name) {
			//console.error("PROXY GET", name);
			supervisor.tablesHandler = supervisor.tablesHandler || new TablesHandler(supervisor);
			return supervisor.tablesHandler.get(name);
		},
	});
}