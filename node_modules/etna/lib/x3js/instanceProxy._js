"use strict";

require('harmony-reflect'); // to get ES6 Proxy API
const glob = require('streamline-runtime').globals;
const runtime = require('etna/lib/engine/runtime/runtime');
const util = require('etna/lib/supervisor/util');
const classModule = require('etna/lib/supervisor/meta/class');
const constants = require("etna/lib/supervisor/constants");
const collectionProxy = require('etna/lib/x3js/collectionProxy');
const instanceProxy = exports;

const instructions = {
	TRBEGIN: runtime.instructions.TRBEGIN(),
	COMMIT: runtime.instructions.COMMIT(),
	ROLLBACK: runtime.instructions.ROLLBACK(),
}

const STATUSES = {
	[constants.CST_ANEW] : "new",
	[constants.CST_ADEL] : "deleted",
	[constants.CST_ANEWDEL] : null,
};


class Invoker {
	constructor(instance) {
		this.instance = instance;
	}
	get $classes() {
		return this.instance.supervisor.api.classes;
	}
	get $tables() {
		return this.instance.supervisor.api.tables;
	}
	get $parent() {
		return instanceProxy.create(this.instance.APARENT);
	}
	get $snapshot() {
		return instanceProxy.create(this.instance.snapshot());
	}
	get $status() {
		const status = STATUSES[this.instance.$astalin];
		if (!status) throw new Error("bad instance status: " + this.instance.$astalin);
		return status;
	}
	$cache(_, jsClassName, key, jsPropName) {
		// load class by js name to get its 4GL name
		var clas = this.instance.supervisor.loadClassByJsName(_, jsClassName);
		if (!clas) throw new Error('cache class not found: ' + jsClassName);
		// lookup prop by js name to get its 4GL name
		var prop = clas.membersByJsName[jsPropName];
		if (!prop) throw new Error('cache property not found: ' + jsClassName + '.' + jsPropName);

		var acache = glob.context.x3session.actx.get(_, 'ACACHE');
		var cl = acache.get(_, clas.name);
		//console.error("CACHE LOOKUP", clas.name, key, prop.name);
		return cl.AGETVALNUM(_, key, prop.name);
	}
	$error(_, text) {
		this.instance.ASETERROR(_, this.args.CURPTH, text, 4); // CST_AERROR == 4
		// todo: set astatus
	}
	// following API are not tied to THIS. Move to helper?
	$message(_, id, chapter, swtch) {
		return runtime.functions.MESS.fn(_, id, chapter, swtch);
	}
	$withTransaction(_, body) {
		instructions.TRBEGIN(_);
		try {
			body(_);
			instructions.COMMIT(_);
		} catch (ex) {
			instructions.ROLLBACK(_);
			throw ex;
		}
	}
	$user(_) {
		return glob.context.x3session.actx.$USER(_);
	}
	$insert(_) {
		return this.instance.$AINSERT(_);
	}
};

const sysProperties = classModule.systemProperties.reduce(function(names, prop) {
	names[prop.FLDCLA] = prop;
	return names;
}, {});

class PropertyHandler {
	constructor(instance, key) {
		this.instance = instance;
		this.key = key;
	}
	get(_) {
		var val = this.instance.get(_, this.key);
		if (util.isCollection(val)) val = collectionProxy.create(val);
		else if (util.isInstance(val)) val = instanceProxy.create(val);
		return val;
	}
	set(_, val) {
		if (val && val.$instance) val = val.$instance;
		this.instance.set(_, this.key, val);
	}
	$error(_, text) {
		this.instance.ASETERROR(_, util.path(this.instance, this.key), text, 4); // CST_AERROR == 4
		// todo: set astatus
	}
}

function lookupJsMembers(instance, key, name) {
	const bases = instance.APARENT 
		? lookupJsMembers(instance.APARENT, '$relations', instance.$parent.proJsName)  // instance.$parent is the collection!
		: instance.class.jsModules;
	return bases.map(base => base[key] && base[key][name]).filter(base => !!base);
}

class ClassHandler {
	constructor(clas) {
		const self = this;
		this.class = clas;
	}
	get(instance, name) {
		const prop = this.class.membersByJsName[name];
		if (prop) return new PropertyHandler(instance, prop.name);
		const methods = lookupJsMembers(instance, '$methods', name);
		if (methods.length > 0) return methods.pop().bind(instanceProxy.create(instance)); // todo: reuse proxy
		if (/^(inspect|toString|stack)$/.test(name)) return typeof instance[name] === 'functtion' ? instance[name].bind(instance) : instance[name]; 
		throw new Error("member not found: " + this.class.name + "." + name);
	}
	ownKeys() {
		const self = this;
		return self.proxyKeys || (self.proxyKeys = Object.keys(this.class.properties) //
			.filter((code) => !sysProperties[code])
			.map((code) => self.class.properties[code].jsName));
	}
}

instanceProxy.create = instance => {
	if (!instance) return null;
	return Proxy(instance, {
		get: function(instance, name) {
			//console.error("INSTANCE GET", name);
			if (name[0] === '$') {
				if (name === '$instance') return instance;
				var invoker = new Invoker(instance);
				var member = invoker[name];
				if (member === undefined) throw new Error("invalid member: " + name);
				return typeof member === 'function' ? member.bind(invoker) : member;
			}
			// TODO: hook up sys members
			instance.meta.handler = instance.meta.handler || new ClassHandler(instance.meta);
			return instance.meta.handler.get(instance, name);
		},
		ownKeys: function(instance) {
			instance.meta.handler = instance.meta.handler || new ClassHandler(instance.meta);
			return instance.meta.handler.ownKeys();

		}
	});
}
