"use strict";
/// !doc
/// [x3js dev guide](x3js-development-guide) > [x3js APIs](x3js-apis) > x3js instance
/// 
/// # x3js instance
/// 

require('harmony-reflect'); // to get ES6 Proxy API
const glob = require('streamline-runtime').globals;
const runtime = require('etna/lib/engine/runtime/runtime');
const util = require('etna/lib/supervisor/util');
const x3jsUtil = require('etna/lib/x3js/util');
const classModule = require('etna/lib/supervisor/meta/class');
const constants = require("etna/lib/supervisor/constants");
const SlotCollection = require("etna/lib/supervisor/slotCollection").SlotCollection;
const collectionProxy = require('etna/lib/x3js/collectionProxy');
const instanceProxy = exports;

const instructions = {
	TRBEGIN: runtime.instructions.TRBEGIN(),
	COMMIT: runtime.instructions.COMMIT(),
	ROLLBACK: runtime.instructions.ROLLBACK(),
}

const STATUSES = {
	0 : "original",
	[constants.CST_ANEW] : "new",
	[constants.CST_AUPD] : "modified",
	[constants.CST_ADEL] : "deleted",
	[constants.CST_ANEWDEL] : null,
};


class Invoker {
	constructor(instance) {
		this.instance = instance;
	}
	/// 
	/// ## Properties
	/// 
	/// * `instance.$classes`: [class manager](x3js-class-manager) for the instance. 
	get $classes() {
		return this.instance.supervisor.api.classes;
	}
	/// * `instance.$tables`: [table manager](x3js-table-manager) for the instance. 
	get $tables() {
		return this.instance.supervisor.api.tables;
	}
	/// * `instance.$cache`: [cache manager](x3js-cache-manager) for the instance. 
	//get $cache() {
	//	return this.instance.supervisor.api.cache;
	//}
	/// * `instance.$context`: [context manager](x3js-context-manager) for the instance. 
	get $context() {
		return this.instance.supervisor.api.context;
	}
	/// * `instance.$parent`: parent instance. 
	get $parent() {
		return instanceProxy.create(this.instance.APARENT);
	}
	/// * `instance.$snapshot`: the instance's snapshot. 
	get $snapshot() {
		return instanceProxy.create(this.instance.snapshot());
	}
	/// * `instance.$status`: the instance's modification status, one of 'original', 'modified', 'new', 'deleted'
	get $status() {
		const status = STATUSES[this.instance.$astalin];
		if (!status) throw new Error("bad instance status: " + this.instance.$astalin);
		return status;
	}
	/// 
	/// ## Methods
	/// 
	/// * `instance.$data(_, full = false)`: returns the instance's properties and their values as a plain JavaScript object.
	///   If `full` is false, only the properties are returned. If true, the collections are also returned, as
	///   arrays of plain JavaScript objects (recursively if several levels of collections).
	$data(_, full) {
		return Object.keys(this.slots).reduce_(_, (_, r, name) => {
			if (r[name] instanceof SlotCollection) {
				if (full) r[name] = r[name].lines.map_(_, (_, child) => child.$data(_, full));
			} else {
				r[name] = x3jsUtil.toJs(r[name]);
			}
			return r;
		}, {});
	}

	// use cache manager API instead
	$cache(_, jsClassName, key, jsPropName) {
		// load class by js name to get its 4GL name
		var clas = this.instance.supervisor.loadClassByJsName(_, jsClassName);
		if (!clas) throw new Error('cache class not found: ' + jsClassName);
		// lookup prop by js name to get its 4GL name
		var prop = clas.membersByJsName[jsPropName];
		if (!prop) throw new Error('cache property not found: ' + jsClassName + '.' + jsPropName);

		var acache = glob.context.x3session.actx.get(_, 'ACACHE');
		var cl = acache.get(_, clas.name);
		//console.error("CACHE LOOKUP", clas.name, key, prop.name);
		return cl.AGETVALNUM(_, key, prop.name);
	}
	/// 
	/// #### Instance level error, warning and info messages
	/// 
	/// * `instance.$error(_, text)`:  adds an error to the instance.
	$error(_, text) {
		this.instance.ASETERROR(_, this.args.CURPTH, text, constants.CST_AERROR);
	}
	/// * `instance.$warn(_, text)`:  adds a warning to the instance.
	$warn(_, text) {
		this.instance.ASETERROR(_, this.args.CURPTH, text, constants.CST_AWARNING);
	}
	/// * `instance.$info(_, text)`:  adds an information message to the instance.
	$info(_, text) {
		this.instance.ASETERROR(_, this.args.CURPTH, text, constants.CST_AINFO);
	}
	/// * `instance.$message(_, chapter, id)`: returns message `id` from chapter `chapter`
	// TODO; investigate 9001 offset  and fix
	$message(_, id, chapter, swtch) {
		return runtime.functions.MESS.fn(_, id, chapter, swtch);
	}
	/// * `instance.$withTransaction(_, body)` executes `body(_)` inside a transation.
	///   The transaction will be committed if `body` returns normally and rollbacked if `body` throws
	///   an exception.
	$withTransaction(_, body) {
		instructions.TRBEGIN(_);
		try {
			body(_);
			instructions.COMMIT(_);
		} catch (ex) {
			instructions.ROLLBACK(_);
			throw ex;
		}
	}
	// user is now handled by context manager
	$user(_) {
		return glob.context.x3session.actx.$USER(_);
	}
	// deprecated, use $save instead
	$insert(_) {
		return this.instance.$AINSERT(_);
	}
	/// 
	/// #### CRUD methods
	/// * `instance.$save(_)`: saves the instance to the database. 
	///    The instance is inserted if its `$status` is `'new'`, updated otherwise. 
	$save(_) {
		if (this.instance.$astalin === constants.CST_ANEW)
			return this.instance.$AINSERT(_);
		else
			return this.instance.$AUPDATE(_);
	}
	/// * `instance.$delete(_)`: deletes the instance from the database. 
	///    The instance is inserted if its `$status` is `'new'`, updated otherwise. 
	$delete(_) {
		return this.instance.$ADELETE(_);
	}
	/// Note: instances are read via the [class manager](x3js-class-manager).
};

const sysProperties = classModule.systemProperties.reduce(function(names, prop) {
	names[prop.FLDCLA] = prop;
	return names;
}, {});

// internal class - don't document
class AttributeHandler {
	constructor(instance, path, atb) {
		this.instance = instance;
		this.path = path;
		this.atb = atb;
	}
	get(_) {
		return x3jsUtil.boolOut(this.instance.getPropertyAttribute(_, this.path, this.atb));
	}
	set(_, val) {
		return this.instance.setPropertyAttribute(_, this.path, this.atb, x3jsUtil.boolIn(val));
	}
}

class PropertyHandler {
	constructor(instance, key) {
		this.instance = instance;
		this.key = key;
		this._path = null;
	}
	get path() {
		return this._path || (this._path = util.path(this.instance, this.key));
	}
	/// 
	/// #### Accessing property values
	/// 
	/// * `val = instance.prop$`: gets the value of the instance's property _prop_.
	get(_) {
		var val = this.instance.get(_, this.key);
		if (util.isCollection(val)) val = collectionProxy.create(val);
		else if (util.isInstance(val)) val = instanceProxy.create(val);
		return val;
	}
	/// * `instance.prop$ = val`: sets the value of instance`'s property _prop_.
	set(_, val) {
		if (val && val.$instance) val = val.$instance;
		this.instance.set(_, this.key, val);
	}

	/// 
	/// #### Property level level error, warning and info messages
	/// 
	/// * `val = instance.prop.error(_, text)`: adds error `text` to the instance's property _prop_.
	error(_, text) {
		this.instance.ASETERROR(_, this.path, text, constants.CST_AERROR);
	}
	/// * `val = instance.prop.warn(_, text)`: adds warning `text` to the instance's property _prop_.
	warn(_, text) {
		this.instance.ASETERROR(_, this.path, text, constants.CST_AWARNING);
	}
	/// * `val = instance.prop.info(_, text)`: adds info `text` to the instance's property _prop_.
	info(_, text) {
		this.instance.ASETERROR(_, this.path, text, constants.CST_AINFO);
	}
	/// 
	/// #### Property attributes
	/// 
	/// TODO: review implementation to have synchronous access on attributes and remove $ at end.
	/// 
	/// * `val = instance.prop.readOnly$`
	/// * `instance.prop.readOnly$ = val`
	///   gets and sets the _read-only_ attribute on an instance property
	get readOnly() {
		return new AttributeHandler(this.instance, this.path, '$isReadOnly');
	}
	/// * `val = instance.prop.mandatory$`
	/// * `instance.prop.mandatory$ = val`
	///   gets and sets the _mandatory_ attribute on an instance property
	get mandatory() {
		return new AttributeHandler(this.instance, this.path, '$isMandatory');
	}
}

function lookupJsMembers(instance, key, name) {
	const bases = instance.APARENT 
		? lookupJsMembers(instance.APARENT, '$relations', instance.$parent.proJsName)  // instance.$parent is the collection!
		: instance.class.jsModules;
	return bases.map(base => base[key] && base[key][name]).filter(base => !!base);
}

// internal class - don't document
class ClassHandler {
	constructor(clas) {
		const self = this;
		this.class = clas;
	}
	get(instance, name) {
		const prop = this.class.membersByJsName[name];
		if (prop) return new PropertyHandler(instance, prop.name);
		const methods = lookupJsMembers(instance, '$methods', name);
		if (methods.length > 0) return methods.pop().bind(instanceProxy.create(instance)); // todo: reuse proxy
		if (/^(inspect|toString|stack)$/.test(name)) return typeof instance[name] === 'functtion' ? instance[name].bind(instance) : instance[name]; 
		throw new Error("member not found: " + this.class.name + "." + name);
	}
	ownKeys() {
		const self = this;
		return self.proxyKeys || (self.proxyKeys = Object.keys(this.class.properties) //
			.filter((code) => !sysProperties[code])
			.map((code) => self.class.properties[code].jsName));
	}
}

// internal
instanceProxy.create = instance => {
	if (!instance) return null;
	return new Proxy(instance, {
		get: function(instance, name) {
			//console.error("INSTANCE GET", name);
			if (name[0] === '$') {
				if (name === '$instance') return instance;
				var invoker = new Invoker(instance);
				var member = invoker[name];
				if (member === undefined) throw new Error("invalid member: " + name);
				return typeof member === 'function' ? member.bind(invoker) : member;
			}
			// TODO: hook up sys members
			instance.meta.handler = instance.meta.handler || new ClassHandler(instance.meta);
			return instance.meta.handler.get(instance, name);
		},
		ownKeys: function(instance) {
			instance.meta.handler = instance.meta.handler || new ClassHandler(instance.meta);
			return instance.meta.handler.ownKeys();

		}
	});
}
