"use strict";
/// !doc
/// [x3js dev guide](x3js-development-guide) > [x3js APIs](x3js-apis) > x3js instance
/// 
/// # x3js instance
/// 

require('harmony-reflect'); // to get ES6 Proxy API
const glob = require('streamline-runtime').globals;
const runtime = require('etna/lib/engine/runtime/runtime');
const util = require('etna/lib/supervisor/util');
const x3jsUtil = require('etna/lib/x3js/util');
const classModule = require('etna/lib/supervisor/meta/class');
const constants = require("etna/lib/supervisor/constants");
const SlotCollection = require("etna/lib/supervisor/slotCollection").SlotCollection;
const collectionProxy = require('etna/lib/x3js/collectionProxy');
const attributes = require("etna/lib/supervisor/attributes");
const instanceProxy = exports;

const instructions = {
	TRBEGIN: runtime.instructions.TRBEGIN(),
	COMMIT: runtime.instructions.COMMIT(),
	ROLLBACK: runtime.instructions.ROLLBACK(),
}

const STATUSES = {
	0 : "original",
	[constants.CST_ANEW] : "new",
	[constants.CST_AUPD] : "modified",
	[constants.CST_ADEL] : "deleted",
	[constants.CST_ANEWDEL] : null,
};

function instanceError(message, instance) {
	const error = new Error(message);
	error.diagnoses = instance.diagnoses;
	return error;
}

class Invoker {
	constructor(instance) {
		this.instance = instance;
	}
	/// * `instance.$tables`: [table manager](x3js-table-manager) for the instance. 
	/// 
	/// ## Properties
	/// 
	/// * `instance.$classeName`: the name of the instance's class. 
	get $className() {
		return this.instance.class.jsName;
	}
	/// * `instance.$classes`: [class manager](x3js-class-manager) for the instance. 
	get $classes() {
		return this.instance.supervisor.api.classes;
	}
	/// * `instance.$tables`: [table manager](x3js-table-manager) for the instance. 
	get $tables() {
		return this.instance.supervisor.api.tables;
	}
	/// * `instance.$folder`: [current folder](x3js-folder). 
	get $folder() {
		return this.instance.supervisor.api;
	}
	/// * `instance.$parent`: parent instance. 
	get $parent() {
		return instanceProxy.create(this.instance.APARENT);
	}
	/// * `instance.$snapshot`: the instance's snapshot. 
	get $snapshot() {
		return instanceProxy.create(this.instance.snapshot());
	}
	/// * `instance.$status`: the instance's modification status, one of 'original', 'modified', 'new', 'deleted'
	get $status() {
		const status = STATUSES[this.instance.$astalin];
		if (!status) throw new Error("bad instance status: " + this.instance.$astalin);
		return status;
	}
	/// * `instance.$diagnoses`: the instance's diagnoses.
	get $diagnoses() {
		return this.instance.diagnoses.map(x3jsUtil.toJsDiagnose);
	}
	/// 
	/// ## Methods
	/// 
	/// * `instance.$data(_, full = false)`: returns the instance's properties and their values as a plain JavaScript object.
	///   If `full` is false, only the properties are returned. If true, the collections are also returned, as
	///   arrays of plain JavaScript objects (recursively if several levels of collections).
	$data(_, full) {
		return Object.keys(this.slots).reduce_(_, (_, r, name) => {
			const slot = this.slots[name];
			if (slot instanceof SlotCollection) {
				if (full) r[name] = slot.lines.map_(_, (_, child) => child.$data(_, full));
			} else {
				if (slot.property == null) throw new Error("invalid slot: no property");
				r[name] = x3jsUtil.toJs(slot.value, slot.property);
			}
			return r;
		}, {});
	}

	/// 
	/// #### Instance level error, warning and info messages
	/// 
	/// * `instance.$error(_, text)`:  adds an error to the instance.
	$error(_, text) {
		this.instance.ASETERROR(_, this.args.CURPTH, text, constants.CST_AERROR);
	}
	/// * `instance.$warn(_, text)`:  adds a warning to the instance.
	$warn(_, text) {
		this.instance.ASETERROR(_, this.args.CURPTH, text, constants.CST_AWARNING);
	}
	/// * `instance.$info(_, text)`:  adds an information message to the instance.
	$info(_, text) {
		this.instance.ASETERROR(_, this.args.CURPTH, text, constants.CST_AINFO);
	}
	/// * `instance.$withTransaction(_, body)` executes `body(_)` inside a transation.
	///   The transaction will be committed if `body` returns normally and rollbacked if `body` throws
	///   an exception.
	$withTransaction(_, body) {
		instructions.TRBEGIN(_);
		try {
			body(_);
			instructions.COMMIT(_);
		} catch (ex) {
			instructions.ROLLBACK(_);
			throw ex;
		}
	}
	// user is now handled by context manager
	$user(_) {
		return glob.context.x3session.actx.$USER(_);
	}
	// deprecated, use $save instead
	$insert(_) {
		return this.instance.$AINSERT(_);
	}
	/// 
	/// #### CRUD methods
	/// * `instance.$save(_)`: saves the instance to the database. 
	///    The instance is inserted if its `$status` is `'new'`, updated otherwise.   
	///    Throws if the save operation fails.
	$save(_) {
		if (!this.$trySave(_)) throw instanceError("save failed", this.instance);
	}
	/// * `instance.$trySave(_)`: saves the instance to the database.  
	///    same as `$save` but returns true if the operation succeeds, false otherwise.
	$trySave(_) {
		if (this.instance.$astalin === constants.CST_ANEW)
			return this.instance.$AINSERT(_) !== constants.CST_AERROR;
		else
			return this.instance.$AUPDATE(_) !== constants.CST_AERROR;
	}
	/// * `instance.$delete(_)`: deletes the instance from the database. 
	///    Throws if the delete operation fails.
	$delete(_) {
		if (!this.$tryDelete(_)) throw instanceError("delete failed", this.instance);
	}
	/// * `instance.$tryDelete(_)`: deletes the instance from the database. 
	///    same as `$delete` but returns true if the operation succeeds, false otherwise.
	$tryDelete(_) {
		return this.instance.$ADELETE(_) !== constants.CST_AERROR;
	}
	/// Note: instances are read via the [class manager](x3js-class-manager).
};

const sysProperties = classModule.systemProperties.reduce(function(names, prop) {
	names[prop.FLDCLA] = prop;
	return names;
}, {});

// internal class - don't document
class AttributeHandler {
	constructor(instance, path, atb) {
		this.instance = instance;
		this.path = path;
		this.atb = atb;
	}
	get(_) {
		return x3jsUtil.boolOut(this.instance.getPropertyAttribute(_, this.path, this.atb));
	}
	set(_, val) {
		return this.instance.setPropertyAttribute(_, this.path, this.atb, x3jsUtil.boolIn(val));
	}
}

class PropertyHandler {
	constructor(instance, key) {
		this.instance = instance;
		this.key = key;
		this._path = null;
	}
	get path() {
		return this._path || (this._path = util.path(this.instance, this.key));
	}
	/// 
	/// #### Accessing property values
	/// 
	/// * `val = instance.prop$`: gets the value of the instance's property _prop_.
	get(_) {
		const slot = this.instance.slot(_, this.key);
		if (slot == null) throw new Error("property not found: " + this.key);
		const val = slot.get(_);
		if (util.isCollection(val)) return collectionProxy.create(val);
		else return x3jsUtil.toJs(val, slot.property);
	}
	/// * `instance.prop$ = val`: sets the value of instance`'s property _prop_.
	set(_, val) {
		const slot = this.instance.slot(_, this.key);
		if (slot == null) throw new Error("property not found: " + this.key);
		slot.set(_, x3jsUtil.fromJs(val, slot.property));
	}

	/// 
	/// #### Property level level error, warning and info messages
	/// 
	/// * `val = instance.prop.error(_, text)`: adds error `text` to the instance's property _prop_.
	error(_, text) {
		this.instance.ASETERROR(_, this.path, text, constants.CST_AERROR);
	}
	/// * `val = instance.prop.warn(_, text)`: adds warning `text` to the instance's property _prop_.
	warn(_, text) {
		this.instance.ASETERROR(_, this.path, text, constants.CST_AWARNING);
	}
	/// * `val = instance.prop.info(_, text)`: adds info `text` to the instance's property _prop_.
	info(_, text) {
		this.instance.ASETERROR(_, this.path, text, constants.CST_AINFO);
	}
}

/// 
/// #### Property attributes
/// 
/// * `val = instance.prop.atb`
/// * `instance.prop.atb = val`
///   gets and sets the _atb_ attribute on an instance property
/// 
/// This API can be used with the following attributes:
/// 
/// * `isReadOnly`
/// * `isMandatory`
/// * `isHidden`
/// * `isDisabled`
/// * `symbol`
/// * `label`
/// * `style`
/// * `index`
/// * `scale`
/// * `precision`
function addAttributeAccessors(atb) {
	Object.defineProperty(PropertyHandler.prototype, atb, {
		get() {
			const slot = this.instance.allocSlot(this.key);
			return slot.getAttribute('$' + atb);
		},
		set(val) {
			const slot = this.instance.allocSlot(this.key);
			return slot.setAttribute('$' + atb, val);			
		},
	});
}

Object.keys(attributes.extAttributesMeta).forEach(k => {
	addAttributeAccessors(k.substring(1));
});


// TODO extAttributesObject (lazy loaded properties)
// TODO resAttributes (references)

function lookupJsMembers(instance, key, name) {
	const bases = instance.APARENT 
		? lookupJsMembers(instance.APARENT, 'relations', instance.$parent.proJsName)  // instance.$parent is the collection!
		: instance.class.jsModules;
	return bases.map(base => base[key] && base[key][name]).filter(base => !!base);
}

// internal class - don't document
class ClassHandler {
	constructor(clas) {
		const self = this;
		this.class = clas;
	}
	get(instance, name) {
		const prop = this.class.membersByJsName[name];
		if (prop) return new PropertyHandler(instance, prop.name);
		const methods = lookupJsMembers(instance, 'methods', name);
		if (methods.length > 0) return methods.pop().bind(instanceProxy.create(instance)); // todo: reuse proxy
		if (/^(inspect|toString|stack)$/.test(name)) return typeof instance[name] === 'functtion' ? instance[name].bind(instance) : instance[name]; 
		throw new Error("member not found: " + this.class.name + "." + name);
	}
	ownKeys() {
		const self = this;
		return self.proxyKeys || (self.proxyKeys = Object.keys(this.class.properties) //
			.filter((code) => !sysProperties[code])
			.map((code) => self.class.properties[code].jsName));
	}
}

// internal
instanceProxy.create = instance => {
	if (!instance) return null;
	return new Proxy(instance, {
		get: function(instance, name) {
			//console.error("INSTANCE GET", name);
			if (name[0] === '$') {
				if (name === '$instance') return instance;
				var invoker = new Invoker(instance);
				var member = invoker[name];
				if (member === undefined) throw new Error("invalid member: " + name);
				return typeof member === 'function' ? member.bind(invoker) : member;
			}
			// TODO: hook up sys members
			instance.meta.handler = instance.meta.handler || new ClassHandler(instance.meta);
			return instance.meta.handler.get(instance, name);
		},
		ownKeys: function(instance) {
			instance.meta.handler = instance.meta.handler || new ClassHandler(instance.meta);
			return instance.meta.handler.ownKeys();

		}
	});
}
