import { _ } from 'streamline-runtime';
import * as fs from 'fs';
import * as fsp from 'path';
import * as util from '../supervisor/util';
import * as x3jsUtil from './util';
import { OrmTracker } from './orm';
import { Supervisor } from '../supervisor/supervisor';
import { Descriptor, PropertyDescriptor, CollectionDescriptor, FullDescriptor } from './descriptor';

// TODO: add typing to babel APIs
type AstNode = any;
type AstTypes = any;
type AstPath = any;

type Dict<T> = { [name: string]: T; };

class ParseError extends Error {
	isParseError: boolean;

	constructor(filePath: string, node: AstNode, message: string) {
		super(`${ filePath }:${ node && node.loc && node.loc.start.line }: ${ message }`);
		this.isParseError = true;
	}
}
function error(filePath: string, node: AstNode, message: string) {
	return new ParseError(filePath, node, message);
}

function propNode(node: AstNode, key: string) {
	return node.properties.filter((p: AstNode) => p.key.name === key)[0];
}

const specials: Dict<(types: AstTypes, node: AstNode) => [AstNode, any]> = {
	property(types, node) {
		// remove this test once all files have been converted
		if (types.isObjectExpression(node)) return node;
		types.assertCallExpression(node);
		types.assertMemberExpression(node.callee);
		types.assertIdentifier(node.callee.property);
		const type = node.callee.property.name.replace(/Property$/, '');
		node = node.arguments[0];
		types.assertObjectExpression(node);
		// add the missing 'type' node.
		node.properties.push(types.objectProperty(
			types.identifier('type'),
			types.stringLiteral(type)));
		return [node, null];
	},
	enum(types, node) {
		types.assertNumericLiteral(node);
		return [null, {
			dictId: node ? node.value : 0
		}];
		//types.assertCallExpression(node);
		//return node.arguments[0];
	},
	message(types, node) {
		types.assertCallExpression(node);
		types.assertNumericLiteral(node.arguments[0]);
		return [null, {
			dictId: node ? node.arguments[0].value : 0
		}];
	},
}

function asPropertyDescriptor(desc: Descriptor): PropertyDescriptor { return desc as any; };
function asCollectionDescriptor(desc: Descriptor): CollectionDescriptor { return desc as any; };

class Parser {
	filePath: string;
	imports: Dict<string>;
	types: AstTypes;

	constructor(filePath: string, imports: Dict<string>) {
		this.filePath = filePath;
		this.imports = imports;
		// lazy require for babel
		this.types = require('babel-types');
	}
	resolveImport(name: string, sub: string) {
		const str = this.imports[name];
		if (!str) throw new Error(`import not found: ${name}`);
		const m = /\.\.\/\.\.\/([^\/]+)\/([^\/]+)\/([^\/]+)$/.exec(str);
		if (!m) throw new Error(`invalid import path: ${str}`);
		if (m[2] !== sub) throw new Error(`invalid import path: ${str}: expected ${sub}, got ${m[1]}`);
		return util.camelize(m[1]) + '.' + util.camelize(m[3], true);
	}

	parse(desc: Descriptor, dest: any, parent: AstNode, name: string, node: AstNode) {
		const types = this.types;
		try {
			switch (desc.type) {
				case 'string':
				case 'flags':
					if (node) types.assertStringLiteral(node);
					dest[name] = node ? node.value : '';
					break;
				case 'boolean':
					if (node) types.assertBooleanLiteral(node);
					dest[name] = node ? node.value : false;
					break;
				case 'enum':
					if (node) types.assertStringLiteral(node);
					// todo; check validity
					dest[name] = node ? node.value : '';
					break;
				case 'integer':
					if (node) types.assertNumericLiteral(node);
					// todo; check validity
					dest[name] = node ? node.value : 0;
					break;
				case 'event':
					if (node) types.assertIdentifier(node);
					if (node) dest[name] = node.name;
					break;
				case 'type':
					types.assertStringLiteral(node);
					dest[name] = node.value;
					['typeCode', 'classCode'].forEach(k => {
						const n = propNode(parent, k);
						if (n) types.assertStringLiteral(n.value);
						dest[k] = n ? n.value.value : '';
					});
					const enumProp = propNode(parent, 'enum');
					if (enumProp) {
						types.assertIdentifier(enumProp.value);
						dest.enum = this.resolveImport(enumProp.value.name, 'enums');
					}
					['maxLength', 'precision', 'scale'].forEach(k => {
						const n = propNode(parent, k);
						if (n) types.assertNumericLiteral(n.value);
						dest[k] = n ? n.value.value : 0;
					});
					// typeCode is not generated in source on boolean nodes
					if (node.value === 'boolean') dest.typeCode = 'M';
					break;
				case 'object':
					let result: any;
					const asColnDesc = asCollectionDescriptor(desc);
					if (node && asColnDesc.codeGen) {
						[node, result] = specials[asColnDesc.codeGen](types, node);
						if (result != null) {
							dest[name] = result;
							break;
						}
					}
					if (node) types.assertObjectExpression(node);
					dest[name] = Object.keys(desc.properties).reduce((obj, key) => {
						const n = node && propNode(node, key);
						if (node && !n) {
							if (desc.properties[key].isMandatory) throw new Error(`mandatory attribute missing`);
						}
						this.parse(desc.properties[key], obj, node, key, n && n.value);
						return obj;
					}, {});
					if (node) Object.keys(desc.collections || {}).forEach(key => {
						const n = propNode(node, key);
						const colDesc = desc.collections[key];
						if (colDesc.key || colDesc.specialKey) {
							dest[name][key] = {};
							if (!n) return;
							types.assertObjectExpression(n.value);
							n.value.properties.forEach((p: AstNode) => {
								// p.key is either an identifier or a string literal.
								this.parse(colDesc, dest[name][key], n.value, p.key.name || p.key.value, p.value);
							});
						} else if (colDesc.cardinality === 1) {
							if (!n) return;
							types.assertObjectExpression(n.value);
							// pass null as parent - don't allow type properties in this context.
							this.parse(colDesc, dest[name], null, key, n.value);
						} else {
							if (!n) return;
							dest[name][key] = [];
							types.assertArrayExpression(n.value);
							n.value.elements.forEach((elt: AstNode, i: number) => {
								this.parse(colDesc, dest[name][key], n.value, '' + i, elt);
							});
						}
					});
					break;
				default:
					throw new Error(`unhandled type ${ desc.type }`);
			}
		} catch (ex) {
			console.error(ex.stack);
			throw ex.isParseError ? ex : error(this.filePath, node, `${ name }: parsing failed: ${ ex.message }`);
		}
	}
}

export function parseFile<T>(_: _,  filePath: string, descriptor: FullDescriptor<T>) {
	try {
		const source = fs.readFile(filePath, 'utf8', _);
		return exports.parseSource(_, source, filePath, descriptor);
	} catch (ex) {
		console.error(ex.stack);
		throw ex.isParseError ? ex : new Error(`${ filePath }: ${ ex.message }`);
	}
};

export function parseSource<T>(_: _,  source: string, filePath: string, descriptor: FullDescriptor<T>) {
	// lazy require for all babel libraries
	const babel = require('babel-core');
	const traverse = require('babel-traverse').default;
	const types = require('babel-types');
	const ast = babel.transform(source, {
		sourceType: 'module',
		plugins: [require('babel-plugin-syntax-flow')],
	}).ast;
	const found = false;
	const result: x3jsUtil.Parsed = {
		file: filePath,
		ast: ast
	};
	const imports: any = {};

	traverse(ast, {
		ImportDeclaration(path: AstPath) {
			if (!types.isStringLiteral(path.node.source)) return;
			path.node.specifiers.filter(types.isImportDefaultSpecifier).forEach((specifier: AstNode) => {
				imports[specifier.local.name] = path.node.source.value;
			});
		},
		ExportDefaultDeclaration(path: AstPath) {
			path.stop();
			var declaration = path.node.declaration;
			if (types.isIdentifier(declaration)) {
				const binding = path.scope.getBinding(declaration.name);
				if (!binding) throw new Error(`binding not found: ${declaration.name}`);
				if (!binding.path.node.init) throw new Error(`binding is not const: ${declaration.name}`);
				declaration = binding.path.node.init;
			}
			if (!types.isCallExpression(declaration) || !types.isMemberExpression(declaration.callee) || !types.isIdentifier(declaration.callee.property, { name: descriptor.defineMethod })) {
				throw error(filePath, declaration, `default export is not an 'x3js.${ descriptor.defineMethod }' call`);
			}
			const def = declaration.arguments[0];
			result.root = def;
			if (!types.isObjectExpression(def)) throw error(filePath, def, `definition is not an object literal`);
			new Parser(filePath, imports).parse(descriptor, result, null, 'data', def);
		}
	});
	if (!result.root) throw new Error(`${ filePath }: invalid source file: export default not found`);
	return result;
};

export function parseSourceFiles<T>(_: _,  subdir: string, descriptor: FullDescriptor<T>, superv: Supervisor, tracker: OrmTracker) {
	tracker.phase = 'reading source files';
	const root = superv.directories.jsLocal || superv.directories.jsShared;
	if (!root) throw new Error("cannot processs files: root directory missing");
	const results: x3jsUtil.Parsed[] = [];
	fs.readdir(root, _).forEach_(_, (_, sub) => {
		const subPath = fsp.join(root, sub, subdir);
		if (!fs.exists(subPath, _, _)) return;
		fs.readdir(subPath, _).forEach_(_, (_, fname) => {
			if (!fname.endsWith('.ts')) return;
			const filePath = fsp.join(subPath, fname);
			tracker.phaseDetail = filePath;
			const parsed = exports.parseFile(_, filePath, descriptor);

			results.push(parsed);
		});
	});
	return results;
};