"use strict";
/// !doc
/// [x3js dev guide](x3js-development-guide) > [x3js APIs](x3js-apis) > x3js user messages
/// 
/// # x3js user messages
/// 
/// Messages are lists of localized user messages
/// 
/// #### Defining a message list
/// 
/// A message list is defined with the `x3js.messages(...)` function:
/// 
/// ``` javascript
/// import * as x3js from 'x3js';
/// 
/// export default x3js.messages({
/// 	dictCode: 148,
/// 	name: 'BusinessIntelligence',
/// 	messages: {
/// 		factTable: 63,
/// 		dimensionUsedByHierarchy: 69,
/// 	}
/// });
/// ```
/// 
/// #### Using a message list
/// 
/// ``` javascript
/// import BusinessIntelligence from '../../system/messages/business-intelligence';
/// 
/// // retrieving a simple message
/// const msg1 = BusinessIntelligence.factTable(_);
/// 
/// // formatting a message with parameters (`$1$`, `$2$` placeholders in the text)
/// const msg2 = BusinessIntelligence.dimensionsUsedByHierarchy(_, 'dimX', 'hierY');
/// ```
/// 
/// Note; an exception will be thrown if you mistype the message code (`BusinessIntelligence.factTabllle` for example).

require('harmony-reflect'); // to get ES6 Proxy API
const runtime = require('etna/lib/engine/runtime/runtime');

class MessageHandler{
	constructor(def) {
		this.def = def;
	}
	/// 
	/// #### Retrieving message names
	/// 
	/// * `MyMessages.$names()`: returns the list of message names, as an array.
	$names() {
		return Object.keys(this.def.messages);
	}
	// note: message ids are not exposed!
}


exports.create = def => {
	if (!def.name) throw new Error(`messages name missing`);
	if (!def.dictCode) throw new Error(`${def.name}: dict code missing`);
	if (!def.messages) throw new Error(`${def.name}: messages missing`);
	return new Proxy(def, {
		get(def, name) {
			if (name[0] === '$') {
				const handler = new MessageHandler(def);
				const member = handler[name];
				if (!member) throw new Error(`${def.name}: invalid member: ${name}`);
				return typeof member === 'function' ? member.bind(handler) : member;
			}
			const id = def.messages[name];
			if (id == null) throw new Error(`${def.name}: invalid message name: ${name}`);
			return (_, ...args) => {
				const fmt = runtime.functions.MESS.fn(_, id, def.dictCode, 1);
				if (fmt == null) throw new Error(`${def.name}.${name}: null message`);
				if (args.length === 0) return fmt;
				return fmt.replace(/\$(\d+)\$/g, (all, i) => {
					if (i > args.length) throw new Error(`${def.name}.${name}: too many parameters: ${args.length}`);
					return args[parseInt(i) - 1];
				});
			};
		},
		ownKeys(def) {
			return Object.keys(def.messages);
		},
	});
}
