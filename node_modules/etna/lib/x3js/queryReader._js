"use strict";
const ez = require('ez-streams');
const Cache = require("etna/lib/supervisor/cache").Cache;
const instanceProxy = require('./instanceProxy');

// temp hack: move this to ez-streams
class BaseReader {};
ez.reader.decorate(BaseReader.prototype);

function combineFilters(f1, f2) {
	return Object.keys(f2).reduce((r, k) => {
		if (r[k]) {

		}
	}, Object.assign({}, f1));
}

class QueryReader extends BaseReader {
	constructor(clas, options) {
		super();
		this.class = clas;
		this.options = options || {};
		this.reader = null;
		this.stopped = false;
	}
	read(_) {
		if (this.stopped) return undefined;
		if (!this.reader) this.reader = this._execute(_);
		return this.reader.read(_);		
	}
	stop(_, arg) {
		if (this.reader) this.reader.stop(_, arg);
		this.reader = null;
		this.stopped = true;
	}
	sort(order) {
		if (order == null) return this;
		return new QueryReader(this.class, Object.assign({}, this.options, {
			sort: order,
		}));
	}
	filter(criteria) {
		if (criteria == null) return this;
		if (typeof criteria == 'function') 
			return ez.devices.generic.reader(this.read.bind(this), this.stop.bind(this)).filter(criteria);
		else
			return new QueryReader(this.class, Object.assign({}, this.options, {
				filters: (this.options.filters || []).concat(criteria),
			}));
	}
	_execute(_) {
		const clas = this.class;
		const recordMapper = (_, record) => {
			return instanceProxy.create(clas.supervisor.new(_, 'Instance', clas).afterCreate(_, record));
		};

		const properties = clas.properties;
		const param = clas.supervisor.sqlDriver.param;
		const tableNames = [clas.table.name + ' T'];
		const columnNames = [];
		const wheres = [];
		var orderBy;
		const descs = [];
		const params = [];
		const sqlOpts = {};
		const cache = new Cache();

		// add link with ACCES if ACCSTR is filled.
		if (clas.data.ACCSTR) {
			tableNames.push("ACCES ACC");
			params.push(glob.context.x3session.actx.$USER(_));
			wheres.push("ACC.USR_0 = " + param(params.length - 1));
			wheres.push("ACC.CODACC_0 = T." + clas.data.ACCSTR + "_0");
			wheres.push("ACC.CONSUL_0 = 2");
		}

		Object.keys(properties).forEach_(_, function(_, name) {
			if (properties[name].getSql) properties[name].getSql(_, columnNames, tableNames, wheres, params, descs, cache, false, sqlOpts);
		});

		if (this.options.sort) {
			orderBy = Object.keys(this.options.sort).map(k => {
				const prop = clas.membersByJsName[k];
				if (!prop) throw new Error("sort property not found: " + clas.jsName + '.' + k);
				return prop.column.sqlName() + (this.options.sort[k] < 0 ? ' desc' : ' asc');
			});
		} else {
			// sort by primary key
			orderBy = clas.tableIndex && clas.tableIndex.sqlNames().map(name => name + ' asc');
		}
		if (this.options.filters) {
			const filters = this.options.filters.length === 1 ? this.options.filters[0] : {
				$and: this.options.filters,
			};
			var qsel = clas.queryToSelect(_, filters, params);
			if (qsel !== "") wheres.push(qsel);
		}
		var sql = "select T.UPDTICK_0, " + columnNames.join(',') + " from " + tableNames.join(',');
		if (wheres.length) sql += " where (" + wheres.join(') and (') + ')';
		if (orderBy.length) sql += " order by " + orderBy.join(',');
		var reader = self.supervisor.sqlReader(_, sql, params, sqlOpts).map(recordMapper);
		// investigate cache later
		// if (cache.isActivated) reader = reader.transform(cache.transform());
		return reader;
	}
}

exports.QueryReader = QueryReader;
