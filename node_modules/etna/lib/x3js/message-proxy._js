"use strict";
/// !doc
/// [x3js dev guide](x3js-development-guide) > [x3js APIs](x3js-apis) > x3js user messages
///
/// # x3js user messages
///
/// Messages are lists of localized user messages
///
/// #### Defining a message list
///
/// A message list is defined with the `x3js.defineMessages(...)` function:
///
/// ``` javascript
/// import * as x3js from 'x3js';
///
/// export default x3js.defineMessages({
/// 	dictId: 148,
/// 	name: 'BusinessIntelligence',
/// 	entries: {
/// 		factTable: 63,
/// 		dimensionUsedByHierarchy: 69,
/// 	}
/// });
/// ```
///
/// #### Using a message list
///
/// ``` javascript
/// const BusinessIntelligence = x3js.messages('system.BusinessIntelligence');
///
/// // retrieving a simple message
/// const msg1 = BusinessIntelligence.factTable(_);
///
/// // formatting a message with parameters (`$1$`, `$2$` placeholders in the text)
/// const msg2 = BusinessIntelligence.dimensionsUsedByHierarchy(_, 'dimX', 'hierY');
/// ```
///
/// Note; an exception will be thrown if you mistype the message code (`BusinessIntelligence.factTabllle` for example).

require('harmony-reflect'); // to get ES6 Proxy API
const runtime = require('etna/lib/engine/runtime/runtime');
const glob = require('streamline-runtime').globals;
const x3jsUtil = require('./util');

class MessageHandler {
	constructor(def) {
		this.def = def;
	}
	/*
	get def() {
		const supervisor = glob.context.x3session && glob.context.x3session.supervisor;
		if (!supervisor) throw new Error("cannot access message list: no supervisor in context");
		const path = this.path;
		const segs = path.split('.');
		if (segs.length !== 2) throw new Error(`invalid messsage list path syntax: ${ path }`);
		const script = supervisor.loadJsScriptSync('messages', segs.join('.'));

		if (!script) throw new Error(`message list script not found: ${ path }`);
		if (!script.default) throw new Error(`no default in message list script: ${ path }`);
		return this._def = script.default;
	}*/
	
	///
	/// #### Retrieving message names
	///
	/// * `MyMessages.$names()`: returns the list of message names, as an array.
	$names() {
		return Object.keys(this.def.entries);
	}
	// note: message ids are not exposed!
}

const proxies = {};

exports.define = def => {
	if (!def.module) throw new Error(`messages module missing`);
	if (!def.name) throw new Error(`messages name missing`);
	if (!def.dictId) throw new Error(`${ def.name }: dict code missing`);
	if (!def.entries) throw new Error(`${ def.name }: entries missing`);
	var key = def.module + '.' + def.name;
	return proxies[key] || (proxies[key] = new Proxy(new MessageHandler(def), {
		get(handler, name) {
			const def = handler.def;
			if (name[0] === '$') {
				const member = handler[name];
				if (!member) throw new Error(`${ def.name }: invalid member: ${ name }`);
				return typeof member === 'function' ? member.bind(handler) : member;
			}
			const id = def.entries[name];
			if (id == null) throw new Error(`${ def.name }: invalid message name: ${ name }`);
			return x3jsUtil.fiberize((_, ...args) => {
				const fmt = runtime.functions.MESS.fn(_, id, def.dictId, 1);
				if (fmt == null) throw new Error(`${ def.name }.${ name }: null message`);
				if (args.length === 0) return fmt;
				return fmt.replace(/\$(\d+)\$/g, (all, i) => {
					if (i > args.length) throw new Error(`${ def.name }.${ name }: too many parameters: ${ args.length }`);
					return args[parseInt(i) - 1];
				});
			});
		},
		ownKeys(handler) {
			const def = handler.def;
			return Object.keys(def.entries);
		}
	}));
};