"use strict";
/// !doc
/// [x3js dev guide](x3js-development-guide) > [x3js APIs](x3js-apis) > x3js user messages
///
/// # x3js user messages
///
/// Messages are lists of localized user messages
///
/// #### Defining a message list
///
/// A message list is defined with the `x3js.defineMessages(...)` function:
///
/// ``` javascript
/// import * as x3js from 'x3js';
///
/// export default x3js.defineMessages({
/// 	dictId: 148,
/// 	name: 'BusinessIntelligence',
/// 	messages: {
/// 		factTable: 63,
/// 		dimensionUsedByHierarchy: 69,
/// 	}
/// });
/// ```
///
/// #### Using a message list
///
/// ``` javascript
/// const BusinessIntelligence = x3js.messages('system.BusinessIntelligence');
///
/// // retrieving a simple message
/// const msg1 = BusinessIntelligence.factTable(_);
///
/// // formatting a message with parameters (`$1$`, `$2$` placeholders in the text)
/// const msg2 = BusinessIntelligence.dimensionsUsedByHierarchy(_, 'dimX', 'hierY');
/// ```
///
/// Note; an exception will be thrown if you mistype the message code (`BusinessIntelligence.factTabllle` for example).

require('harmony-reflect'); // to get ES6 Proxy API
const runtime = require('etna/lib/engine/runtime/runtime');
const glob = require('streamline-runtime').globals;

class MessageHandler {
	constructor(path) {
		this.path = path;
	}
	get def() {
		if (this._def) return this._def;
		const supervisor = glob.context.x3session && glob.context.x3session.supervisor;
		if (!supervisor) throw new Error("cannot access message list: no supervisor in context");
		const path = this.path;
		const segs = path.split('.');
		if (segs.length !== 2) throw new Error(`invalid messsage list path syntax: ${ path }`);
		const script = supervisor.loadJsScriptSync('messages', segs.join('.'));

		if (!script) throw new Error(`message list script not found: ${ path }`);
		if (!script.default) throw new Error(`no default in message list script: ${ path }`);
		return this._def = script.default;
	}
	///
	/// #### Retrieving message names
	///
	/// * `MyMessages.$names()`: returns the list of message names, as an array.
	$names() {
		return Object.keys(this.def.messages);
	}
	// note: message ids are not exposed!
}

const proxies = {};

exports.load = path => {
	if (!proxies[path]) {
		const handler = new MessageHandler(path);
		proxies[path] = new Proxy(handler, {
			get(handler, name) {
				const def = handler.def;
				if (name[0] === '$') {
					const member = handler[name];
					if (!member) throw new Error(`${ def.name }: invalid member: ${ name }`);
					return typeof member === 'function' ? member.bind(handler) : member;
				}
				const id = def.messages[name];
				if (id == null) throw new Error(`${ def.name }: invalid message name: ${ name }`);
				return (_, ...args) => {
					const fmt = runtime.functions.MESS.fn(_, id, def.dictId, 1);
					if (fmt == null) throw new Error(`${ def.name }.${ name }: null message`);
					if (args.length === 0) return fmt;
					return fmt.replace(/\$(\d+)\$/g, (all, i) => {
						if (i > args.length) throw new Error(`${ def.name }.${ name }: too many parameters: ${ args.length }`);
						return args[parseInt(i) - 1];
					});
				};
			},
			ownKeys(handler) {
				const def = handler.def;
				return Object.keys(def.messages);
			}
		});
	};
	return proxies[path];
};

exports.define = def => {
	if (!def.name) throw new Error(`messages name missing`);
	if (!def.dictId) throw new Error(`${ def.name }: dict code missing`);
	if (!def.messages) throw new Error(`${ def.name }: messages missing`);
	return def;
};