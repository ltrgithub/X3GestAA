/// !doc
/// [x3js dev guide](x3js-development-guide) > [x3js APIs](x3js-apis) > x3js table query
///
/// # x3js table query
///
/// _table query_ objects are returned by a `query` call on a table:
///
/// ```javascript
///  const MYTABLE = x3js.table('myModule.MYTABLE');
///  const query = MYTABLE.query(_); // query object
///  ```
///
/// Table query objects have an `execute(_)`  method which produces an `ez-streams`  _reader_ on which
/// you can chain methods to filter, transform, pipe, iterate, etc.
/// See [ez-streams documentation](https://github.com/Sage/ez-streams/blob/master/README.md) for details.
///
/// For example, you can read a table, transform the records (to rename the columns)
/// and write the result to a JSON file in a single statement:
///
/// ```javascript
/// MYTABLE.query(_)
/// .where({ CREUSR: 'ME' }) // select only my records
/// .orderBy({ CREDAT: +1 }) // order by ascending CREDAT
/// .execute(_) // execute the query to get an ez-streams reader
/// .map((_, rec) => ({ // column names -> property names
///   code: rec.CODE,
///   createdDate: rec.CREDAT,
/// }))
/// .transform(ez.transforms.json.formatter()) // convert records to JSON
/// .pipe(_, ez.devices.file.text.writer('myfile.json')); // pipe to the output file
/// ```

import { _ } from 'streamline-runtime';
import * as ez from 'ez-streams';
import { Record, SqlReaderOptions } from '../engine/drivers/types';
import * as types from '../engine/runtime/types';
import { WhereConverter } from './table-where';
import { Table } from '../supervisor/meta/table';
import { Supervisor } from '../supervisor/supervisor';

export interface TableDesc {
	name: string;
	alias: string;
	meta?: Table;
}

type Dict<T> = { [name: string]: T; };
const any = (x: any) => x;

type TableQueryOrder = Dict<number>;

export class TableQuery<T> {
	supervisor: Supervisor;
	table: Table;
	tables: TableDesc[];
	wheres: any[];
	order: TableQueryOrder;
	reader: ez.Reader<T>;

	constructor(table: Table, alias?: string) {
		this.supervisor = table.supervisor;
		this.tables = [{
			name: table.name,
			alias: alias || '',
			meta: table
		}];
		this.wheres = [];
		this.order = null;
		this.reader = null;
	}
	///
	/// #### Building a query
	///
	/// * `query.join(tablePath, alias, condition)`: adds a join to another table. 
	///    The `condition` parameter is described in [SQL filters](x3js-sql-filters). 
	///    Returns `this` for chaining.
	join(tablePath: string, alias: string, condition: any) {
		const segs = tablePath.split('.');
		if (segs.length !== 2) throw new Error(`invalid table path: ${ tablePath }`);
		const tableName = segs[1];
		// TODO: check module.
		this.tables.push({
			name: tableName,
			alias: alias
		});
		this.wheres.push(condition);
		return this;
	}
	/// * `query.where(condition)`: adds a _where_ clause to the query. 
	///    `condition` is described in [SQL filters](x3js-sql-filters). 
	///    Returns `this` for chaining.
	where(condition: any) {
		this.wheres.push(condition);
		return this;
	}
	/// * `query.orderBy(order)`: specifies the _order by_ clause of the query. 
	///   `order`  is an object with column names as keys and +1 / -1 values (asc / desc respectively). 
	///    Returns `this` for chaining.
	orderBy(order: TableQueryOrder) {
		if (this.order) throw new Error("query already has an order by clause");
		this.order = order;
		return this;
	}

	///
	/// #### Executing a query
	///
	/// * `query.execute(_)`:  executes the query and returns an ez-streams reader on
	///   which other methods can be chained.
	execute(_: _) {
		const tables = this.tables.map_(_, (_, t) => {
			return {
				name: t.name,
				alias: t.alias || t.name,
				meta: t.meta || this.supervisor.load(_, 'Table', t.name)
			};
		});
		const sqlOpts: SqlReaderOptions = {
			typesmap: []
		};
		const args: any[] = [];
		const colNames: string[] = [];
		const tableDecls: string[] = [];
		const wheres: string[] = [];
		const orderBys: string[] = [];
		tables.forEach_(_, (_, t) => {
			tableDecls.push(t.name + (t.alias ? ' ' + t.alias : ''));
			const prefix = t.alias ? t.alias + '.' : '';
			Object.keys(t.meta.columns).forEach_(_, (_, name) => {
				const col = t.meta.columns[name];
				colNames.push(col.sqlNames(prefix, t.alias, sqlOpts));
				col.sqlTypesMap(sqlOpts.typesmap);
			});
		});
		if (this.order) Object.keys(this.order).forEach_(_, (_, o) => {
			const dir = this.order[o];

			if (dir === 0) return;
			orderBys.push(o + '_0 ' + (dir > 0 ? 'asc' : 'desc'));
		});
		var sql = 'select ' + colNames.join(',') + ' from ' + tableDecls.join(', ');
		if (this.wheres.length) sql += ' where ' + new WhereConverter(tables, args).toSql(_, this.wheres);
		if (orderBys.length > 0) sql += ' order by ' + orderBys.join(', ');
		return this.supervisor.sqlReader(_, sql, args, sqlOpts).map((_, rec) => mapRecord(_, rec));
	}
}

function mapRecord(_: _,  rec: Record) {
	return Object.keys(rec).reduce((r, k) => {
		const pair = k.split('$');
		if (pair.length > 1) {
			(r[pair[0]] = r[pair[0]] || {})[pair[1]] = rec[k];
		} else {
			r[k] = rec[k];
		}
		return r;
	}, any({}));
}