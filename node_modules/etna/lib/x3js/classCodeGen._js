"use strict";

const babylon = require('babylon');
const generate = require('babel-generator').default;
const traverse = require('babel-traverse').default;
const types = require('babel-types');
const fs = require('fs');
const fsp = require('path');
const util = require('etna/lib/supervisor/util');
const x3jsUtil = require('./util');
const jsEscape = x3jsUtil.jsEscape;
const classDescriptor = require('etna/lib/x3js/classDescriptor');


exports.classTemplate = function(_, inst) {
	return `import * as x3js from 'x3js';

	export default x3js.defineClass({
  		module: '${inst.module(_)}',
  		name: '${inst.name(_)}',
  		title: '${jsEscape(inst.title(_))}',
  		dictCode: '${inst.dictCode(_)}',
  		properties: {},
  		events: {},
	});`;
}

function genProp(dest, name) {
	var prop = dest.filter(n => n.key.name === name)[0];
	if (!prop) {
		prop = types.objectProperty(types.identifier(name), types.identifier('undefined'));
		dest.push(prop);
	}
	return prop;
}

function genAst(desc, dest, name, data) {
	//console.error("GENAST", name, data[name]);
	switch (desc.type) {
		case 'string':
			if (!data[name]) return;
			genProp(dest, name).value = types.stringLiteral(data[name]);
			break;
		case 'boolean':
		case 'addressOrValue':
			if (!data[name]) return;
			genProp(dest, name).value = types.booleanLiteral(data[name]);
			break;
		case 'enum':
			if (!data[name]) return;
			genProp(dest, name).value = types.stringLiteral(data[name]);
			// todo; check validity
			break;
		case 'object':
			const obj = data[name];
			if (!obj || Object.keys(obj).length === 0) return;
			const objExp = types.objectExpression([]);
			Object.keys(desc.properties).forEach(k => {
				const prop = desc.properties[k];
				if (obj[k] != null) {
					genAst(prop, objExp.properties, k, obj);
				}
			});
			Object.keys(desc.collections || {}).forEach(k => {
				const coln = desc.collections[k];
				if (!coln.key) return console.error("GENAST NIY", k);
				if (obj[k] != null) {
					const colnExp = types.objectExpression([]);
					genProp(objExp.properties, k).value = colnExp;
					Object.keys(obj[k]).forEach(key => {
						genAst(coln, colnExp.properties, key, obj[k]);
					});
				}
			});
			genProp(dest, name).value = objExp;
			break;
		case 'type':
			if (!data[name]) return;
			genProp(dest, name).value = types.stringLiteral(data[name]);
			// todo; check validity
			// TODO: get other elements
			break;
		case 'flags':
			const str = Object.keys(desc.dictCodes).filter(k => data[name + util.pascalize(k)]).join(',');
			if (str) genProp(dest, name).value = types.stringLiteral(str);
			break;
		default:
			throw new Error(`${name}: unhandled type ${desc.type}`);
	}
}

function propertyTemplate(_, prop) {
	return `${prop.jsName}: {
		dictCode: '${prop.name}',
		title: '${jsEscape(prop.title(_, 'ENG'))}',
	}`;
}

function propertyFilter(prop) {
	return !x3jsUtil.isSysProperty(prop.name);
}

function template(_, clas) {
	return `import * as x3js from 'x3js';

	export default x3js.defineClass({
  		module: '${clas.moduleName}',
  		name: '${clas.jsName}',
  		title: '${jsEscape(clas.title(_, 'ENG'))}',
  		dictCode: '${clas.data.CODCLA}',
  		properties: {${Object.keys(clas.properties)
  			.filter(k => propertyFilter(clas.properties[k]))
  			.map_(_, (_, k) => propertyTemplate(_, clas.properties[k])).join(',')}},
	});`;
}

function mkdirp(_, path) {
	if (fs.exists(path, _, _)) return;
	mkdirp(_, fsp.join(path, '..'));
	console.error(`creating directory ${path}`);
	fs.mkdir(path, _);
}

function removeSourceInfo(ast) {
	traverse(ast, {
  		enter(path) {
  			delete path.node.loc;
  		}
	});
	delete ast.loc;
	ast.tokens = [];
}

exports.generateSourceFile = function(_, parsed) {
	//console.error("GENERATE", parsed.root);
	const properties = [];
	genAst(classDescriptor, properties, 'data', parsed);
	parsed.root.properties = properties[0].value.properties;
	removeSourceInfo(parsed.ast);
	const output = generate(parsed.ast, {}, '');
	mkdirp(_, fsp.dirname(parsed.file));
	fs.writeFile(parsed.file, output.code, 'utf8', _);
	return output;
}

