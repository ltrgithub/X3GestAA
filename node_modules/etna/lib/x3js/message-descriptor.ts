import { _ } from 'streamline-runtime';
import * as ez from 'ez-streams';
import * as util from '../supervisor/util';
import * as x3jsUtil from './util';

import { EnumData } from '../supervisor/supervisor';
import { OrmInstance } from './orm';
import { FullDescriptor } from './descriptor';

function isReadOnly(_: _,  instance: OrmInstance): boolean {
	if (instance._parent) return isReadOnly(_, instance._parent);
	return (/^(4gl|incomplete)$/.test(instance['status'](_)));
}

export interface ExtendedEnumData extends EnumData {
	ENTRIES: EnumData[];
}

export const descriptor: FullDescriptor<ExtendedEnumData> = {
	type: 'object',
	defineMethod: 'defineMessages',
	hasSourceFile: true,
	subdir: 'messages',
	singular: 'message',
	plural: 'messages',
	dictKey: 'LANCHP',
	entityName: 'x3jsMessage',
	metaName: 'APLSTD',
	metaFilter: {
		LAN: 'ENG'
	},
	metaSort: {
		LANCHP: 1,
		LANNUM: 1
	},
	metaTransform(_,  reader, writer) {
		var result: ExtendedEnumData,
		    LANCHP = -Infinity;
		const flush = (_: _) => {
			if (result && result.ENTRIES.length > 0 && !x3jsUtil.isEnum(result)) writer.write(_, result);
			result = null;
		};
		reader.forEach(_, (_, metaData) => {
			if (!metaData.LANCHP) return;
			//console.error(metaData);
			if (LANCHP !== metaData.LANCHP) {
				flush(_);
				LANCHP = metaData.LANCHP;
				result = Object.assign({}, metaData);
				result.ENTRIES = [];
			}
			if (metaData.LANNUM != null) {
				result.ENTRIES.push(metaData);
			}
		});
		flush(_);
	},
	properties: {
		module: {
			type: 'string'
		},
		name: {
			type: 'string'
		},
		dictId: {
			type: 'integer',
			dictCode: 'LANCHP'
		},
		title: {
			type: 'string',
			dictCode: 'LANMES'
		}
	},
	collections: {
		entries: {
			type: 'object',
			key: 'name',
			metaCode: 'ENTRIES',
			codeGen: 'message',
			orderCode: 'LANNUM',
			localizedKey: 'title',
			genName(meta: EnumData) {
				return x3jsUtil.truncCamelize(meta.LANMES || '', 30);
			},
			properties: {
				dictId: {
					type: 'integer',
					dictCode: 'LANNUM'
				},
				title: {
					type: 'string',
					dictCode: 'LANMES'
				}
			},
			rules: {
				readOnlyProperty: isReadOnly
			}
		}
	},
	rules: {
		readOnlyProperty: isReadOnly
	}
};