"use strict";
const util = require('etna/lib/supervisor/util');
const instanceProxy = require('./instance-proxy');
const collectionProxy = require('./collection-proxy');
const Double = require('etna/lib/engine/runtime/tdouble').Double;
const tbcd = require('etna/lib/engine/runtime/tbcd');
const tdate = require('etna/lib/engine/runtime/tdate');
const tdatetime = require('etna/lib/engine/runtime/tdatetime');
const tblbfile = require('etna/lib/engine/runtime/tblbfile');
const tclbfile = require('etna/lib/engine/runtime/tclbfile');
const tuuid = require('etna/lib/engine/runtime/tuuid');

exports.jsEscape = function(str) {
	return str.replace(/[\\\n\r\t"']/g, ch => '\\' + ({
			'\n': 'n',
			'\r': 'r',
			'\t': 't',
		}[ch] || ch));
};

exports.isSysProperty = function(code) {
	return /^(CREUSR|CREDATTIM|UPDTICK|UPDUSR|UPDDATTIM|AUUID|ASTALIN|AORDER|_AFCRIGHT)$/.test(code);
}

exports.boolOut = function(val, def) {
	if (def !== undefined && val === 0) return def;
	if (val !== 2 && val !== 1) throw new Error("invalid boolean: " + val);
	return val === 2;
};

exports.boolIn = function(val) {
	return val == null ? 0 : val ? 2 : 1;
};

const NFT = [null, false, true];

exports.toJs = function(val, t) {
	if (val == null) return val;
	switch (t.type.data.TYPTYP) {
		case 1: // menu
			if (t.data.NOLIB === 1) return NFT[val];
			else {
				if (val !== (val & 0xff)) throw convertError('tiny int', val);
				return val;
			}
		case 2:
		case 3: // integers
			return val;
		case 4: // decimal
			return val;
		case 5: // float (unused)
		case 6: // double
			if (typeof val.value !== 'number') throw new Error("bad double: " + val);
			return val.value;
		case 7: // string
			return val;
		case 8: // date
			return val.x3IsZero() ? null : val;
		case 9: // blob
		case 10: // clob
			return val.value;
		case 11: // uuid
			return val.x3IsZero() ? null : val.x3ToString();
		case 12: // datetime
			return val.x3IsZero() ? null : val;
		case 13: // instance
			return instanceProxy.create(val);
		default:
			throw new Error("invalid type code: " + t.type.data.TYPTYP);
	}
};

function convertError(target, val) {
	return new Error("cannot convert to " + target + ": " + val + " (type " + typeof val + ')');
}

exports.fromJs = function(val, t) {
	switch (t.type.data.TYPTYP) {
		case 1: // menu
			if (t.data.NOLIB === 1) {
				// don't test type, just truthiness
				return val == null ? 0 : val ? 2 : 1;
			} else {
				if (val !== (val & 0xff)) throw convertError('tiny int', val);
				return val;
			}
		case 2:
		case 3: // integers
			if (val | 0 === val) return val; 
			throw convertError('integer', val);
		case 4: // decimal
			if (typeof val === 'number') return tbcd.fromDouble(val);
			else if (val instanceof tbcd.BCD) return val;
			throw convertError('decimal', val);
		case 5: // float (unused)
		case 6: // double
			if (typeof val === 'number') return val;
			else if (val instanceof tbcd.BCD) return val.x3ToDouble();
			throw convertError('double', val);
		case 7: // string
			if (typeof val === 'string') return val;
			throw convertError('string', val);
		case 8: // date
			if (val == null) return tdate.NULL;
			else if (tdate.isDate(val)) return val;
			throw convertError('date', val);
		case 9: // blob
			if (Buffer.isBuffer(val)) return new tblbfile.Blbfile(val);
			throw convertError('blob', val);
		case 10: // clob
			if (typeof val === 'string') return new cblbfile.Clbfile(val);
			throw convertError('clob', val);
		case 11: // uuid
			if (val == null) return tuuid.NULL;
			else if (typeof val === 'string') return new Buffer(val.replace(/-/g, ''), 'hex');
			throw convertError('uuid', val);
		case 12: // datetime
			if (val == null) return tdatetime.NULL;
			else if (tdatetime.isDatetime(val)) return val;
			throw convertError('datetime', val);
		case 13: // instance
			if (val == null) return null;
			const instance = val.$instance;
			if (instance) return instance;
			throw convertError('instance', val);
		default:
			throw new Error("invalid type code: " + t.type.data.TYPTYP);
	}
};

const JsSeverities = {
	0: "success",
	1: "success",
	2: 'info',
	3: 'warning',
	4: 'error',
}

function toJsSeverity(severity) {
	const jsSeverity = JsSeverities[severity];
	if (!jsSeverity) throw new Error(`invalid severity code: ${diag.severity}`);
	return jsSeverity;
}

exports.toJsDiagnose = function(diag) {
	return {
		severity: toJsSeverity(diag.severity),
		message: diag.message,
		stack: diag.stackTrace,
	};
};

const TypeNames = {
	1: 'enum',
	2: 'integer',
	3: 'integer',
	4: 'decimal',
	5: 'double',
	6: 'double',
	7: 'string',
	8: 'date',
	9: 'blob',
	10: 'clob',
	11: 'uuid',
	12: 'datetime',
	13: 'instance',
};

exports.x3jsTypeNames = TypeNames;
exports.x3jsTypeIds = Object.keys(TypeNames).reduce((r, id) => (r[TypeNames[id]] = id, r), {});

exports.x3jsType = function(type, nolib, long) {
	const result = {
		name: TypeNames[type.data.TYPTYP],
		typeCode: type.data.CODTYP,
		maxLength: 0,
	};
	if (!result.name) throw new Error(`${type.data.CODTYP}: bad TYPTYP: ${type.data.TYPTYP}`);
	switch (type.data.TYPTYP) {
		case 1:
			if (nolib === 1) result.name = 'boolean';
			else result.enum = '' + nolib; // see later
			break;
		case 4:
			Object.assign(result, type.precisionAndScale(long));
			break;
		case 7:
			result.maxLength = type.data.LNGTYP || 0;
			break;
	}
	return result;
}

exports.controlCamelCase = function(propName) {
	return function(_, instance, value) {
		if (value && !/^[a-z_]\w*$/.test(value)) {
			instance.$addError(`invalid name: camelCase expected`, propName);
		}
	};
};

exports.controlPascalCase = function(propName) {
	return function(_, instance, value) {
		if (value && (!/^[A-Z]\w+$/.test(value) || value === value.toUpperCase())) {
			instance.$addError(`invalid name: PascalCase expected`, propName);
		}
	};
};

exports.controlUpperCase = function(propName) {
	return function(_, instance, value) {
		if (value !== value.toUpperCase()) {
			instance.$addError(`invalid name name: UPPER_CASE expected`, propName);
		}
	};
};


