"use strict";
const fsp = require('path');
const fs = require('fs');
const util = require('etna/lib/supervisor/util');
let instanceProxy;
const Double = require('etna/lib/engine/runtime/tdouble').Double;
const tbcd = require('etna/lib/engine/runtime/tbcd');
const tdate = require('etna/lib/engine/runtime/tdate');
const tdatetime = require('etna/lib/engine/runtime/tdatetime');
const tblbfile = require('etna/lib/engine/runtime/tblbfile');
const tclbfile = require('etna/lib/engine/runtime/tclbfile');
const tuuid = require('etna/lib/engine/runtime/tuuid');
const ACTX = require("etna/lib/supervisor/builtins/ACTX");
const globals = require('streamline-runtime').globals;
const supervisor = require("etna/lib/supervisor/supervisor");

exports.jsEscape = function (str) {
	return str.replace(/[\\\n\r\t"']/g, ch => '\\' + ({
		'\n': 'n',
		'\r': 'r',
		'\t': 't'
	}[ch] || ch));
};

exports.isSysProperty = function (code) {
	return (/^(CREUSR|CREDATTIM|UPDTICK|UPDUSR|UPDDATTIM|AUUID|ASTALIN|AORDER|_AFCRIGHT)$/.test(code));
};

exports.boolOut = function (val, def) {
	if (def !== undefined && val === 0) return def;
	if (val !== 2 && val !== 1) throw new Error("invalid boolean: " + val);
	return val === 2;
};

exports.boolIn = function (val) {
	return val == null ? 0 : val ? 2 : 1;
};

const NFT = [null, false, true];

exports.toJs = function (val, t) {
	if (val == null) return val;
	switch (t.type.data.TYPTYP) {
		case 1:
			// menu
			if (t.data.NOLIB === 1) return NFT[val];
			else {
				if (val !== (val & 0xff)) throw convertError('tiny int', val);
				return val;
			}
		case 2:
		case 3:
			// integers
			return val;
		case 4:
			// decimal
			return val;
		case 5: // float (unused)
		case 6:
			// double
			if (typeof val.value !== 'number') throw new Error("bad double: " + val);
			return val.value;
		case 7:
			// string
			return val;
		case 8:
			// date
			return val.x3IsZero() ? null : val;
		case 9: // blob
		case 10:
			// clob
			return val.value;
		case 11:
			// uuid
			return val.x3IsZero() ? null : val.x3ToString();
		case 12:
			// datetime
			return val.x3IsZero() ? null : val;
		case 13:
			// instance
			 instanceProxy = instanceProxy || require('./instance-proxy'); // circular-dependency
			return instanceProxy.create(val);
		default:
			throw new Error("invalid type code: " + t.type.data.TYPTYP);
	}
};

function convertError(target, val) {
	return new Error("cannot convert to " + target + ": " + val + " (type " + typeof val + ')');
}

exports.fromJs = function (val, t) {
	switch (t.type.data.TYPTYP) {
		case 1:
			// menu
			if (t.data.NOLIB === 1) {
				// don't test type, just truthiness
				return val == null ? 0 : val ? 2 : 1;
			} else {
				if (val !== (val & 0xff)) throw convertError('tiny int', val);
				return val;
			}
		case 2:
		case 3:
			// integers
			if (val | 0 === val) return val;
			throw convertError('integer', val);
		case 4:
			// decimal
			if (typeof val === 'number') return tbcd.fromDouble(val);
			else if (val instanceof tbcd.BCD) return val;
			throw convertError('decimal', val);
		case 5: // float (unused)
		case 6:
			// double
			if (typeof val === 'number') return val;
			else if (val instanceof tbcd.BCD) return val.x3ToDouble();
			throw convertError('double', val);
		case 7:
			// string
			if (typeof val === 'string') return val;
			throw convertError('string', val);
		case 8:
			// date
			if (val == null) return tdate.NULL;
			else if (tdate.isDate(val)) return val;
			throw convertError('date', val);
		case 9:
			// blob
			if (Buffer.isBuffer(val)) return new tblbfile.Blbfile(val);
			throw convertError('blob', val);
		case 10:
			// clob
			if (typeof val === 'string') return new tclbfile.Clbfile(val);
			throw convertError('clob', val);
		case 11:
			// uuid
			if (val == null) return tuuid.NULL;
			else if (typeof val === 'string') return new Buffer(val.replace(/-/g, ''), 'hex');
			throw convertError('uuid', val);
		case 12:
			// datetime
			if (val == null) return tdatetime.NULL;
			else if (tdatetime.isDatetime(val)) return val;
			throw convertError('datetime', val);
		case 13:
			// instance
			if (val == null) return null;
			const instance = val.$instance;
			if (instance) return instance;
			throw convertError('instance', val);
		default:
			throw new Error("invalid type code: " + t.type.data.TYPTYP);
	}
};

const JsSeverities = {
	0: "success",
	1: "success",
	2: 'info',
	3: 'warning',
	4: 'error'
};

function toJsSeverity(severity) {
	const jsSeverity = JsSeverities[severity];
	if (!jsSeverity) throw new Error(`invalid severity code: ${ diag.severity }`);
	return jsSeverity;
}

exports.toJsDiagnose = function (diag) {
	return {
		severity: toJsSeverity(diag.severity),
		message: diag.message,
		stack: diag.stackTrace
	};
};

const TypeNames = {
	1: 'enum',
	2: 'integer',
	3: 'integer',
	4: 'decimal',
	5: 'double',
	6: 'double',
	7: 'string',
	8: 'date',
	9: 'blob',
	10: 'clob',
	11: 'uuid',
	12: 'datetime',
	13: 'instance'
};

exports.x3jsTypeNames = TypeNames;
exports.x3jsTypeIds = Object.keys(TypeNames).reduce((r, id) => (r[TypeNames[id]] = id, r), {});

exports.x3jsType = function (type, nolib, long) {
	const result = {
		name: TypeNames[type.data.TYPTYP],
		typeCode: type.data.CODTYP,
		maxLength: 0
	};
	if (!result.name) throw new Error(`${ type.data.CODTYP }: bad TYPTYP: ${ type.data.TYPTYP }`);
	switch (type.data.TYPTYP) {
		case 1:
			if (nolib === 1) result.name = 'boolean';
			else result.enum = '' + nolib; // see later
			break;
		case 4:
			Object.assign(result, type.precisionAndScale(long));
			break;
		case 7:
			result.maxLength = type.data.LNGTYP || 0;
			break;
	}
	return result;
};

exports.controlCamelCase = function (propName) {
	return function (_, instance, value) {
		if (value && !/^[a-z_]\w*$/.test(value)) {
			instance.$addError(`invalid name: camelCase expected`, propName);
		}
	};
};

exports.controlPascalCase = function (propName) {
	return function (_, instance, value) {
		if (value && (!/^[A-Z]\w+$/.test(value) || value === value.toUpperCase())) {
			instance.$addError(`invalid name: PascalCase expected`, propName);
		}
	};
};

exports.controlKebabCase = function (propName) {
	return function (_, instance, value) {
		if (value && !/^[a-z][a-z0-9\-]*[a-z0-9]$/.test(value)) {
			instance.$addError(`invalid name: kebab-case expected`, propName);
		}
	};
};

exports.controlUpperCase = function (propName) {
	return function (_, instance, value) {
		if (value !== value.toUpperCase()) {
			instance.$addError(`invalid name name: UPPER_CASE expected`, propName);
		}
	};
};

exports.truncUpcase = function (str, maxlen) {
	const all = util.upcase(str || '').split('_');
	var len = -1;
	return all.filter((s, i) => (len += 1 + s.length) <= maxlen || i === 0) //
	.join('_').substring(0, maxlen);
}

exports.truncCamelize = function (str, maxlen) {
	const all = util.upcase(str || '').split('_');
	var len = -1;
	return all.filter((s, i) => (len += 1 + s.length) <= maxlen || i === 0) //
	.map((s, i) => i == 0 ? s.toLowerCase() : s.substring(0, 1).toUpperCase() + s.substring(1).toLowerCase()) //
	.join('').substring(0, maxlen);
}

const enumRanges = [
[0, 99],
[175, 175],
[201, 4999],
[5200, 5999],
[6200, 6999],
[7600, 7600],
[7800, 7899],
[7910, 7999],
[8000, 8799],
[9001, 9002],
[9025, 9199],
[9966, 10030],
[11200, 29999]];

const enumExceptions = [75, 7837, 7980, 7981, 7982, 7999, 9097, 9119, 9119, 9120, 9126, 9129, 9130, 9137, 9138, 9139];

exports.isEnum = function(data) {
	const id = data.LANCHP;
	var ok = enumRanges.some(r => r[0] <= id && id <= r[1]);
	ok = ok && enumExceptions.indexOf(id) < 0;
	const likelyMessage = data.ENTRIES.some(e => e.LANMES && e.LANMES.split(' ').length > 5);
	if (ok && data.ENTRIES.length > 5 && likelyMessage) console.error(id + ': LIKELY MESSAGE');
	if (!ok && data.ENTRIES.length > 0 && !likelyMessage) console.error(id + ': LIKELY ENUM');
	return ok;
}

exports.mkdirp = function(_, path) {
	if (fs.exists(path, _, _)) return;
	exports.mkdirp(_, fsp.join(path, '..'));
	console.error(`creating directory ${ path }`);
	fs.mkdir(path, _);
}

exports.fiberize = function(api) {
	// ES2015 methods are not enumerable. Use Object.getOwnPropertyNames rather than Objectkeys
	Object.getOwnPropertyNames(api).forEach(k => {
		// get descriptor to avoid evaluation of property members
		const desc = Object.getOwnPropertyDescriptor(api, k);
		//console.error(typeof desc.value, desc);
		if (typeof desc.value === 'function') {
			const fn = api[k];
			const fiberized = fn['fiberized-0'];
			if (fiberized) api[k] = function(...args) {
				return fiberized.apply(this, [true].concat(args));
			}
		}
	});
}

exports.currentSupervisor = function(_) {
	const session = globals.context.session;
	if (!session) throw new Error("invalid context: no session");
	//console.error("SESSION", session);
	const endpoint = session.getUserProfile(_).selectedEndpoint(_);
	if (!endpoint.useEtna(_)) throw new Error("operation not available on current endpoint");
	//console.error("ENDPOINT", endpoint);
	const conf = endpoint.getEtnaConfig(_, session);
	//console.error("SUPERVISOR CONF", conf);
	const superv = supervisor.create(_, conf);
	ACTX.init(_, conf.session, superv);
	return superv;
};
