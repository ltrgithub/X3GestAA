"use strict";

const babylon = require('babylon');
const generate = require('babel-generator').default;
const traverse = require('babel-traverse').default;
const types = require('babel-types');
const fs = require('fs');
const fsp = require('path');
const util = require('etna/lib/supervisor/util');
const x3jsUtil = require('./util');

function error(filePath, node, message) {
	return new Error(`${filePath}:${node && node.loc && node.loc.start.line}: ${message}`);
}

function propNode(node, key) {
	return node.properties.filter(p => p.key.name === key)[0]
}

class Parser {
	constructor(filePath) {
		this.filePath = filePath;
	}
	parse(desc, dest, parent, name, node) {
		switch (desc.type) {
			case 'string':
			case 'flags':
				if (!types.isStringLiteral(node)) throw error(this.filePath, node, `${name} value is not a string literal`);
				dest[name] = node.value;
				break;
			case 'boolean':
				if (!types.isBooleanLiteral(node)) throw error(this.filePath, node, `${name} value is not a boolean literal`);
				dest[name] = node.value;
				break;
			case 'enum':
				if (!types.isStringLiteral(node)) throw error(this.filePath, node, `${name} value is not a string literal`);
				// todo; check validity
				dest[name] = node.value;
				break;
			case 'integer':
				if (!types.isNumericLiteral(node)) throw error(this.filePath, node, `${name} value is not a numeric literal`);
				// todo; check validity
				dest[name] = node.value;
				break;
			case 'event':
				if (!types.isStringLiteral(node)) throw error(this.filePath, node, `${name} value is not a string literal`);
				// todo; check validity
				dest[name] = node.value;
				break;
			case 'object':
				if (desc.codeGen === 'dictIdOnly') {
					if (!types.isNumericLiteral(node)) throw error(this.filePath, node, `${name} value is not a numeric literal`);
					dest[name] = {
						dictId: node.value
					};
					break;
				}
				if (!types.isObjectExpression(node)) throw error(this.filePath, node, `${name} is not an object literal`);
				dest[name] = Object.keys(desc.properties).reduce((obj, key) => {
					const n = propNode(node, key);
					if (!n) {
						if (desc.isMandatory) throw error(this.filePath, node, `${name}: mandatory attribute missing`);
					} else {
						this.parse(desc.properties[key], obj, node, n.key.name, n.value);
					}
					return obj;
				}, {});
				Object.keys(desc.collections || {}).forEach(key => {
					const n = propNode(node, key);
					const colDesc = desc.collections[key];
					if (!n) return;
					if (colDesc.key) {
						if (!types.isObjectExpression(n.value)) throw error(this.filePath, n, `${name}.${key} is not an object literal`);
						dest[name][key] = {};
						n.value.properties.forEach(p => {
							this.parse(colDesc, dest[name][key], n.value, p.key.name, p.value);
						})
					} else {
						if (!types.isArrayExpression(n.value)) throw error(this.filePath, n, `${name}.${key} is not an array expression`);
						dest[name][key] = [];
						n.value.elements.forEach((elt, i) => {
							this.parse(colDesc, dest[name][key], n.value, i, elt);
						});
					}
				});
				break;
			case 'type':
				if (!types.isStringLiteral(node)) throw error(this.filePath, node, `${name} value is not a string literal`);
				dest[name] = node.value;
				['enum', 'typeCode', 'maxLength', 'precision', 'scale'].forEach(k => {
					const n = propNode(parent, k);
					// TODO: check node tpes
					if (n) dest[k] = n.value.value;
				});
				// todo; check validity
				break;
				/*
			case 'flags':
				if (!types.isStringLiteral(node)) throw error(this.filePath, node, `${name} value is not a string literal`);
				node.value.split(',').forEach(flag => {
					const key = flag.trim();
					if (!desc.dictCodes[key]) throw error(this.filePath, node, `${name} invalid flag value: ${key}`);
					dest[name + util.pascalize(flag.trim())] = true;
				});
				break;*/
			default:
				throw new Error(`${name}: unhandled type ${desc.type}`);
		}
	}
}

exports.parseFile = function(_, filePath, descriptor) {
	const source = fs.readFile(filePath, 'utf8', _);
	return exports.parseSource(_, source, filePath, descriptor);
}

exports.parseSource = function(_, source, filePath, descriptor) {
	const ast = babylon.parse(source, { sourceType: 'module' });
	var found = false;
	var result = {
		file: filePath,
		ast: ast,
	}
	traverse(ast, {
		ExportDefaultDeclaration(path) {
			path.stop();
			const declaration = path.node.declaration;
			if (!types.isCallExpression(declaration) || 
				!types.isMemberExpression(declaration.callee) || 
				!types.isIdentifier(declaration.callee.property, { name: descriptor.defineMethod })) {
				throw error(filePath, declaration, `default export is not an 'x3js.${descriptor.defineMethod}' call`);				
			}
			const def = declaration.arguments[0];
			result.root = def;
			if (!types.isObjectExpression(def)) throw error(filePath, def, `definition is not an object literal`);
			new Parser(filePath).parse(descriptor, result, null, 'data', def);
		},
	});
	if (!result.root) throw new Error(`${path}: invalid source file: export default not found`);
	return result;
}

exports.parseSourceFiles = function(_, subdir, descriptor, superv, tracker) {
	tracker.phase = 'reading source files';
	const root = superv.directories.jsLocal || superv.directories.jsShared;
	if (!root) throw new Error("cannot processs files: root directory missing");
	const results = [];
	fs.readdir(root, _).forEach_(_, (_, sub) => {
		const subPath = fsp.join(root, sub, subdir);
		if (!fs.exists(subPath, _, _)) return;
		fs.readdir(subPath, _).forEach_(_, (_, fname) => {
			if (!fname.endsWith('.x3js')) return;
			const filePath = fsp.join(subPath, fname);
			tracker.phaseDetail = filePath;
			var parsed = exports.parseFile(_, filePath, descriptor);
			results.push(parsed);
		});
	});
	return results;
}


