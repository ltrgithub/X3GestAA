"use strict";

const fs = require('fs');
const fsp = require('path');
const util = require('etna/lib/supervisor/util');
const x3jsUtil = require('./util');

class ParseError extends Error {
	constructor(filePath, node, message) {
		super(`${ filePath }:${ node && node.loc && node.loc.start.line }: ${ message }`);
		this.isParseError = true;
	}
}
function error(filePath, node, message) {
	return new ParseError(filePath, node, message);
}

function propNode(node, key) {
	return node.properties.filter(p => p.key.name === key)[0];
}

class Parser {
	constructor(filePath) {
		this.filePath = filePath;
		// lazy require for babel
		this.types = require('babel-types');
	}
	parse(desc, dest, parent, name, node) {
		const types = this.types;
		try {
			switch (desc.type) {
				case 'string':
				case 'flags':
					if (node) types.assertStringLiteral(node);
					dest[name] = node ? node.value : '';
					break;
				case 'boolean':
					if (node) types.assertBooleanLiteral(node);
					dest[name] = node ? node.value : false;
					break;
				case 'enum':
					if (node) types.assertStringLiteral(node);
					// todo; check validity
					dest[name] = node ? node.value : '';
					break;
				case 'integer':
					if (node) types.assertNumericLiteral(node);
					// todo; check validity
					dest[name] = node ? node.value : 0;
					break;
				case 'event':
					if (node) types.assertIdentifier(node);
					if (node) dest[name] = node.name;
					break;
				case 'type':
					types.assertStringLiteral(node);
					dest[name] = node.value;
					['enum', 'typeCode', 'classCode'].forEach(k => {
						const n = propNode(parent, k);
						if (n) types.assertStringLiteral(n.value);
						dest[k] = n ? n.value.value : '';
					});
					['maxLength', 'precision', 'scale'].forEach(k => {
						const n = propNode(parent, k);
						if (n) types.assertNumericLiteral(n.value);
						dest[k] = n ? n.value.value : 0;
					});
					// typeCode is not generated in source on boolean nodes
					if (node.value === 'boolean') dest.typeCode = 'M';
					break;
				case 'object':
					if (desc.codeGen === 'dictIdOnly') {
						if (node) types.assertNumericLiteral(node);
						dest[name] = {
							dictId: node ? node.value : 0
						};
						break;
					}
					if (node) types.assertObjectExpression(node);
					dest[name] = Object.keys(desc.properties).reduce((obj, key) => {
						const n = node && propNode(node, key);
						if (node && !n) {
							if (desc.isMandatory) throw new Error(`mandatory attribute missing`);
						}
						this.parse(desc.properties[key], obj, node, key, n && n.value);
						return obj;
					}, {});
					if (node) Object.keys(desc.collections || {}).forEach(key => {
						const n = propNode(node, key);
						const colDesc = desc.collections[key];
						if (colDesc.key || colDesc.specialKey) {
							dest[name][key] = {};
							if (!n) return;
							types.assertObjectExpression(n.value);
							n.value.properties.forEach(p => {
								// p.key is either an identifier or a string literal.
								this.parse(colDesc, dest[name][key], n.value, p.key.name || p.key.value, p.value);
							});
						} else if (colDesc.cardinality === 1) {
							if (!n) return;
							types.assertObjectExpression(n.value);
							// pass null as parent - don't allow type properties in this context.
							this.parse(colDesc, dest[name], null, key, n.value);
						} else {
							if (!n) return;
							dest[name][key] = [];
							types.assertArrayExpression(n.value);
							n.value.elements.forEach((elt, i) => {
								this.parse(colDesc, dest[name][key], n.value, i, elt);
							});
						}
					});
					break;
				default:
					throw new Error(`unhandled type ${ desc.type }`);
			}
		} catch (ex) {
			throw ex.isParseError ? ex : error(this.filePath, node, `${ name }: parsing failed: ${ ex.message }`);
		}
	}
}

exports.parseFile = function (_, filePath, descriptor) {
	try {
		const source = fs.readFile(filePath, 'utf8', _);
		return exports.parseSource(_, source, filePath, descriptor);
	} catch (ex) {
		console.error(ex.stack);
		throw ex.isParseError ? ex : new Error(`${ filePath }: ${ ex.message }`);
	}
};

exports.parseSource = function (_, source, filePath, descriptor) {
	// lazy require for all babel libraries
	const babylon = require('babylon');
	const traverse = require('babel-traverse').default;
	const types = require('babel-types');
	const ast = babylon.parse(source, { sourceType: 'module' });
	const found = false;
	const result = {
		file: filePath,
		ast: ast
	};

	traverse(ast, {
		ExportDefaultDeclaration(path) {
			path.stop();
			const declaration = path.node.declaration;
			if (!types.isCallExpression(declaration) || !types.isMemberExpression(declaration.callee) || !types.isIdentifier(declaration.callee.property, { name: descriptor.defineMethod })) {
				throw error(filePath, declaration, `default export is not an 'x3js.${ descriptor.defineMethod }' call`);
			}
			const def = declaration.arguments[0];
			result.root = def;
			if (!types.isObjectExpression(def)) throw error(filePath, def, `definition is not an object literal`);
			new Parser(filePath).parse(descriptor, result, null, 'data', def);
		}
	});
	if (!result.root) throw new Error(`${ filePath }: invalid source file: export default not found`);
	return result;
};

exports.parseSourceFiles = function (_, subdir, descriptor, superv, tracker) {
	tracker.phase = 'reading source files';
	const root = superv.directories.jsLocal || superv.directories.jsShared;
	if (!root) throw new Error("cannot processs files: root directory missing");
	const results = [];
	fs.readdir(root, _).forEach_(_, (_, sub) => {
		const subPath = fsp.join(root, sub, subdir);
		if (!fs.exists(subPath, _, _)) return;
		fs.readdir(subPath, _).forEach_(_, (_, fname) => {
			if (!fname.endsWith('.x3js')) return;
			const filePath = fsp.join(subPath, fname);
			tracker.phaseDetail = filePath;
			const parsed = exports.parseFile(_, filePath, descriptor);

			results.push(parsed);
		});
	});
	return results;
};