"use strict";
/// !doc
/// [x3js dev guide](x3js-development-guide) > [x3js APIs](x3js-apis) > x3js class manager
///
/// # x3js class manager
///
/// Class artifacts are obtained with:
///
/// ```javascript
///  const MyClass = x3js.class('myModule.MyClass');
/// ```
/// For example:
///
/// ```javascript
/// const Country = x3js.class('system.Country');
/// ```
///
/// Once you have a handle to a class, you can use it to create instances of the class, query the class, etc.,
/// with the API described below.

require('harmony-reflect'); // to get ES6 Proxy API
const instanceProxy = require('./instance-proxy');
const ClassQuery = require('./class-query').ClassQuery;
const glob = require('streamline-runtime').globals;
const ACTXCACHE = require('etna/lib/supervisor/builtins/ACTXCACHE');
const constants = require('etna/lib/supervisor/constants');
const util = require('../supervisor/util');
const x3jsUtil = require('./util');

function resolveKey(clas, key) {
	if (typeof key !== 'object') key = [key];
	if (Array.isArray(key)) {
		if (clas.tableIndex == null) throw new Error("cannot read, class is not persistent: " + clas.jsName);
		return key.reduce((r, v, i) => {
			if (i >= clas.tableIndex.columns.length) throw new Error("too many values in key: " + key.length);
			const col = clas.tableIndex.columns[i];
			r[col.name] = x3jsUtil.fromJs(v, col);
			return r;
		}, {});
	} else {
		throw new Error("NIY: key passed as object");
	}
}

class ClassHandler {
	constructor(path, clas) {
		this._path = path;
		this._class = clas;
	}
	get $proxyType() { return "class"; }
	/*
	handle(_) {
		const supervisor = glob.context.x3session.supervisor;
		if (!supervisor) throw new Error("internal error: no supervisor");
		if (this._handle) {
			if (this._handle.supervisor !== supervisor) throw new Error("internal error: supervisor mismatch");
			return this._handle;
		}

		const segs = this._path.split('.');
		if (segs.length !== 2) throw new Error(`invalid class path syntax: ${ this._path }`);
		this._handle = supervisor.loadClassByJsName(_, segs.join('.'));
		if (!this._handle) throw new Error(`class not found: ${ this._path }`);
		return this._handle;
	}*/
	///
	/// #### Creating an instance
	///
	/// * `MyClass.create(values = {})`: returns a new instance of `MyClass`. 
	///   `values` provides initial values for the properties of the new instance.
	create(_, values) {
		const clas = this._class;
		const instance = clas.supervisor.new(_, 'Instance', clas);
		instance._insideInit = true;
		instance.afterCreate(_);
		instance.$astalin = constants.CST_ANEW;
		instance.x3jsClass = this;
		instance.AINIT(_);
		instance._insideInit = false;
		const handler = instanceProxy.create(instance);
		if (values) Object.keys(values).forEach(name => {
			handler[name] = values[name];
			//const member = handler[name];
			//if (!member) throw new Error("invalid class member: " + clas.jsName + '.' + name);
			//member.set(_, values[name]);
		});
		return handler;
	}
	///
	/// #### Query and read
	///
	/// * `MyClass.query()`:  creates a query on `MyClass`. 
	///   See the [class query API](x3js-class-query) for details on the query object returned by this call.
	query() {
		//if (arguments.length > 0) throw new Error("query: bad arg count");
		return new ClassQuery(this._class);
	}
	/// * `MyClass.read(key)`:  reads an instance of `MyClass`, given a key value. 
	/// `key` may be:
	///   * a single value (simple primary key)
	///   * an array (composite primary key)
	///   * a JS object which will give the column names and their values.
	read(_, key) {
		const clas = this._class;
		return instanceProxy.create(clas.readInstance(_, null, resolveKey(clas, key)));
	}
	/// * `MyClass.cache(key)`:  reads an instance of `MyClass` from the folder's cache. 
	///   Similar to `MyClass.read` but going through the folder's cache. 
	///   `key`  must be the primary key value. 
	///   Throws if key value does not match any record. 
	///   Only classes that are marked as cacheable in the dictionary can be read with this call.
	cache(_, key) {
		const clas = this._class;
		const acache = glob.context.x3session.actx.get(_, 'ACACHE');
		const cl = acache.get(_, clas.name);
		const instance = ACTXCACHE.getInstance(_, cl, Array.isArray(key) ? key.join('~') : key);
		if (!instance) throw new Error("cached lookup failed: " + clas.jsName + '/' + key);
		return instanceProxy.create(instance);
	}
}

x3jsUtil.fiberize(ClassHandler.prototype);

const handlers = {};

// internal - don't document
exports.load = function (path) {
	if (!handlers[path]) handlers[path] = new ClassHandler(path);
	return handlers[path];
};


exports.define = function (_, def) {
	const clas = x3jsUtil.currentSupervisor(_).defineClass(_, def);
	return new ClassHandler(clas.jsName, clas);
};
