"use strict";

const glob = require('streamline/lib/globals');
const util = require("./util");
const array = require("./arrays");
const variables = require("./variables");

exports.functions = {
	FILECLA: {
		count: 0
	},
	FILEABRE: {
		count: 1,
		fn(n) {}
	},
	FILENAME: {
		count: 1,
		fn(n) {}
	},
	FILETYP: {
		count: 0,
		fn() {}
	},
	CLANBS: {
		count: 2,
		fn(cla, kind) {}
	},
	CLASIZ: {
		count: 2,
		fn(classe, exp_buf) {}
	},
	CLANAM: {
		count: 1,
		fn(classe) {}
	},
	CLAVAR: {
		count: 2,
		fn(classe, n) {}
	},
	CLALEV: {
		count: 1,
		fn(classe) {}
	}
};

function genSql(_, exp) {
	if (typeof exp === 'function') exp(_);
}

function sqlFn(name, type) {
	return function () {};
}
function binaryOp(op, sqlOp, type, numOp, numType) {
	return function (op1, op2) {
		return function binaryOp$do(_) {
			genSql(_, op1);
			genSql(_, op2);
		};
	};
}

const sqlFunctions = {
	LEN() {},
	TOUPPER: sqlFn("UPPER", "string"),
	TOLOWER: sqlFn("LOWER", "string"),
	CHR$: sqlFn("CHAR", "string"),
	LEFT$: function (arg, len) {},
	MID$: function (arg, first, len) {},
	CTRANS(arg) {},
	PAT(str, pat, revert) {},
	ABS: sqlFn("ABS", "number"),
	MOD: sqlFn("MOD", "number"),
	ARR2(arg) {},
	ARR: sqlFn("ROUND", "number"),
	FIX: sqlFn("TRUNCATE", "number"),
	INT: sqlFn("FLOOR", "number"),
	SQR: sqlFn("SQRT", "number"),
	COS: sqlFn("COS", "number"),
	SIN: sqlFn("SIN", "number"),
	TAN: sqlFn("TAN", "number"),
	ACOS: sqlFn("ACOS", "number"),
	ASIN: sqlFn("ASIN", "number"),
	ATAN: sqlFn("ATAN", "number"),
	PI: sqlFn("PI", "number"),
	EXP: sqlFn("EXP", "number"),
	LN: sqlFn("LOG", "number"),
	LOG: sqlFn("LOG10", "number"),

	FIND(arg) {}
};


exports.instructions = {
	SYMBOL(symb, app) {
		return function symbol$do(_) {};
	},
	LOCK(args, lw) {
		return function lock$do(_) {};
	},
	UNLOCK(args, lw) {
		return function lock$do(_) {};
	},
	NBRECORD(abbrev) {
		return function nbrecord$do(_) {};
	},
	UNIQID(abbrev) {
		return function uniqid$do(_) {};
	},
	ROWCOUNT(abbrev) {
		return function rowcount$do(_) {};
	},

	KEY(letter, abbrev, name, indices) {
		return function key$do(_) {};
	},
	EXECSQL(fsql) {
		return function execsql$do(_) {
			fsql(_);
		};
	},
	ANASQL(fsql, fvar) {
		return function anasql$do(_) {
			fsql(_);
			fvar(_);
		};
	},
	SQLDECL(type, name) {
		return function sqldecl$do(_, abv) {};
	},
	FORSQL(fsql, abv, vars, p, end, block) {
		return function forsql$do(_) {
			fsql(_);
			for (var i = 0; i < vars.length; i++) {
				vars[i](_, abv);
			}
			block(_);
			p[end](_);
		};
	},
	VTBINDEX(target, args) {
		return function vtbindex$do(_, analyse) {
			if (analyse) return target(_, analyse);
			else return array.instructions.INDEX(target, args)(_);
		};
	},
	VTBCV(letter, abbrev, field, silent) {
		return function vtbcv$do(_, analyse) {
			if (analyse) return variables.instructions.CV(letter, abbrev, field, silent);
			else return variables.instructions.CV(letter, abbrev, field, silent)(_);
		};
	},
	VTBV(field) {
		return function vtbv$do(_, analyse) {
			if (analyse) return variables.instructions.V(field);
			else return variables.instructions.V(field)(_);
		};
	},
	FILEVAL(abb, vars, frv, where, order) {
		return function dot$do(_) {
			// extracting values
			const tbvalues = util.instructions.A(frv)(_);
			// extracting table var

			const tbvar = frv.map_(_, (_, e) => e(_, 1));


			if (tbvar.length !== vars.length) throw new X3Error(69, abb);

			// new the other parameters
			for (var i = 0; i < vars.length; i++) {
				vars[i](_, abb);
			}
			where && where(_);
			order && order(_);
		};
	},
	FILESQL(abbrev, name, where, order) {
		return function file$do(_) {
			name(_);
			where && where(_);
			order && order(_);
		};
	},
	CLOSEFILE(scope, abbrevs) {
		return function closefile$do(_) {};
	},
	LOGICCLOSE(scope, abbrevs) {
		return function logicclose$do(_) {};
	},
	FILTER(abbrev, where, order) {
		return function filter$do(_) {
			where && where(_);
			order && order(_);
		};
	},

	COLUMNSITEM(abbrev, field, index) {
		return function columnsitem$do(_, def) {};
	},
	COLUMNS(abbrev, columns, ext) {
		return function columns$do(_) {};
	},
	HINT(nohint, key) {
		return function hint$do(_) {
			key && key(_);
		};
	},
	LINKITEM(key, outer, values) {
		return function linkitem$do(_) {
			key(_);
		};
	},
	LINK(abbrev, as, joins, where, order) {
		return function link$do(_) {
			where && where(_);
			order && order(_);
		};
	},
	LOOK(key, op, values, lock, hint) {
		const avalues = util.instructions.A(values);

		return function look$do(_) {
			avalues(_);
		};
	},

	READ(key, op, values, lock, hint) {
		const avalues = util.instructions.A(values);

		return function read$do(_) {
			avalues(_);
			hint && hint(_);
		};
	},
	WRITE(abbrev) {
		return function write$do(_) {};
	},
	REWRITE(key, op, values) {
		const avalues = util.instructions.A(values);

		return function rewrite$do(_) {
			avalues(_);
		};
	},
	DELETE(key, where, op, values) {
		const avalues = util.instructions.A(values);

		return function delete$do(_) {
			avalues(_);
		};
	},
	ASSIGNUPDATE(lhs, rhs) {
		return function assignupdate$do(_) {
			genSql(_, lhs);
			genSql(_, rhs);
		};
	},
	UPDATE(abbrev, where, assign) {
		return function update$do(_) {
			where && where(_);
		};
	},
	TRBEGIN(abbrevs) {
		//var aabrevs = util.instructions.A(abbrevs);
		return function trbegin$do(_) {};
	},
	COMMIT() {
		return function commit$do(_) {};
	},
	ROLLBACK() {
		return function rollback$do(_) {};
	},
	FORF(key, hint, lock, where, from, to, p, end, block) {
		const frmfv = util.instructions.A(from);
		const tofv = util.instructions.A(to);

		return function forf$do(_) {
			key(_);
			frmfv && frmfv(_);
			tofv && tofv(_);
			hint && hint(_);
			where && where(_);
			block(_);
			p[end](_);
		};
	},
	WHERE(wheres) {
		return function (_) {
			wheres.forEach_(_, (_, exp) => {
				genSql(_, exp);
			});
		};
	},
	WHERE2(wheres) {
		return function (_) {
			wheres.forEach_(_, (_, exp) => {
				exp(_);
			});
		};
	},
	ORDERITEM(exp, dir) {
		return function (_) {
			genSql(_, exp);
		};
	},
	ORDER(keyName, by, withExp, direct, klen) {
		return function (_) {
			withExp && withExp(_);
			klen && klen(_);
		};
	},
	SQLV(field) {
		return function sqlv$do(_) {
			//variables.instructions.V(field)(_);
		};
	},
	SQLINDEX(field, args) {
		const aargs = util.instructions.A(args);

		return function sqlindex$do(_) {
			array.instructions.INDEX(field, args);
			genSql(_, field);
			aargs(_);
		};
	},
	SQLCV(letter, abbrev, field) {
		return function sqlcv$do(_) {
			return variables.instructions.CV(letter, abbrev, field)(_);
		};
	},
	SQLF(field, args) {
		const sqlFunc = sqlFunctions[field];
		//if (!sqlFunc) return flowControl.instructions.F(field, args);

		return function sqlf$do(_) {
			args && args.map_(_, (_, arg) => {
				genSql(_, arg);
			});
		};
	},

	SQLEVALUE(req, ns, arg) {
		return function sqlevalue$do(_) {};
	},
	SQLKEY(kyname, op, np, args) {
		return function sqlsql$do(_) {};
	},

	SQLAND: binaryOp('AND', 'AND', 'boolean'),
	SQLOR: binaryOp('OR', 'OR', 'boolean'),
	SQLEQ: binaryOp('EQ', '=', 'boolean'),
	SQLNE: binaryOp('NE', '<>', 'boolean'),
	SQLLT: binaryOp('LT', '<', 'boolean'),
	SQLLE: binaryOp('LE', '<=', 'boolean'),
	SQLGT: binaryOp('GT', '>', 'boolean'),
	SQLGE: binaryOp('GE', '>=', 'boolean'),
	SQLADD: binaryOp('ADD', 'CONCAT', 'string', '+', 'number'),
	SQLSUB: binaryOp('SUB', 'CONCAT', 'string', '-', 'number'),
	SQLMUL: binaryOp('MUL', '*', 'number'),
	SQLDIV: binaryOp('DIV', '/', 'number')
};