"use strict";
var glob = require('streamline/lib/globals');
var util = require("./util");
var array = require("./arrays");
var variables = require("./variables");


exports.functions = {
	FILECLA: {
		count: 0
	},
	FILEABRE: {
		count: 1,
		fn: function(n) {
		}
	},
	FILENAME: {
		count: 1,
		fn: function(n) {
		}
	},
	FILETYP: {
		count: 0,
		fn: function() {
		}
	},
	CLANBS: {
		count: 2,
		fn: function(cla, kind) {
		}
	},
	CLASIZ: {
		count: 2,
		fn: function(classe, exp_buf) {
		}
	},
	CLANAM: {
		count: 1,
		fn: function(classe) {
		}
	},
	CLAVAR: {
		count: 2,
		fn: function(classe, n) {
		}
	},
	CLALEV: {
		count: 1,
		fn: function(classe) {
		}
	},
};


function genSql(_, exp) {
	if(typeof exp === 'function') exp(_);
}

function sqlFn(name, type) {
	return function() {
	};
}
function binaryOp(op, sqlOp, type, numOp, numType) {
	return function(op1, op2) {
		return function binaryOp$do(_) {
			genSql(_, op1);
			genSql(_, op2);
        }
	};
}

var sqlFunctions = {
	LEN: function() {},
	TOUPPER: sqlFn("UPPER", "string"),
	TOLOWER: sqlFn("LOWER", "string"),
	CHR$: sqlFn("CHAR", "string"),
	LEFT$: function(arg, len) {
	},
	MID$: function(arg, first, len) {
	},
	CTRANS: function(arg) {
	},
	PAT: function(str, pat, revert) {
	},
	ABS: sqlFn("ABS", "number"),
	MOD: sqlFn("MOD", "number"),
	ARR2: function(arg) {
	},
	ARR: sqlFn("ROUND", "number"),
	FIX: sqlFn("TRUNCATE", "number"),
	INT: sqlFn("FLOOR", "number"),
	SQR: sqlFn("SQRT", "number"),
	COS: sqlFn("COS", "number"),
	SIN: sqlFn("SIN", "number"),
	TAN: sqlFn("TAN", "number"),
	ACOS: sqlFn("ACOS", "number"),
	ASIN: sqlFn("ASIN", "number"),
	ATAN: sqlFn("ATAN", "number"),
	PI: sqlFn("PI", "number"),
	EXP: sqlFn("EXP", "number"),
	LN: sqlFn("LOG", "number"),
	LOG: sqlFn("LOG10", "number"),

	FIND: function(arg) {
	}
};

exports.instructions = {
	SYMBOL: function(symb, app) {
		return function symbol$do(_) {

		};
	},
	LOCK: function(args, lw) {
		return function lock$do(_) {
		};
	},
	UNLOCK: function(args, lw) {
		return function lock$do(_) {
		};
	},
	NBRECORD: function(abbrev) {
		return function nbrecord$do(_) {
		};
	},
	UNIQID: function(abbrev) {
		return function uniqid$do(_) {
		};
	},
	ROWCOUNT: function(abbrev) {
		return function rowcount$do(_) {
		};
	},

	KEY: function(letter, abbrev, name, indices) {
		return function key$do(_) {
		};
	},
	EXECSQL: function(fsql) {
		return function execsql$do(_) {
			fsql(_);
		};
	},
	ANASQL: function(fsql, fvar) {
		return function anasql$do(_) {
			fsql(_);
            fvar(_);
		};

	},
	SQLDECL: function(type, name) {
		return function sqldecl$do(_, abv) {
		};
	},
	FORSQL: function(fsql, abv, vars, p, end, block) {
		return function forsql$do(_) {
			fsql(_);
			for (var i = 0; i < vars.length; i++) {
				vars[i](_, abv);
			}
            block(_);
            p[end](_);
		};
	},
	FILESQL: function(abbrev, name, where, order) {
		return function file$do(_) {
			name(_);
			where && where(_);
            order && order(_);
		};
	},
	CLOSEFILE: function(scope, abbrevs) {
		return function closefile$do(_) {
		};
	},
	LOGICCLOSE: function(scope, abbrevs) {
		return function logicclose$do(_) {
		};
	},
	FILTER: function(abbrev, where, order) {
		return function filter$do(_) {
			where && where(_);
            order && order(_);
		};
	},

	COLUMNSITEM: function(abbrev, field, index) {
		return function columnsitem$do(_, def) {
		};
	},
	COLUMNS: function(abbrev, columns, ext) {
		return function columns$do(_) {
		};
	},
	HINT: function(nohint, key) {
		return function hint$do(_) {
			key && key(_);
		};
	},
	LINKITEM: function(key, outer, values) {
		return function linkitem$do(_) {
			key(_);
		};
	},
	LINK: function(abbrev, as, joins, where, order) {
		return function link$do(_) {
			where && where(_);
			order && order(_);
		};
	},
	LOOK: function(key, op, values, lock, hint) {
		var avalues = util.instructions.A(values);
		return function look$do(_) {
            avalues(_);
		};
	},

	READ: function(key, op, values, lock, hint) {
		var avalues = util.instructions.A(values);
		return function read$do(_) {
            avalues(_);
			hint && hint(_);
		};
	},
	WRITE: function(abbrev) {
		return function write$do(_) {
		};
	},
	REWRITE: function(key, op, values) {
		var avalues = util.instructions.A(values);
		return function rewrite$do(_) {
			avalues(_);
		};
	},
	DELETE: function(key, where, op, values) {
		var avalues = util.instructions.A(values);
		return function delete$do(_) {
			avalues(_);
		};
	},
	ASSIGNUPDATE: function(lhs, rhs) {
		return function assignupdate$do(_) {
			genSql(_, lhs);
			genSql(_, rhs);
		};
	},
	UPDATE: function(abbrev, where, assign) {
		return function update$do(_) {
			where && where(_);

		};
	},
	TRBEGIN: function(abbrevs) {
		//var aabrevs = util.instructions.A(abbrevs);
		return function trbegin$do(_) {
		};
	},
	COMMIT: function() {
		return function commit$do(_) {
		};
	},
	ROLLBACK: function() {
		return function rollback$do(_) {
		};
	},
	FORF: function(key, hint, lock, where, from, to, p, end, block) {
		var frmfv = util.instructions.A(from);
		var tofv = util.instructions.A(to);
		return function forf$do(_) {
			key(_);
			frmfv && frmfv(_);
			tofv && tofv(_);
            hint && hint(_);
            where && where(_);
            block(_);
            p[end](_);
		};
	},
	WHERE: function(wheres) {
		return function(_) {
			wheres.forEach_(_, function(_, exp) {
				genSql(_, exp);
			});
		};
	},
	WHERE2: function(wheres) {
		return function(_) {
			wheres.forEach_(_, function(_, exp) {
				exp(_);
			});
		};
	},
	ORDERITEM: function(exp, dir) {
		return function(_) {
			genSql(_, exp);
		};
	},
	ORDER: function(keyName, by, withExp, direct, klen) {
		return function(_) {
            withExp && withExp(_)
            klen && klen(_);
		};
	},
	SQLV: function(field) {
		return function sqlv$do(_) {
			//variables.instructions.V(field)(_);
		};
	},
	SQLINDEX: function(field, args) {
		var aargs = util.instructions.A(args);
		return function sqlindex$do(_) {
			array.instructions.INDEX(field, args);
			genSql(_, field);
			aargs(_);
		};
	},
	SQLCV: function(letter, abbrev, field) {
		return function sqlcv$do(_) {
            return variables.instructions.CV(letter, abbrev, field)(_);
		};
	},
	SQLF: function(field, args) {
		var sqlFunc = sqlFunctions[field];
		//if (!sqlFunc) return flowControl.instructions.F(field, args);
		return function sqlf$do(_) {
			args && args.map_(_, function(_, arg) {
				genSql(_, arg);
			});
		};
	},

	SQLEVALUE: function(req, ns, arg) {
		return function sqlevalue$do(_) {
		};
	},
	SQLKEY: function(kyname, op, np, args) {
        return function sqlsql$do(_) {
		};
	},

	SQLAND: binaryOp('AND', 'AND', 'boolean'),
	SQLOR: binaryOp('OR', 'OR', 'boolean'),
	SQLEQ: binaryOp('EQ', '=', 'boolean'),
	SQLNE: binaryOp('NE', '<>', 'boolean'),
	SQLLT: binaryOp('LT', '<', 'boolean'),
	SQLLE: binaryOp('LE', '<=', 'boolean'),
	SQLGT: binaryOp('GT', '>', 'boolean'),
	SQLGE: binaryOp('GE', '>=', 'boolean'),
	SQLADD: binaryOp('ADD', 'CONCAT', 'string', '+', 'number'),
	SQLSUB: binaryOp('SUB', 'CONCAT', 'string', '-', 'number'),
	SQLMUL: binaryOp('MUL', '*', 'number'),
	SQLDIV: binaryOp('DIV', '/', 'number'),
};