"use strict";

const glob = require('streamline/lib/globals');
import * as util from './util';
import * as fs from 'fs';
const trace = null; //= console.log;

function checkLabel(nsVal, label, loc) {
	const lint = glob.context.lint;

	if (!nsVal || !nsVal[label]) {
		lint.addDiagnose("error", "label " + label + " not found in " + (lint.from || lint.getLocFilename(loc)), loc);
		return false;
	}
	return true;
}
function load(_: _,  ns) {
	const lint = glob.context.lint;

	lint.from = undefined;
	return ns(_);
}

export const instructions = {
	REQ(req, v) {
		const loc = util.sourceLoc;

		return function req$do(_: _) {
			const lint = glob.context.lint;
			const from = v ? v(_) : undefined;

			return lint.require(_, from, loc);
		};
	},
	// utility to delay resolution of p[i] branch
	GO(p, i) {
		return function go$do(_: _) {};
	},
	B(f1, f2) {
		const loc = util.sourceLoc;

		var fns = Array.prototype.slice.call(arguments, 0);
		if (fns.length == 1) return fns[0];
		fns = fns.filter(fn => {
			// eliminate NL(n) instructions
			return fn;
		});
		return function b$do(_: _) {
			for (var i = 0; i < fns.length; i++) {
				try {
					fns[i](_);
				} catch (e) {
					console.log(e.stack);
					var lint = glob.context.lint;
					lint.addDiagnose("fatal", "B:" + e.message, loc);
				}
			}
		};
	},
	GOTO(ns, label) {
		const loc = util.sourceLoc;

		return function gosub$do(_: _) {
			checkLabel(load(_, ns), label, loc);
		};
	},
	RET(arg) {
		return function ret$do(_: _) {};
	},
	ONERRGO(ns, label) {
		const loc = util.sourceLoc;

		return function onerrgo$do(_: _) {
			if (label && checkLabel(load(_, ns), label, loc)) {
				exports.instructions.GOSUB(util.instructions.C(load(_, ns)), label)(_);
			}
		};
	},
	RESUME() {
		const loc = util.sourceLoc;

		return function resume$do(_: _) {};
	},
	CALL(ns, name, args) {
		const aargs = args ? util.instructions.A(args) : undefined;
		const loc = util.sourceLoc;

		return function call$do(_: _) {
			const lint = glob.context.lint;
			const nameVal = typeof name === 'string' ? name : name.value !== undefined ? name.value : name(_);

			if (nameVal === undefined) return; // Happpens with statements like : func =FUNC_NAME

			try {
				var nsVal = ns.value !== undefined ? ns.value : load(_, ns);
			} catch (e) {
				var match = e.message.match(/Cannot find module '(.*)'/);
				if (match) {
					var script1 = match[1].replace(/^.*[\\\/]/, '');
					lint.addDiagnose("error", "script " + script1 + " not found", loc);
				}
				return;
			}
			if (!nsVal) return;

			if (nsVal[nameVal] === undefined) {
				lint.addDiagnose("error", "prog " + nameVal + " not found in " + (lint.from || lint.getLocFilename(loc)), loc);
				return;
			}
			const argVals = aargs ? aargs(_) : undefined;

			//var script = lint.getLocFilename(nsVal[nameVal].loc);

			const script = nsVal.$name;
			const key = script + "." + nameVal;

			if (lint.progs[key] !== undefined) return;
			lint.progs[key] = true;

			if (nsVal[nameVal].params.length && argVals && argVals.length !== nsVal[nameVal].params.length) {
				lint.addDiagnose("error", nameVal + " takes " + nsVal[nameVal].params.length + " parameters", loc);
			} else if (argVals && argVals.length && !nsVal[nameVal].params.length) {
				lint.addDiagnose("error", nameVal + " doesn't take parameters", loc);
			}

			try {
				var frame = glob.context.x3frame;;
				var prev = glob.context.x3frame;
				var cx = prev.context;
				glob.context.x3frame = frame = {
					types: {},
					context: cx
				};
				frame.sub = frame;
				frame.dicts = [frame, cx.globals, cx.sys, frame.context.undecl];

				var params = nsVal[nameVal].params;
				for (var i = 0; i < params.length; i++) {
					// By default the parameter is a constant of type ANY
					frame.types[params[i]] = "CX";
				}

				frame.checkV = true;

				trace && trace("CALL:" + script + "." + nameVal);
				nsVal[nameVal].body(_);
			} catch (e) {
				trace && trace("CALL error:" + e.message);
			} finally {
				glob.context.x3frame = prev;
			}
		};
	},
	END(arg) {
		return function end$do(_: _) {};
	},
	F(name, args) {},
	IF(cond, p, branch, block) {
		return function if$do(_: _) {
			cond && cond(_);
			block(_);
			p[branch](_);
		};
	},
	CASE(exp, p, branch) {
		return function case$do(_: _) {
			exp && exp(_);
			p[branch](_);
		};
	},
	WHEN(exps, p, branch, block) {
		return function when$do(_: _,  val) {
			for (var i = 0; i < exps.length; i++) {
				exps[i] && exps[i](_);
			}
			block(_);
			p[branch](_, val);
		};
	},
	WHILE(cond, p, end, block, isRepeat) {
		return function while$do(_: _) {
			cond && cond(_);
			block && block(_);
			p[end](_);
		};
	},
	FORV(varName, from, to, step, p, end, block) {
		return function forv$do(_: _) {
			from && from(_);
			to && to(_);
			step && step(_);
			block(_);
			p[end](_);
		};
	},
	FORIN(varName, items, p, end, block) {
		return function forv$do(_: _) {
			for (var i = 0, l = items.length; i < l; i++) items[i] && items[i](_);
			block(_);
			p[end](_);
		};
	},
	BREAK(p, level) {
		return function break$do(_: _) {};
	},
	GOSUB(ns, label) {
		const loc = util.sourceLoc;

		return function gosub$do(_: _) {
			const lint = glob.context.lint;
			const nsVal = load(_, ns);

			if (nsVal && checkLabel(nsVal, label, loc)) {
				var script = lint.getLocFilename(nsVal[label].loc || loc);
				var key = script + "." + label;

				// First save dictionnary :
				var frame = glob.context.x3frame;
				var dicts = [frame, frame.context.globals];

				if (lint.labels[key] !== undefined) {
					for (var i = 0; i < lint.labels[key].length; i++) {
						Object.keys(lint.labels[key][i]).forEach(field => {
							dicts[i].types[field] = lint.labels[key][i][field];
						});
					}
				} else {

					lint.labels[key] = [];

					var prev = [];
					for (var i = 0, len = dicts.length; i < len; i++) {
						prev[i] = {};
						if (dicts[i].types) {
							prev[i] = Object.keys(dicts[i].types).reduce((r, key) => {
								r[key] = dicts[i].types[key];
								return r;
							}, {});
						}
					}

					// Call the label
					nsVal[label] && nsVal[label](_);

					// Variables declared by the label :
					for (var i = 0, len = dicts.length; i < len; i++) {
						lint.labels[key][i] = {};
						if (dicts[i].types) {
							Object.keys(dicts[i].types).forEach(field => {
								if (prev[i][field] === undefined) {
									lint.labels[key][i][field] = dicts[i].types[field];
								}
							});
						}
					}
				}
			}
		};
	},
	MAIN(e, _) {
		try {
			exports.instructions.GOSUB(util.instructions.C(e), 'MAIN')(_);
		} catch (e) {
			console.log("FAILED: " + e + "\njs stack=" + e.stack);
		}
	}
};