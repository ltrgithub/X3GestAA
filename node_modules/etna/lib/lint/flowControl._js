"use strict"
var glob = require('streamline/lib/globals');
var util = require("./util");
var fs = require('fs');

var trace ;//= console.log;

function checkLabel(nsVal,label,loc) {
    var lint = glob.context.lint;
    if (!nsVal || !nsVal[label]) {
        lint.addDiagnose("error","label "+label+" not found in "+(lint.from || lint.getLocFilename(loc)),loc);
        return false;
    }
    return true;
}
function load(_,ns) {
	var lint = glob.context.lint;
	lint.from = undefined;
	return ns(_);	
}


exports.instructions = {
	REQ:function(req, v) {
		var loc = util.sourceLoc;
		return function req$do(_) {
			var lint = glob.context.lint;
			var from = v ? v(_) : undefined;
			return lint.require(_, from, loc);
		};
	},
	// utility to delay resolution of p[i] branch
	GO: function(p, i) {
		return function go$do(_) {
		};
	},    
	B: function(f1, f2) {
		var loc = util.sourceLoc;

		var fns = Array.prototype.slice.call(arguments, 0);
		if (fns.length == 1) return fns[0];
		fns = fns.filter(function(fn) { // eliminate NL(n) instructions
			return fn;
		});
		return function b$do(_) {
			for (var i = 0; i < fns.length ; i++) {
				try {
					fns[i](_);
				} catch (e) {
					console.log(e.stack);
					var lint = glob.context.lint;
					lint.addDiagnose("fatal","B:"+ e.message,loc);
				}
			}
		};
	},
	GOTO: function(ns, label) {
		var loc = util.sourceLoc;
		return function gosub$do(_) {
            checkLabel(load(_,ns),label,loc);
		};
	},    
    RET: function(arg) {
		return function ret$do(_) {
		};
	},
	ONERRGO: function(ns, label) {
		var loc = util.sourceLoc;
		return function onerrgo$do(_) {
            if(label && checkLabel(load(_,ns),label,loc)) {
               exports.instructions.GOSUB(util.instructions.C(load(_,ns)), label)(_);
            }
		};
	},
	RESUME: function() {
		var loc = util.sourceLoc;
		return function resume$do(_) {
		};
	},
	CALL:function(ns, name, args) {
		var aargs = args ? util.instructions.A(args) : undefined;
		var loc = util.sourceLoc;
		return function call$do(_) {
			var lint = glob.context.lint;
		
			var nameVal = typeof name === 'string' ? name : name.value !== undefined ? name.value : name(_);
			if(nameVal === undefined) return; // Happpens with statements like : func =FUNC_NAME
			
			var nsVal;
			try {
				var nsVal = ns.value !== undefined ? ns.value : load(_,ns);
			} catch(e) {
				var match = e.message.match(/Cannot find module '(.*)'/);
				if(match) {
					var script = match[1].replace(/^.*[\\\/]/, '');
					lint.addDiagnose("error","script "+script+" not found",loc);
				}
				return;
			}
			if(!nsVal) return;
		
			if(nsVal[nameVal] === undefined) {
				lint.addDiagnose("error","prog "+nameVal+" not found in "+(lint.from || lint.getLocFilename(loc)) ,loc);
				return;
			}
			var argVals = aargs ? aargs(_) : undefined;
			
			var script = lint.getLocFilename(nsVal[nameVal].loc);
			var key    = script + "." + nameVal;
			if(lint.progs[key] !== undefined) return;
			lint.progs[key] = true;

			if(nsVal[nameVal].params.length && argVals && argVals.length !== nsVal[nameVal].params.length) {
				lint.addDiagnose("error",nameVal+ " takes "+nsVal[nameVal].params.length+" parameters",loc);
			} else if(argVals && argVals.length && !nsVal[nameVal].params.length) {
				lint.addDiagnose("error",nameVal+ " doesn't take parameters",loc);
			}			

			try {
				var frame = glob.context.x3frame;;
				var prev = glob.context.x3frame;
                var cx = prev.context;
				glob.context.x3frame = frame = {
					types: {},
                    context: cx,
				};
				frame.sub = frame;
                frame.dicts = [frame, cx.globals, cx.sys, frame.context.undecl];
                frame.checkV = true;
                
				trace && trace("CALL:"+script+":"+nameVal);
				nsVal[nameVal].body(_);
			} catch(e) {
				trace && trace("CALL error:"+e.message);
			} finally {
				glob.context.x3frame = prev;
			}
		}
	},
	END: function(arg) {
		return function end$do(_) {
		};
	},
    F: function(name, args) {
    },
    IF: function(cond, p, branch, block) {
		return function if$do(_) {
			cond && cond(_);
    	    block(_);
		    p[branch](_);
		};
	},
    CASE: function(exp, p, branch) {
		return function case$do(_) {
			exp && exp(_);
            p[branch](_);
		};
	},
	WHEN: function(exps, p, branch, block) {
		return function when$do(_, val) {
			for (var i = 0; i < exps.length; i++) {
				exps[i] && exps[i](_);
			}
            block(_);
            p[branch](_, val);
		};
	},
    WHILE: function(cond, p, end, block, isRepeat) {
		return function while$do(_) {
            cond && cond(_);
            block && block(_);
			p[end](_);
		};
	},
	FORV: function(varName, from, to, step, p, end, block) {
		return function forv$do(_) {
			from && from(_);
			to && to(_);
			step && step(_);
            block(_);
            p[end](_);
		};
	},    
    FORIN: function(varName, items, p, end, block) {
		return function forv$do(_) {
			for (var i = 0, l = items.length; i < l ; i++)  items[i] && items[i](_);
            block(_);
            p[end](_);
    	};
	},
    BREAK: function(p, level) {
		return function break$do(_) {
		};
	},
	GOSUB:function(ns, label) {
		var loc = util.sourceLoc;
		return function gosub$do(_) {
		  	var lint = glob.context.lint;
          	var nsVal = load(_,ns);
	   		if(nsVal && checkLabel(nsVal,label,loc)){
	            var script = lint.getLocFilename(nsVal[label].loc || loc);
	            var key    = script + "." + label;

	            // First save dictionnary :
	            var frame = glob.context.x3frame;
	            var dicts = [frame,frame.context.globals];

	            if(lint.labels[key] !== undefined) {
	            	for(var i=0;i<lint.labels[key].length;i++) {
	            		Object.keys(lint.labels[key][i]).forEach(function(field){
	            			dicts[i].types[field] = lint.labels[key][i][field];
	            		});
	            	}
	            } else {

		            lint.labels[key] = [];    

		            var prev = [];
		            for (var i = 0, len = dicts.length; i < len; i++) {
		            	prev[i] = {};
		            	if(dicts[i].types) {
			            	prev[i] = Object.keys(dicts[i].types).reduce(function(r,key){
			            		r[key] = dicts[i].types[key];
			            		return r;
			            	},{});
		            	}
					}

					// Call the label
		            nsVal[label] && nsVal[label](_);

		            // Variables declared by the label :
		            for (var i = 0, len = dicts.length; i < len; i++) {
		            	lint.labels[key][i] = {}
		            	if(dicts[i].types) {
		            		Object.keys(dicts[i].types).forEach(function(field){
			            		if(prev[i][field] === undefined) {
			            			lint.labels[key][i][field] = dicts[i].types[field];
			            		}
			            	});
			            }
					}
				}
           }
        }
    },    
	MAIN: function(e, _) {
		try {
			exports.instructions.GOSUB(util.instructions.C(e), 'MAIN')(_);
		} catch (e) {
			console.log("FAILED: " + e + "\njs stack=" + e.stack);
		}
	}
};