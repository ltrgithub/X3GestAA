"use strict";

const glob = require('streamline/lib/globals');
import * as util from './util';

export const functions = {
	DIR$: {
		count: 0,
		fn() {}
	},
	FILEXIST: {
		count: 3,
		async: true,
		fn(_: _,  machine, folder, name) {}
	},
	FILINFO: {
		count: 2,
		async: true,
		fn(_: _,  path, what) {}
	},
	FILCOM: {
		//count: 6,
		// some args are optional (for ex only 4 in AVOLUME_CSTD line 665)
		fn(folder, name, ext, app, drive, host) {}
	},
	FILPATH: {
		async: true,
		count: -1,
		fn(_: _,  dir, nam, ext, app, vol, hst) {}
	},
	DELFILE: {
		async: true,
		count: 1,
		fn(_: _,  name) {}
	},
	RENAMEFILE: {
		async: true,
		count: 2,
		fn(_: _,  oldf, newf) {}
	}
};

export const instructions = {
	OPEN(abbrev, name, mode, seek) {
		seek = seek || util.instructions.C(0);
		return function open$do(_: _) {
			name && name(_);
			seek && seek(_);
		};
	},
	CLOSE(abbrev) {
		return function close$do(_: _) {};
	},
	IOMODE(abbrev, mode, value) {
		mode = mode.toLowerCase();
		return function iomode$do(_: _) {
			value && value(_);
		};
	},
	SEEK(abbrev, mode, _direction, value) {
		return function seek$do(_: _) {
			if (typeof _direction === "function") _direction(_);
			if (typeof value === "function") value(_);
		};
	},
	WRSEQ(abbrev, exps) {
		return function wrseq$do(_: _) {
			exps(_);
		};
	},
	RDSEQ(abbrev, vars) {
		return function rdseq$do(_: _) {
			for (var i = 0; i < vars.length; i++) {
				vars[i](_);
			}
			return 0;
		};
	},
	PUTSEQ(abbrev, nbr, vars) {
		return function putseq$do(_: _) {
			for (var i = 0; i < vars.length; i++) {
				vars[i](_);
			}
		};
	},
	GETSEQ(abbrev, nbr, vars, sized) {
		return function putseq$do(_: _) {
			for (var i = 0; i < vars.length; i++) {
				vars[i](_);
			}
		};
	}
};