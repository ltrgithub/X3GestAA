"use strict";

var glob = require('streamline/lib/globals');
var util = require("./util");

exports.functions = {
	DIR$: {
		count: 0,
		fn() {
		}
	},
	FILEXIST: {
		count: 3,
		async: true,
		fn(_, machine, folder, name) {
		}
	},
	FILINFO: {
		count: 2,
		async: true,
		fn(_, path, what) {

		},
	},
	FILCOM: {
		//count: 6,
		// some args are optional (for ex only 4 in AVOLUME_CSTD line 665)
		fn(folder, name, ext, app, drive, host) {
		}
	},
	FILPATH: {
		async: true,
		count: -1,
		fn(_, dir, nam, ext, app, vol, hst) {

		}
	},
	DELFILE: {
		async: true,
		count: 1,
		fn(_, name) {

		}
	},
	RENAMEFILE: {
		async: true,
		count: 2,
		fn(_, oldf, newf) {

		}
	}
};

exports.instructions = {
	OPEN(abbrev, name, mode, seek) {
		seek = seek || util.instructions.C(0);
		return function open$do(_) {
			name && name(_);
			seek && seek(_);
		};
	},
	CLOSE(abbrev) {
		return function close$do(_) {
		};
	},
	IOMODE(abbrev, mode, value) {
		mode = mode.toLowerCase();
		return function iomode$do(_) {
			value && value(_);
		};
	},
	SEEK(abbrev, mode, _direction, value) {
		return function seek$do(_) {
			if (typeof _direction === "function") _direction(_);
			if (typeof value === "function") value(_) ;
		};
	},
	WRSEQ(abbrev, exps) {
		return function wrseq$do(_) {
			exps(_);
		};
	},
	RDSEQ(abbrev, vars) {
		return function rdseq$do(_) {
            for(var i=0;i < vars.length;i++)  {
                vars[i](_);
            }
			return 0;
		};
	},
	PUTSEQ(abbrev, nbr, vars) {
		return function putseq$do(_) {
            for(var i=0;i < vars.length;i++) {
                vars[i](_);
            }
		};
	},
	GETSEQ(abbrev, nbr, vars, sized) {
		return function putseq$do(_) {
            for(var i=0;i < vars.length;i++) {
                vars[i](_);
            }
		};
	},
};