"use strict";

const glob = require('streamline/lib/globals');
import * as util from './util';
const trace = null; //= console.log;

export const instructions = {
	DEFAULT(scope, exp) {
		return function defaultfn$do(_: _) {};
	},
	CLALEV(arg) {
		return function clalev$do(_: _) {};
	},
	V(field) {
		const loc = util.sourceLoc;

		return function v$do(_: _,  operation, val, silent, strict) {
			const frame = glob.context.x3frame;
			// Restrict controls to locals, globals and systems

			const dicts = [frame, frame.context.globals, frame.context.sys];

			for (var i = 0, len = dicts.length; i < len; i++) {
				var dict = dicts[i];
				if (dict.types && dict.types[field] !== undefined) return;
			}
			if (frame.checkV === true) {
				trace && trace("undeclared variable " + field);
				frame.context.undecl.types[field] = loc;
			}
		};
	},
	TYPE(letter, field) {
		return function typev$do(_: _) {};
	},
	DIM(letter, field, rhs) {
		return function dim$do(_: _) {};
	},
	DYNTYPE(arg) {
		return function dyntype$do(_: _) {};
	},
	DYNDIM(arg) {
		return function dyndim$do(_: _) {};
	},
	CV(letter, abbrev, field, silent) {
		const loc = util.sourceLoc;

		return function cv$do(_: _,  operation, val, silent, strict) {
			const lint = glob.context.lint;
			const frame = glob.context.x3frame;

			var dict;
			switch (letter) {
				case 'L':
					dict = frame;
					break;
				case 'V':
					dict = frame.context.globals;
					break;
				case 'S':
					dict = frame.context.sys;
					break;
				case 'F':
				case '?':
					dict = frame.context.tables;
					break;
				case 'M':
				case 'G':
					if (lint.update > 6) lint.addDiagnose("obsolete", 'unknown class letter: [' + letter + ']', loc);
					break;
				default:
					lint.addDiagnose("error", 'unknown class letter: [' + letter + ']', loc);
					break;
			}
			if (['L', 'V', 'S'].indexOf(letter) >= 0 && dict) {
				// Check local and global variables only :
				if (dict.types && dict.types[field] !== undefined) return;
				if (frame.checkV === true) {
					trace && trace("undeclared variable " + field);
					frame.context.undecl.types[field] = loc;
				}
			}
		};
	},
	DECL(key, field, using, lens0, ranges0) {
		return function decl$do(_: _) {
			const frame = glob.context.x3frame;
			const dict = key[0] === 'V' ? frame.context.globals : glob.context.x3frame;

			trace && trace("DECL " + field + " " + key);
			dict.types[field] = key;
			if (key[0] === 'V' && frame.context.undecl.types) delete frame.context.undecl.types[field];
		};
	},
	CA(field, exps) {
		return function ca$do(_: _) {};
	},
	GET(obj, prop) {
		return function get$do(_: _) {};
	},
	SET(lhs, rhs, silent) {
		return function set$do(_: _) {
			if (typeof rhs === "function" && rhs.value === undefined) rhs(_);
			lhs && lhs(_, true);
		};
	},
	ASSIGN(lhs, rhs, silent) {
		return function assign$do(_: _) {};
	},
	RAZ(exps) {
		return function raz$do(_: _) {};
	},
	SNAP(target) {
		return function dot$do(_: _,  assign, val, silent) {};
	},
	PROP(target, name) {
		return function dot$do(_: _,  assign, val, silent) {};
	},
	ATT(target, property, attribut) {
		return function att$do(_: _,  assign, val, silent) {};
	},
	AGETATTR(target, property, attribut) {
		return function agetattr$do(_: _,  silent) {};
	},
	ASETATTR(target, property, attribut, val) {
		return function asetattr$do(_: _,  silent) {};
	},
	XMET(target, name, args) {
		// fmet and callmet
		return function dot$do(_: _) {};
	},
	VAR(key, field) {
		return function var$do(_: _) {};
	},
	FILEVAL(abbrev, vars, from) {
		return function dot$do(_: _) {};
	},
	NEW(clas) {
		return function new$do(_: _) {};
	},
	FREE(allocGroup, isGroup) {
		return function free$do(_: _) {};
	},
	FREEZE(target) {
		return function freeze$do(_: _) {};
	},
	KILL(exps) {
		return function raz$do(_: _) {};
	},
	CLA(letter, abbrev) {
		return function cla$do(_: _,  operation, val, silent, strict) {};
	},
	AADD(target, position) {
		return function aadd$do(_: _,  silent) {};
	},
	ADEL(target, position) {
		return function adel$do(_: _,  silent) {};
	},
	ASETCOLUMNATTR(target, collection, column, attribute, val) {
		return function asetcolumnattr$do(_: _,  silent) {};
	},
	AGETCOLUMNATTR(target, collection, column, attribute) {
		return function agetcolumnattr$do(_: _,  silent) {};
	},

	AGETTEXT(target, property) {
		return function agettext$do(_: _,  silent) {};
	},
	ASETTEXT(target, property, intit) {
		return function asettext$do(_: _,  silent) {};
	},
	AGETTEXTLAN(target, property, lan) {
		return function agettextlan$do(_: _,  silent) {};
	},
	ASETTEXTLAN(target, property, intit, lan) {
		return function asettextlan$do(_: _,  silent) {};
	},
	AGETTEXTRA(target, property) {
		return function agettextra$do(_: _,  silent) {};
	},
	AGETTEXTRALAN(target, property, lan) {
		return function agettextralan$do(_: _,  silent) {};
	},
	ASETTEXTRALAN(target, property, intit, lan) {
		return function asettextralan$do(_: _,  silent) {};
	}
};