"use strict";

const fs = require("streamline-fs");
const glob = require('streamline/lib/globals');
const variables = require("etna/lib/engine/runtime/variables");
const runtime = require("etna/lib/engine/runtime/runtime");
const register = require("etna/lib/engine/register");
const Parser = require("etna/lib/engine/parser").Parser;
const jsgen = require("etna/lib/engine/jsgen");
const util = require("./util");
const trace; //= console.log;

['arrays', 'dates', 'db', 'evaluate', 'fileio', 'flowControl', 'misc', 'numbers', //
'operators', 'stats', 'strings', 'system', 'util', 'variables', //
'tbcd', 'uuid', 'tblbfile', 'tclbfile'].forEach(name => {
	const module = require('./' + name);

	module.instructions && Object.keys(module.instructions).forEach(k => {
		runtime.instructions[k] = module.instructions[k];
	});
});

function mtimeSync(fname) {
	try {
		return fs.statSync(fname).mtime;
	} catch (ex) {
		return 0;
	}
}

function declVar(dict, name, type, value) {
	dict.values[name] = value;
	dict.types[name] = type;
}

class X3Lint {
	constructor(root, options) {
		trace && trace("X3Lint " + root);
		this.root = root;
		this.diagnoses = {};
		this.progs = {};
		this.labels = {};
		this.modulesNotFound = {};
		this.cache = {};
		glob.context.lint = this;
		variables.initStack({});
		glob.context.x3frame.context.undecl = { types: {} };

		const sys = glob.context.x3frame.context.sys;

		declVar(sys, 'ACTIHGUP', 'CS', [1, variables.types["S"].def, ['', '', ''], 0, 2]);
		declVar(sys, 'ACCESSORFILTER', 'CS', [1, variables.types["S"].def, [], 0, null]);
		declVar(sys, 'SNAPSHOTFILTER', 'CS', [1, variables.types["S"].def, [], 0, null]);
		declVar(sys, 'ADXSTI', 'CS', [1, variables.types["S"].def, [], 0, null]);
		declVar(sys, 'ISOMESS', 'VS', "");
	}

	compile(source, name, filename) {
		const fn = new Function("module", "exports", "requireScript", "require", "'use strict';" + source);
		const module = {
			id: name,
			filename: filename,
			exports: {}
		};

		function req(_, name) {
			return this.require(_, name);
		}
		try {
			fn(module, module.exports, req, require);
		} catch (ex) {
			throw new Error(filename + ": module initialization failed: " + ex.stack.split('\n').slice(0, 2).join(': '));
		}
		return module.exports;
	}

	cachedPath(path) {
		const cacheRoot = (process.env.HOME || (process.env.HOMEDRIVE + process.env.HOMEPATH).replace(/\\/g, '/')) + "/.lint";
		const i = path.lastIndexOf('/');

		var dir = cacheRoot + '/' + path.substring(0, i).replace(/[\/\\:]/g, '__');
		dir = dir + path.substring(i, path.length - 4) + ".js";
		register.mkdirsSync(dir);
		return dir;
	}

	require(_, name, loc) {
		if (!name || this.modulesNotFound[name]) return undefined;
		if (this.cache[name]) return this.cache[name];
		this.from = name;
		try {
			var path = this.root + "/" + name + ".src";
			var cpath = this.cachedPath(path);
			var transformed;
			if (mtimeSync(cpath) > mtimeSync(path)) {
				transformed = fs.readFileSync(cpath, "utf8");
			} else {
				//trace && trace(path);
				var source = fs.readFile(path, "utf8", _);
				var parsed = new Parser(source, path).parse();
				transformed = jsgen.generate(parsed.node, path);
				fs.writeFileSync(cpath, transformed, "utf8");
			}
			this.cache[name] = this.compile(transformed, name, path);
			this.cache[name].$name = name;
			return this.cache[name];
		} catch (e) {
			console.log(e.message);
			console.log(e.stack);

			this.modulesNotFound[this.from] = true;
			loc.file = loc.file || this.from;
			var message = e.message.split('\n')[0];

			if (/^ENOENT/.test(message)) {
				message = message.replace(/^.*[\\\/]/, '').replace(/'/g, '');
				this.addDiagnose("fatal", "Cannot find module " + message, loc);
			} else if (/^\[200\] 200 \[/.test(message) || /^\[26\] 26 \[/.test(message)) {

				var line;
				var match = message.match(/^\[\d*\]\s\d*\s\[(.*src):(\d*)/);
				if (match && match.length > 2) {
					line = fs.readFileSync(match[1], 'utf8').split('\n')[parseInt(match[2]) - 1];
					console.log(line);
				}
				message = message.replace(/^.*[\\\/]/, '');
				message = message.substring(0, message.length - 1);

				if (line) message += ' : ' + line;

				this.addDiagnose("fatal", "Parsing error " + message, loc);
			} else this.addDiagnose("fatal", "REQ " + message + " (" + this.from + ")", loc);
		}
	}

	getLocFilename(loc) {
		if (!loc || !loc.file) return "";
		//console.log("getLocFilename:",loc)
		const filename = loc.file.replace(/^.*[\\\/]/, '');

		return filename.substring(0, filename.indexOf('.'));
	}

	addDiagnose(severity, message, loc) {
		// var e = new Error("debug");
		// console.log(e.stack);
		var source = "";
		var line = 0;
		if (loc) {
			source = this.getLocFilename(loc);
			line = loc.line;
		}

		const key = source + '~' + line;

		trace && trace(severity + "(" + key + "):" + message);

		this.diagnoses[key] = {
			severity: severity,
			source: source,
			line: line,
			message: message
		};
	}

	getDiagnoses() {
		const types = glob.context.x3frame.context.undecl.types;

		Object.keys(types).forEach(field => {
			this.addDiagnose("warning", "undefined variable:" + field, types[field]);
		});

		return Object.keys(this.diagnoses).reduce((r, key) => {
			r.push(this.diagnoses[key]);
			return r;
		}, []);
	}

	check(_, script) {
		trace && trace("check:" + script);
		const module = runtime.instructions.REQ(null, util.instructions.C(script))(_);

		module && Object.keys(module).forEach_(_, (_, prog) => {
			if (module[prog].name && module[prog].name[0] !== '$') {
				if (module[prog].name !== 'wrapper') {
					runtime.instructions.CALL(util.instructions.C(module), module[prog].name)(_);
				} else {
					glob.context.x3frame.checkV = false;
					runtime.instructions.GOSUB(util.instructions.C(module), prog)(_);
				}
			}
		});
	}
}

exports.X3Lint = X3Lint;