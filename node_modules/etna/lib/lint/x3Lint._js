"use strict";

var fs = require("streamline-fs");
var glob = require('streamline/lib/globals');

var variables = require("etna/lib/engine/runtime/variables");
var runtime = require("etna/lib/engine/runtime/runtime");
var register = require("etna/lib/engine/register");
var Parser = require("etna/lib/engine/parser").Parser;
var jsgen = require("etna/lib/engine/jsgen");
var util = require("./util");

glob.context.collectErrors = false;
var trace;//= console.log;

['arrays', 'dates', 'db', 'evaluate', 'fileio', 'flowControl', 'misc', 'numbers', //
    'operators', 'stats', 'strings', 'system', 'util', 'variables', //
    'tbcd', 'uuid', 'tblbfile', 'tclbfile'].forEach(function (name) {
    var module = require('./' + name);
    module.instructions && Object.keys(module.instructions).forEach(function (k) {
        runtime.instructions[k] = module.instructions[k];
    });
});


var cacheProperties = {
    sizeLimit : 100,
    nbElementToDelete : 25
}

function mtimeSync(fname) {
    try {
        return fs.statSync(fname).mtime;
    } catch (ex) {
        return 0;
    }
}

function declVar(dict, name, type, value) {
    dict.values[name] = value;
    dict.types[name] = type;
}

function clearCacheAccordingToSize(cache, cacheProperties) {

    var sourceFiles = Object.keys(cache);
    if (sourceFiles.length === cacheProperties.sizeLimit) {
        console.log("reached the size : " + cacheProperties.sizeLimit);
        sourceFiles.sort(function (a, b) {
            return cache[a].$nb - cache[b].$nb;
        });

        for (var i = 0; i < cacheProperties.nbElementToDelete; i++) {
            delete cache[sourceFiles[i]];
        }
        console.log("deleting " + cacheProperties.nbElementToDelete + " cache items");
    }
}


class X3Lint {
    constructor(root, options) {
        trace && trace("X3Lint " + root);
        this.root = root;
        this.diagnoses = {};
        this.progs = {};
        this.labels = {};
        this.modulesNotFound = {};
        this.cache = {};
        glob.context.lint = this;
        variables.initStack({});
        glob.context.x3frame.context.undecl = {types: {}};

        var sys = glob.context.x3frame.context.sys;
        declVar(sys, 'ACTIHGUP', 'CS', [1, variables.types["S"].def, ['', '', ''], 0, 2]);
        declVar(sys, 'ACCESSORFILTER', 'CS', [1, variables.types["S"].def, [], 0, null]);
        declVar(sys, 'SNAPSHOTFILTER', 'CS', [1, variables.types["S"].def, [], 0, null]);
        declVar(sys, 'ADXSTI', 'CS', [1, variables.types["S"].def, [], 0, null]);
        declVar(sys, 'ISOMESS', 'VS', "");

    }

    compile(source, name, filename) {
        var fn = new Function("module", "exports", "requireScript", "require", "'use strict';" + source);
        var module = {
            id: name,
            filename: filename,
            exports: {}
        };

        function req(_, name) {
            return this.require(_, name);
        }

        try {
            fn(module, module.exports, req, require);
        } catch (ex) {
            throw new Error(filename + ": module initialization failed: " + ex.stack.split('\n').slice(0, 2).join(': '));
        }
        return module.exports;
    }


    cachedPath(path) {
        var cacheRoot = ((process.env.HOME || (process.env.HOMEDRIVE + process.env.HOMEPATH).replace(/\\/g, '/')) + "/.lint");
        var i = path.lastIndexOf('/');
        var dir = cacheRoot + '/' + path.substring(0, i).replace(/[\/\\:]/g, '__');
        dir = dir + path.substring(i, path.length - 4) + ".js";
        register.mkdirsSync(dir);
        return dir;
    }

    require(_, name, loc) {
        if (!name || this.modulesNotFound[name]) return undefined;
        if (this.cache[name]) {
            this.cache[name].$nb++;
            return this.cache[name];
        }
        this.from = name;
        clearCacheAccordingToSize(this.cache, cacheProperties);
        try {
            var path = this.root + "/" + name + ".src";
            var cpath = this.cachedPath(path);
            var transformed;
            if (mtimeSync(cpath) > mtimeSync(path)) {
                transformed = fs.readFileSync(cpath, "utf8");
            } else {
                //trace && trace(path);
                var source = fs.readFile(path, "utf8", _);
                var parsed = new Parser(source, path).parse();
                transformed = jsgen.generate(parsed.node, path);
                fs.writeFileSync(cpath, transformed, "utf8");
            }
            this.cache[name] = this.compile(transformed, name, path);
            this.cache[name].$name = name;
            this.cache[name].$nb = 1;
            return this.cache[name];
        } catch (e) {
            //console.log(e.message);
            //console.log(e.stack);

            this.modulesNotFound[this.from] = true;
            loc.file = loc.file || this.from;
            var message = e.message.split('\n')[0];

            if (/^ENOENT/.test(message)) {
                message = message.replace(/^.*[\\\/]/, '').replace(/'/g, '');
                this.addDiagnose("fatal", "Cannot find module " + message, loc);
            } else if (/^\[200\] 200 \[/.test(message) || /^\[26\] 26 \[/.test(message)) {

                var line;
                var match = message.match(/^\[\d*\]\s\d*\s\[(.*src):(\d*)/);
                if (match && match.length > 2) {
                    line = fs.readFileSync(match[1], 'utf8').split('\n')[parseInt(match[2]) - 1];
                    console.log(line);
                }
                message = message.replace(/^.*[\\\/]/, '');
                message = message.substring(0, message.length - 1);

                if (line) message += ' : ' + line;

                this.addDiagnose("fatal", "Parsing error " + message, loc);
            }
            else this.addDiagnose("fatal", "REQ " + message + " (" + this.from + ")", loc);
        }
    }

    getLocFilename(loc) {
        if (!loc || !loc.file) return "";
        //console.log("getLocFilename:",loc)
        var filename = loc.file.replace(/^.*[\\\/]/, '');
        return filename.substring(0, filename.indexOf('.'));
    }

    addDiagnose(severity, message, loc) {
        // var e = new Error("debug");
        // console.log(e.stack);

        //we don't collect errors on a pragma block
        if (glob.context.collectErrors) {
            return;
        }

        var source = "";
        var line = 0;
        if (loc) {
            source = this.getLocFilename(loc);
            line = loc.line;
        }

        var key = source + '~' + line;
        trace && trace(severity + "(" + key + "):" + message);

        this.diagnoses[key] = {
            severity: severity,
            source: source,
            line: line,
            message: message
        };
    }

    getDiagnoses() {
        var self = this;
        var types = glob.context.x3frame.context.undecl.types;
        Object.keys(types).forEach(function (field) {
            self.addDiagnose("warning", "undefined variable:" + field, types[field]);
        });

        return Object.keys(this.diagnoses).reduce(function (r, key) {
            r.push(self.diagnoses[key]);
            return r;
        }, []);
    }


    check(_, script) {
        trace && trace("check:" + script);
        var module = runtime.instructions.REQ(null, util.instructions.C(script))(_);
        module && Object.keys(module).forEach_(_, function (_, prog) {
            if (module[prog].name && module[prog].name[0] !== '$') {
                if (module[prog].name !== 'wrapper') {
                    runtime.instructions.CALL(util.instructions.C(module), module[prog].name)(_);
                } else {
                    glob.context.x3frame.checkV = false;
                    runtime.instructions.GOSUB(util.instructions.C(module), prog)(_);
                }
            }
        })
    }
}


exports.X3Lint = X3Lint;