"use strict";

var fs = require("streamline-fs");
var glob = require('streamline/lib/globals');

var variables = require("etna/lib/engine/runtime/variables");
var runtime = require("etna/lib/engine/runtime/runtime");
var Parser = require("etna/lib/engine/parser").Parser;
var jsgen = require("etna/lib/engine/jsgen");
var util = require("./util");

var trace ;//= console.log;

['arrays','dates','db','evaluate','fileio','flowControl','misc','numbers', //
	'operators','stats','strings','system','util','variables', //
	'tbcd','uuid','tblbfile', 'tclbfile'].forEach(function(name) {
	var module =  require('./' + name);
	module.instructions && Object.keys(module.instructions).forEach(function(k) {
		runtime.instructions[k] = module.instructions[k];
	});
});

class X3Lint {
	constructor(root,options) {
		trace && trace("X3Lint "+root);
		this.root = root;
		this.diagnoses={};
		this.progs = {};
        this.labels = {};
        this.modulesNotFound = {};
        this.cache = {};
		glob.context.lint = this;
        variables.initStack({});
        glob.context.x3frame.context.undecl = {types:{}};
	}

	compile(source, name, filename) {
		var fn = new Function("module", "exports", "requireScript", "require", "'use strict';" + source);
		var module = {
			id: name,
			filename: filename,
			exports: {}
		};

		function req(_, name) {
			return this.require(_, name);
		}
		try {
			fn(module, module.exports, req, require);
		} catch (ex) {
			throw new Error(filename + ": module initialization failed: " + ex.stack.split('\n').slice(0, 2).join(': '));
		}
		return module.exports;
	}

	require(_, name, loc) {
	  	if (!name || this.modulesNotFound[name]) return undefined;
	  	if (this.cache[name]) return this.cache[name];
	  	this.from = name;		
		try {
			var path = this.root + "/" + name + ".src";
			//trace && trace(path);
			var source = fs.readFile(path, "utf8", _);
			var parsed = new Parser(source, path).parse();
			var transformed = jsgen.generate(parsed.node, path);
			this.cache[name ] = this.compile(transformed, name, path);
			return this.cache[name];
		} catch(e) {
			console.log(e.message);
			console.log(e.stack);
			
			this.modulesNotFound[this.from] = true;
			loc.file = loc.file || this.from;
			var message = e.message.split('\n')[0];

			if(/^ENOENT/.test(message)) {
				message = message.replace(/^.*[\\\/]/, '').replace(/'/g,'');
				this.addDiagnose("fatal","Cannot find module "+message,loc);
			} else if(/^\[200\] 200 \[/.test(message) || /^\[26\] 26 \[/.test(message)) {
				
				var line;
				var match = message.match(/^\[\d*\]\s\d*\s\[(.*src):(\d*)/);
				if(match && match.length > 2) {
					line = fs.readFileSync(match[1], 'utf8').split('\n')[parseInt(match[2])-1];
					console.log(line);
				}
				message = message.replace(/^.*[\\\/]/, '');
				message = message.substring(0,message.length-1);

				if(line) message += ' : '+line;

				this.addDiagnose("fatal","Parsing error " + message,loc);
			}
			else this.addDiagnose("fatal","REQ "+ message +" ("+this.from+")",loc);
		}
	}

	getLocFilename(loc) {
		if(!loc || !loc.file) return "";
		//console.log("getLocFilename:",loc)
		var filename  = loc.file.replace(/^.*[\\\/]/, '');
		return filename.substring(0,filename.indexOf('.')); 
	}
	
	addDiagnose(severity, message, loc) {
		// var e = new Error("debug");
		// console.log(e.stack);
		var source="";
		var line = 0;
		if(loc) {
			source = this.getLocFilename(loc); 
			line = loc.line;
		}
	
		var key =  source + '~' + line;
		trace && trace(severity+"("+key+"):"+message);
		
		this.diagnoses[key] = {
			severity:severity,
			source:source,
			line: line,
			message:message
		};
	}
	
	getDiagnoses() {
		var self = this;
        var types = glob.context.x3frame.context.undecl.types; 
        Object.keys(types).forEach(function(field){
            self.addDiagnose("warning","undefined variable:"+field,types[field]);
        });

    	return Object.keys(this.diagnoses).reduce(function(r,key) {
			r.push(self.diagnoses[key]);
			return r;
		},[]);
	}


	check(_,script) {
		trace && trace("check:"+script);
		var module = runtime.instructions.REQ(null, util.instructions.C(script))(_);
		module && Object.keys(module).forEach_(_,function(_,prog) {
			if(module[prog].name && module[prog].name !== 'wrapper') {
				runtime.instructions.CALL(util.instructions.C(module), module[prog].name)(_);
			} else {
				glob.context.x3frame.checkV = false;
                runtime.instructions.GOSUB(util.instructions.C(module), prog)(_);
			}
		})
	}
}


exports.X3Lint = X3Lint;