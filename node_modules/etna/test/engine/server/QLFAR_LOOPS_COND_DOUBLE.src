#<AdxTL>@(#)0.0.0.0 $Revision$
Call OUVRE_TRACE("QLFAR_LOOPS_COND_DOUBLE") From LECFIC
Call TESTSUITE()

Call FERME_TRACE From LECFIC
GTRACE = "QLFAR_LOOPS_COND_DOUBLE_"+GACTX.USER
Call LEC_TRACE From LECFIC
End

Funprog TESTSUITE()
Local Integer NBTEST


#For With Break
#If Elsif Endif
#Case
#While With Break
#Repeat Until
NBTEST=22
Call ADD_TESTCASE("TEST_INIT", "TEST_INIT -- initialization", NBTEST) From AXUNIT

NBTEST=33
Call ADD_TESTCASE("TEST_IF", "TEST_IF -- If instruction", NBTEST) From AXUNIT

NBTEST=46
Call ADD_TESTCASE("TEST_FOR_1", "TEST_FOR_1 -- For instruction", NBTEST) From AXUNIT

NBTEST=87
Call ADD_TESTCASE("TEST_FOR_2", "TEST_FOR_2 -- For instruction", NBTEST) From AXUNIT

NBTEST=39
Call ADD_TESTCASE("TEST_FOR_3", "TEST_FOR_3 -- For instruction", NBTEST) From AXUNIT

NBTEST=53
Call ADD_TESTCASE("TEST_WHILE", "TEST_WHILE -- While instruction", NBTEST) From AXUNIT

NBTEST=41
Call ADD_TESTCASE("TEST_REPEAT", "TEST_REPEAT -- Repeat instruction", NBTEST) From AXUNIT

NBTEST=57
Call ADD_TESTCASE("TEST_CASE", "TEST_CASE -- Case instruction", NBTEST) From AXUNIT

Local Clbfile  SUITE_RESULT
SUITE_RESULT = func AXUNIT.RUN_TESTSUITE("LOOPS_COND", "LOOPS_COND")
End SUITE_RESULT


Subprog CHECK_EQUAL(GOT, EXPECT,TEXT)
Call CHECK_EQUAL(TEXT+"...", TEXT+"...") From AXUNIT
Call CHECK_EQUAL(GOT, EXPECT) From AXUNIT
End

$ERROR
Call CHECK_EQUAL(errn, EX) From AXUNIT
EX = 0
Resume


$FILL
Global Char STRINGS(1)(10)
Global Integer INTS(10)
Global Char LETTERS(20), DIGITS(20), LSORT(20), LSORTS(20), DSORT(20), LBYD(20), DBYL(20)
Global Char DBYL2(20), DBYL22(20), LSORTPART(20), ISORTPART(20)
LETTERS = "DAAFBCBBAF"
DIGITS =  "5531244153"

LSORT =   "AAABBBCDFF"
LSORTD =  "FFDCBBBAAA"
DSORT =   "1123344555"
LBYD  =   "BFBAFBCAAD"
DBYL  =   "3551244513"
DBYL2 =   "3154142553"
DBYL22 =  "3154412355"
LSORTPART = "DAABBCFBAF"
ISORTPART = "5532441153"

For I = 0 To 9 : STRINGS(I) = mid$(LETTERS, I+1, 1) : INTS(I) = val(mid$(DIGITS, I+1, 1)) : Next I
Return

Funprog DUMP_S(AR,DIME_1,DIME)
 Variable Char AR()()
 Value Integer DIME_1,DIME
 Call CHECK_EQUAL("BEGIN DUMP_S", "BEGIN DUMP_S") From AXUNIT
 Call CHECK_EQUAL(dim(AR,-1), DIME_1) From AXUNIT
 Call CHECK_EQUAL(dim(AR,1), DIME) From AXUNIT
End sigma(dim(AR,-1), dim(AR,-1) + dim(AR,1) - 1, AR(indcum))

Funprog DUMP_I(AR,DIME_1,DIME)
 Variable Integer AR()
 Value Integer DIME_1,DIME
 Call CHECK_EQUAL("BEGIN DUMP_I", "BEGIN DUMP_I") From AXUNIT
 Call CHECK_EQUAL(dim(AR,-1), DIME_1) From AXUNIT
 Call CHECK_EQUAL(dim(AR,1), DIME) From AXUNIT
End sigma(dim(AR,-1), dim(AR,-1) + dim(AR,1) - 1, num$(AR(indcum)))



Subprog TEST_INIT()
 Gosub FILL
 Local Integer I,J,K
 Local Char TT(255)
 Call CHECK_EQUAL(dim(STRINGS), 10 ) From AXUNIT
 Call CHECK_EQUAL(dim(INTS), 10 ) From AXUNIT
 Call CHECK_EQUAL(dim(STRINGS,-1), 0 ) From AXUNIT
 Call CHECK_EQUAL(dim(INTS,-1), 0 ) From AXUNIT
 Call CHECK_EQUAL(dim(STRINGS,1), 10 ) From AXUNIT
 Call CHECK_EQUAL(dim(INTS,1), 10 ) From AXUNIT
 Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), LETTERS) From AXUNIT
 Call CHECK_EQUAL(func DUMP_I(INTS,0,10), DIGITS) From AXUNIT

    Call CHECK_EQUAL(STRINGS(I), mid$(LETTERS, I+1, 1)) From AXUNIT
    Call CHECK_EQUAL(num$(STRINGS(I)), mid$(LETTERS, I+1, 1)) From AXUNIT
    #Error: [10] Incompatibilité de type
    If pat(ver$(0),"etna*")>0
    Local Integer EX : EX=10
    Onerrgo ERROR
    Endif
    K=val(STRINGS(I))
    Onerrgo
    Call CHECK_EQUAL(K, 0 ) From AXUNIT
 #
    #Error: [10] Incompatibilité de type
    Local Integer EX : EX=10
    Onerrgo ERROR
    TT=INTS(I)
    Onerrgo
    Call CHECK_EQUAL(num$(INTS(I)), mid$(DIGITS, I+1, 1) ) From AXUNIT
    Call CHECK_EQUAL(num$(INTS(I)), num$(mid$(DIGITS, I+1, 1)) ) From AXUNIT
    #Error: [10] Incompatibilité de type
    Local Integer EX : EX=10
    Onerrgo ERROR
    K=val(INTS(I))
    Onerrgo
    Call CHECK_EQUAL(K, 0 ) From AXUNIT
End

Subprog TEST_FOR_1()
Local Integer I,J,K,L,M
Local Char TT(255)

TT="Single loops without break"
Call CHECK_EQUAL(TT, TT ) From AXUNIT

Raz K,L,M
For I=0 To 9
 K+=1
Next I
Call CHECK_EQUAL(K, 10) From AXUNIT

Raz K
For A=0 To 9
 K+=1
Next I
Call CHECK_EQUAL(A, 10) From AXUNIT

Raz K
For B=0 To 9 Step 0.5
 K+=1
Next I
Call CHECK_EQUAL(B, 9.5) From AXUNIT

TT="One single loop with 'break 0'"
Call CHECK_EQUAL(TT, TT ) From AXUNIT
Raz K,L,M
For I=0 To 9
 K+=1
 Break 0
 L+=1
Next I
Call CHECK_EQUAL(K, 10) From AXUNIT
Call CHECK_EQUAL(L, 10) From AXUNIT

TT="One single loop with 'break''"
Call CHECK_EQUAL(TT, TT ) From AXUNIT
Raz K,L,M
For I=0 To 10
 K+=1
 Break
 L+=1
Next I
Call CHECK_EQUAL(K, 1) From AXUNIT
Call CHECK_EQUAL(L, 0) From AXUNIT

TT="One single loop with 'break 1'"
Call CHECK_EQUAL(TT, TT ) From AXUNIT
Raz K,L,M
For I=0 To 10
 K+=1
 Break 1
 L+=1
Next I
Call CHECK_EQUAL(K, 1) From AXUNIT
Call CHECK_EQUAL(L, 0) From AXUNIT

TT="One single loop with 'break' on condition'"
Call CHECK_EQUAL(TT, TT ) From AXUNIT
Raz K,L,M
For I=0 To 10
 K+=1
 Break (I=5)
 L+=1
Next I
Call CHECK_EQUAL(K, 6) From AXUNIT
Call CHECK_EQUAL(L, 5) From AXUNIT

TT="Two loops without break "
Call CHECK_EQUAL(TT, TT ) From AXUNIT
Raz K,L,M
For I=0 To 9
 For J=0 To 9
  K+=1
 Next J
Next I
Call CHECK_EQUAL(K, 100) From AXUNIT

TT="Two loops with break 0"
Call CHECK_EQUAL(TT, TT ) From AXUNIT
Raz K,L,M
For I=0 To 9
 For J=0 To 9
  K+=1
  Break 0
  L+=1
 Next J
 M+=1
Next I
Call CHECK_EQUAL(K, 100) From AXUNIT
Call CHECK_EQUAL(L, 100) From AXUNIT
Call CHECK_EQUAL(M, 10) From AXUNIT

TT="Two loops with break (=break 1)"
Call CHECK_EQUAL(TT, TT ) From AXUNIT
Raz K,L,M
For I=0 To 9
 For J=0 To 9
  K+=1
  Break
  L+=1
 Next J
 M+=1
Next I
Call CHECK_EQUAL(K, 10) From AXUNIT
Call CHECK_EQUAL(L, 0) From AXUNIT
Call CHECK_EQUAL(M, 10) From AXUNIT

TT="Two loops with break 1"
Call CHECK_EQUAL(TT, TT ) From AXUNIT
Raz K,L,M
For I=0 To 9
 For J=0 To 9
  K+=1
  Break 1
  L+=1
 Next J
 M+=1
Next I
Call CHECK_EQUAL(K, 10) From AXUNIT
Call CHECK_EQUAL(L, 0) From AXUNIT
Call CHECK_EQUAL(M, 10) From AXUNIT

TT="Two loops with break 2"
Call CHECK_EQUAL(TT, TT ) From AXUNIT
Raz K,L,M
For I=0 To 9
 For J=0 To 9
  K+=1
  Break 2
  L+=1
 Next J
 M+=1
Next I
Call CHECK_EQUAL(K, 1) From AXUNIT
Call CHECK_EQUAL(L, 0) From AXUNIT
Call CHECK_EQUAL(M, 0) From AXUNIT

TT="Two loops with break on condition"
Call CHECK_EQUAL(TT, TT ) From AXUNIT
Raz K,L,M
For I=0 To 9
 For J=0 To 9
  K+=1
  Break (J=5)
  L+=1
 Next J
 M+=1
Next I
Call CHECK_EQUAL(K, 60) From AXUNIT
Call CHECK_EQUAL(L, 50) From AXUNIT
Call CHECK_EQUAL(M, 10) From AXUNIT

TT="Two loops with break and Next does not specify loop counter"
Call CHECK_EQUAL(TT, TT ) From AXUNIT
Raz K,L,M
For I=0 To 9
 For J=0 To 9
  K+=1
  Break
  L+=1
 Next
 M+=1
Next
Call CHECK_EQUAL(K, 10) From AXUNIT
Call CHECK_EQUAL(L, 0) From AXUNIT
Call CHECK_EQUAL(M, 10) From AXUNIT

TT="Break negative generates errn=50"
Call CHECK_EQUAL(TT, TT ) From AXUNIT
Local Integer EX
Onerrgo ERROR
EX=50
For J=0 To 0
  Break -1
Next

TT="Break higher than allowed by loops generates errn=50"
Call CHECK_EQUAL(TT, TT ) From AXUNIT
Local Integer EX
Onerrgo ERROR
EX=50
For J=0 To 0
  Break 20
Next


End

Subprog TEST_FOR_2()
 Gosub FILL
 Local Double I,J,K
 Local Char TT(255)
#
 TT="-1 FOR"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 For I=0 To 9
  For J=0 To 9
   K+=1
  Next J
 Next I
 Call CHECK_EQUAL(I, 10 ) From AXUNIT
 Call CHECK_EQUAL(J, 10 ) From AXUNIT
 Call CHECK_EQUAL(K, 100 ) From AXUNIT
#
 TT="-2 FOR"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 For I=0 To 9
  For J=0 To 9
   K+=1
   Call CHECK_EQUAL(num$(I)+'/'+num$(J)+'='+num$(K)-STRINGS(I)+num$(INTS(J)), num$(I)+'/'+num$(J)+'='+num$(K)-mid$(LETTERS, I+1, 1)+mid$(DIGITS, J+1, 1) ) From AXUNIT
   If J>=6 : Break : Endif
  Next J
  Call CHECK_EQUAL('K='+num$(K), 'K='+num$((I+1)*7) ) From AXUNIT
  If K>=32 : Break : Endif
 Next I
 Call CHECK_EQUAL(I, 4 ) From AXUNIT
 Call CHECK_EQUAL(J, 6 ) From AXUNIT
 Call CHECK_EQUAL(K, 35 ) From AXUNIT
 #
 TT="-3 FOR"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 For I=0 To 9
  Call CHECK_EQUAL(STRINGS(I), mid$(LETTERS, I+1, 1) ) From AXUNIT
  For J=0 To 9
   Call CHECK_EQUAL(STRINGS(I)+num$(INTS(J)), mid$(LETTERS, I+1, 1)+mid$(DIGITS, J+1, 1) ) From AXUNIT
   K+=1
   If K>=15 : Break 2 : Endif
  Next J
 Next I
 Call CHECK_EQUAL(I, 1 ) From AXUNIT
 Call CHECK_EQUAL(J, 4 ) From AXUNIT
 Call CHECK_EQUAL(K, 15 ) From AXUNIT

 #
 TT="-4 FOR"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 Local Char TAB(10)(1..50)
 For I=1 To 50
  TAB(I)=num$(I)
 Next
 Raz I,J,K
 For TT="1","3.5","6","8.5","11"
  I+=1
  TAB(I)=TT
 Next
 Call CHECK_EQUAL(TT, "11" ) From AXUNIT
 TT="-5 FOR"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 For I = 1 To 13 Step 2.5 : J+=1 : Call CHECK_EQUAL(num$(I), TAB(J) ) From AXUNIT : Next I : Call CHECK_EQUAL(num$(I), "13.5" ) From AXUNIT
   # affiche : 1 3.5 6 8.5 11 FIN=13.5
# #
 TT="-6 FOR"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 For I= 15 To 12 : J+=1 : Call CHECK_EQUAL(num$(I), TAB(J) ) From AXUNIT : Next I : Call CHECK_EQUAL(num$(I), "15" ) From AXUNIT
#   # affiche : FIN=15
# #
 TT="-7 FOR"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 For I = 15 To 11 Step -1 : J+=1 : Call CHECK_EQUAL(num$(I), TAB(I) ) From AXUNIT : Next I : Call CHECK_EQUAL(num$(I), "10" ) From AXUNIT
#   # affiche : 15 14 13 12 11 FIN=10
End

Subprog TEST_FOR_3()
 Local Char TT(255)
TT="1: loop on a value with step 1"
Call CHECK_EQUAL(TT, TT ) From AXUNIT
   Local Integer I,J
   For I=1 To 10
     J+=I
   Next I
   # At this point, I=11, and J=55
   Call CHECK_EQUAL(I,11) From AXUNIT
   Call CHECK_EQUAL(J,55) From AXUNIT

TT="2: loop on a decimal value"
Call CHECK_EQUAL(TT, TT ) From AXUNIT
  Local Double NUMBER
  Local Integer LOOP_COUNT
  For NUMBER=pi To 10 Step pi
    LOOP_COUNT+=1
  Next NUMBER
  # At this point, NUMBER is equal to 4*pi (the first value that exceeds 10) and LOOP_COUNT is equal to 3
  Call CHECK_EQUAL(NUMBER,4*pi) From AXUNIT
  Call CHECK_EQUAL(LOOP_COUNT,3) From AXUNIT

TT="3: descending loop"
Call CHECK_EQUAL(TT, TT ) From AXUNIT
  Local Integer DOWN, LOOP_COUNT
  For DOWN=20 To 0 Step -4
    LOOP_COUNT+=1
  Next DOWN
  # At this point, DOWN is equal to -4 and LOOP_COUNT is equal to 6
  Call CHECK_EQUAL(DOWN,-4) From AXUNIT
  Call CHECK_EQUAL(LOOP_COUNT,6) From AXUNIT

TT="4: Loop that will never be executed"
Call CHECK_EQUAL(TT, TT ) From AXUNIT
  Local Integer I, STARTING_POINT,LOOP_COUNT
  STARTING_POINT = 12
  For I=STARTING_POINT To STARTING_POINT+3 Step -1
    LOOP_COUNT+=1
  Next I
  Call CHECK_EQUAL(I,12) From AXUNIT
  Call CHECK_EQUAL(LOOP_COUNT,0) From AXUNIT
  # At this point, LOOP_COUNT is equal to 0: as the range is ascending and the step descending no loop will be performed

TT="5: Loop on list and Loop on months xcept June and July"
Call CHECK_EQUAL(TT, TT ) From AXUNIT
  Local Char IMONTH(20)
  Local Integer IWEEK, LOOPCOUNT
  For IMONTH="January","February","March","April","May","August","September","October","November","December"
    For IWEEK=1,3,4
      LOOPCOUNT+=1
    Next IWEEK
  Next IMONTH
  Call CHECK_EQUAL(IMONTH,"December") From AXUNIT
  Call CHECK_EQUAL(IWEEK,4) From AXUNIT
  Call CHECK_EQUAL(LOOPCOUNT,30) From AXUNIT
#
TT="6: Loop on a list of dates"
Call CHECK_EQUAL(TT, TT ) From AXUNIT
  Local Date START_DATE
  Local Integer LOOPCOUNT
  For START_DATE=[01/02/2017],[10/02/2017],[15/02/2017],[20/02/2017]
  LOOPCOUNT+=1
  Break LOOPCOUNT>2
  Next
  Call CHECK_EQUAL(START_DATE,[15/02/2017]) From AXUNIT
  Call CHECK_EQUAL(LOOPCOUNT,3) From AXUNIT

#
TT="7: Loop on a list of dates in different formats - adxdcs=1950"
Call CHECK_EQUAL(TT, TT ) From AXUNIT
  Local Date START_DATE, END_DATE
  Local Integer LOOPCOUNT
  For START_DATE="20170201",[10/02/2017],"510218"
    LOOPCOUNT+=1
 Next
  Call CHECK_EQUAL(START_DATE,[18/02/1951]) From AXUNIT
  Call CHECK_EQUAL(LOOPCOUNT,3) From AXUNIT

TT="8: Loop on a start and end integer"
Call CHECK_EQUAL(TT, TT ) From AXUNIT
  Local Integer START_INT, END_INT, IDX_INT
  Local Integer LOOPCOUNT_INT
  START_INT = 12
  END_INT = 17
  LOOPCOUNT_INT = 0
  For IDX_INT=START_INT To END_INT
    LOOPCOUNT_INT+=IDX_INT
  Next
  Call CHECK_EQUAL(LOOPCOUNT_INT,87) From AXUNIT

TT="9: Loop on a start and end integer with step"
Call CHECK_EQUAL(TT, TT ) From AXUNIT
  Local Integer START_INT, END_INT, IDX_INT
  Local Integer LOOPCOUNT_INT
  START_INT = 12
  END_INT = 17
  LOOPCOUNT_INT = 0
  For IDX_INT=START_INT To END_INT Step 2
    LOOPCOUNT_INT+=IDX_INT
  Next
  Call CHECK_EQUAL(LOOPCOUNT_INT,42) From AXUNIT

########################################################################
# Float is not supported in etna
#TT="10: Loop on a start and end Float"
#Call CHECK_EQUAL(TT, TT ) From AXUNIT
#  Local Float START_DEC, END_FLOAT, IDX_FLOAT
#  Local Float LOOPCOUNT_FLOAT
#  START_FLOAT = 1.7
#  END_FLOAT = 1.70001
#  LOOPCOUNT_FLOAT = 0
#  For IDX_FLOAT=START_FLOAT To END_FLOAT
#    LOOPCOUNT_FLOAT+=IDX_FLOAT
#  Next
#  Call CHECK_EQUAL(LOOPCOUNT_FLOAT,1.7) From AXUNIT
#
#TT="11: Loop on a start and end float with step negative"
#Call CHECK_EQUAL(TT, TT ) From AXUNIT
#  # Note, LOOPCOUNT_FLOAT is equal 1728.51 due to rounding. Actual value should be 1728.45
#  # but it is not an error just rounding of floating points.
#  Local Float START_FLOAT, END_FLOAT, IDX_FLOAT
#  Local Float LOOPCOUNT_FLOAT
#  Local Integer LOOPCOUNT
#  START_FLOAT = 3.7
#  END_FLOAT = 3.2
#  LOOPCOUNT_FLOAT = 0
#  LOOPCOUNT=0
#  For IDX_FLOAT=START_FLOAT To END_FLOAT Step -0.001
#    LOOPCOUNT_FLOAT+=IDX_FLOAT
#    LOOPCOUNT+=1
#  Next
#  Call CHECK_EQUAL(LOOPCOUNT_FLOAT,1728.51) From AXUNIT
#  Call CHECK_EQUAL(LOOPCOUNT,501) From AXUNIT
########################################################################

TT="10: Loop on a start and end Double"
Call CHECK_EQUAL(TT, TT ) From AXUNIT
  Local Double START_DOUBLE, END_DOUBLE, IDX_DOUBLE
  Local Double LOOPCOUNT_DOUBLE
  START_DOUBLE = 1.7
  END_DOUBLE = 1.70001
  LOOPCOUNT_DOUBLE = 0
  For IDX_DOUBLE=START_DOUBLE To END_DOUBLE
    LOOPCOUNT_DOUBLE+=IDX_DOUBLE
  Next
  Call CHECK_EQUAL(LOOPCOUNT_DOUBLE,1.7) From AXUNIT

TT="11: Loop on a start and end Double with step negative"
Call CHECK_EQUAL(TT, TT ) From AXUNIT
  Local Double START_DOUBLE, END_DOUBLE, IDX_DOUBLE
  Local Double LOOPCOUNT_DOUBLE
  Local Integer LOOPCOUNT
  START_DOUBLE = 3.7
  END_DOUBLE = 3.2
  LOOPCOUNT_DOUBLE = 0
  LOOPCOUNT=0
  For IDX_DOUBLE=START_DOUBLE To END_DOUBLE Step -0.001
    LOOPCOUNT_DOUBLE+=IDX_DOUBLE
    LOOPCOUNT+=1
  Next
  Call CHECK_EQUAL(LOOPCOUNT_DOUBLE,1728.45) From AXUNIT
  Call CHECK_EQUAL(LOOPCOUNT,501) From AXUNIT

TT="12: Loop on a start and end Double"
Call CHECK_EQUAL(TT, TT ) From AXUNIT
  Local Double START_DECIMAL, END_DECIMAL, IDX_DECIMAL
  Local Double LOOPCOUNT_DECIMAL
  START_DECIMAL = 1.7
  END_DECIMAL = 1.70001
  LOOPCOUNT_DECIMAL = 0
  For IDX_DECIMAL=START_DECIMAL To END_DECIMAL
    LOOPCOUNT_DECIMAL+=IDX_DECIMAL
  Next
  Call CHECK_EQUAL(LOOPCOUNT_DECIMAL,1.7) From AXUNIT

TT="13: Loop on a start and end Double with step negative"
Call CHECK_EQUAL(TT, TT ) From AXUNIT
  Local Double START_DECIMAL, END_DECIMAL, IDX_DECIMAL
  Local Double LOOPCOUNT_DECIMAL
  Local Integer LOOPCOUNT
  START_DECIMAL = 3.7
  END_DECIMAL = 3.2
  LOOPCOUNT_DECIMAL = 0
  LOOPCOUNT=0
  For IDX_DECIMAL=START_DECIMAL To END_DECIMAL Step -0.001
    LOOPCOUNT_DECIMAL+=IDX_DECIMAL
    LOOPCOUNT+=1
  Next
  Call CHECK_EQUAL(LOOPCOUNT_DECIMAL,1728.45) From AXUNIT
  Call CHECK_EQUAL(LOOPCOUNT,501) From AXUNIT


TT="14: Loop on a start and end integer step 0"
Call CHECK_EQUAL(TT, TT ) From AXUNIT
  Onerrgo ERROR
  EX=41           # Null step value
  Local Integer START_INT, END_INT, IDX_INT
  Local Integer LOOPCOUNT_INT,LOOPCOUNT
  START_INT = 12
  END_INT = 17
  LOOPCOUNT_INT = 0
  LOOPCOUNT=0
  For IDX_INT=START_INT To END_INT Step 0
    LOOPCOUNT +=1
    Break (LOOPCOUNT>1000)
    LOOPCOUNT_INT+=IDX_INT
  Next
  #check that this statement be executed :
  Call CHECK_EQUAL(EX,0) From AXUNIT

  End
#

Subprog TEST_IF()
 Gosub FILL
 Local Integer I,J,K,TROUVE
 Local Char TT(255)
 TT="-1 IF"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 For I=0 To 9
  If STRINGS(I)<> mid$(LETTERS, I+1, 1)
   Call CHECK_EQUAL("Error"+STRINGS(I), mid$(LETTERS, I+1, 1) ) From AXUNIT
  Elsif STRINGS(I)=mid$(DIGITS, I+1, 1)
   Call CHECK_EQUAL("Error"+STRINGS(I), mid$(DIGITS, I+1, 1) ) From AXUNIT
  Elsif STRINGS(I)=mid$(LETTERS, I+1, 1)
   Call CHECK_EQUAL(STRINGS(I), mid$(LETTERS, I+1, 1) ) From AXUNIT
  Endif
 Next I
#
 TT="-2 IF"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 For I=0 To 9
  If STRINGS(I)<> mid$(LETTERS, I+1, 1)
   Call CHECK_EQUAL("Error"+STRINGS(I), mid$(LETTERS, I+1, 1) ) From AXUNIT
  Elsif STRINGS(I)=mid$(DIGITS, I+1, 1)
   Call CHECK_EQUAL("Error"+STRINGS(I), mid$(DIGITS, I+1, 1) ) From AXUNIT
  Elsif STRINGS(I)=mid$(LETTERS, I+1, 1)
   Call CHECK_EQUAL(STRINGS(I), mid$(LETTERS, I+1, 1) ) From AXUNIT
  Else
   Call CHECK_EQUAL("Error"+STRINGS(I), mid$(LETTERS, I+1, 1) ) From AXUNIT
  Endif
 Next I
#
 TT="-3 IF"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 For I=0 To 9
  If STRINGS(I)<> mid$(LETTERS, I+1, 1)
   Call CHECK_EQUAL("Error"+STRINGS(I), mid$(LETTERS, I+1, 1) ) From AXUNIT
  Elsif STRINGS(I)=mid$(DIGITS, I+1, 1)
   Call CHECK_EQUAL("Error"+STRINGS(I), mid$(DIGITS, I+1, 1) ) From AXUNIT
  Else
   Call CHECK_EQUAL(STRINGS(I), mid$(LETTERS, I+1, 1) ) From AXUNIT
  Endif
 Next I
End

Subprog TEST_CASE()
 Local Double I,J,K
 Local Char TT
#
 Raz I,J,K
 Local Char TAB(10)(1..50)
 For I=1 To 50
  TAB(I)=num$(I)
 Next
 Raz I,J,K
 For TT="1","3.5","6","8.5","11"
  I+=1
  TAB(I)=TT
 Next

 #
 TT="-1 CASE - for loop"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 For I=1 To 50
  Case TAB(I)
  When "1" : Call CHECK_EQUAL('When "1" :'-num$(I), 'When "1" :'-TAB(I) ) From AXUNIT
  When "3.5" : Call CHECK_EQUAL('When "3.5" : 3.5', 'When "3.5" :'-TAB(I) ) From AXUNIT
  When "8.5" : Call CHECK_EQUAL('When "8.5" : 8.5', 'When "8.5" :'-TAB(I) ) From AXUNIT
  When "10","15","20" : Call CHECK_EQUAL('When "10","15","20" :'-num$(I), 'When "10","15","20" :'-TAB(I) ) From AXUNIT
  When "30" :
  When "40" : Call CHECK_EQUAL('When "40" :'-num$(I), 'When "40" :'-TAB(I) ) From AXUNIT
  When "45"
  When "50" : Call CHECK_EQUAL('When "50" :'-num$(I), 'When "50" :'-TAB(I) ) From AXUNIT
  When Default : Call CHECK_EQUAL('When Default :'-num$(I), 'When Default :'-num$(I) ) From AXUNIT
  Endcase
 Next
 #
 TT="-2 CASE - For loop step 0.5"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 For I=1 To 10 Step 0.5
  Case I
  When 1   : Call CHECK_EQUAL(1, I ) From AXUNIT
  When 3.5 : Call CHECK_EQUAL(3.5,I) From AXUNIT
  When 8.5 : Call CHECK_EQUAL(8.5,I) From AXUNIT
  Endcase
 Next
 #
 TT="-3 CASE - Step through dates"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Local Date IDATE
 For IDATE=[31/01/2012],"20140218","530917"
  Case IDATE
  When [31/01/2012]  : Call CHECK_EQUAL(IDATE,[31/01/2012] ) From AXUNIT
  When [18/02/2014]  : Call CHECK_EQUAL(IDATE,[18/02/2014] ) From AXUNIT
  When [17/09/1953]  : Call CHECK_EQUAL(IDATE,[17/09/1953] ) From AXUNIT
  Endcase
 Next
End

Subprog TEST_WHILE()
 Gosub FILL
 Local Integer I,J,K,TROUVE
 Local Char TT(255)
#
 TT="-1 While- no breaks"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 While I<=9
  J=0
  While J<=9
   K+=1
   J+=1
  Wend
  I+=1
 Wend
 Call CHECK_EQUAL(I, 10 ) From AXUNIT
 Call CHECK_EQUAL(J, 10 ) From AXUNIT
 Call CHECK_EQUAL(K, 100 ) From AXUNIT
#
 TT="-2 While-Break 0"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 While I<=9
  J=0
  While J<=9
   K+=1
   If J>=6 : Break 0 : Endif
   J+=1
  Wend
  If K>=32 : Break 0: Endif
   I+=1
 Wend
 Call CHECK_EQUAL(I, 10 ) From AXUNIT
 Call CHECK_EQUAL(J, 10 ) From AXUNIT
 Call CHECK_EQUAL(K, 100 ) From AXUNIT
#
 TT="-2 While-Break"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 While I<=9
  J=0
  While J<=9
   K+=1
   If J>=6 : Break : Endif
   J+=1
  Wend
  If K>=32 : Break : Endif
   I+=1
 Wend
 Call CHECK_EQUAL(I, 4 ) From AXUNIT
 Call CHECK_EQUAL(J, 6 ) From AXUNIT
 Call CHECK_EQUAL(K, 35 ) From AXUNIT
 #
 TT="-2 While-Break 1"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 While I<=9
  J=0
  While J<=9
   K+=1
   If J>=6 : Break : Endif
   J+=1
  Wend
  If K>=32 : Break : Endif
   I+=1
 Wend
 Call CHECK_EQUAL(I, 4 ) From AXUNIT
 Call CHECK_EQUAL(J, 6 ) From AXUNIT
 Call CHECK_EQUAL(K, 35 ) From AXUNIT
 #
 TT="-3 While-Break 2"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 While I<=9
  J=0
  Call CHECK_EQUAL(STRINGS(I), mid$(LETTERS, I+1, 1) ) From AXUNIT
  While J<=9
   Call CHECK_EQUAL(STRINGS(I)+num$(INTS(J)), mid$(LETTERS, I+1, 1)+mid$(DIGITS, J+1, 1) ) From AXUNIT
   K+=1
   If K>=15 : Break 2 : Endif
   J+=1
  Wend
  I+=1
 Wend
 Call CHECK_EQUAL(I, 1 ) From AXUNIT
 Call CHECK_EQUAL(J, 4 ) From AXUNIT
 Call CHECK_EQUAL(K, 15 ) From AXUNIT
 #
 TT="-2 While-Break on condition"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 While I<=9
  J=0
  While J<=9
   K+=1
   Break J>=6
   J+=1
  Wend
  Break K>=32
   I+=1
 Wend
 Call CHECK_EQUAL(I, 4 ) From AXUNIT
 Call CHECK_EQUAL(J, 6 ) From AXUNIT
 Call CHECK_EQUAL(K, 35 ) From AXUNIT
 #
 TT="-2 While-Break on func condition"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 While I<=9
  J=0
  While J<=9
   K+=1
   Break func TST_VAL(J,6)
   J+=1
  Wend
  Break func TST_VAL(K,32)
   I+=1
 Wend
 Call CHECK_EQUAL(I, 4 ) From AXUNIT
 Call CHECK_EQUAL(J, 6 ) From AXUNIT
 Call CHECK_EQUAL(K, 35 ) From AXUNIT


#
 TT="-4 While"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 TROUVE=1
 While TROUVE
  J=0
  While J<=9
   K+=1
   If J>=6 : Break : Endif
   J+=1
  Wend
  If K>=32 : TROUVE=0 : Endif
  I+=1
 Wend
 Call CHECK_EQUAL(I, 5 ) From AXUNIT
 Call CHECK_EQUAL(J, 6 ) From AXUNIT
 Call CHECK_EQUAL(K, 35 ) From AXUNIT

#
 TT="-5 While"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 TROUVE=-1
 While TROUVE
  J=0
  While J<=9
   K+=1
   If J>=6 : Break : Endif
   J+=1
  Wend
  If K>=32 : TROUVE=0 : Endif
  I+=1
 Wend
 Call CHECK_EQUAL(I, 5 ) From AXUNIT
 Call CHECK_EQUAL(J, 6 ) From AXUNIT
 Call CHECK_EQUAL(K, 35 ) From AXUNIT

End

Subprog TEST_REPEAT()
 Gosub FILL
 Local Integer I,J,K,TROUVE
 Local Char TT(255)
#
 TT="-1 Repeat"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 Repeat
  J=0
  Repeat
   K+=1
   J+=1
  Until J>9
  I+=1
 Until I>9
 Call CHECK_EQUAL(I, 10 ) From AXUNIT
 Call CHECK_EQUAL(J, 10 ) From AXUNIT
 Call CHECK_EQUAL(K, 100 ) From AXUNIT
#
 TT="-2 Repeat - double repeat"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 Repeat
  J=0
  Repeat
   K+=1
   If J>=6 : Break : Endif
   J+=1
  Until J>9
  If K>=32 : Break : Endif
   I+=1
 Until I>9
 Call CHECK_EQUAL(I, 4 ) From AXUNIT
 Call CHECK_EQUAL(J, 6 ) From AXUNIT
 Call CHECK_EQUAL(K, 35 ) From AXUNIT
 #
 TT="-3 Repeat - double repeat with break 2"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 Repeat
  J=0
  Call CHECK_EQUAL(STRINGS(I), mid$(LETTERS, I+1, 1) ) From AXUNIT
  Repeat
   Call CHECK_EQUAL(STRINGS(I)+num$(INTS(J)), mid$(LETTERS, I+1, 1)+mid$(DIGITS, J+1, 1) ) From AXUNIT
   K+=1
   If K>=15 : Break 2 : Endif
   J+=1
  Until J>9
  I+=1
 Until I>9
 Call CHECK_EQUAL(I, 1 ) From AXUNIT
 Call CHECK_EQUAL(J, 4 ) From AXUNIT
 Call CHECK_EQUAL(K, 15 ) From AXUNIT
#
 TT="-4 Repeat - double repeat with break (=break 1)"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 TROUVE=1
 Repeat
  J=0
  Repeat
   K+=1
   If J>=6 : Break : Endif
   J+=1
  Until J>9
  If K>=32 : TROUVE=0 : Endif
  I+=1
 Until (I>9 | !TROUVE)
 Call CHECK_EQUAL(I, 5 ) From AXUNIT
 Call CHECK_EQUAL(J, 6 ) From AXUNIT
 Call CHECK_EQUAL(K, 35 ) From AXUNIT
#
 TT="-5 Repeat - double repeat with break 1"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 TROUVE=-1
 Repeat
  J=0
  Repeat
   K+=1
   If J>=6 : Break 1 : Endif
   J+=1
  Until J>9
  If K>=32 : TROUVE=0 : Endif
  I+=1
 Until (I>9 | !TROUVE)
 Call CHECK_EQUAL(I, 5 ) From AXUNIT
 Call CHECK_EQUAL(J, 6 ) From AXUNIT
 Call CHECK_EQUAL(K, 35 ) From AXUNIT

#
 TT="-6 Repeat - double repeat with break on condition"
 Call CHECK_EQUAL(TT, TT ) From AXUNIT
 Raz I,J,K
 TROUVE=-1
 Repeat
  J=0
  Repeat
   K+=1
   Break J>=6
   J+=1
  Until J>9
  If K>=32 : TROUVE=0 : Endif
  I+=1
 Until (I>9 | !TROUVE)
 Call CHECK_EQUAL(I, 5 ) From AXUNIT
 Call CHECK_EQUAL(J, 6 ) From AXUNIT
 Call CHECK_EQUAL(K, 35 ) From AXUNIT
End

Funprog TST_VAL(A1,A2)
Value Integer A1,A2
End A1>=A2
