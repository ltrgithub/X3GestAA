#<AdxTL>@(#)0.0.0.0 $Revision$
Call OUVRE_TRACE("QLFAR_FUNCTIONS") From LECFIC
Call TESTSUITE()

Call FERME_TRACE From LECFIC
GTRACE = "QLFAR_FUNCTIONS_"+GACTX.USER
Call LEC_TRACE From LECFIC
End

Funprog TESTSUITE_()
Callmet GACTX.ACTX_SET_LANISO("fr-FR")

Call TESTSUITE_START("FUNCTIONS", "FUNCTIONS") From AXUNIT
Call ADD_TESTCASE("TC_NUM","debug", 0) From AXUNIT


Local Clbfile  SUITE_RESULT
SUITE_RESULT = func AXUNIT.RUN_TESTSUITE("FUNCTIONS", "FUNCTIONS")
End SUITE_RESULT


Funprog TESTSUITE()
Callmet GACTX.ACTX_SET_LANISO("fr-FR")

Call TESTSUITE_START("FUNCTIONS", "FUNCTIONS") From AXUNIT
FUNNY

#Classic functions :
Call ADD_TESTCASE("TC_ABS", "Function abs()", 4) From AXUNIT
Call ADD_TESTCASE("TC_MOD", "Function mod()", 6) From AXUNIT
Call ADD_TESTCASE("TC_RND", "Function rnd()", 4) From AXUNIT
Call ADD_TESTCASE("TC_SGN", "Function sgn()", 3) From AXUNIT
Call ADD_TESTCASE("TC_SQR", "Function sqr()", 2) From AXUNIT

#Truncating functions :
Call ADD_TESTCASE("TC_AR2", "Function ar2()", 6) From AXUNIT
Call ADD_TESTCASE("TC_ARR", "Function arr()", 8) From AXUNIT
Call ADD_TESTCASE("TC_FIX", "Function fix()", 2) From AXUNIT
Call ADD_TESTCASE("TC_INT", "Function int()", 2) From AXUNIT

#String functions :
Call ADD_TESTCASE("TC_ASCII","Function ascii()", 4) From AXUNIT
Call ADD_TESTCASE("TC_LEN","Function len()", 5) From AXUNIT
#TODO Call ADD_TESTCASE("TC_PARSE","Function parse()", 2) From AXUNIT
Call ADD_TESTCASE("TC_PAT","Function pat()", 20) From AXUNIT
Call ADD_TESTCASE("TC_VAL","Function val()", 13) From AXUNIT

#Date functions :
Call ADD_TESTCASE("TC_DAY","Function day()", 5) From AXUNIT
Call ADD_TESTCASE("TC_DAYN","Function dayn()", 2) From AXUNIT
Call ADD_TESTCASE("TC_MONTH","Function month()", 3) From AXUNIT
Call ADD_TESTCASE("TC_NDAY","Function nday()", 3) From AXUNIT
Call ADD_TESTCASE("TC_WEEK","Function week()", 2) From AXUNIT
Call ADD_TESTCASE("TC_YEAR","Function year()", 2) From AXUNIT

#Operators :
Call ADD_TESTCASE("TC_AND","operator and",4) From AXUNIT
Call ADD_TESTCASE("TC_NOT","operator not",2) From AXUNIT
Call ADD_TESTCASE("TC_OR","operator or",4) From AXUNIT
Call ADD_TESTCASE("TC_XOR","operator xor",4) From AXUNIT
Call ADD_TESTCASE("TC_ADD","operator +",5) From AXUNIT
Call ADD_TESTCASE("TC_SUB","operator -",5) From AXUNIT
Call ADD_TESTCASE("TC_MUL","operator *",6) From AXUNIT
Call ADD_TESTCASE("TC_DIV","operator /",1) From AXUNIT
Call ADD_TESTCASE("TC_POW","operator ^",8) From AXUNIT

#Arithmetics functions
Call ADD_TESTCASE("TC_ANP","Function anp()",1) From AXUNIT
Call ADD_TESTCASE("TC_CNP","Function cnp()",1) From AXUNIT
Call ADD_TESTCASE("TC_FAC","Function fac()",1) From AXUNIT

#Statistics functions
Call ADD_TESTCASE("TC_AVG","Function avg()",3) From AXUNIT
Call ADD_TESTCASE("TC_FIND","Function find()",15) From AXUNIT
Call ADD_TESTCASE("TC_FIND_2","Function find() instances",15) From AXUNIT
Call ADD_TESTCASE("TC_MAX","Function max()",2) From AXUNIT
Call ADD_TESTCASE("TC_MIN","Function min()",3) From AXUNIT
Call ADD_TESTCASE("TC_PRD","Function prd()",2) From AXUNIT
Call ADD_TESTCASE("TC_SIGMA","Function sigma()",6) From AXUNIT
Call ADD_TESTCASE("TC_SUM","Function sum()",3) From AXUNIT
Call ADD_TESTCASE("TC_UNI","Function uni()",6) From AXUNIT
Call ADD_TESTCASE("TC_VAR","Function var()",3) From AXUNIT

#Trigonometric functions
Call ADD_TESTCASE("TC_COS","Function cos()",15) From AXUNIT
Call ADD_TESTCASE("TC_SIN","Function sin()",13) From AXUNIT
Call ADD_TESTCASE("TC_TAN","Function tan()",7) From AXUNIT
Call ADD_TESTCASE("TC_ACOS","Function acos()",1) From AXUNIT
Call ADD_TESTCASE("TC_ASIN","Function asin()",1) From AXUNIT
Call ADD_TESTCASE("TC_ATAN","Function atan()",1) From AXUNIT
Call ADD_TESTCASE("TC_ACH","Function ach()",2) From AXUNIT
Call ADD_TESTCASE("TC_ASH","Function ash()",2) From AXUNIT
Call ADD_TESTCASE("TC_ATH","Function ath()",2) From AXUNIT
Call ADD_TESTCASE("TC_CH","Function ch()",2) From AXUNIT
Call ADD_TESTCASE("TC_SH","Function sh()",2) From AXUNIT
Call ADD_TESTCASE("TC_TH","Function th()",3) From AXUNIT

#Logarithmic functions
Call ADD_TESTCASE("TC_EXP","Function exp()",2) From AXUNIT
Call ADD_TESTCASE("TC_LN","Function ln()",1) From AXUNIT
Call ADD_TESTCASE("TC_LOG","Function log()",2) From AXUNIT

#String functions
Call ADD_TESTCASE("TC_LEFT","Function left$()",1) From AXUNIT
Call ADD_TESTCASE("TC_MID","Function mid$()",1) From AXUNIT
Call ADD_TESTCASE("TC_RIGHT","Function right$()",1) From AXUNIT
Call ADD_TESTCASE("TC_SEG","Function seg$()",1) From AXUNIT

Call ADD_TESTCASE("TC_CTRANS","Function ctrans()",1) From AXUNIT
Call ADD_TESTCASE("TC_TOLOWER","Function tolower()",1) From AXUNIT
Call ADD_TESTCASE("TC_TOUPPER","Function toupper()",1) From AXUNIT
Call ADD_TESTCASE("TC_VIREBLC","Function vireblc()",6) From AXUNIT

Call ADD_TESTCASE("TC_CHR","Function chr()",1) From AXUNIT
Call ADD_TESTCASE("TC_SPACE","Function space()",1) From AXUNIT
Call ADD_TESTCASE("TC_STRING","Function string()",2) From AXUNIT
Call ADD_TESTCASE("TC_INSTR","Function instr()",1) From AXUNIT
Call ADD_TESTCASE("TC_COP","Function cop$",1) From AXUNIT
Call ADD_TESTCASE("TC_NUM","Function num$()",5) From AXUNIT
Call ADD_TESTCASE("TC_FORMAT","Function format$()",6) From AXUNIT
Call ADD_TESTCASE("TC_TRTCOU","Function trtcou",2) From AXUNIT
Call ADD_TESTCASE("TC_ADDMONTH","Function addmonth()",1) From AXUNIT
Call ADD_TESTCASE("TC_AWEEK","Function aweek()",1) From AXUNIT
Call ADD_TESTCASE("TC_EOMONTH","Function eomonth()",1) From AXUNIT
Call ADD_TESTCASE("TC_GDAT","Function gdat$()",2) From AXUNIT

Call ADD_TESTCASE("TC_DATE","Function date$",0) From AXUNIT
Call ADD_TESTCASE("TC_DIR","Function dir$",0) From AXUNIT
Call ADD_TESTCASE("TC_FILCOM","Function filcom()",0) From AXUNIT
Call ADD_TESTCASE("TC_FILPATH","Function filpath()",0) From AXUNIT
Call ADD_TESTCASE("TC_GETENV","Function getenv$()",0) From AXUNIT
Call ADD_TESTCASE("TC_MESS","Function mess()",0) From AXUNIT
Call ADD_TESTCASE("TC_TIME","Function time$",0) From AXUNIT
Call ADD_TESTCASE("TC_VER","Function ver$()",2) From AXUNIT
#TODO Call ADD_TESTCASE("TC_TIMESTAMP", "Function timestamp$",2) From AXUNIT

# Array Functions
Call ADD_TESTCASE("TC_DIM","Function dim()",11) From AXUNIT
Call ADD_TESTCASE("TC_MAXTAB","Function maxtab()",2) From AXUNIT

# Miscellaneous
Call ADD_TESTCASE("TC_KILL","Kill variables",14) From AXUNIT

Local Clbfile  SUITE_RESULT
SUITE_RESULT = func AXUNIT.RUN_TESTSUITE("FUNCTIONS", "FUNCTIONS")
End SUITE_RESULT

$ERROR
Call CHECK_EQUAL(errn, EX)
EX = 0
Resume

Subprog CHECK_EVAL(STR, RESULT)
Call CHECK_EQUAL(evalue(STR), RESULT)
End

Subprog CHECK_EQUAL(GOT, EXPECT)
Call CHECK_EQUAL(GOT, EXPECT) From AXUNIT
End

Subprog TC_ABS
Integer EX
Onerrgo ERROR
Call CHECK_EQUAL(abs(3), 3)
Call CHECK_EQUAL(abs(-3), 3)
Call CHECK_EQUAL(abs(0), 0)
EX = 10 : Call CHECK_EQUAL(abs('hello'), "!!!")
End

Subprog TC_MOD
Integer EX
Onerrgo ERROR
Call CHECK_EQUAL(mod(100,7) , 2)
Call CHECK_EQUAL(mod(-100,7), -2)
Call CHECK_EQUAL(mod(100,0), 100)
Call CHECK_EQUAL(mod(-100,0), -100)
Call CHECK_EQUAL(mod(100,-7), 2)
Call CHECK_EQUAL(mod(-100,-7), -2)
End

Subprog TC_RND
Integer EX
Local Decimal RESULT
Onerrgo ERROR
RESULT = rnd(10)
Call CHECK_EQUAL(evalue("(RESULT >= 0) AND (RESULT < 10)"),1)
RESULT = rnd(100)
Call CHECK_EQUAL(evalue("(RESULT >= 0) AND (RESULT < 100)"),1)
RESULT = rnd(-10)
Call CHECK_EQUAL(evalue("(RESULT <= 0) AND (RESULT > -10)"),1)
RESULT = rnd(-100)
Call CHECK_EQUAL(evalue("(RESULT <= 0) AND (RESULT > -100)"),1)
End

Subprog TC_SGN
Integer EX,RESULT
Onerrgo ERROR
Call CHECK_EQUAL(sgn(0), 0)
Call CHECK_EQUAL(sgn(3), 1)
Call CHECK_EQUAL(sgn(-3), -1)
End

Subprog TC_SQR
Integer EX,RESULT
Onerrgo ERROR
Call CHECK_EQUAL(sqr(9), 3)
Call CHECK_EQUAL(sqr(49), 7)
End

Subprog TC_AR2
Integer EX,RESULT
Onerrgo ERROR
Call CHECK_EQUAL(ar2(1.234), 1.23)
Call CHECK_EQUAL(ar2(1.235), 1.24)
Call CHECK_EQUAL(ar2(1.236), 1.24)
Call CHECK_EQUAL(ar2(-1.234), -1.23)
Call CHECK_EQUAL(ar2(-1.235), -1.24)
Call CHECK_EQUAL(ar2(-1.236), -1.24)
End

Subprog TC_ARR
Integer EX,RESULT
Onerrgo ERROR
Call CHECK_EQUAL(arr(1.236, 1), 1)
Call CHECK_EQUAL(arr(1.236, 0.01), 1.24)
Call CHECK_EQUAL(arr(1.236, 0.05), 1.25)
Call CHECK_EQUAL(arr(1.236, 0), 1.236)
Call CHECK_EQUAL(arr(-1.236, 1), -1)
Call CHECK_EQUAL(arr(-1.236, 0.01), -1.24)
Call CHECK_EQUAL(arr(-1.236, 0.05), -1.25)
Call CHECK_EQUAL(arr(-1.236, 0), -1.236)
End

Subprog TC_FIX
Integer EX,RESULT
Onerrgo ERROR
Call CHECK_EQUAL(fix(pi), 3)
Call CHECK_EQUAL(fix(-pi), -3)
End

Subprog TC_INT
Integer EX
Onerrgo ERROR
Call CHECK_EQUAL(int(pi) , 3)
Call CHECK_EQUAL(int(-pi), -4)
End

Subprog TC_ASCII
Integer EX
Onerrgo ERROR
Local Integer AINT
Call CHECK_EQUAL(ascii('a'), 97)
Call CHECK_EQUAL(ascii('z'), 122)

EX=10                 # Type incompatible
AINT = ascii(1)
EX=6                  # Non-existent variable
AINT=ascii(ABC)
End

Subprog TC_LEN
Integer EX
Onerrgo ERROR
Local Integer AINT
Call CHECK_EQUAL(len('a'), 1)
Call CHECK_EQUAL(len('ab'), 2)
Call CHECK_EQUAL(len('abcdef'), 6)

EX=10                 # Type incompatible
AINT = len(1)
EX=10
AINT = len(AINT)
End

Subprog TC_PARSE
Integer EX
Onerrgo ERROR
#TODO Call CHECK_EQUAL(parse('date$') , 0)
#TODO Call CHECK_EQUAL(parse('date$$'), 5)
End

Subprog TC_PAT
Integer EX
Onerrgo ERROR
#le caractère '*' représente un nombre quelconque, éventuellement nul, de caractères,
#le caractère '?' représente exactement un caractère,
#le caractère '#' représente un chiffre,
#le caractère '!' représente une lettre.
Call CHECK_EQUAL(pat('TC','*TC*') , 1)
Call CHECK_EQUAL(pat(' TC','*TC*'), 1)
Call CHECK_EQUAL(pat('TC ','*TC*'), 1)
Call CHECK_EQUAL(pat(' TC ','*TC*'), 1)
Call CHECK_EQUAL(pat('TC ','#TC'), 0)
Call CHECK_EQUAL(pat('TC ','1TC'), 0)
Call CHECK_EQUAL(pat('TC','##TC'), 0)
Call CHECK_EQUAL(pat('2TC','##TC'), 0)
Call CHECK_EQUAL(pat('23TC','##TC'), 1)
Call CHECK_EQUAL(pat('TC','TC##'), 0)
Call CHECK_EQUAL(pat('TC3','TC##'), 0)
Call CHECK_EQUAL(pat('TC34','TC##'), 1)
Call CHECK_EQUAL(pat('TC','!'), 0)
Call CHECK_EQUAL(pat('TC','!!'), 1)
Call CHECK_EQUAL(pat('T#','!!'), 0)
Call CHECK_EQUAL(pat('TC','!!!'), 0)
Call CHECK_EQUAL(pat('TC','?'), 0)
Call CHECK_EQUAL(pat('TC','??'), 1)
Call CHECK_EQUAL(pat('T#','??'), 1)
Call CHECK_EQUAL(pat('!TC5','?!!#'), 1)
End

Subprog TC_VAL
Call CHECK_EQUAL(val("3"), 3)
Call CHECK_EQUAL(val("-3"), -3)
Call CHECK_EQUAL(val("3.14"), 3.14)
Call CHECK_EQUAL(val("6.02e23"), 6.02E23)
Call CHECK_EQUAL(val("6.62e-34"), 6.62E-34)
Call CHECK_EQUAL(val("10E3"), 10000)
Call CHECK_EQUAL(val("1E37"), 1.00E37)
Call CHECK_EQUAL(val(sum("1", "2", "3")), 123)
Call CHECK_EQUAL(val("-111+a111"), -111)
Call CHECK_EQUAL(val(""), 0.0)
Call CHECK_EQUAL(val("    "), 0.0)
Call CHECK_EQUAL(val("."), 0.0)
Call CHECK_EQUAL(val(".00000"), 0.0)
End

Subprog TC_DAY
Call CHECK_EQUAL(day(gdat$(22,8,2011)), 22)
Call CHECK_EQUAL(day(gdat$(1,12,2013)), 1)
Call CHECK_EQUAL(day(gdat$(31,1,2014)), 31)
Call CHECK_EQUAL(day$(gdat$(22,8,2011)), "Lundi")
Call CHECK_EQUAL(day$(1), "Lundi")
End

Subprog TC_DAYN
Call CHECK_EQUAL(dayn(gdat$(21,8,2011)), 7)
Call CHECK_EQUAL(dayn(gdat$(22,8,2011)), 1)
End

Subprog TC_MONTH
Call CHECK_EQUAL(month(gdat$(22,8,2011)), 8)
Call CHECK_EQUAL(month$(gdat$(22,7,2011)), "Juillet")
Call CHECK_EQUAL(month$(7), "Juillet")
End

Subprog TC_NDAY
Call CHECK_EQUAL(nday(gdat$(4,1,1600)), 3)
Call CHECK_EQUAL(nday(gdat$(2,6,2014)), 151363)
Call CHECK_EQUAL(nday$(nday(date$)), date$)
End

Subprog TC_WEEK
Call CHECK_EQUAL(week(gdat$(21,8,2011)), 33)
Call CHECK_EQUAL(week(gdat$(22,8,2011)), 34)
End

Subprog TC_YEAR
Call CHECK_EQUAL(year(gdat$(22,8,2011)), 2011)
Call CHECK_EQUAL(year(date$) >= 2011, 1)
End

Subprog TC_AND
Call CHECK_EVAL("1 and 1", 1)
Call CHECK_EVAL("1 and 0", 0)
Call CHECK_EVAL("0 and 1", 0)
Call CHECK_EVAL("0 and 0", 0)
End

Subprog TC_NOT
Call CHECK_EVAL("not(1=1)", 0)
Call CHECK_EVAL("not(1=0)", 1)
End

Subprog TC_OR
Call CHECK_EVAL("1 or 1", 1)
Call CHECK_EVAL("1 or 0", 1)
Call CHECK_EVAL("0 or 1", 1)
Call CHECK_EVAL("0 or 0", 0)
End

Subprog TC_XOR
Call CHECK_EVAL("1 xor 1", 0)
Call CHECK_EVAL("1 xor 0", 1)
Call CHECK_EVAL("0 xor 1", 1)
Call CHECK_EVAL("0 xor 0", 0)
End

Subprog TC_ADD
Call CHECK_EQUAL(2+3, 5)
Call CHECK_EQUAL((2+3), 5)
Call CHECK_EQUAL('2'+'3', '23')
Call CHECK_EQUAL(gdat$(24,8,2011)+8, gdat$(1,9,2011))
Call CHECK_EQUAL(8+gdat$(24,8,2011), gdat$(1,9,2011))
End

Subprog TC_SUB
Call CHECK_EQUAL(2-3, -1)
Call CHECK_EQUAL('2'-'3', '2 3')
Call CHECK_EQUAL('2  '-'  3', '2 3')
Call CHECK_EQUAL(gdat$(1,9,2011)-8, gdat$(24,8,2011))
Call CHECK_EQUAL(gdat$(1,9,2011)-gdat$(24,8,2011), 8)
End

Subprog TC_MUL
Call CHECK_EQUAL(2*3, 6)
Call CHECK_EQUAL(2*(2+3), 10)
Call CHECK_EQUAL(2*3+4*5, 26)
Call CHECK_EQUAL(2*3-4*5, -14)
Call CHECK_EQUAL(2*(3+4)*5, 70)
Call CHECK_EQUAL(2*(3-4)*5, -10)
End

Subprog TC_DIV
Call CHECK_EQUAL(12/2, 6)
End

Subprog TC_POW
Integer EX
Onerrgo ERROR
Call CHECK_EQUAL(2^2, 4)
Call CHECK_EQUAL(2^4, 16)
Call CHECK_EQUAL(3^3, 27)
Call CHECK_EQUAL(2^-2, 0.25)
Call CHECK_EQUAL(2^-4, 0.0625)
Call CHECK_EQUAL(-(2^-2), -0.25)
Call CHECK_EQUAL(-(2^-4), -0.0625)
EX=53
Call CHECK_EQUAL(0^-3,53)             # Division by 0
Onerrgo
End

Subprog TC_ANP
Call CHECK_EQUAL(anp(7,3), 210)
End

Subprog TC_CNP
Call CHECK_EQUAL(cnp(7,3), 35)
End

Subprog TC_FAC
Call CHECK_EQUAL(fac(6), 720)
End

Subprog TC_AVG
Call CHECK_EQUAL(ar2(avg(3,5,2,7,9,8)), 5.67)
Call CHECK_EQUAL(ar2(avg(2,3,4,5,6,7)), 4.50)
Local Integer AI(1..),I
I+= 1 : AI(I) =  2
I+= 1 : AI(I) =  3
I+= 1 : AI(I) =  4
I+= 1 : AI(I) =  5
I+= 1 : AI(I) =  6
I+= 1 : AI(I) =  7
Call CHECK_EQUAL(ar2(avg(AI)), 4.50)
End

Subprog TC_FIND
Integer EX
Onerrgo ERROR
Call CHECK_EQUAL(find(2,3,5,2,7,9,8), 3)
Call CHECK_EQUAL(find(1,3,5,2,7,9,8), 0)
Call CHECK_EQUAL(find(8,3,5,2,7,9,8), 6)

Local Integer AI(1..6),I
I+= 1 : AI(I) =  3
I+= 1 : AI(I) =  5
I+= 1 : AI(I) =  2
I+= 1 : AI(I) =  7
I+= 1 : AI(I) =  9
I+= 1 : AI(I) =  8
Call CHECK_EQUAL(find(2,AI), 3)
Call CHECK_EQUAL(find(1,AI), 0)
Call CHECK_EQUAL(find(8,AI), 6)

Local Integer BI(1..)
I=  1 : BI(I) =  3
I+= 1 : BI(I) =  5
I+= 1 : BI(I) =  2
I+= 1 : BI(I) =  7
I+= 1 : BI(I) =  9
I+= 1 : BI(I) =  8
Call CHECK_EQUAL(find(2,BI), 3)
Call CHECK_EQUAL(find(1,BI), 0)
Call CHECK_EQUAL(find(8,BI), 6)

Local Integer CI(0..5)
I = 0 : CI(I) =  3
I+= 1 : CI(I) =  5
I+= 1 : CI(I) =  2
I+= 1 : CI(I) =  7
I+= 1 : CI(I) =  9
I+= 1 : CI(I) =  8
Call CHECK_EQUAL(find(2,CI), 3)
Call CHECK_EQUAL(find(1,CI), 0)
Call CHECK_EQUAL(find(8,CI), 6)

Local Integer DI(0..)
I = 0 : DI(I) =  3
I+= 1 : DI(I) =  5
I+= 1 : DI(I) =  2
I+= 1 : DI(I) =  7
I+= 1 : DI(I) =  9
I+= 1 : DI(I) =  8
Call CHECK_EQUAL(find(2,DI), 3)
Call CHECK_EQUAL(find(1,DI), 0)
Call CHECK_EQUAL(find(8,DI), 6)
End


Subprog TC_FIND_2
Integer EX
Onerrgo ERROR
Local Instance BPA(1..5) Using C_BPADDRESS
Local Integer I:I=0
Local Integer J
I += 1 : BPA(I) = NewInstance C_BPADDRESS : BPA(I).BPAADDFLG = I
I += 1 : BPA(I) = NewInstance C_BPADDRESS : BPA(I).BPAADDFLG = I
I += 1 : BPA(I) = NewInstance C_BPADDRESS : BPA(I).BPAADDFLG = I
I += 1 : BPA(I) = NewInstance C_BPADDRESS : BPA(I).BPAADDFLG = I
I += 1 : BPA(I) = NewInstance C_BPADDRESS : BPA(I).BPAADDFLG = I

For I=1 to maxtab(BPA)
 Call CHECK_EQUAL(BPA(I).BPAADDFLG, I)
 Call CHECK_EQUAL(find(I,BPA(1..5).BPAADDFLG),I)
 Call CHECK_EQUAL(find(I,BPA(1..maxtab(BPA)).BPAADDFLG),I)
Next I
End


Subprog TC_MAX
Call CHECK_EQUAL(max(3,5,2,7,9,8), 9)
Local Integer AI(1..),I :
I+= 1 : AI(I) =  3
I+= 1 : AI(I) =  5
I+= 1 : AI(I) =  2
I+= 1 : AI(I) =  7
I+= 1 : AI(I) =  9
I+= 1 : AI(I) =  8
Call CHECK_EQUAL(max(AI), 9)
End

Subprog TC_MIN
Call CHECK_EQUAL(min(3,5,2,7,9,8), 2)
Local Integer AI(1..),I :
I+= 1 : AI(I) =  3
I+= 1 : AI(I) =  5
I+= 1 : AI(I) =  2
I+= 1 : AI(I) =  7
I+= 1 : AI(I) =  9
I+= 1 : AI(I) =  8
Call CHECK_EQUAL(min(AI), 2)
I= 1 : AI(I)  =  -3
I+= 1 : AI(I) =  -5
I+= 1 : AI(I) =  -2
I+= 1 : AI(I) =  -7
I+= 1 : AI(I) =  -9
I+= 1 : AI(I) =  -8
Call CHECK_EQUAL(min(AI), -9)
End

Subprog TC_PRD
Call CHECK_EQUAL(prd(1,2,3,4,5), fac(5))
Local Integer AI(1..5),I :
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
Call CHECK_EQUAL(prd(AI), fac(5))
End

Subprog TC_SIGMA
Call CHECK_EQUAL(sigma(I=1, 10, I), 55)
Call CHECK_EQUAL(ar2(sigma(I=1, 120, 1/I^2)), ar2(pi^2/6))
Call CHECK_EQUAL(sigma( I = 1, 26, chr$(64+I)), "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
Call CHECK_EQUAL(sigma( I = 1, 7, I*I), 140)

Call CHECK_EQUAL(sigma( 1, 7, indcum    ), 28)
Call CHECK_EQUAL(sigma( 1, 7, indcum*indcum), 140)



Subprog TC_SUM
Call CHECK_EQUAL(sum(1,2,3,4,5,6,7), 28)
Local Integer AI(1..),I :
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
Call CHECK_EQUAL(sum(AI), 28)
Call CHECK_EQUAL(sum('TC','_','SUM'), "TC_SUM")
End

Subprog TC_UNI
Call CHECK_EQUAL(uni(1,2,3,4,5,6,7), 0)
Call CHECK_EQUAL(uni(1,1,3,4,5,6,7), 2)
Call CHECK_EQUAL(uni(1,2,1,4,5,6,7), 3)
Call CHECK_EQUAL(uni(1,2,3,4,5,6,1), 7)
Local Integer AI(1..),I :
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
Call CHECK_EQUAL(uni(AI), 0)
AI(4) = 1
Call CHECK_EQUAL(uni(AI), 4)
End

Subprog TC_VAR
Local Integer AI(1..),I :
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
I+= 1 : AI(I) =  I
Call CHECK_EQUAL(var(AI), 4)
Call CHECK_EQUAL(var(1,2,3,4,5,6,7), 4)
Call CHECK_EQUAL(var(5,10,15,20,25,30,35), 100)
End

Subprog TC_COS
Integer EX,RESULT
Onerrgo ERROR

# On calcul désormais en radians
[S]adxmda = 1
Call CHECK_EQUAL(ar2(pi), 3.14)
Call CHECK_EQUAL(cos(0), 1)
Call CHECK_EQUAL(cos(pi)  , -1)
Call CHECK_EQUAL(arr(cos(pi/2),10), 0)
Call CHECK_EQUAL(cos(pi/3), 0.5)
Call CHECK_EQUAL(cos(pi/4), sqr(2)/2)
Call CHECK_EQUAL(cos(pi/6), sqr(3)/2)

# On calcule désormais en degrés
[S]adxmda = 0
Call CHECK_EQUAL(cos(0) , 1)
Call CHECK_EQUAL(arr(cos(90),10), 0)
Call CHECK_EQUAL(cos(45), 0.7071067812 )
Call CHECK_EQUAL(cos(30), 0.8660254038 )

# On calcule désormais en grades
[S]adxmda = 2
Call CHECK_EQUAL(cos(0)    , 1)
Call CHECK_EQUAL(cos(100)  , 0)
Call CHECK_EQUAL(cos(50)  , 0.7071067812 )
Call CHECK_EQUAL(cos(100/3), 0.8660254038 )
End

Subprog TC_SIN
# On calcul désormais en radians
[S]adxmda = 1
Call CHECK_EQUAL(sin(0)   , 0)
Call CHECK_EQUAL(sin(pi/2)  , 1)
Call CHECK_EQUAL(sin(pi), 0)
Call CHECK_EQUAL(sin((3*pi)/2), -1)
Call CHECK_EQUAL(cos(pi/6)^2 + sin(pi/6)^2, 1)

# Degrees
[S]adxmda = 0
Call CHECK_EQUAL(sin(0)    , 0)
Call CHECK_EQUAL(sin(45) , 0.7071067812)
Call CHECK_EQUAL(sin(90)      , 1)
Call CHECK_EQUAL(sin(180), 0)

# Grades
[S]adxmda = 2
Call CHECK_EQUAL(sin(0)    , 0)
Call CHECK_EQUAL(sin(50), 0.7071067812)
Call CHECK_EQUAL(sin(100)     , 1)
Call CHECK_EQUAL(sin(200), 0)
End

Subprog TC_TAN
# On calcul désormais en radians
[S]adxmda = 1
Call CHECK_EQUAL(tan(0), 0)
Call CHECK_EQUAL(tan(pi/4), 1)
Call CHECK_EQUAL(tan(pi/6), sin(pi/6)/cos(pi/6))

# On calcul désormais en degrés
[S]adxmda = 0
Call CHECK_EQUAL(tan(0), 0)
Call CHECK_EQUAL(tan(45), 1)

# On calcul désormais en grades
[S]adxmda = 2
Call CHECK_EQUAL(tan(0), 0)
Call CHECK_EQUAL(tan(50), 1)
End

Subprog TC_ACH
Call CHECK_EQUAL(ach(1), 0)
Call CHECK_EQUAL(ach(ch(3)), 3)
End

Subprog TC_ASH
Call CHECK_EQUAL(ash(1), 0.881373587)
Call CHECK_EQUAL(ash(sh(3)), 3)
End

Subprog TC_ATH
Call CHECK_EQUAL(ath(0),0)
Call CHECK_EQUAL(ath(th(3)), 3)
End

Subprog TC_CH
Call CHECK_EQUAL(ch(1),1.543080635)
Call CHECK_EQUAL(ch(0), 1)
End

Subprog TC_SH
Call CHECK_EQUAL(sh(1),1.175201194)
Call CHECK_EQUAL(sh(0), 0)
End

Subprog  TC_TH
Call CHECK_EQUAL(th(1),0.761594156)
Call CHECK_EQUAL(th(0), 0)
Call CHECK_EQUAL(sh(3)/ch(3), th(3))
End


Subprog TC_ACOS
# On calcul désormais en radians
[S]adxmda = 1
Call CHECK_EQUAL(acos(cos(pi/6)), pi/6)
End

Subprog TC_ASIN
# On calcul désormais en radians
[S]adxmda = 1
Call CHECK_EQUAL(asin(sin(pi/6)), pi/6)
End

Subprog TC_ATAN
# On calcul désormais en radians
[S]adxmda = 1
Call CHECK_EQUAL(atan(tan(pi/6)), pi/6)
End

Subprog TC_EXP
Call CHECK_EQUAL(exp(0), 1)
Call CHECK_EQUAL(exp(1), 2.718281828)
End

Subprog TC_LN
Call CHECK_EQUAL(ln(exp(5)), 5)
End

Subprog TC_LOG
Call CHECK_EQUAL(log(10^3), 3)
Call CHECK_EQUAL(log(10^8), 8)
End

Subprog TC_LEFT
Call CHECK_EQUAL(left$('ABCDEFGH', 5), 'ABCDE')
End

Subprog TC_MID
Call CHECK_EQUAL(mid$('ABCDEFGH', 4, 3), 'DEF')
End

Subprog TC_RIGHT
Call CHECK_EQUAL(right$('ABCDEFGH', 4), 'DEFGH')
End

Subprog TC_SEG
Call CHECK_EQUAL(seg$('ABCDEFGH', 3, 7), 'CDEFG')
End

Subprog TC_CTRANS
Call CHECK_EQUAL(ctrans('He**o','*','l'),"Hello")
End

Subprog TC_TOLOWER
Call CHECK_EQUAL(tolower('Hello'), 'hello')
End

Subprog TC_TOUPPER
Call CHECK_EQUAL(toupper('Hello'), 'HELLO')
End

Subprog TC_VIREBLC
Call CHECK_EQUAL(vireblc(' a b  c ', 0), "a b  c ")
Call CHECK_EQUAL(vireblc(' a b  c ', 1), " a b  c")
Call CHECK_EQUAL(vireblc(' a b  c ', 2), "a b  c")
Call CHECK_EQUAL(vireblc(' a b  c ', 3), "a")
Call CHECK_EQUAL(vireblc(' a b  c ', 4), "abc")
Call CHECK_EQUAL(vireblc(' a b  c ', 5), " a b c ")
End

Subprog TC_CHR
Call CHECK_EQUAL(chr$(97), 'a')
End

Subprog TC_SPACE
Call CHECK_EQUAL(space$(3), "   ")
End

Subprog TC_STRING
Call CHECK_EQUAL(string$(3, 97), "aaa")
Call CHECK_EQUAL(string$(3, 'ab'), "ababab")
End

Subprog TC_INSTR
Call CHECK_EQUAL(instr(1, 'ABCDEF', 'CD'), 3)
End

Subprog TC_COP
Call CHECK_EQUAL(cop$,"ADONIX Copyright ADONIX Paris 1996")
End

Subprog TC_DIR
#TODO
End

Subprog TC_FILCOM
#TODO
End

Subprog TC_FILPATH
#TODO
End

Subprog TC_FORMAT
Integer EX
Onerrgo ERROR
Call CHECK_EQUAL(format$("N:9.2[ Euros]",0),"        0.00 Euros")
Call CHECK_EQUAL(format$("Kv0:20X"," A B C "),"A B C              ")
Call CHECK_EQUAL(format$("Kv1:20X"," A B C ")," A B C")
Call CHECK_EQUAL(format$("Kv5:20X"," A B C ")," A B C ")
Local Char OVERFLOW(1)
[L]OVERFLOW = mid$(adxsca,5,1)
Call CHECK_EQUAL(format$("N:6.2",1234567.12),string$(6,OVERFLOW)+"."+string$(2,OVERFLOW))
Call CHECK_EQUAL(format$("N:3.2",123.456),"123.45")
End

Subprog TC_GETENV
#TODO
End

Subprog TC_MESS
#TODO
End

Subprog TC_NUM
Call CHECK_EQUAL(num$(1), '1')
Call CHECK_EQUAL(num$(1.00E37), '1e37')
Call CHECK_EQUAL(num$(1E37), '1e37')
Call CHECK_EQUAL(num$(1.00E-37), '1e-37')
Call CHECK_EQUAL(num$(1E-37), '1e-37')
End

Subprog TC_TIME
#TODO
End

Subprog TC_TIMESTAMP
Local Integer ANDAYS,ATIMESTAMP_DAYS
Local Decimal ATIMESTAMPD

ATIMESTAMPD = val(timestamp$)
Call CHECK_NOTEQUAL(ATIMESTAMPD,0) From AXUNIT

ANDAYS = date$-[01/01/1970]
ATIMESTAMP_DAYS = ATIMESTAMPD/(3600*24*1000)
Call CHECK_EQUAL(ATIMESTAMP_DAYS,ANDAYS) From AXUNIT
End



Subprog TC_TRTCOU
Call CHECK_EQUAL(left$(trtcou,1),'@')
Call CHECK_NOTEQUAL(instr(1,trtcou,'/QLFAR_FUNCTIONS$adx'),0) From AXUNIT
End

Subprog TC_VER
Call CHECK_NOTEQUAL(vireblc(ver$(0),1),"") From AXUNIT # Not possible to predict version, check for non-blank
Call CHECK_EQUAL(ver$(1),"")
End

Subprog TC_ADDMONTH
Call CHECK_EQUAL(addmonth(gdat$(22,8,2011), 1), gdat$(22,9,2011))
End

Subprog TC_AWEEK
Call CHECK_EQUAL(aweek(34, 2011), gdat$(22,8,2011))
End

Subprog TC_DATE
#TODO
End

Subprog TC_EOMONTH
Call CHECK_EQUAL(eomonth(gdat$(22,8,2011)), gdat$(31,8,2011))
End

Subprog TC_GDAT
Call CHECK_EQUAL(gdat$(0,8,2011), gdat$(31,7,2011))
Call CHECK_EQUAL(gdat$(22,0,2011), gdat$(22,12,2010))
End


Subprog TC_DIM
Local Integer EX
Onerrgo ERROR

Call CHECK_EQUAL(dim(NO_VARIABLE),-1)

Local Char STR_ARRAY(10)
Call CHECK_EQUAL(dim(STR_ARRAY,0),1)
Call CHECK_EQUAL(dim(STR_ARRAY),1)

Local Integer INT_ARRAY(10,20,30,40)
Call CHECK_EQUAL(dim(INT_ARRAY,0),4)
Call CHECK_EQUAL(dim(INT_ARRAY),10)
Call CHECK_EQUAL(dim(INT_ARRAY,1),10)
Call CHECK_EQUAL(dim(INT_ARRAY,2),20)
Call CHECK_EQUAL(dim(INT_ARRAY,3),30)
Call CHECK_EQUAL(dim(INT_ARRAY,4),40)

Local Char STR_ARRAY(10)(1..)
Call CHECK_EQUAL(dim(STR_ARRAY),32767)

Local Decimal DEC_ARRAY(10,20)
EX = 50
Call CHECK_EQUAL(dim(DEC_ARRAY,3),50)
End

Subprog TC_KILL
Local Integer EX
Onerrgo ERROR

Local Char TMP1(10),TMP2(10)
Global Char GTMP1(10),GTMP2(10)
EX=1      # If on error signaled, EX will equal 0 on return
Kill TMP1,GTMP1
Call CHECK_EQUAL(1.2,1.2)

Kill [L]TMP2
Call CHECK_EQUAL(1.3,1.3)

Kill [V]GTMP2
Call CHECK_EQUAL(1.4,1.4)

EX=6
Kill TMP1
Call CHECK_EQUAL(1.5,1.5)

EX=6
Kill GTMP1
Call CHECK_EQUAL(1.6,1.6)

EX=6
Kill [L]TMP2
Call CHECK_EQUAL(1.7,1.7)

EX=6
Kill [V]GTMP2
Call CHECK_EQUAL(1.8,1.8)

Local Char TMP1(10),TMP2(10)
Kill [L]
Call CHECK_EQUAL(1.9,1.9)

EX=6
Kill [L]TMP1
Call CHECK_EQUAL(1.11,1.11)

End


Subprog TC_MAXTAB
Local Integer EX
Onerrgo ERROR

#TODO ? Call CHECK_EQUAL(maxtab(NO_VARIABLE),-1)

#TODO ? Local Char STR_VAR(10)
#TODO ? Call CHECK_EQUAL(maxtab(STR_VAR),1)

Local Integer INT_ARRAY(10,20,30,40)
INT_ARRAY(2,0,0,0)=10
INT_ARRAY(0,5,0,0)=30
Call CHECK_EQUAL(maxtab(INT_ARRAY),9)       # zero based array

Local Char STR_ARRAY(10)(1..)
STR_ARRAY(1000)="ABC"
Call CHECK_EQUAL(maxtab(STR_ARRAY),1000)
End

Funprog SQUARE(X)
 Variable Decimal X
End X^2
