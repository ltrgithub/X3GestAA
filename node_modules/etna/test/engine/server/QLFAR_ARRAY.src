#<AdxTL>@(#)0.0.0.0 $Revision$
Call OUVRE_TRACE("QLFAR_ARRAY") From LECFIC
Call TESTSUITE()

Call FERME_TRACE From LECFIC
GTRACE = "QLFAR_ARRAY_"+GACTX.USER
Call LEC_TRACE From LECFIC

End

Funprog TESTSUITE()
Local Integer NBTEST
NBTEST=68
If pat(ver$(0),"etna*")>0
 NBTEST+=46
Endif
Call ADD_TESTCASE("SIMPLE_TEST", "simple test", NBTEST) From AXUNIT


NBTEST=236
Call ADD_TESTCASE("SORT_TEST", "sort test", NBTEST) From AXUNIT

NBTEST=25
Call ADD_TESTCASE("INSERT_TEST", "insert test", NBTEST) From AXUNIT
Call ADD_TESTCASE("DELETE_TEST", "delete test", NBTEST) From AXUNIT

Local Clbfile  SUITE_RESULT
SUITE_RESULT = func AXUNIT.RUN_TESTSUITE("ARRAY", "ARRAY")
End SUITE_RESULT


Subprog CHECK_EQUAL(GOT, EXPECT,TEXT)
Call CHECK_EQUAL(TEXT+"...", TEXT+"...") From AXUNIT
Call CHECK_EQUAL(GOT, EXPECT) From AXUNIT
End

$ERROR
Call CHECK_EQUAL(errn, EX) From AXUNIT
EX = 0
Resume


$FILL
Global Char STRINGS(1)(10)
Global Integer INTS(10)
Global Char LETTERS, DIGITS, LSORT, LSORTS, DSORT, LBYD, DBYL, DBYL2,DBYL22,LSORTPART,ISORTPART
LETTERS = "DAAFBCBBAF"
DIGITS =  "5531244153"

LSORT =   "AAABBBCDFF"
LSORTD =  "FFDCBBBAAA"
DSORT =   "1123344555"
LBYD  =   "BFBAFBCAAD"
DBYL  =   "3551244513"
DBYL2 =   "3154142553"
DBYL22 =  "3154412355"
LSORTPART = "DAABBCFBAF"
ISORTPART = "5532441153"

For I = 0 To 9 : STRINGS(I) = mid$(LETTERS, I+1, 1) : INTS(I) = val(mid$(DIGITS, I+1, 1)) : Next I
Return

Funprog DUMP_S(AR,DIME_1,DIME)
 Variable Char AR()()
 Value Integer DIME_1,DIME
 Call CHECK_EQUAL("BEGIN DUMP_S", "BEGIN DUMP_S") From AXUNIT
 Call CHECK_EQUAL(dim(AR,-1), DIME_1) From AXUNIT
 Call CHECK_EQUAL(dim(AR,1), DIME) From AXUNIT
End sigma(dim(AR,-1), dim(AR,-1) + dim(AR,1) - 1, AR(indcum))

Funprog DUMP_I(AR,DIME_1,DIME)
 Variable Integer AR()
 Value Integer DIME_1,DIME
 Call CHECK_EQUAL("BEGIN DUMP_I", "BEGIN DUMP_I") From AXUNIT
 Call CHECK_EQUAL(dim(AR,-1), DIME_1) From AXUNIT
 Call CHECK_EQUAL(dim(AR,1), DIME) From AXUNIT
End sigma(dim(AR,-1), dim(AR,-1) + dim(AR,1) - 1, num$(AR(indcum)))

Subprog SLICE_NOBASE(S1, S2, I1, I2)
 Variable Char S1()(), S2()()
 Variable Integer I1(), I2()
    Call CHECK_EQUAL("BEGIN SLICE_NOBASE", "BEGIN SLICE_NOBASE") From AXUNIT
    Call CHECK_EQUAL(dim(STRINGS,-1), 0 ) From AXUNIT
    Call CHECK_EQUAL(dim(INTS,-1), 0 ) From AXUNIT
    Call CHECK_EQUAL(dim(S1,-1), 0 ,"Char slice 3..5 -> 0..")
    Call CHECK_EQUAL(dim(S2,-1), 0 ,"Char slice 3..9 -> 0..")
    Call CHECK_EQUAL(dim(I1,-1), 0 ,"Integer slice 3..5 -> 0..")
    Call CHECK_EQUAL(dim(I2,-1), 0 ,"Integer slice 3..9 -> 0..")
    Call CHECK_EQUAL(func DUMP_S(S1,0,3), mid$(LETTERS, 4, 3)) From AXUNIT
    Call CHECK_EQUAL(func DUMP_S(S2,0,7), right$(LETTERS, 4)) From AXUNIT
    Call CHECK_EQUAL(func DUMP_I(I1,0,3), mid$(DIGITS, 4, 3)) From AXUNIT
    Call CHECK_EQUAL(func DUMP_I(I2,0,7), right$(DIGITS, 4)) From AXUNIT
    Call CHECK_EQUAL("END SLICE_NOBASE", "END SLICE_NOBASE") From AXUNIT
End

Subprog SLICE_BASE(S1, S2)
 Variable Char S1()(1..), S2()(3..)
    Call CHECK_EQUAL("BEGIN SLICE_BASE", "BEGIN SLICE_BASE") From AXUNIT
    Call CHECK_EQUAL(dim(STRINGS,-1), 0 ) From AXUNIT
    Call CHECK_EQUAL(dim(S1,-1), 1,"Char slice 3..5 -> 1..")
    Call CHECK_EQUAL(dim(S2,-1), 3,"Char slice 3..9 -> 3..")

    #Error(69) - Mauvais nombre de param√®tres sur AXUNIT en X3 et pas en ETNA
    If pat(ver$(0),"etna*")<=0
     Call CHECK_EQUAL("Error(69)", "Error(69)") From AXUNIT
    Endif
    Local Integer EX : EX=69
    Onerrgo ERROR
    Call CHECK_EQUAL(func DUMP_S(S1,0,3), mid$(LETTERS, 4, 3), "Char slice 3..5 -> 1..") From AXUNIT
    Onerrgo

    Call CHECK_EQUAL(func DUMP_S(S1,0,3), mid$(LETTERS, 4, 3)) From AXUNIT
    Call CHECK_EQUAL(func DUMP_S(S2,0,7), right$(LETTERS, 4)) From AXUNIT
    Call CHECK_EQUAL(S1(1), mid$(LETTERS, 4, 1)) From AXUNIT
    Call CHECK_EQUAL(S1(3), mid$(LETTERS, 6, 1)) From AXUNIT
    Call CHECK_EQUAL(S2(3), mid$(LETTERS, 4, 1)) From AXUNIT
    Call CHECK_EQUAL(S2(9), mid$(LETTERS, 10, 1)) From AXUNIT
    Call CHECK_EQUAL("END SLICE_BASE", "END SLICE_BASE") From AXUNIT
End


Subprog SIMPLE_TEST()
    Gosub FILL
    Call CHECK_EQUAL(dim(STRINGS,-1), 0 ) From AXUNIT
    Call CHECK_EQUAL(dim(INTS,-1), 0 ) From AXUNIT
    Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), LETTERS) From AXUNIT
    Call CHECK_EQUAL(func DUMP_I(INTS,0,10), DIGITS) From AXUNIT

    #Error(8) - Indice incorrect
    If pat(ver$(0),"etna*")<=0
     Call CHECK_EQUAL("Error(8)", "Error(8)") From AXUNIT
    Endif
    Local Integer EX : EX=8
    Onerrgo ERROR
    Call SLICE_NOBASE(STRINGS(3..5), STRINGS(3..), INTS(3..5), INTS(3..))
    Onerrgo

    Call SLICE_NOBASE(STRINGS(3..5), STRINGS(3..9), INTS(3..5), INTS(3..9))

    #Error(8) - Indice incorrect
    If pat(ver$(0),"etna*")<=0
     Call CHECK_EQUAL("Error(8)", "Error(8)") From AXUNIT
    Endif
    Local Integer EX : EX=8
    Onerrgo ERROR
    Call SLICE_BASE(STRINGS(3..5), STRINGS(3..))
    Onerrgo

    Call SLICE_BASE(STRINGS(3..5), STRINGS(3..9))
    Call CHECK_EQUAL(dim(STRINGS,-1), 0 ) From AXUNIT
    Call CHECK_EQUAL(dim(INTS,-1), 0 ) From AXUNIT
End

Subprog SORT_BASE_VAL(S, I)
 Value Char S()(4..)
 Value Integer I(2..)
 Call CHECK_EQUAL("BEGIN SORT_BASE_VAL", "BEGIN SORT_BASE_VAL") From AXUNIT
    Call CHECK_EQUAL(dim(STRINGS,-1), 0 ) From AXUNIT
    Call CHECK_EQUAL(dim(INTS,-1), 0 ) From AXUNIT
    Call CHECK_EQUAL(dim(S,-1), 4 ,"Char slice -> 4..")
    Call CHECK_EQUAL(dim(I,-1), 2 ,"Integer slice -> 2..")

 Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), LETTERS, "NO Sorta S,D on globals")
 Call CHECK_EQUAL(func DUMP_I(INTS,0,10), DIGITS, "NO Sorta S,D on globals")
 Call CHECK_EQUAL(S(4), 'D', "S(4) indexing")
 Call CHECK_EQUAL(S(13), 'F', "S(13) indexing")
 Call CHECK_EQUAL(I(2), 5, "I(2) indexing")
 Call CHECK_EQUAL(I(11), 3, "I(11) indexing")
    Sorta S,I
    Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), LETTERS, "NO Sorta S,D on globals")
    Call CHECK_EQUAL(func DUMP_I(INTS,0,10), DIGITS, "NO Sorta S,D on globals")
    Call CHECK_EQUAL(func DUMP_S(S,0,10), LSORT, "Sorta S,D")
    Call CHECK_EQUAL(func DUMP_I(I,0,10), DBYL, "Sorta S,D")
 Call CHECK_EQUAL(S(4), 'A', "S(4) indexing")
 Call CHECK_EQUAL(S(13), 'F', "S(13) indexing")
 Call CHECK_EQUAL(I(2), 3, "I(2) indexing")
 Call CHECK_EQUAL(I(11), 3, "I(11) indexing")
    Sorta I,S
    Call CHECK_EQUAL(func DUMP_I(INTS,0,10), DIGITS, "NO Sorta D,S on globals")
    Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), LETTERS, "NO Sorta D,S on globals")
    Call CHECK_EQUAL(func DUMP_I(I,0,10), DSORT, "Sorta D,S")
    Call CHECK_EQUAL(func DUMP_S(S,0,10), LBYD, "Sorta D,S")
 Call CHECK_EQUAL(I(2), 1, "I(2) indexing")
 Call CHECK_EQUAL(I(11), 5, "I(11) indexing")
 Call CHECK_EQUAL("END SORT_BASE_VAL", "END SORT_BASE_VAL") From AXUNIT
End

Subprog SORT_BASE(S, I)
 Variable Char S()(4..)
 Variable Integer I(2..)
 Call CHECK_EQUAL("BEGIN SORT_BASE", "BEGIN SORT_BASE") From AXUNIT
    Call CHECK_EQUAL(dim(STRINGS,-1), 0 ) From AXUNIT
    Call CHECK_EQUAL(dim(INTS,-1), 0 ) From AXUNIT
    Call CHECK_EQUAL(dim(S,-1), 4 ,"Char slice -> 4..")
    Call CHECK_EQUAL(dim(I,-1), 2 ,"Integer slice -> 2..")

 Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), LETTERS, "NO Sorta S,D on globals")
 Call CHECK_EQUAL(func DUMP_I(INTS,0,10), DIGITS, "NO Sorta S,D on globals")
 Call CHECK_EQUAL(S(4), 'D', "S(4) indexing")
 Call CHECK_EQUAL(S(13), 'F', "S(13) indexing")
 Call CHECK_EQUAL(I(2), 5, "I(2) indexing")
 Call CHECK_EQUAL(I(11), 3, "I(11) indexing")
    Sorta S,I
    Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), LSORT, "Sorta S,D on globals")
    Call CHECK_EQUAL(func DUMP_I(INTS,0,10), DBYL, "Sorta S,D on globals")
    Call CHECK_EQUAL(func DUMP_S(S,0,10), LSORT, "Sorta S,D")
    Call CHECK_EQUAL(func DUMP_I(I,0,10), DBYL, "Sorta S,D")
 Call CHECK_EQUAL(S(4), 'A', "S(4) indexing")
 Call CHECK_EQUAL(S(13), 'F', "S(13) indexing")
 Call CHECK_EQUAL(I(2), 3, "I(2) indexing")
 Call CHECK_EQUAL(I(11), 3, "I(11) indexing")
    Sorta I,S
    Call CHECK_EQUAL(func DUMP_I(INTS,0,10), DSORT, "Sorta D,S on globals")
    Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), LBYD, "Sorta D,S on globals")
    Call CHECK_EQUAL(func DUMP_I(I,0,10), DSORT, "Sorta D,S")
    Call CHECK_EQUAL(func DUMP_S(S,0,10), LBYD, "Sorta D,S")
 Call CHECK_EQUAL(I(2), 1, "I(2) indexing")
 Call CHECK_EQUAL(I(11), 5, "I(11) indexing")
 Call CHECK_EQUAL("END SORT_BASE", "END SORT_BASE") From AXUNIT
End

Subprog SORTA_PART(S1, I1)
 Variable Char S1()()
 Variable Integer I1()
    Call CHECK_EQUAL("BEGIN SORTA_PART", "BEGIN SORTA_PART") From AXUNIT
    Sorta S1,I1
    Call CHECK_EQUAL(func DUMP_S(S1,0,5), mid$(LSORTPART,3,5), "Sorta partial S in function")
    Call CHECK_EQUAL(func DUMP_I(I1,0,5), mid$(ISORTPART,3,5), "Sorta partial I in function")
    Call CHECK_EQUAL("END SORTA_PART", "END SORTA_PART") From AXUNIT
End

Subprog SORT_TEST()
    Gosub FILL
    Sorta STRINGS,INTS
    Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), LSORT, "Sorta S,D")
    Call CHECK_EQUAL(func DUMP_I(INTS,0,10), DBYL, "Sorta S,D")
    Sorta STRINGS, INTS Order By STRINGS(indice) Desc
    Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), LSORTD, "Sorta S,D Order By S(indice) Desc")
    Call CHECK_EQUAL(func DUMP_I(INTS,0,10), func DUMP_I(INTS,0,10) , "Sorta S,D Order By S(indice) Desc")
    Call CHECK_EQUAL(func DUMP_I(INTS,0,10), func DUMP_I(INTS,0,10) , "(3154142553 or 3154412355)")
    Call CHECK_EQUAL(find(func DUMP_I(INTS,0,10),DBYL2,DBYL22)>0, 1 , "Res -> (3154142553 or 3154412355)")
    Sorta INTS,STRINGS
    Call CHECK_EQUAL(func DUMP_I(INTS,0,10), DSORT, "Sorta D,S")
    Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), LBYD, "Sorta D,S")
    Gosub FILL
    Call SORT_BASE(STRINGS, INTS)
    Gosub FILL
    Call SORT_BASE_VAL(STRINGS, INTS)
    Gosub FILL
    Sorta STRINGS(2..6),INTS(2..6)
    If pat(ver$(0),"etna*")>0
     Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), LSORTPART, "ETNA: Sorta partial S works in sorta")
     Call CHECK_EQUAL(func DUMP_I(INTS,0,10), ISORTPART, "ETNA: Sorta partial D works in sorta")
    Else
     Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), LSORT, "Sorta partial S doesn't work in sorta")
     Call CHECK_EQUAL(func DUMP_I(INTS,0,10), DBYL, "Sorta partial S doesn't work in sorta")
    Endif
    Gosub FILL
    Call SORTA_PART(STRINGS(2..6),INTS(2..6)) : #Sorta partial works through function
    Call CHECK_EQUAL(dim(STRINGS,-1), 0 ) From AXUNIT
    Call CHECK_EQUAL(dim(INTS,-1), 0 ) From AXUNIT
    Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), LSORTPART, "Sorta partial S works through function")
    Call CHECK_EQUAL(func DUMP_I(INTS,0,10), ISORTPART, "Sorta partial D works through function")
End

Subprog INSERT_TEST()
 Gosub FILL
 Insa 2, 3 STRINGS, INTS
 STRINGS(2) = 'X' : STRINGS(3) = 'Y' : STRINGS(4) = 'Z'
 Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), left$(LETTERS, 2)+"XYZ"+mid$(LETTERS, 3, 5), "Insa 2, 3 S")
 Call CHECK_EQUAL(func DUMP_I(INTS,0,10), left$(DIGITS, 2)+"000"+mid$(DIGITS, 3, 5), "Insa 2, 3 I")
 Gosub FILL
 Insa 2, 3, 7 STRINGS, INTS
 Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), left$(LETTERS, 2)+mid$(LETTERS, 3, 3) +right$(LETTERS, 9), "Insa 2, 3, 7 S")
 STRINGS(2) = 'X' : STRINGS(3) = 'Y' : STRINGS(4) = 'Z'
 Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), left$(LETTERS, 2)+"XYZ"+mid$(LETTERS, 3, 3) +right$(LETTERS, 9), "Insa 2, 3, 7 S")
 Call CHECK_EQUAL(func DUMP_I(INTS,0,10), left$(DIGITS, 2)+"000"+mid$(DIGITS, 3, 3) + right$(DIGITS, 9), "Insa 2, 3, 7 I")
End

Subprog DELETE_TEST()
 Gosub FILL
 Dela 2, 3 STRINGS, INTS
 STRINGS(7) = 'X' : STRINGS(8) = 'Y' : STRINGS(9) = 'Z'
 Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), left$(LETTERS, 2)+right$(LETTERS, 6)+"XYZ", "Dela 2, 3 S")
 Call CHECK_EQUAL(func DUMP_I(INTS,0,10), left$(DIGITS, 2)+right$(DIGITS, 6)+"000", "Dela 2, 3 I")
 Gosub FILL
 Dela 2, 3, 7 STRINGS, INTS
 Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), left$(LETTERS, 2)+mid$(LETTERS, 6, 3)+right$(LETTERS, 9), "Dela 2, 3, 7 S")
 STRINGS(5) = 'X' : STRINGS(6) = 'Y' : STRINGS(7) = 'Z'
 Call CHECK_EQUAL(func DUMP_S(STRINGS,0,10), left$(LETTERS, 2)+mid$(LETTERS, 6, 3)+"XYZ"+right$(LETTERS, 9), "Dela 2, 3, 7 S")
 Call CHECK_EQUAL(func DUMP_I(INTS,0,10), left$(DIGITS, 2)+mid$(DIGITS, 6, 3)+"000"+right$(DIGITS, 9), "Dela 2, 3, 7 I")
End
