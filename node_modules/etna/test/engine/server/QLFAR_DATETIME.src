Local Clbfile RESULT
RESULT=func TESTSUITE()
Call FERME_TRACE From LECFIC
GTRACE = "QLFAR_DATETIME_"+GACTX.USER
Call LEC_TRACE From LECFIC
End


#**
#* The main entry point of the unit test suite for Requirement 69072
#*
#* @see
#* <a href="http://dotat.at/tmp/ISO_8601-2004_E.pdf">International standart for representation of date and time </a>
#*!
Funprog TESTSUITE()
Call ADD_TESTCASE("TC_DECL", "DECL-Datetime declaration", 2) From AXUNIT
Call ADD_TESTCASE("TC_GDATETIME", "GDATETIME$ -Function ", 13) From AXUNIT
Call ADD_TESTCASE("TC_DATETIME", "DATETIME$-Function", 3) From AXUNIT
Call ADD_TESTCASE("TC_NUM", "NUM$-Function", 1) From AXUNIT
Call ADD_TESTCASE("TC_OP_COMP", "OP_COMP-Comparison of datetimes", 9) From AXUNIT
Call ADD_TESTCASE("TC_OP_OPERATIONS", "OP_OPERATIONS operations on datetimes", 7) From AXUNIT
Call ADD_TESTCASE("TC_OP_LOGICAL", "OP_LOGICAL-Logical operations on datetimes", 4) From AXUNIT

Call ADD_TESTCASE("TC_NDAY", "'NDAY' - Number of days since 01/01/1600",2) From AXUNIT
Call ADD_TESTCASE("TC_ADDMONTH", "'ADDMONTH' - Add month to date",5) From AXUNIT
Call ADD_TESTCASE("TC_EOMONTH", "'EOMONTH' - Date of last day of month ",3) From AXUNIT
Call ADD_TESTCASE("TC_DAY", "'DAY$' - Day of week",8) From AXUNIT
Call ADD_TESTCASE("TC_MONTH", "'MONTH' - Returns month number",12) From AXUNIT
Call ADD_TESTCASE("TC_MONTHNAM", "'MONTH$'- Month name",12) From AXUNIT
Call ADD_TESTCASE("TC_WEEK", "'WEEK' - Calculate week number based on date",2) From AXUNIT
Call ADD_TESTCASE("TC_YEAR", "'YEAR' - Calculate year based on date",3) From AXUNIT
Call ADD_TESTCASE("TC_MIN", "'MIN' - Find minimum date in a collection of dates", 2) From AXUNIT
Call ADD_TESTCASE("TC_MAX", "'MAX' - Find max date in a collection of dates", 2) From AXUNIT
Call ADD_TESTCASE("TC_FIND", "'FIND' - Find date in a collection of dates", 2) From AXUNIT
Call ADD_TESTCASE("TC_UNI", "'UNI' - Determine if date is a unique date in a collection of dates", 2) From AXUNIT


End func AXUNIT.RUN_TESTSUITE("REQ-69072", "Datetime GMT")

$ERROR
Call CHECK_EQUAL(errn, EX) From AXUNIT
EX = 0
Resume


Subprog TC_DECL
Integer EX
Onerrgo ERROR
Local Datetime MYDATE

Call CHECK_NOTEQUAL(dim(MYDATE),-1) From AXUNIT
Call CHECK_EQUAL(type(MYDATE),526) From AXUNIT

End

Subprog TC_GDATETIME
Integer EX
Onerrgo ERROR

Local Datetime MYDATE
Local Date MYD
Local Char ONLYDATE(20) : ONLYDATE="2011-12-05"
Local Char ONLYDATEZ(20) : ONLYDATEZ="2011-12-05"+"Z"
Local Char ONLYTIME(20) : ONLYTIME="09:30:15Z"
Local Char COMPLETEDATE(20) : COMPLETEDATE="2011-12-05T09:30:15Z"
Local Char BADDATE(20)
Local Char GOT(25)
Local Char EXPECT(25)

#Date nulle
MYDATE=gdatetime$("")
GOT=num$(MYDATE)
EXPECT="0000-00-00T00:00:00Z"
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT

EXPECT=ONLYDATE+"T00:00:00"+"Z"
MYDATE=gdatetime$(ONLYDATE)
GOT= num$(MYDATE)
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT


EXPECT=ONLYDATE+"T00:00:00"+"Z"
MYDATE=gdatetime$(ONLYDATEZ)
GOT= num$(MYDATE)
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT

EXPECT=COMPLETEDATE
MYDATE=gdatetime$(COMPLETEDATE)
GOT= num$(MYDATE)
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT

BADDATE="2011-15-05T09:30:15Z"
EXPECT="0000-00-00T00:00:00Z"

MYDATE=gdatetime$(BADDATE)
GOT= num$(MYDATE)
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT

BADDATE="15-05-2011T09:30:15Z"

MYDATE=gdatetime$(BADDATE)
GOT= num$(MYDATE)
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT


BADDATE="n'importequoi"
MYDATE=gdatetime$(BADDATE)
GOT= num$(MYDATE)
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT

MYDATE=gdatetime$([01/02/2100])
GOT=num$(MYDATE)
EXPECT="2100-02-01T00:00:00Z"
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT

MYDATE=gdatetime$([01/01/1600])
GOT=num$(MYDATE)
EXPECT="1600-01-01T00:00:00Z"
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT

MYD=[01/01/1600]
MYDATE=gdatetime$(MYD)
GOT=num$(MYDATE)
EXPECT="1600-01-01T00:00:00Z"
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT

MYD=[01/01/1600]-1
MYDATE=gdatetime$(MYD)
GOT=num$(MYDATE)
EXPECT="0000-00-00T00:00:00Z"
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT

EX = 56
MYD=[01/01/1600]-5

EX = 56
MYDATE=gdatetime$([01/01/1600]-5)
End

Subprog TC_DATETIME
Integer EX
Onerrgo ERROR

Local Datetime CURRENTDTM
Local Char DATETMSTR(25)

CURRENTDTM=datetime$
DATETMSTR=num$(CURRENTDTM)
Local Char TOKEN(10)

Local Integer DATETMY, DATETMM, DATETMD, DATEY, DATEM, DATED

TOKEN=left$(DATETMSTR,4)
Local Integer DATETMY
DATETMY=val(TOKEN)
TOKEN=mid$(DATETMSTR,6,2)
DATETMM=val(TOKEN)
TOKEN=mid$(DATETMSTR,9,2)
DATETMD=val(TOKEN)

Local Date TODAY
Local Char TODAYSTR(20)
TODAY=date$
TODAYSTR=num$(TODAY)

Local Integer DATEY
DATEY=year(TODAY)
Local Integer DATEM
DATEM=month(TODAY)
Local Integer DATED
DATED=day(TODAY)
Local Integer GOT
GOT=evalue("DATETMY=DATEY | DATETMY=DATEY+1 | DATETMY=DATEY-1")
Call CHECK_TRUE(GOT) From AXUNIT
GOT=evalue("DATETMM=DATEM | DATETMM=DATEM+1 | DATETMM=DATEM-1")
Call CHECK_TRUE (GOT) From AXUNIT
GOT=evalue("DATETMD=DATED | DATETMD=DATED+1 | DATETMD=DATED-1")
Call CHECK_TRUE (GOT) From AXUNIT



End

Subprog TC_NUM
Integer EX
Onerrgo ERROR

Local Datetime MYDATETM
Local Char DATETMSTR(25)
MYDATETM=datetime$
DATETMSTR=num$(MYDATETM)
Local Integer GOT,EXPECT
EXPECT=1 #pat retourne 1 si la chaîne est conforme au modèle
GOT=pat(DATETMSTR,"####-##-##T##:##:##Z")
Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT
End



Subprog TC_OP_COMP
Integer EX
Onerrgo ERROR

Local Datetime DATE1,DATE2

DATE1=gdatetime$("2012-01-01T05:07:08Z")
DATE2=gdatetime$("2012-02-01T05:07:08Z")
Call CHECK_TRUE(DATE1=DATE1) From AXUNIT
Call CHECK_TRUE(DATE2<>DATE1) From AXUNIT
Call CHECK_TRUE(DATE1<>DATE2) From AXUNIT
Call CHECK_TRUE(DATE2>DATE1) From AXUNIT
Call CHECK_TRUE(DATE1<DATE2) From AXUNIT
Call CHECK_TRUE(DATE2>=DATE1) From AXUNIT
Call CHECK_TRUE(DATE2>=DATE2) From AXUNIT
Call CHECK_TRUE(DATE1<=DATE1) From AXUNIT
Call CHECK_TRUE(DATE1<=DATE2) From AXUNIT

End

Subprog TC_OP_OPERATIONS
Integer EX
Onerrgo ERROR

Local Datetime DATE1,DATE2

#Operation not allowed :
EX=10
DATE1=gdatetime$("2012-01-01T05:07:08Z")
DATE1 += 1
#Operation not allowed :
EX=10
DATE1=gdatetime$("2012-01-01T05:07:08Z")
DATE1 -= 1
#Operation not allowed :
EX=10
DATE1=gdatetime$("2012-01-01T05:07:08Z")
DATE1 *= 1
#Operation not allowed :
EX=10
DATE1=gdatetime$("2012-01-01T05:07:08Z")
DATE1 /= 1
#Operation not allowed :
EX=10
DATE1=gdatetime$("2012-01-01T05:07:08Z")
DATE1 =mod(DATE1,1)
#Operation not allowed :
EX=10
DATE1=gdatetime$("2012-01-01T05:07:08Z")
DATE1 =DATE1^2
#Operation not allowed :
EX=10
DATE1=abs(DATE1)
End

Subprog TC_OP_LOGICAL
Integer EX
Onerrgo ERROR

Local Datetime DATE1
Local Integer RESULT

DATE1=gdatetime$("2012-01-01T05:07:08Z")
#Operation not allowed :
EX=10
RESULT = DATE1 and DATE1
#Operation not allowed :
EX=10
RESULT = DATE1 or DATE1
#Operation not allowed :
EX=10
RESULT = DATE1 xor DATE1
#Operation not allowed :
EX=10
RESULT = !DATE1

End

Subprog TC_YEAR
Integer EX
Onerrgo ERROR
Local Datetime MYDATE
Local Integer GOT_INT,EXP_INT
Local Char COMPLETEDATE(20) : COMPLETEDATE="2011-12-05T09:30:15Z"

GOT_INT = year(MYDATE)
EXP_INT = 0
Call CHECK_EQUAL(GOT_INT,EXP_INT) From AXUNIT

MYDATE=gdatetime$(COMPLETEDATE)

GOT_INT = year(MYDATE)
EXP_INT = 2011
Call CHECK_EQUAL(GOT_INT,EXP_INT) From AXUNIT

GOT_INT = year(datetime$)
EXP_INT = year(date$)
Call CHECK_EQUAL(GOT_INT,EXP_INT) From AXUNIT

End


Subprog TC_MIN
Integer EX
Onerrgo ERROR
Local Datetime MYDATE(10), GOT_DATE, EXP_DATE
Local Integer I, GOT_INT, EXP_INT

For I=0 To 4
  MYDATE(I)=gdatetime$(date$+I)
Next

For I=5 To 9
MYDATE(I)=gdatetime$(date$-I)
Next

EX=50
GOT_DATE=min(datetime$,datetime$)
EX=50
GOT_DATE=min(MYDATE(0..dim(MYDATE)-1))

End

Subprog TC_MAX
Integer EX
Onerrgo ERROR
Local Datetime MYDATE(10), GOT_DATE, EXP_DATE
Local Integer I, GOT_INT, EXP_INT

For I=0 To 4
  MYDATE(I)=gdatetime$(date$+I)
Next

For I=5 To 9
MYDATE(I)=gdatetime$(date$-I)
Next

EX=50
GOT_DATE=max(datetime$,datetime$)
EX=50
GOT_DATE=max(MYDATE)

End

Subprog TC_FIND
Integer EX
Onerrgo ERROR
Local Datetime MYDATE(10),FIND_DATE
Local Integer I, GOT_INT, EXP_INT

For I=0 To 4
  MYDATE(I)=gdatetime$(date$+I)
Next

For I=5 To 9
MYDATE(I)=gdatetime$(date$-I)
Next

FIND_DATE=gdatetime$(date$+3)
GOT_INT=find(FIND_DATE,MYDATE)
EXP_INT=4
Call CHECK_EQUAL(GOT_INT,EXP_INT) From AXUNIT

FIND_DATE=gdatetime$(date$+20)
GOT_INT=find(FIND_DATE,MYDATE)
EXP_INT=0
Call CHECK_EQUAL(GOT_INT,EXP_INT) From AXUNIT

End

Subprog TC_UNI
Integer EX
Onerrgo ERROR
Local Datetime MYDATE(10),FIND_DATE
Local Integer I, GOT_INT, EXP_INT

For I=0 To 4
  MYDATE(I)=gdatetime$(date$+I)
Next

For I=5 To 9
MYDATE(I)=gdatetime$(date$-I)
Next

GOT_INT=uni(MYDATE)
EXP_INT=0
Call CHECK_EQUAL(GOT_INT,EXP_INT) From AXUNIT

For I=5 To 9
MYDATE(I)=gdatetime$(date$)
Next

GOT_INT=uni(MYDATE)
EXP_INT=6
Call CHECK_EQUAL(GOT_INT,EXP_INT) From AXUNIT

End




Subprog TC_DAY
Integer EX
Onerrgo ERROR

Local Datetime GOT_DATE,EXP_DATE
Local Datetime MYDATE
Local Char BADDATE(10)
Local Char GOT(25)
Local Char EXPECT(25)

For I=1 To 7
  EXPECT = mess(I,742,1)
  EX=10
  GOT = day$(gdatetime$([02/01/1600]+I))
  #Call CHECK_EQUAL(GOT,EXPECT) From AXUNIT
Next


EX=56
GOT=day$(gdatetime$(date$+5000000))

End

Subprog TC_WEEK
Integer EX
Onerrgo ERROR

Local Integer GOT_INT,EXP_INT
Local Datetime MYDATE
Local Char GOT(25)
Local Char EXPECT(25)

GOT_INT = week(gdatetime$([30/12/2013]))
EXP_INT = 53                                   # Monday of first week of 2014
Call CHECK_EQUAL(GOT_INT,EXP_INT) From AXUNIT

GOT_INT = week( gdatetime$([29/12/2012] ))
EXP_INT = 52                       # Monday of first week of 2014
Call CHECK_EQUAL(GOT_INT,EXP_INT) From AXUNIT

End


Subprog TC_MONTH
Integer EX
Onerrgo ERROR

Local Integer I,MONTH_NUM
Local Datetime GOT_DATE,EXP_DATE
Local Datetime MYDATE
Local Char GOT(25)
Local Char EXPECT(25)

For I=1 To 12
MONTH_NUM= month(gdatetime$(gdat$(1,I,2014)))
Call CHECK_EQUAL(MONTH_NUM,I) From AXUNIT
Next

End



Subprog TC_MONTHNAM
Integer EX
Onerrgo ERROR

Local Integer I
Local Datetime GOT_DATE,EXP_DATE
Local Datetime MYDATE
Local Char MONTH_NAM(25)
Local Char GOT(25)
Local Char EXPECT(25)

For I=1 To 12
EX=10
MONTH_NAM= month$(gdatetime$(gdat$(1,I,2014)))
#Call CHECK_EQUAL(MONTH_NAM,mess(I,9001,1)) From AXUNIT
Next



End


Subprog TC_ADDMONTH
Integer EX
Onerrgo ERROR

Local Datetime GOT_DATE,EXP_DATE
Local Datetime MYDATE
Local Char BADDATE(10)
Local Char GOT(25)
Local Char EXPECT(25)

GOT_DATE = addmonth(gdatetime$([31/01/2014]),1)
EXP_DATE = gdatetime$([28/02/2014])
Call CHECK_EQUAL(GOT_DATE,EXP_DATE) From AXUNIT

GOT_DATE = addmonth(gdatetime$([31/01/2014]),2)
EXP_DATE = gdatetime$([31/03/2014])
Call CHECK_EQUAL(GOT_DATE,EXP_DATE) From AXUNIT

GOT_DATE = addmonth(gdatetime$([31/03/2014]),-2)
EXP_DATE = gdatetime$([31/01/2014])
Call CHECK_EQUAL(GOT_DATE,EXP_DATE) From AXUNIT

EX=56
GOT_DATE = addmonth(gdatetime$([31/01/2014]),-5000)

EX=56
GOT_DATE = addmonth(gdatetime$([31/01/2014]),150000)
End

Subprog TC_EOMONTH
Integer EX
Onerrgo ERROR

Local Datetime GOT_DATE,EXP_DATE
Local Datetime MYDATE
Local Char BADDATE(10)
Local Char GOT(25)
Local Char EXPECT(25)

GOT_DATE = eomonth(gdatetime$([01/02/1900]))        # Not a leap year because year ends 00 (hundred years)
EXP_DATE = gdatetime$([28/02/1900])
Call CHECK_EQUAL(GOT_DATE,EXP_DATE) From AXUNIT

GOT_DATE = eomonth(gdatetime$([01/02/2000]))        # Is a leap year because 400 year increment
EXP_DATE = gdatetime$([29/02/2000])
Call CHECK_EQUAL(GOT_DATE,EXP_DATE) From AXUNIT


GOT_DATE = eomonth(gdatetime$([01/02/2100]))        # Not a leap year because year ends 00 (hundred years)
EXP_DATE = gdatetime$([28/02/2100])
Call CHECK_EQUAL(GOT_DATE,EXP_DATE) From AXUNIT
End


Subprog TC_NDAY
Integer EX
Onerrgo ERROR
Local Datetime MYDATE
Local Integer DAYS,GOT_INT,EXPECT_INT
Local Char GOT(25)
Local Char EXPECT(25)

MYDATE=gdatetime$([01/02/2100])
EX=10
DAYS = nday(MYDATE)
EXPECT_INT= 3068036
GOT_INT = DAYS
#Call CHECK_EQUAL(GOT_INT,EXPECT_INT) From AXUNIT

EX=10
DAYS = nday(datetime$)
End
