@STRICT

Call OUVRE_TRACE("QLFAR_CONTEXT") From LECFIC
Call TESTSUITE()
Call FERME_TRACE From LECFIC

Global Char GTRACE
GTRACE = "QLFAR_CONTEXT_"+GACTX.USER
Call LEC_TRACE From LECFIC
End

$ERROR
Call CHECK_EQUAL(errn, EX) From AXUNIT
Resume

Funprog TESTSUITE()
Call TESTSUITE_START("X3SON", "X3SON") From AXUNIT

Call ADD_TESTCASE("TC_BASIC", "TC_BASIC", 20) From AXUNIT

Local Clbfile  SUITE_RESULT
SUITE_RESULT = func AXUNIT.RUN_TESTSUITE("X3SON", "X3SON")
End SUITE_RESULT

Subprog FAIL(STR)
	Value Clbfile STR
	Local Integer DUMMY
	Infbox STR
	Call CHECK_NOTEQUAL(STR,"") From AXUNIT
	DUMMY = evalue("1/0")
End

Funprog TYPE_LETTER(T)
	If T >= 10 and T <= 265 : End "S": Endif 
	Case T
	When 3 : End "D"
	When 4 : End "I"
	When 6 : End "F"
	When 7 : End "N"
	When 40 : End "S"
	When 523 : End "C"
	When 524 : End "O"
	When 525 : End "U"
	When 526 : End "T"
	When Default : Call FAIL("bad type" - num$(T))
	Endcase
End ""

#Funprog SKIP_PROP(NAME)
#End find(NAME, "CREDATTIM", "UPDDATTIM", "CREUSR", "UPDUSR", "CREDAT", "UPDDAT") <> 0

Funprog SKIP_PROP(NAME)
End find(NAME, "AATTRIBUTES", "ACACHE", "ACCESS", "ACTX", "AERROR", "AINF", "_AINFOS","_AINSPTH", "AKEYS", "AORDER", "APARENT", "ASTALIN", "AUUID", "CREDAT", "CREDATTIM", "CREUSR", "ENAFLG", "EXPNUM",
& "MODULE",
& "UPDDAT","UPDDATTIM", "UPDUSR" ) <> 0

Funprog FORMAT_INSTANCE(V)
	Local Clbfile S()
	Local Integer N
	Local Char PNAME()
	Local Any PVAL
	Local Integer PTYPE, PDIM
	S = "!" + V.ObjectType + "{"
	N = V.ObjectNbs
	For J = 1 To N
		PNAME = V.objectvar(J)
		PVAL = evalue("V." + PNAME)
		PTYPE = evalue("type(V.CRY)")
		PTYPE = evalue("type(V." + PNAME + ")")
		PDIM = evalue("dim(V." + PNAME + ")")
		If PTYPE <> -1 and not func SKIP_PROP(PNAME)
			S += PNAME + ":" + func STRINGIFY(PVAL, PDIM, PTYPE)
		Endif
	Next J
	S += "}"
End S

Funprog FORMAT_VALUE(LETTER, V)
	Case LETTER
	When "D" : End format$("D:YYYY[-]MM[-]DD",V)
	When "I", "F", "N", "T" : End num$(V)
	When "S", "C" : End num$(len(V)) + '!' + V
	When "O" : End func FORMAT_INSTANCE(V)
	When Default : Call FAIL("bad type letter" - LETTER)
	Endcase
End ""

Funprog STRINGIFY(V, D, T)
	Local Clbfile RESULT
	Local Char LETTER(1)
	LETTER = func TYPE_LETTER(T)
	RESULT += LETTER
	If (D > 1) 
		RESULT += "["
		For I = 1 To maxtab(V)
			RESULT += func FORMAT_VALUE(LETTER, V(I)) + ";"
		Next I
		RESULT += "];"
	Else 
		RESULT += func FORMAT_VALUE(LETTER, V) + ";"
	Endif
End RESULT

Subprog EAT(STR, POS, C)
	Value Clbfile STR
	Variable Integer POS
	Value Char C()
	If mid$(STR, POS, 1) <> C
		Call FAIL("expected " + C + " got" - mid$(STR, POS, 1))
	Endif
	POS += 1
End

Subprog PARS_PROPS(STR, POS, INST)
	Value Clbfile STR
	Variable Integer POS
	Local Char C(1)
	Local Any RESULT(0..)
	Local Integer I
	Local Char CLNAME(), PROPNAME()
	Local Any PROPVAL
	While (POS < len(STR) and mid$(STR, POS, 1) <> '}')
		I = instr(POS, STR, ":")
		If I <= POS
			Call FAIL("missing : after property name")
		Endif
		PROPNAME = mid$(STR, POS, I - POS)
		POS = I + 1
		PROPVAL = func PARS_ONE(STR, POS)
		Assign "INST." + PROPNAME With PROPVAL
	Wend
	Call EAT(STR, POS, "}")
End

Funprog PARS_ONE(STR, POS)
	Value Clbfile STR
	Variable Integer POS
	Local Char LETTER(1)
	Local Integer I, LENG
	Local Integer R_INT(0..)
	Local Decimal R_DEC(0..)
	Local Double R_DBL(0..)
	Local Char R_CHAR()(0..)
	Local Clbfile R_CLB()(0..)
	Local Date R_DATE(0..)
	Local Datetime R_DATIM(0..)
	Local Integer IS_ARRAY
	Local Integer IDX
	Local Any RESULT

	If POS >= len(STR)
		Call FAIL("invalid POS" - num$(POS))
	Endif
	LETTER = mid$(STR, POS, 1)
	POS += 1
	If mid$(STR, POS, 1) = "["
		IS_ARRAY = 1
		POS += 1
	Else
		IS_ARRAY = 0
	Endif
	IDX = 1
	While 1
		Case LETTER
		When "Z"
			RESULT = AVOID.AINS
		When "I"
			If IDX = 1 : RESULT = R_INT : Endif
			I = instr(POS, STR, ";")
			RESULT(IDX) = val(mid$(STR, POS, I - POS))
			POS = I
		When "F"
			If IDX = 1 : RESULT = R_DBL : Endif
			I = instr(POS, STR, ";")
			RESULT(IDX) = val(mid$(STR, POS, I - POS))
			POS = I
		When "N"
			If IDX = 1 : RESULT = R_DEC : Endif
			I = instr(POS, STR, ";")
			RESULT(IDX) = val(mid$(STR, POS, I - POS))
			POS = I
		When 'S'
			If IDX = 1 : RESULT = R_CHAR : Endif
			I = instr(POS, STR, "!")
			LENG = val(mid$(STR, POS, I))
			RESULT(IDX) = mid$(STR, I + 1, LENG)
			POS = I + 1 + LENG
		When 'C'
			If IDX = 1 : RESULT = R_CLB : Endif
			I = instr(POS, STR, "!")
			LENG = val(mid$(STR, POS, I))
			RESULT(IDX) = mid$(STR, I + 1, LENG)
			POS = I + 1 + LENG
		When 'D'
			If IDX = 1 : RESULT = R_DATE : Endif
			RESULT(IDX) = gdat$(val(mid$(STR, POS + 8, 2)), val(mid$(STR, POS + 5, 2)), val(mid$(STR, POS, 4)))
			POS += 10
		When 'T'
			If IDX = 1 : RESULT = R_DATIM : Endif
			I = instr(POS, STR, ";")
			RESULT(IDX) = gdatetime$(mid$(STR, POS, I - POS))
			POS = I
		When 'O'
			Call EAT(STR, POS, "!")
			I = instr(POS + 1, STR, "{")
			Local Char CLNAME()
			CLNAME = mid$(STR, POS, I - POS)
			POS = I + 1
			If IDX = 1
				Local Instance R_INST(0..) Using =CLNAME
				RESULT = R_INST
			Endif
			R_INST(IDX) = NewInstance =CLNAME
			Call PARS_PROPS(STR, POS, R_INST(IDX))
		When Default
			Call FAIL("invalid character" - C)
		Endcase

		Call EAT(STR, POS, ";")
		If IS_ARRAY
			If mid$(STR, POS, 1) = ']'
				POS += 1
				Call EAT(STR, POS, ";")
				Break
			Endif
			IDX += 1
		Else
			RESULT = RESULT(1)
			Break
		Endif
	Wend
End RESULT

Funprog PARS(STR)
	Value Clbfile STR
	Local Integer POS
	Local Char C
	Local Any RESULT
	POS = 1
	RESULT = func PARS_ONE(STR, POS)
End RESULT

Subprog T(V, R)
	Local Clbfile R1, R2
	Local Integer T, D
	T = type(V)
	D = dim(V)
	R1 = func STRINGIFY(V, D, T)
	Call CHECK_EQUAL(R1, R) From AXUNIT
	R2 = func STRINGIFY(func PARS(R), D, T)
	Call CHECK_EQUAL(R2, R) From AXUNIT
End

Subprog TC_BASIC
	Local Integer INTEG1, INTEG2
	Local Decimal DECIM
	Local Double DBL
	Local Date DAT
	Local Datetime DATIM
	Local Char STR()
	Local Clbfile CLB
	Local Integer ARR_INT(0..)
	Local Instance BANK Using C_ABANK

	INTEG1 = 123
	INTEG2 = -123
	DECIM = 123.45
	DBL = 123.45
	DAT = gdat$(29, 10, 2015)
	DATIM = gdatetime$("2015-10-29T10:20:00Z")
	STR = "hello world"
	CLB = "hello world"
	ARR_INT(1) = 3
	ARR_INT(2) = 14
	BANK = NewInstance C_ABANK
	BANK.CRY = "FR"
	BANK.BAN = "ZABA1"
	BANK.VLYSTR = [31/12/2013]
	BANK.VLYEND = [17/10/2014]

	#Call T(AVOID.AINS, type(AVOID.AINS), "Z;")
	Call T(INTEG1, "I123;")
	Call T(INTEG2, "I-123;")
	Call T(DECIM, "N123.45;")
	Call T(DBL, "F123.45;")
	Call T(DAT, "D2015-10-29;")
	Call T(DATIM, "T2015-10-29T10:20:00Z;")
	Call T(STR, 'S11!hello world;')
	Call T(CLB, 'C11!hello world;')
	Call T(ARR_INT, 'I[3;14;];')
	Call T(BANK, 'O!C_ABANK{CRY:S2!FR;BAN:S5!ZABA1;VLYSTR:D2013-12-31;VLYEND:D2014-10-17;};')
End
