"use strict";
const tdate = require('etna/lib/engine/runtime/tdate');
const tdatetime = require('etna/lib/engine/runtime/tdatetime');

QUnit.module(module.id);

function throws(fn, expected, message) {
	if ( typeof expected === "string" ) {
		message = expected;
		expected = null;
	}
	try {
		fn();
		ok(false, message);
	} catch (ex) {
		if (expected) ok(expected.test(ex), message + ': ' + ex.message);
		else ok(true, message + ': ' + ex.message);
	}
}

test('typeof', 8, () => {
	// x3js does not try to fix typeof
	strictEqual(typeof undefined, 'undefined', 'undefined');
	strictEqual(typeof null, 'object', 'null');
	strictEqual(typeof "", 'string', 'string');
	strictEqual(typeof 0, 'number', '0');
	strictEqual(typeof 0.0, 'object', '0.0');
	strictEqual(typeof 0.0e0, 'number', '0.0e0');
	strictEqual(typeof tdate.NULL, 'object', 'tdate.NULL');
	strictEqual(typeof tdatetime.NULL, 'object', 'tdatetime.NULL');
});

function x3typeof(x) {
	if (x === undefined) return 'undefined';
	if (x === null) return 'null';
	if (typeof x !== 'object') return typeof x;
	if (Array.isArray(x)) return 'array';
	if (!x.x3Type) return 'object';
	switch (x.x3Type()) {
		case 3: return 'date';
		case 6: return 'double';
		case 7: return 'decimal';
		case 522: return 'blob';
		case 523: return 'clob';
		case 526: return 'datetime';
		default: return 'type' + x.x3Type();
	}
}

test('x3typeof', 8, () => {
	// x3js does not try to fix typeof
	strictEqual(x3typeof(undefined), 'undefined', 'undefined');
	strictEqual(x3typeof(null), 'null', 'null');
	strictEqual(x3typeof(""), 'string', 'string');
	strictEqual(x3typeof(0), 'number', '0');
	strictEqual(x3typeof(0.0), 'decimal', '0.0');
	strictEqual(x3typeof(0.0e0), 'number', '0.0e0');
	strictEqual(x3typeof(tdate.NULL), 'date', 'tdate.NULL');
	strictEqual(x3typeof(tdatetime.NULL), 'datetime', 'tdatetime.NULL');
});

test('comparisons with null', 30, () => {
	// x3js preserves == and != tests against null
	ok(null == null, 'null == null');
	ok(!(null != null), 'null != null');
	ok(null == undefined, 'null == undefined');
	ok(!(null != undefined), 'null != undefined');
	ok(undefined == null, 'undefined == null');
	ok(undefined == undefined, 'undefined == undefined');
	ok({} != null, '{} != null');
	ok([] != null, '[] != null');
	ok(0 != null, '0 != null');
	ok(0.0 != null, '0.0 != null');
	ok("" != null, '"" != null');
	ok(tdate.NULL != null, 'tdate.NULL != null');
	ok(tdatetime.NULL != null, 'tdatetime.NULL != null');
	// x3js throws when null is used with <, <=, > and >=
	throws(() => null > null, /cannot compare/, 'null > null');
	throws(() => undefined > null, /cannot compare/, 'undefined > null');
	throws(() => null > undefined, /cannot compare/, 'null > undefined');
	throws(() => ({} > null), /cannot compare/, '{} > null');
	throws(() => null > {}, /cannot compare/, 'null > {}');
	throws(() => [] > null, /cannot compare/, '[] > null');
	throws(() => null > [], /cannot compare/, 'null > []');
	throws(() => 0 > null, /cannot compare/, '0 > null');
	throws(() => null > 0, /cannot compare/, 'null > 0');
	throws(() => 0.0 > null, /cannot compare/, '0.0 > null');
	throws(() => null > 0.0, /cannot compare/, 'null > 0.0');
	throws(() => "" > null, /cannot compare/, '"" > null');
	throws(() => null > "", /cannot compare/, 'null > ""');
	throws(() => tdate.NULL > null, /cannot compare/, 'tdate.NULL > null');
	throws(() => null > tdate.NULL, /cannot compare/, 'null > tdate.NULL');
	throws(() => tdatetime.NULL > null, /cannot compare/, 'tdatetime.NULL > null');
	throws(() => null > tdatetime.NULL, /cannot compare/, 'null > tdatetime.NULL');
});

test('comparisons with zeros', 32, () => {
	// x3js promotes numeric types in comparisons
	ok(0 == 0, '0 == 0');
	ok(0 == 0.0, '0 == 0.0');
	ok(0.0 == 0, '0.0 == 0');
	ok(0.0e0 == 0, '0.0e0 == 0');
	ok(0 != 1, '0 != 1');
	ok(0.0 != 1, '0.0 != 1');
	ok(0 != 1.0, '0 != 1.0');
	ok(0 < 1, '0 < 1');
	ok(0.0 < 1, '0.0 < 1');
	ok(0 < 1.0, '0 < 1.0');
	ok(0.0e0 < 1, '0.0e0 < 1');
	ok(0 < 1.0e0, '0 < 1.0e0');
	// x3js throws when 0 is compared with non numerics
	throws(() => '' == 0, /bad operand/, '"" == 0');
	throws(() => '' != 0, /bad operand/, '"" != 0');
	throws(() => '' > 0, /bad operand/, '"" > 0');
	throws(() => '' >= 0, /bad operand/, '"" >= 0');
	throws(() => '' < 0, /bad operand/, '"" < 0');
	throws(() => '' <= 0, /bad operand/, '"" <= 0');
	throws(() => 0 == '', /bad operand/, '0 == ""');
	throws(() => 0 != '', /bad operand/, '0 != ""');
	throws(() => 0 > '', /bad operand/, '0 > ""');
	throws(() => '' == 0.0, /bad operand/, '"" == 0.0');
	throws(() => '' != 0.0, /bad operand/, '"" != 0.0');
	throws(() => '' > 0.0, /bad operand/, '"" > 0.0');
	throws(() => 0 == [], /bad operand/, '0 == []');
	throws(() => 0 != [], /bad operand/, '0 != []');
	throws(() => 0.0 == [], /bad operand/, '0.0 == []');
	throws(() => 0.0 != [], /bad operand/, '0.0 != []');
	throws(() => [] == 0, /bad operand/, '[] == 0');
	throws(() => [] != 0, /bad operand/, '[] != 0');
	throws(() => [] == 0.0, /bad operand/, '[] == 0.0');
	throws(() => [] != 0.0, /bad operand/, '[] != 0.0');
});

test('numeric promotions', 38, () => {
	strictEqual(x3typeof(0 + 1), 'number', '0 + 1');
	strictEqual(x3typeof(0.0 + 1), 'decimal', '0.0 + 1');
	strictEqual(x3typeof(0 + 1.0), 'decimal', '0 + 1.O');
	strictEqual(x3typeof(0.0e0 + 1), 'number', '0.0e0 + 1');
	strictEqual(x3typeof(0 + 1.0e0), 'number', '0 + 1.0e0');
	strictEqual(x3typeof(0.0e0 + 1.0), 'decimal', '0.0e0 + 1.0');
	strictEqual(x3typeof(0.0 + 1.0e0), 'decimal', '0.0 + 1.0e0');
	strictEqual(x3typeof(0 - 1), 'number', '0 - 1');
	strictEqual(x3typeof(0.0 - 1), 'decimal', '0.0 - 1');
	strictEqual(x3typeof(0 - 0.0), 'decimal', '0 - 1.O');
	strictEqual(x3typeof(0.0e0 - 1), 'number', '0.0e0 - 1');
	strictEqual(x3typeof(0 - 1.0e0), 'number', '0 - 1.0e0');
	strictEqual(x3typeof(0.0e0 - 1.0), 'decimal', '0.0e0 - 1.0');
	strictEqual(x3typeof(0.0 - 1.0e0), 'decimal', '0.0 - 1.0e0');
	strictEqual(x3typeof(0 * 1), 'number', '0 * 1');
	strictEqual(x3typeof(0.0 * 1), 'decimal', '0.0 * 1');
	strictEqual(x3typeof(0 * 1.0), 'decimal', '0 * 1.O');
	strictEqual(x3typeof(0.0e0 * 1), 'number', '0.0e0 * 1');
	strictEqual(x3typeof(0 * 1.0e0), 'number', '0 * 1.0e0');
	strictEqual(x3typeof(0.0e0 * 1.0), 'decimal', '0.0e0 * 1.0');
	strictEqual(x3typeof(0.0 * 1.0e0), 'decimal', '0.0 * 1.0e0');
	// integer division yields number if result is integer, bcd otherwise!
	strictEqual(x3typeof(0 / 1), 'number', '0 / 1');
	strictEqual(x3typeof(2 / 1), 'number', '2 / 1');
	strictEqual(x3typeof(1 / 2), 'decimal', '1 / 2');
	strictEqual(x3typeof(0.0 / 1), 'decimal', '0.0 / 1');
	strictEqual(x3typeof(0 / 1.0), 'decimal', '0 / 1.O');
	strictEqual(x3typeof(0.0e0 / 1), 'number', '0.0e0 / 1');
	strictEqual(x3typeof(0 / 1.0e0), 'number', '0 / 1.0e0');
	strictEqual(x3typeof(0.0e0 / 1.0), 'decimal', '0.0e0 / 1.0');
	strictEqual(x3typeof(2.0e0 / 1.0), 'decimal', '1.0e0 / 1.0');
	strictEqual(x3typeof(1.0e0 / 2.0), 'decimal', '1.0e0 / 2.0');
	strictEqual(x3typeof(0.0 / 1.0e0), 'decimal', '0.0 / 1.0e0');
	strictEqual(x3typeof(+ 1), 'number', '+ 1');
	strictEqual(x3typeof(+ 1.0), 'decimal', '+ 1.0');
	strictEqual(x3typeof(+ 1.0e0), 'number', '+ 1.0e0');
	strictEqual(x3typeof(- 1), 'number', '- 1');
	strictEqual(x3typeof(- 1.0), 'decimal', '- 1.0');
	strictEqual(x3typeof(- 1.0e0), 'number', '- 1.0e0');
});

test('arithmetics', 15, () => {
	ok(+ 5 === +5, '+ 5');
	ok(- 5 === -5, '- 5');
	ok(+ 5.0 == +5, '+ 5.0');
	ok(- 5.0 == -5, '- 5.0');
	ok(2 + 5 === 7, '2 + 5');
	ok(2 - 5 === -3, '2 - 5');
	ok(2 * 5 === 10, '2 * 5');
	ok(5 / 2 == 2.5, '5 / 2');
	ok(2.0 + 5 == 7.0, '2.0 + 5');
	ok(2.0 - 5 == -3.0, '2.0 - 5');
	ok(2.0 * 5 == 10.0, '2.0 * 5');
	ok(5.0 / 2 == 2.5e0, '5.0 / 2');
	ok(0.1 + 0.2 == 0.3, '0.1 + 0.2');
	ok(0.1e0 +  0.2e0 != 0.3e0, '0.1e0 + 0.2');
	ok(0.5e0 + 0.5e0 == 1, '0.5e0 + 0.5e0');
});

test('division by 0', 9, () => {
	throws(() => 1 / 0, /division by zero/, '1 / 0');
	throws(() => 1.0 / 0, /division by zero/, '1.0 / 0');
	throws(() => 1 / 0.0, /division by zero/, '1 / 0.0');
	throws(() => 1.0 / 0.0, /division by zero/, '1.0 / 0.0');
	throws(() => 1.1e0 / 0, /division by zero/, '1.1e0 / 0');
	throws(() => 0 / 0, /division by zero/, '0 / 0');
	throws(() => 0.0 / 0, /division by zero/, '0.0 / 0');
	throws(() => 0 / 0.0, /division by zero/, '0 / 0.0');
	throws(() => 0.0 / 0.0, /division by zero/, '0.0 / 0.0');
});

test('arithmetics throws', 12, () => {
	throws(() => 1 + "", /bad operand/, '1 + ""');
	throws(() => 1 - "", /bad operand/, '1 - ""');
	throws(() => 1 * "", /bad operand/, '1 * ""');
	throws(() => 1 / "", /bad operand/, '1 / ""');

	throws(() => 1 + {}, /bad operand/, '1 + {}');
	throws(() => 1 - {}, /bad operand/, '1 - {}');
	throws(() => 1 * {}, /bad operand/, '1 * {}');
	throws(() => 1 / {}, /bad operand/, '1 / {}');

	throws(() => 1 + tdate.make(2000, 1, 1), /bad operand/, '1 + tdate.make(2000, 1, 1)');
	throws(() => 1 - tdate.make(2000, 1, 1), /bad operand/, '1 - tdate.make(2000, 1, 1)');
	throws(() => 1 * tdate.make(2000, 1, 1), /bad operand/, '1 * tdate.make(2000, 1, 1)');
	throws(() => 1 / tdate.make(2000, 1, 1), /bad operand/, '1 / tdate.make(2000, 1, 1)');
});

// utility to validate compliance with JS specs
function refSequence(fn, initial, rhs) {
	// check sequencing
	var seq = [];
	var o = () => {
		seq.push('o()');
		return {
			_i: initial,
			get i() { seq.push('get' + this._i); return this._i; },
			set i(v) { seq.push('set' + v); this._i = v; },
		};
	};
	var p = () => (seq.push('p()'), 'i');
	var v = () => (seq.push('v()'), rhs);
	fn(o, p, v);
	return seq.join('/');
}

test('increments and decrements', 28, () => {
	var i = 1.5;
	ok(i++ == 1.5, 'i++ == 1.5');
	ok(i == 2.5, 'i == 2.5');
	strictEqual(x3typeof(i), 'decimal', 'x3typeof(i)');
	ok(++i == 3.5, '++i == 3.5');
	ok(i == 3.5, 'i == 3.5');
	ok(i-- == 3.5, 'i-- == 3.5');
	ok(i == 2.5, 'i == 2.5');
	ok(--i == 1.5, '--i == 1.5');
	ok(i == 1.5, 'i == 1.5');

	var o = { i: 1.5 };
	ok(o.i++ == 1.5, 'o.i++ == 1.5');
	ok(o.i == 2.5, 'o.i == 2.5');
	strictEqual(x3typeof(o.i), 'decimal', 'x3typeof(o.i)');
	ok(++o.i == 3.5, '++o.i == 3.5');
	ok(o.i == 3.5, 'o.i == 3.5');
	ok(o.i-- == 3.5, 'o.i-- == 3.5');
	ok(o.i == 2.5, 'o.i == 2.5');
	ok(--o.i == 1.5, '--o.i == 1.5');
	ok(o.i == 1.5, 'o.i == 1.5');

	// computed property
	var o = { i: 1.5 };
	var p = () => 'i';
	ok(o[p()]++ == 1.5, 'o[p()]++ == 1.5');
	ok(o[p()] == 2.5, 'o[p()] == 2.5');
	strictEqual(x3typeof(o[p()]), 'decimal', 'x3typeof(o[p()])');
	ok(++o[p()] == 3.5, '++o[p()] == 3.5');
	ok(o[p()] == 3.5, 'o[p()] == 3.5');
	ok(o[p()]-- == 3.5, 'o[p()]-- == 3.5');
	ok(o[p()] == 2.5, 'o[p()] == 2.5');
	ok(--o[p()] == 1.5, '--o[p()] == 1.5');
	ok(o[p()] == 1.5, 'o[p()] == 1.5');

	var seq = refSequence((o, p) => o()[p()]++, 1.5);
	strictEqual(seq, 'o()/p()/get1.5/set2.5');
});

test('assignments', 19, () => {
	var i = 1.5;
	ok((i += 2) == 3.5);
	strictEqual(x3typeof(i), 'decimal', 'x3typeof(i)');
	ok(i == 3.5, 'i += 2');
	ok((i -= 0.2) == 3.3, 'i -= 0.2');
	ok((i *= 2) == 6.6, 'i *= 2');
	ok((i /= 3) == 2.2, 'i /= 3');

	var o = { i: 1.5 };
	ok((o.i += 2) == 3.5);
	strictEqual(x3typeof(o.i), 'decimal', 'x3typeof(o.i)');
	ok(o.i == 3.5, 'o.i += 2');
	ok((o.i -= 0.2) == 3.3, 'o.i -= 0.2');
	ok((o.i *= 2) == 6.6, 'o.i *= 2');
	ok((o.i /= 3) == 2.2, 'o.i /= 3');

	// computed property
	var o = { i: 1.5 };
	var p = () => 'i';
	ok((o[p()] += 2) == 3.5);
	strictEqual(x3typeof(o[p()]), 'decimal', 'x3typeof(o[p()])');
	ok(o[p()] == 3.5, 'o[p()] += 2');
	ok((o[p()] -= 0.2) == 3.3, 'o[p()] -= 0.2');
	ok((o[p()] *= 2) == 6.6, 'o[p()] *= 2');
	ok((o[p()] /= 3) == 2.2, 'o[p()] /= 3');	

	var seq = refSequence((o, p, v) => (o()[p()] += v()), 1.5, 2);
	strictEqual(seq, 'o()/p()/get1.5/v()/set3.5');
});

test('string operators', 10, () => {
	strictEqual('a:' + 'b', 'a:b', 'a:b');
	strictEqual('a:' + undefined, 'a:undefined', 'a:undefined');
	strictEqual('a:' + null, 'a:null', 'a:null');
	strictEqual('a:' + 1, 'a:1', 'a:1');
	strictEqual('a:' + 1.0, 'a:1', 'a:1 (from 1.0)');
	strictEqual('a:' + 1.5, 'a:1.5', 'a:1.5');
	strictEqual('a:' + 0.12345678901234567890123456789, 'a:0.12345678901234567890123456789', 'a:0.12345678901234567890123456789');
	strictEqual('a:' + 1.5e0, 'a:1.5', 'a:1.5 (from 1.5e0)');
	strictEqual('a:' + tdate.make(2016,2,20), 'a:2016-02-20', 'a:2016-02-20');
	strictEqual('a:' + tdatetime.makeUtc(2016,2,20,14,30), 'a:2016-02-20T14:30:00.000Z', 'a:2016-02-20T14:30:00.000Z');
});

test('date', 13, () => {
	// == and !=
	ok(tdate.MIN == tdate.MIN, 'tdate.MIN == tdate.MIN');
	ok(tdate.MIN != tdate.today(), 'tdate.MIN != tdate.today()');
	// comparisons
	ok(tdate.MIN > tdate.NULL, 'tdate.MIN > tdate.NULL');
	ok(tdate.MIN < tdate.today(), 'tdate.MIN < tdate.today()');
	ok(tdate.MAX > tdate.today(), 'tdate.MAX > tdate.today()');
	ok(tdate.today() + 1 > tdate.today(), 'tdate.today() + 1 > tdate.today()');
	ok(tdate.today() - 1 < tdate.today(), 'tdate.today() - 1 < tdate.today()');
	// add and subtract
	ok(tdate.make(2000,1,1) + 1 == tdate.make(2000,1,2), 'tdate.make(2000,1,1) + 1');
	ok(tdate.make(2000,1,1) - 1 == tdate.make(1999,12,31), 'tdate.make(2000,1,1) - 1');
	ok(tdate.make(2000,2,1) - tdate.make(2000,1,1) == 31, 'tdate.make(2000,2,1) - tdate.make(2000,1,1)');
	// concat
	strictEqual("" + tdate.MIN, '1600-01-01', '"" + tdate.MIN');
	// invalid operations
	throws(() => tdate.make(2000,1,1) * 2, /bad operand/, 'tdate.make(2000,1,1) * 2');
	throws(() => tdate.make(2000,1,1) / 2, /bad operand/, 'tdate.make(2000,1,1) / 2');
});

function asyncObj(val) {
	return {
		_v: val,
		prop: function(_, v) {
			process.nextTick(_);
			if (arguments.length > 1) this._v = v;
			else return this._v;
		},
	};
}

asyncTest('async', 7, (_) => {
	var o = asyncObj(1);
	ok(o.prop$ == 1, 'o.prop$ == 1');
	o.prop$ = 2.5;
	ok(o.prop$ == 2.5, 'o.prop$ == 2.5');
	ok((o.prop$ = 3.5) == 3.5, '(o.prop$ = 3.5) == 3.5');
	ok(o.prop$++ == 3.5, 'o.prop$++ == 3.5');
	ok(o.prop$ == 4.5, 'o.prop$ == 4.5');
	ok(++o.prop$ == 5.5, '++o.prop$ == 5.5' + ' -- ' + o.prop$);
	ok((o.prop$ += 3) == 8.5, '(o.prop$ += 3) == 8.5');
	start();
});
