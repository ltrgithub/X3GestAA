"use strict";
const tdate = require('etna/lib/engine/runtime/tdate');
const tdatetime = require('etna/lib/engine/runtime/tdatetime');

QUnit.module(module.id);

function throws(fn, expected, message) {
	if ( typeof expected === "string" ) {
		message = expected;
		expected = null;
	}
	try {
		fn();
		ok(false, message);
	} catch (ex) {
		if (expected) ok(expected.test(ex), message + ': ' + ex.message);
		else ok(true, message + ': ' + ex.message);
	}
}

test('typeof', 8, () => {
	// x3js does not try to fix typeof
	strictEqual(typeof undefined, 'undefined', 'undefined');
	strictEqual(typeof null, 'object', 'null');
	strictEqual(typeof "", 'string', 'string');
	strictEqual(typeof 0, 'number', '0');
	strictEqual(typeof 0.0, 'object', '0.0');
	strictEqual(typeof 0.0e0, 'number', '0.0e0');
	strictEqual(typeof tdate.NULL, 'object', 'tdate.NULL');
	strictEqual(typeof tdatetime.NULL, 'object', 'tdatetime.NULL');
});

function x3typeof(x) {
	if (x === undefined) return 'undefined';
	if (x === null) return 'null';
	if (typeof x !== 'object') return typeof x;
	if (Array.isArray(x)) return 'array';
	if (!x.x3Type) return 'object';
	switch (x.x3Type()) {
		case 3: return 'date';
		case 6: return 'double';
		case 7: return 'decimal';
		case 522: return 'blob';
		case 523: return 'clob';
		case 526: return 'datetime';
		default: return 'type' + x.x3Type();
	}
}

test('x3typeof', 8, () => {
	// x3js does not try to fix typeof
	strictEqual(x3typeof(undefined), 'undefined', 'undefined');
	strictEqual(x3typeof(null), 'null', 'null');
	strictEqual(x3typeof(""), 'string', 'string');
	strictEqual(x3typeof(0), 'number', '0');
	strictEqual(x3typeof(0.0), 'decimal', '0.0');
	strictEqual(x3typeof(0.0e0), 'number', '0.0e0');
	strictEqual(x3typeof(tdate.NULL), 'date', 'tdate.NULL');
	strictEqual(x3typeof(tdatetime.NULL), 'datetime', 'tdatetime.NULL');
});

test('comparisons with null', 30, () => {
	// x3js preserves == and != tests against null
	ok(null == null, 'null == null');
	ok(!(null != null), 'null != null');
	ok(null == undefined, 'null == undefined');
	ok(!(null != undefined), 'null != undefined');
	ok(undefined == null, 'undefined == null');
	ok(undefined == undefined, 'undefined == undefined');
	ok({} != null, '{} != null');
	ok([] != null, '[] != null');
	ok(0 != null, '0 != null');
	ok(0.0 != null, '0.0 != null');
	ok("" != null, '"" != null');
	ok(tdate.NULL != null, 'tdate.NULL != null');
	ok(tdatetime.NULL != null, 'tdatetime.NULL != null');
	// x3js throws when null is used with <, <=, > and >=
	throws(() => null > null, /cannot compare/, 'null > null');
	throws(() => undefined > null, /cannot compare/, 'undefined > null');
	throws(() => null > undefined, /cannot compare/, 'null > undefined');
	throws(() => ({} > null), /cannot compare/, '{} > null');
	throws(() => null > {}, /cannot compare/, 'null > {}');
	throws(() => [] > null, /cannot compare/, '[] > null');
	throws(() => null > [], /cannot compare/, 'null > []');
	throws(() => 0 > null, /cannot compare/, '0 > null');
	throws(() => null > 0, /cannot compare/, 'null > 0');
	throws(() => 0.0 > null, /cannot compare/, '0.0 > null');
	throws(() => null > 0.0, /cannot compare/, 'null > 0.0');
	throws(() => "" > null, /cannot compare/, '"" > null');
	throws(() => null > "", /cannot compare/, 'null > ""');
	throws(() => tdate.NULL > null, /cannot compare/, 'tdate.NULL > null');
	throws(() => null > tdate.NULL, /cannot compare/, 'null > tdate.NULL');
	throws(() => tdatetime.NULL > null, /cannot compare/, 'tdatetime.NULL > null');
	throws(() => null > tdatetime.NULL, /cannot compare/, 'null > tdatetime.NULL');
});

test('comparisons with zeros', 32, () => {
	// x3js promotes numeric types in comparisons
	ok(0 == 0, '0 == 0');
	ok(0 == 0.0, '0 == 0.0');
	ok(0.0 == 0, '0.0 == 0');
	ok(0.0e0 == 0, '0.0e0 == 0');
	ok(0 != 1, '0 != 1');
	ok(0.0 != 1, '0.0 != 1');
	ok(0 != 1.0, '0 != 1.0');
	ok(0 < 1, '0 < 1');
	ok(0.0 < 1, '0.0 < 1');
	ok(0 < 1.0, '0 < 1.0');
	ok(0.0e0 < 1, '0.0e0 < 1');
	ok(0 < 1.0e0, '0 < 1.0e0');
	// x3js throws when 0 is compared with non numerics
	throws(() => '' == 0, /bad operand/, '"" == 0');
	throws(() => '' != 0, /bad operand/, '"" != 0');
	throws(() => '' > 0, /bad operand/, '"" > 0');
	throws(() => '' >= 0, /bad operand/, '"" >= 0');
	throws(() => '' < 0, /bad operand/, '"" < 0');
	throws(() => '' <= 0, /bad operand/, '"" <= 0');
	throws(() => 0 == '', /bad operand/, '0 == ""');
	throws(() => 0 != '', /bad operand/, '0 != ""');
	throws(() => 0 > '', /bad operand/, '0 > ""');
	throws(() => '' == 0.0, /bad operand/, '"" == 0.0');
	throws(() => '' != 0.0, /bad operand/, '"" != 0.0');
	throws(() => '' > 0.0, /bad operand/, '"" > 0.0');
	throws(() => 0 == [], /bad operand/, '0 == []');
	throws(() => 0 != [], /bad operand/, '0 != []');
	throws(() => 0.0 == [], /bad operand/, '0.0 == []');
	throws(() => 0.0 != [], /bad operand/, '0.0 != []');
	throws(() => [] == 0, /bad operand/, '[] == 0');
	throws(() => [] != 0, /bad operand/, '[] != 0');
	throws(() => [] == 0.0, /bad operand/, '[] == 0.0');
	throws(() => [] != 0.0, /bad operand/, '[] != 0.0');
});

test('numeric promotions', 38, () => {
	strictEqual(x3typeof(0 + 1), 'number', '0 + 1');
	strictEqual(x3typeof(0.0 + 1), 'decimal', '0.0 + 1');
	strictEqual(x3typeof(0 + 1.0), 'decimal', '0 + 1.O');
	strictEqual(x3typeof(0.0e0 + 1), 'number', '0.0e0 + 1');
	strictEqual(x3typeof(0 + 1.0e0), 'number', '0 + 1.0e0');
	strictEqual(x3typeof(0.0e0 + 1.0), 'decimal', '0.0e0 + 1.0');
	strictEqual(x3typeof(0.0 + 1.0e0), 'decimal', '0.0 + 1.0e0');
	strictEqual(x3typeof(0 - 1), 'number', '0 - 1');
	strictEqual(x3typeof(0.0 - 1), 'decimal', '0.0 - 1');
	strictEqual(x3typeof(0 - 0.0), 'decimal', '0 - 1.O');
	strictEqual(x3typeof(0.0e0 - 1), 'number', '0.0e0 - 1');
	strictEqual(x3typeof(0 - 1.0e0), 'number', '0 - 1.0e0');
	strictEqual(x3typeof(0.0e0 - 1.0), 'decimal', '0.0e0 - 1.0');
	strictEqual(x3typeof(0.0 - 1.0e0), 'decimal', '0.0 - 1.0e0');
	strictEqual(x3typeof(0 * 1), 'number', '0 * 1');
	strictEqual(x3typeof(0.0 * 1), 'decimal', '0.0 * 1');
	strictEqual(x3typeof(0 * 1.0), 'decimal', '0 * 1.O');
	strictEqual(x3typeof(0.0e0 * 1), 'number', '0.0e0 * 1');
	strictEqual(x3typeof(0 * 1.0e0), 'number', '0 * 1.0e0');
	strictEqual(x3typeof(0.0e0 * 1.0), 'decimal', '0.0e0 * 1.0');
	strictEqual(x3typeof(0.0 * 1.0e0), 'decimal', '0.0 * 1.0e0');
	// integer division yields number if result is integer, bcd otherwise!
	strictEqual(x3typeof(0 / 1), 'number', '0 / 1');
	strictEqual(x3typeof(2 / 1), 'number', '2 / 1');
	strictEqual(x3typeof(1 / 2), 'decimal', '1 / 2');
	strictEqual(x3typeof(0.0 / 1), 'decimal', '0.0 / 1');
	strictEqual(x3typeof(0 / 1.0), 'decimal', '0 / 1.O');
	strictEqual(x3typeof(0.0e0 / 1), 'number', '0.0e0 / 1');
	strictEqual(x3typeof(0 / 1.0e0), 'number', '0 / 1.0e0');
	strictEqual(x3typeof(0.0e0 / 1.0), 'decimal', '0.0e0 / 1.0');
	strictEqual(x3typeof(2.0e0 / 1.0), 'decimal', '1.0e0 / 1.0');
	strictEqual(x3typeof(1.0e0 / 2.0), 'decimal', '1.0e0 / 2.0');
	strictEqual(x3typeof(0.0 / 1.0e0), 'decimal', '0.0 / 1.0e0');
	strictEqual(x3typeof(+ 1), 'number', '+ 1');
	strictEqual(x3typeof(+ 1.0), 'decimal', '+ 1.0');
	strictEqual(x3typeof(+ 1.0e0), 'number', '+ 1.0e0');
	strictEqual(x3typeof(- 1), 'number', '- 1');
	strictEqual(x3typeof(- 1.0), 'decimal', '- 1.0');
	strictEqual(x3typeof(- 1.0e0), 'number', '- 1.0e0');
});

test('arithmetics', 19, () => {
	ok(+ 5 === +5, '+ 5');
	ok(- 5 === -5, '- 5');
	ok(+ 5.0 == +5, '+ 5.0');
	ok(- 5.0 == -5, '- 5.0');
	ok(2 + 5 === 7, '2 + 5');
	ok(2 - 5 === -3, '2 - 5');
	ok(2 * 5 === 10, '2 * 5');
	ok(5 / 2 == 2.5, '5 / 2');
	ok(2.0 + 5 == 7.0, '2.0 + 5');
	ok(2.0 - 5 == -3.0, '2.0 - 5');
	ok(2.0 * 5 == 10.0, '2.0 * 5');
	ok(5.0 / 2 == 2.5e0, '5.0 / 2');
	ok(0.1 + 0.2 == 0.3, '0.1 + 0.2');
	ok(0.1e0 +  0.2e0 != 0.3e0, '0.1e0 + 0.2');
	ok(0.5e0 + 0.5e0 == 1, '0.5e0 + 0.5e0');
	throws(() => 1 + "", /bad operand/, '1 + ""');
	throws(() => 1 - "", /bad operand/, '1 - ""');
	throws(() => 1 * "", /bad operand/, '1 * ""');
	throws(() => 1 / "", /bad operand/, '1 / ""');
});

test('division by 0', 9, () => {
	throws(() => 1 / 0, /division by zero/, '1 / 0');
	throws(() => 1.0 / 0, /division by zero/, '1.0 / 0');
	throws(() => 1 / 0.0, /division by zero/, '1 / 0.0');
	throws(() => 1.0 / 0.0, /division by zero/, '1.0 / 0.0');
	throws(() => 1.1e0 / 0, /division by zero/, '1.1e0 / 0');
	throws(() => 0 / 0, /division by zero/, '0 / 0');
	throws(() => 0.0 / 0, /division by zero/, '0.0 / 0');
	throws(() => 0 / 0.0, /division by zero/, '0 / 0.0');
	throws(() => 0.0 / 0.0, /division by zero/, '0.0 / 0.0');
});

test('increments and decrements', 18, () => {
	var i = 1.5;
	ok(i++ == 1.5, 'i++ == 1.5');
	ok(i == 2.5, 'i == 2.5');
	strictEqual(x3typeof(i), 'decimal', 'x3typeof(i)');
	ok(++i == 3.5, '++i == 3.5');
	ok(i == 3.5, 'i == 3.5');
	ok(i-- == 3.5, 'i-- == 3.5');
	ok(i == 2.5, 'i == 2.5');
	ok(--i == 1.5, '--i == 1.5');
	ok(i == 1.5, 'i == 1.5');

	var o = { i: 1.5 };
	ok(o.i++ == 1.5, 'o.i++ == 1.5');
	ok(o.i == 2.5, 'o.i == 2.5');
	strictEqual(x3typeof(o.i), 'decimal', 'x3typeof(o.i)');
	ok(++o.i == 3.5, '++o.i == 3.5');
	ok(o.i == 3.5, 'o.i == 3.5');
	ok(o.i-- == 3.5, 'o.i-- == 3.5');
	ok(o.i == 2.5, 'o.i == 2.5');
	ok(--o.i == 1.5, '--o.i == 1.5');
	ok(o.i == 1.5, 'o.i == 1.5');
});

test('date', 6, () => {
	ok(tdate.MIN > tdate.NULL, 'tdate.MIN > tdate.NULL');
	ok(tdate.MIN < tdate.today(), 'tdate.MIN < tdate.today()');
	ok(tdate.MAX > tdate.today(), 'tdate.MAX > tdate.today()');
	ok(tdate.today() + 1 > tdate.today(), 'tdate.today() + 1 > tdate.today()');
	ok(tdate.today() - 1 < tdate.today(), 'tdate.today() - 1 < tdate.today()');
	strictEqual("" + tdate.MIN, '1600-01-01', '"" + tdate.MIN');
});

