// Generated by dts-bundle v0.4.3
declare module 'syracuse-core' {
    import * as uuid from 'syracuse-core/uuid';
    import { getTracer } from 'syracuse-core/trace';
    import * as types from 'syracuse-core/types/index';
    import * as error from 'syracuse-core/error';
    import * as apis from 'syracuse-core/apis';
    import * as helpers from 'syracuse-core/helpers';
    import locale from 'syracuse-core/locale';
    import * as http from 'syracuse-core/http';
    import * as resource from 'syracuse-core/resource/index';
    export { uuid, getTracer, types, error, apis, helpers, locale, http, resource };
}

declare module 'syracuse-core/uuid' {
    export function clearTimeout(): void;
    export const $exported: boolean;
    export function generate(sep?: string): string;
    export function fromBytes(bytes: Uint8Array): string;
    export function toBytes(str: string): number[];
    export function fromString32(str: string): string;
    export function toString32(uuid: string): string;
}

declare module 'syracuse-core/trace' {
    export interface Tracer {
        debug?: (message: string) => void;
        info?: (message: string) => void;
        warn?: (message: string) => void;
        error?: (message: string) => void;
    }
    export function getTracer(name: string): Tracer;
}

declare module 'syracuse-core/types/index' {
    import * as bigint from 'syracuse-core/types/bigint';
    import * as binary from 'syracuse-core/types/binary';
    import * as boolean from 'syracuse-core/types/boolean';
    import * as date from 'syracuse-core/types/date';
    import * as datetime from 'syracuse-core/types/datetime';
    import * as time from 'syracuse-core/types/time';
    import * as decimal from 'syracuse-core/types/decimal';
    import * as integer from 'syracuse-core/types/integer';
    import * as real from 'syracuse-core/types/real';
    import * as string from 'syracuse-core/types/string';
    export { bigint, binary, boolean, date, datetime, time, decimal, integer, real, string };
}

declare module 'syracuse-core/error' {
    export interface ErrorConfig {
        exposeStacktrace?: boolean;
    }
    export function configure(options: ErrorConfig): void;
}

declare module 'syracuse-core/apis' {
    export function get(name: string, def: any): any;
    export function register(name: string, getter: () => any): void;
}

declare module 'syracuse-core/helpers' {
    export function defineClass(constructor: Function, parent: Function, members: {}): Function;
    export function defineClassEx(constructor: Function, parent: Function, extraMembers: {}, members: {}): any;
    export interface Visitor {
        visitLeaf?: (key: string, value: any) => void;
        visit?: (key: string, value: any) => boolean;
        leave?: (key: string, value: any) => void;
    }
    export const object: {
        deleteProperties(obj: any, properties: any[]): void;
        find(obj: any, key: string): any;
        get(obj: any, key: string, failIfNull?: boolean): any;
        copy(src: any, dst: any): any;
        extend(src: any, ext: any, override?: boolean, deep?: boolean): any;
        extendEx(obj: any): any;
        merge(src: any, dst: any): boolean;
        clone(obj: any, deep?: boolean): any;
        has(obj: any, key: string): any;
        forEachKey(object: any, body: (key: string, value: any) => void): void;
        isFunction(obj: any): boolean;
        toArray(object: any, mapper: (key: string, value: any) => any): any[];
        areEqual(obj1: any, obj2: any): boolean;
        walkPath(resource: any, path: string): {
            resource: any;
            property: string;
        };
        evalPath(resource: any, path: string): any;
        stringify(obj: any): string;
        traverse(obj: any, visitor: Visitor | ((name: string, value: any) => boolean), key: string): void;
    };
    export const array: {
        ensureArray(obj: any): any;
    };
    export const string: {
        pluralize(str: string): string;
        capitalize(str: string): string;
        makeLabel(str: string): string;
        formatValue(item: any, val: string): string;
        parseValue(item: {
            type: string;
        }, str: any): any;
        padLeft(str: string, len: number, ch?: string): string;
        trim(str: string): string;
        trimRight(str: string): string;
        sqlQuote(str: string): string;
        compare(s1: string, s2: string, ignoreCase?: boolean): number;
        labelSeparator: string;
        htmlEscape(str: string): string;
    };
    export interface ResourceDiagnosis {
        property: string;
        severity: "error" | "warning" | "info";
        message: string;
    }
    export interface Resource {
        $errors?: {
            [key: string]: ResourceDiagnosis[];
        };
        $url?: string;
        $key?: string;
        $uuid?: string;
        $metadata?: any;
        $index?: number;
        $isDeleted?: boolean;
        $resources?: Resource[];
        $properties?: any;
        [name: string]: any;
    }
    export interface Candidate {
        resource: Resource;
        modifiedBy: any;
    }
    export const resource: {
        create(url: string): {
            $url: string;
        };
        syracuseProperties: string[];
        stringify(resource: Resource): string;
        addError(resource: Resource, uuid: string, property: string, message: string): void;
        diff(oldResource: Resource, newResource: Resource): Resource;
        mergeDiff(winner: Candidate, loser: Candidate): {
            result: Resource;
            modifiedBy: string;
        };
        applyDiff(resource: Resource, diff: Resource, isChild?: boolean): Resource;
        setMissingUrls(resource: Resource): void;
        isTemplate(expression: any): boolean;
        applyTemplate(template: string, obj: Resource, fallbackObj: Resource): string;
        sdataDelta(oldResource: Resource, newResource: Resource): any;
        sdataMerge(oldResource: Resource, delta: Resource): any;
    };
    import * as uuid from 'syracuse-core/uuid';
    export { uuid };
    export interface UrlSegment {
        name: string;
        id?: string;
        isExpressionId?: boolean;
    }
    export interface OrderBy {
        binding: string;
        descending?: boolean;
    }
    export const url: {
        postify(value: {}): any;
        formatValue(type: "boolean" | "string" | "integer" | "decimal" | "date" | "datetime" | "time", val: any): any;
        parseValue(type: "boolean" | "string" | "integer" | "decimal" | "date" | "datetime" | "time", str: string): any;
        queryStringify(value: any, ignore: string[]): string;
        parseOrderBy(str: string): {
            binding: string;
            descending: boolean;
        }[];
        formatOrderBy(orderBys: OrderBy[]): string;
        parseQueryString(str: string): any;
        parseUrl(url: string): {
            url: string;
            segments: string[];
            path: string;
            rawQuery: string;
            query: any;
            walkUrl(): string;
            unwalkUrl(): void;
            walked(): string;
            toWalk(): string;
        };
        decodeDetailSegment(segment: string): UrlSegment;
    };
    export const http: {
        parseCookie(cookie: string): any;
        checkIfIE(userAgent: string): boolean;
        parseHeaders(headers: any): any;
    };
    export const debug: {
        traces: {};
        assert(test: any): void;
        traceReturn(tag: string, result: any): any;
        tracer(tag: string): (message?: any, ...optionalParams: any[]) => void;
    };
    export const log: {
        config: {};
        exception(module: NodeModule, ex: Error): void;
        error(module: NodeModule, message: string): void;
        warn(module: NodeModule, message: string): void;
        info(module: NodeModule, message: string): void;
    };
    export function setCookie(name: string, value: string, domain: string, expires: Date | string, path: string, secure: boolean): void;
    export function getCookie(name: string): string;
    export function eraseCookie(name: string, domain: string, path: string): void;
    export function relNumberCmp(rel1: string, rel2: string): number;
}

declare module 'syracuse-core/locale' {
    var locale: any;
    export default locale;
}

declare module 'syracuse-core/http' {
    export const httpStatus: {
        OK: number;
        Created: number;
        Accepted: number;
        NoContent: number;
        MovedPermanently: number;
        Found: number;
        SeeOther: number;
        NotModified: number;
        TemporaryRedirect: number;
        BadRequest: number;
        Unauthorized: number;
        Forbidden: number;
        NotFound: number;
        MethodNotAllowed: number;
        NotAcceptable: number;
        Conflict: number;
        Gone: number;
        PreconditionFailed: number;
        UnsupportedMediaType: number;
        InternalServerError: number;
        NotImplemented: number;
        ServiceUnavailable: number;
    };
    export const statusMessages: any;
    export const mediaTypes: {
        pdf: string;
        xlsx: string;
        docx: string;
        pptx: string;
        doc: string;
        xls: string;
        zip: string;
        excel_worksheet: string;
        word_report: string;
        word_mailmerge: string;
        ppt_slide: string;
    };
    export function parseAccept(str: string): {
        rawType: any;
        type: string;
        parameters: {
            [name: string]: string;
        };
    }[] | {
        rawType: string;
        type: string;
        parameters: {};
    }[];
    export function parseHeaders(headers: any): any;
    export interface DetailSegement {
        name: string;
        id?: string;
        isExpressionId?: boolean;
    }
    export function decodeDetailSegment(segment: string): DetailSegement;
}

declare module 'syracuse-core/resource/index' {
    import * as proxy from 'syracuse-core/resource/resourceProxy';
    import * as util from 'syracuse-core/resource/util';
    export { proxy, util };
}

declare module 'syracuse-core/types/bigint' {
    import { TypeConstraints } from 'syracuse-core/types/type-constraints';
    export function validate(value: any, constraints: TypeConstraints, errors: string[]): void;
    export function make(value: string | number): any;
}

declare module 'syracuse-core/types/binary' {
    import { TypeConstraints } from 'syracuse-core/types/type-constraints';
    export function validate(value: any, constraints: TypeConstraints, errors: string[]): void;
    export function calcMimeType(bin: Uint8Array): string;
}

declare module 'syracuse-core/types/boolean' {
    import { TypeConstraints } from 'syracuse-core/types/type-constraints';
    export function validate(value: any, constraints: TypeConstraints, errors: string[]): number;
    export const defaultValue: boolean;
}

declare module 'syracuse-core/types/date' {
    import { TypeConstraints } from 'syracuse-core/types/type-constraints';
    import * as datetime from "syracuse-core/types/datetime";
    import * as time from "syracuse-core/types/time";
    export const resources: any;
    export function validate(value: any, constraints: TypeConstraints, errors: string[]): void;
    export function isLeap(year: number): boolean;
    export function daysInMonth(year: number, month: number): number;
    export type DateDiff = {
        years?: number;
        months?: number;
        weeks?: number;
        days?: number;
    };
    export class DateValue {
        _value: number;
        constructor(value: number);
        value: number;
        year: number;
        month: number;
        day: number;
        weekDay: number;
        yearDay: number;
        week: number;
        valueOf(): string;
        compare(date: DateValue): number;
        equals(date: DateValue): boolean;
        between(begin: DateValue, end: DateValue): boolean;
        isLeapYear(): boolean;
        isWorkDay(): boolean;
        daysInMonth(): number;
        begOfYear(): DateValue;
        endOfYear(): DateValue;
        begOfQuarter(): DateValue;
        endOfQuarter(): DateValue;
        begOfMonth(): DateValue;
        endOfMonth(): DateValue;
        sameMonth(day: number): DateValue;
        pastDay(day: number, includeThis?: boolean): DateValue;
        futureDay(day: number, includeThis?: boolean): DateValue;
        pastMonth(month: number, includeThis?: boolean): DateValue;
        futureMonth(month: number, includeThis?: boolean): DateValue;
        begOfWeek(startDay?: number): DateValue;
        endOfWeek(startDay: number): DateValue;
        sameWeek(weekDay: number, startDay: number): DateValue;
        pastWeekDay(weekDay: number, includeThis?: boolean): DateValue;
        futureWeekDay(weekDay: number, includeThis?: boolean): DateValue;
        weekNumber(firstDayOfWeek: number): number;
        addYears(years: number): DateValue;
        addMonths(months: number): DateValue;
        addWeeks(weeks: number): DateValue;
        addDays(days: number): DateValue;
        daysDiff(date: DateValue): number;
        add(delta: DateDiff): DateValue;
        toString(format?: string): string;
        at(time: time.Time, millisecond?: number): datetime.Datetime;
        toJsDate(utc?: boolean): Date;
        isNull(): boolean;
    }
    export function amDesignator(): string;
    export function pmDesignator(): string;
    export function monthName(month: number, abbrev?: boolean): string;
    export function monthFromName(name: string): number;
    export function dayName(weekDay: number, abbrev?: boolean): string;
    export const weekDayName: typeof dayName;
    export function weekDayFromName(name: string): number;
    export function walkFormat(format: string, map: {
        [key: string]: (arg: any) => void;
    }): void;
    export function parse(str: string, format: string): DateValue;
    export function today(utc?: boolean): DateValue;
    export function fromJsDate(jsDate: Date, utc?: boolean): DateValue;
    export function fromInternalValue(value: number): DateValue;
    export function make(year: number, month: number, day: number): DateValue;
    export function makeInWeek(year: number, week: number, wday: number): DateValue;
    export function isDate(obj: any): boolean;
    export const sunday: number;
    export const Sunday: number;
    export const monday: number;
    export const Monday: number;
    export const tuesday: number;
    export const Tuesday: number;
    export const wednesday: number;
    export const Wednesday: number;
    export const thursday: number;
    export const Thursday: number;
    export const friday: number;
    export const Friday: number;
    export const saturday: number;
    export const Saturday: number;
}

declare module 'syracuse-core/types/datetime' {
    import { TypeConstraints } from 'syracuse-core/types/type-constraints';
    import * as time from "syracuse-core/types/time";
    import * as date from "syracuse-core/types/date";
    export function validate(value: any, constraints: TypeConstraints, errors: string[]): void;
    export type DatetimeDiff = date.DateDiff & time.TimeDiff;
    export class Datetime {
        _value: number;
        _tzOffset: number;
        _utc: number;
        _local: number;
        constructor(value: number, tzOffset?: number);
        date: date.DateValue;
        time: time.Time;
        year: number;
        month: number;
        day: number;
        weekDay: number;
        yearDay: number;
        hour: number;
        minute: number;
        second: number;
        millisecond: number;
        utcDate: date.DateValue;
        utcTime: time.Time;
        utcYear: number;
        utcMonth: number;
        utcDay: number;
        utcWeekDay: number;
        utcYearDay: number;
        utcHour: number;
        utcMinute: number;
        utcSecond: number;
        utcMillisecond: number;
        value: number;
        timezoneOffset: number;
        compare(dt: Datetime): number;
        equals(dt: Datetime): boolean;
        between(begin: Datetime, end: Datetime): boolean;
        addYears(years: number): Datetime;
        addMonths(months: number): Datetime;
        addWeeks(weeks: number): Datetime;
        addDays(days: number): Datetime;
        addHours(hours: number): Datetime;
        addMinutes(minutes: number): Datetime;
        addSeconds(seconds: number): Datetime;
        addMilliseconds(millis: number): Datetime;
        addDayFractions(fraction: number): Datetime;
        millisDiff(dt: Datetime): number;
        add(delta: DatetimeDiff): Datetime;
        toString(format?: string): string;
        toJsDate(): Date;
        withoutTimezoneOffset(): Datetime;
        isNull(): boolean;
    }
    export function now(withMillis?: boolean): Datetime;
    export function parse(str: string, format?: string): Datetime;
    export function fromJsDate(jsDate: Date): Datetime;
    export function fromMillis(value: number): Datetime;
    export function make(year: number, month: number, day: number, hour: number, minute: number, second: number, millis: number): Datetime;
    export function makeUtc(year: number, month: number, day: number, hour: number, minute: number, second: number, millis: number): Datetime;
    export function isDatetime(obj: any): boolean;
    export const sunday: number;
    export const Sunday: number;
    export const monday: number;
    export const Monday: number;
    export const tuesday: number;
    export const Tuesday: number;
    export const wednesday: number;
    export const Wednesday: number;
    export const thursday: number;
    export const Thursday: number;
    export const friday: number;
    export const Friday: number;
    export const saturday: number;
    export const Saturday: number;
    export function walkFormat(format: string, map: {
        [key: string]: (arg: any) => void;
    }): void;
}

declare module 'syracuse-core/types/time' {
    import { TypeConstraints } from 'syracuse-core/types/type-constraints';
    export function validate(value: any, constraints: TypeConstraints, errors: string[]): void;
    export type TimeDiff = {
        hours?: number;
        minutes?: number;
        seconds?: number;
        millis?: number;
    };
    export class Time {
        _value: number;
        constructor(value: number);
        hour: number;
        minute: number;
        second: number;
        value: number;
        valueOf(): string;
        compare(time: Time): number;
        equals(time: Time): boolean;
        between(begin: Time, end: Time): boolean;
        begOfDay(): Time;
        endOfDay(): Time;
        begOfHour(): Time;
        endOfHour(): Time;
        begOfMinute(): Time;
        endOfMinute(): Time;
        toString(format?: string): string;
        secondsDiff(t: Time): number;
        addHours(hours: number): Time;
        addMinutes(minutes: number): Time;
        addSeconds(seconds: number): Time;
        add(delta: TimeDiff): Time;
        isNull(): boolean;
    }
    export function make(hour: number, minute: number, second: number): Time;
    export function fromSeconds(seconds: number): Time;
    export function fromJsDate(js: Date, utc?: boolean): Time;
    export function now(utc?: boolean): Time;
    export function parse(str: string, format?: string): Time;
    export function amDesignator(): string;
    export function pmDesignator(): string;
    export function isTime(obj: any): boolean;
}

declare module 'syracuse-core/types/decimal' {
    import { TypeConstraints } from 'syracuse-core/types/type-constraints';
    export const resources: any;
    export function validate(value: any, constraints: TypeConstraints, errors: string[]): number;
    export type RoundingMode = number;
    export const RoundingMode: {
        CEILING: number;
        DOWN: number;
        FLOOR: number;
        HALF_DOWN: number;
        HALF_EVEN: number;
        HALF_UP: number;
        UNNECESSARY: number;
        UP: number;
        HALF_CEILING: number;
    };
    export class BigDecimal {
        _value: jsbn.BigInteger;
        _scale: number;
        max_scale: number;
        rounding_mode: number;
        constructor(value: any, scale?: number, bInt?: jsbn.BigInteger);
        _zero(size: number): string;
        _factorInt(value?: number, signum?: number): any;
        _roundToScale(scale: number, roundingMode: RoundingMode): void;
        parse(value: string, ts: string, ds: string): BigDecimal;
        clone(): BigDecimal;
        abs(): BigDecimal;
        add(augend: BigDecimal): BigDecimal;
        compareTo(val: BigDecimal): number;
        divide(divisor: BigDecimal, scale: number, roundingMode: RoundingMode): BigDecimal;
        multiply(multiplicand: BigDecimal, scale: number, roundingMode: RoundingMode): BigDecimal;
        negate(): BigDecimal;
        scale(): number;
        setScale(newScale: number, roundingMode: RoundingMode): BigDecimal;
        signum(): number;
        subtract(subtrahend: BigDecimal): BigDecimal;
        numberValue(): number;
        toString(gs?: string, ds?: string, size?: number): string;
    }
    export function make(value: any, scale?: number): BigDecimal;
    export const parseOld: (value: string, ts: string, ds: string) => BigDecimal;
    export const ZERO: () => BigDecimal;
    export const ONE: () => BigDecimal;
    export const TEN: () => BigDecimal;
    export function format(val: any, format: string): string;
    export function parse(str: string, format: string): BigDecimal;
    export function add(n1: BigDecimal, n2: BigDecimal): BigDecimal;
    export function subtract(n1: BigDecimal, n2: BigDecimal): BigDecimal;
    export function numberValue(val: BigDecimal): number;
    export const defaultValue: number;
}

declare module 'syracuse-core/types/integer' {
    import { TypeConstraints } from 'syracuse-core/types/type-constraints';
    export function validate(value: any, constraints: TypeConstraints, errors: string[]): void;
    export function parse(str: string, format: string): number;
    export function format(val: number, format: string): string;
    export function add(n1: number, n2: number): number;
    export function subtract(n1: number, n2: number): number;
    export function numberValue(val: any): number;
    export const defaultValue: number;
}

declare module 'syracuse-core/types/real' {
    import { TypeConstraints } from 'syracuse-core/types/type-constraints';
    export function validate(value: any, constraints: TypeConstraints, errors: string[]): void;
    export const defaultValue: number;
    export function format(val: number, format: string): string;
    export function parse(str: string, format: string): number;
    export function add(n1: number, n2: number): number;
    export function subtract(n1: number, n2: number): number;
    export function numberValue(val: any): number;
}

declare module 'syracuse-core/types/string' {
    import { TypeConstraints } from 'syracuse-core/types/type-constraints';
    export function validate(value: any, constraints: TypeConstraints, errors: string[]): void;
}

declare type EnumValue = {
	$value: number;
}

declare module 'syracuse-core/types/type-constraints' {
    export interface TypeConstraints {
        $isMandatory?: boolean;
        $isNullable?: boolean;
        $minimum?: number;
        $maximum?: number;
        $minimumCanEqual?: boolean;
        $maximumCanEqual?: boolean;
        $divisibleBy?: number;
        $enum?: EnumValue[];
        $minLength?: number;
        $maxLength?: number;
        $pattern?: string;
        $patternModifiers?: string;
        $patternMessage?: string;
    }
}

declare module 'syracuse-core/resource/resourceProxy' {
    export class Template {
        expression: string;
        matches: any[];
        constructor(expression: string);
        _getPathValue(path: string, obj: any): any;
        isTemplate(): boolean;
        resolve(obj: any, fallbackObj: any): string;
    }
    export interface Prototype {
        $properties: any;
    }
    export class Resource {
        _proto: Prototype;
        _instance: {};
        _relativePath: string;
        static createSubResource: (parentResource: Resource, path: string) => Resource;
        constructor(proto: Prototype, instance: any);
        _getAbsolutePath(propertyPath: string): string;
        _getInstanceValue(propertyPath: string, pathIsAbsolute?: boolean): any;
        _getProtoValue(propertyPath: string, pathIsAbsolute?: boolean): any;
        _getValue(propertyPath: string, obj: any, pathIsAbsolute?: boolean): any;
        _getMatchesFromExpression(expression: string): RegExpMatchArray;
        getValue(propertyPath: string): any;
        setValue(propertyPath: string, val: any): void;
        getChildProto(propertyPath: string): any;
        createChild(propertyPath: string, data: any): Resource;
        parse(expression: string): string;
        getTemplateInfo(propertyPath: string): {
            linkedProperties: string[];
        };
    }
}

declare module 'syracuse-core/resource/util' {
    export interface Typed {
        type: string;
        scale?: number;
        $isArray?: boolean;
    }
    export function parseValue(prop: Typed, val: string): any;
    export function formatValue(prop: Typed, val: any, name: string): any;
    export function compare(prop: Typed, a: any, b: any): number;
    export function parseCapabilities(capabilities: string): any;
}

