"use strict";

var helpers = require('syracuse-core/lib/helpers');
var tracer = require("syracuse-trace/lib/helper").getTracer("notifications");
var globals = require('streamline/lib/globals');
var util = require('util');
var io = require('socket.io');
var socketio;
var traceNotification = require("syracuse-trace/lib/helper").getTracer("notifications");


var SocketHandler = helpers.defineClass(function() {
	this.listSocketEvent = {};

}, null, {
	/*
	 * the socket io pusher needs to have a property socketIoEvent in order to push event
	 * socketIoEvent
	 */
	register: function(id, socketIoEvent) {
		this.listSocketEvent[id] = socketIoEvent;
		this.initEvents(); // reinitialize event to manage
	},
	unregister: function(id) {
		delete this.listSocketEvent[id];
		this.initEvents(); // reinitialize event to manage
	},
	initEvents: function() {
		var self = this;
		socketio = socketio || Â require('syracuse-main/lib/syracuse').socketio;
		Object.keys(this.listSocketEvent).forEach(function(key) {
			var event = self.listSocketEvent[key];
			if (event) {
				socketio && socketio.of(event.path).on('connection', function(socket) {
					// call on connection
					// override socket emit method to log push server request if it's necessary

					traceNotification.debug && traceNotification.debug("receive connection event headers=" + JSON.stringify(socket.handshake.headers));
					event.onConnection(socket, socket.handshake);

					event.message && Object.keys(event.message).forEach(function(k) {
						var message = event.message[k];
						socket.on(k, function(data) {
							traceNotification.debug && traceNotification.debug("receive event " + k + " data" + JSON.stringify(data) + " headers=" + JSON.stringify(socket.handshake.headers));
							message(socket, this.handshake, data);
						});
					});
				});
			}
		});

	}

});
var _socketHandler = new SocketHandler();

exports.socketHandler = _socketHandler;