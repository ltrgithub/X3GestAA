"use strict";

var helpers = require('syracuse-core/lib/helpers');
var tracer = require("syracuse-trace/lib/helper").getTracer("notifications");
var globals = require('streamline/lib/globals');
var util = require('util');
var io = require('socket.io');
var socketio;
var traceNotification = require("syracuse-trace/lib/helper").getTracer("notifications");
var config = require('config');
var configNotif = config && config.notifications ||  {};

var SocketHandler = helpers.defineClass(function() {
	this.listSocketEvent = {};

}, null, {
	/// !doc
	///
	/// # socketHandle API
	/// This module allow the framework to register any kind of event in order
	//  to receive push server message and emit in return message to server
	/// ``` javascript
	/// var SocketHandler = require('syracuse-x3/lib/notifications/SocketHandler').create();
	///
	///

	///
	/// # register socketio event and initialize all event on the framework
	/// register for a specific path and socket io callback depending of event
	///  register(id,path,connectionCallBack [, onDisconnectionHandler, listEventCallBack])
	///
	///  id : identifier of the register module. This allow the module to register and unregister the event
	///  path : http path for reception of event (i.e : "/session")
	///  connectionCallBack : function that will be call on connection event
	///  onDisconnectionHandler : functon that will be call when the client is deconnected (event send by the client or detection of closed socket)
	///  listEventCallBack : list of event name and function that will be call on event reception
	///  var connectionCallBack = function( socket, handshake ){
	///      /// some code
	///  }
	///  var onDisconnectionHandler = function( socket ){
	///      /// some code
	///  }
	///
	///  var listEventCallBack = {
	///      "eventName1" : function( socket, handshake, data){ ... },
	///      "eventName2" : function( socket, handshake, data){ ... },
	///      ....
	///  }
	///
	///
	register: function(id, namespace, onConnectionHandler, onDisconnectionHandler, onEventHandler, onRoomEvent) {
		if (!id || !namespace ||  !onConnectionHandler) {
			throw new Error("mandatory parameter is missing");
		}
		this.listSocketEvent[id] = {
			namespace: namespace,
			onConnection: onConnectionHandler,
			onDisconnected: onDisconnectionHandler,
			message: onEventHandler
		};
		this.initEvents(); // reinitialize event to manage
	},

	///
	/// # unregister socketio event and remove all event that are initialized
	///  unregister a socket events list identified by an id
	///  unregister(id)
	///
	///  id : identifier of the register module. This allow the module to register and unregister the event
	///  path : http path for reception of event (i.e : "/session")
	///  connectionCallBack : function that will be call on connection event
	///  listEventCallBack : list of event name and function that will be call on event reception
	///  var connectionCallBack = function( socket, handshake ){
	///      /// some code
	///  }
	///
	///  var listEventCallBack = {
	///      "eventName1" : function( socket, handshake, data){ ... },
	///      "eventName2" : function( socket, handshake, data){ ... },
	///      ....
	///  }
	///
	///
	unregister: function(id) {
		if (this.listSocketEvent[id]) {
			delete this.listSocketEvent[id];
			this.initEvents(); // reinitialize event to manage
		}
	},

	///
	/// # initEvent
	/// initialize all socket event registered.
	///
	initEvents: function() {
		var self = this;
		socketio = socketio ||  require('syracuse-main/lib/syracuse').socketio;
		Object.keys(this.listSocketEvent).forEach(function(key) {
			var event = self.listSocketEvent[key];
			if (event) {
				socketio && socketio.of(event.namespace).on('connection', function(socket) {
					// add isOpen function to the socket
					socket.isOpened = function() {
						return socket.conn.readyState === 'open';
					};

					// set a check interval if disconnected function is defined
					if (event.onDisconnected) {
						/*setInterval(function(socket) {
							if (socket.conn.readyState === 'open')
								event.onDisconnected(socket, socket.handshake);
						}, configNotif.checkDisconnect);*/
						socket.on('disconnect', function(data) {
							event.onDisconnected(socket, socket.handshake);
						});
					}
					// call on connection
					// override socket emit method to log push server request if it's necessary

					traceNotification.debug && traceNotification.debug("receive connection event headers=" + JSON.stringify(socket.handshake.headers));
					event.onConnection(socket, socket.handshake);

					event.message && Object.keys(event.message).forEach(function(k) {
						var message = event.message[k];
						socket.on(k, function(data) {
							traceNotification.debug && traceNotification.debug("receive event " + k + " data" + JSON.stringify(data) + " headers=" + JSON.stringify(socket.handshake.headers));
							message(socket, socket.handshake, data);
						});
					});

				});
			}
		});

	}

});

var _socketHandler = new SocketHandler();

exports.socketHandler = _socketHandler;