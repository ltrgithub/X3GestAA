"use strict";

var helpers = require('syracuse-core/lib/helpers');
var tracer = require("syracuse-trace/lib/helper").getTracer("notifications");
var globals = require('streamline/lib/globals');
var eventManager = require('syracuse-notification/lib/eventManager');
var util = require('util');
var io = require('socket.io');
var sessionManager = require('syracuse-session/lib/sessionManager').sessionManager;
var socket;

var _cb = function(error, data) {
	if (error) throw error;
	return data;
};

var clients = {};

var getSocketByLogin = exports.getSocketByLogin = function(client, logins) {
	var res = [];
	logins.forEach(function(login) {
		if (clients[login]) clients[login].forEach(function(id) {
			var _sockets = socket.sockets.sockets.filter(function(s) {
				return s.id === id;
			});
			if (_sockets.length > 0) {
				if (!client || (client && _sockets[0].id !== client.id)) res.push({
					login: login,
					socket: _sockets[0]
				});
			}
		});
	});
	return res;
};


var SocketHandler = helpers.defineClass(function(_) {
	socket = socket || require('syracuse-main/lib/syracuse').socket;
	this.initEvents(_);
}, null, {
	initEvents: function(_) {
		var self = this;
		socket.on('connection', function(client) {

			//console.log("CLIENT: "+util.inspect(client,null,3));

			client.on('login', function(login) {
				tracer.info && tracer.info("* IO CONNECT: " + login);
				//tracer.info && tracer.info("* IO CLIENT: " + util.inspect(client, null, 3));
				clients[login] = clients[login] || [];
				clients[login].push(client.id);

				var cookie = client.handshake.headers.cookie;
				var session = sessionManager.sessionByCookie(cookie, "8124");
				session._ioclient = client;
			});


			//console.log("SOCKETS: "+util.inspect(clients,null,3));

			//console.log("CLIENTS: "+util.inspect(clients,null,3));
			tracer.info && tracer.info("Client connected");
			client.on('message', function(event) {
				(function(_) {
					tracer.info && tracer.info("* IO MESSAGE SENT BY CLIENT: " + JSON.stringify(event, null, 2));
					var message = eventManager.createMessage(_, event.type, event.title, event.message, event.from, event.to, event.severity, event.link);
					//
					if (event.to && Array.isArray(event.to)) {
						var _sockets = getSocketByLogin(client, event.to);
						_sockets.forEach(function(_s) {
							tracer.info && tracer.info("* EMIT MESSAGE TO '" + _s.login + "' on socket '" + _s.socket.id + "'");
							_s.socket.emit('message', message);
						});

					} else if (event.to === "*") {
						tracer.info && tracer.info("* EMIT MESSAGE TO EVERY CONNECTED USERS");
						client.broadcast.emit('message', message);
					}
				})(_ >> _cb);
			});

			client.on('get events', function(login, count, fn) {
				(function(_) {
					tracer.info && tracer.info("* IO GET EVENTS");
					var events = eventManager.getEvents(_, login, count || 20);
					fn(events);
				})(_ >> _cb);
			});

			client.on('get users', function(count, fn) {
				tracer.info && tracer.info("* IO GET USERS");
				var users = Object.keys(clients);
				fn(users);
			});

			client.on('disconnect', function(login) {
				tracer.info && tracer.info("* IO DISCONNECT");
				delete clients[login];
				client.broadcast.emit('update users', Object.keys(clients));
				client.leave(client.room);
			});

		});
	}
});

exports.create = function(_) {
	tracer.info && tracer.info("Create socket handler");
	var sh = new SocketHandler(_);
};