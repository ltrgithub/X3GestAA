"use strict";

var helpers = require('syracuse-core/lib/helpers');
var tracer = require("syracuse-trace/lib/helper").getTracer("notifications");
var globals = require('streamline-runtime').globals;
var util = require('util');
var io = require('socket.io');
var traceNotification = require("syracuse-trace/lib/helper").getTracer("notifications");
var config = require('config');
var configNotif = config && config.notifications || {};

// export only for unit test The
var SocketHandler = helpers.defineClass(function(socketio) {
	this.listSocketEvent = {};
	if (socketio) {
		this.setSocketIo(socketio);
	}
	//FOR UNIT TEST with client -  default event manage for unit test
	if (config.system && config.system.enableDevelopmentFeatures) {
		var self = this;
		this.register("/unit_test", function(io, hd) {
			io.emit("connectTest");
		}, function(io, hd) {
			// disconnected
		}, {
			event1: function(io, hd, data) {
				io.emit("eventClient1", data);
			},
			event2: function(io, hd, data) {
				io.emit('eventClient2', data);
			},
			unregisterEvent: function(io, hd, namespace) {
				io.emit("delDynEvent", "unit_test2");
				io.emit("connectTest");
				self.unregister(namespace);

			},
			registerEvent: function(io, hd, namespace) {

				self.register(namespace, function(io2, hd) {
					io2.emit("connectTest");
				}, function(io2, hd) {
					//nothin
				}, {

					dynamicEvent1: function(io2, hd, data) {
						io2.emit("eventDynamicClient1", data);
					},
					dynamicEvent2: function(io2, hd, data) {
						io2.emit('eventDynamicClient2', data);
					}
				});
			}
		});
	}
}, null, {

	setSocketIo: function(socketio) {
		var self = this;
		this.socketio = socketio;
		// define configuration
		Object.keys(configNotif).forEach(function(k) {
			self.socketio.set(k, configNotif[k]);
		});
		// reinit event for module that have register before association between http server and socket io
		this.initEvents();
	},
	/// !doc
	///
	/// # socketHandle API
	/// This module allow the framework to register any kind of event in order
	//  to receive push server message and emit in return message to server
	/// ```javascript
	/// var SocketHandler = require('syracuse-x3/lib/notifications/SocketHandler');
	/// var socketHandlerInst = SocketHandler.getSocketHandler(socketio)
	/// ```
	/// or
	/// ```javascript
	/// var socketHandlerInst = SocketHandler.getSocketHandler()
	/// ```
	///

	///
	/// # register
	/// register for a specific path and socket io callback depending of event
	/// ```javascript
	///  register(namespace,connectionCallBack [, onDisconnectionHandler, listEventCallBack])
	/// ```
	///  namespace : http path for reception of event (i.e : "/session")
	///  connectionCallBack : function that will be call on connection event
	///  onDisconnectionHandler : functon that will be call when the client is deconnected (event send by the client or detection of closed socket)
	///  listEventCallBack : list of event name and function that will be call on event reception
	/// ```javascript
	///
	///  var connectionCallBack = function( socket, handshake ){
	///      /// some code
	///  }
	///  var onDisconnectionHandler = function( socket ){
	///      /// some code
	///  }
	///
	///  var listEventCallBack = {
	///      "eventName1" : function( socket, handshake, data){ ... },
	///      "eventName2" : function( socket, handshake, data){ ... },
	///      ....
	///  }
	/// ```
	///
	register: function(namespace, onConnectionHandler, onDisconnectionHandler, onEventHandler, optConfig) {
		if (!namespace || Â !onConnectionHandler) {
			throw new Error("mandatory parameter is missing");
		}
		traceNotification.debug && traceNotification.debug(" namespace " + namespace);
		this.listSocketEvent[namespace] = {
			namespace: namespace.indexOf("/") !== 0 ? "/" + namespace : namespace,
			onConnection: onConnectionHandler,
			onDisconnection: onDisconnectionHandler,
			message: onEventHandler
		};
		this.initEvents(this.listSocketEvent[namespace]); // reinitialize event to manage

	},

	///
	/// # unregister
	///  unregister a socket events list identified by an id
	/// ```javascript
	///  unregister(namespace)
	/// ```
	///  id : identifier of the register module. This allow the module to register and unregister the event
	///  path : http path for reception of event (i.e : "/session")
	///  connectionCallBack : function that will be call on connection event
	///  listEventCallBack : list of event name and function that will be call on event reception`
	/// ```javascript
	///  var connectionCallBack = function( socket, handshake ){
	///      /// some code
	///  }
	///
	///  var listEventCallBack = {
	///      "eventName1" : function( socket, handshake, data){ ... },
	///      "eventName2" : function( socket, handshake, data){ ... },
	///      ....
	///  }
	/// ```
	///
	unregister: function(namespace) {

		if (this.listSocketEvent[namespace]) {
			traceNotification.debug && traceNotification.debug("register " + namespace);
			delete this.listSocketEvent[namespace];
			this.resetEvents(namespace); // reinitialize event to manage
			delete this.listSocketEvent[namespace];
		}

	},

	resetEvents: function(event) {
		this.socketio && this.socketio.of(event.namespace).on('connection', function(socket) {
			// nothin
		});
	},
	///
	/// # initEvent
	/// ```javascript
	/// initEvents()
	/// ```
	/// initialize all socket event registered.
	///
	initEvents: function(event) {
		var self = this;

		function initEvent(event) {
			if (event) {
				self.socketio && self.socketio.of(event.namespace).on('connection', function(socket) {
					// add isOpen function to the socket
					socket.isOpened = function() {
						return socket.conn.readyState === 'open';
					};


					if (event.onDisconnection) {

						socket.on('disconnect', function(data) {
							event.onDisconnection(socket, socket.handshake);
						});

						socket.on('forceDisconnect', function(data) { // force disconnection
							socket.disconnect();
						});
					}
					// call on connection
					// override socket emit method to log push server request if it's necessary

					traceNotification.debug && traceNotification.debug("receive connection event headers=" + JSON.stringify(socket.handshake.headers));
					event.onConnection(socket, socket.handshake);

					event.message && Object.keys(event.message).forEach(function(k) {
						var message = event.message[k];
						socket.on(k, function(data) {
							traceNotification.debug && traceNotification.debug("receive event " + k + " data" + JSON.stringify(data) + " headers=" + JSON.stringify(socket.handshake.headers));
							message(socket, socket.handshake, data);
						});
					});

				});
			}
		}
		if (event) { // if event defined. we init only that one
			initEvent(event);

		} else { // else we reinit all event
			Object.keys(this.listSocketEvent).forEach(function(key) {
				initEvent(self.listSocketEvent[key]);
			});
		}


	}

});

var _socketHandler = null;
///
/// # getSocketHandler
///  static method that allow to get the singleton instance for socket.io event handler manager
///  retrieve the socketHandler instance that manage all socket io event registered.
/// ```javascript
///  getSocketHandler()
/// ```
/// in that case as no socket.io instance is define to the socket handler we'll need to set the socket.io instance by using socket.io and only in that case the event will be taken in account
///

exports.getSocketHandler = function() {
	if (!_socketHandler) {
		_socketHandler = new SocketHandler();
	}
	return _socketHandler;
};