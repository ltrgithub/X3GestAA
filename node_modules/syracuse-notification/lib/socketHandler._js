"use strict";

var helpers = require('syracuse-core/lib/helpers');
var tracer = require("syracuse-trace/lib/helper").getTracer("notifications");
var globals = require('streamline/lib/globals');
var util = require('util');
var io = require('socket.io');
var traceNotification = require("syracuse-trace/lib/helper").getTracer("notifications");
var config = require('config');
var configNotif = config && config.notifications ||  {};

// export only for unit test The
var SocketHandler = helpers.defineClass(function(socketio) {
	this.listSocketEvent = {};
	if (socketio) {
		this.setSocketIo(socketio);
	}
	//FOR UNIT TEST with client -  default event manage for unit test
	if (config.system && config.system.enableDevelopmentFeatures) {
		var self = this;
		this.register("unit_test", "/unit_test", function(io, hd) {
			io.emit("connectTest");
		}, function(io, hd) {
			// disconnected
		}, {
			event1: function(io, hd, data) {
				io.emit("eventClient1", data);
			},
			event2: function(io, hd, data) {
				io.emit('eventClient2', data);
			},
			unregisterEvent: function(io, hd) {
				io.emit("delDynEvent");
				io.emit("connectTest");
				self.unregister("unit_test2");

			},
			registerEvent: function(io, hd, data) {

				self.register("unit_test2", data, function(io2, hd) {
					io2.emit("connectTest");
				}, function(io2, hd) {
					//nothin
				}, {

					dynamicEvent1: function(io2, hd, data) {
						io2.emit("eventDynamicClient1", data);
					},
					dynamicEvent2: function(io2, hd, data) {
						io2.emit('eventDynamicClient2', data);
					}
				});
			}
		});
	}
}, null, {

	setSocketIo: function(socketio) {
		var self = this;
		this.socketio = socketio;
		// define configuration
		Object.keys(configNotif).forEach(function(k) {
			self.socketio.set(k, configNotif[k]);
		});

	},
	/// !doc
	///
	/// # socketHandle API
	/// This module allow the framework to register any kind of event in order
	//  to receive push server message and emit in return message to server
	/// ``` javascript
	/// var SocketHandler = require('syracuse-x3/lib/notifications/SocketHandler').create();
	/// ```
	///

	///
	/// # register socketio event and initialize all event on the framework
	/// register for a specific path and socket io callback depending of event
	///  register(id,path,connectionCallBack [, onDisconnectionHandler, listEventCallBack])
	///
	///  id : identifier of the register module. This allow the module to register and unregister the event
	///  path : http path for reception of event (i.e : "/session")
	///  connectionCallBack : function that will be call on connection event
	///  onDisconnectionHandler : functon that will be call when the client is deconnected (event send by the client or detection of closed socket)
	///  listEventCallBack : list of event name and function that will be call on event reception
	/// ``` javascript
	///
	///  var connectionCallBack = function( socket, handshake ){
	///      /// some code
	///  }
	///  var onDisconnectionHandler = function( socket ){
	///      /// some code
	///  }
	///
	///  var listEventCallBack = {
	///      "eventName1" : function( socket, handshake, data){ ... },
	///      "eventName2" : function( socket, handshake, data){ ... },
	///      ....
	///  }
	/// ```
	///
	register: function(id, namespace, onConnectionHandler, onDisconnectionHandler, onEventHandler, optConfig) {
		if (!id || !namespace ||  !onConnectionHandler) {
			throw new Error("mandatory parameter is missing");
		}
		this.listSocketEvent[id] = {
			namespace: namespace,
			onConnection: onConnectionHandler,
			onDisconnection: onDisconnectionHandler,
			message: onEventHandler
		};
		this.initEvents(); // reinitialize event to manage

	},

	///
	/// # unregister socketio event and remove all event that are initialized
	///  unregister a socket events list identified by an id
	///  unregister(id)
	///
	///  id : identifier of the register module. This allow the module to register and unregister the event
	///  path : http path for reception of event (i.e : "/session")
	///  connectionCallBack : function that will be call on connection event
	///  listEventCallBack : list of event name and function that will be call on event reception`
	/// ``` javascript
	///  var connectionCallBack = function( socket, handshake ){
	///      /// some code
	///  }
	///
	///  var listEventCallBack = {
	///      "eventName1" : function( socket, handshake, data){ ... },
	///      "eventName2" : function( socket, handshake, data){ ... },
	///      ....
	///  }
	/// ```
	///
	unregister: function(id) {
		if (this.listSocketEvent[id]) {
			delete this.listSocketEvent[id];
			this.initEvents(); // reinitialize event to manage
		}

	},

	///
	/// # initEvent
	/// initialize all socket event registered.
	///
	initEvents: function() {
		var self = this;
		Object.keys(this.listSocketEvent).forEach(function(key) {
			var event = self.listSocketEvent[key];

			if (event) {

				self.socketio && self.socketio.of(event.namespace).on('connection', function(socket) {
					// add isOpen function to the socket
					socket.isOpened = function() {
						return socket.conn.readyState === 'open';
					};


					if (event.onDisconnecton) {

						socket.on('disconnect', function(data) {
							event.onDisconnection(socket, socket.handshake);
						});

						socket.on('forceDisconnect', function(data) { // force disconnection
							socket.disconnect();
						});
					}
					// call on connection
					// override socket emit method to log push server request if it's necessary

					traceNotification.debug && traceNotification.debug("receive connection event headers=" + JSON.stringify(socket.handshake.headers));
					event.onConnection(socket, socket.handshake);

					event.message && Object.keys(event.message).forEach(function(k) {
						var message = event.message[k];
						socket.on(k, function(data) {
							traceNotification.debug && traceNotification.debug("receive event " + k + " data" + JSON.stringify(data) + " headers=" + JSON.stringify(socket.handshake.headers));
							message(socket, socket.handshake, data);
						});
					});

				});
			}

		});

	}

});

var _socketHandler = null;
///
/// # getSocketHandler
///  retrieve the socketHandler instance that manage all socket io event registered
///  getSocketHandler(socketio)
///
///  socketio : socket.io instance
///

exports.getSocketHandler = function(socketio) {
	if (!_socketHandler) {
		_socketHandler = new SocketHandler(socketio); // without socketIo
	}
	return _socketHandler;
};