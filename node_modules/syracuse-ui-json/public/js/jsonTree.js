"use strict";

require("syracuse-ui/deps/d3");
var indentedTree = require("syracuse-ui-json/public/js/indentedTree");
var collapsibleTree = require("syracuse-ui-json/public/js/collapsibleTree");

exports.create = function(div, mode) {
	var value;
	return {
		setValue: function(val) {
			value = val;
			$(div).empty();

			var diagonal = d3.svg.diagonal()
				.projection(function(d) {
					return [d.y, d.x];
				});

			var root = refactor(val, "Tree");

			switch (mode) {
				case "indented":
					indented();
					break;
				case "collapsible":
					collapsible();
					break;
				default:
					indented();
			}

			// Functions
			function indented() {
				var margin = {
					top: 30,
					right: 20,
					bottom: 30,
					left: 20
				};
				var width = $(div).width() - margin.right - margin.left;
				var barHeight = 20;
				var barWidth = width * .8;
				var duration = 400;
				var minHeight = 300;
				var indentMin = width * .02;
				var indentMax = width * .15;
				var svg = d3.select(div).append("svg")
					.attr("width", width + margin.left + margin.right)
					.append("g")
					.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
				var tree = d3.layout.tree()
					.size([indentMin, indentMax]);

				var update = indentedTree.updater({
					barHeight: barHeight,
					barWidth: barWidth,
					duration: duration,
					diagonal: diagonal,
					minHeight: minHeight,
					margin: margin,
					root: root,
					svg: svg,
					tree: tree,
					width: width,
				});
				root.x0 = 0;
				root.y0 = 0;
				root.children.forEach(collapse);
				update(root);
			}

			function collapsible() {
				var margin = {
					top: 20,
					right: 120,
					bottom: 20,
					left: 120
				};
				var width = $(div).width() - margin.right - margin.left;
				var height = 800;
				var heightMinusMargin = height - margin.top - margin.bottom;
				var duration = 750;
				var sizeBranch = 180;
				var svg = d3.select(div).append("svg")
					.attr("height", height)
					.append("g")
					.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
				var tree = d3.layout.tree()
					.size([heightMinusMargin, width]);
				$(div).addClass("json-ui-overflow-x");

				var update = collapsibleTree.updater({
					diagonal: diagonal,
					duration: duration,
					root: root,
					sizeBranch: sizeBranch,
					svg: svg,
					tree: tree,
				});
				root.x0 = heightMinusMargin / 2;
				root.y0 = 0;
				root.children.forEach(collapse);
				update(root);
				d3.select(self.frameElement).style("height", height + "px");
			}

			function refactor(val, name) {
				var data = {};
				data.name = name;
				if (typeof val === "object") {
					data.children = Object.keys(val).map(function(elt, i) {
						return refactor(val[elt], elt);
					});
				} else {
					data.name += ": " + val;
				}
				return data;
			}

			function collapse(d) {
				if (d.children) {
					d._children = d.children;
					d._children.forEach(collapse);
					d.children = null;
				}
			}
		},
		getValue: function() {
			return value;
		}
	};
};