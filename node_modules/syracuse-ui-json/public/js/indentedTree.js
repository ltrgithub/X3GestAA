"use strict";

['/syracuse-ui-json/public/css/indentedTree.css'].forEach(function(href) {
	$("<link/>", {
		rel: "stylesheet",
		type: "text/css",
		href: href,
	}).appendTo("head");
});

exports.updater = function(options) {
	// Init options
	var barHeight = options.barHeight;
	var barWidth = options.barWidth;
	var duration = options.duration;
	var diagonal = options.diagonal;
	var margin = options.margin;
	var minHeight = options.minHeight;
	var root = options.root;
	var svg = options.svg;
	var tree = options.tree;
	var width = options.width;
	var i = 0;

	function color(d) {
		return d._children ? "#3182bd" : d.children ? "#c6dbef" : "#fd8d3c";
	}

	// Toggle children on click.
	function click(d) {
		if (d.children) {
			d._children = d.children;
			d.children = null;
		} else {
			d.children = d._children;
			d._children = null;
		}
		update(d);
	}

	function update(source) {
		// Compute the flattened node list. TODO use d3.layout.hierarchy.
		var nodes = tree.nodes(root);
		var height = Math.max(minHeight, nodes.length * barHeight + margin.top + margin.bottom);

		d3.select("svg").transition()
			.duration(duration)
			.attr("height", height);

		d3.select(self.frameElement).transition()
			.duration(duration)
			.style("height", height + "px");

		// Compute the "layout".
		nodes.forEach(function(n, i) {
			n.x = i * barHeight;
		});

		// Update the nodes…
		var node = svg.selectAll("g.json-ui-indented-node")
			.data(nodes, function(d) {
				return d.id || (d.id = ++i);
			});

		var nodeEnter = node.enter().append("g")
			.attr("class", "json-ui-indented-node")
			.attr("transform", function(d) {
				return "translate(" + source.y0 + "," + source.x0 + ")";
			})
			.style("opacity", 1e-6);

		// Enter any new nodes at the parent's previous position.
		nodeEnter.append("rect")
			.attr("y", -barHeight / 2)
			.attr("height", barHeight)
			.attr("width", barWidth)
			.style("fill", color)
			.on("click", click);

		nodeEnter.append("text")
			.attr("dy", 3.5)
			.attr("dx", 5.5)
			.text(function(d) {
				return d.name;
			});

		// Transition nodes to their new position.
		nodeEnter.transition()
			.duration(duration)
			.attr("transform", function(d) {
				return "translate(" + d.y + "," + d.x + ")";
			})
			.style("opacity", 1);

		node.transition()
			.duration(duration)
			.attr("transform", function(d) {
				return "translate(" + d.y + "," + d.x + ")";
			})
			.style("opacity", 1)
			.select("rect")
			.style("fill", color);

		// Transition exiting nodes to the parent's new position.
		node.exit().transition()
			.duration(duration)
			.attr("transform", function(d) {
				return "translate(" + source.y + "," + source.x + ")";
			})
			.style("opacity", 1e-6)
			.remove();

		// Update the links…
		var link = svg.selectAll("path.json-ui-indented-link")
			.data(tree.links(nodes), function(d) {
				return d.target.id;
			});

		// Enter any new links at the parent's previous position.
		link.enter().insert("path", "g")
			.attr("class", "json-ui-indented-link")
			.attr("d", function(d) {
				var o = {
					x: source.x0,
					y: source.y0
				};
				return diagonal({
					source: o,
					target: o
				});
			})
			.transition()
			.duration(duration)
			.attr("d", diagonal);

		// Transition links to their new position.
		link.transition()
			.duration(duration)
			.attr("d", diagonal);

		// Transition exiting nodes to the parent's new position.
		link.exit().transition()
			.duration(duration)
			.attr("d", function(d) {
				var o = {
					x: source.x,
					y: source.y
				};
				return diagonal({
					source: o,
					target: o
				});
			})
			.remove();

		// Stash the old positions for transition.
		nodes.forEach(function(d) {
			d.x0 = d.x;
			d.y0 = d.y;
		});
	}

	return update;
};