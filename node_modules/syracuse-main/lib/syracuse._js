"use strict";

var http = require('http');
var fs = require('fs');
var path = require('path');
var config = require('./nodeconfig').config; // must be first syracuse require
var locale = require('syracuse-core/lib/locale');
var sdata = require('syracuse-sdata/lib/sdataDispatch');
var soap = require('syracuse-soap/lib/server/soapDispatch');
var x3Disp = require('syracuse-x3/lib/x3Dispatch');
var upload = require('streamline-upload/lib/upload');
var EventEmitter = require('events').EventEmitter;
var port = config.port || 8124;
var basePath = path.join(path.dirname(module.filename), "../..");
var helpers = require('syracuse-core/lib/helpers');
var testServer = require('test-runner/lib/server/testServer');
var sessionManager = require('syracuse-session/lib/sessionManager').sessionManager;
var proxyManager = require('syracuse-proxy/lib/proxy').proxyManager;
var requireDispatcher = require('streamline-require/lib/server/require').dispatcher({
	getResources: locale.getResourcesHook
});
var liveServer = require('syracuse-live/lib/liveServer').liveServer;
var x3Pool = require('syracuse-x3/lib/pool');
var streams = require('streamline/lib/streams/streams');
var factory = require('syracuse-orm/lib/factory');
var mongodb = require('syracuse-orm/lib/mongoDbHandle');
var searchEngine = require('syracuse-search/lib/elasticSearch');
var adminUtil = require('syracuse-collaboration/lib/util');
var adminHelpers = require('syracuse-collaboration/lib/helpers');
var sys = require("util");
var url = require('url');
var querystring = require('querystring');

  // initializing sequence emitter, allow to wait the server initialization
exports.initializerStatus = new EventEmitter();

var extMap = {
	htm: "text/html",
	html: "text/html",
	txt: "text/plain",
	js: "application/javascript",
	json: "application/json",
	css: "text/css",
	png: "image/png",
	gif: "image/gif",
	jpg: "image/jpeg",
	jpeg: "image/jpeg",
	xml: "text/xml"
};

var sdataRegistry = require("syracuse-sdata/lib/sdataRegistry");
var dataModel = require("syracuse-orm/lib/dataModel")




/** check user (and password) for different authentication methods. User name must be in user table 
*/
function _userCheck(session, login, password, method, standardSetting, _) {
	// not useful anymore as guest is created at initialization
	//	if (login == "guest" && password == "guest") return true;
	var user = null;        
	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
	// fetch user
    var whereClause = "(login eq \"" + login + "\")";
	var users = db.fetchInstances(_, db.model.getEntity("user"), {
		sdataWhere: whereClause
	});
	if (users && users.length) {
      user = users[0];
	  if (!user.active(_)) // no login for inactive users!
		user = null;
	}
	if (user) {
      var localConfig = {};
      var userAuthentication = user.authentication(_);
      if (!userAuthentication) {
        if (!standardSetting) standardSetting = adminHelpers.AdminHelper.getStandardSetting(_);
        // clone standardSetting
        var member;
        for (member in standardSetting) localConfig[member] = standardSetting[member];
      }
      else
      {
        switch (userAuthentication) {
      case "db":
        localConfig.method = "basic";
        localConfig.source = "db";
        break;
      case "ldap":
        localConfig.method = "basic";
        localConfig.source = "ldap";
        localConfig.ldap = user.ldap(_)._data;
        break;
      case "oauth2":
        var localOAuth2 = user.oauth2(_)._data;
        localConfig.method = "oauth2-"+(localOAuth2.name || "");
        localConfig.oauth2 = localOAuth2;
        break;
      default:
	    // !!! error handling
        console.log("Wrong authentication method "+userAuthentication);
		throw new Error("Wrong authentication method "+userAuthentication);
      }
      }
      if (localConfig.method !== method) {
        console.log("Wrong OAuth2 server "+localConfig.method+ " - " +method);
        user = null;        
      }
      else if (localConfig.source == "db") {
        if (user.password(_) !== password) user = null;
      } else if (localConfig.source == "ldap") {
        var ldapName = user.authenticationName(_) || user.login(_);
        if (!localConfig.ldap.active) { // server inactive: no authentication
          console.log("LDAP server inactive");
          user = null;
        } else {
        var ldapauth = require("ldapauth");
        localConfig.ldap.cache =  false;
        var auth = new ldapauth(localConfig.ldap);
        try {
          auth.authenticate(ldapName, password, _);
        }
        catch (e) {
          console.log(e);
          user = null;
        } finally {
          auth.close(_);
        }
        }
      } else { // OAuth2 authentication
			// nothing to do because it has already been checked whether OAuth2 is correct
      }
	  if (user) {
		  session.setData("userID", user.$uuid);
		  session.setData("userLogin", user.login(_));
	  }
    }
	return user != null;
}

// obtain module for authentication from request url and standard configuration
var getAuthModule = function(request, redirect, _) {
	var result;
	var parsed = url.parse(request.url);
	var pathname;
	if (redirect) { // use original URL
		pathname = querystring.parse(parsed.query).state;
		request.syracuseOriginalPath = pathname;
	} else {	
		pathname = parsed.pathname;
	}
	var regexResult; // search authentication information in request.url
	var authmethod;
	var authserver;
	var setting; // either standard setting or (partial) setting derived from path: 
	// authentication header in URL path: /auth/basic or /auth/oauth2-<Name>
	regexResult = /^\/auth\/(basic|oauth2-(\w*))/.exec(pathname);
	if (regexResult == null || regexResult[1] === "oauth2-") {
		var standardSetting = adminHelpers.AdminHelper.getStandardSetting(_);
		authmethod = standardSetting.method;
		if (authmethod !== "oauth2-" && regexResult) {
			console.log("No OAuth2 server according to standard config file");
			throw new Error("No OAuth2 server according to standard config file");
		}
		authserver = standardSetting.oauth2;
	} else {		
		authmethod = regexResult[1];
		if (authmethod.indexOf("oauth2") === 0) {	
			// get OAuth2 server from database
			var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
			var authserverInstance = db.fetchInstance(_, db.model.getEntity("oauth2"), {
				sdataWhere: '(name eq "' + regexResult[2] + '")'
			});
			if (!authserverInstance) {
				console.log("No OAuth2 server with name "+regexResult[2]);
				throw new Error("ENOENT, No OAuth2 server with name "+regexResult[2]);
			}
			// !!! not OK. How can I copy all attributes?
			authserver = authserverInstance._data;	
		}
	}
	if (redirect) {
		if (regexResult) 
			pathname = pathname.replace(regexResult[0], "");
		request.syracuseOriginalPath = pathname;
	}
	if (authmethod === "basic") {
		return require("streamline-auth/lib/basic").create(_userCheck, standardSetting);
	}
	else {
		return require("streamline-auth/lib/oauth2").create(_userCheck, authserver, standardSetting);
	}
}

// config dispatcher before modules setup as it does sdataRegistry.register
config.sdata.httpRoot = config.sdata.httpRoot || "http://localhost:" + port;
var sdataDispatcher = sdata.dispatcher(config.sdata);
var soapDispatcher = soap.dispatcher(config);
var x3Dispatcher = x3Disp.x3dispatcher(config);
// default collaboration config
config.collaboration = config.collaboration || {};
config.collaboration.contract = config.collaboration.contract || "syracuse";
config.collaboration.application = config.collaboration.application || "collaboration";
config.collaboration.dataset = config.collaboration.dataset || "syracuse";
// modules setup
adminUtil.setup(config.collaboration);
adminHelpers.setup(config.collaboration, config.session);
factory.setup(config.factory);
// setup a connection cache for mongodb
var mongoConnPool = {};
mongodb.setup(config.mongodb, mongoConnPool);
// configure x3Pool first as it modifies proxy map
config.proxy = config.proxy || {};
config.proxy.map = config.proxy.map || [];
x3Pool.setup(config.x3Pool, config.proxy.map)
sessionManager.setup(config.session, getAuthModule);
proxyManager.setup(config.proxy);
//
searchEngine.setup(config.searchEngine);

var staticProvider = require('streamline-static/lib/staticProvider').staticProvider(basePath);


// patch integration on temp directory: perform special actions and copy files into normal folder
exports.patchintegration = function (_) {
	var write = require('syracuse-patch/lib/write');
	// perform extra actions
	try {
		var oldActions;
		var newActions;
		if (write.exists(write.EXTRA_FUNCTIONS_OLD, _))
			oldActions = fs.readFile(write.EXTRA_FUNCTIONS_OLD, "utf8", _).split(/\r\n|\r|\n/);
		else
			oldActions = [];
		if (write.exists(write.EXTRA_FUNCTIONS, _))
			newActions = fs.readFile(write.EXTRA_FUNCTIONS, "utf8", _).split(/\r\n|\r|\n/);
		else
			newActions = [];
		var oldActionsHash = {};
		var i = oldActions.length;
		while (--i >= 0) {
			oldActionsHash[oldActions[i]] = "";
		}
		i = 0;
		while (i < newActions.length) {
			var action = newActions[i++];
			if (!action || action in oldActionsHash)
				continue;
			var parts = action.split(" ");
			if (parts.length != 2)
				console.log("Invalid action "+action);
			else {
					console.log("Perform action "+action);
					var mod = require(process.cwd()+"/"+parts[0]);
					var result = mod[parts[1]](_);
					console.log("Action "+action+" performed, result "+result);
			}
		}
		write.copyRec(".", "..", true, _);
		var errors = write.checkChecksumsV("..", _);
		if (errors.length > 0) {
			errors = write.checkChecksumsV(".", _);
			if (errors.length > 0)
				throw new Error("Temp directory is corrupt after patch integration");
			write.copyRec(".", "..", false, _);
		}
			
		var version = write.readVersionFile(".", _);
		console.log(JSON.stringify(version));
		if (version.patchNumber === "0")
			write.copyRec(".", "../"+write.RELEASE_DIRECTORY, true, _);
		if (process.argv[2] === "PATCH")
			write.exchangeProcess('..', "./out2.bbb", "");			
	} catch (e) {
		console.log("Exception "+e)
	}

}

function staticDispatcher(_, request, response) {
//	var defaultPageExp = /\/$|(\/default|\/index)\.(html|htm)/;
	var defaultPageExp = /\/$|(\/default)\.(html|htm)/;
	// default page(s)
	if (defaultPageExp.exec(request.url)) {
		//	if (/(\/$|\/default|\/index)\.(html|htm)/.exec(request.url)) {
		// is mobile ?
		if (/[Mm]obile/.exec(request.headers["user-agent"])) {
			response.writeHead("301", {
				Location: request.url.replace(defaultPageExp, "/indexMobile.html")
			})
		} else {
			response.writeHead("301", {
//				Location: request.url.replace(defaultPageExp, "/syracuse-main/html/main.html?url=" + encodeURIComponent("?representation=home.$dashboard"))
				Location: request.url.replace(defaultPageExp, "/index.html")
			})
		}
		return response.end();
	}
    
	// listing of all authentication methods
	if (/index2\.html$/.exec(request.url)) {
		var path = "/syracuse-main/html/main.html?url=" + encodeURIComponent("?representation=home.$dashboard");
		response.writeHead(200, { "Content-type": "text/html" });
		response.write(_, '<html>Authentication methods:<br><a href="'+request.url.replace("/index2.html", path)+'">Standard</a><br>');
		response.write(_, '<html><a href="'+request.url.replace("/index2.html", '/auth/basic'+path)+'">Basic</a><br>');
		var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
		// fetch OAuth2 server data
		var oauth2s = db.fetchInstances(_, db.model.getEntity("oauth2"), {
			sdataWhere: "" });
		var i;				
		for (i=0; i<oauth2s.length; i++) {
			if (oauth2s[i].active(_)) {
				 var name = oauth2s[i].name(_);
				 var displayname = oauth2s[i].displayName(_) || name;
				 response.write(_, '<html><a href="'+request.url.replace("/index2.html", "/auth/oauth2-"+name+path)+'">'+displayname+'</a><br>');
			}
		};
		// if there is not setting instance, also provide link for OAuth2 server in global configuration
		var setting = db.fetchInstance(_, db.model.getEntity("setting"), {
			sdataWhere: "" });
		if (!setting && config.session.auth === "oauth2" && typeof(config.oauth2) != "undefined") {
			response.write(_, '<html><a href="'+request.url.replace("/index2.html", "/auth/oauth2-"+path)+'">Configured OAuth2 server</a><br>');
		}
		return response.end();
	}
			 		
	// OAuth2 redirect path equals "/redirect". In order to avoid parsing every url, it will be searched using a substring function first		
	if (request.url.indexOf("/oauth2/redirect") >= 0 && url.parse(request.url).pathname === "/oauth2/redirect")
	{
		// second step of authentication
		if (!sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth2: true
			})) return;
		// redirect to start page
		response.writeHead(303, { "Content-Type": "text/html", "Location": request.syracuseOriginalPath });
		response.end('<html><a href="/test">Link</a></html>');
		return;
	}
    
    
	if (/(main|mobile)\.html/.exec(request.url)) {
		if (!sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		})) return;
	}
        
    // strip authentication header
	if (request.url.indexOf("/auth/") >= 0 && url.parse(request.url).pathname.indexOf("/auth/") === 0) {
		request.url = request.url.replace(/\/auth\/[\w-]+/, "");
	}

	if (request.url.indexOf(".md") == request.url.length - 3 && request.method == "GET") {
		var html = require('markdown').parse(fs.readFile(basePath + request.url, "utf8", _));
		html += "<h2>Warning</h2><p>Current theme is GPL -- find another one with different license</p>"
		html = '<html><head>' + '<link href="/syracuse-ui/themes/markdown.css" rel="stylesheet" type="text/css"/>' + '</head><body>' + html + '</body></html>';
		response.writeHead("200", {
			"content-type": "text/html"
		});
		return response.end(html);
	}
	if (!staticProvider(_, request, response)) {
		response.writeHead("404", {});
		return response.end("Resource not found.");
	}
}

function allowOrigin(request, response) {
	if (false) { // test request URL here
		response.writeHead(403, {
			"Content-Type": "text/plain"
		});
		response.end('Origin unauthorized', 'utf8');
		return false;
	}
	var writeHead = response.writeHead;
	response.writeHead = function(status, headers) {
		var corsHeaders = ["Authorization", "X-Authorization", "X-Authorization-Mode", "X-Requested-With", "X-HTTP-Method-Override", "Content-Type", "Accept", "If-Match"];

		headers["Access-Control-Allow-Origin"] = "*", headers["Access-Control-Allow-Credentials"] = true;
		headers["Access-Control-Allow-Methods"] = "POST, GET, PUT, DELETE, OPTIONS";
		headers["Access-Control-Max-Age"] = '86400', // 24 hours
		headers["Access-Control-Allow-Headers"] = corsHeaders.join(',');

		response.writeHead = writeHead;
		return response.writeHead(status, headers);
	};
	return true;
}

var _map = {
	sdata: function(_, request, response) {
		return allowOrigin(request, response) && sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && sdataDispatcher(_, request, response);
	},
	trans: function(_, request, response) {
		return allowOrigin(request, response) && sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && x3Dispatcher(_, request, response);
	},
	soap: function(_, request, response) {
		return allowOrigin(request, response) && sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && soapDispatcher(_, request, response);
	},
	upload: function(_, request, response) {
		return sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: false
		}) && upload.dispatcher(_, request, response);
	},
	proxy: function(_, request, response) {
		return sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && proxyManager.proxy(_, request, response);
	},
	tests: function(_, request, response) {
		return sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && testServer.dispatch(_, request, response);
	},
	search: function(_, request, response) {
		return sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && searchEngine.dispatch(_, request, response);
	},
	require: requireDispatcher
};

function _hackRequest(_, request) {
	request.url = request.url.replace(/%27/g, "'"); // for regexp parsing
	var fs = request.url.split('/')[1];
	if (fs) fs = fs.split('?')[0]; // example /proxy?url=...
	var page = /^\/sdata\/syracuse\/ui\/syracuse\/pages\('([^%]*)'\)$/.exec(request.url);
	if (page) request.url = "/syracuse-main/html/" + page[1].replace(/\./g, '/').replace(/\/\$/, "-$") + ".json";
}

function _errorHandler(err) {
	if (err) console.error(err.message + "\n" + err.stack);
}

// see later

function HttpContext(request, response) {
	this.request = request;
	this.response = response;
	var parts = request.url.split('?');
	var segments = parts.splice(0, 1)[0].split('/');
	var segI = 0;
	this.queryString = helpers.url.parseQueryString(parts.join('?'));
}

exports.server = new streams.HttpServer(function(request, response, _) {
	try {
		// console.log("syracuse main: " + request.url);
		//console.log("request (408): "+sys.inspect(request));
		request.context = new HttpContext(request, response);
		// workaround for a nodejs bug
		// see http://groups.google.com/group/nodejs/browse_thread/thread/9189df2597aa199e/965cfa9b7968666d
		// tested with 0.6.7: it works
//		request.unread(request.readAll(_));
		//
		_hackRequest(_, request);
		//
		var fs = request.url.split('/')[1];
		if (fs) fs = fs.split('?')[0]; // example /proxy?url=...
		var dispatch = _map[fs] || staticDispatcher;
		dispatch(_, request, response);
	} catch (err) {
		_errorHandler(err);
		response.writeHead(500, {
			"Content-Type": "text/plain"
		});
		response.end(err.message + "\n" + err.stack);
	}
});
exports.config = config;
exports.liveServer = liveServer;

require("streamline/lib/tools/docTool").generate(_errorHandler, basePath, config.docTool);
// load all endpoints
sdataRegistry.loadAllEndpoints(_);
// cleanup
sessionManager.cleanupSessionInfos(_);
// scheduler (no wait)
adminHelpers.AdminHelper.startTimers();

global.__context = {
	errorHandler: _errorHandler
}
process.on('uncaughtException', function(err) {
	_errorHandler(err);
});
// sessions cleanup
process.on('exit', function() {
	console.log("Exiting ...");
});
// make it invoke onExit
try {
	process.on('SIGINT', process.exit);
} catch(e) {
	console.log("SIGINT not yet available on Windows");
}
console.log("Running node version " + process.version);
// initialize phase ended
exports.initializerStatus.emit("initialized");