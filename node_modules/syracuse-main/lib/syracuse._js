"use strict";
console.log("Node version: " + process.version);
var perfmon = require('syracuse-perfmon');
var perfmonLogger = require('syracuse-perfmon/lib/logger');
var syncInitTiming = perfmon.start(module, "main.syncInit");

var fs = require('streamline-fs');
var path = require('path');
var os = require('os');
var config = require('config'); // must be first syracuse require
require('syracuse-core/lib/errorHelper'); // to get safeStack
var locale = require('syracuse-core/lib/locale');
var sdata = require('syracuse-sdata/lib/sdataDispatch');
var upload = require('streamline-upload/lib/upload');
var globals = require('streamline/lib/globals');
var mock = require('syracuse-load/lib/mock');

//perfmon.enable(!(config.perfmon || {}).disabled);
//
var _initialized = false;
//
if (/^N?\d+$/.test(process.argv[2])) config.port = process.argv[2];

// maybe set tenant ID
for (var i = 2; i < process.argv.length; i++) {
	var arg = process.argv[i];
	if (arg.substr(0, 9) === "tenantId=") {
		globals.context.tenantId = arg.substr(9);
		console.log("Tenant " + globals.context.tenantId);
		break;
	}
}
config.port = config.port || 8124;
var port = config.port;
config.hosting = config.hosting || {};
config.hosting.compressThreshold = config.hosting.compressThreshold || 1024;

config.servername = os.hostname();
if (config.license && config.license.domain) {
	config.servername += ("." + config.license.domain);
}
config.servername += ":" + config.port;
config.session = config.session || {};
config.session.realm = config.session.realm || "Syracuse";

var basePath = path.join(path.dirname(module.filename), "../..");
var helpers = require('syracuse-core/lib/helpers');
var testServer;

config.system = config.system || {};
var enableDevelopmentFeatures = config.system.enableDevelopmentFeatures;
if (enableDevelopmentFeatures) {
	testServer = require('test-runner/lib/server/testServer');
}
if (config.system && config.system.verifyContextMillis) {
	(function() {
		var context = globals.context;
		setInterval(function() {
			if (globals.context !== context) {
				console.error("globals.context corrupted:\nEXPECTED: ", Object.keys(context), "\nGOT: ", Object.keys(globals.context));
				process.exit(1);
			}
		}, config.system.verifyContextMillis);
	})();
}

//Require apiScheduler if running external health checks
if (config.apiHealthScheduler && config.apiHealthScheduler.enabled) {
	var apiTest = require('syracuse-health/apiScheduler');
}
var sessionManager = require('syracuse-session/lib/sessionManager').sessionManager;
var x3Pool = require('syracuse-x3/lib/pool');
var streams = require('streamline/lib/streams/streams');
var ez = require("ez-streams");
var zlib = require('zlib');
var factory = require('syracuse-orm/lib/factory');
var mongodb = require('syracuse-orm/lib/dbHandles/mongoDbHandle');
var searchEngine = require('syracuse-search/lib/elasticSearch');
var indexEngine = require('syracuse-search/lib/elasticIndex');
var adminUtil = require('syracuse-collaboration/lib/util');
var adminHelpers = require('syracuse-collaboration/lib/helpers');
var check = require('syracuse-license/lib/check');

var url = require('url');

var sdataRegistry = require("syracuse-sdata/lib/sdataRegistry");
var dataModel = require("syracuse-orm/lib/dataModel");

var cssRtlOptions = {
	cachePrefix: "rtl$",
	transform: function(_, data) {
		var text = data.toString('utf8');
		text = text.replace(/:\s*(left|right)\s*;/g, function(all, lr) {
			return ': ' + (lr === 'left' ? 'right' : 'left') + ';';
		});
		text = text.replace(/(-?)\b(left|right)\s*:/g, function(all, sep, lr) {
			return sep + (lr === 'left' ? 'right' : 'left') + ':';
		});
		text = text.replace(/:\s*(\d+\w*)\s+(\d+\w*)\s+(\d+\w*)\s+(\d+\w*)\s*;/g, function(all, t, r, b, l) {
			return ': ' + t + ' ' + l + ' ' + b + ' ' + r + ';';
		});
		return new Buffer(text, 'utf8');
	}
};

var htmlRtlOptions = {
	cachePrefix: "rtl$",
	transform: function(_, data) {
		var text = data.toString('utf8');
		text = text.replace(/dir="ltr"/g, 'dir="rtl"');
		text = text.replace(/\.css"/g, '.css?rtl=true"');
		return new Buffer(text, 'utf8');
	}
};

// config dispatcher before modules setup as it does sdataRegistry.register
config.sdata.httpRoot = config.sdata.httpRoot || "http://localhost:" + port;
// default collaboration config
config.collaboration = config.collaboration || {};
config.collaboration.contract = config.collaboration.contract || "syracuse";
config.collaboration.application = config.collaboration.application || "collaboration";
config.collaboration.dataset = config.collaboration.dataset || "syracuse";
// modules setup
adminUtil.setup(config.collaboration);
adminHelpers.setup(config.collaboration, config.session);
factory.setup(config.factory);
// setup a connection cache for mongodb
config.mongodb = config.mongodb || {};
mongodb.setup(config.mongodb, {});
// configure x3Pool first as it modifies proxy map
config.proxy = config.proxy || {};
config.proxy.map = config.proxy.map || [];
x3Pool.setup(config.x3Pool, config.proxy.map);
sessionManager.setup(config.session, port);
//
config.searchEngine = config.searchEngine || {};
searchEngine.setup(config.searchEngine);

// max age of one hour as some static content doesn't get updated after a server change
var staticProvider = require('streamline-static/lib/staticProvider').staticProvider({
	root: basePath,
	maxAge: 3600 * 1000,
});

function notFound(_, request, response) {
	response.writeHead("404", {});
	return response.end("Resource not found: " + request.url);
}

function markdownDispatcher(_, request, response) {
	function nav(tb) {
		return '<div class="nav ' + tb + '"><a href="/apis.md">Index</a></div>';
	}
	if (request.url.indexOf(".md") == request.url.length - 3 && request.method == "GET") {
		var html = require('ghm').parse(fs.readFile(basePath + request.url, "utf8", _));
		html = '<html><head>' + //
		'<link href="/syracuse-ui/themes/markdown.css" rel="stylesheet" type="text/css"/>' + //
		'</head><body>' + nav('top') + html + nav('bottom') + '</body></html>';
		response.writeHead("200", {
			"content-type": "text/html; charset=utf-8"
		});
		return response.end(html);
	}
}

function staticDispatcher(_, request, response) {
	//	console.log("SSSS "+request.connection.authorized)
	//	if (request.connection.authorized) console.log("SSSSCC "+sys.format(request.connection.getPeerCertificate()))
	//	var defaultPageExp = /\/$|(\/default|\/index)\.(html|htm)/;

	if (/\.md$/.test(request.url) && request.method == "GET") return markDownDispatcher(_, request, response);

	var opts = {};
	if (/(\?|\&)rtl=true/.test(request.url)) {
		if (/\.html/.test(request.url)) opts = htmlRtlOptions;
		else if (/\.css/.test(request.url)) opts = cssRtlOptions;
	}
	// don't cache main.html to trigger authentication through refetch.
	if (/^\/syracuse-main\//.test(request.url)) opts.nocache = true;
	if (!staticProvider(_, request, response, opts)) return notFound(_, request, response);
}

// display message to users that server will shutdown soon, do not accept new sessions any more

function patchHeaders(request, response) {
	var writeHead = response.writeHead;
	response.writeHead = function(status, headers) {
		// Security: prevent clickjacking attack
		headers["X-Frame-Options"] = 'DENY';

		// Set expires to -1 !!! IMPORTANT because IE don't send request when receive ETag
		headers.expires = (new Date()).toGMTString();

		response.writeHead = writeHead;
		return response.writeHead(status, headers);
	};
}

var authModule = require('streamline-auth/lib/dispatcher');

// ensures session and authentication
// if noChallenge server will not reply with an auth challenge but will send a forbidden reply if client is not authenticated
// In any case the next dispatcher will only be called if authentication was successful. 
function ensureAuthenticated(dispatcher) {
	return function(_, request, response) {
		patchHeaders(request, response);
		return sessionManager.ensureSession(_, request, response) //
		&& authModule.ensureAuthenticated(_, request, response) //
		&& dispatcher(_, request, response);
	};
}
var requireDispatcher = require('streamline-require/lib/server/require').dispatcher({
	getResources: locale.getResourcesHook,
	whiteList: [
		/^(syracuse-(main|ui|core|rtf|sdata\/lib\/parser)|streamline|jsurl|jsxml|test-runner|html-escape|html5-binary|node-oauth)\//,
		/^syracuse-x3\/.*?\/(format|CvgFormat(ter)?|cvgPageConverter)$/
	],
});
var sdataDispatcher = sdata.dispatcher(config.sdata);
var printDispatcher = require('syracuse-x3/lib/clients/print/printDispatch').dispatcher(config);
var x3Dispatcher = require('syracuse-x3/lib/x3Dispatch').x3dispatcher(config);
var hrmDispatcher = require('syracuse-hrm/lib/hrmDispatch').dispatcher(config);
var wsDispatcher = require('syracuse-soap/lib/server/wsDispatch').dispatcher(config);
var stubDispatcher = require('syracuse-soap/lib/client/stubDispatch').dispatcher(config);
var patchDispatcher = require('syracuse-patch/lib/dispatcher').dispatcher(config.patch);
var licenseDispatcher = require('syracuse-license/lib/dispatcher').dispatcher(config.license);
var authDispatcher = authModule.dispatcher;
var sessionDispatcher = require('syracuse-session/lib/dispatcher').dispatcher(config);
var eventDispatcher = require('syracuse-event/lib/dispatcher').dispatcher(config);

var htmlStaticDispatcher = function(_, request, response) {
	if (request.url.split('/')[2] === 'html') return staticDispatcher(_, request, response);
	else return notFound(_, request, response);
};

var authenticatedRoutes = {
	sdata: sdataDispatcher,
	trans: x3Dispatcher,
	bo: x3Dispatcher, // was unauthenticated before (!), needs to test
	"soap-ws": wsDispatcher,
	"soap-stubs": stubDispatcher,
	print: printDispatcher,
	xtend: hrmDispatcher,
	shrmportal: hrmDispatcher,
	tests: testServer && testServer.dispatch,
	search: searchEngine.dispatch,
	xsearch: searchEngine.dispatch,
	// Exact search, no wildcards
	fsearch: searchEngine.dispatch,
	// Fuzzy like this search
	bundles: require('bundles/lib/dispatcher').dispatcher(config, staticDispatcher),
	perfmon: require('syracuse-perfmon/lib/dispatcher').dispatcher(config),
	help: require('syracuse-help/lib/helpDispatch').dispatcher(config),
	"streamline-require": staticDispatcher,
	"syracuse-ui": staticDispatcher,
	"syracuse-main": htmlStaticDispatcher,
	"syracuse-perfmon": htmlStaticDispatcher,
	require: requireDispatcher,
	upload: upload.dispatcher, // had special auth setting to avoid challenge before
};

var mainRoutes = {
	// Following routes are *NOT* authenticated
	auth: authDispatcher,
	"streamline-auth": htmlStaticDispatcher,
	"syracuse-mobile": staticDispatcher,
	logout: sessionManager.logout,
	// These are nannyCommand urls - we need to do something about them!
	patch: patchDispatcher,
	license: licenseDispatcher,
	event: eventDispatcher,
};

if (config.skyAutomation) {
	if (config.hosting.multiTenant) throw new Error("configuration error: sky-automation application not allowed in multi-tenant mode");
	mainRoutes.healthLogs = require('sky-automation/lib/dispatcher').dispatcher;
}

if (enableDevelopmentFeatures) {
	authenticatedRoutes["test-runner"] = staticDispatcher;
	mainRoutes['dev.html'] = staticDispatcher;
	mainRoutes.memwatch = require('syracuse-memwatch/lib/dispatcher').dispatcher(config);
	mainRoutes.dump = require('syracuse-trace/lib/dispatcher').dispatcher(config);
}

Object.keys(authenticatedRoutes).forEach(function(key) {
	mainRoutes[key] = ensureAuthenticated(authenticatedRoutes[key]);
});

function _hackRequest(_, request) {
	request.url = request.url.replace(/%27/g, "'"); // for regexp parsing
	var fs = request.url.split('/')[1];
	if (fs) fs = fs.split('?')[0]; // example /proxy?url=...
	var page = /^\/sdata\/syracuse\/ui\/syracuse\/pages\('([^%]*)'\)$/.exec(request.url);
	if (page) request.url = "/syracuse-main/html/" + page[1].replace(/\./g, '/').replace(/\/\$/, "-$") + ".json";
}

function _errorHandler(err) {
	if (err) console.error(err.message + "\n" + err.stack);
}

// see later

function HttpContext(request, response) {
	this.request = request;
	this.response = response;
	var parts = request.url.split('?');
	var segments = parts.splice(0, 1)[0].split('/');
	var segI = 0;
	this.queryString = helpers.url.parseQueryString(parts.join('?'));
}

function _makeHttpServerOptions(secure) {
	return secure ? {
		secure: true,
		// The Server's SSL Key
		key: fs.readFileSync(path.join(__dirname, 'ssl/server.key'), "utf8"),
		// The Server's Cert
		cert: fs.readFileSync(path.join(__dirname, 'ssl/server.crt'), "utf8"),
		// The CA (us in this case)
		ca: [fs.readFileSync(path.join(__dirname, 'ssl/ca.crt'), "utf8")],
		// Ask for the client's cert
		requestCert: true,
		// Don't automatically reject
		rejectUnauthorized: false
	} : null;
}

function _enableCompression(request, response) {
	if (!request.headers || !request.headers['accept-encoding'] || request.headers['accept-encoding'].split(',').indexOf('gzip') === -1) return response;
	var writeHead = response.writeHead;
	var write = response.write;
	var end = response.end;
	var zipWriter;
	var err;

	response.writeHead = function(status, headers) {
		var len = headers["content-length"] || headers["Content-Length"];
		if ((len == null || len > config.hosting.compressThreshold) && !headers["content-encoding"] && //
			// only compress selected mime types (images, for ex, are already compressed)
			/^(text|application|multipart)\//.test(headers["content-type"] || headers["Content-Type"])) {
			headers["content-encoding"] = "gzip";
			headers["transfer-encoding"] = "chunked";
			// Two delete because static provider put headers with upper cases
			delete headers["Content-Length"];
			delete headers["content-length"];
			var zipper = zlib.createGzip(config.hosting.compressOptions || {
				// I prefer trading a bit of size for speed. 
				// Default level (6) gains about 20% in size but doubles CPU usage.
				// see http://tukaani.org/lzma/benchmarks.html
				level: 1,
			});
			zipWriter = ez.devices.node.writer(zipper);
			var zipReader = ez.devices.node.reader(zipper);
			// bind is necessary here because of a streamline-fast bug. I'll fix later
			zipReader.pipe.bind(zipReader)(_ >> function(e) {
				if (e) err = e;
			}, {
				write: write
			});
			//console.log("COMPRESSING: " + headers["content-type"] + ": " + request.url);
		}
		writeHead.call(response, status, headers);
	};

	response.write = function(_, data, enc) {
		if (err) throw err;
		if (zipWriter) {
			var timing = perfmon.start(module, "ZipWriter.write", request.url);
			try {
				return zipWriter.write(_, data && enc ? new Buffer(data, enc) : data != null ? data : undefined);
			} finally {
				timing && timing.end();
			}
		} else return write.call(response, _, data, enc);
	};

	response.end = function(data, enc) {
		if (err) throw err;
		if (zipWriter) {
			var timing = perfmon.start(module, "ZipWriter.end", request.url);
			try {
				return zipWriter.end(data && enc ? new Buffer(data, enc) : data != null ? data : undefined);
			} finally {
				timing && timing.end();
			}
		} else return end.call(response, data, enc);
	};
	return response;
}

function getinitializingPageContent(text, url) {
	var delay = 2,
		content = '<!DOCTYPE html>';
	content += '<html><head>';
	content += '<META HTTP-EQUIV="refresh" content="' + delay + ';URL=' + url + '">';
	content += '<style>';
	content += 'body { font-family:Arial, Helvetica, sans-serif; font-stretch:wider; }';
	content += '</style>';
	content += '</head>';
	content += '<body>';
	content += text;
	content += '</body></html>';
	return content;
}
// global request id to avoid some context mixup betwenn sessions in some extreem cases
var requestCnt = 0;

function disp(request, response, _) {
	if (!_initialized && !config.hosting.multiTenant) return response.end(getinitializingPageContent(locale.format(module, "initializing"), request.url));
	//
	// record timing, except if this is a request to the performance monitor itself.
	var timing = (request.url.indexOf('/perfmon/') === -1) && perfmon.start(module, "main.httpDispatch", request.method + ' ' + request.url);
	try {
		// ease access to config in code
		globals.context.config = config;
		globals.context.requestId = requestCnt++;
		// take care of hosting options first
		// tenantId must be set before calling initAsync(_)
		if (config.hosting.multiTenant) {
			var host = request.headers.host;
			if (!host) throw new Error("host header missing");
			globals.context.tenantId = host.split(/[.:]/)[0];
			if (config.health) require('syracuse-health').addTenant(globals.context.tenantId);
		}
		request.hosting = config.hosting;

		initAsync(_);

		if (!config.hosting.nocompress) response = _enableCompression(request, response);
		request.context = new HttpContext(request, response);
		// intercept default URLs and redirect them (they are not in the routing tables).
		if (/\/$|\/(default|index)\.(html|htm)/.exec(request.url)) {
			response.writeHead(301, {
				location: "/syracuse-main/html/main.html?url=%3Frepresentation%3Dhome.%24landing"
			});
			return response.end();
		}
		//
		_hackRequest(_, request);
		//
		var seg = request.url.split('/')[1];
		if (seg) seg = seg.split('?')[0]; // example /proxy?url=...
		var route = mainRoutes[seg] || notFound;
		route(_, request, response);
	} catch (err) {
		if (err.code === "ETIMEOUT") err.message = locale.format(module, "dispatchTimeout", request.url);
		console.log(err.stack); // TEMP DEBUG
		_errorHandler(err);
		if (err.$diagnoses) {
			response.writeHead(err.$httpStatus || 500, {
				"Content-Type": "application/json"
			});
			response.end(JSON.stringify({
				$diagnoses: err.$diagnoses
			}));
		} else {
			response.writeHead(err.$httpStatus || 500, {
				"Content-Type": "text/plain"
			});
			response.end(err.safeStack);
		}
	} finally {
		timing && timing.end({
			status: response.statusCode,
			'content-length': response.headers && response.headers['content-length']
		});
		request.session && request.session.addTimings();
		// maybe kill node at the end of this request
		if (request.context && request.context.kill) {
			try {
				console.log("Final function before killing");
				request.context.kill();
				console.log("Kill node");
				process.kill(process.pid);
			} catch (e) {
				console.log("Error in kill function " + e);
			}
		}
		// crnit : do not survey anymore
		/*		mem2 = process.memoryUsage();
		var diff = {
			rss: (mem2.rss - mem1.rss) / 1024 / 1024,
			heapTotal: (mem2.heapTotal - mem1.heapTotal) / 1024 / 1024,
			heapUsed: (mem2.heapUsed - mem1.heapUsed) / 1024 / 1024
		};
		var threshold = 10;
		if (diff.rss > threshold || diff.heapTotal > threshold || diff.heapUsed > threshold) {
			var session = request.session,
				up = session && session.getUserProfile(_),
				ep = up && up.selectedEndpoint(_),
				endpointName = ep && (ep.application(_) + "/" + ep.contract(_) + "/" + ep.dataset(_)),
				login = session && session.getUserLogin(_);
			console.log((new Date()).toISOString() + ": " + request.method + ' ' + request.url);
			console.log("  memory usage diff=" + JSON.stringify(diff) + " before=" + JSON.stringify(mem1) + " after=" + JSON.stringify(mem2));
			console.log("  login=" + login + ", endpoint=" + endpointName);
		}
        */
	}
}

exports.startServers = function(_, port) {
	if (process.argv[2] === "STOP") {
		initAsync(_, true); // just initialization, then finish the application
		process.exit(0);
	}
	if (process.argv[2] === "batchpatch") {
		var code = 0;
		try {
			code = require('syracuse-patch/lib/integrate').batchIntegration(_, process.argv[3]);
		} catch (e) {
			console.error(e.stack);
			code = 1;
		}
		process.exit(code);
	}
	port = port || config.port || 8124;
	//Port init
	config.sdata.httpRoot = config.sdata.httpRoot || "http://localhost:" + port;
	// start http or mock server
	if ((!config.hosting.multiTenant || globals.context.tenantId) && (exports.server instanceof mock.MockStreamServer)) {
		initAsync(_); // do initialization before listening when started from nanny process
	}
	exports.server.listen(_, port);
	console.log('Server running at http://localhost:' + port + '/');
	if (exports.integrationServer) {
		exports.integrationServer.listen(_, config.integrationServer.port);
		console.log('Integration server running at http://localhost:' + config.integrationServer.port + '/');
	}

	perfmonLogger.start(_);

	// init async (important for tests)
	if (!config.hosting.multiTenant || globals.context.tenantId) initAsync(_);
};

exports.main = function(cb) {
	exports.startServers(_ >>
		(cb || function(err) {
			if (err) throw err;
		}));
};

if (process.argv[2] && process.argv[2].substr(0, 1) === "N") {
	// use output stream which writes to file descriptor 3 (to avoid conflict with normal standard output)
	exports.server = new mock.MockStreamServer(disp, new mock.DescriptorWriteStream(3), process.stdin, {
		timeout: 1 * (process.argv[3] || 0)
	});
	config.mockServer = exports.server;
	// kill process when pipe breaks (i. e. nanny process has been killed)
	process.stdin.on('close', function() {
		console.log("stdin closed - finish process");
		process.exit(0);
	});
} else {
	exports.server = ez.devices.http.server(disp, _makeHttpServerOptions((config.session || {}).secure));
	// https server doesn't support setTimeout
	if (exports.server.hasOwnProperty(setTimeout)) exports.server.setTimeout(10 * 60 * 1000);
}

if (config.integrationServer && config.integrationServer.port) exports.integrationServer = new streams.createHttpServer(disp, _makeHttpServerOptions(true));

exports.config = config;

if (enableDevelopmentFeatures) {
	require("streamline-doctool").generate(_ >> _errorHandler, basePath, config.docTool);
	try {
		require("tools/git/setupHooks");
	} catch (ex) {
		console.log(ex.message);
	}
}

// exception and exit handlers
process.on('uncaughtException', function(err) {
	_errorHandler(err);
});
process.on('exit', function() {
	console.log("Exiting ...");
});
// make it invoke onExit
try {
	process.on('SIGINT', function() {
		setTimeout(process.exit, 100);
	});
} catch (e) {
	console.log("SIGINT not yet available on Windows");
}

// patch streams.httpRequest to get performance monitoring on all outgoing HTTP requests
(function() {
	var originalHttpRequest = streams.httpRequest;
	streams.httpRequest = function(options) {
		var req = originalHttpRequest(options);
		var originalResponse = req.response;
		req.response = function(_) {
			var timing = perfmon.start(module, "httpRequest.response", options.url);
			try {
				return originalResponse.call(req, _);
			} finally {
				timing.end({
					status: originalResponse.statusCode
				});
			}
		};
		return req;
	};
})();

syncInitTiming.end();

var initializedTenants = {};

// Initializations
// simplified: the simplified initialization is for special use when no normal request need to be processed but
// the application should only be started to execute a certain administrative batch task and then finish
// (e. g. node index PATCH for patch integration)

function initAsync(_, simplified) {
	var key = globals.context.tenantId || "$$solo";
	if (initializedTenants[key]) return;
	initializedTenants[key] = true;

	var asyncInitTiming = perfmon.start(module, "main.asyncInit");
	// WARNING: async code below => require will yield and return incomplete API
	var admEp = adminHelpers.AdminHelper.getCollaborationEndpoint(_);
	if (admEp && config.collaboration) {
		var dataset = admEp.dataset(_);
		if (dataset !== config.collaboration.dataset) {
			console.error("Different collaboration dataset in Syracuse endpoint (" + dataset + ") and nodelocal.js (" + config.collaboration.dataset + ")");
			process.exit(1);
		}
	}
	// for emergency, if collaboration endpoint points to wrong database
	if (process.argv[2] === "--rescueEndpoint" && admEp) {
		admEp.localDatabase(_, true);
		admEp.save(_);
		console.log("Set local database for collaboration endpoint");
	}
	// load all endpoints
	sdataRegistry.loadAllEndpoints(_);
	// cleanup
	sessionManager.cleanupSessionInfos(_);
	// update badges
	require("syracuse-collaboration/lib/entities/badge").updateBadges(_);
	// scheduler (no wait)
	if (!simplified) adminHelpers.AdminHelper.startTimers(_);
	// register afterSave events for transparent indexing
	indexEngine.registerModelEvents(_, config.searchEngine);

	asyncInitTiming.end();
	//
	_initialized = true;
}

function runPatch(_) {
	console.log("Final patch integration");
	initAsync(_, true);
	require('syracuse-patch/lib/patchtools').finalIntegration(_);
	// patch integration process finishes here
	// unlock system
	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
	var setting = db.fetchInstance(_, db.model.getEntity(_, "setting"), {
		sdataWhere: ""
	});
	if (setting) {
		setting.patchLock(_, false); // release semaphore lock
		setting.save(_);
	}
	process.exit(0);
}

exports.runPatchCb = function(cb) {
	runPatch(_ >> cb);
};