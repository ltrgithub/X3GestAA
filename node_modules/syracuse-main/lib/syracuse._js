"use strict";
console.log("Node version: " + process.version);
var perfmon = require('syracuse-perfmon');
var syncInitTiming = perfmon.start(module, "main.syncInit");

var fs = require('streamline-fs');
var path = require('path');
var os = require('os');
var config = require('./nodeconfig').config; // must be first syracuse require
var locale = require('syracuse-core/lib/locale');
var sdata = require('syracuse-sdata/lib/sdataDispatch');
var ws = require('syracuse-soap/lib/server/wsDispatch');
var xtend = require('syracuse-xtend/lib/xtendDispatch');
var stub = require('syracuse-soap/lib/client/stubDispatch');
var x3Disp = require('syracuse-x3/lib/x3Dispatch');
var print = require('syracuse-x3/lib/clients/print/printDispatch');
var help = require('syracuse-help/lib/helpDispatch');
var upload = require('streamline-upload/lib/upload');
var globals = require('streamline/lib/globals');
var mock = require('syracuse-load/lib/mock');
var crypto = require('crypto');

//
var _initialized = false;
// memwatch: might not be installed
var memwatch = null;
var heapSnapshot = null;
try {
	if (config.system && config.system.memwatch) memwatch = require("memwatch");
} catch (e) {}
//
if (/^N?\d+$/.test(process.argv[2])) config.port = process.argv[2];

// maybe set tenant ID
for (var i = 2; i < process.argv.length; i++) {
	var arg = process.argv[i];
	if (arg.substr(0, 9) === "tenantId=") {
		globals.context.tenantId = arg.substr(9);
		console.log("Tenant " + globals.context.tenantId);
		break;
	}
}
config.port = config.port || 8124;
var port = config.port;
config.hosting = config.hosting || {};
config.servername = os.hostname();
if (config.license && config.license.domain) {
	config.servername += ("." + config.license.domain);
}
config.servername += ":" + config.port;
config.session = config.session || {};
config.session.realm = config.session.realm || "Syracuse";

var basePath = path.join(path.dirname(module.filename), "../..");
var helpers = require('syracuse-core/lib/helpers');
var testServer;
// helpers.enableDeveloppementFeatures will be deprecated
if ((config.system || {}).enableDevelopmentFeatures || helpers.enableDeveloppementFeatures) {
	testServer = require('test-runner/lib/server/testServer');
}
var sessionManager = require('syracuse-session/lib/sessionManager').sessionManager;
var requireDispatcher = require('streamline-require/lib/server/require').dispatcher({
	getResources: locale.getResourcesHook
});
var x3Pool = require('syracuse-x3/lib/pool');
var streams = require('streamline/lib/streams/streams');
var ez = require("ez-streams");
var http = ez.devices.http;
var zlib = require('zlib');
var factory = require('syracuse-orm/lib/factory');
var mongodb = require('syracuse-orm/lib/dbHandles/mongoDbHandle');
var searchEngine = require('syracuse-search/lib/elasticSearch');
var indexEngine = require('syracuse-search/lib/elasticIndex');
var adminUtil = require('syracuse-collaboration/lib/util');
var adminHelpers = require('syracuse-collaboration/lib/helpers');
var check = require('syracuse-license/lib/check');

var url = require('url');
var querystring = require('querystring');

var extMap = {
	htm: "text/html",
	html: "text/html",
	txt: "text/plain",
	js: "application/javascript",
	json: "application/json",
	css: "text/css",
	png: "image/png",
	gif: "image/gif",
	jpg: "image/jpeg",
	jpeg: "image/jpeg",
	xml: "text/xml"
};

var sdataRegistry = require("syracuse-sdata/lib/sdataRegistry");
var dataModel = require("syracuse-orm/lib/dataModel");


/** check user (and password) for different authentication methods. User name must be in user table
 * parameters:
 * session: current session (which will receive data of current user in case of success
 * login: login user name
 * password: password of user (from basic authentication)
 * passwordCheck: function which checks password (for digest authentication). It takes one parameter (the password from MongoDB) and returns
 *                true when the password is correct
 * method: authentication method (basic, digest, oauth2...)
 * standardSetting: standard setting singleton
 * Return codes: 0 OK, 1 authentication failure, 2 no license, 3 change password, 4 user inactive
 */

function _userCheck(session, login, password, passwordCheck, method, standardSetting, _) {
	var user = null;
	var realm = config.session.realm;
	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
	// fetch user
	var whereClause = "(login eq \"" + login + "\")";
	var users = db.fetchInstances(_, db.model.getEntity(_, "user"), {
		sdataWhere: whereClause
	});
	if (users && users.length) {
		user = users[0];
		if (!user.active(_)) // no login for inactive users!
			return 4;
	}
	if (user) {
		var localConfig = {};
		var userAuthentication = user.authentication(_);
		if (!userAuthentication) {
			if (!standardSetting) standardSetting = adminHelpers.AdminHelper.getStandardSetting(_);
			// clone standardSetting
			var member;
			for (member in standardSetting) localConfig[member] = standardSetting[member];
		} else {
			switch (userAuthentication) {
				case "db":
					localConfig.method = config.session.auth;
					localConfig.source = "db";
					break;
				case "ldap":
					if (method === "digest") return "No HTTP digest authentication with LDAP";
					localConfig.method = "basic";
					localConfig.source = "ldap";
					localConfig.ldap = user.ldap(_)._data;
					break;
				case "oauth2":
					var localOAuth2 = user.oauth2(_)._data;
					localConfig.method = "oauth2-" + (localOAuth2.name || "");
					localConfig.oauth2 = localOAuth2;
					break;
				default:
					// !!! error handling
					console.log("Wrong authentication method " + userAuthentication);
					return locale.format(module, "wrongAuth", userAuthentication);
			}
		}

		// for OAuth2: when the chosen OAuth2 server does not match the OAuth2 server of the user, then login is not possible
		if (localConfig.method !== method && (localConfig.method.indexOf('oauth') >= 0 || method.indexOf('oauth') >= 0)) {
			console.log("Wrong OAuth2 server " + localConfig.method + " - " + method);
			user = null;
		} else if (localConfig.source == "db") {
			if (passwordCheck) {
				if (!passwordCheck(user.password(_))) user = null;
			} else {
				// compute hash of password using user name from user entity
				// apply hash function from RFC2617
				var hash = crypto.createHash('MD5');
				var a1 = user.login(_) + ":" + config.session.realm + ":" + password;
				hash.update(a1, 'binary');
				if (hash.digest("hex") !== user.password(_)) user = null;
			}
		} else if (localConfig.source == "ldap") {
			var ldapName = user.authenticationName(_) || user.login(_);
			if (!localConfig.ldap.active) { // server inactive: no authentication
				console.log("LDAP server inactive");
				user = null;
			} else {
				var ldapauth = require("syracuse-ldap").ldapauth;
				localConfig.ldap.cache = false;
				var auth = new ldapauth(localConfig.ldap);
				try {
					auth.authenticate(ldapName, password, ~_);
				} catch (e) {
					console.log(e);
					user = null;
				} finally {
					auth.close(~_);
				}
			}
		} else { // OAuth2 authentication
			// nothing to do because it has already been checked whether OAuth2 is correct
		}
		var diagnoses = [];
		// License check
		if (user) {
			var p = user.preferences(_);
			var role;
			if (p) {
				// force user locales: hack request accept-language header
				var l = p.lastLocaleCode(_);
				// check if locale exists
				if (globals.context && globals.context.request && l && user.getUserLocaleByCode(_, l)) globals.context.request.headers["accept-language"] = l;
				// take last role from user preferences
				role = p.lastRole(_);
			}
			// no role from user preferences - take role from groups
			if (!role) {
				var groups = user.groups(_).toArray(_);
				for (var j = 0; j < groups.length; j++) {
					var group = groups[j];
					role = group.role(_);
					if (role) break; // role found
				}
			}
			if (!role) {
				console.log("No role for user " + user.login(_));
				user = null;
			}
			if (role && !check.checkConcurrent(session, role, user.login(_), _, getDevice(), diagnoses)) {
				return 2;
			}

			// TODO: show diagnoses!!!!
		}
		if (user) {
			session.setData("userID", user.$uuid);
			session.setData("userLogin", user.login(_));
		}
	}
	if (user && user.changePassword(_)) {
		// redirect to other URL
		return 3;
	}
	return (user == null ? 1 : 0);
}

// get device of current session

function getDevice() {
	// dummy implementation!
	return "desktop";
}

exports.getDevice = getDevice;

function _certUserCheck(session, login, standardSetting, _) {
	var user = null;
	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
	// fetch user
	user = db.fetchInstance(_, db.model.getEntity(_, "user"), {
		jsonWhere: {
			login: login,
			active: true
		}
	});
	if (user) {
		// License check
		var p;
		if (p = user.preferences(_)) {

			// find out badges for current user
			var role = p.lastRole(_);
			var diagnoses = [];
			// console.error("ppppppppppppppppppppppppppppppppppppppppppDIAGD " + require('util').format(session.getUserprofile(_)));
			if (role && !check.checkConcurrent(session, role, user.login(_), _, getDevice(), diagnoses)) {
				return 2;
			}
			// console.error("DIAGDIAG2 " + require('util').format(diagnoses));
			// console.error("DIAGD " + require('util').format(session.getUserprofile(_)));

			// force user locales: hack request accept-language header
			var l = p.lastLocaleCode(_);
			// check if locale exists
			if (globals.context && globals.context.request && l && user.getUserLocaleByCode(_, l)) globals.context.request.headers["accept-language"] = l;
		}
		session.setData("userID", user.$uuid);
		session.setData("userLogin", user.login(_));
		return 0;
	} else return 1;
}

var cssRtlOptions = {
	cachePrefix: "rtl$",
	transform: function(_, data) {
		var text = data.toString('utf8');
		text = text.replace(/:\s*(left|right)\s*;/g, function(all, lr) {
			return ': ' + (lr === 'left' ? 'right' : 'left') + ';';
		});
		text = text.replace(/(-?)\b(left|right)\s*:/g, function(all, sep, lr) {
			return sep + (lr === 'left' ? 'right' : 'left') + ':';
		});
		text = text.replace(/:\s*(\d+\w*)\s+(\d+\w*)\s+(\d+\w*)\s+(\d+\w*)\s*;/g, function(all, t, r, b, l) {
			return ': ' + t + ' ' + l + ' ' + b + ' ' + r + ';';
		});
		return new Buffer(text, 'utf8');
	}
};

var htmlRtlOptions = {
	cachePrefix: "rtl$",
	transform: function(_, data) {
		var text = data.toString('utf8');
		text = text.replace(/dir="ltr"/g, 'dir="rtl"');
		text = text.replace(/\.css"/g, '.css?rtl=true"');
		return new Buffer(text, 'utf8');
	}
};

// obtain module for authentication from request url and standard configuration
var getAuthModule = function(request, redirect, _) {
	// TODO: for now, if secure connection, use of client certificates having CN mapping to a valid user name
	// later, have a possibility of generic client certificate and / or ability to change user
	// certificate auth >>>
	// console.log("GET AUTH "+request.url);
	if (request.connection.authorized) return require("streamline-auth/lib/certificate").create(_certUserCheck, standardSetting);
	// certificate auth <<<
	var result;
	var parsed = url.parse(request.url);
	var pathname;
	if (redirect) { // use original URL
		pathname = querystring.parse(parsed.query).state;
		request.syracuseOriginalPath = pathname;
	} else {
		pathname = parsed.pathname;
	}
	var regexResult; // search authentication information in request.url
	var authmethod;
	var authserver;
	var setting; // either standard setting or (partial) setting derived from path:
	// authentication header in URL path: /auth/basic or /auth/oauth2-<Name>
	regexResult = /^\/auth\/(std|basic|digest|oauth2-(\w*))(\-\-[0-9a-f]*)?/.exec(pathname);
	if (regexResult == null || regexResult[1] === "oauth2-" || regexResult[1] === "std") {
		var standardSetting = adminHelpers.AdminHelper.getStandardSetting(_);
		authmethod = standardSetting.method;
		if (regexResult && regexResult[1] === "oauth2-" && authmethod !== "oauth2-") {
			console.log("No OAuth2 server according to standard config file");
			throw new Error(locale.format(module, "noOauth2"));
		}
		authserver = standardSetting.oauth2;
	} else {
		authmethod = regexResult[1];
		if (authmethod && authmethod.indexOf("oauth2") === 0) {
			// get OAuth2 server from database
			var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
			var authserverInstance = db.fetchInstance(_, db.model.getEntity(_, "oauth2"), {
				sdataWhere: '(name eq "' + regexResult[2] + '")'
			});
			if (!authserverInstance) {
				console.log("No OAuth2 server with name " + regexResult[2]);
				throw new Error(locale.format(module, "noOauth2N", regexResult[2]));
			}
			// !!! not OK. How can I copy all attributes?
			authserver = authserverInstance._data;
		}
	}
	if (regexResult && regexResult[1].indexOf("oauth2") < 0 && regexResult[3]) { // login with token
		var user = require("streamline-auth/lib/changePassword").getTempLogin(regexResult[3]);
		if (user) {
			return {
				authenticate: function(request, response, _) {
					request.session && request.session.afterAuthentication({
						user: user,
					});
					console.log("Authentication after change password");
					return true;
				}
			}; // no authentication necessary any more
		}
	}

	if (authmethod === "basic") {
		return require("streamline-auth/lib/basic").create(_userCheck, standardSetting);
	} else if (authmethod === "digest") {
		return require("streamline-auth/lib/digest").create(_userCheck, standardSetting);
	} else {
		return require("streamline-auth/lib/oauth2").create(_userCheck, authserver, standardSetting);
	}
};

// config dispatcher before modules setup as it does sdataRegistry.register
config.sdata.httpRoot = config.sdata.httpRoot || "http://localhost:" + port;
var sdataDispatcher = sdata.dispatcher(config.sdata);
var wsDispatcher = ws.dispatcher(config);
var stubDispatcher = stub.dispatcher(config);
var x3Dispatcher = x3Disp.x3dispatcher(config);
var printDispatcher = print.dispatcher(config);
var xtendDispatcher = xtend.dispatcher(config);
var helpDispatcher = help.dispatcher(config);
// default collaboration config
config.collaboration = config.collaboration || {};
config.collaboration.contract = config.collaboration.contract || "syracuse";
config.collaboration.application = config.collaboration.application || "collaboration";
config.collaboration.dataset = config.collaboration.dataset || "syracuse";
// modules setup
adminUtil.setup(config.collaboration);
adminHelpers.setup(config.collaboration, config.session);
factory.setup(config.factory);
// setup a connection cache for mongodb
config.mongodb = config.mongodb || {};
mongodb.setup(config.mongodb, {});
// configure x3Pool first as it modifies proxy map
config.proxy = config.proxy || {};
config.proxy.map = config.proxy.map || [];
x3Pool.setup(config.x3Pool, config.proxy.map);
sessionManager.setup(config.session, getAuthModule, port);
//
config.searchEngine = config.searchEngine || {};
searchEngine.setup(config.searchEngine);

// max age of one hour as some static content doesn't get updated after a server change
var staticProvider = require('streamline-static/lib/staticProvider').staticProvider({
	root: basePath,
	maxAge: 3600 * 1000
});

function staticDispatcher(_, request, response) {
	//	console.log("SSSS "+request.connection.authorized)
	//	if (request.connection.authorized) console.log("SSSSCC "+sys.format(request.connection.getPeerCertificate()))
	//	var defaultPageExp = /\/$|(\/default|\/index)\.(html|htm)/;
	var defaultPageExp = /\/$|(\/default)\.(html|htm)/;
	// default page(s)
	if (defaultPageExp.exec(request.url)) {
		response.writeHead("301", {
			Location: request.url.replace(defaultPageExp, "/index.html")
		});
		return response.end();
	}

	// listing of all authentication methods
	if (/index2\.html$/.exec(request.url)) {
		var path = "/syracuse-main/html/main.html?url=" + encodeURIComponent("?representation=home.$landing");
		response.writeHead(200, {
			"Content-type": "text/html"
		});
		response.write(_, '<html>Authentication methods:<br><a href="' + request.url.replace("/index2.html", path) + '">Standard</a><br>');
		response.write(_, '<html><a href="' + request.url.replace("/index2.html", '/auth/digest' + path) + '">Digest</a><br>');
		response.write(_, '<html><a href="' + request.url.replace("/index2.html", '/auth/basic' + path) + '">Basic</a><br>');
		var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
		// fetch OAuth2 server data
		var oauth2s = db.fetchInstances(_, db.model.getEntity(_, "oauth2"), {
			sdataWhere: ""
		});
		var i;
		for (i = 0; i < oauth2s.length; i++) {
			if (oauth2s[i].active(_)) {
				var name = oauth2s[i].name(_);
				var displayname = oauth2s[i].displayName(_) || name;
				response.write(_, '<html><a href="' + request.url.replace("/index2.html", "/auth/oauth2-" + name + path) + '">' + displayname + '</a><br>');
			}
		}
		// if there is not setting instance, also provide link for OAuth2 server in global configuration
		var setting = db.fetchInstance(_, db.model.getEntity(_, "setting"), {
			sdataWhere: ""
		});
		if (!setting && config.session.auth === "oauth2" && typeof(config.oauth2) != "undefined") {
			response.write(_, '<html><a href="' + request.url.replace("/index2.html", "/auth/oauth2-" + path) + '">Configured OAuth2 server</a><br>');
		}
		return response.end();
	}

	// OAuth2 redirect path equals "/redirect". In order to avoid parsing every url, it will be searched using a substring function first
	if (request.url.indexOf("/oauth2/redirect") >= 0 && url.parse(request.url).pathname === "/oauth2/redirect") {
		// second step of authentication
		if (!sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth2: true
		})) return;
		// redirect to start page
		response.writeHead(303, {
			"Content-Type": "text/html",
			"Location": request.syracuseOriginalPath
		});
		response.end('<html><a href="/test">Link</a></html>');
		return;
	}

	// test request to see whether server is still alive
	if (request.url.indexOf("/licensetest") >= 0 && url.parse(request.url).pathname === "/licensetest") {
		response.writeHead(200, {
			"Content-Type": "text/plain"
		});
		console.log("LICENSETEST");
		response.end('OK');
		return;
	}

	// Processing the password change dialog
	if (request.url.indexOf("/auth/pwd--") === 0) {
		var token = request.url.substr(9);
		var newUrl = "/";
		var changePasswordModule = require('streamline-auth/lib/changePassword');
		var tmpLogin = changePasswordModule.getTempLogin(token, request.method === "GET"); // do not delete token for get request, because it will be necessary for subsequent POST request
		if (tmpLogin) {
			console.log("Login found for user " + tmpLogin.user);
			if (request.method === "GET") {
				// try to set locale for given user
				var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
				if (db) {
					var whereClause = "(login eq \"" + tmpLogin.user + "\")";
					var user = db.fetchInstance(_, db.model.getEntity(_, "user"), {
						sdataWhere: whereClause
					});
					if (user) {
						var up = db.model.getEntity(_, "userProfile").factory.createInstance(_, null, db);
						up.loadUserProfile(_, user);
						var loc = up.selectedLocale(_);
						if (loc) {
							var code = loc.code(_);
							console.log("Set locale for password page " + code);
							if (code) locale.setCurrent(_, code);
						}
					}
				}
				// make changes in template for password page to enable localization
				var answer = fs.readFile(__dirname + "/../html/newPassword.html", "utf8", _);
				answer = answer.replace("{changePasswdHeader}", locale.format(module, "changePasswdHeader", user.login(_)));
				answer = answer.replace("{newPwd}", locale.format(module, "newPwd"));
				answer = answer.replace(/\{Password\}/g, locale.format(module, "pwdPlaceholder"));
				answer = answer.replace("{explanation}", locale.format(module, "explanation"));
				answer = answer.replace("{chgPasswd}", locale.format(module, "chgPasswd"));
				answer = answer.replace("{newPwdAgain}", locale.format(module, "newPwdAgain"));
				answer = answer.replace("{different}", locale.format(module, "different"));
				answer = answer.replace("{empty}", locale.format(module, "notEmpty"));
				answer = answer.replace("{invalid}", locale.format(module, "invalidChar", "XXX")); // when you change "XXX", do this also in newPassword.html
				answer = answer.replace("{login}", user.login(_));
				answer = answer.replace("{realm}", config.session.realm);
				answer = answer.replace("{action}", "/auth/pwd" + token); // re-use token;
				response.writeHead(403, {
					"Content-Type": "text/html; charset=utf8"
				});
				response.end(answer);
				return;
			} else {
				// set new password
				var content = request.readAll(_);
				if (content) {
					var stringContent = content.toString("utf8");
					var query = querystring.parse(stringContent);
					var user;
					if (tmpLogin.user.toLowerCase() === query.login.toLowerCase()) {
						var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
						// fetch user
						var whereClause = "(login eq \"" + query.login + "\")";
						var users = db.fetchInstances(_, db.model.getEntity(_, "user"), {
							sdataWhere: whereClause
						});
						if (users && users.length) {
							// console.log("User found");
							user = users[0];
						}
					}
					if (user) {
						user.password(_, query.passwordHash);
						user.changePassword(_, false);
						user.save(_);
						// console.log("Password changed");
						var token = changePasswordModule.setTempLogin({
							user: query.login
						});
						// new url: replace or set authentication token in path, when it already starts with /auth/...,
						// otherwise add /auth/std prefix with authentication token
						if (tmpLogin.url.substr(0, 6) === "/auth/") {
							newUrl = tmpLogin.url.replace(/^(\/auth\/(?:std|digest|basic|oauth2-\w*))(?:\-\-[0-9a-fA-F]*)?/, "$1" + token);
						} else {
							newUrl = "/auth/std" + token + tmpLogin.url;
						}
					}
				}
			}
		}
		response.writeHead(303, {
			"Content-Type": "text/html",
			"Location": newUrl
		});
		response.end('<html><a href="/test">Link</a></html>');
		return;
	}

	// this is called when all sessions should end
	if (request.url.indexOf("/notifyEnd") >= 0 && url.parse(request.url).pathname === "/notifyEnd") {
		response.writeHead(200, {
			"Content-Type": "text/plain"
		});
		console.log("NOTIFY END");
		response.end('OK');
		notifyEnd(_); // function which manages end of sessions
		return;
	}

	// this is called when all sessions should end
	if (request.url.indexOf("/notificationAll") >= 0 && url.parse(request.url).pathname === "/notificationAll") {
		response.writeHead(200, {
			"Content-Type": "text/plain"
		});
		require('syracuse-event/lib/scheduler').scheduleAll(_); // function which updates local notification array
		response.end('OK');
		return;
	}


	// do the patch integration
	if (request.url.indexOf("/patchIntegration") >= 0) {
		var path = url.parse(request.url).pathname;
		var answer = "OK";
		if (path.substr(0, 17) === "/patchIntegration") {
			path = path.substr(17); // remainder of the path
			request.setEncoding("utf8");
			console.log("patch integration");
			var patchdata = request.readAll(_);
			if (!patchdata) {
				response.writeHead(500, {
					"Content-Type": "text/plain"
				});
				response.end('No patch data');
				console.log("No patch data");
				return;
			}
			// batch integration
			if (path === "/batch") {
				try {
					var result = require('syracuse-collaboration/lib/entities/patch').batchIntegration(patchdata, _);
					answer = result;
				} catch (e) {
					response.writeHead(500, {
						"content-Type": "text/plain"
					});
					response.end("1;" + e);
				}
			} else if (path === "/unlock") {
				require('syracuse-collaboration/lib/entities/patch').setLock(_, false);
				answer = "Unlocked";
			} else {
				require('syracuse-patch/lib/integrate').clusterPatch(null, patchdata, {}, _);
				answer = "local patch integrated";
			}
			console.log("patch integrated");
			response.writeHead(200, {
				"Content-Type": "text/plain"
			});
			response.end(answer);
			return;
		}
	}

	// check consistency of the installation
	if (request.url.indexOf("/consistency") >= 0 && url.parse(request.url).pathname === "/consistency") {
		var result = require('syracuse-patch/lib/patchtools').checkChecksumsAll(_);
		console.log("consistency test");
		response.writeHead(200, {
			"Content-Type": "text/plain"
		});
		response.end(JSON.stringify(result));
		return;
	}

	// re-read license from database
	if (request.url.indexOf("/licensecheck") >= 0 && url.parse(request.url).pathname === "/licensecheck") {
		console.log("LIC CHECK");
		check.checkNamed(_); // no instance here in order to avoid infinite loop!
		console.log("LIC CHECK");
		response.writeHead(200, {
			"Content-Type": "text/plain"
		});
		response.end('OK');
		return;
	}

	// update license (license is contained in POST data)
	if (request.url.indexOf("/licenseupdate") >= 0 && url.parse(request.url).pathname === "/licenseupdate") {
		var content = request.readAll(_).toString("utf8");
		response.writeHead(200, {
			"Content-Type": "text/plain"
		});
		console.log("Update request");
		var updateResult = check.updateLicense(content, _);
		response.end(updateResult ? 'Valid license' : 'No valid license');
		return;
	}

	if (/(config|main|mobile)\.html/.exec(request.url)) {
		if (!sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		})) {
			return;
		}
	}

	// strip authentication header
	if (request.url.indexOf("/auth/") >= 0 && url.parse(request.url).pathname.indexOf("/auth/") === 0) {
		var requestUrl = request.url;
		request.url = request.url.replace(/\/auth\/[\w-]+/, "");
		if (!request.url || request.url === "/") {
			response.writeHead("301", {
				Location: requestUrl + "/index.html"
			});
			return response.end();
		}
	}

	function nav(tb) {
		return '<div class="nav ' + tb + '"><a href="/apis.md">Index</a></div>';
	}
	if (request.url.indexOf(".md") == request.url.length - 3 && request.method == "GET") {
		var html = require('ghm').parse(fs.readFile(basePath + request.url, "utf8", _));
		html = '<html><head>' + //
		'<link href="/syracuse-ui/themes/markdown.css" rel="stylesheet" type="text/css"/>' + //
		'</head><body>' + nav('top') + html + nav('bottom') + '</body></html>';
		response.writeHead("200", {
			"content-type": "text/html; charset=utf-8"
		});
		return response.end(html);
	}
	var opts;
	if (/(\?|\&)rtl=true/.test(request.url)) {
		if (/\.html/.test(request.url)) opts = htmlRtlOptions;
		else if (/\.css/.test(request.url)) opts = cssRtlOptions;
	}
	if (!staticProvider(_, request, response, opts)) {
		response.writeHead("404", {});
		return response.end("Resource not found.");
	}
}

function perfmonDispatcher(_, request, response) {
	var url = request.url.split('&')[0]; // temp hack to get rid of &format=text appended by client
	if (url === '/perfmon/session-data') {
		response.writeHead(200, {
			"Content-Type": "application/json"
		});
		var timings = (request.session && request.session.timings) || [];
		response.end(JSON.stringify({
			sessionId: request.session && request.session.id,
			children: timings,
			start: timings.length ? timings[0].start : Date.now(),
			end: Date.now(),
			memory: process.memoryUsage(),
			cpu: perfmon.cpuStats(),
			bigCpuSlices: perfmon.bigCpuSlices(),
			uptime: process.uptime(),
			versions: process.versions,
		}));
	} else {
		response.writeHead(404, {});
		return response.end("Resource not found: " + request.url);
	}
}

function memwatchDispatcher(_, request, response) {
	var url = request.url.split('&')[0]; // temp hack to get rid of &format=text appended by client
	if (url === '/memwatch/heapdiff') {
		response.writeHead(200, {
			"Content-Type": "application/json"
		});
		if (!memwatch) {
			response.end(locale.format(module, "memwatchNotAvailable"));
		} else {
			if (!heapSnapshot) response.end(locale.format(module, "mwNoSnapshot"));
			else response.end(JSON.stringify(heapSnapshot.end(), null, "\t"));
			heapSnapshot = new memwatch.HeapDiff();
		}
	} else {
		response.writeHead(404, {});
		return response.end("Resource not found: " + request.url);
	}
}

function dumpDispatcher(_, request, response) {
	var url = request.url.split('&')[0]; // temp hack to get rid of &format=text appended by client
	response.writeHead(200, {
		"Content-Type": "application/json"
	});
	var d = require("syracuse-trace/lib/dumpGlobals");
	response.end(JSON.stringify(d.dumpGlobals(_, 1, url), null, "\t"));
}

// display message to users that server will shutdown soon, do not accept new sessions any more

function notifyEnd(_) {
	config.shutDownMarker = true;
}
exports.notifyEnd = notifyEnd;

function allowOrigin(request, response) {
	if (false) { // test request URL here
		response.writeHead(403, {
			"Content-Type": "text/plain"
		});
		response.end('Origin unauthorized', 'utf8');
		return false;
	}
	var writeHead = response.writeHead;
	response.writeHead = function(status, headers) {
		var corsHeaders = ["Authorization", "X-Authorization", "X-Authorization-Mode", "X-Requested-With", "X-HTTP-Method-Override", "Content-Type", "Accept", "If-Match"];

		headers["Access-Control-Allow-Origin"] = "*", headers["Access-Control-Allow-Credentials"] = true;
		headers["Access-Control-Allow-Methods"] = "POST, GET, PUT, DELETE, OPTIONS";
		headers["Access-Control-Max-Age"] = '86400', // 24 hours
		headers["Access-Control-Allow-Headers"] = corsHeaders.join(',');

		response.writeHead = writeHead;
		return response.writeHead(status, headers);
	};
	return true;
}

function bundlesDispatcher(_, request, response) {
	var parsed = url.parse(request.url);
	if (parsed.pathname.substring(parsed.pathname.length - 3).toLowerCase() === '.md') return staticDispatcher(_, request, response);
	var name = parsed.pathname.split('/')[2];
	try {
		var bundle = require('bundles/' + name);
	} catch (e) {
		console.error(e);
		response.writeHead(404, {
			"Content-Type": "text/plain"
		});
		return response.end('bad bundle: ' + name, 'utf8');
	}
	if (!bundle.$exported || typeof bundle.httpDispatch !== 'function') {
		response.writeHead(404, {
			"Content-Type": "text/plain"
		});
		return response.end('unauthorized bundle: ' + name, 'utf8');
	}
	return bundle.httpDispatch(_, request, response);
}


function redirectProvider(rootUrl) {
	return function(_, request, response) {
		var url = url.resolve(rootUrl, request.url);
		response.writeHead(307, {
			location: url,
			"content-type": "text/html"
		});
		response.end('<html><head><a href="' + url + '">Visit ' + url + '</a></head><body></body></html>', 'utf8');
		return true;
	};
}


var _map = {
	sdata: function(_, request, response) {
		return allowOrigin(request, response) && sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && sdataDispatcher(_, request, response);
	},
	trans: function(_, request, response) {
		return allowOrigin(request, response) && sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && x3Dispatcher(_, request, response);
	},
	"soap-ws": function(_, request, response) {
		return allowOrigin(request, response) && sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && wsDispatcher(_, request, response);
	},
	"soap-stubs": function(_, request, response) {
		return allowOrigin(request, response) && sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && stubDispatcher(_, request, response);
	},
	print: function(_, request, response) {
		return allowOrigin(request, response) && sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && printDispatcher(_, request, response);
	},
	xtend: function(_, request, response) {
		return allowOrigin(request, response) && sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && xtendDispatcher(_, request, response);
	},
	upload: function(_, request, response) {
		return sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: false
		}) && upload.dispatcher(_, request, response);
	},
	tests: function(_, request, response) {
		return sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && (testServer ? testServer.dispatch(_, request, response) : response.end("No tests available"));
	},
	search: function(_, request, response) {
		return sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && searchEngine.dispatch(_, request, response);
	},
	xsearch: function(_, request, response) {
		return sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && searchEngine.dispatch(_, request, response);
	},
	// Exact search, no wildcards
	fsearch: function(_, request, response) {
		return sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && searchEngine.dispatch(_, request, response);
	},
	// Fuzzy like this search
	perfmon: function(_, request, response) {
		return sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && perfmonDispatcher(_, request, response);
	},
	memwatch: function(_, request, response) {
		return memwatchDispatcher(_, request, response);
	},
	dump: function(_, request, response) {
		return dumpDispatcher(_, request, response);
	},
	bo: function(_, request, response) {
		return x3Dispatcher(_, request, response);
	},
	bundles: function(_, request, response) {
		return sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && bundlesDispatcher(_, request, response);
	},
	help: function(_, request, response) {
		return sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && helpDispatcher(_, request, response);
	},
	require: requireDispatcher,
	logout: function(_, request, response) {
		return sessionManager.logout(_, request, response);
	}
};

function _hackRequest(_, request) {
	request.url = request.url.replace(/%27/g, "'"); // for regexp parsing
	var fs = request.url.split('/')[1];
	if (fs) fs = fs.split('?')[0]; // example /proxy?url=...
	var page = /^\/sdata\/syracuse\/ui\/syracuse\/pages\('([^%]*)'\)$/.exec(request.url);
	if (page) request.url = "/syracuse-main/html/" + page[1].replace(/\./g, '/').replace(/\/\$/, "-$") + ".json";
}

function _errorHandler(err) {
	if (err) console.error(err.message + "\n" + err.stack);
}

// see later

function HttpContext(request, response) {
	this.request = request;
	this.response = response;
	var parts = request.url.split('?');
	var segments = parts.splice(0, 1)[0].split('/');
	var segI = 0;
	this.queryString = helpers.url.parseQueryString(parts.join('?'));
}

function _makeHttpServerOptions(secure) {
	return secure ? {
		secure: true,
		// The Server's SSL Key
		key: fs.readFileSync(path.join(__dirname, 'ssl/server.key'), "utf8"),
		// The Server's Cert
		cert: fs.readFileSync(path.join(__dirname, 'ssl/server.crt'), "utf8"),
		// The CA (us in this case)
		ca: [fs.readFileSync(path.join(__dirname, 'ssl/ca.crt'), "utf8")],
		// Ask for the client's cert
		requestCert: true,
		// Don't automatically reject
		rejectUnauthorized: false
	} : null;
}

function _enableCompression(request, response) {
	if (!request.headers || !request.headers['accept-encoding'] //
		|| request.headers['accept-encoding'].split(',').indexOf('gzip') === -1
		// only compress AJAX requests, not resources loaded by <script> directives.
		// otherwise browser does not try to cache them :-(
		|| request.headers['x-requested-with'] !== 'XMLHttpRequest') return response;
	var writeHead = response.writeHead;
	var write = response.write;
	var end = response.end;
	var zipWriter;
	var err;

	response.writeHead = function(status, headers) {
		if (!headers["content-encoding"] && //
			// only compress selected mime types (images, for ex, are already compressed)
			/^(text|application|multipart)\//.test(headers["content-type"] || headers["Content-Type"])) {
			headers["content-encoding"] = "gzip";
			headers["transfer-encoding"] = "chunked";
			delete headers["content-length"];
			var zipper = zlib.createGzip(config.hosting.compressOptions || {
				// I prefer trading a bit of size for speed. 
				// Default level (6) gains about 20% in size but doubles CPU usage.
				// see http://tukaani.org/lzma/benchmarks.html
				level: 1,
			});
			zipWriter = ez.devices.node.writer(zipper);
			var zipReader = ez.devices.node.reader(zipper);
			// bind is necessary here because of a streamline-fast bug. I'll fix later
			zipReader.pipe.bind(zipReader)(_ >> function(e) {
				if (e) err = e;
			}, {
				write: write
			});
			//console.log("COMPRESSING: " + headers["content-type"] + ": " + request.url);
		}
		writeHead.call(response, status, headers);
	};

	response.write = function(_, data, enc) {
		if (err) throw err;
		if (zipWriter) return zipWriter.write(_, data && enc ? new Buffer(data, enc) : data != null ? data : undefined);
		else return write.call(_, response, data, enc);
	};

	response.end = function(data, enc) {
		if (err) throw err;
		if (zipWriter) return zipWriter.end(data && enc ? new Buffer(data, enc) : data != null ? data : undefined);
		else return end.call(response, data, enc);
	};
	return response;
}

function getinitializingPageContent(text, url) {
	var delay = 2,
		content = '<!DOCTYPE html>';
	content += '<html><head>';
	content += '<META HTTP-EQUIV="refresh" content="' + delay + ';URL=' + url + '">';
	content += '<style>';
	content += 'body { font-family:Arial, Helvetica, sans-serif; font-stretch:wider; }';
	content += '</style>';
	content += '</head>';
	content += '<body>';
	content += text;
	content += '</body></html>';
	return content;
}
// global request id to avoid some context mixup betwenn sessions in some extreem cases
var requestCnt = 0;

function disp(request, response, _) {
	if (!_initialized) return response.end(getinitializingPageContent(locale.format(module, "initializing"), request.url));
	//
	var timing = perfmon.start(module, "main.httpDispatch", request.method + ' ' + request.url),
		mem1 = process.memoryUsage(),
		mem2;
	try {
		// ease access to config in code
		globals.context.config = config;
		globals.context.requestId = requestCnt++;
		// take care of hosting options first
		// tenantId must be set before calling initAsync(_)
		if (config.hosting.multiTenant) {
			var host = request.headers.host;
			if (!host) throw new Error("host header missing");
			globals.context.tenantId = host.split(/[.:]/)[0];
		}
		request.hosting = config.hosting;

		initAsync(_);

		//console.log("request (408): "+sys.inspect(request));
		if (!config.hosting.nocompress) response = _enableCompression(request, response);
		request.context = new HttpContext(request, response);
		// workaround for a nodejs bug
		// see http://groups.google.com/group/nodejs/browse_thread/thread/9189df2597aa199e/965cfa9b7968666d
		// tested with 0.6.7: it works
		//		request.unread(request.readAll(_));
		//
		_hackRequest(_, request);
		//
		var fs = request.url.split('/')[1];
		if (fs) fs = fs.split('?')[0]; // example /proxy?url=...
		var dispatch = _map[fs] || staticDispatcher;
		//		flows.callWithTimeout(_, function(_) {
		dispatch(_, request, response);
		//		}, 119000);
	} catch (err) {
		if (err.code === "ETIMEOUT") err.message = locale.format(module, "dispatchTimeout", request.url);
		_errorHandler(err);
		response.writeHead(500, {
			"Content-Type": "text/plain"
		});
		response.end(err.message + "\n" + err.stack);
	} finally {
		// record timing, except if this is a request to the performance monitor itself.
		if (request.url.indexOf('/perfmon/') != 0) timing.end();
		request.session && request.session.addTimings();

		// maybe kill node at the end of this request
		if (request.context && request.context.kill) {
			try {
				console.log("Final function before killing");
				request.context.kill();
				console.log("Kill node");
				process.kill(process.pid);
			} catch (e) {
				console.log("Error in kill function " + e);
			}
		}
		mem2 = process.memoryUsage();
		var diff = {
			rss: (mem2.rss - mem1.rss) / 1024 / 1024,
			heapTotal: (mem2.heapTotal - mem1.heapTotal) / 1024 / 1024,
			heapUsed: (mem2.heapUsed - mem1.heapUsed) / 1024 / 1024
		};
		var threshold = 10;
		if (diff.rss > threshold || diff.heapTotal > threshold || diff.heapUsed > threshold) {
			var session = request.session,
				up = session && session.getUserProfile(_),
				ep = up && up.selectedEndpoint(_),
				endpointName = ep && (ep.application(_) + "/" + ep.contract(_) + "/" + ep.dataset(_)),
				login = session.getUserLogin(_);
			console.log((new Date()).toISOString() + ": " + request.method + ' ' + request.url);
			console.log("  memory usage diff=" + JSON.stringify(diff) + " before=" + JSON.stringify(mem1) + " after=" + JSON.stringify(mem2));
			console.log("  login=" + login + ", endpoint=" + endpointName);
		}
	}
}

exports.startServers = function(_, port) {
	if (process.argv[2] === "STOP") {
		initAsync(_, true); // just initialization, then finish the application
		process.exit(0);
	}
	if (process.argv[2] === "batchpatch") {
		var code = 0;
		try {
			code = require('syracuse-patch/lib/integrate').batchIntegration(_, process.argv[3]);
		} catch (e) {
			console.error(e.stack);
			code = 1;
		}
		process.exit(code);
	}
	port = port || config.port || 8124;
	//Port init
	config.sdata.httpRoot = config.sdata.httpRoot || "http://localhost:" + port;
	// start http or mock server
	if ((!config.hosting.multiTenant || globals.context.tenantId) && (exports.server instanceof mock.MockStreamServer)) {
		initAsync(_); // do initialization before listening when started from nanny process
	}
	exports.server.listen(_, port);
	console.log('Server running at http://localhost:' + port + '/');
	if (exports.integrationServer) {
		exports.integrationServer.listen(_, config.integrationServer.port);
		console.log('Integration server running at http://localhost:' + config.integrationServer.port + '/');
	}
	// init async (important for tests)
	if (!config.hosting.multiTenant || globals.context.tenantId) initAsync(_);
};

exports.main = function() {
	exports.startServers(_ >>
		function(err) {
			if (err) throw err;
		});
};

if (process.argv[2] && process.argv[2].substr(0, 1) === "N") {
	// use output stream which writes to file descriptor 3 (to avoid conflict with normal standard output)
	exports.server = new mock.MockStreamServer(disp, new mock.DescriptorWriteStream(3), process.stdin, {
		timeout: 1 * (process.argv[3] || 0)
	});
	config.mockServer = exports.server;
	// kill process when pipe breaks (i. e. nanny process has been killed)
	process.stdin.on('close', function() {
		console.log("stdin closed - finish process");
		process.exit(0);
	});
} else {
	exports.server = http.server(disp, _makeHttpServerOptions((config.session || {}).secure));
	exports.server.setTimeout(10 * 60 * 1000);
}

if (config.integrationServer && config.integrationServer.port) exports.integrationServer = new streams.createHttpServer(disp, _makeHttpServerOptions(true));

exports.config = config;

if (helpers.enableDeveloppementFeatures) {
	require("streamline-doctool").generate(_ >> _errorHandler, basePath, config.docTool);
	if (fs.existsSync(__dirname + "/../../../.git") && fs.existsSync(__dirname + "/../../tools/git")) {
		require("tools/git/setupHooks");
	}
}

// setup memory leak watcher
memwatch && memwatch.on("leak", function(info) {
	var log = "";
	try {
		log = JSON.stringify(info, null, "\t");
	} catch (e) {
		log = info;
	}
	console.error("MEMWATCH LEAK DETECTED: " + log);
});

// exception and exit handlers
process.on('uncaughtException', function(err) {
	_errorHandler(err);
});
process.on('exit', function() {
	console.log("Exiting ...");
});
// make it invoke onExit
try {
	process.on('SIGINT', process.exit);
} catch (e) {
	console.log("SIGINT not yet available on Windows");
}

// patch streams.httpRequest to get performance monitoring on all outgoing HTTP requests
(function() {
	var originalHttpRequest = streams.httpRequest;
	streams.httpRequest = function(options) {
		var req = originalHttpRequest(options);
		var originalResponse = req.response;
		req.response = function(_) {
			var timing = perfmon.start(module, "httpClient.response", options.url);
			try {
				return originalResponse.call(req, _);
			} finally {
				timing.end();
			}
		};
		return req;
	};
})();

syncInitTiming.end();

var initializedTenants = {};

// Initializations
// simplified: the simplified initialization is for special use when no normal request need to be processed but
// the application should only be started to execute a certain administrative batch task and then finish
// (e. g. node index PATCH for patch integration)

function initAsync(_, simplified) {
	var key = globals.context.tenantId || "$$solo";
	if (initializedTenants[key]) return;
	initializedTenants[key] = true;

	var asyncInitTiming = perfmon.start(module, "main.asyncInit");
	// WARNING: async code below => require will yield and return incomplete API
	var admEp = adminHelpers.AdminHelper.getCollaborationEndpoint(_);
	if (admEp && config.collaboration) {
		var dataset = admEp.dataset(_);
		if (dataset !== config.collaboration.dataset) {
			console.error("Different collaboration dataset in Syracuse endpoint (" + dataset + ") and nodelocal.js (" + config.collaboration.dataset + ")");
			process.exit(1);
		}
	}
	// for emergency, if collaboration endpoint points to wrong database
	if (process.argv[2] === "--rescueEndpoint" && admEp) {
		admEp.localDatabase(_, true);
		admEp.save(_);
		console.log("Set local database for collaboration endpoint");
	}
	// load all endpoints
	sdataRegistry.loadAllEndpoints(_);
	// cleanup
	sessionManager.cleanupSessionInfos(_);
	// update badges
	require("syracuse-collaboration/lib/entities/badge").updateBadges(_);
	// scheduler (no wait)
	if (!simplified) adminHelpers.AdminHelper.startTimers(!_);
	// register afterSave events for transparent indexing
	indexEngine.registerModelEvents(_, config.searchEngine);

	asyncInitTiming.end();
	//
	_initialized = true;
}

function runPatch(_) {
	console.log("Final patch integration");
	initAsync(_, true);
	require('syracuse-patch/lib/patchtools').finalIntegration(_);
	// patch integration process finishes here
	// unlock system
	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
	var setting = db.fetchInstance(_, db.model.getEntity(_, "setting"), {
		sdataWhere: ""
	});
	if (setting) {
		setting.patchLock(_, false); // release semaphore lock
		setting.save(_);
	}
	process.exit(0);
}

exports.runPatchCb = function(cb) {
	runPatch(_ >> cb);
};