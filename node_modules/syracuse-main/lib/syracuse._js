"use strict";

var http = require('http');
var fs = require('fs');
var path = require('path');
var config = require('./nodeconfig').config; // must be first syracuse require
var locale = require('syracuse-core/lib/locale');
var sdata = require('syracuse-sdata/lib/sdataDispatch');
var x3Disp = require('syracuse-x3/lib/x3Dispatch');
var upload = require('streamline-upload/lib/upload');
var EventEmitter = require('events').EventEmitter;
var port = config.port || 8124;
var basePath = path.join(path.dirname(module.filename), "../..");
var helpers = require('syracuse-core/lib/helpers');
var testServer = require('test-runner/lib/server/testServer');
var sessionManager = require('syracuse-session/lib/sessionManager').sessionManager;
var proxyManager = require('syracuse-proxy/lib/proxy').proxyManager;
var requireDispatcher = require('streamline-require/lib/server/require').dispatcher({
	getResources: locale.getResourcesHook
});
var liveServer = require('syracuse-live/lib/liveServer').liveServer;
var x3Pool = require('syracuse-x3/lib/pool');
var streams = require('streamline/lib/streams/streams');
var factory = require('syracuse-orm/lib/factory');
var mongodb = require('syracuse-orm/lib/mongoDbHandle');
var searchEngine = require('syracuse-search/lib/elasticSearch');
var adminUtil = require('syracuse-collaboration/lib/util');
var adminHelpers = require('syracuse-collaboration/lib/helpers');
var sys = require("util");
var ldapauth;
// load ldapauth only if LDAP is required 
if (config.session.useLdap === true)
  ldapauth = require("ldapauth");

  // initializing sequence emitter, allow to wait the server initialization
exports.initializerStatus = new EventEmitter();

var extMap = {
	htm: "text/html",
	html: "text/html",
	txt: "text/plain",
	js: "application/javascript",
	json: "application/json",
	css: "text/css",
	png: "image/png",
	gif: "image/gif",
	jpg: "image/jpeg",
	jpeg: "image/jpeg",
	xml: "text/xml"
};

var sdataRegistry = require("syracuse-sdata/lib/sdataRegistry");
var dataModel = require("syracuse-orm/lib/dataModel")

var authModule = require("streamline-auth/lib/basic").create(function(session, login, password, _) {
	// not useful anymore as guest is created at initialization
	//	if (login == "guest" && password == "guest") return true;
    if (ldapauth) // ldap authentication
    {
      var auth = new ldapauth(config.ldap);
      try
      {
        var user = auth.authenticate(login, password, _);
        if (user) session.setData("userID", user.dn);
      }
      catch (e)
      {
        console.log(e);
        auth.close(_);
        return false;
      }
      auth.close(_);
      return true;
    }

	var user = null;
	var contract = sdataRegistry.getContract(config.collaboration.application, config.collaboration.contract, true);
	var dataset = config.collaboration.dataset;
	var model = dataModel.make(contract, dataset);
	var db = dataModel.getOrm(_, model, contract.datasets[dataset]);
	// fetch user
	var users = db.fetchInstances(_, model.getEntity("user"), {
		sdataWhere: "(login eq \"" + login + "\") and (password eq \"" + password + "\")"
	});
	//		var users = db.fetchInstances(_, model.getEntity("user"));
	if (users && users.length) user = users[0];
	if (user) session.setData("userID", user.$uuid);
	return user != null;
});

// config dispatcher before modules setup as it does sdataRegistry.register
config.sdata.httpRoot = config.sdata.httpRoot || "http://localhost:" + port;
var sdataDispatcher = sdata.dispatcher(config.sdata);
var x3Dispatcher = x3Disp.x3dispatcher(config);
// default collaboration config
config.collaboration = config.collaboration || {};
config.collaboration.contract = config.collaboration.contract || "syracuse";
config.collaboration.application = config.collaboration.application || "collaboration";
config.collaboration.dataset = config.collaboration.dataset || "syracuse";
// modules setup
adminUtil.setup(config.collaboration);
adminHelpers.setup(config.collaboration);
factory.setup(config.factory);
// setup a connection cache for mongodb
var mongoConnPool = {};
mongodb.setup(config.mongodb, mongoConnPool);
// configure x3Pool first as it modifies proxy map
config.proxy = config.proxy || {};
config.proxy.map = config.proxy.map || [];
x3Pool.setup(config.x3Pool, config.proxy.map)
sessionManager.setup(config.session, authModule);
proxyManager.setup(config.proxy);
//
searchEngine.setup(config.searchEngine);

var staticProvider = require('streamline-static/lib/staticProvider').staticProvider(basePath);

function staticDispatcher(_, request, response) {
//	var defaultPageExp = /\/$|(\/default|\/index)\.(html|htm)/;
	var defaultPageExp = /\/$|(\/default)\.(html|htm)/;
	// default page(s)
	if (defaultPageExp.exec(request.url)) {
		//	if (/(\/$|\/default|\/index)\.(html|htm)/.exec(request.url)) {
		// is mobile ?
		if (/(M|m)+obile/.exec(request.headers["user-agent"])) {
			response.writeHead("301", {
				Location: request.url.replace(defaultPageExp, "/indexMobile.html")
			})
		} else {
			response.writeHead("301", {
//				Location: request.url.replace(defaultPageExp, "/syracuse-main/html/main.html?url=" + encodeURIComponent("?representation=home.$dashboard"))
				Location: request.url.replace(defaultPageExp, "/index.html")
			})
		}
		return response.end();
	}
	if (/(main|mobile)\.html/.exec(request.url)) {
		if (!sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		})) return;
	}
	if (request.url.indexOf(".md") == request.url.length - 3 && request.method == "GET") {
		var html = require('markdown').parse(fs.readFile(basePath + request.url, "utf8", _));
		html += "<h2>Warning</h2><p>Current theme is GPL -- find another one with different license</p>"
		html = '<html><head>' + '<link href="/syracuse-ui/themes/markdown.css" rel="stylesheet" type="text/css"/>' + '</head><body>' + html + '</body></html>';
		response.writeHead("200", {
			"content-type": "text/html"
		});
		return response.end(html);
	}
	if (!staticProvider(_, request, response)) {
		response.writeHead("404", {});
		return response.end("Resource not found.");
	}
}

function allowOrigin(request, response) {
	if (false) { // test request URL here
		response.writeHead(403, {
			"Content-Type": "text/plain"
		});
		response.end('Origin unauthorized', 'utf8');
		return false;
	}
	var writeHead = response.writeHead;
	response.writeHead = function(status, headers) {
		var corsHeaders = ["Authorization", "X-Authorization", "X-Authorization-Mode", "X-Requested-With", "X-HTTP-Method-Override", "Content-Type", "Accept", "If-Match"];

		headers["Access-Control-Allow-Origin"] = "*", headers["Access-Control-Allow-Credentials"] = true;
		headers["Access-Control-Allow-Methods"] = "POST, GET, PUT, DELETE, OPTIONS";
		headers["Access-Control-Max-Age"] = '86400', // 24 hours
		headers["Access-Control-Allow-Headers"] = corsHeaders.join(',');

		response.writeHead = writeHead;
		return response.writeHead(status, headers);
	};
	return true;
}

var _map = {
	sdata: function(_, request, response) {
		return allowOrigin(request, response) && sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && sdataDispatcher(_, request, response);
	},
	trans: function(_, request, response) {
		return allowOrigin(request, response) && sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && x3Dispatcher(_, request, response);
	},
	upload: function(_, request, response) {
		return sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: false
		}) && upload.dispatcher(_, request, response);
	},
	proxy: function(_, request, response) {
		return sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && proxyManager.proxy(_, request, response);
	},
	tests: function(_, request, response) {
		return sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && testServer.dispatch(_, request, response);
	},
	search: function(_, request, response) {
		return sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && searchEngine.dispatch(_, request, response);
	},
	require: requireDispatcher
};

function _hackRequest(_, request) {
	request.url = request.url.replace(/%27/g, "'"); // for regexp parsing
	var fs = request.url.split('/')[1];
	if (fs) fs = fs.split('?')[0]; // example /proxy?url=...
	var page = /^\/sdata\/syracuse\/ui\/syracuse\/pages\('([^%]*)'\)$/.exec(request.url);
	if (page) request.url = "/syracuse-main/html/" + page[1].replace(/\./g, '/').replace(/\/\$/, "-$") + ".json";
}

function _errorHandler(err) {
	if (err) console.error(err.message + "\n" + err.stack);
}

// see later

function HttpContext(request, response) {
	this.request = request;
	this.response = response;
	var parts = request.url.split('?');
	var segments = parts.splice(0, 1)[0].split('/');
	var segI = 0;
	this.queryString = helpers.url.parseQueryString(parts.join('?'));
}

exports.server = new streams.HttpServer(function(request, response, _) {
	try {
		// console.log("syracuse main: " + request.url);
		request.context = new HttpContext(request, response);
		// workaround for a nodejs bug
		// see http://groups.google.com/group/nodejs/browse_thread/thread/9189df2597aa199e/965cfa9b7968666d
		// tested with 0.6.7: it works
//		request.unread(request.readAll(_));
		//
		_hackRequest(_, request);
		//
		var fs = request.url.split('/')[1];
		if (fs) fs = fs.split('?')[0]; // example /proxy?url=...
		var dispatch = _map[fs] || staticDispatcher;
		dispatch(_, request, response);
	} catch (err) {
		_errorHandler(err);
		response.writeHead(500, {
			"Content-Type": "text/plain"
		});
		response.end(err.message + "\n" + err.stack);
	}
});
exports.config = config;
exports.liveServer = liveServer;

require("streamline/lib/tools/docTool").generate(_errorHandler, basePath);
// load all endpoints
sdataRegistry.loadAllEndpoints(_);
// cleanup
sessionManager.cleanupSessionInfos(_);

global.__context = {
	errorHandler: _errorHandler
}
process.on('uncaughtException', function(err) {
	_errorHandler(err);
});
// sessions cleanup
process.on('exit', function() {
	console.log("Exiting ...");
});
// make it invoke onExit
try {
	process.on('SIGINT', process.exit);
} catch(e) {
	console.log("SIGINT not yet available on Windows");
}
console.log("Running node version " + process.version);
// initialize phase ended
exports.initializerStatus.emit("initialized");