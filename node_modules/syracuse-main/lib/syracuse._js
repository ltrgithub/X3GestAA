"use strict";

var http = require('http');
var fs = require('fs');
var path = require('path');
var os = require('os');
var config = require('./nodeconfig').config; // must be first syracuse require
var locale = require('syracuse-core/lib/locale');
var sdata = require('syracuse-sdata/lib/sdataDispatch');
var ws = require('syracuse-soap/lib/server/wsDispatch');
var stub = require('syracuse-soap/lib/client/stubDispatch');
var x3Disp = require('syracuse-x3/lib/x3Dispatch');
var upload = require('streamline-upload/lib/upload');
var EventEmitter = require('events').EventEmitter;
var globals = require('streamline/lib/globals');
var mock = require('syracuse-load/lib/mock')
var crypto = require('crypto')

if (/^N?\d+$/.test(process.argv[2]))
	config.port = process.argv[2];
config.port  = config.port || 8124;
var port = config.port;
config.servername =  os.hostname();
if (config.license && config.license.domain) {
	config.servername += ("."+config.license.domain);
}
config.servername += ":"+config.port;
config.session = config.session || {}
config.session.realm = config.session.realm || "Syracuse";


var basePath = path.join(path.dirname(module.filename), "../..");
var helpers = require('syracuse-core/lib/helpers');
var testServer = require('test-runner/lib/server/testServer');
var sessionManager = require('syracuse-session/lib/sessionManager').sessionManager;
var proxyManager = require('syracuse-proxy/lib/proxy').proxyManager;
var requireDispatcher = require('streamline-require/lib/server/require').dispatcher({
	getResources: locale.getResourcesHook
});
var x3Pool = require('syracuse-x3/lib/pool');
var streams = require('streamline/lib/streams/streams');
var factory = require('syracuse-orm/lib/factory');
var mongodb = require('syracuse-orm/lib/mongoDbHandle');
var searchEngine = require('syracuse-search/lib/elasticSearch');
var indexEngine = require('syracuse-search/lib/elasticIndex');
var adminUtil = require('syracuse-collaboration/lib/util');
var adminHelpers = require('syracuse-collaboration/lib/helpers');
var check = require('syracuse-license/lib/check')

var sys = require("util");
var url = require('url');
var querystring = require('querystring');

  // initializing sequence emitter, allow to wait the server initialization
exports.initializerStatus = new EventEmitter();

var extMap = {
	htm: "text/html",
	html: "text/html",
	txt: "text/plain",
	js: "application/javascript",
	json: "application/json",
	css: "text/css",
	png: "image/png",
	gif: "image/gif",
	jpg: "image/jpeg",
	jpeg: "image/jpeg",
	xml: "text/xml"
};

var sdataRegistry = require("syracuse-sdata/lib/sdataRegistry");
var dataModel = require("syracuse-orm/lib/dataModel")


/** check user (and password) for different authentication methods. User name must be in user table
 * parameters:
 * session: current session (which will receive data of current user in case of success
 * login: login user name
 * password: password of user (from basic authentication)
 * passwordCheck: function which checks password (for digest authentication). It takes one parameter (the password from MongoDB) and returns
 *                true when the password is correct
 * method: authentication method (basic, digest, oauth2...)
 * standardSetting: standard setting singleton
 * Return codes: 0 OK, 1 authentication failure, 2 no license 
*/
function _userCheck(session, login, password, passwordCheck, method, standardSetting, _) {
	var user = null;        
	var realm = config.session.realm
	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
	// fetch user
    var whereClause = "(login eq \"" + login + "\")";
	var users = db.fetchInstances(_, db.model.getEntity("user"), {
		sdataWhere: whereClause
	});
	if (users && users.length) {
      user = users[0];
	  if (!user.active(_)) // no login for inactive users!
		user = null;
	}
	if (user) {
		var localConfig = {};
		var userAuthentication = user.authentication(_);
		if (!userAuthentication) {
			if (!standardSetting) standardSetting = adminHelpers.AdminHelper.getStandardSetting(_);
			// 	clone standardSetting
			var member;
			for (member in standardSetting) localConfig[member] = standardSetting[member];
		}
		else
		{
			switch (userAuthentication) {
			case "db":
				localConfig.method = config.session.auth
				localConfig.source = "db";
				break;
			case "ldap":
				if (method === "digest") return "No HTTP digest authentication with LDAP" 
				localConfig.method = "basic";
				localConfig.source = "ldap";
				localConfig.ldap = user.ldap(_)._data;
				break;
			case "oauth2":
				var localOAuth2 = user.oauth2(_)._data;
				localConfig.method = "oauth2-"+(localOAuth2.name || "");
				localConfig.oauth2 = localOAuth2;
				break;
			default:
				// 	!!! error handling
				console.log("Wrong authentication method "+userAuthentication);
				return locale.format(module, "wrongAuth", userAuthentication);
			}
		}

		// for OAuth2: when the chosen OAuth2 server does not match the OAuth2 server of the user, then login is not possible
		if (localConfig.method !== method && (localConfig.method.indexOf('oauth') >= 0 || method.indexOf('oauth') >= 0)) {
			console.log("Wrong OAuth2 server "+localConfig.method+ " - " +method);
			user = null;        
		}
		else if (localConfig.source == "db") {
			// apply hash function from RFC2617

			// **** Disabled until fixed ****
			if (passwordCheck) {
				if (!passwordCheck(user.password(_))) user = null;
			} else {
			    var hash = crypto.createHash('MD5');
			    var a1 = user.login(_)+":"+realm+":"+password
			    hash.update(a1)
				password = hash.digest("hex")
				if (password !== user.password(_)) user = null;				
			}
		} else if (localConfig.source == "ldap") {
			var ldapName = user.authenticationName(_) || user.login(_);
			if (!localConfig.ldap.active) { // server inactive: no authentication
				console.log("LDAP server inactive");
				user = null;
			} else {
				var ldapauth = require("syracuse-ldap").ldapauth;
				localConfig.ldap.cache =  false;
				var auth = new ldapauth(localConfig.ldap);
				try {
					auth.authenticate(ldapName, password, _);
				}
				catch (e) {
					console.log(e);
					user = null;
				} finally {
					auth.close(_);
				}
			}
		} else { // OAuth2 authentication
			// 	nothing to do because it has already been checked whether OAuth2 is correct
		}
		// License check
		if (user) {
			var p = user.preferences(_);
			var role;
			if (p) {
				// force user locales: hack request accept-language header
				var l = p.lastLocaleCode(_);
				// check if locale exists
				if(globals.context && globals.context.request && l && user.getUserLocaleByCode(_, l))
					globals.context.request.headers["accept-language"] = l;
				// take last role from user preferences
				role = p.lastRole(_);
			}
			// no role from user preferences - take role from groups
			if (!role) {
				var groups = user.groups(_).toArray(_);
				for (var j = 0; j<groups.length; j++) {
					var group = groups[j]
					role = group.role(_)
					if (role) break; // role found
				}
			}
			if (role && !check.checkConcurrent(session, role, user.login(_), _)) {
				return 2;
			} 
		}
		if (user) {
			session.setData("userID", user.$uuid);
			session.setData("userLogin", user.login(_));
		}
    }
	return (user == null ? 1 : 0);
}

function _certUserCheck(session, login, standardSetting, _) {
	var user = null;        
	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
	// fetch user
	var user = db.fetchInstance(_, db.model.getEntity("user"), {
		jsonWhere: {
			login: login,
			active: true
		}
	});
	if (user) {
		// License check
		var p;
		if (p = user.preferences(_)) {			
			
			// find out badges for current user
			
			var role = p.lastRole(_);
			if (role && !check.checkConcurrent(session, role, user.login(_), _)) {
				return 2;
			} 
			
			// force user locales: hack request accept-language header
			var l = p.lastLocaleCode(_);
			// check if locale exists
			if(globals.context && globals.context.request && l && user.getUserLocaleByCode(_, l))
				globals.context.request.headers["accept-language"] = l;
		}
		session.setData("userID", user.$uuid);
		session.setData("userLogin", user.login(_));
		return 0;
	} else
		return 1;
}
// obtain module for authentication from request url and standard configuration
var getAuthModule = function(request, redirect, _) {
	// TODO: for now, if secure connection, use of client certificates having CN mapping to a valid user name
	// later, have a possibility of generic client certificate and / or ability to change user
	// certificate auth >>>
	if('authorized' in request.connection)
		return require("streamline-auth/lib/certificate").create(_certUserCheck, standardSetting);
	// certificate auth <<<
	var result;
	var parsed = url.parse(request.url);
	var pathname;
	if (redirect) { // use original URL
		pathname = querystring.parse(parsed.query).state;
		request.syracuseOriginalPath = pathname;
	} else {	
		pathname = parsed.pathname;
	}
	var regexResult; // search authentication information in request.url
	var authmethod;
	var authserver;
	var setting; // either standard setting or (partial) setting derived from path: 
	// authentication header in URL path: /auth/basic or /auth/oauth2-<Name>
	regexResult = /^\/auth\/(basic|digest|oauth2-(\w*))/.exec(pathname);
	if (regexResult == null || regexResult[1] === "oauth2-") {
		var standardSetting = adminHelpers.AdminHelper.getStandardSetting(_);
		authmethod = standardSetting.method;
		if (authmethod !== "oauth2-" && regexResult) {
			console.log("No OAuth2 server according to standard config file");
			throw new Error(locale.format(module, "noOauth2"));
		}
		authserver = standardSetting.oauth2;
	} else {		
		authmethod = regexResult[1];
		if (authmethod.indexOf("oauth2") === 0) {	
			// get OAuth2 server from database
			var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
			var authserverInstance = db.fetchInstance(_, db.model.getEntity("oauth2"), {
				sdataWhere: '(name eq "' + regexResult[2] + '")'
			});
			if (!authserverInstance) {
				console.log("No OAuth2 server with name "+regexResult[2]);
				throw new Error(locale.format(module, "noOauth2N", regexResult[2]));
			}
			// !!! not OK. How can I copy all attributes?
			authserver = authserverInstance._data;	
		}
	}
	
	/* if (redirect) {
		if (regexResult) 
			pathname = pathname.replace(regexResult[0], "");
		request.syracuseOriginalPath = pathname;
	} */
	if (authmethod === "basic") {
		return require("streamline-auth/lib/basic").create(_userCheck, standardSetting);
	} else if (authmethod === "digest") {
		return require("streamline-auth/lib/digest").create(_userCheck, standardSetting);		
	} else {
		return require("streamline-auth/lib/oauth2").create(_userCheck, authserver, standardSetting);
	}
}

// config dispatcher before modules setup as it does sdataRegistry.register
config.sdata.httpRoot = config.sdata.httpRoot || "http://localhost:" + port;
var sdataDispatcher = sdata.dispatcher(config.sdata);
var wsDispatcher = ws.dispatcher(config);
var stubDispatcher = stub.dispatcher(config);
var x3Dispatcher = x3Disp.x3dispatcher(config);
// default collaboration config
config.collaboration = config.collaboration || {};
config.collaboration.contract = config.collaboration.contract || "syracuse";
config.collaboration.application = config.collaboration.application || "collaboration";
config.collaboration.dataset = config.collaboration.dataset || "syracuse";
// modules setup
adminUtil.setup(config.collaboration);
adminHelpers.setup(config.collaboration, config.session);
factory.setup(config.factory);
// setup a connection cache for mongodb
var mongoConnPool = {};
mongodb.setup(config.mongodb, mongoConnPool);
// configure x3Pool first as it modifies proxy map
config.proxy = config.proxy || {};
config.proxy.map = config.proxy.map || [];
x3Pool.setup(config.x3Pool, config.proxy.map)
sessionManager.setup(config.session, getAuthModule);
proxyManager.setup(config.proxy);
//
searchEngine.setup(config.searchEngine);

var staticProvider = require('streamline-static/lib/staticProvider').staticProvider(basePath);


// patch integration on temp directory: perform special actions and copy files into normal folder
exports.patchintegration = function (_) {
	var write = require('syracuse-patch/lib/write');
	// perform extra actions
	var oldActions;
	var newActions;
	if (write.exists(write.BASE_DIRECTORY+"/"+write.EXTRA_FUNCTIONS_OLD, _))
		oldActions = fs.readFile(write.BASE_DIRECTORY+"/"+write.EXTRA_FUNCTIONS_OLD, "utf8", _).split(/\r\n|\r|\n/);
	else
		oldActions = [];
	if (write.exists(write.BASE_DIRECTORY+"/"+write.EXTRA_FUNCTIONS, _))
		newActions = fs.readFile(write.BASE_DIRECTORY+"/"+write.EXTRA_FUNCTIONS, "utf8", _).split(/\r\n|\r|\n/);
	else
		newActions = [];
	var oldActionsHash = {};
	var i = oldActions.length;
	while (--i >= 0) {
		oldActionsHash[oldActions[i]] = "";
	}
	i = 0;
	while (i < newActions.length) {
		var action = newActions[i++];
		if (!action || action in oldActionsHash)
			continue;
		var parts = action.split(" ");
		if (parts.length != 2)
			console.log("Invalid action "+action);
		else {
				console.log("Perform action "+action);
				var mod = require(write.BASE_DIRECTORY+"/"+parts[0]);
				var result = mod[parts[1]](_);
				console.log("Action "+action+" performed, result "+result);
		}
	}
	write.copyRec(write.BASE_DIRECTORY, write.BASE_DIRECTORY+"/..", true, _);
			
	var version = write.readVersionFile(write.BASE_DIRECTORY, _);
	if (version.patchNumber === "0") {			
		write.copyRec(write.BASE_DIRECTORY, write.BASE_DIRECTORY+"/../"+write.RELEASE_DIRECTORY, true, _);
	}
	if (process.argv[2] === "PATCH")
		write.exchangeProcess(write.BASE_DIRECTORY+'/..', write.BASE_DIRECTORY+"/../out2.bbb", "");			
}
function staticDispatcher(_, request, response) {
//	var defaultPageExp = /\/$|(\/default|\/index)\.(html|htm)/;
	var defaultPageExp = /\/$|(\/default)\.(html|htm)/;
	// default page(s)
	if (defaultPageExp.exec(request.url)) {
		//	if (/(\/$|\/default|\/index)\.(html|htm)/.exec(request.url)) {
		// is mobile ?
		/*if (/[Mm]obile/.exec(request.headers["user-agent"])) {
			response.writeHead("301", {
				Location: request.url.replace(defaultPageExp, "/indexMobile.html")
			})
		} else {*/
		
			response.writeHead("301", {
//				Location: request.url.replace(defaultPageExp, "/syracuse-main/html/main.html?url=" + encodeURIComponent("?representation=home.$dashboard"))
				Location: request.url.replace(defaultPageExp, "/index.html")
			})
		//}
		return response.end();
	}
    
	// listing of all authentication methods
	if (/index2\.html$/.exec(request.url)) {
		var path = "/syracuse-main/html/main.html?url=" + encodeURIComponent("?representation=home.$dashboard");
		response.writeHead(200, { "Content-type": "text/html" });
		response.write(_, '<html>Authentication methods:<br><a href="'+request.url.replace("/index2.html", path)+'">Standard</a><br>');
		response.write(_, '<html><a href="'+request.url.replace("/index2.html", '/auth/digest'+path)+'">Digest</a><br>');
		response.write(_, '<html><a href="'+request.url.replace("/index2.html", '/auth/basic'+path)+'">Basic</a><br>');
		var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
		// fetch OAuth2 server data
		var oauth2s = db.fetchInstances(_, db.model.getEntity("oauth2"), {
			sdataWhere: "" });
		var i;				
		for (i=0; i<oauth2s.length; i++) {
			if (oauth2s[i].active(_)) {
				 var name = oauth2s[i].name(_);
				 var displayname = oauth2s[i].displayName(_) || name;
				 response.write(_, '<html><a href="'+request.url.replace("/index2.html", "/auth/oauth2-"+name+path)+'">'+displayname+'</a><br>');
			}
		};
		// if there is not setting instance, also provide link for OAuth2 server in global configuration
		var setting = db.fetchInstance(_, db.model.getEntity("setting"), {
			sdataWhere: "" });
		if (!setting && config.session.auth === "oauth2" && typeof(config.oauth2) != "undefined") {
			response.write(_, '<html><a href="'+request.url.replace("/index2.html", "/auth/oauth2-"+path)+'">Configured OAuth2 server</a><br>');
		}
		return response.end();
	}
			 		
	// OAuth2 redirect path equals "/redirect". In order to avoid parsing every url, it will be searched using a substring function first		
	if (request.url.indexOf("/oauth2/redirect") >= 0 && url.parse(request.url).pathname === "/oauth2/redirect")
	{
		// second step of authentication
		if (!sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth2: true
			})) return;
		// redirect to start page
		response.writeHead(303, { "Content-Type": "text/html", "Location": request.syracuseOriginalPath });
		response.end('<html><a href="/test">Link</a></html>');
		return;
	}
    
    // test request to see whether server is still alive
	if (request.url.indexOf("/licensetest") >= 0 && url.parse(request.url).pathname === "/licensetest")
	{
		response.writeHead(200, { "Content-Type": "text/plain"});
		response.end('OK');
		return;
	}
		
    // re-read license from database
	if (request.url.indexOf("/licensecheck") >= 0 && url.parse(request.url).pathname === "/licensecheck")
	{
		console.log("LIC CHECK")
		check.checkNamed(_); // no instance here in order to avoid infinite loop!
		console.log("LIC CHECK")
		response.writeHead(200, { "Content-Type": "text/plain"});
		response.end('OK');
		return;
	}
	

	// update license (license is contained in POST data)
	if (request.url.indexOf("/licenseupdate") >= 0 && url.parse(request.url).pathname === "/licenseupdate")
	{
		var content = request.readAll(_);
		response.writeHead(200, { "Content-Type": "text/plain"});
		console.log("Update request");
		var updateResult = check.updateLicense([content], _);
		response.end(updateResult ? 'OK': 'No valid license');
		return;
	}
	
	if (/(config|main|mobile)\.html/.exec(request.url)) {
		if (!sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		})) return;
	}
        

    // strip authentication header
	if (request.url.indexOf("/auth/") >= 0 && url.parse(request.url).pathname.indexOf("/auth/") === 0) {
		var requestUrl = request.url
		request.url = request.url.replace(/\/auth\/[\w-]+/, "");
		if (!request.url || request.url === "/") {
			response.writeHead("301", {
//				Location: request.url.replace(defaultPageExp, "/syracuse-main/html/main.html?url=" + encodeURIComponent("?representation=home.$dashboard"))
				Location: requestUrl+"/index.html"
			})
			return response.end();
		}
	}

	if (request.url.indexOf(".md") == request.url.length - 3 && request.method == "GET") {
		var html = require('markdown').parse(fs.readFile(basePath + request.url, "utf8", _));
		html = '<html><head>' + '<link href="/syracuse-ui/themes/markdown.css" rel="stylesheet" type="text/css"/>' + '</head><body>' + html + '</body></html>';
		response.writeHead("200", {
			"content-type": "text/html"
		});
		return response.end(html);	
	}
	if (!staticProvider(_, request, response)) {
		response.writeHead("404", {});
		return response.end("Resource not found.");
	}
}

function allowOrigin(request, response) {
	if (false) { // test request URL here
		response.writeHead(403, {
			"Content-Type": "text/plain"
		});
		response.end('Origin unauthorized', 'utf8');
		return false;
	}
	var writeHead = response.writeHead;
	response.writeHead = function(status, headers) {
		var corsHeaders = ["Authorization", "X-Authorization", "X-Authorization-Mode", "X-Requested-With", "X-HTTP-Method-Override", "Content-Type", "Accept", "If-Match"];

		headers["Access-Control-Allow-Origin"] = "*", headers["Access-Control-Allow-Credentials"] = true;
		headers["Access-Control-Allow-Methods"] = "POST, GET, PUT, DELETE, OPTIONS";
		headers["Access-Control-Max-Age"] = '86400', // 24 hours
		headers["Access-Control-Allow-Headers"] = corsHeaders.join(',');

		response.writeHead = writeHead;
		return response.writeHead(status, headers);
	};
	return true;
}

var _map = {
	sdata: function(_, request, response) {
		return allowOrigin(request, response) && sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && sdataDispatcher(_, request, response);
	},
	trans: function(_, request, response) {
		return allowOrigin(request, response) && sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && x3Dispatcher(_, request, response);
	},
	"soap-ws": function(_, request, response) {
		return allowOrigin(request, response) && sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && wsDispatcher(_, request, response);
	},
	"soap-stubs": function(_, request, response) {
		return allowOrigin(request, response) && sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && stubDispatcher(_, request, response);
	},
	upload: function(_, request, response) {
		return sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: false
		}) && upload.dispatcher(_, request, response);
	},
	proxy: function(_, request, response) {
		return sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && proxyManager.proxy(_, request, response);
	},
	tests: function(_, request, response) {
		return sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && testServer.dispatch(_, request, response);
	},
	search: function(_, request, response) {
		return sessionManager.sessionManagement(_, request, response, {
			authRequired: true,
			forceAuth: true
		}) && searchEngine.dispatch(_, request, response);
	},
	require: requireDispatcher
};

function _hackRequest(_, request) {
	request.url = request.url.replace(/%27/g, "'"); // for regexp parsing
	var fs = request.url.split('/')[1];
	if (fs) fs = fs.split('?')[0]; // example /proxy?url=...
	var page = /^\/sdata\/syracuse\/ui\/syracuse\/pages\('([^%]*)'\)$/.exec(request.url);
	if (page) request.url = "/syracuse-main/html/" + page[1].replace(/\./g, '/').replace(/\/\$/, "-$") + ".json";
}

function _errorHandler(err) {
	if (err) console.error(err.message + "\n" + err.stack);
}

// see later

function HttpContext(request, response) {
	this.request = request;
	this.response = response;
	var parts = request.url.split('?');
	var segments = parts.splice(0, 1)[0].split('/');
	var segI = 0;
	this.queryString = helpers.url.parseQueryString(parts.join('?'));
}

function _makeHttpServerOptions(secure) {
	return secure ?
		{
			secure: true,
		    // The Server's SSL Key
		    key: fs.readFileSync(path.join(__dirname, 'ssl/server.key')),
		    // The Server's Cert
		    cert: fs.readFileSync(path.join(__dirname, 'ssl/server.crt')),
		    // The CA (us in this case)
		    ca: fs.readFileSync(path.join(__dirname, 'ssl/ca.crt')),
		    // Ask for the client's cert
		    requestCert: true,
		    // Don't automatically reject
		    rejectUnauthorized: false
		} : null;
}


function disp(request, response, _) {
	try {
		//console.log("request (408): "+sys.inspect(request));
		request.context = new HttpContext(request, response);
		// workaround for a nodejs bug
		// see http://groups.google.com/group/nodejs/browse_thread/thread/9189df2597aa199e/965cfa9b7968666d
		// tested with 0.6.7: it works
//		request.unread(request.readAll(_));
		//
		_hackRequest(_, request);
		//
		var fs = request.url.split('/')[1];
		if (fs) fs = fs.split('?')[0]; // example /proxy?url=...
		var dispatch = _map[fs] || staticDispatcher;
		dispatch(_, request, response);
	} catch (err) {
		_errorHandler(err);
		response.writeHead(500, {
			"Content-Type": "text/plain"
		});
		response.end(err.message + "\n" + err.stack);
	} finally {
		// maybe kill node at the end of this request
		if (request.context && request.context.kill) {
			try {
				console.log("Final function before killing");
				request.context.kill();
				console.log("Kill node");
				process.kill(process.pid);
			} catch (e) {
				console.log("Error in kill function "+e);
			}
		}
	}
}

function getDisp(secure) {
	return function(request, response, _) {
		try {
			// TEMP hack: in the code we use socket.secure wich doesn't exists. Fix the code later
			// This hack is not necessary any more - replaced request.socket.secure with 'authorized' in request.connection which does work
			// request.socket.secure = secure;
			request.context = new HttpContext(request, response);
			// workaround for a nodejs bug
			// see http://groups.google.com/group/nodejs/browse_thread/thread/9189df2597aa199e/965cfa9b7968666d
			// tested with 0.6.7: it works
	//		request.unread(request.readAll(_));
			//
			_hackRequest(_, request);
			//
			var fs = request.url.split('/')[1];
			if (fs) fs = fs.split('?')[0]; // example /proxy?url=...
			var dispatch = _map[fs] || staticDispatcher;
			dispatch(_, request, response);
		} catch (err) {
			_errorHandler(err);
			response.writeHead(500, {
				"Content-Type": "text/plain"
			});
			response.end(err.message + "\n" + err.stack);
		} finally {
			// maybe kill node at the end of this request
			if (request.context && request.context.kill) {
				try {
					console.log("Final function before killing");
					request.context.kill();
					console.log("Kill node");
					process.kill(process.pid);
				} catch (e) {
					console.log("Error in kill function "+e);
				}
			}
		}
	}
}
	

if (process.argv[2] && process.argv[2].substr(0, 1) === "N") {
	exports.server = new mock.MockStreamServer(disp, process.stdoutOld, process.stdin, {timeout: 1*(process.argv[3] || 0)});
	config.mockServer = exports.server;
	// kill process when pipe breaks (i. e. nanny process has been killed)
	process.stdin.on('close', function() { console.log("stdin closed - finish process"); process.exit(0)})
} else {
	exports.server = new streams.createHttpServer(getDisp((config.session || {}).secure), _makeHttpServerOptions((config.session || {}).secure));
}	

if(config.integrationServer && config.integrationServer.port)
	exports.integrationServer = new streams.createHttpServer(getDisp(true), _makeHttpServerOptions(true)); 

exports.config = config;

require("streamline/lib/tools/docTool").generate(_errorHandler, basePath, config.docTool);
// load all endpoints
sdataRegistry.loadAllEndpoints(_);
// cleanup
sessionManager.cleanupSessionInfos(_);
// update badges
require("syracuse-collaboration/lib/entities/badge").updateBadges(_);
// scheduler (no wait)
adminHelpers.AdminHelper.startTimers();
// register afterSave events for transparent indexing
indexEngine.registerModelEvents(_, config.searchEngine);

global.__context = {
	errorHandler: _errorHandler
}
process.on('uncaughtException', function(err) {
	_errorHandler(err);
});
// sessions cleanup
process.on('exit', function() {
	console.log("Exiting ...");
});
// make it invoke onExit
try {
	process.on('SIGINT', process.exit);
} catch(e) {
	console.log("SIGINT not yet available on Windows");
}
console.log("Running node version " + process.version);
// initialize phase ended
exports.initializerStatus.emit("initialized");
