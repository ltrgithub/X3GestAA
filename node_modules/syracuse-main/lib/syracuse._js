"use strict";
console.log("Node version: " + process.version + " at " + new Date().toISOString());
var config = require('config'); // must be first syracuse require
var perfmon = require('@sage/syracuse-lib/src/perfmon/record');
var perfmonLogger = require('@sage/syracuse-lib/src/perfmon/logger');
var syncInitTiming = perfmon.start(module, "main.syncInit");
var fs = require('streamline-fs');
var fsp = require('path');
var os = require('os');
require('@sage/syracuse-core').error.configure(config.system || {}); // to get safeStack
var locale = require('streamline-locale');
var sdata = require('@sage/syracuse-lib/src/sdata/sdataDispatch');
var api1 = require('@sage/syracuse-lib/src/sdata/api1Dispatch');
var globals = require('streamline-runtime').globals;
var flows = require('streamline-runtime').flows;
var mock = require('@sage/syracuse-lib/src/load-balancer/mock');
var traceHelper = require('syracuse-trace/lib/helper');
var SocketHandler = require("syracuse-notification/lib/socketHandler");
var flows = require("streamline/lib/util/flows");
const apis = require('@sage/syracuse-core').apis;

setupHttpSecurity();

perfmon.enable((config.perfmon || {}).enabled);
//
var _initialized = false;
//
if (/^[NWB]?\d+$/.test(process.argv[2])) config.port = process.argv[2];

config.hosting = config.hosting || {};

// maybe set tenant ID
for (var i = 2; i < process.argv.length; i++) {
	var arg = process.argv[i];
	if (arg.substr(0, 9) === "tenantId=") {
		config.hosting._globalTenantId = globals.context.tenantId = arg.substr(9);
		if (globals.context.tenantId) {
			console.log("Tenant " + globals.context.tenantId);
		} else {
			config.hosting.multiTenant = false;
			console.log("Switch to single tenant mode");
		}
		continue;
	}
	if (arg.substr(0, 17) === "--addAuthMethods=") {
		if (!Array.isArray(config.session.auth)) {
			config.session.auth = [config.session.auth];
		}
		arg.substr(17).split(",").forEach(function(method) {
			config.session.auth.push(method);
		});
		console.log("Authentication methods " + config.session.auth.join(";"));
	}
}
config.port = config.port || 8124;
var port = config.port;
config.hosting.compressThreshold = config.hosting.compressThreshold || 1024;

config.servername = os.hostname();
if (config.license && config.license.domain) {
	config.servername += ("." + config.license.domain);
}
config.servername += ":" + config.port;
config.session = config.session || {};
config.session.realm = config.session.realm || "Syracuse";

var basePath = fsp.join(fsp.dirname(module.filename), "../..");
var basePublicPath = fsp.join(fsp.dirname(module.filename), "../../..");
var helpers = require('@sage/syracuse-core').helpers;
var testServer;

config.system = config.system || {};

// process should not accept new sessions any more above memory threshold1, and will kill itself above memory threshold2
var MEMORY_THRESHOLD1 = (config.system.memoryThreshold1 || 1000) * 1048576;
var MEMORY_THRESHOLD2 = (config.system.memoryThreshold2 || 1500) * 1048576;

var enableDevelopmentFeatures = config.system.enableDevelopmentFeatures;
if (enableDevelopmentFeatures) {
	testServer = require('test-runner/lib/server/testServer');
}
if (config.system && config.system.verifyContextMillis) {
	(function() {
		var context = globals.context;
		setInterval(function() {
			if (globals.context !== context) {
				console.error("FATAL: globals.context corrupted:\nEXPECTED: ", Object.keys(context), "\nGOT: ", Object.keys(globals.context));
				process.exit(1);
			}
			if (globals.context.tenantId && !config.hosting._globalTenantId) {
				console.error("FATAL: found tenantId in globals.context: " + globals.context.tenantId);
				process.exit(1);
			}
		}, config.system.verifyContextMillis);
	})();
}

//Require apiScheduler if running external health checks
if (config.apiHealthScheduler && config.apiHealthScheduler.enabled) {
	var apiTest = require('syracuse-health/apiScheduler');
}
apis.register('syracuse-health', () => ({
	acceptsRequest(_, request, response) {
		if (config.hosting.sitecheck) {
			var redirectUrl = require('syracuse-health/lib/suspend').getSiteStatus(_, request, response);
			if (redirectUrl) {
				response.writeHead(303, {
					"content-type": "text/html",
					location: redirectUrl
				});
				response.end('<html>Site is currenctly unavailable. Please click on <a href="' + redirectUrl + '">status information</a> for more details</html>');
				return false;
			}
		}
		return true;
	}
}));

var sessionManager = require('@sage/syracuse-lib/src/session/sessionManager').sessionManager;
var x3Pool = require('syracuse-x3/lib/pool');
apis.register('syracuse-x3', () => ({
	pool: x3Pool,
	fs: require("syracuse-x3/lib/fileService"),
}));

var ez = require("ez-streams");
var zlib = require('zlib');
var factory = require('@sage/syracuse-lib/src/orm/factory');
var mongodb = require('@sage/syracuse-lib/src/orm/dbHandles/mongoDbHandle');
var searchEngine = require('syracuse-search/lib/elasticSearch');
var indexEngine = require('syracuse-search/lib/elasticIndex');
var adminUtil = require('@sage/syracuse-lib/src/collaboration/util');
var adminHelpers = require('@sage/syracuse-lib/src/collaboration/helpers');
var check = require('@sage/syracuse-lib/src/license/check');
var historyLog = require('@sage/syracuse-lib/src/collaboration/entities/historyLog');

var url = require('url');
var requireJSDispatcher = require('syracuse-tablet/lib/requireJSDispatcher').dispatcher();

var sdataRegistry = require("@sage/syracuse-lib/src/sdata/sdataRegistry");
var dataModel = require("@sage/syracuse-lib/src/orm/dataModel");

var cssRtlOptions = {
	cachePrefix: "rtl$",
	transform: function(_, data) {
		var text = data.toString('utf8');
		text = text.replace(/:\s*(left|right)\s*;/g, function(all, lr) {
			return ': ' + (lr === 'left' ? 'right' : 'left') + ';';
		});
		text = text.replace(/(-?)\b(left|right)\s*:/g, function(all, sep, lr) {
			return sep + (lr === 'left' ? 'right' : 'left') + ':';
		});
		text = text.replace(/\s(left|right)\s/g, function(all, lr) {
			return ' ' + (lr === 'left' ? 'right' : 'left') + ' ';
		});
		text = text.replace(/-(left|right)\./g, function(all, lr) {
			return '-' + (lr === 'left' ? 'right' : 'left') + '.';
		});
		text = text.replace(/(padding|margin):\s*(\d+\w*)\s+(\d+\w*)\s+(\d+\w*)\s+(\d+\w*)\s*;/g, function(all, tag, t, r, b, l) {
			return tag + ': ' + t + ' ' + l + ' ' + b + ' ' + r + ';';
		});
		return new Buffer(text, 'utf8');
	}
};

var htmlRtlOptions = {
	cachePrefix: "rtl$",
	transform: function(_, data) {
		var text = data.toString('utf8');
		text = text.replace(/dir="ltr"/g, 'dir="rtl"');
		text = text.replace(/\.css"/g, '.css?rtl=true"');
		return new Buffer(text, 'utf8');
	}
};

// config dispatcher before modules setup as it does sdataRegistry.register
config.sdata.httpRoot = config.sdata.httpRoot || "http://localhost:" + port;
// default collaboration config
config.collaboration = config.collaboration || {};
config.collaboration.contract = config.collaboration.contract || "syracuse";
config.collaboration.application = config.collaboration.application || "collaboration";
config.collaboration.dataset = config.collaboration.dataset || "syracuse";
// modules setup
adminUtil.setup(config.collaboration);
adminHelpers.setup(config.collaboration, config.session, config.hosting);
// setup a connection cache for mongodb
config.mongodb = config.mongodb || {};
mongodb.setup(config.mongodb, {});
// configure x3Pool first as it modifies proxy map
config.proxy = config.proxy || {};
config.proxy.map = config.proxy.map || [];
x3Pool.setup(config.x3Pool, config.proxy.map);
sessionManager.setup(config.session, port);
//
config.searchEngine = config.searchEngine || {};
searchEngine.setup(config.searchEngine);

// max age of one hour as some static content doesn't get updated after a server change
var staticProvider = require('streamline-static').dispatcher({
	root: basePath,
	maxAge: 3600 * 1000,
});

var staticPublicProvider = function(_, request, response) {
	var url = request.url.split('?')[0];
	if (/\/public\//.test(url)) return staticProvider(_, request, response);
	else return notFound(_, request, response);
}

var shadowRoot = fsp.join(fsp.dirname(require.resolve('streamline-runtime')), '..');

var staticShadowProvider = require('streamline-static').dispatcher({
	root: shadowRoot,
	maxAge: 3600 * 1000,
});

function notFound(_, request, response) {
	response.writeHead("404", {});
	return response.end("Resource not found.");
}

function defaultRedirect(request, response) {
	// intercept default URLs and redirect them (they are not in the routing tables).
	if (/\/$|\/(default|index)\.(html|htm)/.exec(request.url)) {
		response.writeHead(301, {
			location: "/syracuse-main/html/main.html?url=%3Frepresentation%3Dhome.%24landing"
		});
		return response.end();
	} else {
		response.writeHead("404", {});
		return response.end("Resource not found.");
	}
}

function _isRtlDisplay(_, request) {
	var up = request.session && request.session.getUserProfile(_);
	return up && /^(ar|iw|he)/.test(up.selectedLocale(_).code(_));
}

function staticDisp(provider) {
	return function(_, request, response) {
		//	console.log("SSSS "+request.connection.authorized)
		//	if (request.connection.authorized) console.log("SSSSCC "+sys.format(request.connection.getPeerCertificate()))
		//	var defaultPageExp = /\/$|(\/default|\/index)\.(html|htm)/;

		var opts = {};
		// TODO check language in order to compute the right

		if (_isRtlDisplay(_, request)) {
			//if (/(\?|\&)rtl=true/.test(request.url)) {
			if (/\.html/.test(request.url)) opts = htmlRtlOptions;
			else if (/\.css/.test(request.url)) opts = cssRtlOptions;
		}
		// don't cache main.html to trigger authentication through refetch.
		if (/^\/syracuse-main\//.test(request.url)) opts.nocache = true;
		if (request.method === 'POST') {
			// switch from POST to GET for handling SAML2 in certain cases
			// (sometimes the browser repeats a POST request)
			var beginning = request.read(_, 13).toString();
			if (beginning === 'SAMLResponse=') {
				console.log("Set request method to GET for SAML2");
				request.method = 'GET';
			}
		}
		// don't cache is special UI developper flag is set
		if (config.system.noUiCache) opts.nocache = true;

		if (!provider(_, request, response, opts) && !staticShadowProvider(_, request, response, opts)) return notFound(_, request, response);
	};
}

const staticDispatcher = staticDisp(staticProvider);

// display message to users that server will shutdown soon, do not accept new sessions any more

function setupHttpSecurity() {
	config.security = config.security || {};
	config.security.http = config.security.http || {};
	var csh = config.security.http.headers = config.security.http.headers || {};

	// for compatibility
	csh["x-frame-options"] = config.security.http["x-frame-options"];

	var defaultHeaders = {
		"x-frame-options": "DENY",
		"x-content-type-options": "nosniff",
		"x-xss-protection": "1; mode=block",
		"content-security-policy": {
			// "script-src": [ //
			// 	"'unsafe-eval'", // is required because of client-side require of streamline.
			// 	"'unsafe-inline'", 
			// 	// "'sha256-zEGXzzA6/52MLQQ/9YSeo2s1eJJuN6TjTbgbrhiJZ/E='" //is required because of inline script in main.html.
			// ],
			// "child-src": ["'self'", "https://www.google.com"],
			"frame-ancestors": "'self'",
		}
	};
	for (var k in csh) {
		if (csh[k.toLowerCase()] === undefined) {
			csh[k.toLowerCase()] = csh[k];
			delete csh[k];
		}
	}
	for (k in defaultHeaders) {
		csh[k] = csh[k] || (typeof(defaultHeaders[k]) === "string" ? defaultHeaders[k] : {});
	}
	for (k in csh) {
		flatten(csh, k);
	}

	function flatten(o, k) {
		var parts = [],
			val, m;
		var dsep = o.$directiveSeparator == null ? ";" : o.$directiveSeparator;
		var vsep = o.$valueSeparator == null ? " " : o.$valueSeparator;
		var red = new RegExp("(.*)" + dsep);
		var header = o[k];
		if (typeof(header) !== "string") {
			var def = defaultHeaders[k] || {};
			for (var d in def) {
				if (header[d] === undefined) {
					header[d] = def[d];
				}
			}
			for (var r in header) {
				if (r[0] === "$")
					continue;
				val = null;
				if (Array.isArray(header[r])) {
					val = [r].concat(header[r]);
				} else if (typeof(header[r]) === "string") {
					val = [r, header[r].replace(red, "$1")];
				}
				val && parts.push(val.join(vsep));
			}
			if (parts.length > 0) {
				parts.push("");
				o[k] = parts.join(dsep + " ");
			}
		}
	}
}

var requestTraceId = 0;

function patchHeaders(request, response) {
	var requestId = ++requestTraceId;
	if (config.traces && config.traces.http) console.log(new Date().toISOString(), requestId, "SYRACUSE REQUEST", request.url);
	var writeHead = response.writeHead;
	var t0 = Date.now();
	response.writeHead = function(status, headers) {
		if (config.traces && config.traces.http) console.log(new Date().toISOString(), requestId, "SYRACUSE RESPONSE", status, (Date.now() - t0) + 'ms', request.url);
		headers = headers || {};
		// normalize headers
		var hd = headers && Object.keys(headers).reduce(function(prev, crt) {
			prev[crt.toLowerCase()] = headers[crt];
			return prev;
		}, {});

		if (hd) {
			var csh = config.security.http.headers;
			for (var k in csh) {
				hd[k] = hd[k] || csh[k];
			}
			// expires header is required by IE to force ETag cache validation and management. But it doesn't provide satisfactory behavior on other browsers
			if (helpers.http.checkIfIE((request.headers || {})["user-agent"])) hd.expires = (new Date()).toUTCString();
			if (!hd["cache-control"])
				hd["cache-control"] = "max-age=0, s-maxage=0, must-revalidate, proxy-revalidate";
			if (hd["content-disposition"]) { // this header may contain characters outside the allowed range
				var cont = hd["content-disposition"];
				// header contains filename and there are special characters
				if (cont.indexOf('filename=') > 0 && cont.indexOf('filename*=') < 0 && !/^[\x20-\x7F]+$/.test(cont)) {
					var res = /filename=(["]?)(.*)\1/.exec(cont);
					if (res) {
						var filename2 = encodeURI(res[2]);
						// use rfc5987
						hd["content-disposition"] = cont.substr(0, res.index) + 'filename="' + filename2 + '"; filename*=UTF-8\'\'' + filename2 + " " + cont.substr(res.index + res.input.length);
					}
				}
			}
		}

		response.writeHead = writeHead;
		return response.writeHead(status, hd);
	};
}

var authModule = require('@sage/syracuse-lib/src/auth/dispatcher');

// ensures session and authentication
// if noChallenge server will not reply with an auth challenge but will send a forbidden reply if client is not authenticated
// In any case the next dispatcher will only be called if authentication was successful. 
function ensureAuthenticated(dispatcher) {
	return function(request, response) {
		return flows.withContext(function() {
			(function(_) {
				var useSessionPool = /^\/(api\d+|soap-generic)\//.test(request.url);
				if (useSessionPool && request.url.indexOf("/soap-generic/") === 0) {
					useSessionPool = require('syracuse-soap/lib/server/soapUtils').notTesterSoap(request);
				}
				return sessionManager.ensureSession(_, request, response, useSessionPool) //
					&& authModule.ensureAuthenticated(_, request, response) //
					&& dispatcher(request, response);
			})(function(err) {
				if (err) {
					console.error(err.stack);
					response.writeHead(err.$httpStatus || 500, {});
					response.end(err.message);
				}
			});
		})();
	};
}
var requireDispatcher = require('streamline-require/lib/server/require').dispatcher({
	getResources: locale.getResourcesHook,
	whiteList: [
		/^@sage\/(syracuse-core|syracuse-sdata-parser|html-sanitizer|rtf-converter)\b/,
		/^(syracuse-(main\/html|ui|core|rtf|office|msoffice)|streamline|jsbn|jsurl|js-xml|test-runner)(\/|$)/,
		/\/src\/sdata\/httpHelpers/,
		/^msoffice\/lib\//,
		/^(ez-streams|streamline-(runtime|locale)|regenerator.runtime)(\/|$)/,
		/^@sage\/syracuse-lib\/src\/collaboration\/entities\/page\/classicPageConverter/,
		/^syracuse-x3\/.*?\/(format|CvgFormat(ter)?)$/,
		/(^|\/)public\//,
	],
	root: basePath,
	shadowRoot: shadowRoot,
	nocache: config.system.noUiCache,
	cacheDir: config.streamline.cacheDir,
});

var sdataDispatcher = sdata.dispatcher(config.sdata);
var api1Dispatcher = api1.dispatcher(config.api1 || config.sdata);
var printDispatcher = require('syracuse-x3/lib/clients/print/printDispatch').dispatcher(config);
var x3Dispatcher = require('syracuse-x3/lib/x3Dispatch').x3dispatcher(config);
var hrmDispatcher = require('syracuse-hrm/lib/hrmDispatch').dispatcher(config);
var wsDispatcher = require('syracuse-soap/lib/server/wsDispatch').dispatcher(config);
var wsGenericDispatcher = require('syracuse-soap/lib/generic/dispatch').dispatcher(config);
var wsdlDispatcher = require('syracuse-soap/lib/generic/dispatchWsdl').dispatcher(config);
var stubDispatcher = require('syracuse-soap/lib/client/stubDispatch').dispatcher(config);
var patchDispatcher = require('syracuse-patch/lib/dispatcher').dispatcher(config.patch);
var licenseDispatcher = require('@sage/syracuse-lib/src/license/dispatcher').dispatcher(config.license);
var loggingDispatcher = require('syracuse-trace/lib/dispatcher').dispatcher(config);
var authDispatcher = authModule.dispatcher;
var sessionDispatcher = require('@sage/syracuse-lib/src/session/dispatcher').dispatcher(config);
var eventDispatcher = require('@sage/syracuse-lib/src/scheduler/dispatcher').dispatcher(config);
var widgetRegistryDispatcher = require('./widget-registry').dispatcher(config);
var batchDispatcher = require('syracuse-batch/lib/dispatcher').dispatcher(config);

var htmlStaticDispatcher = function(_, request, response) {
	if (/\/(html)\//.test(request.url)) return staticDispatcher(_, request, response);
	else return notFound(_, request, response);
};

// for performance measuring: returns an amount of data (maximal 1MB)
var _pingDispatcher = function(_, request, response) {
	var index = request.url.indexOf("data=");
	var len = 0;
	var output = "";
	if (index >= 0) {

		var cnt = /^\d+/.exec(request.url.substr(index + 5));
		if (cnt) {
			output = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
			len = Math.min(cnt[0], 1048576);
			while (output.length <= len / 2) {
				output += output;
			}
			if (output.length < len) {
				output += output.substr(0, len - output.length);
			}
		}
	}
	response.writeHead(200, {
		"content-length": len,
		"content-type": "text/plain",
		"content-encoding": "utf8"
	});
	response.end(output);
	return;
};

var _statusDispatcher = function(_, request, response) {
	var body = "OK";
	response.writeHead(200, {
		"content-length": body.length,
		"content-type": "text/plain",
		"content-encoding": "utf8"
	});
	response.end(body);
};

var mobile1Dispatcher = function(_, request, response) {
	request.$stateless = true;
	return sdataDispatcher(_, request, response);
};

var mobile2Dispatcher = function(_, request, response) {
	request.$statelessWC = true;
	return sdataDispatcher(_, request, response);
};

var authenticatedRoutes = {
	api1: api1Dispatcher,
	sdata: sdataDispatcher,
	mobile1: mobile1Dispatcher,
	mobile2: mobile2Dispatcher,
	trans: x3Dispatcher,
	bo: x3Dispatcher, // was unauthenticated before (!), needs to test
	"soap-ws": wsDispatcher,
	"soap-stubs": stubDispatcher,
	"soap-generic": wsGenericDispatcher,
	"soaptest-generic": wsGenericDispatcher, // for Web service tester: execute this request on local machine, even with load balancer (nanny)
	print: printDispatcher,
	xtend: hrmDispatcher,
	shrmportal: hrmDispatcher,
	tests: testServer && testServer.dispatch,
	search: searchEngine.dispatch,
	xsearch: searchEngine.dispatch,
	// Exact search, no wildcards
	fsearch: searchEngine.dispatch,
	// Fuzzy like this search
	bundles: require('bundles/lib/dispatcher').dispatcher(config, staticDispatcher),
	perfmon: require('@sage/syracuse-lib/src/perfmon/dispatcher').dispatcher(config),
	help: require('syracuse-help/lib/helpDispatch').dispatcher(config),
	studio: require('syracuse-studio/lib/studioDispatch').dispatcher(config),
	"streamline-require": staticDispatcher,
	"syracuse-ui": staticDispatcher,
	"msoffice": staticDispatcher,
	"plugin": staticDispatcher,
	"syracuse-main": htmlStaticDispatcher,
	"perfmon": htmlStaticDispatcher,
	require: requireDispatcher,
	ping: _pingDispatcher,
	"main-office": htmlStaticDispatcher
};

if (!config.react || !config.react.path) {
	// Default, not dedicated config for react, serve build output committed by jenkins to node_modules/syracue-react
	authenticatedRoutes["syracuse-react"] = staticDispatcher;
} else {
	// Use this during development only to let the server know on where to fetch react build output while developing    
	var reactBasePath = config.react.path;
	var staticReactProvider = require('streamline-static').dispatcher({
		root: reactBasePath,
		maxAge: 0,
	});
	authenticatedRoutes["syracuse-react"] = (function(_, req, resp) {
		var opts = {};
		// Strip off leading "syracuse-react" segment to allow root project directory to be given by 
		// configuration since we may have more than one local branch/repo with other names in the future 
		if (req.url.indexOf("/syracuse-react/") === 0) {
			req.url = req.url.substr(15);
		}
		if (!staticReactProvider(_, req, resp, opts)) {
			return notFound(_, req, resp);
		}
	});
}


var mainRoutes = {
	// Following routes are *NOT* authenticated
	auth: authDispatcher,
	"@sage": staticDisp(staticPublicProvider),
	"syracuse-mobile": staticDispatcher,
	"syracuse-tablet": staticDispatcher,
	requireJS: requireJSDispatcher,
	"soap-wsdl": wsdlDispatcher,
	logout: sessionManager.logout,
	"batch": batchDispatcher,
	// These are nannyCommand urls - we need to do something about them!
	patch: patchDispatcher,
	license: licenseDispatcher,
	event: eventDispatcher,
	logging: loggingDispatcher,
	'widget-registry': widgetRegistryDispatcher,
	'bundles-non-auth': require('bundles/lib/dispatcher').dispatcherNonAuth(config, staticDispatcher),
	status: _statusDispatcher,
};

if (config.skyAutomation) {
	if (config.hosting.multiTenant) throw new Error("configuration error: sky-automation application not allowed in multi-tenant mode");
	mainRoutes.healthLogs = require('sky-automation/lib/dispatcher').dispatcher;
}

if (enableDevelopmentFeatures) {
	authenticatedRoutes["test-runner"] = staticDispatcher;
	mainRoutes['dev.html'] = staticDispatcher;
	mainRoutes.dump = require('syracuse-trace/lib/dispatcher').dispatcher(config);
	mainRoutes.heapdump = function(_, request, response) {
		var newSnap = Math.round(process.memoryUsage().rss / 1048576);
		var dirname = __dirname + '/../../../heapdumps/';
		if (!fs.existsSync(dirname)) {
			fs.mkdirSync(dirname);
		}
		var filename = Date.now() + "-" + newSnap + 'M.heapsnapshot';
		console.log("Write snapshot " + filename);
		var snapName = dirname + filename;
		try {
			require('heapdump').writeSnapshot(snapName);
		} catch (ex) {
			console.error(ex.stack);
		}
		var data = "Snapshot created: " + filename;
		response.writeHead(200, {
			"content-type": "text/plain",
			"content-length": data.length
		});
		response.end(data);
	};
	//
	var staticTestProvider = require('streamline-static').dispatcher({
		root: fsp.join(fsp.dirname(module.filename), "../../test-contract")
	});
	// test fixtures for sample files to use in tests
	mainRoutes["test-fixtures"] = function(_, request, response) {
		if (!staticTestProvider(_, request, response, {})) return notFound(_, request, response);
	};
}

function unezify(listener) {
	return ez.devices.http.listener(function(request, response, _) {
		if (!config.hosting.nocompress) response = _enableCompression(request, response);
		request.context = new HttpContext(request, response);
		// request and response pointers have changed - store them again into globals.context
		globals.context.request = request;
		globals.context.response = response;
		_hackRequest(_, request);
		return listener(_, request, response);
	});
}

Object.keys(mainRoutes).forEach(function(key) {
	mainRoutes[key] = unezify(mainRoutes[key]);
});
Object.keys(authenticatedRoutes).forEach(function(key) {
	if (mainRoutes[key]) throw new Error("duplicate route key: " + key);
	mainRoutes[key] = ensureAuthenticated(unezify(authenticatedRoutes[key]));
});

function _hackRequest(_, request) {
	request.url = request.url.replace(/%27/g, "'"); // for regexp parsing
	var fs = request.url.split('/')[1];
	if (fs) fs = fs.split('?')[0]; // example /proxy?url=...
	var page = /^\/sdata\/syracuse\/ui\/syracuse\/pages\('([^%]*)'\)$/.exec(request.url);
	if (page) request.url = "/syracuse-main/html/" + page[1].replace(/\./g, '/').replace(/\/\$/, "-$") + ".json";
}

function _errorHandler(err) {
	if (!err) return;
	// don't dump stack if we have an HTTP status: message should be sufficient.
	if (err.$httpStatus) console.error("HTTP Status " + err.$httpStatus + ": " + err.message);
	else console.error(err.stack);
}

// see later

function HttpContext(request, response) {
	this.request = request;
	this.response = response;
	var parts = request.url.split('?');
	var segments = parts.splice(0, 1)[0].split('/');
	var segI = 0;
	this.queryString = helpers.url.parseQueryString(parts.join('?'));
}

function _makeHttpServerOptions(secure) {
	return secure ? {
		secure: true,
		// The Server's SSL Key
		key: fs.readFileSync(fsp.join(__dirname, 'ssl/server.key'), "utf8"),
		// The Server's Cert
		cert: fs.readFileSync(fsp.join(__dirname, 'ssl/server.crt'), "utf8"),
		// The CA (us in this case)
		ca: [fs.readFileSync(fsp.join(__dirname, 'ssl/ca.crt'), "utf8")],
		// Ask for the client's cert
		requestCert: true,
		// Don't automatically reject
		rejectUnauthorized: false
	} : {};
}

function _enableCompression(request, response) {
	// no compression for internal calls from nanny
	if (!request.headers || !request.headers['accept-encoding'] || request.headers['accept-encoding'].split(',').indexOf('gzip') === -1 || request.fromNanny || (request._request && request._request.fromNanny)) return response;
	var writeHead = response.writeHead;

	response.writeHead = function(status, headers) {
		var len = headers["content-length"] || headers["Content-Length"];
		if ((len == null || len > config.hosting.compressThreshold) && !headers["content-encoding"] && //
			// only compress selected mime types (images, for ex, are already compressed)
			/^(text|application|multipart)\//.test(headers["content-type"] || headers["Content-Type"])) {
			headers["content-encoding"] = "gzip";
			headers["transfer-encoding"] = "chunked";
			// Two delete because static provider put headers with upper cases
			delete headers["Content-Length"];
			delete headers["content-length"];
			response.writer = ez.helpers.binary.writer(response.writer, {
				bufSize: 65536,
			}).pre.nodeTransform(zlib.createGzip(config.hosting.compressOptions || {
				// I prefer trading a bit of size for speed. 
				// Default level (6) gains about 20% in size but doubles CPU usage.
				// see http://tukaani.org/lzma/benchmarks.html
				level: 1,
			}));
		}
		writeHead.call(response, status, headers);
	};
	return response;
}

function getinitializingPageContent(text, url) {
	var delay = 2,
		content = '<!DOCTYPE html>';
	content += '<html><head>';
	content += '<META HTTP-EQUIV="refresh" content="' + delay + '">';
	content += '<style>';
	content += 'body { font-family:Arial, Helvetica, sans-serif; font-stretch:wider; }';
	content += '</style>';
	content += '</head>';
	content += '<body>';
	content += text;
	content += '</body></html>';
	return content;
}
// global request id to avoid some context mixup betwenn sessions in some extreem cases
var requestCnt = 0;

var rawStaticDispatcher = unezify(staticDispatcher);

// add automatic create trace session of the current session with all in debug level (except factory)
var debugTraceRecord = exports.debugTraceRecord = function(_, sessionId, request) {

	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
	// create new autorecord
	var recEntity = db.model.getEntity(_, "traceRecord");
	var user = request ? request.session.data.userLogin : globals.context.session.data.userLogin;
	// check if the record already exists
	var inst = db.fetchInstance(_, recEntity, {
		jsonWhere: {
			sessionId: "Record_" + user + "_debug_session_" + sessionId
		}
	}); // no locking because new instance
	if (!inst) {
		inst = db.fetchInstance(_, recEntity, {
			jsonWhere: {
				sessionId: "Record_UNKNOW_debug_session_" + sessionId
			}
		});
	}
	if (!inst) {
		inst = recEntity.createInstance(_, db, null);

		inst.onlySid(_, true);
		inst.sessionId(_, sessionId);

		inst.name(_, "debug_session_" + sessionId);
		// set configuration

		// set debug level for all trace
		inst.configs(_).toArray(_).forEach_(_, function(_, item) {
			item.modules(_) && item.modules(_).toArray(_).forEach_(_, function(_, subItem) {
				if (subItem.name(_) !== "factory") subItem.level(_, "debug");
			});
			item.level(_, "debug");
		});

		inst.save(_);
		inst.startRecording(_);
	}
	return inst;
};

function _timerFn(_, request, nextTimer) {
	var cf = (config.system && config.system.requestReport || {});

	// avoid infinite timers
	if (nextTimer > (cf.upperThreshold || 600000)) {
		console.log("Long request pending - stop counting at : ", nextTimer, request.url);
		return;
	}
	//
	if (nextTimer === 0) {
		nextTimer = cf.threshold || 30000;
	} else if (nextTimer === Infinity) { // prevent in any case a loop if bad configuration or eratic behavior.
		console.log("Long request pending - stop counting at : ", nextTimer, request.url);
		return;
	} else {
		console.log("Long request pending : ", nextTimer / 2, request.url);
		// activate for the this session a traceRecord
		if (cf.autoTraceRecord) {
			debugTraceRecord(_, request.session && request.session.id, request);
		}
	}

	request.timer = flows.setTimeout(function(_) {
		_timerFn(_, request, nextTimer * 2);
	}, nextTimer);
}

function disp(request, response, _) {
	patchHeaders(request, response);

	// exclude OPTIONS and TRACE: method not allowed
	// also manage CORS headers
	if (request.method === "OPTIONS" || request.method === "TRACE") {
		config.security.cors = config.security.cors || {};

		var head = {
			"content-length": 0,
			"allow": config.security.http.allow || "GET, POST"
		};
		head = Object.keys(config.security.cors).reduce(
			function(prev, curr) {
				prev[curr] = config.security.cors[curr];
				return prev;
			}, head);
		response.writeHead(200, head);

		response.end();
		return;
	}

	// request and response are raw node.js objects. They have not yet been ez-ified.
	if (!_initialized && !config.hosting.multiTenant) {
		response.writeHead("200", {
			"content-type": "text/html; charset=utf-8"
		});
		return response.end(getinitializingPageContent(locale.format(module, "initializing"), request.url));
	}
	//
	_timerFn(_, request, 0);
	// record timing, except if this is a request to the performance monitor itself.
	var timing = (request.url.indexOf('/perfmon/') === -1) && perfmon.start(module, "main.httpDispatch", request.method + ' ' + request.url);
	var mem1;
	if (config && config.system && config.system.printMemory) mem1 = process.memoryUsage();
	// disable automatic dumps --> prefer to use heapdump dispatcher ponctually
	/*	if (config && config.system && config.system.memoryLimit) {
		mem1 = process.memoryUsage();
		if (mem1.rss / 1048576 >= memoryDumpLimit) {
			memoryDumpLimit += 100;
			console.log("Write snapshot" + memoryDumpLimit);
			try {
				require('heapdump').writeSnapshot(__dirname + '/../../../' + config.port + "-" + (memoryDumpLimit - 100) + "-" + Date.now() + '.heapsnapshot');
			} catch (ex) {
				console.error(ex.stack);
			}
		}
	}
*/
	try {
		//require('syracuse-etl/lib/logger').info("DISPATCHER: " + request.url);
		// ease access to config in code
		globals.context.config = config;
		globals.context.requestId = requestCnt++;
		//
		var parts = request.url.split('?');
		var routeName = parts[0].split('/')[1];
		// take care of hosting options first
		// tenantId must be set before calling initAsync(_)
		if (config.hosting.multiTenant) {
			// do not set tenant for special internal requests - they must be able to ignore the request when the the tenant has 
			// not been initialized yet
			//console.error("request.url: "+request.url);
			if (['license', 'batch', 'logging', 'patch', 'soap-wsdl'].indexOf(routeName) < 0) {
				var host = request.headers['x-forwarded-host'] || request.headers.host;
				if (!host) throw new Error("host header missing");
				globals.context.tenantId = host.split(/[.:]/)[0];
				if (config.health) require('syracuse-health').addTenant(globals.context.tenantId);
			} else {
				var query = parts[1] && parts[1].split('&');
				query && query.forEach(function(pp) {
					var ii = pp.indexOf('tenantId');
					if (ii === 0) {
						globals.context.tenantId = decodeURIComponent(pp.split('=')[1]);
					}
				});
			}
		}
		request.hosting = config.hosting;

		initAsync(_);

		//
		// /module-name/public/... is static content that can be freely downloaded
		if (/^\/[^\/]+\/public\//.test(request.url)) return rawStaticDispatcher(request, response);

		var route = mainRoutes[routeName] || defaultRedirect;
		route(request, response);
	} catch (err) {
		if (err.code === "ETIMEOUT") err.message = locale.format(module, "dispatchTimeout", request.url);
		console.log(err.stack); // TEMP DEBUG
		_errorHandler(err);
		if (err.$diagnoses) {
			response.writeHead(err.$httpStatus || 500, {
				"Content-Type": "application/json"
			});
			response.end(JSON.stringify({
				$diagnoses: err.$diagnoses
			}));
		} else {
			response.writeHead(err.$httpStatus || 500, {
				"Content-Type": "text/plain"
			});
			response.end(err.safeStack);
		}
	} finally {
		request.timer && clearTimeout(request.timer);
		//
		timing && timing.end({
			status: response.statusCode,
			'content-length': response.headers && response.headers['content-length']
		});
		request.session && request.session.addTimings();
		// maybe kill node at the end of this request
		if (request.context && request.context.kill) {
			try {
				console.log("Final function before killing");
				request.context.kill();
				console.log("Kill node");
				process.kill(process.pid);
			} catch (e) {
				console.log("Error in kill function " + e);
			}
		}
		//		request.context = null;
		//		request.session = null;
		// crnit : do not survey anymore
		if (mem1) {
			var mem2 = process.memoryUsage();
			var diff = {
				rss: (mem2.rss - mem1.rss) / 1024 / 1024,
				heapTotal: (mem2.heapTotal - mem1.heapTotal) / 1024 / 1024,
				heapUsed: (mem2.heapUsed - mem1.heapUsed) / 1024 / 1024
			};
			var threshold = 10;
			if (diff.rss > threshold || diff.heapTotal > threshold || diff.heapUsed > threshold) {
				var session = request.session,
					up = session && session.getUserProfile(_),
					ep = up && up.selectedEndpoint(_),
					endpointName = ep && (ep.application(_) + "/" + ep.contract(_) + "/" + ep.dataset(_)),
					login = session && session.getUserLogin(_);
				console.log((new Date()).toISOString() + ": " + request.method + ' ' + request.url);
				console.log("  memory usage diff=" + JSON.stringify(diff) + " before=" + JSON.stringify(mem1) + " after=" + JSON.stringify(mem2));
				console.log("  login=" + login + ", endpoint=" + endpointName);
			}
		}
	}
}

function rawDisp(request, response) {
	globals.withContext(function() {
		disp(request, response, function(err) {
			if (err) console.error(err.stack);
		});
	}, {})();
}

exports.startServers = function(_, port) {
	if (process.argv[2] === "STOP") {
		process.argv.splice(2, 1); // remove this argument
		initAsync(_, true, true); // just initialization without batch server start, then finish the application
		if (config.hosting && config.hosting.multiTenant) {
			initBatchMulti(_, true); // just initialization, not batch server start 
		}
		process.exit(0);
	}
	if (process.argv[2] === "batchpatch") {
		var code = 0;
		try {
			code = require('syracuse-patch/lib/integrate').batchIntegration(_, process.argv[3]);
		} catch (e) {
			console.error(e.stack);
			code = 1;
		}
		process.exit(code);
	}
	// if the port is forced, make config consistent
	port = config.port = port || config.port || 8124;
	//Port init
	config.sdata.httpRoot = config.sdata.httpRoot || "http://localhost:" + port;
	// start http or mock server
	if ((!config.hosting.multiTenant || globals.context.tenantId) && (exports.server instanceof mock.MockStreamServer)) {
		initAsync(_); // do initialization before listening when started from nanny process
	};
	if (config.hosting.multiTenant && (process.argv[2] === "B0" || !(exports.server instanceof mock.MockStreamServer))) {
		// search list of active tenants to find out whether there are autostart batch pools
		initBatchMulti(_);
	}

	(function(cb) {
		exports.server.on('error', function(err) {
			cb(err);
		}).listen(port, (config.system || {}).bindIP, function() {
			cb();
		});
	})(_);

	console.log('Server running at http://localhost:' + port + '/');

	if (exports.integrationServer) {
		exports.integrationServer.listen(_, config.integrationServer.port, (config.system || {}).bindIP);
		console.log('Integration server running at http://localhost:' + config.integrationServer.port + '/');
	}

	perfmonLogger.start(_);

	// init async (important for tests)
	if (!config.hosting.multiTenant || globals.context.tenantId) initAsync(_);

};

exports.main = function(cb) {
	exports.startServers((cb || function(err) {
		if (err) throw err;
	}));
};

function requireExtension(path) {
	try {
		return require(path);
	} catch (ex) {
		if (ex.code === 'MODULE_NOT_FOUND') {
			try {
				return require(fsp.join(__dirname, '../../../src', path));
			} catch (ex) {
				if (ex.code === 'MODULE_NOT_FOUND' && /memwatch/.test(path)) return undefined;
				else throw ex;
			}
		} else {
			throw ex;
		}
	}
}

var startupExtensions = [];
var registry = require('@sage/syracuse-core').registry;
registry.scanExtensions(function(extensions, sub, pack) {
	if (extensions.startup && extensions.startup.module) {
		var startup = requireExtension(extensions.startup.module);
		if (startup) {
			try {
				startup.setup && startup.setup();
			} catch (e) {
				console.error("Failed to setup extension '" + pack.name + "': " + e.stack);
			}
			startup.start && startupExtensions.push(startup.start);
		}
	}
	if (extensions.http) extensions.http.forEach(function(dispatcher) {
		if (!dispatcher.module) throw new Error(sub + ": package configuration error: http dispatcher module missing");
		var api = requireExtension(dispatcher.module);
		if (api) {
			var name = dispatcher.name || 'app';
			var fn = api[name];
			if (!fn) throw new Error(sub + ': dispatcher function missing: ' + name);
			if (dispatcher.ez) fn = unezify(fn);
			var authFn = ensureAuthenticated(fn);
			var prefix = dispatcher.prefix || sub;
			var unauthPath = dispatcher.unauthenticatedPath && ('/' + prefix + '/' + dispatcher.unauthenticatedPath + '/');
			mainRoutes[prefix] = function(request, response) {
				if (unauthPath && request.url.substring(0, unauthPath.length) === unauthPath) {
					return fn(request, response);
				} else {
					return authFn(request, response);
				}
			};
		}
	});
});

if (process.argv[2] && /^[NWB]/.test(process.argv[2])) {
	// use output stream which writes to file descriptor 3 (to avoid conflict with normal standard output)
	exports.server = new mock.MockStreamServer(rawDisp, new mock.DescriptorWriteStream(3), process.stdin, {
		timeout: +(process.argv[3] || 0),
		pingfunction: function() {
			var sessionLoad = ("" + sessionManager.getLoad()).substr(0, 7);
			var heap = process.memoryUsage().heapUsed;
			if (heap > MEMORY_THRESHOLD1) {
				console.error("ping1 " + heap + " " + MEMORY_THRESHOLD1 + " " + MEMORY_THRESHOLD2);

				if (heap > MEMORY_THRESHOLD2) process.exit(30);
				console.error("ping2 " + heap + " " + MEMORY_THRESHOLD1 + " " + MEMORY_THRESHOLD2);
				return "1|" + sessionLoad;
			}
			return "0|" + sessionLoad;
		}
	}, {
		extraIn: 4,
		extraOut: 5 /* extra streams for ping2 function */
	});
	config.mockServer = exports.server;
	// kill process when pipe breaks (i. e. nanny process has been killed)
	process.stdin.on('close', function() {
		console.log("stdin closed - finish process");
		traceHelper.haltRecording(function(err) {
			console.log("Logging stopped");
			if (err) console.err("Halt recording " + err);
			process.exit(0);
		});
		setTimeout(function() {
			console.log("Logging not stopped");
			process.exit(0);
		}, 1500);
	});
} else {
	var options = _makeHttpServerOptions((config.session || {}).secure);
	exports.server = options.secure //
		? require("https").createServer(options, rawDisp) //
		: require("http").createServer(rawDisp);
	// https server doesn't support setTimeout
	if (exports.server.hasOwnProperty(setTimeout)) exports.server.setTimeout(10 * 60 * 1000);
	// emit SIGINT for windows
	if (process.platform === "win32") {
		require("readline").createInterface({
			input: process.stdin,
			output: process.stdout
		}).on("SIGINT", function() {
			process.emit("SIGINT");
		});
	}
}

if (config.integrationServer && config.integrationServer.port) exports.integrationServer = ez.devices.http.server(disp, _makeHttpServerOptions(true));

// Enable socket.io
var socketHandler = SocketHandler.getSocketHandler();
if (exports.server instanceof mock.MockStreamServer) {
	var socketio = require('socket.io')();
	// need to bind it in a more complicated way so that it is not attached to engine.io
	socketio.bind(exports.server.getMockEngine());
	socketHandler.setSocketIo(socketio);
	socketio = undefined;
} else {
	socketHandler.setSocketIo(require('socket.io').listen(exports.server));
}


exports.config = config;

if (enableDevelopmentFeatures && config.docTool && config.docTool.enabled) {
	require("streamline-doctool").generate(_errorHandler, basePath, config.docTool);
}
if (enableDevelopmentFeatures) {
	try {
		require("tools/git/setupHooks");
	} catch (ex) {
		console.log(ex.message);
	}
}

// exception and exit handlers
process.on('uncaughtException', function(err) {
	_errorHandler(err);
});
process.on('exit', function() {
	// use last opportunity to print cached messages
	var output = traceHelper.getTempMessages();
	console.log(output + "Exiting ...");
});

// make it invoke onExit
try {
	process.on('SIGINT', function() {
		setTimeout(process.exit, 100);
	});
} catch (e) {
	console.log("SIGINT not yet available on Windows");
}

// patch ez.devices.http.client to get performance monitoring on all outgoing HTTP requests
(function() {
	var originalHttpRequest = ez.devices.http.client;
	ez.devices.http.client = function(options) {
		var req = originalHttpRequest(options);
		var originalResponse = req.response;
		req.response = function(_) {
			// log requests taking more that threshold time
			_timerFn(_, req, 0);
			//
			var timing = perfmon.start(module, "httpRequest.response", options.url);
			try {
				return originalResponse.call(req, _);
			} finally {
				req.timer && clearTimeout(req.timer);
				//
				timing.end({
					status: originalResponse.statusCode
				});
			}
		};
		return req;
	};
})();

syncInitTiming.end();

var initializedTenants = {};

// finds out whether this tenant has been initialized
// this is interesting for the dispatchers for license and logging
// which then may ignore the request when the tenant has not been initialized yet
exports.initializedTenant = function(tenantId) {
	return (tenantId in initializedTenants);
};

// names of all initialized tenants
exports.activeTenants = function() {
	return Object.keys(initializedTenants);
};

// Batch servers must be started in multitenant mode even before the first request
// parameter 'stopMode': just initialize tenant, do not start batch servers
function initBatchMulti(_, stopMode) {
	var dbDriver = require('@sage/syracuse-lib/src/load-balancer/dbDriver');
	// search for active tenants (use direct DB connection without SData/ORM framework)
	var dbmain = dbDriver.open(config.collaboration, _);
	var tenants;
	try {
		var tenantsCollection = dbDriver.createCollection(dbmain, 'Tenant', _);
		tenants = dbDriver.find(tenantsCollection, {
			active: true
		}, _);
	} finally {
		dbmain.close();
	}
	if (tenants) {
		if (!config.hosting.parallelInit) {
			tenants.forEach_(_, function(_, tenant) {
				console.log(new Date().toISOString(), "Init tenant " + tenant.tenantId);
				// initialization of tenant database
				exports.initializeTenant(_, tenant.tenantId, stopMode);
			});
		} else { // parallel initialization
			var futures = [];
			tenants.forEach(function(tenant) {
				console.log(new Date().toISOString(), "Init tenant " + tenant.tenantId);
				futures.push(exports.initializeTenant(!_, tenant.tenantId, stopMode));
			});
			futures.forEach_(_, function(_, fut) {
				try {
					fut(_);
				} catch (e) {
					console.error("Error during import " + e + " " + (e.stack ? e.stack : ""))
				}
			})
		}
	}
}

exports.initializeTenant = function(cb, tenantId, stopMode) {
	globals.withContext(function() {
		initAsync(cb, true, stopMode);
	}, {
		tenantId: tenantId
	})();
};


// Initializations
// simplified: the simplified initialization is for special use when no normal request need to be processed but
// the application should only be started to execute a certain administrative batch task and then finish
// (e. g. node index PATCH for patch integration)
// stopMode: do not start batch servers/web service pools (STOP mode)

function initAsync(_, simplified, stopMode) {
	var key = globals.context.tenantId || "$$solo";
	if (!initializedTenants[key]) initializedTenants[key] = {
		funnel: flows.funnel(1),
		done: false,
	}
	initializedTenants[key].funnel(_, function(_) {
		if (initializedTenants[key].done) return;
		initializedTenants[key].done = true;
		var asyncInitTiming = perfmon.start(module, "main.asyncInit");
		// Run init functions from each registered endpoints
		config.sdata.endpoints.forEach(function(ep) {
			if (ep.init) ep.init();
		});
		// Run initialize functions from each registered contracts
		// This can be necessary for some extension that need to execute something after the whole application started
		Object.keys(sdataRegistry.applications).forEach_(_, function(_, appKey) {
			var app = sdataRegistry.applications[appKey];
			Object.keys(app.contracts).forEach_(_, function(_, contractKey) {
				var contract = app.contracts[contractKey];
				if (contract.initialize) contract.initialize(_);
			});
		});
		// WARNING: async code below => require will yield and return incomplete API
		try {
			var orm = adminHelpers.AdminHelper.getCollaborationOrm(_);
		} catch (e) {
			console.error("Failed to open collaboration database: " + e.stack);
			process.exit(1);
		}

		var admEp = adminHelpers.AdminHelper.getCollaborationEndpoint(_);
		if (admEp && config.collaboration) {
			var dataset = admEp.dataset(_);
			if (dataset !== config.collaboration.dataset) {
				console.error("Different collaboration dataset in Syracuse endpoint (" + dataset + ") and nodelocal.js (" + config.collaboration.dataset + ")");
				process.exit(1);
			}
		}
		// for emergency, if collaboration endpoint points to wrong database
		if (process.argv[2] === "--rescueEndpoint" && admEp) {
			admEp.localDatabase(_, true);
			admEp.save(_);
			console.log("Set local database for collaboration endpoint");
		}
		if (process.argv[2] === "--reset" || process.argv[2] === "--resetpass") { // set admin user to DB authentication; test the password
			try {
				var password = process.argv[3];
				var passphrase = process.argv[4];
				var user = orm.fetchInstance(_, orm.getEntity(_, "user"), {
					jsonWhere: {
						login: "admin"
					}
				});
				if (!user) throw new Error(locale.format(module, "resetNoAdmin"));
				// get the password hash
				var hash = require('crypto').createHash('MD5');
				var pwhash = user.password(_);
				var utf8 = (pwhash[0] === 'U');
				hash.update("admin:" + config.session.realm + ":" + password, utf8 ? 'utf8' : 'binary');
				var newpwhash = hash.digest("hex");
				if (utf8) newpwhash = "U" + newpwhash;
				if (process.argv[2] === "--resetpass") {
					// test passphrase
					if (!require('@sage/syracuse-lib/src/load-balancer/certTools').checkPassphrase(_, null, passphrase)) {
						throw new Error(locale.format(module, "resetWrongPhrase"));
					}
				} else {
					if (newpwhash !== pwhash) {
						throw new Error(locale.format(module, "resetWrongWord"));
					}
				}
				// set DB authentication
				user.authentication(_, "db");
				// mark user as active
				user.active(_, true);
				if (newpwhash !== pwhash)
					user.password(_, newpwhash);
				user.save(_);
				var diags = [];
				user.getAllDiagnoses(_, diags, {
					addPropName: true
				});
				if (diags.length) {
					throw new Error(locale.format(module, "resetMessages", require('util').format(diags)));
				}
				console.log(locale.format(module, "resetOK"));
			} catch (e) {
				console.error("" + e);
				process.exit(1);
			}
		}
		// load all endpoints
		sdataRegistry.loadAllEndpoints(_);
		// cleanup
		sessionManager.cleanupSessionInfos(_);
		// maybe add license for tenant
		for (var i = 2; i < process.argv.length; i++) {
			var arg = process.argv[i];
			if (arg.substr(0, 8) === "licfile=") {
				console.log("Read license " + arg.substr(8));
				var lic = fs.readFileSync(arg.substr(8), "utf8");
				var diagnoses = [];
				// console.log("Lizenzinhalt " + lic);
				require('@sage/syracuse-lib/src/license/check').licenseChange(lic, diagnoses, _);
				console.log("Diagnoses when reading license " + JSON.stringify(diagnoses));
				break;
			}
			// 		console.log("Tenant " + globals.context.tenantId);
		}

		// update badges
		require("@sage/syracuse-lib/src/collaboration/entities/badge").updateBadges(_);
		// scheduler (no wait)
		if (!simplified) {
			adminHelpers.AdminHelper.startTimers(_);
			// register afterSave events for transparent indexing
			indexEngine.registerModelEvents(_, config.searchEngine);

			require('@sage/syracuse-lib/src/flamegraph/index').autoStart(_);
		}

		asyncInitTiming.end();

		// Register history log events

		historyLog.registerModelEvents(_);
		// Create historylog setting from file
		require('@sage/syracuse-lib/src/collaboration/entities/setting').updateHistoryLogSetting(_);



		// Initialize tracers
		traceHelper.initializeTracers(_);

		if (!stopMode) {
			// Initialize batch controller	
			// For loadBalancer batch dedicated processes

			// Subscribe to channel batch and listen to batch commands
			if (!/^[W]\d+$/.test(process.argv[2])) {
				require('syracuse-batch/lib/batchManager').registerBatchServer(_);
			}

			// Launch classic web services pools
			// For loadBalancer web services dedicated processes
			if (!/^[NB]\d+$/.test(process.argv[2])) {
				require('syracuse-soap/lib/generic/poolManager').initializePools(_);
			}
		}

		startupExtensions.forEach_(_, function(_, s) {
			try {
				s(_);
			} catch (e) {
				console.error("Failed to start extension: " + e.stack);
			}
		});
		if (!simplified) _initialized = true;
	});

}

function runPatch(_) {
	console.log("Final patch integration");
	initAsync(_, true);
	require('syracuse-patch/lib/patchtools').finalIntegration(_);
	// patch integration process finishes here
	// unlock system
	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
	var setting = db.fetchInstance(_, db.model.getEntity(_, "setting"), {
		sdataWhere: ""
	});
	if (setting) {
		setting.patchLock(_, false); // release semaphore lock
		setting.save(_);
	}
	process.exit(0);
}


exports.runPatchCb = function(cb) {
	runPatch(cb);
};