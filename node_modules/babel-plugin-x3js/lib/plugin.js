"use strict";

function canTransform(state) {
	return state.opts.forceTransform || /^(unknown|.*\.x3js)$/.test(state.file.opts.filename);
}

var binaryMap = {
	'+': 'add',
	'-': 'sub',
	'*': 'mul',
	'/': 'div',
	'==': 'eq',
	'!=': 'ne',
	'<': 'lt',
	'<=': 'le',
	'>': 'gt',
	'>=': 'ge',
};

var unaryMap = {
	'+': 'plus',
	'-': 'minus',
};

var updateMap = {
	'++': 'add',
	'--': 'sub',
};

function runtimeMember(t, state, name) {
	return t.memberExpression(t.identifier(state.x3js.runtimeVar), t.identifier(name));
}

function isAsyncMember(t, node) {
	return t.isMemberExpression(node) && !node.computed && /\$$/.test(node.property.name);
}

/*function isArrayBuiltinMember(t, node) {
	return t.isMemberExpression(node) && !node.computed && 
	/^(forEach|map|filter|some|every|reduce|reduceRight|sort)\$$/.test(node.property.name);
}*/

module.exports = function(pluginArguments) {
	var t = pluginArguments.types;
	return {
		visitor: {
			BinaryExpression: function(path, state) {
				if (!canTransform(state)) return;
				var node = path.node;
				var fn = binaryMap[node.operator];
				if (fn) {
					path.replaceWith(t.callExpression(runtimeMember(t, state, fn), [node.left, node.right]));
				}
			},
			UnaryExpression: function(path, state) {
				if (!canTransform(state)) return;
				var node = path.node;
				var fn = unaryMap[node.operator];
				if (fn) {
					path.replaceWith(t.callExpression(runtimeMember(t, state, fn), [node.argument]));
				}
			},
			UpdateExpression: function(path, state) {
				if (!canTransform(state)) return;
				var node = path.node;
				var scope = path.scope;
				var fn = updateMap[node.operator];
				if (fn) {
					var tval = t.identifier(path.scope.generateUid('v'));
					scope.push({ id: tval });
					if (t.isMemberExpression(node.argument)) {
						var tobj = t.identifier(path.scope.generateUid('o'));
						scope.push({ id: tobj });
						// TODO: computed member - don't eval property twice!!
						var seq = [
							t.assignmentExpression('=', tobj, node.argument.object),
							t.assignmentExpression('=', tval, t.memberExpression(tobj, node.argument.property)),
							t.assignmentExpression('=', t.memberExpression(tobj, node.argument.property), 
								t.callExpression(runtimeMember(t, state, fn), [tval, t.numericLiteral(1)]))
						];
						if (!node.prefix) seq.push(tval);
						path.replaceWith(t.sequenceExpression(seq));
					} else {
						var seq = [
							t.assignmentExpression('=', tval, node.argument),
							t.assignmentExpression('=', node.argument, 
								t.callExpression(runtimeMember(t, state, fn), [tval, t.numericLiteral(1)]))
						];
						if (!node.prefix) seq.push(tval);
						path.replaceWith(t.sequenceExpression(seq));
					}
				}
			},
			MemberExpression: function(path, state) {
				if (!canTransform(state)) return;
				var node = path.node;
				if (isAsyncMember(t, node)) {
					var trimmed = node.property.name.replace(/.$/, '');
					path.replaceWith(t.callExpression(t.memberExpression(node.object, t.identifier(trimmed)),
						[t.identifier('_')]));
				}
			},
			AssignmentExpression: function(path, state) {
				if (!canTransform(state)) return;
				var node = path.node;
				if (isAsyncMember(t, node.left)) {
					var trimmed = node.left.property.name.replace(/.$/, '');
					path.replaceWith(t.callExpression(t.memberExpression(node.left.object, t.identifier(trimmed)),
						[t.identifier('_'), node.right]));
				}
			},
			NumericLiteral: function(path, state) {
				if (!canTransform(state)) return;
				var node = path.node;
				if (node.extra && /\.[^e]*$/i.test(node.extra.raw)) {
					path.replaceWith(t.callExpression(runtimeMember(t, state, 'bcd'), [t.stringLiteral(node.extra.raw)]));
				}
			},
			/*CallExpression: function(path, state) {
				if (!canTransform(state)) return;
				var node = path.node;
				var fArg = node.arguments[0];
				if (isArrayBuiltinMember(t, node.callee) && t.isArrowFunctionExpression(fArg)) {
					var replaced = node.callee.property.name.replace(/\$$/, '_');
					fArg.params.unshift(t.identifier('_'));
					path.replaceWith(t.callExpression(
						t.memberExpression(node.callee.object, t.identifier(replaced)),
						[t.identifier('_'), fArg].concat(node.arguments.slice(1))));
				}
			},*/
			Program: function(path, state) {
				if (!canTransform(state)) return;
				state.x3js = {
					runtimeVar: path.scope.generateUid('x3js'),
				};
				var node = path.node;
				node.body = [
					t.variableDeclaration('var', [
						t.variableDeclarator(
							t.identifier(state.x3js.runtimeVar),
							t.callExpression(t.identifier('require'), [t.stringLiteral('etna/lib/engine/x3js-runtime')]))
					])
				].concat(node.body);
			},
		},
	};
};