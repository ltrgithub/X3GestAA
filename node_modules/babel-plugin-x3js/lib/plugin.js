"use strict";

function canTransform(state) {
	return state.opts.forceTransform || /^(unknown|.*\.x3js)$/.test(state.file.opts.filename);
}

var binaryMap = {
	'+': 'add',
	'-': 'sub',
	'*': 'mul',
	'/': 'div',
	'==': 'eq',
	'!=': 'ne',
	'<': 'lt',
	'<=': 'le',
	'>': 'gt',
	'>=': 'ge',
};

var unaryMap = {
	'+': 'plus',
	'-': 'minus',
};

var updateMap = {
	'++': 'add',
	'--': 'sub',
};

function runtimeMember(t, state, name) {
	return t.memberExpression(state.x3js.runtimeVar, t.identifier(name));
}

function isAsyncMember(t, node) {
	return t.isMemberExpression(node) && !node.computed && /\$$/.test(node.property.name);
}

function transformUpdate(t, scope, state, lhs, fn, rhs, prefix) {
	var tval = t.identifier(scope.generateUid('v'));
	scope.push({
		id: tval
	});
	var seq = [];
	if (t.isMemberExpression(lhs)) {
		var tobj = t.identifier(scope.generateUid('o'));
		scope.push({
			id: tobj
		});
		seq.push(t.assignmentExpression('=', tobj, lhs.object));
		var tprop;
		if (lhs.computed) {
			tprop = t.identifier(scope.generateUid('p'));
			scope.push({
				id: tprop
			});
			seq.push(t.assignmentExpression('=', tprop, lhs.property));
		} else {
			tprop = lhs.property;
		}
		seq.push(t.assignmentExpression('=', tval, t.memberExpression(tobj, tprop, lhs.computed)));
		seq.push(t.assignmentExpression('=', t.memberExpression(tobj, tprop, lhs.computed), t.callExpression(runtimeMember(t, state, fn), [tval, rhs])));
	} else {
		seq.push(t.assignmentExpression('=', tval, lhs))
		seq.push(t.assignmentExpression('=', lhs, t.callExpression(runtimeMember(t, state, fn), [tval, rhs])));
	}
	if (!prefix) seq.push(tval);
	return t.sequenceExpression(seq);
}

module.exports = function(pluginArguments) {
	var t = pluginArguments.types;
	return {
		visitor: {
			BinaryExpression(path, state) {
				if (!canTransform(state)) return;
				var node = path.node;
				var fn = binaryMap[node.operator];
				if (fn) {
					path.replaceWith(t.callExpression(runtimeMember(t, state, fn), [node.left, node.right]));
				}
			},
			UnaryExpression(path, state) {
				if (!canTransform(state)) return;
				var node = path.node;
				var fn = unaryMap[node.operator];
				if (fn) {
					path.replaceWith(t.callExpression(runtimeMember(t, state, fn), [node.argument]));
				}
			},
			UpdateExpression(path, state) {
				if (!canTransform(state)) return;
				var node = path.node;
				var fn = updateMap[node.operator];
				if (fn) {
					path.replaceWith(transformUpdate(t, path.scope, state, node.argument, fn, t.numericLiteral(1), node.prefix));
				}
			},
			MemberExpression(path, state) {
				if (!canTransform(state)) return;
				var node = path.node;
				if (isAsyncMember(t, node)) {
					var trimmed = node.property.name.replace(/.$/, '');
					path.replaceWith(t.callExpression(t.memberExpression(node.object, t.identifier(trimmed)),
						[t.identifier('_')]));
				}
			},
			AssignmentExpression(path, state) {
				if (!canTransform(state)) return;
				var node = path.node;
				if (node.operator !== '=') {
					var fn = binaryMap[node.operator.substring(0, node.operator.length - 1)];
					if (fn) {
						path.replaceWith(transformUpdate(t, path.scope, state, node.left, fn, node.right, true));
					}
				} else {
					if (isAsyncMember(t, node.left)) {
						var trimmed = node.left.property.name.replace(/.$/, '');
						path.replaceWith(t.callExpression(t.memberExpression(node.left.object, t.identifier(trimmed)),
							[t.identifier('_'), node.right]));
					}
				}
			},
			NumericLiteral(path, state) {
				if (!canTransform(state)) return;
				var node = path.node;
				if (node.extra && /\.[^e]*$/i.test(node.extra.raw)) {
					path.replaceWith(t.callExpression(runtimeMember(t, state, 'bcd'), [t.stringLiteral(node.extra.raw)]));
				}
			},
			Program(path, state) {
				if (!canTransform(state)) return;
				if (state.x3js) return;
				state.x3js = {
					runtimeVar: path.scope.generateUidIdentifier('x3js'),
				};
				path.scope.push({
					id: state.x3js.runtimeVar,
					init: t.callExpression(t.identifier('require'), [t.stringLiteral('etna/lib/engine/x3js-runtime')]),
				});
			},
		},
	};
};