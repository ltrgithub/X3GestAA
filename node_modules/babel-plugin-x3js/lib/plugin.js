"use strict";

function canTransform(state) {
	return state.opts.forceTransform || /^(unknown|.*\.x3js)$/.test(state.file.opts.filename);
}

const binaryMap = {
	'+': 'add',
	'-': 'sub',
	'*': 'mul',
	'/': 'div',
	'==': 'eq',
	'!=': 'ne',
	'<': 'lt',
	'<=': 'le',
	'>': 'gt',
	'>=': 'ge',
};

const unaryMap = {
	'+': 'plus',
	'-': 'minus',
};

const updateMap = {
	'++': 'add',
	'--': 'sub',
};

function runtimeMember(t, state, name) {
	return t.memberExpression(state.x3js.runtimeVar, t.identifier(name));
}

function isAsyncMember(t, node) {
	return t.isMemberExpression(node) && !node.computed && /\$$/.test(node.property.name);
}

function transformUpdate(t, scope, state, lhs, fn, rhs, prefix) {
	const tval = t.identifier(scope.generateUid('v'));
	scope.push({
		id: tval
	});
	const seq = [];
	if (t.isMemberExpression(lhs)) {
		const tobj = t.identifier(scope.generateUid('o'));
		scope.push({
			id: tobj
		});
		seq.push(t.assignmentExpression('=', tobj, lhs.object));
		var tprop;
		if (lhs.computed) {
			tprop = t.identifier(scope.generateUid('p'));
			scope.push({
				id: tprop
			});
			seq.push(t.assignmentExpression('=', tprop, lhs.property));
		} else {
			tprop = lhs.property;
		}
		seq.push(t.assignmentExpression('=', tval, t.memberExpression(tobj, tprop, lhs.computed)));
		seq.push(t.assignmentExpression('=', t.memberExpression(tobj, tprop, lhs.computed), t.callExpression(runtimeMember(t, state, fn), [tval, rhs])));
	} else {
		seq.push(t.assignmentExpression('=', tval, lhs))
		seq.push(t.assignmentExpression('=', lhs, t.callExpression(runtimeMember(t, state, fn), [tval, rhs])));
	}
	if (!prefix) seq.push(tval);
	return t.sequenceExpression(seq);
}

module.exports = function(pluginArguments) {
	const t = pluginArguments.types;
	return {
		visitor: {
			BinaryExpression(path, state) {
				if (!canTransform(state)) return;
				const node = path.node;
				const fn = binaryMap[node.operator];
				if (fn) {
					path.replaceWith(t.callExpression(runtimeMember(t, state, fn), [node.left, node.right]));
				}
			},
			UnaryExpression(path, state) {
				if (!canTransform(state)) return;
				const node = path.node;
				const fn = unaryMap[node.operator];
				if (fn) {
					path.replaceWith(t.callExpression(runtimeMember(t, state, fn), [node.argument]));
				}
			},
			UpdateExpression(path, state) {
				if (!canTransform(state)) return;
				const node = path.node;
				const fn = updateMap[node.operator];
				if (fn) {
					path.replaceWith(transformUpdate(t, path.scope, state, node.argument, fn, t.numericLiteral(1), node.prefix));
				}
			},
			MemberExpression(path, state) {
				if (!canTransform(state)) return;
				const node = path.node;
				if (isAsyncMember(t, node)) {
					const trimmed = node.property.name.replace(/.$/, '');
					path.replaceWith(t.callExpression(
						t.memberExpression(t.memberExpression(node.object, t.identifier(trimmed)), t.identifier('get')),
						[t.identifier('_')]));
				}
			},
			AssignmentExpression(path, state) {
				if (!canTransform(state)) return;
				const node = path.node;
				const scope = path.scope;
				if (node.operator !== '=') {
					const fn = binaryMap[node.operator.substring(0, node.operator.length - 1)];
					if (fn) {
						path.replaceWith(transformUpdate(t, path.scope, state, node.left, fn, node.right, true));
					}
				} else {
					if (isAsyncMember(t, node.left)) {
						// build sequence because expression returns rhs value
						const trimmed = node.left.property.name.replace(/.$/, '');
						const tobj = t.identifier(scope.generateUid('o'));
						scope.push({ id: tobj });
						const tval = t.identifier(scope.generateUid('v'));
						scope.push({ id: tval });
						path.replaceWith(t.sequenceExpression([
							t.assignmentExpression('=', tobj, node.left.object),
							t.assignmentExpression('=', tval, node.right),
							t.callExpression(t.memberExpression(t.memberExpression(tobj, t.identifier(trimmed)), t.identifier('set')),
							[t.identifier('_'), tval]),
							tval]));
					}
				}
			},
			NumericLiteral(path, state) {
				if (!canTransform(state)) return;
				const node = path.node;
				if (node.extra && /\.[^e]*$/i.test(node.extra.raw)) {
					path.replaceWith(t.callExpression(runtimeMember(t, state, 'bcd'), [t.stringLiteral(node.extra.raw)]));
				}
			},
			Program(path, state) {
				if (!canTransform(state)) return;
				if (state.x3js) return;
				state.opts.strict = true;
				state.x3js = {
					runtimeVar: path.scope.generateUidIdentifier('x3js'),
				};
				path.scope.push({
					id: state.x3js.runtimeVar,
					init: t.callExpression(t.identifier('require'), [t.stringLiteral('etna/lib/engine/x3js-runtime')]),
				});
			},
			TryStatement(path, state) {
				throw path.buildCodeFrameError('try/catch/finally not allowed in x3js code - use x3js.tryCatch(_, fn) instead');
			},
			VariableDeclaration(path, state) {
				if (!path.node.loc || path.node.declarations.every(decl => !decl.loc)) return; // don't check internal nodes
				switch (path.node.kind) {
					case 'const': break;
					case 'var': throw path.buildCodeFrameError('var declaration not allowed in x3js code - use const or let');
					case 'let': 
						path.node.declarations.forEach(decl => {
							if (path.scope.getBinding(decl.id.name).constant) 
								throw path.buildCodeFrameError(decl.id.name + ' must be declared with const instead of let');
						});
						break;
					default:
						throw path.buildCodeFrameError('internal error, bad node kind: ' + path.node.kind);
				}
			},
		},
	};
};