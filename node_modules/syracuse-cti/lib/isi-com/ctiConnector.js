"use strict";

var net = require('net');
var http = require('http');
var io = require('socket.io');
var fs = require('fs');
var path = require('path');

var controlSequence = require('./ctiCommon').controlSequence;
var ctiServerMethods = require('./ctiServerMethods');
var ctiServerEvents = require('./ctiServerEvents');
var getCstaEventString = require('./ctiCommon').getCstaEventString;

var tracer = require('@sage/syracuse-core').getTracer("cti");

function Connector() {
	var sock;

	function _write(data) {
		try {
			sock.write(data);
		} catch (e) {
			console.error("ISI-COM CTI Error:", e.stack);
		}
	}

	this.connect = function(opt, cb) {
		sock = net.connect({
				port: opt.port,
				host: opt.hostname
			},
			function() { //'connect' listener
				tracer.info && tracer.info('Connected to ISI-COM server: ' + opt.hostname + ":" + opt.port);
				sock.on('data', function(data) {
					var str = data.toString();
					tracer.debug && tracer.debug('<= DATA = ' + str);
					if ((str.length > 3) && (str[0] == controlSequence.STX) && (str.indexOf(controlSequence.CRLF, str.length - controlSequence.CRLF.length) != -1)) {

						while (str.indexOf(controlSequence.CRLF) > 0) {
							// Cut at the 1st CR/LF
							var trame = str.substring(0, str.indexOf(controlSequence.CRLF));
							// And prepare for next One
							str = str.substring(str.indexOf(controlSequence.CRLF) + 2);

							// Terminates with | CR LF normally
							if (trame[trame.length - 1] == controlSequence.ISI_SEPARATOR)
								trame = trame.substring(0, trame.length - 1);

							tracer.debug && tracer.debug('<= TRAME = ' + trame);
							var fields = trame.split(controlSequence.ISI_SEPARATOR);
							// get opcode
							var opcodeStr = ctiServerEvents.GetOpcode(fields[0]);
							var opcode = ctiServerEvents.GetIntOpcode(fields[0]);
							tracer.debug && tracer.debug('<= opcode=' + opcode + '-' + opcodeStr);

							// Remove first element from fields array, it contains the header
							fields.shift();

							if (opcode == ctiServerEvents.AgentInformations) {
								if (fields.length > 4) {
									tracer.debug && tracer.debug('<= AgentInformations agentLogon = ' + fields[4]);
									// TODO : We could use it to manage the RegisterLogonWindows method
								}
							}
							if (opcode == ctiServerEvents.CSTAEvent) {
								opcodeStr = getCstaEventString(fields[0]);
								tracer.debug && tracer.debug('<= CstaEvent : (' + fields[0] + ') ' + opcodeStr);
								// Remove first element too, it only contains the csta event number
								fields.shift();
							}

							for (var i = 0; i < fields.length; i++)
								fields[i] = fields[i].toString("utf8");

							// Send the nale of the event and the arguments
							cb(opcodeStr, fields);
							// io_socket_emit_event(null, 'CTIServerDebug', [fields[0], "Received : " + opcodeStr + " : " + fields.join(", ")]);
							// io_socket_emit_event(null, opcodeStr, fields);
						}

					}
				});
				sock.on('end', function() {
					tracer.info && tracer.info('Disconnected from ISI-COM server: ' + opt.hostname + ":" + opt.port);
				});
				sock.on('error', function(err) {
					tracer.error && tracer.error('ISI-COM server error: ' + err);
				});
			});

		sock.setEncoding("binary");
	};

	this.isAlive = function() {
		return sock && !sock.closed && !sock.detroyed && sock.readable && sock.writable;
	};

	this.registerAll = function() {
		_write(ctiServerMethods.GetMessageCommand(ctiServerMethods._RegisterAll, null));
	};

	this.makeCall = function(agentNum, phoneNumberToDial) {
		_write(ctiServerMethods.GetMessageCommand(ctiServerMethods.srvMakeCall, [agentNum, phoneNumberToDial]));
	};

	this.sendIdentification = function(agentNum, refCom, lastName, firstName, company) {
		_write(ctiServerMethods.GetMessageCommand(ctiServerMethods.srvSendIdentification, [agentNum, refCom, lastName, firstName, company]));
	};
}

exports.Connector = Connector;