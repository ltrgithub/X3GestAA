"use strict";
// Global constants and initialisation
var fs = require('streamline-fs');
var fspath = require('path');
var crypto = require('crypto');
var os = require('os');
var util = require('util');
var cr;

var ROOT = exports.ROOT = '.';
var DATA = exports.DATA = DATA = fspath.join(ROOT, "licensetool");
var GENERAL = exports.GENERAL = fspath.join(DATA, "general");

var PRIVATE = exports.PRIVATE = fspath.join(DATA, "private");
exports.POLICIES = fspath.join(DATA, "policies");
exports.LICENSES = fspath.join(DATA, "licenses");
exports.USER_FILE = fspath.join(GENERAL, "user.json");
exports.PARTNER_FILE = fspath.join(GENERAL, "partner.json");
var PUBLIC_KEY = fspath.join(GENERAL, "public.pem");
var PRIVATE_KEY = fspath.join(PRIVATE, "private.pem");
exports.REALM = "licensetool";
exports.CONFIG_FILE = fspath.join(GENERAL, "config.json");


var ALGORITHM = "RSA-SHA256"; // signature algorithm for licenses and policies

// private key clear/encrypted
var privateKey;
var privateKeyEnc;


exports.users; // JSON structure of all users

exports.partnerId;
exports.prefix; // dictionary prefix

exports.cfg = {};

var policiesFuture; // future of search for used policies
var _usedPolicies; // object of usage count of policies

function _error(text) {
	console.error("Error in initialization: " + text);
	process.exit(1);
}


//initializations
function init(port, user, passwd, pubkey, privkey, passphrase) {
	var change = false;
	if (pubkey || privkey) { // public/private key given: total initialisation
		if (fs.existsSync(GENERAL)) _error("No initialization with existing data directory " + DATA);
		if (!user || !port) _error("No user or port specified");
		try {
			exports.publicKey = fs.readFileSync(pubkey, "utf8");
			privateKeyEnc = fs.readFileSync(privkey, "utf8");
		} catch (e) {
			_error(e.message);
		}
	} else { // otherwise read existing keys
		try {
			exports.publicKey = fs.readFileSync(PUBLIC_KEY, "utf8");
			privateKeyEnc = fs.readFileSync(PRIVATE_KEY, "utf8");
		} catch (e) {
			if (!fs.existsSync(GENERAL)) _error("Initialization necessary!");
			_error(e.message);
		}
	}
	// read user file
	try {
		exports.users = JSON.parse(fs.readFileSync(exports.USER_FILE, "utf8"));
	} catch (e) {
		console.log("New user file");
		exports.users = [];
	}
	if (user) { // make admin user
		if (!passwd || !passphrase) {
			_error("Password or passphrase missing");
		}
		console.log("Test integrity of keys and passphrase");
		try {
			_testKeys(exports.publicKey, privateKeyEnc, passphrase);
		} catch (e) {
			_error(e.message);
		}
		user = user.toLowerCase();
		var userdata;
		if (!exports.users.some(function(item) { // maybe user already exists
			if (item.login === user) {
				userdata = item;
				return true;
			}
		})) {
			userdata = {
				login: user
			};
			exports.users.push(userdata);
		}
		if (!userdata.name) {
			userdata.name = user.charAt(0).toUpperCase() + user.substr(1); // capitalise the login
		}
		userdata.admin = true; // admin user
		exports.updateUserData(userdata, passwd, passphrase);
	} else {
		if (!exports.users.length) _error("No user available");
	}
	try {
		var config = JSON.parse(fs.readFileSync(exports.CONFIG_FILE, "utf8"));
		exports.cfg.port = config.port;
	} catch (e) {
		var config = {
			locales: ["en-us"]
		};
	}
	exports.updateLocales(config.locales);
	if (port) { // set port
		if (!/^\d+/.test(port)) _error("Incorrect port number " + port);
		exports.cfg.port = port;
	} else {
		if (!exports.cfg.port) _error("No port available");
	}
	try {
		exports.setPartnerFile(fs.readFileSync(exports.PARTNER_FILE, "utf8"));
	} catch (e) {
		if (e.code !== 'ENOENT') _error(e.message);
		console.log("No partner file");
	}
	// Changes to file system now, since all checks have been passed
	if (pubkey) {
		// generate directories
		[DATA, GENERAL, exports.POLICIES, exports.LICENSES, PRIVATE].forEach(function(directory) {
			if (!fs.existsSync(directory)) {
				console.log("Create " + directory);
				fs.mkdirSync(directory);
			}
		});
		// write keys
		console.log("Write keys ...");
		fs.writeFileSync(PUBLIC_KEY, exports.publicKey, "utf8");
		fs.writeFileSync(PRIVATE_KEY, privateKeyEnc, "utf8");
	}
	if (user) {
		// write new user file
		console.log("Write user file ...");
		fs.writeFileSync(exports.USER_FILE, JSON.stringify(exports.users), "utf8");
	}
	if (port) {
		console.log("Write config file ...");
		fs.writeFileSync(exports.CONFIG_FILE, JSON.stringify(exports.cfg, null, "\t"), "utf8");
	}
	// 
	if (!pubkey && !user && !port) policiesFuture = _findUsedPolicies(!_);
}
exports.init = init;

exports.localeObject;

exports.setPartnerFile = function(content) {
	var partnerFile = JSON.parse(content);
	// test public key
	var pubKey = exports.publicKey.replace(/-----[A-Z ]+-----|\r|\n/g, "");
	if (pubKey !== partnerFile.publicKey) throw new Error("Public key does not fit to public key of partner file");
	exports.partnerId = partnerFile.partnerId;
	exports.prefix = (partnerFile.codificationRange || {}).dictionnaryPrefix;
	if (exports.prefix && !/^(?:[A-Z]+\,)*[A-Z]+$/.test(exports.prefix)) throw new Error("Wrong format of prefix");
};

exports.updateLocales = function(localeArray, diagnoses) {
	var newLocales = [];
	var tempLoc = {};
	exports.cfg.locales = exports.cfg.locales || [];
	var changed = (exports.cfg.locales.length !== localeArray.length);
	for (var i = 0; i < localeArray.length; i++) {
		var item = localeArray[i];
		var loc = item.localeCode ? item.localeCode.$uuid : item;
		if (!loc) {
			if (diagnoses) diagnoses.push({
				severity: "error",
				message: "No locale code"
			});
		} else {
			if (loc in tempLoc) {
				// duplicate code
				if (diagnoses) diagnoses.push({
					severity: "warning",
					message: "Ignore duplicate locale " + loc
				});
			} else {
				if (loc !== exports.cfg.locales[i]) changed = true;
				tempLoc[loc] = 1;
				newLocales.push(loc);
			}
		}

	}
	if (changed) {
		if (exports.cfg.locales) {
			exports.cfg.locales = newLocales;
			exports.localeObject = tempLoc;
			try {
				fs.writeFileSync(exports.CONFIG_FILE, JSON.stringify(exports.cfg, null, "\t"), "utf8");
			} catch (e) {
				console.error(e);
				if (diagnoses) diagnoses.push({
					severity: "error",
					message: "Error when updating configuration: " + e
				});
			}
			if (diagnoses) diagnoses.push({
				severity: "info",
				message: "Configuration updated"
			});
		} else exports.cfg.locales = newLocales;
	}
	if (!exports.cfg.locales) exports.cfg.locales = [];
};




function _findUsedPolicies(_) {
	var customers = fs.readdir(exports.LICENSES, _);
	var policies = {};
	customers.forEach_(_, function(_, customer) {
		try {
			var lics = fs.readdir(exports.LICENSES + "/" + customer, _);
			lics.forEach(function(p) {
				if (p.indexOf(".json") === p.length - 5) {
					var policyName = p.substr(0, p.lastIndexOf("-"));
					if (policyName in policies) {
						policies[policyName]++;
					} else {
						policies[policyName] = 1;
					}
				}
			});
		} catch (e) {
			// ignore
			console.log(e.stack);
		}
	});
	_usedPolicies = policies;
	policiesFuture = undefined;
	return policies;
}

// if `add` parameter is positive or negative, add/remove to/from usage count for that policy.
// if `add` parameter is not set, return whether policy name has positive usage count
exports.usedPolicies = function(_, name, add) {
	if (!_usedPolicies) {
		if (!policiesFuture) throw new Error("No policies available");
		policiesFuture(_);
	}
	if (add) {
		if (add > 0) {
			if (name in _usedPolicies) _usedPolicies[name] += add;
			else _usedPolicies[name] = add;
		} else {
			if (_usedPolicies[name] > -add) _usedPolicies[name] -= -add;
			else delete _usedPolicies[name];
		}
	} else {
		return (_usedPolicies[name] || 0);
	}
};

exports.setUsedPolicies = function(_, policies) {
	if (!_usedPolicies) {
		if (!policiesFuture) throw new Error("No policies available");
		policiesFuture(_);
	}
	_usedPolicies = policies;
};


function _testKeys(publicKey, privateKeyEnc, passphrase) {
	privateKey = _stripEncryption(privateKeyEnc, passphrase);
	// 	sign and verify
	var signed = _sign("ABCDE");
	if (!_verify("ABCDE", signed))
		throw new Error("Public key does not fit to private key");
}

function verifyLicense(lic) {
	var parsed = JSON.parse(lic);
	lic = lic.replace(/"signature":\s*".*?"/, '"signature": "' + parsed.signatureText + '"');
	lic = normalize(lic);
	return _verify(lic, parsed.signature);
}

function _sign(content) {
	var signRes = crypto.createSign(ALGORITHM);
	signRes.update(content, "utf8");
	return signRes.sign(privateKey, "base64");
}


function _verify(content, signature) {
	var verifier = crypto.createVerify(ALGORITHM);
	verifier.update(new Buffer(content, 'utf8'));
	return verifier.verify(exports.publicKey, signature, 'base64');
}

function signLicense(jsonLic, ctx) {
	if (!privateKey) {
		var passphrase = exports.decryptPassphrase(ctx.pass, ctx.salt, ctx.pwd);
		_testKeys(exports.publicKey, privateKeyEnc, passphrase);
		privateKeyEnc = undefined;
	}
	jsonLic.signature = jsonLic.signatureText;
	var lic = JSON.stringify(jsonLic, null, "\t");
	var normalLic = _normalize(lic);
	var signature = _sign(normalLic);
	lic = lic.replace(/"signature":\s*".*?"/, '"signature": "' + signature + '"');
	return lic;
}
exports.signLicense = signLicense;

// normalize license content: remove all whitespace outside quoted areas
function _normalize(c) {
	c = c.replace(/[\s\r\n]+/g, " ");
	c = c.replace(/(\W) /g, "$1");
	c = c.replace(/ (\W)/g, "$1");
	return c;
}



/// ## Strip the encryption from a private key
///    `stripEncryption(key, passphrase, test)`
///   Arguments are a private key in PEM format and the passphrase. The output will be the private key without encryption in PEM format.
///   When the private key has not been encrypted, the passphrase will be ignored and the private key will be returned unchanged.
///
function _stripEncryption(key, passphrase) {
	var r = /^-----BEGIN ((?:RSA )?PRIVATE KEY)-----\s+(?:Proc-Type: ([\w,]+)\s+DEK-Info: ([\-\w]+)(?:,(\w+))?)?(?:([\w\=\/\+\s]+))/.exec(key);
	if (r) {
		// remove spaces 
		if (r[2] === '4,ENCRYPTED') {
			if (!passphrase) throw new Error("Missing passphrase");
			if (r[4]) {
				var iv = new Buffer(r[4], "hex");
				passphrase = passphrase || "";
				var keyLength = 24;
				switch (r[3]) {
					case 'DES-EDE3-CBC':
						keyLength = 24;
						break;
					case 'DES-CBC':
						keyLength = 8;
						break;
					default:
						throw new Error("Wrong cipher... " + r[3]);
				}
				var ds = "";
				while (ds.length < keyLength) {
					var hash = crypto.createHash('md5');
					hash.update(ds, 'binary');
					hash.update(passphrase, 'binary');
					hash.update(iv);
					var dig = hash.digest();
					if (Buffer.isBuffer(dig)) {
						ds += dig.toString('binary');
					} else {
						ds += dig;
					}
				}
				var keypass = new Buffer(ds.substr(0, keyLength), 'binary');
				var cipher = crypto.createDecipheriv(r[3], keypass, iv);
			} else {
				throw new Error("Wrong private key format: missing salt");
			}
			var buffer = new Buffer(r[5].replace(/\s+/g, ""), "base64");
			try {
				var b1 = cipher.update(buffer, null, 'binary');
				var b2 = cipher.final('binary');
			} catch (e) {
				if (e instanceof TypeError) throw new Error("Wrong passphrase");
				throw new Error("Error in decryption " + e);
			}
			buffer = new Buffer(b1 + b2, 'binary');
			key = _expandToPem(buffer, r[1]);
		}
		return key;
	} else throw new Error("No valid private key format");
};

//Expands a buffer with DER encoded data to the corresponding PEM format. The name of the resulting 
//type (e. g. CERTIFICATE, RSA PRIVATE KEY) must be given in the second parameter 
function _expandToPem(buffer, name) {
	var result = "-----BEGIN " + name + "-----\n";
	var text = buffer.toString("base64");
	var i;
	for (i = 0; i < text.length - 64; i += 64) // insert line breaks in base64 
		result += text.substr(i, 64) + '\n';
	result += text.substr(i) + '\n-----END ' + name + '-----\n';
	return result;
}

function _pwdHash(user, password, salt) {
	return crypto.pbkdf2Sync(user + "\0" + password, new Buffer(salt, "hex"), 7, 20).toString("hex");
}


function _passphraseKey(salt, password) {
	return crypto.pbkdf2Sync(password, new Buffer(salt, "hex"), 60, 32);
}

exports.updateUserData = function(userdata, password, passphrase, ctx) {
	if (!passphrase) {
		// obtain passphrase from context
		passphrase = exports.decryptPassphrase(ctx.pass, ctx.salt, ctx.pwd);
	}
	// create salt
	var salt = userdata.salt = ("000000000" + (Math.floor(Math.random() * 0x100000000)).toString(16)).substr(-8);
	userdata.pwd = _pwdHash(userdata.login, password, salt);
	userdata.pass = exports.encryptPassphrase(passphrase, salt, password);
	return userdata;
};

exports.verifyPassword = function(userdata, password) {
	var hash = _pwdHash(userdata.login, password, userdata.salt);
	return (hash === userdata.pwd);
};

// encrypts passphrase (string) with given user salt (hex string) and user password (string). Returns base64 string
exports.encryptPassphrase = function(passphrase, salt, password) {
	var key = _passphraseKey(salt, password);
	var cipher = crypto.createCipher("aes256", key);
	// fill passphrase with random bytes
	var result = "";
	if (passphrase.length < 48) {
		var extra = new Buffer(48 - passphrase.length);
		for (var i = extra.length - 2; i >= 0; i--) {
			extra[i] = 1 + Math.floor(Math.random() * 255);
		}
		extra[extra.length - 1] = 0;
		result += cipher.update(extra, undefined, "base64");
	}
	result += cipher.update(passphrase, 'binary', "base64");
	result += cipher.final("base64");
	return result;
};

// decrypts passphrase from base64 string using user salt (hex string) and user password (string)
exports.decryptPassphrase = function(passphrase, salt, password) {
	var key = _passphraseKey(salt, password);
	var cipher = crypto.createDecipher("aes256", key);
	var result = cipher.update(passphrase, "base64", 'binary');
	result += cipher.final('binary');
	return result.substr(result.indexOf('\0') + 1);
};

exports.fileTest = function(_, path, fileType) {
	var content;
	try {
		content = fs.readFile(path, "utf8", _);
		// console.log(">>>>>>>>>> "+content+" "+path)
	} catch (e) {
		if (e.code !== "ENOENT")
			throw new Error(fileType + " file read error: " + e);
		else
			throw new Error(fileType + " file not found: " + path);
	}
	try {
		content = JSON.parse(content);
	} catch (e) {
		throw new Error(fileType + " file is not valid JSON: " + e);
	}
	if (exports.partnerId && content.partnerId !== exports.partnerId) {
		throw new Error(fileType + " file has wrong partner ID " + content.partnerId);
	};
	if (content.fileType !== fileType) {
		throw new Error(fileType + " file has wrong file type " + content.fileType);
	};
	if (!content.product || !content.policy) {
		throw new Error(fileType + " file has no product or policy");
	};
	// test validity of versions
	var r = /(\w+\/)?(\w+)[#\-]([\w\.]+)\-(\w+)\-([\w\.]+)(\-\w+)?\.json$/.exec(path);
	if (!r) throw new Error("Invalid file name " + path);
	if (content.product.code !== r[2]) throw new Error("Invalid product code " + content.product.code + ", expected " + r[2]);
	if (content.product.version !== r[3]) throw new Error("Invalid product version " + content.product.version + ", expected " + r[3]);
	if (content.policy.code !== r[4]) throw new Error("Invalid policy code " + content.policy.code + ", expected " + r[4]);
	if (content.policy.version !== r[5]) throw new Error("Invalid policy version " + content.policy.version + ", expected " + r[5]);
	if (fileType === "License") {
		if (!content.licensedTo) throw new Error(fileType + " file has no licensee data");
		if (content.licensedTo.reference + "/" !== r[1]) throw new Error("Invalid licensee reference " + content.licensedTo.reference + ", expected " + r[1]);

	}
	return content;
};

var allLocales;

exports.loadLocales = function() {
	var dir = __dirname + "/../../syracuse-core/lib/types/resources";
	var list = fs.readdirSync(dir);
	if (!allLocales) {
		allLocales = [];
		list.forEach(function(item) {
			if (item.substr(0, 5) === "date-") {
				var data = JSON.parse(fs.readFileSync(dir + "/" + item, "utf8"));
				allLocales[data.name.toLowerCase()] = data.nativeName;
			}
		});
	}
	return allLocales;
};