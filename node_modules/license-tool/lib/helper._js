"use strict";
// Global constants and initialisation
var locale = require("streamline-locale");
var localeHelpers = require('syracuse-core').localeHelpers;
var fs = require('streamline-fs');
var fspath = require('path');
var crypto = require('crypto');
var os = require('os');
var util = require('util');
var cr;

var ROOT = exports.ROOT = '.';
var DATA = exports.DATA = DATA = fspath.join(ROOT, "licensetool");
var GENERAL = exports.GENERAL = fspath.join(DATA, "general");

var PRIVATE = exports.PRIVATE = fspath.join(DATA, "private");
exports.POLICIES = fspath.join(DATA, "policies");
exports.LICENSES = fspath.join(DATA, "licenses");
exports.USER_FILE = fspath.join(GENERAL, "user.json");
exports.PARTNER_FILE = fspath.join(GENERAL, "partner.json");
var PUBLIC_KEY = fspath.join(GENERAL, "public.pem");
var PRIVATE_KEY = fspath.join(PRIVATE, "private.pem");
exports.REALM = "licensetool";
exports.CONFIG_FILE = fspath.join(GENERAL, "config.json");


var ALGORITHM = "RSA-SHA256"; // signature algorithm for licenses and policies

// private key clear/encrypted
var privateKey;
var privateKeyEnc;


exports.users; // JSON structure of all users

exports.partnerFile;
exports.prefix; // dictionary prefix

exports.cfg = {};

var policiesFuture; // future of search for used policies
var _usedPolicies; // object of usage count of policies

function _error(text) {
	console.error("Error in initialization: " + text);
	process.exit(1);
}


//initializations
function init(port, user, passwd, pubkey, privkey, passphrase) {
	var change = false;
	if (pubkey || privkey) { // public/private key given: total initialisation
		if (fs.existsSync(GENERAL)) _error("No initialization with existing data directory " + DATA);
		if (!user || !port) _error("No user or port specified");
		try {
			exports.publicKey = fs.readFileSync(pubkey, "utf8");
			privateKeyEnc = fs.readFileSync(privkey, "utf8");
		} catch (e) {
			_error(e.message);
		}
	} else { // otherwise read existing keys
		try {
			exports.publicKey = fs.readFileSync(PUBLIC_KEY, "utf8");
			privateKeyEnc = fs.readFileSync(PRIVATE_KEY, "utf8");
		} catch (e) {
			if (!fs.existsSync(GENERAL)) _error("Initialization necessary!");
			_error(e.message);
		}
	}
	// read user file
	try {
		exports.users = JSON.parse(fs.readFileSync(exports.USER_FILE, "utf8"));
	} catch (e) {
		console.log("New user file");
		exports.users = [];
	}
	// check for duplicate login names
	var unique = {};
	for (var i = exports.users.length - 1; i >= 0; i--) {
		var user0 = exports.users[i];
		if (user0.login in unique) {
			console.log("Ignore duplicate user " + user0.login);
			exports.users.splice(i, 1);
		} else unique[user0.login] = 1;
	}
	if (user) { // make admin user
		if (!passwd || !passphrase) {
			_error("Password or passphrase missing");
		}
		if (!/^\w+$/.test(user)) _error("User name can only contain A-Z, a-z, 0-9, _");
		if (!/^[ -~]+$/.test(passwd)) _error("User password must not contain diacritical characters");
		console.log("Test integrity of keys and passphrase");
		try {
			_testKeys(exports.publicKey, privateKeyEnc, passphrase);
		} catch (e) {
			_error(e.message);
		}
		user = user.toLowerCase();
		var userdata;
		if (!exports.users.some(function(item) { // maybe user already exists
			if (item.login === user) {
				userdata = item;
				return true;
			}
		})) {
			userdata = {
				login: user
			};
			exports.users.push(userdata);
		}
		if (!userdata.name) {
			userdata.name = user.charAt(0).toUpperCase() + user.substr(1); // capitalise the login
		}
		userdata.admin = true; // admin user
		exports.updateUserData(userdata, passwd, passphrase);
	} else {
		if (!exports.users.length) _error("No user available");
	}
	try {
		var config = JSON.parse(fs.readFileSync(exports.CONFIG_FILE, "utf8"));
		config.locales = config.locales || ["en-US"];
		config.locales = config.locales.map(_adjust);
		exports.cfg.port = config.port;
	} catch (e) {
		if (!port) _error("Cannot read configuration file " + e.stack);
		var config = {
			locales: ["en-US"]
		};
	}
	exports.updateLocales(config.locales, null, true);
	if (port) { // set port
		if (!/^\d+/.test(port)) _error("Incorrect port number " + port);
		exports.cfg.port = port;
	} else {
		if (!exports.cfg.port) _error("No port available");
	}
	try {
		exports.setPartnerFile(fs.readFileSync(exports.PARTNER_FILE, "utf8"));
	} catch (e) {
		if (e.code !== 'ENOENT') _error(e.message);
		console.log("No partner file");
	}
	// Changes to file system now, since all checks have been passed
	if (pubkey) {
		// generate directories
		[DATA, GENERAL, exports.POLICIES, exports.LICENSES, PRIVATE].forEach(function(directory) {
			if (!fs.existsSync(directory)) {
				console.log("Create " + directory);
				try {
					fs.mkdirSync(directory);
				} catch (e) {
					_error(e.message);
				}
			}
		});
		// write keys
		console.log("Write keys ...");
		try {
			fs.writeFileSync(PUBLIC_KEY, exports.publicKey, "utf8");
			fs.writeFileSync(PRIVATE_KEY, privateKeyEnc, "utf8");
		} catch (e) {
			_error(e.message);
		}
	}
	if (user) {
		// write new user file
		console.log("Write user file ...");
		try {
			fs.writeFileSync(exports.USER_FILE, JSON.stringify(exports.users), "utf8");
		} catch (e) {
			_error(e.message);
		}
	}
	if (port) {
		console.log("Write config file ...");
		try {
			fs.writeFileSync(exports.CONFIG_FILE, JSON.stringify(exports.cfg, null, "\t"), "utf8");
		} catch (e) {
			_error(e.message);
		}
	}
	// 
	if (!pubkey && !user && !port) policiesFuture = _findUsedPolicies(!_);
}
exports.init = init;

exports.localeObject;

// set and test partner file
exports.setPartnerFile = function(content) {
	var partnerFile = JSON.parse(content);
	// test public key
	var pubKey = exports.publicKey.replace(/-----[A-Z ]+-----|\r|\n/g, "");
	if (pubKey !== partnerFile.publicKey) throw new Error(locale.format(module, "notFitPartner"));
	exports.partnerFile = partnerFile;
	var range = partnerFile.codificationRange || {};
	exports.prefix = range.dictionaryPrefix || range.dictionnaryPrefix;
	if (exports.prefix) {
		exports.prefix += ",Y";
	} else exports.prefix = "Y";
	//adjust pattern for badge code
	try {
		require('../entities/policies').$properties.badges.$item.code.$pattern = exports._makePattern(exports.prefix);
		console.log("Badge prefix pattern applied: " + exports.prefix);
	} catch (e) {
		console.log("Error during application of badge pattern" + e);
	}

};

exports._makePattern = function(prefix) {
	var pattern = prefix.replace(/[^A-Z0-9,\-]/, "").replace(/,/g, "|");
	pattern = pattern.replace(/([A-Z0-9]+)([A-Z0-9])-\1([A-Z0-9])/g, "$1[$2-$3]");
	return "^(?:" + pattern + ")\\w*$";
};

exports.updateLocales = function(localeArray, diagnoses, noFile) {
	var newLocales = [];
	var tempLoc = {};
	exports.cfg.locales = exports.cfg.locales || [];
	if (!Array.isArray(localeArray)) localeArray = [];
	var changed = (exports.cfg.locales.length !== localeArray.length);
	for (var i = 0; i < localeArray.length; i++) {
		var item = localeArray[i];
		var loc = item.localeCode ? item.localeCode.$uuid : item;
		if (!loc) {
			if (diagnoses) exports.addError(locale.format(module, "noCode"), diagnoses);
		} else {
			if (loc in tempLoc) {
				// duplicate code
				if (diagnoses) diagnoses.push({
					$severity: "warning",
					$message: locale.format(module, "ignoreDuplicate", loc)
				});
			} else {
				if (loc !== exports.cfg.locales[i]) changed = true;
				tempLoc[loc] = 1;
				newLocales.push(loc);
			}
		}

	}

	if (changed) {
		if (exports.cfg.locales) {
			exports.cfg.locales = newLocales;
			exports.localeObject = tempLoc;
			if (!noFile) {
				try {

					fs.writeFileSync(exports.CONFIG_FILE, JSON.stringify(exports.cfg, null, "\t"), "utf8");
				} catch (e) {
					if (diagnoses) exports.addError(locale.format(module, "internalError", e), diagnoses);
				}
				if (diagnoses) diagnoses.push({
					$severity: "info",
					$message: locale.format(module, "updated")
				});
			}
		} else exports.cfg.locales = newLocales;
	}
	if (!exports.cfg.locales) exports.cfg.locales = [];
};



// find reference count of policies: how many licenses reference one policy file?
function _findUsedPolicies(_) {
	var customers = fs.readdir(exports.LICENSES, _);
	var policies = {};
	customers.forEach_(_, function(_, customer) {
		try {
			var lics = fs.readdir(exports.LICENSES + "/" + customer, _);
			lics.forEach(function(p) {
				if (p.indexOf(".json") === p.length - 5) {
					var policyName = p.substr(0, p.lastIndexOf("-"));
					if (policyName in policies) {
						policies[policyName]++;
					} else {
						policies[policyName] = 1;
					}
				}
			});
		} catch (e) {
			// ignore
			console.log(e.stack);
		}
	});
	_usedPolicies = policies;
	policiesFuture = undefined;
	return policies;
}

// if `add` parameter is positive or negative, add/remove to/from usage count for that policy.
// if `add` parameter is not set, return whether policy name has positive usage count
exports.usedPolicies = function(_, name, add) {
	if (!_usedPolicies) {
		if (!policiesFuture) throw new Error(locale.format(module, "noPolicies"));
		policiesFuture(_);
	}
	if (add) {
		if (add > 0) {
			if (name in _usedPolicies) _usedPolicies[name] += add;
			else _usedPolicies[name] = add;
		} else {
			if (_usedPolicies[name] > -add) _usedPolicies[name] -= -add;
			else delete _usedPolicies[name];
		}
	} else {
		return (_usedPolicies[name] || 0);
	}
};

// does not wait until policies are available
exports.usedPoliciesUnsafe = function(name) {
	if (_usedPolicies) return _usedPolicies[name];
	else return 0;
};

exports.setUsedPolicies = function(_, policies) {
	if (!_usedPolicies) {
		if (!policiesFuture) throw new Error(locale.format(module, "noPolicies"));
		policiesFuture(_);
	}
	_usedPolicies = policies;
};

// test integrity of public and private keys
function _testKeys(publicKey, privateKeyEnc, passphrase) {
	privateKey = _stripEncryption(privateKeyEnc, passphrase);
	// 	sign and verify
	var signed = _sign("ABCDE");
	if (!_verify("ABCDE", signed))
		throw new Error(locale.format(module, "notFit"));
}

// digital signature
function _sign(content) {
	var signRes = crypto.createSign(ALGORITHM);
	signRes.update(content, "utf8");
	return signRes.sign(privateKey, "base64");
}

// verify digital signature
function _verify(content, signature) {
	var verifier = crypto.createVerify(ALGORITHM);
	verifier.update(new Buffer(content, 'utf8'));
	return verifier.verify(exports.publicKey, signature, 'base64');
}

// sign a license or policy
function signLicense(jsonLic, ctx) {
	if (!privateKey) {
		var passphrase = exports.decryptPassphrase(ctx.pass, ctx.salt, ctx.pwd);
		_testKeys(exports.publicKey, privateKeyEnc, passphrase);
		privateKeyEnc = undefined;
	}
	jsonLic.signature = jsonLic.signatureText;
	var lic = JSON.stringify(jsonLic, null, "\t");
	var normalLic = _normalize(lic);
	var signature = _sign(normalLic);
	lic = lic.replace(/"signature":\s*".*?"/, '"signature": "' + signature + '"');
	return lic;
}
exports.signLicense = signLicense;

// normalize license content: remove all whitespace outside quoted areas
function _normalize(c) {
	c = c.replace(/[\s\r\n]+/g, " ");
	c = c.replace(/(\W) /g, "$1");
	c = c.replace(/ (\W)/g, "$1");
	return c;
}



/// ## Strip the encryption from a private key
///    `stripEncryption(key, passphrase, test)`
///   Arguments are a private key in PEM format and the passphrase. The output will be the private key without encryption in PEM format.
///   When the private key has not been encrypted, the passphrase will be ignored and the private key will be returned unchanged.
///
function _stripEncryption(key, passphrase) {
	var r = /^-----BEGIN ((?:RSA )?PRIVATE KEY)-----\s+(?:Proc-Type: ([\w,]+)\s+DEK-Info: ([\-\w]+)(?:,(\w+))?)?(?:([\w\=\/\+\s]+))/.exec(key);
	if (r) {
		// remove spaces 
		if (r[2] === '4,ENCRYPTED') {
			if (!passphrase) throw new Error("Missing passphrase");
			if (r[4]) {
				var iv = new Buffer(r[4], "hex");
				var keyLength = 24;
				switch (r[3]) {
					case 'DES-EDE3-CBC':
						keyLength = 24;
						break;
					case 'DES-CBC':
						keyLength = 8;
						break;
					default:
						throw new Error("Wrong cipher... " + r[3]);
				}
				var ds = "";
				while (ds.length < keyLength) {
					var hash = crypto.createHash('md5');
					hash.update(ds, 'binary');
					hash.update(passphrase, 'binary');
					hash.update(iv);
					var dig = hash.digest();
					if (Buffer.isBuffer(dig)) {
						ds += dig.toString('binary');
					} else {
						ds += dig;
					}
				}
				var keypass = new Buffer(ds.substr(0, keyLength), 'binary');
				var cipher = crypto.createDecipheriv(r[3], keypass, iv);
			} else {
				throw new Error("Wrong private key format: missing salt");
			}
			var buffer = new Buffer(r[5].replace(/\s+/g, ""), "base64");
			try {
				var b1 = cipher.update(buffer, null, 'binary');
				var b2 = cipher.final('binary');
			} catch (e) {
				if (e instanceof TypeError) throw new Error("Wrong passphrase");
				throw new Error("Error in decryption " + e);
			}
			buffer = new Buffer(b1 + b2, 'binary');
			key = _expandToPem(buffer, r[1]);
		}
		return key;
	} else throw new Error("No valid private key format");
};

//Expands a buffer with DER encoded data to the corresponding PEM format. The name of the resulting 
//type (e. g. CERTIFICATE, RSA PRIVATE KEY) must be given in the second parameter 
function _expandToPem(buffer, name) {
	var result = "-----BEGIN " + name + "-----\n";
	var text = buffer.toString("base64");
	var i;
	for (i = 0; i < text.length - 64; i += 64) // insert line breaks in base64 
		result += text.substr(i, 64) + '\n';
	result += text.substr(i) + '\n-----END ' + name + '-----\n';
	return result;
}

function _pwdHash(user, password, salt) {
	return crypto.pbkdf2Sync(user + "\0" + password, new Buffer(salt, "hex"), 7, 20).toString("hex");
}


function _passphraseKey(salt, password) {
	return crypto.pbkdf2Sync(password, new Buffer(salt, "hex"), 60, 32);
}

exports.updateUserData = function(userdata, password, passphrase, ctx) {
	if (!passphrase) {
		// obtain passphrase from context
		passphrase = exports.decryptPassphrase(ctx.pass, ctx.salt, ctx.pwd);
	}
	// create salt
	var salt = userdata.salt = ("000000000" + (Math.floor(Math.random() * 0x100000000)).toString(16)).substr(-8);
	userdata.pwd = _pwdHash(userdata.login, password, salt);
	userdata.pass = exports.encryptPassphrase(passphrase, salt, password);
	return userdata;
};

exports.verifyPassword = function(userdata, password) {
	var hash = _pwdHash(userdata.login, password, userdata.salt);
	return (hash === userdata.pwd);
};

// add an error message to diagnoses or create diagnoses
exports.addError = function(message, diagnoses, detailEntity, detailKey) {
	var diagnose = {
		$severity: "error",
		$message: message
	};
	if (detailEntity) {
		diagnose.$links = {
			$details: {
				$title: locale.format(module, "details"),
				$url: "/data/" + detailEntity + "/" + detailKey + "?representation=" + detailEntity + ".$details",
			},
		};
	}
	if (diagnoses) diagnoses.push(diagnose);
	else diagnoses = [diagnose];
	return diagnoses;
};


// encrypts passphrase (string) with given user salt (hex string) and user password (string). Returns base64 string
exports.encryptPassphrase = function(passphrase, salt, password) {
	var key = _passphraseKey(salt, password);
	var cipher = crypto.createCipher("aes256", key);
	// fill passphrase with random bytes
	var result = "";
	if (passphrase.length < 48) {
		var extra = new Buffer(48 - passphrase.length);
		for (var i = extra.length - 2; i >= 0; i--) {
			extra[i] = 1 + Math.floor(Math.random() * 255);
		}
		extra[extra.length - 1] = 0;
		result += cipher.update(extra, undefined, "base64");
	}
	result += cipher.update(passphrase, 'binary', "base64");
	result += cipher.final("base64");
	return result;
};

// decrypts passphrase from base64 string using user salt (hex string) and user password (string)
exports.decryptPassphrase = function(passphrase, salt, password) {
	var key = _passphraseKey(salt, password);
	var cipher = crypto.createDecipher("aes256", key);
	var result = cipher.update(passphrase, "base64", 'binary');
	result += cipher.final('binary');
	return result.substr(result.indexOf('\0') + 1);
};

// basic tests when reading license and policy files
exports.fileTest = function(_, path, fileType) {
	var content;
	try {
		content = fs.readFile(path, "utf8", _);
	} catch (e) {
		if (e.code !== "ENOENT")
			throw new Error(fileType === "License" ? +locale.format(module, "licRead", e) : locale.format(module, "polRead", e));
		else
			throw new Error(fileType === "License" ? +locale.format(module, "licNotFound", path) : locale.format(module, "polNotFound", path));
	}
	try {
		content = JSON.parse(content);
	} catch (e) {
		throw new Error(fileType === "License" ? locale.format(module, "licJson", e) : locale.format(module, "polJson", e));
	}
	if (exports.partnerFile && content.partnerId !== exports.partnerFile.partnerId) {
		throw new Error(fileType === "License" ? locale.format(module, "licWrongPartner", content.partnerId) : locale.format(module, "polWrongPartner", content.partnerId));
	};
	if (content.fileType !== fileType) {
		throw new Error(fileType === "License" ? locale.format(module, "licWrongType", content.fileType) : locale.format(module, "polWrongType", content.fileType));
	};
	if (!content.product || !content.policy) {
		throw new Error(fileType === "License" ? locale.format(module, "licNoProd") : locale.format(module, "polNoProd"));
	};
	// test validity of versions
	var r = /(\w+\/)?(\w+)[#\-]([\w\.]+)\-(\w+)\-([\w\.]+)(\-\w+)?\.json$/.exec(path);
	if (!r) throw new Error(locale.format(module, "invalidName", path));
	if (content.product.code !== r[2]) throw new Error(locale.format(module, "invalidProduct", content.product.code, r[2]));
	if (content.product.version !== r[3]) throw new Error(locale.format(module, "invalidProductVer", content.product.version, r[3]));
	if (content.policy.code !== r[4]) throw new Error(locale.format(module, "invalidPolicy", content.policy.code, r[4]));
	if (content.policy.version !== r[5]) throw new Error(locale.format(module, "invalidPolicyVer", content.policy.version, r[5]));
	if (fileType === "License") {
		if (!content.licensedTo) throw new Error(locale.format(module, "noLicensee"));
		if (content.licensedTo.reference + "/" !== r[1]) throw new Error(locale.format(module, "invalidReference", content.licensedTo.reference, r[1]));
	}
	return content;
};

var allLocales;

// make correct casing of locale name
function _adjust(loc) {
	var index = loc.lastIndexOf("-");
	return loc.substr(0, index + 1).toLowerCase() + loc.substr(index + 1).toUpperCase();
}

exports.loadLocales = function() {
	return allLocales = allLocales || localeHelpers.loadAllLocalesSync().reduce(function(r, loc) {
		r[_adjust(loc.name)] = loc.nativeName;
		return r;
	}, {});
};