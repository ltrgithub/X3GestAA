"use strict";

var fspath = require('path');
var ez = require('ez-streams');
var coreHelpers = require('syracuse-core/lib/helpers');
var locale = require('syracuse-core/lib/locale');
var globals = require('streamline/lib/globals');
require('syracuse-core/lib/localeWrapper'); // for fast mode
var fs = require('streamline-fs');
var fspath = require('path');
var parseUrl = require('url').parse;
var util = require('util');
var helper = require('./helper');
var tracer;

// reference to locales table (will be inserted for each 'localeCode' field)
var LOC_PROTO = {
	$title: "Locale",
	$isMandatory: true,
	$displayLength: 25,
	$type: "application/x-reference",
	$item: {
		$url: "/data/locales/{$uuid}?representation=locales.$thumb",
		$shortUrl: "/data/locales/{$uuid}",
		$value: "{title} [{code}]",
		$key: "{$uuid}",
		$description: "Locale",
		$properties: {
			code: {
				$type: "application/x-string",
				$displayLength: 20,
			},
			title: {
				$displayLength: 20,
				$type: "application/x-string"
			},
		},
		$prototype: "/page?representation=locales.$thumb",
		$links: {
			$lookup: {
				$type: "application/json",
				$title: "Select the locale",
				$url: "/data/locales?representation=locales.$lookup",
			},
			$details: {
				$type: "application/json",
				$url: "/data/locales/{$uuid}?representation=locales.$details",
			},

		}
	}

};


function _usage() {
	console.log("Usage: Normal start: node index");
	console.log("Set port: node node_modules/license-tool <Port>");
	console.log("Set admin user: node node_modules/license-tool <adminuser> <adminpassword> <passphrase>");
	console.log("Total initialisation: node node_modules/license-tool <port> <adminuser> <adminpassword> <public key> <private key> <passphrase>");
}

switch (process.argv.length) {
	case 2:
		helper.init();
		break;
	case 3:
		if (process.argv[2] === "--help") {
			_usage();
		} else helper.init(process.argv[2]); // change port
		process.exit(0);
		break;
	case 5:
		// set user: node
		helper.init(null, process.argv[2], process.argv[3], null, null, process.argv[4]);
		process.exit(0);
		break;
	case 8:
		// installation: node main <port> <adminuser> <adminpassword> <public key file> <private key file> <passphrase>
		helper.init(process.argv[2], process.argv[3], process.argv[4], process.argv[5], process.argv[6], process.argv[7]);
		process.exit(0);
		break;
	default:
		_usage();
		process.exit(0);
}

var staticDispatcher = require('streamline-static/lib/staticProvider').staticProvider({
	root: __dirname + "/../..",
	maxAge: 3600 * 1000
});

var requireDispatcher0 = require('streamline-require/lib/server/require').dispatcher({
	getResources: locale.getResourcesHook,
	whiteList: [
		/^.*$/
	],
});

var requireDispatcher = function(_, request, response) {
	requireDispatcher0(_, request, response);
	return true;
};

function notFound(_, request, response) {
	try {
		response.writeHead(404, {});
		if (request.headers && request.headers.accept && request.headers.accept.indexOf("application/json") >= 0) {
			response.end(JSON.stringify({
				$diagnoses: [{
					$severity: "error",
					$message: locale.format(module, "notFound", request.url)
				}]
			}));
		} else
			response.end(locale.format(module, "notFound", request.url));
	} catch (e) {
		console.log("Error during 'notFound' " + e.stack);
	}
	return true;
}

function jsonReply(_, response, status, headers, data) {
	headers = headers || {};
	headers['content-type'] = 'application/json';
	/* if (status < 300 && data.$diagnoses && data.$diagnoses.some(function(diag) {
		return diag.$severity === "error";
	})) {
		status = 412;
	}*/
	data = new Buffer(typeof data === 'string' ? data : JSON.stringify(data), "utf8");
	headers['content-length'] = data.length;
	headers.expires = (new Date()).toUTCString(); // do not cache this reply!
	response.writeHead(status, headers);
	response.end(data);
	return true;
}

var actionReplies = {};

var actionRoutes = {
	'user-profile': function(_, request, response) {
		jsonReply(_, response, 200, null, {
			user: {
				firstName: "",
				lastName: globals.context.name || "",
			},
			$links: {
				$bookmarks: {}
			}
		});
	},
};

function actionDispatcher(_, request, response) {
	var action = request.parsedUrl.segments[2];
	var route = actionRoutes[action] || notFound;
	route(_, request, response);
	return true;
}

var PAGES = {
	empty: {
		$title: "EMPTY PAGE",
		$properties: {},
	},
	home: {
		$title: "Welcome",
		$properties: {},

		$links: {
			policies: {
				$title: "Policies",
				$url: "/data/policies?representation=policies.$query",

			},
			licenses: {
				$title: "All Licenses",
				$url: "/data/licenses?representation=licenses.$query",

			},
			lic2: {
				$title: "Licenses for customer",
				$url: "/data/licenses?representation=licenses.$query&customer={customer}",
				$method: "GET",
				$parameters: {
					$properties: {
						"customer": {
							$title: "Licensee reference",
							$type: "application/x-string",
							$value: ""
						}
					},
				}

			},
			general: {
				$title: "General",
				$url: "/data/general/$workingCopies?representation=general.$edit",
				$method: "POST"
			},
			users: {
				$title: "Users",
				$url: "/data/users?representation=users.$query"
			},
		}
	}
};

var excludes = ["$save", "$init", "$list", "$load", "$delete", "$modes", "$referenceUpdate"];

function _clone(obj) {
	if (!obj || typeof obj !== 'object') return obj;
	if (Array.isArray(obj)) return obj.map(_clone);
	var result = {};
	Object.keys(obj).forEach(function(key) {
		// do not copy excluded functions
		if (excludes.indexOf(key) >= 0) return;
		if (key.substr(-1) === "_") { // localized properties with standard locales
			var localeObject = helper.loadLocales();
			helper.cfg.locales.forEach(function(loc) {
				var val = _clone(obj[key]);
				if (val.$title) val.$title = localeObject[loc] || loc;
				if (loc === "en-US") val.$isMandatory = true;
				result[key + loc] = val;
			});
		} else result[key] = _clone(obj[key]);
	});
	return result;
}


// returns original required entity or a copy (with some entries removed)
function getEntity(name, clone) {
	var entity = require('../entities/' + name);
	if (clone) {
		entity = _clone(entity);
	}
	return entity;
}


// clears no-query properties and removes $links. Returns a copy of the entity
function _queryEntity(name, clearLinks) {
	var entity = getEntity(name, true);
	// delete objects which should not be in query
	var props = entity.$properties;
	for (var a in props) {
		var val = props[a];
		if (typeof val === 'object') {
			if (val.$noQuery || val.$type === "application/x-array") {
				delete props[a];
			};
			if (clearLinks) delete val.$links;
			if (val.$adminMode) {
				if (globals.context.admin != (val.$adminMode > 0)) {
					delete props[a];
				} else delete val.$adminMode;
			}
		}
	}
	return entity;
}





function _handleArrays(val, capabilities) {
	if (val.$type === "application/x-array") {
		// this is a hack - but a really good implementation would be less efficient
		if (!val.$capabilities || val.$capabilities.indexOf(capabilities) >= 0) val.$capabilities = capabilities;
		// for locales
		for (var b in val.$item) {
			if (b === "localeCode") val.$item[b] = LOC_PROTO;
			else _handleArrays(val.$item[b], capabilities);
		}
		val.$item = {
			$properties: val.$item,
			$type: "application/json",
		};
	}
}

var protoBuilders = {
	$page: function(_, name) {
		return PAGES[name];
	},
	$landing: function(_, name) {
		return PAGES[name];
	},
	$lookup: function(_, name) {
		var entity = _queryEntity(name, true);
		var proto = {
			$title: entity.$title,
			$properties: {
				$resources: {
					$type: 'application/x-array',
					$item: entity,
				}
			},
		};
		return proto;
	},
	$query: function(_, name) {
		var entity = _queryEntity(name);
		entity.$links = _addStdLinks(name, "details,delete,duplicate,edit,extra");
		var proto = {
			$title: entity.$title,
			$properties: {
				$resources: {
					$type: 'application/x-array',
					$item: entity,
				}
			},
		};
		proto.$links = _addStdLinks(name, "create");
		return proto;
	},

	$thumb: function queryfunction3(_, name) {
		return _queryEntity(name, true);
	},
	$details: function(_, name) {
		var entity = getEntity(name, true);
		var props = entity.$properties;
		for (var a in props) {
			var val = props[a];
			if (typeof val === 'object') {
				if (a === "localeCode") {
					props[a] = LOC_PROTO;
				} else {
					if (val.$adminMode) {
						if (globals.context.admin != (val.$adminMode > 0)) {
							delete props[a];
						} else delete val.$adminMode;
					}
					if (val.$noQuery) delete val.$noQuery;
					_handleArrays(val, "sort");
				}
			}
		}
		entity.$links = _addStdLinks(name, "edit,query,duplicate,delete,extra");
		return entity;
	},

	$edit: function(_, name) {
		var entity = getEntity(name, true);
		var props = entity.$properties;
		for (var a in props) {
			var val = props[a];
			if (typeof val === 'object') {
				if (a === "localeCode") {
					props[a] = LOC_PROTO;
				} else if (val.$adminMode) {
					if (globals.context.admin != (val.$adminMode > 0)) {
						delete props[a];
					} else delete val.$adminMode;
				}
				if (val.$noQuery) delete val.$noQuery;
				_handleArrays(val, "sort,filter,append,delete");
			}
		}
		var modes = getEntity(name, false).$modes;
		if (modes && modes.indexOf("extra*") >= 0) {
			entity.$links = {
				$extra: entity.$links.$extra
			};
		} else entity.$links = {};
		var disable = !(modes && modes.indexOf("svb") >= 0);
		entity.$actions = entity.$actions || {};
		entity.$actions.$save = {
			$title: locale.format(module, "save"),
			$isDisabled: disable
		};
		return entity;
	},
};

// Adds links for basic operations (edit, details, delete, list, duplicate). They will be added when $modes of
// the entity is empty or if it contains the corresponding string
// name: name of entity
// links: Links object to add properties will be created if necessary; this will be returned
// mode: list of links to add 
function _addStdLinks(name, mode) {
	var links = {};
	var ent = getEntity(name, false);
	var origLinks = ent.$links || {};
	var modes = ent.$modes;
	if (!globals.context.admin && ent.$modes) modes = modes.replace(/[a-z]+\?/g, "-");
	if (!helper.partnerFile && ent.$modes) modes = modes.replace(/[a-z]+\!/g, "-");

	function handleEvent(event, content) {
		var d_event = "$" + event;
		if (mode.indexOf(event) >= 0 && (!modes || modes.indexOf(event) >= 0)) {
			links[d_event] = origLinks[d_event] || content;
			if (d_event + "1" in origLinks) links[d_event + "1"] = origLinks[d_event + "1"];
		}
	}

	handleEvent("create", {
		$title: locale.format(module, "create"),
		$method: "POST",
		$url: "/data/" + name + "/$workingCopies?representation=" + name + ".$edit",
	});
	handleEvent("query", {
		$title: locale.format(module, "list"),
		$url: "/data/" + name + "?representation=" + name + ".$query",
	});
	handleEvent("details", {
		$title: locale.format(module, "details"),
		$url: "/data/" + name + "/{$uuid}?representation=" + name + ".$details",
	});
	handleEvent("delete", {
		$title: locale.format(module, "delete"),
		$method: "DELETE",
		$confirm: "The entry {$uuid} of " + name + " will be deleted. OK?",
		$url: "/data/" + name + "/{$uuid}"
	});
	handleEvent("edit", {
		$title: locale.format(module, "edit"),
		$method: "POST",
		$url: "/data/" + name + "/$workingCopies/{$uuid}?representation=" + name + ".$edit",
	});
	handleEvent("duplicate", {
		$title: locale.format(module, "duplicate"),
		$method: "POST",
		$url: "/data/" + name + "/$workingCopies/{$uuid}?representation=" + name + ".$edit&duplicate=1",
	});
	if (mode.indexOf("extra") >= 0 && (!modes || modes.indexOf("extra") >= 0) && origLinks.$extra) links.$extra = origLinks.$extra;
	return links;

}

function pageDispatcher(_, request, response) {
	var parsed = request.parsedUrl;
	if (!parsed.query.url) return notFound(_, request, response);
	parsed = parseUrl(parsed.query.url, true);
	if (!(parsed.query && parsed.query.representation)) return jsonReply(_, response, 200, null, {
		$prototype: PAGES.empty
	});
	var pair = parsed.query.representation.split('.');
	var builder = protoBuilders[pair[1]];
	if (!builder) return notFound(_, request, response);
	return jsonReply(_, response, 200, null, {
		$prototype: builder(_, pair[0])
	});
}

// temporary store for working copies
var workingCopies = {};


var workingCopyActions = {
	$save: function(_, entity, wc, result) {
		result.$diagnoses = result.$diagnoses || [];
		var ent = getEntity(entity);
		var key;
		if (ent.$save) {
			key = ent.$save(_, wc, result.$diagnoses);
			if (key && !result.$diagnoses.some(function(diag) {
				return diag.$severity === "error";
			})) {
				if (wc.$url) wc.$url = wc.$url.replace(wc.$uuid, key);
				wc.$uuid = key;
			}
		} else {
			throw new Error("No $save function");
		};
		if (!result.$diagnoses || !result.$diagnoses.some(function(item) {
			return item.$severity === "error";
		})) {
			result.$actions = result.$actions || {};
			// result.$actions.$save = result.$actions.$save || {};
			result.$actions.$save = {
				$isRequested: false,
				$isDisabled: true, // avoid double saving

				$links: {
					$redirect: {
						$title: locale.format(module, "details"),
						$type: "application/json;vnd.sage=syracuse",
						$url: "/data/" + entity + "/" + wc.$uuid + "?representation=" + entity + ".$details",
					}
				},
			};
		} else {
			result.$actions = result.$actions || {};
			result.$actions.$save = result.$actions.$save || {};
			result.$actions.$save.$isDisabled = true;
		}
	},
	$extra: function(_, entity, wc, result) {
		result.$diagnoses = result.$diagnoses || [];
		var ent = getEntity(entity);
		if (ent.$extra) {
			ent.$extra(_, wc, result);
		} else throw new Error("No $extra action in " + entity);
	}
};

function _transfer(dest, src, item, inner) {
	var data = src[item];
	var changed = false;
	if (Array.isArray(data)) {
		var destData = dest[item];
		if (!destData) dest[item] = destData = [];
		if (data.length > 0 && "$index" in data[0]) {
			// incremental changes
			data.forEach(function(part) {
				// find UUID
				var index = destData.length;
				var dest1;
				while (--index >= 0) {
					dest1 = destData[index];
					if (part.$uuid === dest1.$uuid) break;
				}
				if (index < 0) {
					if (!part.$isDeleted) {
						destData.push(part);
						changed = true;
					}
				} else {
					if (part.$isDeleted) {
						destData.splice(index, 1);
						changed = true;
					} else {
						Object.keys(part).forEach(function(p) {
							if (p !== '$index' && _transfer(dest1, part, p, true)) changed = true;
						});
					}
				}
			});
		} else {
			// total array: 
			var newDestData = dest[item] = [];
			data.forEach(function(part) {
				var uuid = part.$uuid;
				var target;
				if (!destData.some(function(item0) {
					if (item0.$uuid === uuid) {
						target = item0;
						return true;
					}
				})) {
					target = {};
				};
				newDestData.push(target);
				Object.keys(part).forEach(function(p) {
					if (p !== '$index' && _transfer(target, part, p, true)) changed = true;
				});
			});
		}
	} else {
		if ((inner || typeof(data) === "string") && dest[item] !== data) {
			changed = true;
		}
		if (item === 'localeCode') { // special treatment: fill in code and title!
			var destData = dest[item];
			if (!destData) destData = dest[item] = data;
			if (!destData.code || destData.$uuid !== data.$uuid) {
				destData.$uuid = destData.code = data.$uuid;
				destData.title = helper.loadLocales()[data.$uuid];
				changed = true;
			}
		} else {
			dest[item] = data;
		}
	}
	return changed;
}


function updateWorkingCopy(_, entity, wc, data) {
	var ent = getEntity(entity, false);
	delete wc.$actions;
	var result;
	var props = ent.$properties;
	var changed = false;
	Object.keys(data).forEach_(_, function(_, key) {
		if (key !== "$actions" && key !== "$url") {
			var prop = props[key];
			if (!prop) { // localized property?
				var index = key.indexOf("_");
				if (index >= 0) {
					prop = props[key.substr(0, index + 1)];
				}
			}
			if (prop && !prop.$isReadOnly) {
				if (prop.$type === "application/x-reference" && ent.$referenceUpdate && (!wc[key] || wc[key].$uuid !== data[key].$uuid)) {
					result = ent.$referenceUpdate(_, wc, data[key]);
				}
				if (_transfer(wc, data, key)) changed = true;
			}
		}
	});
	result = result || {};
	if (data.$actions) Object.keys(data.$actions).forEach_(_, function(_, key) {
		var action = data.$actions[key];
		if (!workingCopyActions[key]) throw new Error("bad action: " + key);
		workingCopyActions[key](_, entity, wc, result);
	});
	if (changed && !result.$uuid && !result.$diagnoses) {
		// enable save only when all fields are set
		var missing = false;
		if (!Object.keys(props).some(function(b) {
			if (props[b].$isMandatory && !wc[b]) return true;
		})) {
			wc.$actions = {
				$save: {
					$isDisabled: false
				}
			};
		}
		return wc;
	} else return result;
}


function workingCopyDispatcher(_, request, response, entity) {
	var uuid = request.parsedUrl.segments[4];
	var wc;
	switch (request.method) {
		case 'POST':
			// create a new working copy
			if (uuid) {
				// editing an existing resource
				var ent = getEntity(entity);
				if (ent.$load) {
					try {
						wc = ent.$load(_, uuid, request.parsedUrl.query, true); // load for editing					
					} catch (e) {
						tracer && tracer("Working copy load error " + uuid + " " + e.stack);
						wc = {
							$diagnoses: helper.addError(locale.format(module, "internalLoad", e))
						};
					}
				} else {
					throw new Error("No $load");
				}
				if (!wc) return notFound(_, request, response);
				if (!wc.$diagnoses) {
					if (request.parsedUrl.query.duplicate) {
						uuid = coreHelpers.uuid.generate();
					}
					wc.$uuid = uuid;
				}
			} else {
				// creating a new resource
				var ent = getEntity(entity);
				wc = {};
				if (ent.$init) {
					try {
						ent.$init(_, wc, request.parsedUrl.query);
					} catch (e) {
						console.error("Init load error " + e.stack);
						wc = {
							$diagnoses: helper.addError(locale.format(module, "internalInit", e))
						};
					}
				}
				if (!wc.$diagnoses) {
					uuid = coreHelpers.uuid.generate();
					wc.$uuid = uuid;
				}
			}
			// set $url, which will be used for following reuests
			wc.$url = "/data/" + entity + "/$workingCopies/" + uuid + "?representation=" + entity + ".$edit";
			// track working copy in global hash table
			workingCopies[uuid] = wc;
			return jsonReply(_, response, 201, {
				location: wc.$url,
			}, wc);
		case 'GET':
			wc = workingCopies[uuid];
			if (!wc) return notFound(_, request, response);
			return jsonReply(_, response, 200, null, wc);
		case 'PUT':
			// file upload?
			var prop = request.parsedUrl.segments[5];
			if (prop) {
				var posted = request.readAll(_);
				wc = workingCopies[uuid];
				if (!wc) return notFound(_, request, response);
				wc["$_$_" + prop] = posted;
				response.writeHead(200, {});
				response.end();
				return true;
			} else {
				var posted = request.readAll(_, 'utf8');
				wc = workingCopies[uuid];
				if (!wc) return notFound(_, request, response);
				var data = JSON.parse(posted);
				var result = updateWorkingCopy(_, entity, wc, data);
			}
			return jsonReply(_, response, 200, null, result);
		case 'DELETE':
			if (!workingCopies[uuid]) return notFound(_, request, response);
			var prop = request.parsedUrl.segments[5];
			if (prop) {
				wc = workingCopies[uuid];
				delete wc["$_$_" + prop];
			} else
				delete workingCopies[uuid];
			return jsonReply(_, response, 200, null, {});
		default:
			throw new Error("bad method: " + request.method);
	}
}

function dataDispatcher(_, request, response) {
	var segments = request.parsedUrl.segments;
	var entity = segments[2];
	var key = segments[3];
	if (!entity) return notFound(_, request, response);
	var ent = getEntity(entity);
	try {
		if (key === '$workingCopies') {
			workingCopyDispatcher(_, request, response, entity);
		} else if (key) {
			if (request.method === "DELETE") {
				var diags = [];
				if (ent.$delete) res = ent.$delete(_, key, diags);
				else {
					throw new Error("No $delete function");
				}
				if (!diags.length) {
					diags.push({
						"$severity": "info",
						"$message": locale.format(module, "deletedR")
					});
				}
				return jsonReply(_, response, 200, null, {
					$diagnoses: diags
				});
			} else if (segments[4] === "$extra") {
				if (!ent.$extra) {
					jsonReply(_, response, 200, null, {
						$diagnoses: helper.addError("No extra action for " + entity)
					});
				} else {
					var result = ent.$extra(_, request, response);
					jsonReply(_, response, 200, null, result);
				}
			} else {
				if (ent.$load) {
					var res = ent.$load(_, key, request.parsedUrl.query);
				} else {
					throw new Error("No $load");
				}
				res.$uuid = key;
				return jsonReply(_, response, 200, null, res);
			}
		} else {
			if (ent.$list) {
				var resources = ent.$list(_, request.parsedUrl.query);
			} else {
				throw new Error("No $list");
			}
			var links = {};
			var startIndex = +(request.parsedUrl.query.startIndex) || 1;
			var count = +(request.parsedUrl.query.count);
			if (resources.truncated) {
				resources.truncated = undefined;
				links.$next = {
					$url: request.parsedUrl.pathname + "?count=" + count + "&startIndex=" + (startIndex + count),
					$type: "application/json; vnd-sage=syracuse"
				};
			}
			if (startIndex > 1) {

				links.$previous = {
					$url: request.parsedUrl.pathname + "?count=" + count + "&startIndex=" + Math.max(startIndex - count, 1),
					$type: "application/json; vnd-sage=syracuse"
				};
			}
			return jsonReply(_, response, 200, null, {
				$links: links,
				$resources: resources,
			});
		}
	} catch (ex) {
		if (ex.errno === 'ENOENT') return notFound(_, request, response);
		else {
			console.error("Error in data dispatcher " + key + " " + ex.stack);
			jsonReply(_, response, 400, null, {
				$diagnoses: helper.addError(locale.format(module, "internalDisp", ex))
			});
		}
	}
	return true;
}

function errorReply(_, response, e) {
	console.error(e.stack);
	return jsonReply(_, response, 400, null, {
		$diagnoses: helper.addError("" + e)
	});
}

function logoutDispatcher(_, request, response) {
	var acceptHeader = (request.headers.accept || "");
	var acceptHtml = (acceptHeader.indexOf("text/html") >= 0 || acceptHeader.indexOf("*/*") >= 0);
	if (acceptHtml) {
		var headers = {
			"content-type": "text/html",
		};
		response.writeHead(200, headers);
		response.end(
			"<html><body><h1>" + (locale.format(module, "closeBrowser")) + "</h1></body></html>", 'utf8');

	} else {
		var headers = {
			"content-type": "application/json",
		};
		response.writeHead(200, headers);
		response.end(
			JSON.stringify({
				$diagnoses: [{
					$message: locale.format(module, "closeBrowser"),
					$severity: "warning",
				}]
			}), 'utf8');
	}
	return true;
}


function downloadDispatcher(_, request, response) {
	var prop = request.parsedUrl.segments[2];
	var header = {
		"content-type": "application/binary",
		"x-file-name": "test"
	};
	var data;
	switch (prop) {
		case "publicKey":
			data = new Buffer(helper.publicKey);
			break;
		case "license":
			if (!request.parsedUrl.segments[3]) throw new Error(locale.format(module, "noLic"));
			var parts = (request.parsedUrl.segments[3] || "").split("-");
			if (!helper.partnerFile) throw new Error(locale.format(module, "noPartner"));
			// put parts together
			// partner file
			var partnerFile = fs.readFile(helper.PARTNER_FILE, _);
			var exported = false;
			// policy
			var policy = fs.readFile(helper.POLICIES + "/" + parts.slice(2, 6).join("-") + ".json", _);
			var licName = helper.LICENSES + "/" + parts[1] + "/" + parts.slice(2).join("-") + ".json";
			var exportLicName = licName.replace(/.json$/, "e.json"); // add "e"
			try {
				var license = fs.readFile(licName);
			} catch (e) {
				if (e.code == "ENOENT") {
					exported = true;
					var license = fs.readFile(exportLicName);
				} else {
					throw e;
				}
			}
			var sep = new Buffer([13, 13]);
			data = Buffer.concat([partnerFile, sep, policy, sep, license]);
			if (!exported) {
				fs.rename(licName, exportLicName, _);
			}
			break;
		default:
			throw new Error("Not implemented");
	}
	header["content-length"] = data.length;
	response.writeHead(200, header);
	response.end(data);
	return true;
}


// first part of path
var routes = {
	require: requireDispatcher,
	"license-tool": staticDispatcher,
	"streamline-require": staticDispatcher,
	"syracuse-ui": staticDispatcher,
	"syracuse-auth": staticDispatcher,
	page: pageDispatcher,
	data: dataDispatcher,
	action: actionDispatcher,
	logout: logoutDispatcher,
	downloads: downloadDispatcher,
};


//authentication
function _unauthenticated(response) {
	response.writeHead(401, {
		"Content-Type": "text/plain; charset=utf-8",
		"WWW-Authenticate": 'Basic realm=' + helper.REALM
	});
	response.end(locale.format(module, "authReq"));
	return true;
}

function authenticate(_, request, response) {
	var credentials = /^[Bb]asic\s([a-zA-Z0-9\+\/]+\=*)/.exec(request.headers.authorization);
	if (!(credentials && credentials[1])) return _unauthenticated(response);
	var usrpwd = new Buffer(credentials[1], "base64");
	// Chrome uses UTF8 for authentication
	var agent = request.headers["user-agent"];
	if (agent && (agent.indexOf(" Chrome/") >= 0)) {
		usrpwd = usrpwd.toString("utf8");
	} else {
		usrpwd = usrpwd.toString("binary");
	}
	var index = usrpwd.indexOf(':');
	if (index < 0) return _unauthenticated(response);
	var user = usrpwd.substr(0, index).toLowerCase();
	var pass = usrpwd.substr(index + 1);
	var users = helper.users;

	if (!users.some(function(userdata) {
		if (userdata.login === user) {
			if (!helper.verifyPassword(userdata, pass)) return _unauthenticated(response);
			else {
				globals.context = {
					login: userdata.login,
					pwd: pass,
					salt: userdata.salt,
					name: (userdata.name || userdata.login),
					admin: (userdata.admin || false),
					pass: userdata.pass
				};
				return true;
			}
		}
	})) return _unauthenticated(response);
	return false;
}



ez.devices.http.server(function(request, response, _) {
	if (request.url === '/') {
		response.writeHead(301, {
			location: '/license-tool/html/main.html?url=' + encodeURIComponent("/home?representation=home.$page")
		});
		response.end();
		return;
	}
	request.parsedUrl = parseUrl(request.url, true);
	// no authentication for logout (Chrome browser)!
	if (request.url.substr(0, 7) !== "/logout" && authenticate(_, request, response)) return;
	request.parsedUrl.segments = request.parsedUrl.pathname.split('/');
	locale.setCurrent(_, 'en-US');

	var route = routes[request.parsedUrl.segments[1]] || notFound;
	if (!route(_, request, response, {})) { // whenever a response is created, the return value must be true
		notFound(_, request, response);
	}
}, {}).listen(_, helper.cfg.port);
console.log("Listen on port " + helper.cfg.port);