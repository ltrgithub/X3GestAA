"use strict";

QUnit.module(module.id);

var time = require("syracuse-core/lib/types/time");
var locale = require('streamline-locale');

test('basic', 4, function() {
	var t = time.make(18, 23, 7);
	strictEqual(t.hour, 18, "hour ok");
	strictEqual(t.minute, 23, "hour ok");
	strictEqual(t.second, 7, "minute ok");
	equal(t, "18:23:07");
});

test('bounds', 8, function() {
	var t = time.make(0, 0, 0);
	strictEqual(t.hour, 0, "min hour ok");
	strictEqual(t.minute, 0, "min hour ok");
	strictEqual(t.second, 0, "min minute ok");
	equal(t, "00:00:00");
	t = time.make(23, 59, 59);
	strictEqual(t.hour, 23, "max hour ok");
	strictEqual(t.minute, 59, "max hour ok");
	strictEqual(t.second, 59, "max minute ok");
	equal(t, "23:59:59");
});

test('compare', 11, function() {
	var t = time.make(18, 23, 7);
	strictEqual(t.equals(time.make(18, 23, 7)), true, "equals itself");
	strictEqual(t.equals(time.make(18, 23, 6)), false, "not equals other");
	strictEqual(t == "18:23:07", true, "== this.toString()");
	strictEqual(t == "18:23:06", false, "!= other.toString()");
	strictEqual(t.compare(time.make(18, 23, 6)) > 0, true, "compare > 0");
	strictEqual(t.compare(time.make(18, 23, 8)) < 0, true, "compare < 0");
	strictEqual(t.compare(time.make(18, 23, 7)) == 0, true, "compare == 0");
	strictEqual(t.between(time.make(18, 23, 7), time.make(18, 23, 7)), true, "between same");
	strictEqual(t.between(time.make(18, 23, 6), time.make(18, 23, 8)), true, "between different");
	strictEqual(t.between(time.make(18, 23, 4), time.make(18, 23, 6)), false, "not between before");
	strictEqual(t.between(time.make(18, 23, 8), time.make(18, 23, 10)), false, "not between after");
});

test('begs and ends', 6, function() {
	var t = time.make(18, 23, 7);
	equal(t.begOfDay(), "00:00:00", "beg of day");
	equal(t.endOfDay(), "23:59:59", "end of day");
	equal(t.begOfHour(), "18:00:00", "beg of day");
	equal(t.endOfHour(), "18:59:59", "end of day");
	equal(t.begOfMinute(), "18:23:00", "beg of day");
	equal(t.endOfMinute(), "18:23:59", "end of day");
});

test('add', 12, function() {
	var t = time.make(18, 23, 7);
	equal(t.addHours(3), "21:23:07", "+3 hours");
	equal(t.addHours(-3), "15:23:07", "-3 hours");
	equal(t.addMinutes(90), "19:53:07", "+90 mins");
	equal(t.addMinutes(-90), "16:53:07", "-90 mins");
	equal(t.addSeconds(90), "18:24:37", "+90 secs");
	equal(t.addSeconds(-90), "18:21:37", "-90 secs");
	equal(t.addHours(24), "18:23:07", "+24 hours");
	equal(t.addHours(-24), "18:23:07", "-24 hours");
	equal(t.addMinutes(24 * 60), "18:23:07", "+24 hours (mins)");
	equal(t.addMinutes(-24 * 60), "18:23:07", "-24 hours (mins)");
	equal(t.addSeconds(24 * 3600), "18:23:07", "+24 hours (secs)");
	equal(t.addSeconds(-24 * 3600), "18:23:07", "-24 hours (secs)");
});

test('diff', 2, function() {
	var t = time.make(18, 23, 7);
	equal(t.secondsDiff(time.make(17, 23, 7)), 3600, "seconds diff +3600");
	equal(t.secondsDiff(time.make(19, 23, 7)), -3600, "seconds diff -3600");
});

asyncTest('parse', 12, function(_) {
	// WARNING tests with AM/PM may not work correctly without setting locale

	var t = time.parse("18:23:07");
	strictEqual(t.hour, 18, "parse check hour (no format)");
	equal(t, "18:23:07", "parse check all (no format)");

	locale.setCurrent(_, 'en-GB');
	t = time.parse("04:31:16 PM", "hh:mm:ss tt");
	strictEqual(t.hour, 16, "parse check hour (hh:mm:ss tt)");
	strictEqual(t.minute, 31, "parse check minute (hh:mm:ss tt)");
	strictEqual(t.second, 16, "parse check second (hh:mm:ss tt)");

	t = time.parse("16.31.16", "H.mm.ss");
	strictEqual(t.hour, 16, "parse check hour (H.mm.ss)");
	strictEqual(t.minute, 31, "parse check minute (H.mm.ss)");
	strictEqual(t.second, 16, "parse check second (H.mm.ss)");

	t = time.parse("Time is : 12'31'16 A", "'Time is : 'h''''mm''''ss t");
	strictEqual(t.hour, 0, "parse check hour (format with literal and quotes)");
	strictEqual(t.minute, 31, "parse check minute (format with literal and quotes)");
	strictEqual(t.second, 16, "parse check second (format with literal and quotes)");

	strictEqual(time.parse("L'heure est : 12'31'16 AM", "'L''heure est : 'h''''mm''''ss tt").toString(), "00:31:16", "parse with quotes");
	start();
});

// note: cannot compare exactly 
test('today and fromJsDate', 5, function() {
	var now = time.now();
	var jsNow = new Date();
	var x = now.hour * 3600 + now.minute * 60 + now.second;
	var y = jsNow.getHours() * 3600 + jsNow.getMinutes() * 60 + jsNow.getSeconds();
	ok(x <= y && y < x + 1, "now matches new Date()");
	equal(time.fromJsDate(new Date(2010, 9, 13, 18, 23, 7)), "18:23:07", "fromJsDate (local summer)");
	equal(time.fromJsDate(new Date(2010, 11, 13, 18, 23, 7)), "18:23:07", "fromJsDate (local winter)");
	// note: following tests assumes Paris timezone
	equal(time.fromJsDate(new Date(2010, 9, 13, 18, 23, 7), true), "16:23:07", "fromJsDate (utc summer)");
	equal(time.fromJsDate(new Date(2010, 11, 13, 18, 23, 7), true), "17:23:07", "fromJsDate (utc winter)");
});

asyncTest('format', 5, function(_) {
	// WARNING tests with AM/PM may not work correctly without setting locale

	locale.setCurrent(_, 'en-GB');
	strictEqual(time.make(18, 23, 7).toString(), "18:23:07", "no format");
	strictEqual(time.make(18, 23, 7).toString("HH:mm:ss"), "18:23:07", "format basic");
	strictEqual(time.make(18, 23, 7).toString("h:mm:ss t"), "6:23:07 P", "(1/2) format with AM/PM mode");
	strictEqual(time.make(7, 23, 7).toString("h.mm.ss tt"), "7.23.07 AM", "(2/2) format with AM/PM mode");
	strictEqual(time.make(18, 23, 7).toString("'Time is : 'h''''mm''''ss tt"), "Time is : 6'23'07 PM", "format with literal and quotes");
	start();
});