"use strict";

var globals = require('streamline/lib/globals');
var cache = {};
var locale = exports;

/// * `loc = locale.current;`
///   returns the current locale, as a string ('en', 'en-US', 'fr-FR', etc.)
Object.defineProperty(locale, 'current', {
	get: function() {
		return (globals.context && globals.context.locale) || 'en-US';
	},
	set: function(val) {
		throw new Error("locale.current is readonly. Use locale.setLocale(_, value) to change it.");
	}
});

Object.defineProperty(locale, 'isRTL', {
	get: function() {
		var lang = locale.current.substring(0, 2);
		return lang === "ar" || lang === "iw";
	},
});

/// * `locale.setCurrent(_, value)`
///   Changes the current locale
///   This is an asynchronous call because we need to fetch the resources again on client side.
locale.setCurrent = function(cb, value, localePreferences) {
	if (!globals.context) return cb(new Error("cannot call locale.setCurrent without a global context"));
	globals.context.locale = value;
	globals.context.localePreferences = localePreferences;
	if (typeof require.localize === "function") require.localize(value, cb);
	else cb();
};

function _loadResources(mod, l) {
	function _loadFile(l, result) {
		if (!mod.filename) console.error(mod);
		var p = mod.filename.replace(/\\/g, '/'),
			slash = p.lastIndexOf('/'),
			dir = p.substring(0, slash) + '/resources',
			base = p.substring(slash + 1);
		base = base.substring(0, base.lastIndexOf('.'));
		var fs_ = 'fs',
			fs = require(fs_),
			path_ = 'path',
			path = require(path_);
		if (!fs.existsSync(dir)) return result || {};
		p = dir + '/' + base + '-' + l + '.json';
		var exists = fs.existsSync(p);
		if (!exists && l.length === 2) {
			var re = new RegExp('^' + base + '-' + l + '-\\w+\\.json$');
			var first = fs.readdirSync(dir).filter(function(s) {
				return re.test(s);
			})[0];
			if (first) {
				p = dir + "/" + first;
				exists = true;
			}
		}
		if (exists) {
			var delta = JSON.parse(fs.readFileSync(p, 'utf8'));
			if (!result) return delta;
			Object.keys(delta).forEach(function(k) {
				result[k] = delta[k];
			});
		}
		return result || {};

	}
	var r = _loadFile('en');
	var k = l.substring(0, 2);
	if (k !== 'en') r = _loadFile(k, r);
	if (l !== k) r = _loadFile(l, r);
	return r;
}

// hack to add resources when serving modules to clients
locale.getResourcesHook = function(cb, filename, accept) {
	var l = (accept || 'en-US').split(',')[0];
	if (l.length > 3) l = l.substring(0, 3) + l.substring(3).toUpperCase();
	var r = locale.resources({
		filename: filename
	}, l)();
	cb(null, JSON.stringify(r));
};

/// * `resources = locale.resources(mod, l)`
///   Returns a loader function for localized resources.
///   Resource `foo` is loaded with `resources().foo`
///   Warning: Returns a function. Do not forget the parentheses!
locale.resources = function(mod, l) {
	return function() {
		// client-side hack - don't support l arg for now
		if (mod.__resources) return mod.__resources;
		var cur = l || locale.current;
		var key = mod.filename + '-' + cur,
			r = cache[key];
		if (!r) r = cache[key] = _loadResources(mod, cur);
		return r;
	};
};

function _format(fmt, args) {
	return fmt.split('{{').map(function(fmt) {
		return fmt.split(/\}\}(?=(?:\}\})*[^\}]|$)/).map(function(fmt) {
			return fmt.replace(/\{([^}]+)\}/g, function(dummy, pat) {
				var sep = pat.indexOf(':');
				if (sep < 0) sep = pat.indexOf('?');
				var ref = sep < 0 ? pat : pat.substring(0, sep);
				var i = parseInt(ref, 10);
				var val = i >= 0 ? args[i] : (args[0] && args[0][ref]);
				switch (pat[sep]) {
					case ':':
						// TODO: apply numeric pattern
						return val;
					case '?':
						var strings = pat.substring(sep + 1).split('|');
						return strings[Math.min(val, strings.length - 1)];
					default:
						return val;
				}
			});
		}).join('}');
	}).join('{');
}

locale.format = function(mod, key) {
	var fmt, args;
	if (typeof mod === 'string') {
		fmt = mod, args = Array.prototype.slice.call(arguments, 1);
	} else {
		fmt = locale.resources(mod)()[key];
		if (fmt == null) throw new Error('resource ' + key + ' not found');
		args = Array.prototype.slice.call(arguments, 2);
	}
	return _format(fmt, args);
};

locale.formatLocale = function(loc, mod, key) {
	var fmt, args;
	if (typeof mod === 'string') {
		fmt = mod, args = Array.prototype.slice.call(arguments, 2);
	} else {
		fmt = locale.resources(mod, loc)()[key];
		if (fmt == null) throw new Error('resource ' + key + ' not found');
		args = Array.prototype.slice.call(arguments, 3);
	}
	return _format(fmt, args);
};

locale.formatAllIso = function(mod, key) {
	// to prevent pre commit rules
	var all = {
		"default": _format(locale.resources(mod, locale.current)()[key])
	};
	Object.keys(longMap).forEach(function(lang) {
		var res = _format(locale.resources(mod, lang)()[key]);
		if (lang === "en" || (lang !== "en" && res !== all.default)) all[longMap[lang]] = res;
	});
	return all;
};



locale.extractLocaleCode = function(acceptLanguageHeader) {
	// for now just take the first; TODO: take the best really supported from the list
	var a = (acceptLanguageHeader || "").split(",")[0];
	a = a.split(";");
	var res = a[0];
	// prefer long format: Can be dangerous a better way would be to have mapping between short format and a long one.
	a.forEach(function(l) {
		if (l.indexOf("-") >= 0) res = l;
	});
	return res;
};

// TEMPORARY map from locale code to ISO language code. Used with x3
var isoLanguageMap = {
	"aa": "AAR", // Afar
	"ab": "ABK", // Assamese
	"ae": "AVE", // Avestic
	"af": "AFR", // Afrikaans
	"ak": "AKA", // Akan
	"am": "AMH", // Amharic
	"an": "ARG", // Aragonese
	"ar": "ARA", // Arabic
	"ar-sa": "ARB", // Arabe Standard
	"as": "ASM", // Assamese
	"av": "AVA", // Avaric
	"ay": "AYM", // Aymara
	"az": "AZE", // Azeri
	"ba": "BAK", // Bachkir
	"be": "BEL", // Belarusian
	"bg": "BUL", // Bulgarian
	"bh": "BIH", // Bihari
	"bi": "BIS", // Bichelamar
	"bm": "BAM", // Bambara
	"bn": "BEN", // Bengali
	"bo": "TIB", // Tibetan
	"br": "BRE", // Breton
	"bs": "BOS", // Bosnian
	"ca": "CAT", // Catalan
	"ce": "CHE", // Chechen
	"ch": "CHA", // Chamorro
	"co": "COR", // Cornish
	"cr": "CRE", // Cri
	"cv": "CHV", // Tchouvatch
	"cy": "WEL", // Welsh
	"cz-cz": "CZE", // Czech
	"da": "DAN", // Danish
	"de-de": "GER", // German
	"dv": "DIV", // Divehi
	"dz": "DZO", // Dzongkha
	"ee": "EWE", // Ewe
	"el": "GRE", // Greek
	"en-au": "AUS", // English  Australia
	"en-gb": "BRI", // English - British
	"en-ph": "FIL", // Filipino
	"en-us": "ENG", // English - American
	"eo": "EPO", // Esperanto
	"es-es": "SPA", // Spanish
	"et": "EST", // Estonian
	"eu": "BAQ", // Basque
	"fa": "PER", // Persian
	"ff": "FUL", // Fulani
	"fi": "FIN", // Finish
	"fj": "FIJ", // Fijian
	"fo": "FAO", // Ferengi
	"fr-ca": "CAN", // French-Canada
	"fr-fr": "FRA", // French
	"fy": "FRY", // Frisian
	"ga": "GLE", // Irish
	"gd": "GLA", // Scotttish
	"gl": "GLG", // Galician
	"gn": "GRN", // Guarani
	"gu": "GUJ", // GujarÃ¢ti
	"gv": "GLV", // Manx
	"ha": "HAU", // Haoussa
	"he": "HEB", // Hebrew
	"hi": "HIN", // Hindi
	"ho": "HMO", // Hiri motu
	"hr": "SCR", // Croatian
	"ht": "HAT", // Creole Haiti
	"hu": "HUN", // Hungarian
	"hy": "ARM", // Armenian
	"hz": "HER", // Herero
	"ia": "INA", // Indian
	"id": "IND", // Indonesian
	"ig": "IBO", // Igbo
	"ii": "III", // Nosu
	"ik": "IPK", // Inupiaq
	"is": "ICE", // Icelandic
	"it-it": "ITA", // Italian
	"iu": "IKU", // Inuktitut
	"ja": "JPN", // Japanese
	"jv": "JAV", // Javanese
	"ka": "GEO", // Georgian
	"kg": "KON", // Kilongo
	"ki": "KIK", // Kikuyu
	"kj": "KUA", // Kunyama
	"kk": "KAZ", // Kazakh
	"kl": "KAL", // Kalaallisut
	"km": "KHM", // Khmer
	"kn": "KAN", // Kannara
	"ko": "KOR", // Korean
	"kr": "KAU", // Kanouri
	"ks": "KAS", // Kashmiri
	"ku": "KUR", // Kurdish
	"kv": "KOM", // Komi
	"ky": "KIR", // Kirghiz
	"lb": "LTZ", // Luxembourgish
	"lg": "LUG", // Ganda
	"li": "LIM", // Limburgish
	"ln": "LIN", // Lingala
	"lo": "LAO", // Lao
	"lt": "LIT", // Lithuanian
	"lu": "LUB", // Tchiluba
	"lv": "LAV", // Lettish ( Latvian)
	"mg": "MLG", // Malagasy
	"mh": "MAH", // Marshallese
	"mi": "MAO", // Maori (New-Zealand)
	"mk": "MAC", // Macedonian
	"ml": "MAL", // Malay
	"mn": "MON", // Mongolian
	"mo": "MOL", // Moldavian
	"mr": "MAR", // MarÃ¢thi
	"mt": "MLT", // Maltese
	"my": "BUR", // Burmese
	"na": "NAU", // Nauruan
	"nb": "NOB", // Norwegian Bokmal
	"nd": "NDE", // Northern Ndebele
	"ne": "NEP", // Nepalese
	"ng": "NDO", // Ndonga
	"nl": "DUT", // Dutch
	"nn": "NNO", // Norwegian Nynorsk
	"no": "NOR", // Norwegian
	"nr": "NBL", // Southern Ndebele
	"nv": "NAV", // Navajo
	"ny": "NYA", // Chichewa
	"oc": "OCI", // Occitan
	"oj": "OJI", // Ojibwe
	"om": "ORM", // Oromo
	"or": "ORI", // Oriya
	"os": "OSS", // Ossitian
	"pa": "PAN", // Punjabi
	"pi": "PLI", // Pali
	"pl-pl": "POL", // Polish
	"ps": "PUS", // Pachto
	"pt-pt": "POR", // Portuguese
	"qu": "QUE", // Quechuan
	"rm": "ROH", // Romanche
	"ro": "RUM", // Rumanian
	"ru-ru": "RUS", // Russian
	"rw": "KIN", // Kinyarwanda
	"sa": "SAN", // Sanskrit
	"sc": "SRD", // Sardinian
	"sd": "SND", // Sindhi
	"se": "SME", // Northern Sami
	"sg": "SAG", // Sango
	"sh": "HBS", // Serbo-Croation
	"sk": "SLO", // Slovak
	"sl": "SLV", // Slovenian
	"sm": "SMO", // Samoan
	"sn": "SNA", // Shona
	"so": "SOM", // Somali
	"sq": "ALB", // Albanese
	"sr": "SCC", // Serbian
	"ss": "SSW", // Siswati
	"st": "SOT", // Southern Sotho
	"su": "SUN", // Sundanese
	"sv": "SWE", // Swedish
	"sw": "SWA", // Swahili
	"ta": "TAM", // Tamil
	"te": "TEL", // Telugu
	"tg": "TGK", // Tadjik
	"th": "THA", // Thai
	"ti": "TIR", // Tigrinya
	"tk": "TUK", // Turkmen
	"tl": "TGL", // Tagalog
	"tn": "TSN", // Tswana
	"to": "TON", // Tongian
	"tr": "TUR", // Turkish
	"ts": "TSO", // Tsonga
	"tt": "TAT", // Tatar
	"tw": "TWI", // Twi
	"ty": "TAH", // Tahitian
	"ug": "UIG", // Ouighour
	"uk": "UKR", // Ukrainian
	"ur": "URD", // Urdu
	"uz": "UZB", // Uzbek
	"ve": "VEN", // Venda
	"vi": "VIE", // Vietnamese
	"vo": "VOL", // Volapuk
	"wa": "WLN", // Walloon
	"wo": "WOL", // Wolof
	"xh": "XHO", // Xhosa
	"yi": "YID", // Yiddish
	"yo": "YOR", // Yoruba
	"za": "ZHA", // Zhuang
	"zh-cn": "CHI", // Chinese
	"zh-tw": "CHT", // Chinese tranditional
	"zu": "ZUL", // Zulu (Southern Africa)
};

var defaultMap = {
	AAR: "aa", // Afar
	ABK: "ab", // Assamese
	AFR: "af", // Afrikaans
	AKA: "ak", // Akan
	ALB: "sq", // Albanese
	AMH: "am", // Amharic
	ARA: "ar", // Arabic
	ARB: "ar-sa", // Arabe Standard
	ARG: "an", // Aragonese
	ARM: "hy", // Armenian
	ASM: "as", // Assamese
	AUS: "en-au", // English  Australia
	AVA: "av", // Avaric
	AVE: "ae", // Avestic
	AYM: "ay", // Aymara
	AZE: "az", // Azeri
	BAK: "ba", // Bachkir
	BAM: "bm", // Bambara
	BAQ: "eu", // Basque
	BEL: "be", // Belarusian
	BEN: "bn", // Bengali
	BIH: "bh", // Bihari
	BIS: "bi", // Bichelamar
	BOS: "bs", // Bosnian
	BRE: "br", // Breton
	BRI: "en-gb", // English - British
	BUL: "bg", // Bulgarian
	BUR: "my", // Burmese
	CAN: "fr-ca", // French-Canada
	CAT: "ca", // Catalan
	CHA: "ch", // Chamorro
	CHE: "ce", // Chechen
	CHI: "zh-cn", // Chinese
	CHT: "zh-tw", // Chinese tranditional
	CHV: "cv", // Tchouvatch
	COR: "co", // Cornish
	CRE: "cr", // Cri
	CZE: "cz-cz", // Czech
	DAN: "da", // Danish
	DIV: "dv", // Divehi
	DUT: "nl", // Dutch
	DZO: "dz", // Dzongkha
	ENG: "en-us", // English - American
	EPO: "eo", // Esperanto
	EST: "et", // Estonian
	EWE: "ee", // Ewe
	FAO: "fo", // Ferengi
	FIJ: "fj", // Fijian
	FIL: "en-ph", // Filipino
	FIN: "fi", // Finish
	FRA: "fr-fr", // French
	FRY: "fy", // Frisian
	FUL: "ff", // Fulani
	GEO: "ka", // Georgian
	GER: "de-de", // German
	GLA: "gd", // Scotttish
	GLE: "ga", // Irish
	GLG: "gl", // Galician
	GLV: "gv", // Manx
	GRE: "el", // Greek
	GRN: "gn", // Guarani
	GUJ: "gu", // GujarÃ¢ti
	HAT: "ht", // Creole Haiti
	HAU: "ha", // Haoussa
	HBS: "sh", // Serbo-Croation
	HEB: "he", // Hebrew
	HER: "hz", // Herero
	HIN: "hi", // Hindi
	HMO: "ho", // Hiri motu
	HUN: "hu", // Hungarian
	IBO: "ig", // Igbo
	ICE: "is", // Icelandic
	III: "ii", // Nosu
	IKU: "iu", // Inuktitut
	INA: "ia", // Indian
	IND: "id", // Indonesian
	IPK: "ik", // Inupiaq
	ITA: "it-it", // Italian
	JAV: "jv", // Javanese
	JPN: "ja", // Japanese
	KAL: "kl", // Kalaallisut
	KAN: "kn", // Kannara
	KAS: "ks", // Kashmiri
	KAU: "kr", // Kanouri
	KAZ: "kk", // Kazakh
	KHM: "km", // Khmer
	KIK: "ki", // Kikuyu
	KIN: "rw", // Kinyarwanda
	KIR: "ky", // Kirghiz
	KOM: "kv", // Komi
	KON: "kg", // Kilongo
	KOR: "ko", // Korean
	KUA: "kj", // Kunyama
	KUR: "ku", // Kurdish
	LAO: "lo", // Lao
	LAV: "lv", // Lettish ( Latvian)
	LIM: "li", // Limburgish
	LIN: "ln", // Lingala
	LIT: "lt", // Lithuanian
	LTZ: "lb", // Luxembourgish
	LUB: "lu", // Tchiluba
	LUG: "lg", // Ganda
	MAC: "mk", // Macedonian
	MAH: "mh", // Marshallese
	MAL: "ml", // Malay
	MAO: "mi", // Maori (New-Zealand)
	MAR: "mr", // MarÃ¢thi
	MLG: "mg", // Malagasy
	MLT: "mt", // Maltese
	MOL: "mo", // Moldavian
	MON: "mn", // Mongolian
	NAU: "na", // Nauruan
	NAV: "nv", // Navajo
	NBL: "nr", // Southern Ndebele
	NDE: "nd", // Northern Ndebele
	NDO: "ng", // Ndonga
	NEP: "ne", // Nepalese
	NNO: "nn", // Norwegian Nynorsk
	NOB: "nb", // Norwegian Bokmal
	NOR: "no", // Norwegian
	NYA: "ny", // Chichewa
	OCI: "oc", // Occitan
	OJI: "oj", // Ojibwe
	ORI: "or", // Oriya
	ORM: "om", // Oromo
	OSS: "os", // Ossitian
	PAN: "pa", // Punjabi
	PER: "fa", // Persian
	PLI: "pi", // Pali
	POL: "pl-pl", // Polish
	POR: "pt-pt", // Portuguese
	PUS: "ps", // Pachto
	QUE: "qu", // Quechuan
	ROH: "rm", // Romanche
	RUM: "ro", // Rumanian
	RUS: "ru-ru", // Russian
	SAG: "sg", // Sango
	SAN: "sa", // Sanskrit
	SCC: "sr", // Serbian
	SCR: "hr", // Croatian
	SLO: "sk", // Slovak
	SLV: "sl", // Slovenian
	SME: "se", // Northern Sami
	SMO: "sm", // Samoan
	SNA: "sn", // Shona
	SND: "sd", // Sindhi
	SOM: "so", // Somali
	SOT: "st", // Southern Sotho
	SPA: "es-es", // Spanish
	SRD: "sc", // Sardinian
	SSW: "ss", // Siswati
	SUN: "su", // Sundanese
	SWA: "sw", // Swahili
	SWE: "sv", // Swedish
	TAH: "ty", // Tahitian
	TAM: "ta", // Tamil
	TAT: "tt", // Tatar
	TEL: "te", // Telugu
	TGK: "tg", // Tadjik
	TGL: "tl", // Tagalog
	THA: "th", // Thai
	TIB: "bo", // Tibetan
	TIR: "ti", // Tigrinya
	TON: "to", // Tongian
	TSN: "tn", // Tswana
	TSO: "ts", // Tsonga
	TUK: "tk", // Turkmen
	TUR: "tr", // Turkish
	TWI: "tw", // Twi
	UIG: "ug", // Ouighour
	UKR: "uk", // Ukrainian
	URD: "ur", // Urdu
	UZB: "uz", // Uzbek
	VEN: "ve", // Venda
	VIE: "vi", // Vietnamese
	VOL: "vo", // Volapuk
	WEL: "cy", // Welsh
	WLN: "wa", // Walloon
	WOL: "wo", // Wolof
	XHO: "xh", // Xhosa
	YID: "yi", // Yiddish
	YOR: "yo", // Yoruba
	ZHA: "za", // Zhuang
	ZUL: "zu", // Zulu (Southern Africa)
};

var longMap = {
	ar: "ar-sa", // Arabe Standard
	cz: "cz-cz", // Czech
	de: "de-de", // German
	//	en: "en-au", // English  Australia
	//	en: "en-gb", // English - British
	//	en: "en-ph", // Filipino
	en: "en-us", // English - American
	es: "es-es", // Spanish
	//	fr: "fr-ca", // French-Canada
	fr: "fr-fr", // French
	it: "it-it", // Italian
	pl: "pl-pl", // Polish
	pt: "pt-pt", // Portuguese
	ru: "ru-ru", // Russian
	zh: "zh-cn", // Chinese
	//	zh: "zh-tw", // Chinese tranditional
};

locale.x3Language = function(isocode, strict) {
	return isoLanguageMap[isocode && isocode.toLowerCase().replace("_", "-") || (!strict && "en-us")];
};

locale.defaultIso = function(code) {
	return defaultMap[code && code.toUpperCase()];
};

locale.longIso = function(isocode) {
	return (/\w\w-\w\w/i).exec(isocode) && isocode.toLowerCase() || longMap[isocode && isocode.toLowerCase()];
};