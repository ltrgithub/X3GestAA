"use strict";

var helpers = require("syracuse-core/lib/helpers");
var forEachKey = helpers.object.forEachKey;
var resourceHelpers = require("syracuse-core/lib/resource/util");
var tracer = helpers.debug.tracer("sdata.internals");
var flows = require('streamline/lib/util/flows');

// TODO: clean this up


function _fix(resource) {
	if (resource.$url && !resource.$key) {
		var url = resource.$url;
		if (url.substring(url.length - 2, url.length) == "')") {
			resource.$key = url.substring(url.lastIndexOf("('") + 2, url.length - 2);
		}
	}
	forEachKey(resource, function(key, value) {
		if (typeof value === "object" && value != null) _fix(value);
	});
}

exports.fix = _fix;

function _fillProtoTemplates(result, entity) {
	result.$url = "{$baseUrl}" + "/" + entity.plural + "('{$key}')";
	result.$value = (entity.$valueTemplate && entity.$valueTemplate.expression) || "{$key}"
	result.$title = (entity.$titleTemplate && entity.$titleTemplate.expression) || (entity.title + " {$key}");
	result.$description = (entity.$descriptionTemplate && entity.$descriptionTemplate.expression) || result.$title;
}

function _fillThumb($thumb, targetEntity, options) {
	_fillProtoTemplates($thumb, targetEntity);
	$thumb.$type = "application/json";
	$thumb.$links = {
		$details: {
			$url: options.baseUrl + "/" + targetEntity.plural + "('{$key}')",
			$type: "{$baseType}." + targetEntity.name + ".$details"
		},
		$lookup: {
			$url: options.baseUrl + "/" + targetEntity.plural,
			$type: "{$baseType}." + targetEntity.name + ".$lookup"
		}
	};
	$thumb.$ = {
		$value: {
			$type: "application/x-string"
		}
	};

}

function _serialize(_, dbHandle, meta, options, isRoot) {
	var entity = meta.entity;
	if (!dbHandle) return dbHandle; // preserve null/undefined distinction
	var url = options.baseUrl + "/" + entity.plural + "('" + dbHandle.id + "')";
	var result = {};
	if (options.isPrototype) {
		if (isRoot) {
			result.$baseUrl = options.baseUrl;
			result.$baseType = options.model.baseType;
		}
		_fillProtoTemplates(result, entity);
		if (options.representation.type) {
			result.$type = "{$baseType}." + entity.name + "." + (isRoot ? options.representation.type : "$child");
		} else {
			result.$type = "application/json";
		}
	} else {
		result.$uuid = dbHandle.id;
		result.$key = dbHandle.id;
		if (!options.representation.type) {
			result.$url = url;
			result.$title = entity.$titleTemplate ? entity.$titleTemplate.resolve(dbHandle) : dbHandle.toString();
			result.$description = entity.$descriptionTemplate ? entity.$descriptionTemplate.resolve(dbHandle) : result.$title;
		}
	}
	var $ = result.$ = helpers.object.clone(dbHandle.$) || {};
	var $links = result.$links = result.$links || {};
	result.$actions = helpers.object.clone(dbHandle.$actions);

	if (options.isPrototype && entity.$valueTemplate) {
		$.$value = {
			$type: "application/x-string"
		}
	}
	//serialize properties
	//
	// crnit : allow serialization of instances
	//	forEachKey(meta.$properties, function(name, property) {
	flows.eachKey(_, meta.$properties, function(_, name, property) {
		var value = dbHandle[name];
		// crnit
		if (typeof(value) === "function") value = dbHandle[name](_);
		if (property.$isLazy) {
			value = {
				//$url: "{$url}/" + name,
				$url: url + "/" + name,
				$type: property.$type
			}
			if (options.representation.type === "$edit") {
				value.$links = {
					$upload: {
						$url: "/upload",
						$method: "POST"
					}
				}
			}
		} else if (value) {
			value = resourceHelpers.formatValue(property, value, name);
		}
		if (typeof value != "undefined") result[name] = value;
	});
	flows.eachKey(_, meta.$relations, function(_, name, relation) {
		var targetEntity = relation.targetEntity;
		var targetType = "{$baseType}." + targetEntity.name;
		if (relation.relType == "parent" || relation.relType == "link") return;
		//if (relation.relType == "association")
		//	return; // for now -- reenable later once UI can handle it
		// fill links
		// Q: should we filter them?
		if (relation.isPlural) {
			$[name] = {
				$url: "{$url}/" + name,
			};
			if (options.isPrototype) {
				$[name].$title = relation.title;
				$[name].$type = "application/x-collection";
				var $item = $[name].$item = {};
				switch (relation.relType) {
				case "association":
					$item.$type = "application/x-reference";
					var $thumb = $item.$thumb = {};
					_fillThumb($thumb, targetEntity, options);
					break;
				case "children":
					$item.$type = targetType + ".$child";
					break;
				default:
					throw new Error("bad relType: " + relation.relType);
				}
			} else if (relation.isSelected) {
				result[name] = [];
				var dbHandles = options.getPluralDbHandles(_, dbHandle, relation);
				if (dbHandles) {
					dbHandles.forEach_(_, function(_, child, index) {
						var resource = _serialize(_, child, relation, options);
						result[name].push(resource);
					});
				}
			}

		} else {
			var relId = dbHandle._data[name];
			var relDbHandle = (relation.needsThumb || relation.isSelected) ? dbHandle[name] : undefined;
			result[name] = relId ? {
				$key: relId,
				$uuid: relId
			} : null;
			$[name] = $[name] || {};
			if (options.isPrototype) {
				$[name].$title = relation.title;
				switch (relation.relType) {
				case "child":
					$[name].$type = targetType + ".$child";
					break;
				case "reference":
					$[name].$type = "application/x-reference";
					var $thumb = $[name].$thumb = {};
					_fillThumb($thumb, targetEntity, options);
					break;

				default:
					throw new Error("bad relType: " + relation.relType);
				}
			} else if (relation.isSelected || relation.needsThumb) {
				if (relDbHandle) result[name] = _serialize(_, relDbHandle, relation, options);
				else result[name] = null;
			}
		}
	});
	var resType = "{$baseType}." + entity.name;
	if (options.isPrototype) {
		if (options.representation.type !== "$details") {
			$links.$details = {
				$title: "Details",
				$url: "{$baseUrl}/" + entity.plural + "('{$key}')",
				$type: "{$baseType}." + entity.name + ".$details"
			}
		}
		if (options.representation.type !== "$edit") {
			$links.$edit = {
				$title: "Edit",
				$url: "{$url}/$workingCopies",
				$type: "{$baseType}." + entity.name + ".$edit",
				$method: "POST"
			}
			$links.$delete = {
				$title: "Delete",
				$url: "{$url}",
				$type: null,
				$method: "DELETE"
			}
		}
		if (options.representation.type !== "$query") {
			$links.$query = {
				$title: "List of " + entity.plural,
				$url: "{$baseUrl}/" + entity.plural,
				$type: "{$baseType}." + entity.name + ".$query",
				$method: "POST"
			}
		}
		if (options.representation.type === "$edit" && isRoot) {
			result.$actions = result.$actions || {};
			result.$actions.$save = result.$actions.$save || {
				$title: "Save",
				$isDisabled: true,
				$isRequested: false,
				$diagnoses: null,
				$links: {
					$details: {
						$title: "OK",
						$url: "{$baseUrl}/" + entity.plural + "('{$key}')",
						$type: "{$baseType}." + entity.name + ".$details",
						$isHidden: true
					},
					$query: {
						$title: "Back to list",
						$url: "{$baseUrl}/" + entity.plural,
						$type: "{$baseType}." + entity.name + ".$query",
						$isHidden: true
					}
				}
			};
		}
	} else {
		if (options.representation.type && isRoot) {
			$links.$prototype = {
				$title: "Prototype",
				$url: options.baseUrl + "/$prototypes('" + entity.name + "." + options.representation.type + "')",
				$type: "application/json",
				$isHidden: true
			};
		}
	}

	if (options.isPrototype && options.representation.type === "$query") {
		var old = result;
		result = {
			$baseUrl: result.$baseUrl,
			$baseType: result.$baseType,
			$url: "{$baseUrl}/" + entity.plural,
			$type: result.$type,
			$title: entity.plural,
			$: {
				$resources: {
					$type: "application/x-collection",
					$item: result
				}
			}
		}
		delete old.$baseType;
		delete old.$baseUrl;
		//old.$type = result.$baseType + "." + entity.name + ":$queryItem";
		old.$type = "application/json";
	}
	return result;
}

exports.serialize = function(_, dbHandle, meta, options) {
	return _serialize(_, dbHandle, meta, options, root);
}