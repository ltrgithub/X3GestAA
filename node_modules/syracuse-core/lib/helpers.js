"use strict";

var helpers = exports;

if (!global.console) { // be safe, maybe we need this in IE
    global.console = {
        error: alert,
        warn: alert,
        info: alert,
        log: alert
    }
}

function _addMembers(proto, members) {
    for (var name in members || {}) {
        var member = members[name];
        if (typeof member.get === "function" || typeof member.set === "function") {
            Object.defineProperty(proto, name, member);
            //if (member.get)
            //  proto.__defineGetter__(name, member.get);
            //if (member.set)
            //  proto.__defineSetter__(name, member.set);
        } else {
            proto[name] = member;
        }
    }
}

exports.defineClass = function(constructor, parent, members) {
    if (parent) constructor.prototype = new parent();
    constructor.prototype.constructor = constructor;
    _addMembers(constructor.prototype, members)
    return constructor;
};
exports.defineClassEx = function(constructor, parent, extraMembers, members) {
    var constuct = exports.defineClass(constructor, parent, members);
    if (extraMembers) {
        (!Array.isArray(extraMembers) ? _addMembers(constuct.prototype, extraMembers) : extraMembers.forEach(function(v, i) {
            _addMembers(constuct.prototype, v);
        }));
    }
    return constuct;
};
exports.object = {
    deleteProperties: function(obj, properties) {
        if (!obj) return;
        Object.keys(obj).forEach(function(key) {
            if (properties.indexOf(key) !== -1) {
                delete obj[key];
            } else {
                if (obj[key] != null && typeof obj[key] == "object") {
                    exports.object.deleteProperties(obj[key], properties);
                }
            }
        });
    },
    find: function(obj, key) {
        if (obj == null) throw new Error("find error: container is null, key=" + key);
        var val = obj[key];
        if (val == null) throw new Error("key not found: " + key);
        return val;
    },
    get: function(obj, key, failIfNull) {
        return failIfNull ? helpers.object.find(obj, key) : (obj ? obj[key] : null);
    },
    copy: function(src, dst) {
        helpers.object.forEachKey(src, function(key, val) {
            dst[key] = val;
        });
        return dst;
    },
    extend: function(src, ext, override, deep) {
        src = src || {};
        helpers.object.forEachKey(ext, function(key, val) {
            if (deep && typeof src[key] === "object" && src[key] !== null) {
                src[key] = src[key] || {};
                helpers.object.extend(src[key], val, override, deep);
            } else if (src[key] == null || override) {
                src[key] = val;
            }
        });
        return src;
    },
    extendEx: function(obj) {
        (Array.prototype.slice.call(arguments, 1)).forEach(function(source) {
            for (var prop in source) {
                obj[prop] = source[prop];
            }
        });
        return obj;
    },
    merge: function(src, dst) {
        var differs = false;
        helpers.object.forEachKey(src, function(key, val) {
            var dstVal = dst[key];
            if (typeof dstVal == "undefined") dst[key] = val;
            else if (val != dstVal && !helpers.object.areEqual(val, dstVal)) differs = true;
        });
        return differs;
    },
    clone: function(obj, deep) {
        if (!obj || typeof obj != "object") return obj;
        if (obj instanceof Date) return obj;
        var clone;
        if (obj instanceof Array) {
            clone = [];
            for (var i = 0; i < obj.length; i++)
            clone.push(deep ? helpers.object.clone(obj[i], deep) : obj[i]);
            return clone;
        }
        clone = {};
        helpers.object.forEachKey(obj, function(key, val) {
            clone[key] = deep ? helpers.object.clone(val, deep) : val;
        });
        return clone;
    },
    has: function(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key);
    },
    forEachKey: function(object, body) {
        for (var key in object)
        if (helpers.object.has(object, key)) body(key, object[key]);
    },
    isFunction: function(obj) {
        return !!(obj && obj.constructor && obj.call && obj.apply);
    },
    toArray: function(object, body) {
        var result = [];
        for (var key in object) {
            if (helpers.object.has(object, key)) {
                var val = body(key, object[key]);
                if (val !== undefined) result.push(val);
            }
        }
        return result;
    },
    areEqual: function(obj1, obj2) {
        if (obj1 == obj2) return true;
        if (obj1 == null || obj2 == null) return false;
        if (obj1 instanceof Array && obj2 instanceof Array) {
            if (obj1.length != obj2.length) return false;
            for (var i = 0; i < obj1.length; i++)
            if (!helpers.object.areEqual(obj1[i], obj2[i])) return false;
            return true;
        }

        if (typeof obj1 != "object" || typeof obj2 != "object") return false;
        //var combined = $.extend({}, obj1, obj2);
        var combined = helpers.object.extend({}, obj1);
        helpers.object.extend(combined, obj2);
        for (var i in combined) {
            if (helpers.object.has(combined, i)) {
                var val1 = obj1[i];
                var val2 = obj2[i];
                if (!helpers.object.areEqual(val1, val2)) return false;
            }
        }
        return true;
    },
    // Walks along a property path.
    // Returns the leaf information (descendant resource + its property).
    walkPath: function(resource, path) {
        if (resource == null) return null;
        var paths = path.split('.');
        var property = paths.pop();
        var instance = resource;
        for (var i = 0; i < paths.length; i++) {
            var p = paths[i];
            if (p.trim() === '') continue;
            if (p.indexOf('[') !== -1) {
                // Array case
                var ps = p.split('[');
                instance = instance[ps.shift()];
                if (instance == null) return null;
                for (var j = 0; j < ps.length; j++) {
                    instance = instance[ps[j].substring(0, ps[j].length - 1)];
                }
            } else {
                instance = instance[p];
            }
            if (instance == null) return null;
        }
        if (property.indexOf('[') !== -1) {
            var ps = property.split('[');
            instance = instance[ps.shift()];
            if (instance == null) return null;
            for (var j = 0; j < ps.length - 1; j++) {
                instance = instance[ps[j].substring(0, ps[j].length - 1)];
            }
            property = ps[j].substring(0, ps[j].length - 1);
        }
        return {
            resource: instance,
            property: property
        };
    },
    evalPath: function(resource, path) {
        var walked = helpers.object.walkPath(resource, path);
        return walked && walked.resource ? walked.resource[walked.property] : null;
    },
    stringify: function(obj) {
        var seen = [];

        return JSON.stringify(obj, function(key, val) {
            if (typeof val === "object") {
                if (seen.indexOf(val) >= 0) return undefined
                seen.push(val)
            }
            return val
        });
    }
};

exports.array = {
    ensureArray: function(obj) {
        if (obj == null) return [];
        if (!Array.isArray(obj)) return [obj];
        return obj;
    }
};

exports.string = {
    pluralize: function(str) {
        // special treatment for y and f preceded with consonant and for s
        if (/(sh?|ch)$/.test(str)) return str + "es";
        if (/[b-df-hj-np-tv-z]y$/.test(str)) return str.substring(0, str.length - 1) + "ies";
        if (/[b-df-hj-np-tv-z]f$/.test(str)) return str.substring(0, str.length - 1) + "ves";
        return str + "s";
    },
    capitalize: function(str) {
        if (str && str.length > 0) str = str.charAt(0).toUpperCase() + str.substring(1);
        return str;
    },
    makeLabel: function(str) {
        for (var i = 0; i < str.length; i++) {
            var ch = str.charAt(i);
            if (ch == ch.toUpperCase()) return str.substring(0, i) + " " + ch.toLowerCase() + helpers.string.makeLabel(str.substring(i + 1));
        }
        return str;
    },
    formatValue: function(item, val) {
        // TODO: enhance with item.format leater
        if (val == null) return "";
        if (item == null) return val.toString();
        switch (item.$type) {
        case "date":
            return val.substring(0, 10);
        case "boolean":
            return val ? "yes" : "no";
        default:
            return val.toString();
        }
    },
    parseValue: function(item, str) {
        if (str == null || str == "") return str;
        switch (item.type) {
        case "integer":
            return typeof str === "string" ? parseInt(str, 10) : str;
        case "real":
            return typeof str === "string" ? parseFloat(str) : str;
        case "date":
            return str + " 00:00:00";
        case "boolean":
            return str == "1" || str == "yes" || str == "true";
        default:
            return str;
        }
    },
    padLeft: function(str, len, ch) {
        str = str ? str.toString() : '';
        if (!ch || ch.length == 0) ch = " ";
        while (str.length < len)
        str = ch + str;
        return str;
    },
    trim: function(str) {
        if (str == null) return str;
        var begin = 0;
        var end = str.length;
        while (begin < str.length && str.charAt(begin) == ' ')
        begin++;
        while (end > begin && str.charAt(end - 1) == ' ')
        end--;
        return str.substring(begin, end);
    },
    trimRight: function(str) {
        if (str == null) return str;
        var end = str.length;
        while (end > 0 && str.charAt(end - 1) == ' ')
        end--;
        return str.substring(0, end);
    },
    checkName: function(name) {
        if (name == null || name.length == 0) throw new Error("invalid name: missing or empty");
        if (typeof name != "string") throw new Error("invalid name: type=" + typeof name);

        if (name.match(/[A-Z][A-Z0-9_\-]*/i) != name) throw new Error("name does not match required pattern: " + name);
    },
    checkPath: function(path) {
        if (path == null || path.length == 0) {
            throw new Error("invalid path: missing or empty");
        }
        if (path.match(/[A-Z][A-Z0-9_]*(?:[.][A-Z][A-Z0-9_]*)*/i) != path) throw new Error("path does not match required pattern: " + path);
    },
    sqlQuote: function(str) {
        return str && ("'" + str.replace(/'/g, "''") + "'");
    },
    compare: function(s1, s2, ignoreCase) {
        if (ignoreCase) {
            s1 = s1.toUpperCase();
            s2 = s2.toUpperCase();
        }
        return s1 == s2 ? 0 : s1 < s2 ? -1 : +1;
    },
    labelSeparator: ' :'
};

var _templatePattern = /(\{.*?\})/g;

exports.resource = {
    create: function(url) {
        return {
            $url: url || ("urn:uuid:" + helpers.uuid.generate())
        };
    },
    syracuseProperties: ["$serverOld", "$clientOld"],

    stringify: function(resource) {
        return JSON.stringify(resource, function(key, value) {
            if (exports.resource.syracuseProperties.indexOf(key) != -1) return;
            else return value;
        });
    },
    addError: function(resource, uuid, property, message) {
        var errors = resource.$errors || (resource.$errors = {});
        var uuidErrors = errors[uuid] || (errors[uuid] = []);
        uuidErrors.push({
            property: property,
            severity: "error",
            message: message
        });
    },
    diff: function(oldResource, newResource) {
        if (oldResource == null) return newResource;

        var hasDiff = false;
        var objDiff = {
            $url: oldResource.$url
        };
        Object.keys(newResource).forEach(function(key) {
            var oldValue = oldResource[key];
            var newValue = newResource[key];
            if (oldValue == null && oldValue !== newValue) {
                objDiff[key] = newResource[key];
                hasDiff = true;
            } else {
                if (typeof newValue == "object") {
                    if (!helpers.object.areEqual(oldValue, newValue)) {
                        hasDiff = true;
                        if (Array.isArray(newValue) && newValue.every(function(item) {
                            return Object.prototype.hasOwnProperty.call(item, "$key")
                        })) {
                            objDiff[key] = [];
                            if (oldValue.reduce(function(a, b) {
                                return a.$url + b.$url;
                            }) !== newValue.reduce(function(a, b) {
                                return a.$url + b.$url;
                            })) {
                                //the list has changed
                                objDiff[key] = newValue.map(function(v, i) {
                                    var oldVal = oldValue.filter(function(ov) {
                                        return ov.$url === v.$url;
                                    });
                                    if (oldVal.length) {
                                        var diff = exports.resource.diff(oldVal[0], v);
                                        return diff || {
                                            $url: v.$url
                                        };
                                    } else {
                                        return v;
                                    }
                                });
                            } else {
                                //the list has not changed, so it's a sub resource.
                                objDiff[key] = [];
                                newValue.forEach(function(v, i) {
                                    var diff = exports.resource.diff(oldValue[i], v);
                                    if (diff) {
                                        diff.$index = i + 1;
                                        if (oldValue[i].$url === v.$url) {
                                            delete diff.$url;
                                        }
                                        objDiff[key].push(diff);
                                    }
                                });
                            }
                        } else {
                            if (Object.prototype.hasOwnProperty.call(newValue, "$url")) { //this is a resource
                                if (oldValue.$url !== newValue.$url) {
                                    objDiff[key] = newValue;
                                } else {
                                    objDiff[key] = exports.resource.diff(oldValue, newValue);
                                }
                            } else {
                                objDiff[key] = newValue;
                            }
                        }
                    }
                } else {
                    if (oldValue !== newValue) {
                        objDiff[key] = newValue;
                        hasDiff = true;
                    }
                }
            }
        });
        Object.keys(oldResource).forEach(function(key) { //New properties
            if (typeof newResource[key] == "undefined") {
                if (objDiff["$undefined"] == null) {
                    objDiff["$undefined"] = [];
                }
                objDiff["$undefined"].push(key);
                hasDiff = true;
            }
        });
        return hasDiff ? objDiff : null;
    },
    mergeDiff: function(winner, loser) {

        function addMetadata(obj, modifiedBy) {
            Object.keys(obj).forEach(function(key) {
                if (ignoreFields.indexOf(key) == -1) {
                    var val = obj[key];
                    if (val && typeof val === "object") {
                        addMetadata(val, modifiedBy);
                    } else {
                        numModifsLoser++;
                        obj.$metadata = obj.$metadata || {};
                        var prop = obj.$metadata[key] = obj.$metadata[key] || {};
                        prop.modifiedBy = modifiedBy;
                    }
                }
            });
        }

        function applyWinner(loser, winner) {
            var obj = loser.resource;
            Object.keys(winner.resource).forEach(function(key) {
                if (ignoreFields.indexOf(key) == -1) {
                    var val = winner.resource[key];
                    var loserVal = obj[key];
                    if (helpers.object.areEqual(val, loserVal)) {
                        //Not very usefull since they have input the same thing, but since winner wins...
                        numModifsLoser--;
                        obj.$metadata[key].modifiedBy = winner.modifiedBy;
                    } else {
                        var doModif = true;
                        if (val && typeof val === "object") {
                            if (loserVal) {
                                applyWinner({
                                    resource: loserVal,
                                    modifiedBy: loser.modifiedBy
                                }, {
                                    resource: val,
                                    modifiedBy: winner.modifiedBy
                                });
                                doModif = false;
                            }
                        }
                        if (doModif) {
                            obj.$metadata = obj.$metadata || {};
                            var prop = obj.$metadata[key] = obj.$metadata[key] || {};
                            if (prop.modifiedBy === loser.modifiedBy) {
                                prop.warning = prop.warning || [];
                                prop.warning.push("edit conflit");
                                numModifsLoser--;
                            }
                            prop.modifiedBy = winner.modifiedBy;
                            obj[key] = val;
                        }
                    }
                }
            });
        }

        var ignoreFields = ["$metadata"];
        var deleteFields = ["$action"];

        var numModifsLoser = 0;
        helpers.object.deleteProperties(winner.resource, deleteFields);
        helpers.object.deleteProperties(loser.resource, deleteFields);

        addMetadata(loser.resource, loser.modifiedBy);
        applyWinner(loser, winner);
        return {
            result: loser.resource,
            modifiedBy: numModifsLoser ? "both" : "winner"
        };
    },
    applyDiff: function(resource, diff, isChild) {
        if (!isChild) {
            resource = helpers.object.clone(resource, true);
        }
        if (!diff) return resource;
        Object.keys(diff).forEach(function(key) {
            var resVal = resource[key];
            var diffVal = diff[key];
            if (resVal == null) {
                resource[key] = diffVal;
                return;
            }
            if (key == "$undefined") {
                diffVal.forEach(function(k) {
                    delete resource[k];
                });
            } else {
                if (diffVal instanceof Array) {
                    if (diffVal.length && diffVal[0].$index) {
                        diffVal.forEach(function(v) {
                            var idx = v.$index - 1;
                            delete v.$index;
                            exports.resource.applyDiff(resource[key][idx], v, true)
                        });
                    } else {
                        resource[key] = diffVal.map(function(v) {
                            var idx = -1;
                            resVal.some(function(rv, i) {
                                if (rv.$url === v.$url) idx = i;
                            });
                            if (idx !== -1) {
                                exports.resource.applyDiff(resource[key][idx], v, true)
                                return resource[key][idx];
                            } else {
                                return v;
                            }
                        });
                    }
                } else {
                    if (typeof diffVal == "object") {
                        if (Object.prototype.hasOwnProperty.call(diffVal, "$url") && (diffVal.$url !== resVal.$url)) {
                            resource[key] = {};
                        }
                        exports.resource.applyDiff(resource[key], diffVal, true);
                    } else {
                        resource[key] = diffVal;
                    }
                }
            }
        });
        if (!isChild) {
            return resource;
        }
    },
    setMissingUrls: function(resource) {
        if (!resource || !resource.$url) return;
        if (resource.$resources) resource.$resources.forEach(function(res) {
            if (res.$key && !res.$url) res.$url = resource.$url + "('" + res.$key + "')";
        });
    },
    isTemplate: function(expression) {
        if (typeof expression != "string") return false;
        var result = _templatePattern.test(expression);
        return result;
    },
    applyTemplate: function(template, obj, fallbackObj) {
        if (!exports.resource.isTemplate(template)) {
            return template;
        }
        var matches = template.match(_templatePattern);
        if (!matches) return template;
        matches.forEach(function(match) {
            var expression = match.trim().substr(1, match.length - 2);
            var value = "";
            var path = exports.object.walkPath(obj, expression);
            if (path) {
                value = path.resource[path.property];
                if (typeof value == "undefined") {
                    path = exports.object.walkPath(fallbackObj, expression);
                    value = path.resource[path.property];
                }
            }
            template = template.replace(match, value);
        });
        return template;
    }
};

exports.uuid = require('./uuid');

exports.url = {
    // postify.js
    // Converts an object to an ASP.NET MVC model-binding-friendly format
    // Author: Nick Riggs
    // http://www.nickriggs.com
    postify: function(value) {
        var result = {};

        var buildResult = function(object, prefix) {
                helpers.object.forEachKey(object, function(key, val) {
                    if (val != null) {
                        // HACK: replace . by : in key to pass filters like xxx.yyy
                        var postKey = isFinite(key) ? (prefix != "" ? prefix : "") + "[" + key + "]" : (prefix != "" ? prefix + "." : "") + (typeof key == "string" && key.indexOf('.') > 0 ? key.replace('.', ':') : key);

                        switch (typeof val) {
                        case "number":
                        case "string":
                        case "boolean":
                            result[postKey] = val;
                            break;

                        case "object":
                            if (val.toUTCString) result[postKey] = val.toUTCString().replace("UTC", "GMT");
                            else {
                                buildResult(val, postKey != "" ? postKey : key);
                            }
                        }
                    }
                });
            };
        buildResult(value, "");

        return result;
    },
    formatValue: function(type, val) {
        if (val == null) return "!0!";
        switch (type) {
        case "boolean":
            return val ? "true" : "false";
        case "string":
            return "" + val;
        case "date":
        case "datetime":
        case "time":
            return val.toString();
        default:
            return "" + val;
        }
    },
    parseValue: function(type, str) {
        if (str == "!0!") return null;
        switch (type) {
        case "boolean":
            return str == "true";
        case "string":
            //helpers.debug.assert(str.charAt(0) == '!');
            return str;
        case "integer":
            return parseInt(str, 10);
        case "decimal":
            return parseFloat(str);
        case "date":
        case "datetime":
        case "time":
            return new Date(str);
        default:
            throw new Error("unsupported type: " + type);
        }

    },
    queryStringify: function(value, ignore) {
        ignore = ignore || [];
        var obj = helpers.url.postify(value);
        var result = '';
        helpers.object.forEachKey(obj, function(key, val) {
            if (val != null) {
                if (ignore.every(function(i) {
                    return key.indexOf(i) !== 0
                })) {
                    result += (result == '' ? '?' : '&') + key + '=' + encodeURIComponent(val);
                }
            }
        });
        return result;
    },
    parseOrderBy: function(str) {
        return (str ? str.split(',') : []).map(function(item) {
            var comps = item.split(' ');
            return {
                binding: comps[0],
                descending: comps[1] == 'desc'
            };
        });
    },
    formatOrderBy: function(orderBys) {
        return (orderBys || []).map(function(item) {
            return item.binding + (item.descending ? ' desc' : ' asc');
        }).join(',');
    },
    parseQueryString: function(str) {
        return (str || '').split('&').reduce(function(result, param) {
            var pair = param.split('=');
            result[pair[0]] = decodeURIComponent(pair[1]);
            return result;
        }, {});
    },
};

exports.http = {
    parseCookie: function(cookie) {
        var cookies = cookie || "";
        var res = {};
        cookies.split(";").forEach(function(cookie) {
            var parts = cookie.split("=");
            if ((parts.length >= 2) && parts[0] && parts[1]) {
                res[parts[0].trim()] = parts[1].trim();
            }
        });
        return res;
    }
};

exports.debug = {
    traces: {},
    assert: function(test) {
        if (!test) throw new Error("assertion failed");
    },
    traceReturn: function(tag, result) {
        print(tag + ": " + result);
        return result;
    },
    tracer: function(tag) {
        return helpers.debug.traces[tag] ? console.log : null;
    }
};

exports.log = {
    config: {},
    // obsolete, use traces instead
    exception: function(module, ex) {
        console.error("Exception: " + ex.message + "\n" + ex.stack);
    },
    error: function(module, message) {
        console.error(module.id + ": " + message);
    },
    warn: function(module, message) {
        console.warn(module.id + ": " + message);
    },
    info: function(module, message) {
        console.info(module.id + ": " + message);
    }
}

function _setResourceId(delta, original) {
    if (original.$uuid) delta.$uuid = original.$uuid;
    if (original.$url) delta.$url = original.$url;
    if (original.$key) delta.$key = original.$key;
}

function _isObjectResource(a, b) {
    if (a && a.$uuid) return true;
    if (b && b.$uuid) return true;
    return false;
}

function _isArrayResource(a, b) {
    if (a && a.length && a[0] && a[0].$uuid) return true;
    if (b && b.length && b[0] && b[0].$uuid) return true;
    return false;
}

//special delta : $deleteMissing && $isUndefined

function _deltaDollar(oldResource, newResource, dollar, delta) {
    var hasDiff = (dollar.length > 0);
    var oldIsNull = (oldResource.$properties == null);
    var newIsNull = (newResource.$properties == null);
    // add undefined values && deleteMissing
    if (dollar.length) {
        delta.$properties = delta.$properties || {};
        dollar.forEach(function(patch) {
            delta.$properties[patch.name] = delta.$properties[patch.name] || {};
            delta.$properties[patch.name][patch.key] = patch.value;
        });
    }
    if (oldIsNull && newIsNull) return;
    if (oldIsNull) {
        delta.$properties = delta.$properties || {};
        hasDiff = true;
        Object.keys(newResource.$properties).forEach(function(key) {
            if (delta.$properties[key]) helpers.object.extend(delta.$properties[key], newResource.$properties[key]);
            else delta.$properties[key] = newResource.$properties[key];
        });
    } else if (newIsNull) {
        if (!hasDiff) {
            delta.$properties = null;
            return true;
        }
        hasDiff = true;
        Object.keys(oldResource.$properties).forEach(function(key) {
            delta.$properties = delta.$properties || {};
            var newVal = delta.$properties[key];
            if (newVal) {
                var oldValue = oldResource.$properties[key]
                Object.keys(oldValue).forEach(function(key) {
                    if (newVal[key] == null) newVal[key] = null;
                });
            } else delta.$properties[key] = null;
        });
    } else {
        var cdelta = _sdataDiff(oldResource.$properties, newResource.$properties, false, false, true);
        if (cdelta) {
            if (hasDiff) {
                Object.keys(delta.$properties).forEach(function(key) {
                    var dvalue = cdelta[key];
                    if (typeof dvalue == "undefined") {
                        cdelta[key] = dvalue;
                    } else if (dvalue == null) {
                        cdelta[key] = delta.$properties[key];
                        var val = cdelta[key];
                        Object.keys(oldResource.$properties[key]).forEach(function(key) {
                            val[key] = null;
                        });
                        //
                    } else {
                        helpers.object.extend(dvalue, delta.$properties[key]);
                    }
                });
                delta.$properties = cdelta;
            } else {
                delta.$properties = cdelta;
            }
            hasDiff = true;
        }
    }
    return hasDiff;
}

function _sdataDiff(oldResource, newResource, top, isResource, isDollar) {
    var hasDiff = false,
        dollar = [];

    if (oldResource == null) {
        return helpers.object.clone(newResource);
    }
    var delta = {};
    if (top) {
        // Top level resource  :
        _setResourceId(delta, newResource);
        // if (newResource.$etag) delta.$etag = newResource.$etag;
        hasDiff = true;
    }
    //if (isResource) isResource = (newResource.$uuid != null) ;
    if (!isResource && !isDollar) {
        if (!helpers.object.areEqual(newResource, oldResource)) {
            return newResource;
        }
        return null;
    }
    if (!top && isResource) _setResourceId(delta, newResource);
    Object.keys(newResource).forEach(function(key) {
        var oldValue = oldResource[key];
        var newValue = newResource[key];
        // be optimist : oldValue === newValue
        if (oldValue === newValue) {} else if (typeof newValue != "object") {
            delta[key] = newValue;
            hasDiff = true;
        } else if ((newValue === null) || (oldValue == null)) {
            delta[key] = newValue;
            hasDiff = true;
        } else if (typeof newValue != "object") {
            delta[key] = newValue;
            hasDiff = true;
        } else {
            // newValue is an array or an object)
            if (Array.isArray(newValue)) {
                if (!_isArrayResource(newValue, oldValue)) {
                    if (!helpers.object.areEqual(oldValue, newValue)) {
                        delta[key] = newValue;
                        hasDiff = true;
                    }
                } else {
                    childDelta = _sdataArrayDiff(key, oldValue, newValue, dollar);
                    if (childDelta) {
                        delta[key] = childDelta;
                        hasDiff = true;
                    }
                }
            } else {
                if (key != "$properties") {
                    var childDelta = _sdataDiff(oldValue, newValue, false, isResource, isDollar);
                    if (childDelta) {
                        hasDiff = true;
                        delta[key] = childDelta;
                    }
                }
            }

        }
    });
    Object.keys(oldResource).forEach(function(key) {
        if (typeof newResource[key] == "undefined") {
            if (isResource) {
                if ((key != "$properties") && (key[0] != "$")) {
                    dollar.push({
                        name: key,
                        key: "$isUndefined",
                        value: true
                    });
                }
            } else delta[key] = null;
            hasDiff = true;
        }
    });
    if (isResource) {
        hasDiff = _deltaDollar(oldResource, newResource, dollar, delta, true) || hasDiff;
    }
    return hasDiff ? delta : null;
}

function _sdataArrayDiff(resourceName, oldResource, newResource, dollar) {
    //Sub-resources that appear inside a list MUST carry a $uuid attribute
    //They MAY carry $url and $key attributes
    /*
     * Syracuse distinguishes two cases for list deltas:
     * 1. The order of the elements did not change. New elements may be inserted in the list and some elements may be removed too.
     *     What matters is that the elements that remain in the list remain in the same order relative to each other.
     * 2. The order did change. There is at least one pair of elements which was in a certain order in the list before and which is in the opposite order after the change.
     */
    var diff = [],
        newLen = newResource.length,
        oldLen = oldResource.length;
    var orderChanged = false;
    if (newLen == 0) {
        if (newLen == oldLen) return null;
        // delete all elements
        oldResource.forEach(function(value, index) {
            var delta = {};
            _setResourceId(delta, value);
            delta.$isDeleted = true;
            delta.$index = 0;
            diff.push(delta);
        });
        return diff;
    } else if (oldLen == 0) {
        newResource.forEach(function(value, index) {
            value = helpers.object.clone(value, false);
            value.$index = index;
            diff.push(value);
        });
        return diff;
    }
    var hasDiff = false;
    var oldMap = {},
        newMap = {}; // used for fast find
    var prevUID = "";
    newResource.forEach(function(value, index) {
        newMap[value.$uuid] = index + 1;
    });
    oldResource.forEach(function(value, index) {
        oldMap[value.$uuid] = index + 1;
        if (!newMap[value.$uuid]) {
            hasDiff = true; // deleted
        } else if (!orderChanged) {
            if (prevUID) {
                orderChanged = (newMap[prevUID] > newMap[value.$uuid]);
            }
            prevUID = value.$uuid;
        }
    });
    if (orderChanged) {
        hasDiff = true;
        newResource.forEach(function(child, index) {
            var oldIndex = oldMap[child.$uuid];
            if (oldIndex) {
                var delta = _sdataDiff(oldResource[oldIndex - 1], child, false, true, false);
                if (!delta) {
                    delta = {};
                    _setResourceId(delta, child);
                }
                diff.push(delta);
            } else diff.push(child);
        });
        dollar.push({
            name: resourceName,
            key: "$deleteMissing",
            value: true
        })
    } else {
        var progressIndex = 0;
        var _delete = function(di) {
                var si = progressIndex;
                for (var i = si; i < oldLen; i++) {
                    if (!newMap[oldResource[i].$uuid]) {
                        progressIndex++;
                        var delta = {};
                        _setResourceId(delta, oldResource[i]);
                        delta.$isDeleted = true;
                        delta.$index = di;
                        diff.push(delta);
                    } else {
                        break;
                    }
                }
            };
        newResource.forEach(function(child, index) {
            var oldIndex = oldMap[child.$uuid];
            if (!oldIndex) {
                _delete(index);
                hasDiff = true;
                child = helpers.object.clone(child, true);
                child.$index = index;
                diff.push(child);
            } else {
                _delete(index);
                progressIndex = oldIndex;
                var delta = _sdataDiff(oldResource[oldIndex - 1], child, false, true, false);
                if (delta) {
                    hasDiff = true;
                    diff.push(delta);
                    delta.$index = index;
                }
            }
        });
        _delete(newLen);
    }
    return hasDiff ? diff : null;
}

function _sdataMerge(resource, delta, isResource) {
    if (resource == null) return delta;
    if (delta == null) return resource;
    //if (isResource) isResource = (delta.$uuid != null);
    if (!isResource) {
        return helpers.object.clone(delta, true);
    }
    var dollar = resource.$properties;
    delete resource.$properties;
    var newResource = helpers.object.clone(resource, false);
    resource.$properties = dollar;
    dollar = delta.$properties;
    var resDollar = (dollar ? helpers.object.clone(dollar, true) : dollar);
    delete delta.$properties;
    Object.keys(delta).forEach(function(key) {
        var deltaValue = delta[key];
        if (typeof deltaValue == "object" && deltaValue !== null) {
            if (Array.isArray(deltaValue)) {
                var meta = (resDollar && resDollar[key]) ? resDollar[key] : undefined;
                newResource[key] = _sdataArrayMerge(resource[key], deltaValue, meta);
            } else {
                newResource[key] = _sdataMerge(resource[key], deltaValue, true);
            }

        } else newResource[key] = deltaValue;
    });
    if (isResource) {
        _mergeDollar(resource.$properties, resDollar, newResource);
    }
    if (dollar) delta.$properties = dollar;
    return newResource;
}

function _mergeDollar(resDollar, deltaDollar, result) {
    if (deltaDollar === null) return; //
    var delta = resDollar || {};
    if (deltaDollar) {
        Object.keys(deltaDollar).forEach(function(key) {
            var value = deltaDollar[key];
            if (value === null) {
                delete delta[key];
            } else {
                if (typeof value == "object" && !Array.isArray(value)) {
                    if (value.$isUndefined) {
                        delete result[key];
                    }
                    delete value.$isUndefined;
                    delta[key] = delta[key] || {};
                    Object.keys(value).forEach(function(skey) {
                        if (value[skey] === null) delete delta[key][skey];
                        else delta[key][skey] = value[skey];

                    });
                } else delta[key] = value;
            }
        });
    } else if (deltaDollar == null) {
        // undefined
        if (resDollar) result.$properties = resDollar;
        return;
    }
    var keys = Object.keys(delta);
    var len = keys.length;
    // cleanup empty objects
    keys.forEach(function(key) {
        var value = delta[key];
        if (typeof value == "object" && !Array.isArray(value)) {
            if (Object.keys(value).length == 0) {
                len--;
                delete delta[key];
            }
        }
    });
    if (len) result.$properties = delta;
}

function _sdataArrayMerge(resource, deltaValue, meta) {
    var res = [];
    var map = {};
    if (!resource) return deltaValue;
    if (meta && meta.$deleteMissing) {
        deltaValue.forEach(function(value, index) {
            res.push(value);
            map[value.$uuid] = res.length;
        });
        resource.forEach(function(value, index) {
            if (map[value.$uuid]) {
                var delta = res[map[value.$uuid] - 1];
                res[map[value.$uuid] - 1] = _sdataMerge(value, delta, true);
            }
        });
        delete meta.$deleteMissing;
    } else {
        // same order
        resource.forEach(function(value, index) {
            res.push(value);
            map[value.$uuid] = value;
        });
        deltaValue.forEach(function(value, index) {
            if (value.$isDeleted) {
                res.splice(value.$index, 1);
                delete value.$index;
            } else if (typeof value.$index == "undefined") {
                res.push(value);
                delete value.$index;
            } else {
                var add = (value.$index >= res.length);
                if (!add) add = (map[value.$uuid] == null);
                if (add) {
                    res.splice(value.$index, 0, value);
                    delete value.$index;
                } else {
                    var oldvalue = res[value.$index];
                    res[value.$index] = _sdataMerge(oldvalue, value, true);
                    delete res[value.$index].$index;
                }

            }
        });
    }
    return res;
}

exports.resource.sdataDelta = function(oldResource, newResource) {
    return _sdataDiff(oldResource, newResource, true, true, false)
};
exports.resource.sdataMerge = function(oldResource, delta) {
    return _sdataMerge(oldResource, delta, true, true)
};
/*
 exports.hacked = console.error;
 function hack(obj){
 if (!obj || typeof obj !== 'object')
 return obj;
 if (obj.$ !== undefined) {
 exports.hacked("FOUND $");
 obj.$properties = obj.$;
 delete obj.$;
 }
 if (obj.$type === 'application/x-collection') {
 exports.hacked("FOUND x-collection");
 obj.$type = 'application/x-array';
 }
 if (obj.$constraints) {
 exports.hacked("FOUND $constraints");
 Object.keys(obj.$constraints).forEach(function(k){
 obj[k] = obj.$constraints[k];
 });
 delete obj.$constraints;
 }
 Object.keys(obj).forEach(function(k){
 obj[k] = hack(obj[k]);
 });
 return obj;
 }

 var JSONparse = JSON.parse;
 JSON.parse = function(){
 var result = JSONparse.apply(JSON, arguments);
 // result = hack(result);
 return result;
 }*/