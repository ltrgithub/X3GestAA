"use strict";
var helpers = exports;

/*if (!global.console) { // be safe, maybe we need this in IE
 global.console = {
 error: alert,
 warn: alert,
 info: alert,
 log: alert
 };
 }*/
function _addMembers(proto, members) {
	for (var name in members || {}) {
		var member = members[name];
		if (typeof member.get === "function" || typeof member.set === "function") {
			Object.defineProperty(proto, name, member);
			//if (member.get)
			//  proto.__defineGetter__(name, member.get);
			//if (member.set)
			//  proto.__defineSetter__(name, member.set);
		} else {
			proto[name] = member;
		}
	}
}

exports.defineClass = function(constructor, parent, members) {
	// avoid parent invocation to copy prototype
	//	if (parent) constructor.prototype = new parent();
	// Note: testing function name is fragile but there is no reliable API to do it yet.
	if (Object.getPrototypeOf(constructor).name === "GeneratorFunctionPrototype" && //
		parent &&
		Object.getPrototypeOf(parent).name !== "GeneratorFunctionPrototype") {
		// eval because syntax is invalid without --harmony switch
		parent = eval("(function*() { return parent.apply(this, arguments); })");
	}
	if (parent)
		constructor.prototype = Object.create(parent.prototype);
	//
	// try/catch for streamline generators-fast mode
	try {
		constructor.prototype.constructor = constructor;
	} catch (ex) {};
	_addMembers(constructor.prototype, members);
	return constructor;
};
exports.defineClassEx = function(constructor, parent, extraMembers, members) {
	var constuct = exports.defineClass(constructor, parent, members);
	if (extraMembers) {
		(!Array.isArray(extraMembers) ? _addMembers(constuct.prototype, extraMembers) : extraMembers.forEach(function(v, i) {
			_addMembers(constuct.prototype, v);
		}));
	}
	return constuct;
};
exports.object = {
	deleteProperties: function(obj, properties) {
		if (!obj)
			return;
		Object.keys(obj).forEach(function(key) {
			if (properties.indexOf(key) !== -1) {
				delete obj[key];
			} else {
				if (obj[key] != null && typeof obj[key] == "object") {
					exports.object.deleteProperties(obj[key], properties);
				}
			}
		});
	},
	find: function(obj, key) {
		if (obj == null)
			throw new Error("find error: container is null, key=" + key);
		var val = obj[key];
		if (val == null)
			throw new Error("key not found: " + key);
		return val;
	},
	get: function(obj, key, failIfNull) {
		return failIfNull ? helpers.object.find(obj, key) : (obj ? obj[key] : null);
	},
	copy: function(src, dst) {
		helpers.object.forEachKey(src, function(key, val) {
			dst[key] = val;
		});
		return dst;
	},
	extend: function(src, ext, override, deep) {
		src = src || {};
		helpers.object.forEachKey(ext, function(key, val) {
			if (deep && typeof src[key] === "object" && src[key] !== null) {
				src[key] = src[key] || {};
				helpers.object.extend(src[key], val, override, deep);
			} else
			if (src[key] == null || override) {
				src[key] = val;
			}
		});
		return src;
	},
	extendEx: function(obj) {
		(Array.prototype.slice.call(arguments, 1)).forEach(function(source) {
			for (var prop in source) {
				obj[prop] = source[prop];
			}
		});
		return obj;
	},
	merge: function(src, dst) {
		var differs = false;
		helpers.object.forEachKey(src, function(key, val) {
			var dstVal = dst[key];
			if (typeof dstVal == "undefined")
				dst[key] = val;
			else
			if (val != dstVal && !helpers.object.areEqual(val, dstVal))
				differs = true;
		});
		return differs;
	},
	clone: function(obj, deep) {
		if (!obj || typeof obj != "object")
			return obj;
		if (obj instanceof Date)
			return obj;
		var clone;
		//if (obj instanceof Array) {
		if (Array.isArray(obj)) {
			clone = [];
			for (var i = 0; i < obj.length; i++)
				clone.push(deep ? helpers.object.clone(obj[i], deep) : obj[i]);
			return clone;
		}
		clone = {};
		helpers.object.forEachKey(obj, function(key, val) {
			clone[key] = deep ? helpers.object.clone(val, deep) : val;
		});
		return clone;
	},
	has: function(obj, key) {
		return Object.prototype.hasOwnProperty.call(obj, key);
	},
	forEachKey: function(object, body) {
		for (var key in object)
			if (helpers.object.has(object, key))
				body(key, object[key]);
	},
	isFunction: function(obj) {
		return !!(obj && obj.constructor && obj.call && obj.apply);
	},
	toArray: function(object, body) {
		var result = [];
		for (var key in object) {
			if (helpers.object.has(object, key)) {
				var val = body(key, object[key]);
				if (val !== undefined)
					result.push(val);
			}
		}
		return result;
	},
	areEqual: function(obj1, obj2) {
		if (obj1 == obj2)
			return true;
		if (obj1 == null || obj2 == null)
			return false;
		if (Array.isArray(obj1) && Array.isArray(obj2)) {
			if (obj1.length != obj2.length)
				return false;
			for (var i = 0; i < obj1.length; i++)
				if (!helpers.object.areEqual(obj1[i], obj2[i]))
					return false;
			return true;
		}

		if (typeof obj1 != "object" || typeof obj2 != "object")
			return false;
		//var combined = $.extend({}, obj1, obj2);
		var combined = helpers.object.extend({}, obj1);
		helpers.object.extend(combined, obj2);
		for (var i in combined) {
			if (helpers.object.has(combined, i)) {
				var val1 = obj1[i];
				var val2 = obj2[i];
				if (!helpers.object.areEqual(val1, val2))
					return false;
			}
		}
		return true;
	},
	// Walks along a property path.
	// Returns the leaf information (descendant resource + its property).
	walkPath: function(resource, path) {
		if (resource == null)
			return null;
		var paths = path.split('.');
		var property = paths.pop();
		var instance = resource;
		for (var i = 0; i < paths.length; i++) {
			var p = paths[i];
			if (p.trim() === '')
				continue;
			if (p.indexOf('[') !== -1) {
				// Array case
				var ps = p.split('[');
				instance = instance[ps.shift()];
				if (instance == null)
					return null;
				for (var j = 0; j < ps.length; j++) {
					instance = instance[ps[j].substring(0, ps[j].length - 1)];
				}
			} else {
				instance = instance[p];
			}
			if (instance == null)
				return null;
		}
		if (property.indexOf('[') !== -1) {
			var ps = property.split('[');
			instance = instance[ps.shift()];
			if (instance == null)
				return null;
			for (var j = 0; j < ps.length - 1; j++) {
				instance = instance[ps[j].substring(0, ps[j].length - 1)];
			}
			property = ps[j].substring(0, ps[j].length - 1);
		}
		return {
			resource: instance,
			property: property
		};
	},
	evalPath: function(resource, path) {
		var walked = helpers.object.walkPath(resource, path);
		return walked && walked.resource ? walked.resource[walked.property] : null;
	},
	stringify: function(obj) {
		var seen = [];

		return JSON.stringify(obj, function(key, val) {
			if (typeof val === "object") {
				if (seen.indexOf(val) >= 0)
					return undefined;
				seen.push(val);
			}
			return val;
		});
	},
	traverse: function(obj, visitor, key) {
		var seen = [];

		if (helpers.object.isFunction(visitor)) {
			visitor = {
				visit: visitor
			};
		}

		if (!obj || typeof obj != "object") {
			visitor.visitLeaf && visitor.visitLeaf(key, obj);
			return;
		}
		if (obj instanceof Date)
			return;
		if (Array.isArray(obj)) {
			for (var i = 0; i < obj.length; i++) {
				helpers.object.traverse(obj[i], visitor, key);
			}
			return;
		}
		helpers.object.forEachKey(obj, function(key, val) {
			if (visitor.visit(key, val)) {
				if (typeof val === "object" && seen.indexOf(val) < 0) {
					seen.push(val);
					helpers.object.traverse(val, visitor, key);
				}
				visitor.leave && visitor.leave(key, val);
			}
		});
	}
};

exports.array = {
	ensureArray: function(obj) {
		if (obj == null)
			return [];
		if (!Array.isArray(obj))
			return [obj];
		return obj;
	}
};

exports.string = {
	pluralize: function(str) {
		// special treatment for y and f preceded with consonant and for s
		if (/(sh?|ch)$/.test(str))
			return str + "es";
		if (/[b-df-hj-np-tv-z]y$/.test(str))
			return str.substring(0, str.length - 1) + "ies";
		if (/[b-df-hj-np-tv-z]f$/.test(str))
			return str.substring(0, str.length - 1) + "ves";
		return str + "s";
	},
	capitalize: function(str) {
		if (str && str.length > 0)
			str = str.charAt(0).toUpperCase() + str.substring(1);
		return str;
	},
	makeLabel: function(str) {
		for (var i = 0; i < str.length; i++) {
			var ch = str.charAt(i);
			if (ch == ch.toUpperCase())
				return str.substring(0, i) + " " + ch.toLowerCase() + helpers.string.makeLabel(str.substring(i + 1));
		}
		return str;
	},
	formatValue: function(item, val) {
		// TODO: enhance with item.format leater
		if (val == null)
			return "";
		if (item == null)
			return val.toString();
		switch (item.$type) {
			case "date":
				return val.substring(0, 10);
			case "boolean":
				return val ? "yes" : "no";
			default:
				return val.toString();
		}
	},
	parseValue: function(item, str) {
		if (str == null || str == "")
			return str;
		switch (item.type) {
			case "integer":
				return typeof str === "string" ? parseInt(str, 10) : str;
			case "real":
				return typeof str === "string" ? parseFloat(str) : str;
			case "date":
				return str + " 00:00:00";
			case "boolean":
				return str == "1" || str == "yes" || str == "true";
			default:
				return str;
		}
	},
	padLeft: function(str, len, ch) {
		str = str ? str.toString() : '';
		if (!ch || ch.length == 0)
			ch = " ";
		while (str.length < len)
			str = ch + str;
		return str;
	},
	trim: function(str) {
		if (str == null)
			return str;
		var begin = 0;
		var end = str.length;
		while (begin < str.length && str.charAt(begin) == ' ')
			begin++;
		while (end > begin && str.charAt(end - 1) == ' ')
			end--;
		return str.substring(begin, end);
	},
	trimRight: function(str) {
		if (str == null)
			return str;
		var end = str.length;
		while (end > 0 && str.charAt(end - 1) == ' ')
			end--;
		return str.substring(0, end);
	},
	checkName: function(name) {
		if (name == null || name.length == 0)
			throw new Error("invalid name: missing or empty");
		if (typeof name != "string")
			throw new Error("invalid name: type=" + typeof name);

		if (name.match(/[A-Z][A-Z0-9_\-]*/i) != name)
			throw new Error("name does not match required pattern: " + name);
	},
	checkPath: function(path) {
		if (path == null || path.length == 0) {
			throw new Error("invalid path: missing or empty");
		}
		if (path.match(/[A-Z][A-Z0-9_]*(?:[.][A-Z][A-Z0-9_]*)*/i) != path)
			throw new Error("path does not match required pattern: " + path);
	},
	sqlQuote: function(str) {
		return str && ("'" + str.replace(/'/g, "''") + "'");
	},
	compare: function(s1, s2, ignoreCase) {
		if (ignoreCase) {
			s1 = s1.toUpperCase();
			s2 = s2.toUpperCase();
		}
		return s1 == s2 ? 0 : s1 < s2 ? -1 : +1;
	},
	labelSeparator: ' :',
	htmlEscape: function(str) {
		var htmlEscaper = /[&<>"'\/]/g,
			htmlEscapes = {
				'&': '&amp;',
				'<': '&lt;',
				'>': '&gt;',
				'"': '&quot;',
				"'": '&#x27;',
				'/': '&#x2F;'
			};
		return (str).replace(htmlEscaper, function(match) {
			return htmlEscapes[match];
		});
	}
};

var _templatePattern = /(\{.*?\})/g;

exports.resource = {
	create: function(url) {
		return {
			$url: url || ("urn:uuid:" + helpers.uuid.generate())
		};
	},
	syracuseProperties: ["$serverOld", "$clientOld"],

	stringify: function(resource) {
		return JSON.stringify(resource, function(key, value) {
			if (exports.resource.syracuseProperties.indexOf(key) != -1)
				return;
			else
				return value;
		});
	},
	addError: function(resource, uuid, property, message) {
		var errors = resource.$errors || (resource.$errors = {});
		var uuidErrors = errors[uuid] || (errors[uuid] = []);
		uuidErrors.push({
			property: property,
			severity: "error",
			message: message
		});
	},
	diff: function(oldResource, newResource) {
		if (oldResource == null)
			return newResource;

		var hasDiff = false;
		var objDiff = {
			$url: oldResource.$url
		};
		Object.keys(newResource).forEach(function(key) {
			var oldValue = oldResource[key];
			var newValue = newResource[key];
			if (oldValue == null && oldValue !== newValue) {
				objDiff[key] = newResource[key];
				hasDiff = true;
			} else {
				if (typeof newValue == "object") {
					if (!helpers.object.areEqual(oldValue, newValue)) {
						hasDiff = true;
						if (Array.isArray(newValue) &&
							newValue.every(function(item) {
								return Object.prototype.hasOwnProperty.call(item, "$key");
							})) {
							objDiff[key] = [];
							if (oldValue.reduce(function(a, b) {
									return a.$url + b.$url;
								}) !==
								newValue.reduce(function(a, b) {
									return a.$url + b.$url;
								})) {
								//the list has changed
								objDiff[key] = newValue.map(function(v, i) {
									var oldVal = oldValue.filter(function(ov) {
										return ov.$url === v.$url;
									});
									if (oldVal.length) {
										var diff = exports.resource.diff(oldVal[0], v);
										return diff || {
											$url: v.$url
										};
									} else {
										return v;
									}
								});
							} else {
								//the list has not changed, so it's a sub resource.
								objDiff[key] = [];
								newValue.forEach(function(v, i) {
									var diff = exports.resource.diff(oldValue[i], v);
									if (diff) {
										diff.$index = i + 1;
										if (oldValue[i].$url === v.$url) {
											delete diff.$url;
										}
										objDiff[key].push(diff);
									}
								});
							}
						} else {
							if (Object.prototype.hasOwnProperty.call(newValue, "$url")) { //this is a resource
								if (oldValue.$url !== newValue.$url) {
									objDiff[key] = newValue;
								} else {
									objDiff[key] = exports.resource.diff(oldValue, newValue);
								}
							} else {
								objDiff[key] = newValue;
							}
						}
					}
				} else {
					if (oldValue !== newValue) {
						objDiff[key] = newValue;
						hasDiff = true;
					}
				}
			}
		});
		Object.keys(oldResource).forEach(function(key) { //New properties
			if (typeof newResource[key] == "undefined") {
				if (objDiff["$undefined"] == null) {
					objDiff["$undefined"] = [];
				}
				objDiff["$undefined"].push(key);
				hasDiff = true;
			}
		});
		return hasDiff ? objDiff : null;
	},
	mergeDiff: function(winner, loser) {

		function addMetadata(obj, modifiedBy) {
			Object.keys(obj).forEach(function(key) {
				if (ignoreFields.indexOf(key) == -1) {
					var val = obj[key];
					if (val && typeof val === "object") {
						addMetadata(val, modifiedBy);
					} else {
						numModifsLoser++;
						obj.$metadata = obj.$metadata || {};
						var prop = obj.$metadata[key] = obj.$metadata[key] || {};
						prop.modifiedBy = modifiedBy;
					}
				}
			});
		}

		function applyWinner(loser, winner) {
			var obj = loser.resource;
			Object.keys(winner.resource).forEach(function(key) {
				if (ignoreFields.indexOf(key) == -1) {
					var val = winner.resource[key];
					var loserVal = obj[key];
					if (helpers.object.areEqual(val, loserVal)) {
						//Not very usefull since they have input the same thing, but since winner wins...
						numModifsLoser--;
						obj.$metadata[key].modifiedBy = winner.modifiedBy;
					} else {
						var doModif = true;
						if (val && typeof val === "object") {
							if (loserVal) {
								applyWinner({
									resource: loserVal,
									modifiedBy: loser.modifiedBy
								}, {
									resource: val,
									modifiedBy: winner.modifiedBy
								});
								doModif = false;
							}
						}
						if (doModif) {
							obj.$metadata = obj.$metadata || {};
							var prop = obj.$metadata[key] = obj.$metadata[key] || {};
							if (prop.modifiedBy === loser.modifiedBy) {
								prop.warning = prop.warning || [];
								prop.warning.push("edit conflit");
								numModifsLoser--;
							}
							prop.modifiedBy = winner.modifiedBy;
							obj[key] = val;
						}
					}
				}
			});
		}

		var ignoreFields = ["$metadata"];
		var deleteFields = ["$action"];

		var numModifsLoser = 0;
		helpers.object.deleteProperties(winner.resource, deleteFields);
		helpers.object.deleteProperties(loser.resource, deleteFields);

		addMetadata(loser.resource, loser.modifiedBy);
		applyWinner(loser, winner);
		return {
			result: loser.resource,
			modifiedBy: numModifsLoser ? "both" : "winner"
		};
	},
	applyDiff: function(resource, diff, isChild) {
		if (!isChild) {
			resource = helpers.object.clone(resource, true);
		}
		if (!diff)
			return resource;
		Object.keys(diff).forEach(function(key) {
			var resVal = resource[key];
			var diffVal = diff[key];
			if (resVal == null) {
				resource[key] = diffVal;
				return;
			}
			if (key == "$undefined") {
				diffVal.forEach(function(k) {
					delete resource[k];
				});
			} else {
				if (Array.isArray(diffVal)) {
					if (diffVal.length && diffVal[0].$index) {
						diffVal.forEach(function(v) {
							var idx = v.$index - 1;
							delete v.$index;
							exports.resource.applyDiff(resource[key][idx], v, true);
						});
					} else {
						resource[key] = diffVal.map(function(v) {
							var idx = -1;
							resVal.some(function(rv, i) {
								if (rv.$url === v.$url)
									idx = i;
							});
							if (idx !== -1) {
								exports.resource.applyDiff(resource[key][idx], v, true);
								return resource[key][idx];
							} else {
								return v;
							}
						});
					}
				} else {
					if (typeof diffVal == "object") {
						if (Object.prototype.hasOwnProperty.call(diffVal, "$url") && (diffVal.$url !== resVal.$url)) {
							resource[key] = {};
						}
						exports.resource.applyDiff(resource[key], diffVal, true);
					} else {
						resource[key] = diffVal;
					}
				}
			}
		});
		if (!isChild) {
			return resource;
		}
	},
	setMissingUrls: function(resource) {
		if (!resource || !resource.$url)
			return;
		if (resource.$resources)
			resource.$resources.forEach(function(res) {
				if (res.$key && !res.$url)
					res.$url = resource.$url + "('" + res.$key + "')";
			});
	},
	isTemplate: function(expression) {
		if (typeof expression != "string")
			return false;
		var result = _templatePattern.test(expression);
		return result;
	},
	applyTemplate: function(template, obj, fallbackObj) {
		if (!exports.resource.isTemplate(template)) {
			return template;
		}
		var matches = template.match(_templatePattern);
		if (!matches)
			return template;
		matches.forEach(function(match) {
			var expression = match.trim().substr(1, match.length - 2);
			var value = "";
			var path = exports.object.walkPath(obj, expression);
			if (path) {
				value = path.resource[path.property];
				if (typeof value == "undefined") {
					path = exports.object.walkPath(fallbackObj, expression);
					value = path.resource[path.property];
				}
			}
			template = template.replace(match, value);
		});
		return template;
	}
};

exports.uuid = require('./uuid');

exports.url = {
	// postify.js
	// Converts an object to an ASP.NET MVC model-binding-friendly format
	// Author: Nick Riggs
	// http://www.nickriggs.com
	postify: function(value) {
		var result = {};

		var buildResult = function(object, prefix) {
			helpers.object.forEachKey(object, function(key, val) {
				if (val != null) {
					// HACK: replace . by : in key to pass filters like xxx.yyy
					var postKey = isFinite(key) ? (prefix != "" ? prefix : "") + "[" + key + "]" : (prefix != "" ? prefix + "." : "") + (typeof key == "string" && key.indexOf('.') > 0 ? key.replace('.', ':') : key);

					switch (typeof val) {
						case "number":
						case "string":
						case "boolean":
							result[postKey] = val;
							break;

						case "object":
							if (val.toUTCString)
								result[postKey] = val.toUTCString().replace("UTC", "GMT");
							else {
								buildResult(val, postKey != "" ? postKey : key);
							}
					}
				}
			});
		};
		buildResult(value, "");

		return result;
	},
	formatValue: function(type, val) {
		if (val == null)
			return "!0!";
		switch (type) {
			case "boolean":
				return val ? "true" : "false";
			case "string":
				return "" + val;
			case "date":
			case "datetime":
			case "time":
				return val.toString();
			default:
				return "" + val;
		}
	},
	parseValue: function(type, str) {
		if (str == "!0!")
			return null;
		switch (type) {
			case "boolean":
				return str == "true";
			case "string":
				//helpers.debug.assert(str.charAt(0) == '!');
				return str;
			case "integer":
				return parseInt(str, 10);
			case "decimal":
				return parseFloat(str);
			case "date":
			case "datetime":
			case "time":
				return new Date(str);
			default:
				throw new Error("unsupported type: " + type);
		}

	},
	queryStringify: function(value, ignore) {
		ignore = ignore || [];
		var obj = helpers.url.postify(value);
		var result = '';
		helpers.object.forEachKey(obj, function(key, val) {
			if (val != null) {
				if (ignore.every(function(i) {
					return key.indexOf(i) !== 0;
				})) {
					result += (result == '' ? '?' : '&') + key + '=' + encodeURIComponent(val);
				}
			}
		});
		return result;
	},
	parseOrderBy: function(str) {
		return (str ? str.split(',') : []).map(function(item) {
			var comps = item.split(' ');
			return {
				binding: comps[0],
				descending: comps[1] == 'desc'
			};
		});
	},
	formatOrderBy: function(orderBys) {
		return (orderBys || []).map(function(item) {
			return item.binding + (item.descending ? ' desc' : ' asc');
		}).join(',');
	},
	parseQueryString: function(str) {
		return (str || '').split('&').reduce(function(result, param) {
			var pair = param.split('=');
			result[pair[0]] = decodeURIComponent(pair[1]);
			return result;
		}, {});
	},
	parseUrl: function(url) {
		var _split = url.split("?");
		var _parser = {
			url: url,
			segments: url.split("/")
		};
		_parser.path = _split.splice(0, 1)[0];
		_parser.rawQuery = _split.join('?');
		_parser.query = exports.url.parseQueryString(_parser.rawQuery);
		var _segments = _parser.path.split('/').map(function(seg) {
			return decodeURIComponent(seg);
		});
		var _segI = 1; // start after leading /
		_parser.walkUrl = function() {
			return _segments[_segI++];
		};
		_parser.unwalkUrl = function() {
			_segI--;
		};
		_parser.walked = function() {
			return _segments.slice(0, _segI).join("/");
		};
		_parser.toWalk = function() {
			return _segments.slice(_segI).join("/");
		};
		//
		return _parser;
	},
	decodeDetailSegment: function(segment) {
		var match = /^([^\/(]*)\((.*)\)$/.exec(segment);
		if (match) {
			var res = {
				name: match[1]
			};
			if (match[2]) {
				if (match[2][0] !== "'") {
					res.id = match[2];
					res.isExpressionId = true;
				} else {
					res.id = match[2].substring(1, match[2].length - 1);
					res.isExpressionId = false;
				}
			}
			return res;
		} else
			return null;
	}
};

exports.http = {
	parseCookie: function(cookie) {
		var cookies = cookie || "";
		var res = {};
		cookies.split(";").forEach(function(cookie) {
			var parts = cookie.split("=");
			if ((parts.length >= 2) && parts[0] && parts[1]) {
				res[parts[0].trim()] = parts[1].trim();
			}
		});
		return res;
	}
};

exports.debug = {
	traces: {},
	assert: function(test) {
		if (!test)
			throw new Error("assertion failed");
	},
	traceReturn: function(tag, result) {
		print(tag + ": " + result);
		return result;
	},
	tracer: function(tag) {
		return helpers.debug.traces[tag] ? console.log : null;
	}
};

exports.log = {
	config: {},
	// obsolete, use traces instead
	exception: function(module, ex) {
		console.error("Exception: " + ex.message + "\n" + ex.stack);
	},
	error: function(module, message) {
		console.error(module.id + ": " + message);
	},
	warn: function(module, message) {
		console.warn(module.id + ": " + message);
	},
	info: function(module, message) {
		console.info(module.id + ": " + message);
	}
};

function _setResourceId(delta, original) {
	if (original.$uuid)
		delta.$uuid = original.$uuid;
	if (original.$url)
		delta.$url = original.$url;
	if (original.$key)
		delta.$key = original.$key;
}

function _isObjectResource(a, b) {
	if (a && a.$uuid)
		return true;
	if (b && b.$uuid)
		return true;
	return false;
}

function _isArrayResource(a, b) {
	if (a && a.length && a[0] && a[0].$uuid)
		return true;
	if (b && b.length && b[0] && b[0].$uuid)
		return true;
	return false;
}

//special delta : $deleteMissing && $isUndefined

function _deltaDollar(oldResource, newResource, dollar, delta) {
	var hasDiff = (dollar.length > 0);
	var oldIsNull = (oldResource.$properties == null);
	var newIsNull = (newResource.$properties == null);
	// add undefined values && deleteMissing
	if (dollar.length) {
		delta.$properties = delta.$properties || {};
		dollar.forEach(function(patch) {
			delta.$properties[patch.name] = delta.$properties[patch.name] || {};
			delta.$properties[patch.name][patch.key] = patch.value;
		});
	}
	if (oldIsNull && newIsNull)
		return;
	if (oldIsNull) {
		delta.$properties = delta.$properties || {};
		hasDiff = true;
		Object.keys(newResource.$properties).forEach(function(key) {
			if (delta.$properties[key])
				helpers.object.extend(delta.$properties[key], newResource.$properties[key]);
			else
				delta.$properties[key] = newResource.$properties[key];
		});
	} else
	if (newIsNull) {
		if (!hasDiff) {
			delta.$properties = null;
			return true;
		}
		hasDiff = true;
		Object.keys(oldResource.$properties).forEach(function(key) {
			delta.$properties = delta.$properties || {};
			var newVal = delta.$properties[key];
			if (newVal) {
				var oldValue = oldResource.$properties[key];
				Object.keys(oldValue).forEach(function(key) {
					if (newVal[key] == null)
						newVal[key] = null;
				});
			} else
				delta.$properties[key] = null;
		});
	} else {
		var cdelta = _sdataDiff(oldResource.$properties, newResource.$properties, false, false, true);
		if (cdelta) {
			if (hasDiff) {
				Object.keys(delta.$properties).forEach(function(key) {
					var dvalue = cdelta[key];
					if (typeof dvalue == "undefined") {
						cdelta[key] = dvalue;
					} else
					if (dvalue == null) {
						cdelta[key] = delta.$properties[key];
						var val = cdelta[key];
						Object.keys(oldResource.$properties[key]).forEach(function(key) {
							val[key] = null;
						});
						//
					} else {
						helpers.object.extend(dvalue, delta.$properties[key]);
					}
				});
				delta.$properties = cdelta;
			} else {
				delta.$properties = cdelta;
			}
			hasDiff = true;
		}
	}
	return hasDiff;
}

function _sdataDiff(oldResource, newResource, top, isResource, isDollar) {
	var hasDiff = false,
		dollar = [];

	if (oldResource == null) {
		return helpers.object.clone(newResource);
	}
	var delta = {};
	if (top) {
		// Top level resource  :
		_setResourceId(delta, newResource);
		// if (newResource.$etag) delta.$etag = newResource.$etag;
		hasDiff = true;
	}
	//if (isResource) isResource = (newResource.$uuid != null) ;
	if (!isResource && !isDollar) {
		if (!helpers.object.areEqual(newResource, oldResource)) {
			return newResource;
		}
		return null;
	}
	if (!top && isResource)
		_setResourceId(delta, newResource);
	Object.keys(newResource).forEach(function(key) {
		var oldValue = oldResource[key];
		var newValue = newResource[key];
		// be optimist : oldValue === newValue
		if (oldValue === newValue) {} else
		if (typeof newValue != "object") {
			delta[key] = newValue;
			hasDiff = true;
		} else
		if ((newValue === null) || (oldValue == null)) {
			delta[key] = newValue;
			hasDiff = true;
		} else
		if (typeof newValue != "object") {
			delta[key] = newValue;
			hasDiff = true;
		} else {
			// newValue is an array or an object)
			if (Array.isArray(newValue)) {
				if (!_isArrayResource(newValue, oldValue)) {
					if (!helpers.object.areEqual(oldValue, newValue)) {
						delta[key] = newValue;
						hasDiff = true;
					}
				} else {
					childDelta = _sdataArrayDiff(key, oldValue, newValue, dollar);
					if (childDelta) {
						delta[key] = childDelta;
						hasDiff = true;
					}
				}
			} else {
				if (key != "$properties") {
					var childDelta = _sdataDiff(oldValue, newValue, false, isResource, isDollar);
					if (childDelta) {
						hasDiff = true;
						delta[key] = childDelta;
					}
				}
			}

		}
	});
	Object.keys(oldResource).forEach(function(key) {
		if (typeof newResource[key] == "undefined") {
			if (isResource) {
				if ((key != "$properties") && (key[0] != "$")) {
					dollar.push({
						name: key,
						key: "$isUndefined",
						value: true
					});
				}
			} else
				delta[key] = null;
			hasDiff = true;
		}
	});
	if (isResource) {
		hasDiff = _deltaDollar(oldResource, newResource, dollar, delta, true) || hasDiff;
	}
	return hasDiff ? delta : null;
}

function _sdataArrayDiff(resourceName, oldResource, newResource, dollar) {
	//Sub-resources that appear inside a list MUST carry a $uuid attribute
	//They MAY carry $url and $key attributes
	/*
	 * Syracuse distinguishes two cases for list deltas:
	 * 1. The order of the elements did not change. New elements may be inserted in the list and some elements may be removed too.
	 *     What matters is that the elements that remain in the list remain in the same order relative to each other.
	 * 2. The order did change. There is at least one pair of elements which was in a certain order in the list before and which is in the opposite order after the change.
	 */
	var diff = [],
		newLen = newResource.length,
		oldLen = oldResource.length;
	var orderChanged = false;
	if (newLen == 0) {
		if (newLen == oldLen)
			return null;
		// delete all elements
		oldResource.forEach(function(value, index) {
			var delta = {};
			_setResourceId(delta, value);
			delta.$isDeleted = true;
			delta.$index = 0;
			diff.push(delta);
		});
		return diff;
	} else
	if (oldLen == 0) {
		newResource.forEach(function(value, index) {
			value = helpers.object.clone(value, false);
			value.$index = index;
			diff.push(value);
		});
		return diff;
	}
	var hasDiff = false;
	var oldMap = {}, newMap = {}; // used for fast find
	var prevUID = "";
	newResource.forEach(function(value, index) {
		newMap[value.$uuid] = index + 1;
	});
	oldResource.forEach(function(value, index) {
		oldMap[value.$uuid] = index + 1;
		if (!newMap[value.$uuid]) {
			hasDiff = true; // deleted
		} else
		if (!orderChanged) {
			if (prevUID) {
				orderChanged = (newMap[prevUID] > newMap[value.$uuid]);
			}
			prevUID = value.$uuid;
		}
	});
	if (orderChanged) {
		hasDiff = true;
		newResource.forEach(function(child, index) {
			var oldIndex = oldMap[child.$uuid];
			if (oldIndex) {
				var delta = _sdataDiff(oldResource[oldIndex - 1], child, false, true, false);
				if (!delta) {
					delta = {};
					_setResourceId(delta, child);
				}
				diff.push(delta);
			} else
				diff.push(child);
		});
		dollar.push({
			name: resourceName,
			key: "$deleteMissing",
			value: true
		});
	} else {
		var progressIndex = 0;
		var _delete = function(di) {
			var si = progressIndex;
			for (var i = si; i < oldLen; i++) {
				if (!newMap[oldResource[i].$uuid]) {
					progressIndex++;
					var delta = {};
					_setResourceId(delta, oldResource[i]);
					delta.$isDeleted = true;
					delta.$index = di;
					diff.push(delta);
				} else {
					break;
				}
			}
		};
		newResource.forEach(function(child, index) {
			var oldIndex = oldMap[child.$uuid];
			if (!oldIndex) {
				_delete(index);
				hasDiff = true;
				child = helpers.object.clone(child, true);
				child.$index = index;
				diff.push(child);
			} else {
				_delete(index);
				progressIndex = oldIndex;
				var delta = _sdataDiff(oldResource[oldIndex - 1], child, false, true, false);
				if (delta) {
					hasDiff = true;
					diff.push(delta);
					delta.$index = index;
				}
			}
		});
		_delete(newLen);
	}
	return hasDiff ? diff : null;
}

function _sdataMerge(resource, delta, isResource) {
	if (resource == null)
		return delta;
	if (delta == null)
		return resource;
	//if (isResource) isResource = (delta.$uuid != null);
	if (!isResource) {
		return helpers.object.clone(delta, true);
	}
	var dollar = resource.$properties;
	delete resource.$properties;
	var newResource = helpers.object.clone(resource, false);
	resource.$properties = dollar;
	dollar = delta.$properties;
	var resDollar = (dollar ? helpers.object.clone(dollar, true) : dollar);
	delete delta.$properties;
	Object.keys(delta).forEach(function(key) {
		var deltaValue = delta[key];
		if (typeof deltaValue == "object" && deltaValue !== null) {
			if (Array.isArray(deltaValue)) {
				var meta = (resDollar && resDollar[key]) ? resDollar[key] : undefined;
				newResource[key] = _sdataArrayMerge(resource[key], deltaValue, meta);
			} else {
				newResource[key] = _sdataMerge(resource[key], deltaValue, true);
			}

		} else
			newResource[key] = deltaValue;
	});
	if (isResource) {
		_mergeDollar(resource.$properties, resDollar, newResource);
	}
	if (dollar)
		delta.$properties = dollar;
	return newResource;
}

function _mergeDollar(resDollar, deltaDollar, result) {
	if (deltaDollar === null)
		return; //
	var delta = resDollar || {};
	if (deltaDollar) {
		Object.keys(deltaDollar).forEach(function(key) {
			var value = deltaDollar[key];
			if (value === null) {
				delete delta[key];
			} else {
				if (typeof value == "object" && !Array.isArray(value)) {
					if (value.$isUndefined) {
						delete result[key];
					}
					delete value.$isUndefined;
					delta[key] = delta[key] || {};
					Object.keys(value).forEach(function(skey) {
						if (value[skey] === null)
							delete delta[key][skey];
						else
							delta[key][skey] = value[skey];

					});
				} else
					delta[key] = value;
			}
		});
	} else
	if (deltaDollar == null) {
		// undefined
		if (resDollar)
			result.$properties = resDollar;
		return;
	}
	var keys = Object.keys(delta);
	var len = keys.length;
	// cleanup empty objects
	keys.forEach(function(key) {
		var value = delta[key];
		if (typeof value == "object" && !Array.isArray(value)) {
			if (Object.keys(value).length == 0) {
				len--;
				delete delta[key];
			}
		}
	});
	if (len)
		result.$properties = delta;
}

function _sdataArrayMerge(resource, deltaValue, meta) {
	var res = [];
	var map = {};
	if (!resource)
		return deltaValue;
	if (meta && meta.$deleteMissing) {
		deltaValue.forEach(function(value, index) {
			res.push(value);
			map[value.$uuid] = res.length;
		});
		resource.forEach(function(value, index) {
			if (map[value.$uuid]) {
				var delta = res[map[value.$uuid] - 1];
				res[map[value.$uuid] - 1] = _sdataMerge(value, delta, true);
			}
		});
		delete meta.$deleteMissing;
	} else {
		// same order
		resource.forEach(function(value, index) {
			res.push(value);
			map[value.$uuid] = value;
		});
		deltaValue.forEach(function(value, index) {
			if (value.$isDeleted) {
				res.splice(value.$index, 1);
				delete value.$index;
			} else
			if (typeof value.$index == "undefined") {
				res.push(value);
				delete value.$index;
			} else {
				var add = (value.$index >= res.length);
				if (!add)
					add = (map[value.$uuid] == null);
				if (add) {
					res.splice(value.$index, 0, value);
					delete value.$index;
				} else {
					var oldvalue = res[value.$index];
					res[value.$index] = _sdataMerge(oldvalue, value, true);
					delete res[value.$index].$index;
				}

			}
		});
	}
	return res;
}

exports.resource.sdataDelta = function(oldResource, newResource) {
	return _sdataDiff(oldResource, newResource, true, true, false);
};
exports.resource.sdataMerge = function(oldResource, delta) {
	return _sdataMerge(oldResource, delta, true, true);
};

exports.setCookie = function(name, value, domain, expires, path, secure) {
	var cookie = name + "=" + unescape(value);
	cookie += (domain) ? "; domain=" + domain : "";
	cookie += (expires) ? "; expires=" + expires : "";
	cookie += (path) ? "; path=" + path : "";
	cookie += (secure) ? "; secure" : "";
	document.cookie = cookie;
	return;
};
exports.getCookie = function(name) {
	var i = 0; //searchposition within cookie
	var search = name + "=";
	while (i < document.cookie.length) {
		if (document.cookie.substring(i, i + search.length) == search) {
			var ende = document.cookie.indexOf(";", i + search.length);
			ende = (ende > -1) ? ende : document.cookie.length;
			var cookie = document.cookie.substring(i + search.length, ende);
			return unescape(cookie);
		}
		i++;
	}
	return null;
};
exports.eraseCookie = function(name, domain, path) {
	// set expires-date to past so that the cookie is invalid
	var cookie = name + "=; expires=Thu, 01-Jan-70 00:00:01 GMT";
	cookie += (domain) ? "domain=" + domain : "";
	cookie += (path) ? "path=" + path : "";
	document.cookie = cookie;
	return;
};

//relNumberCmp: comparison of release numbers
//split release numbers in parts with dots as delimiters and numerically compare the parts
//result is negative, 0, positive if first release number is smaller, equal, bigger than second
//here also patch number will be considered (separator: '-')
// example: relNumberCmp("7.0", "10.0") < 0, relNumberCmp("7.1.9", "7.2") < 0, relNumberCmp("7.1", "7.1.0") < 0
exports.relNumberCmp = function(rel1, rel2) {
	var parts1 = rel1.split(/[\.\-]+/);
	var parts2 = rel2.split(/[\.\-]+/);
	var bound = Math.min(parts1.length, parts2.length);
	var i;
	for (i = 0; i < bound; i++) {
		var diff = parts1[i] - parts2[i];
		if (diff !== 0)
			return diff;
	}
	return parts1.length - parts2.length;
};


/*


 exports.hacked = console.error;


 function hack(obj){


 if (!obj || typeof obj !== 'object')


 return obj;


 if (obj.$ !== undefined) {


 exports.hacked("FOUND $");


 obj.$properties = obj.$;


 delete obj.$;


 }


 if (obj.$type === 'application/x-collection') {


 exports.hacked("FOUND x-collection");


 obj.$type = 'application/x-array';


 }


 if (obj.$constraints) {


 exports.hacked("FOUND $constraints");


 Object.keys(obj.$constraints).forEach(function(k){


 obj[k] = obj.$constraints[k];


 });


 delete obj.$constraints;


 }


 Object.keys(obj).forEach(function(k){


 obj[k] = hack(obj[k]);


 });


 return obj;


 }


 var JSONparse = JSON.parse;


 JSON.parse = function(){


 var result = JSONparse.apply(JSON, arguments);


 // result = hack(result);


 return result;


 }*/