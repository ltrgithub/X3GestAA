"use strict";
const helpers = require("../helpers");
const date = require("./date");
const time = require("./time");
const locale = require("syracuse-core/lib/locale");

const _resources = date.resources;

exports.validate = function(value, constraints, errors) {
	if (value == null) {
		if (constraints.$isMandatory) return errors.push(locale.format(module, "valMand"));
		if (!constraints.$isNullable) return errors.push(locale.format(module, "valNull"));
		return;
	}
	if (!(value instanceof Datetime)) {
		errors.push(locale.format(module, "valDT"));
		return;
	}

	// month value check
	if (!(value.month >= 1 && value.month <= 12)) {
		errors.push(locale.format(module, "valMon"));
		return;
	}

	// day value check
	if (!(value.day >= 1 && value.day <= date.daysInMonth(value.year, value.month))) {
		errors.push(locale.format(module, "valDay"));
		return;
	}
};

function _pad2(val) {
	const s = val.toString();
	return (s.length == 1) ? "0" + s : s;
}

function _pad3(val) {
	const s = val.toString();
	switch (s.length) {
		case 1:
			return "00" + s;
		case 2:
			return "0" + s;
		default:
			return s;
	}
}

// returns millis value for seconds and milliseconds part

function _ms(dt) {
	// add millis for approx 2000 years to ensure positive before applying modulo
	return (dt._value + 2000 * 365 * 24 * 3600 * 1000) % 1000;
}

// get UTC components packed into an int
// millis are not included as they are independent from UTC/local

function _utc(dt) {
	var utc = dt._utc;
	if (!utc) {
		const d = new Date(dt._value);
		utc = d.getUTCFullYear() * 10000 * 100000 + (d.getUTCMonth() + 1) * 100 * 100000 + d.getUTCDate() * 100000 + d.getUTCHours() * 3600 + d.getUTCMinutes() * 60 + d.getUTCSeconds();
		d._utc = utc;
	}
	return utc;
}

// get local components packed into an int
// millis are not included as they are independent from UTC/local

function _local(dt) {
	var local = dt._local;
	if (!local) {
		const d = new Date(dt._value);
		local = d.getFullYear() * 10000 * 100000 + (d.getMonth() + 1) * 100 * 100000 + d.getDate() * 100000 + d.getHours() * 3600 + d.getMinutes() * 60 + d.getSeconds();
		d._local = local;
	}
	return local;
}

// internal value is GMT millis since origin (Jan 1st, 1970).
// We also cache the local and utc values separately as _local and _utc, when
// they are requested.

class Datetime {
	constructor(value, tzOffset) {
		this._value = value;
		if (tzOffset != null) this._tzOffset = tzOffset;
	}
	get date() {
		return date.fromInternalValue(Math.floor(_local(this) / 100000));
	}
	get time() {
		return time.fromSeconds(_local(this) % 100000);
	}
	get year() {
		return this.date.year;
	}
	get month() {
		return this.date.month;
	}
	get day() {
		return this.date.day;
	}
	get weekDay() {
		return this.date.weekDay;
	}
	get yearDay() {
		return this.date.yearDay;
	}
	get hour() {
		return this.time.hour;
	}
	get minute() {
		return this.time.minute;
	}
	get second() {
		return this.time.second;
	}
	get millisecond() {
		return _ms(this);
	}
	get utcDate() {
		return date.fromInternalValue(Math.floor(_utc(this) / 100000));
	}
	get utcTime() {
		return time.fromSeconds(_utc(this) % 100000);
	}
	get utcYear() {
		return this.utcDate.year;
	}
	get utcMonth() {
		return this.utcDate.month;
	}
	get utcDay() {
		return this.utcDate.day;
	}
	get utcWeekDay() {
		return this.utcDate.weekDay;
	}
	get utcYearDay() {
		return this.utcDate.yearDay;
	}
	get utcHour() {
		return this.utcTime.hour;
	}
	get utcMinute() {
		return this.utcTime.minute;
	}
	get utcSecond() {
		return this.utcTime.second;
	}
	get utcMillisecond() {
		return _ms(this);
	}
	get value() {
		return this._value;
	}
	get timezoneOffset() {
		if (this._tzOffset == null) this._tzOffset = this.toJsDate().getTimezoneOffset();
		return this._tzOffset;
	}
	compare(dt) {
		return this._value - dt._value;
	}
	equals(dt) {
		return this._value === dt._value;
	}
	between(begin, end) {
		return begin._value <= this._value && this._value <= end._value;
	}
	addYears(years) {
		return this.date.addYears(years).at(this.time, this.millisecond);
	}
	addMonths(months) {
		return this.date.addMonths(months).at(this.time, this.millisecond);
	}
	addWeeks(weeks) {
		return this.date.addWeeks(weeks).at(this.time, this.millisecond);
	}
	addDays(days) {
		return this.date.addDays(days).at(this.time, this.millisecond);
	}
	addHours(hours) {
		return new Datetime(this._value + hours * 3600 * 1000);
	}
	addMinutes(minutes) {
		return new Datetime(this._value + minutes * 60 * 1000);
	}
	addSeconds(seconds) {
		return new Datetime(this._value + seconds * 1000);
	}
	addMilliseconds(millis) {
		return new Datetime(this._value + millis);
	}
	addDayFractions(fraction) {
		return new Datetime(this._value + fraction * 86400 * 1000);
	}
	millisDiff(dt) {
		return this._value - dt._value;
	}

	/**
     * Adds (or subtracts) to the value of the year, month, day, hour, minute, second, millisecond of the date instance using given configuration object. Positive and Negative values allowed.
     * Example
     <pre><code>
     Date.today().add( { day: 1, month: 1 } )
     </code></pre>
     * @param {Object}   Configuration object containing attributes (month, day, etc.)
     * @return {Date}    this
     */
	add(delta) {
		return this.addYears(delta.years || 0).addMonths(delta.months || 0).addWeeks(delta.weeks || 0).addDays(delta.days || 0).addHours(delta.hours || 0).addMinutes(delta.minutes || 0).addSeconds(delta.seconds || 0).addMillis(delta.millis || 0);
	}

	// format as
	toString(format) {
		const self = this;
		if (format == null) {
			return new Date(this._value).toISOString();
		} else {
			const utc = _getIndexOfZ(format);
			const _date = utc ? self.utcDate : self.date;
			const _time = utc ? self.utcTime : self.time;

			var result = '';
			_walkFormat(format, {
				literal: function(lit) {
					result += lit;
				},
				H: function(repeat) {
					switch (repeat) {
						case 1:
							result += _time.hour.toString();
							break;
						case 2:
							result += _pad2(_time.hour);
							break;
						default:
							throw new Error(locale.format(module, "formatH", repeat));
					}
				},
				h: function(repeat) {
					switch (repeat) {
						case 1:
							result += _time.hour < 13 ? _time.hour : (_time.hour - 12);
							break;
						case 2:
							result += _pad2(_time.hour < 13 ? _time.hour : (_time.hour - 12));
							break;
						default:
							throw new Error(locale.format(module, "formath", repeat));
					}
				},
				m: function(repeat) {
					switch (repeat) {
						case 2:
							result += _pad2(_time.minute);
							break;
						default:
							throw new Error(locale.format(module, "formatm", repeat));
					}
				},
				s: function(repeat) {
					switch (repeat) {
						case 2:
							result += _pad2(self.second);
							break;
						default:
							throw new Error(locale.format(module, "formats", repeat));
					}
				},
				t: function(repeat) {
					switch (repeat) {
						case 1:
							result += self.hour < 12 ? _resources().amDesignator.substring(0, 1) : _resources().pmDesignator.substring(0, 1);
							break;
						case 2:
							result += self.hour < 12 ? _resources().amDesignator : _resources().pmDesignator;
							break;
						default:
							throw new Error(locale.format(module, "formata", repeat));
					}
				},
				d: function(repeat) {
					switch (repeat) {
						case 1:
							result += _date.day.toString();
							break;
						case 2:
							result += _pad2(_date.day);
							break;
						case 3:
							result += date.dayName(_date.weekDay, true);
							break;
						case 4:
							result += date.dayName(_date.weekDay);
							break;
						default:
							throw new Error(locale.format(module, "formatd", repeat));
					}
				},
				M: function(repeat) {
					switch (repeat) {
						case 1:
							result += _date.month.toString();
							break;
						case 2:
							result += _pad2(_date.month);
							break;
						case 3:
							result += date.monthName(_date.month, true);
							break;
						case 4:
							result += date.monthName(_date.month);
							break;
						default:
							throw new Error(locale.format(module, "formatM", repeat));
					}
				},
				y: function(repeat) {
					switch (repeat) {
						case 2:
							result += _date.year.toString().substring(2, 4);
							break;
						case 4:
							result += _date.year.toString();
							break;
						default:
							throw new Error(locale.format(module, "formaty", repeat));
					}
				},
				S: function(repeat) {
					if (repeat === 3) result += _pad3(self.millisecond);
					else new Error(locale.format(module, "formatS", repeat));
				}
			});
			return result;
		}
	}
	toJsDate() {
		return new Date(this._value);
	}
	withoutTimezoneOffset() {
		return new Datetime(this._value);
	}
	isNull() {
		return this._value == 0;
	}
}

function _formatTzOffset(offset, len) {
	var s = "-";
	if (offset < 0) {
		s = "+";
		offset = -offset;
	}
	const hr = Math.round(offset / 60);
	const min = offset - hr * 60;
	s += len > 1 ? _pad2(hr) : hr;
	s += len > 2 || min ? (":" + (len > 1 ? _pad2(min) : min)) : "";
	return s;
}

function _parseIso(str) {
	var year = 0,
		month = 0,
		day = 0,
		hours = 0,
		minutes = 0,
		seconds = 0,
		ms = 0,
		offset = 0,
		convertError = true;
	const d = /(\d{4})-(\d{2})-(\d{2})([T\s]?)(\d{2})?(:)?(\d{2})?(:)?(\d{2})?(\.(\d{3}))?(Z)?(([+-])(\d{2}))?(.*$)/.exec(str);
	if (d) {
		convertError = false;
		year = +d[1];
		month = d[2] - 1;
		day = +d[3];
		hours = +(d[5] || 0);
		minutes = +(d[7] || 0);
		seconds = +(d[9] || 0);
		ms = +(d[11] || 0);
		if (d[12] === "Z") {
			if (d[14] === '-') offset = (d[15] || 0) * 60;
			else if (d[14] === '+') offset = -(d[15] || 0) * 60;
			const utc = Date.UTC(year, month, day, hours, minutes + offset, seconds, ms);
			return new Datetime(utc);
		} else {
			const jsDate = new Date(year, month, day, hours, minutes + offset, seconds, ms);
			return new Datetime(jsDate.getTime(), jsDate.getTimezoneOffset());
		}
	}
	if (convertError) throw new Error(locale.format(module, "noParse", str));
}

exports.now = function(withMillis) {
	const jsDate = new Date();
	var millis = jsDate.getTime();
	if (!withMillis) millis = Math.floor(millis / 1000) * 1000;
	return new Datetime(millis, jsDate.getTimezoneOffset());
};

exports.parse = function(str, format) {
	if (str == null) throw new Error(locale.format(module, "isNull"));

	if (format == null) {
		return _parseIso(str);
	} else {
		return _parse(str, format);
	}
};

exports.fromJsDate = function(jsDate) {
	return new Datetime(jsDate.getTime(), jsDate.getTimezoneOffset());
};

exports.fromMillis = function(value) {
	return new Datetime(value);
};

exports.isDatetime = function(obj) {
	return obj instanceof Datetime;
};

function _make(year, month, day, hour, minute, second, millis) {
	const jsDate = new Date(year, month - 1, day, hour || 0, minute || 0, second || 0, millis || 0);
	return new Datetime(jsDate.getTime(), jsDate.getTimezoneOffset());
}

exports.make = _make;
exports.makeUtc = _makeUtc;

function _makeUtc(year, month, day, hour, minute, second, millis) {
	const jsDate = new Date(Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millis || 0));
	return new Datetime(jsDate.getTime(), jsDate.getTimezoneOffset());
}

// hack to install "at" method in date, without require cycles
date.make(1, 1, 1).constructor.prototype.at = function(time, millisecond) {
	return exports.make(this.year, this.month, this.day, time.hour, time.minute, time.second, millisecond);
};

exports.sunday = 0;
exports.Sunday = 0;
exports.monday = 1;
exports.Monday = 1;
exports.tuesday = 2;
exports.Tuesday = 2;
exports.wednesday = 3;
exports.Wednesday = 3;
exports.thursday = 4;
exports.Thursday = 4;
exports.friday = 5;
exports.Friday = 5;
exports.saturday = 6;
exports.Saturday = 6;

function _walkFormat(format, map) {
	var i = 0;
	const len = format.length;

	function count(i) {
		const ch = format[i];
		var k = 1;
		while (format[i + k] === ch)
			k++;
		return k;
	}

	while (i < len) {
		const c = format[i];
		switch (c) {
			case "'":
				i++;
				var literal = '';
				// going to the end of the following litteral or to the format end
				for (; i < len; i++) {
					if (format[i] === "'") {
						i++;
						// check wether the "'" is not doubled
						if (format[i] === "'") {
							literal += "'";
						} else break;
					} else {
						literal += format[i];
					}
				}
				map.literal(literal);
				break;
			case "H":
			case "h":
			case "m":
			case "s":
			case "S":
			case "t":
			case "d":
			case "M":
			case "y":
				const repeat = count(i);
				map[c](repeat);
				i += repeat;
				break;
			default:
				map.literal(c);
				i++;
		}
	}
}

exports.walkFormat = _walkFormat;

function _parse(str, format) {
	var day, weekday, month, year, hour, minute, second, millis, timeMode, abbrTimeMode;
	const timeModes = [date.amDesignator(), date.pmDesignator()];
	//const timeModes = _resources().amDesignator ? [_resources().amDesignator, _resources().pmDesignator] : ["AM", "PM"];
	const abbrTimeModes = [timeModes[0].substring(0, 1), timeModes[1].substring(0, 1)];
	//const abbrTimeModes = _resources().amDesignator ? [_resources().amDesignator.substring(0, 1), _resources().pmDesignator.substring(0, 1)] : ["A", "P"];

	// position in str
	var j = 0;

	function parseInteger(max) {
		if (!/\d/.test(str[j])) {
			throw new Error(locale.format(module, "noNumber", str.substring[j]));
		}
		const beg = j++;
		while (j < beg + max && /\d/.test(str[j]))
			j++;
		return parseInt(str.substring(beg, j), 10);
	}

	function parseName(names) {
		for (var k = 0; k < names.length; k++) {
			const name = names[k],
			len = name.length;
			if (str.substring(j, j + len).toUpperCase() == name.toUpperCase()) {
				j += len;
				return k;
			}
		}
		throw new Error(locale.format(module, "unknown", str.substring(j)));
	}

	_walkFormat(format, {
		literal: function(literal) {
			if (str.substring(j, j + literal.length) !== literal) throw new Error(locale.format(module, "formatMis", literal, str.substring(j)));
			j += literal.length;
		},
		d: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					day = parseInteger(2);
					break;
				case 3:
					weekday = parseName(_resources().abbreviatedDayNames);
					break;
				case 4:
					weekday = parseName(_resources().dayNames);
					break;
				default:
					throw new Error(locale.format(module, "badDay", format.substring(j))); // replaced i with j
			}
		},
		M: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					month = parseInteger(2);
					break;
				case 3:
					month = parseName(_resources().abbreviatedMonthNames) + 1;
					break;
				case 4:
					month = parseName(_resources().monthNames) + 1;
					break;
				default:
					throw new Error(locale.format(module, "badDay", format.substring(j))); // replaced i with j
			}
		},
		y: function(arg) {
			switch (arg) {
				case 2:
					year = parseInteger(2);
					year = year < 40 ? 2000 + year : 1900 + year;
					break;
				case 4:
					year = parseInteger(4);
					break;
				default:
					throw new Error(locale.format(module, "badYear", format.substring(j))); // replaced i with j
			}
		},
		H: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					hour = parseInteger(2);
					break;
				default:
					throw new Error(locale.format(module, "badHour", format.substring(j)));
			}
		},
		h: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					hour = parseInteger(2);
					break;
				default:
					throw new Error(locale.format(module, "badHour", format.substring(j)));
			}
		},
		m: function(arg) {
			switch (arg) {
				case 2:
					minute = parseInteger(2);
					break;
				default:
					throw new Error(locale.format(module, "badMin", format.substring(j)));
			}
		},
		s: function(arg) {
			switch (arg) {
				case 2:
					second = parseInteger(2);
					break;
				default:
					throw new Error(locale.format(module, "badSec", format.substring(j)));
			}
		},
		t: function(arg) {
			switch (arg) {
				case 1:
					abbrTimeMode = parseName(abbrTimeModes);
					break;
				case 2:
					timeMode = parseName(timeModes);
					break;
				default:
					throw new Error(locale.format(module, "badMarker", format.substring(j)));
			}
		}
	});

	// from 12 format to 24 format, used when necessary

	function from12to24(mode, index) {
		switch (mode[index]) {
			case mode[0]:
				// AM
				hour = hour === 12 ? 0 : hour;
				break;
			case mode[1]:
				// PM
				if (hour >= 1 && hour <= 11) {
					hour += 12;
				}
				break;
		}
	}

	if (timeMode != null || abbrTimeMode != null) {
		if (hour > 12) throw new Error(locale.format(module, "badHourVal", hour, timeMode));
		const mode = timeMode != null ? timeModes : abbrTimeModes;
		const index = timeMode != null ? timeMode : abbrTimeMode;
		from12to24(mode, index);
	}

	// ignore weekday
	return _make(year, month, day, hour, minute, second, millis);
}

function _getIndexOfZ(format) {
	var i = 0;
	const len = format.length;

	function count(i) {
		const ch = format[i];
		var k = 1;
		while (format[i + k] === ch)
			k++;
		return k;
	}

	while (i < len) {
		const c = format[i];
		if (c === "'") {
			i++;
			var literal = '';
			// going to the end of the following litteral or to the format end
			for (; i < len; i++) {
				if (format[i] === "'") {
					i++;
					// check wether the "'" is not doubled
					if (format[i] === "'") {
						literal += "'";
					} else break;
				} else {
					literal += format[i];
				}
			}
		} else if (c === 'Z') {
			return i;
		} else {
			i++;
		}
	}
}

/*const utc = format.indexOf("Z") >= 0;

 const date = utc ? self.utcDate : self.date;

 const time = utc ? self.utcTime : self.time;

 return format.replace(/dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|SS?S?S?|tt?|zz?z?/g, function(format){

 switch (format) {

 case "hh":

 return _pad2(time.hour < 13 ? time.hour : (time.hour - 12));

 case "h":

 return time.hour < 13 ? time.hour : (time.hour - 12);

 case "HH":

 return _pad2(time.hour);

 case "H":

 return time.hour.toString();

 case "mm":

 return _pad2(time.minute);

 case "m":

 return time.minute.toString();

 case "ss":

 return _pad2(self.second);

 case "s":

 return self.second.toString();

 case "yyyy":

 return date.year.toString();

 case "yy":

 return date.year.toString().substring(2, 4);

 case "dddd":

 return _dayName(date.weekDay);

 case "ddd":

 return _dayName(date.weekDay, true);

 case "dd":

 return _pad2(date.day);

 case "d":

 return date.day.toString();

 case "MMMM":

 return _monthName(date.month);

 case "MMM":

 return _monthName(date.month, true);

 case "MM":

 return _pad2(date.month);

 case "M":

 return date.month.toString();

 case "t":

 return time.hour < 12 ? Date.CultureInfo.amDesignator.substring(0, 1) : Date.CultureInfo.pmDesignator.substring(0, 1);

 case "tt":

 return time.hour < 12 ? Date.CultureInfo.amDesignator : Date.CultureInfo.pmDesignator;

 case "zzz":

 case "zz":

 case "z":

 return _formatTzOffset(self.timezoneOffset, format.length);

 case "Z":

 return "Z";

 case "SSS":

 return self.millisecond.toString();

 default:

 throw new Error("internal error: format=" + format);

 }

 });*/