"use strict";
var helpers = require("../helpers");
var decimal = require("./decimal");
var locale = require("../locale");
var _resources = decimal.resources;
var globals = require("streamline/lib/globals");

var localeKeys = {
	gs : "numberGroupSeparator",
	ds : "numberDecimalSeparator"
};

//======================
//	Useful elements
//======================

/**
 * Format object used to handle format. Useful for the formatting and parsing methods
 * @param {Object} prefix	Any text before directives
 * @param {Object} postfix	Any text after directives
 * @param {Object} properties	Properties are : hasDecimalSeparator, hasGroupSeparator, mandatoryAfter, maxAfter, groupSize, mandatoryBefore, directive, hasPercent, hasPermil, hasSignFormat 
 */
function formatObj(prefix,postfix,properties){
	this.prefix = prefix;
	this.postfix = postfix;
	this.properties = properties;
}

/**
 * Set number format properties from directive parameter. 
 * @param {String}	directive
 * @param {Object}	fObj
 * @return {Object}	Returns a formatObj with properties set
 */
function _processDirective(directive, fObj){
	// properties to set:   
	
	// result
	var f = new formatObj(fObj.prefix,fObj.postfix,fObj.properties);

	var hasDecimalSeparator,hasGroupSeparator;
	
	var dsIndex = directive.indexOf('.');
	var gsIndex = directive.indexOf(',');
	
	// decimal and group separator properties
	f.properties.hasDecimalSeparator = hasDecimalSeparator = dsIndex > -1;
	f.properties.hasGroupSeparator = hasGroupSeparator = gsIndex > -1;
	
	// after properties	
	if (hasDecimalSeparator){
		var decimal = directive.substring(dsIndex+1);
		f.properties.mandatoryAfter = decimal.indexOf("0") > -1 ? decimal.match(/0/g).length : 0;
		f.properties.maxAfter = decimal.length;
	}
	
	// group size property
	if (hasGroupSeparator){
		f.properties.groupSize = hasDecimalSeparator ? dsIndex-gsIndex-1 : directive.substring(gsIndex+1).length;
	}
	
	// before property
	var integer = hasDecimalSeparator ? directive.substring(0,dsIndex) : directive;
	f.properties.mandatoryBefore = integer.indexOf("0") > -1 ? integer.match(/0/g).length : 0; 
		
	// directive
	f.properties.directive = directive;
	
	// percent/permil property
	f.properties.hasPercent = directive.indexOf("%") > -1;
	f.properties.hasPermil = directive.indexOf("‰") > -1;
	
	// sign format
	f.properties.hasSignFormat = directive.indexOf('+') > -1 && directive.indexOf('+') === 0;
	
	return f;
}

/**
 * Walk through the given format and run functions in map
 * @param {Object} format
 * @param {Object} map
 */
function _walkFormat(format, map){
    var i = 0, len = format.length;
    
    // valid directive characters in format (except ';')
    var validDir = "0#.,%‰+"; //	'E' or 'e' are not supported yet
    function count(i){
        var ch = format[i], k = 1;
        while (validDir.indexOf(format[i + k]) > -1) 
            k++;
        return k;
    }
    
    while (i < len) {
        var c = format[i];
        switch (c) {
            case "'":
                i++;
                var literal = '';
                // going to the end of the following litteral or to the format end
                for (; i < len; i++) {
                    if (format[i] === "'") {
                        i++;
                        // check wether the "'" is not doubled
                        if (format[i] === "'") {
                            literal += "'";
                        }
                        else 
                            break;
                    }
                    else {
                        literal += format[i];
                    }
                }
                map.literal(literal);
                break;
            case "0":
            case "#":
            case ".":
            case "%":
            case "‰":
            case "+":
                var directiveLength = count(i);
                map.directive(i, i + directiveLength);
                i += directiveLength;
                break;
            case ";":
                map.listSeparator();
                i++;
                break;
            default:
                map.literal(c);
                i++;
        }
        // at the end of the loop
        if (i === len) {
            map.listSeparator();
        }
    }
}

/**
 * Add separator parameter after every digits group of size value to the number paramater.
 * @param {Object} num
 * @param {Object} gs
 * @param {Object} size
 */
function _addSeparator(num,gs,size){
	var result = "";
	var len = num.length;
	var c = "";
	var count = 0; 
	for (var i=len-1;i>=0;i--){
		c = num[i];
		result += c;
		++count;
		if ((count%size===0) && i>0){
			result += gs;
		}
	}
	return result.split("").reverse().join("");
}

/**
 * Returns key value from either user preferences or locale resources values
 * @param {Object} key
 */
function _localized(key){
	var l = globals && globals.context && globals.context.localePreferences;
	if (l)
		return l[key] || "";
	return _resources()[key];
}

//======================
//	Format functions
//======================

/**
 * Forat a number
 * @param {Object} val	Raw number
 * @param {Object} format	Format to apply
 * @return {String} Returns a string value containing formatted number
 */
exports.format = function(val, format){
	
//	if (!val)
//		throw new Error("empty number value");
		
	if (isNaN(val))
		throw new Error(val + " is not a number");
		
	if (format == null){
		val = val.toString();
		var dsIndex = val.indexOf('.');
		var hasDecimal = dsIndex > -1;
		var intPart = hasDecimal ? val.substring(0,dsIndex) : val;
		var decimalPart = hasDecimal ? val.substring(dsIndex+1) : '';
		var gs = _localized(localeKeys.gs) || "";
		//var gs = _resources().groupSeparator ? _resources().groupSeparator : "";
		var ds = hasDecimal ? (_localized(localeKeys.ds) || ".") : '';
		//var ds = hasDecimal ? (_resources().decimalSeparator ? _resources().decimalSeparator : ".") : '';
		return _addSeparator(intPart,gs,3)+ds+decimalPart;
	}
	
	else {
		return _format(val, format);
	}
	
	
}


function _format(val, format){
	var prefix,postfix;
	// position in val
	var j = 0;
	// format list (used in case of list of formats separated with ';', empty otherwise)
	var formatsList = [];
	
	var directiveProcessed = false;
	
	var f = new formatObj('','',{});
		
	_walkFormat(format, {
        literal: function(literal){
			// set prefix or postfix value
			directiveProcessed ? f.postfix += literal : f.prefix += literal
        },
		directive: function(beg,end){
			// get directive part of the format
			var directive = format.substring(beg,end);
			
			// process directive
			f = _processDirective(directive,f);
			
			directiveProcessed = true;
		},
		listSeparator: function(){
			directiveProcessed = false;
			formatsList.push(f);
			f = new formatObj('','',{});
			prefix = '';
			postfix = '';
		}
	});
	
	var flen = formatsList.length;
	switch(flen){
		case 1:
			return _formatNumber(val,formatsList[0]);
			break;
		case 2:
		case 3:
			if (val === 0)
				return _formatZero(formatsList[2]);
			else
				return val < 0 ? _formatNumber(val.toString().substring(1),formatsList[1]) : _formatNumber(val,formatsList[0]); 	
			break;
		default:
			throw new Error(flen===0 ? "error. no format specified" : "error. too many formats specified in formats list");
	}
}

function _formatZero(fObj){
	return fObj.prefix;
}

function _formatNumber(num,fObj){
	var res = '';
	
	// locale separators
	var gs = _localized(localeKeys.gs);
	var ds = _localized(localeKeys.ds);
	//var gs = _resources().groupSeparator;
	//var ds = _resources().decimalSeparator;
	
	//var fObj = listPos ? formatsList[listPos] : formatsList[0];
	var directive = fObj.properties.directive;
	
	// special case for percentages
	num = fObj.properties.hasPercent ? num*100 : num ;
	num = fObj.properties.hasPermil ? num*1000 : num ;
	
	// == decimal ==
	if (fObj.properties.hasDecimalSeparator){
		var decimalPart = '';
		var maxAfter = fObj.properties.maxAfter;
		var decimalFormat = directive.substr(directive.indexOf('.')+1,maxAfter)
		var decimalValue = num % 1;
		var decimalString = '' + decimalValue.toFixed(maxAfter);
		decimalString = decimalString.substring(decimalString.indexOf('.')+1);
		for (var i=0;i<maxAfter;i++){
			var f = decimalFormat.charAt(i);
			var n = decimalString.charAt(i);
			if (f === '0'){
				decimalPart += n;
			}
			else if (f === '#' && n !== '0'){
				decimalPart += n;
			}
			else if (f === '#' && n === '0'){ // end loop if only '0' left in decimalString
				var notParsed = decimalString.substring(i);
				if (notParsed.match('[1-9]'))
					decimalPart += n;
				else 
					break;
			}			 
		}
		res = decimalPart ? ds + decimalPart : res; // in case of integer value, decimalPart --> ''
	}
	else {
		// it is possible to have decimal number and format not containing decimal separator
		num = Math.round(num);
	}
	
	
	// == integer ==
	var intPart = num < 0 ? '' + Math.ceil(num) : '' + Math.floor(num);
	intPart = intPart.replace(/[^\d]+/g,''); 
	var intFormat = directive.indexOf('.') === -1 ? directive : directive.substring(0,directive.indexOf('.'));
	// padding if necessary
	if (intPart.length < fObj.properties.mandatoryBefore){
		var missing = fObj.properties.mandatoryBefore - intPart.length;
		var toAdd = '';
		for (var i=0;i<missing;i++){
			toAdd += '0';
		}
		intPart = toAdd + intPart;
	}
	// adding group separator if needed
	if (fObj.properties.hasGroupSeparator){
		if (fObj.properties.groupSize < intPart.length){
			intPart = _addSeparator(intPart,gs,fObj.properties.groupSize);
		}
	}
	
	// in case of no mandatory digit before decimal separator, no character for int part
	intPart = (parseInt(intPart,10) === 0 && fObj.properties.mandatoryBefore === 0) ? '' : intPart;
	
	intPart = intPart && num < 0 ? '-'+intPart : intPart;
	res = intPart + res;
	
	// == specific cases ==
	// sign format
	res = fObj.properties.hasSignFormat && num > 0 ? '+'+res : res;
	
	// percent and/or permil
	res += fObj.properties.hasPercent ? "%" : '';
	res += fObj.properties.hasPermil ? "‰" : '';
	
	return fObj.prefix + res + fObj.postfix;
}



//======================
//	Parsing functions
//======================

// * @param {Object} fn	Function called if number returned doesn't match with the integer type (only use)
// exports.parse = function(str, format, fn){
/**
 * Get a number from a formatted number string value
 * @param {Object} str	Formatted number
 * @param {Object} format	Format supposedly used
 * @return {Object}	Returns a number (integer : floor(number), decimal : BigDecimal, real : number)
 */
exports.parse = function(str, format){
    if (!str)
		return 0;
        //throw new Error("number string is null");
    
    if (format == null) {
        return parseFloat(str);
    }
    else {
        return _parse(str, format);
    }
}

function _parse(str, format){
    //format = /[0-9-+,.#eE%‰;()\s]/g.exec();
	var prefix,postfix;
	
	// position in str
	var j = 0;	
	
	// format list (used in case of list of formats separated with ';', empty otherwise)
	var formatsList = [];
	
	var directiveProcessed = false;
	
	var f = new formatObj('','',{});
		
	_walkFormat(format, {
        literal: function(literal){
			// set prefix or postfix value
			directiveProcessed ? f.postfix += literal : f.prefix += literal
        },
		directive: function(beg,end){
			// get directive part of the format
			var directive = format.substring(beg,end);
			
			// process directive
			f = _processDirective(directive,f);
			
			directiveProcessed = true;
		},
		listSeparator: function(){
			directiveProcessed = false;
			formatsList.push(f);
			f = new formatObj('','',{});
			prefix = '';
			postfix = '';
		}
	});
	
	
	return _parseFormats(str,formatsList);
}

function _parseFormats(str, formatsList, negative){
	var flen = formatsList.length;
	var num;
	// locale separators
	var gs = _localized(localeKeys.gs);
	var ds = _localized(localeKeys.ds);
	//var gs = _resources().groupSeparator;
	//var ds = _resources().decimalSeparator;
	switch(flen){
		case 1:
			var fObj = formatsList[0];
			var formatNumber = str;
			var integerPart,decimalPart;
			// extract prefix and postfix
			var prefix = fObj.prefix;
			var postfix = fObj.postfix;
			formatNumber = prefix ? formatNumber.substring(prefix.length) : formatNumber;
			formatNumber = postfix ? formatNumber.substring(0,formatNumber.length-postfix.length) : formatNumber;
			
			// splitting into integer and decimal parts
    		var splitted = formatNumber.split(ds);
			// error : too many periods
			if (splitted.length > 2)
				throw new Error("invalid number, only one decimal separator expected : " + formatNumber);
			// setting integer and decimal parts values
			integerPart = splitted[0] ? splitted[0].match(/[0-9]/g).join('') : '0';
			decimalPart = splitted.length > 1 ? splitted[1].match(/[0-9]/g).join('') : '';
			num = parseFloat(decimalPart ? integerPart+"."+decimalPart : integerPart);
			
			// == specific cases ==
			// negative value
			num = formatNumber.charAt(0) === '-' ? parseFloat('-' + num) : num;
			// percent or permil
			num = fObj.properties.hasPercent ? num/100 : num;
			num = fObj.properties.hasPermil ? num/1000 : num;
			// negative value set for list separator cases
			num =  negative ? parseFloat('-' + num) : num;
			break;
		case 2:
		case 3:
			// valid characters in formatted number
			var validFormat = "1234567890"+ds+gs+"%‰-+";	// 'E' or 'e' are not supported yet
			var len = formatsList.length;
			var slen = str.length;
			
			for (var i = 0; i < len; i++){
				var f = formatsList[i];
				var prefix = f.prefix;
				var postfix = f.postfix;
				
				var prefixDefined = prefix ? true : false;
				var postfixDefined = postfix ? true : false;
				
				var pre,post;
				
				pre = prefixDefined ? str.substring(0,prefix.length) : '';
				post = postfixDefined ? str.substring(slen-postfix.length) : '';
				
				if (((prefixDefined && !postfixDefined) && pre.indexOf(prefix) > -1)     
				|| ((prefixDefined && postfixDefined) && (pre.indexOf(prefix) > -1 && post.indexOf(postfix) > -1))
				|| ((!prefixDefined && postfixDefined) && post.indexOf(postfix) > -1)
				|| ((!prefixDefined && !postfixDefined) && (validFormat.indexOf(str.charAt(0)) > -1 && validFormat.indexOf(str.charAt(slen-1)) > -1))
				){
					break;
				}
			}
			var flist = [];
			flist.push(formatsList[i]);
			switch(i){
				case 0:
					num = _parseFormats(str,flist);
					break;
				case 1:
					num = _parseFormats(str,flist,true);
					break;
				case 2:
					num = 0;
					break;
				default:
					throw new Error("internal error. couldn't parse list format");
			}
			break;
		default:
			throw new Error(flen===0 ? "error. no format specified" : "error. too many formats specified");
	}
	return num;
}