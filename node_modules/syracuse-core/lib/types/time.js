"use strict";
const locale = require("syracuse-core/lib/locale");
const helpers = require("../helpers");
const date = require("./date");

const _resources = date.resources;

exports.validate = function(value, constraints, errors) {
	if (value == null) {
		if (constraints.$isMandatory) return errors.push(locale.format(module, "valMan"));
		if (!constraints.$isNullable) return errors.push(locale.format(module, "valNull"));
		return;
	}
	if (!(value instanceof Time)) {
		errors.push(locale.format(module, "valTime"));
		return;
	}
};

function _pad2(val) {
	const s = val.toString();
	return (s.length == 1) ? "0" + s : s;
}

function _parse2(str, beg, end) {
	return parseInt(str.substring(beg, end), 10);
}

function _make(hour, minute, second) {
	return new Time(hour * 3600 + (minute || 0) * 60 + (second || 0));
}

function _amDesignator() {
	return date.amDesignator();
}

function _pmDesignator() {
	return date.pmDesignator();
}

class Time {
	constructor(value) {
		// force modulo on value to bring it back in range
		value = (value + 86400 * 365 * 10000) % 86400;
		this._value = value;
	}
	get hour() {
		return Math.floor(this._value / 3600);
	}
	get minute() {
		return Math.floor(this._value / 60) % 60;
	}
	get second() {
		return this._value % 60;
	}
	get value() {
		return this._value;
	}
	valueOf() {
		return this.toString();
	}
	compare(time) {
		return this._value - time._value;
	}
	equals(time) {
		return this._value === time._value;
	}
	between(begin, end) {
		return begin._value <= this._value && this._value <= end._value;
	}
	begOfDay() {
		return _make(0, 0, 0);
	}
	endOfDay() {
		return _make(23, 59, 59);
	}
	begOfHour() {
		return _make(this.hour, 0, 0);
	}
	endOfHour() {
		return _make(this.hour, 59, 59);
	}
	begOfMinute() {
		return _make(this.hour, this.minute, 0);
	}
	endOfMinute() {
		return _make(this.hour, this.minute, 59);
	}

	// format as
	toString(format) {
		const self = this;
		if (format == null) {
			return _pad2(self.hour) + ":" + _pad2(self.minute) + ":" + _pad2(self.second);
		} else {
			var result = '';
			_walkFormat(format, {
				literal: function(lit) {
					result += lit;
				},
				H: function(repeat) {
					switch (repeat) {
						case 1:
							result += self.hour;
							break;
						case 2:
							result += _pad2(self.hour);
							break;
						default:
							throw new Error(locale.format(module, "formatH", repeat));
					}
				},
				h: function(repeat) {
					var hour;
					switch (repeat) {
						case 1:
							hour = self.hour;
							if (hour === 0) {
								result += 12;
							} else {
								result += hour > 12 ? hour - 12 : hour;
							}
							break;
						case 2:
							hour = self.hour;
							if (hour === 0) {
								result += 12;
							} else {
								result += hour > 12 ? _pad2(hour - 12) : _pad2(hour);
							}
							break;
						default:
							throw new Error(locale.format(module, "formath", repeat));
					}
				},
				m: function(repeat) {
					switch (repeat) {
						case 2:
							result += _pad2(self.minute);
							break;
						default:
							throw new Error(locale.format(module, "formatm", repeat));
					}
				},
				s: function(repeat) {
					switch (repeat) {
						case 2:
							result += _pad2(self.second);
							break;
						default:
							throw new Error(locale.format(module, "formats", repeat));
					}
				},
				t: function(repeat) {
					switch (repeat) {
						case 1:
							result += self.hour < 12 ? _amDesignator().substring(0, 1) : _pmDesignator().substring(0, 1);
							break;
						case 2:
							result += self.hour < 12 ? _amDesignator() : _pmDesignator();
							break;
						default:
							throw new Error(locale.format(module, "formata", repeat));
					}
				}
			});
			return result;
		}

	}
	secondsDiff(t) {
		return this._value - t._value;
	}

	// add functions circle from 23:59:59 to 00:00:00 without warning
	addHours(hours) {
		return hours == 0 ? this : new Time(this._value + hours * 3600);
	}
	addMinutes(minutes) {
		return minutes == 0 ? this : new Time(this._value + minutes * 60);
	}
	addSeconds(seconds) {
		return seconds == 0 ? this : new Time(this._value + seconds);
	}
	add(delta) {
		return this.addHours(delta.hours || 0).addMinutes(delta.minutes || 0).addSeconds(delta.seconds || 0);
	}
	isNull() {
		return this._value == 0;
	}
}

exports.make = _make;

exports.fromSeconds = function(seconds) {
	return new Time(seconds);
};

exports.fromJsDate = function(js, utc) {
	return utc ? _make(js.getUTCHours(), js.getUTCMinutes(), js.getUTCSeconds()) : _make(js.getHours(), js.getMinutes(), js.getSeconds());
};

exports.now = function(utc) {
	return exports.fromJsDate(new Date(), utc);
};

exports.parse = function(str, format) {
	if (str == null) throw new Error(locale.format(module, "isNull"));

	if (format == null) {
		// RFC 3339 full time without fraction -- very fast
		// hh:mm
		if (str.length != 5 && str.length != 8) throw new Error(locale.format(module, "badFormat", str));

		const value = str.length == 8 ? _parse2(str, 0, 2) * 3600 + _parse2(str, 3, 5) * 60 + _parse2(str, 6, 8) : _parse2(str, 0, 2) * 3600 + _parse2(str, 3, 5) * 60;
		return new Time(value);
	} else {
		return _parse(str, format);
	}
};

function _walkFormat(format, map) {
	var i = 0;
	const len = format.length;

	function count(i) {
		const ch = format[i];
		var k = 1;
		while (format[i + k] === ch)
			k++;
		return k;
	}

	while (i < len) {
		const c = format[i];
		switch (c) {
			case "'":
				i++;
				var literal = '';
				// going to the end of the following literal or to the format end
				for (; i < len; i++) {
					if (format[i] === "'") {
						i++;
						// check whether the "'" is not doubled
						if (format[i] === "'") {
							literal += "'";
						} else break;
					} else {
						literal += format[i];
					}
				}
				map.literal(literal);
				break;
			case "H":
			case "h":
			case "m":
			case "s":
			case "t":
				const repeat = count(i);
				map[c](repeat);
				i += repeat;
				break;
			default:
				map.literal(c);
				i++;
		}
	}
}

function _parse(str, format) {
	var hour, minute, second, timeMode, abbrTimeMode;
	const timeModes = [_amDesignator(), _pmDesignator()];
	//const timeModes = _resources().amDesignator ? [_resources().amDesignator, _resources().pmDesignator] : ["AM", "PM"];
	const abbrTimeModes = [timeModes[0].substring(0, 1), timeModes[1].substring(0, 1)];
	//const abbrTimeModes = _resources().amDesignator ? [_resources().amDesignator.substring(0, 1), _resources().pmDesignator.substring(0, 1)] : ["A", "P"];
	// position in str
	var j = 0;

	function parseInteger(max) {
		if (!/\d/.test(str[j])) {
			throw new Error(locale.format(module, "noNumber", str.substring[j]));
		}
		const beg = j++;
		while (j < beg + max && /\d/.test(str[j]))
			j++;
		return parseInt(str.substring(beg, j), 10);
	}

	function parseName(names) {
		for (var k = 0; k < names.length; k++) {
			const name = names[k],
			len = name.length;
			if (str.substring(j, j + len).toUpperCase() == name.toUpperCase()) {
				j += len;
				return k;
			}
		}
		throw new Error(locale.format(module, "unknown", str.substring(j)));
	}

	_walkFormat(format, {
		literal: function(literal) {
			if (str.substring(j, j + literal.length) !== literal) throw new Error(locale.format(module, "wrongFormat", literal, str.substring(j)));
			j += literal.length;
		},
		H: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					hour = parseInteger(2);
					break;
				default:
					throw new Error(locale.format(module, "badHour", format.substring(j))); // replaced i with j
			}
		},
		h: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					hour = parseInteger(2);
					break;
				default:
					throw new Error(locale.format(module, "badHour", format.substring(j)));
			}
		},
		m: function(arg) {
			switch (arg) {
				case 2:
					minute = parseInteger(2);
					break;
				default:
					throw new Error(locale.format(module, "badMin", format.substring(j)));
			}
		},
		s: function(arg) {
			switch (arg) {
				case 2:
					second = parseInteger(2);
					break;
				default:
					throw new Error(locale.format(module, "badSec", format.substring(j)));
			}
		},
		t: function(arg) {
			switch (arg) {
				case 1:
					abbrTimeMode = parseName(abbrTimeModes);
					break;
				case 2:
					timeMode = parseName(timeModes);
					break;
				default:
					throw new Error(locale.format(module, "badMarker", format.substring(j)));
			}
		}
	});

	// from 12 format to 24 format, used when necessary

	function from12to24(mode, index) {
		switch (mode[index]) {
			case mode[0]:
				// AM
				hour = hour === 12 ? 0 : hour;
				break;
			case mode[1]:
				// PM
				if (hour >= 1 && hour <= 11) {
					hour += 12;
				}
				break;
		}
	}

	if (timeMode != null || abbrTimeMode != null) {
		if (hour > 12) throw new Error(locale.format(module, "badHourVal", hour, timeMode));
		const mode = timeMode != null ? timeModes : abbrTimeModes;
		const index = timeMode != null ? timeMode : abbrTimeMode;
		from12to24(mode, index);
	}

	return _make(hour, minute, second);
}

exports.amDesignator = _amDesignator;
exports.pmDesignator = _pmDesignator;