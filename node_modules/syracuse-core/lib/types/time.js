"use strict";
var helpers = require("../helpers");
var date = require("./date");

var _resources = date.resources;

exports.validate = function(value, constraints, errors) {
	if (value == null) {
		if (constraints.$isMandatory) return errors.push("value is mandatory");
		if (!constraints.$isNullable) return errors.push("value cannot be null");
		return;
	}
	if (!(value instanceof Time)) {
		errors.push("value must be a time");
		return;
	}
};

function Time(value) {
	// force modulo on value to bring it back in range
	value = (value + 86400 * 365 * 10000) % 86400;
	this._value = value;
}

function _pad2(val) {
	var s = val.toString();
	return (s.length == 1) ? "0" + s : s;
}

function _parse2(str, beg, end) {
	return parseInt(str.substring(beg, end), 10);
}

function _make(hour, minute, second) {
	return new Time(hour * 3600 + (minute || 0) * 60 + (second || 0));
}

function _amDesignator() {
	return date.amDesignator();
}

function _pmDesignator() {
	return date.pmDesignator();
}

helpers.defineClass(Time, null, {
	hour: {
		get: function() {
			return Math.floor(this._value / 3600);
		}
	},
	minute: {
		get: function() {
			return Math.floor(this._value / 60) % 60;
		}
	},
	second: {
		get: function() {
			return this._value % 60;
		}
	},
	value: {
		get: function() {
			return this._value;
		}
	},
	valueOf: function() {
		return this.toString();
	},
	compare: function(time) {
		return this._value - time._value;
	},
	equals: function(time) {
		return this._value === time._value;
	},
	between: function(begin, end) {
		return begin._value <= this._value && this._value <= end._value;
	},

	begOfDay: function() {
		return _make(0, 0, 0);
	},
	endOfDay: function() {
		return _make(23, 59, 59);
	},
	begOfHour: function() {
		return _make(this.hour, 0, 0);
	},
	endOfHour: function() {
		return _make(this.hour, 59, 59);
	},
	begOfMinute: function() {
		return _make(this.hour, this.minute, 0);
	},
	endOfMinute: function() {
		return _make(this.hour, this.minute, 59);
	},

	// format as
	toString: function(format) {
		var self = this;
		if (format == null) {
			return _pad2(self.hour) + ":" + _pad2(self.minute) + ":" + _pad2(self.second);
		} else {
			var result = '';
			_walkFormat(format, {
				literal: function(lit) {
					result += lit;
				},
				H: function(repeat) {
					switch (repeat) {
						case 1:
							result += self.hour;
							break;
						case 2:
							result += _pad2(self.hour);
							break;
						default:
							throw new Error("bad format directive H: " + repeat);
					}
				},
				h: function(repeat) {
					switch (repeat) {
						case 1:
							var hour = self.hour;
							if (hour === 0) {
								result += 12;
							} else {
								result += hour > 12 ? hour - 12 : hour;
							}
							break;
						case 2:
							var hour = self.hour;
							if (hour === 0) {
								result += 12;
							} else {
								result += hour > 12 ? _pad2(hour - 12) : _pad2(hour);
							}
							break;
						default:
							throw new Error("bad format directive h: " + repeat);
					}
				},
				m: function(repeat) {
					switch (repeat) {
						case 2:
							result += _pad2(self.minute);
							break;
						default:
							throw new Error("bad format directive m: " + repeat);
					}
				},
				s: function(repeat) {
					switch (repeat) {
						case 2:
							result += _pad2(self.second);
							break;
						default:
							throw new Error("bad format directive s: " + repeat);
					}
				},
				t: function(repeat) {
					switch (repeat) {
						case 1:
							result += self.hour < 12 ? _amDesignator().substring(0, 1) : _pmDesignator().substring(0, 1);
							break;
						case 2:
							result += self.hour < 12 ? _amDesignator() : _pmDesignator();
							break;
						default:
							throw new Error("bad format directive a: " + repeat);
					}
				}
			});
			return result;
		}

	},

	secondsDiff: function(t) {
		return this._value - t._value;
	},

	// add functions circle from 23:59:59 to 00:00:00 without warning
	addHours: function(hours) {
		return hours == 0 ? this : new Time(this._value + hours * 3600);
	},
	addMinutes: function(minutes) {
		return minutes == 0 ? this : new Time(this._value + minutes * 60);
	},
	addSeconds: function(seconds) {
		return seconds == 0 ? this : new Time(this._value + seconds);
	},
	add: function(delta) {
		return this.addHours(delta.hours || 0).addMinutes(delta.minutes || 0).addSeconds(delta.seconds || 0);
	}
});

exports.make = _make;

exports.fromSeconds = function(seconds) {
	return new Time(seconds);
};

exports.fromJsDate = function(js, utc) {
	return utc ? _make(js.getUTCHours(), js.getUTCMinutes(), js.getUTCSeconds()) : _make(js.getHours(), js.getMinutes(), js.getSeconds());
};

exports.now = function(utc) {
	return exports.fromJsDate(new Date(), utc);
};

exports.parse = function(str, format) {
	if (str == null) throw new Error("time is null");

	if (format == null) {
		// RFC 3339 full time without fraction -- very fast
		// hh:mm
		if (str.length != 5 && str.length != 8) throw new Error("bad time format, expected hh:mm or hh:mm:ss, got " + str);

		var value = str.length == 8 ? _parse2(str, 0, 2) * 3600 + _parse2(str, 3, 5) * 60 + _parse2(str, 6, 8) : _parse2(str, 0, 2) * 3600 + _parse2(str, 3, 5) * 60;
		return new Time(value);
	} else {
		return _parse(str, format);
	}
};

function _walkFormat(format, map) {
	var i = 0,
		len = format.length;

	function count(i) {
		var ch = format[i],
			k = 1;
		while (format[i + k] === ch)
		k++;
		return k;
	}

	while (i < len) {
		var c = format[i];
		switch (c) {
			case "'":
				i++;
				var literal = '';
				// going to the end of the following litteral or to the format end
				for (; i < len; i++) {
					if (format[i] === "'") {
						i++;
						// check wether the "'" is not doubled
						if (format[i] === "'") {
							literal += "'";
						} else break;
					} else {
						literal += format[i];
					}
				}
				map.literal(literal);
				break;
			case "H":
			case "h":
			case "m":
			case "s":
			case "t":
				var repeat = count(i);
				map[c](repeat);
				i += repeat;
				break;
			default:
				map.literal(c);
				i++;
		}
	}
}

function _parse(str, format) {
	var hour, minute, second, timeMode, abbrTimeMode;
	var timeModes = [_amDesignator(), _pmDesignator()];
	//var timeModes = _resources().amDesignator ? [_resources().amDesignator, _resources().pmDesignator] : ["AM", "PM"];
	var abbrTimeModes = [timeModes[0].substring(0, 1), timeModes[1].substring(0, 1)];
	//var abbrTimeModes = _resources().amDesignator ? [_resources().amDesignator.substring(0, 1), _resources().pmDesignator.substring(0, 1)] : ["A", "P"];
	// position in str
	var j = 0;

	function parseInteger(max) {
		if (!/\d/.test(str[j])) {
			throw new Error("invalid date: expected number, got " + str.substring[j]);
		}
		var beg = j++;
		while (j < beg + max && /\d/.test(str[j]))
		j++;
		return parseInt(str.substring(beg, j), 10);
	}

	function parseName(names) {
		for (var k = 0; k < names.length; k++) {
			var name = names[k],
				len = name.length;
			if (str.substring(j, j + len).toUpperCase() == name.toUpperCase()) {
				j += len;
				return k;
			}
		}
		throw new Error("unknown time format: " + str.substring(j));
	}

	_walkFormat(format, {
		literal: function(literal) {
			if (str.substring(j, j + literal.length) !== literal) throw new Error("format mismatch: expected " + literal + ", got " + str.substring(j));
			j += literal.length;
		},
		H: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					hour = parseInteger(2);
					break;
				default:
					throw new Error("bad hour format: " + format.substring(i));
			}
		},
		h: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					hour = parseInteger(2);
					break;
				default:
					throw new Error("bad hour format: " + format.substring(i));
			}
		},
		m: function(arg) {
			switch (arg) {
				case 2:
					minute = parseInteger(2);
					break;
				default:
					throw new Error("bad minute format: " + format.substring(i));
			}
		},
		s: function(arg) {
			switch (arg) {
				case 2:
					second = parseInteger(2);
					break;
				default:
					throw new Error("bad second format: " + format.substring(i));
			}
		},
		t: function(arg) {
			switch (arg) {
				case 1:
					abbrTimeMode = parseName(abbrTimeModes);
					break;
				case 2:
					timeMode = parseName(timeModes);
					break;
				default:
					throw new Error("bad AM/PM marker format: " + format.substring(i));
			}
		}
	});

	// from 12 format to 24 format, used when necessary
	function from12to24(mode, index) {
		switch (mode[index]) {
			case mode[0]:
				// AM
				hour = hour === 12 ? 0 : hour;
				break;
			case mode[1]:
				// PM
				if (hour >= 1 && hour <= 11) {
					hour += 12;
				}
				break;
		}
	}

	if (timeMode != null || abbrTimeMode != null) {
		if (hour > 12) throw new Error("bad hour value: expected 1<hour<12, got :" + hour + " for mode :" + timeMode);
		var mode = timeMode != null ? timeModes : abbrTimeModes;
		var index = timeMode != null ? timeMode : abbrTimeMode;
		from12to24(mode, index);
	}

	return _make(hour, minute, second);
}

exports.amDesignator = _amDesignator;
exports.pmDesignator = _pmDesignator;