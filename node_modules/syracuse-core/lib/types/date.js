"use strict";
/* @flow */
/*::
import type { TypeConstraint } from './constraint';
*/

var locale = require("syracuse-core/lib/locale");
var helpers = require("../helpers");
var locale = require("../locale");
var _resources = locale.resources(module);

exports.resources = _resources;

exports.validate = function(value: any, constraints: TypeConstraint, errors: string[]): void {
	if (value == null) {
		if (constraints.$isMandatory)
			errors.push(locale.format(module, "valMan"));
		else if (!constraints.$isNullable)
			errors.push(locale.format(module, "valNull"));
		return;
	}
	if (!(value instanceof DateObj)) {
		errors.push(locale.format(module, "valDate"));
		return;
	}

	// month value check
	if (!(value.month >= 1 && value.month <= 12)) {
		errors.push(locale.format(module, "invMonth"));
		return;
	}

	// day value check
	if (!(value.day >= 1 && value.day <= _daysInMonth(value.year, value.month))) {
		errors.push(locale.format(module, "invDay"));
		return;
	}

};

var _monthOffsets = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
var _monthLengths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

// internal value is integer yyyymmdd
// this is a very simple and compact representation that leads to
// very efficient component extraction and formatting. 
// Also nice for debugging

function _dayName(weekDay: number, abbrev ? : boolean): string {
	return abbrev ? _resources().abbreviatedDayNames[weekDay] : _resources().dayNames[weekDay];
}

function _monthName(month: number, abbrev ? : boolean): string {
	return abbrev ? _resources().abbreviatedMonthNames[month - 1] : _resources().monthNames[month - 1];
}

function _pad2(val) {
	var s = val.toString();
	return (s.length == 1) ? "0" + s : s;
}

function _toOffset(date) {
	var year = date.year;
	var month = date.month;
	var day = date.day;
	// Compute the number of leap days since Jan 1st, 1970.
	// The trick is to use the previous year if month is January or February,
	// the current year otherwise.
	// Then, we compute the number of multiples of 4, 100 and 400 since 1970.
	var y = month <= 2 ? year - 1 : year;

	var n4 = Math.floor(y / 4) - Math.floor(1970 / 4);
	var n100 = Math.floor(y / 100) - Math.floor(1970 / 100);
	var n400 = Math.floor(y / 400) - Math.floor(1970 / 400);

	// Years that are multiple of 400 (like 2000) contribute by 1 (1 -1 +1 in expression below)
	// Years that are multiple of 100 but not of 400 contribute by 0 (1 -1 +0 in expression below)
	// Years that are multiple of 4 but not 100 nor 400 contribute by 1 (1 -0 +0 in expression below).
	var nLeap = n4 - n100 + n400;

	// The offset is straightforward at this point.
	// The February/March transition on leap days will be handled by the fact that the
	// 'y' value above will change, and hence the 'nLeap' value.
	return (year - 1970) * 365 + nLeap + _monthOffsets[month - 1] + day - 1;
}

function _fromOffset(offset: number) {
	var julian = 2440588 + offset;
	var l = julian + 68569;
	var n = Math.floor((4 * l) / 146097);
	l = l - Math.floor((146097 * n + 3) / 4);
	var i = Math.floor((4000 * (l + 1)) / 1461001);
	l = l - Math.floor((1461 * i) / 4) + 31;
	var j = Math.floor((80 * l) / 2447);
	var day = l - Math.floor((2447 * j) / 80);
	l = Math.floor(j / 11);
	var month = j + 2 - (12 * l);
	var year = 100 * (n - 49) + i + l;
	return new DateObj(year * 10000 + month * 100 + day);
}

function _make(year: number, month: number, day: number): DateObj {
	return new DateObj(year * 10000 + month * 100 + day);
}

function _isLeap(year: number): boolean {
	return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}

function _daysInMonth(year: number, month: number): number {
	return month == 2 ? (_isLeap(year) ? 29 : 28) : _monthLengths[month - 1];
}

function _isWorkDay(weekDay) {
	return weekDay != 0 && weekDay != 6;
}

function _amDesignator(): string {
	return _resources().amDesignator || "AM";
}

function _pmDesignator(): string {
	return _resources().pmDesignator || "PM";
}

exports.amDesignator = _amDesignator;
exports.pmDesignator = _pmDesignator;

// do not export the class
class DateObj {
	_value: number;
	constructor(value) {
		this._value = value;
		//Object.freeze(this); -- confuses JSON, reenable later
	}
	get year() {
		return Math.floor(this._value / 10000);
	}
	get month() {
		return Math.floor(this._value / 100) % 100;
	}
	get day() {
		return this._value % 100;
	}
	get weekDay() {
		// Add Julian offset (+1 because Julian origin is Monday) 
		// so that modulo is on positive value even if date is before 1970
		return ((2440588 + 1 + _toOffset(this)) % 7);
	}
	get yearDay() {
		var month = this.month;
		var leap = month > 2 && _isLeap(this.year) ? 1 : 0;
		return _monthOffsets[month - 1] + leap + this.day;
	}
	get week() {
		// ISO 8601 with week 0
		// week 1 is the beg of week that contains Jan 4th.
		var begOfWeek1 = _make(this.year, 1, 4).begOfWeek(1);
		return Math.floor((7 + _toOffset(this) - _toOffset(begOfWeek1)) / 7);
	}

	valueOf() {
		return this.toString();
	}
	compare(date) {
		return this._value - date._value;
	}
	equals(date) {
		return this._value === date._value;
	}
	between(begin, end) {
		return begin._value <= this._value && this._value <= end._value;
	}

	isLeapYear() {
		return _isLeap(this.year);
	}
	isWorkDay() {
		return _isWorkDay(this.weekDay);
	}
	daysInMonth() {
		return _daysInMonth(this.year, this.month);
	}

	begOfYear() {
		return _make(this.year, 1, 1);
	}
	endOfYear() {
		return _make(this.year, 12, 31);
	}
	begOfQuarter() {
		return _make(this.year, Math.floor((this.month - 1) / 3) * 3 + 1, 1);
	}
	endOfQuarter() {
		return this.begOfQuarter().addMonths(2).endOfMonth();
	}
	begOfMonth() {
		return _make(this.year, this.month, 1);
	}
	endOfMonth() {
		return _make(this.year, this.month, this.daysInMonth());
	}
	sameMonth(day) {
		day = Math.min(day, this.daysInMonth());
		return _make(this.year, this.month, day);
	}
	pastDay(day, includeThis) {
		var delta = day - this.day;
		return (delta > 0 || delta == 0 && !includeThis) ? this.addMonths(-1).sameMonth(day) : this.sameMonth(day);
	}
	futureDay(day, includeThis) {
		var delta = day - this.day;
		return (delta < 0 || delta == 0 && !includeThis) ? this.addMonths(1).sameMonth(day) : this.sameMonth(day);
	}
	pastMonth(month, includeThis) {
		var delta = this.month - month;
		delta = delta == 0 ? (includeThis ? 0 : 12) : delta > 0 ? delta : delta + 12;
		return this.addMonths(-delta);
	}
	futureMonth(month, includeThis) {
		var delta = month - this.month;
		delta = delta == 0 ? (includeThis ? 0 : 12) : delta > 0 ? delta : delta + 12;
		return this.addMonths(delta);
	}
	begOfWeek(startDay) { // 0: Sunday (default), 1: Monday
		var delta = this.weekDay - (startDay || 0);
		return delta == 0 ? this : delta > 0 ? this.addDays(-delta) : this.addDays(-delta - 7);
	}
	endOfWeek(startDay) {
		return this.begOfWeek(startDay).addDays(6);
	}
	sameWeek(weekDay, startDay) {
		return this.begOfWeek(startDay).futureWeekDay(weekDay, true);
	}
	pastWeekDay(weekDay, includeThis) {
		var result = this.begOfWeek(weekDay);
		return !includeThis && result.equals(this) ? this.addWeeks(-1) : result;
	}
	futureWeekDay(weekDay, includeThis) {
		return this.pastWeekDay(weekDay, !includeThis).addWeeks(1);
	}
	addYears(years) {
		if (years == 0)
			return this;
		var year = this.year + years;
		var month = this.month;
		var day = Math.min(this.day, _daysInMonth(year, month));
		return _make(year, month, day);
	}
	addMonths(months: number) {
		if (months == 0)
			return this;
		var self = this;
		var day = self.day;
		var month0 = self.month - 1;
		var year = self.year;
		month0 += months;
		year += Math.floor(month0 / 12);
		var month = (month0 + 120000) % 12 + 1;
		var monthLen = _daysInMonth(year, month);
		day = day < monthLen ? day : monthLen;
		return _make(year, month, day);
	}
	addWeeks(weeks) {
		return this.addDays(7 * weeks);
	}
	addDays(days) {
		if (days == 0)
			return this;
		return _fromOffset(_toOffset(this) + days);
	}

	daysDiff(date) {
		return _toOffset(this) - _toOffset(date);
	}

	/**
     * Adds (or subtracts) to the value of the year, month, day, hour, minute, second, millisecond of the date instance using given configuration object. Positive and Negative values allowed.
     * Example
     <pre><code>
     Date.today().add( { day: 1, month: 1 } )
     </code></pre>
     * @param {Object}   Configuration object containing attributes (month, day, etc.)
     * @return {Date}    this
     */
	add(delta) {
		return this.addYears(delta.years || 0).addMonths(delta.months || 0).addWeeks(delta.weeks || 0).addDays(delta.days || 0);
	}

	// format as 
	toString(format) {
		var self = this;
		if (format == null) {
			// RFC 3339 by default -- very fast
			var str = self._value.toString();
			str = helpers.string.padLeft(str, 8, "0");
			return str.substring(0, 4) + "-" + str.substring(4, 6) + "-" + str.substring(6, 8);
		} else {
			var result = '';
			_walkFormat(format, {
				literal: function(lit) {
					result += lit;
				},
				d: function(repeat) {
					switch (repeat) {
						case 1:
							result += self.day.toString();
							break;
						case 2:
							result += _pad2(self.day);
							break;
						case 3:
							result += _dayName(self.weekDay, true);
							break;
						case 4:
							result += _dayName(self.weekDay);
							break;
						default:
							throw new Error(locale.format(module, "formatd", repeat));
					}
				},
				M: function(repeat) {
					switch (repeat) {
						case 1:
							result += self.month.toString();
							break;
						case 2:
							result += _pad2(self.month);
							break;
						case 3:
							result += _monthName(self.month, true);
							break;
						case 4:
							result += _monthName(self.month);
							break;
						default:
							throw new Error(locale.format(module, "formatM", repeat));
					}
				},
				y: function(repeat) {
					switch (repeat) {
						case 2:
							result += self.year.toString().substring(2, 4);
							break;
						case 4:
							result += self.year.toString();
							break;
						default:
							throw new Error(locale.format(module, "formatM", repeat));
					}
				}
			});
			return result;
		}
	}

	at(time, millisecond) {
		throw new Error(locale.format(module, "notInstalled"));
	}

	toJsDate(utc) {
		return utc ? new Date(Date.UTC(this.year, this.month - 1, this.day)) : new Date(this.year, this.month - 1, this.day);
	}

	isNull() {
		return this._value == 0;
	}
}

exports.monthName = _monthName;

/**
 * Gets the month number (1-12) if given a Culture Info specific string which is a valid monthName or abbreviatedMonthName.
 * @param {String}   The name of the month (eg. "February, "Feb", "october", "oct").
 * @return {Number}  The day number
 */
exports.monthFromName = function(name: string): number {
	var n = _resources().monthNames,
		m = _resources().abbreviatedMonthNames,
		s = name.toLowerCase();
	for (var i = 0; i < n.length; i++) {
		if (n[i].toLowerCase() == s || m[i].toLowerCase() == s) {
			return i + 1;
		}
	}
	return -1;
};

exports.dayName = _dayName;

/**
 * Gets the day number (0-6) if given a CultureInfo specific string which is a valid dayName, abbreviatedDayName or shortestDayName (two char).
 * @param {String}   The name of the day (eg. "Monday, "Mon", "tuesday", "tue", "We", "we").
 * @return {Number}  The day number
 */
exports.weekDayFromName = function(name: string): number {
	var n = _resources().dayNames,
		m = _resources().abbreviatedDayNames,
		o = _resources().shortestDayNames,
		s = name.toLowerCase();
	for (var i = 0; i < n.length; i++) {
		if (n[i].toLowerCase() == s || m[i].toLowerCase() == s) {
			return i;
		}
	}
	return -1;
};

exports.isLeap = _isLeap;

exports.daysInMonth = _daysInMonth;

exports.today = function(utc ? : boolean): DateObj {
	return exports.fromJsDate(new Date(), utc);
};

function _walkFormat(format: string, map: {
	[key: string]: (arg: any) => void
}) {
	var i = 0,
		len = format.length;

	function count(i) {
		var ch = format[i],
			k = 1;
		while (format[i + k] === ch)
			k++;
		return k;
	}

	while (i < len) {
		var c = format[i];
		switch (c) {
			case "'":
				i++;
				var literal = '';
				// going to the end of the following litteral or to the format end
				for (; i < len; i++) {
					if (format[i] === "'") {
						i++;
						// check wether the "'" is not doubled
						if (format[i] === "'") {
							literal += "'";
						} else
							break;
					} else {
						literal += format[i];
					}
				}
				map.literal(literal);
				break;
			case "d":
			case "M":
			case "y":
				var repeat = count(i);
				map[c](repeat);
				i += repeat;
				break;
			default:
				map.literal(c);
				i++;

		}
	}
}

function _parse(str, format) {
	var day = 0,
		weekday, month = 0,
		year = 0;
	// position in str
	var j = 0;

	function parseInteger(max: number) {
		if (!/\d/.test(str[j])) {
			throw new Error(locale.format(module, "notNumber", str.substring[j]));
		}
		var beg = j++;
		while (j < beg + max && /\d/.test(str[j]))
			j++;
		return parseInt(str.substring(beg, j), 10);
	}

	function parseName(names) {
		for (var k = 0; k < names.length; k++) {
			var name = names[k],
				len = name.length;
			if (str.substring(j, j + len).toUpperCase() == name.toUpperCase()) {
				j += len;
				return k;
			}
		}
		throw new Error(locale.format(module, "unknown", str.substring(j)));
	}

	_walkFormat(format, {
		literal: function(literal) {
			if (str.substring(j, j + literal.length) !== literal)
				throw new Error(locale.format(module, "wrongFormat", literal, str.substring(j)));
			j += literal.length;
		},
		d: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					day = parseInteger(2);
					break;
				case 3:
					weekday = parseName(_resources().abbreviatedDayNames);
					break;
				case 4:
					weekday = parseName(_resources().dayNames);
					break;
				default:
					throw new Error(locale.format(module, "badDay", format.substring(j))); // replaced i with j
			}
		},
		M: function(arg) {
			switch (arg) {
				case 1:
				case 2:
					month = parseInteger(2);
					break;
				case 3:
					month = parseName(_resources().abbreviatedMonthNames) + 1;
					break;
				case 4:
					month = parseName(_resources().monthNames) + 1;
					break;
				default:
					throw new Error(locale.format(module, "badDay", format.substring(j))); // replaced i with j
			}
		},
		y: function(arg) {
			switch (arg) {
				case 2:
					year = parseInteger(2);
					year = year < 40 ? 2000 + year : 1900 + year;
					break;
				case 4:
					year = parseInteger(4);
					break;
				default:
					throw new Error(locale.format(module, "badYear", format.substring(j))); // replaced i with j
			}
		}
	});

	//console.log(result);
	// ignore weekday
	return _make(year, month, day);
}

exports.parse = function(str: string, format: string): DateObj {
	if (str == null)
		throw new Error(locale.format(module, "dateNull"));

	if (format == null) {
		// RFC 3339 by default -- very fast
		if (str.length != 10)
			throw new Error(locale.format(module, "badFormat", str));
		var value = parseInt(str.replace(/-/g, ''), 10);
		return new DateObj(value);
	} else {
		return _parse(str, format);
	}
};

// used for format conversions
exports.walkFormat = _walkFormat;

exports.fromJsDate = function(jsDate: Date, utc ? : boolean): DateObj {
	return utc ? _make(jsDate.getUTCFullYear(), jsDate.getUTCMonth() + 1, jsDate.getUTCDate()) : _make(jsDate.getFullYear(), jsDate.getMonth() + 1, jsDate.getDate());
};

exports.fromInternalValue = function(value: number): DateObj {
	return new DateObj(value);
};

exports.makeInWeek = function(year: number, week: number, wday: number): DateObj {
	var dday = wday ? wday - 1 : 6;
	return _make(year, 1, 4).begOfWeek(1).addDays(7 * (week - 1) + dday);
};
exports.isDate = function(obj: any): boolean {
	return obj instanceof DateObj;
};


exports.sunday = 0;
exports.Sunday = 0;
exports.monday = 1;
exports.Monday = 1;
exports.tuesday = 2;
exports.Tuesday = 2;
exports.wednesday = 3;
exports.Wednesday = 3;
exports.thursday = 4;
exports.Thursday = 4;
exports.friday = 5;
exports.Friday = 5;
exports.saturday = 6;
exports.Saturday = 6;

exports.make = _make;