"use strict";
var locale = require("syracuse-core/lib/locale");
var helpers = require("../helpers");
var bigint = require("./bigint");
var locale = require("../locale");
var _resources = locale.resources(module);
exports.resources = _resources;
var globals = require("streamline/lib/globals");

// IMPORTANT TO SET numberFormat var AFTER exporting resources
// will be improved
var numberFormat = require("./numberFormat");

exports.validate = function(value, constraints, errors) {
	if (value == null) {
		if (constraints.$isMandatory) return errors.push(locale.format(module, "valMan"));
		if (!constraints.$isNullable) return errors.push(locale.format(module, "valNull"));
		return;
	}
	if (!(value instanceof BigDecimal)) {
		errors.push(locale.format(module, "valDec"));
		return;
	}
	if (constraints.$minimum != null) {
		if (constraints.$minimumCanEqual) {
			if (value.compare.compareTo(_make(constraints.$minimum)) < 0) errors.push(locale.format(module, "valGe", constraints.$minimum));
		} else {
			if (value.compare.compareTo(_make(constraints.$minimum)) <= 0) errors.push(locale.format(module, "valGt", constraints.$minimum));
		}
	}
	if (constraints.$maximum != null) {
		if (constraints.$maximumCanEqual) {
			if (value.compare.compareTo(_make(constraints.$maximum)) > 0) errors.push(locale.format(module, "valLe", constraints.$maximum));
		} else {
			if (value.compare.compareTo(_make(constraints.$maximum)) >= 0) errors.push(locale.format(module, "valLt", constraints.$maximum));
		}
	}
};

var _zero = "00000000000000000000000000000000000000000000000000000000000";
var
CEILING = 0, //Rounding mode to round towards positive infinity.
	DOWN = 1, //Rounding mode to round towards zero.
	FLOOR = 2, //Rounding mode to round towards negative infinity.
	HALF_DOWN = 3, //Rounding mode to round towards "nearest neighbor" unless both neighbors are equidistant, in which case round down.
	HALF_EVEN = 4, //Rounding mode to round towards the "nearest neighbor" unless both neighbors are equidistant, in which case, round towards the even neighbor.
	HALF_UP = 5, //Rounding mode to round towards "nearest neighbor" unless both neighbors are equidistant, in which case round up.
	UNNECESSARY = 6, //Rounding mode to assert that the requested operation has an exact result, hence no rounding is necessary.
	UP = 7, //Rounding mode to round away from zero.
	HALF_CEILING = 8; // when value > 0  HALF_UP, when value < 0 HALF_DOWN

exports.CEILING = CEILING;
exports.DOWN = DOWN;
exports.FLOOR = FLOOR;
exports.HALF_DOWN = HALF_DOWN;
exports.HALF_EVEN = HALF_EVEN;
exports.HALF_UP = HALF_UP;
exports.UNNECESSARY = UNNECESSARY;
exports.UP = UP;
exports.HALF_CEILING = HALF_CEILING;

/*
 *   new BigDecimal(x)= {_value: new BigInteger(x*Math.pow(10, max_scale)), _scale: integer}
 */
function BigDecimal(value, scale, bInt) {
	var self = this;
	self._scale = ((scale != null) ? scale : self.max_scale);
	if (bInt) self._value = bInt.clone();
	else {
		if (typeof value == "number") {
			value = value.toFixed(self._scale);
		}
		var ti = value.indexOf(".");
		if (ti >= 0) {
			var tmp = value.substr(ti + 1, 10);
			tmp = tmp + self._zero(self.max_scale - tmp.length);
			value = value.substr(0, ti) + tmp;
		} else {
			value = value + self._zero(self.max_scale);
		}
		self._value = bigint.make(value);
	}
}

BigDecimal.prototype.max_scale = 10;
BigDecimal.prototype.rounding_mode = HALF_CEILING;

function _make(value, scale) {
	return new BigDecimal(value, scale);
}
helpers.defineClass(BigDecimal, null, {
	_zero: function(size) {
		return _zero.substr(0, size);
	},
	_factorInt: function(value, signum) {
		var self = this;
		if (value == null) value = self.max_scale;
		if (signum == null) signum = 1;
		return bigint.make(signum + self._zero(value));
	},
	_roundToScale: function(scale, roundingMode) {
		var self = this;
		if (roundingMode == null) roundingMode = self.rounding_mode;
		var s = (scale == null) ? self._scale : scale;
		if (s >= self.max_scale) return;
		var trunc = self._value.divide(self._factorInt(self.max_scale - s)).multiply(self._factorInt(self.max_scale - s));

		var rest = self._value.subtract(trunc).abs();
		var compare = bigint.make("5" + self._zero(self.max_scale - s - 1));
		var signum = self._value.signum();
		if (rest.equals(bigint.make(0))) {
			self._value = trunc;
			return;
		}
		switch (roundingMode) {
			case CEILING:
				if (signum > 0) self._value = trunc.add(self._factorInt(self.max_scale - s, signum));
				else self._value = trunc;
				return;
			case FLOOR:
				if (signum > 0) self._value = trunc;
				else self._value = trunc.add(self._factorInt(self.max_scale - s, signum));
				return;
			case UP:
				self._value = trunc.add(self._factorInt(self.max_scale - s, signum));
				return;
			case DOWN:
				self._value = trunc;
				return;
		}
		var cr = compare.compareTo(rest);
		if (cr == 0) {
			switch (roundingMode) {
				case HALF_DOWN:
					self._value = trunc;
					break;
				case HALF_UP:
					self._value = trunc.add(self._factorInt(self.max_scale - s, signum));
					break;
				case HALF_EVEN:
					var isOdd = self._value.divide(self._factorInt(self.max_scale)).testBit(0);
					if (isOdd) self._value = trunc.add(self._factorInt(self.max_scale - s, signum));
					else self._value = trunc;
					break;
				default:
					if (signum > 0) self._value = trunc.add(self._factorInt(self.max_scale - s, signum));
					else self._value = trunc;
					break;
			}
		} else if (cr > 0) {
			self._value = trunc;
		} else {
			self._value = trunc.add(self._factorInt(self.max_scale - s, signum));
		}
	},
	// === old parse method ===
	parse: function(value, ts, ds) {
		ts = (ts === ".") ? "[.]" : ts;
		ds = (ds === ".") ? "[.]" : ds;
		value = value.toString();
		return new BigDecimal(value.replace(new RegExp(ts || " ", "g"), "").replace(new RegExp(ds || "[.]", "g"), "."));
	},
	clone: function() {
		var self = this;
		return new BigDecimal(0, self._scale, self._value);
	},
	abs: function() {
		var self = this;
		return new BigDecimal(0, self._scale, self._value.abs());
	},
	add: function(augend) {
		var self = this;
		return new BigDecimal(0, self._scale, self._value.add(augend._value));
	},
	compareTo: function(val) {
		var self = this;
		return self._value.compareTo(val._value);
	},
	divide: function(divisor, scale, roundingMode) {
		var self = this;
		var res = new BigDecimal(0, self._scale, self._value.multiply(self._factorInt()).divide(divisor._value));
		if (scale != null) res._scale = scale;
		res._roundToScale(res._scale, roundingMode);
		return res;
	},
	multiply: function(multiplicand, scale, roundingMode) {
		var self = this;
		var res = new BigDecimal(0, self._scale, self._value.multiply(multiplicand._value).divide(self._factorInt()));
		if (scale != null) res._scale = scale;
		res._roundToScale(res._scale, roundingMode);
		return res;
	},
	negate: function() {
		var self = this;
		var res = new BigDecimal(0, self._scale, self._value.negate());
		return res;
	},
	scale: function() {
		var self = this;
		return self._scale;
	},
	setScale: function(newScale, roundingMode) {
		var self = this;
		var res = self.clone();
		if (newScale != null) res._scale = newScale;
		res._roundToScale(res._scale, roundingMode);
		return res;
	},
	signum: function() {
		var self = this;
		return self._value.signum();
	},
	subtract: function(subtrahend) {
		var self = this;
		var res = new BigDecimal(0, self._scale, self._value.subtract(subtrahend._value));
		return res;
	},
	numberValue: function() {
		var self = this;
		return parseFloat(self.toString());
	},
	// === old format method ===
	// size --> group size
	// afterwards, instead of size, we should have a set of properties and/or constraints
	toString: function(gs, ds, size) {
		var self = this;
		var a = [];
		var res = self._value.toString();
		if ((res[0] == "-") || (res[0] == "+")) {
			a.push(res[0]);
			res = res.substr(1);
		}
		var len = res.length;
		var separated = res.substr(0, len - self.max_scale);

		// add group separator if defined
		separated = gs ? _addSeparator(separated, gs, size || 3) : separated;

		a.push(separated || "0");
		if (self._scale > 0) {
			a.push(ds || ".");
			a.push((self._zero(self.max_scale - len) + res).substr(Math.max(len - self.max_scale, 0), self._scale));
		}
		return a.join("");
	}
});

function _addSeparator(num, gs, size) {
	var result = "";
	var len = num.length;
	var c = "";
	var count = 0;
	for (var i = len - 1; i >= 0; i--) {
		c = num[i];
		result += c;
		++count;
		if ((count % size === 0) && i > 0) {
			result += gs;
		}
	}
	return result.split("").reverse().join("");
}

exports.make = _make;
exports.parseOld = BigDecimal.prototype.parse;
exports.ZERO = function() {
	return _make(0);
};
exports.ONE = function() {
	return _make(1);
};
exports.TEN = function() {
	return _make(10);
};

exports.format = function(val, format) {
	if (val == null) {
		return "";
	}
	if (typeof val == "object") {
		val = val.toString();
	}
	return numberFormat.format(val, format);
};

exports.parse = function(str, format) {
	return new BigDecimal(numberFormat.parse(str, format));
};

exports.add = function(n1, n2) {
	return n1.add(n2);
};

exports.subtract = function(n1, n2) {
	return n1.subtract(n2);
};

exports.numberValue = function(val) {
	return val.numberValue();
};

exports.defaultValue = 0;
