"use strict";
var path = require('path'),
	config = require('config'),
	ez = require("ez-streams"),
	file = ez.devices.file,
	fs = require("streamline-fs"),
	patchGenerator = require('scm/lib/patchGenerator');

/// !doc
/// # Patch generator unit tests
/// The goal of this unitTest is to build patch files from some reference json files 
/// These json files are located in resources/refJsonFiles
/// Each generated patch file will then be compared to a ref patch file stored in resources/refPatchFiles

var doStop = false;
QUnit.module(module.id, {
	setup: function() {},
	teardown: function() {
		if (doStop) {
			setTimeout(function() {
				process.kill(process.pid);
			}, 100);
		}
	}
});


var unitTests = [];


if (!config.scm) {
	return test('PATCH GENERATOR UNIT TESTS DISABLED FOR NOW', 1, function() {
		ok(true, "work in progress");
	});
}


config.scm.unitTests = config.scm.unitTests || {};
config.scm.unitTests.refPatchFolder = config.scm.unitTests.refPatchFolder || (__dirname + "/resources/refPatchFiles");
config.scm.unitTests.refJsonFolder = config.scm.unitTests.refJsonFolder || (__dirname + "/resources/refJSonFiles");


function registerTest(jsonFile, refPatchFile) {
	unitTests.push({
		json: path.join(config.scm.unitTests.refJsonFolder, jsonFile),
		refPatch: path.join(config.scm.unitTests.refPatchFolder, refPatchFile),
	});
}

registerTest("CONTENTTYPES/ATYPE0.json", "ATYP_ATYPE0.dat");

registerTest("ACTIVITYCODES/ABI.json", "ACV_ABI.dat");

// tables
registerTest("TABLES/ABANK.json", "ATB_ABANK.dat");

registerTest("CLASSES/TCAWRKHISSUI.json", "ACLA_TCAWRKHISSUI.dat");
registerTest("CLASSES/ACTXPARAM.json", "ACLA_ACTXPARAM.dat");
registerTest("WINDOWS/OACLA.json", "AWI_OACLA.dat");
registerTest("CONTEXTS/AFOLDER.json", "ACTX_AFOLDER.dat");
registerTest("CONTEXTS/AHISTO.json", "ACTX_AHISTO.dat");
registerTest("FUNCTIONS/ABATPAR.json", "AFC_ABATPAR.dat");
registerTest("GLOBVARS/G300CPFI.json", "AGB_G300CPFI.dat");
registerTest("INQUIRIES/AJE.json", "ACN_AJE.dat");
registerTest("OBJECTS/AAA.json", "AOB_AAA.dat");
registerTest("PARAMETERS/AASAUTNUM.json", "ADP_AASAUTNUM.dat");
registerTest("PROCESSES/1099MISC.json", "ADC_1099MISC.dat");
registerTest("REPORTS/ABLOB.json", "ARP_ABLOB.dat");
registerTest("REPORTS/ACODIF.json", "ARP_ACODIF.dat");

// Representations
registerTest("REPRESENTATIONS/ABANK.json", "ASW_ABANK.dat");

// Representations
registerTest("REPRESENTATIONS/SQUOTE.json", "ASW_SQUOTE.dat");

// Representations : validate ASHWMENU sub table + validate ASHWLNK with empty CODLNK
registerTest("REPRESENTATIONS/CONTACTCRM.json", "ASW_CONTACTCRM.dat");

// Representations : validate ASHWMET sub table
registerTest("REPRESENTATIONS/PPRICSEARCHM.json", "ASW_PPRICSEARCHM.dat");

// Representations : validate ASHWOPT sub table
registerTest("REPRESENTATIONS/SPRICCONF.json", "ASW_SPRICCONF.dat");

// Screens
registerTest("SCREENS/AAB1.json", "AMK_AAB1.dat");

// Screens : validate AMSKPAR sub table
registerTest("SCREENS/PTH1.json", "AMK_PTH1.dat");

registerTest("VIEWS/ADICADX.json", "AVW_ADICADX.dat");

registerTest("MISCTABLES/6.json", "ADV_6.dat");

registerTest("ACTIONS/ABIIMP.json", "ACT_ABIIMP.dat");


function comparePatchFiles(_, config, patchGenerator, patchFile, refPatchFile) {
	function _parseFile(_, filename, checkOrder) {
		var lastTypeIndex = -1;
		var lastType = "not set";
		var parts = {};
		var s = fs.stat(filename, _);
		var reader = file.text.reader(filename, "utf8").transform(ez.transforms.lines.parser());
		var currentBlockId;
		var currentBlockIdPrefix;
		var line;
		var lineCount = 0;
		var orderedTypes = patchGenerator.getOrderedTypes();
		while ((line = reader.read(_)) != undefined) {
			lineCount++;
			switch (line.charAt(0)) {
				case "1":
					// Sth like 1,"test","ENG/FRA","1","","X3","1",
					// Start of a 1..8 block
					parts["HEADER"] = line;
					break;
				case "2":
					// Try to parse sth like 2,"ACLA","TCAWRKHISSUI","Workflow tracking archive"
					var result = /^2,\"(\w+)\",\"(\w+)\",\"(.+)\"/.exec(line);
					if (result) {
						// Start of a 2..7 block
						var type = result[1];
						if (checkOrder) {
							var typeIndex = orderedTypes.indexOf(type);
							if (typeIndex == -1)
								throw new Error("Unhandled type : " + type);
							if (typeIndex < lastTypeIndex)
								throw new Error("The types are not sorted in the right order : " + lastType + " should be declared before " + type + ", file = " + filename);
							lastType = type;
							lastTypeIndex = typeIndex;
						}
						currentBlockIdPrefix = type + "." + result[2];
						parts[currentBlockIdPrefix + ".ITEM_HEADER"] = line;
					}
					break;
				case "3":
					// Try to parse sth like 3,"ACLAF","ABROBJ"
					var result = /^3,\"(\w+)\",\"?([^\"]+)\"?/.exec(line);
					if (result) {
						// Start of a 3..6 block
						currentBlockId = currentBlockIdPrefix + "." + result[1] + ":" + result[2];
						parts[currentBlockId] = "";
					}
					break;
				case "6":
					// Try to parse sth like 6,"ACLA"
					// End of 3..6 block
					currentBlockId = null;
					break;
				case "7":
					// Try to parse sth like 7,"ACLA","TCAWRKHISSUI","Workflow tracking archive"
					// End of 2..7 block
					currentBlockIdPrefix = null;
					break;
				case "8":
					// End of 1..8 block
					// Nothing special to be done. should be the end of the file
					break;
				default:
					if (parts[currentBlockId].length)
						parts[currentBlockId] += "\n";
					parts[currentBlockId] += line;
			}

		}
		return parts;
	}

	function _compareParts(filename1, parts1, filename2, parts2) {
		Object.keys(parts1).forEach(function(key) {
			var part1 = parts1[key];
			var part2 = parts2[key];
			if (!part2) {
				throw new Error("Could not find key " + key + " in file " + filename2);
			}
			var lines1 = part1.split("\n");
			var lines2 = part2.split("\n");
			var same = lines1.length == lines2.length;
			same = same && !lines1.some(function(line1) {
				var idx2 = lines2.indexOf(line1);
				if (idx2 == -1) {
					config.trace && config.trace("Could not find string '" + line1 + "' from file " + filename2);
					return true;
				}
				return false;
			});

			if (!same) {
				config.trace && config.trace("------------- " + filename1);
				config.trace && config.trace(part1);
				config.trace && config.trace("------------- " + filename2);
				config.trace && config.trace(part2);
				config.trace && config.trace("-------------");
				throw new Error("Content mismatch : " + key);
			}
		});

	}
	var parts1 = _parseFile(_, patchFile, true);
	var parts2 = _parseFile(_, refPatchFile, true);
	_compareParts(patchFile, parts1, refPatchFile, parts2);
	_compareParts(refPatchFile, parts2, patchFile, parts1);
}

asyncTest('Generation of single patches, one patch file per JSON file', 2 * unitTests.length, function(_) {
	var pg = patchGenerator.newGenerator(_, config.scm);

	unitTests.forEach_(_, function(_, unitTest) {
		var patchFile;
		try {
			patchFile = pg.generatePatches(_, [unitTest.json])[0];
			ok(true, "Generation of patch from JSON file : " + unitTest.json + ", result = " + patchFile);
		} catch (err) {
			ok(false, "Generation of patch from JSON file : " + unitTest.json + ", reason = " + err.message);
			throw err;
		}

		// Temp hack ... should be removed ASAP
		// for now, the writer returns when a writer.write(_) is done but the stream is not 
		// flushed yet, so the file can't be read immediately
		setTimeout(~_, 200);

		try {
			comparePatchFiles(_, config, pg, patchFile, unitTest.refPatch);
			ok(true, "Compare with reference patch file : " + unitTest.refPatch);
		} catch (err) {
			ok(false, "Compare with reference patch file : " + unitTest.refPatch + ", reason = " + err.message);

		}

	});

	start();
});

asyncTest('Generation of unique patch file, one patch file for many JSON file', 2, function(_) {
	var pg = patchGenerator.newGenerator(_, config.scm);

	var files = unitTests.map(function(unitTest) {
		return unitTest.json;
	});

	var patchFile;
	try {
		patchFile = pg.generatePatches(_, files)[0];
		ok(true, "Generation of unique patch from many JSON files, result = " + patchFile);
	} catch (err) {
		ok(false, "Generation of unique patch from many JSON file, reason = " + err.message);
		throw err;
	}

	// Temp hack ... should be removed ASAP
	// for now, the writer returns when a writer.write(_) is done but the stream is not 
	// flushed yet, so the file can't be read immediately
	setTimeout(~_, 1000);

	var refPatchFile = path.join(config.scm.unitTests.refPatchFolder, "FULL.dat");
	try {
		comparePatchFiles(_, config, pg, patchFile, refPatchFile);
		ok(true, "Compare with reference patch file : " + refPatchFile);
	} catch (err) {
		ok(false, "Compare with reference patch file : " + refPatchFile + ", reason = " + err.message);
		throw err;
	}

	start();
});

asyncTest("Stop", function(_) {
	doStop = true;
	start();
});
