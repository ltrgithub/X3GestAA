"use strict";
var supervisor = require("etna-supervisor/lib/supervisor");
var nodeLocalConfig = require('config');
var gitWrapper = require('etna-etl/lib/gitWrapper');
var path = require("path");
var ez = require("ez-streams");
var file = ez.devices.file;
var fs = require("streamline-fs");


exports.newGenerator = function(_, config) {

	config.patch = config.patch || {};
	config.patch.langs = config.patch.langs || ["ENG", "FRA"]
	config.patch.comment = config.patch.comment || "test";
	config.patch.version = config.patch.version || 1;
	config.patch.product = config.patch.product || "X3";

	var superv = supervisor.create(_, config);
	var settingsTable = "AAA";

	try {
		// Make sure the settings table exists
		superv.sqlDriver.getTableDef(_, superv.folderName, settingsTable);
	} catch (err) {
		console.log("ERROR : " + err);
		var tableDef = {
			schemaName: superv.folderName,
			tableName: settingsTable,
			columns: [{
				name: "GITSHA1",
				isNullable: true,
				type: "nvarchar",
				maxLength: 40
			}],
			indexes: [],
		};
		superv.sqlDriver.createTableFromTableDefinition(_, tableDef);
		config.trace && config.trace("Settings table '" + settingsTable + "' was created.")
	}

	function getGitWrapper() {
		var options = {
			folder: config.gitFolder
		};
		return new gitWrapper.git(options);
	}

	function processElement(_, writer, elt, type, pk) {
		writer.write(_, "3,\"" + type + "\",\"" + elt[pk] + "\"\n");

		var allLines = {};

		function writeItem(_, lineType, name, dimension, values) {
			var line = lineType + ',"' + name + '",' + dimension;
			if (!Array.isArray(values))
				values = [values];
			values.forEach(function(value) {
				if (" " === value)
					value = "";
				line += ',';
				if (typeof(value) == "string")
					line += '"' + value + '"';
				else
					line += value;
			});

			allLines[name] = allLines[name] || [];
			allLines[name].push(line);
			//			console.log(line);
			//writer.write(_, line + "\n");
		}

		if (elt["##texts##"]) {
			var texts = elt["##texts##"];
			Object.keys(texts).forEach_(_, function(_, columnName) {
				// each item concerns a specific column
				var setLangCodes = [];
				Object.keys(texts[columnName]).forEach_(_, function(_, langCode) {
					setLangCodes.push(langCode);
					if (config.patch.langs.indexOf(langCode) == -1)
						return;
					var valsToWrite = [
						texts[columnName][langCode],
						langCode,
						elt[columnName],
					];
					if (elt["##comments##"] && elt["##comments##"][columnName] && elt["##comments##"][columnName][langCode])
						valsToWrite.push(elt["##comments##"][columnName][langCode]);
					else
						valsToWrite.push("");
					writeItem(_, 5, columnName, 0, valsToWrite)
				});
				config.patch.langs.forEach_(_, function(_, langCode) {
					if (setLangCodes.indexOf(langCode) == -1) {
						// No localized text was found for this lang.
						writeItem(_, 5, columnName, 0, ["", langCode, elt[columnName], ""]);
					}

				});
				writeItem(_, 5, columnName, 0, ["", "***"]);
				delete(elt[columnName]);
			});
			// val.forEach_(_, function(_, arrayItem, itemIdx) {
			// 	writeItem(_, 5, key, itemIdx, arrayItem);
			// });
			delete(elt["##texts##"]);
			delete(elt["##comments##"]);
		}

		function padDatePart(part, length) {
			// convert any int value into string
			part = "" + part;
			while (part.length < length)
				part = "0" + part;
			return part;
		}

		Object.keys(elt).forEach_(_, function(_, key) {
			var val = elt[key];
			if (Array.isArray(val)) {
				val.forEach_(_, function(_, arrayItem, itemIdx) {
					writeItem(_, 4, key, itemIdx, arrayItem);
				});
			} else {
				if (["LONG", "NUMFLD"].indexOf(key) != -1) //STDEN
					val = parseFloat(val);
				else if ("string" === typeof(val)) {
					var result = /(\d+)-(\d+)-(\d+)T(\d+):(\d+):(\d+).(\d+)Z/.exec(val);
					if (result) {
						// This is date time : just remove the millis
						val = result[1] + "-" + result[2] + "-" + result[3] + "T" + result[4] + ":" + result[5] + ":" + result[6] + "Z";
					} else {
						result = /(\d+)-(\d+)-(\d+)/.exec(val);
						if (result) {
							// This is a date
							val = parseInt(result[1] + result[2] + result[3]);
						}
					}
				}
				writeItem(_, 4, key, 0, val);
			}
		});

		Object.keys(allLines).sort().forEach_(_, function(_, lines) {
			allLines[lines].forEach_(_, function(_, line) {
				writer.write(_, line + "\n");
			});
		});
		writer.write(_, "6,\"" + type + "\"\n");
	}

	function processATableElement(_, writer, entityExportConfig, elt) {
		var firstText = elt["##texts##"][entityExportConfig.textLinks[0]]["ENG"];
		var header = '"' + entityExportConfig.abbrev + '","' + elt[entityExportConfig.primaryKey] + '","' + firstText + '"';
		writer.write(_, "2," + header + "\n");
		var children = [];
		if (entityExportConfig.children) {
			// The configuration describes some child-node, we have to keep them in a separate list.
			// They will be processed later.
			Object.keys(entityExportConfig.children).forEach(function(childName) {
				// For instance, in tables.js, childName == 'COLUMNS' or 'INDEXES'
				if (elt[childName]) {
					// note : elt[childName] is an array. Each item describes a child (i.e. one index or one column)
					elt[childName].forEach(function(c) {
						children.push({
							name: childName,
							node: c
						});
					});
					// We have to delete the child, otherwise it would be exposed as a value in the .dat file
					delete(elt[childName]);
				}
			});
		}
		processElement(_, writer, elt, entityExportConfig.abbrev, entityExportConfig.primaryKey);

		// Now, we can process the children
		children.forEach_(_, function(_, child) {
			var patchPK = entityExportConfig.children[child.name].patchPK;
			if (!patchPK)
			{
				// Build the patchPK from the orderBy property
				patchPK, entityExportConfig.children[child.name].orderBy.split(',')[0];
			}
			processElement(_, writer, child.node, entityExportConfig.children[child.name].abbrev, entityExportConfig.children[child.name].patchPK || entityExportConfig.children[child.name].orderBy);

		});

		writer.write(_, "7," + header + "\n");
	}

	function _generatePatch(_, filesList, options) {

		function openWriter(_, shortFilename) {
			var patchFilename = config.patchFolder + "/" + shortFilename + ".dat";
			filenames.push(patchFilename);
			var writer = file.text.writer(patchFilename, "utf8");
			console.log("Generate patch file: " + patchFilename);
			writer.write(_, '1,"' + config.patch.comment + '","' + config.patch.langs.join("/") + '","' + config.patch.version + '","","' + config.patch.product + '","1",\n');
			return writer;
		}

		function closeWriter(_, writer) {
			writer.write(_, '8,"' + config.patch.comment + '"\n');
			writer.write(_);
		}

		var filenames = [];

		var writer;

		if (options.oneFile) {
			writer = openWriter(_, "patch");
		}

		var normalizedMetaFolder = path.normalize(config.metaFolder + "/").toLowerCase();
		// console.log(normalizedMetaFolder);

		var done = false;
		filesList.forEach_(_, function(_, filename) {
			if (done)
				return;
			console.log("Processing file " + filename);
			done = true;
			var normalizedFilePath = path.normalize(config.gitFolder + "/" + filename).toLowerCase();
			if (!normalizedFilePath.substr(0, normalizedMetaFolder.length) == normalizedMetaFolder) {
				// This file is not a metadata file
				return;
			}
			var relativeFilePath = normalizedFilePath.substr(normalizedMetaFolder.length);
			//var parts = normalizedFilePath.slice('')
			var parts = relativeFilePath.split(path.sep);
			// parts[0] = module name (superv, common, sales, stocks, ...)
			// parts[1] = metadata type (datatype, entity, table, classe, ...)
			// parts[2] = entity type (atable, atype, ...)

			var elt = JSON.parse(fs.readFile(normalizedFilePath, 'utf8', _));
			if (!options.oneFile) {
				writer = openWriter(_, parts[1] + "_" + parts[2]);
			}
			if ((parts[1] == 'tables') || (parts[1] == 'classes')) {
				var entityExportConfig = require("etna-etl/lib/entities/" + parts[1]).entity;
				console.log(normalizedFilePath);
				processATableElement(_, writer, entityExportConfig, elt);
			}
			if (!options.oneFile) {
				closeWriter(_, writer);
			}
		});
		if (options.oneFile) {
			closeWriter(_, writer);
			if (options.x3PatchToCompare)
				comparePatchFiles(_, filenames[0], options.x3PatchToCompare);
		}

		return filenames;
	}

	function comparePatchFiles(_, filename1, filename2) {
		function parseFile(_, filename) {
			var parts = {};
			var reader = ez.devices.file.text.reader(filename, "utf8").transform(ez.transforms.lines.parser());
			var currentBlockId;
			while (true) {
				var line = reader.read(_);
				if (!line)
					break;
				var result = /^1,\"(.*)\",\"([\w,\/]*)\",\"(\w*)\",\"(\w*)\",\"(\w*)\",\"(\w*)\"/.exec(line);
				if (result) {
					// Main header
					parts["HEADER"] = line;
					continue;
				}
				result = /^2,\"(\w+)\",\"(\w+)\",\"(.+)\"/.exec(line);
				if (result) {
					// Item header
					//parts["ITEM_HEADER"] = line;
					continue;
				}
				result = /^3,\"(\w+)\",\"?([^\"]+)\"?/.exec(line);
				if (result) {
					// Start of a 3..6 block
					currentBlockId = result[1] + ":" + result[2];
					parts[currentBlockId] = "";
					continue;
				}
				result = /^6,\"(\w+)\"/.exec(line);
				if (result) {
					// End of 3..6 block
					currentBlockId = null;
					continue;
				}
				if (!currentBlockId)
					console.log("**************** " +  line);
				parts[currentBlockId] += line;
			}
			return parts;
		}

		function compareParts(parts1, parts2)
		{
			Object.keys(parts1).forEach(function(key){
				var part1 = parts1[key];
				var part2 = parts2[key];
				if (!part2)
					throw new Error("Could not find key " + key);
				if (part1 !== part2)
				{
					console.log("-------------");
					console.log(part1);
					console.log("-------------");
					console.log(part2);
					console.log("-------------");
					throw new Error("Content mismatch : " + key);
				}
			});

		}

		console.log(">>>>>>>>>>>>>>>>> " + filename1);
		var parts1 = parseFile(_, filename1);
		var parts2 = parseFile(_, filename2);
		compareParts(parts1, parts2);
		compareParts(parts2, parts1);
	}

	return {

		/// Returns the sha1 that was last synchronized
		getLastSyncdHead: function(_) {
			var head;
			try {
				superv.sqlDriver.withConnection(_, function(_, cnx) {
					var row = superv.sqlDriver.reader(_, cnx, "select GITSHA1 from " + settingsTable).toArray(_)[0];
					if (!row) {
						config.trace && config.trace("First sync : full sync");
						return null;
					}
					head = row.GITSHA1;
				});
			} catch (err) {
				console.log("ERROR : " + err.message);
			}
			config.trace && config.trace("Incremental sync from sha1 : " + head);
			return head;
		},

		/// Stores the sha1 that was last synchronized
		setLastSyncdHead: function(_, sha1) {
			try {
				superv.sqlDriver.withConnection(_, function(_, cnx) {
					superv.sqlDriver.execute(_, cnx, "delete from " + settingsTable);
					superv.sqlDriver.execute(_, cnx, "insert into " + settingsTable + " (GITSHA1) values (" + superv.sqlDriver.param(0) + ")", [sha1]);
				});
			} catch (err) {
				console.log("ERROR : " + err.message);
			}
			config.trace && config.trace("HEAD '" + sha1 + "' written");
		},

		listModifiedFiles: function(_, fromSha1, toSha1) {
			var allText = '';
			var result = getGitWrapper().diffStat(_, fromSha1, toSha1);
			//var result = getGitWrapper().getLog(_);
			return result.diffs.map(function(diff) {
				switch (diff.touch) {

					case 'A': // Add
					case 'M': // Modified
						return diff.filename;
					case 'D': // Deleted
						// STDEN : ignored for now
						return;
					default:
						// STDEN : ignored for now
						return;
				}
			});
		},

		generatePatch: function(_, filesList, options) {
			return _generatePatch(_, filesList, options);
		}
	}
};
