"use strict";

var config = require("../../../nodelocal").config || {};
var path = require('path');
var fs = require('streamline-fs');
var httpClient = require("syracuse-httpclient/lib/httpClient");
var markdown = require('markdown').markdown;
var spdxLicenses = require('spdx-license-list/spdx-full');
var utils = require('./utils');
var colors = require('colors/safe');
console.log(colors.green("!!! Please wait for build of copyright html file..."));
var sys = require('util');
var write = process.stdout.write.bind(process.stdout);
process.stdout.write = function () {};
process.stderr.write = function () {};

var licensesToCheck = ["MIT", "BSD-2-Clause", "BSD-3-Clause", "Apache-2.0", "ISC"];
var packages = {};
var deps = {};
var missLic = {};
var missCopy = {};
var hardCoded = JSON.parse(fs.readFile(path.join(__dirname, "manual-licenses-list.json"), "utf8", _));
var count = 0;
var twins = 0;


var trace;// = function(txt) {write(txt);};

var config = config.copyright;
var proxyConf = config.proxy;
if (proxyConf.auth && proxyConf.auth.toLowerCase() === "ntlm") {
	proxyConf.proxyAuthenticator = require('syracuse-httpclient/lib/proxyAuthenticator');
}

var authorsIgnoreList = JSON.parse(fs.readFile(path.join(__dirname, "authors-ignore-list.json"), "utf8", _));

write("Config: "+JSON.stringify(config,null,2));

var stdOpt = {
	method: "GET",
	headers: {
		"user-agent": "Syracuse-Copyrights-Helper",
		Authorization: "token " + config.token
	},
	proxy: proxyConf
};

function browsePackages(_, root, path, fileName, depth) {


	var files = fs.readdir(root + path, _);
	files.forEach_(_, function(_, file) {
		var fpath = path + "/" + file;
		var stats = fs.lstat(root + fpath, _);
		if (stats.isDirectory() && !/test$/.test(file)) {
			//write("\n"+depth + "- dir: " + file);
			browsePackages(_, root, fpath, fileName, depth + 1);
		} else if (stats.isFile() && file === fileName) {
			count++;
			//write("\nModule found: " +  path.substring(1));
			var pack = require(root + path + "/" + file);
			var author = typeof pack.author === "object" ? pack.author.name : pack.author;
			if (hardCoded[pack.name] || (!packages[pack.name] && !missLic[pack.name] && !missCopy[pack.name]) && (!author || (author && authorsIgnoreList.indexOf(author) === -1))) {
				write("-> Inspect " + pack.name + " ("+pack.version+") --> "+ path + "\t");
				

				if (hardCoded[pack.name]) {
					pack.licenses = [];
					pack.licenses.push(hardCoded[pack.name]);
				} else {
					if (pack.license) {
						pack.licenses = pack.licenses || [];
						pack.licenses.push({
							type: typeof pack.license === "object" ? (pack.license.name || pack.license.type) : pack.license
						});
					}
				}
				var repoLic = requestRepositoryLicenseInformation(_, pack.name, pack.repository, path, pack.licenses && pack.licenses[0]);
				if (!repoLic) write(colors.red("\n\tError while inspect repository for "+pack.name + " ("+pack.version+") --> "+ path));
				pack.licenses = [repoLic];
				
			

				if (!pack.licenses[0].type || pack.licenses[0].type.length === 0) {
					write(colors.red("Type not found !\n"));
					missLic[pack.name] = pack.licenses;
				} else {
					packages[pack.name] = pack;
				}
				
				if (!pack.licenses[0].copyright || pack.licenses[0].copyright.length === 0) {
					write(colors.yellow("Copyright not found !\n"));
					missCopy[pack.name] = pack.licenses;
				}
				
				if (pack.licenses[0].type && pack.licenses[0].type.length > 0 && pack.licenses[0].copyright && pack.licenses[0].copyright.length > 0) {
					write(colors.green("OK\n"));
					
				} else {
					write("\n");
				}
				trace && trace("* Result: "+sys.inspect(repoLic)+"\n");
			} else if (!packages[pack.name] && !missLic[pack.name]){
				count--;
				write(colors.grey("# Ignore package "+ pack.name + "\n"));
			} else {
				twins++;
				count--;
			}
		}
	});
}


function extractSlugUrl(url, path, spliceId) {
	url = url.replace("github.com:", "github.com/");
    var gitRegex = 'github.com/([^/]+/.*)?(.git$)';
    var urlRegex = 'github.com/([^/]+/.*)?';

    var gitMatch = url.match(gitRegex);
    var urlMatch = url.match(urlRegex);

    var slug = (gitMatch || url.match(urlRegex));
    if (!slug) {
		return;
    }
    slug = slug[1];
    if (spliceId != null) slug = slug.split('/').splice(0, spliceId).join('/');
    return slug;
}

function handleRedirect(_, body, opt, res, cb) {
	var redir = JSON.parse(body);
	opt.url = redir.url;
    
	var requestRedirect = httpClient.httpRequest(_, opt);
	var responseRedirect = requestRedirect.end().response(_);
	var bodyRedirect = responseRedirect.readAll(_);
	if (responseRedirect.statusCode === 200) {
		cb(_, bodyRedirect);
	} else if (responseRedirect.statusCode === 301) {
		handleRedirect(_, bodyRedirect, opt, res, cb);
	} else {
		res.$diagnoses = utils.addDiagnose(res.$diagnoses, "error", "An error occured while getting contents (from redirection) on github repository ("+responseRedirect.statusCode+") - url: "+opt.url);
	}
}

var requestRepositoryLicenseInformation = function (_, name, repository, path, res) {
	
	function inspectLicenseFile(url, _body, checkType) {
		trace && trace("Inspect license content\n");
		// extract copyright
		res.copyright = res.copyright || [];
		var cr = utils.extractCopyright(_body);
		if (cr) {
			cr.forEach(function(c) {
				if (res.copyright.indexOf(c) === -1) res.copyright.push(c);
			});
		}
		
		// extract license type
		if (checkType) {
			res.type = res.type || [];
			var lic = matchLicense(_body);
			if (lic && res.type.indexOf(lic) === -1) res.type.push(lic);
			if (url) res.url = url;
		}
	}
	
	function inspectReadmeFile(file, cnt, checkType) {
		trace && trace("Inspect readme content\n");
		var lic;
		if (/\.(md|markdown)$/i.test(file)) {
			// extract license type from markdown
			var mdParseRes = parseMarkdownLicense(cnt, checkType);
			lic = res.type || mdParseRes.type;
			if (mdParseRes.copyright) {
				res.copyright = res.copyright || [];
				mdParseRes.copyright.forEach(function(c) {
					if (res.copyright.indexOf(c) === -1) res.copyright.push(c);
				});
			}
		} else if (/licen[cs]e/i.test(cnt)) {
			// extract copyright
			res.copyright = res.copyright || [];
			var cr = utils.extractCopyright(cnt);
			if (cr) {
				cr.forEach(function(c) {
					if (res.copyright.indexOf(c) === -1) res.copyright.push(c);
				});
			}
			
	    	// extract license type
			if (checkType) {
				lic = res.type || matchLicense(cnt);
			}
	    }
		res.type = res.type || [];
		if (lic) {
			lic.forEach(function(l) {
				if (res.type.indexOf(l) === -1) res.type.push(l);
			});
		}
	}
	
	function readLicenseFile(_, url, checkType) {
		opt.url = url;
		trace && trace("Get raw licence file: "+opt.url+"\n");
		var _request = httpClient.httpRequest(_, opt);
		var _resp = _request.end().response(_);
		var _body = _resp.readAll(_);
		trace && trace("Status: "+_resp.statusCode+"\n");
		if (_resp.statusCode === 200) {
			inspectLicenseFile(url, _body, checkType);
		} else {
			res.$diagnoses = utils.addDiagnose(res.$diagnoses, "warning", "An error occured while getting LICENSE file on github repository ("+_resp.statusCode+")");
		}
	}
	
	function readReadmeFile(_, url, checkType) {
		opt.url = url;
		trace && trace("Get raw readme file: "+opt.url+"\n");
		var _request = httpClient.httpRequest(_, opt);
		var _resp = _request.end().response(_);
		var _body = _resp.readAll(_);
		trace && trace("Status: "+_resp.statusCode+"\n");
		if (_resp.statusCode === 200) {
			inspectReadmeFile(url, _body, checkType);
		} else {
			res.$diagnoses = utils.addDiagnose(res.$diagnoses, "warning", "An error occured while getting README file on github repository ("+_resp.statusCode+")");
		}
	}
	
	function analyseGithubContents(_, _body) {
		var contents = JSON.parse(_body);
		//write("\ncontents: "+JSON.stringify(contents,null,2));
		var lic = contents.filter(function (content) {
	        return content.name.match(/licen[cs]e/i);
	    });
		
		if (lic.length !== 0) {
			lic.forEach_(_, function(_, l) {
				readLicenseFile(_, l.download_url, mustCheckType);
			});
		} else {
			res.$diagnoses = utils.addDiagnose(res.$diagnoses, "error", "No LICENSE file github repository");
		}
		
		if (lic.length === 0 || !res.type || !res.copyright) {
			var rm = contents.filter(function (content) {
		        return content.name.match(/^readme/i);
		    });
			if (rm.length !== 0) {
				readReadmeFile(_, rm[0].download_url, mustCheckType);
				if (res.type) delete res.$diagnoses;
			} else {
				res.$diagnoses = utils.addDiagnose(res.$diagnoses, "error", "No README file github repository");
			}
		}
	}
	
	function fetchGithubContent(_, url) {
		var slug = extractSlugUrl(url, path);
	    var username = slug.split('/')[0];
	    var project = slug.split('/')[1];
	
		
		opt.url = 'https://api.github.com/repos/' + username + "/" + project + '/contents';
		trace && trace("\n=> fetch github content:" + project+"\n\tgithub url: "+url+"\n\tslug url: "+opt.url);
	    
		var request = httpClient.httpRequest(_, opt);
		var response = request.end().response(_);
		var body = response.readAll(_);
		if (response.statusCode === 200) {
			analyseGithubContents(_, body);
		
	
		} else if (response.statusCode === 301) {
			handleRedirect(_, body, opt, res, analyseGithubContents);
			
		} else {
			res.$diagnoses = utils.addDiagnose(res.$diagnoses, "error", "An error occured while getting contents on github repository ("+response.statusCode+") - url: "+opt.url);
		}
	}
	
	
	//
	//
	repository = repository || {};
	res = res || {};
	//write("RES: "+JSON.stringify(res,null,2));
	if (res.type && !Array.isArray(res.type)) res.type = [res.type];

	
	
	
	//write("Res:"+JSON.stringify(res,null,2)+"\n");
	var mustCheckType = !res.type || res.type.length === 0;
	res.path = path;
	
	// Inspect file system to find LICENSE and README files
	var files = fs.readdir(rootDir + path, _);
	var filesLic = [], fileReadme;
	files.forEach_(_, function(_, file) {
		var fpath = path + "/" + file;
		var stats = fs.lstat(rootDir + fpath, _);
		if (stats.isFile()) {
			if (file.match(/licen[cs]e/i)) {
				filesLic.push(file);
			} else if (file.match(/^readme/i)) {
				fileReadme = file;
			}
		}
	});
	
	if (filesLic.length !== 0) {
		filesLic.forEach_(_, function(_, f) {
			inspectLicenseFile(null, fs.readFile(rootDir + path + "/" + f, 'utf8', _), mustCheckType);
		});
	} else if (fileReadme && (!res.type || !res.copyright)) {
		var readmeCnt = fs.readFile(rootDir + path + "/" + fileReadme, 'utf8', _);
		inspectReadmeFile(fileReadme, readmeCnt, mustCheckType);
	}
	
	
	// Inspect github repository if license type and copyright not identified
	if ((!res.type || res.type.length === 0 || !res.copyright || res.copyright.length === 0)) {
		var opt = stdOpt;
		var slug;
		if (res.url && !repository.url) {
			slug = extractSlugUrl(res.url, path, 2);
			if (!slug) {
				if (!res.type || res.type.length === 0) write(colors.magenta("Repository url problem\n"));
				return res;
			}
			repository.url = "https://github.com/" + slug;
		}
		if (repository.url) {
			fetchGithubContent(_, repository.url)
		} else {
			trace && trace(colors.magenta("No url found to access github repository\n"));
		}
	}
	
   // write("\nRes: "+JSON.stringify(res,null,2));
	return res;
};

// Match a license body or license id against known set of licenses.
function matchLicense(licenseString) {
    // Find all textual matches on license text.
    var normalized = utils.normalizeText(licenseString);
    var matchingLicenses = [];
    //write("\nnormalized : "+normalized);
    // Check matches of normalized license content against signatures.
    var found = false, bestMatch, bestScore = 0;
    for (var i = 0; i < licenses.length; i++) {
        var license = licenses[i];
        var match = false;
        for (var j = 0; j < license.signatures.length; j++) {
            if (normalized.indexOf(license.signatures[j]) >= 0) {
                match = true;
                break;
            }

        }
        if (!match) {
	        for (var k = 0; k < license.signatures.length; k++) {
	        	var percentMatch = utils.similarity(normalized, license.signatures[k]);
	        	if (percentMatch > bestScore) {
	        		bestScore = percentMatch;
	        		bestMatch = license;
	        	}
	            if (percentMatch >= 80) {
	            	//write("\nlicense: "+bestMatch.id+ " seems to match - score: "+ bestScore);
	                match = true;
	                break;
	            }
	        }
	        
	    }
       
        if (match) {
        	found = true;
            matchingLicenses.push(license);
        }
    }
    
    // For single-line license, check if it's a known license id.
    if (matchingLicenses.length === 0 && !/[\n\f\r]/.test(licenseString) && licenseString.length < 100) {
        var licenseName = utils.normalizeText(licenseString);
        // If there's an extra "license" on the end of the name, drop it ("MIT License" -> "MIT").
        var license = licenseIndex[licenseName] || licenseIndex[licenseName.replace(/ licen[sc]e$/, "")];
        if (license) {
        	matchingLicenses.push(license);
        } else {
        	trace && trace(colors.magenta("\tNon-matched license name: " + licenseName+"\n"));
        }
    }
    if (matchingLicenses.length === 0) {
        return null;
    }
    if (matchingLicenses.length > 1) {
    	trace && trace(colors.magenta("\tMultiple matching licenses: " + matchingLicenses.length, matchingLicenses.map(function(l) {
        	return l.id;
        })+"\n"));
    }
    return matchingLicenses.map(function(l) {
    	return l.name;
    }).join(',');
}

function parseMarkdownLicense(markdownText, checkType) {
    var license = getMarkdownLicenseSection(markdownText);
    return {
    	type: checkType ? [(license ? matchLicense(license) : matchLicense(markdownText))] : null,
    	copyright: license ? utils.extractCopyright(license) : utils.extractCopyright(markdownText)
    };
}

function getMarkdownLicenseSection(text) {
    // Parse as markdown
    var tree = markdown.parse(text);
    for (var i = 0; i < tree.length; i++) {
        var node = tree[i];
        // Find section with "License" in the name
        if (node[0] === 'header' && /licen[cs]e/i.test(node[2])) {
            var section = [];
            // Group together all paragraph nodes immediately after the header
            for (var j = i + 1; j < tree.length; j++) {
                var childNode = tree[j];
                if (childNode[0] === 'para') {
                    section.push(childNode[1]);
                } else {
                    break;
                }
            }
            // If we got a license, return it
            if (section.length) {
                return section.join('\n\n');
            }
            // Otherwise consider using the header contents itself (e.g. "MIT License")
            if (/.+licen[cs]e/i.test(node[2])) {
                return node[2];
            }
        }
        // Check if paragraph has 'license' in it, and use it as-is
        if (node[0] === 'para' && /.+licen[cs]e/i.test(node[1])) {
            return node[1];
        }
    }
    return null;
}


var licenses = [];
var licenseIndex = {};
Object.keys(spdxLicenses).forEach(function (key) {
	// check only some licenses
	if (licensesToCheck.indexOf(key) >= 0) {
	    var license = spdxLicenses[key];
	    license.id = key;
	    license.signatures = [utils.normalizeText(license.license)];
	
	    licenses.push(license);
	    licenseIndex[key] = license;
	    licenseIndex[utils.normalizeText(key)] = license;
	}
});

var rootDir = path.join(__dirname, "../../..");
browsePackages(_, rootDir, "", "package.json", 0);
//write("\nPackages:"+JSON.stringify(packages,null,2));

write("\n======== End processing licenses ==========");
if (Object.keys(missLic).length !== 0) {
	write("\nMissing licences : "+JSON.stringify(missLic,null,2));
	write(colors.red("\nMissing licenses types : " + Object.keys(missLic).length));
}
if (Object.keys(missCopy).length !== 0) {
	write(colors.yellow("\nMissing licenses copyrights : " + Object.keys(missCopy).length));
}
var packKeys = Object.keys(packages);
write(colors.green("\nComputed licenses : " + packKeys.length));
write("\nTotal packages count : " + count);
write("\nIgnored twins count : " + twins);
write("\n======== ==================================");

var output = packKeys.map(function(key) {
	var pack = packages[key];
	var lic = pack.licenses[0];
	//write("LIC: "+sys.inspect(lic,null,3));
	return {
		name: key,
		version: pack.version,
		licenses: lic.type && lic.type.map(function(t) {
			return t ? t.replace(/ licen[sc]e$/i, "") : "";
		}).join(', '),
		copyrights: lic.copyright && lic.copyright.join(', '),
		path: lic.path
	};
	
});

fs.writeFile(path.join(__dirname, "licenses-output.json"), JSON.stringify(output,null,2), "utf8", _);


process.exit();