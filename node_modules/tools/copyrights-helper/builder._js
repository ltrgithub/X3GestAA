"use strict";

var config = require("../../../nodelocal").config || {};
var path = require('path');
var fs = require('streamline-fs');
var httpClient = require("@sage/syracuse-lib/src/http-client/httpClient");
var markdown = require('markdown').markdown;
var spdxLicenses = require('spdx-license-list/spdx-full');
var utils = require('./utils');
var colors = require('colors/safe');
var sys = require('util');

var write = process.stdout.write.bind(process.stdout);
process.stdout.write = function () {};
process.stderr.write = function () {};

var licensesToCheck = ["MIT", "BSD-2-Clause", "BSD-3-Clause", "Apache-2.0", "ISC"];
var licenses = [];
var licenseIndex = {};
//
var packages = {};
var deps = {};
var missLic = {};
var missCopy = {};
var missDeps = {};
var packList = JSON.parse(fs.readFile(path.join(__dirname, "manual-packages-list.json"), "utf8", _));
var depsList = JSON.parse(fs.readFile(path.join(__dirname, "manual-deps-list.json"), "utf8", _));
var count = 0;
var twins = 0;
var ignoredDir = 0;

var trace;// = function(txt) {write(txt);};

var config = config.copyright;
var proxyConf = config.proxy;
if (proxyConf && proxyConf.auth && proxyConf.auth.toLowerCase() === "ntlm") {
	proxyConf.proxyAuthenticator = require('@sage/syracuse-lib/src/http-client/proxyAuthenticator');
}

var authorsIgnoreList = JSON.parse(fs.readFile(path.join(__dirname, "authors-ignore-list.json"), "utf8", _));
var dirIgnoreList = JSON.parse(fs.readFile(path.join(__dirname, "dir-ignore-list.json"), "utf8", _));

//write("Config: "+JSON.stringify(config,null,2));

var stdOpt = {
	method: "GET",
	headers: {
		"user-agent": "Syracuse-Copyrights-Helper",
		Authorization: "token " + config.token
	},
	ignoreProxy: proxyConf == null,
	proxy: proxyConf
};

function extractSlugUrl(url, path, spliceId) {
	url = url.replace("github.com:", "github.com/");
    var gitRegex = 'github.com/([^/]+/.*)?(.git$)';
    var urlRegex = 'github.com/([^/]+/.*)?';

    var gitMatch = url.match(gitRegex);
    var urlMatch = url.match(urlRegex);

    var slug = (gitMatch || url.match(urlRegex));
    if (!slug) {
		return;
    }
    slug = slug[1];
    if (spliceId != null) slug = slug.split('/').splice(0, spliceId).join('/');
    return slug;
}

function handleRedirect(_, body, opt, res, cb) {
	var redir = JSON.parse(body);
	opt.url = redir.url;
    
	var requestRedirect = httpClient.httpRequest(_, opt);
	var responseRedirect = requestRedirect.end().response(_);
	var bodyRedirect = responseRedirect.readAll(_);
	if (responseRedirect.statusCode === 200) {
		cb(_, bodyRedirect);
	} else if (responseRedirect.statusCode === 301) {
		handleRedirect(_, bodyRedirect, opt, res, cb);
	} else {
		res.$diagnoses = utils.addDiagnose(res.$diagnoses, "error", "An error occured while getting contents (from redirection) on github repository ("+responseRedirect.statusCode+") - url: "+opt.url);
	}
}

var requestRepositoryLicenseInformation = function (_, name, repository, path, res) {
	try {
		return _requestRepositoryLicenseInformation(_, name, repository, path, res);
	} catch(e) {
		write(colors.magenta("!! Repository problem: " + name + " [" + e.message + "]\n"));		
	}
};
	
var _requestRepositoryLicenseInformation = function (_, name, repository, path, res) {

	function inspectLicenseFile(url, _body, checkType) {
		trace && trace("Inspect license content\n");
		// extract copyright
		res.copyright = res.copyright || [];
		var cr = utils.extractCopyright(_body);
		if (cr) {
			cr.forEach(function(c) {
				if (res.copyright.indexOf(c) === -1) res.copyright.push(c);
			});
		}
		
		// extract license type
		if (checkType) {
			res.type = res.type || [];
			var lic = matchLicense(_body);
			if (lic && res.type.indexOf(lic) === -1) res.type.push(lic);
			if (url) res.url = url;
		}
	}
	
	function inspectReadmeFile(file, cnt, checkType) {
		trace && trace("Inspect readme content\n");
		var lic;
		if (/\.(md|markdown)$/i.test(file)) {
			// extract license type from markdown
			var mdParseRes = parseMarkdownLicense(cnt, checkType);
			lic = res.type || mdParseRes.type;
			if (mdParseRes.copyright) {
				res.copyright = res.copyright || [];
				mdParseRes.copyright.forEach(function(c) {
					if (res.copyright.indexOf(c) === -1) res.copyright.push(c);
				});
			}
		} else if (/licen[cs]e/i.test(cnt)) {
			// extract copyright
			res.copyright = res.copyright || [];
			var cr = utils.extractCopyright(cnt);
			if (cr) {
				cr.forEach(function(c) {
					if (res.copyright.indexOf(c) === -1) res.copyright.push(c);
				});
			}
			
	    	// extract license type
			if (checkType) {
				lic = res.type || matchLicense(cnt);
			}
	    }
		res.type = res.type || [];
		if (lic) {
			lic.forEach(function(l) {
				if (l && res.type.indexOf(l) === -1) res.type.push(l);
			});
		}
	}
	
	function readLicenseFile(_, url, checkType) {
		opt.url = url;
		trace && trace("Get raw licence file: "+opt.url+"\n");
		var _request = httpClient.httpRequest(_, opt);
		var _resp = _request.end().response(_);
		var _body = _resp.readAll(_);
		trace && trace("Status: "+_resp.statusCode+"\n");
		if (_resp.statusCode === 200) {
			inspectLicenseFile(url, _body, checkType);
		} else {
			res.$diagnoses = utils.addDiagnose(res.$diagnoses, "warning", "An error occured while getting LICENSE file on github repository ("+_resp.statusCode+")");
		}
	}
	
	function readReadmeFile(_, url, checkType) {
		opt.url = url;
		trace && trace("Get raw readme file: "+opt.url+"\n");
		var _request = httpClient.httpRequest(_, opt);
		var _resp = _request.end().response(_);
		var _body = _resp.readAll(_);
		trace && trace("Status: "+_resp.statusCode+"\n");
		if (_resp.statusCode === 200) {
			inspectReadmeFile(url, _body, checkType);
		} else {
			res.$diagnoses = utils.addDiagnose(res.$diagnoses, "warning", "An error occured while getting README file on github repository ("+_resp.statusCode+")");
		}
	}
	
	function analyseGithubContents(_, _body) {
		var contents = JSON.parse(_body);
		//write("\ncontents: "+JSON.stringify(contents,null,2));
		var lic = contents.filter(function (content) {
	        return content.name.match(/licen[cs]e/i);
	    });
		
		if (lic.length !== 0) {
			lic.forEach_(_, function(_, l) {
				readLicenseFile(_, l.download_url, mustCheckType);
			});
		} else {
			res.$diagnoses = utils.addDiagnose(res.$diagnoses, "error", "No LICENSE file github repository");
		}
		
		if (lic.length === 0 || !res.type || !res.copyright) {
			var rm = contents.filter(function (content) {
		        return content.name.match(/^readme/i);
		    });
			if (rm.length !== 0) {
				readReadmeFile(_, rm[0].download_url, mustCheckType);
				if (res.type) delete res.$diagnoses;
			} else {
				res.$diagnoses = utils.addDiagnose(res.$diagnoses, "error", "No README file github repository");
			}
		}
	}
	
	function fetchGithubContent(_, url) {
		var slug = extractSlugUrl(url, path);
	    var username = slug.split('/')[0];
	    var project = slug.split('/')[1];
	
		
		opt.url = 'https://api.github.com/repos/' + username + "/" + project + '/contents';
		trace && trace("\n=> fetch github content:" + project+"\n\tgithub url: "+url+"\n\tslug url: "+opt.url);
	    
		var request = httpClient.httpRequest(_, opt);
		var response = request.end().response(_);
		var body = response.readAll(_);
		if (response.statusCode === 200) {
			analyseGithubContents(_, body);
		
	
		} else if (response.statusCode === 301) {
			handleRedirect(_, body, opt, res, analyseGithubContents);
			
		} else {
			res.$diagnoses = utils.addDiagnose(res.$diagnoses, "error", "An error occured while getting contents on github repository ("+response.statusCode+") - url: "+opt.url);
		}
	}
	
	
	//
	//
	repository = repository || {};
	res = res || {};
	//write("RES: "+JSON.stringify(res,null,2));
	if (res.type && !Array.isArray(res.type)) res.type = [res.type];

	
	
	
	//write("Res:"+JSON.stringify(res,null,2)+"\n");
	var mustCheckType = !res.type || res.type.length === 0;
	res.path = path;
	
	// Inspect file system to find LICENSE and README files
	var files = fs.readdir(rootDir + path, _);
	var filesLic = [], fileReadme;
	files.forEach_(_, function(_, file) {
		var fpath = path + "/" + file;
		var stats = fs.lstat(rootDir + fpath, _);
		if (stats.isFile()) {
			if (file.match(/licen[cs]e/i)) {
				filesLic.push(file);
			} else if (file.match(/^readme/i)) {
				fileReadme = file;
			}
		}
	});
	
	if (filesLic.length !== 0) {
		filesLic.forEach_(_, function(_, f) {
			inspectLicenseFile(null, fs.readFile(rootDir + path + "/" + f, 'utf8', _), mustCheckType);
		});
	} else if (fileReadme && (!res.type || !res.copyright)) {
		var readmeCnt = fs.readFile(rootDir + path + "/" + fileReadme, 'utf8', _);
		inspectReadmeFile(fileReadme, readmeCnt, mustCheckType);
	}
	
	
	// Inspect github repository if license type and copyright not identified
	if ((!res.type || res.type.length === 0 || !res.copyright || res.copyright.length === 0)) {
		var opt = stdOpt;
		var slug;
		if (res.url && !repository.url) {
			slug = extractSlugUrl(res.url, path, 2);
			if (!slug) {
				if (!res.type || res.type.length === 0) write(colors.magenta("Repository url problem\n"));
				return res;
			}
			repository.url = "https://github.com/" + slug;
		}
		if (repository.url) {
			fetchGithubContent(_, repository.url);
		} else {
			trace && trace(colors.magenta("No url found to access github repository\n"));
		}
	}
	
   // write("\nRes: "+JSON.stringify(res,null,2));
	return res;
};

// Match a license body or license id against known set of licenses.
function matchLicense(licenseString) {
    // Find all textual matches on license text.
    var normalized = utils.normalizeText(licenseString);
    var matchingLicenses = [];
    //write("\nnormalized : "+normalized);
    // Check matches of normalized license content against signatures.
    var found = false, bestMatch, bestScore = 0;
    for (var i = 0; i < licenses.length; i++) {
        var license = licenses[i];
        var match = false;
        for (var j = 0; j < license.signatures.length; j++) {
            if (normalized.indexOf(license.signatures[j]) >= 0) {
                match = true;
                break;
            }

        }
        if (!match) {
	        for (var k = 0; k < license.signatures.length; k++) {
	        	var percentMatch = utils.similarity(normalized, license.signatures[k]);
	        	if (percentMatch > bestScore) {
	        		bestScore = percentMatch;
	        		bestMatch = license;
	        	}
	            if (percentMatch >= 80) {
	            	//write("\nlicense: "+bestMatch.id+ " seems to match - score: "+ bestScore);
	                match = true;
	                break;
	            }
	        }
	        
	    }
       
        if (match) {
        	found = true;
            matchingLicenses.push(license);
        }
    }
    
    // For single-line license, check if it's a known license id.
    if (matchingLicenses.length === 0 && !/[\n\f\r]/.test(licenseString) && licenseString.length < 100) {
        var licenseName = utils.normalizeText(licenseString);
        // If there's an extra "license" on the end of the name, drop it ("MIT License" -> "MIT").
        var license = licenseIndex[licenseName] || licenseIndex[licenseName.replace(/ licen[sc]e$/, "")];
        if (license) {
        	matchingLicenses.push(license);
        } else {
        	trace && trace(colors.magenta("\tNon-matched license name: " + licenseName+"\n"));
        }
    }
    if (matchingLicenses.length === 0) {
        return null;
    }
    if (matchingLicenses.length > 1) {
    	trace && trace(colors.magenta("\tMultiple matching licenses: " + matchingLicenses.length, matchingLicenses.map(function(l) {
        	return l.id;
        })+"\n"));
    }
//    return matchingLicenses.map(function(l) {
//    	return l.name;
//    }).join(',');
    return matchingLicenses[0].name;
}

function parseMarkdownLicense(markdownText, checkType) {
    var license = getMarkdownLicenseSection(markdownText);
    return {
    	type: checkType ? [(license ? matchLicense(license) : matchLicense(markdownText))] : null,
    	copyright: license ? utils.extractCopyright(license) : utils.extractCopyright(markdownText)
    };
}

function getMarkdownLicenseSection(text) {
    // Parse as markdown
    var tree = markdown.parse(text);
    for (var i = 0; i < tree.length; i++) {
        var node = tree[i];
        // Find section with "License" in the name
        if (node[0] === 'header' && /licen[cs]e/i.test(node[2])) {
            var section = [];
            // Group together all paragraph nodes immediately after the header
            for (var j = i + 1; j < tree.length; j++) {
                var childNode = tree[j];
                if (childNode[0] === 'para') {
                    section.push(childNode[1]);
                } else {
                    break;
                }
            }
            // If we got a license, return it
            if (section.length) {
                return section.join('\n\n');
            }
            // Otherwise consider using the header contents itself (e.g. "MIT License")
            if (/.+licen[cs]e/i.test(node[2])) {
                return node[2];
            }
        }
        // Check if paragraph has 'license' in it, and use it as-is
        if (node[0] === 'para' && /.+licen[cs]e/i.test(node[1])) {
            return node[1];
        }
    }
    return null;
}

function browsePackages(_, root, path, fileName, depth) {


	var files = fs.readdir(root + path, _);
	files.forEach_(_, function(_, file) {
		var fpath = path + "/" + file;
		var stats = fs.lstat(root + fpath, _);
		if (stats.isDirectory() && !/^test$/.test(file)) {
			if (dirIgnoreList.some(function (d) {
				return fpath.match(d);
			})) {
				ignoredDir++;
				write(colors.grey("# Exclude directory "+ fpath + "\n"));				
				return;
			}
			//write("\n"+depth + "- dir: " + file);
			browsePackages(_, root, fpath, fileName, depth + 1);
		} else if (stats.isFile() && file === fileName) {
			count++;
			//write("\nModule found: " +  path.substring(1));
			var pack = require(root + path + "/" + file);
			var author = typeof pack.author === "object" ? pack.author.name : pack.author;
			if (packList[pack.name] || (!packages[pack.name] && !missLic[pack.name] && !missCopy[pack.name]) && (!author || (author && authorsIgnoreList.indexOf(author) === -1))) {
				write("-> Inspect " + pack.name + " ("+pack.version+") --> "+ path + "\t");
				

				if (packList[pack.name]) {
					pack.licenses = [];
					pack.licenses.push(packList[pack.name]);
				} else {
					if (pack.license) {
						pack.licenses = pack.licenses || [];
						pack.licenses.push({
							type: typeof pack.license === "object" ? (pack.license.name || pack.license.type) : pack.license
						});
					} else if (pack.licenses) {
						if (!Array.isArray(pack.licenses)) {
							if (typeof pack.licenses === "string") {
								pack.licenses = [{type: pack.licenses}];
							} else {
								pack.licenses = [pack.licenses];
							}
						} else if (typeof pack.licenses[0] === "string") {
							pack.licenses = pack.licenses.map(function(l) {
								return {
									type: l
								};
							});
						}
					}
				}
				var repoLic = requestRepositoryLicenseInformation(_, pack.name, pack.repository, path, pack.licenses && pack.licenses[0]);
				if (!repoLic) write(colors.red("\n\tError while inspect repository for "+pack.name + " ("+pack.version+") --> "+ path));
				pack.licenses = [repoLic];
				
			

				if (!pack.licenses[0].type || pack.licenses[0].type.length === 0 || !pack.licenses[0].type[0]) {
					write(colors.red("Type not found !\n"));
					missLic[pack.name] = pack.licenses;
				} else {
					packages[pack.name] = pack;
				}
				
				if (!pack.licenses[0].copyright || pack.licenses[0].copyright.length === 0 || !pack.licenses[0].copyright[0]) {
					write(colors.yellow("Copyright not found !\n"));
					missCopy[pack.name] = pack.licenses;
				}
				
				if (pack.licenses[0].type && pack.licenses[0].type.length > 0 && pack.licenses[0].copyright && pack.licenses[0].copyright.length > 0) {
					write(colors.green("OK\n"));
					
				} else {
					write("\n");
				}
				trace && trace("* Result: "+sys.inspect(repoLic)+"\n");
			} else if (!packages[pack.name] && !missLic[pack.name]){
				count--;
				write(colors.grey("# Ignore package "+ pack.name + "\n"));
			} else {
				twins++;
				count--;
			}
		}
	});
}

function simplifyLicenseName(name) {
	name = name.replace(/ licen[sc]e$/i, "");
	name = name.replace("Apache-2.0", "Apache License 2.0");
	return name;
}

function forceManualEntry(entries, dest) {
	var res = {};
	var keys = Object.keys(entries);
	keys.forEach(function(k) {
		if (!dest[k]) {
			res[k] = {
				name: k,
				version: Array.isArray(entries[k].version) ? entries[k].version.join(", ") : entries[k].version,
				licenses: entries[k].type ? entries[k].type.join(',') : entries[k].licenses,
				copyrights: Array.isArray(entries[k].copyrights) ? entries[k].copyrights.join(", ") : entries[k].copyrights
			};
		}
	});
	return res;
}

function processPackages(_) {
	write(colors.green("!!! Please wait for build of packages output JSON file...\n"));
	Object.keys(spdxLicenses).forEach(function (key) {
		// check only some licenses
		if (licensesToCheck.indexOf(key) >= 0) {
		    var license = spdxLicenses[key];
		    license.id = key;
		    license.signatures = [utils.normalizeText(license.license)];
		
		    licenses.push(license);
		    licenseIndex[key] = license;
		    licenseIndex[utils.normalizeText(key)] = license;
		}
	});
	
	write("======== Begin processing packages ==========\n");
	browsePackages(_, rootDir, "", "package.json", 0);
	//write("\nPackages:"+JSON.stringify(packages,null,2));

	write("\n======== End processing packages ==========");
	if (Object.keys(missLic).length !== 0) {
		write("\nMissing licences : "+JSON.stringify(missLic,null,2));
		write(colors.red("\nMissing licenses types : " + Object.keys(missLic).length));
	}
	if (Object.keys(missCopy).length !== 0) {
		write(colors.yellow("\nMissing licenses copyrights : " + Object.keys(missCopy).length));
	}

	var packKeys = Object.keys(packages);
	write(colors.green("\nComputed licenses : " + packKeys.length));
	write("\nTotal packages count : " + count);
	write("\nIgnored twins count : " + twins);

	var output = packKeys.map(function(key) {
		var pack = packages[key];
		var lic = pack.licenses[0];
		//write("LIC: "+sys.inspect(lic,null,3));
		return {
			name: key,
			version: pack.version,
			licenses: lic.type && lic.type.map(function(t) {
				return t ? simplifyLicenseName(t) : "";
			}).join(', '),
			copyrights: lic.copyright && lic.copyright.join(', '),
			path: lic.path
		};
		
	});

	var manPacks = forceManualEntry(packList, packages) ;
	var manKeys = Object.keys(manPacks);
	manKeys.forEach(function(m) {
		output.push(manPacks[m]);
	});
	
	write("\n===========================================\n");
	fs.writeFile(path.join(process.cwd(), "copyrights/output-packages.json"), JSON.stringify(output,null,2), "utf8", _);

	return output;
}

function browseDeps(_, root, curr, depth, packs) {
	var files = fs.readdir(root + curr, _);
	files.forEach_(_, function(_, file) {
		var fpath = curr + "/" + file;
		var stats = fs.lstat(root + fpath, _);
		if (stats.isDirectory() && !/^test$/.test(file)) {
			if (/^deps$/.test(file)) {
				var depsFiles = fs.readdir(path.join(root, curr, file), _);
				if (depsFiles.indexOf("package.json") === -1) {
					write("\nInspect deps folder in: " + curr);
					depsFiles.forEach(function(dep) {
						if (!deps[dep]) {
							var idx = outputPacks.indexOf(dep.toLowerCase());
							if (depsList[dep]) {
								write(colors.green("\n\tDeps found in manual-deps-list.json: "+dep));
								deps[dep] = depsList[dep];
								deps[dep].name = dep;
								deps[dep].path = curr + "/deps/" + dep;
								
							} else if (idx !== -1) {
								write(colors.cyan("\n\tDeps already computed with packages: "+dep));
								deps[dep] = packs[idx];
							}
							
							if (deps[dep] && !deps[dep].licenses) {
								write(colors.red("\n\tLicense is missing for " + colors.yellow(dep) +". Please consider to add this dependency in manual-deps-list.json: "+dep));
								missDeps[dep] = {
									name: dep,
									path: curr + "/deps/" + dep
								};
							}
							
						}
					});
				}
				
			} else {
				browseDeps(_, root, fpath, depth + 1, packs);
			}
		}
	});
}

var outputPacks;
function processDeps(_, packs) {
	try {
		packs = packs || JSON.parse(fs.readFile(path.join(process.cwd(), "copyrights/output-packages.json"), "utf8", _));
	} catch (e) {
		write(colors.red("output-packages.json file parse exception...\nPlease run this tool with --pack option before...\n"));
		write(colors.red(e.message));
		process.exit();
	}
	write(colors.green("!!! Please wait for build of dependencies output JSON file...\n"));
	
	write("======== Begin processing deps ==========\n");
	
	outputPacks = packs.map(function(p) {
		return p.name.toLowerCase();
	});
	browseDeps(_, rootDir, "", 0, packs);
	//write("\nPackages:"+JSON.stringify(packages,null,2));

	
	write("\n======== End processing deps ==========");
	if (Object.keys(missDeps).length !== 0) {
		write("\nMissing licences : "+JSON.stringify(missDeps,null,2));
		write(colors.red("\nMissing licenses types : " + Object.keys(missDeps).length));
	}
	var depsKeys = Object.keys(deps);
	write(colors.green("\nComputed deps : " + depsKeys.length));

	var output = depsKeys.map(function(key) {
		return deps[key];
	});
	
	var manDeps = forceManualEntry(depsList, deps) ;
	
	var manKeys = Object.keys(manDeps);
	write(colors.yellow("\nForced manual deps : " + manKeys.length));
	manKeys.forEach(function(m) {
		output.push(manDeps[m]);
	});
	
	write("\n===========================================\n");
	fs.writeFile(path.join(process.cwd(), "copyrights/output-deps.json"), JSON.stringify(output,null,2), "utf8", _);
}

var rootDir = path.join(__dirname, "../../..");


var mode = process.argv.length > 2 ? process.argv[2] : "--all";
switch(mode) {
	case "--all":
		var packs = processPackages(_);
		processDeps(_, packs);
		break;
	case "--pack":
		processPackages(_);
		break;
	case "--deps":
		processDeps(_);
		break;
	default:
		write(colors.yellow("Bad parameter\nUsage:\n"));
		write(colors.yellow("node node_modules/tools/copyrights-helper [param]\n"));
		write(colors.yellow("param can be:\n"));
		write(colors.yellow("\t`--pack` to build output-packages.json file\n"));
		write(colors.yellow("\t`--deps` to build output-deps.json file\n"));
		write(colors.yellow("\t`--html` to build rendering output HTML file\n"));
		write(colors.yellow("\t`--all` to build all output files\n"));
		
		break;
}

process.exit();