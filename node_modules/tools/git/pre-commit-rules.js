"use strict";
var fs = require('fs');
var beautify = require('js-beautify').js_beautify;
var JSHINT = require("jshint").JSHINT;
var pre_commit = require('./pre-commit');
var beautifyCount = 0;
var localeCount = 0;
var asiCount = 0;
var errCount = 0;
var checkLocaleSync = require('tools/check/checkLocaleSync');
var changedFiles = [];
var checkVariableSync = require('tools/check/checkVariableSync');
var traceHelperResources;

function error(msg) {
	console.error("ERROR: " + msg);
	errCount++;
}

function info(msg) {
	console.log(msg);
}

function acceptFile(f) {
	var ext = f.substring(f.lastIndexOf('.'));
	if (ext !== '.json' && ext !== '.js' && ext !== '._js') return false;
	if (f.indexOf('/cvgRecords/') >= 0) return false;
	if (f.indexOf('node_modules/tools/') >= 0) return false;
	if (f.indexOf('syracuse-') < 0 && f.indexOf('node_modules/jsx509/') < 0 && f.indexOf("node_modules/license-tool") < 0) return false;
	var start = f.indexOf("node_modules/");
	if (f.indexOf('/deps/') > 0 || f.indexOf('/node_modules/', start + 1) > 0) return false;
	if (f.indexOf('/html/tests/') >0 || (f.indexOf('/html/mobile/') > 0 && f.indexOf('/html/mobile/js/debug') < 0)) return false;
	if (f.indexOf('/syracuse-tablet/mockup') > 0) return false;
	if (f.indexOf('syracuse-ui/themes/') >= 0) return false;
	if (f.indexOf('/syracuse-tablet/dist/js/main.min.js') > 0) return;
	if (f.indexOf('/syracuse-tablet/dist/js/main.joined.js') > 0) return;
	// These resources are copies of /syracuse-tablet/html/js/resources so no need to check 
	if (f.indexOf('/syracuse-tablet/dist/js/resources/') > 0) return;
	return true;
}

exports.do_not_change = undefined;

exports.processFileSync = function(file) {
	if (!acceptFile(file)) return;
	if (!fs.existsSync(file)) return; // file deleted by commit
	var source = fs.readFileSync(file, 'utf8');
	if (file.indexOf('.json') === file.length-5) {
		var json;
		try {
			json = JSON.parse(source);
		} catch (e) {
			error("Invalid JSON in "+file+": " +e);
		}
		var changed = {};
		checkLocaleSync.checkLocalization(json, file, changed);
		if (changed.messages.length) {
			error("Localized messages in " + file + ":\n" + changed.messages.join("\n"));
		}
		return;
	}
	var errCountOld = errCount;
	var modified = false;
	if (!/^\uFEFF?\n?["']use strict["'];/.test(source.substring(0, source.indexOf('\n', 2)))) error(file + ': "use strict"; missing at top of file (must be first line)');
	if (/^[^\/\"\']*debugger/m.test(source)) error(file + ': contains active "debugger" statement');
	if (/^(<<<<<<<|=======|>>>>>>>)/m.test(source)) error(file + ': unresolved merge conflict (search for <<<<, ==== , >>>>)');
	if (/\bthrow\s+\(*\s*[\'\"]/m.test(source)) error(file + ': throw "..." detected - change it to throw new Error("...")');
	var r = /exports\.([A-Z][A-Z0-9\_\.\$]*|[^A-Z][\w\.\$]+)\s*(?:\=\s*[\w\.\$]+\s*)*\=\s*helpers?\.defineClass\s*\(/.exec(source);
	if (r) {
		error(file+': exported class '+r[1]+' does not start with uppercase letter or does not contain lower case letters');		
	}
	// variable check
	if (process.argv[2] === "vars_check") {
		try {
			var result = checkVariableSync.checkFile(file, source);
			if (result && result.length > 0) {
				error("Undeclared variables in "+file+"\n"+result.join('\n')+"\n");
			}
		} catch (e) {
			console.error("Parse exception in file "+file+": "+e);
		}
		
	}
	// check and fix localized messages
	// /* comment out when there are problems with processing localized messages
	try {
		var changed = { allowChange: ((errCount === errCountOld) && !exports.do_not_change)};
		source = checkLocaleSync.treatFile(source, file, changed);
		if (changed.messages && changed.messages.length) {
			error("Mismatches for localized messages in " +file+"\n"+changed.messages.join("\n")+"\n");
			return;
		} else if (changed.change && errCount === errCountOld) {
			modified = true;
			// also stage resource file for git
			if (changed.resource) changedFiles.push(changed.resource);
			localeCount++;
		}
	} catch (e) {
		error("Localized messages in "+file+": " +e);
		return;
	}
	// */
	// check tracers
	var regex = /(\w+)\s*=\s*require\s*\(\s*["']syracuse-trace\/lib\/helper["']\s*\)\.getTracer\s*\(\s*(?:["']([\w\-\.]+)["']\s*\))?/g;
	var r;
	while (r = regex.exec(source)) {
		if (r[2]) {
			if (!traceHelperResources) {
				try {
					traceHelperResources = JSON.parse(fs.readFileSync(__dirname+"/../../syracuse-trace/lib/resources/helper-en.json", "utf8"));
				} catch (e) {
					console.error("Warning: cannot open trace helper resource file "+e);
					traceHelperResources = {};
				}
			}
			if (!(r[2] in traceHelperResources)) {
				error(file+": No resource for tracer module '"+r[2]+"' in resource file syracuse-trace/lib/resources/helper-en.json");
			}			
		} else {
			var line = source.lastIndexOf('\n', r.index);
			var line2 = source.indexOf('\n', line+1);
			console.error("Warning: Please check manually syracuse-trace/lib/resources/helper-en.json\nbecause module of tracer instance '"+r[1]+"' cannot be determined in\n"+(line2 >= 0 ? source.substring(line+1, line2) : source.substr(line+1)));
		}
		var remaining = source.substr(r.index+1);
		var index = -1;
		while ((index = remaining.indexOf(r[1], index+1)) >= 0) {
			var line = remaining.lastIndexOf('\n', index);
			var finish = (line < index); // last line without line separator
			// maybe a property of an object
			if (!/^\w/.test(remaining[index+r[1].length]) && !/^[\w\.]/.test(remaining[index-1])) { // test whether tracer variable has not been found by incident as part of a bigger variable
				// find out whether it will be really invoked
				var linestart = remaining.substring(line+1, index);
				// remove escaped characters
				linestart = linestart.replace(/\\['"\/]/g, ""); 
				var tmp;
				// remove strings, multiline comment ends, regex, and full multiline comments 
				while ((tmp = linestart.replace(/^([^\/"']*)(?:(["']).*?\2)/, "$1a")) !== linestart || (tmp = linestart.replace(/^[^\/"']*\*\//, "")) !== linestart || (tmp = linestart.replace(/^([^\/"']*)\/(?:[^\*].*?|\*.*?\*)\//, "$1a")) !== linestart) {
					linestart = tmp;
				}
				// when tracer outside of line comment, it may be an object property or must be invoked like tracer.debug && tracer.debug(...
				var line2 = remaining.indexOf('\n', line+1);
				if (!/\/\/|"|'/.test(linestart) && !/^(\w+)(?:\s*\:|\.(debug|info|warn|error|fatal)\s*\&\&\s*\1\.\2\s*\()/.test(remaining.substr(index))) {
					// maybe tracer itself passed as function parameter: warning
					var fullLine = (line2 >= 0 ? remaining.substring(line+1, line2) : remaining.substr(line+1));
					if (remaining[index+r[1].length] !== '.') {
						// find out whether it is in function call: count brackets						
						while ((tmp = linestart.replace(/\([^\(\)]*\)/g, "")) !== linestart) {
							linestart = tmp;
						}
						if (linestart.indexOf('(') >= 0) console.error(file+": Passed tracer '"+r[1]+"' to a function. Will not check correct invocation of tracer within function:\n"+fullLine);
						else if (/[:=]\s*$/.test(linestart)) console.error(file+": Assigned tracer '"+r[1]+"' to a variable. Will not check correct invocation of tracer:\n"+fullLine);
						else error(file+": tracer '"+r[1]+"' is invoked without property in line:\n"+fullLine);
					} else
					error(file+": tracer '"+r[1]+"' is not invoked correctly in line:\n"+fullLine);
				}
				index = line2;
			}
			if (finish) break;
		}
	}

	if (errCount !== errCountOld || exports.do_not_change)
		return;
	// beautify
	var beautified = beautify(source, {
		indent_char: '\t',
		indent_size: 1,
	});
	if (beautified !== source) {
		info(file + ": beautified");
		beautifyCount++;
		modified = true;
		source = beautified;
	}

	// add missing semicolons
	var asiFixed = false;
	var jshintrcConf, jshintrcFile = __dirname + '/../../../.jshintrc';
	if (!fs.existsSync(jshintrcFile)) {
		jshintrcConf = {};
	}
	else {
		try {
			jshintrcConf = JSON.parse(fs.readFileSync(jshintrcFile, 'utf8'));
		} catch(e) {
			throw new Error("The .jshintrc file is not parsable !");
		}
	}
	if (!JSHINT(source, jshintrcConf)) {
		var lines = source.split(/\r?\n/);
		JSHINT.data().errors.forEach(function(err) {
			if (!err) return;
			var line = lines[err.line - 1];
			if (/^Missing semicolon/.test(err.reason) && !/[;:\{]$/.test(line)) {
				lines[err.line - 1] += ';';
				asiFixed = true;
			}
		});
		if (asiFixed) {
			console.log(file + ": fixed semicolons");
			asiCount++;
			modified = true;
			source = lines.join('\n');
		}
	}
	if (modified) {
		source = source.replace(/^[\uFEFF\n\s]+/, ""); // remove characters at the beginning which should not be there
		fs.writeFileSync(file, source, 'utf8');
		changedFiles.push(file);
	}
};

// execute 'git add' as a subprocess. This function will also be used as a callback function for child_process.exec
function execute(error, stdout, stderr) {
	if (error) {
		console.error("Error in git add :"+error+" Return code "+error.code);
		console.error("Output: "+stdout+stderr);
		process.exit(errCount > 0 || beautifyCount > 0 || asiCount > 0);
	}
	if (changedFiles.length) {
		var files = changedFiles.splice(0, 20).join(' ');
		console.log("git add "+files);
		pre_commit.exec('git add '+files, execute);
	} else {
		process.exit(errCount > 0 || beautifyCount > 0 || asiCount > 0);
	}
}

exports.finish = function(no_git_add) {
	if (beautifyCount > 0) console.error(beautifyCount + " files have been beautified. Please run commit again!");
	if (asiCount > 0) console.error(asiCount + " files had missing semicolons (fixed). Please run commit again!");
	if (errCount > 0) console.error(errCount + " errors detected by pre-commit hook. Aborting!");
	if (localeCount > 0) console.error(localeCount + " files have been changed for localized messages. Please run commit again!");
	if (no_git_add)
		changedFiles.length = 0;
	// execute 'git add' and exit
	execute(null);
};
