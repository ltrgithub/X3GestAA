"use strict";
var fs = require('fs');
var beautify = require('js-beautify').js_beautify;
var JSHINT = require("jshint").JSHINT;
var pre_commit = require('./pre-commit');
var beautifyCount = 0;
var localeCount = 0;
var asiCount = 0;
var errCount = 0;
var checkLocaleSync = require('tools/check/checkLocaleSync');
var changedFiles = [];
var checkVariableSync =   require('tools/check/checkVariableSync');

function error(msg) {
	console.error("ERROR: " + msg);
	errCount++;
}

function info(msg) {
	console.log(msg);
}

function acceptFile(f) {
	var ext = f.substring(f.lastIndexOf('.'));
	if (ext !== '.json' && ext !== '.js' && ext !== '._js') return false;
	if (f.indexOf('/cvgRecords/') >= 0) return false;
	if (f.indexOf('node_modules/tools/') >= 0) return false;
	if (f.indexOf('syracuse-') < 0 && f.indexOf('node_modules/jsx509/') < 0 && f.indexOf('node_modules/streamline-auth/') < 0) return false;
	var start = f.indexOf("node_modules/");
	if (f.indexOf('/deps/') > 0 || f.indexOf('/node_modules/', start + 1) > 0) return false;
	if (f.indexOf('/html/tests/') >0 || (f.indexOf('/html/mobile/') > 0 && f.indexOf('/html/mobile/js/debug') < 0)) return false;
	if (f.indexOf('/syracuse-tablet/mockup') > 0) return false;
	if (f.indexOf('syracuse-ui/themes/desktop/sage') >= 0) return false;
	return true;
}

exports.do_not_change = undefined;

exports.processFileSync = function(file) {
	if (!acceptFile(file)) return;
	if (!fs.existsSync(file)) return; // file deleted by commit
	var source = fs.readFileSync(file, 'utf8');
	if (file.indexOf('.json') === file.length-5) {
		try {
			JSON.parse(source);
		} catch (e) {
			error("Invalid JSON in "+file+": " +e);
		}
		return;
	}
	var errCountOld = errCount;
	var modified = false;
	if (!/^\uFEFF?\n?["']use strict["'];/.test(source.substring(0, source.indexOf('\n', 2)))) error(file + ': "use strict"; missing at top of file (must be first line)');
	if (/^[^\/\"\']*debugger/m.test(source)) error(file + ': contains active "debugger" statement');
	if (/^(<<<<<<<|=======|>>>>>>>)/m.test(source)) error(file + ': unresolved merge conflict (search for <<<<, ==== , >>>>)');
	if (/\bthrow\s+\(*\s*[\'\"]/m.test(source)) error(file + ': throw "..." detected - change it to throw new Error("...")');
	// variable check
	if (process.argv[2] === "vars_check") {
		try {
			var result = checkVariableSync.checkFile(file, source);
			if (result && result.length > 0) {
				error("Undeclared variables in "+file+"\n"+result.join('\n')+"\n");
			}
		} catch (e) {
			console.error("Parse exception in file "+file+": "+e);
		}
		
	}
	// check and fix localized messages
	// /* comment out when there are problems with processing localized messages
	try {
		var changed = { allowChange: ((errCount === errCountOld) && !exports.do_not_change)};
		source = checkLocaleSync.treatFile(source, file, changed);
		if (changed.messages && changed.messages.length) {
			error("Mismatches for localized messages in " +file+"\n"+changed.messages.join("\n")+"\n");
			return;
		} else if (changed.change && errCount === errCountOld) {
			modified = true;
			// also stage resource file for git
			if (changed.resource) changedFiles.push(changed.resource);
			localeCount++;
		}
	} catch (e) {
		error("Localized messages in "+file+": " +e);
		return;
	}
	// */
	if (errCount !== errCountOld || exports.do_not_change)
		return;
	// beautify
	var beautified = beautify(source, {
		indent_char: '\t',
		indent_size: 1,
	});
	if (beautified !== source) {
		info(file + ": beautified");
		beautifyCount++;
		modified = true;
		source = beautified;
	}

	// add missing semicolons
	var asiFixed = false;
	var jshintrcConf, jshintrcFile = __dirname + '/../../../.jshintrc';
	if (!fs.existsSync(jshintrcFile)) {
		jshintrcConf = {};
	}
	else {
		try {
			jshintrcConf = JSON.parse(fs.readFileSync(jshintrcFile, 'utf8'));
		} catch(e) {
			throw new Error("The .jshintrc file is not parsable !");
		}
	}
	if (!JSHINT(source, jshintrcConf)) {
		var lines = source.split(/\r?\n/);
		JSHINT.data().errors.forEach(function(err) {
			if (!err) return;
			var line = lines[err.line - 1];
			if (/^Missing semicolon/.test(err.reason) && !/[;:\{]$/.test(line)) {
				lines[err.line - 1] += ';';
				asiFixed = true;
			}
		});
		if (asiFixed) {
			console.log(file + ": fixed semicolons");
			asiCount++;
			modified = true;
			source = lines.join('\n');
		}
	}
	if (modified) {
		fs.writeFileSync(file, source, 'utf8');
		changedFiles.push(file);
	}
};

// execute 'git add' as a subprocess. This function will also be used as a callback function for child_process.exec
function execute(error, stdout, stderr) {
	if (error) {
		console.error("Error in git add :"+error+" Return code "+error.code);
		console.error("Output: "+stdout+stderr);
		process.exit(errCount > 0 || beautifyCount > 0 || asiCount > 0);
	}
	if (changedFiles.length) {
		var files = changedFiles.splice(0, 20).join(' ');
		console.log("git add "+files);
		pre_commit.exec('git add '+files, execute);
	} else {
		process.exit(errCount > 0 || beautifyCount > 0 || asiCount > 0);
	}
}

exports.finish = function(no_git_add) {
	if (beautifyCount > 0) console.error(beautifyCount + " files have been beautified. Please run commit again!");
	if (asiCount > 0) console.error(asiCount + " files had missing semicolons (fixed). Please run commit again!");
	if (errCount > 0) console.error(errCount + " errors detected by pre-commit hook. Aborting!");
	if (localeCount > 0) console.error(localeCount + " files have been changed for localized messages. Please run commit again!");
	if (no_git_add)
		changedFiles.length = 0;
	// execute 'git add' and exit
	execute(null);
};
