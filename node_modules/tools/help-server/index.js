var static = require('node-static');
var file = new static.Server('../online-doc/DOCV7-X3');
var crypto = require('crypto');
var config = require('./config');

var x = 0;
var secret = config.key.replace(/./g, function(c) {
	return String.fromCharCode(0x21 + ((x += c.charCodeAt(0)) & 0x3f));
});

var port = config.port || 80;
var tolerance = config.tolerance || 5;

function refused(response, status, reason) {
	response.writeHead(status, {
		"content-type": "text/plain"
	});
	response.end(reason);
}

function parseDate(s) {
	// use Ecmascript 5 date extension
	return new Date(s);
}

function authorize(request, response) {
	try {
		var header = request.headers.authorization,
			matches;
		// header = "X3Doc eyJzZXJpYWwiOiIxMDIzNyIsImRhdGUiOiIyMDEzLTA3LTIyVDE1OjQ3OjAwWiIsIm9uY2UiOiI4N2E4LTA5MmIt4oCmIiwic2lnbmF0dXJlIjoiMTBiOC4uLiJ9==";
		if (!header || !(matches = /^X3Doc (\S+)$/.exec(header))) return refused(response, 403, "token missing");
		var token = new Buffer(matches[1], 'base64').toString('utf8');
		token = JSON.parse(token);
		var d = parseDate(token.date);
		var now = new Date();
		if (!d) return refused(response, 403, "bad date format");
		if (Math.abs(d - now) > tolerance * 60 * 1000) return refused(response, 403, "time mismatch");
		var str = token.serial + '/' + token.date + '/' + token.once + '/' + secret;
		var hash = crypto.createHash('MD5');
		hash.update(str, "utf8");
		var sign = hash.digest("hex");
		if (sign !== token.signature) return refused(response, 403, "signature mismatch");
		return true;
	} catch (ex) {
		console.error(ex.stack);
		return refused(response, 500, "exception");
	}
}

require('http').createServer(function(request, response) {
	request.addListener('end', function() {
		if (config.unsafe || authorize(request, response)) file.serve(request, response, function(err, result) {
			if (err) return refused(response, 500, err.message);
			else return refused(response, result.status, result.message);
		});
	}).resume();
}).listen(port);

console.log("server started on port " + port);