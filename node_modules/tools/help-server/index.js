var static = require('node-static');
var file = new static.Server('../online-doc/DOCV7-X3');
var crypto = require('crypto');
var config = require('./config');

var x = 0;
var secret = config.key.replace(/./g, function(c) {
	return String.fromCharCode(0x21 + ((x += c.charCodeAt(0)) & 0x3f));
});

var port = config.port || 80;
var tolerance = config.tolerance || 5;

function refused(response, status, reason) {
	response.writeHead(status, {
		"content-type": "text/plain"
	});
	response.end(reason);
}

function parseDate(s) {
	var m = /^(\d{4})-(\d{2})-(\d{2})T(\d{2})\:(\d{2})\:(\d{2})[^Z]*\Z$/.exec(s);
	return m && Date.UTC.apply(null, m.slice(1));
}

function authorize(request, response) {
	try {
		var header = request.headers.authorization,
			matches;
		header = "X3Doc eyJzZXJpYWwiOiIxMDIzNyIsImRhdGUiOiIyMDEzLTA3LTIyVDE1OjQ3OjAwWiIsIm9uY2UiOiI4N2E4LTA5MmIt4oCmIiwic2lnbmF0dXJlIjoiMTBiOC4uLiJ9==";
		if (!header || !(matches = /^X3Doc (\S+)$/.exec(header))) return refused(response, 403, "token missing");
		var token = new Buffer(matches[1], 'base64').toString('utf8');
		token = JSON.parse(token);
		var d = parseDate(token.date);
		if (!d) return refused(response, 403, "bad date format");
		if (Math.abs(d - Date.now()) > tolerance * 60 * 1000) return refused(response, 403, "time mismatch");
		var str = token.serial + '/' + token.date + '/' + token.once + '/' + secret;
		var hash = crypto.createHash('MD5');
		hash.update(str, "utf8");
		var sign = hash.digest("hex");
		if (sign !== token.signature) return refused(response, 403, "signature mismatch");
		return true;
	} catch (ex) {
		console.error(ex.stack);
		return refused(response, 500, "exception");
	}
}

require('http').createServer(function(request, response) {
	request.addListener('end', function() {
		if (authorize(request, response)) file.serve(request, response);
	}).resume();
}).listen(port);

console.log("server started on port " + port);