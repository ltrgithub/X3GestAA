var crypto = require('crypto');
var secretkey = 0;

function parseDate(s) {
	// use Ecmascript 5 date extension
	return new Date(s);
}

function refused(response, status, reason) {
	response.writeHead(status, {
		"content-type": "text/plain"
	});
	response.end(reason);
}

function secret(key) {
var x = 0;
var result =""
for (i=0; i<key.length; i++)
result += String.fromCharCode(0x21 + ((x += key.charCodeAt(i)) & 0x3f));
return result;
}

exports.auth = function (request, response, config) {
	try {
		var tolerance = config.tolerance || 5;
		secretkey = secretkey || secret (config.key);
		var header = request.headers.authorization,
			matches;
		if (!header || !(matches = /^X3Doc ([A-Za-z0-9\+=\/]+)$/.exec(header))) return refused(response, 403, "token missing");
		var token = new Buffer(matches[1], 'base64').toString('utf8');
		token = JSON.parse(token);
		var d = parseDate(token.date);
		var now = new Date();
		if (!d) return refused(response, 403, "bad date format");
		if (Math.abs(d - now) > tolerance * 60 * 1000) return refused(response, 403, "time mismatch");
		var str = token.serial + '/' + token.date + '/' + token.once + '/' + secretkey;
		var hash = crypto.createHash('MD5');
		hash.update(str, "utf8");
		var sign = hash.digest("hex");
		if (sign !== token.signature) return refused(response, 403, "signature mismatch");
		return true;
	} catch (ex) {
		console.error(ex.stack);
		return refused(response, 500, "exception");
	}
}