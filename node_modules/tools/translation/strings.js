"use strict";
require('npm-shadow')();

var fs = require('fs');
var os = require('os');
var util = require("util");

var parser = require("esprima-fb/esprima");

var t = {
	SCRIPT: "Program",
	EXPRESSION: "ExpressionStatement",
	ASSIGN: "AssignmentExpression",
	OBJECT: "ObjectExpression",
	PROPERTY: "Property",
	ARRAY: "ArrayExpression",
	UNARY: "UnaryExpression",
	LITERAL: "Literal",
};

// console.log("ANZ "+Object.keys(local).length)
var EOL = os.EOL;
var stringsMap = {};

function toJSON(object, indent) {
	var result = "{" + EOL;
	var indentInner = (indent || "") + "\t";
	var init = true;
	Object.keys(object).sort().forEach(function(key) {
		if (init) init = false;
		else result += "," + EOL;
		result += indentInner + '"' + key + '": ';
		var value = object[key];
		if (value instanceof Object) {
			result += toJSON(value, indentInner);
		} else {
			result += '"' + value.toString().replace(/(["\\])/g, "\\$1").replace(/\n/g, "\\n") + '"';
		}
	});
	// final part
	result += (init ? "" : "" + EOL) + (indent || "") + "}";
	return result;
}

function checkType(parsed, expected) {
	if (parsed.type !== expected) throw new Error("Expected '" + expected + "' got '" + parsed.type + "'");
}

function scanModule(project) {
	console.log("Scanning module " + project);

	// if no strings.js file it is not a syracuse module
	try {
		fs.lstatSync(project + "/lib/strings.js");
	} catch (e) {
		console.log(">>> skiped");
		return;
	}
	var stringsFile = project + "/lib/resources/strings-en.json";
	try {
		fs.lstatSync(stringsFile);
	} catch (e) {
		if (e.code == "ENOENT") {
			stringsFile = "src/collaboration/resources/strings-en.json";
			try {
				fs.lstatSync(stringsFile);
			} catch (e) {
				return;
			}
		} else {
			return;
		}
	}
	var stringsEntry = stringsMap[stringsFile];
	if (!stringsEntry) {
		try {
			stringsEntry = stringsMap[stringsFile] = {
				local: JSON.parse(fs.readFileSync(stringsFile, "utf8")),
				target: {}
			};
		} catch (e) {
			return;
		}
	}
	var local = stringsEntry.local;
	var target = stringsEntry.target;
	console.log("... using local " + stringsFile);

	function file(filepath) {
		var r = /([^\\\/]+\.)_?js$/.exec(filepath);
		if (!r) throw new Error("Wrong path " + filepath);
		var relevant = {};
		var entname = r[1];
		var source = fs.readFileSync(filepath, "utf8");
		var index = 0;
		if (source.indexOf("\n") >= 0) {
			source = source.replace(/\r/g, "");
		}
		r = /^(\s*)exports\.entity\s*\=\s*/m.exec(source);
		if (!r) {
			// console.log("No entity "+filepath);
			return;
		}
		console.log("Entity " + filepath);
		// console.log("ANF "+entname)
		Object.keys(local).forEach(function(item) {
			if (item.indexOf(entname) === 0 && item.length > entname.length) {
				target[item] = relevant[item] = local[item];
			}
		});
		console.log("strings " + Object.keys(target).length + "/" + Object.keys(local).length);
		entname = entname.substr(0, entname.length - 1);
		// console.log("REL "+util.format(relevant))
		index = r.index + r[1].length;
		var result = source.substring(0, index);
		// source = source.replace(/^"use strict";/g, "")
		source = source.substr(index);
		// source = "(function(exports){\n"+source+"})()";
		index = 0;
		// console.error("Start "+util.format(new Buffer(source.substring(0, 300))))
		var parsed = parser.parse(source, filepath);
		checkType(parsed, t.SCRIPT);
		// console.error("root:", parsed.type, util.inspect(parsed));
		parsed = parsed.body[0];
		// console.error("body:", parsed.type, util.inspect(parsed));
		checkType(parsed, t.EXPRESSION);
		/*
	parsed = parsed.expression;
	if (parsed.type !== t.CALL) throw new Error("Wrong type21");
	parsed = parsed.children[0];
	if (parsed.type !== t.FUNCTION) throw new Error("Wrong type22");
	parsed = parsed.body; 
	if (parsed.type !== t.SCRIPT) throw new Error("Wrong type23");
	parsed = parsed.children[0]; 
	if (parsed.type !== t.EXPRESSION) throw new Error("Wrong type24");
	*/
		parsed = parsed.expression;
		// console.error("expression: ", parsed.type, util.inspect(parsed, {depth:3}));
		checkType(parsed, t.ASSIGN);
		parsed = parsed.right;


		function findTitle(parsed, path, next_start0, mode) {
			// console.error("findTitle:", path, parsed.type, util.inspect(parsed));
			// console.error("findTitle:", path, parsed.type);
			checkType(parsed, t.OBJECT);

			for (var i = 0; i < parsed.properties.length; i++) {
				var next_start = (i + 1 < parsed.properties.length ? parsed.properties[i + 1].start : next_start0);
				var child = parsed.properties[i];
				// console.error("\tchild[" + i + "]", child.type, util.inspect(child));
				// console.error("\tchild[" + i + "]", child.type);
				var val;
				if (child.type === t.PROPERTY) {
					var prop = child.value;
					var name = child.key.name;
					// console.error("\t<<prop>>:", name, prop.type, util.inspect(prop));
					// console.error("\t<<prop>>:", name, prop.type);
					switch (prop.type) {
						case t.OBJECT:
							if (name === '$properties' || name === '$relations') {
								findTitle(prop, path, next_start);
							} else {
								findTitle(prop, path + "." + name, next_start);
							}
							break;
						case t.ARRAY:
							if (name === '$enum') {
								var arrChildren = prop.elements;
								for (var j = 0; j < arrChildren.length; j++) {
									var chld = arrChildren[j];
									var next_start1 = (j + 1 < arrChildren.length ? arrChildren[j + 1].start : next_start);
									// console.log("ZZZ "+next_start1+" "+next_start+" "+u[chld.type]);

									var p = findTitle(chld, path, next_start1, 1);
									findTitle(chld, path + "." + p, next_start1, 2);
									// console.log("XXXy "+path+"."+p+"="+q+" ");
									// console.log(chld.end+" "+next_start1+"DANACH <<"+source.substring(chld.end, next_start1)+">>")

								}
							}
							break;
						case t.UNARY:
							try {
								checkType(prop.argument, t.LITERAL);
								val = "" + prop.operator + prop.argument.value;
								if (mode === 1 && name === '$value') {
									return val;
								}
							} catch (e) {
								console.error("XXX " + util.format(child));
								throw e;
							}
							break;
						case t.LITERAL:
							val = prop.value;
							if (mode === 1 && name === '$value' || (typeof(val) === "string" && name === '$default')) {
								return val;
							}
							if (mode !== 1 && typeof(val) !== "string") {
								// console.error(">>>> NOT A STRING:", path + '.' + name, typeof(val), util.format(val));
								return;
							}
							if (mode !== 1 && /^\$\w*(default|description|[Tt]itle|Template)$/.test(name)) {
								// test whether there is translatable content
								var val1 = val;
								var temp;
								var endpos, inbetween;
								// remove all placeholders
								while ((temp = val1.replace(/\{\w+\}/g, "")) !== val1) {
									val1 = temp;
								}
								// console.log("1. "+val+" - "+val1);
								// when only whitespace remains, do not put it into strings-en.json
								if (!/^\s*$/.test(val1)) {
									// console.error("\t<<LITERAL>> tok:", prop.start, prop.end, source.substring(prop.start, prop.end));
									var key;
									if (mode === 2) {
										key = path;
									} else {
										key = path + '.' + name;
									}
									// console.log("XXX "+key+"="+child.children[1].value);
									if (key in relevant) {
										target[key] = relevant[key];
										if (val !== relevant[key]) {
											console.log("  " + key + " in entity: <<" + val + ">>, in strings-en.json: <<" + relevant[key] + ">>");
										}
									} else {
										target[key] = val;
									}

									val = target[key].replace(/\\/g, "\\\\").replace(/"/g, "\\\"");
									endpos = child.end;
									inbetween = source.substring(endpos, next_start);
									if ((r = /^\s*,/.exec(inbetween))) {
										// result += "JJ";
										endpos += r[0].length;
										inbetween = inbetween.substr(r[0].length);
									}
									// result += "<<<<"+val+"|"+inbetween+">>>>"
									if ((r = /^[ \t]*\/\/[ \t]*LOC\:[ \t]*\"((?:\\.|[^"])*)\"[ \t]*/.exec(inbetween))) {
										// result += "$<<"+r[1]+"|"+val+">>$";
										if ((r[1] !== val)) {
											result += source.substring(index, endpos);
											result += ' // LOC: "' + val + '" ';
											result += inbetween.substr(r[0].length);
											index = next_start;
										}
									} else if (/^[ \t]*\/\//.test(inbetween) || /^[ \t]*[\r\n]/.test(inbetween)) {
										result += source.substring(index, endpos);
										result += ' // LOC: "' + val + '" ';
										result += inbetween;
										index = next_start;
									} else { // insert line feed
										var lastSpaces = /([\r\n]\s*)[^\s]*$/.exec(source.substring(index, endpos));
										result += source.substring(index, endpos);
										result += ' // LOC: "' + val + '" ';
										result += lastSpaces ? lastSpaces[1] : EOL;
										result += inbetween;
										index = next_start;
									}
									// console.log(child.end+" "+next_start+"DANACH <<"+source.substring(child.end, next_start)+">>")
								} else
								// entfernen
									endpos = child.end;
								inbetween = source.substring(endpos, next_start);
								var rem = inbetween.replace(/^(\s*,)?[ \t]*\/\/[ \t]*LOC\:[ \t]*\"(?:\\.|[^"])*\"[ \t]*/, "$1");
								if (rem !== inbetween) {
									result += source.substring(index, endpos);
									result += rem;
									index = next_start;
								}
								// console.log("Kein Inhalt "+path+'.'+name+"="+child.children[1].value);
							}
							break;
					}
				}
			}
		}

		findTitle(parsed, entname, source.length);
		result += source.substring(index);
		result = result.replace(/\n/g, EOL);
		// fs.writeFileSync(filepath, result, "utf8");

		// console.log("LLLLL "+result)
		// console.log("LLLLL "+util.format(target))
	}

	function scan(f) {
		var stat = fs.lstatSync(f);
		if (stat.isDirectory()) {
			f += "/";
			if (f.indexOf('/test/') >= 0 || //
				f.indexOf('/dotnet/') >= 0 || //
				f.indexOf('node_modules/tools/') >= 0 || //
				f.indexOf('node_modules/bundles/') >= 0 || //
				f.indexOf('node_modules/aws-sdk/') >= 0 || //
				f.indexOf('node_modules/syracuse-tablet/dist/') >= 0 || //
				f.indexOf('node_modules/syracuse-tablet/html/js/demos/') >= 0 || //				
				f.indexOf('/junk') >= 0) {
				return;
			}
			var files = fs.readdirSync(f);
			files.forEach(function(n) {
				if (n.charAt(0) !== '.') scan(f + n);
			});
		} else if (!stat.isSymbolicLink()) {
			var ext = f.substring(f.lastIndexOf('.')).toLowerCase();
			if (ext === '.js' || ext === '._js') {
				try {
					file(f);
				} catch (e) {
					console.error("ERROR: " + e.stack);
				}
			}
		}
	}
	scan(project);

	// if (scan(project)) { // write strings-en.json
	// 	if (Object.keys(target).length > 0) {
	// 		console.log("rewrite local " + stringsFile + " with " + Object.keys(target).length + " keys");
	// 		fs.writeFileSync(stringsFile, toJSON(target, ""), "utf8");
	// 	}
	// }
}

var root = "node_modules";
fs.readdirSync(root).forEach(function(f) {
	if (f.charAt(0) === '.') return;
	f = root + "/" + f;
	var stat = fs.lstatSync(f);
	if (stat.isDirectory()) {
		scanModule(f);
	}
});

Object.keys(stringsMap).forEach(function(stringsFile) {
	var target = stringsMap[stringsFile].target;
	console.log("rewrite local '" + stringsFile + "'' with " + Object.keys(target).length + " keys vs. " + Object.keys(stringsMap[stringsFile].local).length);
	fs.writeFileSync(stringsFile, toJSON(target, ""), "utf8");
});
