"use strict";

var fs = require('streamline-fs');
var fsp = require("path");
var argo = require("./argo");
var httpsession = require("./httpsession");
var helpers = require('@sage/syracuse-core').helpers;
var localeHelpers = require('@sage/syracuse-core').localeHelpers;
var translationHelpers = require("syracuse-translation/lib/helpers");
var sha1 = translationHelpers.sha1;
var messageStore = require('syracuse-translation/lib/messageStore');
var translation = require('syracuse-translation/lib/translation');
var TranslationProcess = translation.TranslationProcess;
var World = require("./world");
var MessageSet = messageStore.MessageSet;
var dictionary = messageStore.dictionary;
var utils = messageStore.utils;
var defBaseUrl = "http://localhost:8124";

var cwd = process.cwd();
var argv = process.argv.slice(2),
	arg;

var tracer; // = console.error;

// Exemple of use:
// _node node_modules/tools/translation/t9n._js --help
// _node node_modules/tools/translation/t9n._js --get -u erbou -p erbou -d X3INDAMBAS --url http://aws-syrindambas:8124/ --out translation-indexes/messages_10031-10035.txt

function readJson(_, filename) {
	var data = fs.exists(filename, _) && fs.readFile(filename, "utf8", _);
	if (!data) {
		tracer && tracer("data is empty ");
		return {};
	} else {
		try {
			return JSON.parse(data);
			// tracer && tracer("index data " + JSON.stringify(index, null, 2));
		} catch (e) {
			throw new Error("Incorrect Json format: " + filename);
		}
	}
}

function getStamp() {
	return new Date().toISOString().replace(/:/g, "").replace(/T/g, "-").replace(/\..*$/, "");
}

function _quote(t) {
	return "'" + t + "'";
}

var options = argo.parse(argv);
console.log(JSON.stringify(options));

function _auth(opts) {
	var auth = (opts["--auth"] || "").split(":");
	return {
		user: opts["--user"] || auth[0],
		password: opts["--password"] || auth[1]
	};
}

function _baseUrl(opts) {
	return opts["--url"] || opts[Object.keys(opts)[0]] || defBaseUrl;
}
var commandMap = {
	"--merge": {
		syntax: "--merge <resource> <source culture> <dest culture>",
		exec: function merge(_, opts) {
			var mo = opts["--merge"];
			return _mergeJson(_, mo[0], mo[1], mo[2]);
		},
	},
	"--fix-types": {
		syntax: "--fix-types",
		exec: localeHelpers.fixDecimalResources,
	},
	"--update": {
		syntax: "--update (--a <user:password> | ((--user|-u) <user> (--password|-p) <password>)) --url <url> (--input|-i|--) <input file> (--endpoint|-d) <endpoint name>",
		sample: "--update --auth erbou:ERBOU -d X3INDAMBAS -- translation-indexes/messages_10031-10035.txt",
		exec: function update(_, opts) {
			var auth = _auth(opts);
			var endpoint = opts["--endpoint"];
			var input = opts["--input"];
			if (!auth.user || !auth.password)
				usage("user/password are mandatory");
			if (!input)
				usage("input file is mandatory");
			if (!endpoint)
				usage("endpoint is mandatory");

			var baseUrl = _baseUrl(opts);
			var ses = httpsession.create(_, baseUrl, auth.user, auth.password);
			var content = fs.readFileSync(fsp.join(cwd, input), "utf8");
			return _update(_, ses, "/sdata/x3/erp/" + endpoint + "/", content, 10031);
		}
	},
	"--get": {
		syntax: "--get {<url>} (--a <user:password> | ((--user|-u) <user> (--password|-p) <password>)) --url <url> (--endpoint|-d) <endpoint name> --chp <chp1>{..<chp2>} --lan <language> --tstamp <tstamp>",
		sample: "--get http://aws-syrindambas:8124/ -a erbou:ERBOU -d X3INDAMBAS --chp 10031..10032 --lan FRA --tstamp 2010-01-01T00:00:00Z --out translation-indexes/output/messages_@@.txt",
		exec: function get(_, opts) {
			var auth = _auth(opts);
			var endpoint = opts["--endpoint"];
			if (!auth.user || !auth.password)
				usage("user/password are mandatory");
			if (!endpoint)
				usage("endpoint is mandatory");

			var set, data;
			var input = opts["--input"];
			if (input) {
				console.error("Read dictionnary from file: " + input);
				set = new MessageSet();
				data = (fs.readFileSync(fsp.join(cwd, input), "utf8") || "").replace(/\r/g, "");
				set.load(data);
			}

			var chp = ((opts["--chp"] || "10031..10045") + "").split("..");
			var baseUrl = _baseUrl(opts);
			var ses = httpsession.create(_, baseUrl, auth.user, auth.password);
			data = _get(_, ses, "/sdata/x3/erp/" + endpoint + "/", chp[0], chp[1], opts["--lan"], opts["--tstamp"]);
			var out = opts["--out"];
			var fixopt = opts["--fix"];
			set = new MessageSet();
			set.load(data);
			if (fixopt) _fix(_, set, fixopt, {
				endpoint: endpoint,
				chp: chp,
				out: out,
				opts: opts
			});
			var rebuild = opts["--rebuild"];
			if (rebuild) _rebuild(_, set, rebuild, {
				endpoint: endpoint,
				chp: chp,
				out: out,
				opts: opts
			});
			_saveData(_, data, {
				endpoint: endpoint,
				chp: chp,
				out: out,
				opts: opts
			});
		}
	},
	"--gen-dic": {
		syntax: "--gen-dic -- <message file>",
		sample: "--gen-dic -- translation-indexes/output/messages.txt",
		exec: function genDic(_, opts) {
			var input = opts["--input"];
			var content = fs.readFileSync(fsp.join(cwd, input), "utf8");
			var deflang = messageStore.defaultLanguage.x3;
			var re = /(\w+)\t(\d+)\t(\d+)\t(\w+)?\t([\s\S]*?)[\n\r]+/g;
			var unit = {};
			content = content && content.replace(/\r/, "");
			utils.parsePlainContents(content, re, function(chp, id, lan, text, stamp, lanori) {
				if (unit.id != utils.makeKey(chp, id)) {
					unit.values && Object.keys(unit.values).forEach(function(l) {
						if (l === "XXX" && l === deflang)
							return;
						dictionary.smartAssign(unit.key, l, unit.values[l], unit.id);
					});
					unit = {
						id: utils.makeKey(chp, id),
						values: {}
					};
				}
				if (lan === deflang) {
					unit.key = text;
				} else if (lan !== "XXX") {
					if (unit.key)
						dictionary.smartAssign(unit.key, lan, text, unit.id);
					else
						unit.values[lan] = text;
				}
			});
			content = "";
			var data = {}, u;
			dictionary.traverse(function(k, v) {
				Object.keys(v.text).forEach(function(l) {
					u = data[l] = data[l] || (data[l] = {
						content: ""
					});
					if (v.text[l].length > 1) {
						u.content += '"' + k + '":\n';
						// content += "\t[" + l + "]: " + JSON.stringify(v.text[l]) + "\n";
						// u.content += "\t[" + l + "]:\n";
						v.text[l].forEach(function(e) {
							// u.content += '\t\t"' + e[0] + '": ' + JSON.stringify(e[1]) + "\n";
							u.content += '\t"' + e[0] + '": ' + JSON.stringify(e[1]) + "\n";
						});
					}
				});
			});
			Object.keys(data).forEach_(_, function(_, l) {
				var name = "translation-indexes/output/dic-" + l + ".txt";
				console.error("Writing output to " + name);
				fs.writeFile(name, data[l].content, "utf8", _);
			});
		}
	},
	"--index-find": {
		syntax: "--index-find (--key <key> | --text <text>) --lan <lan> --input <index file>",
		sample: "--index-find --key <key> --input",
		exec: function indexFind(_, opts) {
			var input = opts["--input"];
		}
	},
	"--test": {
		exec: function test(_, opts) {
			// var set2 = new MessageSet();
			// set2.init(10031, 1, "ENG", "10031/1/ENG");
			// set2.init(10031, 1, "FRA", "10031/1/FRA");
			// set2.init(10031, 1, "XXX", sha1.hex_sha1("10031/1/XXX"));

			// set2.init(10031, 2, "ENG", "10031/2/ENG");
			// set2.init(10031, 2, "FRA", "10031/2/FRA");
			// set2.init(10031, 2, "XXX", sha1.hex_sha1("10031/1/XXX"));

			// var count = 0;
			// var missingKeys = [];
			// set2.traverse(function(context, chp, id, lan, text, meta) {
			// 	// console.error("traverse :" + JSON.stringify(context) + "\n - " + chp + "/" + id + "/" + lan + ": '" + text + "'");
			// 	if (id == null || chp == null)
			// 		return;
			// 	if (lan == null) {
			// 		!context.$id["XXX"] && missingKeys.push(chp + "/" + id);
			// 		return;
			// 	}
			// 	// console.error("text=" + text);
			// 	if (text != null)
			// 		count++;
			// }, {
			// 	sort: true
			// });
			// console.error("count=" + count + ", missing=" + missingKeys);

			console.error("dir=" + opts["--dir"]);
			console.error("resolved dir=" + fsp.resolve(opts["--dir"]));
			// var dir = fsp.resolve(__dirname, "../../");
			// console.error("walk: " + dir);
			// var visitor;
			// walk(_, dir, visitor = {
			// 	init: function(_) {
			// 		this.$groups = {};
			// 	},
			// 	visitDir: function(_, file, path) {
			// 		// if (/^resources$/.test(file)) {
			// 		// 	console.error("visitDir: " + path);
			// 		// }
			// 		return true;
			// 	},
			// 	visitFile: function(_, file, path) {
			// 		// console.error("visitFile: " + path + "/" + file);
			// 		var m = /(.+\/resources\/[^\/]+)-(\w\w(-\w\w))?.json$/.exec(path);
			// 		var g;
			// 		if (m) {
			// 			g = this.$groups[m[1]] || (this.$groups[m[1]] || {});
			// 			console.error("visitFile: " + m[1].substring(this._rootDir.length + 1) + " " + m[2]);
			// 			this.$resCount = (this.$resCount || 0) + 1;
			// 		}
			// 	},
			// });
			// console.error("count: " + visitor.$resCount);
		}
	},
	"--trans": {
		syntax: "--trans {<url>} (--a <user:password> | ((--user|-u) <user> (--password|-p) <password>)) --url <url> (--endpoint|-d) <endpoint name> --type <type1>{,<type2>, ...} -- dir <sourcedir>",
		sample: "--trans http://aws-syrindambas:8124/ -a erbou:ERBOU -d X3INDAMBAS --op merge,extract --type syracuse --dir /d/workspaces/syracuse",
		exec: function trans(_, opts) {
			var auth = _auth(opts);
			var endpoint = opts["--endpoint"];
			if (!auth.user || !auth.password)
				usage("user/password are mandatory");
			if (!endpoint)
				usage("endpoint is mandatory");

			// var chp = (opts["--chp"] || "10031..10045").split("..");
			var baseUrl = _baseUrl(opts);
			var ses = httpsession.create(_, baseUrl, auth.user, auth.password);

			var world = new World({
				session: ses,
				getUser: function(_) {
					return {
						login: function(_) {
							auth.user;
						}
					};
				}
			});
			var ep = world.getEndpoint(endpoint);
			var tracking = [];
			var rtype = (opts["--type"] || "syracuse,dotnet,admin").split(",");
			var dir = opts["--dir"] || ".";
			var out = opts["--out"];
			var topt = {
				$tracking: tracking,
				// $addDiagnosis:null
				rootpath: dir && fsp.resolve(dir) || "d:/workspaces/syracuse",
				resources: {},
				endpointRead: ep,
				endpointWrite: ep,
				noDBFlush: true,
				// noDBStore: true,
				// renumber: false,
				// resetIndex: false,
				// loadFromIndex: false,
				ignoreIndexEndpoint: true,
				// verify: false,
				ignoreChecksum: true,
				filterAdmin: true,
				useTheir: opts["--use-their"]
			};
			rtype.forEach(function(t) {
				topt.resources[t] = true;
			});
			var tp = new TranslationProcess(_, world, topt);

			var ops = (opts["--op"] || "merge").split(",");
			ops.forEach_(_, function(_, op) {
				var data, set;
				if (op === "merge") {
					tp.updateAll(_);
				} else if (op === "extract") {
					var input = opts["--input"];
					if (input && rtype.length === 1) {
						console.error("Read dictionnary from file: " + input);
						set = new MessageSet();
						data = (fs.readFileSync(fsp.join(cwd, input), "utf8") || "").replace(/\r/g, "");
						set.load(data);
					}
					tp.extractAll(_);
					if (tp.files) {
						console.error("new or modified files:\n" + tp.files.modified.join("\n"));
						console.error("deleted files:\n" + tp.files.deleted.join("\n"));
					}
				} else if (op === "delete") {
					tp.deleteAll(_);
				} else if (op === "rebuild") {
					data = {};
					set = new MessageSet();
					rtype.forEach_(_, function(_, t) {
						var categ = translation.getCategory(t);
						if (!categ) return;
						// Get current texts
						var input = opts["--input"];
						if (input && rtype.length === 1) {
							console.error("Read input from file: " + input);
							data[t] = (fs.readFileSync(fsp.join(cwd, input), "utf8") || "").replace(/\r/g, "");
						} else {
							console.error("Read input from server: ");
							data[t] = _get(_, ses, "/sdata/x3/erp/" + endpoint + "/", categ.$min, categ.$max);
							_saveData(_, data[t], {
								endpoint: endpoint,
								chp: [categ.$min, categ.$max],
								out: out,
								opts: opts
							});
						}
						set.load(data[t]);
					});
					topt.rebuild = true;
					topt.dictionary = messageStore.resetDictionary();
					// topt.dictionary = messageStore.dictionary;
					// 
					tp.extractAll(_);
					if (tp.files) {
						console.error("new or modified files:\n" + tp.files.modified.join("\n"));
						console.error("deleted files:\n" + tp.files.deleted.join("\n"));
					}
				}
				console.error(tracking.map(function(t) {
					return "[" + t.$severity.toUpperCase() + "] " + t.$message + (t.$stackTrace ? " at " + t.$stackTrace : "");
				}).join("\n"));
			});
		}
	},

	"--sql": {
		syntax: "--sql -- <message file>",
		sample: "--sql -- translation-indexes/output/messages.txt",
		exec: function sql(_, opts) {
			var input = opts["--input"];
			var file = fsp.join(cwd, input);
			var content = fs.readFileSync(file, "utf8");
			var deflang = messageStore.defaultLanguage.x3;
			var re = /(\w+)\t(\d+)\t(\d+)\t(\w+)?\t([\s\S]*?)[\n\r]+/g;
			var transformed = "";
			var insert = /-delta/.test(file);
			var count = 0,
				chp1 = 10045,
				chp2 = 10031;
			content = content && content.replace(/\r/, "");
			transformed += "set define off\n";
			transformed += "set feedback off\n";
			transformed += "set termout off\n";
			transformed += "truncate table T$APLSTD;\n";
			transformed += "drop table T$APLSTD;\n";
			transformed += "create global temporary table T$APLSTD on commit preserve rows as select * from APLSTD where 0=1;\n";
			utils.parsePlainContents(content, re, function(chp, id, lan, text, stamp, lanori) {
				if (chp > chp2) chp2 = chp;
				if (chp < chp1) chp1 = chp;
				// if (lan === "XXX") return;
				var qtext = text.replace(/'/g, "''").replace(/\n/g, "\\n");
				// transformed += "call upsert(" + [chp, id, _quote(lan), _quote(lanori || " "), _quote(qtext)].join(",") + ");\n";
				transformed += "insert into t$aplstd (UPDTICK_0,LANCHP_0,LANNUM_0,LAN_0,LANORI_0,LANMES_0,UPDDAT_0,UPDUSR_0,CREUSR_0,CREDAT_0,CREDATTIM_0,UPDDATTIM_0,AUUID_0) ";
				// transformed += "values (" + [1, chp, id, _quote(lan), _quote(lanori || " "), _quote(qtext), "CURRENT_DATE", _quote("ERBOU"), _quote("ERBOU"), "CURRENT_DATE", "CURRENT_TIMESTAMP", "CURRENT_TIMESTAMP", _quote("00000000000000000000000000000000")].join(",") + ");\n";
				transformed += "values (" + [1, chp, id, _quote(lan), _quote(lanori || " "), _quote(qtext), "CURRENT_DATE", _quote("ERBOU"), _quote("ERBOU"), "CURRENT_DATE", "CURRENT_TIMESTAMP", "CURRENT_TIMESTAMP", "sys_guid()"].join(",") + ");\n";
				if ((++count % 500) === 0)
					transformed += "commit;\n";
			});
			if ((count % 500) !== 0)
				transformed += "commit;\n\n";

			transformed += "set feedback on\n";
			transformed += "set termout on\n\n";

			// update existing rows
			var criteria = "t1.lan_0<>'XXX' and t1.lanchp_0=t2.lanchp_0 and t1.lannum_0=t2.lannum_0 and t1.lan_0=t2.lan_0";
			transformed += "update aplstd t1 set (lanmes_0, upddattim_0, UPDDAT_0, UPDUSR_0) = (\n";
			transformed += " select t2.lanmes_0, CURRENT_TIMESTAMP, CURRENT_DATE, 'ERBOU'\n";
			transformed += "   from t$aplstd t2 where " + criteria + ")\n";
			transformed += "  where exists (\n";
			transformed += "          select 1 from t$aplstd t2 WHERE " + criteria + ");\n\n";
			transformed += "commit;\n";

			// insert new rows
			var b1, b2;
			transformed += "insert into aplstd (UPDTICK_0,LANCHP_0,LANNUM_0,LAN_0,LANORI_0,LANMES_0,UPDDAT_0,UPDUSR_0,CREUSR_0,CREDAT_0,CREDATTIM_0,UPDDATTIM_0,AUUID_0)\n";
			transformed += " select 1,LANCHP_0,LANNUM_0,LAN_0,LANORI_0,LANMES_0,CURRENT_DATE,UPDUSR_0,CREUSR_0,CURRENT_DATE,CURRENT_TIMESTAMP,CURRENT_TIMESTAMP,AUUID_0\n";
			transformed += "   from t$aplstd t1\n";
			transformed += "  where (lanchp_0, lannum_0, lan_0) not in (\n";
			transformed += "   select lanchp_0, lannum_0, lan_0\n";
			transformed += "     from aplstd t2\n";
			transformed += "    where t2.lanchp_0 between " + chp1 + " and " + chp2 + ");\n\n";
			transformed += "commit;\n";

			transformed += "truncate table T$APLSTD;\n";
			transformed += "drop table T$APLSTD;\n";

			fs.writeFile(opts["--out"] || file.replace(/\.txt$/, ".sql"), transformed, "utf8", _);
		}
	},

	// "--autofill": function autofill(_, opts) {
	// 	niy("autofill");
	// 	// 	return exports.autoFillIndexes(_);
	// },
	// "--cleanup": function cleanup(_, opts) {
	// 	niy("cleanup");
	// 	// 	return exports.cleanup(_);
	// },
	// "--export": function xport(_, opts) {
	// 	niy("export");
	// 	// 	param = argv[i + 1];
	// 	// 	param = param.charAt(0).toUpperCase() + param.substr(1).toLowerCase();
	// 	// 	return exports["exportTo" + param](_);
	// },
	// "--extract": function extract(_, opts) {
	// 	niy("extract");
	// 	// 	param = argv[i + 1];
	// 	// 	param = param.charAt(0).toUpperCase() + param.substr(1).toLowerCase();
	// 	// 	return exports["extract" + param](_);
	// },
	// "--verify": function verify(_, opts) {
	// 	niy("verify");
	// 	// 	return exports.verify(_);
	// },
	"--compare": {
		syntax: "--compare <file1> <file2>",
		sample: "--compare translation-indexes/messages_10031-10035.txt translation-indexes/output/messages-fetched_10031-10035.txt",
		exec: function compare(_, opts) {
			// console.error("compare:", opts["--compare"][0], opts["--compare"][1]);
			return messageStore.compare(_, opts["--compare"][0], opts["--compare"][1]);
		}
	},
	// "--tmx": function compare(_, opts) {
	// 	niy("compare");
	// // 	return exports.exportToTmx(_, fsp.join(__dirname, argv[i + 1]));
	// },
	"--help": {
		exec: function help() {
			console.log("\nusage: _node " + process.argv[1]);
			console.log("Options:");
			for (var cmd in commandMap) {
				if (/^--/.test(cmd)) {
					console.log("  " + syntax(cmd));
				}
			}
			process.exit(0);
		}
	}
};

// Create aliases
var aliases = {
	commands: {
		"--help": ["-h"],
		"--merge": ["-m"],
	},
	options: {
		"--auth": ["-a"],
		"--user": ["-u"],
		"--password": ["-p"],
		"--endpoint": ["-d"],
		"--input": ["-i", "--"],
	}
};
Object.keys(aliases.commands).forEach(function(k) {
	aliases.commands[k].forEach(function(a) {
		commandMap[a] = commandMap[k];
	});
});
Object.keys(aliases.options).forEach(function(k) {
	aliases.options[k].forEach(function(a) {
		if (options[k] == null) {
			options[k] = options[a];
		}
	});
});

// console.log("\nincluding aliases:\n" + JSON.stringify(options));

function niy(cmd) {
	console.error("NIY: " + cmd);
}

function syntax(cmd) {
	return (commandMap[cmd] || {}).syntax || cmd;
}

function usage(msg) {
	console.error(msg);
	console.error("usage: " + syntax(Object.keys(options)[0]));
	process.exit(-1);
}

function _processCmd(_) {
	var cmd = commandMap[Object.keys(options)[0]];
	cmd && cmd.exec && cmd.exec(_, options);
}

function _mergeJson(_, file, l1, l2) {
	var file1 = file + "-" + l1 + ".json",
		file2 = file + "-" + l2 + ".json",
		fileref = file + "-en.json";

	var jsonRef = readJson(_, fileref),
		json1 = readJson(_, file1),
		json2 = readJson(_, file2),
		json3 = {};

	Object.keys(json1).forEach(function(k) {
		json2[k] = json2[k] || json1[k];
	});

	Object.keys(json2).sort().forEach(function(k) {
		if (jsonRef[k] != null) json3[k] = json2[k];
	});
	fs.writeFile(file2, JSON.stringify(json3, null, "\t"), "utf8", _);
}

var clobRep = "ATRANS";

function _update(_, session, epUrl, data, chp1) {

	function cdoc2(id) {
		return ["$workingCopies('" + id + "')", clobRep, "CONTENTS"].join("/");
	}

	if (!data) return;
	var id = helpers.uuid.generate(),
		url, r, t0, t1;

	data = data.replace(/\r/g, "");

	t0 = t1 = Date.now();
	url = epUrl + clobRep + "('" + chp1 + "~~')/$workingCopies?representation=" + clobRep + ".$edit&trackingId=" + id;
	console.error("Creating workingCopie: " + url);
	var reply = session.post(_, url, "", {
		contentType: "text/plain; charset=utf-8"
	});
	if (session.replyInError(reply))
		return;
	console.error("done in", Date.now() - t1, "ms");

	t1 = Date.now();
	url = epUrl + cdoc2(id);
	// console.log("Updating workingCopie: " + url + "\n" + data);
	console.error("Updating workingCopie: " + url);
	reply = session.put(_, url, data, {
		contentType: "text/plain; charset=utf-8"
	});
	if (session.replyInError(reply))
		return;
	console.error("done in", Date.now() - t1, "ms");

	t1 = Date.now();
	console.error("Saving workingCopie");
	url = epUrl + "$workingCopies('" + id + "')?representation=" + clobRep + ".$edit";
	reply = session.put(_, url, {
		"CHP1": chp1,
		"$actions": {
			"$save": {
				"$isRequested": true
			}
		}
	});
	if (session.replyInError(reply))
		return;
	console.error("done in", Date.now() - t1, "ms");
	console.error("full complete in", Date.now() - t0, "ms");
}

function _get(_, session, epUrl, chp1, chp2, lan, tstamp) {
	var url, t0;

	function cdoc(chp1, chp2, lan, stamp) {
		var key = ["C_" + clobRep, "CONTENTS", chp1 || "", (chp2 || chp1 || ""), (lan || ""), stamp || ""].join("~%C2%A8~");
		return "CDOC('" + key + "')";
	}

	url = epUrl + cdoc(chp1, chp2, lan, tstamp);
	t0 = Date.now();
	console.error("Getting messages: chp1=" + chp1 + ", chp2=" + chp2 + ", lan=" + lan + ", tstamp=" + tstamp);
	var resp = session.get(_, url);
	if (session.replyInError(resp)) {
		return;
	}
	console.error("Done in", Date.now() - t0, "ms");
	return resp.body;
}

function walk(_, rootDir, visitor) {
	visitor = visitor || {};

	function _walk(_, dir, file) {
		var path = fsp.join(dir, file || "").replace(/\\/g, "/"),
			fileInfo;
		tracer && tracer("walk PATH " + path);
		var stat = fs.stat(path, _);
		if (stat.isDirectory()) {
			visitor._currentDir = path;
			if (visitor.visitDir && visitor.visitDir(_, file, path) || !visitor.visitDir) {
				fs.readdir(path, _).forEach_(_, function(_, f) {
					_walk(_, path, f);
				});
			}
			visitor.leaveDir && visitor.leaveDir(_, file, path);
			visitor._currentDir = dir;
		} else {
			visitor.visitFile && visitor.visitFile(_, file, path);
		}
	}

	rootDir = rootDir.replace(/\\/g, "/");
	visitor._rootDir = rootDir;
	visitor.init && visitor.init(_);
	var segments = rootDir.split("/");
	_walk(_, segments.slice(0, -1).join("/"), segments.slice(-1).join("/"));
}

function _fix(_, set, fixopt, opts) {
	opts = opts || {};
	if (typeof(fixopt) ==="string" && !Array.isArray(fixopt))
		fixopt = [fixopt];
	var out = opts.out;
	var lang = fixopt[0];
	var deflang = messageStore.defaultLanguage.x3;
	var lines = [];
	set.traverse(function(context, chp, id, lan, text, meta) {
		if (chp == null || id == null || lan == null)
			return;
		if (lang && lan != lang)
			return;

		// if (chp == 10032 && ([792, 793, 794, 798, 806, 808, 809, 820, 821, 822, 828, 829, 834, 835, 837, 838, 847, 857, 891].indexOf(id) > -1))
		// 	return;


		var loc = context.$id;
		var e = context.$entry;
		var lanori;
		var isPlaceHolder = messageStore.isEqualPlaceHolder(text);
		meta = meta || {};
		if (loc[deflang] == null) {
			// remove obsolete lines
			if (opts.removeObsolete) {
				lines.push(utils.formatLine(chp, id, lan, "--", ""));
				lines.push(utils.formatLine(chp, id, lan, "", ""));
			}
			return;
		} else if (lan === "XXX") {
			return;
		}

		var tref = utils.cleanString(loc[deflang]);
		if ((!text || isPlaceHolder /*|| text === tref*/ ) && lan != deflang && lan != "BRI") {
			// reuse existing translations for non translated texts
			var tmu = dictionary.getEntry(tref),
				proposal;
			if (tmu) {
				if ((proposal = tmu.getText(lan)) != null) {
					if (proposal !== text && proposal !== tref) {
						lanori = "";
						text = proposal;
						isPlaceHolder = false;
					}
				}
			}
		}
		if (!isPlaceHolder) {
			if (utils.varError(loc[deflang], text)) {
				lanori = meta.lanori === deflang ? null : deflang;
			} else if (meta.lanori && text != null && text != loc[meta.lanori]) {
				// set lanori to blank for translated text
				lanori = "";
			}
		} else if (!meta.lanori && text != null && (text === loc[deflang] || isPlaceHolder)) {
			// lines.push(utils.formatLine(chp, id, lan, text, deflang);
		}
		if (lanori != null) {
			lines.push(utils.formatLine(chp, id, lan, text, lanori));
		}

	});
	var file;
	var endpoint = opts.endpoint;
	var chp = opts.chp;

	if (out && out.indexOf("@@")) {
		file = out.replace("@@", endpoint + "-" + chp[0] + (chp[1] ? "-" + chp[1] : "") + "-fix-" + getStamp());
	} else {
		file = "fix-" + (out || (endpoint + "-" + chp[0] + (chp[1] ? "-" + chp[1] : "") + "-" + getStamp()));
	}
	fs.writeFile(file, lines.join("\n"), "utf8", _);
}

function _rebuild(_, set, type, opts) {
	// 1. walk source tree
	// 2. find dictionary entry for the english text
	//    a. if found then write the index entry and add
	//    b. module does not exist then ok
	opts = opts || {};
	var out = opts.out;
	var rtype = (type || "syracuse,dotnet,admin").split(",");
	var dir = opts["--dir"] || ".";
	var indexDir = fsp.join(dir, "translation-indexes");
	var deflang = messageStore.defaultLanguage.x3;
	var set2 = new MessageSet();
	//set2.newEntries(key, 1);
	var map = {};
	set.traverse(function(context, chp, id, lan, text, meta) {
		if (chp == null || id == null || lan == null)
			return;
		var loc = context.$id;
		var e = context.$entry;
		var lanori;
		var isPlaceHolder = messageStore.isEqualPlaceHolder(text);
		meta = meta || {};
		if (loc[deflang] == null) {
			// do not add obsolete texts
			return;
		} else if (lan === "XXX") {
			return;
		}

		var tref = utils.cleanString(loc[deflang]);
		if (lan != deflang) {
			// if ((!text || isPlaceHolder /*|| text === tref*/ ) && lan != deflang && lan != "BRI") {
			// reuse existing translations for non translated texts
			var tmu = dictionary.getEntry(tref),
				proposals, p, v, k;
			if (tmu) {
				// proposals = tmu.getAllTexts(lan);
				proposals = tmu.get(lan);
				if (proposals && proposals.length > 1) {
					context.visited = context.visited || (context.visited = {});
					k = [lan, tref].join("/");
					v = context.visited[k];
					if (!v) {
						console.error("multiple proposal for: " + tref + "[" + lan + "]: " + proposals.join("|"));
						context.visited[k] = true;
					}
					// if (proposal !== text && proposal !== tref) {
					// 	lanori = "";
					// 	text = proposal;
					// 	isPlaceHolder = false;
					// }
				}
			}
		}
		// if (!isPlaceHolder) {
		// 	if (utils.varError(loc[deflang], text)) {
		// 		lanori = meta.lanori === deflang ? null : deflang;
		// 	} else if (meta.lanori && text != null && text != loc[deflang]) {
		// 		// set lanori to blank for translated text
		// 		lanori = "";
		// 	}
		// } else if (!meta.lanori && text != null && (text === loc[deflang] || isPlaceHolder)) {
		// 	// lines.push(utils.formatLine(chp, id, lan, text, deflang);
		// }
		// if (lanori != null) {
		// 	lines.push(utils.formatLine(chp, id, lan, text, lanori));
		// }

	});
	var visitor;
	walk(_, fsp.join(dir, "node_modules"), visitor = {
		init: function(_) {
			this.$groups = {};
		},
		visitDir: function(_, file, path) {
			// if (/^resources$/.test(file)) {
			// 	console.error("visitDir: " + path);
			// }
			return true;
		},
		visitFile: function(_, file, path) {
			// console.error("visitFile: " + path + "/" + file);
			var m = /(.+\/resources\/[^\/]+?)-(\w\w(-\w\w)?).json$/.exec(path);
			var g;
			if (m) {
				g = this.$groups[m[1]] || (this.$groups[m[1]] = {});
				g[m[2]] = path;
				// console.error("visitFile: " + m[1].substring(this._rootDir.length + 1) + " " + m[2]);
				this.$resCount = (this.$resCount || 0) + 1;
			}
		},
	});
	console.error("groups: ", visitor.$groups);
	console.error("count: " + visitor.$resCount);
}

function _reassign(_, set, type, opts) {
	// 1. Traverse the index
	// 2. find if the module still exists
	//    a. module exists then ok
	//    b. module does not exist then ok
	opts = opts || {};
	var out = opts.out;
	// var set = new MessageSet();
	var rtype = (type || "syracuse,dotnet,admin").split(",");
	var dir = opts["--dir"] || ".";
	var indexDir = fsp.join(dir, "translation-indexes");
	rtype.forEach_(_, function(_, t) {
		var indexFile = fsp.join(indexDir, "index" + t + ".json");
		var index = readJson(_, indexFile);
		translationHelpers.traverseIndex(index, function(file, unit, txt) {
			if (!unit) return;
			if (unit[0][0] === "$") return;
			var u = unit[1];
			if (!txt) {
				var entry = set.getByKey(u.$key);
				if (!entry) {
					console.error("ERROR: Entry not found for " + u.$key + " ,code=" + unit[0]);
					return;
				}
			} // if (!entry) {
			// 	console.error("ERROR: Entry not found for " + unit.$key + " ,text=" + txt[1]);
			// 	return;
			// }
			// console.error("traverseIndex: file=" + file + " ,unit=" + unit + ", txt=" + txt);
		});
	});
}

function _saveData(_, data, opts) {
	opts = opts || {};
	var out = opts.out,
		endpoint = opts.endpoint,
		chp = opts.chp || ["#", "#"];
	var lines = [];
	var file = out && out.replace("@@", endpoint + "-" + chp[0] + (chp[1] ? "-" + chp[1] : "") + "-" + getStamp());
	utils.parsePlainContents(data, function(chp, id, lan, text, stamp, lanori) {
		lines.push(utils.formatLine(chp, id, lan, text, lanori));
	});
	if (file) {
		fs.writeFile(file, lines.join("\n"), "utf8", _);
	} else {
		console.log(lines.join("\n"));
	}
}

exports.startCb = function(config, _) {
	// Program start
	_processCmd(_);
	process.exit(0);
};
