"use strict";

var fs = require('streamline-fs');
var fsp = require("path");
var argo = require("./argo");
var httpsession = require("./httpsession");
var helpers = require('syracuse-core/lib/helpers');
var sha1 = require("syracuse-translation/lib/helpers").sha1;
var messageStore = require('syracuse-translation/lib/messageStore');
var MessageSet = messageStore.MessageSet;
var dictionary = messageStore.dictionary;
var utils = messageStore.utils;
var defBaseUrl = "http://localhost:8124";

var argv = process.argv.slice(2),
	arg;

var tracer;

// Exemple of use:
// _node node_modules/tools/translation/t9n._js --help
// _node node_modules/tools/translation/t9n._js --get -u erbou -p erbou -d X3INDAMBAS --url http://aws-syrindambas:8124/ --out translation-indexes/messages_10031-10035.txt

function readJson(_, filename) {
	var data = fs.exists(filename, _) && fs.readFile(filename, "utf8", _);
	if (!data) {
		tracer && tracer("data is empty ");
		return {};
	} else {
		try {
			return JSON.parse(data);
			// tracer && tracer("index data " + JSON.stringify(index, null, 2));
		} catch (e) {
			throw new Error("Incorrect Json format: " + filename);
		}
	}
}

function getStamp() {
	return new Date().toISOString().replace(/:/g, "").replace(/T/g, "-").replace(/\..*$/, "");
}

var options = argo.parse(argv);
console.log(JSON.stringify(options));

function _auth(opts) {
	var auth = (opts["--auth"] || "").split(":");
	return {
		user: opts["--user"] || auth[0],
		password: opts["--password"] || auth[1]
	};
}

function _baseUrl(opts) {
	return opts["--url"] || opts[Object.keys(opts)[0]] || defBaseUrl;
}
var commandMap = {
	"--merge": {
		syntax: "--merge <resource> <source culture> <dest culture>",
		exec: function merge(_, opts) {
			var mo = opts["--merge"];
			return _mergeJson(_, mo[0], mo[1], mo[2]);
		},
	},
	"--fix-types": {
		syntax: "--fix-types",
		exec: function fixTypes(_, opts) {
			var dir = fsp.resolve(__dirname, "../../syracuse-core/lib/types/resources/");
			fs.readdir(dir, _).forEach_(_, function(_, f) {
				var m = /date-(\w\w-\w\w).json/.exec(f);
				var dirty = false;
				if (m) {
					var dest = fsp.join(dir, "decimal-" + m[1] + ".json");
					var content1 = readJson(_, fsp.join(dir, f));
					var content2 = readJson(_, dest);
					if (content2 && Object.keys(content2) > 0) {
						["name", "englishName", "nativeName"].forEach(function(p) {
							if (content2[p] !== content1[p]) {
								dirty = true;
								content2[p] = content1[p];
							}
						});
						if (dirty) {
							fs.writeFile(dest, JSON.stringify(content2, null, "\t"), "utf8", _);
						}
					}
				}
			});
		},
	},
	"--update": {
		syntax: "--update (--a <user:password> | ((--user|-u) <user> (--password|-p) <password>)) --url <url> (--input|-i|--) <input file> (--endpoint|-d) <endpoint name>",
		sample: "--update --auth erbou:ERBOU -d X3INDAMBAS -- translation-indexes/messages_10031-10035.txt",
		exec: function update(_, opts) {
			var auth = _auth(opts);
			var endpoint = opts["--endpoint"];
			var input = opts["--input"];
			if (!auth.user || !auth.password)
				usage("user/password are mandatory");
			if (!input)
				usage("input file is mandatory");
			if (!endpoint)
				usage("endpoint is mandatory");

			var baseUrl = _baseUrl(opts);
			var ses = httpsession.create(_, baseUrl, auth.user, auth.password);
			var cwd = process.cwd();
			var content = fs.readFileSync(fsp.join(cwd, input), "utf8");
			return _update(_, ses, "/sdata/x3/erp/" + endpoint + "/", content, 10031);
		}
	},
	"--get": {
		syntax: "--get {<url>} (--a <user:password> | ((--user|-u) <user> (--password|-p) <password>)) --url <url> (--endpoint|-d) <endpoint name> --chp <chp1>{..<chp2>} --lan <language> --tstamp <tstamp>",
		sample: "--get http://aws-syrindambas:8124/ -a erbou:ERBOU -d X3INDAMBAS --chp 10031..10032 --lan FRA --tstamp 2010-01-01T00:00:00Z --out translation-indexes/output/messages_@@.txt",
		exec: function get(_, opts) {
			var auth = _auth(opts);
			var endpoint = opts["--endpoint"];
			if (!auth.user || !auth.password)
				usage("user/password are mandatory");
			if (!endpoint)
				usage("endpoint is mandatory");

			var chp = (opts["--chp"] || "10031..10045").split("..");
			var baseUrl = _baseUrl(opts);
			var ses = httpsession.create(_, baseUrl, auth.user, auth.password);
			var cwd = process.cwd();
			var data = _get(_, ses, "/sdata/x3/erp/" + endpoint + "/", chp[0], chp[1], opts["--lan"], opts["--tstamp"]);
			var out = opts["--out"];
			var file;
			var lines = [];
			var fixopt = opts["--fix"];
			if (fixopt) {
				if (!Array.isArray(fixopt))
					fixopt = [fixopt];
				var set = new MessageSet();
				set.load(data);
				var lang = fixopt[1];
				var deflang = messageStore.defaultLanguage.x3;
				set.traverse(function(context, chp, id, lan, text, meta) {
					if (chp == null || id == null || lan == null)
						return;
					if (lang && lan != lang)
						return;

					// if (chp == 10032 && ([792, 793, 794, 798, 806, 808, 809, 820, 821, 822, 828, 829, 834, 835, 837, 838, 847, 857, 891].indexOf(id) > -1))
					// 	return;


					var loc = context.$id;
					var e = context.$entry;
					var lanori;
					var isPlaceHolder = messageStore.isEqualPlaceHolder(text);
					meta = meta || {};
					if (loc[deflang] == null) {
						// remove obsolete lines
						lines.push(utils.formatLine(chp, id, lan, "--", ""));
						lines.push(utils.formatLine(chp, id, lan, "", ""));
						return;
					} else if (lan === "XXX") {
						return;
					}

					var tref = utils.cleanString(loc[deflang]);
					if ((!text || isPlaceHolder /*|| text === tref*/ ) && lan != deflang && lan != "BRI") {
						// reuse existing translations for non translated texts
						var tmu = dictionary.getEntry(tref),
							proposal;
						if (tmu) {
							if ((proposal = tmu.getText(lan)) != null) {
								if (proposal !== text && proposal !== tref) {
									lanori = "";
									text = proposal;
									isPlaceHolder = false;
								}
							}
						}
					}
					if (!isPlaceHolder) {
						if (utils.varError(loc[deflang], text)) {
							lanori = meta.lanori === deflang ? null : deflang;
						} else if (meta.lanori && text != null && text != loc[deflang]) {
							// set lanori to blank for translated text
							lanori = "";
						}
					} else if (!meta.lanori && text != null && (text === loc[deflang] || isPlaceHolder)) {
						// lines.push(utils.formatLine(chp, id, lan, text, deflang);
					}
					if (lanori != null) {
						lines.push(utils.formatLine(chp, id, lan, text, lanori));
					}

				});
				if (out && out.indexOf("@@")) {
					file = out.replace("@@", endpoint + "-" + chp[0] + (chp[1] ? "-" + chp[1] : "") + "-fix-" + getStamp());
				} else {
					file = "fix-" + (out || (endpoint + "-" + chp[0] + (chp[1] ? "-" + chp[1] : "") + "-" + getStamp()));
				}
				fs.writeFile(file, lines.join("\n"), "utf8", _);
			}
			file = out && out.replace("@@", endpoint + "-" + chp[0] + (chp[1] ? "-" + chp[1] : "") + "-" + getStamp());
			if (file) {
				lines = [];
				utils.parsePlainContents(data, function(chp, id, lan, text, stamp, lanori) {
					lines.push(utils.formatLine(chp, id, lan, text, lanori));
				});
				fs.writeFile(file, lines.join("\n"), "utf8", _);
			} else {
				console.log(lines.join("\n"));
			}
		}
	},
	"--gen-dic": {
		syntax: "--gen-dic -- <message file>",
		sample: "--gen-dic -- translation-indexes/output/messages.txt",
		exec: function genDic(_, opts) {
			var input = opts["--input"];
			var cwd = process.cwd();
			var content = fs.readFileSync(fsp.join(cwd, input), "utf8");
			var deflang = messageStore.defaultLanguage.x3;
			var re = /(\w+)\t(\d+)\t(\d+)\t(\w+)?\t([\s\S]*?)[\n\r]+/g;
			var unit = {};
			content = content && content.replace(/\r/, "");
			utils.parsePlainContents(content, re, function(chp, id, lan, text, stamp, lanori) {
				if (unit.id != utils.makeKey(chp, id)) {
					unit.values && Object.keys(unit.values).forEach(function(l) {
						if (l === "XXX" && l === deflang)
							return;
						dictionary.smartAssign(unit.key, l, unit.values[l], unit.id);
					});
					unit = {
						id: utils.makeKey(chp, id),
						values: {}
					};
				}
				if (lan === deflang) {
					unit.key = text;
				} else if (lan !== "XXX") {
					if (unit.key)
						dictionary.smartAssign(unit.key, lan, text, unit.id);
					else
						unit.values[lan] = text;
				}
			});
			content = "";
			var keyAdded = false;
			dictionary.traverse(function(k, v) {
				keyAdded = false;
				Object.keys(v.text).forEach(function(l) {
					if (v.text[l].length > 1) {
						if (!keyAdded) {
							content += '"' + k + '":\n';
							keyAdded = true;
						}
						// content += "\t[" + l + "]: " + JSON.stringify(v.text[l]) + "\n";
						content += "\t[" + l + "]:\n";
						v.text[l].forEach(function(e) {
							content += '\t\t"' + e[0] + '": ' + JSON.stringify(e[1]) + "\n";
						});
					}
				});
			});
			fs.writeFile("dic.txt", content, "utf8", _);
		}
	},
	"--index-find": {
		syntax: "--index-find (--key <key> | --text <text>) --lan <lan> --input <index file>",
		sample: "--index-find --key <key> --input",
		exec: function indexFind(_, opts) {
			var input = opts["--input"];
			var cwd = process.cwd();
		}
	},
	"--test": {
		exec: function test(_, opts) {
			var set2 = new MessageSet();
			set2.init(10031, 1, "ENG", "10031/1/ENG");
			set2.init(10031, 1, "FRA", "10031/1/FRA");
			set2.init(10031, 1, "XXX", sha1("10031/1/XXX"));

			set2.init(10031, 2, "ENG", "10031/2/ENG");
			set2.init(10031, 2, "FRA", "10031/2/FRA");
			set2.init(10031, 2, "XXX", sha1("10031/1/XXX"));

			var count = 0;
			var missingKeys = [];
			set2.traverse(function(context, chp, id, lan, text, meta) {
				// console.error("traverse :" + JSON.stringify(context) + "\n - " + chp + "/" + id + "/" + lan + ": '" + text + "'");
				if (id == null || chp == null)
					return;
				if (lan == null) {
					!context.$id["XXX"] && missingKeys.push(chp + "/" + id);
					return;
				}
				// console.error("text=" + text);
				if (text != null)
					count++;
			}, {
				sort: true
			});
			console.error("count=" + count + ", missing=" + missingKeys);
		}
	},
	// "--autofill": function autofill(_, opts) {
	// 	niy("autofill");
	// 	// 	return exports.autoFillIndexes(_);
	// },
	// "--cleanup": function cleanup(_, opts) {
	// 	niy("cleanup");
	// 	// 	return exports.cleanup(_);
	// },
	// "--export": function xport(_, opts) {
	// 	niy("export");
	// 	// 	param = argv[i + 1];
	// 	// 	param = param.charAt(0).toUpperCase() + param.substr(1).toLowerCase();
	// 	// 	return exports["exportTo" + param](_);
	// },
	// "--extract": function extract(_, opts) {
	// 	niy("extract");
	// 	// 	param = argv[i + 1];
	// 	// 	param = param.charAt(0).toUpperCase() + param.substr(1).toLowerCase();
	// 	// 	return exports["extract" + param](_);
	// },
	// "--verify": function verify(_, opts) {
	// 	niy("verify");
	// 	// 	return exports.verify(_);
	// },
	// "--compare": function compare(_, opts) {
	// 	niy("compare");
	// 	// 	return messageStore.compare(_, argv[i + 1], argv[i + 2]);
	// },
	// "--tmx": function compare(_, opts) {
	// 	niy("compare");
	// // 	return exports.exportToTmx(_, fsp.join(__dirname, argv[i + 1]));
	// },
	"--help": {
		exec: function help() {
			console.log("\nusage: _node " + process.argv[1]);
			console.log("Options:");
			console.log("  --autofill");
			console.log("  --cleanup");
			console.log("  --export text");
			console.log("  --extract text");
			console.log("  " + syntax("--merge"));
			console.log("  " + syntax("--update"));
			console.log("  --verify");
			console.log("  --tmx");
			console.log("  --help");
			process.exit(0);
		}
	}
};

// Create aliases
var aliases = {
	"--help": ["-h"],
	"--merge": ["-m"],
	"--auth": ["-a"],
	"--user": ["-u"],
	"--password": ["-p"],
	"--endpoint": ["-d"],
	"--input": ["-i", "--"],
};
Object.keys(aliases).forEach(function(k) {
	aliases[k].forEach(function(a) {
		commandMap[a] = commandMap[k];
		if (options[k] == null) {
			options[k] = options[a];
		}
	});
});

// console.log("\nincluding aliases:\n" + JSON.stringify(options));

function niy(cmd) {
	console.error("NIY: " + cmd);
}

function syntax(cmd) {
	return (commandMap[cmd] || {}).syntax || "";
}

function usage(msg) {
	console.error(msg);
	console.error("usage: " + syntax(Object.keys(options)[0]));
	process.exit(-1);
}

function _processCmd(_) {
	var cmd = commandMap[Object.keys(options)[0]];
	cmd && cmd.exec && cmd.exec(_, options);
}

function _mergeJson(_, file, l1, l2) {
	var file1 = file + "-" + l1 + ".json",
		file2 = file + "-" + l2 + ".json",
		fileref = file + "-en.json";

	var jsonRef = readJson(_, fileref),
		json1 = readJson(_, file1),
		json2 = readJson(_, file2),
		json3 = {};

	Object.keys(json1).forEach(function(k) {
		json2[k] = json2[k] || json1[k];
	});

	Object.keys(json2).sort().forEach(function(k) {
		if (jsonRef[k] != null) json3[k] = json2[k];
	});
	fs.writeFile(file2, JSON.stringify(json3, null, "\t"), "utf8", _);
}

var clobRep = "ATRANS";

function _update(_, session, epUrl, data, chp1) {

	function cdoc2(id) {
		return ["$workingCopies('" + id + "')", clobRep, "CONTENTS"].join("/");
	}

	if (!data) return;
	var id = helpers.uuid.generate(),
		url, r, t0, t1;

	data = data.replace(/\r/g, "");

	t0 = t1 = Date.now();
	url = epUrl + clobRep + "('" + chp1 + "~~')/$workingCopies?representation=" + clobRep + ".$edit&trackingId=" + id;
	console.error("Creating workingCopie: " + url);
	var reply = session.post(_, url, "", {
		contentType: "text/plain; charset=utf-8"
	});
	if (session.replyInError(reply))
		return;
	console.error("done in", Date.now() - t1, "ms");

	t1 = Date.now();
	url = epUrl + cdoc2(id);
	// console.log("Updating workingCopie: " + url + "\n" + data);
	console.error("Updating workingCopie: " + url);
	reply = session.put(_, url, data, {
		contentType: "text/plain; charset=utf-8"
	});
	if (session.replyInError(reply))
		return;
	console.error("done in", Date.now() - t1, "ms");

	t1 = Date.now();
	console.error("Saving workingCopie");
	url = epUrl + "$workingCopies('" + id + "')?representation=" + clobRep + ".$edit";
	reply = session.put(_, url, {
		"CHP1": chp1,
		"$actions": {
			"$save": {
				"$isRequested": true
			}
		}
	});
	if (session.replyInError(reply))
		return;
	console.error("done in", Date.now() - t1, "ms");
	console.error("full complete in", Date.now() - t0, "ms");
}

function _get(_, session, epUrl, chp1, chp2, lan, tstamp) {
	var url, t0;

	function cdoc(chp1, chp2, lan, stamp) {
		var key = ["C_" + clobRep, "CONTENTS", chp1 || "", (chp2 || chp1 || ""), (lan || ""), stamp || ""].join("~%C2%A8~");
		return "CDOC('" + key + "')";
	}

	url = epUrl + cdoc(chp1, chp2, lan, tstamp);
	t0 = Date.now();
	console.error("Getting messages: chp1=" + chp1 + ", chp2=" + chp2 + ", lan=" + lan + ", tstamp=" + tstamp);
	var resp = session.get(_, url);
	if (session.replyInError(resp)) {
		return;
	}
	console.error("Done in", Date.now() - t0, "ms");
	return resp.data;
}

function walk(_, rootDir, visitor) {
	visitor = visitor || {};

	function _walk(_, dir, file) {
		var path = fsp.join(dir, file || ""),
			fileInfo;
		tracer && tracer("walk PATH " + path);
		var stat = fs.stat(path, _);
		if (stat.isDirectory()) {
			if (visitor.visitDir && visitor.visitDir(file, path, rootDir) || !visitor.visitDir) {
				fs.readdir(path, _).forEach_(_, function(_, f) {
					_walk(_, path, f);
				});
			}
			visitor.leaveDir && visitor.leaveDir(file, path, rootDir);
		} else {
			visitor.visitFile && visitor.visitFile(file, path, rootDir);
		}
	}

	rootDir = rootDir.replace(/\\/g, "/");
	var segments = rootDir.split("/").slice(-1);
	_walk(_, segments.slice(0, -1), segments.slice(-1));
}

// Program start
_processCmd(_);
process.exit(0);
