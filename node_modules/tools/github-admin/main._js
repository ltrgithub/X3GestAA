"use strict";

const os = require('os');
const fs = require('streamline-fs');
const fsp = require('path');
const yaml = require('js-yaml');
const colors = require('colors/safe');
const GitHub = require('./github').GitHub;
const GitCommander = require('./github').GitCommander;
const helper = require('./helper');

var gh, config;
const log = helper.log;

function loadFile(_, file, desc, format) {
	desc = desc || "";
	try {
		file = fsp.normalize(fsp.resolve(file));
		format = format || fsp.extname(file).toLowerCase().substring(1);
		// log("file: " + file);
		// log("format: " + format);
		if (!fs.exists(file, _)) throw new Error(desc + " file does not exist: " + file);
		var data = fs.readFile(file, 'utf8', _);
		switch (format) {
			case "yml":
			case "yaml":
				return yaml.safeLoad(data);

			case "json":
				return JSON.parse(data);

			default:
				return data;
		}
	} catch (e) {
		log(e.message, "red");
	}
}

function sortMember(a, b) {
	if (a === b)
		return 0;
	var la = (a || "").toLowerCase();
	var lb = (b || "").toLowerCase();
	var na = la.replace(/-/g, "");
	var nb = lb.replace(/-/g, "");
	var ca = na,
		cb = nb;
	if (ca === cb) {
		ca = la;
		cb = lb;
	}
	// the lsm tool seems to sort lines and not only keys, so we add ":" to have the same order
	var ca = ca + ":",
		cb = cb + ":";
	if (ca === cb) {
		log("member name differs only by case: " + a + " / " + b, "yellow");
		ca = a + ":";
		cb = b + ":";
	}
	return ca > cb ? 1 : -1;
}

function MembersMap(_, file, gh) {
	var membersMap = loadFile(_, file, "Active directory reconcilling");
	log("Members loaded: " + Object.keys(membersMap).length);

	var index = Object.keys(membersMap).reduce(function(r, k) {
		var lk = k.toLowerCase();
		if (r[lk]) {
			log("duplicated member: " + k + " / " + r[lk].name + " [" + membersMap[k] + "]");
			return r;
		}
		r[lk] = {
			name: k,
			email: membersMap[k]
		};
		return r;
	}, {});

	this.addMembers = function(_, members, pendings) {
		var result = {
			added: 0,
			invited: 0
		};
		members && Object.keys(members).forEach_(_, function(_, k) {
			var lk = k.toLowerCase();
			var mship = gh.checkMembership(_, k);

			var toAdd = mship.isMember || pendings[lk];
			// log("===> " + k + "=" + members[k] + " - isMember=" + mship.isMember);
			if (!toAdd) {
				var user = gh.getUser(_, lk);
				if (user && (user.login || "").toLowerCase() === lk) {
					log("to invite member: " + k + "[" + members[k] + "]", "yellow");
					var resp = gh.addMember(_, k);
					if (resp.status === 200) {
						result.invited++;
						toAdd = true;
						log("member invited: " + k + "[" + members[k] + "] - " + resp.data.state, "yellow");
					}
				} else {
					log("account does not exist: " + k + " [" + members[k] + "]", "red");
				}
			}
			if (index[lk]) {
				log("member already exists: " + k + " / " + index[lk].name + " [" + index[lk].email + "]", "yellow");
				return;
			}
			if (toAdd) {
				result.added++;
				membersMap[k] = members[k];
				log("adding member: " + k + "[" + members[k] + "]");
			}
		});
		return result;
	};

	this.save = function(_, toFile) {
		toFile = toFile || file;
		var dump = yaml.safeDump(membersMap, {
			'sortKeys': sortMember
		});
		if (dump.indexOf("\r") < 0)
			dump = dump.replace(/\n/g, os.EOL);
		else if (dump.indexOf("\n") < 0)
			dump = dump.replace(/\r/g, os.EOL);

		fs.writeFile(toFile, dump, "utf8", _);
		log("Members saved: " + Object.keys(membersMap).length);
	};
}

function Pendings(_, gh) {
	var pendings;

	this.getMap = function() {
		return pendings.reduce(function(r, e) {
			if (e.role != "billing_manager") {
				r[e.login.toLowerCase()] = e;
			}
			return r;
		}, {});
	};

	this.toString = function() {
		return pendings.reduce(function(r, e) {
			if (e.role != "billing_manager") {
				r += "\n- " + e.login + " [" + e.email + "] invited by " + e.inviter.login;
			}
			return r;
		}, "");
	};

	this.refresh = function(_) {
		return pendings = gh.pendingInvitations(_);
	};

	this.refresh(_);
}

var config = loadFile(_, __dirname + "/config.yml", "Config");
var newMembers = loadFile(_, __dirname + "/data/members-to-add.yml", "Members");
// log("members to add:" + JSON.stringify(newMembers, null, "\t") + "\n");

var gh = new GitHub(config);

var git = new GitCommander(config.lsm.dir);

function execGitCommands(commands, next) {
	var cmd = commands[0];
	if (!cmd)
		return next ? next() : process.exit(0);

	log("> Executing... git " + cmd.join(" "));
	git.exec(cmd[0], cmd.slice(1), function(error, stdout, stderr) {
		log(stdout);
		execGitCommands(commands.slice(1), next);
	});
}

function inviteSync() {
	(function(_) {
		var pendings = new Pendings(_, gh);

		var pendingMap = pendings.getMap();
		log("Current pending invitations:" + pendings.toString() + "\n");

		var membersMap = new MembersMap(_, fsp.join(config.lsm.dir, config.lsm.github.file), gh);
		var addResult = membersMap.addMembers(_, newMembers, pendingMap);
		membersMap.save(_);

		pendings.refresh(_);
		log("\nPending invitations:" + pendings.toString());

		log("\nMembers invited: " + addResult.invited);
		log("Members added: " + addResult.added);

		var cmds = [];
		if (addResult.added > 0) {
			log("\nPropagate changes to lsm git repo\n");
			cmds = cmds.concat([
				["diff", "-U1"],
				["commit", "-a", "-m", '"add X3 users"'],
				["pull", "--rebase"],
				["status", "-sb"],
				["push"],
			]);
		} else {
			log("\nNo change, cleanup lsm repo\n");
			cmds = cmds.concat([
				["checkout", "."],
				["clean", "-ffd"],
				["status", "-sb"],
			]);
		}

		if (cmds.length > 0)
			execGitCommands(cmds);

	})(function(err) {
		if (err) console.error(err);
	});
}

function start() {
	execGitCommands([
		["checkout", "."],
		["clean", "-ffd"],
	], inviteSync);
}

start();