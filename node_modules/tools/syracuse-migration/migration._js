"use strict";

var config = require("../../../nodelocal").config || {};
var path = require('path');
var uuid = require('syracuse-core').uuid;
var fs = require('streamline-fs');
var utils = require('./utils');
var yaml = require('js-yaml');
var mongo = require('./mongo');

var config;
function loadConfig(_, ymlFile) {
	try {
		if (!fs.exists(ymlFile, _)) throw new Error("Config file does not exist: "+ymlFile);
		config = yaml.safeLoad(fs.readFile(ymlFile, 'utf8', _));
		//utils.log("Config: "+JSON.stringify(config,null,2));
	} catch(e) {
		utils.log(e.message, "red");
	}
}

function mongodump() {
	utils.log("*************** Mongo dump operation ***************", "cyan");
	if (config.mongodb && config.mongodb.out && config.mongodb.source) {
		config.mongodb.source.out = config.mongodb.out;
		mongo.dump(path.join(config.mongodb.path, "bin/mongodump"), config.mongodb.source, genFilePath("mongodump", "log"));
	} else {
		utils.log("Can't execute mongodump step because mongodb.out or mongodb.source are missing", "magenta");
	}
}

function mongorestore() {
	utils.log("*************** Mongo restore operation ***************", "cyan");
	if (config.mongodb && config.mongodb.out && config.mongodb.destination) {
		config.mongodb.destination.path = path.join(config.mongodb.out, config.mongodb.source.db);
		// set drop parameter to true
		config.mongodb.destination.drop = config.mongodb.destination.drop != null ? config.mongodb.destination.drop : true;
		mongo.restore(path.join(config.mongodb.path, "bin/mongorestore"), config.mongodb.destination, genFilePath("mongorestore", "log"));
	} else {
		utils.log("Can't execute mongorestore step because mongodb.out or mongodb.destination are missing", "magenta");
	}
}

function updateX3Solutions(_) {
	utils.log("*************** X3 solution transformations ***************", "cyan");
	config.x3solutions && config.x3solutions.forEach_(_, function(_, s) {
		var oldSolName = s.solutionToModify;
		var old = client.find(_, "X3solution", {"code": oldSolName});
		if (old && old.length) {
			old = old[0];
			s = s.newSolution;
			old.code = s.code != null ? s.code : old.code;
			old.description = s.description != null ? {default:s.description} : old.description;
			old.solutionName = s.solutionName != null ? s.solutionName : old.solutionName;
			old.serverHost = s.serverHost != null ? s.serverHost : old.serverHost;
			old.serverPort = s.serverPort != null ? s.serverPort : old.serverPort;
			old.serverTimeout = s.serverTimeout != null ? s.serverTimeout : old.serverTimeout;
			old.webServer = s.webServer != null ? s.webServer : old.webServer;
			old.webServerPort = s.webServerPort != null ? s.webServerPort : old.webServerPort;
			old.proxy = s.proxy != null ? s.proxy : old.proxy;
			
			// add new runtimes configuration
			old.runtimes = [];
			s.runtimes.forEach(function(r, idx) {
				
				if (!r.serverHost || !r.serverPort) {
					utils.log("WARN: Runtime ["+idx+"] of new solution ["+s.solutionName+"] has been ignored because 'host' or 'port' are not provided !!!", "yellow");
				} else {
		            r.tag = r.tag || "";
		            r.exclusive = r.exclusive != null ? r.exclusive : false;
		            r.banTimeout = r.banTimeout || 60;
		            r.banned = r.banned != null ? r.banned : false;
		            r.disabled = r.disabled != null ? r.disabled : false;
		            r.errorTry = 0;
		            r.autoConfig = false;
		            r._uuid = uuid.generate('-');
		            old.runtimes.push(r);
				}
			});
			
			// check MAIN tag is correctly set
			if (s.runtimes && s.runtimes.length && !s.runtimes.some(function(r) {
				return r.tag !== null;
			})) {
				s.runtimes[0].tag = "MAIN";
				console.log("WARN: No MAIN tag detected on every runtimes of the new solution '"+s.solutionName+"'. So first runtime has been assign with MAIN tag automatically", "yellow");
			}
			
			client.update(_, "X3solution", {_id: old._id}, old);
			utils.log("INFO: Solution '" + oldSolName + "' updated with new configuration '" + s.solutionName + "'...", "green");
		} else {
			utils.log("ERROR: Old X3 solution '" + oldSolName + "' not found. New configuration has been ignored...", "red");
		}

	});
}

function updateHost(_) {
	var h = config.host;
	utils.log("*************** Host instance transformation ***************", "cyan");
	if (config.host && config.host.oldHostname && h.hostname && h.tcpHostName) {
		var regex = new RegExp(["^", h.oldHostname, "$"].join(""), "i");
		var old = client.find(_, "Host", {"hostname": regex});
		if (old && old.length) {
			old = old[0];
			old.hostname = h.hostname;
			old.tcpHostName = h.tcpHostName;
			old.children = h.children != null ? h.children : old.children;
			old.wsChildren = h.wsChildren != null ? h.wsChildren : old.wsChildren;
			old.started = false;
			//
			client.update(_, "Host", {_id: old._id}, old);
			utils.log("INFO: Host '" + config.host.oldHostname + "' updated with new configuration '" + h.hostname + "'...", "green");
			//
			removeHostCertificate(_, config.host.oldHostname);
		} else {
			utils.log("ERROR: Old host configuration for '" + h.oldHostname + "' not found. New configuration has been ignored...", "red");
		}
	} else {
		utils.log("ERROR: 'config.host' section have to be defined... 'oldHostname', 'hostname' and 'tcpHostName' properties are mandatory to change Host instance settings", "magenta");
	}
}

function removeHostCertificate(_, oldHostname) {
	var nb = client.remove(_, "Certificate", {"name":oldHostname});
	utils.log("INFO: Old certificate for host '" + oldHostname + "' deleted: " + nb, "green");
}

function genFilePath(filename, extension) {
	var d = new Date();
	return path.join(__dirname, filename + '_' + d.getFullYear() + '-' + d.getMonth() + '-' + d.getDay() + '.' + extension);
}

var client;
var mode = process.argv.length > 2 ? process.argv[2] : "--config";

switch(mode) {
	case "--config":
		var ymlFile = path.join(__dirname, "config.yml");
		if (process.argv[3] && process.argv[2] !== "") ymlFile = process.argv[3];
		utils.logSection(["Starting Migration tool using YAML configuration file:" , ymlFile], "magenta");
		//console.log(yaml.safeDump(jsonconfig));
		
		
		try {
			loadConfig(_, ymlFile);
			mongodump();
			mongorestore();
			
			client = new mongo.Client(config.mongodb.destination).connect(_);
			updateX3Solutions(_);
			updateHost(_);
		
		} catch(e) {
			console.error(e);
		} finally {
			if (client) client.close();
		}
		break;
	default:
		utils.log("Bad parameter\nUsage:", "yellow");
		utils.log("node node_modules/tools/syracuse-migration [param]", "yellow");
		utils.log("param can be:", "yellow");
		utils.log("\t`--config` to specify yaml configuration file full path", "yellow");
		
		break;
}


process.exit();