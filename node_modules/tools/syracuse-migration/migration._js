"use strict";

var config = require("../../../nodelocal").config || {};
var path = require('path');
var uuid = require('@sage/syracuse-core').uuid;
var fs = require('streamline-fs');
var utils = require('./utils');
var yaml = require('js-yaml');
var mongo = require('./mongo');

var config;
function loadConfig(_, ymlFile) {
	try {
		if (!fs.exists(ymlFile, _)) throw new Error("Config file does not exist: "+ymlFile);
		config = yaml.safeLoad(fs.readFile(ymlFile, 'utf8', _));
		//utils.log("Config: "+JSON.stringify(config,null,2));
	} catch(e) {
		utils.log(e.message, "red");
	}
}

function mongodump() {
	utils.log("\n*************** Mongo dump operation begin***************", "cyan");
	if (config.mongodb && config.mongodb.out && config.mongodb.source) {
		config.mongodb.source.out = config.mongodb.out;
		mongo.dump(path.join(config.mongodb.path, "bin/mongodump"), config.mongodb.source, genFilePath("mongodump", "log"));
	} else {
		throw new Error("Can't execute mongodump step because mongodb.out or mongodb.source are missing");
	}
	utils.log("*************** Mongo dump operation ended***************", "cyan");
}

function mongorestore() {
	utils.log("\n*************** Mongo restore operation begin***************", "cyan");
	if (config.mongodb && config.mongodb.out && config.mongodb.destination) {
		config.mongodb.destination.path = path.join(config.mongodb.out, config.mongodb.source.db);
		// set drop parameter to true
		config.mongodb.destination.drop = config.mongodb.destination.drop != null ? config.mongodb.destination.drop : true;
		mongo.restore(path.join(config.mongodb.path, "bin/mongorestore"), config.mongodb.destination, genFilePath("mongorestore", "log"));
	} else {
		utils.log("Can't execute mongorestore step because mongodb.out or mongodb.destination are missing", "magenta");
	}
	utils.log("*************** Mongo restore operation ended***************", "cyan");
}

function updateX3Solutions(_) {
	utils.log("\n*************** X3 solution transformations begin ***************", "cyan");
	config.x3solutions && config.x3solutions.forEach_(_, function(_, s) {
		var oldSolName = s.solutionToModify;
		var old = client.find(_, "X3solution", {"code": oldSolName});
		if (old && old.length) {
			old = old[0];
			s = s.newSolution;
			old.code = s.code != null ? s.code : old.code;
			old.description = s.description != null ? {default:s.description} : old.description;
			old.solutionName = s.solutionName != null ? s.solutionName : old.solutionName;
			old.serverHost = s.serverHost != null ? s.serverHost : old.serverHost;
			old.serverPort = s.serverPort != null ? s.serverPort : old.serverPort;
			old.serverTimeout = s.serverTimeout != null ? s.serverTimeout : old.serverTimeout;
			old.webServer = s.webServer != null ? s.webServer : old.webServer;
			old.webServerPort = s.webServerPort != null ? s.webServerPort : old.webServerPort;
			old.proxy = s.proxy != null ? s.proxy : old.proxy;
			
			// add new runtimes configuration
			old.runtimes = [];
			s.runtimes.forEach(function(r, idx) {
				
				if (!r.serverHost || !r.serverPort) {
					utils.log("WARN: Runtime ["+idx+"] of new solution ["+s.solutionName+"] has been ignored because 'host' or 'port' are not provided !!!", "yellow");
				} else {
		            r.tag = r.tag || "";
		            r.exclusive = r.exclusive != null ? r.exclusive : false;
		            r.banTimeout = r.banTimeout || 60;
		            r.banned = r.banned != null ? r.banned : false;
		            r.disabled = r.disabled != null ? r.disabled : false;
		            r.errorTry = 0;
		            r.autoConfig = false;
		            r._uuid = uuid.generate('-');
		            old.runtimes.push(r);
				}
			});
			
			// check MAIN tag is correctly set
			if (s.runtimes && s.runtimes.length && !s.runtimes.some(function(r) {
				return r.tag !== null;
			})) {
				s.runtimes[0].tag = "MAIN";
				console.log("WARN: No MAIN tag detected on every runtimes of the new solution '"+s.solutionName+"'. So first runtime has been assign with MAIN tag automatically", "yellow");
			}
			
			client.update(_, "X3solution", {_id: old._id}, old);
			utils.log("INFO: Duplicated solution '" + oldSolName + "' has been updated with new configuration '" + s.solutionName + "'...", "green");
		} else {
			utils.log("ERROR: Old X3 solution '" + oldSolName + "' not found. New configuration has been ignored...", "red");
		}

	});
	utils.log("*************** X3 solution transformations ended ***************", "cyan");
}

function updateEndpoints(_, endpoints) {
	utils.log("\n*************** Endpoints transformations begin ***************", "cyan");
	endpoints = endpoints || config.endpoints || [];
	config.endpoints && config.endpoints.forEach_(_, function(_, e) {
		var oldEpName = e.endpointToModify;
		var old = client.find(_, "EndPoint", {"dataset": oldEpName});
		if (old && old.length) {
			old = old[0];
			e = e.newEndpoint;
			old.dataset = e.dataset != null ? e.dataset : old.dataset;
			old.description = e.description != null ? {default:e.description} : old.description;
			old.x3ServerFolder = e.x3ServerFolder != null ? e.x3ServerFolder : old.x3ServerFolder;
			old.x3ParentFolder = e.x3ParentFolder != null ? e.x3ParentFolder : old.x3ParentFolder;
			old.helpBaseUrl = e.helpBaseUrl != null ? e.helpBaseUrl : old.helpBaseUrl;
			
			// for syracuse endpoints
			old.localDatabase = e.localDatabase != null ? e.localDatabase : old.localDatabase;
			old.databaseDriver = e.databaseDriver != null ? e.databaseDriver : old.databaseDriver;
			old.databaseHost = e.databaseHost != null ? e.databaseHost : old.databaseHost;
			old.databasePort = e.databasePort != null ? e.databasePort : old.databasePort;
			old.databaseName = e.databaseName != null ? e.databaseName : old.databaseName;
			
			
			
			client.update(_, "EndPoint", {_id: old._id}, old);
			utils.log("INFO: Duplicated endpoint '" + oldEpName + "' has been updated with new configuration '" + e.dataset + "'...", "green");
		} else {
			utils.log("ERROR: Old Endpoint '" + oldEpName + "' not found. New configuration has been ignored...", "red");
		}
	});
	utils.log("*************** Endpoints transformations ended ***************", "cyan");
}


function updateHost(_) {
	utils.log("\n*************** Hosts instances transformation begin ***************", "cyan");
	config.hosts && config.hosts.forEach_(_, function(_, h) {
		if (h && h.hostnameToModify && h.hostname && h.tcpHostName) {
			var regex = new RegExp(["^", h.hostnameToModify, "$"].join(""), "i");
			var old = client.find(_, "Host", {"hostname": regex});
			if (old && old.length) {
				old = old[0];
				old.hostname = h.hostname;
				old.tcpHostName = h.tcpHostName != null ? h.tcpHostName : old.tcpHostName;
				old.children = h.children != null ? h.children : old.children;
				old.wsChildren = h.wsChildren != null ? h.wsChildren : old.wsChildren;
				old.started = false;
				//
				client.update(_, "Host", {_id: old._id}, old);
				utils.log("INFO: Duplicated host '" + h.hostnameToModify + "' has been updated with new configuration '" + h.hostname + "'...", "green");
				//
				removeHostCertificate(_, h.hostnameToModify);
			} else {
				utils.log("ERROR: Old host configuration for '" + h.hostnameToModify + "' not found. New configuration has been ignored...", "red");
			}
		} else {
			utils.log("ERROR: 'config.host' section have to be defined correctly... 'hostnameToModify', 'hostname' and 'tcpHostName' properties are mandatory to change Host instance settings", "magenta");
		}
	});
	utils.log("*************** Hosts instances transformation ended ***************", "cyan");
}

function updateCollaborationEndpoint(_) {
	utils.log("\n*************** Modify collaboration endpoint begin ***************", "cyan");
	var ep = client.find(_, "EndPoint", {"application": "syracuse", "contract": "collaboration", "dataset": "syracuse"});
	if (ep || ep.length) {
		ep = ep[0];
		ep.databaseHost = config.mongodb.destination.host;
		ep.databasePort = config.mongodb.destination.port;
		client.update(_, "EndPoint", {_id: ep._id}, ep);
	}
	else {
		throw new Error("Collaboration endpoint not found ! Please check on source server that the following endpoint exists: 'application': 'syracuse', 'contract': 'collaboration', 'dataset': 'syracuse'}");
	}

	utils.log("*************** Modify collaboration endpoint ends ***************", "cyan");
}

function removeHostCertificate(_, hostnameToModify) {
	var h = hostnameToModify.toLowerCase();
	utils.log("\n*************** Delete certificates begin ***************", "cyan");
	var nb = client.remove(_, "Certificate", {"name":h});
	utils.log("INFO: Old certificate for host '" + h + "' deleted: " + JSON.stringify(nb), "green");
	utils.log("WARN: New certificates will be imported when starting your Syracuse server.", "yellow");
	utils.log("WARN: ATTENTION: Your new certificates needs to be generated on destination server, and passphrase has to be inserted.", "yellow");
	utils.log("*************** Delete certificates ended ***************", "cyan");
}

function genFilePath(filename, extension) {
	var d = new Date();
	var logsDir = config.logsDir || '.';
	var p;
	if(path.isAbsolute(logsDir)) {
	   p = logsDir;
	} else {
		p = path.join(__dirname, logsDir);
	}
	return path.join(p, filename + '_' + d.toISOString().replace(/:/g, '-') + '.' + extension);
}

try {
	var client;
	var mode = process.argv.length > 2 ? process.argv[2] : "--config";
	
	switch(mode) {
		case "--config":
			var ymlFile = path.join(__dirname, "config.yml");
			if (process.argv[3] && process.argv[2] !== "") ymlFile = process.argv[3];
			utils.logSection(["Starting Migration tool using YAML configuration file:" , ymlFile], "magenta");

			try {
				loadConfig(_, ymlFile);
				mongodump();
				mongorestore();
				
				client = new mongo.Client(config.mongodb.destination).connect(_);
				updateCollaborationEndpoint(_);	
				updateX3Solutions(_);
				updateEndpoints(_);
				updateHost(_);

			} finally {
				if (client) client.close();
			}
			break;
		default:
			utils.log("Bad parameter\nUsage:", "yellow");
			utils.log("node node_modules/tools/syracuse-migration [param]", "yellow");
			utils.log("param can be:", "yellow");
			utils.log("\t`--config` to specify yaml configuration file full path", "yellow");
			
			break;
	}
} catch(e) {
	utils.log(e.stack, "red");
	process.exit(-1);
}

process.exit(0);