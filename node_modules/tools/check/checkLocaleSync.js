"use strict";

var fs = require('fs');
var path = require('path');
var util = require('util');
var RESOURCE_CHANGED = ">>>"; // dummy entry for strings resources to indicate that contents have changed

//formatted output of object in JSON format. All values will be converted to strings unless they are objects
function toJSON(object, indent) {
	var result = "{\n";
	var indentInner = (indent || "") + "\t";
	var init = true;
	Object.keys(object).sort().forEach(function(key) {
		if (key === RESOURCE_CHANGED) return;
		if (init) init = false;
		else result += ",\n";
		result += indentInner + '"' + key + '": ';
		var value = object[key];
		if (value instanceof Object) {
			result += toJSON(value, indentInner);
		} else {
			result += '"' + value.toString().replace(/(["\\])/g, "\\$1") + '"';
		}
	});
	// final part
	result += (init ? "" : "\n") + (indent || "") + "}";
	return result;
}

// the function converts strings with `$#$` in it into localized messages and checks whether there are localized messages with errors.
// Parameters:
// content: content of file (as string)
// filepath: path of file
// changed: object which will have some status information:
//          - allowChange: allow changing resource file (because no errors have already been found) 
//          - messages: error messages
//          - change: when set, the original content has changed
//          - resource: when set, this will be the path of the resource file which has been changed.
// return value: changed content
function treatFile(content, filepath, changed) {

	function mess(i, message) {
		changed.messages.push((i ? "Line " + (i + 1) + ": " : "") + message);
	}

	// path of resource file
	var dirname = path.dirname(filepath);
	var filename = path.basename(filepath).replace(/\..*$/, ""); // basename without extension
	var resourceContents;
	changed.messages = [];
	var resourcepath = dirname + "/resources/" + filename + "-en.json";
	// console.log("Resource file "+resource)
	try {
		resourceContents = fs.readFileSync(resourcepath, "utf8");
	} catch (e) {
		var resourcepath2 = dirname + "/resources/" + filename + "-en-US.json";
		try {
			resourceContents = fs.readFileSync(resourcepath2, "utf8");
			resourcepath = resourcepath2;
		} catch (e) {
			// console.log("Read resource exception "+e)			
		}
	}
	if (resourceContents) {
		try {
			resourceContents = JSON.parse(resourceContents);
		} catch (e) {
			resourceContents = {};
			mess(null, "Resource file " + resourcepath + " does not contain valid JSON");
		}
	}
	var tmpResourceContents = resourceContents || {};

	content = convert(content, tmpResourceContents);
	if (RESOURCE_CHANGED in tmpResourceContents) { // check whether locale is defined
		changed.change = true; // changes by replacing
		resourceContents = tmpResourceContents; // maybe no resource contents yet
		if (!/locale\s*\=\s*require\s*\(\s*([\"\'])syracuse-core\/lib\/locale\1/.test(content)) {
			var r;
			var index = 0;
			// is there some block of require definitions before the first function declaration?
			if ((r = /((?:^|\r\n|\n|\r)+)\s*(?:(function)\s*\w?|var\s+\w+\s*\=\s*require)\s*\(/.exec(content)) && !r[2]) {
				index = r.index + r[1].length;
			} else { // no require definitions block found - put it at the beginning of the file
				if (r = /(?:^|\r\n|\n|\r)\"use strict\";?\s*[\n\r]*/.exec(content)) { // put it after "use strict"
					index = r.index + r[0].length;
				}
			}
			content = content.substr(0, index) + 'var locale = require("syracuse-core/lib/locale");\n' + content.substr(index);
		}
	}
	var resourceParameters = {};
	if (resourceContents) {
		Object.keys(resourceContents).forEach(function(key) {
			var value = resourceContents[key];
			var re = /\{(\d+)/g;
			var r;
			var max = -1;
			while (r = re.exec(value)) {
				if (max < r[1]) max = r[1];
			}
			resourceParameters[key] = 1 * max + 3;
		});
	}

	// console.log("resources "+JSON.stringify(resourceContents))
	var missingLocale = false;
	var localizePattern = null;
	var decl = false;
	var lines = content.split(/\r\n|\r|\n/);

	for (var i = 0; i < lines.length; i++) {
		var line = lines[i];
		if (/^\s*\/\//.test(line)) continue;
		if (line.search(/^\s*((var|const)\s+?)(\w+)\s*\=\s*require\s*\(\s*['"]syracuse-core\/lib\/locale['"]\s*\)/) >= 0) {
			decl = true;
		}
		var r;
		if (r = /(\w+)\s*\=\s*locale\.resources\s*\(\s*module\s*\)\s*(\(\s*\))?(?!\()/.exec(line)) {
			localizePattern = new RegExp(r[1] + "\\b" + (r[2] ? "" : "(\\(\\s*\\))?") + "\\.(\\w+)");
			// if (r[2]) console.error("line "+(i+1)+": Message: Static resources access");
		}
		var re = /locale\.format\s*\(/g;
		if (localizePattern && (r = localizePattern.exec(line))) {
			if (r[2]) {
				var keyWord = r[2];
				if (!r[1]) mess(i, "Missing brackets in reference to locale.resources function for " + keyWord);
			} else {
				var keyWord = r[1];
			}
			// console.log(line+"  KEY "+keyWord+" "+util.format(r))
			if (!resourceParameters || !(keyWord in resourceParameters)) {
				mess(i, "Key not defined in resource file: " + keyWord);
			} else {
				resourceParameters[keyWord] = -Math.abs(resourceParameters[keyWord]);

			}
		}
		while (r = re.exec(line)) {
			var line_remaining = line.substr(r.index + r[0].length);
			if (!decl && !missingLocale) {
				missingLocale = true;
				mess(null, "Missing declaration of locale");
			}
			if (!resourceParameters) {
				mess(null, "No resource file available");
			}
			var closingBracket = -1;
			while (closingBracket < 0 && i < lines.length) {
				// console.log("Remaining after locale format"+line_remaining);
				// replace special characters
				line_remaining = line_remaining.replace(/\\['"\\]/g, "!");
				// replace everything within strings
				line_remaining = line_remaining.replace(/(['"])(.*?)\1/g, function(a0, a1, a2) {
					return a1 + a2.replace(/\W+/, "!") + a1;
				});
				// remove all closed brackets
				var tmp = line_remaining;
				while ((tmp = line_remaining.replace(/\([^\(\)]*\)/, "")) !== line_remaining) {
					line_remaining = tmp;
				}
				// console.log("Remaining after removed brackets "+line_remaining);
				var closingBracket = line_remaining.indexOf(")");
				if (closingBracket < 0) { // no closing bracket found: take next line
					i++;
					line_remaining += lines[i];
				}
			}
			line_remaining = line_remaining.substr(0, closingBracket);
			// console.log("Remaining after removed brackets2 "+line_remaining);
			var parts = line_remaining.split(/\s*,\s*/);
			// console.log(i+"parts"+JSON.stringify(parts))
			if (parts[0] !== "module") {
				break; // checks only make sense when locale.format(module, ...) is used
			}
			if (parts.length < 2) {
				mess(i, "Not enough arguments for locale.format: " + line);
				break;
			}
			var keyWord = "";
			var keyWord2 = ""; // second key word for ".. ? .. : .." statement
			while (true) {
				var localizeCall = 0; // 1 for locale.format(localize.xxx), 0 for locale.format(module, ...)
				if (!keyWord && !/^(["'])\w+\1$/.test(parts[1])) {
					if (localizePattern && (r = localizePattern.exec(parts[0]))) {
						keyWord = r[2] ? r[2] : r[1];
						localizeCall = 1;
					} else {
						var decisionStatement = /\?\s*(["'])(\w+)\1\s*\:\s*(["'])(\w+)\3\s*$/.exec(parts[1]); // end of a "... ? ... : ..." statement, the condition will not be checked
						if (decisionStatement) {
							keyWord = decisionStatement[2];
							keyWord2 = decisionStatement[4];
						} else {
							console.log("Warning in "+filepath+": Cannot check integrity of localized message in: " + line) //mess(i, "Second argument for locale.format is not simple: " + line);
							break;							
						}
					}
				}
				// number of arguments...
				keyWord = keyWord || parts[1].replace(/["']/g, "");
				if (!resourceParameters || !(keyWord in resourceParameters)) {
					mess(i, "Key not defined in resource file: " + keyWord);
					break;
				} else {
					var parameterCount = Math.abs(resourceParameters[keyWord]);
					if (parameterCount !== parts.length + localizeCall) {
						mess(i, "Key " + keyWord + ": Parameters in message " + (parameterCount - 2) + ", parameters in invocation " + (parts.length - 2));
					}
					resourceParameters[keyWord] = -parameterCount;
				}
				if (keyWord2) {
					keyWord = keyWord2;
					keyWord2 = "";
				} else break;
			}
		}
	}
	if (changed.messages.length > 0) {
		return content;
	}
	if (resourceContents && RESOURCE_CHANGED in resourceContents && changed.allowChange) {
		try {
			fs.mkdirSync(dirname + "/resources");
		} catch (e) { // ignore error - then directory is already there			
		}
		try {
			console.log("Write resource "+resourcepath)
			fs.writeFileSync(resourcepath, toJSON(resourceContents));
			changed.resource = resourcepath;
		} catch (e) {
			console.error("exception when writing resource file " + e);
			changed.error = "Error messages available - do not save";
		}
	}
	return content;
}

exports.treatFile = treatFile;


// skip comment part
function _comment(rest, r) {
	if (r[0] === '//') {
		var rest1 = rest.substr(r.index + 2);
		var r1 = /[\r\n]+/.exec(rest1);
		if (r1) {
			return r.index + 2 + r1.index + r1[0].length;
		} else return rest.length;
	} else if (r[0] === '/*') {
		var index = rest.indexOf("*/", r.index);
		if (index >= 0) return index;
		else throw "Commentary not finished";
	}
	return 0;
}

// convert strings marked with $#$ to a call of a localized message and put the corresponding key and value to the resource object.
// return value: the text with replacements. The function throws an error when the key already exists in the resource object with different text.
function convert(text, resource) {
	var r;
	while ((r = /(["'])(\w+)\$\#\$/.exec(text))) {
		var index = r.index + r[0].length;
		var globalStartIndex = r.index;
		var startIndex = index;
		var str = r[1];
		var label = r[2];
		var brack = "";
		var closeBrack = "";
		var level = 0;
		var parameters = [];
		var message = "";
		var closingBrackets = {
			'(': ')',
			'[': ']'
		};
		while (index < text.length) {
			var rest = text.substr(index);
			if (str) {
				r = /[\\\"\']/.exec(rest);
				if (r) {
					if (r[0] === '\\') { // skip next character
						index += (r.index + 2);
						continue;
					} else {
						if (r[0] === str) { // end of string
							str = "";
							index += r.index + 1;
							message += text.substring(startIndex, index - 1);
						} else {
							index += r.index + 1;
						}
						continue;
					}
				} else throw "Unexpected end of input1";
			}
			if (level > 0) {
				switch (brack) {
					case '[':
						r = /(\[|\]|\/\/|\/\*)/.exec(rest);
						break;
					case '(':
						r = /(\(|\)|\/\/|\/\*)/.exec(rest);
						break;
				}
				if (r) {
					if (r[0] === brack) {
						level++;
						index += r.index + 1;
						continue;
					}
					if (r[0] === closeBrack) {
						level--;
						index += r.index + 1;
						if (level === 0) {
							brack = closeBrack = '';
							parameters[parameters.length - 1] += text.substring(startIndex, index);
						}
						continue;
					}
					var c = _comment(rest, r);
					if (c > 0) {
						index += c;
						continue;
					}
				} else throw "Bracket level not finished";
			}

			// outside strings and brackets
			r = /^\s*\+\s*(\"|\'|\(|[\$\w\.]+)/.exec(rest);
			if (r) {
				if (r[1] === '"' || r[1] === "'") {
					str = r[1];
					index += r.index + r[0].length;
					startIndex = index;
					continue;
				}
				// new parameter
				message += "{" + parameters.length + "}";
				parameters[parameters.length] = "";
				if (r[1] === '(') {
					brack = r[1];
					closeBrack = closingBrackets[brack];
					level = 1;
					index += r.index + r[0].length;
					startIndex = index - 1;
					continue;
				}
				// just number or variable
				index += r.index + r[0].length;
				parameters[parameters.length - 1] += r[1];
				startIndex = index;
				continue;
			}
			// multiplication/division
			r = /^\s*([\/\*]+)\s*[\$\w]*/.exec(rest);
			var mult = false;
			while (r && r[1].length === 1) {
				index += r[0].length;
				parameters[parameters.length - 1] += r[0];
				mult = true;
				rest = rest.substr(r[0].length);
				r = /^\s*([\/\*]+)\s*[\$\w]*/.exec(rest);
			}
			if (mult) continue;

			// opening bracket
			r = /^\s*([\(\[])/.exec(rest);
			if (r) {
				brack = r[1];
				closeBrack = closingBrackets[brack];
				level = 1;
				index += r.index + r[0].length;
				startIndex = index - 1;
				continue;
			}
			// property of an object
			r = /^\.[\$\w\.]+/.exec(rest);
			if (r) {
				index += r.index + r[0].length;
				parameters[parameters.length - 1] += r[0];
				startIndex = index;
				continue;
			}
			break; // cannot continue
		}
		text = text.substr(0, globalStartIndex) + 'locale.format(module, "' + label + '"' + (parameters.length ? ", " : "") + parameters.join(", ") + ")" + text.substr(index);
		if (label in resource && resource[label] !== message) {
			throw "Key " + label + " already exists with different message: "+resource[label];
		} else {
			resource[label] = message;
			console.error("Key added " + label+ " with message: "+message);
			resource[RESOURCE_CHANGED] = 1;			
		}
	}
	return text;
}

exports.convert = convert;