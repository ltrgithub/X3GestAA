"use strict";
var fs = require("streamline-fs");

exports.newImporter = function(config) {
	var trace = config.trace;
	var db = config.importDb;
	if (!db) throw new Error("config.importDb missing");
	var pool = require("./connectionPool").create(db, trace);

	var jsondir = config.output || __dirname + "/../../../../x3meta";
	var files;

	function executeSql(_, stmt, args) {
		//trace && trace("SQL: " + stmt + ", args=" + args);
		return pool.withConnection(_, function(_, cnx) {
			return cnx.execute(stmt, args || [], _);
		});
	}

	function init(_) {
		files = {};
		fs.readdir(jsondir, _).forEach_(_, function(_, module) {
			var moduleDir = jsondir + "/" + module;
			if (fs.stat(moduleDir, _).isDirectory()) {
				fs.readdir(moduleDir, _).forEach_(_, function(_, act) {
					var actDir = moduleDir + "/" + act;
					if (fs.stat(actDir, _).isDirectory()) {
						fs.readdir(actDir, _).forEach_(_, function(_, type) {
							var typeDir = actDir + "/" + type;
							if (fs.stat(typeDir, _).isDirectory()) {
								fs.readdir(typeDir, _).filter(function(name) {
									return /\.json$/.test(name);
								}).forEach_(_, function(_, name) {
									files[type] = files[type] || {};
									files[type][name.substring(0, name.length - 5)] = typeDir + "/" + name;
								});
							}
						});
					}
				});
			}
		});
	}

	function readFile(_, path) {
		return JSON.parse(fs.readFile(path, 'utf8', _));
	}

	function sqlType(col) {
		switch (col.CODTYP_0) {
		case 'M':
			return "NUMBER(3,0)";
		case 'L':
			return "NUMBER(10,0)";
		case 'D':
			return "DATE";
		case 'ATDATIM':
			return "TIMESTAMP(3)";
		default:
			return "VARCHAR2(1020)"; // for now - types not exported yet - need them to get type and length
		}
	}

	function expandColumn(withType) {
		return function(col) {
			var s = "";
			var dim = col.DIME_0 || 1; // TODO get dim from activity code if missing here
			for (var i = 0; i < dim; i++) s += (s ? "," : "") + col.CODZONE_0 + "_" + i + (withType ? " " + sqlType(col) : "");
			return s;
		};
	}

	var DATE_ZERO = new Date("1599-12-31T00:00:00Z");

	function defValue(col) {
		switch (col.CODTYP_0) {
		case 'M':
		case 'L':
			return 0;
		case 'D':
		case 'ATDATIM':
			return DATE_ZERO;
		default:
			return ""; // for now - types not exported yet - need them to get type and length
		}
	}

	function colValue(col, i, data) {
		var v = data[col.CODZONE_0 + '_' + i];
		if (v === undefined) return defValue(col);
		switch (col.CODTYP_0) {
		case 'D':
		case 'ATDATIM':
			return new Date(v);
		}
		return v;
	}

	function createTable(_, table, exists) {
		//trace && trace("creating table " + table.CODFIC_0);
		if (exists) executeSql(_, "drop table " + table.CODFIC_0, []);
		var ATABLE = files.TABLES.ATABLE;
		var sql = "create table " + table.CODFIC_0 + " (" + table.COLUMNS.map(expandColumn(true)).join(',') + ")";
		executeSql(_, sql, []);
	}

	function insert(_, entity, meta, data) {
		var j = 0;
		var sql = "insert into " + meta.CODFIC_0 + " (" + meta.COLUMNS.map(expandColumn(false)).join(',') + //
		") values (" + meta.COLUMNS.map(function(col) {
			var s = "";
			var dim = col.DIME_0 || 1; // TODO get dim from activity code if missing here
			for (var i = 0; i < dim; i++) s += (i > 0 ? ',' : '') + ':' + ++j;
			return s;
		}).join(',') + ")";
		var values = [];
		meta.COLUMNS.forEach(function(col) {
			var dim = col.DIME_0 || 1; // TODO get dim from activity code if missing here
			for (var i = 0; i < dim; i++) values.push(colValue(col, i, data));
		});
		executeSql(_, sql, values);
	}

	return {
		init: init,
		createTables: function(_) {
			trace && trace("creating tables ...");
			var t0 = Date.now();
			var oldTables = executeSql(_, "select TABLE_NAME from USER_TABLES").reduce(function(r, v) {
				r[v.TABLE_NAME] = true;
				return r;
			}, {});
			var tableNames = Object.keys(files.TABLES);
			tableNames.forEach_(_, function(_, name) {
				createTable(_, readFile(_, files.TABLES[name]), oldTables[name]);
			});
			trace && trace(tableNames.length + " tables created in " + Math.round((Date.now() - t0) / 1000) + " seconds");
		},
		fillTables: function(_, entity) {
			trace && trace("inserting " + entity.title + " metadata ...");
			var t0 = Date.now();
			var meta = readFile(_, files.TABLES[entity.tableName]);
			var childMetas = (Object.keys(entity.children) || []).map_(_, function(_, childName) {
				var child = entity.children[childName];
				return {
					name: childName,
					entity: child,
					meta: readFile(_, files.TABLES[child.tableName]),
				}
			});
			var names = Object.keys(files[entity.subdir]);
			names.forEach_(_, function(_, name) {
				//trace && trace("inserting " + entity.title + " " + name);
				var data = readFile(_, files[entity.subdir][name]);
				insert(_, entity, meta, data);
				childMetas.forEach_(_, function(_, childMeta, i) {
					data[childMeta.name].forEach_(_, function(_, childData) {
						// parent key is not saved in .json file - restore it
						childData[childMeta.entity.parentKey || entity.primaryKey] = data[entity.primaryKey];
						insert(_, childMeta.entity, childMeta.meta, childData);
					});
				});
			});
			trace && trace(entity.title + ": " + names.length + " resources created in " + Math.round((Date.now() - t0) / 1000) + " seconds");
		}
	}
}
