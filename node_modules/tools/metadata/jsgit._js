var git = require('git-node'),
	fs = require('streamline-fs'),
	pathJoin = require('path').join;

var defCommit = {
	author: {
		name: "Drew Fyock",
		email: "drew.fyock@sage.com"
	},
	committer: {
		name: "Drew Fyock",
		email: "drew.fyock@sage.com"
	},
	message: "test commit"
};

function importHash(repo, path, callback) {
	return importPath(repo, path, function(err, stat) {
		if (err) return callback(err);
		return callback(null, stat.hash);
	});
};

function importPath(repo, path, callback) {
	if (!callback) return importPath.bind(this, repo, path);
	var stat;
	fs.lstat(path, onStat);

	function onStat(err, result) {
		if (err) return callback(err);
		stat = result;
		if (stat.isFile()) {
			return fs.readFile(path, onData);
		}
		if (stat.isDirectory()) {
			return fs.readdir(path, onDir);
		}
		if (stat.isSymbolicLink()) {
			return fs.readlink(path, onData);
		}
		return callback(new Error("Can't import non-file " + path));
	}

	function onDir(err, names) {
		if (err) return callback(err);
		var giti = names.indexOf('.git')
		if (giti > -1) names.splice(giti, 1);
		parallel(names.map(function(name) {
			return importPath(repo, pathJoin(path, name));
		}), function(err, stats) {
			if (err) return callback(err);
			var dir = names.map(function(name, i) {
				var stat = stats[i];
				return {
					name: name,
					mode: stat.isDirectory() ? 040000 : stat.isSymbolicLink() ? 0120000 : (stat.mode & 0111) ? 0100755 : 0100644,
					hash: stat.hash
				};
			});
			repo.saveAs("tree", dir, onSave);
		});
	}

	function onData(err, buffer) {
		if (err) return callback(err);
		repo.saveAs("blob", buffer, onSave);
	}

	function onSave(err, hash) {
		if (err) return callback(err);
		stat.hash = hash;
		callback(null, stat);
	}
}

function parallel(commands, callback) {
	var results, length, left, i, done;

	left = length = commands.length;
	results = new Array(left);
	for (i = 0; i < length; i++) {
		run(i, commands[i]);
	}

	function run(key, command) {
		command(function(err, result) {
			if (done) return;
			if (err) {
				done = true;
				return callback(err);
			}
			results[key] = result;
			if (--left) return;
			done = true;
			callback(null, results);
		});
	}
}

function walk(repo, path, _) {
	var stat = fs.lstat(path, _);
	return fs.readdir(path, _).forEach_(_, function(_, file) {
		if (/^\..*/.test(file)) return; // ignore .git, .*
		var newPath = pathJoin(path, file);
		stat = fs.stat(newPath, _);
		if (stat.isDirectory()) {
			walk(repo, newPath, _);
			var dir = fs.readdir(newPath, _).map_(_, function(_, name) {
				stat = fs.stat(pathJoin(newPath, name), _);
				return {
					name: name,
					mode: stat.isDirectory() ? 040000 : stat.isSymbolicLink() ? 0120000 : (stat.mode & 0111) ? 0100755 : 0100644,
					hash: stat.hash
				};
			});
			console.log(dir);
			stat.hash = repo.saveAs("tree", dir, _);
		} else if (stat.isFile()) {
			stat.hash = repo.saveAs("blob", file, _);
		}
	});
};

exports.newGit = function(config) {
	var trace = config.trace;
	var repo = git.repo(pathJoin(config.output, ".git"));

	return {
		gitify: function(_, commit) {
			commit = commit || defCommit;
			trace && trace("Git process start");
			repo.setHead("master", _);

			var parent;
			repo.loadAs("commit", "master", function(err, commit) {
				if (err && err.code === "ENOENT") return;
				parent = commit.tree;
			});
			var hash = importHash(repo, config.output, _);

			if (parent != hash) {
				commit.tree = hash;
				if (parent) commit.parent = parent;
				hash = repo.saveAs("commit", commit, _);
				repo.updateHead(hash, _);
				trace && trace("Git repo updated with commit: " + hash);
			}

			trace && trace("Git process complete.");
		}
	}
}
