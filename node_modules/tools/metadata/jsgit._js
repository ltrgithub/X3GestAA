var git = require('git-node'),
  fs = require('streamline-fs'),
  pathJoin = require('path').join;

var defMock = {
  author: { name: "Drew Fyock", email: "drew.fyock@sage.com" },
  committer: { name: "Drew Fyock", email: "drew.fyock@sage.com" },
  message: "test commit on " + new Date()
};

function importHash(repo, path, callback) {
  return importPath(repo, path, function (err, stat) {
    if (err) return callback(err);
    return callback(null, stat.hash);
  });
};

function importPath(repo, path, callback) {
  if (!callback) return importPath.bind(this, repo, path);
  var stat;
  fs.lstat(path, onStat);

  function onStat(err, result) {
    if (err) return callback(err);
    stat = result;
    if (stat.isFile()) {
      return fs.readFile(path, onData);
    }
    if (stat.isDirectory()) {
      return fs.readdir(path, onDir);
    }
    if (stat.isSymbolicLink()) {
      return fs.readlink(path, onData);
    }
    return callback(new Error("Can't import non-file " + path));
  }

  function onDir(err, names) {
    if (err) return callback(err);
    var giti = names.indexOf('.git')
    if (giti > -1) names.splice(giti,1);
    parallel(names.map(function (name) {
      return importPath(repo, pathJoin(path, name));
    }), function (err, stats) {
      if (err) return callback(err);
      var dir = names.map(function (name, i) {
        console.log(name);
        var stat = stats[i];
        return {
          name: name,
          mode: stat.isDirectory() ? 040000 :
                stat.isSymbolicLink() ? 0120000 :
                (stat.mode & 0111) ? 0100755 : 0100644,
          hash: stat.hash
        };
      });
      repo.saveAs("tree", dir, onSave);
    });
  }

  function onData(err, buffer) {
    if (err) return callback(err);
    repo.saveAs("blob", buffer, onSave);
  }

  function onSave(err, hash) {
    if (err) return callback(err);
    stat.hash = hash;
    callback(null, stat);
  }
}

function parallel(commands, callback) {
  var results, length, left, i, done;

  left = length = commands.length;
  results = new Array(left);
  for (i = 0; i < length; i++) {
    run(i, commands[i]);
  }

  function run(key, command) {
    command(function (err, result) {
      if (done) return;
      if (err) {
        done = true;
        return callback(err);
      }
      results[key] = result;
      if (--left) return;
      done = true;
      callback(null, results);
    });
  }
}

exports.newGit = function(config) {
  var trace = config.trace;
  var repo = git.repo(config.output + "/.git");

  return {
    gitify: function(_, mock) {
      mock = mock || defMock;
      trace && trace("Git process start");
      repo.setHead("master", _);

      var parent = repo.resolveHashish("HEAD", function (err) {
        if (err) console.log('Creating new repo');
      });
      var hash = importHash(repo, config.output, _);
      console.log("parent/hash: " + parent + "/" + hash);
      if (parent != hash) {
        var commit = {
          tree: hash,
          parent: parent,
          author: mock.author,
          committer: mock.committer,
          message: mock.message
        };
        if (!parent) delete commit.parent;
        hash = repo.saveAs("commit", commit, _);
        repo.updateHead(hash, _);
        trace && trace("Git repo updated with commit: " + hash);
      }

      trace && trace("Git process complete.");
    }
  }
}
