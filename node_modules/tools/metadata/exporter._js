"use strict";

var fs = require('streamline-fs'),
	flows = require('streamline/lib/util/flows');

exports.newExporter = function(config) {
	var trace = config.trace;
	var db = config.db;
	if (!db) throw new Error("config.db missing");
	var pool = require("./connectionPool").create(db, trace);

	var fsFunnel = flows.funnel(1);

	function mkdir(_, s) {
		if (!fs.exists(s, _)) {
			fsFunnel(_, function(_) {
				if (!fs.exists(s, _)) fs.mkdir(s, _);
			});
		}
	}

	function rm(_, s) {
		if (!fs.exists(s, _)) return;
		var stat = fs.stat(s, _);
		if (stat.isDirectory()) {
			fs.readdir(s, _).forEach_(_, function(_, f) {
				rm(_, s + '/' + f);
			});
			fs.rmdir(s, _);
		} else {
			fs.unlink(s, _);
		}
	}

	function trim(obj) {
		var result = Object.keys(obj).reduce(function(o, k) {
			var v = obj[k];
			if (v instanceof Date) {
				v = v.toISOString();
				if (/T00\:00\:00\.000Z$/.test(v)) {
					v = v.substring(0, v.length - 14);
					if (v === '1599-12-31') v = null;
				}
			}
			if (/^CAST\(AUUID_0/.test(k)) k = "AUUID_0";
			var kk = k.substring(0, k.lastIndexOf('_'));
			var isArray = (obj[kk + '_1'] !== undefined);
			if (isArray) {
				o[kk] = o[kk] || [];
				o[kk].push(v);
			} else {
				if (v && v !== ' ') o[kk] = v;
			}
			return o;
		}, {});
		Object.keys(result).forEach(function(k) {
			var v = result[k];
			if (Array.isArray(v)) {
				var len = v.length;
				while (len > 0 && !(v[len - 1] && v[len - 1] !== ' ')) len--;
				result[k] = v.slice(0, len);
			}
		});
		return result;
	}

	function executeSql(_, stmt, args) {
		// trace && trace("SQL: " + stmt + "\nARGS: " + args);
		try {
			return pool.withConnection(_, function(_, cnx) {
				return cnx.execute(stmt, args || [], _).map(trim);
			});
		} catch (ex) {
			throw new Error("SQL error: " + ex.message + " while executing: " + stmt + " with args: " + args);
		}
	}

	function buildKey(_, keys, where) {
		if (!Array.isArray(keys)) keys = keys.split(',');
		return keys.map_(_, function(_, c, i) {
			return where ? c + '_0=:' + (i + 1) : (~keys.indexOf('_0') ? c : c + '_0');
		}).join(where ? ' and ' : ',');
	}

	function buildExecute(_, select, tableName, orderBy, elt, where) {
		if (!Array.isArray(select) && !~select.indexOf('_0')) select = buildKey(_, select);
		if (!where && elt) where = Object.keys(elt).join(',');
		trace && trace(tableName, orderBy, elt, where);
		return executeSql(_, "select " + select + " from " + tableName + //
			(where ? " where " + buildKey(_, where, 1) : '') + (orderBy ? " order by " + buildKey(_, orderBy) : ''), //
		(elt ? Object.keys(elt).map_(_, function(_, c) {
				return elt[c] || '';
			}) : []));
	}

	function writeResource(_, res) {
		var d = config.output;
		res.path.split('/').forEach_(_, function(_, s) {
			mkdir(_, d = d + "/" + s);
		});
		fs.writeFile(d + "/" + res.name + ".json", JSON.stringify(res.data, null, '\t'), "utf8", _);
	}

	return {
		config: config,
		trace: trace,
		clean: function(_) {
			trace && trace("cleaning output: " + config.output);
			mkdir(_, config.output);
			fs.readdir(config.output, _).forEach_(_, function(_, name) {
				if (name !== '.git') rm(_, config.output + '/' + name);
			});
		},
		init: function(_) {
			trace && trace("getting folder type");
			var folderType = parseInt(buildExecute(_, "VALEUR", "ADOVAL", null, {
				"PARAM": "TYPDOS"
			})[0].VALEUR_0, 10);
			if (folderType !== 1 && !config.force) throw new Error("Bad folder type: " + folderType);
		},
		moduleNames: ["UNKNOWN", "SUPERV", "FINANCE", "BP", "EXTERNAL", //
			"SALES", "PURCHASES", "STOCKS", "CAPM", "COMMON", //
			"DEV", "INTERNAL", "SUPPORT", "MARKETING", "FA", //
			"HR", "SPE1", "SPE2", "SPE3", "SPE4", "TALENT"
		],
		getTableColumns: function(_, tableName) {
			// trace && trace("loading columns for " + tableName);
			return buildExecute(_, "CODZONE,DIME,CODTYP", "ATABZON", "CODZONE", {
				'CODFIC': tableName
			}).map(function(elt) {
				var arr = [];
				for (var i = 0; i < elt.DIME; i++) {
					var s = elt.CODZONE + '_' + i;
					if (s === "AUUID_0") s = "CAST(AUUID_0 as varchar2(32))"; // hack to get around unsupported datatype in driver
					if (["AX1", "AX2", "AX3"].indexOf(elt.CODTYP) < 0) arr.push(s);
				}
				return arr.join(',');
			}).filter(function(s) {
				return s;
			});
		},
		buildExecute: buildExecute,
		writeResource: writeResource,
		objVals: function(_, elt, objectTypes) {
			return Object.keys(elt).map_(_, function(_, k) {
				return (objectTypes && objectTypes[elt[k]] ? objectTypes[elt[k]] : elt[k]);
			}).join(' ');
		}
	};
};
