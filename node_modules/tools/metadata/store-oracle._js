"use strict";

exports.newStore = function(config, files, readFile) {
	var trace = config.trace;
	var jsondir = config.output;

	var db = config.importDb;
	if (!db) throw new Error("config.importDb missing");
	var pool;

	function executeSql(_, stmt, args) {
		//trace && trace("SQL: " + stmt + ", args=" + args);
		return pool.withConnection(_, function(_, cnx) {
			return cnx.execute(stmt, args || [], _);
		});
	}

	function sqlType(col) {
		switch (col.CODTYP) {
		case 'M':
			return "NUMBER(3,0)";
		case 'L':
			return "NUMBER(10,0)";
		case 'D':
			return "DATE";
		case 'ADATIM':
			return "TIMESTAMP(3)";
		default:
			return "VARCHAR2(1020)"; // for now - types not exported yet - need them to get type and length
		}
	}

	var DATE_ZERO = new Date("1599-12-31T00:00:00Z");

	function defValue(col) {
		switch (col.CODTYP) {
		case 'M':
		case 'L':
			return 0;
		case 'D':
		case 'ATDATIM':
			return DATE_ZERO;
		default:
			return ""; // for now - types not exported yet - need them to get type and length
		}
	}

	function colValue(col, i, data) {
		var v = data[col.CODZONE + '_' + i];
		if (v === undefined) return defValue(col);
		switch (col.CODTYP) {
		case 'D':
		case 'ATDATIM':
			return new Date(v);
		}
		return v;
	}
	
	function expandColumn(withType) {
		return function(col) {
			var s = "";
			var dim = col.DIME || 1; // TODO get dim from activity code if missing here
			for (var i = 0; i < dim; i++) s += (s ? "," : "") + col.CODZONE + "_" + i + (withType ? " " + sqlType(col) : "");
			return s;
		};
	}

	function createTable(_, table, exists) {
		//trace && trace("creating table " + table.CODFIC);
		if (exists) executeSql(_, "drop table " + table.CODFIC, []);
		var ATABLE = files.TABLES.ATABLE;
		var sql = "create table " + table.CODFIC + " (" + table.COLUMNS.map(expandColumn(true)).join(',') + ")";
		executeSql(_, sql, []);
	}

	function insert(_, entity, meta, data) {
		var j = 0;
		var sql = "insert into " + meta.CODFIC + " (" + meta.COLUMNS.map(expandColumn(false)).join(',') + //
		") values (" + meta.COLUMNS.map(function(col) {
			var s = "";
			var dim = col.DIME || 1; // TODO get dim from activity code if missing here
			for (var i = 0; i < dim; i++) s += (i > 0 ? ',' : '') + ':' + ++j;
			return s;
		}).join(',') + ")";
		var values = [];
		meta.COLUMNS.forEach(function(col) {
			var dim = col.DIME || 1; // TODO get dim from activity code if missing here
			for (var i = 0; i < dim; i++) values.push(colValue(col, i, data));
		});
		executeSql(_, sql, values);
	}
	return {
		open: function(_) {
			pool = require("./connectionPool").create(db, trace);
			return this;		
		},
		createTables: function(_) {
			trace && trace("creating tables ...");
			var t0 = Date.now();
			var oldTables = executeSql(_, "select TABLE_NAME from USER_TABLES").reduce(function(r, v) {
				r[v.TABLE_NAME] = true;
				return r;
			}, {});
			var tableNames = Object.keys(files.TABLES);
			tableNames.forEach_(_, function(_, name) {
				createTable(_, readFile(_, files.TABLES[name]), oldTables[name]);
			});
			trace && trace(tableNames.length + " tables created in " + Math.round((Date.now() - t0) / 1000) + " seconds");
		},
		fillTables: function(_, entity) {
			trace && trace("inserting " + entity.title + " metadata ...");
			var t0 = Date.now();
			var meta = readFile(_, files.TABLES[entity.tableName]);
			var childMetas = (Object.keys(entity.children) || []).map_(_, function(_, childName) {
				var child = entity.children[childName];
				return {
					name: childName,
					entity: child,
					meta: readFile(_, files.TABLES[child.tableName]),
				}
			});
			var names = Object.keys(files[entity.subdir] || {});
			names.forEach_(_, function(_, name) {
				//trace && trace("inserting " + entity.title + " " + name);
				var data = readFile(_, files[entity.subdir][name]);
				insert(_, entity, meta, data);
				childMetas.forEach_(_, function(_, childMeta, i) {
					data[childMeta.name].forEach_(_, function(_, childData) {
						// parent key is not saved in .json file - restore it
						childData[childMeta.entity.parentKey || entity.primaryKey] = data[entity.primaryKey];
						insert(_, childMeta.entity, childMeta.meta, childData);
					});
				});
			});
			trace && trace(entity.title + ": " + names.length + " resources created in " + Math.round((Date.now() - t0) / 1000) + " seconds");
		},
		fillTexts: function(_) {
			trace && trace("inserting texts ...");
			var t0 = Date.now();
			var names = files.TEXTS;
			var entity, meta;
			names.forEach_(_, function(_, name) {
				var data = readFile(_, name);
				if (data.TEXTS) {
					entity = require('./texts/atextra').text;
					meta = readFile(_, files.TABLES[entity.tableName]);
					data.TEXTS.forEach_(_, function(_, row) {
						insert(_, entity, meta, row);
					});
				} else if (Array.isArray(data)) {
					entity = require('./texts/atexte').text;
					meta = readFile(_, files.TABLES[entity.tableName]);
					data.forEach_(_, function(_, row) {
						insert(_, entity, meta, row);
					});
				}
				else console.log("bad text file: " + name);
			});
			files.MENUS.forEach_(_, function(_, name) {
				var data = readFile(_, name);
				entity = require('./texts/aplstd').text;
				meta = readFile(_, files.TABLES[entity.tableName]);
				data.forEach_(_, function(_, row) {
					insert(_, entity, meta, row);
				});
			})
			trace && trace("TEXTS: " + (names.length + files.MENUS.length) + " resources created in " + Math.round((Date.now() - t0) / 1000) + " seconds");
		},
	}
};
