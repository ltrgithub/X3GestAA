"use strict";
var streams = require('streamline/lib/streams/server/streams');
var fs = require('fs');
var jsxml = require('jsxml');

/*var schema = streams.httpRequest({
	url: 'https://sdata.showcase.sage.com/sdata/accounts50/SDO/-/$schema',
	proxy: process.env.https_proxy,
	headers: {
		Host: "sdata.showcase.sage.com"
	},
	user: "MANAGER",
	password: "",
}).end().response(_).checkStatus(200).readAll(_);*/

var schemaNamespaces = {
	"http://schemas.sage.com/sdata/sme/2007": {
		$prefix: "$sme"
	},
	"http://www.w3.org/2001/XMLSchema": {
		$prefix: "$xsd"
	},
	// not used by schemas but present in examples!
	"http://www.w3.org/2005/Atom": {
		$prefix: "$atom"
	},
	"http://schemas.sage.com/sdata/2008/1": {
		$prefix: "$sdata"
	},
}

var feedNamespaces = {
	"http://www.w3.org/2005/Atom": {
		$prefix: "$atom"
	},
	"http://schemas.sage.com/sdata/2008/1": {
		$prefix: "$sdata"
	},
}

var xsd = fs.readFile(__dirname + "/data/schema.xml", "utf8", _);
var parsed = jsxml.parse(xsd);
var targetNamespace = Object.keys(parsed).map(function(k) {
	return parsed[k].$.targetNamespace;
})[0];
var namespaces = Object.keys(schemaNamespaces).reduce(function(r, k) {
	r[k] = schemaNamespaces[k];
	return r;
}, {});
namespaces[targetNamespace] = {
	$prefix: "$target"
};
var root = jsxml.canon(parsed, {
	namespaces: namespaces
});
var schema = root.$xsd.schema;
if (!schema.element || !schema.element.length) throw new Error("invalid schema: no elements");
if (!schema.complexType || !schema.complexType.length) throw new Error("invalid schema: no complex types");

var typeMap = schema.complexType.reduce(function(r, ct) {
	r[ct.name] = ct;
	return r;
}, {});

var xsdSourcePrefix = root.$xmlns["http://www.w3.org/2001/XMLSchema"].$sourcePrefix;

var simpleTypesMap = {
	int: 'integer',
	anyURI: 'string',
}
var formatsMap = {
	anyURI: 'url'
}

function mapType(e, prop) {
	if (!e.type) throw new Error("schema element lacks type attribute " + e.name);
	var pair = e.type.split(':');
	if (pair.length === 2 && pair[0] === xsdSourcePrefix) {
		prop.$type = "application/x-" + (simpleTypesMap[pair[1]] || pair[1]);
		var fmt = formatsMap[pair[1]];
		if (fmt) prop.$format = fmt;
	} else {
		prop.$type = e.type;
	}
}

schema.element.forEach_(_, function(_, elt) {
	var name = elt.name;
	var type = typeMap[elt.type];
	if (!type) throw new Error("no complex type for " + name);
	if (!type.all) throw new Error("invalid complex type " + name + ": all missing");
	//console.log(type.all);
	var proto = {
		$title: elt.title,
		$properties: type.all.element.reduce(function(r, e) {
			var prop = (r[e.name] = {
				$title: (e.$sme && e.$sme.label) || e.name,
			});
			mapType(e, prop);
			return r;
		}, {})
	}
	var json = JSON.stringify(proto, null, 2);
	fs.writeFile(__dirname + "/prototypes/" + name + "-proto.json", json, 'utf8', _);
})
//console.log(JSON.stringify(schema, null, 2));