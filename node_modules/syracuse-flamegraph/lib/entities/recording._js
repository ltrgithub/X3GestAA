"use strict";

var date = require("syracuse-core/lib/types/date");
var datetime = require("syracuse-core/lib/types/datetime");
var config = require('config');
var fsp = require('path');
var flamegraphSettings = require('./setting');

var tasks = {};

function getOptions(_, instance) {
	return {
		rate: instance.rate(_),
		sourceUrl: "https://github.com/Sage-ERP-X3/Syracuse/tree/master/node_modules/{relpath}#L{line}",
		sourceRoot: fsp.join(__dirname, "../../.."),
	};
}

exports.entity = {
	$titleTemplate: "Flamegraph recording",
	$valueTemplate: "{description}",
	$descriptionTemplate: "Recording from {stamp}",
	$canCreate: false,
	$canDelete: true,
	$canEdit: false,
	$properties: {
		name: {
			$title: "Name",
			$isMandatory: true,
			$isReadOnly: false,
			$linksToDetails: true,
		},
		rate: {
			$title: "Sampling rate (ms)",
			$type: "integer",
			$default: 10,
		},
		stamp: {
			$title: "Timestamp",
			$type: "datetime",
			$isReadOnly: true,
			$isNullable: true
		},
		pid: {
			$title: "Process ID",
			$type: "integer",
			$isReadOnly: true,
			$isNullable: true,
			$default: process.pid,
		},
		status: {
			$title: "Status",
			$enum: [{
				$title: "created",
				$value: "created",
			}, {
				$title: "running",
				$value: "running",
			}, {
				$title: "paused",
				$value: "paused",
			}, {
				$title: "complete",
				$value: "complete",
			}, {
				$title: "error",
				$value: "error",
			}],
			$default: "created",
		},
		size: {
			$title: "Size",
			$type: "integer",
			$compute: function(_, instance) {
				var recording = instance.recording(_);
				return recording.fileExists(_) ? recording.getProperties(_).length : null;
			},
		},
		recording: {
			$title: "Recording",
			$type: "binary",
			$isDisabled: false,
			$storage: "db_file",
		},
		fullGraph: {
			$title: "Full Graph",
			$type: "binary",
			$isDisabled: false,
			$storage: "db_file",
		},
		cpuGraph: {
			$title: "CPU Graph",
			$type: "binary",
			$isDisabled: false,
			$storage: "db_file",
		},
		transcript: {
			$title: "Transcript",
			$type: "text/plain",
			$isReadOnly: true,
			$default: "",
		}
	},
	$relations: {},
	$searchIndex: {
		$fields: ["name", "date"]
	},
	$functions: {
		log: function(_, message) {
			this.transcript(_, this.transcript(_) + '\n' + datetime.now() + ' ' + message);
		},
		startRecording: function(_) {
			var self = this;
			if (this.status(_) !== "created") throw new Error("bad status: " + this.status(_));
			// create task
			var task = require('streamline-flamegraph/lib/record').create(getOptions(_, this));
			tasks[this._id] = task;

			// create output stream
			var output = this.recording(_).createWritableStream(_, {
				"contentType": "application/x-flamegraph",
				"contentEncoding": "gzip",
				"fileName": this.name(_) + ".gz",
			});

			// run the pipe (do not wait)
			task.reader.pipe(_ >>
				function(err) {
					self.finishRecording(!_, err);
				}, output);
			task.start();

			// update status and save
			this.status(_, "running");
			this.log(_, "recording started");
			this.save(_);
		},
		finishRecording: function(_, err) {
			this.status(_, err ? "error" : "complete");
			this.log(_, err ? "recording failed: " + err.message : "recording complete");
			this.save(_);
		},
		stopRecording: function(_) {
			var err;
			try {
				var task = tasks[this._id];
				if (task) {
					delete tasks[this._id];
					task.stop(_);
				}
			} catch (e) {
				err = e;
			}
			this.finishRecording(_, err);
		},
		pauseRecording: function(_) {
			if (this.status(_) !== "running") throw new Error("bad status: " + this.status(_));
			var task = tasks[this._id];
			task.pause();
			this.status(_, "paused");
			this.log(_, "recording paused");
			this.save(_);
		},
		resumeRecording: function(_) {
			if (this.status(_) !== "paused") throw new Error("bad status: " + this.status(_));
			var task = tasks[this._id];
			task.resume();
			this.status(_, "running");
			this.log(_, "recording resumed");
			this.save(_);
		},
		generateSvg: function(_) {
			if (this.status(_) !== "complete") throw new Error("bad status: " + this.status(_));
			var recording = this.recording(_);
			if (!recording.fileExists(_)) throw new Error("Recording doesn't exist");

			var full = this.fullGraph(_).createWritableStream(_, {
				"contentType": "image/svg+xml",
				"fileName": this.name(_) + "-full.svg",
			});
			var cpu = this.cpuGraph(_).createWritableStream(_, {
				"contentType": "image/svg+xml",
				"fileName": this.name(_) + "-cpu.svg",
			});
			this.log(_, "SVG graphs generated");
			this.save(_);

			// do the folding pass once
			var converter = require('streamline-flamegraph/lib/fold').converter(_, recording.createReadableStream(_), getOptions(_, this));
			// run the two svg conversion tasks - 
			// sequentially for now to avoid collision on palette file (and have same palette) for both.
			converter(_, true).pipe(_, full);
			converter(_, false).pipe(_, cpu);
		}
	},
	$services: {
		create: {
			$title: "Create",
			$description: "Create new recording",
			$method: "POST",
			$isDisabled: function(_, instance) {
				return instance != null;
			},
			$execute: function(_, context) {
				var instance = context.entity.createInstance(_, context.db);
				instance.stamp(_, datetime.now());
				instance.name(_, "Flamegraph " + instance.stamp(_));
				instance.status(_, "created");
				instance.save(_);
			},
		},
		start: {
			$title: "Start",
			$description: "Start recording",
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "created";
			},
			$execute: function(_, context, instance) {
				instance.startRecording(_);
			},
		},
		stop: {
			$title: "Stop",
			$description: "Stop recording",
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "running";
			},
			$execute: function(_, context, instance) {
				instance.stopRecording(_);
			},
		},
		pause: {
			$title: "Pause",
			$description: "Stop recording",
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "running";
			},
			$execute: function(_, context, instance) {
				instance.pauseRecording(_);
			},
		},
		resume: {
			$title: "Resume",
			$description: "Stop recording",
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "paused";
			},
			$execute: function(_, context, instance) {
				instance.resumeRecording(_);
			},
		},
		generateSvg: {
			$title: "Generate Graphs",
			$description: "Generate SVG graphs",
			$method: "POST",
			$isMethod: true,
			//$invocationMode: "async",
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "complete" || instance.fullGraph(_).fileExists(_);
			},
			$execute: function(_, context, instance) {
				instance.generateSvg(_);
			},
		},
		sendByMail: {
			$title: "Send by mail",
			$description: "Send by e-mail to support",
			$method: "POST",
			$isMethod: true,
			//$invocationMode: "async",
			$isDisabled: function(_, instance) {
				return !instance.fullGraph(_).fileExists(_);
			},
			$execute: function(_, context, instance) {
				try {
					var template = flamegraphSettings.getInstance(_, context.db).mailTemplate(_);
					if (!template) throw new Error("mail template has not been configured");
					template.sendMail(_, {
						view: instance.serializeInstance(_),
						attachments: ['recording', 'fullGraph', 'cpuGraph'].map_(_, function(_, k) {
							return instance[k](_).createReadableStream(_);
						}),
					});
					instance.log(_, "mail sent sucessfully");
				} catch (ex) {
					instance.log(_, "mail attempt failed: " + ex.message);
				}
				instance.save(_);
			},
		},
	},
	$links: {
		settings: flamegraphSettings.getLink(),
	}
};