"use strict";
/// !doc
///
var globals = require("streamline/lib/globals");
var ez = require('ez-streams');

var datetime = require("syracuse-core/lib/types/datetime");
var locale = require("syracuse-core/lib/locale");
var sadFsq = require('syracuse-x3/lib/clients/sadfsq/sadfsqClient');
var SadFsqClient = sadFsq.SadFsqClient;

var flamegraph = require('streamline-flamegraph/lib/flamegraph.js');
var x3Transform = require('syracuse-flamegraph/lib/x3Transform._js');

var pool = require("syracuse-x3/lib/pool");

exports.entity = {
	$titleTemplate: "Session log activation",
	$valueTemplate: "{name}",
	$descriptionTemplate: "{description}",
	$canCreate: false,
	$canDelete: true,
	$properties: {
		name: {
			$title: "Name",
			$isMandatory: true,
			$linksToDetails: true,
			$default: function(_, instance) {
				return "Log " + datetime.now();
			}
		},
		stamp: {
			$title: "Timestamp",
			$type: "datetime",
			$isReadOnly: true,
			$isNullable: true,
			$default: function(_, instance) {
				return datetime.now();
			},
		},
		status: {
			$title: "Status",
			$enum: [{
				$title: "created",
				$value: "created",
			}, {
				$title: "running",
				$value: "running",
			}, {
				$title: "stopped",
				$value: "stopped",
			}, {
				$title: "complete",
				$value: "complete",
			}, {
				$title: "error",
				$value: "error",
			}],
			$isReadOnly: true,
			$default: "created",
		},
		cpuGraph: {
			$title: "CPU Graph",
			$type: "image",
			$storage: "db_file",
			$isReadOnly: true
		},
		log: {
			$title: "Log",
			$type: "binary",
			$storage: "db_file",
			$isReadOnly: true
		},
		memoryDump1: {
			$title: "Memory on start",
			$type: "binary",
			$storage: "db_file",
			$isReadOnly: true
		},
		memoryDump2: {
			$title: "Memory on stop",
			$type: "binary",
			$storage: "db_file",
			$isReadOnly: true
		},
		heapMemoryUsed1: {
			$title: "Heap memory on start",
			$type: "integer",
			$isReadOnly: true,
			$isHidden: true
		},
		heapMemoryUsed2: {
			$title: "Memory used",
			$type: "integer",
			$isReadOnly: true
		},
		heapMemoryGrowth: {
			$title: "Memory growth",
			$type: "integer",
			$isReadOnly: true
		},
		dataset: {
			$title: "Dataset",
			$isExcluded: true
		}
	},
	/// ## Relations
	$relations: {
		/// * **endPoint** - Endpoint: Endpoint for which the log is activated (all endpoints if none is specified)
		///
		endpoint: {
			$title: "Endpoint",
			$type: "endPoint",
			$isHidden: function(_, instance) {
				return true;
			},
			$propagate: function(_, instance, val) {
				if (val) instance.dataset(_, val.dataset(_));
				else instance.dataset(_, "");
			}
		}
	},
	$functions: {
		writeStream: function(_, property, contents, contentType, fileName) {
			if (contents && contents.length) {
				this[property](_, contents);
				var writer = this[property](_).createWritableStream(_, {
					contentType: contentType,
					fileName: "memory.dmp",
				});
				writer.write(_, contents, "binary");
				writer.write(_, null);
			}
		},
		memoryDump: function(_, endpoint) {
			var path = endpoint.getService(_, "memoryDump").file;
			var x3server = endpoint.x3server(_);
			var sadfs = new SadFsqClient(_, x3server.serverHost(_), x3server.serverPort(_), null, null, false);
			return sadfs.readFile(_, {
				path: path
			}, {
				flag: "r",
				encoding: "utf-8"
			});
		},
		getHeapMemoryUsed: function(memoryDump) {
			var heapMemoryUsed = 0;
			if (memoryDump) {
				var match = /HEAP MEMORY USED : (\d+) bytes/.exec(memoryDump);
				if (match) {
					console.log("match:" + JSON.stringify(match));
					heapMemoryUsed = parseFloat(match[1]);
				}
			}
			return heapMemoryUsed;
		}
	},
	/// ## Services
	$services: {
		create: {
			$title: "Create",
			$description: "Create new recording",
			$method: "POST",
			$isDefined: function(_, instance) {
				return instance == null;
			},
			$execute: function(_, context) {
				var instance = context.entity.createInstance(_, context.db);
				instance.stamp(_, datetime.now());
				instance.name(_, "Log " + instance.stamp(_));
				instance.status(_, "created");
				instance.heapMemoryUsed1(_, 0);
				instance.heapMemoryUsed2(_, 0);
				instance.heapMemoryGrowth(_, 0);
				instance.save(_);
			},
		},
		start: {
			$method: "POST",
			// $confirm: "This operation will change the X3 runtime configuration of all subsequent sessions.\n\nDo you want to continue ?",
			$isMethod: true,
			$title: "Start",
			$execute: function(_, context, instance) {
				try {
					var up = globals.context.session && globals.context.session.getUserProfile(_);
					var user = up.user(_);
					var endpoint = up.selectedEndpoint(_);
					if (context.httpSession.x3SessionConfig && context.httpSession.x3SessionConfig.runtime) {
						endpoint.postService(_, "resetLog");
						context.httpSession.x3SessionConfig.runtime.logId++;
					} else {
						context.httpSession.x3SessionConfig = context.httpSession.x3SessionConfig || {};
						instance.$diagnoses = instance.$diagnoses || [];

						var runtimeCfg = context.httpSession.x3SessionConfig.runtime = (context.httpSession.x3SessionConfig.runtime || {});
						runtimeCfg.runtimeLog = true;
						runtimeCfg.logFlag = 1;
						runtimeCfg.dataset = instance.endpoint(_) ? instance.endpoint(_).dataset(_) : null;
						runtimeCfg.logDir = "TRA";
						runtimeCfg.logId = 0;

						instance.$diagnoses.push({
							$severity: "info",
							$message: locale.format(module, "runtimeLogEnabled")
						});
					}
					var memoryDump = instance.memoryDump(_, endpoint);
					instance.heapMemoryUsed1(_, instance.getHeapMemoryUsed(memoryDump));
					instance.writeStream(_, "memoryDump1", memoryDump, "x-trace", "memory.dmp");
					instance.status(_, "running");
					instance.save(_);

				} catch (e) {
					context.httpSession.x3SessionConfig = {};
					console.error(e.stack);
					return {
						$diagnoses: [{
							severity: "error",
							message: e.message
						}]
					};
				}
			}
		},
		generate: {
			$method: "POST",
			// $confirm: "This operation will change the X3 runtime configuration of all subsequent sessions.\n\nDo you want to continue ?",
			$isMethod: true,
			$title: "Generate Graph",
			$isDefined: function(_, instance) {
				return /^(running|paused)$/.test(instance.status(_));
			},
			$execute: function(_, context, instance) {
				try {
					if (context.httpSession.x3SessionConfig && context.httpSession.x3SessionConfig.runtime) {
						var up = globals.context.session && globals.context.session.getUserProfile(_);
						var user = up.user(_);
						var endpoint = up.selectedEndpoint(_);
						var login = user.getEndpointLogin(_, endpoint.$uuid).toLowerCase();

						var client = pool.getClient(_, globals.context.session, endpoint);

						var fileName = ["x3diary", login, client.getProcessId(), context.httpSession.x3SessionConfig.runtime.logId].join('_');
						var x3server = endpoint.x3server(_);
						var sadfs = new SadFsqClient(_, x3server.serverHost(_), x3server.serverPort(_), null, null, false);

						var tra = sadfs.readFile(_, {
							folder: endpoint.x3ServerFolder(_),
							path: "TRA",
							name: fileName,
							extension: "tra"
						}, {
							flag: "r",
							encoding: "utf-8"
						});

						if (tra && tra.length) {
							instance.writeStream(_, "log", tra, "x-trace", "x3.tra");

							var log = ez.devices.buffer.reader(tra);
							var data = x3Transform.convert(_, log);

							var options = {
								href: "https://github.com/Sage-ERP-X3/Syracuse/tree/master/{0}#L{1}",
								target: "_blank",
								codes: data.codes,
								frames: data.frames,
								frameformat: "{2} ({0}:{1})",
								palette: {
									"io": "rgb(0,255,255)"
								},
								hash: 2
							};

							var svg = flamegraph.makesvg(data.res, options);
							instance.writeStream(_, "cpuGraph", svg, "image/svg+xml", "cpuGraph.svg");
							var memoryDump = instance.memoryDump(_, endpoint);
							instance.heapMemoryUsed2(_, instance.getHeapMemoryUsed(memoryDump));

							instance.heapMemoryGrowth(_, instance.heapMemoryUsed2(_) - instance.heapMemoryUsed1(_));
							instance.writeStream(_, "memoryDump2", memoryDump, "x-trace", "memory.dmp");


							instance.status(_, "complete");
							instance.save(_);
						}
					}
				} catch (e) {
					context.httpSession.x3SessionConfig = {};
					console.error(e.stack);
					return {
						$diagnoses: [{
							severity: "error",
							message: e.message
						}]
					};
				}
			}
		},
		stop: {
			$method: "POST",
			// $confirm: "This operation will change the X3 runtime configuration of all subsequent sessions.\n\nDo you want to continue ?",
			$isMethod: true,
			$title: "Stop",
			$isDefined: function(_, instance) {
				return /^(running|paused)$/.test(instance.status(_));
			},
			$execute: function(_, context, instance) {
				try {
					if (context.httpSession.x3SessionConfig && context.httpSession.x3SessionConfig.runtime) {
						delete context.httpSession.x3SessionConfig.runtime;
						instance.$diagnoses = instance.$diagnoses || [];
						instance.$diagnoses.push({
							$severity: "info",
							$message: locale.format(module, "runtimeLogDisabled")
						});
						instance.writeStream(_, "memoryDump2", memoryDump(_, endpoint), "x-trace", "memory.dmp");
						instance.status(_, "stopped");
						instance.save(_);

					}
				} catch (e) {
					context.httpSession.x3SessionConfig = {};
					console.error(e.stack);
					return {
						$diagnoses: [{
							severity: "error",
							message: e.message
						}]
					};
				}
			}
		}
	}
};