"use strict";

var helpers = require('syracuse-core/lib/helpers');
var uuid = helpers.uuid;
var forEachKey = helpers.object.forEachKey;
var config = require('config'); // must be first syracuse require
var dataModel = require("syracuse-orm/lib/dataModel");
var registry = require("syracuse-sdata/lib/sdataRegistry");
var mongodb = require('streamline-mongodb');
var sys = require("util");
var factory = require("syracuse-orm/lib/factory");
var parser = require('syracuse-sdata/lib/parser/parser');
var checksum = require("syracuse-orm/lib/checksum");
var signSerializer = new(require("syracuse-orm/lib/serializer").SignSerializer)();
var locale = require("syracuse-core/lib/locale");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
//
var tracer; // = console.log;
//force basic auth
config.session = config.session || {};
config.session.auth = "basic";
config.session.ignoreStoreSession = true;
//no integration server
config.integrationServer = null;

//add model
var adminTestFixtures = require("syracuse-collaboration/test/fixtures/adminTestFixtures");
var endPoint = adminTestFixtures.modifyCollaborationEndpoint("mongodb_example");
var testEp = {
	contract: require("test-contract/lib/contract").contract,
	datasets: {
		test: {
			driver: "mongodb",
			database: "test",
			hostname: "localhost",
			port: 27017
		}
	}
};
registry.register([testEp]);

config.sdata.endpoints.push(endPoint);
endPoint.contract.datasets = endPoint.datasets;

var port = 3004;
var db;
//

function _getModel() {
	return dataModel.make(testEp.contract, "test");
}
//
var doStop = false;
QUnit.module(module.id, {
	setup: function() {},
	teardown: function() {
		if (doStop) {
			setTimeout(function() {
				process.kill(process.pid);
			}, 100);
		}
	}
});

asyncTest("init database", 1, function(_) {
	var server = new mongodb.Server(endPoint.datasets["mongodb_example"].hostname, endPoint.datasets["mongodb_example"].port, {});
	var _db = adminTestFixtures.newMongoDb(endPoint.datasets["mongodb_example"].database, server, {});
	_db = _db.open(_);
	_db.dropDatabase(_);
	var server = new mongodb.Server(testEp.datasets["test"].hostname, testEp.datasets["test"].port, {});
	var _db = adminTestFixtures.newMongoDb(testEp.datasets["test"].database, server, {});
	_db = _db.open(_);
	_db.dropDatabase(_);
	ok(true, "mongodb initialized");

	start();
});

//start syracuse server
asyncTest("initialize syracuse test server", 1, function(_) {
	require('syracuse-main/lib/syracuse').startServers(_, port);
	ok(true, "server initialized");
	start();
});

asyncTest("get database handle", 1, function(_) {
	var ep = adminHelper.getEndpoint(_, {
		dataset: "syracuse"
	});
	if (ep) {
		ep.dataset(_, "mongodb_example");
		var res = ep.save(_);
	}
	var adminDb = ep.getOrm(_);
	var ap = adminDb.getEntity(_, "application").createInstance(_, adminDb);
	ap.description(_, "test");
	ap.application(_, "example");
	ap.contract(_, "admin");
	ap.protocol(_, "syracuse");
	ap.save(_);
	var ep = adminDb.getEntity(_, "endPoint").createInstance(_, adminDb);
	ep.description(_, "test");
	ep.applicationRef(_, ap);
	ep.dataset(_, "test");
	ep.databaseHost(_, testEp.datasets.test.hostname);
	ep.databasePort(_, testEp.datasets.test.port);
	var res = ep.save(_);
	ok(ep.getModel(_) != null, "Test endpoint ok");
	//
	db = ep.getOrm(_);

	start();
});

asyncTest("list snapshot test", 5, function(_) {
	// make a country
	var countryEntity = db.model.getEntity(_, "country");
	var country = countryEntity.factory.createInstance(_, null, db);
	country.code(_, "FR");
	country.description(_, "France");
	country.save(_);
	// deep navigate conditions
	var addressEntity = db.model.getEntity(_, "address");
	var address = addressEntity.factory.createInstance(_, null, db);
	address.country(_, country);
	var userEntity = db.model.getEntity(_, "user");
	var user = userEntity.factory.createInstance(_, null, db);
	user.lastName(_, "TestUser");
	user.address(_, address);
	var postEntity = db.model.getEntity(_, "post");
	var post1 = postEntity.factory.createInstance(_, null, db);
	post1.postNum(_, 1);
	user.posts(_).set(_, post1);
	tracer && tracer("before user save (88)");
	user.save(_);
	tracer && tracer("after user save (89)");
	var diag = [];
	user.getAllDiagnoses(_, diag);
	ok(diag.length == 0, "User saved ok");
	// reset user entity
	tracer && tracer("after user save (94); diags: " + sys.inspect(diag, null, 4));
	user = db.fetchInstance(_, userEntity, user.$uuid);
	ok(user != null, "User fetch ok");
	var post2 = postEntity.factory.createInstance(_, null, db);
	post2.postNum(_, 2);
	user.posts(_).set(_, post2);
	strictEqual(user.posts(_).getLength(), 2, "Posts count ok");
	strictEqual(user.$snapshot.posts(_).getLength(), 1, "Snapshot posts count ok");
	tracer && tracer("posts (99): " + sys.inspect(user.$snapshot.posts(_), null, 4));
	tracer && tracer("snapshot posts (100): " + sys.inspect(user.$snapshot.posts(_), null, 4));
	var snapList = user.$snapshot.posts(_).toArray(_);
	tracer && tracer("snapshot posts array (102): " + sys.inspect(snapList, null, 4));
	strictEqual(snapList[0].postNum(_), 1, "Got postnum ok");
	//
	start();
});

asyncTest("cursor test", 4, function(_) {
	//	var db = dataModel.getOrm(_, _getModel(), endPoint.datasets.mongodb_example);
	// add second country
	var countryEntity = db.model.getEntity(_, "country");
	var country = countryEntity.factory.createInstance(_, null, db);
	country.code(_, "US");
	country.description(_, "US");
	country.save(_);
	//
	var cursor = db.createCursor(_, countryEntity, {
		jsonWhere: {},
		orderBy: [{
			binding: "code",
			descending: true
		}]
	});
	var data = cursor.next(_);
	ok(data != null, "data fetch ok");
	strictEqual(data.code(_), "US", "fetched US ok");
	var data = cursor.next(_);
	ok(data != null, "data fetch ok");
	strictEqual(data.code(_), "FR", "fetched FR ok");
	//
	start();
});

asyncTest("Collections management test", 8, function(_) {
	var refAEnt = db.getEntity(_, "refA");
	var refDEnt = db.getEntity(_, "refD");
	//
	var refA1 = refAEnt.createInstance(_, db);
	var refA2 = refAEnt.createInstance(_, db);
	var refD1 = refDEnt.createInstance(_, db);
	var refD2 = refDEnt.createInstance(_, db);
	refA1.refDList(_).set(_, refD1);
	refA1.refDList(_).set(_, refD2);
	refA2.refDList(_).set(_, refD1);
	refA2.refDList(_).set(_, refD2);
	refD1.refAList(_).set(_, refA1);
	refD1.refAList(_).set(_, refA2);
	refD2.refAList(_).set(_, refA1);
	refD2.refAList(_).set(_, refA2);
	strictEqual(refA1.refDList(_).getLength(), 2, "Length A1 ok");
	strictEqual(refA2.refDList(_).getLength(), 2, "Length A2 ok");
	strictEqual(refD1.refAList(_).getLength(), 2, "Length D1 ok");
	strictEqual(refD2.refAList(_).getLength(), 2, "Length D2 ok");
	//
	refA1.refDList(_).deleteInstance(_, refD1.$uuid);
	strictEqual(refA1.refDList(_).getLength(), 2, "Length A1 after delete ok");
	strictEqual(refD1.refAList(_).getLength(), 2, "Length D1 after delete ok");
	// save and reload
	// TODO: FIX FIRST circular reference when save(_) beacause of relatedInstances
	tracer && tracer("refA1related: " + sys.inspect(refA1._relatedInst));
	tracer && tracer("refA2related: " + sys.inspect(refA2._relatedInst));
	tracer && tracer("refD1related: " + sys.inspect(refD1._relatedInst));
	tracer && tracer("refD2related: " + sys.inspect(refD2._relatedInst));
	refA1.save(_);
	refA2.save(_);
	refD1.save(_);
	refD2.save(_);
	//
	refA1 = db.fetchInstance(_, refAEnt, refA1.$uuid);
	refD1 = db.fetchInstance(_, refDEnt, refD1.$uuid);
	strictEqual(refA1.refDList(_).getLength(), 1, "Length A1 after delete ok");
	strictEqual(refD1.refAList(_).getLength(), 1, "Length D1 after delete ok");
	//
	start();
});

asyncTest("circular navigation test", 1, function(_) {
	var refAEnt = db.getEntity(_, "refA");
	var refBEnt = db.getEntity(_, "refB");
	//
	var refA1 = refAEnt.createInstance(_, db);
	refA1.description(_, "nav_test_1");
	refA1.save(_);
	var refB1 = refBEnt.createInstance(_, db);
	refA1.refBList(_).set(_, refB1);
	// modify soemthing
	refA1.description(_, "nav_test_2");
	// navigate
	tracer && tracer("before navigate: (197)");
	refB1.refAList(_).get(_, refA1.$uuid);
	tracer && tracer("after navigate: (199)");
	// check value
	strictEqual(refA1.description(_), "nav_test_2", "Modified value still ok");

	start();
});

asyncTest("storage area API test", 11, function(_) {
	//	var db = dataModel.getOrm(_, _getModel(), endPoint.datasets.mongodb_example);
	//
	var storeTestEntity = db.model.getEntity(_, "storeTest");
	// db_file mode
	var storeInst = storeTestEntity.factory.createInstance(_, null, db);
	var store = storeInst.content(_);
	var w = store.createWritableStream(_, {
		fileName: "test.txt"
	});
	// make 2 writes
	w.write(_, "012", "utf8");
	w.write(_, "345", "utf8");
	w.write(_, null);
	//store.write(_, "012345");
	// create readable store
	var r = store.createReadableStream(_);
	var buf;
	var res = "";
	while (buf = r.read(_))
		res += buf;
	strictEqual(res, "012345", "Simple content write/read ok");
	storeInst.save(_);
	var storeInstUuid = storeInst.$uuid;
	var dbFileName = storeInst.content(_).getUuid();
	// reload from db
	storeInst = db.fetchInstance(_, storeTestEntity, storeInstUuid);
	// retest read
	var r = (store = storeInst.content(_)).createReadableStream(_);
	var buf;
	var res = "";
	while (buf = r.read(_))
		res += buf;
	strictEqual(res, "012345", "Simple content write/read ok");
	// working copy mode test
	// create a store wc
	store.createWorkingCopy(_);
	w = store.createWritableStream(_, {
		fileName: "test1.txt"
	});
	w.write(_, "new file");
	w.write(_, null);
	var dbNewFileName = store.getUuid();
	ok(dbNewFileName != dbFileName, "Created new file ok");
	// both files exists now
	ok(mongodb.GridStore.exist(db.db, dbFileName, _), "Old file exists ok");
	ok(mongodb.GridStore.exist(db.db, dbNewFileName, _), "New file exists ok");
	//
	storeInst.save(_);
	// old file should have been deleted
	ok(!mongodb.GridStore.exist(db.db, dbFileName, _), "Db file deleted ok");
	dbFileName = dbNewFileName;
	// recreate a Wc, after save the old file should be deleted
	store.createWorkingCopy(_);
	// the file should stil exist before final save
	ok(mongodb.GridStore.exist(db.db, dbFileName, _), "File stil exists ok");
	storeInst.save(_);
	// the file should stil exist before final save
	ok(!mongodb.GridStore.exist(db.db, dbFileName, _), "File is deleted ok");
	//
	// delete store inst
	storeInst.deleteSelf(_);
	// check inst deleted
	storeInst = db.fetchInstance(_, storeTestEntity, storeInstUuid);
	ok(!storeInst, "Store inst deleted ok");
	// check file deleted
	ok(!mongodb.GridStore.exist(db.db, dbFileName, _), "Db file deleted ok");
	// file mode
	var storeInst = storeTestEntity.factory.createInstance(_, null, db);
	storeInst.storageType(_, "file");
	var store = storeInst.content(_);
	store._store.setFile(_, require("path").join(__dirname, "rsrc", "stringReaderTest.txt"));
	var r = store.createReadableStream(_);
	var buf;
	var res = "";
	while (buf = r.read(_))
		res += buf;
	strictEqual(res, "a string to read", "File storage read ok");

	//
	start();
});

function _unescape(obj, dbProp, objProp) {
	obj[objProp] = obj[dbProp];
	delete obj[dbProp];
}

asyncTest("Signed objects", 6, function(_) {
	var signedEnt = db.getEntity(_, "signedTests");
	var signed = signedEnt.createInstance(_, db);
	signed.description(_, "Sign test");
	var r = signed.save(_);
	ok(!(r.$diagnoses || []).some(function(d) {
		return d.severity === "error";
	}), "Signed saved ok");
	// check signature
	var dbObj = (db.db.collection("SignedTest", _).find({
		description: "Sign test"
	}).toArray(_))[0];
	// unescape
	/*	Object.keys(dbObj).forEach(function(prop) {
		if(prop === "_id")
			db.unescapeJson(dbObj, prop, "$uuid");
		else
			if(prop[0] === "_")
				db.unescapeJson(dbObj, prop, "$" + prop.slice(1));
	});*/
	dbObj.$uuid = dbObj._id;
	delete dbObj._id;
	dbObj = signSerializer.serializeResource(signedEnt, db.unescapeJson(dbObj));
	//
	ok(checksum.verify(dbObj, ["_id", "$key", "$loaded"]), "Signature verified from db");
	// try to fetch
	var obj = db.fetchInstance(_, signedEnt, {
		jsonWhere: {
			description: "Sign test"
		}
	});
	strictEqual(obj.description(_), "Sign test", "Signed object fetch ok");
	// modification test
	obj.description2(_, "desc2");
	var r = obj.save(_);
	ok(!(r.$diagnoses || []).some(function(d) {
		return d.severity === "error";
	}), "Signed saved ok (2)");
	// try to fetch
	var obj = db.fetchInstance(_, signedEnt, {
		jsonWhere: {
			description: "Sign test"
		}
	});
	strictEqual(obj.description2(_), "desc2", "Signed object fetch ok (2)");

	// direct database modification
	db.db.collection("SignedTest", _).update({
		description: "Sign test"
	}, {
		$set: {
			description: "Changed sign"
		}
	}, {
		safe: true,
		multi: true
	}, _);
	// try to fetch - should get an error
	try {
		var obj = db.fetchInstance(_, signedEnt, {
			jsonWhere: {
				description: "Changed sign"
			}
		});
		ok(false, "NOT ok, should have got an error");
	} catch (e) {
		ok(true, "Fetch error of changed object ok");
	}

	start();
});

asyncTest("localized properties test", 9, function(_) {
	var locEnt = db.getEntity(_, "localized");
	//
	locale.setCurrent(_, "en-US");
	// create an instance and set en-US only.
	var loc = locEnt.createInstance(_, db);
	loc.description(_, "english text");
	loc.save(_);
	//
	var prop = loc.getPropAllLocales(_, "description");
	strictEqual(prop["default"], "english text", "Default prop ok");
	strictEqual(prop["en-us"], "english text", "en-US prop ok");
	// filter in en-US: must find
	var loc = db.fetchInstance(_, locEnt, {
		jsonWhere: {
			description: "english text"
		}
	});
	ok(loc != null, "Filter in english found ok");
	// test fr-FR
	locale.setCurrent(_, "fr-FR");
	// filter in fr-FR: must find using default property
	var loc = db.fetchInstance(_, locEnt, {
		jsonWhere: {
			description: "english text"
		}
	});
	ok(loc != null, "Filter in french found ok");
	// modify french text
	loc.description(_, "french text");
	var prop = loc.getPropAllLocales(_, "description");
	strictEqual(prop["default"], "english text", "Default prop ok");
	strictEqual(prop["en-us"], "english text", "en-US prop ok");
	strictEqual(prop["fr-fr"], "french text", "fr-FR prop ok");
	loc.save(_);
	// filter in fr-FR: must NOT find using because there is a text in fr-FR
	var loc = db.fetchInstance(_, locEnt, {
		jsonWhere: {
			description: "english text"
		}
	});
	ok(loc == null, "Filter in french NOT found ok");
	// filter in fr-FR: must find french text
	var loc = db.fetchInstance(_, locEnt, {
		jsonWhere: {
			description: "french text"
		}
	});
	ok(loc != null, "Filter in french found ok");

	start();
});

asyncTest("case insensitive properties", 6, function(_) {
	var ciEnt = db.getEntity(_, "caseInsensitive");
	var ci = ciEnt.createInstance(_, db);
	ci.ci(_, "TEST");
	ci.cs(_, "TEST");
	ci.save(_);
	// fetch case sensitive
	ci = db.fetchInstance(_, ciEnt, {
		jsonWhere: {
			ci: "TEST"
		}
	});
	ok(ci != null, "Case sensitive fetch of case insensitive prop ok");
	ci = db.fetchInstance(_, ciEnt, {
		jsonWhere: {
			cs: "TEST"
		}
	});
	ok(ci != null, "Case sensitive fetch of case sensitive prop ok");
	// fetch case insensitive
	ci = db.fetchInstance(_, ciEnt, {
		jsonWhere: {
			ci: "test"
		}
	});
	ok(ci != null, "Case insensitive fetch of case insensitive prop ok");
	ci = db.fetchInstance(_, ciEnt, {
		jsonWhere: {
			cs: "test"
		}
	});
	ok(ci == null, "Case insensitive fetch of case sensitive prop ok");
	// unique key
	ci = ciEnt.createInstance(_, db);
	ci.ci(_, "TEST");
	tracer && tracer("ci status (445): " + sys.inspect(ci.$properties.ci));
	var diag = ci.$properties && ci.$properties.ci && ci.$properties.ci.$diagnoses;
	ok(diag && diag.some(function(d) {
		return (d.$severity || d.severity) === "error";
	}), "Case sensitive unique test ok");
	ci = ciEnt.createInstance(_, db);
	ci.ci(_, "test");
	var diag = ci.$properties && ci.$properties.ci && ci.$properties.ci.$diagnoses;
	ok(diag && diag.some(function(d) {
		return (d.$severity || d.severity) === "error";
	}), "Case insensitive unique test ok");

	start();
});

asyncTest("polymorphic relations", 8, function(_) {
	var refAEnt = db.getEntity(_, "refA");
	var refBEnt = db.getEntity(_, "refB");
	var refCEnt = db.getEntity(_, "refC");
	//
	var refA1 = refAEnt.createInstance(_, db);
	refA1.description(_, "poly_A");
	refA1.prop1(_, "prop1_A");
	refA1.save(_);
	var refB1 = refBEnt.createInstance(_, db);
	refB1.description(_, "poly_B");
	refB1.prop1(_, "prop1_B");
	refB1.save(_);
	var refC1 = refCEnt.createInstance(_, db);
	refC1.description(_, "poly_C");
	refC1.save(_);
	//
	var polyEnt = db.getEntity(_, "polymorph");
	// 
	var pp = polyEnt.createInstance(_, db);
	pp.description(_, "pA");
	pp.poly(_, refA1, false, "A");
	pp.save(_);
	var pp = polyEnt.createInstance(_, db);
	pp.description(_, "pB");
	pp.poly(_, refB1, false, "B");
	pp.save(_);
	var pp = polyEnt.createInstance(_, db);
	pp.description(_, "pC");
	pp.poly(_, refC1, false, "C");
	pp.save(_);
	// test
	var pp = db.fetchInstance(_, polyEnt, {
		jsonWhere: {
			description: "pA"
		}
	});
	ok(pp != null, "pA fetched ok");
	ok(pp && pp.poly && pp.poly(_) && pp.poly(_).description(_) === "poly_A", "Poly A relation ok");
	var res = pp.serializeInstance(_);
	tracer && tracer("(551) PA " + sys.inspect(res));
	ok(res && res.poly && res.poly.A && (res.poly.A.prop1 == null), "Reference fetched no properties ok");
	//
	var pp = db.fetchInstance(_, polyEnt, {
		jsonWhere: {
			description: "pB"
		}
	});
	ok(pp != null, "pB fetched ok");
	ok(pp && pp.poly && pp.poly(_) && pp.poly(_).description(_) === "poly_B", "Poly B relation ok");
	var res = pp.serializeInstance(_);
	tracer && tracer("(551) PB " + sys.inspect(res));
	strictEqual(res.poly.B.prop1, "prop1_B", "Reference fetched with properties ok");
	//
	var pp = db.fetchInstance(_, polyEnt, {
		jsonWhere: {
			description: "pC"
		}
	});
	ok(pp != null, "pC fetched ok");
	ok(pp && pp.poly && pp.poly(_) && pp.poly(_).description(_) === "poly_C", "Poly C relation ok");
	// TODO: test with a class not in $variants, should throw exception

	start();
});

asyncTest("atomic counter", 24, function(_) {
	strictEqual(db.getCounterValue(_, "dom1", "code1", {
		increment: 1
	}).value, 1, "Counter first val ok");
	strictEqual(db.getCounterValue(_, "dom1", "code1", {
		increment: 10
	}).value, 11, "Counter increment 10 val ok");
	strictEqual(db.getCounterValue(_, "dom1", "code1", {
		increment: 1
	}).value, 12, "Counter increment true val ok");
	strictEqual(db.getCounterValue(_, "dom1", "code2", {
		increment: 1
	}).value, 1, "Counter code isolation val ok");
	strictEqual(db.getCounterValue(_, "dom2", "code1", {
		increment: 10
	}).value, 10, "Counter domain isolation val ok");
	// no increment
	strictEqual(db.getCounterValue(_, "dom2", "code1").value, 10, "No increment val ok");
	strictEqual(db.getCounterValue(_, "dom2", "code1").value, 10, "No increment val (2) ok");
	// set value
	strictEqual(db.getCounterValue(_, "dom1", "code1", {
		value: 13
	}).value, 13, "Counter set value on existing counter ok");
	strictEqual(db.getCounterValue(_, "dom1", "code1", {
		increment: 2,
		value: 20
	}).value, 15, "Counter increment/value on precedence ok");
	strictEqual(db.getCounterValue(_, "dom1", "code3", {
		value: 5
	}).value, 5, "Counter set value on new counter ok");
	// data
	var cnt = db.getCounterValue(_, "dom1", "code4", {
		data: {
			first: 1,
			deep: {
				deeper: {
					val: "is deep"
				}
			}
		}
	});
	ok(cnt.value == null, "Counter value not defined ok");
	strictEqual(cnt.data.first, 1, "Counter data ok (1.0)");
	strictEqual(cnt.data.deep.deeper.val, "is deep", "Counter data ok (1.1)");
	var cnt = db.getCounterValue(_, "dom1", "code4", {
		data: {
			deep: {
				deeper: {
					val: "is even deeper"
				}
			}
		}
	});
	strictEqual(cnt.data.first, 1, "Counter data ok (2.0)");
	strictEqual(cnt.data.deep.deeper.val, "is even deeper", "Counter data ok (2.1)");
	var cnt = db.getCounterValue(_, "dom1", "code4", {
		increment: 2,
		data: {
			first: 5
		}
	});
	strictEqual(cnt.value, 2, "Counter increment and data ok");
	strictEqual(cnt.data.first, 5, "Counter data ok (3.0)");
	strictEqual(cnt.data.deep.deeper.val, "is even deeper", "Counter data ok (3.1)");
	// just read
	var cnt = db.getCounterValue(_, "dom1", "code4");
	strictEqual(cnt.value, 2, "Counter increment and data ok");
	strictEqual(cnt.data.first, 5, "Counter data ok (4.0)");
	strictEqual(cnt.data.deep.deeper.val, "is even deeper", "Counter data ok (4.1)");
	// update data only on existing
	var cnt = db.getCounterValue(_, "dom2", "code1", {
		increment: 1,
		data: {
			first: "aa",
			second: "bb"
		}
	});
	strictEqual(cnt.value, 11, "Combined update value ok");
	strictEqual(cnt.data.first, "aa", "Combined update data 1 ok");
	strictEqual(cnt.data.second, "bb", "Combined update data 2 ok");

	start();
});

asyncTest("stop  tests", 0, function(_) {
	doStop = true;
	start();
});