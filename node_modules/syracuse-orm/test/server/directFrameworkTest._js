"use strict";

var helpers = require('@sage/syracuse-core').helpers;
var uuid = helpers.uuid;
var forEachKey = helpers.object.forEachKey;
var config = require('config'); // must be first syracuse require
var dataModel = require("syracuse-orm/lib/dataModel");
var registry = require("syracuse-sdata/lib/sdataRegistry");
var mongodb = require('mongodb');
var sys = require("util");
var factory = require("syracuse-orm/lib/factory");
var checksum = require("syracuse-orm/lib/checksum");
var signSerializer = new(require("syracuse-orm/lib/serializer").SignSerializer)();
var locale = require('streamline-locale');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
// make unit test run with old and new module structure
try {
	var globals = require('streamline-runtime').globals;
} catch (e) {
	var globals = require('streamline/lib/globals');
}
//
var tracer; // = console.log;
//force basic auth
config.session = config.session || {};
config.session.auth = "basic";
config.session.ignoreStoreSession = true;
//no integration server
config.integrationServer = null;

//add model
var testAdmin = require('@sage/syracuse-core').apis.get('test-admin');
var endPoint = testAdmin.modifyCollaborationEndpoint("mongodb_example");
var testEp = {
	contract: require("test-contract/lib/contract").contract,
	datasets: {
		test: {
			driver: "mongodb",
			database: "test",
			hostname: config.collaboration.hostname || "localhost",
			port: config.collaboration.port || 27017
		}
	}
};
registry.register([testEp]);

config.sdata.endpoints.push(endPoint);
endPoint.contract.datasets = endPoint.datasets;

var port = (config.unit_test && config.unit_test.serverPort) || 3004;
var db;
//

function _getModel() {
	return dataModel.make(testEp.contract, "test");
}
//
QUnit.module(module.id, {});

asyncTest("init database", 1, function(_) {
	var server = new mongodb.Server(endPoint.datasets["mongodb_example"].hostname, endPoint.datasets["mongodb_example"].port, {});
	var _db = testAdmin.newMongoDb(endPoint.datasets["mongodb_example"].database, server, {});
	_db = _db.open(_);
	_db.dropDatabase(_);
	var server = new mongodb.Server(testEp.datasets["test"].hostname, testEp.datasets["test"].port, {});
	var _db = testAdmin.newMongoDb(testEp.datasets["test"].database, server, {});
	_db = _db.open(_);
	_db.dropDatabase(_);
	ok(true, "mongodb initialized");

	start();
});

//start syracuse server
asyncTest("initialize syracuse test server", 1, function(_) {
	require('syracuse-main/lib/syracuse').startServers(_, port);
	ok(true, "server initialized");
	start();
});

asyncTest("get database handle", 1, function(_) {
	var ep = adminHelper.getEndpoint(_, {
		dataset: "syracuse"
	});
	if (ep) {
		ep.dataset(_, "mongodb_example");
		var res = ep.save(_);
	}
	var adminDb = ep.getOrm(_);
	var ap = adminDb.getEntity(_, "application").createInstance(_, adminDb);
	ap.description(_, "test");
	ap.application(_, "example");
	ap.contract(_, "admin");
	ap.protocol(_, "syracuse");
	ap.save(_);
	var ep = adminDb.getEntity(_, "endPoint").createInstance(_, adminDb);
	ep.description(_, "test");
	ep.applicationRef(_, ap);
	ep.dataset(_, "test");
	ep.databaseHost(_, testEp.datasets.test.hostname);
	ep.databasePort(_, testEp.datasets.test.port);
	var res = ep.save(_);
	ok(ep.getModel(_) != null, "Test endpoint ok");
	//
	db = ep.getOrm(_);

	start();
});

asyncTest("lock test", 11, function(_) {
	try {
		var instance = {
			$uuid: "1234567890"
		};
		var session0 = globals.context.session;
		try {
			globals.context.session = {
				id: "1",
				getUserLogin: function(_) {
					return "testuser";
				}
			};
			// unlock instance (maybe there is old lock on it)
			db.unlockInstance(_, instance);
			var res = db.lockInstance(_, instance);
			strictEqual(res.status, "success", "Aquire lock");
			var res = db.lockInstance(_, instance);
			strictEqual(res.status, "success", "Aquire lock in same session");
			globals.context.session.id = "2";
			var res = db.lockInstance(_, instance);
			strictEqual(res.status, "locked", "Aquire lock in second session");
			if (res.lock) {
				strictEqual(res.lock._id, instance.$uuid, "correct lock ID");
				strictEqual(res.lock.sessionId, "1", "correct session ID");
			}
			globals.context.session.id = "1";
			var res = db.lockInstance(_, instance);
			strictEqual(res.status, "success", "Aquire lock in initial session");
			db.unlockInstance(_, instance);
			globals.context.session.id = "2";
			var res = db.lockInstance(_, instance);
			strictEqual(res.status, "success", "Aquire lock in second session after releasing lock");
			db.unlockInstance(_, instance);
			// now real session IDs
			db.unlockInstance(_, instance);
			globals.context.session = {
				id: "00000000-0000-0000-0000-000000000000",
				getUserLogin: function(_) {
					return "testuser";
				}
			};
			var coll = db.db.collection("SessionInfo", _);
			var result = coll.update({
				_id: "00000000-0000-0000-0000-000000000000"
			}, {
				sid: "00000000-0000-0000-0000-000000000000"
			}, {
				safe: true,
				upsert: true
			}, _);
			var res = db.lockInstance(_, instance);
			strictEqual(res.status, "success", "Aquire lock");
			var res = db.lockInstance(_, instance);
			strictEqual(res.status, "success", "Aquire lock in same session");
			globals.context.session.id = "00000000-0000-0000-0000-000000000001";
			var res = db.lockInstance(_, instance);
			strictEqual(res.status, "locked", "Aquire lock in second session");
			var dbresult = coll.remove({
				_id: "00000000-0000-0000-0000-000000000000"
			}, {
				safe: true
			}, _);
			var res = db.lockInstance(_, instance);
			strictEqual(res.status, "success", "First session does not exist any more");
		} finally {
			globals.context.session = session0;
		}
	} catch (e) {
		console.log("ERR " + e.stack);
	}
	start();
});
asyncTest("list snapshot test", 5, function(_) {
	// make a country
	var countryEntity = db.model.getEntity(_, "country");
	var country = countryEntity.factory.createInstance(_, null, db);
	country.code(_, "FR");
	country.description(_, "France");
	country.save(_);
	// deep navigate conditions
	var addressEntity = db.model.getEntity(_, "address");
	var address = addressEntity.factory.createInstance(_, null, db);
	address.country(_, country);
	var userEntity = db.model.getEntity(_, "user");
	var user = userEntity.factory.createInstance(_, null, db);
	user.lastName(_, "TestUser");
	user.address(_, address);
	var postEntity = db.model.getEntity(_, "post");
	var post1 = postEntity.factory.createInstance(_, null, db);
	post1.postNum(_, 1);
	user.posts(_).set(_, post1);
	tracer && tracer("before user save (88)");
	user.save(_);
	tracer && tracer("after user save (89)");
	var diag = [];
	user.getAllDiagnoses(_, diag);
	ok(diag.length == 0, "User saved ok");
	// reset user entity
	tracer && tracer("after user save (94); diags: " + sys.inspect(diag, null, 4));
	user = db.fetchInstance(_, userEntity, user.$uuid);
	ok(user != null, "User fetch ok");
	var post2 = postEntity.factory.createInstance(_, null, db);
	post2.postNum(_, 2);
	user.posts(_).set(_, post2);
	strictEqual(user.posts(_).getLength(), 2, "Posts count ok");
	strictEqual(user.$snapshot.posts(_).getLength(), 1, "Snapshot posts count ok");
	tracer && tracer("posts (99): " + sys.inspect(user.$snapshot.posts(_), null, 4));
	tracer && tracer("snapshot posts (100): " + sys.inspect(user.$snapshot.posts(_), null, 4));
	var snapList = user.$snapshot.posts(_).toArray(_);
	tracer && tracer("snapshot posts array (102): " + sys.inspect(snapList, null, 4));
	strictEqual(snapList[0].postNum(_), 1, "Got postnum ok");
	//
	start();
});

asyncTest("cursor test", 4, function(_) {
	//	var db = dataModel.getOrm(_, _getModel(), endPoint.datasets.mongodb_example);
	// add second country
	var countryEntity = db.model.getEntity(_, "country");
	var country = countryEntity.factory.createInstance(_, null, db);
	country.code(_, "US");
	country.description(_, "US");
	country.save(_);
	//
	var cursor = db.createCursor(_, countryEntity, {
		jsonWhere: {},
		orderBy: [{
			binding: "code",
			descending: true
		}]
	});
	var data = cursor.next(_);
	ok(data != null, "data fetch ok");
	strictEqual(data.code(_), "US", "fetched US ok");
	var data = cursor.next(_);
	ok(data != null, "data fetch ok");
	strictEqual(data.code(_), "FR", "fetched FR ok");
	//
	start();
});

asyncTest("Collections management test", 8, function(_) {
	var refAEnt = db.getEntity(_, "refA");
	var refDEnt = db.getEntity(_, "refD");
	//
	var refA1 = refAEnt.createInstance(_, db);
	var refA2 = refAEnt.createInstance(_, db);
	var refD1 = refDEnt.createInstance(_, db);
	var refD2 = refDEnt.createInstance(_, db);
	refA1.refDList(_).set(_, refD1);
	refA1.refDList(_).set(_, refD2);
	refA2.refDList(_).set(_, refD1);
	refA2.refDList(_).set(_, refD2);
	refD1.refAList(_).set(_, refA1);
	refD1.refAList(_).set(_, refA2);
	refD2.refAList(_).set(_, refA1);
	refD2.refAList(_).set(_, refA2);
	strictEqual(refA1.refDList(_).getLength(), 2, "Length A1 ok");
	strictEqual(refA2.refDList(_).getLength(), 2, "Length A2 ok");
	strictEqual(refD1.refAList(_).getLength(), 2, "Length D1 ok");
	strictEqual(refD2.refAList(_).getLength(), 2, "Length D2 ok");
	//
	refA1.refDList(_).deleteInstance(_, refD1.$uuid);
	strictEqual(refA1.refDList(_).getLength(), 2, "Length A1 after delete ok");
	strictEqual(refD1.refAList(_).getLength(), 2, "Length D1 after delete ok");
	// save and reload
	// TODO: FIX FIRST circular reference when save(_) beacause of relatedInstances
	tracer && tracer("refA1related: " + sys.inspect(refA1._relatedInst));
	tracer && tracer("refA2related: " + sys.inspect(refA2._relatedInst));
	tracer && tracer("refD1related: " + sys.inspect(refD1._relatedInst));
	tracer && tracer("refD2related: " + sys.inspect(refD2._relatedInst));
	refA1.save(_);
	refA2.save(_);
	refD1.save(_);
	refD2.save(_);
	//
	refA1 = db.fetchInstance(_, refAEnt, refA1.$uuid);
	refD1 = db.fetchInstance(_, refDEnt, refD1.$uuid);
	strictEqual(refA1.refDList(_).getLength(), 1, "Length A1 after delete ok");
	strictEqual(refD1.refAList(_).getLength(), 1, "Length D1 after delete ok");
	//
	start();
});

asyncTest("circular navigation test", 1, function(_) {
	var refAEnt = db.getEntity(_, "refA");
	var refBEnt = db.getEntity(_, "refB");
	//
	var refA1 = refAEnt.createInstance(_, db);
	refA1.description(_, "nav_test_1");
	refA1.save(_);
	var refB1 = refBEnt.createInstance(_, db);
	refA1.refBList(_).set(_, refB1);
	// modify soemthing
	refA1.description(_, "nav_test_2");
	// navigate
	tracer && tracer("before navigate: (197)");
	refB1.refAList(_).get(_, refA1.$uuid);
	tracer && tracer("after navigate: (199)");
	// check value
	strictEqual(refA1.description(_), "nav_test_2", "Modified value still ok");

	start();
});

asyncTest("storage area API test", 11, function(_) {
	//	var db = dataModel.getOrm(_, _getModel(), endPoint.datasets.mongodb_example);
	//
	var storeTestEntity = db.model.getEntity(_, "storeTest");
	// db_file mode
	var storeInst = storeTestEntity.factory.createInstance(_, null, db);
	var store = storeInst.content(_);
	var w = store.createWritableStream(_, {
		fileName: "test.txt"
	});
	// make 2 writes
	w.write(_, "012", "utf8");
	w.write(_, "345", "utf8");
	w.write(_, null);
	//store.write(_, "012345");
	// create readable store
	var r = store.createReadableStream(_);
	var buf;
	var res = "";
	while (buf = r.read(_))
		res += buf;
	strictEqual(res, "012345", "Simple content write/read ok");
	storeInst.save(_);
	var storeInstUuid = storeInst.$uuid;
	var dbFileName = storeInst.content(_).getUuid();
	// reload from db
	storeInst = db.fetchInstance(_, storeTestEntity, storeInstUuid);
	// retest read
	var r = (store = storeInst.content(_)).createReadableStream(_);
	var buf;
	var res = "";
	while (buf = r.read(_))
		res += buf;
	strictEqual(res, "012345", "Simple content write/read ok");
	// working copy mode test
	// create a store wc
	store.createWorkingCopy(_);
	w = store.createWritableStream(_, {
		fileName: "test1.txt"
	});
	w.write(_, "new file");
	w.write(_, null);
	var dbNewFileName = store.getUuid();
	ok(dbNewFileName != dbFileName, "Created new file ok");
	// both files exists now
	ok(mongodb.GridStore.exist(db.db, dbFileName, _), "Old file exists ok");
	ok(mongodb.GridStore.exist(db.db, dbNewFileName, _), "New file exists ok");
	//
	storeInst.save(_);
	// old file should have been deleted
	ok(!mongodb.GridStore.exist(db.db, dbFileName, _), "Db file deleted ok");
	dbFileName = dbNewFileName;
	// recreate a Wc, after save the old file should be deleted
	store.createWorkingCopy(_);
	// the file should stil exist before final save
	ok(mongodb.GridStore.exist(db.db, dbFileName, _), "File stil exists ok");
	storeInst.save(_);
	// the file should stil exist before final save
	ok(!mongodb.GridStore.exist(db.db, dbFileName, _), "File is deleted ok");
	//
	// delete store inst
	storeInst.deleteSelf(_);
	// check inst deleted
	storeInst = db.fetchInstance(_, storeTestEntity, storeInstUuid);
	ok(!storeInst, "Store inst deleted ok");
	// check file deleted
	ok(!mongodb.GridStore.exist(db.db, dbFileName, _), "Db file deleted ok");
	// file mode
	var storeInst = storeTestEntity.factory.createInstance(_, null, db);
	storeInst.storageType(_, "file");
	var store = storeInst.content(_);
	store._store.setFile(_, require("path").join(__dirname, "rsrc", "stringReaderTest.txt"));
	var r = store.createReadableStream(_);
	var buf;
	var res = "";
	while (buf = r.read(_))
		res += buf;
	strictEqual(res, "a string to read", "File storage read ok");

	//
	start();
});

function _unescape(obj, dbProp, objProp) {
	obj[objProp] = obj[dbProp];
	delete obj[dbProp];
}

asyncTest("Signed objects", 6, function(_) {
	var signedEnt = db.getEntity(_, "signedTests");
	var signed = signedEnt.createInstance(_, db);
	signed.description(_, "Sign test");
	var r = signed.save(_);
	ok(!(r.$diagnoses || []).some(function(d) {
		return d.severity === "error";
	}), "Signed saved ok");
	// check signature
	var dbObj = (db.db.collection("SignedTest", _).find({
		description: "Sign test"
	}).toArray(_))[0];
	// unescape
	/*	Object.keys(dbObj).forEach(function(prop) {
		if(prop === "_id")
			db.unescapeJson(dbObj, prop, "$uuid");
		else
			if(prop[0] === "_")
				db.unescapeJson(dbObj, prop, "$" + prop.slice(1));
	});*/
	dbObj.$uuid = dbObj._id;
	delete dbObj._id;
	dbObj = signSerializer.serializeResource(signedEnt, db.unescapeJson(dbObj));
	//
	ok(checksum.verify(dbObj, ["_id", "$key", "$loaded"]), "Signature verified from db");
	// try to fetch
	var obj = db.fetchInstance(_, signedEnt, {
		jsonWhere: {
			description: "Sign test"
		}
	});
	strictEqual(obj.description(_), "Sign test", "Signed object fetch ok");
	// modification test
	obj.description2(_, "desc2");
	var r = obj.save(_);
	ok(!(r.$diagnoses || []).some(function(d) {
		return d.severity === "error";
	}), "Signed saved ok (2)");
	// try to fetch
	var obj = db.fetchInstance(_, signedEnt, {
		jsonWhere: {
			description: "Sign test"
		}
	});
	strictEqual(obj.description2(_), "desc2", "Signed object fetch ok (2)");

	// direct database modification
	db.db.collection("SignedTest", _).update({
		description: "Sign test"
	}, {
		$set: {
			description: "Changed sign"
		}
	}, {
		safe: true,
		multi: true
	}, _);
	// try to fetch - should get an error
	try {
		var obj = db.fetchInstance(_, signedEnt, {
			jsonWhere: {
				description: "Changed sign"
			}
		});
		ok(false, "NOT ok, should have got an error");
	} catch (e) {
		ok(true, "Fetch error of changed object ok");
	}

	start();
});

asyncTest("localized properties test", 9, function(_) {
	var locEnt = db.getEntity(_, "localized");
	//
	locale.setCurrent(_, "en-US");
	// create an instance and set en-US only.
	var loc = locEnt.createInstance(_, db);
	loc.description(_, "english text");
	loc.save(_);
	//
	var prop = loc.getPropAllLocales(_, "description");
	strictEqual(prop["default"], "english text", "Default prop ok");
	strictEqual(prop["en-us"], "english text", "en-US prop ok");
	// filter in en-US: must find
	var loc = db.fetchInstance(_, locEnt, {
		jsonWhere: {
			description: "english text"
		}
	});
	ok(loc != null, "Filter in english found ok");
	// test fr-FR
	locale.setCurrent(_, "fr-FR");
	// filter in fr-FR: must find using default property
	var loc = db.fetchInstance(_, locEnt, {
		jsonWhere: {
			description: "english text"
		}
	});
	ok(loc != null, "Filter in french found ok");
	// modify french text
	loc.description(_, "french text");
	var prop = loc.getPropAllLocales(_, "description");
	strictEqual(prop["default"], "english text", "Default prop ok");
	strictEqual(prop["en-us"], "english text", "en-US prop ok");
	strictEqual(prop["fr-fr"], "french text", "fr-FR prop ok");
	loc.save(_);
	// filter in fr-FR: must NOT find using because there is a text in fr-FR
	var loc = db.fetchInstance(_, locEnt, {
		jsonWhere: {
			description: "english text"
		}
	});
	ok(loc == null, "Filter in french NOT found ok");
	// filter in fr-FR: must find french text
	var loc = db.fetchInstance(_, locEnt, {
		jsonWhere: {
			description: "french text"
		}
	});
	ok(loc != null, "Filter in french found ok");

	start();
});

asyncTest("case insensitive properties", 6, function(_) {
	var ciEnt = db.getEntity(_, "caseInsensitive");
	var ci = ciEnt.createInstance(_, db);
	ci.ci(_, "TEST");
	ci.cs(_, "TEST");
	ci.save(_);
	// fetch case sensitive
	ci = db.fetchInstance(_, ciEnt, {
		jsonWhere: {
			ci: "TEST"
		}
	});
	ok(ci != null, "Case sensitive fetch of case insensitive prop ok");
	ci = db.fetchInstance(_, ciEnt, {
		jsonWhere: {
			cs: "TEST"
		}
	});
	ok(ci != null, "Case sensitive fetch of case sensitive prop ok");
	// fetch case insensitive
	ci = db.fetchInstance(_, ciEnt, {
		jsonWhere: {
			ci: "test"
		}
	});
	ok(ci != null, "Case insensitive fetch of case insensitive prop ok");
	ci = db.fetchInstance(_, ciEnt, {
		jsonWhere: {
			cs: "test"
		}
	});
	ok(ci == null, "Case insensitive fetch of case sensitive prop ok");
	// unique key
	ci = ciEnt.createInstance(_, db);
	ci.ci(_, "TEST");
	tracer && tracer("ci status (445): " + sys.inspect(ci.$properties.ci));
	var diag = ci.$properties && ci.$properties.ci && ci.$properties.ci.$diagnoses;
	ok(diag && diag.some(function(d) {
		return (d.$severity || d.severity) === "error";
	}), "Case sensitive unique test ok");
	ci = ciEnt.createInstance(_, db);
	ci.ci(_, "test");
	var diag = ci.$properties && ci.$properties.ci && ci.$properties.ci.$diagnoses;
	ok(diag && diag.some(function(d) {
		return (d.$severity || d.severity) === "error";
	}), "Case insensitive unique test ok");

	start();
});

asyncTest("polymorphic relations", 8, function(_) {
	var refAEnt = db.getEntity(_, "refA");
	var refBEnt = db.getEntity(_, "refB");
	var refCEnt = db.getEntity(_, "refC");
	//
	var refA1 = refAEnt.createInstance(_, db);
	refA1.description(_, "poly_A");
	refA1.prop1(_, "prop1_A");
	refA1.save(_);
	var refB1 = refBEnt.createInstance(_, db);
	refB1.description(_, "poly_B");
	refB1.prop1(_, "prop1_B");
	refB1.save(_);
	var refC1 = refCEnt.createInstance(_, db);
	refC1.description(_, "poly_C");
	refC1.save(_);
	//
	var polyEnt = db.getEntity(_, "polymorph");
	// 
	var pp = polyEnt.createInstance(_, db);
	pp.description(_, "pA");
	pp.poly(_, refA1, false, "A");
	pp.save(_);
	var pp = polyEnt.createInstance(_, db);
	pp.description(_, "pB");
	pp.poly(_, refB1, false, "B");
	pp.save(_);
	var pp = polyEnt.createInstance(_, db);
	pp.description(_, "pC");
	pp.poly(_, refC1, false, "C");
	pp.save(_);
	// test
	var pp = db.fetchInstance(_, polyEnt, {
		jsonWhere: {
			description: "pA"
		}
	});
	ok(pp != null, "pA fetched ok");
	ok(pp && pp.poly && pp.poly(_) && pp.poly(_).description(_) === "poly_A", "Poly A relation ok");
	var res = pp.serializeInstance(_);
	tracer && tracer("(551) PA " + sys.inspect(res));
	ok(res && res.poly && res.poly.A && (res.poly.A.prop1 == null), "Reference fetched no properties ok");
	//
	var pp = db.fetchInstance(_, polyEnt, {
		jsonWhere: {
			description: "pB"
		}
	});
	ok(pp != null, "pB fetched ok");
	ok(pp && pp.poly && pp.poly(_) && pp.poly(_).description(_) === "poly_B", "Poly B relation ok");
	var res = pp.serializeInstance(_);
	tracer && tracer("(551) PB " + sys.inspect(res));
	strictEqual(res.poly.B.prop1, "prop1_B", "Reference fetched with properties ok");
	//
	var pp = db.fetchInstance(_, polyEnt, {
		jsonWhere: {
			description: "pC"
		}
	});
	ok(pp != null, "pC fetched ok");
	ok(pp && pp.poly && pp.poly(_) && pp.poly(_).description(_) === "poly_C", "Poly C relation ok");
	// TODO: test with a class not in $variants, should throw exception

	start();
});

asyncTest("atomic counter", 24, function(_) {
	strictEqual(db.getCounterValue(_, "dom1", "code1", {
		increment: 1
	}).value, 1, "Counter first val ok");
	strictEqual(db.getCounterValue(_, "dom1", "code1", {
		increment: 10
	}).value, 11, "Counter increment 10 val ok");
	strictEqual(db.getCounterValue(_, "dom1", "code1", {
		increment: 1
	}).value, 12, "Counter increment true val ok");
	strictEqual(db.getCounterValue(_, "dom1", "code2", {
		increment: 1
	}).value, 1, "Counter code isolation val ok");
	strictEqual(db.getCounterValue(_, "dom2", "code1", {
		increment: 10
	}).value, 10, "Counter domain isolation val ok");
	// no increment
	strictEqual(db.getCounterValue(_, "dom2", "code1").value, 10, "No increment val ok");
	strictEqual(db.getCounterValue(_, "dom2", "code1").value, 10, "No increment val (2) ok");
	// set value
	strictEqual(db.getCounterValue(_, "dom1", "code1", {
		value: 13
	}).value, 13, "Counter set value on existing counter ok");
	strictEqual(db.getCounterValue(_, "dom1", "code1", {
		increment: 2,
		value: 20
	}).value, 15, "Counter increment/value on precedence ok");
	strictEqual(db.getCounterValue(_, "dom1", "code3", {
		value: 5
	}).value, 5, "Counter set value on new counter ok");
	// data
	var cnt = db.getCounterValue(_, "dom1", "code4", {
		data: {
			first: 1,
			deep: {
				deeper: {
					val: "is deep"
				}
			}
		}
	});
	ok(cnt.value == null, "Counter value not defined ok");
	strictEqual(cnt.data.first, 1, "Counter data ok (1.0)");
	strictEqual(cnt.data.deep.deeper.val, "is deep", "Counter data ok (1.1)");
	var cnt = db.getCounterValue(_, "dom1", "code4", {
		data: {
			deep: {
				deeper: {
					val: "is even deeper"
				}
			}
		}
	});
	strictEqual(cnt.data.first, 1, "Counter data ok (2.0)");
	strictEqual(cnt.data.deep.deeper.val, "is even deeper", "Counter data ok (2.1)");
	var cnt = db.getCounterValue(_, "dom1", "code4", {
		increment: 2,
		data: {
			first: 5
		}
	});
	strictEqual(cnt.value, 2, "Counter increment and data ok");
	strictEqual(cnt.data.first, 5, "Counter data ok (3.0)");
	strictEqual(cnt.data.deep.deeper.val, "is even deeper", "Counter data ok (3.1)");
	// just read
	var cnt = db.getCounterValue(_, "dom1", "code4");
	strictEqual(cnt.value, 2, "Counter increment and data ok");
	strictEqual(cnt.data.first, 5, "Counter data ok (4.0)");
	strictEqual(cnt.data.deep.deeper.val, "is even deeper", "Counter data ok (4.1)");
	// update data only on existing
	var cnt = db.getCounterValue(_, "dom2", "code1", {
		increment: 1,
		data: {
			first: "aa",
			second: "bb"
		}
	});
	strictEqual(cnt.value, 11, "Combined update value ok");
	strictEqual(cnt.data.first, "aa", "Combined update data 1 ok");
	strictEqual(cnt.data.second, "bb", "Combined update data 2 ok");

	start();
});

asyncTest("fetch from url", 2, function(_) {
	var inst = factory.fetchFromUrl(_, "/sdata/example/admin/test/countries(code eq 'FR')");
	ok(inst && inst.code(_) === "FR", "Fetch from url with expression ok");
	//
	inst = factory.fetchFromUrl(_, "/sdata/example/admin/test/countries('" + inst.$uuid + "')");
	ok(inst && inst.code(_) === "FR", "Fetch from url with $uuid ok");

	start();
});

asyncTest("safe call test", 27, function(_) {

	// function _safeCall(callback, instance, propName, fn, field, val) {

	var _safeCall = factory._sc;

	var fn_rec = function(_, i, val) {
		return _safeCall(_, i, "propName", fn_rec, "field", val);
	};

	var fn_long = function(_, i, val) {
		setTimeout(_, 3000);
		return "long_" + val;
	};
	var fn_short = function(_, i, val) {
		setTimeout(_, 1000);
		return "short_" + val;
	};

	var fn_error = function(_, i, val) {
		setTimeout(_, 1000);
		throw new Error("error_" + val);
	};

	var instance = {
		errors: [],
		$addError: function(x) {
			this.errors.push(x);
		}
	};
	// cause internal error
	var res = _safeCall(_, {}, "propName", fn_rec, "field", "val");
	ok(true, "Internal error handled");



	// recursive invocation
	var res = _safeCall(_, instance, "propName", fn_rec, "field", "val");
	strictEqual(instance.errors.length, 1, "One error in recursion");
	strictEqual(instance.errors[0].indexOf("Timeout for executing wrapper for propName") >= 0, true, "One error in recursion");
	instance.errors = [];
	var fut1 = _safeCall(!_, instance, "propName", fn_long, "field", "val");
	var fut2 = _safeCall(!_, instance, "propName", fn_long, "field", "val");
	var res = fut1(_);
	strictEqual(res, "long_val", "Correct result for first long invocation");
	try {
		fut2(_);
		ok(false, "No error for second long invocation");
	} catch (e) {
		strictEqual(e.message, "Timeout for executing wrapper for propName", "Timeout for second long invocation");
	}
	strictEqual(instance.errors.length, 0, "No error in short invocations");
	instance.errors = [];



	var fut1 = _safeCall(!_, instance, "propName", fn_short, "field", "val");
	var fut2 = _safeCall(!_, instance, "propName", fn_short, "field", "val");
	var res = fut1(_);
	strictEqual(res, "short_val", "Correct result for first short invocation");
	var res = fut2(_);
	strictEqual(res, "short_val", "Correct result for second short invocation");
	strictEqual(instance.errors.length, 0, "No error in short invocations");

	var fut1 = _safeCall(!_, instance, "propName", fn_short, "field", "val");
	var res = _safeCall(_, instance, "propName", fn_short, "field", "val2");
	strictEqual(res, "short_val2", "Correct result for first invocation with different results");
	strictEqual(fut1(_), "short_val", "Correct result for second invocation with different results");
	strictEqual(instance.errors.length, 0, "No error in short invocations");

	var fut1 = _safeCall(!_, instance, "propName", fn_error, "field", "val");
	var res = _safeCall(_, instance, "propName", fn_error, "field", "val2");
	strictEqual(res, undefined, "Correct result for first invocation with error function");
	strictEqual(fut1(_), undefined, "Correct result for second invocation with error function");
	strictEqual(instance.errors.length, 2, "2 errors in error invocations")
	strictEqual(instance.errors[0].indexOf("error_val") >= 0, true, "First error in error invocations")
	strictEqual(instance.errors[1].indexOf("error_val2") >= 0, true, "Second error in error invocations")
	instance.errors = [];
	var fut1 = _safeCall(!_, instance, "propName", fn_short, "field", "val");
	var fut2 = _safeCall(!_, instance, "propName", fn_long, "field", "val");
	var res = fut1(_);
	strictEqual(res, "short_val", "Correct result for first invocation with different functions")
	var res = fut2(_);
	strictEqual(res, "long_val", "Correct result for second invocation with different functions");
	strictEqual(instance.errors.length, 0, "No error in invocations with different functions")

	// many invocations at the same time
	var fut1 = _safeCall(!_, instance, "propName", fn_short, "field", "val");
	var fut2 = _safeCall(!_, instance, "propName", fn_short, "field", "val");
	var fut3 = _safeCall(!_, instance, "propName", fn_short, "field", "val2");
	var fut4 = _safeCall(!_, instance, "propName", fn_short, "field", "val");
	var res = fut1(_);
	strictEqual(res, "short_val", "Correct result for first short invocation")
	var res = fut2(_);
	strictEqual(res, "short_val", "Correct result for second short invocation");
	var res = fut3(_);
	strictEqual(res, "short_val2", "Correct result for third short invocation");
	var res = fut4(_);
	strictEqual(res, "short_val", "Correct result for forth short invocation");
	strictEqual(instance.errors.length, 0, "No error in short invocations")

	var futures = [];
	for (var i = 0; i < 13; i++) {
		futures.push(_safeCall(!_, instance, "propName", fn_short, "field", "val"));
	}
	strictEqual(futures[0](_), "short_val", "Correct first result for first multiple execution")
	var errorcase = "";
	for (var i = 1; i < 13; i++) {
		try {
			futures[i](_);
			errorcase += "No error detected " + i
		} catch (e) {
			if (e.message.indexOf("Too many concurrent attempts to compute") < 0) {
				errorcase += "Wrong message " + e.message + " " + i;
			}
		}
	}
	strictEqual("", errorcase, "Handling many concurrent invocations")
	start();
});



asyncTest("stop  tests", 0, function(_) {
	doStop = true;
	start();
});