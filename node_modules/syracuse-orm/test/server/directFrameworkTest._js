"use strict";

var module = QUnit.module;
var helpers = require('syracuse-core/lib/helpers');
var uuid = helpers.uuid;
var forEachKey = helpers.object.forEachKey;
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var dataModel = require("syracuse-orm/lib/dataModel");
var registry = require("syracuse-sdata/lib/sdataRegistry");
var mongodb = require("mongodb");
var sys = require("util");
var factory = require("syracuse-orm/lib/factory");
var parser = require('syracuse-sdata/lib/parser/parser');
var checksum = require("syracuse-orm/lib/checksum");
//
var tracer = console.log;
//var tracer = null;
//force basic auth
config.session = config.session || {};
config.session.auth = "basic";
config.session.ignoreStoreSession = true;

//add model
var endPoint = {
	contract: require("test-contract/lib/contract").contract,
	datasets: {
		mongodb_example: {
			driver: "mongodb",
			port: 27017
		}
	}
};
config.sdata.endpoints.push(endPoint);
endPoint.contract.datasets = endPoint.datasets;

var baseUrl = "http://localhost:3004"
var contractUrl = "/sdata/example/admin/mongodb_example/";
var port = 3004;
var syracuse = require('syracuse-main/lib/syracuse');
var streams = require('streamline/lib/streams/streams');
var db;
//
function _getModel() {
	return dataModel.make(endPoint.contract, "mongodb_example");
}
//
var doStop = false;
module("directFrameworkTest", {
	setup: function() {},
	teardown: function() {
		if (doStop) {
			//syracuse.server.close();
			setTimeout(function() {
				process.kill(process.pid);
			}, 100)
		}
	}
});

asyncTest("init database", 1, function(_) {
	var server = new mongodb.Server(endPoint.datasets["mongodb_example"].hostname, endPoint.datasets["mongodb_example"].port, {});
	var _db = new mongodb.Db(endPoint.datasets["mongodb_example"].database, server, {});
	_db = _db.open(_);
	_db.dropDatabase(_);
	ok(true, "mongodb initialized");
	//
	db = dataModel.getOrm(_, _getModel(), endPoint.datasets.mongodb_example);
	//
	start();
});

asyncTest("list snapshot test", 5, function(_) {
	// make a country
	var countryEntity = db.model.getEntity("country");
	var country = countryEntity.factory.createInstance(_, null, db);
	country.code(_, "FR");
	country.description(_, "France");
	country.save(_);
	// deep navigate conditions
	var addressEntity = db.model.getEntity("address");
	var address = addressEntity.factory.createInstance(_, null, db);
	address.country(_, country);
	var userEntity = db.model.getEntity("user");
	var user = userEntity.factory.createInstance(_, null, db);
	user.lastName(_, "TestUser");
	user.address(_, address);
	var postEntity = db.model.getEntity("post");
	var post1 = postEntity.factory.createInstance(_, null, db);
	post1.postNum(_, 1);
	user.posts(_).set(_, post1);
	tracer && tracer("before user save (88)");
	user.save(_);
	tracer && tracer("after user save (89)");
	var diag = [];
	user.getAllDiagnoses(_, diag);
	ok(diag.length == 0, "User saved ok");
	// reset user entity
	tracer && tracer("after user save (94); diags: "+sys.inspect(diag, null, 4));
	user = db.fetchInstance(_, userEntity, user.$uuid);
	ok(user != null, "User fetch ok");
	var post2 = postEntity.factory.createInstance(_, null, db);
	post2.postNum(_, 2);
	user.posts(_).set(_, post2);
	strictEqual(user.posts(_).getLength(), 2, "Posts count ok");
	strictEqual(user.$snapshot.posts(_).getLength(), 1, "Snapshot posts count ok");
	tracer && tracer("posts (99): "+sys.inspect(user.$snapshot.posts(_), null, 4));
	tracer && tracer("snapshot posts (100): "+sys.inspect(user.$snapshot.posts(_), null, 4));
	var snapList = user.$snapshot.posts(_).toArray(_);
	tracer && tracer("snapshot posts array (102): "+sys.inspect(snapList, null, 4));
	strictEqual(snapList[0].postNum(_), 1, "Got postnum ok");
	//
	start();
});

asyncTest("cursor test", 4, function(_) {
//	var db = dataModel.getOrm(_, _getModel(), endPoint.datasets.mongodb_example);
	// add second country
	var countryEntity = db.model.getEntity("country");
	var country = countryEntity.factory.createInstance(_, null, db);
	country.code(_, "US");
	country.description(_, "US");
	country.save(_);
	//
	var cursor = db.createCursor(_, countryEntity, {
		jsonWhere: {},
		orderBy: [{binding:"code", descending: true}]
	});
	var data = cursor.next(_);
	ok(data != null, "data fetch ok");
	strictEqual(data.code(_), "US", "fetched US ok");
	var data = cursor.next(_);
	ok(data != null, "data fetch ok");
	strictEqual(data.code(_), "FR", "fetched FR ok");
	//
	start();
});

asyncTest("Collections management test", 8, function(_) {
	var refAEnt = db.getEntity(_, "refA");
	var refDEnt = db.getEntity(_, "refD");
	//
	var refA1 = refAEnt.createInstance(_, db);
	var refA2 = refAEnt.createInstance(_, db);
	var refD1 = refDEnt.createInstance(_, db);
	var refD2 = refDEnt.createInstance(_, db);
	refA1.refDList(_).set(_, refD1);
	refA1.refDList(_).set(_, refD2);
	refA2.refDList(_).set(_, refD1);
	refA2.refDList(_).set(_, refD2);
	refD1.refAList(_).set(_, refA1);
	refD1.refAList(_).set(_, refA2);
	refD2.refAList(_).set(_, refA1);
	refD2.refAList(_).set(_, refA2);
	strictEqual(refA1.refDList(_).getLength(), 2, "Length A1 ok");
	strictEqual(refA2.refDList(_).getLength(), 2, "Length A2 ok");
	strictEqual(refD1.refAList(_).getLength(), 2, "Length D1 ok");
	strictEqual(refD2.refAList(_).getLength(), 2, "Length D2 ok");
	//
	console.log("before delete (159)");
	refA1.refDList(_).deleteInstance(_, refD1.$uuid);
	console.log("after delete (161)");
	strictEqual(refA1.refDList(_).getLength(), 2, "Length A1 after delete ok");
	strictEqual(refD1.refAList(_).getLength(), 2, "Length D1 after delete ok");
	// save and reload
	// TODO: FIX FIRST circular reference when save(_) beacause of relatedInstances
	tracer && tracer("refA1related: "+sys.inspect(refA1._relatedInst));
	tracer && tracer("refA2related: "+sys.inspect(refA2._relatedInst));
	tracer && tracer("refD1related: "+sys.inspect(refD1._relatedInst));
	tracer && tracer("refD2related: "+sys.inspect(refD2._relatedInst));
	refA1.save(_);
	refA2.save(_);
	refD1.save(_);
	refD2.save(_);
	//
	refA1 = db.fetchInstance(_, refAEnt, refA1.$uuid);
	refD1 = db.fetchInstance(_, refDEnt, refD1.$uuid);
	strictEqual(refA1.refDList(_).getLength(), 1, "Length A1 after delete ok");
	strictEqual(refD1.refAList(_).getLength(), 1, "Length D1 after delete ok");
	//
	start();
});

asyncTest("storage area API test", 11, function(_) {
//	var db = dataModel.getOrm(_, _getModel(), endPoint.datasets.mongodb_example);
	//
	var storeTestEntity = db.model.getEntity("storeTest");
	// db_file mode
	var storeInst = storeTestEntity.factory.createInstance(_, null, db);
	var store = storeInst.content(_);
	var w = store.createWritableStream(_, {
		fileName: "test.txt"
	});
	// make 2 writes
	w.write(_, "012", "utf8");
	w.write(_, "345", "utf8");
	w.write(_, null);
	//store.write(_, "012345");
	// create readable store
	var r = store.createReadableStream(_);
	var buf;
	var res = "";
	while(buf = r.read(_))
		res += buf;
	strictEqual(res, "012345", "Simple content write/read ok");
	storeInst.save(_);
	var storeInstUuid = storeInst.$uuid;
	var dbFileName = storeInst.content(_).getUuid();
	// reload from db
	storeInst = db.fetchInstance(_, storeTestEntity, storeInstUuid);
	// retest read
	var r = (store = storeInst.content(_)).createReadableStream(_);
	var buf;
	var res = "";
	while(buf = r.read(_))
		res += buf;
	strictEqual(res, "012345", "Simple content write/read ok");
	// working copy mode test
	// create a store wc
	store.createWorkingCopy(_);
	w = store.createWritableStream(_, {
		fileName: "test1.txt"
	});
	w.write(_, "new file");
	w.write(_, null);
	var dbNewFileName = store.getUuid();
	ok(dbNewFileName != dbFileName, "Created new file ok");
	// both files exists now
	ok(mongodb.GridStore.exist(db.db, dbFileName, _), "Old file exists ok");
	ok(mongodb.GridStore.exist(db.db, dbNewFileName, _), "New file exists ok");
	//
	storeInst.save(_);
	// old file should have been deleted
	ok(!mongodb.GridStore.exist(db.db, dbFileName, _), "Db file deleted ok");
	dbFileName = dbNewFileName;
	// recreate a Wc, after save the old file should be deleted
	store.createWorkingCopy(_);
	// the file should stil exist before final save
	ok(mongodb.GridStore.exist(db.db, dbFileName, _), "File stil exists ok");
	storeInst.save(_);
	// the file should stil exist before final save
	ok(!mongodb.GridStore.exist(db.db, dbFileName, _), "File is deleted ok");
	//
	// delete store inst
	storeInst.deleteSelf(_);
	// check inst deleted
	storeInst = db.fetchInstance(_, storeTestEntity, storeInstUuid);
	ok(!storeInst, "Store inst deleted ok");
	// check file deleted
	ok(!mongodb.GridStore.exist(db.db, dbFileName, _), "Db file deleted ok");
	// file mode
	var storeInst = storeTestEntity.factory.createInstance(_, null, db);
	storeInst.storageType(_, "file");
	var store = storeInst.content(_);
	store._store.setFile(_, require("path").join(__dirname, "rsrc", "stringReaderTest.txt"));
	var r = store.createReadableStream(_);
	var buf;
	var res = "";
	while(buf = r.read(_))
		res += buf;
	strictEqual(res, "a string to read", "File storage read ok");
	
	//
	start();
});

function _unescape(obj, dbProp, objProp) {
	obj[objProp] = obj[dbProp];
	delete obj[dbProp];
}

asyncTest("Signed objects", 4, function(_) {
	var signedEnt = db.getEntity(_, "signedTests");
	var signed = signedEnt.createInstance(_, db);
	signed.description(_, "Sign test");
	var r = signed.save(_);
	ok(!(r.$diagnoses || []).some(function(d) {
		return d.severity === "error";
	}), "Signed saved ok");
	// check signature
	var dbObj = (db.db.collection("SignedTest", _).find({
		description: "Sign test"
	}).toArray(_))[0];
	// unescape
	Object.keys(dbObj).forEach(function(prop) {
		if(prop === "_id")
			_unescape(dbObj, prop, "$uuid");
		else
			if(prop[0] === "_")
				_unescape(dbObj, prop, "$" + prop.slice(1));
	});
	//
	ok(checksum.verify(dbObj, ["_id", "$uuid", "$key", "$loaded"]), "Signature verified from db");
	// try to fetch
	var obj = db.fetchInstance(_, signedEnt, {
		jsonWhere: {
			description: "Sign test"
		}
	});
	strictEqual(obj.description(_), "Sign test", "Signed object fetch ok");
	// direct database modification
	db.db.collection("SignedTest", _).update({ description: "Sign test" }, { $set: { description: "Changed sign" } },{ safe: true, multi: true }, _);
	// try to fetch - should get an error
	try {
		var obj = db.fetchInstance(_, signedEnt, {
			jsonWhere: {
				description: "Changed sign"
			}
		});
		ok(false, "NOT ok, should have got an error");
	} catch(e) {
		ok(true, "Fetch error of changed object ok");
	}
	
	start();
});

asyncTest("stop  tests", 0, function(_) {
	doStop = true;
	start();
});
