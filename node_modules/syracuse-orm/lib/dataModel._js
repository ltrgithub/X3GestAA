"use strict";

var helpers = require('syracuse-core/lib/helpers');
var httpHelper = require("syracuse-sdata/lib/httpHelper");
var find = helpers.object.find;
var forEachKey = helpers.object.forEachKey;
var pluralize = helpers.string.pluralize;
var capitalize = helpers.string.capitalize;
var resourceProxy = require("syracuse-core/lib/resource/resourceProxy");
var resourceHelpers = require("syracuse-core/lib/resource/util");
var globals = require('streamline/lib/globals');
// do not directly "require" the class as initialization sequence might lead to "undefined" (because of early require in factory.js
// of a module requiring "dataModel.js"
//var Factory = require("./factory").Factory;
var factory = require("./factory");
var locale = require("syracuse-core/lib/locale");
var flows = require('streamline/lib/util/flows');
var entityClasses = require("./entities");
var sys = require("util");
var types = require("syracuse-core/lib/types/allTypes");
var queryRepr = ["$query", "$lookup", "$search", "$select", "$bulk"]; // query like facets

// localization notes:
// 		localization applies to text, image, sound and video.
//		if property is marked as localized, mapper creates a one to many relationship transparently
//
//		string resources (identified by module name + resource name) are handled
//		explicitly via a StringResource entity because needs input from user
//
//		string is *not* localizable, use text type instead.

function _getTranslatedString(stringResources, parts, combineParts) {
	if (!stringResources || !parts || !parts.length) return "";
	for (var i = 0; i < (combineParts ? parts.length : 1); i++) {
		var str = stringResources[parts.slice(i).join(".")];
		//console.log("resource for : "+parts.slice(i).join(".")+"="+str);
		if (str) return str;
	}
}

function _getLink(facetName, title, params, entityName) {
	var link = {
		$type: "application/json;vnd.sage=syracuse"
	};
	if (title) link.$title = title;
	var plural = (entityName && pluralize(entityName)) || "{$pluralType}";
	var singular = entityName || "{$representation}";
	//
	switch (facetName) {
		case "$details":
			link.$url = "{$baseUrl}/" + plural + "('{$key}')?representation=" + singular + "." + facetName + "&role={$role}" + (params ? "&" + params : "");
			break;
		case "$lookup":
		case "$select":
		case "$query":
			link.$url = "{$baseUrl}/" + plural + "?representation=" + singular + "." + facetName + "&role={$role}" + (params ? "&" + params : "");
			break;
		case "$edit":
			link.$url = "{$baseUrl}/" + plural + "('{$key}')/$workingCopies?representation=" + singular + "." + facetName + "&role={$role}" + (params ? "&" + params : "");
			link.$method = "POST";
			break;
		case "$create":
			// $create facet is in fact an $edit facet
			link.$url = "{$baseUrl}/" + plural + "/$template/$workingCopies?representation=" + singular + ".$edit&role={$role}" + (params ? "&" + params : "");
			link.$method = "POST";
			break;
	}
	return link;
}

function _copyIfStatic(src, dest, name) {
	if (src[name] && (typeof src[name] !== "function")) dest[name] = src[name];
}

var _allEvents = ["$beforeSave", "$canSave", "$afterSave"];

function DataModel(contract) {
	var datasetOperations = {};
	var mapper = null;

	var pluralMap = {};
	var classMap = {}; // entities (not factories) by class name
	var self = this;

	var entities = contract.entities || {};
	var rules = contract.$rules || {};
	//
	this.dbMeta = contract.dbMeta || {};
	this.name = contract.name;
	this.contract = contract;
	//
	self.singularize = function(name) {
		return pluralMap[name];
	};
	//
	contract.localizedString = (function(entityName, propName) {
		var stringRes = contract.resources && contract.resources();
		return _getTranslatedString(stringRes, [entityName, propName]);
	}).bind(contract);

	var _entInstances = this._entities = {};
	forEachKey(entities, function(name, entity) {
		entity.name = name;

		// search facets
		if (contract.searchFacets) forEachKey(contract.searchFacets, function(key, facet) {
			if (facet.$fields && facet.$fields[entity.name]) {
				var f = entity.$facets = (entity.$facets || {});
				var ff = f[facet.$fields[entity.name]] = (f[facet.$fields[entity.name]] || []);
				ff.push(key);
			}
		});
		var entInst = _entInstances[name] = entities[name] = new entityClasses.Entity(self, name, entity);

		if (pluralMap[entInst.plural]) throw new Error(entInst.name + ": duplicate plural: " + entInst.plural);
		if (entities[entInst.plural]) throw new Error(entInst.name + ": plural is identical to singular: " + entInst.plural);
		classMap[entity.className] = entInst;
		pluralMap[entity.plural] = name;

	});
	// solve targetEntity
	forEachKey(entities, function(name, entity) {
		entity._solveTargetEntities();
	});
	// another pass to verify reverse relationships
	forEachKey(entities, function(name, entity) {
		entity._checkReverseRelations();
	});
	//
	forEachKey(contract.service || {}, function(name, operation) {
		if (typeof operation.execute != "function") throw new Error(entity.name + "operation '" + name + "' does not have execute method");
		datasetOperations[name] = operation;
	});
	self.datasetOperations = function() {
		return helpers.object.clone(datasetOperations, false);
	};
	self.getEntities = function() {
		return helpers.object.clone(contract.entities, false);
	};
	self.getRules = function() {
		return helpers.object.clone(rules, false);
	};
	self.getRepresentation = function(_, name, facet) {
		// TODO: return the representation as the associated entity with filtered properties
		//return contract.entities[name];
		return _entInstances[name];
	};
	self.getEntity = function(_, name) {
		//return contract.entities[name];
		return _entInstances[name];
	};
	self.entityByClassName = function(name) {
		return classMap[name];
	};
	self.getIndexedEntities = function(_) {
		return Object.keys(entities).filter(function(eName) {
			//return entities[eName].$searchIndex && entities[eName].$searchIndex.$fields;
			return _entInstances[eName].$searchIndex && _entInstances[eName].$searchIndex.$fields;
		}).map(function(eName) {
			//return entities[eName];
			return _entInstances[eName];
		});
	};
	self.getSearchFacets = function(_) {
		return Object.keys(contract.searchFacets || {}).map(function(fCode) {
			return {
				code: fCode,
				description: contract.searchFacets[fCode].$title
			};
		});
	};

	self.baseType = "application/json;vnd.sage=syracuse";

	// global events
	self.$events = {};
	_allEvents.forEach(function(name) {
		self.$events[name] = self.$events[name] || [];
	});
	self.registerEvent = (function(_, eventName, eventId, handler, entityName) {
		var target = entityName ? self.getEntity(_, entityName) : self;
		if (!target && target.$events && target.$events[eventName]) return;
		if (eventId) {
			var ev;
			target.$events[eventName].some(function(e) {
				if (e.id === eventId) {
					ev = e;
					return true;
				}
				return false;
			});
			if (ev) {
				ev.handler = handler;
				return;
			}
		}
		target.$events[eventName].push(eventId ? {
			id: eventId,
			handler: handler
		} : handler);
	}).bind(self);
}

helpers.defineClass(DataModel);

exports.getDefaultRepresentation = function(entity, facetName) {
	//var queryRepr = ["$query", "$lookup", "$search", "$select"]; // query like facets
	//
	//	var repr = [{$name:"general", $title: "General"}];
	//	var section = repr[0];
	//	section.$blocks = [{$name:"general", $contains: []}];
	var repr = {
		$items: [{}]
	};
	//
	if (facetName !== "$thumbnail") {
		//		section.$blocks[0].$contains = Object.keys(entity.$properties).slice(0);
		repr.$items[0].$contains = Object.keys(entity.$properties).slice(0);
		//
		var contains = repr.$items[0].$contains;
		forEachKey(entity.$relations, function(name, rel) {
			if (rel.isPlural) {
				if (queryRepr.indexOf(facetName) < 0) contains.push(name);
			} else contains.push(name);
		});
		//
		if (queryRepr.indexOf(facetName) >= 0) {
			repr.$items[0].$bind = "$resources";
			//			section.$blocks[0].$items = [{$name: "$resources", $contains: contains}];
			//			delete section.$blocks[0].$contains;
		}
	} else repr.$items[0].$contains = (new Array(entity.$valueTemplate && entity.$valueTemplate.expression.substring(1, entity.$valueTemplate.expression.length - 1) || "$key", entity.$titleTemplate && entity.$titleTemplate.expression.substring(1, entity.$titleTemplate.expression.length - 1) || "$key"));
	//
	return repr;
};

exports.make = function(contract, dataset) {
	// TODO : if the same model should be used for several datasets, first load modifies contract entities
	// so second load fails. Should detect the case or clone theese entities
	//	dataset = dataset || "all";
	// for now, same model for all dataset of the same contract
	dataset = "all";
	contract.models = contract.models || {};
	var model = contract.models[dataset];
	return model ? model : (contract.models[dataset] = new DataModel(contract));
};

exports.getOrm = function(_, model, dataset) {
	//	console.log("dataset "+dataset.driver);
	var orm;
	if (dataset.driver && (dataset.driver === "mongodb")) orm = require("syracuse-orm/lib/dbHandles/mongoDbHandle").create(_, model, dataset);
	else throw new Error("unsupported ORM driver: " + dataset.driver);
	// add synchronization data
	if (model.contract && model.contract.entities) {
		var ents = model.contract.entities;
		var metaEnt;
		var endpoint;
		var conflictPriority;
		var locked = false;
		try {
			Object.keys(ents).forEach_(_, function(_, name) {
				var entity = ents[name];
				if (!entity.$allowSync) return;
				if (!metaEnt) {
					metaEnt = orm.model.getEntity(_, "entity");
					if (!metaEnt) throw new Error(locale.format(module, "noMetaEntity"));
				}
				entity._syncInfo = orm.fetchInstance(_, metaEnt, {
					jsonWhere: {
						name: name
					}
				});
				if (entity._syncInfo) return;
				if (!locked) orm.lockDatabaseRetry(_);
				locked = true;
				// create meta instance
				if (!endpoint) {
					var settingsEnt = orm.model.getEntity(_, "setting");
					if (settingsEnt) {
						var globalData = orm.fetchInstance(_, settingsEnt, {});
						if (!globalData) throw new Error(locale.format(module, "noGlobalSettings"));
						endpoint = globalData.endpoint(_) || "";
						conflictPriority = globalData.conflictPriority(_);
					} else {
						// for test cases
						conflictPriority = 5;
						endpoint = "http://" + require('os').hostname() + ":" + require('syracuse-main/lib/nodeconfig').config.port;
					}
					endpoint += "/sdata/" + model.contract.application + "/" + model.contract.contract + "/" + dataset.database + "/";
				}
				// TODO: use real endpoint 
				var entInstance = metaEnt.createInstance(_, orm, null);
				entInstance.name(_, name);
				entInstance.tick(_, 2);
				entInstance.conflictPriority(_, conflictPriority);
				entInstance.endpoint(_, endpoint + entity.plural);
				entInstance.digest(_, []);
				var anzahl = orm.fetchInstances(_, metaEnt, {});
				entInstance.save(_);
				// put syncUuid, endpoint, and tick to instances which do not have it yet
				var cursor = orm.createCursor(_, entity, {});
				var inst;
				var syncUuids = {};
				while ((inst = cursor.next(_))) {
					// console.log("III "+((login in inst) ? inst.login(_) : inst.$uuid));
					if (!inst.$syncUuid) {
						var syncUuid = helpers.uuid.generate();
						if (syncUuid in syncUuids || syncUuid === inst.$uuid) {
							for (var i = 1; i < 10; i++) {
								var syncUuid = helpers.uuid.generate();
								if (syncUuid in syncUuids || syncUuid === inst.$uuid) syncUuid = undefined;
							}
							if (!syncUuid) throw new Error(locale.format(module, "noGenerateUuid"));
						}
						inst.$syncUuid = syncUuid;
					}
					syncUuids[inst.$syncUuid] = null;
					if (!inst.$endpoint) {
						inst.$endpoint = endpoint;
						inst.$tick = 1;
						inst._syracuseNoIncreaseTick = true;
						inst.save(_);
					}
				}
				entity._syncInfo = entInstance;

			});
		} finally {
			if (locked) {
				orm.unlockDatabase(_);
			}
		}
	}


	return orm;
};