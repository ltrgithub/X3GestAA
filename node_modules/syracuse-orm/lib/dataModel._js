"use strict";

var helpers = require('syracuse-core/lib/helpers')
var find = helpers.object.find;
var forEachKey = helpers.object.forEachKey;
var pluralize = helpers.string.pluralize;
var capitalize = helpers.string.capitalize;
var orm = require("./orm");
var resourceProxy = require("syracuse-core/lib/resource/resourceProxy");
var resourceHelpers = require("syracuse-core/lib/resource/util");
// do not directly "require" the class as initialization sequence might lead to "undefined" (because of early require in factory.js 
// of a module requiring "dataModel.js"
//var Factory = require("./factory").Factory;
var factory = require("./factory");
var locale = require("syracuse-core/lib/locale");
var flows = require('streamline/lib/util/flows');
var sys = require("util");
var types = require("syracuse-core/lib/types/allTypes");
// localization notes:
// 		localization applies to text, image, sound and video.
//		if property is marked as localized, mapper creates a one to many relationship transparently
//
//		string resources (identified by module name + resource name) are handled
//		explicitly via a StringResource entity because needs input from user
//
//		string is *not* localizable, use text type instead.
var _integerSizes = {
	tiny: 1,
	small: 2,
	medium: 3,
	normal: 4,
	big: 8
};

var _realSizes = {
	small: 4,
	normal: 8
};

var _datetimeSizes = {
	normal: 8,
	big: 8 // same size in mysql but tracks microseconds
};

var _timeSizes = {
	normal: 3,
	big: 8
};

var _binarySizes = {
	tiny: 255,
	normal: 64 * 1024 - 1,
	// 64KB
	medium: 16 * 1024 * 1024 - 1,
	// 16MB
	"long": 4 * 1024 * 1024 * 1024 - 1 // 4GB
};

// divide by 3 because of UTF encoding
var _textLengths = {
	tiny: Math.floor(_binarySizes.tiny / 3),
	// 85
	normal: Math.floor(_binarySizes.normal / 3),
	// 21KB
	medium: Math.floor(_binarySizes.medium / 3),
	// 5.3MB
	"long": Math.floor(_binarySizes["long"] / 3) // 1.3GB
};

var _stringLengths = {
	tiny: 255,
	normal: 1024 // much smaller than text because contributes to row size
};

function _getTranslatedString(stringResources, parts, combineParts) {
	if(!stringResources || ! parts || !parts.length) return "";
	for(var i = 0; i < (combineParts ? parts.length : 1); i++) {
		var str = stringResources[parts.slice(i).join(".")];
		//console.log("resource for : "+parts.slice(i).join(".")+"="+str);
		if(str) return str;
	}
}

function _setSize(prop, def, sizes, hasLength) {
	if (hasLength && !prop.size && prop.maxLength) prop.size = Object.keys(sizes).filter(function(size) {
		return sizes[size] >= prop.maxLength;
	})[0];
	prop.size = prop.size || def;
	if (hasLength) {
		if (!prop.maxLength) prop.maxLength = sizes[prop.size]
		// sanity check
		if (prop.maxLength > sizes[prop.size]) throw new Error(prop.name + ": maxLength incompatible with size")

		if (!sizes[prop.size]) throw new Error(prop.name + ": invalid size: " + prop.size);
	}
}

function _getLink(facetName, title, params, entityName) {
	var link = {
		$type: "application/json;vnd.sage=syracuse"
	}
	if (title) link.$title = title;
	var plural = (entityName && pluralize(entityName)) || "{$pluralType}";
	var singular = entityName || "{$representation}";
	//
	switch (facetName) {
	case "$details":
		link.$url = "{$baseUrl}/" + plural + "('{$key}')?representation=" + singular + "." + facetName + "&role={$role}" + (params ? "&" + params : "");
		break;
	case "$lookup":
	case "$select":
	case "$query":
		link.$url = "{$baseUrl}/" + plural + "?representation=" + singular + "." + facetName + "&role={$role}" + (params ? "&" + params : "");
		break;
	case "$edit":
		link.$url = "{$baseUrl}/" + plural + "('{$key}')/$workingCopies?representation=" + singular + "." + facetName + "&role={$role}" + (params ? "&" + params : "");
		link.$method = "POST";
		break;
	case "$create":
		// $create facet is in fact an $edit facet
		link.$url = "{$baseUrl}/" + plural + "/$template/$workingCopies?representation=" + singular + ".$edit&role={$role}" + (params ? "&" + params : "");
		link.$method = "POST";
		break;
	}
	return link;
}

var _decoratePropertyProtoMap = {
		graph: function(_, $p, entity, prop) {
			$p.$url = "{$baseUrl}/{$pluralType}('{$key}')/$graphs/" + prop.name;
			$p.$linkCategories = [];
			$p.$nodeCategories = [];
			//
			var maps = prop.getGraphRelationsMaps(_);
			//
			flows.eachKey(_, maps.nodes, function(_, nodeName, node) {
				$p.$nodeCategories.push(node);
			});
			flows.eachKey(_, maps.links, function(_, linkName, link) {
				$p.$linkCategories.push(link);
			});
		},
		"tag-cloud": function(_, $p, entity, prop) {
			$p.$url = "{$baseUrl}/{$pluralType}('{$key}')/$tagClouds/" + prop.name;
			$p.$nodeCategories = [];
			// TODO
			$p.$nodeCategories.push({$title: "Categ test", $prototype: {$: {$value: "Test"}}});
		}
	}

function _initProperty(entity, prop) {
	prop.type = prop.type || prop.$type || "string";
	prop.title = prop.title || prop.$title || prop.name;
	prop.$title = prop.$title || prop.title;
	// dont create the property if there isn't any default value, as null property means null default value
	if (prop.hasOwnProperty("defaultValue")) 
		prop.defaultValue = prop.defaultValue;
	else
		if (prop.hasOwnProperty("$default")) 
			prop.defaultValue = prop.$default;
	var constraints = prop.$constraints;
	if (constraints) {
		prop.minLength = constraints.$minLength;
		prop.maxLength = constraints.$maxLength;
		prop.mandatory = prop.$isMandatory;
		prop.nullable = constraints.$isNullable;
	}
	prop.$constraints = prop.$constraints || {};
	//	prop.prototype.getAllConstraints = function() {
	//		var c = helpers.object.clone(this.$constraints);
	//		c.$isMandatory = this.$isMandatory;
	//	};
	prop.getAllConstraints = (function() {
		var c = helpers.object.clone(this.$constraints);
		if (this.$isMandatory) c.$isMandatory = this.$isMandatory;
		if (this.$isDefined) c.$isDefined = this.$isDefined;
		return c;
	}).bind(prop);
	//
	prop.isExternalStorage = (function() {
//		return (!(this.$storage === "inline") && (["image", "binary"].indexOf(this.type) >= 0));
		return (this.hasOwnProperty("$storage"));
	}).bind(prop);
	// 
	prop.getMimeType = (function() {
		switch(this.type) {
		case "image":
		case "text/rtf":
			return this.type;
		default:
			return ("application/x-" + this.type);
		}
	}).bind(prop);
	// add type specific operations
	prop.getPropertyPrototype = (function(_, stringRes, facetName, isChild) {
		var name = this.name;
		var $p = {};
		$p.$title = _getTranslatedString(stringRes, [entity.name, name, "$title"], true) || prop.$title;
		$p.$isHidden = prop.$isHidden;
		if (prop["$enum"] && Array.isArray(prop["$enum"])) {
			$p.$type = "application/x-choice";
			var $value = $p.$value = {
				$type: prop.getMimeType(),
				$constraints: prop.$constraints
			}
			var enumCaptions = prop.$enumCaptions || [];
			var protoEnum = $value.$constraints.$enum = [];
			prop["$enum"].forEach(function(value, idx) {
				protoEnum.push({
					$value: value,
					$title: _getTranslatedString(stringRes, [entity.name, name, value], true) || enumCaptions[idx] || value
				});
			});
		} else {
			$p.$type = prop.getMimeType();
			if(prop.isExternalStorage())
				if(facetName === "$edit")
					$p.$url = "{$baseUrl}/$workingCopies('{$trackingId}')/"+name;
				else
					$p.$url = "{$baseUrl}/{$pluralType}('{$key}')/"+name;
			$p.$format = prop.$format;
			$p.$constraints = prop.$constraints;
			$p.$isMandatory = prop.$isMandatory;
			$p.$isDisabled = prop.$isDisabled;
			//
		}
		if (prop.isComputed || prop.$compute) $p.$isDisabled = true;
		$p.$capabilities = prop.hasOwnProperty("$capabilities") ? prop.$capabilities : (isChild ? "sort" : "sort,filter");
		if((prop.type === "string") && ($p.$capabilities.indexOf("alphaTab") < 0)) 
			$p.$capabilities = $p.$capabilities + ",alphaTab"; 
		//
		// for now, move il later in dataModel.js ?
		if (prop.$linksToDetails && (facetName !== "$lookup" && facetName !== "$select")) {
			$p.$links = {
				$details: _getLink("$details")
			}
		}
		if (prop.$lookup) {
			$p.$links = $p.$links || {};
			$p.$links.$lookup = _getLink("$lookup", null, "trackingId={$trackingId}&binding=" + prop.name + (prop.$lookup.parameters ? "&" + prop.$lookup.parameters : ""), prop.$lookup.entity);
			$p.$links.$lookup.$result = prop.$lookup.field;
		}
		//
		_decoratePropertyProtoMap[prop.$type] && _decoratePropertyProtoMap[prop.$type](_, $p, entity, prop);
		//
		return $p;
	}).bind(prop);
	//
	prop.getDefaultValue = (function(_, instance) {
		var property = this;
		if(property.hasOwnProperty("defaultValue")) {
			if(typeof property.defaultValue === "function")
				return property.defaultValue();
			else
				return property.defaultValue; 
		} else
			return (types[(property.$type || "string")] || {}).defaultValue;
	}).bind(prop);
	//
	prop.hasDefaultValue = (function() {
		return this.hasOwnProperty("defaultValue");
	}).bind(prop);
	//
	if(prop.$type === "graph")
		prop.getGraphRelationsMaps = (function(_) {
			function _addNodes(_, rel, relMap, walked) {
				var ent = rel.targetEntity;
				if(!nodesMap[ent.name])
					nodesMap[ent.name] = {
						$name: ent.name,
						$title: ent.$titleTemplate && ent.$titleTemplate.expression,
						$selected: (relMap.$selected !== false),
						$prototype: {
							$: {
								$value: ent.$valueTemplate && ent.$valueTemplate.expression
							},
							$links: {
								$default: {
									$url: "{$baseUrl}/" + ent.plural+ "('{$uuid}')?representation=" + ent.name + ".$details",
									$target: "blank"
								}
							}
						}
					}
				if(!linksMap[walked])
					linksMap[walked] = {
						$name: walked,
						$title: rel.$title
					}
			}
			function _walkRelation(_, ent, relName, relMap, walked) {
				if(relName[0] === "$") return;
				//
				var targetEntity = ent.$relations && ent.$relations[relName] && ent.$relations[relName].targetEntity;
				if(!targetEntity) throw new Error(locale.format(module, "relationEntityNotFound", relName));
				// 
				_addNodes(_, ent.$relations[relName], relMap, walked);
				// continue recursion
				flows.eachKey(_, relMap, function(_, locRelName, locRelMap) {
					_walkRelation(_, targetEntity, locRelName, locRelMap, walked + "." + locRelName);
				})
			}
			var nodesMap = {};
			var linksMap = {};
			// add starting point
			nodesMap[entity.name] = {
				$name: entity.name,
				$title: entity.$titleTemplate && entity.$titleTemplate.expression,
				$selected: true,
				$prototype: {
					$: {
						$value: entity.$valueTemplate && entity.$valueTemplate.expression
					}
				}
			}
			//
			flows.eachKey(_, this.$relations, function(_, relName, relation) {
				_walkRelation(_, entity, relName, relation, relName);
			});
			//
			return {
				nodes: nodesMap,
				links: linksMap
			}
		}).bind(prop);
}

var _allEvents = ["afterRead", //
"beforeCreate", "beforeCreateMerge", "afterCreate", //
"beforeUpdate", "beforeUpdateMerge", "afterUpdate", //
"beforeDelete", "afterDelete", //
"created", "saved", "edited", "removed", "listChanged", "dbHandleNotFound"];

function _createMissingFacets(entity, facets) {
	facets.$$generated = {
		$query: (facets.$query == null),
		$details: (facets.$details == null),
		$edit: (facets.$edit == null),
		$thumb: (facets.$thumb == null),
	};
	// create missing facets
	facets.$query = facets.$query || [];
	facets.$details = facets.$details || [];
	facets.$edit = facets.$edit || [];
	// standard thumbnail
	facets.$thumb = facets.$thumb || (new Array(entity.$valueTemplate && entity.$valueTemplate.expression.substring(1, entity.$valueTemplate.expression.length - 1) || "$key", entity.$titleTemplate && entity.$titleTemplate.expression.substring(1, entity.$titleTemplate.expression.length - 1) || "$key"));
}

function _pushPropertyToFacets(facets, propName) {
	if (facets.$$generated.$query) facets.$query.push(propName);
	if (facets.$$generated.$details) facets.$details.push(propName);
	if (facets.$$generated.$edit) facets.$edit.push(propName);
}

function _pushRelationToFacets(facets, relName, isPlural) {
	if (facets.$$generated.$details) facets.$details.push(relName);
	if (facets.$$generated.$edit) facets.$edit.push(relName);
	if (!isPlural && facets.$$generated.$query) facets.$query.push(relName);
}
//


function _getMeta(entity, metaName, parameters, selected, needsThumb, forceChildren, depth) {
	return {
		entity: entity,
		name: metaName,
		$properties: entity.$properties,
		$relations: entity.$relations,
		isSelected: selected,
		needsThumb: needsThumb,
		defaultOrder: entity.defaultOrder
	};
}

function _checkDefaultOrder(entity, orders) {
	orders.forEach(function(order) {
		if (!(order instanceof Array)) throw new Error(entity.name + ": default order element is not an array");
		if (!entity.$properties[order[0]]) throw new Error(entity.name + ": invalid order property: " + order[0]);
		if (order[1] === undefined) order[1] = true;
	})
}

function DataModel(contract) {
	var datasetOperations = {};
	var mapper = null;

	var pluralMap = {};
	var classMap = {}; // entities (not factories) by class name
	var self = this;

	var entities = contract.entities || {};
	var rules = contract.$rules || {};
	var _tags = [];
	//
	this.dbMeta = contract.dbMeta || {};
	this.name = contract.name;

	function _tagsMask(tags) {
		if (!tags) return 0;
		var mask = 0;
		tags.split(",").forEach(function(tag) {
			var i = _tags.indexOf(tag);
			if (i < 0) {
				i = _tags.length;
				_tags.push(tag);
			}
			mask |= 1 << i;
		});
		return mask;
	}

	forEachKey(entities, function(name, entity) {
		entity.name = name;
		entity.className = entity.className || capitalize(name);
		entity.plural = entity.plural || pluralize(name);
		entity.title = entity.title || entity.$title || entity.name;
		// default $isPersistent is true
		if (!entity.hasOwnProperty("$isPersistent")) entity.$isPersistent = true;
		if (pluralMap[entity.plural]) throw new Error(entity.name + ": duplicate plural: " + entity.plural);
		if (entities[entity.plural]) throw new Error(entity.name + ": plural is identical to singular: " + entity.plural)

		entity.$properties = entity.$properties || {};
		var fields = {};
		helpers.object.forEachKey(entity.$properties, function(propName, prop) {
			prop.name = propName;
			prop.tagsMask = _tagsMask(prop.tags);
			_initProperty(entity, prop);
			if (!prop.isComputed) fields[propName] = prop;
		});

		classMap[entity.className] = entity;
		pluralMap[entity.plural] = name;

		entity.defaultOrder = entity.defaultOrder || entity.$defaultOrder;
		if(!entity.defaultOrder && entity.$properties["description"])
			entity.defaultOrder = [["description", true]];
		if(!entity.defaultOrder)
			entity.defaultOrder = [];
		_checkDefaultOrder(entity, entity.defaultOrder);

		if (entity.descriptor) {
			if (typeof entity.descriptor != "function" && !entity.$properties[entity.descriptor]) throw new Error(entity.name + ": invalid descriptor property: " + entity.descriptor);
		}

		entity.$services = entity.$services || {};
		entity.$events = entity.$events || {};
		entity.$methods = entity.$methods || {};
		entity.$functions = entity.$functions || {};
		entity.$rules = entity.$rules || {};
		entity.$links = entity.$links || {};
		entity.$actions = entity.$actions || {};
		// allProperties =  properties + relations
		var allProps = Object.keys(entity.$properties);
		entity.$relations = entity.$relations || {};
		forEachKey(entity.$relations, function(relName, rel) {
			rel.name = relName;
			rel.title = rel.title || rel.$title || rel.name;
			rel.isComputed = rel.isComputed || rel.$isComputed;
			rel.isChild = rel.isChild || rel.$isChild;
			rel.tagsMask = _tagsMask(rel.tags);
			if (typeof rel.optional == "undefined") rel.optional = false;
			if (rel.isChild) rel.owned = true;
			if (rel.before) {
				var i = allProps.indexOf(rel.before);
				if (i < 0) allProps.push(relName);
				else allProps.splice(i, 0, relName);
			} else allProps.push(relName);
		})
		entity.allProperties = {};
		allProps.forEach(function(propertyName) {
			if (entity.$properties[propertyName]) entity.allProperties[propertyName] = entity.$properties[propertyName];
			else entity.allProperties[propertyName] = entity.$relations[propertyName];

		});
		forEachKey(entity.$rules, function(name, rule) {
			// rule : {event: string("changed"/"created"/"save"/"delete/listChanged"), triggers: ["property1", "property2", ...], type: ("validation"/"propagation"/"ui")   , action: function }
			rule.event = rule.event || rule.$event;
			rule.triggers = rule.triggers || rule.$triggers;
			rule.action = rule.action || rule.$action;
			rule.type = rule.type || rule.$type;
			if (!rule.event) rule.event = "changed";
			if (!rule.type && (rule.event == "changed")) rule.type = "propagation";
			if ((rule.event == "changed") && (!rule.triggers || !rule.triggers.length)) throw new Error(entity.name + "." + name + " - Bad rule definition :  no triggers for rule.");
			var index = ["changed", "listChanged"].indexOf(rule.event);
			if (index >= 0) {
				rule.triggers && rule.triggers.forEach(function(property) {
					var property = entity.allProperties[property];
					if (!property) return;
					property.$rules = property.$rules || {};
					var path = (index == 0) ? rule.type : rule.event;
					property.$rules[path] = property.$rules[path] || {};
					property.$rules[path][name] = rule.action;
				});
			} else {
				entity.$events[rule.event] = entity.$events[rule.event] || {};
				entity.$events[rule.event][name] = rule.action;
			}
		});
		forEachKey(entity.$links, function(name, link) {
			link.name = name;
			link.tagsMask = _tagsMask(link.tags);
		});
		forEachKey(entity.$actions, function(name, action) {
			action.name = name;
			action.tagsMask = _tagsMask(action.tags);
		});

		function _makeTemplate(str) {
			var template = new resourceProxy.Template(str);
			(template.matches || []).forEach(function(match) {
				match = match.substring(1, match.length - 2).trim();
				if (entity.$properties[match]) entity.$properties[match].usedByTemplate = true;
			});
			return template;
		}
		if (entity.$valueTemplate && (typeof entity.$valueTemplate === "string")) entity.$valueTemplate = _makeTemplate(entity.$valueTemplate);
		if (entity.$titleTemplate && (typeof entity.$titleTemplate === "string")) entity.$titleTemplate = _makeTemplate(entity.$titleTemplate);
		if (entity.$descriptionTemplate && (typeof entity.$descriptionTemplate === "string")) entity.$descriptionTemplate = _makeTemplate(entity.$descriptionTemplate);
		if (entity.$iconTemplate && (typeof entity.$iconTemplate === "string")) entity.$iconTemplate = _makeTemplate(entity.$iconTemplate);

		// usefull functions
		entity.createInstance = (function(_, db, initial) {
			return this.factory.createInstance(_, initial, db);
		}).bind(entity);
		entity.fetchInstance = (function(_, db, options) {
			return db.fetchInstance(_, this, options);
		}).bind(entity);
		entity.fetchInstances = (function(_, db, options) {
			return db.fetchInstances(_, this, options);
		}).bind(entity);
		entity.count = (function(_, db, options) {
			return db.count(_, this, options);
		}).bind(entity);
		// add standard links resources for the entity
		entity.fillLinksResource = (function(reprType, resource) {
			var stringRes = contract.resources && contract.resources();
			var self = this;
			var $links = (resource.$links = (resource.$links || {}));
			if (reprType !== "$details") {
				if (self.$isPersistent !== false) $links.$details = _getLink("$details", locale.format(module,"detailsLinkTitle"));
			}
			if (reprType !== "$edit") {
				if(self.$canEdit !== false)
					$links.$edit = _getLink("$edit", locale.format(module, "editLinkTitle"));
				if(self.$canDelete !== false)
					$links.$delete = {
						$title: locale.format(module, "deleteActionTitle"),
						$confirm: locale.format(module, "deleteConfirmMessage", _getTranslatedString(stringRes, [self.name, "$valueTemplate"])),
						// send to query representation
						$url: "{$baseUrl}/{$pluralType}('{$key}')?representation={$representation}." + reprType + "&role={$role}",
						$type: "application/json;vnd.sage=syracuse",
						$method: "DELETE"
					}
			}
			if (reprType !== "$query") {
				if (self.$isPersistent !== false) $links.$query = _getLink("$query", _getTranslatedString(stringRes, [self.name, "$listTitle"]) || locale.format(module, "listOf", self.name));
			}
			if (reprType === "$edit") {
				resource.$actions = resource.$actions || {};
				if (self.$canSave !== false) {
					resource.$actions.$save = resource.$actions.$save || {
						$title: locale.format(module, "saveActionTitle"),
						$isDisabled: true,
						$links: {
							$details: _getLink("$details", locale.format(module, "ok"), "", self.name),
							$query: _getLink("$query", locale.format(module, "backToList"), "", self.name),
							$create: _getLink("$create", _getTranslatedString(stringRes, [self.name, "$createActionTitle"]) || locale.format(module, "newLinkTitle", self.name), "", self.name)
						}
					}
					resource.$actions.$save.$links.$details.$isHidden = (self.$isPersistent === false);
					resource.$actions.$save.$links.$query.$isHidden = (self.$isPersistent === false);
					resource.$actions.$save.$links.$create.$isHidden = (self.$isPersistent === false);
				}
			}
			// services
			forEachKey(self.$services, function(key, service) {
				if (service.$method && (service.$method !== "GET") && (reprType === "$edit")) {
					resource.$actions = resource.$actions || {};
					var action = resource.$actions[key] = {};
					action.$title = service.$title || key;
					action.$method = service.$method || "GET";
				} else {
					// make service links
					resource.$links = resource.$links || {};
					var link = resource.$links[key] = {
						$type: "application/json;vnd.sage=syracuse",
						$title: service.$title || key,
						$method: service.$method || "GET",
						$url: "{$baseUrl}/{$pluralType}('{$uuid}')/$service/" + key
					}
				}
			});
			resource.$links = resource.$links || {};
			forEachKey(self.$links, function(key, link) {
				if(typeof link !== "function")
					resource.$links[key] = link;
			});
			// PDFHACK
			$links.$print = _getLink(reprType, locale.format(module, "print"));
			$links.$print.$type = "application/pdf";

			// $lookup and $select items should only have $details link
			if (["$lookup", "$select"].indexOf(reprType) >= 0) {
				resource.$links = {
					$details: _getLink("$details", locale.format(module,"detailsLinkTitle"))		 
				}
			}
		}).bind(entity);
	});
	forEachKey(entities, function(name, entity) {
		forEachKey(entity.$relations, function(relName, rel) {
			rel.name = relName;
			rel.type = rel.type || rel.$type || relName;
			// mandatory is not a constraint anymore
			//if (rel.$constraints) {
			//	rel.mandatory = rel.$constraints.$isMandatory;
			//}
			rel.title = rel.title || rel.$title || rel.name;
			rel.mandatory = rel.$isMandatory;
			rel.inv = rel.inv || rel.$inv;
			var singular = pluralMap[rel.type];
			rel.isPlural = singular != null;
			rel.isComputed = rel.isComputed || rel.$isComputed;
			if (rel.isPlural) {
				if (!rel.inv && !helpers.useInstances) throw new Error(entity.name + ": inverse relation missing on " + relName)
				// rel.inv = rel.inv || name; 
				rel.targetEntity = find(entities, singular);
				if (rel.$assoType) {
					rel.targetAssoEntity = find(entities, rel.$assoType);
					if (!rel.$assoInv) throw new Error(entity.name + ": inverse association missing on " + relName);
				}
				if (rel.defaultOrder !== undefined)(rel.targetEntity, rel.defaultOrder);
				else rel.defaultOrder = rel.targetEntity.defaultOrder;
			} else {
				if (!entities[rel.type]) throw new Error(entity.name + ": relation '" + relName + "' targets unknown type: " + rel.type);
				rel.targetEntity = find(entities, rel.type);
			}
			// 
			if(rel.targetEntity && !rel.isComputed) {
				rel.targetEntity.referingEntities = rel.targetEntity.referingEntities || {};
				rel.targetEntity.referingEntities[name] = rel.targetEntity.referingEntities[name] || [];
				rel.targetEntity.referingEntities[name].push(relName);
			}
		});
		// standard services
		if((entity.$lockType === "pessimist") && !entity.$services.forceLockInstance) {
			// force locking of an instance allready locked by another user
			entity.$services.forceLockInstance = {
				$method: "POST",
				$isMethod: true,
				$title: "Force lock",
				$isHidden: true,
				$execute: function(_, context, instance) {
					// delete locks for instance (other session?)
					instance.unlockInstance(_);
					// lock for this session
					instance.lockInstance(_);
					//
					context.reply(_, 200);
				}
			}
		}
		//
		forEachKey(entity.$services, function(name, operation) {
			operation.name = name;
			operation.tagsMask = _tagsMask(operation.tags);
			operation.method = operation.method || operation.$method;
			operation.isMethod = operation.isMethod || operation.$isMethod || false;
			operation.execute = operation.execute || operation.$execute;
			if (typeof operation.execute != "function") throw new Error(entity.name + "operation '" + name + "' does not have execute method");
		});
		//
		forEachKey(entity.$events, function(name, event) {
			if (_allEvents.indexOf(name) < 0) throw new Error(entity.name + ": invalid event name: " + name);

		});
		// set default meta
		entity.getMeta = function(parameters, forceChildren) {
			return _getMeta(entity, entity.plural, parameters || {}, true, false, forceChildren, 0)
		};
	});
	// another pass to verify reverse relationships
	forEachKey(entities, function(name, entity) {
		forEachKey(entity.$relations, function(relName, rel) {
			var inv = rel.targetEntity.$relations[rel.inv];
			if (inv) {
				if (inv.targetEntity != entity) throw new Error(rel.targetEntity.name + "." + inv.name + ": expected type=" + entity.name + ", got type=" + inv.targetEntity.name);
				if (!inv.inv) inv.inv = rel.name;
				if (inv.inv != rel.name) throw new Error(rel.targetEntity.name + "." + inv.name + ": expected inv=" + rel.name + ", got inv=" + inv.inv);
			} else {
				if (rel.isPlural && !helpers.useInstances) throw new Error(entity.name + "." + rel.name + ": missing inverse relation");
			}
		});
		forEachKey(entity.$relations, function(relName, rel) {
			var inv = rel.targetEntity.$relations[rel.inv];
			// classify with relType
			if (rel.isPlural) {
				if (rel.isChild) rel.relType = "children";
				else if (inv && inv.isPlural) rel.relType = "association";
				else rel.relType = "link";
			} else {
				if (rel.isChild) rel.relType = "child";
				else if (inv && inv.isChild) rel.relType = "parent";
				else rel.relType = "reference";
			}
		});
// RECURSION !!!!!
//		entity.shallowMeta = entity.getMeta(null, false);
//		entity.deepMeta = entity.getMeta(null, true);
		//
		forEachKey(entity.$functions, function(name, fn) {
			if (typeof fn != "function") throw new Error(entity.name + ": " + name + " is not a function");
		});
		forEachKey(entity.$methods, function(name, fn) {
			if (typeof fn != "function") throw new Error(entity.name + ": " + name + " is not a function");
		});
	});
	forEachKey(contract.service || {}, function(name, operation) {
		if (typeof operation.execute != "function") throw new Error(entity.name + "operation '" + name + "' does not have execute method");
		datasetOperations[name] = operation;
	});
	self.datasetOperations = function() {
		return helpers.object.clone(datasetOperations, false);
	}
	self.getEntities = function() {
		return helpers.object.clone(contract.entities, false);
	}
	self.getRules = function() {
		return helpers.object.clone(rules, false);
	}
	self.singularize = function(name) {
		return pluralMap[name];
	}
	self.getEntity = function(name) {
		return contract.entities[name];
	}
	self.entityByClassName = function(name) {
		return classMap[name];
	}
	if (!helpers.useInstances) {
		self.connect = mapper.connect.bind(mapper);
		self.reset = mapper.reset.bind(mapper);
	}

	self.baseType = "application/json;vnd.sage=syracuse";

	forEachKey(entities, function(name, entity) {
		entity.factory = new factory.Factory(entity);
	});
}

helpers.defineClass(DataModel);

exports.getDefaultRepresentation = function(entity, facetName) {
	var queryRepr = ["$query", "$lookup", "$search", "$select"]; // query like facets
	//
	//	var repr = [{$name:"general", $title: "General"}];
	//	var section = repr[0];
	//	section.$blocks = [{$name:"general", $contains: []}];
	var repr = {
		$items: [{}]
	};
	//
	if (facetName !== "$thumbnail") {
		//		section.$blocks[0].$contains = Object.keys(entity.$properties).slice(0);
		repr.$items[0].$contains = Object.keys(entity.$properties).slice(0);
		//
		var contains = repr.$items[0].$contains;
		forEachKey(entity.$relations, function(name, rel) {
			if (rel.isPlural) {
				if (queryRepr.indexOf(facetName) < 0) contains.push(name);
			} else contains.push(name);
		});
		//
		if (queryRepr.indexOf(facetName) >= 0) {
			repr.$items[0].$bind = "$resources";
			//			section.$blocks[0].$items = [{$name: "$resources", $contains: contains}];
			//			delete section.$blocks[0].$contains;
		}
	} else repr.$items[0].$contains = (new Array(entity.$valueTemplate && entity.$valueTemplate.expression.substring(1, entity.$valueTemplate.expression.length - 1) || "$key", entity.$titleTemplate && entity.$titleTemplate.expression.substring(1, entity.$titleTemplate.expression.length - 1) || "$key"));
	//	
	return repr;
}

exports.make = function(contract, dataset) {
	// TODO : if the same model should be used for several datasets, first load modifies contract entities 
	// so second load fails. Should detect the case or clone theese entities
//	dataset = dataset || "all";
	// for now, same model for all dataset of the same contract
	dataset = "all";
	contract.models = contract.models || {};
	var model = contract.models[dataset];
	return model ? model : (contract.models[dataset] = new DataModel(contract));
}

exports.getOrm = function(_, model, dataset) {
//	console.log("dataset "+dataset.driver);
	if (dataset.driver && (dataset.driver === "mongodb")) return require("syracuse-orm/lib/mongoDbHandle").create(_, model, dataset);
	else return require("syracuse-orm/lib/mysqlDbHandle").create(_, model, dataset);
}