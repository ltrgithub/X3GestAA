"use strict";

var helpers = require('syracuse-core/lib/helpers');
var httpHelper = require("syracuse-sdata/lib/httpHelper");
var find = helpers.object.find;
var forEachKey = helpers.object.forEachKey;
var pluralize = helpers.string.pluralize;
var capitalize = helpers.string.capitalize;
var orm = require("./orm");
var resourceProxy = require("syracuse-core/lib/resource/resourceProxy");
var resourceHelpers = require("syracuse-core/lib/resource/util");
// do not directly "require" the class as initialization sequence might lead to "undefined" (because of early require in factory.js 
// of a module requiring "dataModel.js"
//var Factory = require("./factory").Factory;
var factory = require("./factory");
var locale = require("syracuse-core/lib/locale");
var flows = require('streamline/lib/util/flows');
var sys = require("util");
var types = require("syracuse-core/lib/types/allTypes");
var queryRepr = ["$query", "$lookup", "$search", "$select", "$bulk"]; // query like facets
// localization notes:
// 		localization applies to text, image, sound and video.
//		if property is marked as localized, mapper creates a one to many relationship transparently
//
//		string resources (identified by module name + resource name) are handled
//		explicitly via a StringResource entity because needs input from user
//
//		string is *not* localizable, use text type instead.
var _integerSizes = {
	tiny: 1,
	small: 2,
	medium: 3,
	normal: 4,
	big: 8
};

var _realSizes = {
	small: 4,
	normal: 8
};

var _datetimeSizes = {
	normal: 8,
	big: 8 // same size in mysql but tracks microseconds
};

var _timeSizes = {
	normal: 3,
	big: 8
};

var _binarySizes = {
	tiny: 255,
	normal: 64 * 1024 - 1,
	// 64KB
	medium: 16 * 1024 * 1024 - 1,
	// 16MB
	"long": 4 * 1024 * 1024 * 1024 - 1 // 4GB
};

// divide by 3 because of UTF encoding
var _textLengths = {
	tiny: Math.floor(_binarySizes.tiny / 3),
	// 85
	normal: Math.floor(_binarySizes.normal / 3),
	// 21KB
	medium: Math.floor(_binarySizes.medium / 3),
	// 5.3MB
	"long": Math.floor(_binarySizes["long"] / 3) // 1.3GB
};

var _stringLengths = {
	tiny: 255,
	normal: 1024 // much smaller than text because contributes to row size
};

function _getTranslatedString(stringResources, parts, combineParts) {
	if(!stringResources || ! parts || !parts.length) return "";
	for(var i = 0; i < (combineParts ? parts.length : 1); i++) {
		var str = stringResources[parts.slice(i).join(".")];
		//console.log("resource for : "+parts.slice(i).join(".")+"="+str);
		if(str) return str;
	}
}

function _setSize(prop, def, sizes, hasLength) {
	if (hasLength && !prop.size && prop.maxLength) prop.size = Object.keys(sizes).filter(function(size) {
		return sizes[size] >= prop.maxLength;
	})[0];
	prop.size = prop.size || def;
	if (hasLength) {
		if (!prop.maxLength) prop.maxLength = sizes[prop.size]
		// sanity check
		if (prop.maxLength > sizes[prop.size]) throw new Error(prop.name + ": maxLength incompatible with size")

		if (!sizes[prop.size]) throw new Error(prop.name + ": invalid size: " + prop.size);
	}
}

function _getLink(facetName, title, params, entityName) {
	var link = {
		$type: "application/json;vnd.sage=syracuse"
	}
	if (title) link.$title = title;
	var plural = (entityName && pluralize(entityName)) || "{$pluralType}";
	var singular = entityName || "{$representation}";
	//
	switch (facetName) {
	case "$details":
		link.$url = "{$baseUrl}/" + plural + "('{$key}')?representation=" + singular + "." + facetName + "&role={$role}" + (params ? "&" + params : "");
		break;
	case "$lookup":
	case "$select":
	case "$query":
		link.$url = "{$baseUrl}/" + plural + "?representation=" + singular + "." + facetName + "&role={$role}" + (params ? "&" + params : "");
		break;
	case "$edit":
		link.$url = "{$baseUrl}/" + plural + "('{$key}')/$workingCopies?representation=" + singular + "." + facetName + "&role={$role}" + (params ? "&" + params : "");
		link.$method = "POST";
		break;
	case "$create":
		// $create facet is in fact an $edit facet
		link.$url = "{$baseUrl}/" + plural + "/$template/$workingCopies?representation=" + singular + ".$edit&role={$role}" + (params ? "&" + params : "");
		link.$method = "POST";
		break;
	}
	return link;
}

var _decoratePropertyProtoMap = {
		graph: function(_, $p, entity, prop) {
			$p.$url = "{$baseUrl}/{$pluralType}('{$key}')/$graphs/" + prop.name;
			$p.$linkCategories = [];
			$p.$nodeCategories = [];
			//
			var maps = prop.getGraphRelationsMaps(_);
			//
			flows.eachKey(_, maps.nodes, function(_, nodeName, node) {
				$p.$nodeCategories.push(node);
			});
			flows.eachKey(_, maps.links, function(_, linkName, link) {
				$p.$linkCategories.push(link);
			});
		},
		"tag-cloud": function(_, $p, entity, prop) {
			$p.$url = "{$baseUrl}/{$pluralType}('{$key}')/$tagClouds/" + prop.name;
			$p.$nodeCategories = [];
			// TODO
			$p.$nodeCategories.push({$title: "Categ test", $prototype: {$properties: {$value: "Test"}}});
		}
	}

function _copyConstraints(src, dst) {
	// TODO: check this $constraints list
	['$minLength', '$maxLength', '$minValue', '$maxValue', //
	'$isUnique', '$isNullable', '$isMandatory', '$isDefined', //
	 '$scale', '$precision'].forEach(function(key) {
	 	if (src[key] !== undefined) dst[key] = src[key];
	 });
}

function _normalizeCapabilities(prop, facetName, isChild) {
	var cap = (prop.$capabilities && prop.$capabilities.split(",")) || [];
	var i_add = cap.indexOf("insert");
	var i_app = cap.indexOf("append");
	var i_del = cap.indexOf("delete");
	// ad standard caps only if the class caps is not defined
	if(prop.$capabilities == null) {
		if(cap.indexOf("sort") < 0) cap.push("sort");
		if(facetName === "$edit") {
			if(prop.$isArray || prop.isPlural) {
				if(i_add < 0) cap.push("insert");
				if(i_add < 0) cap.push("append");
				if(i_del < 0) cap.push("delete");
			}
// by default no reorder
//			if(prop.isPlural)
//				cap.push("reorder");
		}
		if(!isChild && (cap.indexOf("filter") < 0))
			cap.push("filter");
	}
	if(facetName !== "$edit") {
		if(i_add >= 0) cap.splice(i_add, 1);
		if(i_app >= 0) cap.splice(i_app, 1);
		if(i_del >= 0) cap.splice(i_del, 1);
	}
	//console.log("(183): "+prop.name+"."+facetName+"; array: "+(prop.$isArray || prop.isPlural)+"; result="+cap.join(","));
	return cap.join(",");
}

function _getEntityPrototype(_, model, entity, reprName, facetName, isChild, childPrefix) {
	function _fillProtoTemplates(result, e) {
		result.$url = "{$baseUrl}/{$pluralType}('{$key}')";
		result.$value = (e.$valueTemplate && (_getTranslatedString(stringRes, [e.name, "$valueTemplate"]) 
			|| e.$valueTemplate.expression)) || "{$key}";
		// $title conflicts with the property title for reference thumb.
		//			result.$title = (e.$titleTemplate && e.$titleTemplate.expression) || (e.title + " {$key}");
		result.$description = (e.$descriptionTemplate && (_getTranslatedString(stringRes, [e.name, "$descriptionTemplate"]) 
			|| e.$descriptionTemplate.expression)) || _getTranslatedString(stringRes, [e.name, "$title"]) || result.$title;
		// extract all fields in templates
		result.$key = "{$uuid}";
		result.$properties = {};
		var allFields = {};

		function addField(elem) {
			elem = elem.substring(1, elem.length - 1);
			if (!allFields[elem] && e.$properties[elem]) allFields[elem] = e.$properties[elem];
		}
		if (e.$valueTemplate && e.$valueTemplate.matches) e.$valueTemplate.matches.forEach(addField);
		if (e.$titleTemplate && e.$titleTemplate.matches) e.$titleTemplate.matches.forEach(addField);
		if (e.$descriptionTemplate && e.$descriptionTemplate.matches) e.$descriptionTemplate.matches.forEach(addField);
		//
		forEachKey(allFields, function(field, value) {
			result.$properties[field] = {
				$type: value.getMimeType()
			}
		});
	}

	function _fillThumb($thumb, e, rel, prefix) {
		_fillProtoTemplates($thumb, e);
		$thumb.$url += "?representation={$representation}.$thumb";
		$thumb.$prototype = "{$baseUrl}/$prototypes('{$representation}.$thumb')";
		$thumb.$representation = e.name;
		if(rel.$isDisabled && (typeof rel.$isDisabled !== "function")) $thumb.$isDisabled = rel.$isDisabled;
		if(rel.$isReadOnly && (typeof rel.$isReadOnly !== "function")) $thumb.$isReadOnly = rel.$isReadOnly;
		$thumb.$links = {
			$details: _getLink("$details", null, "", e.name)
		};
		//
		//var lookupLinkName = ((rel && rel.isPlural && rel.relType !== "children") ? "$select" : "$lookup");
		var lookupLinkName = "$lookup";
		$thumb.$links[lookupLinkName] = _getLink(lookupLinkName, locale.format(module, "createTableActionTitle"), 
				"trackingId={$trackingId}" + ((rel && rel.name) ? "&binding=" + prefix : ""), e.name);
	}

	function _addWordLinks(_, resource, entityName, facetName)
	{
		if(!adminBaseUrl) {
			var adminEP = require("syracuse-collaboration/lib/helpers").AdminHelper.getCollaborationEndpoint(_);
			adminBaseUrl = adminEP.getBaseUrl(_);
		}
		if (queryRepr.indexOf(facetName) >= 0) {
			resource.$links.$wordmailmerge = {
				"$title": locale.format(module, "mailMerge"),
				"$url": _getLink(facetName).$url + "&createMode={creationMode}&doc_uuid={document}",
				"$type": httpHelper.mediaTypes.word_mailmerge,
				
				"$parameters": {
					"$url": adminBaseUrl + "/msoMailMergeDocSels/$template/$workingCopies?representation=msoMailMergeDocSel.$edit&role={$role}",
					"$method": "POST",
					"$properties": {
						"dummy": {  // the user will be prompted to enter user1 value
							"$title": "dummy",
							"$type": "application/x-string"
						}
					},
					"msoCurrentRepresentation": "{$representation}" + "." + facetName
				}
			};
		}

		resource.$links.$wordreport = {
			"$title": locale.format(module, "wordReport"),
			"$url": _getLink(facetName).$url + "&reportMode={reportMode}&doc_uuid={document}",
			"$type": httpHelper.mediaTypes.word_report,
			
			"$parameters": {
				"$url": adminBaseUrl + "/msoReportModes/$template/$workingCopies?representation=msoReportMode.$edit&role={$role}",
				"$method": "POST",
				"$properties": {
					"dummy": { 
						"$title": "dummy",
						"$type": "application/x-string"
					}
				},
				"msoCurrentRepresentation": "{$representation}" + "." + facetName
			}
		}
	}
	function _addPptLinks(resource)
	{
		if (queryRepr.indexOf(facetName) >= 0) {
			resource.$links.$pptslide = {
				"$title": locale.format(module, "createNewSlide"),
				"$url": _getLink(facetName).$url + "&pptMode=newSlide",
				"$type": httpHelper.mediaTypes.ppt_slide
			}
		}
	}	

	//
	var adminBaseUrl = null;
	var stringRes = entity.contract.resources && entity.contract.resources();
	var resource = {
		$type: "application/json"
	};
	resource.$prototype = "{$baseUrl}/$prototypes('{$representation}." + facetName + "')";
	if (!isChild) {
		resource.$url = "{$baseUrl}/{$pluralType}('{$key}')";
		resource.$value = (entity.$valueTemplate && (_getTranslatedString(stringRes, [entity.name, "$valueTemplate"]) || entity.$valueTemplate.expression)) || "{$key}";
		resource.$title = (entity.$titleTemplate && (_getTranslatedString(stringRes, [entity.name, "$titleTemplate"]) || entity.$titleTemplate.expression)) || (entity.title + " {$key}");
	}
	resource.$description = (entity.$descriptionTemplate && (_getTranslatedString(stringRes, [entity.name, "$descriptionTemplate"]) || entity.$descriptionTemplate.expression)) || resource.$title;
	resource.$pluralType = entity.plural;
	resource.$representation = reprName;
	var $ = resource.$properties = {};
	flows.eachKey(_, entity.$properties, function(_, name, prop) {
		//if (prop.type === "json") return;
		if ((prop.type === "graph") && (queryRepr.indexOf(facetName) >= 0)) return;
		if ((prop.type === "password") && (facetName !== "$edit")) return;
		if (prop.$isDeveloppementFeature && !helpers.enableDeveloppementFeatures) return;
		//
//don't send default values as might create an difference between the value stored on server and showed by the client
//		if (typeof prop.$default !== "undefined") {
//			resource[name] = resourceHelpers.formatValue(prop, prop.$default);
//		}
		//
		var $p = $[name] = prop.getPropertyPrototype(_, stringRes, facetName, isChild);
	});
	var $links = resource.$links = {};
	flows.eachKey(_, entity.$relations, function(_, name, rel) {
		if (rel.isPlural && (queryRepr.indexOf(facetName) >= 0)) return;
		if (rel.relType == "parent") return;
		var $r = ($[name] = {});
		$r.$title = _getTranslatedString(stringRes, [entity.name, name, "$title"], true) || rel.title;

		// TODO: check the list of constraints that we copy
		//$r.$constraints = rel.$constraints;
		$r.$isUnique = rel.$isUnique;

		if(rel.$isMandatory && (typeof rel.$isMandatory !== "function")) $r.$isMandatory = rel.$isMandatory;
		if(rel.$isDisabled && (typeof rel.$isDisabled !== "function")) $r.$isDisabled = rel.$isDisabled;
		if(rel.$isReadOnly && (typeof rel.$isReadOnly !== "function")) $r.$isReadOnly = rel.$isReadOnly;
		//
		$r.$capabilities = _normalizeCapabilities(rel, facetName, isChild);
		//
		if(rel.$isHidden && (typeof rel.$isHidden !== "function")) $r.$isHidden = rel.$isHidden;
		// properly format binding for childrens
		var thumbRelName = rel.name;
		if(childPrefix)
			thumbRelName = childPrefix.replace("uuid", "parent_uuid") + "('{$uuid}')/" + thumbRelName;
		//
		if (rel.isPlural) {
			$r.$type = "application/x-array";
			var $item = $r.$item = {};
			switch (rel.relType) {
			case "association":
			case "link":
				if (rel.$assoType) {
					$item = $r.$item = _getEntityPrototype(_, model, rel.targetAssoEntity, rel.targetAssoEntity.name, "$thumb", true, thumbRelName);
					if (facetName === "$edit") {
						$r.$actions = $r.$actions || {};
						$r.$actions.$create = $r.$actions.$create || {
							$title: locale.format(module, "createTableActionTitle"),
							$method: "PUT"
						}
					}
				} else {
					$item.$type = "application/x-reference";
					_fillThumb($item, rel.targetEntity, rel, thumbRelName);
					($r.$links = $r.$links || {}).$select = _getLink("$select", locale.format(module, "createTableActionTitle"), 
							"trackingId={$trackingId}" + (rel.name ? "&binding=" + thumbRelName : ""), rel.targetEntity.name);
				}
				break;
			case "children":
				$item = $r.$item = _getEntityPrototype(_, model, rel.targetEntity, rel.targetEntity.name, facetName, true, thumbRelName);
				// override representation
				$item.$representation = rel.targetEntity.name;
				if (facetName === "$edit") {
					$r.$actions = $r.$actions || {};
					if(rel.$select) {
						$r.$actions.$select = $r.$actions.$select || {
							$title: locale.format(module, "createTableActionTitle"),
							$method: "PUT"
						}
						var a = $r.$actions.$select;
						a.$parameters = a.$parameters || {};
						var selectEnt = model.getEntity(rel.$select.$type);
						a.$parameters.$actions = a.$parameters.$actions || {};
						a.$parameters.$actions.$select = {
							$title: rel.$select.$title,
							$type: "application/x-array",
							$item: _getEntityPrototype(_, model, selectEnt, selectEnt.name, "$select", true, thumbRelName),
							$url: "{$baseUrl}/" + selectEnt.plural + "?representation=" + selectEnt.name + ".$select" + 
								(rel.$select.$parameters ? "&" + rel.$select.$parameters : "")
						}
//						if(rel.$select.$selectField) 
//							$r.$actions.$create.$parameters.$actions.$select.$selectField = rel.$select.$selectField;
					} else {
						$r.$actions.$create = $r.$actions.$create || {
							$title: locale.format(module, "createTableActionTitle"),
							$method: "PUT"
						}
					}
				}
				break;
			default:
				throw new Error(locale.format(module,"badRelType",rel.relType));
			}
		} else {
			switch (rel.relType) {
			case "child":
				$r.$type = "application/x-object";
				$item = $r.$item = _getEntityPrototype(_, model, rel.targetEntity, rel.targetEntity.name, facetName, true, thumbRelName);
				if (facetName === "$edit") {
					$r.$actions = $r.$actions || {};
					$r.$actions.$create = $r.$actions.$create || {
						$title: locale.format(module, "createActionTitle"),
						$method: "PUT"
					}
				}
				break;
			case "reference":
				$r.$type = "application/x-reference";
				_fillThumb($r, rel.targetEntity, rel, thumbRelName);
				break;

			default:
				throw new Error(locale.format(module,"badRelType",rel.relType));
			}
		}
	})
	// some standard properties
	$["$creUser"] = {
			$title: "Created by",
			$type: "application/x-string",
			$isDisabled: true,
			$isHidden: true,
			$capabilities: "sort,filter"
		};
	$["$updUser"] = {
			$title: "Updated by",
			$type: "application/x-string",
			$isDisabled: true,
			$isHidden: true,
			$capabilities: "sort,filter"
		};
	$["$creDate"] = {
			$title: "Created on",
			$type: "application/x-datetime",
			$isDisabled: true,
			$isHidden: true,
			$capabilities: "sort,filter"
		};
	$["$updDate"] = {
			$title: "Updated on",
			$type: "application/x-datetime",
			$isDisabled: true,
			$isHidden: true,
			$capabilities: "sort,filter"
		};
	//
	if ((facetName !== "$child") && !isChild) {
		entity.fillLinksResource(facetName, resource);
		//
		_addWordLinks(_, resource, entity.name, facetName);
		// removed ppt since reporting in ppt is not supported yet
		// _addPptLinks(resource, facetName);
		//
		if (queryRepr.indexOf(facetName) >= 0) {
			var old = resource;
			resource = {
				$baseUrl: resource.$baseUrl,
				$baseType: resource.$baseType,
				$url: "{$baseUrl}/" + entity.plural,
				$type: resource.$type,
				$title: _getTranslatedString(stringRes, [entity.name, "$listTitle"]) || locale.format(module, "listOf", entity.plural),
				$properties: {
					$resources: {
						$type: "application/x-array",
						$item: resource
					}
				}
			}
			if (facetName !== "$search") {
				resource.$pluralType = entity.plural;
				resource.$representation = reprName;
			}
			resource.$links = resource.$links || {};
			resource.$links.$create = _getLink("$create", _getTranslatedString(stringRes, [entity.name, "$createActionTitle"]) || locale.format(module, "newLinkTitle", entity.name));
			//
			resource.$links.$print = _getLink(facetName, locale.format(module, "print"));
			resource.$links.$print.$type = httpHelper.mediaTypes.pdf;
			resource.$links.$excel = _getLink(facetName, locale.format(module, "excel"));
			resource.$links.$excel.$type = httpHelper.mediaTypes.excel_worksheet;
			_addWordLinks(_, resource, entity.name, facetName);
			// removed ppt since reporting in ppt is not supported yet
			// _addPptLinks(resource, facetName);
			
			delete old.$baseType;
			delete old.$baseUrl;
			//old.$type = result.$baseType + "." + entity.name + ":$queryItem";
			old.$type = "application/json";
		}
	} else if (isChild) {
		if (facetName === "$edit") {
			resource.$actions = resource.$actions || {};
			resource.$actions.$delete = resource.$actions.$delete || {
				$title: locale.format(module, "deleteActionTitle"),
				$method: "PUT"
			}
		}
	}
	//
	return resource;
}

function _initProperty(entity, prop) {
	prop.type = prop.type || prop.$type || "string";
	prop.title = prop.title || prop.$title || prop.name;
	prop.$title = prop.$title || prop.title;
	if(prop.$enumCaptions)
		throw new Error(locale.format(module, "enumFormatDeprecated", entity.name, prop.name));
//		prop.$enumValues = prop.$enum;
//	delete prop.$enum;
	// dont create the property if there isn't any default value, as null property means null default value
	if (prop.hasOwnProperty("defaultValue")) 
		prop.defaultValue = prop.defaultValue;
	else
		if (prop.hasOwnProperty("$default")) 
			prop.defaultValue = prop.$default;
	prop.minLength = prop.$minLength;
	prop.maxLength = prop.$maxLength;
	prop.mandatory = prop.$isMandatory;
	prop.nullable = prop.$isNullable;

/*	if (prop.$enumValues) {
		var captions = prop.$enumCaptions || [];
		prop.$enum = prop.$enumValues.map(function(v, i) {
			return { $value: v, $title: captions[i]};
		});
	}*/
	prop.getAllConstraints = (function() {
		var c = {};
		_copyConstraints(this, c);
		if (this.$isMandatory) c.$isMandatory = this.$isMandatory;
		if (this.$isDefined) c.$isDefined = this.$isDefined;
		return c;
	}).bind(prop);
	//
	prop.isExternalStorage = (function() {
//		return (!(this.$storage === "inline") && (["image", "binary"].indexOf(this.type) >= 0));
		return (this.hasOwnProperty("$storage"));
	}).bind(prop);
	// 
	prop.getMimeType = (function() {
		switch(this.type) {
		case "image":
		case "text/rtf":
			return this.type;
		default:
			return ("application/x-" + this.type);
		}
	}).bind(prop);
	// add type specific operations
	prop.getPropertyPrototype = (function(_, stringRes, facetName, isChild) {
		var name = this.name;
		var res = {};
		res.$title = _getTranslatedString(stringRes, [entity.name, name, "$title"], true) || prop.$title;
		res.$isHidden = prop.$isHidden;
		var $p;
		if(this.$isArray) {
			res.$type = "application/x-array";
			$p = res.$item = {};
		} else
			$p = res;
		if (prop["$enum"] && Array.isArray(prop["$enum"])) {
			$p.$type = "application/x-choice";
			var $value = $p.$value = {
				$type: prop.getMimeType(),
			}
			_copyConstraints(prop, $value);
//			var enumCaptions = prop.$enumCaptions || [];
			var protoEnum = $value.$enum = [];
			prop["$enum"].forEach(function(e, idx) {
				protoEnum.push({
					$value: e.$value,
					$title: _getTranslatedString(stringRes, [entity.name, name, e.$value], true) || e.$title || e.$value
				});
			});
		} else {
			$p.$type = prop.getMimeType();
			if(prop.isExternalStorage())
				if(facetName === "$edit")
					$p.$url = "{$baseUrl}/$workingCopies('{$trackingId}')/"+name;
				else
					$p.$url = "{$baseUrl}/{$pluralType}('{$key}')/"+name;
			$p.$format = prop.$format;
			_copyConstraints(prop, $p);
			if(prop.$isMandatory && (typeof prop.$isMandatory !== "function")) $p.$isMandatory = prop.$isMandatory;
			if(prop.$isDisabled && (typeof prop.$isDisabled !== "function")) $p.$isDisabled = prop.$isDisabled;
			if(prop.$isReadOnly && (typeof prop.$isReadOnly !== "function")) $p.$isReadOnly = prop.$isReadOnly;
			//
		}
		if (prop.isComputed || prop.$compute) $p.$isDisabled = true;
		// capabilities: use "res" variable for $capabilities as for the arrays we must be on prop level not on $item (as is $p)
		res.$capabilities = _normalizeCapabilities(prop, facetName, isChild);
//		$p.$capabilities = prop.hasOwnProperty("$capabilities") ? prop.$capabilities : (isChild ? "sort" : "sort,filter");
		if((prop.type === "string") && (res.$capabilities.indexOf("alphaTab") < 0)) 
			res.$capabilities = res.$capabilities + ",alphaTab"; 
		//
		// for now, move il later in dataModel.js ?
		if (prop.$linksToDetails && (facetName !== "$lookup" && facetName !== "$select")) {
			$p.$links = {
				$details: _getLink("$details")
			}
		}
		if (prop.$lookup) {
			$p.$links = $p.$links || {};

			$p.$links.$lookup = (typeof prop.$lookup === 'function') ?  {} : _getLink("$lookup", null, "trackingId={$trackingId}&binding=" + prop.name + (prop.$lookup.parameters ? "&" + prop.$lookup.parameters : ""), prop.$lookup.entity);

			$p.$links.$lookup.$result = prop.$lookup.field;
		}
		//
		_decoratePropertyProtoMap[prop.$type] && _decoratePropertyProtoMap[prop.$type](_, $p, entity, prop);
		//
		return res;
	}).bind(prop);
	//
	prop.getDefaultValue = (function(_, instance) {
		var property = this;
		if(property.hasOwnProperty("defaultValue")) {
			if(typeof property.defaultValue === "function")
				return property.defaultValue();
			else
				return property.defaultValue; 
		} else
			return (types[(property.$type || "string")] || {}).defaultValue;
	}).bind(prop);
	//
	prop.hasDefaultValue = (function() {
		return this.hasOwnProperty("defaultValue");
	}).bind(prop);
	//
	if(prop.$type === "graph")
		prop.getGraphRelationsMaps = (function(_) {
			function _addNodes(_, rel, relMap, walked) {
				var ent = rel.targetEntity;
				if(!nodesMap[ent.name])
					nodesMap[ent.name] = {
						$name: ent.name,
						$title: ent.$titleTemplate && ent.$titleTemplate.expression,
						$selected: (relMap.$selected !== false),
						$prototype: {
							$properties: {
								$value: ent.$valueTemplate && ent.$valueTemplate.expression
							},
							$links: {
								$default: {
									$url: "{$baseUrl}/" + ent.plural+ "('{$uuid}')?representation=" + ent.name + ".$details",
									$target: "blank"
								}
							}
						}
					}
				if(!linksMap[walked])
					linksMap[walked] = {
						$name: walked,
						$title: rel.$title
					}
			}
			function _walkRelation(_, ent, relName, relMap, walked) {
				if(relName[0] === "$") return;
				//
				var targetEntity = ent.$relations && ent.$relations[relName] && ent.$relations[relName].targetEntity;
				if(!targetEntity) throw new Error(locale.format(module, "relationEntityNotFound", relName));
				// 
				_addNodes(_, ent.$relations[relName], relMap, walked);
				// continue recursion
				flows.eachKey(_, relMap, function(_, locRelName, locRelMap) {
					_walkRelation(_, targetEntity, locRelName, locRelMap, walked + "." + locRelName);
				})
			}
			var nodesMap = {};
			var linksMap = {};
			// add starting point
			nodesMap[entity.name] = {
				$name: entity.name,
				$title: entity.$titleTemplate && entity.$titleTemplate.expression,
				$selected: true,
				$prototype: {
					$properties: {
						$value: entity.$valueTemplate && entity.$valueTemplate.expression
					}
				}
			}
			//
			flows.eachKey(_, this.$relations, function(_, relName, relation) {
				_walkRelation(_, entity, relName, relation, relName);
			});
			//
			return {
				nodes: nodesMap,
				links: linksMap
			}
		}).bind(prop);
}

var _allEvents = ["$beforeSave", "$canSave", "$afterSave"];

function _getMeta(entity, metaName, parameters, selected, needsThumb, forceChildren, depth) {
	return {
		entity: entity,
		name: metaName,
		$properties: entity.$properties,
		$relations: entity.$relations,
		isSelected: selected,
		needsThumb: needsThumb,
		defaultOrder: entity.defaultOrder
	};
}

function _checkDefaultOrder(entity, orders) {
	orders.forEach(function(order) {
		if (!(order instanceof Array)) throw new Error(entity.name + ": default order element is not an array");
		if (!entity.$properties[order[0]]) throw new Error(entity.name + ": invalid order property: " + order[0]);
		if (order[1] === undefined) order[1] = true;
	})
}

function DataModel(contract) {
	var datasetOperations = {};
	var mapper = null;

	var pluralMap = {};
	var classMap = {}; // entities (not factories) by class name
	var self = this;

	var entities = contract.entities || {};
	var rules = contract.$rules || {};
	var _tags = [];
	//
	this.dbMeta = contract.dbMeta || {};
	this.name = contract.name;

	function _tagsMask(tags) {
		if (!tags) return 0;
		var mask = 0;
		tags.split(",").forEach(function(tag) {
			var i = _tags.indexOf(tag);
			if (i < 0) {
				i = _tags.length;
				_tags.push(tag);
			}
			mask |= 1 << i;
		});
		return mask;
	}

	forEachKey(entities, function(name, entity) {
		entity.name = name;
		entity.className = entity.className || capitalize(name);
		entity.plural = entity.plural || pluralize(name);
		entity.contract = contract;
		entity.title = entity.title || entity.$title || entity.name;
		// default $isPersistent is true
		if (!entity.hasOwnProperty("$isPersistent")) entity.$isPersistent = true;
		if (pluralMap[entity.plural]) throw new Error(entity.name + ": duplicate plural: " + entity.plural);
		if (entities[entity.plural]) throw new Error(entity.name + ": plural is identical to singular: " + entity.plural)

		entity.$properties = entity.$properties || {};
		var fields = {};
		helpers.object.forEachKey(entity.$properties, function(propName, prop) {
			prop.name = propName;
			prop.tagsMask = _tagsMask(prop.tags);
			_initProperty(entity, prop);
			if (!prop.isComputed) fields[propName] = prop;
		});

		classMap[entity.className] = entity;
		pluralMap[entity.plural] = name;

		entity.defaultOrder = entity.defaultOrder || entity.$defaultOrder;
		if(!entity.defaultOrder && entity.$properties["description"])
			entity.defaultOrder = [["description", true]];
		if(!entity.defaultOrder)
			entity.defaultOrder = [];
		_checkDefaultOrder(entity, entity.defaultOrder);

		if (entity.descriptor) {
			if (typeof entity.descriptor != "function" && !entity.$properties[entity.descriptor]) throw new Error(entity.name + ": invalid descriptor property: " + entity.descriptor);
		}

		entity.$services = entity.$services || {};
		entity.$events = entity.$events || {};
		_allEvents.forEach(function(name) {
			entity.$events[name] = entity.$events[name] || [];
		});
		entity.$methods = entity.$methods || {};
		entity.$functions = entity.$functions || {};
		entity.$rules = entity.$rules || {};
		entity.$links = entity.$links || {};
		entity.$actions = entity.$actions || {};
		// allProperties =  properties + relations
		var allProps = Object.keys(entity.$properties);
		entity.$relations = entity.$relations || {};
		forEachKey(entity.$relations, function(relName, rel) {
			rel.name = relName;
			rel.title = rel.title || rel.$title || rel.name;
			rel.isComputed = rel.isComputed || rel.$isComputed;
			rel.isChild = rel.isChild || rel.$isChild;
			rel.tagsMask = _tagsMask(rel.tags);
			if (typeof rel.optional == "undefined") rel.optional = false;
			if (rel.isChild) rel.owned = true;
			if (rel.before) {
				var i = allProps.indexOf(rel.before);
				if (i < 0) allProps.push(relName);
				else allProps.splice(i, 0, relName);
			} else allProps.push(relName);
		})
		entity.allProperties = {};
		allProps.forEach(function(propertyName) {
			if (entity.$properties[propertyName]) entity.allProperties[propertyName] = entity.$properties[propertyName];
			else entity.allProperties[propertyName] = entity.$relations[propertyName];

		});
		forEachKey(entity.$links, function(name, link) {
			link.name = name;
			link.tagsMask = _tagsMask(link.tags);
		});
		forEachKey(entity.$actions, function(name, action) {
			action.name = name;
			action.tagsMask = _tagsMask(action.tags);
		});

		function _makeTemplate(str) {
			var template = new resourceProxy.Template(str);
			(template.matches || []).forEach(function(match) {
				match = match.substring(1, match.length - 2).trim();
				if (entity.$properties[match]) entity.$properties[match].usedByTemplate = true;
			});
			return template;
		}
		if (entity.$valueTemplate && (typeof entity.$valueTemplate === "string")) entity.$valueTemplate = _makeTemplate(entity.$valueTemplate);
		if (entity.$summaryTemplate && (typeof entity.$summaryTemplate === "string")) entity.$summaryTemplate = _makeTemplate(entity.$summaryTemplate);
		if (entity.$titleTemplate && (typeof entity.$titleTemplate === "string")) entity.$titleTemplate = _makeTemplate(entity.$titleTemplate);
		if (entity.$descriptionTemplate && (typeof entity.$descriptionTemplate === "string")) entity.$descriptionTemplate = _makeTemplate(entity.$descriptionTemplate);
		if (entity.$iconTemplate && (typeof entity.$iconTemplate === "string")) entity.$iconTemplate = _makeTemplate(entity.$iconTemplate);
		entity.$urlTemplate = _makeTemplate("{$baseUrl}/" + entity.plural + "('{$key}')?representation=" + entity.name + ".$details");
		
		// usefull functions
		entity.createInstance = (function(_, db, initial) {
			return this.factory.createInstance(_, initial, db);
		}).bind(entity);
		entity.fetchInstance = (function(_, db, options) {
			return db.fetchInstance(_, this, options);
		}).bind(entity);
		entity.fetchInstances = (function(_, db, options) {
			return db.fetchInstances(_, this, options);
		}).bind(entity);
		entity.count = (function(_, db, options) {
			return db.count(_, this, options);
		}).bind(entity);
		// add standard links resources for the entity
		entity.fillLinksResource = (function(reprType, resource) {
			var stringRes = contract.resources && contract.resources();
			var self = this;
			var $links = (resource.$links = (resource.$links || {}));
			if (reprType !== "$details") {
				if (self.$isPersistent !== false) $links.$details = _getLink("$details", locale.format(module,"detailsLinkTitle"));
			}
			if (reprType !== "$edit") {
				if(self.$canEdit !== false)
					$links.$edit = _getLink("$edit", locale.format(module, "editLinkTitle"));
				if(self.$canDelete !== false)
					$links.$delete = {
						$title: locale.format(module, "deleteActionTitle"),
						$confirm: locale.format(module, "deleteConfirmMessage", self.$valueTemplate && self.$valueTemplate.expression),
						// send to query representation
						$url: "{$baseUrl}/{$pluralType}('{$key}')?representation={$representation}." + reprType + "&role={$role}",
						$type: "application/json;vnd.sage=syracuse",
						$method: "DELETE"
					}
			}
			if (reprType !== "$query") {
				if (self.$isPersistent !== false) $links.$query = _getLink("$query", _getTranslatedString(stringRes, [self.name, "$listTitle"]) || locale.format(module, "listOf", self.name));
			}
			if (reprType === "$edit") {
				resource.$actions = resource.$actions || {};
				if (self.$canSave !== false) {
					resource.$actions.$save = resource.$actions.$save || {
						$title: locale.format(module, "saveActionTitle"),
						$isDisabled: true,
						$links: {
							$details: _getLink("$details", locale.format(module, "ok"), "", self.name),
							$query: _getLink("$query", locale.format(module, "backToList"), "", self.name),
							$create: _getLink("$create", _getTranslatedString(stringRes, [self.name, "$createActionTitle"]) || locale.format(module, "newLinkTitle", self.name), "", self.name)
						}
					}
					resource.$actions.$save.$links.$details.$isHidden = (self.$isPersistent === false);
					resource.$actions.$save.$links.$query.$isHidden = (self.$isPersistent === false);
					resource.$actions.$save.$links.$create.$isHidden = (self.$isPersistent === false);
				}
			}
			// services
			forEachKey(self.$services, function(key, service) {
				if (service.$method && (service.$method !== "GET") && (reprType === "$edit")) {
					resource.$actions = resource.$actions || {};
					var action = resource.$actions[key] = {};
					action.$title = service.$title || key;
					action.$method = service.$method || "GET";
				} else {
					// make service links
					resource.$links = resource.$links || {};
					var link = resource.$links[key] = {
						$type: "application/json;vnd.sage=syracuse",
						$title: service.$title || key,
						$method: service.$method || "GET",
						$url: "{$baseUrl}/{$pluralType}('{$uuid}')/$service/" + key
					}
				}
			});
			resource.$links = resource.$links || {};
			forEachKey(self.$links, function(key, link) {
				if(typeof link !== "function")
					resource.$links[key] = link;
			});
			// PDFHACK
			$links.$print = _getLink(reprType, locale.format(module, "print"));
			$links.$print.$type = "application/pdf";

			// $lookup and $select items should only have $details link
			if (["$lookup", "$select"].indexOf(reprType) >= 0) {
				resource.$links = {
					$details: _getLink("$details", locale.format(module,"detailsLinkTitle"))		 
				}
			}
		}).bind(entity);
		entity.getPrototype = (function(_, reprName, facetName) {
			return _getEntityPrototype(_, self, entity, reprName, facetName);
		}).bind(entity);
		entity.getModel = (function() {
			return self;
		}).bind(entity);
		// search facets
		if(contract.searchFacets)
			forEachKey(contract.searchFacets, function(key, facet) {
				if(facet.$fields && facet.$fields[entity.name]) {
					var f = entity.$facets = (entity.$facets || {});
					var ff = f[facet.$fields[entity.name]] = (f[facet.$fields[entity.name]] || []);
					ff.push(key);
				}
			});
		entity.getSearchFacets = (function(_) {
			return entity.$facets;
		}).bind(entity);
		entity.getSearchFields = function(_) {
			return entity.$searchIndex && entity.$searchIndex.$fields;
		}
	});
	forEachKey(entities, function(name, entity) {
		forEachKey(entity.$relations, function(relName, rel) {
			rel.name = relName;
			rel.type = rel.type || rel.$type || relName;
			rel.title = rel.title || rel.$title || rel.name;
			rel.mandatory = rel.$isMandatory;
			rel.inv = rel.inv || rel.$inv;
			var singular = pluralMap[rel.type];
			rel.isPlural = rel.$isPlural = singular != null;
			rel.isComputed = rel.isComputed || rel.$isComputed;
			if (rel.isPlural) {
				if (!rel.inv && !helpers.useInstances) throw new Error(entity.name + ": inverse relation missing on " + relName)
				// rel.inv = rel.inv || name; 
				rel.targetEntity = find(entities, singular);
				if (rel.$assoType) {
					rel.targetAssoEntity = find(entities, rel.$assoType);
					if (!rel.$assoInv) throw new Error(entity.name + ": inverse association missing on " + relName);
				}
//				if (rel.defaultOrder !== undefined) (rel.targetEntity, rel.defaultOrder);
//				else rel.defaultOrder = rel.targetEntity.defaultOrder;
				if(!rel.defaultOrder) {
					if(rel.$capabilities && (rel.$capabilities.split(",").indexOf("reorder") >= 0))
						rel.defaultOrder = "$index";
					else
						rel.defaultOrder = rel.targetEntity.defaultOrder;
				}
			} else {
				if (!entities[rel.type]) throw new Error(entity.name + ": relation '" + relName + "' targets unknown type: " + rel.type);
				rel.targetEntity = find(entities, rel.type);
			}
			// 
			if(rel.targetEntity && !rel.isComputed) {
				rel.targetEntity.referingEntities = rel.targetEntity.referingEntities || {};
				rel.targetEntity.referingEntities[name] = rel.targetEntity.referingEntities[name] || [];
				rel.targetEntity.referingEntities[name].push(relName);
			}
		});
		// standard services
		if((entity.$lockType === "pessimist") && !entity.$services.forceLockInstance) {
			// force locking of an instance allready locked by another user
			entity.$services.forceLockInstance = {
				$method: "POST",
				$isMethod: true,
				$title: "Force lock",
				$isHidden: true,
				$execute: function(_, context, instance) {
					// delete locks for instance (other session?)
					instance.unlockInstance(_);
					// lock for this session
					instance.lockInstance(_);
					//
					context.reply(_, 200);
				}
			}
		}
		//
		forEachKey(entity.$staticFunctions, function(name, fn) {
			if (typeof fn != "function") throw new Error(entity.name + ": " + name + " is not a function");
			//
			entity[name] = fn.bind(entity);
		});
		forEachKey(entity.$services, function(name, operation) {
			operation.name = name;
			operation.tagsMask = _tagsMask(operation.tags);
			operation.method = operation.method || operation.$method;
			operation.isMethod = operation.isMethod || operation.$isMethod || false;
			operation.execute = operation.execute || operation.$execute;
			if (typeof operation.execute != "function") throw new Error(entity.name + "operation '" + name + "' does not have execute method");
		});
		//
		forEachKey(entity.$events, function(name, event) {
			if (_allEvents.indexOf(name) < 0) throw new Error(entity.name + ": invalid event name: " + name);

		});
		// set default meta
		entity.getMeta = function(parameters, forceChildren) {
			return _getMeta(entity, entity.plural, parameters || {}, true, false, forceChildren, 0)
		};
	});
	// another pass to verify reverse relationships
	forEachKey(entities, function(name, entity) {
		forEachKey(entity.$relations, function(relName, rel) {
			var inv = rel.targetEntity.$relations[rel.inv];
			if (inv) {
				if (inv.targetEntity != entity) throw new Error(rel.targetEntity.name + "." + inv.name + ": expected type=" + entity.name + ", got type=" + inv.targetEntity.name);
				if (!inv.inv) inv.inv = rel.name;
				if (inv.inv != rel.name) throw new Error(rel.targetEntity.name + "." + inv.name + ": expected inv=" + rel.name + ", got inv=" + inv.inv);
			} else {
				if (rel.isPlural && !helpers.useInstances) throw new Error(entity.name + "." + rel.name + ": missing inverse relation");
			}
		});
		forEachKey(entity.$relations, function(relName, rel) {
			var inv = rel.targetEntity.$relations[rel.inv];
			// classify with relType
			if (rel.isPlural) {
				if (rel.isChild) rel.relType = "children";
				else if (inv && inv.isPlural) rel.relType = "association";
				else rel.relType = "link";
			} else {
				if (rel.isChild) rel.relType = "child";
				else if (inv && inv.isChild) rel.relType = "parent";
				else rel.relType = "reference";
			}
		});
// RECURSION !!!!!
//		entity.shallowMeta = entity.getMeta(null, false);
//		entity.deepMeta = entity.getMeta(null, true);
		//
		forEachKey(entity.$staticFunctions, function(name, fn) {
			if (typeof fn != "function") throw new Error(entity.name + ": " + name + " is not a function");
		});
		forEachKey(entity.$functions, function(name, fn) {
			if (typeof fn != "function") throw new Error(entity.name + ": " + name + " is not a function");
		});
		forEachKey(entity.$methods, function(name, fn) {
			if (typeof fn != "function") throw new Error(entity.name + ": " + name + " is not a function");
		});
	});
	forEachKey(contract.service || {}, function(name, operation) {
		if (typeof operation.execute != "function") throw new Error(entity.name + "operation '" + name + "' does not have execute method");
		datasetOperations[name] = operation;
	});
	self.datasetOperations = function() {
		return helpers.object.clone(datasetOperations, false);
	}
	self.getEntities = function() {
		return helpers.object.clone(contract.entities, false);
	}
	self.getRules = function() {
		return helpers.object.clone(rules, false);
	}
	self.singularize = function(name) {
		return pluralMap[name];
	}
	self.getEntity = function(name) {
		return contract.entities[name];
	}
	self.entityByClassName = function(name) {
		return classMap[name];
	}
	self.getIndexedEntities = function(_) {
		return Object.keys(entities).filter(function(eName) {
			return entities[eName].$searchIndex && entities[eName].$searchIndex.$fields;
		}).map(function(eName) {
			return entities[eName];
		});
	}
	self.getSearchFacets = function(_) {
		return contract.searchFacets;
	}
	
	self.baseType = "application/json;vnd.sage=syracuse";

	forEachKey(entities, function(name, entity) {
		entity.factory = new factory.Factory(entity);
	});
	// global events
	self.$events = {};
	_allEvents.forEach(function(name) {
		self.$events[name] = self.$events[name] || [];
	})
	self.registerEvent = (function(eventName, handler, entityName) {
		var target = entityName ? self.getEntity(entityName) : self;
		if(target && target.$events && target.$events[eventName])
			target.$events[eventName].push(handler);
	}).bind(self);
}

helpers.defineClass(DataModel);

exports.getDefaultRepresentation = function(entity, facetName) {
	//var queryRepr = ["$query", "$lookup", "$search", "$select"]; // query like facets
	//
	//	var repr = [{$name:"general", $title: "General"}];
	//	var section = repr[0];
	//	section.$blocks = [{$name:"general", $contains: []}];
	var repr = {
		$items: [{}]
	};
	//
	if (facetName !== "$thumbnail") {
		//		section.$blocks[0].$contains = Object.keys(entity.$properties).slice(0);
		repr.$items[0].$contains = Object.keys(entity.$properties).slice(0);
		//
		var contains = repr.$items[0].$contains;
		forEachKey(entity.$relations, function(name, rel) {
			if (rel.isPlural) {
				if (queryRepr.indexOf(facetName) < 0) contains.push(name);
			} else contains.push(name);
		});
		//
		if (queryRepr.indexOf(facetName) >= 0) {
			repr.$items[0].$bind = "$resources";
			//			section.$blocks[0].$items = [{$name: "$resources", $contains: contains}];
			//			delete section.$blocks[0].$contains;
		}
	} else repr.$items[0].$contains = (new Array(entity.$valueTemplate && entity.$valueTemplate.expression.substring(1, entity.$valueTemplate.expression.length - 1) || "$key", entity.$titleTemplate && entity.$titleTemplate.expression.substring(1, entity.$titleTemplate.expression.length - 1) || "$key"));
	//	
	return repr;
}

exports.make = function(contract, dataset) {
	// TODO : if the same model should be used for several datasets, first load modifies contract entities 
	// so second load fails. Should detect the case or clone theese entities
//	dataset = dataset || "all";
	// for now, same model for all dataset of the same contract
	dataset = "all";
	contract.models = contract.models || {};
	var model = contract.models[dataset];
	return model ? model : (contract.models[dataset] = new DataModel(contract));
}

exports.getOrm = function(_, model, dataset) {
//	console.log("dataset "+dataset.driver);
	if (dataset.driver && (dataset.driver === "mongodb")) return require("syracuse-orm/lib/mongoDbHandle").create(_, model, dataset);
	else return require("syracuse-orm/lib/mysqlDbHandle").create(_, model, dataset);
}
