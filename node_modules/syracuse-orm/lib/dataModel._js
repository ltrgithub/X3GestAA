"use strict";

var helpers = require('syracuse-core/lib/helpers');
var httpHelper = require("syracuse-sdata/lib/httpHelper");
var find = helpers.object.find;
var forEachKey = helpers.object.forEachKey;
var pluralize = helpers.string.pluralize;
var capitalize = helpers.string.capitalize;
var orm = require("./orm");
var resourceProxy = require("syracuse-core/lib/resource/resourceProxy");
var resourceHelpers = require("syracuse-core/lib/resource/util");
var globals = require('streamline/lib/globals');
// do not directly "require" the class as initialization sequence might lead to "undefined" (because of early require in factory.js
// of a module requiring "dataModel.js"
//var Factory = require("./factory").Factory;
var factory = require("./factory");
var locale = require("syracuse-core/lib/locale");
var flows = require('streamline/lib/util/flows');
var entityClasses = require("./entities");
var sys = require("util");
var types = require("syracuse-core/lib/types/allTypes");
var queryRepr = ["$query", "$lookup", "$search", "$select", "$bulk"]; // query like facets
// localization notes:
// 		localization applies to text, image, sound and video.
//		if property is marked as localized, mapper creates a one to many relationship transparently
//
//		string resources (identified by module name + resource name) are handled
//		explicitly via a StringResource entity because needs input from user
//
//		string is *not* localizable, use text type instead.

function _getTranslatedString(stringResources, parts, combineParts) {
	if (!stringResources || !parts || !parts.length) return "";
	for (var i = 0; i < (combineParts ? parts.length : 1); i++) {
		var str = stringResources[parts.slice(i).join(".")];
		//console.log("resource for : "+parts.slice(i).join(".")+"="+str);
		if (str) return str;
	}
}

function _getLink(facetName, title, params, entityName) {
	var link = {
		$type: "application/json;vnd.sage=syracuse"
	};
	if (title) link.$title = title;
	var plural = (entityName && pluralize(entityName)) || "{$pluralType}";
	var singular = entityName || "{$representation}";
	//
	switch (facetName) {
		case "$details":
			link.$url = "{$baseUrl}/" + plural + "('{$key}')?representation=" + singular + "." + facetName + "&role={$role}" + (params ? "&" + params : "");
			break;
		case "$lookup":
		case "$select":
		case "$query":
			link.$url = "{$baseUrl}/" + plural + "?representation=" + singular + "." + facetName + "&role={$role}" + (params ? "&" + params : "");
			break;
		case "$edit":
			link.$url = "{$baseUrl}/" + plural + "('{$key}')/$workingCopies?representation=" + singular + "." + facetName + "&role={$role}" + (params ? "&" + params : "");
			link.$method = "POST";
			break;
		case "$create":
			// $create facet is in fact an $edit facet
			link.$url = "{$baseUrl}/" + plural + "/$template/$workingCopies?representation=" + singular + ".$edit&role={$role}" + (params ? "&" + params : "");
			link.$method = "POST";
			break;
	}
	return link;
}

var _decoratePropertyProtoMap = {
	graph: function(_, $p, entity, prop) {
		$p.$url = "{$baseUrl}/{$pluralType}('{$key}')/$graphs/" + prop.name;
		$p.$linkCategories = [];
		$p.$nodeCategories = [];
		//
		var maps = prop.getGraphRelationsMaps(_);
		//
		flows.eachKey(_, maps.nodes, function(_, nodeName, node) {
			$p.$nodeCategories.push(node);
		});
		flows.eachKey(_, maps.links, function(_, linkName, link) {
			$p.$linkCategories.push(link);
		});
	},
	"tag-cloud": function(_, $p, entity, prop) {
		$p.$url = "{$baseUrl}/{$pluralType}('{$key}')/$tagClouds/" + prop.name;
		$p.$nodeCategories = [];
		// TODO
		$p.$nodeCategories.push({
			$title: "Categ test",
			$prototype: {
				$properties: {
					$value: "Test"
				}
			}
		});
	},
	filter: function(_, $p, entity, prop) {
		if (prop.$filterRepresentation && (typeof prop.$filterRepresentation !== "function")) {
			$p.$links = $p.$links || {};
			var l = $p.$links.$prototype = {
				$url: "{$baseUrl}/$prototypes('" + prop.$filterRepresentation + ".$query')",
				$isHidden: true
			};
		}
	}
};

function _copyConstraints(src, dst) {
	['$pattern', '$patternMessage', '$minLength', '$maxLength', '$minimum', '$maximum', '$maximumCanEqual', '$minimumCanEqual', //
		'$isUnique', '$isNullable', '$isMandatory', '$isDefined', //
		'$isReadOnly', '$isDisabled', '$scale', '$precision'
	].forEach(function(key) {
		if ((src[key] !== undefined) && (src[key] !== "function")) dst[key] = src[key];
	});
}

function _isEntityCapableOf(entity, capability) {
	var caps = (entity.$capabilities || "").split(",");
	return caps.indexOf(capability) >= 0;
}

function _copyIfStatic(src, dest, name) {
	if (src[name] && (typeof src[name] !== "function")) dest[name] = src[name];
}

function _normalizeCapabilities(prop, facetName, isChild) {
	var cap = (prop.$capabilities && prop.$capabilities.split(",")) || [];
	var i_add = cap.indexOf("insert");
	var i_app = cap.indexOf("append");
	var i_del = cap.indexOf("delete");
	var i_reo = cap.indexOf("reorder");
	// ad standard caps only if the class caps is not defined
	if (prop.$capabilities == null) {
		if (cap.indexOf("sort") < 0) cap.push("sort");
		if (facetName === "$edit") {
			if (prop.$isArray || prop.isPlural) {
				// only allow insert if we can reorder, it's append only otherwise
				if (i_add < 0 && (cap.indexOf("reorder") >= 0)) cap.push("insert");
				if (i_add < 0) cap.push("append");
				if (i_del < 0) cap.push("delete");
			}
			// by default no reorder
			//			if(prop.isPlural)
			//				cap.push("reorder");
		}
		if (!isChild && (cap.indexOf("filter") < 0)) cap.push("filter");
	}
	if (facetName !== "$edit") {
		if (i_add >= 0) cap.splice(cap.indexOf("insert"), 1);
		if (i_app >= 0) cap.splice(cap.indexOf("append"), 1);
		if (i_del >= 0) cap.splice(cap.indexOf("delete"), 1);
		if (i_reo >= 0) cap.splice(cap.indexOf("reorder"), 1);
	}
	//console.log("(183): "+prop.name+"."+facetName+"; array: "+(prop.$isArray || prop.isPlural)+"; result="+cap.join(","));
	return cap.join(",");
}

function _getEntityPrototype(_, model, entity, reprName, facetName, isChild, childPrefix) {
	function _fillProtoTemplates(result, e) {
		result.$url = "{$baseUrl}/{$pluralType}('{$key}')";
		result.$value = (e.$valueTemplate && (_getTranslatedString(stringRes, [e.name, "$valueTemplate"]) || e.$valueTemplate.expression)) || "{$key}";
		// $title conflicts with the property title for reference thumb.
		//			result.$title = (e.$titleTemplate && e.$titleTemplate.expression) || (e.title + " {$key}");
		result.$description = (e.$descriptionTemplate && (_getTranslatedString(stringRes, [e.name, "$descriptionTemplate"]) || e.$descriptionTemplate.expression)) || _getTranslatedString(stringRes, [e.name, "$title"]) || result.$title;
		// extract all fields in templates
		result.$key = e.$key || "{$uuid}";
		result.$properties = {};
		var allFields = {};

		function addField(elem) {
			elem = elem.substring(1, elem.length - 1);
			if (!allFields[elem] && e.$properties[elem]) allFields[elem] = e.$properties[elem];
		}
		if (e.$valueTemplate && e.$valueTemplate.matches) e.$valueTemplate.matches.forEach(addField);
		if (e.$valueTitleTemplate && e.$valueTitleTemplate.matches) e.$valueTitleTemplate.matches.forEach(addField);
		if (e.$descriptionTemplate && e.$descriptionTemplate.matches) e.$descriptionTemplate.matches.forEach(addField);
		//
		forEachKey(allFields, function(field, value) {
			result.$properties[field] = {
				$type: value.getMimeType()
			};
		});
	}

	function _fillThumb($thumb, e, rel, prefix) {
		_fillProtoTemplates($thumb, e);
		$thumb.$url += "?representation={$representation}.$thumb";
		$thumb.$prototype = "{$baseUrl}/$prototypes('{$representation}.$thumb')";
		$thumb.$representation = e.name;
		$thumb.$title = (e.$valueTitleTemplate && (_getTranslatedString(stringRes, [e.name, "$valueTitleTemplate"]) || e.$valueTitleTemplate.expression));
		if (rel.$isDisabled && (typeof rel.$isDisabled !== "function")) $thumb.$isDisabled = rel.$isDisabled;
		if (rel.$isReadOnly && (typeof rel.$isReadOnly !== "function")) $thumb.$isReadOnly = rel.$isReadOnly;
		$thumb.$links = {
			$details: _getLink("$details", null, "", rel.$isDynamicType ? null : e.name)
		};
		//
		//var lookupLinkName = ((rel && rel.isPlural && rel.relType !== "children") ? "$select" : "$lookup");
		if ((facetName === "$edit") || (queryRepr.indexOf(facetName) >= 0)) {
			var lookupLinkName = "$lookup";
			var relLookupParams = (rel.$lookup && (rel.$lookup.parameters || rel.$lookup.$parameters)) || (rel.$select && (rel.$select.parameters || rel.$select.$parameters));
			$thumb.$links[lookupLinkName] = _getLink(lookupLinkName, locale.format(module, "createTableActionTitle"), "trackingId={$trackingId}" + ((rel && rel.name) ? "&binding=" + prefix : "") + (relLookupParams ? "&" + relLookupParams : ""), e.name);
		}
	}

	function _addWordLinks(_, resource, entityName, facetName) {
		if (!adminBaseUrl) {
			var adminEP = require("syracuse-collaboration/lib/helpers").AdminHelper.getCollaborationEndpoint(_);
			adminBaseUrl = adminEP && adminEP.getBaseUrl(_);
		}

		// These parameters can be set to enforce filtering on set properties during template selection
		var templateParams = {
			"$msoRepr": "{$representation}" + "." + facetName,
			"$msoLocale": "",
			//require("streamline/lib/globals").context.locale,
			"$msoCpy": "",
			"$msoLeg": "",
			"$msoActiv": "",
			"$msoEndpoint": "" // endpoint as string formed like <application>.<contract>.<dataset> e.g. x3.erp.SUPERV
		};

		var urlParams = "";
		flows.eachKey(_, templateParams, function(_, name, value) {
			urlParams += "&" + name + "=" + value;
		});

		if (queryRepr.indexOf(facetName) >= 0) {
			resource.$links.$wordmailmerge = {
				"$title": locale.format(module, "mailMerge"),
				"$url": _getLink(facetName).$url + "&createMode={creationMode}&doc_uuid={document}",
				"$type": httpHelper.mediaTypes.word_mailmerge,
				"$confirm": locale.format(module, "installOfficeAddin"),
				"$officeAddinSetup": "/msoffice/lib/general/addIn/SyracuseOfficeAddinsSetup.EXE",
				"$parameters": {
					"$url": adminBaseUrl + "/msoMailMergeDocSels/$template/$workingCopies?representation=msoMailMergeDocSel.$edit&role={$role}" + urlParams,
					"$method": "POST",
					"$properties": {
						"dummy": { // the user will be prompted to enter user1 value
							"$title": "dummy",
							"$type": "application/x-string"
						}
					}
				}
			};
		}

		resource.$links.$wordreport = {
			"$title": locale.format(module, "wordReport"),
			"$url": _getLink(facetName).$url + "&reportMode={reportMode}&doc_uuid={document}",
			"$type": httpHelper.mediaTypes.word_report,
			"$confirm": locale.format(module, "installOfficeAddin"),
			"$officeAddinSetup": "/msoffice/lib/general/addIn/SyracuseOfficeAddinsSetup.EXE",
			"$parameters": {
				"$url": adminBaseUrl + "/msoReportModes/$template/$workingCopies?representation=msoReportMode.$edit&role={$role}" + urlParams,
				"$method": "POST",
				"$properties": {
					"dummy": {
						"$title": "dummy",
						"$type": "application/x-string"
					}
				}
			}
		};
	}

	function _addPptLinks(resource) {
		if (queryRepr.indexOf(facetName) >= 0) {
			resource.$links.$pptslide = {
				"$title": locale.format(module, "createNewSlide"),
				"$url": _getLink(facetName).$url + "&pptMode=newSlide",
				"$type": httpHelper.mediaTypes.ppt_slide,
				"$confirm": locale.format(module, "installOfficeAddin"),
				"$officeAddinSetup": "/msoffice/lib/general/addIn/SyracuseOfficeAddinsSetup.EXE"
			};
		}
	}

	function _updateChildRef(_, resource, rel, variant, facetName, isChild, childPrefix, isCollection) {
		var $item = resource.$item = _getEntityPrototype(_, model, variant.targetEntity, variant.targetEntity.name, facetName, isChild, childPrefix);
		$item.$representation = variant.targetEntity.name;
		if (facetName === "$edit") {
			if (isCollection) {
				resource.$actions = resource.$actions || {};
				if (variant.$select) {
					resource.$actions.$select = resource.$actions.$select || {
						$title: locale.format(module, "createTableActionTitle"),
						$method: "PUT"
					};
					var a = resource.$actions.$select;
					a.$parameters = a.$parameters || {};
					var selectEnt = model.getEntity(_, variant.$select.$type);
					a.$parameters.$actions = a.$parameters.$actions || {};
					var lp = variant.$select && (variant.$select.parameters || variant.$select.$parameters);
					a.$parameters.$actions.$select = {
						$title: variant.$select.$title,
						$type: "application/x-array",
						$item: _getEntityPrototype(_, model, selectEnt, selectEnt.name, "$select", true, childPrefix),
						$url: "{$baseUrl}/" + selectEnt.plural + "?representation=" + selectEnt.name + ".$select" + (lp ? "&" + lp : "") + "&trackingId={trackingId}" + (childPrefix ? "&binding=" + childPrefix : "")
					};
				} else {
					if (!rel.$capabilities || rel.$capabilities.indexOf("append") >= 0) resource.$actions.$create = resource.$actions.$create || {
						$title: locale.format(module, "createTableActionTitle"),
						$method: "PUT"
					};
				}
			} else {
				if (variant.$lookup) {
					var lookupLinkName = "$lookup";
					$item.$links = $item.$links || {};
					var lp = variant.$lookup && (variant.$lookup.parameters || variant.$lookup.$parameters);
					$item.$links[lookupLinkName] = _getLink(lookupLinkName, locale.format(module, "selectItemActionTitle"), "trackingId={$trackingId}" + ((rel && rel.name) ? "&binding=" + childPrefix : "") + (lp ? "&" + lp : ""), variant.targetEntity.name);
				}
				if ($item.$actions && $item.$actions.$delete) delete $item.$actions.$delete;
			}
		}
	}

	//
	var adminBaseUrl = null;
	var stringRes = entity.contract.resources && entity.contract.resources();
	var resource = {
		$type: "application/json"
	};
	resource.$prototype = "{$baseUrl}/$prototypes('{$representation}." + facetName + "')";
	if (!isChild) {
		resource.$url = "{$baseUrl}/{$pluralType}('{$key}')";
		resource.$value = (entity.$valueTemplate && (_getTranslatedString(stringRes, [entity.name, "$valueTemplate"]) || entity.$valueTemplate.expression)) || "{$key}";
		resource.$title = (entity.$titleTemplate && (_getTranslatedString(stringRes, [entity.name, "$titleTemplate"]) || entity.$titleTemplate.expression)) || (entity.title + " {$key}");
	}
	resource.$key = "{$uuid}";
	resource.$description = (entity.$descriptionTemplate && (_getTranslatedString(stringRes, [entity.name, "$descriptionTemplate"]) || entity.$descriptionTemplate.expression)) || resource.$title;
	resource.$pluralType = entity.plural;
	resource.$representation = reprName;
	var $ = resource.$properties = {};
	flows.eachKey(_, entity.$properties, function(_, name, prop) {
		//if (prop.type === "json") return;
		if ((prop.type === "graph") && (queryRepr.indexOf(facetName) >= 0)) return;
		if ((prop.type === "password") && (facetName !== "$edit")) return;
		// keep helpers.enableDeveloppementFeatures for compat but should deprecate it
		if (prop.$isDeveloppementFeature && !(((globals.context.config || {}).system || {}).enableDevelopmentFeatures || helpers.enableDeveloppementFeatures)) return;
		//
		//don't send default values as might create an difference between the value stored on server and showed by the client
		//		if (typeof prop.$default !== "undefined") {
		//			resource[name] = resourceHelpers.formatValue(prop, prop.$default);
		//		}
		//
		var $p = $[name] = prop.getPropertyPrototype(_, stringRes, facetName, isChild);
	});
	var $links = resource.$links = {};
	flows.eachKey(_, entity.$relations, function(_, name, rel) {
		if (rel.isPlural && (queryRepr.indexOf(facetName) >= 0)) return;
		if (rel.relType == "parent") return;
		var $r = ($[name] = {});
		$r.$title = _getTranslatedString(stringRes, [entity.name, name, "$title"], true) || rel.title;
		if (typeof rel.$description !== "function") $r.$description = _getTranslatedString(stringRes, [entity.name, name, "$description"], true) || rel.$description;
		$r.$displayLength = rel.$displayLength;

		// TODO: check the list of constraints that we copy
		//$r.$constraints = rel.$constraints;
		$r.$isUnique = rel.$isUnique;

		["$isMandatory", "$isDisabled", "$isReadOnly", "$isHidden", "$isExcluded"].forEach(function(n) {
			_copyIfStatic(rel, $r, n);
		});
		//
		$r.$capabilities = _normalizeCapabilities(rel, facetName, isChild);
		//
		// properly format binding for childrens
		var thumbRelName = rel.name;
		if (childPrefix) thumbRelName = childPrefix.replace("uuid", "parent_uuid") + "('{$uuid}')/" + thumbRelName;
		//
		if (rel.isPlural) {
			$r.$type = "application/x-array";
			var $item = $r.$item = {};
			switch (rel.relType) {
				case "association":
				case "link":
					if (rel.$variants) {
						$item.$type = "application/x-variant";
						$item.$variants = {};
						Object.keys(rel.$variants).forEach(function(vName) {
							var ent = rel.$variants[vName].targetEntity;
							var variant = rel.$variants[vName];
							var $v = $item.$variants[ent.name] = {};
							$v.$type = "application/x-reference";
							$v.$item = {};
							_fillThumb($v.$item, variant.targetEntity, rel, thumbRelName);
							if (facetName === "$edit") {
								var lp = rel.$select && (rel.$select.parameters || rel.$select.$parameters);
								($v.$links = $v.$links || {}).$select = _getLink("$select", locale.format(module, "createTableActionTitle"), "trackingId={$trackingId}" + (rel.name ? "&binding=" + thumbRelName : "") + (lp ? "&" + lp : ""), variant.targetEntity.name);
							}
						});
					} else {
						$item.$type = "application/x-reference";
						$item.$item = {};
						_fillThumb($item.$item, rel.targetEntity, rel, thumbRelName);
						if (facetName === "$edit") {
							var lp = rel.$select && (rel.$select.parameters || rel.$select.$parameters);
							($r.$links = $r.$links || {}).$select = _getLink("$select", locale.format(module, "createTableActionTitle"), "trackingId={$trackingId}" + (rel.name ? "&binding=" + thumbRelName : "") + (lp ? "&" + lp : ""), rel.targetEntity.name);
						}
					}
					break;
				case "children":
					if (rel.$variants) {
						$item.$type = "application/x-variant";
						$item.$variants = {};
						Object.keys(rel.$variants).forEach_(_, function(_, vName) {
							var ent = rel.$variants[vName].targetEntity;
							var $v = $item.$variants[ent.name] = {};
							$v.$type = "application/x-object";
							_updateChildRef(_, $v, rel, rel.$variants[vName], facetName, true, thumbRelName, true);
						});
					} else _updateChildRef(_, $r, rel, rel, facetName, true, thumbRelName, true);

					break;
				default:
					throw new Error(locale.format(module, "badRelType", rel.relType, entity.name, rel.name));
			}
		} else {
			switch (rel.relType) {
				case "child":
					$r.$type = "application/x-object";
					if (rel.$variants) {
						$r.$type = "application/x-variant";
						$r.$variants = {};
						Object.keys(rel.$variants).forEach_(_, function(_, vName) {
							var ent = rel.$variants[vName].targetEntity;
							var $v = $r.$variants[ent.name] = {};
							$v.$type = "application/x-object";
							_updateChildRef(_, $v, rel, rel.$variants[vName], facetName, true, thumbRelName);
						});
					} else _updateChildRef(_, $r, rel, rel, facetName, true, thumbRelName);
					break;
				case "reference":
					if (rel.$variants) {
						$r.$type = "application/x-variant";
						$r.$variants = {};
						Object.keys(rel.$variants).forEach(function(vName) {
							var ent = rel.$variants[vName].targetEntity;
							var variant = rel.$variants[vName];
							var $v = $r.$variants[ent.name] = {};
							$v.$type = "application/x-reference";
							$v.$item = {};
							_fillThumb($v.$item, variant.targetEntity, rel, thumbRelName);
						});
					} else {
						$r.$type = "application/x-reference";
						$r.$item = {};
						_fillThumb($r.$item, rel.targetEntity, rel, thumbRelName);
					}
					break;

				default:
					throw new Error(locale.format(module, "badRelType", rel.relType, entity.name, rel.name));
			}
		}
	});
	// some standard properties
	$["$creUser"] = {
		$title: "Created by",
		$type: "application/x-string",
		$isDisabled: true,
		$isHidden: true,
		$capabilities: "sort,filter"
	};
	$["$updUser"] = {
		$title: "Updated by",
		$type: "application/x-string",
		$isDisabled: true,
		$isHidden: true,
		$capabilities: "sort,filter"
	};
	$["$creDate"] = {
		$title: "Created on",
		$type: "application/x-datetime",
		$isDisabled: true,
		$isHidden: true,
		$capabilities: "sort,filter"
	};
	$["$updDate"] = {
		$title: "Updated on",
		$type: "application/x-datetime",
		$isDisabled: true,
		$isHidden: true,
		$capabilities: "sort,filter"
	};
	//
	if ((facetName !== "$child") && !isChild) {
		entity.fillLinksResource(facetName, resource);
		// word links is "opt-in"
		if (_isEntityCapableOf(entity, "wordReport")) _addWordLinks(_, resource, entity.name, facetName);
		// removed ppt since reporting in ppt is not supported yet
		// _addPptLinks(resource, facetName);
		//
		if (queryRepr.indexOf(facetName) >= 0) {
			var old = resource;
			resource = {
				$baseUrl: resource.$baseUrl,
				$baseType: resource.$baseType,
				$url: "{$baseUrl}/" + entity.plural,
				$type: resource.$type,
				$title: _getTranslatedString(stringRes, [entity.name, "$listTitle"]) || locale.format(module, "listOf", entity.plural),
				$properties: {
					$resources: {
						$type: "application/x-array",
						$item: resource
					}
				}
			};
			// default order
			resource.$properties.$resources.$item.$defaultOrder = entity.defaultOrder.map(function(item) {
				return item[1] ? item[0] : item[0] + " desc";
			}).join(",");
			//
			if (facetName !== "$search") {
				resource.$pluralType = entity.plural;
				resource.$representation = reprName;
			}
			resource.$links = resource.$links || {};
			if (entity.$canCreate !== false) {
				resource.$links.$create = _getLink("$create", _getTranslatedString(stringRes, [entity.name, "$createActionTitle"]) || locale.format(module, "newLinkTitle", entity.name));
			}
			// print is opt-out: not for 7.0
			// if (_isEntityCapableOf(entity, "pdfReport")) {
			// 	resource.$links.$print = _getLink(facetName, locale.format(module, "print"));
			// 	resource.$links.$print.$type = httpHelper.mediaTypes.pdf;
			// }
			// excel is opt-out
			if (_isEntityCapableOf(entity, "excelReport")) {
				resource.$links.$excel = _getLink(facetName, locale.format(module, "excel"));
				resource.$links.$excel.$type = httpHelper.mediaTypes.excel_worksheet;
			}
			// word links is "opt-in"
			if (_isEntityCapableOf(entity, "mailMerge")) _addWordLinks(_, resource, entity.name, facetName);
			// removed ppt since reporting in ppt is not supported yet
			// _addPptLinks(resource, facetName);
			if (entity.$helpPage) {
				resource.$links.$help = {
					$url: "{$baseHelpUrl}/" + entity.$helpPage + '.html',
					$title: locale.format(module, "helpTitle"),
					$type: "text/html",
					$target: "help",
				};
			}

			delete old.$baseType;
			delete old.$baseUrl;
			//old.$type = result.$baseType + "." + entity.name + ":$queryItem";
			old.$type = "application/json";
		}
	} else if (isChild) {
		if (facetName === "$edit") {
			resource.$actions = resource.$actions || {};
			resource.$actions.$delete = resource.$actions.$delete || {
				$title: locale.format(module, "deleteActionTitle"),
				$method: "PUT"
			};
		}
	}
	//
	return resource;
}

function _initProperty(entity, prop) {
	prop.type = prop.type || prop.$type || "string";
	prop.title = prop.title || prop.$title || prop.name;
	prop.$title = prop.$title || prop.title;
	if (prop.$enumCaptions) throw new Error(locale.format(module, "enumFormatDeprecated", entity.name, prop.name));
	//		prop.$enumValues = prop.$enum;
	//	delete prop.$enum;
	// dont create the property if there isn't any default value, as null property means null default value
	if (prop.hasOwnProperty("defaultValue")) prop.defaultValue = prop.defaultValue;
	else if (prop.hasOwnProperty("$default")) prop.defaultValue = prop.$default;
	prop.minLength = prop.$minLength;
	prop.maxLength = prop.$maxLength;
	prop.mandatory = prop.$isMandatory;
	prop.nullable = prop.$isNullable;

	prop.getAllConstraints = (function() {
		var c = {};
		_copyConstraints(this, c);
		if (this.$isMandatory) c.$isMandatory = this.$isMandatory;
		if (this.$isDefined) c.$isDefined = this.$isDefined;
		return c;
	}).bind(prop);
	//
	prop.isExternalStorage = (function() {
		//		return (!(this.$storage === "inline") && (["image", "binary"].indexOf(this.type) >= 0));
		return (this.hasOwnProperty("$storage"));
	}).bind(prop);
	//
	prop.getMimeType = (function() {
		switch (this.type) {
			case "image":
			case "text/html":
			case "text/rtf":
			case "text/plain":
				return this.type;
			default:
				return ("application/x-" + this.type);
		}
	}).bind(prop);
	// add type specific operations
	prop.getTitle = (function() {
		var stringRes = entity.contract.resources && entity.contract.resources();
		return _getTranslatedString(stringRes, [entity.name, prop.name, "$title"], true) || prop.$title;
	}).bind(prop);
	prop.getPropertyPrototype = (function(_, stringRes, facetName, isChild) {
		var name = this.name;
		var res = {};
		res.$title = _getTranslatedString(stringRes, [entity.name, name, "$title"], true) || prop.$title;
		if (typeof prop.$description !== "function") res.$description = _getTranslatedString(stringRes, [entity.name, name, "$description"], true) || prop.$description;
		["$isHidden", "$isExcluded"].forEach(function(n) {
			_copyIfStatic(prop, res, n);
		});
		res.$displayLength = prop.$displayLength;
		res.$links = prop.$links;
		var $p;
		if (this.$isArray) {
			res.$type = "application/x-array";
			$p = res.$item = {};
		} else $p = res;
		if (prop["$enum"]) {
			$p.$type = "application/x-choice";
			var $value = $p.$value = {
				$type: prop.getMimeType(),
			};
			var protoEnum = $value.$enum = [];
			Array.isArray(prop["$enum"]) && prop["$enum"].forEach(function(e, idx) {
				protoEnum.push({
					$value: e.$value,
					$title: _getTranslatedString(stringRes, [entity.name, name, e.$value], true) || e.$title || e.$value
				});
			});
		} else {
			$p.$type = prop.getMimeType();
			if (prop.isExternalStorage())
				if (facetName === "$edit") $p.$url = "{$baseUrl}/$workingCopies('{$trackingId}')/" + name;
				else $p.$url = "{$baseUrl}/{$pluralType}('{$key}')/" + name;
		}
		$p.$format = prop.$format;
		_copyConstraints(prop, $p);
		//
		if (prop.$type === "password" && prop.$salt) {
			var c = ((require("syracuse-main/lib/nodeconfig").config || {}).session || {});
			$p.$salt = prop.$salt.replace("{$realm}", c.realm || "Syracuse");
		}
		//
		if (prop.isComputed || prop.$compute) $p.$isDisabled = true;
		// capabilities: use "res" variable for $capabilities as for the arrays we must be on prop level not on $item (as is $p)
		res.$capabilities = _normalizeCapabilities(prop, facetName, isChild);
		if ((prop.type === "string") && (res.$capabilities.indexOf("alphaTab") < 0)) res.$capabilities = res.$capabilities + ",alphaTab";
		//
		// for now, move il later in dataModel.js ?
		if (prop.$linksToDetails && (facetName !== "$lookup" && facetName !== "$select")) {
			$p.$links = $p.$links || {};
			$p.$links.$details = _getLink("$details");
		}
		if (prop.$lookup) {
			$p.$links = $p.$links || {};
			if (typeof prop.$lookup !== 'function') {
				var lp = prop.$lookup && (prop.$lookup.parameters || prop.$lookup.$parameters);
				$p.$links.$lookup = _getLink("$lookup", null, "trackingId={$trackingId}&binding=" + prop.name + (lp ? "&" + lp : ""), prop.$lookup.entity);
				$p.$links.$lookup.$result = prop.$lookup.field;
			} else $p.$links.$lookup = {
				$isDisabled: true
			};
		}
		//
		_decoratePropertyProtoMap[prop.$type] && _decoratePropertyProtoMap[prop.$type](_, $p, entity, prop);
		//
		return res;
	}).bind(prop);
	//
	prop.getDefaultValue = (function(_, instance) {
		var property = this;
		if (property.hasOwnProperty("defaultValue")) {
			if (typeof property.defaultValue === "function") return property.defaultValue(_, instance);
			else return property.defaultValue;
		} else return (types[(property.$type || "string")] || {}).defaultValue;
	}).bind(prop);
	//
	prop.hasDefaultValue = (function() {
		return this.hasOwnProperty("defaultValue");
	}).bind(prop);
	//
	if (prop.$type === "graph") prop.getGraphRelationsMaps = (function(_) {
		var stringRes = entity.contract.resources && entity.contract.resources();

		function _addNodes(_, rel, relMap, walked) {
			var ent = rel.targetEntity;
			if (!nodesMap[ent.name]) nodesMap[ent.name] = {
				$name: ent.name,
				$title: _getTranslatedString(stringRes, [ent.name, "$pluralTitle"]) || ent.$pluralTitle,
				$selected: (relMap.$selected !== false),
				$prototype: {
					$properties: {
						$value: ent.$valueTemplate && ent.$valueTemplate.expression
					},
					$links: {
						$default: {
							$url: "{$baseUrl}/" + ent.plural + "('{$uuid}')?representation=" + ent.name + ".$details",
							$type: "json",
							//$target: "blank"
						}
					}
				}
			};
			if (!linksMap[walked]) linksMap[walked] = {
				$name: walked,
				$title: rel.$title
			};
		}

		function _walkRelation(_, ent, relName, relMap, walked) {
			if (relName[0] === "$") return;
			//
			var targetEntity = ent.$relations && ent.$relations[relName] && ent.$relations[relName].targetEntity;
			if (!targetEntity) throw new Error(locale.format(module, "relationEntityNotFound", relName));
			//
			_addNodes(_, ent.$relations[relName], relMap, walked);
			// continue recursion
			flows.eachKey(_, relMap, function(_, locRelName, locRelMap) {
				_walkRelation(_, targetEntity, locRelName, locRelMap, walked + "." + locRelName);
			});
		}
		var nodesMap = {};
		var linksMap = {};
		// add starting point
		nodesMap[entity.name] = {
			$name: entity.name,
			$title: _getTranslatedString(stringRes, [entity.name, "$pluralTitle"]) || entity.$pluralTitle,
			$selected: true,
			$prototype: {
				$properties: {
					$value: entity.$valueTemplate && entity.$valueTemplate.expression
				}
			}
		};
		//
		flows.eachKey(_, this.$relations, function(_, relName, relation) {
			_walkRelation(_, entity, relName, relation, relName);
		});
		//
		return {
			nodes: nodesMap,
			links: linksMap
		};
	}).bind(prop);
}

var _allEvents = ["$beforeSave", "$canSave", "$afterSave"];

function _getMeta(entity, metaName, parameters, selected, needsThumb, forceChildren, depth) {
	return {
		entity: entity,
		name: metaName,
		$properties: entity.$properties,
		$relations: entity.$relations,
		isSelected: selected,
		needsThumb: needsThumb,
		defaultOrder: entity.defaultOrder
	};
}

function _checkDefaultOrder(entity, orders) {
	orders.forEach(function(order) {
		if (!(order instanceof Array)) throw new Error(entity.name + ": default order element is not an array");
		if (!entity.$properties[order[0]]) throw new Error(entity.name + ": invalid order property: " + order[0]);
		if (order[1] === undefined) order[1] = true;
	});
}

function DataModel(contract) {
	var datasetOperations = {};
	var mapper = null;

	var pluralMap = {};
	var classMap = {}; // entities (not factories) by class name
	var self = this;

	var entities = contract.entities || {};
	var rules = contract.$rules || {};
	var _tags = [];
	//
	this.dbMeta = contract.dbMeta || {};
	this.name = contract.name;
	this.contract = contract;

	contract.localizedString = (function(entityName, propName) {
		var stringRes = contract.resources && contract.resources();
		return _getTranslatedString(stringRes, [entityName, propName]);
	}).bind(contract);

	function _tagsMask(tags) {
		if (!tags) return 0;
		var mask = 0;
		tags.split(",").forEach(function(tag) {
			var i = _tags.indexOf(tag);
			if (i < 0) {
				i = _tags.length;
				_tags.push(tag);
			}
			mask |= 1 << i;
		});
		return mask;
	}

	forEachKey(entities, function(name, entity) {
		entity.name = name;
		entity.className = entity.className || capitalize(name);
		entity.plural = entity.plural || pluralize(name);
		entity.$pluralTitle = entity.$pluralTitle || capitalize(entity.plural);
		entity.contract = contract;
		entity.title = entity.title || entity.$title || entity.name;
		// default $isPersistent is true
		if (!entity.hasOwnProperty("$isPersistent")) entity.$isPersistent = true;
		if (pluralMap[entity.plural]) throw new Error(entity.name + ": duplicate plural: " + entity.plural);
		if (entities[entity.plural]) throw new Error(entity.name + ": plural is identical to singular: " + entity.plural);
		if (!entity.hasOwnProperty("$capabilities")) entity.$capabilities = "excelReport,pdfReport"; // wordReport and mailMerge are opt-in
		entity.$properties = entity.$properties || {};
		var fields = {};
		helpers.object.forEachKey(entity.$properties, function(propName, prop) {
			prop.name = propName;
			prop.tagsMask = _tagsMask(prop.tags);
			_initProperty(entity, prop);
			if (!prop.isComputed) fields[propName] = prop;
		});

		classMap[entity.className] = entity;
		pluralMap[entity.plural] = name;

		entity.defaultOrder = entity.defaultOrder || entity.$defaultOrder;
		if (!entity.defaultOrder && entity.$properties["description"]) entity.defaultOrder = [
			["description", true]
		];
		if (!entity.defaultOrder) entity.defaultOrder = [];
		_checkDefaultOrder(entity, entity.defaultOrder);

		if (entity.descriptor) {
			if (typeof entity.descriptor != "function" && !entity.$properties[entity.descriptor]) throw new Error(entity.name + ": invalid descriptor property: " + entity.descriptor);
		}

		entity.$services = entity.$services || {};
		entity.$events = entity.$events || {};
		_allEvents.forEach(function(name) {
			entity.$events[name] = entity.$events[name] || [];
		});
		entity.$methods = entity.$methods || {};
		entity.$functions = entity.$functions || {};
		entity.$rules = entity.$rules || {};
		entity.$links = entity.$links || {};
		entity.$actions = entity.$actions || {};
		// allProperties =  properties + relations
		var allProps = Object.keys(entity.$properties);
		entity.$relations = entity.$relations || {};
		forEachKey(entity.$relations, function(relName, rel) {
			rel.name = relName;
			rel.title = rel.title || rel.$title || rel.name;
			rel.isComputed = rel.isComputed || rel.$isComputed;
			rel.isChild = rel.$isChild = rel.isChild || rel.$isChild;
			rel.$canReorder = rel.$canReorder || (rel.$capabilities && (rel.$capabilities.indexOf("reorder") >= 0));
			rel.tagsMask = _tagsMask(rel.tags);
			if (typeof rel.optional == "undefined") rel.optional = false;
			if (rel.isChild) rel.owned = true;
			if (rel.before) {
				var i = allProps.indexOf(rel.before);
				if (i < 0) allProps.push(relName);
				else allProps.splice(i, 0, relName);
			} else allProps.push(relName);
			rel.getTitle = (function() {
				var stringRes = entity.contract.resources && entity.contract.resources();
				return _getTranslatedString(stringRes, [entity.name, rel.name, "$title"], true) || rel.$title;
			}).bind(rel);
		});
		entity.allProperties = {};
		allProps.forEach(function(propertyName) {
			if (entity.$properties[propertyName]) entity.allProperties[propertyName] = entity.$properties[propertyName];
			else entity.allProperties[propertyName] = entity.$relations[propertyName];

		});
		forEachKey(entity.$links, function(name, link) {
			link.name = name;
			link.tagsMask = _tagsMask(link.tags);
		});
		forEachKey(entity.$actions, function(name, action) {
			action.name = name;
			action.tagsMask = _tagsMask(action.tags);
		});

		function _makeTemplate(str) {
			var template = new resourceProxy.Template(str);
			(template.matches || []).forEach(function(match) {
				match = match.substring(1, match.length - 2).trim();
				if (entity.$properties[match]) entity.$properties[match].usedByTemplate = true;
			});
			return template;
		}
		if (entity.$valueTemplate && (typeof entity.$valueTemplate === "string")) entity.$valueTemplate = _makeTemplate(entity.$valueTemplate);
		if (entity.$valueTitleTemplate && (typeof entity.$valueTitleTemplate === "string")) entity.$valueTitleTemplate = _makeTemplate(entity.$valueTitleTemplate);
		if (entity.$summaryTemplate && (typeof entity.$summaryTemplate === "string")) entity.$summaryTemplate = _makeTemplate(entity.$summaryTemplate);
		if (entity.$titleTemplate && (typeof entity.$titleTemplate === "string")) entity.$titleTemplate = _makeTemplate(entity.$titleTemplate);
		if (entity.$descriptionTemplate && (typeof entity.$descriptionTemplate === "string")) entity.$descriptionTemplate = _makeTemplate(entity.$descriptionTemplate);
		if (entity.$iconTemplate && (typeof entity.$iconTemplate === "string")) entity.$iconTemplate = _makeTemplate(entity.$iconTemplate);
		entity.$urlTemplate = _makeTemplate("{$baseUrl}/" + entity.plural + "('{$key}')?representation=" + entity.name + ".$details");

		// usefull functions
		entity.createInstance = (function(_, db, initial) {
			return this.factory.createInstance(_, initial, db);
		}).bind(entity);
		entity.fetchInstance = (function(_, db, options) {
			return db.fetchInstance(_, this, options);
		}).bind(entity);
		entity.fetchInstances = (function(_, db, options) {
			return db.fetchInstances(_, this, options);
		}).bind(entity);
		entity.count = (function(_, db, options) {
			return db.count(_, this, options);
		}).bind(entity);
		// add standard links resources for the entity
		entity.fillLinksResource = (function(reprType, resource) {
			var stringRes = contract.resources && contract.resources();
			var self = this;
			var $links = (resource.$links = (resource.$links || {}));
			if (reprType !== "$details") {
				if (self.$isPersistent !== false) $links.$details = _getLink("$details", locale.format(module, "detailsLinkTitle"));
			}
			if (reprType !== "$edit") {
				if (self.$canEdit !== false) $links.$edit = _getLink("$edit", locale.format(module, "editLinkTitle"));
				if (self.$canDelete !== false) $links.$delete = {
					$title: locale.format(module, "deleteActionTitle"),
					$confirm: locale.format(module, "deleteConfirmMessage", self.$valueTemplate && self.$valueTemplate.expression),
					// send to query representation
					$url: "{$baseUrl}/{$pluralType}('{$key}')?representation={$representation}." + reprType + "&role={$role}",
					$type: "application/json;vnd.sage=syracuse",
					$method: "DELETE"
				};
			}
			if (reprType !== "$query") {
				if (self.$isPersistent !== false) $links.$query = _getLink("$query", _getTranslatedString(stringRes, [self.name, "$listTitle"]) || locale.format(module, "listOf", self.plural));
			}
			if (reprType === "$edit") {
				resource.$actions = resource.$actions || {};
				if (self.$canSave !== false) {
					resource.$actions.$save = resource.$actions.$save || {
						$title: locale.format(module, "saveActionTitle"),
						$isDisabled: true,
						$links: {
							$details: _getLink("$details", locale.format(module, "ok"), "", self.name),
							$query: _getLink("$query", locale.format(module, "backToList"), "", self.name),
						}
					};
					if (self.$canCreate !== false) {
						resource.$actions.$save.$links.$create = _getLink("$create", _getTranslatedString(stringRes, [self.name, "$createActionTitle"]) || locale.format(module, "newLinkTitle", self.name), "", self.name);
						resource.$actions.$save.$links.$create.$isHidden = (self.$isPersistent === false);
					}
					resource.$actions.$save.$links.$details.$isHidden = (self.$isPersistent === false);
					resource.$actions.$save.$links.$query.$isHidden = (self.$isPersistent === false);
				}
			}
			if (entity.$helpPage) {
				$links.$help = {
					$url: "{$baseHelpUrl}/" + entity.$helpPage + '.html',
					$title: locale.format(module, "helpTitle"),
					$type: "text/html",
					$target: "help",
				};
			}
			if (self.$actions) {
				resource.$actions = resource.$actions || {};
				Object.keys(self.$actions).forEach(function(lName) {
					var a = self.$actions[lName];
					if (typeof a === "function") return;
					if (!a.$facets || (a.$facets && a.$facets.indexOf(reprType) >= 0)) var p = resource.$actions[lName] = resource.$actions[lName] || {};
					helpers.object.extend(p, a, true, true);
				});
			}
			// services
			forEachKey(self.$services, function(key, service) {
				var s = null;
				if (service.$method && (service.$method !== "GET") && (reprType === "$edit")) {
					resource.$actions = resource.$actions || {};
					s = resource.$actions[key] = {};
				} else {
					// make service links
					resource.$links = resource.$links || {};
					s = resource.$links[key] = {
						$type: service.$type || "application/json;vnd.sage=syracuse",
						$url: "{$baseUrl}/" + (reprType === "$edit" ? "$workingCopies('{$trackingId}')" : "{$pluralType}('{$uuid}')") + "/$service/" + key + "?representation={$representation}." + reprType
					};
					if (service.$parameters && service.$parameters.$properties) {
						var props = service.$parameters.$properties;
						var par = Object.keys(props).map(function(p) {
							return p + "=" + "{" + p + "}";
						}).join("&");
						if (par) s.$url += "&" + par;
					}
				}
				s.$title = service.$title || key;
				s.$method = service.$method || "GET";
				s.$confirm = service.$confirm;
				if (service.$isHidden && (typeof s.$isHidden != "function")) s.$isHidden = service.$isHidden;
				if (service.$parameters) s.$parameters = service.$parameters;
				if (service.$invocationMode) {
					s.$invocationMode = service.$invocationMode;
					s.$url = s.$url + "&trackngId={$trackngId}";
				}
				if (service.$urlParameters) s.$url += "&" + service.$urlParameters;
			});
			resource.$links = resource.$links || {};
			forEachKey(self.$links, function(key, link) {
				if (typeof link !== "function") resource.$links[key] = link;
			});
			// PDFHACK: not for 7.0
			// if (_isEntityCapableOf(entity, "pdfReport")) {
			// 	$links.$print = _getLink(reprType, locale.format(module, "print"));
			// 	$links.$print.$type = "application/pdf";
			// }
			// $lookup and $select items should only have $details link
			if (["$lookup", "$select"].indexOf(reprType) >= 0) {
				resource.$links = {
					$details: _getLink("$details", locale.format(module, "detailsLinkTitle"))
				};
			}
		}).bind(entity);
		entity.getPrototype = (function(_, reprName, facetName) {
			return (this.$getPrototype && this.$getPrototype(_, reprName, facetName)) || _getEntityPrototype(_, self, entity, reprName, facetName);
		}).bind(entity);
		entity.getModel = (function() {
			return self;
		}).bind(entity);
		// search facets
		if (contract.searchFacets) forEachKey(contract.searchFacets, function(key, facet) {
			if (facet.$fields && facet.$fields[entity.name]) {
				var f = entity.$facets = (entity.$facets || {});
				var ff = f[facet.$fields[entity.name]] = (f[facet.$fields[entity.name]] || []);
				ff.push(key);
			}
		});
		entity.getSearchFacets = (function(_) {
			return entity.$facets;
		}).bind(entity);
		entity.getSearchFields = function(_) {
			return entity.$searchIndex && entity.$searchIndex.$fields;
		};
		entity.isCapableOf = function(cap) {
			return _isEntityCapableOf(entity, cap);
		};
	});
	forEachKey(entities, function(name, entity) {
		forEachKey(entity.$relations, function(relName, rel) {
			rel.name = relName;
			//			rel.type = rel.type || rel.$type || relName;
			rel.type = rel.type || rel.$type;
			rel.title = rel.title || rel.$title || rel.name;
			rel.mandatory = rel.$isMandatory;
			rel.inv = rel.inv || rel.$inv;
			var singular = rel.type && pluralMap[rel.type];
			rel.isPlural = rel.$isPlural = (rel.hasOwnProperty("$isPlural") || rel.hasOwnProperty("isPlural")) ? (rel.isPlural || rel.$isPlural) : (singular != null);
			rel.isComputed = rel.isComputed || rel.$isComputed;
			if (rel.isPlural) {
				if (singular) {
					rel.targetEntity = find(entities, singular);
				} else if (rel.$variants) {
					Object.keys(rel.$variants).forEach(function(vName) {
						var v = rel.$variants[vName];
						v.type = v.type || v.$type;
						v.targetEntity = find(entities, v.type);
					});
				}
				if (!rel.defaultOrder) {
					if (rel.$capabilities && (rel.$capabilities.split(",").indexOf("reorder") >= 0)) rel.defaultOrder = "$index";
					else rel.defaultOrder = rel.targetEntity && rel.targetEntity.defaultOrder;
				}
			} else {
				if (rel.type) {
					if (!entities[rel.type]) throw new Error(entity.name + ": relation '" + relName + "' targets unknown type: " + rel.type);
					rel.targetEntity = find(entities, rel.type);
				} else if (rel.$variants) {
					Object.keys(rel.$variants).forEach(function(vName) {
						var v = rel.$variants[vName];
						v.type = v.type || v.$type;
						v.targetEntity = find(entities, v.type);
					});
				}
			}
			//
			if (rel.targetEntity && !rel.isComputed) {
				rel.targetEntity.referingEntities = rel.targetEntity.referingEntities || {};
				rel.targetEntity.referingEntities[name] = rel.targetEntity.referingEntities[name] || [];
				rel.targetEntity.referingEntities[name].push(relName);
			}
		});
		// standard services
		if ((entity.$lockType === "pessimist") && !entity.$services.forceLockInstance) {
			// force locking of an instance allready locked by another user
			entity.$services.forceLockInstance = {
				$method: "POST",
				$isMethod: true,
				$title: "Force lock",
				$isHidden: true,
				$execute: function(_, context, instance) {
					// delete locks for instance (other session?)
					instance.unlockInstance(_);
					// lock for this session
					instance.lockInstance(_);
					//
					context.reply(_, 200);
				}
			};
		}
		//
		forEachKey(entity.$staticFunctions, function(name, fn) {
			if (typeof fn != "function") throw new Error(entity.name + ": " + name + " is not a function");
			//
			entity[name] = fn.bind(entity);
		});
		forEachKey(entity.$services, function(name, operation) {
			operation.name = name;
			operation.tagsMask = _tagsMask(operation.tags);
			operation.method = operation.method || operation.$method;
			operation.isMethod = operation.isMethod || operation.$isMethod || false;
			operation.execute = operation.execute || operation.$execute;
			if (typeof operation.execute != "function") throw new Error(entity.name + "operation '" + name + "' does not have execute method");
		});
		//
		forEachKey(entity.$events, function(name, event) {
			if (_allEvents.indexOf(name) < 0) throw new Error(entity.name + ": invalid event name: " + name);

		});
		// set default meta
		entity.getMeta = function(parameters, forceChildren) {
			return _getMeta(entity, entity.plural, parameters || {}, true, false, forceChildren, 0);
		};
	});
	// another pass to verify reverse relationships
	forEachKey(entities, function(name, entity) {
		forEachKey(entity.$relations, function(relName, rel) {
			if (!rel.targetEntity && !rel.$variants && !rel.$isDynamicType) throw new Error(entity.name + "." + relName + ": target entity undefined");
			// TODO: check inv for dynamicType case
			if (!rel.targetEntity) return;
			var inv = rel.targetEntity.$relations[rel.inv];
			if (inv) {
				if (!inv.targetEntity) throw new Error(rel.targetEntity.name + "." + inv.name + ": target entity undefined");
				if (inv.targetEntity != entity) throw new Error(rel.targetEntity.name + "." + inv.name + ": expected type=" + entity.name + ", got type=" + inv.targetEntity.name);
				if (!inv.inv) inv.inv = rel.name;
				if (inv.inv != rel.name) throw new Error(rel.targetEntity.name + "." + inv.name + ": expected inv=" + rel.name + ", got inv=" + inv.inv);
			}
		});
		forEachKey(entity.$relations, function(relName, rel) {
			var inv = rel.targetEntity && rel.targetEntity.$relations[rel.inv];
			if (!inv && rel.$variants) {
				// all relations in variants should be homogenous, so just pick the first
				var firstName = Object.keys(rel.$variants)[0];
				var firstVar = firstName && rel.$variants[firstName];
				if (firstVar && firstVar.inv) inv = firstVar.targetEntity.$relations[firstVar.inv];
			}
			// classify with relType
			if (rel.isPlural) {
				if (rel.isChild) rel.relType = "children";
				else if (inv && inv.isPlural) rel.relType = "association";
				else rel.relType = "link";
			} else {
				if (rel.isChild) rel.relType = "child";
				else if (inv && inv.isChild) rel.relType = "parent";
				else rel.relType = "reference";
			}
		});
		// RECURSION !!!!!
		//		entity.shallowMeta = entity.getMeta(null, false);
		//		entity.deepMeta = entity.getMeta(null, true);
		//
		forEachKey(entity.$staticFunctions, function(name, fn) {
			if (typeof fn != "function") throw new Error(entity.name + ": " + name + " is not a function");
		});
		forEachKey(entity.$functions, function(name, fn) {
			if (typeof fn != "function") throw new Error(entity.name + ": " + name + " is not a function");
		});
		forEachKey(entity.$methods, function(name, fn) {
			if (typeof fn != "function") throw new Error(entity.name + ": " + name + " is not a function");
		});
	});
	forEachKey(contract.service || {}, function(name, operation) {
		if (typeof operation.execute != "function") throw new Error(entity.name + "operation '" + name + "' does not have execute method");
		datasetOperations[name] = operation;
	});
	self.datasetOperations = function() {
		return helpers.object.clone(datasetOperations, false);
	};
	self.getEntities = function() {
		return helpers.object.clone(contract.entities, false);
	};
	self.getRules = function() {
		return helpers.object.clone(rules, false);
	};
	self.singularize = function(name) {
		return pluralMap[name];
	};
	self.getRepresentation = function(_, name, facet) {
		// TODO: return the representation as the associated entity with filtered properties
		return contract.entities[name];
	};
	self.getEntity = function(_, name) {
		return contract.entities[name];
	};
	self.entityByClassName = function(name) {
		return classMap[name];
	};
	self.getIndexedEntities = function(_) {
		return Object.keys(entities).filter(function(eName) {
			return entities[eName].$searchIndex && entities[eName].$searchIndex.$fields;
		}).map(function(eName) {
			return entities[eName];
		});
	};
	self.getSearchFacets = function(_) {
		return Object.keys(contract.searchFacets || {}).map(function(fCode) {
			return {
				code: fCode,
				description: contract.searchFacets[fCode].$title
			};
		});
	};

	self.baseType = "application/json;vnd.sage=syracuse";

	forEachKey(entities, function(name, entity) {
		entity.factory = new factory.Factory(entity);
		// make $properties and $relations read only
		entity._$properties = entity.$properties;
		delete entity.$properties;
		Object.defineProperty(entity, "$properties", {
			get: function() {
				var p = {};
				Object.keys(entity._$properties).forEach(function(pk) {
					p[pk] = entity._$properties[pk];
				});
				return p;
			},
			set: function(val) {
				throw new Error(locale.format(module, "attemptToWrite", "$properties"));
			}
		});
		//
		/*		entity._$relations = Object.keys(entity.$relations).reduce(function(prev, relName) {
			var rel = prev._metas[relName] = new entityClasses.Relation(entity.$relations[relName]);
			Object.defineProperty(prev, relName, {
				enumerable: true,
				get: function() {
					return this._metas[relName];
				}
			});
			return prev;
		}, { _metas: {}});
		delete entity.$relations;
		Object.defineProperty(entity, "$relations", {
			get: function() {
				return entity._$relations;
			},
			set: function(val) {
				throw new Error(locale.format(module, "attemptToWrite", "$relations"));
			}
		});*/
		entity._$relations = entity.$relations;
		delete entity.$relations;
		Object.defineProperty(entity, "$relations", {
			get: function() {
				var p = {};
				Object.keys(entity._$relations).forEach(function(pk) {
					p[pk] = entity._$relations[pk];
				});
				return p;
			},
			set: function(val) {
				throw new Error(locale.format(module, "attemptToWrite", "$relations"));
			}
		});
	});
	// global events
	self.$events = {};
	_allEvents.forEach(function(name) {
		self.$events[name] = self.$events[name] || [];
	});
	self.registerEvent = (function(_, eventName, eventId, handler, entityName) {
		var target = entityName ? self.getEntity(_, entityName) : self;
		if (!target && target.$events && target.$events[eventName]) return;
		if (eventId) {
			var ev;
			target.$events[eventName].some(function(e) {
				if (e.id === eventId) {
					ev = e;
					return true;
				}
				return false;
			});
			if (ev) {
				ev.handler = handler;
				return;
			}
		}
		target.$events[eventName].push(eventId ? {
			id: eventId,
			handler: handler
		} : handler);
	}).bind(self);
}

helpers.defineClass(DataModel);

exports.getDefaultRepresentation = function(entity, facetName) {
	//var queryRepr = ["$query", "$lookup", "$search", "$select"]; // query like facets
	//
	//	var repr = [{$name:"general", $title: "General"}];
	//	var section = repr[0];
	//	section.$blocks = [{$name:"general", $contains: []}];
	var repr = {
		$items: [{}]
	};
	//
	if (facetName !== "$thumbnail") {
		//		section.$blocks[0].$contains = Object.keys(entity.$properties).slice(0);
		repr.$items[0].$contains = Object.keys(entity.$properties).slice(0);
		//
		var contains = repr.$items[0].$contains;
		forEachKey(entity.$relations, function(name, rel) {
			if (rel.isPlural) {
				if (queryRepr.indexOf(facetName) < 0) contains.push(name);
			} else contains.push(name);
		});
		//
		if (queryRepr.indexOf(facetName) >= 0) {
			repr.$items[0].$bind = "$resources";
			//			section.$blocks[0].$items = [{$name: "$resources", $contains: contains}];
			//			delete section.$blocks[0].$contains;
		}
	} else repr.$items[0].$contains = (new Array(entity.$valueTemplate && entity.$valueTemplate.expression.substring(1, entity.$valueTemplate.expression.length - 1) || "$key", entity.$titleTemplate && entity.$titleTemplate.expression.substring(1, entity.$titleTemplate.expression.length - 1) || "$key"));
	//
	return repr;
};

exports.make = function(contract, dataset) {
	// TODO : if the same model should be used for several datasets, first load modifies contract entities
	// so second load fails. Should detect the case or clone theese entities
	//	dataset = dataset || "all";
	// for now, same model for all dataset of the same contract
	dataset = "all";
	contract.models = contract.models || {};
	var model = contract.models[dataset];
	return model ? model : (contract.models[dataset] = new DataModel(contract));
};

exports.getOrm = function(_, model, dataset) {
	//	console.log("dataset "+dataset.driver);
	if (dataset.driver && (dataset.driver === "mongodb")) return require("syracuse-orm/lib/dbHandles/mongoDbHandle").create(_, model, dataset);
	else return require("syracuse-orm/lib/mysqlDbHandle").create(_, model, dataset);
};