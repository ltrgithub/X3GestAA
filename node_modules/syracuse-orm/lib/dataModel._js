"use strict";

var helpers = require('syracuse-core/lib/helpers');
var httpHelper = require("syracuse-sdata/lib/httpHelper");
var find = helpers.object.find;
var forEachKey = helpers.object.forEachKey;
var pluralize = helpers.string.pluralize;
var capitalize = helpers.string.capitalize;
var resourceProxy = require("syracuse-core/lib/resource/resourceProxy");
var resourceHelpers = require("syracuse-core/lib/resource/util");
var globals = require('streamline/lib/globals');
// do not directly "require" the class as initialization sequence might lead to "undefined" (because of early require in factory.js
// of a module requiring "dataModel.js"
//var Factory = require("./factory").Factory;
var factory = require("./factory");
var locale = require("syracuse-core/lib/locale");
var flows = require('streamline/lib/util/flows');
var entityClasses = require("./entities");
var sys = require("util");
var types = require("syracuse-core/lib/types/allTypes");
var queryRepr = ["$query", "$lookup", "$search", "$select", "$bulk"]; // query like facets

// localization notes:
// 		localization applies to text, image, sound and video.
//		if property is marked as localized, mapper creates a one to many relationship transparently
//
//		string resources (identified by module name + resource name) are handled
//		explicitly via a StringResource entity because needs input from user
//
//		string is *not* localizable, use text type instead.

function _getTranslatedString(stringResources, parts, combineParts) {
	if (!stringResources || !parts || !parts.length) return "";
	for (var i = 0; i < (combineParts ? parts.length : 1); i++) {
		var str = stringResources[parts.slice(i).join(".")];
		//console.log("resource for : "+parts.slice(i).join(".")+"="+str);
		if (str) return str;
	}
}

function _copyIfStatic(src, dest, name) {
	if (src[name] && (typeof src[name] !== "function")) dest[name] = src[name];
}

var _allEvents = ["$beforeSave", "$canSave", "$afterSave"];

function _makeSelect(select, src) {
	if (Array.isArray(src)) {
		src.forEach(function(item) {
			_makeSelect(select, item);
		});
	} else forEachKey(src || {}, function(pName, prop) {
		if (pName === "$bind") {
			select[pName] = {};
			if (src.$items) _makeSelect(select[pName], src.$items);
			if (src.$layout) _makeSelect(select[pName], src.$layout);
		} else if (typeof prop === "object") {
			if (pName === "$items" || pName === "$layout" && !src.$bind) _makeSelect(select, prop);
		}
	});
}

function DataModel(contract) {
	var datasetOperations = {};
	var mapper = null;

	var pluralMap = {};
	var classMap = {}; // entities (not factories) by class name
	var self = this;

	var entities = contract.entities || {};
	var repr = contract.representations || {};
	var rules = contract.$rules || {};
	//
	this.dbMeta = contract.dbMeta || {};
	this.name = contract.name;
	this.contract = contract;
	//
	self.singularize = function(name) {
		return pluralMap[name];
	};
	//
	contract.localizedString = (function(entityName, propName) {
		var stringRes = contract.resources && contract.resources();
		return _getTranslatedString(stringRes, [entityName, propName]);
	}).bind(contract);

	var _entInstances = this._entities = {};
	forEachKey(entities, function(name, entity) {
		entity.name = name;

		// search facets
		if (contract.searchFacets) forEachKey(contract.searchFacets, function(key, facet) {
			if (facet.$fields && facet.$fields[entity.name]) {
				var f = entity.$facets = (entity.$facets || {});
				var ff = f[facet.$fields[entity.name]] = (f[facet.$fields[entity.name]] || []);
				ff.push(key);
			}
		});
		var entInst = _entInstances[name] = entities[name] = new entityClasses.Entity(self, name, entity);

		if (pluralMap[entInst.plural]) throw new Error(entInst.name + ": duplicate plural: " + entInst.plural);
		if (entities[entInst.plural]) throw new Error(entInst.name + ": plural is identical to singular: " + entInst.plural);
		classMap[entity.className] = entInst;
		pluralMap[entity.plural] = name;

	});
	// solve targetEntity
	forEachKey(entities, function(name, entity) {
		entity._solveTargetEntities();
	});
	// another pass to verify reverse relationships
	forEachKey(entities, function(name, entity) {
		entity._checkReverseRelations();
	});
	//
	forEachKey(contract.service || {}, function(name, operation) {
		if (typeof operation.execute != "function") throw new Error("Contract service '" + name + "' does not have execute method");
		datasetOperations[name] = operation;
	});
	self.datasetOperations = function() {
		return helpers.object.clone(datasetOperations, false);
	};
	// representations
	forEachKey(repr, function(rName, rr) {
		rr.name = rName;
		forEachKey(repr.$facets || {}, function(fName, ff) {
			ff.name = fName;
			if (ff.$copy) rr.$facets[fName] = rr.$facets[ff.$copy];
			else {
				ff._select = {};
				_makeSelect(ff._select, ff.$layout);
			}
		});
	});
	//
	self.getEntities = function() {
		return helpers.object.clone(contract.entities, false);
	};
	self.getRules = function() {
		return helpers.object.clone(rules, false);
	};
	self.getRepresentation = function(_, name, facet) {
		// TODO: return the representation as the associated entity with filtered properties
		//return contract.entities[name];
		return _entInstances[name];
	};
	self.getEntity = function(_, name) {
		//return contract.entities[name];
		return _entInstances[name];
	};
	self.entityByClassName = function(name) {
		return classMap[name];
	};
	self.getIndexedEntities = function(_) {
		return Object.keys(entities).filter(function(eName) {
			//return entities[eName].$searchIndex && entities[eName].$searchIndex.$fields;
			return _entInstances[eName].$searchIndex && _entInstances[eName].$searchIndex.$fields;
		}).map(function(eName) {
			//return entities[eName];
			return _entInstances[eName];
		});
	};
	self.getSearchFacets = function(_) {
		return Object.keys(contract.searchFacets || {}).map(function(fCode) {
			return {
				code: fCode,
				description: contract.searchFacets[fCode].$title
			};
		});
	};

	self.baseType = "application/json;vnd.sage=syracuse";

	// global events
	self.$events = {};
	_allEvents.forEach(function(name) {
		self.$events[name] = self.$events[name] || [];
	});
	self.registerEvent = (function(_, eventName, eventId, handler, entityName) {
		var target = entityName ? self.getEntity(_, entityName) : self;
		if (!target && target.$events && target.$events[eventName]) return;
		if (eventId) {
			var ev;
			target.$events[eventName].some(function(e) {
				if (e.id === eventId) {
					ev = e;
					return true;
				}
				return false;
			});
			if (ev) {
				ev.handler = handler;
				return;
			}
		}
		target.$events[eventName].push(eventId ? {
			id: eventId,
			handler: handler
		} : handler);
	}).bind(self);
}

helpers.defineClass(DataModel);

exports.make = function(contract, dataset) {
	// TODO : if the same model should be used for several datasets, first load modifies contract entities
	// so second load fails. Should detect the case or clone theese entities
	//	dataset = dataset || "all";
	// for now, same model for all dataset of the same contract
	dataset = "all";
	contract.models = contract.models || {};
	var model = contract.models[dataset];
	return model ? model : (contract.models[dataset] = new DataModel(contract));
};

// getSyncData(_, orm):
// retrieve basic data for synchronization (endpoint, conflictPriority) from globalSettings instance
// result is an array: [endpoint, conflictPriority]

function getSyncData(_, orm) {
	var settingsEnt = orm.model.getEntity(_, "setting");
	var endpoint;
	var conflictPriority;
	if (settingsEnt) {
		var globalData = orm.fetchInstance(_, settingsEnt, {});
		if (!globalData) throw new Error(locale.format(module, "noGlobalSettings"));
		endpoint = globalData.endpoint(_) || "";
		conflictPriority = globalData.conflictPriority(_);
	} else {
		// for test cases
		conflictPriority = 5;
		endpoint = "http://" + require('os').hostname() + ":" + require('syracuse-main/lib/nodeconfig').config.port;
	}
	endpoint += "/sdata/" + orm.model.contract.application + "/" + orm.model.contract.contract + "/" + orm.dataset.database + "/";
	return [endpoint, conflictPriority];
}
exports.getSyncData = getSyncData;


exports.getOrm = function(_, model, dataset) {
	//	console.log("dataset "+dataset.driver);
	var orm;
	if (dataset.driver && (dataset.driver === "mongodb")) orm = require("syracuse-orm/lib/dbHandles/mongoDbHandle").create(_, model, dataset);
	else throw new Error("unsupported ORM driver: " + dataset.driver);
	// add synchronization data
	if (model.contract && model.contract.entities) {
		var ents = model.contract.entities;
		var metaEnt;
		var endpoint;
		var conflictPriority;
		var locked = false;
		try {
			Object.keys(ents).forEach_(_, function(_, name) {
				var entity = ents[name];
				if (!entity.$allowSync) return;
				var cnt = entity.getCounterValue(_, orm, "tick");
				if (!cnt) { // create counter
					if (!locked) orm.lockDatabaseRetry(_);
					locked = true;
					if (!endpoint) {
						var syncData = getSyncData(_, orm);
						endpoint = syncData[0];
						conflictPriority = syncData[1];
					}
					var data = {
						conflictPriority: conflictPriority,
						digest: []
					};
					if (endpoint) {
						data.endpoint = endpoint + entity.plural;
					}
					entity._syncEndpoint = data.endpoint || "";
					entity.getCounterValue(_, orm, "tick", {
						value: 2,
						data: data
					});
					// 	put syncUuid, endpoint, and tick to instances which do not have it yet
					var cursor = orm.createCursor(_, entity, {});
					var inst;
					var syncUuids = {};
					while ((inst = cursor.next(_))) {
						// 	console.log("III "+((login in inst) ? inst.login(_) : inst.$uuid));
						if (!inst.$syncUuid) {
							var syncUuid = helpers.uuid.generate();
							if (syncUuid in syncUuids || syncUuid === inst.$uuid) {
								for (var i = 1; i < 10; i++) {
									var syncUuid = helpers.uuid.generate();
									if (syncUuid in syncUuids || syncUuid === inst.$uuid) syncUuid = undefined;
								}
								if (!syncUuid) throw new Error(locale.format(module, "noGenerateUuid"));
							}
							inst.$syncUuid = syncUuid;
						}
						syncUuids[inst.$syncUuid] = null;
						if (!inst.$endpoint) {
							inst.$endpoint = "";
							inst.$tick = 1;
							inst._noIncreaseTick = true;
							inst.save(_);
						}
					}
				} else {
					entity._syncEndpoint = cnt.data.endpoint;
				}
			});
		} finally {
			if (locked) {
				orm.unlockDatabase(_);
			}
		}
	}


	return orm;
};