"use strict";
//HACK
//--> remove dbHandle
// TODO  _hackBeforeSelect && _hackAfterSelect && _hackdbCollection, _hackManyToMany
//TODO remove  (data.$uuid || data.id || data.$key) --> data.$uuid
var helpers = require("syracuse-core/lib/helpers");
var forEachKey = helpers.object.forEachKey;
var types = require("syracuse-core/lib/types/allTypes");
var ruleTracer = helpers.debug.tracer("context.rule");
var dataHelpers = require("./dataContextHelpers");
var resourceHelpers = require("syracuse-core/lib/resource/util");
var serializer = require("syracuse-core/lib/resource/serializer");
var flows = require('streamline/lib/util/flows');

var translation = {
	invalidWhereBinary: function(value) {
		return "invalid where clause: expected binary expression, got " + value;
	},
	invalidWhereIdentifier: function(value) {
		return "invalid where clause: expected binary expression, got " + value;
	},
	invalidWhereClause: "invalid where clause: expected condition, got literal",
	invalidWhereFunction: "NIY: function in where clause",
	invalidWhereOR: "NIY: 'or' operator in where clause",
	invalidWhereIntenalError: function(value) {
		return "internal error: bad expression type: " + value;
	},
	invalidEntityName: function(value) {
		return "invalid entity name: " + value;
	}
};

function _applyCondition(query, exp) {
	if (exp.children.length != 2) throw new Error(translation.invalidWhereBinary(exp));
	if (exp.children[0].type != "identifier") throw new Error(translation.invalidWhereIdentifier(exp.children[0]));
	if (exp.children[1].type != "literal") throw new Error(translation.invalidWhereLiteral(exp.children[1]));
	return query.filter(exp.children[0].value, exp.value.code, exp.children[1].value)
}

function _applyWhere(query, where) {
	if (!where) return query;
	switch (where.type) {
	case "literal":
		throw new Error(translation.invalidWhereClause);
	case "function":
		throw new Error(translation.invalidWhereFunction);
	case "operator":
		switch (where.value.code) {
		case "and":
			return _applyWhere(_applyWhere(query, where.children[0]), where.children[1]);
		case "or":
			throw new Error(translation.invalidWhereOR);
		default:
			return _applyCondition(query, where);

		}
		break;
	default:
		throw new Error(translation.invalidWhereIntenalError(where.type));
	}
}

exports.where = _applyWhere;

function DataContext(model, readOnly) {
	this.model = model;
	this.readOnly = readOnly;
	this._dirty = {}; // list of modified properties
	this.dbHandles = []; //master dbHandles
	this._errorCount = 0;
	this.modified = false;
	this.serverSession = null;
	this._connected = false;
	this.statusCode = 200;
	this.config = {
		autoCreateOwned: false
	}; // auto-create compositions
	// hack
	this.interactive = true;
	this._session = null;
	this.lastState = null;
}

function _findEntity(context, name) {
	var entity = context.model.entityByClassName(name);
	if (entity == null) throw new Error(translation.invalidEntityName(name));
	return entity;
}

function _isManyToMany(relation) {
	return relation.isPlural && relation.targetEntity.dbFactory.meta.hasMany[relation.inv] && relation.targetEntity.dbFactory.meta.hasMany[relation.inv].manyToMany;
}

function _setMeta(context, dbHandle) {
	var entity = _findEntity(context, dbHandle._type);
	context.meta = entity.getMeta({}, true);
}

exports.DataContext = helpers.defineClass(DataContext, null, {
	withTransaction: function(_, doIt) {
		var self = this;
		if (self._connected) return doIt && doIt(_);

		self._connected = true;
		var session = self.model.connect(_);
		self.session = session;
		var createTransaction = session.transaction;
		// override session.transaction
		session.transaction = function(explicitCommit, _) {
			if (!self._transaction) throw new Error("data context used without transaction");
			return self._transaction;
		}
		self._transaction = createTransaction(!self.readOnly, _);
		try {
			return doIt(_);
		} catch (ex) {
			console.log("EX: " + ex.message + "\n" + ex.stack)
			self._transaction.rollback(session, _);
			throw ex;
		}
		//finally {
		//self._transaction = null;
		//}
	},
	entityByName: function(entityName) {
		return _findEntity(this, entityName);
	},
	// not used any more!
	checkErrors: function() {
		var self = this;
		if (self._errorCount > 0) throw new Error("cannot save: " + self._errorCount + " errors detected");
/*
 		if (self.hasErrors()) {
 		if (self.dbHandles.length) {
 		var errors = self._extractErrors(self.dbHandles[0]);
 		throw new Error("\n" + errors);
 		} else
 		throw new Error("Context with errors"); //TODO
 		}*/
	},
	setMainDbHandle: function(dbHandle) {
		var self = this;
		if (dbHandle._new) self.statusCode = 201;
		self.dbHandles.splice(0, 0, dbHandle);
		_setMeta(self, dbHandle);
	},
	commit: function(_) {
		var self = this;
		// clear errors
		self.clearErrors();
		// check dirty properties
		self.check(_);
		// look for errors
		self.checkErrors();
		//no errors --> fire saved
		self.fireEvent(_, "saved");
		// apply all validation rules
		self.validate(_);
		self.checkErrors();

		self._beforeCommit(_);
		// commit database transaction
		if (self._transaction) {
			self._transaction.commit(self.session, _);
			self.modified = false;
			return self._afterCommit(_);
		} else return null;
	},
	_afterCommit: function(_) {
		var self = this;
		self._clear(true);
	},
	_afterRollback: function(_) {
		var self = this;
	},
	_hackRemove: function(dbHandle) {
		var self = this;
		delete self.session.trackedObjects[dbHandle.id];
		if (!dbHandle._new) self.session.remove(dbHandle);
		self._rmvDbHandleListeners(dbHandle);
	},
	_hackdbCollection: function(execContext, dbHandle, name, rel, force) {
		var self = this;
		if (rel.isPlural && (!dbHandle._data[name] || force)) {
			self.session.queryCollectionCache = {};
			dbHandle._data[name] = dataHelpers.createCompositionList(self.session, dbHandle, rel, name, function(_, dbHandle, relation, dbHandles, index) {
				self._fireDbHandlePropertyEvent(_, execContext, "listChanged", dbHandle, relation, dbHandles, index);
			});
		}
		return dbHandle._data[name];
	},
	_hackManyToMany: function(execContext, dbHandle, name, rel, force) {
		var self = this;
		if (rel.isPlural && (!dbHandle._data[name] || force)) {
			var coll = dbHandle[name];
			self.session.queryCollectionCache = {};
			dbHandle._data[name] = dataHelpers.createManyToManyList(self.session, dbHandle, rel, name, function(_, dbHandle, relation, dbHandles, index) {
				self._fireDbHandlePropertyEvent(_, execContext, "listChanged", dbHandle, relation, dbHandles, index);
			});
			dbHandle._data[name]._old = coll;
			if (!force) dbHandle._data[name].save();

		}
		return dbHandle._data[name];
	},
	_hackManyToManyBeforeDelete: function(dbHandle, name, rel) {
		var coll = dbHandle[name];
		if (coll && coll._old) {
			coll.beforeDelete(coll._old);
			dbHandle._data[name] = coll._old;
		}
	},
	_hackManyToManyBeforeCommit: function(dbHandle, name, rel) {
		var coll = dbHandle[name];
		if (coll && coll._old) {
			coll.beforeCommit(coll._old);
			dbHandle._data[name] = coll._old;
			delete coll._old;
		}
	},
	_hackBeforeSelect: function() {
		var self = this;
		self._session = {};
		self._session.trackedObjects = self.session.trackedObjects;
		self.session.trackedObjects = {};
		self._session.objectsToRemove = self.session.objectsToRemove;
		self.session.objectsToRemove = {};
	},
	_hackAfterSelect: function() {
		var self = this;
		if (!self._session) return;
		forEachKey(self.session.trackedObjects, function(name, dbHandle) {
			if (!self._session.trackedObjects[name]) self._session.trackedObjects[name] = dbHandle;
		});
		self.session.trackedObjects = self._session.trackedObjects
		delete self._session.trackedObjects;
		self.session.objectsToRemove = self._session.objectsToRemove;
		delete self._session.trackedObjects;
		self._session = null;
		self.session.queryCollectionCache = {};
	},
	_hackGetOldValue: function(dbHandle, name) {
		var self = this;
		var old = dbHandle._dirtyProperties[name];
		if (old) return self.session.trackedObjects[old]
		return null;
	},
	_entity: function(dbHandle) {
		var self = this;
		return _findEntity(self, dbHandle._type);
	},
	_removeRefOwned: function(entity, dbHandle, property, val) {
		var self = this;
		var rel = entity.$relations[property];
		if (rel && rel.owned && !rel.isPlural) {
			// hack to get old value !!!!!
			var old = self._hackGetOldValue(dbHandle, property);
			if (old) self._remove(null, old, null, true);
		}
	},
	_setDbHandleListener: function(entity, dbHandle) {
		var self = this;
		dbHandle.addEventListener('set', function(event, dbHandle, property, val) {
			if (entity.allProperties[property]) {
				var rel = entity.$relations[property];
				var firstModif = false;
				if (!self._dirty[dbHandle.id]) {
					self._dirty[dbHandle.id] = {
						dbHandle: dbHandle,
						props: {}
					};
				}
				if (self._dirty[dbHandle.id].props[property]) {
					if (rel) self._dirty[dbHandle.id].props[property] = {};
					else {
						// detect fake changes
						if (self._dirty[dbHandle.id].props[property].oldValue === val) delete self._dirty[dbHandle.id].props[property];
					}
					self._dirty[dbHandle.id].props[property] = {
						oldValue: (rel ? undefined : dbHandle[property])
					};

				} else {
					self._dirty[dbHandle.id].props[property] = {
						oldValue: (rel ? undefined : dbHandle[property])
					};
				}
				self._dirty[dbHandle.id].props[property] = true; // used to test
				self._removeRefOwned(entity, dbHandle, property, val);
			}
		});
	},
	_rmvDbHandleListeners: function(dbHandle) {
		dbHandle.subscribers = {};
	},
	_filter: function(query, parameters, filter) {
		var self = this;
		if (parameters) {
			if (parameters.id) return query.filter("id", "=", parameters.id);
			var where = parameters.where;
			if (where) {
				query = _applyWhere(query, where);
			}
			if (parameters.count) query = query.limit(parameters.count);
			if (parameters.startIndex) query = query.skip(parameters.startIndex - 1);
		}
		if (filter) {
			query = filter(query);
		}
		return query;
	},
	create: function(_, entityName, data, execContext) {
		var self = this;
		execContext = self._checkExecuteContext(execContext);
		self.withTransaction(_, function(_) {
			return self._create(_, entityName, data, execContext);
		});
	},
	_checkExecuteContext: function(execContext) {
		if (typeof execContext == "function") throw new Error("EXEC CONTEXT IS FUNCTION");
		execContext = execContext || [];
		return execContext;
	},
	_addDbHandleExecuteContext: function(execContext, dbHandle) {
		if (!execContext) return [dbHandle];
		var result = execContext.slice(0, execContext.length);
		result.push(dbHandle);
		return result;
	},
	_create: function(_, entityName, data, execContext) {
		var self = this;
		execContext = self._checkExecuteContext(execContext);
		var entity = _findEntity(self, entityName);
		var dbHandle = new entity.dbFactory(self.session, null);
		self.modified = true;
		if (data && (data.$key || data.$uuid)) {
			dbHandle.id = (data.$key || data.$uuid);
		}
		self.session.add(dbHandle); // add dbHandle
		// init properties with default values
		forEachKey(entity.$properties, function(name, prop) {
			var dv = prop.defaultValue;
			if (dv === undefined) dv = prop["default"];
			if (dv !== undefined) dbHandle[name] = (typeof dv == "function") ? dv() : dv;
		});
		self._setDbHandleListener(entity, dbHandle);
		self._fireDbHandleEvent(_, "created", dbHandle, execContext);
		//auto-create relations owned = true && mandatory=true
		var ec = self._addDbHandleExecuteContext(execContext, dbHandle);
		flows.eachKey(_, entity.$relations, function(_, name, relation) {
			if (relation.owned) {
				self._hackdbCollection(execContext, dbHandle, name, relation, false);
				if (relation.mandatory) {
					var child = self.create(_, relation.targetEntity.className, null, ec);
					if (relation.isPlural) {
						return dbHandle[name].add2(_, child, true);
					} else dbHandle[name] = child;
				}
			} else if (_isManyToMany(relation)) {
				self._hackManyToMany(execContext, dbHandle, name, relation, false);
			}
		});
		self._initDbHandle(_, dbHandle, data, execContext, false);
		return dbHandle;
	},
	onDestroy: function() {
		var self = this;
		self._clear(false);
	},
	_clear: function(onlyRemoved) {
		var self = this;
		if (!self.session) return;
		if (!onlyRemoved) {
			self.dbHandles.length = 0;
			forEachKey(self.session.trackedObjects, function(id, dbHandle) {
				self._rmvDbHandleListeners(dbHandle);
				var entity = self._entity(dbHandle);
				forEachKey(entity.$relations, function(name, relation) {
					delete dbHandle._data[name];
				});
			});
			delete self.session.trackedObjects;
			self.session.trackedObjects = {};

		}
		forEachKey(self.session.objectsToRemove, function(id, dbHandle) {
			self._rmvDbHandleListeners(dbHandle);
			var entity = self._entity(dbHandle);
			forEachKey(entity.$relations, function(name, relation) {
				delete dbHandle._data[name];
			});
		});
		delete self.session.objectsToRemove;
		self.session.objectsToRemove = {};
	},
	edit: function(_, entityName, data, execContext) {
		var self = this;
		self.modified = true;
		execContext = self._checkExecuteContext(execContext);
		if (typeof entityName === "object") {
			return self._editDbHandle(_, entityName, data, execContext, true, false);
		}
		var dbHandle = self.fetch(_, entityName, (data.$uuid || data.$key));
		if (dbHandle) {
			return self._editDbHandle(_, dbHandle, data, execContext, true, false);
		} else return null;
	},
	_remove: function(_, dbHandle, execContext, isSync) {
		var self = this;
		if (!dbHandle) return;
		delete self._dirty[dbHandle.id];
		var entity = self._entity(dbHandle);
		// try to delete  children in right order
		var deletelist = [];
		//var hasCallback = (_ != null);
		var ec = self._addDbHandleExecuteContext(execContext, dbHandle);
		flows.eachKey(_, entity.$relations, function(_, name, rel) {
			if (rel.owned) {
				if (rel.isPlural) {
					if (!isSync) {
						var query = dbHandle[name];
						var relDbHandles = query.list(self._transaction, _);
						relDbHandles.forEach_(_, function(_, relDbHandle, index) {
							self._remove(_, relDbHandle, ec);
						});
					}
				} else if (dbHandle[name]) {
					deletelist.push(dbHandle[name])
				}
			} else {
				if (_isManyToMany(rel)) {
					self._hackManyToManyBeforeDelete(dbHandle, name, rel);

				}
			}
		});
		self._hackRemove(dbHandle);
		deletelist.forEach_(_, function(_, child, index) {
			self._remove(_, child, ec, isSync);
		});
		return dbHandle;
	},
	remove: function(_, entityName, id, execContext) {
		var self = this;
		execContext = self._checkExecuteContext(execContext);
		self.withTransaction(_, function(_) {
			// commit
			// TODO add to _editDbHandle
			if (typeof entityName === "object") {
				return self._editDbHandle(_, entityName, null, execContext, true, true);
			}
			var dbHandle = self.fetch(_, entityName, id);
			var inst = null;
			if (dbHandle) {
				inst = self._editDbHandle(_, dbHandle, null, execContext, true, true);
			}
			if (inst) {
				var dbHandle = self._removeDbHandle(_, inst, execContext);
				self._fireDbHandleEvent(_, "removed", dbHandle, null);
				return dbHandle;
			} else {
				return null;
			}
		});
	},
	removeAndCommit: function(_, entityName, id, execContext) {
		var self = this;
		var dbHandle = self.remove(_, entityName, id, execContext);
		if (dbHandle) {
			self.commit(_);
			return dbHandle;
		}
		return null;
	},
	_removeDbHandle: function(_, dbHandle, execContext) {
		var self = this;
		return self._remove(_, dbHandle, execContext);
	},
	querysData: function(_, entityName, parameters) {
		var self = this;
		return self._fetch(_, entityName, parameters);
	},
	query: function(_, entityName, filter) {
		var self = this;
		return self._fetch(_, entityName, null, filter);
	},
	fetch: function(_, entityName, id) {
		var self = this;
		var dbHandles = self._fetch(_, entityName, {
			"id": id
		});
		return dbHandles ? dbHandles[0] : null;
	},
	_updateDbHandle: function(_, dbHandle, data, execContext) {
		var self = this;
		self._initDbHandle(_, dbHandle, data, execContext, true);
		return dbHandle;
	},
	_editDbHandle: function(_, dbHandle, data, execContext, top, isRemove) {
		var self = this;
		self.withTransaction(_, function(_) {
			var entity = self._entity(dbHandle);
			self.session.add(dbHandle);
			//load relations
			flows.eachKey(_, entity.$relations, function(_, name, relation) {
				if (relation.owned) {
					if (relation.isPlural) {
						var query = dbHandle[name];
						relation.defaultOrder.forEach(function(order) {
							query = query.order(order[0], order[1]);
						});
						self._hackBeforeSelect();
						var relDbHandles = query.list(self._transaction, _);
						self._hackAfterSelect();
						// dbCollection --> localCollection
						var list = self._hackdbCollection(execContext, dbHandle, name, relation, true);
						relDbHandles.forEach_(_, function(_, relDbHandle, index) {
							list.add2(_, relDbHandle, false);
							self._editDbHandle(_, relDbHandle, null, self._addDbHandleExecuteContext(execContext, dbHandle), false, isRemove);
						});
					} else {
						var relDbHandle = dbHandle.fetch(self._transaction, name, _);
						if (relDbHandle) self._editDbHandle(_, relDbHandle, null, self._addDbHandleExecuteContext(execContext, dbHandle), false, isRemove);
					}
				} else {
					if (!relation.isPlural) {
						// load references
						var relDbHandle = dbHandle.fetch(self._transaction, name, _);
					} else if (_isManyToMany(relation)) {
						//many-to-many
						var query = dbHandle[name];
						self._hackBeforeSelect();
						var relDbHandles = query.list(self._transaction, _);
						self._hackAfterSelect();
						var list = self._hackManyToMany(execContext, dbHandle, name, relation, true);
						relDbHandles.forEach_(_, function(_, relDbHandle, index) {
							list.add2(_, relDbHandle, false);
						});
						dbHandle[name].save(); // save load state
					}
				}
			});
			self._setDbHandleListener(entity, dbHandle);
			if (!isRemove) self._fireDbHandleEvent(_, "edited", dbHandle, execContext);
			self._initDbHandle(_, dbHandle, data, execContext, false);
			return dbHandle;
		});
	},
	applyDelta: function(_, data) {
		var self = this;
		var execContext = self._checkExecuteContext(null);
		return self._updateDbHandle(_, self.dbHandles[0], data, execContext);
	},
	_execOperation: function(_, execContext, name, op, dbHandle) {
		var self = this;
		op.$isRequested = false;
		op.$diagnoses = [];
		try {
			var entity = self._entity(dbHandle);
			if (entity.$methods && entity.$methods[name]) {
				entity.$methods[name](_, self, execContext, dbHandle);
			}
			switch (name) {
			case "$save":
				self.commit(_);
				if (!op.$diagnoses.some(function(diag) {
					return diag.severity === "error";
				})) {
					op.$diagnoses.splice(0, 0, {
						severity: "info",
						message: "Resource has been saved"
					})
					op.$links = {
						$details: {
							$isHidden: false
						},
						$query: {
							$isHidden: false
						},
					}
				}
				break;
			case "remove":
				break;
			}
		} catch (ex) {
			op.$diagnoses.push({
				severity: "error",
				message: ex.message
			});
		}
	},
	_execOperations: function(_, dbHandle, execContext, actions) {
		var self = this;
		actions = actions || {};
		dbHandle.$actions = dbHandle.$actions || {};
		["$save"].forEach_(_, function(_, name) {
			var op = (dbHandle.$actions[name] = actions[name] || {});
			if (op.$isRequested) {
				self._execOperation(_, execContext, name, op, dbHandle);
			} else {
				op.$diagnoses = null;
			}
		});
	},
	_fetch: function(_, entityName, parameters, filter) {
		var self = this;
		self.withTransaction(_, function(_) {
			var entity = _findEntity(self, entityName);
			if (!entity) return null;
			if (parameters && parameters.id) {
				if (self.session.trackedObjects[parameters.id]) {
					return [self.session.trackedObjects[parameters.id]];
				}
				if (self.session.objectsToRemove[parameters.id]) return null;
			}
			var query = self._filter(entity.dbFactory.all(self.session), parameters, filter);
			if (!query) return null;
			self._hackBeforeSelect();
			var results = query.list(self._transaction, _);
			self._hackAfterSelect();
			results = results.length == null ? null : results;
			return results;
		});
	},
	_initListComposition: function(_, dbHandle, name, relation, resource, meta, delta, execContext) {
		var self = this;
		if (!resource) resource = [];
		var ec = self._addDbHandleExecuteContext(execContext, dbHandle);
		var local = self._hackdbCollection(execContext, dbHandle, name, relation, false);
		var diff = local.applyDiff(_, resource, meta && meta.$deleteMissing);
		diff.removeList.forEach_(_, function(_, child, index) {
			self._remove(_, child, ec);
		});
		diff.createList.forEach_(_, function(_, resource, index) {
			var child = self.create(_, relation.targetEntity.className, resource, ec);
			local.afterAdd(_, child, false);
		});
		diff.editList.forEach_(_, function(_, resource, index) {
			var child = local.dbHandle(resource.$uuid || resource.$key);
			self._initDbHandle(_, child, resource, ec, false);
		});
		var dbHandles = local.list(self._transaction, _);
		if (diff.firstModified < dbHandles.length) {
			self._fireDbHandlePropertyEvent(_, execContext, "listChanged", dbHandle, relation, dbHandles, diff.firstModified);
			local.sort();
		}
	},
	_initRefComposition: function(_, dbHandle, name, relation, resource, meta, delta, execContext) {
		var self = this;
		if (!resource) {
			//dbHandle[name] = null; //TODO delete ?
		} else {
			var ec = self._addDbHandleExecuteContext(execContext, dbHandle);
			var ci = dbHandle[name];
			var id = (resource.$uuid || resource.$key || resource.id);
			if (id && ci && (id != ci.id)) {
				dbHandle[name] = null; //delete existing dbHandle
				ci = null
			}
			if (ci) {
				self._initDbHandle(_, ci, resource, ec, false);
			} else {
				dbHandle[name] = self.create(_, relation.targetEntity.className, resource, ec);
			}
		}
	},
	_initComposition: function(_, dbHandle, name, relation, resource, meta, delta, execContext) {
		var self = this;
		if (relation.isPlural) return self._initListComposition(_, dbHandle, name, relation, resource, meta, delta, execContext);
		else return self._initRefComposition(_, dbHandle, name, relation, resource, meta, delta, execContext);
	},
	_initAssociation: function(_, dbHandle, name, relation, resource, meta, delta, execContext) {
		var self = this;
		if (relation.isPlural) {
			if (_isManyToMany(relation)) {
				var local = self._hackManyToMany(execContext, dbHandle, name, relation, false);
				var ec = self._addDbHandleExecuteContext(execContext, dbHandle);
				var diff = local.applyDiff(_, resource, meta && meta.$deleteMissing);
				diff.createList.forEach_(_, function(_, resource, index) {
					var child = self.fetch(_, relation.targetEntity.className, (resource.$uuid || resource.$key));
					if (child) {
						return local.afterAdd(_, child, false);
					}
				});
				return diff.firstModified;
			} else {
				// invalid set
			}

		} else {
			if (!resource) {
				dbHandle[name] = null;
			} else {
				var ci = dbHandle[name];
				var id = (resource.$uuid || resource.$key || resource.id);
				if (!id) return; // can't modify references
				if (ci && (id == ci.id)) return; // no modif
				dbHandle[name] = self.fetch(_, relation.targetEntity.className, id);
			}
		}
	},
	_initDbHandle: function(_, dbHandle, resource, execContext, delta) {
		var self = this;
		var entity = self._entity(dbHandle);
		if (self.interactive && !delta) {
			forEachKey(entity.allProperties, function(name, prop) {
				var rel = entity.$relations[name];
				if (rel) {
					if (prop.mandatory) self.setMandatory(dbHandle, name, true);
				}
			});
		}
		if (!resource) return;
		if (resource.$uuid || resource.$key) {
			dbHandle.id = (resource.$uuid || resource.$key);
		}
		var meta = resource ? (resource.$ || {}) : null;
		flows.eachKey(_, resource, function(_, name, prop) {
			var rel = entity.$relations[name];
			if (rel) {
				if (rel.owned) self._initComposition(_, dbHandle, name, rel, prop, meta[name], delta, execContext);
				else self._initAssociation(_, dbHandle, name, rel, prop, meta[name], delta, execContext);
			} else {
				if ((name !== "id") && (entity.$properties[name])) {
					try {
						prop = resourceHelpers.parseValue(entity.$properties[name], prop)
						dbHandle[name] = prop;
					} catch (ex) {
						self.addError(dbHandle, name, ex.message);
					}
				}
			}
		});
		self._execOperations(_, dbHandle, execContext, resource.$actions);
	},
	all: function(entityName) {
		var self = this;
		var entity = _findEntity(self, entityName);
		return entity.dbFactory.all(self.session);
	},
	_extractDbHandleErrors: function(path, entity, dbHandle, errors) {
		var self = this;
		var d = dbHandle.$;
		if (dbHandle.$diagnoses && dbHandle.$diagnoses.length) {
			dbHandle.$diagnoses.forEach(function(error) {
				errors.push(path + "-->" + error.message)
			});
		}
		if (d) {
			forEachKey(entity.allProperties, function(name) {
				var d = dbHandle.$[name];
				if (d && d.$diagnoses && d.$diagnoses.length) {
					d.$diagnoses.forEach(function(error) {
						errors.push(path + "." + name + "-->" + error.message);
					});
				}
			});
		};
		forEachKey(entity.$relations, function(name, rel) {
			if (rel.owned && dbHandle[name]) {
				if (!rel.isPlural) {
					self._extractDbHandleErrors(path + "." + name, rel.targetEntity, dbHandle[name], errors);
				}
			}
		});
	},
	_extractErrors: function(dbHandle) {
		var self = this;
		var errors = [];
		var entity = self._entity(dbHandle);
		self._extractDbHandleErrors(entity.className, entity, dbHandle, errors);
		return errors.join("\n");
	},
	getSerializeOptions: function() {
		var self = this;
		return {
			model: self.model,
			baseUrl: "",
			representation: {
				type: "$edit"
			},
			getPluralDbHandles: function(_, dbHandle, relation) {
				return self._getPluralDbHandles(_, dbHandle, relation);
			}
		};
	},
	_getPluralDbHandles: function(_, dbHandle, relation) {
		var self = this;
		if (_isManyToMany(relation)) {
			var local = self._hackManyToMany(null, dbHandle, relation.name, relation, false);
			return local.list(null, _);
		} else {
			var local = self._hackdbCollection(null, dbHandle, relation.name, relation, false);
			return local.list(null, _);
		}
	},
	restoreLastResource: function(resource) {
		var self = this;
		self.lastState = resource;
	},
	patchLastResource: function(data) {
		var self = this;
		if (self.lastState && data) {
			self.lastState = helpers.resource.sdataMerge(self.lastState, data);
		}
	},
	serializeDbHandle: function(_, dbHandle, options) {
		var self = this;
		var coptions = self.getSerializeOptions();
		helpers.object.copy(options, coptions);
		var resource = serializer.serialize(_, dbHandle, self.meta, coptions);
		if (resource.$actions && resource.$actions.$save) {
			resource.$actions.$save.$isDisabled = (self.hasErrors() || !self.modified);
		}
		if (coptions.delta) {
			//console.log("SERIALIZE: " + JSON.stringify(resource));
			if (self.lastState) {
				//console.log("LAST: " + JSON.stringify(self.lastState));
				var delta = helpers.resource.sdataDelta(self.lastState, resource);
				self.lastState = helpers.object.clone(resource, true);
				//console.log("DELTA: " + JSON.stringify(delta));
				resource = delta;
			} else self.lastState = helpers.object.clone(resource, true);
		}
		return resource;
	},
	setVisible: function(dbHandle, propName, value) {
		var self = this;
		self._setMetaProperty(dbHandle, propName, null, "$isHidden", value === false, false);
	},
	setMandatory: function(dbHandle, propName, value) {
		var self = this;
		self._setMetaProperty(dbHandle, propName, null, "$isMandatory", value === true, false);
	},
	setReadOnly: function(dbHandle, propName, value) {
		var self = this;
		self._setMetaProperty(dbHandle, propName, null, "$isReadOnly", value === true, false);
	},
	setDisabled: function(dbHandle, propName, value) {
		var self = this;
		self._setMetaProperty(dbHandle, propName, null, "$isDisabled", value === true, false);
	},
	_setMetaProperty: function(dbHandle, propertyName, preKey, key, value, defValue) {
		dbHandle.$ = dbHandle.$ || {};
		var meta = dbHandle.$;
		if (propertyName) meta = dbHandle.$[propertyName] = dbHandle.$[propertyName] || {};
		if (preKey) meta = meta[preKey] = meta[preKey] || {};
		if (value === defValue) delete meta[key];
		else meta[key] = value;
	},
	addError: function(dbHandle, propertyName, message) {
		var self = this;
		var meta = dbHandle;
		if (propertyName) {
			dbHandle.$ = dbHandle.$ || {};
			meta = dbHandle.$[propertyName] = dbHandle.$[propertyName] || {};

		}
		self._errorCount++;
		meta.$diagnoses = meta.$diagnoses || [];
		meta.$diagnoses.push({
			severity: "error",
			message: message
		});
	},
	_clearDbHandleErrors: function(dbHandle, propertyName) {
		var self = this;
		var meta = dbHandle;
		if (propertyName) {
			meta = null;
			if (dbHandle && dbHandle.$) meta = dbHandle.$[propertyName];
		}
		if (meta && meta.$diagnoses) {
			self._errorCount -= meta.$diagnoses.length;
			delete meta.$diagnoses;
		}
	},
	clearErrors: function(dbHandle, propertyName) {
		var self = this;
		if (dbHandle == null) {
			self.dbHandles.forEach(function(dbHandle) {
				self._clearDbHandleErrors(dbHandle, "");
			});
			self._errorCount = 0;
		} else {
			self._clearDbHandleErrors(dbHandle, propertyName);
		}
	},
	hasErrors: function() {
		var self = this;
		return (self._errorCount > 0);
	},
	fireEvent: function(_, event) {
		var self = this;
		self.dbHandles.forEach_(_, function(_, dbHandle, index) {
			self._fireDbHandleEvent(_, event, dbHandle, null);
		});
	},
	_fireDbHandleEvent: function(_, event, dbHandle) {
		var self = this;
		var entity = self._entity(dbHandle)
		var events = entity.$events[event];
		ruleTracer && ruleTracer("Fire event \"" + event + "\" to  " + entity.className + "(" + dbHandle.id + ")");
		if (!events) return;
		flows.eachKey(_, events, function(_, ruleName, event) {
			ruleTracer && ruleTracer(" Execute rule \"" + ruleName + "\" on " + entity.className + "(" + dbHandle.id + ")");
			event(_, self, dbHandle);
		});
	},
	_fireDbHandlePropertyEvent: function(_, execContext, eventName, dbHandle, property, list, startIndex) {
		var self = this;
		var entity = (ruleTracer) ? self._entity(dbHandle) : null;
		var rules = property.$rules;
		if (!rules) return;
		var events = rules[eventName];
		if (!events) return;
		ruleTracer && ruleTracer("Fire event \"" + eventName + "\" to  " + entity.className + "(" + dbHandle.id + ")." + property.type);
		flows.eachKey(_, events, function(_, ruleName, event) {
			ruleTracer && ruleTracer(" Execute rule \"" + ruleName + "\" on " + entity.className + "(" + dbHandle.id + ")." + property.type);
			event(_, self, dbHandle, list, startIndex);
		});
	},
	_validationError: function(dbHandle, property, name, error) {
		var self = this;
		self.addError(dbHandle, name, error);
	},
	_validateRelation: function(dbHandle, rel, name) {
		var self = this;
		if (rel.mandatory) {
			var value = dbHandle[name];
			if (value == null) {
				self._validationError(dbHandle, rel, name, "invalid value: empty");
			} else if (rel.isPlural) {
				//TODO <--check that
				//(value.length == 0)
				// self._validationError(dbHandle, rel, name, "invalid value: empty");
			}
		}
	},
	_validateProperty: function(dbHandle, property, name) {
		var self = this;
		if (property.isComputed) return true;
		var value = dbHandle[name];
		if (typeof value == "undefined") {
			self._validationError(dbHandle, property, name, "invalid value: undefined");
			return false;
		}
		var type = types[property.type];
		if (type) {
			var errors = [];
			type.validate(value, property.$constraints, errors);
			if (errors.length) {
				errors.forEach(function(error) {
					self._validationError(dbHandle, property, name, error);
				});
				return false;
			}
		}
		return true;
	},
	_checkComposition: function(_, dbHandle, dirtyProperties, types) {
		var self = this;
		var doCheck = (dbHandle != null);
		var dp = null;
		if (doCheck) {
			if (dirtyProperties != null) {
				doCheck = (self._dirty[dbHandle.id] != null);
				if (doCheck) dp = self._dirty[dbHandle.id].props;
			}
		}
		if (doCheck) self._checkDbHandle(_, dbHandle, dp, types);
	},
	_checkDbHandle: function(_, dbHandle, dirtyProperties, types) {
		var self = this;

		var entity = self._entity(dbHandle);
		ruleTracer && ruleTracer(" Check dbHandle " + entity.className + "(" + dbHandle.id + ")");
		//process properties in definition order
		flows.eachKey(_, entity.allProperties, function(_, name, property) {
			if ((dirtyProperties == null) || (dirtyProperties[name] != null)) {
				//apply rules to dbHandle
				if (dirtyProperties) delete dirtyProperties[name];

				var rel = entity.$relations[name];
				types.forEach_(_, function(_, type, index) {
					if (type == "validation") {
						// do JSON-SCHEMA validation
						self.clearErrors(dbHandle, name);
						if (rel) {
							self._validateRelation(dbHandle, rel, name);
						} else {
							self._validateProperty(dbHandle, property, name);
						}
					}
					if (property && property.$rules && property.$rules[type]) {
						flows.eachKey(_, property.$rules[type], function(_, triggerName, trigger) {
							ruleTracer && ruleTracer("  Execute rule \"" + triggerName + "\" triggered by \"" + name + "\" on " + entity.className + "(" + dbHandle.id + ")");
							trigger(_, self, dbHandle);
						});
					}
				});
				if (rel && rel.owned) {
					// validate compositions
					if (rel.isPlural) {
						var coll = dbHandle[name];
						var dbHandles = coll.list(self._transaction, _);
						dbHandles.forEach_(_, function(_, inst, index) {
							self._checkComposition(_, inst, dirtyProperties, types);
						});
					} else {
						self._checkComposition(_, dbHandle[name], dirtyProperties, types);
					}
				}
			}
		});
	},
	check: function(_) {
		var self = this;
		self._internalCheck(_, ["validation", "propagation"], false);
	},
	_orderDbHandleBeforeCommit: function(_, dbHandle) {
		var self = this;
		var entity = self._entity(dbHandle);
		flows.eachKey(_, entity.$relations, function(_, name, relation) {
			if (_isManyToMany(relation)) {
				self._hackManyToManyBeforeCommit(dbHandle, name, relation);
			} else if (relation.owned) {

			}
		});
	},
	_beforeCommit: function(_) {
		var self = this;
		//self._session.trackedObjects = self.session.trackedObjects;
		//self.session.trackedObjects = {};
		if (self.dbHandles.length) {
			self.dbHandles.forEach_(_, function(_, dbHandle, index) {
				self._orderDbHandleBeforeCommit(_, dbHandle);
			});
		}
		//delete self._session.trackedObjects;
	},
	validate: function(_) {
		var self = this;
		self._internalCheck(_, ["validation"], true);
	},
	_internalCheck: function(_, types, checkall) {
		ruleTracer && ruleTracer("Execute check : \"" + types + "\" checkAll = " + checkall);
		var self = this;
		if (checkall) {
			// check all dbHandles
			if (self.dbHandles.length) {
				self.dbHandles.forEach_(_, function(_, dbHandle, index) {
					self._checkDbHandle(_, dbHandle, null, types);
				});
			}
		} else {
			// check dirty dbHandles
			flows.eachKey(_, self._dirty, function(_, key, dirty) {
				if (dirty.props && Object.keys(dirty.props).length) {
					self._checkDbHandle(_, dirty.dbHandle, dirty.props, types);
				}
			});
		}
/*
 		//There is not executed rules ? ?
 		forEachKey(self._dirty, function(key, dirty, next) {
 		forEachKey(dirty.props, function(name, prop, next) {
 		if (prop) throw new Error("Rule definition error");
 		});
 		});
 		*/
		self._dirty = {};

	},
	getUser: function(_) {
		var self = this;
		if (!self.serverSession) return null;
		var user = self.serverSession.getData("user");
		if (user) return user;
		var userUUID = self.serverSession.getData("userID");
		if (userUUID) {
			user = self.fetch(_, "User", userUUID);
			self.serverSession.setData("user", user);
			return user;
		}
		return null;
	},
/*
 	TODO:
 	--> expose all methods:  for now, only "save" is exposed
 	--> dispatch of methods : only save is dispatched
 	--> handle database errors :  restore hackCollectons
 	--> handle database commit :  remove hackCollectons
 	--> handle database commit :  review: order insert/delete/edit statement
 	--> serialize many-to-many relations
 	-->  orm: define unique indexes +  check before commit
 	-->  orm: define multiplicity
 	-->  orm: foreign keys
 	-->  performances ?
 	-->  code review
 	--> implement draft.patchLastResource
 	--> remove
 	*/
});

exports.create = function(sdataContext) {
	var result = new DataContext(sdataContext.model, true);
	result.serverSession = sdataContext.request.session;
	return result;
};