"use strict";

/// !doc
/// # Storage Area API  
/// ```javascript
/// var sa = require('syracuse-orm/lib/storageArea')  
/// ```
/// This module is exported to be able to be call from X3

exports.$exported = true;


var helpers = require('syracuse-core/lib/helpers'),
	fs = require('fs'),
	util = require('util'),
	uuid = require('syracuse-core/lib/uuid'),
	adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;

/// -------------
/// ## getDocumentInstance function :
/// ``` javascript
/// var document = sa.getDocumentInstance(_, filter); 
/// ```
/// Retrieve document instance from storage area.  
/// 
/// * The `filter` parameter represents filter selector :  
/// 
/// ``` javascript
/// var filter = {
///   jsonWhere:{
///     $uuid: uuid
///   }
/// }  
/// ```
/// * The `volume` parameter represents the name of the volume where a new document will be stored.
/// 
/// Returns a Document entity  
/// 
exports.getDocumentInstance = function(_, filter, volume){
	return new Helper(_).getDocumentInstance(_, filter, volume);
}


/// -------------
/// ## readAll function :
/// ``` javascript
/// var document = sa.readAll(_, filter); 
/// ```
/// Read document from storage area.  
/// 
/// * The `filter` parameter represents filter selector :  
/// 
/// ``` javascript
/// var filter = {
///   jsonWhere:{
///     $uuid: uuid
///   }
/// }  
/// ```
/// Returns a Document entity  
/// 
exports.readAll = function(_, filter){
	return new Helper(_).readAll(_, filter);
}

/// -------------
/// ## writeAll function :
/// ``` javascript
/// var document = sa.writeAll(_, properties, buf, filter);  
/// ```
/// Update document in storage area if filter is valid, else Create it. 
/// 
/// * The `properties` parameter represents the document properties in JSON format :  
/// 
/// ``` javascript
/// var properties = {
///   description: "UPDATE",
///   content: {
///     contentType: "application/pdf",
///     fileName: "update.pdf",
///   }
/// }
/// ```
/// * The `buf` parameter represents the document in binary format.  
/// * The `filter` parameter represents filter selector. It's used only for update.  
/// 
/// ``` javascript
/// var filter = {
///        jsonWhere:{
///           $uuid: uuid
///        }
///    }
/// ```
/// * The `volume` parameter represents the name of the volume where a new document will be stored.
/// 
/// Returns a Document entity.  
///  
exports.writeAll = function(_, properties, buf, filter, volume){
	return new Helper(_).writeAll(_, properties, buf, filter, volume);
}
/// -------------
/// ## remove function :
/// ``` javascript
/// sa.remove(_, filter);  
/// ```
/// Remove document from storage area.  
/// 
/// * The `filter` parameter represents filter selector :  
/// 
/// ``` javascript
/// var filter = {
///        jsonWhere:{
///           $uuid: uuid
///        }
///    }
/// ```
/// Returns 1 if operation is successful else throw Error.  
///  
exports.remove = function(_, filter){
	return new Helper(_).remove(_, filter);
}

/// -------------
/// ## open function :
/// ``` javascript
/// var dd = sa.open(_, filter);  
/// ``` 
/// Open document from storage area or create a new instance.  
/// 
/// * The `filter` parameter represents filter selector :  
/// 
/// ``` javascript
/// var filter = {  
///      jsonWhere:{
///         $uuid: uuid
///      }
///    }
/// ```
/// 
/// * The `options` parameter represents miscellanous options :  
///    * The `volume` option allow to specify what Syracuse volume will be used to store the document. `STD` is used by default.  
///    * The `recordSep` option MUST be used ONLY for `plain/text` documents. It permit to define records separators.  
/// 
/// ``` javascript
/// var options = {  
///      volume: "STD",
///      recordSep: "\r\n"
///    }
/// ```
/// Returns a Document Descriptor UUID or null if document was not found. 
///  
exports.open = function(_, filter, options){
	return new Helper(_).open(_, filter, options);
}

/// -------------
/// ## write function :
/// ``` javascript
/// dd.write(_, ddUuid, properties, stream); 
/// ```   
/// Write content of document instance.  
/// This function CAN be called between `open` and `close` functions.  
/// 
/// * The `ddUuid` parameter represents an identifier of Document Descriptor in uuid format.  
/// * The `properties` parameter represents the document properties in JSON format :  
/// 
/// ``` javascript
/// var properties = {
///        description: "STREAM",
///        content: {
///            contentType: "application/pdf",
///            fileName: "stream.pdf",
///        }
///    }
/// ```
/// * The `stream` parameter represents a stream of the document in binary format.  
///  
exports.write = function(_, ddUuid, properties, stream){
	return new Helper(_).write(_, ddUuid, properties, stream);
}

/// -------------
/// ## read function :
/// ``` javascript
/// dd.read(_, ddUuid); 
/// ```    
/// Read content of document instance. 
/// This function CAN be called between `open` and `close` functions.  
/// 
/// * The `ddUuid` parameter represents an identifier of Document Descriptor in uuid format.  
/// * The `chunkSize` parameter represents the length to read. If its value is -1, chunkSize is ignored.
/// Returns a Buffer part.  
///  
exports.read = function(_, ddUuid, chunkSize){
	return new Helper(_).read(_, ddUuid, chunkSize);
}

/// -------------
/// ## close function :
/// ``` javascript
/// dd.close(_, ddUuid);  
/// ```   
/// Close the document store and persist the content in datastore.  
/// IMPORTANT : this function MUST be called after `open` function !!!!  
/// 
/// * The `ddUuid` parameter represents an identifier of Document Descriptor in uuid format.  
/// Returns a Document entity.  
///  
exports.close = function(_, ddUuid, withSave){
	return new Helper(_).close(_, ddUuid, withSave);
}


var stack = {};


var Helper = helpers.defineClass(function(_) {
	// getting the administration ORM
	this.db = adminHelper.getCollaborationOrm(_);
	// the metamodel is associated to the orm
	this.model = this.db.model;
	this.entity = this.model.getEntity("document");
	this.factory = this.entity.factory;
	
}, null, {
	getDocumentInstance : function(_, filter, volume){
		var document;
		if (filter != null && filter.length !== 0){
			// fetchInstance(callback, entity, filter)
			document = this.db.fetchInstance(_, this.entity, filter);
		}else{
			// Retrieve volume or STD by default
			var vol = this.db.fetchInstance(_, this.db.model.getEntity("storageVolume"), {
				"jsonWhere": {
					"code": volume && volume.length !== 0 ? volume : "STD"
				}
			});

			if (!vol)
				throw new Error("Volume '" + volume + "' doesn't exist");
			// create a new object, createInstance params are : (callback, initialDataJson, ormInstance)
			document = this.factory.createInstance(_, null, this.db);
			document.volume(_, vol);
		}
		return document;
	},
	
	readAll : function(_, filter){
		// fetchInstance(callback, entity, filter)
		var document = this.db.fetchInstance(_, this.entity, filter);
		if (document == null) throw new Error("Document not found with filter :\n" + JSON.stringify(filter,null,2));
		var store = document.content(_);
		// read the binary content
		if (!store.fileExists(_)) throw new Error("File doesn't exist");
		// get file meta
		var res = store.createReadableStream(_).readAll(_);
		return res.toString('binary');
	},


	writeAll : function(_, props, buf, filter, volume){
		
		var document = this.getDocumentInstance(_, filter, volume);
		Object.keys(props).forEach_(_, function(_,elt){
			if (elt !== 'content' && document[elt]){
				document[elt](_, props[elt]);
			}
		});
		
		if (buf != null && buf.length !== 0){
			var store = document.content(_);
			var props = props.content != null ? props.content : {};
			var stream = store.createWritableStream(_, props);
			stream.write(_, buf, "binary");
			stream.write(_, null);
		}
		document.save(_);
		ckeckDiagnoses(document);
		return document;
	},
	
	remove : function(_, filter){
		
		var document = this.db.fetchInstance(_, this.entity, filter);
		if (!document) throw new Error("Document not found.");
		var res = document._db.deleteInstance(_, document);
		if (res !== 1)
			throw new Error("Document instance has not been deleted.");
		return res;
	},
	
	open : function(_, filter, options){
		
		var ddUuid = uuid.generate('-');
		var self = this;
		var StoWriter = helpers.defineClass(function(_, filter) {
			this.document = self.getDocumentInstance(_, filter, options.volume);
			this.store = this.document && this.document.content(_);
			this.first = true;
			if (options.recordSep)
				this.recordSep = options.recordSep;
		}, null, {});
		
		var writer = new StoWriter(_, filter);
		if (!writer.document) return null;
		
		stack[ddUuid] = writer;
		return ddUuid;
	},
	

	write : function(_, ddUuid, props, stream) {
		
		var dd = stack[ddUuid];
		if (dd != null){
			if (stream != null && stream.length !== 0){
				try{
					if (dd.first){
						Object.keys(props).forEach_(_, function(_,elt){
							if (elt !== 'content' && dd.document[elt]){
								dd.document[elt](_, props[elt]);
							}
						});
						dd._stream = dd.store.createWritableStream(_, props.content);
						dd.first = false;
					}
					dd._stream.write(_, stream, "binary");
					if (dd.recordSep) {
						dd._stream.write(_, dd.recordSep, "binary");
					}
				}catch(e){
					removeFromStack(ddUuid);
					throw e;
				}
			}else{
				throw new Error("Document content must not be empty.");
			}
			
		}else{
			throw new Error("Document descriptor not found");
		}
	},
	
	read : function(_, ddUuid, chunkSize){
		var dd = stack[ddUuid];
		if (dd != null){
			try{
				if (dd.first){
					// read the binary content
					if (!dd.store.fileExists(_)) throw new Error("File doesn't exist");
					// get file meta
					dd._stream = dd.store.createReadableStream(_);
					dd.first = false;
				}
				var stoProps = dd.store.getProperties(_);
				var res = '';
				if (chunkSize && chunkSize !== -1) {
					res = dd._stream.read(_, chunkSize).toString('binary');
				} else if (dd.recordSep) {
					var tmp;
					while (tmp = dd._stream.read(_, 1)) {
						res += tmp.toString();
						if (res.indexOf(dd.recordSep) !== -1) break;
					}
					if (!tmp) return null;
					res = res.toString().substring(0, res.length - dd.recordSep.length);
				}else {
					res = dd._stream.read(_, stoProps.chunkSize);
				}
				return res;	
			}catch(e){
				removeFromStack(ddUuid);
				throw e;
			}
		}else{
			throw new Error("Document descriptor not found");
		}
		
	},

	close : function(_, ddUuid, withSave) {
		var dd = stack[ddUuid];
		if (dd != null){
			try{
				// a readable stream doesn't have "write" method
				dd._stream && dd._stream.write && dd._stream.write(_, null);
				withSave && dd.document.save(_);
			}finally{
				removeFromStack(ddUuid);
			}
			ckeckDiagnoses(dd.document);
			return dd.document;
		}else{
			throw new Error("Document descriptor not found");
		}
	}
	
});

function removeFromStack(ddUuid){
	//console.log("removeFromStack: "+ddUuid);
	delete stack[ddUuid];
}

function ckeckDiagnoses(doc){
	
	var mess = '';
	Object.keys(doc.$properties).forEach(function(elt){
		if (doc.$properties[elt].$diagnoses != null && doc.$properties[elt].$diagnoses.length !== 0){
			doc.$properties[elt].$diagnoses.forEach(function(diag){
				mess += diag.severity + " : " + diag.message + "\n";
			});
		}
	});
	if (mess !== '')
		throw new Error(mess);	
}