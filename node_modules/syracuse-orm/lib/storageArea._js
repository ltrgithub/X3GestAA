"use strict";

/// !doc
/// # Storage Area API  
/// ```javascript
/// var sa = require('syracuse-orm/lib/storageArea')  
/// ```
/// 

var helpers = require('syracuse-core/lib/helpers'),
	fs = require('fs'),
	util = require('util'),
	uuid = require('syracuse-core/lib/uuid'),
	adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;

/// -------------
/// ## readAll function :
/// ``` javascript
/// var document = sa.readAll(_, filter); 
/// ```
/// Read document from storage area.  
/// 
/// * The `filter` parameter represents filter selector :  
/// 
/// ``` javascript
/// var filter = {
///   jsonWhere:{
///     $uuid: uuid
///   }
/// }  
/// ```
/// Returns a Document entity  
/// 
exports.readAll = function(_, filter){
	return new Helper(_).readAll(_, filter);
}

/// -------------
/// ## writeAll function :
/// ``` javascript
/// var document = sa.writeAll(_, properties, buf, filter);  
/// ```
/// Update document in storage area if filter is valid, else Create it. 
/// 
/// * The `properties` parameter represents the document properties in JSON format :  
/// 
/// ``` javascript
/// var properties = {
///   description: "UPDATE",
///   content: {
///     contentType: "application/pdf",
///     fileName: "update.pdf",
///   }
/// }
/// ```
/// * The `buf` parameter represents the document in binary format.  
/// * The `filter` parameter represents filter selector. It's used only for update.  
/// 
/// ``` javascript
/// var filter = {
///        jsonWhere:{
///           $uuid: uuid
///        }
///    }
/// ```
/// Returns a Document entity.  
///  
exports.writeAll = function(_, properties, buf, filter){
	return new Helper(_).writeAll(_, properties, buf, filter);
}
/// -------------
/// ## remove function :
/// ``` javascript
/// sa.remove(_, filter);  
/// ```
/// Remove document from storage area.  
/// 
/// * The `filter` parameter represents filter selector :  
/// 
/// ``` javascript
/// var filter = {
///        jsonWhere:{
///           $uuid: uuid
///        }
///    }
/// ```
/// Returns 1 if operation is successful else throw Error.  
///  
exports.remove = function(_, filter){
	return new Helper(_).remove(_, filter);
}

/// -------------
/// ## open function :
/// ``` javascript
/// var dd = sa.open(_, filter);  
/// ``` 
/// Open document from storage area or create a new instance.  
/// 
/// * The `filter` parameter represents filter selector :  
/// 
/// ``` javascript
/// var filter = {  
///         jsonWhere:{
///         $uuid: uuid
///      }
///    }
/// ```
/// Returns a Document Descriptor UUID. 
///  
exports.open = function(_, filter){
	return new Helper(_).open(_, filter);
}

/// -------------
/// ## write function :
/// ``` javascript
/// dd.write(_, ddUuid, properties, stream); 
/// ```   
/// Write content of document instance.  
/// This function CAN be called between `open` and `close` functions.  
/// 
/// * The `ddUuid` parameter represents an identifier of Document Descriptor in uuid format.  
/// * The `properties` parameter represents the document properties in JSON format :  
/// 
/// ``` javascript
/// var properties = {
///        description: "STREAM",
///        content: {
///            contentType: "application/pdf",
///            fileName: "stream.pdf",
///        }
///    }
/// ```
/// * The `stream` parameter represents a stream of the document in binary format.  
///  
exports.write = function(_, ddUuid, properties, stream){
	return new Helper(_).write(_, ddUuid, properties, stream);
}

/// -------------
/// ## read function :
/// ``` javascript
/// dd.read(_, ddUuid); 
/// ```    
/// Read content of document instance. 
/// This function CAN be called between `open` and `close` functions.  
/// 
/// * The `ddUuid` parameter represents an identifier of Document Descriptor in uuid format.  
/// Returns a Buffer part.  
///  
exports.read = function(_, ddUuid){
	return new Helper(_).read(_, ddUuid);
}

/// -------------
/// ## close function :
/// ``` javascript
/// dd.close(_, ddUuid);  
/// ```   
/// Close the document store and persist the content in datastore.  
/// IMPORTANT : this function MUST be called after `open` function !!!!  
/// 
/// * The `ddUuid` parameter represents an identifier of Document Descriptor in uuid format.  
/// Returns a Document entity.  
///  
exports.close = function(_, ddUuid){
	return new Helper(_).close(_, ddUuid);
}


var stack = {};


var Helper = helpers.defineClass(function(_) {
	// getting the administration ORM
	this.db = adminHelper.getCollaborationOrm(_);
	// the metamodel is associated to the orm
	this.model = this.db.model;
	this.entity = this.model.getEntity("document");
	this.factory = this.entity.factory;
	
}, null, {
	getDocumentInstance : function(_, filter){
		var document;
		if (filter != null){
			// fetchInstance(callback, entity, filter)
			document = this.db.fetchInstance(_, this.entity, filter);
		}else{
			// create a new object, createInstance params are : (callback, initialDataJson, ormInstance)
			document = this.factory.createInstance(_, null, this.db);
		}
		return document;
	},
	
	readAll : function(_, filter){
		// fetchInstance(callback, entity, filter)
		var document = this.db.fetchInstance(_, this.entity, filter);
		if (document == null) throw new Error("Document not found with filter :\n" + JSON.stringify(filter,null,2));
		var store = document.content(_);
		// read the binary content
		if (!store.fileExists(_)) throw new Error("File doesn't exist");
		// get file meta example
		var props = store.getProperties(_);
// crnit: change of storage area read interface: use a "real" ReadableStream >>>
		// store.readOpen(_);
		var stream = store.createReadableStream(_);
		var buf;
		var len = 0;
		var buffers = [];
		// while(buf = store.read(_, props.chunkSize)){
// crnit <<<
		while(buf = stream.read(_, props.chunkSize)){
			len += buf.length;
			buffers.push(buf);
		}
		return Buffer.concat(buffers, len);
	},


	writeAll : function(_, props, buf, filter){
		
		var document = this.getDocumentInstance(_, filter);
		Object.keys(props).forEach_(_, function(_,elt){
			if (elt !== 'content' && document[elt]){
				document[elt](_, props[elt]);
			}
		});
		
		if (buf != null && buf.length !== 0){
			var store = document.content(_);
			var props = props.content != null ? props.content : {};
			store.write(_, buf, props);	
			store.close(_);
		}
		document.save(_);
		ckeckDiagnoses(document);
		return document;
	},
	
	remove : function(_, filter){
		
		var document = this.db.fetchInstance(_, this.entity, filter);
		var res = document._db.deleteInstance(_, document);
		
		if (res !== 1)
			throw new Error("Document instance has not been deleted.");
		
		return res;
	},
	
	open : function(_, filter){
		
		var ddUuid = uuid.generate('-');
		var self = this;
		var StoWriter = helpers.defineClass(function(_, filter) {
			this.document = self.getDocumentInstance(_, filter);
			this.store = this.document.content(_);
			this.first = true;
		}, null, {});
		
		stack[ddUuid] = new StoWriter(_, filter);
		return ddUuid;
	},
	

	write : function(_, ddUuid, props, stream) {
		
		var dd = stack[ddUuid];
		if (dd != null){
			if (stream != null && stream.length !== 0){
				try{
					if (dd.first){
						Object.keys(props).forEach_(_, function(_,elt){
							if (elt !== 'content' && dd.document[elt]){
								dd.document[elt](_, props[elt]);
							}
						});
						dd.first = false;
					}
					dd.store.write(_, stream, props.content);
				}catch(e){
					removeFromStack(ddUuid);
					throw e;
				}
			}else{
				throw new Error("Document content must not be empty.");
			}
			
		}else{
			throw new Error("Document descriptor not found");
		}
	},
	
	read : function(_, ddUuid){
		
		var dd = stack[ddUuid];
		if (dd != null){
			try{
				if (dd.first){
					// read the binary content
					if (!dd.store.fileExists(_)) throw new Error("File doesn't exist");
					// get file meta example
					
// crnit: change of storage area read interface: use a "real" ReadableStream >>>
					// dd.store.readOpen(_);
					dd._stream = dd.store.createReadableStream(_);
					dd.first = false;
					
				}
				var props = dd.store.getProperties(_);
				// return dd.store.read(_, props.chunkSize);
				return dd._stream.read(_, props.chunkSize);
// crnit <<<
				
			}catch(e){
				removeFromStack(ddUuid);
				throw e;
			}
		}else{
			throw new Error("Document descriptor not found");
		}
		
	},

	close : function(_, ddUuid) {
		
		var dd = stack[ddUuid];
		if (dd != null){
			try{
				
				dd.store.close(_);
				dd.document.save(_);
			}finally{
				removeFromStack(ddUuid);
			}
			ckeckDiagnoses(dd.document);
			return dd.document;
		}else{
			throw new Error("Document descriptor not found");
		}
	}
	
});

function removeFromStack(ddUuid){
	//console.log("removeFromStack: "+ddUuid);
	delete stack[ddUuid];
}

function ckeckDiagnoses(doc){
	
	var mess = '';
	Object.keys(doc.$).forEach(function(elt){
		if (doc.$[elt].$diagnoses != null && doc.$[elt].$diagnoses.length !== 0){
			doc.$[elt].$diagnoses.forEach(function(diag){
				mess += diag.severity + " : " + diag.message + "\n";
			});
		}
	});
	if (mess !== '')
		throw new Error(mess);	
}


