"use strict";

/// !doc
/// 
/// # Storage Area API
/// 
/// `var sa = require('syracuse-orm/lib/storageArea')`
/// 

var helpers = require('syracuse-core/lib/helpers'),
	fs = require('fs'),
	util = require('util'),
	adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;


/// * `var document = sa.readDocument(_, filter);`  
///   Read document from storage area.
///   The `filter` parameter represents filter selector :
///      ex: var filter = {
///                 jsonWhere:{
///                    $uuid: uuid
///                 }
///              }
///   Returns a Document entity 
exports.readDocument = function(_, filter){
	return new Helper(_).read(_, filter);
}

/// * `var document = sa.createDocument(_, properties, buf);`  
///   Create document in storage area.
///   The `properties` parameter represents document properties in JSON format :
///      ex: var properties = {
///                  description: "CREATE",
///                  content: {
///                     contentType: "application/pdf",
///                     fileName: "create.pdf",
///                  }
///              }
///   The `buf` parameter represents the document in binary format.
///   Returns a Document entity 
exports.createDocument = function(_, properties, buf){
	return new Helper(_).write(_, properties, buf, null);
}

/// * `var document = sa.updateDocument(_, properties, buf, filter);`  
///   Update document in storage area.
///   The `properties` parameter represents document properties in JSON format :
///      ex: var properties = {
///                  description: "UPDATE",
///                  content: {
///                     contentType: "application/pdf",
///                     fileName: "update.pdf",
///                  }
///              }
///   The `buf` parameter represents the document in binary format.
///   The `filter` parameter represents filter selector :
///      ex: var filter = {
///                 jsonWhere:{
///                    $uuid: uuid
///                 }
///              }
///   Returns a Document entity.
exports.updateDocument = function(_, properties, buf, filter){
	return new Helper(_).write(_, properties, buf, filter);
}

/// * `var document = sa.removeDocument(_, filter);`  
///   Remove document from storage area.
///   The `filter` parameter represents filter selector :
///      ex: var filter = {
///                 jsonWhere:{
///                    $uuid: uuid
///                 }
///              }
///   Returns 1 if operation is successful else throw Error. 
exports.removeDocument = function(_, filter){
	return new Helper(_).remove(_, filter);
}

/// * `var dd = sa.openDocument(_, filter);`  
///   Open document from storage area or create a new instance.  
///   The `filter` parameter represents filter selector :
///      ex: var filter = {
///                 jsonWhere:{
///                    $uuid: uuid
///                 }
///              }
///   Returns a Document Descriptor.
exports.openDocument = function(_, filter){
	return new Helper(_).open(_, filter);
}

var Helper = helpers.defineClass(function(_) {
	// getting the administration ORM
	this.db = adminHelper.getCollaborationOrm(_);
	// the metamodel is associated to the orm
	this.model = this.db.model;
	this.entity = this.model.getEntity("document");
	this.factory = this.entity.factory;
}, null, {
	getDocumentInstance : function(_, filter){
		var document;
		if (filter != null){
			// fetchInstance(callback, entity, filter)
			document = this.db.fetchInstance(_, this.entity, filter);
		}else{
			// create a new object, createInstance params are : (callback, initialDataJson, ormInstance)
			document = this.factory.createInstance(_, null, this.db);
		}
		return document;
	},
	
	read : function(_, filter){

		// fetchInstance(callback, entity, filter)
		var document = this.db.fetchInstance(_, this.entity, filter);

		if (document == null) throw new Error("Document not found");
		var store = document.content(_);
		
		// read the binary content
		if (!store.fileExists(_)) throw new Error("File doesn't exist");
		// get file meta example
		var props = store.getProperties(_);
		
		store.readOpen(_);
		var buf;
		
		var test;
		while(buf = store.read(_, props.chunkSize)){
		
			test += buf.toString('binary');
		}
		ckeckDiagnoses(document);
		return document;
	},


	write : function(_, props, buf, filter){

		
		var document = this.getDocumentInstance(_, filter);
		
		Object.keys(props).forEach_(_, function(_,elt){
			if (elt !== 'content' && document[elt]){
				document[elt](_, props[elt]);
			}
		});
		
		if (buf != null && buf.length !== 0){
			var store = document.content(_);
			var props = props.content != null ? props.content : {};
			store.write(_, buf, props);	
			store.close(_);
		}
		document.save(_);
		ckeckDiagnoses(document);
		return document;
	},
	
	remove : function(_, filter){
		var document = this.db.fetchInstance(_, this.entity, filter);
		var res = document._db.deleteInstance(_, document);
		
		if (res !== 1)
			throw new Error("Document instance has not been deleted.");
		
		return res;
	},
	
	open : function(_, filter){
		
		var self = this;
		var StoWriter = helpers.defineClass(function(_, filter) {
			this.document = self.getDocumentInstance(_, filter);
			this.store = this.document.content(_);
			this.first = true;
		}, null, {
			
			/// * `dd.write(_, properties, stream);`  
			///   Write content of document instance.  
			///   The `properties` parameter represents document properties in JSON format :
			///      ex: var properties = {
			///                  description: "STREAM",
			///                  content: {
			///                     contentType: "application/pdf",
			///                     fileName: "stream.pdf",
			///                  }
			///              }
			///   The `stream` parameter represents a stream of the document in binary format.
			write : function(_, props, stream) {

				if (this.first){
					var that = this;
					Object.keys(props).forEach_(_, function(_,elt){
						if (elt !== 'content' && that.document[elt]){
							that.document[elt](_, props[elt]);
						}
					});
					props.content = props.content != null ? props.content : {};
					this.first = false;
				}else{
					props.content = {};
				}
				if (stream != null && stream.length !== 0){
					this.store.write(_, stream, props.content);	
				}
			},
			/// * `dd.close(_);`  
			///   Close the document store and persist the content in datastore.  
			///   Returns a Document entity.
			close : function(_) {
				this.store.close(_);
				this.document.save(_);
				ckeckDiagnoses(this.document);
				return this.document;
			}
		});
		

		return new StoWriter(_, filter);
	}
	

	
});


function ckeckDiagnoses(doc){
	var mess = '';
	Object.keys(doc.$).forEach(function(elt){
		if (doc.$[elt].$diagnoses != null && doc.$[elt].$diagnoses.length !== 0){
			doc.$[elt].$diagnoses.forEach(function(diag){
				mess += diag.severity + " : " + diag.message + "\n";
			});
		}
	});
	if (mess !== '')
		throw new Error(mess);	
}


