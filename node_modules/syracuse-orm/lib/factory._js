"use strict";

// TODO : centralized management of $init, apply on childrens too

var helpers = require("syracuse-core/lib/helpers");
var httpHelpers = require("syracuse-sdata/lib/httpHelper");
var forEachKey = helpers.object.forEachKey;
var types = require("syracuse-core/lib/types/allTypes");
var resourceHelpers = require("syracuse-core/lib/resource/util");
var flows = require("streamline/lib/util/flows");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var fileStoreFactory = require("./fileStoreFactory");
var locale = require("syracuse-core/lib/locale");
var parser = require('syracuse-sdata/lib/parser/parser');
var sys = require("util");

var config = {};

function getTopInstance(instance) {
	var parent = instance._parent || instance;
	while(parent._parent) { parent = parent._parent }
	return parent;
}

function _formatValue(prop, val) {
	return resourceHelpers.formatValue(prop, val);
}

function _getPropertiesResourceMeta(_, resource, instance) {
	function _internalGetMeta(_, key, prop) {
		if(prop.$isMandatory && (typeof prop.$isMandatory === "function")) {
			// conditional mandatory
			resource.$[key] = resource.$[key] || {};
			resource.$[key].$isMandatory = prop.$isMandatory(_, instance);
		}
		if(prop.$isHidden && (typeof prop.$isHidden === "function")) {
			// conditional mandatory
			resource.$[key] = resource.$[key] || {};
			resource.$[key].$isHidden = prop.$isHidden(_, instance);
		}
		if(prop.$isDefined && (typeof prop.$isDefined === "function")) {
			// conditional mandatory
			resource.$[key] = resource.$[key] || {};
			resource.$[key].$isHidden = !prop.$isDefined(_, instance);
		}
		if(prop.$isDisabled && (typeof prop.$isDisabled === "function")) {
			// conditional mandatory
			resource.$[key] = resource.$[key] || {};
			resource.$[key].$isDisabled = prop.$isDisabled(_, instance);
		}
	}
	resource.$ = resource.$ || {};
	flows.eachKey(_, instance._meta.$properties, function(_, key, property) {
		_internalGetMeta(_, key, property);
	});
	flows.eachKey(_, instance._meta.$relations, function(_, key, relation) {
		_internalGetMeta(_, key, relation);	
	});
}

function _makeLazyUrl(url, propName, segment) {
	var lazyUrl;
	if(url) {
		lazyUrl = url.split("?");
		lazyUrl[0] += (segment ? "/"+segment : "") + "/" + propName;
		lazyUrl = lazyUrl.join("?");
	} else
		lazyUrl = "{$baseUrl}/{$pluralType}('{$key}')" + (segment ? "/"+segment : "") + "/" + propName;
	return lazyUrl;
}

var _propTypeFormaterMap = {
	graph: function(property, instance) {
		return {
			$url: _makeLazyUrl(instance.$url, property.name, "$graphs"),
			$type: property.$type
		}
	},
	"tag-cloud": function(property, instance) {
		return {
			$url: _makeLazyUrl(instance.$url, property.name, "$tagClouds"),
			$type: property.$type
		}
	}
}

function _serializeExternalStorageProperty(_, instance, propName) {
	var key = propName;
	if(!instance[key](_)) return null;
	if(!instance[key](_).fileExists(_)) return null;
	var property = instance._meta.$properties[key];
	var storeProps = instance[key](_).getProperties(_) || {};
	return {
		$uuid: instance[key](_).getUuid(),
		$url: _makeLazyUrl(instance.$url, key),
		$type: property.$type,
		$contentType: storeProps.contentType,
		$fileName: storeProps.fileName,
		$length: storeProps.length
	}
}

function _serialize(_, instance, shallow) {
	if (!instance)
		return null;
	// particular case of pages
	config.tracer && config.tracer("factory._serialize enter: "+instance.$uuid);
	if (instance.serialize) {
		return instance.serialize(_);
	}
	if (instance._data && instance._data.serialize) {
		return instance._data.serialize(_);
	}
	// non persistent object might have this
	if (instance.$serialize) {
		config.tracer && config.tracer("factory._serialize exit: ($serialize)");
		return instance.$serialize(_);
	}
	//
	var meta = instance._meta;
	var resource = {
		$uuid: instance.$uuid,
		$key: instance.$key,
//		$trackingId: instance.$trackingId || instance.$uuid,
		$trackingId: instance.$trackingId,
		$url: instance.$url,
		$type: instance.$type,
		$etag: instance.$etag,
		$creUser: instance.$creUser,
		$creDate: instance.$creDate,
		$updUser: instance.$updUser,
		$updDate: instance.$updDate, 
		$: instance.$
	};
	if (instance.$diagnoses && instance.$diagnoses.length)
		resource.$diagnoses = instance.$diagnoses;
	//
	if(instance.hasOwnProperty("$index"))
		resource.$index = instance.$index;
	flows.eachKey(_, meta.$properties, function(_, key, property){
		config.tracer && config.tracer("factory._serialize property: "+key);
		if(property.isExternalStorage() && !(instance[key](_) && instance[key](_).fileExists(_)))
			return;
		if(property.$isLazy || property.isExternalStorage()) {
			resource[key] = _serializeExternalStorageProperty(_, instance, key);
		} else 
			resource[key] = (_propTypeFormaterMap[property.$type] && _propTypeFormaterMap[property.$type](property, instance)) || _formatValue(property, instance[key](_));
	});
	flows.eachKey(_, meta.$relations, function(_, key, relation){
		if(relation.isPlural && shallow) return;
		// no need to serialize the inverse of a child relation
		var inv = relation.$inv && relation.targetEntity.$relations[relation.$inv];
		if (inv && inv.isChild) return;
		config.tracer && config.tracer("factory._serialize relation: "+instance.$uuid+"."+key);
		var val = instance[key](_);
		if (relation.isPlural) {
			var collData = val.toArray(_).filter(function(elt){return !elt.$isDeleted});
			if(collData.length)
				resource[key] = collData.map_(_, 
					function(_, elt){
						//return _serialize(_, elt, (relation.isChild?"$details":"$thumb"));
						if (relation.$assoType)
							return _serialize(_, val.getAsso(_, elt.$uuid), false);
						else
							return _serialize(_, elt, !relation.isChild);
					});
		}
		else 
			resource[key] = val && _serialize(_, val, !relation.isChild);
	});
	//
	_getPropertiesResourceMeta(_, resource, instance);
	//
	config.tracer && config.tracer("factory._serialize exit: "+instance.$uuid+"-"+sys.inspect(resource));
	return resource;
}

function _applyDelta(_, instance, delta){
	instance._errorCount = 0;
	instance.$diagnoses = [];
	// in case of relations, we will set instances for every child relation
	config.tracer && config.tracer("factory._applyDelta input: "+sys.inspect(delta));
	flows.eachKey(_, delta, function(_, key, value){
		config.tracer && config.tracer("factory._applyDelta key: "+key);
		if (Array.isArray(value)) {
			var collection = instance[key](_);
			// delete missing
			var receivedUuids = (delta.$properties && delta.$properties[key] && delta.$properties[key].deleteMissing)?[]:null;
			value.forEach_(_, function(_, newElt){
				// check $uuid presence for references
				if(!collection._relMeta.isChild && !newElt.$uuid) {
					instance.$addError(locale.format(module, "referenceNotFound", collection._relMeta.name), collection._relMeta.name);
					return;
				}
				//
				receivedUuids && receivedUuids.push(newElt.$uuid);
				if (newElt.$isDeleted) {
					config.tracer && config.tracer("factory._applyDelta isDeleted: " + newElt.$uuid);
					collection.deleteInstance(_, newElt.$uuid);
				}
				else {
					var actualItem = collection.get(_, newElt.$uuid);
					if (!actualItem) 
						actualItem = collection.set(_, instance.createChild(_, key, newElt.$uuid));
					if(actualItem.$isDeleted)
						actualItem.$isDeleted = false;
					if (collection._relMeta.isChild) 
						_applyDelta(_, actualItem, newElt);
					// association class ?
					if (collection._relMeta.$assoType)
						_applyDelta(_, collection.getAsso(_, newElt.$uuid), newElt);
				}
			});
			// delete missing
			if(receivedUuids) {
				var collUuids = collection.toUuidArray(_);
				collUuids.forEach_(_, function(_, collEltUuid){
					if (receivedUuids.indexOf(collEltUuid) < 0) {
						config.tracer && config.tracer("factory._applyDelta isDeleted: " + collEltUuid);
						collection.deleteInstance(_, collEltUuid);
					}	
				});
			}
		} else {
			if (key[0] == '$') {
				instance[key] = value;
				// manage of "undefined" values
				if (key === "$")
					for (var d in delta.$)
						if (delta.$[d].$isUndefined)
							delete instance._data[d];
			}
			else {
				var rel = instance._meta.$relations && instance._meta.$relations[key];
//				if (instance._meta.$relations && instance._meta.$relations.hasOwnProperty(key)) {
				if (rel) {
					if (value) {
						if(rel.isChild) {
							// child "1" relation, apply delta if allready exists, set new instance otherwise 
							if (!instance[key](_)) 
								instance[key](_, instance.createChild(_, key, value.$uuid));
							_applyDelta(_, instance[key](_), value);
						}
						else {
							var relVal = instance[key](_);
							if(!relVal && !value.$uuid) {
								instance.$addError(locale.format(module, "referenceNotFound", rel.name), rel.name);
								return;
							}
							if(!relVal || (value.$uuid && (value.$uuid !== relVal.$uuid)))
								// reference change
								instance[key](_, instance.createChild(_, key, value.$uuid));
						}
					} else
						instance[key](_, null);
				}
				else 
					if (instance._meta.$properties && instance._meta.$properties.hasOwnProperty(key)) 
						instance[key](_, resourceHelpers.parseValue(instance._meta.$properties[key], value));
			}
		}
	});
	config.tracer && config.tracer("factory._applyDelta resulting instance data: "+sys.inspect(instance._data));
//	config.tracer && config.tracer("factory._applyDelta related inst: "+sys.inspect(instance.relatedInst));
}

function _cleanupDeleted(_, instance, shallow) {
	config.tracer && config.tracer("factory._cleanupDelete for instance: "+instance._meta.name+"."+instance.$uuid);
	if(!instance._meta.$relations) return;
	//
	flows.eachKey(_, instance._meta.$relations, function(_, key, rel) {
		if(instance._data[key])
			if(rel.isPlural) {
				// remove deleted instances
				if(instance._data[key]._data)
					flows.eachKey(_, instance._data[key]._data, function(_, elemKey, elemInst) {
						if(elemInst.$isDeleted) {
							config.tracer && config.tracer("factory._cleanupDelete removing: "+key+"."+elemKey);
							delete instance._data[key]._data[elemKey];
						} else
							if(!shallow || rel.isChild)
								_cleanupDeleted(_, elemInst, true);
					});
			} else
				if(!shallow)
					_cleanupDeleted(_, instance._data[key], true);
	});
}

function _cleanupExternalStorage(_, instance) {
	if(!instance.$snapshot) return;
	config.tracer && config.tracer("factory._cleanupExternalStorage for instance: "+instance._meta.name+"."+instance.$uuid);
	flows.eachKey(_, instance._propertyStores, function(_, key, store) {
		var oldFile = instance.$snapshot[key](_).getUuid();
		if(oldFile && (oldFile !== instance[key](_).getUuid())) {
			config.tracer && config.tracer("factory._cleanupExternalStorage deleting: "+oldFile);
			instance.$snapshot[key](_).deleteFile(_);
		}
	});
}

function _executeActions(_, context, instance) {
	config.tracer && config.tracer("factory._executeActions instance: "+instance._meta.name+"."+instance.$uuid+" - actions: "+sys.inspect(instance.$actions,null,3));
	// for each relation, scan if action isRequested
	flows.eachKey(_, instance._meta.$relations, function(_, key, rel) {
		var relInst = instance[key](_);
		if(!relInst || !rel.isChild) return;
		// recurse
		if (rel.isPlural) {
			var coll = relInst.toArray(_);
			coll.forEach_(_, function(_, item) {
				_executeActions(_, context, item);
			})
		} else
			_executeActions(_, context, relInst);
		// execute relation actions
		var acts = relInst.$actions || (instance.$[key] && instance.$[key].$actions);
		if (acts)
			flows.eachKey(_, acts, function(_, name, action) {
				// for the moment, save is managed differently
				if (action.$isRequested && (name !== "$save")) {
					if (name === "$create") {
						config.tracer && config.tracer("factory._executing "+name+".$create");
						if(action.$parameters && action.$parameters.$select) {
							action.$parameters.$select.forEach_(_, function(_, item) {
								var child = instance.createChild(_, key);
								if (rel.isPlural) 
									relInst.set(_, child);
								else
									instance[key](_, child);
								//
//								config.tracer && config.tracer("factory._executing "+name+".$create; setting "+rel.$select.$target+" on "+rel.targetEntity.name+"."+rel.targetEntity.$relations[rel.$select.$target].name);
								var fields = rel.$select.$fieldMap;
								fields && Object.keys(fields).forEach_(_, function(_, targetName) {
									if(rel.targetEntity.$relations[targetName]) {
										var inst = instance._db.fetchInstance(_, rel.targetEntity.$relations[targetName].targetEntity, item[fields[targetName]]);
										inst && child[targetName](_, inst);
									} else
										if(rel.targetEntity.$properties[targetName]) {
											item[fields[targetName]] && child[targetName](_, item[fields[targetName]]);
										}
								});
							});
						} else {
							var child = instance.createChild(_, key);
							if (rel.isPlural) 
								relInst.set(_, child);
							else
								instance[key](_, child);
						}
					}
					//
					delete action.$parameters;
					action.$isRequested = false;
				}
			});
	});
	// execute instance actions
	if (instance.$actions)
		flows.eachKey(_, instance.$actions, function(_, name, action) {
			// for the moment, save is managed differently
			if (action.$isRequested && (name !== "$save")) {
				config.tracer && config.tracer("factory._executing "+name);
				if (name === "$delete") {
					instance.$isDeleted = true;
				} else
					if (instance._meta.$services && instance._meta.$services[name])
						instance._meta.$services[name].$execute(_, context, instance);
				//
				action.$isRequested = false;
			}
		});
}

function _delta(oldObj, newObj){
	if (newObj && !oldObj) 
		return newObj;
	if (oldObj && !newObj) 
		return null;
	
	if (Array.isArray(oldObj)) {
		if (Array.isArray(newObj) && oldObj.length == newObj.length) {
			var arr = newObj.map(function(newElt, i){
				return _delta(oldObj[i], newElt);
			});
			if (arr.some(function(elt){
				return typeof elt !== "undefined";
			})) 
				return newObj; // will optimize later
			else 
				return;
		}
		return newObj;
	}
	else if (typeof oldObj === "object" && typeof newObj === "object") {
		var result;
		var keys = {}
		forEachKey(oldObj, function(key, oldVal){
			keys[key] = true;
			var diff = _delta(oldVal, newObj[key]);
			if (typeof diff !== "undefined") {
				result = result || {};
				result[key] = diff;
			}
		});
		forEachKey(newObj, function(key, newVal){
			if (!keys[key]) {
				result = result || {};
				result[key] = newVal;
			}
		})
		return result;	
	}
	else if (oldObj !== newObj) {
		return newObj;
	}
}

// async for computed values
// use snapshotType instead of snapshot as we can have snapshots for
// childrens w/o snapshot for main instance
function _computeDelta(_, instance, snapshotType, snapshotValue, fullLocale) {
	config.tracer && config.tracer("factory.computeDelta: "+instance.$uuid);
	var snapshot = snapshotValue || instance[snapshotType];
	var meta = instance._meta;
	var delta = {};
	var delta$ = {};
	if (snapshot) {
		flows.eachKey(_, meta.$properties, function(_, key, property) {
			var newVal = _formatValue(property, ((property.$isLocalized && !fullLocale) || property.$compute) ? instance[key](_) : instance._data[key]);
			var oldVal = _formatValue(property, ((property.$isLocalized && !fullLocale) || property.$compute) ? snapshot[key](_) : snapshot._data[key]);
			// TEMP, TODO proper management of snapshots on external stored props
			config.tracer && config.tracer("factory.compute delta on property: "+key+"; oldVal: "+sys.inspect(oldVal)+"; newVal: "+sys.inspect(newVal));
			if (property.isExternalStorage()) {
//				if(instance[key](_) && instance[key](_).invalid) {
				if(instance[key](_)) {
//					delta[key] = _serializeExternalStorageProperty(_, instance, key);
					var d = _delta(oldVal, newVal);
					if(d) delta[key] = d;
				}
			} else {
				// new data has a value (may be null) and oldVal is different or not set
				if (property.$isLocalized && fullLocale) {
					var locDelta = _delta(oldVal, newVal);
					if(locDelta) delta[key] = locDelta;
				} else
					if ((instance._data.hasOwnProperty(key) || property.$compute) && ((newVal != oldVal) || !snapshot._data.hasOwnProperty(key))) 
						delta[key] = newVal;
			}
			// meta
			var newMeta = instance.$[key];
			var oldMeta = snapshot.$[key];
			delta$[key] = _delta(oldMeta, newMeta);
		});
		if(instance.hasOwnProperty("$index"))
			if(instance.$index != snapshot.$index)
				delta.$index = instance.$index;
	}
	// compute delta on relations even if no snapshot provided for the main instance 
	flows.eachKey(_, meta.$relations, function(_, key, relation){
		// TODO : there seems to be a problem as we have deltas on relations even if there is no difference
		config.tracer && config.tracer("factory.compute delta on relation: "+key+"; $assoType:"+relation.$assoType);
		if (relation.isPlural) {
//			var newColl = (relation.$assoType?instance[key](_)._asso:instance[key](_)._data); 
			var newColl = instance[key](_).toArray(_); 
			var oldColl = (snapshot && (relation.$assoType?snapshot[key](_)._asso:snapshot[key](_)._data));
//			var oldColl = (snapshot && snapshot[key](_));
			var deltaColl = [];
			newColl.forEach_(_, function(_, newElt) {
				var newId = newElt.$uuid;
				if (newElt.$isDeleted) 
					deltaColl.push({$uuid: newId,$isDeleted: true});
				else {
					var oldElt = oldColl && oldColl[newId];
					oldElt = (oldElt && (oldElt[snapshotType] || oldElt)) || newElt[snapshotType];
					if (relation.isChild || relation.$assoType) 
						deltaColl.push(_computeDelta(_, newElt, snapshotType, oldElt, fullLocale));
					else 
						if (newElt && ((oldElt && (newElt.$uuid != oldElt.$uuid)) || !oldElt)) 
							deltaColl.push(_serialize(_,newElt, true));
				}
			});
			if (deltaColl.length)
				delta[key] = deltaColl;
		} else {
			var newVal = instance._data[key];
			if (newVal) {
				var oldVal = ((snapshot && snapshot._data[key]) || newVal[snapshotType]);
				if(relation.isChild) {
					var d = _computeDelta(_, newVal, snapshotType, oldVal, fullLocale);
					if (d !== {}) delta[key] = d;
				} else
					if(newVal.$uuid != (oldVal && oldVal.$uuid))
						// send serialization of thumb, not just an uuid
						delta[key] = _serialize(_,newVal, true);
						// delta[key] = {$uuid:newVal.$uuid};
			} else
				if((snapshot && snapshot._data.hasOwnProperty(key) && snapshot._data[key]) || (snapshot && !snapshot._data.hasOwnProperty(key)) || !snapshot)
					delta[key] = null;
		}
		var newMeta = instance.$[key];
		var oldMeta = snapshot && snapshot.$[key];
		delta$[key] = _delta(oldMeta, newMeta);
	});
	//
	if (delta$ !== {})
		delta.$ = delta$;
	if (delta !== {}) {	
		delta.$url = instance.$url;
		delta.$key = instance.$key;
		delta.$uuid = instance.$uuid;
		delta.$type = instance.$type;
		delta.$etag = instance.$etag;
		delta.$creUser = instance.$creUser;
		delta.$creDate = instance.$creDate;
		delta.$updUser = instance.$updUser;
		delta.$updDate = instance.$updDate; 
		delta.$isDelta = true;
	}
	if (instance.$diagnoses && instance.$diagnoses.length)
		delta.$diagnoses = instance.$diagnoses;
	//	
	_getPropertiesResourceMeta(_, delta, instance);
	//
	config.tracer && config.tracer("factory.computeDelta exit: "+instance.$uuid+"; "+sys.inspect(delta));
	return delta;
}

function _errorCount(instance){
	return (Object.keys(instance.$).reduce(function(prev, current) {
		return prev +  (instance.$[current].$diagnoses || []).filter(function(diag){
			return diag.severity == "error" || diag.severity == "fatal";
		}).length;
	}, 0)) +  (instance.$diagnoses || []).filter(function(diag){
		return diag.severity == "error" || diag.severity == "fatal";
	}).length;
}

function _existsError(_, instance){
	if ((instance.$diagnoses || []).some(function(diag){
		return diag.severity == "error" || diag.severity == "fatal";
	}))
		return true;
	//
	var hasErr = false;
	if (instance.$)
		flows.eachKey(_, instance.$, function(_, key, item) {
			hasErr = hasErr || ((item && item.$diagnoses) || []).some(function(diag){
				return diag.severity == "error" || diag.severity == "fatal";
			});
		})
	if (hasErr)
		return true;
	// recurse relations
	flows.eachKey(_, (instance._meta.$relations || {}), function(_, key, rel) {
		if (rel.isChild)
			if (rel.isPlural) {
				instance[key](_).toArray(_).forEach_(_, function (_, item) {
					hasErr = hasErr || _existsError(_, item);
				});
			} else
				hasErr = hasErr || (instance[key](_) && _existsError(_, instance[key](_)));
	});
	if (hasErr)
		return true;
	//
	return false;
}

function _safeCall(_, instance, propName, fn, field, val){
	if (!instance[field]) {
		instance[field] = [];
	}
	else {
		if (instance[field].indexOf(propName) >= 0) 
			throw new Error(field.substring(1) + " loop on " + propName);
	}
	instance[field].push(propName);
	try {
		return fn(_, instance, val);
	}
	finally {
		instance[field].pop();
	}
}

function _fireOnDelete(_, instance) {
	flows.eachKey(_, instance._meta.$relations, function(_, relName, rel) {
		if(rel.isChild && rel.targetEntity.$functions && rel.targetEntity.$functions.$onDelete) {
			var relInst = instance[relName](_);
			if(!relInst) return;
			if(rel.isPlural) 
				relInst.toArray(_, false).forEach_(_, function(_, item) {
					item.$isDeleted && item.$onDelete && item.$onDelete(_);
				})
			else
				relInst.$isDeleted && relInst$onDelete && relInst.$onDelete(_);
		}
	});
	instance.$onDelete && instance.$onDelete(_);
}

function _validateRelation(_, instance, relation, name, value) {
	if(relation.$compute)
		return true;
	if (instance.$validated[name])
		return true;
	//
	instance.$validated[name] = true;
	//
	config.tracer && config.tracer("factory._validateRelation enter: "+name+":"+relation.name);
	//
	var mandatory = relation.$isMandatory;
	if(typeof mandatory === "function")
		mandatory = mandatory(_, instance);
	if(mandatory)
		if(!value)
			instance.$addError(name + " is mandatory", name);
}
function _validateProperty(_, instance, property, name, value) {
	if (property.$compute)
		return true;
	if (instance.$validated[name])
		return true;
	//
	instance.$validated[name] = true;
	//
	config.tracer && config.tracer("factory._validateProperty enter: "+name+":"+property.name);
	//
//	var value = instance[name](_);
	var type = types[(property.type || "string")];
	if (type) {
		var errors = [];
		var c = property.getAllConstraints();
		if(c.$isMandatory && (typeof c.$isMandatory === "function"))
			c.$isMandatory = c.$isMandatory(_, instance);
		if(c.$isDefined && (typeof c.$isDefined === "function"))
			c.$isNullable = c.$isNullable || !c.$isDefined(_, instance);
		type.validate(value, c, errors);
		if (errors.length) {
			config.tracer && config.tracer("factory._validateProperty errors: "+sys.inspect(errors));
			errors.forEach(function(error) {
				// crnit:extended error message is needed for import; TODO: as error is associated with property meta, 
				// leave simple error message but correctly extract it for import
//				instance.$addError(instance._meta.name+"."+property.name+":"+error, property.name);
				instance.$addError(error, property.name);
			});
			return false;
		} 	
	}
	// unique validate, not for childrens where the validation must be done for the childrens list of the parent
	if (!instance._parent && property.$constraints && property.$constraints.$isUnique) {
		var filter = {jsonWhere:{}};
		if(property.$isLocalized)
			filter.jsonWhere[property.name+"."+locale.current] = value;
		else	
			filter.jsonWhere[property.name] = value;
		filter.jsonWhere.$uuid = {$ne:instance.$uuid};
		var testInstance = instance._db.fetchInstance(_, instance._meta, filter);
		if (testInstance) {
			instance.$addError(instance._meta.name+" "+property.name+" must be unique ("+value+")", property.name);
			return false;
		}
	}
	//
	return true;
}
// check mandatory props
function _validateMandatory(_, instance){
	config.tracer && config.tracer("factory._validateMandatory: "+instance._meta.name);
	flows.eachKey(_, instance._meta.$properties, function(_, name, property) {
		_validateProperty(_, instance, property, name, instance[name](_));
	});
	flows.eachKey(_, instance._meta.$relations, function(_, name, relation) {
		var mandatory = relation.$isMandatory;
		if(typeof mandatory === "function")
			mandatory = mandatory(_, instance);
		if (mandatory || relation.isChild) {
			var relValue = instance[name](_);
			if (mandatory) {
				if ((relation.isPlural && relValue.isEmpty()) || (relValue == null)) 
					instance.$addError(name + " is mandatory", name);
			}
			if(relation.isChild && relValue) {
				if (relation.isPlural) {
					var values = relValue.toArray(_);
					values.forEach_(_, function(_, value){
						_validateMandatory(_, value);
						instance._errorCount += value._errorCount;
					});
				}
				else {
					_validateMandatory(_, relValue);
					instance._errorCount += relValue._errorCount;
				}					
			}
		}			 
	});
}

function _clone(obj){
	var result = {};
	forEachKey(obj, function(key, val){
		if (Array.isArray(val)) 
			result[key] = val.map(function(elt){
				return _clone(elt)
			});
		else if (val != null && typeof val === "object") 
			result[key] = _clone(val);
		else 
			result[key] = val;
	});
	return result;
}

function Factory(meta){
	// wrapper to generic stream implementation
	function PropertyStore(instance, property) {
		this.instance = instance;
		this.property = property;
		// needs refreshing on compute delta. Normaly updated on propagate. Cleared by compute delta
		this.invalid = false;
		// create the proper factory
		var storageType = property.$storage && ((typeof property.$storage === "function") ? property.$storage(instance) : property.$storage);
		this._store = storageType && fileStoreFactory.createFileStore(instance, property, storageType);
	}
	var streamerProto = PropertyStore.prototype;
	streamerProto.getUuid = function() {
		return this._store && this._store.fileName;
	}
	streamerProto.getProperties = function(_) {
		return this._store.getProperties(_);
	}
	streamerProto.fileExists = function(_) {
		return this._store.fileExists(_);
	}
	// creates a new file for storage, to use for two phase update: when using a workingCopy, one must avoir persist changes of the file
	// before invoke "Save" on the object. So we should create a new file for update, then "Save" will persist object's pointer to the new file.
	streamerProto.createWorkingCopy = function(_) {
		var instance = this.instance;
		// allready in working copy ?
		if (instance._snapshotEnabled && instance.$snapshot) return;
		if (instance._sysSnapshotEnabled && instance.$sysSnapshot) return;
		// create snapshot
		if (instance._snapshotEnabled && !instance.$snapshot) 
			instance.$snapshot = _createSnapshot(_, instance, "$snapshot");
		if (instance._sysSnapshotEnabled && !instance.$sysSnapshot) 
			instance.$sysSnapshot = _createSnapshot(_, instance, "$sysSnapshot");
		//
		instance._data[this.property.name] = {$uuid:""};
		this._store.setFile(_, "");
	}
	streamerProto.readOpen = function(_) {
		return this._store.readOpen(_);
	}
	streamerProto.read = function(_, len) {
		return this._store.read(_, len);
	}
	streamerProto.readAll = function(_) {
		return this._store.readAll(_);
	}
	streamerProto.write = function(_, data, options) {
		var instance = this.instance;
		if (instance._snapshotEnabled && !instance.$snapshot) 
			instance.$snapshot = _createSnapshot(_, instance, "$snapshot");
		if (instance._sysSnapshotEnabled && !instance.$sysSnapshot) 
			instance.$sysSnapshot = _createSnapshot(_, instance, "$sysSnapshot");
		var opt = options || {};
		opt.referingInstance = {className: this.instance._meta.name, property: this.property.name, uuid: this.instance.$uuid};
		//
		if(!this._store.fileName) {
			this._store.setFile(_, (instance._data[this.property.name] = {$uuid:helpers.uuid.generate()}).$uuid);
			config.tracer && config.tracer("propertyStore.createFile: "+this._store.fileName+" check property uuid: "+instance._data[this.property.name].$uuid);
		}
		this._store.write(_, data, opt);
	}
	streamerProto.deleteFile = function(_) {
		this._store.deleteFile(_);
	}
	streamerProto.close = function(_) {
		this._store.close(_);
	}
	// Collections prototype
	function InstanceCollection(instance, name, relMeta, value) {
		this._data = {};
		this._asso = {};
		this._relName = name;
		this._relMeta = relMeta;
		this._parent = instance;
		// loaded allows lazyLoad of computed relations (association use case when list is loaded by querying opposite table)
		this.loaded = !relMeta.isComputed;
		//
		var self = this;
		if (Array.isArray(value)) 
			value.forEach(function(elt){
				self._data[elt.$uuid] = instance.syncCreateChild(self._relMeta.name, elt.$uuid, elt);
			});
		else 
			for (var key in value) {
				if((key[0] != "$") && (key[0] != "_")) {
					self._data[key] = instance.syncCreateChild(self._relMeta.name, key, relMeta.isChild?value[key]:null);
					if (relMeta.$assoType)
						self._asso[key] = instance.syncCreateChild(self._relMeta.name, key, value[key], true);
				}
			}
	}
	//
	function _createParentSnapshot(_, collection) {
		var parent = collection._parent;		
		if (parent._snapshotEnabled && !parent.$snapshot) 
			parent.$snapshot = _createSnapshot(_, parent, "$snapshot");
		if (parent._sysSnapshotEnabled && !parent.$sysSnapshot) 
			parent.$sysSnapshot = _createSnapshot(_, parent, "$sysSnapshot");
		config.tracer && config.tracer("factory.collection createParentSnapshot exit");
	}
	function _computeCollection(_, collection) {
		if (collection._parent && collection._parent.$uuid) {
			var filter = {};
			filter[collection._relMeta.$inv + (collection._relMeta.targetEntity.$relations[collection._relMeta.$inv].isPlural?".$keys":".$uuid")] = collection._parent.$uuid;
			config.tracer && config.tracer("factory.collection fetchOpposite: parent:" + collection._parent.$uuid);
			var instArray = collection._parent._db.fetchInstances(_, collection._relMeta.targetEntity, {jsonWhere: filter});
			instArray.forEach(function(inst){	
				collection._data[inst.$uuid] = inst;
			});
			collection.loaded = true;
		}
	}
	//	
	var _collProto = InstanceCollection.prototype;
	// return an array of elements or an array of snapshots if the parent is an snapshot
	_collProto.toArray = function(_, excludeDeleted) { 
		var self = this;
		var result = [];
		flows.eachKey(_, self._data, function(_, key, value){
			if(!excludeDeleted || (excludeDeleted && !value.$isDeleted))
				result.push(self.get(_, key));
		});
		result.sort(function(a,b) {
			// for now only supports properties, 
			// TODO : implement proper typed comparaison
			// TODO : ascending / descending 
			if(self._relMeta.defaultOrder && self._relMeta.defaultOrder.length)
				return self._relMeta.defaultOrder.reduce(function(prevValue, value) {
					if(prevValue) return prevValue;
					if(a._data[value[0]] < b._data[value[0]]) return -1;
					if(a._data[value[0]] > b._data[value[0]]) return 1;
					return 0;
				},0);
			else
				return ((a.$index || 0) - (b.$index || 0));
		});
		config.tracer && config.tracer("factory._toArray() result: "+sys.inspect(result));
		return result; 
	}
	// return an array of uuids
	_collProto.toUuidArray = function(_, excludeDeleted) { 
		var self = this;
		var result = [];
		flows.eachKey(_, self._data, function(_, key, value){
			if(!excludeDeleted || (excludeDeleted && !value.$isDeleted))
				result.push(key);
		});
		return result; 
	}
	_collProto.deleteInstance = function(_, instanceId) {
		if(!instanceId)
			return;
		// create a snapshot for the parent
		config.tracer && config.tracer("factory.collection deleteInstance; _parent: "+this._parent.$uuid+" $uuid: "+instanceId);
		_createParentSnapshot(_, this);
		// if delete on computed relation, make the delete to the opposite side
		var relInst = this.get(_, instanceId);
		if(relInst) {
			if(this._relMeta.isComputed) {
				config.tracer && config.tracer("factory.collection deleteInstance on computed relation: "+this._relName);
				relInst._snapshotEnabled = true;
				relInst._sysSnapshotEnabled = true;
				if(relInst._meta.$relations[this._relMeta.$inv].isPlural)
					relInst[this._relMeta.$inv](_).deleteInstance(_, this._parent.$uuid);
				else
					relInst[this._relMeta.$inv](_, null);
				this._parent.addRelatedInstance(relInst);
			} 
			//
			relInst.$isDeleted = true;
		} 
		//
		config.tracer && config.tracer("factory.collection deleteInstance exit ; _parent: "+this._parent.$uuid+" $uuid: "+instanceId);
	}
	_collProto.reset = function(_) { 
		// create a snapshot for the parent
		_createParentSnapshot(_, this);
		//
		this._data = {}; 
	}
	_collProto.get = function(_, uuid) {
		if(!uuid)
			return null;
		var relation = this._relMeta;
		var val = this._data[uuid];
		var val = this._parent._snapshotType?(val[this._parent._snapshotType] || _createSnapshot(_, val, this._parent._snapshotType)) : val;
		// lazy load associations 
		if (!relation.isChild && val && !val.$isDeleted) {
			val.ensureLoaded(_);
		}
		//
		config.tracer && config.tracer("factory.collection.get: "+uuid+"; "+(val && val.$inspect && val.$inspect(true)));
		return val;
	}
	_collProto.getAsso = function(_, uuid) {
		if(!uuid || !this._relMeta.$assoType)
			return null;
		var relation = this._relMeta;
		var val;
		if (relation.isComputed) {
			// get the opposite instance
			val = this.get(_, uuid);
			// get the association from the opposite instance
			if (val) val = val[this._relMeta.$inv](_).getAsso(_, this._parent.$uuid);
		} else {
			val = this._asso[uuid];
			val = this._parent._snapshotType?(val[this._parent._snapshotType] || _createSnapshot(_, val,this._parent._snapshotType)):val;
		}
		//
		config.tracer && config.tracer("factory.collection.getAsso: "+uuid+"; "+(val && val.$inspect && val.$inspect(true)));
		return val;
	}
	// isInverse : called from the inverse relation set, so don't propagate 	
	_collProto.set = function(_, value, isInverse) {
		if(!value) 
			throw Error("Cannot set an undefined value for a collection; use deleteInstance instead.");
		config.tracer && config.tracer("factory.collection.set: value: "+value.$inspect(true)+"; isInverse:"+sys.inspect(isInverse));
		// create a snapshot for the parent
		_createParentSnapshot(_, this);
		//
		this._data[value.$uuid] = value;
		// create association instance
		if (!this._relMeta.isComputed && this._relMeta.$assoType && !this._asso[value.$uuid]) {
			var ass = this._asso[value.$uuid] = this._parent.createChild(_, this._relMeta.name, value.$uuid, null, true);
			ass[this._relMeta.$assoInv](_, this._parent);
			var oppositeName = this._relMeta.targetEntity.$relations[this._relMeta.$inv] && this._relMeta.targetEntity.$relations[this._relMeta.$inv].$assoInv;
			if (oppositeName)
				ass[oppositeName](_, value);
		}
		//
		if (!isInverse && this._relMeta.$inv && value._meta.$relations[this._relMeta.$inv]) {
			config.tracer && config.tracer("factory.collection.set inverse relation");
			// set inverse relation
			if (value._meta.$relations[this._relMeta.$inv].isPlural) {
				// create the inverse relation if *-*
				// use the getter to lazy load
				this.get(_, value.$uuid)[this._relMeta.$inv](_).set(_, this._parent, true);
			}
			else
				this.get(_, value.$uuid)[this._relMeta.$inv](_, this._parent, true);
			// to persist
			if (!this._relMeta.isChild && !value._meta.$relations[this._relMeta.$inv].isComputed)
				this._parent.addRelatedInstance(value);
		}
		if (this._relMeta.$propagate) {
			var svPropagate = this._relMeta.$propagate;
			this._relMeta.$propagate = null;
			_safeCall(_, this._parent, this._relMeta.name, svPropagate, "_propagating", value);
			this._relMeta.$propagate = svPropagate;
		}
		// allow chaining
		return value;
	}
	_collProto.setArray = function(_, values) {
		this.reset(_);
		//
		var self = this;
		if(typeof values === "object") {
			values.$items.forEach_(_, function(_, item) {
				var searchParam = {jsonWhere:{}};
				searchParam.jsonWhere[values.$key] = item;
				var inst = self._parent._db.fetchInstance(_, self._relMeta.targetEntity, searchParam);
				if(!inst) throw new Error(self._relMeta.targetEntity.name+" "+item+" not found");
				self.set(_, inst);
			});
		} else
			throw new Error("collection.setArray of instances NIY");
	}
	_collProto.filter = function(_, options) {
		var self = this;
		var result = [];
		//
		if(!options || !options.jsonWhere) return this.toArray(_);
		//
		var filter = options.jsonWhere;
		config.tracer && config.tracer("factory.collection.filter processed filter: "+sys.inspect(filter));
		flows.eachKey(_, self._data, function(_, key, value){
			var inst = self.get(_, key);
			// filter instance
			var add = true;
			flows.eachKey(_, filter, function(_, filterKey, filterValue) {
				var tempInst = inst;
				// TODO: optimize - take the filterItem compute out of the main loop
				var filterItem = filterKey.split(".");
				var term;
				while(term = filterItem.shift()) {
					if(!tempInst) break;
					config.tracer && config.tracer("factory.collection.filter testing term: "+term+" on "+tempInst.$uuid);
					if(tempInst._meta.$properties[term]) {
						// is final prop
						if(tempInst._meta.$properties[term].$isLocalized) {
							var loc = filterItem.shift();
							add = add && ((loc ? _getLocalizedProp(_, tempInst, term, tempInst._meta.$properties[term], loc) : tempInst[term](_)) === filterValue);
						} else
							add = add && (tempInst[term](_) === filterValue);
						break;
					} else
						if(tempInst._meta.$relations[term] && !tempInst._meta.$relations[term].isPlural) {
							// walk
							tempInst = tempInst[term](_);
						}
				}
			});
			config.tracer && config.tracer("factory.collection.filter testing: "+sys.inspect(filter)+" on "+inst.$uuid+"="+add);
			if(add) result.push(inst);
		});
		return result;
	}
	_collProto.isEmpty = function() {
		return (Object.keys(this._data).length == 0);
	}
	_collProto.getLength = function(){
		return Object.keys(this._data).length;
	}
	// instance prototype
	function Instance(data, $, connection, context){
//		config.tracer && config.tracer("factory.Instance().connection:"+sys.inspect(connection));
		this._propagateTick = 0;
		this.$etag = 1;
		// _meta is entity here
		this._meta = meta;
		// functions bind
		this._errorCount = 0;
		this.$ = $ || {};
		// property to avoid multiple validation
		this.$validated = {};
		//
		this._data = {};
		this._propertyStores = {};
		// database connection, usefull for lazy loads
		this._db = connection;
		this._context = context;
		// other instances to persist with the main instance
		this.relatedInst = {};
		//
		var self = this;
		//
		forEachKey(meta.$functions, function(name, fn) {
			self[name] = fn.bind(self); // can bind it
		});
		forEachKey(meta.$methods, function(name, fn) {
			self.prototype[name] = fn; // natural usage will bind it
		});
		// should replace with _load but is async. So remove this lateras we won't pass data anymore
		if(data) {
			forEachKey(data, function(key,value) {
				if (value && Array.isArray(value)) {
					self._data[key] = new InstanceCollection(self, key, meta.$relations[key], value);
				}
				else 
					if (value && meta.$relations && meta.$relations.hasOwnProperty(key)) {
						if (meta.$relations[key].isPlural) 
							self._data[key] = new InstanceCollection(self, key, meta.$relations[key], value);
						else 
							// check null relation
							if (!(value && value.$uuid))
								self._data[key] = null;
							else 
								self._data[key] = self.syncCreateChild(key, value.$uuid, value);
					}
					else {
						if (key[0] === "$") 
							self[key] = value;
						else {
							if(meta.$properties && meta.$properties[key]) {
								if(meta.$properties[key].isExternalStorage()) {
									// compat, change of storage format
									if(typeof value === "string")
										self._data[key] = {$uuid: value}
									else
										self._data[key] = value;
								} else
									self._data[key] = resourceHelpers.parseValue(meta.$properties[key], value);
							} else
								self._data[key] = value;
						}
					}
			});
			self.$initialUpdDate = this.$updDate;
			self.$updUser = this.$updUser || this.$creUser;
		}
		//
		this.$key = this.$uuid;
//		self.$initialUpdDate = this.$updDate;
//		self.$updUser = this.$updUser || this.$creUser;
		//
		this._snapshotEnabled = true;
		this._sysSnapshotEnabled = true;
	}
	var _proto = Instance.prototype;
			
	_proto._load = function(_, data) {
		var self = this;
		var meta = this._meta;
		//
		forEachKey(data, function(key, value) {
			if (value && Array.isArray(value)) {
				self._data[key] = new InstanceCollection(self, key, meta.$relations[key], value);
			}
			else 
				if (value && meta.$relations && meta.$relations.hasOwnProperty(key)) {
					if (meta.$relations[key].isPlural) 
						self._data[key] = new InstanceCollection(self, key, meta.$relations[key], value);
					else 
						// check null relation
						if (!(value && value.$uuid))
							self._data[key] = null;
						else 
							self._data[key] = self.syncCreateChild(key, value.$uuid, value);
				}
				else {
					if (key[0] === "$") 
						self[key] = value;
					else {
						if(meta.$properties && meta.$properties[key]) {
							if(meta.$properties[key].isExternalStorage()) {
								// compat, change of storage format
								if(typeof value === "string")
									self._data[key] = {$uuid: value}
								else
									self._data[key] = value;
							} else
								self._data[key] = resourceHelpers.parseValue(meta.$properties[key], value);
						} else
							self._data[key] = value;
					}
				}
		});
		//
		self.$initialUpdDate = this.$updDate;
		self.$updUser = this.$updUser || this.$creUser;
		//
		return self;
	}
	
	function _createSnapshot(_, instance, type) {
		// allready a snapshot
		if(instance._snapshotType || !instance.$uuid) return;
		//
		config.tracer && config.tracer("factory._createSnapshot: $uuid: "+instance.$uuid);
		//
		instance.lockInstance(_);
		//
		var data = instance._data;
		var copy = {};
		forEachKey(instance._meta.$properties, function(name, prop){
			var v = data[name];
			if (v != null) {
				if (Array.isArray(v)) 
					v = v.slice(0);
				if(prop.$isLocalized || prop.isExternalStorage())
//				if(typeof v === "object")
					copy[name] = _clone(v);
				else
					// use formatValue as passes through the same code that treats database data
					copy[name] = _formatValue(prop, v);
			}
		});
//		var snapshot = new Instance(copy, _clone(instance.$), instance._db, instance._context);
		var snapshot = (new Factory(instance._meta)).createInstance(_, copy, instance._db, instance._context);
		// relations
		flows.eachKey(_, instance._meta.$relations, function(_, name, prop){
			var v = data[name];
			if (v != null) {
				if (prop.isPlural) {
					var coll = snapshot[name](_);
					// for collections, create a snapshot collections pointing to the org. collection elements 
					flows.eachKey(_, v._data, function(_, uuid, elt){
						coll._data[uuid] = elt;
					});
				}
				else 
					// snapshot continues to point to the same instance of the relation. This should be right as 
					// the instance has her own snapshot in case of modification
					// direct copy as _setRel might trigger rules
//					snapshot[name](_, v);
					snapshot._data[name] = v;
			}
		});
		snapshot._snapshotType = type;
		config.tracer && config.tracer("factory._createSnapshot exit: $uuid: "+instance.$uuid);
		return snapshot;
	}
	
	// run validations before save
	function _validateBeforeSave(_, instance) {
		config.tracer && config.tracer("factory._validateBeforeSave: "+instance._meta.name);
		// revalidate all props as they might never been set
		flows.eachKey(_, instance._meta.$properties, function(_, name, property) {
			_validateProperty(_, instance, property, name, instance[name](_));
		});
		//
		flows.eachKey(_, instance._meta.$relations, function(_, name, relation) {
			var mandatory = relation.$isMandatory;
			if(typeof mandatory === "function")
				mandatory = mandatory(_, instance);
			if (mandatory || relation.isChild) {
				var relValue = instance[name](_);
				if (mandatory) {
					if ((relation.isPlural && relValue.isEmpty()) || (relValue == null)) 
						instance.$addError(name + " is mandatory", name);
				}
				if(relation.isChild && relValue) {
					if (relation.isPlural) {
						var values = relValue.toArray(_);
						values.forEach_(_, function(_, value){
							_validateBeforeSave(_, value);
							instance._errorCount += value._errorCount;
						});
					}
					else {
						_validateBeforeSave(_, relValue);
						instance._errorCount += relValue._errorCount;
					}					
				}
			}			 
		});
		// control rule 
		if(instance._meta.$control)
			instance._meta.$control(_, instance);
		//
		flows.eachKey(_, instance.relatedInst, function(_, key, value) {
			_validateBeforeSave(_, value);
			if(value._errorCount)
				instance.$addError("Related instance error: "+value.$uuid);
		});
		//
		if(instance._errorCount)
			config.tracer && config.tracer("factory._validateBeforSave errors: " + sys.inspect(instance.$));
		config.tracer && config.tracer("factory._validateBeforeSave exit: "+instance._meta.name);
	}
	// getters ****************************************************
	function _getExternalStorageProp(_, instance, name, property) {
		// getter
		var val = instance._propertyStores[property.name] || (instance._propertyStores[property.name] = new PropertyStore(instance, property));
		//
		config.tracer && config.tracer("factory._getExternalStorageProp("+name+")="+val);
		return val;
	}
	function _getLocalizedProp(_, instance, name, property, localeCode) {
		// getter
		var val = instance._data[name] && (instance._data[name][localeCode || locale.current] || instance._data[name]["default"]);
		if (instance._snapshotType && val)
			val = val[instance._snapshotType] || val;
		//
		config.tracer && config.tracer("factory._getLocalizedProp("+name+")="+val);
		return val;
	}
	function _getProp(_, instance, name, property) {
		// getter
		var val = instance._data[name];
		if (instance._snapshotType && val)
			val = val[instance._snapshotType] || val;
		//
		config.tracer && config.tracer("factory._getProp("+name+")="+val);
		return val;
	}
	function _getRel(_, instance, name, relation){
		config.tracer && config.tracer("factory._getRel enter: "+instance.$uuid+"."+name);
		// getter
		if (relation.$compute) 
			return _safeCall(_, instance, relation.name, relation.$compute, "_computing");
		if (relation.isPlural) {
			// returns InstanceCollection, not an array
			if (!instance._data[name]) 
				instance._data[name] = new InstanceCollection(instance, name, relation);
			// lazy loads collection
			if (!instance._data[name].loaded) 
				_computeCollection(_, instance._data[name]);
				config.tracer && config.tracer("factory._getRel collection: "+name+";"+
					sys.inspect(Object.keys(instance._data[name]._data).map(
						function(key){
							var item = instance._data[name]._data[key];
							return {$uuid:item.$uuid, $loaded: item.$loaded}
						}
					)));
			return instance._data[name];
		}
		else {
			var val = instance._data[name];
			if (instance._snapshotType && val) {
				val = val[instance._snapshotType] || val
				// on get, if is child, create a snapshot in case someone gets a pointer
				if (relation.isChild)
					_createSnapshot(_, val, instance._snapshotType);
			}
			// lazy load associations 
			if (!relation.isChild && val && val.$uuid && !val.$loaded) {
				val.ensureLoaded(_);
			}
			config.tracer && config.tracer("factory._getRel: "+name+";"+(val && val.$inspect && val.$inspect(true)));
			return val;
		}
	}
	// setters *********************************************************
	// set value
	function _prepareSetValue(_, instance, name, property, val, validateFunction) {
		if (instance._controlling && instance._controlling != property.name) {
			throw new Error("invalid attempt to assign " + property.name +
			" while controlling " +
			instance._controlling);
		}
		//
		var oldVal = instance._data[name];
		// allow setting null values
		if (instance._data.hasOwnProperty(name) && (oldVal === val)) 
			return false;
		// control (before setting new value)
		// TODO: doesn't work, see later
/*		instance._controlling = property.name;
		try {
			var errCount = _errorCount(instance);
			console.log("initial error count: "+errCount)
			// validation
			if (instance._meta.$properties[name])
				validateFunction(_, instance, property, name, val);
			console.log("after error count: "+_errorCount(instance));
			console.log("diags: "+sys.inspect(instance.$[name]));
			// control rule
			if (property.$control) 
				property.$control(_, instance, val);
		}
		finally {
			instance._controlling = null;
		}
		// check if validation has found errors
		if(errCount !== _errorCount(instance))
			return false;*/
		//
		if (instance._snapshotEnabled && !instance.$snapshot) 
			instance.$snapshot = _createSnapshot(_, instance, "$snapshot");
		if (instance._sysSnapshotEnabled && !instance.$sysSnapshot) 
			instance.$sysSnapshot = _createSnapshot(_, instance, "$sysSnapshot");
		//
		var $prop = (instance.$[name] = instance.$[name] || {});
		$prop.$diagnoses = [];
		// EXCEPTION: setting null when allready undefined shouldn't fire validation rules but should write in the null value
		if((oldVal == null) && (val == null)) {
			instance._data[name] = val;
			return false;
		}
		//
		instance.$validated[name] = false;
		//
		return true;
	}
	function _afterSetValue(_, instance, name, property, val, validateFunction) {
		// force lazy load for relations
		var val = instance[name](_);
		//
		instance._controlling = property.name;
		try {
			var errCount = _errorCount(instance);
			// validation
			if (instance._meta.$properties[name])
				validateFunction(_, instance, property, name, val);
			// control rule
			if (property.$control) 
				property.$control(_, instance, val);
		}
		finally {
			instance._controlling = null;
		}
		// propagate, is after value is set
		if (property.$propagate && errCount == _errorCount(instance)) {
//		if (property.$propagate) {
			var svPropagate = property.$propagate;
			property.$propagate = null;
			_safeCall(_, instance, property.name, svPropagate, "_propagating", val);
			property.$propagate = svPropagate;
		}
	}
	_proto.setLocalizedProp = function(_, name, localeCode, val) {
		var instance = this;
		//
		var _data = instance._data[name] = (instance._data[name] || {});
		_data[localeCode] = val;
		if(!_data["default"]) _data["default"] = val;
		//
		config.tracer && config.tracer("factory.setLocalizedProp: "+name+","+localeCode+","+val+"; Actual value: "+sys.inspect(instance._data[name]));
	}
	function _setProp(_, instance, name, property, val) {
		// setter
		config.tracer && config.tracer("factory._setProp: "+name+","+sys.inspect(val));
		//
		instance._data[name] = val;
	}	
	function _setRel(_, instance, name, property, val, isInverse) {
		// setter
		config.tracer && config.tracer("factory._set: "+name+","+sys.inspect(isInverse)+","+((val && val.$inspect && val.$inspect(true)) || sys.inspect(val))+")");
		//
		if(!_prepareSetValue(_, instance, name, property, val, _validateRelation)) return;
		//
		if (property.isPlural) {
			// set of array used in object initialisation
			throw (new Error("Instance: cannot set collection property"));
		}
		else {
			instance._data[name] = val;
			// replication
			if (property.$propagateInv) {
				if(property.$inv && val._meta.$relations[property.$inv] && val._meta.$relations[property.$inv].isPlural) {
					config.tracer && config.tracer("factory._set propagateInv to list; oldVal: "+(oldVal && oldVal.$uuid));
					if(oldVal) {
						config.tracer && config.tracer("factory._set remove from old list of: "+oldVal.$uuid);
						oldVal.ensureLoaded(_);
						oldVal[val._meta.$relations[property.$inv].name](_).deleteInstance(_, instance.$uuid);
						instance.addRelatedInstance(oldVal);
					}
					// add instance to new list
					if (!isInverse) {
						// use getter to lazy load
						instance[property.name](_)[val._meta.$relations[property.$inv].name](_).set(_, instance, true);
						// to persist
						instance.addRelatedInstance(instance[property.name](_));
					}				
				}
			}
		}
		// validation & control
		_afterSetValue(_, instance, name, property, val, _validateRelation);
	}
	forEachKey(meta.$properties, function(name, property){
		_proto[name] = function(_, val){
			if (arguments.length == 1) {
				//
				if (property.$compute) {
					config.tracer && config.tracer("factory.get compute prop: "+property.name);
					return _safeCall(_, this, property.name, property.$compute, "_computing");
				}
				//
				if(property.isExternalStorage())
					return _getExternalStorageProp(_, this, name, property);
				else
					if(property.$isLocalized)
						return _getLocalizedProp(_, this, name, property);
					else
						return _getProp(_, this, name, property);
			}
			else {
				// check
				if(!_prepareSetValue(_, this, name, property, val, _validateProperty)) return;
				// setter
				if(property.$isLocalized) {
					var self = this;
					// accept maps
					if(val && (typeof val == "object")) {
						Object.keys(val).forEach_(_, function(_, key) {
							self.setLocalizedProp(_, name, key, val[key]);
						});
					} else
						self.setLocalizedProp(_, name, locale.current, val);
				} else
					_setProp(_, this, name, property, val);
				// propagate
				// validation & control
				_afterSetValue(_, this, name, property, val, _validateProperty);
			}
		}
	});
	
	forEachKey(meta.$relations, function(name, relation){
		_proto[name] = function(_, val, isInverse){
			if (arguments.length == 1) {
				return _getRel(_, this, name, relation);
			}
			else {
				_setRel(_, this, name, relation, val, isInverse);
			}
		}
	});

	_proto._initialize = function (_, context) {
		if(!this.$uuid) {
			this.$uuid = this.$key = helpers.uuid.generate();
			this.$created = true;
			var user = context && context.getUser(_);
			this.$creUser = (user && user.login(_));
			this.$updUser = this.$creUser;
		}
		//
		var instance = this;
		config.tracer && config.tracer("factory._initialize: "+instance.$uuid);
		// create snapshot
		instance._snapshotEnabled = true;
		instance._sysSnapshotEnabled = true;
		if(!instance.$snapshot)
			instance.$snapshot = _createSnapshot(_, instance, "$snapshot");
		if(!instance.$sysSnapshot)
			instance.$sysSnapshot = _createSnapshot(_, instance, "$sysSnapshot");
		//
		flows.eachKey(_, instance._meta.$properties, function(_, name, property) {
			if(property.hasDefaultValue())
				instance[name](_, property.getDefaultValue(_, instance));
		});
		flows.eachKey(_, instance._meta.$relations, function(_, name, relation) {
			if (relation.hasOwnProperty("defaultValue")) {
				var defVal = null;
				if (typeof relation.defaultValue === "function") 
					defVal = relation.defaultValue();
				else 
					defVal = relation.defaultValue;
				//
				if((defVal instanceof Instance) || !defVal) 
					instance[name](_, defVal);
				else 			
					instance[name](_, instance.createChild(_, name, helpers.uuid.generate(), defVal));
			} 
		});
		if(instance._meta.$init)
			instance._meta.$init(_, instance, context);
		//
		return instance;
	}
	_proto.$addError = function(message, propName, links){
		config.tracer && config.tracer("error added for "+this.$uuid+"."+propName+" "+message);
		this._errorCount++;
		var node = this;
		var controlProp = propName || this._controlling;
		if (controlProp) 
			node = (this.$[controlProp] = this.$[controlProp] || {});
		node.$diagnoses = node.$diagnoses || [];
		node.$diagnoses.push({
			severity: "error",
			message: message,
			$links: links
		});
	}
	_proto.lockInstance = function(_) {
		adminHelper.lockInstance(_, this);
	}
	_proto.unlockInstance = function(_) {
		adminHelper.unlockInstance(_, this);
	}
	_proto.$inspect = function(withData, withMeta) {
		return "instance: "+this._meta.name+"; $uuid: "+this.$uuid+(withData?sys.inspect(this._data):"")+(withMeta?sys.inspect(this._meta):"");		
	}
	_proto.serializeInstance = function(_) {
		return _serialize(_, this, null);
	}
	_proto.ensureLoaded = function(_) {
		if (!this.$loaded && this._meta.$isPersistent) {
			config.tracer && config.tracer("factory.ensureLoaded.load: "+this.$uuid);
			var asso = this._db.fetchInstance(_, this._meta, this.$uuid);
			if(asso) {
				// replace _data by _data fetched
				var self = this;
				self._data = asso._data;
				forEachKey(asso, function(key) {
					if(key[0] == "$")
						self[key] = asso[key];
				});
				self.$initialUpdDate = asso.$updDate;
			}
			this.$key = this.$uuid;
			this.$loaded = true;
		}
		//
		return this;
	}
	//
	_proto.getSnapshotDelta = function(_) {
		return _computeDelta(_, this, "$snapshot", null, false);
	}
	_proto.getSaveSnapshotDelta = function(_) {
		return _computeDelta(_, this, "$snapshot", null, true);
	}
	_proto.getClassName = function() {
		return helpers.string.capitalize(this._meta.name);
	}
	_proto.createChild = function(_, relationName, uuid, data, forAsso){
		var child = this.syncCreateChild(relationName, uuid, data, forAsso);
		if((!data && (this._meta.$relations[relationName].isChild || forAsso)) || !uuid) child._initialize(_, this._context);
//		if(!data) child._initialize(_, this._context);
		return child;
	}
	_proto.syncCreateChild = function(relationName, uuid, data, forAsso) {
		config.tracer && config.tracer("factory.syncCreateChild: "+relationName+";"+sys.inspect(data));
		var targetType = forAsso?this._meta.$relations[relationName].targetAssoEntity:this._meta.$relations[relationName].targetEntity;
		var elt = (new Factory(targetType)).syncCreateInstance(data, this._db, this._context);
		// don't generate an uuid, let _initialize do it
//		elt.$uuid = uuid || helpers.uuid.generate();
		elt.$uuid = uuid;
		// if creating -> is loaded
		elt.$loaded = (uuid == null);
		elt._snapshotEnabled = true;
		elt._sysSnapshotEnabled = true;
		elt._parent = this;
		return elt; 
	}
	// add the instance to persist to the related list of the top instance
	_proto.addRelatedInstance = function(instance) {
		if(!instance) return;
		config.tracer && config.tracer("factory.addRelatedInstance: "+instance.$inspect());
		var top = getTopInstance(this);
		config.tracer && config.tracer("factory.topInstance: "+top.$inspect());
		top.relatedInst[instance.$uuid] = instance;
		config.tracer && config.tracer("factory.topInstance related inst: "+sys.inspect(top.relatedInst));
	}
	_proto.save = function(_) {
		var self = this;
		// fire $onDelete (for childrens)
		_fireOnDelete(_, this);
		// global validation
		_validateBeforeSave(_, this);
		// from datacontext._execoperation
		var op = {
			$isRequested: false, 
//			$diagnoses: [], 
			$links: {
			}
		};
		if(!(self.$created && (self._meta.$isPersistent !== false)))
			op.$links.$create = { $isHidden: true }
		//
		var hasErrors = _existsError(_, this);
		if(hasErrors) {
			// TODO : review this, should not be necessary. There is a problem detecting errors in childrens (multi-level), 
			// so for now we push this global error
/*			op.$diagnoses.push({
				severity: "error",
				message: "Cannot save this resource as some properties are in error state"
			});*/
			// if errors, hide standard links
			op.$links.$details = (op.$links.$details || {});
			op.$links.$details.$isHidden = true;
			op.$links.$query = (op.$links.$query || {});
			op.$links.$query.$isHidden = true;
			op.$links.$create = (op.$links.$create || {});
			op.$links.$create.$isHidden = true;
		} 
		else
			try {
				op.$diagnoses = [];
				this._saveErrorCode = 0;
				if(this.$save)
					this.$save(_, op);
				else {
					var saveResult = this._db.saveInstance(_,this);
					config.tracer && config.tracer("factory.save: db saveResult: "+sys.inspect(saveResult));
					if (saveResult == 0) {
						config.tracer && config.tracer("factory.save: concurency error; lastModified: "+this.$updDate);
						this._saveErrorCode = httpHelpers.HttpStatus.Conflict;
						throw new Error("Cannot save this resource as it has been modified by another user ("+this._meta.name+"."+this.$uuid+")");
					}
				}
				// cleanup external storage files
				_cleanupExternalStorage(_, this);
				//
				if (this._snapshotEnabled && this.$snapshot) 
					this.$snapshot = null;
				// save related instances
				// Q : what if fails ? (we should validate related instances first)
				// Q : should we do this at first or at the end ?
				config.tracer && config.tracer("factory.save: relatedInstances; $uuid: "+this.$uuid+"; "+sys.inspect(this.relatedInst));
				var hasRelatedErrors = false;
				flows.eachKey(_, this.relatedInst, function(_, key, value) {
					var res = value.save(_);
					// push diagnoses to main diagnoses
					res.$actions.$save.$diagnoses.forEach(function(diag) {
						if(diag.severity === "error") {
							op.$diagnoses.push(diag);
							hasRelatedErrors = true;
						}
					});
				});
				// cleanup deleted instances (plural relations)
				_cleanupDeleted(_, this);
				// cleanup snapshot
				this.$snapshot = null;
				this.$sysSnapshot = null;
				//
				this.unlockInstance(_);
				//
				if(!hasRelatedErrors)
					op.$diagnoses.splice(0, 0, {
						severity: "info",
						message: "Resource has been saved"
					});
				//
				self.$created = false;
			} catch (ex) {
				op.$diagnoses.push({
					severity: "error",
					message: ex.message
				});
//				console.error(ex.stack);
			}
		
//		op.$title = "Save";
		op.$isDisabled = true;
		op.$isRequested = false;
		//
		var result = _serialize(_, this);
		// crnit : from serializer
		result.$actions = result.$actions || {};
		result.$actions.$save = op;
		//
		return result;
	}
	function _evaluate(_, instance, expression) {
		// TODO: lowercase for strings
		function _getReferenceValue(ref, returnInstance) {
			return (returnInstance ? ref : ref && ref.$uuid);
		}
		function _evaluateChild(_, exp, childInst, returnInstance) {
			var result = null;
			switch(exp.type) {
				case "operator":
					return _evaluate(_, childInst, exp);
				case "identifier":
					if(["$uuid", "$updDate", "$updUser", "$creDate", "$creUser"].indexOf(exp.value) >= 0)
						return childInst[exp.value];
					var meta = childInst._meta.$properties[exp.value];
					if(meta) return childInst[exp.value](_);
					meta = childInst._meta.$relations[exp.value];
					if(meta) return (meta.isPlural ? null : _getReferenceValue(childInst[exp.value](_), returnInstance));
					if(typeof childInst[exp.value === "function"])
						result = childInst[exp.value](_);
					else
						result = childInst[exp.value];
					return null;
				case "literal":
					return exp.value;
				default:
					throw new Error(exp.type + "NYI");
			}
			return null;
		}
		//
		if(!expression) return true;
		//
		switch(expression.type) {
			case "operator":
				switch(expression.value.code) {
					case "and":
						break;
					case "or":
						break;
					case ".":
						if(expression.children.length != 2)
							throw new Error("Invalid expression: '.' operator" + expression.toString());
						if(expression.children[1].type != "identifier")
							throw new Error("Invalid expression: '.' operator" + expression.toString());
						var child1 = _evaluateChild(_, expression.children[0], instance, true);
						return child1 && _evaluateChild(_, expression.children[1], child1, true);
					case "=":
						return _evaluateChild(_, expression.children[0], instance) == _evaluateChild(_, expression.children[1], instance);
					case "<>":
						return _evaluateChild(_, expression.children[0], instance) != _evaluateChild(_, expression.children[1], instance);
					case "<":
						return _evaluateChild(_, expression.children[0], instance) < _evaluateChild(_, expression.children[1], instance);
					case "<=":
						return _evaluateChild(_, expression.children[0], instance) <= _evaluateChild(_, expression.children[1], instance);
					case ">":
						return _evaluateChild(_, expression.children[0], instance) > _evaluateChild(_, expression.children[1], instance);
					case ">=":
						return _evaluateChild(_, expression.children[0], instance) >= _evaluateChild(_, expression.children[1], instance);
					case "like":
						if(expression.children[1].type !== "literal")
							throw new Error(locale.format(module, "literalExpected", expression.value.code, expression.children[1].value));
						return ((_evaluateChild(_, expression.children[0], instance) || "").search("^"+expression.children[1].value.replace(/%/g, ".*")+"$") >= 0);
					case "between":
						var term = _evaluateChild(_, expression.children[0], instance);
						return (term >= _evaluateChild(_, expression.children[1], instance)) && (term <= _evaluateChild(_, expression.children[2], instance));
					default:
						throw new Error("operator: " + expression.value.code + " NYI");
				}
				break;
			default:
				throw new Error(expression.type + " NYI");
		}
	}
	_proto.match = function(_, expression) {
		return _evaluate(_, this, expression);
	}
	_proto.canDelete = function(_){
		// check here if we can delete instance; set deleteError otherwise
		var self = this;
		self.deleteError = "";
		return (!self._meta.$relations || !Object.keys(self._meta.$relations).filter(function(relName) {
			return self._meta.$relations[relName].$cascadeDelete;
		}).some_(_, function(_, relName) {
			var rel = self._meta.$relations[relName];
			if(rel.isPlural)
				return self[relName](_).toArray(_).some_(_, function(_, item) {
					return !item.canDelete(_);
				});
			else
				return (!self[relName](_) || !self[relName](_).canDelete(_));
		})) &&			
			(!self._meta.referingEntities || !Object.keys(self._meta.referingEntities).some_(_, function(_, entityName) {
				var entity = self._db.model.getEntity(entityName);
				if(!entity) throw new Error(locale.format(module, "entityNotFound", entityName));
				if(entity.$isPersistent === false) return false;
				// check if is refered
				var filter = {};
				var rels = self._meta.referingEntities[entityName].filter(function(relName) {
					// ignore relation if direct or inverse is with cascade
					var rel = entity.$relations && entity.$relations[relName];
					if(rel && rel.$cascadeDelete) return false;
					var inv = rel && rel.$inv && rel.targetEntity && rel.targetEntity.$relations[rel.$inv];
					return (!inv || !inv.$cascadeDelete);
				});
				if(rels.length == 0) return false;
				if(rels.length > 1) {
					filter.$or = rels.map(function(relName) {
						var part = {};
						part[relName] = self.$uuid;
						return part;
					});
				} else
					filter[rels[0]] = self.$uuid;
				var inst = self._db.fetchInstance(_, entity, {jsonWhere:filter});
				if(inst) {
					self.deleteError = "Cannot delete "+self.getValue(_)+" as is referenced by \""+inst._meta.name+"\" "+inst.getValue(_);
				}
				return (inst != null);
			}));
	}
	_proto.deleteSelf = function(_){
		try {
			var self = this;
			// fire $onDelete
			_fireOnDelete(_, this);
			//
			this._db.deleteInstance(_, this);
			// cascade delete
			Object.keys(self._meta.$relations).filter(function(relName) {
				return self._meta.$relations[relName].$cascadeDelete;
			}).forEach_(_, function(_, relName) {
				var rel = self._meta.$relations[relName];
				if(rel.isPlural)
					self[relName](_).toArray(_).forEach_(_, function(_, item) {
						item.deleteSelf(_);
					});
				else
					self[relName](_) && self[relName](_).deleteSelf(_);
			});
		} catch(e) {
			this.deleteError = e.message;
			return false;
		}
		return true;
	}
	_proto.getAllDiagnoses = function(_, diag, options) {
		function _makeDiagnose(diag, propName) {
			var res = diag;
			if(propName && options && options.addPropName)
				diag.message = propName + ":" + diag.message;
			if(options && options.addEntityName)
				diag.message = self._meta.name + ":" + diag.message;
			return diag;
		}
		var self = this;
		if(self.$diagnoses) 
			self.$diagnoses.forEach(function(item) {
				diag.push(_makeDiagnose(item));
			});
		//
		if(self.$)
			forEachKey(self.$, function(key, prop) {
				if(prop.$diagnoses)
					prop.$diagnoses.forEach(function(item) {
						diag.push(_makeDiagnose(item, key));
					});
			});
		//
		flows.eachKey(_, self._meta.$relations, function(_, key, rel) {
			if(rel.isChild) {
				var relData = self[key](_);
				if(rel.isPlural)
					relData.toArray(_).forEach_(_, function(_, item) {
						item.getAllDiagnoses(_, diag, options);
					});
				else
					relData && relData.getAllDiagnoses(_, diag, options);
			}
		});
		//
		forEachKey(self.$actions, function(key, action) {
			if(action.$diagnoses)
				action.$diagnoses.forEach(function(item) {
					diag.push(_makeDiagnose(item));
				});
		});
	}
	function _decodeTemplate(_, inst, template) {
		if(!inst) return "";
		if(!template) return "";
		var res = template.expression;
		template.matches.forEach_(_, function(_, match) {
			var prop = match.substring(1, match.length - 1);
			if (inst._meta.$properties[prop]) res = res.replace(match, _formatValue(inst._meta.$properties[prop], inst[prop](_)));
			else if (inst._meta.$relations[prop]) {
				if (inst._meta.$relations[prop].isPlural) res = res.replace(match, inst[prop](_).toArray(_).map_(_, function(_, elem) {
					return decodeTemplate(_, elem, inst._meta.$relations[prop].targetEntity.$valueTemplate);
				}).join(","));
				else res = res.replace(match, decodeTemplate(_, inst[prop](_), inst._meta.$relations[prop].targetEntity.$valueTemplate));
			}
		});
		return res;
	}
	_proto.getValue = function(_) {
		return _decodeTemplate(_, this, this._meta.$valueTemplate);
	}
	//
	this.__defineGetter__("meta", function(){
		return meta;
	});
	// connection is usefull for lazy loads, provide a dbHandle
	this.createInstance = function(_, data, connection, context){
		var inst = new Instance(data, null, connection, context);
//		var inst = new Instance(null, null, connection, context);
		if(!data) inst._initialize(_, context);
//		else inst._load(_, data);
		return inst;
	}
	this.syncCreateInstance = function(data, connection, context){
		return new Instance(data, null, connection, context);
	}
}

exports.Factory = helpers.defineClass(Factory, null, {})

// Working copy stuff

function _testETag(_, context, instance, delta){
	if (!delta || delta.$etag != instance.$etag) {
		config.tracer && config.tracer("factory.etag test failed: delta.etag="+(delta && delta.$etag)+"; instance etag="+instance.$etag);
		var headers = {
			etag: instance.$etag,
			"content-type": instance.$type
		};
		context.reply(_, 412, _serialize(_, instance), headers);
		return false;
	}
	return true;
}

function _instanceById(_, context) {
	// try to find the instance in cache
	var instance = null;
//	config.tracer && config.tracer("factory._instanceById: "+sys.inspect(context));
	if(context.entity.$isPersistent)
		instance = context.db.fetchInstance(_, context.entity, context.instanceId, false, context);
	else {
		instance = (new Factory(context.entity)).createInstance(_, null, context.db, context);
		instance.$setId(_, context, context.instanceId);
	}
	return instance;
}

function _createWorkingCopy(_, context, factory) {
	context.setMeta(true);
	var wcId = context.query.trackingId;
	// crnit : use database abstraction
	var instance = null;
	if (context.instanceId) {
		//instance = context.db.fetchInstance(_, context.entity, context.instanceId, (context.representation && context.representation.type));
		instance = _instanceById(_, context);
		config.tracer && config.tracer("factory.create working copy fetched instance: "+sys.inspect(instance));
		if (!instance) {
			context.reply(_, 404, "The requested ressource has not been found");
			return;
		}
		// explicit lock instance in create WC only (to have the error earlieast), for other cases is done by _createSnapshot
		try {
			instance.lockInstance(_);
		} catch(ex) {
			if(ex.httpStatus) {
				config.tracer && config.tracer("factory.createWC http error: "+ex.httpStatus+"="+ex.message);
				if((ex.httpStatus == httpHelpers.HttpStatus.Conflict) && ex.lockStatus) {
					// send diagnoses allowing to unlock
					instance.$addError(ex.message, null, {
						$unlock: {
							$title: "Force unlock",
							$url: context.baseUrl + "/$workingCopies('" + wcId + "')/$service/forceLockInstance",
							$method: "POST"
						}
					});
				} else {
					context.reply(_, ex.httpStatus, ex.message);
					return;
				}
			} else {
				throw ex;
			}
		}
		//
	} else {
		instance = factory.createInstance(_, null, context.db, context);
//		instance._initialize(_, context);
	}
	if (instance.$setParameters)
		instance.$setParameters(_, context);
//	instance.$url = context.baseUrl + "/$workingCopies('" + wcId + "')?representation=" + instance._meta.name + ".$edit";
	instance.$url = context.baseUrl + "/$workingCopies('" + wcId + "')?representation=" + context.representation.entity + ".$edit";
	instance.$trackingId = wcId;
	instance.$type = context.model.baseType;
	instance._snapshotEnabled = true;
	instance._sysSnapshotEnabled = true;
	//
	context.httpSession[wcId] = instance;
	//
	return instance;
}

exports.createWorkingCopy = function(_, context, factory){
	var instance = _createWorkingCopy(_, context, factory);
	if(!instance) return;
	var resource = _serialize(_, instance);
	// activate SAVE, see if we need to implement some conditions here
	var res = resource;
	if(instance._meta.$canSave !== false) {
		res.$actions = res.$actions || {};
		res.$actions.$save = res.$actions.$save || {};
		res.$actions.$save.$isRequested = false;
		res.$actions.$save.$isDisabled = false;
	//	res.$actions.$save.$isDisabled = true;
	}
	// no details link if instance is created
	if(instance.$created) {
		res.$links = res.$links || {};
		res.$links.$details = res.$links.$details || {};
		res.$links.$details.$isHidden = true;
	}
	//
	context.reply(_, httpHelpers.HttpStatus.Created, resource);
}

exports.getWorkingCopy = function(_, context, instance){
	var entity = context.getEntity();
	if(!instance && entity.$autoRecreateWorkingCopy) {
		context.entity = entity;
		instance = _createWorkingCopy(_, context, entity.factory);
	}
	//
	context.reply(_, 200, _serialize(_, instance));
}

exports.updateWorkingCopy = function(_, context, instance){
	var entity = context.getEntity();
	if(!instance && entity.$autoRecreateWorkingCopy) {
		context.entity = entity;
		instance = _createWorkingCopy(_, context, entity.factory);
	}
	// lock TODO !!!
	try {
		instance.lockInstance(_);
	} catch(ex) {
		if(ex.httpStatus) {
			config.tracer && config.tracer("factory.createWC http error: "+ex.httpStatus+"="+ex.message);
			if((ex.httpStatus == httpHelpers.HttpStatus.Conflict) && ex.lockStatus) {
				// send diagnoses allowing to unlock
				instance.$addError(ex.message, null, {
					$unlock: {
						$title: "Force unlock",
						$url: context.baseUrl + "/$workingCopies('" + context.query.trackingId + "')/$service/forceLockInstance",
						$method: "POST"
					}
				});
			} else {
				context.reply(_, ex.httpStatus, ex.message);
				return;
			}
		} else {
			throw ex;
		}
	}
	//
	instance.$sysSnapshot = null;
	var delta = JSON.parse(context.request.readAll(_));
	if (!_testETag(_, context, instance, delta)) 
		return;
	_applyDelta(_, instance, delta);
	// execute actions
	_executeActions(_, context, instance);
	//
	instance.$etag++;
	instance.$updUser = (context && context.getUser(_) && context.getUser(_).login(_));
	//
	if (delta.$actions && delta.$actions.$save && delta.$actions.$save.$isRequested) {
		// save
		try {
			var resource = instance.save(_);
			// for working copies, send allways OK status code and let diagnoses show error messages
//			context.reply(_, instance._saveErrorCode ? instance._saveErrorCode : httpHelpers.HttpStatus.OK, resource);
			context.reply(_, httpHelpers.HttpStatus.OK, resource);
		} catch(e) {
			context.reply(_, 500, e.message);
		}
	}
	else {
		var res = _computeDelta(_, instance, "$sysSnapshot", null, false);
		// activer save
		// !!! validateMandatory desactivated for now, it's better for the user to see the error when he saves.
		// anyway, validateMandatory should not fill $diagnoses
//		_validateMandatory(_, instance);
		if (!instance._errorCount && (instance._meta.$canSave !== false)) {
			res.$actions = res.$actions || {};
			res.$actions.$save = res.$actions.$save || {};
			res.$actions.$save.$isRequested = false;
			res.$actions.$save.$isDisabled = false;
		}
		// no details link if instance is created
		if(instance.$created) {
			res.$links = res.$links || {};
			res.$links.$details = res.$links.$details || {};
			res.$links.$details.$isHidden = true;
		}
		//
		context.reply(_, httpHelpers.HttpStatus.OK, res);
	}
}

exports.fetchInstances = function(_, context, entity, parameters) {
	config.tracer && config.tracer("factory.fetchInstances enter");
	context.setMeta(false);
	//
	var ent = entity || context.entity;
	var params = parameters || context.parameters || {};
	var instances;
	if(ent.$fetchInstances) {
		var preliminary = context.sortInstancesArray(_, context.filterInstancesArray(_, ent.$fetchInstances(_, context, params)), ent.defaultOrder);
		var listCount = preliminary.length;
		//
		context.totalCount = listCount
		var start = (params.startIndex || 1)-1;
		var count = (params.count || (listCount-start));
		instances = preliminary.slice(start, Math.min(start+count, listCount));
	} else {
		context.addComplementFilter(_, params);
		context.totalCount = context.db.count(_, ent, params); 
		// add filter for letter paging (no letter paging for count compute)
		if(params.startLetter && params.orderBy && params.orderBy[0] && params.orderBy[0].binding) {
			var newFilter = parser.Parser.parse("(" + params.orderBy[0].binding + " between '" + params.startLetter.toLowerCase() + "' and 'z') or " +
					"(" + params.orderBy[0].binding + " between '" + params.startLetter.toUpperCase() + "' and 'Z')");
			if(params.where)
				params.where = {
					type: "operator",
					value: {
						code: "and"
					},
					children: [params.where, newFilter]
				}
			else
				params.where = newFilter;
		}
		instances = context.db.fetchInstances(_, ent, params);
	}
	config.tracer && config.tracer("factory.fetchInstances count:"+context.totalCount);
	//
	var resources = [];
	instances.forEach_(_, function(_, instance){
		resources.push(_serialize(_, instance, (["$query","$lookup","$select"].indexOf(context.representation.type) >= 0)));
	});
	context.replyResources(_, httpHelpers.HttpStatus.OK, resources);
}

exports.fetchInstance = function(_, context, notFoundCallback) {
	config.tracer && config.tracer("factory.fetchInstance enter");
	context.setMeta(false);
	var instance = _instanceById(_, context);
	if(instance)
		context.replyResource(_, httpHelpers.HttpStatus.OK, _serialize(_, instance));
	else
		if(notFoundCallback)
			notFoundCallback(_, context);
		else {
			var repMeta = context.getRepresentationMeta(context.contract, context.getRepresentation(context.contract, context.entity.name, context.representation.entity), context.representation.type);
			if(repMeta && repMeta.$options && repMeta.$options.$notFoundUrl) {
				// TODO: expression parse for this url ?
//				var location = repMeta.$options.$notFoundUrl;
				var location = repMeta.$options.$notFoundUrl && repMeta.$options.$notFoundUrl.replace("{$baseUrl}", context.baseUrl);
				context.reply(_, httpHelpers.HttpStatus.TemporaryRedirect, "", { Location: location });
			} else
				context.reply(_, 404);
		}
}

exports.createInstance = function(_, context, factory) {
	// create instance
	var instance = factory.createInstance(_, null, context.db, context);
//	instance.$url = context.baseUrl + "/"+instance._meta.name+"('" + instance.$uuid + "')?representation=" + instance._meta.name + ".$edit";
	instance.$url = context.baseUrl + "/"+instance._meta.name+"('" + instance.$uuid + "')?representation=" + context.representation.entity + ".$edit";
	instance.$type = context.model.baseType;
	// apply delta
	instance.$sysSnapshot = null;
	var delta = JSON.parse(context.request.readAll(_));
	_applyDelta(_, instance, delta);
	// save
	var res = instance.save(_);
	context.reply(_, _existsError(_, instance)?httpHelpers.HttpStatus.BadRequest:httpHelpers.HttpStatus.Created, res);
}

exports.updateInstance = function(_, context){
	if (context.instanceId) {
//		var instance = context.db.fetchInstance(_, context.entity, context.instanceId, (context.representation && context.representation.type));
		var instance = _instanceById(_, context);
		config.tracer && config.tracer("factory.updateInstance fetched instance: "+instance.$inspect(true));
		if (!instance) {
			context.reply(_, 404);
			return;
		}
		// apply delta
		instance.$sysSnapshot = null;
		instance._snapshotEnabled = true;
		instance._sysSnapshotEnabled = true;
		instance.$updUser = (context && context.getUser(_) && context.getUser(_).login(_));
		var delta = JSON.parse(context.request.readAll(_));
		_applyDelta(_, instance, delta);
		// save
		try {
			var resource = instance.save(_);
			context.reply(_, _existsError(_, instance)?httpHelpers.HttpStatus.BadRequest:httpHelpers.HttpStatus.OK, resource);
		} catch(e) {
			context.reply(_, 500, e.message);
		}
	} else
		context.reply(_, 404);
}

exports.deleteInstance = function(_, context){
	if (context.instanceId) {
		var instance = _instanceById(_, context);
		//var instance = context.db.fetchInstance(_, context.entity, context.instanceId, (context.representation && context.representation.type));
		if (!instance) {
			context.reply(_, 404);
			return;
		}
		config.tracer && config.tracer("factory.updateInstance fetched instance: "+instance.$inspect(true));
		// check
		if (instance.canDelete(_) && instance.deleteSelf(_)) {
			// save
			context.replyDeleted(_);
		} else
			context.reply(_, 403, instance.deleteError);
	} else
		context.reply(_, 404);
}

// setup
exports.setup = function(factoryConfig) {
	config = factoryConfig || {};
}
