"use strict";

/// !doc
/// # Factory API  
/// ```javascript
/// var factory = require('syracuse-orm/lib/factory')  
/// ```
/// 

// TODO : centralized management of $init, apply on childrens too

var globals = require('streamline/lib/globals');
var helpers = require("syracuse-core/lib/helpers");
var httpHelpers = require("syracuse-sdata/lib/httpHelper");
var forEachKey = helpers.object.forEachKey;
var types = require("syracuse-core/lib/types/allTypes");
var resourceHelpers = require("syracuse-core/lib/resource/util");
var flows = require("streamline/lib/util/flows");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var fileStoreFactory = require("./fileStoreFactory");
var locale = require("syracuse-core/lib/locale");
var parser = require('syracuse-sdata/lib/parser/parser');
var Template = require("syracuse-core/lib/resource/resourceProxy").Template;
var searchIndex = require("syracuse-search/lib/elasticIndex");
var serializer = require("syracuse-orm/lib/serializer");
var Parser = require("syracuse-sdata/lib/parser/parser").Parser;
var sys = require("util");

var config = {};

var queryFacets = ["$query","$lookup","$select","$bulk","$search"];

function getTopInstance(instance) {
	var parent = instance._parent || instance;
	while(parent._parent) { parent = parent._parent }
	return parent;
}

function _formatValue(prop, val) {
/*	if(prop.$isArray && Array.isArray(val))
		return val.map(function(v) {
			return resourceHelpers.formatValue(prop, v);
		});
	else*/
		return resourceHelpers.formatValue(prop, val);
}

// TODO: should be async to be able to load X3 entities ...
function _getTargetEntity(model, relation, type) {
	var targetType;
	if (relation.$isDynamicType && type) {
		targetType = model.getEntity(type);
		if(!targetType)
			throw new Error(locale.format(module, "dynTargetTypeNotFound", relation.name, type));
	} else {
		targetType = relation.targetEntity;
		if(!targetType)
			throw new Error(locale.format(module, "targetTypeNotFound", relation.name));
	}
	return targetType;
}

function _getPropertiesResourceMeta(_, resource, instance) {
	function _internalGetMeta(_, key, prop) {
		if(prop.$isMandatory && (typeof prop.$isMandatory === "function")) {
			// conditional mandatory
			resource.$properties[key] = resource.$properties[key] || {};
			resource.$properties[key].$isMandatory = prop.$isMandatory(_, instance);
		}
		if(prop.$isHidden && (typeof prop.$isHidden === "function")) {
			// conditional mandatory
			resource.$properties[key] = resource.$properties[key] || {};
			resource.$properties[key].$isHidden = prop.$isHidden(_, instance);
		}
		if(prop.$isDefined && (typeof prop.$isDefined === "function")) {
			// conditional mandatory
			resource.$properties[key] = resource.$properties[key] || {};
			resource.$properties[key].$isHidden = !prop.$isDefined(_, instance);
		}
		if(prop.$isDisabled && (typeof prop.$isDisabled === "function")) {
			// conditional mandatory
			resource.$properties[key] = resource.$properties[key] || {};
			resource.$properties[key].$isDisabled = prop.$isDisabled(_, instance);
		}
		if(prop.$isReadOnly && (typeof prop.$isReadOnly === "function")) {
			// conditional mandatory
			resource.$properties[key] = resource.$properties[key] || {};
			resource.$properties[key].$isReadOnly = prop.$isReadOnly(_, instance);
		}
		if(prop.$lookup && (typeof prop.$lookup === "function")) {
			// conditional lookup
			resource.$properties[key] = resource.$properties[key] || {};
			var res = prop.$lookup(_, instance);
			if (res)
				resource.$properties[key].$links = {
					$lookup: res,
	
				}
		}
		if(prop.$select && (typeof prop.$select === "function")) {
			// conditional lookup
			resource.$properties[key] = resource.$properties[key] || {};
			var res = prop.$select(_, instance);
			if (res)
				resource.$properties[key].$links = {
					$select: res,
	
				}
		}
	}
	resource.$properties = resource.$properties || {};
	flows.eachKey(_, instance._meta.$properties, function(_, key, property) {
		_internalGetMeta(_, key, property);
	});
	flows.eachKey(_, instance._meta.$relations, function(_, key, relation) {
		_internalGetMeta(_, key, relation);	
	});
	// links
	flows.eachKey(_, instance._meta.$links, function(_, key, link) {
		if(typeof link === "function") {
			var l = link(_, instance);
			if(l) {
				resource.$links = resource.$links || {};
				resource.$links[key] = l
			}
		}
	});
	flows.eachKey(_, instance.$links, function(_, key, link) {
		var l = (typeof link === "function") ? link(_, instance) : link;
		if(l) {
			resource.$links = resource.$links || {};
			resource.$links[key] = l
		}
	});
}

function _makeLazyUrl(url, propName, segment) {
	var lazyUrl;
	if(url) {
		lazyUrl = url.split("?");
		lazyUrl[0] += (segment ? "/"+segment : "") + "/" + propName;
		lazyUrl = lazyUrl.join("?");
	} else
		lazyUrl = "{$baseUrl}/{$pluralType}('{$key}')" + (segment ? "/"+segment : "") + "/" + propName;
	return lazyUrl;
}

var _propTypeFormaterMap = {
	graph: function(property, instance) {
		return {
			$url: _makeLazyUrl(instance.$url, property.name, "$graphs"),
			$type: property.$type
		}
	},
	"tag-cloud": function(property, instance) {
		return {
			$url: _makeLazyUrl(instance.$url, property.name, "$tagClouds"),
			$type: property.$type
		}
	}
}

function _createSnapshot(_, instance, type) {
	// allready a snapshot
	if(instance._snapshotType || !instance.$uuid) return;
	//
	config.tracer && config.tracer("factory._createSnapshot: $uuid: "+instance.$uuid);
	//
	instance.lockInstance(_);
	//
	var data = instance._data;
	var copy = {};
	forEachKey(instance._meta.$properties, function(name, prop){
		var v = data[name];
		if (v != null) {
			if (Array.isArray(v)) 
				v = v.slice(0);
			if(prop.$isLocalized || prop.isExternalStorage())
//			if(typeof v === "object")
				copy[name] = _clone(v);
			else
				// use formatValue as passes through the same code that treats database data
				copy[name] = _formatValue(prop, v);
		}
	});
//	var snapshot = new Instance(copy, _clone(instance.$properties), instance._db, instance._context);
	var snapshot = instance._meta.factory.createInstance(_, copy, instance._db, instance._context);
	// relations
	flows.eachKey(_, instance._meta.$relations, function(_, name, prop){
		var v = data[name];
		if (v != null) {
			if (prop.isPlural) {
				var coll = snapshot[name](_);
				// for collections, create a snapshot collections pointing to the org. collection elements 
/*				flows.eachKey(_, v._data, function(_, uuid, elt){
					coll._data[uuid] = elt;
				});*/
				coll._data = null;
				coll._array = v._array.slice(0);
			}
			else 
				// snapshot continues to point to the same instance of the relation. This should be right as 
				// the instance has her own snapshot in case of modification
				// direct copy as _setRel might trigger rules
//				snapshot[name](_, v);
				snapshot._data[name] = v;
		}
	});
	snapshot._snapshotType = type;
	config.tracer && config.tracer("factory._createSnapshot exit: $uuid: "+instance.$uuid);
	return snapshot;
}

function _serializeExternalStorageProperty(_, instance, propName) {
	config.tracer && config.tracer("factory._serializeExternalStorageProperty enter: "+instance.$uuid);
	var key = propName;
	if(!instance[key](_)) return null;
	if(!instance[key](_).fileExists(_)) return null;
	var property = instance._meta.$properties[key];
	var storeProps = instance[key](_).getProperties(_) || {};
	config.tracer && config.tracer("factory._serializeExternalStorageProperty properties: "+sys.inspect(storeProps));
	return {
		$uuid: instance[key](_).getUuid(),
		$url: _makeLazyUrl(instance.$url, key),
		$type: property.$type,
		$contentType: storeProps.contentType,
		$fileName: storeProps.fileName,
		$length: storeProps.length
	}
}

function _serializeReference(_, instance, relMeta) {
	function _addMatches(t) {
		if(t && t.matches) {
			t.matches.forEach(function(e) {
				var m = e.substring(1, e.length - 1);
				if(_matches.indexOf(m) < 0)
					_matches.push(m);
			})
		}
	}
	if(!instance) return null;
	if(relMeta.isChild || relMeta.$serializeAll) {
		config.tracer && config.tracer("factory._serialize child reference: "+relMeta.name);
		return _serialize(_, instance);
	} else {
		config.tracer && config.tracer("factory._serialize reference: "+relMeta.name);
		//
		var res = {
			$uuid: instance.$uuid,
			$key: instance.$key
		}
		//
		// serialize only props that compose $valueTemplate or $key
//		var targetType = _getTargetEntity(instance._db.model, relMeta, instance && instance.$type);
		var targetType = instance.getEntity();
		var _matches = [];
		_addMatches(targetType.$valueTemplate);
		_addMatches(targetType.$valueTitleTemplate);
		var kt = targetType.$key ? (new Template(targetType.$key)) : null;
		kt && _addMatches(kt);
		// ensure load
		var i = instance;
		_matches.forEach_(_, function(_, match) {
			res[match] = i.$resolvePath(_, match);
		});
		if(relMeta.$isDynamicType) {
			res.$pluralType = targetType.plural;
			res.$representation = targetType.name;
			var t = targetType.$valueTemplate || kt;
			res.$value = t && t.resolve(res);
		}
		//
		return res;
	}
}

function _internalSerialize(_, instance, shallow) {
	if (!instance)
		return null;
	//
	var meta = instance._meta;
	var resource = {
		$uuid: instance.$uuid,
		$key: instance.$key,
//		$trackingId: instance.$trackingId || instance.$uuid,
		$trackingId: instance.$trackingId,
		$url: instance.$url || instance.computeUrl(),
		$type: instance.$type,
		$etag: instance.$etag,
		$creUser: instance.$creUser,
		$creDate: instance.$creDate,
		$updUser: instance.$updUser,
		$updDate: instance.$updDate, 
		$properties: instance.$properties
	};
	if (instance.$diagnoses && instance.$diagnoses.length)
		resource.$diagnoses = instance.$diagnoses;
	// add all parents uuid - usefull for childrens with expressions
	if(!shallow) {
		var parent = instance;
		var prefix = "$";
		while(parent = parent._parent)
			resource[(prefix += "parent_") + "uuid"] = parent.$uuid;
	}
	//
	if(instance.hasOwnProperty("$index"))
		resource.$index = instance.$index;
	flows.eachKey(_, meta.$properties, function(_, key, property){
		config.tracer && config.tracer("factory._serialize property: "+key);
		if(property.isExternalStorage() && !(instance[key](_) && instance[key](_).fileExists(_)))
			return;
		if(property.$isLazy || property.isExternalStorage()) {
			resource[key] = _serializeExternalStorageProperty(_, instance, key);
		} else 
			resource[key] = (_propTypeFormaterMap[property.$type] && _propTypeFormaterMap[property.$type](property, instance)) || _formatValue(property, instance[key](_));
	});
	flows.eachKey(_, meta.$relations, function(_, key, relation){
		if(relation.isPlural && shallow) return;
		// no need to serialize the inverse of a child relation
		var inv = relation.$inv && relation.targetEntity.$relations[relation.$inv];
		if (inv && inv.isChild) return;
		config.tracer && config.tracer("factory._serialize relation: "+instance.$uuid+"."+key);
		var val = instance[key](_);
		if (relation.isPlural) {
			var collData = val.toArray(_, true);
			if(collData.length)
				resource[key] = collData.map_(_, 
					function(_, elt) {
						//var r = _serialize(_, elt, !relation.isChild);
						var r = _serializeReference(_, elt, relation);
						// $index should be returned only in delta mode. In serialize we return full table
						delete r.$index;
						return r;
					});
		}
		else {
			resource[key] = _serializeReference(_, val, relation);
		}
	});
	//
	_getPropertiesResourceMeta(_, resource, instance);
	// compute $key
	if(meta.$key)
		resource.$key = (new Template(meta.$key)).resolve(resource);
	if(meta.$valueTemplate)
		resource.$value = meta.$valueTemplate.resolve(resource);
	//
	config.tracer && config.tracer("factory._serialize exit: "+instance.$uuid+"-"+sys.inspect(resource));
	return resource;
}

function _serialize(_, instance, shallow) {
	if (!instance)
		return null;
	// particular case of pages
	config.tracer && config.tracer("factory._serialize enter: "+instance.$uuid);
	if (instance.serialize) {
		return instance.serialize(_);
	}
	if (instance._data && instance._data.serialize) {
		return instance._data.serialize(_);
	}
	// non persistent object might have this
	if (instance.$serialize) {
		config.tracer && config.tracer("factory._serialize exit: ($serialize)");
		return instance.$serialize(_);
	}
	//
	return _internalSerialize(_, instance, shallow);
}

// takes an url identifying an object and fetches the associated object. The url must be in form:
// [http://server:port]/sdata/application/contract/dataset/entities('identifier')[?...]
function _resolveDetailUrl(_, url) {
	// takes the last 4 segments of the url
	config.tracer && config.tracer("factory._resolveUrl url: "+url);
	var segs = url.split("?")[0].split("/").slice(-4);
	if(!segs[3]) return null;
	//
	var det = httpHelpers.decodeDetailSegment(segs[3]);
	if(!det) return null;
	config.tracer && config.tracer("factory._resolveUrl params: "+JSON.stringify(det));
	//
	var ep = adminHelper.getEndpoint(_, {
		application: segs[0],
		contract: segs[1],
		dataset: segs[2]
	});
	if(!ep) return null;
	//
	var db = ep.getOrm(_);
	var where = det.isExpressionId ? {
		sdataWhere: det.id
	} : det.id;
	return db.fetchInstance(_, db.getEntity(_, db.model.singularize(det.name)), where);
}

function _applyDelta(_, instance, delta){
	instance._errorCount = 0;
	instance.$diagnoses = [];
	instance.$properties = {};
	// will execute propagate after sysSnapshot creation
	instance.deferPropagate = [];
	// in case of relations, we will set instances for every child relation
	config.tracer && config.tracer("factory._applyDelta input: "+sys.inspect(delta));
	flows.eachKey(_, delta, function(_, key, value){
		config.tracer && config.tracer("factory._applyDelta key: "+key);
		var r = instance._meta && instance._meta.$relations && instance._meta.$relations[key];
		if (r && r.isPlural) {
			if(Array.isArray(value)) {
				var collection = instance[key](_);
				var oldElts = collection.toArray(_);
				// delete missing: now we detect delta mode by the $index property
	//			var receivedUuids = (delta.$properties && delta.$properties[key] && delta.$properties[key].$deleteMissing)?[]:null;
				if(value.length && !value[0])
					throw new Error("Internal error: inconsistent data (null element in array)");
				var isDelta = (value.length && (value[0].$index != null));
				var receivedUuids = isDelta ? null : [];
	//			collection._isDelta = (receivedUuids == null);
				// AS 20/11/2012: the client always sends deltas. Deleted records will always have $isDeleted: true. 
				//var receivedUuids = null;
				collection._isDelta = true;
				value.forEach_(_, function(_, newElt, idx){
					if(!newElt) return;
					// has url ?
					var resolvedInstance = null;
					if(!collection._relMeta.isChild && ((!newElt.$uuid && !newElt.$key && newElt.$url) || (collection._relMeta.$isDynamicType && newElt.$url))) {
						resolvedInstance = _resolveDetailUrl(_, newElt.$url);
						if(!resolvedInstance) {
							instance.$addDiagnose("warning", locale.format(module, "referenceNotFound", collection._relMeta.name), collection._relMeta.name);
							return;
						}
					}
					//
					if(!newElt.$uuid)
						newElt.$uuid = helpers.uuid.generate();
					// check $uuid presence for references
					if(!collection._relMeta.isChild && !newElt.$uuid) {
						instance.$addError(locale.format(module, "referenceNotFound", collection._relMeta.name), collection._relMeta.name);
						return;
					}
					//
					var k = newElt.$key || newElt.$uuid;
					receivedUuids && receivedUuids.push(k);
					if (newElt.$isDeleted) {
						config.tracer && config.tracer("factory._applyDelta isDeleted: " + k);
						collection.deleteInstance(_, k);
					}
					else {
						var isCreated = false;
						var actualItem = collection.get(_, k);
						if (!actualItem) {
							actualItem = collection.set(_, resolvedInstance || instance.createChild(_, key, k, r.$inlineStore && newElt));
							isCreated = true;
						}
						if(actualItem.$isDeleted)
							actualItem.$isDeleted = false;
						if (collection._relMeta.isChild) 
							_applyDelta(_, actualItem, newElt);
						// order management
						if(isDelta) {
							actualItem.$index = newElt.$index;
							// no need to splice, set should do it
							//if(isCreated) collection._array.splice(newElt.$index, 0, actualItem);
						} else
							actualItem.$index = idx;
					}
				});
				// rebase indexes
				if(isDelta)
					oldElts.forEach(function(e, i) {
						e.$index = i;
					});
				else
					collection._array.sort(function(a,b) {
						return a.$index - b.$index;
					});
				// delete missing
				if(receivedUuids) {
					var collUuids = collection.toUuidArray(_);
					config.tracer && config.tracer("factory._applyDelta delete missing: received Uuids: " + sys.inspect(receivedUuids) + "; " +
							sys.inspect(collUuids));
					collUuids.forEach_(_, function(_, collEltUuid){
						if (receivedUuids.indexOf(collEltUuid) < 0) {
							config.tracer && config.tracer("factory._applyDelta isDeleted: " + collEltUuid);
							collection.deleteInstance(_, collEltUuid);
						}	
					});
				}
			}
		} else {
			if (key[0] == '$') {
				instance[key] = value;
				// manage of "undefined" values
				if (key === "$properties")
					for (var d in delta.$properties)
						if (delta.$properties[d].$isUndefined)
							delete instance._data[d];
			}
			else {
				var rel = instance._meta.$relations && instance._meta.$relations[key];
//				if (instance._meta.$relations && instance._meta.$relations.hasOwnProperty(key)) {
				if (rel) {
					if (value) {
						if(rel.isChild) {
							// child "1" relation, apply delta if allready exists, set new instance otherwise 
							if (!instance[key](_)) 
								instance[key](_, instance.createChild(_, key, value.$uuid));
							_applyDelta(_, instance[key](_), value);
						}
						else {
							// has url ?
							if(value.$url) {
								value = _resolveDetailUrl(_, value.$url);
								if(!value) {
									instance.$addDiagnose("warning", locale.format(module, "referenceNotFound", rel.name), rel.name);
									return;
								}
							}
							var relVal = instance[key](_);
							if(!relVal && !value.$uuid) {
								instance.$addError(locale.format(module, "referenceNotFound", rel.name), rel.name);
								return;
							}
							var k = value.$key || value.$uuid;
//							if(!relVal || (value.$uuid && (value.$uuid !== relVal.$uuid)))
							if(!relVal || (k !== relVal.$key))
								// reference change
								//instance[key](_, instance.createChild(_, key, value.$uuid));
								instance[key](_, instance.createChild(_, key, k));
						}
					} else
						instance[key](_, null);
				}
				else 
					if (instance._meta.$properties && instance._meta.$properties.hasOwnProperty(key)) {
						var p = instance._meta.$properties[key];
						if(p.$isArray && Array.isArray(value))
							instance[key](_, value.map(function(v) {
								return resourceHelpers.parseValue(p, v);
							}));
						else {
							instance[key](_, resourceHelpers.parseValue(p, value));
						}
					}
			}
		}
	});
	// create sys snapshot
	instance.$sysSnapshot = _createSnapshot(_, instance, "$sysSnapshot");
	// execute defered
	// !!! BUG !!! the defered execution of propagates might override modifications in delta
	instance.executeDefered(_, "deferPropagate");
	//
	config.tracer && config.tracer("factory._applyDelta resulting instance data: "+sys.inspect(instance._data));
	config.tracer && config.tracer("factory._applyDelta resulting instance properties: "+sys.inspect(instance.$properties));
//	config.tracer && config.tracer("factory._applyDelta related inst: "+sys.inspect(instance._relatedInst));
}

function _cleanupDeleted(_, instance, shallow) {
	config.tracer && config.tracer("factory._cleanupDelete for instance: "+instance._meta.name+"."+instance.$uuid);
	if(!instance._meta.$relations) return;
	//
	flows.eachKey(_, instance._meta.$relations, function(_, key, rel) {
		if(instance._data[key])
			if(rel.isPlural) {
				// remove deleted instances
				if(instance._data[key]._data)
					flows.eachKey(_, instance._data[key]._data, function(_, elemKey, elemInst) {
						if(elemInst.$isDeleted) {
							config.tracer && config.tracer("factory._cleanupDelete removing: "+key+"."+elemKey);
							delete instance._data[key]._data[elemKey];
						} else
							if(!shallow || rel.isChild)
								_cleanupDeleted(_, elemInst, true);
					});
			} else
				if(!shallow)
					_cleanupDeleted(_, instance._data[key], true);
	});
}

function _cleanupExternalStorage(_, instance) {
	if(!instance.$snapshot) return;
	config.tracer && config.tracer("factory._cleanupExternalStorage for instance: "+instance._meta.name+"."+instance.$uuid);
	flows.eachKey(_, instance._propertyStores, function(_, key, store) {
		var oldFile = instance.$snapshot[key](_).getUuid();
		if(oldFile && (oldFile !== instance[key](_).getUuid())) {
			config.tracer && config.tracer("factory._cleanupExternalStorage deleting: "+oldFile);
			instance.$snapshot[key](_).deleteFile(_);
		}
	});
}

function _executeActions(_, context, instance) {
	config.tracer && config.tracer("factory._executeActions instance: "+instance._meta.name+"."+instance.$uuid+" - actions: "+sys.inspect(instance.$actions,null,3));
	// for each relation, scan if action isRequested
	flows.eachKey(_, instance._meta.$relations, function(_, key, rel) {
		var relInst = instance[key](_);
		if(!relInst || !rel.isChild) return;
		// recurse
		if (rel.isPlural) {
			var coll = relInst.toArray(_);
			coll.forEach_(_, function(_, item) {
				_executeActions(_, context, item);
			})
		} else
			_executeActions(_, context, relInst);
		// execute relation actions
		var acts = relInst.$actions || (instance.$properties[key] && instance.$properties[key].$actions);
		if (acts)
			flows.eachKey(_, acts, function(_, name, action) {
				// for the moment, save is managed differently
				if (action.$isRequested && (name !== "$save")) {
					if ((name === "$select") || (name === "$create")) {
						config.tracer && config.tracer("factory._executing "+name+".$create");
						if(action.$parameters && action.$parameters.$select) {
							action.$parameters.$select.forEach_(_, function(_, item) {
								var child = instance.createChild(_, key);
								if (rel.isPlural) 
									relInst.set(_, child);
								else
									instance[key](_, child);
								//
//								config.tracer && config.tracer("factory._executing "+name+".$create; setting "+rel.$select.$target+" on "+rel.targetEntity.name+"."+rel.targetEntity.$relations[rel.$select.$target].name);
								var fields = rel.$select.$fieldMap;
								fields && Object.keys(fields).forEach_(_, function(_, targetName) {
									if(rel.targetEntity.$relations[targetName]) {
										var inst = instance._db.fetchInstance(_, rel.targetEntity.$relations[targetName].targetEntity, item[fields[targetName]]);
										inst && child[targetName](_, inst);
									} else
										if(rel.targetEntity.$properties[targetName]) {
											item[fields[targetName]] && child[targetName](_, item[fields[targetName]]);
										}
								});
							});
						} else {
							var child = instance.createChild(_, key);
							if (rel.isPlural) 
								relInst.set(_, child);
							else
								instance[key](_, child);
						}
					}
					//
					delete action.$parameters;
					action.$isRequested = false;
				}
			});
	});
	
	flows.eachKey(_, instance._meta.$properties, function(_, key, prop) {
		
		var propInst = instance[key](_);
		if(!propInst || typeof propInst === 'string') return;
		
		var lnks = instance.$properties[key] && instance.$properties[key].$links;
		if (lnks)
			flows.eachKey(_, lnks, function(_, name, lnk) {
				if (lnk && (name === "$lookup")) {
					var fields = lnk.$fieldMap;
					fields && Object.keys(fields).forEach_(_, function(_, targetName) {

						if (instance.$properties[targetName]){
							instance[targetName](_, propInst[fields[targetName]]);
						}
					});
				}
			});
	});
	// execute instance actions
	if (instance.$actions)
		flows.eachKey(_, instance.$actions, function(_, name, action) {
			// for the moment, save is managed differently
			if (action.$isRequested && (name !== "$save")) {
				config.tracer && config.tracer("factory._executing "+name);
				if (name === "$delete") {
					instance.$isDeleted = true;
				} else
					if (instance._meta.$services && instance._meta.$services[name])
						instance._meta.$services[name].$execute(_, context, instance, action.$parameters);
				//
				action.$isRequested = false;
			}
		});
}

function _delta(oldObj, newObj){
	if (newObj && !oldObj) 
		return newObj;
	if (oldObj && !newObj) 
		return null;
	
	if (Array.isArray(oldObj)) {
		if (Array.isArray(newObj) && oldObj.length == newObj.length) {
			var arr = newObj.map(function(newElt, i){
				return _delta(oldObj[i], newElt);
			});
			if (arr.some(function(elt){
				return typeof elt !== "undefined";
			})) 
				return newObj; // will optimize later
			else 
				return;
		}
		return newObj;
	}
	else if (typeof oldObj === "object" && typeof newObj === "object") {
		var result;
		var keys = {}
		forEachKey(oldObj, function(key, oldVal){
			keys[key] = true;
			var diff = _delta(oldVal, newObj[key]);
			if (typeof diff !== "undefined") {
				result = result || {};
				result[key] = diff;
			}
		});
		forEachKey(newObj, function(key, newVal){
			if (!keys[key]) {
				result = result || {};
				result[key] = newVal;
			}
		})
		return result;	
	}
	else if (oldObj !== newObj) {
		return newObj;
	}
}

function _computePropertyDelta(_, instance, snapshot, delta, property, fullLocale) {
	var key = property.name;
	var newVal = _formatValue(property, ((property.$isLocalized && !fullLocale) || property.$compute) ? instance[key](_) : instance._data[key]);
	var oldVal = _formatValue(property, ((property.$isLocalized && !fullLocale) || property.$compute) ? snapshot[key](_) : snapshot._data[key]);
	// TEMP, TODO proper management of snapshots on external stored props
	config.tracer && config.tracer("factory.compute delta on property: "+key+"; oldVal: "+sys.inspect(oldVal)+"; newVal: "+sys.inspect(newVal));
	if (property.isExternalStorage()) {
		if(instance[key](_)) {
			delta[key] = _delta(oldVal, newVal);
		}
	} else {
		// new data has a value (may be null) and oldVal is different or not set
		if (property.$isLocalized && fullLocale) {
			delta[key] = _delta(oldVal, newVal);
		} else
			if ((instance._data.hasOwnProperty(key) || property.$compute) && ((newVal != oldVal) || !snapshot._data.hasOwnProperty(key))) 
				delta[key] = newVal;
	}
}

function _computeReferenceDelta(_, instance, snapshot, snapshotType, relation, delta, fullLocale) {
	var key = relation.name;
	config.tracer && config.tracer("factory.compute delta on relation: "+key);
	var newVal = instance._data[key];
	if (newVal) {
		var oldVal = ((snapshot && snapshot._data[key]) || newVal[snapshotType]);
		if(relation.isChild) {
			var d = _computeDelta(_, newVal, snapshotType, oldVal, fullLocale);
			if (d !== {}) delta[key] = d;
		} else
			if(newVal.$uuid != (oldVal && oldVal.$uuid))
				// send serialization of thumb, not just an uuid
				delta[key] = _serialize(_, newVal, true);
				// delta[key] = {$uuid:newVal.$uuid};
	} else
		if((snapshot && snapshot._data.hasOwnProperty(key) && snapshot._data[key]) || (snapshot && !snapshot._data.hasOwnProperty(key)) || !snapshot)
			delta[key] = null;
	config.tracer && config.tracer("factory.compute delta on relation: "+key+"; exit");
}

function _computePluralDelta(_, instance, snapshot, snapshotType, relation, delta, fullLocale, forceDelta) {
	var key = relation.name;
	config.tracer && config.tracer("factory.compute delta on relation: "+key);
	// detect delta type
	// do not return $isDeleted elements anymore
	var newColl = instance[key](_).toArray(_, true); 
/*	var oldColl = (snapshot && snapshot[key](_).toArray(_));
	// is different ?
	if(newColl.some_(_, function(_, newElt, i) {
		if(newElt.$isDeleted) return true;
		var oldElt = oldColl && oldColl[i];
		if(!oldElt) return true;
		if(oldElt.$uuid !== newElt.$uuid) return true;
		//
		if(relation.isChild)
			return _computeDelta(_, newElt, snapshotType, oldElt, fullLocale) != {};
	}))*/
		delta[key] = newColl.map_(_, function(_, e) {
			if(e.$isDeleted)
				return { $uuid: e.$uuid, $isDeleted: true }
			else 
				return _serializeReference(_, e, relation);
		});
/*	if(instance[key](_)._isDelta || forceDelta) {
		var newColl = instance[key](_).toArray(_); 
		var oldColl = (snapshot && snapshot[key](_)._data);
//				var oldColl = (snapshot && snapshot[key](_));
		var deltaColl = [];
		newColl.forEach_(_, function(_, newElt) {
			var newId = newElt.$uuid;
			if (newElt.$isDeleted) 
				deltaColl.push({$uuid: newId,$isDeleted: true});
			else {
				var oldElt = oldColl && oldColl[newId];
				oldElt = (oldElt && (oldElt[snapshotType] || oldElt)) || newElt[snapshotType];
				if (relation.isChild || relation.$assoType) 
					deltaColl.push(_computeDelta(_, newElt, snapshotType, oldElt, fullLocale));
				else 
					if (newElt && ((oldElt && (newElt.$uuid != oldElt.$uuid)) || !oldElt)) 
						deltaColl.push(_serialize(_,newElt, true));
			}
		});
		if (deltaColl.length)
			delta[key] = deltaColl;
	} else {
		var newColl = instance[key](_).toArray(_, true); 
		delta[key] = newColl.map_(_, function(_, e) {
			return _serialize(_, e, true);
		});
	}
*/
	config.tracer && config.tracer("factory.compute delta on relation: "+key+"; exit");
}

function _computeSaveDelta(_, instance, snapshotValue) {
	config.tracer && config.tracer("factory.computeSaveDelta: "+instance.$uuid);
	var snapshotType = "$snapshot";
	var snapshot = snapshotValue || instance[snapshotType];
	var meta = instance._meta;
	var delta = {};
	if (snapshot) {
		flows.eachKey(_, meta.$properties, function(_, key, property) {
			if(property.$compute) return;
			_computePropertyDelta(_, instance, snapshot, delta, property, true);
		});
	}
	flows.eachKey(_, meta.$relations, function(_, key, relation){
		if (relation.isPlural) {
			//_computePluralDelta(_, instance, snapshot, snapshotType, relation, delta, true, true);
			// if a relation is in instance._dirtyList, it should ALWAYS be fully serialized instead of coputing delta
			delta[key] = instance[key](_).toArray(_, true).map_(_, function(_, e) {
				return relation.isChild ? _serialize(_, e, true) : { $uuid: e.$uuid }
			});
		} else
			_computeReferenceDelta(_, instance, snapshot, snapshotType, relation, delta, true);
	});
	if (delta !== {}) {	
		delta.$url = instance.$url;
		delta.$key = instance.$key;
		delta.$uuid = instance.$uuid;
		delta.$type = instance.$type;
		delta.$etag = instance.$etag;
		delta.$creUser = instance.$creUser;
		delta.$creDate = instance.$creDate;
		delta.$updUser = instance.$updUser;
		delta.$updDate = instance.$updDate; 
//		delta.$isDelta = true;
	}
	if(meta.$key)
		// TODO: make a "resolveInstance" function to template, to avoid use of _data
		delta.$key = (new Template(meta.$key)).resolve(instance._data);
	//
	config.tracer && config.tracer("factory.computeSaveDelta exit: "+instance.$uuid+"; "+sys.inspect(delta));
	return delta;
}

// async for computed values
// use snapshotType instead of snapshot as we can have snapshots for
// childrens w/o snapshot for main instance
function _computeDelta(_, instance, snapshotType, snapshotValue, fullLocale, forceDelta) {
	config.tracer && config.tracer("factory.computeDelta: "+instance.$uuid);
	var snapshot = snapshotValue || instance[snapshotType];
	var meta = instance._meta;
	var delta = {};
	var delta$ = {};
	if (snapshot) {
		flows.eachKey(_, meta.$properties, function(_, key, property) {
			_computePropertyDelta(_, instance, snapshot, delta, property, fullLocale);
			// meta
			var newMeta = instance.$properties[key];
			var oldMeta = snapshot.$properties[key];
			delta$[key] = _delta(oldMeta, newMeta);
		});
		if(instance.hasOwnProperty("$index"))
			if(instance.$index != snapshot.$index)
				delta.$index = instance.$index;
	}
	// compute delta on relations even if no snapshot provided for the main instance 
	flows.eachKey(_, meta.$relations, function(_, key, relation){
		// TODO : there seems to be a problem as we have deltas on relations even if there is no difference
		if (relation.isPlural) {
			_computePluralDelta(_, instance, snapshot, snapshotType, relation, delta, fullLocale, forceDelta);
		} else
			_computeReferenceDelta(_, instance, snapshot, snapshotType, relation, delta, fullLocale);
		var newMeta = instance.$properties[key];
		var oldMeta = snapshot && snapshot.$properties[key];
		delta$[key] = _delta(oldMeta, newMeta);
	});
	//
	if (delta$ !== {})
		delta.$properties = delta$;
	if (delta !== {}) {	
		delta.$url = instance.$url;
		delta.$key = instance.$key;
		delta.$uuid = instance.$uuid;
		delta.$type = instance.$type;
		delta.$etag = instance.$etag;
		delta.$creUser = instance.$creUser;
		delta.$creDate = instance.$creDate;
		delta.$updUser = instance.$updUser;
		delta.$updDate = instance.$updDate; 
//		delta.$isDelta = true;
	}
	if (instance.$diagnoses && instance.$diagnoses.length)
		delta.$diagnoses = instance.$diagnoses;
	//	
	_getPropertiesResourceMeta(_, delta, instance);
	// compute $key
	if(meta.$key)
		// TODO: make a "resolveInstance" function to template, to avoid use of _data
		delta.$key = (new Template(meta.$key)).resolve(instance._data);
	//
	config.tracer && config.tracer("factory.computeDelta exit: "+instance.$uuid+"; "+sys.inspect(delta));
	return delta;
}

function _errorCount(instance){
	if(instance.$properties && (typeof instance.$properties === "object"))
		return (Object.keys(instance.$properties).reduce(function(prev, current) {
			return prev +  (instance.$properties[current].$diagnoses || []).filter(function(diag){
				return diag.severity == "error" || diag.severity == "fatal";
			}).length;
		}, 0)) +  (instance.$diagnoses || []).filter(function(diag){
			return diag.severity == "error" || diag.severity == "fatal";
		}).length;
	else
		return 0;
}

function _existsError(_, instance){
	if ((instance.$diagnoses || []).some(function(diag){
		return diag.severity == "error" || diag.severity == "fatal";
	}))
		return true;
	//
	var hasErr = false;
	if (instance.$properties)
		flows.eachKey(_, instance.$properties, function(_, key, item) {
			hasErr = hasErr || ((item && item.$diagnoses) || []).some(function(diag){
				return diag.severity == "error" || diag.severity == "fatal";
			});
		})
	if (hasErr)
		return true;
	// recurse relations
	flows.eachKey(_, (instance._meta.$relations || {}), function(_, key, rel) {
		if (rel.isChild)
			if (rel.isPlural) {
				instance[key](_).toArray(_).forEach_(_, function (_, item) {
					hasErr = hasErr || _existsError(_, item);
				});
			} else
				hasErr = hasErr || (instance[key](_) && _existsError(_, instance[key](_)));
	});
	if (hasErr)
		return true;
	//
	return false;
}

function _safeCall(_, instance, propName, fn, field, val){
	if (!instance[field]) {
		instance[field] = [];
	}
	else {
		if (instance[field].indexOf(propName) >= 0) 
			throw new Error(field.substring(1) + " loop on " + propName);
	}
	instance[field].push(propName);
	try {
		return fn(_, instance, val);
	}
	finally {
		instance[field].pop();
	}
}

function _fireOnDelete(_, instance) {
	flows.eachKey(_, instance._meta.$relations, function(_, relName, rel) {
		if(rel.isChild && rel.targetEntity.$functions && rel.targetEntity.$functions.$onDelete) {
			var relInst = instance[relName](_);
			if(!relInst) return;
			if(rel.isPlural) 
				relInst.toArray(_, false).forEach_(_, function(_, item) {
					item.$isDeleted && item.$onDelete && item.$onDelete(_);
				})
			else
				relInst.$isDeleted && relInst$onDelete && relInst.$onDelete(_);
		}
	});
	instance.$onDelete && instance.$onDelete(_);
}

function _validateRelation(_, instance, relation, name, value) {
	if(relation.$compute)
		return true;
	if (instance.$validated[name])
		return true;
	//
	instance.$validated[name] = true;
	//
	config.tracer && config.tracer("factory._validateRelation enter: "+name+":"+relation.name);
	//
	var mandatory = relation.$isMandatory;
	if(typeof mandatory === "function")
		mandatory = mandatory(_, instance);
	if(mandatory)
		if(!value)
			instance.$addError(name + " is mandatory", name);
}
function _validateProperty(_, instance, property, name, value) {
	if (property.$compute)
		return true;
	if (instance.$validated[name])
		return true;
	//
	instance.$validated[name] = true;
	//
	config.tracer && config.tracer("factory._validateProperty enter: "+name+":"+property.name);
	//
//	var value = instance[name](_);
	var type = types[(property.type || "string")];
	if (type) {
		var errors = [];
		var c = property.getAllConstraints();
		if(c.$isMandatory && (typeof c.$isMandatory === "function"))
			c.$isMandatory = c.$isMandatory(_, instance);
		if(c.$isDefined && (typeof c.$isDefined === "function"))
			c.$isNullable = c.$isNullable || !c.$isDefined(_, instance);
		if(property.$isArray && Array.isArray(value))
			value.forEach(function(v) {
				type.validate(v, c, errors);
			});
		else
			type.validate(value, c, errors);
		if (errors.length) {
			config.tracer && config.tracer("factory._validateProperty errors: "+sys.inspect(errors));
			errors.forEach(function(error) {
				// crnit:extended error message is needed for import; TODO: as error is associated with property meta, 
				// leave simple error message but correctly extract it for import
//				instance.$addError(instance._meta.name+"."+property.name+":"+error, property.name);
				instance.$addError(error, property.name);
			});
			return instance.$validated[name] = false;
		} 	
	}
	// unique validate, not for childrens where the validation must be done for the childrens list of the parent
	if (!instance._parent) {
		var filter = {};
		var propNames = [];
		var propFiltered = false;
		if(property.$isUnique) {
			filter.jsonWhere = filter.jsonWhere || {};
			if(property.$isLocalized)
				filter.jsonWhere[property.name+"."+locale.current] = value;
			else	
				filter.jsonWhere[property.name] = value;
			propNames.push(property.name);
			propFiltered = true;
		}
		instance._meta.$uniqueConstraints && instance._meta.$uniqueConstraints.forEach_(_, function(_, ui) {
			// property is part of an unique index ?
			if(ui.indexOf(property.name) >= 0) {
				ui.forEach_(_, function(_, p) {
					if((p === property.name) && propFiltered) return;
					var prop = instance._meta.$properties[p] || instance._meta.$relations[p];
					if(!prop) return;
					propNames.push(p);
					var fval = (p === property.name) ? value : instance[p](_);
					if(fval && fval.$uuid) fval = fval.$uuid;
					filter.jsonWhere = filter.jsonWhere || {};
					if(prop.$isLocalized)
						filter.jsonWhere[prop.name+"."+locale.current] = fval;
					else	
						filter.jsonWhere[prop.name] = fval;
				});
			}
		});
		if(filter.jsonWhere) {
			filter.jsonWhere.$uuid = {$ne:instance.$uuid};
			var testInstance = instance._db.fetchInstance(_, instance._meta, filter);
			if (testInstance) {
				instance.$addError(locale.format(module, "uniqueKeyViolation", instance._meta.name, propNames.join(",")), property.name);
				return instance.$validated[name] = false;
			}
		}
	}
	//
	return true;
}
// check mandatory props
function _validateMandatory(_, instance){
	config.tracer && config.tracer("factory._validateMandatory: "+instance._meta.name);
	flows.eachKey(_, instance._meta.$properties, function(_, name, property) {
		_validateProperty(_, instance, property, name, instance[name](_));
	});
	flows.eachKey(_, instance._meta.$relations, function(_, name, relation) {
		var mandatory = relation.$isMandatory;
		if(typeof mandatory === "function")
			mandatory = mandatory(_, instance);
		if (mandatory || relation.isChild) {
			var relValue = instance[name](_);
			if (mandatory) {
				if ((relation.isPlural && relValue.isEmpty()) || (relValue == null)) 
					instance.$addError(name + " is mandatory", name);
			}
			if(relation.isChild && relValue) {
				if (relation.isPlural) {
					var values = relValue.toArray(_);
					values.forEach_(_, function(_, value){
						_validateMandatory(_, value);
						instance._errorCount += value._errorCount;
					});
				}
				else {
					_validateMandatory(_, relValue);
					instance._errorCount += relValue._errorCount;
				}					
			}
		}			 
	});
}

function _clone(obj){
	var result = {};
	forEachKey(obj, function(key, val){
		if (Array.isArray(val)) 
			result[key] = val.map(function(elt){
				return _clone(elt)
			});
		else if (val != null && typeof val === "object") 
			result[key] = _clone(val);
		else 
			result[key] = val;
	});
	return result;
}

function Factory(meta){
	// wrapper to generic stream implementation
	function PropertyStore(instance, property) {
		this.instance = instance;
		this.property = property;
		// needs refreshing on compute delta. Normaly updated on propagate. Cleared by compute delta
		this.invalid = false;
	}
	var streamerProto = PropertyStore.prototype;
	streamerProto.init = function(_, fileName) {
		var property = this.property;
		var instance = this.instance;
		// create the proper factory
		var storageType = property.$storage && ((typeof property.$storage === "function") ? property.$storage(_, instance) : property.$storage);
		config.tracer && config.tracer("propertyStore.init: create store of "+storageType+" type");
		this._store = storageType && fileStoreFactory.createFileStore(instance, property, storageType);
		if(fileName != null) this._store.setFile(_, fileName);
	}
	streamerProto.getUuid = function() {
		return this._store && this._store.fileName;
	}
	/// -------------
	/// ## Stream property getProperties function :
	/// ``` javascript
	/// var props = anInstance.content(_).getProperties(_); 
	/// ```
	/// 
	/// Returns the stored element properties (file size, content type, ...)  
	/// 
	streamerProto.getProperties = function(_) {
		return this._store.getProperties(_);
	}
	/// -------------
	/// ## Stream property fileExists function :
	/// ``` javascript
	/// var isThere = anInstance.content(_).fileExists(_); 
	/// ```
	/// 
	streamerProto.fileExists = function(_) {
		return this._store.fileExists(_);
	}
	/// -------------
	/// ## Stream property createWorkingCopy function :
	/// ``` javascript
	/// anInstance.content(_).createWorkingCopy(_); 
	/// ```
	/// 
	/// creates a new file for storage, to use for two phase update: when using a workingCopy, one must have persist changes of the file
	/// before invoke "Save" on the object. So we should create a new file for update, then "Save" will persist object's pointer to the new file.
	/// 
	streamerProto.createWorkingCopy = function(_) {
		var instance = this.instance;
		// allready in working copy ?
		if (instance._snapshotEnabled && instance.$snapshot) return;
		// create snapshot
		if (instance._snapshotEnabled && !instance.$snapshot) 
			instance.$snapshot = _createSnapshot(_, instance, "$snapshot");
		//
		instance._data[this.property.name] = {$uuid:""};
//		instance._data[this.property.name] = {};
		this._store.setFile(_, "");
	}
	/// -------------
	/// ## Stream property createReadableStream function :
	/// ``` javascript
	/// var stream = anInstance.content(_).createReadableStream(_); 
	/// var buf;
	/// while(buf = stream.read(_))
	///   doSomething(buf);
	/// ```
	/// 
	streamerProto.createReadableStream = function(_) {
		return this._store.createReadableStream(_);
	}
	/// ------------
	/// ## Stream property createWritableStream function :
	/// ``` javascript
	/// var stream = anInstance.content(_).createWritableStream(_); 
	/// while(buf = something)
	///   stream.write(_, buf, encoding);
	/// stream.end(lastMessage, encoding, _);
	/// ```
	///
	/// NOTE: the "end" signature isn't standard as normaly doesn't take a callback. But Mongodb "GridFS" driver needs it
	/// so make sure you passe a callback in las parameter of "end"
	/// 
	streamerProto.createWritableStream = function(_, options) {
		var instance = this.instance;
		if (instance._snapshotEnabled && !instance.$snapshot) 
			instance.$snapshot = _createSnapshot(_, instance, "$snapshot");
		var opt = options || {};
		opt.referingInstance = {className: this.instance._meta.name, property: this.property.name, uuid: this.instance.$uuid};
		//
		if(!this._store.fileName) {
			this._store.setFile(_, (instance._data[this.property.name] = {$uuid:helpers.uuid.generate()}).$uuid);
			config.tracer && config.tracer("propertyStore.createFile: "+this._store.fileName+" check property uuid: "+instance._data[this.property.name].$uuid);
		}
		// TODO: propagate is done before writing the content and passes the options. Is this the right thing to do ?
		if(this.property && this.property.$propagate)
			this.property.$propagate(_, this.instance, options);
		//
		return this._store.createWritableStream(_, options);
	}
	streamerProto.uploadDone = function(_) {
		this.property.$uploadDone && this.property.$uploadDone(_, this.instance);
	}
	//
	streamerProto.deleteFile = function(_) {
		this._store.deleteFile(_);
	}
	streamerProto.close = function(_) {
		this._store.close(_);
	}
	streamerProto.attach = function(_, store) {
		var instance = this.instance;
		if (instance._snapshotEnabled && !instance.$snapshot) 
			instance.$snapshot = _createSnapshot(_, instance, "$snapshot");
		var opt = store.getProperties(_) || {};
		opt.referingInstance = {className: this.instance._meta.name, property: this.property.name, uuid: this.instance.$uuid};
		// use the same file (store) as the source store
		this._store.setFile(_, (instance._data[this.property.name] = {$uuid: store._store.fileName}).$uuid);
		config.tracer && config.tracer("propertyStore.createFile: "+this._store.fileName+" check property uuid: "+instance._data[this.property.name].$uuid);
		// TODO: propagate is done before writing the content and passes the options. Is this the right thing to do ?
		if(this.property && this.property.$propagate)
			this.property.$propagate(_, this.instance, opt);
		// force writing the new metadata and closes the stream
		this._store.writeMetadata(_, opt);
	}
	// Collections prototype
	function InstanceCollection(instance, name, relMeta, value) {
		this._data = null;
		this._deletedInstances = {};
		this._asso = {};
		this._array = [];
		this._relName = name;
		this._relMeta = relMeta;
		this._parent = instance;
		this._ordered = true;
		// loaded allows lazyLoad of computed relations (association use case when list is loaded by querying opposite table)
		this.loaded = !relMeta.isComputed;
		//
		this._isDelta = true;
		//
		var self = this;
		if (Array.isArray(value)) 
			this._array = value.map(function(elt) {
				return instance.syncCreateChild(self._relMeta.name, elt.$uuid, elt);
			});
		else 
			for (var key in value) {
				if((key[0] != "$") && (key[0] != "_")) {
					self._array.push(instance.syncCreateChild(self._relMeta.name, key, relMeta.isChild ? value[key]:null));
				}
			}
	}
	//
	function _createParentSnapshot(_, collection) {
		var parent = collection._parent;		
		if (parent._snapshotEnabled && !parent.$snapshot) 
			parent.$snapshot = _createSnapshot(_, parent, "$snapshot");
		config.tracer && config.tracer("factory.collection createParentSnapshot exit");
	}
	function _computeCollection(_, collection) {
		if (collection._parent && collection._parent.$uuid) {
			var filter = {};
//			filter[collection._relMeta.$inv + (collection._relMeta.targetEntity.$relations[collection._relMeta.$inv].isPlural?".$keys":".$uuid")] = collection._parent.$uuid;
			filter[collection._relMeta.$inv + ".$uuid"] = collection._parent.$uuid;
			config.tracer && config.tracer("factory.collection fetchOpposite: parent:" + collection._parent.$uuid);
			var instArray = collection._parent._db.fetchInstances(_, collection._relMeta.targetEntity, {jsonWhere: filter});
			collection._array = instArray.slice(0);
			collection.loaded = true;
		}
	}
	//	
	var _collProto = InstanceCollection.prototype;
	//
	function _getCollEltValue(_, coll, elt) {
		var self = coll;
		var val = elt;
		var v = self._parent._snapshotType?(val[self._parent._snapshotType] || _createSnapshot(_, val, self._parent._snapshotType)) : val;
		// lazy load associations 
		if (!self._relMeta.isChild && v && !v.$isDeleted) {
			v.ensureLoaded(_);
		}
		return v;
	}
	/// -------------
	/// ## Collections toArray function :
	/// ``` javascript
	/// var array = anInstance.myList(_).toArray(_); 
	/// ```
	/// 
	/// returns an array of elements or an array of snapshots if the parent is an snapshot
	/// 
	_collProto.toArray = function(_, excludeDeleted) { 
		var self = this;
		var result = [];
		config.tracer && config.tracer("factory._toArray(" + excludeDeleted + ") enter");
		//
		if(!self._ordered && !self._relMeta.$canReorder && self._relMeta.defaultOrder && self._relMeta.defaultOrder.length) {
			// ensure loaded for all
			if (!self._relMeta.isChild) 
				self._array.forEach_(_, function(_, v) {
				if(v && !v.$isDeleted)
					v.ensureLoaded(_);
				});
			self._array.sort_(_, function(_, a, b) {
				// for now only supports properties, 
				// TODO : implement proper typed comparaison
				// TODO : ascending / descending 
				return self._relMeta.defaultOrder.reduce_(_, function(_, prevValue, value) {
					if(prevValue) return prevValue;
					var p = value[0];
					if(a[p](_) < b[p](_)) return -1;
					if(a[p](_) > b[p](_)) return 1;
					return 0;
				},0);
				self._ordered = true;
			});
		}
		self._array.forEach_(_, function(_, val) {
			if(excludeDeleted && val.$isDeleted) return;
			result.push(_getCollEltValue(_, self, val));
		});
		//
		config.tracer && config.tracer("factory._toArray(" + excludeDeleted + ") result: "+sys.inspect(result.map(function(r) {
			return {
				$uuid: r.$uuid,
				_data: r._data,
				$index: r.$index,
				$isDeleted: r.$isDeleted
			}
		})));
		return result; 
	}
	/// -------------
	/// ## Collections toUuidArray function :
	/// ``` javascript
	/// var array = anInstance.myList(_).toUuidArray(_); 
	/// ```
	/// 
	/// return an array of uuids (to avoid instanciation)
	/// 
	_collProto.toUuidArray = function(_, excludeDeleted) { 
		var self = this;
		return (excludeDeleted ? self._array.filter(function(e) { return !e.$isDeleted; }) : self._array).map(function(e) {
			return e.$key || e.$uuid;
		});
	}
	/// -------------
	/// ## Collections refresh function :
	/// ``` javascript
	/// anInstance.myList(_).refresh(_); 
	/// ```
	/// 
	/// for computed relations, reloades the objects list. Does nothing for stored relations
	/// 
	_collProto.refresh = function(_) {
		config.tracer && config.tracer("factory.collection refresh; _parent: "+this._parent.$uuid);
		if(this._relMeta.isComputed)
			_computeCollection(_, this);
		// chaining
		return this;
	}
	/// -------------
	/// ## Collections deleteInstance function :
	/// ``` javascript
	/// anInstance.myList(_).deleteInstance(_, instanceId); 
	/// ```
	/// 
	/// removes the instance identified by instanceId from the collection
	/// 
	_collProto.deleteInstance = function(_, instanceId) {
		if(!instanceId)
			return;
		// create a snapshot for the parent
		config.tracer && config.tracer("factory.collection deleteInstance; _parent: "+this._parent.$uuid+" $uuid: "+instanceId);
		_createParentSnapshot(_, this);
		// if delete on computed relation, make the delete to the opposite side
		var relInst = this.get(_, instanceId);
		if(relInst) {
			if(this._relMeta.isComputed) {
				config.tracer && config.tracer("factory.collection deleteInstance on computed relation: "+this._relName);
				relInst._snapshotEnabled = true;
				relInst._sysSnapshotEnabled = true;
				if(relInst._meta.$relations[this._relMeta.$inv].isPlural)
					relInst[this._relMeta.$inv](_).deleteInstance(_, this._parent.$uuid);
				else
					relInst[this._relMeta.$inv](_, null);
				this._parent.addRelatedInstance(relInst);
			} else
				this._parent.addReindexInstance(relInst);
			//
			relInst.$isDeleted = true;
		} 
		//
		config.tracer && config.tracer("factory.collection deleteInstance exit ; _parent: "+this._parent.$uuid+" $uuid: "+instanceId);
	}
	/// -------------
	/// ## Collections reset function :
	/// ``` javascript
	/// anInstance.myList(_).reset(_); 
	/// ```
	/// 
	/// Removes all elements from the collection
	/// 
	_collProto.reset = function(_) { 
		// create a snapshot for the parent
		_createParentSnapshot(_, this);
		//
		this._data = null;
		this._array = [];
	}
	//
	function _buildCollMap(_, coll) {
		coll._data = {};
		coll._array.forEach(function(e) {
			coll._data[e.$uuid] = e;
		});
	}
	/// -------------
	/// ## Collections get function :
	/// ``` javascript
	/// var elem = anInstance.myList(_).get(_, uuid); 
	/// ```
	/// 
	_collProto.get = function(_, uuid) {
		if(!uuid) return null;
		//
		this._data || _buildCollMap(_, this);
		//
		var relation = this._relMeta;
		var val = this._data[uuid];
		var val = this._parent._snapshotType?(val[this._parent._snapshotType] || _createSnapshot(_, val, this._parent._snapshotType)) : val;
		// lazy load associations 
		if (!relation.isChild && val && !val.$isDeleted) {
			val.ensureLoaded(_);
		}
		//
		config.tracer && config.tracer("factory.collection.get: "+uuid+"; "+(val && val.$inspect && val.$inspect(false)));
		return val;
	}
	/// -------------
	/// ## Collections add function :
	/// ``` javascript
	/// var newElem = anInstance.collection(_).add(_); 
	/// ```
	/// Creates a new element and adds it to the collection  
	/// 
	/// Returns the created new element  
	/// 
	_collProto.add = function(_) {
		return this.set(_, this._parent.createChild(_, this._relMeta.name));
	}
	/// -------------
	/// ## Collections set function :
	/// ``` javascript
	/// var array = anInstance.myList(_).set(_, anInstance); 
	/// ```
	/// 
	// isInverse : called from the inverse relation set, so don't propagate 	
	// TODO: create an internal function so isInverse would not be exposed
	_collProto.set = function(_, value, isInverse) {
		if(!value) 
			throw Error("Cannot set an undefined value for a collection; use deleteInstance instead.");
		config.tracer && config.tracer("factory.collection.set: value: "+value.$inspect(true)+"; isInverse:"+sys.inspect(isInverse));
		// create a snapshot for the parent
		_createParentSnapshot(_, this);
		//
		var k = value.$key || value.$uuid;
		this._data || _buildCollMap(_, this);
		if(!this._data[k]) {
			// insert
			this._array.splice((value.$index != null ? value.$index : this._array.length), 0, value);
		}
		this._data[k] = value;
		//
		if (!isInverse && this._relMeta.$inv && value._meta.$relations[this._relMeta.$inv]) {
			config.tracer && config.tracer("factory.collection.set inverse relation");
			// set inverse relation
			if (value._meta.$relations[this._relMeta.$inv].isPlural) {
				// create the inverse relation if *-*
				// use the getter to lazy load
				this.get(_, k)[this._relMeta.$inv](_).set(_, this._parent, true);
			}
			else
				this.get(_, k)[this._relMeta.$inv](_, this._parent, true);
			// to persist
			if (!this._relMeta.isChild && !value._meta.$relations[this._relMeta.$inv].isComputed)
				this._parent.addRelatedInstance(value);
			else
				this._parent.addReindexInstance(value);
		}
		if (this._relMeta.$propagate) {
			var svPropagate = this._relMeta.$propagate;
			this._relMeta.$propagate = null;
			_safeCall(_, this._parent, this._relMeta.name, svPropagate, "_propagating", value);
			this._relMeta.$propagate = svPropagate;
		}
		// indicate to reorder to the next read
		this._ordered = false;
		// allow chaining
		return value;
	}
	_collProto.setArray = function(_, values) {
		this.reset(_);
		//
		var self = this;
		if(typeof values === "object") {
			values.$items.forEach_(_, function(_, item) {
				var searchParam = {jsonWhere:{}};
				searchParam.jsonWhere[values.$key] = item;
				var inst = self._parent._db.fetchInstance(_, self._relMeta.targetEntity, searchParam);
				if(!inst) throw new Error(self._relMeta.targetEntity.name+" "+item+" not found");
				self.set(_, inst);
			});
		} else
			throw new Error("collection.setArray of instances NIY");
	}
	/// -------------
	/// ## Collections filter function :
	/// ``` javascript
	/// var options = {
	///     jsonWhere: {
	///       title: "some title"
	///     }
	/// }
	/// var array = anInstance.myList(_).filter(_, options); 
	/// ```
	/// 
	/// returns an array of collection elements filtered with an expression. Doesn't affect the collection itself
	///
	/// * options - object allowing to pass the filter as one of the properties
	/// - jsonWhere : json like
	/// - sdataWhere : string of sdata syntax
	/// - where : parsed tree of sdata syntax
	/// 
	_collProto.filter = function(_, options) {
		var self = this;
		var result = [];
		//
		if(!options || !options.jsonWhere) return this.toArray(_);
		//
		var filter = options.jsonWhere;
		config.tracer && config.tracer("factory.collection.filter processed filter: "+sys.inspect(filter));
//		flows.eachKey(_, self._data, function(_, key, value){
		self._array.forEach_(_, function(_, inst){
			// filter instance
			var add = true;
			flows.eachKey(_, filter, function(_, filterKey, filterValue) {
				var tempInst = inst;
				// TODO: optimize - take the filterItem compute out of the main loop
				var filterItem = filterKey.split(".");
				var term;
				while(term = filterItem.shift()) {
					if(!tempInst) break;
					config.tracer && config.tracer("factory.collection.filter testing term: "+term+" on "+tempInst.$uuid);
					if(!tempInst._meta.$properties[term] && !tempInst._meta.$relations[term])
						throw new Error(locale.format(module, "unknownFilterTerm", term, tempInst._meta.name));
					if(tempInst._meta.$properties[term]) {
						// is final prop
						if(tempInst._meta.$properties[term].$isLocalized) {
							var loc = filterItem.shift();
							add = add && ((loc ? _getLocalizedProp(_, tempInst, term, tempInst._meta.$properties[term], loc) : tempInst[term](_)) === filterValue);
						} else
							add = add && (tempInst[term](_) === filterValue);
						break;
					} else
						if(tempInst._meta.$relations[term] && !tempInst._meta.$relations[term].isPlural) {
							// walk
							tempInst = tempInst[term](_);
						}
				}
			});
			config.tracer && config.tracer("factory.collection.filter testing: "+sys.inspect(filter)+" on "+inst.$uuid+"="+add);
			if(add) result.push(inst);
		});
		return result;
	}
	/// -------------
	/// ## Collections isEmpty function :
	/// ``` javascript
	/// var empty = anInstance.myList(_).isEmpty(); 
	/// ```
	/// 
	_collProto.isEmpty = function() {
//		return (Object.keys(this._data).length == 0);
		return this._array.length == 0;
	}
	/// -------------
	/// ## Collections getLength function :
	/// ``` javascript
	/// var array = anInstance.myList(_).getLength(); 
	/// ```
	/// 
	_collProto.getLength = function(){
//		return Object.keys(this._data).length;
		return this._array.length;
	}
	// ensure locale key is in lowercase
	function _fixLocalized(p, v) {
		if(!p.$isLocalized) return v;
		var r = {};
		Object.keys(v).forEach(function(k) {
			r[k.toLowerCase()] = v[k];
		});
		return r;
	}
	// instance prototype
	function Instance(data, $, connection, context){
//		config.tracer && config.tracer("factory.Instance().connection:"+sys.inspect(connection));
		this._propagateTick = 0;
		this.$etag = 1;
		// _meta is entity here
		this._meta = meta;
		// functions bind
		this._errorCount = 0;
		this.$properties = $ || {};
		// property to avoid multiple validation
		this.$validated = {};
		//
		this._data = {};
		this._propertyStores = {};
		this.$attr = {};
		// database connection, usefull for lazy loads
		this._db = connection;
		this._context = context;
		// other instances to persist with the main instance
		this._relatedInst = {};
		// instances that we should reindex
		this._reindexInst = {};
		//
		var self = this;
		//
		forEachKey(meta.$functions, function(name, fn) {
			self[name] = fn.bind(self); // can bind it
		});
		forEachKey(meta.$methods, function(name, fn) {
			self.prototype[name] = fn; // natural usage will bind it
		});
		// should replace with _load but is async. So remove this later as we won't pass data anymore
		if(data) {
			forEachKey(data, function(key,value) {
				var r = meta.$relations && meta.$relations[key];
				if (value && r && r.isPlural && Array.isArray(value)) {
					self._data[key] = new InstanceCollection(self, key, r, value);
				}
				else 
					if (value && r) {
						var rel = r;
						if (rel.isPlural) 
							self._data[key] = new InstanceCollection(self, key, rel, value);
						else {
							var id = rel.targetEntity.$key ? (new Template(rel.targetEntity.$key)).resolve(value) : value.$uuid;
							// check null relation
							if (!id && !value.$url)
								self._data[key] = null;
							else 
								self._data[key] = self.syncCreateChild(key, id, value);
						}
					}
					else {
						if (key[0] === "$") 
							self[key] = value;
						else {
							var p = meta.$properties && meta.$properties[key];
							if(p) {
								if(p.isExternalStorage()) {
									// compat, change of storage format
									if(typeof value === "string")
										self._data[key] = {$uuid: value}
									else
										self._data[key] = value;
								} else {
									if(p.$isArray && Array.isArray(value))
										self._data[key] = value.map(function(v) {
											return resourceHelpers.parseValue(p, _fixLocalized(p, v));
										});
									else
										self._data[key] = resourceHelpers.parseValue(p, _fixLocalized(p, value));
								}
							} else
								self._data[key] = value;
						}
					}
			});
			self.$initialUpdDate = this.$updDate;
			self.$updUser = this.$updUser || this.$creUser;
		}
		//
		//this.$key = this.$uuid;
		self.$key = self.computeKey();
		//
		this._snapshotEnabled = true;
		this._sysSnapshotEnabled = true;
	}
	var _proto = Instance.prototype;

	/// -------------
	/// ## Instance getEntity function :
	/// ``` javascript
	/// var entity = anInstance.getEntity(); 
	/// ```
	/// 
	_proto.getEntity = function() {
		return this._meta;
	}
			
	_proto.computeKey = function() {
		return (meta.$key ? (new Template(meta.$key)).resolve(this._data) : this.$uuid);
	}
	
	_proto.computeUrl = function() {
		return [this._db.baseUrl, this._meta.plural + "('"+this.computeKey()+"')"].join("/") + "?representation="+this._meta.name+".$details";
	}
	
	_proto._load = function(_, data) {
		// TODO !!!!!
		throw new Error("NYI");
	}		
	
	
	// run validations before save
	function _validateBeforeSave(_, instance) {
		config.tracer && config.tracer("factory._validateBeforeSave: "+instance._meta.name);
		// revalidate all props as they might never been set
		flows.eachKey(_, instance._meta.$properties, function(_, name, property) {
			_validateProperty(_, instance, property, name, instance[name](_));
		});
		//
		flows.eachKey(_, instance._meta.$relations, function(_, name, relation) {
			var mandatory = relation.$isMandatory;
			if(typeof mandatory === "function")
				mandatory = mandatory(_, instance);
			if (mandatory || relation.isChild) {
				var relValue = instance[name](_);
				if (mandatory) {
					if ((relation.isPlural && relValue.isEmpty()) || (relValue == null)) 
						instance.$addError(name + " is mandatory", name);
				}
				if(relation.isChild && relValue) {
					if (relation.isPlural) {
						var values = relValue.toArray(_);
						values.forEach_(_, function(_, value){
							_validateBeforeSave(_, value);
							instance._errorCount += value._errorCount;
						});
					}
					else {
						_validateBeforeSave(_, relValue);
						instance._errorCount += relValue._errorCount;
					}					
				}
			}			 
		});
		// control rule 
		if(instance._meta.$control)
			instance._meta.$control(_, instance);
		//
		flows.eachKey(_, instance._relatedInst, function(_, key, value) {
			_validateBeforeSave(_, value);
			value.getAllDiagnoses(_, instance.$diagnoses, {
				addEntityName: true,
				addPropName: true
			});
//			if(value._errorCount)
//				instance.$addError("Related instance error: "+value.$uuid);
		});
		//
		if(instance._errorCount)
			config.tracer && config.tracer("factory._validateBeforSave errors: " + sys.inspect(instance.$properties));
		config.tracer && config.tracer("factory._validateBeforeSave exit: "+instance._meta.name);
	}
	// getters ****************************************************
	function _getExternalStorageProp(_, instance, name, property) {
		// getter
		var val;
		if(property.$compute) {
			val = property.$compute(_, instance);
			//
			config.tracer && config.tracer("factory._getExternalStorageProp("+name+"): $compute="+sys.inspect(val));
		} else {
			if(!(val = instance._propertyStores[property.name])) {
				val = instance._propertyStores[property.name] = new PropertyStore(instance, property);
				val.init(_);
			}
			//
			config.tracer && config.tracer("factory._getExternalStorageProp("+name+")="+sys.inspect(val));
		}
		return val;
	}
	/// -------------
	/// ## Instance getPropAllLocales function :
	/// ``` javascript
	/// var object = anInstance.getPropAllLocales(_, propName); 
	/// ```
	/// For localized properties, returns a map with all locales 
	///
	_proto.getPropAllLocales = function(_, propName) {
		var e = this.getEntity();
		var p = e.$properties[propName];
		if(!p) throw new Error(locale.format(module, "propertyNotFound", propName, e.name));
		return p.$compute ? p.$compute(_, instance, true) : this._data[propName];
	}
	//
	function _getLocalizedProp(_, instance, name, property, localeCode) {
		// getter
		var val = instance._data[name] && (instance._data[name][(localeCode || globals.context.sessionLocale || locale.current).toLowerCase()] || instance._data[name]["default"]);
		if (instance._snapshotType && val)
			val = val[instance._snapshotType] || val;
		//
		config.tracer && config.tracer("factory._getLocalizedProp("+name+")="+val);
		return val;
	}
	function _getProp(_, instance, name, property) {
		// getter
		var val = instance._data[name];
		if (instance._snapshotType && val)
			val = val[instance._snapshotType] || val;
		//
		config.tracer && config.tracer("factory._getProp("+name+")="+val);
		return val;
	}
	function _getRel(_, instance, name, relation){
		config.tracer && config.tracer("factory._getRel enter: "+instance.$uuid+"."+name);
		// getter
		if (relation.$compute) 
			return _safeCall(_, instance, relation.name, relation.$compute, "_computing");
		if (relation.isPlural) {
			// returns InstanceCollection, not an array
			if (!instance._data[name]) 
				instance._data[name] = new InstanceCollection(instance, name, relation);
			// lazy loads collection
			if (!instance._data[name].loaded) 
				_computeCollection(_, instance._data[name]);
				config.tracer && config.tracer("factory._getRel collection: "+name+";"+
					sys.inspect(instance._data[name]._array.map(
						function(item){
							return {$uuid:item.$uuid, $loaded: item.$loaded}
						}
					)));
			return instance._data[name];
		}
		else {
			var val = instance._data[name];
			if (instance._snapshotType && val) {
				val = val[instance._snapshotType] || val
				// on get, if is child, create a snapshot in case someone gets a pointer
				if (relation.isChild)
					_createSnapshot(_, val, instance._snapshotType);
			}
			// lazy load associations 
			if (!relation.isChild && val && val.$key && !val.$loaded) {
				val.ensureLoaded(_);
				// if stil not loaded, the reference might not exists anymore (like it was deleted)
				if(!val.$loaded)
					val = null;
			}
			config.tracer && config.tracer("factory._getRel: "+name+";"+(val && val.$inspect && val.$inspect(false)));
			return val;
		}
	}
	// setters *********************************************************
	// set value
	function _prepareSetValue(_, instance, name, property, val, validateFunction) {
		if (instance._controlling && instance._controlling != property.name) {
			throw new Error("invalid attempt to assign " + property.name +
			" while controlling " +
			instance._controlling);
		}
		//
		var oldVal = instance._data[name];
		// allow setting null values
		if (instance._data.hasOwnProperty(name) && (oldVal === val)) 
			return false;
		// control (before setting new value)
		// TODO: doesn't work, see later
/*		instance._controlling = property.name;
		try {
			var errCount = _errorCount(instance);
			console.log("initial error count: "+errCount)
			// validation
			if (instance._meta.$properties[name])
				validateFunction(_, instance, property, name, val);
			console.log("after error count: "+_errorCount(instance));
			console.log("diags: "+sys.inspect(instance.$properties[name]));
			// control rule
			if (property.$control) 
				property.$control(_, instance, val);
		}
		finally {
			instance._controlling = null;
		}
		// check if validation has found errors
		if(errCount !== _errorCount(instance))
			return false;*/
		//
		if (instance._snapshotEnabled && !instance.$snapshot) 
			instance.$snapshot = _createSnapshot(_, instance, "$snapshot");
		//
		var $prop = (instance.$properties[name] = instance.$properties[name] || {});
		$prop.$diagnoses = [];
		// EXCEPTION: setting null when allready undefined shouldn't fire validation rules but should write in the null value
		if((oldVal == null) && (val == null)) {
			instance._data[name] = val;
			return false;
		}
		//
		instance.$validated[name] = false;
		//
		return true;
	}
	function _afterSetValue(_, instance, name, property, val, validateFunction) {
		// force lazy load for relations
		var val = instance[name](_);
		//
		instance._controlling = property.name;
		try {
			var errCount = _errorCount(instance);
			// validation
			if (instance._meta.$properties[name])
				validateFunction(_, instance, property, name, val);
			// control rule
			if (property.$control) 
				property.$control(_, instance, val);
		}
		finally {
			instance._controlling = null;
		}
		// propagate, is after value is set
		if (property.$propagate && errCount == _errorCount(instance)) {
//		if (property.$propagate) {
			var closure = function(_) {
				var svPropagate = property.$propagate;
				property.$propagate = null;
				_safeCall(_, instance, property.name, svPropagate, "_propagating", val);
				property.$propagate = svPropagate;
			}
			if(instance.deferPropagate) 
				instance.defer("deferPropagate", closure);
			else
				closure(_);
		}
	}
	_proto.setLocalizedProp = function(_, name, localeCode, val) {
		var instance = this;
		//
		var _data = instance._data[name] = (instance._data[name] || {});
		// normalize locale code to lowercase
		_data[localeCode.toLowerCase()] = val;
		if(!_data["default"]) _data["default"] = val;
		//
		config.tracer && config.tracer("factory.setLocalizedProp: "+name+","+localeCode+","+val+"; Actual value: "+sys.inspect(instance._data[name]));
	}
	function _setProp(_, instance, name, property, val) {
		// setter
		config.tracer && config.tracer("factory._setProp: "+name+","+sys.inspect(val));
		//
		if(property.$isArray && property.$sorted)
			val.sort(property.$sort || function(a, b) {
				return resourceHelpers.compare(property, a, b);
			});
		instance._data[name] = val;
	}	
	function _setRel(_, instance, name, property, val, isInverse) {
		// setter
		config.tracer && config.tracer("factory._set: "+name+","+sys.inspect(isInverse)+","+((val && val.$inspect && val.$inspect(true)) || sys.inspect(val))+")");
		//
		if(!_prepareSetValue(_, instance, name, property, val, _validateRelation)) return;
		//
		if (property.isPlural) {
			// set of array used in object initialisation
			throw (new Error("Instance: cannot set collection property"));
		}
		else {
			instance._data[name] = val;
			if(!isInverse) {
				val._parent = instance;
				val._relation = property;
			}
			if(property.$isDynamicType && val) val.$type = val.getEntity().name; 
			// replication
			if (property.$propagateInv) {
				if(property.$inv && val._meta.$relations[property.$inv] && val._meta.$relations[property.$inv].isPlural) {
					config.tracer && config.tracer("factory._set propagateInv to list; oldVal: "+(oldVal && oldVal.$uuid));
					if(oldVal) {
						config.tracer && config.tracer("factory._set remove from old list of: "+oldVal.$uuid);
						oldVal.ensureLoaded(_);
						oldVal[val._meta.$relations[property.$inv].name](_).deleteInstance(_, instance.$uuid);
						instance.addRelatedInstance(oldVal);
					}
					// add instance to new list
					if (!isInverse) {
						// use getter to lazy load
						instance[property.name](_)[val._meta.$relations[property.$inv].name](_).set(_, instance, true);
						// to persist
						instance.addRelatedInstance(instance[property.name](_));
					}				
				}
			}
		}
		// validation & control
		_afterSetValue(_, instance, name, property, val, _validateRelation);
	}
	forEachKey(meta.$properties, function(name, property){
		_proto[name] = function(_, val){
			if (arguments.length == 1) {
				//
				if (property.$compute) {
					config.tracer && config.tracer("factory.get compute prop: "+property.name);
					return _safeCall(_, this, property.name, property.$compute, "_computing");
				}
				//
				if(property.isExternalStorage())
					return _getExternalStorageProp(_, this, name, property);
				else
					if(property.$isLocalized)
						return _getLocalizedProp(_, this, name, property);
					else
						return _getProp(_, this, name, property);
			}
			else {
				// check
				if(!_prepareSetValue(_, this, name, property, val, _validateProperty)) return;
				// setter
				if(property.$isLocalized) {
					var self = this;
					// accept maps
					if(val && (typeof val == "object")) {
						Object.keys(val).forEach_(_, function(_, key) {
							self.setLocalizedProp(_, name, key, val[key]);
						});
					} else
						self.setLocalizedProp(_, name, locale.current, val);
				} else {
					if(property.isExternalStorage() && val && val.$value && val.$contentType && val.$fileName) {
						//val.$value is the content of file encoded in base64
						var store = _getExternalStorageProp(_, this, name, property);
						if (store) {
							store.createWorkingCopy(_);
							var stream = store.createWritableStream(_, {
								contentType: val.$contentType,
								fileName: val.$fileName
							});
							var buf = new Buffer(val.$value, 'base64');
							delete val.$value;
							stream.write(_, buf, "binary");
							stream.write(_, null);
							store.uploadDone(_);
						}
					} else 
						_setProp(_, this, name, property, val);
				}
				// propagate
				// validation & control
				_afterSetValue(_, this, name, property, val, _validateProperty);
			}
		}
	});
	
	forEachKey(meta.$relations, function(name, relation){
		_proto[name] = function(_, val, isInverse){
			if (arguments.length == 1) {
				return _getRel(_, this, name, relation);
			}
			else {
				_setRel(_, this, name, relation, val, isInverse);
			}
		}
	});

	_proto._initialize = function (_, context) {
		if(!this.$uuid) {
			this.$uuid = helpers.uuid.generate();
			this.$key = this.computeKey();
			this.$created = true;
			var session = globals.context.session;
			this.$creUser = (session && session.getUserLogin(_)) || "anonymous";
			this.$updUser = this.$creUser;
		}
		//
		var instance = this;
		config.tracer && config.tracer("factory._initialize: "+instance.$uuid);
		// create snapshot
		instance._snapshotEnabled = true;
		instance._sysSnapshotEnabled = true;
		if(!instance.$snapshot)
			instance.$snapshot = _createSnapshot(_, instance, "$snapshot");
		//
		flows.eachKey(_, instance._meta.$properties, function(_, name, property) {
			if(property.hasDefaultValue())
				instance[name](_, property.getDefaultValue(_, instance));
			else
				if(property.$type === "boolean")
					instance[name](_, false);
		});
		flows.eachKey(_, instance._meta.$relations, function(_, name, relation) {
			if (relation.hasOwnProperty("defaultValue")) {
				var defVal = null;
				if (typeof relation.defaultValue === "function") 
					defVal = relation.defaultValue(_);
				else 
					defVal = relation.defaultValue;
				//
				instance[name](_, defVal);
			} 
		});
		if(instance._meta.$init)
			instance._meta.$init(_, instance, context);
		//
		return instance;
	}
	_proto.$addError = function(message, propName, links){
		config.tracer && config.tracer("error added for "+this.$uuid+"."+propName+" "+message);
		this._errorCount++;
		var node = this;
		var controlProp = propName || this._controlling;
		if (controlProp) 
			node = (this.$properties[controlProp] = this.$properties[controlProp] || {});
		node.$diagnoses = node.$diagnoses || [];
		node.$diagnoses.push({
			severity: "error",
			message: message,
			$links: links
		});
	}
	_proto.$addDiagnose = function(severity, message, propName, links){
		config.tracer && config.tracer("diagnose added for "+this.$uuid+"."+propName+" "+message);
		var node = this;
		if (propName) 
			node = (this.$properties[propName] = this.$properties[propName] || {});
		node.$diagnoses = node.$diagnoses || [];
		node.$diagnoses.push({
			severity: severity,
			message: message,
			$links: links
		});
	}
	_proto.lockInstance = function(_) {
		adminHelper.lockInstance(_, this);
	}
	_proto.unlockInstance = function(_) {
		adminHelper.unlockInstance(_, this);
	}
	_proto.$inspect = function(withData, withMeta) {
		return "instance: "+this._meta.name+"; $uuid: "+this.$uuid+(withData?"; data="+sys.inspect(this._data):"")+(withMeta?sys.inspect(this._meta):"");		
	}
	_proto._internalSerialize = function(_) {
		return _internalSerialize(_, this);
	}
	_proto.serializeInstance = function(_) {
		return _serialize(_, this, null);
	}
	_proto.ensureLoaded = function(_) {
//		if (!this.$loaded && this._meta.$isPersistent) {
		if (!this.$loaded) {
			config.tracer && config.tracer("factory.ensureLoaded.load: "+this.$uuid);
//			var asso = this._db.fetchInstance(_, this._meta, this.$uuid);
			var asso = _instanceById(_, {
				entity: this._meta,
				db: this._db,
				instanceId: this.$key
			});
			if(asso) {
				// replace _data by _data fetched
				var self = this;
				self._data = asso._data;
				forEachKey(asso, function(key) {
					if(key[0] == "$")
						self[key] = asso[key];
				});
				self.$initialUpdDate = asso.$updDate;
			}
//			this.$key = this.$uuid;
			this.$loaded = asso != null;
		}
		//
		return this;
	}
	//
	_proto.getSnapshotDelta = function(_) {
		return _computeDelta(_, this, "$snapshot", null, false);
	}
	_proto.getSaveSnapshotDelta = function(_) {
		return serializer.serialize(_, this, new serializer.SaveSerializer("$snapshot"), {
			tracer: config && config.tracer
		});
//		return _computeSaveDelta(_, this);
//		return _computeDelta(_, this, "$snapshot", null, true, true);
	}
	_proto.getClassName = function() {
		return helpers.string.capitalize(this._meta.name);
	}
	_proto.createChild = function(_, relationName, key, data, forAsso){
		var child = this.syncCreateChild(relationName, key, data, forAsso);
		if((!data && (this._meta.$relations[relationName].isChild || forAsso)) || !key) child._initialize(_, this._context);
//		if(!data) child._initialize(_, this._context);
		return child;
	}
	_proto.syncCreateChild = function(relationName, key, data, forAsso) {
		config.tracer && config.tracer("factory.syncCreateChild: "+relationName+";"+sys.inspect(data));
//		if(!this._meta.$relations[relationName]) console.log("factory.syncCreateChild: "+relationName+";"+sys.inspect(data));
		var r = this._meta.$relations[relationName];
		var t;
		if(data && r.$isDynamicType) {
			if(data.$type)
				t = data.$type;
			else
				if(data.$url) {
					var url = data.$url;
					var segs = url.split("?")[0].split("/").slice(-4);
					var det = httpHelpers.decodeDetailSegment(segs[3]);
					if(det) {
						data.$type = t = this._db.model.singularize(det.name);
						key = det.id;
					}
				}
		}
		var targetType = _getTargetEntity(this._db.model, r, t);
		var elt = targetType.factory.syncCreateInstance(data, this._db, this._context);
		// don't generate an uuid, let _initialize do it
		if(targetType.$key && key) {
			elt.$key = key;
			elt.$uuid = (data && data.$uuid);
		} else
			elt.$uuid = elt.$key = key;
		// if creating -> is loaded
		elt.$loaded = (key == null) || r.isChild || (data && r.$inlineStore);
		elt._snapshotEnabled = true;
		elt._sysSnapshotEnabled = true;
		elt._parent = this;
		elt._relation = r;
		return elt; 
	}
	// add the instance to persist to the related list of the top instance
	_proto.addRelatedInstance = function(instance) {
		if(!instance) return;
		config.tracer && config.tracer("factory.addRelatedInstance: "+instance.$inspect());
		var top = getTopInstance(this);
		config.tracer && config.tracer("factory.topInstance: "+top.$inspect());
		top._relatedInst[instance.$uuid] = instance;
		config.tracer && config.tracer("factory.topInstance related inst: "+sys.inspect(top._relatedInst));
	}
	// add the instance to reindex to the related list of the top instance
	_proto.addReindexInstance = function(instance) {
		if(!instance) return;
		config.tracer && config.tracer("factory.addReindexInstance: "+instance.$inspect());
		var top = getTopInstance(this);
		config.tracer && config.tracer("factory.topInstance: "+top.$inspect());
		top._reindexInst[instance.$uuid] = instance;
		config.tracer && config.tracer("factory.topInstance reindex inst: "+sys.inspect(top._reindexInst));
	}
	function _fireBeforeSave(_, self) {
		self._meta.$events.$beforeSave.forEach_(_, function(_, h) {
			h(_, self);
		});
		self._db.model.$events.$beforeSave.forEach_(_, function(_, h) {
			h(_, self);
		});
		// can save ?
		self._meta.$events.$canSave.forEach_(_, function(_, h) {
			h(_, self);
		});
		self._db.model.$events.$canSave.forEach_(_, function(_, h) {
			h(_, self);
		});
	}
	function _fireAfterSave(_, self) {
		self._meta.$events.$afterSave.forEach_(_, function(_, h) {
			h(_, self);
		});
		self._db.model.$events.$afterSave.forEach_(_, function(_, h) {
			h(_, self);
		});
	}
	_proto.save = function(_) {
		var self = this;
		// fire before save
		_fireBeforeSave(_, this);
		// fire $onDelete (for childrens)
		_fireOnDelete(_, this);
		// global validation
		_validateBeforeSave(_, this);
		// from datacontext._execoperation
		var op = {
			$isRequested: false, 
//			$diagnoses: [], 
			$links: {
			}
		};
		if(!(self.$created && (self._meta.$isPersistent !== false)))
			op.$links.$create = { $isHidden: true }
		//
		var hasErrors = _existsError(_, this);
		if(hasErrors) {
			// TODO : review this, should not be necessary. There is a problem detecting errors in childrens (multi-level), 
			// so for now we push this global error
/*			op.$diagnoses.push({
				severity: "error",
				message: "Cannot save this resource as some properties are in error state"
			});*/
			// if errors, hide standard links
			op.$links.$details = (op.$links.$details || {});
			op.$links.$details.$isHidden = true;
			op.$links.$query = (op.$links.$query || {});
			op.$links.$query.$isHidden = true;
			op.$links.$create = (op.$links.$create || {});
			op.$links.$create.$isHidden = true;
		} 
		else
			try {
				op.$diagnoses = [];
				this._saveErrorCode = 0;
				if(this.$save)
					this.$save(_, op);
				else {
					var saveResult = this._db.saveInstance(_,this);
					config.tracer && config.tracer("factory.save: db saveResult: "+sys.inspect(saveResult));
					if (saveResult == 0) {
						config.tracer && config.tracer("factory.save: concurency error; lastModified: "+this.$updDate);
						this._saveErrorCode = httpHelpers.HttpStatus.Conflict;
						throw new Error("Cannot save this resource as it has been modified by another user ("+this._meta.name+"."+this.$uuid+")");
					}
				}
				// cleanup external storage files
				_cleanupExternalStorage(_, this);
				//
				if (this._snapshotEnabled && this.$snapshot) 
					this.$snapshot = null;
				// save related instances
				// Q : what if fails ? (we should validate related instances first)
				// Q : should we do this at first or at the end ?
				config.tracer && config.tracer("factory.save: relatedInstances; $uuid: "+this.$uuid+"; "+sys.inspect(this._relatedInst));
				var hasRelatedErrors = false;
				flows.eachKey(_, this._relatedInst, function(_, key, value) {
					var res = value.save(_);
					// push diagnoses to main diagnoses
					res.$actions.$save.$diagnoses.forEach(function(diag) {
						if(diag.severity === "error") {
							op.$diagnoses.push(diag);
							hasRelatedErrors = true;
						}
					});
				});
				// cleanup deleted instances (plural relations)
				_cleanupDeleted(_, this);
				// cleanup snapshot
				this.$snapshot = null;
				this.$sysSnapshot = null;
				//
				this.unlockInstance(_);
				//
				if(!hasRelatedErrors)
					op.$diagnoses.splice(0, 0, {
						severity: "success",
						message: "Resource has been saved"
					});
				//
				self.$created = false;
			} catch (ex) {
				op.$diagnoses.push({
					severity: "error",
					message: ex.message + ex.stack
				});
				config.tracer && config.tracer("Save error stack: " + ex.stack);
			}
		
//		op.$title = "Save";
		op.$isDisabled = true;
		op.$isRequested = false;
		//
		var result = _serialize(_, this);
		// crnit : from serializer
		result.$actions = result.$actions || {};
		result.$actions.$save = op;
		// fire after save
		_fireAfterSave(_, this);
		//
		return result;
	}
	_proto.getEndpoint = function(_) {
		// TODO: should optimise - endpoint should be a variable. Might be entities should be declined by endpoint !
		var e = this.getEntity();
		return adminHelper.getEndpoint(_, {
			application: e.contract.application,
			contract: e.contract.contract,
			dataset: this._db.dataset.database
		});
	}
	_proto.getUrl = function(_) {
		var e = this.getEndpoint(_);
		return [e.getBaseUrl(_), this._meta.plural + "('" + this.computeKey() + "')"].join("/");
	}
	function _evaluate(_, instance, expression) {
		// TODO: lowercase for strings
		function _getReferenceValue(ref, returnInstance) {
			return (returnInstance ? ref : ref && ref.$uuid);
		}
		function _evaluateChild(_, exp, childInst, returnInstance) {
			var result = null;
			switch(exp.type) {
				case "operator":
					return _evaluate(_, childInst, exp);
				case "identifier":
					if(["$uuid", "$updDate", "$updUser", "$creDate", "$creUser"].indexOf(exp.value) >= 0)
						return childInst[exp.value];
					var meta = childInst._meta.$properties[exp.value];
					if(meta) return childInst[exp.value](_);
					meta = childInst._meta.$relations[exp.value];
					if(meta) return (meta.isPlural ? null : _getReferenceValue(childInst[exp.value](_), returnInstance));
					if(typeof childInst[exp.value === "function"])
						result = childInst[exp.value](_);
					else
						result = childInst[exp.value];
					return null;
				case "literal":
					return exp.value;
				default:
					throw new Error(exp.type + "NYI");
			}
			return null;
		}
		//
		if(!expression) return true;
		//
		switch(expression.type) {
			case "operator":
				switch(expression.value.code) {
					case "and":
						break;
					case "or":
						break;
					case ".":
						if(expression.children.length != 2)
							throw new Error("Invalid expression: '.' operator" + expression.toString());
						if(expression.children[1].type != "identifier")
							throw new Error("Invalid expression: '.' operator" + expression.toString());
						var child1 = _evaluateChild(_, expression.children[0], instance, true);
						return child1 && _evaluateChild(_, expression.children[1], child1, true);
					case "=":
						return _evaluateChild(_, expression.children[0], instance) == _evaluateChild(_, expression.children[1], instance);
					case "<>":
						return _evaluateChild(_, expression.children[0], instance) != _evaluateChild(_, expression.children[1], instance);
					case "<":
						return _evaluateChild(_, expression.children[0], instance) < _evaluateChild(_, expression.children[1], instance);
					case "<=":
						return _evaluateChild(_, expression.children[0], instance) <= _evaluateChild(_, expression.children[1], instance);
					case ">":
						return _evaluateChild(_, expression.children[0], instance) > _evaluateChild(_, expression.children[1], instance);
					case ">=":
						return _evaluateChild(_, expression.children[0], instance) >= _evaluateChild(_, expression.children[1], instance);
					case "like":
						if(expression.children[1].type !== "literal")
							throw new Error(locale.format(module, "literalExpected", expression.value.code, expression.children[1].value));
						return ((_evaluateChild(_, expression.children[0], instance) || "").search("^"+expression.children[1].value.replace(/%/g, ".*")+"$") >= 0);
					case "between":
						var term = _evaluateChild(_, expression.children[0], instance);
						return (term >= _evaluateChild(_, expression.children[1], instance)) && (term <= _evaluateChild(_, expression.children[2], instance));
					default:
						throw new Error("operator: " + expression.value.code + " NYI");
				}
				break;
			default:
				throw new Error(expression.type + " NYI");
		}
	}
	_proto.match = function(_, expression) {
		return _evaluate(_, this, expression);
	}
	_proto.defer = function(poolName, closure) {
		var pool = this[poolName] = this[poolName] || [];
		pool && pool.push(closure);
	}
	_proto.executeDefered = function(_, poolName) {
		var closure;
		if(this[poolName]) {
			while(closure = this[poolName].shift())
				closure(_);
			this[poolName] = null;
		}
	}
	/// -------------
	/// ## Factory $resolvePath function :
	/// ``` javascript
	/// var value = instance.$resolvePath(_, "myRelation.secondRef.property"); 
	/// ```
	/// Returns the value of the property scanning the path
	/// 
	_proto.$resolvePath = function(_, path) {
		var self = this;
		var segs = path.split(".");
		var seg;
		while(seg = segs.shift()) {
			if(!self) return null;
			if(seg[0] === "$")
				return self[seg];
			if(self._meta.$properties[seg])
				return self[seg](_);
			else
				if(self._meta.$relations[seg] && !self._meta.$relations[seg].isPlural)
					self = self[seg](_);
		}
		return null;
	}
	/// -------------
	/// ## Factory $canDelete function :
	/// ``` javascript
	/// var canDelete = instance.$canDelete(_); 
	/// ```
	/// Performs verifications before delete
	/// 
	/// Returns false if cannot delete. instance.deleteError hints of the reason  
	/// 
	_proto.$canDelete = function(_){
		// check here if we can delete instance; set deleteError otherwise
		var self = this;
		self.deleteError = "";
		return (!self._meta.$relations || !Object.keys(self._meta.$relations).filter(function(relName) {
			return self._meta.$relations[relName].$cascadeDelete;
		}).some_(_, function(_, relName) {
			var rel = self._meta.$relations[relName];
			if(rel.isPlural)
				return self[relName](_).toArray(_).some_(_, function(_, item) {
					return !item.$canDelete(_);
				});
			else
				return (!self[relName](_) || !self[relName](_).$canDelete(_));
		})) &&			
			(!self._meta.referingEntities || !Object.keys(self._meta.referingEntities).some_(_, function(_, entityName) {
				var entity = self._db.model.getEntity(entityName);
				if(!entity) throw new Error(locale.format(module, "entityNotFound", entityName));
				if(entity.$isPersistent === false) return false;
				// check if is refered
				var filter = {};
				var rels = self._meta.referingEntities[entityName].filter(function(relName) {
					// ignore relation if direct or inverse is with cascade
					var rel = entity.$relations && entity.$relations[relName];
					if(rel && (rel.$cascadeDelete || rel.$nullOnDelete)) return false;
					var inv = rel && rel.$inv && rel.targetEntity && rel.targetEntity.$relations[rel.$inv];
					return (!inv || !inv.$cascadeDelete);
				});
				if(rels.length == 0) return false;
				if(rels.length > 1) {
					filter.$or = rels.map(function(relName) {
						var part = {};
						part[relName] = self.$uuid;
						return part;
					});
				} else
					filter[rels[0]] = self.$uuid;
				var inst = self._db.fetchInstance(_, entity, {jsonWhere:filter});
				if(inst) {
					self.deleteError = "Cannot delete "+self.getValue(_)+" as is referenced by \""+inst._meta.name+"\" "+inst.getValue(_);
				}
				return (inst != null);
			}));
	}
	/// -------------
	/// ## Factory deleteSelf function :
	/// ``` javascript
	/// instance.deleteSelf(_); 
	/// ```
	/// Deletes the instance from the database
	/// Performs verifications and cascade deletes
	///
	/// Returns false in case of error and instance.deleteError hints of the error
	/// 
	_proto.deleteSelf = function(_){
		try {
			var self = this;
			//
			if(!self.$canDelete(_)) return false;
			// fire $onDelete
			_fireOnDelete(_, this);
			//
			this._db.deleteInstance(_, this);
			// cascade delete
			Object.keys(self._meta.$relations).filter(function(relName) {
				return self._meta.$relations[relName].$cascadeDelete;
			}).forEach_(_, function(_, relName) {
				var rel = self._meta.$relations[relName];
				if(rel.isPlural)
					self[relName](_).toArray(_).forEach_(_, function(_, item) {
						item.deleteSelf(_);
					});
				else
					self[relName](_) && self[relName](_).deleteSelf(_);
			});
			// null on delete
			Object.keys(self._meta.$relations).filter(function(relName) {
				return self._meta.$relations[relName].$nullOnDelete;
			}).forEach_(_, function(_, relName) {
				var rel = self._meta.$relations[relName];
				if(rel.isPlural) {
					var coll = self[relName](_);
					coll.toArray(_).forEach_(_, function(_, item) {
						coll.deleteInstance(_, item.$uuid);
					});
				}
			});
			// null on delete: TODO: should set null on the relations refering this object. Or we might leave it and ignore on load ...
			// delete storage files
			Object.keys(self._meta.$properties).filter(function(propName) {
				return self._meta.$properties[propName].isExternalStorage();
			}).forEach_(_, function(_, propName) {
				var store = self[propName](_);
				store && store.deleteFile(_);
			});
		} catch(e) {
			this.deleteError = e.message;
			this.$addError(e.message);
			return false;
		}
		return true;
	}
	/// -------------
	/// ## Factory hasErrors function :
	/// ``` javascript
	/// if(instance.hasErrors(_) doSomething();
	/// ```
	/// Returns true if there are error diagnoses 
	/// 
	_proto.hasErrors = function(_) {
		return this.getAllDiagnoses(_).some(function(d) {
			return d.severity === "error";
		});
	}
	
	/// -------------
	/// ## Factory getAllDiagnoses function :
	/// ``` javascript
	/// var diags = [];
	/// instance.getAllDiagnoses(_, diag, options);
	/// ```
	/// Returns an flat array of diagnoses instead of a tree. Allows quick detection of diagnose messages 
	/// 
	/// * diag - results array; diagnoses will be pushed into this array
	/// * options = {
	///			addPropName: true, // adds the property name to the message
	///			addEntityName: true // adds the entity name to the message
	///  }
	/// 
	_proto.getAllDiagnoses = function(_, diagnoses, options) {
		function _makeDiagnose(diag, propName) {
			var res = diag;
			if(propName && options && options.addPropName)
				diag.message = propName + ":" + diag.message;
			if(options && options.addEntityName)
				diag.message = self._meta.name + ":" + diag.message;
			return diag;
		}
		var self = this;
		var diag = [];
		config.tracer && config.tracer("factory.getAllDiagnoses instance: "+self._meta.name+"."+self.$uuid);
		if(self.$diagnoses) 
			self.$diagnoses.forEach(function(item) {
				diag.push(_makeDiagnose(item));
			});
		//
		if(self.$properties)
			forEachKey(self.$properties, function(key, prop) {
				config.tracer && config.tracer("factory.getAllDiagnoses add diag: "+key);
				if(prop.$diagnoses)
					prop.$diagnoses.forEach(function(item) {
						diag.push(_makeDiagnose(item, key));
					});
			});
		//
		flows.eachKey(_, self._meta.$relations, function(_, key, rel) {
			config.tracer && config.tracer("factory.getAllDiagnoses add diag: "+key);
			if(rel.isChild) {
				var relData = self[key](_);
				if(rel.isPlural)
					relData.toArray(_).forEach_(_, function(_, item) {
						item.getAllDiagnoses(_, diag, options);
					});
				else
					relData && relData.getAllDiagnoses(_, diag, options);
			}
		});
		//
		forEachKey(self.$actions, function(key, action) {
			config.tracer && config.tracer("factory.getAllDiagnoses add diag: "+key);
			if(action.$diagnoses)
				action.$diagnoses.forEach(function(item) {
					diag.push(_makeDiagnose(item));
				});
		});
		//
		if(diagnoses)
			diag.forEach(function(d) {
				diagnoses.push(d);
			});
		return diag;
	}
	function _decodeTemplate(_, inst, template) {
		if(!inst) return "";
		if(!template) return "";
		var res = template.expression;
		template.matches.forEach_(_, function(_, match) {
			var prop = match.substring(1, match.length - 1);
			if (inst._meta.$properties[prop]) res = res.replace(match, _formatValue(inst._meta.$properties[prop], inst[prop](_)));
			else if (inst._meta.$relations[prop]) {
				if (inst._meta.$relations[prop].isPlural) res = res.replace(match, inst[prop](_).toArray(_).map_(_, function(_, elem) {
					return decodeTemplate(_, elem, inst._meta.$relations[prop].targetEntity.$valueTemplate);
				}).join(","));
				else res = res.replace(match, decodeTemplate(_, inst[prop](_), inst._meta.$relations[prop].targetEntity.$valueTemplate));
			}
		});
		return res;
	}
	_proto.getValue = function(_) {
		return _decodeTemplate(_, this, this._meta.$valueTemplate);
	}
	//
	this.__defineGetter__("meta", function(){
		return meta;
	});
	// connection is usefull for lazy loads, provide a dbHandle
	/// -------------
	/// ## Factory createInstance function :
	/// ``` javascript
	/// var newInstance = entity.factory.createInstance(_, initialData, dbConnection); 
	/// ```
	/// Creates a new instance of entity. If initial data is provided (existing object), it uses it to initialize the instance or creates a new object otherwise
	/// dbConnection must be provided as an instance of the database driver
	/// 
	/// Returns the created new element  
	/// 
	this.createInstance = function(_, data, connection, context){
		var inst = new Instance(data, null, connection, context);
//		var inst = new Instance(null, null, connection, context);
		if(!data) inst._initialize(_, context);
//		else inst._load(_, data);
		return inst;
	}
	this.syncCreateInstance = function(data, connection, context){
		return new Instance(data, null, connection, context);
	}
}

exports.Factory = helpers.defineClass(Factory, null, {})

// Working copy stuff

function _testETag(_, context, instance, delta){
	if (!delta || (delta.$etag && (delta.$etag != instance.$etag))) {
		config.tracer && config.tracer("factory.etag test failed: delta.etag="+(delta && delta.$etag)+"; instance etag="+instance.$etag);
		context.reply(_, 412, _serialize(_, instance));
		return false;
	}
	return true;
}

function _instanceById(_, context) {
	// try to find the instance in cache
	var instance = null;
//	config.tracer && config.tracer("factory._instanceById: "+sys.inspect(context));
	config.tracer && config.tracer("factory._instanceById requested id: "+context.instanceId+"; isExpression: "+context.isExpressionId);
	var where = context.isExpressionId ? {
		sdataWhere: context.instanceId
	} : context.instanceId;
	if(context.entity.$isPersistent)
		instance = context.db.fetchInstance(_, context.entity, where);
	else {
		instance = context.entity.factory.createInstance(_, null, context.db);
		instance.$setId(_, context, context.instanceId);
		// recompute $key as it might have changed in setId (hasn't been initialized in create)
		instance.$key = instance.computeKey();
	}
	return instance;
}

function _createWorkingCopy(_, context, factory, wcId) {
	context.setMeta(true);
//	var wcId = context.query.trackingId;
	// crnit : use database abstraction
	var instance = null;
	if (context.instanceId) {
		//instance = context.db.fetchInstance(_, context.entity, context.instanceId, (context.representation && context.representation.type));
		instance = _instanceById(_, context);
		config.tracer && config.tracer("factory.create working copy fetched instance: "+sys.inspect(instance));
		if (!instance) {
			context.reply(_, 404, "The requested ressource has not been found");
			return;
		}
		// explicit lock instance in create WC only (to have the error earlieast), for other cases is done by _createSnapshot
		try {
			instance.lockInstance(_);
		} catch(ex) {
			if(ex.httpStatus) {
				config.tracer && config.tracer("factory.createWC http error: "+ex.httpStatus+"="+ex.message);
				if((ex.httpStatus == httpHelpers.HttpStatus.Conflict) && ex.lockStatus) {
					// send diagnoses allowing to unlock
					instance.$addError(ex.message, null, {
						$unlock: {
							$title: "Force unlock",
							$url: context.baseUrl + "/$workingCopies('" + wcId + "')/$service/forceLockInstance",
							$method: "POST"
						}
					});
				} else {
					context.reply(_, ex.httpStatus, ex.message);
					return;
				}
			} else {
				throw ex;
			}
		}
		//
	} else {
		instance = factory.createInstance(_, null, context.db, context);
//		instance._initialize(_, context);
	}
	if (instance.$setParameters)
		instance.$setParameters(_, context);
//	instance.$url = context.baseUrl + "/$workingCopies('" + wcId + "')?representation=" + instance._meta.name + ".$edit";
	instance.$url = context.baseUrl + "/$workingCopies('" + wcId + "')?representation=" + context.representation.entity + ".$edit";
	instance.$trackingId = wcId;
	instance.$type = context.model.baseType;
	instance._snapshotEnabled = true;
	instance._sysSnapshotEnabled = true;
	//
	context.httpSession[wcId] = instance;
	//
	return instance;
}

exports.createTemplate = function(_, context, factory){
	// create an instance, serialize it and remove it
	var instance =  factory.createInstance(_, null, context.db, context);
	//serialize
	if(instance) {
		var resource = _serialize(_, instance);
		delete resource.$uuid;
		delete resource.$key;
		// todo delete all 
		context.reply(_, httpHelpers.HttpStatus.OK, resource);
	} else 
		context.reply(_, 404, "The requested ressource has not been found");
}
 

exports.createWorkingCopy = function(_, context, factory){
	var delta = JSON.parse(context.request.readAll(_));
	var instance = _createWorkingCopy(_, context, factory, context.query.trackingId || (delta && delta.$trackingId) || helpers.uuid.generate());
	if(!instance) return;
	var resource;
	// in WC creation we might get initial data from client sendBag
	instance.$sysSnapshot = null;
	if(delta) {
		config.tracer && config.tracer("factory.createWorkingCopy got delta: "+sys.inspect(delta));
		instance.$etag = delta.$etag;
		//
		_applyDelta(_, instance, delta);
		// execute actions
		_executeActions(_, context, instance);
		//
		instance.$etag++;
		instance.$updUser = (context && context.getUser(_) && context.getUser(_).login(_));
		//
		if (delta.$actions && delta.$actions.$save && delta.$actions.$save.$isRequested) {
			// save
			resource = instance.save(_);
		}
	}
	//
	resource = resource || _serialize(_, instance);
	// activate SAVE, see if we need to implement some conditions here
	var res = resource;
	if(instance._meta.$canSave !== false) {
		res.$actions = res.$actions || {};
		res.$actions.$save = res.$actions.$save || {};
		res.$actions.$save.$isRequested = false;
		res.$actions.$save.$isDisabled = false;
	//	res.$actions.$save.$isDisabled = true;
	}
	// no details link if instance is created
	if(instance.$created && (instance._meta.$isPersistent !== false)) {
		res.$links = res.$links || {};
		res.$links.$details = res.$links.$details || {};
		res.$links.$details.$isHidden = true;
	}
	//
	context.reply(_, httpHelpers.HttpStatus.Created, resource);
}

exports.getWorkingCopy = function(_, context, instance){
	context.reply(_, 200, _serialize(_, instance));
}

exports.updateWorkingCopy = function(_, context, instance){
	// lock TODO !!!
	try {
		instance.lockInstance(_);
	} catch(ex) {
		if(ex.httpStatus) {
			config.tracer && config.tracer("factory.createWC http error: "+ex.httpStatus+"="+ex.message);
			if((ex.httpStatus == httpHelpers.HttpStatus.Conflict) && ex.lockStatus) {
				// send diagnoses allowing to unlock
				instance.$addError(ex.message, null, {
					$unlock: {
						$title: "Force unlock",
						$url: context.baseUrl + "/$workingCopies('" + context.query.trackingId + "')/$service/forceLockInstance",
						$method: "POST"
					}
				});
			} else {
				context.reply(_, ex.httpStatus, ex.message);
				return;
			}
		} else {
			throw ex;
		}
	}
	//
	instance.$sysSnapshot = null;
	var delta = JSON.parse(context.request.readAll(_));
	if (!_testETag(_, context, instance, delta)) 
		return;
	_applyDelta(_, instance, delta);
	// execute actions
	_executeActions(_, context, instance);
	//
	instance.$etag++;
	instance.$updUser = (context && context.getUser(_) && context.getUser(_).login(_));
	//
	if (delta.$actions && delta.$actions.$save && delta.$actions.$save.$isRequested) {
		// save
		try {
			var resource = instance.save(_);
			// for working copies, send allways OK status code and let diagnoses show error messages
//			context.reply(_, instance._saveErrorCode ? instance._saveErrorCode : httpHelpers.HttpStatus.OK, resource);
			context.reply(_, httpHelpers.HttpStatus.OK, resource);
		} catch(e) {
			context.reply(_, 500, e.message);
		}
	}
	else {
		var res = _computeDelta(_, instance, "$sysSnapshot", null, false);
		// activer save
		// !!! validateMandatory desactivated for now, it's better for the user to see the error when he saves.
		// anyway, validateMandatory should not fill $diagnoses
//		_validateMandatory(_, instance);
		if (!instance._errorCount && (instance._meta.$canSave !== false)) {
			res.$actions = res.$actions || {};
			res.$actions.$save = res.$actions.$save || {};
			res.$actions.$save.$isRequested = false;
			res.$actions.$save.$isDisabled = false;
		}
		// no details link if instance is created
		if(instance.$created && (instance._meta.$isPersistent !== false)) {
			res.$links = res.$links || {};
			res.$links.$details = res.$links.$details || {};
			res.$links.$details.$isHidden = true;
		}
		//
		context.reply(_, httpHelpers.HttpStatus.OK, res);
	}
}
/// -------------
/// ## Factory replyInstances function :
/// ``` javascript
/// var factory = require("syracuse-orm/lib/factory");
/// ...
/// factory.replyInstances(_, context); 
/// ```
/// Replies the request with an array of resources based on the context object  
/// The context must provide the database abstraction, an entity and the filters
///
exports.replyInstances = function(_, context, entity, parameters) {
	config.tracer && config.tracer("factory.replyInstances enter");
	context.setMeta(false);
	//
	var ent = entity || context.entity;
	var params = parameters || context.parameters || {};
	var instances;
	if(ent.$fetchInstances) {
		var preliminary = (ent.$sortInstances || context.sortInstancesArray)(_, context.filterInstancesArray(_, ent.$fetchInstances(_, context, params)), params, ent.defaultOrder);
		var listCount = preliminary.length;
		//
		context.totalCount = listCount
		var start = (params.startIndex || 1)-1;
		var count = (params.count || (listCount-start));
		instances = (params.key && params.key.split(".")[0] === "lt") ? preliminary.slice(-count) : preliminary.slice(start, Math.min(start+count, listCount));
	} else {
		context.addComplementFilter(_, params);
		context.totalCount = context.db.count(_, ent, params); 
		// add filter for letter paging (no letter paging for count compute)
		if(params.startLetter && params.orderBy && params.orderBy[0] && params.orderBy[0].binding) {
			var newFilter = parser.Parser.parse("(" + params.orderBy[0].binding + " between '" + params.startLetter.toLowerCase() + "' and 'z') or " +
					"(" + params.orderBy[0].binding + " between '" + params.startLetter.toUpperCase() + "' and 'Z')");
			if(params.where)
				params.where = {
					type: "operator",
					value: {
						code: "and"
					},
					children: [params.where, newFilter]
				}
			else
				params.where = newFilter;
		}
		instances = context.db.fetchInstances(_, ent, params);
	}
	config.tracer && config.tracer("factory.fetchInstances count:"+context.totalCount);
	//
	var resources = [];
	instances.forEach_(_, function(_, instance){
		resources.push(_serialize(_, instance, (queryFacets.indexOf(context.representation.type) >= 0)));
	});
	context.replyResources(_, httpHelpers.HttpStatus.OK, resources);
}
/// -------------
/// ## Factory fetchInstance function :
/// ``` javascript
/// var factory = require("syracuse-orm/lib/factory");
/// ...
/// var instance = factory.fetchInstance(_, context); 
/// ```
/// Fetches an instance based on the context object  
/// The context must provide the database abstraction, an entity and the instanceId
///
/// Returns the fetched element or null  
/// 
exports.fetchInstance = function(_, context) {
	config.tracer && config.tracer("factory.fetchInstance enter");
	context.setMeta(false);
	return _instanceById(_, context);
}
/// -------------
/// ## Factory replyInstance function :
/// ``` javascript
/// var factory = require("syracuse-orm/lib/factory");
/// ...
/// factory.replyInstance(_, context); 
/// ```
/// Replies the request with a resource based on the context object  
/// The context must provide the database abstraction, an entity and the instanceId
///
exports.replyInstance = function(_, context, notFoundCallback) {
	config.tracer && config.tracer("factory.replyInstance enter");
	context.setMeta(false);
	var instance = _instanceById(_, context);
	if(instance)
		context.replyResource(_, httpHelpers.HttpStatus.OK, _serialize(_, instance));
	else
		if(notFoundCallback)
			notFoundCallback(_, context);
		else {
			var repMeta = context.getRepresentationMeta(context.contract, context.getRepresentation(context.contract, context.entity.name, context.representation.entity), context.representation.type);
			if(repMeta && repMeta.$options && repMeta.$options.$notFoundUrl) {
				// TODO: expression parse for this url ?
//				var location = repMeta.$options.$notFoundUrl;
				var location = repMeta.$options.$notFoundUrl && repMeta.$options.$notFoundUrl.replace("{$baseUrl}", context.baseUrl);
				context.reply(_, httpHelpers.HttpStatus.TemporaryRedirect, "", { Location: location });
			} else
				context.reply(_, 404);
		}
}


function _createInstance(_, context, factory, batchRequest) {
	// create instance
	var instance = null;
	if (context.batchResult) {
		instance = _instanceById(_, context);
		if (instance && (instance.$uuid && (instance.$uuid == context.instanceId))) {
			context.reply(_, httpHelpers.HttpStatus.Created, _serialize(_, instance));
			return;
		}
	}
	instance = factory.createInstance(_, null, context.db, context);
//	instance.$url = context.baseUrl + "/"+instance._meta.name+"('" + instance.$uuid + "')?representation=" + instance._meta.name + ".$edit";
	instance.$url = context.baseUrl + "/"+instance._meta.plural+"('" + instance.$uuid + "')?representation=" + context.representation.entity + ".$edit";
	instance.$type = context.model.baseType;
	// apply delta
	instance.$sysSnapshot = null;
	var delta = batchRequest?batchRequest:JSON.parse(context.request.readAll(_));
	_applyDelta(_, instance, delta);
	// save
	instance.$url = context.baseUrl + "/"+instance._meta.plural+"('" + instance.$uuid + "')";
	var res = instance.save(_);
	context.reply(_, _existsError(_, instance)?httpHelpers.HttpStatus.BadRequest:httpHelpers.HttpStatus.Created, res);
}

exports.createInstance = function (_, context, factory) { _createInstance(_, context, factory);}

function _updateInstance(_, context, batchRequest){
	if (context.instanceId) {
//		var instance = context.db.fetchInstance(_, context.entity, context.instanceId, (context.representation && context.representation.type));
		var instance = _instanceById(_, context);
		config.tracer && config.tracer("factory.updateInstance fetched instance: "+instance.$inspect(true));
		if (context.batchResult && (!instance || (instance.$uuid != context.instanceId))) {
			context.reply(_, 410);
			return;
		}
		if (!instance) {
			if (context.batchResult) 
				context.reply(_, 410);
			else
				context.reply(_, 404);
			return;
		}
		// apply delta
		instance.$sysSnapshot = null;
		instance._snapshotEnabled = true;
		instance._sysSnapshotEnabled = true;
		instance.$updUser = (context && context.getUser(_) && context.getUser(_).login(_));
		var delta = batchRequest?batchRequest:JSON.parse(context.request.readAll(_));
		_applyDelta(_, instance, delta);
		// save
		try {
			var resource = instance.save(_);
			var ee = _existsError(_, instance);
			context.reply(_, (ee?httpHelpers.HttpStatus.BadRequest:httpHelpers.HttpStatus.OK), resource);
		} catch(e) {
			context.reply(_, 500, e.message);
		}
	} else
		context.reply(_, 404);
}
exports.updateInstance = function(_, context) { _updateInstance(_, context); };

function _deleteInstance(_, context) {
	if (context.instanceId) {
		var instance = _instanceById(_, context);
		//var instance = context.db.fetchInstance(_, context.entity, context.instanceId, (context.representation && context.representation.type));
		if (context.batchResult && (!instance || (context.instanceId != instance.$uuid))) {
			context.reply(_, 410);
			return;
		}
		if (!instance) {
			if (context.batchResult) 
				context.reply(_, 410);
			else
				context.reply(_, 404);
			return;
		}
		config.tracer && config.tracer("factory.deleteInstance fetched instance: "+instance.$inspect(true));
		// check
		if (instance.deleteSelf(_)) {
			// save
			context.replyDeleted(_);
		} else
			context.reply(_, 403, instance.deleteError);
	} else
		context.reply(_, 404);
}

exports.deleteInstance = _deleteInstance;

// setup
exports.setup = function(factoryConfig) {
	config = factoryConfig || {};
}

exports.batch = function(_, context){	
	try {
		var batchResult = {$resources: []};
		var brequest = JSON.parse(context.request.readAll(_));
		
		brequest.$resources.forEach_(_,function(_, entry){
			var op = {etag: entry.$etag, method: entry.$httpMethod.toLowerCase(), ifMatch: entry.$httpifMatch};
			delete entry.$httpMethod;
			delete entry.$httpifMatch;
			var opres = {$httpStatus: 200};
			context.instanceId = entry.$uuid;
			batchResult.$resources.push(opres);
			try {
				context.batchResult = opres;
				switch (op.method) {
					case "post":
						_createInstance(_, context, context.entity.factory, entry)
						break;
					case "put":
						_updateInstance(_, context, entry);
						break;
					case "delete":
						_deleteInstance(_, context);
						break;
					default:  
						break;
				}
			} catch (ex) {
				opres.$httpStatus = 500;
				opres.$httpMessage = ex.message;
			}
		});
		context.batchResult = null;
		context.reply(_, 200, batchResult);
	} catch(e) {
		context.batchResult = null;
		context.reply(_, 500, e.message);
	}
	
}
