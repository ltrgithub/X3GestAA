"use strict";

var sys = require("util");
var Parser = require("syracuse-sdata/lib/parser/parser").Parser;
var globals = require('streamline/lib/globals');
var config = {};

function _left(where) {
	var result = "";
	if (!where) return result;
	switch (where.type) {
		case "operator":
			switch (where.value.code) {
				case ".":
					result = _left(where.children[0]) + "." + _left(where.children[1]);
					break;
				default:
					throw new Error("_left : \"" + where.value.code + "\" not yet implemented");
			}
			break;
		default:
			result = where.value;
	}
	config.tracer && config.tracer("mongodb.filter.left: " + result);
	return result;
}

function _format(value, isDate) {
	return isDate ? new Date(value) : ((typeof value === "object") && value.toString()) ? value.toString() : value;
}

function _createFilter(where) {
	// accept string sdata clause or parsed sdata clause
	if (where && (typeof where === "string")) where = Parser.parse(where);
	//
	config.tracer && config.tracer("mongodbDbHandle.create filter enter: " + sys.inspect(where));
	if (!where) return {};
	//
	var result = {};
	switch (where.type) {
		case "operator":
			switch (where.value.code) {
				case "and":
					if (where.children.length < 2) {
						throw new Error("Invalid \"AND\" condition");
					}
					var _filter = [];
					_filter[0] = _createFilter(where.children[0]);
					_filter[1] = _createFilter(where.children[1]);
					result = {
						$and: [_filter[0], _filter[1]]
					};
					break;
				case "or":
					if (where.children.length < 2) {
						throw new Error("Invalid \"OR\" condition");
					}
					var _filter = [];
					_filter[0] = _createFilter(where.children[0]);
					_filter[1] = _createFilter(where.children[1]);
					result = {
						$or: [_filter[0], _filter[1]]
					};
					break;
				default:
					// (franck kevin, issue#3033) handling 'empty' and 'not empty' filtering requests
					if (where.children[1] && where.children[1].value == null) {
						// case 'empty'. query example : {"$or":[{"firstName":{"$exists":false}},{"firstName":""}]} 
						if (where.value.code === "=") {
							var oper = "$or";
							var field = _left(where.children[0]);
							var arg1 = {};
							var arg2 = {};
							result[oper] = [];
							arg1[field] = null;
							arg2[field] = "";
							result[oper].push(arg1, arg2);
						} else {
							// case 'not empty'. query example : {"firstName":{"$exists":true,"$ne":""}}
							if (where.value.code === "<>") {
								result[_left(where.children[0])] = {
									"$exists": true,
									"$ne": ""
								};
							} else {
								throw new Error("Unexpected operator '" + where.value.code + "' for 'null' value. Expected '=' or '<>'");
							}
						}
					} else {

						//          config.tracer && config.tracer("mongodbDbHandle.create where.children[0]: " + sys.inspect(where.children[0].value));
						var isDate = (where.children[0].value === "$updDate") || (where.children[0].value === "$creDate");
						if (where.value.code === "=") {
							result[_left(where.children[0])] = _format(where.children[1].value, isDate);
						} else {
							var oper = where.value.text;
							if (oper === "between") {
								if (where.children.length < 3) throw new Error("Invalid \"BETWEEN\" condition");

								result[_left(where.children[0])] = {
									$gte: _format(where.children[1].value, isDate),
									$lte: _format(where.children[2].value, isDate)
								};
							} else {
								if (where.children.length < 2) {
									throw new Error("Invalid \"" + oper.toUpperCase() + "\" condition");
								}

								var options = null;
								var right = where.children[1] && _format(where.children[1].value, isDate);
								// oper translation from sData to mongo
								switch (oper) {
									case "le":
										oper = "lte";
										break;
									case "ge":
										oper = "gte";
										break;
									case "like":
										oper = "regex";
										if (right.charAt(0) != "%") right = "^" + right;
										right = right.replace(/%/g, ".*");
										options = "i";
										break;
									case "in":
										right = where.children.slice(1).map(function(c) {
											return c && _format(c.value, isDate);
										});
										break;
								}
								//
								oper = "$" + oper;

								// Finally populate the result
								var k = _left(where.children[0]);
								result[k] = {};
								result[k][oper] = right;
								if (options) {
									result[k].$options = options;
								}
							}
						}
					}
			}
			break;
		default:
			throw new Error(where.type + " not yet implemented");
	}
	config.tracer && config.tracer("create filter exit: " + sys.inspect(result, null, 18));
	return result;
}

function _toFilterValue(value, type) {
	switch (type || typeof value) {
		case "number":
		case "boolean":
			return value;
		case "string":
			return "\"" + value + "\"";
		case "object":
			return "\"" + value.toString() + "\"";
		default:
			throw new Error("object filter NIY");
	}
}

function _createSdataFilter(where) {
	var res = "";
	switch (where.type) {
		case "operator":
			if (where.children.length < 2) {
				throw new Error("Invalid \"" + where.value.code.toUpperCase() + "\" condition");
			}

			switch (where.value.code) {
				case "and":
				case "AND":
				case "or":
				case "OR":
					res = _createSdataFilter(where.children[0]) + " " + where.value.code + " " + _createSdataFilter(where.children[1]);
					break;
				default:
					res = "(" + _left(where.children[0]) + " " + where.value.text + " " + _toFilterValue(_format(where.children[1].value)) + ")";
			}
			break;
		default:
			throw new Error(where.type + " not yet implemented");
	}
	//
	return res;
}

function _createSdataFilterFromJson(jsonWhere) {
	// TODO: for now only manages "=" and base types
	return Object.keys(jsonWhere).map(function(k) {
		var v = _toFilterValue(jsonWhere[k]);
		return "(" + k + " eq " + v + ")";
	}).join(" and ");
}

exports.sdataFilterToJson = function(where, options) {
	config = options || {};
	return _createFilter(where);
};

exports.jsonToSdata = function(params) {
	var p = params || {};
	var exp = [];
	if (p.sdataWhere) exp.push(p.sdataWhere);
	if (p.where) exp.push(_createSdataFilter(p.where));
	if (p.jsonWhere) exp.push(_createSdataFilterFromJson(p.jsonWhere));
	return exp.length ? exp.filter(function(term) {
		return term;
	}).map(function(term) {
		return "(" + term + ")";
	}).join(" AND ") : "";
};

exports.addRights = function(_, entity, filter, options) {
	config = options || {};
	var sp = globals.context.session && globals.context.session.getSecurityProfile(_);
	if (sp) {
		config.tracer && config.tracer("filters.addRights found security profile: " + sp.code(_));
		var r = sp.canReadClass(_, entity.name);
		config.tracer && config.tracer("filters.addRights got condition: " + r);
		if (typeof r === "boolean") {
			if (r === false) {
				filter = filter || {};
				filter.$uuid = "none"; // TODO: better send null, debug this
			}
		} else {
			// filter is a sdata condition
			// replace some standard properties; TODO: better, more generic definition ?
			r = r.replace("{$user}", globals.context.session.getUserLogin(_));
			// 
			var f = exports.sdataFilterToJson(r);
			// append filter
			if (filter) {
				filter = {
					$and: [filter, f]
				};
			} else filter = f;
		}
	}
	config.tracer && config.tracer("addRights filter exit: " + sys.inspect(filter));
	return filter;
};