"use strict";
// Thin layer on top of persistence to handle rhino/jdbc environement
var helpers = require('syracuse-core/lib/helpers')
var find = helpers.object.find;
var forEachKey = helpers.object.forEachKey;
var types = require("syracuse-core/lib/types/allTypes");
var persistencejs = require('../deps/persistencejs/lib/persistence');
var mysql = require('../deps/persistencejs/lib/persistence.store.mysql');
var mappingTracer = helpers.debug.tracer("sql.mapping");
// jdbc converts our time values from local to GMT based on Jan 1st 1970 timezone offset
// when we pass them to mysql. So, in Paris, they are 1 hour off (up) when we query them from normal SQL clients.
// So we fix this by adding timeOffset before passing times to mysql and subtracting timeOffset when reading from mysql.
// Note: the Java timeoffset is backwards and expressed in minutes: -60 in GMT+1
// TODO: NODE
var timeOffset = 0;

var _typeMapper = {
	idType: {
		sqlType: "BINARY(16)",
		type: "uuid"
	},
	columnType: function(prop) {
		return prop.sqlType;
	},
	inVar: function(str, prop) {
		switch (prop.type) {
		case "uuid":
			return "hex(" + str + ")";
		case "binary":
		case "json":
		case "xml":
		case "text":
			return prop.$isLazy ? ("length(" + str + ")") : str;
		default:
			return str;
		}
	},
	outVar: function(str, prop) {
		switch (prop.type) {
		case "uuid":
			return "unhex(" + str + ")";
		default:
			return str;
		}
	},
	outId: function(id) {
		return "unhex('" + id.replace(/-/g, '') + "')"
	},
	newUuid: helpers.uuid.generate,
	defaultValue: function(prop) {
		return null;
	},
	entityValToDbVal: function(val, prop, metaName) {
		var type = prop.sqlType;
		mappingTracer && mappingTracer("to db: " + metaName + " type=" + prop.sqlTyp + " val=" + val)
		if (val && val.id) return val && helpers.uuid.toString32(val.id);
		switch (prop.type) {
		case "uuid":
			return val && helpers.uuid.toString32(val);
		case "json":
			return val && JSON.stringify(val);
		case "text":
			return val;
		case "decimal":
			return val && val.toString();
		case "datetime":
			//format YYYY-MM-DD HH:MM:SSZ
			var str = val && val.toString("yyyy-MM-dd HH:mm:ssZ");
			return str && str.substring(0, str.length - 1);
		case "date":
			//format YYYY-MM-DD
			return val && val.toString(null);
		case "time":
			//format HH:MM:SS
			return val && val.toString();
		default:
			return val;
		}
	},
	dbValToEntityVal: function(val, prop, metaName) {
		mappingTracer && mappingTracer("from db: " + metaName + " type=" + prop.sqlType + " val=" + val)
		switch (prop.type) {
		case "uuid":
			return val && helpers.uuid.fromString32(val);
		case "text":
			return prop.$isLazy ? (val ? {
				$url: ""
			} : null) : val;
		case "json":
			return prop.$isLazy ? (val ? {
				$url: ""
			} : null) : val && JSON.parse(val);
		case "datetime":
			// native-mysql: val= new Date(dbvalue+'Z');
			return val && types.datetime.fromJsDate(val);
		case "date":
			// native-mysql: val= new Date(dbvalue+'Z');
			return val && types.date.fromJsDate(val, true);
		case "time":
			// native-mysql format HH:MM:SS
			return val && types.time.parse(val, null);
		case "boolean":
			return val == null ? null : val != '\u0000';
		case "integer":
		case "period":
			return val == null ? null : val;
		case "real":
			return val == null ? null : val;
		case "decimal":
			return val == null ? null : types.decimal.make(val, prop.scale);
		default:
			return prop.$isLazy ? (val ? {
				$url: ""
			} : null) : val;
		}
	}
}

exports.create = function(model, dataset) {
	if (dataset.driver === "mongodb") {
		return require('syracuse-orm/lib/mongodbOrm').create(model, dataset);
	} else {
		return new function() {
			var persistence = persistencejs.createPersistence();
			persistence.debug = helpers.debug.tracer("sql.execute") != null;
			mysql.config(persistence, dataset.hostname, dataset.port, dataset.database, dataset.login, dataset.password);
			// persistence API is hacky, need to get getSession immediately after config.
			var getSession = mysql.getSession;

			//model.dump = persistence.dump.bind(persistence);
			//model.load = persistence.load.bind(persistence);
			model.reset = persistence.reset.bind(persistence);
			persistence.typeMapper = helpers.object.extend(_typeMapper, persistence.typeMapper);

			this.define = function(name, fields) {
				var dbFactory = persistence.define(name, fields);
				return dbFactory;
			}
			this.connect = function(_) {
				try {
					var session = getSession(_);
					// Expose these 3 persistence methods for the service layer
					// do not expose persistence itself for now
					// Must be done after config call. Otherwise reset does not exist
					if (dataset.dirty) {
						session.schemaSync(session.transaction(_), _, null);
						dataset.dirty = false;
					}
					return session;
				} catch (ex) {
					helpers.log.error(module, "cannot connect to " + dataset + ": " + ex)
					throw ex;
				}
			}
			this.reset = function(_, transaction) {
				persistence.reset(transaction, _);
			}
		}
	}
}