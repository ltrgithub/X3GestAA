"use strict";
var helpers = require("syracuse-core/lib/helpers");
var forEachKey = helpers.object.forEachKey;

function DbHandleCollection(persistence) {
	this._internalInit(persistence);

}

// a sample list of dbHandles
helpers.defineClass(DbHandleCollection, null, {
	_internalInit: function(persistence) {
		var self = this;
		self._items = []; // dbHandle llist
		self.loaded = true;
		self._persistence = persistence;
		self._limit = -1;
		self._skip = 0;
		self._reverse = false;
		self._orderColumns = [];
	},
	persistQueries: function() {
		return []
	},
	afterAdd: function(_, dbHandle, notify) {},
	add2: function(_, dbHandle, notify) {
		var self = this;
		if (notify == null) notify = true;
		if (self._items.indexOf(dbHandle.id) >= 0) {
			return;
		}
		self._items.push(dbHandle.id);
		self.afterAdd(_, dbHandle, notify);
	},
	count: function(tx, _) {
		var self = this;
		return self._items.length;
	},
	insert2: function(_, index, dbHandle, notify) {
		var self = this;
		if (notify == null) notify = true;
		if (self._items.indexOf(dbHandle.id) >= 0) return;
		var count = self.count(_);
		if ((index < count) && (index > 0)) {
			self._items.splice(index, 0, dbHandle.id);
			self.afterAdd(_, dbHandle, notify);
		} else return self.add2(_, dbHandle, notify);
	},
	load: function(dbHandles, _) {
		var self = this;
		self.dbHandles.length = 0;
		dbHandles.forEach_(_, function(_, dbHandle, index) {
			self.dbHandles.push(dbHandle);
		});
	},
	dbHandle: function(id) {
		var self = this;
		return self._persistence.trackedObjects[id];
	},
	sort: function() {
		var self = this;
	},
	_afterRemove: function(_, dbHandle, notify) {
		return dbHandle;
	},
	find: function(id) {
		var self = this;
		if (id) return self._items.indexOf(id);
		else return -1;
	},
	_move: function(oldIndex, newIndex) {
		var self = this;
		if (oldIndex != newIndex) {
			var old = self._items[oldIndex];
			self._items.splice(oldIndex, 1);
			self._items.splice(newIndex, 0, old);
		}
	},
	remove: function(dbHandle, callback, notify) {
		var self = this;
		self.remove2(function(err, result) {
			if (err) return tx.errorHandler && tx.errorHandler(err);
			if (callback) callback(result);
		}, dbHandle, notify);
	},
	remove2: function(_, dbHandle, notify) {
		var self = this;
		var index = find(dbHandle.id)
		return self.removeByIndex(_, index, notify);
	},
	removeByIndex: function(_, index, notify) {
		var self = this;
		if (notify == null) notify = true;
		if ((index >= 0) && (index < self._items.length)) {
			var dbHandle = self.dbHandle(self._items[index]);
			self._items.splice(index, 1);
			return self._afterRemove(_, dbHandle, notify);
		}
		return null;
	},
	order: function(column, asc) {
		var self = this;
		return self;
	},
	list: function(tx, _) {
		var self = this;
		var results = [];
		self._items.forEach_(_, function(_, id, index) {
			results.push(self.dbHandle(id));
		});
		return results;
	},
	applyDiff: function(_, resource, deleteMissing) {
		var self = this,
			i;
		var delta = {};
		var removeList = [],
			createList = [],
			editList = [];
		var dst = {};
		var firstModified = self._items.length;
		var _patchStartIndex = function(index) {
				firstModified = Math.min(firstModified, index);
			};
		self._items.forEach(function(id, index) {
			dst[id] = true;
		}); // fast find
		resource.forEach_(_, function(_, element) {
			if (!deleteMissing && (element.$index == null)) deleteMissing = true;
			var id = element.$uuid || element.$key;
			if (!id) {
				id = helpers.uuid.generate();
				element.$uuid = id;
			}
			if (element.$isDeleted) {
				deleteMissing = false;
				i = dst[id];
				if (dst[id]) {
					delete dst[id];
					i = self._items.indexOf(id);
					var dbHandle = self.removeByIndex(_, i, false);
					if (dbHandle) removeList.push(dbHandle)
					_patchStartIndex(i);
				}
			} else delta[id] = element;
		});
		if (deleteMissing) {
			// remove missing
			i = self._items.length
			while (i-- > 0) {
				var id = self._items[i];
				if (!delta[id]) {
					delete dst[id];
					var dbHandle = self.removeByIndex(_, i, false);
					if (dbHandle) removeList.push(dbHandle);
					_patchStartIndex(i);
				}
			}
		}
		// add /insert/edit
		i = 0;
		forEachKey(delta, function(id, value) {
			if (dst[id]) {
				var index = self._items.indexOf(id);
				_patchStartIndex(index);
				var newIndex = (value.$index == null) ? index : value.$index;
				if ((newIndex >= self.length) || (newIndex < 0)) newIndex = self.length - 1;
				_patchStartIndex(newIndex);
				editList.push(value);
				self._move(index, newIndex);
			} else {
				createList.push(value);
				var newIndex = (value.$index == null) ? self._items.length : ((value.$index < 0) ? self._items.length : value.$index);
				_patchStartIndex(newIndex);
				self._items.splice(newIndex, 0, id);
			}
		});
		return {
			removeList: removeList,
			createList: createList,
			editList: editList,
			firstModified: firstModified
		};
	}
});

function ClassDbHandleCollection(persistence) {
	DbHandleCollection.call(this, persistence);
}

helpers.defineClass(ClassDbHandleCollection, DbHandleCollection, {
	sort: function() {
		var self = this;
		self._items.sort(function(a, b) {
			a = self.dbHandle(a);
			b = self.dbHandle(b);
			for (var i = 0; i < self._orderColumns.length; i++) {
				var col = self._orderColumns[i][0];
				var asc = self._orderColumns[i][1];
				var aVal = self._persistence.get(a, col); //todo
				var bVal = self._persistence.get(b, col); //todo
				if (aVal < bVal) {
					return asc ? -1 : 1;
				} else if (aVal > bVal) {
					return asc ? 1 : -1;
				}
			}
			return 0;
		});
	},
	entity: {
		get: function() {
			return this._entity;
		},
		set: function(value) {
			this._entity = value;
		}
	}

});

function CompositionCollection(persistence) {
	ClassDbHandleCollection.call(this, persistence);
};

helpers.defineClass(CompositionCollection, ClassDbHandleCollection, {
	parent: {
		get: function() {
			var self = this;
			return self._parent;
		}
	},
	relation: {
		get: function() {
			var self = this;
			return self._relation;
		},
		set: function(value) {
			var self = this;
			self._orderColumns.length = 0;
			self._relation = value;
			if (self._relation) {
				self.entity = self._relation.targetEntity;
				self._relation.defaultOrder.forEach(function(order) {
					self._orderColumns.push([order[0], order[1]]);
				});
			}
		}
	},
	afterAdd: function(_, dbHandle, notify) {
		var self = this;
		//fix persitence
		if (dbHandle._new) {
			dbHandle[self.relation.inv] = self.parent;
		} else {
			// si on fait  dbHandle[relation.inv] = dbHandle;
			dbHandle._data[self.relation.inv] = self.parent.id;
			dbHandle._data_obj[self.relation.inv] = self.parent;
		}
		self._persistence.add(dbHandle);
		if (notify && self._onListChanged) {
			var dbHandles = self.list(null, _);
			self._onListChanged(_, self._parent, self.relation, dbHandles, 0);
		}

	}
});

function ManyToManyCollection(persistence) {
	var self = this;
	CompositionCollection.call(self, persistence);
	self._saved = {};
	self._cache = {};
}

helpers.defineClass(ManyToManyCollection, CompositionCollection, {
	save: function() {
		var self = this;
		self._items.forEach(function(item) {
			self._saved[item] = item;
		});
		forEachKey(self._cache, function(id) {
			if (!self._saved[id]) delete self._cache[id];
		})
	},
	afterAdd: function(_, dbHandle, notify) {
		var self = this;
		if (dbHandle) {
			self._cache[dbHandle.id] = dbHandle;
		}
	},
	_afterRemove: function(_, dbHandle, notify) {
		var self = this;
		if (dbHandle) self._cache[dbHandle.id] = dbHandle;
		return dbHandle;
	},
	beforeDelete: function(original) {
		// delete old
		var self = this;
		forEachKey(self._saved, function(id) {
			var dbHandle = self._cache[id];
			if (dbHandle) original._localRemoved.push(dbHandle);
		});
	},
	beforeCommit: function(original) {
		var self = this;
		self._items.forEach(function(id) {
			if (!self._saved[id]) {
				var dbHandle = self._cache[id];
				if (dbHandle) original._localAdded.push(dbHandle);
			}
		});
		forEachKey(self._saved, function(id) {
			var dbHandle = self._cache[id];
			if (self._items.indexOf(id) < 0) {
				var dbHandle = self._cache[id];
				if (dbHandle) {
					original._localRemoved.push(dbHandle);
				}
			}
		});
	}
});

exports.createCompositionList = function(persistence, dbHandle, relation, name, onListChanged) {
	var result = new CompositionCollection(persistence);
	result._parent = dbHandle;
	result.relation = relation;
	result._onListChanged = onListChanged;
	return result;
};
exports.createManyToManyList = function(persistence, dbHandle, relation, name) {
	var result = new ManyToManyCollection(persistence);
	result._parent = dbHandle;
	result.relation = relation;
	return result;
};