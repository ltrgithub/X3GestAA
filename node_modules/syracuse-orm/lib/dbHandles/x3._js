"use strict"

var globals = require('streamline/lib/globals');
var helpers = require("syracuse-core/lib/helpers");
var pool = require("syracuse-x3/lib/pool");
var filterHelpers = require("syracuse-orm/lib/filters");
var Factory = require("syracuse-orm/lib/factory").Factory;
var Template = require("syracuse-core/lib/resource/resourceProxy").Template;
var locale = require("syracuse-core/lib/locale");
var sys = require("util");

var tracer = console.log;
var tracer = null;

var _models = {};

var _allEvents = ["$beforeSave", "$canSave", "$afterSave"];


function _fetchPrototype(_, handle, entityName, facetName) {
	if(!facetName)
		throw new Error("_fetchPrototype: facetName is required");
	// fetch prototype
	var client = handle._client;
	var pr = client.jsonSend(_, {
		head: {
			headers: {
				"accept": "application/json;vnd.sage=syracuse",
				"accept-language": locale.current || "en-US"
			},
			method: "GET",
			url: handle._baseUrl + "/$prototypes('" + entityName + "." + facetName + "')"
		},
		body: {}
	});
	//
	return pr && pr.body;
}

function X3Entity(model, entityName) {
	this._model = model;
	this.name = entityName;
	this.$isPersistent = true;
	this.$orgPrototypes = {};
	this.$properties = {};
	this.$relations = {};
}

helpers.defineClass(X3Entity, null, {
	createInstance: function(_, db, initial) {
		return this.factory.createInstance(_, initial, db);
	},
	fetchInstance: function(_, db, options) {
		return db.fetchInstance(_, this, options);
	},
	fetchInstances: function(_, db, options) {
		return db.fetchInstances(_, this, options);
	},
	count: function(_, db, options) {
		return db.count(_, this, options);
	},
	//
	// add standard links resources for the entity
	fillLinksResource: function(reprType, resource) {
		resource.$links = (ent.$orgPrototypes[reprType] || {}).$links;
		resource.$actions = (ent.$orgPrototypes[reprType] || {}).$actions;
	},
	getPrototype: function(_, facetName) {
		return this.$orgPrototypes[facetName] || (this.$orgPrototypes[facetName] = _fetchPrototype(_, this._model.getHandle(_), this.name, facetName));
	},
	getSearchFacets: function(_) {
		// TODO: make an array of facets to be indexed
		return null;
	},
	getSearchFields: function(_) {
		// TODO: all fields should be indexed ??
		return Object.keys(this.$properties);
	}
});

function _jsonToEntity(_, proto, localization, model, entityName, facet) {
	var loc = localization;
	var ent = model._entities[entityName] || (new X3Entity(model, entityName));
	//
	ent.$orgPrototypes[facet || "$details"] = proto;
	var itProto = proto.$.$resources ? proto.$.$resources.$item : proto;
	var pr = itProto.$;
	ent.$key = itProto.$key || "$uuid";
	// TODO: there should be $valueTemplate or $summaryTemplate on the prototype
	ent.$valueTemplate = itProto.$key;
	//
	Object.keys(pr).forEach_(_, function(_, pName) {
		var prop = pr[pName];
		if(prop.$type) {
			var p;
			switch(prop.$type) {
				case "application/x-reference":
					// for now, extract the class from url
					var className = prop.$url.match(/.*representation=(.*).*/)[1].split("&")[0].split(".")[0];
					p = ent.$relations[pName] = {
							$type: className,
							$title: (loc && (new Template(prop.$title)).resolve(loc)) || prop.$title,
							targetEntity: _jsonToEntity(_, prop, localization, model, className, facet),
							isPlural: false,
							$isPlural: false
						}
					break;
				case "application/x-collection":
					p = ent.$relations[pName] = {
						$title: (loc && (new Template(prop.$title)).resolve(loc)) || prop.$title,
						isPlural: true,
						$isPlural: true
					}
					var className;
					if(prop.$item.$type === "application/json") {
						// load from item; TODO: get the classname from $prototype
						className = pName;
						p.$isChild = p.isChild = true;
					} else {
						className = prop.$item.$url.match(/.*representation=(.*).*/)[1].split("&")[0].split(".")[0];
					}
					p.$type = className;
					p.targetEntity = _jsonToEntity(_, prop.$item, localization, model, className, facet);
					break;
				case "application/x-choice":
					p = ent.$properties[pName] = {
						$type: prop.$value.$type.replace("application/x-", ""),
						$title: (loc && (new Template(prop.$title)).resolve(loc)) || prop.$title,
					}
					p.type = p.$type;
					p.title = p.$title;
					//
					p.$enum = [];
					p.$enumCaptions = [];
					//
					prop.$value.$constraints.$enum.forEach(function(e) {
						p.$enum.push(e.$value);
						p.$enumCaptions.push(e.$title);
					});
					break;
				default:
					p = ent.$properties[pName] = {
						$type: prop.$type.replace("application/x-", ""),
						$title: (loc && (new Template(prop.$title)).resolve(loc)) || prop.$title,
					}
					p.type = p.$type;
					p.title = p.$title;
			}
			p.name = pName;
			p.hasDefaultValue = function() { return false; } // TODO
			p.isExternalStorage = function() { return false; } // TODO
		}
	});
	ent.factory = new Factory(ent);
	//
	return ent;
}

function _makeEntity(_, model, entityName, facet) {
	var pr = _fetchPrototype(_, model.getHandle(_), entityName, (facet || "$details"));
	//
	if(!pr || !pr.$) return null;
	// convert to entity
	var ent = _jsonToEntity(_, pr, pr.$localization, model, entityName, facet);
	//
	return model._entities[entityName] = ent;
}

function _fetchQueryResources(_, handle, entity, parameters) {
	var params = parameters || {}
	var sdataWhere = filterHelpers.jsonToSdata(params);
	var client = handle._client;
	var r = client.jsonSend(_, {
		head: {
			headers: {
				"accept":"application/json;vnd.sage=syracuse",
				"accept-language": locale.current || "en-US"
			}, 
			method: "GET",
			url: handle._baseUrl + "/" + entity.name + "?representation=" + entity.name + ".$query" + 
					(sdataWhere ? "&where=(" + encodeURIComponent(sdataWhere) + ")" : "") +
					(params.count ? "&count=" + params.count : "")
		},
		body: {}
	});
	if(!r || !r.body || !r.body.$resources) return null;
	// convert to entity
	return r.body.$resources;
}

function _fetchDetailResource(_, handle, entity, key) {
	var r = handle._client.jsonSend(_, {
		head: {
			headers: {
				"accept":"application/json;vnd.sage=syracuse",
				"accept-language": locale.current || "en-US"
			}, 
			method: "GET",
			url: handle._baseUrl + "/" + entity.name + "('" + key + "')?representation=" + entity.name + ".$details"
		},
		body: {}
	});
	if(!r || !r.body || !r.body) return null;
	// convert to entity
	return r.body;
}

function X3Cursor(handle, entity, x3BulkReader) {
	this._cursor = cursor;
	this._entity = entity;
	this._db = handle;
	this._reader = x3BulkReader;
}

helpers.defineClass(X3Cursor, null, {
	next: function(_) {
		var r = this._reader.next(_);
		return r && this._entity.factory.createInstance(_, r, this._handle);
	}
});

function X3Model(endpoint) {
	var self = this;
	//
	self._entities = {};
	self._endpoint = endpoint;
	// global events
	self.$events = {};
	_allEvents.forEach(function(name) {
		self.$events[name] = self.$events[name] || [];
	})
}

helpers.defineClass(X3Model, null, {
	getEntity: function(_, entityName, facet) {
		if(this._entities[entityName] && this._entities[entityName].$orgPrototypes[facet])
			return this._entities[entityName];
		//
		return _makeEntity(_, this, entityName, facet);
	},
	getIndexedEntities: function(_) {
		// fetch indexed entities from X3 (returns an array)
		return [this.getEntity(_, "ATABLE")];
	},
	getSearchFacets: function(_) {
		// fetch search facets from X3
	},
	registerEvent: function(_, eventName, handler, entityName) {
		var target = entityName ? self.getEntity(entityName) : self;
		if(target && target.$events && target.$events[eventName])
			target.$events[eventName].push(handler);
	},
	getHandle: function(_) {
		return this._handle || (this._handle = exports.create(_, this._endpoint));
		//return this._handle || (this._handle = exports.create(_, this._endpoint))Â 
	}
});

function X3DbHandle(endpoint, model) {
	this._endpoint = endpoint;
	this._model = model;
}

helpers.defineClass(X3DbHandle, null, {
	connect: function(_) {
		this._client = pool.getClient(_, globals.context.session, this._endpoint);
		this._baseUrl = this._endpoint.getBaseUrl(_);
	},
	//
	/// -------------
	/// ## getEntity function :
	/// ``` javascript
	/// var entity = db.getEntity(_, entityName);
	/// ```
	/// Get the class metadata as an entity
	/// 
	/// 
	getEntity: function(_, entityName, facet) {
		return this._model.getEntity(_, entityName, facet);
	},
	// fetch instance
	fetchInstance: function(_, entity, params) {
		tracer && tracer("fetch instance: " + entity.name + "; " + sys.inspect(params));
		// if params is string, then it's the object key, or a filter otherwise
		var r;
		if(typeof params === "object") {
			params.count = 1;
			r = _fetchQueryResources(_, this, entity, params);
			r = (r || [])[0];
		} else
			r = _fetchDetailResource(_, this, entity, params);
		//
		return entity.factory.createInstance(_, r, this);
	},
	//
	count: function(_, entity, params) {
		throw new Error("count(_): Unsupported for this driver");
	},
	//
	/// -------------
	/// ## createCursor function :
	/// ``` javascript
	/// var cursor = db.createCursor(_, entity, params, shallow);
	/// var data;
	/// while(data = cursor.next(_) {
	///   // do something with data witch is an object instance
	/// }
	/// ```
	/// Creates a cursor allowing to iterate over the objects in a collection
	/// function next(_) on the cursor returns the current instance. Returns null at the end of the cursor
	/// 
	/// ```javascript
	/// // parameters example
	/// params = {
	///   count: 20, // cursor fetch limit
	///   startIndex: 2, // skip parameter
	///   orderBy: [{binding:"name", descending: true}, {binding: title}],
	///   jsonWhere: {/* mongodb style json filter */} // or sdataWhere = sdataClause or where = parsed_expression_object
	/// }
	/// ```
	/// 
	createCursor: function(_, entity, params) {
		// NOT SUPPORTED YET
		return null;
		// create a bulk mode x3 cursor
		return new X3Cursor(this, entity, this._client.createBulkReader(_, {
			entityName: entity.name,
			where: filterHelpers.jsonToSdata(params)
		}));
	},
	// fetch all instances acording to parameters
	fetchInstances: function(_, entity, params) {
		var self = this;
		var r = _fetchQueryResources(_, self, entity, params);
		return (r || []).map_(_, function(_, item) {
			return entity.factory.createInstance(_, item, self);
		});
	}
});

exports.makeModel = function(_, endpoint) {
	return _models[endpoint.$uuid] || (_models[endpoint.$uuid] = new X3Model(endpoint));
}

exports.create = function(_, endpoint) {
	var handle = new X3DbHandle(endpoint, endpoint.getModel(_));
	handle.connect(_);
	return handle;
}

exports.setup = function(options) {
	if(!options) return;
	// x3 pool injection (for tests)
	if(options.x3driver)
		pool = options.x3driver;
}
