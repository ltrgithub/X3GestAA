'use strict';

var fs = require('streamline-fs');
var fsp = require('path');
var helpers = require('../helpers');
var health = require('syracuse-health/lib/check');
var ez = require('ez-streams');
var mongo = require('streamline-mongodb');

module.exports = {
	$titleTemplate: 'Site {customer} {site}',
	$helpPage: 'SKY-reference-site',
	$createActionTitle: 'New site',
	$listTitle: 'List of Sites',
	$properties: {
		site: {
			$title: 'Site',
			$isMandatory: true,
			$linksToDetails: true,
		},
		shortName: {
			$title: 'Short Name',
			$isMandatory: true,
		},
		isDefault: {
			$title: 'Default site',
			$type: 'boolean',
			$default: false,
		},
		status: {
			$title: 'Status',
			$isReadOnly: true,
			$default: 'created',
		},
		uri: {
			$title: 'Site URI',
			$isReadOnly: true,
		},
		ipX3: {
			$title: 'IP of X3 instance',
			$isReadOnly: true,
		},
		ipORA: {
			$title: 'IP of Oracle instance',
			$isReadOnly: true,
		},
		isTest: {
			$title: 'Test site',
			$type: 'boolean',
			$default: false,
			$isHidden: true,
		},
	},
	$relations: {
		customer: {
			$title: 'Customer',
			$type: 'customer',
			$inv: 'sites',
			$isMandatory: true,
		},
		subscriptions: {
			$title: 'Subscriptions',
			$type: 'subscriptions',
			$inv: 'site',
			$isComputed: true
		},
	},
	$searchIndex: {
		$fields: ['site']
	},
	$uniqueConstraints: [
		['customer', 'site']
	],
	$functions: {},
	$services: {
		provision: {
			$title: 'Provision',
			$method: 'POST',
			$invocationMode: 'async',
			$capabilities: 'abort',
			$isMethod: true,
			$execute: function(_, context, instance) {
				var service = 'provision';
				setStatus(_, context, instance, service);
			},
		},
		activate: {
			$title: 'Activate',
			$method: 'POST',
			$invocationMode: 'async',
			$capabilities: 'abort',
			$isMethod: true,
			$execute: function(_, context, instance) {
				var service = 'activate';
				setStatus(_, context, instance, service);
			}
		},
		suspend: {
			$title: 'Suspend',
			$method: 'POST',
			$invocationMode: 'async',
			$capabilities: 'abort',
			$isMethod: true,
			$execute: function(_, context, instance) {
				var service = 'suspend';
				setStatus(_, context, instance, service);
			}
		},
		shelve: {
			$title: 'Shelve',
			$method: 'POST',
			$invocationMode: 'async',
			$capabilities: 'abort',
			$isMethod: true,
			$execute: function(_, context, instance) {
				var service = 'shelve';
				setStatus(_, context, instance, service);
			}
		},
		restore: {
			$title: 'Restore',
			$method: 'POST',
			$invocationMode: 'async',
			$capabilities: 'abort',
			$isMethod: true,
			$execute: function(_, context, instance) {
				var service = 'restore';
				setStatus(_, context, instance, service);
			}
		},
		'delete': {
			$title: 'Delete',
			$method: 'POST',
			$invocationMode: 'async',
			$capabilities: 'abort',
			$isMethod: true,
			$execute: function(_, context, instance) {
				var service = 'delete';
				setStatus(_, context, instance, service);
			}
		},
		siteHealth: {
			$title: 'Check site health',
			$method: 'GET',
			$isMethod: true,
			$isHidden: true,
			$execute: function(_, context, instance) {
				return health.getSiteHealth(_, context, instance);
			},
		},
		health: {
			$title: 'Health all sites',
			$method: 'GET',
			$isHidden: true,
			$execute: function(_, context) {
				return health.getHealth(_, context);
			},
		},
		siteX3Usage: {
			$title: 'Check site usage metrics',
			$method: 'GET',
			$isMethod: true,
			$isHidden: true,
			$execute: function(_, context, instance) {
				return health.getSiteUsage(_, context, instance, 'x3');
			},
		},
		x3Usage: {
			$title: 'Usage Metrics all sites',
			$method: 'GET',
			$isHidden: true,
			$execute: function(_, context) {
				return health.getUsage(_, context, 'x3');
			},
		},
		siteDbUsage: {
			$title: 'Check site usage metrics',
			$method: 'GET',
			$isMethod: true,
			$isHidden: true,
			$execute: function(_, context, instance) {
				return health.getSiteUsage(_, context, instance, 'db');
			},
		},
		dbUsage: {
			$title: 'Usage Metrics all sites',
			$method: 'GET',
			$isHidden: true,
			$execute: function(_, context) {
				return health.getUsage(_, context, 'db');
			},
		},
		update: {
			$title: 'Update',
			$method: 'POST',
			$invocationMode: 'async',
			$capabilities: 'abort',
			$isMethod: true,
			$execute: function(_, context, instance) {
				updateHibernate(_, context, instance);
			},
		},
	},
};

function codify(str) {
	return str.replace(/[^\w]/gi, '').toLowerCase();
}

function setStatus(_, context, instance, service) {
	helpers.tracker = context.tracker;
	helpers.log('I-phase: Service process started:', service);
	var site = codify(instance.site(_));
	var customer = codify(instance.customer(_).customer(_));
	var shortName = instance.shortName(_).replace(/ /g,'').toLowerCase();

	/**
	 * provision: changes the status from created to provisioned.
	 * activate: changes the status from provisioned, hibernating or suspended to active.
	 * suspend: changes the status from active, hibernating or provisioned to suspended.
	 * shelve: changes the status from suspended to shelved.
	 * restore: changes the status from shelved to suspended.
	 * delete: changes the status from suspended, shelved, created, provisioned to deleted.
	 */
	var statusMap = {
		'provision': {
			curr: ['created'],
			next: 'provisioned',
			params: {
				customer: customer,
				site: site,
				stack: shortName,
			},
			postOp: function(_, context, instance) {
				var server = new mongo.Server('localhost', '27017');
				var db = new mongo.Db('production', server, {
					fsync: true
				});
				var result = db.open(_);
				var collection = db.collection('Site', _);
				//Thought we needed a regular expression expecting instance.site(_) to be all lower case.
				//However, that is not the case at this point so going to a straight find on mongodb.
				//var cursor = collection.find(  {site: { $regex: new RegExp('^' + instance.site(_) + '$', 'i') }} ).toArray(_);
				var cursor = collection.find( {site:instance.site(_)} ).toArray(_);
				instance.uri(_, cursor[0].uri);
				instance.ipX3(_, cursor[0].ipX3);
				instance.ipORA(_, cursor[0].ipORA);
			},
		},
		'activate': {
			curr: ['provisioned', 'hibernating', 'suspended'],
			next: 'active',
			params: instance.status(_) === 'provisioned' ? null : {
				stack: shortName,
			},
			postOp: require('../services/activate'),
		},
		'suspend': {
			curr: ['active', 'hibernating', 'provisioned'],
			next: 'suspended',
			params: {
				stack: shortName,
			},
		},
		'shelve': {
			curr: ['suspended'],
			next: 'shelved',
			params: {
				stack: shortName,
			},
			postOp: require('../services/delete'),
		},
		'restore': {
			curr: ['shelved'],
			next: 'suspended',
			params: {
				customer: customer,
				site: site,
				stack: shortName,
			},
		},
		'delete': {
			curr: ['suspended', 'shelved', 'created', 'provisioned'],
			next: 'deleted',
			postOp: require('../services/delete'),
		},
	};

	if (!statusMap[service] || statusMap[service].curr.indexOf(instance.status(_)) === -1)
		throw new Error('Invalid status change!');

	// call to ops for service
	if (statusMap[service].params && !instance.isTest(_)) helpers.ops(_, service, statusMap[service].params);

	if (statusMap[service].postOp) statusMap[service].postOp(_, context, instance);

	instance.status(_, statusMap[service].next);
	instance.save(_);
	helpers.log('I-phase: Service process completed:', service);
}

var temp = 0;
function updateHibernate(_, context, instance) {
	var baseHost = "http://localhost:8124";
	var path = context.request.url.substring(0, context.request.url.indexOf('sites'));

	var listOfSubs = instance.subscriptions(_)._array;
	var filtered = listOfSubs.filter(filterArrayByDate);
	var mostRecentSub = filtered[0].$key;

	var collabUrl = baseHost + path + "subscriptions(\'" + mostRecentSub + "\')";
	var hibernateData = context.request.readAll(_);

	var resp = ez.devices.http.client({
		rejectUnauthorized: false,
		url: collabUrl,
		method: 'PUT',
		headers: {
			Authorization: 'Basic YWRtaW46YWRtaW4=',
			'content-type': 'application/json',
		}
	}).end(hibernateData).response(_);

	if (resp.statusCode !== 200){
		helpers.error('Error managing subscription');
		return;
	}
}

function filterArrayByDate(element, index, array) {
	if (array.length === 1)
		temp = element;
	
	if(index !== 0) {
		if (element.$creDate > array[index-1].$creDate)
			temp = element;
	}

	if (index === (array.length-1))
		return temp;
}