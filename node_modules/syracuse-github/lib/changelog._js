"use strict";
var streams = require("streamline-streams");
var fs = require("streamline-fs");
var fsp = require("path");
var sys = require("util");

var tags_limit = 10;
var tracer; // = console.log;

var _formatters = {
	"html": function(json) {
		var cnt = '<!DOCTYPE html><html><head><meta charset="UTF-8" /><link href="/syracuse-ui/themes/markdown.css" rel="stylesheet" type="text/css"/></head><body>';
		json.forEach(function(tag) {
			cnt += '<h1>' + tag.name + '</h1>';
			tag.issues.forEach(function(issue) {
				cnt += '#' + issue.issue.number + ' (' + issue.issue.state + ') :' + '<a href="https://github.com/Sage-ERP-X3/Syracuse/issues/' + issue.issue.number + '" target="blank">' + issue.issue.title + '</a>';
				cnt += '<ul>';
				issue.commits.forEach(function(commit) {
					cnt += '<li><a href="https://github.com/Sage-ERP-X3/Syracuse/commit/' + commit.sha + '" target="blank">' + (new Date(Date.parse(commit.date))).toUTCString() + ' ' + commit.committerName + '</a>: ' + commit.message + '</li>';
				});
				cnt += '</ul>';
			});
		});
		cnt += '</body></html>';
		return cnt;
	},
	"txt": function(json) {

	}
};

function _makeUrl(owner, repo, objName) {
	return "https://api.github.com/repos/" + owner + "/" + repo + "/" + objName;
}

function _buildChangeLog(_, options) {
	function _getFromGithub(_, path) {
		if (path.substr(0, 5) !== "https") path = _makeUrl(options.owner, options.repo, path);
		var opt = {
			url: path,
			method: "GET",
			user: options.user,
			password: options.password,
			headers: {
				"user-agent": options.user
			}
		};
		if (options.proxy) opt.proxy = options.proxy;
		var req = streams.httpRequest(opt).proxyConnect(_).end();
		var res = req.response(_);
		if (res.statusCode != 200) {
			throw new Error("Git http error " + res.statusCode + ": " + res.readAll(_));
		} else return {
			headers: res.headers,
			body: JSON.parse(res.readAll(_))
		};
	}

	function _getIssue(_, number) {
		if (!issues[number]) {
			var issue = _getFromGithub(_, "issues/" + number);
			if (issue.body) {
				var it = issues[number] = {};
				["url", "number", "title", "state" /*, "body"*/ ].forEach(function(k) {
					it[k] = issue.body[k];
				});
			} else issues[number] = null;
		}
		return issues[number];
	}

	function _getLocalIssue(_, store, number) {
		if (!number) number = 0;
		if (store[number]) return store[number];
		return store[number] = number === 0 ? {
			issue: {
				number: 0,
				title: "No issue"
			},
			commits: []
		} : {
			issue: _getIssue(_, number),
			commits: []
		};
	}
	// issues
	var issues = {};
	// fetch tags
	var tags = _getFromGithub(_, "tags").body;
	tracer && tracer("tags:\n" + sys.inspect(tags));
	//
	tags = tags.filter(function(t) {
		return (!options.tag_filter || t.name.match(options.tag_filter)) && (!options.max_tag || t.name <= options.max_tag);
	});
	// start tags
	if (options.from_sha) {
		tags.push({
			name: options.from_sha,
			commit: {
				sha: options.from_sha
			}
		});
	}
	tags = tags.map_(_, function(_, t) {
		var commit = t.commit && t.commit.sha && _getFromGithub(_, "commits/" + t.commit.sha).body;
		// tracer && tracer("\ntag commit:\n" + sys.inspect(commit.commit));
		return {
			name: t.name,
			commit_sha: t.commit && t.commit.sha,
			date: commit && commit.commit && commit.commit.author.date,
			issues: []
		};
	}).slice(0, tags_limit).sort(function(a, b) {
		// sort descending
		// return a.name > b.name ? -1 : 1;
		return a.date > b.date ? -1 : 1;
	});
	tracer && tracer("\ntags:\n" + sys.inspect(tags));
	// return tags;
	tags.forEach_(_, function(_, tag, index) {
		// tracer && tracer("name: " + tag.name + ", index: " + index);
		var locIssues = {};
		var nextTag = tags[index + 1];
		// fetch commits
		if (!nextTag) return;
		try {
			tracer && tracer("\ncompare/" + nextTag.name + "..." + tag.name);
			var res = _getFromGithub(_, "compare/" + nextTag.name + "..." + tag.name);
		} catch (e) {
			console.error(e.message);
		}
		//
		//		if (res.headers && res.headers.link) nextCommitsUrl = /<(.*)>;\s?rel="next".*/.exec(res.headers.link);
		//		nextCommitsUrl = nextCommitsUrl && nextCommitsUrl[1];
		//
		var commits = res.body.commits;
		commits.some_(_, function(_, c) {
			if (c.parents && (c.parents.length >= 2)) return false;
			//
			var r = {
				sha: c.sha
			};
			if (c.committer) r.login = c.committer.login;
			if (c.commit && c.commit.committer) {
				r.committerName = c.commit.committer.name;
				r.date = c.commit.committer.date;
				r.message = c.commit.message;
			}
			tracer && tracer("Commit: " + c.sha + "; Date: " + r.date + +"author: " + c.commit.author.name + " Message: " + r.message);
			// issue
			var issue_nb = /.*#(\d+).*/.exec(r.message);
			issue_nb = issue_nb && issue_nb[1];
			var locIssue = _getLocalIssue(_, locIssues, issue_nb);
			//
			locIssue.commits.push(r);
			//
			return false;
		});
		//
		tag.issues = Object.keys(locIssues).map(function(k) {
			return locIssues[k];
		});
	});
	//
	tracer && tracer("\ntags:\n" + sys.inspect(tags));
	return tags;
}

function _makeChangelog(_, opt) {
	var options = JSON.parse(fs.readFile(fsp.join(__dirname, "../../../changelog/changelogSettings.json"), "utf8", _));
	options.max_tag = opt && opt.max_tag;
	options.from_sha = opt && opt.from_sha;
	var log = _buildChangeLog(_, options);
	fs.writeFile(fsp.join(__dirname, "../../changelog." + options.format), _formatters[(options.format || "txt")](log), "utf8", _);
};

exports.makeChangelog = function(cb, opt) {
	return _makeChangelog(_ >> cb, opt);
};