"use strict";
var streams = require("streamline-streams");
var fs = require("streamline-fs");
var fsp = require("path");
var sys = require("util");

var tags_limit = 10;
var tracer; // = console.log;


var _formatters = {
	"html": function(json) {
		var cnt = '<!DOCTYPE html><html><head><meta charset="UTF-8" /><link href="markdown.css" rel="stylesheet" type="text/css"/></head><body>';
		json.forEach(function(tag) {
			cnt += '<h1>' + tag.name + '</h1>';
			tag.issues.forEach(function(issue) {
				cnt += '#' + issue.issue.number + ' (' + issue.issue.state + ') :' + '<a href="https://github.com/Sage-ERP-X3/Syracuse/issues/' + issue.issue.number + '" target="blank">' + issue.issue.title + '</a>';
				cnt += '<ul>';
				issue.commits.forEach(function(commit) {
					cnt += '<li><a href="https://github.com/Sage-ERP-X3/Syracuse/commit/' + commit.sha + '" target="blank">' + (new Date(Date.parse(commit.date))).toUTCString() + ' ' + commit.committerName + '</a>: ' + commit.message + '</li>';
				});
				cnt += '</ul>';
			});
		});
		cnt += '</body></html>';
		return cnt;
	},
	"txt": function(json) {

	}
};

function _makeUrl(owner, repo, objName) {
	return "https://api.github.com/repos/" + owner + "/" + repo + "/" + objName;
}

function _buildChangeLog(_, options) {
	function _getFromGithub(_, path) {
		if (path.substr(0, 5) !== "https") path = _makeUrl(options.owner, options.repo, path);
		var opt = {
			url: path,
			method: "GET",
			user: options.user,
			password: options.password,
			headers: {
				"user-agent": options.user
			}
		};
		if (options.proxy) opt.proxy = options.proxy;
		var req = streams.httpRequest(opt).proxyConnect(_).end();
		var res = req.response(_);
		switch (res.statusCode) {
			case 200:
			case 404:
				return {
					headers: res.headers,
					body: JSON.parse(res.readAll(_))
				};
			default:
				throw new Error("Git http error (url: " + path + "; code: " + res.statusCode + ") " + res.readAll(_));
		};
	}

	function _getIssue(_, number) {
		if (!issues[number]) {
			var issue = _getFromGithub(_, "issues/" + number);
			if (issue.body) {
				var it = issues[number] = {};
				["url", "number", "title", "state" /*, "body"*/ ].forEach(function(k) {
					it[k] = issue.body[k];
				});
			} else issues[number] = null;
		}
		return issues[number];
	}

	function _getLocalIssue(_, store, number) {
		if (!number) number = 0;
		if (store[number]) return store[number];
		return store[number] = number === 0 ? {
			issue: {
				number: 0,
				title: "No issue"
			},
			commits: []
		} : {
			issue: _getIssue(_, number),
			commits: []
		};
	}
	// issues
	var issues = {};
	// fetch tags
	var tags = _getFromGithub(_, "tags").body;
	//tracer && tracer("tags:\n" + sys.inspect(tags));
	//
	tags = tags.filter(function(t) {
		return (!options.tag_filter || t.name.match(options.tag_filter)) && (!options.max_tag || t.name <= options.max_tag);
	});
	// start tags
	if (options.from_sha) {
		tags.push({
			name: options.from_sha,
			commit: {
				sha: options.from_sha
			}
		});
	}
	tags = tags.map_(_, function(_, t) {
		var commit = t.commit && t.commit.sha && _getFromGithub(_, "commits/" + t.commit.sha).body;
		// tracer && tracer("\ntag commit:\n" + sys.inspect(commit.commit));
		return {
			name: t.name,
			commit_sha: t.commit && t.commit.sha,
			date: commit && commit.commit && commit.commit.author.date,
			issues: []
		};
	}).sort(function(a, b) {
		// sort descending
		// return a.name > b.name ? -1 : 1;
		return a.date > b.date ? -1 : 1;
	});

	// manage tags_milit
	var ntag = 0;
	if (options.from_sha) {
		// tags_limit from from_sha
		for (var ntag = 0; ntag < tags.length; ntag++) {
			if (tags[ntag].commit_sha == options.from_sha) {
				// found
				break;
			}
		}
	}

	// slice max ntags from older selected commit
	tags.slice(ntag, ntag + tags_limit);


	tracer && tracer("\ntags:\n" + sys.inspect(tags));

	// now list commits
	// find tags for breaks

	var pageRead = 0;
	var indexTag = 0;
	var pageUrl = "commits?sha=" + tags[indexTag].commit_sha + "&per_page=100&since=" + tags[tags.length - 1].date;
	var locIssues = {};
	tracer && tracer("\ncurrent tag : " + tags[indexTag].name);

	while (1) {
		try {
			tracer && tracer("\npage " + pageRead + " : " + pageUrl);
			var pageCurrent = _getFromGithub(_, pageUrl);
			pageRead += 1;

		} catch (e) {
			console.error(e.message);
			// no more page ?
			break;
		}

		var commits = pageCurrent.body;

		commits.some_(_, function(_, c) {

			// is this commit a tag ?
			for (var ntag = 1; ntag < tags.length; ntag++) {
				if (tags[ntag].commit_sha == c.sha) {
					// found a tag

					//close current tag and assign issues
					tags[indexTag].issues = Object.keys(locIssues).map(function(k) {
						return locIssues[k];
					});

					// reset issues for the tag
					locIssues = {};
					// assign current tag
					indexTag = ntag;

					tracer && tracer("\ncurrent tag : " + tags[indexTag].name);

				}
			}

			// do not log merges
			if (c.parents && (c.parents.length >= 2)) return false;
			//
			var r = {
				sha: c.sha
			};
			if (c.committer) r.login = c.committer.login;
			if (c.commit && c.commit.committer) {
				r.committerName = c.commit.committer.name;
				r.date = c.commit.committer.date;
				r.message = c.commit.message;
			}
			//tracer && tracer("Commit: " + c.sha + "; Date: " + r.date + +"author: " + c.commit.author.name + " Message: " + r.message);
			// issue
			var issue_nb = /.*#(\d+).*/.exec(r.message);
			issue_nb = issue_nb && issue_nb[1];
			var locIssue = _getLocalIssue(_, locIssues, issue_nb);
			//
			locIssue.commits.push(r);
			//
			return false;
		});

		// next url = next commits
		var headers = pageCurrent.headers;
		if (headers.link) {

			//tracer && tracer("\nlinks :\n" + sys.inspect(headers.link));

			if (headers.link.indexOf((">; rel=\"next\"")) != -1) {
				pageUrl = headers.link.split(">; rel=\"next\"", 1)[0].substring(1);
			} else {
				// no more next
				break;
			}

		} else {
			// no links in the header !
			// uhgh ???
			break;
		}
	}

	//close last tag and assign issues
	tags[indexTag].issues = Object.keys(locIssues).map(function(k) {
		return locIssues[k];
	});
	//
	//tracer && tracer("\ntags:\n" + sys.inspect(tags,null,6));

	tags.forEach(function(tag) {
		var nbCommits = 0;
		tag.issues.forEach(function(issue) {
			issue.commits.forEach(function(commit) {
				nbCommits += 1;
			});
		});
		tracer && tracer("\n tag : " + tag.name + " issues : " + tag.issues.length + " commits : " + nbCommits);
	});

	return tags;
}

function _makeChangelog(_, opt) {
	var options = JSON.parse(fs.readFile(fsp.join(__dirname, "../../../changelog/changelogSettings.json"), "utf8", _));
	options.max_tag = opt && opt.max_tag;
	options.from_sha = opt && opt.from_sha;
	var log = _buildChangeLog(_, options);
	fs.writeFile(fsp.join(__dirname, "../../changelog." + options.format), _formatters[(options.format || "txt")](log), "utf8", _);
};

exports.makeChangelog = function(cb, opt) {
	return _makeChangelog(_ >> cb, opt);
};