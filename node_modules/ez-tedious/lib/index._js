"use strict";

var generic = require('ez-streams').devices.generic;
var dru = require('etna-util/lib/drivers-util');
var tds = require('tedious');


function tds_query(cnx, sql, args, cb) {
	var req = new tds.Request(sql, cb);
	dru.tdsAddParameters(req, args);
	cnx.execSql(req);
	return req;
};

/// !doc
/// ## ez-streams wrapper for _tedious_ driver (SQL server)
/// 
/// `var eztedious = require('ez-tedious');`
/// 
module.exports = {
	/// * `reader = eztedious.reader(_, connection, sql, args)`   
	reader: function(_, connection, sql, args) {
		var received = [],
			error, callback, done;

		var trace;
		var tablename;
		/*
		trace = function(str) {
			try {
				if (!tablename)
				{
					var result =/ (from|FROM) \[?(\w+)\]?\.\[?(\w+)\]?/.exec(sql); 
					tablename = result[2] + '.' + result[3];
				}
			} catch (err) {
				console.log("Could not retrieve tablename from " + sql);
			}
			console.log(tablename + " : " + str);
		}
*/
		var low = 0,
			high = 2;

		// handle the pause/resume dance
		var paused = false;


		function push(record) {
			received.push(record);
			if (received.length === high) {
				connection.socket.pause();
				paused = true;
			}

		}

		function shift() {
			if (received.length === low + 1) {
				paused = false;
				connection.socket.resume();
			}
			return received.shift();
		}

		function send(err, result) {
			trace && trace('IIIIIIIIIIIIIIII send ' + ' (' + (err ? err.message : "undefined") + "," + (result ? "result" : "undefined") + ")");
			var cb = callback;
			callback = null;
			if (cb) {
				// A pending callback is available, we have to invoke it
				// This happens when the first read is done before the first row is collected.
				cb(err, result);
			} else {
				error = error || err;
				if (result) {
					// Enqueue the row, il will be dequeued by the generic.reader
					push(result);
				} else
					done = true;
			}
		}

		function sendResult(result) {
			result = dru.tdsColumnsToRow(result);
			return send(null, result);
		}

		var reader = generic.reader(_(function(cb) {
			if (error) {
				return cb(error);
			}
			if (received.length) {
				// Dequeue the first available row.
				return cb(null, shift());
			}
			if (done) {
				// Notify the caller that we have nothing more to read. The caller will receive 'undefined'.				
				return cb();
			}

			// The request is not completed yet, we have to store the callback, it will
			// be invoked later, when a result will be available (see send() method)
			callback = cb;
		}, 0));

		reader.context = {};
		trace && trace('>>>>>>>>>>>>>>> ' + sql);

		var request = tds_query(connection, sql, args, function(err, rowCount, rows) {
			if (callback && err)
				trace && trace('***************************');
			else
				trace && trace('--------------------------- ');
			send(err);
		});

		request.on('row', sendResult);

		request.on('column', function(fields) {
			reader.context.fields = fields;
		});
		return reader;
	},


	/// * `writer = eztedious.writer(connection, sql, columnDefs)`
	/// connection : a sql connection (created by require('tedious').Connection(...))
	/// sql : the sql statement (sth like INSERT INTO)
	/// columnDefs : a structure that describes the metadata of each parameter
	///   should look like { "@p0" : xxx, "@p1" : yyy, ...} where xxx and yyy are objects created 
	/// by sqlserver.readTableSchema(...)
	writer: function(connection, sql, columnDefs) {
		if (!connection)
			throw new Error("connection is missing")
		if (!sql)
			throw new Error("sql query is missing")
		if (!columnDefs)
			throw new Error("column definitions are missing")
		var done = false;
		var callback;
		var trace;
		var tablename;
		var isPreparing = true;
		var pendingParamValues;
		var shouldUnprepare = false;

/*		
		trace = function(str) {
			try {
				if (!tablename) {
					var result = / (into|INTO) \[?(\w+)\]?\.\[?(\w+)\]?/.exec(sql);
					tablename = result[2] + '.' + result[3];
				}
			} catch (err) {
				console.log("Could not retrieve tablename from " + sql);
			}
			console.log(tablename + " : " + str);
		}
*/

		trace && trace("writer initialized : " + sql);

		function processError(err) {
			trace && trace('ERROR : ' + JSON.stringify(err));
			connection.removeListener('errorMessage', processError);
			return send(err);
		}

		function send(err) {
			if (callback) {
				trace && trace('send(' + (err ? err.message : "undefined") + ")");
				callback(err);
			}
			callback = null;
		}

		var request = new tds.Request(sql, function(err, rowCount, rows) {
			// Note : this callback is invoked :
			// - when the request is executed
			// - when the request is unprepared
			if (trace) {
				if (err)
					trace("request's callback invoked with error " + err);
				else
					trace("request's callback invoked with success, row count = " + rowCount);
			}
			if (isPreparing) {
				trace && trace("prepared confirmed");
				// here, the send() method must not be invoked. It will be invoked when the first execute
				// is over (so, on the next call of this callback)
				return;
			}
			if (done)
				trace && trace("last call : unlock the caller");
			send(err);
		});

		// Now, we can prepare the request
		trace && trace("preparing the request");
		Object.keys(columnDefs).forEach(function(paramName)
		{
			var columnDef = columnDefs[paramName];
			if (paramName[0] = '@')
				paramName = paramName.substring(1);
			switch(columnDef.type)
			{
				case "tinyint":
					request.addParameter(paramName, tds.TYPES.TinyInt);
					break;
				case "smallint":
					request.addParameter(paramName, tds.TYPES.SmallInt);
					break;
				case "int":
					request.addParameter(paramName, tds.TYPES.Int);
					break;
				case "datetime":
					request.addParameter(paramName, tds.TYPES.DateTime);
					break;
				case "decimal":
					request.addParameter(paramName, tds.TYPES.Numeric);
					break;
				case "blob":
					request.addParameter(paramName, tds.TYPES.VarBinary);
					break;
				case "varchar":
					request.addParameter(paramName, tds.TYPES.VarChar);
					break;
				case "uuid":
				case "binary":
					request.addParameter(paramName, tds.TYPES.Binary);
					break;
				case "clob":
					request.addParameter(paramName, tds.TYPES.NVarChar);
					break;
				case "nvarchar":
					request.addParameter(paramName, tds.TYPES.NVarChar);
					break;
				default:
					throw new Error('unknown column type ' + columnDef.type + ' for parameter ' + paramName + ' in query ' + sql);
			}
		});

		request.on('prepared', function() {
			trace && trace("request prepared");
			isPreparing = false;
			if (shouldUnprepare)
			{
				// The writer was closed without having written any row.
				// The write(null) was issued when the request was preparing, the request could not
				// be unprepared because the connection had an invalid state (SentClientRequest). We have 
				// to unprepare it now (once the request is unprepared, the request's callback will be invoked)
				trace && trace("unpreparing the request");
				connection.unprepare(request);
				shouldUnprepare = false;
				return;
			}
			if (pendingParamValues) {
				trace && trace("dequeing values " + JSON.stringify(pendingParamValues));
				connection.execute(request, pendingParamValues);
			}
		});

		// connection.prepare is asynchronous. The connection will have an invalid state until the 'prepared'
		// event is received. Before this event is received, we MUST NOT launch any connection.execute(...)
		connection.prepare(request);

		// Note : the 'error' event is only available on the connection
		// As connections are pooled, we will have to unregister this event before leaving ...
		connection.on('errorMessage', processError);

		//var requestPrepared = false;
		return generic.writer(_(function(cb, obj) {
			if (done)
				return;
			callback = cb;
			if ((obj === undefined) && !done) {
				// End of writing operation.
				done = true; // from now, we must not write anything more
				if (isPreparing)
				{
					// This case occurs when the writer has been created and closed without having written any row
					// The request is being prepared (the 'prepare' event was not fired yet).
					// The request will be unprepared as soon as the 'prepared' event is received					
					shouldUnprepare = true;
					trace && trace("should unprepare");
				}
				else
				{
					trace && trace("unpreparing the request");
					connection.unprepare(request);
				}
				connection.removeListener('errorMessage', processError);
				// Note : we must not invoke the send() method here because the connection has an invalid state
				// it's processing the unprepare. When the unprepare will be over, the callback bound to the request
				// will be invoked and then the send() method will be invoked.
				return;
			}
			try {
				var vals = Array.isArray(obj) ? obj : Object.keys(obj).map(function(k, i) {
					return obj[k];
				});

				var paramValues = {};
				vals.forEach(function(value, index){
					paramValues["p" + index] = value;
				});

				if (isPreparing) {
					// We can't execute the request now, the connection is not in a valid state
					// We have to enqueue the values. The request will be executed as soon as
					// the request will be prepared (see request.on('prepared') for more details)
					trace && trace("waiting for request's prepare : enqueing values " + JSON.stringify(paramValues));
					pendingParamValues = paramValues;
				} else {
					trace && trace("execute values " + JSON.stringify(paramValues));
					connection.execute(request, paramValues);
				}
			} catch (err) {
				trace && trace("ERROR : " + err);
				if (callback) {
					// Do not invoke callback twice
					callback(err);
					callback = null;
				}
			}
		}, 0));
	},
};
