"use strict";

var generic = require('ez-streams').devices.generic;
var dru = require('etna-util/lib/drivers-util');
var tds = require('tedious');


function tds_query(cnx, sql, args, cb) {
	var req = new tds.Request(sql, cb);
	dru.tdsAddParameters(req, args);
	cnx.execSql(req);
	return req;
};

/// !doc
/// ## ez-streams wrapper for _tedious_ driver (SQL server)
/// 
/// `var eztedious = require('ez-tedious');`
/// 
module.exports = {
	/// * `reader = eztedious.reader(_, connection, sql, args)`   
	reader: function(_, connection, sql, args) {
		var received = [],
			error, callback, done;

		var trace;
		var tablename;
/*
		trace = function(str)
		{
			if (!tablename)
				tablename = / from (\w+)/.exec(sql)[1];;
			console.log(tablename + " : " + str);
		}
*/
		/* The current tedious implementation does not support pause/resume
		var low = 0,
			high = 2;

		// handle the pause/resume dance
		var paused = false;
*/

		function push(record) {
			received.push(record);
			/* The current tedious implementation does not support pause/resume
			if (received.length === high) {
				connection.pause();
				paused = true;
			}
			*/
		}

		function shift() {
			/* The current tedious implementation does not support pause/resume
			if (received.length === low + 1) {
				paused = false;
				connection.resume();
			}
			*/
			return received.shift();
		}

/* 		The current tedious implementation does not support pause/resume

		// override release because we need to destroy if connection is released before the end of the reader
		// would be nice to have an API to abort the query without destroying the connection
		var release = connection.release;
		connection.release = function() {
			console.log("******************* DESTROY");
			if (paused) this.destroy();
			else release.call(this);
		}
*/

		function send(err, result) {
			trace && trace('IIIIIIIIIIIIIIII send ' + ' (' + (err ? err.message : "undefined") + "," + (result ? "result" : "undefined") + ")");
			var cb = callback;
			callback = null;
			if (cb) {
				// A pending callback is available, we have to invoke it
				// This happens when the first read is done before the first row is collected.
				cb(err, result);
			} else {
				error = error || err;
				if (result) {
					// Enqueue the row, il will be dequeued by the generic.reader
					push(result);
				} else
					done = true;
			}
		}

		function sendResult(result) {
			result = dru.tdsColumnsToRow(result);
			return send(null, result);
		}

		var reader = generic.reader(_(function(cb) {
			if (error) {
				return cb(error);
			}
			if (received.length) {
				// Dequeue the first available row.
				return cb(null, shift());
			}
			if (done) {
				// Notify the caller that we have nothing more to read. The caller will receive 'undefined'.				
				return cb();
			}

			// The request is not completed yet, we have to store the callback, it will
			// be invoked later, when a result will be available (see send() method)
			callback = cb;
		}, 0));

		reader.context = {};
		trace && trace('>>>>>>>>>>>>>>> ' + sql);

		var request = tds_query(connection, sql, args, function(err, rowCount, rows) {
			if (callback && err)
				trace && trace('***************************');
			else
				trace && trace('--------------------------- ');
			send(err);
		});

		request.on('row', sendResult);

		request.on('column', function(fields) {
			reader.context.fields = fields;
		});
		return reader;
	},


	/// * `writer = eztedious.writer(connection, sql)`  
	writer: function(connection, sql) {
		var done = false;
		var initDone = false;
		var callback;

		var trace;
		var tablename;
/*		
		trace = function(str) {
			if (!tablename)
				tablename = / into (\w+)/.exec(sql)[1];
			console.log(tablename + " : " + str);
		}
*/

		trace && trace("XXXXXXXXX");

		function processError(err) {
			trace && trace('TTTTTTTTTTTTTTTTTTTT');
			connection.removeListener('errorMessage', processError);
			return send(err);
		}

		function send(err) {
			if (callback) {
				trace && trace('------ send ' + ' (' + (err ? err.message : "undefined") + ")");
				callback(err);
			}
			callback = null;
		}

		var request = new tds.Request(sql, function(err, rowCount, rows) {
			trace && trace("========================================== " + err + " / " + rowCount + " / " + rows);
			if (err)
				send(err);
		});

		var Blbfile = require('etna-engine/lib/runtime/tblbfile').Blbfile;

		return generic.writer(_(function(cb, obj) {
			if ((obj === undefined) || done) {
				// End of writing operation.
				done = true; // from now, we must not write anything more
						//connection.unprepare(request);
						connection.removeListener('errorMessage', processError);
				return;
			}
			callback = cb;
			try {
				if (obj === undefined || done) {
					//send();
					if (!done) {
						trace && trace(">>>>>>>>>>>>>>");
					}
					done = true;
					// if (callback) {
					// 	// Do not invoke callback twice
					// 	callback();
					// 	callback = null;
					// }
					return;
				}
				var vals = Array.isArray(obj) ? obj : Object.keys(obj).map(function(k, i) {
					return obj[k];
				});

				if (!initDone) {
					// First row : we have to prepare the request
					// The request is only prepared once and then executed for each row
					for (var i = 0; vals && i < vals.length; i++) {
						if (vals[i] instanceof Buffer)
							request.addParameter("p" + i, tds.TYPES.Binary);
						else if (vals[i] instanceof Blbfile)
							request.addParameter("p" + i, tds.TYPES.Varbinary);
						else if (vals[i] instanceof Date)
							request.addParameter("p" + i, tds.TYPES.DateTime);
						else if ((typeof vals[i]) === "number")
							request.addParameter("p" + i, tds.TYPES.Int);
						else
							request.addParameter("p" + i, tds.TYPES.NVarChar);
					}
					connection.prepare(request);
					request.on('doneProc', function(rowCount, more, rows) {
						// We use this event to known when the previous execute has been done
						// We MUST NOT invoke cnx.execute(req) before the previous execution is over
						// cnx.execute(req) returns when the request is launched, not when its done.
						trace && trace('BBBBBBBBBBBBBBB ' + done);
						send();
						// if (callback) {
						// 	// Do not invoke callback twice
						// 	callback();
						// 	callback = null;
						// }
					});
					// Note : the 'error' event is only available on the connection
					// As connections are pooled, we will have to unregister this event before leaving ...
					connection.on('errorMessage', processError);
					/*
					request.on('error', function(err) {
						send(err);
						// if (callback) {
						// 	// Do not invoke callback twice
						// 	callback(err);
						// 	callback = null;
						// }
					});
		*/
					initDone = true;
				}

				var params = {};
				for (var i = 0; vals && i < vals.length; i++) {
					if (vals[i] instanceof Blbfile)
						params["p" + i] = vals[i].value;
					else
						params["p" + i] = vals[i];
				}
				trace && trace("EEEEEEEEEEEEEE " + JSON.stringify(params));
				connection.execute(request, params);
			} catch (err) {
				trace && trace("+++++++++++++++++++++++++++++++++++++++");
				if (callback) {
					// Do not invoke callback twice
					callback(err);
					callback = null;
				}
			}
		}, 0));
	},
};
