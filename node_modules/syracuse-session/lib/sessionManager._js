"use strict";

var events = require('events');
var url = require('url');
var config = require("syracuse-main/lib/nodeconfig").config;
var sessionMod = require('./session');
var Session = sessionMod.Session;
var helpers = require('syracuse-core/lib/helpers');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var os = require("os");
var fusionPool = require("syracuse-x3/lib/fusionPool");
var globals = require('streamline/lib/globals');
var check = require('syracuse-license/lib/check');
var locale = require("syracuse-core/lib/locale");
var sys = require("util");

var tracer = console.log; // null;

var _sessions = {};

/**
 * Session Manager Object
 * Settings:
 *	- key 				The Cookie key to store sessionId in
 * 	- timeout              	Number of minutes that a session can remain idle
 * 	- checkInterval		The interval (in seconds) between checks for expired sessions
 */
/***
 ** sessionManager.sessionManagement(_, request, response, options)
 * options:
 * ** authRequired = true--> the user must be logged to execute service
 * ** forceAuth = true --> when user isn't logged and authRequired=true  try to logon
 *                       = false --> when user isn't logged and authRequired=true  the request is refused (for OAuth2, result must be false)
 * ** forceAuth2 = true  for OAuth2, authentication is done on an external server, and the above forceAuth just invokes the
 *                       external server. After invoking Syracuse again using the redirect url, there is one more attempt
 *                       to authenticate - now using the authenticate2 method.
 */
exports.sessionManager = new

function() {
	events.EventEmitter.call(this);
	var _timer = null;
	// number of active sespsions
	var _count = 0;
	// Active sessions
	var _settings;
	var _getAuthModule;

	this.setup = function(settings, getAuthModule) {
		tracer = settings.tracer;
		//
		_settings = helpers.object.clone(settings || {});
		_getAuthModule = getAuthModule;
		_settings.key = _settings.key || "syracuse.sid";
		_settings.timeout = _settings.timeout || 20;
		_settings.checkInterval = _settings.checkInterval || 5 * 60;
		// Start expiration timer for sessions
		if (!_settings.disabled) _timer = setInterval(_checkExpired, _settings.checkInterval * 1000);
		//
		sessionMod.setup(settings);
	};

	function _checkExpired() {
		var expired = +new Date - _settings.timeout * 60 * 1000;
		tracer && tracer("sessionManager.session check expired, lastAccess < "+expired);
		for (var key in _sessions) {
			var session = _sessions[key];
			if (session && (session.lastAccess < expired)) {
				tracer && tracer("sessionManager.session "+key+" expired");
				_deleteSession(null, key);
			}
		}
	}
	
	function _deleteSession(_, key) {
		var session = _sessions[key];
		if(session) {
			tracer && tracer("sessionManager.deleteSession found: "+key);
			delete _sessions[key];
			_count--;
			session.destroy(_);
		} else
			tracer && tracer("sessionManager.deleteSession not found: "+key);
	}
	this.deleteSession = function(_, sid) {
		_deleteSession(_, sid);
	}
	this.destroy = function(_) {
		for (var key in _sessions) {
			_deleteSession(_, key);
		}
	};

	this.getSettings = function(_) {
		return helpers.object.clone(_settings);
	}
	
	function _allocSID() {
		return helpers.uuid.generate();
	}

	this.sessionById = function(key) {
		return _sessions[key];
	}
	this.sessionByCookie = function(cookie) {
		var cookies = helpers.http.parseCookie(cookie);
		var key = cookies[_settings.key];
		if (key) return _sessions[key];
		return null;
	}

	function _getSession(_, request, response) {
		var clientCookie = request.headers.cookie;
		var cookies = helpers.http.parseCookie(clientCookie);
		var cookie = cookies[_settings.key] || "";
		var createSesion = true;
		if (cookie) {
			var session = _sessions[cookie];
			if (session) {
				createSesion = false;
				session.touch();
				request.session = session;
			} else {
				tracer && tracer("Session (" + cookie + ") expired.");
				// force new authorization, needed for logout
				request.headers.authorization = "";
			}
		}
		if (createSesion) {
			_internalCreateSession(_, request, response);
		}
		//
		if(globals.context) {
			globals.context.session = request.session;
			globals.context.request = request;
		}
	}

	function _internalCreateSession(_, request, response) {
		// create session object
		var clientCookie = request.headers.cookie;
		var clientId = null;
		if (clientCookie) {
			var r = /client\.id=([\w-]+)/.exec(clientCookie);
			if (r) clientId = r[1];
		}
		var session = new Session(request, _allocSID(), clientId);
		session.ignoreStoreSession = _settings.ignoreStoreSession;
		session.host = (('authorized' in request.connection) ? "https" : "http") + "://" + request.headers.host;
		session.cookie = _settings.key + "=" + session.id;
		request.session = session;

		clientCookie = (clientCookie ? (clientCookie + "; ") : "") + _settings.key + "=" + session.id;
		// set cookie in request
		request.headers.cookie = clientCookie;
		_sessions[request.session.id] = session;
		_count++;
		tracer && tracer("Create syracuse session for " + request.url + " (sessionId=" + session.id + ").");
		// session.authModule = _authModule;
		// store session in DB
		tracer && tracer("Store syracuse session for " + request.url + " (sessionId=" + session.id + ").");
		session.touch();
//		session.updateSessionInfo(_);
	}

	function _setSessionCookie(request, response, _, options) {
		if (!response) return true;

		var writeHead = response.writeHead;
		response.writeHead = function(statusCode, headers) {
			if (request.session) {
				request.session.touch();
				// Send the cookie to the browser
				headers = headers || {};
				var cookie = headers["set-cookie"];
				
				var expired = new Date(+new Date + _settings.timeout * 60 * 1000);
				var syraCookie = _settings.key + "=" + request.session.id + '; path=/; expires=';
				if (!cookie || cookie.indexOf(syraCookie) < 0) {
					cookie = (cookie ? (cookie + "\r\nset-cookie: ") : "") + syraCookie + expired.toGMTString();
				}
				// client ID
				if (cookie.indexOf("client.id=") < 0) {
					var clientExpire = new Date(+new Date + 200* 86400 * 1000); // 200 days
					cookie += "\r\nset-cookie: client.id="+request.session.clientId+"; path=/; expires="+clientExpire.toGMTString();
				}
				headers['set-cookie'] = cookie;
				// locales
				if(!headers["content-language"])
					headers["content-language"] = locale.current;
				//
				delete headers['Last-Modified'];
				delete headers['Cache-Control'];
				delete headers['ETag'];
			}
			response.writeHead = writeHead;
			return response.writeHead(statusCode, headers);
		};
		var session = request.session;
		if (options.authRequired && session) {
			if (!session.isAuthenticated()) {
				var authModule = _getAuthModule(request, options.forceAuth2, _);
				if (options.forceAuth) {
					return authModule.authenticate(request, response, _);
				} else if (options.forceAuth2 && authModule.authenticate2) {
					return authModule.authenticate2(request, response, _);
				} else return authModule.forbidden(request, response);
			}
		}
		return true;
	}

	/*
	 * options:
	 * ** authRequired = true--> the user must be logged to execute service
	 * ** forceAuth = true --> when user isn't logged and authRequired=true  try to logon
	 *                       = false --> when user isn't logged and authRequired=true  the request is refused
	 */
	this.sessionManagement = function(_, request, response, options) {
		if (_settings.disabled || !options) return true;
		if (_count === 0 && !("mockServer" in config)) { // in cluster it is not necessary to check license again when there are no sessions
			                                           // because all running Syracuse processes will be notified even when they do not have sessions
			check.updateFromDB(_);
		}
		_getSession(_, request, response);
		//
		var cookieResult = _setSessionCookie(request, response, _, options);
		// set locales (needs _setSessionCookie be executed first)
		request.session && request.session.setLocales(_, locale.extractLocaleCode(request.headers["accept-language"]));
		//
		return cookieResult;
	}
	//
	this.logout = function(_, request, response) {
		tracer && tracer("sessionManager.Logout enter");
		var cookie = (helpers.http.parseCookie(request.headers.cookie) || {})[_settings.key];
		if(cookie) {
			tracer && tracer("sessionManager.logout deleting session: "+cookie);
			_deleteSession(_, cookie);
		} 
	}
	//
	this.cleanupSessionInfos = function(_) {
		var db = adminHelper.getCollaborationOrm(_);
		var sessionInfos = db.fetchInstances(_, db.model.getEntity("sessionInfo"), {
			jsonWhere: {
				serverName: config.servername
			}
		});
		tracer && tracer("session.close server name: "+config.servername);
		sessionInfos.forEach_(_, function(_, sessionInfo) {
			tracer && tracer("session.close close session: "+sessionInfo.sid(_));
			// delete all locks for this session
			adminHelper.releaseSessionLocks(_, sessionInfo.sid(_));
			// close all fusion sessions
			try {
				sessionInfo.fusionSessions(_).toArray(_).forEach_(_, function(_, fusionSession) {
					tracer && tracer("session.close fusion session: "+fusionSession.sid(_));
					fusionPool.closeSession(_, fusionSession.sid(_), fusionSession.sessionUrl(_), fusionSession.isXmlSessionFormat(_));
				});
			} catch(e) {
				// fusionSession release shouldn't be blocking 
				tracer && tracer("session.close fusion session error: "+e.message);
			}
			//
			tracer && tracer("DELETESELF"+config.servername);
			sessionInfo.deleteSelf(_);
		});
	}
}