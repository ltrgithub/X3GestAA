"use strict";

var events = require('events');
var config = require("syracuse-main/lib/nodeconfig").config;
var sessionMod = require('./session');
var Session = sessionMod.Session;
var helpers = require('syracuse-core/lib/helpers');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var os = require("os");
var globals = require('streamline/lib/globals');
var check = require('syracuse-license/lib/check');
var locale = require("syracuse-core/lib/locale");
var sys = require("util");
var url = require('url');
var adminHelpers = require('syracuse-collaboration/lib/helpers');
var crypto = require('crypto');

var tracer; // = console.log;

var _sessions = {};
var _tempSessions = {};

// get device of current session

function getDevice() {
	// dummy implementation!
	return "desktop";
}

exports.getDevice = getDevice;

function _certUserCheck(session, login, standardSetting, _) {
	var user = null;
	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
	// fetch user
	user = db.fetchInstance(_, db.model.getEntity(_, "user"), {
		jsonWhere: {
			login: login,
			active: true
		}
	});
	if (user) {
		// License check
		var p;
		if (p = user.preferences(_)) {

			// find out badges for current user
			var role = p.lastRole(_);
			var diagnoses = [];
			// console.error("ppppppppppppppppppppppppppppppppppppppppppDIAGD " + require('util').format(session.getUserprofile(_)));
			if (role && !check.checkConcurrent(session, role, user.login(_), _, getDevice(), diagnoses)) {
				return 2;
			}
			// console.error("DIAGDIAG2 " + require('util').format(diagnoses));
			// console.error("DIAGD " + require('util').format(session.getUserprofile(_)));

			// force user locales: hack request accept-language header
			var l = p.lastLocaleCode(_);
			// check if locale exists
			if (globals.context && globals.context.request && l && user.getUserLocaleByCode(_, l)) globals.context.request.headers["accept-language"] = l;
		}
		session.setData("userID", user.$uuid);
		session.setData("userLogin", user.login(_));
		return 0;
	} else return 1;
}

var userRedirect = {};

function _clearRedir(request) {
	// console.log("CLR")
	if (request) {
		var cookie = request.headers.cookie;
		if (cookie) {
			var r = /\bclient\.id=([\w\-]+)/.exec(cookie);
			if (r) {
				var id = r[1];
				// console.log("IDl "+id+ " "+require('util').format(userRedirect));
				for (var login in userRedirect) {
					if (login.indexOf(id) === 0) delete userRedirect[login];
				}
			}
		}
	}
}
exports.clearRedir = _clearRedir;

//avoid redirect when same user wants to log in again (within 100 seconds)
// redirect will stay for at least 1.5 seconds, because sometimes it is not recognized by the client
// therefore double login will be avoided.
// this does not apply to OAuth2, because OAuth2 does not check authentication locally
function _redir(login, status, userAuthentication, request) {
	if (userAuthentication === "oauth2") return status;
	var now = Date.now();
	var compare = now - 100000; // 100 seconds
	for (var login1 in userRedirect) {
		if (userRedirect[login1] < compare) delete userRedirect[login1];
	}
	var id = "";
	if (request) {
		var cookie = request.headers.cookie;
		if (cookie) {
			var r = /\bclient\.id=([\w\-]+)/.exec(cookie);
			if (r) id = r[1];
			// console.log("ID "+id);
		}
	}
	login = id + "$" + login;
	var val = userRedirect[login];
	if (val && (now - val > 1500 || val > now)) {
		// console.log("del "+login)
		delete userRedirect[login];
		return 1;
	} else {
		// console.log("add "+login)
		if (!val) userRedirect[login] = now;
		return status;
	}
}


/** check user (and password) for different authentication methods. User name must be in user table
 * parameters:
 * session: current session (which will receive data of current user in case of success
 * login: login user name
 * password: password of user (from basic authentication)
 * passwordCheck: function which checks password (for digest authentication). It takes one parameter (the password from MongoDB) and returns
 *                true when the password is correct
 * method: authentication method (basic, digest, oauth2...)
 * standardSetting: standard setting singleton
 * Return codes: 0 OK, 1 authentication failure, 2 no license, 3 change password, 4 user inactive, 5 no group, 6 no role, 7 wrong OAuth2 server
 */

function _userCheck(session, login, password, passwordCheck, method, standardSetting, _, request) {
	var user = null;
	var realm = config.session.realm;
	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
	// fetch user
	var whereClause = "(login eq \"" + login + "\")";
	var users = db.fetchInstances(_, db.model.getEntity(_, "user"), {
		sdataWhere: whereClause
	});
	if (users && users.length) {
		user = users[0];
	}
	if (user) {
		var localConfig = {};
		var userAuthentication = user.authentication(_);
		if (!userAuthentication) {
			if (!standardSetting) standardSetting = adminHelpers.AdminHelper.getStandardSetting(_);
			// clone standardSetting
			var member;
			for (member in standardSetting) localConfig[member] = standardSetting[member];
		} else {
			switch (userAuthentication) {
				case "db":
					localConfig.method = config.session.auth;
					localConfig.source = "db";
					break;
				case "ldap":
					if (method === "digest") return "No HTTP digest authentication with LDAP";
					localConfig.method = "basic";
					localConfig.source = "ldap";
					localConfig.ldap = user.ldap(_)._data;
					break;
				case "oauth2":
					var localOAuth2 = user.oauth2(_)._data;
					localConfig.method = "oauth2-" + (localOAuth2.name || "");
					localConfig.oauth2 = localOAuth2;
					break;
				default:
					// !!! error handling
					console.log("Wrong authentication method " + userAuthentication);
					return locale.format(module, "wrongAuth", userAuthentication);
			}
		}
		if (!user.active(_)) // no login for inactive users!
			return _redir(login, 4, userAuthentication, request);

		// for OAuth2: when the chosen OAuth2 server does not match the OAuth2 server of the user, then login is not possible
		if (localConfig.method !== method && (localConfig.method.indexOf('oauth') >= 0 || method.indexOf('oauth') >= 0)) {
			console.log("Wrong OAuth2 server " + localConfig.method + " - " + method);
			return _redir(login, 7, userAuthentication, request);
		} else if (localConfig.source == "db") {
			if (passwordCheck) {
				if (!passwordCheck(user.password(_))) user = null;
			} else {
				// compute hash of password using user name from user entity
				// apply hash function from RFC2617
				var hash = crypto.createHash('MD5');
				var a1 = user.login(_) + ":" + config.session.realm + ":" + password;
				hash.update(a1, 'binary');
				if (hash.digest("hex") !== user.password(_)) user = null;
			}
		} else if (localConfig.source == "ldap") {
			var ldapName = user.authenticationName(_) || user.login(_);
			if (!localConfig.ldap.active) { // server inactive: no authentication
				console.log("LDAP server inactive");
				user = null;
			} else {
				var LdapAuth = require("syracuse-ldap").LdapAuth;
				localConfig.ldap.cache = false;
				var auth = new LdapAuth(localConfig.ldap);
				try {
					auth.authenticate(ldapName, password, ~_);
				} catch (e) {
					console.log("LDAP Authentication error: " + e.toString());
					user = null;
				} finally {
					auth.close(~_);
				}
			}
		} else { // OAuth2 authentication
			// nothing to do because it has already been checked whether OAuth2 is correct
		}
		var diagnoses = [];
		// License check
		if (user) {
			// check role
			var groups = user.groups(_).toArray(_);
			if (!groups.length) return _redir(login, 5, userAuthentication, request);
			var p = user.preferences(_);
			var role;
			if (p) {
				// force user locales: hack request accept-language header
				var l = p.lastLocaleCode(_);
				// check if locale exists
				if (globals.context && globals.context.request && l && user.getUserLocaleByCode(_, l)) globals.context.request.headers["accept-language"] = l;
				// take last role from user preferences
				role = p.lastRole(_);
			}
			var role2 = role;
			if (role) {
				// test whether role is in current groups
				for (var j = 0; j < groups.length; j++) {
					var group = groups[j];
					role = group.role(_);
					if (role && role.$uuid === role2.$uuid) break; // role found
					role = null;
				}
			}
			// no role from user preferences - take role from groups
			if (!role) {
				if (!groups.length) return 5;
				for (var j = 0; j < groups.length; j++) {
					var group = groups[j];
					role = group.role(_);
					if (role) break; // role found
				}
			}
			if (!role) {
				return _redir(login, 6, userAuthentication, request); // no role
			}
			if (role && !check.checkConcurrent(session, role, login, _, getDevice(), diagnoses, true)) { // try to find new session
				return 2;
			}

			// TODO: show diagnoses!!!!
		}
		if (user) {
			session.setData("userID", user.$uuid);
			session.setData("userLogin", login);
		}
	}
	if (user && user.changePassword(_)) {
		// redirect to other URL
		return 3;
	}
	return (user == null ? 1 : 0);
}


// obtain module for authentication from request url and standard configuration
function getAuthModule(request, redirect, _) {
	// TODO: for now, if secure connection, use of client certificates having CN mapping to a valid user name
	// later, have a possibility of generic client certificate and / or ability to change user
	// certificate auth >>>
	// console.log("GET AUTH "+request.url);
	if (request.connection.authorized) return require("streamline-auth/lib/certificate").create(_certUserCheck, standardSetting);
	// certificate auth <<<
	var result;
	var parsed = url.parse(request.url);
	var pathname;
	if (redirect) { // use original URL
		pathname = querystring.parse(parsed.query).state;
		request.syracuseOriginalPath = pathname;
	} else {
		pathname = parsed.pathname;
	}
	var regexResult; // search authentication information in request.url
	var authmethod;
	var authserver;
	var setting; // either standard setting or (partial) setting derived from path:
	// authentication header in URL path: /auth/basic or /auth/oauth2-<Name>
	regexResult = /^\/auth\/(std|basic|digest|oauth2-(\w*))(\-\-[0-9a-f]*)?/.exec(pathname);
	if (regexResult == null || regexResult[1] === "oauth2-" || regexResult[1] === "std") {
		var standardSetting = adminHelpers.AdminHelper.getStandardSetting(_);
		authmethod = standardSetting.method;
		if (regexResult && regexResult[1] === "oauth2-" && authmethod !== "oauth2-") {
			console.log("No OAuth2 server according to standard config file");
			throw new Error(locale.format(module, "noOauth2"));
		}
		authserver = standardSetting.oauth2;
	} else {
		authmethod = regexResult[1];
		if (authmethod && authmethod.indexOf("oauth2") === 0) {
			// get OAuth2 server from database
			var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
			var authserverInstance = db.fetchInstance(_, db.model.getEntity(_, "oauth2"), {
				sdataWhere: '(name eq "' + regexResult[2] + '")'
			});
			if (!authserverInstance) {
				console.log("No OAuth2 server with name " + regexResult[2]);
				throw new Error(locale.format(module, "noOauth2N", regexResult[2]));
			}
			if (!authserverInstance.active(_)) {
				console.log("inactive OAuth2 server with name " + regexResult[2]);
				throw new Error(locale.format(module, "oauth2Inact", regexResult[2]));
			}
			// !!! not OK. How can I copy all attributes?
			authserver = authserverInstance._data;
		}
	}
	if (regexResult && regexResult[1].indexOf("oauth2") < 0 && regexResult[3]) { // login with token
		var user = require("streamline-auth/lib/changePassword").getTempLogin(regexResult[3]);
		if (user) {
			return {
				authenticate: function(request, response, _) {
					request.session && request.session.afterAuthentication({
						user: user,
					});
					console.log("Authentication after change password");
					return true;
				}
			}; // no authentication necessary any more
		}
	}

	if (authmethod === "basic") {
		return require("streamline-auth/lib/basic").create(_userCheck, standardSetting);
	} else if (authmethod === "digest") {
		return require("streamline-auth/lib/digest").create(_userCheck, standardSetting);
	} else {
		return require("streamline-auth/lib/oauth2").create(_userCheck, authserver, standardSetting);
	}
};

/**
 * Session Manager Object
 * Settings:
 *	- key 				The Cookie key to store sessionId in
 * 	- timeout              	Number of minutes that a session can remain idle
 * 	- checkInterval		The interval (in seconds) between checks for expired sessions
 */
/***
 ** sessionManager.sessionManagement(_, request, response, options)
 * options:
 * ** authRequired = true--> the user must be logged to execute service
 * ** forceAuth = true --> when user isn't logged and authRequired=true  try to logon
 *                       = false --> when user isn't logged and authRequired=true  the request is refused (for OAuth2, result must be false)
 * ** forceAuth2 = true  for OAuth2, authentication is done on an external server, and the above forceAuth just invokes the
 *                       external server. After invoking Syracuse again using the redirect url, there is one more attempt
 *                       to authenticate - now using the authenticate2 method.
 */
exports.sessionManager = new function() {
	events.EventEmitter.call(this);
	var _timer = null;
	// number of active sessions
	var _count = 0;
	// Active sessions
	var _settings;

	this.setup = function(settings) {
		tracer = settings.tracer;
		//
		_settings = helpers.object.clone(settings || {});
		_settings.key = _settings.key || "syracuse.sid";
		_settings.timeout = _settings.timeout || 20;
		this.sessionTimeout = _settings.timeout;
		_settings.checkInterval = _settings.checkInterval || 5 * 60;
		// Start expiration timer for sessions
		if (!_settings.disabled)
			_timer = setInterval(_checkExpired, _settings.checkInterval * 1000);
		//
		sessionMod.setup(settings);
	};

	function _checkExpired() {
		// if memory limit is defined and no sessions anymore, stop server, it will be restarted by the load balancer or the agent
		var limit = config && config.system && config.system.memoryLimit;
		if (limit == null) limit = 500; // test with null as it might be 0 and in this case shouldn't be changed
		if (limit > 0 && Object.keys(_sessions).length === 0) {
			var hu = process.memoryUsage().heapUsed / 1024 / 1024;
			if (hu > limit) {
				console.error(locale.format(module, "memoryLimit", hu, limit));
				process.exit(0);
			}
		}
		//
		var expired = +new Date() - _settings.timeout * 60 * 1000;
		tracer && tracer("sessionManager.session check expired, lastAccess < " + expired);
		for (var key in _sessions) {
			var session = _sessions[key];
			if (session && (session.lastAccess < expired)) {
				tracer && tracer("sessionManager.session " + key + " expired");
				_deleteSession(!_, key);
			}
		}
	}

	function _deleteSession(_, key) {
		var session = _sessions[key];
		if (session) {
			tracer && tracer("sessionManager.deleteSession found: " + key);
			delete _sessions[key];
			_count--;
			session.destroy(_);
		} else {
			tracer && tracer("sessionManager.deleteSession not found: " + key + "; will delete sessionInfo");
			var db = adminHelper.getCollaborationOrm(_);
			var si = db.fetchInstance(_, db.getEntity(_, "sessionInfo"), {
				jsonWhere: {
					sid: key
				}
			});
			si && si.deleteSelf(_);
		}
	}
	this.formatSessionCookie = function(sid) {
		return _settings.key + "=" + sid + '; path=/; expires=';
	};
	this.deleteSession = function(_, sid) {
		_deleteSession(_, sid);
	};
	this.destroy = function(_) {
		for (var key in _sessions) {
			_deleteSession(_, key);
		}
	};

	this.getSettings = function(_) {
		return helpers.object.clone(_settings);
	};

	function _allocSID() {
		return helpers.uuid.generate();
	}

	this.sessionById = function(key) {
		return _sessions[key];
	};
	this.sessionByCookie = function(cookie) {
		var cookies = helpers.http.parseCookie(cookie);

		var key = cookies[_settings.key];
		if (key)
			return _sessions[key];
		return null;
	};

	function _getSession(_, request, response) {
		var clientCookie = request.headers.cookie;
		var cookies = helpers.http.parseCookie(clientCookie);
		var port = request.connection.localPort;
		var cookie = cookies[_settings.key + "." + port] || "";
		var createSesion = true;
		if (cookie) {
			var session = _sessions[cookie];
			// CHROME HACK: chrome doesn't replace cookie with new one on 401 response. So we need
			// to store the old session id in _tempSessions until the new one is authenticated
			if (!session && _tempSessions[cookie]) {
				session = _tempSessions[cookie];
				delete _tempSessions[cookie];
			}
			if (request.headers.authorization && session && session.authData && session.authData.authorization && (session.authData.authorization !== request.headers.authorization)) {
				if (session.authData.authorization.substr(0, 6) === "Digest") {
					// digest authentication looks different each time because of nonce. Ignore nonce.
					var auth1 = session.authData.authorization;
					var auth2 = request.headers.authorization;
					auth1 = auth1.replace(/\b(response|nc|cnonce)\="\w+"/g, "");
					auth2 = auth1.replace(/\b(response|nc|cnonce)\="\w+"/g, "");
					if (auth1 !== auth2) session = null;
				} else session = null;
			}
			if (session) {
				createSesion = false;
				session.touch();
				request.session = session;
			} else {
				tracer && tracer("Session (" + cookie + ") expired.");
				// force new authorization, needed for logout
				//				request.headers.authorization = "";
			}
		}
		if (createSesion) {
			if (config.shutDownMarker) {
				tracer && tracer("No new session during shutdown");
				request.headers.authorization = "";
				response.writeHead(503, {
					"Content-Type": "text/plain"
				});
				response.end(locale.format(module, "noNewSession"));
				return false;
			}
			_internalCreateSession(_, request, response, cookie);
			// if there was a session that doesn't exists anymore (expired or logged out),
			// create a non authenticated session and force browser to login
			if (cookie) {
				// CHROME HACK: chrome doesn't replace cookie with new one on 401 response. So we need
				// to store the old session id in _tempSessions until the new one is authenticated
				_tempSessions[cookie] = request.session;
				// make a timeout in case user abandon login
				setTimeout(function() {
					delete _tempSessions[cookie];
				}, 5 * 60 * 1000);
				// set cookie to the new session id
				_setSessionCookie(request, response, _, {
					authRequired: false
				});
				//
				tracer && tracer("sending 401 for session: " + cookie);
				var authModule = getAuthModule(request, false, _);
				_clearRedir(request);
				return (authModule && (!authModule.unAuthenticated || authModule.unAuthenticated(request, response, _))) || false;
			}
		}
		//
		if (globals.context) {
			globals.context.session = request.session;
			globals.context.request = request;
		}
		return true;
	}

	function _internalCreateSession(_, request, response, reuseSid) {
		// create session object
		var clientCookie = request.headers.cookie;
		var clientId = null;
		if (clientCookie) {
			var r = /client\.id=([\w-]+)/.exec(clientCookie);
			if (r)
				clientId = r[1];
		}
		// reuseSid: Chrome doesn't update the session cookie if a 401 response so this ends up in an failure for user
		// to connect, even with proper credentials. So create a new session with the same session id to prevent this issue.
		// It's OK on all other browsers tested
		// crnit UPDATE: cannot reuse the session Id because the client uses it to detect session change and asks
		// for a new user profile and reload of source code
		//		var session = new Session(request, reuseSid || _allocSID(), clientId);
		var session = new Session(request, _allocSID(), clientId);

		session.ignoreStoreSession = _settings.ignoreStoreSession;

		var secure = (request.hosting && request.hosting.https) || ('authorized' in request.connection);
		var port = request.connection.localPort;

		session.host = (secure ? "https" : "http") + "://" + request.headers.host;
		session.cookie = _settings.key + "." + port + "=" + session.id;
		request.session = session;

		clientCookie = (clientCookie ? (clientCookie + "; ") : "") + _settings.key + "." + port + "=" + session.id;
		// set cookie in request
		request.headers.cookie = clientCookie;
		_sessions[request.session.id] = session;
		_count++;
		tracer && tracer("Create syracuse session for " + request.url + " (sessionId=" + session.id + ").");
		// session.authModule = _authModule;
		// store session in DB
		tracer && tracer("Store syracuse session for " + request.url + " (sessionId=" + session.id + ").");
		session.touch();
	}

	function _setSessionCookie(request, response, _, options) {
		function _hasCookie(cookies, value) {
			return cookies.some(function(ck) {
				return ck.indexOf(value) >= 0;
			});
		}
		tracer && tracer("_setSessionCookie: has response: " + (response != null));
		if (!response)
			return true;

		var writeHead = response.writeHead;
		response.writeHead = function(statusCode, headers) {
			if (request.session) {
				request.session.touch();
				// Send the cookie to the browser
				headers = headers || {};
				var cookie = headers["set-cookie"];
				// multiple cookies
				cookie = cookie || [];
				if (!Array.isArray(cookie))
					cookie = [cookie];

				var expired = new Date(+new Date + _settings.timeout * 60 * 1000);
				var port = request.connection.localPort;

				var syraCookie = _settings.key + "." + port + "=" + request.session.id + '; path=/; expires=';
				if (!_hasCookie(cookie, syraCookie)) {
					cookie.push(syraCookie);
				}
				// client ID
				if (!_hasCookie(cookie, "client.id=")) {
					var clientExpire = new Date(+new Date + 200 * 86400 * 1000); // 200 days
					cookie.push("client.id=" + request.session.clientId + "; path=/; expires=" + clientExpire.toGMTString());
				}
				// user profile
				if (!_hasCookie(cookie, "user.profile.+" + port) && request.session.userProfileCookie) {
					var profileExpire = new Date(+new Date + 200 * 86400 * 1000); // 200 days
					cookie.push("user.profile." + port + "=" + request.session.userProfileCookie + "; path=/; expires=" + profileExpire.toGMTString());
				}
				headers['set-cookie'] = cookie;
				// locales
				if (!headers["content-language"])
					headers["content-language"] = locale.current;
			}
			response.writeHead = writeHead;
			return response.writeHead(statusCode, headers);
		};
		var session = request.session;
		if (options.authRequired && session) {
			tracer && tracer("Session is auth: " + session.isAuthenticated());
			if (!session.isAuthenticated()) {
				var authRes = false;
				var authModule = getAuthModule(request, options.forceAuth2, _);
				if (options.forceAuth) {
					authRes = authModule.authenticate(request, response, _);
				} else
				if (options.forceAuth2 && authModule.authenticate2) {
					authRes = authModule.authenticate2(request, response, _);
				} else
					authRes = authModule.forbidden(request, response);
				//
				if (authRes) {
					// TODO: this should be in session.afterAuthentication
					// force user profile loading
					session.getUserProfile(_);
				}
				//
				return authRes;
			}
		}
		return true;
	}

	/*
	 * options:
	 * ** authRequired = true--> the user must be logged to execute service
	 * ** forceAuth = true --> when user isn't logged and authRequired=true  try to logon
	 *                       = false --> when user isn't logged and authRequired=true  the request is refused
	 */
	this.sessionManagement = function(_, request, response, options) {
		tracer && tracer("Session manager options: " + sys.inspect(options));
		if (_settings.disabled || !options)
			return true;
		if (_count === 0 && !("mockServer" in config)) { // in cluster it is not necessary to check license again when there are no sessions
			// because all running Syracuse processes will be notified even when they do not have sessions
			check.updateFromDB(_);
		}
		if (!_getSession(_, request, response))
			return false;
		//
		var cookieResult = _setSessionCookie(request, response, _, options);
		// set locales (needs _setSessionCookie be executed first)
		// language url param has priority over accept-language header
		var params = helpers.url.parseQueryString(request.url.split("?")[1]);
		var lang = params && params.language;
		//
		request.session && request.session.setLocales(_, lang || locale.extractLocaleCode(request.headers["accept-language"]));
		//
		return cookieResult;
	};

	// SAM 98078 - in case of endpoint change we have to disconnect syracuse session
	this.disconnectX3Sessions = function(_, request, response) {
		var session = _getSession(_, request, response);
		if (session) {
			session.disconnectX3Sessions(_);
		}
	};

	//
	this.logout = function(_, request, response) {
		// DO NOT delete session cookie. It will allow us to detect a logged out session and force the browser to login again
		tracer && tracer("sessionManager.Logout enter");
		var pck = helpers.http.parseCookie(request.headers.cookie) || {};
		var port = request.connection.localPort;

		var cookie = pck[_settings.key + "." + port];
		if (cookie) {
			tracer && tracer("sessionManager.logout deleting session: " + cookie);
			// delete session
			_deleteSession(_, cookie);
		}
		var h = {
			location: "/",
			"content-type": "application/json"
		};
		response.writeHead(200, h);
		return response.end(JSON.stringify({
			$diagnoses: [{
				$severity: "success",
				$message: "Logged out"
			}]
		}));
	};
	//
	this.cleanupSessionInfos = function(_) {
		var db = adminHelper.getCollaborationOrm(_);
		var sessionInfos = db.fetchInstances(_, db.model.getEntity(_, "sessionInfo"), {
			jsonWhere: {
				serverName: config.servername
			}
		});
		tracer && tracer("session.close - nbSess: " + sessionInfos.length + " - server name: " + config.servername);
		sessionInfos.forEach_(_, function(_, sessionInfo) {
			tracer && tracer("\tsession.close close session: " + sessionInfo.sid(_));
			// delete all locks for this session
			adminHelper.releaseSessionLocks(_, sessionInfo.sid(_));
			sessionInfo.deleteSelf(_);
		});
	}, // FDB - Returns an array that contains all convergence sessions info
	// -> for all Syracuse session if sid==null
	// -> for one Syracuse session if sid!=null
	this.cvgAdmSessInfos = function(_, sid) {
		var res = [],
			self = this;
		var keys = sid ? keys = [sid] : Object.keys(_sessions);
		keys.forEach_(_, function(_, sessId) {
			var syraSess = _sessions[sessId];
			if (syraSess) {
				var cvgSessions = syraSess.getCvgSessions(_);
				if (cvgSessions && cvgSessions.length > 0) {
					cvgSessions.forEach_(_, function(_, cvgSess) {
						res.push(self._getSessionInfo(_, syraSess, cvgSess));
					});
				}
			}
		});
		return res;
	}, //Append syraSessioninfo to cvgSessions instance
	this._getSessionInfo = function(_, syraSess, cvgSess) {
		var i = cvgSess.cvgAdmSessInfo(_);
		// display inactivity time / sessionTimeout
		i.timeout = "" + Math.floor((new Date().getTime() - syraSess.lastAccess) / 1000) + "/" + Math.floor(_settings.timeout * 60), i.syraid = syraSess.id;
		i.syralogin = syraSess.getData("userLogin");
		return i;
	}, // FDB - Returns convergence fusion with given sid
	this.cvgAdmSessInfo = function(_, cvgid) {
		var self = this;
		for (var id in _sessions) {
			var sess = _sessions[id];
			if (sess) {
				var cvgSess = sess.getCvgSession(cvgid);
				if (cvgSess) {
					return self._getSessionInfo(_, sess, cvgSess);
				}
			}
		}
		return null;
	};
};

exports.getGlobals = function(_) {
	return _sessions;
};