"use strict";

var events = require('events');
var config = require('config');
var sessionMod = require('./session');
var Session = sessionMod.Session;
var helpers = require('syracuse-core/lib/helpers');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var os = require("os");
var traceHelper = require('syracuse-trace/lib/helper');
var globals = require('streamline/lib/globals');
var check = require('syracuse-license/lib/check');
var locale = require("syracuse-core/lib/locale");
var sys = require("util");
var url = require('url');
var adminHelpers = require('syracuse-collaboration/lib/helpers');
var path = require('path');
var fs = require('streamline-fs');
var querystring = require('querystring');

var tracer; // = console.log;

var _sessions = {};
var _mustTerminate = false;
var _terminateOrigin = "";

var checkIfIE = helpers.http.checkIfIE;

// get device of current session

/**
 * Session Manager Object
 * Settings:
 *	- key 				The Cookie key to store sessionId in
 * 	- timeout              	Number of minutes that a session can remain idle
 * 	- checkInterval		The interval (in seconds) between checks for expired sessions
 */
/***
 ** sessionManager.ensureSession(_, request, response, options)
 * options:
 * ** authRequired = true--> the user must be logged to execute service
 * ** forceAuth = true --> when user isn't logged and authRequired=true  try to logon
 *                       = false --> when user isn't logged and authRequired=true  the request is refused (for OAuth2, result must be false)
 * ** forceAuth2 = true  for OAuth2, authentication is done on an external server, and the above forceAuth just invokes the
 *                       external server. After invoking Syracuse again using the redirect url, there is one more attempt
 *                       to authenticate - now using the authenticate2 method.
 */
exports.sessionManager = new function() {
	events.EventEmitter.call(this);
	var _timer = null;
	// number of active sessions
	var _count = 0;
	// Active sessions
	var _settings;

	this.setup = function(settings) {
		tracer = settings.tracer;
		//
		_settings = helpers.object.clone(settings || {});
		_settings.key = _settings.key || "syracuse.sid";
		_settings.timeout = _settings.timeout || 20;
		this.sessionTimeout = _settings.timeout;
		_settings.checkInterval = _settings.checkInterval || 5 * 60;
		// Start expiration timer for sessions
		if (!_settings.disabled)
			_timer = setInterval(_checkExpired, _settings.checkInterval * 1000);
		//
		sessionMod.setup(settings);
	};

	function totalSessionCount() {
		return Object.keys(_sessions).reduce(function(total, tenantId) {
			return total + Object.keys(_sessions[tenantId]).length;
		}, 0);
	}

	function _checkExpired() {
		// if memory limit is defined and no sessions anymore, stop server, it will be restarted by the load balancer or the agent
		var limit = config && config.system && config.system.memoryLimit;
		if (limit == null) limit = 500; // test with null as it might be 0 and in this case shouldn't be changed
		if (limit > 0 && totalSessionCount() === 0) {
			var hu = process.memoryUsage().heapUsed / 1024 / 1024;
			if (hu > limit) {
				console.error(locale.format(module, "memoryLimit", hu, limit));
				process.exit(0);
			}
		}
		//
		var expired = +new Date() - (_settings.timeout + 5) * 60 * 1000; // add 5 minutes to Syracuse session timeout to allow Covergence sessions to safelly terminate
		tracer && tracer("sessionManager.session check expired, lastAccess < " + expired);
		for (var tenantId in _sessions) {
			var sessions = _sessions[tenantId];
			for (var key in sessions) {
				var session = sessions[key];
				if (session && (session.lastAccess < expired)) {
					tracer && tracer("sessionManager.session " + key + " expired");
					_deleteSession(!_, key, session, false);
				} else {
					if (_mustTerminate) {
						if (!session.hasCvgSessions()) _deleteSession(!_, key, null, false);
					} else session.isAuthenticated() && session.updateSessionInfo(!_, true, true);
				}
			}
		}
		//
		if (_mustTerminate) {
			if (Object.keys(_sessions).length === 0) {
				console.error(locale.format(module, "gentlyTerminateExit", (new Date()).toISOString(), _terminateOrigin));
				process.exit(1);
			} else {
				console.error(locale.format(module, "gentlyTerminateSessions", (new Date()).toISOString(), Object.keys(_sessions).length));
			}
		}
	}

	function _deleteSession(_, key, session, forceDbDelete) {
		if (session) {
			tracer && tracer("sessionManager.deleteSession found: " + key);
			var sessions = _sessions[session.tenantId];
			if (sessions) {
				delete sessions[key];
				_count--;
			} else {
				console.error("deleteSession: session key not found!");
			}
			session.destroy(_, forceDbDelete);
		} else {
			tracer && tracer("sessionManager.deleteSession not found: " + key + "; will delete sessionInfo");
			var db = adminHelper.getCollaborationOrm(_);
			var si = db.fetchInstance(_, db.getEntity(_, "sessionInfo"), {
				jsonWhere: {
					sid: key
				}
			});
			si && si.deleteSelf(_, {
				ignoreRestrictions: true
			});
		}
	}
	this.formatSessionCookie = function(sid, port) {
		return _settings.key + (port ? ("." + port) : "") + "=" + sid + '; path=/';
	};
	// This is called by license check, in the context of a tenant
	this.deleteSession = function(_, sid) {
		_deleteSession(_, sid, tenantSession(sid), true);
	};

	this.destroy = function(_) {
		for (var tenantId in _sessions) {
			var sessions = _sessions[tenantId];
			for (var key in sessions) {
				_deleteSession(_, key, sessions[key], true);
			}
		}
	};

	this.getSettings = function(_) {
		return helpers.object.clone(_settings);
	};

	function _allocSID() {
		return helpers.uuid.generate();
	}

	function tenantSessions() {
		return _sessions[globals.context.tenantId] || {};
	}

	function tenantSession(key) {
		return tenantSessions()[key];
	}

	this.getTenantSessions = function() {
		return tenantSessions();
	};
	this.sessionById = function(key) {
		return tenantSession(key);
	};
	this.sessionByCookie = function(cookie) {
		var cookies = helpers.http.parseCookie(cookie);

		var key = cookies[_settings.key];
		return key ? tenantSession(key) : null;
	};

	function _getSession(_, request, response) {
		var clientCookie = request.headers.cookie;
		var cookies = helpers.http.parseCookie(clientCookie);
		var port = request.connection.localPort;
		var cookie = cookies[_settings.key + "." + port] || "";
		if (checkIfIE(request.headers['user-agent']))
			cookie = cookies["client.id"];
		var session = null;
		if (cookie) {
			session = tenantSession(cookie);
			if (request.headers.authorization && session && session.authData && session.authData.authorization && (session.authData.authorization !== request.headers.authorization)) {
				if (session.authData.authorization.substr(0, 6) === "Digest") {
					// digest authentication looks different each time because of nonce. Ignore nonce.
					var auth1 = session.authData.authorization;
					var auth2 = request.headers.authorization;
					auth1 = auth1.replace(/\b(response|nc|cnonce)\="\w+"/g, "");
					auth2 = auth1.replace(/\b(response|nc|cnonce)\="\w+"/g, "");
					if (auth1 !== auth2) session = null;
				} else session = null;
			}
			if (session) {
				session.touch();
				request.session = session;
			} else {
				tracer && tracer("Session (" + cookie + ") expired.");
				// force new authorization, needed for logout
				//				request.headers.authorization = "";
			}
		}
		if (!session) {
			if (config.shutDownMarker || _mustTerminate) {
				tracer && tracer("No new session during shutdown");
				var err = new Error(locale.format(module, "noNewSession"));
				err.$httpStatus = 503;
				throw err;
			}
			_internalCreateSession(_, request, response, cookie);
			// if there was a session that doesn't exists anymore (expired or logged out),
			// create a non authenticated session and force browser to login
			if (cookie) {
				// set cookie to the new session id
				_setSessionCookie(_, request, response);
			}
		}
		//
		if (globals.context) {
			globals.context.session = request.session;
			globals.context.request = request;
			globals.context.response = response;
		}
	}

	function _internalCreateSession(_, request, response, reuseSid) {
		// create session object
		var clientCookie = request.headers.cookie;
		var clientId = null;
		if (clientCookie) {
			var r = /client\.id=([\w-]+)/.exec(clientCookie);
			if (r)
				clientId = r[1];
		}
		// reuseSid: Chrome doesn't update the session cookie if a 401 response so this ends up in an failure for user
		// to connect, even with proper credentials. So create a new session with the same session id to prevent this issue.
		// It's OK on all other browsers tested
		// crnit UPDATE: cannot reuse the session Id because the client uses it to detect session change and asks
		// for a new user profile and reload of source code
		//		var session = new Session(request, reuseSid || _allocSID(), clientId);
		var session = new Session(request, _allocSID(), clientId);
		if (checkIfIE(request.headers['user-agent']))
			session.id = session.clientId;

		session.device = 'desktop'; // for now

		session.ignoreStoreSession = _settings.ignoreStoreSession;

		var secure = (request.hosting && request.hosting.https) || ('authorized' in request.connection);
		var port = request.connection.localPort;

		var cookie = _settings.key + "." + port + "=" + session.id;
		if (checkIfIE(request.headers['user-agent']))
			cookie = "client.id=" + session.clientId;

		session.host = (secure ? "https" : "http") + "://" + request.headers.host;
		session.cookie = cookie;

		request.session = session;

		clientCookie = (clientCookie ? (clientCookie + "; ") : "") + _settings.key + "." + port + "=" + session.id;
		// set cookie in request
		request.headers.cookie = clientCookie;
		var tenantId = globals.context.tenantId;
		var sessions = _sessions[tenantId] || (_sessions[tenantId] = {});
		sessions[request.session.id] = session;
		_count++;
		tracer && tracer("Create syracuse session for " + request.url + " (sessionId=" + session.id + ").");
		// session.authModule = _authModule;
		// store session in DB
		tracer && tracer("Store syracuse session for " + request.url + " (sessionId=" + session.id + ").");
		session.touch();
	}

	function _setSessionCookie(_, request, response) {
		function _hasCookie(cookies, value) {
			return cookies.some(function(ck) {
				return ck.indexOf(value) >= 0;
			});
		}

		var secure = (request.hosting && request.hosting.https) || ('authorized' in request.connection);

		function _secureCookie(value) {
			if (secure) value += '; Secure';
			value += '; HttpOnly';
			return value;
		}
		tracer && tracer("_setSessionCookie: has response: " + (response != null));
		if (!response) throw new Error("cannot set session cookie: no response!");

		var writeHead = response.writeHead;
		response.writeHead = function(statusCode, headers) {
			if (request.session) {
				request.session.touch();
				// Send the cookie to the browser
				headers = headers || {};
				var cookie = headers["set-cookie"];
				// multiple cookies
				cookie = cookie || [];
				if (!Array.isArray(cookie))
					cookie = [cookie];

				var expired = new Date(+new Date + _settings.timeout * 60 * 1000);
				var expireGMTString = (new Date(+new Date + 200 * 86400 * 1000)).toUTCString(); // 200 days
				var port = request.connection.localPort;

				if (!_hasCookie(cookie, _settings.key + "." + port)) {
					var syraCookie = _secureCookie(_settings.key + "." + port + "=" + request.session.id + '; path=/;');
					cookie.push(syraCookie);
				}
				// client ID
				if (!_hasCookie(cookie, "client.id")) {
					var clientId = _secureCookie("client.id=" + request.session.clientId + "; path=/; expires=" + expireGMTString);
					if (checkIfIE(request.headers['user-agent']))
						clientId = _secureCookie("client.id=" + request.session.id + "; path=/; expires=" + expireGMTString);
					cookie.push(clientId);
				}
				// user profile
				if (!_hasCookie(cookie, "user.profile." + port) && request.session.userProfileCookie) {
					// Do not add HttpOnly on this cookie to allow cookie modification by client
					var userProfileCookie = "user.profile." + port + "=" + request.session.userProfileCookie + "; path=/; expires=" + expireGMTString;
					cookie.push(userProfileCookie);
				}
				headers['set-cookie'] = cookie;
				// locales
				if (!headers["content-language"])
					headers["content-language"] = locale.current;
			}
			response.writeHead = writeHead;
			return response.writeHead(statusCode, headers);
		};
	}

	/*
	 * options:
	 * ** authRequired = true--> the user must be logged to execute service
	 * ** forceAuth = true --> when user isn't logged and authRequired=true  try to logon
	 *                       = false --> when user isn't logged and authRequired=true  the request is refused
	 */
	this.ensureSession = function(_, request, response) {
		//tracer && tracer("Session manager options: " + sys.inspect(options));
		if (_settings.disabled) throw new Error("configuration error: sessions are disabled!");
		if (_count === 0 && !("mockServer" in config)) { // in cluster it is not necessary to check license again when there are no sessions
			// because all running Syracuse processes will be notified even when they do not have sessions
			check.updateFromDB(_);
		}
		_getSession(_, request, response);
		//
		var cookieResult = _setSessionCookie(_, request, response);
		if (!request.session) throw new Error("internal error: request.session not set");

		// set locales (needs _setSessionCookie be executed first)
		// language url param has priority over accept-language header
		var params = helpers.url.parseQueryString(request.url.split("?")[1]);
		var lang = params && params.language;
		//
		request.session.setLocales(_, lang || locale.extractLocaleCode(request.headers["accept-language"]));
		// only now the session can be stored in database, after _setSessionCookie that forces the user profile to load
		if (request.session && request.session.isAuthenticated() && !request.session.sessionInfo) request.session.updateSessionInfo(!_, true);
		//
		return request.session;
	};

	// SAM 98078 - in case of endpoint change we have to disconnect syracuse session
	this.disconnectX3Sessions = function(_, request, response) {
		_getSession(_, request, response);
		session.disconnectX3Sessions(_);
	};

	//
	this.logout = function(_, request, response, session) {
		// DO NOT delete session cookie. It will allow us to detect a logged out session and force the browser to login again
		tracer && tracer("sessionManager.Logout enter");
		var pck = helpers.http.parseCookie(request.headers.cookie) || {};
		var port = request.connection.localPort;

		var cookie = pck[_settings.key + "." + port];
		if (request.headers['user-agent'] && checkIfIE(request.headers['user-agent']))
			cookie = pck["client.id"];
		var errorExists = false;
		tracer && tracer((new Date()).toISOString() + "; Logout cookie is " + cookie);
		if (cookie) {
			var session = _sessions[cookie];
			if (!session)
				session = tenantSession(cookie);
			// do not logout if there are convergence sessions, unless force=true parameter
			if (session && session.hasCvgSessions()) {
				var query = helpers.url.parseQueryString(request.url.split("?")[1] || "");
				if (!query || !query.force) {
					response.writeHead(403, {
						"content-type": "application/json"
					});
					return response.end(JSON.stringify({
						$diagnoses: [{
							$severity: "warning",
							$message: locale.format(module, "cannotLogoutHasConvergence")
						}]
					}));
				}
			}
			tracer && tracer("sessionManager.logout deleting session: " + cookie);
			if (session && session.authData && session.authData.logout) {
				request.session = session;
				session.authData.logout(_, request, response);
			}
			tracer && tracer((new Date()).toISOString() + "; sessionManager.logout deleting session: " + cookie);
			// delete session
			if (session && session.loginError) {
				errorExists = true;
				require('syracuse-auth/lib/helpers').redirect(_, request, response, "/auth/login/page");
			}
			_deleteSession(_, cookie, session, true);
		}

		if (!errorExists) {
			var h = {
				location: "/auth/login/page",
				"content-type": "application/json"
			};
			response.writeHead(200, h);
			return response.end(JSON.stringify({
				$diagnoses: [{
					$severity: "success",
					$message: "Logged out"
				}]
			}));
		}
	};
	//
	this.cleanupSessionInfos = function(_) {
		var db = adminHelper.getCollaborationOrm(_);
		var sessionInfos = db.fetchInstances(_, db.model.getEntity(_, "sessionInfo"), {
			jsonWhere: {
				serverName: config.servername
			}
		});
		tracer && tracer("session.close - nbSess: " + sessionInfos.length + " - server name: " + config.servername);
		// only close sessions of non existing processes
		var pids = {}; // cache in order to invoke process.kill not more often than necessary
		sessionInfos.forEach_(_, function(_, sessionInfo) {
			var pid = sessionInfo.pid(_);
			if (!(pid in pids)) {
				try {
					process.kill(pid, 0);
					pids[pid] = true;
				} catch (e) { // process does not exist
					pids[pid] = false;
				}
			}
			if (!pids[pid]) {
				var sid = sessionInfo.sid(_);
				tracer && tracer("\tsession.close close session: " + sid);
				// delete all locks for this session
				adminHelper.releaseSessionLocks(_, sid);
				sessionInfo.deleteSelf(_, {
					ignoreRestrictions: true
				});
			}
		});
	}, // FDB - Returns an array that contains all convergence sessions info
	// -> for all Syracuse session if sid==null
	// -> for one Syracuse session if sid!=null
	this.cvgAdmSessInfos = function(_, sid) {
		var res = [],
			self = this;
		var sessions = tenantSessions();
		var keys = sid ? keys = [sid] : Object.keys(sessions);
		keys.forEach_(_, function(_, sessId) {
			var syraSess = sessions[sessId];
			if (syraSess) {
				var cvgSessions = syraSess.getCvgSessions(_);
				if (cvgSessions && cvgSessions.length > 0) {
					cvgSessions.forEach_(_, function(_, cvgSess) {
						res.push(self._getSessionInfo(_, syraSess, cvgSess));
					});
				}
			}
		});
		return res;
	}, //Append syraSessioninfo to cvgSessions instance
	this._getSessionInfo = function(_, syraSess, cvgSess) {
		var i = cvgSess.cvgAdmSessInfo(_);
		// display inactivity time / sessionTimeout
		i.timeout = "" + Math.floor((new Date().getTime() - syraSess.lastAccess) / 1000) + "/" + Math.floor(_settings.timeout * 60), i.syraid = syraSess.id;
		i.syralogin = syraSess.getData("userLogin");
		return i;
	}, // FDB - Returns convergence fusion with given sid
	this.cvgAdmSessInfo = function(_, cvgid) {
		var self = this;
		var sessions = tenantSessions();
		for (var id in sessions) {
			var sess = sessions[id];
			if (sess) {
				var cvgSess = sess.getCvgSession(cvgid);
				if (cvgSess) {
					return self._getSessionInfo(_, sess, cvgSess);
				}
			}
		}
		return null;
	};

	/* Tablet needs - Temporarily to manage a login form in tablet client*/
	this.tabletCheckLogin = function(_, request, response) {
		var cookies = helpers.http.parseCookie(request.headers.cookie);
		var port = request.connection.localPort;
		var cookie = cookies[_settings.key + "." + port] || "";
		if (cookie) {
			var session = tenantSession(cookie);
			if (session) {
				var expired = +new Date() - _settings.timeout * 60 * 1000;
				var res = {
					authenticated: session.isAuthenticated(),
					expired: session.lastAccess < expired
				};
				res.ok = res.authenticated && !res.expired;
				return res;
			}
		}
		return {
			ok: false
		};
	};


	/* Tablet needs - Temporarily to manage the login action trough a form in tablet client*/
	this.tabletDoLogin = function(_, request, response) {
		var cookies = helpers.http.parseCookie(request.headers.cookie);
		var port = request.connection.localPort;
		var cookie = cookies[_settings.key + "." + port] || "";
		if (cookie) {
			var session = tenantSession(cookie);
			if (session) {
				var expired = +new Date() - _settings.timeout * 60 * 1000;
				var res = {
					authenticated: session.isAuthenticated(),
					expired: session.lastAccess < expired
				};
				res.ok = res.authenticated && !res.expired;
				return res;
			}
		}
		return {
			ok: false
		};
	};
};

exports.gentlyTerminate = function(_, origin, withReply) {
	_mustTerminate = true;
	_terminateOrigin = origin;
	console.error(locale.format(module, "gentlyTerminateRequested", (new Date()).toISOString(), _terminateOrigin));
	//
	if (withReply) {
		if (globals.context && globals.context.response) {
			var rr = globals.context.response;
			rr.writeHead(500, {
				"x-syracuse-restrict": "on",
				"content-type": "application/json"
			});
			rr.end(JSON.stringify({
				$diagnoses: [{
					"$severity": "error",
					"$message": locale.format(module, "serverErrorRestrict")
				}]
			}));
			rr.__isEnded = true;
		}
	}
};

// Security risk here: only the globals dump utility should use this
exports.getGlobals = function() {
	return _sessions;
};