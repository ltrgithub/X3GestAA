"use strict";

var events = require('events');
var config = require("syracuse-main/lib/nodeconfig").config;
var sessionMod = require('./session');
var Session = sessionMod.Session;
var helpers = require('syracuse-core/lib/helpers');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var os = require("os");
var globals = require('streamline/lib/globals');
var check = require('syracuse-license/lib/check');
var locale = require("syracuse-core/lib/locale");
var tracer = console.log; // null;

var _sessions = {};

/**
 * Session Manager Object
 * Settings:
 *	- key 				The Cookie key to store sessionId in
 * 	- timeout              	Number of minutes that a session can remain idle
 * 	- checkInterval		The interval (in seconds) between checks for expired sessions
 */
/***
 ** sessionManager.sessionManagement(_, request, response, options)
 * options:
 * ** authRequired = true--> the user must be logged to execute service
 * ** forceAuth = true --> when user isn't logged and authRequired=true  try to logon
 *                       = false --> when user isn't logged and authRequired=true  the request is refused (for OAuth2, result must be false)
 * ** forceAuth2 = true  for OAuth2, authentication is done on an external server, and the above forceAuth just invokes the
 *                       external server. After invoking Syracuse again using the redirect url, there is one more attempt
 *                       to authenticate - now using the authenticate2 method.
 */
exports.sessionManager = new

function() {
	events.EventEmitter.call(this);
	var _timer = null;
	// number of active sessions
	var _count = 0;
	// Active sessions
	var _settings;
	var _getAuthModule;

	this.setup = function(settings, getAuthModule) {
		tracer = settings.tracer;
		//
		_settings = helpers.object.clone(settings || {});
		_getAuthModule = getAuthModule;
		_settings.key = _settings.key || "syracuse.sid";
		_settings.timeout = _settings.timeout || 20;
		this.sessionTimeout = _settings.timeout;
		_settings.checkInterval = _settings.checkInterval || 5 * 60;
		// Start expiration timer for sessions
		if (!_settings.disabled) _timer = setInterval(_checkExpired, _settings.checkInterval * 1000);
		//
		sessionMod.setup(settings);
	};

	function _checkExpired() {
		var expired = +new Date - _settings.timeout * 60 * 1000;
		tracer && tracer("sessionManager.session check expired, lastAccess < " + expired);
		for (var key in _sessions) {
			var session = _sessions[key];
			if (session && (session.lastAccess < expired)) {
				tracer && tracer("sessionManager.session " + key + " expired");
				_deleteSession(void _, key);
			}
		}
	}

	function _deleteSession(_, key) {
		var session = _sessions[key];
		if (session) {
			tracer && tracer("sessionManager.deleteSession found: " + key);
			delete _sessions[key];
			_count--;
			session.destroy(_);
		} else {
			tracer && tracer("sessionManager.deleteSession not found: " + key + "; will delete sessionInfo");
			var db = adminHelper.getCollaborationOrm(_);
			var si = db.fetchInstance(_, db.getEntity(_, "sessionInfo"), {
				sid: key
			});
			si && si.deleteSelf(_);
		}
	}
	this.deleteSession = function(_, sid) {
		_deleteSession(_, sid);
	};
	this.destroy = function(_) {
		for (var key in _sessions) {
			_deleteSession(_, key);
		}
	};

	this.getSettings = function(_) {
		return helpers.object.clone(_settings);
	};

	function _allocSID() {
		return helpers.uuid.generate();
	}

	this.sessionById = function(key) {
		return _sessions[key];
	};
	this.sessionByCookie = function(cookie) {
		var cookies = helpers.http.parseCookie(cookie);
		var key = cookies[_settings.key];
		if (key) return _sessions[key];
		return null;
	};

	function _getSession(_, request, response) {
		var clientCookie = request.headers.cookie;
		var cookies = helpers.http.parseCookie(clientCookie);
		var cookie = cookies[_settings.key] || "";
		var createSesion = true;
		if (cookie) {
			var session = _sessions[cookie];
			if (session) {
				createSesion = false;
				session.touch();
				request.session = session;
			} else {
				tracer && tracer("Session (" + cookie + ") expired.");
				// force new authorization, needed for logout
				request.headers.authorization = "";
			}
		}
		if (createSesion) {
			if (config.shutDownMarker) {
				tracer && tracer("No new session during shutdown");
				request.headers.authorization = "";
				console.log("No new session");
				response.writeHead(503, {
					"Content-Type": "text/plain"
				});
				response.end(locale.format(module, "noNewSession"));
				return false;
			}
			_internalCreateSession(_, request, response);
		}
		//
		if (globals.context) {
			globals.context.session = request.session;
			globals.context.request = request;
		}
		return true;
	}

	function _internalCreateSession(_, request, response) {
		// create session object
		var clientCookie = request.headers.cookie;
		var clientId = null;
		if (clientCookie) {
			var r = /client\.id=([\w-]+)/.exec(clientCookie);
			if (r) clientId = r[1];
		}
		var session = new Session(request, _allocSID(), clientId);
		session.ignoreStoreSession = _settings.ignoreStoreSession;
		session.host = (('authorized' in request.connection) ? "https" : "http") + "://" + request.headers.host;
		session.cookie = _settings.key + "=" + session.id;
		request.session = session;

		clientCookie = (clientCookie ? (clientCookie + "; ") : "") + _settings.key + "=" + session.id;
		// set cookie in request
		request.headers.cookie = clientCookie;
		_sessions[request.session.id] = session;
		_count++;
		tracer && tracer("Create syracuse session for " + request.url + " (sessionId=" + session.id + ").");
		// session.authModule = _authModule;
		// store session in DB
		tracer && tracer("Store syracuse session for " + request.url + " (sessionId=" + session.id + ").");
		session.touch();
		//		session.updateSessionInfo(_);
	}

	function _setSessionCookie(request, response, _, options) {
		if (!response) return true;

		var writeHead = response.writeHead;
		response.writeHead = function(statusCode, headers) {
			if (request.session) {
				request.session.touch();
				// Send the cookie to the browser
				headers = headers || {};
				var cookie = headers["set-cookie"];

				var expired = new Date(+new Date + _settings.timeout * 60 * 1000);
				var syraCookie = _settings.key + "=" + request.session.id + '; path=/; expires=';
				if (!cookie || cookie.indexOf(syraCookie) < 0) {
					cookie = (cookie ? (cookie + "\r\nset-cookie: ") : "") + syraCookie + expired.toGMTString();
				}
				// client ID
				if (cookie.indexOf("client.id=") < 0) {
					var clientExpire = new Date(+new Date + 200 * 86400 * 1000); // 200 days
					cookie += "\r\nset-cookie: client.id=" + request.session.clientId + "; path=/; expires=" + clientExpire.toGMTString();
				}
				headers['set-cookie'] = cookie;
				// locales
				if (!headers["content-language"]) headers["content-language"] = locale.current;
			}
			response.writeHead = writeHead;
			return response.writeHead(statusCode, headers);
		};
		var session = request.session;
		if (options.authRequired && session) {
			if (!session.isAuthenticated()) {
				var authRes = false;
				var authModule = _getAuthModule(request, options.forceAuth2, _);
				if (options.forceAuth) {
					authRes = authModule.authenticate(request, response, _);
				} else if (options.forceAuth2 && authModule.authenticate2) {
					authRes = authModule.authenticate2(request, response, _);
				} else authRes = authModule.forbidden(request, response);
				//
				if (authRes) {
					// TODO: this should be in session.afterAuthentication
					// force user profile loading
					session.getUserProfile(_);
				}
				//
				return authRes;
			}
		}
		return true;
	}

	/*
	 * options:
	 * ** authRequired = true--> the user must be logged to execute service
	 * ** forceAuth = true --> when user isn't logged and authRequired=true  try to logon
	 *                       = false --> when user isn't logged and authRequired=true  the request is refused
	 */
	this.sessionManagement = function(_, request, response, options) {
		if (_settings.disabled || !options) return true;
		if (_count === 0 && !("mockServer" in config)) { // in cluster it is not necessary to check license again when there are no sessions
			// because all running Syracuse processes will be notified even when they do not have sessions
			check.updateFromDB(_);
		}
		if (!_getSession(_, request, response)) return false;
		//
		var cookieResult = _setSessionCookie(request, response, _, options);
		// set locales (needs _setSessionCookie be executed first)
		request.session && request.session.setLocales(_, locale.extractLocaleCode(request.headers["accept-language"]));
		//
		return cookieResult;
	};
	//
	this.logout = function(_, request, response) {
		tracer && tracer("sessionManager.Logout enter");
		var cookie = (helpers.http.parseCookie(request.headers.cookie) || {})[_settings.key];
		if (cookie) {
			tracer && tracer("sessionManager.logout deleting session: " + cookie);
			_deleteSession(_, cookie);
		}
	};
	//
	this.cleanupSessionInfos = function(_) {
		var db = adminHelper.getCollaborationOrm(_);
		var sessionInfos = db.fetchInstances(_, db.model.getEntity(_, "sessionInfo"), {
			jsonWhere: {
				serverName: config.servername
			}
		});
		tracer && tracer("session.close - nbSess: " + sessionInfos.length + " - server name: " + config.servername);
		sessionInfos.forEach_(_, function(_, sessionInfo) {
			tracer && tracer("\tsession.close close session: " + sessionInfo.sid(_));
			// delete all locks for this session
			adminHelper.releaseSessionLocks(_, sessionInfo.sid(_));
			sessionInfo.deleteSelf(_);
		});
	},
	// FDB - Returns an array that contains all convergence sessions info 
	// -> for all Syracuse session if sid==null
	// -> for one Syracuse session if sid!=null
	this.cvgAdmSessInfos = function(_, sid) {
		var res = [],
			self = this;
		var keys = sid ? keys = [sid] : Object.keys(_sessions);
		keys.forEach_(_, function(_, sessId) {
			var syraSess = _sessions[sessId];
			if (syraSess) {
				var cvgSessions = syraSess.getCvgSessions(_);
				if (cvgSessions && cvgSessions.length > 0) {
					cvgSessions.forEach_(_, function(_, cvgSess) {
						res.push(self._getSessionInfo(_, syraSess, cvgSess));
					});
				}
			}
		});
		return res;
	},
	//Append syraSessioninfo to cvgSessions instance
	this._getSessionInfo = function(_, syraSess, cvgSess) {
		var i = cvgSess.cvgAdmSessInfo(_);
		// display inactivity time / sessionTimeout
		i.timeout = "" + Math.floor((new Date().getTime() - syraSess.lastAccess) / 1000) + "/" + Math.floor(_settings.timeout * 60),
		i.syraid = syraSess.id;
		i.syralogin = syraSess.getData("userLogin");
		return i;
	},
	// FDB - Returns convergence fusion with given sid
	this.cvgAdmSessInfo = function(_, cvgid) {
		var self = this;
		for (var id in _sessions) {
			var sess = _sessions[id];
			if (sess) {
				var cvgSess = sess.getCvgSession(cvgid);
				if (cvgSess) {
					return self._getSessionInfo(_, sess, cvgSess);
				}
			}
		}
		return null;
	};
};