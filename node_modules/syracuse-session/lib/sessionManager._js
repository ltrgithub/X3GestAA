"use strict";

var events = require('events');
var config = require("syracuse-main/lib/nodeconfig").config;
var sessionMod = require('./session');
var Session = sessionMod.Session;
var helpers = require('syracuse-core/lib/helpers');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var os = require("os");
var globals = require('streamline/lib/globals');
var check = require('syracuse-license/lib/check');
var locale = require("syracuse-core/lib/locale");
var sys = require("util");
var tracer; // = console.log;

var _sessions = {};
var _tempSessions = {};

/**
 * Session Manager Object
 * Settings:
 *	- key 				The Cookie key to store sessionId in
 * 	- timeout              	Number of minutes that a session can remain idle
 * 	- checkInterval		The interval (in seconds) between checks for expired sessions
 */
/***
 ** sessionManager.sessionManagement(_, request, response, options)
 * options:
 * ** authRequired = true--> the user must be logged to execute service
 * ** forceAuth = true --> when user isn't logged and authRequired=true  try to logon
 *                       = false --> when user isn't logged and authRequired=true  the request is refused (for OAuth2, result must be false)
 * ** forceAuth2 = true  for OAuth2, authentication is done on an external server, and the above forceAuth just invokes the
 *                       external server. After invoking Syracuse again using the redirect url, there is one more attempt
 *                       to authenticate - now using the authenticate2 method.
 */
exports.sessionManager = new function() {
	events.EventEmitter.call(this);
	var _timer = null;
	// number of active sessions
	var _count = 0;
	// Active sessions
	var _settings;
	var _getAuthModule;

	this.setup = function(settings, getAuthModule) {
		tracer = settings.tracer;
		//
		_settings = helpers.object.clone(settings || {});
		_getAuthModule = getAuthModule;
		_settings.key = _settings.key || "syracuse.sid";
		_settings.timeout = _settings.timeout || 20;
		this.sessionTimeout = _settings.timeout;
		_settings.checkInterval = _settings.checkInterval || 5 * 60;
		// Start expiration timer for sessions
		if (!_settings.disabled)
			_timer = setInterval(_checkExpired, _settings.checkInterval * 1000);
		//
		sessionMod.setup(settings);
	};

	function _checkExpired() {
		var expired = +new Date() - _settings.timeout * 60 * 1000;
		tracer && tracer("sessionManager.session check expired, lastAccess < " + expired);
		for (var key in _sessions) {
			var session = _sessions[key];
			if (session && (session.lastAccess < expired)) {
				tracer && tracer("sessionManager.session " + key + " expired");
				_deleteSession(!_, key);
			}
		}
	}

	function _deleteSession(_, key) {
		var session = _sessions[key];
		if (session) {
			tracer && tracer("sessionManager.deleteSession found: " + key);
			delete _sessions[key];
			_count--;
			session.destroy(_);
		} else {
			tracer && tracer("sessionManager.deleteSession not found: " + key + "; will delete sessionInfo");
			var db = adminHelper.getCollaborationOrm(_);
			var si = db.fetchInstance(_, db.getEntity(_, "sessionInfo"), {
				jsonWhere: {
					sid: key
				}
			});
			si && si.deleteSelf(_);
		}
	}
	this.formatSessionCookie = function(sid) {
		return _settings.key + "=" + sid + '; path=/; expires=';
	};
	this.deleteSession = function(_, sid) {
		_deleteSession(_, sid);
	};
	this.destroy = function(_) {
		for (var key in _sessions) {
			_deleteSession(_, key);
		}
	};

	this.getSettings = function(_) {
		return helpers.object.clone(_settings);
	};

	function _allocSID() {
		return helpers.uuid.generate();
	}

	this.sessionById = function(key) {
		return _sessions[key];
	};
	this.sessionByCookie = function(cookie) {
		var cookies = helpers.http.parseCookie(cookie);

		var key = cookies[_settings.key];
		if (key)
			return _sessions[key];
		return null;
	};

	function _getSession(_, request, response) {
		var clientCookie = request.headers.cookie;
		var cookies = helpers.http.parseCookie(clientCookie);
		var port = request.connection.localPort;
		var cookie = cookies[_settings.key + "." + port] || "";
		var createSesion = true;
		if (cookie) {
			var session = _sessions[cookie];
			// CHROME HACK: chrome doesn't replace cookie with new one on 401 response. So we need
			// to store the old session id in _tempSessions until the new one is authenticated
			if (!session && _tempSessions[cookie]) {
				session = _tempSessions[cookie];
				delete _tempSessions[cookie];
			}
			if (request.headers.authorization && session && session.authData && session.authData.authorization && (session.authData.authorization !== request.headers.authorization)) session = null;
			if (session) {
				createSesion = false;
				session.touch();
				request.session = session;
			} else {
				tracer && tracer("Session (" + cookie + ") expired.");
				// force new authorization, needed for logout
				//				request.headers.authorization = "";
			}
		}
		if (createSesion) {
			if (config.shutDownMarker) {
				tracer && tracer("No new session during shutdown");
				request.headers.authorization = "";
				response.writeHead(503, {
					"Content-Type": "text/plain"
				});
				response.end(locale.format(module, "noNewSession"));
				return false;
			}
			_internalCreateSession(_, request, response, cookie);
			// if there was a session that doesn't exists anymore (expired or logged out),
			// create a non authenticated session and force browser to login
			if (cookie) {
				// CHROME HACK: chrome doesn't replace cookie with new one on 401 response. So we need
				// to store the old session id in _tempSessions until the new one is authenticated
				_tempSessions[cookie] = request.session;
				// make a timeout in case user abandon login
				setTimeout(function() {
					delete _tempSessions[cookie];
				}, 5 * 60 * 1000);
				// set cookie to the new session id
				_setSessionCookie(request, response, _, {
					authRequired: false
				});
				//
				tracer && tracer("sending 401 for session: " + cookie);
				var authModule = _getAuthModule(request, false, _);
				return (authModule && (!authModule.unAuthenticated || authModule.unAuthenticated(request, response, _))) || false;
			}
		}
		//
		if (globals.context) {
			globals.context.session = request.session;
			globals.context.request = request;
		}
		return true;
	}

	function _internalCreateSession(_, request, response, reuseSid) {
		// create session object
		var clientCookie = request.headers.cookie;
		var clientId = null;
		if (clientCookie) {
			var r = /client\.id=([\w-]+)/.exec(clientCookie);
			if (r)
				clientId = r[1];
		}
		// reuseSid: Chrome doesn't update the session cookie if a 401 response so this ends up in an failure for user
		// to connect, even with proper credentials. So create a new session with the same session id to prevent this issue.
		// It's OK on all other browsers tested
		// crnit UPDATE: cannot reuse the session Id because the client uses it to detect session change and asks
		// for a new user profile and reload of source code
		//		var session = new Session(request, reuseSid || _allocSID(), clientId);
		var session = new Session(request, _allocSID(), clientId);

		session.ignoreStoreSession = _settings.ignoreStoreSession;

		var secure = (request.hosting && request.hosting.https) || ('authorized' in request.connection);
		var port = request.connection.localPort;

		session.host = (secure ? "https" : "http") + "://" + request.headers.host;
		session.cookie = _settings.key + "." + port + "=" + session.id;
		request.session = session;

		clientCookie = (clientCookie ? (clientCookie + "; ") : "") + _settings.key + "." + port + "=" + session.id;
		// set cookie in request
		request.headers.cookie = clientCookie;
		_sessions[request.session.id] = session;
		_count++;
		tracer && tracer("Create syracuse session for " + request.url + " (sessionId=" + session.id + ").");
		// session.authModule = _authModule;
		// store session in DB
		tracer && tracer("Store syracuse session for " + request.url + " (sessionId=" + session.id + ").");
		session.touch();
	}

	function _setSessionCookie(request, response, _, options) {
		function _hasCookie(cookies, value) {
			return cookies.some(function(ck) {
				return ck.indexOf(value) >= 0;
			});
		}
		tracer && tracer("_setSessionCookie: has response: " + (response != null));
		if (!response)
			return true;

		var writeHead = response.writeHead;
		response.writeHead = function(statusCode, headers) {
			if (request.session) {
				request.session.touch();
				// Send the cookie to the browser
				headers = headers || {};
				var cookie = headers["set-cookie"];
				// multiple cookies
				cookie = cookie || [];
				if (!Array.isArray(cookie))
					cookie = [cookie];

				var expired = new Date(+new Date + _settings.timeout * 60 * 1000);
				var port = request.connection.localPort;

				var syraCookie = _settings.key + "." + port + "=" + request.session.id + '; path=/; expires=';
				if (!_hasCookie(cookie, syraCookie)) {
					cookie.push(syraCookie);
				}
				// client ID
				if (!_hasCookie(cookie, "client.id=")) {
					var clientExpire = new Date(+new Date + 200 * 86400 * 1000); // 200 days
					cookie.push("client.id=" + request.session.clientId + "; path=/; expires=" + clientExpire.toGMTString());
				}
				// user profile
				if (!_hasCookie(cookie, "user.profile.+" + port) && request.session.userProfileCookie) {
					var profileExpire = new Date(+new Date + 200 * 86400 * 1000); // 200 days
					cookie.push("user.profile." + port + "=" + request.session.userProfileCookie + "; path=/; expires=" + profileExpire.toGMTString());
				}
				headers['set-cookie'] = cookie;
				// locales
				if (!headers["content-language"])
					headers["content-language"] = locale.current;
			}
			response.writeHead = writeHead;
			return response.writeHead(statusCode, headers);
		};
		var session = request.session;
		if (options.authRequired && session) {
			tracer && tracer("Session is auth: " + session.isAuthenticated());
			if (!session.isAuthenticated()) {
				var authRes = false;
				var authModule = _getAuthModule(request, options.forceAuth2, _);
				if (options.forceAuth) {
					authRes = authModule.authenticate(request, response, _);
				} else
				if (options.forceAuth2 && authModule.authenticate2) {
					authRes = authModule.authenticate2(request, response, _);
				} else
					authRes = authModule.forbidden(request, response);
				//
				if (authRes) {
					// TODO: this should be in session.afterAuthentication
					// force user profile loading
					session.getUserProfile(_);
				}
				//
				return authRes;
			}
		}
		return true;
	}

	/*
	 * options:
	 * ** authRequired = true--> the user must be logged to execute service
	 * ** forceAuth = true --> when user isn't logged and authRequired=true  try to logon
	 *                       = false --> when user isn't logged and authRequired=true  the request is refused
	 */
	this.sessionManagement = function(_, request, response, options) {
		tracer && tracer("Session manager options: " + sys.inspect(options));
		if (_settings.disabled || !options)
			return true;
		if (_count === 0 && !("mockServer" in config)) { // in cluster it is not necessary to check license again when there are no sessions
			// because all running Syracuse processes will be notified even when they do not have sessions
			check.updateFromDB(_);
		}
		if (!_getSession(_, request, response))
			return false;
		//
		var cookieResult = _setSessionCookie(request, response, _, options);
		// set locales (needs _setSessionCookie be executed first)
		// language url param has priority over accept-language header
		var params = helpers.url.parseQueryString(request.url.split("?")[1]);
		var lang = params && params.language;
		//
		request.session && request.session.setLocales(_, lang || locale.extractLocaleCode(request.headers["accept-language"]));
		//
		return cookieResult;
	};

	// SAM 98078 - in case of endpoint change we have to disconnect syracuse session
	this.disconnectX3Sessions = function(_, request, response) {
		var session = _getSession(_, request, response);
		if (session) {
			session.disconnectX3Sessions(_);
		}
	};

	//
	this.logout = function(_, request, response) {
		// DO NOT delete session cookie. It will allow us to detect a logged out session and force the browser to login again
		tracer && tracer("sessionManager.Logout enter");
		var pck = helpers.http.parseCookie(request.headers.cookie) || {};
		var port = request.connection.localPort;

		var cookie = pck[_settings.key + "." + port];
		if (cookie) {
			tracer && tracer("sessionManager.logout deleting session: " + cookie);
			// delete session
			_deleteSession(_, cookie);
		}
		var h = {
			location: "/",
			"content-type": "application/json"
		};
		response.writeHead(200, h);
		return response.end(JSON.stringify({
			$diagnoses: [{
				$severity: "success",
				$message: "Logged out"
			}]
		}));
	};
	//
	this.cleanupSessionInfos = function(_) {
		var db = adminHelper.getCollaborationOrm(_);
		var sessionInfos = db.fetchInstances(_, db.model.getEntity(_, "sessionInfo"), {
			jsonWhere: {
				serverName: config.servername
			}
		});
		tracer && tracer("session.close - nbSess: " + sessionInfos.length + " - server name: " + config.servername);
		sessionInfos.forEach_(_, function(_, sessionInfo) {
			tracer && tracer("\tsession.close close session: " + sessionInfo.sid(_));
			// delete all locks for this session
			adminHelper.releaseSessionLocks(_, sessionInfo.sid(_));
			sessionInfo.deleteSelf(_);
		});
	}, // FDB - Returns an array that contains all convergence sessions info
	// -> for all Syracuse session if sid==null
	// -> for one Syracuse session if sid!=null
	this.cvgAdmSessInfos = function(_, sid) {
		var res = [],
			self = this;
		var keys = sid ? keys = [sid] : Object.keys(_sessions);
		keys.forEach_(_, function(_, sessId) {
			var syraSess = _sessions[sessId];
			if (syraSess) {
				var cvgSessions = syraSess.getCvgSessions(_);
				if (cvgSessions && cvgSessions.length > 0) {
					cvgSessions.forEach_(_, function(_, cvgSess) {
						res.push(self._getSessionInfo(_, syraSess, cvgSess));
					});
				}
			}
		});
		return res;
	}, //Append syraSessioninfo to cvgSessions instance
	this._getSessionInfo = function(_, syraSess, cvgSess) {
		var i = cvgSess.cvgAdmSessInfo(_);
		// display inactivity time / sessionTimeout
		i.timeout = "" + Math.floor((new Date().getTime() - syraSess.lastAccess) / 1000) + "/" + Math.floor(_settings.timeout * 60), i.syraid = syraSess.id;
		i.syralogin = syraSess.getData("userLogin");
		return i;
	}, // FDB - Returns convergence fusion with given sid
	this.cvgAdmSessInfo = function(_, cvgid) {
		var self = this;
		for (var id in _sessions) {
			var sess = _sessions[id];
			if (sess) {
				var cvgSess = sess.getCvgSession(cvgid);
				if (cvgSess) {
					return self._getSessionInfo(_, sess, cvgSess);
				}
			}
		}
		return null;
	};
};

exports.getGlobals = function(_) {
	return _sessions;
};