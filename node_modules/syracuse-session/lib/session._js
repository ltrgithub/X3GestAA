"use strict";

var events = require('events');
var helpers = require("syracuse-core/lib/helpers");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var flows = require("streamline/lib/util/flows");
var locale = require("syracuse-core/lib/locale");
var datetime = require("syracuse-core/lib/types/datetime");
var x3pool = require("syracuse-x3/lib/pool");
var util = require("util");

var tracer = null;
var updateSessionFuture = null;

function Session(req, id){
	var self = this;
	self.id = id;
	self.lastAccess = new Date();
	self.data = {};
	self.authModule = null;
	self.authData = null;
	self.host = "";
};

exports.Session = helpers.defineClass(Session, events.EventEmitter, {
	isAuthenticated: function(){
		var self = this;
		if (self.authData) 
			return true;
		return false;
	},
	afterAuthentication: function(authData){
		var self = this;
		self.authData = authData;
	},
	touch: function(){
		var self = this;
		// no ms
		self.lastAccess = datetime.now().toJsDate();
		// update session info is asynchronous but we don't wait the result here
		tracer && tracer("session.touch");
		self.updateSessionInfo(null, true);
	},
	destroy: function(_){
		var self = this;
		tracer && tracer("session.destroy: "+this.id);
		// delete all locks for this session
		adminHelper.releaseSessionLocks(_, this.id);
		// close x3 sessions
		x3pool.disconnect(_, this.id);
		// close all fusion sessions
		var fusionSessions = self.getData("fusionSessions");
		if(fusionSessions) 
			Object.keys(fusionSessions).forEach_(_, function(_, ssid) {
				tracer && tracer("session.close fusion session: "+ssid);
				self.closeFusionSession(ssid, false, _);
			});
		//
		self.deleteSessionInfo(_);
	},
	getData: function(name){
		return this.data[name];
	},
	setData: function(name, value){
		var self = this;
		var old = self.data[name];
		if (old == value) 
			return;
		if (old && old.endListener) {
			self.removeListener('end', old.endListener)
		}
		if (old && old.onDestroy) {
			old.onDestroy();
		}
		if (value && value.endListener) {
			self.addListener('end', value.endListener)
		}
		if (typeof value == "undefined") 
			delete self.data[name];
		else 
			self.data[name] = value;
	},
	setUserProfile: function(_, userProfile) {
		this.setData("userProfile", userProfile);
		// set current locale
		this.setLocales(_);
		//
		// update session info is asynchronous but we don't wait the result here
		this.updateSessionInfo();
	},
	getUserProfile: function(_) {
		var up = this.getData("userProfile");
		if (!up && this.getData("userID")) {
			// try to load user profile
			var db = adminHelper.getCollaborationOrm(_);
			if (db) {
				var user = db.fetchInstance(_, db.model.getEntity("user"), this.getData("userID"));
				if (user) {
					up = db.model.getEntity("userProfile").factory.createInstance(_, null, db);
					up.loadUserProfile(_, user);
					this.setUserProfile(_, up);
				}
			}
		}
		return up;
	},
	getUserLogin: function(_) {
		return this.getUserProfile(_) && this.getUserProfile(_).user(_).login(_);
	},
	setLocales: function(_, defaultLocale) {
		// set the locales
		var up = this.getUserProfile(_);
		if(up) {
			if(!up.selectedLocale(_) && defaultLocale) {
				// default locale comes from headers, so might be just "en" or "fr". 
				var defLocale = up._db.fetchInstance(_, up._db.model.getEntity("localePreference"), {jsonWhere:{code:{$regex: "^"+defaultLocale, $options:"i"}}});
				up.selectedLocale(_, defLocale);
				up.save(_);
			}
			if(up.selectedLocale(_)) locale.setCurrent(_, up.selectedLocale(_).code(_), up.selectedLocale(_).toLocaleStructure(_));
		} else 
			defaultLocale && locale.setCurrent(_, defaultLocale);
	},
	deleteSessionInfo: function(_) {
		var session = this;
		if(!session.updateFunnel) session.updateFunnel = flows.funnel(1);
		return session.updateFunnel(_, function(_) {
			tracer && tracer("session.deleteSessionInfo");
			if(session.sessionInfo) session.sessionInfo.deleteSelf(_);
		});
	},
	updateSessionInfo: function(_, timeCheck) {
		var session = this;
		if(session.ignoreStoreSession) return;
		if(!session.updateFunnel) session.updateFunnel = flows.funnel(1);
		return session.updateFunnel(_, function(_) {
			tracer && tracer("session.updateSessionInfo at "+new Date());
			// store or update session
			var sessionInfo = session.sessionInfo;
			if(!sessionInfo) {
				var db = adminHelper.getCollaborationOrm(_);
				// 
				sessionInfo = db.model.getEntity("sessionInfo").factory.createInstance(_, null, db);
				sessionInfo.sid(_, session.id);
				//
				session.sessionInfo = sessionInfo;
			} else
				if(timeCheck && sessionInfo.lastAccess(_).equals(datetime.fromJsDate(session.lastAccess))) {
					return;
				}
			if(session.getData("userProfile")) sessionInfo.userName(_, session.getData("userProfile").user(_).login(_));
			sessionInfo.lastAccess(_, datetime.fromJsDate(session.lastAccess));
			sessionInfo.save(_);
		});
	},
	getFusionSession: function(fsid) {
		return (this.getData("fusionSessions") || {})[fsid];
	},
	// usualy we call this function as future
	updateFusionSession: function(fusionSession, _) {
		var session = this;
		if(!session.updateFunnel) session.updateFunnel = flows.funnel(1);
		return session.updateFunnel(_, function(_) {
			tracer && tracer("session.updateFusionSessionInfo at "+new Date());
			var fusionSessions = session.getData("fusionSessions");
			if(!fusionSessions) session.setData("fusionSessions", fusionSessions = {});
			fusionSessions[fusionSession.sid] = fusionSession;
			// update dbinfo
			if(session.sessionInfo) {
				tracer && tracer("session.updateFusionSessionInfo dbupdate");
				var fusionSessionInfo = session.sessionInfo.fusionSessions(_).get(_, fusionSession.sid);
				if(!fusionSessionInfo) {
					fusionSessionInfo = session.sessionInfo.createChild(_, "fusionSessions", fusionSession.sid);
					fusionSessionInfo.sid(_, fusionSession.sid);
					session.sessionInfo.fusionSessions(_).set(_, fusionSessionInfo);
				}
				//
				fusionSessionInfo.lastAccess(_, datetime.now());
				fusionSessionInfo.sessionUrl(_, fusionSession.sessionUrl);
				fusionSessionInfo.isXmlSessionFormat(_, fusionSession.isXmlSessionFormat);
				//
				if(session.ignoreStoreSession) return;
				session.sessionInfo.save(_);
			}
		});
	},
	closeFusionSession: function(fsid, reuse, _) {
		var fusionSessions = this.getData("fusionSessions");
		fusionSessions[fsid].close(_, reuse);
		delete fusionSessions[fsid];
	}
});

exports.setup = function(config) {
	tracer = config && config.tracer;
}
