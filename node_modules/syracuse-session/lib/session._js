"use strict";

var events = require('events');
var helpers = require("syracuse-core/lib/helpers");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var flows = require("streamline/lib/util/flows");
var glob = require("streamline/lib/globals");
var locale = require("syracuse-core/lib/locale");
var datetime = require("syracuse-core/lib/types/datetime");
var x3pool = require("syracuse-x3/lib/pool");
var util = require("util");
var sys = util;
var uuid = require('syracuse-core/lib/uuid');
var perfmon = require('syracuse-perfmon');
var locale = require("syracuse-core/lib/locale");

var config;
var tracer; // = console.log;
var updateSessionFuture = null;
var maxTimings = 20;


// add temporary function to log create and destroy syrapedia session

function syrapediaTrace(sess, created) {
	var date = new Date().toUTCString();
	if (created) {
		tracer && tracer(date + " - syracuse session create : [" + sess.id + "]");
	} else {
		tracer && tracer(date + " - syracuse session destroy : [" + sess.id + "]");
	}
}

function Session(req, id, clientId) {
	var self = this;
	self.id = id;
	self.lastAccess = new Date();
	self.data = {};
	self.authModule = null;
	self.authData = null;
	self.host = "";
	self.clientId = clientId || uuid.generate();
	self.serverName = config && config.servername;
};

exports.Session = helpers.defineClass(Session, events.EventEmitter, {
	isAuthenticated: function() {
		var self = this;
		if (self.authData) return true;
		return false;
	},
	afterAuthentication: function(authData) {
		var self = this;
		self.authData = authData;
	},
	touch: function() {
		var self = this;
		// no ms
		self.lastAccess = datetime.now().toJsDate();
		var req = glob.context.request;
		req && self.setData("requestInfo", {
			url: req.url,
			peerAddress: req.connection ? (req.connection.remoteAddress || "") : "-"
		});
		// update session info is asynchronous but we don't wait the result here
		tracer && tracer((new Date()).toISOString() + "; session.touch " + self.id);
		// don't save it here, we'll save the same time with check to spare resources
		//self.updateSessionInfo(!_, true);
	},
	disconnectX3Sessions: function(_) {
		// close x3 sessions
		x3pool.disconnect(_, this.id);
	},
	destroy: function(_, forceDelete) {
		var self = this;
		syrapediaTrace(this, false);
		tracer && tracer((new Date()).toISOString() + "; session.destroy: " + this.id);
		// delete all locks for this session
		adminHelper.releaseSessionLocks(_, this.id);
		// close x3 sessions
		this.disconnectX3Sessions(_);
		// close all fusion sessions
		var cvgSessions = self.getData("cvgSessions");
		if (cvgSessions) Object.keys(cvgSessions).forEach_(_, function(_, ssid) {
			tracer && tracer("session.close fusion session: " + ssid);
			self.closeCvgSession(ssid, false, "Closed destroy syracuse session", _);
		});
		//
		// it's purge by time to live now but for logout we keep the direct delete
		if (forceDelete) self.deleteSessionInfo(_);
	},

	getData: function(name) {
		return this.data[name];
	},
	setData: function(name, value) {
		var self = this;
		var old = self.data[name];
		if (old == value) return;
		if (old && old.endListener) {
			self.removeListener('end', old.endListener);
		}
		if (old && old.onDestroy) {
			old.onDestroy();
		}
		if (value && value.endListener) {
			self.addListener('end', value.endListener);
		}
		if (typeof value == "undefined") delete self.data[name];
		else self.data[name] = value;
	},
	fromCache: function(categ, id) {
		return ((this.cache || {})[categ] || {})[id];
	},
	toCache: function(categ, id, value) {
		this.cache = this.cache || {};
		this.cache[categ] = this.cache[categ] || {};
		this.cache[categ][id] = value;
		return value;
	},
	resetCache: function(categ) {
		if (categ) {
			if ((this.cache || {})[categ]) this.cache[categ] = {};
		} else this.cache = {};
	},
	setUserProfile: function(_, userProfile) {
		this.setData("userProfile", userProfile);
		this.setData("userLogin", userProfile.user(_).login(_));
		// set current locale
		this.setLocales(_);
		// set security profile
		if (userProfile && userProfile.selectedRole(_) && userProfile.selectedRole(_).securityProfile(_)) this.setData("securityProfile", userProfile.selectedRole(_).securityProfile(_));
		// update session info is asynchronous but we don't wait the result here
		// update is not here anymore, it's with check interval
		// this.updateSessionInfo(!_);
		// get right access

	},
	getUserProfile: function(_) {
		var up = this.getData("userProfile");
		if (!up && this.getData("userID")) {
			// try to load user profile
			var db = adminHelper.getCollaborationOrm(_);
			if (db) {
				var user = db.fetchInstance(_, db.model.getEntity(_, "user"), this.getData("userID"));
				if (user) {
					up = db.model.getEntity(_, "userProfile").factory.createInstance(_, null, db);
					up.loadUserProfile(_, user);
					this.setUserProfile(_, up);
				}
			}
		}
		return up;
	},
	getSecurityProfile: function(_) {
		return this.getData("securityProfile");
	},
	setSecurityProfile: function(profile) {
		this.setData("securityProfile", profile);
	},
	getUserLogin: function(_) {
		//return this.getUserProfile(_) && this.getUserProfile(_).user(_).login(_);
		return this.getData("userLogin");
	},
	setLocales: function(_, localeHeaderCode) {
		localeHeaderCode && locale.setCurrent(_, localeHeaderCode);
	},
	deleteSessionInfo: function(_) {
		var session = this;
		//		if (!session.updateFunnel) session.updateFunnel = flows.funnel(1);
		//		return session.updateFunnel(_, function(_) {
		tracer && tracer("session.deleteSessionInfo" + (session.sessionInfo ? ": got session Info" : "no session info"));
		if (session.sessionInfo) session.sessionInfo.deleteSelf(_);
		//		});
	},

	updateSessionInfo: function(_, timeCheck, withCvgSessions) {
		var session = this;
		if (session.ignoreStoreSession) return;
		try {
			//		if (!session.updateFunnel) session.updateFunnel = flows.funnel(1);
			//		return session.updateFunnel(_, function(_) {
			// store or update session
			var sessionInfo = session.sessionInfo;
			if (!sessionInfo) {
				var db = adminHelper.getCollaborationOrm(_);
				// 
				sessionInfo = session.sessionInfo = (session.sessionInfo || db.model.getEntity(_, "sessionInfo").factory.createInstance(_, null, db));
				syrapediaTrace(session, true);
				sessionInfo.sid(_, session.id);
				sessionInfo.pid(_, "" + process.pid);
				//
				//sessionInfo.badge(_, ""); // temporary badge;
				sessionInfo.clientId(_, session.clientId); // client ID 
			} else if (timeCheck && sessionInfo.lastAccess(_).equals(datetime.fromJsDate(session.lastAccess))) {
				return;
			}
			if (session.getData("userProfile")) sessionInfo.userName(_, session.getData("userProfile").user(_).login(_));
			else sessionInfo.userName(_, locale.format(module, "noUserProfile", session.authData ? session.authData.user : "!none!"));
			sessionInfo.badge(_, session.getData("badge") || "");
			sessionInfo.x3Sessions(_, x3pool.allClientIds(session.id).join(", "));
			var req = session.getData("requestInfo") || {};
			sessionInfo.lastUrl(_, req.url);
			sessionInfo.peerAddress(_, req.peerAddress);
			sessionInfo.lastAccess(_, datetime.fromJsDate(session.lastAccess));
			var res = sessionInfo.save(_, null, {
				shallowSerialize: true,
				ignoreRestrictions: true
			});
			if (res && res.$actions && res.$actions.$save && res.$actions.$save.$diagnoses) //
				tracer && tracer((new Date()).toISOString() + "; session.updateSessionInfo " + session.id + "; result: " + sys.inspect(res && res.$actions && res.$actions.$save && res.$actions.$save.$diagnoses));
			else {
				tracer && tracer((new Date()).toISOString() + "; session.updateSessionInfo(2) " + session.id + "; result: " + sys.inspect(res));
				tracer && tracer((new Date()).toISOString() + "; session.updateSessionInfo(3) " + session.id + "; result: " + sys.inspect(sessionInfo.getAllDiagnoses(_)));
			}
			// update associated cvgSessions
			if (withCvgSessions) {
				session.getCvgSessions(_).forEach_(_, function(_, cvgs) {
					res = cvgs.cvgUpdateSessionInfo(_);
					tracer && tracer((new Date()).toISOString() + "; session.updateCvgSessionInfo " + cvgs.sessionInfo.sid(_) + "; result: " + sys.inspect(res && res.$actions && res.$actions.$save && res.$actions.$save.$diagnoses));
				});
			}
		} catch (e) {
			console.error((new Date()).toISOString() + "; Error in session.updateSessionInfo: " + e.message);
			throw e;
		}
		//		});
	},
	getCvgSession: function(fsid) {
		return (this.getData("cvgSessions") || {})[fsid];
	},
	hasCvgSessions: function() {
		var cvgSessions = this.getData("cvgSessions");
		return (cvgSessions != null) && (Object.keys(cvgSessions).length > 0);
	},
	getCvgSessions: function(_) {
		var res = [];
		var cvgSessions = this.getData("cvgSessions");
		if (cvgSessions) {
			Object.keys(cvgSessions).forEach_(_, function(_, ssid) {
				res.push(cvgSessions[ssid]);
			});
		}
		return res;
	},
	updateCvgSession: function(cvgSession) {
		// Session lastAccess has been updated by touch before
		var cvgSessions = this.getData("cvgSessions");
		if (!cvgSessions) this.setData("cvgSessions", cvgSessions = {});
		cvgSessions[cvgSession.sid] = cvgSession;
		cvgSession.lastAccess = datetime.now();
		//cvgSession.cvgUpdateSessionInfo(_);
	},
	closeCvgSession: function(fsid, reuse, reason, _) {
		tracer && tracer("closeCvgSession - id=" + fsid + "- reuse=" + reuse + " - reason=" + reason);
		var cvgSessions = this.getData("cvgSessions");
		if (cvgSessions && cvgSessions[fsid]) {
			cvgSessions[fsid].close(_, reuse, reason);
			delete cvgSessions[fsid];
			tracer && tracer("\tSession deleted");
		} else {
			tracer && tracer("\tcloseCvgSession - Session not found");
		}
	},
	addTimings: function() {
		var timings = perfmon.collect(true);
		if (!maxTimings || !timings || !timings.children || !timings.children.length) return;
		this.timings = this.timings || [];
		this.timings.push(timings);
		while (this.timings.length > maxTimings) this.timings.shift();
	}
});

exports.setup = function(cfg) {
	config = cfg;
	tracer = config && config.tracer;
};