"use strict";

var config = require('config');
var globals = require('streamline/lib/globals');
var _sessions = [];

var counters = {
	alloc: 0,
	reuse: 0,
	recycle: 0,
	discard: 0,
};

function httpError(status, message) {
	var error = new Error(message);
	error.$httpStatus = status;
	return error;
}

exports.allocSession = function(_, request, response, sessionManager) {
	var tenantId = globals.context.tenantId;
	var tenantSessions = _sessions[tenantId] || (_sessions[tenantId] = {});
	//if (!request.headers.authorization) throw httpError(401, "Authorization header missing");
	var poolKey = request.headers.authorization + '/' + request.headers['accept-language'];
	var bucket = tenantSessions[poolKey] || (tenantSessions[poolKey] = { sessions: [] });
	bucket.touchTime = Date.now();
	var session;
	bucket.sessions = bucket.sessions.filter(function(session) {
		return !session.destroyed;
	});
	if (bucket.sessions.length > 0) {
		counters.reuse++;
		session = bucket.sessions.pop();
		request.session = session;
	} else {
		counters.alloc++;
		session = sessionManager.ensureSession(_, request, response, false);
	}
	response.on('finish', function() {
		if (session.authData) {
			counters.recycle++;
			bucket.sessions.push(session);
		} else {
			counters.discard++;
		}
	});
	return session;
}

// use same timeout setting as interactive sessions - we'll introduce a separate setting later if requested
var timeoutMillis = (config.session.timeout || 20) * 60 * 1000;

// Note: we don't need to worry about globals in this cleanup loop as it does *not* notify applicative code
setInterval(function() {
	var now = Date.now();
	Object.keys(_sessions).forEach(function(tenantId) {
		var tenantSessions = _sessions[tenantId];
		var keepTenant = false;
		Object.keys(tenantSessions).forEach(function(key) {
			var bucket = tenantSessions[key]
			if (now > bucket.touchTime + timeoutMillis) delete tenantSessions[key];
			else keepTenant = true;
		});
		if (!keepTenant) delete _sessions[tenantId];
	});
	//console.error(counters, _sessions);
}, timeoutMillis);