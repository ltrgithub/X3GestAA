"use strict";
(function($) {
	var that = $.smobile;
	that.controls = that.controls || {};
	var $helpers = $.helpers; // == require
	var $proto = $.proto; // == require
	/* used for $query or $lookup */


	var _checkMetaData = function(controller, cp, options) {
		var metaKey = options.$bind;
		//  Issue #2298 - For X3 reference field metadata is returned on $rvalue field 
		if (cp.$rtype === "application/x-reference" && cp.$rvalue) metaKey = cp.$rvalue;
		var meta = controller.getProtoDataValue(metaKey);
		return {
			$isHidden: meta && meta.$isHidden
		};
	};

	that.controls.SingleField = {
		sync: true,
		initData: function(cp, ft, title, opts, $article) {
			var res = "";
			$article = $article || {};
			opts.label = title;
			opts.$article = $article;
			opts.$isMandatory = cp.$isMandatory != null && cp.$isMandatory;
			opts.$format = cp.$format != null && cp.$format;
			switch (ft) {
				case "application/x-string":
				case "application/x-password":
					opts.type = "text";
					opts.$minLength = cp.$minLength;
					opts.$maxLength = cp.$maxLength;
					opts.$salt = cp.$salt;
					if (cp.$format === "$email") {
						opts.type = "email";
					} else if (cp.$format === "$url") {
						opts.type = "url";
					} else if (cp.$format === "$phone") {
						opts.type = "tel";
					}
					if (ft === "application/x-password") {
						opts.type = "password";
						if (cp.$capabilities && (cp.$capabilities.indexOf("confirm") >= 0)) {
							opts.$confirm = true;
						}
					}
					res = "Edit";
					break;
				case "application/x-choice":
					var items = [];
					opts.items = items;
					opts.$isMandatory = true;
					cp.$value.$enum.forEach(function(value) {
						items.push({
							value: value.$value,
							title: $proto.execExpression(value.$title, cp)
						});

					});
					res = "Combo";
					break;
				case "application/x-integer":
				case "application/x-real":
				case "application/x-decimal":
				case "application/x-quantity":
					opts.type = "number";
					opts.decimals = 0;
					var isQuantity = (ft === "application/x-quantity"); //ok
					var cpp = isQuantity ? cp.$value : cp;
					if (cpp.$format != null) {
						opts.decimals = $helpers.format2decimals(cpp.$format);
					} else if (cpp.$scale != null) {
						opts.decimals = cpp.$scale;
					}
					if (opts.$article.$minimum != null) {
						opts.$minimum = opts.$article.$minimum;
					}
					if (opts.$article.$maximum != null) {
						opts.$maximum = opts.$article.$maximum;
					}
					if (cpp.$minimum != null) {
						opts.$minimum = cpp.$minimum;
					}
					if (cpp.$maximum != null) {
						opts.$maximum = cpp.$maximum;
					}
					if (isQuantity) {
						opts.quantity = cp.$unit;
					}
					res = "Edit";
					if (opts.gauge) res = "Gauge";
					break;
				case "application/x-boolean":
					res = "CheckBox";
					break;
				case "image":
					res = "Picture";
					break;
				case "application/x-date":
					opts.type = "date";
					res = "Edit";
					break;
				case "application/x-time":
					opts.type = "time";
					res = "Edit";
					break;
				case "application/x-datetime":
					opts.type = "datetime";
					res = "Edit";
					break;
				case "text/plain":
				case "text/rtf":
				case "text/html":
					res = "Text";
					break;
			}
			return res;
		},
		handler: function(c, after) {
			var controller = this,
				fieldData;
			var options = c.data || {};
			var $article = options.$article || {};
			var page = controller.getPageData();
			var controls, cc, scc, ft, opts, cclass, title;
			if (!page) return after({
				html: "",
				options: {}
			});
			var html = [];
			var edit = $article.$inquiry === "result" ? false : (options.facet === "$edit") || (options.facet === "$create");
			var cp = $proto.getProto(page, options.$bind),
				pp = cp;
			var entityProto = $proto.getProto(page);
			if (cp.$rtype === "application/x-reference") {
				pp = cp.$protoparent;
			}
			if (c.data && c.data.$gauge) { // Is property to be displayed as gauge?
				/* 
				 * Note: Charts can not be rendered as plain html as done for other widgets in non edit mode.
				 * We need to build a container and the use JS/SVG to apply the chart.
				 * This is why gauges are always handled like in edit mode (create field, add binding - not only plain html generation)
				 */
				options.$article = null;
				controls = [];
				cc = null;
				ft = cp.$type || cp.$rtype;
				scc = {
					id: c.id + "_" + options.$bind,
					data: {
						inline: false,
						bind: options.$bind,
						gauge: c.data.$gauge
					}
				};
				opts = scc.data;
				if (pp.$isHidden || pp.$isExcluded || _checkMetaData(controller, cp, options).$isHidden) {
					return after(null);
				}
				title = $proto.parseExpression(pp.$shortTitle || pp.$title, {
					data: null,
					$prototype: pp
				}, "$title");

				cclass = that.controls.SingleField.initData(cp, ft, title, opts, $article);
				if (cclass) {
					scc.id = c.id + "_" + options.$bind;
					cc = that.controls[cclass]["create" + cclass](controller, scc, $article);
					cc.id = scc.id;
					cc.uiClass = cclass;
					cc.scid = "_" + options.$bind;
				}

				if (cc) {
					controls.push(cc);
				}
				if (controls.length) {
					return after(controls);
				} else {
					return after(null);
				}
			} else if (edit) {
				options.$article = null;
				controls = [];
				cc = null;
				ft = cp.$type || cp.$rtype;
				scc = {
					id: c.id + "_" + options.$bind,
					data: {
						inline: false,
						bind: options.$bind
					}
				};
				if (c.data && c.data.$gauge) {
					scc.data.gauge = c.data.$gauge;
				}
				opts = scc.data;
				if (pp.$isReadOnly) opts.$isReadOnly = true;
				if (pp.$isDisabled) opts.$isDisabled = true;
				if (pp.$isEditMode) opts.$isEditMode = true;
				if (pp.$isHidden || pp.$isExcluded || _checkMetaData(controller, cp, options).$isHidden) {
					return after(null);
				}
				title = $proto.parseExpression(pp.$shortTitle || pp.$title, {
					data: null,
					$prototype: pp
				}, "$title");
				switch (ft) {
					case "application/x-reference":
						opts.type = "text";
						fieldData = controller.getValue(options.$bind);
						opts.label = title;
						opts.$article = $article;
						scc.id = c.id + "_" + options.$bind;
						if (cp.$links && cp.$links.$lookup && cp.$links.$lookup.$url) {
							opts.$lookupurl = cp.$links.$lookup.$url;
						}
						// #2826
						if (pp && pp.$isMandatory) opts.$isMandatory = true;
						cc = that.controls.Lookup.createLookup(controller, scc);
						cc.id = scc.id;
						cc.uiClass = "Lookup";
						cc.scid = "_" + options.$bind;
						break;
					default:
						cclass = that.controls.SingleField.initData(cp, ft, title, opts, $article);
						break;
				}
				if (cclass) {
					scc.id = c.id + "_" + options.$bind;
					cc = that.controls[cclass]["create" + cclass](controller, scc, $article);
					cc.id = scc.id;
					cc.uiClass = cclass;
					cc.scid = "_" + options.$bind;
				}

				if (cc) {
					controls.push(cc);
				}
				if (controls.length) {
					return after(controls);
				} else {
					return after(null);
				}
			} else {
				if (cp.$isHidden || $article.$isHidden || cp.$isExcluded || $article.$isExcluded || _checkMetaData(controller, cp, options).$isHidden) {
					return after({
						html: "",
						bind: false
					});
				}
				var isEmpty = null;
				var spaceIfEmpty = "withtitle" == c.emptyCellOption;
				var labelAfter = false,
					cssl;
				html.push('<div class="s-m-relative');
				html.push('">');
				cssl = ["s-m-style", "s-m-label"];
				if (!$article.$isTitleHidden) {
					if (cp.$type === "image") {
						$article.$label = $article.$label || {};
						$article.$label.$styles = $article.$label.$styles || [];
						$article.$label.$styles.push("top");
					}
					labelAfter = $proto.auth.mobileExtentionsLbl(cssl, $article);
					if (labelAfter) {
						cssl.push("after");
					} else {
						html.push('<label class="' + cssl.join(' ') + '">');
						html.push($proto.parseExpression(pp.$shortTitle || pp.$title || "", {
							data: null,
							$prototype: pp
						}, "$title", {
							html: true
						}));
						html.push('</label>');
					}
				}
				var css = ["s-m-style s-m-value"];
				$proto.auth.mobileExtentions(css, $article);
				var _createparentDiv = function(isImage) {
					html.push('<div class="');
					html.push(css.join(' '));
					if ($article.$cssPrefix) html.push(' noindent');
					if (isImage === true) html.push(' image');
					html.push('"');
					if ($article.$style) html.push(' style="' + $article.$style + '"');
					html.push('>');
				};
				if (cp.$rtype === "application/x-reference") {
					_createparentDiv();
					fieldData = controller.getValue(options.$bind);
					var toptions = that.controls.types.addReference(cp, fieldData, controller, options.$bind, $article.$refDescription && $article.$refDescription.$withTitle);
					//					that.controls.SingleField._processExternalLinks(html, cp, controller, dd, pp);
					if (toptions.value == null || toptions.value.trim().length == 0) {
						isEmpty = true;
						if (spaceIfEmpty) {
							html.push("&nbsp;");
						}
					} else {
						toptions.$article = $article;
						that._addLink(html, toptions, controller);
					}
				} else {
					var updproto = {}, added = false;
					$proto.updproto(updproto, cp);
					if ($proto.isNumeric(cp.$type)) {
						if ($article.$maximum != null) updproto.$maximum = $article.$maximum;
						if ($article.$minimum != null) updproto.$minimum = $article.$minimum;
						var valproto = controller.getProtoDataValue(options.$bind);
						$proto.updproto(updproto, valproto);
						if ((updproto.$maximum != null) && (updproto.$minimum != null)) {
							var value = controller.getValue(options.$bind) || 0;
							if (value < $article.$minimum) value = $article.$minimum;
							if (value > $article.$maximum) value = $article.$maximum;
							added = true;
							var proc = 0;
							try {
								proc = parseInt(value * 10000 / ($article.$maximum - $article.$minimum)) / 100;

							} catch (ex) {}
							css.push("top");
							_createparentDiv();
							html.push('<div class= "s-m-slider"><div class="s-m-slider-ind" style="left:' + proc + '%"><center>');
							var fieldValue = $proto.htmlValue(controller.getValue(), entityProto, updproto, {
								$bind: options.$bind,
								$type: cp.$type
							}, value, {
								useValue: true
							});
							isEmpty = fieldValue == null || fieldValue.trim().length == 0;
							html.push(isEmpty ? spaceIfEmpty ? "&nbsp;" : "" : fieldValue);
							html.push('</center></div></div>');
							//
							//html.push("***");
						}

					}
					if (!added) {
						_createparentDiv(updproto.$type === "image");
						var dd = controller.getValue();
						var defvalue = $proto.htmlValue(dd, entityProto, updproto, {
							$bind: options.$bind,
							$type: cp.$type
						}, null, {
							cssPrefix: $article.$cssPrefix,
							styles: $article.$styles
						});
						var fieldValue = defvalue;
						if ($article && $article.$expression) {
							fieldValue = $article.$expression.replace(/\{(.*?)\}/g, function(match, prop) {
								if (prop === options.$bind) return defvalue;

								var cppp = $proto.getProto(page, prop);
								if (!cppp) return "";
								return $proto.htmlValue(dd, entityProto, cppp, {
									$bind: prop,
									$type: cppp.$type
								}, '', {
									list: true
								});
							});

						}
						isEmpty = fieldValue == null || fieldValue.trim().length == 0;
						if (!isEmpty) {
							$proto.auth.mobileCssPrefix(fieldValue, html, $article, controller.getValue(), null, false, false);
						} else if (spaceIfEmpty) {
							html.push("&nbsp;");
						}
					}
				}
				html.push('</div>');
				if (labelAfter) {
					html.push('<label class="' + cssl.join(' ') + '">');
					html.push($proto.parseExpression(pp.$shortTitle || pp.$title || "", {
						data: null,
						$prototype: pp
					}, "$title", {
						html: true
					}));
					html.push('</label>');
				}

				that.controls.SingleField._processExternalLinks(html, cp, controller, dd, pp);
				html.push('</div>');
				var res = {
					html: html.join(''),
					bind: options.bind,
					options: options,
					isEmpty: isEmpty
				};
				if (isEmpty === true && c.emptyCellOption != null) {
					// Issue #3128 - do not display empty cells or empty rows for RowLayouts
					if (c.emptyCellOption === "empty") {
						res.html = "";
					} else if (c.emptyCellOption === "filled") {
						res.html = "&nbsp;";
					} // else if (c.emptyCellOption === "withtitle") -> Nothing
				}
				return after(res);
			}
		},
		_processExternalLinks: function(html, cp, controller, dd, pp) {
			if (cp.$externalLinks) {
				Object.keys(cp.$externalLinks).forEach(function(link) {
					html.push('<div class="s-m-style s-m-value-link">');
					var text = $proto.parseExpression(cp.$externalLinks[link].$title, {
						data: controller.exprData(dd),
						$prototype: pp
					}, "$title", {
						html: true
					});
					var href = $proto.parseExpression(cp.$externalLinks[link].$url, {
						data: controller.exprData(dd),
						$prototype: pp
					}, "$url", {
						html: false
					});
					html.push('<a href="' + href + '" target="_blank">' + text + '</a>');
					html.push("</div>");
				});
			}
		}
	};
})(jQuery);