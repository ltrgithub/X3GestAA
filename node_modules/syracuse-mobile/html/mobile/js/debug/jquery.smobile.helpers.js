'use strict';
(function() {

	// http://jsperf.com/equal-ignore-case
	var _chrCmpMap = (function() {
		var tab = {};
		var str = 'abcdifghijklmnopqrstuvwxyzàèéìòù';
		for (var i = 0, n = str.length; i !== n; i++) {
			var c = str[i];
			tab[c] = c;
			tab[c.toUpperCase()] = c;
		}
		return tab;
	})();

	String.prototype.equalsIgnoreCase = function(s) {
		if (typeof s !== 'string') return false;
		var n = this.length;
		if (n !== s.length) return false;
		var tab = _chrCmpMap;
		while (n--) {
			var c = this[n];
			var t = tab[c];
			if (t === undefined) {
				if (c !== s[n]) return false;
			} else {
				if (t !== tab[s[n]]) return false;
			}
		}
		return true;
	};

})();

(function($) {

	var that = $.proto || {};
	$.proto = that;
	var $proto = that;
	var $helpers = $.helpers;
	var $scroller = $.scroller;
	that.x3supportbatch = false;
	that.support$actions = true;

	var _exp = function(data) {
		this.stack = [];
		if (data) this.stack.push(data);
	};
	_exp.prototype = {
		push: function(data) {
			this.stack.unshift(data);
		},
		data: function() {
			if (this.stack.length) return this.stack[this.stack.length - 1];
			return null;
		},
		add: function(cd) {
			this.stack.push(cd);
		},
		pop: function() {
			this.stack.splice(this.stack.length - 1, 1);
		},
		parent: function(data) {
			var ii = this.stack.indexOf(data);
			if (ii > 0) return this.stack[ii - 1];
			return null;
		}

	};

	// http://detectmobilebrowsers.com/
	(function(a) {
		that.isMobile = /android.+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|e\-|e\/|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(di|rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|xda(\-|2|g)|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4));
	})(navigator.userAgent || navigator.vendor || window.opera);

	var _basicTypes = ["application/x-string", "application/x-password",
		"application/x-integer", "application/x-real",
		"application/x-decimal", "application/x-quantity", "application/x-boolean",
		"application/x-date", "application/x-time",
		"application/x-datetime", "application/x-choice", "image"];
	that.isNumeric = function(type) {
		return (["application/x-integer", "application/x-real",
			"application/x-decimal"].indexOf(type) >= 0);

	};
	that.formatDecimal = function(value, cp, data, field) {
		try {
			var dec = 0;
			if (cp) {
				if (cp.$format) {
					dec = $helpers.format2decimals(cp.$format);
				} else if (cp.$scale) {
					dec = cp.$scale;
				}
				if (data && field && data.$properties && data.$properties[field]) {
					if (data.$properties[field].$format) dec = $helpers.format2decimals(data.$properties[field].$format);
					else if (data.$properties[field].$scale) dec = data.$properties[field].$scale;
				}
				value = $helpers.number2str(value, dec);
			}
			return value;
		} catch (e) {
			throw new Error('formatDecimal ' + field.$bind + '\n' + e.message);
		}
	};
	that.isExpression = function(strValue) {
		return (strValue.indexOf("{") >= 0);
	};
	that.updproto = function(proto, delta) {
		if (delta) {
			Object.keys(delta).forEach(function(pn) {
				if (typeof proto[pn] !== "object") proto[pn] = delta[pn];
			});
		}
	};
	that.sdataKey = {
		"workingCopies": "$workingCopies",
		"batch": "$batch",
		"batchGet": that.x3supportbatch ? "$batch" : "$batchGet"
	};
	that.exprData = function(data) {
		return new _exp(data);
	};
	that.getMetaValue = function(bind, data) {
		var cd = data;
		var res = null;
		if (cd) {
			cd.$properties = cd.$properties || {};
			res = cd.$properties;
			res[bind] = res[bind] || {};
			res = res[bind];
		}
		return res;
	};
	that.setDeleteMissing = function(proto, data) {
		Object.keys(proto.$properties).forEach(function(pn) {
			var pi = proto.$properties[pn];
			if (pi.$type === "application/x-array") {
				if ((pi.$item.$type === "application/json") || (pi.$item.$type === "application/x-object") || (pi.$item.$type === "application/x-reference")) {
					var meta = that.getMetaValue(pn, data);
					meta.$deleteMissing = true;
					var fields = data[pn];
					// recursive
					if (fields && fields.length) {
						fields.forEach(function(fd) {
							delete fd.$index;
							if (!fd.$uuid) fd.$uuid = $helpers.uuid();
							if (pi.$item.$type != "application/x-reference") that.setDeleteMissing(pi.$item, fd);
						});
					}
				}
			}
		});
	};

	that.defaultFilter = function(cp) {
		var res = "";
		if (cp && cp.$filters) {
			Object.keys(cp.$filters).forEach(function(fn) {
				if (cp.$filters[fn].$isDefault) res = fn;
			});
		}
		return res;
	};
	that.acceptSubLayout = function(cp) {
		if (cp.$type === "application/x-array") {
			if (cp.$item) {
				if (_basicTypes.indexOf(cp.$item).$type >= 0) return false;
			}
			return true;
		} else return false;

	};
	that.extractLinks = function(cp, proto, data, edit, pagedata) {
		var exclude = ["$lookup"];
		if (!cp) return null;
		var scan = (edit && $proto.support$actions) ? cp.$actions : cp.$links;
		if (!scan) return null;
		var links = [];
		Object.keys(scan).forEach(function(ln) {
			var lv = scan[ln];
			if (exclude.indexOf(ln) >= 0) return;
			if (true && (ln.charAt(0) === "$")) return; // filter std actions
			if (lv.$isHidden || lv.$isExcluded) return;
			if (edit && $proto.support$actions) {} else if (!lv.$url || !lv.$title) return;

			var method = lv.$method || (edit ? "POST" : "GET");
			method = method.toUpperCase();
			// if (edit && (method !== "POST")) return; // only services
			var cl = {
				name: ln
			};
			var ped = that.exprData(data);
			cl.method = method;
			var cn = ln.toLowerCase();
			if (pagedata && pagedata.$article && pagedata.$article && pagedata.$article.$menuicons && pagedata.$article.$menuicons[cn]) cn = pagedata.$article.$menuicons[cn];
			cl.icon = "service " + cn;

			cl.$url = lv.$url;
			cl.$title = lv.$shortTitle || lv.$title;
			if (!edit) cl.url = that.parseExpression(lv.$url, {
				data: ped,
				$prototype: proto
			}, "$url");
			cl.$title = that.parseExpression(lv.$title, {
				data: ped,
				$prototype: proto
			}, "$title");
			cl.$type = lv.$type;
			cl.$method = method;
			// Issue #2372 
			cl.$parameters = $.extend(true, {}, lv.$parameters);
			links.push(cl);
		});
		return (links.length ? links : null);
	};
	that.canAdd = function(arrayproto, arrayData) {
		var res = arrayproto.$capabilities && ((arrayproto.$capabilities.indexOf('append') >= 0) || (arrayproto.$capabilities.indexOf('insert') >= 0));
		if (res && arrayproto.$maxItems && (arrayData.length >= arrayproto.$maxItems)) res = false;
		return res;
	};
	that.canDel = function(arrayproto) {
		var res = arrayproto.$capabilities && (arrayproto.$capabilities.indexOf('delete') >= 0);
		return res;
	};

	that.htmlValue = function(data, proto, cp, field, value, options) {
		options = options || {};
		if (!options.useValue) value = data ? data[field.$bind] : "";
		var exprData = data ? that.exprData(data) : null;
		if ((cp.$isHidden || cp.$isExcluded) && !options.list) {
			return "";
		}
		if (value === null) value = "";
		switch (field.$type) {
			case "application/x-password":
			case "application/x-string":
				// no links for listview
				if (options.list) {
					if (cp.$format && value) {
						if (cp.$format === "$phone") return '<span class="s-m-phone">' + $helpers.htmlEncode(value) + '</span>';
					}
					return $helpers.htmlEncode(value);
				}
				if (cp.$format && value) {
					if (cp.$format === "$email") {
						return '<a data-role ="none" class="s-m-email"  href="mailto:' + value + '">' + $helpers.htmlEncode(value) + '</a>';
					} else if (cp.$format === "$phone") {
						return '<a class="s-m-phone" href="tel:' + value + '">' + $helpers.htmlEncode(value) + '</a>';
					}
				}
				return $helpers.htmlEncode(value);
			case "application/x-integer":
				if (value == null) value = "";
				return $helpers.htmlEncode(value + "");
			case "application/x-real":
				if (value == null) value = "";
				return $helpers.htmlEncode(value + "");
			case "application/x-decimal":
				value = that.formatDecimal(value, cp, data, field);
				if (value == null) value = "";
				return $helpers.htmlEncode(value + "");
			case "application/x-quantity":
				//ok
				value = that.formatDecimal(value, cp.$value, data, field);
				if (value == null) value = "";
				if (cp.$rprotoparent && cp.$rprotoparent.$properties[cp.$unit]) {
					if (data && data[cp.$unit] && data[cp.$unit].$symbol) {
						value = value + " " + data[cp.$unit].$symbol;
					}
				}

				return $helpers.htmlEncode(value + "");
			case "application/x-date":
				// todo
				if (value) {
					value = $scroller.formatDate($helpers.dateSettings.dateFormat, Date.parseISO8601(value));
				}
				return $helpers.htmlEncode(value + "");
			case "application/x-datetime":
				// todo
				if (value) value = $scroller.formatDate($helpers.dateSettings.dateFormat, Date.parseISO8601(value));
				return $helpers.htmlEncode(value || "");
			case "application/x-time":
				// todo
				if (value) {
					var tt = $helpers.Time.parse(value);
					value = tt.format(cp.$format);
				}
				return $helpers.htmlEncode(value || "");
			case "application/x-boolean":
				if (options.cssPrefix) {
					return {
						value: value
					};
				}
				var styles = options.styles;
				if (options.list) {
					if (styles && styles.indexOf("c") != -1) return '<center><div class="ui-checkbox" style="display:inline"><center class="ui-icon ui-icon-checkbox-' + (value ? "on" : "off") + '"> </center></div></center>';
					else return '<div class="ui-checkbox" style="display:inline"><center class="ui-icon ui-icon-checkbox-' + (value ? "on" : "off") + '"> </center></div>';
				} else {
					if (styles && styles.indexOf("c") != -1) return '<center><span class="ui-checkbox"><center class="ui-icon ui-icon-checkbox-' + (value ? "on" : "off") + '"> </center></span></center>';
					else return '<span class="ui-checkbox"><center class="ui-icon ui-icon-checkbox-' + (value ? "on" : "off") + '"> </center></span>';

				}

			case "application/x-choice":
				var enums = cp.$value.$enum;
				for (var i = 0, len = enums.length; i < len; i++)
				if (enums[i].$value == value) {
					var tt = $proto.execExpression(enums[i].$title, cp);
					if (options.cssPrefix) {
						return {
							value: value,
							title: $helpers.htmlEncode(tt)
						};
					}
					return $helpers.htmlEncode(tt);
				}
				break;
			case "image":
				if (value && proto) {
					if (value.$value) {
						return '<image class="s-image-detail" src="' + "data:" + (value.$contentType || "image/jpeg") + ";base64," + value.$value + '"/>';
					} else {
						var url = value.$url;
						if (!url && cp.$url) {
							url = that.parseExpression(cp.$url, {
								data: exprData,
								$prototype: cp
							}, "$url");
						}
						if (url) {
							var curl = url;
							if (that.isExpression(url)) {
								curl = that.parseExpression(url, {
									data: exprData,
									$prototype: proto
								}, "$url");
							}
							return '<image class="s-image-detail" src="' + curl + '"/>';
						} else if (value.$value) {
							return '<image class="s-image-detail" src="' + "data:" + (value.$contentType || "image/jpeg") + ";base64," + value.$value + '"/>';

						}
					}
				}
				break;
			default:
				break;

		}
		return null;
	};

	that.settings = {
		"CollapsibleLayout": {
			jmdata: function(root) {
				return {
					"data-mini": "false",
					"data-theme": "c",
					"data-content-theme": "d",
					"data-inset": "true",
					"data-expanded-icon": "arrow-u",
					"data-collapsed-icon": "arrow-d"
				};
			}
		},

		"CollapsibleSetsLayout": {
			jmdata: function() {
				return {
					"data-mini": "false",
					"data-theme": "a",
					"data-content-theme": "a",
					"data-inset": "true",
					"data-expanded-icon": "arrow-u",
					"data-collapsed-icon": "arrow-d"

				};
			}
		}
	};

	that.getArticle = function(data, bind) {
		var article = data.$article;
		if (article) return article;
		article = data.$prototype;
		return article.$article;
	};
	that.extractFirstProp = function(exp) {
		var res = exp;
		var i = res.indexOf("}");
		if (i >= 0) res = res.substring(0, i);
		i = res.indexOf("{");
		if (i >= 0) res = res.substring(i + 1);
		return res;
	};
	that.getProto = function(data, bind, onlyProp) {
		if (!data) return {};
		if (!bind) return data.$prototype || data.$;
		var proto = data.$prototype;
		if (proto && proto.$properties) proto = proto.$properties;
		else proto = data.$properties;
		if (proto) {
			proto = proto[bind];
			if (proto && !onlyProp) {
				switch (proto.$type) {
					case "application/x-array":
						proto = proto.$item;
						if (proto.$item) proto = proto.$item; // for x-reference and
						// x-object

						break;
					case "application/x-reference":
						if (proto.$item) proto = proto.$item;
						break;
					case "application/x-object":
						if (proto.$item) proto = proto.$item;
						break;
				}
			}
			return proto;
		} else return null;
	};
	that.linkParents = function(data, parent, path) {
		if (!data) return;
		var cd = data;
		var list = [];
		if (!cd.$protoparent) cd.$protoparent = parent;
		if (!cd.$rprotoparent) cd.$rprotoparent = parent;
		if (cd.$properties) {
			Object.keys(cd.$properties).forEach(function(property) {
				var pv = cd.$properties[property];
				switch (pv.$type) {
					case "application/x-array":
						pv.$protoparent = cd;
						pv.$rprotoparent = cd;
						pv.$item.$rtype = "application/x-array";
						pv.$item.$protoparent = pv;
						pv.$item.$rprotoparent = cd;
						var item = pv.$item;
						if (item && item.$item) {
							item = item.$item;
							item.$rprotoparent = cd;
							item.$protoparent = pv.$item;
							item.$rtype = "application/x-array";
						}
						list.push(item);
						break;
					case "application/x-reference":
						pv.$protoparent = cd;
						pv.$rprotoparent = cd;
						pv.$item.$protoparent = pv;
						pv.$item.$rprotoparent = cd;
						pv.$item.$rtype = "application/x-reference";
						pv.$item.$rvalue = property;
						//  Issue #2298 - For X3 ref fields $value gives the name of the field that used by X3 to return metadata and diagnoses
						if (pv.$item.$value) {
							var vals = pv.$item.$value.match(/{[^}]+}/g);
							if (vals && vals.length == 1) {
								// In X3 we expect only one param in $values -> "{CUR}"
								// v : must point to key of cd object - { $value:"{F1}", F1:"{F2}"} - F2 must be a field of cd parent
								var reg = /[{}]/g,
									f1 = vals[0].replace(reg, "").trim(),
									err = null;
								if (pv.$item[f1]) {
									var f2 = pv.$item[f1].replace(reg, "").trim();
									if (cd.$properties[f2]) {
										pv.$item.$rvalue = f2;
									} // else field not found in parent keep $rvalue = property
								} // else item  key not found keep $rvalue = property
								if (err) console.log("Reference Field [" + property + "] bar $value [" + err + "]");
							}
						}
						list.push(pv.$item);
						break;
					case "application/x-object":
						if (!pv.$item) return;
						pv.$protoparent = cd;
						pv.$rprotoparent = cd;
						pv.$item.$protoparent = pv;
						pv.$item.$rprotoparent = cd;
						list.push(pv.$item);
						pv.$item.$rtype = "application/x-object";
						break;
					default:
						{
							pv.$protoparent = cd;
							pv.$rprotoparent = cd;

						}
				}
			});
		}
		list.forEach(function(nd) {
			that.linkParents(nd, cd);
		});
	};
	that.useUuid = function(proto) {
		return (proto.$key === "{$uuid}");
	};
	// ok
	that.getRefFromValue = function(value, cp) {
		if (!value) return null;
		var cv = {};
		if (that.useUuid(cp)) {
			cv.$uuid = value.$uuid;
			cv.$key = value.$key || value.$uuid;
		}
		// additional propertiers (no expressions)
		Object.keys(cp.$properties).forEach(function(key) {
			cv[key] = value[key];
		});
		return cv;
	};
	that.setArrayRef = function(cv, cp, data, bind) {
		var isuuid = that.useUuid(cp);
		if (isuuid) return cv;
		var nd = {};
		Object.keys(cp.$properties).forEach(

		function(propName) {
			var pi = cp.$properties;
			if (pi.$isReadOnly) {
				if (cv) delete cv[propName];
				// don't propagate value to parent
				return;
			}

			// propagate value to parent
			var value = (cv ? cv[propName] : "") || "";
			var exp = cp[propName];
			if (!exp) exp = "{" + propName + "}"; // default expression
			if (!exp || (exp.charAt(0) != "{") || (exp.charAt(exp.length - 1) != "}")) {
				// don't propagate value to parent
				return;
			}
			if (cv) delete cv[propName];
			var realPropName = exp.substring(1, exp.length - 1);
			nd[realPropName] = value;

		});
		return nd;
	};
	that.formatValue = function(pi, value, params) {
		switch (pi.$type) {
			case "application/x-password":
			case "application/x-string":
				return value;
				break;
			case "application/x-decimal":
			case "application/x-real":
				return value;
				break;
			case "application/x-quantity":
				//ok
				return value;
				break;
			case "application/x-integer":
				return value;
				break;
			case "application/x-boolean":
				return value;
				break;
			case "application/x-date":
				return value;
				break;
			case "application/x-datetime":
				return value;
				break;
			case "application/x-time":
				return value;
				break;
			case "application/x-choice":
				return value;
				break;
		}
		return value;
	};
	that.proto2Value = function(pi, propName, res) {
		var d;
		switch (pi.$type) {
			case "application/x-password":
			case "application/x-string":
				res[propName] = "";
				break;
			case "application/x-quantity":
				//ok
				res[propName] = 0.0;
				break;
			case "application/x-decimal":
			case "application/x-real":
				res[propName] = 0.0;
				break;
			case "application/x-integer":
				res[propName] = 0;
				break;
			case "application/x-boolean":
				res[propName] = false;
				break;
			case "application/x-date":
				// d = new Date();
				// res[propName] = $helpers.date.checkString(d.toISOString());
				res[propName] = '';
				break;
			case "application/x-datetime":
				// d = new Date();
				// res[propName] = d.toISOString();
				res[propName] = '';
				break;
			case "application/x-time":
				// d = $helpers.Time.parse("00:00");
				// res[propName] = d.toISO();
				res[propName] = '';
				break;
			case "application/x-choice":
				res[propName] = pi.$value.$enum[0].$value;
				break;
		}
	};
	that.proto2Instance = function(cp) {
		var res = {
			$properties: {}
		};
		// $template for references
		Object.keys(cp.$properties).forEach(function(propName) {
			if (propName.charAt(0) === "$") return;
			that.proto2Value(cp.$properties[propName], propName, res);
			// issue #2465 - FDB - $edit facet returns the meta hidden/mandatory for the fields in $properties
			// --> in that case data are generate by js
			// --> we do the same here by copying meta from prototype to allow getProtoDataValue in smobile.js to return meta-data for the edit field
			res.$properties[propName] = $.extend({}, cp.$properties[propName]);
		});
		return res;
	};
	that.setRef = function(cv, cp, data, bind) {
		var isuuid = that.useUuid(cp);
		var topdata = data.data();
		if (isuuid) {
			// reference by uuid
			topdata[bind] = cv;
			return;
		}
		// reference by code(s)
		Object.keys(cp.$properties).forEach(

		function(propName) {
			var pi = cp.$properties;
			if (pi.$isReadOnly) {
				if (cv) delete cv[propName];
				// don't propagate value to parent
				return;
			}

			// propagate value to parent
			var value = (cv ? cv[propName] : "") || "";
			var exp = cp[propName];
			if (!exp) exp = "{" + propName + "}"; // default expression
			if ((exp.charAt(0) != "{") || (exp.charAt(exp.length - 1) != "}")) {
				// constant expression ?
				return;
			}
			if (cv) delete cv[propName];
			var realPropName = exp.substring(1, exp.length - 1);
			if (cp.$rprotoparent.$properties[realPropName]) {
				topdata[realPropName] = value;
			}
		});
		if (!cv) {
			delete topdata[bind];
		} else {
			if (Object.keys(cv).length) topdata[bind] = cv;
		}
	};
	// for
	that._protoProp = function(proto, prop) {
		if (prop === "$baseUrl") return {
			value: $helpers.baseUrl(),
			found: true,
			stop: true
		};
		var p = proto;
		if (prop.charAt(0) == "@") {
			while (p) {
				if (p && p.$localization && p.$localization.hasOwnProperty(prop)) return {
					value: p.$localization[prop],
					found: true,
					stop: true
				};
				p = p.$rprotoparent;
			}
		} else {
			while (p) {
				if (p.hasOwnProperty(prop)) return {
					value: p[prop],
					found: true
				};
				p = p.$protoparent;
			}
		}
		return {
			found: false
		};
	};
	that._dataProp = function(data, prop, proto) {
		if (prop === "$baseUrl") return {
			value: $helpers.baseUrl(),
			found: true,
			stop: true
		};
		var cd = data.data();
		while (cd) {
			if (cd.hasOwnProperty(prop)) {
				var pi = null;
				if (proto && proto.$properties && proto.$properties[prop]) {
					pi = proto.$properties[prop];
					//
				}
				return {
					value: cd[prop],
					found: true,
					pi: pi
				};
			}
			cd = data.parent(cd);
		}
		return {
			value: "",
			found: false
		};

	};

	that._formatOutValue = function(value, options, pi, data) {
		if (options.key) {
			return value;
		} else if (options.html) {
			if (pi) {
				if (options && options.list && (pi.$type === "application/x-reference")) {
					if (!value) value = null;
					data.add(value);
					value = $proto.parseExpression(pi.$item.$value, {
						data: data,
						$prototype: pi.$item
					}, "$value");
					data.pop();
					if (!value) value = "";
					return $helpers.htmlEncode(value + "");
				}
				return that.htmlValue(null, null, pi, {
					$type: pi.$type
				}, value, {
					useValue: true,
					list: options.list,
					cssPrefix: options.cssPrefix
				});
			} else return $helpers.htmlEncode(value + "");

		} else if (options.url) {
			return value;
		} else return value;
	};
	/*
	 * options html --> out html onlyValue --> out value url --> out in url
	 * keepBrackets --> if true keep {propNonFound} else ""
	 */
	that.execExpression = function(expression, proto, data, level, options) {
		options = options || {};
		level = level || 0;

		expression = (expression || "") + "";
		if (!level) {
			if (expression.indexOf("{") < 0) {
				if (data) {
					var value = that._dataProp(data, expression, proto);
					if (value.found) {
						// Fix false value which was transformed to ""
						var vf = value.value == null ? "" : value.value;
						return that._formatOutValue(vf, options, value.pi,
						data);
					}
				}
			} else {
				if (options.html) {
					expression = $helpers.htmlEncode(expression);
				}

			}
		}
		var res = expression.replace(
			/\{(.*?)\}/g,

		function(match, prop) {
			var dvalue, pvalue, cv;
			if (!level && proto && !proto.noRef && proto.$protoparent && (proto.$protoparent.$type === "application/x-reference")) {
				pvalue = that._protoProp(proto, prop);
				if (!pvalue.found) {
					dvalue = data ? that._dataProp(data,
					prop, proto) : {
						found: false
					};
					if (!dvalue.found) {
						if ($helpers.trace.expressions) {
							$helpers.log(expression);
							$helpers.log("Not found:" + prop);
							$helpers.log("----------------------------------");
						};
					}
					cv = dvalue.value || "";
					return that._formatOutValue(cv,
					options, dvalue.pi, data);
				} else {
					if (pvalue.stop) {
						cv = pvalue.value || "";;
						return that._formatOutValue(cv,
						options, null, null);

					}
					if (pvalue.value.indexOf("{") >= 0) {
						var cp = proto;
						if (pvalue.value.indexOf("{" + prop + "}") >= 0) {
							cp = proto.$protoparent;
						}
						if (options.html) {
							pvalue.value = $helpers.htmlEncode(pvalue.value);
						}
						return that.execExpression(
						pvalue.value, cp, data,
						level + 1, options);
					} else {
						dvalue = data ? that._dataProp(
						data, prop, proto) : {
							found: false
						};
						if (!dvalue.found) {
							if ($helpers.trace.expressions) {
								$helpers.log(expression);
								$helpers.log("Not found:" + prop);
								$helpers.log("----------------------------------");
							}
						}
						cv = dvalue.value || "";
						return that._formatOutValue(cv,
						options, dvalue.pi, data);
					}
				}
			} else {
				dvalue = data ? that._dataProp(data, prop,
				proto) : {
					found: false
				};
				if (dvalue.found) {
					cv = dvalue.value || "";
					return that._formatOutValue(cv,
					options, dvalue.pi, data);
				}
				pvalue = (proto ? that._protoProp(proto,
				prop) : {
					found: false
				});
				if (!pvalue.found) {
					if ($helpers.trace.expressions) {
						$helpers.log(expression);
						$helpers.log("Not found:" + prop);
						$helpers.log("----------------------------------");
					}
					cv = "";
					if (options.keepBrackets) cv = "{" + prop + "}";
					return that._formatOutValue(cv,
					options, null, null);
				}
				if (pvalue.stop) {
					cv = pvalue.value || "";
					return that._formatOutValue(cv,
					options, null, null);
				}
				if (pvalue.value.indexOf("{") >= 0) {
					if (options.html) {
						pvalue.value = $helpers.htmlEncode(pvalue.value);
					}
					return that.execExpression(
					pvalue.value, proto, data,
					level + 1, options);
				}
				cv = pvalue.value || "";
				return that._formatOutValue(cv, options,
				null, null);
			}
		});
		return res || "";
	};
	that.parseExpression = function(expression, data, propName, options) {
		if (!options) {
			options = {};
			options.url = (propName === "$url");
			options.key = (propName === "$url") || (propName === "$key");
		}

		return that.execExpression(expression, data.$prototype, data.data,
		0, options);
	};

	var _canGroup = function(element) {
		return (_basicTypes.indexOf(element.$type) >= 0) || (element.$type === "application/x-reference");
	};
	that.uiCanGroupField = _canGroup;
	that.jqmDataArray = function() {
		return {
			"data-inset": "true",
			"data-mini": "true",
			"data-theme": "d",
			"data-divider-theme": "e"
		};
	};
})(jQuery);

(function($) {
	var that = $.helpers || {};
	$.helpers = that;
	var $scroller = $.scroller;
	that.trace = {
		expressions: false,
		sdata: false,
		ajax: false
	};
	that.log = function(msg) {
		window.console.log(msg);
	};
	that.baseUrl = function() {
		return "";
	}; // overloaded in $.sdata
	that.getTarget = function(e, tags) {
		tags = tags || ['BUTTON', 'A'];
		if (!e) return null;
		var target = e.target,
			p;
		while (target && target.tagName && (tags.indexOf(target.tagName) < 0)) {
			p = $(target).attr("data-action");
			if (p) break;
			target = target.parentNode;
		}
		return target;
	};
	var _msgType = ["success", "info", "warning", "error", "fatal"];
	var consts = {
		normal_icon: "s-m-icon-space",
		normal_icon_size: "s-m-icon-size",
		normal_image_list: "s-m-image-list",
		normal_noimage: "s-m-noimage",

		panel_icon: "s-m-panel-space",
		panel_icon_size: "s-m-panel-size",
		default_panel_name: "sage.default",
		default_panel_class: "sage",

		menu_icon: "s-m-menu-space",
		menu_icon_size: "s-m-menu-size",

		default_menu_name: "sage.empty",
		default_menu_class: "sage",

		default_icon_name: "sage.empty",
		default_icon_class: "sage"
	};
	that.ui = that.ui || {};
	that.ui.consts = consts;

	// 
	that.cleanUp = function(obj, norecursive, done) {
		var done = done || [];
		var keys = Object.keys(obj);
		keys.forEach(function(p) {
			var o = obj[p];
			if (o && (typeof o === "object") && !Array.isArray(o) && !norecursive) {
				if (done.indexOf(o) == -1) {
					done.push(o);
					that.cleanUp(o, false, done);
				}
			}
			obj[p] = null;
		});
	};

	that.alert = function(message, after, debug) {
		if (!debug) return after();
		if (navigator.notification && navigator.notification.alert) navigator.notification.alert(message, after);
		else {
			alert(message);
			after();
		}

	};
	var _compat = function() {
		if (!Array.isArray) Array.isArray = function(arg) {
			return ((arg != null) && (arg.splice != null));
		};
		if (!Function.prototype.bind) {
			Function.prototype.bind = function(oThis) {
				if (typeof this !== "function") {
					// closest thing possible to the ECMAScript 5 internal
					// IsCallable function
					throw new TypeError(
						"Function.prototype.bind - what is trying to be bound is not callable");
				}

				var aArgs = Array.prototype.slice.call(arguments, 1),
					fToBind = this,
					fNOP = function() {}, fBound = function() {
						return fToBind.apply(this instanceof fNOP ? this : oThis || window, aArgs.concat(Array.prototype.slice.call(arguments)));
					};

				fNOP.prototype = this.prototype;
				fBound.prototype = new fNOP();

				return fBound;
			};
		}
		if (!Object.keys) Object.keys = function(o) {
			if (o !== Object(o)) throw new TypeError('Object.keys called on non-object');
			var ret = [],
				p;
			for (p in o)
			if (Object.prototype.hasOwnProperty.call(o, p)) ret.push(p);
			return ret;
		};
		//  Issue #2371  - same code as Desktop
		Date.parseISO8601 = function(str) {
			var year = 0,
				month = 0,
				day = 0,
				hours = 0,
				minutes = 0,
				seconds = 0,
				ms = 0,
				offset = 0,
				convertError = true;
			var d = /(\d{4})-(\d{2})-(\d{2})([T\s]?)(\d{2})?(:)?(\d{2})?(:)?(\d{2})?(\.(\d{3}))?(Z)?(([+-])(\d{2}))?(.*$)/.exec(str);
			if (d) {
				convertError = false;
				year = +d[1];
				month = d[2] - 1;
				day = +d[3];
				hours = +(d[5] || 0);
				minutes = +(d[7] || 0);
				seconds = +(d[9] || 0);
				ms = +(d[11] || 0);
				if (d[12] === "Z") {
					if (d[14] === '-') offset = (d[15] || 0) * 60;
					else if (d[14] === '+') offset = -(d[15] || 0) * 60;
					var utc = Date.UTC(year, month, day, hours, minutes + offset, seconds, ms);
					return new Date(utc);
				} else {
					return new Date(year, month, day, hours, minutes + offset, seconds, ms);
				}
			}
			if (convertError) throw new Error("cannot parse date: " + str);
		};
	};
	_compat();
	that.online = function() {
		if (navigator.onLine === false) return false;
		return true;
	};
	that.AutomaticSendBatch = function() {
		return true;
	};
	that.extend = function(proto, object) {
		for (var p in object)
		proto[p] = object[p];
	};
	var _errors = {
		http: 1,
		db: 2,
		exception: 3,
		sdata: 4,
		error: 5,
		warning: 6,
		info: 7,
		success: 8,
		fatal: 9
	};
	var _errKeys = [_errors.success, _errors.info, _errors.warning,
	_errors.error, _errors.fatal];

	that.slashAtEnd = function(url) {
		if (url && (url.charAt(url.length - 1) != "/")) url = url + "/";
		return url;
	};
	that.displayDateFormat = "YYYY-MM-DD";
	that.http = {
		parseCookie: function(cookie) {
			var cookies = cookie || "";
			var res = {};
			cookies.split(";").forEach(function(cookie) {
				var parts = cookie.split("=");
				if ((parts.length >= 2) && parts[0] && parts[1]) {
					res[parts[0].trim()] = parts[1].trim();
				}
			});
			return res;
		},
		setCookie: function(name, value, path, expireDate) {
			if (!value && (value == "")) expireDate = new Date();
			try {
				window.document.cookie = name + "=" + value + ((expireDate != null) ? ("; expires=" + expireDate.toGMTString()) : "") + (path ? ("; path=" + path) : "/");
			} catch (e) {}
		}
	};
	that._extractDiag = function(data, prop, res, type) {
		var $d = data.$diagnoses,
			count = 0;
		var s = type ? Array.isArray(type) ? type : [type] : _msgType;
		$d.forEach(function(d) {
			d = that._checkDiag(d);
			if (s.indexOf(d.severity) >= 0) {
				res.errors = res.errors || [];
				count++;
				res.errors.push({
					propName: prop,
					message: d.message,
					severity: d.severity,
					stackTrace: d["$stackTrace"]
				});
				if (res.defMsg) {
					res.defMsg = false;
					res.message = (prop ? (prop + ": ") : "") + d.message;
				}
			}
		});
		return count;
	};

	that.dataReadErrors = function(data, defaultMsg, root, path, res, type) {
		if (root == null) root = true;
		res = res || {
			message: defaultMsg || "",
			defMsg: true,
			errors: [],
			nbFieldErrors: 0
		};
		if (!data) return res;
		var o = {};
		if (data.$diagnoses && data.$diagnoses.length) that._extractDiag(data, path, res, type);
		if (data.$properties) {
			var o = {};
			Object.keys(data.$properties).forEach(function(pn) {
				var o = data.$properties[pn];
				if (o.$diagnoses && o.$diagnoses.length) {
					res.nbFieldErrors += that._extractDiag(o, path ? (path + '.' + pn) : pn, res, type);
				}
			});
		}


		if (data.$actions) {
			var o = {};
			Object.keys(data.$actions).forEach(

			function(pn) {
				var o = data.$actions[pn];
				if (o.$diagnoses && o.$diagnoses.length) {
					that._extractDiag(o, path ? (path + '.' + pn) : pn, res, type);
				}
			});
		}
		Object.keys(data).forEach(

		function(pn) {
			if (pn.charAt(0) === "$") return;
			var o = data[pn];
			if (Array.isArray(o)) {
				for (var i = 0, len = o.length; i < len; i++) {
					var co = o[i];
					if (typeof co === "object") {
						that.dataReadErrors(co, "", false, path ? (path + '.' + pn + '[' + i + ']') : pn,
						res, type);
					}
				}
			} else if (typeof o === "object") {
				that.dataReadErrors(o, "", false,
				path ? (path + '.' + pn) : pn, res, type);
				//
			}
		});
		if (root) {
			res.onlyFieldsErrors = res.nbFieldErrors > 0 && res.nbFieldErrors == res.errors.length;
		}
		return res;

	};

	that._extractAll = function(data, defaultMsg) {
		var res = that.dataReadErrors(data, defaultMsg || "", true, "", null, null);
		if (res && res.errors && res.errors.length > 0) {
			that._sortDiagnoses(res.errors);
			res.errors.forEach(function(d) {
				if (d.severity == "error") {
					that.pushException(d);
				} else if (d.severity == "fatal") {
					that._pushMsgItem({
						title: that.locale().ui.app_fatal,
						type: _errors.fatal,
						data: {
							message: d.message,
							stackTrace: d.stackTrace
						}
					});
				} else if (d.severity == "warning") {
					that._pushMsgItem({
						title: d.message,
						type: _errors.warning,
						data: {
							message: d.stackTrace
						}
					});
				} else {
					that._pushMsgItem({
						title: d.message,
						type: d.severity == "success" ? _errors.success : _errors.info
					});
				}
			});
		}
		return res;
	};
	that.format = function(value, params) {
		value = value ? value.replace(/\{([0-9]\})*/g, function($0, $1, $2) {
			return params[parseInt($1)];
		}) : "No resource found";
		return value;

	};
	that.uuid = function() {
		return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,

		function(c) {
			var r = Math.random() * 16 | 0,
				v = c == 'x' ? r : (r & 0x3 | 0x8);
			return v.toString(16);
		});
	};
	that.incId = function() {
		if (!that._iid) that._iid = 0;
		that._iid++;
		return (that._iid + "");
	};

	that.htmlEncode = function(value) {
		return $('<div/>').text(value).html();
	};
	that.htmlDecode = function(value) {
		return $('<div/>').html(value).text();
	};

	// remove
	that.ERRORS = _errors;

	that.pushDiagnoses = function(cd) {
		if (cd) {
			// FDB - Display all Errors/Warning/info
			var res = that._extractAll(cd);
			return res && res.errors && res.errors.length > 0;
		}
		return false;
	};
	that._checkDiag = function(d) {
		var x = d.severity || d["$severity"];
		if (!x || _msgType.indexOf(x) == -1) x = "info";
		d.severity = d["$severity"] = x;
		x = d.message || d["$message"];
		if (!x) x = "no message";
		d.message = d["$message"] = x;
		return d;
	};
	that._sortDiagnoses = function(diag) {
		if (!diag) return [];
		diag.forEach(function(d) {
			that._checkDiag(d);
		});
		return diag.sort(function(a, b) {
			return _msgType.indexOf(b) - _msgType.indexOf(a);
		});
	};
	that.pushAjaxError = function(jqXHR, textStatus, errorThrown, url,
	method) {
		var errorThrown = errorThrown ? errorThrown.message ? errorThrown.message : errorThrown.toString() : null;
		method = method || "GET";
		var diag = null;
		if (jqXHR.status === 0) {
			// offline
			return that.pushError({
				origin: _errors.exception,
				title: that.locale().ui.exception_offline,
				data: {
					message: that.locale().ui.check_net
				}
			});
		} else if (textStatus === 'timeout') {
			return that.pushError({
				origin: _errors.exception,
				title: that.locale().ui.exception_timeout,
				data: {
					message: that.locale().ui.check_net
				}
			});
		}
		if (jqXHR.responseText) {
			if (jqXHR.responseText.indexOf("$diagnoses") > 0) {
				try {
					diag = JSON.parse(jqXHR.responseText);
				} catch (ex) {}
			}
			if (!diag) {
				var err = errorThrown ? errorThrown : "Http " + (method ? method + " method" : "") + " error - Status=" + jqXHR.status;
				diag = {
					"$diagnoses": [that._checkDiag({
						"$severity": "error",
						"$message": err,
						"$stackTrace": (url ? "URL : " + url + "\n" : "") + jqXHR.responseText
					})]
				};
			}
		}
		// 200/201 - Application error with message returned by backoffice
		var userMsg = null;
		var detail = "METHOD : " + method + " - STATUS : " + jqXHR.status + "\n" + url;
		if (diag && diag.$diagnoses && diag.$diagnoses.length) {
			var x = that._sortDiagnoses(diag.$diagnoses);
			if (userMsg == null) {
				userMsg = x[0].message.split('\n');
				var stack = x[0]["$stackTrace"];
				if (stack) {
					var p = stack.indexOf("<<< async stack >>>");
					if (p > 0) stack = stack.substring(0, p);
				}
				if (userMsg.length > 1) {
					// Copy lines except first one to stack
					stack = userMsg.join('\n');
				}
				// We just display first line
				userMsg = userMsg[0];
				if (stack) detail += "\nDETAIL\n" + stack;
			}
			for (var i = 1; i < x.length; i++) {
				var m = x[i];
				detail += "\n\nNEXT ERROR:\n" + m.message;
				if (m["$stackTrace"]) detail += "\nDETAIL\n" + m["$stackTrace"];
			};
		} else if (errorThrown) {
			if (userMsg == null) userMsg = errorThrown;
			else detail += "\n" + errorThrown;
		} else if (jqXHR.statusText) {
			if (userMsg == null) userMsg = jqXHR.statusTex;
			else detail += "\n" + jqXHR.statusTex;
		}
		if (userMsg == null) userMsg = that.locale().ui.unknownError;
		that.pushError({
			origin: _errors.http,
			title: userMsg,
			data: {
				message: detail
			}
		});
	};
	that._errkey = function(type) {
		return "mobile_" + (_errors.success == type ? "success" : _errors.info == type ? "infos" : _errors.warning == type ? "warnings" : _errors.fatal == type ? "fatal" : "errors");
	};
	that._localStorage = true;
	try {
		if (!window.sessionStorage) that._localStorage = false;
	} catch (ex) {
		that._localStorage = false;
	}

	that._pushMsgItem = function(error) {
		if (!error) return;
		if (error.type == null) error.type = _errors.error;
		var key = that._errkey(error.type);
		if (that._localStorage) {
			var errors = window.sessionStorage.getItem(key);
			errors = errors ? JSON.parse(errors) : [];
			errors.push(error);
			window.sessionStorage.setItem(key, JSON.stringify(errors));
		} else {
			if (!that[key]) that[key] = [];
			that[key].push(error);
		}
	};
	that._hasMsgItem = function(type) {
		var key = that._errkey(type);
		if (that._localStorage) {
			var errors = window.sessionStorage.getItem(key);
			if (errors) {
				errors = JSON.parse(errors);
				return (errors.length > 0);
			}
			return false;
		} else return (that[key] && that[key].length);
	};

	that._clearAllMsgItems = function(type) {
		_errKeys.forEach(function(typ) {
			var key = that._errkey(typ);
			if (that._localStorage) window.sessionStorage.removeItem(key);
			else delete that[key];
		});
	};

	that._clearAllInfoItems = function() {
		[_errors.success, _errors.info, _errors.warning].forEach(function(typ) {
			var key = that._errkey(typ);
			if (that._localStorage) window.sessionStorage.removeItem(key);
			else delete that[key];
		});
	};

	that._lastMsgItem = function(type) {
		var key = that._errkey(type);
		if (that._localStorage) {
			var errors = window.sessionStorage.getItem(key);
			if (errors) return JSON.parse(errors);
			return null;
		} else return that[key];
	};
	// Stores fields errors in edit mode
	var _fieldsErrors = false;
	that.pushFieldsErrors = function() {
		_fieldsErrors = true;
	};
	that.hasFieldsErrors = function() {
		return _fieldsErrors === true;
	};
	that._rmvFieldsErrors = function() {
		_fieldsErrors = false;
	};
	that.pushError = function(error) {
		if (error == null) return;
		if (typeof error == "string") error = {
			title: error
		};
		error.type = _errors.error;
		that._pushMsgItem(error);
	};
	that.pushInfo = function(msg) {
		var error = {
			title: msg
		};
		error.type = _errors.info;
		that._pushMsgItem(error);
	};
	that.hasErrors = function() {
		return that._hasMsgItem(_errors.error) || that._hasMsgItem(_errors.fatal);
	};
	that.hasMessages = function() {
		var i = _errKeys.length;
		while (i--) {
			var tt = _errKeys[i];
			if (that._hasMsgItem(tt)) return true;
		}
		return false;
	},
	that.clearErrors = function() {
		that._rmvFieldsErrors();
		that._clearAllMsgItems();
	};
	that.clearInfos = function() {
		that._clearAllInfoItems();
	};
	that.lastErrors = function() {
		var res = that._lastMsgItem(_errors.fatal);
		var errors = that._lastMsgItem(_errors.error);
		if (errors) {
			if (!res) return errors;
			res.push.apply(res, errors);
		}
		return res;
	};
	that.pushdbError = function(ex) {
		if (ex) that.pushError({
			origin: _errors.db,
			title: that.locale().ui.db_exception,
			data: {
				message: ex.message,
				stackTrace: ex.stackTrace
			}
		});
	},
	that.pushException = function(ex, solution) {
		that.pushError({
			origin: _errors.exception,
			title: that.locale().ui.app_exception,
			data: {
				message: ex.message,
				solution: solution,
				stackTrace: ex.stackTrace
			}
		});

	};
	that.hasWarnings = function() {
		return that._hasMsgItem(_errors.warning);
	};
	that.allMessages = function() {
		var res = [],
			msgs = that.lastErrors();
		if (msgs) res.push.apply(res, msgs);
		msgs = that._lastMsgItem(_errors.warning);
		if (msgs) res.push.apply(res, msgs);
		msgs = that._lastMsgItem(_errors.info);
		if (msgs) res.push.apply(res, msgs);
		msgs = that._lastMsgItem(_errors.success);
		if (msgs) res.push.apply(res, msgs);
		return res;
	};
	that.each = function(array, fn, next, parallel) {
		array = array || [];
		if (!array.length) return next();
		if (next == null) {
			return array.forEach(fn);
		}
		parallel = parallel || 1;
		var pending = 0;
		var i = 0,
			len = array.length;
		(function advance() {
			if (i == len && !pending) return next();
			while (i < len && pending < parallel) {
				pending++;
				var j = i++;
				fn(array[j], j, function() {
					pending--;
					advance();
				});
			}
		})();
	};

	that.forEachKey = function(object, body, next, parallel) {
		if (next) {
			if (object == null) return next();
			return that.each(Object.keys(object), function(key, i, next) {
				return body(key, object[key], next);
			}, next, parallel);
		} else {
			for (var key in object)
			body(key, object[key]);
		}
	};

	that.sdataURL2key = function(uri) {
		var match = /^.*\(\'(.*)\'\)$/.exec(uri);
		if (match && (match.length == 2)) return match[1];
		return "";
	};
	that.applySDataSort = function(sort, res) {
		var sh = null;
		if (sort.length === 1) {
			sh = function(a, b) {
				var so = sort[0],
					v1 = a[so.name],
					v2 = b[so.name];
				if (v1 === v2) return 0;
				if (v1 > v2) return (so.asc ? 1 : -1);
				return (so.asc ? -1 : 1);
			};

		} else {
			sh = function(a, b) {
				var v1, v2;
				for (var i = 0, len = sort.length; i < len; i++) {
					var so = sort[i];
					v1 = a[so.name];
					v2 = b[so.name];
					if (v1 == v2) continue;
					if (v1 > v2) {

						return (so.asc ? 1 : -1);
					} else {
						return (so.asc ? -1 : 1);
					}
				}
				return 0;
			};
		}
		res.sort(sh);
	};
	/**
	 * @param {{jmdata:
	 *            Object}} options
	 */

	that.addJqmData = function(options, html, filter, inline, inlinePrefix) {
		if (options.jmdata) Object.keys(options.jmdata)
			.forEach(

		function(name) {
			if (filter && (filter.indexOf(name) < 0)) return;
			var value = options.jmdata[name];
			var qu = ((options.jmdata == "true") || (options.jmdata == "false")) ? "" : "\"";
			if (inline) html.push(' ' + inlinePrefix + value);
			else html.push(' ' + name + '=' + qu + value + qu);
		});
	};
	that.encodeURIComponent = function(query) {
		return encodeURIComponent(query).replace(/\'/g, '%27');

	};
	that.decodeURIComponent = function(query) {
		return decodeURIComponent(query).replace(/\%27'/g, '\'');

	};

	that.encodeJsmQuery = function(query) {
		return that.encodeURIComponent(query);

	};
	that.decodeJsmQuery = function(query) {
		if (query.indexOf("=") > 0) return query;
		return decodeURIComponent(query);
	};
	that.hashFirst = function() {
		return true;
	};

	/**
	 * @param {{orderBy:
	 *            string}} query
	 */
	that.sdataSort = function(query) {
		if (query && query.orderBy) {
			var orders = query.orderBy.split(',');
			orders.forEach(function(value, index) {
				value = value.trim();
				var s = value.split(' ');
				if (s.length == 2) {
					orders[index] = {
						name: s[0],
						asc: (s[1] != 'desc')
					};
				} else orders[index] = {
					name: value,
					asc: true
				};
			});
			return orders;
		}
		return null;
	};

	that.number = {
		decimalSep: '.',
		thousandSep: ' '
	};
	that.format2decimals = function(ff) {
		var d = ff.split(';');
		var dec = 0;
		d.forEach(function(f) {
			var i = f.indexOf(".");
			if (i >= 0) {
				var cd = f.length - i - 1;
				if (cd > dec) dec = cd;
			}
		});
		return dec;
	};
	var _numRegExp = /\B(?=(\d{3})+(?!\d))/g;
	that.number2str = function(value, decimals, prec) {
		if ("" == value || value == null) value = 0;
		if (!value.toFixed) {
			var v = parseFloat(value);
			if (isNaN(v)) {
				throw new Error("Not a number[" + value + "]");
			} else {
				value = v;
			}
		}
		value = value || 0;
		value = value.toFixed(decimals) + "";
		var values = value.split(".");
		values[0] = values[0].replace(_numRegExp, that.number.thousandSep);
		if (!decimals) return values[0];
		if (values.length < 2) values.push("");
		return values.join(that.number.decimalSep);
	};

	var _pad2 = function(i) {
		var res = "" + i;
		if (res.length == 1) res = "0" + res;
		return res;
	};
	that.date = {
		isoToDate: function(diso) {
			return Date.parseISO8601(diso);
		},
		dateMY: function(dd) {
			return that.messages.monthsOfYear[dd.getMonth()] + ' ' + dd.getFullYear();
		},
		dateMY2: function(mm, yyyy) {
			return that.messages.monthsOfYear[mm] + ' ' + yyyy;
		},
		dateym: function(dd) {
			return dd.getFullYear() + '-' + _pad2(dd.getMonth() + 1);
		},
		str2dateym: function(value) {
			var dd = that.date.isoToDate(value);
			return dd.getFullYear() + '-' + _pad2(dd.getMonth() + 1);
		},
		str2dateYM: function(value) {
			var dd = that.date.isoToDate(value);
			return that.date.dateMY(dd);
		},

		dateTimeToLocalDate: function(dd) {
			return dd.getFullYear() + '-' + _pad2(dd.getMonth() + 1) + '-' + _pad2(dd.getDate());
		},
		checkString: function(val, orig) {
			if (!orig) return val.substring(0, 10);
			try {
				var cv = val.substring(0, 10);
				var ov = orig.substring(0, 10);
				if (ov == cv) return orig;
				return cv;
			} catch (ex) {
				return orig;
			}
		},
		toString: function(val) {
			var res = $scroller.formatDate(that.dateSettings.dateFormat + "  " + that.dateSettings.timeFormat, val);
			return res;
		}

	};
	// clone and take into account references to parent (like in mobile prototype $parent,$rparent)
	that.clone = function(deep, target, ref, done) {
		if (ref == null || typeof ref !== "object" || $.isFunction(ref)) return ref;
		if (target == null || typeof target !== "object" || $.isFunction(target)) target = {};
		var done = done || {
			copy: [],
			clone: []
		}, copyIsArray, name, src, idx, copy, clone;
		for (name in ref) {
			copy = ref[name];
			if (target === copy) continue;
			if (deep && copy && ($.isPlainObject(copy) || (copyIsArray = $.isArray(copy)))) {
				idx = done.copy.indexOf(copy);
				if (idx === -1) {
					src = target[name];
					if (copyIsArray) {
						copyIsArray = false;
						clone = src && $.isArray(src) ? src : [];
					} else {
						clone = src && $.isPlainObject(src) ? src : {};
					}
					done.copy.push(copy);
					done.clone.push(clone);
					target[name] = that.clone(deep, clone, copy, done);
				} else {
					target[name] = done.clone[idx];
				}
			} else if (copy !== undefined) {
				target[name] = copy;
			}
		}
		return target;
	};

})(jQuery);

(function($) {
	var that = $.helpers || {};
	$.helpers = that;
	var $scroller = $.scroller;
	that.Time = function(value) {
		value = (value + 86400 * 365 * 10000) % 86400;
		this._value = value;
	};
	var _pad2 = function(val) {
		var s = val.toString();
		return (s.length == 1) ? "0" + s : s;
	};

	that.Time.prototype = {
		hour: function() {
			return Math.floor(this._value / 3600);
		},
		minute: function() {
			return Math.floor(this._value / 60) % 60;
		},
		second: function() {
			return this._value % 60;
		},
		value: function() {
			return this._value;
		},
		toISO: function() {
			var self = this;
			return _pad2(self.hour()) + ":" + _pad2(self.minute()) + ":" + _pad2(self.second());
		},
		format: function($format) {
			var self = this;
			var hh = self.hour();
			var mm = self.minute();
			var sec = self.second();
			var format;
			//  Issue #2371 - TT -> long time format
			if ("TT" == $format && that.dateSettings.longTimeFormat) {
				format = that.dateSettings.longTimeFormat;
			} else if (that.dateSettings.timeFormat == null) {
				format = "HH:ii";
			} else {
				format = that.dateSettings.timeFormat;
			}
			var ms = mm + "",
				mms = _pad2(mm),
				ss = sec + "",
				sss = _pad2(sec);
			if (that.dateSettings.ampmText) {
				var ampm = "AM";
				if (hh >= 13) {
					hh = hh - 12;
					ampm = "PM";
				} else if (hh == 0) {
					//  Issue #2371 - 12:45 AM instead of 00:45 AM
					hh = 12;
				}
				return format.replace(/ii/, mms).replace(/i/, ms).replace(
					/ss/, sss).replace(/s/, ss).replace(/hh/, _pad2(hh))
					.replace(/h/, hh + "").replace(/A/, ampm);
			} else {
				return format.replace(/ii/, mms).replace(/i/, ms).replace(
					/ss/, sss).replace(/s/, ss).replace(/HH/, _pad2(hh))
					.replace(/H/, hh + "");
			}
		}
	};
	that.Time.parse = function(str) {
		str = str || "00:00";
		if (str.length != 5 && str.length != 8) throw new Error(
			"bad time format, expected hh:mm or hh:mm:ss, got " + str);
		var value = str.length == 8 ? parseInt(str.substring(0, 2), 10) * 3600 + parseInt(str.substring(3, 5), 10) * 60 + parseInt(str.substring(6.8), 10) : parseInt(str.substring(0, 2), 10) * 3600 + parseInt(str.substring(3, 5), 10) * 60;
		return new that.Time(value);
	};
	that.Time.parseTime = function(str) {
		var sd = $scroller.formatDate(that.dateSettings.dateFormat,
		new Date());
		var dd1 = $scroller.parseDate(that.dateSettings.dateFormat + ' ' + that.dateSettings.timeFormat, sd + ' ' + str);
		var dd2 = $scroller.parseDate(that.dateSettings.dateFormat + ' ' + that.dateSettings.timeFormat, sd + ' ' + new that.Time('00:00').format());
		var res = new that.Time((dd1 - dd2) / 1000);
		return res;
	};
	that.lang2DateSettings = function(shortDate, shortTime, longTime) {
		if (!longTime) longTime = shortTime;
		var date = new Date();
		that.dateSettings = that.dateSettings || {};
		that.dateSettings.ampmText = (that.locale().datetime.amDesignator || that.locale().datetime.pmDesignator) ? '&nbsp;' : '';
		if (shortDate) that.dateSettings.dateFormat = shortDate.toLowerCase(); // .replace(/yyyy/,'yy'),
		that.dateSettings.dateOrder = that.locale().datetime.dateElementOrder.replace(/m/, 'mm').replace(/y/, 'yy').replace(/d/, 'dd');
		that.dateSettings.dayNames = that.locale().datetime.dayNames;
		that.dateSettings.dayNamesShort = that.locale().datetime.abbreviatedDayNames;
		that.dateSettings.monthNames = that.locale().datetime.monthNames;
		that.dateSettings.monthNamesShort = that.locale().datetime.abbreviatedMonthNames;
		if (shortTime) that.dateSettings.timeFormat = shortTime.replace(/tt/g, 'A').replace(/m/g, 'i');
		if (longTime) that.dateSettings.longTimeFormat = longTime.replace(/tt/g, 'A').replace(/m/g, 'i');
		that.dateSettings.yearText = that.locale().datetime.year;
		that.dateSettings.monthText = that.locale().datetime.month;
		that.dateSettings.dayText = that.locale().datetime.day;
		that.dateSettings.minuteText = that.locale().datetime.minutes;
		that.dateSettings.hourText = that.locale().datetime.hour;
		that.dateSettings.secText = that.locale().datetime.seconds;
		that.dateSettings.endYear = date.getFullYear() + 20;
		if (that.dateSettings.ampmText) that.dateSettings.timeFormat = that.dateSettings.timeFormat.replace(/H/g, 'h');
		else that.dateSettings.timeFormat = that.dateSettings.timeFormat.replace(/h/g, 'H');
		that.dateSettings.timeWheels = that.dateSettings.timeFormat.replace(/:/g, '').replace(/ /g, '');
	};
	// Default date setting
	that.lang2DateSettings("M/d/yyyy", "h:mm tt", "h:mm:ss tt");
	if ($scroller) $scroller.setDefaults(that.dateSettings);
	that.authHeaders = null;
	that.addCustomHeaders = function(header, retry) {
		var lang = that.language();
		if (lang) header["Accept-Language"] = lang;
		if (that.authHeaders) return that.authHeaders(header, retry);
		return false;
		//
	};
})(jQuery);