"use strict";
(function($) {
	var $helpers = $.helpers;
	var that = $.sdata || {};
	$.sdata = that;
	var tokenType = {
		identifier: 'identifier',
		operator: 'operator',
		literal: 'literal'
	};
	that.tokenType = tokenType;
	(function($sdata) {
		/**
		 * @constructor
		 */
		function Operator(code, text, precedence, isPrefix, isInfix, isAssociative, isPredicate) {
			var self = this;
			self.code = code;
			self.text = text;
			self.precedence = precedence;
			self.isPrefix = isPrefix;
			self.isInfix = isInfix;
			self.isAssociative = isAssociative;
			self.isPredicate = isPredicate;
		}
		$helpers.extend(Operator.prototype, {
			toString: function() {
				return this.text;
			}
		});
		/**
		 * @constructor
		 */
		function Operators() {
			var self = this;
			self.operators = {};
			self.init();
		}
		$helpers.extend(Operators.prototype, {
			_createOp: function(code, text, precedence, isPrefix, isInfix, isAssociative, isPredicate) {
				var self = this;
				var op = new Operator(code || text, text, precedence, isPrefix, isInfix, isAssociative, isPredicate);
				self.operators[op.text] = op;
			},
			init: function() {
				var self = this;
				self._createOp(null, ".", 1, false, true, true, false);
				self._createOp(null, "not", 2, true, false, false, false);
				self._createOp("*", "mul", 3, false, true, true, false);
				self._createOp("/", "div", 3, false, true, true, false);
				self._createOp("%", "mod", 3, false, true, true, false);
				self._createOp(null, "+", 4, false, true, true, false);
				self._createOp(null, "-", 4, true, true, true, false);
				self._createOp("=", "eq", 5, false, true, false, true);
				self._createOp("<>", "ne", 5, false, true, false, true);
				self._createOp("<", "lt", 5, false, true, false, true);
				self._createOp("<=", "le", 5, false, true, false, true);
				self._createOp(">", "gt", 5, false, true, false, true);
				self._createOp(">=", "ge", 5, false, true, false, true);
				self._createOp(null, "between", 5, false, true, false, true);
				self._createOp(null, "in", 5, false, true, false, true);
				self._createOp(null, "like", 5, false, true, false, true);
				self._createOp(null, "like_s", 5, false, true, false, true);
				self._createOp(null, "and", 6, false, true, true, true);
				self._createOp(null, "or", 7, false, true, true, true);
				self._createOp(null, "(", 8, true, false, false, false);
				self._createOp(null, ")", 8, false, false, false, false);
				self._createOp(null, ",", 8, false, false, false, false);
			}
		});
		var operators = new Operators();
		/**
		 * @constructor
		 */
		function Token(type, line, offset, length, val) {
			var self = this;
			self.type = type;
			self.value = val;
			var _line = line;
			var _offset = offset;
			var _length = length;
			self.getRemainingText = function() {
				return _line.substring(_offset, _line.length);
			};
		}

		$helpers.extend(Token.prototype, {
			matches: function(code) {
				return this.value instanceof Operator && this.value.code == code;
			}
		});

		/**
		 * @constructor
		 */
		function _Tokenizer() {
			var self = this;

			function _skipSpaces(chars, i) {
				while (i < chars.length && chars[i] === " ") {
					i++;
				}
				return i;
			}

			function _isDigit(str) {
				return new RegExp('[0-9]').test(str);
			}

			function _isLetter(str) {
				return new RegExp('[a-zA-Z%\']').test(str);
			}

			function _isWordChar(str) {
				return new RegExp('[a-zA-Z0-9_%.%\']').test(str);
			}

			function _parseNumber(line, chars, i, tokens) {
				var end = i + 1,
					nt, cdt;
				while (end < chars.length && _isDigit(chars[end])) {
					end++;
				}
				var val;
				if (end < chars.length && chars[end] === '.') {
					end++;
					while (end < chars.length && _isDigit(chars[end])) {
						end++;
					}
					val = parseFloat(line.substring(i, end));
					cdt = "float";

				} else {
					val = parseInt(line.substring(i, end), 10);
					cdt = "int";
				}
				nt = new Token(tokenType.literal, line, i, end - i, val);
				nt.dataType = cdt;
				tokens.push(nt);
				return end;
			}

			function _parseWord(line, chars, i, tokens) {
				var end = i + 1,
					nt;
				while (end < chars.length && _isWordChar(chars[end])) {
					end++;
				}
				var word = chars.substr(i, end - i);
				var op = operators.operators[word.toLowerCase()];
				if (op != null) {
					tokens.push(new Token(tokenType.operator, line, i, end - i, op));
				} else {
					if (word === 'true' || word === 'false' || word === 'null') {
						nt = new Token(tokenType.literal, line, i, end - i, word);
						nt.dataType = "bool";
						tokens.push(nt);
					} else {
						nt = new Token(tokenType.identifier, line, i, end - i, word);
						nt.dataType = "word";
						tokens.push(nt);
					}
				}
				return end;
			}

			function _parseQuotedString(line, chars, i, tokens) {
				var quote = chars[i];
				var end = i + 1;
				var dest = 0;
				var res = "";
				while (end < chars.length) {
					if (chars[end] === quote) {
						end++;
						if (end === chars.length || chars[end] !== quote) {
							var nt = new Token(tokenType.literal, line, i, end - i, res);
							nt.dataType = "string";
							tokens.push(nt);
							return end;
						}
					}
					res += chars[end++];
				}
				throw new Error('Where parser: quoted string not terminated: ' + line.substring(i));
			}

			function _parseOperator(line, ch, i, tokens) {
				var op = operators.operators[ch];
				tokens.push(new Token(tokenType.operator, line, i, 1, op));
				return i + 1;
			}

			function _parseDateTime(line, chars, i, tokens) {
				var end = i + 1,
					len = chars.length;
				while (end < len) {
					if (chars[end] == '@') break;
					end++;
				}
				if (end === chars.length) {
					throw new Error('Where parser: date constant not terminated:' + line.substring(i, line.length));
				}
				var str = chars.substr(i + 1, end - i - 1);
				var dt = new Date(str);
				if (dt != null) {
					var nt = new Token(tokenType.literal, line, i, end + 1 - i, dt);
					nt.dataType = "datetime";
					nt.svalue = str;
					tokens.push(nt);
				}
				return end + 1;
			}

			self.tokenize = function(line) {
				var tokens = [];
				var i = 0;
				while (i < line.length) {
					i = _skipSpaces(line, i);
					var ch = line[i];
					switch (ch) {
						case '@':
							i = _parseDateTime(line, line, i, tokens);
							break;
						case '"':
						case '\'':
							i = _parseQuotedString(line, line, i, tokens);
							break;
							//case '.':
						case '-':
						case '+':
						case '(':
						case ')':
						case ',':
							i = _parseOperator(line, ch, i, tokens);
							break;
						default:
							if (_isLetter(ch)) {
								i = _parseWord(line, line, i, tokens);
							} else if (_isDigit(ch)) {
								i = _parseNumber(line, line, i, tokens);
							} else {
								throw new Error('Where parser: invalid character: "' + ch + '"');
							}
							break;
					}
				}

				return tokens;
			};

			return self;
		};
		var Tokenizer = new _Tokenizer();

		/**
		 * @constructor
		 */
		function Expression(config) {
			var self = this;
			self.children = null;
			if (config.operator) {
				self.type = "operator";
				self.value = config.operator;
				self.children = [];
				if (config.expression1) {
					self.children.push(config.expression1);
				}
				if (config.expression2) {
					self.children.push(config.expression2);
				}
			} else if (config.expressionType) {
				self.type = config.expressionType;
				self.value = config.value;
				self.svalue = config.svalue;
				self.dataType = config.dataType;
				if (self.type === "function") {
					self.children = [];
				}
			}
		};

		$helpers.extend(Expression.prototype, {
			isPredicate: function() {
				switch (this.type) {
					case "operator":
						return this.value.isPredicate;
					case "identifier":
						return true; // don't know
					case "function":
						return true; // don't know -- will improve later
					case "literal":
						return false;
					default:
						throw new Error("Where parser: invalid expression type: " + this.type);
				}
			},
			toString: function() {
				if (this.children == null) {
					return this.value.toString();
				}
				var sb = [];
				sb.push("[" + this.value.toString());
				for (var i = 0; i < this.children.length; i++) {
					sb.push(" " + this.children[i].toString());
				}
				sb.push("]");
				return sb.join('');
			}
		});

		/**
		 * @constructor
		 */
		function _Parser() {
			var self = this;
			var _maxPrecedence = 8;

			function _finishBetween(tokens, tokenIndex, exp, precedence) {
				if (tokenIndex[0] == tokens.length || !tokens[tokenIndex[0]].matches("and")) {
					throw new Error("Where parser: invalid expression: expected 'and' after " + tokens[tokenIndex[0] - 1].getRemainingText());
				}
				tokenIndex[0]++;
				var arg = _parseExpression(tokens, tokenIndex, precedence);
				exp.children.push(arg);
			}

			function _parseExpression(tokens, tokenIndex, precedence) {
				var exp = _parseTerm(tokens, tokenIndex);
				while (tokenIndex[0] < tokens.length) {
					var tk = tokens[tokenIndex[0]];
					var op = tk.value instanceof Operator ? tk.value : null;
					if (op == null || !op.isInfix || op.precedence > precedence) {
						break;
					}
					tokenIndex[0]++;
					if (op.code == "in") {
						if (tokenIndex[0] === tokens.length || !tokens[tokenIndex[0]].matches("(")) {
							throw new Error("Where parser: invalid expression: '(' expected after " + tk.getRemainingText());
						}
						tokenIndex[0]++;
						exp = new Expression({
							operator: op,
							expression1: exp
						});
						_parseArguments(tokens, tk, tokenIndex, exp.children);
					} else {
						var arg = _parseExpression(tokens, tokenIndex, op.precedence - 1);
						exp = new Expression({
							operator: op,
							expression1: exp,
							expression2: arg
						});
						if (op.code == "between") {
							_finishBetween(tokens, tokenIndex, exp, op.precedence);
						}
					}
					if (!op.isAssociative && op.precedence == precedence) {
						return exp;
					}
				}
				return exp;
			}

			function _parseTerm(tokens, tokenIndex) {
				if (tokenIndex[0] == tokens.length) {
					throw new Error("Where parser: premature end of expression");
				}
				var tk = tokens[tokenIndex[0]];
				switch (tk.type) {
					case tokenType.identifier:
						tokenIndex[0]++;
						if (tokenIndex[0] < tokens.length && tokens[tokenIndex[0]].matches("(")) {
							return _parseFunctionCall(tokens, tk, tokenIndex);
						} else {
							return new Expression({
								expressionType: "identifier",
								value: tk.value
							});
						}
					case tokenType.literal:
						tokenIndex[0]++;
						return new Expression({
							expressionType: "literal",
							value: tk.value,
							svalue: tk.svalue,
							dataType: tk.dataType
						});
					case tokenType.operator:
						var op = tk.value;
						if (!op.isPrefix) {
							throw new Error("Where parser: invalid expression: expected beginning of term at " + tk.getRemainingText());
						}
						tokenIndex[0]++;
						return _parsePrefixOperator(tokens, op, tokenIndex);
					default:
						throw new Error("Where parser: internal error: bad token type " + tk.type);
				}
			}

			function _parseArguments(tokens, tk, tokenIndex, args) {
				if (tokenIndex[0] < tokens.length && tokens[tokenIndex[0]].matches(")")) {
					tokenIndex[0]++;
					return;
				}
				while (tokenIndex[0] < tokens.length) {
					var arg = _parseExpression(tokens, tokenIndex, _maxPrecedence);
					args.push(arg);
					if (tokenIndex[0] < tokens.length && tokens[tokenIndex[0]].matches(")")) {
						tokenIndex[0]++;
						return;
					}
					if (tokenIndex[0] == tokens.length || !tokens[tokenIndex[0]].matches(",")) {
						throw new Error("Where parser:invalid expression: expected ',' or ')' at " + tokens[tokenIndex[0]].getRemainingText());
					}
					tokenIndex[0]++;
				}
				throw new Error("Where parser:invalid function call syntax: argument missing after " + tk.getRemainingText());
			}

			function _parsePrefixOperator(tokens, op, tokenIndex) {
				var arg1;
				switch (op.code) {
					case "-":
					case "not":
						arg1 = _parseExpression(tokens, tokenIndex, 1);
						return new Expression({
							operator: op,
							expression1: arg1
						});
					case "(":
						arg1 = _parseExpression(tokens, tokenIndex, op.precedence);
						//require('term').stream.print('???' + tokens[tokenIndex[0]].value);
						if (tokenIndex[0] == tokens.length || !tokens[tokenIndex[0]].matches(")")) {
							throw new Error("Where parser:invalid expression: expected ')' after " + tokens[tokenIndex[0] - 1].getRemainingText());
						}
						tokenIndex[0]++;
						return arg1;
					default:
						throw new Error("Where parser:internal error: bad prefix operator " + op.code);
				}
			}

			function _parseFunctionCall(tokens, tk, tokenIndex) {
				tokenIndex[0]++;
				var exp = new Expression({
					expressionType: "function",
					value: tk.value
				});
				_parseArguments(tokens, tk, tokenIndex, exp.children);
				return exp;
			}

			self.parse = function(str) {
				if (str == null || str.length == 0) {
					return null;
				}
				var tokens = Tokenizer.tokenize(str);
				var tokenIndex = [];
				tokenIndex[0] = 0;
				var exp = _parseExpression(tokens, tokenIndex, _maxPrecedence);
				if (tokenIndex[0] != tokens.length) {
					throw new Error("Where parser: invalid expression: unexpected token at " + tokens[tokenIndex[0]].getRemainingText());
				}
				return exp;
			};

			return self;
		};
		var Parser = new _Parser();
		$sdata.parseWhere = function(str) {
			return Parser.parse(str);
		};

		function _exec(data, exp, proto) {
			if (exp.type == "identifier") {
				exp.property = $.sdata.syncGetValue(data, exp.value);
				// issue #3744 in X3 boolean properties has numeric values  
				//and in the x3 filters (where clauses use numeric values 1(false)  and 2(true)  for boolean properties) 
				if (proto && proto.$properties && proto.$properties.$resources &&
					proto.$properties.$resources.$item &&
					proto.$properties.$resources.$item.$properties &&
					proto.$properties.$resources.$item.$properties[exp.value] &&
					proto.$properties.$resources.$item.$properties[exp.value].$type === "application/x-boolean") {
					if (exp.property == true)
						exp.property = 2;
					else
						exp.property = 1;
				}
			} else if (exp.type == "literal") {
				exp.property = (exp.dataType == "datetime") ? exp.svalue : exp.value;
			} else {
				if (exp.children) {
					var property = null;

					// propagate property from child to parent if operator if low level operator
					if (exp.type == "operator") {
						switch (exp.value.code) {

							case "and":
								exp.children.forEach(function(child) {
									_exec(data, child, proto);
								});
								exp.property = (exp.children[0].property && exp.children[1].property);
								break;
							case "or":
								exp.children.forEach(function(child) {
									_exec(data, child, proto);
								});
								exp.property = (exp.children[0].property || exp.children[1].property);
								break;
							case "between":
								exp.children.forEach(function(child) {
									_exec(data, child, proto);
								});
								exp.property = (exp.children[0].property >= exp.children[1].property) && (exp.children[0].property <= exp.children[2].property);
								break;
							case ">=":
								exp.children.forEach(function(child) {
									_exec(data, child, proto);
								});
								exp.property = (exp.children[0].property >= exp.children[1].property);
								break;
							case ">":
								exp.children.forEach(function(child) {
									_exec(data, child, proto);
								});
								exp.property = (exp.children[0].property > exp.children[1].property);
								break;
							case "<=":
								exp.children.forEach(function(child) {
									_exec(data, child, proto);
								});
								exp.property = (exp.children[0].property <= exp.children[1].property);
								break;
							case "<":
								exp.children.forEach(function(child) {
									_exec(data, child, proto);
								});
								exp.property = (exp.children[0].property < exp.children[1].property);
								break;
							case "like_s":
								exp.children.forEach(function(child) {
									_exec(data, child, proto);
								});
								exp.property = (exp.children[0].property.toUpperCase().indexOf(exp.children[1].property.toUpperCase()) === 0);
								break;
							case "like":
								exp.children.forEach(function(child) {
									_exec(data, child, proto);
								});
								var val = exp.children[1].property.toUpperCase().replace(/%/g, '');
								exp.property = (exp.children[0].property.toUpperCase().indexOf(val) >= 0);
								break;
							case "=":
								exp.children.forEach(function(child) {
									_exec(data, child, proto);
								});
								if (exp.children[0].property == "0000-00-00" && exp.children[1].dataType === "datetime") {
									exp.children[0].property = "";
								}
								if (exp.children[1].property == "0000-00-00" && exp.children[0].dataType === "datetime") {
									exp.children[1].property = "";
								}
								exp.property = (exp.children[0].property == exp.children[1].property);
								break;
							case "<>":
								exp.children.forEach(function(child) {
									_exec(data, child, proto);
								});
								if (exp.children[0].property == "0000-00-00" && exp.children[1].dataType === "datetime") {
									exp.children[0].property = "";
								}
								if (exp.children[1].property == "0000-00-00" && exp.children[0].dataType === "datetime") {
									exp.children[1].property = "";
								}
								exp.property = (exp.children[0].property != exp.children[1].property);
								break;
							case ".":
								_exec(data, exp.children[0], proto);
								_exec(exp.children[0].property, exp.children[1], proto);
								exp.property = exp.children[1].property;
								break;
							default:
								exp.property = property;
								// propagate to literals
								exp.children.forEach(function(child) {
									_exec(data, child, proto);
									if (child.type == "literal") child.property = property;
								});
						}
					} else if (exp.type == "function") {
						var args = [];
						if (exp.children) {
							exp.children.forEach(function(child) {
								_exec(data, child, proto);
								args.push(child.property);
							});
						}
						var hnd = $.sdata.getFunc(exp.value);
						if (hnd) exp.property = hnd.apply($.sdata, args);
					}
				}
			}
		};

		$sdata.execWhere = function(dataContext, exp, proto) {
			if (exp == null) return true;
			_exec(dataContext, exp, proto);
			return exp.property;
		};

	})(that);
})(jQuery);