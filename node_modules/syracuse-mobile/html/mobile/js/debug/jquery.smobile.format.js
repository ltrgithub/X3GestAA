"use strict";
/* 
 * TEMPORARY FORMATS LIBRARY
 * COPY FROM syracuse-x3\lib\formatter\format.js
 * PROVIDE alphanumeric and numeric format
 * See unit test in syracuse-mobile/html/tests/test-unit-x3formats.js
 * To remove once we will be able to use a shared/standalone library that dosn't use require and core libraries
 */
(function($) {
	if (!$.x3formats) $.x3formats = {};
	var exports = $.x3formats;

	function _isLower(ch) {
		return ch >= 'a' && ch <= 'z';
	}

	function _isUpper(ch) {
		return ch >= 'A' && ch <= 'Z';
	}

	function _isDigit(ch) {
		return ch >= '0' && ch <= '9';
	}

	function _isHexa(ch) {
		return (ch >= 'A' && ch <= 'F') || (ch >= '0' && ch <= '9');
	}

	var SP = ' '.charCodeAt(0);

	// VIREBLC engine functions
	var trimFuncs = exports.trimFuncs = [

		function(s) { // left
			var i, len = s.length;
			for (i = 0; i < len && s.charCodeAt(i) === SP; i++);
			return i === 0 ? s : s.substring(i);
		},
		function(s) { // right
			var i, len = s.length;
			for (i = len - 1; i >= 0 && s.charCodeAt(i) === SP; i--);
			return i === len ? s : s.substring(0, i + 1);
		},
		function(s) { // both
			var i, j, len = s.length;
			for (i = 0; i < len && s.charCodeAt(i) === SP; i++);
			for (j = len - 1; j >= i && s.charCodeAt(j) === SP; j--);
			return s.substring(i, j + 1);
		},
		function(s) { // token
			var i, j, len = s.length;
			for (i = 0; i < len && s.charCodeAt(i) === SP; i++);
			for (j = i; j < len && s.charCodeAt(j) !== SP; j++);
			return s.substring(i, j);
		},
		function(s) { // all
			return s.replace(/ /g, '');
		},
		function(s) { // adjacent
			return s.replace(/[ ]+/g, ' ');
		}
	];

	// FORMAT$ engine function
	function process(settings, fmt, val, parse) {
		var special = settings.ADXSCA || ['?', '?', settings.thousandSep || '', settings.decimalSep || '.', settings.badChar || '#', settings.fillChar || '*'];
		var options = {},
			fmtPos = 0,
			fmtChar, repeat, badChar = ' ',
			secretChar, fillChar, fmtLen = fmt.length,
			srcPos = 0,
			now, integ = "",
			lenIntg,
			decim = "",
			partStr, partNum = 0,
			numExtra = 0,
			// number of chars added to integral part
			valid = true,
			result = "",
			negative = false,
			dynTypes,
			badFormat = false;

		function _throwBadFormat(txt) {
			badFormat = true;
			throw new Error(txt ? txt : "Unexpected format character " + (fmtChar ? " [" + fmtChar + "] " : "") + "- Position[" + (srcPos - 1) + "] - Format='" + fmt + "'");
		}

		function _fmtInt(val, repeat, forbid0) {
			var s;
			if (val === 0 && forbid0 /* && options.Z*/ ) {
				s = '';
				while (repeat-- > 0) s += ' ';
				return s;
			}
			s = val.toString();
			while (s.length < repeat) s = "0" + s;
			return s;
		}

		function _mismatch(got, expected, ignore) {
			valid = false;
			if (!ignore) throw new Error("value does not match format: fmt: " + fmt + ": expected " + expected + ", got " + got + " at index " + srcPos + " in '" + val + "'");
		}

		function formatChar(fmtChar, valChar, depth, ignore) {
			switch (fmtChar) {
				case 'X':
					break;
				case 'A':
					if (!_isUpper(valChar)) {
						if (_isLower(valChar) && !options.A) valChar = valChar.toUpperCase();
						else _mismatch(valChar, "uppercase letter", ignore);
					}
					break;
				case 'a':
					if (!_isLower(valChar)) {
						if (_isUpper(valChar) && !options.A) valChar = valChar.toLowerCase();
						else _mismatch(valChar, "lowercase letter", ignore);
					}
					break;
				case 'B':
					if (!_isUpper(valChar) && !_isDigit(valChar)) {
						if (_isLower(valChar) && !options.A) valChar = valChar.toUpperCase();
						else _mismatch(valChar, "uppercase letter or digit", ignore);
					}
					break;
				case 'b':
					if (!_isLower(valChar) && !_isDigit(valChar)) {
						if (_isUpper(valChar) && !options.A) valChar = valChar.toLowerCase();
						else _mismatch(valChar, "lowercase letter or digit", ignore);
					}
					break;
				case 'C':
					if (!_isLower(valChar) && !_isUpper(valChar) && !_isDigit(valChar)) {
						_mismatch(valChar, "letter or digit", ignore);
					}
					break;
				case 'L':
					if (!_isLower(valChar) && !_isUpper(valChar)) {
						_mismatch(valChar, "lowercase letter", ignore);
					}
					break;
				case 'H':
					if (!_isHexa(valChar)) {
						_mismatch(valChar, "hexadecimal character", ignore);
					}
					break;
				case ' ':
					if (fmtChar !== ' ') {
						_mismatch(valChar, "space", ignore);
					}
					break;
				case '#':
					if (!_isDigit(valChar)) {
						if (parse && valChar == ' ') return '';
						_mismatch(valChar, "digit", ignore);
					}
					break;
				default:
					var dyn = settings.dynFormats && settings.dynFormats[fmtChar];
					if (dyn) {
						if (depth === 0) dynTypes = [fmtChar];
						var savValid = valid;
						for (var i = 0; i < dyn.subType.length; i++) {
							var dynChar = dyn.subType[i];
							if (dynTypes.indexOf(dynChar) < 0) {
								dynTypes.push(dynChar);
								valid = true;
								var ch = formatChar(dynChar, valChar, depth + 1, true);
								if (valid) {
									valid = savValid;
									return ch;
								}
							}
						}
						if (dyn.complement && dyn.complement.indexOf(valChar) >= 0) {
							valid = savValid;
							return valChar;
						}
						if (depth === 0) {
							dynTypes = [];
							var resolveFmt = function(f) {
								if (!settings.dynFormats) return f;
								var r = '';
								for (var i = 0; i < f.length; i++) {
									var c = f[i];
									if (c == '[') {
										do {
											r += f[i];
										} while (f[i] != ']' && i++ < f.length);
									} else if (settings.dynFormats[c]) {
										if (dynTypes.indexOf(c) < 0) {
											dynTypes.push(c);
											r += '(';
											r += resolveFmt(settings.dynFormats[c].subType, r);
											if (settings.dynFormats[c].complement) {
												r += '(' + settings.dynFormats[c].complement + ')';
											}
											r += ')';
											dynTypes.pop();
										} //else skip
									} else r += c;
								}
								return r;
							};
							throw new Error("Unexpected character - Val[" + val + "] - Position[" + (srcPos - 1) + "] - dynamicFormat='" + fmt + "{" + resolveFmt(fmt.substr(fmt.indexOf(':') + 1)) + "}");
						}
						return valChar;
					} else {
						if (settings.skipBadFormat === true && settings.skipBadDynFmt === false) {
							throw new Error("Unknown dynamic format (" + fmtChar + ") - Format='" + fmt + "'");
						}
						_throwBadFormat("Unknown dynamic format");
					}
			}
			return valChar;
		}

		function stringWalker() {
			if (fmtChar === '>') {
				return; // ignore it
			}
			var isEmpty = result.length === 0;
			for (; repeat > 0; repeat--) {
				var valChar = val[srcPos++];
				if (valChar == null) {
					result += ' ';
				} else {
					valChar = formatChar(fmtChar, valChar, 0, valChar == ' ' && isEmpty);
					isEmpty = isEmpty && valChar == ' ';
					if (secretChar) valChar = secretChar;
					result += valChar;
				}
			}
		}

		function numberFormatter(floatFmt) {
			function flush() {
				if (!partStr) {
					if (partNum === 0 && (options['*'] || options['0'])) partStr = '';
					else return;
				}
				if (partStr.length < repeat + numExtra) {
					if (floatFmt !== true) {
						if (options['3'] && (options['*'] || options['0']) && integ == partStr && partStr.length < repeat) {
							var tmp = integ,
								r = repeat;
							while (partStr.length < (r + numExtra)) {
								if (tmp.length % (Math.floor(tmp.length / 4) * 4 + 3) === 0) tmp = special[2] + tmp;
								if (fillChar) tmp = fillChar + tmp;
								r--;
							}
							repeat = r;
							result += tmp;
						} else {
							while (partStr.length < repeat--) {
								if (fillChar) result += fillChar;
							}
							result += partStr;
						}
					} else {
						result += partStr;
					}
				} else if (partStr.length === repeat + numExtra) {
					result += partStr;
				} else {
					result += partStr.substring(0, repeat);
					if (partNum === 0) {
						valid = false;
						throw new Error("Number of digits overflow [" + partStr + "] - Expected length[" + (repeat + numExtra) + "]");
					}
				}
				numExtra = 0;
				partStr = null;
			}
			switch (fmtChar) {
				case undefined:
					// directive missing after repeat count
				case '#':
					if (partNum === 0) {
						flush();
					} else {
						if (partStr.length < repeat) {
							result += partStr;
							if (floatFmt !== true) {
								while (partStr.length < repeat--) result += '0';
							}
							partStr = '';
						} else {
							if (settings.strict === true && partStr.length > repeat) {
								throw new Error("Bad decimal part [" + partStr + "] - Expected length[" + repeat + "]");
							}
							result += partStr.substring(0, repeat);
							partStr = partStr.substring(repeat);
						}
					}
					partNum++;
					break;
				case '.':
					if (partNum > 1) throw new Error("too many '.' directives in format");
					flush();
					result += special[3];
					partStr = decim;
					partNum = 1;
					break;
				case 'F':
					fmtChar = '#';
					if (parseInt(integ, 10) === 0) integ = '0';
					partStr = integ;
					var extra = numExtra;
					numberFormatter(true);
					repeat = repeat - integ.length + extra;
					if (decim && parseInt(decim, 10) > 0) {
						result += special[3];
						partStr = decim;
						partNum = 1;
						numberFormatter(true);
					}
					break;
				default:
					throw _throwBadFormat();
			}
		}

		function numberParser() {
			var ch;
			if (result === '') {
				ch = val[srcPos];
				if (ch === '-' && result === '') {
					result += ch;
					srcPos++;
				} else if (ch === '+') {
					if (options['-']) srcPos++;
					else if (settings.strict === true) throw new Error("Unexpected positive sign");
					else srcPos++;
				}
				while ((ch = val[srcPos]) && (ch === fillChar || ch === special[2]) && (options['*'] || options['0'])) srcPos++;
			}
			while ((ch = val[srcPos])) {
				if (_isDigit(ch)) result += ch;
				else if ((ch == "-" || ch == "+") && options.D && srcPos == (val.length - 1)) {
					result = ch + result;
					break;
				} else if (!(ch === special[2] && options["3"])) break;
				srcPos++;
			}
			if (ch === special[3] && (fmtChar === '.' || fmtChar === 'F')) {
				result += '.';
				srcPos++;
				while ((ch = val[srcPos]) && _isDigit(ch)) {
					result += ch;
					srcPos++;
				}
			} else if (ch === special[3] && settings.strict === true) {
				throw new Error("No decimal part expected");
			}
		}

		function dateFormatter() {}

		function dateParser() {}

		function unknownWalker() {
			result += "?";
		}

		try {
			var typeChar = fmt[0];
			// default trim option
			if (typeChar === 'K') options.v = 1;
			else if (typeChar == 'N') options.v = 2;

			var walkers = parse ? {
				K: stringWalker,
				N: numberParser,
				D: dateParser,
				L: unknownWalker
			} : {
				K: stringWalker,
				N: numberFormatter,
				D: dateFormatter,
				L: unknownWalker
			};

			var walker = walkers[typeChar];
			if (walker) {
				for (fmtPos = 1; fmtPos < fmt.length && (fmtChar = fmt[fmtPos]) !== ':'; fmtPos++) {
					switch (fmtChar) {
						case 'v':
							// ignore v option when formatting numbers
							if (typeChar !== 'N' && _isDigit(fmt[fmtPos + 1])) options.v = parseInt(fmt[++fmtPos], 10);
							break;
						default:
							options[fmtChar] = true;
							break;
					}
				}
				fmtPos++;
			} else {
				_throwBadFormat();
			}
			fillChar = options['*'] ? special[5] : options['0'] ? '0' : null;
			if (typeChar != 'N' && fillChar == null) fillChar = ' ';
			if (typeChar === 'N' && !parse) {
				integ = val.toString();
				integ = integ.replace(/[^\d\.\-\+]/g, '');
				if (options.z && (integ === '0' || integ === '')) return '';
				if (integ === '' || integ === '.') integ = '0';
				lenIntg = integ.length - 1;
				if (integ[0] === '+' || integ[0] === '-') {
					negative = integ[0] === '-';
					integ = integ.substring(1);
				} else if ((integ[lenIntg] === '+' || integ[lenIntg] === '-') && options.D) {
					negative = integ[lenIntg] === '-';
					integ = integ.substring(0, lenIntg);
				}
				var dot = integ.indexOf('.');
				if (dot >= 0) {
					decim = integ.substring(dot + 1);
					integ = integ.substring(0, dot);
				}
				if (options["3"]) {
					var l = integ.length;
					if (l > 3) {
						var n3 = Math.floor(l) / 3;
						for (var k = 0; k < n3; k++) {
							l = integ.length - 4 * k - 3;
							if (l > 0) {
								integ = integ.substring(0, l) + special[2] + integ.substring(l);
								numExtra++;
							}
						}
					}
				}
				partStr = integ;
				badChar = special[4];
			}
			secretChar = options.X && special[5];
			var lastValid = 0,
				maxLength = 0;
			while (fmtPos < fmtLen) {
				var beg = fmtPos;
				if ((fmtChar = fmt[fmtPos]) === '[') {
					fmtPos = fmt.indexOf(']', fmtPos + 1);
					var lit = fmt.substring(beg + 1, fmtPos);
					if (fmtPos < 0) fmtPos = fmtLen;
					if (parse) {
						maxLength += lit.length;
						var got = val.substring(srcPos, srcPos + lit.length);
						if (got !== lit) {
							if (got !== '' && !(result === '' && /^ *$/.test(lit))) _mismatch(got, lit);
						} else {
							srcPos += lit.length;
						}
					} else {
						result += lit;
					}
					fmtPos++;
					continue;
				}
				repeat = 0;
				do {
					while (_isDigit(fmtChar = fmt[fmtPos])) fmtPos++;
					repeat += fmtPos > beg ? parseInt(fmt.substring(beg, fmtPos), 10) : fmtChar == '>' ? 0 : 1;
					while (fmtChar && fmtChar === fmt[fmtPos + 1]) {
						fmtPos++;
						repeat++;
					}
					fmtPos++;
					beg = fmtPos;
				} while (fmtChar === '#' && _isDigit(fmt[fmtPos]));
				maxLength += repeat;
				walker.call(this);
				if (valid) lastValid = result.length;
			}
			if (typeChar === 'N' && settings.strict === true && decim && decim.length > 0 && partNum == 1) {
				throw new Error("No decimal part expected");
			}
			if (val && typeChar === 'K' && settings.strict === true && val.length > maxLength) {
				throw new Error("Size overflow - nbRead[" + val.length + "] - Expected[" + maxLength + "]");
			}
			if (parse) {
				if (fmt[0] === 'N') {
					var n = parseFloat(result, 10);
					if (isNaN(n)) throw new Error("Bad number");
					if (settings.strict === true && Math.abs(n).toString().replace(/^\d/g, '').length > maxLength) throw new Error("Size overflow");
					return result;
				} else {
					return result;
				}
			} else {
				if (typeChar === 'N') {
					if (!valid) {
						result = result.replace(/./g, badChar);
					} else {
						if (options['+'] && negative) throw new Error("Unexpected negative number");
						var sign = negative ? '-' : options['-'] ? '+' : null;
						if (sign) {
							if (options.D) result += sign;
							else result = sign + result;
						}
						if (result.length > 0 && result[result.length - 1] == special[3]) {
							result = result.substr(0, result.length - 1);
						}
					}
				}
				var trim = trimFuncs[options.v];
				return trim && settings.vOn !== false ? trim(result) : result;
			}
		} catch (ex) {
			if (badFormat === true && settings.skipBadFormat === true) {
				if (settings.tracer) settings.tracer("Bad X3 format - " + ex.message);
				return val;
			}
			if (ex.message) ex.message = "Parse[" + parse + "]: " + ex.message;
			throw ex;
		}
	}

	exports.format = function(settings, fmt, val) {
		//console.log("\tformat - format:" +fmt + " -  value:'"+val+"'");
		var res = process(settings, fmt, val, false);
		//console.log("\t\tres='"+res+"'");
		return res;
	};

	exports.parse = function(settings, fmt, val) {
		var res = process(settings, fmt, val, true);
		//console.log("\tparse - format:" +fmt + " -  value:'"+val+"' - res='"+res+"'");
		return res;
	};

})(jQuery);