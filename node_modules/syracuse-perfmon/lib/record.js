"use strict";
/// !doc
/// 
/// # Simple performance monitoring API
/// 
/// This API allows you to gather performance data in your JS code. Typical usage is:
/// 
/// ``` javascript
/// var perfmon = require('syracuse-perfmon');
/// 
/// function myFunction(p1, p2) {
///   var timing = perfmon.start(module, "myFunction", p1);
///   // my function body
///   // ...
///   timing.end();
/// }
/// ```
/// 
/// The collected performance data can be retrieved with an HTTP request on http://localhost:8124/perfmon/session-data.
/// A link for it has been added in the main menu panel.
/// 
var helpers = require('syracuse-core/lib/helpers');
var glob = require('streamline/lib/globals');
var tick = 0;

// Date.now() jumps by steps of 16 ms on windows. Use hrtime instead to get better values
var hrOffset = 0;

function currentMillis() {
	var vals = process.hrtime();
	return hrOffset + (vals[0] * 1000) + Math.floor(vals[1] / 1000000);
}
// first call to initialize hrOffset
hrOffset = Date.now() - currentMillis();

function currentSessionId() {
	return glob.context && glob.context.session && glob.context.session.id;
}

var Timing = helpers.defineClass(function(mod, tag, details) {
	this.module = mod && mod.id;
	this.tag = "" + tag;
	this.details = details == null ? "" : details.toString();
	this.start = currentMillis();
	this.startTick = tick;
}, null, {
	end: function() {
		var end = currentMillis();
		// don't record actions that last 0 ms.
		if (this.start === end) return;
		var cx = (glob.context || (glob.context = {}));
		var timings = (cx.timings || (cx.timings = []));
		var timing = {
			module: this.module,
			tag: this.tag,
			details: this.details,
			sessionId: currentSessionId(),
			start: this.start,
			end: end,
			ticks: tick - this.startTick,
		};
		if (freshBigSlices.length > 0) {
			for (var i = freshBigSlices.length - 1; i >= 0; i--) {
				var slice = freshBigSlices[i];
				if (slice.sessionId === timing.sessionId && slice.start >= timing.start && slice.end <= timing.end) {
					slice.parentTag = timing.tag;
					slice.parentDetails = timing.details;
					freshBigSlices.splice(i, 1);
				}
			}
		}
		timings.push(timing);
	}
});

/// ## Monitoring code sections
/// 
/// `var perfmon = require('syracuse-perfmon');`
/// 
/// * `var timing = perfmon.start(module, tag, details);`  
///   start a monitoring operation.  
///   `module` is the current node.js module. This variable is set automatically by the require machinery.  
///   `tag` identifies the function or operation.  
///   `details` gives details about current invocation of the operation (typically a parameter value).
/// * `timing.end()`  
///   ends the timing and records the performance data.
/// 
exports.start = function(mod, tag, details) {
	return new Timing(mod, tag, details);
};

// Recording CPU usage
var cpuSlices = [];
var cpuDistribution = [];
var cpuTotal = 0;
var lastResume = currentMillis();
var maxCpuSlices = 10000; // make it configurable
var bigSlices = [];
var maxBigSlices = 50;
var freshBigSlices = [];

function log2(n) {
	var i = 0;
	while (n > 0) {
		i++;
		n >>= 1;
	}
	return i;
}

try {
	var events = require( /* server-side only */
	"events");
	glob.emitter = glob.emitter || new events.EventEmitter();
	glob.emitter.on('resume', function() {
		lastResume = currentMillis();
	});
	glob.emitter.on('yield', function() {
		var t = currentMillis();
		var delta = t - lastResume;
		// only record calls that take more than 1 ms
		if (delta >= 1) {
			var slice = {
				module: module.id,
				tag: 'perfmon.CPU',
				details: '',
				sessionId: currentSessionId(),
				start: lastResume,
				end: t,
				delta: t - lastResume
			};
			cpuSlices.push(slice);
			if (cpuSlices.length > maxCpuSlices) cpuSlices = cpuSlices.slice(maxCpuSlices / 2); // keep second half
			var index = 0;
			while (index < bigSlices.length && bigSlices[index].delta < delta) index++;
			if (index > 0 || bigSlices.length < maxBigSlices) {
				bigSlices.splice(index, 0, slice);
				if (bigSlices.length > maxBigSlices) bigSlices.shift();
				freshBigSlices.push(slice);
				if (freshBigSlices.length > maxBigSlices) freshBigSlices.shift();
			}
		}
		var slot = log2(delta);
		cpuDistribution[slot] = (cpuDistribution[slot] || 0) + 1;
		cpuTotal += delta;
		// set lastResume beyond so that we don't record the same slice twice.
		lastResume = t;
		tick++;
	});
} catch (ex) {
	// fail silently client-side
	if (typeof process === 'object') console.error(ex.stack);
}

function addCpuSlices(timings) {
	var sessionId = currentSessionId();
	var dst = timings.length - 1;
	var thisCpu = 0,
		otherCpu = 0;
	for (var i = cpuSlices.length - 1; i >= 0 && dst > 0; i--) {
		var cpu = cpuSlices[i];
		if (cpu.start >= timings[dst].end) continue;
		while (dst > 0 && timings[dst - 1].end >= cpu.end) dst--;
		timings.splice(dst, 0, cpu);
		if (sessionId === cpu.sessionId) thisCpu += (cpu.end - cpu.start);
		else otherCpu += (cpu.end - cpu.start);
	}
	timings[timings.length - 1].thisCpu = thisCpu;
	timings[timings.length - 1].otherCpu = otherCpu;
}

/// ## Collecting monitoring data
/// 

function hierarchize(timings, root) {
	root.children = [];
	var n;
	while ((n = timings.pop()) && n.start >= root.start) {
		root.children.splice(0, 0, hierarchize(timings, n));
	}
	if (n) timings.push(n);
	return root;
}

/// * `var collection = perfmon.collect(reset)`  
///   returns the array of timing records that have been collected.  
///   if `reset` is true the recorded data is reset.
exports.collect = function(reset) {
	if (!glob.context) return null;
	var timings = glob.context.timings;
	if (timings) addCpuSlices(timings);
	if (reset) glob.context.timings = null;
	return timings && hierarchize(timings, timings.pop());
};

exports.cpuStats = function() {
	for (var i = 0; i < cpuDistribution.length; i++) cpuDistribution[i] = cpuDistribution[i] || 0;
	return {
		distribution: cpuDistribution,
		total: cpuTotal,
	};
};

exports.bigCpuSlices = function() {
	return bigSlices;
};