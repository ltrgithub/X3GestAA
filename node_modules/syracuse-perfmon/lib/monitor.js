"use strict";
/// !doc
/// 
/// # Simple performance monitoring API
/// 
/// This API allows you to gather performance data in your JS code. Typical usage is:
/// 
/// ``` javascript
/// var perfmon = require('syracuse-perfmon');
/// 
/// function myFunction(p1, p2) {
///   var timing = perfmon.start(module, "myFunction", p1);
///   // my function body
///   // ...
///   timing.end();
/// }
/// ```
/// 
/// The collected performance data can be retrieved with an HTTP request on http://localhost:8124/perfmon/session-data.
/// A link for it has been added in the main menu panel.
/// 
var helpers = require('syracuse-core/lib/helpers');
var glob = require('streamline/lib/globals');

function currentSessionId() {
	return glob.context && glob.context.session && glob.context.session.id;
}

var Timing = helpers.defineClass(function(mod, tag, details) {
	this.module = mod && mod.id;
	this.tag = "" + tag;
	this.details = details == null ? "" : details.toString();
	this.start = Date.now();
}, null, {
	end: function() {
		var end = Date.now();
		// don't record actions that last 0 ms.
		if (this.start === end) return;
		var cx = (glob.context || (glob.context = {}));
		var timings = (cx.timings || (cx.timings = []));
		timings.push({
			module: this.module,
			tag: this.tag,
			details: this.details,
			sessionId: currentSessionId(),
			start: this.start,
			end: end,
		});
	}
})


/// ## Monitoring code sections
/// 
/// `var perfmon = require('syracuse-perfmon');`
/// 
/// * `var timing = perfmon.start(module, tag, details);`  
///   start a monitoring operation.  
///   `module` is the current node.js module. This variable is set automatically by the require machinery.  
///   `tag` identifies the function or operation.  
///   `details` gives details about current invocation of the operation (typically a parameter value).
/// * `timing.end()`  
///   ends the timing and records the performance data.
/// 
exports.start = function(mod, tag, details) {
	return new Timing(mod, tag, details);
}

// Recording CPU usage
var cpuSlices = [];
var lastResume;
var maxCpuSlices = 10000; // make it configurable

try {
	var events = require(/* server-side only */"events");
	glob.emitter = glob.emitter || new events.EventEmitter();
	glob.emitter.on('resume', function() {
		lastResume = Date.now();
	});
	glob.emitter.on('yield', function() {
		var t = Date.now();
		// only record calls that take more than 1 ms
		if (t >= lastResume + 1) {
				cpuSlices.push({
				module: module.id,
				tag: 'perfmon.CPU',
				details: '',
				sessionId: currentSessionId(),
				start: lastResume,
				end: t
			});
			if (cpuSlices.length > maxCpuSlices)
				cpuSlices = cpuSlices.slice(maxCpuSlices / 2); // keep second half
		}
		// set lastResume beyond so that we don't record the same slice twice.
		lastResume = t;
	});
} catch (ex) {
	// fail silently client-side
	if (typeof process === 'object') console.error(ex.stack);
}

function addCpuSlices(timings) {
	var sessionId = currentSessionId();
	var dst = timings.length - 1;
	var thisCpu = 0, otherCpu = 0;
	for (var i = cpuSlices.length - 1; i >= 0 && dst > 0; i--) {
		var cpu = cpuSlices[i];
		if (cpu.start >= timings[dst].end) continue;
		while (dst > 0 && timings[dst - 1].end >= cpu.end) dst--;
		timings.splice(dst, 0, cpu);
		if (sessionId === cpu.sessionId) thisCpu += (cpu.end - cpu.start);
		else otherCpu += (cpu.end - cpu.start);
	}
	timings[timings.length - 1].thisCpu = thisCpu;
	timings[timings.length - 1].otherCpu = otherCpu;
}

/// ## Collecting monitoring data
/// 

function hierarchize(timings, root) {
	root.children = [];
	var n;
	while ((n = timings.pop()) && n.start >= root.start) {
		root.children.splice(0, 0, hierarchize(timings, n));
	}
	if (n) timings.push(n);
	return root;
}

function cssClass(millis) {
	if (millis < 1) return "zero";
	if (millis < 10) return "low";
	if (millis < 100) return "medium";
	if (millis < 1000) return "high";
	return "very-high";
}

function formatMillis(millis) {
	return '<span class="' + cssClass(millis) + '">' + millis + ' ms</span>';
}

function formatDetails(n) {
	if (n.tag !== 'perfmon.CPU') return n.details;
	if (currentSessionId() === n.sessionId) return "current ";
	return "other: " + n.sessionId;
}
function formatChildren(children, start, end) {
	if (!children || !children.length) return '';
	var cur = start || children[0].start;
	end = end || Date.now();
	function wait(t) {
		var s = '<li><span class="other">' + (t - cur) + ' ms</span> ...' + /*' start=' + t + */'</li>';
		cur = t;
		return s;
	}
	function format(n) {
		var s = '';
		if (n.start != cur) {
			s += wait(n.start);
			cur = n.end;
		}
		var mod = n.module.substring(n.module.indexOf('node_modules') + 13);
		var millis = (n.end - n.start);
		var nchildren =  n.children.length;
		var cursor = nchildren ? 'pointer' : 'default';
		s += '<li style="cursor:' + cursor + '"><b>' + formatMillis(millis) + '</b> (' + nchildren + ') ';
		s += '<span title="' + mod + '" class="tag">' + n.tag + '</span> ';
		if (!start) s += '- <span class="aggregate">CPU:</span> current ' + formatMillis(n.thisCpu) + ', other ' + formatMillis(n.otherCpu) + ' - <span class="aggregate">IO:</span> ' + formatMillis(millis - n.thisCpu - n.otherCpu) + ' ';
		s += '<span class="details">' + formatDetails(n) + '</span>';
		//s += ' start=' + n.start;
		s += '<ul style="display: none;">' + formatChildren(n.children, n.start, n.end) + '</ul>';
		s += '</li>';
		cur = n.end;
		return s;
	}
	var s = children.map(format).join('');
	if (cur < end) s += wait(end);
	return s;
}

var head = '<html>' + '<head><title>Performance Monitoring</title>' + //
'<link href="/syracuse-perfmon/lib/monitor.css" rel="stylesheet" type="text/css"/>' + //
'<script>window.onload = ' + function() {
	var lis = document.getElementsByTagName('li');
	for (var i = 0; i < lis.length; i++) {
		var li = lis[i];
		li.onclick = function(ev) { 
			var uls = ev.currentTarget.getElementsByTagName('ul');
			for (var i = 0; i < uls.length; i++)
				uls[i].style.display = uls[i].style.display == 'none' ? 'inline' : 'none';
			ev.cancelBubble = true;
		}
	}
} + '</script>'
'</head><body>';
var tail = '</body></html>';

/// * `var collection = perfmon.collect(reset)`  
///   returns the array of timing records that have been collected.  
///   if `reset` is true the recorded data is reset.
exports.collect = function(reset) {
	if (!glob.context) return null;
	var timings = glob.context.timings;
	if (timings) addCpuSlices(timings);
	if (reset) glob.context.timings = null;
	return timings;
}
/// * var html = perfmon.toHtml(collections);  
///   formats collected data as HTML.  
///   `collections` is an array of timing collections.
///   Each element of the `collections` array is an array containing timing entries.
exports.toHtml = function(collections) {
	if (!collections) return head + 'Sorry, no data available. <a href="/syracuse-main/html/main.html?url=%3Frepresentation%3Dhome.%24dashboard">Navigate first!</a>' + tail;
	var lastTiming;
	var children = collections.map(function(timings) {
		timings = timings.slice(0);
		return hierarchize(timings, lastTiming = timings.pop());
	});
	return head + '<h2>Data collected ' + new Date(lastTiming.end) +'</h2>' + //
	'<ul>' + formatChildren(children) + '</ul>' + //
	tail;
}