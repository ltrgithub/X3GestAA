"use strict";
/// !doc
/// 
/// # Simple performance monitoring API
/// 
/// This API allows you to gather performance data in your JS code. Typical usage is:
/// 
/// ``` javascript
/// var perfmon = require('syracuse-perfmon');
/// 
/// function myFunction(p1, p2) {
///   var timing = perfmon.start(module, "myFunction", p1);
///   // my function body
///   // ...
///   timing.end();
/// }
/// ```
/// 
/// The collected performance data can be retrieved with an HTTP request on http://localhost:8124/perfmon/session-data.
/// A link for it has been added in the main menu panel.
/// 
var helpers = require('syracuse-core/lib/helpers');
var glob = require('streamline/lib/globals');

var Timing = helpers.defineClass(function(mod, tag, details) {
	this.module = mod && mod.id;
	this.tag = "" + tag;
	this.details = details == null ? "" : details.toString();
	this.start = Date.now();
}, null, {
	end: function() {
		var end = Date.now();
		// don't record actions that last 0 ms.
		if (this.start === end) return;
		var cx = (glob.context || (glob.context = {}));
		var timings = (cx.timings || (cx.timings = []));
		timings.push({
			module: this.module,
			tag: this.tag,
			details: this.details,
			start: this.start,
			end: end,
		});
	}
})


/// ## Monitoring code sections
/// 
/// `var perfmon = require('syracuse-perfmon');`
/// 
/// * `var timing = perfmon.start(module, tag, details);`  
///   start a monitoring operation.  
///   `module` is the current node.js module. This variable is set automatically by the require machinery.  
///   `tag` identifies the function or operation.  
///   `details` gives details about current invocation of the operation (typically a parameter value).
/// * `timing.end()`  
///   ends the timing and records the performance data.
/// 
exports.start = function(mod, tag, details) {
	return new Timing(mod, tag, details);
}

// Recording CPU usage
var cpuSlices = [];
var lastResume;
var maxCpuSlices = 1000; // make it configurable
var cpuThreshold = 2; // number of ms above which we start recording CPU slices
try {
	var events = require(/* server-side only */"events");
	glob.emitter = glob.emitter || new events.EventEmitter();
	glob.emitter.on('resume', function() {
		lastResume = Date.now();
	});
	glob.emitter.on('yield', function() {
		var t = Date.now();
		// only record calls that take more than 5 ms
		if (t >= lastResume + cpuThreshold) {
				cpuSlices.push({
				module: module.id,
				tag: 'perfmon.CPU',
				details: glob.context && glob.context.session && glob.context.session.id,
				start: lastResume,
				end: t
			});
			if (cpuSlices.length > maxCpuSlices)
				cpuSlices = cpuSlices.slice(maxCpuSlices / 2); // keep second half
		}
	});
} catch (ex) {
	// fail silently client-side
	if (typeof process === 'object') console.error(ex.stack);
}

function addCpuSlices(timings) {
	var dst = timings.length - 1;
	for (var i = cpuSlices.length - 1; i >= 0 && dst > 0; i--) {
		var cpu = cpuSlices[i];
		if (cpu.start >= timings[dst].end) continue;
		while (dst > 0 && timings[dst - 1].end >= cpu.end) dst--;
		timings.splice(dst, 0, cpu);
	}
}

/// ## Collecting monitoring data
/// 

function hierarchize(timings, root) {
	root.children = [];
	var n;
	while ((n = timings.pop()) && n.start >= root.start) {
		root.children.splice(0, 0, hierarchize(timings, n));
	}
	if (n) timings.push(n);
	return root;
}

function cssClass(millis) {
	if (millis < 10) return "low";
	if (millis < 100) return "medium";
	if (millis < 1000) return "high";
	return "very-high";
}

function formatDetails(n) {
	if (n.tag !== 'perfmon.CPU') return n.details;
	if (glob.context && glob.context.session && glob.context.session.id === n.details) return "current session";
	return "other session: " + n.details;
}
function formatChildren(children, start, end) {
	if (!children || !children.length) return '';
	var cur = start || children[0].start;
	end = end || Date.now();
	function wait(ms) {
		return '<li><span class="other">' + ms + ' ms</span> ...</li>';
	}
	function format(n) {
		var s = '';
		if (n.start != cur) {
			s += wait(n.start - cur);
			cur = n.end;
		}
		var mod = n.module.substring(n.module.indexOf('node_modules') + 13);
		var millis = (n.end - n.start);
		s += '<li><span class="' + cssClass(millis) + '"><b>' + millis + " ms</b></span> " + //
		'<span title="' + mod + '" class="tag">' + n.tag + '</span> ' + //
		'<span class="details">' + formatDetails(n) + '</span>';
		s += '<ul>' + formatChildren(n.children, n.start, n.end) + '</ul>';
		s += '</li>';
		return s;
	}
	var s = children.map(format).join('');
	if (cur < end) s += wait(end - cur);
	return s;
}

var head = '<html>' + '<head><title>Performance Monitoring</title>' + //
'<link href="/syracuse-perfmon/lib/styles.css" rel="stylesheet" type="text/css"/>' + //
'</head><body>';
var tail = '</body></html>';

/// * `var collection = perfmon.collect(reset)`  
///   returns the array of timing records that have been collected.  
///   if `reset` is true the recorded data is reset.
exports.collect = function(reset) {
	if (!glob.context) return null;
	var timings = glob.context.timings;
	if (timings) addCpuSlices(timings);
	if (reset) glob.context.timings = null;
	return timings;
}
/// * var html = perfmon.toHtml(collections);  
///   formats collected data as HTML.  
///   `collections` is an array of timing collections.
///   Each element of the `collections` array is an array containing timing entries.
exports.toHtml = function(collections) {
	if (!collections) return head + 'Sorry, no data available. <a href="/syracuse-main/html/main.html?url=%3Frepresentation%3Dhome.%24dashboard">Navigate first!</a>' + tail;
	var lastTiming;
	var children = collections.map(function(timings) {
		timings = timings.slice(0);
		return hierarchize(timings, lastTiming = timings.pop());
	});
	return head + '<h2>Data collected ' + new Date(lastTiming.end) +'</h2>' + //
	'<ul>' + formatChildren(children) + '</ul>' + //
	tail;
}