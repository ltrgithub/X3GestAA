"use strict";

var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var tracer = require('syracuse-core').getTracer("batch");
var flows = require('streamline-runtime').flows;
var locale = require('streamline-locale');
var ez = require('ez-streams');
var querystring = require('querystring');
var x3client = require('syracuse-x3/lib/client');
var x3FolderHelper = require('syracuse-collaboration/lib/entities/lookupX3Folder');
var X3BatchException = require("syracuse-batch/lib/x3BatchException").X3BatchException;

var helpers = require('syracuse-core').helpers;
var config0 = require('config');
var globals = require('streamline-runtime').globals;
var multiTenant = (config0.hosting && config0.hosting.multiTenant);

// this map will retains all X3 batch clients
var bClients = {};

exports.getBatchClient = function(code) {
	if (multiTenant) {
		var tenantId = globals.context.tenantId;
		var bClients0 = bClients[tenantId];
		return bClients0 ? bClients0[code] : undefined;
	}
	//console.error("SERVERS KEYS: " + JSON.stringify(Object.keys(bClients), null, 2));
	return bClients[code];
};

function getLocalePrefFromX3Lang(_, lang) {
	var iso = locale.defaultIso(lang);
	if (!iso) throw new Error(locale.format(module, "langIncorrect", lang));
	return getLocalePrefFromIso(_, iso);
}

var localesMap = {};

function getLocalePrefFromIso(_, iso) {
	var db = adminHelper.getCollaborationOrm(_);
	if (iso.length === 2) iso = locale.longIso(iso);
	locale.setCurrent(_, iso);
	var codeIso = iso.substring(0, 3) + iso.substring(3).toUpperCase();
	tracer.debug && tracer.debug("Use language: " + codeIso);
	if (!localesMap[codeIso]) localesMap[codeIso] = db.fetchInstances(_, db.model.getEntity(_, "localePreference"), {
		jsonWhere: {
			code: codeIso
		}
	})[0];
	if (!localesMap[codeIso]) throw new Error("Can't find locale preference corresponding to '" + iso + "'");
	return localesMap[codeIso];
}

exports.X3BatchClient = helpers.defineClass(function(options) {
	options = options || {};
	this.queueSize = options.queueSize || 100000;
	this.created = 0;
	this.q = ez.devices.queue({
		max: this.queueSize,
	});
	this.readFunnel = flows.funnel(1);
	this.destroyFunnel = flows.funnel(1);

}, null, {
	_init: function(_, context, batchSrvInst) {
		var self = this;
		this.servers = [];
		// this map will keep maxQuery parameter for each server
		this.maxQueries = {};

		this.code = batchSrvInst.code(_);
		this.x3solution = batchSrvInst.x3solution(_);
		this.auto = batchSrvInst.auto(_);
		this.execInterval = batchSrvInst.execInterval(_);
		// the two following are only necessary for X3 side
		this.killOverTime = batchSrvInst.killOverTime(_);
		this.maxDelay = batchSrvInst.maxDelay(_);
		//
		this.refUrl = batchSrvInst.refUrl(_);
		this.refUser = batchSrvInst.refUser(_) || "ADMIN";
		this.refLang = batchSrvInst.refLang(_) || "ENG";

		if (multiTenant) {
			var tenantId = globals.context.tenantId;
			var bClients0 = bClients[tenantId];
			if (!bClients0)
				bClients0 = bClients[tenantId] = {};
			bClients0[this.code] = this;
		} else {
			bClients[this.code] = this;
		}

		// consider configuration that match to configurations where maxQueries is > 0
		var confEnabled = batchSrvInst.runtimes(_).toArray(_).filter_(_, function(_, r) {
			return r.maxQueries(_) > 0;
		});
		if (confEnabled.length === 0) throw new Error(locale.format(module, "noConfEnabled"));

		// select corresponding runtimes in x3solution
		this.servers = batchSrvInst.x3solution(_).getServersByDescription(_, confEnabled.map_(_, function(_, r) {
			return r.description(_);
		}));

		var srvDescriptions = this.servers.map_(_, function(_, s) {
			return s.description(_);
		});
		// watch missing servers to alert with trace and/or diagnoses
		confEnabled.forEach_(_, function(_, conf) {
			if (srvDescriptions.indexOf(conf.description(_)) === -1) {
				var msg = locale.format(module, "srvNotAvailable", conf.description(_));
				context && context.instance && context.instance.$diagnoses.push({
					$severity: "warning",
					$message: msg
				});
				tracer.debug && tracer.debug("[" + self.code + "] " + msg);
			} else {
				// consider maxQuery parameter for a given server
				self.maxQueries[conf.description(_)] = conf.maxQueries(_);
			}
		});
		this.totalMaxQueries = 0;
		for (var i = 0; i < Object.keys(this.maxQueries).length; i++) {
			this.totalMaxQueries += this.maxQueries[Object.keys(this.maxQueries)[i]];
		}

		tracer.info && tracer.info("[" + this.alias + "] X3 batch client initialized");
		this.initialized = true;



		return batchSrvInst;
	},
	start: function(_, context, batchSrvInst) {
		try {
			this._init(_, context, batchSrvInst);
		} catch (e) {
			console.error(e.stack);
			context && context.instance && context.instance.$diagnoses.push({
				$severity: "error",
				$message: e.message,
				$stackTrace: e.safeStack
			});
			tracer.warn && tracer.warn("[" + this.code + "] " + e.message);
			return batchSrvInst;
		}


		this.refClients = [];

		for (var i = 0; i < this.servers.length; i++) {
			var srv = this.servers[i];
			// create as many client as we have x3 runtimes
			var cli = this._createClient(_, context, {
				x3server: srv,
				lang: this.refLang,
				user: this.refUser,
				folder: this.refFolder,
				localePref: getLocalePrefFromX3Lang(_, this.refLang)
			});
			if (cli) {
				tracer.info && tracer.info("[" + this.code + "] " + locale.format(module, "clientCreated", cli.pid, cli.x3server.serverHost(_), cli.x3server.serverPort(_)));
				this.refClients.push(cli);
				try {
					// propagate configuration
					this._mngtAllParams(_, context);
				} catch (e) {
					if (e instanceof X3BatchException) {
						// stop the batch server if config propagation failed
						this.stop(_, null, batchSrvInst);
						break;
					}
				}

				context && context.instance && context.instance.$diagnoses.push({
					$severity: "success",
					$message: locale.format(module, "clientCreated", cli.pid, cli.x3server.serverHost(_), cli.x3server.serverPort(_))
				});
			}
		}

		if (this.refClients && this.refClients.length === 0) {
			this.stop(_, context, batchSrvInst);
			return batchSrvInst;
		}
		this.started = true;
		// set status running
		batchSrvInst.status(_, "running");
		batchSrvInst.save(_);
		// start watching queries
		this._launchWatchLoop();
		return batchSrvInst;
	},
	stop: function(_, context, batchSrvInst) {
		try {
			// stop watching queries
			this._stopWatchLoop();

			var self = this;
			this.refClients.forEach_(_, function(_, cli) {
				// disconnect all administrative clients
				cli.disconnect(_);
				var msg = locale.format(module, "clientDisconnected", cli.pid, cli.x3server.serverHost(_), cli.x3server.serverPort(_));
				context && context.instance && context.instance.$diagnoses.push({
					$severity: "success",
					$message: msg
				});
				tracer.debug && tracer.debug("[" + self.code + "] " + msg);
			});
		} catch (e) {
			console.error(e.stack);
			context && context.instance && context.instance.$addError(e.message);
		}

		this.refClients = null;
		this.started = false;
		// set status stopped
		batchSrvInst.status(_, "stopped");
		batchSrvInst.save(_);
		return batchSrvInst;
	},
	_launchWatchLoop: function() {
		// execute watch function every execInterval time
		this.loopInterval = flows.setInterval(this._executeControlLoop.bind(this), this.execInterval * 1000);
		tracer.info && tracer.info("[" + this.code + "]  Queries listener is enabled and will handle " + this.totalMaxQueries + " queries every " + this.execInterval + " seconds");
	},
	_stopWatchLoop: function() {
		if (this.loopInterval) {
			// stop watch loop
			clearInterval(this.loopInterval);
			this.loopInterval = null;
			tracer.info && tracer.info("[" + this.code + "]  Queries listener disabled");
		}
	},
	_createClient: function(_, context, options) {
		try {
			var adminEP = adminHelper.getCollaborationEndpoint(_);
			var client = x3client.create({
				x3solution: this.x3solution,
				x3server: options.x3server
			});
			var _x3 = client.connect(_, {
				server: "",
				folder: options.folder,
				locale: options.lang,
				runtimeLog: options.runtimeLogFlag || "",
				runtimeLogDir: options.runtimeLogDir || ""
			});
			client.pid = _x3.pid;
			var session = context && (context.httpSession || context.session);
			var peer = session && (session.getData("requestInfo") || {}).peerAddress;
			this.sid = client.createSession(_, {
				locale: options.lang,
				userName: options.user,
				adxtyp: options.adxtyp || 35, // adxtyp = 35 for batch
				localePreferences: options.localePref,
				baseUrl: context && context.baseUrl,
				collaborationBaseUrl: adminEP && session ? session.host + adminHelper.getCollaborationEndpoint(_).getBaseUrl(_) : "",
				peerAddress: peer
			});

			return client;
		} catch (e) {
			console.error(e.stack);
			context && context.instance && context.instance.$addError(e.message);
		}
	},
	_inspectResponse: function(_, context, alias, resp, options) {
		if (resp) {
			if (!options.noTraces) tracer.debug && tracer.debug("[" + this.code + "] " + alias + " call result: " + JSON.stringify(resp, null, 2));
			if (resp.head && resp.head.status) {
				if (resp.head.status !== 200) {
					var diags = (resp.body && resp.body.$diagnoses) || [];
					if (diags.length === 0 && resp.head.message) {
						diags.push({
							$severity: "error",
							$message: locale.format(module, "x3err", alias, resp.head.message)
						});
					}
					if (diags && diags.length > 0) {
						diags.forEach(function(d) {
							if (context && context.instance) context.instance.$diagnoses.push(d);
							tracer.error && tracer.error(d.$message);
						});
						// some actions need to be blocking (like configuration propagation)
						if (options.throwErr) throw new X3BatchException(diags[0].$message);
					}
				} else {
					return resp.body;
				}
			}
		}
		return null;
	},
	_sdataRequest: function(_, context, client, url, alias, method, body, options) {
		options = options || {};
		var params = {
			head: {
				method: method,
				url: url,
				accept: "application/json",
				"content-type": "application/json"
			},
			body: body
		};
		if (!options.noTraces) tracer.debug && tracer.debug("[" + this.code + "] " + alias + " call params: " + JSON.stringify(params, null, 2));
		var resp = client.jsonSend(_, params);
		return this._inspectResponse(_, context, alias, resp, options);
	},
	_execRpc: function(_, context, client, mod, name, method, body, options) {
		var url = this.refUrl + "/$service/rpc?module=" + mod + "&name=" + name;
		return this._sdataRequest(_, context, client, url, mod + ":" + name, method, body, options);
	},
	_mngtAllParams: function(_, context) {
		this._execRpc(_, context, this.refClients[0], "ASYRSRVBATCH", "ABATCH_MNGT_ALLPARAMS", "POST", {
			execInterval: this.execInterval,
			killOverTime: this.killOverTime,
			maxDelay: this.maxDelay
		}, {
			throwErr: true
		});
	},
	_mngtServReq: function(_, context) {
		var self = this;
		this.refClients.forEach_(_, function(_, cli) {
			self._execRpc(_, context, cli, "ASYRSRVBATCH", "ABATCH_MNGT_SERVREQ", "POST", {
				server: cli.x3server.serverHost(_),
				port: cli.x3server.serverPort(_)
			});
		});
	},
	_mngtAllReq: function(_, context) {
		this._execRpc(_, context, this.refClients[0], "ASYRSRVBATCH", "ABATCH_MNGT_ALLREQ", "POST", {});
	},
	_listQueries: function(_, params) {
		params = params || {};
		params.representation = "ASYRREQ.$query";
		if (!params.orderby) params.orderBy = "DAT,HEURE,NUMREQ";
		//
		var url = this.refUrl + "/ASYRREQ?" + querystring.stringify(params);
		return this._sdataRequest(_, null, this.refClients[0], url, "ASYRREQ", "GET", {}
			//,{noTraces: true}
		);
	},
	_stopRecurrent: function(_, context, folderName) {
		var cli = this.refClients[0];
		this._execRpc(_, context, cli, "ASYRSRVBATCH", "ABATCH_STOP_RECURRENT", "POST", {
			server: cli.x3server.serverHost(_),
			port: cli.x3server.serverPort(_),
			folder: folderName
		});
	},
	_selectServer: function(_) {

	},
	_execQuery: function(_, query) {

	},
	_executeControlLoop: function(_) {
		tracer.debug && tracer.debug("\n============== [" + this.code + "]  begin control loop ==============");
		this._mngtServReq(_);
		this._mngtAllReq(_);
		var resp = this._listQueries(_, {
			count: this.totalMaxQueries
		});
		var queries = resp && resp.$resources;

		console.error("Queries: " + JSON.stringify(queries, null, 2));
		queries = queries.filter(function(q) {
			return q.FLAG === 1;
		});

		for (var i = 0; i < queries.length; i++) {

			var q = queries[i];



		}


		tracer.debug && tracer.debug("============== [" + this.code + "]  end control loop ================");

	}

});

exports.initBatchServers = function(_) {
	var db = adminHelper.getCollaborationOrm(_);
	var x3solutions = db.fetchInstances(_, db.getEntity(_, "x3solution"));
	var bsEntity = db.getEntity(_, "batchServer");
	x3solutions.forEach_(_, function(_, s) {
		var bs = null;
		var bss = db.fetchInstances(_, bsEntity, {
			jsonWhere: {
				code: s.code(_)
			}
		});
		// Get existing batch server config
		if (bss.length > 0) bs = bss[0];
		// create if if doesn't exist
		if (!bs) {
			bs = bsEntity.createInstance(_, db);
			bs.code(_, s.code(_));
			bs.x3solution(_, s);

			// compute ref endpoint
			var ep;
			if (s) {
				var motherFolders = x3FolderHelper.getFoldersFromJson(_, s, function(f) {
					return f.mother && f.mother.length === 0;
				});
				if (motherFolders && motherFolders.length > 0) {
					ep = s.getEp(_, motherFolders[0].name);
					if (!ep) {
						ep = s.createEndpoint(_, motherFolders[0].name);
					}
					if (ep) {
						bs.refEndpoint(_, ep);
					}
				}
			}
		}

		// reset statuses
		if (bs.status(_) === "running") {
			bs.status(_, "stopped");
		}
		// synchronize runtimes list with x3solution configuration
		bs.syncServers(_);
		// persist data
		bs.save(_);

		// start the batch server
		if (bs.auto(_)) {
			bs.start(_);
		}

	});
};