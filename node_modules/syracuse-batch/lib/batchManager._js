"use strict";

var adminHelper = require("@sage/syracuse-lib/src/collaboration/helpers").AdminHelper;
var tracer = require('@sage/syracuse-core').getTracer("batch");
var flows = require('streamline-runtime').flows;
var locale = require('@sage/syracuse-core').locale;
var ez = require('ez-streams');
var querystring = require('querystring');
var X3BatchException = require('./x3BatchException').X3BatchException;
var batchHelper = require('./batchHelper');
var sessionManager = require('@sage/syracuse-lib/src/session/sessionManager').sessionManager;
var helpers = require('@sage/syracuse-core').helpers;
var config0 = require('config');
var globals = require('streamline-runtime').globals;
var multiTenant = (config0.hosting && config0.hosting.multiTenant);



// to not execute controller loop
var simulation = config0.x3batch && config0.x3batch.simulation;
// to not trace some debug results
var lightDebugTraces = config0.x3batch && config0.x3batch.lightDebugTraces;
// retry connection to X3 server for admin client
var retryCount = config0.x3batch && config0.x3batch.retryCount || 0;
var retryInterval = config0.x3batch && config0.x3batch.retryInterval || 0;


// this map will retains all X3 batch clients
var bClients = {};

var client;

exports.registerBatchServer = function(_) {
	function startBatchServers(_) {
		tracer.info && tracer.info("Starting batch servers " + lock.sessionId);
		_subscribeBatchServer(_)
		batchHelper.initBatchServers(flows.check);
	}

	var orm = adminHelper.getCollaborationOrm(_);
	var lock = orm.lock(_, "batch", 30 * 1000, false);
	if (lock.status == "success") {
		startBatchServers(_)
	} else var timer = setInterval(function() {
		(_ => {
			lock = orm.lock(_, "batch", 30 * 1000, false);
			if (lock.status == "success") {
				startBatchServers(_)
				clearInterval(timer);
			}
		})(flows.check);
	}, 60 * 1000);

}

// Using publish/subscriber messaging to start/stop the batch server
// The communication channel use to send commands to batch server is  "batch"
// The response comme on dedicate channel "batch.diagnoses.<batch-server-name>" 
// (see getChannelName method on batchServer.js)
function _subscribeBatchServer(_) {
	var getBroker = require("../../@sage/syracuse-lib/src/pub-sub/broker").getBroker;

	client = getBroker(_).subscribe(_, "batch", function(_, message) {
		var diagnoses = [];
		var batchSrvInst;
		try {
			var db = adminHelper.getCollaborationOrm(_);
			batchSrvInst = db.fetchInstance(_, db.model.getEntity(_, "batchServer"), {
				jsonWhere: {
					code: message.code
				}
			});

			var clientBatch = exports.getBatchClient(message.code,
				(message.action == "start"),
				(message.action == "applyChanges"));

			switch (message.action) {
				case "start":
					clientBatch.start(_, diagnoses, batchSrvInst, undefined);
					getBroker(_).publish(_, batchSrvInst.getChannelName(_), diagnoses);
					break;
				case "stop":
					clientBatch.stop(_, diagnoses, batchSrvInst, undefined);
					getBroker(_).publish(_, batchSrvInst.getChannelName(_), diagnoses);
					break;
				case "stopAll":
					clientBatch.stopAll(_, diagnoses, batchSrvInst, undefined);
					getBroker(_).publish(_, batchSrvInst.getChannelName(_), diagnoses);
					break;
				case "applyChanges":
					clientBatch.applyChanges(_, diagnoses, batchSrvInst, message.data);
					getBroker(_).publish(_, batchSrvInst.getChannelName(_), diagnoses);
					break;
				default:
					console.log("Command not found", message.action);
					break;
			}

		} catch (e) {
			diagnoses && diagnoses.push({
				$severity: "error",
				$message: e.message,
				$stackTrace: e.safeStack
			});
			batchSrvInst && getBroker(_).publish(_, batchSrvInst.getChannelName(_), diagnoses);
			tracer.error && tracer.error("[" + this.code + "] " + e.message);
		}

	});
};


exports.getBatchClient = function(code, start, ignoreErr) {
	var bc;
	var tenantId = globals.context.tenantId;
	if (multiTenant) {
		var bClients0 = bClients[tenantId];
		bc = bClients0 ? bClients0[code] : undefined;
	} else {
		bc = bClients[code];
	}
	//console.error("SERVERS KEYS: " + JSON.stringify(Object.keys(bClients), null, 2));
	if (!bc) {
		if (start) {
			bc = new exports.X3BatchClient(code);
			if (multiTenant) {
				if (!bClients[tenantId])
					bClients[tenantId] = bClients[tenantId] = {};
				bClients[tenantId][code] = bc;
			} else {
				bClients[code] = bc;
			}
			return bc;
		} else if (!ignoreErr) {
			throw new Error("Batch is not initialized for the solution '" + code + "'");
		}
	}
	return bc;
};

function removeBatchClient(code) {
	if (multiTenant) {
		var tenantId = globals.context.tenantId;
		var bClients0 = bClients[tenantId];
		if (bClients0) {
			tracer.info && tracer.info("############## [" + code + "]  Batch server destroyed for tenant [" + tenantId + "] ##############\n");
			delete bClients0[code];
		}
	} else {
		tracer.info && tracer.info("############## [" + code + "]  Batch server destroyed ##############\n");
		delete bClients[code];
	}
}



exports.X3BatchClient = helpers.defineClass(function(code) {
	this.code = code;
	this.timeouts = {}; // stores timeouts for admin clients
}, null, {
	// initialize instance. When already initialized, return 'null' to abort start function
	_init: function(_, diagnoses, batchSrvInst) {
		var self = this;
		this.db = this.db || adminHelper.getCollaborationOrm(_);
		if (!batchSrvInst) {
			batchSrvInst = this.db.fetchInstance(_, this.db.model.getEntity(_, "batchServer"), {
				jsonWhere: {
					code: this.code
				}
			});
			if (!batchSrvInst) throw new Error(locale.format(module, "noBatchServer", this.code));
		}
		if (batchSrvInst.status(_) === "running" || batchSrvInst.status(_) === "starting") {
			return null; // already started - finish function
		}
		// set status to "starting";
		this.status = "starting";
		batchSrvInst.status(_, "starting");
		batchSrvInst.save(_);
		this.x3solutionCode = batchSrvInst.x3solution(_).code(_);
		this.totalMaxQueries = 0;
		this.monoPendings = {}; // datasets will be stored here to know if a mono request is pending
		this.checkTimeout = 0;
		//
		// this.code = batchSrvInst.code(_);
		this.auto = batchSrvInst.auto(_);
		this.execInterval = batchSrvInst.execInterval(_);
		// the two following are only necessary for X3 side
		this.killOverTime = batchSrvInst.killOverTime(_);
		this.maxDelay = batchSrvInst.maxDelay(_);
		//
		this.refEndpoint = batchSrvInst.refEndpoint(_);
		this.refUrl = this.refEndpoint.getBaseUrl(_);
		this.refFolder = this.refEndpoint.x3ServerFolder(_);
		var cl = this.adminClients = {};
		if (!this.refUrl || !this.refFolder) throw new Error(locale.format("noRefEndpoint"));
		this.user = batchSrvInst.user(_);
		this.localePref = batchSrvInst.localePref(_);

		this.role = batchSrvInst.role(_);
		if (!globals.context.session) {
			globals.context.session = sessionManager.createBatchSession(_, this.user, this.role, this.localePref, diagnoses);
		}
		this.ctrlLogin = this.user.getEndpointLogin(_, this.refEndpoint.$uuid),
			this.ctrlLanIso = this.localePref.code(_);

		// consider configuration that match to configurations where maxQueries is > 0
		var confEnabled = batchSrvInst.runtimes(_).toArray(_).filter_(_, function(_, r) {
			return r.maxQueries(_) > 0;
		});
		if (confEnabled.length === 0) throw new Error(locale.format(module, "noConfEnabled"));


		// select corresponding runtimes in x3solution
		var servers = batchSrvInst.x3solution(_).getServersByDescription(_, confEnabled.map_(_, function(_, r) {
			return r.description(_);
		}));
		var srvDescriptions = servers.map_(_, function(_, s) {
			return s.description(_);
		});

		this.srvQueue = ez.devices.queue();
		// watch missing servers to alert with trace and/or diagnoses
		confEnabled.forEach_(_, function(_, conf) {
			if (srvDescriptions.indexOf(conf.description(_)) === -1) {
				var msg = locale.format(module, "srvNotAvailable", conf.description(_));
				diagnoses && diagnoses.push({
					$severity: "warning",
					$message: msg
				});
				tracer.debug && tracer.debug("[" + self.code + "] " + msg);
			} else {

				var srv = servers.filter_(_, function(_, s) {
					return s.description(_) === conf.description(_);
				})[0];
				if (srv && conf.maxQueries(_) > 0) {
					cl[srv.description(_)] = null;
					self.qAdd(_, diagnoses, [{
						server: srv,
						maxQueries: conf.maxQueries(_)
					}]);
				}

			}
		});

		return batchSrvInst;
	},
	start: function(_, diagnoses, batchSrvInst) {

		try {
			this._stopShutdownLoop(_); // in case of shutdown loop running
			tracer.info && tracer.info("############## [" + this.code + "]  Batch server starting ##############");
			batchSrvInst = this._init(_, diagnoses, batchSrvInst);
			if (batchSrvInst === null) {
				return; // already started
			}
			if (this.srvQueue && this.srvQueue.contents().length === 0) {
				var errMsg = locale.format(module, "noAdmClientCreated");
				tracer.error && tracer.error(errMsg);
				diagnoses && diagnoses.push({
					$severity: "warning",
					$message: errMsg
				});
				this.status = "stopped";
				batchSrvInst.status(_, "stopped");
				batchSrvInst.save(_);
				// do not stop the batch server anymore.
				// if a network problem appears, it will continue when problem solved
				//this.stop(_, diagnoses, batchSrvInst);
				return batchSrvInst;
			}
			// NOT USE ANYMORE !!!
			// propagate configuration on one server only
			// this._mngtAllParSet(_, diagnoses, this.adminClients[Object.keys(this.adminClients)[0]]);


			// synchronize already pending queries
			var queries = this._listQueries(_, {
				where: "FLAG in (2, 5)"
			});
			// store previously launched queries to be able to check their statuses if stop service is called
			this.previousQueries = queries.map(function(q) {
				return q.NUMREQ;
			});
			if (this.srvQueue) {
				// store these queries into servers conf
				this.srvQueue.adjust(function(arr) {
					return arr.map(function(s) {
						queries.filter(function(q) {
							return (q.SERVER.toLowerCase() + ":" + q.PORT) === s.descr;
						}).forEach(function(q) {
							s._queries.push(q);
						});
						return s;
					});
				});

				tracer.info && tracer.info("[" + this.code + "] X3 batch clients initialized: " + JSON.stringify(Object.keys(this.adminClients)));

				this.status = "running";
				batchSrvInst.status(_, "running");
				batchSrvInst.save(_);

				tracer.info && tracer.info("############## [" + this.code + "]  Batch server started ##############\n");
				// start watching queries
				this._launchWatchLoop(_);
			}
		} catch (e) {
			console.error(e.stack);
			// stop the batch server if config propagation failed
			this.stop(_, null, batchSrvInst);
			if (e instanceof X3BatchException) {
				return;
			}

			diagnoses && diagnoses.push({
				$severity: "error",
				$message: e.message,
				$stackTrace: e.safeStack
			});
			tracer.error && tracer.error("[" + this.code + "] " + e.message);
		}
		return batchSrvInst;
	},
	// set a timeout which can be interrupted. When interrupted, the callback function will
	// receive 'true' as second argument
	setInterruptibleTimeout: function(callback, time, descr) {
		var self = this;
		if (self.timeouts[descr]) self.interrupt(descr);
		var t = setTimeout(function() {
			delete self.timeouts[descr];
			console.log("SIT1", descr);
			return callback();
		}, time);
		t._syrCallback = callback;
		self.timeouts[descr] = t;
	},
	// interrupt named timeout
	interrupt: function(descr) {
		var t = this.timeouts[descr];
		if (t) {
			clearTimeout(t);
			process.nextTick(function() {
				return t._syrCallback(undefined, true);
			});
			delete this.timeouts[descr];
			return true;
		}
	},
	// interrupt all pending timeouts
	interruptAll: function() {
		var self = this;
		Object.keys(this.timeouts).forEach(function(t) {
			return self.interrupt(t);
		});
	},
	stopAll: function(_, diagnoses, batchSrvInst) {
		return this.stop(_, diagnoses, batchSrvInst, true);
	},
	stop: function(_, diagnoses, batchSrvInst, stopPendings) {
		tracer.info && tracer.info("############## [" + this.code + "]  Batch server stopping ##############");
		try {
			batchSrvInst = batchSrvInst || this.db.fetchInstance(_, this.db.model.getEntity(_, "batchServer"), {
				jsonWhere: {
					code: this.code
				}
			});
			this.status = "stopping";
			batchSrvInst.status(_, "stopping");
			batchSrvInst.save(_);

			// stop watching queries
			this._stopWatchLoop();

			var firstClientIndex = 0;
			var pendingQueries = this.listPendingQueries();

			// stop pendings queries if stop all has been called
			if (stopPendings) {
				this._mngtStopServReq(_, diagnoses);
			}
			// else launch shutdown loop and keep only one administrative client
			else {
				if (this.adminClients) {
					var cliDescr = Object.keys(this.adminClients)[0];
					var cliToKeepAlive = this.adminClients[cliDescr];
					if (cliToKeepAlive) {
						diagnoses && diagnoses.push({
							$severity: "warning",
							$message: locale.format(module, "keepAdmClientAlive", cliDescr, cliToKeepAlive.pid)
						});
						firstClientIndex = 1; // in this case, we keep one administrative client to be able to ask queries statuses					
						this._launchShutdownLoop();
					}
				}
			}

			// disconnect all administrative clients
			this._disconnectAllAdminClients(_, diagnoses, firstClientIndex);

			if (!this.shutdownInterval && pendingQueries.length === 0) {
				this.status === "stopped";
				this._setBatchInstanceStopped(_, batchSrvInst);
			} else if (pendingQueries.length > 0) {
				tracer.info && tracer.info("[" + this.code + "] " + pendingQueries.length + " queries are still pendings in memory");
			}
		} catch (e) {
			console.error(e.stack);
			diagnoses && diagnoses.push({
				$severity: "error",
				$message: e.message
			});
		}
		return batchSrvInst;
	},
	listPendingQueries: function() {
		var result = [];

		function _push(q) {
			result.push(q);
		}
		if (this.srvQueue) {
			this.srvQueue.contents().forEach(function(curr) {
				curr._queries.forEach(_push);
			});
		}
		return result;
	},
	_disconnectClient: function(_, diagnoses, cli) {
		if (cli) {
			try {
				cli.disconnect(_);
				var msg = locale.format(module, "clientDisconnected", cli.pid, cli.x3server.description(_));
				diagnoses && diagnoses.push({
					$severity: "success",
					$message: msg
				});
				tracer.info && tracer.info("[" + this.code + "] " + msg);

			} catch (e) {
				tracer.error && tracer.error("[" + this.code + "] Disconnection failed on client " + (cli && cli.pid));
			}
		}
	},
	_disconnectAllAdminClients(_, diagnoses, keep) {
		if (this.adminClients) {
			var cliList = Object.keys(this.adminClients);
			this.interruptAll(); // clear all pending attempts to start admin clients
			for (var i = ~~keep; i < cliList.length; i++) {
				//console.error("CLIENTS: "+JSON.stringify(cliList,null,2));
				var cli = this.adminClients[cliList[i]];
				delete this.adminClients[cliList[i]];
				this._disconnectClient(_, diagnoses, cli);
			}
		}
	},
	_setBatchInstanceStopped: function(_, batchSrvInst) {
		try {
			this._stopShutdownLoop(_);
			// disconnect all administrative clients
			this._disconnectAllAdminClients(_, null);
			// finally flush the clients map
			this.adminClients = {};
			this.srvQueue = null;
			// stop instance
			var bs = batchSrvInst || this.db.fetchInstance(_, this.db.model.getEntity(_, "batchServer"), {
				jsonWhere: {
					code: this.code
				}
			});
			if (!bs) throw new Error(locale.format(module, "noBatchServer", this.code));
			tracer.info && tracer.info("############## [" + this.code + "]  Batch server stopped ##############\n");
			bs.status(_, "stopped");
			bs.save(_);
		} finally {
			removeBatchClient(this.code);
		}
	},
	_createAdminClient: function(_, diagnoses, srvConf, options) {
		options = options || {};
		var admCli;
		// create as many client as we have x3 runtimes
		var retries = retryCount + 1;
		while (--retries >= 0) {
			try {
				admCli = this._createClient(_, diagnoses, {
					x3server: this._getX3Server(_, srvConf.$uuid),
					localePref: this.localePref,
					user: this.ctrlLogin,
					folder: this.refFolder,
					license: this.license
				});
				if (!admCli && retryInterval > 0) {
					tracer.warn && tracer.warn("############## [" + srvConf.descr + "]  admCli could not be created, try again");
					if (!this.setInterruptibleTimeout(_, retryInterval, srvConf.descr))
						continue;
				}
			} catch (e) {
				if (retryInterval > 0) {
					tracer.warn && tracer.warn("############## [" + srvConf.descr + "]  Error when starting, try again: " + e);
					if (!this.setInterruptibleTimeout(_, retryInterval, srvConf.descr))
						continue;
				}
				throw e;
			}
			break; // client generated or no retry interval set: no need to retry
		}
		if (admCli) {
			var client = admCli.client;
			// license is stored to be reused by every queries execution
			if (!this.license) {
				// when license check for this endpoint is necessary but license not available, this is an error
				if (admCli.session && !admCli.session.noLicense && !admCli.session.license)
					throw new Error(locale.format(module, "licenseError", srvConf.descr));
				this.license = admCli.session && admCli.session.license;
			}
			var successMsg = locale.format(module, "clientCreated", client.pid, srvConf.descr);
			tracer.info && tracer.info("[" + this.code + "] " + successMsg);
			diagnoses && diagnoses.push({
				$severity: "info",
				$message: successMsg
			});

			// put conf in client itself ; this will be useful to recreate client when steam will be closed unexpectedly
			client._srvConf = srvConf;
			// store administrative client
			this.adminClients[srvConf.descr] = client;
			this.totalMaxQueries += srvConf._maxQueries;
		} else {
			var errConnMsg = locale.format(module, "x3ConnectionFailed", srvConf.descr);
			tracer.error && tracer.error("[" + this.code + "] " + errConnMsg);
			diagnoses && diagnoses.push({
				$severity: "error",
				$message: errConnMsg
			});
		}
	},
	_createClient: function(_, diagnoses, options) {
		try {
			return batchHelper.connectX3Client(_, this._getX3Solution(_), options);
		} catch (e) {
			if (e.$diagnoses) {
				if (diagnoses) {
					e.$diagnoses.forEach(function(d) {
						diagnoses.push(d);
					});
				}
			} else {
				diagnoses && diagnoses.push({
					$severity: "error",
					$message: e.message,
					$stackTrace: e.safeStack
				});
				e.$diagnoses = [{
					$severity: "error",
					$message: e.message,
					$stackTrace: e.safeStack
				}];
			}
			tracer.error && tracer.error("[" + this.code + "] X3 client connection failed: " + JSON.stringify(e.$diagnoses, null, 2));
			throw e;
		}
	},
	_getAdminClient: function(_, descr) {
		if (!descr) {
			descr = Object.keys(this.adminClients)[0];
		}
		var cli = this.adminClients[descr];
		if (!cli) {
			try {
				var srvConf = this.srvQueue.contents().filter(function(conf) {
					return conf.descr === descr;
				})[0];
				tracer.info && tracer.info("[" + this.code + "] Administrative client not found for [" + descr + "].\nTry to create a new one with the following configuration: " + JSON.stringify(srvConf, null, 2));
				cli = this._createAdminClient(_, null, srvConf);
			} catch (e) {
				tracer.warn && tracer.warn("[" + this.code + "] Create administrative client failed on '" + descr + "'.\n" + e.stack);
			}
		} else if (cli && !cli.isAlive()) {
			tracer.warn && tracer.warn("[" + this.code + "] Administrative client on '" + cli.x3server.description(_) + "' fall... Try to reconnect it");
			this.totalMaxQueries -= cli._srvConf._maxQueries;
			try {
				cli = this._createAdminClient(_, null, cli._srvConf);
			} catch (e) {
				this.adminClients[descr] = undefined;
				tracer.warn && tracer.warn("[" + this.code + "] Reconnection try failed on '" + cli.x3server.description(_) + "'.\n" + e.message);
			}
		}
		return cli;
	},
	_getX3Solution: function(_) {
		var solution = this.db.fetchInstance(_, this.db.model.getEntity(_, "x3solution"), {
			jsonWhere: {
				code: this.x3solutionCode
			}
		});
		if (!solution) throw new Error("No X3 solution found with code '" + this.x3solutionCode + "'");
		return solution;
	},
	_getX3Server: function(_, uuid, options) {
		options = options || [];
		var sol = this._getX3Solution(_);
		var servers = sol.runtimes(_).toArray(_).filter_(_, function(_, s) {
			return s.$uuid === uuid;
		});
		if (servers.length === 0) throw new Error("No X3 server found with uuid '" + uuid + "'");
		return servers[0];
	},
	// this is generic helper used by nanny !!!
	applyChanges: function(_, diagnoses, batchSrvInst, changes) {
		//console.error("ON THE FLY: "+JSON.stringify(changes,null,2));
		var changesKeys = Object.keys(changes);
		for (var j = 0; j < changesKeys.length; j++) {
			var func = changesKeys[j];
			var data = changes[func];
			if (this[func]) this[func](_, diagnoses, data);
		}
	},
	qRemove: function(_, diagnoses, uuids) {
		tracer.debug && tracer.debug("[" + this.code + "] Try to remove configurations");
		var self = this;
		try {
			var servers = {};
			this.srvQueue.adjust(function(arr) {
				return arr.filter(function(s) {
					if (uuids.indexOf(s.$uuid) !== -1) {
						tracer.warn && tracer.warn("[" + self.code + "] Server '" + s.descr + "' is removed from batch server list");
						servers[s.descr] = true;
						if (self.adminClients[s.descr] != null) {
							self.totalMaxQueries -= s._maxQueries;
							tracer.info && tracer.info("[" + self.code + "] Administrative client found and total max queries decreased to " + self.totalMaxQueries);
						}

						return false;
					}
					return true;
				});
			});

			var srvKeys = Object.keys(servers);
			for (var i = 0; i < srvKeys.length; i++) {
				var descr = srvKeys[i];
				var mustDisconnect = servers[descr];

				if (mustDisconnect) {
					this.interrupt(descr); // maybe in loop to create client: stop this
					if (this.adminClients[descr] && this.adminClients[descr].isAlive()) {
						this.adminClients[descr].disconnect(_);
						var msgDisc = locale.format(module, "clientDisconnected", this.adminClients[descr].pid, descr);
						tracer.info && tracer.info("[" + this.code + "] " + msgDisc);
						diagnoses && diagnoses.push({
							$severity: "info",
							$message: msgDisc
						});
					}
					delete this.adminClients[descr];
				}
				var msgDel = locale.format(module, "hostDeleted", descr);
				tracer.info && tracer.info("[" + this.code + "] " + msgDel);
				diagnoses && diagnoses.push({
					$severity: "warning",
					$message: msgDel
				});
			}
		} catch (e) {
			console.error("[" + this.code + "] An error occured when purging server where we can't connect\n" + e.stack);
		}
	},
	// confs is an array of objects : [{server: x3serverInstance, maxQueries: 3}, {server: x3srvUuid, maxQueries: 2}, ...]
	qAdd: function(_, diagnoses, confs) {
		tracer.debug && tracer.debug("[" + this.code + "] Try to add new configurations");
		for (var i = 0; i < confs.length; i++) {
			var conf = confs[i];
			if (conf.server && conf.maxQueries) {
				// if server is uuid --> fetch it
				var server = typeof conf.server === "string" ? this._getX3Server(_, conf.server) : conf.server;
				var srvConf = {
					$uuid: server.$uuid,
					descr: server.description(_).toLowerCase(),
					_maxQueries: conf.maxQueries, // set max number
					_queries: [], // init array
					_isMain: server.isMain(_)
				};
				this.srvQueue.put(srvConf);
				try {
					this._createAdminClient(_, diagnoses, srvConf);
				} catch (e) {
					tracer.error && tracer.error("[" + this.code + "] Create connection failed: " + e.message + e.stack);
					this.qRemove(_, null, [srvConf.$uuid]);
					return;
				}
				var msg = locale.format(module, "hostInserted", srvConf.descr, conf.maxQueries);
				tracer.info && tracer.info("[" + this.code + "] " + msg);
				diagnoses && diagnoses.push({
					$severity: "info",
					$message: msg
				});
			} else {
				throw new Error("Cannot add server in queue... server and maxQueries parameter must be provided.");
			}
		}
	},
	// confs is an array of objects : [{server: x3serverInstance, maxQueries: 3}, {server: x3srvUuid, maxQueries: 2}, ...]
	qUpdate: function(_, diagnoses, confs) {
		tracer.info && tracer.info("[" + this.code + "] Try to update existing configurations: " + JSON.stringify(confs, null, 2));
		for (var j = 0; j < confs.length; j++) {
			var conf = confs[j];
			if (conf.server && conf.maxQueries) {
				// if server is uuid --> fetch it
				var server = typeof conf.server === "string" ? this._getX3Server(_, conf.server) : conf.server;

				var alreadyExists = false;
				for (var i = 0; i < this.srvQueue.contents().length; i++) {
					var s = this.srvQueue.contents()[i];
					if (s.$uuid === server.$uuid) {
						// conf already exists into queue
						alreadyExists = true;
						if (conf.maxQueries != null) {
							this.totalMaxQueries -= s._maxQueries;
							this.totalMaxQueries += conf.maxQueries;
							s._maxQueries = conf.maxQueries;
						}
						var oldDescr = s.descr;
						if (s._isMain !== server.isMain(_)) s._isMain = server.isMain(_);

						// if host or port changed, we must disconnect administrative client and recreate new one
						if (conf.reconnect) {
							s.descr = server.description(_);
							this.interrupt(oldDescr); // maybe in loop to create client: stop this
							if (this.adminClients[oldDescr] && this.adminClients[oldDescr].isAlive()) {
								this.adminClients[oldDescr].disconnect(_);
								var msgDisc = locale.format(module, "clientDisconnected", this.adminClients[oldDescr].pid, oldDescr);
								tracer.info && tracer.info("[" + this.code + "] " + msgDisc);
								diagnoses && diagnoses.push({
									$severity: "info",
									$message: msgDisc
								});
							}
							delete this.adminClients[oldDescr];
							// create new administrative connection
							try {
								this.totalMaxQueries -= conf.maxQueries;
								this._createAdminClient(_, diagnoses, s);
							} catch (e) {
								tracer.error && tracer.error("[" + this.code + "] Change connection failed: " + e.message);
								this.qRemove(_, null, [s.$uuid]);
								return;
							}
						}

						var msg = locale.format(module, "hostUpdated", server.description(_), conf.maxQueries);
						tracer.info && tracer.info("[" + this.code + "] " + msg);
						diagnoses.push({
							$severity: "info",
							$message: msg
						});
						break;
					}
				}
				if (!alreadyExists && conf.maxQueries > 0) {
					this.qAdd(_, diagnoses, [{
						server: server,
						maxQueries: conf.maxQueries
					}]);
				}
			}
		}
	},
	_launchShutdownLoop: function() {
		// execute watch function every execInterval time
		this.shutdownInterval = flows.setInterval(this._executeShutdownLoop.bind(this), this.execInterval * 1000);
		tracer.info && tracer.info("[" + this.code + "] Shutdown loop enabled to check pending queries status before stopping batch server");
	},
	_stopShutdownLoop: function(_) {
		if (this.shutdownInterval) {
			// stop shutdown loop
			clearInterval(this.shutdownInterval);
			this.shutdownInterval = null;
			tracer.info && tracer.info("[" + this.code + "] Shutdown loop disabled");
			if (this.adminClients)
				this._disconnectClient(_, null, this.adminClients[0]);
		}
	},
	_launchWatchLoop: function(_) {
		// execute one first time to not have to wait for scheduling...
		this._executeControlLoop(!_);
		// execute watch function every execInterval time
		this.loopInterval = flows.setInterval(this._executeControlLoop.bind(this), this.execInterval * 1000);
		tracer.info && tracer.info("[" + this.code + "] Queries listener is enabled and will handle " + this.totalMaxQueries + " queries every " + this.execInterval + " seconds");
	},
	_stopWatchLoop: function() {
		if (this.loopInterval) {
			// stop watch loop
			clearInterval(this.loopInterval);
			this.loopInterval = null;
			tracer.info && tracer.info("[" + this.code + "] Queries listener disabled");
		}
	},
	_sdataRequest: function(_, diagnoses, client, url, alias, method, body, options) {
		options = options || {};
		options.prefix = "[" + this.code + "] ";
		return batchHelper.sdataRequest(_, diagnoses, client, url, alias, method, body, options);
	},
	_execRpc: function(_, diagnoses, client, mod, name, method, body, options) {
		options = options || {};
		options.prefix = "[" + this.code + "] ";
		return batchHelper.execRpc(_, diagnoses, client, this.refUrl, mod, name, method, body, options);
	},
	/*// Obsolete since killOverTime and maxDelay are passed in necessary payloads
	_mngtAllParSet: function(_, diagnoses, client) {
		this._execRpc(_, diagnoses, client, "ASYRSRVBATCH", "ABATCH_MNGT_ALLPARSET", "POST", {
			execInterval: this.execInterval,
			killOverTime: this.killOverTime,
			maxDelay: this.maxDelay
		}, {
			throwErr: true
		});
	},
	*/
	_mngtStopServReq: function(_, diagnoses) {
		for (var i = 0; i < this.srvQueue && this.srvQueue.contents().length; i++) {
			var srvConf = this.srvQueue.contents()[i];
			var cli = this._getAdminClient(_, srvConf.descr);
			if (cli) {
				this._execRpc(_, diagnoses, cli, "ASYRSRVBATCH", "ABATCH_STOP_SERVREQ", "POST", {
					server: cli.x3server.serverHost(_),
					port: cli.x3server.serverPort(_),
					maxDelay: this.maxDelay
				});
			}
		}
	},
	_mngtServReq: function(_, diagnoses) {
		if (!this.srvQueue) return;
		for (var i = 0; this.srvQueue && i < this.srvQueue.contents().length; i++) {
			var srvConf = this.srvQueue.contents()[i];
			var cli = this._getAdminClient(_, srvConf.descr);
			if (cli) {
				this._execRpc(_, diagnoses, cli, "ASYRSRVBATCH", "ABATCH_MNGT_SERVREQ", "POST", {
					server: cli.x3server.serverHost(_),
					port: cli.x3server.serverPort(_),
					maxDelay: this.maxDelay
				});
				this._refreshPendingQueries(_, cli._srvConf);
			}
		}
	},
	_mngtAllReq: function(_, diagnoses) {
		this._execRpc(_, diagnoses, this._getAdminClient(_), "ASYRSRVBATCH", "ABATCH_MNGT_ALLREQ", "POST", {});
	},
	_mngtAllErr: function(_, diagnoses, numreq, diags) {
		var self = this;
		diags.forEach_(_, function(_, d) {
			self._execRpc(_, diagnoses, self._getAdminClient(_), "ASYRSRVBATCH", "ABATCH_MNGT_ALLERR", "POST", {
				numreq: numreq,
				$severity: d.$severity,
				$message: d.$message
			});
		});
	},
	_listQueries: function(_, params, options) {
		params = params || {};
		options = options || {};
		var _representation = options.representation || "ASYRREQ";
		params.representation = _representation + ".$query";
		//
		var url = this.refUrl + "/" + _representation + "?" + querystring.stringify(params);
		var resp = this._sdataRequest(_, null, this._getAdminClient(_), url, _representation, "GET", {}, options);
		return (resp && resp.$resources) || [];
	},
	_stopAllRecurrent: function(_, diagnoses, folderName) {
		for (var i = 0; i < this.srvQueue.contents().length; i++) {
			var srvConf = this.srvQueue.contents()[i];
			this._stopRecurrent(_, diagnoses, folderName, srvConf);
		}
	},
	_stopRecurrent: function(_, diagnoses, folderName, srvConf) {
		var cli = this._getAdminClient(_, srvConf.descr);
		if (cli) this._execRpc(_, diagnoses, cli, "ASYRSRVBATCH", "ABATCH_STOP_RECURRENT", "POST", {
			server: cli.x3server.serverHost(_),
			port: cli.x3server.serverPort(_),
			folder: folderName,
			maxDelay: this.maxDelay
		});
	},
	_execQuery: function(_, srvConf, query, options) {
		var self = this;
		options = options || {};
		options.throwErr = true;


		if (query.MONO) {
			if (!this.monoPendings[query.DOSSIER]) {

				this.monoPendings[query.DOSSIER] = query.NUMREQ;

				// call X3 service ABATCH_STOP_RECURRENT to ask to stop all recurrent requests
				this._stopAllRecurrent(_, null, query.DOSSIER);
			}

			var pendingOnFolder = this._listQueries(_, {
				where: "(DOSSIER eq '" + query.DOSSIER + "')",
				orderBy: "FLAG desc,DAT asc,HEURE asc,NUMREQ asc"
			}, {
				noTraces: lightDebugTraces,
				representation: "ASYRREQPEND",
				throwErr: true
			});

			// If recurrent are still pending ; force call stopRecurrent
			var recurrentOnFolder = pendingOnFolder.filter(function(q) {
				return q.RECURRENT;
			});
			if (recurrentOnFolder.length > 0) {
				tracer.warn && tracer.warn("[" + this.code + "] Some recurrent requests have not been killed on '" + query.DOSSIER + "'");
				var srvDescrs = recurrentOnFolder.reduce(function(prev, curr) {
					var descr = curr.SERVER.toLowerCase() + ":" + curr.PORT;
					if (prev.indexOf(descr) === -1) {
						prev.push(descr);
					}
					return prev;
				}, []);
				srvDescrs.forEach_(_, function(_, descr) {
					var srvConf = self.srvQueue.contents().filter(function(conf) {
						return conf.descr === descr;
					})[0];
					if (!srvConf) {
						tracer.warn && tracer.warn("[" + self.code + "] Stop recurrent can't be called on '" + descr + "' because server not available");
					} else {
						self._stopRecurrent(_, null, query.DOSSIER, srvConf);
					}
				});
			}

			var monoFound = false;
			pendingOnFolder = pendingOnFolder.filter(function(q) {
				var isMyMono = (q.NUMREQ === query.NUMREQ);
				monoFound = monoFound || isMyMono;
				return !isMyMono;
			});
			if (!monoFound) {
				tracer.warn && tracer.warn("[" + self.code + "] Mono not retrieved in list and has probably been deleted");
				return;
			}

			tracer.info && tracer.info("[" + self.code + "] Consider mono " + query.NUMREQ + " - check pending or waiting requests : '" + query.DOSSIER + "': " + JSON.stringify(pendingOnFolder.map(function(q) {
				return q.NUMREQ;
			})));

			if (pendingOnFolder.length > 0) {
				tracer.info && tracer.info("[" + this.code + "] Some requests are pending or waiting on folder '" + query.DOSSIER + "', then the mono '" + query.NUMREQ + "' can't be executed now");
				return;
			} else {
				tracer.info && tracer.info("[" + this.code + "] No requests are pending or waiting on folder '" + query.DOSSIER + "', then the mono '" + query.NUMREQ + "' can be executed");
			}

		}

		// SAM 
		//		else if (this.monoPendings[query.DOSSIER]) {
		//			tracer.info && tracer.info("[" + this.code + "] Mono request '" + this.monoPendings[query.DOSSIER] + "' is pending or waiting on folder '" + query.DOSSIER + "', then the query '" + query.NUMREQ + "' can be executed");
		//			return;
		//		}

		var cli = this._createClient(_, null, {
			x3server: this._getX3Server(_, srvConf.$uuid),
			lang: query.LAN,
			user: query.LOGIN,
			folder: query.DOSSIER,
			localePref: batchHelper.getLocalePrefFromIso(_, query.LANISO),
			license: this.license
		}).client;

		tracer.info && tracer.info("[" + this.code + "] Execute query " + (query.MONO ? " (MONO) " : "") + "'" + query.NUMREQ + "' on server " + srvConf.descr + " with client '" + cli.pid + "'");
		var url = "/sdata/x3/erp/" + query.DOSSIER + "/$service/batch?requestId=" + query.NUMREQ;
		// Ask X3 to execute query
		this._sdataRequest(function(err) {
			if (err) {
				self._listQueries(function(err2, _q) {
					if (err2) tracer.error && tracer.error("[" + self.code + "] Error when listing queries to get interruption reason: " + err2.stack);
					if (_q && _q.length && (_q[0].FLAG === 5 || _q[0].FLAG === 6)) {
						tracer.warn && tracer.warn("[" + self.code + "] The query '" + query.NUMREQ + "' has been aborted");
					} else {
						tracer.error && tracer.error("[" + self.code + "] An error occured when executing query '" + query.NUMREQ + "': " + err.stack);
						self._mngtAllErr(function(err3) {
							if (err3) tracer.error && tracer.error("[" + self.code + "] Error raising error to X3: " + err3.stack);
						}, null, query.NUMREQ, [{
							$severity: "error",
							$message: err.message + (err.stack ? "\nStacktrace: " + err.stack : "")
						}]);
					}
				}, {
					where: "(NUMREQ eq " + query.NUMREQ + ")"
				}, {
					noTraces: lightDebugTraces
				});
			}
			if (cli && cli.isAlive()) {
				tracer.info && tracer.info("[" + self.code + "] Disconnect batch client " + cli.pid);
				cli.disconnect(flows.ignore);
				cli = null;
			}
			// remove pending requests from memory
			srvConf._queries.splice(srvConf._queries.findIndex(function(q) {
				if (q.NUMREQ === query.NUMREQ) {
					// remove Mono from memory map
					if (query.MONO && self.monoPendings[query.DOSSIER] === query.NUMREQ) {
						delete self.monoPendings[query.DOSSIER];
					}
					return true;
				}
			}), 1);

			// if batch server is currently stopping and there are no other request pending
			if (self.status === "stopping" && self.listPendingQueries().length === 0) {
				self.status === "stopped";
				// if administrative client are also stopped
				if (Object.keys(self.adminClients).length < 2) {
					self._setBatchInstanceStopped(flows.ignore);
				}
			}

		}, null, cli, url, "Batch request " + query.NUMREQ, "POST", {
			maxDelay: this.maxDelay,
			ctrlFolder: this.refFolder,
			ctrlLogin: this.ctrlLogin,
			ctrlLanIso: this.ctrlLanIso
		}, options);
		// add the query number in server instance
		srvConf._queries.push(query);
	},
	_refreshPendingQueries: function(_, _srvConf) {
		// TODO: Split where to 15 NUMREQ max !!!
		var self = this;
		// if requests are pending on this server, we check their status and actualize the list on server instance
		var newPending = [];
		if (_srvConf._queries.length > 0) {
			// get the requests list with only previous launched requests numbers
			var temp = _srvConf._queries.map(function(q) {
				return q.NUMREQ;
			}).join(',');

			var queriesWhere = "(NUMREQ in (" + temp + "))";
			var queries = self._listQueries(_, {
				where: queriesWhere
			}, {
				noTraces: lightDebugTraces
			});
			queries.forEach_(_, function(_, query) {
				tracer.info && tracer.info("[" + self.code + "] Query " + query.NUMREQ + " status: " + query.FLAG);
				if (query.FLAG === 1 || query.FLAG === 2 || query.FLAG === 5) {
					// keep in array if still running (or waiting because just launched)
					newPending.push(query);
				} else {
					// if a mono ended, set endpoint free to launch new requests
					if (query.MONO) {
						if (self.monoPendings[query.DOSSIER] === query.NUMREQ) {
							delete self.monoPendings[query.DOSSIER];
						}
					}
				}
			});
		}
		// this check is mandatory for deleted mono requests
		Object.keys(this.monoPendings).forEach_(_, function(_, k) {
			var monoNum = self.monoPendings[k];
			var _queries = self._listQueries(_, {
				where: "(NUMREQ eq " + monoNum + ")"
			}, {
				noTraces: lightDebugTraces
			});
			if (_queries.length === 0) delete self.monoPendings[k];
		});

		_srvConf._queries = newPending;
		tracer.info && tracer.info("[" + this.code + "] Pending queries on " + _srvConf.descr + ": " + _srvConf._queries.length + "/" + _srvConf._maxQueries + " " + JSON.stringify(_srvConf._queries.map(function(q) {
			return q.NUMREQ;
		})));
	},
	_executeControlLoop: function(_) {

		function _selectServer(_, mainOnly) {

			var srvConf;
			// select Main server if available (set in the config with a maxQueries parameter)				
			var nbSrvConcerned = 0;
			if (mainOnly && self.srvQueue.contents().length > 1) {
				self.srvQueue.adjust(function(arr) {
					return arr.sort(function(srvA, srvB) {
						if (srvA._isMain) {
							nbSrvConcerned++;
							return -1;
						} else if (srvB._isMain) {
							nbSrvConcerned++;
							return 1;
						}
						return 0;
					});
				});
			} else if (!(mainOnly && self.srvQueue.contents().length === 1 && !self.srvQueue.contents()[0]._isMain)) {
				nbSrvConcerned = self.srvQueue.contents().length;
			}
			//console.error("QUEUE ORDER: "+JSON.stringify(self.srvQueue.contents().map(function(s) {return s.descr;}),null,2));
			// if first server is not MAIN and request must be executed on main
			if (mainOnly && nbSrvConcerned === 0) {
				tracer.warn && tracer.warn("[" + self.code + "] No Main server available");
				throw new Error(locale.format(module, "noMainSrv"));
			}
			for (var i = 0; i < nbSrvConcerned; i++) {
				// pop a server from the queue
				srvConf = self.srvQueue.read(_);

				if (mainOnly && nbSrvConcerned === 1 && !srvConf._isMain) {
					tracer.warn && tracer.warn("[" + self.code + "] No Main server available");
					throw new Error(locale.format(module, "noMainSrv"));
				}


				// get srv instance
				var srv = self._getX3Server(_, srvConf.$uuid);
				// refresh pending requests list
				self._refreshPendingQueries(_, srvConf);
				if (srv.disabled(_) || srv.banned(_)) {
					tracer.warn && tracer.warn("[" + self.code + "] The server '" + srvConf.descr + "' is not available and will be removed from batch controller list");
					// put again in the queue to remove properly
					self.srvQueue.put(srvConf);
					self.qRemove(_, null, [srv.$uuid]);
				} else if (srvConf._queries.length < srvConf._maxQueries) {
					// if max number of concurrent queries is not reached for this server, return the server
					// the server instance will be put again in the queue after the launch of the query
					tracer.info && tracer.info("[" + self.code + "] Select (" + (mainOnly ? "MAIN" : "LB") + ") '" + srvConf.descr + "' server: pending: " + srvConf._queries.length + " - max: " + srvConf._maxQueries);
					return srvConf;
				} else {
					// if max number of concurrent queries is reached for this server, put the server again in the queue
					tracer.warn && tracer.warn("[" + self.code + "] Ignore (because is full) '" + srvConf.descr + "' server: pending: " + srvConf._queries.length + " - max: " + srvConf._maxQueries);
					// console.error("MAX QUERIES REACHED SO PUT THE SRV CONF IN THE QUEUE");
					self.srvQueue.put(srvConf);
				}
			}
			tracer.warn && tracer.warn("[" + self.code + "] No free slot found on servers");

		}
		//
		//
		if (!this.loopRunning) {
			this.loopRunning = true;
			var self = this;
			tracer.info && tracer.info("============== [" + this.code + "]  begin control loop ==============");
			tracer.info && tracer.info("[" + this.code + "] The batch controller can handle " + this.totalMaxQueries + " queries simultaneously");

			//console.error("Before Servers queue contents: " + JSON.stringify(this.srvQueue.contents(), null, 2));

			try {
				if (this.checkTimeout === 0 || this.checkTimeout >= this.killOverTime) {
					this._mngtServReq(_); // first call see specification
					this._mngtAllReq(_); // second call see specification
					this.checkTimeout = 0;
				} else {
					tracer.info && tracer.info("[" + this.code + "] CheckTimeout (" + this.checkTimeout + ") didn't exceed killOverTime... Ignore servReq step");
				}

				var queries = this._listQueries(_, {
					count: this.totalMaxQueries,
					orderBy: "FLAG desc,DAT asc,HEURE asc,NUMREQ asc"
				}, {
					// ASYRREQPEND allows to get only requests :
					// - not concerned by folder busy by mono requests
					// - EXENOW eq true
					representation: "ASYRREQPEND"
				});

				// consider only request with "stand by" status (1) and EXENOW flag set (that means the execution datetime is reached)
				queries = queries.filter(function(q) {
					return q.FLAG === 1 && q.EXENOW === true;
				});
				tracer.info && tracer.info("[" + self.code + "] Nb queries to execute (" + queries.length + ") " + queries.map(function(q) {
					return q.NUMREQ;
				}));

				var queriesWaiting = [];
				for (var i = 0; i < queries.length; i++) {
					var query = queries[i];
					tracer.info && tracer.info("************** [" + self.code + "] Begin to consider query " + query.NUMREQ + "**************");

					var selectedConf;
					try {
						selectedConf = _selectServer(_, query.MAISRV);
					} catch (e) {
						tracer.warn && tracer.warn("[" + this.code + "] " + e.message);
						queriesWaiting.push(query.NUMREQ);
					} finally {
						// put the server instance in the queue
						// console.error("Put server configuration into the queue");
						if (selectedConf && this.srvQueue) this.srvQueue.put(selectedConf);
					}
					if (selectedConf) {
						try {
							// simulation mode can be used to test server selection algorithm but to not execute queries
							if (!simulation) {
								this._execQuery(_, selectedConf, query);
							}
						} catch (e) {
							if (e instanceof X3BatchException) {
								tracer.error && tracer.error("[" + this.code + "] Query execution failed '" + query.NUMREQ + "' on server " + selectedConf.descr + "\n" + e.message);
							} else {
								tracer.error && tracer.error("[" + this.code + "] Query execution failed '" + query.NUMREQ + ": " + e.message);
								this._mngtAllErr(_, null, query.NUMREQ, e.$diagnoses || [{
									$severity: "error",
									$message: e.message
								}]);
							}
						}
					} else {
						queriesWaiting.push(query.NUMREQ);
					}
					tracer.info && tracer.info("************** [" + self.code + "] End to consider query " + query.NUMREQ + "**************");
				}
				if (queriesWaiting.length) {
					tracer.info && tracer.info("[" + self.code + "] Queries waiting for free servers: " + JSON.stringify(queriesWaiting));
				}
			} catch (e) {
				tracer.error && tracer.error("[" + this.code + "] An error occured during control loop\n" + e.stack);
			} finally {
				//console.error("After Servers queue contents: " + JSON.stringify(this.srvQueue.contents(), null, 2));

				tracer.info && tracer.info("============== [" + this.code + "]  end control loop ================\n");
				this.loopRunning = false;
				this.checkTimeout += this.execInterval;
			}
		} else {
			tracer.warn && tracer.warn("[" + this.code + "] previous loop not ended !!!"); // probably due to active debugger on X3 supervisor side
		}
	},
	_executeShutdownLoop: function(_) {
		if (!this.shLoopRunning) {
			// if already stopped by another way (should never been called)
			if (this.status === "stopped") {
				this._stopShutdownLoop(_);
				return;
			}
			this.shLoopRunning = true;
			tracer.info && tracer.info("============== [" + this.code + "]  begin shutdown loop ==============");
			try {
				var queries = this._listQueries(_, {
					where: "FLAG in (2, 5)"
				}).filter(function(q) {
					return !q.RECURRENT;
				});
				//console.error("QUERIES PENDING: "+JSON.stringify(queries,null,2));
				if (queries.length === 0) {
					this.status === "stopped";
					tracer.info && tracer.info("[" + this.code + "] No pending queries anymore"); // probably due to active debugger on X3 supervisor side
					this._setBatchInstanceStopped(flows.ignore);
				} else {
					tracer.info && tracer.info("[" + this.code + "] " + queries.length + " pending queries are not ended"); // probably due to active debugger on X3 supervisor side
				}
			} finally {
				tracer.info && tracer.info("============== [" + this.code + "]  end shutdown loop ================\n");
				this.shLoopRunning = false;
			}
		}
	}
});