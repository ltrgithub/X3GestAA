"use strict";

var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var tracer = require('syracuse-core').getTracer("batch");
var flows = require('streamline-runtime').flows;
var locale = require('streamline-locale');
var ez = require('ez-streams');
var querystring = require('querystring');
var x3client = require('syracuse-x3/lib/client');
var x3FolderHelper = require('syracuse-collaboration/lib/entities/lookupX3Folder');
var X3BatchException = require("syracuse-batch/lib/x3BatchException").X3BatchException;

var helpers = require('syracuse-core').helpers;
var config0 = require('config');
var globals = require('streamline-runtime').globals;
var multiTenant = (config0.hosting && config0.hosting.multiTenant);

// this flag enable more traces
var fullDebug = false;

// this map will retains all X3 batch clients
var bClients = {};

exports.getBatchClient = function(code) {
	if (multiTenant) {
		var tenantId = globals.context.tenantId;
		var bClients0 = bClients[tenantId];
		return bClients0 ? bClients0[code] : undefined;
	}
	//console.error("SERVERS KEYS: " + JSON.stringify(Object.keys(bClients), null, 2));
	return bClients[code];
};

function getLocalePrefFromX3Lang(_, lang) {
	var iso = locale.defaultIso(lang);
	if (!iso) throw new Error(locale.format(module, "langIncorrect", lang));
	return getLocalePrefFromIso(_, iso);
}

var localesMap = {};

function getLocalePrefFromIso(_, iso) {
	var db = adminHelper.getCollaborationOrm(_);
	if (iso.length === 2) iso = locale.longIso(iso);
	locale.setCurrent(_, iso);
	var codeIso = iso.substring(0, 3) + iso.substring(3).toUpperCase();
	tracer.debug && tracer.debug("Use language: " + codeIso);
	if (!localesMap[codeIso]) localesMap[codeIso] = db.fetchInstances(_, db.model.getEntity(_, "localePreference"), {
		jsonWhere: {
			code: codeIso
		}
	})[0];
	if (!localesMap[codeIso]) throw new Error("Can't find locale preference corresponding to '" + iso + "'");
	return localesMap[codeIso];
}

exports.X3BatchClient = helpers.defineClass(function() {}, null, {
	_init: function(_, context, batchSrvInst) {
		var self = this;
		this.db = adminHelper.getCollaborationOrm(_);
		this.x3solutionCode = batchSrvInst.x3solution(_).code(_);
		this.totalMaxQueries = 0;
		this.monoPendings = []; // datasets will be stored here to know if a mono request is pending
		//
		this.code = batchSrvInst.code(_);
		this.auto = batchSrvInst.auto(_);
		this.execInterval = batchSrvInst.execInterval(_);
		// the two following are only necessary for X3 side
		this.killOverTime = batchSrvInst.killOverTime(_);
		this.maxDelay = batchSrvInst.maxDelay(_);
		//

		this.refUrl = batchSrvInst.refUrl(_);
		if (!this.refUrl) throw new Error(locale.format("noRefEndpoint"));
		this.refUser = batchSrvInst.refUser(_) || "ADMIN";
		this.refLang = batchSrvInst.refLang(_) || "ENG";

		if (multiTenant) {
			var tenantId = globals.context.tenantId;
			var bClients0 = bClients[tenantId];
			if (!bClients0)
				bClients0 = bClients[tenantId] = {};
			bClients0[this.code] = this;
		} else {
			bClients[this.code] = this;
		}

		// consider configuration that match to configurations where maxQueries is > 0
		var confEnabled = batchSrvInst.runtimes(_).toArray(_).filter_(_, function(_, r) {
			return r.maxQueries(_) > 0;
		});
		if (confEnabled.length === 0) throw new Error(locale.format(module, "noConfEnabled"));


		// select corresponding runtimes in x3solution
		var servers = batchSrvInst.x3solution(_).getServersByDescription(_, confEnabled.map_(_, function(_, r) {
			return r.description(_);
		}));
		var srvDescriptions = servers.map_(_, function(_, s) {
			return s.description(_);
		});

		this.srvQueue = ez.devices.queue();
		// watch missing servers to alert with trace and/or diagnoses
		confEnabled.forEach_(_, function(_, conf) {
			if (srvDescriptions.indexOf(conf.description(_)) === -1) {
				var msg = locale.format(module, "srvNotAvailable", conf.description(_));
				context && context.instance && context.instance.$diagnoses.push({
					$severity: "warning",
					$message: msg
				});
				tracer.debug && tracer.debug("[" + self.code + "] " + msg);
			} else {

				var srv = servers.filter_(_, function(_, s) {
					return s.description(_) === conf.description(_);
				})[0];
				if (srv && conf.maxQueries(_) > 0) {
					self.srvQueue.put({
						descr: srv.description(_).toLowerCase(),
						_maxQueries: conf.maxQueries(_), // set max number
						_queries: [], // init array
						_isMain: srv.isMain(_)
					});
				}

			}
		});

		this.adminClients = this.srvQueue.contents().reduce(function(prev, curr) {
			prev[curr.descr] = null;
			return prev;
		}, {});

		this.initialized = true;
		return batchSrvInst;
	},
	start: function(_, context, batchSrvInst) {
		try {
			this._init(_, context, batchSrvInst);
		} catch (e) {
			console.error(e.stack);
			context && context.instance && context.instance.$diagnoses.push({
				$severity: "error",
				$message: e.message,
				$stackTrace: e.safeStack
			});
			tracer.warn && tracer.warn("[" + this.code + "] " + e.message);
			return batchSrvInst;
		}

		var servers = this.srvQueue.contents();
		for (var i = 0; i < servers.length; i++) {
			this._createAdminClient(_, context, batchSrvInst, servers[i]);
		}

		if (this.srvQueue.contents().length === 0) {
			var errMsg = locale.format(module, "noAdmClientCreated");
			tracer.error && tracer.error(errMsg);
			context && context.instance && context.instance.$diagnoses.push({
				$severity: "error",
				$message: errMsg
			});
			this.stop(_, context, batchSrvInst);
			return batchSrvInst;
		}

		try {
			// propagate configuration on one server only
			this._mngtAllParams(_, context, this.adminClients[Object.keys(this.adminClients)[0]]);
		} catch (e) {
			if (e instanceof X3BatchException) {
				// stop the batch server if config propagation failed
				this.stop(_, null, batchSrvInst);
				return;
			}
		}

		// synchronize already pending queries
		var queries = this._listQueries(_, {
			where: "FLAG eq 2"
		});
		this.srvQueue.adjust(function(arr) {
			return arr.map(function(s) {
				queries.filter(function(q) {
					return (q.SERVER.toLowerCase() + ":" + q.PORT) === s.descr;
				}).forEach(function(q) {
					s._queries.push(q);
				});
				return s;
			});
		});


		tracer.info && tracer.info("[" + this.code + "] X3 batch clients initialized: " + JSON.stringify(Object.keys(this.adminClients)));


		this.started = true;
		// set status running
		batchSrvInst.status(_, "running");
		batchSrvInst.save(_);
		// start watching queries
		this._launchWatchLoop(_);
		return batchSrvInst;
	},
	stop: function(_, context, batchSrvInst) {
		try {
			// stop watching queries
			this._stopWatchLoop();

			var self = this;
			var servers = this.srvQueue.contents();
			for (var i = 0; i < servers.length; i++) {
				var srvConf = this.srvQueue.read(_);
				var cli = srvConf._admClient;
				// disconnect all administrative clients
				if (cli) {
					cli.disconnect(_);
					var msg = locale.format(module, "clientDisconnected", cli.pid, cli.x3server.description(_));
					context && context.instance && context.instance.$diagnoses.push({
						$severity: "success",
						$message: msg
					});
					tracer.debug && tracer.debug("[" + self.code + "] " + msg);
				}
			}
		} catch (e) {
			console.error(e.stack);
			context && context.instance && context.instance.$addError(e.message);
		}

		this.started = false;
		// set status stopped
		batchSrvInst.status(_, "stopped");
		batchSrvInst.save(_);
		return batchSrvInst;
	},
	_createAdminClient: function(_, context, batchSrvInst, srvConf) {
		var srv = this._getX3Server(_, srvConf.descr);
		// create as many client as we have x3 runtimes
		var admCli = this._createClient(_, context, {
			x3server: srv,
			lang: this.refLang,
			user: this.refUser,
			folder: this.refFolder
		});
		if (admCli) {
			var successMsg = locale.format(module, "clientCreated", admCli.pid, srvConf.descr);
			tracer.info && tracer.info("[" + this.code + "] " + successMsg);
			context && context.instance && context.instance.$diagnoses.push({
				$severity: "success",
				$message: successMsg
			});

			// put conf in client itself ; this will be useful to recreate client when steam will be closed unexpectedly
			admCli._srvConf = srvConf;
			// store administrative client
			this.adminClients[srvConf.descr] = admCli;
			this.totalMaxQueries += srvConf._maxQueries;
		} else {
			var errConnMsg = locale.format(module, "x3ConnectionFailed", srvConf.descr);
			tracer.error && tracer.error("[" + this.code + "] " + errConnMsg);
			context && context.instance && context.instance.$diagnoses.push({
				$severity: "error",
				$message: errConnMsg
			});
		}
	},
	_createClient: function(_, context, options) {
		try {
			var adminEP = adminHelper.getCollaborationEndpoint(_);
			var client = x3client.create({
				x3solution: this._getX3Solution(_),
				x3server: options.x3server
			});
			var localePref = getLocalePrefFromX3Lang(_, options.lang);
			var _x3 = client.connect(_, {
				server: this._getX3Solution(_).serverHost(_),
				folder: options.folder,
				locale: localePref.code(_),
				runtimeLog: options.runtimeLogFlag || "",
				runtimeLogDir: options.runtimeLogDir || ""
			});
			client.pid = _x3.pid;
			context = context || globals.context;
			var session = context && (context.httpSession || context.session);
			var peer = session && (session.getData("requestInfo") || {}).peerAddress;
			this.sid = client.createSession(_, {
				userName: options.user,
				adxtyp: options.adxtyp || 35, // adxtyp = 35 for batch
				locale: localePref.code(_),
				localePreferences: options.localePref,
				baseUrl: context && context.baseUrl,
				collaborationBaseUrl: adminEP && session ? session.host + adminHelper.getCollaborationEndpoint(_).getBaseUrl(_) : "",
				peerAddress: peer
			});

			return client;
		} catch (e) {
			if (e.$diagnoses) {
				if (context && context.instance) context.instance.$diagnoses = (context.instance.$diagnoses || []).concat(e.$diagnoses);
				tracer.error && tracer.error("[" + this.code + "] X3 client connection failed: " + JSON.stringify(e.$diagnoses, null, 2));
			} else {
				tracer.error && tracer.error("[" + this.code + "] X3 client connection failed: " + e.stack);
				context && context.instance && context.instance.$addError(e.message);
			}
			this._removeSrvFromQueue(_, options.x3server);
		}
	},
	_getAdminClient: function(_, idx) {
		idx = idx != null ? idx : 0;
		var cliList = Object.keys(this.adminClients);
		if (cliList.length === 0) throw new Error("No administrative client available");
		var cli = this.adminClients[cliList[idx]];
		//		console.error("KEY: "+cliList[idx]);
		//		console.error("Clients available: "+require('util').inspect(this.adminClients,null,1));
		if (cli && !cli.isAlive()) {
			tracer.debug && tracer.debug("[" + this.code + "] Admin client on '" + cli.x3server.description(_) + "' fall... Try to reconnect it");
			this.totalMaxQueries -= cli._srvConf._maxQueries;
			cli = this._createAdminClient(_, null, null, cli._srvConf);
		}
		return cli;
	},
	_getX3Solution: function(_) {
		var solutions = this.db.fetchInstances(_, this.db.model.getEntity(_, "x3solution"), {
			jsonWhere: {
				code: this.x3solutionCode
			}
		});
		if (solutions.length === 0) throw new Error("No X3 solution found with code '" + this.x3solutionCode + "'");
		return solutions[0];
	},
	_getX3Server: function(_, descr) {
		var sol = this._getX3Solution(_);
		var servers = sol.runtimes(_).toArray(_).filter_(_, function(_, s) {
			return s.description(_).toLowerCase() === descr.toLowerCase();
		});
		if (servers.length === 0) throw new Error("No X3 server found with description '" + descr + "'");
		if (servers[0].banned(_) || servers[0].disabled(_)) throw new Error("X3 server '" + descr + "' is not available");
		return servers[0];
	},
	_removeSrvFromQueue: function(_, srvInst) {
		try {
			var descr = srvInst.description(_);
			var mustDisconnect = false;
			this.srvQueue.adjust(function(arr) {
				return arr.filter(function(s) {
					if (s.descr === descr) {
						mustDisconnect = true;
						return false;
					}
					return true;
				});
			});
			if (mustDisconnect) {
				if (this.adminClients[descr] && this.adminClients[descr].isAlive()) {
					tracer.info && tracer.info("[" + this.code + "] " + locale.format(module, "clientDisconnected", this.adminClients[descr].pid, descr));
					this.adminClients[descr].disconnect(_);
				}
				delete this.adminClients[descr];
			}
		} catch (e) {
			console.error("An error occured when purging server where we can't connect\n" + e.stack);
		}
	},
	_launchWatchLoop: function(_) {
		// execute one first time to not have to wait for scheduling...
		this._executeControlLoop(_);
		// execute watch function every execInterval time
		this.loopInterval = flows.setInterval(this._executeControlLoop.bind(this), this.execInterval * 1000);
		tracer.info && tracer.info("[" + this.code + "] Queries listener is enabled and will handle " + this.totalMaxQueries + " queries every " + this.execInterval + " seconds");
	},
	_stopWatchLoop: function() {
		if (this.loopInterval) {
			// stop watch loop
			clearInterval(this.loopInterval);
			this.loopInterval = null;
			tracer.info && tracer.info("[" + this.code + "]  Queries listener disabled");
		}
	},
	_sdataRequest: function(_, context, client, url, alias, method, body, options) {
		function _inspectResponse(_, resp) {
			if (resp) {
				if (!options.noTraces) tracer.debug && tracer.debug("[" + self.code + "] " + alias + " call result: " + JSON.stringify(resp, null, 2));
				if (resp.head && resp.head.status) {
					if (resp.head.status !== 200) {
						var diags = (resp.body && resp.body.$diagnoses) || [];
						if (diags.length === 0 && resp.head.message) {
							diags.push({
								$severity: "error",
								$message: locale.format(module, "x3err", alias, resp.head.message)
							});
						}
						if (diags && diags.length > 0) {
							diags.forEach(function(d) {
								if (context && context.instance) context.instance.$diagnoses.push(d);
								tracer.error && tracer.error("[" + self.code + "] " + alias + " call result: " + resp.head.status + " - " + d.$message);
							});
							// some actions need to be blocking (like configuration propagation)
							if (options.throwErr) throw new X3BatchException(diags[0].$message);
						}
					} else {
						if (!options.noTraces) tracer.info && tracer.info("[" + self.code + "] " + alias + " call result: " + resp.head.status);
						return resp.body;
					}
				}
			}
			return null;
		}
		//
		//
		var self = this;
		options = options || {};
		var params = {
			head: {
				method: method,
				url: url,
				accept: "application/json",
				"content-type": "application/json"
			},
			body: body
		};
		if (client && client._srvConf && !client.isAlive()) {
			this.adminClients[client._srvConf.descr] = null;
			return;
		} else if (!client) {
			return;
		}
		if (!options.noTraces) {
			tracer.debug && tracer.debug("[" + this.code + "] Execute sdata request on " + client.x3server.description(_) + " with adonix: " + (client && client.pid) + " - alive: " + (client && client.isAlive()) + " (url=" + url + ")");
			tracer.debug && tracer.debug("[" + this.code + "] " + alias + " call params: " + JSON.stringify(params, null, 2));
		}

		var resp = client.jsonSend(_, params);
		return _inspectResponse(_, resp);
	},
	_execRpc: function(_, context, client, mod, name, method, body, options) {
		var url = this.refUrl + "/$service/rpc?module=" + mod + "&name=" + name;
		return this._sdataRequest(_, context, client, url, mod + ":" + name, method, body, options);
	},
	_mngtAllParams: function(_, context, client) {
		this._execRpc(_, context, client, "ASYRSRVBATCH", "ABATCH_MNGT_ALLPARAMS", "POST", {
			execInterval: this.execInterval,
			killOverTime: this.killOverTime,
			maxDelay: this.maxDelay
		}, {
			throwErr: true
		});
	},
	_mngtServReq: function(_, context) {
		for (var i = 0; i < Object.keys(this.adminClients).length; i++) {
			var cli = this._getAdminClient(_, i);
			if (cli) {

				this._execRpc(_, context, cli, "ASYRSRVBATCH", "ABATCH_MNGT_SERVREQ", "POST", {
					server: cli.x3server.serverHost(_),
					port: cli.x3server.serverPort(_)
				});
				this._refreshPendingQueries(_, cli._srvConf);
			}
		}
	},
	_mngtAllReq: function(_, context) {
		this._execRpc(_, context, this._getAdminClient(_), "ASYRSRVBATCH", "ABATCH_MNGT_ALLREQ", "POST", {});
	},
	_listQueries: function(_, params, options) {
		params = params || {};
		params.representation = "ASYRREQ.$query";
		if (!params.orderby) params.orderBy = "DAT,HEURE,NUMREQ";
		//
		var url = this.refUrl + "/ASYRREQ?" + querystring.stringify(params);
		var resp = this._sdataRequest(_, null, this._getAdminClient(_), url, "ASYRREQ", "GET", {}, options);
		return (resp && resp.$resources) || [];
	},
	_stopRecurrent: function(_, context, folderName) {
		for (var i = 0; i < Object.keys(this.adminClients).length; i++) {
			var cli = this._getAdminClient(_, i);
			if (cli) this._execRpc(_, context, cli, "ASYRSRVBATCH", "ABATCH_STOP_RECURRENT", "POST", {
				server: cli.x3server.serverHost(_),
				port: cli.x3server.serverPort(_),
				folder: folderName
			});
		}
	},
	_execQuery: function(_, srvConf, query, options) {
		var self = this;
		options = options || {};
		options.throwErr = true;
		var cli;
		try {
			cli = this._createClient(_, null, {
				x3server: this._getX3Server(_, srvConf.descr),
				lang: query.LAN,
				user: query.LOGIN,
				folder: query.DOSSIER,
				localePref: getLocalePrefFromX3Lang(_, query.LAN)
			});
			// ensure endpoint exists
			var x3sol = this._getX3Solution(_);
			var ep = x3sol.getEp(_, query.DOSSIER);
			if (!ep) x3sol.createEndpoint(_, query.DOSSIER);

			// this condition should never been called, but protect it just in case :)
			// BECAUSE of monoExcludeFilter used in _executeControlLoop
			// no query on specific endpoint should be run if this.monoPendings map contains the dataset
			if (this.monoPendings.indexOf(query.DOSSIER) !== -1) {
				tracer.warn && tracer.warn("!!! [" + this.code + "] Query launch ignored '" + query.NUMREQ + "' because other mono is pending on folder '" + query.DOSSIER + "'");
				return;
			}

			// if it's a mono query
			if (query.MONO) {
				// if other queries are currently running for the same endpoint
				if (srvConf._queries.some(function(q) {
					return q.DOSSIER === query.DOSSIER && query.NUMREQ !== q.NUMREQ;
				})) {
					// call X3 service ABATCH_STOP_RECURRENT to ask to stop all recurrent requests
					this._stopRecurrent(_, null, query.DOSSIER);
					// set mono state for this folder
					this.monoPendings[query.DOSSIER] = query.NUMREQ;

					// --> then do not launch mono request now... It would start later (when other queries will be ended)
					tracer.info && tracer.info("[" + this.code + "] Ignore mono request " + query.NUMREQ + " because some other requests are pending");
					return;
				} else {

				}
				// if no other queries are running on the same endpoint, then we continue, and execute the mono query
			}

			tracer.info && tracer.info("[" + this.code + "] Execute query " + (query.MONO ? " (MONO) " : "") + "'" + query.NUMREQ + "' on server " + srvConf.descr + " with client '" + cli.pid + "'");
			var url = "/sdata/x3/erp/" + query.DOSSIER + "/$service/batch?requestId=" + query.NUMREQ;
			// Ask X3 to execute query
			this._sdataRequest(function(err) {
				if (err) tracer.error && tracer.error("An error occured when executing query '" + query.NUMREQ + "': " + err.stack);
				if (cli && cli.isAlive()) {
					tracer.info && tracer.info("[" + self.code + "] Disconnect batch client " + cli.pid);
					cli.disconnect(flows.ignore);
					cli = null;
				}
			}, null, cli, url, "Batch request " + query.NUMREQ, "POST", {}, options);
			// add the query number in server instance
			srvConf._queries.push(query);
		} catch (e) {
			if (e instanceof X3BatchException) {
				tracer.error && tracer.error("[" + this.code + "] Query launch failed '" + query.NUMREQ + "' on server " + srvConf.descr + "\n" + e.message);
				if (query.MONO) delete this.monoPendings[query.DOSSIER];
			} else {
				// TODO call X3 err service
				console.error("_execQuery error: " + e.stack);
			}
		}
	},
	_refreshPendingQueries: function(_, _srvConf) {
		var self = this;
		// if requests are pending on this server, we check their status and actualize the list on server instance
		var newPending = [];
		if (_srvConf._queries.length > 0) {
			// get the requests list with only previous launched requests numbers
			var temp = _srvConf._queries.map(function(q) {
				return q.NUMREQ;
			}).join(',');

			var queriesWhere = "(NUMREQ in (" + temp + "))";
			var queries = self._listQueries(_, {
				where: queriesWhere
			}, {
				noTraces: true
			});
			queries.forEach_(_, function(_, query) {
				tracer.info && tracer.info("[" + self.code + "] Query " + query.NUMREQ + " status: " + query.FLAG);
				if (query.FLAG <= 2) {
					// keep in array if still running
					newPending.push(query);
				} else {
					// if a mono ended, set endpoint free to launch new requests
					if (query.MONO) delete self.monoPendings[query.DOSSIER];
				}
			});
		}
		_srvConf._queries = newPending;
		tracer.info && tracer.info("[" + this.code + "] Pending queries on " + _srvConf.descr + ": " + _srvConf._queries.length + "/" + _srvConf._maxQueries + " " + JSON.stringify(_srvConf._queries.map(function(q) {
			return q.NUMREQ;
		})));
	},
	_executeControlLoop: function(_) {

		function _selectServer(_, mainOnly) {

			var srvConf;
			// select Main server if available (set in the config with a maxQueries parameter)				
			var nbSrvConcerned = 0;
			if (mainOnly) {
				nbSrvConcerned = 1;
				self.srvQueue.adjust(function(arr) {
					return arr.sort(function(srvA) {
						if (srvA._isMain) {
							return -1;
						} else {
							return 1;
						}
						return 0;
					});
				});
			} else {
				nbSrvConcerned = self.srvQueue.contents().length;
			}
			//console.error("QUEUE ORDER: "+JSON.stringify(self.srvQueue.contents().map(function(s) {return s.descr;}),null,2));

			for (var i = 0; i < nbSrvConcerned; i++) {
				// pop a server from the queue
				srvConf = self.srvQueue.read(_);
				// if first server is not MAIN and request must be executed on main
				if (mainOnly && !srvConf._isMain) {
					tracer.warn && tracer.warn("[" + self.code + "] No Main server available");
					return;
				}
				// get srv instance
				var srv = self._getX3Server(_, srvConf.descr);
				// refresh pending requests list
				self._refreshPendingQueries(_, srvConf);
				if (srv.disabled(_) || srv.banned(_)) {
					tracer.warn && tracer.warn("[" + self.code + "] The server '" + srvConf.descr + "' is not available");
					// remove the server from the queue
					// self._removeSrvFromQueue(_, srv); // not necessary as we red the conf
				} else if (srvConf._queries.length < srvConf._maxQueries) {
					// if max number of concurrent queries is not reached for this server, return the server
					// the server instance will be put again in the queue after the launch of the query
					tracer.info && tracer.info("[" + self.code + "] Select (" + (mainOnly ? "MAIN" : "LB") + ") '" + srvConf.descr + "' server: pending: " + srvConf._queries.length + " - max: " + srvConf._maxQueries);
					return srvConf;
				} else {
					// if max number of concurrent queries is reached for this server, put the server again in the queue
					tracer.warn && tracer.warn("[" + self.code + "] Ignore (because is full) '" + srvConf.descr + "' server: pending: " + srvConf._queries.length + " - max: " + srvConf._maxQueries);
					fullDebug && tracer.debug && tracer.debug("MAX QUERIES REACHED SO PUT THE SRV CONF IN THE QUEUE");
					self.srvQueue.put(srvConf);
				}
			}
			tracer.warn && tracer.warn("[" + self.code + "] No free slot found on servers");

		}
		//
		//
		var self = this;
		tracer.info && tracer.info("============== [" + this.code + "]  begin control loop ==============");

		//
		fullDebug && tracer.debug && tracer.debug("Servers queue contents: " + JSON.stringify(this.srvQueue.contents().map(function(s) {
			return s.descr;
		}), null, 2));
		//
		try {
			this._mngtServReq(_);
			this._mngtAllReq(_);

			var queries = this._listQueries(_, {
				count: this.totalMaxQueries - this.monoPendings.length, // if mono are currently running, we must consider less queries to execute
				filter: "ACTIVE"
			});
			queries.sort(function(a, b) {
				return a.FLAG < b.FLAG;
			});
			var queriesMap = queries.reduce(function(prev, curr) {
				prev[curr.DOSSIER] = prev[curr.DOSSIER] || [];
				prev[curr.DOSSIER].push(curr);
				return prev;
			}, {});

			var foldersToIgnore = [],
				monoToExecute = [];
			var folders = Object.keys(queriesMap);
			folders.forEach(function(folderName) {
				var _queries = queriesMap[folderName];
				//				console.error("Queries: "+JSON.stringify(_queries,null,2));
				for (var i = 0; i < _queries.length; i++) {
					var q = _queries[i];
					if (q.MONO === true && q.FLAG === 1) {
						if (i === 0) {
							monoToExecute.push(q.NUMREQ);
							tracer.info && tracer.info("[" + self.code + "] Mono " + q.NUMREQ + " will be executed on folder " + q.DOSSIER + " and all other requests will be ignored for this folder");
						} else {
							tracer.warn && tracer.warn("[" + self.code + "] Mono " + q.NUMREQ + " is waiting on folder " + q.DOSSIER + " so ignore all request for this folder");
						}
						foldersToIgnore.push(q.DOSSIER);
						self.monoPendings[q.DOSSIER] = self.monoPendings[q.DOSSIER] || [];
						self.monoPendings[q.DOSSIER].push(q.NUMREQ);

						break;
					}
				}


			});

			//			console.error("foldersToIgnore: "+JSON.stringify(foldersToIgnore));
			//			console.error("monoToExecute: "+JSON.stringify(monoToExecute));

			// consider only request with "stand by" status (1) and EXENOW flag set (that means the execution datetime is reached)
			queries = queries.filter(function(q) {
				return q.FLAG === 1 && q.EXENOW === true && (foldersToIgnore.indexOf(q.DOSSIER) === -1 || monoToExecute.indexOf(q.NUMREQ) !== -1);
			});
			tracer.info && tracer.info("[" + self.code + "] Nb queries to execute (" + queries.length + ") " + queries.map(function(q) {
				return q.NUMREQ;
			}));

			var queriesWaiting = [];
			for (var i = 0; i < queries.length; i++) {
				var query = queries[i];
				tracer.info && tracer.info("************** [" + self.code + "] Begin to consider query " + query.NUMREQ + "**************");
				var srvConf = _selectServer(_, query.MAISRV);
				if (srvConf) {
					try {
						this._execQuery(_, srvConf, query);
					} finally {
						// put the server instance in the queue
						fullDebug && tracer.debug && tracer.debug("Put server configuration into the queue");
						this.srvQueue.put(srvConf);
					}
				} else {
					queriesWaiting.push(query.NUMREQ);
				}
				tracer.info && tracer.info("************** [" + self.code + "] End to consider query " + query.NUMREQ + "**************");
			}
			if (queriesWaiting.length) {
				tracer.info && tracer.info("[" + self.code + "] Queries waiting for free servers: " + JSON.stringify(queriesWaiting));
			}
		} catch (e) {
			tracer.error && tracer.error("[" + this.code + "] An error occured during control loop\n" + e.stack);
		}
		tracer.info && tracer.info("============== [" + this.code + "]  end control loop ================");
	}

});

exports.initBatchServers = function(_) {
	var db = adminHelper.getCollaborationOrm(_);
	var x3solutions = db.fetchInstances(_, db.getEntity(_, "x3solution"));
	var bsEntity = db.getEntity(_, "batchServer");
	x3solutions.forEach_(_, function(_, s) {
		var bs = null;
		var bss = db.fetchInstances(_, bsEntity, {
			jsonWhere: {
				code: s.code(_)
			}
		});
		// Get existing batch server config
		if (bss.length > 0) bs = bss[0];
		// create if if doesn't exist
		if (!bs) {
			bs = bsEntity.createInstance(_, db);
			bs.code(_, s.code(_));
			bs.x3solution(_, s);

			// compute ref endpoint
			var ep;
			if (s) {


				try {
					var motherFolders = x3FolderHelper.getFoldersFromJson(_, s, function(f) {
						return f.mother && f.mother.length === 0;
					});
					if (motherFolders && motherFolders.length > 0) {
						ep = s.getEp(_, motherFolders[0].name);
						if (!ep) {
							ep = s.createEndpoint(_, motherFolders[0].name);
						}
						if (ep) {
							bs.refEndpoint(_, ep);
						}
					}
				} catch (e) {
					console.error("An error occured when synchronising x3 solution and batch server '" + s.code(_) + "'\n" + e.stack);
				}

			}
		}
		// reset statuses
		if (bs.status(_) === "running") {
			bs.status(_, "stopped");
		}
		// synchronize runtimes list with x3solution configuration
		try {
			bs.syncServers(_, true);
		} catch (e) {
			console.error(e.stack);
		}
		// persist data
		bs.save(_);

		// start the batch server
		if (bs.auto(_)) {
			bs.start(_);
		}

	});
};