"use strict";

var locale = require('streamline-locale');
var bm = require('syracuse-batch/lib/batchManager');
var helpers = require('syracuse-core').helpers;
var config = require('config');
var globals = require('streamline-runtime').globals;
var mock = require('syracuse-load/lib/mock');
var config = require('config');
var withTenant = (config.hosting && config.hosting.multiTenant);

exports.entity = {
	$lockType: "noLock",
	$titleTemplate: "Batch server",
	$valueTemplate: "{code}",
	$descriptionTemplate: "Batch server",
	$canDelete: false,
	$capabilities: "",
	$properties: {
		code: {
			$title: "Code",
			$isReadOnly: true,
			$isUnique: true,
			$isMandatory: true,
			$linksToDetails: true
		},
		active: {
			$type: "boolean",
			$title: "Active",
			$default: false
		},
		auto: {
			$type: "boolean",
			$title: "Auto start",
			$default: false
		},
		execInterval: {
			$title: "Time between two searches (sec)",
			$type: "integer",
			$isMandatory: function(_, instance) {
				return instance.active(_);
			},
			$default: 30,
			$isNullable: true
		},
		killOverTime: {
			$title: "Timeout search time (sec)",
			$type: "integer",
			$isMandatory: function(_, instance) {
				return instance.active(_);
			},
			$default: 30,
			$isNullable: true
		},
		maxDelay: {
			$title: "Maximum delay to launch a query (minutes)",
			$type: "integer",
			$default: 0,
			$isNullable: true
		},
		status: {
			$title: "Status",
			$isReadOnly: true,
			$enum: [{
				$value: "running",
				$title: "Running"
			}, {
				$value: "stopped",
				$title: "Stopped"
			}, {
				$value: "stopping",
				$title: "Stopping"
			}, {
				$value: "unavailable",
				$title: "Unavailable"
			}],
			$default: "stopped"
		},
		refFolder: {
			$title: "Folder",
			$description: "Mother folder used for administrative tasks",
			$default: "X3",
			$isNullable: false
		},
		refUser: {
			$title: "X3 user",
			$description: "X3 user used for administrative tasks",
			$default: "ADMIN",
			$isNullable: false
		},
		refLang: {
			$title: "X3 language",
			$description: "X3 language used for administrative tasks",
			$default: "ENG",
			$isNullable: false
		},
		refUrl: {
			$isHidden: true,
			$isNullable: true
		}
	},
	$relations: {
		x3solution: {
			$type: "x3solution",
			$isMandatory: true,
			$isReadOnly: true,
			$cascadeDelete: true,
			$propagate: function(_, instance, val) {
				if (val) {
					instance.code(_, val.code(_));
				}
			}
		},
		runtimes: {
			$capabilities: "",
			$type: "batchServerConfigs",
			$isChild: true,
		},
		refEndpoint: {
			$type: "endPoint",
			$title: "Administrative endpoint",
			$description: "Endpoint corresponding to mother folder used for administrative tasks",
			$isMandatory: true,
			$nullOnDelete: true,
			$isNullable: true,
			$propagate: function(_, instance, val) {
				if (val === null) {
					instance.refFolder(_, null);
					instance.refUrl(_, null);
					instance.stop(_);
				} else if (val) {
					instance.refFolder(_, val.x3ServerFolder(_));
					instance.refUrl(_, val.getBaseUrl(_));
				}
			}
		}
	},
	$functions: {
		getClient: function(_, start, ignoreErr) {
			return bm.getBatchClient(this.code(_), start, ignoreErr);
		},
		start: function(_, diagnoses) {
			this.getClient(_, true).start(_, diagnoses, this, undefined);
		},
		stop: function(_, diagnoses) {
			this.getClient(_).stop(_, diagnoses, this, undefined);
		},
		stopAll: function(_, diagnoses) {
			this.getClient(_).stopAll(_, diagnoses, this, undefined);
		},
		applyChanges: function(_, changes) {
			if ("mockServer" in config) {
				this._propagate(_, "applyChanges", this.code(_), "POST", changes);
			} else {
				var bc = this.getClient(_, false, true);
				if (bc) bc.applyChanges(_, this.$diagnoses, this, changes);
			}
		},
		_propagateConfigChanges: function(_) {
			var _trace; // = console.error;
			var maxQueriesMap = {};
			var configs = this.runtimes(_).toArray(_);
			// store new values in map
			configs.forEach_(_, function(_, r) {
				maxQueriesMap[r.$uuid] = {
					new: {
						description: r.description(_),
						maxQueries: r.maxQueries(_)
					}
				};
			});

			// fetch the instance to get old values before modifications
			var oldBatchServer = this._db.fetchInstance(_, this._db.getEntity(_, "batchServer"), {
				jsonWhere: {
					code: this.code(_)
				}
			});
			oldBatchServer.runtimes(_).toArray(_).forEach_(_, function(_, r) {
				maxQueriesMap[r.$uuid] = maxQueriesMap[r.$uuid] || {};
				maxQueriesMap[r.$uuid].old = {
					description: r.description(_),
					maxQueries: r.maxQueries(_)
				};
			});

			this._changesOnFly = this._changesOnFly || {};
			for (var i = 0; i < Object.keys(maxQueriesMap).length; i++) {
				var uuid = Object.keys(maxQueriesMap)[i];
				var conf = maxQueriesMap[uuid];
				// if change made manually on batch configuration
				if (!helpers.object.areEqual(conf.old, conf.new)) {
					// batch configuration propagation
					if (conf.new.maxQueries > 0) {
						this._changesOnFly.qUpdate = this._changesOnFly.qUpdate || [];
						// we create the entry on the fly
						_trace && _trace("qUpdate because maxQueries changed: " + conf.new.description);

						// if not already set by x3solution change !
						if (!this._changesOnFly.qUpdate.some(function(elt) {
							return elt.server === uuid;
						})) {
							var updConf = {
								server: uuid, // use uuid because nanny command propagation needs it !
								maxQueries: conf.new.maxQueries
							};
							if (conf.old.description !== conf.new.description) {
								updConf.reconnect = true;
							}
							this._changesOnFly.qUpdate.push(updConf);
						}

					} else {
						_trace && _trace("qRemove because maxQueries 0: " + conf.new.description);
						this._changesOnFly.qRemove = this._changesOnFly.qRemove || [];
						this._changesOnFly.qRemove.push(uuid);
					}
				}

			}

			// the magic happens here :)
			if (Object.keys(this._changesOnFly).length > 0) {
				this.applyChanges(_, this._changesOnFly);
			}
		},
		_propagate: function(_, action, id, method, data) { // propagation only when load balancer is available!
			if ("mockServer" in config) {
				var self = this;
				var path = "/nannyCommand/notifyB/batch/" + action + "?code=" + encodeURIComponent(id);
				if (withTenant) {
					path += '&tenantId=' + globals.context.tenantId;
					console.log("Set tenant " + path);
				}
				var options = {
					path: path,
					method: method || "GET",
					headers: {
						hostname: (globals.context.tenantId || "")
					},
				};
				options.headers[mock.BALANCER_HEADER] = config.port;
				// console.log("Propagate: "+util.format(options))
				try {
					var text = config.mockServer.mockClient.simpleRequest(options, data != null ? JSON.stringify(data) : "", _);
					var lines = text.split(/[\r\n]+/);
					console.log("TEXT " + text);
					lines.forEach(function(line) {
						if (line.charAt(0) === '{') {
							var childData = JSON.parse(line);
							if (childData.message) {
								var diags = JSON.parse(childData.message);
								diags.forEach(function(diag) {
									self.$diagnoses.push(diag);
								});
							}
						}
					});
				} catch (e) {
					console.error("Error " + e.stack);
					self.$addError({
						$severity: "error",
						$message: "" + e,
						$stack: e.stack
					});
				}
				// update local instance

				// TODO: make this better
				var inst_new = this._db.fetchInstance(_, this._meta, this.$uuid);
				if (inst_new) {
					self.status(_, inst_new.status(_));

				}
			}
		}
	},
	$services: {
		start: {
			$title: "Start",
			$description: "Start batch controller",
			$facets: ["$details"],
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) === "running" || !instance.active(_);
			},
			$execute: function(_, context, instance) {
				instance.$diagnoses = instance.$diagnoses || [];
				if ("mockServer" in config)
					instance._propagate(_, "start", instance.code(_));
				else
					instance.start(_, instance.$diagnoses);
			},
		},
		stop: {
			$title: "Stop",
			$description: "Stop batch controller only",
			$facets: ["$details"],
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "running" || !instance.active(_);
			},
			$execute: function(_, context, instance) {
				instance.$diagnoses = instance.$diagnoses || [];
				if ("mockServer" in config)
					instance._propagate(_, "stop", instance.code(_));
				else
					instance.stop(_, instance.$diagnoses);
			},
		},
		stopAll: {
			$title: "Stop ALL",
			$description: "Stop batch server and all pending queries",
			$method: "POST",
			$facets: ["$details"],
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) === "stopped" || !instance.active(_);
			},
			$execute: function(_, context, instance) {
				instance.$diagnoses = instance.$diagnoses || [];
				if ("mockServer" in config)
					instance._propagate(_, "stopAll", instance.code(_));
				else
					instance.stopAll(_, instance.$diagnoses);
			},
		},
		queries: {
			$method: "GET",
			$isMethod: true,
			$title: "Query management",
			$parameters: {
				$url: "{refUrl}/ASYRREQ?representation=ASYRREQ.$query&orderby=NUMREQ desc",
				$method: "GET",
				$properties: {}
			},
			$execute: function(_, context, instance) {
				// Do nothing
			},
		},
	},
	$links: function(_, instance) {
		return {
			x3traces: {
				$title: "X3 server traces",
				$url: instance.refEndpoint(_).getBaseUrl(_) + "/$service/upload?fileName=[SRV]/TRA/serveur.tra&type=1&$format=txt",
				$method: "GET",
				$isDisabled: !instance.refEndpoint(_)
			}
		};
	},
	$events: {
		$canDelete: [

			function(_, instance) {
				if (instance.active(_))
					instance.$addError(locale.format(module, "serverActive"));
			}
		],
		$beforeSave: [

			function(_, instance) {
				instance.$diagnoses = instance.$diagnoses || [];
				// report to nanny process that batch process should be started/stopped. These notifications should not happen more often than necessary, but shoud
				// never be omitted when they are necessary. The following ensures that the notifications are not omitted and that they do not happen more often
				// than necessary only when in the beginning there are 0 active instances and then simultaneously several are activated or: all active instances are
				// deactivated simultaneously (these are rare situations).
				if (config.mockServer) { // find out whether "active" flag has changed 	
					var count = instance._db.count(_, instance.getEntity(_), {
						jsonWhere: {
							active: true
						}
					});
					if (count === 0) {
						// no active instance. Therefore current instance is either new or inactive in database. 
						// Notification is necessary when it is now active
						if (instance.active(_)) instance._notifyActive = 2; // report change anyway 
					} else {
						// conditions:
						// instance.$created: current server not in database: already other server is active, therefore no check necessary
						// instance.active(_): is instance now active, either it was not active before (and therefore another instance was active) or active flag has not changed 
						if (!instance.$created && !instance.active(_)) {
							var oldInstance = instance._db.fetchInstance(_, instance.getEntity(_), instance.$uuid);
							// only interesting case: flag has now changed from true to false, so maybe there are no active servers any more
							if (!oldInstance || oldInstance.active(_))
								instance._notifyActive = (count === 1 ? 2 : 1); // when there are at least 2 active instances in the beginning, re-check after   
							// saving whether there is no active instance left. Reason for double-checking: when several instances
							// are deactivated at the same time, there must be at least one signal to the nanny process)
						}
					}
				}

				instance._propagateConfigChanges(_);


			}
		],
		$afterSave: [

			function(_, instance) { // named user check
				// update host data when either "active" instance is newly created or "active" flag is changed
				if (config.mockServer && (instance._notifyActive === 2 || instance._notifyActive === 1 && 0 === instance._db.count(_, instance.getEntity(_), {
					jsonWhere: {
						active: true
					}
				}))) {
					var options = {
						path: "/nannyCommand/notifyNannies/update",
						method: "PUT"
					};
					try {
						console.log(config.mockServer.mockClient.simpleRequest(options, null, _));
					} catch (e) {
						console.log("Error " + e);
					}
				}
				instance._notifyActive = undefined;
			}
		],
	},

};