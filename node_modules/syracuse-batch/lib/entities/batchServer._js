"use strict";

var locale = require('streamline-locale');
var bm = require('syracuse-batch/lib/batchManager');
var batchHelper = require("syracuse-batch/lib/batchHelper");
var helpers = require('@sage/syracuse-core').helpers;
var config = require('config');
var globals = require('streamline-runtime').globals;
var mock = require('../../../../src/load-balancer/mock');
var config = require('config');
var withTenant = (config.hosting && config.hosting.multiTenant);

function getX3FolderLangs(_, db) {
	var x3folderIsoLangs = [];
	var tablanQuery = db.getEntity(_, "TABLAN", "$query");
	var tablan = db.fetchInstances(_, tablanQuery, {
		sdataWhere: "LANISO ne '' and LANCON eq true"
	});
	tablan && tablan.forEach_(_, function(_, f) {
		x3folderIsoLangs.push(f.LANISO(_));
	});
	return x3folderIsoLangs;
}



exports.entity = {
	$lockType: "noLock",
	$titleTemplate: "Batch server",
	$valueTemplate: "{code}",
	$descriptionTemplate: "Batch server",
	$helpPage: "Administration-reference_Batch-server",
	$canDelete: false,
	$canCreate: false,
	$capabilities: "",
	$properties: {
		code: {
			$title: "Code",
			$isReadOnly: true,
			$isUnique: true,
			$isMandatory: true,
			$linksToDetails: true
		},
		auto: {
			$type: "boolean",
			$title: "Auto start",
			$default: false
		},
		execInterval: {
			$title: "Time between two searches (sec)",
			$type: "integer",
			$isMandatory: true,
			$default: 30,
			$minimum: 1,
			$minimumCanEqual: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "stopped";
			}
		},
		killOverTime: {
			$title: "Timeout search time (sec)",
			$type: "integer",
			$isMandatory: true,
			$default: 30,
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "stopped";
			}
		},
		maxDelay: {
			$title: "Maximum delay to launch a query (minutes)",
			$type: "integer",
			$default: 0,
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "stopped";
			}
		},
		status: {
			$title: "Status",
			$isReadOnly: true,
			$enum: [{
				$value: "running",
				$title: "Running"
			}, {
				$value: "stopped",
				$title: "Stopped"
			}, {
				$value: "stopping",
				$title: "Stopping"
			}, {
				$value: "unavailable",
				$title: "Unavailable"
			}],
			$default: "stopped"
		},
	},
	$relations: {
		x3solution: {
			$type: "x3solution",
			$isMandatory: true,
			$isReadOnly: true,
			$inv: "batchServer",
			$propagate: function(_, instance, val) {
				if (val) {
					instance.code(_, val.code(_));
				}
			}
		},
		refEndpoint: {
			$type: "endPoint",
			$title: "Administrative endpoint",
			$description: "Endpoint corresponding to mother folder used for administrative tasks",
			$nullOnDelete: true,
			$isNullable: true,
			$propagate: function(_, instance, val) {
				if (val === null) {
					instance.stop(_);
				}
			}
		},
		user: {
			$title: "User",
			$description: "User used for administrative tasks",
			$type: "user",
			$isNullable: true
		},
		role: {
			$title: "Role",
			$description: "Role used for administrative tasks",
			$type: "role",
			$isNullable: true
		},
		localePref: {
			$title: "Locale",
			$type: "localePreference",
			$description: "Language used for administrative tasks",
			$isMandatory: true,
			$lookupFilter: function(_, instance) {
				var ep = instance.refEndpoint(_);
				var filter;
				var x3IsoLangs = [];
				if (ep) {
					var db = ep.getOrm(_);
					try {
						x3IsoLangs = getX3FolderLangs(_, db);
						x3IsoLangs.forEach_(_, function(_, l) {
							filter = filter || {
								$or: []
							};
							filter.$or.push({
								"code": l
							});
						});
					} catch (e) {
						console.error(locale.format(module, "repAdossierMissing", ep.dataset(_), e.message));
					}
				} else {
					filter = {
						code: {
							$in: []
						}
					};
				}
				return filter;
			}
		},
		runtimes: {
			$capabilities: "",
			$type: "batchServerConfigs",
			$isChild: true,
		},
	},
	$functions: {
		$serialize: function(_) {
			// dynamicaly define the listQueries link
			var self = this;
			var res = self._internalSerialize(_);
			var ep = this.refEndpoint(_);
			if (ep) {
				res.refUrl = ep.getBaseUrl(_);
			}
			return res;
		},
		getClient: function(_, start, ignoreErr) {
			return bm.getBatchClient(this.code(_), start, ignoreErr);
		},
		start: function(_, diagnoses) {
			if (batchHelper.checkMandatoryFields(_, this)) return;
			this.getClient(_, true).start(_, diagnoses, this, undefined);
		},
		stop: function(_, diagnoses) {
			this.getClient(_).stop(_, diagnoses, this, undefined);
		},
		stopAll: function(_, diagnoses) {
			this.getClient(_).stopAll(_, diagnoses, this, undefined);
		},
		syncOldConf: function(_) {
			// no need to use only B0 in this case
			batchHelper.getOldX3BatchConfig(_, this);
		},
		applyChanges: function(_, changes) {
			if ("mockServer" in config) {
				this._propagate(_, "applyChanges", this.code(_), "POST", changes);
			} else {
				var bc = this.getClient(_, false, true);
				if (bc) bc.applyChanges(_, this.$diagnoses, this, changes);
			}
		},
		_propagateConfigChanges: function(_) {
			var _trace; // = console.error;
			var maxQueriesMap = {};
			var configs = this.runtimes(_).toArray(_);
			// store new values in map
			configs.forEach_(_, function(_, r) {
				maxQueriesMap[r.$uuid] = {
					new: {
						description: r.description(_),
						maxQueries: r.maxQueries(_)
					}
				};
			});

			// fetch the instance to get old values before modifications
			var oldBatchServer = this._db.fetchInstance(_, this._db.getEntity(_, "batchServer"), {
				jsonWhere: {
					code: this.code(_)
				}
			});
			if (!oldBatchServer) return;

			oldBatchServer.runtimes(_).toArray(_).forEach_(_, function(_, r) {
				maxQueriesMap[r.$uuid] = maxQueriesMap[r.$uuid] || {};
				maxQueriesMap[r.$uuid].old = {
					description: r.description(_),
					maxQueries: r.maxQueries(_)
				};
			});

			this._changesOnFly = this._changesOnFly || {};
			for (var i = 0; i < Object.keys(maxQueriesMap).length; i++) {
				var uuid = Object.keys(maxQueriesMap)[i];
				var conf = maxQueriesMap[uuid];
				// if change made manually on batch configuration
				if (!helpers.object.areEqual(conf.old, conf.new)) {
					// batch configuration propagation
					if (conf.new.maxQueries > 0) {
						this._changesOnFly.qUpdate = this._changesOnFly.qUpdate || [];
						// we create the entry on the fly
						_trace && _trace("qUpdate because maxQueries changed: " + conf.new.description);

						// if not already set by x3solution change !
						if (!this._changesOnFly.qUpdate.some(function(elt) {
								return elt.server === uuid;
							})) {
							var updConf = {
								server: uuid, // use uuid because nanny command propagation needs it !
								maxQueries: conf.new.maxQueries
							};
							if (conf.old && conf.old.description !== conf.new.description) {
								updConf.reconnect = true;
							}
							this._changesOnFly.qUpdate.push(updConf);
						}

					} else {
						_trace && _trace("qRemove because maxQueries 0: " + conf.new.description);
						this._changesOnFly.qRemove = this._changesOnFly.qRemove || [];
						this._changesOnFly.qRemove.push(uuid);
					}
				}

			}

			// the magic happens here :)
			if (Object.keys(this._changesOnFly).length > 0) {
				this.applyChanges(_, this._changesOnFly);
			}
		},
		_propagate: function(_, action, id, method, data) { // propagation only when load balancer is available!
			if ("mockServer" in config) {
				var self = this;
				var path = "/nannyCommand/notifyB/batch/" + action + "?code=" + encodeURIComponent(id);
				if (withTenant) {
					path += '&tenantId=' + globals.context.tenantId;
					console.log("Set tenant " + path);
				}
				var options = {
					path: path,
					method: method || "GET",
					headers: {
						hostname: (globals.context.tenantId || "")
					},
				};
				options.headers[mock.BALANCER_HEADER] = config.port;
				// console.log("Propagate: "+util.format(options))
				try {
					var text = config.mockServer.mockClient.simpleRequest(options, data != null ? JSON.stringify(data) : "", _);
					var lines = text.split(/[\r\n]+/);
					console.log("TEXT " + text);
					lines.forEach(function(line) {
						if (line.charAt(0) === '{') {
							var childData = JSON.parse(line);
							if (childData.message) {
								var diags = JSON.parse(childData.message);
								diags.forEach(function(diag) {
									self.$diagnoses.push(diag);
								});
							}
						}
					});
				} catch (e) {
					console.error("Error " + e.stack);
					self.$diagnoses.push({
						$severity: "error",
						$message: "" + e,
						$stack: e.stack
					});
				}
				// update local instance

				// TODO: make this better
				var inst_new = this._db.fetchInstance(_, this._meta, this.$uuid);
				if (inst_new) {
					self.status(_, inst_new.status(_));

				}
			}
		}
	},
	$services: {
		start: {
			$title: "Start",
			$description: "Start batch controller",
			$facets: ["$details", "$query"],
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) === "running";
			},
			$execute: function(_, context, instance) {
				instance.$diagnoses = instance.$diagnoses || [];
				if ("mockServer" in config)
					instance._propagate(_, "start", instance.code(_));
				else
					instance.start(_, instance.$diagnoses);
			},
		},
		stop: {
			$title: "Stop",
			$description: "Stop batch controller only",
			$facets: ["$details", "$query"],
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "running";
			},
			$execute: function(_, context, instance) {
				instance.$diagnoses = instance.$diagnoses || [];
				if ("mockServer" in config)
					instance._propagate(_, "stop", instance.code(_));
				else
					instance.stop(_, instance.$diagnoses);
			},
		},
		stopAll: {
			$title: "Stop ALL",
			$description: "Stop batch server and all pending queries",
			$method: "POST",
			$facets: ["$details", "$query"],
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) === "stopped";
			},
			$execute: function(_, context, instance) {
				instance.$diagnoses = instance.$diagnoses || [];
				if ("mockServer" in config)
					instance._propagate(_, "stopAll", instance.code(_));
				else
					instance.stopAll(_, instance.$diagnoses);
			},
		},
		queries: {
			$method: "GET",
			$isMethod: true,
			$title: "List of queries",
			$parameters: {
				$url: "{refUrl}/ASYRREQ?representation=ASYRREQ.$query&orderby=NUMREQ desc",
				$method: "GET",
				$properties: {}
			},
			$execute: function(_, context, instance) {
				// Do nothing
			},
			$isDisabled: function(_, instance) {
				return !instance.refEndpoint(_);
			},
		},
		syncOldConf: {
			$title: "Synchronize configuration",
			$description: "Synchronize old X3 batch server configuration or initialize it",
			$method: "POST",
			$facets: ["$details"],
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "stopped";
			},
			$execute: function(_, context, instance) {
				instance.$diagnoses = instance.$diagnoses || [];
				instance.syncOldConf(_);
			},
		}
	},
	$links: function(_, instance) {
		var lnks = {};
		if (instance.refEndpoint(_)) {
			lnks.x3traces = {
				$title: "X3 server traces",
				$url: instance.refEndpoint(_).getBaseUrl(_) + "/$service/upload?fileName=[SRV]/TRA/serveur.tra&type=1&$format=txt",
				$method: "GET",
				$isDisabled: !instance.refEndpoint(_)
			};
		}
		return lnks;
	},
	$events: {
		$afterSave: [

			function(_, instance) {
				instance.$diagnoses = instance.$diagnoses || [];
				if (!instance._initialization) instance._propagateConfigChanges(_);
			}
		],
	},
};