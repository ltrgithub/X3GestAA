"use strict";

var locale = require('streamline-locale');
var bm = require('syracuse-batch/lib/batchManager');
var config = require('config');

exports.entity = {
	$titleTemplate: "Batch server",
	$valueTemplate: "{code}",
	$descriptionTemplate: "Batch server",
	$properties: {
		code: {
			$title: "Code",
			$isReadOnly: true,
			$isUnique: true,
			$isMandatory: true,
			$linksToDetails: true
		},
		active: {
			$type: "boolean",
			$title: "Active",
			$default: false
		},
		auto: {
			$type: "boolean",
			$title: "Auto start",
			$default: false
		},
		execInterval: {
			$title: "Time between two searches (sec)",
			$type: "integer",
			$isMandatory: function(_, instance) {
				return instance.active(_);
			},
			$default: 30,
			$isNullable: true
		},
		killOverTime: {
			$title: "Timeout search time (sec)",
			$type: "integer",
			$isMandatory: function(_, instance) {
				return instance.active(_);
			},
			$default: 30,
			$isNullable: true
		},
		maxDelay: {
			$title: "Maximum delay to launch a query (minutes)",
			$type: "integer",
			$default: 0,
			$isNullable: true
		},
		status: {
			$title: "Status",
			$isReadOnly: true,
			$enum: [{
				$value: "running",
				$title: "Running"
			}, {
				$value: "stopped",
				$title: "Stopped"
			}, {
				$value: "stopping",
				$title: "Stopping"
			}, {
				$value: "unavailable",
				$title: "Unavailable"
			}],
			$default: "stopped"
		},
		refFolder: {
			$title: "Folder",
			$description: "Mother folder used for administrative tasks",
			$default: "X3",
			$isNullable: false
		},
		refUser: {
			$title: "X3 user",
			$description: "X3 user used for administrative tasks",
			$default: "ADMIN",
			$isNullable: false
		},
		refLang: {
			$title: "X3 language",
			$description: "X3 language used for administrative tasks",
			$default: "ENG",
			$isNullable: false
		},
		refUrl: {
			$isHidden: true,
			$isNullable: true
		}
	},
	$relations: {
		x3solution: {
			$type: "x3solution",
			$isMandatory: true,
			$isReadOnly: true,
			$cascadeDelete: true,
			$propagate: function(_, instance, val) {
				if (val) {
					instance.code(_, val.code(_));
				}
			}
		},
		runtimes: {
			$type: "batchServerConfigs",
			$isChild: true,
		},
		refEndpoint: {
			$type: "endPoint",
			$title: "Administrative endpoint",
			$description: "Endpoint corresponding to mother folder used for administrative tasks",
			$isMandatory: true,
			$nullOnDelete: true,
			$isNullable: true,
			$propagate: function(_, instance, val) {
				if (val === null) {
					instance.refFolder(_, null);
					instance.refUrl(_, null);
					instance.stop(_);
				} else if (val) {
					instance.refFolder(_, val.x3ServerFolder(_));
					instance.refUrl(_, val.getBaseUrl(_));
				}
			}
		}
	},
	$functions: {
		getClient: function(_, start, ignoreErr) {
			return bm.getBatchClient(this.code(_), start, ignoreErr);
		},
		start: function(_, diagnoses) {
			this.getClient(_, true).start(_, diagnoses, this, undefined);
		},
		stop: function(_, diagnoses) {
			this.getClient(_).stop(_, diagnoses, this, undefined);
		},
		stopAll: function(_, diagnoses) {
			this.getClient(_).stopAll(_, diagnoses, this, undefined);
		},
		syncServers: function(_, valuesPropagated) {
			console.error("SYNC SERVERS");
			var confEntity = this._db.getEntity(_, "batchServerConfig");
			var self = this;
			var sList = [];
			var rList = this.runtimes(_).toArray(_).map_(_, function(_, r) {
				return r.description(_);
			});
			this.x3solution(_).runtimes(_).toArray(_).forEach_(_, function(_, r) {
				sList.push(r.description(_));
				// if not already synchronized
				if (rList.indexOf(r.description(_)) === -1) {
					var c = confEntity.createInstance(_, self._db);
					c.serverHost(_, r.serverHost(_));
					c.serverPort(_, r.serverPort(_));
					c.maxQueries(_, (valuesPropagated && valuesPropagated[r.description(_)]) || 0);
					self.runtimes(_).set(_, c);
				}
			});
			this.runtimes(_).toArray(_).forEach_(_, function(_, r) {
				if (sList.indexOf(r.description(_)) === -1) {
					self.runtimes(_).deleteInstance(_, r.$uuid);
				}
			});
			this.save(_);
		},
		propagateSrvChanges: function(_, oldSrv, newSrv) {
			var bsClient = this.getClient(_, false, true);
			console.error("A");
			if (bsClient && oldSrv && newSrv) {
				var confBatch = this.runtimes(_).toArray(_).filter_(_, function(_, c) {
					return oldSrv.description(_) === c.description(_);
				});
				confBatch = confBatch && confBatch[0];
				var valuesToPropagate = {};
				console.error("B");





				if (oldSrv.description(_) !== newSrv.description(_)) {
					console.error("C");
					for (var i = 0; i < bsClient.srvQueue.contents().length; i++) {
						var s = bsClient.srvQueue.contents()[i];
						if (s.descr === oldSrv.description(_)) {
							console.error("D");
							s.descr = newSrv.description(_);
							s._isMain = newSrv.isMain(_);
							// propagate config value
							if (confBatch) valuesToPropagate[s.descr] = confBatch.maxQueries(_);
						}
					}
				}
				// if ban or disabled status changed
				if (!newSrv.banned(_) && !newSrv.disabled(_) && (oldSrv.banned(_) || oldSrv.disabled(_))) {
					// if server not already taken into account by batch controller
					if (!bsClient.srvQueue.contents().some_(_, function(_, conf) {
						return conf.descr === newSrv.description(_);
					})) {
						// and if maxQueries is set
						if (confBatch && confBatch.maxQueries(_) > 0) {
							bsClient.srvQueue.put({
								descr: newSrv.description(_).toLowerCase(),
								_maxQueries: confBatch.maxQueries(_), // set max number
								_queries: [], // init array
								_isMain: newSrv.isMain(_)
							});
						}
					}
				}
				this.syncServers(_);
			}
			// if a runtime is deleted and a batch controller is running
			else if (bsClient && oldSrv && newSrv.$isDeleted) {
				bsClient._removeSrvFromQueue(_, oldSrv.description(_));
				this.syncServers(_);
			}
			// for new runtimes
			else if (newSrv.$isCreated) {
				this.syncServers(_);
			}
		}
	},
	$services: {
		start: {
			$title: "Start",
			$description: "Start batch controller",
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "stopped";
			},
			$execute: function(_, context, instance) {
				instance.$diagnoses = instance.$diagnoses || [];
				instance.start(_, instance.$diagnoses);
			},
		},
		stop: {
			$title: "Stop",
			$description: "Stop batch controller only",
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) === "stopped";
			},
			$execute: function(_, context, instance) {
				instance.$diagnoses = instance.$diagnoses || [];
				instance.stop(_, instance.$diagnoses);
			},
		},
		stopAll: {
			$title: "Stop ALL",
			$description: "Stop batch server and all pending queries",
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) === "stopped";
			},
			$execute: function(_, context, instance) {
				instance.$diagnoses = instance.$diagnoses || [];
				instance.stopAll(_, instance.$diagnoses);
			},
		},
		_mngtAllParams: {
			$title: "_mngtAllParams",
			$description: "_mngtAllParams",
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "running";
			},
			$execute: function(_, context, instance) {
				instance.getClient(_)._mngtAllParams(_);
			},
		},
		_mngtAllReq: {
			$title: "_mngtAllReq",
			$description: "_mngtAllReq",
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "running";
			},
			$execute: function(_, context, instance) {
				instance.getClient(_)._mngtAllReq(_);
			},
		},
		_mngtServReq: {
			$title: "_mngtServReq",
			$description: "_mngtServReq",
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "running";
			},
			$execute: function(_, context, instance) {
				instance.getClient(_)._mngtServReq(_);
			},
		},
		_pendingReq: {
			$title: "_pendingRequests",
			$description: "Get global pending requests count",
			$method: "POST",
			$isMethod: true,
			$execute: function(_, context, instance) {
				instance.$diagnoses = context.instance.$diagnoses || [];
				var nb = instance.getClient(_).countPendingRequests();
				instance.$diagnoses.push({
					$severity: "info",
					$message: "NB pending: " + nb
				});
			},
		},
		queries: {
			$method: "GET",
			$isMethod: true,
			$title: "Query management",
			$parameters: {
				$url: "{refUrl}/ASYRREQ?representation=ASYRREQ.$query&orderby=NUMREQ desc",
				$method: "GET",
				$properties: {}
			},
			$execute: function(_, context, instance) {
				// Do nothing
			},
		},
	},
	$events: {
		$canDelete: [

			function(_, instance) {
				if (instance.active(_))
					instance.$addError(locale.format(module, "serverActive"));
			}
		],
		$beforeSave: [

			function(_, instance) { // report to nanny process that batch process should be started/stopped. These notifications should not happen more often than necessary, but shoud
				// never be omitted when they are necessary. The following ensures that the notifications are not omitted and that they do not happen more often
				// than necessary only when in the beginning there are 0 active instances and then simultaneously several are activated or: all active instances are
				// deactivated simultaneously (these are rare situations).
				if (config.mockServer) { // find out whether "active" flag has changed 	
					var count = instance._db.count(_, instance.getEntity(_), {
						jsonWhere: {
							active: true
						}
					});
					if (count === 0) {
						// no active instance. Therefore current instance is either new or inactive in database. 
						// Notification is necessary when it is now active
						if (instance.active(_)) instance._notifyActive = 2; // report change anyway 
					} else {
						// conditions:
						// instance.$created: current server not in database: already other server is active, therefore no check necessary
						// instance.active(_): is instance now active, either it was not active before (and therefore another instance was active) or active flag has not changed 
						if (!instance.$created && !instance.active(_)) {
							var oldInstance = instance._db.fetchInstance(_, instance.getEntity(_), instance.$uuid);
							// only interesting case: flag has now changed from true to false, so maybe there are no active servers any more
							if (!oldInstance || oldInstance.active(_))
								instance._notifyActive = (count === 1 ? 2 : 1); // when there are at least 2 active instances in the beginning, re-check after   
							// saving whether there is no active instance left. Reason for double-checking: when several instances
							// are deactivated at the same time, there must be at least one signal to the nanny process)
						}
					}
				}
			}
		],
		$afterSave: [

			function(_, instance) { // named user check
				// update host data when either "active" instance is newly created or "active" flag is changed
				if (config.mockServer && (instance._notifyActive === 2 || instance._notifyActive === 1 && 0 === instance._db.count(_, instance.getEntity(_), {
					jsonWhere: {
						active: true
					}
				}))) {
					var options = {
						path: "/nannyCommand/notifyNannies/update",
						method: "PUT"
					};
					try {
						console.log(config.mockServer.mockClient.simpleRequest(options, null, _));
					} catch (e) {
						console.log("Error " + e);
					}
				}
				instance._notifyActive = undefined;
			}
		],
	},

};