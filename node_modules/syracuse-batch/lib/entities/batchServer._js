"use strict";

var locale = require('streamline-locale');
var bm = require('../batchManager');
var batchHelper = require('../batchHelper');
var helpers = require('@sage/syracuse-core').helpers;
var config = require('config');
var globals = require('streamline-runtime').globals;
var mock = require('@sage/syracuse-lib/src/load-balancer/mock');
var config = require('config');
var withTenant = (config.hosting && config.hosting.multiTenant);
import {
	getBroker
} from "../../../@sage/syracuse-lib/src/pub-sub/broker";

function getX3FolderLangs(_, db) {
	var x3folderIsoLangs = [];
	var tablanQuery = db.getEntity(_, "TABLAN", "$query");
	var tablan = db.fetchInstances(_, tablanQuery, {
		sdataWhere: "LANISO ne '' and LANCON eq true"
	});
	tablan && tablan.forEach_(_, function(_, f) {
		x3folderIsoLangs.push(f.LANISO(_));
	});
	return x3folderIsoLangs;
}

exports.entity = {
	$lockType: "noLock",
	$titleTemplate: "Batch server",
	$valueTemplate: "{code}",
	$descriptionTemplate: "Batch server",
	$helpPage: "Administration-reference_Batch-server",
	$canDelete: false,
	$canCreate: false,
	$capabilities: "",
	$properties: {
		code: {
			$title: "Code",
			$isReadOnly: true,
			$isUnique: true,
			$isMandatory: true,
			$linksToDetails: true
		},
		auto: {
			$type: "boolean",
			$title: "Auto start",
			$default: false
		},
		execInterval: {
			$title: "Time between two searches (sec)",
			$type: "integer",
			$isMandatory: true,
			$default: 30,
			$minimum: 1,
			$minimumCanEqual: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "stopped";
			}
		},
		killOverTime: {
			$title: "Timeout search time (sec)",
			$type: "integer",
			$isMandatory: true,
			$default: 30,
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "stopped";
			}
		},
		maxDelay: {
			$title: "Maximum delay to launch a query (minutes)",
			$type: "integer",
			$default: 0,
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "stopped";
			}
		},
		status: {
			$title: "Status",
			$isReadOnly: true,
			$enum: [{
				$value: "running",
				$title: "Running"
			}, {
				$value: "starting",
				$title: "Starting"
			}, {
				$value: "stopped",
				$title: "Stopped"
			}, {
				$value: "stopping",
				$title: "Stopping"
			}, {
				$value: "unavailable",
				$title: "Unavailable"
			}],
			$default: "stopped"
		},
	},
	$relations: {
		x3solution: {
			$type: "x3solution",
			$isMandatory: true,
			$isReadOnly: true,
			$inv: "batchServer",
			$propagate: function(_, instance, val) {
				if (val) {
					instance.code(_, val.code(_));
				}
			}
		},
		refEndpoint: {
			$type: "endPoint",
			$title: "Administrative endpoint",
			$description: "Endpoint corresponding to mother folder used for administrative tasks",
			$nullOnDelete: true,
			$isNullable: true,
			$propagate: function(_, instance, val) {
				if (val === null) {
					instance.stop(_);
				}
			}
		},
		user: {
			$title: "User",
			$description: "User used for administrative tasks",
			$type: "user",
			$isNullable: true
		},
		role: {
			$title: "Role",
			$description: "Role used for administrative tasks",
			$type: "role",
			$isNullable: true
		},
		localePref: {
			$title: "Locale",
			$type: "localePreference",
			$description: "Language used for administrative tasks",
			$isMandatory: true,
			$lookupFilter: function(_, instance) {
				var ep = instance.refEndpoint(_);
				var filter;
				var x3IsoLangs = [];
				if (ep) {
					var db = ep.getOrm(_);
					try {
						x3IsoLangs = getX3FolderLangs(_, db);
						x3IsoLangs.forEach_(_, function(_, l) {
							filter = filter || {
								$or: []
							};
							filter.$or.push({
								"code": l
							});
						});
					} catch (e) {
						console.error(locale.format(module, "repAdossierMissing", ep.dataset(_), e.message));
					}
				} else {
					filter = {
						code: {
							$in: []
						}
					};
				}
				return filter;
			}
		},
		runtimes: {
			$capabilities: "",
			$type: "batchServerConfigs",
			$isChild: true,
		},
	},
	$functions: {
		$serialize: function(_) {
			// dynamicaly define the listQueries link
			var self = this;
			var res = self._internalSerialize(_);
			var ep = this.refEndpoint(_);
			if (ep) {
				res.refUrl = ep.getBaseUrl(_);
			}
			return res;
		},
		syncOldConf: function(_) {
			// no need to use only B0 in this case
			batchHelper.getOldX3BatchConfig(_, this);
		},
		_propagateConfigChanges: function(_) {
			var _trace; // = console.error;
			var maxQueriesMap = {};
			var configs = this.runtimes(_).toArray(_);
			// store new values in map
			configs.forEach_(_, function(_, r) {
				maxQueriesMap[r.$uuid] = {
					new: {
						description: r.description(_),
						maxQueries: r.maxQueries(_)
					}
				};
			});

			// fetch the instance to get old values before modifications
			var oldBatchServer = this._db.fetchInstance(_, this._db.getEntity(_, "batchServer"), {
				jsonWhere: {
					code: this.code(_)
				}
			});
			if (!oldBatchServer) return;

			oldBatchServer.runtimes(_).toArray(_).forEach_(_, function(_, r) {
				maxQueriesMap[r.$uuid] = maxQueriesMap[r.$uuid] || {};
				maxQueriesMap[r.$uuid].old = {
					description: r.description(_),
					maxQueries: r.maxQueries(_)
				};
			});

			this._changesOnFly = this._changesOnFly || {};
			for (var i = 0; i < Object.keys(maxQueriesMap).length; i++) {
				var uuid = Object.keys(maxQueriesMap)[i];
				var conf = maxQueriesMap[uuid];
				// if change made manually on batch configuration
				if (!helpers.object.areEqual(conf.old, conf.new)) {
					// batch configuration propagation
					if (conf.new.maxQueries > 0) {
						this._changesOnFly.qUpdate = this._changesOnFly.qUpdate || [];
						// we create the entry on the fly
						_trace && _trace("qUpdate because maxQueries changed: " + conf.new.description);

						// if not already set by x3solution change !
						if (!this._changesOnFly.qUpdate.some(function(elt) {
								return elt.server === uuid;
							})) {
							var updConf = {
								server: uuid, // use uuid because nanny command propagation needs it !
								maxQueries: conf.new.maxQueries
							};
							if (conf.old && conf.old.description !== conf.new.description) {
								updConf.reconnect = true;
							}
							this._changesOnFly.qUpdate.push(updConf);
						}

					} else {
						_trace && _trace("qRemove because maxQueries 0: " + conf.new.description);
						this._changesOnFly.qRemove = this._changesOnFly.qRemove || [];
						this._changesOnFly.qRemove.push(uuid);
					}
				}

			}

			// the magic happens here :)
			var self = this;

			if (Object.keys(this._changesOnFly).length > 0) {
				//this.applyChanges(_, this._changesOnFly);
				getBroker(_).publish(_, "batch", {
					action: "applyChanges",
					code: self.code(_),
					data: this._changesOnFly
				});
			}

		},
		getChannelName: function(_) {
			return "batch.diagnoses." + this.code(_);
		},

		executeCommand: function(_, action) {
			var self = this;
			self.$diagnoses = self.$diagnoses || [];
			var message = getBroker(_).publishAndWaitOn(_, "batch", {
				action: action,
				code: self.code(_)
			}, self.getChannelName(_));

			self.$diagnoses = self.$diagnoses.concat(message);

			var reloadInst = self._db.fetchInstance(_, self._meta, self.$uuid);
			if (reloadInst)
				self.status(_, reloadInst.status(_));

		}
	},
	$services: {
		start: {
			$title: "Start",
			$description: "Start batch controller",
			$facets: ["$details", "$query"],
			$method: "POST",
			$isMethod: true,
			//$invocationMode: "async",
			$isDisabled: function(_, instance) {
				return instance.status(_) === "running" || instance.status(_) === "starting";
			},
			$execute: function(_, context, instance) {
				instance.executeCommand(_, "start");
			},
		},
		stop: {
			$title: "Stop",
			$description: "Stop batch controller only",
			$facets: ["$details", "$query"],
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "running" && instance.status(_) !== "starting";
			},
			$execute: function(_, context, instance) {
				instance.executeCommand(_, "stop");
			},
		},
		stopAll: {
			$title: "Stop ALL",
			$description: "Stop batch server and all pending queries",
			$method: "POST",
			$facets: ["$details", "$query"],
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) === "stopped";
			},
			$execute: function(_, context, instance) {
				instance.executeCommand(_, "stopAll");
			},
		},
		queries: {
			$method: "GET",
			$isMethod: true,
			$title: "List of queries",
			$parameters: {
				$url: "{refUrl}/ASYRREQ?representation=ASYRREQ.$query&orderBy=NUMREQ desc",
				$method: "GET",
				$properties: {}
			},
			$execute: function(_, context, instance) {
				// Do nothing
			},
			$isDisabled: function(_, instance) {
				return !instance.refEndpoint(_);
			},
		},
		syncOldConf: {
			$title: "Synchronize configuration",
			$description: "Synchronize old X3 batch server configuration or initialize it",
			$method: "POST",
			$facets: ["$details"],
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "stopped";
			},
			$execute: function(_, context, instance) {
				instance.$diagnoses = instance.$diagnoses || [];
				instance.syncOldConf(_);
			},
		}
	},
	$links: function(_, instance) {
		var lnks = {};
		if (instance.refEndpoint(_)) {
			lnks.x3traces = {
				$title: "X3 server traces",
				$url: instance.refEndpoint(_).getBaseUrl(_) + "/$service/upload?fileName=[SRV]/TRA/serveur.tra&type=1&$format=txt",
				$method: "GET",
				$isDisabled: !instance.refEndpoint(_)
			};
		}
		return lnks;
	},
	$events: {
		$afterSave: [

			function(_, instance) {
				instance.$diagnoses = instance.$diagnoses || [];
				if (!instance._initialization) instance._propagateConfigChanges(_);
			}
		],
	},
};