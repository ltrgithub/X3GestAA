"use strict";

var locale = require('streamline-locale');
var bm = require('syracuse-batch/lib/batchManager');
var httpClient = require('syracuse-httpclient/lib/httpClient');
var config = require('config');
var flows = require('streamline-runtime').flows;
var globals = require('streamline-runtime').globals;
var mock = require('syracuse-load/lib/mock');
var config = require('config');
var withTenant = (config.hosting && config.hosting.multiTenant);

exports.entity = {
	$lockType: "noLock",
	$titleTemplate: "Batch server",
	$valueTemplate: "{code}",
	$descriptionTemplate: "Batch server",
	$properties: {
		code: {
			$title: "Code",
			$isReadOnly: true,
			$isUnique: true,
			$isMandatory: true,
			$linksToDetails: true
		},
		active: {
			$type: "boolean",
			$title: "Active",
			$default: false
		},
		auto: {
			$type: "boolean",
			$title: "Auto start",
			$default: false
		},
		execInterval: {
			$title: "Time between two searches (sec)",
			$type: "integer",
			$isMandatory: function(_, instance) {
				return instance.active(_);
			},
			$default: 30,
			$isNullable: true
		},
		killOverTime: {
			$title: "Timeout search time (sec)",
			$type: "integer",
			$isMandatory: function(_, instance) {
				return instance.active(_);
			},
			$default: 30,
			$isNullable: true
		},
		maxDelay: {
			$title: "Maximum delay to launch a query (minutes)",
			$type: "integer",
			$default: 0,
			$isNullable: true
		},
		status: {
			$title: "Status",
			$isReadOnly: true,
			$enum: [{
				$value: "running",
				$title: "Running"
			}, {
				$value: "stopped",
				$title: "Stopped"
			}, {
				$value: "stopping",
				$title: "Stopping"
			}, {
				$value: "unavailable",
				$title: "Unavailable"
			}],
			$default: "stopped"
		},
		refFolder: {
			$title: "Folder",
			$description: "Mother folder used for administrative tasks",
			$default: "X3",
			$isNullable: false
		},
		refUser: {
			$title: "X3 user",
			$description: "X3 user used for administrative tasks",
			$default: "ADMIN",
			$isNullable: false
		},
		refLang: {
			$title: "X3 language",
			$description: "X3 language used for administrative tasks",
			$default: "ENG",
			$isNullable: false
		},
		refUrl: {
			$isHidden: true,
			$isNullable: true
		}
	},
	$relations: {
		x3solution: {
			$type: "x3solution",
			$isMandatory: true,
			$isReadOnly: true,
			$cascadeDelete: true,
			$propagate: function(_, instance, val) {
				if (val) {
					instance.code(_, val.code(_));
				}
			}
		},
		runtimes: {
			$type: "batchServerConfigs",
			$isChild: true,
		},
		refEndpoint: {
			$type: "endPoint",
			$title: "Administrative endpoint",
			$description: "Endpoint corresponding to mother folder used for administrative tasks",
			$isMandatory: true,
			$nullOnDelete: true,
			$isNullable: true,
			$propagate: function(_, instance, val) {
				if (val === null) {
					instance.refFolder(_, null);
					instance.refUrl(_, null);
					instance.stop(_);
				} else if (val) {
					instance.refFolder(_, val.x3ServerFolder(_));
					instance.refUrl(_, val.getBaseUrl(_));
				}
			}
		}
	},
	$functions: {
		getClient: function(_, start, ignoreErr) {
			return bm.getBatchClient(this.code(_), start, ignoreErr);
		},
		start: function(_, diagnoses) {
			this.getClient(_, true).start(_, diagnoses, this, undefined);
		},
		stop: function(_, diagnoses) {
			this.getClient(_).stop(_, diagnoses, this, undefined);
		},
		stopAll: function(_, diagnoses) {
			this.getClient(_).stopAll(_, diagnoses, this, undefined);
		},
		syncServers: function(_, valuesPropagated) {
			valuesPropagated = valuesPropagated || {};
			var confEntity = this._db.getEntity(_, "batchServerConfig");
			var self = this;
			var sList = [];
			var rList = this.runtimes(_).toArray(_).map_(_, function(_, r) {
				return r.description(_);
			});
			this.x3solution(_).runtimes(_).toArray(_).forEach_(_, function(_, r) {
				sList.push(r.description(_));
				// if not already synchronized
				if (rList.indexOf(r.description(_)) === -1) {
					var c = confEntity.createInstance(_, self._db);
					c.serverHost(_, r.serverHost(_));
					c.serverPort(_, r.serverPort(_));
					c.maxQueries(_, valuesPropagated[r.description(_)] || 0);
					self.runtimes(_).set(_, c);
				}
			});
			this.save(_);
			this.runtimes(_).toArray(_).forEach_(_, function(_, r) {
				if (sList.indexOf(r.description(_)) === -1) {
					self.runtimes(_).deleteInstance(_, r.$uuid);
				}
			});
			this.save(_);
		},
		propagateSrvChanges: function(_, oldSrv, newSrv) {
			try {
				this.$diagnoses = this.$diagnoses || [];
				var bsClient = this.getClient(_, false, true);
				if (oldSrv && newSrv) {
					var valuesToPropagate = {};
					try {
						var confBatch = this.runtimes(_).toArray(_).filter_(_, function(_, c) {
							return oldSrv.description(_) === c.description(_);
						});
						confBatch = confBatch && confBatch[0];

						var self = this;
						if (oldSrv.description(_) !== newSrv.description(_)) {
							// propagate config value
							if (confBatch) valuesToPropagate[newSrv.description(_)] = confBatch.maxQueries(_);
							// if batch controller is started
							if (bsClient) {
								for (var i = 0; i < bsClient.srvQueue.contents().length; i++) {
									var s = bsClient.srvQueue.contents()[i];
									if (s.descr === oldSrv.description(_)) {
										var newDescr = newSrv.description(_);
										var maxQ = confBatch.maxQueries(_);
										var isM = newSrv.isMain(_);
										// update server config on the fly and force administrative client reconnection
										bsClient._updateSrvInQueue(function(err, updated) {
											if (err) return;
											if (!updated) {
												// we create the entry on the fly
												bsClient._addSrvInQueue(flows.ignore, self.$diagnoses, newDescr, maxQ, isM);
											}
										}, this.$diagnoses, oldSrv.description(_), newDescr, maxQ, isM, true);
										break;
									}
								}
							}
						}
						// if batch controller is started
						if (bsClient) {
							// if ban or disable a server, the controller will remove the configuration by itself --> nothing to do...
							// if unban or enabled a server
							if (!newSrv.banned(_) && !newSrv.disabled(_) && (oldSrv.banned(_) || oldSrv.disabled(_))) {
								// if server not already taken into account by batch controller
								if (!bsClient.srvQueue.contents().some_(_, function(_, conf) {
									return conf.descr === newSrv.description(_);
								})) {
									// and if maxQueries is set
									if (confBatch && confBatch.maxQueries(_) > 0) {
										bsClient._addSrvInQueue(_, this.$diagnoses, newSrv.description(_), confBatch.maxQueries(_), newSrv.isMain(_));
									}
								}
								// else the configuration is already taken into account --> nothing to do...
							}
						}
					} finally {
						this.syncServers(_, valuesToPropagate);
					}
				}
				// if a runtime is deleted and a batch controller is running
				else if (bsClient && oldSrv && newSrv.$isDeleted) {
					bsClient._removeSrvFromQueue(_, this.$diagnoses, oldSrv.description(_));
					this.syncServers(_);
				}
				// for new runtimes
				else if (newSrv.$isCreated) {
					// the new configuration will be set with maxQueries to 0,
					// so the configuration would be propagated to batch controller when batch server itself will be be updated
					this.syncServers(_);
				}
			} catch (e) {
				console.error("e: " + e.stack);
			}
		},
		_propagate: function(_, action, id, method) { // propagation only when load balancer is available!
			if ("mockServer" in config) {
				var self = this;
				var path = "/nannyCommand/notifyB/batch/" + action + "?code=" + encodeURIComponent(id);
				if (withTenant) {
					path += '&tenantId=' + globals.context.tenantId;
					console.log("Set tenant " + path);
				}
				var options = {
					path: path,
					method: method || "GET",
					headers: {
						hostname: (globals.context.tenantId || "")
					},
				};
				options.headers[mock.BALANCER_HEADER] = config.port;
				// console.log("Propagate: "+util.format(options))
				try {
					var text = config.mockServer.mockClient.simpleRequest(options, "", _);
					var lines = text.split(/[\r\n]+/);
					console.log("TEXT " + text);
					lines.forEach(function(line) {
						if (line.charAt(0) === '{') {
							var childData = JSON.parse(line);
							if (childData.message) {
								var diags = JSON.parse(childData.message);
								diags.forEach(function(diag) {
									self.$diagnoses.push(diag);
								});
							}
						}
					});
				} catch (e) {
					console.error("Error " + e.stack);
					self.$addError({
						$severity: "error",
						$message: "" + e,
						$stack: e.stack
					});
				}
				// update local instance

				// TODO: make this better
				var inst_new = this._db.fetchInstance(_, this._meta, this.$uuid);
				if (inst_new) {
					self.status(_, inst_new.status(_));

				}
			}
		}
	},
	$services: {
		start: {
			$title: "Start",
			$description: "Start batch controller",
			$facets: ["$details"],
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "stopped" || !instance.active(_);
			},
			$execute: function(_, context, instance) {
				instance.$diagnoses = instance.$diagnoses || [];
				if ("mockServer" in config)
					instance._propagate(_, "start", instance.code(_));
				else
					instance.start(_, instance.$diagnoses);
			},
		},
		stop: {
			$title: "Stop",
			$description: "Stop batch controller only",
			$facets: ["$details"],
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) === "stopped" || !instance.active(_);
			},
			$execute: function(_, context, instance) {
				instance.$diagnoses = instance.$diagnoses || [];
				if ("mockServer" in config)
					instance._propagate(_, "stop", instance.code(_));
				else
					instance.stop(_, instance.$diagnoses);
			},
		},
		stopAll: {
			$title: "Stop ALL",
			$description: "Stop batch server and all pending queries",
			$method: "POST",
			$facets: ["$details"],
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) === "stopped" || !instance.active(_);
			},
			$execute: function(_, context, instance) {
				instance.$diagnoses = instance.$diagnoses || [];
				if ("mockServer" in config)
					instance._propagate(_, "stopAll", instance.code(_));
				else
					instance.stopAll(_, instance.$diagnoses);
			},
		},
		_mngtAllParams: {
			$title: "_mngtAllParams",
			$description: "_mngtAllParams",
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "running" || !instance.active(_);
			},
			$execute: function(_, context, instance) {
				instance.getClient(_)._mngtAllParams(_);
			},
		},
		_mngtAllReq: {
			$title: "_mngtAllReq",
			$description: "_mngtAllReq",
			$method: "POST",
			$facets: ["$details"],
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "running" || !instance.active(_);
			},
			$execute: function(_, context, instance) {
				instance.getClient(_)._mngtAllReq(_);
			},
		},
		_mngtServReq: {
			$title: "_mngtServReq",
			$description: "_mngtServReq",
			$facets: ["$details"],
			$method: "POST",
			$isMethod: true,
			$isDisabled: function(_, instance) {
				return instance.status(_) !== "running" || !instance.active(_);
			},
			$execute: function(_, context, instance) {
				instance.getClient(_)._mngtServReq(_);
			},
		},
		_pendingReq: {
			$title: "_pendingRequests",
			$description: "Get global pending requests count",
			$method: "POST",
			$facets: ["$details"],
			$isMethod: true,
			$execute: function(_, context, instance) {
				instance.$diagnoses = context.instance.$diagnoses || [];
				var nb = instance.getClient(_).countPendingRequests();
				instance.$diagnoses.push({
					$severity: "info",
					$message: "NB pending: " + nb
				});
			},
		},
		queries: {
			$method: "GET",
			$isMethod: true,
			$title: "Query management",
			$parameters: {
				$url: "{refUrl}/ASYRREQ?representation=ASYRREQ.$query&orderby=NUMREQ desc",
				$method: "GET",
				$properties: {}
			},
			$execute: function(_, context, instance) {
				// Do nothing
			},
		},
	},
	$links: function(_, instance) {
		return {
			x3traces: {
				$title: "X3 server traces",
				$url: instance.refEndpoint(_).getBaseUrl(_) + "/$service/upload?fileName=[SRV]/TRA/serveur.tra&type=1&$format=txt",
				$method: "GET",
				$isDisabled: !instance.refEndpoint(_)
			}
		};
	},
	$events: {
		$canDelete: [

			function(_, instance) {
				if (instance.active(_))
					instance.$addError(locale.format(module, "serverActive"));
			}
		],
		$beforeSave: [

			function(_, instance) {
				instance.$diagnoses = instance.$diagnoses || [];
				// report to nanny process that batch process should be started/stopped. These notifications should not happen more often than necessary, but shoud
				// never be omitted when they are necessary. The following ensures that the notifications are not omitted and that they do not happen more often
				// than necessary only when in the beginning there are 0 active instances and then simultaneously several are activated or: all active instances are
				// deactivated simultaneously (these are rare situations).
				if (config.mockServer) { // find out whether "active" flag has changed 	
					var count = instance._db.count(_, instance.getEntity(_), {
						jsonWhere: {
							active: true
						}
					});
					if (count === 0) {
						// no active instance. Therefore current instance is either new or inactive in database. 
						// Notification is necessary when it is now active
						if (instance.active(_)) instance._notifyActive = 2; // report change anyway 
					} else {
						// conditions:
						// instance.$created: current server not in database: already other server is active, therefore no check necessary
						// instance.active(_): is instance now active, either it was not active before (and therefore another instance was active) or active flag has not changed 
						if (!instance.$created && !instance.active(_)) {
							var oldInstance = instance._db.fetchInstance(_, instance.getEntity(_), instance.$uuid);
							// only interesting case: flag has now changed from true to false, so maybe there are no active servers any more
							if (!oldInstance || oldInstance.active(_))
								instance._notifyActive = (count === 1 ? 2 : 1); // when there are at least 2 active instances in the beginning, re-check after   
							// saving whether there is no active instance left. Reason for double-checking: when several instances
							// are deactivated at the same time, there must be at least one signal to the nanny process)
						}
					}
				}
			}
		],
		$afterSave: [

			function(_, instance) { // named user check
				// update host data when either "active" instance is newly created or "active" flag is changed
				if (config.mockServer && (instance._notifyActive === 2 || instance._notifyActive === 1 && 0 === instance._db.count(_, instance.getEntity(_), {
					jsonWhere: {
						active: true
					}
				}))) {
					var options = {
						path: "/nannyCommand/notifyNannies/update",
						method: "PUT"
					};
					try {
						console.log(config.mockServer.mockClient.simpleRequest(options, null, _));
					} catch (e) {
						console.log("Error " + e);
					}
				}
				instance._notifyActive = undefined;
			}
		],
	},

};