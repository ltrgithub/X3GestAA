"use strict";

var locale = require('syracuse-core').locale;
var X3BatchException = require("syracuse-batch/lib/x3BatchException").X3BatchException;
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var x3FolderHelper = require('syracuse-collaboration/lib/entities/lookupX3Folder');
var globals = require('streamline-runtime').globals;
var x3client = require('syracuse-x3/lib/client');
var tracer = require('syracuse-core').getTracer("batch");

var host;

exports.connectX3Client = function(_, x3sol, options) {
	var adminEP = adminHelper.getCollaborationEndpoint(_);
	// ensure endpoint exists
	var ep = x3sol.getEp(_, options.folder);
	if (!ep) ep = x3sol.createEndpoint(_, options.folder);

	// create X3 client
	var client = x3client.create({
		x3solution: x3sol,
		x3server: options.x3server
	});
	var localePref = options.localePref || getLocalePrefFromX3Lang(_, options.lang);
	var _x3 = client.connect(_, {
		server: x3sol.serverHost(_),
		folder: options.folder,
		locale: localePref.code(_),
		runtimeLog: options.runtimeLogFlag || "",
		runtimeLogDir: options.runtimeLogDir || ""
	});
	client.pid = _x3.pid;

	// !!!
	// this part of code doesn't retrieve session on syracuse startup
	// it works only when 'start' service is called manually
	var context = globals.context;
	var session = context && (context.httpSession || context.session);
	host = host || (session && session.host);
	// the impact is that baseUrl and collaborationBaseUrl are only sub urls like '/sdata/x3/erp/...'
	// !!!

	var sessionOpt = {
		userName: options.user,
		adxtyp: options.adxtyp || 35, // adxtyp = 35 for batch
		locale: localePref.code(_),
		localePreferences: options.localePref,
		baseUrl: host ? host + ep.getBaseUrl(_) : "", //context && context.baseUrl,
		collaborationBaseUrl: host ? (adminEP ? host + adminHelper.getCollaborationEndpoint(_).getBaseUrl(_) : "") : "",
		license: options.license
	};
	//console.error("Session opt: "+require('util').inspect(sessionOpt,null,2));
	var x3Session = client.createSession(_, sessionOpt);
	return {
		client: client,
		session: x3Session
	};
};

function getLocalePrefFromX3Lang(_, lang) {
	var iso = locale.defaultIso(lang);
	if (!iso) throw new Error(locale.format(module, "langIncorrect", lang));
	return exports.getLocalePrefFromIso(_, iso);
}

var localesMap = {};

exports.getLocalePrefFromIso = function(_, iso) {
	var db = adminHelper.getCollaborationOrm(_);
	if (iso.length === 2) iso = locale.longIso(iso);
	locale.setCurrent(_, iso);
	var codeIso = iso.substring(0, 3) + iso.substring(3).toUpperCase();
	if (!localesMap[codeIso]) localesMap[codeIso] = db.fetchInstance(_, db.model.getEntity(_, "localePreference"), {
		jsonWhere: {
			code: codeIso
		}
	});
	if (!localesMap[codeIso]) throw new Error("Can't find locale preference corresponding to '" + iso + "'");
	return localesMap[codeIso];
};

function syncWithSolution(_, batchSrvInst) {
	//console.error("Synchronize solutions and batches");
	var confEntity = batchSrvInst._db.getEntity(_, "batchServerConfig");

	var sList = [];
	var rList = batchSrvInst.runtimes(_).toArray(_).map_(_, function(_, r) {
		return r.description(_);
	});
	if (batchSrvInst.x3solution(_)) {
		batchSrvInst.x3solution(_).runtimes(_).toArray(_).forEach_(_, function(_, r) {
			sList.push(r.description(_));
			// if not already synchronized
			if (rList.indexOf(r.description(_)) === -1) {
				var c = confEntity.createInstance(_, batchSrvInst._db);
				c.$uuid = r.$uuid; // same uuid as x3server --> very important !
				c.serverHost(_, r.serverHost(_));
				c.serverPort(_, r.serverPort(_));
				c.maxQueries(_, 0);
				batchSrvInst.runtimes(_).set(_, c);
			}
		});
		batchSrvInst.save(_);
		batchSrvInst.runtimes(_).toArray(_).forEach_(_, function(_, r) {
			if (sList.indexOf(r.description(_)) === -1) {
				batchSrvInst.runtimes(_).deleteInstance(_, r.$uuid);
			}
		});
		batchSrvInst.save(_);
	}
}

exports.getOldX3BatchConfig = function(_, batchSrvInst) {

	try {
		var tracePrefix = "[" + batchSrvInst.code(_) + "] ";
		var connOpt = {
			x3server: batchSrvInst.x3solution(_).selectX3Server(_),
			lang: batchSrvInst.refLang(_) || "ENG",
			user: batchSrvInst.refUser(_) || "ADMIN",
			folder: batchSrvInst.refFolder(_) || "X3",
			adxtyp: 35
		};
		var client = exports.connectX3Client(_, batchSrvInst.x3solution(_), connOpt).client;
		var resp = exports.execRpc(_, batchSrvInst.$diagnoses, client, batchSrvInst.refUrl(_), "ASYRSRVBATCH", "ABATCH_MNGT_ALLPARGET", "POST", {}, {
			throwErr: true,
			prefix: tracePrefix
		});
		var config = resp && resp.$result;
		if (config) {

			if (config.execInterval != null) batchSrvInst.execInterval(_, config.execInterval);
			if (config.killOverTime != null) batchSrvInst.killOverTime(_, config.killOverTime);
			if (config.maxDelay != null) batchSrvInst.maxDelay(_, config.maxDelay);
			if (config.maxQueries != null) {
				var mainSrvConf = batchSrvInst.runtimes(_).toArray(_).filter_(_, function(_, r) {
					return batchSrvInst.x3solution(_).isMainRuntime(_, r.serverHost(_), r.serverPort(_));
				})[0];
				if (mainSrvConf) {
					mainSrvConf.maxQueries(_, config.maxQueries);
				}
			}
			tracer.info && tracer.info(tracePrefix + "Configration retrieved from X3 and applied to this instance: " + JSON.stringify(config, null, 2));
			batchSrvInst.save(_);
		}
		client.disconnect(_);
	} catch (e) {
		console.error(e.$diagnoses ? JSON.stringify(e.$diagnoses, null, 2) + "\n" + e.stack : e.stack);
		batchSrvInst.$diagnoses = batchSrvInst.$diagnoses || [];
		if (e.$diagnoses) {
			e.$diagnoses.forEach(function(d) {
				batchSrvInst.$diagnoses.push(d);
			});
		}
		batchSrvInst.$diagnoses.push({
			$severity: "error",
			$message: e.message
		});
	} finally {
		return batchSrvInst;
	}
};

exports.initBatchServer = function(_, s) {
	var db = adminHelper.getCollaborationOrm(_);
	var bsEntity = db.getEntity(_, "batchServer");
	var bs = db.fetchInstance(_, bsEntity, {
		jsonWhere: {
			code: s.code(_)
		}
	});
	//console.error("Init batch server for solution " + s.code(_));
	// create if if doesn't exist
	var bsReady;
	if (!bs) {
		bs = bsEntity.createInstance(_, db);
		bs.code(_, s.code(_));
		bs.x3solution(_, s);

		// compute ref endpoint
		var ep;
		if (s) {
			try {
				var motherFolders = x3FolderHelper.getFoldersFromJson(_, s, function(f) {
					return f.mother && f.mother.length === 0;
				});
				if (motherFolders && motherFolders.length > 0) {
					ep = s.getEp(_, motherFolders[0].name);
					if (!ep) {
						ep = s.createEndpoint(_, motherFolders[0].name);
					}
					if (ep) {
						bs.refEndpoint(_, ep);
						bsReady = true;
					}
				}
			} catch (e) {
				console.error("An error occured when synchronising x3 solution and batch server '" + s.code(_) + "'\n" + e.stack);
			}
		}

	}

	if (!bs.user(_)) {
		var usrEntity = db.getEntity(_, "user");
		var usr = db.fetchInstance(_, usrEntity, {
			jsonWhere: {
				login: "admin"
			}
		});
		if (usr) bs.user(_, usr);
	}

	if (!bs.localePref(_)) {
		var lpEntity = db.getEntity(_, "localePreference");
		var lp = db.fetchInstance(_, lpEntity, {
			jsonWhere: {
				code: "en-US"
			}
		});
		if (lp) bs.localePref(_, lp);
	}

	// reset status
	if (bs.status(_) === "running" || bs.status(_) === "stopping") {
		bs.status(_, "stopped");
	}
	// synchronize runtimes list with x3solution configuration
	try {
		syncWithSolution(_, bs);
	} catch (e) {
		console.error(e.stack);
	}

	// try to get old X3 batch server configuration
	if (bsReady) {
		bs.syncOldConf(_);
	}

	// start the batch server
	if (bs.active(_) && bs.auto(_)) {
		bs.start(_);
	}

	s.batchServer(_, bs);
	s.save(_);
	return s;
};

exports.initBatchServers = function(_) {
	var db = adminHelper.getCollaborationOrm(_);
	var x3solutions = db.fetchInstances(_, db.getEntity(_, "x3solution"));

	x3solutions.forEach_(_, function(_, s) {
		exports.initBatchServer(_, s);

	});
};

exports.sdataRequest = function(_, diagnoses, client, url, alias, method, body, options) {
	function _inspectResponse(_, resp) {
		if (resp) {
			if (!options.noTraces) tracer.debug && tracer.debug(options.prefix + alias + " (" + client.x3server.description(_) + ") call result: " + JSON.stringify(resp, null, 2));
			if (resp.head && resp.head.status) {
				if (resp.head.status !== 200) {
					var diags = (resp.body && resp.body.$diagnoses) || [];
					if (diags.length === 0 && resp.head.message) {
						diags.push({
							$severity: "error",
							$message: locale.format(module, "x3err", alias, resp.head.message)
						});
					}
					if (diags && diags.length > 0) {
						diags.forEach_(_, function(_, d) {
							diagnoses && diagnoses.push(d);
							tracer.error && tracer.error(options.prefix + alias + " (" + client.x3server.description(_) + ") call result: " + resp.head.status + " - " + d.$message + "\n" + d.safeStack);
						});
						// some actions need to be blocking (like configuration propagation)
						var customErr = new X3BatchException(diags[0].$message);
						customErr.stack = diags[0].$stackTrace;
						if (options.throwErr) throw customErr;
					}
				} else {
					if (!options.noTraces) tracer.info && tracer.info(options.prefix + alias + " (" + client.x3server.description(_) + ") call result: " + resp.head.status);
					return resp.body;
				}
			}
		}
		return null;
	}
	//
	//
	options = options || {};
	var params = {
		head: {
			method: method,
			url: url,
			accept: "application/json",
			"content-type": "application/json"
		},
		body: body
	};

	if (client && client._srvConf && !client.isAlive()) {
		tracer.error && tracer.error(options.prefix + " client " + client.pid + " is not alive !!!");
		return;
	} else if (!client) {
		tracer.error && tracer.error("No client provided to execute sdata request '" + alias + "'");
		return;
	}

	if (!options.noTraces) {
		tracer.debug && tracer.debug(options.prefix + alias + " Execute sdata request on " + client.x3server.description(_) + " with adonix: " + (client && client.pid) + " - alive: " + (client && client.isAlive()) + " (url=" + url + ")");
		tracer.info && tracer.info(options.prefix + alias + " call params: " + JSON.stringify(params));
	}

	var resp = client.jsonSend(_, params);
	return _inspectResponse(_, resp);
};

exports.execRpc = function(_, diagnoses, client, refUrl, mod, name, method, body, options) {
	var url = refUrl + "/$service/rpc?module=" + mod + "&name=" + name;
	return exports.sdataRequest(_, diagnoses, client, url, mod + ":" + name, method, body, options);
};