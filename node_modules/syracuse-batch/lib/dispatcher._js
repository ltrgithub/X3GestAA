"use strict";
var syracuse;
var url = require('url');
var batchManager = require('./batchManager');
var mock = require('@sage/syracuse-lib/src/load-balancer/mock');
var config = require('config');
var globals = require('streamline-runtime').globals;

var multiTenant = config.hosting && config.hosting.multiTenant;
var tracer; // = console.error;

exports.dispatcher = function(config) {
	return function(_, request, response) {
		tracer && tracer("DISPb " + request.url);
		syracuse = syracuse || require('syracuse-main/lib/syracuse');
		if (syracuse.server instanceof mock.MockStreamServer && !request.fromNanny && !request._request.fromNanny || !(syracuse.server instanceof mock.MockStreamServer) && (!config.system || !config.system.enableDevelopmentFeatures)) {
			response.writeHead("404", {});
			return response.end("Resource not found.");
		}
		var parsed = url.parse(request.url, true);
		var parts = parsed.pathname.split('/');
		var tenant = parsed.query.tenantId;
		if (multiTenant && tenant && !syracuse.initializedTenant(tenant)) {
			syracuse.initializeTenant(_, tenant); // manual start of pool should work even when Tenant collection is not up to date
		} else {
			globals.context.tenantId = tenant;
		}


		var data = request.readAll(_);
		if (data && data.length > 0) {
			try {
				data = JSON.parse(data);
				tracer && tracer("DISPb DATA: " + JSON.stringify(data, null, 2));
				globals.context.session = {
					id: data.id,
					clientId: data.clientId,
					serverName: data.serverName,
					getData: function(code) {
						return data.data && data.data[code];
					}
				};
			} catch (e) {
				console.error("Can't parse nanny request data: " + e.safeStack);
			}
		}


		var command = parsed.pathname.split('/')[2];
		tracer && tracer("TENANT " + globals.context.tenantId);
		var diagnoses = [];
		try {
			var client = batchManager.getBatchClient(parsed.query.code, (command === "start"));
			if (command in client)
			// second parameter: instance of batch Server (will be created internally when necessary)
				client[command](_, diagnoses, undefined, data);
		} catch (e) {
			console.error("Batch server dispatcher error: " + e.stack);
			diagnoses.push({
				$severity: "error",
				$message: "" + e,
				$stack: e.stack
			});
		}
		tracer && tracer("DISPb Diagnoses: " + JSON.stringify(diagnoses, null, 2));
		var json = new Buffer(JSON.stringify(diagnoses));
		response.writeHead(200, {
			"Content-Type": "application/json",
			"Content-length": json.length
		});
		response.end(json);
	};
};