"use strict";

/*
 * proxyManager singleton
 */
var events = require('events');
var http = require('http');
var url = require('url');
var helpers = require("syracuse-core/lib/helpers");
var sessionManager = require("syracuse-session/lib/sessionManager").sessionManager;
var streams = require("streamline/lib/streams/streams");
var sys = require("util");

//TEMPORARY, must solve x3client not receiving body in POST issue
helpers.readAllProxy = true;


//TODO ALCOU A mettre dans une fonction helper ?
//Problématique d'avoir une dissimétrie entre lecture et écriture des headers http.

function _normalizeMapUri(uri) {
	var uri = uri.toLowerCase();
	if(uri.indexOf("http") == 0) 
		return "/"+uri.split("/").slice(3).join("/");
	else
		return uri;
}

function upperCaseHeaderName(headerName) {
	return headerName.split("-").map(function(h) {
		var f = h.substring(0, 1).toUpperCase();
		return f + h.substring(1, h.length).toLowerCase();
	}).join("-");
}

function nodeToHttpHeaderAdapter(nodeHeader) {
	var httpHeader = {};
	if (typeof nodeHeader === "string") {
		return nodeHeader;
	}
	Object.keys(nodeHeader).forEach(function(headerName) {
		var capitalized = upperCaseHeaderName(headerName);
		if (capitalized == "Content-Length") // HACK
		return;
		httpHeader[capitalized] = nodeHeader[headerName];
	});
	return httpHeader;
}

function _getProxyURL(uri, request) {
	var parsedURL = url.parse(uri, true);
	var localRequest = false;
	uri = parsedURL.query.url;
	var localHost = (('authorized' in request.connection) ? "https" : "http") + "://" + request.headers.host;
	// detect local host
	if (uri[0] == "/") {
		uri = localHost + uri;
		localRequest = true;
	} else {
		localRequest = uri.indexOf(localHost) == 0;
	}
	return {
		uri: uri,
		local: localRequest
	};
}

function _streamRequest(_, request, response, uriConfig) {
	var rurl = request.url.replace(/'/g, "%27"); // temp fix for 0.4.2 url.parse
	var parsedURL = url.parse(rurl);
	if (parsedURL.port) parsedURL.port = parseInt(parsedURL.port, 10);
	else parsedURL.port = 80;
	//	data.headers = data.headers || {};
	var map = exports.proxyManager.getMap(request.url);
	if (!map && uriConfig.local) map = {
		local: true
	};
	if (map) {
		_authAndStream(_, map, parsedURL, request, response);
	} else {
		throw new Error("Proxy Config not found for " + request.url);
	}
}

function _authAndStream(_, map, purl, request, response) {
	if (map.authmodule) {
		var auth = require(map.authmodule).Authentication;
		if (auth) {
			if (!request.session) request.session = sessionManager.sessionByCookie(request.headers.cookie);
			//var send = function(req) {
			//	return _send(purl, req, map);
			//};
			request.parsedURI = purl;
			request.authData = map;
			// SHORTCIRCUIT AUTH FOR NOW
			//auth.authentificate(data, send);
			_stream(_, purl, request, response, map);
		}
	}
	_stream(_, purl, request, response, map);
}

function _request(_, data) {
	var rurl = data.url.replace(/'/g, "%27"); // temp fix for 0.4.2 url.parse
	var parsedURL = url.parse(rurl);
	if (parsedURL.port) parsedURL.port = parseInt(parsedURL.port, 10);
	else parsedURL.port = 80;
	data.headers = data.headers || {};
	var map = exports.proxyManager.getMap(data.url);
	if (!map && data.local) map = {
		local: true
	};
	if (map) {
		return _authAndSend(_, map, parsedURL, data);
	} else {
		throw new Error("Proxy Config not found for " + data.url);
	}
}

function _authAndSend(_, map, purl, data) {
	if (map.authmodule) {
		var auth = require(map.authmodule).Authentication;
		if (auth) {
			if (!data.session) data.session = sessionManager.sessionByCookie(data.headers.cookie);
			//var send = function(req) {
			//	return _send(purl, req, map);
			//};
			data.parsedURI = purl;
			data.authData = map;
			// SHORTCIRCUIT AUTH FOR NOW
			//auth.authentificate(data, send);
			return _send(_, purl, data, map);
		}
	}
	return _send(_, purl, data, map);
}

function _send(_, parsedURL, data, map) {
	if (data.error) throw data.error;

	var resData = {
		statusCode: 200,
		body: null,
		headers: null
	};
	var headers = data.headers || {};
	headers.host = parsedURL.host;
	data.method = (data.method || "GET");
	if (data.local && data.session) headers.cookie = data.session.cookie;
	var sendBody = false;
	if (helpers.readAllProxy) {
		sendBody = ((data.method != "GET") && data.body);
		if (sendBody) {
			if (typeof(data.body) == "object") {
				data.body = JSON.stringify(data.body);
				headers["Content-Type"] = "application/json; charset=UTF-8";
				headers["Content-Length"] = data.body.length;
			} else if (typeof(data.body) == "string") {
				headers["Content-Type"] = "application/json; charset=UTF-8";
				headers["Content-Length"] = data.body.length;
			} else {
				data.body = null;
				sendBody = false;
			}
		}
	}
	headers["User-Agent"] = "NodeJS HTTP Client";
	headers["x-requested-with"] = "XMLHttpRequest";
	if (typeof map.processRequest === "function") {
		return map.processRequest(_, data)
	}
	// TODO: shortcircuit local requests
	// TODO: switch to https is map says so.
	var options = {
		url: parsedURL.href,
		//protocol: parsedURL.protocol,
		//host: parsedURL.hostname, 
		//port: parsedURL.port,
		//path: (parsedURL.pathname || "/") 
		//+ (parsedURL.query ? ("?" + parsedURL.query) : "") 
		//+ (parsedURL.hash ? ("#" + parsedURL.hash) : ""),
		method: data.method,
		headers: headers
	};
	//console.log("PROXY SEND " + options.url)
	var proxyRequest = streams.httpRequest(options);
	if (!helpers.readAllProxy) {
		var buffer = null;
		while (buffer = data.request.read(_)) proxyRequest.write(_, buffer, "utf8");
	} else if (sendBody) proxyRequest.write(_, data.body, "utf8");
	var proxyResponse = proxyRequest.end().response(_);
	//console.log("PROXY RESPONSE " + proxyResponse.statusCode)
	resData.statusCode = proxyResponse.statusCode;
	resData.headers = {};
	Object.keys(proxyResponse.headers).forEach(function(header) {
		resData.headers[header] = proxyResponse.headers[header]
	});
	if (helpers.readAllProxy) {
		resData.body = proxyResponse.readAll(_);
		if (data.afterRequest) {
			if (!data.afterRequest(resData)) {
				delete data.error;
				delete data.afterRequest;
				return _request(_, data);
			}
		}
	} else resData.proxyResponse = proxyResponse;
	return resData;
}

function ProxyRequestManager(config) {
	this.map = {};
	this.interceptAfter = null;
};

helpers.defineClass(ProxyRequestManager, null, {
	setup: function(config) {
		var self = this;
		if (!config) return;
		if (config.map) {
			config.map.forEach(function(map) {
				self.map[_normalizeMapUri(map.uri)] = map;
			});
//			self.map = config.map;
		}
	},
	getMap: function(url) {
/*		var self = this;
		var i = self.map.length;
		var map = null;
		while (i--) {
			map = self.map[i];
			if (locUrl.indexOf(map.uri) == 0) return map;
		}
		return null;*/
		var normalUri = _normalizeMapUri(url);
		for (var prefix in this.map) {
			if (normalUri.substring(0, prefix.length) == prefix) return this.map[prefix];
		}
		return null;
//		return this.map[_normalizeMapUri(url)];
	},
	forward: function(_, data) {
		//console.log("PROXY: " + data.method + " " + data.url)
		var self = this;
		data.headers = data.headers || {};
		if (data.url && (data.url[0] === "/")) {
			var host = data.headers.host || "localhost";
			data.url = "http://" + host + data.url;
		}
		var parsedURL = url.parse(data.url);
		if (parsedURL.port) parsedURL.port = parseInt(parsedURL.port, 10);
		else parsedURL.port = 80;
		var map = self.getMap(data.url);
		if (!map && data.local) map = {
			local: true
		};
		if (!map) {
			return {
				statusCode: 404,
				body: "Host not found : " + data.url,
				headers: data.headers
			}
		}
		return _authAndSend(_, map, parsedURL, data);
	},
	_sendResult: function(_, requestData, request, response, data, proxyURL) {
		var self = this;
		if (self.interceptAfter) data = self.interceptAfter(_, requestData, request, data, proxyURL);
		response.writeHead(data.statusCode, nodeToHttpHeaderAdapter(data.headers));
		if (!helpers.readAllProxy && !data.body) { // data.body test added for X3 pool
			var buffer = null;
			while (buffer = data.proxyResponse.read(_)) response.write(_, buffer, "utf8");
		} else if (data.body) {
			var ct = (data.headers && data.headers['content-type']) || "text";
			ct = ct.split('/');
			if (ct[0] === 'image' || ct[1] === 'pdf') {
				response.write(_, data.body);
			} else {
				if (typeof data.body == "object") {
					data.body = JSON.stringify(data.body);
				}
				response.write(_, data.body, "utf8");
			}
		}
		response.end();
	},
	proxy: function(_, request, response) {
		try {
			var self = this;
			var uriConfig = _getProxyURL(request.url, request);
			var requestData = "";

			var data = {
				method: request.headers["x_http_method_override"] || request.method,
				uri: request.url,
				headers: request.headers,
				body: ""
			};
			if (!helpers.readAllProxy) data.request = request;
			else data.body = request.readAll(_);
/* TODO: reenable later
			 if (request._session) {
			 var fn = request._session;
			 request._session = null;
			 var cb = function() {
			 _dispatch(_, data, request, response);
			 };
			 fn(cb);
			 } else*/
			if (!uriConfig.uri) throw new Error("invalid proxy call (url).");

			data.url = uriConfig.uri;
			data.local = uriConfig.local;
			var rsp = _request(_, data);
			self._sendResult(_, data.body, request, response, rsp, uriConfig.uri)
			return true;
		} catch (ex) {
			response.writeHead(500, {});
			response.end(ex.message + "\n" + ex.stack);
		}
	},
	updateProxyMap: function(proxyMapEntry) {
		if (proxyMapEntry && !this.getMap(proxyMapEntry.uri))
			this.map[_normalizeMapUri(proxyMapEntry.uri)] = proxyMapEntry;
		//	this.map.push(proxyMapEntry);
	}
});

exports.proxyManager = new ProxyRequestManager(null);