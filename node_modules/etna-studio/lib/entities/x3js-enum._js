"use strict";
const globals = require('streamline-runtime').globals;
const fsp = require('path');
const fs = require('fs');
const util = require('etna/lib/supervisor/util');
const x3jsUtil = require('etna/lib/x3js/util');
const entityHelper = require('etna/lib/x3js/entity-helper');
const entityParser = require('etna/lib/x3js/entity-parser');
const enumDescriptor = require('etna/lib/x3js/enum-descriptor');
const codeGen = require('etna/lib/x3js/entity-codegen');
const ezm = require('ez-mongodb');

function fillInstance(_, helper, instance, metaData, parsed) {
	var data;
	if (parsed) {
		data = parsed.data;
		if (!data.module) throw new Error(`${data.file}: no module`);
		instance.module(_, data.module || '');
		instance.name(_, data.name || '');
		instance.dictId(_, data.dictId || '');
		instance.title(_, data.title || '');
		instance.status(_, data.status || '4gl');
		instance.comment(_, data.comment || '');
		instance.source(_, fs.readFile(parsed.file, 'utf8', _));
	} else {
		instance.module(_, '');
		instance.name(_, '');
		instance.status(_, '4gl');
		instance.comment(_, '');
		instance.source(_, '');
		data = helper.metaToCanonical(_, metaData);
	}
	helper.fillInstance(_, instance, data);
}

function updateAll(_, instance, saving) {
	entityHelper.fromInstance(_, instance, enumDescriptor).updateAll(_, instance, saving);
}

exports.entity = {
	$canDelete: true,
	$canCreate: true,
	$canEdit: true,
	$capabilities: "",
	$titleTemplate: "Enum {name} {title}",
	$listTitle: "List of X3JS enums",
	$descriptionTemplate: " ",
	$valueTemplate: " ",
	$properties: {
		module: {
			$title: "module",
		},
		name: {
			$title: "X3JS name",
			$linksToDetails: true,
			$control: x3jsUtil.controlPascalCase('name'),
			$propagate: function(_, instance, value) {
				updateAll(_, instance);
			},
		},
		dictId: {
			$title: "chapter",
			$type: 'integer',
			$linksToDetails: true,
			$isReadOnly: enumDescriptor.rules.readOnlyProperty,
		},
		title: {
			$title: "title",
			$isReadOnly: enumDescriptor.rules.readOnlyProperty,
		},
		status: {
			$title: "dev status",
			$enum: [{
				$value: "4gl",
				$title: "4GL",
			}, {
				$value: "incomplete",
				$title: "mapping in progress",
			}, {
				$value: "mapped",
				$title: "mapped",
			}, {
				$value: "x3js",
				$title: "X3JS",
			}, {
				$value: "error",
				$title: "error",
			}],
			$isReadOnly: true,
		},
		comment: {
			$title: "comment",
		},
		source: {
			$title: "source",
			$type: "javascript",
		},
		sourceState: {
			$title: "source state",
			$type: "string",
			$isHidden: true,
		},
	},
	$relations: {
		endpoint: {
			$type: "endPoint",
			$title: "Endpoint",
			$isReadOnly: true,
		},
		entries: {
			$type: "x3jsEnumEntries",
			$isChild: true,
			$title: "Values",
		},
	},
	$events: {
		$afterActions(_, instance) {
			updateAll(_, instance);
		},
		$beforeSave(_, instance) {
			updateAll(_, instance, true);
		},
	},
	$functions: {
		$toString(_) {
			return `enum ${this.name(_)} (${this.dictId(_)})`;
		},
		conflictingMappings(_) {
			return [];
		},
		missingMappings(_) {
			if (!this.module(_)) return [`${this.dictId(_)}: missing module name`];
			if (!this.name(_)) return [`${this.dictId(_)}: missing enum name`];
			const missing = [];
			this.entries(_).toArray(_).forEach_(_, (_, entry) => {
				if (!entry.name(_)) {
					missing.push(`${this.dictId(_)}.${entry.dictId(_)}: missing value mapping`);
				}
			});
			return missing;
		},
	},
	$services: {
		synchronize: {
			$method: "POST",
			$isMethod: false,
			$facets: ["$query"],
			$title: "Synchronize list",
			$invocationMode: "async",
			$execute(_, context) {
				const tracker = context.tracker;
				const userProfile = globals.context.session.getUserProfile(_);
				const endpoint = userProfile.selectedEndpoint(_);
				const superv = entityHelper.getSupervisor(_, endpoint);
				const helper = entityHelper.create(superv, classDescriptor);

				const parsedFiles = entityParser.parseSourceFiles(_, 'enums', enumDescriptor, superv, tracker);
				const byDictId = parsedFiles.reduce((r, parsed) => {
					console.error("PARSEDFILES", parsed.file, parsed.data);
					parsed.ast = null;
					if (parsed.data.dictId != null) {
						const old = r[parsed.data.dictId];
						if (old) throw new Error(`${parsed.file}: duplicate dictId, already found in ${old.file}`);
						r[parsed.data.dictId] = parsed;
					}
					return r;
				}, {});
				const enums = parsedFiles;

				const entity = context.db.model.getEntity(_, "x3jsEnum");

				tracker.phase = 'processing metadata';
				const processed = {};
				var oldData;
				var instance, LANCHP = -Infinity;

				const flush = (_) => {
					if (!instance) return;
					instance.save(_);
					tracker.$diagnoses = tracker.$diagnoses || [];

					if (instance.hasErrors(_)) {
						const oldLen = tracker.$diagnoses.length;
						instance.getAllDiagnoses(_, tracker.$diagnoses, {
							addEntityName: true,
							addPropName: true,
						});
						console.error("SAVE FAILED", tracker.$diagnoses.slice(oldLen));
					}
					processed[instance.dictId(_)] = true;
					instance = null;
				};

				ezm.reader(superv.mongoStore.collection('APLSTD', _).find({
					LAN: 'ENG',
				}).sort({
					LANCHP: 1,
					LANNUM: 1,
				})).forEach(_, (_, metaData) => {
					if (!metaData.LANCHP) return;
					//console.error(metaData);
					if (LANCHP !== metaData.LANCHP) {
						flush(_);
						LANCHP = metaData.LANCHP;
						const oldData = context.db.db.collection('X3jsEnum', _).find({
							'endpoint._uuid': endpoint.$uuid,
							dictId: metaData.LANCHP,
						}).toArray(_)[0];
						instance = entity.factory.createInstance(_, null, context.db, null, oldData && oldData._id);
						instance.endpoint(_, endpoint);
						fillInstance(_, helper, instance, metaData, byDictId[metaData.LANCHP]);
						// preserve mapping data.
						if (oldData) {
							instance.status(_, oldData.status);
							instance.name(_, oldData.name);
							instance.comment(_, oldData.comment);
						} else {
							instance.dictId(_, metaData.LANCHP);
							instance.status(_, '4gl');
						}
					}
					if (metaData.LANNUM != null) {
						const entries = instance.entries(_);
						var entry = entries.toArray(_).filter_(_, (_, entry) => entry.dictId(_) === metaData.LANNUM)[0];
						if (!entry) {
							entry = entries.add(_);
							entry.dictId(_, metaData.LANNUM);
							entry.title(_, metaData.LANMES);
						}
					}

				});
				flush(_);

				tracker.phase = 'purging metadata';
				/*
				context.db.db.collection('X3jsEnum', _).remove({
					'endpoint._uuid': endpoint.$uuid,
					dictId: {
						$not: {
							$in: Object.keys(processed),
						},
					},
				}, _);
				*/

				tracker.phase = 'inserting pure x3js enums';
				enums.forEach_(_, (_, parsed) => {
					const fileData = parsed.data;
					if (fileData.dictId) {
						if (processed[fileData.dictId]) return;
						else throw new Error(`${fileData.name}: invalid dictId: ${fileData.dictId}`);
					}
					const instance = entity.factory.createInstance(_, null, context.db);
					instance.endpoint(_, endpoint);
					fillInstance(_, helper, instance, null, parsed);
					instance.save(_);
				});
				tracker.progress = 100;
			},
		},
	},
	$defaultOrder: [
		["module", true],
		["name", true],
		["dictId", true]
	],
};

entityHelper.fillEntity(exports.entity, enumDescriptor);