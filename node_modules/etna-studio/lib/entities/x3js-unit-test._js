"use strict";
const globals = require('streamline-runtime').globals;
const fsp = require('path');
const fs = require('fs');
const util = require('etna/lib/supervisor/util');
const x3jsUtil = require('etna/lib/x3js/util');
const entityHelper = require('etna/lib/x3js/entity-helper');
const unitTestDescriptor = require('etna/lib/x3js/unit-test-descriptor');
const datetime = require('syracuse-core').types.datetime;

function updateAll(_, instance, saving) {
	entityHelper.fromInstance(_, instance, unitTestDescriptor).updateAll(_, instance, saving);
}

exports.entity = {
	$canDelete: true,
	$canCreate: true,
	$canEdit: true,
	$capabilities: "",
	$titleTemplate: "Unit test {name}",
	$listTitle: "List of X3JS Unit Tests",
	$descriptionTemplate: " ",
	$valueTemplate: "{name}",
	$properties: {
		module: {
			$title: "module",
		},
		name: {
			$title: "name",
			$linksToDetails: true,
			$control: x3jsUtil.controlKebabCase('name'),
			$propagate: function(_, instance, value) {
				updateAll(_, instance);
			},
		},
		title: {
			$title: "title",
		},
		active: {
			$title: "active",
			$type: "boolean",
		},
		comment: {
			$title: "comment",
		},
		source: {
			$title: "source",
			$type: "javascript",
		},
		sourceState: {
			$title: "source state",
			$type: "string",
			$isHidden: true,
		},
	},
	$relations: {
		endpoint: {
			$type: "endPoint",
			$title: "Endpoint",
			$isReadOnly: true,
		},
		cases: {
			$type: "x3jsUnitTestCases",
			$isChild: true,
			$title: "Test Cases",
		},
	},
	$events: {
		$afterActions(_, instance) {
			updateAll(_, instance);
		},
		$beforeSave(_, instance) {
			updateAll(_, instance, true);
		},
	},
	$links: {
		results: {
			$title: "All test results",
			"$url": "{$baseUrl}/x3jsUnitTestResults?representation=x3jsUnitTestResult.$query",
			"$method": "GET"
		},
	},

	$functions: {
		$toString(_) {
			return `unit test ${this.name(_)})`;
		},
		conflictingMappings(_) {
			return [];
		},
		missingMappings(_) {
			return [];
		},
	},
	$services: {
		synchronize: {
			$method: "POST",
			$isMethod: false,
			$facets: ["$query"],
			$title: "Synchronize list",
			$invocationMode: "async",
			$execute(_, context) {
				return entityHelper.fromCurrentSession(_, unitTestDescriptor).synchronize(_, context);
			}
		},
		execute: {
			$method: "POST",
			$isMethod: true,
			$facets: ["$details"],
			$title: "Run unit test",
			$invocationMode: "async",
			$execute(_, context, instance) {
				const helper = entityHelper.fromCurrentSession(_, unitTestDescriptor);
				const tracker = context.tracker;
				tracker.$phase = `running unit test`;
				tracker.$details = instance.name(_);
				tracker.$diagnoses = tracker.$diagnoses || [];
				const beg = datetime.now();
				const result = helper.supervisor.api.runUnitTest(_, helper.sourceFilename(instance.module(_), instance.name(_)));
				const end = datetime.now();
				context.tracker.$phase = `saving test result`;
				const resultObj = instance._db.getEntity(_, 'x3jsUnitTestResult').createInstance(_, instance._db);
				resultObj.fill(_, beg, end, [{
					unitTest: instance,
					result: result,
				}]);
				resultObj.save(_);
				if (resultObj.hasErrors(_)) {
					const errors = [];
					resultObj.getAllDiagnoses(_, errors, {
						addEntityName: true,
						addPropName: true,
					});
					throw new Error(`results save failed: ${JSON.stringify(errors)}`);
				}
				tracker.$links = {
					$result: {
						$title: "test result",
						$url: `{baseUrl}/x3jsUnitTestResults('${resultObj.$uuid}')?representation=x3jsUnitTestResult.$details`,
						$method: "GET",
					},
				};
				if (resultObj.passed(_)) {
					tracker.$diagnoses.push({
						$severity: 'info',
						$message: `test passed: ${resultObj.summary(_)}`,
					});
				} else {
					tracker.$diagnoses.push({
						$severity: 'error',
						$message: `test failed: ${resultObj.summary(_)}`,
					});
				}
				tracker.progress = 100;
			}
		},
	},
	$defaultOrder: [
		["name", true]
	]
};

entityHelper.fillEntity(exports.entity, unitTestDescriptor);