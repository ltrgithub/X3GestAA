"use strict";
const globals = require('streamline-runtime').globals;
const fsp = require('path');
const fs = require('fs');
const util = require('etna/lib/supervisor/util');
const x3jsUtil = require('etna/lib/x3js/util');
const entityParser = require('etna/lib/x3js/entity-parser');
const entityHelper = require('etna/lib/x3js/entity-helper');
const classDescriptor = require('etna/lib/x3js/class-descriptor');

function updateAll(_, instance, saving) {
	entityHelper.fromInstance(_, instance, classDescriptor).updateAll(_, instance, saving);
}

exports.entity = {
	$canDelete: true,
	$canCreate: true,
	$canEdit: true,
	$capabilities: "",
	$titleTemplate: "Class {name} {title}",
	$listTitle: "List of classes",
	$descriptionTemplate: " ",
	$valueTemplate: "{name}",
	$properties: {
		module: {
			$title: "module",
			$isReadOnly: classDescriptor.rules.readOnlyProperty,
		},
		name: {
			$title: "X3JS name",
			$linksToDetails: true,
			$control: x3jsUtil.controlPascalCase('name'),
			$propagate: function(_, instance, value) {
				updateAll(_, instance);
			},
		},
		dictCode: {
			$title: "dictionary code",
			$linksToDetails: true,
			$isReadOnly: classDescriptor.rules.readOnlyProperty,
		},
		title: {
			$title: "title",
			$isReadOnly: classDescriptor.rules.readOnlyProperty,
		},
		status: {
			$title: "dev status",
			$enum: [{
				$value: "4gl",
				$title: "4GL",
			}, {
				$value: "incomplete",
				$title: "mapping in progress",
			}, {
				$value: "mapped",
				$title: "mapped",
			}, {
				$value: "x3js",
				$title: "X3JS",
			}, {
				$value: "error",
				$title: "error",
			}],
			$isReadOnly: true,
		},
		comment: {
			$title: "comment",
		},
		source: {
			$title: "source",
			$type: "javascript",
		},
		sourceState: {
			$title: "source state",
			$type: "string",
			$isHidden: true,
		},
	},
	$relations: {
		endpoint: {
			$type: "endPoint",
			$title: "Endpoint",
			$isReadOnly: true,
		},
		properties: {
			$type: "x3jsProperties",
			$isChild: true,
			$title: "Properties",
		},
		collections: {
			$type: "x3jsClassCollections",
			$isChild: true,
			$title: "Collections",
		},
		scripts: {
			$type: "x3jsClassScripts",
			$isChild: true,
			$title: "Scripts",
		},
		joins: {
			$type: "x3jsClassJoins",
			$isChild: true,
			$title: "Joins",
		},
		behaviors: {
			$type: "x3jsClassBehaviors",
			$isChild: true,
			$title: "Behaviors",
		},
		tableDef: {
			$type: "x3jsClassTable",
			$isChild: true,
			$title: "Table definition",
		},
		unitTests: {
			$type: "x3jsUnitTests",
			$title: "Unit Tests",
			$isComputed: true,
			$inv: 'class',
			$links: { // TODO: link does not work :-(. would be cool to have a button to create a unit test here
				create: {
					$title: 'Create unit test',
					$method: 'POST',
					$url: "{$baseUrl}/x3jsUnitTests?representation=x3jsUnitTest.$edit",
				}
			},
		},
	},
	$links: { // TODO: link does not work :-(. would be cool to have a button to create a unit test here
		createUnitTest: {
			$facets: ['details'],
			$title: 'Create unit test',
			$method: 'POST',
			$type: "application/json;vnd.sage=syracuse",
			$url: "{$baseUrl}/x3jsUnitTests/$template/$workingCopies?representation=x3jsUnitTest.$edit&class={$uuid}&module={module}&active=true",
			$target: "main",
		},
	},
	$events: {
		$afterActions(_, instance) {
			updateAll(_, instance);
		},
		$beforeSave(_, instance) {
			updateAll(_, instance, true);
		},
	},
	$functions: {
		$toString(_) {
			return `class ${this.name(_)} (${this.dictCode(_)})`;
		},
		conflictingMappings(_) {
			const names = {};
			const properties = this.properties(_).toArray(_);
			const errors = [];
			properties.forEach_(_, (_, prop) => {
				const name = prop.name(_);
				if (name) {
					if (names[name]) {
						errors.push(`duplicate property mapping: ${name} used by ${names[name].dictCode(_)} and ${prop.dictCode(_)}`);
					} else {
						names[name] = prop;
					}
				}
			});
			return errors;
		},
		missingMappings(_) {
			if (!this.name(_)) return [`${this.dictCode(_)}: missing X3JS class name`];
			const missing = [];
			this.properties(_).toArray(_).forEach_(_, (_, prop) => {
				if (!prop.name(_)) {
					missing.push(`${prop.dictCode(_)}: missing X3JS property name`);
				}
				if (prop.type(_) === 'enum' && /^\d/.test(prop.enum(_))) {
					missing.push(`${prop.dictCode(_)}: missing enum name - numeric enum id ${prop.enum(_)} must be converted to an enum name`);
				}
			});
			this.collections(_).toArray(_).forEach_(_, (_, coln) => {
				if (!coln.name(_)) {
					missing.push(`${coln.dictCode(_) || coln.itemClassCode(_)}: missing X3JS collection name`);
				}
				if (coln.itemClassCode(_) && !coln.itemClassName(_)) {
					missing.push(`${coln.dictCode(_) || coln.itemClassCode(_)}: missing X3JS item class name`);
				}
			});
			return missing;
		},
	},
	$services: {
		synchronize: {
			$method: "POST",
			$isMethod: false,
			$facets: ["$query"],
			$title: "Synchronize list",
			$invocationMode: "async",
			$execute(_, context) {
				return entityHelper.fromCurrentSession(_, classDescriptor).synchronize(_, context);
			}
		},
	},
	$defaultOrder: [
		["name", true]
	]
};

entityHelper.fillEntity(exports.entity, classDescriptor);