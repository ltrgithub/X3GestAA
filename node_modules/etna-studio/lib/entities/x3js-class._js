"use strict";
const globals = require('streamline-runtime').globals;
const fsp = require('path');
const fs = require('fs');
const supervisor = require("etna/lib/supervisor/supervisor");
const ACTX = require("etna/lib/supervisor/builtins/ACTX");
const x3jsUtil = require('etna/lib/x3js/util');

function x3jsModule(clas) {
	return 'system'; // see later
}

function x3jsInfo(_, clas) {
	var script;
	var comment;
	var status;
	var mod = x3jsModule(clas);
	try {
		const classPath = mod + '.' + clas.jsName;
		script = clas.supervisor.loadJsScript(_, 'classes', classPath);
		if (!script) status = 'not started';
		else {
			const def = script.default;
			if (!def) throw new Error(`$ {
				classPath
			}: invalid script: no default`);
			if (!def.dictCode) status = 'upgraded';
			else if (def.mapped) status = 'mapped';
			else status = 'generated';

			comment = def.comment || '';
		}
	} catch (ex) {
		console.error(ex.stack);
		comment = ex.message;
	}
	return {
		module: mod,
		status: status,
		comment: comment,
		title: clas.title(_, 'ENG'),
	}
}

function getSupervisor(_, context, endpoint) {
	if (!endpoint.useEtna(_)) throw new Error("operation not available on current endpoint");
	const conf = endpoint.getEtnaConfig(_, context.request.session);
	const superv = supervisor.create(_, conf);
	ACTX.init(_, conf.session, superv);
	return superv;
}

function fillInstance(_, inst, clas, endpoint, old) {
	const info = x3jsInfo(_, clas);
	if (old &&
		clas.jsName === old.jsName &&
		clas.title === old.title &&
		clas.name === old.dictCode &&
		info.title === old.title &&
		info.module === old.module &&
		info.status === old.status &&
		info.comment === old.comment) return false;
	if (old) inst.$uuid = old._id;
	if (!old) {
		// do not update these ones automatically
		inst.name(_, clas.jsName);
		inst.dictCode(_, clas.name);
		inst.title(_, info.title);
		inst.comment(_, info.comment);
	}
	inst.module(_, info.module);
	inst.status(_, info.status);
	inst.endpoint(_, endpoint);

	const properties = inst.properties(_);
	properties.reset(_);
	Object.keys(clas.properties)
		.filter(k => !x3jsUtil.isSysProperty(clas.properties[k].name))
		.forEach_(_, (_, k) => {
			const prop = clas.properties[k];
			const x3jsProp = properties.add(_);
			x3jsProp.name(_, prop.jsName);
			x3jsProp.title(_, prop.title(_, 'ENG'));
			x3jsProp.dictCode(_, prop.name);
			x3jsProp.comment(_, '');
		});
	return true;
}

// This entity is not persistent 
exports.entity = {
	$canDelete: true,
	$canCreate: true,
	$canEdit: true,
	$capabilities: "",
	$titleTemplate: "Class {name}",
	$listTitle: "List of X3JS classes",
	$descriptionTemplate: " ",
	$valueTemplate: " ",
	$properties: {
		module: {
			$title: "module",
			$isReadOnly(_, instance) {
				return !!instance.dictCode(_);
			},
		},
		name: {
			$title: "X3JS name",
			$linksToDetails: true,
		},
		title: {
			$title: "title",
			$isReadOnly(_, instance) {
				return !!instance.dictCode(_);
			},
		},
		dictCode: {
			$title: "dictionary code",
			$isReadOnly(_, instance) {
				return !!instance.dictCode(_);
			},
		},
		status: {
			$title: "dev status",
			$enum: [{
				$value: "not started",
				$title: "not started",
			}, {
				$value: "generated",
				$title: "generated",
			}, {
				$value: "mapped",
				$title: "mapped",
			}, {
				$value: "upgraded",
				$title: "upgraded",
			}, {
				$value: "invalid",
				$title: "invalid",
			}],
			$isReadOnly(_, instance) {
				return !!instance.dictCode(_);
			},
		},
		comment: {
			$title: "comment",
		},
		source: {
			$title: "source",
			$type: "javascript",
		},
	},
	$relations: {
		endpoint: {
			$type: "endPoint",
			$title: "Endpoint",
			$isReadOnly: true,
		},
		properties: {
			$type: "x3jsProperties",
			$isChild: true,
			$title: "Properties",
		},
	},
	$functions: {},
	$services: {
		synchronize: {
			$method: "POST",
			$isMethod: false,
			$facets: ["$query"],
			$title: "Synchronize list",
			$invocationMode: "async",
			$execute(_, context) {
				const tracker = context.tracker;
				const userProfile = globals.context.session.getUserProfile(_);
				const endpoint = userProfile.selectedEndpoint(_);
				const superv = getSupervisor(_, context, endpoint);
				const entity = context.db.model.getEntity(_, "x3jsClass");
				tracker.phase = 'reading old list';
				var existing = context.db.db.collection('X3jsClass', _).find({
					'endpoint._uuid': endpoint.$uuid,
				}).toArray(_);
				existing = existing.reduce((r, d) => {
					tracker.phaseDetail = `$ {
						d.dictCode
					}`;
					if (d.dictCode) r[d.dictCode] = d;
					return r;
				}, {});
				tracker.phase = 'synchronizing';
				superv.reader(_, 'Class').forEach(_, function(_, clas, i) {
					tracker.phaseDetail = `#$ {
						i
					}: $ {
						clas.name
					}`;
					const inst = entity.factory.createInstance(_, null, context.db);
					if (fillInstance(_, inst, clas, endpoint, existing[clas.name])) inst.save(_);
				});
				tracker.progress = 100;
				return context.reply(_, 200, {});
			},
		},
		generateCode: {
			$method: "POST",
			$isMethod: true,
			$facets: ["$details"],
			$title: "Generate code",
			$isHidden(_, instance) {
				return !instance.dictCode(_);
			},
			$execute(_, context, instance) {
				const superv = getSupervisor(_, context, instance.endpoint(_));
				const clas = superv.load(_, 'Class', instance.dictCode(_));
				// fix jsName
				clas.jsName = instance.name(_);
				const output = require('etna/lib/x3js/classCodeGen').generateSourceFile(_, clas);
				instance.$addDiagnose("success", `source generated: $ {
					clas.x3jsSourceFile
				}`);
				instance.source(_, output.code);
			},
		},
	},
	$defaultOrder: [
		["name", true]
	]
};