"use strict";
const globals = require('streamline-runtime').globals;
const fsp = require('path');
const fs = require('fs');
const supervisor = require("etna/lib/supervisor/supervisor");
const ACTX = require("etna/lib/supervisor/builtins/ACTX");
const util = require('etna/lib/supervisor/util');
const x3jsUtil = require('etna/lib/x3js/util');
const classParser = require('etna/lib/x3js/classParser');
const entityHelper = require('etna/lib/x3js/entity-helper');
const classDescriptor = require('etna/lib/x3js/classDescriptor');
const codeGen = require('etna/lib/x3js/classCodeGen');
const ezm = require('ez-mongodb');

function x3jsModule(clas) {
	return 'system'; // see later
}

function processSourceFiles(_, tracker, superv) {
	tracker.phase = 'reading source files';
	const root = superv.directories.jsLocal || superv.directories.jsShared;
	if (!root) throw new Error("cannot processs files: root directory missing");
	const classes = [];
	const byDictCode = {};
	fs.readdir(root, _).forEach_(_, (_, sub) => {
		const classesDir = fsp.join(root, sub, 'classes');
		if (!fs.exists(classesDir, _, _)) return;
		fs.readdir(classesDir, _).forEach_(_, (_, fname) => {
			if (!fname.endsWith('.x3js')) return;
			const filePath = fsp.join(classesDir, fname);
			tracker.phaseDetail = filePath;
			var parsed = classParser.parseFile(_, filePath);
			parsed.ast = null; // we don't need it here
			if (parsed.data.dictCode) {
				const old = byDictCode[parsed.data.dictCode];
				if (old) throw new Error(`${filePath}: duplicate dictCode, already found in ${old.file}`);
				byDictCode[parsed.dictCode] = parsed.data;
			}
			classes.push(parsed.data);
		});
	});
	return {
		classes: classes,
		byDictCode: byDictCode,
	};
}

function sourceFilename(_, inst, superv) {
	const root = superv.directories.jsLocal || superv.directories.jsShared;
	return fsp.join(root, inst.module(_) || 'undefined', 'classes', inst.name(_) + '.x3js');
}

function getSupervisor(_, endpoint) {
	if (!endpoint.useEtna(_)) throw new Error("operation not available on current endpoint");
	const conf = endpoint.getEtnaConfig(_, globals.context.request.session);
	//console.error("SUPERVISOR CONF", conf);
	const superv = supervisor.create(_, conf);
	ACTX.init(_, conf.session, superv);
	return superv;
}

function fillInstance(_, superv, inst, metaData, fileData) {
	if (fileData) {
		if (!fileData.module) throw new Error(`${fileData.file}: no module`);
		if (!fileData.properties) throw new Error(`${fileData.file}: no properties`);
		inst.module(_, fileData.module);
		inst.name(_, fileData.name);
		inst.dictCode(_, fileData.dictCode || '');
		inst.title(_, fileData.title || '');
		inst.status(_, fileData.status || '');
		inst.comment(_, fileData.comment || '');
		inst.source(_, fs.readFile(fileData.file, 'utf8', _));
		const properties = inst.properties(_);
		Object.keys(fileData.properties).forEach_(_, (_, k) => {
			const fileProp = fileData.properties[k];
			const prop = properties.add(_);
			prop.name(_, k);
			prop.title(_, fileProp.title || '');
			prop.dictCode(_, fileProp.dictCode || '');
			prop.comment(_, fileProp.comment || '');
		});
	} else {
		inst.name(_, '');
		inst.status(_, '4GL');
		inst.comment(_, '');
		inst.source(_, '');
		entityHelper.fillFromMeta(_, inst, classDescriptor, superv, metaData);
	}
}

function mergeData(d1, desc, d2, prefix) {
	const merged = Object.assign({}, d1);
	if (d2 === undefined) return merged;
	Object.keys(desc.properties).forEach(k => {
		const prop = desc.properties[k];
		switch (prop.type) {
			case 'string':
			case 'x3TypTyp':
			case 'boolean':
			case 'addressOrValue':
			case 'enum':
				const v1 = d1[k];
				const v2 = d2[k];
				merged[k] = v2 != undefined ? v2 : v1;
				break;
			case 'object':
				mergeData(d1, prop, d2, prefix ? prefix + util.pascalize(k) : k);
				break;
			case 'flags':
				merged[k] = Object.keys(prop.dictCodes).filter(flag => {
					const name = k + util.pascalize(flag);
					return d2[name] === true;
				}).join(',');
				break;
			case 'type':
				{
					const v1 = d1[k];
					const v2 = d2[k];
					merged[k] = v2 !== undefined ? v2 : v1;
					if (d2.enum) merged.enum = d2.enum;
					if (d2.typeCode) merged.typeCode = d2.typeCode;
					if (d2.maxLength) merged.maxLength = d2.maxLength;
					if (d2.precision) merged.precision = d2.precision;
					if (d2.scale) merged.scale = d2.scale;
					// see later about other attribues
				}
				break;
			default:
				throw new Error(`${k}: invalid type ${prop.type}`);
		}
	});
	Object.keys(desc.collections || {}).forEach(k => {
		const coln = desc.collections[k];
		if (!d2[k]) return;
		if (!coln.key) {
			// do not try to match old elements, replace whole list
			merged[k] = d2[k].map(elt => mergeData({}, coln, elt, ''));
		} else {
			d2[k].forEach(elt => {
				const key = elt[coln.key];
				if (key) {
					merged[k] = merged[k] || {};
					merged[k][key] = mergeData(merged[key] || {}, coln, elt, '');
				}
			});
		}
	});
	return merged;
}

function updateAll(_, instance, saving) {
	if (instance.name(_) === '') {
		instance.status(_, '4gl');
	} else if (instance.status(_) === '4gl') {
		instance.status(_, 'incomplete');
	}
	if (instance.status(_) === '4gl') {
		instance.source(_, `// ${instance.dictCode(_)}: source not available. X3JS class name has not been set.`);
		// do not save to file.
		return;
	}

	// don't go further when synchronizing
	if (globals.context.dontGenerateX3jsSource) return;

	const superv = getSupervisor(_, instance.endpoint(_));
	const filePath = sourceFilename(_, instance, superv);

	const missing = instance.missingMappings(_);
	const conflicts = instance.conflictingMappings(_);
	if (missing.length > 0 || conflicts.length > 0) instance.status(_, 'incomplete');
	if (saving) conflicts.forEach(conflict => instance.$addError(conflict));

	var parsed;
	if (fs.exists(filePath, _, _)) {
		parsed = classParser.parseFile(_, filePath);
	} else {
		const source = codeGen.classTemplate(_, instance);
		parsed = classParser.parseSource(_, source, filePath);
	}
	parsed.data = mergeData(parsed.data, classDescriptor, instance.serializeInstance(_), '');
	const output = codeGen.generateSourceCode(_, parsed);
	var source = output.code;
	if (instance.status(_) === 'incomplete') {
		source = `// ${instance.name(_)}: source is incomplete and cannot be saved to file. Following mapping information is missing: ${
			'\n' + missing.concat(conflicts).map(s => '// * ' + s).join('\n') + '\n\n'
		}` + source;
	}
	instance.source(_, source);

	if (saving) codeGen.generateSourceFile(_, parsed.file, source);
}

exports.entity = {
	$canDelete: true,
	$canCreate: true,
	$canEdit: true,
	$capabilities: "",
	$titleTemplate: "Class {name} {title}",
	$listTitle: "List of X3JS classes",
	$descriptionTemplate: " ",
	$valueTemplate: " ",
	$properties: {
		module: {
			$title: "module",
			$isReadOnly: classDescriptor.rules.readOnlyProperty,
		},
		name: {
			$title: "X3JS name",
			$linksToDetails: true,
			$control: x3jsUtil.controlPascalCase('name'),
			$propagate: function(_, instance, value) {
				if (value && instance.status(_) === '4gl') instance.status(_, 'incomplete');
				else if (!value) instance.status(_, '4gl');
				entityHelper.updateSource(_, instance);
			},
		},
		title: {
			$title: "title",
			$isReadOnly: classDescriptor.rules.readOnlyProperty,
		},
		dictCode: {
			$title: "dictionary code",
			$linksToDetails: true,
			$isReadOnly: classDescriptor.rules.readOnlyProperty,
		},
		status: {
			$title: "dev status",
			$enum: [{
				$value: "4gl",
				$title: "4GL",
			}, {
				$value: "incomplete",
				$title: "mapping in progress",
			}, {
				$value: "mapped",
				$title: "mapped",
			}, {
				$value: "x3js",
				$title: "X3JS",
			}, {
				$value: "error",
				$title: "error",
			}],
			$isReadOnly: true,
		},
		comment: {
			$title: "comment",
		},
		source: {
			$title: "source",
			$type: "javascript",
		},
	},
	$relations: {
		endpoint: {
			$type: "endPoint",
			$title: "Endpoint",
			$isReadOnly: true,
		},
		properties: {
			$type: "x3jsProperties",
			$isChild: true,
			$title: "Properties",
		},
	},
	$events: {
		$beforeSave(_, instance) {
			updateAll(_, instance, true);
		},
	},
	$functions: {
		$toString(_) {
			return `class ${this.name(_)} (${this.dictCode(_)})`;
		},
		updateSource(_) {
			updateAll(_, this);
		},
		conflictingMappings(_) {
			const names = {};
			const properties = this.properties(_).toArray(_);
			const errors = [];
			properties.forEach_(_, (_, prop) => {
				const name = prop.name(_);
				if (name) {
					if (names[name]) {
						errors.push(`duplicate property mapping: ${name} used by ${names[name].dictCode(_)} and ${prop.dictCode(_)}`);
					} else {
						names[name] = prop;
					}
				}
			});
			return errors;
		},
		missingMappings(_) {
			if (!this.name(_)) return [`${this.dictCode(_)}: X3JS class name`];
			const missing = [];
			this.properties(_).toArray(_).forEach_(_, (_, prop) => {
				if (!prop.name(_)) {
					missing.push(`${prop.dictCode(_)}: X3JS property name missing`);
				}
				if (prop.type(_) === 'enum' && /^\d/.test(prop.enum(_))) {
					missing.push(`${prop.dictCode(_)}: numeric enum id ${prop.enum(_)} must be converted to a "named" enum`);
				}
			});
			return missing;
		},
	},
	$services: {
		synchronize: {
			$method: "POST",
			$isMethod: false,
			$facets: ["$query"],
			$title: "Synchronize list",
			$invocationMode: "async",
			$execute(_, context) {
				const tracker = context.tracker;
				const userProfile = globals.context.session.getUserProfile(_);
				const endpoint = userProfile.selectedEndpoint(_);
				const superv = getSupervisor(_, endpoint);
				const {
					classes,
					byDictCode
				} = processSourceFiles(_, tracker, superv);
				const entity = context.db.model.getEntity(_, "x3jsClass");

				tracker.phase = 'processing metadata';
				const processed = {};
				ezm.reader(superv.mongoStore.collection('ACLASSE', _).find({})).forEach(_, (_, metaData) => {
					var oldData = context.db.db.collection('X3jsClass', _).find({
						'endpoint._uuid': endpoint.$uuid,
						dictCode: metaData.CODCLA,
					}).toArray(_)[0]

					// hack to avoid catastrophic performance and errors with propagate
					globals.context.dontGenerateX3jsSource = true;

					var inst = entity.factory.createInstance(_, null, context.db, null, oldData && oldData._id);
					inst.endpoint(_, endpoint);
					fillInstance(_, superv, inst, metaData, byDictCode[metaData.CODCLA]);
					// preserve mapping data.
					if (oldData) {
						inst.status(_, oldData.status);
						inst.name(_, oldData.name);
						inst.comment(_, oldData.comment);
						inst.properties(_).toArray(_).forEach_(_, (_, prop) => {
							const dictCode = prop.dictCode(_);
							oldData.properties.forEach_(_, (_, oldProp) => {
								if (oldProp.dictCode === dictCode) {
									prop.name(_, oldProp.name);
									prop.comment(_, oldProp.comment);
									return;
								}
							});
						});
					} else {
						inst.status(_, '4gl');
					}
					inst.save(_);
					tracker.$diagnoses = tracker.$diagnoses || [];
					if (inst.hasErrors(_)) {
						const oldLen = tracker.$diagnoses.length;
						inst.getAllDiagnoses(_, tracker.$diagnoses, {
							addEntityName: true,
							addPropName: true,
						});
						console.error("SAVE FAILED", tracker.$diagnoses.slice(oldLen));
					}
					processed[metaData.CODCLA] = true;
				});

				tracker.phase = 'purging metadata';
				context.db.db.collection('X3jsClass', _).remove({
					'endpoint._uuid': endpoint.$uuid,
					dictCode: {
						$not: {
							$in: Object.keys(processed),
						},
					},

				}, _);

				tracker.phase = 'inserting pure x3js classes';
				classes.forEach_(_, (_, fileData) => {
					if (fileData.dictCode) {
						if (processed[fileData.dictCode]) return;
						else throw new Error(`${fileData.name}: invalid dictCode: ${fileData.dictCode}`);
					}
					const inst = entity.factory.createInstance(_, null, context.db);
					inst.endpoint(_, endpoint);
					fillInstance(_, superv, inst, null, fileData);
					inst.save(_);
				});
				tracker.progress = 100;
				//return context.reply(_, 200, {});
			},
		},
	},
	$defaultOrder: [
		["name", true]
	]
};

entityHelper.addProperties(exports.entity, classDescriptor);