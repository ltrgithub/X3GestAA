"use strict";
import { assert } from 'chai';
Object.keys(assert).forEach(key => {
	if (key !== 'isNaN') global[key] = assert[key];
});

if (true) {
	describe(module.id, () => {
		it('dummy', () => {});
	});
} else {
describe(module.id, () => {

	const helper = require("etna/test/engine/fixtures/helper");


	helper.x3jsTest(() => {
		const entityHelper = require('etna/lib/api/entity-helper');
		const classDescriptor = require('etna/lib/api/class-descriptor').descriptor;
		const AAUTILIS = require('../fixtures/AAUTILIS');

		function sorter(p) {
			return function(o1, o2) {
				return o1[p] - o2[p];
			}
		}

		// fix AAUTILIS.PROPERTIES
		AAUTILIS.PROPERTIES = AAUTILIS.PROPERTIES.sort(sorter('NUMLIG'))
			.filter(elt => !/^(CREDATTIM|CREUSR|UPDDATTIM|UPDUSR|AUUID)$/.test(elt.FLDCLA))
			.map((elt, i) => (elt.NUMLIG = i + 1, elt));

		function ignore(path) {
			// AWMAJTYP:  strange flag: a boolean which is never true, and does not have any title - let's ignore it.
			// title and shortTitle are also ignored - we get them in source roundtrip
			return /[\.\]](_id|_proxyName|_etag|CREDATTIM|CREUSR|UPDDATTIM|UPDUSR|AWMAJTYP|title|shortTitle)$/.test(path);
		}

		function deepCheck(path, data, meta, i) {
			if (ignore(path)) return;
			if (Array.isArray(data)) {
				ok(Array.isArray(meta), `${path}: both arrays (${meta && typeof meta})`);
				// some properties are filtered => we may get less but not more
				ok(meta.length <= data.length, `${path}: array length ok`);
				data.forEach((elt, i) => deepCheck(`${path}[${i}]`, elt, meta[i], i));
			} else if (data && typeof data === 'object') {
				ok(meta && typeof meta === 'object', `${path}: both objects (${meta && typeof meta})`);
				const keys = Object.keys(data);
				keys.forEach(k => deepCheck(`${path}.${k}`, data[k], meta[k], i));
				Object.keys(meta).filter(k => keys.indexOf(k) < 0).forEach(k => ok(false, `${path}.${k}: unexpected key`));
			} else {
				// ignore system localized properties (ATEXTE)
				if (meta === -1 && data > 0) return;
				// only check type on generated properties like NUMFLD:
				if (path.endsWith('.NUMFLD')) return ok(meta % 10 === 0, `${path}: computed value ok ${meta}`);
				// else check equality
				strictEqual(data, meta, `${path}: same values ${meta}`);
			}
		}


		function getStudioTestDb(_) {
			// session stub methods
			const globals = require('streamline-runtime').globals;
			globals.context.session.getUserLogin = _ => "guest";
			globals.context.session.getSecurityProfile = _ => null;

			const config = require('config');
			const registry = require("../../../../src/sdata/sdataRegistry");
			const dataset = {
				driver: config.collaboration.driver,
				hostname: config.collaboration.hostname,
				port: config.collaboration.port,
				connectionString: config.collaboration.connectionString,
				database: 'unit-test-x3js-studio',
				databaseName: 'unit-test-x3js-studio',
			};
			//const contract = registry.getContract('x3js', 'studio', true);
			const contract = require('etna-studio/lib/contract-extension');
			const model = require('../../../../src/orm/dataModel').make(contract, dataset.database);
			const db = require('../../../../src/orm/dataModel').getOrm(_, model, dataset);
			return db;
		}

		var superv;

		it('init', function(_) {
			superv = helper.getTestSupervisor(_);
			ok(superv != null, "init superv");
		});

		it('meta canonical roundtrip', function(_) {
			const helper = entityHelper.create(superv, classDescriptor);
			const data = helper.metaToCanonical(_, AAUTILIS);
			//console.error("DATA", data);
			const meta = helper.canonicalToMeta(_, data);
			//console.error("META", meta);
			deepCheck('root', AAUTILIS, meta);
		});

		it('meta instance roundtrip', function(_) {
			const helper = entityHelper.create(superv, classDescriptor);
			const data = helper.metaToCanonical(_, AAUTILIS);

			const studioDb = getStudioTestDb(_);
			const entity = studioDb.getEntity(_, "x3jsClass");
			const instance = entity.factory.createInstance(_, null, studioDb);

			helper.fillInstance(_, instance, null, {
				file: '<unit test>',
				data: data,
			});
			//console.error("DATA1", data);
			const data2 = helper.instanceToCanonical(_, instance);
			//console.error("DATA2", data2);
			deepCheck('root', data, data2);
		});

		// re-enable later
		false && it('source code roundtrip', function(_) {
			const helper = entityHelper.create(superv, classDescriptor);
			const data = helper.metaToCanonical(_, AAUTILIS);

			const parsed1 = helper.parseSource(_, helper.template(), '<empty data>');
			parsed1.data = data;
			//console.error("DATA1", parsed1.data);
			const source = helper.generateSource(_, parsed1).code;
			//console.error("SOURCE", source);
			const parsed2 = helper.parseSource(_, source, '<unit test data>');
			//console.error("DATA2", parsed2.data);
			delete parsed2.data.name; // name was not in original data
			deepCheck('root', data, parsed2.data);
		});

		it('end', function(_) {
			setTimeout(_, 10);
			ok(true, "end");
		});
	});
});
}