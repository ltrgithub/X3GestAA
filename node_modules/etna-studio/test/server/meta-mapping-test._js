"use strict";
QUnit.module(module.id);

const helper = require("etna/test/engine/fixtures/helper");


helper.x3jsTest(() => {
	const entityHelper = require('etna/lib/x3js/entity-helper');
	const classDescriptor = require('etna/lib/x3js/class-descriptor').descriptor;
	const AAUTILIS = require('../fixtures/AAUTILIS');

	function sorter(p) {
		return function(o1, o2) {
			return o1[p] - o2[p];
		}
	}

	// fix AAUTILIS.PROPERTIES
	AAUTILIS.PROPERTIES = AAUTILIS.PROPERTIES.sort(sorter('NUMLIG'))
		.filter(elt => !/^(CREDATTIM|CREUSR|UPDDATTIM|UPDUSR|AUUID)$/.test(elt.FLDCLA))
		.map((elt, i) => (elt.NUMLIG = i + 1, elt));

	function ignore(path) {
		// AWMAJTYP:  strange flag: a boolean which is never true, and does not have any title - let's ignore it.
		// title and shortTitle are also ignored - we get them in source roundtrip
		return /[\.\]](_id|_proxyName|_etag|CREDATTIM|CREUSR|UPDDATTIM|UPDUSR|AWMAJTYP|title|shortTitle)$/.test(path);
	}

	function deepCheck(path, data, meta, i) {
		if (ignore(path)) return;
		if (Array.isArray(data)) {
			ok(Array.isArray(meta), `${path}: both arrays (${meta && typeof meta})`);
			// some properties are filtered => we may get less but not more
			ok(meta.length <= data.length, `${path}: array length ok`);
			data.forEach((elt, i) => deepCheck(`${path}[${i}]`, elt, meta[i], i));
		} else if (data && typeof data === 'object') {
			ok(meta && typeof meta === 'object', `${path}: both objects (${meta && typeof meta})`);
			const keys = Object.keys(data);
			keys.forEach(k => deepCheck(`${path}.${k}`, data[k], meta[k], i));
			Object.keys(meta).filter(k => keys.indexOf(k) < 0).forEach(k => ok(false, `${path}.${k}: unexpected key`));
		} else {
			// ignore system localized properties (ATEXTE)
			if (meta === -1 && data > 0) return;
			// only check type on generated properties like NUMFLD:
			if (path.endsWith('.NUMFLD')) return ok(meta % 10 === 0, `${path}: computed value ok ${meta}`);
			// else check equality
			strictEqual(data, meta, `${path}: same values ${meta}`);
		}
	}


	function getStudioTestDb(_) {
		// session stub methods
		const globals = require('streamline-runtime').globals;
		globals.context.session.getUserLogin = _ => "guest";
		globals.context.session.getSecurityProfile = _ => null;

		const config = require('config');
		const registry = require("syracuse-sdata/lib/sdataRegistry");
		const dataset = {
			driver: config.collaboration.driver,
			hostname: config.collaboration.hostname,
			port: config.collaboration.port,
			connectionString: config.collaboration.connectionString,
			database: 'unit-test-x3js-studio',
			databaseName: 'unit-test-x3js-studio',
		};
		//const contract = registry.getContract('x3js', 'studio', true);
		const contract = require('etna-studio/lib/contract-extension');
		const model = require('syracuse-orm/lib/dataModel').make(contract, dataset.database);
		const db = require('syracuse-orm/lib/dataModel').getOrm(_, model, dataset);
		return db;
	}

	var superv;

	asyncTest("init", 1, function(_) {
		superv = helper.getTestSupervisor(_);
		ok(superv != null, "init superv");
		start();
	});

	asyncTest("meta canonical roundtrip", 1414, function(_) {
		const helper = entityHelper.create(superv, classDescriptor);
		const data = helper.metaToCanonical(_, AAUTILIS);
		//console.error("DATA", data);
		const meta = helper.canonicalToMeta(_, data);
		//console.error("META", meta);
		deepCheck('root', AAUTILIS, meta);
		start();
	});

	asyncTest("meta instance roundtrip", 1283, function(_) {
		const helper = entityHelper.create(superv, classDescriptor);
		const data = helper.metaToCanonical(_, AAUTILIS);

		const studioDb = getStudioTestDb(_);
		const entity = studioDb.getEntity(_, "x3jsClass");
		const instance = entity.factory.createInstance(_, null, studioDb);

		helper.fillInstance(_, instance, null, {
			file: '<unit test>',
			data: data,
		});
		//console.error("DATA1", data);
		const data2 = helper.instanceToCanonical(_, instance);
		//console.error("DATA2", data2);
		deepCheck('root', data, data2);
		start();
	});

	// re-enable later
	false && asyncTest("source code roundtrip", 1283, function(_) {
		const helper = entityHelper.create(superv, classDescriptor);
		const data = helper.metaToCanonical(_, AAUTILIS);

		const parsed1 = helper.parseSource(_, helper.template(), '<empty data>');
		parsed1.data = data;
		//console.error("DATA1", parsed1.data);
		const source = helper.generateSource(_, parsed1).code;
		//console.error("SOURCE", source);
		const parsed2 = helper.parseSource(_, source, '<unit test data>');
		//console.error("DATA2", parsed2.data);
		delete parsed2.data.name; // name was not in original data
		deepCheck('root', data, parsed2.data);
		start();
	});

	asyncTest("end", 1, function(_) {
		setTimeout(_, 10);
		ok(true, "end");
		start();
	});
});