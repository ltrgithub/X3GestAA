"use strict";

/// `obj = xmlParse(str, map)`
/// Parses XML:
/// 
/// <t1 p11="v11" p12="v12">
///		<t2 p21="v21">d2</t2>
///		<t3>d3</t3>
///	</t1> 
/// 
/// gives:
/// 
/// {
///		$$tag: "t1",
///		p11: "v11",
///		p12: "v12",
///		$$children: [{
///			$$tag: "t2",
///			p21: "v21",
///			$$value: "d2",
///		}, {
///			$$tag: "t3",
///			$$value: "d3"
///		}]
///	}
///
/// map: {
///		p1: { type: t, repeat: r, attribute: t/f, name: n },
///		p2: { type: t, repeat: r, attribute: t/f, name: n },
/// }
/// 
/// map defines the mapping for each property:
///		type: object (default), string, number, boolean, date, time, datetime
///		repeat: tag: property is array of type. repeat is the name of tag around each item ('' if no intermediate tag)
///		attribute: true if mapped as an attribute (type cannot be object).
///		name: name of the xml element/attribute
///
/// If the map contains a '*' element, it is loose
var begWord = {},
inWord = {},
space = {},
LF = '\n'.charCodeAt(0),
	LT = '<'.charCodeAt(0),
	GT = '>'.charCodeAt(0),
	EXCLAM = '!'.charCodeAt(0),
	QMARK = '?'.charCodeAt(0),
	SLASH = '/'.charCodeAt(0),
	OBRA = '['.charCodeAt(0),
	EQ = '='.charCodeAt(0),
	DQUOTE = '"'.charCodeAt(0),
	DASH = '-'.charCodeAt(0),
	entitiesByChar = {
		'&': 'amp',
		'<': 'lt',
		'>': 'gt',
		'"': 'quot',
		"'": 'apos',
	},
	entitiesByName = {};

(function() {
	function add(clas, chs, i) {
		chs.split('').forEach(function(ch) {
			clas[ch.charCodeAt(0) + (i || 0)] = true;
		});
	}
	for (var i = 0; i <= 9; i++) add(inWord, '0', i);
	for (var i = 0; i < 26; i++) add(begWord, 'aA', i), add(inWord, 'aA', i);
	add(begWord, ':_'), add(inWord, ':_-.');
	add(space, ' \t\r\n');
	Object.keys(entitiesByChar).forEach(function(ch) {
		entitiesByName[entitiesByChar[ch]] = ch;
	});
})();

function builder(error) {
	var root = {},
	elt = root;
	return {
		push: function(tag) {
			if (elt.$$cdata != null) throw error("cannot mix CDATA and children");
			if (elt.$$value != null) throw error("cannot mix value and children");
			var children = elt.$$children || (elt.$$children = []);
			elt = {
				$$tag: tag,
				$$parent: elt
			};
			children.push(elt);
		},

		pop: function(tag) {
			if (tag && tag !== elt.$$tag) throw error("closing tag mismatch: expected " + elt.$$tag + ", got " + tag);
			var parent = elt.$$parent;
			if (!parent) throw error("too many closing tags");
			delete elt.$$parent;
			elt = parent;
		},

		attribute: function(atb, val) {
			if (elt[atb] != null) throw error("duplicate attribute: " + atb);
			elt[atb] = val;
		},

		value: function(val) {
			if (elt.$$cdata != null) throw error("cannot mix CDATA and value");
			if (elt.$$children != null) throw error("cannot mix children and value");
			elt.$$value = val;
		},
		cdata: function(val) {
			if (elt.$$value != null) throw error("cannot mix value and CDATA");
			if (elt.$$children != null) throw error("cannot mix children and CDATA");
			elt.$$cdata = val;
		},
		getResult: function() {
			if (elt !== root) throw error("tag not closed: " + elt.$$tag);
			if (root.$$children == null) throw error("root tag not found");
			if (root.$$children.length != 1) throw error("more than one top level element");
			return root.$$children[0];
		},
	};
}

function parse(str) {
	var pos = str.indexOf('<'),
		len = str.length,
		bld = builder(error);

	function error(msg) {
		var end = str.substring(pos).match(/[\n\>]/, pos);
		end = end ? pos + end.index + 1 : str.length;
		var line = str.substring(0, pos).split('\n').length;
		return new Error("Invalid XML: " + msg + " at line " + line + " near " + str.substring(pos, end));
	}

	function eatSpaces() {
		while (space[ch = str.charCodeAt(pos)]) pos++;
	}

	function eat(ch) {
		if (str.charCodeAt(pos) !== ch) throw error("expected '" + String.fromCharCode(ch) + "', got '" + str[pos] + "'");
		pos++;
	}

	function clean(str) {
		return str.replace(/&([^;]+);/g, function(s, ent) {
			var ch = entitiesByName[ent];
			if (ch) return ch;
			if (ent[0] != '#') throw error("invalid entity: &" + ent + ";");
			ent = ent.substring(1);
			var v = parseInt(ent, 16);
			if (isNaN(v)) throw error("hex value expected, got " + ent);
			return String.fromCharCode(v);
		});
	}

	function checkEmpty(str) {
		if (str.match(/[^ \t\r\n]/)) throw error("unexpected value: " + str);
	}

	while (pos < len) {
		eat(LT);
		var beg = pos;
		var ch = str.charCodeAt(pos++);
		if (begWord[ch]) {
			while (inWord[str.charCodeAt(pos)]) pos++;
			bld.push(str.substring(beg, pos));
			while (true) {
				eatSpaces();
				beg = pos;
				ch = str.charCodeAt(pos++);
				if (ch === SLASH) {
					eat(GT);
					bld.pop();
					break;
				} else if (begWord[ch]) {
					while (inWord[str.charCodeAt(pos)]) pos++;
					var atb = str.substring(beg, pos);
					eatSpaces();
					eat(EQ);
					eatSpaces();
					eat(DQUOTE);
					beg = pos;
					pos = str.indexOf('"', pos);
					if (pos < 0) throw error("double quote missing");
					bld.attribute(atb, clean(str.substring(beg, pos)));
					pos++;
				} else if (ch === GT) {
					var j = str.indexOf('<', pos);
					if (j < 0) throw error("tag not closed");
					if (str.charCodeAt(j + 1) === SLASH) bld.value(j === pos ? "" : clean(str.substring(pos, j))), pos = j;
					else checkEmpty(str.substring(pos, j));
					break;
				} else {
					pos--;
					throw error("unexpected character: '" + str[pos] + "'");
				}
			}
		} else if (ch === SLASH) {
			beg = pos;
			var ch = str.charCodeAt(pos);
			if (begWord[ch]) {
				pos++;
				while (inWord[str.charCodeAt(pos)]) pos++;
				var tag = str.substring(beg, pos);
			}
			eatSpaces();
			eat(GT);
			bld.pop(tag);
		} else if (ch === EXCLAM) {
			var ch = str.charCodeAt(pos++);
			if (ch === DASH && str.charCodeAt(pos++) === DASH) {
				var j = str.indexOf('-->', pos);
				if (j < 0) throw error("--> missing");
				pos = j + 3;
			} else if (ch === OBRA && str.substring(pos, pos + 6) === 'CDATA[') {
				pos += 6;
				var j = str.indexOf(']]>', pos);
				if (j < 0) throw error("]]> missing");
				bld.cdata(str.substring(pos, j));
				pos = j + 3;
				eatSpaces();
			} else {
				throw error("invalid syntax after <!");
			}
		} else if (ch === QMARK) {
			var j = str.indexOf('?>', pos);
			if (j < 0) throw error("?> missing");
			pos = j + 2;
		} else {
			throw error("unexpected character: " + str[beg]);
		}
		eatSpaces();
	}
	return bld.getResult();
}

function formatter(options) {
	var str = '',
		depth = 0;

	function indent() {
		str += '\n' + Array(depth + 1).join(options.indent);
	}

	function escape(val) {
		return val.replace(/[\n\r\t&<>"']/g, function(ch) {
			var ent = entitiesByChar[ch];
			if (ent) return '&' + ent + ';';
			return '&#' + ('00' + ch.charCodeAt(0).toString(16)).slice(-2) + ';';
		});
	}
	return {
		beginTag: function(tag) {
			options.indent && indent();
			str += '<' + tag;
			depth++;
		},
		addAttribute: function(atb, val) {
			str += ' ' + atb + '="' + escape(val) + '"';
		},
		endTag: function(close) {
			close && depth--;
			str += close ? '/>' : '>';
		},
		closeTag: function(tag, val) {
			depth--;
			if (val != null) {
				str += escape(val);
			} else {
				options.indent && indent();
			}
			str += '</' + tag + '>';
		},
		cdata: function(data) {
			str += '<![CDATA[' + data + ']]>';
		},
		getResult: function() {
			// indexOf to eliminate newline that indent may put before root
			return str.substring(str.indexOf('<'));
		}
	};
}

exports.stringify = function(elt, options) {
	options = typeof options === "string" ? {
		indent: options
	} : (options || {});
	var fmt = formatter(options);

	function error(msg) {
		return new Error(msg);
	}

	function strfy(elt) {
		if (!elt.$$tag) throw error("$$tag missing");
		fmt.beginTag(elt.$$tag);
		Object.keys(elt).forEach(function(atb) {
			var v;
			if (atb[0] !== '$' && (v = elt[atb]) != null) fmt.addAttribute(atb, v);
		});
		if (elt.$$value != null) {
			if (elt.$$children && elt.$$children.length > 0) throw error("cannot mix $$value and $$children");
			if (elt.$$cdata) throw error("cannot mix $$value and $$cdata");
			fmt.endTag();
			fmt.closeTag(elt.$$tag, elt.$$value);
		} else if (elt.$$cdata != null) {
			if (elt.$$children && elt.$$children.length > 0) throw error("cannot mix $$cdata and $$children");
			fmt.endTag();
			fmt.cdata(elt.$$cdata);
			fmt.closeTag(elt.$$tag);
		} else if (elt.$$children && elt.$$children.length > 0) {
			fmt.endTag();
			elt.$$children.forEach(strfy);
			fmt.closeTag(elt.$$tag);
		} else {
			fmt.endTag(true);
		}
	}
	strfy(elt);
	return fmt.getResult();
};

exports.parse = function(str, map) {
	return mapIn(parse(str), map);
};

function mapIn(root, map) {
	if (!map) return root;
	var eltMap = {},
	atbMap = {};
	Object.keys(map).forEach(function(key) {
		if (key === '*') return;
		var prop = map[key],
			nodeMap = prop.attribute ? atbMap : eltMap,
			node = (nodeMap[prop.name || key] = {
				prop: key,
				type: prop.type || 'object',
				repeat: prop.repeat
			});
		if (node.repeat) {
			nodeMap[node.repeat] = {
				prop: key,
				type: 'array',
				item: node
			};
		}
	});

	function valueIn(val, type) {
		switch (type) {
			case 'number':
				return parseFloat(val);
			case 'boolean':
				return val.toUpperCase() === 'TRUE';
			default:
				return val;
		}
	}

	function unmapped(key) {
		if (!map['*']) throw new Error("no XML mapping for " + key);
	}

	function objIn(obj, elt) {
		switch ((elt && elt.type) || 'object') {
			case 'object':
				Object.keys(obj).forEach(function(key) {
					var atb = atbMap[key];
					if (atb) {
						obj[atb.prop] = valueIn(obj[key], atb.type);
					} else {
						if (key === '$$children') {
							var remain = [];
							obj.$$children.forEach(function(child) {
								var childElt = eltMap[child.$$tag];
								if (childElt) {
									if (childElt.repeat != null) {
										var arr = (obj[childElt.prop] = obj[childElt.prop] || []);
										arr.push(objIn(child, childElt));
									} else {
										if (obj[childElt.prop]) throw new Error("invalid duplicate element: " + child.tag);
										obj[childElt.prop] = objIn(child, childElt);
									}
								} else {
									unmapped(child.$$tag);
									remain.push(objIn(child));
								}
							});
							if (remain.length > 0) obj.$$children = remain;
							else delete obj.$$children;
						} else {
							if (key !== '$$tag') unmapped(key);
						}
					}
				});
				if (elt) delete obj.$$tag;
				return obj;
			case 'array':
				return obj.$$children && obj.$$children.map(function(child) {
					return objIn(child, elt.item);
				});
			default:
				return valueIn(obj.$$value, elt.type);
		}
	}
	return objIn(root, map[root.$$tag]);
}

function assert(cond, msg) {
	if (!cond) throw new Error(msg);
}