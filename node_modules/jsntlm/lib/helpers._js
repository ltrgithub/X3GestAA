"use strict";
var crypto = require('crypto');

var PARITY = [];

for (var i = 0; i < 256; i++) {
	var sum = 0;
	for (var j = 0; j < 8; j++) sum += (i >> j) & 1;
	PARITY[i] = sum % 2 ?  i : i ^ 1 ;
}

/*
 *  LAN Manager Password Hash
 *  This is a 32-bit hexadecimal sequence that represents the password clients will use.
 *  It is derived by encrypting the string  KGS!@#$% with a 56-bit DES algorithm using
 *  the user's password (forced to 14 bytes and converted to capital letters) twice
 *  repeated as the key.
 */
exports.hashLanManagerPassword = function(passw){
	var magic = 'KGS!@#$%';
	var lm_pw = new Buffer(14);
	for (var i = 0 ; i < 14 ; i++){
		lm_pw[i] = passw[i] ? passw.toUpperCase().charCodeAt(i) : 0x00 ;
	}

    var ks = setup_des_key(lm_pw.slice(0,7));
    var lm_hpw = des_encrypt(magic, ks);
    ks = setup_des_key(lm_pw.slice(7));
    lm_hpw += des_encrypt(magic, ks);
    return lm_hpw;
}

/* 
 * NT Password Hash
 * This is a 32-bit hexadecimal sequence that represents the password Windows NT clients
 * will use. It is derived by hashing the user's password (represented as a 16-bit little-endian
 * Unicode sequence) with an MD4 hash. The password is not converted to uppercase letters first.
 */
exports.hashNtPassword = function(passw){
    var nt_hpw = crypto.createHash('md4').update(new Buffer(passw,'ucs2')).digest("hex");  
    return nt_hpw;
}

/*
 * takes a 21 byte buffers and treats it as 3 56-bit DES keys. The
 * 8 byte plaintext is encrypted with each key and the resulting 24
 * bytes are stored in the results array.
 */
exports.calc_resp = function(keys, plaintext, results)
{
    var ks = setup_des_key(keys.slice(0,7));
    results = des_encrypt(plaintext, ks);

    ks = setup_des_key(keys.slice(7,14));
    results += des_encrypt(plaintext, ks);
    
    ks = setup_des_key(keys.slice(14));
    results += des_encrypt(plaintext, ks);
    
    return results;
}

/*
 * turns a 56 bit key into the 64 bit, odd parity key and sets the key.
 * The key schedule ks is also set.
 */
function setup_des_key(key_56)
{
	function odd_parity(key){
		for (var i = 0; i < 8; i++){
			key[i] = PARITY[key[i]];
		}
	}
    var key = new Buffer(8);
	key[0] = key_56[0];
	key[1] = ((key_56[0] << 7) & 0xff) | (key_56[1] >> 1);
	key[2] = ((key_56[1] << 6) & 0xff) | (key_56[2] >> 2);
	key[3] = ((key_56[2] << 5) & 0xff) | (key_56[3] >> 3);
	key[4] = ((key_56[3] << 4) & 0xff) | (key_56[4] >> 4);
	key[5] = ((key_56[4] << 3) & 0xff) | (key_56[5] >> 5);
	key[6] = ((key_56[5] << 2) & 0xff) | (key_56[6] >> 6);
	key[7] = (key_56[6] << 1) & 0xff;
	odd_parity(key);
    return key;
}

function des_encrypt(str, key){
    var iv = new Buffer(8);
    for (var i = 0 ; i < 8 ; i++)
    	iv[i] = 0x00;
	var tokencrypt = crypto.createCipheriv('des-cbc', new Buffer(key, 'hex'), iv);
	var token = tokencrypt.update(str, 'ascii', 'hex');
	tokencrypt.final('hex');
	return token;
}