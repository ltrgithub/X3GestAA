"use strict";
var crypto = require('crypto');

var PARITY = [];

for (var i = 0; i < 256; i++) {
	var sum = 0;
	for (var j = 0; j < 8; j++) sum += (i >> j) & 1;
	PARITY[i] = sum % 2 ?  i : i ^ 1 ;
}

exports.hashLanManagerPassword = function(passw){
	/*
	 *  LAN Manager Password Hash
	 *  This is a 32-bit hexadecimal sequence that represents the password clients will use.
	 *  It is derived by encrypting the string  KGS!@#$% with a 56-bit DES algorithm using
	 *  the user's password (forced to 14 bytes and converted to capital letters) twice
	 *  repeated as the key. If there is currently no password for this user, the first 11
	 *  characters of the hash will consist of the sequence 'NO PASSWORD' followed by  X
	 *  characters for the remainder.
	 */
	 
	
	function test(enc){

		console.log("==== Encoding: " +enc+" ============");
		  var cipher_hpw = crypto.createCipher(enc, ks);
		  lm_hpw = cipher_hpw.update(magic, 'binary', 'hex');
		  console.log("update result= "+lm_hpw);
		  lm_hpw += cipher_hpw.final('hex');
		  console.log("final result=  "+lm_hpw);
		  console.log("EXPECTED HASH= 2cfb541d293ba1db");
		  
		  var decipher = crypto.createDecipher(enc,ks);
		  var dec = decipher.update(lm_hpw,'hex','hex');
		  dec += decipher.final('hex');
		  console.log("decipher=  "+dec);
		  console.log("=====================================\n");
	}
	var lm_pw = [];
    var len = passw.length;
    if (len > 14)  len = 14;
    var idx;
    for (idx=0; idx<len; idx++)
        lm_pw[idx] = passw[idx].toUpperCase();
    for (idx; idx<14; idx++)
        lm_pw[idx] = 0;
    
    console.log("Lan Manager Password: "+lm_pw.join(''));
    
    /* create LanManager hashed password */

    var magic = new Buffer(8);
    magic[0] = 0x4B;
    magic[1] = 0x47;
    magic[2] = 0x53;
    magic[3] = 0x21;
    magic[4] = 0x40;
    magic[5] = 0x23;
    magic[6] = 0x24;
    magic[7] = 0x25;
    console.log("MAGIC="+magic.toString("utf8"));
    	var lm_hpw, lm_hpw_1, lm_hpw_2;
    
    
      var ks = setup_des_key("ARTIFLO");
     // var ks = "BEEBLEB";
      console.log("KS:"+ks);

	  test("des-ecb");
//	  test("des-ede3");
//	  test("des3");
//	  test("des-ede");
//	  test("des-ede3-cbc");
//	  test("desx");
//	  test("des");
//	  test("des-ede-cbc");
//	  test("des-ede3-cfb");
//	  test("des-cbc");
//	  test("des-ede-cfb");
//	  test("des-ede3-ofb");
//	  test("des-cfb");
//	  test("des-ede-ofb");
//	  test("des-ofb");

	  
    
   // console.log("-> Hashed Lan Manager Password: "+lm_hpw_1+lm_hpw_2);
    return;
}

exports.hashNtPassword = function(passw){
	
    /* 
     * NT Password Hash
     * This is a 32-bit hexadecimal sequence that represents the password Windows NT clients
     * will use. It is derived by hashing the user's password (represented as a 16-bit little-endian
     * Unicode sequence) with an MD4 hash. The password is not converted to uppercase letters first.
     */

    var nt_hpw = crypto.createHash('md4').update(new Buffer(passw,'ucs2')).digest("hex");  
    return nt_hpw;
}

/*
 * takes a 21 byte array and treats it as 3 56-bit DES keys. The
 * 8 byte plaintext is encrypted with each key and the resulting 24
 * bytes are stored in the results array.
 */
exports.calc_resp = function(keys, plaintext, results)
{
    var ks;
    
   
    //setup_des_key(keys, ks);
    ks = setup_des_key(keys);
    //des_ecb_encrypt((des_cblock*) plaintext, (des_cblock*) results, ks, DES_ENCRYPT);
    var cipher_1 = crypto.createCipher("des", ks.join(''));
    results += cipher_1.update(plaintext, 'ascii').toString('hex');
    results += cipher_1.final('hex');

    //setup_des_key(keys+7, ks);
//    ks = setup_des_key(keys);
//    des_ecb_encrypt((des_cblock*) plaintext, (des_cblock*) (results+8), ks, DES_ENCRYPT);
//
//    setup_des_key(keys+14, ks);
//    des_ecb_encrypt((des_cblock*) plaintext, (des_cblock*) (results+16), ks, DES_ENCRYPT);
}

/*
 * turns a 56 bit key into the 64 bit, odd parity key and sets the key.
 * The key schedule ks is also set.
 */
function setup_des_key(key_56)
{
	function odd_parity(key){
		for (var i = 0; i < 8; i++){
			key[i] = PARITY[key[i]];
		}
		

	}
    var key = new Buffer(8);
	  
	  
    console.log("KEY56="+key_56);
    key_56 = new Buffer(key_56, 'utf8');
    
    
    
    console.log("HEXA KEY56 :   "+key_56.toString('hex'));
    console.log("Expected hexa: "+"41525449464c4f");
    
    
	key[0] = key_56[0];
	key[1] = ((key_56[0] << 7) & 0xff) | (key_56[1] >> 1);
	key[2] = ((key_56[1] << 6) & 0xff) | (key_56[2] >> 2);
	key[3] = ((key_56[2] << 5) & 0xff) | (key_56[3] >> 3);
	key[4] = ((key_56[3] << 4) & 0xff) | (key_56[4] >> 4);
	key[5] = ((key_56[4] << 3) & 0xff) | (key_56[5] >> 5);
	key[6] = ((key_56[5] << 2) & 0xff) | (key_56[6] >> 6);
	key[7] = (key_56[6] << 1) & 0xff;

	odd_parity(key);
	
    console.log("HEXA KEY :     "+key.toString('hex'));
    console.log("Expected hexa: "+"40a894899432319e");
    return key;
}


