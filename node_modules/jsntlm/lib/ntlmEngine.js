"use strict";

var http = require('http');
var helpers = require('syracuse-core/lib/helpers');
var crypto = require('crypto');
var tracer = console.log;
//var tracer = null;


// Flags we use; descriptions according to:
// http://davenport.sourceforge.net/ntlm.html
// and
// http://msdn.microsoft.com/en-us/library/cc236650%28v=prot.20%29.aspx
var FLAG_REQUEST_UNICODE_ENCODING = 0x00000001;      // Unicode string encoding requested
var FLAG_REQUEST_TARGET = 0x00000004;                      // Requests target field
var FLAG_REQUEST_SIGN = 0x00000010;  // Requests all messages have a signature attached, in NEGOTIATE message.
var FLAG_REQUEST_SEAL = 0x00000020;  // Request key exchange for message confidentiality in NEGOTIATE message.  MUST be used in conjunction with 56BIT.
var FLAG_REQUEST_LAN_MANAGER_KEY = 0x00000080;    // Request Lan Manager key instead of user session key
var FLAG_REQUEST_NTLMv1 = 0x00000200; // Request NTLMv1 security.  MUST be set in NEGOTIATE and CHALLENGE both
var FLAG_DOMAIN_PRESENT = 0x00001000;        // Domain is present in message
var FLAG_WORKSTATION_PRESENT = 0x00002000;   // Workstation is present in message
var FLAG_REQUEST_ALWAYS_SIGN = 0x00008000;   // Requests a signature block on all messages.  Overridden by REQUEST_SIGN and REQUEST_SEAL.
var FLAG_REQUEST_NTLM2_SESSION = 0x00080000; // From server in challenge, requesting NTLM2 session security
var FLAG_REQUEST_VERSION = 0x02000000;       // Request protocol version
var FLAG_TARGETINFO_PRESENT = 0x00800000;    // From server in challenge message, indicating targetinfo is present
var FLAG_REQUEST_128BIT_KEY_EXCH = 0x20000000; // Request explicit 128-bit key exchange
var FLAG_REQUEST_EXPLICIT_KEY_EXCH = 0x40000000;     // Request explicit key exchange
var FLAG_REQUEST_56BIT_ENCRYPTION = 0x80000000;      // Must be used in conjunction with SEAL

/** Strip dot suffix from a name */
function stripDotSuffix(value) {
    var index = value.indexOf(".");
    if (index !== -1)
        return value.substring(0, index);
    return value;
}

/** Convert host to standard form */
function convertHost(host) {
    return stripDotSuffix(host);
}

/** Convert domain to standard form */
function convertDomain(domain) {
    return stripDotSuffix(domain);
}

var PARITY = [];

for (var i = 0; i < 256; i++) {
	var sum = 0;
	for (var j = 0; j < 8; j++) sum += (i >> j) & 1;
	PARITY[i] = sum % 2 ?  i : i ^ 1 ;
}

/**
 * Calculates the NTLM2 Session Response for the given challenge, using the
 * specified password and client challenge.
 *
 * @return The NTLM2 Session Response. This is placed in the NTLM response
 *         field of the Type 3 message; the LM response field contains the
 *         client challenge, null-padded to 24 bytes.
 */
var ntlm2SessionResponse = function(_ntlmHash, challenge, clientChallenge) {
    try {
		var digest = crypto.createHash('md5').update(challenge).update(clientChallenge).digest();
		return lmResponse(ntlmHash, digest.slice(0, 8));
    } catch (e) {
        throw new Error(e.message, e);
    }
};

/**
 * Creates the LM Hash of the user's password.
 * This is a 32-bit hexadecimal sequence that represents the password clients will use.
 * It is derived by encrypting the string  KGS!@#$% with a 56-bit DES algorithm using
 * the user's password (forced to 14 bytes and converted to capital letters) twice
 * repeated as the key.
 * 
 * @param password The password.
 *
 * @return The LM Hash of the given password, used in the calculation
 * of the LM Response.
 */
var lmHash = function(password){
	var magic = 'KGS!@#$%';
	var lm_pw = new Buffer(14);
	for (var i = 0 ; i < 14 ; i++){
		lm_pw[i] = password[i] ? password.toUpperCase().charCodeAt(i) : 0x00 ;
	}

  var ks = setup_des_key(lm_pw.slice(0,7));
  var lm_hpw = des_encrypt(magic, ks);
  ks = setup_des_key(lm_pw.slice(7));
  lm_hpw += des_encrypt(magic, ks);
  return lm_hpw;
};

/// ## ntlmHash
/// ``` javascript
/// var lmHash = helpers.ntlmHash(password);  
/// ```
/// Creates the NTLM Hash of the user's password.
/// This is a 32-bit hexadecimal sequence that represents the password Windows NT clients
/// will use. It is derived by hashing the user's password (represented as a 16-bit little-endian
/// Unicode sequence) with an MD4 hash. The password is not converted to uppercase letters first.
///
/// @param password The password.
///
/// @return The NTLM Hash of the given password, used in the calculation
/// of the NTLM Response and the NTLMv2 and LMv2 Hashes.
///
var ntlmHash = exports.ntlmHash = function(password){
	return crypto.createHash('md4').update(new Buffer(password,'ucs2')).digest('hex');
};

/// ## ntlmv2Hash
/// ``` javascript
/// var lmHash = helpers.ntlmv2Hash(target, user, password);  
/// ```
/// Creates the NTLMv2 Hash of the user's password.
///
/// @param target The authentication target (i.e., domain).
/// @param user The username.
/// @param password The password.
///
/// @return The NTLMv2 Hash, used in the calculation of the NTLMv2
/// and LMv2 Responses. 
///
var ntlmv2Hash = function(target, user, _ntlmHash){
	var identity = user.toUpperCase() + target;
	return crypto.createHmac('md5', _ntlmHash).update(new Buffer(identity,'ucs2')).digest('hex');
};

var lmv2Hash = function(target, user, _ntlmHash){
	var identity = Buffer.concat([new Buffer(user.toUpperCase(),'ucs2'), new Buffer(target.toUpperCase(),'ucs2')]);
	return crypto.createHmac('md5', _ntlmHash).update(identity).digest('hex');
};

/**
 * Creates the LM Response from the given hash and Type 2 challenge.
 *
 * @param hash The LM or NTLM Hash.
 * @param challenge The server challenge from the Type 2 message.
 *
 * @return The response (either LM or NTLM, depending on the provided
 * hash).
 */
var lmResponse = function(hash, challenge) {
	function padHash(buf){
		var newBuf = new Buffer(21);
		buf.copy(newBuf);
		for (var i = 16 ; i < 21 ; i++){
			newBuf[i] = 0x00 ;
		}
		return newBuf;
	}
	
	var keys = padHash(hash);
    var ks = setup_des_key(keys.slice(0,7));
    var resp = des_encrypt(challenge, ks);

    ks = setup_des_key(keys.slice(7,14));
    resp += des_encrypt(challenge, ks);
    
    ks = setup_des_key(keys.slice(14));
    resp += des_encrypt(challenge, ks);
    
    return new Buffer(resp, 'hex');
};

/**
 * Creates the LMv2 Response from the given hash, client data, and
 * Type 2 challenge.
 *
 * @param hash The NTLMv2 Hash.
 * @param clientData The client data (blob or client nonce).
 * @param challenge The server challenge from the Type 2 message.
 *
 * @return The response (either NTLMv2 or LMv2, depending on the
 * client data).
 */
var lmv2Response = function(hash, challenge, clientData) {
    var data = Buffer.concat([challenge, clientData], challenge.length + clientData.length);
    var macHex =  crypto.createHmac('md5', hash).update(data).digest('hex');
    var mac = new Buffer(macHex, 'hex');
    return Buffer.concat([mac, clientData], mac.length + clientData.length);
};

/**
 * Creates the NTLMv2 blob from the given target information block and
 * client nonce.
 *
 * @param clientNonce The random 8-byte client nonce.
 * @param targetInformation The target information block from the Type 2
 * message.
 *
 * @return Buffer The blob, used in the calculation of the NTLMv2 Response.
 */
var createBlob = function(clientNonce, targetInformation, timestamp) {
    var blobSignature = new Buffer([0x01, 0x01, 0x00, 0x00]);
    var reserved = new Buffer([0x00, 0x00, 0x00, 0x00]);
    var unknown1 = new Buffer([0x00, 0x00, 0x00, 0x00]);
    var unknown2 = new Buffer([0x00, 0x00, 0x00, 0x00]);
    var blobLen = blobSignature.length + reserved.length + timestamp.length + clientNonce.length + unknown1.length + targetInformation.length + unknown2.length;
    return Buffer.concat([blobSignature, reserved, timestamp, clientNonce, unknown1, targetInformation, unknown2], blobLen);
};

/*
 * turns a 56 bit key into the 64 bit, odd parity key and sets the key.
 * The key schedule ks is also set.
 */
var setup_des_key = function(key_56)
{
	function odd_parity(key){
		for (var i = 0; i < 8; i++){
			key[i] = PARITY[key[i]];
		}
	}
    var key = new Buffer(8);
	key[0] = key_56[0];
	key[1] = ((key_56[0] << 7) & 0xff) | (key_56[1] >> 1);
	key[2] = ((key_56[1] << 6) & 0xff) | (key_56[2] >> 2);
	key[3] = ((key_56[2] << 5) & 0xff) | (key_56[3] >> 3);
	key[4] = ((key_56[3] << 4) & 0xff) | (key_56[4] >> 4);
	key[5] = ((key_56[4] << 3) & 0xff) | (key_56[5] >> 5);
	key[6] = ((key_56[5] << 2) & 0xff) | (key_56[6] >> 6);
	key[7] = (key_56[6] << 1) & 0xff;
	odd_parity(key);
    return key;
};

/**
 * Creates a DES encryption key from the given key material.
 *
 * @param str Data to encrypt.
 * @param key The key to use for the encryption.
 *
 * @return Encrypted data.
 */
var des_encrypt = function(str, key){
    var iv = new Buffer(8);
    for (var i = 0 ; i < 8 ; i++) iv[i] = 0x00;
	var tokencrypt = crypto.createCipheriv('des-cbc', new Buffer(key, 'hex'), iv);
	var token = tokencrypt.update(str, 'ascii', 'hex');
	tokencrypt.final('hex');
	return token;
};

var rc4_encrypt = function(str, key){
    var iv = new Buffer(8);
    for (var i = 0 ; i < 256 ; i++) iv[i] = 0x00;
	var tokencrypt = crypto.createCipheriv('rc4', new Buffer(key, 'hex'), iv);
	tokencrypt.update(str, 'ascii', 'hex');
	return tokencrypt.final();
};

var CipherGen = exports.CipherGen = helpers.defineClass(function(domain, user, password, challenge, target, targetInformation, clientChallenge, clientChallenge2, secondaryKey, timestamp) {
    this.domain = domain;
    this.target = target;
    this.user = user;
    this.password = password;
    this.challenge = challenge;
    this.targetInformation = targetInformation;
    this.clientChallenge = clientChallenge;
    this.clientChallenge2 = clientChallenge2;
    this.secondaryKey = secondaryKey;
    this.timestamp = timestamp;

    // Stuff we always generate
    this.lmHash = null;
    this.lmResponse = null;
    this.ntlmHash = null;
    this.ntlmResponse = null;
    this.ntlmv2Hash = null;
    this.lmv2Hash = null;
    this.lmv2Response = null;
    this.ntlmv2Blob = null;
    this.ntlmv2Response = null;
    this.ntlm2SessionResponse = null;
    this.lm2SessionResponse = null;
    this.lmUserSessionKey = null;
    this.ntlmUserSessionKey = null;
    this.ntlmv2UserSessionKey = null;
    this.ntlm2SessionResponseUserSessionKey = null;
    this.lanManagerSessionKey = null;

}, null, {
	
    /** Calculate and return client challenge */
    getClientChallenge: function() {
		if (this.clientChallenge == null)
			this.clientChallenge = crypto.randomBytes(8);
        return this.clientChallenge;
    },

    /** Calculate and return second client challenge */
    getClientChallenge2: function() {
		if (this.clientChallenge2 == null)
			this.clientChallenge2 = crypto.randomBytes(8);
        return this.clientChallenge2;
    },

    /** Calculate and return random secondary key */
    getSecondaryKey: function() {
		if (this.secondaryKey == null)
			this.secondaryKey = crypto.randomBytes(16);
        return this.secondaryKey;
    },

    /** Calculate and return the LMHash */
    getLMHash: function() {
		if (this.lmHash == null)
			this.lmHash = new Buffer(lmHash(this.password), 'hex');
        return this.lmHash;
    },

    /** Calculate and return the LMResponse */
    getLMResponse: function() {
		if (this.lmResponse == null)
			this.lmResponse = lmResponse(this.getLMHash(), this.challenge);
        return this.lmResponse;
    },

    /** Calculate and return the NTLMHash */
    getNTLMHash: function() {
		if (this.ntlmHash == null)
			this.ntlmHash = new Buffer(ntlmHash(this.password), 'hex');
        return this.ntlmHash;
    },

    /** Calculate and return the NTLMResponse */
    getNTLMResponse: function() {
		if (this.ntlmResponse == null)
			this.ntlmResponse = lmResponse(this.getNTLMHash(),this.challenge);
        return this.ntlmResponse;
    },

    /** Calculate the LMv2 hash */
    getLMv2Hash: function() {
		if (this.lmv2Hash == null)
			this.lmv2Hash = new Buffer(lmv2Hash(this.domain, this.user, this.getNTLMHash()), 'hex');
        return this.lmv2Hash;
    },

    /** Calculate the NTLMv2 hash */
    getNTLMv2Hash: function() {
		if (this.ntlmv2Hash == null)
			this.ntlmv2Hash = new Buffer(ntlmv2Hash(this.domain, this.user, this.getNTLMHash()), 'hex');
        return this.ntlmv2Hash;
    },

    /** Calculate a timestamp */
    getTimestamp: function(millis) {
		millis = millis || new Date().getTime();
		// shift origin to Jan 1, 1601
		var t = millis + 11644473600000;
		// t uses 44 bits. JS integers only have 52 bits.
		// We can't multiply by 10000 because result would need 57 bits
		// So we divide by 16 to gain 4 bits and we multiply by 625
		// instead of 10000 to save another 4 bits  (625 == 10000 / 16).
		// Caution: don't divide with >> 4 at it treats operands as 32 bit integers.
		t = Math.floor(t / 16) * 625;
		// t is the value to serialize, divided by 256.
		var buf = new Buffer(8);
		buf[0] = 0; // set lower bits to 0 to cope for 256 division
		for (var i = 1; i < 8; i++) {
			buf[i] = t & 0xff;
			t = Math.floor(t / 256);
		}
		return buf;
    },

    /** Calculate the NTLMv2Blob */
    getNTLMv2Blob: function(forcedTime) {
		if (this.ntlmv2Blob == null)
			this.ntlmv2Blob = createBlob(this.getClientChallenge2(), this.targetInformation, this.getTimestamp(forcedTime));
        return this.ntlmv2Blob;
    },

    /** Calculate the NTLMv2Response */
    getNTLMv2Response: function(forcedTime) {
		if (this.ntlmv2Response == null)
			this.ntlmv2Response = lmv2Response(this.getNTLMv2Hash(),this.challenge,this.getNTLMv2Blob(forcedTime));
        return this.ntlmv2Response;
    },
    
    /** Calculate the LMv2Response */
    getLMv2Response: function() {
		if (this.lmv2Response == null)
			this.lmv2Response = lmv2Response(this.getLMv2Hash(),this.challenge,this.getClientChallenge());
        return this.lmv2Response;
    },

    /** Get NTLM2SessionResponse */
    getNTLM2SessionResponse: function() {
		if (this.ntlm2SessionResponse == null)
			this.ntlm2SessionResponse = ntlm2SessionResponse(this.getNTLMHash(),this.challenge,this.getClientChallenge());
        return this.ntlm2SessionResponse;
    },

    /** Calculate and return LM2 session response */
    getLM2SessionResponse: function() {
        if (this.lm2SessionResponse == null) {
            var _clientChallenge = this.getClientChallenge();            
            this.lm2SessionResponse = Buffer.concat([_clientChallenge.slice(0, _clientChallenge.length), new Buffer([0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00])]);
        }
        return this.lm2SessionResponse;
    },

    /** Get LMUserSessionKey */
    getLMUserSessionKey: function() {
        if (this.lmUserSessionKey == null) {
            var _lmHash = this.getLMHash();
            this.lmUserSessionKey = Buffer.concat([_lmHash.slice(0, 8), new Buffer([0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00])]);
        }
        return this.lmUserSessionKey;
    },

    /** Get NTLMUserSessionKey */
    getNTLMUserSessionKey: function() {
        if (this.ntlmUserSessionKey == null) {
            var _ntlmHash = this.getNTLMHash();
            this.ntlmUserSessionKey = new Buffer(crypto.createHash('md4').update(_ntlmHash).digest('hex'), 'hex');
        }
        return this.ntlmUserSessionKey;
    },

    /** GetNTLMv2UserSessionKey */
    getNTLMv2UserSessionKey: function() {
        if (this.ntlmv2UserSessionKey == null) {
            var _ntlmv2hash = this.getNTLMv2Hash();
            var truncatedResponse = this.getNTLMv2Response().slice(0, 16);
            this.ntlmv2UserSessionKey = new Buffer(crypto.createHmac('md5', _ntlmv2hash).update(truncatedResponse).digest('hex'), 'hex');
        }
        return this.ntlmv2UserSessionKey;
    },

    /** Get NTLM2SessionResponseUserSessionKey */
    getNTLM2SessionResponseUserSessionKey: function() {
        if (this.ntlm2SessionResponseUserSessionKey == null) {
            var ntlmUserSessionKey = this.getNTLMUserSessionKey();
            var ntlm2SessionResponseNonce = this.getLM2SessionResponse();
            var sessionNonce = Buffer.concat([this.challenge, ntlm2SessionResponseNonce]);
            this.ntlm2SessionResponseUserSessionKey =  new Buffer(crypto.createHmac('md5', ntlmUserSessionKey).update(sessionNonce).digest('hex'), 'hex');
        }
        return this.ntlm2SessionResponseUserSessionKey;
    },

    /** Get LAN Manager session key */
    getLanManagerSessionKey: function() {
        if (this.lanManagerSessionKey == null) {
            var lmHash = this.getLMHash();
            var lmResponse = this.getLMResponse();

            try {

				var keyBytes = new Buffer(14);
				for (var i = 0 ; i < 8 ; i++){
					keyBytes[i] = lmHash[i];
				}
				for (var j = 8 ; j < keyBytes.length ; j++){
					keyBytes[i] = 0xbd;
				}
				var truncatedResponse = lmResponse.slice(0,8);
				var ks = setup_des_key(keyBytes.slice(0,7));
				this.lanManagerSessionKey = des_encrypt(truncatedResponse, ks);
				ks = setup_des_key(keyBytes.slice(7));
				this.lanManagerSessionKey += des_encrypt(truncatedResponse, ks);                
            } catch (e) {
                throw new Error(e.message, e);
            }
        }
        return this.lanManagerSessionKey;
    }
});

var NTLMMessage = helpers.defineClass(function(messageBody, expectedType) {
	if (messageBody != null && expectedType != null) {
		this.messageContents = new Buffer(messageBody, 'base64');
		if (this.messageContents.length < 13)
	        throw new Error("NTLM message decoding error - packet too short");
		
		var valid = new Buffer("4e544c4d53535000", 'hex');
		for (var i = 0; i < 8; i++) {
			if (this.messageContents[i] !== valid[i])
				throw new Error("NTLM message expected - instead got unrecognized bytes");
		}	
	
		var type = this.messageContents.readUInt32LE(8, 12);
		if (type !== expectedType)
	        throw new Error("NTLM type " + expectedType + " message expected - instead got type " + type);
	}
}, null, {
    /** Read a security buffer from a position within the message buffer */
    readSecurityBuffer: function(index) {
        var length = this.messageContents.readUInt16LE(index);
        var offset = this.messageContents.readUInt32LE(index + 4);
        if (this.messageContents.length < offset + length)
            throw new Error("NTLM authentication - buffer too small for data item");
        return this.messageContents.slice(offset, offset + length);
    },

    /**
     * Prepares the object to create a response of the given length.
     *
     * @param maxlength
     *            the maximum length of the response to prepare, not
     *            including the type and the signature (which this method
     *            adds).
     */
    prepareResponse: function(maxlength, messageType) {
        this.messageContents = new Buffer(maxlength);
		// First 8 bytes: NTLMSSP[0]
		this.messageContents.write('NTLMSSP', 0, 7, 'ascii');
		this.messageContents.writeUInt8(0, 7);// '\0'
		// Next 4 bytes: Ulong
		this.messageContents.writeUInt32LE(messageType, 8);
    },
    
    /**
     * Returns the response that has been generated after shrinking the
     * array if required and base64 encodes the response.
     *
     * @return The response as above.
     */
	getResponse: function() {
		return this.messageContents.toString('base64');
	}
});

var Type1Message = helpers.defineClass(function(domain, host) {
	NTLMMessage.call(this);
	try {
        // Strip off domain name from the host!
        var unqualifiedHost = convertHost(host);
        // Use only the base domain name!
        var unqualifiedDomain = convertDomain(domain);

        this.hostBytes = new Buffer(unqualifiedHost, "ascii");
        this.domainBytes = new Buffer(unqualifiedDomain.toUpperCase(), "ascii");
    } catch (e) {
        throw new Error("Unicode unsupported: " + e.message, e);
    }
	
}, NTLMMessage, {
	/**
	 * Getting the response involves building the message before returning
	 * it
	 */
	 getResponse: function() {
        // Now, build the message. Calculate its length first, including
        // signature or type.
        var finalLength = 32 + 8 /*+ hostBytes.length + domainBytes.length */;

        // Set up the response. This will initialize the signature, message
        // type, and flags.
        this.prepareResponse(finalLength, 1);

        // Flags. These are the complete set of flags we support.
		this.messageContents.writeUInt32LE(
			//FLAG_WORKSTATION_PRESENT |
			//FLAG_DOMAIN_PRESENT |
			
			// Required flags
			//FLAG_REQUEST_LAN_MANAGER_KEY |
			FLAG_REQUEST_NTLMv1 |
			FLAG_REQUEST_NTLM2_SESSION |
			
			// Protocol version request
			FLAG_REQUEST_VERSION |
			
			// Recommended privacy settings
			FLAG_REQUEST_ALWAYS_SIGN |
			//FLAG_REQUEST_SEAL |
			//FLAG_REQUEST_SIGN |
			
			// These must be set according to documentation, based on use of SEAL above
			FLAG_REQUEST_128BIT_KEY_EXCH |
			FLAG_REQUEST_56BIT_ENCRYPTION |
			//FLAG_REQUEST_EXPLICIT_KEY_EXCH |
			
			FLAG_REQUEST_UNICODE_ENCODING, 12, true);
		
		// Domain length (two times).
		this.messageContents.writeUInt16LE(this.domainBytes.length, 16);
		this.messageContents.writeUInt16LE(this.domainBytes.length, 18);
		// Domain offset.
		this.messageContents.writeUInt32LE(32 + this.hostBytes.length, 20);
		
		// Host length (two times).
		this.messageContents.writeUInt16LE(this.hostBytes.length, 24);
		this.messageContents.writeUInt16LE(this.hostBytes.length, 26);
		// Host offset (always 32 + 8).
		this.messageContents.writeUInt32LE(32 + 8, 28);
		
		// Version
		this.messageContents.writeUInt16LE(0x0105, 32);
		// Build
		this.messageContents.writeUInt32LE(2600, 34);
		// NTLM revision
		this.messageContents.writeUInt16LE(0x0f00, 38);
		
		return NTLMMessage.prototype.getResponse.call(this);
	 },
});

var Type2Message = helpers.defineClass(function(message) {
	NTLMMessage.call(this, message, 2);
	
	// Type 2 message is laid out as follows:
    // First 8 bytes: NTLMSSP[0]
    // Next 4 bytes: Ulong, value 2
    // Next 8 bytes, starting at offset 12: target field (2 ushort lengths, 1 ulong offset)
    // Next 4 bytes, starting at offset 20: Flags, e.g. 0x22890235
    // Next 8 bytes, starting at offset 24: Challenge
    // Next 8 bytes, starting at offset 32: ??? (8 bytes of zeros)
    // Next 8 bytes, starting at offset 40: targetinfo field (2 ushort lengths, 1 ulong offset)
    // Next 2 bytes, major/minor version number (e.g. 0x05 0x02)
    // Next 8 bytes, build number
    // Next 2 bytes, protocol version number (e.g. 0x00 0x0f)
    // Next, various text fields, and a ushort of value 0 at the end

    // Parse out the rest of the info we need from the message
    // The nonce is the 8 bytes starting from the byte in position 24.
    this.challenge = this.messageContents.slice(24);

    this.flags = this.messageContents.readUInt32LE(20);

    if ((this.flags & FLAG_REQUEST_UNICODE_ENCODING) === 0)
        throw new Error("NTLM type 2 message has flags that make no sense: " + this.flags);

    // Do the target!
    this.target = null;
    // The TARGET_DESIRED flag is said to not have understood semantics
    // in Type2 messages, so use the length of the packet to decide
    // how to proceed instead
    if (this.messageContents.length >= 12 + 8) {
        var tnBuf = this.readSecurityBuffer(12);
        if (tnBuf.length !== 0) {
            try {
                this.target = tnBuf.toString('ucs2');
            } catch (e) {
                throw new Error(e.message, e);
            }
        }
    }

    // Do the target info!
    this.targetInfo = null;
    // TARGET_DESIRED flag cannot be relied on, so use packet length
    if (this.messageContents.length >= 40 + 8) {
        var tiBuf = this.readSecurityBuffer(40);
        if (tiBuf.length !== 0) {
            this.targetInfo = tiBuf;
        }
    }
	
	
}, NTLMMessage, {
	
});
	
var Type3Message = helpers.defineClass(function(domain, host, user, password, nonce, type2Flags, target, targetInformation) {
	// Save the flags
    this.type2Flags = type2Flags;
    
    // Strip off domain name from the host!
    var unqualifiedHost = convertHost(host);
    // Use only the base domain name!
    var unqualifiedDomain = convertDomain(domain);
    
    // Create a cipher generator class.  Use domain BEFORE it gets modified!
    var gen = new CipherGen(unqualifiedDomain, user, password, nonce, target, targetInformation);
    try {
        // This conditional may not work on Windows Server 2008 R2 and above, where it has not yet
        // been tested
        if (((this.type2Flags & FLAG_TARGETINFO_PRESENT) !== 0) && targetInformation != null && target != null) {
            // NTLMv2
            this.ntResp = gen.getNTLMv2Response();
            this.lmResp = gen.getLMv2Response();
            if ((this.type2Flags & FLAG_REQUEST_LAN_MANAGER_KEY) !== 0) {
                this.userSessionKey = gen.getLanManagerSessionKey();
            } else {
                this.userSessionKey = gen.getNTLMv2UserSessionKey();
            }
        } else {
            // NTLMv1
            if ((this.type2Flags & FLAG_REQUEST_NTLM2_SESSION) !== 0) {
                // NTLM2 session stuff is requested
				this.ntResp = gen.getNTLM2SessionResponse();
				this.lmResp = gen.getLM2SessionResponse();
                if ((this.type2Flags & FLAG_REQUEST_LAN_MANAGER_KEY) !== 0) {
                    this.userSessionKey = gen.getLanManagerSessionKey();
                } else {
                    this.userSessionKey = gen.getNTLM2SessionResponseUserSessionKey();
                }
            } else {
				this.ntResp = gen.getNTLMResponse();
				this.lmResp = gen.getLMResponse();
                if ((this.type2Flags & FLAG_REQUEST_LAN_MANAGER_KEY) !== 0) {
                    this.userSessionKey = gen.getLanManagerSessionKey();
                } else {
                    this.userSessionKey = gen.getNTLMUserSessionKey();
                }
            }
        }
    } catch (e) {
        // This likely means we couldn't find the MD4 hash algorithm -
        // fail back to just using LM
		this.ntResp = new Buffer(0);
		this.lmResp = gen.getLMResponse();
        if ((this.type2Flags & FLAG_REQUEST_LAN_MANAGER_KEY) !== 0) {
            this.userSessionKey = gen.getLanManagerSessionKey();
        } else {
            this.userSessionKey = gen.getLMUserSessionKey();
        }
    }
    
    
    if ((this.type2Flags & FLAG_REQUEST_SIGN) !== 0) {
	if ((this.type2Flags & FLAG_REQUEST_EXPLICIT_KEY_EXCH) !== 0) {
		this.sessionKey = rc4_encrypt(gen.getSecondaryKey(), this.userSessionKey);
	} else
		this.sessionKey = this.userSessionKey;
	} else {
		this.sessionKey = null;
    }

    try {
        this.domainBytes = new Buffer(unqualifiedDomain.toUpperCase(), 'ucs2');
        this.hostBytes = new Buffer(unqualifiedHost, 'ucs2');
        this.userBytes = new Buffer(user, 'ucs2');
    } catch (e) {
        throw new Error("Unicode not supported: " + e.message, e);
    }
    
    
}, NTLMMessage, {
    getResponse: function() {
        var ntRespLen = this.ntResp.length;
        var lmRespLen = this.lmResp.length;

        var domainLen = this.domainBytes.length;
        var hostLen = this.hostBytes.length;
        var userLen = this.userBytes.length;
        var sessionKeyLen;
        if (this.sessionKey != null)
            sessionKeyLen = this.sessionKey.length;
        else
            sessionKeyLen = 0;

        // Calculate the layout within the packet
        var lmRespOffset = 72;  // allocate space for the version
        var ntRespOffset = lmRespOffset + lmRespLen;
        var domainOffset = 64;
        var userOffset = domainOffset + domainLen;
        var hostOffset = userOffset + userLen;
        var sessionKeyOffset = hostOffset + hostLen;
        var finalLength = sessionKeyOffset + sessionKeyLen;

        // Start the response. Length includes signature and type
        this.prepareResponse(finalLength, 3);

        // LM Resp Length (twice)
        this.messageContents.writeUInt16LE(lmRespLen, 12);
        this.messageContents.writeUInt16LE(lmRespLen, 14);

        // LM Resp Offset
        this.messageContents.writeUInt32LE(lmRespOffset, 16);

        // NT Resp Length (twice)
        this.messageContents.writeUInt16LE(ntRespLen, 20);
        this.messageContents.writeUInt16LE(ntRespLen, 22);

        // NT Resp Offset
        this.messageContents.writeUInt32LE(ntRespOffset, 24);

        // Domain length (twice)
        this.messageContents.writeUInt16LE(domainLen, 28);
        this.messageContents.writeUInt16LE(domainLen, 30);

        // Domain offset.
        this.messageContents.writeUInt32LE(domainOffset, 32);

        // User Length (twice)
        this.messageContents.writeUInt16LE(userLen, 36);
        this.messageContents.writeUInt16LE(userLen, 38);

        // User offset
        this.messageContents.writeUInt32LE(userOffset, 40);

        // Host length (twice)
        this.messageContents.writeUInt16LE(hostLen, 44);
        this.messageContents.writeUInt16LE(hostLen, 46);

        // Host offset
        this.messageContents.writeUInt32LE(hostOffset, 48);

        // Session key length (twice)
        this.messageContents.writeUInt16LE(sessionKeyLen, 52);
        this.messageContents.writeUInt16LE(sessionKeyLen, 54);

        // Session key offset
        this.messageContents.writeUInt32LE(sessionKeyOffset, 56);

        var newFlags = 
			//FLAG_WORKSTATION_PRESENT |
			//FLAG_DOMAIN_PRESENT |

            // Required flags
            (this.type2Flags & FLAG_REQUEST_LAN_MANAGER_KEY) |
            (this.type2Flags & FLAG_REQUEST_NTLMv1) |
            (this.type2Flags & FLAG_REQUEST_NTLM2_SESSION) |

            // Protocol version request
            FLAG_REQUEST_VERSION |

            // Recommended privacy settings
            (this.type2Flags & FLAG_REQUEST_ALWAYS_SIGN) |
            (this.type2Flags & FLAG_REQUEST_SEAL) |
            (this.type2Flags & FLAG_REQUEST_SIGN) |

            // These must be set according to documentation, based on use of SEAL above
            (this.type2Flags & FLAG_REQUEST_128BIT_KEY_EXCH) |
            (this.type2Flags & FLAG_REQUEST_56BIT_ENCRYPTION) |
            (this.type2Flags & FLAG_REQUEST_EXPLICIT_KEY_EXCH) |

            (this.type2Flags & FLAG_TARGETINFO_PRESENT) |
            (this.type2Flags & FLAG_REQUEST_UNICODE_ENCODING) |
            (this.type2Flags & FLAG_REQUEST_TARGET);

        // Flags.
        this.messageContents.writeUInt32LE(newFlags, 60, true);

        // Version
        this.messageContents.writeUInt16LE(0x0105, 66);
        // Build
        this.messageContents.writeUInt32LE(2600, 68);
        // NTLM revision
        this.messageContents.writeUInt16LE(0x0f00, 70);

        // Add the actual data
        this.messageContents = Buffer.concat([this.messageContents, this.lmResp, this.ntResp, this.domainBytes, this.userBytes, this.hostBytes]);

		if (this.sessionKey != null)
			this.messageContents = Buffer.concat([this.messageContents, this.sessionKey]);

        return NTLMMessage.prototype.getResponse.call(this);
    }

});

/**
 * Creates the first message (type 1 message) in the NTLM authentication
 * sequence. This message includes the user name, domain and host for the
 * authentication session.
 *
 * @param host
 *            the computer name of the host requesting authentication.
 * @param domain
 *            The domain to authenticate with.
 * @return String the message to add to the HTTP request header.
 */
var getType1Message = function(host, domain) {
    return new Type1Message(domain, host).getResponse();
};

/**
 * Creates the type 3 message using the given server nonce. The type 3
 * message includes all the information for authentication, host, domain,
 * username and the result of encrypting the nonce sent by the server using
 * the user's password as the key.
 *
 * @param user
 *            The user name. This should not include the domain name.
 * @param password
 *            The password.
 * @param host
 *            The host that is originating the authentication request.
 * @param domain
 *            The domain to authenticate within.
 * @param nonce
 *            the 8 byte array the server sent.
 * @return The type 3 message.
 * @throws NTLMEngineException
 *             If {@encrypt(byte[],byte[])} fails.
 */
var getType3Message = function(user, password, host, domain, nonce, type2Flags, target, targetInformation) {
    return new Type3Message(domain, host, user, password, nonce, type2Flags, target, targetInformation).getResponse();
};

var generateType1Msg = exports.generateType1Msg = function(domain,workstation) {
    return getType1Message(workstation, domain);
};

var generateType3Msg = exports.generateType3Msg = function(username,password,domain,workstation,message) {
    var t2m = new Type2Message(message);
    return getType3Message(username, password, workstation, domain, t2m.challenge, t2m.flags, t2m.target, t2m.targetInfo);
};


// Temporary function. Http requests will be handle somewhere else.
exports.authenticate = function(proxy){

	function sendMsg(msg, cookie, cb){
		var opt = {
			protocol: "http:",
			method: "GET",
			host: proxy.host,
			port: proxy.port,
			//path: "http://footballpool.dataaccess.eu/data/info.wso?wsdl",
			headers: {
				//"host": "footballpool.dataaccess.eu",
				"Proxy-Connection": "Keep-Alive",
				"Proxy-Authorization": "NTLM " + msg
				//,"Persist": proxy.host,
				//"Connection": "Persist"
			}
		};
		//if (cookie)
			//opt.headers.cookie = cookie;
		tracer && tracer("Request Headers: "+JSON.stringify(opt.headers,null,2));

		http.request(opt, cb).end();
		
//		var request = streams.httpRequest(opt);
//		return request.end().response(_);
	}
	
	try {
	//
	if (!proxy.user) throw new Error("request error: no proxy user for NTLM authentication");
	
	var msg1, msg2, msg3;
	
	msg1 = generateType1Msg(proxy.domain, proxy.workstation);

	var response1 = {};
	var cb1 = function(response) {
		var cb2 = function(response2) {
			tracer && tracer("Response 2 Headers: "+JSON.stringify(response2.headers,null,2));
			tracer && tracer("Response 2 status code: "+response2.statusCode);
			response2.on("error", function(e){
				tracer && tracer("Got error in response 2: " + e.message);
			});
		};
		
		
		response1.statusCode = response.statusCode;
		response1.headers = response.headers;
		response1.body = "";

		//another chunk of data has been received, so append it to `str`
		response.on('data', function (chunk) {
			response1.body += chunk;
		});
		
		//the whole response has been received, so we just print it out here
		response.on('end', function () {
			tracer && tracer("Response 1 ended: "+response1.body);
			tracer && tracer("Response 1 Headers: "+JSON.stringify(response1.headers,null,2));
			tracer && tracer("Response 1 status code: "+response1.statusCode);
			
			var proxyAuth = response1.headers["proxy-authenticate"];
			var cookie = response1.headers["set-cookie"];
			if (proxyAuth && proxyAuth.indexOf('NTLM ') === 0){
				msg2 = proxyAuth.split('NTLM ')[1];
				
				msg3 = generateType3Msg(proxy.user, proxy.password, proxy.domain, proxy.workstation, msg2);
				tracer && tracer("=====================");
				tracer && tracer("Send second request");
				sendMsg(msg3, cookie, cb2);
			}else{
				throw new Error ("Type-2 message not received.");
			}

		});
		response.on("error", function(e){
			tracer && tracer("Got error in response 1: " + e.message);
		});
	};
	
	var cb0 = function(response0) {
		tracer && tracer("Response 0 Headers: "+JSON.stringify(response0.headers,null,2));
		tracer && tracer("Response 0 status code: "+response0.statusCode);
		response0.on("error", function(e){
			tracer && tracer("Got error in response 0: " + e.message);
		});
	};
	tracer && tracer("=====================");
	tracer && tracer("Send first request");
	http.request({
		protocol: "http:",
		method: "GET",
		host: proxy.host,
		port: proxy.port,
		headers: {
			"Proxy-Connection": "Keep-Alive"
		}
	}, cb0).end();
	
	tracer && tracer("=====================");
	tracer && tracer("Send second request");
	sendMsg(msg1, null, cb1);

	}catch(e) {
		console.error(e.stack);
	}
	



	return "NTLM ";	
};