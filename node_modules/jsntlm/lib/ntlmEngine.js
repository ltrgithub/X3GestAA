"use strict";

var http = require('http');
var helpers = require('syracuse-core/lib/helpers');
var events = require('events');
var crypto = require('crypto');

/*
[MS-NLMP]
2.2.2.5 NEGOTIATE
During NTLM authentication, each of the following flags is a possible value of the NegotiateFlags
field of the NEGOTIATE_MESSAGE, CHALLENGE_MESSAGE, and AUTHENTICATE_MESSAGE, unless
otherwise noted. These flags define client or server NTLM capabilities supported by the sender.
*/
var NTLMSSP_NEGOTIATE_UNICODE_FLAG =0x00000001;	/* A  */
var NTLMSSP_NEGOTIATE_OEM_FLAG =0x00000002;	/* B  */
var NTLMSSP_REQUEST_TARGET_FLAG =0x00000004;	/* C  */
//var r9						0x00000008	/* r9 */
var NTLMSSP_NEGOTIATE_SIGN_FLAG =0x00000010;	/* D  */
var NTLMSSP_NEGOTIATE_SEAL_FLAG =0x00000020;	/* E  */
var NTLMSSP_NEGOTIATE_DATAGRAM_FLAG =0x00000040;	/* F  */
var NTLMSSP_NEGOTIATE_LM_KEY_FLAG =0x00000080;	/* G  */
//var r8						0x00000100	/* r8 */
var NTLMSSP_NEGOTIATE_NTLM_FLAG =0x00000200;	/* H  */
var NTLMSSP_NEGOTIATE_NT_ONLY_FLAG =0x00000400;	/* I  */
var NTLMSSP_NEGOTIATE_anonymous_FLAG =0x00000800;	/* J  */
var NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED_FLAG =0x00001000;	/* K  */
var NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED_FLAG =0x00002000;	/* L  */
//var r7						0x00004000	/* r7 */
var NTLMSSP_NEGOTIATE_ALWAYS_SIGN_FLAG =0x00008000;	/* M  */
var NTLMSSP_TARGET_TYPE_DOMAIN_FLAG =0x00010000;	/* N  */
var NTLMSSP_TARGET_TYPE_SERVER_FLAG =0x00020000;	/* O  */
//var r6						0x00040000	/* r6 */
var NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY_FLAG =0x00080000;	/* P  */
var NTLMSSP_NEGOTIATE_IDENTIFY_FLAG =0x00100000;	/* Q  */
//var r5						0x00200000	/* r5 */
var NTLMSSP_REQUEST_NON_NT_SESSION_KEY_FLAG =0x00400000;	/* R  */
var NTLMSSP_NEGOTIATE_TARGET_INFO_FLAG =0x00800000;	/* S  */
//var r4						0x01000000	/* r4 */
var NTLMSSP_NEGOTIATE_VERSION_FLAG =0x02000000;	/* T  */
//var r3						0x04000000	/* r3 */
//var r2						0x08000000	/* r2 */
//var r1						0x10000000	/* r1 */
var NTLMSSP_NEGOTIATE_128_FLAG =0x20000000;	/* U  */
var NTLMSSP_NEGOTIATE_KEY_EXCH_FLAG =0x40000000;	/* V  */
var NTLMSSP_NEGOTIATE_56_FLAG =0x80000000;	/* W  */
    


/* Minimum set of common features we need to work. */
/* we operate in NTLMv2 mode */
var NEGOTIATE_FLAGS_COMMON_MIN = bitWiseOr([
	NTLMSSP_NEGOTIATE_UNICODE_FLAG,
	NTLMSSP_NEGOTIATE_NTLM_FLAG,
	NTLMSSP_NEGOTIATE_ALWAYS_SIGN_FLAG,
	NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY_FLAG,
	NTLMSSP_NEGOTIATE_TARGET_INFO_FLAG
]);

/* Negotiate flags for connection-based mode. Nice to have but optional. */
var NEGOTIATE_FLAGS_CONN = bitWiseOr([
	NEGOTIATE_FLAGS_COMMON_MIN,
	NTLMSSP_NEGOTIATE_VERSION_FLAG,
	NTLMSSP_NEGOTIATE_128_FLAG,
	NTLMSSP_NEGOTIATE_56_FLAG,
	NTLMSSP_REQUEST_TARGET_FLAG
]);

/* Extra negotiate flags required in connectionless NTLM */
var NEGOTIATE_FLAGS_CONNLESS_EXTRA = bitWiseOr([
	NTLMSSP_NEGOTIATE_SIGN_FLAG,
	NTLMSSP_NEGOTIATE_DATAGRAM_FLAG,
	NTLMSSP_NEGOTIATE_IDENTIFY_FLAG,
	NTLMSSP_NEGOTIATE_KEY_EXCH_FLAG
]);

/* Negotiate flags required in connectionless NTLM */
var NEGOTIATE_FLAGS_CONNLESS = bitWiseOr([NEGOTIATE_FLAGS_CONN, NEGOTIATE_FLAGS_CONNLESS_EXTRA]);

var magicString = {
	client: {
		signing: "session key to client-to-server signing key magic constant",
		sealing: "session key to client-to-server sealing key magic constant"
	},
	server: {
		signing: "session key to server-to-client signing key magic constant",
		sealing: "session key to server-to-client sealing key magic constant"
	}
};

var windowsVersions = [
    "0501280A0000000F", // WindowsXp
    "060072170000000F", // WindowsVista
    "0601B11D0000000F"  // Windows7
];

/** Strip dot suffix from a name */
function stripDotSuffix(value) {
    var index = value.indexOf(".");
    if (index !== -1)
        return value.substring(0, index);
    return value;
}

/** Convert host to standard form */
function convertHost(host) {
    return stripDotSuffix(host);
}

/** Convert domain to standard form */
function convertDomain(domain) {
    return stripDotSuffix(domain);
}

var PARITY = [];

for (var i = 0; i < 256; i++) {
	var sum = 0;
	for (var j = 0; j < 8; j++) sum += (i >> j) & 1;
	PARITY[i] = sum % 2 ?  i : i ^ 1 ;
}

/**
 * Calculates the NTLM2 Session Response for the given challenge, using the
 * specified password and client challenge.
 *
 * @return The NTLM2 Session Response. This is placed in the NTLM response
 *         field of the Type 3 message; the LM response field contains the
 *         client challenge, null-padded to 24 bytes.
 */
var ntlm2SessionResponse = function(_ntlmHash, challenge, clientChallenge) {
    try {
		var digest = crypto.createHash('md5').update(challenge).update(clientChallenge).digest();
		return lmResponse(_ntlmHash, digest.slice(0, 8));
    } catch (e) {
        throw new Error(e.message, e);
    }
};

/**
 * Creates the LM Hash of the user's password.
 * This is a 32-bit hexadecimal sequence that represents the password clients will use.
 * It is derived by encrypting the string  KGS!@#$% with a 56-bit DES algorithm using
 * the user's password (forced to 14 bytes and converted to capital letters) twice
 * repeated as the key.
 * 
 * @param password The password.
 *
 * @return The LM Hash of the given password, used in the calculation
 * of the LM Response.
 */
var lmHash = function(password){
	var magic = 'KGS!@#$%';
	var lm_pw = new Buffer(14);
	for (var i = 0 ; i < 14 ; i++){
		lm_pw[i] = password[i] ? password.toUpperCase().charCodeAt(i) : 0x00 ;
	}

  var ks = setup_des_key(lm_pw.slice(0,7));
  var lm_hpw = des_encrypt(magic, ks);
  ks = setup_des_key(lm_pw.slice(7));
  lm_hpw += des_encrypt(magic, ks);
  return lm_hpw;
};

/// ## ntlmHash
/// ``` javascript
/// var lmHash = helpers.ntlmHash(password);  
/// ```
/// Creates the NTLM Hash of the user's password.
/// This is a 32-bit hexadecimal sequence that represents the password Windows NT clients
/// will use. It is derived by hashing the user's password (represented as a 16-bit little-endian
/// Unicode sequence) with an MD4 hash. The password is not converted to uppercase letters first.
///
/// @param password The password.
///
/// @return The NTLM Hash of the given password, used in the calculation
/// of the NTLM Response and the NTLMv2 and LMv2 Hashes.
///
var ntlmHash = function(password){
	return crypto.createHash('md4').update(new Buffer(password,'ucs2')).digest('hex');
};

/// ## ntlmv2Hash
/// ``` javascript
/// var lmHash = helpers.ntlmv2Hash(target, user, password);  
/// ```
/// Creates the NTLMv2 Hash of the user's password.
///
/// @param target The authentication target (i.e., domain).
/// @param user The username.
/// @param password The password.
///
/// @return The NTLMv2 Hash, used in the calculation of the NTLMv2
/// and LMv2 Responses. 
///
var ntlmv2Hash = function(target, user, _ntlmHash){
	var identity = user.toUpperCase() + target;
	return crypto.createHmac('md5', _ntlmHash).update(new Buffer(identity,'ucs2')).digest('hex');
};

var lmv2Hash = function(target, user, _ntlmHash){
	var identity = Buffer.concat([new Buffer(user.toUpperCase(),'ucs2'), new Buffer(target.toUpperCase(),'ucs2')]);
	return crypto.createHmac('md5', _ntlmHash).update(identity).digest('hex');
};

/**
 * Creates the LM Response from the given hash and Type 2 challenge.
 *
 * @param hash The LM or NTLM Hash.
 * @param challenge The server challenge from the Type 2 message.
 *
 * @return The response (either LM or NTLM, depending on the provided
 * hash).
 */
var lmResponse = function(hash, challenge) {
	function padHash(buf){
		var newBuf = new Buffer(21);
		buf.copy(newBuf);
		for (var i = 16 ; i < 21 ; i++){
			newBuf[i] = 0x00 ;
		}
		return newBuf;
	}
	
	var keys = padHash(hash);
    var ks = setup_des_key(keys.slice(0,7));
    var resp = des_encrypt(challenge, ks);

    ks = setup_des_key(keys.slice(7,14));
    resp += des_encrypt(challenge, ks);
    
    ks = setup_des_key(keys.slice(14));
    resp += des_encrypt(challenge, ks);
    
    return new Buffer(resp, 'hex');
};

/**
 * Creates the LMv2 Response from the given hash, client data, and
 * Type 2 challenge.
 *
 * @param hash The NTLMv2 Hash.
 * @param clientData The client data (blob or client challenge).
 * @param challenge The server challenge from the Type 2 message.
 *
 * @return The response (either NTLMv2 or LMv2, depending on the
 * client data).
 */
var lmv2Response = function(hash, challenge, clientData) {
    var data = Buffer.concat([challenge, clientData], challenge.length + clientData.length);
    var macHex =  crypto.createHmac('md5', hash).update(data).digest('hex');
    var mac = new Buffer(macHex, 'hex');
    return Buffer.concat([mac, clientData], mac.length + clientData.length);
};

/**
 * Creates the NTLMv2 blob from the given target information block and
 * client challenge.
 *
 * @param clientNonce The random 8-byte client challenge.
 * @param targetInformation The target information block from the Type 2
 * message.
 *
 * @return Buffer The blob, used in the calculation of the NTLMv2 Response.
 */
var createBlob = function(clientNonce, targetInformation, timestamp) {
    var blobSignature = new Buffer([0x01, 0x01, 0x00, 0x00]);
    var reserved = new Buffer([0x00, 0x00, 0x00, 0x00]);
    var unknown1 = new Buffer([0x00, 0x00, 0x00, 0x00]);
    var unknown2 = new Buffer([0x00, 0x00, 0x00, 0x00]);
    var blobLen = blobSignature.length + reserved.length + timestamp.length + clientNonce.length + unknown1.length + targetInformation.length + unknown2.length;
    return Buffer.concat([blobSignature, reserved, timestamp, clientNonce, unknown1, targetInformation, unknown2], blobLen);
};

/*
 * turns a 56 bit key into the 64 bit, odd parity key and sets the key.
 * The key schedule ks is also set.
 */
var setup_des_key = function(key_56)
{
	function odd_parity(key){
		for (var i = 0; i < 8; i++){
			key[i] = PARITY[key[i]];
		}
	}
    var key = new Buffer(8);
	key[0] = key_56[0];
	key[1] = ((key_56[0] << 7) & 0xff) | (key_56[1] >> 1);
	key[2] = ((key_56[1] << 6) & 0xff) | (key_56[2] >> 2);
	key[3] = ((key_56[2] << 5) & 0xff) | (key_56[3] >> 3);
	key[4] = ((key_56[3] << 4) & 0xff) | (key_56[4] >> 4);
	key[5] = ((key_56[4] << 3) & 0xff) | (key_56[5] >> 5);
	key[6] = ((key_56[5] << 2) & 0xff) | (key_56[6] >> 6);
	key[7] = (key_56[6] << 1) & 0xff;
	odd_parity(key);
    return key;
};

/**
 * Creates a DES encryption key from the given key material.
 *
 * @param str Data to encrypt.
 * @param key The key to use for the encryption.
 *
 * @return Encrypted data.
 */
var des_encrypt = function(str, key){
    var iv = new Buffer(8);
    for (var i = 0 ; i < 8 ; i++) iv[i] = 0x00;
	var tokencrypt = crypto.createCipheriv('des-cbc', new Buffer(key, 'hex'), iv);
	var token = tokencrypt.update(str, 'ascii', 'hex');
	tokencrypt.final('hex');
	return token;
};

var rc4_encrypt = function(buf, key){

	var S = new Buffer(256);
	var T = new Buffer(256);
	
	var keylen, i, j;
    if (key.length < 1 || key.length > 256) {
        throw new Error("RC4 key must be between 1 and 256 bytes");
    } else {
        keylen = key.length;
        for(i = 0; i < 256; i++) {
            S[i] = i & 0xff;
            T[i] = key[i % keylen];
        }
        j = 0;
        for(i = 0; i < 256; i++) {
            j = (j + S[i] + T[i]) & 0xFF;
            S[i] ^= S[j];
            S[j] ^= S[i];
            S[i] ^= S[j];
        }
    }
	
    i = 0;
    j = 0;
    var ciphertext = new Buffer(buf.length);
    var counter, k, t;
    for (counter = 0; counter < buf.length; counter++) {
        i = (i + 1) & 0xFF;
        j = (j + S[i]) & 0xFF;
        S[i] ^= S[j];
        S[j] ^= S[i];
        S[i] ^= S[j];
        t = (S[i] + S[j]) & 0xFF;
        k = S[t];
        ciphertext[counter] = (buf[counter] ^ k) & 0xFF;
    }
    return ciphertext;
};

function bitWiseOr(arr) {
	var result = arr[0];
	
	console.log("Res0: "+result);
	for (var i = 1; i < arr.length; i++) {
		result = (result | arr[i]);
		console.log("-Res"+i+": "+result);
		if (result < 0)
			result = result + 0x100000000;
		console.log("+Res"+i+": "+result);
	}
	console.log("Result: "+result);
	return result; 
}

var CipherGen = exports.CipherGen = helpers.defineClass(function(domain, user, password, challenge, target, targetInformation, clientChallenge, clientChallenge2, randomSessionKey, timestamp) {
    this.domain = domain;
    this.target = target;
    this.user = user;
    this.password = password;
    this.challenge = challenge;
    this.targetInformation = targetInformation;
    this.clientChallenge = clientChallenge;
    this.clientChallenge2 = clientChallenge2;
    this.randomSessionKey = randomSessionKey;
    this.timestamp = timestamp;
    
    
//    console.log("domain: "+this.domain.toString('hex'));
//    console.log("target: "+this.target.toString('hex'));
//    console.log("user: "+this.user.toString('hex'));
//    console.log("password: "+this.password.toString('hex'));
//    console.log("challenge: "+this.challenge.toString('hex'));
//    console.log("targetInformation: "+this.targetInformation.toString('hex'));
//    console.log("clientChallenge: "+this.clientChallenge.toString('hex'));
//    console.log("clientChallenge2: "+this.clientChallenge2.toString('hex'));
//    console.log("randomSessionKey: "+this.randomSessionKey.toString('hex'));
//    console.log("timestamp: "+this.timestamp.toString('hex'));
    

    // Stuff we always generate
    this.lmHash = null;
    this.lmResponse = null;
    this.ntlmHash = null;
    this.ntlmResponse = null;
    this.ntlmv2Hash = null;
    this.lmv2Hash = null;
    this.lmv2Response = null;
    this.ntlmv2Blob = null;
    this.ntlmv2Response = null;
    this.ntlm2SessionResponse = null;
    this.lm2SessionResponse = null;
    this.lmUserSessionKey = null;
    this.ntlmUserSessionKey = null;
    this.ntlmv2UserSessionKey = null;
    this.ntlm2SessionResponseUserSessionKey = null;
    this.lanManagerSessionKey = null;

    this.MAC_VERSION = new Buffer([1, 0, 0, 0]);
}, null, {
	
    /** Calculate and return client challenge */
    getClientChallenge: function() {
		if (this.clientChallenge == null)
			this.clientChallenge = crypto.randomBytes(8);
        return this.clientChallenge;
    },

    /** Calculate and return second client challenge */
    getClientChallenge2: function() {
		if (this.clientChallenge2 == null)
			this.clientChallenge2 = crypto.randomBytes(8);
        return this.clientChallenge2;
    },

    /** Calculate and return random secondary key */
    getRandomSessionKey: function() {
		if (this.randomSessionKey == null)
			this.randomSessionKey = crypto.randomBytes(16);
        return this.randomSessionKey;
    },

    /** Calculate and return the LMHash */
    getLMHash: function() {
		if (this.lmHash == null)
			this.lmHash = new Buffer(lmHash(this.password), 'hex');
        return this.lmHash;
    },

    /** Calculate and return the LMResponse */
    getLMResponse: function() {
		if (this.lmResponse == null)
			this.lmResponse = lmResponse(this.getLMHash(), this.challenge);
        return this.lmResponse;
    },

    /** Calculate and return the NTLMHash */
    getNTLMHash: function() {
		if (this.ntlmHash == null)
			this.ntlmHash = new Buffer(ntlmHash(this.password), 'hex');
        return this.ntlmHash;
    },

    /** Calculate and return the NTLMResponse */
    getNTLMResponse: function() {
		if (this.ntlmResponse == null)
			this.ntlmResponse = lmResponse(this.getNTLMHash(),this.challenge);
        return this.ntlmResponse;
    },

    /** Calculate the LMv2 hash */
    getLMv2Hash: function() {
		if (this.lmv2Hash == null)
			this.lmv2Hash = new Buffer(lmv2Hash(this.domain, this.user, this.getNTLMHash()), 'hex');
        return this.lmv2Hash;
    },

    /** Calculate the NTLMv2 hash */
    getNTLMv2Hash: function() {
		if (this.ntlmv2Hash == null)
			this.ntlmv2Hash = new Buffer(ntlmv2Hash(this.domain, this.user, this.getNTLMHash()), 'hex');
        return this.ntlmv2Hash;
    },

    /** Calculate a timestamp */
    getTimestamp: function(millis) {
		millis = new Date().getTime();
		// shift origin to Jan 1, 1601
		var t = millis + 11644473600000;
		// t uses 44 bits. JS integers only have 52 bits.
		// We can't multiply by 10000 because result would need 57 bits
		// So we divide by 16 to gain 4 bits and we multiply by 625
		// instead of 10000 to save another 4 bits  (625 == 10000 / 16).
		// Caution: don't divide with >> 4 at it treats operands as 32 bit integers.
		t = Math.floor(t / 16) * 625;
		// t is the value to serialize, divided by 256.
		var buf = new Buffer(8);
		buf[0] = 0; // set lower bits to 0 to cope for 256 division
		for (var i = 1; i < 8; i++) {
			buf[i] = t & 0xff;
			t = Math.floor(t / 256);
		}
		return buf;
    },

    /** Calculate the NTLMv2Blob */
    getNTLMv2Blob: function() {
		if (this.ntlmv2Blob == null)
			this.ntlmv2Blob = createBlob(this.getClientChallenge2(), this.targetInformation, this.timestamp || this.getTimestamp());
        return this.ntlmv2Blob;
    },

    /** Calculate the NTLMv2Response */
    getNTLMv2Response: function() {
		if (this.ntlmv2Response == null)
			this.ntlmv2Response = lmv2Response(this.getNTLMv2Hash(),this.challenge,this.getNTLMv2Blob());
        return this.ntlmv2Response;
    },

    /** Calculate the LMv2Response */
    getLMv2Response: function() {
		if (this.lmv2Response == null)
			this.lmv2Response = lmv2Response(this.getNTLMv2Hash(),this.challenge,this.getClientChallenge());
        return this.lmv2Response;
    },

    /** Get NTLM2SessionResponse */
    getNTLM2SessionResponse: function() {
		if (this.ntlm2SessionResponse == null) 
			this.ntlm2SessionResponse = ntlm2SessionResponse(this.getNTLMHash(),this.challenge,this.getClientChallenge());
		return this.ntlm2SessionResponse;
    },

    /** Calculate and return LM2 session response */
    getLM2SessionResponse: function() {
        if (this.lm2SessionResponse == null) {
            var _clientChallenge = this.getClientChallenge();            
            this.lm2SessionResponse = Buffer.concat([_clientChallenge.slice(0, _clientChallenge.length), new Buffer([0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00])]);
        }
        return this.lm2SessionResponse;
    },

    /** Get LMUserSessionKey */
    getLMUserSessionKey: function() {
        if (this.lmUserSessionKey == null) {
            var _lmHash = this.getLMHash();
            this.lmUserSessionKey = Buffer.concat([_lmHash.slice(0, 8), new Buffer([0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00])]);
        }
        return this.lmUserSessionKey;
    },

    /** Get NTLMUserSessionKey */
    getNTLMUserSessionKey: function() {
        if (this.ntlmUserSessionKey == null) {
            var _ntlmHash = this.getNTLMHash();
            this.ntlmUserSessionKey = new Buffer(crypto.createHash('md4').update(_ntlmHash).digest('hex'), 'hex');
        }
        return this.ntlmUserSessionKey;
    },

    /** GetNTLMv2UserSessionKey */
    getNTLMv2UserSessionKey: function() {
        if (this.ntlmv2UserSessionKey == null) {
            var _ntlmv2hash = this.getNTLMv2Hash();
            var truncatedResponse = this.getNTLMv2Response().slice(0, 16);
            this.ntlmv2UserSessionKey = new Buffer(crypto.createHmac('md5', _ntlmv2hash).update(truncatedResponse).digest('hex'), 'hex');
        }
        return this.ntlmv2UserSessionKey;
    },
    
    /** GetEncryptedSessionKey */
	getEncryptedSessionKey: function(sessionKey) {
		return rc4_encrypt(this.getRandomSessionKey(), sessionKey);
	},

    /** Get NTLM2SessionResponseUserSessionKey */
    getNTLM2SessionResponseUserSessionKey: function() {
        if (this.ntlm2SessionResponseUserSessionKey == null) {
            var ntlmUserSessionKey = this.getNTLMUserSessionKey();
            var ntlm2SessionResponseNonce = this.getLM2SessionResponse();
            var sessionNonce = Buffer.concat([this.challenge, ntlm2SessionResponseNonce]);
            this.ntlm2SessionResponseUserSessionKey =  new Buffer(crypto.createHmac('md5', ntlmUserSessionKey).update(sessionNonce).digest('hex'), 'hex');
        }
        return this.ntlm2SessionResponseUserSessionKey;
    },

    /** Get LAN Manager session key */
    getLanManagerSessionKey: function() {
        if (this.lanManagerSessionKey == null) {
            var lmHash = this.getLMHash();
            var lmResponse = this.getLMResponse();

            try {

				var keyBytes = new Buffer(14);
				for (var i = 0 ; i < 8 ; i++){
					keyBytes[i] = lmHash[i];
				}
				for (var j = 8 ; j < keyBytes.length ; j++){
					keyBytes[i] = 0xbd;
				}
				var truncatedResponse = lmResponse.slice(0,8);
				var ks = setup_des_key(keyBytes.slice(0,7));
				this.lanManagerSessionKey = des_encrypt(truncatedResponse, ks);
				ks = setup_des_key(keyBytes.slice(7));
				this.lanManagerSessionKey += des_encrypt(truncatedResponse, ks);                
            } catch (e) {
                throw new Error(e.message, e);
            }
        }
        return this.lanManagerSessionKey;
    },
    
    signkey: function(flags, keyType) {
		if (flags & NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY_FLAG !== 0) {
	        var key = magicString[keyType].signing;
	        var magicBuf = new Buffer(key.length + 1);
	        magicBuf.write(key, 0, key.length, 'ascii');
	        magicBuf.writeUInt8(0, key.length);// '\0'
			
			var data = Buffer.concat([this.getRandomSessionKey(), magicBuf]);
			var _signKey = crypto.createHash('md5').update(data).digest('hex');
			return new Buffer(_signKey, "hex");
		} else {
		    return null;
		}
    },
    
    sealkey: function(flags, keyType) {
        var _sealKey;
        if (flags & NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY_FLAG !== 0) {
			if (flags & NTLMSSP_NEGOTIATE_128_FLAG !== 0) {
			    _sealKey = this.getRandomSessionKey();
			} else if (flags & NTLMSSP_NEGOTIATE_56_FLAG !== 0) {
			    _sealKey = this.getRandomSessionKey().slice(0, 7);
			} else {
			    _sealKey = this.getRandomSessionKey().slice(0, 5);
			}
	        var key = magicString[keyType].sealing;
	        var magicBuf = new Buffer(key.length + 1);
	        magicBuf.write(key, 0, key.length, 'ascii');
	        magicBuf.writeUInt8(0, key.length);// '\0'
	        
			var data = Buffer.concat([_sealKey, magicBuf]);
			_sealKey = new Buffer(crypto.createHash('md5').update(data).digest('hex'), "hex");
        } else {
            _sealKey = new Buffer(8);
			if (flags & NTLMSSP_NEGOTIATE_56_FLAG !== 0) {
			    // todo [!] seems to be either spec error or examples error - see http://social.msdn.microsoft.com/Forums/en-US/os_windowsprotocols/thread/a6d0241f-b608-4863-bff0-7cb0bb4f27e2/
			/*
			                System.arraycopy(randomSessionKey, 0, _sealKey, 0, 7);
			                _sealKey[7] = (byte) 0xA0;
			*/
			    _sealKey = this.getRandomSessionKey();
			} else {
				_sealKey = this.getRandomSessionKey().slice(0, 5);
			    _sealKey[5] = 0xE5 & 0xff;
			    _sealKey[6] = 0x38 & 0xff;
			    _sealKey[7] = 0xB0 & 0xff;
			}
        }
        return _sealKey;
    },
    
    mac: function(negotiateFlags, seqNum, signingKey, sealingKey, randomPad, message) {
        if (negotiateFlags & NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY_FLAG !== 0) {

			/*
			3.4.4.2 With Extended Session Security
			When Extended Session Security (NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY) is
			negotiated and session security (NTLMSSP_NEGOTIATE_SIGN or NTLMSSP_NEGOTIATE_SEAL) is
			negotiated, the message signature for NTLM with extended session security is a 16-byte value that
			contains the following components, as described by the NTLMSSP_MESSAGE_SIGNATURE structure:
			* A 4-byte version-number value that is set to 1.
			* The first eight bytes of the message's HMAC_MD5.
			* The 4-byte sequence number (SeqNum).
			If message integrity is negotiated, the message signature is calculated as follows:
			-- Input:
			--  SigningKey - The key used to sign the message.
			--  SealingKey - The key used to seal the message or checksum.
			--  Message - The message being sent between the client and server.
			--  SeqNum - Defined in section 3.1.1.
			--  Handle - The handle to a key state structure corresponding to the
			--          current state of the SealingKey
			--
			-- Output:
			--  An NTLMSSP_MESSAGE_SIGNATURE structure whose fields are defined
			    in section 2.2.2.9.
			--  SeqNum - Defined in section 3.1.1.
			--
			-- Functions used:
			--  ConcatenationOf() - Defined in Section 6.
			--  RC4() - Defined in Section 6.
			--  HMAC_MD5() - Defined in Section 6.
			*/
			var seqBuf = new Buffer(4);
			seqBuf.writeUInt32LE(seqNum, 0);
			
			console.log("SeqNum: "+seqBuf.toString('hex'));
			var hmacMd5 = crypto.createHmac('md5', signingKey).update(seqBuf).update(message).digest('hex');
			var md5Result = new Buffer(hmacMd5, "hex").slice(0, 8);
			console.log("md5Result: "+md5Result.toString('hex'));
			var checksum;
			if (negotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH_FLAG !== 0) {
				try {
					// TODO : this doesn't work; also the signature too
					checksum = rc4_encrypt(md5Result.slice(0, 8), sealingKey);
					console.log("checksum: "+checksum.toString("hex"));
				} catch (e) {
				    throw new Error("Internal error");
				}
			} else {
			    checksum = md5Result.slice(0, 8);
			}

			return Buffer.concat([this.MAC_VERSION, checksum, seqBuf]);

        } else {
			throw new Error("Calculate mac Without Extended Session Security not yet implemented");
//			macWithoutExtendedSessionSecurity(seqNum, randomPad, sealingKey, message);
//			
//			
//			
//			
//			byte[] checksum = calculateCRC32(message);
//			try {
//			    /*byte[] randomPad = */sealingKey.doFinal(randomPadIn);
//			    checksum = sealingKey.doFinal(checksum);
//			    byte[] seqNum = sealingKey.doFinal(EMPTY_ARRAY);
//			    byte[] seqNumInArray = intToBytes(seqNumIn);
//			    for (int i = 0; i < seqNumInArray.length; i++) {
//			        seqNum[i] = (byte) (seqNum[i] ^ seqNumInArray[i]);
//			    }
//			    return concat(MAC_VERSION, EMPTY_ARRAY, checksum, seqNum);
//			} catch (Exception e) {
//			    throw new RuntimeException("Internal error", e);
//			}

        } 
    }
    
});

var NTLMMessage = helpers.defineClass(function(messageBody, expectedType) {
	if (messageBody != null && expectedType != null) {
		this.messageContents = new Buffer(messageBody, 'base64');
		if (this.messageContents.length < 13)
	        throw new Error("NTLM message decoding error - packet too short");
		
		var valid = new Buffer("4e544c4d53535000", 'hex');
		for (var i = 0; i < 8; i++) {
			if (this.messageContents[i] !== valid[i])
				throw new Error("NTLM message expected - instead got unrecognized bytes");
		}	
	
		var type = this.messageContents.readUInt32LE(8, 12);
		if (type !== expectedType)
	        throw new Error("NTLM type " + expectedType + " message expected - instead got type " + type);
	}
}, events.EventEmitter, {
    /** Read a security buffer from a position within the message buffer */
    readSecurityBuffer: function(index) {
        var length = this.messageContents.readUInt16LE(index);
        var offset = this.messageContents.readUInt32LE(index + 4);
        if (this.messageContents.length < offset + length)
            throw new Error("NTLM authentication - buffer too small for data item");
        return this.messageContents.slice(offset, offset + length);
    },

    parseAvFields: function(targetInfoBuf) {
		var id, fields = {}, j = 0;
		var AvId = [
			"MsvAvEOL", //0x0000: Indicates that this is the last AV_PAIR in the list. AvLen MUST be 0. This type of information MUST be present in the AV pair list.
			"MsvAvNbComputerName", //0x0001: The server's NetBIOS computer name. The name MUST be in Unicode, and is not null-terminated. This type of information MUST be present in the AV_pair list.
			"MsvAvNbDomainName", //0x0002: The server's NetBIOS domain name. The name MUST be in Unicode, and is not null-terminated. This type of information MUST be present in the AV_pair list.
			"MsvAvDnsComputerName", //0x0003: The fully qualified domain name (FQDN (1)) of the computer. The name MUST be in Unicode, and is not null-terminated.
			"MsvAvDnsDomainName", //0x0004: The FQDN (2) of the domain. The name MUST be in Unicode, and is not null-terminated.
			"MsvAvDnsTreeName", //0x0005: The FQDN (2) of the forest. The name MUST be in Unicode, and is not null-terminated.<11>
			"MsvAvFlags", //0x0006: A 32-bit value indicating server or client configuration.
								//0x00000001: indicates to the client that the account authentication is constrained.
								//0x00000002: indicates that the client is providing message integrity in the MIC field (section 2.2.1.3) in the AUTHENTICATE_MESSAGE.<12>
								//0x00000004: indicates that the client is providing a target SPN generated from an untrusted source.<13>
			"MsvAvTimestamp", //0x0007: A FILETIME structure ([MS-DTYP] section 2.3.1) in little-endian byte order that contains the server local time.<14>
			"MsvAvSingleHost", //0x0008: A Single_Host_Data (section 2.2.2.2) structure. The Value field contains a platform-specific blob, as well as a MachineID created at computer startup to identify the calling machine.<15>
			"MsvAvTargetName", //0x0009: The SPN of the target server. The name MUST be in Unicode and is not null-terminated.<16>
			"MsvChannelBindings"  //0x000A: A channel bindings hash. The Value field contains an MD5 hash ([RFC4121] section 4.1.1.2) of a gss_channel_bindings_struct ([RFC2744] section 3.11). An all-zero value of the hash is used to indicate absence of channel bindings.<17>
		];
		while ((id = targetInfoBuf.readUInt16LE(j)) !== 0) {
			j += 2;
			var len = targetInfoBuf.readUInt16LE(j);
			j += 2;
			var value = targetInfoBuf.slice(j, j + len);
			if (id <= 5 || id === 9) {
				value = value.toString('ucs2');
			}
			fields[AvId[id]] = value;
			j += len;
		}
		return fields;
    },
    
    /**
     * Prepares the object to create a response of the given length.
     *
     * @param maxlength
     *            the maximum length of the response to prepare, not
     *            including the type and the signature (which this method
     *            adds).
     */
    prepareResponse: function(maxlength, messageType) {
        this.messageContents = new Buffer(maxlength);
		// First 8 bytes: NTLMSSP[0]
		this.messageContents.write('NTLMSSP', 0, 7, 'ascii');
		this.messageContents.writeUInt8(0, 7);// '\0'
		// Next 4 bytes: Ulong
		this.messageContents.writeUInt32LE(messageType, 8);
    },
    
    /**
     * Returns the response that has been generated after shrinking the
     * array if required and base64 encodes the response.
     *
     * @return The response as above.
     */
	getResponse: function() {
		this.response = this.messageContents.toString('base64');
		this.emit('done');
	}
});

var Type1Message = helpers.defineClass(function(connectionType, domain, workstation) {
	NTLMMessage.call(this);
	this.connectionType = connectionType;
	this.negotiateFlags = connectionType === "connectionOriented" ? NEGOTIATE_FLAGS_CONN : NEGOTIATE_FLAGS_CONNLESS;

	try {
        // Strip off domain name from the host!
        var unqualifiedHost = convertHost(workstation);
        // Use only the base domain name!
        var unqualifiedDomain = convertDomain(domain);

        this.hostBytes = new Buffer(unqualifiedHost, "ascii");
        this.domainBytes = new Buffer(unqualifiedDomain.toUpperCase(), "ascii");
    } catch (e) {
        throw new Error("Unicode unsupported: " + e.message, e);
    }
	
}, NTLMMessage, {
	/**
	 * Getting the response involves building the message before returning
	 * it
	 */
	 getResponse: function() {
		if (this.connectionType === "connectionOriented") {
			// Now, build the message. Calculate its length first, including
	        // signature or type.
	        var finalLength = 32 + 8 /*+ hostBytes.length + domainBytes.length */;
	
	        // Set up the response. This will initialize the signature, message
	        // type, and flags.
	        this.prepareResponse(finalLength, 1);
	
	        // Flags. These are the complete set of flags we support.
			this.messageContents.writeUInt32LE(this.negotiateFlags, 12, true);
			
			// Domain length (two times).
			this.messageContents.writeUInt16LE(this.domainBytes.length, 16);
			this.messageContents.writeUInt16LE(this.domainBytes.length, 18);
			// Domain offset.
			this.messageContents.writeUInt32LE(32 + this.hostBytes.length, 20);
			
			// Host length (two times).
			this.messageContents.writeUInt16LE(this.hostBytes.length, 24);
			this.messageContents.writeUInt16LE(this.hostBytes.length, 26);
			// Host offset (always 32 + 8).
			this.messageContents.writeUInt32LE(32 + 8, 28);
			
			// Version
			this.messageContents.writeUInt16LE(0x0105, 32);
			// Build
			this.messageContents.writeUInt32LE(2600, 34);
			// NTLM revision
			this.messageContents.writeUInt16LE(0x0f00, 38);
			NTLMMessage.prototype.getResponse.call(this);
		} else {
			this.response = "";
			this.emit('done');
		}
	 },
});

var Type2Message = helpers.defineClass(function(message) {
	NTLMMessage.call(this, message, 2);
	
	// Type 2 message is laid out as follows:
    // First 8 bytes: NTLMSSP[0]
    // Next 4 bytes: Ulong, value 2
    // Next 8 bytes, starting at offset 12: target field (2 ushort lengths, 1 ulong offset)
    // Next 4 bytes, starting at offset 20: Flags, e.g. 0x22890235
    // Next 8 bytes, starting at offset 24: Challenge
    // Next 8 bytes, starting at offset 32: ??? (8 bytes of zeros)
    // Next 8 bytes, starting at offset 40: targetinfo field (2 ushort lengths, 1 ulong offset)
    // Next 2 bytes, major/minor version number (e.g. 0x05 0x02)
    // Next 8 bytes, build number
    // Next 2 bytes, protocol version number (e.g. 0x00 0x0f)
    // Next, various text fields, and a ushort of value 0 at the end

    // Parse out the rest of the info we need from the message
    // The challenge is the 8 bytes starting from the byte in position 24.
    this.challenge = this.messageContents.slice(24, 24 + 8);

    this.flags = this.messageContents.readUInt32LE(20);

    if ((this.flags & NTLMSSP_NEGOTIATE_UNICODE_FLAG) === 0)
        throw new Error("NTLM type 2 message has flags that make no sense: " + this.flags);

    // Do the target!
    this.target = null;
    // The TARGET_DESIRED flag is said to not have understood semantics
    // in Type2 messages, so use the length of the packet to decide
    // how to proceed instead
    if (this.messageContents.length >= 12 + 8) {
        var tnBuf = this.readSecurityBuffer(12);
        if (tnBuf.length !== 0) {
            try {
                this.target = tnBuf.toString('ucs2');
            } catch (e) {
                throw new Error(e.message, e);
            }
        }
    }

    // Do the target info!
    this.targetInfo = null;
    // TARGET_DESIRED flag cannot be relied on, so use packet length
    if (this.messageContents.length >= 40 + 8) {
        var tiBuf = this.readSecurityBuffer(40);
        if (tiBuf.length !== 0) {
            this.targetInfo = tiBuf;
        }
    }
}, NTLMMessage, {
	
});

var Type3Message = helpers.defineClass(function(connectionType, negociateMessage, challengeMessage, domain, host, user, password, clientChallenge, clientChallenge2, randomSessionKey, timestamp) {
	
	this.connectionType = connectionType;
	this.negociateMessage = negociateMessage;
	this.challengeMessage = challengeMessage;
	this.timestamp = timestamp;
	
	// Save the flags
    this.negotiateFlags = bitWiseOr([challengeMessage.flags, NTLMSSP_REQUEST_TARGET_FLAG]);

	if (this.negotiateFlags & NTLMSSP_NEGOTIATE_OEM_FLAG !== 0)
			this.negotiateFlags -= NTLMSSP_TARGET_TYPE_SERVER_FLAG;

	if ((this.negotiateFlags & NTLMSSP_NEGOTIATE_OEM_FLAG !== 0) && (this.negotiateFlags & NTLMSSP_NEGOTIATE_UNICODE_FLAG !== 0)) {
		this.negotiateFlags -= NTLMSSP_NEGOTIATE_OEM_FLAG;
	}

	if ((this.negotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY_FLAG !== 0) && (this.negotiateFlags & NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY_FLAG !== 0)) {
		this.negotiateFlags -= NTLMSSP_NEGOTIATE_LM_KEY_FLAG;
	}

    // Save Target information fields
    this.targetInfoFields = this.parseAvFields(challengeMessage.targetInfo);
    //console.log("Target info fields: "+JSON.stringify(this.targetInfoFields,null,2));
    
    // Strip off domain name from the host!
    var unqualifiedHost = convertHost(host);
    // Use only the base domain name!
    var unqualifiedDomain = convertDomain(domain);
    
    try {
        this.domainBytes = new Buffer(unqualifiedDomain.toUpperCase(), 'ucs2');
        this.hostBytes = new Buffer(unqualifiedHost, 'ucs2');
        this.userBytes = new Buffer(user, 'ucs2');
    } catch (e) {
        throw new Error("Unicode not supported: " + e.message, e);
    }
    
	if (this.targetInfoFields.MsvAvTimestamp) {
		this.timestamp = this.targetInfoFields.MsvAvTimestamp;
	}
	if (this.targetInfoFields.MsvAvFlags) {
		// TODO: Set MsAvFlags in TargetInfo
	}

    // Create a cipher generator class.  Use domain BEFORE it gets modified!
    this.gen = new CipherGen(unqualifiedDomain, user, password, challengeMessage.challenge, challengeMessage.target, challengeMessage.targetInfo, clientChallenge, clientChallenge2, randomSessionKey, this.timestamp);
    
    try {
        // This conditional may not work on Windows Server 2008 R2 and above, where it has not yet
        // been tested
        if (((this.negotiateFlags & NTLMSSP_NEGOTIATE_TARGET_INFO_FLAG) !== 0) && challengeMessage.targetInfo != null && challengeMessage.target != null) {
			// NTLMv2
			this.ntResp = this.gen.getNTLMv2Response();
			this.lmResp = this.gen.getLMv2Response();
			if ((this.negotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY_FLAG) !== 0) {
			    this.userSessionKey = this.gen.getLanManagerSessionKey();
			} else {
			    this.userSessionKey = this.gen.getNTLMv2UserSessionKey();
			}
        } else {
			// NTLMv1
			if ((this.negotiateFlags & NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY_FLAG) !== 0) {
			    // NTLM2 session stuff is requested
				this.ntResp = this.gen.getNTLM2SessionResponse();
				this.lmResp = this.gen.getLM2SessionResponse();
			    if ((this.negotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY_FLAG) !== 0) {
			        this.userSessionKey = this.gen.getLanManagerSessionKey();
			    } else {
			        this.userSessionKey = this.gen.getNTLM2SessionResponseUserSessionKey();
			    }
			} else {
				this.ntResp = this.gen.getNTLMResponse();
				this.lmResp = this.gen.getLMResponse();
			    if ((this.negotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY_FLAG) !== 0) {
			        this.userSessionKey = this.gen.getLanManagerSessionKey();
			    } else {
			        this.userSessionKey = this.gen.getNTLMUserSessionKey();
			    }
			}
        }
    } catch (e) {
		console.error(e.stack);
		// This likely means we couldn't find the MD4 hash algorithm -
		// fail back to just using LM
		this.ntResp = new Buffer(0);
		this.lmResp = this.gen.getLMResponse();
		if ((this.negotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY_FLAG) !== 0) {
		    this.userSessionKey = this.gen.getLanManagerSessionKey();
		} else {
		    this.userSessionKey = this.gen.getLMUserSessionKey();
		}
    }

    if ((this.negotiateFlags & NTLMSSP_NEGOTIATE_SIGN_FLAG) !== 0) {
		if ((this.negotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH_FLAG) !== 0) {
			this.sessionKey = this.gen.getEncryptedSessionKey(this.userSessionKey);
		} else {
			this.sessionKey = this.userSessionKey || null;
		}
	} 
    else {
		this.sessionKey = null;
    }
    
    this.clientSigningKey = this.gen.signkey(this.negotiateFlags, "client");
    this.serverSigningKey = this.gen.signkey(this.negotiateFlags, "server");
    this.clientSealingKey = this.gen.sealkey(this.negotiateFlags, "client");
    this.serverSealingKey = this.gen.sealkey(this.negotiateFlags, "server");

}, NTLMMessage, {
	
    calculateMac: function(message) {
		if (!this.seqNum) this.seqNum = 0;
		var mac = this.gen.mac(this.negotiateFlags, this.seqNum, this.clientSigningKey, this.clientSealingKey, new Buffer(4), message);
		if (this.connectionType === "connectionOriented") {
		    this.seqNum++;
		}
		return mac;
    },
    
    getResponse: function() {
        var ntRespLen = this.ntResp.length;
        var lmRespLen = this.lmResp.length;

        var domainLen = this.domainBytes.length;
        var hostLen = this.hostBytes.length;
        var userLen = this.userBytes.length;
        var sessionKeyLen;
        if (this.sessionKey != null)
            sessionKeyLen = this.sessionKey.length;
        else
            sessionKeyLen = 0;

        // Calculate the layout within the packet
        var domainOffset = 72 + 24;// allocate space for version and mic
        var userOffset = domainOffset + domainLen;
        var hostOffset = userOffset + userLen;
        var lmRespOffset = hostOffset + hostLen;  
        var ntRespOffset = lmRespOffset + lmRespLen;
        var sessionKeyOffset = ntRespOffset + ntRespLen;
        var finalLength = sessionKeyOffset + sessionKeyLen;

        // Start the response. Length includes signature and type
        this.prepareResponse(finalLength, 3);

        /*
        2.2.1.3 AUTHENTICATE_MESSAGE
        */
        // LM Resp Length (twice)
        this.messageContents.writeUInt16LE(lmRespLen, 12);
        this.messageContents.writeUInt16LE(lmRespLen, 14);
        // LM Resp Offset
        this.messageContents.writeUInt32LE(lmRespOffset, 16);

        // NT Resp Length (twice)
        this.messageContents.writeUInt16LE(ntRespLen, 20);
        this.messageContents.writeUInt16LE(ntRespLen, 22);
        // NT Resp Offset
        this.messageContents.writeUInt32LE(ntRespOffset, 24);
        
        // Domain length (twice)
        this.messageContents.writeUInt16LE(domainLen, 28);
        this.messageContents.writeUInt16LE(domainLen, 30);
        // Domain offset.
        this.messageContents.writeUInt32LE(domainOffset, 32);      
        
        // User Length (twice)
        this.messageContents.writeUInt16LE(userLen, 36);
        this.messageContents.writeUInt16LE(userLen, 38);
        // User offset
        this.messageContents.writeUInt32LE(userOffset, 40);

        // Host length (twice)
        this.messageContents.writeUInt16LE(hostLen, 44);
        this.messageContents.writeUInt16LE(hostLen, 46);
        // Host offset
        this.messageContents.writeUInt32LE(hostOffset, 48);

        // Session key length (twice)
        this.messageContents.writeUInt16LE(sessionKeyLen, 52);
        this.messageContents.writeUInt16LE(sessionKeyLen, 54);
        // Session key offset
        this.messageContents.writeUInt32LE(sessionKeyOffset, 56);

        // Flags
        this.messageContents.writeUInt32LE(this.negotiateFlags, 60, true);

        // TODO: Compute real version and MIC
        // Version
        /*
        A VERSION structure (section 2.2.2.10) that is present only when the
        NTLMSSP_NEGOTIATE_VERSION flag is set in the NegotiateFlags field. This structure is used
        for debugging purposes only. In normal protocol messages, it is ignored and does not affect
        the NTLM message processing.<9>

         <9> Section 2.2.1.3: The Version field is NOT sent or consumed by Windows NT or Windows 2000.
        Windows NT and Windows 2000 assume that the Payload field started immediately after
        NegotiateFlags. Since all references into the Payload field are by offset from the start of the
        message (not from the start of the Payload field), Windows NT and Windows 2000 can correctly
        interpret messages constructed with Version fields
               
         */
		if (windowsVersions.indexOf(this.windowsVersion) >= windowsVersions.indexOf("0501280A0000000F") && (this.negotiateFlags & NTLMSSP_NEGOTIATE_VERSION_FLAG) !== 0) {
			this.messageContents.write(this.windowsVersion, 66, 8, "hex");
		} else {
			this.messageContents.write("0000000000000000", 66, 8, "hex");
		}

        // MIC
        /*
        The message integrity for the NTLM NEGOTIATE_MESSAGE,
        CHALLENGE_MESSAGE, and AUTHENTICATE_MESSAGE.<10>

        <10> Section 2.2.1.3: The MIC field is omitted in Windows NT, Windows 2000, Windows XP, and
        Windows Server 2003.

        3.1.5.1.2 Set MIC to HMAC_MD5(ExportedSessionKey, ConcatenationOf(NEGOTIATE_MESSAGE, CHALLENGE_MESSAGE, AUTHENTICATE_MESSAGE))
        Set AUTHENTICATE_MESSAGE.MIC to MIC
        */
        if (windowsVersions.indexOf(this.windowsVersion) >= windowsVersions.indexOf("060072170000000F")) {
            var data, hmac = crypto.createHmac('md5', this.sessionKey);
			if (this.connectionType === "connectionOriented") {
				data = Buffer.concat([this.negotiateMessage.messageContents, this.challengeMessage.messageContents, this.messageContents]);
			} else {
				data = Buffer.concat([this.challengeMessage.messageContents, this.messageContents]);
			}
            var mic = hmac.update(data).digest('hex');
            this.messageContents.write(mic, 76, 16, "hex");
		} else {
			this.messageContents.write("00000000000000000000000000000000", 74, 16, "hex");
		}
        // Add payload
        this.messageContents.write(this.lmResp.toString('hex'), lmRespOffset, lmRespLen, "hex");
        this.messageContents.write(this.ntResp.toString('hex'), ntRespOffset, ntRespLen, "hex");
        this.messageContents.write(this.domainBytes.toString('hex'), domainOffset, domainLen, "hex");
        this.messageContents.write(this.userBytes.toString('hex'), userOffset, userLen, "hex");
        this.messageContents.write(this.hostBytes.toString('hex'), hostOffset, hostLen, "hex");

		if (this.sessionKey != null)
			 this.messageContents.write(this.sessionKey.toString('hex'), sessionKeyOffset, sessionKeyLen, "hex");

        return NTLMMessage.prototype.getResponse.call(this);
    }

});

/**
 * Creates the first message (type 1 message) in the NTLM authentication
 * sequence. This message includes the user name, domain and host for the
 * authentication session.
 *
 * @param host
 *            the computer name of the host requesting authentication.
 * @param domain
 *            The domain to authenticate with.
 * @return String the message to add to the HTTP request header.
 */
var getType1Message = function(connectionType, domain, workstation) {
    return new Type1Message(connectionType, domain, workstation);
};

/**
 * Creates the type 3 message using the given server challenge. The type 3
 * message includes all the information for authentication, host, domain,
 * username and the result of encrypting the challenge sent by the server using
 * the user's password as the key.
 *
 * @param user
 *            The user name. This should not include the domain name.
 * @param password
 *            The password.
 * @param host
 *            The host that is originating the authentication request.
 * @param domain
 *            The domain to authenticate within.
 * @param challenge
 *            the 8 byte array the server sent.
 * @return The type 3 message.
 * @throws NTLMEngineException
 *             If {@encrypt(byte[],byte[])} fails.
 */
var getType3Message = function(connectionType, negociateMessage, challengeMessage, user, password, host, domain, challenge, negotiateFlags, target, targetInformation, clientChallenge, clientChallenge2, randomSessionKey, timestamp) {
    return new Type3Message(connectionType, negociateMessage, challengeMessage, domain, host, user, password, challenge, negotiateFlags, target, targetInformation, clientChallenge, clientChallenge2, randomSessionKey, timestamp);
};

exports.generateNegociateMessage = function(connectionType, domain, workstation) {
    return getType1Message(connectionType, domain, workstation);
};

exports.generateAuthenticateMessage = function(connectionType, negociateMessage, username, password, domain, workstation, message, clientChallenge, clientChallenge2, randomSessionKey, timestamp) {
    var challengeMessage = new Type2Message(message);
    return getType3Message(connectionType, negociateMessage, challengeMessage, username, password, workstation, domain, clientChallenge, clientChallenge2, randomSessionKey, timestamp);
};