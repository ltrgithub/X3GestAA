"use strict";

var helpers = require('syracuse-core/lib/helpers');
var crypto = require('crypto');

var PARITY = [];

for (var i = 0; i < 256; i++) {
	var sum = 0;
	for (var j = 0; j < 8; j++) sum += (i >> j) & 1;
	PARITY[i] = sum % 2 ?  i : i ^ 1 ;
}

/**
 * Creates the LM Hash of the user's password.
 * This is a 32-bit hexadecimal sequence that represents the password clients will use.
 * It is derived by encrypting the string  KGS!@#$% with a 56-bit DES algorithm using
 * the user's password (forced to 14 bytes and converted to capital letters) twice
 * repeated as the key.
 * 
 * @param password The password.
 *
 * @return The LM Hash of the given password, used in the calculation
 * of the LM Response.
 */
var lmHash = function(password){
	var magic = 'KGS!@#$%';
	var lm_pw = new Buffer(14);
	for (var i = 0 ; i < 14 ; i++){
		lm_pw[i] = password[i] ? password.toUpperCase().charCodeAt(i) : 0x00 ;
	}

  var ks = setup_des_key(lm_pw.slice(0,7));
  var lm_hpw = des_encrypt(magic, ks);
  ks = setup_des_key(lm_pw.slice(7));
  lm_hpw += des_encrypt(magic, ks);
  return new Buffer(lm_hpw, 'hex');
};

/// ## ntlmHash
/// ``` javascript
/// var lmHash = helpers.ntlmHash(password);  
/// ```
/// Creates the NTLM Hash of the user's password.
/// This is a 32-bit hexadecimal sequence that represents the password Windows NT clients
/// will use. It is derived by hashing the user's password (represented as a 16-bit little-endian
/// Unicode sequence) with an MD4 hash. The password is not converted to uppercase letters first.
///
/// @param password The password.
///
/// @return The NTLM Hash of the given password, used in the calculation
/// of the NTLM Response and the NTLMv2 and LMv2 Hashes.
///
var ntlmHash = function(password){
	var digest = crypto.createHash('md4').update(new Buffer(password,'ucs2')).digest("hex");
	return new Buffer(digest, 'hex');
};

/// ## ntlmv2Hash
/// ``` javascript
/// var lmHash = helpers.ntlmv2Hash(target, user, password);  
/// ```
/// Creates the NTLMv2 Hash of the user's password.
///
/// @param target The authentication target (i.e., domain).
/// @param user The username.
/// @param password The password.
///
/// @return The NTLMv2 Hash, used in the calculation of the NTLMv2
/// and LMv2 Responses. 
///
var ntlmv2Hash = function(target, user, password){
	var _ntlmHash = ntlmHash(password);
	var identity = user.toUpperCase() + target;
	return crypto.createHmac('md5', _ntlmHash).update(new Buffer(identity,'ucs2')).digest("hex");
};

/**
 * Creates the LM Response from the given hash and Type 2 challenge.
 *
 * @param hash The LM or NTLM Hash.
 * @param challenge The server challenge from the Type 2 message.
 *
 * @return The response (either LM or NTLM, depending on the provided
 * hash).
 */
var lmResponse = function(hash, challenge) {
	function padHash(buf){
		var newBuf = new Buffer(21);
		buf.copy(newBuf);
		for (var i = 16 ; i < 21 ; i++){
			newBuf[i] = 0x00 ;
		}
		return newBuf;
	}
	
	var keys = padHash(hash);
    var ks = setup_des_key(keys.slice(0,7));
    var resp = des_encrypt(challenge, ks);

    ks = setup_des_key(keys.slice(7,14));
    resp += des_encrypt(challenge, ks);
    
    ks = setup_des_key(keys.slice(14));
    resp += des_encrypt(challenge, ks);
    
    return new Buffer(resp, 'hex');
};

/**
 * Creates the LMv2 Response from the given hash, client data, and
 * Type 2 challenge.
 *
 * @param hash The NTLMv2 Hash.
 * @param clientData The client data (blob or client nonce).
 * @param challenge The server challenge from the Type 2 message.
 *
 * @return The response (either NTLMv2 or LMv2, depending on the
 * client data).
 */
var lmv2Response = function(hash, clientData, challenge) {
    var data = Buffer.concat([challenge, clientData], challenge.length + clientData.length);
    var mac =  crypto.createHmac('md5', hash).update(data).digest("hex");
    return Buffer.concat([mac, clientData], mac.length + clientData.length);
};

/**
 * Creates the NTLMv2 blob from the given target information block and
 * client nonce.
 *
 * @param targetInformation The target information block from the Type 2
 * message.
 * @param clientNonce The random 8-byte client nonce.
 *
 * @return Buffer The blob, used in the calculation of the NTLMv2 Response.
 */
var createBlob = function(targetInformation, clientNonce) {
    var blobSignature = new Buffer([0x01, 0x01, 0x00, 0x00]);
    var reserved = new Buffer([0x00, 0x00, 0x00, 0x00]);
    var unknown1 = new Buffer([0x00, 0x00, 0x00, 0x00]);
    var unknown2 = new Buffer([0x00, 0x00, 0x00, 0x00]);
    var time = new Date().getMilliseconds(); 
    // milliseconds from January 1, 1601 -> epoch.
    time += 11644473600000l;
    time *= 10000; // tenths of a microsecond.
    // convert to little-endian byte array.
    var timestamp = new Buffer(8);
    for (var i = 0; i < 8; i++) {
        timestamp[i] = time;
        time >>>= 8;
    }
    var blobLen = blobSignature.length + reserved.length + timestamp.length + clientNonce.length + unknown1.length + targetInformation.length + unknown2.length;
    return Buffer.concat([blobSignature, reserved, timestamp, clientNonce, unknown1, targetInformation, unknown2], blobLen);
};

/*
 * turns a 56 bit key into the 64 bit, odd parity key and sets the key.
 * The key schedule ks is also set.
 */
var setup_des_key = function(key_56)
{
	function odd_parity(key){
		for (var i = 0; i < 8; i++){
			key[i] = PARITY[key[i]];
		}
	}
    var key = new Buffer(8);
	key[0] = key_56[0];
	key[1] = ((key_56[0] << 7) & 0xff) | (key_56[1] >> 1);
	key[2] = ((key_56[1] << 6) & 0xff) | (key_56[2] >> 2);
	key[3] = ((key_56[2] << 5) & 0xff) | (key_56[3] >> 3);
	key[4] = ((key_56[3] << 4) & 0xff) | (key_56[4] >> 4);
	key[5] = ((key_56[4] << 3) & 0xff) | (key_56[5] >> 5);
	key[6] = ((key_56[5] << 2) & 0xff) | (key_56[6] >> 6);
	key[7] = (key_56[6] << 1) & 0xff;
	odd_parity(key);
    return key;
};

/**
 * Creates a DES encryption key from the given key material.
 *
 * @param str Data to encrypt.
 * @param key The key to use for the encryption.
 *
 * @return Encrypted data.
 */
var des_encrypt = function(str, key){
    var iv = new Buffer(8);
    for (var i = 0 ; i < 8 ; i++) iv[i] = 0x00;
	var tokencrypt = crypto.createCipheriv('des-cbc', new Buffer(key, 'hex'), iv);
	var token = tokencrypt.update(str, 'ascii', 'hex');
	tokencrypt.final('hex');
	return token;
};

exports.Responses = helpers.defineClass(function() {}, null, {
    /**
     * Calculates the LM Response for the given challenge, using the specified
     * password.
     *
     * @param password The user's password.
     * @param challenge The Type 2 challenge from the server.
     *
     * @return The LM Response.
     */
    getLMResponse: function(password, challenge) {
        var _lmHash = lmHash(password);
        return lmResponse(_lmHash, challenge);
    },

    /**
     * Calculates the NTLM Response for the given challenge, using the
     * specified password.
     *
     * @param password The user's password.
     * @param challenge The Type 2 challenge from the server.
     *
     * @return The NTLM Response.
     */
    getNTLMResponse: function(password, challenge) {
        var _ntlmHash = ntlmHash(password);
        return lmResponse(_ntlmHash, challenge);
    },

    /**
     * Calculates the NTLMv2 Response for the given challenge, using the
     * specified authentication target, username, password, target information
     * block, and client nonce.
     *
     * @param target The authentication target (i.e., domain).
     * @param user The username. 
     * @param password The user's password.
     * @param targetInformation The target information block from the Type 2
     * message.
     * @param challenge The Type 2 challenge from the server.
     * @param clientNonce The random 8-byte client nonce. 
     *
     * @return The NTLMv2 Response.
     */
    getNTLMv2Response: function(target, user, password, targetInformation, challenge, clientNonce) {
        var _ntlmv2Hash = ntlmv2Hash(target, user, password);
        var blob = createBlob(targetInformation, clientNonce);
        return lmv2Response(_ntlmv2Hash, blob, challenge);
    },

    /**
     * Calculates the LMv2 Response for the given challenge, using the
     * specified authentication target, username, password, and client
     * challenge.
     *
     * @param target The authentication target (i.e., domain).
     * @param user The username.
     * @param password The user's password.
     * @param challenge The Type 2 challenge from the server.
     * @param clientNonce The random 8-byte client nonce.
     *
     * @return The LMv2 Response. 
     */
    getLMv2Response: function(target, user, password, challenge, clientNonce) {
        var _ntlmv2Hash = ntlmv2Hash(target, user, password);
        return lmv2Response(_ntlmv2Hash, clientNonce, challenge);
    },

    /**
     * Calculates the NTLM2 Session Response for the given challenge, using the
     * specified password and client nonce.
     *
     * @param password The user's password.
     * @param challenge The Type 2 challenge from the server.
     * @param clientNonce The random 8-byte client nonce.
     *
     * @return The NTLM2 Session Response.  This is placed in the NTLM
     * response field of the Type 3 message; the LM response field contains
     * the client nonce, null-padded to 24 bytes.
     */
    getNTLM2SessionResponse: function(password, challenge, clientNonce) {
        var _ntlmHash = ntlmHash(password);
        var md5 = crypto.createHmac('md5', _ntlmHash);  
        md5.update(challenge);
        md5.update(clientNonce);
        //TODO Check this part
        var digest = new Buffer(md5.digest("hex"), 'hex');
        var sessionHash = digest.slice(0, 7);
        return lmResponse(_ntlmHash, sessionHash);
    }
});