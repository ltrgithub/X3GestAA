"use strict";

var trace;

function deepClone(o) {
	return Object.keys(o).reduce(function(r, k) {
		var v = o[k];
		if (Array.isArray(v)) v = v.map(deepClone);
		else if (typeof v === 'object' && v) v = deepClone(v);
		r[k] = v;
		return r;
	}, {});
}

function shallowClone(o) {
	return Object.keys(o).reduce(function(r, k) {
		r[k] = o[k];
		return r;
	}, {});
}

exports.canon = function(root, options) {
	options = options || {};
	// namespaces gives mapping from URL to the $xxx JSON node
	var namespaces = options.namespaces ? deepClone(options.namespaces) : {};
	// nsindex is used to generate $i node names for namespaces that don't have a prefix
	var nsindex = 0;

	// map gives the mapping from xml ns prefixes to JSON nodes (changes as we walk the tree)

	function canon1(obj, prop, index, curNs, $meta, map, result) {
		var p = index == null ? prop : index;
		var val = obj[p];
		var dst = result;
		var remain;
		if (typeof val === 'object' && val != null) {
			var nmap;
			remain = [];
			val.$ && Object.keys(val.$).forEach(function(key) {
				var pair = key.split(':');
				if (pair[0] === 'xmlns') {
					nmap = nmap || shallowClone(map);
					var url = val.$[key];
					var ns = namespaces[url];
					if (!ns) {
						trace && trace("unknown namespace: " + url);
						ns = (namespaces[url] = {
							$prefix: '$' + ++nsindex
						});
					}
					if (!ns.$prefix) {
						trace && trace("missing prefix in namespace: " + url);
						ns.$prefix = '$' + ++nsindex;
					}
					nmap[pair[1] || ''] = ns;
					if (pair[1]) ns.$sourcePrefix = ns.$sourcePrefix || pair[1]; // will be undefined if no prefix given
				} else {
					remain.push(key);
				}
			});
			map = nmap || map;
		}
		var propNs, $prop;
		if (index != null) {
			propNs = curNs;
			$prop = $meta;
		} else {
			var pair = prop.split(':');
			if (pair.length > 1) {
				propNs = map[pair[0]];
				prop = pair[1];
				p = prop;
			} else {
				propNs = prop[0] === '$' ? curNs : map[''];
			}
			if (propNs == null) throw new Error("invalid namespace prefix: " + prop);

			propNs.$properties = propNs.$properties || {};
			if (propNs !== curNs) {
				$prop = (propNs.$properties[prop] = propNs.$properties[prop] || {});
				dst = (result[propNs.$prefix] = result[propNs.$prefix] || {});
			} else {
				$prop = ($meta[prop] = $meta[prop] || {});
			}
		}

		if (Array.isArray(val)) {
			$prop.$type = "application/x-array";
			$prop.$item = {};

			dst = (dst[p] = []);
			val.forEach(function(v, i) {
				canon1(val, prop, i, propNs, $prop.$item, map, dst);
			});
		} else if (typeof val === 'object' && val != null) {
			if ($prop !== propNs.$properties[prop]) {
				$prop.$type = "application/json";
				$prop.$prototype = prop;
			}

			var $elt = (propNs.$properties[prop] = propNs.$properties[prop] || {});
			var $props = ($elt.$properties = $elt.$properties || {});

			dst = (dst[p] = {});
			remain.forEach(function(key) {
				var d = dst,
					v = val.$[key];
				var pair = key.split(':');
				var $pps = $props;
				if (pair.length > 1) {
					var ns = map[pair[0]];
					if (ns == null) throw new Error("invalid namespace prefix: " + pair[0]);
					if (ns !== curNs) {
						d = (dst[ns.$prefix] = dst[ns.$prefix] || {});
						ns.$properties = ns.$properties || {};
						$pps = ns.$properties;
					}
					key = pair[1];
				};
				//(d.$ = d.$ || {})[key] = v;
				d[key] = v;
				$pps[key] = $pps[key] || {
					$type: "application/x-string",
					$xmlAtb: true
				};
			});
			Object.keys(val).forEach(function(key) {
				if (key !== '$') {
					/*if (key[0] === '$') dst[key] = val[key];
					else*/
					canon1(val, key, null, propNs, $props, map, dst);
				}
			});
		} else {
			$prop.$type = "application/x-string";
			dst[p] = val;
		}
	}

	var result = {};
	canon1({
		root: root
	}, 'root', null, {
		$prefix: ''
	}, {}, {
		'': {
			$prefix: '$0'
		}
	}, result);
	if (Object.keys(namespaces).length > 0) result.$0.root.$xmlns = namespaces;
	return result.$0.root;
};