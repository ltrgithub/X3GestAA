"use strict";

var locale = require('streamline-locale');
var adminHelpers = require('syracuse-collaboration/lib/helpers');
var crypto = require('crypto');
var check = require('syracuse-license/lib/check');
var globals = require('streamline-runtime').globals;
var config = require('config');
var authHelper = require("syracuse-auth/lib/helpers");

exports.checkUserLogin = function(_, session, login) {
	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
	// fetch user
	var user = db.fetchInstance(_, db.model.getEntity(_, "user"), {
		jsonWhere: {
			login: login,
			active: true
		}
	});
	if (!user) throw authHelper.unauthorized();

	// License check
	var p = user.preferences(_);
	// TODO: review this: why do we return ok if p is null?
	if (p) {
		// find out badges for current user
		var role = p.lastRole(_);
		var diagnoses = [];
		if (role && !check.checkConcurrent(_, session, role, user.login(_), session.device, diagnoses)) {
			throw authHelper.accessDenied("noLicense", user);
		}
		// force user locales: hack request accept-language header
		var l = p.lastLocaleCode(_); // check if locale exists
		if (globals.context && globals.context.request && l && user.getUserLocaleByCode(_, l)) globals.context.request.headers["accept-language"] = l;
	}
	session.setData("userID", user.$uuid);
	session.setData("userLogin", user.login(_));
};

exports.fromCertificate = function(_, session, login) {
	return exports.checkUserLogin(_, session, login);
};

/** check user (and password) for different authentication methods. User name must be in user table
 * parameters:
 * request: current request (request.session will receive data of current user in case of success
 * method: authentication method (basic, digest, oauth2...)
 * login: login user name
 * password: password of user (from basic authentication), or function to check the password
 * serverName: additional server name for oauth2
 */

exports.fromLoginPage = function(_, request, method, login, password, challenge, serverName) {
	var session = request.session;
	var standardSetting = authHelper.getStandardSetting(_);
	var user = null;
	var realm = config.session.realm;

	// fetch user in database
	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
	var condition = {};
	if (login.indexOf('@') > 0 && (!config.session || !config.session.authAlwaysLogin)) {
		condition.sdataWhere = 'active eq true and (email like "' + login + '" or ((email eq null or email eq "") and (login eq "' + login + '")))';
		if (method !== "basic") condition.sdataWhere += ' and (authentication eq "' + method + '")';
	} else {
		condition.jsonWhere = {
			login: login,
			active: true
		};
		if (method !== "basic") condition.jsonWhere.authentication = method;
	}
	var users = db.fetchInstances(_, db.model.getEntity(_, "user"), condition);

	// if no user, we are done
	if (users.length == 0) {
		if (method === 'oauth2' || method === 'saml2') {
			console.log("Login name not found " + login);
			throw new Error(locale.format(module, "notFound", login));
		} else {
			if (method === 'sage-id')
				require("sage-id").create(require("syracuse-auth/lib/sage-id").getSageIdOptions(request)).logout(request, null, session, _);
			throw authHelper.unauthorized(challenge);
		}
	}

	// if several users match, reject except if admin is in the list - keep it.
	if (users && users.length > 1) {
		users = users.filter_(_, function(_, u) {
			return u.login(_) === 'admin';
		});
		if (users.length != 1) throw authHelper.accessDenied("ambiguousUser");
	}
	var user = users[0];

	// check that user is active (should be already filtered out above)
	if (!user.active(_)) throw authHelper.accessDenied("inactiveUser", user);

	// get auth configuration for this user
	var userAuthentication = user.authentication(_) || "";
	var localConfig = {
		method: userAuthentication,
	};
	// console.log("User auth "+user.login(_)+" "+" "+user.email(_)+" "+userAuthentication)
	// combine user-level and global authentication settings
	switch (userAuthentication) {
		case "":
			localConfig = standardSetting;
			break;
		case "db":
			localConfig.method = authHelper.getDbMethod();
			localConfig.source = "db";
			break;
		case "ldap":
			localConfig.ldap = user.ldap(_)._data;
			localConfig.ldap.tlsOptions = user.ldap(_).getTlsOptions(_);
			break;
		case "oauth2":
			localConfig.oauth2 = user.oauth2(_)._data;
			break;
		case "saml2":
			localConfig.saml2 = user.saml2(_)._data;
			break;
		case "sage-id":
			break;
		default:
			throw new Error("bad user authentication method: " + userAuthentication);
	}
	if (!localConfig.source) localConfig.source = localConfig.method;

	// check that we used the right method
	// console.log("Test "+localConfig.method +" "+ method)
	if (localConfig.method !== method && localConfig.method !== "ldap" && method !== "basic") {
		throw authHelper.accessDenied("wrongAuth", user, method);
	}

	// Verify the password
	switch (localConfig.source) {
		case "db":
			if (typeof password === "function") {
				if (!password(user.password(_))) throw authHelper.unauthorized(challenge);
			} else {
				// compute hash of password using user name from user entity
				// apply hash function from RFC2617
				var hash = crypto.createHash('MD5');
				var pwd = user.password(_);
				var pwd0 = pwd;
				var a1 = user.login(_) + ":" + config.session.realm + ":" + password;
				if (pwd[0] === "U") { // hash has been obtained using UTF8 representation (new)
					pwd = pwd.substr(1);
					hash.update(a1, 'utf8');
				} else
					hash.update(a1, 'binary');
				if (hash.digest("hex") !== pwd) throw authHelper.unauthorized(challenge);
				if (pwd0[0] !== "U" && !db.hasDatabaseLock(_)) {
					// update the password to new mode
					var hash = crypto.createHash('MD5');
					hash.update(a1, 'utf8');
					user.password(_, "U" + hash.digest("hex"));
					user.save(_);
					var diags = [];
					user.getAllDiagnoses(_, diags, {
						addPropName: true
					});
					console.log("Update user password of " + user.login(_));
					if (diags.some(function(diag) {
						return diag.$severity === "error";
					})) {
						console.error("Cannot update password format for user " + user.login(_) + ": " + JSON.stringify(diags));
					}
				}
			}
			break;
		case "ldap":
			var ldapName = user.authenticationName(_) || user.login(_);
			if (!localConfig.ldap.active) { // server inactive: no authentication
				console.log("LDAP server inactive");
				throw authHelper.unauthorized(challenge);
			} else {
				var ldapauth = require("syracuse-ldap").ldapauth;
				try {
					ldapauth.ldapAuthentication(_, ldapName, password, localConfig.ldap);
				} catch (e) {
					console.log("LDAP Authentication error: " + e.toString());
					throw authHelper.unauthorized(challenge);
				}
			}
			break;
		case "oauth2":
			if (serverName !== localConfig.oauth2.name) throw authHelper.accessDenied("wrongAuth", user, serverName);
			break;
		case "saml2":
			if (serverName !== localConfig.saml2.name) throw authHelper.accessDenied("wrongAuth", user, serverName);
			break;
		case "sage-id":
			// TODO: extra check on server name
			break;
		default:
			throw new Error("internal error: bad auth source " + localConfig.source);
	}

	var diagnoses = [];

	// check role
	var groups = user.groups(_).toArray(_);
	if (!groups.length) throw authHelper.accessDenied("noGroup", user);
	var p = user.preferences(_);
	var role;
	// do not force accept-language for web services
	if (p && request.url.indexOf("/soap-") === -1) {
		// force user locales: hack request accept-language header
		var l = p.lastLocaleCode(_);
		// check if locale exists
		if (globals.context && globals.context.request && l && user.getUserLocaleByCode(_, l)) globals.context.request.headers["accept-language"] = l;
		// take last role from user preferences
		role = p.lastRole(_);
	}
	var role2 = role;
	if (role) {
		// test whether role is in current groups
		for (var j = 0; j < groups.length; j++) {
			var group = groups[j];
			role = group.role(_);
			if (role && role.$uuid === role2.$uuid) break; // role found
			role = null;
		}
	}
	// no role from user preferences - take role from groups
	if (!role) {
		if (!groups.length) throw authHelper.accessDenied("noGroup", user);
		for (var j = 0; j < groups.length; j++) {
			var group = groups[j];
			role = group.role(_);
			if (role) break; // role found
		}
	}
	if (!role) {
		throw authHelper.accessDenied("noRole", user);
	}
	if (role && !check.checkConcurrent(_, session, role, login, session.device, diagnoses, true)) { // try to find new session
		throw authHelper.accessDenied("noLicense", user);
	}

	// user is valid
	session.setData("userID", user.$uuid);
	session.setData("userLogin", login);
	// TODO: show diagnoses!!!! The code below does not work
	var up = session.getUserProfile(_);
	if (up) {
		diagnoses.forEach(function(diag) {
			up.$addDiagnose(diag.$severity, diag.$message);
		});
	}
	return user;
};