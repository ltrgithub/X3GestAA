"use strict";

var config = require('config');
var locale = require('syracuse-core/lib/locale');
var helpers = require('syracuse-core/lib/helpers');
var fs = require('streamline-fs');
var sessionManager = require('syracuse-session/lib/sessionManager').sessionManager;
var httpHelper = require('syracuse-sdata/lib/httpHelper');
// caching standard settings for 1 second
var standardCache;
var globals = require('streamline/lib/globals');
var cacheAccess = 0;
var multiTenant = config.hosting && config.hosting.multiTenant;

var authMethods = (config.session && config.session.auth) || "basic";
if (!Array.isArray(authMethods)) authMethods = [authMethods];

var dbMethods = authMethods.filter(function(method) {
	return /^(basic|digest)$/.test(method);
});
if (dbMethods.length > 1) throw new Error("configuration error: session.auth cannot contain both basic and digest");
var dbMethod = dbMethods[0];

exports.isAllowed = function(method) {
	return authMethods.indexOf(method) >= 0;
};

exports.getDbMethod = function() {
	if (!dbMethod) throw new Error("configuration error: no default for database authentication");
	return dbMethod;
};

exports.getAuthModule = function(name) {
	if (authMethods.indexOf(name) < 0) return null;
	return require('syracuse-auth/lib/' + name);
};

// returns the enum of allowed auth values for global setting (glob === true) or user (glob === false)
exports.authEnum = function(glob) {
	var result = [];
	if (glob) {
		if (authMethods.indexOf('basic') >= 0) result.push({
			$value: "basic",
			$title: "Basic"
		});
		if (authMethods.indexOf('digest') >= 0) result.push({
			$value: "digest",
			$title: "Digest"

		});
	} else {
		result.push({
			$value: "",
			$title: "Standard"
		});
		// basic and digest are collapsed into a single 'db' method
		if (authMethods.indexOf('basic') >= 0 || authMethods.indexOf('digest') >= 0) result.push({
			$value: "db",
			$title: "DB"
		});
	};
	[{
		$value: "ldap",
		$title: "LDAP"
	}, {
		$value: "oauth2",
		$title: "OAuth2"
	}, {
		$value: "sage-id",
		$title: "Sage ID"
	}].forEach(function(elt) {
		if (authMethods.indexOf(elt.$value) >= 0) result.push(elt);
	});
	return result;
};

// standard setting computed from configuration file and instance of settings singleton.
// result has elements: 
//   - method: "basic", "digest", "ldap", "oauth2", "sage-id"
//   - source: "db" for database authentication, "ldap" for LDAP authentication, empty for OAuth2 authentication
//   - ldap:   data for standard LDAP server (only if source is "ldap")
//   - oauth2: data for standard OAuth2 server (only if method is "oauth2")	
// !!! caching possible, because function will be invoked many times?

function _makeSetting(sc) {
	var result = {
		method: sc.method,
		source: sc.source,
	};
	if ("ldap" in sc) result.ldap = sc.ldap;
	if ("oauth2" in sc) result.oauth2 = sc.oauth2;
	return result;

}

exports.getStandardSetting = function(_) {
	var now = Date.now();
	if (now - cacheAccess < 1000) {
		if (multiTenant) {
			var tenantId = globals.context.tenantId;
			var sc = standardCache[tenantId];
			if (sc && now - sc._time < 1000) return _makeSetting(sc);
		} else {
			if (standardCache) return _makeSetting(standardCache);
		}
	} else {
		if (multiTenant) standardCache = {};
	}
	cacheAccess = now;
	var db = require('syracuse-collaboration/lib/helpers').AdminHelper.getCollaborationOrm(_);
	var setting = db.fetchInstance(_, db.model.getEntity(_, "setting"), {
		sdataWhere: ""
	});
	var method = setting ? setting.authentication(_) : authMethods[0];
	// fail the hard way if default auth is not enabled by config file.
	if (authMethods.indexOf(method) < 0) throw new Error("configuration error: default authentication " + method + " not enabled. Fix your nodelocal.js config file!");

	var result = {
		method: method,
		source: method,
	};
	switch (method) {
		case "basic":
		case "digest":
			result.source = "db";
			break;
		case "ldap":
			var ldap = setting ? setting.ldap(_) : config.session.ldap;
			if (!ldap) throw new Error("configuration error: ldap server missing");
			result.ldap = setting ? ldap._data : ldap;
			break;
		case "oauth2":
			var oauth2 = setting ? setting.oauth2(_) : config.session.oauth2;
			if (!oauth2) throw new Error("configuration error: oauth2 server missing");
			result.oauth2 = setting ? oauth2._data : oauth2;
			break;
	}
	if (multiTenant) {
		result._time = now;
		standardCache[tenantId] = result;
	} else standardCache = result;
	return result;
};

exports.error = function(status, message, headers) {
	var err = new Error(message);
	err.$httpStatus = status;
	err.$httpHeaders = headers;
	return err;
};

exports.unauthorized = function(challenge) {
	return exports.error(401, locale.format(module, "unauth"), challenge && {
		'www-authenticate': challenge,
	});
};

exports.accessDenied = function(status, login) {
	var args = [module, status].concat(Array.prototype.slice.call(arguments, 2));
	return exports.error(status === "noLicense" ? 402 : 403, locale.format.apply(locale, args));
};

exports.genPage = function(_, response, path, params) {
	var html = fs.readFile(path, "utf8", _);
	// keep only the sections for enabled auth methods
	html = html.replace(/\{\{([^\}]+)\}\}/g, function(all, name) {
		return /^js\$/.test(name) ? params[name] : helpers.string.htmlEscape(params[name]);
	});
	response.writeHead(200, {
		"content-type": "text/html"
	});
	response.end(html);
};

exports.redirect = function(_, request, response, location, authenticated) {
	// we are not authenticated - response depends on accept header
	var acceptHtml = httpHelper.parseAccept(request.headers.accept).some(function(elt) {
		return elt.type === "*" || elt.type === "html";
	});

	// TODO: localize
	if (acceptHtml) {
		var headers = {
			"content-type": "text/html; charset=utf8",
			"location": location,
		};
		response.writeHead(307, headers);
		response.end('<html><head><title>Redirecting...</title></head>' + //
			'<body><a href="' + location + '">click here to continue</a></body></html>', "utf8");
	} else {
		// AJAX (or similar) request - generate a diagnose with a link to the login page.
		// don't redirect, send unauthorized instead
		var headers = {
			"content-type": "application/json",
		};
		var status, severity, message, title;
		if (authenticated) {
			message = "sucessfully authenticated";
			status = 200;
			severity = "info";
			title = "requested page";
		} else {
			headers["www-authenticate"] = "Redirect " + location, // keep HTTP spec happy
			message = request.session && request.session.loginError || locale.format(module, "ajaxDisconnected");;
			status = 401;
			severity = "error";
			title = "login page";
		}
		response.writeHead(status, headers);
		response.end(JSON.stringify({
			$diagnoses: [{
				$message: message,
				$severity: severity,
				$links: {
					$redirect: {
						$title: title,
						//locale.format(module, "continue"),
						$type: "html",
						$target: "_self",
						$url: location,
					}
				}
			}]
		}), 'utf8');
	}
};

function notFound(_, request, response) {
	response.writeHead(404, {
		"content-type": "text/plain",
	});
	response.end("url not found: " + request.url);
	return false;
}

function setLocaleFromRequest(_, request) {
	var header = request.headers['accept-language'];
	if (header) {
		var loc = /^[-a-zA-Z]+/.exec(header);
		if (loc) {
			locale.setCurrent(_, loc[0]);
		}
	}
}

exports.dispatcher = function(level, routes) {
	return function(_, request, response) {
		if (level === 2) {
			sessionManager.ensureSession(_, request, response);
			setLocaleFromRequest(_, request);
		}
		try {
			var token = request.url.split(/[\/\?]/)[level];
			var route = routes[token] || notFound;
			return route(_, request, response);
		} catch (ex) {
			console.error(ex.stack);
			request.session.loginError = ex.message;
			return exports.redirect(_, request, response, "/auth/login/page");
		}
	};
};