"use strict";

exports.$exported = true;

var config = require('config');
var fs = require('fs');
var crypto = require('crypto');
var httpClient = require('ez-streams').devices.http.client;
var globals = require('streamline-runtime').globals;

exports.querySFData = function(_, accessToken, instanceUrl, method, path, postData) {
	var authHeader = 'Bearer ' + accessToken;
	var clientOptions = {
		url: instanceUrl + config.sf.restPath + path,
		method: method,
		headers: {
			'Authorization': authHeader,
			'Content-Type': 'application/json',
		}
	};
	var responseBody = sfClient(_, clientOptions, JSON.stringify(postData));
	if (responseBody.statusCode != 200 && responseBody.statusCode != 201 && responseBody.statusCode != 204)
		return {
			statusCode: responseBody.statusCode,
			errorCode: responseBody.responseBody[0].errorCode,
			message: responseBody.responseBody[0].message
		};
	return responseBody;
};

exports.getSFAccessToken = getSFAccessToken;

function getSFAccessToken(_) {
	var statusCheck = checkUserProfile(_);
	if (statusCheck.statusCode != 200)
		return statusCheck;

	var oauthConfig = (config.sf && config.sf.oauth) ? config.sf.oauth : {};
	var key = fs.readFileSync(oauthConfig.certPath, 'utf8');
	var jwtHeader = {"alg":"RS256"};
	var jwtHeaderBase64 = encodeURL(new Buffer(JSON.stringify(jwtHeader)).toString('base64'));

	var currentDate = new Date().getTime();
	var expirationDateMil = new Date(currentDate + 300000).getTime();
	var expirationDate = Math.round(expirationDateMil / 1000);

	var jwtClaim = oauthConfig.jwtClaim;
	jwtClaim.exp = expirationDate.toString();

	var currentUser = globals.context.session.getUserProfile(_).user(_);
	if (!currentUser.sfUserName(_))
		return {
			statusCode: 500,
			errorCode: 'invalid salesforce username',
			message: 'user does not have salesforce username associated'
		};
	jwtClaim.sub = currentUser.sfUserName(_);

	var jwtClaimBase64 = encodeURL(new Buffer(JSON.stringify(jwtClaim)).toString('base64'));

	var newString = jwtHeaderBase64 + '.' + jwtClaimBase64;

	var sign = crypto.createSign('RSA-SHA256');
	sign.update(newString);
	var signature = encodeURL(sign.sign(key, 'base64'));
	var newSignedString = encodeURL(newString + '.' + signature);

	var clientOptions = {
		url: oauthConfig.host + '/services/oauth2/token',
		method: 'POST',
		headers: {
			'Content-Type': 'application/x-www-form-urlencoded'
		}
	};

	var postData = {
		'grant_type': 'urn:ietf:params:oauth:grant-type:jwt-bearer',
		'assertion': newSignedString
	};

	var post_data = Object.keys(postData).map(function(k) {
		return encodeURIComponent(k) + "=" + encodeURIComponent(postData[k]);
	}).join("&");

	var response = sfClient(_, clientOptions, post_data);
	if (response.statusCode != 200)
		return {
			statusCode: response.statusCode,
			errorCode: response.responseBody.error,
			message: response.responseBody.error_description
		};
	var json = response.responseBody;
	return {
		statusCode: response.statusCode,
		accessToken: json.access_token, 
		endpointUrl: json.instance_url
	};
};

function sfClient(_, options, postData) {
	var req = httpClient(options).end(postData);
	var resp = req.response(_);
	//console.log(options.method + " - " + options.url)
	//console.log('Status - ' + resp.statusCode);

	var body = resp.readAll(_);
	return {
		statusCode: resp.statusCode,
		responseBody: JSON.parse(body)
	};
}

function encodeURL(str){
    return str.replace(/\+/g, '-').replace(/\//g, '_').replace(/\=+$/, '');
}

function checkUserProfile(_) {
	var session = globals.context.session;
	var up = session.getUserProfile(_);
	var valid = false;
	up.user(_).getUserRolesList(_).forEach_(_, function(_, role) {
		if (role.code(_) === 'Salesforce CRM') {
			valid = true;
			return;
		}
	});
	if (!valid)
		return {
			statusCode: 500,
			errorCode: 'invalid access',
			message: 'user does not have proper access to execute action'
		};
	else
		return {
			statusCode: 200
		};
}