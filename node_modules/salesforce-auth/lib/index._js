"use strict";

exports.$exported = true;

var config = require('config');
var fs = require('fs');
var crypto = require('crypto');
var httpClient = require('ez-streams').devices.http.client;
var globals = require('streamline-runtime').globals;
var adminHelpers = require('syracuse-collaboration/lib/helpers');

exports.querySFData = function(_, accessToken, instanceUrl, method, path, postData) {
	var authHeader = 'Bearer ' + accessToken;
	var clientOptions = {
		url: instanceUrl + config.sf.restPath + path,
		method: method,
		headers: {
			'Authorization': authHeader,
			'Content-Type': 'application/json',
		}
	};
	var responseBody = sfClient(_, clientOptions, JSON.stringify(postData));
	if (responseBody.statusCode != 200 && responseBody.statusCode != 201 && responseBody.statusCode != 204)
		return {
			statusCode: responseBody.statusCode,
			errorCode: responseBody.responseBody[0].errorCode,
			message: responseBody.responseBody[0].message
		};
	return responseBody;
};

exports.getSFAccessToken = getSFAccessToken;

function getSFAccessToken(_) {
	var statusCheck = checkUserProfile(_);
	if (statusCheck.statusCode != 200)
		return statusCheck;

	var jwtHeader = {"alg":"RS256"};
	var jwtHeaderBase64 = encodeURL(new Buffer(JSON.stringify(jwtHeader)).toString('base64'));

	var currentDate = new Date().getTime();
	var expirationDateMil = new Date(currentDate + 300000).getTime();
	var expirationDate = Math.round(expirationDateMil / 1000);

	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
	var server = db.fetchInstances(_, db.model.getEntity(_, "oauth2"), {
		jsonWhere: {
			name: 'salesforce',
		}
	})[0];
	if (!server) throw authHelper.error(404, "internal error: oauth2 server not found: " + name);
	if (!server.active(_)) throw authHelper.error(403, "internal error: oauth2 server not active: " + name);

	var jwtClaim = {
		iss: server.jwtIssuer(_),
        aud: server.jwtAudience(_),
        exp: expirationDate.toString(),
        sub: 'giancarlo.paredes@dev.sagex3s'
    };

    console.log(jwtClaim)

    var jwtClaimBase64 = encodeURL(new Buffer(JSON.stringify(jwtClaim)).toString('base64'));
	var newString = jwtHeaderBase64 + '.' + jwtClaimBase64;

	var signature = server.certificate(_).sign(_, 'RSA-SHA256', newString, {input_encoding: 'base64'}).toString('base64');
	console.log(signature)
	var newSignedString = encodeURL(newString + '.' + signature);

	var clientOptions = {
		url: server.jwtAudience(_) + '/services/oauth2/token',
		method: 'POST',
		headers: {
			'Content-Type': 'application/x-www-form-urlencoded'
		}
	};

	var postData = {
		'grant_type': 'urn:ietf:params:oauth:grant-type:jwt-bearer',
		'assertion': newSignedString
	};

	var post_data = Object.keys(postData).map(function(k) {
		return encodeURIComponent(k) + "=" + encodeURIComponent(postData[k]);
	}).join("&");

	var response = sfClient(_, clientOptions, post_data);
	if (response.statusCode != 200)
		return {
			statusCode: response.statusCode,
			errorCode: response.responseBody.error,
			message: response.responseBody.error_description
		};
	var json = response.responseBody;
	return {
		statusCode: response.statusCode,
		accessToken: json.access_token,
		endpointUrl: json.instance_url
	};

	/*var oauthConfig = (config.sf && config.sf.oauth) ? config.sf.oauth : {};
	var key = fs.readFileSync(oauthConfig.certPath, 'utf8');
	var jwtHeader = {"alg":"RS256"};
	var jwtHeaderBase64 = encodeURL(new Buffer(JSON.stringify(jwtHeader)).toString('base64'));

	var currentDate = new Date().getTime();
	var expirationDateMil = new Date(currentDate + 300000).getTime();
	var expirationDate = Math.round(expirationDateMil / 1000);

	var jwtClaim = oauthConfig.jwtClaim;
	jwtClaim.exp = expirationDate.toString();

	var currentUser = globals.context.session.getUserProfile(_).user(_);
	if (!currentUser.sfUserName(_))
		return {
			statusCode: 500,
			errorCode: 'invalid salesforce username',
			message: 'user does not have salesforce username associated'
		};
	jwtClaim.sub = currentUser.sfUserName(_);

	var jwtClaimBase64 = encodeURL(new Buffer(JSON.stringify(jwtClaim)).toString('base64'));

	var newString = jwtHeaderBase64 + '.' + jwtClaimBase64;

	var sign = crypto.createSign('RSA-SHA256');
	sign.update(newString);
	var signature = encodeURL(sign.sign(key, 'base64'));
	var newSignedString = encodeURL(newString + '.' + signature);

	var clientOptions = {
		url: oauthConfig.host + '/services/oauth2/token',
		method: 'POST',
		headers: {
			'Content-Type': 'application/x-www-form-urlencoded'
		}
	};

	var postData = {
		'grant_type': 'urn:ietf:params:oauth:grant-type:jwt-bearer',
		'assertion': newSignedString
	};

	var post_data = Object.keys(postData).map(function(k) {
		return encodeURIComponent(k) + "=" + encodeURIComponent(postData[k]);
	}).join("&");

	var response = sfClient(_, clientOptions, post_data);
	if (response.statusCode != 200)
		return {
			statusCode: response.statusCode,
			errorCode: response.responseBody.error,
			message: response.responseBody.error_description
		};
	var json = response.responseBody;
	return {
		statusCode: response.statusCode,
		accessToken: json.access_token, 
		endpointUrl: json.instance_url
	};*/
};

function sfClient(_, options, postData) {
	var req = httpClient(options).end(postData);
	var resp = req.response(_);
	var body = resp.readAll(_);
	return {
		statusCode: resp.statusCode,
		responseBody: JSON.parse(body)
	};
}

function encodeURL(str){
    return str.replace(/\+/g, '-').replace(/\//g, '_').replace(/\=+$/, '');
}

function checkUserProfile(_) {
	var session = globals.context.session;
	var up = session.getUserProfile(_);
	var valid = false;
	up.user(_).getUserBadgesList(_).forEach_(_, function(_, badge) {
		if (badge.code(_) === 'ERPCRM') {
			valid = true;
			return;
		}
	});
	if (!valid)
		return {
			statusCode: 500,
			errorCode: 'invalid access',
			message: 'user does not have proper access to execute action'
		};
	else
		return {
			statusCode: 200
		};
}