"use strict";

exports.$exported = true;

var config = require('config');
var fs = require('fs');
var crypto = require('crypto');
var httpClient = require('ez-streams').devices.http.client;
var globals = require('streamline-runtime').globals;
var adminHelpers = require('@sage/syracuse-lib/src/collaboration/helpers');
var authHelper = require('@sage/syracuse-lib/src/auth/helpers');

exports.querySFData = function(_, accessToken, instanceUrl, method, path, postData) {
	var authHeader = 'Bearer ' + accessToken;
	var clientOptions = {
		url: instanceUrl + config.salesforce.restPath + path,
		method: method,
		headers: {
			'Authorization': authHeader,
			'Content-Type': 'application/json',
		}
	};
	var responseBody = sfClient(_, clientOptions, JSON.stringify(postData));
	if (responseBody.statusCode != 200 && responseBody.statusCode != 201 && responseBody.statusCode != 204)
		return {
			statusCode: responseBody.statusCode,
			errorCode: responseBody.responseBody[0].errorCode,
			message: responseBody.responseBody[0].message
		};
	return responseBody;
};

exports.getSFAccessToken = getSFAccessToken;

function getSFAccessToken(_) {
	var statusCheck = checkUserProfile(_);
	if (statusCheck.statusCode != 200)
		return statusCheck;

	var jwtHeader = {
		"alg": "RS256"
	};
	var jwtHeaderBase64 = encodeURL(new Buffer(JSON.stringify(jwtHeader)).toString('base64'));

	var currentDate = Date.now();
	var expirationDate = Math.round((currentDate + 300000) / 1000);

	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
	var name = 'salesforce';
	var server = db.fetchInstance(_, db.model.getEntity(_, "oauth2"), {
		jsonWhere: {
			// Should be configurable
			name: name,
		}
	});
	// Below code is to support many to one relationship between Salesforce orgs and Sage X3 instance
	/*var server = db.fetchInstances(_, db.model.getEntity(_, "oauth2"), {
		jsonWhere: {
			_id: oauth2ServerId,
		}
	})[0];*/
	if (!server) throw authHelper.error(404, "internal error: oauth2 server not found: " + name);
	if (!server.active(_)) throw authHelper.error(403, "internal error: oauth2 server not active: " + name);
	if (!server.certificate(_)) throw authHelper.error(500, "internal error: no certificate for oauth2 server: " + name);

	var sfUsername = globals.context.session.getUserProfile(_).user(_).getOAuth2Username(_, server.$uuid);
	var jwtClaim = {
		iss: server.jwtIssuer(_),
		aud: server.jwtAudience(_),
		exp: expirationDate.toString(),
		sub: sfUsername
	};

	var jwtClaimBase64 = encodeURL(new Buffer(JSON.stringify(jwtClaim)).toString('base64'));
	var newString = jwtHeaderBase64 + '.' + jwtClaimBase64;

	var signature = server.certificate(_).sign(_, 'RSA-SHA256', newString, {
		input_encoding: 'base64'
	}).toString('base64');
	var newSignedString = encodeURL(newString + '.' + signature);

	var clientOptions = {
		url: server.jwtAudience(_) + '/services/oauth2/token',
		method: 'POST',
		headers: {
			'Content-Type': 'application/x-www-form-urlencoded'
		}
	};

	var postData = {
		'grant_type': 'urn:ietf:params:oauth:grant-type:jwt-bearer',
		'assertion': newSignedString
	};

	var post_data = Object.keys(postData).map(function(k) {
		return encodeURIComponent(k) + "=" + encodeURIComponent(postData[k]);
	}).join("&");

	var response = sfClient(_, clientOptions, post_data);
	if (response.statusCode != 200)
		return {
			statusCode: response.statusCode,
			errorCode: response.responseBody.error,
			message: response.responseBody.error_description
		};
	var json = response.responseBody;
	return {
		statusCode: response.statusCode,
		accessToken: json.access_token,
		endpointUrl: json.instance_url
	};
}

function sfClient(_, options, postData) {
	var req = httpClient(options).end(postData);
	var resp = req.response(_);
	var body = resp.readAll(_);
	return {
		statusCode: resp.statusCode,
		responseBody: JSON.parse(body)
	};
}

function encodeURL(str) {
	return str.replace(/\+/g, '-').replace(/\//g, '_').replace(/\=+$/, '');
}

function checkUserProfile(_) {
	var session = globals.context.session;
	var up = session.getUserProfile(_);
	var valid = up.user(_).getUserBadgesList(_).some_(_, function(_, badge) {
		return badge.code(_) === 'ERPCRM';
	});
	if (!valid)
		return {
			statusCode: 500,
			errorCode: 'invalid access',
			message: 'user does not have proper access to execute action'
		};
	else
		return {
			statusCode: 200
		};
}