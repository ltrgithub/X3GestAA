"use strict";
var config = require('config');
var flows = require('streamline/lib/util/flows');
var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var mongodb = require('streamline-mongodb');
var os = require('os');
var net = require('net');
var ez = require('ez-streams');
var repl_set = require('mongodb/node-mongodb-native/lib/mongodb/connection/repl_set/repl_set');
var sql = require('mssql');

var AWS = require('aws-sdk');
AWS.config.update(config.aws);
var ec2 = new AWS.EC2({
	apiVersion: '2014-06-15'
});
var cloudwatch = new AWS.CloudWatch({
	apiVersion: '2010-08-01'
});

var perSite = {};
var startTime = new Date();
var user = '';
var pwd = '';

var healthCheck = function(_, checkURL) {
	var request = ez.devices.http.client({
		url: checkURL,
		rejectUnauthorized: false,
		method: 'GET',
		headers: {
			'content-type': 'text/json'
		}
	});
	try {
		var resp = request.setTimeout((config.apiHealthScheduler.timeout) * 1000).end().response(_);
		var jsonResp = resp.readAll(_);
		var result = {
			statusCode: resp.statusCode,
			response: jsonResp
		};
		//console.log('\n\n Health Check Response = ' + resp.statusCode + '\n' +  jsonResp.toString());
		return result;
	} catch (e) {
		return;
	}
};


var tests = {
	indexPageResponseTime: function(_, site) {
		// Do outside health check of index.html page for X3
		var url = (site.uri || 'null') + config.apiHealthScheduler.siteuriSuffix;
		//console.log('url = ' + url);
		var result = healthCheck(_, url);
		// 	console.log('result:  ' + result);
		var n = 0;
		if (result !== undefined && result !== null && result.response !== null) {
			var retVal = result.response;
			n = retVal.indexOf('<div class="s-product"');
		}
		if (n <= 0) {
			throw new Error('index page test: failed');
		}
	},
	seiResponseTime: function(_, site) {
		//Set HTML search string
		var search = '<label class="Sage Enterprise Intelligence ui-block-a">';
		// Get base url
		var url = (site.uri || 'null') + config.apiHealthScheduler.siteuriSuffix;

		//Build SEI url
		var pos = url.indexOf('/auth');
		url = url.substring(0,pos);
		pos = url.indexOf('.');
		var back = url.substring(pos);
		var front = url.substring(0,pos);
		var seiUrl = front + '-sei' + back + ':8443';
		//console.log('seiUrl:  ',seiUrl);

		var result = healthCheck(_, seiUrl);
		//console.log('result:  ',result);
		var n = 0;
		var left = '';
		if (result !== undefined && result !== null) {
			var retVal = result.response;
			n = retVal.indexOf(search);
			if (n !== 0)
				pos = retVal.indexOf(search);
				left = retVal.substring(pos + search.length, pos + search.length + 8);
			console.log('left = ',left);
		}
		if (n == 0 || left == '</label>') {
			throw new Error('sei test: failed');
		}
	},
	x3ServerResponseTime: function(_, site) {
		var _stream = null;
		var ipX3 = site.ipX3;
		var port = 1807;

		//Make sure instance exists and is running before attempting to connect
		var ret = getInstanceState(ipX3, _);
		if (ret.status !== 'running') {
			throw new Error('X3 Server ' + ret.status);
			return;
		}

		var _client = ez.devices.net.tcpClient(port, ipX3);
		try {
			_stream = _client.connect(_);
			_stream.close(_);
		} catch (e) {
			throw new Error('X3 Server connection test: failed');
		}
	},
	elasticSearchResponseTime: function(_) {
		var url = config.apiHealthScheduler.esHostName + ':' + config.apiHealthScheduler.esPort;
		var result = healthCheck(_, url);
		var retVal;
		if (result !== undefined && result !== null && result.response !== null) {
			retVal = JSON.parse(result.response);
			if (result.statusCode !== 200) {
				throw new Error('Elasticsearch connection test: failed');
			}
		} else {
			throw new Error('Elasticsearch connection test: failed');
		}
	},
	mongoDbResponseTime: function(_) {
		//Iterate through MongoDb instances and ensure at least one is running.  If none are running,
		//return status of last instance checked.
		var mongoHost = config.apiHealthScheduler.mongoHostName;
		var hostArray = mongoHost.split(",")
		var ip = '';
		var ret = '';
		var runningInstance = false;
		for (var i = 0; i < hostArray.length; i++) {
        	//Need to parse out of existing collaboration.hostname configuration
        	var pos = hostArray[i].indexOf(':');
			if (pos > 0) {
				ip = hostArray[i].substring(0, pos);
			} else {
				ip = hostArray[i];
			}
            ret = getInstanceState(ip, _);
            if (ret.status === 'running') {
            	runningInstance = true;
            	break; 
            } 
        }
        if (runningInstance === false) {
			throw new Error('MongoDB Server ' + ret.status);
			return;
		}

		var db = initializeMongoDB(mongoHost, config.apiHealthScheduler.mongoPort, 'syracuse');
		var result;
		try {
			result = db.open(_);
		} catch (e) {
			throw new Error('MongoDB connection test: failed');
		}
		db.close();
	},
	dbResponseTime: function(_, site) {
		//Make sure instance exists and is running before attempting to connect
		var ret = getInstanceState(site.ipORA, _);
		if (ret.status !== 'running') {
			throw new Error('Database Server ' + ret.status);
			return;
		}
		var configuration = {
		    user: user,
		    password: pwd,
		    server: site.ipORA + '\\' + config.apiHealthScheduler.ds.instance,
		    database: config.apiHealthScheduler.ds.catalog,
		    connectionTimeout: config.apiHealthScheduler.ds.timeout,
		    pool: {
		    	idleTimeoutMillis: 500
		    }
		}
		sql.connect(configuration, ~_);
	}
	// xmResponseTime: function(_, site) {
	// 	// Ensure XM Symphony system is healthy and functional
	// 	var ips = config.apiHealthScheduler.xm.ips;
	// 	var port = config.apiHealthScheduler.xm.port;
	// 	var path = config.apiHealthScheduler.xm.path;
	// 	var hostArray = ips.split(',');

	// 	for (var i = 0; i < hostArray.length; i++) {
	// 		var ip = hostArray[i];
	// 		var url = "http://" + ip + ":" + port + path;
	// 		//console.log('url = ' + url);
	// 		var result = healthCheck(_, url);
	// 		//console.log('result:  ' + result);

	// 		if (result !== undefined && result !== null) {
	// 			if (result.statusCode !== 200)
	// 				throw new Error('XM Symphony connection test: failed');
	// 		} else
	// 			throw new Error('XM Symphony connection test: failed');
	// 	};
	// }
};

var usageTests = {
	CPUUtilization: function(_, ip) {
		var ret = getInstanceState(ip, _);
		if (ret.status !== 'running') {
			throw new Error('Instance ' + ret.status);
			return;
		}
		var usage = getUsage(ret.instanceId, 'CPUUtilization', _);
		return usage;
	},
	NetworkIn: function(_, ip) {
		var ret = getInstanceState(ip, _);
		if (ret.status !== 'running') {
			throw new Error('Instance ' + ret.status);
			return;
		}
		var usage = getUsage(ret.instanceId, 'NetworkIn', _);
		return usage;
	},
	NetworkOut: function(_, ip) {
		var ret = getInstanceState(ip, _);
		if (ret.status !== 'running') {
			throw new Error('Instance ' + ret.status);
			return;
		}
		var usage = getUsage(ret.instanceId, 'NetworkOut', _);
		return usage;
	},
};

function getInstanceState(ip, _) {

	var retVal = {
		status: '',
		instanceId: ''
	};

	if (ip == '') {
		retVal.status = 'not defined';
		return retVal;
	};
	//Check if instance exists before attempting to connect
	var ec2Instance = getInstanceFromIP(ip, _);
	if (ec2Instance == undefined) {
		retVal.status = 'does not exist';
		return retVal;
	};
	retVal.instanceId = ec2Instance.InstanceId;
	//Check if instance is not running.  If not, return instance status.
	var code = ec2Instance.State.Code;
	if (code !== 16) {
		retVal.status = ec2Instance.State.Name;
		return retVal;
	}
	//If we got this far, the instance is running
	retVal.status = 'running';
	return retVal;
};

function doUsageTest(_, site, name, data, instId) {
	var result = {
		name: name,
	};
	//Make sure site is active before running actual tests and logging to Cloudwatch
	if (site.status !== 'active'){
		result.error = 'Site not active.  Site status is ' + site.status + '.';
		result.ms = 0;
		data.exceptions++;
	}
	else {
		var t0 = new Date();
		try {
			var usageData = usageTests[name](_, instId);
			// console.log('usageData = ',usageData)
			result.unit = usageData.Unit;
			result.average = usageData.Average;
			result.minimum = usageData.Minimum;
			result.maximum = usageData.Maximum;
		} catch (ex) {
			result.error = ex.message;
			result.stack = ex.stack;
			data.exceptions++;
		} finally {
			result.ms = new Date() - t0;
		}
	}
	return result;
}

function getTenantUsage(_, site, instanceType) {
	var ip = '';
	var instId = '';
	if (instanceType === 'x3Usage') {
		ip = site.ipX3;
	} else {
		ip = site.ipORA //db usage;
	}
	var data = perSite[site.site];
	var t = new Date();
	try {
		return {
			type: instanceType,
			site: site.site.split(' ').join('').toUpperCase(),
			siteStatus: site.status,
			startTime: startTime,
			currentTime: t,
			previousTime: data.lastTime,
			hostname: os.hostname(),
			pid: process.pid,
			tests: Object.keys(usageTests).map_(_, function(_, name) {
				return doUsageTest(_, site, name, data, ip);
			}),
			memory: process.memoryUsage(),
			totalExceptions: data.exceptions,
			newExceptions: data.exceptions - data.lastExceptions,
			//timings: timings(_),
		};
	} finally {
		data.lastTime = t;
		data.lastExceptions = data.exceptions;
	}
}

function doTest(_, name, site, data) {
	var result = {
		name: name,
	};
	//Make sure site is active before running actual tests and logging to Cloudwatch
	if (site.status !== 'active'){
		result.error = 'Site not active.  Site status is ' + site.status + '.';
		result.ms = 0;
		data.exceptions++;
	}
	else if (site.sei == undefined && name == 'seiResponseTime') {
		result.error = 'SEI not activated for site.';
		result.ms = 0;
		data.exceptions++;
	}
	else {
		var t0 = new Date();
		try {
			tests[name](_, site);
		} catch (ex) {
			result.error = ex.message;
			result.stack = ex.stack;
			data.exceptions++;
		} finally {
			result.ms = new Date() - t0;
			if (config.apiHealthScheduler.cloudwatch) logAWS(_, result, site);
		}
	}
	return result;
}

function logAWS(_, result, site) {
	//console.log('Logging AWS');
	var cloudwatch = new AWS.CloudWatch({
		apiVersion: '2010-08-01'
	});
	//Publish health metric to Cloudwatch.  Passing latency time.  If error occurs, setting
	//latency to 1 minute which should trigger a cloud watch alarm.
	var value = 0;
	if (result.error !== undefined) {
		value = 60000;
	} else {
		value = result.ms;
	}
	var params = {
		Namespace: 'Site',
		MetricData: [{
			MetricName: result.name,
			Unit: 'Milliseconds',
			Dimensions: [{
				Name: 'Site ID',
				Value: site.site
			}, ],
			Value: value
		}]
	};
	cloudwatch.putMetricData(params, function(err, data) {
		if (err) console.log(err, err.stack);
		//else console.log(data);
	});
	return;
};


function getTenantHealth(_, site) {
	var data = perSite[site.site];
	var t = new Date();
	try {
		return {
			type: 'api',
			site: site.site.split(' ').join('').toUpperCase(),
			siteStatus: site.status,
			startTime: startTime,
			currentTime: t,
			previousTime: data.lastTime,
			hostname: os.hostname(),
			pid: process.pid,
			tests: Object.keys(tests).map_(_, function(_, name) {
				return doTest(_, name, site, data);
			}),
			memory: process.memoryUsage(),
			totalExceptions: data.exceptions,
			newExceptions: data.exceptions - data.lastExceptions,
			//timings: timings(_),
		};
	} finally {
		data.lastTime = t;
		data.lastExceptions = data.exceptions;
	}
}


function getInstanceFromIP(instanceIP, _) {
	var params = {
		Filters: [{
			Name: 'private-ip-address',
			Values: [
				instanceIP
			]
		}]
	};
	if(config.skyAutomation.vpcId) {
      	params.Filters.push({
        	Name: 'vpc-id',
        	Values: [
          		config.skyAutomation.vpcId,
        	]
      	});
    }
	var data = ec2.describeInstances(params, ~_);
	//console.log('Data =', data);
	var reservations = data.Reservations;
	if (!reservations.length) return;
	var instances = reservations[0].Instances;
	var instance = instances[0];
	return instance;
};


function getUsage(instanceId, metricName, _) {
	var today = new Date();
	var now = new Date();
	var earlier = new Date(now.setMinutes(now.getMinutes() - 10)); //less 10 Minutes  Should be logging every 5 minutes

	var params = {
		Namespace: 'AWS/EC2',
		MetricName: metricName,
		StartTime: earlier.toISOString(),
		EndTime: today.toISOString(),
		Period: 60 * 5,
		//Unit:'Percent',
		Statistics: [
			'Average',
			'Minimum',
			'Maximum'
		],
		Dimensions: [{
			Name: 'InstanceId',
			Value: instanceId
		}],
	};

	var data = cloudwatch.getMetricStatistics(params, ~_);
	var usage = data.Datapoints;
	var length = usage.length;
	//If more than one usage object in array is returned, log the most recent.
	if (length > 1) {
		usage = sortByKey(usage, 'Timestamp');
	}
	//console.log('Usage = ',data)
	return usage[length - 1];
};

function sortByKey(array, key) {
	return array.sort(function(a, b) {
		var x = a[key];
		var y = b[key];
		return ((x < y) ? -1 : ((x > y) ? 1 : 0));
	});
};


function addSite(site) {
	//console.log('\n site in addSIte = ' + site);
	perSite[site] = perSite[site] || {
		exceptions: 0,
		lastExceptions: 0,
		lastTime: null,
	};
};


flows.setInterval(function(_) {
	try {
		//console.log("API Health Check interval")
		var enc = config.apiHealthScheduler.ds.healthId;
		var dec = new Buffer(enc, 'base64').toString();
		var pos = dec.indexOf(':');
		user = dec.substring(0, pos);
		var pos2 = dec.indexOf('!', pos);
		pwd = dec.substring(pos+1, pos2);

		var db = initializeMongoDB(config.collaboration.hostname, config.collaboration.port, 'production', _);
		var db2 = initializeMongoDB(config.collaboration.hostname, config.collaboration.port, 'production', _);
		var result;
		var result2;
		try {
			result = db.open(_);
			result2 = db2.open(_);
			var collection = db.collection('Site', _);
			var collection2 = db2.collection('healthLogs', _);

			var cursor = collection.find().toArray(_);

			for (var i = 0; i < cursor.length; i++) {
				addSite(cursor[i].site);
				//console.log('Site = ' + cursor[i].site);
				collection2.insert(getTenantHealth(_, cursor[i]), _);
				//collection2.insert(getTenantUsage(_, cursor[i], 'x3Usage'), _);
				//collection2.insert(getTenantUsage(_, cursor[i], 'dbUsage'), _);
			}

		} catch (e) {
			console.log("Error in open().");
			console.log(e);
		}
		db.close(_);
		db2.close(_);

	} catch (ex) {
		console.log(ex.stack);
	}
}, (config.apiHealthScheduler.delay || 300) * 1000);


function initializeMongoDB(mongoHost, mongoPort, mongoDatabase, _) {
    var hostArray = mongoHost.split(",")
    if (hostArray.length > 1) {
        var servers = [];
        var mongoServer = '';
		var port = 0;
        for (var i = 0; i < hostArray.length; i++) {
        	//Need to parse out of existing collaboration.hostname configuration
        	var pos = hostArray[i].indexOf(':');
			if (pos > 0) {
				mongoServer = hostArray[i].substring(0, pos);
				port = hostArray[i].substring(pos + 1);
			}
			else {
				mongoServer = hostArray[i];
				port = mongoPort;
			}
            servers[i] = new mongodb.Server(mongoServer || 'localhost', port || 27017, {});
        }
        var replSet = repl_set.ReplSet(servers,{});
        var db = new mongodb.Db(mongoDatabase || 'syracuse', replSet, {
            w: 1 // majority
        });
    } else {
        var server = new mongodb.Server(mongoHost || 'localhost', mongoPort || 27017, {});
        var db = new mongodb.Db(mongoDatabase || 'syracuse', server, {
            w: 1 // majority
        });
    }
    return db;
}
