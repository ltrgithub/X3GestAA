"use strict";
var config = require('config');
var flows = require('streamline/lib/util/flows');
var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var mongodb = require('streamline-mongodb');
var os = require('os');
var net = require('net');
var ez = require('ez-streams');
var repl_set = require('mongodb/node-mongodb-native/lib/mongodb/connection/repl_set/repl_set');

var AWS = require('aws-sdk');
AWS.config.update(config.aws);
var ec2 = new AWS.EC2({
	apiVersion: '2014-06-15'
});
var cloudwatch = new AWS.CloudWatch({
	apiVersion: '2010-08-01'
});

var perSite = {};
var startTime = new Date();

var healthCheck = function(_, checkURL) {
	var request = ez.devices.http.client({
		url: checkURL,
		rejectUnauthorized: false,
		method: 'GET',
		headers: {
			'content-type': 'text/json'
		}
	});
	try {
		var resp = request.end().response(_);
		var jsonResp = resp.readAll(_);
		//console.log('\n\n Health Check Response = ' + resp.statusCode + '\n' +  jsonResp.toString());
		return jsonResp;
	} catch (e) {
		return;
	}
};


var tests = {
	indexPageResponseTime: function(_, site) {
		// Do outside health check of index.html page for X3
		var url = (site.uri || 'null') + config.apiHealthScheduler.siteuriSuffix;
		//console.log('url = ' + url);
		var result = healthCheck(_, url);
		// 	console.log('result:  ' + result);
		var n = 0;
		if (result !== undefined && result !== null) {
			var retVal = result;
			n = retVal.indexOf('<div class="s-product"');
		}
		if (n <= 0) {
			throw new Error('index page test: failed');
		}
	},
	x3ServerResponseTime: function(_, site) {
		var _stream = null;
		var ipX3 = site.ipX3;
		var port = 1807;

		//Make sure instance exists and is running before attempting to connect
		var ret = getInstanceState(ipX3, _);
		if (ret.status !== 'running') {
			throw new Error('X3 Server ' + ret.status);
			return;
		}

		var _client = ez.devices.net.tcpClient(port, ipX3);
		try {
			_stream = _client.connect(_);
			_stream.close(_);
		} catch (e) {
			throw new Error('X3 Server connection test: failed');
		}
	},
	elasticSearchResponseTime: function(_) {

		//Make sure instance exists and is running before attempting to connect
		var ret = getInstanceState(config.apiHealthScheduler.esHostName, _);
		if (ret.status !== 'running') {
			throw new Error('Elasticsearch Server ' + ret.status);
			return;
		}

		var url = 'http://' + config.apiHealthScheduler.esHostName + ':' + config.apiHealthScheduler.esPort;
		var result = healthCheck(_, url);
		var retVal;
		if (result !== undefined) {
			retVal = JSON.parse(result);
			if (retVal['ok'] !== true) {
				throw new Error('Elasticsearch connection test: failed');
			}
		} else {
			throw new Error('Elasticsearch connection test: failed');
		}
	},
	mongoDbResponseTime: function(_) {

		//Make sure instance exists and is running before attempting to connect
		var ret = getInstanceState(config.apiHealthScheduler.mongoHostName, _);
		if (ret.status !== 'running') {
			throw new Error('MongoDB Server ' + ret.status);
			return;
		}

		var server = new mongo.Server(config.apiHealthScheduler.mongoHostName, config.apiHealthScheduler.mongoPort);
		var db = new mongo.Db('Syracuse', server, {
			fsync: true
		});
		var result;
		try {
			result = db.open(_);
		} catch (e) {
			throw new Error('MongoDB connection test: failed');
		}
		db.close();
	},
	dbResponseTime: function(_, site) {

		//Make sure instance exists and is running before attempting to connect
		var ret = getInstanceState(site.ipORA, _);
		if (ret.status !== 'running') {
			throw new Error('Database Server ' + ret.status);
			return;
		}

		var client = ez.devices.net.tcpClient(1521, site.ipORA);
		client.connect(_);
	},
};

var usageTests = {
	CPUUtilization: function(_, ip) {
		var ret = getInstanceState(ip, _);
		if (ret.status !== 'running') {
			throw new Error('Instance ' + ret.status);
			return;
		}
		var usage = getUsage(ret.instanceId, 'CPUUtilization', _);
		return usage;
	},
	NetworkIn: function(_, ip) {
		var ret = getInstanceState(ip, _);
		if (ret.status !== 'running') {
			throw new Error('Instance ' + ret.status);
			return;
		}
		var usage = getUsage(ret.instanceId, 'NetworkIn', _);
		return usage;
	},
	NetworkOut: function(_, ip) {
		var ret = getInstanceState(ip, _);
		if (ret.status !== 'running') {
			throw new Error('Instance ' + ret.status);
			return;
		}
		var usage = getUsage(ret.instanceId, 'NetworkOut', _);
		return usage;
	},
};

function getInstanceState(ip, _) {

	var retVal = {
		status: '',
		instanceId: ''
	};

	if (ip == '') {
		retVal.status = 'not defined';
		return retVal;
	};
	//Check if instance exists before attempting to connect
	var ec2Instance = getInstanceFromIP(ip, _);
	if (ec2Instance == undefined) {
		retVal.status = 'does not exist';
		return retVal;
	};
	retVal.instanceId = ec2Instance.InstanceId;
	//Check if instance is not running.  If not, return instance status.
	var code = ec2Instance.State.Code;
	if (code !== 16) {
		retVal.status = ec2Instance.State.Name;
		return retVal;
	}
	//If we got this far, the instance is running
	retVal.status = 'running';
	return retVal;
};

function doUsageTest(_, name, data, instId) {
	var result = {
		name: name,
	};
	var t0 = new Date();
	try {
		var usageData = usageTests[name](_, instId);
		// console.log('usageData = ',usageData)
		result.unit = usageData.Unit;
		result.average = usageData.Average;
		result.minimum = usageData.Minimum;
		result.maximum = usageData.Maximum;
	} catch (ex) {
		result.error = ex.message;
		result.stack = ex.stack;
		data.exceptions++;
	} finally {
		result.ms = new Date() - t0;
	}
	//console.log('usage result = ',result);
	return result;
}

function getTenantUsage(_, site, instanceType) {
	var ip = '';
	var instId = '';
	if (instanceType === 'x3Usage') {
		ip = site.ipX3;
	} else {
		ip = site.ipORA //db usage;
	}
	var data = perSite[site.site];
	//var ec2Instance = getInstanceFromIP(ip, _);
	//if (ec2Instance !== undefined) instId = ec2Instance.InstanceId;
	var t = new Date();
	try {
		return {
			type: instanceType,
			site: site.site.split(' ').join('').toUpperCase(),
			startTime: startTime,
			currentTime: t,
			previousTime: data.lastTime,
			hostname: os.hostname(),
			pid: process.pid,
			tests: Object.keys(usageTests).map_(_, function(_, name) {
				//return doUsageTest(_, name, data, instId);
				return doUsageTest(_, name, data, ip);
			}),
			memory: process.memoryUsage(),
			totalExceptions: data.exceptions,
			newExceptions: data.exceptions - data.lastExceptions,
			//timings: timings(_),
		};
	} finally {
		data.lastTime = t;
		data.lastExceptions = data.exceptions;
	}
}

function doTest(_, name, site, data) {
	var result = {
		name: name,
	};
	var t0 = new Date();
	try {
		tests[name](_, site);
	} catch (ex) {
		result.error = ex.message;
		result.stack = ex.stack;
		data.exceptions++;
	} finally {
		result.ms = new Date() - t0;
		if (config.apiHealthScheduler.cloudwatch) logAWS(_, result, site);
	}
	//console.log('api result = ',result);
	return result;
}

function logAWS(_, result, site) {
	//console.log('Logging AWS');
	var cloudwatch = new AWS.CloudWatch({
		apiVersion: '2010-08-01'
	});
	//Publish health metric to Cloudwatch.  Passing latency time.  If error occurs, setting
	//latency to 1 minute which should trigger a cloud watch alarm.
	var value = 0;
	if (result.error !== undefined) {
		value = 60000;
	} else {
		value = result.ms;
	}
	var params = {
		Namespace: 'Site',
		MetricData: [{
			MetricName: result.name,
			Unit: 'Milliseconds',
			Dimensions: [{
				Name: 'Site ID',
				Value: site.site
			}, ],
			Value: value
		}]
	};
	cloudwatch.putMetricData(params, function(err, data) {
		if (err) console.log(err, err.stack);
		//else console.log(data);
	});
	return;
};


function getTenantHealth(_, site) {
	var data = perSite[site.site];
	var t = new Date();
	try {
		return {
			type: 'api',
			site: site.site.split(' ').join('').toUpperCase(),
			startTime: startTime,
			currentTime: t,
			previousTime: data.lastTime,
			hostname: os.hostname(),
			pid: process.pid,
			tests: Object.keys(tests).map_(_, function(_, name) {
				return doTest(_, name, site, data);
			}),
			memory: process.memoryUsage(),
			totalExceptions: data.exceptions,
			newExceptions: data.exceptions - data.lastExceptions,
			//timings: timings(_),
		};
	} finally {
		data.lastTime = t;
		data.lastExceptions = data.exceptions;
	}
}


function getInstanceFromIP(instanceIP, _) {
	var params = {
		Filters: [{
			Name: 'private-ip-address',
			Values: [
				instanceIP
			]
		}]
	};
	var data = ec2.describeInstances(params, ~_);
	//console.log('Data =', data);
	var reservations = data.Reservations;
	if (!reservations.length) return;
	var instances = reservations[0].Instances;
	var instance = instances[0];
	return instance;
};


function getUsage(instanceId, metricName, _) {
	var today = new Date();
	var now = new Date();
	var earlier = new Date(now.setMinutes(now.getMinutes() - 10)); //less 10 Minutes  Should be logging every 5 minutes

	var params = {
		Namespace: 'AWS/EC2',
		MetricName: metricName,
		StartTime: earlier.toISOString(),
		EndTime: today.toISOString(),
		Period: 60 * 5,
		//Unit:'Percent',
		Statistics: [
			'Average',
			'Minimum',
			'Maximum'
		],
		Dimensions: [{
			Name: 'InstanceId',
			Value: instanceId
		}],
	};

	var data = cloudwatch.getMetricStatistics(params, ~_);
	var usage = data.Datapoints;
	var length = usage.length;
	//If more than one usage object in array is returned, log the most recent.
	if (length > 1) {
		usage = sortByKey(usage, 'Timestamp');
	}
	//console.log('Usage = ',data)
	return usage[length - 1];
};

function sortByKey(array, key) {
	return array.sort(function(a, b) {
		var x = a[key];
		var y = b[key];
		return ((x < y) ? -1 : ((x > y) ? 1 : 0));
	});
};


function addSite(site) {
	//console.log('\n site in addSIte = ' + site);
	perSite[site] = perSite[site] || {
		exceptions: 0,
		lastExceptions: 0,
		lastTime: null,
	};
};


flows.setInterval(function(_) {
	try {
		//console.log("API Health Check interval")
		var db = initializeMongoDB(config.collaboration.hostname, config.collaboration.port, 'production');
		var db2 = initializeMongoDB(config.collaboration.hostname, config.collaboration.port, 'production');
		var result;
		var result2;
		try {
			result = db.open(_);
			result2 = db2.open(_);
			var collection = db.collection('Site', _);
			var collection2 = db2.collection('healthLogs', _);

			var cursor = collection.find().toArray(_);

			for (var i = 0; i < cursor.length; i++) {
				addSite(cursor[i].site);
				//console.log('Site = ' + cursor[i].site);
				collection2.insert(getTenantHealth(_, cursor[i]), _);
				collection2.insert(getTenantUsage(_, cursor[i], 'x3Usage'), _);
				collection2.insert(getTenantUsage(_, cursor[i], 'dbUsage'), _);
			}

		} catch (e) {
			console.log("Error in open().");
			console.log(e);
		}
		db.close();

	} catch (ex) {
		console.log(ex.stack);
	}
}, (config.apiHealthScheduler.delay || 300) * 1000);


function initializeMongoDB(mongoHost, mongoPort, mongoDatabase) {
    var hostArray = mongoHost.split(",")
    if (hostArray.length > 1) {
        var servers = [];
        var mongoServer = '';
		var port = 0;
        for (var i = 0; i < hostArray.length; i++) {
        	//Need to parse out of existing collaboration.hostname configuration
        	var pos = hostArray[i].indexOf(':');
			if (pos > 0) {
				mongoServer = hostArray[i].substring(0, pos);
				port = hostArray[i].substring(pos + 1);
			}
			else {
				mongoServer = hostArray[i];
				port = mongoPort;
			}
            servers[i] = new mongodb.Server(mongoServer || 'localhost', port || 27017, {});
        }
        var replSet = repl_set.ReplSet(servers,{});
        var db = new mongodb.Db(mongoDatabase || 'syracuse', replSet, {
            w: 1 // majority
        });
    } else {
        var server = new mongodb.Server(mongoHost || 'localhost', mongoPort || 27017, {});
        var db = new mongodb.Db(mongoDatabase || 'syracuse', server, {
            w: 1 // majority
        });
    }
    return db;
}