var config = require('config');
var flows = require('streamline/lib/util/flows');
var streams = require('streamline-streams');
var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var mongo = require('streamline-mongodb');
var os = require('os');
var net = require('net');

var AWS = require('aws-sdk');
AWS.config.update(config.aws);

var perSite = {};
var startTime = new Date();


var healthCheck = function(_, checkURL) {
    var request = streams.httpRequest({
		url: checkURL,
		method: 'GET',
		headers: {
			'content-type': 'text/json'
		}
	});
	try {
		var resp = request.end().response(_);
        var jsonResp = resp.readAll(_);
        //console.log('\n\n Health Check Response = ' + resp.statusCode + '\n' +  jsonResp.toString());
		if (resp.statusCode != 200) {
			// TODO: write failure to mongo 
		} else {
			// TODO: write success to mongo
		}
		return jsonResp;
	} catch (e) {
		return;
	}
};

var tests = {
	indexPageResponseTime: function(_, site) {
        // Do outside health check of index.html page for X3
        var url = 'http://' + (site.uri || 'null') + '/index.html';
        var result = healthCheck(_, url);
        var n = 0;
        if (result !== undefined && result !== null) {
            var retVal = result;
            n = retVal.indexOf('<div class="s-start">');
        }
        if (n <= 0) {
            throw new Error('index page test: failed');
        }
	},
	x3ServerResponseTime: function(_, site) {
		var _stream = null;
		var ipX3 = site.ipX3;
		var port = 1807;

		var _client = streams.tcpClient(port, ipX3);
		try {
			_stream = _client.connect(_);
			_stream.close(_);
		} catch (e) {
			throw new Error('X3 Server connection test: failed');
		}
	},
	elasticSearchResponseTime: function(_) {
		var url = 'http://' + config.apiHealthScheduler.esHostName + ':' + config.apiHealthScheduler.esPort;
		var result = healthCheck(_, url);
		var retVal;
		if (result !== undefined) {
			retVal = JSON.parse(result);
			if (retVal['ok'] !== true) {
				throw new Error('Elastic Search connection test: failed');
			}
		} else {
			throw new Error('Elastic Search connection test: failed');
		}
	},
	mongoDbResponseTime: function(_) {
		var server = new mongo.Server(config.apiHealthScheduler.mongoHostName, config.apiHealthScheduler.mongoPort);
		db = new mongo.Db('Syracuse', server, {
			fsync: true
		});
		var result;
		try {
			result = db.open(_);
		} catch (e) {
			throw new Error('MongoDB connection test: failed');
		} 
		db.close();
	},
	oracleResponseTime: function(_, site) {
		var client = net.createConnection(1521, site.ipORA).on("connect", function(e) {
			//console.log("Success");
			client.destroy();
		}).on("error", function(e) {
			//console.log("Failure: " + e);
			throw new Error('Oracle connection test: failed');
		});
	},
}

function doTest(_, name, site, data) {
	var result = {
		name: name,
	};
	var t0 = new Date();
	try {
		tests[name](_, site);
	} catch (ex) {
		result.error = ex.message;
		result.stack = ex.stack;
		data.exceptions++;
	} finally {
		result.ms = new Date() - t0;
        if (config.apiHealthScheduler.cloudwatch) logAWS(_, result, site);
	}
	return result;
}

function logAWS(_, result, site){
    console.log('Logging AWS');
	var cloudwatch = new AWS.CloudWatch({
		apiVersion: '2010-08-01'
	});
	//Publish health metric to Cloudwatch.  Passing latency time.  If error occurs, setting
	//latency to 1 minute which should trigger a cloud watch alarm.
	var value = 0;
	if (result.error !== undefined) {
		value = 60000;
	}
	else
	{
		value = result.ms;
	}
	var params = {
		Namespace: 'Site',
		MetricData: [{
			MetricName: result.name,
			Unit: 'Milliseconds',
			Dimensions: [{
				Name: 'Site ID',
				Value: site.site
			}, ],
			Value: value
		}]
	};
	cloudwatch.putMetricData(params, function(err, data) {
		if (err) console.log(err, err.stack);
		else console.log(data);
	});
	return;
};

function getTenantHealth(_, site) {
	var data = perSite[site.site];
	var t = new Date();
	try {
		return {
            type: 'api',
			site: site.site.toUpperCase(),
			startTime: startTime,
			currentTime: t,
			previousTime: data.lastTime,
			hostname: os.hostname(),
			pid: process.pid,
			tests: Object.keys(tests).map_(_, function(_, name) {
				return doTest(_, name, site, data);
			}),
			memory: process.memoryUsage(),
			totalExceptions: data.exceptions,
			newExceptions: data.exceptions - data.lastExceptions,
			//timings: timings(_),

		};
	} finally {
		data.lastTime = t;
		data.lastExceptions = data.exceptions;
	}
}

function addSite(site) {
    //console.log('\n site in addSIte = ' + site);
	perSite[site] = perSite[site] || {
		exceptions: 0,
		lastExceptions: 0,
		lastTime: null,
	};
};

flows.setInterval(function(_) {
	try {
        console.log("API Health Check interval")
        
        var server = new mongo.Server('localhost', '27017');
        db = new mongo.Db('production', server, {
            fsync: true
        });
        var server2 = new mongo.Server('localhost', '27017');
        db2 = new mongo.Db('production', server2, {
            fsync: true
        });
        var result;
        var result2;
        try {
            result = db.open(_);
            result2 = db2.open(_);
            var collection = db.collection('Site', _);
            var collection2 = db2.collection('healthLogs', _);
            
            var cursor = collection.find().toArray(_);

            for(var i = 0; i < cursor.length; i++) {
                addSite(cursor[i].site);
                collection2.insert(getTenantHealth(_, cursor[i]),_);
            }
            
        } catch (e) {
            console.log("Error in open().");
            console.log(e);

        }
        db.close();

	} catch (ex) {
		console.log(ex.stack);
	}
}, (config.apiHealthScheduler.delay || 60) * 1000);


