"use strict"
var util = require('util')
var adminHelpers = require('syracuse-collaboration/lib/helpers');
var fs = require('fs')
var http = require('http')

var locale = require("syracuse-core/lib/locale");
var lic = require('../index')
var l = lic.load('license');
var date = require('syracuse-core/lib/types/date');
var config = require('syracuse-main/lib/nodeconfig').config;
var mongodb = require('mongodb')

var POLICY_FILE = __dirname+"/../../../policy.json";
var PARTNER_FILE = __dirname+"/../../../partner.json";

/// updateFromDB: read license data from database (because database data may have changed)
function updateFromDB(_) {
	try {
		var licenses = lic.readLicenses(_);
		_manageLicenseData(_, licenses, true);
	} catch (e) {
		console.log(e)
	}
}

exports.updateFromDB = updateFromDB;

/// getParsedLicense: get parsed license data
function getParsedLicense(_) {
	var data = _manageLicenseData(_);
	if (data) return data[1];
	return null;
}
exports.getParsedLicense = getParsedLicense;

/// getRawLicense: get list of license strings exactly in the format in which they have been provided to the license system
function getRawLicense(_) {
	var data = _manageLicenseData(_);
	if (data) return data[0];
	return null;
}
exports.getRawLicense = getRawLicense;

// _manageLicenseData: retrieve and store license data
//  newLicenses: optional array of licenses or policy files which will be added to the existing data and will overwrite existing data of the same kind
//  doNotStore: optional parameter which indicates that the license data should not be stored in the database 
function _manageLicenseData(_, newLicenses, doNotStore) {
	if (!l) 
		return null;
	try {
		var data = l.license();
	} catch (e) {
		throw new Error(locale.format(module, "licError", e.toString()));
	}
	if (!data) {
		return null;
	}
	var firstTime = !data[1];
	if (firstTime) { // first invocation: read policy and partner file
		newLicenses = newLicenses || [];
		if (fs.existsSync(POLICY_FILE))
			newLicenses.push(fs.readFile(POLICY_FILE, "utf8", _));
		if (fs.existsSync(PARTNER_FILE))
			newLicenses.push(fs.readFile(PARTNER_FILE, "utf8", _));
	}
	var result = _parseLicenses(data, newLicenses);
	// store new content
	try {
		l.license(result);
	} catch (e) {
		throw new Error(locale.format(module, "licError", e.toString()));		
	}
	if (!doNotStore && result !== data) { // change in licenses: update contents in database
		_storeDB(result[0], _);
	}
	if (firstTime && fs.existsSync(lic.LICENSE_FILE)) {
		var renamed = lic.LICENSE_FILE.replace(/\w+$/, "bbb");		
		try { // remove renamed file if existent 
			fs.unlink(renamed, _);
		} catch (e) {}
		fs.rename(lic.LICENSE_FILE, renamed, _);
	}
	return result;
}

// update raw license data in database (replace old list of licenses with new list)
function _storeDB(licenses, _) {
	if (!config || !config.license)
		throw new Error(locale.format(module, "noConfig"));
	var db = new mongodb.Db(config.license.database, new mongodb.Server(config.license.hostname, config.license.port,
			 {}), {});

	// Establish connection to db
	try {
		db = db.open(_);
		var collection = db.createCollection('license', _);
		collection.remove({}, {safe: true, fsync: true}, _);
		
		var ins = licenses.map(function(item) { return {text: item}; })
		collection.insert(ins, _);
	} finally {
		db.close();
	}
}

/* structure of parsed license data:
 * - nextCheck: new computation of data necessary after this date (e. g. "2012-01-31")
 * - keyFunctions: list of all license protected X3 functions of all modules
 * - badges: object with keys being badge code; for each badge code the maximum number and the functions which are released by this badge
 * - expires: list of all expiring modules: module code, expire date, partnerId, sorted ascending by expire date
 * - concurrent: licensing model: concurrent (true) or named user (false)
 * - licensedTo: to whom the license has been issued
 * - partners: ID's of partners for whom a license is installed
 */
function _parseLicenses(data, newLicenses) {
	if (!Array.isArray(data) || !Array.isArray(data[0])) return null;
	var licenses = data[0];
	var currentDate = date.today();
	var currentDateString = currentDate.toString();
	if ((!newLicenses || newLicenses.length === 0) && data[1] && data[1].nextCheck >= currentDateString)
		return data;
	var licenseData = {};
	var policyData = {};
	var grouped = {};
	var newLic = false; // real changes with new licenses
	licenses.forEach(function(license) {
		var parsed = JSON.parse(license);
		var partnerId = parsed.partnerId || "";
		var type = parsed.fileType+" "+partnerId;
		if (parsed.fileType === "License") 
			licenseData[partnerId] = parsed;
		else if (parsed.fileType === "Policy")
			policyData[partnerId] = parsed;
		else if (parsed.fileType !== "Partner")
			throw new Error(locale.format(module, "wrongType", parsed.fileType))
			
		grouped[type] = license.trim();
	});
	// insert new licenses
	if (newLicenses) {
		newLicenses.forEach(function(newLicense) {
			if (!newLicense) return;
			newLicense = newLicense.toString();
			var parsed = JSON.parse(newLicense);
			var partnerId = parsed.partnerId || "";
			var type = parsed.fileType+" "+partnerId;
			if (grouped[type] !== newLicense.trim()) { 
				newLic = true;
				if (parsed.fileType === "License") 
					licenseData[partnerId] = parsed;
				else if (parsed.fileType === "Policy")
					policyData[partnerId] = parsed;
				else if (parsed.fileType !== "Partner")
					throw new Error(locale.format(module, "wrongType", parsed.fileType))
				grouped[type] = newLicense;
			}
		});		
	}
	if (!newLic && data[1] && data[1].nextCheck >= currentDate)
		return data;
	// compute new parsed data
	if (newLic) {
		var k = Object.keys(grouped).map(function(key){ return grouped[key]; });
		data = [k, {}];
	}
	else {
		data[1] = {};
	}
	var infos = data[1];
	var keyFunctions = {};
	var licensedModules = {};
	var policyModules = {};
	// parse the licenses
	var partners = Object.keys(licenseData).sort(); // Sage license should come first
	var nextCheck = date.today().addYears(1000);
	var expires = [];
	infos.badges = {};
	infos.partners = partners;
	for (var i = 0; i<partners.length; i++) {
		var key = partners[i];
		if (!(key in policyData)) {
			if (key)
				throw new Error(locale.format(module, "noPolicyP", key))
			else
				throw new Error(locale.format(module, "noPolicy"))
		}		
		var parsed = licenseData[key];
		var parsedPolicy = policyData[key];
		var modulesInLicense = {}; // modules which occur in current license
		var badgesInLicense = {}; // badges which occur in current license
		if (!key) { // only Sage session control setting is relevant, not of partner licenses 
			infos.concurrent = (parsed.sessionControl === "concurrent");
			infos.licensedTo = parsed.licensedTo;
		}
		parsed.modules.forEach(function (module) {
			if (module.code in licensedModules) return;
			licensedModules[module.code] = 0;
			modulesInLicense[module.code] = "";
			if (module.validity[0]) {
				var validFrom = date.parse(module.validity[0]);
				if (validFrom.compare(currentDate) > 0) {
					// module not yet valid
					validFrom = validFrom.addDays(-1);
					if (validFrom.compare(nextCheck) < 0)
						nextCheck = validFrom;
					return;
				}
			}
			if (module.validity[1]) {
				var validTo = date.parse(module.validity[1]);
				if (validTo.compare(currentDate) < 0) {
					// module not valid any more
					return;
				} else {
					if (validTo.compare(nextCheck) < 0)
						nextCheck = validTo;
				}
				expires.push({module: module.code, expire: module.validity[1], partner: parsed.partnerId}); 
			}
			// module is licensed
			licensedModules[module.code] = 1;
		});
		// add policy data for modules
		parsedPolicy.modules.forEach(function (module) {
			if (module.code in policyModules) return;
			policyModules[module.code] = "";
			var licensed = (licensedModules[module.code] ? 1 : 0)
			module.keyFunctions.forEach(function(fkt) {
				if (!(fkt in keyFunctions))
					keyFunctions[fkt] = licensed;
			});
		});
		parsed.badges.forEach(function (badge) {
			if (badge.code in infos.badges) return;
			badgesInLicense[badge.code] = "";
			infos.badges[badge.code] = {max: badge.max, func:[], multi: (badge.multi ? badge.multi : 1), title: badge.title};
		});
		// add policy data for badges
		parsedPolicy.badges.forEach(function (badge) {
			if (badge.code in badgesInLicense) { // only consider badges which are licensed
				badge.functions.forEach(function (fkt)  {
					if (keyFunctions[fkt]) {// function belongs to licensed module
						infos.badges[badge.code].func.push(fkt);
					}
				});
			}
		});
	};
	infos.keyFunctions = Object.keys(keyFunctions);
	infos.expires = expires.sort(function(a,b){ return (a.expire > b.expire ? 1 : (a.expire === b.expire ? 0 : -1)) });
	infos.nextCheck = nextCheck.toString();
	return data;
}
exports._p = _parseLicenses;

// returns an object which contains all unlicensed key functions and the list of partner ID's for which a license has been installed.
function getFunctionsAndLicenses(session, _) {
	// read license content
	var data = getParsedLicense(_);
	var licensed = {}; // X3 functions which are allowed by at least one badge
	var badges = role.badges(_).toArray(_);
	badges.forEach(function(badge) {
		badge.func.forEach(function(fkt) {
			licensed[fkt] = "";
		})
	});
	// return X3 functions which are not allowed by at least one badge
	var func = data.keyFunctions.filter(function (item) { return !(item in licensed);});
	return {functions: func, licenses: data.partners};
}

exports.getFunctionsAndLicenses = getFunctionsAndLicenses;


function checkConcurrent(session, role, _) { 
	// read license content
	var data = getParsedLicense(_);
	if (!data || !data.concurrent) return true;
	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
		
	var badgeCodes = {};
	var badges = role.badges(_).toArray(_);
	var j = badges.length;
	while (--j >= 0) {
		badgeCodes[badges[j].code(_)] = "";
	}

	console.log("Badges "+util.format(Object.keys(badgeCodes)))

	var serverNames = {};
	var sessionInfos = _remainingLicenses(_, db, data, badgeCodes, session, serverNames);
	if (sessionInfos != null) { // maybe old sessions have been counted
		var ok = false;
		delete serverNames[session.sessionInfo.serverName(_)];
		var otherServers = Object.keys(serverNames);
		if (otherServers.length > 0) {
			var i = otherServers.length;
			var futures = [];
			while (--i >= 0) {
				futures[i] = _askServer(otherServers[i], "/licensetest")			
			}
			i = otherServers.length;
			while (--i >= 0) {
				if (futures[i](_) === true) // server could be reached - remove it from list whose sessions should be deleted
					delete serverNames[otherServers[i]]
			}
			i = sessionInfos.length;
			// delete sessions of servers which cannot be reached any more
			// no additional database search for deletion, because outdated sessions cannot have changed
			while (--i >= 0) {
				if (sessionInfos[i].serverName(_) in serverNames) {
					sessionInfos[i].deleteSelf(_);
					ok = true;				
				}
			}
			if (ok) { // sessions have been delete - therefore get session infos again
				sessionInfos = _remainingLicenses(_, db, data, badgeCodes, session)
			}
		}
	}
	return sessionInfos === null
}

exports.checkConcurrent = checkConcurrent;

/// remainingLicenses
/// computes the number of used badges from sessionInfo entity and checks whether the badges in badgeCodes are still licensed
/// session: current session
/// serverNames: optional parameter, which must be an object; its keys will be filled with the distinct server names from the
/// sessionInfo instances.
/// If the licenses are enough, the function saves the currently used badges into the session context and returns null, 
/// otherwise it returns the list of sessionInfos for further investigations.
function _remainingLicenses(_, db, parsedData, badgeCodes, session, serverNames) {
	var badgeCount = {};
	// fill maximal badge numbers from license
	Object.keys(parsedData.badges).map(function(key) {
		badgeCount[key] = parsedData.badges[key].max;
	})
	console.log("Total "+util.format(badgeCount))
	// count already used badges
	var sessionInfos = db.fetchInstances(_, db.model.getEntity("sessionInfo"), null);			
	var i = sessionInfos.length;
	while (--i >= 0) {
		var sid = sessionInfos[i].sid(_);
		if (serverNames)
			serverNames[sessionInfos[i].serverName(_)]  = "";
		var badges = sessionInfos[i].badge(_);
		// console.log(sid+" "+badges+" "+sessionInfos[i].serverName(_))
		if (badges && sid !== session.id) {
			badges = badges.split(',');
			var j = badges.length;
			while (--j >= 0)
				badgeCount[badges[j]]--									
		}
	}
	console.log("Remaining "+util.format(badgeCount))
	for (var badge in badgeCodes) {
		if (!(badgeCount[badge] >= 1)) {
			console.log("Missing badge "+badge)
			return sessionInfos;
		}
	}	
	console.log("Check OK")
	session.sessionInfo.badge(_, Object.keys(badgeCodes).join(","))
	session.sessionInfo.save(_);
	return null;
}


function _putServerInt(name, path, content, callback) {
	console.log("PUTSERVER "+name)
	var parts = name.split(':');
	var req = http.request({hostname: parts[0], port: parts[1] || 80, path: path, method: 'PUT'}, function(res) {
		res.setEncoding("utf8");
	res.on("data", function(chunk) {
		console.log("BODY "+chunk);
	})});
	req.on("error", callback);
	req.end(content);
	return callback(null, "OK");
}

function _putServer(name, path, content, _) {
	return _putServerInt(name, path, content, _);
}

function _askServerInt(name, path, callback) {
	console.log("Ask server "+name)
	http.get("http://"+name+path, function(res) {
		  // console.log("Got response: " + res.statusCode);
          // res.setEncoding('utf8');
		  res.on('data', function(data) {
			  // console.log('>>>data '+data)
		  });
		  res.on('end', function() {
			  return callback(null, 1*res.statusCode == 200);
		  });
		}).on('error', function(e) {
		  // console.log("Got error: " + e.message);
		  return callback(null, false);
		});
}

// wrapper for use as a future
function _askServer(name, path, _) {
	var res = _askServerInt(name, path, _);
	return res;
}

exports.licenseChange = function(name, content, session, _) {
	// verify license and store it
	if (!_manageLicenseData(_, [content]))
		throw new Error(locale.format(module, "notInit"));
	// inform other servers
	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
	var sessionInfos = db.fetchInstances(_, db.model.getEntity("sessionInfo"), null);			
	var i = sessionInfos.length;
	var servers = {};
	while (--i >= 0) {
		servers[sessionInfos[i].serverName(_)]  = "";
	}
	
	delete servers[session.sessionInfo.serverName(_)];
	servers = Object.keys(servers);
	i = servers.length;
	var futures = [];
	while (--i >= 0) {
		console.log("PUT SERVER "+servers[i])
		futures[i] = _putServer(servers[i], "/licenseupdate", content)			
	}
	i = servers.length;
	while (--i >= 0) {
		console.log("Answer from "+servers[i]+": "+futures[i](_));
	}
}

/// updateLicense
/// update license in native module, but do not store it in database
/// returns a true value when licenses are valid
exports.updateLicense = function(license, _) {
	console.log("Update license")
	try {
		_manageLicenseData(_, [license], true);
		return true;
	} catch (e) { return false;}
}

	
