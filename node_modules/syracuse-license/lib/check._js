"use strict"
var util = require('util')
var adminHelpers = require('syracuse-collaboration/lib/helpers');
var fs = require('fs')
var badgeutil = require('./badge')
var http = require('http')



function checkConcurrent(session, role, _) { 
	// read license content
	if (!fs.existsSync("license.json"))
		return true;
	var	licenseContent = JSON.parse(fs.readFile("license.json", _))
	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
		
	var badgeCodes = {};	
	var badges = role.badges(_).toArray(_);
	var j = badges.length;
	while (--j >= 0) {
		badgeCodes[badges[j].code(_)] = "";
	}

	// console.log("BADG"+util.format(badgeCodes))

	var serverNames = {};
	var sessionInfos = _remainingLicenses(_, db, licenseContent, badgeCodes, session, serverNames);
	if (sessionInfos != null) { // maybe old sessions have been counted
		var ok = false;
		delete serverNames[session.sessionInfo.serverName(_)];
		var otherServers = Object.keys(serverNames);
		if (otherServers.length > 0) {
			var i = otherServers.length;
			var futures = [];
			while (--i >= 0) {
				futures[i] = _askServer(otherServers[i])			
			}
			i = otherServers.length;
			while (--i >= 0) {
				if (futures[i](_) === true) // server could be reached - remove it from list whose sessions should be deleted
					delete serverNames[otherServers[i]]
			}
			i = sessionInfos.length;
			// delete sessions of servers which cannot be reached any more
			// no additional database search for deletion, because outdated sessions cannot have changed
			while (--i >= 0) {
				if (sessionInfos[i].serverName(_) in serverNames) {
					sessionInfos[i].deleteSelf(_);
					ok = true;				
				}
			}
			if (ok) { // sessions have been delete - therefore get session infos again
				sessionInfos = _remainingLicenses(_, db, licenseContent, badgeCodes, session)
			}
		}
	}
	return sessionInfos === null
}

exports.checkConcurrent = checkConcurrent;

/// remainingLicenses
/// computes the number of used badges from sessionInfo entity and checks whether the badges in badgeCodes are still licensed
/// session: current session
/// serverNames: optional parameter, which must be an object; its keys will be filled with the distinct server names from the
/// sessionInfo instances.
/// If the licenses are enough, the function saves the currently used badges into the session context and returns null, 
/// otherwise it returns the list of sessionInfos for further investigations.
function _remainingLicenses(_, db, licenseContent, badgeCodes, session, serverNames) {
	// console.log("REMAINING "+util.format(badgeCodes))
	var badgeCount = {};
	// fill maximal badge numbers from license
	var i = licenseContent.badges.length;
	while (--i >= 0) {
		var badge = licenseContent.badges[i];
		badgeCount[badge.code] = badge.max;
	}
	// console.log("MAX"+util.format(badgeCount))
	// count already used badges
	var sessionInfos = db.fetchInstances(_, db.model.getEntity("sessionInfo"), null);			
	i = sessionInfos.length;
	// console.log("SessionInfos "+i);
	while (--i >= 0) {
		var sid = sessionInfos[i].sid(_);
		if (serverNames)
			serverNames[sessionInfos[i].serverName(_)]  = "";
		var badges = badgeutil.getBadge(sessionInfos[i].badge(_), sid);
		// console.log(sid+" "+badges+" "+sessionInfos[i].serverName(_))
		if (badges && sid !== session.id) {
			badges = badges.split(',');
			var j = badges.length;
			while (--j >= 0)
				badgeCount[badges[j]]--									
		}
	}
	// console.log("MAX1"+util.format(badgeCount))
	for (var badge in badgeCodes) {
		if (!(badgeCount[badge] >= 1)) {
			return sessionInfos;
		}
	}	
	session.sessionInfo.badge(_, badgeutil.markBadge(Object.keys(badgeCodes).join(",")), session.id)
	session.sessionInfo.save(_);
	return null;
}

function _askServerInt(name, callback) {
	// console.log("ASKSERVER "+name)
	http.get("http://"+name+"/licensetest", function(res) {
		  // console.log("Got response: " + res.statusCode);
          // res.setEncoding('utf8');
		  res.on('data', function(data) {
			  // console.log('>>>data '+data)
		  });
		  res.on('end', function() {
			  return callback(null, 1*res.statusCode == 200);
		  });
		}).on('error', function(e) {
		  // console.log("Got error: " + e.message);
		  return callback(null, false);
		});
}

function _askServer(name, _) {
	var res = _askServerInt(name, _);
	// console.log("ASKSERVER "+name+" "+res)
	return res;
}

	
