"use strict"
var util = require('util')
var adminHelpers = require('syracuse-collaboration/lib/helpers');
var fs = require('fs')
var badgeutil = require('./badge')
var http = require('http')

var lic = require('../index')
var l = lic.load('license');





function checkConcurrent(session, role, _) { 
	// read license content
	if (!l) 
		return true;
	var licenses = l.license();
	if (!licenses || !("" in licenses))
		return true;
	var	licenseContent = JSON.parse(licenses[""])
	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
		
	var badgeCodes = {};
	var badges = role.badges(_).toArray(_);
	var j = badges.length;
	while (--j >= 0) {
		badgeCodes[badges[j].code(_)] = "";
	}

	console.log("Badges "+util.format(Object.keys(badgeCodes)))

	var serverNames = {};
	var sessionInfos = _remainingLicenses(_, db, licenseContent, badgeCodes, session, serverNames);
	if (sessionInfos != null) { // maybe old sessions have been counted
		var ok = false;
		delete serverNames[session.sessionInfo.serverName(_)];
		var otherServers = Object.keys(serverNames);
		if (otherServers.length > 0) {
			var i = otherServers.length;
			var futures = [];
			while (--i >= 0) {
				futures[i] = _askServer(otherServers[i], "/licensetest")			
			}
			i = otherServers.length;
			while (--i >= 0) {
				if (futures[i](_) === true) // server could be reached - remove it from list whose sessions should be deleted
					delete serverNames[otherServers[i]]
			}
			i = sessionInfos.length;
			// delete sessions of servers which cannot be reached any more
			// no additional database search for deletion, because outdated sessions cannot have changed
			while (--i >= 0) {
				if (sessionInfos[i].serverName(_) in serverNames) {
					sessionInfos[i].deleteSelf(_);
					ok = true;				
				}
			}
			if (ok) { // sessions have been delete - therefore get session infos again
				sessionInfos = _remainingLicenses(_, db, licenseContent, badgeCodes, session)
			}
		}
	}
	return sessionInfos === null
}

exports.checkConcurrent = checkConcurrent;

/// remainingLicenses
/// computes the number of used badges from sessionInfo entity and checks whether the badges in badgeCodes are still licensed
/// session: current session
/// serverNames: optional parameter, which must be an object; its keys will be filled with the distinct server names from the
/// sessionInfo instances.
/// If the licenses are enough, the function saves the currently used badges into the session context and returns null, 
/// otherwise it returns the list of sessionInfos for further investigations.
function _remainingLicenses(_, db, licenseContent, badgeCodes, session, serverNames) {
	var badgeCount = {};
	// fill maximal badge numbers from license
	var i = licenseContent.badges.length;
	while (--i >= 0) {
		var badge = licenseContent.badges[i];
		badgeCount[badge.code] = badge.max;
	}
	console.log("Total "+util.format(badgeCount))
	// count already used badges
	var sessionInfos = db.fetchInstances(_, db.model.getEntity("sessionInfo"), null);			
	i = sessionInfos.length;
	while (--i >= 0) {
		var sid = sessionInfos[i].sid(_);
		if (serverNames)
			serverNames[sessionInfos[i].serverName(_)]  = "";
		var badges = badgeutil.getBadge(sessionInfos[i].badge(_), sid);
		// console.log(sid+" "+badges+" "+sessionInfos[i].serverName(_))
		if (badges && sid !== session.id) {
			badges = badges.split(',');
			var j = badges.length;
			while (--j >= 0)
				badgeCount[badges[j]]--									
		}
	}
	console.log("Remaining "+util.format(badgeCount))
	for (var badge in badgeCodes) {
		if (!(badgeCount[badge] >= 1)) {
			console.log("Missing badge "+badge)
			return sessionInfos;
		}
	}	
	console.log("Check OK")
	session.sessionInfo.badge(_, badgeutil.markBadge(Object.keys(badgeCodes).join(",")), session.id)
	session.sessionInfo.save(_);
	return null;
}

function _askServerInt(name, path, callback) {
	console.log("Ask server "+name)
	http.get("http://"+name+path, function(res) {
		  // console.log("Got response: " + res.statusCode);
          // res.setEncoding('utf8');
		  res.on('data', function(data) {
			  // console.log('>>>data '+data)
		  });
		  res.on('end', function() {
			  return callback(null, 1*res.statusCode == 200);
		  });
		}).on('error', function(e) {
		  // console.log("Got error: " + e.message);
		  return callback(null, false);
		});
}

// wrapper for use as a future
function _askServer(name, path, _) {
	var res = _askServerInt(name, path, _);
	return res;
}

exports.licenseChange = function(name, content, session, _) {
	lic.insertLicense(name, content, _);
	// inform other servers
	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
	var sessionInfos = db.fetchInstances(_, db.model.getEntity("sessionInfo"), null);			
	var i = sessionInfos.length;
	console.log("SessionInfos "+i);
	var servers = {};
	while (--i >= 0) {
		servers[sessionInfos[i].serverName(_)]  = "";
	}
	
	console.log("Hostname "+session.sessionInfo.serverName(_))
	delete servers[session.sessionInfo.serverName(_)];
	servers = Object.keys(servers);
	i = servers.length;
	console.log("Servers "+i);
	var futures = [];
	while (--i >= 0) {
		futures[i] = _askServer(servers[i], "/licenseupdate")			
	}
	i = servers.length;
	while (--i >= 0) {
		console.log("Answer "+futures[i](_));
	}
}

/// updateLicense
/// read license from database and load it into native module
/// returns a true value when licenses are valid
exports.updateLicense = function(_) {
	console.log("Read licenses from DB")
	var currentLicenses = lic.readLicenses(_);
	return l.license("", currentLicenses[""]);
}

	
