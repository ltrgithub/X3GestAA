"use strict";
var util = require('util');
var adminHelpers = require('syracuse-collaboration/lib/helpers');
var fs = require('streamline-fs');
var http = require('http');

var locale = require("syracuse-core/lib/locale");
var lic = require('../index');
var l = lic.load('license');
var date = require('syracuse-core/lib/types/date');
var config = require('syracuse-main/lib/nodeconfig').config;
var fut = require('streamline/lib/util/future');
var mock = require('syracuse-load/lib/mock');
var hostEntity = require('syracuse-collaboration/lib/entities/host');
var tracer = null;
// var mongodb = require('streamline-mongodb')

var POLICY_FILE = __dirname + "/../../../policy.json";
var PARTNER_FILE = __dirname + "/../../../partner.json";

// number of days before license expiry that a notification will be sent
var NOTIFICATION_INTERVAL = 10;
/// updateFromDB: read license data from database (because database data may have changed) before first session is started
/// also check badge count for named users from database information

function updateFromDB(_) {
	try {
		var licenses = lic.readLicenses(~_, true);
		_manageLicenseData(_, licenses, true, null, true); // force named users badge count
	} catch (e) {
		if (e instanceof Error) // do not log message that there is no database configuration
		{
			console.log("TTTT" + e);
			console.log(util.inspect(e, false, 10));
		}
	}
}

exports.updateFromDB = updateFromDB;

/// getParsedLicense: get parsed license data

function getParsedLicense(_) {
	var data = _manageLicenseData(_);
	if (data) return data[1];
	return null;
}
exports.getParsedLicense = getParsedLicense;

function deleteLicense(partnerId, productCode, productVersion, policyCode, policyVersion, diagnoses, _) {
	_manageLicenseData(_, [], false, diagnoses, false, {
		partnerId: partnerId,
		productCode: productCode,
		productVersion: productVersion,
		policyCode: policyCode,
		policyVersion: policyVersion
	});
	propagateChange(_);
}
exports.deleteLicense = deleteLicense;

/// getRawLicense: get list of license strings exactly in the format in which they have been provided to the license system

function getRawLicense(_) {
	var data = _manageLicenseData(_);
	if (data) return data[0];
	return null;
}
exports.getRawLicense = getRawLicense;

// _manageLicenseData: retrieve and store license data
//  newLicenses: optional array of licenses or policy files which will be added to the existing data and will overwrite existing data of the same kind
//  doNotStore: optional parameter which indicates that the license data should not be stored in the database
// checkNamed: check count of badges of named users even if it is not the first invocation
// deleteProfile: Data for license which should be deleted

function _manageLicenseData(_, newLicenses, doNotStore, diagnoses, checkNamed, deleteProfile) {
	if (!l) return null;
	try {
		var data = l.license();
	} catch (e) {
		throw new Error(locale.format(module, "licError", e.toString()));
	}
	if (!data) {
		return null;
	}
	var firstTime = !data[1];
	if (firstTime) { // first invocation: read policy and partner file
		newLicenses = newLicenses || [];
		if (fs.existsSync(POLICY_FILE)) newLicenses.push(fs.readFile(POLICY_FILE, "utf8", _));
		if (fs.existsSync(PARTNER_FILE)) newLicenses.push(fs.readFile(PARTNER_FILE, "utf8", _));
	}
	try {
		var result = _parseLicenses(data, newLicenses, diagnoses, deleteProfile);
	} catch (e) {
		console.error(e.stack);
		throw new Error(locale.format(module, "LicenseError", "" + e));
	}
	// named users
	if (firstTime || result !== data || checkNamed) { // change in licenses or first time or explicitly required
		var ok = _checkNamedInt(_, result[1], null, diagnoses);
		if (!ok && !firstTime) // too many named users
			throw new Error(locale.format(module, "tooManyUsers"));
		result[1].namedUsers = ok;
	}
	if (result === data && diagnoses) diagnoses.push({
		severity: "warning",
		message: locale.format(module, "NoNewLicense")
	});
	// store new content
	try {
		l.license(result);
	} catch (e) {
		throw new Error(locale.format(module, "licError", e.toString()));
	}

	if (!doNotStore && result !== data) { // change in licenses: update contents in database
		_storeDB(result[0], _);
		var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
		// search for license notification event
		var whereClause = '(code eq "license")';
		var event = db.fetchInstance(_, db.model.getEntity(_, "notificationEvent"), {
			sdataWhere: whereClause
		});
		if (event) {
			// schedule license expiries
			var scheduleData = result[1].validLicenses.map(function(entry) {
				var executionTime = new Date(entry.expiryDate).getTime();
				executionTime -= 86400000 * NOTIFICATION_INTERVAL; // multiply number of days with milliseconds per day 
				entry.daysBefore = NOTIFICATION_INTERVAL;
				return [entry.partnerId + "_" + entry.productCode + "_" + entry.productVersion + "_" + entry.policyCode + "_" + entry.policyVersion, executionTime, entry];
			});
			tracer && tracer("Schedule data " + util.format(scheduleData));
			// update scheduler and database. Notification of other servers works already via license notification mechanism.
			event.scheduleAll(_, scheduleData, 1);
		}
	}
	if (firstTime && fs.existsSync(lic.LICENSE_FILE)) {
		var renamed = lic.LICENSE_FILE.replace(/\w+$/, "bbb");
		try { // remove renamed file if existent 
			fs.unlink(renamed, _);
		} catch (e) {}
		fs.rename(lic.LICENSE_FILE, renamed, _);
	}
	return result;
}

// converts keys from underscore to dash, e. g. en_US to en-US

function convertTitle(title) {
	if (title && (title instanceof Object)) {
		Object.keys(title).forEach(function(key) {
			var keyOrig = key;
			if (/^[a-z][a-z]_[A-Z][A-Z]$/.test(key)) {
				key = key.substr(0, 2) + "-" + key.substr(3);
			}
			key = key.toLowerCase();
			if (keyOrig !== key) {
				title[key] = title[keyOrig];
				delete title[keyOrig];
			}
		});
		if (!("default" in title)) {
			title["default"] = title["en-us"];
		}
	}
	return title;
}
exports.convertTitle = convertTitle;

// update raw license data in database (replace old list of licenses with new list)

function _storeDB(licenses, _) {
	console.log("STORE DB");
	var db = lic.getDatabase();

	// Establish connection to db
	try {
		db = db.open(~_);
		var collection = db.createCollection('license', ~_);
		collection.remove({}, {
			safe: true,
			fsync: true
		}, ~_);

		var ins = licenses.map(function(item) {
			return {
				text: item
			};
		});
		collection.insert(ins, ~_);
	} finally {
		db.close();
	}
	// update badge information
	console.log("STORE BADGES");
	require('syracuse-collaboration/lib/entities/badge').updateBadges(_);
	console.log("ST BADGES");
}

/* central function for parsing license data and putting them together
 * parameters: data: return value from license() function of native module
 *             newLicenses: new license, policy, partner data (may be equal to already existing data)
 *             diagnoses: optional parameter: add diagnostic warning messages about ignored modules and badges
 *             deleteProfile: product code, version, policy code, version of a license which should be deleted
 * structure of parsed license data:
 * - nextCheck: new computation of data necessary after this date (e. g. "2012-01-31")
 * - previousCheck: new computation of data necessary before this date (e. g. "2012-01-31")
 * - keyFunctions: list of all license protected X3 functions of all modules
 * - badges: object with keys being badge code and values being objects with keys max:
 *    maximal number of allowed badges, func: functions released by badge, title: badge.title};
 *    for each badge code the maximum number and the functions which are released by this badge
 * - expires: list of all expiring modules: module code, expire date, partnerId, sorted ascending by expire date
 * - concurrent: licensing model: concurrent (true) or named user (false)
 * - licensedTo: to whom the license has been issued
 * - partners: ID's of partners for whom a license is installed
 * - maxSessions: maximum number of sessions
 * - namedUsers: true: licenses are sufficient for named users, false: licenses are not sufficient for named users
 * - validLicenses: array of data for valid licenses, for each license an object with attributes:
 *	 expiryDate (end of validity in ISO date format), partnerId, productCode, productTitle, productVersion, policyCode, policyTitle, policyVersion.
 */

function _parseLicenses(data, newLicenses, diagnoses, deleteProfile) {
	if (!Array.isArray(data) || !Array.isArray(data[0])) return null;
	var licenses = data[0];
	var currentDate = date.today();
	var currentDateString = currentDate.toString();
	if (!deleteProfile && (!newLicenses || newLicenses.length === 0) && data[1] && (data[1].nextCheck >= currentDateString && data[1].previousCheck <= currentDateString)) return data;
	var licenseData = {};
	var policyData = {};
	var grouped = {};
	var partners = {}; // partner names
	var newLic = false; // real changes with new licenses
	licenses.forEach(function(license) {
		var parsed = JSON.parse(license);
		if (parsed.fileType !== "Partner") {
			if (!parsed.product || !parsed.policy) throw new Error(locale.format(module, "noProductPolicy"));
			var key = (parsed.partnerId || "") + "\0" + parsed.product.code + "\0" + parsed.product.version + "\0" + parsed.policy.code + "\0" + parsed.policy.version;
		} else {
			var key = (parsed.partnerId || "");
		}
		partners[parsed.partnerId || ""] = 0;
		var type = parsed.fileType + " " + key;
		if (parsed.fileType === "License") {
			if (deleteProfile && deleteProfile.partnerId == parsed.partnerId && deleteProfile.productCode === parsed.product.code && deleteProfile.productVersion === parsed.product.version && deleteProfile.policyCode === parsed.policy.code && deleteProfile.policyVersion === parsed.policy.version) {
				return; // this license should be deleted
			}
			_checkFormat(parsed.validity, parsed, true);
			licenseData[key] = parsed;
		} else if (parsed.fileType === "Policy") policyData[key] = parsed;
		else if (parsed.fileType !== "Partner") throw new Error(locale.format(module, "wrongType", parsed.fileType));

		grouped[type] = license.trim();
	});
	// insert new licenses
	if (newLicenses) {
		newLicenses.forEach(function(newLicense) {
			if (!newLicense) return;
			newLicense = newLicense.toString();
			var parsed = JSON.parse(newLicense);
			if (parsed.fileType !== "Partner") {
				if (!parsed.product || !parsed.policy) throw new Error(locale.format(module, "noProductPolicy"));
				var key = (parsed.partnerId || "") + "\0" + parsed.product.code + "\0" + parsed.product.version + "\0" + parsed.policy.code + "\0" + parsed.policy.version;
			} else {
				var key = (parsed.partnerId || "");
			}
			partners[parsed.partnerId || ""] = 0;
			var type = parsed.fileType + " " + key;
			if (grouped[type] !== newLicense.trim()) {
				newLic = true;
				if (parsed.fileType === "License") {
					_checkFormat(parsed.validity, parsed, true);
					licenseData[key] = parsed;
				} else if (parsed.fileType === "Policy") {
					policyData[key] = parsed;
				} else if (parsed.fileType !== "Partner") throw new Error(locale.format(module, "wrongType", parsed.fileType));
				grouped[type] = newLicense;

			}
		});
	}
	if (!deleteProfile && !newLic && data[1] && (data[1].nextCheck >= currentDate && data[1].previousCheck <= currentDate)) return data;
	// compute new parsed data
	if (newLic || deleteProfile) {
		var k = Object.keys(grouped).map(function(key) {
			return grouped[key];
		});
		data = [k, {}];
	} else {
		data[1] = {};
	}
	var infos = data[1];
	var keyFunctions = {};
	var policyItems = {}; // object with licensed types in policy files (modules, activity codes etc.) as keys and objects as values
	// parse the licenses
	var keys = Object.keys(policyData).sort(); // Sage license should come first
	var nextCheck = date.today().addYears(1000);
	var previousCheck = date.today().addYears(-1000);
	var expires = [];
	infos.badges = {};
	infos.namedUsers = true;
	infos.validLicenses = [];
	// loop over all policies
	keys.forEach(function(key) {
		var parsedPolicy = policyData[key];
		var parsedLicense = licenseData[key]; // there may be a license for this policy
		if (parsedLicense) {
			var validFrom = date.parse(parsedLicense.validity[0]);
			var validTo = date.parse(parsedLicense.validity[1]);
			var tmpParsedLicense = parsedLicense;
			// check validity of license
			if (validFrom.compare(currentDate) > 0) {
				// license not yet valid
				if (validFrom.compare(nextCheck) <= 0) {
					nextCheck = validFrom.addDays(-1);
					parsedLicense = null;
				} else {
					if (validFrom.compare(previousCheck) > 0) previousCheck = validFrom;
				}
			}
			if (validTo.compare(currentDate) < 0) {
				// license not valid any more
				if (validTo.compare(previousCheck) >= 0) {
					previousCheck = validTo.addDays(1);
					parsedLicense = null;
				} else {
					if (validTo.compare(nextCheck) < 0) nextCheck = validTo;
				}
			}
			// when there are several Sage licenses, only valid licenses should give data (or a first non-valid license)
			if (key.substr(0, 1) === "\0" && (parsedLicense || !infos.licensedTo)) { // only Sage session control setting is relevant, not of partner licenses 
				infos.concurrent = (tmpParsedLicense.sessionControl === "concurrent");
				infos.licensedTo = tmpParsedLicense.licensedTo;
				if (tmpParsedLicense.maxSessions === 0) infos.maxSessions = 0;
				else infos.maxSessions = Math.abs(tmpParsedLicense.maxSessions || 1);
			}
			if (parsedLicense) {
				var licenseInfos = {
					expiryDate: parsedLicense.validity[1],
					partnerId: parsedPolicy.partnerId,
					productCode: parsedPolicy.product.code,
					productTitle: convertTitle(parsedPolicy.product.title),
					productVersion: parsedPolicy.product.version,
					policyCode: parsedPolicy.policy.code,
					policyTitle: convertTitle(parsedPolicy.policy.title),
					policyVersion: parsedPolicy.policy.version
				};
				infos.validLicenses.push(licenseInfos);
			};
		}
		["modules", "activityCodes", "languages", "legislations", "parameterKits"].forEach(function(item) {
			policyItems[item] = policyItems[item] || {};
			var policyItems0 = policyItems[item];
			if (!parsedPolicy[item]) return; // nothing to iterate
			var licensedItems = {};
			if (parsedLicense && parsedLicense[item]) {
				parsedLicense[item].forEach(function(item0) {
					_checkFormat(item0.validity, parsedLicense, false);
					licensedItems["$$" + item0.code] = item0;
				});
			}
			parsedPolicy[item].forEach(function(item0) {
				var code = item0.code;
				if (code in policyItems0) { // does this item occur in another policy file?
					if (diagnoses) diagnoses.push({
						severity: "warning",
						message: locale.format(module, "ignored" + item, code, parsedPolicy.partnerId)
					});
					return;
				}
				policyItems0[code] = 0;
				if (item0.condition === "never" || !parsedLicense) {
					return; // never licensed
				}
				if (item0.condition === "always") {
					policyItems0[code] = 1; // always allowed
					return;
				}
				// consult license for licensed items
				if (!parsedLicense[item]) return; // nothing in license
				var item1 = licensedItems["$$" + code];
				if (item1) {
					// corresponding item found in license
					var valid = true; // assume that it is licensed. Now check dates
					if (item1.validity) {
						_checkFormat(item1.validity, parsedLicense, false);
						if (item1.validity[0]) {
							var validFrom = date.parse(item1.validity[0]);
							if (validFrom.compare(currentDate) > 0) {
								// item not yet valid
								if (validFrom.compare(nextCheck) <= 0) {
									nextCheck = validFrom.addDays(-1);
								}
								valid = false;
							} else {
								if (validFrom.compare(previousCheck) > 0) previousCheck = validFrom;
							}
						}
						if (item1.validity[1]) {
							var validTo = date.parse(item1.validity[1]);
							if (validTo.compare(currentDate) < 0) {
								// item not valid any more
								if (validTo.compare(previousCheck) >= 0) {
									previousCheck = validTo.addDays(1);
								}
								valid = false;
							} else {
								if (validTo.compare(nextCheck) < 0) nextCheck = validTo;
							}
							if (item === "modules" && valid) expires.push({
								module: item1.code,
								type: item,
								code: item1.code,
								expire: item1.validity[1],
								partner: parsedLicense.partnerId
							});
						}
					}
					// module is licensed
					if (valid) policyItems0[code] = 1;
				};
				if (item === "modules") {
					var licensed = policyItems0[code]; // mark key functions for modules
					item0.keyFunctions.forEach(function(fkt) {
						if (!(fkt in keyFunctions)) keyFunctions[fkt] = licensed;
						else {
							// double key function
							if (diagnoses) diagnoses.push({
								severity: "warning",
								message: locale.format(module, "ignoredKeyFunction", fkt, parsedLicense.partnerId)
							});
						}
					});
				}
			});
		});
		// badges should only unlock licensed key functions
		parsedPolicy.badges.forEach(function(badge) {
			var code = badge.code;
			if (code in infos.badges) {
				if (diagnoses) diagnoses.push({
					severity: "warning",
					message: locale.format(module, "ignoredB", code, parsedPolicy.partnerId)
				});
				return;
			}
			var max = 0;
			if (parsedLicense && parsedLicense.badges) {
				parsedLicense.badges.forEach(function(badge1) {
					if (badge1.code === code) {
						max = badge1.max;
					}
					return;
				});
			};
			var funcs = [];
			infos.badges[code] = {
				max: max,
				func: funcs,
				allFunc: badge.functions.join(","),
				title: convertTitle(badge.title)
			};
			badge.functions.forEach(function(fkt) {
				if (keyFunctions[fkt]) { // function belongs to licensed module
					funcs.push(fkt);
				}
			});
		});
	});
	infos.keyFunctions = Object.keys(keyFunctions);
	infos.activityCodes = policyItems.activityCodes || {};
	infos.languages = policyItems.languages || {};
	infos.legislations = policyItems.legislations || {};
	infos.parameterKits = policyItems.parameterKits || {};
	infos.expires = expires.sort(function(a, b) {
		return (a.expire > b.expire ? 1 : (a.expire === b.expire ? 0 : -1));
	});
	infos.nextCheck = nextCheck.toString();
	infos.previousCheck = previousCheck.toString();
	infos.partners = Object.keys(partners).sort();
	return data;
}

// Checks format of date strings

function _checkFormat(validity, parsed, errorNull) {
	if (!validity) {
		if (!errorNull) return;
		throw new Error(locale.format(module, "noValidityGiven", parsed.fileType, parsed.product.code, parsed.product.version));
	}
	if (!validity[0]) {
		if (errorNull) throw new Error(locale.format(module, "noValidityFromGiven", parsed.fileType, parsed.product.code, parsed.product.version));
	} else {
		if (!/^\d\d\d\d-[01]\d-[0-3]\d$/.test(validity[0])) throw new Error(locale.format(module, "validityFromFormat", validity[0], parsed.fileType, parsed.product.code, parsed.product.version));
	}
	if (!validity[1]) {
		if (errorNull) throw new Error(locale.format(module, "noValidityToGiven", parsed.fileType, parsed.product.code, parsed.product.version));
	} else {
		if (!/^\d\d\d\d-[01]\d-[0-3]\d$/.test(validity[1])) throw new Error(locale.format(module, "validityToFormat", validity[1], parsed.fileType, parsed.product.code, parsed.product.version));
	}
}


exports._p = _parseLicenses;

// returns an object which contains all unlicensed key functions and the list of partner ID's for which a license has been installed.
// session is the current session

function getX3LicenseInfo(session, _) {
	// read license content
	var data = getParsedLicense(_);
	var licensed = {}; // X3 functions which are allowed by at least one badge
	var badgeString = session.sessionInfo.badge(_);
	if (badgeString) {
		var parts = badgeString.split(",");
		parts.forEach(function(badge) {
			if (badge in data.badges) {
				var funcs = data.badges[badge].func || [];
				funcs.forEach(function(fkt) {
					licensed[fkt] = "";
				});
			}
		});
	}
	// return X3 functions which are not allowed by at least one badge
	var func = data.keyFunctions.filter(function(item) {
		return !(item in licensed);
	});
	return {
		functions: func,
		licenses: data.partners,
		licensedTo: data.licensedTo
	};
}

exports.getX3LicenseInfo = getX3LicenseInfo;

// counts the badges of all users (only important for named users)

function _checkNamedInt(_, parsed, inst, diagnoses) {
	if (!parsed || parsed.concurrent) return true;
	// console.log("RRRRRRRR "+util.format(parsed))
	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);

	var cursor = db.createCursor(_, db.model.getEntity(_, "user"), null);
	var user;
	var usedBadges = {};
	while (user = cursor.next(_)) {
		var badgeObject = {};
		// console.log("USER "+user.$uuid)
		if (inst && user.getEntity(_) === inst.getEntity(_) && user.$uuid === inst.$uuid) user = inst;
		if (!user.active(_)) continue;
		var groups = user.groups(_).toArray(_, true); // do not consider instances which have been marked for deletion
		var j = groups.length;
		while (--j >= 0) {
			var group = groups[j];
			if (inst && group.getEntity(_) === inst.getEntity(_) && group.$uuid === inst.$uuid) group = inst;
			var role = group.role(_);
			if (inst && role.getEntity(_) === inst.getEntity(_) && role.$uuid === inst.$uuid) role = inst;
			if (role) {
				var badges = role.badges(_).toArray(_, true);
				var l = badges.length;
				while (--l >= 0) {
					badgeObject[badges[l].code(_)] = "";
				}
			}
		}
		// console.log(user.login(_)+" "+util.format(badgeObject))
		Object.keys(badgeObject).forEach(function(badge) {
			if (badge in usedBadges) usedBadges[badge]++;
			else usedBadges[badge] = 1;
		});
	}
	var ok = true;
	// compare numbers of badges in license and for users
	Object.keys(usedBadges).forEach(function(badge) {
		if (badge in parsed.badges) {
			var diff = usedBadges[badge] - parsed.badges[badge].max;
			if (diff > 0) {
				if (diagnoses) {
					diagnoses.push({
						severity: "error",
						message: locale.format(module, "namedTooMuch", badge, diff)
					});
				}
				ok = false;
				console.log(badge + " more " + usedBadges[badge] + " " + parsed.badges[badge].max);
			} else console.log(badge + " OK " + usedBadges[badge] + " " + parsed.badges[badge].max);
		} else {
			if (diagnoses) {
				diagnoses.push({
					severity: "warning",
					message: locale.format(module, "unlicensedBadge", badge)
				});
			}
			ok = false;
			console.log(badge + " more2 " + usedBadges[badge]);
		}
	});
	console.log("NAMED OK? " + ok);
	return ok;

}

// check number of named user licenses
// inst: optional instance of an entity (which is about to be stored). 
//       When it is provided, data will be taken from this instance rather than from the database instance
// messages: optional message array: stores information whether
// return code: true iff there has been a change in the information that named user licenses are sufficent.

function checkNamed(_, inst, messages) {
	var data = _manageLicenseData(_);
	if (!data || data[1].concurrent) return false;
	var ok = _checkNamedInt(_, data[1], inst, messages);
	if (ok != data[1].namedUsers) {
		data[1].namedUsers = ok;
		// store changed parsed content in license module
		try {
			l.license(data);
		} catch (e) {
			throw new Error(locale.format(module, "licError", e.toString()));
		}
		return true;
	}
	return false;
}

exports.checkNamed = checkNamed;

// check number of concurrent licenses, considering the data from the session table together with the data of the
// current session and the intended (new) 

function checkConcurrent(session, role, userName, _) {
	// read license content
	var data = getParsedLicense(_);
	if (!data || !data.concurrent) return true;
	var db = adminHelpers.AdminHelper.getCollaborationOrm(_);

	var badgeCodes = {};
	var badges = role.badges(_).toArray(_);
	var j = badges.length;
	while (--j >= 0) {
		badgeCodes[badges[j].code(_)] = "";
	}

	// console.log("Badges "+util.format(badgeCodes))

	var serverNames = {};
	var sessionInfos = _remainingLicenses(_, db, data, badgeCodes, session, userName, serverNames);
	if (sessionInfos != null) { // maybe old sessions have been counted
		console.log("2ND");
		var ok = false;
		if (config.mockServer) {
			// ask nanny process for up-to-date information
			var data = hostEntity.collectClusterData(_);
			if (!data) serverNames = {};
			else {
				data.forEach(function(host) {
					console.log("HOST " + host.hostname + " " + host.status + " " + host.children);
					var hostName = host.hostname;
					if (host.status * 1 === 3) {
						for (var i = host.children - 1; i >= 0; i--) {
							delete serverNames[hostName + ":N" + i];
							console.log("Delete " + hostName + ":N" + i);
						}
					}
				});
			}
		} else {
			delete serverNames[session.sessionInfo.serverName(_)];
			var otherServers = Object.keys(serverNames);
			if (otherServers.length > 0) {
				var i = otherServers.length;
				var futures = [];
				while (--i >= 0) {
					if (/\:\d+$/.test(otherServers[i])) { // contact only real servers
						futures[i] = _putServer(!_, otherServers[i], "GET", "/licensetest");
					}
				}
				i = otherServers.length;
				while (--i >= 0) {
					try {
						if (futures[i] && futures[i](_) === true) // server could be reached - remove it from list whose sessions should be deleted
							delete serverNames[otherServers[i]];
					} catch (e) {
						// ignore exceptions
					}
				}
			}
		}
		var i = sessionInfos.length;
		// delete sessions of servers which cannot be reached any more
		// no additional database search for deletion, because outdated sessions cannot have changed
		while (--i >= 0) {
			if (sessionInfos[i].serverName(_) in serverNames) {
				sessionInfos[i].deleteSelf(_);
				ok = true;
			}
		}
		if (ok) { // sessions have been deleted - therefore get session infos again
			sessionInfos = _remainingLicenses(_, db, data, badgeCodes, session, userName);
		}
	}
	return sessionInfos === null;
}

exports.checkConcurrent = checkConcurrent;

function propagateChange(_) {
	_propagate(_, "GET", "/licensecheck");
}
exports.propagateChange = propagateChange;

/// remainingLicenses
/// computes the number of used badges from sessionInfo entity and checks whether the badges in the badgeCodes are still licensed
/// session: current session
/// serverNames: optional parameter, which must be an object; its keys will be filled with the distinct server names from the
/// sessionInfo instances (the key for the current session is not set).
/// userName: if not null, take user name from here and not from session
/// If the licenses are enough, the function saves the currently used badges into the session context and returns null, 
/// otherwise it returns the list of sessionInfos for further investigations.

function _remainingLicenses(_, db, parsedData, badgeCodes, session, userName, serverNames) {
	var sessionInfos = db.fetchInstances(_, db.model.getEntity(_, "sessionInfo"), null);
	var i = sessionInfos.length;

	// count already used badges (grouped by client ID and user)
	var sessionBadges = {};
	while (--i >= 0) {
		var sid = sessionInfos[i].sid(_);
		if (sid === session.id || !sessionInfos[i].badge(_)) continue;
		if (serverNames) serverNames[sessionInfos[i].serverName(_)] = "";
		var badges = sessionInfos[i].badge(_).split(',');
		var clientId = sessionInfos[i].clientId(_) + "_" + sessionInfos[i].userName(_);
		var j = badges.length;
		while (--j >= 0) {
			var badge = badges[j];
			if (!badge) continue;
			if (!(badge in parsedData.badges)) {
				console.log("No licensed badge " + badges[j]);
				return sessionInfos;
			}
			if (!sessionBadges[badge]) sessionBadges[badge] = {};
			if (!(clientId in sessionBadges[badge])) sessionBadges[badge][clientId] = 1;
			else sessionBadges[badge][clientId]++;
		}
	}

	// add data of current session
	var clientId = session.clientId + "_" + (userName || session.sessionInfo.userName(_));
	for (var badge in badgeCodes) {
		if (!sessionBadges[badge]) sessionBadges[badge] = {};
		if (!(clientId in sessionBadges[badge])) sessionBadges[badge][clientId] = 1;
		else sessionBadges[badge][clientId]++;
	}

	// find out total usage
	for (var badge in parsedData.badges) {
		var count = 0;
		if (parsedData.maxSessions > 0) {
			for (var clId in sessionBadges[badge]) {
				count += Math.ceil(sessionBadges[badge][clId] / parsedData.maxSessions);
			}
		} else {
			if (sessionBadges[badge]) count = Object.keys(sessionBadges[badge]).length;
		}
		console.log(badge + " " + count);
		if (count > parsedData.badges[badge].max) {
			console.log("Missing badge " + badge);
			return sessionInfos;
		}
	}
	console.log("Check OK");
	session.sessionInfo.badge(_, Object.keys(badgeCodes).join(","));
	session.sessionInfo.save(_);
	return null;
}

// exports.psi = _putServerInt;
var _putServer = _(function(callback, name, method, path, content) {
	var parts = name.split(':');
	var options = {
		hostname: parts[0],
		port: parts[1] || 80,
		path: path,
		method: method
	};
	var req = http.request(options, function(res) {
		res.setEncoding("utf8");
		res.on("data", function(chunk) {});
		res.on("end", function(chunk) {
			return callback(null, 1 * res.statusCode == 200);
		});
	});
	req.on("error", function(e, d) {
		console.log("REQUESTERROR" + e + " " + name + " " + path + " " + content);
		return callback(null, false);
	});
	if (content) req.end(content);
	else req.end();
	// return callback(null, 1*res.statusCode == 200);		
}, 0);

exports.pS = _putServer; // !!!! TODO

function _propagate(_, method, path, content) {
	if ("mockServer" in config) {
		var options = {
			path: "/nannyCommand/notifyAll" + path,
			method: method,
			hostname: "",
			port: 0,
			headers: {}
		};
		options.headers[mock.BALANCER_HEADER] = config.port;
		try {
			console.log(mock.simpleRequest(config.mockServer.mockClient, options, content, _));
		} catch (e) {
			console.log("Error " + e);
		}
	} else {
		var db = adminHelpers.AdminHelper.getCollaborationOrm(_);
		var sessionInfos = db.fetchInstances(_, db.model.getEntity(_, "sessionInfo"), null);
		var i = sessionInfos.length;
		var servers = {};
		while (--i >= 0) {
			servers[sessionInfos[i].serverName(_)] = "";
		}
		delete servers[config.servername];
		servers = Object.keys(servers);
		i = servers.length;
		var futures = [];
		while (--i >= 0) {
			if (/\:\d+$/.test(servers[i])) { // notify only servers with real ports
				console.log("PUT SERVER " + servers[i]);
				futures[i] = _putServer(!_, servers[i], method, path, content);
			}
		}
		i = servers.length;
		while (--i >= 0) {
			if (futures[i]) console.log("Answer from " + servers[i] + ": " + futures[i](_));
		}
	}
}

/// splits license data from input into license files and removes unnecessary data around them
// Redundant code: this also appears in syracuse-load/lib/balancer._js
exports._s = function(content) {
	// remove beginning and end
	content = content.replace(/^[^\{\}]*\{/, "").replace(/\}[^\{\}]*$/, "");
	// split into parts and add curly braces
	var parts = content.split(/\}[^\{\},]*[\n\r][^\{\},]*\{/).map(function(part) {
		return "{" + part + "}";
	});
	return parts;
};

exports.licenseChange = function(content, session, diagnoses, _) {
	// verify license and store it
	console.log("MANAGE");
	var data = _manageLicenseData(_, exports._s(content), false, diagnoses);
	if (!data) throw new Error(locale.format(module, "notInit"));
	console.log("ERROR");
	// inform other servers
	_propagate(_, "PUT", "/licenseupdate", content);
};

/// updateLicense
/// update license in native module, but do not store it in database
/// returns a true value when licenses are valid
exports.updateLicense = function(license, _) {
	console.log("Update license");
	try {
		_manageLicenseData(_, [license], true);
		// just update the scheduler without database changes
		require('syracuse-collaboration/lib/entities/notificationTime').scheduleAll(_);
		return true;
	} catch (e) {
		return false;
	}
};