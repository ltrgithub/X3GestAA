"use strict";

var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var globals = require('streamline-runtime').globals;
var xmlCrypto = require('xml-crypto');
var dom = require('xmldom').DOMParser;
var select = xmlCrypto.xpath;
var SignedXml = xmlCrypto.SignedXml;
var FileKeyInfo = xmlCrypto.FileKeyInfo;
var locale = require('streamline-locale');


var certtools;
var tracer; // = console.log;

function getAlgorithm(algorithm0) {
	switch (algorithm0) {
		case "RSA-SHA256":
			return "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256";
			break;
		case "RSA-SHA1":
			return "http://www.w3.org/2000/09/xmldsig#rsa-sha1";
			break;
		default:
			throw new Error(locale.format(module, "unsupportedAlgorithm", algorithm0));
	}
}

function signXml(_, xml, data, path, keyInfoProvider) {
	var signedInfo;
	var algorithm0 = data.signatureAlgorithm || "RSA-SHA256";
	var algorithm = getAlgorithm(algorithm0);
	tracer && tracer("Algorithm selected:", algorithm);
	var DUMMYSIGNATURE = "ABCDEFGHABCDEFGH";
	// in order to use the standard (asynchronous) signing function of Syracuse, the normal function of xml-crypto will only return a dummy
	// signature, and it will be replaced with the real signature later on
	var signFunction = function() {
		this.getSignature = function(signedInfo0, signingKey) {
			signedInfo = signedInfo0;
			// since this call must be synchronous, return a dummy signature first and compute the real signature later
			return DUMMYSIGNATURE;
		};
		this.getAlgorithmName = function() {
			return algorithm;
		};
	};

	// save normal signature algorithm
	var old = SignedXml.SignatureAlgorithms[algorithm];
	try {
		SignedXml.SignatureAlgorithms[algorithm] = signFunction;
		var sig = new SignedXml();
		sig.signatureAlgorithm = algorithm;
		if (keyInfoProvider) sig.keyInfoProvider = keyInfoProvider;
		sig.addReference(path);
		sig.computeSignature(xml);
		xml = sig.getSignedXml();
	} finally {
		SignedXml.SignatureAlgorithms[algorithm] = old;
	}
	certtools = certtools || require('syracuse-load/lib/certTools');

	var digest = certtools.sign(_, data.certificate.name(_), algorithm0, signedInfo, {
		data_encoding: 'utf8',
		output_encoding: 'base64'
	}, globals.context.tenantId);

	// replace dummy signature with real signature
	xml = xml.replace("<SignatureValue>" + DUMMYSIGNATURE + "</SignatureValue>", "<SignatureValue>" + digest + "</SignatureValue>");
	tracer && tracer("Signed xml " + xml);
	return xml;
}


function fetchCertificate(_, name) {
	var db = adminHelper.getCollaborationOrm(_);
	var model = db.model;
	var entity = model.getEntity(_, "certificate");
	var filter = {
		jsonWhere: {
			name: name
		}
	};

	var cert = db.fetchInstance(_, entity, filter);
	if (!cert) throw new Error(locale.format(module, 'errCertInstNotFound', name));
	return cert;
}

exports.sign = function(_, xml, rootElement, options) {
	options = options || {};
	var cert = options.certificate;
	if (!cert && options.certificateName) {
		cert = fetchCertificate(_, options.certificateName);
	}

	var data = {
		certificate: cert,
		signatureAlgorithm: options.signatureAlgorithm
	};
	return signXml(_, xml, data, "//*[local-name(.)='" + rootElement + "']", options.keyInfoProvider);
}



exports.verify = function(_, xml, customKeyInfo) {
	var doc = new dom().parseFromString(xml);

	var signature = select(doc, "/*/*[local-name(.)='Signature' and namespace-uri(.)='http://www.w3.org/2000/09/xmldsig#']")[0];
	var sig = new SignedXml();
	sig.keyInfoProvider = customKeyInfo;
	sig.loadSignature(signature.toString());

	var res = sig.checkSignature(xml);
	if (!res) console.log(sig.validationErrors);

	return res;
}