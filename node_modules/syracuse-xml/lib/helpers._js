"use strict";

var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var globals = require('streamline-runtime').globals;
var xmlCrypto = require('xml-crypto');
var dom = require('xmldom').DOMParser;
var select = xmlCrypto.xpath;
var SignedXml = xmlCrypto.SignedXml;
var FileKeyInfo = xmlCrypto.FileKeyInfo;
var locale = require('streamline-locale');
var jsx509 = require('jsx509');


var certtools;
var tracer; // = console.log;

function getAlgorithm(algorithm0) {
	switch (algorithm0) {
		case "RSA-SHA256":
			return "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256";
			break;
		case "RSA-SHA1":
			return "http://www.w3.org/2000/09/xmldsig#rsa-sha1";
			break;
		default:
			throw new Error(locale.format(module, "unsupportedAlgorithm", algorithm0));
	}
}

function fetchCertificate(_, name) {
	var db = adminHelper.getCollaborationOrm(_);
	var model = db.model;
	var entity = model.getEntity(_, "certificate");
	var filter = {
		jsonWhere: {
			name: name
		}
	};

	var cert = db.fetchInstance(_, entity, filter);
	if (!cert) throw new Error(locale.format(module, 'errCertInstNotFound', name));
	return cert;
}

/// Signs a given XML string. Parameters:
///  xml: string with XML
///  path: xpath expression to the part of XML which should be signed (may be empty for root element of XML)
///  name: name of certificate in certificate entity (must be certificate with private key)
///  options: Object with additional information for signing:
///     signatureAlgorithm: signature algorithm
///     includeKeyInfo: include key info into signature with certificate and details of public key
exports.sign = function(_, xml, path, name, options) {
	options = options || {};
	var cert = options.certificate;
	if (!cert && options.certificateName) {
		cert = fetchCertificate(_, options.certificateName);
	}
	var rootElement = "Facturae";
	path = path || "/*"; // "//*[local-name(.)='" + rootElement + "']"
	var signedInfo;
	var algorithm0 = options.signatureAlgorithm || "RSA-SHA256";
	var algorithm = getAlgorithm(algorithm0);
	tracer && tracer("Algorithm selected:", algorithm);
	var DUMMYSIGNATURE = "ABCDEFGHABCDEFGH";
	// in order to use the standard (asynchronous) signing function of Syracuse, the normal function of xml-crypto will only return a dummy
	// signature, and it will be replaced with the real signature later on
	var signFunction = function() {
		this.getSignature = function(signedInfo0, signingKey) {
			signedInfo = signedInfo0;
			// since this call must be synchronous, return a dummy signature first and compute the real signature later
			return DUMMYSIGNATURE;
		};
		this.getAlgorithmName = function() {
			return algorithm;
		};
	};

	// save normal signature algorithm
	var old = SignedXml.SignatureAlgorithms[algorithm];
	certtools = certtools || require('syracuse-load/lib/certTools');
	try {
		SignedXml.SignatureAlgorithms[algorithm] = signFunction;
		var sig = new SignedXml();
		sig.signatureAlgorithm = algorithm;
		if (options.includeKeyInfo) {
			var certificate = certtools.getPEMCertificate(_, name, false, globals.context.tenantId);
			var startIndex = certificate.indexOf('-----BEGIN CERTIFICATE-----');
			var endIndex = certificate.indexOf('-----END CERTIFICATE-----');
			if (startIndex < 0 || endIndex < 0) throw new Error(locale.format(module, "incomplete", name));
			var strippedCertificate = certificate.substring(startIndex + 27, endIndex);
			var cert = new jsx509.Certificate(certificate);
			var t = cert.publicKeyDetails;
			sig.keyInfoProvider = {
				getKeyInfo: function() {
					return "<X509Data><X509Certificate>" + strippedCertificate + "</X509Certificate></X509Data>" +
						"<KeyValue><RSAKeyValue><Modulus>" + t.modulus.toString("base64") + "</Modulus><Exponent>" + t.exponent.toString("base64") + "</Exponent></RSAKeyValue></KeyValue>";
				}
			}

		}
		sig.addReference(path);
		sig.computeSignature(xml);
		xml = sig.getSignedXml();
	} finally {
		SignedXml.SignatureAlgorithms[algorithm] = old;
	}

	var digest = certtools.sign(_, name, algorithm0, signedInfo, {
		data_encoding: 'utf8',
		output_encoding: 'base64'
	}, globals.context.tenantId);

	// replace dummy signature with real signature
	xml = xml.replace("<SignatureValue>" + DUMMYSIGNATURE + "</SignatureValue>", "<SignatureValue>" + digest + "</SignatureValue>");
	tracer && tracer("Signed xml " + xml);
	return xml;
}





/* verifies XML signature. 
 * name: name of certificate in certificate entity (private key not necessary).
 * 
 * Function checks whether file is signed with key corresponding to this certificate.
 */
exports.verify = function(_, xml, name) {
	var doc = new dom().parseFromString(xml);

	var signature = select(doc, "/*/*[local-name(.)='Signature' and namespace-uri(.)='http://www.w3.org/2000/09/xmldsig#']")[0];
	doc.removeChild(signature); // explicitly delete signature from XML (otherwise checksum will not be correct)
	var xml0 = doc.toString();
	var sig = new SignedXml();
	var cert = certtools.getPEMCertificate(_, name, false, globals.context.tenantId);

	sig.keyInfoProvider = {
		getKey: function(keyinfo) {
			// ignore key info
			return cert;
		}
	}
	sig.loadSignature(signature.toString());

	var res = sig.checkSignature(xml0);
	if (!res) console.log(sig.validationErrors);

	return res;
}