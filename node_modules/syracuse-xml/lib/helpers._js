"use strict";

var adminHelper = require("@sage/syracuse-lib/src/collaboration/helpers").AdminHelper;
var globals = require('streamline-runtime').globals;
var xmlCrypto = require('xml-crypto');
var Dom = require('xmldom').DOMParser;
var select = xmlCrypto.xpath;
var SignedXml = xmlCrypto.SignedXml;
var FileKeyInfo = xmlCrypto.FileKeyInfo;
var locale = require('streamline-locale');
var jsx509 = require('jsx509');
var fs = require('streamline-fs');


var certtools;
var tracer; // = console.log;

exports.$exported = true;

// Overwrite some parts of xml-crypto to handle Xades signatures

// for canonicalization "http://www.w3.org/TR/2001/REC-xml-c14n-20010315": collect namespaces of ancestors
function enhanceNS(node) {
	var current = node;
	var result = {
		inclusiveNamespacesPrefixList: []
	}
	var prefixes = result.inclusiveNamespacesPrefixList;
	while (current) {
		if (current.attributes) {
			for (var i = 0; i < current.attributes.length; ++i) {
				var attr = current.attributes[i];
				//only look at namespace definition attributes
				if (attr.prefix === "xmlns") {
					if (prefixes.indexOf(attr.localName) < 0) {
						prefixes.push(attr.localName);
						if (current != node) {
							node.setAttributeNS("http://www.w3.org/2000/xmlns/", attr.name, attr.value);
						}
					}
				} else if (attr.name === "xmlns") { // default name space
					if (!("defaultNs" in result)) result.defaultNs = attr.value;
				}
			}
		}
		current = current.parentNode;
	}
	return result;
}


function NonExclusiveCanonicalization() {
	/* Non-exclusive Canonicalization as "http://www.w3.org/TR/2001/REC-xml-c14n-20010315" 
	 * differs from exclusive canonicalization by namespace handling */
	this.process = function(node) {
		var options = enhanceNS(node, true);
		var algo = SignedXml.CanonicalizationAlgorithms["http://www.w3.org/2001/10/xml-exc-c14n#"];
		return new algo().process(node, options);
	}
	this.getAlgorithmName = function() {
		return "http://www.w3.org/TR/2001/REC-xml-c14n-20010315"
	}
}

SignedXml.CanonicalizationAlgorithms["http://www.w3.org/TR/2001/REC-xml-c14n-20010315"] = NonExclusiveCanonicalization;

// hack: overwrite addReference to allow type for reference
SignedXml.prototype.addReference = function(xpath, transforms, digestAlgorithm, uri, digestValue, inclusiveNamespacesPrefixList, isEmptyUri, type) {
	this.references.push({
		"xpath": xpath,
		"transforms": transforms ? transforms : [],
		"digestAlgorithm": digestAlgorithm ? digestAlgorithm : "http://www.w3.org/2000/09/xmldsig#sha1",
		"uri": uri,
		"digestValue": digestValue,
		"inclusiveNamespacesPrefixList": inclusiveNamespacesPrefixList,
		"isEmptyUri": isEmptyUri,
		type: type
	});
}



function _includeSignature(location, signatureDocD, referenceNode) {
	if (location.action === "append") {
		referenceNode.appendChild(signatureDocD);
	} else if (location.action === "prepend") {
		referenceNode.insertBefore(signatureDocD, referenceNode.firstChild);
	} else if (location.action === "before") {
		referenceNode.parentNode.insertBefore(signatureDocD, referenceNode);
	} else if (location.action === "after") {
		referenceNode.parentNode.insertBefore(signatureDocD, referenceNode.nextSibling);
	}
}


// hack: overwrite computeSignature to pass add part of signature before building references
SignedXml.prototype.computeSignature = function(xml, opts) {
	var doc = new Dom().parseFromString(xml),
		xmlNsAttr = "xmlns",
		signatureAttrs = [],
		location,
		attrs,
		prefix,
		currentPrefix;

	var validActions = ["append", "prepend", "before", "after"];

	opts = opts || {};
	prefix = opts.prefix;
	attrs = opts.attrs || {};
	location = opts.location || {};
	// defaults to the root node
	location.reference = location.reference || "/*";
	// defaults to append action
	location.action = location.action || "append";

	if (validActions.indexOf(location.action) === -1) {
		throw new Error("location.action option has an invalid action: " + location.action +
			", must be any of the following values: " + validActions.join(", "));
	}

	// automatic insertion of `:`
	if (prefix) {
		xmlNsAttr += ":" + prefix;
		currentPrefix = prefix + ":";
	} else {
		currentPrefix = "";
	}

	Object.keys(attrs).forEach(function(name) {
		if (name !== "xmlns" && name !== xmlNsAttr) {
			signatureAttrs.push(name + "=\"" + attrs[name] + "\"");
		}
	});

	// add the xml namespace attribute
	signatureAttrs.push(xmlNsAttr + "=\"http://www.w3.org/2000/09/xmldsig#\"");

	var signatureXml1 = "<" + currentPrefix + "Signature " + signatureAttrs.join(" ") + ">";
	var signatureXml2 = this.getKeyInfo(prefix) + "</" + currentPrefix + "Signature>"
	var signatureDoc = new Dom().parseFromString(signatureXml1 + signatureXml2);
	var signatureDocD = signatureDoc.documentElement;

	var referenceNode = select(doc, location.reference);

	if (!referenceNode || referenceNode.length === 0) {
		throw new Error("the following xpath cannot be used because it was not found: " + location.reference);
	}
	// add signature node to DOM structure for computation of references
	referenceNode = referenceNode[0];
	_includeSignature(location, signatureDocD, referenceNode)
	var signedInfo = this.createSignedInfo(doc, prefix);
	// remove signature node from DOM to create original XML with ID
	signatureDocD.parentNode.removeChild(signatureDocD);
	this.originalXmlWithIds = doc.toString()
	var signatureContent = this.createSignature(signedInfo, prefix);
	var signatureContentDoc = new Dom().parseFromString(signatureContent);
	signatureDocD.insertBefore(signatureContentDoc.documentElement, signatureDocD.firstChild);
	var signedInfoDoc = new Dom().parseFromString(signedInfo);
	signatureDocD.insertBefore(signedInfoDoc.documentElement, signatureDocD.firstChild);

	// finally signature node to DOM structure again
	var referenceNode = select(doc, location.reference)[0];
	_includeSignature(location, signatureDocD, referenceNode)
	this.signatureXml = signatureXml1 + signedInfo + signatureContent + signatureXml2;
	this.signedXml = doc.toString()

}


// hack: overwrite createReferences to allow references with type
SignedXml.prototype.createReferences = function(doc, prefix) {
	var res = ""

	prefix = prefix || ''
	prefix = prefix ? prefix + ':' : prefix
	var enhanced = false; // is already preliminary signature contained in path?
	for (var n in this.references) {
		if (!this.references.hasOwnProperty(n)) continue;
		var ref = this.references[n]
		var nodes = select(doc, ref.xpath)
		if (nodes.length == 0) {
			throw new Error('the following xpath cannot be signed because it was not found: ' + ref.xpath)
		}

		for (var h in nodes) {
			if (!nodes.hasOwnProperty(h)) continue;

			var node = nodes[h]
			var type = "";
			if (ref.type)
				type = 'Type="' + ref.type + '" ';
			if (ref.isEmptyUri) {
				res += "<" + prefix + "Reference " + type + "URI=\"\">"
			} else {
				var id = this.ensureHasId(node);
				ref.uri = id
				res += "<" + prefix + "Reference " + type + "URI=\"#" + id + "\">"
			}
			res += "<" + prefix + "Transforms>"
			if (!Array.isArray(ref.transforms)) ref.transforms = [ref.transforms]
			for (var t in ref.transforms) {
				if (!ref.transforms.hasOwnProperty(t)) continue;

				var trans = ref.transforms[t]
				var transform = this.findCanonicalizationAlgorithm(trans)
				res += "<" + prefix + "Transform Algorithm=\"" + transform.getAlgorithmName() + "\" />"
			}

			var canonXml = this.getCanonXml(ref.transforms, node)

			var digestAlgorithm = this.findHashAlgorithm(ref.digestAlgorithm)
			res += "</" + prefix + "Transforms>" +
				"<" + prefix + "DigestMethod Algorithm=\"" + digestAlgorithm.getAlgorithmName() + "\" />" +
				"<" + prefix + "DigestValue>" + digestAlgorithm.getHash(canonXml) + "</" + prefix + "DigestValue>" +
				"</" + prefix + "Reference>"
		}
	}
	return res
}

// hack: overwrite getKeyInfo to allow Object in signature
SignedXml.prototype.getKeyInfo = function(prefix) {
	var res = ""
	var currentPrefix

	currentPrefix = prefix || ''
	currentPrefix = currentPrefix ? currentPrefix + ':' : currentPrefix

	if (this.keyInfoProvider) {
		res += "<" + currentPrefix + "KeyInfo>"
		res += this.keyInfoProvider.getKeyInfo(this.signingKey, prefix)
		res += "</" + currentPrefix + "KeyInfo>"
	}
	if (this.keyInfoProvider && this.keyInfoProvider.getObjectInfo && this.keyInfoProvider.getObjectInfo()) {
		res += "<" + currentPrefix + "Object>" + this.keyInfoProvider.getObjectInfo() + "</" + currentPrefix + "Object>";
	}
	return res
}



// hack: overwrite getCanonXml to handle line breaks and empty tags correctly
SignedXml.prototype._getCanonXml = SignedXml.prototype.getCanonXml;
SignedXml.prototype.getCanonXml = function(transforms, node, options) {
	/* if (transforms.indexOf(this.canonicalizationAlgorithm) < 0)
		transforms.push(this.canonicalizationAlgorithm);*/
	if (this.options.addSignatureCanonicalization && transforms.length === 0) {
		transforms.push(this.canonicalizationAlgorithm);
	}
	var res = this._getCanonXml(transforms, node, options);
	if (res.indexOf("/>") > 0) {
		res = res.replace(/<([^ >]+)([^>]*?)\/>/g, "<$1$2></$1>");
	}
	return res;
}




function getAlgorithm(algorithm0) {
	switch (algorithm0) {
		case "RSA-SHA256":
			return "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256";
			break;
		case "RSA-SHA1":
			return "http://www.w3.org/2000/09/xmldsig#rsa-sha1";
			break;
		default:
			throw new Error(locale.format(module, "unsupportedAlgorithm", algorithm0));
	}
}

function fetchCertificate(_, name) {
	var db = adminHelper.getCollaborationOrm(_);
	var model = db.model;
	var entity = model.getEntity(_, "certificate");
	var filter = {
		jsonWhere: {
			name: name
		}
	};

	var cert = db.fetchInstance(_, entity, filter);
	if (!cert) throw new Error(locale.format(module, 'errCertInstNotFound', name));
	return cert;
}
// find Id in document which has not been used yet.
function _findNewId(xml) {
	// find all Id attributes
	var ids = xml.match(/ [Ii]d=(["']).*?\1/g);
	var values = ids ? ids.map(function(id) {
		return id.substring(5, id.length - 1)
	}) : [];
	for (var i = 0; i < values.length + 1; i++) { // iterate until values.length so that new value must be found
		var newId = "Id" + i;
		if (values.indexOf(newId) < 0) {
			return newId;
		}
	}
	throw new Error("ID not found");
}


function _makeAlgorithmURI(name) {
	name = name.toLowerCase();
	if (name === "sha1") return "http://www.w3.org/2000/09/xmldsig#sha1";
	else return "http://www.w3.org/2001/04/xmlenc#" + name;
}



/// Signs a given XML file. Parameters:
///  xml: string with path of XML file
///  xmlout: string with path of XML file
///  path: xpath expression to the part of XML which should be signed (empty value for enveloped signature; can also be an array)
///  name: name of certificate in certificate entity (must be certificate with private key)
///  options: Object with additional information for signing:
///     folder: X3 folder (if empty, use Syracuse server for reading/writing)
///     endpoint: X3 endpoint (optional, if folder is not unique)
///     signatureAlgorithm: signature algorithm (default: "RSA-SHA256")
///     utf8 (optional boolean): XML data (with UTF8 encoding) have been read in UTF8 mode, not in binary mode. Output also for UTF8 mode.
///     includeKeyInfo (optional boolean): include key info into signature with certificate and details of public key
///     prefix (optional): prefix for signature namespace
///     canonicalizationAlgorithm: canonicalization algorithm (default: "http://www.w3.org/2001/10/xml-exc-c14n#"); currently no other algorithm supported 
///     xades: include xades information. Must be object with information:
///        - identifier: identifier, e. g. http://www.facturae.es/politica_de_firma_formato_facturae/politica_de_firma_formato_facturae_v3_1.pdf
///        - description: description, e. g. facturae31
///        - hashAlgorithm (optional) hash algorithm, default "SHA1", may be "SHA256", "SHA512"
///        - hash (only necessary if 'document' is not given): value of hash, if document is not given, e. g. Ohixl6upD6av8N7pEvDABhEL6hM=
///        - document (only necessary if 'hash' is not given): document to create hash from, given as a buffer
///         
exports.signfile = function(_, xml, xmlout, path, name, options) {
	var sadfsq = _getSadfsq(_, options);
	var xml0 = sadfsq ? sadfsq.readFile(_, {
		path: xml
	}, {
		flag: "r",
		encoding: 'binary'
	}) : fs.readFile(xml, 'binary', _);
	xml0 = exports.sign(_, xml0, path, name, options);
	sadfsq ? sadfsq.writeFile(_, {
		path: xmlout
	}, xml0, {
		flag: "w",
		encoding: 'binary'
	}) : fs.writeFile(xmlout, xml0, 'binary', _);
}

function _getSadfsq(_, options) {
	if (options && options.folder) {
		var db = adminHelper.getCollaborationOrm(_);
		if (options.folder) {
			var condition = {
				x3ServerFolder: options.folder
			};
			if (options.solution) condition.x3SolutionName = options.solution;
		}
		var entity = db.model.getEntity(_, "endPoint");
		var filter = {
			jsonWhere: condition
		}
		var endpoint = db.fetchInstance(_, entity, filter);
		if (!endpoint) throw new Error(locale.format(module, "noEndpoint", options.folder));
		var Sadfsq = require("syracuse-x3/lib/clients/sadfsq/sadfsqClient").SadFsqClient;
		return new Sadfsq(_, endpoint, null, null, null);
	}
	return undefined;
}


/// Signs a given XML string. Parameters:
///  xml: string with XML
///  path: xpath expression to the part of XML which should be signed (empty value for enveloped signature; can also be an array)
///  name: name of certificate in certificate entity (must be certificate with private key)
///  options: Object with additional information for signing:
///     signatureAlgorithm: signature algorithm (default: "RSA-SHA256")
///     utf8 (optional boolean): XML data (with UTF8 encoding) have been read in UTF8 mode, not in binary mode. Output also for UTF8 mode.
///     includeKeyInfo (optional boolean): include key info into signature with certificate and details of public key
///     prefix (optional): prefix for signature namespace
///     canonicalizationAlgorithm: canonicalization algorithm (default: "http://www.w3.org/2001/10/xml-exc-c14n#"); currently no other algorithm supported 
///     xades: include xades information. Must be object with information:
///        - identifier: identifier, e. g. http://www.facturae.es/politica_de_firma_formato_facturae/politica_de_firma_formato_facturae_v3_1.pdf
///        - description: description, e. g. facturae31
///        - hashAlgorithm (optional) hash algorithm, default "SHA1", may be "SHA256", "SHA512"
///        - hash (only necessary if 'document' is not given): value of hash, if document is not given, e. g. Ohixl6upD6av8N7pEvDABhEL6hM=
///        - document (only necessary if 'hash' is not given): document to create hash from, given as a buffer
///         
exports.sign = function(_, xml, path, name, options) {
	function addRef(pth, canon) {
		if (pth)
			sig.addReference(pth, [canon]);
		else
			sig.addReference("/*", ["http://www.w3.org/2000/09/xmldsig#enveloped-signature", canon], undefined, undefined, undefined, undefined, true);
	}
	options = options || {};
	if (!(options instanceof Object)) options = JSON.parse(options);
	path = path || [""];
	if (!Array.isArray(path)) path = [path];
	var sigOpts = {
		prefix: options.prefix
	}; // options for signing
	// fix encoding - data have been read in binary mode, 
	// therefore XML string has to be adjusted according to encoding mentioned in XML
	// currently, only UTF8 encoded XML is supported, specific transformations are necessary for each type of input XML
	// signed XML will always be UTF8 encoded
	if (!options.utf8) {
		var r = /\<\?xml [^\>]* encoding=(["'])([\w\-]+)\1/.exec(xml);
		var encoding = r && r[2];
		if (encoding) encoding = encoding.toLowerCase();
		if (encoding && encoding != "utf8" && encoding != "utf-8" && encoding.indexOf("iso-8859-") > 0) throw new Error("Unsupported encoding " + r[2]);
		if (!encoding || encoding.indexOf("utf") >= 0)
			xml = new Buffer(xml, 'binary').toString("utf8");
	}
	var cert = options.certificate;
	if (!cert && options.certificateName) {
		cert = fetchCertificate(_, options.certificateName);
	}


	var signedInfo;
	var algorithm0 = options.signatureAlgorithm || "RSA-SHA256";
	var algorithm = getAlgorithm(algorithm0);
	tracer && tracer("Algorithm selected:", algorithm);
	var DUMMYSIGNATURE = "ABCDEFGHABCDEFGH";
	// in order to use the standard (asynchronous) signing function of Syracuse, the normal function of xml-crypto will only return a dummy
	// signature, and it will be replaced with the real signature later on
	var signFunction = function() {
		this.getSignature = function(signedInfo0, signingKey) {
			signedInfo = signedInfo0;
			// since this call must be synchronous, return a dummy signature first and compute the real signature later
			return DUMMYSIGNATURE;
		};
		this.getAlgorithmName = function() {
			return algorithm;
		};
	};

	// save normal signature algorithm
	var old = SignedXml.SignatureAlgorithms[algorithm];
	certtools = certtools || require('@sage/syracuse-lib/src/load-balancer/certTools');
	try {
		SignedXml.SignatureAlgorithms[algorithm] = signFunction;
		var sig = new SignedXml();
		if (options.canonicalizationAlgorithm) sig.canonicalizationAlgorithm = options.canonicalizationAlgorithm;
		sig.signatureAlgorithm = algorithm;
		var keyInfo = "";
		var certificate = certtools.getPEMCertificate(_, name, false, globals.context.tenantId);
		var cert = new jsx509.Certificate(certificate);
		var currentPrefix = options.prefix ? options.prefix + ":" : "";
		if (options.includeKeyInfo) {
			var startIndex = certificate.indexOf('-----BEGIN CERTIFICATE-----');
			var endIndex = certificate.indexOf('-----END CERTIFICATE-----');
			if (startIndex < 0 || endIndex < 0) throw new Error(locale.format(module, "incomplete", name));
			var strippedCertificate = certificate.substring(startIndex + 27, endIndex);
			var t = cert.publicKeyDetails;
			keyInfo += "<" + currentPrefix + "X509Data><" + currentPrefix + "X509Certificate>" + strippedCertificate + "</" + currentPrefix + "X509Certificate></" + currentPrefix + "X509Data>" +
				"<" + currentPrefix + "KeyValue><" + currentPrefix + "RSAKeyValue><" + currentPrefix + "Modulus>" + t.modulus.toString("base64") + "</" + currentPrefix + "Modulus><" + currentPrefix + "Exponent>" + t.exponent.toString("base64") + "</" + currentPrefix + "Exponent></" + currentPrefix + "RSAKeyValue></" + currentPrefix + "KeyValue>";
		}
		var sigAlgoName = cert.sigAlgorithmName;
		var sigAlgorithm = _makeAlgorithmURI(sigAlgoName.substr(4));
		var tbs = cert.parsed;
		var tbsbuffer = jsx509.asn1.toBuffer(tbs);
		var hash0 = require('crypto').createHash(sigAlgoName.substr(4));
		hash0.update(tbsbuffer);
		var hash = hash0.digest("base64");
		var objectInfo = "";

		if (options.xades) {
			if (!options.xades.identifier)
				throw new Error("Missing identifier for SignedSignatureProperties");
			var sigId = _findNewId(xml); // need some ID for reference to signature
			var hash;
			var hashAlgorithm = "SHA1" || options.xades.hashAlgorithm;
			if (options.xades.hash) {
				hash = options.xades.hash;
			} else if (options.xades.document) {

				var hash0 = require('crypto').createHash(hashAlgorithm);
				hash0.update(options.xades.document);
				hash = hash0.digest("base64");
			}
			// Xades needs a target for the signature 
			objectInfo = '<etsi:QualifyingProperties xmlns:etsi="http://uri.etsi.org/01903/v1.3.2#" Target="#' + sigId + '"><etsi:SignedProperties>';
			objectInfo += '<etsi:SignedSignatureProperties>';
			objectInfo += '<etsi:SigningTime>' + (new Date().toISOString()) + '</etsi:SigningTime>';
			objectInfo += '<etsi:SigningCertificate><etsi:Cert>';
			objectInfo += '<etsi:CertDigest><' + currentPrefix + 'DigestMethod Algorithm="' + sigAlgorithm + '"></' + currentPrefix + 'DigestMethod><' + currentPrefix + 'DigestValue>' + hash + '</' + currentPrefix + 'DigestValue></etsi:CertDigest>';
			objectInfo += '<etsi:IssuerSerial><' + currentPrefix + 'X509IssuerName>' + cert.issuerDn + '</' + currentPrefix + 'X509IssuerName><' + currentPrefix + 'X509SerialNumber>' + cert.serialDecimal + '</' + currentPrefix + 'X509SerialNumber></etsi:IssuerSerial>';
			objectInfo += '</etsi:Cert></etsi:SigningCertificate>';

			objectInfo += '<etsi:SignaturePolicyIdentifier><etsi:SignaturePolicyId><etsi:SigPolicyId><etsi:Identifier>' + options.xades.identifier + '</etsi:Identifier>';
			if (options.xades.description) objectInfo += '<etsi:Description>' + options.xades.description + '</etsi:Description>';
			objectInfo += '</etsi:SigPolicyId>';
			objectInfo += '<etsi:SigPolicyHash><' + currentPrefix + 'DigestMethod Algorithm="' + _makeAlgorithmURI(hashAlgorithm) + '"></' + currentPrefix + 'DigestMethod><' + currentPrefix + 'DigestValue>' + hash + '</' + currentPrefix + 'DigestValue></etsi:SigPolicyHash>';
			objectInfo += '</etsi:SignaturePolicyId></etsi:SignaturePolicyIdentifier>';
			if (options.xades.claimedRoles || options.xades.certifiedRoles) {
				objectInfo += '<etsi:SignerRole>';
				var roles = options.xades.claimedRoles;
				if (roles) {
					if (!Array.isArray(roles)) roles = [roles];
					objectInfo += '<etsi:ClaimedRoles>';
					objectInfo += roles.map(function(role) {
						return '<etsi:ClaimedRole>' + role + '</etsi:ClaimedRole>';
					}).join("");
					objectInfo += '</etsi:ClaimedRoles>';
				}
				var roles = options.xades.certifiedRoles;
				if (roles) {
					if (!Array.isArray(roles)) roles = [roles];
					objectInfo += '<etsi:CertifiedRoles>';
					objectInfo += roles.map(function(role) {
						return '<etsi:CertifiedRole>' + role + '</etsi:CertifiedRole>';
					}).join("");
					objectInfo += '</etsi:CertifiedRoles>';
				}
				objectInfo += '</etsi:SignerRole>';
			}


			objectInfo += '</etsi:SignedSignatureProperties></etsi:SignedProperties></etsi:QualifyingProperties>';
			sigOpts.attrs = {
				"Id": sigId
			};
			// add reference for SignedProperties
			sig.addReference("//*[local-name(.)='SignedProperties' and namespace-uri(.)='http://uri.etsi.org/01903/v1.3.2#']", sig.canonicalizationAlgorithm, null, null, null, null, null, "http://uri.etsi.org/01903#SignedProperties");
			if (keyInfo) {
				sig.addReference("//*[local-name(.)='KeyInfo' and namespace-uri(.)='http://www.w3.org/2000/09/xmldsig#']", sig.canonicalizationAlgorithm);
			}
		}
		if (keyInfo || objectInfo) {
			sig.keyInfoProvider = {
				getKeyInfo: function() {
					return keyInfo;
				},
				getObjectInfo: function() {
					return objectInfo
				}
			}

		}
		path.forEach(function(p) {
			addRef(p, sig.canonicalizationAlgorithm)
		});
		sig.computeSignature(xml, sigOpts);
		xml = sig.getSignedXml();
		if (!options.utf8) { // change UTF8 into binary format so that data can be written in binary mode.
			xml = new Buffer(xml, 'utf8').toString("binary");
		}
	} finally {
		SignedXml.SignatureAlgorithms[algorithm] = old;
	}
	var digest = certtools.sign(_, name, algorithm0, signedInfo, {
		data_encoding: 'utf8',
		output_encoding: 'base64'
	}, globals.context.tenantId);
	// replace dummy signature with real signature
	xml = xml.replace("<" + currentPrefix + "SignatureValue>" + DUMMYSIGNATURE + "</" + currentPrefix + "SignatureValue>", "<" + currentPrefix + "SignatureValue>" + digest + "</" + currentPrefix + "SignatureValue>");
	tracer && tracer("Signed xml " + xml);
	return xml;
}



/// verifies XML signature.
/// 
/// Function checks whether file is signed with key corresponding to this certificate 
//  TODO: extract certificate data/public key data out of signed XML, verify with certificate chain
/// xmlfile: absolute path of xml file
/// name: name of certificate in certificate entity (private key not necessary).
///  options: Object with additional information for verifying:
///     folder: X3 folder (if empty, use Syracuse server for reading/writing)
///     utf8: XML data (with UTF8 encoding) have been read in UTF8 mode, not in binary mode.
///     endpoint: X3 endpoint (optional, if folder is not unique)
///     notNormalizeLineEndings: do not normalize line endings to 0x0A.
///     addSignatureCanonicalization: when no canonicalization is there for references, add canonicalization of signature
///
///  Return value: array of verification errors.      
exports.verifyfile = function(_, xmlfile, name, options) {
	var sadfsq = _getSadfsq(_, options);
	var xml0 = sadfsq ? sadfsq.readFile(_, {
		path: xmlfile
	}, {
		flag: "r",
		encoding: 'binary'
	}) : fs.readFile(xmlfile, 'binary', _);
	return exports.verify(_, xml0, name, options);
}


/// verifies XML signature.
/// Parameters:
/// xml: xml string
/// name: name of certificate in certificate entity (private key not necessary).
/// 
/// Function checks whether file is signed with key corresponding to this certificate.
///  options: Object with additional information for verifying:
///     notNormalizeLineEndings: do not normalize line endings to 0x0A.
///     addSignatureCanonicalization: when no canonicalization is there for references, add canonicalization of signature
///     utf8: XML data (with UTF8 encoding) have been read in UTF8 mode, not in binary mode.
///
///  Return value: array of verification errors.      
exports.verify = function(_, xml, name, options) {
	certtools = certtools || require('@sage/syracuse-lib/src/load-balancer/certTools');
	options = options || {};
	if (!(options instanceof Object)) options = JSON.parse(options);
	if (!options.notNormalizeLineEndings) xml = xml.replace(/\x0d\x0a/g, "\x0a")
	var doc = new Dom().parseFromString(xml);

	var signature = select(doc, "/*/*[local-name(.)='Signature' and namespace-uri(.)='http://www.w3.org/2000/09/xmldsig#']")[0];
	if (!signature) {
		throw new Error("No signature included");
	}
	enhanceNS(signature, true);
	var signatureString = signature.toString(); // Signature

	var sig = new SignedXml("", options);
	var cert = certtools.getPEMCertificate(_, name, false, globals.context.tenantId);
	sig.keyInfoProvider = {
		getKey: function(keyinfo) {
			// ignore key info
			return cert;
		}
	}
	sig.loadSignature(signatureString);

	return sig.validationErrors;
}

//check whether certificate exists with certain name (together with private key)
//Parameters: name: name of certificate
// withKey: only look for entries which also have a private key
//Return value: true, if it exists, false otherwise
function certificateExists(_, name, withKey) {
	var db = adminHelper.getCollaborationOrm(_);
	var condition = {
		name: name,
	}
	if (withKey) condition.keyExists = true;
	var count = db.count(_, db.model.getEntity(_, "certificate"), {
		jsonWhere: condition
	});
	return count > 0;
}

exports.certificateExists = certificateExists;