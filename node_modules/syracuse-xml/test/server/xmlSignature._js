"use strict";

var helpers = require('syracuse-core').helpers;
var config = require('config'); // must be first syracuse require
var adminHelper = require("syracuse-collaboration/lib/helpers");
var globals = require('streamline-runtime').globals;
var rmdirRec = require('syracuse-patch/lib/patchtools').rmdirRec;
var xmlHelper = require('syracuse-xml/lib/helpers');
var certtools = require('syracuse-load/lib/certTools');
var jsx509 = require('jsx509');
var adminTestFixtures = require("syracuse-collaboration/test/fixtures/adminTestFixtures");

var tracer; // = console.error;


QUnit.module(module.id, {
	setup: function() {},
	teardown: function() {}
});

var fs = require('streamline-fs'),
	fsp = require('path'),
	util = require('util');

var directory = fsp.join(__dirname, '../../../../certificatetest/');
var db; // Initialised when we set up the environment


var certificates = [{
	name: 'server',
	passphrase: 'server'
}];

//force basic auth
config.session = config.session || {};
config.session.auth = "basic";
//no integration server
config.integrationServer = null;
globals.context.session = {
	id: helpers.uuid.generate(),
	getUserLogin: function(_) {
		return "guest";
	},
	getUserProfile: function(_) {
		return {
			user: function(_) {
				// getting the administration ORM
				//var db = adminHelper.getCollaborationOrm(_);
				return db.fetchInstance(_, db.model.getEntity(_, "user"), {
					jsonWhere: {
						login: "guest"
					}
				});
			},
			getDefaultX3Endpoints: function(_) {
				return [];
			}
		};
	},
	getSecurityProfile: function(_) {
		return null;
	},
	getData: function(code) {
		return null;
	}
};

var ckeckDiagnoses = function(obj) {
	//tracer && tracer(util.inspect(obj));

	if (obj && obj.$diagnoses) {
		for (var i in obj.$diagnoses) {
			if (obj.$diagnoses[i] != null) {
				if (obj.$diagnoses[i].$severity === "error") {
					throw new Error(obj.$diagnoses[i].$severity + ": " + util.inspect(obj.$diagnoses[i].$message));
				} else {
					tracer && tracer(obj.$diagnoses[i].$severity + ": " + util.inspect(obj.$diagnoses[i].$message));
				}
			}
		}
	}
	if (obj && obj.$properties) {
		Object.keys(obj.$properties).forEach(function(elt) {
			if (obj.$properties[elt] && obj.$properties[elt].$diagnoses != null && obj.$properties[elt].$diagnoses.length !== 0) {
				obj.$properties[elt].$diagnoses.forEach(function(diag) {
					if (diag.$severity === "error") {
						throw new Error(diag.$severity + " in element: " + elt + " : " + diag.$message);
					} else {
						tracer && tracer(diag.$severity + " in element: " + elt + " : " + diag.$message);
					}
				});
			}
		});
	}
	if (obj && obj.$actions) {
		Object.keys(obj.$actions).forEach(function(elt) {
			if (obj.$actions[elt] && obj.$actions[elt].$diagnoses != null && obj.$actions[elt].$diagnoses.length !== 0) {
				obj.$actions[elt].$diagnoses.forEach(function(diag) {
					if (diag.$severity === "error") {
						throw new Error(diag.$severity + " in element: " + elt + " : " + diag.$message);
					} else {
						tracer && tracer(diag.$severity + " in element: " + elt + " : " + diag.$message);
					}
				});
			}
		});
	}

};

var jsx509Dir = fsp.dirname(require.resolve('jsx509'));

var createCertificateInstance = function(_, name, passphrase) {
	//var db = adminHelper.getCollaborationOrm(_);
	var model = db.model;
	var entity = model.getEntity(_, "certificate");

	var certInst = entity.createInstance(_, db, null);
	certInst.name(_, name + "_test");
	certInst.internal(_, false);
	certInst.keyExists(_, true);
	certInst.pass(_, passphrase);

	var caString = fs.readFileSync(fsp.join(jsx509Dir, "test/server/fixtures/" + name + ".crt"), "utf8");
	var caBuf = new Buffer(caString);
	var caStore = certInst.certificate(_);
	var stream = caStore.createWritableStream(_, {
		length: caBuf.length
	});
	stream.write(_, caBuf.toString(), "binary");
	stream.write(_, null);
	caStore.close(_);

	var keyString = fs.readFileSync(fsp.join(jsx509Dir, "test/server/fixtures/" + name + ".key"), "utf8");
	var keyBuf = new Buffer(keyString);
	var keyStore = certInst.key(_);
	var stream2 = keyStore.createWritableStream(_, {
		length: keyBuf.length
	});
	stream2.write(_, keyBuf.toString(), "binary");
	stream2.write(_, null);
	keyStore.close(_);

	var res = certInst.save(_);
	ckeckDiagnoses(res);
	return certInst;
};

asyncTest('initialise environment', function(_) {
	var config = {
		application: "syracuse",
		contract: "collaboration",
		dataset: "unit_test"
	};
	adminHelper.setup(config);

	//
	db = adminTestFixtures.initializeTestEnvironnement(_);
	ok(db != null, "Environment initialized");
	start();
});

asyncTest('check certificate existence', function(_) {
	var ex = xmlHelper.certificateExists(_, certificates[0].name + "_test")
	strictEqual(ex, "", "No certificate yet");
	start();
});

asyncTest('check nodelocal config', function(_) {
	var options = {
		certdir: directory
	};
	try {
		config.collaboration.certdir = directory;
		fs.mkdirSync(directory);
	} catch (e) {
		tracer && tracer(e);
	}
	strictEqual(options.certdir && fs.existsSync(options.certdir), true, "Certificate directory exists.");
	start();
});

asyncTest('create certificates instances', function(_) {
	for (var i in certificates) {
		var cert = createCertificateInstance(_, certificates[i].name, certificates[i].passphrase);
		strictEqual(cert.name(_), certificates[i].name + "_test", "'" + certificates[i].name + "_test' certificate instance created");
	}
	start();
});

asyncTest('check certificate existence 2', function(_) {
	var ex = xmlHelper.certificateExists(_, certificates[0].name + "_test", true)
	strictEqual(JSON.stringify(ex), JSON.stringify({
		"notAfter": "2014-05-13T06:47:16.000Z"
	}), "Certificate exists");
	start();
});




/*
asyncTest('sign and verify xml', function(_) {
    
    for (var i in certificates) {
        var certName = certificates[i].name + '_test';
        var input = fs.readFile(__dirname + '/data/input.xml', 'utf8', _);
        
        var signedXml = xmlHelper.sign(_, input, null, certName, {
            algorithm: 'RSA-SHA256',
            includeKeyInfo: true
        });
        console.log("signedXmlcc:",signedXml);

        var verif = xmlHelper.verify(_, signedXml, certName);
        strictEqual(verif.length, 0, "Signature validated");

            
    }
    start();
}); */

asyncTest('verify Facturae example', function(_) {
	//var db = adminHelper.getCollaborationOrm(_);
	var model = db.model;
	var entity = model.getEntity(_, "certificate");

	var certInst = entity.createInstance(_, db, null);
	certInst.name(_, "cuevas");
	certInst.internal(_, false);
	certInst.keyExists(_, false);

	var caString = fs.readFileSync(fsp.join(__dirname, 'data/facturae2.crt'), "utf8");
	var caBuf = new Buffer(caString);
	var caStore = certInst.certificate(_);
	var stream = caStore.createWritableStream(_, {
		length: caBuf.length
	});
	stream.write(_, caBuf.toString(), "binary");
	stream.write(_, null);
	caStore.close(_);

	var res = certInst.save(_);
	ckeckDiagnoses(res);

	var certName = "cuevas";
	var input = fs.readFile(__dirname + '/data/FAC-C10015-000001.xml', 'binary', _);

	var verif = xmlHelper.verify(_, input, certName, {
		addSignatureCanonicalization: true
	});
	// this XML file must be correct
	strictEqual(verif.length, 0, "Correctly verified");

	start();
});

asyncTest('verify test example', function(_) {
	var model = db.model;
	var entity = model.getEntity(_, "certificate");

	var certInst = entity.createInstance(_, db, null);
	certInst.name(_, "testsig_test");
	certInst.internal(_, false);
	certInst.keyExists(_, true);

	var caString = fs.readFileSync(fsp.join(__dirname, 'data/testsig.crt'), "utf8");
	var caBuf = new Buffer(caString);
	var caStore = certInst.certificate(_);
	var stream = caStore.createWritableStream(_, {
		length: caBuf.length
	});
	stream.write(_, caBuf.toString(), "binary");
	stream.write(_, null);
	caStore.close(_);

	var keyString = fs.readFileSync(fsp.join(__dirname, 'data/testsig.key'), "utf8");
	var keyBuf = new Buffer(keyString);
	var keyStore = certInst.key(_);
	var stream2 = keyStore.createWritableStream(_, {
		length: keyBuf.length
	});
	stream2.write(_, keyBuf.toString(), "binary");
	stream2.write(_, null);
	keyStore.close(_);

	var res = certInst.save(_);
	ckeckDiagnoses(res);





	var certName = "testsig_test";

	var input = fs.readFile(__dirname + '/data/testunsig.xml', 'binary', _);
	// signing
	var signedXml = xmlHelper.sign(_, input, null, certName, {
		algorithm: 'RSA-SHA1',
		includeKeyInfo: true
	});

	var verif = xmlHelper.verify(_, signedXml, certName);
	strictEqual(verif.length, 0, "Signature validated");

	var tmpfile = __dirname + '/data/testtemp.xml';
	try {
		fs.unlink(tmpfile, _)
	} catch (e) {
		console.log(e + " ", e.code)
		if (e.code !== "ENOENT") throw e;
	}
	// signing
	xmlHelper.signfile(_, __dirname + '/data/testunsig.xml', tmpfile, null, certName, JSON.stringify({
		algorithm: 'RSA-SHA1',
		includeKeyInfo: true
	}));

	verif = xmlHelper.verifyfile(_, tmpfile, certName);
	strictEqual(verif.length, 0, "Signature validated (file)");
	try {
		fs.unlink(tmpfile, _)
	} catch (e) {
		console.log(e + " ", e.code)
		if (e.code !== "ENOENT") throw e;
	}


	input = fs.readFile(__dirname + '/data/testunsig.xml', 'binary', _);
	// signing
	signedXml = xmlHelper.sign(_, input, null, certName, {
		algorithm: 'RSA-SHA1',
		includeKeyInfo: true,
		xades: {
			identifier: "XYZ",
			document: "ABCDE",
			claimedRoles: ["A", "B", "C"],
			certifiedRoles: "D"
		}
	});
	console.log("signedXml2:", signedXml);

	verif = xmlHelper.verify(_, signedXml, certName);





	strictEqual(verif.length, 0, "Signature validated");



	input = fs.readFile(__dirname + '/data/testsig.xml', 'binary', _);



	verif = xmlHelper.verify(_, input, certName);
	strictEqual(verif.length, 0, "Signature validated");
	start();
});


asyncTest('verify example with chain', function(_) {
	var model = db.model;
	var entity = model.getEntity(_, "certificate");

	var certInst = entity.createInstance(_, db, null);
	certInst.name(_, "cert8");
	certInst.internal(_, false);
	certInst.keyExists(_, true);

	var caString = fs.readFileSync(fsp.join(__dirname, 'data/cert8.crt'), "utf8");
	var caBuf = new Buffer(caString);
	var caStore = certInst.certificate(_);
	var stream = caStore.createWritableStream(_, {
		length: caBuf.length
	});
	stream.write(_, caBuf.toString(), "binary");
	stream.write(_, null);
	caStore.close(_);

	var keyString = fs.readFileSync(fsp.join(__dirname, 'data/cert8.key'), "utf8");
	var keyBuf = new Buffer(keyString);
	var keyStore = certInst.key(_);
	var stream2 = keyStore.createWritableStream(_, {
		length: keyBuf.length
	});
	stream2.write(_, keyBuf.toString(), "binary");
	stream2.write(_, null);
	keyStore.close(_);

	var res = certInst.save(_);
	ckeckDiagnoses(res);

	var certInst = entity.createInstance(_, db, null);
	certInst.name(_, "signcert8");
	certInst.internal(_, false);
	certInst.keyExists(_, false);

	var caString = fs.readFileSync(fsp.join(__dirname, 'data/signcert8.crt'), "utf8");
	var caBuf = new Buffer(caString);
	var caStore = certInst.certificate(_);
	var stream = caStore.createWritableStream(_, {
		length: caBuf.length
	});
	stream.write(_, caBuf.toString(), "binary");
	stream.write(_, null);
	caStore.close(_);


	var res = certInst.save(_);
	ckeckDiagnoses(res);




	var certName = "cert8";

	var input = fs.readFile(__dirname + '/data/testunsig.xml', 'binary', _);
	// signing
	var signedXml = xmlHelper.sign(_, input, null, certName, {
		algorithm: 'RSA-SHA1',
		includeKeyInfo: true
	});
	// try chain with wrong signing certificate
	var verif = xmlHelper.verify(_, signedXml, certName, {
		chain: true
	});
	console.log("Errors", verif)
	strictEqual(verif.length, 0, "Signature validated");
	// now correct signing certificate
	certName = "signcert8";
	var verif = xmlHelper.verify(_, signedXml, certName, {
		chain: true
	});
	console.log("Errors", verif)
	strictEqual(verif.length, 0, "Signature validated (with CA)");

	start();
});



asyncTest('clean up', function(_) {
	rmdirRec(directory, _);
	ok(true);
	start();
});