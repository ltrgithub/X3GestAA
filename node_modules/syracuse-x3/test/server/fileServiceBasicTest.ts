"use strict";
var xfs = require('syracuse-x3/lib/fileService');

const assert = require('chai').assert;
Object.keys(assert).forEach(key => {
	if (key !== 'isNaN') global[key] = assert[key];
});

describe(module.id, () => {

	var volumes = {
		"": "tmp",
		"TRA": "TRA",
		"TRT": "TRT",
		"TMP": "TMP",
		"BCH": "TRA/../../MAINFOLD/BCH"
	};

	function accepted(folder, path, xroot, xpath, xext) {
		var m = /^(\[(.*)\])?(.*)$/.exec(path);
		var parts = path.split("/");
		var volpath = m && volumes[m[2]];
		var fpath = m && m[3];
		var opt = xfs.resolveFileDesc(folder, volpath, fpath);
		var expected = {
			folder: folder,
			path: xroot,
			name: xpath,
			extension: xext
		};
		deepEqual(opt, expected, JSON.stringify(expected));
	}

	function rejected(folder, path, xroot, xpath, xext) {
		var opt;
		try {
			opt = accepted(folder, path, xroot, xpath, xext);
		} catch (e) {
			ok(e.message === "Bad filename", "reject '" + path + "'");
			return;
		}
		ok(false, "should reject '" + path + "'");
	}

	it('Valid file desc', function() {
		accepted("X3", "[TRA]/file.txt", volumes["TRA"], "file", "txt");
		accepted("X3", "[TRA]file.txt", volumes["TRA"], "file", "txt");
		accepted("X3", "[TMP]/sub/file.txt", volumes["TMP"], "sub/file", "txt");
		accepted("X3", "[BCH]/file.src", volumes["BCH"], "file", "src");
		accepted("X3", "[BCH]file.src", volumes["BCH"], "file", "src");
		accepted("X3", "[TMP]/TRT/../sub/file.dat", volumes["TMP"], "sub/file", "dat");
		accepted("X3", "/TRT/../sub/file.dat", volumes[""], "sub/file", "dat");
	});

	it('Invalid file desc', function() {
		rejected("X3", "[TRA]/sub/../../TMP/file.txt", volumes["TRA"], "../file", "txt");
		rejected("X3", "[TRA]/../file.txt", volumes["TRA"], "file", "txt");
		rejected("X3", "[TRA]../file.txt", volumes["TRA"], "file", "txt");
		rejected("X3", "[TRA]/../TRT/file.src", volumes["TRA"], "file", "src");
		rejected("X3", "../TRT/file.src", volumes[""], "file", "src");
	});
});