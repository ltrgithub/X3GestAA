"use strict";

var sys = require("util");
var net = require("net");
var crypto = require("crypto");
var helpers = require("syracuse-core/lib/helpers");
var fs = require('streamline-fs');
var fsp = require("path");
var config = require('config'); // must be first syracuse require
var ez = require('ez-streams');

var tracer; // = console.log;

var pub_key;
var priv_key;

function _makeToSignChallenge(userName, challenge) {
	var toSign = new Buffer(userName + "\0" + challenge, "utf8");
	//console.log("To sign: " + sys.inspect(toSign));
	return toSign;
}

function X3Mock() {
	var self = this;

	self._responses = [];

	function loadResponses(_) {
		var pathFiles = fsp.join(__dirname, "responses");
		var files = fs.readdir(pathFiles, _);
		if (files) {
			files.forEach_(_, function(_, file) {
				var pathFile = fsp.join(pathFiles, file);
				var data = fs.readFile(pathFile, "ascii", _);
				try {
					self._responses.push(JSON.parse(data));
				} catch (e) {
					tracer("JSON PARSING ERROR : " + file);
				}
			});
		}
	}

	loadResponses();

	function readRequest(_, c, data) {
		var buf = data;
		//		console.log("mock in buffer" + sys.inspect(buf));
		var headLen = buf.readUInt32BE(0) - 1;
		var head = JSON.parse(c.read(_, headLen));
		// body read
		var chunks = [];
		do {
			buf = c.read(_, 5);
			var bodyLen = buf.readUInt32BE(0) - 1;
			if (bodyLen) chunks.push(c.read(_, bodyLen, "utf8"));
		} while (buf[4] == 2);
		//		_checkCode(frame.code, 3);
		//
		var respStr = chunks.join("");
		var body;
		if (respStr) try {
			body = JSON.parse(respStr);
		} catch (e) {
			tracer && tracer("x3Mock json parse error: " + respStr);
			body = {
				message: "JSON parse error"
			};
		}
		return {
			head: head,
			body: body
		};
	}

	function connectionRequest(request) {
		var respHead = {
			status: 201,
			location: "aaa"
		};
		self.challenge = helpers.uuid.generate();
		var respBody = {
			id: "123456",
			auth: {
				method: "X3RSA",
				challenge: self.challenge
			}
		};
		return {
			head: respHead,
			body: respBody
		};
	}

	self.onSessionRequest = function(request) {
		// check signature
		var verifier = crypto.createVerify(config.sdata.signAlgorithm);
		verifier.update(_makeToSignChallenge(request.body.auth.user, self.challenge));
		var respHead;
		if (verifier.verify(pub_key, request.body.auth.signature, "base64")) {
			respHead = {
				status: 201,
				location: "aaa"
			};
		} else {
			respHead = {
				status: 401
			};
		}
		var respBody = {
			id: "123456"
		};
		return {
			head: respHead,
			body: respBody
		};
	};

	function findItem(originalValue, item, url, method) {
		if (url.indexOf(item.url) === 0 && method === url.method) {
			return item.response;
		}
		return originalValue;
	}

	function findRequest(url, method) {
		var result = null;
		self._responses.forEach(function(item) {
			if (item.$items) {
				item.$items.forEach(function(itemChild) {
					result = findItem(result, itemChild, url, method);
				});
			} else {
				result = findItem(result, item, url, method);
			}
		});
		return result;
	}

	function dispatchRequest(request) {
		//console.log("dispatchRequest : " + sys.inspect(request));
		if (request.head.url) {
			var url = request.head.url;


			if (url == "/$connections") {
				return connectionRequest(request);
			}
			if (url == "/$sessions") {
				return self.onSessionRequest(request);
			}

			var response = findRequest(url, request.head.method);
			if (response) {
				return response;
			}

			return {
				head: {
					status: 404
				},
				body: {
					message: "NYI"
				}
			};

		}
	}

	function writeResponse(_, c, response) {
		tracer && tracer("x3MockwriteResponse enter");
		var respHead = JSON.stringify(response.head);
		var respBody = JSON.stringify(response.body);
		var len = Buffer.byteLength(respHead, "utf8");
		var resp = new Buffer(len + 5);
		resp.writeInt32BE(len + 1, 0);
		resp[4] = 0x01;
		resp.write(respHead, 5, "utf8");
		c.write(_, resp);

		len = Buffer.byteLength(respBody, "utf8");
		resp = new Buffer(len + 5);
		resp.writeInt32BE(len + 1, 0);
		resp[4] = 0x03;
		resp.write(respBody, 5, "utf8");
		c.write(_, resp);
	}

	self.close = function() {
		if (self.crtSocket) self.crtSocket.end();
	};

	self.server = ez.devices.net.server(function(c, _) {
		try {
			self.crtSocket = c;
			var data = c.read(_, 4);
			if (data.readUInt32BE(0) !== 0x00070300) throw new Error("connection refused: bad magic");
			c.write(_, new Buffer([0, 0, 1, 2]));
			while (data = c.read(_, 5)) {
				tracer && tracer("x3Mock net server data(5): " + sys.inspect(data));
				if (data[4] !== 0x01) throw new Error("bad request type: " + data[4]);
				var request = readRequest(_, c, data);
				var head = request.head;
				var body = request.body;
				tracer && tracer("x3Mock request: " + sys.inspect(request, null, 4));
				var response = dispatchRequest(request);
				tracer && tracer("x3Mock response: " + sys.inspect(response, null, 4));
				writeResponse(_, c, response);
			}
		} catch (ex) {
			console.error(ex.stack);
			throw ex;
		}
	});
}

exports.create = function(_, port) {
	pub_key = fs.readFile(fsp.join(__dirname, "../../", config.sdata.pubkeyName + ".pem"), "ascii", _);
	priv_key = fs.readFile(fsp.join(__dirname, "../../key.pem"), "ascii", _);
	var mock = new X3Mock();
	mock.server.listen(_, port);
	return mock;
};