"use strict";

var flows = require('streamline/lib/util/flows');
var streams = require('streamline/lib/streams/streams');
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var util = require('util');
var sys = util;
var x3helpers = require("./helpers");
var locale = require("syracuse-core/lib/locale");
var jsRunner = require('syracuse-x3/lib/jsRunner');
var globals = require('streamline/lib/globals');
var check = require("syracuse-license/lib/check");
var docx = require('msoffice/lib/word/docx');
var xlsx = require('msoffice/lib/excel/xlsx');
var helpers = require("syracuse-core/lib/helpers");
var httpHelper = require('syracuse-sdata/lib/httpHelper');
var perfmon = require("syracuse-perfmon");
var licenseCheck = require("syracuse-license/lib/check");



function _getSrvErrorFromResponse(mainMess, response) {
	var error, message = mainMess,
		diagnoses = null;
	if (response.body && response.body.$diagnoses && response.body.$diagnoses.length > 0) {
		diagnoses = response.body.$diagnoses;
	} else if (response.body && response.body.$diagnoses) {
		diagnoses = [response.body.$diagnoses];
	} else {
		message = mainMess + ": " + JSON.stringify(response.body);
	}
	error = new Error(message);
	if (response.head && response.head.statusCode)
		error.httpStatus = response.head.statusCode;
	if (response.body)
		error.httpBody = response.body;
	if (diagnoses)
		error.$diagnoses = diagnoses;
	return error;
}

function _getDiagMessage(d) {
	return d.message || d.$message;
}

function _getError(d) {
	var err = new Error(_getDiagMessage(d));
	err.$stackTrace = d.$stackTrace;
	return err;
}

function ReadableMemoryStream(data, enc) {
	var self = this;
	//
	var position = 0;
	var buffer = new Buffer(data, enc);
	var encoding = enc;
	//
	self.read = function(_, len) {
		var end = (len ? (len + position) : buffer.length);
		if (position >= buffer.length) return null;
		var buf = buffer.toString(encoding, position, end);
		position = end;
		return buf;
	};
}

function WritableMemoryStream() {
	var self = this;
	//
	var chunks = [];
	//
	self.write = function(_, data, enc) {
		chunks.push(typeof data === "string" ? new Buffer(data, enc || "utf8") : data);
	};
	self.toString = function(enc) {
		return chunks.map(function(chunk) {
			return chunk.toString(enc);
		}).join("");
	};
	self.end = function() {
		// ?
	};
}

function X3Client(config) {
	var _tracer = config.tracer;
	var _client = streams.tcpClient(config.port, config.address, {
		read: {
			timeout: (config.x3Pool && config.x3Pool.timeout) || 600000
		}
	});
	var _stream = null;
	var _funnel = flows.funnel(1);
	var _x3;
	var _busy = false;
	var _baseUrl = "";
	var self = this;

	this.read = function(_, len, withTimeout) {
		try {
			return _stream.read(_, len, withTimeout);
		} catch (e) {
			if (e.code === "ETIMEOUT") e.message = locale.format(module, "x3ReadTimeout", len, _stream.available());
			// destroy stream
			_stream.destroy();
			_stream = null;
			//
			throw e;
		}
	};

	function _outBuffer(code, obj) {
		var toSend;
		if (Buffer.isBuffer(obj)) toSend = obj;
		else {
			toSend = ((typeof obj === "object") ? JSON.stringify(obj) : obj);
			toSend = toSend ? new Buffer(toSend, "utf8") : new Buffer([]);
		}
		var len = toSend.length + 1;
		_tracer && _tracer("X3.client.outBuffer: sending length: " + len);
		var buf = new Buffer(len + 4);
		buf[0] = (len >> 24) & 0xff;
		buf[1] = (len >> 16) & 0xff;
		buf[2] = (len >> 8) & 0xff;
		buf[3] = len & 0xff;
		buf[4] = code;
		toSend.copy(buf, 5);
		return buf;
	}

	function _readInt(chunk) {
		return (chunk[0] << 24) | (chunk[1] << 16) | (chunk[2] << 8) | chunk[3];
	}

	function _readFrame(_, encoding) {
		_tracer && _tracer("reading frame from X3");
		var intro = self.read(_, 5, true);
		if (intro == null) throw new Error("error reading frame: stream closed");
		var len = _readInt(intro);
		_tracer && _tracer("reading frame from X3: got len=" + (len - 1));
		var data = self.read(_, len - 1, true);
		_tracer && _tracer("frame read ok");
		return {
			code: intro[4],
			//			data: (len > 1) ? (encoding ? data && data.toString(encoding) : data) : null
			data: (encoding ? data && data.toString(encoding) : data)
		};
	}

	function _checkCode(got, expected) {
		if (got != expected) throw new Error("bad frame code: got " + got + ", expected " + expected);
	}

	// wrapper for the streaming _send function

	function _jsonSend(_, params) {
		return _funnel(_, function(_) {
			var response = new WritableMemoryStream();
			response.writeHead = function(statusCode, headers) {
				this.statusCode = statusCode;
				this.headers = headers;
			};
			_send(_, params.head, new ReadableMemoryStream(JSON.stringify(params.body)), response);
			var respStr = response.toString("utf8");
			_tracer && _tracer("_jsonSend got response: " + respStr);
			if (respStr) try {
				respStr = JSON.parse(respStr);
			} catch (e) {
				// make a diagnose body
				respStr = {
					$diagnoses: [{
						$severity: "error",
						$message: respStr
					}]
				};
			} else respStr = null;
			//
			var result = {
				head: response.headers,
				body: respStr
			};
			result.head.statusCode = response.statusCode;
			//
			return result;
		});
	}

	function handleSpecialX3Calls(_, head) {

		function isSpecial(location) {
			var specials = ['js', 'future'];
			for (var i in specials) {
				if (location.indexOf(specials[i] + ":") === 0) return true;
			}
			return false;
		}
		var frame;
		// Intercept JS calls and (Http requests from X3 don't work for instance)
		while (head.location != null && isSpecial(head.location)) {
			var parts = head.location.split(':');
			var special = parts[0];
			var res = {};
			switch (special) {
				case "js":
					var modul = parts[1];
					frame = _readFrame(_);
					var x3json = null;
					try {
						x3json = JSON.parse(frame.data.toString('utf8'));
					} catch (e) {
						console.log("Parse error : " + e.stack);
						console.log(frame.data.toString('utf8'));
						res.body = '';
						res.header = {
							"statusCode": 500,
							"message": "Bad JSON: " + util.inspect(e.message) + "\n" + util.inspect(frame.data.toString('utf8')),
							"exception": e.stack
						};
					}
					try {
						if (x3json) {
							res = jsRunner.execute(_, modul, x3json);
						}
					} catch (e) {
						console.log("JS Error: " + e.stack);
						res.body = '';
						res.header = {
							"statusCode": 500,
							"message": e.message,
							"exception": e.stack
						};
					}
					break;
				case "future":
					var uuid = head.location.substring(7);
					frame = _readFrame(_);

					try {
						res = jsRunner.getResult(_, uuid);
					} catch (e) {
						console.log("Future retrieve Error: " + e.stack);
						res.body = '';
						res.header = {
							"statusCode": 500,
							"message": e.message,
							"exception": e.stack
						};
					}
					break;
				default:
					//Do nothing
			}
			var bodyStr;
			if (typeof res.body === 'object') {
				bodyStr = util.inspect(JSON.stringify(res.body)).replace(/\\\\/g, "\\");
			} else {
				bodyStr = JSON.stringify(res.body);
			}
			_stream.write(_, _outBuffer(1, JSON.stringify(res.header)));
			_stream.write(_, _outBuffer(2, ""));
			_stream.write(_, _outBuffer(3, bodyStr));

			frame = _readFrame(_);
			_checkCode(frame.code, 1);
			head = JSON.parse(frame.data);
			head.statusCode = head.status;
		}
	}

	function _send(_, header, request, response) {
		_tracer && _tracer("sending header: " + JSON.stringify(header));
		var timing = perfmon.start(module, "x3Client.send", header.url);

		if (header && header["x3-referer"]) {
			header["referer"] = header["x3-referer"];
			delete header["x3-referer"];
		}
		if (header && header["x3-content-length"]) {
			header["content-length"] = header["x3-content-length"];
			delete header["x3-content-length"];
		}

		//
		_stream.write(_, _outBuffer(1, header));
		var buf;
		while (buf = request.read(_)) {
			// FDB- Change util.inspect(buf) by (buf ? buf : "null") because it logs ' as \' which is confusing
			_tracer && _tracer("sending chunk: " + (buf ? buf : "null"));
			_stream.write(_, _outBuffer(2, buf));
		}
		_tracer && _tracer("write end frame");
		_stream.write(_, _outBuffer(3, ""));
		//
		var frame = _readFrame(_, "binary");
		_tracer && _tracer("received header frame: " + frame.data);
		_checkCode(frame.code, 1);
		var head = JSON.parse(frame.data);
		head.statusCode = head.status; // compat stuff -- fix protocol
		_tracer && _tracer("head.location: " + head.location);
		//
		// Special call allow to call javascript functions from 4GL and retrieve future callback results.
		handleSpecialX3Calls(_, head);

		if (request.url && (/\/IMAGE\(.*\).*mime=/.test(request.url) || /\/BDOC\(.*\).*mime=/.test(request.url))) {
			// Handles URLs like http://localhost:8124/sdata/x3/erp/SUPERV/IMAGE('C_AOBJBUR~BLOB~SQH~TEST')?word_document=true
			// by not serving the actual content but a dummy document containing the original URL so that word can
			// download the document itself
			handleSpecialMimetype(_, request, response, head);
		} else {
			response.writeHead(head.statusCode, head);
			//		var parts = [];
			//		var total = 0;
			do {
				// dont convert to UTF8, might be binary (images for ex.)
				//			frame = _readFrame(_, "utf8");
				frame = _readFrame(_);
				_tracer && _tracer("received body frame " + frame.code + ": " + frame.data.toString("utf8"));
				//			_tracer && _tracer("received body frame " + frame.code);
				if (head.statusCode === 500) {
					_tracer && _tracer("ERROR 500: head=" + JSON.stringify(head) + "\nbody=" + frame.data);
					console.error("ERROR 500: head=" + JSON.stringify(head) + "\nbody=" + frame.data);
				}
				//			response.write(_, frame.data, "utf8");
				response.write(_, frame.data);
				//			parts.push(frame.data);
				//			total += frame.data.length;
			} while (frame.code == 2);
			_checkCode(frame.code, 3);
		}

		_tracer && _tracer("ending response");
		response.end();
		timing.end();

		// suicide client if 500 response code as the X3 server might be in inconsistent state
		if (head.statusCode === 500) try {
			self.disconnect(_);
		} catch (e) {
			_stream = null;
		}

		// for diagnose
		return head;
	}

	function handleSpecialMimetype(_, request, response, head) {
		var document;
		var frame;
		var docUrl = request.context.url.split("?")[0];
		var filename = request.context.query.filename || "";
		var mime = request.context.query.mime || "";
		var buildevenlope = request.context.query.buildevenlope || "";
		var frames = [];
		var len = 0;

		do {
			frame = _readFrame(_);
			len += frame.data.length;
			frames.push(frame.data);

			if (head.statusCode === 500) {
				_tracer && _tracer("ERROR 500: head=" + JSON.stringify(head) + "\nbody=" + frame.data);
				console.error("ERROR 500: head=" + JSON.stringify(head) + "\nbody=" + frame.data);
			}
		} while (frame.code == 2);
		_checkCode(frame.code, 3);

		var data;

		data = Buffer.concat(frames, len);
		if (mime === httpHelper.mediaTypes.docx && buildevenlope === "true") {
			document = docx.handleV6Document(_, data, docUrl);
			data = {
				data: document.data,
				type: document.type
			};
		} else if (mime === httpHelper.mediaTypes.xlsx && buildevenlope === "true") {
			document = xlsx.handleV6Document(_, data, docUrl);
			data = {
				data: document.data,
				type: document.type
			};
		} else {
			data = {
				data: data,
				type: mime
			};
		}

		head["content-type"] = data.type;
		head["content-disposition"] = "attachment; filename=\"" + filename + "\"";
		response.writeHead(head.statusCode, head);
		response.write(_, data.data);
	}

	function _response(response) {
		return {
			statusCode: response.head.statusCode,
			headers: response.head,
			body: response.body
		};
	}

	this.isAlive = function() {
		return _stream && !_stream.closed;
	};

	this.busy = function() {
		return _busy;
	};

	this.checkServerSettings = function(_, params) {
		_tracer && _tracer("x3client.checkServerSettings enter");
		// dont check licences here as is just a connection test
		/*		var lic = check.getParsedLicense(_);
		if (lic && !lic.namedUsers)
			throw locale.format(module, "tooManyBadges");*/
		if (_stream) return [{
			$severity: "info",
			$message: locale.format(module, "serverConnected", config.address + ":" + config.port)
		}];
		try {
			_stream = _client.connect(_);
		} catch (e) {
			return [{
				$severity: "error",
				$message: locale.format(module, "connectionRefused", config.address, config.port, e.message)
			}];
		}
		_stream.write(_, new Buffer([0, 7, 3, params.fusion ? 1 : 0]));
		var pidBuf = self.read(_, 4, true);
		if (pidBuf == null) throw new Error("error reading pid: stream closed");
		_x3 = {
			pid: _readInt(pidBuf)
		};
		_tracer && _tracer("connected: pid=" + _x3.pid);

		var response = _jsonSend(_, {
			head: {
				method: "POST",
				url: "/$connections",
				"content-type": "application/json",
				"accept-language": params.locale || "en-US"
			},
			body: {
				server: params.server || "",
				folder: params.folder || "SUPERV"
			}
		});
		if (response.head.statusCode >= 400) {
			return (response.body && response.body.$diagnoses) || [{
				$severity: "error",
				$message: locale.format(module, "connectionRefused", config.address, config.port, response.head.statusCode)
			}];
		}
		_x3.connectionUrl = response.head.location;
		_x3.connectionId = response.body.id;
		_x3.auth = response.body.auth;
		// disconnect now
		var sendParams = {
			head: {
				method: "DELETE",
				url: "/$connections('" + _x3.connectionId + "')"
			},
			body: null
		};
		response = _jsonSend(_, sendParams);
		// close stream
		if (_stream) _stream.end();
		//
		return [{
			$severity: "info",
			$message: locale.format(module, "serverConnected", config.address + ":" + config.port)
		}];
	};

	this.connect = function(_, params) {
		_tracer && _tracer("x3client.connect enter");
		var lic = check.getParsedLicense(_);
		if (lic && !lic.namedUsers) throw locale.format(module, "tooManyBadges");
		if (_stream) throw new Error("already connected!");
		try {
			_stream = _client.connect(_);
			_stream.setNoDelay(true);
		} catch (e) {
			throw new Error(locale.format(module, "connectionRefused", config.address, config.port, e.message));
		}
		try {
			_stream.write(_, new Buffer([0, 7, 3, params.fusion ? 1 : 0]));
			var pidBuf = self.read(_, 4, true);
			if (pidBuf == null) throw new Error("error reading pid: stream closed");
			_x3 = {
				pid: _readInt(pidBuf)
			};
			_tracer && _tracer("connected: pid=" + _x3.pid + ", params=" + JSON.stringify(params));

			var response = _jsonSend(_, {
				head: {
					method: "POST",
					url: "/$connections",
					"content-type": "application/json",
					"accept-language": params.locale || "en-US"
				},
				body: {
					server: params.server || "",
					folder: params.folder || "SUPERV",
					runtimeLog: "" + (params.runtimeLog || ""),
					runtimeLogDir: "" + (params.runtimeLogDir || "")

				}
			});
			if (response.head.statusCode >= 400) {
				throw _getSrvErrorFromResponse(locale.format(module, "connectError"), response);
			}
			if (response.head.statusCode != 201) throw new Error("connect failed: " + JSON.stringify(response));
			_x3.connectionUrl = response.head.location;
			_x3.connectionId = response.body.id;
			_x3.auth = response.body.auth;
			if (!_x3.connectionUrl) throw new Error("connectionUrl missing");
			if (!_x3.connectionId) throw new Error("connectionId missing");
		} catch (e) {
			// close stream
			if (_stream) _stream.end();
			_stream = null;
		}
		//
		return _x3;
	};
	this.createSession = function(_, params) {
		_tracer && _tracer("x3client.createSession enter");
		if (!_x3) throw new Error("cannot create session: not connected");
		if (_x3.sessionUrl) throw new Error("cannot create session: previous session not closed");
		//
		_baseUrl = params.baseUrl;
		//
		params.userName = (params.userName || "sage").toLowerCase();
		//
		//console.log(params.locale);
		var sendParams = {
			head: {
				method: "POST",
				url: "/$sessions", // debug mode is curre,tly not supported: + (nodeconfig && nodeconfig.config && nodeconfig.config.debugMode ? "?debugMode=" + nodeconfig.config.debugMode : ""),
				"content-type": "application/json",
				"accept-language": params.locale || "en-US"
			},
			body: {
				connectionId: _x3.connectionId,
				sessionType: params.sessionType || "primary",
				adxtyp: params.adxtyp || 33, // 33 means primary, 34 is secondary
				baseUrl: params.baseUrl,
				collaborationBaseUrl: params.collaborationBaseUrl
			}
		};
		if (params.sysAuthToken) {
			sendParams.body.sysAuthToken = params.sysAuthToken;
		}
		if (_x3.auth && (_x3.auth.method === "X3RSA")) {
			sendParams.head.authorization = "x3-challenge";
			//
			//			console.log("nodeconf: "+require("util").inspect(nodeconfig.config));
			var pubkeyName = nodeconfig.config.sdata.pubkeyName;
			if (config.certificate) {
				pubkeyName = config.certificate.name(_).replace(/[\@\$\.]/g, "_");
			} else if (nodeconfig.config.x3key) { // use internal certificate of this server
				pubkeyName = require('os').hostname().toLowerCase().replace(/[\@\$\.]/g, "_");
			}
			_tracer && _tracer("pubkeyname " + pubkeyName);
			var auth = sendParams.body.auth = {
				method: "X3RSA",
				pubkey: pubkeyName,
				user: params.userName || "sage"
			};
			auth.signature = x3helpers.getSignature(_, _x3.auth.challenge, auth.user, config.certificate);
		} else sendParams.head.authorization = params.authToken || "auth-token";
		if (params.localePreferences) sendParams.body.preferences = {
			shortDateFormat: x3helpers.dateFormatToX3Format(params.localePreferences.shortDate(_)),
			longDateFormat: x3helpers.dateFormatToX3Format(params.localePreferences.longDate(_)),
			shortTimeFormat: x3helpers.dateFormatToX3Format(params.localePreferences.shortTime(_)),
			longTimeFormat: x3helpers.dateFormatToX3Format(params.localePreferences.longTime(_)),
			shortDatetimeFormat: x3helpers.dateFormatToX3Format(params.localePreferences.shortDatetime(_)),
			longDatetimeFormat: x3helpers.dateFormatToX3Format(params.localePreferences.longDatetime(_)),
			decimalSep: params.localePreferences.numberDecimalSeparator(_),
			thousandsSep: params.localePreferences.numberGroupSeparator(_),
			twoDigitYearMax: params.localePreferences.twoDigitYearMax(_),
			firstDayOfWeek: params.localePreferences.firstDayOfWeek(_)
		};
		sendParams.body.fusionTech = params.fusionTech;
		// console.log("SENDPARAMS "+require('util').format(sendParams))
		//
		try {
			var response = _jsonSend(_, sendParams);
			if (response.head.statusCode >= 400) {
				throw _getSrvErrorFromResponse(locale.format(module, "createSessError"), response);
			}
			if (response.head.statusCode != 201) throw new Error("create session failed: " + JSON.stringify(response));
			_x3.sessionUrl = response.head.location;
			_x3.sessionId = response.body.id; // ?
			if (!_x3.sessionUrl) throw new Error("sessionUrl missing");
			if (!_x3.sessionId) throw new Error("sessionId missing");
			//
			_x3.acceptLocale = params.locale || "en-US";
			_x3.contentLocale = response.head["content-language"];
			_x3.$links = response.body.$links;
			// license information
			var x3licData = response.body.license;
			if (x3licData && x3licData.product) {
				var lk = x3licData.$links && x3licData.$links.$license;
				if (lk) {
					var diags = [];
					var license = licenseCheck.getX3LicenseInfo(_, x3licData.product, x3licData.version, globals.context.session, diags);
					if (!license) {
						this.disconnect(_);
						var err = new Error(locale.format(module, "licenseError", x3licData.product, x3licData.version));
						err.$diagnoses = diags;
						throw err;
					}
					var response = _jsonSend(_, {
						head: {
							method: lk.$method,
							url: lk.$url,
							"content-type": "application/json",
							"accept-language": params.locale || "en-US"
						},
						body: license
					});
					if (response.head.statusCode >= 400) {
						throw _getSrvErrorFromResponse(locale.format(module, "licenseError", x3licData.product, x3licData.version), response);
					}
				}
			}
			//
			return _x3;
		} catch (e) {
			// close stream
			if (_stream) _stream.end();
			_stream = null;
		}
	};
	this.getSessionServiceLink = function(_, name) {
		return _x3 && _x3.$links && _x3.$links[name];
	};
	this.disconnect = function(_) {
		try {
			// disconnect session
			var sendParams = {
				head: {
					method: "DELETE",
					url: "/$sessions('" + _x3.sessionId + "')"
				},
				body: null
			};
			var response = _jsonSend(_, sendParams);
			if (response.head.statusCode >= 400) {
				throw _getSrvErrorFromResponse(locale.format(module, "closeSessError"), response);
			}
			if (response.head.statusCode != 204) throw new Error("disconnect session failed: " + JSON.stringify(response));

			// disconnect connection
			var sendParams = {
				head: {
					method: "DELETE",
					url: "/$connections('" + _x3.connectionId + "')"
				},
				body: null
			};
			var response = _jsonSend(_, sendParams);
			// TODO restore error management code, for now there is an error as X3 doesn't implement this order
			if (response.head.statusCode >= 400) {
				throw _getSrvErrorFromResponse(locale.format(module, "disconnectError"), response);
			}
			if (response.head.statusCode != 204) throw new Error("disconnect connection failed: " + JSON.stringify(response));
		} finally {
			// close stream
			if (_stream) _stream.end();
			_stream = null;
		}
	};

	function _clone(obj) {
		var result = {};
		for (var i in obj) result[i] = obj[i];
		return result;
	}

	// make it easier for X3, normalize single quotes

	function _fixUrl(str) {
		return str.replace(/%27/g, "'");
	}
	this.sendRequest = function(_, request, response) {
		return _funnel(_, function(_) {
			if (!_x3) throw new Error("cannot send request: not connected");
			if (!_x3.sessionUrl) throw new Error("cannot send request: no session");
			var head = _clone(request.headers || {});
			head.method = request.method;
			if (nodeconfig && nodeconfig.config && nodeconfig.config.x3Pool && nodeconfig.config.x3Pool.debugMode) {
				head["pragma"] = "debug-" + nodeconfig.config.x3Pool.debugMode; // "debug-immediate" for immediate stop or "debug-on" for stopping on breakpoints
			}
			_tracer && _tracer("X3 client requested url=" + request.url + "\n\theader=" + JSON.stringify(head));
			head.url = _fixUrl(request.url);
			if (!head["accept-language"]) head["accept-language"] = locale.current;
			return _send(_, head, request, response);
		});
	};
	this.jsonSend = function(_, params) {
		params.head.url = _fixUrl(params.head.url);
		return _jsonSend(_, params);
	};
	//

	function BulkReader(readerBaseUrl) {
		//
		var bulk = this;
		var _parts = [];
		var _done = false;
		var _frame = null;
		var diagnoses = [];
		//
		bulk.open = function(_, params) {
			// alloc this client for long read
			_busy = true;
			//
			diagnoses = [];
			_tracer && _tracer("opening bulk reader");
			// make request
			var x3head = {
				headers: {
					"accept": "application/json;vnd.sage=syracuse",
					"accept-language": locale.current || "en-US"
				},
				method: "GET",
				url: params.url
			};
			//
			_tracer && _tracer("bulk reader header params: " + sys.inspect(x3head, null, 4));
			_stream.write(_, _outBuffer(1, x3head));
			_stream.write(_, _outBuffer(3, ""));
			// receive
			var frame = _readFrame(_, "utf8");
			_tracer && _tracer("received header frame: " + frame.data);
			_checkCode(frame.code, 1);
			var head = JSON.parse(frame.data);
			head.statusCode = head.status; // compat stuff -- fix protocol
			bulk.header = head;
			if (head.status === 500) {
				// TODO: better error management ?
				_frame = JSON.parse(_readFrame(_, "utf8").data);
				_tracer && _tracer("bulkReader.open received error; frame " + JSON.stringify(_frame));
				if (_frame.$diagnoses && _frame.$diagnoses.length) throw _getError(_frame.$diagnoses[0]);
				else throw new Error(head.message);
			} else
			// future
				_frame = _readFrame(!_, "utf8");
			//
			return bulk;
		};
		bulk.next = function(_) {
			_tracer && _tracer("bulkReader.next enter");
			while (!_parts.length) {
				if (_done) return null;
				//
				var f = _frame(_);
				_tracer && _tracer("bulkReader.next received body frame " + f.code + ": " + f.data);
				if (f.code === 3) {
					_done = true;
					_busy = false;
				} else
				// next future
					_frame = _readFrame(!_, "utf8");
				//
				var res = f.data.split("\n");
				res.forEach(function(r) {
					// TODO: better extraction of start/end
					if (["{\"$resources\":[", "[", "]", "]}"].indexOf(r) >= 0) return;
					r = r.replace(/,$/, "");
					_tracer && _tracer("bulkReader.next resource :" + r);
					// TODO: how to interpret this ? should be an error ...
					if (!r) return;
					//
					try {
						var part = JSON.parse(r.replace(/,$/, ""));
						_parts.push(part);
					} catch (e) {
						diagnoses.push({
							$severity: "error",
							$message: e.message,
							$stackTrace: e.stack
						});
					}
				});
			}
			//
			return _parts.shift();
		};
	}
	//

	function QueryReader(readerBaseUrl) {
		//
		var bulk = this;
		var _parts = [];
		var _done = false;
		var _next = null;
		var diagnoses = [];
		//
		bulk.open = function(_, params) {
			// alloc this client for long read
			_busy = true;
			//
			diagnoses = [];
			_tracer && _tracer("opening query reader; url=" + params.url);
			// make request
			_next = _jsonSend(!_, {
				head: {
					"accept": "application/json;vnd.sage=syracuse",
					"accept-language": locale.current || "en-US",
					method: "GET",
					url: params.url
				},
				body: null
			});
			//
			return bulk;
		};
		bulk.next = function(_) {
			_tracer && _tracer("queryReader.next enter");
			while (!_parts.length) {
				if (_done) return null;
				//
				var r = _next(_);
				if (r.head.statusCode >= 400) {
					_tracer && _tracer("queryReader.next received error" + JSON.stringify(r.body));
					if (r.body.$diagnoses && r.body.$diagnoses.length) {
						throw _getError(r.body.$diagnoses[0]);
					} else throw new Error(r.head.message);
				}
				_parts = r.body.$resources;
				var url = r.body.$links && r.body.$links.$next && r.body.$links.$next.$url;
				if (!_parts.length || !url) {
					_done = true;
					_busy = false;
				} else {
					// future
					url = url.replace("{$baseUrl}", readerBaseUrl || _baseUrl);
					_tracer && _tracer("queryReader.next future; url=" + url);
					_next = _jsonSend(!_, {
						head: {
							"accept": "application/json;vnd.sage=syracuse",
							"accept-language": locale.current || "en-US",
							method: "GET",
							url: url
						},
						body: null
					});
				}
			}
			//
			return _parts.shift();
		};
	}

	this.createBulkReader = function(_, params) {
		try {
			var reader = (params.facet && params.facet === "$query") ? new QueryReader(params.baseUrl) : new BulkReader(params.baseUrl);
			return reader.open(_, params);
		} catch (e) {
			//			this.disconnect(_);
			throw e;
		}
	};

	this.getStream = function() {
		return _stream;
	};
}

exports.create = function(config) {
	return new X3Client(config);
};