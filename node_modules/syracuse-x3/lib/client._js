"use strict";

var flows = require('streamline/lib/util/flows');
var streams = require('streamline/lib/streams/streams');
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var util = require('util');
var x3helpers = require("./helpers");
var locale = require("syracuse-core/lib/locale");
var jsRunner = require('syracuse-x3/lib/jsRunner');
var globals = require('streamline/lib/globals');

function ReadableMemoryStream(data, enc) {
	var self = this;
	//
	var position = 0;
	var buffer = new Buffer(data, enc);
	var encoding = enc;
	//
	self.read = function(_, len) {
		var end = (len ? (len + position) : buffer.length);
		if (position >= buffer.length) return null;
		var buf = buffer.toString(encoding, position, end);
		position = end;
		return buf;
	}
}

function WritableMemoryStream() {
	var self = this;
	//
	var chunks = [];
	//
	self.write = function(_, data, enc) {
		chunks.push(new Buffer(data, enc));
	}
	self.toString = function(enc) {
		return chunks.map(function(chunk) {
			return chunk.toString(enc);
		}).join("");
	}
	self.end = function() {
		// ?
	}
}

function X3Client(config) {
	var _tracer = config.tracer;
	var _client = streams.tcpClient(config.port, config.address);
	var _stream = null;
	var _funnel = flows.funnel(1);
	var _x3;

	function _outBuffer(code, obj) {
		var json = ((typeof obj === "object") ? JSON.stringify(obj) : obj);
		var len = Buffer.byteLength(json) + 1;
		var buf = new Buffer(len + 4);
		buf[0] = (len >> 24) & 0xff;
		buf[1] = (len >> 16) & 0xff;
		buf[2] = (len >> 8) & 0xff;
		buf[3] = len & 0xff;
		buf[4] = code;
		buf.write(json, 5, 'utf8')
		return buf;
	}

	function _readInt(chunk) {
		return (chunk[0] << 24) | (chunk[1] << 16) | (chunk[2] << 8) | chunk[3];
	}

	function _readFrame(_, encoding) {
		var intro = _stream.read(_, 5);
		if (intro == null) throw new Error("error reading frame: stream closed");
		var len = _readInt(intro);
		var data = _stream.read(_, len - 1);
		return {
			code: intro[4],
			data: encoding ? data && data.toString(encoding) : data
		};
	}

	function _checkCode(got, expected) {
		if (got != expected) throw new Error("bad frame code: got " + got + ", expected " + expected);
	}

	function _concat(parts, total) {
		if (parts.length == 1) return parts[0];
		var result = new Buffer(total);
		parts.reduce(function(val, part) {
			part.copy(result, val);
			return val + part.length;
		}, 0);
		return result;
	}

	// wrapper for the streaming _send function

	function _jsonSend(_, params) {
		var response = new WritableMemoryStream();
		response.writeHead = function(statusCode, headers) {
			this.statusCode = statusCode;
			this.headers = headers;
		}
		_send(_, params.head, new ReadableMemoryStream(JSON.stringify(params.body)), response);
		var respStr = response.toString("utf8");
		var result = {
			head: response.headers,
			body: respStr ? JSON.parse(respStr) : null
		}
		result.head.statusCode = response.statusCode;
		//
		return result;
	}

	function _send(_, header, request, response) {
		_tracer && _tracer("sending header: " + JSON.stringify(header));
		//
		_stream.write(_, _outBuffer(1, header));
		var buf;
		while (buf = request.read(_)) {
			_tracer && _tracer("sending chunk: " + util.inspect(buf));
			_stream.write(_, _outBuffer(2, buf));
		}
		_stream.write(_, _outBuffer(3, ""));
		//
		var frame = _readFrame(_, "utf8");
		_tracer && _tracer("received header frame: " + frame.data);
		_checkCode(frame.code, 1);
		var head = JSON.parse(frame.data);
		head.statusCode = head.status; // compat stuff -- fix protocol
		//
		// Intercept JS calls and (Http requests from X3 don't work for instance)
		while (head.location != null && head.location.indexOf('js:') == 0) {

			var modul = head.location.substring(3);

			frame = _readFrame(_);

			var body, result = {};

			try {
				body = JSON.parse(frame.data.toString('utf8'));
				result = jsRunner.execute(_, modul, body);

			} catch (e) {
				result.body = ''
				result.header = {
					"statusCode": "500",
					"message": e.message,
					"exception": e.stack
				}
			}

			_stream.write(_, _outBuffer(1, result.header));
			_stream.write(_, _outBuffer(2, ""));
			_stream.write(_, _outBuffer(3, result.body));

			frame = _readFrame(_);

			_checkCode(frame.code, 1);
			head = JSON.parse(frame.data);
			head.statusCode = head.status;
		}


		response.writeHead(head.statusCode, head);
		//		var parts = [];
		//		var total = 0;
		do {
			// dont convert to UTF8, might be binary (images for ex.)
			//			frame = _readFrame(_, "utf8");
			frame = _readFrame(_);
			_tracer && _tracer("received body frame " + frame.code + ": " + frame.data);
			//			_tracer && _tracer("received body frame " + frame.code);
			if (head.statusCode === 500) {
				_tracer && _tracer("ERROR 500: head=" + JSON.stringify(head) + "\nbody=" + frame.data);
				console.error("ERROR 500: head=" + JSON.stringify(head) + "\nbody=" + frame.data);
			}
			//			response.write(_, frame.data, "utf8");
			response.write(_, frame.data);
			//			parts.push(frame.data);
			//			total += frame.data.length;
		} while (frame.code == 2);
		_checkCode(frame.code, 3);
		response.end();

		// for diagnose
		return head;
	}

	function _response(response) {
		return {
			statusCode: response.head.statusCode,
			headers: response.head,
			body: response.body
		};
	}

	this.isAlive = function() {
		return _stream && !_stream.closed;
	}

	this.connect = function(_, params) {
		_tracer && _tracer("x3client.connect enter");
		if (_stream) throw new Error("already connected!");
		try {
			_stream = _client.connect(_);
		} catch (e) {
			throw new Error(locale.format(module, "connectionRefused", config.address, config.port, e.message));
		}
		_stream.write(_, new Buffer([0, 7, 3, 0]));
		var pidBuf = _stream.read(_, 4);
		if (pidBuf == null) throw new Error("error reading pid: stream closed")
		_x3 = {
			pid: _readInt(pidBuf)
		};
		_tracer && _tracer("connected: pid=" + _x3.pid);

		var response = _jsonSend(_, {
			head: {
				method: "POST",
				url: "/$connections",
				"content-type": "application/json",
				"accept-language": params.locale || "en-US"
			},
			body: {
				server: params.server || "",
				folder: params.folder || "SUPERV"
			}
		});
		if (response.head.statusCode >= 400) {
			var error = new Error("create session error: " + JSON.stringify(response.body));
			error.httpStatus = response.head.statusCode;
			throw error;
		}
		if (response.head.statusCode != 201) throw new Error("connect failed: " + JSON.stringify(response));
		_x3.connectionUrl = response.head.location;
		_x3.connectionId = response.body.id;
		_x3.auth = response.body.auth;
		if (!_x3.connectionUrl) throw new Error("connectionUrl missing")
		if (!_x3.connectionId) throw new Error("connectionId missing")
	}
	this.createSession = function(_, params) {
		_tracer && _tracer("x3client.createSession enter");
		if (!_x3) throw new Error("cannot create session: not connected");
		if (_x3.sessionUrl) throw new Error("cannot create session: previous session not closed");
		//
		params.userName = (params.userName || "sage").toLowerCase();
		//
		var sendParams = {
			head: {
				method: "POST",
				url: "/$sessions", // debug mode is curre,tly not supported: + (nodeconfig && nodeconfig.config && nodeconfig.config.debugMode ? "?debugMode=" + nodeconfig.config.debugMode : ""), 
				"content-type": "application/json",
				"accept-language": params.locale || "en-US"
			},
			body: {
				connectionId: _x3.connectionId,
				sessionType: params.sessionType || "primary",
				adxtyp: params.adxtyp || 33 // 33 means primary, 34 is secondary
			}
		};
		if (_x3.auth && (_x3.auth.method === "X3RSA")) {
			sendParams.head.authorization = "x3-challenge";
			//
			//			console.log("nodeconf: "+require("util").inspect(nodeconfig.config));
			var auth = sendParams.body.auth = {
				method: "X3RSA",
				pubkey: nodeconfig.config.sdata.pubkeyName,
				user: params.userName || "sage"
			};
			auth.signature = x3helpers.getSignature(_, _x3.auth.challenge, auth.user);
		} else sendParams.head.authorization = params.authToken || "auth-token";
		if (params.localePreferences) sendParams.body.preferences = {
			shortDateFormat: x3helpers.dateFormatToX3Format(params.localePreferences.shortDate(_)),
			longDateFormat: x3helpers.dateFormatToX3Format(params.localePreferences.longDate(_)),
			shortTimeFormat: x3helpers.dateFormatToX3Format(params.localePreferences.shortTime(_)),
			longTimeFormat: x3helpers.dateFormatToX3Format(params.localePreferences.longTime(_)),
			shortDatetimeFormat: x3helpers.dateFormatToX3Format(params.localePreferences.shortDatetime(_)),
			longDatetimeFormat: x3helpers.dateFormatToX3Format(params.localePreferences.longDatetime(_)),
			decimalSep: params.localePreferences.numberDecimalSeparator(_),
			thousandsSep: params.localePreferences.numberGroupSeparator(_)
		}
		//
		var response = _jsonSend(_, sendParams);
		if (response.head.statusCode >= 400) {
			var error = new Error("create session error: " + JSON.stringify(response.body));
			error.httpStatus = response.head.statusCode;
			throw error;
		}
		if (response.head.statusCode != 201) throw new Error("create session failed: " + JSON.stringify(response));
		_x3.sessionUrl = response.head.location;
		_x3.sessionId = response.body.id; // ?
		if (!_x3.sessionUrl) throw new Error("sessionUrl missing")
		if (!_x3.sessionId) throw new Error("sessionId missing");
		//
		_x3.acceptLocale = params.locale || "en-US";
		_x3.contentLocale = response.head["content-language"];
	}
	this.disconnect = function(_) {
		// disconnect session
		var sendParams = {
			head: {
				method: "DELETE",
				url: "/$sessions('" + _x3.sessionId + "')"
			},
			body: null
		};
		var response = _jsonSend(_, sendParams);
		if (response.head.statusCode >= 400) {
			var error = new Error("disconnect session error: " + JSON.stringify(response.body));
			error.httpStatus = response.head.statusCode;
			throw error;
		}
		if (response.head.statusCode != 204) throw new Error("disconnect session failed: " + JSON.stringify(response));

		// disconnect connection
		var sendParams = {
			head: {
				method: "DELETE",
				url: "/$connections('" + _x3.connectionId + "')"
			},
			body: null
		};
		var response = _jsonSend(_, sendParams);
		// TODO restore error management code, for now there is an error as X3 doesn't implement this order
		if (response.head.statusCode >= 400) {
			var error = new Error("disconnect connection error: " + JSON.stringify(response.body));
			error.httpStatus = response.head.statusCode;
			throw error;
		}
		if (response.head.statusCode != 204) throw new Error("disconnect connection failed: " + JSON.stringify(response));

		// close stream
		if (_stream) _stream.end();
	}

	function _clone(obj) {
		var result = {};
		for (var i in obj)
		result[i] = obj[i];
		return result;
	}

	// make it easier for X3, normalize single quotes

	function _fixUrl(str) {
		return str.replace(/%27/g, "'")
	}
	this.sendRequest = function(_, request, response) {
		return _funnel(_, function(_) {
			if (!_x3) throw new Error("cannot send request: not connected");
			if (!_x3.sessionUrl) throw new Error("cannot send request: no session");
			var head = _clone(request.headers || {});
			head.method = request.method;
			if (nodeconfig && nodeconfig.config && nodeconfig.config.x3Pool && nodeconfig.config.x3Pool.debugMode) {
				head["pragma"] = "debug-" + nodeconfig.config.x3Pool.debugMode; // "debug-immediate" for immediate stop or "debug-on" for stopping on breakpoints
			}
			_tracer && _tracer("X3 client requested url: "+request.url);
			head.url = _fixUrl(request.url);
			if (!head["accept-language"]) head["accept-language"] = locale.current;
			return _send(_, head, request, response);
		});
	}
	this.jsonSend = function(_, params) {
		params.head.url = _fixUrl(params.head.url);
		return _jsonSend(_, params);
	}
	//
	function BulkReader() {
		//
		var bulk = this;
		var _parts = [];
		var _done = false;
		var _frame = null;
		//
		bulk.open = function(_, params) {
			_tracer && _tracer("opening bulk reader");
			// make request
			var x3head = {
				headers: {
					"accept":"application/json;vnd.sage=syracuse",
					"accept-language": locale.current || "en-US"
				},
				method: "GET",
				url:  "/sdata/x3/erp/superv/" + params.entity + "?representation=" + params.entity + ".$bulk"
			}
			//
			_stream.write(_, _outBuffer(1, x3head));
			// receive
			var frame = _readFrame(_, "utf8");
			_tracer && _tracer("received header frame: " + frame.data);
			_checkCode(frame.code, 1);
			var head = JSON.parse(frame.data);
			head.statusCode = head.status; // compat stuff -- fix protocol
			bulk.header = head;
			// future
			bulk._frame = _readFrame();
			do {
				// dont convert to UTF8, might be binary (images for ex.)
				//			frame = _readFrame(_, "utf8");
				frame = _readFrame(_);
				_tracer && _tracer("received body frame " + frame.code + ": " + frame.data);
				//			_tracer && _tracer("received body frame " + frame.code);
				if (head.statusCode === 500) {
					_tracer && _tracer("ERROR 500: head=" + JSON.stringify(head) + "\nbody=" + frame.data);
					console.error("ERROR 500: head=" + JSON.stringify(head) + "\nbody=" + frame.data);
				}
				//			response.write(_, frame.data, "utf8");
				response.write(_, frame.data);
				//			parts.push(frame.data);
				//			total += frame.data.length;
			} while (frame.code == 2);
			_checkCode(frame.code, 3);
			response.end();

			// 
			return bulk;
		}
		bulk.next = function(_) {
			if(_done)
				return null;
			if(!_parts.length) {
				//
				var f = _frame(_);
				if(f.code === 3)
					_done = true;
				else
					// next future
					_frame = _readFrame();
				//
				var res = f.data.split("\n");
				res.forEach(function(r) {
					if((r === "[") || (r === "]"))
						return;
					_parts.push(JSON.parse(r));
				});
			}
			//
			return _parts.shift();
		}
	}

	this.createBulkReader = function(_, params) {
		var reader = new BulkReader();
		return reader.open(_, params);
	}
}

exports.create = function(config) {
	return new X3Client(config);
}