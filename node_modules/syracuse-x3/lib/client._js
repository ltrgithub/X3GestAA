"use strict";

var flows = require('streamline-runtime').flows;
var ez = require('ez-streams');
var nodeConfig = require("config");
var util = require('util');
var sys = util;
var x3helpers = require("./helpers");
var locale = require('streamline-locale');
var jsRunner = require('syracuse-x3/lib/jsRunner');
var globals = require('streamline-runtime').globals;
// adxWhatApiTest crashes node (at least on OSX node 0.12) if the next two lines are swapped.
// this is because upload helpers requires the mmmagic binary and there is a problem if this binary
// is loaded after the license add-on. Will investigate later
var uploadHelpers = require('../../../src/upload/helpers');
var check = require("../../../src/license/check");
var docx = require('msoffice/lib/word/docx');
var xlsx = require('msoffice/lib/excel/xlsx');
var helpers = require('@sage/syracuse-core').helpers;
var httpHelpers = require('@sage/syracuse-core').http;
var perfmon = require('../../../src/perfmon/record');
var adminHelper = require("../../../src/collaboration/helpers").AdminHelper;
var _protocolVersions = {
	WIRE_BASE: 2, // protocol supported by the runtime ($connections part). Currently not required
	WIRE: 2 // protocol supported by the supervisor ($sessions part)
};

function _getSrvErrorFromResponse(mainMess, response, params) {
	var error, message = mainMess,
		diagnoses = null;
	if (response.body && response.body.$diagnoses && response.body.$diagnoses.length > 0) {
		diagnoses = response.body.$diagnoses;
	} else if (response.body && response.body.$diagnoses) {
		diagnoses = [response.body.$diagnoses];
	} else {
		message = mainMess + ": " + JSON.stringify(response.body);
	}
	error = new Error(message);
	if (response.head && response.head.statusCode)
		error.httpStatus = response.head.statusCode;
	if (response.body)
		error.httpBody = response.body;
	if (diagnoses) {

		if (diagnoses[0]) {
			// Customize message for bad logins on connection
			if (diagnoses[0].$message === "Incorrect user / password") {
				diagnoses[0].$message = locale.format(module, "noMatchingUser", params.userName);
			}
			// Concat generic message and details
			diagnoses[0].$message = message + " : " + diagnoses[0].$message;
		}
		error.$diagnoses = diagnoses;
	}
	return error;
}

function _getDiagMessage(d) {
	return d.message || d.$message;
}

function _getError(d) {
	var err = new Error(_getDiagMessage(d));
	err.$stackTrace = d.$stackTrace;
	return err;
}

function ReadableMemoryStream(data, enc) {
	var self = this;
	//
	var position = 0;
	var buffer = new Buffer(data, enc);
	var encoding = enc;
	//
	self.read = function(_, len) {
		var end = (len ? (len + position) : buffer.length);
		if (position >= buffer.length) return null;
		var buf = buffer.toString(encoding, position, end);
		position = end;
		return buf;
	};
}

function WritableMemoryStream() {
	var self = this;
	//
	var chunks = [];
	//
	self.write = function(_, data, enc) {
		chunks.push(typeof data === "string" ? new Buffer(data, enc || "utf8") : data);
	};
	self.toString = function(enc) {
		return chunks.map(function(chunk) {
			return chunk.toString(enc);
		}).join("");
	};
	self.end = function() {
		// ?
	};
}
exports.WritableMemoryStream = WritableMemoryStream;

function X3Client(poolConfig) {
	var _tracer = poolConfig.tracer;
	var _client;
	var _stream = null;
	var _funnel = flows.funnel(1);
	var _x3;
	var _busy = false;
	var _async = poolConfig.async;
	var _baseUrl = "";
	var _endpointDataset = "";
	var self = this;
	this.init = function(_) {
		if (!poolConfig.x3solution && !poolConfig.x3server) throw new Error("x3solution instance MUST be set in client config");
		_client = null;
		_stream = null;
		_x3 = null;
		_busy = false;
		_baseUrl = "";
		// select x3 server with round robin
		if (poolConfig.x3server) this.exactServer = true;
		this.x3server = poolConfig.x3server || poolConfig.x3solution.selectX3Server(_, {
			tags: poolConfig.x3serverTags
		});
		_client = ez.devices.net.tcpClient(this.x3server.serverPort(_), this.x3server.serverHost(_), {
			read: {
				timeout: (nodeConfig.x3Pool && nodeConfig.x3Pool.timeout) || 600000
			}
		});
		return this;
	};

	this.read = function(_, len, withTimeout) {
		try {
			return _stream.read(_, len, false);
		} catch (e) {
			if (e.code === "ETIMEOUT") e.message = locale.format(module, "x3ReadTimeout", len, _stream.available());
			// destroy stream
			if (_stream) _stream.destroy();
			_stream = null;
			//
			throw e;
		}
	};

	this.getSessionId = function() {
		return _x3 && _x3.sessionId;
	};

	this.getProcessId = function() {
		return _x3 && _x3.pid;
	};

	function _outBuffer(code, obj) {
		var toSend;
		if (Buffer.isBuffer(obj)) toSend = obj;
		else {
			toSend = ((typeof obj === "object") ? JSON.stringify(obj) : obj);
			toSend = toSend ? new Buffer(toSend, "utf8") : new Buffer([]);
		}
		var len = toSend.length + 1;
		_tracer && _tracer.info && _tracer.info("X3.client.outBuffer: sending length: " + len);
		var buf = new Buffer(len + 4);
		buf[0] = (len >> 24) & 0xff;
		buf[1] = (len >> 16) & 0xff;
		buf[2] = (len >> 8) & 0xff;
		buf[3] = len & 0xff;
		buf[4] = code;
		toSend.copy(buf, 5);
		return buf;
	}

	function _readInt(chunk) {
		return (chunk[0] << 24) | (chunk[1] << 16) | (chunk[2] << 8) | chunk[3];
	}

	function _readFrame(_, encoding) {
		_tracer && _tracer.info && _tracer.info("reading frame from X3");
		var intro = self.read(_, 5, true);
		if (intro == null) throw new Error("error reading frame: stream closed");
		var len = _readInt(intro);
		_tracer && _tracer.info && _tracer.info("reading frame from X3: got len=" + (len - 1));
		var data = self.read(_, len - 1, true);
		_tracer && _tracer.info && _tracer.info("frame read ok");
		return {
			code: intro[4],
			//			data: (len > 1) ? (encoding ? data && data.toString(encoding) : data) : null
			data: (encoding ? data && data.toString(encoding) : data)
		};
	}

	function _checkCode(got, expected) {
		if (got != expected) throw new Error("bad frame code: got " + got + ", expected " + expected);
	}

	function _getConnectRequest(_, params) {
		return {
			head: {
				method: "POST",
				url: "/$connections",
				"content-type": "application/json",
				"accept-language": params.locale || "en-US"
			},
			body: {
				// wireBaseProtocolVersion: _protocolVersions.WIRE_BASE,
				wireProtocolVersion: _protocolVersions.WIRE,
				server: (params.server && (self.x3server.serverHost(_) !== params.server)) ? params.server : "", // MAIN server MUST NOT be set
				folder: params.folder || "X3",
				runtimeLog: "" + (params.runtimeLog || ""),
				runtimeLogDir: "" + (params.runtimeLogDir || "")
			}
		};
	}

	function _getDisconnectRequest() {
		return {
			head: {
				method: "DELETE",
				url: "/$connections('" + _x3.connectionId + "')"
			},
			body: null
		};
	}

	// wrapper for the streaming _send function
	//  #3978 - funnel!=null -> Force to use a new funnel 
	function _jsonSend(_, params, funnel) {
		if (!funnel) funnel = _funnel;
		return funnel.call(null, _, function(_) {
			var response = new WritableMemoryStream();
			response.writeHead = function(statusCode, headers) {
				this.statusCode = statusCode;
				this.headers = headers;
			};
			_tracer && _tracer.info && _tracer.info("_jsonSend : " + JSON.stringify(params.body));
			_send(_, params.head, new ReadableMemoryStream(params.raw && typeof(params.body) === "string" ? params.body : JSON.stringify(params.body)), response);
			var respStr = response.toString("utf8");

			_tracer && _tracer.info && _tracer.info("_jsonSend got response: " + respStr);
			if (params.raw) {
				// no transformation
			} else if (respStr) try {
				respStr = JSON.parse(respStr);
			} catch (e) {
				// make a diagnose body
				respStr = {
					$diagnoses: [{
						$severity: "error",
						$message: respStr
					}]
				};
			} else respStr = null;
			//
			var result = {
				head: response.headers || {},
				body: respStr
			};
			result.head.statusCode = response.statusCode;
			//
			return result;
		});
	}

	function handleSpecialX3Calls(_, head) {

		function isSpecial(location) {
			var specials = ['js', 'future'];
			for (var i in specials) {
				if (location.indexOf(specials[i] + ":") === 0) return true;
			}
			return false;
		}
		var frame;
		// Intercept JS calls and (Http requests from X3 don't work for instance)
		while (head.location != null && isSpecial(head.location)) {
			var parts = head.location.split(':');
			var location = head.location;
			delete head.location;
			var special = parts[0];
			var res = {};
			switch (special) {
				case "js":
					var modul = parts[1];
					frame = _readFrame(_);
					var x3json = null;
					try {
						x3json = JSON.parse(frame.data.toString('utf8'));
					} catch (e) {
						_tracer && _tracer.error && _tracer.error("Parse error : " + e.stack);
						_tracer && _tracer.error && _tracer.error(frame.data.toString('utf8'));
						res.body = '';
						res.header = {
							"statusCode": 500,
							"message": "Bad JSON: " + util.inspect(e.message) + "\n" + util.inspect(frame.data.toString('utf8')),
							"exception": e.safeStack
						};
					}
					try {
						if (x3json) {
							globals.context.endpointDataset = _endpointDataset;
							res = jsRunner.execute(_, modul, x3json);
						}
					} catch (e) {
						_tracer && _tracer.error && _tracer.error("JS Error: " + e.stack);
						res.body = '';
						res.header = {
							"statusCode": 500,
							"message": e.message,
							"exception": e.safeStack
						};
					}
					break;
				case "future":
					var uuid = location.substring(7);
					frame = _readFrame(_);

					try {
						res = jsRunner.getResult(_, uuid);
					} catch (e) {
						_tracer && _tracer.error && _tracer.error("Future retrieve Error: " + e.stack);
						res.body = '';
						res.header = {
							"statusCode": 500,
							"message": e.message,
							"exception": e.safeStack
						};
					}
					break;
				default:
					//Do nothing
			}
			var bodyStr;
			if (typeof res.body === 'object') {
				bodyStr = util.inspect(JSON.stringify(res.body)).replace(/\\\\/g, "\\");
			} else {
				bodyStr = JSON.stringify(res.body);
			}
			_stream.write(_, _outBuffer(1, JSON.stringify(res.header)));
			_stream.write(_, _outBuffer(2, ""));
			_stream.write(_, _outBuffer(3, bodyStr));

			frame = _readFrame(_);
			_checkCode(frame.code, 1);
			head = JSON.parse(frame.data);
			head.statusCode = head.status;
		}
		// remove location header. it's not useful for the client




	}

	// licenseData: optional licenseData of X3 client object
	function _send(_, header, request, response, licenseData) {
		_tracer && _tracer.info && _tracer.info("sending header: " + JSON.stringify(header));
		if (_stream == null) { // method must not be called when _stream does not exist any more. This avoids null pointer errors
			_tracer && _tracer.error && _tracer.error("_send called when stream has been deleted " + JSON.stringify(header));
			return;
		}
		var timing = perfmon.start(module, "x3Client.send", header.url);

		if (header && header["x3-referer"]) {
			header["referer"] = header["x3-referer"];
			delete header["x3-referer"];
		}
		var inputLength = 0;
		var duration;
		var status;
		// license check only for API1 RESTful service calls
		// if (true) { 			licenseData = {product:"1"};
		if (licenseData && request.session && request.session.apiPrefix === 'api1') {
			// Explanation of the mechanism: The first call to check.step is before the invocation 
			// so that the system does not execute the service at all. Since I do not know whether 
			// the "content-length" header is set, I firstly add the value (because it has to be counted anyway). 
			// I take the minus value, because I increase the inputLength by the lengths of all input data in 
			// the loop "while ((buf = reader.read(_)))" below. 
			// So when "content-length" is set, it should be 0 after processing the input (because the value 
			// of the content length has already been told to the license system), when "content-length" is not 
			// set, inputLength should have the length of all input after processing the input. 
			// Later, the length of all output for the response is added in the loop "while (frame.code == 2)"
			// below. The next invocation of check.step is necessary so that the license system also gets to 
			// know the length of the response.
			inputLength = -(header && header["content-length"] || 0);

			status = check.step(_, -inputLength || 1, {
				product: {
					code: licenseData.product
				}
			});
			// status = 2;
			// Web services system will blocked --> the grace limit is exceeded
			if (status < 0) {
				var resp = JSON.stringify({
					$diagnoses: [{
						$severity: "error",
						$message: locale.format(module, "systemBlocked")
					}]
				});
				resp = new Buffer(resp);
				response.writeHead(400, {
					"content-type": "application/json",
					"content-encoding": "utf8",
					"content-length": resp.length
				});
				response.end(resp);
				return;
			}
			// system will be slown down
			else if (status > 0) {
				duration = Date.now(); // start of license time measuring
			}
		}
		if (header && header["x3-content-length"]) {
			header["content-length"] = header["x3-content-length"];
			delete header["x3-content-length"];
		}

		var reader = request;
		if (request.method === "PUT" && request.url && (/\/\$workingCopies\(.*\)\//.test(request.url))) {
			var options = {
				contentType: request.headers["x-content-type-override"] || request.headers["content-type"],
				fileName: request.headers["x-file-name"]
			};
			reader = uploadHelpers.sanitizeReader(_, request, options.contentType);
		}
		//
		_stream.write(_, _outBuffer(1, header));
		var buf;
		while ((buf = reader.read(_))) {
			inputLength += buf.length;
			// FDB- Change util.inspect(buf) by (buf ? buf : "null") because it logs ' as \' which is confusing
			_tracer && _tracer.info && _tracer.info("sending chunk: " + (buf ? buf : "null"));
			_stream.write(_, _outBuffer(2, buf));
		}
		_tracer && _tracer.info && _tracer.info("write end frame");
		_stream.write(_, _outBuffer(3, ""));
		//
		var frame = _readFrame(_, "binary");
		_tracer && _tracer.info && _tracer.info("received header frame: " + frame.data);
		_checkCode(frame.code, 1);
		var head = JSON.parse(frame.data);
		head.statusCode = head.status; // compat stuff -- fix protocol
		_tracer && _tracer.info && _tracer.info("head.location: " + head.location);
		//
		// Special call allow to call javascript functions from 4GL and retrieve future callback results.
		handleSpecialX3Calls(_, head);
		// license check: maybe slow down
		if (duration && status > 0) {
			duration = Date.now() - duration; // now duration contains the time between the start and now
			setTimeout(_, duration * (status - 1)); // wait so that the total time will be status times execution time;
		}
		if (request.url && (/\/IMAGE\(.*\).*mime=/.test(request.url) || /\/BDOC\(.*\).*mime=/.test(request.url))) {
			// Handles URLs like http://localhost:8124/sdata/x3/erp/SUPERV/IMAGE('C_AOBJBUR~BLOB~SQH~TEST')?word_document=true
			// by not serving the actual content but a dummy document containing the original URL so that word can
			// download the document itself
			handleSpecialMimetype(_, request, response, head);
		} else {
			var pendingHeader = true;
			//		var parts = [];
			//		var total = 0;
			do {
				// dont convert to UTF8, might be binary (images for ex.)
				//			frame = _readFrame(_, "utf8");
				frame = _readFrame(_);
				_tracer && _tracer.info && _tracer.info("received body frame " + frame.code + ": " + frame.data.toString("utf8"));
				//			_tracer && _tracer.info && _tracer.info("received body frame " + frame.code);
				if (pendingHeader) {
					pendingHeader = false;
					if (head["content-type"] === "image") {
						// Find a more relevant image type
						head["content-type"] = uploadHelpers.detectMediaType(frame.data, _);
					}
					response.writeHead(head.statusCode, head);
				}
				if (head.statusCode === 500) {
					_tracer && _tracer.error && _tracer.error("ERROR 500: head=" + JSON.stringify(head) + "\nbody=" + frame.data);
					//console.error("ERROR 500: head=" + JSON.stringify(head) + "\nbody=" + frame.data);
				}
				//			response.write(_, frame.data, "utf8");
				response.write(_, frame.data);
				inputLength += frame.data.length;
				//			parts.push(frame.data);
				//			total += frame.data.length;
			} while (frame.code == 2);
			_checkCode(frame.code, 3);
		}
		_tracer && _tracer.info && _tracer.info("ending response");
		response.end();
		timing.end();
		// license check
		if (licenseData && inputLength > 0 && request.session.apiPrefix === 'api1') { // just measure the end of the invocation
			check.step(_, inputLength, {
				product: {
					code: licenseData.product
				}
			});
		}
		// suicide client if 500 response code as the X3 server might be in inconsistent state
		if (head.statusCode === 500) {
			try {
				//  #3978 - _send is called through a funnel - We force to use a new funnel to disconnect because current _funnel is busy
				self.disconnect(_, flows.funnel(1));
			} catch (e) {
				_stream = null;
			}
		}
		// for diagnose
		return head;
	}

	function handleSpecialMimetype(_, request, response, head) {
		var document;
		var frame;
		var docUrl = request.context.url.split("?")[0];
		var filename = request.context.query.filename || "";
		var mime = request.context.query.mime || "";
		var buildevenlope = request.context.query.buildevenlope || "";
		var frames = [];
		var len = 0;

		do {
			frame = _readFrame(_);
			len += frame.data.length;
			frames.push(frame.data);

			if (head.statusCode === 500) {
				_tracer && _tracer.error && _tracer.error("ERROR 500: head=" + JSON.stringify(head) + "\nbody=" + frame.data);
				//console.error("ERROR 500: head=" + JSON.stringify(head) + "\nbody=" + frame.data);
			}
		} while (frame.code == 2);
		_checkCode(frame.code, 3);

		var data;

		data = Buffer.concat(frames, len);
		if (mime === httpHelpers.mediaTypes.docx && buildevenlope === "true") {
			document = docx.handleV6Document(_, data, docUrl);
			data = {
				data: document.data,
				type: document.type
			};
		} else if (mime === httpHelpers.mediaTypes.xlsx && buildevenlope === "true") {
			document = xlsx.handleV6Document(_, data, docUrl);
			data = {
				data: document.data,
				type: document.type
			};
		} else {
			data = {
				data: data,
				type: mime
			};
		}

		head["content-type"] = data.type;
		head["content-disposition"] = "attachment; filename=\"" + filename + "\"";
		response.writeHead(head.statusCode, head);
		response.write(_, data.data);
	}

	function _response(response) {
		return {
			statusCode: response.head.statusCode,
			headers: response.head,
			body: response.body
		};
	}

	this.isAlive = function() {
		return _stream && !_stream.closed;
	};

	this.busy = function() {
		return _busy || _async;
	};

	this.checkServerSettings = function(_, params) {
		_tracer && _tracer.info && _tracer.info("x3client.checkServerSettings enter");
		// dont check licences here as is just a connection test
		/*		var lic = check.getParsedLicense(_);
		if (lic && !lic.namedUsers && lic.sessionControl !== "concurrent")
			throw locale.format(module, "tooManyBadges");*/
		this.init(_);
		if (_stream) return [{
			$severity: "info",
			$message: locale.format(module, "serverConnected", this.x3server.serverHost(_) + ":" + this.x3server.serverPort(_))
		}];
		try {
			_stream = _client.connect(_);
		} catch (e) {
			return [{
				$severity: "error",
				$message: locale.format(module, "connectionRefused", this.x3server.serverHost(_), this.x3server.serverPort(_), e.message)
			}];
		}
		_stream.write(_, new Buffer([0, 7, 3, params.fusion ? 1 : 0]));
		var pidBuf = self.read(_, 4, true);
		if (pidBuf == null) throw new Error("error reading pid: stream closed");
		_x3 = {
			pid: _readInt(pidBuf)
		};
		_tracer && _tracer.info && _tracer.info("connected: pid=" + _x3.pid);

		var connectionRequest = _getConnectRequest(_, params);
		var response = _jsonSend(_, connectionRequest);
		if (response.head.statusCode >= 400) {
			return (response.body && response.body.$diagnoses) || [{
				$severity: "error",
				$message: locale.format(module, "connectionRefused", this.x3server.serverHost(_), this.x3server.serverPort(_), response.head.statusCode)
			}];
		}
		_x3.connectionUrl = response.head.location;
		_x3.connectionId = response.body.id;
		_x3.auth = response.body.auth;
		// disconnect now
		response = _jsonSend(_, _getDisconnectRequest());
		// close stream
		if (_stream) _stream.destroy();
		//
		return [{
			$severity: "info",
			$message: locale.format(module, "serverConnected", this.x3server.serverHost(_) + ":" + this.x3server.serverPort(_))
		}];
	};

	this.connect = function(_, params) {
		var self = this;
		this.init(_);
		_tracer && _tracer.info && _tracer.info("x3client.connect enter");
		var lic = check.getParsedLicense(_);
		if (lic && !lic.namedUsers && lic.sessionControl !== "concurrent") {
			var e = new Error(locale.format(module, "tooManyBadges"));
			e.httpStatus = 403;
			throw e;
		}
		if (_stream) throw new Error("already connected!");
		try {
			_stream = _client.connect(_);
			_stream.setNoDelay(true);
		} catch (e) {
			_tracer && _tracer.info && _tracer.info("Can't connect to server " + this.x3server.description(_));
			// bannish x3server (one hour by default)
			var retry = this.x3server.bannish(_);
			if (!this.exactServer && retry) {
				_tracer && _tracer.info && _tracer.info("Retry to connect with another server...");
				return self.connect(_, params);
			}
			throw new Error(locale.format(module, "connectionRefused", this.x3server.serverHost(_), this.x3server.serverPort(_), e.message));
		}
		try {
			_stream.write(_, new Buffer([0, 7, 3, params.fusion ? 1 : 0]));
			var pidBuf = self.read(_, 4, true);
			if (pidBuf == null) throw new Error("error reading pid: stream closed");
			_x3 = {
				pid: _readInt(pidBuf)
			};
			_tracer && _tracer.info && _tracer.info("connected: pid=" + _x3.pid + ", params=" + JSON.stringify(params));

			var response = _jsonSend(_, _getConnectRequest(_, params));
			if (response.head.statusCode >= 400) {
				throw _getSrvErrorFromResponse(locale.format(module, "connectError"), response);
			}
			if (response.head.statusCode != 201) throw new Error("connect failed: " + JSON.stringify(response));
			_x3.connectionUrl = response.head.location;
			// _x3.wireBaseProtocolVersion = ~~response.body.wireBaseProtocolVersion || 1;
			_x3.wireProtocolVersion = ~~response.body.wireProtocolVersion || 1;
			_x3.connectionId = response.body.id;
			_x3.auth = response.body.auth;
			_x3.processId = response.body.processId;
			if (!_x3.connectionUrl) throw new Error("connectionUrl missing");
			if (!_x3.connectionId) throw new Error("connectionId missing");
		} catch (e) {
			// close stream
			if (_stream) _stream.destroy();
			_stream = null;
			throw e;
		}
		//
		return _x3;
	};

	// This function has only sense if userProfile is set !!!
	function setProductName(_, params, x3licData) {
		if (!params.userProfile) return;
		var validLicense = check.validLicenses();
		for (var i = 0; i < validLicense.length && !params.userProfile.productName(_); i++) {
			if (validLicense[i].productCode === x3licData.product) {
				adminHelper.setProductByEndpoint(validLicense[i].productTitle, params.userProfile.selectedEndpoint(_).dataset(_), x3licData.product, x3licData.version);
			}
		}
	}

	this.createSession = function(_, params) {
		_tracer && _tracer.info && _tracer.info("x3client.createSession enter");
		if (!_x3) throw new Error("cannot create session: not connected");
		if (_x3.sessionUrl) throw new Error("cannot create session: previous session not closed");
		//
		_baseUrl = params.baseUrl;
		_endpointDataset = params.endpointDataset;
		//
		params.userName = (params.userName || "sage").toLowerCase();
		//
		this.context = this.context || {};
		this.context.userName = params.userName;
		//console.log(params.locale);
		var sendParams = {
			head: {
				method: "POST",
				url: "/$sessions",
				"content-type": "application/json",
				"accept": "application/json;vnd.sage=syracuse",
				"accept-language": params.locale || "en-US"
			},
			body: {
				connectionId: _x3.connectionId,
				sessionType: params.sessionType || "primary",
				adxtyp: params.adxtyp || 33, // 33 means primary, 34 is secondary
				wireProtocolVersion: _protocolVersions.WIRE,
				baseUrl: params.baseUrl,
				collaborationBaseUrl: params.collaborationBaseUrl,
				peerAddress: params.peerAddress
			}
		};
		if (params.sysAuthToken) {
			sendParams.body.sysAuthToken = params.sysAuthToken;
		}
		if (_x3.auth && (_x3.auth.method === "X3RSA")) {
			sendParams.head.authorization = "x3-challenge";
			//
			//			console.log("nodeconf: "+require("util").inspect(nodeConfig));
			var pubkeyName = nodeConfig.sdata.pubkeyName;
			if (poolConfig.certificate) {
				pubkeyName = poolConfig.certificate.name(_).replace(/[\@\$\.]/g, "_");
			} else if (nodeConfig.x3key) { // use internal certificate of this server
				pubkeyName = require('os').hostname().toLowerCase().replace(/[\@\$\.]/g, "_");
			}
			_tracer && _tracer.info && _tracer.info("pubkeyname " + pubkeyName);
			var auth = sendParams.body.auth = {
				method: "X3RSA",
				pubkey: pubkeyName,
				user: params.userName || "sage"
			};
			auth.signature = x3helpers.getSignature(_, _x3.auth.challenge, auth.user, poolConfig.certificate);
		} else sendParams.head.authorization = params.authToken || "auth-token";
		if (params.localePreferences) sendParams.body.preferences = x3helpers.getX3Preferences(_, params.localePreferences);

		sendParams.body.fusionTech = params.fusionTech;

		// manage application connection parameters
		if (params.applicationConnectionData) {
			//console.log("SEND: " + JSON.stringify(params.applicationConnectionData));
			sendParams.body.applicationConnectionData = params.applicationConnectionData;
		}
		//console.log("SENDPARAMS "+require('util').format(sendParams))
		//
		try {
			var response = _jsonSend(_, sendParams);
			if (response.head.statusCode >= 400) {
				throw _getSrvErrorFromResponse(locale.format(module, "createSessError"), response, params);
			}
			if (response.head.statusCode != 201) throw new Error("create session failed: " + JSON.stringify(response));
			_x3.sessionUrl = response.head.location;
			_x3.sessionId = response.body.id; // ?
			if (!_x3.sessionUrl) throw new Error("sessionUrl missing");
			if (!_x3.sessionId) throw new Error("sessionId missing");
			//
			// _x3.wireBaseProtocolVersion = ~~response.body.wireBaseProtocolVersion || _x3.wireBaseProtocolVersion;
			_x3.wireProtocolVersion = ~~response.body.wireProtocolVersion || _x3.wireProtocolVersion;
			_x3.acceptLocale = params.locale || "en-US";
			_x3.contentLocale = response.head["content-language"];
			_x3.$links = response.body.$links;
			// license information (store it in memory to be able to reuse it)
			var x3licData = this.licenseData = response.body.license;
			if (x3licData && x3licData.product && !params.noCheckLicense) {
				var lk = x3licData.$links && x3licData.$links.$license;
				if (lk) {
					// if userProfile is set :
					if (params.userProfile) {
						// update the productName in user profile for the client
						setProductName(_, params, x3licData);
					}
					var diags = [];
					var license = params.license || check.getX3LicenseInfo(_, x3licData.product, x3licData.version, globals.context.session, diags);
					if (!license) {
						this.disconnect(_);
						var err = new Error(locale.format(module, "licenseError", x3licData.product, x3licData.version));
						console.error(new Date().toISOString(), "License error for " + x3licData.product + " " + x3licData.version + ": " + util.format(diags));
						err.$diagnoses = diags;
						err.$httpStatus = 403;
						throw err;
					}

					if (!params.license) _x3.license = license;

					var licParams = {
						head: {
							method: lk.$method,
							url: lk.$url,
							"accept": "application/json;vnd.sage=syracuse",
							"content-type": "application/json",
							"accept-language": params.locale || "en-US"
						},
						body: license
					};
					response = _jsonSend(_, licParams);
					if (response.head.statusCode >= 400) {
						throw _getSrvErrorFromResponse(locale.format(module, "licenseError", x3licData.product, x3licData.version), response);
					}
				}
			} else {
				_x3.noLicense = true; // no license check on this endpoint
			}
			//
			return _x3;
		} catch (e) {
			// close stream
			if (_stream) _stream.destroy();
			_stream = null;
			throw e;
		}
	};

	this.updateSession = function(_, body) {
		_tracer && _tracer.info && _tracer.info("x3client.updateSession enter");

		if (_x3.wireProtocolVersion < 2)
			return false;

		var sendParams = {
				head: {
					method: "PUT",
					url: _x3.sessionUrl,
					"content-type": "application/json",
					"accept": "application/json;vnd.sage=syracuse",
					"accept-language": locale.current || "en-US"
				},
				body: body
			},
			response;

		try {
			response = _jsonSend(_, sendParams);
		} catch (e) {
			if (e.code == 'ECONNRESET') return; // ignore connection reset. Comparison with '==' because value comes from native function
			throw e;
		}
		_tracer && _tracer.info && _tracer.info("x3client.updateSession statusCode=" + response.head.statusCode + ", hasBody=" + !!response.body);

		if (response.head.statusCode >= 400) {
			throw _getSrvErrorFromResponse(locale.format(module, "updateSessError"), response);
		}
		// if the supervisor does not support update of session it might return 200 by default but without body
		if (response.head.statusCode == 200) return !!response.body;
		if (response.head.statusCode != 204) throw new Error("update session failed: " + JSON.stringify(response));
		return false;
	};

	this.getSessionServiceLink = function(_, name) {
		return _x3 && _x3.$links && _x3.$links[name];
	};
	//  #3978 - funnel!=null -> Force to use a new funnel 
	this.disconnect = function(_, funnel) {
		if (_stream == null) { // not necessary to disconnect twice (this may happen in an asynchronous call from the pool when X3 server sends a response with status 500)
			_tracer && _tracer.info && _tracer.info("'disconnect' called when stream has been deleted");
			return;
		}
		try {
			// disconnect session
			var sendParams = {
					head: {
						method: "DELETE",
						url: "/$sessions('" + _x3.sessionId + "')"
					},
					body: null
				},
				response;
			try {
				response = _jsonSend(_, sendParams, funnel);
			} catch (e) {
				if (e.code == 'ECONNRESET') return; // ignore connection reset. Comparison with '==' because value comes from native function
				throw e;
			}
			if (response.head.statusCode >= 400) {
				throw _getSrvErrorFromResponse(locale.format(module, "closeSessError"), response);
			}
			if (response.head.statusCode != 204) throw new Error("disconnect session failed: " + JSON.stringify(response));

			// disconnect connection
			try {
				response = _jsonSend(_, _getDisconnectRequest(), funnel);
			} catch (e) {
				if (e.code == 'ECONNRESET') return; // ignore connection reset. Comparison with '==' because value comes from native function
				throw e;
			}
			// TODO restore error management code, for now there is an error as X3 doesn't implement this order
			if (response.head.statusCode >= 400) {
				throw _getSrvErrorFromResponse(locale.format(module, "disconnectError"), response);
			}
			if (response.head.statusCode != 204) throw new Error("disconnect connection failed: " + JSON.stringify(response));
		} finally {
			// close stream
			if (_stream) _stream.destroy();
			_stream = null;
		}
	};

	function _clone(obj) {
		var result = {};
		for (var i in obj) result[i] = obj[i];
		return result;
	}

	// make it easier for X3, normalize single quotes

	function _fixUrl(str) {
		return str.replace(/%27/g, "'");
	}
	this.sendRequest = function(_, request, response) {
		var self = this;
		return _funnel(_, function(_) {
			if (!_x3) throw new Error("cannot send request: not connected");
			if (!_x3.sessionUrl) throw new Error("cannot send request: no session");
			var head = _clone(request.headers || {});
			head.method = request.method.toUpperCase(); // force to use method in upper case , lower case is not understandable by x3
			if (nodeConfig.x3Pool && nodeConfig.x3Pool.debugMode) {
				head["pragma"] = "debug-" + nodeConfig.x3Pool.debugMode; // "debug-immediate" for immediate stop or "debug-on" for stopping on breakpoints
			}
			_tracer && _tracer.info && _tracer.info("X3 client requested url=" + request.url + "\n\theader=" + JSON.stringify(head));
			head.url = _fixUrl(request.url);
			if (!head["accept-language"]) head["accept-language"] = locale.current;
			return _send(_, head, request, response, self.licenseData);
		});
	};
	this.jsonSend = function(_, params) {
		params.head.url = _fixUrl(params.head.url);
		return _jsonSend(_, params);
	};
	//

	function BulkReader(readerBaseUrl) {
		//
		var bulk = this;
		var _parts = [];
		var _done = false;
		var _frame = null;
		var diagnoses = [];
		//
		bulk.open = function(_, params) {
			// alloc this client for long read
			_busy = true;
			//
			diagnoses = [];
			_tracer && _tracer.info && _tracer.info("opening bulk reader");
			// make request
			var x3head = {
				headers: {
					"accept": "application/json;vnd.sage=syracuse",
					"accept-language": locale.current || "en-US"
				},
				method: "GET",
				url: params.url
			};
			//
			_tracer && _tracer.info && _tracer.info("bulk reader header params: " + sys.inspect(x3head, null, 4));
			_stream.write(_, _outBuffer(1, x3head));
			_stream.write(_, _outBuffer(3, ""));
			// receive
			var frame = _readFrame(_, "utf8");
			_tracer && _tracer.info && _tracer.info("received header frame: " + frame.data);
			_checkCode(frame.code, 1);
			var head = JSON.parse(frame.data);
			head.statusCode = head.status; // compat stuff -- fix protocol
			bulk.header = head;
			if (head.status === 500) {
				// TODO: better error management ?
				_frame = JSON.parse(_readFrame(_, "utf8").data);
				_tracer && _tracer.info && _tracer.info("bulkReader.open received error; frame " + JSON.stringify(_frame));
				if (_frame.$diagnoses && _frame.$diagnoses.length) throw _getError(_frame.$diagnoses[0]);
				else throw new Error(head.message);
			} else
			// future
				_frame = _readFrame(!_, "utf8");
			//
			return bulk;
		};
		bulk.next = function(_) {
			_tracer && _tracer.info && _tracer.info("bulkReader.next enter");
			while (!_parts.length) {
				if (_done) return null;
				//
				var f = _frame(_);
				_tracer && _tracer.info && _tracer.info("bulkReader.next received body frame " + f.code + ": " + f.data);
				if (f.code === 3) {
					_done = true;
					_busy = false;
				} else
				// next future
					_frame = _readFrame(!_, "utf8");
				//
				var res = f.data.replace(/\}\]\}$/, "}").split("\n");
				res.forEach(function(r) {
					// TODO: better extraction of start/end
					if (["{\"$resources\":[", "[", "]", "]}"].indexOf(r) >= 0) return;
					// Handle last record (because there is no \n after the object itself 
					r = r.replace(/,$/, "");
					_tracer && _tracer.info && _tracer.info("bulkReader.next resource :" + r);
					// TODO: how to interpret this ? should be an error ...
					if (!r) return;
					//
					try {
						var part = JSON.parse(r.replace(/,$/, ""));
						_parts.push(part);
					} catch (e) {
						diagnoses.push({
							$severity: "error",
							$message: e.message,
							$stackTrace: e.safeStack
						});
					}
				});
			}
			//
			return _parts.shift();
		};
	}
	//

	function QueryReader(readerBaseUrl) {
		//
		var bulk = this;
		var _parts = [];
		var _done = false;
		var _next = null;
		var diagnoses = [];
		//
		bulk.open = function(_, params) {
			// alloc this client for long read
			_busy = true;
			//
			diagnoses = [];
			_tracer && _tracer.info && _tracer.info("opening query reader; url=" + params.url);
			// make request
			_next = _jsonSend(!_, {
				head: {
					"accept": "application/json;vnd.sage=syracuse",
					"accept-language": locale.current || "en-US",
					method: "GET",
					url: params.url
				},
				body: null
			});
			//
			return bulk;
		};
		bulk.next = function(_) {
			_tracer && _tracer.info && _tracer.info("queryReader.next enter");
			while (!_parts.length) {
				if (_done) return null;
				//
				var r = _next(_);
				if (r.head.statusCode >= 400) {
					_tracer && _tracer.info && _tracer.info("queryReader.next received error" + JSON.stringify(r.body));
					if (r.body.$diagnoses && r.body.$diagnoses.length) {
						throw _getError(r.body.$diagnoses[0]);
					} else throw new Error(r.head.message);
				}
				_parts = r.body.$resources;
				var url = r.body.$links && r.body.$links.$next && r.body.$links.$next.$url;
				if (!_parts.length || !url) {
					_done = true;
					_busy = false;
				} else {
					// future
					url = url.replace("{$baseUrl}", readerBaseUrl || _baseUrl);
					// remove server name
					url = url.replace(/^https?\:\/\/[^\/]+/, "");
					_tracer && _tracer.info && _tracer.info("queryReader.next future; url=" + url);
					_next = _jsonSend(!_, {
						head: {
							"accept": "application/json;vnd.sage=syracuse",
							"accept-language": locale.current || "en-US",
							method: "GET",
							url: url
						},
						body: null
					});
				}
			}
			//
			return _parts.shift();
		};
	}

	this.createBulkReader = function(_, params) {
		try {
			var reader = (params.facet && params.facet === "$query") ? new QueryReader(params.baseUrl) : new BulkReader(params.baseUrl);
			return reader.open(_, params);
		} catch (e) {
			//			this.disconnect(_);
			throw e;
		}
	};

	this.getStream = function() {
		return _stream;
	};
}

exports.create = function(poolConfig) {
	return new X3Client(poolConfig);
};