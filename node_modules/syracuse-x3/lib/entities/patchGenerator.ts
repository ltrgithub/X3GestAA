"use strict";

import * as config from 'config';
import * as globals from 'streamline/lib/globals';
import * as zip from 'streamline-zip';
import * as fez from 'f-streams';
import * as ez from 'ez-streams';
import * as syracuseCore from '@sage/syracuse-core';

const tracer = syracuseCore.getTracer('patch');
exports.$exported = true;

function trackMessage(context, severity, message) {
	switch (severity) {
		case "error":
			tracer.error && tracer.error(message);
			break;
		case "info":
			tracer.info && tracer.info(message);
			break;
		default:
			tracer.debug && tracer.debug(message);
			break;
	}

	var t = context && context.tracker;
	if (t) {
		//t.phaseDetail = t.phaseDetail;
		t.$diagnoses = t.$diagnoses || [];
		t.$diagnoses.push({
			$severity: severity,
			$message: message
		});
	}
}

exports.entity = {
	$isPersistent: true,
	$canSave: true,
	$titleTemplate: "Patch Generator",
	$descriptionTemplate: "Patch Generator",
	$valueTemplate: "{name}",
	$properties: {
		scmServer: {
			$title: "SCM Server",
			$default: function(_) {
				return (config.scmServer && config.scmServer.url)||"";
			}
		},	
		fromSha: {
			$title: "from SHA",
			$default: function(_) {
				return "3ce92eb2cad6a3754222df22f037be152f8c4d24";
			}

		},	
		toSha: {
			$title: "from SHA",
			$default: function(_) {
				return "bba71e8928dcd29ffa265c59dad076b4b1585dfd";
			}
		},	
		patch: {
			$title: "Patch",
			$type: "binary",
			$storage: "db_file",
		}
	},
	$functions: {
		generate:function(_,context:any, scmServer:string,fromSha:string,toSha:string) {

			try {
				// request SCM to produce a patch 
				let url = scmServer +"/continuousDelivery/fromLinux/generateDeltaPatch?fromSha="+fromSha+"&toSha="+toSha;
				trackMessage(context, "info","call SCM");
				const response =  fez.devices.http.client({
						url:url,
						method: "GET",
						headers: {}
					}).end().response();
				let body = response.readAll();
				if (response.statusCode >= 500)  throw new Error(body)

				let patchName:string;
				let scmFiles:any = {};

				// Unzip the patch generated by SCM
				(new zip.Unzip(body,
					function(filename:string, filecontent, headers, _) {
						if(!patchName && filename.indexOf('/'))  patchName = filename.substring(0, filename.indexOf('/'));
						trackMessage(context, "info","unzip "+filename);
						scmFiles[filename] = filecontent.toString('utf8');
					})).unzip(_);


				// - Use the script dictionnary to know if a script can be delivered or not 
				// If the script is to be delivered => type =TRT
				// If the script is not to be delivered => type =ADX

				let catalog = JSON.parse(scmFiles['catalog.json']); 
				let update  = JSON.parse(scmFiles[patchName+'/update.json']);
				let product = update.patches[0].type;
				let endpoint;
				var up = globals.context.session && globals.context.session.getUserProfile(_);
				up && (endpoint = up.selectedEndpoint(_));


				catalog.files = catalog.files.slice().filter_(_, function(_,file) {
					let keep = true;
					let patchFilename = patchName +'/'+file.patchFilename;
					if(scmFiles[patchFilename]) {
						// Read the maintenance
						const lines = scmFiles[patchFilename].split('\n');
						// First get the type and id of the patch:
						lines.some( line => {
							if(/^2/.test(line)) {
								const ids   = line.split(',').map(s => s.replace(/"/g,''));
								file.type = ids[1];
								file.id   = ids[2];
								keep = !(file.type === "TRT" && /^[WXYZ]/.test(file.id));
							}
							if(/^4,"MODULE",\d*,\d*$/.test(line)) {
								const module = line.split(',')[3];
								keep = !(    (product === "SU" && module === 2)
								          || (product === "X3" && module === 11));
							}
							return !keep; // break if the entity should not be kept
						});

						if(keep && file.type === "TRT" && endpoint) {
							let keepLine=false;
							let response = endpoint.postService(_, "deliverScript", {
								name:file.id.toUpperCase()
							},{
								source:lines.filter( line => {
									if(!keepLine && /^2/.test(line)) {
										keepLine=true;
										return false;
									}
									else if(keepLine && /^[\*]{10}/.test(line)) {
										keepLine=false;
										return false;
									}
									return keepLine;
								}).join('\n')
							});
							if(response.head.status === 200) {
								// console.log(response.body);
								file.type = response.body.type;
								if(file.type === "ADX") {
									var adx = new Buffer(response.body.source, 'base64');
									// console.log(adx.toString('utf8'));
								}
							}
						}
					}
					!keep && delete scmFiles[patchFilename];// Remove it from the patch
					return keep;
				});
				// Update the catalog:
				scmFiles['catalog.json'] = JSON.stringify(catalog);

				// Add indexes
				let patchIndex = catalog.files.map( file => [file.type,file.id].join(';'));
				
				// Split the index in lists of 25 items:
				let index;
				let count=0;
				while((index = patchIndex.splice(0,25)) && index.length) {
					scmFiles['index_'+("00"+(++count)).slice (-2)+'.lst'] = index.join('\n');
				}

				// Zip the new patch:
				console.log("zip files");
				let wbs = ez.devices.buffer.writer();
				let zp = new zip.Zip(wbs);
				Object.keys(scmFiles).forEach_(_, (_, file) => {
					zp.add(_, {
						name: file,
						data: new Buffer(scmFiles[file], "utf8")
					});
				});
				zp.finish(_);

				const writer = this.patch(_).createWritableStream(_, {
					contentType: "application/x-zip-compressed",
					fileName: patchName+".zip",
				});
				writer.write(_, wbs.toBuffer(), "binary");
				writer.write(_, null);
				this.save(_);
			} catch(e) {
				trackMessage(context, "error", e.message);
			}
		}
	},
	$services: {
		generate: {
			$method: "POST",
			$title: "Generate Patch",
			$isMethod: true,
			$invocationMode: "async",
			$capabilities: "abort",
			$facets: ["$edit","$details"],
			$execute: function(_, context, instance) {
				return instance.generate(_,context,
							instance.scmServer(_),
							instance.fromSha(_),
							instance.toSha(_));
			}
		},
	}
};