"use strict";

import * as config from 'config';
import * as globals from 'streamline/lib/globals';
import * as zip from 'streamline-zip';
import * as ez from 'ez-streams';
import * as syracuseCore from '@sage/syracuse-core';
import * as adminHelpers from "@sage/syracuse-lib/src/collaboration/helpers";

const tracer = syracuseCore.getTracer('patch');
exports.$exported = true;

function trackMessage(context, severity, message) {
	switch (severity) {
		case "error":
			tracer.error && tracer.error(message);
			break;
		case "info":
			tracer.info && tracer.info(message);
			break;
		default:
			tracer.debug && tracer.debug(message);
			break;
	}

	var t = context && context.tracker;
	if (t) {
		//t.phaseDetail = t.phaseDetail;
		t.$diagnoses = t.$diagnoses || [];
		t.$diagnoses.push({
			$severity: severity,
			$message: message
		});
	}
}

exports.entity = {
	$isPersistent: true,
	$canSave: true,
	$titleTemplate: "Patch Generator",
	$descriptionTemplate: "Patch Generator",
	$valueTemplate: "{name}",
	$properties: {
		scmServer: {
			$title: "SCM Server",
			$default: function(_) {
				return (config.scmServer && config.scmServer.url)||"";
			}
		},	
		fromSha: {
			$title: "from SHA",
			$default: function(_) {
				return "3ce92eb2cad6a3754222df22f037be152f8c4d24";
			}

		},	
		toSha: {
			$title: "to SHA",
			$default: function(_) {
				return "bba71e8928dcd29ffa265c59dad076b4b1585dfd";
			}
		},	
		fromBranch: {
			$title: "from Branch"
		},	
		toBranch: {
			$title: "to Branch"
		},	
		patch: {
			$title: "Patch",
			$type: "binary",
			$storage: "db_file",
		}
	},
	$functions: {
		generate:function(_,context:any, parameters:any) {

			const fileKey = (file) =>  [file.type,file.id].join(';');
			try {
				// request SCM to produce a patch 
				let url = parameters.scmServer +"/continuousDelivery/fromLinux/generateDeltaPatch?"
						+ ["fromBranch","fromSha","toSha","toBranch"].reduce( (r,p) => {
							if(parameters[p]) r.push(p+"="+parameters[p]);
							return r;
						},[]).join('&');
				trackMessage(context, "info","call SCM");
				const response =  ez.devices.http.client({
						url:url,
						method: "GET",
						headers: {}
					}).end().response(_);
				let body = response.readAll(_);
				if (response.statusCode >= 500)  throw new Error(body)

				let patchName:string;
				let scmFiles:any = {};

				// Unzip the patch generated by SCM
				trackMessage(context, "info","unzip SCM Patch");
				(new zip.Unzip(body,
					function(filename:string, filecontent, headers, _) {
						if(!patchName && filename.indexOf('/'))  patchName = filename.substring(0, filename.indexOf('/'));
						scmFiles[filename] = filecontent.toString('utf8');
					})).unzip(_);


				// - Use the script dictionnary to know if a script can be delivered or not 
				// If the script is to be delivered => type =TRT
				// If the script is not to be delivered => type =ADX

				let catalog = JSON.parse(scmFiles['catalog.json']); 
				let update  = JSON.parse(scmFiles[patchName+'/update.json']);
				let product = update.patches[0].type;
				let endpoint;
				var up = globals.context.session && globals.context.session.getUserProfile(_);
				up && (endpoint = up.selectedEndpoint(_));

				let deleted=[];
				let entities = {};
				let ignoreFiles = ((config.scmServer && config.scmServer.ignore) || [])
									.map( s => new RegExp("^"+s.replace(/\*/g,".*")+"$","g"));

				catalog.files = catalog.files.slice().filter_(_, function(_,file) {
					let keep = true;
					let patchFilename = patchName +'/'+file.patchFilename;
					if(scmFiles[patchFilename]) {
						console.log(file);
						if(!file.filename.endsWith('.rpt')) {
							// Read the maintenance
							const lines = scmFiles[patchFilename].split('\n');
							// First get the type and id of the patch:
							lines.some( line => {
								if(/^2,/.test(line)) {
									const ids   = line.split(',').map(s => s.replace(/"/g,''));
									file.type = ids[1];
									file.id   = ids[2];
									const key = fileKey(file);
									console.log(file.status);
									if(file.status === 'deleted') {
										keep = false;
										deleted.push(key);
									} else {
										keep = !ignoreFiles.some( r => r.test(key));
									}

									if(keep) {
										keep = (entities[key] === undefined); // Don't deliver twice the same entity
										entities[key] = key;
									}
									console.log((keep ? "keep":"don't keep")+" "+key);
								}
								if(/^4,"MODULE",\d*,\d*$/.test(line)) {
									const module = line.split(',')[3];
									keep = keep && !(  (product === "SU" && module === 2)
									                || (product === "X3" && module === 11));
								}
								return !keep; // break if the entity should not be kept
							});
						} else {
							file.type = "ETA";
							const match = file.filename.match(/([^\/]+).rpt/);
							file.id = match[1];
						}

						if(keep && file.type === "TRT" && endpoint) {
							let keepLine=false;
							let fromLine:number;
							let toLine:number;
							let response = endpoint.postService(_, "deliverScript", {
								name:file.id.toUpperCase()
							},{
								source:lines.filter( (line,i) => {
									if(!keepLine && /^2/.test(line)) {
										keepLine=true;
										fromLine = i+1;
										return false;
									}
									else if(keepLine && /^[\*]{10}/.test(line)) {
										keepLine=false;
										toLine = i;
										return false;
									}
									return keepLine;
								}).join('\n')
							});
							if(response.head.status === 200) {
								// console.log(response.body);
								file.type = response.body.type;
								/*if(file.type === "ADX") {
									var adx = (new Buffer(response.body.source, 'base64')).toString('utf8');
									lines[fromLine] =  lines[fromLine].replace('"TRT"','"ADX"');
									scmFiles[patchFilename] =  [
										lines.slice(0,fromLine).join('\n'),
										'\n'+adx.length,
										'\n'+adx,
										lines.slice(toLine,lines.length).join('\n')].join('');

								}*/
							}
						}
					}
					!keep && delete scmFiles[patchFilename];// Remove it from the patch
					keep && trackMessage(context, "info","keep "+fileKey(file));
					return keep;
				});
				// Update the catalog:
				scmFiles['catalog.json'] = JSON.stringify(catalog,null,'\t');

				// Split the index in lists of maxItems items:
				let buildIndex = function(files,maxItems,_idx) {
					let idx = _idx || 0;
					let patchIndex = Object.keys(files.map(file => fileKey(file))
							.reduce( (r, key) => { // Remove duplicated elements
								r[key] = true;
								return r;
							},{}));

					let index;
					while((index = patchIndex.splice(0,maxItems)) && index.length) {
						scmFiles['index_'+("0000"+(++idx)).slice (-4)+'.lst'] = index.concat('').join('\n');
					}
					return idx;
				}
				let count = buildIndex(catalog.files.filter( file => file.type !== 'ETA'),25);
				buildIndex(catalog.files.filter( file => file.type === 'ETA'),10,count);
				
				// Add the list of deleted entities:
				scmFiles["deleted.lst"] = deleted.join('\n');

				// Zip the new patch:
				console.log("zip files");
				let wbs = ez.devices.buffer.writer();
				let zp = new zip.Zip(wbs);
				Object.keys(scmFiles).forEach_(_, (_, file) => {
					zp.add(_, {
						name: file,
						data: new Buffer(scmFiles[file], "utf8")
					});
				});
				zp.finish(_);

				const writer = this.patch(_).createWritableStream(_, {
					contentType: "application/x-zip-compressed",
					fileName: patchName+".zip",
				});
				writer.write(_, wbs.toBuffer(), "binary");
				writer.write(_, null);
				this.save(_);
			} catch(e) {
				trackMessage(context, "error", e.message);
			}
		}
	},
	$services: {
		generate: {
			$method: "POST",
			$title: "Generate Patch",
			$isMethod: true,
			$invocationMode: "async",
			$capabilities: "abort",
			$facets: ["$details"],
			$execute: function(_, context, instance) {
				return instance.generate(_,context,{
					scmServer: instance.scmServer(_),
					fromSha: instance.fromSha(_),
					toSha: instance.toSha(_),
					toBranch:instance.toBranch(_)
				});
			}
		},
		remoteCreation: {
			$method: "POST",
			$isVisible: false,
			$title: "Remote Creation",
			$isMethod: false,
			$invocationMode: "async",
			$overridesReply: true,
			$facets: [],
  			$execute: function(_, context, instance, _parameters) {
  				function _error(msg, statusCode) {
					var err = new Error(msg);
					err.$httpStatus = statusCode || 400;
					throw err;
				}

				let parameters = _parameters || {};
				console.log("remoteCreation:",parameters);
				if(!parameters.scmServer) _error("the SCM server isn't defined");
				if(!parameters.fromSha && !parameters.fromBranch) _error("from isn't defined");
				if(!parameters.toSha && !parameters.toBranch) _error("from isn't defined");

				var db =  adminHelpers.AdminHelper.getCollaborationOrm(_);
				var patch = db.getEntity(_, "patchGenerator").createInstance(_, db);
				patch.scmServer(_,parameters.scmServer);
				parameters.fromBranch && patch.fromBranch(_,parameters.fromBranch);
				parameters.fromSha && patch.fromSha(_,parameters.fromSha);
				parameters.toSha && patch.toSha(_,parameters.toSha);
				parameters.toBranch && patch.toSha(_,parameters.toBranch);
				patch.$persist(_);
				patch.generate(_,context,parameters);

				// return patch.patch(_);	
				context.replyProperty(_, patch, "patch");
  			}
		},
	}
};