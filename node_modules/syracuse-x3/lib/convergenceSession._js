"use strict";

var locale = require("syracuse-core/lib/locale");
var helpers = require("syracuse-core/lib/helpers");
var streams = require("streamline/lib/streams/streams");
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var x3helpers = require("./helpers");
var dispatcher = require('./proxyFusionDispatcher');
var parseUrl = require('url').parse;
var x3helpers = require("./helpers");
var globals = require('streamline/lib/globals');
var sys = require("util");
var httpHelpers = require("syracuse-sdata/lib/httpHelper");
var check = require("syracuse-license/lib/check");
var x3client = require('syracuse-x3/lib/client');
var CvgClient = require("syracuse-x3/lib/convergence/client/CvgClient").CvgClient;
var CvgException = require("syracuse-x3/lib/convergence/model/CvgException").CvgException;

var printSrvConfig = nodeconfig.config && nodeconfig.config.x3print && nodeconfig.config.x3print.server;
var traceSessions = nodeconfig.config && nodeconfig.config.x3fusion && nodeconfig.config.x3fusion.sessions && nodeconfig.config.x3fusion.sessions.trace;

var listReuse = [];

function _startProfile() {
	return (new Date()).getTime();
}

function _endProfile(startTime) {
	return (new Date()).getTime() - startTime;
}

function FusionSession(fsid) {
	this.sessionUrl = "";
	this.isXmlSessionFormat = false;
	this.sid = fsid;
}

function _getRsrc() {
	try {
		var args = [module];
		for (var i in arguments) {
			args.push(arguments[i]);
		}
		return locale.format.apply(locale, args);
	} catch (e) {
		return "Resource not found [" + arguments[0] + "]";
	}
}

function getErrDiagnose(e, client, resourceId) {
	console.error("Error: "+e.stack);
	var error, msg = resourceId ? _getRsrc(resourceId) : e.message;
	if (e instanceof CvgException) {
		error = e;
		error.diagnose.message = msg;
	} else {
		error = new CvgException(client, e, msg);
	}
	
	return error.diagnose;
}

function sendResponse(_, context, statusCode, data) {
	context.response.writeHead(statusCode, {
		"content-type": "application/json",
	});
	context.response.write(_, JSON.stringify(data), 'utf8');
	context.response.end();	
}

var activeClientList = {}


var sessionProto = FusionSession.prototype;
//

sessionProto.connect = function(_, context, config) {
	traceSessions && traceSessions("Direct Fusion Connect");
	var lic = check.getParsedLicense(_);
	if (lic && !lic.namedUsers)
		throw locale.format(module, "tooManyBadges");
	
	var x3server = context.endpoint.x3server(_);
	var userProfile = context.httpSession.getUserProfile(_);
	var localePrefs = userProfile && userProfile.selectedLocale(_);
	var endpoint = context.endpoint;
	
	var host = x3server.serverHost(_);
	var port = x3server.serverPort(_);
	var solution = endpoint.x3SolutionName(_);
	var adxFolder = endpoint.x3ServerFolder(_);
	var server = x3server.serverName(_);
	var adxHttpPub = endpoint.getApplicationServerBaseUrl(_);
	var username = userProfile && userProfile.user(_) && userProfile.user(_).getEndpointLogin(_, endpoint.$uuid);

	var preferences;
	var selLocale = userProfile && userProfile.selectedLocale(_);
	if (selLocale) {
		// FDB - Session Settings required by X3 client - dateOrder (dym-myd-ymd-dm if no year...)/dateSep/decSep/thousandSep
		preferences = x3helpers.dateFormatToX3Prefs(selLocale.shortDate(_));
		var decimalSep = selLocale.numberDecimalSeparator(_);
		var thousandsSep = selLocale.numberGroupSeparator(_);
		var timeSep = x3helpers.getTimeSep(selLocale.shortTime(_));
		if (decimalSep != null) preferences.decimalSep = decimalSep;
		if (thousandsSep != null) preferences.thousandsSep = thousandsSep;
		if (timeSep != null) preferences.timeSep = timeSep;
	}

	var config = {
		user: username,
		adxHttpPub: adxHttpPub,
		server: host,
		port: port,
		syraPreferences: preferences,
		codeLangIso: locale.current,
		printSrv: printSrvConfig,
	}

	var reuseClient = null;
	traceSessions && traceSessions("Create session [Nb reuse: "+listReuse.length+"]");
	if (listReuse && listReuse.length !== 0) {
		traceSessions && traceSessions("Search reuse...");
		var reuseContext = config;
		var i=0;
		for(i=0; i < listReuse.length && reuseClient == null ;i++){
			reuseClient = listReuse[i].isSameContext(reuseContext) ? reuseClient = listReuse[i] : reuseClient = null;
		}
		// remove client from reuse list
		if(reuseClient){
			traceSessions && traceSessions("Reuse found !");
			reuseClient.setInReuseMode(_,false);
			listReuse.splice(i-1,1);
		}
	}
	var data = {}, statusCode = 200, response =null;
	try {
		if (!reuseClient){
			traceSessions && traceSessions("Create new client.");
			
			var client = x3client.create({
				port: port,
				address: host,
				tracer : traceSessions,
			});
			var cid = client.connect(_, {
				server: server,
				folder: adxFolder,
				fusion: true,
				locale: locale.current,
			});
			traceSessions && traceSessions("Connected...");
			traceSessions && traceSessions("Create session [username: "+username+"]");
			var sid = client.createSession(_, {
				locale: locale.current,
				userName: username,
				adxtyp: 25,
				fusionTech: {
					protocol: "150067",
					wkf: context.parameters.f
				},
	
	
			});
			traceSessions && traceSessions("Session ID: " + this.sid);
			this._fusionClient = new CvgClient(_, client.getStream(), {
				adxHttpPub: adxHttpPub,
				adxFolder: adxFolder,
			}, config);
			this._fusionClient.sessionConv = this;
			response = this._fusionClient.start(_);
		}else{
			this._fusionClient = reuseClient;
			traceSessions && traceSessions("Retrieve existing client.");
			this._fusionClient.isReuse=false;
			response = this._fusionClient.execOpenFunction(_,context.parameters.f);
		}
		this._fusionClient._spy && this._fusionClient._spy.dumpJSON(_, "RESPONSE", response);
	
		return {
			sid: this.sid,
			headers: {
				"content-type": "application/json",
			},
			body: response,
		};
	} catch(e){
		statusCode = 500;
		data = getErrDiagnose(e, this._fusionClient, "connectionFailed");	
		sendResponse(_, context, statusCode, data);
	}
	
	

}

sessionProto.destroyReuseClient = function(_,cvgClient){
	var found = null;
	for(var i=0;i<listReuse.length && found;i++){
		listReuse[i].sid === cvgClient.sid ? found = listReuse[i] : found = null;
	}	
	listReuse.splice(i-1,1);
	cvgClient.deconnectClient(_,"timeout reuse");
}

sessionProto.processRequest = function(_, context) {
	var data = {}, statusCode = 200;
	try{
		if (context.method !== 'put') throw new Error("bad method: " + context.method);
		var act = context.parameters.act;
		var post = JSON.parse(context.request.readAll(_));
		if (parseInt(post.act, 10) !== parseInt(context.parameters.act, 10)) throw new Error("act mismatch: expected " + context.parameters.act + ", got " + post.act);
		this._spy && this._spy.dumpJSON(_, "REQUEST", post);
		data = this._fusionClient.processRequest(_, post);
		//console.log("RESPONSE: " + JSON.stringify(response, null, 2));
		this._spy && this._spy.dumpJSON(_, "RESPONSE", data);

	}catch(e){
		statusCode = 500;
		data = getErrDiagnose(e, this._fusionClient);	
	}
	sendResponse(_, context, statusCode, data);

}


sessionProto.proxy = function(_, context, config) {
	try {
		var svc = context.segments[context.segments.length - 1];
		switch (svc) {
			case 'requestSvc':
				return this.processRequest(_, context);
			case 'formatSvc':
				return this._fusionClient.services.formatSvc.processRequest(_, context);
			case 'blobSvc':
				return this._fusionClient.services.blobSvc.processRequest(_, context);
			default:
				throw new Error("invalid fusion service: " + svc);
		}
	} catch(e) {
		statusCode = 500;
		data = getErrDiagnose(e, this._fusionClient, "proxyFailed");
		sendResponse(_, context, statusCode, data);
	}
	
}


sessionProto.close = function(_, reuse) {
	traceSessions && traceSessions("Close session [reuse:"+(reuse === true)+"] : "+this.sid);
	function _addReuse(url) {
		if (!reuse) return url;
		if (url.indexOf("?") >= 0) return url + "&reuse=" + reuse;
		else return url + "?reuse=" + reuse;
	}
	try {
		if (reuse){
			// store CvgClient in reuse list
			this._fusionClient.setInReuseMode(_,true);
			listReuse.push(this._fusionClient);
			traceSessions && traceSessions("Add reuse session [size: "+listReuse.length+"]");
		}else{
			if (this._fusionClient.stream) {
				this._fusionClient.deconnectClient(_,"logout");
			}
		}
	} catch (ex) {
		data = getErrDiagnose(e, this._fusionClient, "closeFailed");
	}
}

exports.getFusionSession = function(_, fsid) {
	return new FusionSession(fsid);
}

// global function called from sessions cleanup
exports.closeSession = function(_, fsid, sessionUrl) {
	var options = {
		url: sessionUrl,
		method: "DELETE"
	}
	var request = streams.httpRequest(options);
	var resp = request.end();
	//	var respStr = request.end().response(_).readAll(_).toString("utf8");
	// TODO: decode response ?
}

exports.install = function() {
	var bridge = require('./fusionSession');
	Object.keys(bridge).forEach(function(key) {
		bridge[key] = exports[key];
	})
}
