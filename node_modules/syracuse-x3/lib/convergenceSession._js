"use strict";

var locale = require("syracuse-core/lib/locale");
var helpers = require("syracuse-core/lib/helpers");
var streams = require("streamline/lib/streams/streams");
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var x3helpers = require("./helpers");
var dispatcher = require('./proxyFusionDispatcher');
var parseUrl = require('url').parse;
var x3helpers = require("./helpers");
var globals = require('streamline/lib/globals');
var sys = require("util");
var httpHelpers = require("syracuse-sdata/lib/httpHelper");
var check = require("syracuse-license/lib/check");
var x3client = require('syracuse-x3/lib/client');

var listReuse = [];
var CvgClient = require("syracuse-x3/lib/convergence/client/CvgClient").CvgClient;
var CvgException = require("syracuse-x3/lib/convergence/model/CvgException").CvgException;
var CvgFormatException = require("syracuse-x3/lib/convergence/model/CvgException").CvgFormatException;
var traceSessions = nodeconfig.config && nodeconfig.config.x3fusion && nodeconfig.config.x3fusion.sessions && nodeconfig.config.x3fusion.sessions.trace;


var tracer = null;

function _startProfile() {
	return (new Date()).getTime();
}

function _endProfile(startTime) {
	return (new Date()).getTime() - startTime;
}

function FusionSession(fsid) {
	this.sessionUrl = "";
	this.isXmlSessionFormat = false;
	this.sid = fsid;
}


function _getRsrc() {
	try {
		var args = [module];
		for (var i in arguments) {
			args.push(arguments[i]);
		}
		return locale.format.apply(locale, args);
	} catch (e) {
		return "Resource not found [" + arguments[0] + "]";
	}
}

function _getErrMsg(_, ex, rsrcId, ep) {
	var msg = rsrcId ? _getRsrc(rsrcId) : null;
	if (msg == undefined) msg = "";
	if (ex.message && ex.message.search(/ECONNREFUSED/i) >= 0) {
		msg += "\n" + _getRsrc("bridgeNotAvail");
	}
	if (ep) {
		var baseUrl = ep.getFusionDataServerBaseUrl(_);
		baseUrl = baseUrl ? parseUrl(baseUrl) : "";
		// BRJOU DISABLE: msg += "\n--------------\n" + _getRsrc("endpointInfo", baseUrl.host, ep.getApplicationServerName(_), ep.getSolutionName(_), ep.getX3FolderName(_));
	}
	return msg;
}

function _fusionErr(_, ex, rsrcId, context) {
	throw new x3helpers.Error(_getErrMsg(_, ex, rsrcId, context), ex, ex.statusCode);
}

var activeClientList = {}


var sessionProto = FusionSession.prototype;
//

sessionProto.connect = function(_, context, config) {
	traceSessions && traceSessions("Direct Fusion Connect");
	var lic = check.getParsedLicense(_);
	if (lic && !lic.namedUsers)
		throw locale.format(module, "tooManyBadges");
	
	var x3server = context.endpoint.x3server(_);
	var userProfile = context.httpSession.getUserProfile(_);
	var localePrefs = userProfile && userProfile.selectedLocale(_);
	var endpoint = context.endpoint;
	var host = x3server.serverHost(_);
	var port = x3server.serverPort(_);
	var solution = endpoint.x3SolutionName(_);
	var adxFolder = endpoint.x3ServerFolder(_);
	var server = x3server.serverName(_);
	var adxHttpPub = endpoint.getApplicationServerBaseUrl(_);
	var preferences;
	var selLocale = userProfile && userProfile.selectedLocale(_);
	if (selLocale) {
		// FDB - Session Settings required by X3 client - dateOrder (dym-myd-ymd-dm if no year...)/dateSep/decSep/thousandSep
		preferences = x3helpers.dateFormatToX3Prefs(selLocale.shortDate(_));
		preferences.decimalSep = selLocale.numberDecimalSeparator(_);
		preferences.thousandsSep = selLocale.numberGroupSeparator(_);
		preferences.timeSep = x3helpers.getTimeSep(selLocale.shortTime(_));
	}
	var username = userProfile && userProfile.user(_) && userProfile.user(_).getEndpointLogin(_, endpoint.$uuid);
	
	
	var config = {
		user: username,
		adxHttpPub: adxHttpPub,
		server: host,
		port: port,
		syraPreferences: preferences,
		codeLangIso: locale.current,
	}

	var reuseClient = null;
	traceSessions && traceSessions("exec create session  reuse size "+listReuse.length);
	if (listReuse && listReuse.length !== 0) {
		traceSessions && traceSessions("parcours reuse");
		var reuseContext = config;
		var i=0;
		for(i=0; i < listReuse.length && reuseClient == null ;i++){
			reuseClient = listReuse[i].isSameContext(reuseContext) ? reuseClient = listReuse[i] : reuseClient = null;
		}
		// remove client from reuse list
		if(reuseClient){
			traceSessions && traceSessions("find reuse");
			reuseClient.setInReuseMode(_,false);
			listReuse.splice(i-1,1);
		}
	}
	var response =null;
	//try {
	if (!reuseClient){
		traceSessions && traceSessions("Create new client.");
		
		var client = x3client.create({
			port: port,
			address: host,
			tracer : traceSessions,
		});
		var cid = client.connect(_, {
			server: server,
			folder: adxFolder,
			fusion: true,
			locale: locale.current,
		});
		traceSessions && traceSessions("CONNECTED: " + cid);
		traceSessions && traceSessions("create session username = "+username);
		var sid = client.createSession(_, {
			locale: locale.current,
			userName: username,
			adxtyp: 25,
			fusionTech: {
				protocol: "150067",
				wkf: context.parameters.f
			},


		});
		traceSessions && traceSessions("SESSION OK: " + this.sid);


	
		this._fusionClient = new CvgClient(_, client.getStream(), {
			adxHttpPub: adxHttpPub,
			adxFolder: adxFolder,
		}, config);
		this._fusionClient.sessionConv = this;
		response = this._fusionClient.start(_);
	}else{
		this._fusionClient = reuseClient;
		traceSessions && traceSessions("Retrieve existing client.");
		this._fusionClient.isReuse=false;
		response = this._fusionClient.execOpenFunction(_,context.parameters.f);
	}
	this._fusionClient._spy && this._fusionClient._spy.dumpJSON(_, "RESPONSE", response);

	return {
		headers: {
			"content-type": "application/json",
		},
		body: response,
	};
	//} catch (ex) {
	//	throw _fusionErr(_, ex, "connectionFailed", context);
	//}
}

sessionProto.destroyReuseClient = function(_,cvgClient){
	var found = null;
	for(var i=0;i<listReuse.length && found;i++){
		listReuse[i].sid === cvgClient.sid ? found = listReuse[i] : found = null;
	}	
	listReuse.splice(i-1,1);
	cvgClient.deconnectClient(_,"timeout reuse");
}

sessionProto.processRequest = function(_, context) {
	var data = {}, statusCode = 200;
	try{
		if (context.method !== 'put') throw new Error("bad method: " + context.method);
		var act = context.parameters.act;
		var post = JSON.parse(context.request.readAll(_));
		if (parseInt(post.act, 10) !== parseInt(context.parameters.act, 10)) throw new Error("act mismatch: expected " + context.parameters.act + ", got " + post.act);
		this._spy && this._spy.dumpJSON(_, "REQUEST", post);
		data = this._fusionClient.processRequest(_, post);
		//console.log("RESPONSE: " + JSON.stringify(response, null, 2));
		this._spy && this._spy.dumpJSON(_, "RESPONSE", data);

	}catch(e){
		console.error("Request service error: "+e.stack);

		var error = new CvgException(this.client, e, "Request service error");
		statusCode = 500;
		data.$diagnoses = [];
		data.$diagnoses.push(JSON.parse(JSON.stringify(error.diagnose)));
		
	}

	context.response.writeHead(statusCode, {
		"content-type": "application/json",
	});
	context.response.write(_, JSON.stringify(data), 'utf8');
	context.response.end();
}



sessionProto.processMisc = function(_, context) {
	throw new Error('NIY');
}


sessionProto.proxy = function(_, context, config) {
	try {
		//console.log(context.segments);
		var svc = context.segments[context.segments.length - 1];
		switch (svc) {
			case 'requestSvc':
				return this.processRequest(_, context);
			case 'formatSvc':
				return this._fusionClient.services.formatSvc.processRequest(_, context);
			case 'miscSvc':
				return this.processMisc(_, context);
			case 'blobSvc':
				return this._fusionClient.services.blobSvc.processRequest(_, context);
			default:
				throw new Error("invalid fusion service: " + svc);
		}
	} catch (ex) {
		// Maybe we have to close socket ?
		//this.close(_,false);
		throw _fusionErr(_, ex, "proxyFailed", this._endpoint);
	}
}


sessionProto.close = function(_, reuse) {
	console.error("CLOSE!!!");
	console.error("REUSE: "+reuse);
	function _addReuse(url) {
		if (!reuse) return url;
		if (url.indexOf("?") >= 0) return url + "&reuse=" + reuse;
		else return url + "?reuse=" + reuse;
	}
	try {
		if (reuse){
			// store CvgClient in reuse list
			this._fusionClient.setInReuseMode(_,true);
			listReuse.push(this._fusionClient);
			traceSessions && traceSessions("add reuse : size "+listReuse.length)
		}else{
			if (this._fusionClient.stream)
				this._fusionClient.deconnectClient(_,"logout");
		}
	} catch (ex) {
		console.error("EX: "+ex.stack);
		throw _fusionErr(_, ex, "closeFailed",this._endpoint);
	}
}

exports.getFusionSession = function(_, fsid) {
	return new FusionSession(fsid);
}

// global function called from sessions cleanup
exports.closeSession = function(_, fsid, sessionUrl) {
	var options = {
		url: sessionUrl,
		method: "DELETE"
	}
	var request = streams.httpRequest(options);
	var resp = request.end();
	//	var respStr = request.end().response(_).readAll(_).toString("utf8");
	// TODO: decode response ?
}

exports.install = function() {
	var bridge = require('./fusionSession');
	Object.keys(bridge).forEach(function(key) {
		bridge[key] = exports[key];
	})
}
