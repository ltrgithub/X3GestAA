"use strict";

var locale = require("syracuse-core/lib/locale");
var helpers = require("syracuse-core/lib/helpers");
var streams = require("streamline/lib/streams/streams");
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var x3helpers = require("./helpers");
var dispatcher = require('./proxyFusionDispatcher');
var parseUrl = require('url').parse;
var x3helpers = require("./helpers");
var globals = require('streamline/lib/globals');
var sys = require("util");
var httpHelpers = require("syracuse-sdata/lib/httpHelper");
var check = require("syracuse-license/lib/check");
var x3client = require('syracuse-x3/lib/client');

var listReuse = [];
var CvgClient = require("syracuse-x3/lib/convergence/client/CvgClient").CvgClient;

var traceSessions = nodeconfig.config && nodeconfig.config.x3fusion && nodeconfig.config.x3fusion.sessions && nodeconfig.config.x3fusion.sessions.trace;


var tracer = null;

function _startProfile() {
	return (new Date()).getTime();
}

function _endProfile(startTime) {
	return (new Date()).getTime() - startTime;
}

function FusionSession(fsid) {
	this.sessionUrl = "";
	this.isXmlSessionFormat = false;
	this.sid = fsid;
}


function _getRsrc() {
	try {
		var args = [module];
		for (var i in arguments) {
			args.push(arguments[i]);
		}
		return locale.format.apply(locale, args);
	} catch (e) {
		return "Resource not found [" + arguments[0] + "]";
	}
}

function _getErrMsg(_, ex, rsrcId, context) {
	var msg = rsrcId ? _getRsrc(rsrcId) : null;
	if (msg == undefined) msg = "";
	if (ex.message && ex.message.search(/ECONNREFUSED/i) >= 0) {
		msg += "\n" + _getRsrc("bridgeNotAvail");
	}
	var ep = context.endpoint;
	if (ep) {
		var baseUrl = ep.getFusionDataServerBaseUrl(_);
		baseUrl = baseUrl ? parseUrl(baseUrl) : "";
		// BRJOU DISABLE: msg += "\n--------------\n" + _getRsrc("endpointInfo", baseUrl.host, ep.getApplicationServerName(_), ep.getSolutionName(_), ep.getX3FolderName(_));
	}
	return msg;
}

function _fusionErr(_, ex, rsrcId, context) {
	throw new x3helpers.Error(_getErrMsg(_, ex, rsrcId, context), ex, ex.statusCode);
}

var activeClientList = {}


var sessionProto = FusionSession.prototype;
//
var SETTINGS = {
	"SDate": "/",
	"STime": ":",
	"SDecimal": ".",
	"SThousand": " ",
	"IDate": "0",

	"BOSEC": "SecEnterprise",
	"BOSERV": "sodged02.sagefr.adinternal.com:6400",
	"BOUSR": "CRYPT:udosdoQfsgrUgr",
	"BOPWD": "CRYPT:udorw3RgrskUksvaxvascc",

	"ADXAppHost": "172.28.16.106",
	"ADXFolder": "SUPERV",
	"ADXPort": "17000",
	"ADXTrtHost": "172.28.16.106",

	"usrProfile": "ADMIN",
	"formater.von": "on",
	"user": "cmi"
};




sessionProto.connect = function(_, context, config) {
	traceSessions && traceSessions("Direct Fusion Connect");
	var lic = check.getParsedLicense(_);
	if (lic && !lic.namedUsers)
		throw locale.format(module, "tooManyBadges");
	
	var x3server = context.endpoint.x3server(_);
	var userProfile = context.httpSession.getUserProfile(_);
	var localePrefs = userProfile && userProfile.selectedLocale(_);
	var endpoint = context.endpoint;
	var host = x3server.serverHost(_);
	var port = x3server.serverPort(_);
	var solution = endpoint.x3SolutionName(_);
	var adxFolder = endpoint.x3ServerFolder(_);
	var server = x3server.serverName(_);
	var adxHttpPub = endpoint.getApplicationServerBaseUrl(_);
	var preferences;
	var selLocale = userProfile.selectedLocale(_);
	if (selLocale) {
		// FDB - Session Settings required by X3 client - dateOrder (dym-myd-ymd-dm if no year...)/dateSep/decSep/thousandSep
		preferences = x3helpers.dateFormatToX3Prefs(selLocale.shortDate(_));
		preferences.decimalSep = selLocale.numberDecimalSeparator(_);
		preferences.thousandsSep = selLocale.numberGroupSeparator(_);
		preferences.timeSep = x3helpers.getTimeSep(selLocale.shortTime(_));
	}
	var username = userProfile && userProfile.user(_) && userProfile.user(_).getEndpointLogin(_, endpoint.$uuid);
	var reuseClient = null;
	//console.log("exec create session  reuse size "+listReuse.length);
	if (listReuse && listReuse.length !== 0) {
		//console.log("parcours reuse");
		var reuseContext = {
			user:username,
			adxHttpPub:adxHttpPub,
			server:host,
			port:port,
			syraPreferences:preferences,
			codeLangIso: locale.current,
		}
		var i=0;
		for(i=0;i<listReuse.length && reuseClient!==null ;i++){
			reuseClient = listReuse[i].isSameContext(reuseContext) ? reuseClient = listReuse[i] : reuseClient = null;
		}
		// remove client from reuse list
		if(reuseClient){
			//console.log("find reuse");
			this._fusionClient.setInReuseMode(true);
			listReuse.splice(i-1,1);
		}
	}
	var response =null;
	if (!reuseClient){
		traceSessions && traceSessions("Create new client.");
		//try {
		var client = x3client.create({
			port: port,
			address: host,
			tracer : traceSessions,
		});
		var cid = client.connect(_, {
			fusion: true,
			locale: locale.current,
		});
		traceSessions && traceSessions("CONNECTED: " + cid);
		var sid = client.createSession(_, {
			locale: locale.current,
			userName: username,
			adxtyp: 25,
			fusionTech: {
				protocol: "150067",
				wkf: context.parameters.f
			},


		});
		traceSessions && traceSessions("SESSION OK: " + this.sid);


	
		this._fusionClient = new CvgClient(_, client.getStream(), {
			adxHttpPub: adxHttpPub,
			adxFolder: adxFolder,
		}, {
			syraPreferences: preferences,
			user: username,
			server:host,
			port:port,
			codeLangIso: locale.current,
		});
		this._fusionClient.sessionConv = this;
		response = this._fusionClient.start(_);
	}else{
		this._fusionClient = reuseClient;
		traceSessions && traceSessions("Retrieve existing client.");
		this._fusionClient.isReuse=false;
		response = this._fusionClient.execOpenFunction(_,context.parameters.f);
	}
	this._fusionClient._spy && this._fusionClient._spy.dumpJSON(_, "RESPONSE", response);

	return {
		headers: {
			"content-type": "application/json",
		},
		body: response,
	};
	//} catch (ex) {
	//	throw _fusionErr(_, ex, "connectionFailed", context);
	//}
}

sessionProto.destroyReuseClient = function(cvgClient){
	var found = null;
	for(var i=0;i<listReuse.length && found;i++){
		listReuse[i].sid === cvgClient.sid ? found = listReuse[i] : found = null;
	}	
	console.log("remove session "+cvgClient.sid+" from reuse");
	listReuse.splice(i-1,1);
	cvgClient.deconnectClient("timeout reuse");

}

sessionProto.processRequest = function(_, context) {
	try {
		if (context.method !== 'put') throw new Error("bad method: " + context.method);
		var act = context.parameters.act;
		var post = JSON.parse(context.request.readAll(_));
		if (parseInt(post.act, 10) !== parseInt(context.parameters.act, 10)) throw new Error("act mismatch: expected " + context.parameters.act + ", got " + post.act);
		this._spy && this._spy.dumpJSON(_, "REQUEST", post);
		var response = this._fusionClient.processRequest(_, post);
		//console.log("RESPONSE: " + JSON.stringify(response, null, 2));
		this._spy && this._spy.dumpJSON(_, "RESPONSE", response);

		context.response.writeHead(200, {
			"content-type": "application/json",
		});
		context.response.write(_, JSON.stringify(response), 'utf8');
		context.response.end();
	} catch (ex) {
		// remove console.log later
		console.log(ex.stack);
		throw _fusionErr(_, ex, "connectionFailed", context);
	}
}

/*
					String paramStr = serviceRequest.getProviderContext().getParamGet(QUERY_ACT);
				int param = CXStringUtils.strToInt(paramStr, -1);
				CAdonixReply x3Reply = null;
				if (param == -1 && param != webPayload.getAction()) {
					// catch action in body if not present in url
					param = webPayload.getAction();
				}
				webResponse.setTechProp(JSON_ACTION, EAction.num2Name(param));
				if (param == EAction.CALL.getNumber()) {
					// get the xml of call
					x3Reply = execCall(webPayload);
				} else if (param == EAction.REPLY.getNumber()) {
					// send xml reply for the execi
					x3Reply = execReply(webPayload);
				} else if (param >= EAction.APPLICATIVE.getNumber()) {
					// execute applicative action
					x3Reply = executeStandardRequest(webPayload);

				} else if (param < EAction.APPLICATIVE.getNumber()) { // super
					// action retrieve the class that manage action and execute
					// it
					// Return last action response
					webResponse = execSuperAction(webRequest, param);
				}

				if (x3Reply != null) {
					CvgClient.checkFailed(x3Reply, FusionClientInfo.REQHDL, null);
					webResponse.setTechProp(JSON_X3REPLY, x3Reply);
				}
				// recuperation du reply et du request pour generate un state
				// fusion
				webResponse.setTechNano(JSON_TIMEEXEC, System.nanoTime() - start);
				fusionOutput.setSDataPayload(webResponse);
				// add in response header ADXLangIso
				fusionOutput.dumpInString(CONTENTYPE.JSON, false);
				*/


sessionProto.processFormat = function(_, context) {
	

	throw new Error('NIY');
}

sessionProto.processMisc = function(_, context) {
	throw new Error('NIY');
}


sessionProto.proxy = function(_, context, config) {
	try {
		//console.log(context.segments);
		var svc = context.segments[context.segments.length - 1];
		switch (svc) {
			case 'requestSvc':
				return this.processRequest(_, context);
			case 'formatSvc':
				return this.processFormat(_, context);
			case 'miscSvc':
				return this.processMisc(_, context);
			case 'blobSvc':
				return this._fusionClient.services.blobSvc.processRequest(_, context);
			default:
				throw new Error("invalid fusion service: " + svc);
		}

		/*
		var start = _startProfile();
		var tracer = config && config.tracer;
		var profiler = config && config.profiler;
		//
		var toWalk = context.toWalk();
		var baseUrl = context.endpoint.getFusionDataServerBaseUrl(_) + "/$sessions('" + this.sid + "')" + (toWalk ? "/" + toWalk : "");
		var clientReq = context.request;
		//clientReq.setEncoding("binary");
		//	var params = Object.keys(context.parameters).map(function(key) {return key + "=" + encodeURIComponent(context.parameters[key]); }).join("&");
		var params = context.rawQuery;
		var options = {
			url: baseUrl + (params ? ("?" + params) : ""),
			method: context.method,
			headers: clientReq.headers
		}
		tracer && tracer("FusionSession.proxy url: " + options.url);
		var proxyReq = streams.httpRequest(options);
		var buf;
		while (buf = clientReq.read(_))
		proxyReq.write(_, buf, "utf8");
		var proxyResp = proxyReq.end().response(_);
		var respHeaders = httpHelpers.parseHeaders(proxyResp.headers);
		proxyResp.setEncoding(respHeaders.toNodeCharset());
		var clientResp = context.response;
		var dis = dispatcher.create(context, function(data) {
			// data.headers and data.status have been forwarded by dispatcher only if dispatch is true
			if (!data.headers) data.headers = proxyResp.headers;
			if (!data.status) data.status = proxyResp.statusCode;

			// Add response time in httpheaders (dvlp)
			data.headers["syra-proxy-time"] = _endProfile(start);
			clientResp.writeHead(data.status, data.headers);
			// data.body has been forwarded by dispatcher
			clientResp.write(null, data.body, respHeaders.toNodeCharset());
			clientResp.end();
			profiler && profiler("PROFILE; Transition proxy roundtrip: " + _endProfile(start));
		});

		while (buf = proxyResp.read(_)) {
			dis.write(buf, respHeaders.toNodeCharset());
		}
		dis.forward(_, this.sid);
		*/
	} catch (ex) {
		console.error(ex);
		throw _fusionErr(_, ex, "proxyFailed", context);
	}
}


sessionProto.close = function(_, reuse) {
	console.error("CLOSE!!!");
	console.error("REUSE: "+reuse);
	function _addReuse(url) {
		if (!reuse) return url;
		if (url.indexOf("?") >= 0) return url + "&reuse=" + reuse;
		else return url + "?reuse=" + reuse;
	}
	try {
		if (reuse){
			// store CvgClient in reuse list
			this._fusionClient.setInReuseMode(true);
			listReuse.push(this._fusionClient);
			traceSessions && traceSessions("add reuse : size "+listReuse.length)
		}


		if (!this._baseUrl) return;
		// delete connection and session
		if (this._sessionUrl) {
			var options = {
				url: _addReuse(this._baseUrl + this._sessionUrl),
				method: "DELETE",
				headers: {
					"accept-charset": "utf-8"
				}
			}

			var request = streams.httpRequest(options);
			// response
			var resp = request.end().response(_);
			// check code
			if (resp.statusCode !== 204) {
				tracer && tracer("Delete session " + this.cid + " statusCode: " + resp.statusCode);
				// resp contains JSON error message sent by Java Bridge server
				var respHeaders = httpHelpers.parseHeaders(resp.headers);
				var respData = resp.readAll(_).toString(respHeaders.toNodeCharset());
				if (respHeaders.isJSON()) respData = JSON.parse(respData);
				//resp.setEncoding("binary");
				return {
					body: respData,
					statusCode: resp.statusCode
				}
			}
			tracer && tracer("Session " + this.sid + " deleted" + (reuse ? " with reuse" : ""));
		}
		if (this._connectionUrl) {
			var options = {
				url: _addReuse(this._baseUrl + this._connectionUrl),
				method: "DELETE",
				headers: {
					"accept-charset": "utf-8"
				}
			}
			var request = streams.httpRequest(options);
			// response
			var resp = request.end().response(_);
			// check code
			if ((resp.statusCode !== 204) && (resp.statusCode !== 404)) {
				tracer && tracer("Delete connection " + this.cid + " statusCode: " + resp.statusCode);
				// resp contains JSON error message sent by Java Bridge server
				var respHeaders = httpHelpers.parseHeaders(resp.headers);
				var respData = resp.readAll(_).toString(respHeaders.toNodeCharset());
				if (respHeaders.isJSON()) respData = JSON.parse(respData);
				return {
					body: respData,
					statusCode: resp.statusCode
				}
			}
			tracer && tracer("Connection " + this.cid + " deleted" + (reuse ? " with reuse" : ""));
		}
	} catch (ex) {
		throw _fusionErr(_, ex, "closeFailed", context);
	}
}

exports.getFusionSession = function(_, fsid) {
	return new FusionSession(fsid);
}

// global function called from sessions cleanup
exports.closeSession = function(_, fsid, sessionUrl) {
	var options = {
		url: sessionUrl,
		method: "DELETE"
	}
	var request = streams.httpRequest(options);
	var resp = request.end();
	//	var respStr = request.end().response(_).readAll(_).toString("utf8");
	// TODO: decode response ?
}

exports.install = function() {
	var bridge = require('./fusionSession');
	Object.keys(bridge).forEach(function(key) {
		bridge[key] = exports[key];
	})
}
