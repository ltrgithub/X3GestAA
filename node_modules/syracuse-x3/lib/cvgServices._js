"use strict";

var locale = require("syracuse-core/lib/locale");
var helpers = require("syracuse-core/lib/helpers");
var cvgSession = require("./cvgSession");
var httpHelper = require("syracuse-sdata/lib/httpHelper");
var streams = require("streamline/lib/streams/streams");
var zlib = require('zlib');

exports.connect = function(_, context, config) {
	var startConnect = new Date().getTime();
	var fsid = helpers.uuid.generate();
	var session = null;
	try {
		var request = context.request;
		if (!request.session) {
			var error = new Error(locale.format(module, "noSession"));
			error.httpStatus = httpHelper.HttpStatus.NotFound;
			error.recoveryCode = 'ABORT';
			throw error;
		}
		// check if it exists reuse session and check context	
		session = cvgSession.newSession(_, fsid);
		if (session != null) request.session.updateCvgSession(session);
		session.connect(_, context, config);
		// location mandatory - Used to propagate cvgSession id
		// FDB - Add response time in http  headers (dvlp)
		/*var result = {
			// FDB - return resp.statusCode if exists - Used to propagate Bridge errors to fusion client
			statusCode: resp.statusCode==null ? 201 : resp.statusCode,
			headers: respHeaders,
			body: resp.body,
			sid: resp.sid
		}*/
	} catch (e) {
		// Set location to send session.sid if connect fails -> client can retrieve session id
		e.httpHeaders = {
			location: context.baseUrl + "/$sessions('" + fsid + "')"
		};
		throw e;
	}
};

exports.proxy = function(_, context, config) {
	// bypass
	var request = context.request;
	if (!request.session) throw new Error(locale.format(module, "noSession"));
	//
	var session = request.session.getCvgSession(context.cvgSessionId);
	if (!session) {
		var error = new Error(locale.format(module, "sessionNotFound", context.cvgSessionId));
		error.httpStatus = httpHelper.HttpStatus.NotFound;
		error.recoveryCode = 'ABORT';
		throw error;
	}
	session.proxy(_, context, config);
	request.session.updateCvgSession(session);
};

exports.webProxy = function(_, context, webServerPath, config) {
	var baseUrl = context.endpoint.getWebServerBaseUrl(_, false);
	var request = context.request;
	request.setEncoding("binary");
	var options = {
		url: baseUrl + "/" + webServerPath,
		method: context.method,
		headers: request.headers
	};
	//console.log ("RQT PROXY OPT : " + JSON.stringify(options, null, 2));
	var clientReq = streams.httpRequest(options);
	var buf;
	while ((buf = request.read(_))) clientReq.write(_, buf, "binary");
	var response = clientReq.end().response(_);
	response.setEncoding("utf8");
	//
	if (context.request.headers['accept-encoding'] && context.request.headers['accept-encoding'].split(',').indexOf('gzip') !== -1) {
		var chunked = new Buffer([]);
		while (buf = response.read(_)) {
			chunked = Buffer.concat([chunked, new Buffer(buf)]);
		}
		chunked = zlib.gzip(chunked, ~_);
		response.headers["content-length"] = chunked.length;
		response.headers["content-encoding"] = "gzip";
		context.response.writeHead(response.statusCode, response.headers);
		context.response.end(chunked);
	} else {
		context.response.writeHead(response.statusCode, response.headers);
		while (buf = response.read(_)) {
			context.response.write(_, buf);
		}
		context.response.end();
	}
};