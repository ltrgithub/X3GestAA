"use strict";

var locale = require("syracuse-core/lib/locale");
var helpers = require("syracuse-core/lib/helpers");
var cvgSession = require("./cvgSession");
var httpHelper = require("syracuse-sdata/lib/httpHelper");
var streams = require("streamline/lib/streams/streams");

exports.connect = function(_, context, config) {
	var startConnect = new Date().getTime();
	var fsid = helpers.uuid.generate();
	var session = null;
	try {
		var request = context.request;
		if (!request.session) {
			var error = new Error(locale.format(module, "noSession"));
			error.httpStatus = httpHelper.HttpStatus.NotFound;
			error.recoveryCode = 'ABORT';
			throw error;
		}
		// check if it exists reuse session and check context	
		session = cvgSession.newSession(_, fsid);
		if (session != null) request.session.updateCvgSession(session);
		session.connect(_, context, config);
		// location mandatory - Used to propagate cvgSession id
		// FDB - Add response time in http  headers (dvlp)
		/*var result = {
			// FDB - return resp.statusCode if exists - Used to propagate Bridge errors to fusion client
			statusCode: resp.statusCode==null ? 201 : resp.statusCode,
			headers: respHeaders,
			body: resp.body,
			sid: resp.sid
		}*/
	} catch (e) {
		// Set location to send session.sid if connect fails -> client can retrieve session id
		e.httpHeaders = {
			location: context.baseUrl + "/$sessions('" + fsid + "')"
		};
		throw e;
	}
};

exports.proxy = function(_, context, config) {
	// bypass
	var request = context.request;
	if (!request.session) throw new Error(locale.format(module, "noSession"));
	//
	var session = request.session.getCvgSession(context.cvgSessionId);
	if (!session) {
		var error = new Error(locale.format(module, "sessionNotFound", context.cvgSessionId));
		error.httpStatus = httpHelper.HttpStatus.NotFound;
		error.recoveryCode = 'ABORT';
		throw error;
	}
	session.proxy(_, context, config);
	request.session.updateCvgSession(session);
};

exports.webProxy = function(_, context, webServerPath, config) {
	var baseUrl = context.endpoint.getWebServerBaseUrl(_, false);
	var request = context.request;
	request.setEncoding("binary");
	var params = Object.keys(context.parameters).map(function(key) {
		return key + "=" + encodeURIComponent(context.parameters[key]);
	}).join("&");
	var options = {
		url: baseUrl + "/" + webServerPath + (params ? ("?" + params) : ""),
		method: context.method,
		headers: request.headers
	};
	var clientReq = streams.httpRequest(options);
	var buf;
	while ((buf = request.read(_))) clientReq.write(_, buf, "binary");
	var response = clientReq.end().response(_);
	response.setEncoding("binary");
	//
	context.response.writeHead(response.statusCode, response.headers);
	while ((buf = response.read(_))) context.response.write(_, buf, "binary");
	context.response.end();
};