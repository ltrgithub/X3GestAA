"use strict";

var locale = require("syracuse-core/lib/locale");
var helpers = require("syracuse-core/lib/helpers");
var cvgSession = require("./cvgSession");
var httpHelper = require("syracuse-sdata/lib/httpHelper");
var ez = require("ez-streams");
var config = require('config');
var mimeUtils = require('streamline-static/lib/utils').mime;
var perfmon = require('syracuse-perfmon');

exports.connect = function(_, context, config) {
	var startConnect = new Date().getTime();
	var fsid = helpers.uuid.generate();
	var session = null;
	try {
		var request = context.request;
		if (!request.session) {
			var error = new Error(locale.format(module, "noSession"));
			error.httpStatus = httpHelper.HttpStatus.NotFound;
			error.recoveryCode = 'ABORT';
			throw error;
		}
		// check if it exists reuse session and check context
		session = cvgSession.newSession(_, fsid);
		if (session != null) {
			request.session.updateCvgSession(session);
		}
		session.connect(_, context, config);
		// location mandatory - Used to propagate cvgSession id
		// FDB - Add response time in http  headers (dvlp)
		/*var result = {
			// FDB - return resp.statusCode if exists - Used to propagate Bridge errors to fusion client
			statusCode: resp.statusCode==null ? 201 : resp.statusCode,
			headers: respHeaders,
			body: resp.body,
			sid: resp.sid
		}*/
	} catch (e) {


		// Set location to send session.sid if connect fails -> client can retrieve session id
		e.httpHeaders = {
			location: context.baseUrl + "/$sessions('" + fsid + "')"
		};
		throw e;
	}
};

exports.proxy = function(_, context, config) {
	// bypass
	var request = context.request;
	if (!request.session) {
		throw new Error(locale.format(module, "noSession"));
	}
	//
	var session = request.session.getCvgSession(context.cvgSessionId);
	if (!session) {
		console.error((new Date()).toISOString() + "-session: " + request.session.id + "; " + locale.format(module, "sessionNotFound", context.cvgSessionId));
		console.log((new Date()).toISOString() + "-session: " + request.session.id + "; " + locale.format(module, "sessionNotFound", context.cvgSessionId));
		var error = new Error(locale.format(module, "sessionNotFound", context.cvgSessionId));
		error.httpStatus = httpHelper.HttpStatus.NotFound;
		error.recoveryCode = 'ABORT';
		throw error;
	}
	session.proxy(_, context, config);
	request.session.updateCvgSession(session);
};

var sys = require("util");
exports.webProxy = function(_, context, webServerPath, config) {
	// Security whitelist (ilog res are mandatories)
	var wl = (config || {}).webProxyWhitelist || ["^(.*)/(GEN|RES)/.*\.(js|json|gif|png|jpeg|jpg|ico|bmp)$"];
	if (!Array.isArray(wl)) wl = [wl];
	wl.push("^(.*)/TMP/.*\.(ilinv|ilitm|ilres|ilacl|iladi|ilcpv|ildih|ilfeat|ilfeed|ilfocus|illnk|ilmfg|ilope|ilpar|ilrpw|iltun|iltuv|iltwd|ilwst)$"); // Gantt
	wl.push("^(.*)/TMP/.*\.(ilall|ilbox|ilcbt|ilcgd|ilctn|ilhsh|ilmat|ilmwg|ilpha|ilsle|ilsto|iltco|ilwgg|tra)$"); // Scales
	wl.push("^(.*)/TMP/.*\.(csv)$"); // csv

	if (!wl.some(function(wlItem) {
		return webServerPath.match(wlItem);
	})) return context.reply(_, 403);
	//
	var baseUrl = context.endpoint.getWebServerBaseUrl(_, false);
	var request = context.request;
	var options = {
		url: baseUrl + "/" + webServerPath,
		method: context.method,
		headers: request.headers,
		detectEncoding: "strict"
	};
	var timing = perfmon.start(module, "cvgService.webProxy", options.url);
	// console.log("webProxy options : " + JSON.stringify(options, null, 2));
	var clientReq = ez.devices.http.client(options);
	var buf;
	while ((buf = request.read(_))) {
		clientReq.write(_, buf);
	}
	var response = clientReq.end().response(_);
	pipe(_, response, context.response);
	timing.end({
		status: response.statusCode
	});
};

function pipe(_, input, output) {
	var timing = perfmon.start(module, "cvgService.pipe", input.url);
	var buf = input.read(_);

	input.headers["content-type"] = mimeUtils.fromContent(buf) || input.headers["content-type"];
	output.writeHead(input.statusCode, input.headers);

	buf && output.write(_, buf);
	while ((buf = input.read(_))) {
		output.write(_, buf);
	}
	output.end();
	timing.end({
		status: input.statusCode
	});
}