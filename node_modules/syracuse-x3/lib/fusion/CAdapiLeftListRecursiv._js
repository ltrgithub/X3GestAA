"use strict";
var helpers = require('syracuse-core/lib/helpers');
var CTraverser = function() {};
var CAdapiLeftList = function() {};

var CAdapiLeftNodeAttacher = helpers.defineClass(function(aLeftListNode, aClp) {
	this.leftListNode = aLeftListNode;
	this.clp = aClp;
}, CTraverser, {
	doWhenTraverse: function(aValue, aIdx, aWhen) {
		var wTraversingState = ITraverser.CONTINUE_TRAVERSING;
		var wLeftListNode = aValue;
		var wFound = wLeftListNode.cle.equals(this.clp);
		if (wFound) {
			wLeftListNode.attachLefListNode(this.leftListNode);

		}
		return wTraversingState;
	}
});

// CAdapiLeftNodeAttacher
var CAdapiLeftNodeFinder = helpers.defineClass(function(aNodeId) {
	this.nodeId = aNodeId;
	this.leftListNode = null;
}, CTraverser, {
	doWhenTraverse: function(aValue, aIdx, aWhen) {
		var wTraversingState = ITraverser.CONTINUE_TRAVERSING;
		var wLeftListNode = aValue;
		var wNodeId = wLeftListNode.nodeId;
		var wFound = wNodeId == this.nodeId;
		if (wFound) {
			this.leftListNode = wLeftListNode;
			wTraversingState = ITraverser.STOP_TRAVERSING;
		}
		return wTraversingState;
	},
	getLeftListNode: function() {
		return this.leftListNode;
	}
});

var NODE_INDEX_NULL = -1;

var CAdapiLeftListRecursiv = helpers.defineClass(function(aStackedWindow, aAdapiScreen, aEntityIndexBaseOne, aId, aListFormat, aNbColumns) {
	TODO_SUPER(aStackedWindow, aAdapiScreen, aEntityIndexBaseOne, aId, aListFormat, aNbColumns);
	this.addingLineInEmptyList = false;
	this.nodeIdToExpanded = NODE_INDEX_NULL;
	this.nodeIndex = NODE_INDEX_NULL;
}, CAdapiLeftList, {
	appendLeftListLine: function(aIdx, aBranche, aTxt, aVal, aClf, aClp) {
		var wLeftListNode = this.entrySup.clone();
		memoAddingLineInEmptyList();
		this.nodeIndex++;
		wLeftListNode.setColumns(this.nodeIndex, aTxt, aClf);
		if (aClp.size() == 0) {
			// si la cle pere est vide : ajout au premier niveau
			appendLeftListLine(wLeftListNode);
		} else {
			// sinon, recherche de tous les noeuds ayant la Clp comme cle pour ajouter
			attachLeftListNode(wLeftListNode, aClp);
		}
		return wLeftListNode;

	},
	attachLeftListNode: function(aLeftListNode, aClp) {
		if (!hasNodeIdToExpanded()) {
			var wNodeAttacher = new CAdapiLeftNodeAttacher(aLeftListNode, aClp);
			traverseAllSubNodes(wNodeAttacher);
		} else {
			findLeftListNode(this.nodeIdToExpanded).attachLefListNode(aLeftListNode);
		}
	},
	findLeftListNode: function(aNodeId) {
		var wNodeFinder = new CAdapiLeftNodeFinder(aNodeId);
		traverseAllSubNodes(wNodeFinder);
		var wLeftListNode = wNodeFinder.leftListNode;
		return wLeftListNode;
	},
	hasAddingLineInEmptyList: function() {
		return this.addingLineInEmptyList;
	},
	hasNodeIdToExpanded: function() {
		return this.nodeIdToExpanded != NODE_INDEX_NULL;
	},
	memoAddingLineInEmptyList: function() {
		if (!this.addingLineInEmptyList) {
			this.addingLineInEmptyList = this.nodeIndex == NODE_INDEX_NULL;
		}
	},
	razModification: function() {
		TODO_SUPER.razModification();
		this.addingLineInEmptyList = false;
		this.nodeIdToExpanded = NODE_INDEX_NULL;
	},
	serverRemoveAllLines: function() {
		TODO_SUPER.serverRemoveAllLines();
		this.nodeIndex = NODE_INDEX_NULL;
	},
	setNodeIdToExpanded: function(aNodeId) {
		this.nodeIdToExpanded = aNodeId;
	},
	toJsonAddRCD: function(line, record) {
		if (line instanceof CAdapiLeftListLineNode) {
			if (record.length() == 0) {
				// must create the $rcd object
				var o = line.toJson();
				if (o != null) {
					record.put(o);
				}
				return o;
			} else {
				return null;
			}
		} else {
			return TODO_SUPER.toJsonAddRCD(line, record);
		}
	},
	traverseAllSubNodes: function(aTraverser) {
		return traverseNodes(aTraverser, true);
	},
	traverseNodes: function(aTraverser, aWithSubNodes) {
		var wTraversingState = ITraverser.CONTINUE_TRAVERSING;
		//  prise en compte des n lignes de premier niveau
		var wLeftListNode;
		var wI = 0;
		while (wI < size()) {
			wLeftListNode = getLine(wI);

			wTraversingState = aTraverser.doWhenTraverse(wLeftListNode, wI);
			/*
			 * prise en compte des n fils
			 */
			if (wTraversingState != ITraverser.STOP_TRAVERSING && aWithSubNodes && wLeftListNode.hasSubNode()) {
				wTraversingState = wLeftListNode.traverseNodes(aTraverser, aWithSubNodes);
			}

			if (wTraversingState == ITraverser.STOP_TRAVERSING) {
				return ITraverser.STOP_TRAVERSING;
			}

			wI++;
		}
		return wTraversingState;
	},
	traverseSettable: function(aStructIst, aAdapiSetter) {
		if (aStructIst.isLineIst()) {
			var wI = aStructIst.idx;
			var wLeftListNode = findLeftListNode(wI);
			return aAdapiSetter.setAdapiModifiable(aStructIst, wLeftListNode);
		} else {
			return TODO_SUPER.traverseSettable(aStructIst, aAdapiSetter);
		}
	},
	traverseSubNodes: function(aTraverser) {
		return traverseNodes(aTraverser, false);
	}
});