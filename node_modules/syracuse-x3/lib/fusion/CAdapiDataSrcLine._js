"use strict";
var helpers = require('syracuse-core/lib/helpers');
var CAdapiEntity = function() {};

var CAdapiDataSrcLine = helpers.defineClass(function(requester, dataSrc, id, nbVars, zeroBaseIdx) {
	TODO_SUPER(dataSrc.getAdapiClient(), id, 0, EntityType.ROW);
	this.zeroBaseIdx = zeroBaseIdx !== undefined ? zeroBaseIdx : -1;
	setZeroBaseIdx(zeroBaseIdx);
	this.adapiRequester = requester;
	this.adapiDataSrc = dataSrc;
	// Table des variables => indxees par leur RANG
	this.vars = new CAdapiVariable[Math.max(nbVars, 0)];
	// Table des variables => indxees par leur NOM
	this.hVars = new Hashtable(String, CAdapiVariable)();
	this.modified = false;
	// true if a combo cell has a disableChoice modif
	this.comboDchModif = false;
	addObserver(requester.getAdapiClient());
	// En dernier
	setTypeJsonNode(ETypeJsonNode.ENTITY);
}, CAdapiEntity, {
	addOneVar: function(aVariable) {
		this.hVars.put(aVariable.getId(), aVariable);
		this.vars[this.hVars.size() - 1] = aVariable;
	},
	// FDB - Suppression des mvts MODIFIED/UNMODIFIED
	// Remplacé par this.modified - Impacte le $rcd de fuison
	cellHasBeenModified: function() {
		if (!this.modified) {
			this.modified = true;
			forceServerValueModification(true);
			forceChange();
		}
	},
	clone: function() {
		var srcLine = new CAdapiDataSrcLine(getAdapiRequester(), getDataSrc(), getId(), getNbVar(), getZeroBaseLineIdx());
		cloneVars(srcLine);
		return srcLine;
	},
	cloneVars: function(srcLine) {
		var wMax = this.vars.length;
		var wClonedVariable;
		var wI = 0;
		while (wI < wMax) {
			wClonedVariable = this.vars[wI].clone();
			wClonedVariable.setSrcLine(srcLine);
			srcLine.this.vars[wI] = wClonedVariable;
			wI++;
		}
	},
	comboDchAddJSON: function(arr) {
		for (var v in this.getVars()) {
			if (v instanceof CAdapiVariableCombo) {
				var x = new JSONArray();
				x.put(v.getId());
				x.put(getOneBaseLineIdx());
				v.toDchJSON(x);
				arr.put(x);
			}
		}
		return arr;
	},
	comboDchModifhas: function() {
		return this.comboDchModif;

	},
	comboDchModifSet: function() {
		if (!this.comboDchModif) {
			this.comboDchModif = true;
			forceChange();
		}
	},
	dispose: function() {
		TODO_SUPER.dispose();
		this.adapiDataSrc = null;
		this.adapiRequester = null;
		if (this.hVars != null) {
			for (var v in this.hVars.values()) {
				if (v != null) {
					v.dispose();
				}
			}
			this.hVars.clear();
			this.hVars = null;
		}
		if (this.vars != null) {
			for (var v in this.vars) {
				if (v != null) {
					v.dispose();
				}
			}
			this.vars = null;
		}
	},
	forceChange: function() {
		if (this.adapiDataSrc != null && this.adapiDataSrc.isBlocGrid()) {
			this.adapiDataSrc.forceChange();
		} else {

		}
	},
	getAdapiObservableId: function() {
		var fullId = TODO_SUPER.getAdapiObservableId();
		fullId += "-L" + getOneBaseLineIdx();
		return fullId;
	},
	getAdapiRequester: function() {
		return this.adapiRequester;
	},
	getAdxId: function() {
		var wSB = new StringBuilder(16);
		wSB.append(getDataSrcAdxId());
		wSB.append('0');
		wSB.append(',');
		wSB.append(getOneBaseLineIdx());
		return wSB.toString();
	}

	// Retourne l'AdapiDataSrc mere de la datasource
	,
	getDataSrc: function() {
		return this.adapiDataSrc;
	}

	// Retourne l'AdxId de la datasource "mere"
	,
	getDataSrcAdxId: function() {
		return this.adapiDataSrc == null ? null : this.adapiDataSrc.getAdxId();
	},
	getListEntityDifferentValue: function (metadata) {
		var map = new Hashtable(Long, CAdapiEntity)();
		var value = "";
		var colVal = "";
		var i = 0;
		for (var item in getVars()) {
			if (i != 0) {
				var colVar = getDataSrc().getEntrySup() != null ? getDataSrc().getEntrySup().getVars()[i] : null;
				var valueItem = "";
				var stamp = -1;
				var lineStamp = -1;
				var colStamp = -1;
				switch (metadata) {
				case STY:
					valueItem = item.getStyle(); // value cell
					value = getStyle(); // value line
					if (colVar != null) {
						colVal = colVar.getStyle(); // value column
						colStamp = colVar.getLastStampModSty();
					}
					stamp = item.getLastStampModSty();
					lineStamp = getLastStampModSty();
					break;
				case STT:
					valueItem = Integer.toString(item.getState());
					value = Integer.toString(getState());
					stamp = item.getLastStampModState();
					lineStamp = getLastStampModState();
					if (colVar != null) {
						colStamp = colVar.getLastStampModState();
						colVal = Integer.toString(colVar.getState()); // value column
					}
					break;
				case TIT:
					valueItem = item.getTitle();
					value = getTitle();
					stamp = item.getLastStampModTit();
					lineStamp = getLastStampModTit();
					if (colVar != null) {
						colStamp = colVar.getLastStampModTit();
						colVal = colVar.getTitle(); // value column
					}
					break;
				case FMT:
					if (item.getFormat() != null) {
						valueItem = item.getFormat().getString();
						if (getFormat() != null) {
							value = getFormat().getString();
						}
						if (colVar != null) {
							if (colVar.getFormat() != null) {
								colVal = colVar.getFormat().getString(); // value column
							}
							colStamp = colVar.getLastStampModFmt();
						}
						stamp = item.getLastStampModFmt();
						lineStamp = getLastStampModFmt();
					}
					break;
				}
				if (stamp != -1) {
					if (lineStamp > colStamp) { // la ligne est plus recente
						if (valueItem != null && !valueItem.equals(value) && stamp > lineStamp) {
							map.put(stamp, item);
						}
					} else {
						if (valueItem != null && !valueItem.equals(colVal) && stamp > colStamp) {
							map.put(stamp, item);
						}
					}
				}
			}
			i++;
		}
		return map;
	},
	getListEntityOlderThan: function(metaData, timstamp, olderthan) {
		var listAdapiEntity = new Hashtable(Long, CAdapiEntity)();
		for (var v in this.getVars()) {
			var hasValue = false;
			var stamp = -1;
			switch (metaData) {
			case FMT:
				stamp = this.
				v.getLastStampModFmt();
				hasValue = this.
				v.getFormat() != null;
				break;
			case STT:
				stamp = this.
				v.getLastStampModState();
				hasValue = stamp != -1;
				break;
			case STY:
				stamp = this.
				v.getLastStampModSty();
				hasValue = this.
				v.getStyle() != null && this.
				v.getStyle().length() != 0;
				break;
			case TIT:
				stamp = this.
				v.getLastStampModTit();
				hasValue = this.
				v.getTitle() != null && this.
				v.getTitle().length() != 0;
				break;
			}
			if (olderthan) {
				if (stamp != -1) {
					if (stamp < timstamp && hasValue) {
						listAdapiEntity.put(stamp, this.
						v);
					}
				}
			} else {
				if (stamp != -1) {
					if (stamp >= timstamp && hasValue) {
						listAdapiEntity.put(stamp, this.
						v);
					}
				}
			}
		}
		return listAdapiEntity;
	},
	getNbVar: function() {
		return this.vars == null ? 0 : this.vars.length;
	},
	getOneBaseLineIdx: function() {
		return this.zeroBaseLineIdx + 1;
	},
	getVar: function(aIndex) {
		var wVar = null;
		if (aIndex >= 0 && aIndex < this.vars.length) {
			wVar = this.vars[aIndex];
		}
		return wVar;
	},
	getVars: function() {
		return this.vars;
	},
	getZeroBaseLineIdx: function() {
		return this.zeroBaseLineIdx;
	},
	initVars: function(nbVar) {
		this.vars = new CAdapiVariable[nbVar];
	},
	isModiefied: function() {
		return this.modified;
	},
	notifyObservers: function() {
		TODO_SUPER.notifyObservers();
	},
	razModification: function() {
		this.modified = false;
		this.comboDchModif = false;
		for (var item in this.vars) {
			item.razModification();
		}
		TODO_SUPER.razModification();
	}

	/**
	 * GLUTE : gestion des formats dans les colonnes des tableaux juste apres sa
	 * construction, on associe a la ligne une ligne "mere". (voir clonage dans
	 * la methode "insertServerLines" de "CAdapiDataSrc") Note: sert a la
	 * propagation du format courant a chaque modification de valeur
	 */
	,
	setFormaterEntity: function(aLineOfFormater) {
		var vars = getVars();
		for (i = 0; i < vars.length; i++) {
			vars[i].setColumnFormater(aLineOfFormater.getVar(i));
		}
	},
	setVar: function(aIndex, v) {
		if (aIndex >= 0 && aIndex < this.vars.length) {
			this.vars[aIndex] = v;
		}
	},
	setZeroBaseIdx: function(zeroBaseIdx) {
		this.zeroBaseLineIdx = zeroBaseIdx;
	},
	toJson: function() {
		var nbCells = getVars().length;
		// On ne transmet pas le N° de ligne
		if (nbCells <= 1) {
			return null;
		}
		var object = new JSONObject();
		// line number - from 1
		for (j = 1; j < nbCells; j++) {
			var v = getVar(j);
			if (v.hasServerValueModification()) {
				// Styles separes des data
				object.put(v.getJsonKey(),
				v.getValueForJson());
			}
		}
		if (object.length() == 0) {
			// Null si aucune variable
			return null;
		} else {
			// used only by fusion client for update mvts
			object.put(JSON_DOLLAR_UUID, this.getZeroBaseLineIdx());
		}
		return object;
	},
	traverseAll: function(aTraverser) {
		var wMax = this.vars.length;
		var wVariable;
		var wI = 0;
		while (wI < wMax) {
			wVariable = this.vars[wI];

			if (aTraverser.doWhenTraverse(wVariable, wI) == ITraverser.STOP_TRAVERSING) {
				return ITraverser.STOP_TRAVERSING;
			}

			wI++;
		}
		return ITraverser.CONTINUE_TRAVERSING;
	},
	traverseChilds: function(aTraverser) {
		var wTraversingState = ITraverser.CONTINUE_TRAVERSING;
		var wX3Variable;
		var wMax = this.vars.length;
		var wI = 0;
		while (wI < wMax) {
			wX3Variable = this.vars[wI];
			if (wX3Variable == null) {
				wTraversingState = ITraverser.STOP_TRAVERSING;
			}
			if (wTraversingState != ITraverser.STOP_TRAVERSING) {
				wTraversingState = aTraverser.doWhenTraverse(wX3Variable, wI);
			}
			if (wTraversingState == ITraverser.STOP_TRAVERSING) {
				return wTraversingState;
			}
			wI++;
		}
		return wTraversingState;
	},
	traverseSettable: function(aStructIst, aAdapiSetter) {
		/*
		 * 15w_017 - Fiche 46222 - Gestion des colonnes de tableau invisibles Si
		 * la porte est un champ ou une colonne
		 */
		if (aStructIst.isFieldIst() || aStructIst.isAllLinesOfColumnIst()) {
			var wI = aStructIst.getFieldZeroBase();

			if (wI < 0 || wI >= this.vars.length) {
				var wMess = getAdapiClient().getAdapiResources().getMessage(CAdapiResources.KEYMESS_ERROR_VAR_UNKNOWN);
				wMess = CStringFacilities.sprintf(wMess, String.valueOf(wI), String.valueOf(this.vars.length), getAdxId());
				aAdapiSetter.setLogicalErrMess(wMess);
				return false;
			}
			var wVariable = this.vars[wI];
			return aAdapiSetter.setAdapiModifiable(aStructIst, wVariable);
		}
		/*
		 * Si la porte l'ensemble des lignes
		 */
		else if (aStructIst.isAllLinesOfBlocIst()) {
			return traverseSettableFields(aStructIst, aAdapiSetter);
		}
		/*
		 * Sinon la porte est la ligne
		 */
		else if (aStructIst.isLineIst()) {
			var wContinue = aAdapiSetter.setAdapiModifiable(aStructIst, this);
			// si c'est un changement d'etat : application sur toutes les champs
			if (wContinue && aAdapiSetter instanceof CAdapiRequest.CServerStateSetter) {
				wContinue = traverseSettableFields(aStructIst, aAdapiSetter);
			}
			return wContinue;
		} else {
			var wMess = getRsrcMess(CAdapiResources.KEYMESS_ERROR_TRAVERSE_SETTABLE);
			wMess = CStringFacilities.sprintf(wMess, aStructIst.getAlphanumCodage(), getAdxId(), CStringFacilities.getClasseName(aAdapiSetter.getClass()));
			aAdapiSetter.setLogicalErrMess(wMess);
			return false;
		}
	},
	traverseSettableFields: function(aStructIst, aAdapiSetter) {
		var wContinue = true;
		var wI = 0;
		var wMax = this.vars.length;
		var wVariable;

		while (wI < wMax && wContinue) {
			wVariable = this.vars[wI];

			wContinue = aAdapiSetter.setAdapiModifiable(aStructIst, wVariable);

			wI++;
		}
		return wContinue;
	}

});