"use strict"; var helpers = require('syracuse-core/lib/helpers');

import java.io.File;
import java.security.PrivateKey;
import java.security.PublicKey;

import com.adonix.util.CXFileDir;
import com.adonix.util.json.JSONObject;
import com.sage.x3.context.CContextCore;
import com.sage.x3.crypto.CKeyPairSerializer;
import com.sage.x3.shared.CConstants;

var FusionConfig = helpers.defineClass(function() {}, null, {

	public final static String HANGUP_TEMP = "runtime_bundle.webclient.hangup.check.tompo";
	public final static String EMPTY = "";
	public final static String ACTIVE_FUSION = "runtime.bundle_fusion.active.on";
	public final static String SYRA_PUB_KEY = "runtime.bundle_fusion.public.key";
	public final static String SYRA_PRIV_KEY = "runtime.bundle_fusion.private.key";
	public final static String REUSE_MAX_TIME_IN_STACK = "runtime.bundle_fusion.timeout.free.reuse.session";
	public final static String REUSE_CHECK_INTERVAL = "runtime.bundle_fusion.reuse.stack.checkinterval";
	public final static String FUSION_ACTIVE_RECORD_EXCHANGE_FOLDER = "runtime.bundle_fusion.client.recording.folder";
	public final static String FUSION_ACTIVE_RECORD_EXCHANGE = "runtime.bundle_fusion.client.recording.on";
	private static String RECORD_DIRPREF = "FusionClient_";
	private static String TEMPDIR = CConstants.DIR_TEMP;
	private static String PUBLICDIR = CConstants.DIR_PUBLIC;
	private static String PUBLICDIR_SERVLETPATH = "/" +  PUBLICDIR;
	private static String HTTPDIR ="http";


	public static boolean getBool(key) {
		try {
			var val = getProp(key, false);
			if (val == null) {
				val = EMPTY;
			}
			val = val.trim().toLowerCase();
			return "on".equals(val) || "true".equals(val) || "yes".equals(val);
		} catch (e) {
		}
		return false;
	}

	public static CXFileDir getDataPublicDir()  throws Exception {
		return getDataSubDir(PUBLICDIR);

	}

	public static CXFileDir getDataSubDir (path) throws Exception  {
		var dir = new CXFileDir(getInstallDataDir(), path);
		if (!dir.exists()) {
			dir.createHierarchy();
		}
		return dir;
	}

	public static CXFileDir getDataTempDir()  throws Exception {
		return getDataSubDir(TEMPDIR);
	}

	public static CXFileDir getInstallDataDir () throws Exception {
		var dir = new CXFileDir(getInstallDataPath());
		if (!dir.exists()) {
			throw new Exception("Install data directory not found\n[" +getInstallDataPath()+"]");
		}
		return dir;
	}

	private static String getInstallDataPath() {
		return CContextCore.getConfig().getInstallDataPath();
	}

	public static CXFileDir getInstallToolDir () throws Exception {
		var dir = new CXFileDir(getInstallToolPath());
		if (!dir.exists()) {
			throw new Exception("Install tool directory not found\n[" +getInstallToolPath()+"]");
		}
		return dir;
	}

	private static String getInstallToolPath() {
		return CContextCore.getConfig().getInstallToolPath();
	}

	public static int getInt(key, def) {
		var res = getPropInt(key, false);
		return res == null ? def : res.intValue();
	}

	public static int getIntMandatory(key, def) {
		return getPropInt(key, true);
	}

	public static JSONObject getJSONMainInfo() {
			var cfgCtx = new JSONObject().put("host", getLocalHost()).put("tools", getInstallToolPath()).put("data", getInstallDataPath());
			cfgCtx.put("systemarch", getStr("all.control.systemarch", EMPTY));
			cfgCtx.put("systembits", getStr("all.control.systembits", EMPTY));
			cfgCtx.put("systemtype", getStr("all.control.systemtype", EMPTY));
			cfgCtx.put("sdataPort", getStr("runtime.bundle_sdata.http.port", EMPTY));
			cfgCtx.put("jettyPort", getStr("runtime.service.jetty.port", EMPTY));
			cfgCtx.put("installpatch", getStr("all.control.installpatch", EMPTY));
			cfgCtx.put("installvers", getStr("all.control.installvers", EMPTY));
			cfgCtx.put("installversname", getStr("all.control.installversname", EMPTY));
			cfgCtx.put("installversnum", getStr("all.control.installversnum", EMPTY));
			cfgCtx.put("installfix", getStr("all.control.installfix", EMPTY));
			cfgCtx.put("installminor", getStr("all.control.installminor", EMPTY));
			cfgCtx.put("installfix", getStr("all.control.installfix", EMPTY));
			cfgCtx.put("builddate", CContextCore.getConfig().getBuildDate());
			return cfgCtx;
	}

	private static String getKeyFileDir() {
		return CContextCore.getConfig().getToolKeystoreDir().getAbsolutePath() + File.separatorChar + "syracuse";
	}

	public static String getLocalHost() {
		return CContextCore.getConfig().getLocalHost();
	}

	public static long getLong(key, def) {
		var res = getPropLong(key, false);
		return res == null ? def : res.longValue();
	}

	public static long getLongMandatory(key, def) {
		return getPropLong(key, true);
	}

	public static PrivateKey getPrivateKey() {
		var keyFile = getProp(SYRA_PRIV_KEY, true);
		try {
			var pubkey = CKeyPairSerializer.LoadPrivKey(getKeyFileDir(), keyFile + ".pem", "RSA");
			return pubkey;
		} catch (f) {
			throw f;
		} catch (e) {
			FusionExcep.throwConfigExcep("Bad private key file\n\tkeystorepath[" + getKeyFileDir() + "]\n\tKey[" + keyFile + "]", e);
		}
		return null;
	}

	private static String getProp(key, mandatory) {
		try {
			var res = CContextCore.getConfig().getProperty(key);
			if (mandatory && res != null) {
				res = res.trim();
			}
			if (mandatory && (res == null || res.isEmpty())) {
				throw new Exception("Empty property");
			}
			return res;
		} catch (e) {
			if (mandatory) {
				FusionExcep.throwConfigExcep(e.getMessage() + " - Key[" + key + "]", e);
			}
		}
		return null;
	}

	private static Integer getPropInt(key, mandatory) {
		try {
			return new Integer(getProp(key, mandatory));
		} catch (f) {
			throw f;
		} catch (e) {
			if (mandatory) {
				FusionExcep.throwConfigExcep("Bad int value - Key[" + key + "]", e);
			}
		}
		return null;
	}

	private static Long getPropLong(key, mandatory) {
		try {
			return new Long(getProp(key, mandatory));
		} catch (f) {
			throw f;
		} catch (e) {
			if (mandatory) {
				FusionExcep.throwConfigExcep("Bad long value - Key[" + key + "]", e);
			}
		}
		return null;
	}

	public static String getPubKeyName() {
		return CContextCore.getConfig().getProperty(SYRA_PUB_KEY);
	}

	public static PublicKey getPublicKey(keyFile) {
		try {
			return CKeyPairSerializer.LoadPubKey(getKeyFileDir(), keyFile + ".pem", "RSA", "file");
		} catch (f) {
			throw f;
		} catch (e) {
			FusionExcep.throwConfigExcep("Bad public key file\n\tdir[" + getKeyFileDir() + "]\n\tfile[" + keyFile + "]", e);
		}
		return null;
	}

	public static String getSchemaNameSpace() {
		return "http://" + CContextCore.getConfig().getLocalHost() + "/schema/2012";
	}

	public static String getStr(key, def) {
		var r = getProp(key, false);
		return r == null ? def : r;
	}

	public static String getStrMandatory(key) {
		return getProp(key, true);
	}

	public static boolean isFusionActive() {
		return getBool(ACTIVE_FUSION);
	}

	public static CXFileDir recordDirHttp(customSubFolder, sessId, create) {
		var dir = null;
		try {
			var parent = recordDirParent(customSubFolder, sessId, create);
			dir = new CXFileDir(parent, HTTPDIR);
			if (create) {
				dir.createHierarchy();
			}
		} catch (e) {
			System.err.println("!! recordDirHttpInit failed");
			e.printStackTrace();
			dir = null;
		}
		return dir;
	}

	public static CXFileDir recordDirParent(customSubFolder, sessId, create) {
		var res = null;
		try {
			var tmp = getDataPublicDir();
			if (tmp != null) {
				var parent = new CXFileDir(tmp, recordSubFolder(customSubFolder));
				if (create) {
					parent.createHierarchy();
				}
				res = new CXFileDir(parent, RECORD_DIRPREF + sessId);
				if (create) {
					res.createHierarchy();
				}

			}
		} catch (e) {
			System.err.println("!! recordDirFusionClient failed");
			e.printStackTrace();
			res = null;
		}
		return res;
	}

	public static String recordGetServletAccessParent(customSubFolder, sessId) {
		return PUBLICDIR_SERVLETPATH + "/" + recordSubFolder(customSubFolder);
	}

	// Voir config jetty - File acces - /com.sage.x3.simulator/all/tool/TOOLS/jettyhome/contexts/fusion_record.xml
	public static String recordGetServletAccessPath(customSubFolder, sessId,fileName) {
		return recordGetServletAccessParent(customSubFolder,sessId) + "/" + RECORD_DIRPREF + sessId + "/" + HTTPDIR + "/" + fileName;
	}

	private static String recordSubFolder(customSubFolder){
		if (customSubFolder == null || customSubFolder.trim().isEmpty()){
			return getStr(FusionConfig.FUSION_ACTIVE_RECORD_EXCHANGE_FOLDER, "fusion_record");
		}else{
			return customSubFolder.trim();
		}
	}
}
