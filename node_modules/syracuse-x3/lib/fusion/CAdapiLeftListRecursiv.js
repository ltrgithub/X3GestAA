"use strict";
var helpers = require('syracuse-core/lib/helpers');
var CTraverser = Object; //require('syracuse-x3/lib/fusion/CTraverser').CTraverser;
var CAdapiLeftList = require('syracuse-x3/lib/fusion/CAdapiLeftList').CAdapiLeftList;

var CAdapiLeftNodeAttacher = exports.CAdapiLeftNodeAttacher = helpers.defineClass(function(aLeftListNode, aClp) {
	this.leftListNode = aLeftListNode;
	this.clp = aClp;
}, CTraverser, {
	doWhenTraverse: function(aValue, aIdx, aWhen) {
		var wTraversingState = false;
		var wLeftListNode = aValue;
		var wFound = wLeftListNode.cle === this.clp;
		if (wFound) {
			wLeftListNode.attachLefListNode(this.leftListNode);

		}
		return wTraversingState;
	}
});

// CAdapiLeftNodeAttacher
var CAdapiLeftNodeFinder = exports.CAdapiLeftNodeFinder = helpers.defineClass(function(aNodeId) {
	this.nodeId = aNodeId;
	this.leftListNode = null;
}, CTraverser, {
	doWhenTraverse: function(aValue, aIdx, aWhen) {
		var wTraversingState = false;
		var wLeftListNode = aValue;
		var wNodeId = wLeftListNode.nodeId;
		var wFound = wNodeId == this.nodeId;
		if (wFound) {
			this.leftListNode = wLeftListNode;
			wTraversingState = true;
		}
		return wTraversingState;
	},
});

var NODE_INDEX_NULL = -1;

var CAdapiLeftListRecursiv = exports.CAdapiLeftListRecursiv = helpers.defineClass(function(aStackedWindow, aScreen, aEntityIndexBaseOne, aId, aListFormat, aNbColumns) {
	CAdapiLeftList.call(this, aStackedWindow, aScreen, aEntityIndexBaseOne, aId, aListFormat, aNbColumns);
	this.addingLineInEmptyList = false;
	this.nodeIdToExpanded = NODE_INDEX_NULL;
	this.nodeIndex = NODE_INDEX_NULL;
}, CAdapiLeftList, {
	appendLeftListLine: function(aIdx, aBranche, aTxt, aVal, aClf, aClp) {
		var wLeftListNode = this.entrySup.clone();
		memoAddingLineInEmptyList();
		this.nodeIndex++;
		wLeftListNode.setColumns(this.nodeIndex, aTxt, aClf);
		if (aClp.length == 0) {
			// si la cle pere est vide : ajout au premier niveau
			CAdapiDataSrc.prototype.appendLeftListLine.call(this, wLeftListNode);
		} else {
			// sinon, recherche de tous les noeuds ayant la Clp comme cle pour ajouter
			this.attachLeftListNode(wLeftListNode, aClp);
		}
		return wLeftListNode;

	},
	attachLeftListNode: function(aLeftListNode, aClp) {
		if (!hasNodeIdToExpanded()) {
			var wNodeAttacher = new CAdapiLeftNodeAttacher(aLeftListNode, aClp);
			traverseAllSubNodes(wNodeAttacher);
		} else {
			findLeftListNode(this.nodeIdToExpanded).attachLefListNode(aLeftListNode);
		}
	},
	findLeftListNode: function(aNodeId) {
		var wNodeFinder = new CAdapiLeftNodeFinder(aNodeId);
		traverseAllSubNodes(wNodeFinder);
		var wLeftListNode = wNodeFinder.leftListNode;
		return wLeftListNode;
	},
	hasAddingLineInEmptyList: function() {
		return this.addingLineInEmptyList;
	},
	hasNodeIdToExpanded: function() {
		return this.nodeIdToExpanded != NODE_INDEX_NULL;
	},
	memoAddingLineInEmptyList: function() {
		if (!this.addingLineInEmptyList) {
			this.addingLineInEmptyList = this.nodeIndex == NODE_INDEX_NULL;
		}
	},
	razModification: function() {
		CAdapiLeftList.prototype.razModification.call(this);
		this.addingLineInEmptyList = false;
		this.nodeIdToExpanded = NODE_INDEX_NULL;
	},
	serverRemoveAllLines: function() {
		CAdapiLeftList.prototype.serverRemoveAllLines.call(this);
		this.nodeIndex = NODE_INDEX_NULL;
	},
	setNodeIdToExpanded: function(aNodeId) {
		this.nodeIdToExpanded = aNodeId;
	},
	toJsonAddRCD: function(line, record) {
		if (line instanceof CAdapiLeftListLineNode) {
			if (record.length == 0) {
				// must create the $rcd object
				var o = line.toJSON();
				if (o != null) {
					record.put(o);
				}
				return o;
			} else {
				return null;
			}
		} else {
			return CAdapiLeftList.prototype.toJsonAddRCD.call(this, line, record);
		}
	},
	traverseAllSubNodes: function(aTraverser) {
		return traverseNodes(aTraverser, true);
	},
	traverseNodes: function(aTraverser, aWithSubNodes) {
		var wTraversingState = false;
		//  prise en compte des n lignes de premier niveau
		var wLeftListNode;
		var wI = 0;
		while (wI < size()) {
			wLeftListNode = getLine(wI);

			wTraversingState = aTraverser.doWhenTraverse(wLeftListNode, wI);
			/*
			 * prise en compte des n fils
			 */
			if (wTraversingState != true && aWithSubNodes && wLeftListNode.hasSubNode()) {
				wTraversingState = wLeftListNode.traverseNodes(aTraverser, aWithSubNodes);
			}

			if (wTraversingState == true) {
				return true;
			}

			wI++;
		}
		return wTraversingState;
	},
	traverseSettable: function(aStructIst, aSetter) {
		if (aStructIst.isLineIst()) {
			var wI = aStructIst.idx;
			var wLeftListNode = findLeftListNode(wI);
			return aSetter.setAdapiModifiable(aStructIst, wLeftListNode);
		} else {
			return CAdapiLeftList.prototype.traverseSettable.call(this, aStructIst, aSetter);
		}
	},
	traverseSubNodes: function(aTraverser) {
		return this.traverseNodes(aTraverser, false);
	}
});