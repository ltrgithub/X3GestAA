"use strict";
var helpers = require('syracuse-core/lib/helpers');

/**
 * "Resu" contenu dans un argument d'un neoud.
 * <p>
 * Le res_u est compose par 2 octets donnant le type et la longueur, suivis de
 * la valeur.
 * <ul>
 * <li>0 indique un résu nul. le 2ieme octet est nul.
 * <li>44 indique un "libelle". le 2ieme octet est nul, le 3ieme indique la
 * valeur
 * <li>45 indique un entier court, le 2ime octet est nul et 3&4 donne la valeur
 * (Little Endian)
 * <li>46 indique un entier long, le 2 est nul, la valeur est sur 4 octets
 * <li>47 indique un BCD. le 2 indique la lg de mantisse</li>
 * <li>51 indique une date (un entier sur 3 octets),</li>
 * <ul>
 * <li>le 2 est normalement a 3</li>
 * <li>suit le nombre de jours depuis le 1er janvier 1600.</li>
 * </ul>
 * <li>122 indique une chaine unicode:</li>
 * <ul>
 * <li>les 2ème et 3 ème octets donnent la longueur du buffer à suivre (2 + n)</li>
 * <li>les 4ème et 5 ème octets donnent le nombre de caracteres (0 à n)</li>
 * <li>suivent n caractères codés en UTF-8</li>
 * </ul>
 * </ul>
 * 
 * <pre>
 *   (moteur) : 44      45       46       47         51    122     125       124
 *   (java)   : Byte    Short    Integer  BigDecimal Date  String  CClob     byte[]
 *   (résu)   : LIB     SHORT    INT      BCD        DATE  STRU.   CLOB      BLOB
 *   (L4G)    : Libelle Shortint Integer  Decimal    Date  Char    Clobfile  Blobfile
 * </pre>
 * 
 * <li>X3TYP_BLOB = 0x7C; //124; (lg sur 4 octets +
 * binaire)
 * <li>X3TYP_CLOB = 0x7D; //125; (lg sur 4 octets +
 * UTF8)
 * <li>X3TYP_DATE = 0x33; //51;
 * <li>X3TYP_DCB = 0x2F; //47;
 * <li>X3TYP_INT = 0x2E; //46;
 * <li>X3TYP_LIBELLE = 0x2C; //44;
 * <li>X3TYP_NULL = 0x00; //0;
 * <li>X3TYP_SHORT = 0x2D; //45;
 * <li>X3TYP_STRU = 0x7A; //122;
 * <li>X3TYP_UNKNOWN = -1;
 * 
 * @author Adonix Grenoble
 * @version 140_000
 */

var CStructResu = exports.CStructResu = helpers.defineClass(function(type, val) {
	this.type = type;
	this.value = val;
}, null, {
	toString: function() {
		return JSON.stringify(this);
	},
	equals: function(v) {
		return v && v.type === this.type && v.value === this.value;
	},
	isNull: function() {
		return this.type === CStructResu.TDO_NULL;
	},
	isDate: function() {
		return this.type === CStructResu.TDO_DATE;
	},
	isDCB: function() {
		return this.type === CStructResu.TDO_DCB;
	},
	isInt: function() {
		return this.type === CStructResu.TDO_INT;
	},
	isShort: function() {
		return this.type === CStructResu.TDO_SHORT;
	},
	isDateNull: function() {
		return this.isDate() && this.value === "00000000";
	},
	isNum: function() {
		return this.isDCB() || this.isInt() || this.isShort();
	},
	getBytes: function() {
		var val = this.value;
		switch (this.type) {
			case CStructResu.TDO_ALPHA:
				var buf = new Buffer(2 + 2 * (val.length + 1));
				buf[0] = CStructResu.TAG_STRU;
				buf[1] = val.length;
				for (var i = 0; i < val.length; i++) {
					var ch = val.charCodeAt(i);
					buf[2 + 2 * i] = (ch >> 8) & 0xff;
					buf[2 + 2 * i + 1] = ch & 0xff;
				}
				buf[2 + 2 * val.length] = 0;
				buf[2 + 2 * val.length + 1] = 0;
				return buf;
			case CStructResu.TDO_NULL:
				return new Buffer([0, 0]);
			case CStructResu.TDO_SHORT:
				return new Buffer([CStructResu.TAG_SHORT, 0, (val >> 8) & 0xff, val & 0xff])
			case CStructResu.TDO_INT:
			case CStructResu.TDO_MENLOC:
				// MENLOC like int
				return new Buffer([CStructResu.TAG_INT, 0, (val >> 24) & 0xff, (val >> 16) & 0xff, //
				(val >> 8) & 0xff, val & 0xff]);
			case CStructResu.TDO_DCB:
				return BCD.toBytes(val);
			default:
				throw new Error("NIY resu to bytes: " + this.type);
		}
	}
});


CStructResu.TAG_BLOB = 0x7c; // 124 (lg sur 4 octets + binaire)
CStructResu.TAG_CLOB = 0x7d; // 125 (lg sur 4 octets + UTF8)
CStructResu.TAG_DATE = 0x33; // 51
CStructResu.TAG_DCB = 0x2f; // 47
CStructResu.TAG_INT = 0x2e; // 46
CStructResu.TAG_LIBELLE = 0x2c; // 44
CStructResu.TAG_NULL = 0x00; // 0
CStructResu.TAG_SHORT = 0x2d; // 45
CStructResu.TAG_STRU = 0x7a; // 122


CStructResu.TDO_NULL = 0;
CStructResu.TDO_MENLOC = 1;
CStructResu.TDO_SHORT = 2;
CStructResu.TDO_INT = 3;
CStructResu.TDO_DCB = 4;
CStructResu.TDO_DECI = 5;
CStructResu.TDO_FLOT = 6;
CStructResu.TDO_ALPHA = 7;
CStructResu.TDO_DATE = 8;
CStructResu.TDO_BLOB = 9;
CStructResu.TDO_CLOB = 10;

CStructResu.read = function(reader) {
	var tag = reader.nextByte();
	var len = reader.nextByte();
	var val;
	switch (tag) {
		case CStructResu.TAG_INT:
			val = reader.nextLong();
			return new CStructResu(CStructResu.TDO_INT, val);
		case CStructResu.TAG_DCB:
			if (len !== 17) throw new Error("bad bcd len: " + len);
			val = reader.nextBcd();
			return new CStructResu(CStructResu.TDO_DCB, val);
		case CStructResu.TAG_NULL:
			return new CStructResu(CStructResu.TDO_NULL, null);
		case CStructResu.TAG_STRU:
			val = reader.nextUnicode(len);
			return new CStructResu(CStructResu.TDO_ALPHA, val);
		case CStructResu.TAG_DATE:
			if (len !== 3) throw new Error("bad date len: " + len);
			val = reader.nextDate3();
			return new CStructResu(CStructResu.TDO_DATE, val);
		default:
			throw new Error("bad resu tag: " + tag + " (" + String.fromCharCode(tag) + ")");
	}
}

CStructResu.fromAction = function(type, str) {
	console.log("FROMACTION: type=" + type + " val=" + str);
	switch (type) {
		case CStructResu.TDO_NULL:
			return new CStructResu(type, null);
		case CStructResu.TDO_SHORT:
		case CStructResu.TDO_INT:
		case CStructResu.TDO_MENLOC:
			return new CStructResu(type, parseInt(str, 10));
		case CStructResu.TDO_ALPHA:
			return new CStructResu(type, str);
		default:
			throw new Error("bad resu type: " + type);
	}
}