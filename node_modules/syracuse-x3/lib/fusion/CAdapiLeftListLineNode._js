"use strict";
var helpers = require('syracuse-core/lib/helpers');
var CAdapiLeftListLine = function() {};


var CAdapiLeftListLineNode = helpers.defineClass(function(aStackedWindow, aLeftList, aId, aNbVariables, idx) {
	TODO_SUPER(aStackedWindow, aLeftList, aId, aNbVariables, idx);
	this.subLeftListNodes = new ArrayList(CAdapiLeftListLineNode)();
}, CAdapiLeftListLine, {
	attachLefListNode: function(aLeftListNode) {
		this.subLeftListNodes.add(aLeftListNode);
	},
	clone: function() {
		var idx = this.dataSrc.size();
		var wClone = new CAdapiLeftListLineNode(this.adapiRequester, this.dataSrc, this.id, this.nbVar, idx);
		cloneVars(wClone);
		return wClone;
	},
	getLeftListRecursiv: function() {
		return this.dataSrc;
	},
	getNodeId: function() {
		return this.oneBaseLineIdx;
	},
	hasSubNode: function() {
		return this.subLeftListNodes.size() > 0;
	},
	setColumns: function(aIdx, aText, aClf) {
		setZeroBaseIdx(aIdx);
		setCle(aClf);
		var v = this.getVar(0);
		if (v != null) {
			v.setUnModifiableServerValue(new CStructResu(this.tracer, CStructResu.X3TYP_STRU, aText));
		}
	},
	traverseChilds: function(aTraverser) {
		var wTraversingState = ITraverser.CONTINUE_TRAVERSING;
		if (hasSubNode()) {
			wTraversingState = traverseSubNodes(aTraverser);
		}
		if (wTraversingState == ITraverser.CONTINUE_TRAVERSING) {
			TODO_SUPER.traverseChilds(aTraverser);
		}
		return wTraversingState;
	},
	traverseNodes: function(aTraverser, aWithSubNodes) {

		var wTraversingState = ITraverser.CONTINUE_TRAVERSING;
		var wLeftListNode;
		var wMax = this.subLeftListNodes.size();
		var wI = 0;
		while (wI < wMax) {
			wLeftListNode = this.subLeftListNodes.get(wI);
			wTraversingState = aTraverser.doWhenTraverse(wLeftListNode, wI);
			if (wTraversingState != ITraverser.STOP_TRAVERSING && aWithSubNodes && wLeftListNode.hasSubNode()) {
				wTraversingState = wLeftListNode.traverseNodes(aTraverser, aWithSubNodes);
			}
			if (wTraversingState == ITraverser.STOP_TRAVERSING) {
				return ITraverser.STOP_TRAVERSING;
			}
			wI++;
		}
		return wTraversingState;
	},
	traverseSubNodes: function(aTraverser) {
		return traverseNodes(aTraverser, false);
	}
});