"use strict";
var helpers = require('syracuse-core/lib/helpers');
var AdapiObservable = require('syracuse-x3/lib/fusion/AdapiObservable').AdapiObservable;
var CStructIst = require('syracuse-x3/lib/fusion/CStructIst').CStructIst;

var lastTick = 0;
function getTick() {
	var tick = Date.now() * 1000000;
	if (tick <= lastTick) {
		tick = lastTick + 1;
	}
	lastTick = tick;
	//console.log("tick=" + tick);
	return tick;
}

var FusionEntityState = exports.FusionEntityState = helpers.defineClass(function(maskVal, maskAtt, maskNot) {
	this.maskVal = maskVal;
	this.maskAtt = maskAtt;
	this.maskNot = maskNot;
}, null, {
	isOn: function(status) {
		return (this.maskVal & status) > 0;
	},
	setBits: function(status, on) {
		var isOn = this.isOn(status);
		if (on && !isOn) {
			return status | this.maskVal | this.maskAtt;
		}
		if (!on && isOn) {
			return status & this.maskNot | this.maskAtt;
		}
		return status;
	}

});

FusionEntityState.razAtt = function(status) {
	return status & 0x0000FFFF;
}

FusionEntityState.ACTIF = new FusionEntityState(0x0001, 0x00010000, 0xFFFFFFFE);
FusionEntityState.READONLY = new FusionEntityState(0x0002, 0x00020000, 0xFFFFFFFD);
FusionEntityState.VISIBLE = new FusionEntityState(0x0004, 0x00040000, 0xFFFFFFFB);
FusionEntityState.SELECTED = new FusionEntityState(0x0008, 0x00080000, 0xFFFFFFF7);


var FusionMetaData = exports.FusionMetaData = {
	STY: 0,
	STT: 1,
	TIT: 2,
	FMT: 3
}

// Etats géré par ADAPI
/**
 * <pre>
 *  0  0  0  0  0  0  0
 *  ^  ^  ^  ^  ^  ^  ^
 *  |  |  |  |  |  |  |
 *  |  |  |  |  |  |  +- VISIBLE
 *  |  |  |  |  |  +- EDITABLE
 *  |  |  |  |  +- GRIZO
 *  |  |  |  +- DISZO
 *  |  |  +- SELECTED
 * </pre>
 */
var STATE_VISIBLE = 1;
var STATE_NOT_VISIBLE = 2;
var STATE_ENABLE = 4;
var STATE_NOT_ENABLE = 8;
var STATE_SELECT = 16;
var STATE_NOT_SELECT = 32;
var STATE_READONLY = 64;
var STATE_NOT_READONLY = 128;
var STATE_DEFAULT = 0;
//var STATE_GRIZO = 4;
// Etats reçu du serveur X3
var X3_SRV_GRIZO = 0;
var X3_SRV_ACTZO = 1;
var X3_SRV_DISZO = 2;
// Variables X3 - attribut MAF du xml
var X3VAR_MAF_AFFICHE = 2;
var X3VAR_MAF_INVISIBLE = 3;
var X3VAR_MAF_SAISI = 1;
var X3VAR_MAF_TECHNIQUE = 4;

var AT = '@'.charCodeAt(0);

var CAdapiEntity = exports.CAdapiEntity = helpers.defineClass(function(aAdapiClient, aId, aEntityIndexBaseOne, aEntityTyp) {
	AdapiObservable.call(this, aAdapiClient);
	//console.log("CREATE ENTITY: type=" + aEntityTyp + ", index=" + aEntityIndexBaseOne);
	this.state = STATE_DEFAULT;
	this.isTitleModified = false;
	this.format = null;
	this.columnFormater = null;
	this.srvValueModified = false; // true by default
	this.lastState = STATE_DEFAULT;
	this.formatModified = false;
	this.styleModified = false;
	this.serverValue = null;
	this.stateModified = false;
	this.style = "";
	// Label champ, titre fenetre
	this.title = null;
	this.titleStyle = null;
	this.lastStampModState = -1;
	this.lastStampModSty = -1;
	this.lastStampModFmt = -1;
	this.lastStampModTit = -1;
	this.entityIdxAlpha = null;

	this.forceServerValueModification(false);
	this.client = aAdapiClient;
	this.id = aId;
	this.entityIndexBaseOne = aEntityIndexBaseOne;
	// AlphaNum
	var wSB = "";
	var w26E1 = Math.floor(this.entityIndexBaseOne / 26);
	if (w26E1 > 0) {
		wSB += String.fromCharCode(AT + w26E1);
		wSB += String.fromCharCode(AT + this.entityIndexBaseOne % 26);
	} else {
		wSB += String.fromCharCode(AT + this.entityIndexBaseOne);
	}
	console.log("CREATE " + aEntityTyp + " entityIdxAlpha=" + wSB + ', index=' + aEntityIndexBaseOne);
	this.entityIdxAlpha = wSB;
	this.entityTyp = aEntityTyp;
	// force change, this method perform update if jsonType is sepcified else we need to forceChange again
	this.forceChange();
}, AdapiObservable, {

	//Bits    15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 0
	//        |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  +-- « Etat » ==> 0 : inactif(Grizo) – 1 : actif (actzo)
	//        |  |  |  |  |  |  |  |  |  |  |  |  |  |  +----- « Lecture seule » (Diszo)==> 0 : non  – 1 : oui
	//        |  |  |  |  |  |  |  |  |  |  |  |  |  +-------- « Apparence » ==> 0 : invisible – 1 : visible
	//        |  |  |  |  |  |  |  |  |  |  |  |  +----------- « Statut » ==> 0 : désélectionné – 1 : sélectionné
	//Bits    31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16
	//        |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  +-- Notion « Etat » ==> 0 : absente – 1 : présente
	//        |  |  |  |  |  |  |  |  |  |  |  |  |  |  +----- Notion « Lecture seule » ==> 0 : absente – 1 : présente
	//        |  |  |  |  |  |  |  |  |  |  |  |  |  +-------- Notion « Apparence » ==> 0 : absente – 1 : présente
	//        |  |  |  |  |  |  |  |  |  |  |  |  +----------- Notion « Statut » ==> 0 : absente – 1 : présente
	calcJsonNewEntityState: function(curFusionState, stateToAdd) {
		var addActif = (stateToAdd & STATE_ENABLE) > 0;
		var addNotActif = (stateToAdd & STATE_NOT_ENABLE) > 0;
		var addVisible = (stateToAdd & STATE_VISIBLE) > 0;
		var addNotVisible = (stateToAdd & STATE_NOT_VISIBLE) > 0;
		var addReadOnly = (stateToAdd & STATE_READONLY) > 0;
		var addNotReadOnly = (stateToAdd & STATE_NOT_READONLY) > 0;
		var addSelect = (stateToAdd & STATE_SELECT) > 0;
		var addNotSelect = (stateToAdd & STATE_NOT_SELECT) > 0;

		var newFusionState = curFusionState;
		if (addActif) {
			newFusionState = FusionEntityState.ACTIF.setBits(newFusionState, true);
		}
		if (addNotActif) {
			newFusionState = FusionEntityState.ACTIF.setBits(newFusionState, false);
		}
		if (addVisible) {
			newFusionState = FusionEntityState.VISIBLE.setBits(newFusionState, true);
		}
		if (addNotVisible) {
			newFusionState = FusionEntityState.VISIBLE.setBits(newFusionState, false);
		}
		if (addReadOnly) {
			newFusionState = FusionEntityState.READONLY.setBits(newFusionState, true);
		}
		if (addNotReadOnly) {
			newFusionState = FusionEntityState.READONLY.setBits(newFusionState, false);
		}
		if (addSelect) {
			newFusionState = FusionEntityState.SELECTED.setBits(newFusionState, false);
		}
		if (addNotSelect) {
			newFusionState = FusionEntityState.SELECTED.setBits(newFusionState, false);
		}
		return newFusionState;
	},
	cloneValues: function(v) {
		v.style = this.style;
		v.setLastStampMod(getTick(), 'STY');
		if (this.serverValue != null) {
			v.serverValue = this.serverValue.clone();
		}
	},
	stateSet: function(aNewState, force) {
		var old = this.state;
		var niou = this.calcJsonNewEntityState(this.state, aNewState);
		if (niou != old) {
			this.setLastStampMod(getTick(), 'STT');
		}
		if (force || this.state != niou) {
			this.state = niou;
			this.stateModified = niou != this.lastState;
		}
	},
	forceServerFormat: function(aServerFormat) {
		if (this.format == null || aServerFormat.string === this.format.string) {
			this.setLastStampMod(getTick(), 'FMT');
		}
		this.format = aServerFormat;
	},
	forceServerValueModification: function(count) {
		this.srvValueModified = true;
	},

	// WINID + SCREENID + BLOCID + FIELDID
	getAdapiObservableId: function() {
		var ist = this.getAdxIst();
		if (ist != null) {
			var fullId = "";
			fullId += ist.winAlphaId;
			if (this.entityTyp != 'WINDOW') {
				fullId += ist.screenAlphaIdFusion;
				if (this.entityTyp != 'SCREEN') {
					fullId += ist.blocAlphaId;
					if (this.entityTyp == 'FIELD') {
						fullId += ist.field;
					}
				}
			}
			return fullId;
		}
		return null;
	},

	//getAdxId: function();
	// Todo - Optimiser sur modif adxId
	getAdxIst: function() {
		return new CStructIst(this.getAdxId());
	},

	getFatherWindowId: function() {
		// using identity id to find the windows
		console.log("FATHER: " + this.getAdxIst());
		return this.getAdxId() == null ? null : this.getAdxIst().winAlphaId;
	},

	// Cle pour entree JSON fusion - ON supprime le code window
	// WIN 		-> WINID    							- Ex B
	// SCREEN 	-> SCREENID     						- Ex B
	// BLOC 	-> SCREENID  + BLOCID	   				- Ex BA
	// FIELD 	-> SCREENID  + BLOCID +  FIELD ID	   	- Ex BA3
	getJsonKey: function() {
		var ist = this.getAdxIst();
		if (ist == null) {
			return null;
		}
		if (this.entityTyp == 'WINDOW') {
			return ist.winAlphaId;
		}
		if (this.entityTyp == 'SCREEN') {
			return ist.screenAlphaIdFusion;
		}
		var jsonKey = "";
		jsonKey += ist.screenAlphaIdFusion;
		jsonKey += ist.blocAlphaId;
		if (this.entityTyp == 'FIELD') {
			jsonKey += ist.field;
		}
		return jsonKey;
	},
	getRsrcMess: function(id) {
		return this.client.resources.getMessage(id);
	},
	getServerValInt: function() {
		return this.serverValue != null ? this.serverValue.value : -1;
	},
	getServerValStr: function() {
		return this.serverValue != null ? this.serverValue.value : "";
	},
	hasColumnFormater: function() {
		return this.columnFormater != null;
	},
	hasModifState: function() {
		return this.stateModified;
	},
	hasModifStyle: function() {
		return this.styleModified;
	},
	hasModifTitle: function() {
		return this.isTitleModified;
	}

	// retourne vrai si la valeur a ete changee par le serveur
	,
	hasServerValueModification: function() {
		return this.srvValueModified;
	},
	hasValidFormat: function() {
		// TODO TCA
		return true;
		return this.format != null && this.format.isValid();
	},
	isDisposed: function() {
		return this.client == null;
	},
	isServerValueEquals: function(aValue) {
		return this.serverValue != null ? this.serverValue === aValue : aValue == null;
	},
	isStateEditable: function() {
		return FusionEntityState.ACTIF.isOn(this.state);
	},
	isStateVisible: function() {
		return FusionEntityState.VISIBLE.isOn(this.state);
	},
	razModification: function() {
		AdapiObservable.prototype.razModification.call(this);
		this.formatModified = false;
		this.razStateModified();
		this.styleModified = false;
		this.isTitleModified = false;
		this.setLastStampModFmt(-1);
		this.setLastStampModSty(-1);
		this.setLastStampModState(-1);
		this.setLastStampModTit(-1);
		this.razServerValueModified();
	},
	razServerValueModified: function() {
		this.resetServerModified();
	},
	razStateModified: function() {
		this.state = FusionEntityState.razAtt(this.state);
		this.lastState = this.state;
		this.stateModified = false;
	},
	resetServerModified: function() {
		this.srvValueModified = false;
	}

	// Pour une colonne on associe un 'format' commun pour toutes cellules - Ce format est le format d'une cellule d'une ligne déié à la gestion des formats
	// formatRefCell - Cellule de référence pour toutes celles de la colonne
	,
	setColumnFormater: function(formatRefCell) {
		if (this.format == null || this.format.string === formatRefCell.format.string) {
			this.setLastStampMod(getTick(), 'FMT');
		}
		this.columnFormater = formatRefCell;
		if (this.hasColumnFormater()) {
			// on appelle pas "forceServerFormat" pour ne pas incrementer le compteur de modification.
			this.format = this.columnFormater.format;
		}
		this.lastStampModFmt = getTick();
	},
	setFormat: function(f) {
		this.format = f;
	},
	setLastStampMod: function(lastStampMod, metadata) {
		switch (metadata) {
		case 'STT':
			this.setLastStampModState(lastStampMod);
			break;
		case 'STY':
			this.setLastStampModSty(lastStampMod);
			break;
		case 'FMT':
			this.setLastStampModFmt(lastStampMod);
			break;
		case 'TIT':
			this.setLastStampModTit(lastStampMod);
			break;
		}
		if (lastStampMod != -1) {
			this.forceChange();
		}
	},
	setLastStampModFmt: function(lastStampModFmt) {
		this.lastStampModFmt = lastStampModFmt;
	},
	setLastStampModState: function(lastStampModState) {
		this.lastStampModState = lastStampModState;
	},
	setLastStampModSty: function(lastStampModSty) {
		this.lastStampModSty = lastStampModSty;
	},
	setLastStampModTit: function(lastStampModTit) {
		this.lastStampModTit = lastStampModTit;
	},
	setLeftListLinePickingSel: function(selected) {
		setLeftListLineSelected(selected, true);
		// 15w_016 - Fiche 44742 - Non deselection d'une ligne pick si fiche bloquee
		// il est n�cessaire de forcer "this.lastState" pour qu'un NDULAR arrivant avant un noeud de fin de message (cf. NDBOXI) puisse s'appliquer
		this.lastState = this.state;
	}

	// State utilise auusi  pour sélectionner une ligne
	,
	setLeftListLineSelected: function(selected, force) {
		this.stateSet(selected ? STATE_SELECT : STATE_NOT_SELECT, true);
	},
	setServerFormat: function(aFormat) {
		this.formatModified = true;
		if (this.format == null || aFormat.string !== this.format.string) {
			setLastStampMod(getTick(), 'FMT');
		}
		this.format = aFormat;
		var wInferredState = STATE_DEFAULT;
		var wFormatVisible = this.format != null && this.format.isVisible();
		var wChangeVisibility = this.isStateVisible() && !wFormatVisible || !this.isStateVisible() && wFormatVisible;
		if (this.hasColumnFormater()) {
			this.columnFormater.storeFormat(aFormat);
		}
		if (wChangeVisibility) {
			wInferredState = wFormatVisible ? STATE_VISIBLE : STATE_NOT_VISIBLE;
			this.stateSet(wInferredState, false);
			if (this.hasColumnFormater()) {
				this.columnFormater.stateSet(wInferredState, false);
				// si l'etat du formater n'a pas encore ete modifie => on le force
				if (!this.columnFormater.stateModified) {
					this.columnFormater.stateModified = true;
				}
			}
		}
		return wInferredState;
	},
	setServerResu: function(aStructResu) {
		this.serverValue = aStructResu;
	}

	// Style pour les variables - Noeud NDCSTL
	,
	setServerStyle: function(aStyle, applyOn) {
		if (applyOn != null && applyOn == StyleApply.TITLE) {
			// Style applies on title
			this.titleStyle = aStyle;
			this.isTitleModified = true;
		} else {
			// Style applies on entity
			if (this.style == null || this.style !== aStyle) {
				setLastStampMod(getTick(), 'STY');
			}
			this.style = aStyle;
			this.styleModified = true;
		}
	},
	setServerTitle: function(aTitle) {
		var wNewTitle = aTitle != null && aTitle !== this.title;
		if (wNewTitle) {
			this.title = aTitle;
			this.isTitleModified = true;
			// TODO TCA 
			// Last stamp mod must be in nano seconds
			this.setLastStampMod(new Date().getTime(), 'TIT');
		}
	},
	setServerValue: function(aStructResu) {
		if (this.serverValue == null || this.serverValue !== aStructResu) {
			this.forceServerValueModification(false);
		}
		this.setServerResu(aStructResu);
		if (!this.formatModified && this.columnFormater != null && this.columnFormater !== this.format) {
			this.forceServerFormat(this.columnFormater.format);
		}
		this.forceChange();
	},

	// State  pour les variables - Attribut MAF
	setStateFromDescr: function(state) {
		this.state = this.calcJsonNewEntityState(this.state, state);
	}

	// Style pour les variables - Attribut STX
	,
	setStyleFromDescr: function(aStyle) {
		if (this.style == null || this.style !== aStyle) {
			setLastStampMod(getTick(), 'STY');
		}
		this.style = aStyle;
	},
	setUnModifiableServerValue: function(aStructResu) {
		var wNewValue = (aStructResu !== this.serverValue);
		if (wNewValue) {
			this.setServerValue(aStructResu);
		}
		return wNewValue;
	},
	storeFormat: function(aFormat) {
		if (this.format == null || this.format.string !== aFormat.string) {
			this.lastStampModFmt = getTick();
		}
		this.format = aFormat;
	},
	toString: function() {
		return this.entityTyp + " " + this.entityIdxAlpha;
	}

	//toJSON: function();
});

// Variables - Mode d'affichage - Reprise Web126
CAdapiEntity.x3AffModeToEntityState = function(mode) {
	switch (mode) {
	case X3VAR_MAF_SAISI:
		return STATE_VISIBLE + STATE_ENABLE;
	case X3VAR_MAF_AFFICHE:
		return STATE_VISIBLE + CAdapiEntity.x3State2EntityState(X3_SRV_GRIZO);
	case X3VAR_MAF_INVISIBLE:
	case X3VAR_MAF_TECHNIQUE:
	default:
		return STATE_NOT_VISIBLE;
	}
}

// Testé avec CMichel
CAdapiEntity.x3State2EntityState = function(aX3State) {
	switch (aX3State) {
	case X3_SRV_GRIZO:
		return STATE_NOT_READONLY + STATE_NOT_ENABLE;
	case X3_SRV_DISZO:
		return STATE_READONLY + STATE_ENABLE;
	case X3_SRV_ACTZO:
		return STATE_ENABLE + STATE_NOT_READONLY;
	default:
		throw new Error("Unknown X3 server state[" + aX3State + "]");
	}
}

CAdapiEntity.x3StateToString = function(aServerState) {
	switch (aServerState) {
	case X3_SRV_GRIZO:
		return "SRV_GRIZO";
	case X3_SRV_ACTZO:
		return "SRV_ACTZO";
	case X3_SRV_DISZO:
		return "SRV_DISZO";
	default:
		{
			return "Unknown serverState [" + aServerState + ']';
		}
	}
}