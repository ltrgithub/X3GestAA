"use strict";
var helpers = require('syracuse-core/lib/helpers');
var CAdapiEntity = require('syracuse-x3/lib/fusion/CAdapiEntity').CAdapiEntity;
var CAdapiVariable = require('syracuse-x3/lib/fusion/CAdapiEntity').CAdapiVariable;
var CAdapiResources = require('syracuse-x3/lib/fusion/CAdapiResources').CAdapiResources;



var CAdapiDataSrcLine = exports.CAdapiDataSrcLine = helpers.defineClass(function(requester, dataSrc, id, nbVars, zeroBaseIdx) {
	CAdapiEntity.call(this, dataSrc && dataSrc.adapiClient, id, 0, 'ROW');
	this.zeroBaseIdx = zeroBaseIdx !== undefined ? zeroBaseIdx : -1;
	this.setZeroBaseIdx(zeroBaseIdx);
	this.adapiRequester = requester;
	this.dataSrc = dataSrc;
	// Table des variables => indxees par leur RANG
	this.vars = [];
	// Table des variables => indxees par leur NOM
	this.hVars = {};
	this.modified = false;
	// true if a combo cell has a disableChoice modif
	this.comboDchModif = false;
	this.addObserver(requester && requester.adapiClient);
	// En dernier
	this.setJsonType('ENTITY');
}, CAdapiEntity, {
	addOneVar: function(aVariable) {
		this.hVars[aVariable.id] = aVariable;
		this.vars[this.hVars.length - 1] = aVariable;
	},
	// FDB - Suppression des mvts MODIFIED/UNMODIFIED
	// Remplacé par this.modified - Impacte le $rcd de fuison
	cellHasBeenModified: function() {
		if (!this.modified) {
			this.modified = true;
			this.forceServerValueModification(true);
			this.forceChange();
		}
	},
	clone: function() {
		var srcLine = new CAdapiDataSrcLine(this.adapiRequester, this.dataSrc, this.id, this.vars.length, this.zeroBaseLineIdx);
		this.cloneVars(srcLine);
		return srcLine;
	},
	cloneVars: function(srcLine) {
		var wMax = this.vars.length;
		var wClonedVariable;
		var wI = 0;
		while (wI < wMax) {
			wClonedVariable = this.vars[wI].clone();
			wClonedVariable.setSrcLine(srcLine);
			srcLine.this.vars[wI] = wClonedVariable;
			wI++;
		}
	},
	comboDchAddJSON: function(arr) {
		for (var v in this.vars) {
			if (v instanceof CAdapiVariableCombo) {
				var x = [];
				x.push(v.id);
				x.push(this.zeroBaseLineIdx + 1);
				v.toDchJSON(x);
				arr.push(x);
			}
		}
		return arr;
	},
	comboDchModifhas: function() {
		return this.comboDchModif;

	},
	comboDchModifSet: function() {
		if (!this.comboDchModif) {
			this.comboDchModif = true;
			forceChange();
		}
	},
	dispose: function() {
		CAdapiEntity.prototype.dispose.call(this);
		this.dataSrc = null;
		this.adapiRequester = null;
		if (this.hVars != null) {
			for (var v in Object.keys(this.hVars)) {
				if (this.hVars[v] != null) {
					this.hVars[v].dispose();
				}
			}
			this.hVars = [];
			this.hVars = null;
		}
		if (this.vars != null) {
			for (var v in this.vars) {
				if (v != null) {
					v.dispose();
				}
			}
			this.vars = null;
		}
	},
	forceChange: function() {
		if (this.dataSrc != null && this.dataSrc.isBlocGrid()) {
			this.dataSrc.forceChange();
		} else {

		}
	},
	getAdapiObservableId: function() {
		var fullId = CAdapiEntity.prototype.getAdapiObservableId.call(this);
		fullId += "-L" + (this.zeroBaseLineIdx + 1);
		return fullId;
	},
	getAdxId: function() {
		var wSB = "";
		wSB += this.getDataSrcAdxId();
		wSB += '0';
		wSB += ',';
		wSB += this.zeroBaseLineIdx + 1;
		return wSB;
	},

	// Retourne l'AdxId de la datasource "mere"
	getDataSrcAdxId: function() {
		return this.dataSrc == null ? null : this.dataSrc.getAdxId();
	},
	getListEntityDifferentValue: function (metadata) {
		var map = {};
		var value = "";
		var colVal = "";
		var i = 0;
		for (var item in this.vars) {
			if (i != 0) {
				var colVar = this.dataSrc.entrySup != null ? this.dataSrc.entrySup.vars[i] : null;
				var valueItem = "";
				var stamp = -1;
				var lineStamp = -1;
				var colStamp = -1;
				switch (metadata) {
				case STY:
					valueItem = item.style; // value cell
					value = this.style; // value line
					if (colVar != null) {
						colVal = colVar.style; // value column
						colStamp = colVar.lastStampModSty;
					}
					stamp = item.lastStampModSty;
					lineStamp = this.lastStampModSty;
					break;
				case STT:
					valueItem = item.state.toString();
					value = this.state.toString();
					stamp = item.lastStampModState;
					lineStamp = this.lastStampModState;
					if (colVar != null) {
						colStamp = colVar.lastStampModState;
						colVal = colVar.state.toString(); // value column
					}
					break;
				case TIT:
					valueItem = item.title;
					value = this.title;
					stamp = item.lastStampModTit;
					lineStamp = this.lastStampModTit;
					if (colVar != null) {
						colStamp = colVar.lastStampModTit;
						colVal = colVar.title; // value column
					}
					break;
				case FMT:
					if (item.format != null) {
						valueItem = item.format.string;
						if (this.format != null) {
							value = this.format.string;
						}
						if (colVar != null) {
							if (colVar.format != null) {
								colVal = colVar.format.string; // value column
							}
							colStamp = colVar.lastStampModFmt;
						}
						stamp = item.lastStampModFmt;
						lineStamp = this.lastStampModFmt;
					}
					break;
				}
				if (stamp != -1) {
					if (lineStamp > colStamp) { // la ligne est plus recente
						if (valueItem != null && !valueItem.equals(value) && stamp > lineStamp) {
							map[stamp] = item;
						}
					} else {
						if (valueItem != null && !valueItem.equals(colVal) && stamp > colStamp) {
							map[stamp] = item;
						}
					}
				}
			}
			i++;
		}
		return map;
	},
	getListEntityOlderThan: function(metaData, timstamp, olderthan) {
		var listAdapiEntity = {};
		for (var v in this.vars) {
			var hasValue = false;
			var stamp = -1;
			switch (metaData) {
			case FMT:
				stamp = this.
				v.lastStampModFmt;
				hasValue = this.
				v.format != null;
				break;
			case STT:
				stamp = this.
				v.lastStampModState;
				hasValue = stamp != -1;
				break;
			case STY:
				stamp = this.
				v.lastStampModSty;
				hasValue = this.
				v.style != null && this.
				v.style.length != 0;
				break;
			case TIT:
				stamp = this.
				v.lastStampModTit;
				hasValue = this.
				v.title != null && this.
				v.title.length != 0;
				break;
			}
			if (olderthan) {
				if (stamp != -1) {
					if (stamp < timstamp && hasValue) {
						listAdapiEntity[stamp] = this.v;
					}
				}
			} else {
				if (stamp != -1) {
					if (stamp >= timstamp && hasValue) {
						listAdapiEntity[stamp] = this.v;
					}
				}
			}
		}
		return listAdapiEntity;
	},
	getVar: function(aIndex) {
		var wVar = null;
		if (aIndex >= 0 && aIndex < this.vars.length) {
			wVar = this.vars[aIndex];
		}
		return wVar;
	},
	initVars: function(nbVar) {
		this.vars = new CAdapiVariable[nbVar];
	},
	isModiefied: function() {
		return this.modified;
	},
	notifyObservers: function() {
		CAdapiEntity.prototype.notifyObservers.call(this);
	},
	razModification: function() {
		this.modified = false;
		this.comboDchModif = false;
		for (var item in this.vars) {
			item.razModification();
		}
		CAdapiEntity.prototype.razModification.call(this);
	}

	/**
	 * GLUTE : gestion des formats dans les colonnes des tableaux juste apres sa
	 * construction, on associe a la ligne une ligne "mere". (voir clonage dans
	 * la methode "insertServerLines" de "CAdapiDataSrc") Note: sert a la
	 * propagation du format courant a chaque modification de valeur
	 */
	,
	setFormaterEntity: function(aLineOfFormater) {
		var vars = this.vars;
		for (var i = 0; i < vars.length; i++) {
			vars[i].setColumnFormater(aLineOfFormater.getVar(i));
		}
	},
	setVar: function(aIndex, v) {
		if (aIndex >= 0 && aIndex < this.vars.length) {
			this.vars[aIndex] = v;
		}
	},
	setZeroBaseIdx: function(zeroBaseIdx) {
		this.zeroBaseLineIdx = zeroBaseIdx;
	},
	toJson: function() {
		var nbCells = this.vars.length;
		// On ne transmet pas le N° de ligne
		if (nbCells <= 1) {
			return null;
		}
		var object = {};
		// line number - from 1
		for (j = 1; j < nbCells; j++) {
			var v = getVar(j);
			if (v.hasServerValueModification()) {
				// Styles separes des data
				object[v.getJsonKey()] = v.getDisplayValue();
			}
		}
		if (object.length == 0) {
			// Null si aucune variable
			return null;
		} else {
			// used only by fusion client for update mvts
			object.$uuid = this.zeroBaseLineIdx;
		}
		return object;
	},
	traverseAll: function(aTraverser) {
		var wMax = this.vars.length;
		var wVariable;
		var wI = 0;
		while (wI < wMax) {
			wVariable = this.vars[wI];

			if (aTraverser.doWhenTraverse(wVariable, wI) == true) {
				return true;
			}

			wI++;
		}
		return false;
	},
	traverseChilds: function(aTraverser) {
		var wTraversingState = false;
		var wX3Variable;
		var wMax = this.vars.length;
		var wI = 0;
		while (wI < wMax) {
			wX3Variable = this.vars[wI];
			if (wX3Variable == null) {
				wTraversingState = true;
			}
			if (wTraversingState != true) {
				wTraversingState = aTraverser.doWhenTraverse(wX3Variable, wI);
			}
			if (wTraversingState == true) {
				return wTraversingState;
			}
			wI++;
		}
		return wTraversingState;
	},
	traverseSettable: function(aStructIst, aAdapiSetter) {
		/*
		 * 15w_017 - Fiche 46222 - Gestion des colonnes de tableau invisibles Si
		 * la porte est un champ ou une colonne
		 */
		if (aStructIst.isFieldIst() || aStructIst.isAllLinesOfColumnIst()) {
			var wI = aStructIst.fieldZeroBase;

			if (wI < 0 || wI >= this.vars.length) {
				var wMess = this.adapiClient.adapiResources.getMessage(CAdapiResources.KEYMESS_ERROR_VAR_UNKNOWN, wI.toString(), this.vars.length.toString(), this.getAdxId());
				//wMess = CStringFacilities.sprintf(wMess, wI.toString(), this.vars.length.toString(), this.getAdxId());
				aAdapiSetter.setLogicalErrMess(wMess);
				return false;
			}
			var wVariable = this.vars[wI];
			return aAdapiSetter.setAdapiModifiable(aStructIst, wVariable);
		}
		/*
		 * Si la porte l'ensemble des lignes
		 */
		else if (aStructIst.isAllLinesOfBlocIst()) {
			return traverseSettableFields(aStructIst, aAdapiSetter);
		}
		/*
		 * Sinon la porte est la ligne
		 */
		else if (aStructIst.isLineIst()) {
			var wContinue = aAdapiSetter.setAdapiModifiable(aStructIst, this);
			// si c'est un changement d'etat : application sur toutes les champs
			if (wContinue && aAdapiSetter instanceof CAdapiRequest.CServerStateSetter) {
				wContinue = traverseSettableFields(aStructIst, aAdapiSetter);
			}
			return wContinue;
		} else {
			var wMess = getRsrcMess(CAdapiResources.KEYMESS_ERROR_TRAVERSE_SETTABLE);
			wMess = CStringFacilities.sprintf(wMess, aStructIst.alphanumCodage, this.getAdxId(), CStringFacilities.getClasseName(aAdapiSetter.class));
			aAdapiSetter.setLogicalErrMess(wMess);
			return false;
		}
	},
	traverseSettableFields: function(aStructIst, aAdapiSetter) {
		var wContinue = true;
		var wI = 0;
		var wMax = this.vars.length;
		var wVariable;

		while (wI < wMax && wContinue) {
			wVariable = this.vars[wI];

			wContinue = aAdapiSetter.setAdapiModifiable(aStructIst, wVariable);

			wI++;
		}
		return wContinue;
	}

});