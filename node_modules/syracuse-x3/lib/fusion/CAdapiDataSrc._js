"use strict"; var helpers = require('syracuse-core/lib/helpers');

	var AdapiLineMove = helpers.defineClass(function() {}, null, {
		private static int ACT_INS = 1;
		private static int ACT_DEL = 0;
		private static int IDX_ACT = 0;
		private static int IDX_IDX = 1;
		private static int IDX_NBLINE = 2;
		private ArrayList<int[]> this.mvts = new ArrayList<int[]>();
		private boolean this.removeAll = false;
		private boolean this.lefList = false;

		public AdapiLineMove(lefList) {
			this.lefList = lefList;
			reset();
		}, addDelete: function(nbLines, idx) {
			// Idx Ok
			this.mvts.add(new int[] { ACT_DEL, idx, nbLines });
		}

		// $mvt[i][0] intege Operation code. 0 : delete - 1 : insert
		// $mvt[i][1] integer The one-based location in the array from which to
		// start apply operation
		// $mvt[i][2] string The number of lines involved in the operation
		, addInsert: function(nbLines, idx) {
			if (this.lefList && !this.mvts.isEmpty()) {
				// Cumul pour left list
				int[] x = this.mvts.get(0);
				x[IDX_NBLINE] = x[IDX_NBLINE] + 1;
			} else {
				// idx +1 car X3 0 based
				this.mvts.add(new int[] { ACT_INS, idx + 1, nbLines });
			}
		}, removeAllLines: function() {
			this.removeAll = true;
		}, reset: function() {
			this.removeAll = false;
			this.mvts.clear();
		}, toJson: function() {
				var result = new JSONArray();
				if (this.removeAll) {
					// "$mvt": [[0]]
					result.put(new JSONArray().put(ACT_DEL));
				}
				var size = this.mvts.size();
				if (size > 0) {
					if (size == 1) {
						for (int[] e : this.mvts) {
							result.put(new JSONArray(e));
						}
					} else {
						// clone -> prev is momdified
						int[] prev = Arrays.copyOf(this.mvts.get(0),3), cur = null;
						int curAct, prevAct, curIdx, prevIdx, curNb, prevNb;
						boolean cumul;
						for (i = 1; i < size; i++) {
							cumul = false;
							cur = this.mvts.get(i);
							curAct = cur[IDX_ACT];// action current move
							prevAct = prev[IDX_ACT]; // action previous move
							if (curAct == prevAct) {
								curIdx = cur[IDX_IDX];
								prevIdx = prev[IDX_IDX];
								curNb = cur[IDX_NBLINE];
								prevNb = prev[IDX_NBLINE];
								if (curAct == 0 && curIdx == prevIdx || curAct == 1 && curIdx == prevIdx + prevNb) {
									// Mvts:[[1,4,1],[1,5,3],[1,6,2],[1,7,1],[1,8,1]] -> [1,4,8]
									// Mvts:[[0,4,1],[1,4,3],[1,4,2],[1,4,1],[1,4,1]] -> [0,4,8]
									prev[IDX_NBLINE] += curNb;
									cumul = true;
								}
							}
							if (!cumul) {
								result.put(new JSONArray(prev));
								// clone -> prev is momdified
								prev = Arrays.copyOf(cur,3);
							}
						}
						result.put(new JSONArray(prev));
					}
				}
				return result;
		}, toJsonX3Mvts: function() {
				var result = new JSONObject();
				var arr = new JSONArray();
				for (int[] e : this.mvts) {
					arr.put(new JSONArray(e));
				}
				result.put("mvts", arr);
				result.put("removeAll", this.removeAll);
				return result;
		}
	}

var CAdapiDataSrc = helpers.defineClass(function() {}, CAdapiEntity, {


	private AdapiLineMove listEventLine;
	private static final int AFTB_END = 1;
	private static final int AFTB_START_COMPLEMENT = 3;
	private static final int AFTB_START_COMPLETE = 0;
	private static final int AFTB_START_PARTIAL = 2;
	private static final String LABEL_AFTB_END = "AFTB_END";
	private static final String LABEL_AFTB_START_COMPLEMENT = "_AFTB_START_COMPLEMENT";
	private static final String LABEL_AFTB_START_COMPLETE = "AFTB_START_COMPLETE";
	private static final String LABEL_AFTB_START_PARTIAL = "AFTB_START_PARTIAL";
	private static final String LIB_EXCEPTION = "Exception";
	public final static char TYPE_LEFTLIST = 'Q';
	public final static char TYPE_SCREEN = 'E';

	public static String aftbTypToString(aAftbTyp) {
		switch (aAftbTyp) {
		case AFTB_START_COMPLETE:
			return LABEL_AFTB_START_COMPLETE;
		case AFTB_END:
			return LABEL_AFTB_END;
		case AFTB_START_PARTIAL:
			return LABEL_AFTB_START_PARTIAL;
		case AFTB_START_COMPLEMENT:
			return LABEL_AFTB_START_COMPLEMENT;
		default:
			return "aftb unknown : " + aAftbTyp;
		}
	}

	private CAdapiScreen this.adapiScreen;
	// indicateur de chargement complementaire. positionne lorsqu'un noeud NDAFTB de type "3"
	private boolean this.complementaryLoading = false;
	private int this.dataSrcType = CAdapiDataSrc.TYPE_SCREEN;
	// Dimension de la datasource ex:250 pour un tableau
	private int this.dim;
	// Record "suplementaire" pour gerer la ligne a cloner
	private CAdapiDataSrcLine this.entrySup = null;
	// Vecteur des lignes de la DataSource
	private Vector<CAdapiDataSrcLine> this.lines;
	// Nombre de colonne de la datasource
	private int this.nbColumns;
	// Nombre de lignes du chargement partiel. positionne lors de la reception d'un noeud NDAFTB de type "2"
	private int this.nbPartialLines = 0;
	// indicateur de chargement partiel. positionne lorsqu'un noeud NDAFTB de type "2"
	private boolean this.partialLoading = false;
	private CAdapiStackedWindow this.stackedWindow;
	// Id de la variable de bas de page
	private String this.varBasPage = null;

	protected CAdapiDataSrc(aAdapiRequester, aAdapiScreen, aEntityIndexBaseOne, aDataSourceID, aDim, aNbField, aVarBasPage) {
		this(aAdapiRequester, aAdapiScreen, aEntityIndexBaseOne, aDataSourceID, aDim, aNbField, aVarBasPage, CAdapiDataSrc.TYPE_SCREEN);
	}

	protected CAdapiDataSrc(aAdapiRequester, aAdapiScreen, aEntityIndexBaseOne, aDataSourceID, aDim, aNbField, aVarBasPage, dataSrcType) {
		TODO_SUPER(aAdapiRequester.getAdapiClient(), aDataSourceID, aEntityIndexBaseOne, EntityType.BLOC);
		this.dataSrcType = dataSrcType;
		listEventLine = new AdapiLineMove(dataSrcType == CAdapiDataSrc.TYPE_LEFTLIST);
		this.lines = new Vector<CAdapiDataSrcLine>();
		this.stackedWindow = aAdapiRequester;
		this.adapiScreen = aAdapiScreen;
		this.dim = aDim < 1 ? 1 : aDim;
		this.nbColumns = aNbField;
		this.varBasPage = aVarBasPage;
		// En dernier
		setTypeJsonNode(ETypeJsonNode.ENTITY);
	}, _traceLines: function(){
		boolean trace=false;
		if( trace){
			Utils.toConsole("\tSize["+getId()+"]=" + size());
			for (var l inthis.lines){
				Utils.toConsole("\t" + l.getZeroBaseLineIdx() + " - " + l.getDataSrcAdxId());
			}
		}
	}, appendFirstBlankLine: function(srcLine) {
		this.lines.addElement(srcLine);
		srcLine.setZeroBaseIdx(0);
		fusionMvtsInsert(1, 0);
	}, appendLeftListLine: function(l) {
		this.lines.add(l);
		if (l != null && l.isFlatLeftList()) {
			fusionMvtsInsert(1, 0);// index 0 base and not 1
		}
	}

	private CAdapiVariable[] blocFicheGetChilds() {
		var l = getFirstLine();
		if (l == null || l.getVars() == null) {
			throw new RuntimeException("List boloc - Unexpected null first line");
		}
		return l.getVars();
	}, buildMessErrorTraverse: function(aStructIst, aAdapiSetter, aKeyOfMessSuffix) {
		var wMess = getAdapiClient().getAdapiResources().getMessage(CAdapiResources.KEYMESS_ERROR_TRAVERSE_SETTABLE);
		wMess = CStringFacilities.sprintf(wMess, aStructIst.getAlphanumCodage(), getAdxId(), CStringFacilities.getClasseName(aAdapiSetter.getClass()));
		return wMess + getAdapiClient().getAdapiResources().getMessage(aKeyOfMessSuffix);
	}, fusionMvtsDelete: function(nbLines, idx) {
		// Utils.toConsole(this.getId() + " - Mvt delete - nbLines[" + nbLines + "] - idx[" + idx + "]");
		listEventLine.addDelete(nbLines, idx);
		_traceLines();
		// Notifie datasrc to genarate JSON
		this.forceChange();
	}, fusionMvtsInsert: function(nbLines, idx) {
		// Utils.toConsole(this.getId() + " - Mvt insert - nbLines[" + nbLines + "] - idx[" + idx + "]");
		listEventLine.addInsert(nbLines, idx);
		_traceLines();
	}, fusionMvtsRemoveAll: function() {
		// Utils.toConsole(this.getId() + " - Mvt RemoveAll");
		listEventLine.removeAllLines();
		_traceLines();
		// Notifie datasrc to genarate JSON
		this.forceChange();
	}, fusionMvtsReset: function() {
		// Utils.toConsole(this.getId() + " - Mvt Reset");
		listEventLine.reset();
	}, getAdxId: function() {
		return this.adapiScreen==null?null:new StringBuilder().append(this.adapiScreen.getAdxId()).append(',').append(getEntityIndexBaseOneInAlphanumFormat()).toString();
	}, getDim: function() {
		return this.dim;
	}, getEntrySup: function() {
		return this.entrySup;
	}, getFirstLine: function() {
		return this.lines.size() > 0 ? this.lines.firstElement() : null;

	}, getJsonMetadata: function(Map<Long, CAdapiEntity> map, metadata) {
		Long[] keys = map.keySet().toArray(new Long[map.keySet().size()]);
		Arrays.sort(keys);
		var meta = new JSONArray();
		var itemJs = null;
		for (key : keys) {
			itemJs = new JSONArray();
			var item = map.get(key);
			var obsId = item.getAdapiObservableId();
			if (item instanceof CAdapiDataSrcLine) {
				obsId = getAdapiObservableId();
			}
			itemJs.put(obsId); // id instance
			if (item instanceof CAdapiVariable) {
				if (((CAdapiVariable) item).getSrcLine().equals(this.entrySup)) {
					// it's a colomn
					itemJs.put(0);
				} else {
					// it's a cell  retrinve line number
					var lineNumber = -1;
					if (((CAdapiVariable) item).getSrcLine() instanceof CAdapiDataSrcLine) {
						lineNumber = ((CAdapiVariable) item).getSrcLine().getOneBaseLineIdx();
					}
					itemJs.put(lineNumber);
				}
			} else if (item instanceof CAdapiDataSrcLine) {
				// it's a line
				itemJs.put(((CAdapiDataSrcLine) item).getOneBaseLineIdx());
			}
			// indice colomn, cellule
			switch (metadata) {
			case STY:
				itemJs.put(item.getStyle()); // style
				break;
			case STT:
				itemJs.put(item.getState()); // style
				break;
			case FMT:
				if (item.getFormat() != null) {
					itemJs.put(item.getFormat().getString()); // style

				}
				break;
			case TIT:
				if (item.getTitle() != null) {
					itemJs.put(item.getTitle()); // style
				}
				break;
			}
			meta.put(itemJs);
		}
		return meta;
	}, getLastLine: function() {
		return this.lines.size() > 0 ? this.lines.lastElement() : null;

	}, getLine: function(idx) {
		return this.lines.get(idx);
	}, getNbColumns: function() {
		return this.nbColumns;
	}, getNbPartialLines: function() {
		return this.nbPartialLines;
	}

	//  Retourne la fenetre mere de la Datasource
	CAdapiStackedWindow getStackedWindow() {
		return this.stackedWindow;
	}

	// return true if this data source admit column
	, hasColumn: function() {
		return hasEntrySup();
	}

	// Retourne vrai si la dimension est depassee !
	, hasDimOverFlow: function() {
		return size() > getDim();
	}

	// return true if EntrySup is not null ( admit entry
	, hasEntrySup: function() {
		return this.entrySup != null;
	}

	//retourne si un variable "baspag" est associee a la DataSource
	, hasVarBasPage: function() {
		return this.varBasPage != null && this.varBasPage.length() > 0;
	}, isBlocFiche: function() {
		return this.dataSrcType == CAdapiDataSrc.TYPE_SCREEN && getDim() == 1 && !hasVarBasPage();
	}, isBlocGrid: function() {
		return isLeftList() || isBlocTableau();
	}, isBlocTableau: function() {
		return this.dataSrcType == CAdapiDataSrc.TYPE_SCREEN && hasVarBasPage();// this.dim>1;
	}, isLeftList: function() {
		return this.dataSrcType == CAdapiDataSrc.TYPE_LEFTLIST;
	}, manageMetadata: function(Map<Long, CAdapiEntity> map, line, metadata, lastLine) {
		// check if we need to add change metadata about
		var stampLine = -1;
		var hasValue = false;
		switch (metadata) {
		case STY:
			stampLine = line.getLastStampModSty();
			hasValue = line.getStyle() != null;
			break;
		case STT:
			stampLine = line.getLastStampModState();
			hasValue = stampLine != -1;
			break;
		case FMT:
			stampLine = line.getLastStampModFmt();
			hasValue = line.getFormat() != null;
			break;
		case TIT:
			stampLine = line.getLastStampModTit();
			hasValue = line.getTitle() != null;
			break;
		}

		// check if a colomn has apply a style before
		if (this.entrySup != null) {
			Map<Long, CAdapiEntity> colEntity = this.entrySup.getListEntityOlderThan(metadata, stampLine, true);
			map.putAll(colEntity);
		}
		if (hasValue && stampLine != -1) {
			map.put(stampLine, line);

		}
		// check if an item of the line has a different value
		// for metadata and if the colomn has not the same status we add him
		// analyse list of variable on current line even no change has been done
		// on current line
		map.putAll(line.getListEntityDifferentValue(metadata));

		if (lastLine) {
			// generate style for all column that are younger that the last line
			if (this.entrySup != null) {
				Map<Long, CAdapiEntity> colEntity = this.entrySup.getListEntityOlderThan(metadata, stampLine, false);
				map.putAll(colEntity);
			}
			map.putAll(line.getListEntityDifferentValue(metadata));
		}

	}, razAffState: function() {
		this.partialLoading = false;
		this.complementaryLoading = false;
	}, razModification: function() {
		razAffState();
		for (line : this.lines) {
			line.razModification();
		}
		if (this.entrySup != null) {
			this.entrySup.razModification();
		}
		// Reset des modification des mouvements fusion en fin de request client
		fusionMvtsReset();
		TODO_SUPER.razModification();
	}

	// insert "apres" aTargetLine
	, serverInsertLines: function(zeroBasedIdx, nbLines) {
		for (i = 0; i < nbLines; i++) {
			// CAdapiDataSrcLine constructor Notify oberver that a new line has been created
			var srcLine = (CAdapiDataSrcLine) getEntrySup().clone();
			// GLUTE : gestion des formats dans les colonnes des tableaux pour associer chacune des variables de la nouvelle ligne a sa correspondante dans la ligne "this.entrySup"
			// Note: sert a la propagation du format courant a chaque modification de valeur
			srcLine.setFormaterEntity(getEntrySup());
			this.lines.add(zeroBasedIdx + i, srcLine);
		}
		updateIdx(zeroBasedIdx);
		fusionMvtsInsert(nbLines, zeroBasedIdx);
	}

	// Supprime toutes les lignes de la dataSource
	, serverRemoveAllLines: function() {
		this.lines.removeAllElements();
		fusionMvtsRemoveAll();

	}, serverRemoveLines: function(startX3Idx, nbLines) {
		var stop = startX3Idx - 1;
		var start = Math.min(stop + nbLines, size());
		for (i = start - 1; i >= stop; i--) {
			CAdapiDataSrcLine l=this.lines.remove(i);
			if (l!=null) {
				l.dispose();
			}
		}
		fusionMvtsDelete(nbLines, startX3Idx);
		updateIdx(stop);
	}, setAffState: function(aAftbTyp, aNbLines) {
		if (aAftbTyp != AFTB_END) {
			// si chargement complementaire :
			if (aAftbTyp == AFTB_START_COMPLEMENT) {
				/*
				 * positionnement flag si on n'etait pas en chargement partiel !
				 * si on etait deja en chjargement partiel, cela devient un
				 * chargement total, donc on laisse this.complementaryLoading a
				 * false mais on force le flag d'envoi d'image
				 * 
				 * @version 141_p05
				 */
				this.complementaryLoading = !this.partialLoading;
			}
			/*
			 * si chargement partiel note : si on etait en chargement partiel,
			 * le flag est remis a faux lorsque l'on receois le complement dans
			 * le meme flot!
			 */
			this.partialLoading = aAftbTyp == AFTB_START_PARTIAL;
			if (this.partialLoading) {
				this.nbPartialLines = aNbLines;
			}
		}
	}

	//  Met en place une Entry suplementaire pour les datasources qui ont une
	, setEntrySup: function(aDataSrcEntry) {
		this.entrySup = aDataSrcEntry;
	}, setServerStyle: function(aStyle, applyOn) {
		if (StyleApply.CHILDS == applyOn && isBlocFiche()) {
			for (v : blocFicheGetChilds()) {
				v.setServerStyle(aStyle, StyleApply.ENTITY);
			}
		} else {
			TODO_SUPER.setServerStyle(aStyle, applyOn);
		}
	}, size: function() {
		return this.lines.size();
	}, toJson: function() {
			var object = new JSONObject();
			if (isBlocGrid()) {
				// construct metadata json object
				Map<Long, CAdapiEntity> mapSty = new HashMap<Long, CAdapiEntity>();
				Map<Long, CAdapiEntity> mapFmt = new HashMap<Long, CAdapiEntity>();
				Map<Long, CAdapiEntity> mapStt = new HashMap<Long, CAdapiEntity>();
				Map<Long, CAdapiEntity> mapTit = new HashMap<Long, CAdapiEntity>();
				var mapDch = null;
				// $rcd
				var records = new JSONArray();
				for (i = 0; i < this.lines.size(); i++) {
					var line = this.lines.get(i);
					if (line != null && !line.isDisposed()) {
						toJsonAddRCD(line, records);
						// treatement of metadata style - !! a optimiser
						var lastLine = i == this.lines.size() - 1;
						manageMetadata(mapSty, line, FusionMetaData.STY, lastLine);
						manageMetadata(mapStt, line, FusionMetaData.STT, lastLine);
						manageMetadata(mapFmt, line, FusionMetaData.FMT, lastLine);
						manageMetadata(mapTit, line, FusionMetaData.TIT, lastLine);
						// DCH - cell by cell
						if (line.comboDchModifhas()){
							if (mapDch==null){
								mapDch=new JSONArray();
							}
							line.comboDchAddJSON(mapDch);
						}
					}
				}
				if (!Utils.emptyJson(records)) {
					object.put(JSON_RCD, records);// add record table that represent
				}
				object.put(JSON_MVT, listEventLine.toJson());
				object.put("X3Mvts", listEventLine.toJsonX3Mvts());
				// create metadata
				var metadata = new JSONObject();
				if (mapDch!=null) {
					metadata.put(JSON_DCH, mapDch);
				}
				var sty = getJsonMetadata(mapSty, FusionMetaData.STY);
				if (!Utils.emptyJson(sty)) {
					metadata.put(JSON_STY, sty);
				}
				var fmt = getJsonMetadata(mapFmt, FusionMetaData.FMT);
				if (!Utils.emptyJson(fmt)) {
					metadata.put(JSON_FMT, fmt);
				}
				var stt = getJsonMetadata(mapStt, FusionMetaData.STT);
				if (!Utils.emptyJson(stt)) {
					metadata.put(JSON_STT, stt);
				}
				var tit = getJsonMetadata(mapTit, FusionMetaData.TIT);
				if (!Utils.emptyJson(tit)) {
					metadata.put(JSON_TIT, tit);
				}
				if (!Utils.emptyJson(metadata)) {
					object.put(JSON_META, metadata);
				}
			}
			// Modif DataSrc
			if (hasModifTitle()) {
				object.put(JSON_TIT, getTitle());
				if (getTitleSty() != null) {
					object.put(JSON_STYTIT, getTitleSty());
				}
			}
			if (hasModifStyle()) {
				object.put(JSON_STY, getStyle());
			}
			return object;
	}

	// Pour surcharge par liste recursive
	, toJsonAddRCD: function(line, record) {
		var lineJSon = line.toJson();
		if (lineJSon != null) {
			record.put(lineJSon);
		}
		return lineJSon;
	}, traverseAll: function(aTraverser) {
		var wMax = size();
		var wDataSrcLine;
		var wI = 0;
		while (wI < wMax) {
			wDataSrcLine = getLine(wI);
			if (aTraverser.doWhenTraverse(wDataSrcLine, wI) == ITraverser.STOP_TRAVERSING) {
				return ITraverser.STOP_TRAVERSING;
			}
			if (wDataSrcLine.traverseAll(aTraverser) == ITraverser.STOP_TRAVERSING) {
				return ITraverser.STOP_TRAVERSING;
			}
			wI++;
		}
		return ITraverser.CONTINUE_TRAVERSING;
	}, traverseChilds: function(aTraverser) {
		var wTraversingState = ITraverser.CONTINUE_TRAVERSING;
		var wMax = this.lines.size();
		if (hasEntrySup()) {
			wTraversingState = aTraverser.doWhenTraverse(this.entrySup, -1);
			if (wTraversingState == ITraverser.STOP_TRAVERSING) {
				return ITraverser.STOP_TRAVERSING;
			}
		}
		var wI = 0;
		if (this.partialLoading) {
			wMax = Math.min(this.nbPartialLines, wMax);
		} else if (this.complementaryLoading) {
			wI = this.nbPartialLines;
		}
		while (wI < wMax) {
			wTraversingState = aTraverser.doWhenTraverse(getLine(wI), wI);
			if (wTraversingState == ITraverser.STOP_TRAVERSING) {
				return ITraverser.STOP_TRAVERSING;
			}
			wI++;
		}
		return wTraversingState;
	}

	/**
	 * 14w_005 - bug 30654 - mise en place mode "envoi pour rebind"
	 * <p>
	 * Propagation du changement d'etat sur toutes les lignes existante de la
	 * datasource
	 * 
	 * 14w_006 - Bug 31739 - gestion tableau
	 * <p>
	 * Application des regles de propagations des changements d'etat
	 * fonctionnant dans le client X3
	 * <li>si sAdxidTarget.nAdxid est de type GRID et sAdxidTarget.nNumLine ==
	 * -1 : on applique le cState a toutes les cellules du tableau
	 * <li>si sAdxidTarget.nAdxid est de type GRID et sAdxidTarget.nNumLine > 0
	 * : on applique le cState a toutes les cellules de la ligne
	 * <li>si sAdxidTarget.nAdxid correspond a une colonne et
	 * sAdxidTarget.nNumLine == -1 : on applique le cState a toutes les cellules
	 * de la colonne
	 * <li>si sAdxidTarget.nAdxid correspond a une colonne et
	 * sAdxidTarget.nNumLine > 0 : on applique le cState a la cellule
	 * colonne/ligne
	 * 
	 * @param aStructIst
	 * @param aAdapiSetter
	 * @return
	 */
	boolean traverseSettable(aStructIst, aAdapiSetter) {
		try {
			// Si la porte est une colonne ou toutes les lignes d'une colonne
			// ATTENTION : il
			// faut tester "this.dim>1 && isColumnIst()" avant "isFieldIst()" car si
			// this.dim>1 on a
			// egalite entre "isColumnIst()" et "isFieldIst()"
			// 16w_115 - gestion des tableau de dimension 1 // on execute
			// traverseSettable si on admet des colonnes
			if (hasColumn() && aStructIst.isColumnIst() || aStructIst.isAllLinesOfColumnIst()) {
				// Application sur la ligne suplementaire EntrySup
				var wContinue = this.entrySup.traverseSettable(aStructIst, aAdapiSetter);

				// si c'est un changement d'etat: application sur toutes les
				// lignes (pour une colonne)
				if (wContinue && aAdapiSetter instanceof CAdapiRequest.CServerStateSetter) {
					wContinue = traverseSettableLines(aStructIst, aAdapiSetter);
				}
				return wContinue;
			}
			// Si la porte est le champ ou la ligne: application sur l'entite
			// inferieure designee
			else if (aStructIst.isFieldIst() || aStructIst.isLineIst()) {
				var wI = getDim() > 1 ? aStructIst.getIdxZeroBase() : 0;
				// si numero de ligne incorrect
				if (wI < 0 || wI >= this.lines.size()) {
					var wMess = getAdapiClient().getAdapiResources().getMessage(CAdapiResources.KEYMESS_ERROR_LINE_UNKNOWN);

					wMess = CStringFacilities.sprintf(wMess, String.valueOf(wI), String.valueOf(this.lines.size()), getAdxId());
					aAdapiSetter.setLogicalErrMess(wMess);
					return false;
				}
				var wDataSrcLine = getLine(wI);
				return wDataSrcLine == null ? false : wDataSrcLine.traverseSettable(aStructIst, aAdapiSetter);
			}
			// Si la porte est le bloc ou toutes les lignes du bloc :
			// application sur le bloc.
			else if (aStructIst.isBlocIst() || aStructIst.isAllLinesOfBlocIst()) {
				// Application sur le bloc
				var wContinue = aAdapiSetter.setAdapiModifiable(aStructIst, this);
				// si c'est un changement d'etat :
				if (wContinue && aAdapiSetter instanceof CAdapiRequest.CServerStateSetter) {
					// 16w_104 - Fiche 51885 - RH V5 : zone non saisissable en
					// Web
					// Application sur la ligne suplementaire EntrySup
					wContinue = this.entrySup.traverseSettable(aStructIst, aAdapiSetter);
					if (wContinue) {
						// application sur toutes les lignes (pour toutesles
						// colonnes)
						wContinue = traverseSettableLines(aStructIst, aAdapiSetter);
					}
				}
				return wContinue;
			} else {
				aAdapiSetter.setLogicalErrMess(buildMessErrorTraverse(aStructIst, aAdapiSetter, CAdapiResources.KEYMESS_ERROR_TRAVERSE_SETTABLE_CASE));
				return true;
			}
		} catch (e) {
			var wMess = buildMessErrorTraverse(aStructIst, aAdapiSetter, CAdapiResources.KEYMESS_ERROR_TRAVERSE_SETTABLE_EXCEPT);
			var wTB = new CTraceBuffer(256);
			wTB.append(wMess);
			wTB.append(' ');
			wTB.appendDescr(LIB_EXCEPTION, e);
			aAdapiSetter.setLogicalErrMess(wTB.toString());
			throw new RuntimeException(wMess,e);
		}
	}, traverseSettableLines: function(aStructIst, aAdapiSetter) {
		var wContinue = true;
		var wI = 0;
		var wMax = size();
		var wDataSrcLine;
		while (wI < wMax && wContinue) {
			wDataSrcLine = getLine(wI);
			wContinue = wDataSrcLine.traverseSettable(aStructIst, aAdapiSetter);
			wI++;
		}
		return wContinue;
	}, updateIdx: function(startIdx){
		for (i = startIdx,l=size(); i <l; i++) {
			this.lines.get(i).setZeroBaseIdx(i);
		}
	}
}
