"use strict";
var helpers = require('syracuse-core/lib/helpers');
var CAdapiEntity = function() {};

var CAdapiVariable = helpers.defineClass(function(srcLine, aEntityIndexBaseOne, aVariableName, aVariableId, aDataType, aFormat, aEntityState) {
	TODO_SUPER(srcLine.getAdapiClient(), aVariableId, aEntityIndexBaseOne, EntityType.FIELD);
	this.srcLine = null;
	this.browserValue = null;
	this.decimal = 0;
	this.mustBeFormated = false;
	this.withDecimal = false;

	this.name = aVariableName;
	setSrcLine(srcLine);
	setStateFromDescr(aEntityState);
	this.dataType = aDataType;
	this.resuType = CStructResu.tdoNumToResuTyp(getTracer(), this.dataType);
	setFormat(aFormat);
	// En dernier
	setTypeJsonNode(ETypeJsonNode.ENTITY);
}, CAdapiEntity, {
	acceptEditFormat: function() {
		return true;
	},
	buildMessFormterExcetion: function(aMessKey, aWhatFormatKey, aValue, e) {
		return this.buildMessFormterExcetion(aMessKey, aWhatFormatKey, aValue, CException.eClassAndMessInString(e));
	},
	/* TODO overload
	buildMessFormterExcetion: function(aMessKey, aWhatFormatKey, aValue, aErrDescr) {
		return CStringFacilities.sprintf(getRsrcMess(aMessKey), getRsrcMess(aWhatFormatKey), getId(), aErrDescr);
	},*/
	callFormater: function(aValue) {
		try {
			if (getAdapiClient().hasValidFormater() && hasValidFormat()) {
				// "formater" ET format valide
				return getAdapiClient().getFormater().formatField(getFormat(), aValue, true);
			} else if (aValue != null && aValue.length() > 0) {
				// pas de "formater" ou si le format n'est pas valide
				return formatHimself(aValue);
			}
		} catch (e) {
			getAdapiClient().addLogicalErrorMess(this, "callFormater", getAdxId(), buildMessFormterExcetion(CAdapiResources.KEYMESS_ERROR_FORMAT_EXCEPTION, CAdapiResources.KEYMESS_FORMAT_RTOS, aValue, e));
		}
		return aValue; // retourne la donnee brute
	},
	callUnFormater: function(aValue) {
		if (getAdapiClient().hasValidFormater() && hasValidFormat()) {
			try {
				var fmt = getAdapiClient().getFormater();
				// Format la valeur - 1/2/3 -> 01/02/03
				try {
					aValue = fmt.formatField(getFormat(), aValue, false);
				} catch (e) {
					// aValue peut etre une valeur formatee au format X3 --> On
					// tente le unformate
				}
				// Déformate - 01/02/03 -> 20030201
				return fmt.unformatField(getFormat(), aValue, true);
			} catch (e) {
				throw CAdapiException.newFmtException(getAdapiClient(), e, buildMessFormterExcetion(CAdapiResources.KEYMESS_ERROR_UNFORMAT_EXCEPTION, CAdapiResources.KEYMESS_UNFORMAT_STOR, aValue, e));
			}
		}
		// No format
		return unformatHimself(aValue);
	},

	//clone: function();
	cloneValues: function(v) {
		TODO_SUPER.cloneValues(v);
		v.this.browserValue = this.browserValue;
	},
	dispose: function() {
		TODO_SUPER.dispose();
		this.srcLine = null;
		this.browserValue = null;
	},
	forceChange: function() {
		if (this.srcLine != null) {
			var dataSrc = this.srcLine.getDataSrc();
			if (dataSrc.isBlocGrid()) {
				// Sur modification de valeur on notifie le parent seuelemnt si bloc tableau ou liste gauche
				this.srcLine.cellHasBeenModified();
				return;
			}
		}
		TODO_SUPER.forceChange();
	},
	formatEditToDisplay: function(aValue) {
		if (!acceptEditFormat()) {
			return aValue;
		}
		var res;
		var adp = getAdapiClient();
		if (adp.hasValidFormater() && hasValidFormat()) {
			try {
				res = adp.getFormater().inputGetFocusOutValue(getFormat(), aValue, true);
			} catch (e) {
				try {
					// ON essaie pour voir si la valeur saisie est une valeur
					// formatée X3 (Display)
					res = adp.getFormater().unformatField(getFormat(), aValue);
					res = adp.getFormater().formatField(getFormat(), aValue, true, true);
				} catch (e2) {
					throw CAdapiException.newFmtException(adp, e, buildMessFormterExcetion(CAdapiResources.KEYMESS_ERROR_FORMAT_EXCEPTION, CAdapiResources.KEYMESS_FORMAT_ETOS, aValue, e));
				}
			}
		} else {
			return aValue;
		}
		return res;
	}

	// Valeur renvoyée si pas de formateur ou pas de format - Surchargée par
	// type de variable
	,
	formatHimself: function(aValue) {
		return aValue;
	},
	formatX3ToDisplay: function(aData) {
		var x3Value = aData.getValue();
		// formatage uniquement si session interractive
		var wMustCallFormater = true;
		if (!this.mustBeFormated) {
			wMustCallFormater = false;
		}
		if (wMustCallFormater && x3Value == null) {
			wMustCallFormater = false;
		}
		var res;
		if (wMustCallFormater) {
			res = callFormater(x3Value);
		} else {
			res = x3Value;
		}
		return res;
	},
	formatX3ToEdit: function() {
		var val = getServerValResu() != null ? getServerValResu().getValue() : null;
		var res = val;
		if (acceptEditFormat() && this.mustBeFormated && val != null) {
			if (hasValidFormat() && getAdapiClient().hasValidFormater()) {
				try {
					res = getAdapiClient().getFormater().inputGetFocusInValue(getFormat(), val, true);
				} catch (e) {
					getAdapiClient().addLogicalErrorMess(this, "callUnformaterToEdit", getId(), buildMessFormterExcetion(CAdapiResources.KEYMESS_ERROR_UNFORMAT_EXCEPTION, CAdapiResources.KEYMESS_UNFORMAT_STOE, val, e));
				}
			}
		}
		return res;
	},
	getAdxId: function() {
		if (this.srcLine == null) {
			return null;
		}
		var sb = new StringBuilder();
		sb.append(this.srcLine.getDataSrcAdxId()).append(getIdxInBloc()).append(',').append(String.valueOf(this.srcLine.getOneBaseLineIdx()));
		return sb.toString();

	},
	getBrowserValue: function() {
		return this.browserValue;
	},
	getDataType: function() {
		return this.dataType;
	}

	// Retourne la valeur courante suivant le codage ou la conversion lie au
	// type de de donnee
	,
	getDisplayValue: function() {
		var res = getServerValResu() != null ? formatX3ToDisplay(getServerValResu()) : EMPTY;
		// formatX3ToDisplay peut renvoyer null
		return res == null ? EMPTY : res;
	}

	// retoune l'index de la variable dans le bloc en extrayant la partie
	// numerique de l'id qui est de la forme "AH12"
	,
	getIdxInBloc: function() {
		var wIdx = getId();
		var wPos = 0;
		while (!Character.isDigit(wIdx.charAt(wPos))) {
			wPos++;
		}
		return wIdx.substring(wPos);
	},
	getName: function() {
		return this.name;
	},
	getNbDecimals: function() {
		return this.decimal;
	},
	getResuTyp: function() {
		return this.resuType;
	},
	getSrcLine: function() {
		return this.srcLine;
	},
	getValueForJson: function() {
		return getDisplayValue();
	}

	// vrai si une modification de couleur, etat, titre, style ou choix
	// contextuel a ete envoyee par le serveur sur l'entite.
	,
	hasGuiModModifications: function() {
		return hasModifState() || hasModifTitle() || hasModifStyle();
	},
	isWithDecimal: function() {
		return this.withDecimal;
	},
	mustBeFormated: function() {
		return this.mustBeFormated;
	},
	razModification: function() {
		storeBrowserValue(getServerValResu());
		TODO_SUPER.razModification();
	}

	/**
	 * Valorise la variable avec une chaine representant une valeur non
	 * formatee. Cette methode est utilisee pour stocker la valeur saisie par
	 * l'utilisateur lors des envois des actions vers le serveur.
	 */
	,
	setBrowserUnformatedValue: function(aBrowserValue) {
		setServerResu(aBrowserValue);
		storeBrowserValue(aBrowserValue);
	},
	setDecimal: function(aDecimal) {
		this.decimal = aDecimal;
		this.withDecimal = this.decimal > 0 || this.decimal == -1;
	},
	setMustBeFormated: function(aMustBeFormated) {
		this.mustBeFormated = aMustBeFormated;
	},
	setServerFormat: function(aFormat) {
		var wIndferredState = TODO_SUPER.setServerFormat(aFormat);
		setMustBeFormated(hasValidFormat());
		return wIndferredState;
	}

	/**
	 * Modification de la variable e patir d'un noeud "NDCHVL" reeu du serveur.
	 * La valiable est modifiee seulement si le resu est different de la valeur
	 * initiale Apres cette valorisation, la variable est consideree comme
	 * modifiee
	 */
	,
	setServerValue: function(aResu) {

		if (this.browserValue == null || !this.browserValue.equals(aResu)) {
			if (!hasServerValueModification() || !isServerValueEquals(aResu)) {
				TODO_SUPER.setServerValue(aResu);
			} else {
				forceServerValueModification(true);
			}
		} else if (mustBeFormated()) {
			TODO_SUPER.setServerValue(aResu);
			resetServerModified();

		} else if (hasServerValueModification()) {
			TODO_SUPER.setServerValue(this.browserValue);
			resetServerModified();
		}
	},
	setSrcLine: function(srcLine) {
		this.srcLine = srcLine;
	},
	setUnModifiableServerValue: function(aResu) {
		storeBrowserValue(null);
		return TODO_SUPER.setUnModifiableServerValue(aResu);
	},
	storeBrowserValue: function(aBrowserValue) {
		this.browserValue = aBrowserValue;
	},
	toJson: function() {
		if (!hasServerValueModification() && !hasGuiModModifications()) {
			return null;
		}
		var object = new JSONObject();
		if (hasModifState()) {
			object.put(JSON_STT, getState());
		}
		if (hasModifStyle() && getStyle() != null && getStyle().length() != 0) {
			object.put(JSON_STY, getStyle()); // style presentation
		}
		if (hasModifTitle()) {
			object.put(JSON_TIT, getTitle());
			if (getTitleSty() != null) {
				object.put(JSON_STYTIT, getTitleSty());
			}
		}
		if (hasServerValueModification()) {
			var value = getValueForJson();
			if (value != null) {
				object.put(JSON_VAL, value);
			} else {
				object.put(JSON_VAL, "");
			}
		}
		return object;
	},
	unFormatData: function(aValue) {
		return aValue;
	},

	// Valeur renvoyée si pas de formateur ou pas de format - Surchargée par
	// type de variable
	unformatHimself: function(aValue) {
		return aValue;
	}
});