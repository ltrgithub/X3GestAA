"use strict"; var helpers = require('syracuse-core/lib/helpers');

/**
 * 16w_121 - Fiche 71202 thread permettant de manager les differents client afin
 * d'appeler de maniere periodique la methode musthangUp pour que le client
 * puisse se tuer si le hangUp est atteint et que le client Web n'est pas l√†.
 * 
 * @author apisu
 * 
 * NOT USED IN FUSION CLIENT
 * 
 */
var CAdapiHangUpManager = exports.CAdapiHangUpManager = helpers.defineClass(function() {}, Thread, {

	private static int DEFAULT_TEMPO_HANGUP_CHECK = 100;
	private static CAdapiHangUpManager sHangUpManager = null;

	public static CAdapiHangUpManager this.hangUpManager {
		if (sHangUpManager == null) {
			sHangUpManager = new CAdapiHangUpManager();
			sHangUpManager.start();
		}
		return sHangUpManager;
	}

	private boolean continu = true;
	private int hangUpCheck = DEFAULT_TEMPO_HANGUP_CHECK;
	private Map<Integer, IAdapiHangUp> this.listHangUp = new Hashtable<Integer, IAdapiHangUp>();

	private CAdapiHangUpManager() {
		var wValue = FusionConfig.getInt(FusionConfig.HANGUP_TEMP, DEFAULT_TEMPO_HANGUP_CHECK);
		if (wValue > 0) {
			hangUpCheck = wValue;
		}
	}, doExecute: function() {
		synchronized (this.listHangUp) {
			if (this.listHangUp.keySet() != null && this.listHangUp.keySet().size() != 0) {
				for (key : this.listHangUp.keySet()) {
					this.listHangUp.get(key).performHangUp();
				}
			}
		}
	}, getContinue: function() {
		return continu;
	}, register: function(aHangUpable) {
		synchronized (this.listHangUp) {
			this.listHangUp.put(aHangUpable.hashCode(), aHangUpable);
		}

	}, run: function() {
		while (this.continue) {
			try {
				doExecute();
				sleep(hangUpCheck);
			} catch (e) {
				e.printStackTrace();
			}
		}
	}, setContinue: function(cont) {
		continu = cont;
	}, unRegister: function(aHangUpable) {
		synchronized (this.listHangUp) {
			this.listHangUp.remove(aHangUpable.hashCode());
		}

	}
}
