"use strict";


var streams = require("streamline/lib/streams/streams"),
	helpers = require('syracuse-core/lib/helpers'),
	jsxml = require('jsxml'),
	util = require('util'),
	srvactions = require('syracuse-ui/lib/fusion/core/client/sap/srvactions');

var tracer = true;

var Dispatcher = helpers.defineClass(function(context,endCallBack) {
	this.context = context;
	this.endCallBack=endCallBack;
	this.content = '';
	this.execi = {};
}, null, {
	write: function(buf) {
		this.content += buf.toString('utf8');
		
	},
	forward: function(_, sid){
		var self = this;
		var keyword = "PROXY_DISPATCH";
		
        function isProxyDispatch() {
            // Avoid parsing
            if (!self.content.indexOf(keyword) < 0) return false;
            self.respJson = JSON.parse(self.content);
            if (self.respJson.sap != null &&
            self.respJson.sap.target != null &&
            self.respJson.sap.target.rpc != null &&
            self.respJson.sap.target.rpc.xml != null) {
                self.execi = jsxml.parse(self.respJson.sap.target.rpc.xml).execi;
               // console.log("RESP = "+JSON.stringify(self.respJson,null,2));
                if (self.execi.$.id === keyword) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        }
		
		function execute(_){

			function exec(_, header){
				var args = [];
				function execJsFunc(_, modul){
					parseBody();
					var result;
					if (body.mode == "sync" ){
						result = require(modul)[body.function].apply(null, args);
					}else if (body.mode == "wait"){
						if (body.callbackIndex == null){
							body.callbackIndex = -1;
						}
						result = require(modul)[body.function].apply_(_, null, args, body.callbackIndex);
					}else{
						throw new Error("Invalid mode");
					}
					if (body.return != null){
						result = eval('result.'+body.return);
					}

					try{
						result = JSON.stringify(result,null,0);
					}catch(e){
						console.error("Stringify error:"+e.message);
					}
					return result;
				}
				
				function execHttpRequest(_, header){

					var request = streams.httpRequest(header);
					if (header.method == 'POST' || header.method == 'PUT'){
						//console.log('data='+data);
						parseBody();
						request.write(_,body);
					}

					var resp = request.end().response(_);
					resp.setEncoding("utf8");
					var content = resp.readAll(_);
					
					trace("Request method="+  header.method);
					trace("Request url="+  header.url);
					trace("Request header="+  JSON.stringify(header.headers,null,2));
					trace("Status Code="+  resp.statusCode);
					trace("Header="+  JSON.stringify(resp.headers,null,2));
					trace("Content="+ content);

					return {
						header: resp.headers,
						body: content
					}
				}
				
				function parseBody(){
					binary = JSON.parse(self.execi.param[1].resu.$cdata);
					//console.log("param="+self.execi.param[2].resu.$cdata);
					body = JSON.parse(self.execi.param[2].resu.$cdata);

					if (body.args != null){
						if (body.encodings != null && body.args.length !== body.encodings.length)
							throw new Error("Body elements 'args' and 'encodings' must have same length.");
						// Decode base64 if body.encodings is set to 1
						body.args.forEach(function(elt, idx){
							if (body.encodings != null && body.encodings[idx] === 1){
								args[idx] = new Buffer(elt, 'base64').toString('binary');
							}else{
								args[idx] = elt;
							}
						});

					}
				}

				
				var resu,
					typ = "STRU",
					errl = 0,
					errm = "",
					errn = 0,
					errp = "",
					errt = 0;
				try{
					// Syracuse function execution
					if (header.url.indexOf('js:') == 0){
						resu = execJsFunc(_, header.url.substring(3));
					} 
					// Http Request
					else if (header.method != null){
						if (header.url.indexOf('http://') == 0 || header.url.indexOf('https://') == 0){
							resu = JSON.stringify(execHttpRequest(_, header),null,0);
						}else{
							throw new Error("Invalid protocol");
						}
						
					} 
					// Unknow call type
					else{
						return genExeciNode(null, "STRU", 1, "Unknow Call", 1, "proxyDispatcher._js", 1);
					}
					
				}catch(e){
					//TODO Catch every error's elements
					console.error("ERROR="+e.stack);
					errl = 1;
					errn = 1;
					errt = 1;
					errp = "proxyDispatcher._js";
					errm = e.message;
					resu = null;
				}

				return genExeciNode(resu, typ, errl, errm, errn, errp, errt);
			}
			
			
			function genExeciNode(resu, typ, errl, errm, errn, errp, errt){
				//TODO - Manage RESU Type
				
				var node = '<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>';
				node += '<execi errl=\"'+errl+'\" errm=\"'+errm+'\" errn=\"'+errn+'\" errp=\"'+errp+'\" errt=\"'+errt+'\" >';
				node += '<resu size=\"'+(resu != null ? resu.length : 'NULL')+'\" typ=\"'+typ+'\" ><![CDATA['+resu+']]></resu>';
				node += '</execi>';
				return node;
			}
			

			var header = JSON.parse(self.execi.param[0].resu.$cdata),
				binary,
				body;

			

			var data = {
					act: srvactions.getSrvAction('SRV_RESI'),
					param: {
						target: self.respJson.sap.target.rpc.ist,
						reply: {
							xml: ''
						}
					}
			};
			
			data.param.reply.xml = exec(_, header);


			return new Buffer(JSON.stringify(data, null, 0), 'utf8');
		}
		

		
		function dispatch(_){
			
			traceSection("REPLY FROM SERVER", self.content);

			if (isProxyDispatch() == true){
				
				var data = execute(_);
				var options = {
					url: self.context.endpoint.getFusionDataServerBaseUrl(_) + "/$sessions('" + sid + "')/requestSvc?act="+data.act,
					method: "PUT",
					headers: {
						"content-type": "application/json",
						"accept": "application/json;vnd.sage=syracuse"
					}	
				}
				
				var request = streams.httpRequest(options);
				traceSection("REQUEST FROM NODE TO SERVER", data);

				request.write(_, data);
				
				var response = request.end().response(_);

				self.headers = response.headers;
				self.status = response.statusCode;

				
				var buf;
				self.content="";
				while(buf = response.read(_)){
					self.write(buf);
				}

				dispatch(_);
			}else{
				traceSection("REQUEST FROM CLIENT TO SERVER", self.content);
				endResponse({
					body:self.content,
					headers:self.headers,
					status:self.status

				});
			}
		}
		
		// Flush flush httpclient response via endCallBack
		function endResponse(data){
			if (self.endCallBack){
				self.endCallBack(data);
			}
			self.endCallBack=null;
			self.context=null;
		}
		try{
		
			dispatch(_);
		
		
		}catch(e){
			console.error("An error has occured : "+e.stack)
		}
	}
	
});
		
function traceSection(title, content){
	trace("\n");
	trace("##################################################");
	trace("#    "+title);
	trace("##################################################");
	trace(" "+JSON.stringify(JSON.parse(content.toString('utf8')),null,2));
}
	
function trace(str){
	if (tracer === true)
		console.log(str);
}


exports.create = function(context, endCallback){
	trace("\n==================================================");
	trace("==================================================\n");
	return new Dispatcher(context, endCallback);
}