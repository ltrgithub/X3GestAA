"use strict";

var streams = require("streamline/lib/streams/streams"),
	helpers = require('syracuse-core/lib/helpers'),
	jsxml = require('jsxml'),
	util = require('util'),
	srvactions = require('syracuse-ui/lib/fusion/core/client/sap/srvactions'),
	jsRunner = require('syracuse-x3/lib/jsRunner');

var tracer = helpers.fusionProxyTracer != null ? helpers.fusionProxyTracer : false;

var Dispatcher = helpers.defineClass(function(context,endCallBack) {
	this.context = context;
	this.endCallBack=endCallBack;
	this.content = '';
	this.execi = {};
}, null, {
	write: function(buf) {
		this.content += buf.toString('utf8');
		
	},
	forward: function(_, sid){
		var self = this;
		var keyword = "PROXY_DISPATCH";
		
        function isProxyDispatch() {
            // Avoid parsing
            if (!self.content.indexOf(keyword) < 0) return false;
            self.respJson = JSON.parse(self.content);
            if (self.respJson.sap != null &&
            self.respJson.sap.target != null &&
            self.respJson.sap.target.rpc != null &&
            self.respJson.sap.target.rpc.xml != null) {
                self.execi = jsxml.parse(self.respJson.sap.target.rpc.xml).execi;
               // console.log("RESP = "+JSON.stringify(self.respJson,null,2));
                if (self.execi.$.id === keyword) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        }
		
		function execute(_){

			function exec(_, header){
				
				function parseBody(){
					body = JSON.parse(self.execi.param[1].resu.$cdata);
				}
				
				var resu,
					typ = "STRU",
					errl = 0,
					errm = "",
					errn = 0,
					errp = "",
					errt = 0;
				try{
					// Syracuse function execution
					if (header.url.indexOf('js:') == 0){
						parseBody();
						resu = jsRunner.execute(_, header.url.substring(3), body);
					} 
					// Http Request
					else if (header.method != null){
						if (header.url.indexOf('http://') == 0 || header.url.indexOf('https://') == 0){
							if (header.method == 'POST' || header.method == 'PUT'){
								parseBody();
							}
							resu = jsRunner.httpRequest(_, header, body);

							trace("Header="+  JSON.stringify(resu.header,null,2));
							//trace("Body="+ resu.body);
							
							//resu = JSON.stringify(execHttpRequest(_, header),null,0);
						}else{
							throw new Error("Invalid protocol");
						}
						
					} 
					// Unknow call type
					else{
						return genExeciNode(null, "STRU", 1, "Unknow Call", 1, "proxyDispatcher._js", 1);
					}
					
				}catch(e){
					//TODO Catch every error's elements
					console.error("ERROR="+e.stack);
					errl = 1;
					errn = 1;
					errt = 1;
					errp = "proxyFusionDispatcher._js";
					errm = e.message;
					resu = {
							header: {
								"statusCode": "500",
								"message": e.message,
								"exception": e.stack	
							},
							body: ''
					}
				}

				return genExeciNode(resu, typ, errl, errm, errn, errp, errt);
			}
			
			
			function genExeciNode(resu, typ, errl, errm, errn, errp, errt){
				//TODO - Manage RESU Type
				
				var node = '<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>';
				node += '<execi errl=\"'+errl+'\" errm=\"'+errm+'\" errn=\"'+errn+'\" errp=\"'+errp+'\" errt=\"'+errt+'\" >';
				node += '<resu size=\"'+(resu.body != null ? resu.body.length : 'NULL')+'\" typ=\"'+typ+'\" ><![CDATA['+JSON.stringify(resu.body,null,0)+']]></resu>';
				node += '<debuginfos><trace><![CDATA[' + JSON.stringify(resu.header,null,0) + ']]></trace></debuginfos>'
				node += '</execi>';
				return node;
			}
			
			var header = JSON.parse(self.execi.param[0].resu.$cdata),
				body;

			var data = {
					act: srvactions.getSrvAction('SRV_RESI'),
					param: {
						target: self.respJson.sap.target.rpc.ist,
						reply: {
							xml: ''
						}
					}
			};
			
			data.param.reply.xml = exec(_, header);

			return new Buffer(JSON.stringify(data, null, 0), 'utf8');
		}
		

		
		function dispatch(_){
			
			traceSection("REPLY FROM SERVER", self.content);

			if (isProxyDispatch() == true){
				
				var data = execute(_);
				var options = {
					url: self.context.endpoint.getFusionDataServerBaseUrl(_) + "/$sessions('" + sid + "')/requestSvc?act="+data.act,
					method: "PUT",
					headers: {
						"content-type": "application/json",
						"accept": "application/json;vnd.sage=syracuse"
					}	
				}
				
				var request = streams.httpRequest(options);
				traceSection("REQUEST FROM NODE TO SERVER", data);

				request.write(_, data);
				
				var response = request.end().response(_);

				self.headers = response.headers;
				self.status = response.statusCode;

				
				var buf;
				self.content="";
				while(buf = response.read(_)){
					self.write(buf);
				}

				dispatch(_);
			}else{
				traceSection("REQUEST FROM CLIENT TO SERVER", self.content);
				endResponse({
					body:self.content,
					headers:self.headers,
					status:self.status

				});
			}
		}
		
		// Flush flush httpclient response via endCallBack
		function endResponse(data){
			if (self.endCallBack){
				self.endCallBack(data);
			}
			self.endCallBack=null;
			self.context=null;
		}
		try{
		
			dispatch(_);
		
		
		}catch(e){
			console.error("An error has occured : "+e.stack)
		}
	}
	
});
		
function traceSection(title, content){
	trace("\n");
	trace("##################################################");
	trace("#    "+title);
	trace("##################################################");
	trace(" "+JSON.stringify(JSON.parse(content.toString('utf8')),null,2));
}
	
function trace(str){
	if (tracer === true)
		console.log(str);
}


exports.create = function(context, endCallback){
	trace("\n==================================================");
	trace("==================================================\n");
	return new Dispatcher(context, endCallback);
}