"use strict";


var streams = require("streamline/lib/streams/streams"),
	helpers = require('syracuse-core/lib/helpers'),
	jsxml = require('jsxml'),
	util = require('util'),
	srvactions = require('syracuse-ui/lib/fusion/core/client/sap/srvactions');


var Dispatcher = helpers.defineClass(function(context,endCallBack) {
	this.context = context;
	this.endCallBack=endCallBack;
	this.content = '';
	this.execi = {};
}, null, {
	write: function(buf) {
		this.content += buf.toString('utf8');
		
	},
	forward: function(_, sid){
		var self = this;
		

        function isProxyDispatch() {
            // Avoid parsing
            if (!self.content.indexOf("PROXY_DISPATCH") < 0) return false;
            self.respJson = JSON.parse(self.content);
            if (self.respJson.sap != null &&
            self.respJson.sap.target != null &&
            self.respJson.sap.target.rpc != null &&
            self.respJson.sap.target.rpc.xml != null) {
                self.execi = jsxml.parse(self.respJson.sap.target.rpc.xml).execi;
                //console.log("EXECI = "+JSON.stringify(self.execi,null,2));
                if (self.execi.$.id === "PROXY_DISPATCH") {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        }
		
		function execute(_){

			function exec(_, header){
				
				function execJsFunc(_, modul){
					parseBody();
					if (body.mode == "sync" ){
						return require(modul)[body.function].apply(null, body.args);
					}else if (body.mode == "wait"){
						if (body.callbackIndex == null){
							body.callbackIndex = -1;
						}
						return require(modul)[body.function].apply_(_, null, body.args, body.callbackIndex);
					}else{
						throw new Error("Invalid mode");
					}

				}
				
				function execHttpRequest(_, header){

					var request = streams.httpRequest(header);
					if (header.method == 'POST' || header.method == 'PUT'){
						//console.log('data='+data);
						parseBody();
						request.write(_,body);
					}

					var resp = request.end().response(_);
					resp.setEncoding("utf8");
					var content = resp.readAll(_);
					
					console.log("Request method="+  header.method);
					console.log("Request url="+  header.url);
					console.log("Request header="+  JSON.stringify(header.headers,null,2));
					console.log("Status Code="+  resp.statusCode);
					console.log("Header="+  JSON.stringify(resp.headers,null,2));
//					console.log("Content="+ content);

					return {
						header: resp.headers,
						body: content
					}
				}
				
				function parseBody(){
					binary = JSON.parse(self.execi.param[1].resu.$cdata);
					body = JSON.parse(self.execi.param[2].resu.$cdata);
				
					if (binary == 1) {
						console.log("decode base64");
						body = JSON.parse(new Buffer(body, 'base64').toString('utf8'));
					}
				}

				
				var resu,
					typ = "STRU",
					errl = 0,
					errm = "",
					errn = 0,
					errp = "",
					errt = 0;
				try{
					// Syracuse function execution
					if (header.url.indexOf('js:') == 0){
						resu = execJsFunc(_, header.url.substring(3));
					} 
					// Http Request
					else if (header.method != null){
						if (header.url.indexOf('http://') == 0 || header.url.indexOf('https://') == 0){
							resu = JSON.stringify(execHttpRequest(_, header),null,0);
						}else{
							throw new Error("Invalid protocol");
						}
						
					} 
					// Unknow call type
					else{
						return genExeciNode(null, "STRU", 1, "Unknow Call", 1, "proxyDispatcher._js", 1);
					}
					
				}catch(e){
					//TODO Catch every error's elements
					console.error("ERROR="+e);
					errl = 1;
					errn = 1;
					errt = 1;
					errp = "proxyDispatcher._js";
					errm = e.message;
					resu = null;
				}

				return genExeciNode(resu, typ, errl, errm, errn, errp, errt);
			}
			
			
			function genExeciNode(resu, typ, errl, errm, errn, errp, errt){
				//TODO - Manage RESU Type
				
				var node = '<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>';
				node += '<execi errl=\"'+errl+'\" errm=\"'+errm+'\" errn=\"'+errn+'\" errp=\"'+errp+'\" errt=\"'+errt+'\" >';
				node += '<resu size=\"'+(resu != null ? resu.length : 'NULL')+'\" typ=\"'+typ+'\" ><![CDATA['+resu+']]></resu>';
				node += '</execi>';
				return node;
			}
			

			var header = JSON.parse(self.execi.param[0].resu.$cdata),
				binary,
				body;

			

			var data = {
					act: srvactions.getSrvAction('SRV_RESI'),
					param: {
						target: self.respJson.sap.target.rpc.ist,
						reply: {
							xml: ''
						}
					}
			};
			
			data.param.reply.xml = exec(_, header);


			return new Buffer(JSON.stringify(data, null, 0), 'utf8');
		}
		
		// Flush de la r√©ponse http du client via endCallBack
		function endResponse(dispatched, data){
			if (self.endCallBack){
				self.endCallBack(dispatched, data);
			}
			self.endCallBack=null;
			self.context=null;
		}
		
		try{
		
			var clientResp=this.context.response;
			if (isProxyDispatch() == true){
				
				var data = execute(_);
				var options = {
					url: this.context.endpoint.getFusionDataServerBaseUrl(_) + "/$sessions('" + sid + "')/requestSvc?act="+data.act,
					method: "PUT",
					headers: {
						"content-type": "application/json",
						"accept": "application/json;vnd.sage=syracuse"
					}	
				}
				
				var request = streams.httpRequest(options);
				request.write(_, data);
				
				var response = request.end().response(_);
				
				var buf;
				this.content="";
				while(buf = response.read(_)){
					//console.log("RESP="+buf.toString('utf8'));
					//clientResp.write(_, buf, "utf8");
					this.content += buf.toString('utf8');
				}
				endResponse(true,{
					status:response.statusCode,
					headers:response.headers,
					body:this.content
				});
			}else{
				endResponse(false,{
					body:this.content					
				});
			}
		
		
		}catch(e){
			console.error("An error has occured : "+e.stack)
		}
	}
	
});
		

	
exports.create = function(context, endCallback){
	return new Dispatcher(context, endCallback);
}