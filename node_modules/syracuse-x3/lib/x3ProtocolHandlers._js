"use strict";

var helpers = require("syracuse-core/lib/helpers");
var classes = require("./x3ProtocolClasses");

var MAP = require("./x3Protocol").MAP;

var HANDLERS = {};

function parseKeyValues(str) {
	return str.split('\n').reduce(function(result, line) {
		if (line) {
			var pair = line.split('=\u0001');
			console.log(pair);
			result[pair[0]] = pair[1];
		}
		return result;
	}, {});
}

function formatKeyValues(result) {
	return [Object.keys(result).map(function(key) {
		return key + '=\u0001' + result[key] + '\n';
	})];
}

function parseKey(str) {
	var keys = str.split('\n');
	if (keys.length !== 2 || keys[1]) throw new Error("bad key: " + str);
	return keys[0];
}

function checkLen(list, len) {
	if (list.length !== len) throw new Error("bad list length: " + list.length);
}

function istWin(ist) {
	return (ist >> 24) & 0xff;
}

function istScreen(ist) {
	return (ist >> 16) & 0xff;
}

function istBlock(ist) {
	return (ist >> 8) & 0xff;
}

function istField(ist) {
	return ist & 0xff;
}

function makeIst(win, screen, block, field) {
	return (win << 24) | (screen << 16) | (block << 8) | field;
}

var UIActions = {
	SetTechnoVers: function(_, req, values) {
		// bad values, but they keep our replay test happy 
		values.Id = "2";
		values.Version = "null.null"; // for now
		return values;
	},
	SessionSettings: function(_, req, values) {
		return {
			UIAction: "SessionSettings"
		};
	},
	SetWindFeatures: function(_, req, values) {
		// strange!
		return {
			UIAction: "SessionSettings"
		};
	},
	Sethangup: function(_, req, values) {
		return {
			Sethangup: 1
		};
	},
}

HANDLERS.ND_SLF = function(_, req, node, actions) {
	checkLen(actions, 1);
	var values = parseKeyValues(actions[0]);
	var fn = UIActions[values.UIAction];
	if (!fn) throw new Error("bad UI action: " + values.UIAction);
	var result = fn(_, req, values);
	return formatKeyValues(result);
};

var GfdValues = {
	X3FileVersion: "null.null",
	SDate: "/",
	IDate: "0",
	SDecimal: ".",
	SThousand: " ",
};

HANDLERS.ND_GFD = function(_, req, node, actions) {
	checkLen(actions, 1);
	var key = parseKey(actions[0]);
	var result = {}
	result[key] = GfdValues[key];
	if (result[key] === undefined) result[key] = key + " : unsupported param";
	return formatKeyValues(result);
}

HANDLERS.NDOMNBO = function(_, req, node, wIdm, wRng, wIde, wFlg, wActionId, wTxt, wAcc) {
	//ctx.reply.addMenuWin(wFlg, wActionId, wTxt, wIdm, wRng, wIde, wAcc);
}

HANDLERS.NDOWIN = function(_, req, node, ist, winId, funId, stamp, extra) {
	if (winId === "TEMPON") {
		ctx.nbNodeOpenTempon++
		return [0];
	}
	// compat hack
	if (winId[0] === '&') winId[0] = '_';

	//wX3Reply.setChangeWindow();
	ctx.reply.changeWindow = true;
	var win = new classes.StackedWindow(ctx, winId, funId, stamp, istWin(ist));
	ctx.windows.push(win);
	ctx.reply.pushedWindows.push(win); // TODO: handle menu
	// was setting stamp in reply: useless!
	// TODO: handle extends ??
	// does not acknowledge???
}

exports.newContext = function(stream) {
	return new classes.Context(stream, HANDLERS);
}

exports.HANDLERS = HANDLERS;
