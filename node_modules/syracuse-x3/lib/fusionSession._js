"use strict";

var locale = require("syracuse-core/lib/locale");
var helpers = require("syracuse-core/lib/helpers");
var streams = require("streamline/lib/streams/streams");
var fs = require("fs");
var dateObj = require("syracuse-core/lib/types/date");
var util = require("util");
var sys = require("util");
var jsxml = require("./xmlToJsReply");
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var x3helpers = require("./helpers");
var dispatcher = require('./proxyFusionDispatcher');

var tracer = console.log;
//var tracer = null;

function _startProfile() {
	return (new Date()).getTime();
}

function _endProfile(startTime) {
	return (new Date()).getTime() - startTime;
}

function FusionSession(fsid) {
	this.sessionUrl = "";
	this.isXmlSessionFormat = false;
}	

var sessionProto = FusionSession.prototype;
//
sessionProto.connect = function(_, context, config) {
	var tracer = config && config.tracer;
	var profiler = config && config.profiler;
	//
	var fncTime = _startProfile();
	//
	var baseUrl = context.endpoint.getFusionDataServerBaseUrl(_);
	var x3server = context.endpoint.x3server(_);
	var userProfile = context.httpSession.getUserProfile(_);
	var localePrefs = userProfile && userProfile.selectedLocale(_);
	var endpoint = context.endpoint;
	//
	this._baseUrl = baseUrl;
	//
	if(!context.parameters || !context.parameters.f)
		throw new Error(locale.format(module, "parFunctionExpected"));
	//
	tracer && tracer("fusionSession.connect request");
	//
	var reqStr = JSON.stringify({
	   host: x3server.serverHost(_),
	   port: x3server.serverPort(_),
	   folder: endpoint.x3ServerFolder(_)
	});
	var options = {
		url: baseUrl + "/$connections",
		method: "POST",
		headers: {
			"content-type": "application/json",
			"content-length": reqStr.length,
			"accept-language": locale.current || "en-US",
			"accept": "application/json;vnd.sage=syracuse"
		}	
	}
	//
	var start = profiler && _startProfile();
	var request = streams.httpRequest(options);
	request.write(_, reqStr, "utf8");
	// response
	var resp = request.end().response(_);
	// check code
	if(resp.statusCode !== 201) {
		tracer && tracer("fusionSession.connect "+options.url+" statusCode: "+resp.statusCode);
		try {
			var respContent = resp.readAll(_);
		} catch(e) {
			// content encoding error ...
			respContent = resp.statusCode + "/" + e.message;
		}
		var error = new Error(locale.format(module, "connectionFailed", (respContent && respContent.toString("utf8")) || ""));
		error.statusCode = resp.statusCode;
		throw error;
	}
	var respJson = JSON.parse(resp.readAll(_).toString("utf8"));
	profiler && profiler("PROFILE; Transition connection: " + _endProfile(start));
	tracer && tracer("fusionSession.connect connected; response: "+util.inspect(respJson));
	//
	if(!respJson.id)
		throw new Error(locale.format(module, "connectionIdExpected"));
	this.cid = respJson.id;
	this._connectionUrl = resp.headers["location"];
	// create a session
	var options = {
		url: baseUrl + "/$sessions",
		method: "POST",
		headers: {
			"content-type": "application/json",
			"accept-language": locale.current || "en-US",
			"accept": "application/json;vnd.sage=syracuse",
			"x-forwarded-for": context.request.connection.remoteAddress
		}	
	}
	var body = {
			connectionId: this.cid,
			sessionType: "primary",
			appServerUrl: endpoint.getApplicationServerBaseUrl(_),
			"function": context.parameters.f
		};
	if(respJson.auth && (respJson.auth.method === "X3RSA")) {
		options.headers.authorization = "x3-challenge";
		var auth = body.auth = {
			method: "X3RSA",
			pubkey: nodeconfig.config.sdata.pubkeyName,
			user: userProfile && userProfile.user(_) && userProfile.user(_).getEndpointLogin(_, endpoint.$uuid)
		};
		auth.signature = x3helpers.getSignature(_, respJson.auth.challenge, auth.user);
	}
	var selLocale = userProfile.selectedLocale(_);
	if(selLocale)
		body.preferences = {
			shortDateFormat: x3helpers.dateFormatToX3Format(selLocale.shortDate(_)),
			longDateFormat: x3helpers.dateFormatToX3Format(selLocale.longDate(_)),
			shortTimeFormat: x3helpers.dateFormatToX3Format(selLocale.shortTime(_)),
			longTimeFormat: x3helpers.dateFormatToX3Format(selLocale.longTime(_)),
			shortDatetimeFormat: x3helpers.dateFormatToX3Format(selLocale.shortDatetime(_)),
			longDatetimeFormat: x3helpers.dateFormatToX3Format(selLocale.longDatetime(_)),
			decimalSep: selLocale.numberDecimalSeparator(_),
			thousandsSep: selLocale.numberGroupSeparator(_)
		}
	var reqStr = JSON.stringify(body);
	options.headers["content-length"] = reqStr.length;
	var start = profiler && _startProfile();
	var request = streams.httpRequest(options);
	request.write(_, reqStr, "utf8");
	// response
	var resp = request.end().response(_);
	profiler && profiler("PROFILE; Transition session create - got response: " + _endProfile(start));
	var start = profiler && _startProfile();
	// check code
	if(resp.statusCode !== 201) {
		tracer && tracer("fusionSession.connect "+options.url+" statusCode: "+resp.statusCode);
		try {
			var respContent = resp.readAll(_);
		} catch(e) {
			// content encoding error ...
			respContent = resp.statusCode + "/" + e.message;
		}
		var error = new Error(locale.format(module, "sessionFailed", (respContent && respContent.toString("utf8")) || ""));
		error.statusCode = resp.statusCode;
		throw error;
	}
	//	get sid from location
	this._sessionUrl = this.sessionUrl = resp.headers["location"];
	this.sid = /\('(.*)'\)$/.exec(resp.headers["location"])[1];
	if(!this.sid)
		throw new Error(locale.format(module, "sessionIdExpected"));
	tracer && tracer("fusionSession.connect session sid: "+this.sid+" created; response: "+util.inspect(respJson));
	// FDB - Propagate  X3 bridge headers
	var x3Headers={};
	if (resp.headers){
		for (var p in resp.headers){
			if (p.indexOf("x3-bridge-"==0)){
				x3Headers[p]=resp.headers[p]
			}
		}
	}
	var respContent = resp.readAll(_).toString("utf8");
	//
	profiler && profiler("PROFILE; Transition session create - got content: " + _endProfile(start));
	profiler && profiler("PROFILE; Syracuse transition connect total: " + _endProfile(fncTime));
	// FDB - Propagate  X3 bridge headers
	return {
		body:JSON.parse(respContent),
		headers:x3Headers
	}
}

sessionProto.proxy = function(_, context, config) {
	var start = _startProfile();
	var tracer = config && config.tracer;
	var profiler = config && config.profiler;
	//
	var toWalk = context.toWalk();
	var baseUrl = context.endpoint.getFusionDataServerBaseUrl(_) + "/$sessions('" + this.sid + "')" + (toWalk ? "/" + toWalk : "");
	var clientReq = context.request;
//	var params = Object.keys(context.parameters).map(function(key) {return key + "=" + encodeURIComponent(context.parameters[key]); }).join("&");
	var params = context.rawQuery;
	var options = {
			url: baseUrl + (params ? ("?" + params) : ""),
			method: context.method,
			headers: clientReq.headers
		}
	tracer && tracer("FusionSession.proxy url: "+options.url);
	var proxyReq = streams.httpRequest(options);
	var buf;
	while(buf = clientReq.read(_)) proxyReq.write(_, buf, "utf8");
	var proxyResp = proxyReq.end().response(_);
	var clientResp = context.response;
	//
	var dis = dispatcher.create(context,function(dispatched, data){		
		// Flush http client response
		if (!dispatched) {
			// No dispatch - Return proxyResp content
			data.headers=proxyResp.headers;
			data.status=proxyResp.statusCode;
			// data.body has been calculated by dispatcher
		}// Else - Dispatch - data contains forward response content
		// Add response time in httpheaders (dvlp)
		data.headers["syra-proxy-time"]= _endProfile(start);
		clientResp.writeHead(data.status,data.headers);
		clientResp.write(null, data.body || "");
		clientResp.end();
		profiler && profiler("PROFILE; Transition proxy roundtrip: " + _endProfile(start));	
	});
	while(buf = proxyResp.read(_)){
		dis.write(buf);
		//context.proxyResp.write(_, buf, "utf8");
	}
	dis.forward(_, this.sid);
}

sessionProto.close = function(_, reuse) {
	function _addReuse(url) {
		if(!reuse) return url;
		if(url.indexOf("?") >= 0)
			return url + "&reuse=" + reuse;
		else
			return url + "?reuse=" + reuse;
	}
	if(!this._baseUrl) return;
	// delete connection and session
	if(this._sessionUrl) {
		var options = {
				url: _addReuse(this._baseUrl + this._sessionUrl),
				method: "DELETE"
			}
		var request = streams.httpRequest(options);
		// response
		var resp = request.end().response(_);
		// check code
		if(resp.statusCode !== 204) {
			var error = new Error(locale.format(module, "sessionDeleteError", resp.readAll(_).toString("utf8")));
			error.statusCode = resp.statusCode;
			throw error;
		}
		tracer && tracer("Session "+this.sid+" deleted");
	}
	if(this._connectionUrl) {
		var options = {
				url: _addReuse(this._baseUrl + this._connectionUrl),
				method: "DELETE"
			}
		var request = streams.httpRequest(options);
		// response
		var resp = request.end().response(_);
		// check code
		if((resp.statusCode !== 204) && (resp.statusCode !== 404)) {
			tracer && tracer("Delete connection "+this.cid+" statusCode: "+resp.statusCode);
			var errMessage = resp.readAll(_);
			var error = new Error(locale.format(module, "connectionDeleteError", (errMessage && errMessage.toString("utf8")) || resp.statusCode));
			error.statusCode = resp.statusCode;
			throw error;
		}
		tracer && tracer("Connection "+this.cid+" deleted");
	}
}

exports.getFusionSession = function(_, fsid) {
	return new FusionSession(fsid);
}

// global function called from sessions cleanup
exports.closeSession = function(_, fsid, sessionUrl) {
	var options = {
			url: sessionUrl,
			method: "DELETE"
		}
	var request = streams.httpRequest(options);
	var resp = request.end();
//	var respStr = request.end().response(_).readAll(_).toString("utf8");
	// TODO: decode response ?
}

