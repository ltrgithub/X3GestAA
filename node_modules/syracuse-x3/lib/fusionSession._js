"use strict";

var locale = require("syracuse-core/lib/locale");
var helpers = require("syracuse-core/lib/helpers");
var streams = require("streamline/lib/streams/streams");
var fs = require("fs");
var dateObj = require("syracuse-core/lib/types/date");
var util = require("util");
var sys = require("util");
var jsxml = require("./xmlToJsReply");
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var x3helpers = require("./helpers");
var dispatcher = require('./proxyFusionDispatcher');

var tracer = console.log;
//var tracer = null;

function _startProfile(){
    return (new Date()).getTime();
}

function _endProfile(startTime){
    return (new Date()).getTime() - startTime;
}

function FusionSession(fsid){
    this.sessionUrl = "";
    this.isXmlSessionFormat = false;
}

var sessionProto = FusionSession.prototype;
//
sessionProto.connect = function(_, context, config){
    var tracer = config && config.tracer;
    var profiler = config && config.profiler;
    //
    var fncTime = _startProfile();
    //
    var baseUrl = context.endpoint.getFusionDataServerBaseUrl(_);
    var x3server = context.endpoint.x3server(_);
    var userProfile = context.httpSession.getUserProfile(_);
    var localePrefs = userProfile && userProfile.selectedLocale(_);
    var endpoint = context.endpoint;
    //
    this._baseUrl = baseUrl;
    //
    if (!context.parameters || !context.parameters.f) 
        throw new Error(locale.format(module, "parFunctionExpected"));
    //
    tracer && tracer("fusionSession.connect request");
    //
    // FDB - Url's parameters (context.query) are propagated to Bridge server
    // Ex: host/port/level for X3 trace client - context.parameters contains more params than query.url
    // FDB - Url's parameters (context.query) are propagated to Bridge server
    // Ex: host/port/level for X3 trace client - context.parameters contains more params than query.url
    var cnxParams = "";
    for (var p in context.query) {
        cnxParams += (cnxParams.length == 0 ? "?" : "&") + encodeURIComponent(p) + "=" + encodeURIComponent(context.query[p]);
    }
    var r = {
            host: x3server.serverHost(_),
            port: x3server.serverPort(_),
            folder: endpoint.x3ServerFolder(_)
        }
    if(x3server.serverName(_))
    	r.server = x3server.serverName(_);
    var reqStr = JSON.stringify(r);
    var options = {
        url: baseUrl + "/$connections" + cnxParams,
        method: "POST",
        headers: {
            "content-type": "application/json",
            "content-length": reqStr.length,
            "accept-language": locale.current || "en-US",
            "accept": "application/json;vnd.sage=syracuse"
        }
    }
    //
    var start = profiler && _startProfile();
    var request = streams.httpRequest(options);
    request.write(_, reqStr, "utf8");
    // response
    var resp = request.end().response(_);
    // check code
    if (resp.statusCode !== 201) {
        tracer && tracer("fusionSession.connect " + options.url + " statusCode: " + resp.statusCode);
    	// FDB
        try {
			var respContent=resp.readAll(_);
			if ( respContent==null || respContent.length==0) respContent='{"$diagnoses": [{"message": "fusionSession.createConnection error - No error reason[' + resp.statusCode + ']"}]}';
	    	respContent = respContent.toString("utf8");
        } catch (e) {
			console.log(e.message);
			console.log(resp.statusCode.message);
            var respContent = resp.statusCode + "/" + e.message;
			var error = new Error(locale.format(module, "connectionFailed", (respContent && respContent.toString("utf8")) || ""));
	        error.statusCode = resp.statusCode;
	        throw error;
        }
	    return {
	        body: JSON.parse(respContent),
			statusCode : resp.statusCode
	    }
    }
    var respJson = JSON.parse(resp.readAll(_).toString("utf8"));
    profiler && profiler("PROFILE; Transition connection: " + _endProfile(start));
    tracer && tracer("fusionSession.connect connected; response: " + util.inspect(respJson));
    //
    if (!respJson.id) 
        throw new Error(locale.format(module, "connectionIdExpected"));
    this.cid = respJson.id;
    this._connectionUrl = resp.headers["location"];
    // create a session
    var options = {
        url: baseUrl + "/$sessions",
        method: "POST",
        headers: {
            "content-type": "application/json",
            "accept-language": locale.current || "en-US",
            "accept": "application/json;vnd.sage=syracuse",
            "x-forwarded-for": context.request.connection.remoteAddress
        }
    }
    var body = {
        connectionId: this.cid,
        sessionType: "primary",
        adxtyp: 25, // 25 is primary, 26 is secondary
        appServerUrl: endpoint.getApplicationServerBaseUrl(_),
        "function": context.parameters.f
    };
    if (respJson.auth && (respJson.auth.method === "X3RSA")) {
        options.headers.authorization = "x3-challenge";
        var auth = body.auth = {
            method: "X3RSA",
            pubkey: nodeconfig.config.sdata.pubkeyName,
            user: userProfile && userProfile.user(_) && userProfile.user(_).getEndpointLogin(_, endpoint.$uuid)
        };
        auth.signature = x3helpers.getSignature(_, respJson.auth.challenge, auth.user);
    }
    var selLocale = userProfile.selectedLocale(_);
    if (selLocale) {
		// FDB - Session Settings required by X3 client - dateOrder (dym-myd-ymd-dm if no year...)/dateSep/decSep/thousandSep
		body.preferences = x3helpers.dateFormatToX3Prefs(selLocale.shortDate(_));
		body.preferences.decimalSep = selLocale.numberDecimalSeparator(_);
		body.preferences.thousandsSep = selLocale.numberGroupSeparator(_);
		body.preferences.timeSep =  x3helpers.getTimeSep(selLocale.shortTime(_));
	}
    var reqStr = JSON.stringify(body);
    options.headers["content-length"] = reqStr.length;
    var start = profiler && _startProfile();
    var request = streams.httpRequest(options);
    request.write(_, reqStr, "utf8");
    // response
    var resp = request.end().response(_);
    profiler && profiler("PROFILE; Transition session create - got response: " + _endProfile(start));
    var start = profiler && _startProfile();
    // check code
	// FDB
    if (resp.statusCode !== 201) {
        tracer && tracer("fusionSession.connect " + options.url + " statusCode: " + resp.statusCode);
		// FDB
        try {
			var respContent=resp.readAll(_);
			if ( respContent==null || respContent.length==0) respContent='{"$diagnoses": [{"message": "fusionSession.createSession error - No error reason[' + resp.statusCode + ']"}]}';
	    	respContent = respContent.toString("utf8");
        } catch (e) {
            var respContent = resp.statusCode + "/" + e.message;
			var error = new Error(locale.format(module, "sessionFailed", (respContent && respContent.toString("utf8")) || ""));
	        error.statusCode = resp.statusCode;
	        throw error;
        }
	    return {
	        body: JSON.parse(respContent),
	        headers: x3Headers,
			statusCode : resp.statusCode
	    }
    }else{
	    //	get sid from location
	    this._sessionUrl = this.sessionUrl = resp.headers["location"];
	    this.sid = /\('(.*)'\)$/.exec(resp.headers["location"])[1];
		if (!this.sid) 
        throw new Error(locale.format(module, "sessionIdExpected"));
    	// FDB - Propagate  X3 bridge headers
    	var x3Headers = {};
    	if (resp.headers) {
        	for (var p in resp.headers) {
           	 	if (p.indexOf("x3-bridge-" == 0)) {
               	 	x3Headers[p] = resp.headers[p]
            	}
        	}
    	}
    	var respContent = resp.readAll(_).toString("utf8");
    	tracer && tracer("fusionSession.connect session sid: " + this.sid + " created; response: " + util.inspect(respContent));
  		//
	    profiler && profiler("PROFILE; Transition session create - got content: " + _endProfile(start));
	    profiler && profiler("PROFILE; Syracuse transition connect total: " + _endProfile(fncTime));
	    // FDB - Propagate  X3 bridge headers
	    return {
	        body: JSON.parse(respContent),
	        headers: x3Headers
	    }
	}
}

sessionProto.proxy = function(_, context, config){
    var start = _startProfile();
    var tracer = config && config.tracer;
    var profiler = config && config.profiler;
    //
    var toWalk = context.toWalk();
    var baseUrl = context.endpoint.getFusionDataServerBaseUrl(_) + "/$sessions('" + this.sid + "')" + (toWalk ? "/" + toWalk : "");
    var clientReq = context.request;
    //	var params = Object.keys(context.parameters).map(function(key) {return key + "=" + encodeURIComponent(context.parameters[key]); }).join("&");
    var params = context.rawQuery;
    var options = {
        url: baseUrl + (params ? ("?" + params) : ""),
        method: context.method,
        headers: clientReq.headers
    }
    tracer && tracer("FusionSession.proxy url: " + options.url);
    var proxyReq = streams.httpRequest(options);
    var buf;
    while (buf = clientReq.read(_)) 
        proxyReq.write(_, buf, "utf8");
    var proxyResp = proxyReq.end().response(_);
    var clientResp = context.response;
    //
    var dis = dispatcher.create(context, function(data){
        // data.headers and data.status have been forwarded by dispatcher only if dispatch is true
        if (!data.headers) 
            data.headers = proxyResp.headers;
        if (!data.status) 
            data.status = proxyResp.statusCode;
        
        // Add response time in httpheaders (dvlp)
        data.headers["syra-proxy-time"] = _endProfile(start);
        clientResp.writeHead(data.status, data.headers);
        // data.body has been forwarded by dispatcher
        clientResp.write(null, data.body || "");
        clientResp.end();
        profiler && profiler("PROFILE; Transition proxy roundtrip: " + _endProfile(start));
    });
    
    while (buf = proxyResp.read(_)) {
        dis.write(buf);
    }
    dis.forward(_, this.sid);
}

sessionProto.close = function(_, reuse){
    function _addReuse(url){
        if (!reuse) 
            return url;
        if (url.indexOf("?") >= 0) 
            return url + "&reuse=" + reuse;
        else 
            return url + "?reuse=" + reuse;
    }
    if (!this._baseUrl) 
        return;
    // delete connection and session
    if (this._sessionUrl) {
        var options = {
            url: _addReuse(this._baseUrl + this._sessionUrl),
            method: "DELETE"
        }
        var request = streams.httpRequest(options);
        // response
        var resp = request.end().response(_);
        // check code
        if (resp.statusCode !== 204) {
            var error = new Error(locale.format(module, "sessionDeleteError", resp.readAll(_).toString("utf8")));
            error.statusCode = resp.statusCode;
            throw error;
        }
        tracer && tracer("Session " + this.sid + " deleted" + (reuse ? " with reuse" : ""));
    }
    if (this._connectionUrl) {
        var options = {
            url: _addReuse(this._baseUrl + this._connectionUrl),
            method: "DELETE"
        }
        var request = streams.httpRequest(options);
        // response
        var resp = request.end().response(_);
        // check code
        if ((resp.statusCode !== 204) && (resp.statusCode !== 404)) {
            tracer && tracer("Delete connection " + this.cid + " statusCode: " + resp.statusCode);
            var errMessage = resp.readAll(_);
            var error = new Error(locale.format(module, "connectionDeleteError", (errMessage && errMessage.toString("utf8")) || resp.statusCode));
            error.statusCode = resp.statusCode;
            throw error;
        }
        tracer && tracer("Connection " + this.cid + " deleted" + (reuse ? " with reuse" : ""));
    }
}

exports.getFusionSession = function(_, fsid){
    return new FusionSession(fsid);
}

// global function called from sessions cleanup
exports.closeSession = function(_, fsid, sessionUrl){
    var options = {
        url: sessionUrl,
        method: "DELETE"
    }
    var request = streams.httpRequest(options);
    var resp = request.end();
    //	var respStr = request.end().response(_).readAll(_).toString("utf8");
    // TODO: decode response ?
}

