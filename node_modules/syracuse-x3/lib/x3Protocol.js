"use strict";

require('buffer').INSPECT_MAX_BYTES = 2048;
Buffer.prototype.toJSON = function() {
	return this.toString('hex');
}
// !: error
// F: call function
// B: read byte
// S: read short
// L: read long
// U: read UTF8
// I: read ist (long + short)
// A: short + buf
// V: value
// X: special var array of ints
// l: write long
// digit: repeat N times
var DESCS = [
	[0, "ND_RCN", null],
	[1, "ND_GFD", "[UF[U"],
	[2, "ND_SLF", "[UF[U"],
	[14, "NDEXT", null],
	[17, "ND_CMVD", null],
	[18, "NDIMPR", null],
	[19, "NDOPEN", null],
	[20, "ND_CLF", "IF"], // I is nxtist (LS)
	[21, "ND_CLT", "BF"],
	[22, "ND_INP", null],
	[23, "ND_CRD", "F2l"],
	[25, "NDCSTL", "IUF"],
	[26, "NDCHCR", "BF"],
	[27, "NDCHTIT", "!"],
	[28, "NDACTOBJ", "IBFB"],
	[31, "NDCOPMENU", "AF"],
	[32, "NDOUVIMP", "BBUUUUFs"],
	[33, "ND_IMF", "BF"],
	[38, "ND_INT", "Fb"],
	[42, "ND_ASKUI", "!"],
	[43, "NDSYSTEM", "F2a"],
	[45, "NDAFRE", "UF"],

	[49, "NDACV", "LSSUBBF"],

	[56, "NDDEB", ""], // read function was null
	[57, "NDOFENB", "SSSSBSF"],
	[58, "NDOFENH", "UF"],
	[59, "NDOFENA", "SSSSBSF"],
	[60, "NDOFENP", "SSSSBSF"],
	[61, "NDOBOXE", "BBUUBF"],
	[62, "NDOBOXW", "BBUUBF"],
	[63, "NDOBOXQ", "BBUUBF"],
	[64, "NDOBOXS", "SSSSBSF"],
	[65, "NDOBOXI", "BBUUBF"],
	[66, "NDOBOUT", "LUSSUUF"],
	[67, "NDOMNBO", "LSLBSUSF"],
	[68, "NDOMENC", "LF"],
	[69, "NDOMENB", "LF"],
	[70, "NDOMENA", "UF"],

	[73, "NDOTXSC", "IBSUUSF"],

	[80, "NDCREUX", "LSSCCUF"],

	[84, "NDODIAG", "SSSSBSF"], /*  Ouverture Dialogue	*/
	[85, "NDODGSB", "SSSSBSF"], /*  Ouv. Dialogue ss Bt	*/
	[87, "NDOWIN", "IUUUF"], /*  Ouverture Fenetre	*/

	[90, "ND_IMG", "UVF"], /*  Affichage Image	*/
	[91, "ND_RAT", "LLSSF2c"], /*  Rattachement	*/

	[94, "ND_EVT", "UCSF"], /*  Evenement/Instance	*/
	[95, "NDOCSX", "LSSBUF"], /*  Ouv. Case a Cocher	*/
	[96, "NDOGRD", "LSSBBF"], /*  Ouv. Groupe Radio	*/
	[97, "NDOBRD", "LBUF"], /*  Ouv. Bouton Radio	*/
	[98, "NDOTBL", "LSS5BBBBUF"], /*  Ouv. Tableau	*/
	[99, "NDOCTB", "LLBSBUF"], /*  Ouv. Colonne Tbl.	*/
	[100, "NDOCMB", "LSSBSF"], /*  Ouverture Combo	*/
	[101, "NDOFRM", "LSSBF"], /*  Ouverture Frame	*/
	[105, "NDOBOG", "LSSBF"], /*  Ouv. Boite a Onglets*/
	[106, "NDOONG", "LUUF"], /*  Ouv. Onglets	*/
	[107, "NDTBLK", "UUF"], /*  Titre des Blocs	*/
	[108, "NDOBPG", "LSSBF"], /*  Barre Progression	*/
	[109, "NDOIMG", "LSSBF"], /*  Cadre Image		*/
	[110, "NDFIMG", "BLBUF"], /*  Image de Fond	*/
	[111, "NDIHLP", "UUF"], /*  Aide d'un Objet	*/
	[112, "NDITTP", "UUF"], /*  ToolTip d'un Objet	*/
	[113, "NDCHVB", "IF"], /*  Modif Valeur Bin	*/
	[114, "NDCHVL", "IVF"], /*  Modif. Val. Zone	*/
	[115, "NDGIST", "IF"], /*  Allez a Une Zone	*/
	[116, "NDMIST", "IF"], /*  Allez au Menu Zone	*/
	[118, "NDSUPLI", "ISSF"], /*  Suppression Lignes	*/
	[119, "NDINSLI", "ISSF"], /*  Insertion Lignes	*/
	[120, "NDSATAN", "IF"], /*  Saisie Bas de Page	*/
	[121, "NDOLST", "LSSBF"], /*  Ouverture Liste	*/
	[122, "NDOCLS", "IBAF"], /*  Creation Col. Liste	*/
	[123, "NDOLLS", "ILLAF"], /*  Creat. Ligne Liste	*/

	[125, "NDACTOP", "LBF"], /*  Activation Option	*/
	[126, "NDOJLB", "LBUF"], /*  Creat Jeu Libelle	*/
	[127, "NDAJLB", "LBUF"], /*  Alim Jeu Libelles	*/
	[128, "NDCHFM", "IUF"], /*  Format d'une Zone	*/
	[132, "NDOMNAO", "LSLBSUSF"], /*  Option Menu Appli	*/
	[133, "NDGLLS", "IAF"], /*  Allez a Lg Liste	*/
	[134, "NDOPFN", "LSSBF"], /*  Creat. Part. Fen.	*/
	[136, "NDDTOB", "LBF"], /*  Destruction d'Objet	*/
	[137, "NDCTSU", "BUUF"], /*  Creation Type Prg	*/
	[138, "ND_DCL", "IF"], /*  Debut Chgt Liste	*/
	[139, "ND_FCL", "IF"], /*  Fin Chrgt Liste	*/
	[140, "ND_ICL", "IF2c"], /*  Inter Chgt Liste	*/
	[141, "NDOMNCO", "BSUSUF"], /*  Option Menu Surg.	*/
	[142, "NDAFTB", "IBSF"], /*  Disable un Tableau	*/
	[143, "NDCHGR", "BF"], /*  Actzo/Grizo/Diszo	*/
	[144, "NDRZLS", "IF"], /*  Effacement Liste	*/

	[147, "NDINED", "BUF"], /*  Saisie Editeur	*/
	[149, "NDOARB", "LSSBF"], /*  Ouverture Arbre	*/
	[150, "NDOCAR", "IBAF"], /*  Creation Col. Arbre	*/
	[151, "NDOLAR", "ISBUAAAF"], /*  Creat. Ligne Arbre	*/
	[152, "ND_NAP", "UF"], /*  Nouvelle Session	*/
	[153, "NDGLAR", "IAF"], /*  Allez a Lg Arbre	*/
	[154, "NDRZAR", "IF"], /*  Effacement Arbre	*/
	[155, "ND_DCA", "UF"], /*  Debut Chgt Arbre	*/
	[156, "ND_FCA", "UF"], /*  Fin Chrgt Arbre	*/
	[157, "ND_REB", "17UF"], /*  Reboot Serveur	*/
	[158, "NDOMSG", "BBFs"], /*  Ouvre Messagerie	*/
	[159, "NDEDBK", "XFxx"], /*  Editeur de Blocs	*/
	[160, "NDULLS", "IAF"], /*  Desel Ligne Liste	*/
	[161, "NDULAR", "IAF"], /*  Desel Ligne Arbre	*/
	[162, "NDPKLS", "IF"], /*  Picking		*/
	[163, "NDPKAR", "IF"], /*  Picking Hierarchise	*/
	[164, "NDGTDT", "F"], /*  Destinataires	*/
	[165, "NDGTIM", "F"], /*  Imprimantes		*/
	[166, "NDCHLP", "ISSUF"], /*  Aide d'un Objet	*/
	[167, "NDCTTP", "ISSUF"], /*  ToolTip d'un Objet	*/
	[168, "NDCTIT", "IUF"], /*  Titre d'un Objet	*/
	[169, "ND_OCX", "F"], /*  Interface avec OCX	*/
	[170, "NDOFML", "UF"], /*  Ouverture Formule	*/
	[171, "NDOFLD", "IUUUSUUF"], /*  Ouverture Champs	*/
	[172, "NDDSLB", "BF"], /*  Desactiv Libelle	*/
	[173, "ND_IHM", "F"], /*  Interface avec IHM	*/
	[174, "NDDTLB", "!"], /*  Desactiv Libelle	*/
	[175, "ND_LIM", "F"], /*  Interface avec LIM	*/
	[176, "NDRESUL", "ISSUBSF"], ];

var NODES = [];
var MAP = {}

DESCS.forEach(function(node) {
	var pat = node[2] || "";
	var params = pat.split('F')[0];
	var acks = pat.split('F')[1] || "";
	var lists = params.split('[')[1] || "";
	params = params.split('[')[0];
	var n = {
		id: node[0],
		name: node[1],
		params: params,
		lists: lists,
		acks: acks,
		def: 0,
	};
	NODES[node[0]] = n;
	MAP[node[1]] = n;
})

NODES.forEach(function(node) {
	node.def = NODES[0];
})
MAP.ND_CLT.def = null;
MAP.NDOWIN.def = null;
MAP.ND_REB.def = null;

function resolve(v) {
	if (v === 0) return;
	else if (!MAP[v]) throw new Error("bad key: " + v);
	return MAP[v];
}

MAP.ND_RCN.transitions = [ //
"ND_RCN", 0, 0, 0, 0, 0, 0, 0, //
0, 0, 0, 0, 0, 0, "NDEXT", 0, //
0, "ND_CMVD", "NDIMPR", "ND_INP" //
].map(resolve);

MAP.NDEXT.transitions = [ //
0, "NDOPEN", "ND_RAT", "ND_EVT", "NDTBLK", 0, 0, 0, //
0, 0, "NDSUPLI", "NDINSLI", "NDSATAN", 0, 0, 0, //
0, 0, 0, 0, "ND_CLF", "ND_CLT", "NDDTOB", 0, //
0, "ND_REB", "ND_NAP", 0, 0, 0, "NDGIST", "NDCHGR", //
"NDMIST", 0, "NDCTSU", 0, "ND_DCL", "ND_FCL", "NDAFTB", "NDRZLS", //
"NDGLLS", "NDULLS", 0, 0, 0, "NDRZAR", "NDGLAR", "ND_DCA", //
"ND_FCA", "NDULAR", "NDCHTIT", "NDCTIT", "NDCSTL", 0, 0, 0, //
0, 0, 0, 0, "NDACTOBJ", 0, 0, "NDFIMG", //
"NDACTOP", 0, "NDAJLB", "NDCHFM", "NDDSLB", 0, 0, "NDCOPMENU", //
"NDIHLP", "NDITTP", "NDCHLP", "NDCTTP" //
].map(resolve);

MAP.ND_CMVD.transitions = [ //
0, 0, 0, 0, 0, "ND_INT", 0, 0, //
0, 0, "NDSYSTEM", 0, 0, 0, 0, 0, //
"ND_ICL", "ND_CRD", "NDINED", "NDEDBK", 0, "NDAFRE", 0, "NDPKLS", "NDPKAR", //
0, 0, 0, 0, 0, 0, 0, 0, //
0, 0, 0, 0, 0, 0, 0, 0, //
0, 0, 0, 0, 0, 0, 0, 0, //
0, 0, 0, 0, 0, 0, 0, 0, //
0, 0, 0, 0, 0, 0, 0, 0, //
0, 0, "NDCHCR", 0, 0, "NDCHVL", "NDCHVB" //
].map(resolve);

MAP.NDOPEN.transitions = [ //
0, "NDDEB", "NDOFENB", "NDOFENH", "NDOFENA", "NDOFENP", "NDODIAG", "NDODGSB", //
"NDOBOXI", 0, "NDOBOXE", "NDOBOXW", "NDOBOXQ", "NDOBOXS", "NDOBOXI", 0, //
0, 0, 0, 0, "NDOBOUT", "NDOTBL", "NDOCTB", "NDOGRD", //
"NDOBRD", "NDOCMB", "NDOFRM", "NDOBOG", "NDOONG", "NDOCSX", "NDCREUX", "NDOBPG", //
"NDOIMG", "NDOLST", "NDOCLS", "NDOLLS", "NDOJLB", "NDOPFN", 0, "NDOFML", //
"NDOFLD", "NDOARB", "NDOCAR", "NDOLAR", 0, 0, 0, 0, //
0, 0, 0, 0, 0, 0, 0, 0, //
0, 0, 0, 0, 0, 0, 0, 0, //
0, 0, 0, 0, 0, 0, 0, "NDOTXSC", //
0, 0, 0, 0, 0, 0, 0, 0, //
0, "NDACV", 0, 0, 0, 0, 0, "NDOWIN", //
0, 0, 0, 0, 0, 0, "NDOMNCO", "NDOMENC", //
"NDOMNAO", "NDOMNBO", "NDOMENA", "NDOMENB" //
].map(resolve);

MAP.NDIMPR.transitions = [ //
0, "NDOUVIMP", "ND_IMF", 0, 0, "NDOMSG", "NDGTDT", "NDGTIM", //
"ND_OCX", "ND_IHM", "ND_LIM", "ND_GFD", "ND_SLF" //
].map(resolve);

MAP.ND_INP.transitions = [ //
0, "NDRESUL" //
].map(resolve);

var HANDLERS = NODES.map(function(node) {
	return function() {
		var args = Array.prototype.slice.call(arguments, 3);
		console.log("NODE HANDLER: " + node.name + JSON.stringify(args));
		return [0];
	}
});

function readVal(req, letter) {
	switch (letter) {
	case 'B':
		return req.nextByte();
	case 'S':
		return req.nextShort();
	case 'L':
		return req.nextLong();
	case 'U':
		return req.nextString();
	case 'I':
		return req.nextIst();
	case 'A':
		return req.nextBuf();
	default:
		throw new Error("bad arg char: " + letter);

	}
}

function readListVal(req, letter) {
	switch (letter) {
	case 'U':
		return req.nextClob();
	default:
		throw new Error("bad list char: " + letter);

	}
}

function readList(_, ctx, letter) {
	var list = [];
	while (true) {
		var head = ctx.stream.read(_, 5);
		var len = head.readInt32BE(1);
		if (len < 0) throw new Error("bad list len: " + len);
		if (len === 0) return list;
		var req = new Request(head[0], len, ctx.stream.read(_, len));
		console.log("YYY=" + letter);
		list.push(readListVal(req, letter))
	}
}

function writeVal(_, ctx, letter, val) {
	var stream = ctx.stream;
	switch (letter) {
	case 'B':
		stream.write(_, new Buffer([val]));
		break;
	default:
		throw new Error("bad ack char: " + letter);
	}
}

function writeVals(_, ctx, letter, vals) {
	var stream = ctx.stream;
	console.log("vals=" + vals);
	for (var i = 0; i < vals.length; i++) {
		var val = vals[i];
		switch (letter) {
		case 'U':
			var buf = new Buffer(5);
			buf[0] = 0;
			buf.writeInt32BE(val.length, 1);
			stream.write(_, buf);
			stream.write(_, new Buffer(val, "utf8"));
			break;
		default:
			throw new Error("bad ack char: " + letter);
		}
	}
	var buf = new Buffer(5);
	buf.fill(0);
	stream.write(_, buf);
}

function processNode(_, ctx, req, node) {
	var handler = ctx.handlers[node.id];
	if (!handler) return;
	var args = [_, ctx, req];
	var params = node.params;
	for (var i = 0; i < params.length; i++) {
		if (params[i] === 'A') req.ensure(_, ctx, req.peekShort() + 2);
		else if (params[i] === 'U') req.ensure(_, ctx, req.peekShort() + 2);
		args.push(readVal(req, params[i]))
	}
	var lists = node.lists;
	for (var i = 0; i < lists.length; i++) {
		console.log("XXX=" + lists[i]);
		args.push(readList(_, ctx, lists[i]));
	}
	var results = handler.apply(null, args);
	console.log("results=" + results);
	var acks = node.acks;
	var ack = 0;
	for (var i = 0; i < acks.length; i++) {
		if (acks[i] === '[') {
			i++;
			writeVals(_, ctx, acks[i], results[ack])
		} else {
			writeVal(_, ctx, acks[i], results[ack]);
		}
		ack++;
	}
}

function processRequest(_, ctx, req, node) { /*  Caractere a Traite  */
	var car = req.nextByte();
	if (car == 0) return node;

	while (node) {
		console.log("node=" + node.name + ", car=0x" + car.toString(16));
		if (node.transitions) {
			var nextNode = node.transitions[car];
			if (nextNode) {
				console.log("transition to " + nextNode.name);
				if (node.finish) node.finish(_, ctx, req, car);
				processNode(_, ctx, req, nextNode);
				node = nextNode;
				car = req.nextByte();
				if (car == 0) return nextNode.def;
				else continue;
			}
		}

		/*  Fausse transition vers le Noeud Defaut  */
		if (node === node.def) throw new Error("infinite loop")
		console.log("transition to default");
		node = node.def;
	}
	return null;
}

function readRequest(_, ctx) {
	var head = ctx.stream.read(_, 3);
	var len = (head[1] >> 8) | head[2];
	return new Request(head[0], len, len ? ctx.stream.read(_, len) : new Buffer());
}

// was setting def to -40!!!

function process(_, ctx) {
	var req, node = NODES[0];
	do {
		req = readRequest(_, ctx);
		while (req.peek() > 0 && node) {
			node = processRequest(_, ctx, req, node);
		}
	} while (node);
}

function Request(wnd, len, data) {
	this.wnd = wnd;
	this.len = len;
	this.pos = 0;
	this.data = data;
}

Request.prototype.peek = function() {
	return this.pos < this.len ? this.data[this.pos] : -1;
}
Request.prototype.nextByte = function() {
	return this.pos < this.len ? this.data[this.pos++] : 0;
}
Request.prototype.nextShort = function() {
	return this.pos < this.len - 1 ? (this.data[this.pos++] << 8) | this.data[this.pos++] : 0;
}
Request.prototype.nextLong = function() {
	return this.pos < this.len - 3 ? (this.data[this.pos++] << 24) | (this.data[this.pos++] << 16) //
	| (this.data[this.pos++] << 8) | this.data[this.pos++] : 0;
}

Request.prototype.peekShort = function() {
	var pos = this.pos,
		val = this.nextShort();
	this.pos = pos;
	return val;
}

Request.prototype.nextLongLong = function() {
	return this.pos < this.len - 7 ? (this.nextLong() << 32) | this.nextLong() : 0;
}
Request.prototype.nextIst = function() {
	return this.pos < this.len - 5 ? (this.nextLong() << 32) | this.nextShort() : 0;
}
Request.prototype.nextString = function() {
	var len = this.nextShort() - 2; // next short is included in byte count!
	var nchars = this.nextShort();
	var str = this.data.slice(this.pos, this.pos + len).toString('utf8');
	this.pos += len;
	if (str.length < nchars) throw new Error("bad string: expected " + nchars + ", got " + str.length);
	if (str.length > nchars) {
		console.log("string too long: " + (str.length - nchars) + " extra, ignoring: '" + str.substring(nchars) + "'");
		str = str.substring(0, nchars);
	}
	return str;
}
Request.prototype.nextBuf = function() {
	var len = this.nextShort();
	//console.log("nextBuf len=" + len + ", pos=" + this.pos + ", data.len=" + this.data.length);
	//console.log(this.data.slice(this.pos));
	var buf = this.data.slice(this.pos, this.pos + len);
	this.pos += len;
	return buf;
}
Request.prototype.nextClob = function() {
	if (this.pos !== 0) throw new Error("invalid call: pos=" + this.pos);
	var str = this.data.toString('utf8');
	this.pos = this.len;
	return str;
}
Request.prototype.ensure = function(_, ctx, len) {
	var missing = this.pos + len - this.data.length
	if (missing > 0) this.data = Buffer.concat([this.data, ctx.stream.read(_, missing)]);
}

function Stream() {
	this.bufs = [];
	this.bufi = 0;
	this.written = new Buffer(0);
	this.pos = 0;
}

Stream.prototype.Add = function(bytes, odd) {
	if (this.bufs.length % 2 !== odd) this.bufs.push(new Buffer(0));
	this.bufs[this.bufs.length - 1] = Buffer.concat([this.bufs[this.bufs.length - 1], new Buffer(bytes)]);
}

Stream.prototype.AddRead = function(bytes) {
	//console.log("add read: " + new Buffer(bytes).toString("ascii"));
	return this.Add(bytes, 1);
}
Stream.prototype.AddWrite = function(bytes) {
	console.log("add write: " + new Buffer(bytes).toString("ascii"));
	return this.Add(bytes, 0);
}

Stream.prototype.read = function(_, len) {
	if (this.bufi % 2 !== 0) {
		var got = this.written.toString("hex");
		var expected = this.bufs[this.bufi].toString("hex");
		if (got != expected) {
			var cut = 0;
			while (cut < got.length && got[cut] === expected[cut]) cut++;
			throw new Error("write mismatch: " + this.bufi + ", expected " + expected + ", got=" + got + 
				", near:" + got.substring(cut) + '\ntext=' + this.bufs[this.bufi].toString("ascii").replace(/\u0000/g, '.'));
		}
		this.bufi++;
		this.pos = 0;
	}
	var buf = this.bufs[this.bufi];
	if (this.pos + len > buf.length) throw new Error("read past end: pos=" + this.pos + "/" + buf.length + ", len=" + len);
	var data = buf.slice(this.pos, this.pos + len);
	this.pos += len;
	console.log("stream read: " + data.toString('hex'));
	return data;
}

Stream.prototype.write = function(_, data) {
	console.log("stream write: " + data.toString('hex'));
	if (this.bufi % 2 !== 1) {
		var total = this.bufs[this.bufi].length;
		if (this.pos !== total) throw new Error("unread bytes: " + this.bufi + ", consumed=" + this.pos + ", total=" + total);
		this.bufi++;
		this.written = new Buffer(0);
	}
	this.written = Buffer.concat([this.written, data]);
	console.log("************************************************************");
}

HANDLERS[MAP.ND_SLF.id] = function(_, ctx, req, actions) {
	console.log("ND_SLF: " + actions);
	console.log(actions);
	if (actions[0].indexOf('UIAction=\u0001SetTechnoVers') === 0) {
		return [["UIAction=\u0001SetTechnoVers\n", "Id=\u00012\n", "Version=\u0001null.null\n", "Protocol=\u0001150067\n"]];
	} else {
		throw new Error("unhandled UIAction: " + actions[0]);
	}
}
HANDLERS[MAP.ND_GFD.id] = function(_, ctx, req, actions) {
	console.log("ND_GFD: " + actions);
	console.log(actions);
	if (actions[0] === 'X3Version\n') {
		return [["X3Version=\u0001X3Version : unsupported param\n"]];
	} else {
		throw new Error("unhandled UIAction: " + actions[0]);
	}
}
exports.newContext = function() {
	return {
		stream: new Stream(),
		handlers: HANDLERS
	};
}
exports.process = process;