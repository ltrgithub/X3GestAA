"use strict";

var helpers = require("syracuse-core/lib/helpers");

var TrackerResponse = helpers.defineClass(function() {
    this.status = 202;
    this.head = {"content-type" : "application/json"};
    this.encoding =  "utf8";
    this.chunks = [];
    this.isFinished = false;
    this.isFlushed = false;
}, null, {
    writeHead: function(status, head) {
        if (status!=null) this.status = status;
        if (head!=null) {
        	for (var p in head) this.head[p]=head[p];
        }
		this.head["conv-async"] = "true";
    },
    write: function(data) {
        if (data!=null) this.chunks.push(typeof data =="string" ? data : JSON.stringify(data));
    },
    finish: function(statusCode, data) {
        this.isFinished = true;
        this.writeHead(statusCode,data.head);
        this.write (data.body);
    },
    flush: function(_, response) {
    	 this.isFlushed=true;
        response.writeHead (this.status, this.head);
        for (var i = 0; i < this.chunks.length; i++) {
        	response.write(_, this.chunks[i], this.encoding);
        }
        response.end();
    },
    end: function(data) {
        if (data) this.chunks.push(data);
    }
});

var _log=function(tracker, txt){
	console.log("[" +  tracker._trackId + "] "+(new Date().getTime() - tracker._startTime) + "  " + txt);		
}
_log = null;

exports.cvgTracker = helpers.defineClass(function(_, context, trackId, cvgClient, isConnect) {
	this._trackId = trackId;
	this.client = cvgClient;
	this.isConnect = isConnect;
	this.partialResponse ;
    this._timeoutId=null;
    this._location = context.path +(isConnect ? "('"+cvgClient._cvgSession.sid+"')":"") + "?$trackers=" + trackId + "";
    this._startTime = 0;
    this._trackResponse = null;
    this._tracked = false;
   }, null, {
	   // response : httpResponse to write request content
    track: function(_, response) {
		var self = this;
		if (self._timeoutId != null){
    		_log && _log(self, "\tclearTimeout");
			clearTimeout(self._timeoutId);
			self._timeoutId = null;
		}
		self._tracked = true;
		_log && _log(self, "tracker.TRACK - isFinished[" + self.isFinished() + "]");
    	try{
			if (self.isFinished()) {
				// Original request completed -> Send response to client
				self._trackResponse.flush(_, response);				
			}else {
				// Original request not completed -> Send tracking response to client
				// --> self._location is the tracking url which will be used by client
				response.writeHead(202, {
					"content-type": "application/json",
					location: self._location,
				});
				var respJson = self.client.getResponse(self.isConnect,true);
				// We don't send partial responses in record mode
				if (self.client.recorder == null) self.client.razModification(); 
				var body = JSON.stringify({
					phase: "Tracking",
					elapsedSeconds:  new Date().getTime() - self._startTime,
					pollingMillis: 1000,
					// unused
					phaseDetail: "",
					progress: null,
					remainingSeconds: 0,
					// We don't send partial responses in record mode
					reply : self.client.recorder == null ? respJson :{}
				});
				response.write(_, body, "utf8");
				response.end();
			} 
    	}catch(e){
    		_log && _log(self, "\ttracker.TRACK.ERROR - " + (e.stack ? e.stack : e.message ? e.message : e));
    		throw e;
    	}
    },
	start: function(_, context, waitMs){
		var self = this, excep=null;
	    self._startTime = new Date().getTime();
	    self._startResponse = context.response;
	    // Substitute context.response by _trackResponse to collect data sent by long process
	    // -> Not used - Data sent by long process are passed  in stop method data parameter
	    // -> If used we need to define a protocol for client and change _trackResponse.write and finish methods 
	    context.response = self._trackResponse = new TrackerResponse();
		_log && _log(this, "tracker.START - waitMs=" + waitMs);
	    if (waitMs>0){
	    	// Wait waitMs before sending tracking response
	    	// -> If tracker.stop occurs before waitMs, timeout is canceled and request's response is sent to client
	    	// -> If If tracker.stop occurs before waitMs, tracking response is sent to client
			self._timeoutId = setTimeout(function(_){
				_log && _log(this, "\ttracker.track.begin.timeout");
				self.track(_, self._startResponse);
				_log && _log(this, "\ttracker.track.end.timeout");
			}, waitMs);
	    }else{
	    	// Send tracking response to client
	    	// -> 2 requests will be sent by client in any cases -1- requestSvc -2- tracking request
			self.track(_, self._startResponse);
	    }
	},
	stop:function(_, context, data, statusCode){
		var self = this;
		_log && _log(this, "\ttracker.STOP - " + statusCode);
		self._trackResponse.finish (statusCode, data);	
		// _tracked = true
		// --> If a tracking response has been sent we need to wait next tracking request to send the original resquest's response
		// _tracked = false
		// --> If not (reply received before waitMs start delay) we send the response in context.response
		if (!self._tracked) {
			// If no tracking - Restore original context response
			context.response = self._startResponse;
			self.track(_, context.response);
		}
	},
	destroy:function(_){	
		var self = this;
		self._startResponse = null;
		self._startResponse = null;
		_log && _log(self, "tracker.DESTROY");
		if (self._timeoutId != null){
			clearTimeout(self._timeoutId);
			self._timeoutId = null;
		}
	},
	isFinished:function(){
		return this._trackResponse == null || this._trackResponse.isFinished;
	},
	isFlushed:function(){
		return this._trackResponse == null || this._trackResponse.isFlushed;
	}
});




