"use strict";

var helpers = require("syracuse-core/lib/helpers");
var flows = require('streamline-runtime').flows;
var config = require('config');
var tracerAction = require('syracuse-core/lib/trace').getTracer("classic.action");

var TrackerResponse = helpers.defineClass(function() {
	this.status = 202;
	this.head = {
		"content-type": "application/json"
	};
	this.encoding = "utf8";
	this.chunks = [];
	this.isFinished = false;
	this.isFlushed = false;
}, null, {
	writeHead: function(status, head) {
		if (status != null) this.status = status;
		if (head != null) {
			for (var p in head) this.head[p] = head[p];
		}
		this.head["conv-async"] = "true";
	},
	write: function(data) {
		if (data != null) this.chunks.push(typeof data == "string" ? data : JSON.stringify(data));
	},
	finish: function(statusCode, data) {
		this.isFinished = true;
		this.writeHead(statusCode, data.head);
		this.write(data.body);
	},
	flush: function(_, response) {
		this.isFlushed = true;
		for (var i = 0, len = 0, count = this.chunks.length; i < count; i++) {
			var chunk = this.chunks[i];
			if (!Buffer.isBuffer(chunk)) this.chunks[i] = chunk = new Buffer(chunk, this.encoding);
			len += chunk.length; // length is always length in bytes
		}
		this.head["content-length"] = len;
		response.writeHead(this.status, this.head);

		for (i = 0; i < count; i++) {
			response.write(_, this.chunks[i]);
		}
		response.end();

	},
	end: function(data) {
		if (data) this.chunks.push(data);
	}
});

var _log = function(tracker, txt) {
	console.error("[" + tracker._trackId + "] " + (new Date().getTime() - tracker._startTime) + "  " + txt);
};
_log = null;

exports.CvgTracker = helpers.defineClass(function(context, trackId, cvgClient, isConnect) {
	this._trackId = trackId;
	this.observer = cvgClient;
	this.isConnect = isConnect;
	this._pollingMillis;
	this.partialResponse;
	this._timeoutId = null;
	this._location = context.path + (isConnect ? "('" + cvgClient._cvgSession.sid + "')" : "") + "?$trackers=" + trackId + "";
	this._startTime = 0;
	this._trackResponse = null;
	this._tracked = false;
}, null, {
	// response : httpResponse to write request content
	track: function(_, response) {
		var self = this;
		if (self._timeoutId != null) {
			_log && _log(self, "\tclearTimeout");
			clearTimeout(self._timeoutId);
			self._timeoutId = null;
		}
		self._tracked = true;
		_log && _log(self, "tracker.TRACK - isFinished[" + self.isFinished() + "]");
		try {
			if (self.isFinished()) {
				// Original request completed -> Send response to client
				//console.log("resp " + JSON.stringify(self.observer.response.body, null, 2));
				self._trackResponse.flush(_, response);
			} else {
				// Original request not completed -> Send tracking response to client
				// --> self._location is the tracking url which will be used by client

				var head = {
					"content-type": "application/json",
					location: self._location,
				};
				self.observer.generateResponse(_, self.isConnect, false);

				var pollingMillis = self._pollingMillis ? self._pollingMillis : 1000;

				response.writeHead(202, head);
				var partialResp = self.observer.response.body;
				// We don't send partial responses in record mode
				if (self.observer.recorder == null) self.observer.razModification(); // TODO check why in certain case download are still present
				var body = JSON.stringify({
					phase: "Tracking",
					elapsedSeconds: new Date().getTime() - self._startTime,
					pollingMillis: pollingMillis,
					// unused
					phaseDetail: "",
					progress: null,
					remainingSeconds: 0,
					// We don't send partial responses in record mode
					reply: self.observer.recorder == null ? partialResp : {},
				});

				response.end(body, "utf8");
				if (partialResp) {
					tracerAction.info && tracerAction.info("************************************");
					tracerAction.info && tracerAction.info("Partial response:\n" + JSON.stringify(partialResp, null, 2));
					tracerAction.info && tracerAction.info("************************************");
				}
			}
		} catch (e) {
			_log && _log(self, "\ttracker.TRACK.ERROR - " + (e.stack ? e.stack : e.message ? e.message : e));
			throw e;
		}
	},
	start: function(_, context, waitMs) {
		var self = this,
			excep = null;
		self.context = context;
		self._pollingMillis = waitMs;
		self._startTime = new Date().getTime();
		self._startResponse = context.response;
		// Substitute context.response by _trackResponse to collect data sent by long process
		// -> Not used - Data sent by long process are passed  in stop method data parameter
		// -> If used we need to define a protocol for client and change _trackResponse.write and finish methods 
		context.response = self._trackResponse = new TrackerResponse();
		_log && _log(this, "tracker.START - waitMs=" + waitMs);
		if (waitMs > 0) {
			// Wait waitMs before sending tracking response
			// -> If tracker.stop occurs before waitMs, timeout is canceled and request's response is sent to client
			// -> If If tracker.stop occurs before waitMs, tracking response is sent to client
			self._timeoutId = flows.setTimeout(function(_) {
				_log && _log(self, "\ttracker.track.begin.timeout");
				self.track(_, self._startResponse);
				_log && _log(self, "\ttracker.track.end.timeout");
			}, waitMs);
		} else {
			// Send tracking response to client
			// -> 2 requests will be sent by client in any cases -1- requestSvc -2- tracking request
			self.track(_, self._startResponse);
		}
	},
	stop: function(_, context, data, statusCode) {
		var self = this;
		_log && _log(this, "\ttracker.STOP - " + statusCode);
		self._trackResponse.finish(statusCode, data);
		// _tracked = true
		// --> If a tracking response has been sent we need to wait next tracking request to send the original resquest's response
		// _tracked = false
		// --> If not (reply received before waitMs start delay) we send the response in context.response
		if (!self._tracked) {
			// If no tracking - Restore original context response
			context.response = self._startResponse;
			self.track(_, context.response);
		}
	},
	destroy: function(_) {
		var self = this;
		self._startResponse = null;
		self._startResponse = null;
		_log && _log(self, "tracker.DESTROY");
		if (self._timeoutId != null) {
			clearTimeout(self._timeoutId);
			self._timeoutId = null;
		}
	},
	isFinished: function() {
		return this._trackResponse == null || this._trackResponse.isFinished;
	},
	isFlushed: function() {
		return this._trackResponse == null || this._trackResponse.isFlushed;
	}
});