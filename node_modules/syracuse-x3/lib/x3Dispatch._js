"use strict";

var fs = require('streamline-fs');
var helpers = require("syracuse-core/lib/helpers");
var sessionManager = require('syracuse-session/lib/sessionManager').sessionManager;
var Context = require("syracuse-sdata/lib/sdataContext").Context;
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var locale = require("syracuse-core/lib/locale");
var streams = require("streamline/lib/streams/streams");
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var cvgServices = require("./cvgServices");
var x3helpers = require("./helpers");
var boRestClient = require("syracuse-x3/lib/boRestClient");
var globals = require("streamline/lib/globals");

var _tracer = null;
var _profiler = null;
var _config = {};

function getProtoUrl(_, context) {
	if (!context && !context.endpoint) return null;
	return context.endpoint.getFusionPrototypeUrl(_, {
		// required
		secure: context.secure,
		langCode: locale.extractLocaleCode(context.request.headers["accept-language"]),
		prototypeId: context.prototypeId,
		// optional
		prototypesLocalServerRoot: _config && _config.prototypesLocalServerRoot,
		prototypesFolder: _config && _config.prototypesFolder
	});
}

function _parseSegment(segment) {
	var match = /^([^\/(]*)\('([^']*)'\)$/.exec(segment);
	return match ? {
		name: match[1],
		id: match[2]
	} : {
		name: segment
	};
}

function _dispatch(_, context, map) {
	var seg = context.walkUrl();
	if (seg == null) {
		// we reached the end of the URL, dispatch method
		//var method = context.request.method.toLowerCase();
		var method = context.method;
		if (map[method]) return map[method](_, context);
		else throw context.badMethod(method);
	} else {
		var pair = _parseSegment(seg);
		if (pair.name[0] == '$') {
			var name = pair.name.substring(1);
			if (map[name]) {
				return map[name](_, context, pair.id);
			}
		} else if (map.walk) {
			return map.walk(_, context, pair.name, pair.id);
		}
		throw context.badRequest(locale.format(module, "unexpectedSegment", seg));
	}
}

var _fusionMap = {
	walk: function(_, context, name, id) {
		context.applicationName = name;
		return _dispatch(_, context, _applicationMap);
	}
};

// URL is http://host/x3/app
var _applicationMap = {
	walk: function(_, context, name, id) {
		context.contractName = name;
		//

		var app = adminHelper.getApplication(_, context.applicationName, context.contractName);
		if (!app || (app && app.protocol(_) !== "x3")) throw context.notFound(locale.format(module, "applicationNotFound", context.applicationName, context.contractName));
		context.applicationRef = app;
		//
		return _dispatch(_, context, _contractMap);
	}
};

// URL is http://host/sdata/app/contract
var _contractMap = {
	walk: function(_, context, name, id) {

		if (context.applicationRef) { // TEST to allow stubs
			// find the endpoint
			var ep = adminHelper.getEndpoint(_, {
				application: context.applicationName,
				contract: context.contractName,
				dataset: name
			});

			if (!ep) throw context.notFound(locale.format(module, "endpointNotFound", context.applicationName, context.contractName, name));
			context.endpoint = ep;
			//
			context.baseUrl = context.walked();
		}
		return _dispatch(_, context, _datasetMap);
	}
};

// URL is http://host/sdata/app/contract/dataset
// reply to prototypes request, delegate everything else to cvgServices
var _datasetMap = {
	walk: function(_, context, name, id) {
		throw new Error(locale.format(module, "unexpectedSegment", name));
	},
	"proxy-bo": function(_, context, id) {
		return boRestClient.forward(_, context, "/" + context.toWalk(), _config);
	},
	prototypes: function(_, context, id) {
		if (id) {
			context.prototypeId = id;
			return _dispatch(_, context, _prototypeMap);
		} else {
			// NYI
			throw new Error(locale.forat(module, "NYI"));
		}
	},
	plugin: function(_, context, id) {
		context.cvgSessionId = id; // TODO add parameter to make a difference with multiple plugin.
		context.observer = "_cvgClient.cvgPlugin.ND_IHM.ilog";

		//console.log(require("util").inspect(context));
		return _dispatch(_, context, _connectMap);
	},
	sessions: function(_, context, id) {
		context.cvgSessionId = id;
		context.observer = "_cvgClient";

		return _dispatch(_, context, _connectMap);
	},
	files: function(_, context, id) {
		cvgServices.webProxy(_, context, context.endpoint.x3ServerFolder(_) + "/" + context.toWalk(), _config);
	},
	shared: function(_, context, id) {
		cvgServices.webProxy(_, context, "X3_ROOT/" + context.toWalk(), _config);
	}
};

function getPrototypeStubResp(_, context, protoUrl, getPrototypeResp) {
	var fs = require('streamline-fs');
	var fsp = require('path');
	// url is like '/sdata/contract/application/dataset/$prototypes('name.type.variant')',
	var path = protoUrl.split("/").slice(1);
	// helpers.stubsPath is to be deprecated
	var stubsPath = ((globals.context.config || {}).system || {}).stubsPath || helpers.stubsPath;
	path[0] = stubsPath;
	path = path.join("/");
	var proto = null;
	try {
		proto = JSON.parse(fs.readFile(fsp.join(__dirname, "../../..") + "/" + path, "utf8", _));
	} catch (err) {
		if (err.code !== "ENOENT") throw err;
		var root = _config.prototypesLocalServerRoot;
		delete _config.prototypesLocalServerRoot;
		var resp = getPrototypeResp(_, getProtoUrl(_, context));
		_config.prototypesLocalServerRoot = root;
		return resp;
	}
	return {
		statusCode: 200,
		readAll: function(_) {
			return {
				toString: function(enc) {
					return proto && JSON.stringify(proto);
				}
			};
		}
	};
}

//URL is http://host/sdata/app/contract/dataset/$prototypes('id')
var _prototypeMap = {
	get: function(_, context) {
		function getPrototypeResp(_, protoUrl) {
			// make a request to the web server for entity.xml
			var options = {
				url: protoUrl,
				method: "GET",
				headers: {
					"accept-charset": "utf-8"
				}
			};
			_tracer && _tracer("x3dispatch.prototype.get url:\n\t" + protoUrl);
			// helpers.stubsPath is to be deprecated
			var stubsPath = ((globals.context.config || {}).system || {}).stubsPath || helpers.stubsPath;
			if (stubsPath && _config.prototypesLocalServerRoot && protoUrl.indexOf(_config.prototypesLocalServerRoot) === 0) {
				return getPrototypeStubResp(_, context, protoUrl, getPrototypeResp);
			}
			var request = streams.httpRequest(options);
			return request.end().response(_);
		}
		var response = getPrototypeResp(_, getProtoUrl(_, context));
		if (response.statusCode == 200) {
			var responseStr = response.readAll(_).toString("utf8");
			_tracer && _tracer("x3dispatch.prototype.get content: " + responseStr);
			// content language should be forced here as we've got the prototype into a language dependent folder
			var lang = locale.extractLocaleCode(context.request.headers["accept-language"]) || locale.current;
			try {
				context.reply(_, 200, JSON.parse(responseStr), {
					"content-language": lang
				});
			} catch (e) {
				throw new Error("Error parsing X3 function prototype\n" + getProtoUrl(_, context) + "\n\n" + e.message);
			}
		} else {
			context.reply(_, response.statusCode);
		}
	}
};

function getErroReply(ex) {
	var bdy = null;
	if (ex.toJson) {
		// ex is a fusion error
		bdy = ex.toJson();
	} else {
		bdy = {
			$message: x3helpers.errShortPath(ex.message ? ex.message : ex.toString()),
			"$diagnoses": [{
				message: x3helpers.errShortPath(ex.stack ? ex.stack : ex.toString())
			}],
			"$origin": "NodeJS: convergence Server - x3Dispatch",
			// tells cvg client how to deal with server session - can be null
			$recoveryCode: ex.recoveryCode || '',
			$severity: "ERROR"
		};
		if (ex.stack) {
			bdy.$diagnoses = [{
				$stackTrace: ex.stack
			}];
		}
	}
	return bdy;
}

var _connectMap = {
	walk: function(_, context, name, id) {
		// proxy use all segments after sessions but it has allready been walked. So unwalk a segment
		context.unwalkUrl();
		cvgServices.proxy(_, context, _config);
	},
	get: function(_, context) {
		cvgServices.proxy(_, context, _config);
	},
	post: function(_, context) {
		// it's the connect method that dump result in http response
		cvgServices.connect(_, context, _config);
	},
	"delete": function(_, context) {
		for (var i in context.parameters) {
			if (i.indexOf("sid_") > -1) {
				var sid = context.parameters[i];
				context.httpSession.closeCvgSession(sid, false, "Closed by client (Delete)", _);
			}
		}
		context.httpSession.closeCvgSession(context.cvgSessionId, context.parameters, "Closed by client (Delete)", _);
		context.replyDeleted(_);
	}
};

function _doIt(_, context) {
	try {

		var protocol = context.walkUrl();
		if (protocol != "trans" && protocol != "bo") throw new Error(locale.format(module, "badUrl", "trans", protocol));
		_dispatch(_, context, _fusionMap);
	} catch (ex) {
		// Catchs all exceptions and sends a fusion error message to the client
		_tracer && _tracer("x3dispatcher.main - Error\n", ex.toString());
		var bdy = null;
		if (ex.toJson) {
			// ex is a fusion error
			bdy = ex.toJson();
		} else {
			bdy = {
				$message: x3helpers.errShortPath(ex.message ? ex.message : ex.toString()),
				"$diagnoses": [{
					message: x3helpers.errShortPath(ex.stack ? ex.stack : ex.toString())
				}],
				"$origin": "NodeJS: convergence Server - x3Dispatch",
				// tells cvg client how to deal with server session - can be null
				$recoveryCode: ex.recoveryCode || '',
				$severity: "ERROR"
			};
			if (ex.stack) {
				bdy.$diagnoses = [{
					$stackTrace: ex.stack
				}];
			}
		}
		return context.reply(_, ex.httpStatus == null ? 500 : ex.httpStatus, bdy, ex.httpHeaders || null);
	}

}

exports.x3dispatcher = function(config) {
	// setup config here
	_config = (config && config.x3fusion) || {};
	_tracer = _config.tracer;
	_profiler = _config.profiler;
	//
	return function(_, request, response) {
		var context = new Context(request, response);
		request.context = context;
		_doIt(_, context);
	};
};