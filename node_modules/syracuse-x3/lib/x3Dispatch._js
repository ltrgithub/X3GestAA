"use strict"

var helpers = require("syracuse-core/lib/helpers");
var Context = require("syracuse-sdata/lib/sdataContext").Context;
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var locale = require("syracuse-core/lib/locale");
var streams = require("streamline/lib/streams/streams");
var xmlToProto = require("./xmlToProto");
var x3FusionPool = require("./fusionPool");
var util = require("util");

var tracer = null;
var profiler = null;
var _config = {};

function _parseSegment(segment) {
	var match = /^([^\/(]*)\('([^']*)'\)$/.exec(segment);
	return match ? {
		name: match[1],
		id: match[2]
	} : {
		name: segment
	}
}

function _dispatch(_, context, map) {
	var seg = context.walkUrl();
	if (seg == null) {
		// we reached the end of the URL, dispatch method
		//var method = context.request.method.toLowerCase();
		var method = context.method;
		if (map[method]) return map[method](_, context);
		else throw context.badMethod(method);
	} else {
		var pair = _parseSegment(seg);
		if (pair.name[0] == '$') {
			var name = pair.name.substring(1);
			if (map[name]) {
				return map[name](_, context, pair.id);
			}
		} else if (map.walk) {
			return map.walk(_, context, pair.name, pair.id);
		}
		throw context.badRequest(locale.format(module, "unexpectedSegment", seg));
	}
}


var _fusionMap = {
	walk: function(_, context, name, id) {
		context.applicationName = name;
		return _dispatch(_, context, _applicationMap);
	}
}

// URL is http://host/x3/app
var _applicationMap = {
	walk: function(_, context, name, id) {
		context.contractName = name;
		//
		var app = adminHelper.getApplication(_, context.applicationName, context.contractName);
		if(!app || (app && app.protocol(_) !== "x3")) throw context.notFound(locale.format(module, "applicationNotFound", context.applicationName, context.contractName));
		context.applicationRef = app;
		//
		return _dispatch(_, context, _contractMap);
	}
}

// URL is http://host/sdata/app/contract
var _contractMap = {
	walk: function(_, context, name, id) {
		if (context.applicationRef) { // TEST to allow stubs
			// find the endpoint
			var ep = adminHelper.getEndpoint(_, {
				application: context.applicationName,
				contract: context.contractName,
				dataset: name
			});
			if(!ep) throw context.notFound(locale.format(module, "endpointNotFound", context.applicationName, context.contractName, name));
			context.endpoint = ep;
			//
			context.baseUrl = context.walked();
		}
		return _dispatch(_, context, _datasetMap);
	}
}

// URL is http://host/sdata/app/contract/dataset
// reply to prototypes request, delegate everything else to x3FusionPool
var _datasetMap = {
	walk: function(_, context, name, id) {
		throw new Error(locale.format(module, "unexpectedSegment", name));
	},
	prototypes: function(_, context, id) {
		if (id) {
			context.prototypeId = id;
			return _dispatch(_, context, _prototypeMap);
		} else {
			// NYI
			throw new Error(locale.format(module, "NYI"));
		}
	},
	sessions: function(_, context, id) {
/*		if (id) {
			context.fusionSessionId = id;
			// delegate to x3fusionPool
			x3FusionPool.proxy(_, context);
		} else {
			return _dispatch(_, context, _connectMap);
		}
*/		
		context.fusionSessionId = id;
		return _dispatch(_, context, _connectMap);
	},
	files: function(_, context, id) {
		x3FusionPool.webProxy(_, context, context.endpoint.x3ServerFolder(_) + "/" + context.toWalk(), _config);
	},
	shared: function(_, context, id) {
		x3FusionPool.webProxy(_, context, "X3_ROOT/" + context.toWalk(), _config);
	}
}

//URL is http://host/sdata/app/contract/dataset/$prototypes('id')
var _prototypeMap = {
	get: function(_, context) {
		function getPrototypeResp(_, protoUrl) {
			// make a request to the web server for entity.xml
			var options = {
				url: protoUrl,
				method: "GET",
				headers: {
					"Accept-Charset": "utf8"
				}
			}
			tracer && tracer("x3dispatch.prototype.get url: "+protoUrl);
			var request = streams.httpRequest(options);
			return request.end().response(_);
		}
		var keys = context.prototypeId.split(".");
		// use of stubs ?
		if ((!context.endpoint) && helpers.stubsPath) {
			context.reply(_, 200, getPrototypeStub(_, context));
		} else {
//			entity: keys[0],
//			type: keys[1],
//			variant: keys[2]
			var url;
			var parser;
			if(helpers.fusionJsonPrototypes === "dynamic") {
				// temporary testing purpose alternate prototype path
				var x3server = context.endpoint.x3server(_);
				url = "http://"+[(x3server.webServer(_) || x3server.serverHost(_))+":"+x3server.webServerPort(_), 
				                 "Adonix_"+context.endpoint.getSolutionName(_), context.endpoint.x3ServerFolder(_), 
				                 "GEN", "SYR", locale.current.toUpperCase(), "FENJ", keys[0] + ".json"].join("/");
				parser = JSON;
			} else {
				if((helpers.fusionJsonPrototypes === true) || (helpers.fusionJsonPrototypes === "static")) {
					// temporary testing purpose alternate prototype path
					var x3server = context.endpoint.x3server(_);
					url = "http://"+[(x3server.webServer(_) || x3server.serverHost(_))+":"+x3server.webServerPort(_), 
					                 "Adonix_"+context.endpoint.getSolutionName(_), context.endpoint.x3ServerFolder(_), 
					                 "GEN", locale.isoLanguageMap[locale.current.toLowerCase()], "FENJ", keys[0] + ".json"].join("/");
					parser = JSON;
				} else {
					url = context.endpoint.getFusionPrototypeBaseUrl(_) + "/" + keys[0] + ".xml";
					parser = xmlToProto;
				}
			}
			//
			var response = getPrototypeResp(_, url);
			//
			if(response.statusCode == 200) {
				var responseStr = response.readAll(_).toString("utf8");
				context.reply(_, 200, parser.parse(responseStr));
			} else 
			if(response.statusCode == 404) {
				if(helpers.fusionJsonPrototypes) {
					// try to get xml version
					url = context.endpoint.getFusionPrototypeBaseUrl(_) + "/" + keys[0] + ".xml";
					response = getPrototypeResp(_, url);
					if(response.statusCode == 200) {
						var responseStr = response.readAll(_).toString("utf8");
						context.reply(_, 200, xmlToProto.parse(responseStr));
					} else
						context.reply(_, response.statusCode);
				} else
					context.reply(_, response.statusCode);
			} else {
				context.reply(_, response.statusCode);
			}
		}
	}
}

var _connectMap = {
	walk: function(_, context, name, id) {
		// proxy use all segments after sessions but it has allready been walked. So unwalk a segment
		context.unwalkUrl();
		x3FusionPool.proxy(_, context, _config);
	},
	post: function(_, context) {
		var result = x3FusionPool.connect(_, context, _config);
		context.reply(_, result.statusCode, result.body, result.headers);
	},
	"delete": function(_, context) {
		context.httpSession.closeFusionSession(context.fusionSessionId, context.parameters.reuse, _);
		context.replyDeleted(_);
	}
}

function _doIt(_, context) {
	try {
		var protocol = context.walkUrl();
		if (protocol != "trans") throw new Error(locale.format(module, "badUrl"));
		_dispatch(_, context, _fusionMap);
	} catch (ex) {
		if (ex.httpStatus) {
			return context.reply(_, ex.httpStatus, ex.message + "\n" + ex.stack);
		} else if (ex.stack) {
			console.error(ex.message + "\n" + ex.stack);
			return context.reply(_, 500, ex.message + "\n" + ex.stack);
		} else {
			console.error("CAUGHT NON ERROR: " + ex)
			return context.reply(_, 500, ex.toString());
		}
	}
}

exports.x3dispatcher = function(config) {
	// setup config here
	_config = (config && config.x3fusion) || {};
	tracer = config && config.x3fusion && config.x3fusion.tracer;
	profiler = config && config.x3fusion && config.x3fusion.profiler;
	//
	return function(_, request, response) {
		var context = new Context(request, response);
		request.context = context;
		try {
			_doIt(_, context);
		} catch (err) {
			helpers.log.exception(module, err);
			context.reply(_, 500, err.message + "\n" + err.stack);
		}
	}
}