"use strict"

var helpers = require("syracuse-core/lib/helpers");
var Context = require("syracuse-sdata/lib/sdataContext").Context;
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var locale = require("syracuse-core/lib/locale");
var streams = require("streamline/lib/streams/streams");
var x3FusionPool = require("./fusionPool");
var x3helpers = require("./helpers");

var _tracer = null;
var _profiler = null;
var _config = {};

function _parseSegment(segment) {
	var match = /^([^\/(]*)\('([^']*)'\)$/.exec(segment);
	return match ? {
		name: match[1],
		id: match[2]
	} : {
		name: segment
	}
}

function _dispatch(_, context, map) {
	var seg = context.walkUrl();
	if (seg == null) {
		// we reached the end of the URL, dispatch method
		//var method = context.request.method.toLowerCase();
		var method = context.method;
		if (map[method]) return map[method](_, context);
		else throw context.badMethod(method);
	} else {
		var pair = _parseSegment(seg);
		if (pair.name[0] == '$') {
			var name = pair.name.substring(1);
			if (map[name]) {
				return map[name](_, context, pair.id);
			}
		} else if (map.walk) {
			return map.walk(_, context, pair.name, pair.id);
		}
		throw context.badRequest(locale.format(module, "unexpectedSegment", seg));
	}
}

var _fusionMap = {
	walk: function(_, context, name, id) {
		context.applicationName = name;
		return _dispatch(_, context, _applicationMap);
	}
}

// URL is http://host/x3/app
var _applicationMap = {
	walk: function(_, context, name, id) {
		context.contractName = name;
		//
		var app = adminHelper.getApplication(_, context.applicationName, context.contractName);
		if(!app || (app && app.protocol(_) !== "x3")) throw context.notFound(locale.format(module, "applicationNotFound", context.applicationName, context.contractName));
		context.applicationRef = app;
		//
		return _dispatch(_, context, _contractMap);
	}
}

// URL is http://host/sdata/app/contract
var _contractMap = {
	walk: function(_, context, name, id) {
		if (context.applicationRef) { // TEST to allow stubs
			// find the endpoint
			var ep = adminHelper.getEndpoint(_, {
				application: context.applicationName,
				contract: context.contractName,
				dataset: name
			});
			if(!ep) throw context.notFound(locale.format(module, "endpointNotFound", context.applicationName, context.contractName, name));
			context.endpoint = ep;
			//
			context.baseUrl = context.walked();
		}
		return _dispatch(_, context, _datasetMap);
	}
}

// URL is http://host/sdata/app/contract/dataset
// reply to prototypes request, delegate everything else to x3FusionPool
var _datasetMap = {
	walk: function(_, context, name, id) {
		throw new Error(locale.format(module, "unexpectedSegment", name));
	},
	prototypes: function(_, context, id) {
		if (id) {
			context.prototypeId = id;
			return _dispatch(_, context, _prototypeMap);
		} else {
			// NYI
			throw new Error(locale.format(module, "NYI"));
		}
	},
	sessions: function(_, context, id) {
		context.fusionSessionId = id;
		return _dispatch(_, context, _connectMap);
	},
	files: function(_, context, id) {
		x3FusionPool.webProxy(_, context, context.endpoint.x3ServerFolder(_) + "/" + context.toWalk(), _config);
	},
	shared: function(_, context, id) {
		x3FusionPool.webProxy(_, context, "X3_ROOT/" + context.toWalk(), _config);
	}
}

//URL is http://host/sdata/app/contract/dataset/$prototypes('id')
var _prototypeMap = {
	get: function(_, context) {
		function getPrototypeResp(_, protoUrl) {
			// make a request to the web server for entity.xml
			var options = {
				url: protoUrl,
				method: "GET",
				headers: {
					"accept-charset": "utf-8"
				}
			}
			_tracer && _tracer("x3dispatch.prototype.get url:\n\t"+protoUrl);
			var request = streams.httpRequest(options);
			return request.end().response(_);
		}
		
		var keys = context.prototypeId.split(".");
		// use of stubs ?
		if ((!context.endpoint) && helpers.stubsPath) {
			context.reply(_, 200, getPrototypeStub(_, context));
		} else {
			var url;
			var parser;
			var x3server = context.endpoint.x3server(_);
			// accepted language from header
			var lang = locale.extractLocaleCode(context.request.headers["accept-language"]) || locale.current;
			//
			if(_config && _config.prototypesFolder) {
				url = "http://"+[(x3server.webServer(_) || x3server.serverHost(_))+":"+x3server.webServerPort(_), 
				                 "Adonix_"+context.endpoint.getSolutionName(_), context.endpoint.x3ServerFolder(_), 
				                 _config.prototypesFolder, keys[0] + ".json"].join("/");
			} else
				url = "http://"+[(x3server.webServer(_) || x3server.serverHost(_))+":"+x3server.webServerPort(_), 
				                 "Adonix_"+context.endpoint.getSolutionName(_), context.endpoint.x3ServerFolder(_), 
				                 "GEN", "SYR", lang.toUpperCase(), "FENJ", keys[0] + ".json"].join("/");
			parser = JSON;
			//
			var response = getPrototypeResp(_, url);
			//
			if(response.statusCode == 200) {
				var responseStr = response.readAll(_).toString("utf8");
				// content language should be forced here as we've got the prototype into a language dependent folder
				context.reply(_, 200, parser.parse(responseStr), {
					"content-language": lang
				});
			} else 
				context.reply(_, response.statusCode);
		}
	}
}

var _connectMap = {
	walk: function(_, context, name, id) {
		// proxy use all segments after sessions but it has allready been walked. So unwalk a segment
		context.unwalkUrl();
		x3FusionPool.proxy(_, context, _config);
	},
	post: function(_, context) {
		var result = x3FusionPool.connect(_, context, _config);
		context.reply(_, result.statusCode, result.body, result.headers);
	},
	"delete": function(_, context) {
		context.httpSession.closeFusionSession(context.fusionSessionId, context.parameters.reuse, _);
		context.replyDeleted(_);
	}
}

function _doIt(_, context) {
	var protocol = context.walkUrl();
	if (protocol != "trans") throw new Error(locale.format(module, "badUrl"));
	_dispatch(_, context, _fusionMap);
}

exports.x3dispatcher = function(config) {
	// setup config here
	_config = (config && config.x3fusion) || {};
	_tracer = console.log || (config && config.x3fusion && config.x3fusion.tracer);
	_profiler = config && config.x3fusion && config.x3fusion.profiler;
	//
	return function(_, request, response) {
		var context = new Context(request, response);
		request.context = context;
		try {
			_doIt(_, context);
		} catch (ex) {
			// Catchs all exceptions and sends a fusion error message to the client
			_tracer && _tracer("x3dispatcher.main - Error\n", ex.toString());
			if (ex.toJson){
				// ex is a fusion error
				var fusionBody=ex.toJson();
			}else{
				// FDB - Fusion message - msgDefault: end user message - diagnoses : Stack
				var fusionBody={
					msgDefault:x3helpers.errShortPath(ex.message?ex.message:ex.toString()),
					diagnoses:[{
						message:x3helpers.errShortPath(ex.stack?ex.stack:ex.toString()),
						severity: "error"
					}]		
				};
			}
			return context.reply(_, ex.httpStatus==undefined?500:ex.httpStatus,fusionBody);
		}
	}
}