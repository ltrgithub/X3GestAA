"use strict"

var helpers = require("syracuse-core/lib/helpers");
var Context = require("syracuse-sdata/lib/sdataContext").Context;
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var locale = require("syracuse-core/lib/locale");
var streams = require("streamline/lib/streams/streams");
var x3FusionPool = require("./fusionPool");
var x3helpers = require("./helpers");

var _tracer = null;
var _profiler = null;
var _config = {};

function getProtoUrl(_, context){
	if (!context && !context.endpoint) return null;	
	var x3server = context.endpoint.x3server(_);
	if (!x3server) return null;	
	var url=[];
	var host=(x3server.webServer(_) || x3server.serverHost(_));
	if (!host || host.length==0) throw "Unexpected empty web server host";
	var port= x3server.webServerPort(_);
	if (port<=0) throw "Bad web server port";
	url.push(host + ":" + port);
	var sol= context.endpoint.getSolutionName(_);
	if (!sol || sol.length==0) throw "Unexpected empty solution name";
	url.push("Adonix_" + sol);
	var fldr= context.endpoint.x3ServerFolder(_);
	if (!fldr || fldr.length==0) throw "Unexpected empty folder name";
	url.push(fldr);	
	if (_config && _config.prototypesFolder) {
		url.push(_config.prototypesFolder);
	}else {
		// accepted language from header
		var lang = locale.extractLocaleCode(context.request.headers["accept-language"]) || locale.current;
		url.push("GEN");
		url.push("SYR");
		url.push(lang.toUpperCase());
		url.push("FENJ");
	}
	if (context.prototypeId) url.push(context.prototypeId.split(".")[0] + ".json");
	return "http://" + url.join("/");
}
function _parseSegment(segment) {
	var match = /^([^\/(]*)\('([^']*)'\)$/.exec(segment);
	return match ? {
		name: match[1],
		id: match[2]
	} : {
		name: segment
	}
}

function _dispatch(_, context, map) {
	var seg = context.walkUrl();
	if (seg == null) {
		// we reached the end of the URL, dispatch method
		//var method = context.request.method.toLowerCase();
		var method = context.method;
		if (map[method]) return map[method](_, context);
		else throw context.badMethod(method);
	} else {
		var pair = _parseSegment(seg);
		if (pair.name[0] == '$') {
			var name = pair.name.substring(1);
			if (map[name]) {
				return map[name](_, context, pair.id);
			}
		} else if (map.walk) {
			return map.walk(_, context, pair.name, pair.id);
		}
		throw context.badRequest(locale.format(module, "unexpectedSegment", seg));
	}
}

var _fusionMap = {
	walk: function(_, context, name, id) {
		context.applicationName = name;
		return _dispatch(_, context, _applicationMap);
	}
}

// URL is http://host/x3/app
var _applicationMap = {
	walk: function(_, context, name, id) {
		context.contractName = name;
		//
		var app = adminHelper.getApplication(_, context.applicationName, context.contractName);
		if(!app || (app && app.protocol(_) !== "x3")) throw context.notFound(locale.format(module, "applicationNotFound", context.applicationName, context.contractName));
		context.applicationRef = app;
		//
		return _dispatch(_, context, _contractMap);
	}
}

// URL is http://host/sdata/app/contract
var _contractMap = {
	walk: function(_, context, name, id) {
		if (context.applicationRef) { // TEST to allow stubs
			// find the endpoint
			var ep = adminHelper.getEndpoint(_, {
				application: context.applicationName,
				contract: context.contractName,
				dataset: name
			});
			if(!ep) throw context.notFound(locale.format(module, "endpointNotFound", context.applicationName, context.contractName, name));
			context.endpoint = ep;
			//
			context.baseUrl = context.walked();
		}
		return _dispatch(_, context, _datasetMap);
	}
}

// URL is http://host/sdata/app/contract/dataset
// reply to prototypes request, delegate everything else to x3FusionPool
var _datasetMap = {
	walk: function(_, context, name, id) {
		throw new Error(locale.format(module, "unexpectedSegment", name));
	},
	prototypes: function(_, context, id) {
		if (id) {
			context.prototypeId = id;
			return _dispatch(_, context, _prototypeMap);
		} else {
			// NYI
			throw new Error(locale.format(module, "NYI"));
		}
	},
	sessions: function(_, context, id) {
		context.fusionSessionId = id;
		return _dispatch(_, context, _connectMap);
	},
	files: function(_, context, id) {
		x3FusionPool.webProxy(_, context, context.endpoint.x3ServerFolder(_) + "/" + context.toWalk(), _config);
	},
	shared: function(_, context, id) {
		x3FusionPool.webProxy(_, context, "X3_ROOT/" + context.toWalk(), _config);
	}
}

//URL is http://host/sdata/app/contract/dataset/$prototypes('id')
var _prototypeMap = {
	get: function(_, context) {
		function getPrototypeResp(_, protoUrl) {
			// make a request to the web server for entity.xml
			var options = {
				url: protoUrl,
				method: "GET",
				headers: {
					"accept-charset": "utf-8"
				}
			}
			_tracer && _tracer("x3dispatch.prototype.get url:\n\t"+protoUrl);
			var request = streams.httpRequest(options);
			return request.end().response(_);
		}
		// use of stubs ?
		if ((!context.endpoint) && helpers.stubsPath) {
			context.reply(_, 200, getPrototypeStub(_, context));
		} else {
			var response = getPrototypeResp(_, getProtoUrl(_, context));
			if (response.statusCode == 200) {
				var responseStr = response.readAll(_).toString("utf8");
				_tracer && _tracer("x3dispatch.prototype.get content: " + responseStr);
				// content language should be forced here as we've got the prototype into a language dependent folder				
				var lang = locale.extractLocaleCode(context.request.headers["accept-language"]) || locale.current;
				context.reply(_, 200, JSON.parse(responseStr), {
					"content-language": lang
				});
			}
			else {
				context.reply(_, response.statusCode);
			}
		}
	}
}

var _connectMap = {
	walk: function(_, context, name, id) {
		// proxy use all segments after sessions but it has allready been walked. So unwalk a segment
		context.unwalkUrl();
		x3FusionPool.proxy(_, context, _config);
	},
	post: function(_, context) {
		var result = x3FusionPool.connect(_, context, _config);
		var b=result.body;
		if (b){
			// Help to diagnose issues - dvlp 
			try {
				if (!b.srvop) 
				b.srvop = {};
				var sctx=b.srvop.syraCtx = {
					proto: getProtoUrl(_, context),
					fusion: context.endpoint.getFusionDataServerBaseUrl(_)
				}
				var up = context.httpSession.getUserProfile(_);
				if (up && up.user(_)) {
					sctx.x3user = up.user(_).getEndpointLogin(_, context.endpoint.$uuid);
				}
				var x3server = context.endpoint.x3server(_);
				if (x3server){
					sctx.x3host=x3server.serverHost(_);
					sctx.x3port=x3server.serverPort(_);
					sctx.x3name=x3server.serverName(_);
				}
			}catch(e){}
		}
		context.reply(_, result.statusCode, b, result.headers);
	},
	"delete": function(_, context) {
		context.httpSession.closeFusionSession(context.fusionSessionId, context.parameters.reuse, _);
		context.replyDeleted(_);
	}
}

function _doIt(_, context) {
	var protocol = context.walkUrl();
	if (protocol != "trans") throw new Error(locale.format(module, "badUrl"));
	_dispatch(_, context, _fusionMap);
}

exports.x3dispatcher = function(config) {
	// setup config here
	_config = (config && config.x3fusion) || {};
	_tracer = console.log || (config && config.x3fusion && config.x3fusion.tracer);
	_profiler = config && config.x3fusion && config.x3fusion.profiler;
	//
	return function(_, request, response) {
		var context = new Context(request, response);
		request.context = context;
		try {
			_doIt(_, context);
		} catch (ex) {
			// Catchs all exceptions and sends a fusion error message to the client
			_tracer && _tracer("x3dispatcher.main - Error\n", ex.toString());
			if (ex.toJson){
				// ex is a fusion error
				var fusionBody=ex.toJson();
			}else{
				// FDB - Fusion message - msgDefault: end user message - diagnoses : Stack
				var fusionBody={
					msgDefault:x3helpers.errShortPath(ex.message?ex.message:ex.toString()),
					diagnoses:[{
						message:x3helpers.errShortPath(ex.stack?ex.stack:ex.toString()),
						severity: "error"
					}]		
				};
			}
			return context.reply(_, ex.httpStatus==undefined?500:ex.httpStatus,fusionBody);
		}
	}
}