"use strict";

var helpers = require("syracuse-core/lib/helpers");
var x3client = require("./client");
var flows = require('streamline/lib/util/flows');
var locale = require("syracuse-core/lib/locale");
var glob = require("streamline/lib/globals");
//var adminUtil = require('syracuse-collaboration/lib/util');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var sys = require("util");

var _configs = {};

var _clients = {};

var tracerPool = require("syracuse-trace/lib/helper").getTracer("x3Comm.pool");

exports.testPoints = {};

function _updateSession(_, ssid) {
	// update Syracuse session info (at the moment not necessary - will be important when the Supervisor notifies Syracuse
	// when sessions have been killed in APSADX. (SAM 99770). At the moment all invocations are commented out.
	var session = glob.context.session;
	var sessionInfo = session.sessionInfo;
	if (session.id !== ssid) {
		var db = adminHelper.getCollaborationOrm(_);
		var entity = db.getEntity(_, "sessionInfo");
		// fetchInstance(callback, entity, filter)
		sessionInfo = db.fetchInstance(_, entity, {
			jsonWhere: {
				"sid": ssid
			}
		});
	}
	console.error("ID " + session.id + " " + ssid);
	sessionInfo.x3Sessions(_, exports.allClientIds(ssid).join(", "));
	sessionInfo.save(_);
}

function _addClient(client, ssid, datasetName) {
	var cp = _clients[ssid] = _clients[ssid] || {};
	(cp[datasetName] = cp[datasetName] || []).push(client);
	// _updateSession(!_, ssid);
	poolLog(ssid, datasetName, true);
}

// returns all session id attributes of the pooled sessions (not including convergence sessions)
exports.allClientIds = function(ssid) {
	var cp = _clients[ssid];
	var result = [];
	if (!cp) return result;

	function putClient(c) {
		result.push(c.getSessionId());
	}

	for (var dataset in cp) {
		var arr = cp[dataset];
		arr && arr.forEach(putClient);
	}
	return result;
};

function _pickClient(ssid, datasetName) {
	var cp = _clients[ssid] = _clients[ssid] || {};
	var unchanged = true;
	cp[datasetName] = (cp[datasetName] || []).filter(function(c) {
		var alive = c.isAlive();
		unchanged &= alive;
		return alive;
	});
	// if (!unchanged) _updateSession(!_, ssid);
	return (cp[datasetName].filter(function(c) {
		return !c.busy();
	}))[0];
}

// issue SAM 99572
function _isSameRuntimeLogConf(clientRuntimeLogCfg, sessionRuntimeLogCfg, dataset) {
	var res = false;
	if (!clientRuntimeLogCfg && !sessionRuntimeLogCfg || (sessionRuntimeLogCfg.dataset && sessionRuntimeLogCfg.dataset !== dataset)) {
		return true;
	} else if (clientRuntimeLogCfg && sessionRuntimeLogCfg) {
		res = clientRuntimeLogCfg.dataset == sessionRuntimeLogCfg.dataset;
		res = clientRuntimeLogCfg.logFlag == sessionRuntimeLogCfg.logFlag;
		res = clientRuntimeLogCfg.logDir == sessionRuntimeLogCfg.logDir;
	}
	return res;
}

function _makeClient(_, session, endpoint, async) {
	tracerPool.info && tracerPool.info("x3pool.makeClient enter");
	if (!session) throw new Error(locale.format(module, "noSession"));
	if (!session.x3funnel) session.x3funnel = flows.funnel(1);

	tracerPool.info && tracerPool.info("x3pool.makeClient return session.x3funnel");
	return session.x3funnel(_, function(_) {
		tracerPool.info && tracerPool.info("x3pool.makeClient funnel enter");
		var runtimeCfg = (session.x3SessionConfig && session.x3SessionConfig.runtime) || {};

		//
		if (!endpoint) throw new Error(locale.format(module, "noEndpoint", ""));
		//
		var client = async ? null : _pickClient(session.id, endpoint.dataset(_)); // for async request, always create a client
		if (client) {
			if (_isSameRuntimeLogConf(client.activateRuntimeLog, runtimeCfg, endpoint.dataset(_))) {
				return client;
			} else {
				client.disconnect(_);
			}

		}

		// get X3 user name for this client
		var userProfile;
		var userName = "";
		userProfile = session.getUserProfile(_);

		var x3solution = endpoint.x3solution(_);
		if (!x3solution) throw new Error(locale.format(module, "noX3Solution", endpoint.description(_)));

		// create client config
		var config = {
			x3solution: x3solution,
			x3serverTags: userProfile.getX3ServerTags(_),
			certificate: x3solution.certificate(_),
			async: async
		};
		config.tracer = tracerPool;


		if (!userProfile) throw new Error(locale.format(module, "noUserProfile"));
		var user = userProfile.user(_);
		userName = user.getEndpointLogin(_, endpoint.$uuid);
		config.tracer.info && config.tracer.info("x3pool._makeClient: found login " + userName + " for endpoint " + endpoint.description(_));
		//
		client = x3client.create(config);
		client.activateRuntimeLog = runtimeCfg && (!runtimeCfg.dataset || endpoint.dataset(_) === runtimeCfg.dataset) && runtimeCfg.logFlag ? runtimeCfg : {};
		//
		client.connect(_, {
			server: x3solution.serverHost(_),
			folder: endpoint.x3ServerFolder(_),
			locale: locale.current,
			runtimeLog: !runtimeCfg.dataset || endpoint.dataset(_) === runtimeCfg.dataset ? runtimeCfg.logFlag : "",
			runtimeLogDir: !runtimeCfg.dataset || endpoint.dataset(_) === runtimeCfg.dataset ? runtimeCfg.logDir : ""

		});
		//
		var adminEP = adminHelper.getCollaborationEndpoint(_);
		client.createSession(_, {
			sessionType: "primary",
			locale: locale.current,
			localePreferences: userProfile.selectedLocale(_),
			userName: userName,
			baseUrl: session.host + endpoint.getBaseUrl(_),
			endpointDataset: endpoint.dataset(_),
			collaborationBaseUrl: adminEP ? session.host + adminHelper.getCollaborationEndpoint(_).getBaseUrl(_) : "",
			peerAddress: (session.getData("requestInfo") || {}).peerAddress,
			userProfile: userProfile // pass user profile to update the productName
		});
		//
		_addClient(client, session.id, endpoint.dataset(_));
		//
		return client;
	});
}

// temporary add to log bug 93133

function poolLog(sessid, clientId, created) {
	var date = new Date().toUTCString();
	if (created) {
		tracerPool.info && tracerPool.info(date + " - connect syrapedia client : session [" + sessid + "] , dataset id [" + clientId + "]");
	} else {
		tracerPool.info && tracerPool.info(date + " - disconnect syrapedia client : [" + sessid + "] , dataset Id [" + clientId + "]");
	}
}

function _send(_, context) {
	tracerPool.info && tracerPool.info("x3pool.send enter");
	var request = context.request;
	if (!request.session) throw new Error("configuration error: no session in X3 send");
	// pull all headers but with some mods
	request.headers.accept = request.headers.accept && request.headers.accept.split(",")[0];
	request.headers["accept-language"] = request.session.locale;
	if (request.headers["x-http-method-override"]) {
		request.method = request.headers["x-http-method-override"];
		delete request.headers["x-http-method-override"];
	}
	//
	var client = _makeClient(_, context.request.session, context.endpoint, context.isAsync());
	// unit test checkpoint entry
	if (exports.testPoints._send) exports.testPoints._send(request);
	//
	var clientResp = client.sendRequest(_, request, context.response);
	if (clientResp.statusCode == 500) {
		// destroy client
		tracerPool.info && tracerPool.info("X3session: Error 500 so destroying client");
		delete(_clients[request.session.id] || {})[context.endpoint.dataset(_)];
	}
	if (context.isAsync()) {
		// destroy client
		tracerPool.info && tracerPool.info("X3session: Destroy async client");
		client.disconnect(_);
		delete(_clients[request.session.id] || {})[context.endpoint.dataset(_)];
	}
	return clientResp;
}

function _jsonSend(_, session, endpoint, params) {
	tracerPool.info && tracerPool.info("x3pool._jsonSend enter");
	tracerPool.info && tracerPool.info(JSON.stringify(params, null, 2));
	if (!session) throw new Error("configuration error: no session in X3 send");
	params.head.accept = params.head.accept && params.head.accept.split(",")[0];
	params.head["accept-language"] = session.locale;
	//
	var context = glob.context.sdataContext;
	//
	var client = _makeClient(_, session, endpoint, context.isAsync());
	var resp = client.jsonSend(_, params);
	if (context.isAsync()) {
		// destroy client
		tracerPool.info && tracerPool.info("X3session: Destroy async client");
		client.disconnect(_);
		delete(_clients[session.id] || {})[endpoint.dataset(_)];
	}
	return resp;
}

function Authentication() {}

helpers.defineClass(Authentication, null, {
	authentificate: function(data, send) {
		var self = this;
		send(data);
	}
});

exports.setup = function(configs, proxyMap) {
	// Do not use nodelocal tracer configuration anymore
	//tracer = configs && configs.tracer;
};

exports.send = _send;

exports.jsonSend = _jsonSend;

exports.getClient = function(_, session, endpoint) {
	return _makeClient(_, session, endpoint);
};

exports.checkServerSettings = function(_, params) {
	var config = {
		x3solution: params.x3solution,
		x3server: params.x3server,
		tracer: tracerPool
	};
	var client = x3client.create(config);
	//
	return client.checkServerSettings(_, {
		server: params.applicationServer,
		folder: params.folder,
		locale: locale.current
	});
};

exports.Authentication = new Authentication();

exports.disconnect = function(_, sessionId) {
	if (_clients[sessionId]) Object.keys(_clients[sessionId]).forEach_(_, function(_, clientId) {
		(_clients[sessionId][clientId] || []).forEach_(_, function(_, c) {
			c.disconnect(_);
			poolLog(sessionId, clientId, false);
		});
	});
	// do not save changes to Syracuse session because it will be deleted anyway
	delete _clients[sessionId];
};

exports.injectClientStub = function(client) {
	x3client = client;
};