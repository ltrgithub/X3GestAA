"use strict";

var helpers = require("syracuse-core/lib/helpers");
var x3client = require("./client");
var flows = require('streamline/lib/util/flows');
var locale = require("syracuse-core/lib/locale");
//var adminUtil = require('syracuse-collaboration/lib/util');
var sys = require("util");

var _configs = {};

var _clients = {};

var tracer = null;

exports.testPoints = {};

function _addClient(client, ssid, datasetName) {
	var cp = _clients[ssid] = _clients[ssid] || {};
	(cp[datasetName] = cp[datasetName] || []).push(client);
}

function _pickClient(ssid, datasetName) {
	var cp = _clients[ssid] = _clients[ssid] || {};
	cp[datasetName] = (cp[datasetName] || []).filter(function(c) {
		return c.isAlive();
	});
	return (cp[datasetName].filter(function(c) {
		return !c.busy();
	}))[0];
}

function _makeClient(_, session, endpoint, wcId) {
	tracer && tracer("x3pool.makeClient enter");
	if (!session) throw new Error(locale.format(module, "noSession"));
	if (!session.x3funnel) session.x3funnel = flows.funnel(1);

	return session.x3funnel(_, function(_) {
		tracer && tracer("x3pool.makeClient funnel enter");
		//
		if (!endpoint) throw new Error(locale.format(module, "noEndpoint", ""));
		//
		var client = _pickClient(session.id, endpoint.dataset(_));
		if(client) return client;
		// choose a server
		var x3server = endpoint.x3server(_);
		if(!x3server)
			throw new Error(locale.format(module, "noX3Server", endpoint.description(_)));
		// create client config
		var config = {
			address: x3server.serverHost(_),
			port: x3server.serverPort(_)
		}
		config.tracer = tracer;
		// get X3 user name for this client
		var userProfile;
		var userName = "";
		userProfile = session.getUserProfile(_);
		if(!userProfile)
			throw new Error(locale.format(module, "noUserProfile"));
		var user = userProfile.user(_);
		userName = user.getEndpointLogin(_, endpoint.$uuid);
		config.tracer && config.tracer("x3pool._makeClient: found login "+userName+" for endpoint "+endpoint.description(_));
		//
		client = x3client.create(config);
		//
		client.connect(_, {
			server: x3server.serverName(_),
			folder: endpoint.x3ServerFolder(_),
			locale: locale.current
		});
		//
		client.createSession(_, {
				sessionType: "primary",
				locale: locale.current,
				localePreferences: userProfile.selectedLocale(_),
				userName: userName
			});
		//
		_addClient(client, session.id, endpoint.dataset(_));
		//
		return client;
	});
}

function _send(_, context) {
	tracer && tracer("x3pool.send enter");
	var request = context.request;
	if (!request.session) throw new Error("configuration error: no session in X3 send");
/*	request.headers = { // headers cleanup -- for now
		accept: request.headers.accept.split(",")[0],
		"accept-language": request.session.locale
	};
*/
	// pull all headers but with some mods
	request.headers.accept = request.headers.accept.split(",")[0];
	request.headers["accept-language"] = request.session.locale;
	if(request.headers["x-http-method-override"]) {
		request.method = request.headers["x-http-method-override"];
		delete request.headers["x-http-method-override"];
	}
	//
	var client = _makeClient(_, context.request.session, context.endpoint);
	// unit test checkpoint entry
	if(exports.testPoints._send)
		exports.testPoints._send(request);
	//
	var clientResp = client.sendRequest(_, request, context.response);
	if(clientResp.statusCode == 500) {
		// destroy client
		var request = context.request;
		var endpoint = context.endpoint;
		tracer && tracer("X3session: Error 500 so destroying client");
		delete (_clients[request.session.id] || {})[endpoint.dataset(_)];
	}
	return clientResp;
}

function Authentication() {};

helpers.defineClass(Authentication, null, {
	authentificate: function(data, send) {
		var self = this;
		send(data);
	}
})

exports.setup = function(configs, proxyMap) {
	tracer = configs && configs.tracer;
}

exports.send = _send;

exports.getClient = function(_, session, endpoint, wcId) {
	return _makeClient(_, session, endpoint, wcId);
}

exports.Authentication = new Authentication();

exports.disconnect = function(_, sessionId) {
	if(_clients[sessionId])
		Object.keys(_clients[sessionId]).forEach_(_, function(_, clientId) {
			(_clients[sessionId][clientId] || []).forEach_(_, function(_, c) {
				c.disconnect(_);
			});
		});
	delete _clients[sessionId];
}