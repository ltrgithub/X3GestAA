"use strict";

var streams = require("streamline/lib/streams/streams"), 
    helpers = require('syracuse-core/lib/helpers'), 
    jsxml = require('jsxml'), 
    util = require('util'), 
    srvactions = require('syracuse-ui/lib/fusion/core/client/sap/srvactions'),
    jsRunner = require('syracuse-x3/lib/jsRunner');

var tracer = helpers.fusionProxyTracer?console.log:null;

var fusionDispatcher=function(context, endCallBack){
    this.context = context;
    this.endCallBack = endCallBack;
    this.content = '';
    this.execi = {};
}

var Dispatcher = helpers.defineClass(fusionDispatcher, null, {
    write: function(buf){
        this.content += buf.toString('utf8');        
    },
    forward: function(_, sid){
        var self = this;
        var keyword = "PROXY_DISPATCH";        
        function isProxyDispatch(){
            // Avoid parsing
            if (self.content && self.content.indexOf(keyword)>=0) {
                try {
                    self.respJson = JSON.parse(self.content);
                    if (self.respJson.sap != null &&
                    self.respJson.sap.target != null &&
                    self.respJson.sap.target.rpc != null &&
                    self.respJson.sap.target.rpc.xml != null) {
                        self.execi = jsxml.parse(self.respJson.sap.target.rpc.xml).execi;
                        // console.log("RESP = "+JSON.stringify(self.respJson,null,2));
                        if (self.execi.$.id === keyword) {
                            return true;
                        }
                    }
                } 
                catch (e) {
                    // If bad JSON reply returne buy server
                    tracer && tracer("!!! isProxyDispatch - Bad JSON reply\n" + self.content);
					throw e;
                }
            }
            return false;
        }        
        function execute(_){        
            function exec(_, header){
                function parseBody(){
                    body = JSON.parse(self.execi.param[1].resu.$cdata);
                }
                var resu, typ = "STRU", errl = 0, errm = "", errn = 0, errp = "", errt = 0;
                try {
                    // Syracuse function execution
                    if (header.url.indexOf('js:') == 0) {
                        parseBody();
                        resu = jsRunner.execute(_, header.url.substring(3), body);
                    }
                    // Http Request
                    else 
                        if (header.method != null) {
                            if (header.url.indexOf('http://') == 0 || header.url.indexOf('https://') == 0) {
                                if (header.method == 'POST' || header.method == 'PUT') {
                                    parseBody();
                                }
                                resu = jsRunner.httpRequest(_, header, body);
                                tracer && tracer("Header=" + JSON.stringify(resu.header, null, 2));
                            } else {
                                throw new Error("Invalid protocol");
                            }                            
                        }
                        // Unknow call type
                        else {
                            return genExeciNode(null, "STRU", 1, "Unknow Call", 1, "proxyDispatcher._js", 1);
                        }                    
                } 
                catch (e) {
                    //TODO Catch every error's elements
                    errl = 1;
                    errn = 1;
                    errt = 1;
                    errp = "proxyFusionDispatcher._js";
                    errm = e.message;
                    resu = {
                        header: {
                            "statusCode": "500",
                            "message": e.message,
                            "exception": e.stack
                        },
                        body: ''
                    }
                }
                return genExeciNode(resu, typ, errl, errm, errn, errp, errt);
            }        
            function genExeciNode(resu, typ, errl, errm, errn, errp, errt){
                //TODO - Manage RESU Type                
                var node = '<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>';
                node += '<execi errl=\"' + errl + '\" errm=\"' + errm + '\" errn=\"' + errn + '\" errp=\"' + errp + '\" errt=\"' + errt + '\" >';
                node += '<resu size=\"' + (resu.body != null ? resu.body.length : 'NULL') + '\" typ=\"' + typ + '\" ><![CDATA[' + JSON.stringify(resu.body, null, 0) + ']]></resu>';
                node += '<debuginfos><trace><![CDATA[' + JSON.stringify(resu.header, null, 0) + ']]></trace></debuginfos>'
                node += '</execi>';
                return node;
            }            
            var header = JSON.parse(self.execi.param[0].resu.$cdata), body;            
            var data = {
                act: srvactions.getSrvAction('SRV_RESI'),
                param: {
                    target: self.respJson.sap.target.rpc.ist,
                    reply: {
                        xml: ''
                    }
                }
            };            
            data.param.reply.xml = exec(_, header);            
            return new Buffer(JSON.stringify(data, null, 0), 'utf8');
        }            
        function dispatch(_){
            tracer && traceSection("REPLY FROM SERVER", self.content);            
            if (isProxyDispatch() == true) {            
                var data = execute(_);
                var options = {
                    url: self.context.endpoint.getFusionDataServerBaseUrl(_) + "/$sessions('" + sid + "')/requestSvc?act=" + data.act,
                    method: "PUT",
                    headers: {
                        "content-type": "application/json",
                        "accept": "application/json;vnd.sage=syracuse"
                    }
                }                
                var request = streams.httpRequest(options);
                tracer && traceSection("REQUEST FROM NODE TO SERVER", data);                
                request.write(_, data);                
                var response = request.end().response(_);                
                self.headers = response.headers;
                self.status = response.statusCode;
                var buf;
                self.content = "";
                while (buf = response.read(_)) {
                    self.write(buf);
                }                
                dispatch(_);
            }
            else {
                tracer && traceSection("REQUEST FROM CLIENT TO SERVER", self.content);
                endResponse({
                    body: self.content,
                    headers: self.headers,
                    status: self.status
                
                });
            }
        }        
        // Flush flush httpclient response via endCallBack
        function endResponse(data){
            if (self.endCallBack) {
                self.endCallBack(data);
            }
            self.endCallBack = null;
            self.context = null;
        }
        dispatch(_);        
    }    
});

function traceSection(title, content){
	if (tracer) {
		tracer("\n");
		tracer("##################################################");
		tracer("#    " + title);
		tracer("##################################################");
		try {
			var x=content.toString('utf8');
			if (x && x.length>0) tracer(" " + JSON.stringify(JSON.parse(x), null, 2));
		} 
		catch (e) {
			tracer(" !!! BAD REQUEST CONTENT - CAN T PARSE [" + e + "]");
			tracer(content.toString('utf8'));
		}
	}
}

exports.create = function(context, endCallback){
		if (tracer) {
			tracer("\n==================================================");
			tracer("==================================================\n");
		}
        return new Dispatcher(context, endCallback);   
}
