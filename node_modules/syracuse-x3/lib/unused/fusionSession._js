"use strict";

var locale = require("syracuse-core/lib/locale");
var helpers = require("syracuse-core/lib/helpers");
var streams = require("streamline/lib/streams/streams");
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var x3helpers = require("./helpers");
var dispatcher = require('./proxyFusionDispatcher');
var parseUrl = require('url').parse;
var x3helpers = require("./helpers");
var globals = require('streamline/lib/globals');
var sys = require("util");
var httpHelpers = require("syracuse-sdata/lib/httpHelper");
var check = require("syracuse-license/lib/check")

if (nodeconfig.config.x3fusion && !nodeconfig.config.x3fusion.undirect) {
	module.exports = require('syracuse-x3/lib/convergenceSession');
	return;
}

var tracer = null; 

function _startProfile(){
    return (new Date()).getTime();
}

function _endProfile(startTime){
    return (new Date()).getTime() - startTime;
}

function FusionSession(fsid){
    this.sessionUrl = "";
    this.isXmlSessionFormat = false;
}

function _getRsrc(){
	try{ 
	 	var args=[module];
		for (var i in arguments){
    		args.push(arguments[i]);
		}
		return locale.format.apply(locale, args);
	}catch(e){
		return "Resource not found ["+ arguments[0] +"]";
	}
}
function _getErrMsg(_, ex, rsrcId, ep){
	var msg=rsrcId?_getRsrc(rsrcId):null;
	if (msg==undefined) msg=""; 
	if (ex.message && ex.message.search(/ECONNREFUSED/i)>=0){		
		msg+= "\n" + _getRsrc("bridgeNotAvail");
	}	
	if (ep) {
		var baseUrl = ep.getFusionDataServerBaseUrl(_);
		baseUrl=baseUrl?parseUrl(baseUrl):"";		
		msg += "\n--------------\n" + _getRsrc("endpointInfo", baseUrl.host, ep.getApplicationServerName(_), ep.getSolutionName(_), ep.getX3FolderName(_));
	}
	return msg;
}

function _fusionErr(_, ex , rsrcId, ep){
	throw new x3helpers.Error(_getErrMsg(_,ex, rsrcId, ep), ex, ex.statusCode);
}
var sessionProto = FusionSession.prototype;
//
sessionProto.connect = function(_, context, config){
	try {
		var tracer = config && config.tracer;
		var profiler = config && config.profiler;
		var lic = check.getParsedLicense(_);
		if (lic && !lic.namedUsers)
			throw locale.format(module, "tooManyBadges");
		var fncTime = _startProfile();
		var baseUrl = context.endpoint.getFusionDataServerBaseUrl(_);
		var x3server = context.endpoint.x3server(_);
		var userProfile = context.httpSession.getUserProfile(_);
		var localePrefs = userProfile && userProfile.selectedLocale(_);
		var endpoint = this._endpoint = context.endpoint;
		this._baseUrl = baseUrl;
		//
		if (!context.parameters || !context.parameters.f)  throw "fusionSession.connect - Function parameter expected";
		tracer && tracer("fusionSession.connect request");
		var cnxParams = "";
		for (var p in context.query) {
			cnxParams += (cnxParams.length == 0 ? "?" : "&") + encodeURIComponent(p) + "=" + encodeURIComponent(context.query[p]);
		}
		var r = {
			host: x3server.serverHost(_),
			port: x3server.serverPort(_),
			folder: endpoint.x3ServerFolder(_)
		}
		if (x3server.serverName(_)) 
			r.server = x3server.serverName(_);
		var reqStr = JSON.stringify(r);
		var options = {
			url: baseUrl + "/$connections" + cnxParams,
			method: "POST",
			headers: {
				"content-type": "application/json",
				"content-length": reqStr.length,
				"accept-language": locale.current || "en-US",
				"accept": "application/json;vnd.sage=syracuse",
				"accept-charset": "utf-8"
			}
		}
		var start = profiler && _startProfile();
		var request = streams.httpRequest(options);
		tracer && tracer("fusionSession.connect - $connect request: " + reqStr);
		request.write(_, reqStr, "utf8");
		// response
		var resp = request.end().response(_);	
		var respHeaders = httpHelpers.parseHeaders(resp.headers);
		tracer && tracer("fusionSession.connect - $connect response headers: " + sys.inspect(resp.headers));
		tracer && tracer("fusionSession.connect - $connect parsed response headers: " + sys.inspect(respHeaders));
		var respData = resp.readAll(_).toString(respHeaders.toNodeCharset());
		if(respHeaders.isJSON())
			try {	
				respData = JSON.parse(respData);
			}catch(e){
				throw "fusionSession.connect - Bridge server request - Bad JSON response\n" + e.toString();
			}
		// check code
		if (resp.statusCode !== 201 || !respHeaders.isJSON()) {
			tracer && tracer("fusionSession.connect " + options.url + " statusCode: " + resp.statusCode);
			// respJson contains Fusion JSON error message sent by Java Bridge server
			return {
				body: respData,
				headers: resp.headers,
				statusCode: resp.statusCode
			}	
		}
		profiler && profiler("PROFILE; Transition connection: " + _endProfile(start));
		var respJson = respData;
		tracer && tracer("fusionSession.connect connected - response: " + JSON.stringify(respJson,null,"   "));
		if (!respJson.id)  throw "fusionSession.connect - Connection id expected";
		this.cid = respJson.id;
		this._connectionUrl = resp.headers["location"];
		// create a session
		var options = {
			url: baseUrl + "/$sessions",
			method: "POST",
			headers: {
				"content-type": "application/json",
				"accept-language": locale.current || "en-US",
				"accept": "application/json;vnd.sage=syracuse",
				"accept-charset": "utf-8",
				"x-forwarded-for": context.request.connection.remoteAddress
			}
		}
		tracer && tracer("fusionSession.createSession headers: "+sys.inspect(options.headers));
		var body = {
			connectionId: this.cid,
			sessionType: "primary",
			adxtyp: 25, // 25 is primary, 26 is secondary
			appServerUrl: endpoint.getApplicationServerBaseUrl(_),
			"function": context.parameters.f
		};
		if (respJson.auth && (respJson.auth.method === "X3RSA")) {
			options.headers.authorization = "x3-challenge";
			var auth = body.auth = {
				method: "X3RSA",
				pubkey: nodeconfig.config.sdata.pubkeyName,
				user: userProfile && userProfile.user(_) && userProfile.user(_).getEndpointLogin(_, endpoint.$uuid)
			};
			auth.signature = x3helpers.getSignature(_, respJson.auth.challenge, auth.user);
		}
		var selLocale = userProfile.selectedLocale(_);
		if (selLocale) {
			// FDB - Session Settings required by X3 client - dateOrder (dym-myd-ymd-dm if no year...)/dateSep/decSep/thousandSep
			body.preferences = x3helpers.dateFormatToX3Prefs(selLocale.shortDate(_));
			body.preferences.decimalSep = selLocale.numberDecimalSeparator(_);
			body.preferences.thousandsSep = selLocale.numberGroupSeparator(_);
			body.preferences.timeSep = x3helpers.getTimeSep(selLocale.shortTime(_));
		}
		var reqStr = JSON.stringify(body);
		options.headers["content-length"] = reqStr.length;
		var start = profiler && _startProfile();
		var request = streams.httpRequest(options);
		request.write(_, reqStr, "utf8");
		// response
		var resp = request.end().response(_);
		var respHeaders = httpHelpers.parseHeaders(resp.headers);
		tracer && tracer("fusionSession.connect - $session response headers: " + sys.inspect(resp.headers));
		tracer && tracer("fusionSession.connect - $session parsed response headers: " + sys.inspect(respHeaders));
		var respData = resp.readAll(_).toString(respHeaders.toNodeCharset());
		if(respHeaders.isJSON())
			try {	
				var respData = JSON.parse(respData);
			}catch(e){
				throw "fusionSession.createSession - Bridge server request - Bad JSON response\n" + e.toString();
			}
		profiler && profiler("PROFILE; Transition session create - got response: " + _endProfile(start));
		var start = profiler && _startProfile();
		// check code
		if (resp.statusCode !== 201 || !respHeaders.isJSON()) {
			tracer && tracer("fusionSession.createSession " + options.url + " statusCode: " + resp.statusCode);
			// respJson contains Fusion JSON error message sent by Java Bridge server
			return {
				body: respData,
				headers: x3Headers,
				statusCode: resp.statusCode
			}
		}
		else {
			var respJson = respData;
			//	get sid from location
			this._sessionUrl = this.sessionUrl = resp.headers["location"];
			this.sid = /\('(.*)'\)$/.exec(resp.headers["location"])[1];
			if (!this.sid) throw "fusionSession.createSession  - Session id expected";
			var x3Headers = {};
			if (resp.headers) {
				for (var p in resp.headers) {
					if (p.indexOf("x3-bridge-" == 0)) {
						x3Headers[p] = resp.headers[p]
					}
				}
			}
			if(resp.headers["content-language"]) {
        		x3Headers["content-language"] = resp.headers["content-language"];
        		this._contentLanguage = resp.headers["content-language"];
			}
			tracer && tracer("fusionSession.connect session sid: " + this.sid + " created");
			tracer && tracer("fusionSession.connect session sid: " + this.sid + " reply headers: " + sys.inspect(x3Headers, null, 4));
			profiler && profiler("PROFILE; Transition session create - got content: " + _endProfile(start));
			profiler && profiler("PROFILE; Syracuse transition connect total: " + _endProfile(fncTime));
			return {
				body: respJson,
				headers: x3Headers
			}
		}
	}catch(ex){
		throw _fusionErr(_,ex, "connectionFailed", this._endpoint);
	}
}

sessionProto.proxy = function(_, context, config){
	try {
		var start = _startProfile();
		var tracer = config && config.tracer;
		var profiler = config && config.profiler;
		//
		var toWalk = context.toWalk();
		var baseUrl = context.endpoint.getFusionDataServerBaseUrl(_) + "/$sessions('" + this.sid + "')" + (toWalk ? "/" + toWalk : "");
		var clientReq = context.request;
		//clientReq.setEncoding("binary");
		//	var params = Object.keys(context.parameters).map(function(key) {return key + "=" + encodeURIComponent(context.parameters[key]); }).join("&");
		var params = context.rawQuery;
		var options = {
			url: baseUrl + (params ? ("?" + params) : ""),
			method: context.method,
			headers: clientReq.headers
		}
		tracer && tracer("FusionSession.proxy url: " + options.url);
		var proxyReq = streams.httpRequest(options);
		var buf;
		while (buf = clientReq.read(_)) 
			proxyReq.write(_, buf, "utf8");
		var proxyResp = proxyReq.end().response(_);
		var respHeaders = httpHelpers.parseHeaders(proxyResp.headers);
		proxyResp.setEncoding(respHeaders.toNodeCharset());
		var clientResp = context.response;
		var dis = dispatcher.create(context, function(data){
			// data.headers and data.status have been forwarded by dispatcher only if dispatch is true
			if (!data.headers) 
				data.headers = proxyResp.headers;
			if (!data.status) 
				data.status = proxyResp.statusCode;
			
			// Add response time in httpheaders (dvlp)
			data.headers["syra-proxy-time"] = _endProfile(start);
			clientResp.writeHead(data.status, data.headers);
			// data.body has been forwarded by dispatcher
			clientResp.write(null, data.body, respHeaders.toNodeCharset());  
			clientResp.end();
			profiler && profiler("PROFILE; Transition proxy roundtrip: " + _endProfile(start));
		});
		
		while (buf = proxyResp.read(_)) {
			dis.write(buf, respHeaders.toNodeCharset());
		}
		dis.forward(_, this.sid);
	} catch (ex) {
		throw _fusionErr(_,ex, "proxyFailed", this._endpoint);
    }
}

sessionProto.close = function(_, reuse){
    function _addReuse(url){
        if (!reuse) 
            return url;
        if (url.indexOf("?") >= 0) 
            return url + "&reuse=" + reuse;
        else 
            return url + "?reuse=" + reuse;
    }
	try {
		if (!this._baseUrl) 
			return;
		// delete connection and session
		if (this._sessionUrl) {
			var options = {
				url: _addReuse(this._baseUrl + this._sessionUrl),
				method: "DELETE",
				headers: {
					"accept-charset": "utf-8"
				}
			}
			var request = streams.httpRequest(options);
			// response
			var resp = request.end().response(_);
			// check code
			if (resp.statusCode !== 204) {
				tracer && tracer("Delete session " + this.cid + " statusCode: " + resp.statusCode);
				// resp contains JSON error message sent by Java Bridge server
				var respHeaders = httpHelpers.parseHeaders(resp.headers);
				var respData = resp.readAll(_).toString(respHeaders.toNodeCharset());
				if(respHeaders.isJSON())
					respData = JSON.parse(respData);
				//resp.setEncoding("binary");
				return {
					body: respData,
					statusCode: resp.statusCode
				}
			}
			tracer && tracer("Session " + this.sid + " deleted" + (reuse ? " with reuse" : ""));
		}
		if (this._connectionUrl) {
			var options = {
				url: _addReuse(this._baseUrl + this._connectionUrl),
				method: "DELETE",
				headers: {
					"accept-charset": "utf-8"
				}
			}
			var request = streams.httpRequest(options);
			// response
			var resp = request.end().response(_);
			// check code
			if ((resp.statusCode !== 204) && (resp.statusCode !== 404)) {
				tracer && tracer("Delete connection " + this.cid + " statusCode: " + resp.statusCode);	
				// resp contains JSON error message sent by Java Bridge server
				var respHeaders = httpHelpers.parseHeaders(resp.headers);
				var respData = resp.readAll(_).toString(respHeaders.toNodeCharset());
				if(respHeaders.isJSON())
					respData = JSON.parse(respData);
				return {
					body: respData,
					statusCode: resp.statusCode
				}
			}
			tracer && tracer("Connection " + this.cid + " deleted" + (reuse ? " with reuse" : ""));
		}
	}catch(ex){		
		throw _fusionErr(_,ex, "closeFailed", this._endpoint);
	}
}

exports.getFusionSession = function(_, fsid){
    return new FusionSession(fsid);
}

// global function called from sessions cleanup
exports.closeSession = function(_, fsid, sessionUrl){
    var options = {
        url: sessionUrl,
        method: "DELETE"
    }
    var request = streams.httpRequest(options);
    var resp = request.end();
    //	var respStr = request.end().response(_).readAll(_).toString("utf8");
    // TODO: decode response ?
}

