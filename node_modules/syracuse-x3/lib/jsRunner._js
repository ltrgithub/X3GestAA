"use strict";

var helpers = require('syracuse-core/lib/helpers'),
	httpClient = require("syracuse-httpclient/lib/httpClient");

var tracerJs = require("syracuse-trace/lib/helper").getTracer("x3Comm.jsRunner");
var perfmon = require('syracuse-perfmon');

function genErrorHead(_, status, message, stack) {
	var result = '';
	var head = {
		"statusCode": status.toString(),
		"message": message,
		"exception": stack
	};
	tracerJs.error && tracerJs.error(stack);
	return {
		header: head,
		body: result
	};
}

var Runner = helpers.defineClass(function() {
	// Futures Map
	this.futures = {};
}, null, {
	execute: function(_, modul, body) {
		var timing = perfmon.start(module, "jsRunner.execute", modul + "." + body.function);

		tracerJs.info && tracerJs.info("******************");
		tracerJs.info && tracerJs.info("Mode: " + body.mode.toUpperCase() + " : Execute JS function from 4GL process...");
		tracerJs.info && tracerJs.info("******************");
		tracerJs.info && tracerJs.info("Module: " + JSON.stringify(modul, null, 2));
		tracerJs.info && tracerJs.info("Body: " + JSON.stringify(body, null, 2));
		try {
			var args = [];
			// Check if arguments must be encoded...
			if (body.args != null) {
				if (body.encodings != null && body.args.length !== body.encodings.length) {
					throw new Error("Body elements 'args' and 'encodings' must have same length.");
				}
				// Decode base64 if body.encodings is set to 1
				body.args.forEach_(_, function(_, elt, idx) {
					if (body.encodings != null && body.encodings[idx] > 0) {
						if (body.encodings[idx] === 1) {
							args[idx] = new Buffer(elt, 'base64');
							tracerJs.info && tracerJs.info("Decrypted argument [" + idx + "]: " + JSON.stringify(args[idx], null, 2));
						} else {
							throw new Error("Specified encodings can be 0 for 'non binary' or 1 for 'binary'");
						}
					} else {
						args[idx] = elt;
					}
				});
			}

			var $module = require(modul);
			// Security: check if the module can be called...
			if (!$module.$exported) throw new Error("module " + modul + " forbidden - $exported flag is not set");

			// Identify Mode and call target function...
			// Call synchronous function
			if (body.mode === "sync") {
				return $module[body['function']].apply(null, args);
			}
			// Call asynchronous function
			else if (body.mode === "wait") {
				// If callback position is not defined, put it at the last argument.
				if (body.callbackIndex == null) {
					body.callbackIndex = -1;
				}
				return $module[body['function']].apply_(_, null, args, body.callbackIndex);
			} else if (body.mode === "future") {
				// If callback position is not defined, put it at the last argument.
				if (body.callbackIndex == null) {
					body.callbackIndex = -1;
				}
				var uuid = helpers.uuid.generate('-');
				var res = $module[body['function']].apply_(!_, null, args, body.callbackIndex);
				// Store the future result and the body received
				this.futures[uuid] = {
					body: body,
					result: res
				};
				return uuid;

			} else {
				return genErrorHead(_, 500, "Invalid mode: Allowed modes are 'sync', 'wait' or 'future'.", 'no stack');
			}
		} catch (e) {
			//console.error(e.stack);
			if (e.message === "Cannot call method 'apply_' of undefined") {
				return genErrorHead(_, 404, "The method '" + body['function'] + "' doesn't exists.", e.stack);
			} else if (e.message === "Cannot find module '" + modul + "'") {
				return genErrorHead(_, 404, e.message, e.stack);
			} else if (e.message === "forbidden") {
				return genErrorHead(_, 403, "The module '" + modul + "' is not authorized to be called from X3", e.stack);
			} else {
				return genErrorHead(_, 500, e.message, e.stack);
			}
		} finally {
			timing.end();
		}

	},

	buildResponse: function(_, result, body, future) {
		var res;
		try {
			// If an error occurs in execute function, the response is already generated...
			if (result != null && typeof result === "object" && result.header != null && result.statusCode !== 200 && result.body != null) {
				res = result;
			}

			if (res == null) {
				// If future mode, ignore ignore 'return' and 'return_encoding' properties.
				if (!future) {
					if (body && body['return'] != null) {
						try {
							result = eval('result.' + body['return']);
						} catch (e) {
							return genErrorHead(_, 500, "Property " + body['return'] + " doesn't exists.", e.stack);
						}

					}
					if (body.return_encoding && body.return_encoding === 1) {
						try {
							if (result && result.length > 0) result = new Buffer(result, 'binary').toString('base64');
						} catch (e) {
							return genErrorHead(_, 500, "A problem oocured while enconding response to base64", e.stack);
						}
					}
				}
				if (result && typeof result !== 'object') result = result.toString();
				res = {
					header: {
						"statusCode": "200",
						"message": "OK",
						"content-type": "application/json",
						"content-length": result && result.length ? result.length.toString() : "0"
					},
					body: result
				};
			}
		} catch (e) {
			return genErrorHead(_, 500, "A problem occured while building response", e.stack);
		}
		tracerJs.info && tracerJs.info("Function Result: " + JSON.stringify(res, null, 2));
		return res;
	},

	httpRequest: function(_, header, body) {
		tracerJs.info && tracerJs.info("******************");
		tracerJs.info && tracerJs.info("Execute HTTP request from 4GL process...");
		tracerJs.info && tracerJs.info("******************");
		tracerJs.info && tracerJs.info("Header: " + JSON.stringify(header, null, 2));
		tracerJs.info && tracerJs.info("Body: " + JSON.stringify(body, null, 2));
		var res;
		try {

			var request = httpClient.httpRequest(_, header);
			if (header.method === 'POST' || header.method === 'PUT') {
				request.write(_, body);
			}

			var resp = request.end().response(_);
			resp.setEncoding("utf8");
			var content = resp.readAll(_);

			resp.headers.statusCode = resp.statusCode.toString();
			if (resp.statusCode !== 200) {
				resp.headers.message = content;
			}

			res = {
				header: resp.headers,
				body: resp.statusCode === 200 ? content : ""
			};
		} catch (e) {
			return genErrorHead(_, 500, "A problem occured while executing HTTP request", e.stack);
		}
		tracerJs.info && tracerJs.info("HTTP Result: " + JSON.stringify(res, null, 2));
		return res;

	}
});

var runner = new Runner();

exports.execute = function(_, modul, body) {
	var result = runner.execute(_, modul, body);
	return runner.buildResponse(_, result, body, body.mode === "future");
};

exports.getResult = function(_, uuid) {
	tracerJs.info && tracerJs.info("******************");
	tracerJs.info && tracerJs.info("Retrieve future: " + uuid);
	tracerJs.info && tracerJs.info("******************");
	var future = runner.futures[uuid];
	if (future == null) return genErrorHead(_, 500, "The 'future' corresponding to uuid '" + uuid + "' doesn't exist", 'no stack');
	var result = future.result(_);
	var response = runner.buildResponse(_, result, future.body);
	delete runner.futures[uuid];
	return response;
};

exports.httpRequest = function(_, header, body) {
	return runner.httpRequest(_, header, body);
};