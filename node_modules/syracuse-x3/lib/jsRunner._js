"use strict";

var streams = require("streamline/lib/streams/streams"),
	helpers = require('syracuse-core/lib/helpers'),
	jsxml = require('jsxml'),
	util = require('util');

var tracer = helpers.fusionProxyTracer != null ? helpers.fusionProxyTracer : false;

var Runner = helpers.defineClass(function() {

}, null, {
	execute: function(_, modul, body){
		 
		function processArgs(){
			if (body.args != null){
				if (body.encodings != null && body.args.length !== body.encodings.length){
					console.log("Body args length: "+body.args.length);
					console.log("Body encodings length: "+body.encodings.length);
					throw new Error("Body elements 'args' and 'encodings' must have same length.");
					
				}
				// Decode base64 if body.encodings is set to 1
				body.args.forEach(function(elt, idx){
					if (body.encodings != null && body.encodings[idx] === 1){
						args[idx] = new Buffer(elt, 'base64').toString('utf-8');
					}else{
						args[idx] = elt;
					}
				});
			}
		}
		
		function genErrorHead(status, message, exception){
			var result = '';
			var head = {
					  "statusCode": status,
					  "message": message,
					 // "exception": exception
					}
			return JSON.stringify({
				header: head,
				body: result
			});
		}
		
		var head, result;
		var args = [];
		

		try{
			processArgs();
		}catch(e){
			return genErrorHead(500, e.message, e.stack);
		}
		
		try{
			var $module = require(modul);
			if (!$module.$exported)
				throw new Error("forbidden");
			
			if (body.mode == "sync" ){
				result = $module[body.function].apply(null, args);
			}else if (body.mode == "wait"){
				if (body.callbackIndex == null){
					body.callbackIndex = -1;
				}
				result = $module[body.function].apply_(_, null, args, body.callbackIndex);
			}else{
				return genErrorHead(500, "Invalid mode: Allowed modes are 'sync' or 'wait'.", 'no stack');
			}
		}catch(e){
			if (e.message == "Cannot call method 'apply_' of undefined"){
				return genErrorHead(404, "The method '" + body.function + "' doesn't exists.", e.stack);
			}else if ( e.message == "Cannot find module '" + modul + "'"){
				return genErrorHead(404, e.message, e.stack);
			}else if ( e.message == "forbidden"){
				return genErrorHead(403, "This module is not authorized to be call from X3", e.stack);
			}else{
				return genErrorHead(500, e.message, e.stack);
			}
		}
		
		if (body.return != null){
			try{
				result = eval('result.'+body.return);
			}catch(e){
				return genErrorHead(500, "Property " + body.return + " doesn't exists.", e.stack);
			}
			
		}
		
		if (body.return_encoding && body.return_encoding === 1){
			try{
				//console.log("Resss: "+result);
				if (result && result.length > 0)
					result = new Buffer(result, 'binary').toString('base64');
			}catch(e){
				return genErrorHead(500, "A problem oocured while enconding response to base64", e.stack);
			}
		}

		head = {
		  "statusCode": 200,
		  "message": "OK",
		  "content-type": "application/json",
		  "content-length": result && result.length ? result.length.toString() : "0"
		}
		

		return JSON.stringify({
			header: head,
			body: result
		});
	},
	
	
	httpRequest: function(_, header, body){
		console.log("Header: "+JSON.stringify(header,null,2));
		var request = streams.httpRequest(header);
		if (header.method == 'POST' || header.method == 'PUT'){
			request.write(_,body);
		}

		var resp = request.end().response(_);
		resp.setEncoding("utf8");
		var content = resp.readAll(_);
		
		resp.headers.statusCode = resp.statusCode;
		if (resp.statusCode !== 200)
			resp.headers.message = content
		return JSON.stringify({
			header: resp.headers,
			body: resp.statusCode === 200 ? content : ""
		});
		
	}
});



exports.execute = function(_, modul, body){
	var runner = new Runner();
	return runner.execute(_, modul, body);
}

exports.httpRequest = function(_, header, body){
	var runner = new Runner();
	return runner.httpRequest(_, header, body);
}