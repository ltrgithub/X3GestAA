"use strict";

var helpers = require('syracuse-core/lib/helpers'),
	config = require('syracuse-main/lib/nodeconfig').config,
	httpClient = require("syracuse-httpclient/lib/httpClient");

var trace = config.jsRunner && config.jsRunner.trace;

function genErrorHead(status, message, exception) {
	var result = '';
	var head = {
		"statusCode": status.toString(),
		"message": message,
		"exception": exception
	};
	return {
		header: head,
		body: result
	};
}

var Runner = helpers.defineClass(function() {
	// Futures Map
	this.futures = {};
}, null, {
	execute: function(_, modul, body) {

		trace && trace("******************");
		trace && trace("Mode: " + body.mode.toUpperCase() + " : Execute JS function from 4GL process...");
		trace && trace("******************");
		trace && trace("Module: " + JSON.stringify(modul, null, 2));
		trace && trace("Body: " + JSON.stringify(body, null, 2));
		try {
			var args = [];
			// Check if arguments must be encoded...
			if (body.args != null) {
				if (body.encodings != null && body.args.length !== body.encodings.length) {
					throw new Error("Body elements 'args' and 'encodings' must have same length.");
				}
				// Decode base64 if body.encodings is set to 1
				body.args.forEach(function(elt, idx) {
					if (body.encodings != null && body.encodings[idx] > 0) {
						if (body.encodings[idx] === 1) {
							args[idx] = new Buffer(elt, 'base64');
							trace && trace("Decrypted argument [" + idx + "]: " + JSON.stringify(args[idx], null, 2));
						} else {
							throw new Error("Specified encodings can be 0 for 'non binary' or 1 for 'binary'");
						}
					} else {
						args[idx] = elt;
					}
				});
			}

			var $module = require(modul);
			// Security: check if the module can be called...
			if (!$module.$exported) throw new Error("forbidden");

			// Identify Mode and call target function...
			// Call synchronous function
			if (body.mode === "sync") {
				return $module[body['function']].apply(null, args);
			}
			// Call asynchronous function
			else if (body.mode === "wait") {
				// If callback position is not defined, put it at the last argument.
				if (body.callbackIndex == null) {
					body.callbackIndex = -1;
				}
				return $module[body['function']].apply_(_, null, args, body.callbackIndex);
			} else if (body.mode === "future") {
				// Put 'null' in the place of the callback
				if (body.callbackIndex >= 0) {
					args.splice(body.callbackIndex, 0, null);
				}
				var uuid = helpers.uuid.generate('-');
				var res = $module[body['function']].apply(null, args);
				// Store the future result and the body received
				this.futures[uuid] = {
					body: body,
					result: res
				};
				return uuid;

			} else {
				return genErrorHead(500, "Invalid mode: Allowed modes are 'sync', 'wait' or 'future'.", 'no stack');
			}
		} catch (e) {
			//console.error(e.stack);
			if (e.message === "Cannot call method 'apply_' of undefined") {
				return genErrorHead(404, "The method '" + body['function'] + "' doesn't exists.", e.stack);
			} else if (e.message === "Cannot find module '" + modul + "'") {
				return genErrorHead(404, e.message, e.stack);
			} else if (e.message === "forbidden") {
				return genErrorHead(403, "The module '" + modul + "' is not authorized to be called from X3", e.stack);
			} else {
				return genErrorHead(500, e.message, e.stack);
			}
		}

	},

	buildResponse: function(result, body, future) {
		var res;
		try {
			// If an error occurs in execute function, the response is already generated...
			if (result != null && typeof result === "object" && result.header != null && result.body != null) res = result;

			if (res == null) {
				// If future mode, ignore ignore 'return' and 'return_encoding' properties.
				if (!future) {
					if (body['return'] != null) {
						try {
							result = eval('result.' + body['return']);
						} catch (e) {
							return genErrorHead(500, "Property " + body['return'] + " doesn't exists.", e.stack);
						}

					}
					if (body.return_encoding && body.return_encoding === 1) {
						try {
							if (result && result.length > 0) result = new Buffer(result, 'binary').toString('base64');
						} catch (e) {
							return genErrorHead(500, "A problem oocured while enconding response to base64", e.stack);
						}
					}
				}
				if (result && typeof result !== 'object') result = result.toString();
				res = {
					header: {
						"statusCode": "200",
						"message": "OK",
						"content-type": "application/json",
						"content-length": result && result.length ? result.length.toString() : "0"
					},
					body: result
				};
			}
		} catch (e) {
			return genErrorHead(500, "A problem oocured while building response", e.stack);
		}
		trace && trace("Function Result: " + JSON.stringify(res, null, 2));
		return res;
	},

	httpRequest: function(_, header, body) {
		trace && trace("******************");
		trace && trace("Execute HTTP request from 4GL process...");
		trace && trace("******************");
		trace && trace("Header: " + JSON.stringify(header, null, 2));
		trace && trace("Body: " + JSON.stringify(body, null, 2));
		var res;
		try {

			var request = httpClient.httpRequest(_, header);
			if (header.method === 'POST' || header.method === 'PUT') {
				request.write(_, body);
			}

			var resp = request.end().response(_);
			resp.setEncoding("utf8");
			var content = resp.readAll(_);

			resp.headers.statusCode = resp.statusCode.toString();
			if (resp.statusCode !== 200) {
				resp.headers.message = content;
			}

			res = {
				header: resp.headers,
				body: resp.statusCode === 200 ? content : ""
			};
		} catch (e) {
			return genErrorHead(500, "A problem occured while executing HTTP request", e.stack);
		}
		trace && trace("HTTP Result: " + JSON.stringify(res, null, 2));
		return res;

	}
});

var runner = new Runner();

exports.execute = function(_, modul, body) {
	var result = runner.execute(_, modul, body);
	return runner.buildResponse(result, body, body.mode === "future");
};

exports.getResult = function(_, uuid) {
	trace && trace("******************");
	trace && trace("Retrieve future: " + uuid);
	trace && trace("******************");
	var future = runner.futures[uuid];
	if (future == null) return genErrorHead(500, "The 'future' corresponding to uuid '" + uuid + "' doesn't exist", 'no stack');
	var result = future.result(_);
	var response = runner.buildResponse(result, future.body);
	delete runner.futures[uuid];
	return response;
};

exports.httpRequest = function(_, header, body) {
	return runner.httpRequest(_, header, body);
};