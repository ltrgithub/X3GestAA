"use strict";

var streams = require("streamline/lib/streams/streams"),
	helpers = require('syracuse-core/lib/helpers'),
	jsxml = require('jsxml'),
	util = require('util'),
	config = require('syracuse-main/lib/nodeconfig').config;

var trace = config.jsRunner && config.jsRunner.trace;

var Runner = helpers.defineClass(function() {

}, null, {
	execute: function(_, modul, body){
		 
		trace && trace("******************");
		trace && trace("Execute JS function from 4GL process...");
		trace && trace("******************");
		
		trace && trace("Module: "+JSON.stringify(modul,null,2));
		trace && trace("Body: "+JSON.stringify(body,null,2));
		
		function processArgs(){
			if (body.args != null){
				if (body.encodings != null && body.args.length !== body.encodings.length){
					throw new Error("Body elements 'args' and 'encodings' must have same length.");
				}
				// Decode base64 if body.encodings is set to 1
				body.args.forEach(function(elt, idx){
					if (body.encodings != null && body.encodings[idx] === 1){
						args[idx] = new Buffer(elt, 'base64').toString('utf-8');
					}else{
						args[idx] = elt;
					}
				});
			}
		}
		
		function genErrorHead(status, message, exception){
			var result = '';
			var head = {
			  "statusCode": status.toString(),
			  "message": message,
			  "exception": exception
			}
			var res = {
				header: head,
				body: result
			};
			trace && trace("Function Result: "+JSON.stringify(res,null,2));
			return res;
		}
		
		var head, result;
		var args = [];
		

		try{
			processArgs();
		}catch(e){
			return genErrorHead(500, e.message, e.stack);
		}
		
		try{
			var $module = require(modul);
			if (!$module.$exported)
				throw new Error("forbidden");
			
			if (body.mode == "sync" ){
				result = $module[body.function].apply(null, args);
			}else if (body.mode == "wait"){
				if (body.callbackIndex == null){
					body.callbackIndex = -1;
				}
				result = $module[body.function].apply_(_, null, args, body.callbackIndex);
			}else{
				return genErrorHead(500, "Invalid mode: Allowed modes are 'sync' or 'wait'.", 'no stack');
			}
		}catch(e){
			if (e.message == "Cannot call method 'apply_' of undefined"){
				return genErrorHead(404, "The method '" + body.function + "' doesn't exists.", e.stack);
			}else if ( e.message == "Cannot find module '" + modul + "'"){
				return genErrorHead(404, e.message, e.stack);
			}else if ( e.message == "forbidden"){
				return genErrorHead(403, "This module is not authorized to be call from X3", e.stack);
			}else{
				return genErrorHead(500, e.message, e.stack);
			}
		}
		
		if (body.return != null){
			try{
				result = eval('result.'+body.return);
			}catch(e){
				return genErrorHead(500, "Property " + body.return + " doesn't exists.", e.stack);
			}
			
		}
		
		if (body.return_encoding && body.return_encoding === 1){
			try{
				if (result && result.length > 0)
					result = new Buffer(result, 'binary').toString('base64');
			}catch(e){
				return genErrorHead(500, "A problem oocured while enconding response to base64", e.stack);
			}
		}

		head = {
		  "statusCode": "200",
		  "message": "OK",
		  "content-type": "application/json",
		  "content-length": result && result.length ? result.length.toString() : "0"
		}
		
		
		var res = {
			header: head,
			body: result
		};
		
		trace && trace("Function Result: "+JSON.stringify(res,null,2));
		return res;
	},
	
	
	httpRequest: function(_, header, body){
		var trace = x3helpers.config("dispatch.trace",localConfig);
		trace && trace("******************");
		trace && trace("Execute HTTP request from 4GL process...");
		trace && trace("******************");
		trace && trace("Header: "+JSON.stringify(header,null,2));
		trace && trace("Body: "+JSON.stringify(body,null,2));
		var request = streams.httpRequest(header);
		if (header.method == 'POST' || header.method == 'PUT'){
			request.write(_,body);
		}

		var resp = request.end().response(_);
		resp.setEncoding("utf8");
		var content = resp.readAll(_);
		
		resp.headers.statusCode = resp.statusCode.toString();
		if (resp.statusCode !== 200) {
			resp.headers.message = content
		}
		
		var res = {
			header: resp.headers,
			body: resp.statusCode === 200 ? content : ""
		};
   	 	trace && trace("HTTP Result: "+JSON.stringify(res,null,2));
   	 	return res;

	}
});



exports.execute = function(_, modul, body){
	var runner = new Runner();
	return runner.execute(_, modul, body);
}

exports.httpRequest = function(_, header, body){
	var runner = new Runner();
	return runner.httpRequest(_, header, body);
}