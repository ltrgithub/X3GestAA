"use strict";

var helpers = require('syracuse-core/lib/helpers'),
	config = require('config'),
	httpClient = require("syracuse-httpclient/lib/httpClient");
var fs = require('streamline-fs');
var path = require('path');

var tracerJs = require("syracuse-trace/lib/helper").getTracer("x3Comm.jsRunner");
var perfmon = require('syracuse-perfmon');

function genErrorHead(status, message, stack) {
	var result = '';
	var head = {
		"statusCode": status.toString(),
		"message": message,
		"exception": stack
	};
	tracerJs.error && tracerJs.error(stack);
	return {
		header: head,
		body: result
	};
}

// finds package.json file for that module path and looks whether
function explorePackage(_, modul) {
	// look for first package.json file
	var modulpth = require.resolve(modul);
	var modulpth2 = modulpth.replace(/\.\w+$/, "");
	var pth = modulpth;
	var dir;
	while ((dir = path.dirname(pth)) !== pth) {
		try {
			var f = fs.readFile(path.join(dir, "package.json"), _);
			try {
				var content = JSON.parse(f.toString());
				var apis = content.sage.x3.extensions['4gl-apis'];
				return apis.some(function(mod) {
					var j = path.join(dir, mod.module);
					return (j === modulpth || j === modulpth2);
				});
			} catch (e) {
				// package.json is not valid JSON or does not contain 4gl-apis section
				return false;
			}
		} catch (e) {
			// no package.json file found - try next directory
			if (e.code === 'ENOENT') {
				pth = dir;
				continue;
			}
			throw e;
		}
		return false;
	}
	return false;
}
// for unit tests
exports.explorePackage = explorePackage;


var Runner = helpers.defineClass(function() {
	// Futures Map
	this.futures = {};
}, null, {
	// now this function includes generateResponse!
	execute: function(_, modul, body) {
		var timing = perfmon.start(module, "jsRunner.execute", modul + "." + body.function);

		tracerJs.info && tracerJs.info("******************");
		tracerJs.info && tracerJs.info("Mode: " + body.mode.toUpperCase() + " : Execute JS function from 4GL process...");
		tracerJs.info && tracerJs.info("******************");
		tracerJs.info && tracerJs.info("Module: " + JSON.stringify(modul, null, 2));
		tracerJs.info && tracerJs.info("Body: " + JSON.stringify(body, null, 2));
		try {
			var args = [];
			// Check if arguments must be encoded...
			if (body.args != null) {
				if (body.encodings != null && body.args.length !== body.encodings.length) {
					throw new Error("Body elements 'args' and 'encodings' must have same length.");
				}
				// Decode base64 if body.encodings is set to 1
				body.args.forEach(function(elt, idx) {
					if (body.encodings != null && body.encodings[idx] > 0) {
						if (body.encodings[idx] === 1) {
							args[idx] = new Buffer(elt, 'base64');
							tracerJs.info && tracerJs.info("Decrypted argument [" + idx + "]: " + JSON.stringify(args[idx], null, 2));
						} else {
							throw new Error("Specified encodings can be 0 for 'non binary' or 1 for 'binary'");
						}
					} else {
						args[idx] = elt;
					}
				});
			}

			var $module = require(modul);
			// Security: check if the module can be called...
			if (!$module.$exported) {
				if (explorePackage(_, modul)) $module.$exported = true; // set exported flag - then package check is not necessary any more next time 
				else
					return genErrorHead(403, "The module '" + modul + "' is not authorized to be called from X3");
			}

			if (!(body['function'] in $module))
				return genErrorHead(404, "The " + body.mode + " method '" + body['function'] + "' doesn't exist.");
			var fnc = $module[body['function']];
			if (!(typeof fnc === 'function'))
				return genErrorHead(404, "The property '" + body['function'] + "' is not a (" + body.mode + ") function.");

			// Identify Mode and call target function...
			// Call synchronous function
			if (body.mode === "sync") {
				// no future!
				return this.buildResponse(_, fnc.apply(null, args), body, false);
			}
			// Call asynchronous function
			else if (body.mode === "wait") {
				// If callback position is not defined, put it at the last argument.
				if (body.callbackIndex == null) {
					body.callbackIndex = -1;
				}
				// no future!
				return this.buildResponse(_, fnc.apply_(_, null, args, body.callbackIndex), body, false);
			} else if (body.mode === "future") {
				// If callback position is not defined, put it at the last argument.
				if (body.callbackIndex == null) {
					body.callbackIndex = -1;
				}
				var uuid = helpers.uuid.generate('-');
				var res = fnc.apply_(!_, null, args, body.callbackIndex);
				// Store the future result and the body received
				this.futures[uuid] = {
					body: body,
					result: res
				};
				// with future
				return this.buildResponse(_, uuid, body, true);

			} else {
				throw new Error("Invalid mode: Allowed modes are 'sync', 'wait' or 'future'.");
			}
		} catch (e) {
			if (e.code === "MODULE_NOT_FOUND") {
				return genErrorHead(404, e.message);
			}
			console.error(e.stack);
			return genErrorHead(500, e.message, e.safeStack);
		} finally {
			timing.end();
		}

	},

	buildResponse: function(_, result, body, future) {
		var res;
		try {
			// If future mode, ignore 'return' and 'return_encoding' properties.
			if (!future) {
				if (body && body['return'] != null) {
					try {
						result = eval('result.' + body['return']);
					} catch (e) {
						return genErrorHead(500, "Property " + body['return'] + " doesn't exist.", e.safeStack);
					}

				}
				if (body.return_encoding && body.return_encoding === 1) {
					try {
						if (result && result.length > 0) result = new Buffer(result, 'binary').toString('base64');
					} catch (e) {
						return genErrorHead(500, "A problem oocured while enconding response to base64", e.safeStack);
					}
				}
			}
			if (result && typeof result !== 'object') result = result.toString();

			// result can already be ready for reply
			if (result && result.statusCode && result.header && result.body !== undefined) {
				res = result;
				result.message = require('http').STATUS_CODES[result.statusCode];
			} else {
				res = {
					header: {
						"statusCode": "200",
						"message": "OK",
						"content-type": "application/json",
						"content-length": result && result.length ? result.length.toString() : "0"
					},
					body: result
				};
			}
		} catch (e) {
			return genErrorHead(500, "A problem occured while building response", e.safeStack);
		}
		tracerJs.info && tracerJs.info("Function Result: " + JSON.stringify(res, null, 2));
		return res;
	},

	httpRequest: function(_, header, body) {
		tracerJs.info && tracerJs.info("******************");
		tracerJs.info && tracerJs.info("Execute HTTP request from 4GL process...");
		tracerJs.info && tracerJs.info("******************");
		tracerJs.info && tracerJs.info("Header: " + JSON.stringify(header, null, 2));
		tracerJs.info && tracerJs.info("Body: " + JSON.stringify(body, null, 2));
		var res;
		try {

			var request = httpClient.httpRequest(_, header);
			if (header.method === 'POST' || header.method === 'PUT') {
				request.write(_, body);
			}

			var resp = request.end().response(_);
			resp.setEncoding("utf8");
			var content = resp.readAll(_);

			resp.headers.statusCode = resp.statusCode.toString();
			if (resp.statusCode !== 200) {
				resp.headers.message = content;
			}

			res = {
				header: resp.headers,
				body: resp.statusCode === 200 ? content : ""
			};
		} catch (e) {
			return genErrorHead(500, "A problem occured while executing HTTP request", e.safeStack);
		}
		tracerJs.info && tracerJs.info("HTTP Result: " + JSON.stringify(res, null, 2));
		return res;

	}
});

var runner = new Runner();

exports.execute = function(_, modul, body) {
	return runner.execute(_, modul, body);
};

exports.getResult = function(_, uuid) {
	tracerJs.info && tracerJs.info("******************");
	tracerJs.info && tracerJs.info("Retrieve future: " + uuid);
	tracerJs.info && tracerJs.info("******************");
	var future = runner.futures[uuid];
	if (future == null) return genErrorHead(500, "The 'future' corresponding to uuid '" + uuid + "' doesn't exist", 'no stack');
	try {
		var result = future.result(_);
	} catch (e) {
		return genErrorHead(500, e.message, e.safeStack);
	}
	var response = runner.buildResponse(_, result, future.body);
	delete runner.futures[uuid];
	return response;
};

exports.httpRequest = function(_, header, body) {
	return runner.httpRequest(_, header, body);
};