"use strict";
// Low level formatting functions shared by engine and fusion client
var helpers = require('syracuse-core/lib/helpers');
var date = require('syracuse-core/lib/types/date');
var datetime = require('syracuse-core/lib/types/datetime');
var locale = require("syracuse-core/lib/locale");
var resources = locale.resources(module);

function _isLower(ch) {
	return ch >= 'a' && ch <= 'z';
}

function _isUpper(ch) {
	return ch >= 'A' && ch <= 'Z';
}

function _isDigit(ch) {
	return ch >= '0' && ch <= '9';
}

function _isHexa(ch) {
	return (ch >= 'A' && ch <= 'F') || (ch >= '0' && ch <= '9');
}

var _months3 = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];

function _monthName(month, repeat) {
	// for now, get it from JS resource and capitalize (wrong for French!)
	// crnit: locale files doesn't support objects
	//	var s = resources().monthNames[month - 1] || '';
	var s = resources()["monthNames." + month] || '';
	while (s.length < repeat)
		s += ' ';
	return s.length > repeat ? s.substring(0, repeat) : s;
}

function _findMonth(name) {
	if (name.length === 0) return -1;
	// crnit: locale files doesn't support objects
	//	var names = resources().monthNames;
	/*	for (var i = 0; i < names.length; i++) {
		if (names[i].substring(0, name.length) === name) return i + 1;
	}*/
	var n = -1;
	var res = resources();
	Object.keys(res).some(function(rKey) {
		var p = rKey.split(".");
		if ((p[0] === "monthNames") && (res[rKey].substring(0, name.length) === name)) {
			n = p[1];
			return true;
		}
		return false;
	});
	return n;
}

var ORIGIN = date.make(1599, 12, 31);

var SP = ' '.charCodeAt(0);

// VIREBLC engine functions
var trimFuncs = exports.trimFuncs = [

	function(s) { // left
		var i, len = s.length;
		for (i = 0; i < len && s.charCodeAt(i) === SP; i++);
		return i === 0 ? s : s.substring(i);
	},
	function(s) { // right
		var i, len = s.length;
		for (i = len - 1; i >= 0 && s.charCodeAt(i) === SP; i--);
		return i === len ? s : s.substring(0, i + 1);
	},
	function(s) { // both
		var i, j, len = s.length;
		for (i = 0; i < len && s.charCodeAt(i) === SP; i++);
		for (j = len - 1; j >= i && s.charCodeAt(j) === SP; j--);
		return s.substring(i, j + 1);
	},
	function(s) { // token
		var i, j, len = s.length;
		for (i = 0; i < len && s.charCodeAt(i) === SP; i++);
		for (j = i; j < len && s.charCodeAt(j) !== SP; j++);
		return s.substring(i, j);
	},
	function(s) { // all
		return s.replace(/ /g, '');
	},
	function(s) { // adjacent
		return s.replace(/[ ]+/g, ' ');
	}
];

// FORMAT$ engine function

function process(settings, fmt, val, parse) {
	// engine passes settings directly as ADXSCA array.
	// use this format internally for max engine efficiency.
	var special = settings.ADXSCA || ['?', '?', settings.thousandSep || '', settings.decimalSep || '.', settings.badChar || '#', settings.fillChar || '*'];
	var options = {},
		fmtPos = 0,
		fmtChar, repeat, badChar = ' ',
		secretChar, fillChar, fmtLen = fmt.length,
		srcPos = 0,
		now, integ = "",
		lenIntg,
		decim = "",
		partStr, partNum = 0,
		numExtra = 0,
		// number of chars added to integral part
		valid = true,
		result = "",
		negative = false,
		dynTypes,
		badFormat = false;

	function _throwBadFormat(txt) {
		badFormat = true;
		throw new Error(txt ? txt : "Unexpected format character " + (fmtChar ? " [" + fmtChar + "] " : "") + "- Position[" + (srcPos - 1) + "] - Format='" + fmt + "'");
	}

	function _fmtInt(val, repeat, forbid0) {
		var s;
		if (val === 0 && forbid0 /* && options.Z*/ ) {
			s = '';
			while (repeat-- > 0) s += ' ';
			return s;
		}
		s = val.toString();
		while (s.length < repeat) s = "0" + s;
		return s;
	}

	function _mismatch(got, expected, ignore) {
		valid = false;
		if (!ignore) throw new Error("value does not match format: fmt: " + fmt + ": expected " + expected + ", got " + got + " at index " + srcPos + " in '" + val + "'");
	}

	function formatChar(fmtChar, valChar, depth, ignore) {
		switch (fmtChar) {
			case 'X':
				break;
			case 'A':
				if (!_isUpper(valChar)) {
					if (_isLower(valChar) && !options.A) valChar = valChar.toUpperCase();
					else _mismatch(valChar, "uppercase letter", ignore);
				}
				break;
			case 'a':
				if (!_isLower(valChar)) {
					if (_isUpper(valChar) && !options.A) valChar = valChar.toLowerCase();
					else _mismatch(valChar, "lowercase letter", ignore);
				}
				break;
			case 'B':
				if (!_isUpper(valChar) && !_isDigit(valChar)) {
					if (_isLower(valChar) && !options.A) valChar = valChar.toUpperCase();
					else _mismatch(valChar, "uppercase letter or digit", ignore);
				}
				break;
			case 'b':
				if (!_isLower(valChar) && !_isDigit(valChar)) {
					if (_isUpper(valChar) && !options.A) valChar = valChar.toLowerCase();
					else _mismatch(valChar, "lowercase letter or digit", ignore);
				}
				break;
			case 'C':
				if (!_isLower(valChar) && !_isUpper(valChar) && !_isDigit(valChar)) {
					_mismatch(valChar, "letter or digit", ignore);
				}
				break;
			case 'L':
				if (!_isLower(valChar) && !_isUpper(valChar)) {
					_mismatch(valChar, "lowercase letter", ignore);
				}
				break;
			case 'H':
				if (!_isHexa(valChar)) {
					_mismatch(valChar, "hexadecimal character", ignore);
				}
				break;
			case ' ':
				if (fmtChar !== ' ') {
					_mismatch(valChar, "space", ignore);
				}
				break;
			case '#':
				if (!_isDigit(valChar)) {
					// We accept ' ' but we don't append them to result
					if (parse && valChar == ' ') return '';
					_mismatch(valChar, "digit", ignore);
				}
				break;
			default:
				var dyn = settings.dynFormats && settings.dynFormats[fmtChar];
				if (dyn) {
					if (depth === 0) dynTypes = [fmtChar];
					var savValid = valid;
					for (var i = 0; i < dyn.subType.length; i++) {
						var dynChar = dyn.subType[i];
						// dynTypes guards us against infinite recursion if cycle in dyn formats
						if (dynTypes.indexOf(dynChar) < 0) {
							dynTypes.push(dynChar);
							valid = true;
							var ch = formatChar(dynChar, valChar, depth + 1, true);
							if (valid) {
								valid = savValid;
								return ch;
							}
						}
					}
					if (dyn.complement && dyn.complement.indexOf(valChar) >= 0) {
						valid = savValid;
						return valChar;
					}
					// TODO: improve by describing custom format
					if (depth === 0) {
						dynTypes = [];
						var resolveFmt = function(f) {
							if (!settings.dynFormats) return f;
							var r = '';
							for (var i = 0; i < f.length; i++) {
								var c = f[i];
								if (c == '[') {
									do {
										r += f[i];
									} while (f[i] != ']' && i++ < f.length);
								} else if (settings.dynFormats[c]) {
									if (dynTypes.indexOf(c) < 0) {
										dynTypes.push(c);
										r += '(';
										r += resolveFmt(settings.dynFormats[c].subType, r);
										if (settings.dynFormats[c].complement) {
											r += '(' + settings.dynFormats[c].complement + ')';
										}
										r += ')';
										dynTypes.pop();
									} //else skip
								} else r += c;
							}
							return r;
						};
						throw new Error("Unexpected character - Val[" + val + "] - Position[" + (srcPos - 1) + "] - dynamicFormat='" + fmt + "{" + resolveFmt(fmt.substr(fmt.indexOf(':') + 1)) + "}");
					}
					return valChar;
				} else {
					// #553 - we have the possibility to skip or not skip bad dynamic format error
					if (settings.skipBadFormat === true && settings.skipBadDynFmt === false) {
						// this error is propagated to caller even if skipBadFormat==true
						throw new Error("Unknown dynamic format (" + fmtChar + ") - Format='" + fmt + "'");
					}
					_throwBadFormat("Unknown dynamic format");
				}
		}
		return valChar;
	}

	function stringWalker() {
		if (fmtChar === '>') {
			return; // ignore it
		}
		var isEmpty = result.length === 0;
		for (; repeat > 0; repeat--) {
			var valChar = val[srcPos++];
			if (valChar == null) {
				result += ' ';
			} else {
				valChar = formatChar(fmtChar, valChar, 0, valChar == ' ' && isEmpty);
				isEmpty = isEmpty && valChar == ' ';
				if (secretChar) valChar = secretChar;
				result += valChar;
			}
		}
	}

	function numberFormatter(floatFmt) {
		function flush() {
			if (!partStr) {
				if (partNum === 0 && (options['*'] || options['0'])) partStr = '';
				else return;
			}
			if (partStr.length < repeat + numExtra) {
				if (floatFmt !== true) {
					// FDB - Add fillChar with thousand sep if enabled - Add sign before filling chars
					// N-3zv*:14.# - '14322,34' -> '+* *** *14 322,3'
					if (options['3'] && (options['*'] || options['0']) && integ == partStr && partStr.length < repeat) {
						var tmp = integ,
							r = repeat;
						while (partStr.length < (r + numExtra)) {
							// FDB - No count down for thousand sep (like in cs client) 
							if (tmp.length % (Math.floor(tmp.length / 4) * 4 + 3) === 0) tmp = special[2] + tmp;
							// FDB - No default whitespace as fillChar for numerics (like in cs client) 
							if (fillChar) tmp = fillChar + tmp;
							r--;
						}
						repeat = r;
						result += tmp;
					} else {
						while (partStr.length < repeat--) {
							// FDB - No default whitespace as fillChar for numerics (like in cs client) 
							if (fillChar) result += fillChar;
						}
						result += partStr;
					}
				} else {
					// No fillChar for F format
					result += partStr;
				}
			} else if (partStr.length === repeat + numExtra) {
				result += partStr;
			} else {
				result += partStr.substring(0, repeat);
				if (partNum === 0) {
					valid = false;
					// FDB - integer part is not truncated - Error
					throw new Error("Number of digits overflow [" + partStr + "] - Expected length[" + (repeat + numExtra) + "]");
				}
			}
			numExtra = 0;
			partStr = null;
		}
		switch (fmtChar) {
			case undefined:
				// directive missing after repeat count
			case '#':
				if (partNum === 0) {
					flush();
				} else {
					if (partStr.length < repeat) {
						// X3 engine does not follow spec: Z option is now set by default
						result += partStr;
						if (floatFmt !== true) {
							// No 0 at the end for F format
							while (partStr.length < repeat--) result += '0';
						}
						partStr = '';
					} else {
						// FDB - Add strict option
						// -> Used by edit format - if strict and N:4.2 and user says  '12,345' --> Error - decimal part is not truncated 
						if (settings.strict === true && partStr.length > repeat) {
							throw new Error("Bad decimal part [" + partStr + "] - Expected length[" + repeat + "]");
						}
						result += partStr.substring(0, repeat);
						partStr = partStr.substring(repeat);
					}
				}
				partNum++;
				break;
			case '.':
				if (partNum > 1) throw new Error("too many '.' directives in format");
				flush();
				result += special[3];
				partStr = decim;
				partNum = 1;
				break;
			case 'F':
				// FDB - Process float like std numeric format with same controls
				fmtChar = '#';
				if (parseInt(integ, 10) === 0) integ = '0';
				partStr = integ;
				var extra = numExtra;
				numberFormatter(true);
				repeat = repeat - integ.length + extra;
				if (decim && parseInt(decim, 10) > 0) {
					result += special[3];
					partStr = decim;
					partNum = 1;
					numberFormatter(true);
				}
				break;
			default:
				throw _throwBadFormat();
		}
	}

	function numberParser() {
		var ch;
		if (result === '') {
			// FDB- +/- sign precedes fillChar
			// -> N-3zv*:14.# - '14322,34' -> '+* *** *14 322,3'
			ch = val[srcPos];
			if (ch === '-' && result === '') {
				result += ch;
				srcPos++;
			} else if (ch === '+') {
				if (options['-']) srcPos++;
				else if (settings.strict === true) throw new Error("Unexpected positive sign"); //+ sign only if options['-'] 
				else srcPos++; // Skip + character
			}
			while ((ch = val[srcPos]) && (ch === fillChar || ch === special[2]) && (options['*'] || options['0'])) srcPos++;
		}
		while ((ch = val[srcPos])) {
			if (_isDigit(ch)) result += ch;
			else if ((ch == "-" || ch == "+") && options.D && srcPos == (val.length - 1)) {
				result = ch + result;
				break;
			} else if (!(ch === special[2] && options["3"])) break;
			srcPos++;
		}
		if (ch === special[3] && (fmtChar === '.' || fmtChar === 'F')) {
			result += '.';
			srcPos++;
			while ((ch = val[srcPos]) && _isDigit(ch)) {
				result += ch;
				srcPos++;
			}
		} else if (ch === special[3] && settings.strict === true) {
			throw new Error("No decimal part expected");
		}
	}

	function dateFormatter() {
		switch (fmtChar) {
			case 'D':
				result += _fmtInt(val.day, repeat, true);
				break;
			case 'M':
				if (repeat <= 2) {
					result += _fmtInt(val.month, repeat, true);
				} else if (repeat === 3) {
					result += _months3[val.month - 1] || (fillChar + fillChar + fillChar);
				} else {
					result += _monthName(val.month, repeat);
				}
				break;
			case 'Y':
				result += _fmtInt(repeat <= 2 ? val.year % 100 : val.year, repeat, val.year === 0);
				break;
			case 'h':
				result += _fmtInt((now = now || datetime.now()).hour, repeat);
				break;
			case 'm':
				result += _fmtInt((now = now || datetime.now()).minute, repeat);
				break;
			case 's':
				result += _fmtInt((now = now || datetime.now()).second, repeat);
				break;
			default:
				_throwBadFormat();
		}
	}

	// FDB - zValue to make the difference with 0 for Z option
	// -> if Z we keep 0 value (not 2000)
	function _parseInt(expected, zValue) {
		var beg = srcPos;
		while (repeat && _isDigit(val[srcPos])) srcPos++, repeat--;
		if (srcPos === beg) {
			if (options.Z) { // second chance
				while (repeat && val[srcPos] === ' ') srcPos++, repeat--;
				return zValue === undefined ? 0 : zValue;
			}
			_mismatch(val[srcPos], expected);
		}
		return parseInt(val.substring(beg, srcPos), 10);
	}

	function dateParser() {
		result = result || {};
		var m;
		switch (fmtChar) {
			case 'D':
				result.day = _parseInt("day of month not a number");
				break;
			case 'M':
				if (repeat <= 2) {
					result.month = _parseInt("month not a number");
				} else if (repeat === 3) {
					m = val.substring(srcPos, srcPos + 3).toUpperCase();
					srcPos += 3;
					result.month = _months3.indexOf(m) + 1;
					if (result.month <= 0) {
						if (options.Z && (m === '   ' || m === '')) result.month = 0;
						else _mismatch(m, "3-letter month name");
					}
				} else {
					m = val.substring(srcPos, srcPos + repeat).replace(/ *$/, '');
					// FDB - accept one or more occurences of whitespaces afer month name
					// Used for country dates - DD1,DD2,DD2,DD4 - Ex: D:DD[ ]MMMMMMMMMMMMM[ ]YYYY accepts 01 Mai 2012 and 01 Mai         2012
					var p = m.indexOf(' ');
					if (p != -1) {
						m = m.substr(0, p);
						repeat = p;
						while (p < m.length && m[p++] == ' ') repeat++;
					}
					srcPos += repeat;
					result.month = _findMonth(m);
					if (result.month <= 0) {
						if (options.Z && /^ *$/.test(m)) result.month = 0;
						else _mismatch(m, "month name[" + m + "]");
					}
				}
				break;
			case 'Y':
				if (repeat <= 2) {
					var wasEmpty = val[srcPos] === ' ';
					var y = _parseInt("year", -99999);
					if (y === -99999) {
						// FDB - Z option - return 0 for date null instead of 2000
						result.year = 0;
					} else {
						var century = Math.floor(new Date().getFullYear() / 100) * 100;
						result.year = wasEmpty ? y : y < settings.datePivot ? century + y : century + y - 100;
					}
				} else {
					result.year = _parseInt("year");
				}
				break;
			case 'h':
				result.hour = _parseInt("hour");
				break;
			case 'm':
				result.minute = _parseInt("minute");
				break;
			case 's':
				result.second = _parseInt("second");
				break;
			default:
				_throwBadFormat();
		}
	}

	function unknownWalker() {
		result += "?";
	}

	try {
		var typeChar = fmt[0];
		// default trim option
		if (typeChar === 'K') options.v = 1;
		else if (typeChar == 'N') options.v = 2;

		var walkers = parse ? {
			K: stringWalker,
			N: numberParser,
			D: dateParser,
			L: unknownWalker
		} : {
			K: stringWalker,
			N: numberFormatter,
			D: dateFormatter,
			L: unknownWalker
		};

		var walker = walkers[typeChar];
		if (walker) {
			for (fmtPos = 1; fmtPos < fmt.length && (fmtChar = fmt[fmtPos]) !== ':'; fmtPos++) {
				switch (fmtChar) {
					case 'v':
						// ignore v option when formatting numbers
						if (typeChar !== 'N' && _isDigit(fmt[fmtPos + 1])) options.v = parseInt(fmt[++fmtPos], 10);
						break;
					default:
						options[fmtChar] = true;
						break;
				}
			}
			fmtPos++;
		} else {
			_throwBadFormat();
		}
		fillChar = options['*'] ? special[5] : options['0'] ? '0' : null;
		// FDB - No default whitespace as fillChar for numerics (like in cs client) 
		if (typeChar != 'N' && fillChar == null) fillChar = ' ';
		if (typeChar === 'N' && !parse) {
			integ = val.toString();
			integ = integ.replace(/[^\d\.\-\+]/g, ''); // get rid of all invalid chars
			if (options.z && (integ === '0' || integ === '')) return '';
			if (integ === '' || integ === '.') integ = '0';
			lenIntg = integ.length - 1;
			// remove leading + that may start value
			if (integ[0] === '+' || integ[0] === '-') {
				negative = integ[0] === '-';
				integ = integ.substring(1);
			} else if ((integ[lenIntg] === '+' || integ[lenIntg] === '-') && options.D) {
				negative = integ[lenIntg] === '-';
				integ = integ.substring(0, lenIntg);
			}
			// TODO: handle scientific format
			var dot = integ.indexOf('.');
			if (dot >= 0) {
				decim = integ.substring(dot + 1);
				integ = integ.substring(0, dot);
			}
			if (options["3"]) {
				// insert thousand separators - FDB - No thousand sep if 3 digit 
				var l = integ.length;
				if (l > 3) {
					var n3 = Math.floor(l) / 3;
					for (var k = 0; k < n3; k++) {
						l = integ.length - 4 * k - 3;
						if (l > 0) {
							integ = integ.substring(0, l) + special[2] + integ.substring(l);
							numExtra++;
						}
					}
				}
			}
			partStr = integ;
			badChar = special[4];
		}
		secretChar = options.X && special[5];
		var lastValid = 0,
			maxLength = 0;
		while (fmtPos < fmtLen) {
			var beg = fmtPos;
			if ((fmtChar = fmt[fmtPos]) === '[') {
				fmtPos = fmt.indexOf(']', fmtPos + 1);
				var lit = fmt.substring(beg + 1, fmtPos);
				if (fmtPos < 0) fmtPos = fmtLen;
				if (parse) {
					// strict mode for parse action - add comments
					maxLength += lit.length;
					var got = val.substring(srcPos, srcPos + lit.length);
					if (got !== lit) {
						// don't signal mismatch at end - also ignore mismatch because of silly [ ] at begining of format
						if (got !== '' && !(result === '' && /^ *$/.test(lit))) _mismatch(got, lit);
						// don't increment srcPos
					} else {
						srcPos += lit.length;
					}
				} else {
					result += lit;
				}
				fmtPos++;
				continue;
			}
			repeat = 0;
			do {
				while (_isDigit(fmtChar = fmt[fmtPos])) fmtPos++;
				repeat += fmtPos > beg ? parseInt(fmt.substring(beg, fmtPos), 10) : fmtChar == '>' ? 0 : 1;
				while (fmtChar && fmtChar === fmt[fmtPos + 1]) {
					fmtPos++;
					repeat++;
				}
				fmtPos++;
				beg = fmtPos;
			} while (fmtChar === '#' && _isDigit(fmt[fmtPos]));
			maxLength += repeat;
			walker.call(this);
			if (valid) lastValid = result.length;
		}
		if (typeChar === 'N' && settings.strict === true && decim && decim.length > 0 && partNum == 1) {
			// FDB - Strict
			throw new Error("No decimal part expected");
		}
		if (val && typeChar === 'K' && settings.strict === true && val.length > maxLength) {
			// FDB - Strict
			throw new Error("Size overflow - nbRead[" + val.length + "] - Expected[" + maxLength + "]");
		}
		if (parse) {
			if (fmt[0] === 'D') {
				if (result.hour !== undefined || result.minute !== undefined || result.second !== undefined) {
					return datetime.make(result.year || new Date().getFullYear(), result.month || 1, result.day || 1, //
						result.hour || 0, result.minute || 0, result.second || 0);
				} else {
					if (result.year === 1599 && result.month === 12 && result.day === 31) return ORIGIN;
					if (!result.year && !result.month && !result.day) return ORIGIN;
					else {
						// Check month and day
						if (result.day < 1 || result.day > 31) {
							_mismatch(JSON.stringify(result), "day of month (1-31)");
						}
						if (result.month < 1 || result.month > 12) {
							_mismatch(JSON.stringify(result), "month number (1-12)");
						}
						return date.make(result.year || new Date().getFullYear(), result.month || 1, result.day || 1);
					}
				}
			} else if (fmt[0] === 'N') {
				var n = parseFloat(result, 10);
				if (isNaN(n)) throw new Error("Bad number");
				if (settings.strict === true && Math.abs(n).toString().replace(/^\d/g, '').length > maxLength) throw new Error("Size overflow");
				return result;
			} else {
				return result;
			}
		} else {
			if (typeChar === 'N') {
				if (!valid) {
					result = result.replace(/./g, badChar);
				} else {
					// FDB - Deal with sign options
					if (options['+'] && negative) throw new Error("Unexpected negative number");
					var sign = negative ? '-' : options['-'] ? '+' : null;
					if (sign) {
						if (options.D) result += sign;
						else result = sign + result;
					}
					if (result.length > 0 && result[result.length - 1] == special[3]) {
						// FDB - Remove last char if decimalSep
						result = result.substr(0, result.length - 1);
					}
				}
			} else if (typeChar === 'D' && lit && lit.length) {
				if (result.replace(new RegExp("\\" + lit + "|" + "\x20", "g"), "") === "") {
					if (options.Z) {
						result = "" // null value autorized;
					} else {
						// TODO : null value not autorisez
					}
				}
			} else if (typeChar === 'K' && lit && lit.length) {
				if (result.replace(new RegExp("\\" + lit + "|" + "\x20", "g"), "") === "") {
					result = "";
				}
			}
			var trim = trimFuncs[options.v];
			return trim && settings.vOn !== false ? trim(result) : result;
		}
	} catch (ex) {
		// If invalid format -> return raw value 
		// #553 - Orginally skipBadFormat worked only with format action (!parse)
		// -> We enable skipBadFormat also for unformat to solve that issue with the risk to allow client to send bad data to X3 server
		if (badFormat === true && settings.skipBadFormat === true) {
			// In order to log a diagnose - This error could occur if X3 field contains a wrong format
			// -> User can enter a value and is not stucked on the field
			if (settings.tracer) settings.tracer("Bad X3 format - " + ex.message);
			return val;
		}
		if (ex.message) ex.message = "Parse[" + parse + "]: " + ex.message;
		throw ex;
	}
}

exports.format = function(settings, fmt, val) {
	//console.log("\tformat - format:" +fmt + " -  value:'"+val+"'");
	var res = process(settings, fmt, val, false);
	//console.log("\t\tres='"+res+"'");
	return res;
};

exports.parse = function(settings, fmt, val) {
	var res = process(settings, fmt, val, true);
	//console.log("\tparse - format:" +fmt + " -  value:'"+val+"' - res='"+res+"'");
	return res;
};