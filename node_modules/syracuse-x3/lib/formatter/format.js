"use strict";
// Low level formatting functions shared by engine and fusion client
var helpers = require('syracuse-core/lib/helpers');
var date = require('syracuse-core/lib/types/date');
var datetime = require('syracuse-core/lib/types/datetime');
var locale = require("syracuse-core/lib/locale");
var resources = locale.resources(module);

function _isLower(ch) {
	return ch >= 'a' && ch <= 'z';
}

function _isUpper(ch) {
	return ch >= 'A' && ch <= 'Z';
}

function _isDigit(ch) {
	return ch >= '0' && ch <= '9';
}

function _isHexa(ch) {
	return (ch >= 'A' && ch <= 'F') || (ch >= '0' && ch <= '9');
}

var _months3 = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];

function _monthName(month, repeat) {
	// for now, get it from JS resource and capitalize (wrong for French!)
	var s = resources().monthNames[month - 1] || '';
	while (s.length < repeat)
	s += ' ';
	return s.length > repeat ? s.substring(0, repeat) : s;
}

var SP = ' '.charCodeAt(0);

// VIREBLC engine functions
var trimFuncs = exports.trimFuncs = [function(s) { // left
	var i, len = s.length;
	for (i = 0; i < len && s.charCodeAt(i) === SP; i++);
	return i === 0 ? s : s.substring(i);
}, function(s) { // right
	var i, len = s.length;
	for (i = len - 1; i >= 0 && s.charCodeAt(i) === SP; i--);
	return i === len ? s : s.substring(0, i + 1);
}, function(s) { // both
	var i, j, len = s.length;
	for (i = 0; i < len && s.charCodeAt(i) === SP; i++);
	for (j = len - 1; j >= i && s.charCodeAt(j) === SP; j--);
	return s.substring(i, j + 1);
}, function(s) { // token
	var i, j, len = s.length;
	for (i = 0; i < len && s.charCodeAt(i) === SP; i++);
	for (j = i; j < len && s.charCodeAt(j) !== SP; j++);
	return s.substring(i, j);
}, function(s) { // all
	return s.replace(/ /g, '');
}, function(s) { // adjacent
	return s.replace(/[ ]+/g, ' ');
}];

// FORMAT$ engine function
exports.format = function(settings, fmt, val) {
	// engine passes settings directly as ADXSCA array.
	// use this format internally for max engine efficiency.
	var special = settings.ADXSCA || ['?', '?', settings.thousandChar || '', settings.decimalChar || '.', settings.badChar || '#', settings.fillChar || '*'];
	var options = {},
		fmtPos = 0,
		fmtChar,
		repeat,
		badChar = ' ', secretChar, fillChar,
		fmtLen = fmt.length,
		srcPos = 0,
		now, 
		integ, decim = "", 
		partStr, partNum = 0, 
		numExtra = 0, // number of chars added to integral part
		valid = true,
		result = "",
		tail = "";

	function badFormat() {
		return "Unexpected format character [" + ch + "] - Position[" + (srcPos - 1) + "] - Format='" + fmt + "'";
	}

	function _fmtInt(val, repeat, forbid0) {
		var s;
		if (val == 0 && forbid0/* && options.Z*/) {
			s = '';
			while (repeat-- > 0) s += ' ';
			return s;
		}
		s = val.toString();
		while (s.length < repeat) s = "0" + s;
		return s;
	}


	var formatters = {
		K: function() {
			for (; repeat > 0; repeat--) {
				var valChar = val[srcPos++];
				var defined = valChar != null;
				valChar = valChar || ' ';
				switch (fmtChar) {
				case 'X':
					break;
				case 'A':
					if (!_isUpper(valChar)) {
						if (_isLower(valChar) && !options.A) valChar = valChar.toUpperCase();
						else valid = false;
					}
					break;
				case 'a':
					if (!_isLower(valChar)) {
						if (_isUpper(valChar) && !options.A) valChar = valChar.toLowerCase();
						else valid = false;
					}
					break;
				case 'B':
					if (!_isUpper(valChar) && !_isDigit(valChar)) {
						if (_isLower(valChar) && !options.A) valChar = valChar.toUpperCase();
						else valid = false;
					}
					break;
				case 'b':
					if (!_isLower(valChar) && !_isDigit(valChar)) {
						if (_isUpper(valChar) && !options.A) valChar = valChar.toLowerCase();
						else valid = false;
					}
					break;
				case 'C':
					if (!_isLower(valChar) && !_isUpper(valChar) && !_isDigit(valChar)) {
						valid = false;
					}
					break;
				case 'L':
					if (!_isLower(valChar) && !_isUpper(valChar)) {
						valid = false;
					}
					break;
				case 'H':
					if (!_isHexa(valChar)) {
						valid = false;
					}
					break;
				case ' ':
					if (fmtChar !== ' ') {
						valid = false;
					}
					break;
				case '#':
					if (!_isDigit(valChar)) {
						valid = false;
					}
					break;
				case '>':
					srcPos--;
					return; // ignore it
				default:
					// we get lower case letter in unit tests - accept them silently
					if (!/[c-z]/.test(fmtChar)) throw new Error(badFormat());
				}
				if (secretChar && defined) valChar = secretChar;
				result += valChar;
			}
		},
		N: function() {
			function flush() {
				if (!partStr) return;
				if (partStr.length < repeat + numExtra) {
					if (fillChar === '0' && partStr[0] === '-') {
						result += '-';
						partStr = partStr.substring(1);
						repeat--;
					}
					while (partStr.length < repeat--) result += fillChar;
					result += partStr;
				} else if (partStr.length === repeat + numExtra) {
					result += partStr;
				} else {
					result += partStr.substring(0, repeat);
					if (partNum === 0) valid = false;
				}
				numExtra = 0;
				partStr = null;
			}
			switch (fmtChar) {
			case undefined: // directive missing after repeat count
			case '#':
				if (partNum === 0) {
					flush();
				} else {
					if (partStr.length < repeat) {
						// X3 engine does not follow spec: Z option is now set by default
						result += partStr;
						while (partStr.length < repeat--) result += '0';
						partStr = '';
					} else {
						result += partStr.substring(0, repeat);
						partStr = partStr.substring(repeat);
					}
				}
				partNum++;
				break;
			case '.':
				if (partNum > 1) throw new Error("too many . directives in format");
				flush();
				result += special[3]
				partStr = decim;
				partNum = 1;
				break;
			case 'F':
				// TODO: check this (it makes FDB tests happy)
				partStr = integ;
				if (partStr.length <= repeat) {
					if (decim) {
						repeat++; // allow decimal char
						partStr = (partStr + special[3] + decim).substring(0, repeat);
					}
				}
				integ = null;
				decim = null;
				flush();
				break;
			default:
				throw new Error(badFormat());

			}
		},
		D: function() {
			switch (fmtChar) {
			case 'D':
				result += _fmtInt(val.day, repeat, true);
				break;
			case 'M':
				if (repeat <= 2) {
					result += _fmtInt(val.month, repeat, true);
				} else if (repeat === 3) {
					result += _months3[val.month - 1] || (fillChar + fillChar + fillChar);
				} else {
					result += _monthName(val.month, repeat);
				}
				break;
			case 'Y':
				result += _fmtInt(repeat <= 2 ? val.year % 100 : val.year, repeat, val.year === 0);
				break;
			case 'h':
				result += _fmtInt((now = now || datetime.now()).hour, repeat);
				break;
			case 'm':
				result += _fmtInt((now = now || datetime.now()).minute, repeat);
				break;
			case 's':
				result += _fmtInt((now = now || datetime.now()).second, repeat);
				break;
			default:
				throw new Error("badChar format character: " + fmtChar);
			}
		},
		L: function() {
			result += "?";
		}
	}

	try {
		var typeChar = fmt[0];
		// default trim option
		if (typeChar === 'K') options.v = 1;
		else if (typeChar == 'N') options.v = 2;

		var fn = formatters[typeChar];
		if (fn) {
			for (fmtPos = 1; fmtPos < fmt.length && (fmtChar = fmt[fmtPos]) !== ':'; fmtPos++) {
				switch (fmtChar) {
				case 'v':
					// ignore v option when formatting numbers
					if (typeChar !== 'N' && _isDigit(fmt[fmtPos + 1])) options.v = parseInt(fmt[++fmtPos]);
					break;
				default:
					options[fmtChar] = true;
					break;
				}
			}
			fmtPos++;
		} else {
			fn = formatters.K;
		}
		fillChar = options['*'] ? special[5] : (options['0'] ? '0' : ' ');

		if (typeChar === 'N') {
			integ = val.toString();
			integ = integ.replace(/[^\d\.\-\+]/g, ''); // get rid of all invalid chars
			if (options.z && (integ === '0' || integ === '')) return '';
			if (integ === '' || integ === '.') integ = '0';
			// remove leading + that may start value
			if (integ[0] === '+') integ = integ.substring(1);
			// TODO: handle scientific format
			var dot = integ.indexOf('.');
			if (dot >= 0) {
				decim = integ.substring(dot + 1);
				integ = integ.substring(0, dot);
			}
			if (integ[0] === '-' || integ[0] === '+') {
				if (options.D && options['0']) {
					tail = integ[0];
					integ = integ.substring(1);
				}
			} else {
				if (options['-']) {
					if (options.D && options['0']) tail = '+';
					else integ = '+' + integ;
				}
			}
			if (options["3"]) {
				// insert thousand separators
				var n3 = (integ.length - (integ[0] === '_') - 1) / 3;
				for (var k = 0; k < n3; k++) {
					var l = integ.length - 4 * k - 3;
					integ = integ.substring(0, l) + special[2] + integ.substring(l);
					numExtra++;
				}
			}
			partStr = integ;
			badChar = special[4];
		}
		secretChar = options.X && special[5];
		var lastValid = 0;
		while (fmtPos < fmtLen) {
			var beg = fmtPos;
			if ((fmtChar = fmt[fmtPos]) === '[') {
				fmtPos = fmt.indexOf(']', fmtPos + 1);
				if (fmtPos < 0) fmtPos = fmtLen;
				result += fmt.substring(beg + 1, fmtPos);
				fmtPos++;
				continue;
			}
			repeat = 0;
			do {
				while (_isDigit(fmtChar = fmt[fmtPos])) fmtPos++;
				repeat += fmtPos > beg ? parseInt(fmt.substring(beg, fmtPos), 10) : 1;
				while (fmtChar && fmtChar === fmt[fmtPos + 1]) {
					fmtPos++;
					repeat++;
				}
				fmtPos++;
				beg = fmtPos;
			} while (fmtChar === '#' && _isDigit(fmt[fmtPos]))
			fn.call(this);
			if (valid) lastValid = result.length;
		}
		//console.log("result=" + result + ", v=" + options.v + ", valid=" + valid);
		if (tail) result += tail;
		if (!valid) {
			if (settings.strict) return null;
			if (typeChar === 'N') result = result.replace(/./g, badChar);
			//else result = result.substring(0, lastValid);
		}
		var trim = trimFuncs[options.v];
		return trim && settings.vOn !== false ? trim(result) : result;
	} catch (ex) {
		if (settings.strict) return null;
		else throw ex;
	}
}