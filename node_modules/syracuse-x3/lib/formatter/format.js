"use strict";
// Low level formatting functions shared by engine and fusion client
var helpers = require('syracuse-core/lib/helpers');
var date = require('syracuse-core/lib/types/date');
var datetime = require('syracuse-core/lib/types/datetime');
var locale = require("syracuse-core/lib/locale");
var resources = locale.resources(module);

function _isLower(ch) {
	return ch >= 'a' && ch <= 'z';
}

function _isUpper(ch) {
	return ch >= 'A' && ch <= 'Z';
}

function _isDigit(ch) {
	return ch >= '0' && ch <= '9';
}

function _isHexa(ch) {
	return (ch >= 'A' && ch <= 'F') || (ch >= '0' && ch <= '9');
}

var _months3 = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];

function _monthName(month, rep) {
	// for now, get it from JS resource and capitalize (wrong for French!)
	var s = resources().monthNames[month - 1];
	while (s.length < rep)
	s += ' ';
	return s.length > rep ? s.substring(0, len) : s;
}

var SP = ' '.charCodeAt(0);

// VIREBLC engine functions
var trimFuncs = exports.trimFuncs = [function(s) { // left
	var i, len = s.length;
	for (i = 0; i < len && s.charCodeAt(i) === SP; i++);
	return i === 0 ? s : s.substring(i);
}, function(s) { // right
	var i, len = s.length;
	for (i = len - 1; i >= 0 && s.charCodeAt(i) === SP; i--);
	return i === len ? s : s.substring(0, i + 1);
}, function(s) { // both
	var i, j, len = s.length;
	for (i = 0; i < len && s.charCodeAt(i) === SP; i++);
	for (j = len - 1; j >= i && s.charCodeAt(j) === SP; j--);
	return s.substring(i, j + 1);
}, function(s) { // token
	var i, j, len = s.length;
	for (i = 0; i < len && s.charCodeAt(i) === SP; i++);
	for (j = i; j < len && s.charCodeAt(j) !== SP; j++);
	return s.substring(i, j);
}, function(s) { // all
	return s.replace(/ /g, '');
}, function(s) { // adjacent
	return s.replace(/[ ]+/g, ' ');
}];

// FORMAT$ engine function
exports.format = function(settings, fmt, val) {
	console.log("val=" + val);
	// engine passes settings directly as ADXSCA array.
	// use this format internally for max engine efficiency.
	var special = settings.ADXSCA || ['?', '?', settings.thousandChar || '', settings.decimalChar || '.', settings.badChar || '#', settings.fillChar || '*'];
	var options = {},
		i = 0,
		ch, rep;
	var valid = true,
		bad = ' ';
	var len = fmt.length,
		j = 0,
		result = "",
		pwc, now, integ, decim = "",
		tail = "",
		cur, n3 = 0,
		replaceBad = false;

	function badFormat() {
		return "Unexpected format character [" + ch + "] - Position[" + (j - 1) + "] - Format='" + fmt + "'";
	}

	function _fmtInt(val, rep) {
		var s;
		if (val == 0 && options.Z) {
			s = '';
			while (rep-- > 0) s += ' ';
			return s;
		}
		s = val.toString();
		while (s.length < rep)
		s = "0" + s;
		return s;
	}


	var formatters = {
		K: function() {
			for (; rep > 0; rep--) {
				var vch = val[j++];
				var defined = vch != null;
				vch = vch || ' ';
				switch (ch) {
				case 'X':
					break;
				case 'A':
					if (!_isUpper(vch)) {
						if (_isLower(vch) && !options.A) vch = vch.toUpperCase();
						else valid = false;
					}
					break;
				case 'a':
					if (!_isLower(vch)) {
						if (_isUpper(vch) && !options.A) vch = vch.toLowerCase();
						else valid = false;
					}
					break;
				case 'B':
					if (!_isUpper(vch) && !_isDigit(vch)) {
						if (_isLower(vch) && !options.A) vch = vch.toUpperCase();
						else valid = false;
					}
					break;
				case 'b':
					if (!_isLower(vch) && !_isDigit(vch)) {
						if (_isUpper(vch) && !options.A) vch = vch.toLowerCase();
						else valid = false;
					}
					break;
				case 'C':
					if (!_isLower(vch) && !_isUpper(vch) && !_isDigit(vch)) {
						valid = false;
					}
					break;
				case 'L':
					if (!_isLower(vch) && !_isUpper(vch)) {
						valid = false;
					}
					break;
				case 'H':
					if (!_isHexa(vch)) {
						valid = false;
					}
					break;
				case ' ':
					if (ch !== ' ') {
						valid = false;
					}
					break;
				case '#':
					if (!_isDigit(vch)) {
						valid = false;
					}
					break;
				default:
					throw new Error(badFormat());
				}
				if (pwc && defined) vch = pwc;
				result += vch;
			}
		},
		N: function() {
			replaceBad = true;
/*
			if (i > 0 && cur && ch != '#' && ch !== 'F') {
				ch = '#';
				i--; // backtrack
			}*/
			function flush() {
				if (!cur) return;
				if (cur.length < rep) {
					var fill = options['*'] ? special[5] : options['0'] ? '0' : ' ';
					if (fill === '0' && cur[0] === '-') {
						result += '-';
						cur = cur.substring(1);
						rep--;
					}
					while (cur.length < rep--) result += fill;
					result += cur;
				} else if (cur.length === rep) {
					result += cur;
				} else {
					result += cur.substring(0, rep);
					valid = false;
				}
				cur = null;
			}
			switch (ch) {
			case undefined: // directive missing after rep count
			case '#':
				if (cur === integ) {
					// allow thousand seps can overflow (weird!)
					rep += n3;
					integ = null;
					flush();
				} else if (cur === decim) {
					if (cur.length < rep) {
						// X3 engine does not follow spec: Z option is now set by default
						var fill = '0'; //options['Z'] ? '0' : ' ';
						result += cur;
						while (cur.length < rep--)
						result += fill;

					} else {
						result += cur.substring(0, rep);
					}
					cur = null;
				} else {
					throw new Error("too many # directives in format");
				}
				break;
			case '.':
				flush();
				result += special[3]
				cur = decim;
				break;
			case 'F':
				// TODO: check this (it makes FDB tests happy)
				cur = integ;
				if (cur.length <= rep) {
					if (decim) {
						rep++; // allow decimal char
						cur = (cur + special[3] + decim).substring(0, rep);
					}
				}
				integ = null;
				decim = null;
				flush();
				break;
			default:
				throw new Error(badFormat());

			}
		},
		D: function() {
			switch (ch) {
			case 'D':
				result += _fmtInt(val.day, rep);
				break;
			case 'M':
				if (rep <= 2) {
					result += _fmtInt(val.month, rep);
				} else if (rep === 3) {
					result += _months3[val.month - 1];
				} else {
					result += _monthName(val.month, rep);
				}
				break;
			case 'Y':
				result += _fmtInt(rep <= 2 ? val.year % 100 : val.year, rep);
				break;
			case 'h':
				result += _fmtInt((now = now || datetime.now()).hour, rep);
				break;
			case 'm':
				result += _fmtInt((now = now || datetime.now()).minute, rep);
				break;
			case 's':
				result += _fmtInt((now = now || datetime.now()).second, rep);
				break;
			default:
				throw new Error("bad format character: " + ch);
			}
		},
		L: function() {
			result += "?";
		}
	}

	try {
		var tch = fmt[0];
		// default trim option
		if (tch === 'K') options.v = 1;
		else if (tch == 'N') options.v = 2;

		var fn = formatters[tch];
		if (fn) {
			for (i = 1; i < fmt.length && (ch = fmt[i]) !== ':'; i++) {
				switch (ch) {
				case 'v':
					if (_isDigit(fmt[i + 1])) options.v = parseInt(fmt[++i]);
					break;
				default:
					options[ch] = true;
					break;
				}
			}
			i++;
		} else {
			fn = formatters.K;
		}
		if (tch === 'N') {
			integ = val.toString();
			// TODO: handle scientific format
			var dot = integ.indexOf('.');
			if (dot >= 0) {
				decim = integ.substring(dot + 1);
				integ = integ.substring(0, dot);
			}
			if (integ[0] === '-' || integ[0] === '+') {
				if (options.D) {
					tail = integ[0];
					integ = integ.substring(1);
				}
			} else {
				if (options['-']) {
					if (options.D) tail = '+';
					else integ = '+' + integ;
				}
			}
			if (options["3"]) {
				// insert thousand separators
				n3 = (integ.length - (integ[0] === '_') - 1) / 3;
				for (var k = 0; k < n3; k++) {
					var l = integ.length - 4 * k - 3;
					integ = integ.substring(0, l) + special[2] + integ.substring(l);
				}
			}
			cur = integ;
			bad = special[4];
		}
		pwc = options.X && special[5];
		var lastValid = 0;
		while (i < len) {
			var beg = i,
				ch;
			if ((ch = fmt[i]) === '[') {
				i = fmt.indexOf(']', i + 1);
				if (i < 0) i = len;
				result += fmt.substring(beg + 1, i);
				i++;
				continue;
			}
			while ((ch = fmt[i]) >= '0' && ch <= '9')
			i++;
			rep = i > beg ? parseInt(fmt.substring(beg, i), 10) : 1;
			while (ch && ch === fmt[i + 1]) {
				i++;
				rep++;
			}
			i++;
			fn.call(this);
			if (valid) lastValid = result.length;
		}
		//console.log("result=" + result + ", v=" + options.v + ", valid=" + valid);
		if (tail) result += tail;
		if (!valid) {
			if (settings.strict) return null;
			if (replaceBad) result = result.replace(/./g, bad);
			//else result = result.substring(0, lastValid);
		}
		var trim = trimFuncs[options.v];
		return trim ? trim(result) : result;
	} catch (ex) {
		if (settings.strict) return null;
		else throw ex;
	}
}