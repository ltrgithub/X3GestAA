"use strict";
// Low level formatting functions shared by engine and fusion client
var helpers = require('syracuse-core/lib/helpers');
var date = require('syracuse-core/lib/types/date');
var datetime = require('syracuse-core/lib/types/datetime');
var locale = require("syracuse-core/lib/locale");
var resources = locale.resources(module);

function _isLower(ch) {
	return ch >= 'a' && ch <= 'z';
}

function _isUpper(ch) {
	return ch >= 'A' && ch <= 'Z';
}

function _isDigit(ch) {
	return ch >= '0' && ch <= '9';
}

function _isHexa(ch) {
	return (ch >= 'A' && ch <= 'F') || (ch >= '0' && ch <= '9');
}

var _months3 = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];

function _monthName(month, repeat) {
	// for now, get it from JS resource and capitalize (wrong for French!)
	var s = resources().monthNames[month - 1] || '';
	while (s.length < repeat)
	s += ' ';
	return s.length > repeat ? s.substring(0, repeat) : s;
}

function _findMonth(name, len) {
	var names = resources().monthNames;
	for (var i = 0; i < names; i++) {
		if (names[i].substring(0, len) === name) return i + 1;
	}
	return -1;
}

var ORIGIN = date.make(1599, 12, 31);

var SP = ' '.charCodeAt(0);

// VIREBLC engine functions
var trimFuncs = exports.trimFuncs = [function(s) { // left
	var i, len = s.length;
	for (i = 0; i < len && s.charCodeAt(i) === SP; i++);
	return i === 0 ? s : s.substring(i);
}, function(s) { // right
	var i, len = s.length;
	for (i = len - 1; i >= 0 && s.charCodeAt(i) === SP; i--);
	return i === len ? s : s.substring(0, i + 1);
}, function(s) { // both
	var i, j, len = s.length;
	for (i = 0; i < len && s.charCodeAt(i) === SP; i++);
	for (j = len - 1; j >= i && s.charCodeAt(j) === SP; j--);
	return s.substring(i, j + 1);
}, function(s) { // token
	var i, j, len = s.length;
	for (i = 0; i < len && s.charCodeAt(i) === SP; i++);
	for (j = i; j < len && s.charCodeAt(j) !== SP; j++);
	return s.substring(i, j);
}, function(s) { // all
	return s.replace(/ /g, '');
}, function(s) { // adjacent
	return s.replace(/[ ]+/g, ' ');
}];

// FORMAT$ engine function

function process(settings, fmt, val, parse) {
	// engine passes settings directly as ADXSCA array.
	// use this format internally for max engine efficiency.
	var special = settings.ADXSCA || ['?', '?', settings.thousandChar || '', settings.decimalChar || '.', settings.badChar || '#', settings.fillChar || '*'];
	var options = {},
		fmtPos = 0,
		fmtChar, repeat, badChar = ' ',
		secretChar, fillChar, fmtLen = fmt.length,
		srcPos = 0,
		now, integ = "",
		decim = "",
		partStr, partNum = 0,
		numExtra = 0,
		// number of chars added to integral part
		valid = true,
		result = "",
		tail = "";

	function badFormat() {
		return "Unexpected format character [" + fmtChar + "] - Position[" + (srcPos - 1) + "] - Format='" + fmt + "'";
	}

	function _fmtInt(val, repeat, forbid0) {
		var s;
		if (val == 0 && forbid0 /* && options.Z*/ ) {
			s = '';
			while (repeat-- > 0) s += ' ';
			return s;
		}
		s = val.toString();
		while (s.length < repeat) s = "0" + s;
		return s;
	}

	function _mismatch(got, expected, ignore) {
		valid = false;
		if (parse && !ignore) throw new Error("value does not match format: expected " + expected + ", got " + got + " at index " + srcPos + " in " + val);
	}

	function stringWalker() {
		for (; repeat > 0; repeat--) {
			var valChar = val[srcPos++];
			var defined = valChar != null;
			valChar = valChar || ' ';
			switch (fmtChar) {
			case 'X':
				break;
			case 'A':
				if (!_isUpper(valChar)) {
					if (_isLower(valChar) && !options.A) valChar = valChar.toUpperCase();
					else _mismatch(valChar, "uppercase letter", valChar === ' ');
				}
				break;
			case 'a':
				if (!_isLower(valChar)) {
					if (_isUpper(valChar) && !options.A) valChar = valChar.toLowerCase();
					else _mismatch(valChar, "lowercase letter", valChar === ' ');
				}
				break;
			case 'B':
				if (!_isUpper(valChar) && !_isDigit(valChar)) {
					if (_isLower(valChar) && !options.A) valChar = valChar.toUpperCase();
					else _mismatch(valChar, "uppercase letter or digit", valChar === ' ');
				}
				break;
			case 'b':
				if (!_isLower(valChar) && !_isDigit(valChar)) {
					if (_isUpper(valChar) && !options.A) valChar = valChar.toLowerCase();
					else _mismatch(valChar, "lowercase letter or digit", valChar === ' ');
				}
				break;
			case 'C':
				if (!_isLower(valChar) && !_isUpper(valChar) && !_isDigit(valChar)) {
					_mismatch(valChar, "letter or digit", valChar === ' ');
				}
				break;
			case 'L':
				if (!_isLower(valChar) && !_isUpper(valChar)) {
					_mismatch(valChar, "lowercase letter", valChar === ' ');
				}
				break;
			case 'H':
				if (!_isHexa(valChar)) {
					_mismatch(valChar, "hexadecimal character", valChar === ' ');
				}
				break;
			case ' ':
				if (fmtChar !== ' ') {
					_mismatch(valChar, "space", valChar === ' ');
				}
				break;
			case '#':
				if (!_isDigit(valChar)) {
					_mismatch(valChar, "digit", valChar === ' ');
				}
				break;
			case '>':
				srcPos--;
				return; // ignore it
			default:
				// we get lower case letter in unit tests - accept them silently
				if (!/[c-z]/.test(fmtChar)) throw new Error(badFormat());
			}
			if (secretChar && defined) valChar = secretChar;
			result += valChar;
		}
	}

	function numberFormatter() {
		function flush() {
			if (!partStr) return;
			if (partStr.length < repeat + numExtra) {
				if (fillChar === '0' && partStr[0] === '-') {
					result += '-';
					partStr = partStr.substring(1);
					repeat--;
				}
				while (partStr.length < repeat--) result += fillChar;
				result += partStr;
			} else if (partStr.length === repeat + numExtra) {
				result += partStr;
			} else {
				result += partStr.substring(0, repeat);
				if (partNum === 0) valid = false;
			}
			numExtra = 0;
			partStr = null;
		}
		switch (fmtChar) {
		case undefined:
			// directive missing after repeat count
		case '#':
			if (partNum === 0) {
				flush();
			} else {
				if (partStr.length < repeat) {
					// X3 engine does not follow spec: Z option is now set by default
					result += partStr;
					while (partStr.length < repeat--) result += '0';
					partStr = '';
				} else {
					result += partStr.substring(0, repeat);
					partStr = partStr.substring(repeat);
				}
			}
			partNum++;
			break;
		case '.':
			if (partNum > 1) throw new Error("too many . directives in format");
			flush();
			result += special[3]
			partStr = decim;
			partNum = 1;
			break;
		case 'F':
			// TODO: check this (it makes FDB tests happy)
			partStr = integ;
			if (partStr.length <= repeat) {
				if (decim) {
					repeat++; // allow decimal char
					partStr = (partStr + special[3] + decim).substring(0, repeat);
				}
			}
			integ = null;
			decim = null;
			flush();
			break;
		default:
			throw new Error(badFormat());

		}
	}

	function numberParser() {
		var ch;
		if (result === '') {
			while ((ch = val[srcPos]) && ch === fillChar && options['*']) srcPos++; 
			if (ch === '-' && result === '') {
				result += ch;
				srcPos++;
			} else if (ch === '+' && options['-']) {
				srcPos++;
			}
		}
		while (ch = val[srcPos]) {
			if (_isDigit(ch)) result += ch;
			else if (!(ch === special[2] && options["3"])) break;
			srcPos++;
		}
		if (ch === special[3] && (fmtChar === '.' || fmtChar === 'F')) {
			result += '.'
			srcPos++;
			while ((ch = val[srcPos]) && _isDigit(ch)) {
				result += ch;
				srcPos++;
			}
		}
	}

	function dateFormatter() {
		switch (fmtChar) {
		case 'D':
			result += _fmtInt(val.day, repeat, true);
			break;
		case 'M':
			if (repeat <= 2) {
				result += _fmtInt(val.month, repeat, true);
			} else if (repeat === 3) {
				result += _months3[val.month - 1] || (fillChar + fillChar + fillChar);
			} else {
				result += _monthName(val.month, repeat);
			}
			break;
		case 'Y':
			result += _fmtInt(repeat <= 2 ? val.year % 100 : val.year, repeat, val.year === 0);
			break;
		case 'h':
			result += _fmtInt((now = now || datetime.now()).hour, repeat);
			break;
		case 'm':
			result += _fmtInt((now = now || datetime.now()).minute, repeat);
			break;
		case 's':
			result += _fmtInt((now = now || datetime.now()).second, repeat);
			break;
		default:
			throw new Error("badChar format character: '" + fmtChar + "'");
		}
	}

	function _parseInt(expected) {
		var beg = srcPos;
		while (repeat && _isDigit(val[srcPos])) srcPos++, repeat--;
		if (srcPos === beg) {
			if (options.Z) { // second chance
				while (repeat && val[srcPos] === ' ') srcPos++, repeat--;
				return 0;
			}
			_mismatch(val[srcPos], expected);
		}
		return parseInt(val.substring(beg, srcPos), 10);
	}

	function dateParser() {
		result = result || {};
		switch (fmtChar) {
		case 'D':
			result.day = _parseInt("day of month (1-31)");
			break;
		case 'M':
			if (repeat <= 2) {
				result.month = _parseInt("month number (1-12)")
			} else if (repeat === 3) {
				var m = val.substring(srcPos, srcPos + 3).toUpperCase();
				srcPos += 3;
				result.month = _months3.indexOf(m) + 1;
				if (result.month <= 0) {
					if (options.Z && m === '   ') result.month = 0;
					else _mismatch(m, "3-letter month name");
				}
			} else {
				var m = val.substring(srcPos, srcPos + repeat).replace(/ *$/, '');
				srcPos += repeat;
				result.month += _findMonth(m);
				if (result.month <= 0) {
					if (options.Z && /^ *$/.test(m)) result.month = 0;
					else _mismatch(m, "month name");
				}
			}
			break;
		case 'Y':
			if (repeat <= 2) {
				var wasEmpty = val[srcPos] === ' ';
				var y = _parseInt("year");
				var century = Math.floor(new Date().getFullYear() / 100) * 100;
				result.year = wasEmpty ? y : y < settings.datePivot ? century + y : century + y - 100;
			} else {
				result.year = _parseInt("year");
			}
			break;
		case 'h':
			result.hour = _parseInt("hour");
			break;
		case 'm':
			result.minute = _parseInt("minute");
			break;
		case 's':
			result.second = _parseInt("second");
			break;
		default:
			throw new Error("badChar format character: " + fmtChar);
		}
	}

	function unknownWalker() {
		result += "?";
	}

	try {
		var typeChar = fmt[0];
		// default trim option
		if (typeChar === 'K') options.v = 1;
		else if (typeChar == 'N') options.v = 2;

		var walkers = parse ? {
			K: stringWalker,
			N: numberParser,
			D: dateParser,
			L: unknownWalker
		} : {
			K: stringWalker,
			N: numberFormatter,
			D: dateFormatter,
			L: unknownWalker
		};

		var walker = walkers[typeChar];
		if (walker) {
			for (fmtPos = 1; fmtPos < fmt.length && (fmtChar = fmt[fmtPos]) !== ':'; fmtPos++) {
				switch (fmtChar) {
				case 'v':
					// ignore v option when formatting numbers
					if (typeChar !== 'N' && _isDigit(fmt[fmtPos + 1])) options.v = parseInt(fmt[++fmtPos], 10);
					break;
				default:
					options[fmtChar] = true;
					break;
				}
			}
			fmtPos++;
		} else {
			walker = walkers.K;
		}
		fillChar = options['*'] ? special[5] : (options['0'] ? '0' : ' ');

		if (typeChar === 'N' && !parse) {
			integ = val.toString();
			integ = integ.replace(/[^\d\.\-\+]/g, ''); // get rid of all invalid chars
			if (options.z && (integ === '0' || integ === '')) return '';
			if (integ === '' || integ === '.') integ = '0';
			// remove leading + that may start value
			if (integ[0] === '+') integ = integ.substring(1);
			// TODO: handle scientific format
			var dot = integ.indexOf('.');
			if (dot >= 0) {
				decim = integ.substring(dot + 1);
				integ = integ.substring(0, dot);
			}
			if (integ[0] === '-' || integ[0] === '+') {
				if (options.D && options['0']) {
					tail = integ[0];
					integ = integ.substring(1);
				}
			} else {
				if (options['-']) {
					if (options.D && options['0']) tail = '+';
					else integ = '+' + integ;
				}
			}
			if (options["3"]) {
				// insert thousand separators
				var n3 = (integ.length - (integ[0] === '_') - 1) / 3;
				for (var k = 0; k < n3; k++) {
					var l = integ.length - 4 * k - 3;
					integ = integ.substring(0, l) + special[2] + integ.substring(l);
					numExtra++;
				}
			}
			partStr = integ;
			badChar = special[4];
		}
		secretChar = options.X && special[5];
		var lastValid = 0;

		while (fmtPos < fmtLen) {
			var beg = fmtPos;
			if ((fmtChar = fmt[fmtPos]) === '[') {
				fmtPos = fmt.indexOf(']', fmtPos + 1);
				var lit = fmt.substring(beg + 1, fmtPos);
				if (fmtPos < 0) fmtPos = fmtLen;
				if (parse) {
					var got = val.substring(srcPos, srcPos + lit.length);
					if (got !== lit) {
						// don't signal mismatch at end
						// also ignore mismatch because of silly [ ] at begining of format
						if (got != '' && !(result === '' && /^ *$/.test(lit))) _mismatch(got, lit);
						// don't increment srcPos
					} else {
						srcPos += lit.length;
					}
				} else {
					result += lit;
				}
				fmtPos++;
				continue;
			}
			repeat = 0;
			do {
				while (_isDigit(fmtChar = fmt[fmtPos])) fmtPos++;
				repeat += fmtPos > beg ? parseInt(fmt.substring(beg, fmtPos), 10) : 1;
				while (fmtChar && fmtChar === fmt[fmtPos + 1]) {
					fmtPos++;
					repeat++;
				}
				fmtPos++;
				beg = fmtPos;
			} while (fmtChar === '#' && _isDigit(fmt[fmtPos]))
			walker.call(this);
			if (valid) lastValid = result.length;
		}
		//console.log("result=" + result + ", v=" + options.v + ", valid=" + valid);
		if (parse) {
			if (fmt[0] === 'D') {
				if (result.hour !== undefined || result.minute !== undefined || result.second !== undefined) {
					return datetime.make(result.year || new Date().getFullYear(), result.month || 1, result.day || 1, //
					result.hour || 0, result.minute || 0, result.second || 0);
				} else {
					if (result.year === 1599 && result.month === 12 && result.day === 31) return ORIGIN;
					if (!result.year && !result.month && !result.day) return ORIGIN;
					else return date.make(result.year || new Date().getFullYear(), result.month || 1, result.day || 1);
				}
			} else if (fmt[0] === 'N') {
				return result;
			} else {
				return result;
			}
		} else {
			if (tail) result += tail;
			if (!valid) {
				if (settings.strict) return null;
				if (typeChar === 'N') result = result.replace(/./g, badChar);
				//else result = result.substring(0, lastValid);
			}
			var trim = trimFuncs[options.v];
			return trim && settings.vOn !== false ? trim(result) : result;
		}
	} catch (ex) {
		if (settings.strict) return null;
		else throw ex;
	}
}

exports.format = function(settings, fmt, val) {
	return process(settings, fmt, val, false);
}

exports.parse = function(settings, fmt, val) {
	return process(settings, fmt, val, true);
}