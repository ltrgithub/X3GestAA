"use strict";

require('buffer').INSPECT_MAX_BYTES = 2048;
Buffer.prototype.toJSON = function() {
	return this.toString('hex');
}

var Request = require('./x3ProtocolRequest').Request;

// !: error
// F: call function
// B: read byte
// S: read short
// L: read long
// U: read UTF8
// I: read ist (long + short)
// A: short + buf
// V: value
// X: special var array of ints
// D: defs
// l: write long
// digit: repeat N times
var DESCS = [
	[0, "ND_RCN", null],
	[1, "ND_GFD", "[UF[U"],
	[2, "ND_SLF", "[UF[U"],
	[14, "NDEXT", null],
	[17, "ND_CMVD", null],
	[18, "NDIMPR", null],
	[19, "NDOPEN", null],
	[20, "ND_CLF", "IF"], // I is nxtist (LS)
	[21, "ND_CLT", "BF"],
	[22, "ND_INP", null],
	[23, "ND_CRD", "F2l"],
	[25, "NDCSTL", "IUF"],
	[26, "NDCHCR", "BF"],
	[27, "NDCHTIT", "!"],
	[28, "NDACTOBJ", "IBFB"],
	[31, "NDCOPMENU", "AF"],
	[32, "NDOUVIMP", "BBUUUUFs"],
	[33, "ND_IMF", "BF"],
	[38, "ND_INT", "Fb"],
	[42, "ND_ASKUI", "!"],
	[43, "NDSYSTEM", "F2a"],
	[45, "NDAFRE", "UF"],

	[49, "NDACV", "LSSUBBF"],

	[56, "NDDEB", ""], // read function was null
	[57, "NDOFENB", "SSSSBSF"],
	[58, "NDOFENH", "UF"],
	[59, "NDOFENA", "SSSSBSF"],
	[60, "NDOFENP", "SSSSBSF"],
	[61, "NDOBOXE", "BBUUBF"],
	[62, "NDOBOXW", "BBUUBF"],
	[63, "NDOBOXQ", "BBUUBF"],
	[64, "NDOBOXS", "SSSSBSF"],
	[65, "NDOBOXI", "BBUUBF"],
	[66, "NDOBOUT", "LUSSUUF"],
	[67, "NDOMNBO", "LSLBSUSF"],
	[68, "NDOMENC", "LF"],
	[69, "NDOMENB", "LF"],
	[70, "NDOMENA", "UF"],

	[73, "NDOTXSC", "IBSUUSF"],

	[80, "NDCREUX", "LSSCCUF"],

	[84, "NDODIAG", "SSSSBSF"], /*  Ouverture Dialogue	*/
	[85, "NDODGSB", "SSSSBSF"], /*  Ouv. Dialogue ss Bt	*/
	[87, "NDOWIN", "IUUUEF"], /*  Ouverture Fenetre	*/

	[90, "ND_IMG", "UVF"], /*  Affichage Image	*/
	[91, "ND_RAT", "LLSSF2c"], /*  Rattachement	*/

	[94, "ND_EVT", "UCSF"], /*  Evenement/Instance	*/
	[95, "NDOCSX", "LSSBUF"], /*  Ouv. Case a Cocher	*/
	[96, "NDOGRD", "LSSBBF"], /*  Ouv. Groupe Radio	*/
	[97, "NDOBRD", "LBUF"], /*  Ouv. Bouton Radio	*/
	[98, "NDOTBL", "LSS5BBBBUF"], /*  Ouv. Tableau	*/
	[99, "NDOCTB", "LLBSBUF"], /*  Ouv. Colonne Tbl.	*/
	[100, "NDOCMB", "LSSBSF"], /*  Ouverture Combo	*/
	[101, "NDOFRM", "LSSBF"], /*  Ouverture Frame	*/
	[105, "NDOBOG", "LSSBF"], /*  Ouv. Boite a Onglets*/
	[106, "NDOONG", "LUUF"], /*  Ouv. Onglets	*/
	[107, "NDTBLK", "UUF"], /*  Titre des Blocs	*/
	[108, "NDOBPG", "LSSBF"], /*  Barre Progression	*/
	[109, "NDOIMG", "LSSBF"], /*  Cadre Image		*/
	[110, "NDFIMG", "BLBUF"], /*  Image de Fond	*/
	[111, "NDIHLP", "UUF"], /*  Aide d'un Objet	*/
	[112, "NDITTP", "UUF"], /*  ToolTip d'un Objet	*/
	[113, "NDCHVB", "IF"], /*  Modif Valeur Bin	*/
	[114, "NDCHVL", "IVF"], /*  Modif. Val. Zone	*/
	[115, "NDGIST", "IF"], /*  Allez a Une Zone	*/
	[116, "NDMIST", "IF"], /*  Allez au Menu Zone	*/
	[118, "NDSUPLI", "ISSF"], /*  Suppression Lignes	*/
	[119, "NDINSLI", "ISSF"], /*  Insertion Lignes	*/
	[120, "NDSATAN", "IF"], /*  Saisie Bas de Page	*/
	[121, "NDOLST", "LSSBF"], /*  Ouverture Liste	*/
	[122, "NDOCLS", "IBAF"], /*  Creation Col. Liste	*/
	[123, "NDOLLS", "ILLAF"], /*  Creat. Ligne Liste	*/

	[125, "NDACTOP", "LBF"], /*  Activation Option	*/
	[126, "NDOJLB", "LBUF"], /*  Creat Jeu Libelle	*/
	[127, "NDAJLB", "LBUF"], /*  Alim Jeu Libelles	*/
	[128, "NDCHFM", "IUF"], /*  Format d'une Zone	*/
	[132, "NDOMNAO", "LSLBSUSF"], /*  Option Menu Appli	*/
	[133, "NDGLLS", "IAF"], /*  Allez a Lg Liste	*/
	[134, "NDOPFN", "LSSBF"], /*  Creat. Part. Fen.	*/
	[136, "NDDTOB", "LBF"], /*  Destruction d'Objet	*/
	[137, "NDCTSU", "BUUF"], /*  Creation Type Prg	*/
	[138, "ND_DCL", "IF"], /*  Debut Chgt Liste	*/
	[139, "ND_FCL", "IF"], /*  Fin Chrgt Liste	*/
	[140, "ND_ICL", "IFB"], /*  Inter Chgt Liste	*/
	[141, "NDOMNCO", "BSUSUF"], /*  Option Menu Surg.	*/
	[142, "NDAFTB", "IBSF"], /*  Disable un Tableau	*/
	[143, "NDCHGR", "BF"], /*  Actzo/Grizo/Diszo	*/
	[144, "NDRZLS", "IF"], /*  Effacement Liste	*/

	[147, "NDINED", "BUF"], /*  Saisie Editeur	*/
	[149, "NDOARB", "LSSBF"], /*  Ouverture Arbre	*/
	[150, "NDOCAR", "IBDF"], /*  Creation Col. Arbre	*/
	[151, "NDOLAR", "ISBUDDDF"], /*  Creat. Ligne Arbre	*/
	[152, "ND_NAP", "UF"], /*  Nouvelle Session	*/
	[153, "NDGLAR", "IAF"], /*  Allez a Lg Arbre	*/
	[154, "NDRZAR", "IF"], /*  Effacement Arbre	*/
	[155, "ND_DCA", "UF"], /*  Debut Chgt Arbre	*/
	[156, "ND_FCA", "UF"], /*  Fin Chrgt Arbre	*/
	[157, "ND_REB", "17UF"], /*  Reboot Serveur	*/
	[158, "NDOMSG", "BBFs"], /*  Ouvre Messagerie	*/
	[159, "NDEDBK", "XFxx"], /*  Editeur de Blocs	*/
	[160, "NDULLS", "IAF"], /*  Desel Ligne Liste	*/
	[161, "NDULAR", "IAF"], /*  Desel Ligne Arbre	*/
	[162, "NDPKLS", "IF"], /*  Picking		*/
	[163, "NDPKAR", "IF"], /*  Picking Hierarchise	*/
	[164, "NDGTDT", "F"], /*  Destinataires	*/
	[165, "NDGTIM", "F"], /*  Imprimantes		*/
	[166, "NDCHLP", "ISSUF"], /*  Aide d'un Objet	*/
	[167, "NDCTTP", "ISSUF"], /*  ToolTip d'un Objet	*/
	[168, "NDCTIT", "IUF"], /*  Titre d'un Objet	*/
	[169, "ND_OCX", "F"], /*  Interface avec OCX	*/
	[170, "NDOFML", "UF"], /*  Ouverture Formule	*/
	[171, "NDOFLD", "IUUUSUUF"], /*  Ouverture Champs	*/
	[172, "NDDSLB", "BF"], /*  Desactiv Libelle	*/
	[173, "ND_IHM", "F"], /*  Interface avec IHM	*/
	[174, "NDDTLB", "!"], /*  Desactiv Libelle	*/
	[175, "ND_LIM", "F"], /*  Interface avec LIM	*/
	[176, "NDRESUL", "ISSUBSF"], ];

var NODES = [];
var MAP = {}

DESCS.forEach(function(node) {
	var pat = node[2] || "";
	var params = pat.split('F')[0];
	var acks = pat.split('F')[1] || "";
	var lists = params.split('[')[1] || "";
	params = params.split('[')[0];
	var n = {
		id: node[0],
		name: node[1],
		params: params,
		lists: lists,
		acks: acks,
		def: 0,
		skipHandler: (node[2] == null),
	};
	NODES[node[0]] = n;
	MAP[node[1]] = n;
})

NODES.forEach(function(node) {
	node.def = NODES[0];
})
MAP.ND_CLT.def = null;
MAP.NDOWIN.def = null;
MAP.ND_REB.def = null;

function resolve(v) {
	if (v === 0) return;
	else if (!MAP[v]) throw new Error("bad key: " + v);
	return MAP[v];
}

MAP.ND_RCN.transitions = [ //
"ND_RCN", 0, 0, 0, 0, 0, 0, 0, //
0, 0, 0, 0, 0, 0, "NDEXT", 0, //
0, "ND_CMVD", "NDIMPR", "ND_INP" //
].map(resolve);

MAP.NDEXT.transitions = [ //
0, "NDOPEN", "ND_RAT", "ND_EVT", "NDTBLK", 0, 0, 0, //
0, 0, "NDSUPLI", "NDINSLI", "NDSATAN", 0, 0, 0, //
0, 0, 0, 0, "ND_CLF", "ND_CLT", "NDDTOB", 0, //
0, "ND_REB", "ND_NAP", 0, 0, 0, "NDGIST", "NDCHGR", //
"NDMIST", 0, "NDCTSU", 0, "ND_DCL", "ND_FCL", "NDAFTB", "NDRZLS", //
"NDGLLS", "NDULLS", 0, 0, 0, "NDRZAR", "NDGLAR", "ND_DCA", //
"ND_FCA", "NDULAR", "NDCHTIT", "NDCTIT", "NDCSTL", 0, 0, 0, //
0, 0, 0, 0, "NDACTOBJ", 0, 0, "NDFIMG", //
"NDACTOP", 0, "NDAJLB", "NDCHFM", "NDDSLB", 0, 0, "NDCOPMENU", //
"NDIHLP", "NDITTP", "NDCHLP", "NDCTTP" //
].map(resolve);

MAP.ND_CMVD.transitions = [ //
0, 0, 0, 0, 0, "ND_INT", 0, 0, //
0, 0, "NDSYSTEM", 0, 0, 0, 0, 0, //
"ND_ICL", "ND_CRD", "NDINED", "NDEDBK", 0, "NDAFRE", 0, "NDPKLS", "NDPKAR", //
0, 0, 0, 0, 0, 0, 0, 0, //
0, 0, 0, 0, 0, 0, 0, 0, //
0, 0, 0, 0, 0, 0, 0, 0, //
0, 0, 0, 0, 0, 0, 0, 0, //
0, 0, 0, 0, 0, 0, 0, 0, //
0, 0, "NDCHCR", 0, 0, "NDCHVL", "NDCHVB" //
].map(resolve);

MAP.NDOPEN.transitions = [ //
0, "NDDEB", "NDOFENB", "NDOFENH", "NDOFENA", "NDOFENP", "NDODIAG", "NDODGSB", //
"NDOBOXI", 0, "NDOBOXE", "NDOBOXW", "NDOBOXQ", "NDOBOXS", "NDOBOXI", 0, //
0, 0, 0, 0, "NDOBOUT", "NDOTBL", "NDOCTB", "NDOGRD", //
"NDOBRD", "NDOCMB", "NDOFRM", "NDOBOG", "NDOONG", "NDOCSX", "NDCREUX", "NDOBPG", //
"NDOIMG", "NDOLST", "NDOCLS", "NDOLLS", "NDOJLB", "NDOPFN", 0, "NDOFML", //
"NDOFLD", "NDOARB", "NDOCAR", "NDOLAR", 0, 0, 0, 0, //
0, 0, 0, 0, 0, 0, 0, 0, //
0, 0, 0, 0, 0, 0, 0, 0, //
0, 0, 0, 0, 0, 0, 0, "NDOTXSC", //
0, 0, 0, 0, 0, 0, 0, 0, //
0, "NDACV", 0, 0, 0, 0, 0, "NDOWIN", //
0, 0, 0, 0, 0, 0, "NDOMNCO", "NDOMENC", //
"NDOMNAO", "NDOMNBO", "NDOMENA", "NDOMENB" //
].map(resolve);

MAP.NDIMPR.transitions = [ //
0, "NDOUVIMP", "ND_IMF", 0, 0, "NDOMSG", "NDGTDT", "NDGTIM", //
"ND_OCX", "ND_IHM", "ND_LIM", "ND_GFD", "ND_SLF" //
].map(resolve);

MAP.ND_INP.transitions = [ //
0, "NDRESUL" //
].map(resolve);

function readVal(req, letter) {
	switch (letter) {
	case 'B':
		return req.nextByte();
	case 'S':
		return req.nextShort();
	case 'L':
		return req.nextLong();
	case 'U':
		return req.nextString();
	case 'I':
		return req.nextIst();
	case 'A':
		return req.nextBuf();
	case 'E':
		return req.nextExtend();
	case 'D':
		return req.nextDefs();
	case 'V':
		return req.nextResu();
	default:
		throw new Error("bad arg char: " + letter);

	}
}

function readListVal(req, letter) {
	switch (letter) {
	case 'U':
		return req.nextClob();
	default:
		throw new Error("bad list char: " + letter);

	}
}

function readList(_, ctx, letter) {
	var list = [];
	while (true) {
		var head = ctx.stream.read(_, 5);
		var len = head.readInt32BE(1);
		if (len < 0) throw new Error("bad list len: " + len);
		if (len === 0) return list;
		var req = new Request(ctx, head[0], ctx.stream.read(_, len));
		console.log("YYY=" + letter);
		list.push(readListVal(req, letter))
	}
}

function writeVal(_, ctx, letter, val) {
	var stream = ctx.stream;
	switch (letter) {
	case 'B':
		stream.write(_, new Buffer([val]));
		break;
	default:
		throw new Error("bad ack char: " + letter);
	}
}

function writeVals(_, ctx, letter, vals) {
	var stream = ctx.stream;
	console.log("vals=" + vals);
	for (var i = 0; i < vals.length; i++) {
		var val = vals[i];
		switch (letter) {
		case 'U':
			var buf = new Buffer(5);
			buf[0] = 0;
			buf.writeInt32BE(val.length, 1);
			stream.write(_, buf);
			stream.write(_, new Buffer(val, "utf8"));
			break;
		default:
			throw new Error("bad ack char: " + letter);
		}
	}
	var buf = new Buffer(5);
	buf.fill(0);
	stream.write(_, buf);
}


exports.defaultHandler = function(_) {
	return [0];
}


function processNode(_, ctx, req, node) {
	var handler = ctx.handlers[node.name];
	if (!handler) handler = exports.defaultHandler;
	var args = [req, node];
	var params = node.params;
	for (var i = 0; i < params.length; i++) {
		if ('AUD'.indexOf(params[i]) >= 0) req.ensure(_, ctx, req.peekShort() + 2);
		else if ('E'.indexOf(params[i]) >= 0) req.ensure(_, ctx, req.peekLong() + 4);
		args.push(readVal(req, params[i]))
	}
	var lists = node.lists;
	for (var i = 0; i < lists.length; i++) {
		args.push(readList(_, ctx, lists[i]));
	}
	console.log("NODE HANDLER: " + node.name + JSON.stringify(args.slice(2)));
	var results = handler.apply_(_, null, args, 0);
	console.log("results=" + results);
	var acks = node.acks;
	var ack = 0;
	if (acks.length === 1 && results === undefined) results = [0]; // auto hack
	for (var i = 0; i < acks.length; i++) {
		if (acks[i] === '[') {
			i++;
			writeVals(_, ctx, acks[i], results[ack])
		} else {
			writeVal(_, ctx, acks[i], results[ack]);
		}
		ack++;
	}
}

function processRequest(_, ctx, req, node) { /*  Caractere a Traite  */
	var car = req.nextByte();
	if (car == 0) return node;

	while (node) {
		console.log("node=" + node.name + ", car=0x" + car.toString(16));
		if (node.transitions) {
			var nextNode = node.transitions[car];
			if (nextNode) {
				console.log("transition to " + nextNode.name);
				if (node.finish) node.finish(_, ctx, req, car);
				processNode(_, ctx, req, nextNode);
				node = nextNode;
				car = req.nextByte();
				if (car == 0) return nextNode.def;
				else continue;
			}
		}

		/*  Fausse transition vers le Noeud Defaut  */
		if (node === node.def) throw new Error("infinite loop")
		console.log("transition to default");
		node = node.def;
	}
	return null;
}

function readRequest(_, ctx) {
	var head = ctx.stream.read(_, 3);
	var len = (head[1] >> 8) | head[2];
	console.log("head len=" + len);
	return new Request(ctx, head[0], len ? ctx.stream.read(_, len) : new Buffer(0));
}

// was setting def to -40!!!

function process(_, ctx) {
	var req, node = NODES[0];
	do {
		req = readRequest(_, ctx);
		while (req.peek() > 0 && node) {
			node = processRequest(_, ctx, req, node);
		}
	} while (node);
}

exports.MAP = MAP;
exports.process = process;