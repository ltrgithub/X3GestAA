"use strict";
var helpers = require('syracuse-core/lib/helpers');
var httpClient = require("syracuse-httpclient/lib/httpClient");
var x3helpers = require('syracuse-x3/lib/helpers');
var config = require('syracuse-main/lib/nodeconfig').config;
var localConfig = x3helpers.config("x3fusion", null, {});
var trace = x3helpers.config("cache.trace", localConfig);
var jsxml = require('jsxml');

var nocache = config && config.hosting && config.hosting.nocache;
var globals = require('streamline/lib/globals');

var managers = {};
exports.getCacheManager = function() {
	var id = globals.context.tenantId || 0;
	managers[id] = managers[id] || Â new CvgCacheManager();
	return managers[id];
};

var CvgCacheManager = helpers.defineClass(function() {
	this.cache = {};
}, null, {
	cacheContains: function(url) {
		return this.cache[url] != null;
	},
	getResource: function(_, url, headers, options, recOptions) {
		options = options || {};
		if (this.cache[url]) {
			if (options.force) {
				return this.cache[url].resource;
			}
			if (options.timestamp) {
				trace && trace("Timestamp asked for '" + url + "': " + options.timestamp);
				if (options.timestamp === this.cache[url].timestamp) {
					trace && trace("Resource found in cache");
					return this.cache[url].resource;
				} else {
					trace && trace("Resource not found in cache: " + JSON.stringify(this.getInfos(url), null, 2));
				}
			}
		}
		//var cacheCtrl, maxAge, lastmodified;
		headers = headers || {};
		headers["Accept-Encoding"] = "utf-8";
		headers["Cache-Control"] = "max-age=0, must-revalidate, proxy-revalidate";

		if (this.cache && this.cache[url]) {
			headers["If-None-Match"] = this.cache[url].etag;
			headers["If-Modified-Since"] = this.cache[url].lastModified;
		}

		var opt = {
			method: "GET",
			url: url,
			headers: headers
		};
		trace && trace("HTTP request options: " + JSON.stringify(opt, null, 2));
		trace && trace("--------------");

		var request = httpClient.httpRequest(_, opt);
		var response = request.end().response(_);
		response.setEncoding('utf8');

		var body = response.readAll(_);
		trace && trace("HTTP response for '" + url + "':\nStatus Code:" + response.statusCode + "\nHeaders: " + JSON.stringify(response.headers, null, 2) + (body ? "\nBody : " + body.substr(0, 150) + " [...]" : ""));
		trace && trace("\n---------------------------------------\n");

		trace && trace("---------------------------------------");
		trace && trace("GET (" + response.statusCode + ") " + url);
		trace && trace(" - Headers: " + JSON.stringify(response.headers, null, 2));
		if (body) {
			trace && trace(" - Body : " + body);
		}
		trace && trace("---------------------------------------");
		if (response.statusCode === 200 && body) {
			if (recOptions && recOptions.recMode === "REC") {
				recOptions.recorder.dumpHttpResp(_, body);
			}
			if (options.xmlToJson) {
				trace && trace("Transform XML to JSON");
				body = jsxml.parse(body);
				trace && trace(" - Body transformed : " + JSON.stringify(body, null, 2));
			}
			if (!nocache) {
				this.cache[url] = {
					resource: body,
					etag: response.headers.etag,
					lastModified: response.headers['last-modified']
				};
			}
			return body;
		} else if (response.statusCode === 304) {
			if (recOptions && recOptions.recMode === "REC") {
				recOptions.recorder.dumpHttpResp(_, this.cache[url].resource);
			}
			return this.cache[url].resource;
		} else {
			throw new Error(response.statusCode + ": (url:" + url + ") " + body);
		}
		return body;
	},
	getInfos: function(url) {
		return this.cache && this.cache[url] ? {
			etag: this.cache[url].etag,
			lastModified: this.cache[url].lastModified,
			timestamp: this.cache[url].timestamp
		} : {};
	}
});