"use strict";
var helpers = require('syracuse-core').helpers;
var httpClient = require("syracuse-httpclient/lib/httpClient");
var jsxml = require('js-xml');
var config = require('config');
var tracerCache = require('syracuse-core').getTracer("classic.srvCache");
var nocache = config && config.hosting && config.hosting.nocache;
var perfmon = require('syracuse-perfmon');
var globals = require('streamline-runtime').globals;

var managers = {};
exports.getCacheManager = function() {
	var id = globals.context.tenantId || 0;
	managers[id] = managers[id] || new CvgCacheManager();
	return managers[id];
};

var CvgCacheManager = helpers.defineClass(function() {
	this.cache = {};
}, null, {
	cacheContains: function(url) {
		return this.cache[url] != null;
	},
	getResource: function(_, url, headers, options, recOptions) {
		options = options || {};
		if (this.cache[url]) {
			if (options.force) {
				return this.cache[url].resource;
			}
			if (options.timestamp) {
				tracerCache.info && tracerCache.info("Timestamp asked for '" + url + "': " + options.timestamp);
				if (options.timestamp === this.cache[url].timestamp) {
					tracerCache.info && tracerCache.info("Resource found in cache");
					return this.cache[url].resource;
				} else {
					tracerCache.info && tracerCache.info("Resource not found in cache: " + JSON.stringify(this.getInfos(url), null, 2));
				}
			}
		}
		//var cacheCtrl, maxAge, lastmodified;
		var timing = perfmon.start(module, "CvgCacheManager.getResource", url);

		if (!recOptions || recOptions.recMode === "REC") {
			headers = headers || {};
			headers.accept = "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8";
			headers["accept-encoding"] = "utf-8";
			headers["cache-control"] = "max-age=0, must-revalidate, proxy-revalidate";

			if (this.cache && this.cache[url]) {
				headers["if-none-match"] = this.cache[url].etag;
				headers["if-modified-since"] = this.cache[url].lastModified;
			}

			var opt = {
				method: "GET",
				url: url,
				headers: headers
			};
			if (options.ignoreProxy) opt.ignoreProxy = true;
			tracerCache.debug && tracerCache.debug("--------------");
			tracerCache.debug && tracerCache.debug("HTTP request options: " + JSON.stringify(opt, null, 2));
			tracerCache.debug && tracerCache.debug("--------------");

			var request = httpClient.httpRequest(_, opt);
			var response = request.end().response(_);
			response.setEncoding('utf8');

			var body = response.readAll(_);

			tracerCache.info && tracerCache.info("---------------------------------------");
			tracerCache.info && tracerCache.info("GET (" + response.statusCode + ") " + url);
			tracerCache.debug && tracerCache.debug(" - Headers: " + JSON.stringify(response.headers, null, 2));
			if (body) {
				tracerCache.debug && tracerCache.debug(" - Body : " + body);
			}
			tracerCache.info && tracerCache.info("---------------------------------------");
			timing.end({
				status: response.statusCode
			});
			if (response.statusCode === 200 && body) {
				if (recOptions && recOptions.recMode === "REC") {
					recOptions.recorder.dumpHttpResp(_, body);
				}
				if (options.xmlToJson) {
					tracerCache.info && tracerCache.info("Transform XML to JSON");
					body = jsxml.parse(body);
					tracerCache.debug && tracerCache.debug(" - Body transformed : " + JSON.stringify(body, null, 2));
				}
				if (!nocache) {
					this.cache[url] = {
						resource: body,
						etag: response.headers.etag,
						lastModified: response.headers['last-modified']
					};
				}
				return body;
			} else if (response.statusCode === 304) {
				if (recOptions && recOptions.recMode === "REC") {
					recOptions.recorder.dumpHttpResp(_, this.cache[url].resource);
				}
				return this.cache[url].resource;
			} else {
				var error = new Error(response.statusCode + ": (url:" + url + ") " + body);
				error.STATUS_CODE = response.statusCode; // need extra status code
				throw error;
			}
		} else if (recOptions.player) {
			this.cache[url] = {
				resource: recOptions.player.readHttpResp()
			};
			return this.cache[url].resource;
		}
	},
	getInfos: function(url) {
		return this.cache && this.cache[url] ? {
			etag: this.cache[url].etag,
			lastModified: this.cache[url].lastModified,
			timestamp: this.cache[url].timestamp
		} : {};
	}
});