"use strict";
var helpers = require('syracuse-core/lib/helpers');
var httpClient = require("syracuse-httpclient/lib/httpClient");
var x3helpers = require('syracuse-x3/lib/helpers');
var config = require('syracuse-main/lib/nodeconfig').config;

var tracerCache = require("syracuse-trace/lib/helper").getTracer("classic.srvCache");
var nocache = config && config.hosting && config.hosting.nocache;

exports.CvgCacheManager = helpers.defineClass(function() {
	this.cache = {};
}, null, {
	getResource: function(_, url, headers) {
		var cacheCtrl, maxAge, lastmodified;
		headers = headers || {};
		headers["Accept-Encoding"] = "utf-8";
		headers["Cache-Control"] = "max-age=0, must-revalidate, proxy-revalidate";

		if (this.cache && this.cache[url]) {
			headers["If-None-Match"] = this.cache[url].etag;
			headers["If-Modified-Since"] = this.cache[url].lastModified;
		}

		var opt = {
			method: "GET",
			url: url,
			headers: headers
		};
		tracerCache.info() && tracerCache.info("HTTP request options: " + JSON.stringify(opt, null, 2));
		tracerCache.info() && tracerCache.info("--------------");

		var request = httpClient.httpRequest(_, opt);
		var response = request.end().response(_);
		response.setEncoding('utf8');

		var body = response.readAll(_);
		tracerCache.info() && tracerCache.info("HTTP response for '" + url + "':\nStatus Code:" + response.statusCode + "\nHeaders: " + JSON.stringify(response.headers, null, 2) + (body ? "\nBody : " + body.substr(0, 150) + " [...]" : ""));
		tracerCache.info() && tracerCache.info("\n---------------------------------------\n");
		if (response.statusCode === 200 && body) {
			if (!nocache) {
				this.cache[url] = {
					resource: body,
					etag: response.headers.etag,
					lastModified: response.headers['last-modified']
				};
			}
			return body;
		} else if (response.statusCode === 304) {
			return this.cache[url].resource;
		} else {
			throw new Error(response.statusCode + ": (url:" + url + ") " + body);
		}
	},
	getInfos: function(url) {
		return this.cache && this.cache[url] ? {
			etag: this.cache[url].etag,
			lastModified: this.cache[url].lastModified
		} : {};
	}
});