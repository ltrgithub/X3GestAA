"use strict";
var helpers = require('syracuse-core/lib/helpers');
var httpClient = require("syracuse-httpclient/lib/httpClient");
var config = require('config');
var tracerCache = require('syracuse-core/lib/trace').getTracer("classic.srvCache");
var nocache = config && config.hosting && config.hosting.nocache;
var perfmon = require('syracuse-perfmon');

exports.CvgCacheManager = helpers.defineClass(function() {
	this.cache = {};
}, null, {
	cacheContains: function(url) {
		return this.cache[url] != null;
	},
	getResource: function(_, url, headers, options, recOptions) {
		options = options || {};
		if (options.force) {
			return this.cache[url].resource;
		}
		//var cacheCtrl, maxAge, lastmodified;
		var timing = perfmon.start(module, "CvgCacheManager.getResource", url);

		if (!recOptions || recOptions.recMode === "REC") {
			headers = headers || {};
			headers.accept = "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8";
			headers["accept-encoding"] = "utf-8";
			headers["cache-control"] = "max-age=0, must-revalidate, proxy-revalidate";

			if (this.cache && this.cache[url]) {
				headers["if-none-match"] = this.cache[url].etag;
				headers["if-modified-since"] = this.cache[url].lastModified;
			}

			var opt = {
				method: "GET",
				url: url,
				headers: headers
			};
			if (options.ignoreProxy) opt.ignoreProxy = true;
			tracerCache.debug && tracerCache.debug("--------------");
			tracerCache.debug && tracerCache.debug("HTTP request options: " + JSON.stringify(opt, null, 2));
			tracerCache.debug && tracerCache.debug("--------------");

			var request = httpClient.httpRequest(_, opt);
			var response = request.end().response(_);
			response.setEncoding('utf8');

			var body = response.readAll(_);

			tracerCache.info && tracerCache.info("---------------------------------------");
			tracerCache.info && tracerCache.info("GET (" + response.statusCode + ") " + url);
			tracerCache.debug && tracerCache.debug(" - Headers: " + JSON.stringify(response.headers, null, 2));
			if (body) {
				tracerCache.debug && tracerCache.debug(" - Body : " + body);
			}
			tracerCache.info && tracerCache.info("---------------------------------------");
			timing.end({
				status: response.statusCode
			});
			if (response.statusCode === 200 && body) {
				if (recOptions && recOptions.recMode === "REC") {
					recOptions.recorder.dumpHttpResp(_, body);
				}
				if (!nocache) {
					this.cache[url] = {
						resource: body,
						etag: response.headers.etag,
						lastModified: response.headers['last-modified']
					};
				}
				return body;
			} else if (response.statusCode === 304) {
				if (recOptions && recOptions.recMode === "REC") {
					recOptions.recorder.dumpHttpResp(_, this.cache[url].resource);
				}
				return this.cache[url].resource;
			} else {
				throw new Error(response.statusCode + ": (url:" + url + ") " + body);
			}
		} else if (recOptions.player) {
			this.cache[url] = {
				resource: recOptions.player.readHttpResp()
			};
			return this.cache[url].resource;
		}
	},
	getInfos: function(url) {
		return this.cache && this.cache[url] ? {
			etag: this.cache[url].etag,
			lastModified: this.cache[url].lastModified
		} : {};
	}
});