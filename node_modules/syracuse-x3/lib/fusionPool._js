"use strict";

var locale = require("syracuse-core/lib/locale");
var helpers = require("syracuse-core/lib/helpers");
var jsonSessionFactory = require("./fusionSession");
var httpHelper = require("syracuse-sdata/lib/httpHelper");
var util = require("util");
var streams = require("streamline/lib/streams/streams");

exports.connect = function(_, context, config) {
	//
	var startConnect=new Date().getTime();
	var fsid = helpers.uuid.generate();
	var request = context.request;
	if (!request.session) throw new Error(locale.format(module, "noSession"));
	//
	var session = jsonSessionFactory.getFusionSession(_, fsid);
	var resp=session.connect(_, context, config);
	// FDB - Propagate  X3 bridge headers
	var respHeaders=resp.headers || {};
	respHeaders.location = context.baseUrl +  "/$sessions('" + session.sid + "')";
	// FDB - Add response time in http  headers (dvlp)
	respHeaders["syra-proxy-time"]=new Date().getTime()-startConnect;
	var result = {
		// FDB - return resp.statusCode if exists - Used to propagate Bridge errors to fusion client
		statusCode: resp.statusCode==null ? 201 : resp.statusCode,
		headers: respHeaders,
		body: resp.body
	}
	//
	request.session.updateFusionSession(session);
	return result;
}

exports.proxy = function(_, context, config) {
	// bypass
	var request = context.request;
	if (!request.session) throw new Error(locale.format(module, "noSession"));
	//
	var session = request.session.getFusionSession(context.fusionSessionId);
	if(!session) {
		var error = new Error(locale.format(module, "sessionNotFound", context.fusionSessionId));
		error.statusCode = httpHelper.HttpStatus.NotFound;
		throw error;
	}
	session.proxy(_, context, config);
	request.session.updateFusionSession(session);
}

exports.closeSession = function(_, fsid, sessionUrl, xmlFormat) {
	return jsonSessionFactory.closeSession(_, fsid, sessionUrl);
}

exports.webProxy = function(_, context, webServerPath, config) {
	var baseUrl = context.endpoint.getWebServerBaseUrl(_, false);
	var request = context.request;
	request.setEncoding("binary");
	var params = Object.keys(context.parameters).map(function(key) {return key + "=" + encodeURIComponent(context.parameters[key]); }).join("&");
	var options = {
			url: baseUrl + "/" + webServerPath + (params ? ("?" + params) : ""),
			method: context.method,
			headers: request.headers
		}
	var clientReq = streams.httpRequest(options);
	var buf;
	while(buf = request.read(_)) clientReq.write(_, buf, "binary");
	var response = clientReq.end().response(_);
	response.setEncoding("binary");
	//
	context.response.writeHead(response.statusCode, response.headers);
	while(buf = response.read(_)) context.response.write(_, buf, "binary");
	context.response.end();
}