"use strict";

var locale = require("syracuse-core/lib/locale");
var helpers = require("syracuse-core/lib/helpers");
var datetime = require("syracuse-core/lib/types/datetime");
var streams = require("streamline/lib/streams/streams");
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var x3helpers = require("./helpers");
var parseUrl = require('url').parse;
var x3helpers = require("./helpers");
var util = require("util");
var url = require('url');
var check = require("syracuse-license/lib/check");
var x3client = require('syracuse-x3/lib/client');
var CvgClient = require("syracuse-x3/lib/convergence/client/CvgClient").CvgClient;
var CvgException = require("syracuse-x3/lib/convergence/model/CvgException").CvgException;

var printSrvConfig = nodeconfig.config && nodeconfig.config.x3print && nodeconfig.config.x3print.server;
var traceSessions = nodeconfig.config && nodeconfig.config.x3fusion && nodeconfig.config.x3fusion.sessions && nodeconfig.config.x3fusion.sessions.trace;

var _listReuse = [];

function _startProfile() {
	return (new Date()).getTime();
}

function _endProfile(startTime) {
	return (new Date()).getTime() - startTime;
}

function cvgSession(fsid) {
	traceSessions && traceSessions("New cvgSession - " + fsid);
	this.sessionUrl = "";
	this.isXmlSessionFormat = false;
	this.sid = fsid;
	//Set by session.updateCvgSession
	this.lastAccess=0;
	this.creationDate=datetime.now();
}

function _getRsrc() {
	try {
		var args = [module];
		for (var i in arguments) {
			args.push(arguments[i]);
		}
		return locale.format.apply(locale, args);
	} catch (e) {
		return "Resource not found [" + arguments[0] + "]";
	}
}

function getErrDiagnose(e, client, resourceId) {
	console.error("Error: "+e.stack);
	var error, msg = resourceId ? _getRsrc(resourceId) : e.message;
	if (e instanceof CvgException) {
		error = e;
		error.diagnose.message = msg;
	} else {
		error = new CvgException(client, e, msg);
	}
	
	return error.diagnose;
}

function sendResponse(_, context, statusCode, data) {
	context.response.writeHead(statusCode, {
		"content-type": "application/json",
	});
	context.response.write(_, JSON.stringify(data), 'utf8');
	context.response.end();	
}

//-------------------------------------------------------
// localCtrl à true indique que le client :
//		se charge des contrôles de saisie
//		assure le formatage « edit to display » de la zone courante (donc plus de previous dans le reply qui fait suite)
//		assure le déformatage de la zone courante, donc le fld.v dans le body du poste est déjà au format raw.
//		localFormat à true indique que le client se charge de formater toutes les donnée présentes dans les data sources (donc tout ce qui figure sous sap.wins.CdWin.entities d’un reply)
// localFormat à true indique que le client 
//		se charge de formater toutes les donnée présentes dans les data sources (donc tout ce qui figure sous sap.wins.CdWin.entities d’un reply)
var _cliSettingsDef={ 
		format: {
			localCtrl : false,
			localFormat: false
		}
};
function _readClientSettings(_, context){
	try{
		var body=(context.request.readAll(_) || "").trim();
		if (body.length!=0){
			body=JSON.parse(body);
			if (body.settings){
				for (var p in _cliSettingsDef){
					if(body.settings[p]==null) body.settings[p]=_cliSettingsDef[p]
				}
				return body.settings;
			} 
		}
	}catch(e){}
	return _cliSettingsDef;
}
//-------------------------------------------------------
var sessionProto = cvgSession.prototype;
//

sessionProto.connect = function(_, context, config) {
	traceSessions && traceSessions("Direct Fusion Connect");
	var lic = check.getParsedLicense(_);
	if (lic && !lic.namedUsers)
		throw locale.format(module, "tooManyBadges");
	// client settings allow web client to enbale/disable CvgClient behaviors
	var cliSettings = _readClientSettings(_,context);
	var endpoint = context.endpoint;
	var x3server = endpoint.x3server(_);
	var userProfile = context.httpSession.getUserProfile(_);
	var localePrefs = userProfile && userProfile.selectedLocale(_);
	var remoteAddr=context.request.connection.remoteAddress;
	var referer=context.request.headers["referer"];
	this.sessInfo={
			remoteAddress: remoteAddr && remoteAddr.length>0 ? remoteAddr : "unknown",
		    httpReferer: referer && referer.length>0 ? url.parse(referer).host : "unknown",
			x3Host : x3server.serverHost(_),
			x3Port : x3server.serverPort(_),
			x3Solution : endpoint.x3SolutionName(_),
			x3Folder : endpoint.x3ServerFolder(_),
			x3User : userProfile && userProfile.user(_) && userProfile.user(_).getEndpointLogin(_, endpoint.$uuid),	
			x3Lang : locale.current,
			timeoutReuse: nodeconfig.config && nodeconfig.config.x3fusion && nodeconfig.config.x3fusion.reuseTimeout || 120000,
			x3Function: context.parameters.f.split('/')[0]
	};
	var adxInfo={
			adxHttpPub: endpoint.getApplicationServerBaseUrl(_),
			adxFolder: this.sessInfo.x3Folder,
			adxSolution: this.sessInfo.x3Solution
		}
	var preferences;
	var selLocale = userProfile && userProfile.selectedLocale(_);
	if (selLocale) {
		// FDB - Session Settings required by X3 client - dateOrder (dym-myd-ymd-dm if no year...)/dateSep/decSep/thousandSep
		preferences = x3helpers.dateFormatToX3Prefs(selLocale.shortDate(_));
		var decimalSep = selLocale.numberDecimalSeparator(_);
		var thousandsSep = selLocale.numberGroupSeparator(_);
		var timeSep = x3helpers.getTimeSep(selLocale.shortTime(_));
		if (decimalSep != null) preferences.decimalSep = decimalSep;
		if (thousandsSep != null) preferences.thousandsSep = thousandsSep;
		if (timeSep != null) preferences.timeSep = timeSep;
	}
	var config = {
		user: this.sessInfo.x3User,
		server: this.sessInfo.x3Host,
		port: this.sessInfo.x3Port,
		codeLangIso: this.sessInfo.x3Lang,
		timeoutReuse:this.sessInfo.timeoutReuse,
		syraPreferences: preferences,
		printSrv: printSrvConfig,
		clientSettings:cliSettings
	}
	var reuseClient = null;
	traceSessions && traceSessions("Create session [Nb reuse: "+_listReuse.length+"]");
	if (_listReuse && _listReuse.length !== 0) {
		traceSessions && traceSessions("Search reuse...");
		var i=0;
		for(i=0; i < _listReuse.length && reuseClient == null ;i++){
			reuseClient = _listReuse[i].isSameContext(config, adxInfo) ? reuseClient = _listReuse[i] : reuseClient = null;
		}
		// remove client from reuse list
		if(reuseClient){
			traceSessions && traceSessions("Reuse found ! - id=" + reuseClient.uuid);
			reuseClient.setInReuseMode(_,false);
			_listReuse.splice(i-1,1);
			traceSessions && traceSessions("\t _listReuse.length"+_listReuse.length+"]");
		}else{
			traceSessions && traceSessions("Reuse not found !");
		}
	}
	var data = {}, statusCode = 200, response =null;
	try {
		if (!reuseClient){
			traceSessions && traceSessions("Create new client.");			
			var client = x3client.create({
				port: this.sessInfo.x3Port,
				address: this.sessInfo.x3Host,
				tracer : traceSessions,
			});
			var _x3=client.connect(_, {
				server: x3server.serverName(_),
				folder: this.sessInfo.x3Folder,
				fusion: true,
				locale: locale.current,
			});
			adxInfo.x3Pid="" + _x3.pid;
			adxInfo.x3SessionUrl = _x3.sessionUrl;
			adxInfo.x3SessionId = _x3.sessionId;
			traceSessions && traceSessions("Connected...");
			traceSessions && traceSessions("Create session [username: "+this.sessInfo.x3User+"]");
			var sid = client.createSession(_, {
				locale: locale.current,
				userName: this.sessInfo.x3User,
				adxtyp: 25,
				fusionTech: {
					protocol: "150067",
					wkf: context.parameters.f
				},	
			});
			traceSessions && traceSessions("Session ID: " + this.sid);
			this._fusionClient = new CvgClient(_, client.getStream(), adxInfo, config);
			this._fusionClient.sessionConv = this;
			response = this._fusionClient.start(_);
		}else{
			this._fusionClient = reuseClient;
			traceSessions && traceSessions("Retrieve existing client.");
			this._fusionClient.isReuse=false;
			response = this._fusionClient.execOpenFunction(_,context.parameters.f);
		}
		this._fusionClient._spy && this._fusionClient._spy.dumpJSON(_, "RESPONSE", response);	
		return {
			sid: this.sid,
			headers: {
				"content-type": "application/json",
			},
			body: response,
		};
	} catch(e){
		sendResponse(_, context, 500, getErrDiagnose(e, this._fusionClient, "connectionFailed"));
	}
}

sessionProto.destroyReuseClient = function(_, cvgClient){
	traceSessions && traceSessions("destroyReuseClient - nbReused:" + _listReuse.length + " - id:" + cvgClient.uuid);
	var found = false;
	var i=0;
	for(;i<_listReuse.length && !found ;i++){
		found=_listReuse[i].uuid === cvgClient.uuid;
	}	 
	if (found){
		_listReuse.splice(i-1,1);
		traceSessions && traceSessions("\treused client found - nbReused:" + _listReuse.length);
		// FDB - disconnected only if found ??
		cvgClient.deconnectClient(_,"timeout reuse");
	}else{
		traceSessions && traceSessions("\treused client not found");
	}
}

sessionProto.processRequest = function(_, context) {
	var data = {}, statusCode = 200;
	try{
		if (context.method !== 'put') throw new Error("bad method: " + context.method);
		var act = context.parameters.act;
		var post = JSON.parse(context.request.readAll(_));
		if (parseInt(post.act, 10) !== parseInt(context.parameters.act, 10)) throw new Error("act mismatch: expected " + context.parameters.act + ", got " + post.act);
		this._spy && this._spy.dumpJSON(_, "REQUEST", post);
		data = this._fusionClient.processRequest(_, post);
		//console.log("RESPONSE: " + JSON.stringify(response, null, 2));
		this._spy && this._spy.dumpJSON(_, "RESPONSE", data);

	}catch(e){
		statusCode = 500;
		data = getErrDiagnose(e, this._fusionClient);	
	}
	sendResponse(_, context, statusCode, data);
}


sessionProto.proxy = function(_, context, config) {
	try {
		var svc = context.segments[context.segments.length - 1];
		switch (svc) {
			case 'requestSvc':
				return this.processRequest(_, context);
			case 'formatSvc':
				return this._fusionClient.services.formatSvc.processRequest(_, context);
			case 'blobSvc':
				return this._fusionClient.services.blobSvc.processRequest(_, context);
			default:
				throw new Error("invalid fusion service: " + svc);
		}
	} catch(e) {
		sendResponse(_, context, 500, getErrDiagnose(e, this._fusionClient, "proxyFailed"));
	}	
}

sessionProto.close = function(_, reuse) {
	traceSessions && traceSessions("Close session [reuse:"+(reuse === true)+"] : "+this.sid);
	try {
		if (reuse){
			// store CvgClient in reuse list
			this._fusionClient.setInReuseMode(_,true);
			_listReuse.push(this._fusionClient);
			traceSessions && traceSessions("Add reuse session [size: "+_listReuse.length+"] - id=" + this._fusionClient.uuid);
		}else if (this._fusionClient.stream) {
			this._fusionClient.deconnectClient(_,"logout");
		}
	} catch (e) {
		console.error("Convergence session close failed");
		console.error(e.stack);
	}
}

// FDB - Return cvgSession entity data
sessionProto.cvgAdmSessInfo = function(_) {
	var res={};
	res.sid=this.sid;
	res.creationDate=this.creationDate;
	res.lastAccess=this.lastAccess;
	res.remoteaddr = this.sessInfo.remoteAddress,
	res.httpreferer = this.sessInfo.httpReferer,
	res.x3host=this.sessInfo.x3Host;
	res.x3port="" + this.sessInfo.x3Port;
	res.x3solution=this.sessInfo.x3Solution;
	res.x3folder=this.sessInfo.x3Folder;
	res.x3user=this.sessInfo.x3User;
	res.x3lang=this.sessInfo.x3Lang;
	res.x3func=this.sessInfo.x3Function;
	var cli=this._fusionClient;
	res.x3pid=cli.adxInfos.x3Pid;
	res.open=cli && cli.stream!=null;
	res.reused=cli && cli.reused;
	return res;
}
exports.newSession = function(_, fsid) {
	return new cvgSession(fsid);
}

// global function called from sessions cleanup
exports.closeSession = function(_, fsid, sessionUrl) {
	var options = {
		url: sessionUrl,
		method: "DELETE"
	}
	var request = streams.httpRequest(options);
	var resp = request.end();
	//	var respStr = request.end().response(_).readAll(_).toString("utf8");
	// TODO: decode response ?
}

exports.cvgAdmReuseClients=function(_, id){
	var res=[];
	for(var i=0; i<_listReuse.length;i++){
		var cli=_listReuse[i];
		if (id && cli.uuid!=id) continue;
		var cfg=cli.clientConfig.params;
		var info={
			cid:cli.uuid,
			x3host: cfg.server,
			x3port: "" + cfg.port,
			x3solution: cli.adxInfos.adxSolution,
			x3folder: cli.adxInfos.adxFolder,
			x3pid: cli.adxInfos.x3Pid,
			x3user: cfg.user,
			x3lang: cfg.codeLangIso,
			timeout:"" + Math.floor((new Date().getTime() - cli.timeToReuse)/1000) + "/" + Math.floor(cfg.timeoutReuse/1000),
			open:  cli.stream!=null,
			creationDate:cli.creationDate
		}
		res.push(info);
		if (id) break;
	}
	return res;
}

exports.cvgAdmReuseKill=function(_,cid){
	traceSessions && traceSessions("cvgAdmReuseKill - nbReused:" + _listReuse.length + " - id:" + cid);
	var cli = null;
	var i=0;
	for(;i<_listReuse.length && cli==null;i++){
		if (_listReuse[i].uuid === cid) cli = _listReuse[i];
	}	
	if (cli) {
		_listReuse.splice(i-1,1);
		traceSessions && traceSessions("\treused client found - nbReused:" + _listReuse.length);
		cli.deconnectClient(_,"closed by administrator");	
	}else{
		traceSessions && traceSessions("\treused client not found");
	}
	return cli!=null;
}
