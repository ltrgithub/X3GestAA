"use strict";

var datetime = require("syracuse-core/lib/types/datetime");
var util = require("util");
var url = require('url');
var check = require("syracuse-license/lib/check");
var flows = require("streamline/lib/util/flows");
var locale = require("syracuse-core/lib/locale");
var helpers = require("syracuse-core/lib/helpers");
var datetime = require("syracuse-core/lib/types/datetime");
var cvghelpers = require("./helpers");
var x3client = require('./client');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var ConvTracker = require("./cvgAsync").CvgTracker;
var CvgClient = require("syracuse-x3/lib/convergence/client/CvgClient").CvgClient;
var CvgException = require("syracuse-x3/lib/convergence/model/CvgException").CvgException;
var recordMgr = require("syracuse-x3/lib/convergence/records/recordMgr").recordMgr;

var globals = require('streamline/lib/globals');
var _tracer = cvghelpers.config("x3fusion.sessions.trace");
var _listReuse = [];
var _recModes = ["REC", "PLAY"];
var funnelReuse = flows.funnel(1);


function _getRsrc() {
	try {
		var i, args = [module];
		for (i in arguments) {
			args.push(arguments[i]);
		}
		return locale.format.apply(locale, args);
	} catch (e) {
		return "Resource not found [" + arguments[0] + "]";
	}
}

function _getErrDiagnose(e, client, resourceId) {
	//if (e) console.log("cvgSession Error: " + (e.stack ? "\n" + e.stack : (e.message ? e.message : e)));
	var error, msg = resourceId ? _getRsrc(resourceId) : e.message,
		diag;
	if (e instanceof CvgException) {
		error = e;
		if (error.diagnose.message) {
			error.diagnose.message += "\n" + msg;
		} else {
			error.diagnose.message = msg;
		}
	} else {
		if (e && e.$diagnoses && e.$diagnoses.length > 0) {
			// Diagnoses from peer
			error = new CvgException(client, e.message, msg);
			error.diagnose.$diagnoses = e.$diagnoses;
		} else {
			error = new CvgException(client, e, msg);
		}
	}
	return error;
}

function _sendResponse(_, context, statusCode, data, headers) {
	headers = headers || {};
	headers["content-type"] = "application/json";
	context.response.writeHead(statusCode, headers);
	context.response.write(_, JSON.stringify(data), 'utf8');
	context.response.end();
}

//-------------------------------------------------------
// No current settings - localCtrl/localFormat have been remove - we keep this code just in case we add new settings
var _cliSettingsDef = {};

function _readClientSettings(_, body) {
	try {
		if (body.length !== 0) {
			body = JSON.parse(body);
			if (body.settings) {
				var p;
				for (p in _cliSettingsDef) {
					if (body.settings[p] == null) {
						body.settings[p] = _cliSettingsDef[p];
					}
				}
				return body.settings;
			}
		}
	} catch (e) {}
	return _cliSettingsDef;
}
//-------------------------------------------------------
var CvgSession = helpers.defineClass(function _cvgSession(fsid) {
	_tracer && _tracer("New cvgSession - " + fsid);
	this.sessionUrl = "";
	this.sid = fsid;
	this.creationDate = datetime.now();
	//Set by session.updateCvgSession
	this.lastAccess = datetime.now();
	this._trackers = {};
}, null, {
	connect: function(_, context, config) {
		_tracer && _tracer("Direct Fusion Connect");
		// console.log(util.inspect(context));
		var lic = check.getParsedLicense(_);
		if (lic && !lic.namedUsers) {
			throw locale.format(module, "tooManyBadges");
		}
		this.syraid = context.httpSession.id;
		var endpoint = context.endpoint;
		var x3server = endpoint.x3server(_);
		var userProfile = context.httpSession.getUserProfile(_);
		this.syralogin = userProfile.user(_).login(_);

		var runtimeConfig = (context.httpSession.x3SessionConfig && context.httpSession.x3SessionConfig.runtime) || {};
		var remoteAddr = context.request.connection.remoteAddress;
		var referer = context.request.headers.referer;
		this.sessInfo = {
			remoteAddress: remoteAddr && remoteAddr.length > 0 ? remoteAddr : "unknown",
			httpReferer: referer && referer.length > 0 ? url.parse(referer).host : "unknown",
			x3Func: context.parameters.f.split('/')[0],
			serverUrl: ((context.request.context && context.request.context.url) || "").split("/").slice(0, 3).join("/")
		};
		// We need to store string to pass to recorder
		var requestBody = (context.request.readAll(_) || "").trim();
		var cliCfg = {
			x3User: userProfile && userProfile.user(_) && userProfile.user(_).getEndpointLogin(_, endpoint.$uuid),
			x3Host: x3server.serverHost(_),
			x3Port: x3server.serverPort(_),
			x3Lang: locale.current,
			x3HttpPub: endpoint.getWebServerBaseUrl(_),
			x3Folder: endpoint.x3ServerFolder(_),
			x3Solution: endpoint.x3SolutionName(_),
			timeoutReuse: cvghelpers.config("x3fusion.reuseTimeout", null, 120000),
			printConfig: cvghelpers.config("x3print"),
			appHost: x3server.serverName(_)
		};
		// Record exchanges - REC or PLAY
		cliCfg.recmode = context.parameters ? _recModes[_recModes.indexOf(context.parameters.recmode)] : null;
		// Add Syracuse preferences - dateOrder, thousandSep....
		cvghelpers.addLocaleConfig(_, cliCfg, userProfile);
		// Check mandatory values
		var p, err = null;
		for (p in cliCfg) {
			if (p.indexOf("x3") === 0 && (cliCfg[p] == null || cliCfg[p].toString().trim().length === 0)) {
				err += (err ? ", " : "") + p;
			}
		}
		if (err) {
			throw new Error("Bad administration configuration.\nFollowing parameter(s) are mandatory[" + err + "]");
		}
		var reuseClient = null;
		// Force !reuse if cliCfg.recmode = record or play
		if (cliCfg.recmode == null) {
			_tracer && _tracer("Create session [Nb reuse: " + _listReuse.length + "]");
			if (_listReuse && _listReuse.length !== 0) {
				_tracer && _tracer("Search reuse...");
				var i = 0;
				var self = this;
				funnelReuse(_, function(_) {
					for (i = 0; i < _listReuse.length && reuseClient == null; i++) {
						reuseClient = _listReuse[i].isSameContext(cliCfg) ? reuseClient = _listReuse[i] : reuseClient = null;
					}
					if (reuseClient) {
						_tracer && _tracer("Reuse found ! - id=" + reuseClient.uuid);
						reuseClient.setInReuseMode(_, false);
						self.sessionInfo = reuseClient.sessionInfo;
						self.sessionInfo.reused(_, false);
						_listReuse.splice(i - 1, 1);
						_tracer && _tracer("\t _listReuse.length" + _listReuse.length + "]");
					} else {
						_tracer && _tracer("Reuse not found !");
					}
				});



			}
		}
		var data = {}, statusCode = 200,
			response = null;
		try {
			// Records data exchanged between cvgCli and x3/uiCli
			var recorder = null;
			var isActivateRLog = runtimeConfig.runtimeLog && !runtimeConfig.dataset || endpoint.dataset(_) === runtimeConfig.dataset;
			if (!reuseClient || isActivateRLog) {
				// player fakes x3client - returned recorded data
				var player = cliCfg.recmode == "PLAY" ? recordMgr.getPlayer(context.parameters.recfile) : null;
				var client;
				if (player == null) {
					_tracer && _tracer("Create new client.");
					client = x3client.create({
						port: cliCfg.x3Port,
						address: cliCfg.x3Host,
						_tracer: _tracer
					});
					var _x3 = client.connect(_, {
						server: x3server.serverName(_),
						folder: cliCfg.x3Folder,
						fusion: true,
						locale: locale.current,
						runtimeLog: !runtimeConfig.dataset || endpoint.dataset(_) === runtimeConfig.dataset ? runtimeConfig.logFlag : "",
						runtimeLogDir: !runtimeConfig.dataset || endpoint.dataset(_) === runtimeConfig.dataset ? runtimeConfig.logDir : ""

					});
					cliCfg.x3Pid = "" + _x3.pid;
					cliCfg.x3SessionUrl = _x3.sessionUrl;
					cliCfg.x3SessionId = _x3.sessionId;
					_tracer && _tracer("Connected...");
					_tracer && _tracer("Create session [username: " + cliCfg.x3User + "]");
					_tracer && _tracer("session context fct  [" + context.parameters.f + "]");

					var adminEP = adminHelper.getCollaborationEndpoint(_);
					var sysAuthToken;
					if (userProfile) {
						var u = userProfile.user(_);
						if (u && u.infov6(_)) {
							sysAuthToken = new Buffer(u.userv6(_) + ":" + u.passwordv6(_), "utf8").toString("base64");
						}
					}
					var sid = client.createSession(_, {
						locale: locale.current,
						userName: cliCfg.x3User,
						adxtyp: 25,
						sysAuthToken: sysAuthToken,
						fusionTech: {
							protocol: "150067",
							wkf: context.parameters.f
						},
						localePreferences: userProfile.selectedLocale(_),
						baseUrl: context.baseUrl,
						collaborationBaseUrl: adminEP ? context.request.session.host + adminHelper.getCollaborationEndpoint(_).getBaseUrl(_) : ""
					});
					// If enabled records data exchange for replay
					if (cliCfg.recmode == "REC") {
						var opts = {
							fileName: context.parameters.recfile,
							overwrite: false,
							x3Func: this.sessInfo.x3Func,
							endpoint: {
								application: context.applicationName,
								contract: context.contractName,
								dataset: endpoint.dataset(_)
							},
							cliCfg: {}
						};
						recorder = recordMgr.newRecorder(_, client.getStream(), opts, cliCfg);
					}
					_tracer && _tracer("Session ID: " + this.sid);
				} else {
					_tracer && _tracer("cvgSession.connect - Mode PLAY  - No x3 connection");
					// Set cliCfg with data stored during recording
					// Player will run with same x3User and Syra preferences as recored ones independently of cuurent user profile
					player.restoreClientConfig(cliCfg);
				}
				this._cvgClient = new CvgClient(_, this, (player ? player : client.getStream()), cliCfg, recorder, context);
				this._cvgClient.activateRuntimeLog = runtimeConfig.runtimeLog;

				this._doAsync(_, context, 'connect', requestBody);
			} else {
				this._cvgClient = reuseClient;
				_tracer && _tracer("Retrieve existing client.");
				this._cvgClient._cvgSession = this;
				this._cvgClient.isReuse = false;
				this._doAsync(_, context, 'reuse', requestBody);
			}
			if (requestBody) {
				var sett = JSON.parse(requestBody);
				this._cvgClient.srvTrace = sett && sett.settings && sett.settings.srvTrace ? sett.settings.srvTrace : null;
			}
			this.cvgUpdateSessionInfo(_);
			return {
				sid: this.sid,
				headers: {
					"content-type": "application/json"
				},
				body: response
			};
		} catch (e) {
			var exp = _getErrDiagnose(e, this._cvgClient, this._cvgClient && this._cvgClient.clientConfig.modePLAY ? null : "connectionFailed");
			// we set location in order to let client to retreive cvgSessionId even if error
			_sendResponse(_, context, 500, exp.diagnose && exp.diagnose.toJSON ? exp.diagnose.toJSON() : exp.diagnose, {
				location: context.baseUrl + "/$sessions('" + this.sid + "')"
			});
		}
	},

	destroyReuseClient: function(_, cvgClient) {
		_tracer && _tracer("destroyReuseClient - nbReused:" + _listReuse.length + " - id:" + cvgClient.uuid);
		var found = false;
		var i;
		for (i = 0; i < _listReuse.length && !found; i++) {
			found = _listReuse[i].uuid === cvgClient.uuid;
		}
		if (found) {
			_listReuse.splice(i - 1, 1);
			_tracer && _tracer("\treused client found - nbReused:" + _listReuse.length);
			// FDB - disconnected only if found ??
			cvgClient.sessionInfo.deleteSelf(_);
			console.log("delete sessionInfo");
			cvgClient.deconnectClient(_, "timeout reuse");
		} else {
			_tracer && _tracer("\treused client not found");
		}
	},


	// Asynchronous call to X3 processes
	_doAsync: function(_, context, connectAct, bodyStr) {
		var self = this,
			data = null,
			tracker = null,
			excep = null,
			trackId = context.parameters.trackngId || "",
			trackAct = null;




		var observer = self;
		context.observer.split(".").forEach(function(key) {
			observer = observer[key];
		});
		// calculate the observer reference

		// Manage traces
		var x3SessionConfig = context.httpSession.x3SessionConfig || {};
		if (x3SessionConfig.cvgLog) {
			self._cvgClient.tracer.enabled = true;
			self._cvgClient.tracer.config = x3SessionConfig.convergence;
		}
		//

		if (trackId.length > 0) {
			// 'trackngId' parameters means start tracking
			trackAct = "START";
		} else {
			// '$trackers' parameters means track an existing tracker
			trackId = context.parameters.$trackers || "";
			if (trackId.length > 0) {
				trackAct = "TRACK";
			}
		}
		self.cvgUpdateSessionInfo(_);
		if (trackAct == null) {
			if (self._cvgClient.recorder) {
				self._cvgClient.recorder.dumpHttpReq(_, context, bodyStr);
			}
			// execute request in synchronous mode

			if ('connect' === connectAct) { // connection mode
				self._cvgClient.connectStart(_, context);
				context.reply(_, 200, self._cvgClient.generateResponse(_, true), self._cvgClient.response.head);
			} else if ('reuse' === connectAct) { // reuse mode
				self._cvgClient.execOpenFunction(_, context);
				context.reply(_, 200, self._cvgClient.generateResponse(_, true), self._cvgClient.response.head);
			} else if ('requestSvc' === connectAct) {
				self._cvgClient.processRequest(_, context, bodyStr);
				context.reply(_, 200, self._cvgClient.generateResponse(_, false), self._cvgClient.response.head);
			} else if ('blobSvc' === connectAct) {
				self._cvgClient.services.blobSvc.processRequest(_, context, bodyStr);
			}

			if (self._cvgClient.recorder) {
				self._cvgClient.recorder.dumpHttpResp(_, data.body);
			}
		} else {
			try {
				if (trackAct == "START") {
					// Start tracking request
					self._trackers[context.observer] = self._trackers[context.observer] || {};
					if (self._trackers[context.observer][trackId]) { // tracker is prefix by observer to allow to use the same id for plugin
						throw new Error("Tracker already exist. trackId[" + trackId + "]");
					}
					tracker = self._trackers[context.observer][trackId] = new ConvTracker(_, context, trackId, observer, connectAct != null);
					data = null;
					var statusCode = 500;
					try {
						// function that stop tracker and write response in normal case

						if (self._cvgClient.recorder) {
							self._cvgClient.recorder.dumpHttpReq(_, context, bodyStr);
						}
						// if we are in orhestration mode the asyncWait must be less that less 1 second
						var asyncWait = _asynchWait;
						if (self._cvgClient.cvgPlugin)
							asyncWait = 500;
						tracker.start(_, context, asyncWait);
						// console.log("\tprocessRequest.begin");

						if (connectAct === 'connect') {
							self._cvgClient.connectStart(_, context, tracker);
						} else if (connectAct === 'reuse') {
							self._cvgClient.execOpenFunction(_, context, tracker);
						} else if (connectAct === 'requestSvc') {
							observer.processRequest(_, context, bodyStr, tracker); // process the rquest of the client or other observer link the client
						} else if (connectAct === 'blobSvc') {
							observer.services.blobSvc.processRequest(_, context, bodyStr);
						}


					} catch (e) {
						statusCode = 500;
						var body = e.toJSON ? e.diagnose.toJSON() : _getErrDiagnose(e, this._cvgClient, "connectionFailed").diagnose.toJSON();
						data = {
							head: {},
							body: body
						};
						//console.log("\tprocessRequest.end "+statusCode+" data "+JSON.stringify(data));
						tracker.stop(_, context, data, statusCode); // tracker in the case of no excpetion is closed
						if (statusCode == 200 && self._cvgClient.recorder) {
							self._cvgClient.recorder.dumpHttpResp(_, data.body);
						}
					}
				} else {
					// trackAct == "TRACK"
					// Pooling tracking request
					trackId = context.parameters.$trackers;
					switch (context.method) {
						case 'get':
							tracker = self._trackers[context.observer][trackId];
							if (!tracker) {
								return context.reply(_, 404, "tracker not found: " + trackId);
							}
							tracker.track(_, context.response);
							break;
						case 'delete':
							delete self._trackers[context.observer][trackId];
							context.reply(_, 204);
							break;
						default:
							throw new Error("_doAsynch.track - Bad method: " + context.method);
					}
				}
			} catch (e) {
				console.log("cvgSession._doAsync - ERROR " + (e.stack ? e.stack : e));
				excep = e;
				var exp = e.toJSON ? e : new CvgException(self[observer], e, "");
				//context.reply(_,500 , body,{});
				throw exp;

			} finally {
				// Clear trackers list
				if (excep != null || (tracker && tracker.isFlushed())) {
					// console.log("cvgSession._doAsync - Clear tracker " + trackId)
					if (tracker) {
						tracker.destroy(_);
					}
					delete self._trackers[context.observer][trackId];
				}
			}
		}
	},

	proxy: function(_, context, config) {
		try {
			// Read requestbody - only one call to readAll is allowed
			var bodyStr;
			var svc = context.segments[context.segments.length - 1];
			switch (svc) {
				case 'requestSvc':
					bodyStr = context.request.readAll(_) || "{}";
					this._doAsync(_, context, "requestSvc", bodyStr);
					break;
				case 'blobSvc':
					this._doAsync(_, context, "blobSvc", bodyStr);
					//this._cvgClient.services.blobSvc.processRequest(_, context, bodyStr);
					break;
				default:
					// connection case
					bodyStr = context.request.readAll(_) || "{}";
					this._doAsync(_, context, "requestSvc", bodyStr);
					//throw new Error("invalid convergence service: " + svc);
			}
		} catch (e) {
			_sendResponse(_, context, 500, _getErrDiagnose(e, this._cvgClient, "proxyFailed").diagnose.toJSON());
		}
	},

	close: function(_, params, reason) {
		_tracer && _tracer("Close session [reuse:" + (params.reuse === true) + "] : " + this.sid);
		try {
			if (params.reuse && !this._cvgClient.activateRuntimeLog) {
				// store CvgClient in reuse list
				this._cvgClient.setInReuseMode(_, true);
				this.sessionInfo.reused(_, true);
				this.cvgUpdateSessionInfo(_);
				this._cvgClient.sessionInfo = this.sessionInfo; // save sessionInfo

				_listReuse.push(this._cvgClient);
				_tracer && _tracer("Add reuse session [size: " + _listReuse.length + "] - id=" + this._cvgClient.uuid + " - reason=" + reason);
			} else if (this._cvgClient) {
				var self = this;
				flows.setTimeout(function(_) {
					self._cvgClient.deconnectClient(_, params, reason || "logout");
					self.sessionInfo.deleteSelf(_);

				}, 1); //ghost session deconnect can blocked if a action is in progress. To prevent blocking of logout we delay the close
			} else {
				_tracer && _tracer("\tNo cvgClient");
			}
			// purge async tracker in any case
			this._trackers = {};
		} catch (e) {
			console.log("Convergence session close failed");
			console.log(e.stack ? e.stack : e.message ? e.message : e);
		}
	},

	cvgUpdateSessionInfo: function(_) {
		var session = this;
		if (session.ignoreStoreSession) {
			return;
		}
		if (!session.updateFunnel) {
			session.updateFunnel = flows.funnel(1);
		}
		return session.updateFunnel(_, function(_) {
			//_tracer && _tracer("cvgSession.updateSessionInfo at " + new Date());
			// store or update session
			var cvgSessionInfo = session.sessionInfo;
			if (!cvgSessionInfo) {
				var db = adminHelper.getCollaborationOrm(_);
				//
				var factory = db.model.getEntity(_, "cvgSession").factory;
				cvgSessionInfo = factory.createInstance(_, null, db);
				var res = session.cvgAdmSessInfo(_);
				cvgSessionInfo.sid(_, res.sid);
				cvgSessionInfo.syralogin(_, res.syralogin);
				cvgSessionInfo.syraid(_, res.syraid);
				cvgSessionInfo.remoteaddr(_, res.remoteaddr);
				cvgSessionInfo.creationDate(_, res.creationDate);
				cvgSessionInfo.lastAccess(_, res.lastAccess);
				cvgSessionInfo.httpreferer(_, res.httpreferer);
				// add cli info
				cvgSessionInfo.cid(_, res.cid);
				cvgSessionInfo.x3host(_, res.x3host);
				cvgSessionInfo.x3port(_, res.x3port);
				cvgSessionInfo.x3solution(_, res.x3solution);
				cvgSessionInfo.x3folder(_, res.x3folder);
				cvgSessionInfo.x3pid(_, res.x3pid);
				cvgSessionInfo.x3user(_, res.x3user);
				cvgSessionInfo.x3lang(_, res.x3lang);
				cvgSessionInfo.open(_, res.open);
				//
				session.sessionInfo = cvgSessionInfo;
			} else if (cvgSessionInfo.lastAccess(_).equals(session.lastAccess)) {
				return;
			}
			cvgSessionInfo.lastAccess(_, session.lastAccess);
			cvgSessionInfo.save(_);
		});

	},

	// FDB - Return cvgSession entity data
	cvgAdmSessInfo: function(_) {
		var res = {};
		res.sid = this.sid;
		res.syraid = this.syraid;
		res.syralogin = this.syralogin;

		res.creationDate = this.creationDate;
		res.lastAccess = this.lastAccess;
		res.remoteaddr = this.sessInfo && this.sessInfo.remoteAddress;
		res.httpreferer = this.sessInfo && this.sessInfo.httpReferer;
		res.x3func = this.sessInfo && this.sessInfo.x3Func;
		var cli = this._cvgClient;
		_cvgAdmAddCliInfo(cli, res);
		res.reused = cli && cli.reused;
		return res;
	}

});
//




// Time to wait before sending the first tracking reply to client
var _asynchWait = cvghelpers.config("x3fusion.tracker.maxTimeBeforeSend", null, 4000);

exports.newSession = function(_, fsid) {
	return new CvgSession(fsid);
};

// Info property mame are the name of cvgReuseClient and cvgSession entity  properties

function _cvgAdmAddCliInfo(cli, info) {
	var cfg = cli && cli.clientConfig || {};
	info.cid = cli.uuid;
	info.x3host = cfg.getParam("x3Host");
	info.x3port = "" + cfg.getParam("x3Port");
	info.x3solution = cfg.getParam("x3Solution");
	info.x3folder = cfg.getParam("x3Folder");
	info.x3pid = "" + cfg.getParam("x3Pid");
	info.x3user = cfg.getParam("x3User");
	info.x3lang = cfg.getParam("x3Lang");
	info.open = cli.stream != null;
	return info;
}
exports.cvgAdmReuseClients = function(_, id) {
	var i, res = [];
	for (i = 0; i < _listReuse.length; i++) {
		var cli = _listReuse[i];
		if (id && cli.uuid != id) {
			continue;
		}
		// Info property mame is the name of cvgReuseClient entity  property
		var cfg = cli.clientConfig;
		var info = {
			timeout: "" + Math.floor((new Date().getTime() - cli.timeToReuse) / 1000) + "/" + Math.floor(cfg.getParam("timeoutReuse") / 1000),
			creationDate: cli.creationDate
		};
		_cvgAdmAddCliInfo(cli, info);
		res.push(info);
		if (id) {
			break;
		}
	}
	return res;
};
exports.cvgAdmReuseKill = function(_, cid) {
	_tracer && _tracer("cvgAdmReuseKill - nbReused:" + _listReuse.length + " - id:" + cid);
	var cli = null;
	var i;
	for (i = 0; i < _listReuse.length && cli == null; i++) {
		if (_listReuse[i].uuid === cid) {
			cli = _listReuse[i];
		}
	}
	if (cli) {
		_listReuse.splice(i - 1, 1);
		_tracer && _tracer("\treused client found - nbReused:" + _listReuse.length);
		cli.sessionInfo.deleteSelf(_);
		console.log("delete sessionInfo");
		delete cli.sessionInfo;
		cli.deconnectClient(_, "closed by administrator");
	} else {
		_tracer && _tracer("\treused client not found");
	}
	return cli != null;
};