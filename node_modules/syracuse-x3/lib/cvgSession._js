"use strict";

var datetime = require("syracuse-core/lib/types/datetime");
var util = require("util");
var url = require('url');
var check = require("syracuse-license/lib/check");
var flows = require("streamline/lib/util/flows");
var locale = require("syracuse-core/lib/locale");
var helpers = require("syracuse-core/lib/helpers");
var datetime = require("syracuse-core/lib/types/datetime");
var cvghelpers = require("./helpers");
var x3client = require('./client');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var ConvTracker = require("./cvgAsync").CvgTracker;
var CvgClient = require("syracuse-x3/lib/convergence/client/CvgClient").CvgClient;
var CvgException = require("syracuse-x3/lib/convergence/model/CvgException").CvgException;
var recordMgr = require("syracuse-x3/lib/convergence/records/recordMgr").recordMgr;
var cvgListReuse = require("syracuse-x3/lib/cvgListReuse");

var globals = require('streamline/lib/globals');
var _tracer = cvghelpers.config("x3fusion.sessions.trace");
var _listReuse = [];

var _recModes = ["REC", "PLAY"];


function _getRsrc() {
	try {
		var i, args = [module];
		for (i in arguments) {
			args.push(arguments[i]);
		}
		return locale.format.apply(locale, args);
	} catch (e) {
		return "Resource not found [" + arguments[0] + "]";
	}
}

function _getErrDiagnose(e, client, resourceId) {
	//if (e) console.log("cvgSession Error: " + (e.stack ? "\n" + e.stack : (e.message ? e.message : e)));
	var error, msg = resourceId ? _getRsrc(resourceId) : e.message,
		diag;
	if (e instanceof CvgException) {
		error = e;
		if (error.diagnose.message) {
			error.diagnose.message += "\n" + msg;
		} else {
			error.diagnose.message = msg;
		}
	} else {
		if (e && e.$diagnoses && e.$diagnoses.length > 0) {
			// Diagnoses from peer
			error = new CvgException(client, e.message, msg);
			error.diagnose.$diagnoses = e.$diagnoses;
		} else {
			error = new CvgException(client, e, msg);
		}
	}
	return error;
}

function _sendResponse(_, context, statusCode, data, headers) {
	headers = headers || {};
	headers["content-type"] = "application/json";
	context.response.writeHead(statusCode, headers);
	context.response.write(_, JSON.stringify(data), 'utf8');
	context.response.end();
}

//-------------------------------------------------------
// No current settings - localCtrl/localFormat have been remove - we keep this code just in case we add new settings
var _cliSettingsDef = {};





function _readClientSettings(_, body) {
	try {
		if (body.length !== 0) {
			body = JSON.parse(body);
			if (body.settings) {
				var p;
				for (p in _cliSettingsDef) {
					if (body.settings[p] == null) {
						body.settings[p] = _cliSettingsDef[p];
					}
				}
				return body.settings;
			}
		}
	} catch (e) {}
	return _cliSettingsDef;
}
//-------------------------------------------------------
var CvgSession = helpers.defineClass(function _cvgSession(fsid) {
	_tracer && _tracer("New cvgSession - " + fsid);
	this.sessionUrl = "";
	this.sid = fsid;
	this.creationDate = datetime.now();
	//Set by session.updateCvgSession
	this.lastAccess = datetime.now();
	this._trackers = {};
}, null, {
	connect: function(_, context, config) {
		_tracer && _tracer("Direct Fusion Connect");
		// console.log(util.inspect(context));
		var self = this;
		var lic = check.getParsedLicense(_);
		if (lic && !lic.namedUsers) {
			throw locale.format(module, "tooManyBadges");
		}
		this.syraid = context.httpSession.id;
		var endpoint = context.endpoint;
		var x3server = endpoint.x3server(_);
		var userProfile = context.httpSession.getUserProfile(_);
		this.syralogin = userProfile.user(_).login(_);

		var runtimeConfig = (context.httpSession.x3SessionConfig && context.httpSession.x3SessionConfig.runtime) || {};
		var remoteAddr = context.request.connection.remoteAddress;
		var referer = context.request.headers.referer;
		this.sessInfo = {
			remoteAddress: remoteAddr && remoteAddr.length > 0 ? remoteAddr : "unknown",
			httpReferer: referer && referer.length > 0 ? url.parse(referer).host : "unknown",
			x3Func: context.parameters.f.split('/')[0],
			serverUrl: ((context.request.context && context.request.context.url) || "").split("/").slice(0, 3).join("/")
		};
		// We need to store string to pass to recorder
		var requestBody = (context.request.readAll(_) || "").trim();
		var reuseTimeout = cvghelpers.config("x3fusion.reuseTimeout", null, 20 * 60 * 1000);
		var cliCfg = {
			x3User: userProfile && userProfile.user(_) && userProfile.user(_).getEndpointLogin(_, endpoint.$uuid),
			x3Host: x3server.serverHost(_),
			x3Port: x3server.serverPort(_),
			x3Lang: locale.current,
			x3HttpPub: endpoint.getWebServerBaseUrl(_),
			x3Folder: endpoint.x3ServerFolder(_),
			x3Solution: endpoint.x3SolutionName(_),
			timeoutReuse: (reuseTimeout < 1000 ? reuseTimeout * 60 * 1000 : reuseTimeout),
			printConfig: cvghelpers.config("x3print"),
			appHost: x3server.serverName(_),
			endpointUuid: endpoint.$uuid // needed for historical folder
		};
		// Record exchanges - REC or PLAY
		cliCfg.recmode = context.parameters ? _recModes[_recModes.indexOf(context.parameters.recmode)] : null;
		// Add Syracuse preferences - dateOrder, thousandSep....
		cvghelpers.addLocaleConfig(_, cliCfg, userProfile);
		// Check mandatory values
		var p, err = null;
		for (p in cliCfg) {
			if (p.indexOf("x3") === 0 && (cliCfg[p] == null || cliCfg[p].toString().trim().length === 0)) {
				err += (err ? ", " : "") + p;
			}
		}
		if (err) {
			throw new Error("Bad administration configuration.\nFollowing parameter(s) are mandatory[" + err + "]");
		}
		var reuseClient = null;
		// Force !reuse if cliCfg.recmode = record or play
		if (cliCfg.recmode == null) {
			var i = 0;

			var reuseClient = cvgListReuse.getClient(_, context, cliCfg);
			if (reuseClient) {
				_tracer && _tracer("Reuse found ! - id=" + reuseClient.uuid);
				reuseClient.setInReuseMode(_, false);
				self.sessionInfo = reuseClient.sessionInfo;
				self.sessionInfo.reused(_, false);

			} else {
				_tracer && _tracer("Reuse not found !");
			}
		}
		var data = {}, statusCode = 200,
			response = null;
		try {
			// Records data exchanged between cvgCli and x3/uiCli
			var recorder = null;
			var isActivateRLog = runtimeConfig.runtimeLog && !runtimeConfig.dataset || endpoint.dataset(_) === runtimeConfig.dataset;
			if (!reuseClient || isActivateRLog) {
				// player fakes x3client - returned recorded data
				var player = cliCfg.recmode == "PLAY" ? recordMgr.getPlayer(context.parameters.recfile) : null;
				var client;
				if (player == null) {
					_tracer && _tracer("Create new client.");
					client = x3client.create({
						port: cliCfg.x3Port,
						address: cliCfg.x3Host,
						_tracer: _tracer
					});
					var _x3 = client.connect(_, {
						server: x3server.serverName(_),
						folder: cliCfg.x3Folder,
						fusion: true,
						locale: locale.current,
						runtimeLog: !runtimeConfig.dataset || endpoint.dataset(_) === runtimeConfig.dataset ? runtimeConfig.logFlag : "",
						runtimeLogDir: !runtimeConfig.dataset || endpoint.dataset(_) === runtimeConfig.dataset ? runtimeConfig.logDir : ""

					});
					cliCfg.x3Pid = "" + _x3.pid;
					cliCfg.x3SessionUrl = _x3.sessionUrl;
					cliCfg.x3SessionId = _x3.sessionId;
					_tracer && _tracer("Connected...");
					_tracer && _tracer("Create session [username: " + cliCfg.x3User + "]");
					_tracer && _tracer("session context fct  [" + context.parameters.f + "]");

					var adminEP = adminHelper.getCollaborationEndpoint(_);
					var sysAuthToken;
					if (userProfile) {
						var u = userProfile.user(_);
						if (u && u.infov6(_)) {
							sysAuthToken = new Buffer(u.userv6(_) + ":" + u.passwordv6(_), "utf8").toString("base64");
						}
					}
					var sid = client.createSession(_, {
						locale: locale.current,
						userName: cliCfg.x3User,
						adxtyp: 25,
						sysAuthToken: sysAuthToken,
						fusionTech: {
							protocol: "150067",
							wkf: context.parameters.f
						},
						localePreferences: userProfile.selectedLocale(_),
						baseUrl: context.baseUrl,
						collaborationBaseUrl: adminEP ? context.request.session.host + adminHelper.getCollaborationEndpoint(_).getBaseUrl(_) : ""
					});
					// If enabled records data exchange for replay
					if (cliCfg.recmode == "REC") {
						var opts = {
							fileName: context.parameters.recfile,
							overwrite: false,
							x3Func: this.sessInfo.x3Func,
							endpoint: {
								application: context.applicationName,
								contract: context.contractName,
								dataset: endpoint.dataset(_)
							},
							cliCfg: {}
						};
						recorder = recordMgr.newRecorder(_, client.getStream(), opts, cliCfg);
					}
					_tracer && _tracer("Session ID: " + this.sid);
				} else {
					_tracer && _tracer("cvgSession.connect - Mode PLAY  - No x3 connection");
					// Set cliCfg with data stored during recording
					// Player will run with same x3User and Syra preferences as recored ones independently of cuurent user profile
					player.restoreClientConfig(cliCfg);
				}
				this._cvgClient = new CvgClient(_, this, (player ? player : client.getStream()), cliCfg, recorder, context);
				this._cvgClient.activateRuntimeLog = runtimeConfig.runtimeLog;

				this._doAsync(_, context, 'C', requestBody);
			} else {
				this._cvgClient = reuseClient;
				_tracer && _tracer("Retrieve existing client.");
				this._cvgClient.setCvgSession(this);
				this._cvgClient.isReuse = false;
				this._doAsync(_, context, 'R', requestBody);
			}
			if (requestBody) {
				var sett = JSON.parse(requestBody);
				this._cvgClient.srvTrace = sett && sett.settings && sett.settings.srvTrace ? sett.settings.srvTrace : null;
			}
			this.cvgUpdateSessionInfo(_);
			return {
				sid: this.sid,
				headers: {
					"content-type": "application/json"
				},
				body: response
			};
		} catch (e) {
			var exp = _getErrDiagnose(e, this._cvgClient, this._cvgClient && this._cvgClient.clientConfig.modePLAY ? null : "connectionFailed");
			// we set location in order to let client to retreive cvgSessionId even if error
			_sendResponse(_, context, 500, exp.diagnose && exp.diagnose.toJSON ? exp.diagnose.toJSON() : exp.diagnose, {
				location: context.baseUrl + "/$sessions('" + this.sid + "')"
			});
		}
	},

	destroyReuseClient: function(_, cvgClient) {

		cvgListReuse.destroyReuseClient(_, cvgClient, this.syraid);
	},


	// Asynchronous call to X3 processes
	_doAsync: function(_, context, connectAct, bodyStr) {
		var self = this,
			data = null,
			tracker = null,
			excep = null,
			trackId = context.parameters.trackngId || "",
			trackAct = null,
			timeAsync = Date.now();

		// Manage traces
		var x3SessionConfig = context.httpSession.x3SessionConfig || {};
		if (x3SessionConfig.cvgLog) {
			self._cvgClient.tracer.enabled = true;
			self._cvgClient.tracer.config = x3SessionConfig.convergence;
		}
		//

		if (trackId.length > 0) {
			// 'trackngId' parameters means start tracking
			trackAct = "START";
		} else {
			// '$trackers' parameters means track an existing tracker
			trackId = context.parameters.$trackers || "";
			if (trackId.length > 0) {
				trackAct = "TRACK";
			}
		}
		// will be done by the syracuse session in checkInterval
		// self.cvgUpdateSessionInfo(_);
		if (trackAct == null) {
			if (self._cvgClient.recorder) {
				self._cvgClient.recorder.dumpHttpReq(_, context, bodyStr);
			}
			// execute request in synchronous mode

			if ('C' === connectAct) { // connection mode
				self._cvgClient.connectStart(_, context);
			} else if ('R' === connectAct) { // reuse mode
				self._cvgClient.execOpenFunction(_, context);
			} else {
				self._cvgClient.processRequest(_, context, bodyStr);
			}

			context.reply(_, 200, self._cvgClient.generateResponse(_, 'C' === connectAct || 'R' === connectAct), self._cvgClient.response.head);
			if (self._cvgClient.recorder) {
				self._cvgClient.recorder.dumpHttpResp(_, data.body);
			}
		} else {
			try {
				if (trackAct == "START") {
					var beforeProcess = Date.now();
					// Start tracking request
					if (self._trackers[trackId]) {
						throw new Error("Tracker already exist. trackId[" + trackId + "]");
					}
					tracker = self._trackers[trackId] = new ConvTracker(_, context, trackId, self._cvgClient, connectAct != null);
					data = null;
					var statusCode = 500;
					try {
						if (self._cvgClient.recorder) {
							self._cvgClient.recorder.dumpHttpReq(_, context, bodyStr);
						}
						tracker.start(_, context, _asynchWait);
						// console.log("\tprocessRequest.begin");
						//console.log("before call process "+(Date.now()-beforeProcess));
						if (connectAct == null) {
							self._cvgClient.processRequest(_, context, bodyStr);
						} else {
							if (connectAct === 'C') {
								self._cvgClient.connectStart(_, context);
							} else if (connectAct === 'R') {
								self._cvgClient.execOpenFunction(_, context);
							}
						}
						self._cvgClient.generateResponse(_, 'C' === connectAct || 'R' === connectAct);
						data = self._cvgClient.response;
						statusCode = 200;
					} catch (e) {
						statusCode = 500;
						var body = e.toJSON ? e.diagnose.toJSON() : _getErrDiagnose(e, this._cvgClient, "connectionFailed").diagnose.toJSON();
						data = {
							head: {},
							body: body
						};
					} finally {
						//console.log("\tprocessRequest.end "+statusCode+" data "+JSON.stringify(data));
						tracker.stop(_, context, data, statusCode);
						if (statusCode == 200 && self._cvgClient.recorder) {
							self._cvgClient.recorder.dumpHttpResp(_, data.body);
						}
					}
				} else {
					// trackAct == "TRACK"
					// Pooling tracking request
					trackId = context.parameters.$trackers;
					switch (context.method) {
						case 'get':
							tracker = self._trackers[trackId];
							if (!tracker) {
								return context.reply(_, 404, "tracker not found: " + trackId);
							}
							tracker.track(_, context.response);
							break;
						case 'delete':
							delete self._trackers[trackId];
							context.reply(_, 204);
							break;
						default:
							throw new Error("_doAsynch.track - Bad method: " + context.method);
					}
				}
			} catch (e) {
				console.log("cvgSession._doAsync - ERROR " + (e.stack ? e.stack : e));
				excep = e;
				var exp = e.toJSON ? e : new CvgException(self._cvgClient, e, "");
				//context.reply(_,500 , body,{});
				throw exp;

			} finally {
				// Clear trackers list
				if (excep != null || (tracker && tracker.isFlushed())) {
					// console.log("cvgSession._doAsync - Clear tracker " + trackId)
					if (tracker) {
						tracker.destroy(_);
					}
					delete self._trackers[trackId];
				}
			}
		}
		//console.log("time async "+(Date.now()-timeAsync));
	},

	proxy: function(_, context, config) {
		try {
			// Read requestbody - only one call to readAll is allowed
			var bodyStr;
			var svc = context.segments[context.segments.length - 1];
			switch (svc) {
				case 'requestSvc':
					bodyStr = context.request.readAll(_) || "{}";
					this._doAsync(_, context, null, bodyStr);
					_tracer && _tracer("proxy.requestSvc: " + context.method.toUpperCase() + " " + (context.request.context || {}).url + "\n" + bodyStr);
					break;
				case 'blobSvc':
					this._cvgClient.services.blobSvc.processRequest(_, context, bodyStr);
					break;
				default:
					// connection case
					bodyStr = context.request.readAll(_) || "{}";
					this._doAsync(_, context, null, bodyStr);
					//throw new Error("invalid convergence service: " + svc);
			}
		} catch (e) {
			_sendResponse(_, context, 500, _getErrDiagnose(e, this._cvgClient, "proxyFailed").diagnose.toJSON());
		}
	},

	/*
	 close all reuse client that are assoiciate to that http session
	 */

	close: function(_, params, reason) {
		_tracer && _tracer("Close session [reuse:" + (params.reuse === true) + "] : " + this.sid);
		try {
			if (params.reuse && !this._cvgClient.activateRuntimeLog) {
				// store CvgClient in reuse list
				var self = this;

				self.sessionInfo.reused(_, true);
				self.cvgUpdateSessionInfo(_);
				cvgListReuse.addReuse(_, self._cvgClient, self.sessionInfo, this.syraid, reason);
			} else if (this._cvgClient) {
				var self = this;
				flows.setTimeout(function(_) {
					self._cvgClient.deconnectClient(_, params, reason || "logout");
					self.sessionInfo.deleteSelf(_, {
						ignoreRestrictions: true
					});

				}, 1); //ghost session deconnect can blocked if a action is in progress. To prevent blocking of logout we delay the close
			} else {
				_tracer && _tracer("\tNo cvgClient");
			}
			// purge async tracker in any case
			this._trackers = {};
		} catch (e) {
			console.log("Convergence session close failed");
			console.log(e.stack ? e.stack : e.message ? e.message : e);
		}
	},

	cvgUpdateSessionInfo: function(_) {
		var session = this;
		if (session.ignoreStoreSession) {
			return null;
		}
		//		if (!session.updateFunnel) {
		//			session.updateFunnel = flows.funnel(1);
		//		}
		//		return session.updateFunnel(_, function(_) {
		//_tracer && _tracer("cvgSession.updateSessionInfo at " + new Date());
		// store or update session
		var cvgSessionInfo = session.sessionInfo;
		if (!cvgSessionInfo) {
			var db = adminHelper.getCollaborationOrm(_);
			//
			var factory = db.model.getEntity(_, "cvgSession").factory;
			cvgSessionInfo = factory.createInstance(_, null, db);
			var res = session.cvgAdmSessInfo(_);
			cvgSessionInfo.sid(_, res.sid);
			cvgSessionInfo.syralogin(_, res.syralogin);
			cvgSessionInfo.syraid(_, res.syraid);
			cvgSessionInfo.remoteaddr(_, res.remoteaddr);
			cvgSessionInfo.creationDate(_, res.creationDate);
			cvgSessionInfo.lastAccess(_, res.lastAccess);
			cvgSessionInfo.httpreferer(_, res.httpreferer);
			// add cli info
			cvgSessionInfo.cid(_, res.cid);
			cvgSessionInfo.x3host(_, res.x3host);
			cvgSessionInfo.x3port(_, res.x3port);
			cvgSessionInfo.x3solution(_, res.x3solution);
			cvgSessionInfo.x3folder(_, res.x3folder);
			cvgSessionInfo.x3pid(_, res.x3pid);
			cvgSessionInfo.x3user(_, res.x3user);
			cvgSessionInfo.x3lang(_, res.x3lang);
			cvgSessionInfo.open(_, res.open);
			//
			session.sessionInfo = cvgSessionInfo;
		} else if (cvgSessionInfo.lastAccess(_).equals(session.lastAccess)) {
			return null;
		}
		cvgSessionInfo.lastAccess(_, session.lastAccess);
		return cvgSessionInfo.save(_, null, {
			shallowSerialize: true,
			ignoreRestrictions: true,
			clearDiagnoses: true
		});
		//		});

	},

	// FDB - Return cvgSession entity data
	cvgAdmSessInfo: function(_) {
		var res = {};
		res.sid = this.sid;
		res.syraid = this.syraid;
		res.syralogin = this.syralogin;

		res.creationDate = this.creationDate;
		res.lastAccess = this.lastAccess;
		res.remoteaddr = this.sessInfo.remoteAddress;
		res.httpreferer = this.sessInfo.httpReferer;
		res.x3func = this.sessInfo.x3Func;
		var cli = this._cvgClient;
		cli && cvgListReuse.cvgAdmAddCliInfo(cli, res);
		res.reused = cli && cli.reused;
		return res;
	}

});
//




// Time to wait before sending the first tracking reply to client
var _asynchWait = cvghelpers.config("x3fusion.tracker.maxTimeBeforeSend", null, 4000);

exports.newSession = function(_, fsid) {
	return new CvgSession(fsid);
};