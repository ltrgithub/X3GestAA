"use strict";

var datetime = require("syracuse-core/lib/types/datetime");
var util = require("util");
var url = require('url');
var check = require("syracuse-license/lib/check");
var flows = require("streamline/lib/util/flows");
var locale = require("syracuse-core/lib/locale");
var helpers = require("syracuse-core/lib/helpers");
var datetime = require("syracuse-core/lib/types/datetime");
var cvghelpers = require("./helpers");
var x3client = require('./client');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var convTracker = require("./cvgAsync").cvgTracker;
var CvgClient = require("syracuse-x3/lib/convergence/client/CvgClient").CvgClient;
var CvgException = require("syracuse-x3/lib/convergence/model/CvgException").CvgException;
var recordMgr = require("syracuse-x3/lib/convergence/records/recordMgr").recordMgr;

var _tracer = cvghelpers.config("x3fusion.sessions.trace");
var _listReuse = [];
var _recModes = ["REC", "PLAY"];

function _cvgSession(fsid) {
	_tracer && _tracer("New cvgSession - " + fsid);
	this.sessionUrl = "";
	this.sid = fsid;
	this.creationDate = datetime.now();
	//Set by session.updateCvgSession
	this.lastAccess = datetime.now();
	this._trackers = {};
}

function _getRsrc() {
	try {
		var args = [module];
		for (var i in arguments) {
			args.push(arguments[i]);
		}
		return locale.format.apply(locale, args);
	} catch (e) {
		return "Resource not found [" + arguments[0] + "]";
	}
}

function _getErrDiagnose(e, client, resourceId) {
	if (e) console.log("cvgSession Error: " + (e.stack ? "\n" + e.stack : (e.message ? e.message : e)));
	var error, msg = resourceId ? _getRsrc(resourceId) : e.message;
	if (e instanceof CvgException) {
		error = e;
		if (error.diagnose.message) error.diagnose.message += "\n" + msg;
		else error.diagnose.message = msg;
	} else error = new CvgException(client, e, msg);
	return error;
}

function _sendResponse(_, context, statusCode, data, headers) {
	var headers = headers || {};
	headers["content-type"] = "application/json";
	context.response.writeHead(statusCode, headers);
	context.response.write(_, JSON.stringify(data), 'utf8');
	context.response.end();
}

//-------------------------------------------------------
// No current settings - localCtrl/localFormat have been remove - we keep this code just in case we add new settings
var _cliSettingsDef = {};

function _readClientSettings(_, body) {
	try {
		if (body.length != 0) {
			body = JSON.parse(body);
			if (body.settings) {
				for (var p in _cliSettingsDef) {
					if (body.settings[p] == null) body.settings[p] = _cliSettingsDef[p];
				}
				return body.settings;
			}
		}
	} catch (e) {}
	return _cliSettingsDef;
}
//-------------------------------------------------------
var _sessionProto = _cvgSession.prototype;
//
_sessionProto.connect = function(_, context, config) {
	_tracer && _tracer("Direct Fusion Connect");
	// console.log(util.inspect(context));
	var lic = check.getParsedLicense(_);
	if (lic && !lic.namedUsers) throw locale.format(module, "tooManyBadges");
	var endpoint = context.endpoint;
	var x3server = endpoint.x3server(_);
	var userProfile = context.httpSession.getUserProfile(_);
	var remoteAddr = context.request.connection.remoteAddress;
	var referer = context.request.headers["referer"];
	this.sessInfo = {
		remoteAddress: remoteAddr && remoteAddr.length > 0 ? remoteAddr : "unknown",
		httpReferer: referer && referer.length > 0 ? url.parse(referer).host : "unknown",
		x3Func: context.parameters.f.split('/')[0],
		serverUrl: ((context.request.context && context.request.context.url) || "").split("/").slice(0, 3).join("/")
	};
	// We need to store string to pass to recorder
	var requestBody = (context.request.readAll(_) || "").trim();
	// change getApplicationBaseUrl by getWebServerBaseUrl to be sure of x3pub url
	var cliCfg = {
		x3User: userProfile && userProfile.user(_) && userProfile.user(_).getEndpointLogin(_, endpoint.$uuid),
		x3Host: x3server.serverHost(_),
		x3Port: x3server.serverPort(_),
		x3Lang: locale.current,
		x3HttpPub: endpoint.getWebServerBaseUrl(_),
		x3Folder: endpoint.x3ServerFolder(_),
		x3Solution: endpoint.x3SolutionName(_),
		timeoutReuse: cvghelpers.config("x3fusion.reuseTimeout", null, 120000),
		printConfig: cvghelpers.config("x3print"),
		appHost: x3server.serverName(_)
	};
	// Record exchanges - REC or PLAY
	cliCfg.recmode = context.parameters ? _recModes[_recModes.indexOf(context.parameters.recmode)] : null;
	// Add Syracuse preferences - dateOrder, thousandSep....
	cvghelpers.addLocaleConfig(_, cliCfg, userProfile);
	// Check mandatory values
	var err = null;
	for (var p in cliCfg) {
		if (p.indexOf("x3") == 0 && (cliCfg[p] == null || cliCfg[p].toString().trim().length == 0)) err += (err ? ", " : "") + p;
	}
	if (err) throw new Error("Bad administration configuration.\nFollowing parameter(s) are mandatory[" + err + "]");
	var reuseClient = null;
	// Force !reuse if cliCfg.recmode = record or play
	if (cliCfg.recmode == null) {
		_tracer && _tracer("Create session [Nb reuse: " + _listReuse.length + "]");
		if (_listReuse && _listReuse.length !== 0) {
			_tracer && _tracer("Search reuse...");
			var i = 0;
			for (i = 0; i < _listReuse.length && reuseClient == null; i++) {
				reuseClient = _listReuse[i].isSameContext(cliCfg) ? reuseClient = _listReuse[i] : reuseClient = null;
			}
			// remove client from reuse list
			if (reuseClient) {
				_tracer && _tracer("Reuse found ! - id=" + reuseClient.uuid);
				reuseClient.setInReuseMode(_, false);
				_listReuse.splice(i - 1, 1);
				_tracer && _tracer("\t _listReuse.length" + _listReuse.length + "]");
			} else {
				_tracer && _tracer("Reuse not found !");
			}
		}
	}
	var data = {}, statusCode = 200,
		response = null;
	try {
		// Records data exchanged between cvgCli and x3/uiCli
		var recorder = null;
		if (!reuseClient) {
			// player fakes x3client - returned recorded data 
			var player = cliCfg.recmode == "PLAY" ? player = recordMgr.getPlayer(context.parameters.recfile) : null;
			if (player == null) {
				_tracer && _tracer("Create new client.");
				var client = x3client.create({
					port: cliCfg.x3Port,
					address: cliCfg.x3Host,
					_tracer: _tracer,
				});
				var _x3 = client.connect(_, {
					server: x3server.serverName(_),
					folder: cliCfg.x3Folder,
					fusion: true,
					locale: locale.current,
				});
				cliCfg.x3Pid = "" + _x3.pid;
				cliCfg.x3SessionUrl = _x3.sessionUrl;
				cliCfg.x3SessionId = _x3.sessionId;
				_tracer && _tracer("Connected...");
				_tracer && _tracer("Create session [username: " + cliCfg.x3User + "]");
				_tracer && _tracer("session context fct  [" + context.parameters.f + "]");

				var adminEP = adminHelper.getCollaborationEndpoint(_);
				var sid = client.createSession(_, {
					locale: locale.current,
					userName: cliCfg.x3User,
					adxtyp: 25,
					fusionTech: {
						protocol: "150067",
						wkf: context.parameters.f
					},
					localePreferences: userProfile.selectedLocale(_),
					baseUrl: context.baseUrl,
					collaborationBaseUrl: adminEP ? context.request.session.host + adminHelper.getCollaborationEndpoint(_).getBaseUrl(_) : ""
				});
				// If enabled records data exchange for replay 
				if (cliCfg.recmode == "REC") {
					var opts = {
						fileName: context.parameters.recfile,
						overwrite: false,
						x3Func: this.sessInfo.x3Func,
						endpoint: {
							application: context.applicationName,
							contract: context.contractName,
							dataset: endpoint.dataset(_)
						},
						cliCfg: {}
					};
					recorder = recordMgr.newRecorder(_, client.getStream(), opts, cliCfg);
				}
				_tracer && _tracer("Session ID: " + this.sid);
			} else {
				_tracer && _tracer("cvgSession.connect - Mode PLAY  - No x3 connection");
				// Set cliCfg with data stored during recording
				// Player will run with same x3User and Syra preferences as recored ones independently of cuurent user profile
				player.restoreClientConfig(cliCfg);
			}
			this._cvgClient = new CvgClient(_, this, player ? player : client.getStream(), cliCfg, recorder, context);
			this._doAsync(_, context, 'C', requestBody);
		} else {
			this._cvgClient = reuseClient;
			_tracer && _tracer("Retrieve existing client.");
			this._cvgClient._cvgSession = this;
			this._cvgClient.isReuse = false;
			this._doAsync(_, context, 'R', requestBody);
		}
		this.cvgUpdateSessionInfo(_);
		return {
			sid: this.sid,
			headers: {
				"content-type": "application/json",
			},
			body: response,
		};
	} catch (e) {
		if (this._cvgClient && this._cvgClient.clientConfig.modePLAY) {
			//Mode play - add error message diagnose
			var exp = _getErrDiagnose(e, this._cvgClient);
		} else {
			var exp = _getErrDiagnose(e, this._cvgClient, "connectionFailed");
		}
		// we set location in order to let client to retreive cvgSessionId even if error
		_sendResponse(_, context, 500, exp.diagnose, {
			location: context.baseUrl + "/$sessions('" + this.sid + "')"
		});
	}
};

_sessionProto.destroyReuseClient = function(_, cvgClient) {
	_tracer && _tracer("destroyReuseClient - nbReused:" + _listReuse.length + " - id:" + cvgClient.uuid);
	var found = false;
	var i = 0;
	for (; i < _listReuse.length && !found; i++) {
		found = _listReuse[i].uuid === cvgClient.uuid;
	}
	if (found) {
		_listReuse.splice(i - 1, 1);
		_tracer && _tracer("\treused client found - nbReused:" + _listReuse.length);
		// FDB - disconnected only if found ??
		cvgClient.deconnectClient(_, "timeout reuse");
	} else {
		_tracer && _tracer("\treused client not found");
	}
};

// Time to wait before sending the first tracking reply to client
var _asynchWait = cvghelpers.config("x3fusion.tracker.maxTimeBeforeSend", null, 4000);

// Asynchronous call to X3 processes
_sessionProto._doAsync = function(_, context, connectAct, bodyStr) {
	var self = this,
		data = null,
		tracker = null,
		excep = null,
		trackId = context.parameters.trackngId || "",
		trackAct = null;
	if (trackId.length > 0) {
		// 'trackngId' parameters means start tracking
		trackAct = "START";
	} else {
		// '$trackers' parameters means track an existing tracker
		trackId = context.parameters.$trackers || "";
		if (trackId.length > 0) trackAct = "TRACK";
	}

	this.cvgUpdateSessionInfo(_);
	if (trackAct == null) {
		if (self._cvgClient.recorder) self._cvgClient.recorder.dumpHttpReq(_, context, bodyStr);
		// execute request in synchronous mode
		var data;
		if ('C' === connectAct) { // connection mode
			data = self._cvgClient.connectSart(_, context);
		} else if ('R' === connectAct) { // reuse mode
			data = self._cvgClient.execOpenFunction(_, context);
		} else {
			data = self._cvgClient.processRequest(_, context, bodyStr);
		}
		context.reply(_, 200, data.body, data.head);
		if (self._cvgClient.recorder) self._cvgClient.recorder.dumpHttpResp(_, data.body);
	} else {
		try {
			if (trackAct == "START") {
				// Start tracking request
				if (self._trackers[trackId]) throw new Error("Tracker already exist. trackId[" + trackId + "]");
				tracker = self._trackers[trackId] = new convTracker(_, context, trackId, self._cvgClient, connectAct != null);
				var data = null,
					statusCode = 500;
				try {
					if (self._cvgClient.recorder) self._cvgClient.recorder.dumpHttpReq(_, context, bodyStr);
					tracker.start(_, context, _asynchWait);
					// console.log("\tprocessRequest.begin");
					if (connectAct == null) {
						data = self._cvgClient.processRequest(_, context, bodyStr);
					} else {
						if (connectAct === 'C') {
							data = self._cvgClient.connectSart(_, context);
						} else if (connectAct === 'R') {
							data = self._cvgClient.execOpenFunction(_, context);
						}
					}
					statusCode = 200;
				} catch (e) {
					statusCode = 500;
					var body = e.toJSON ? e.diagnose.toJSON() : _getErrDiagnose(e, this._cvgClient, "connectionFailed").diagnose.toJSON();
					data = {
						head: {},
						body: body
					};
				} finally {
					//console.log("\tprocessRequest.end "+statusCode+" data "+JSON.stringify(data));
					tracker.stop(_, context, data, statusCode);
					if (statusCode == 200 && self._cvgClient.recorder) self._cvgClient.recorder.dumpHttpResp(_, data.body);
				}
			} else {
				// trackAct == "TRACK"
				// Pooling tracking request
				trackId = context.parameters.$trackers;
				switch (context.method) {
					case 'get':
						tracker = self._trackers[trackId];
						if (!tracker) return context.reply(_, 404, "tracker not found: " + trackId);
						tracker.track(_, context.response);
						break;
					case 'delete':
						delete self._trackers[trackId];
						context.reply(_, 204);
						break;
					default:
						throw new Error("_doAsynch.track - Bad method: " + context.method);
				}
			}
		} catch (e) {
			console.log("cvgSession._doAsync - ERROR " + (e.stack ? e.stack : e));
			excep = e;
			var exp = e.toJSON ? e : new CvgException(self._cvgClient, e, "");
			//context.reply(_,500 , body,{});			
			throw exp;

		} finally {
			// Clear trackers list
			if (excep != null || (tracker && tracker.isFlushed())) {
				// console.log("cvgSession._doAsync - Clear tracker " + trackId)
				if (tracker) tracker.destroy(_);
				delete self._trackers[trackId];
			}
		}
	}
};

_sessionProto.proxy = function(_, context, config) {
	try {
		// Read requestbody - only one call to readAll is allowed
		var bodyStr = context.request.readAll(_) || "{}";
		var svc = context.segments[context.segments.length - 1];
		switch (svc) {
			case 'requestSvc':
				this._doAsync(_, context, null, bodyStr);
				break;
			case 'blobSvc':
				this._cvgClient.services.blobSvc.processRequest(_, context, bodyStr);
				break;
			default:
				// connection case
				this._doAsync(_, context, null, bodyStr);
				//throw new Error("invalid convergence service: " + svc);
		}
	} catch (e) {
		_sendResponse(_, context, 500, _getErrDiagnose(e, this._cvgClient, "proxyFailed").diagnose);
	}
};

_sessionProto.close = function(_, reuse, reason) {
	_tracer && _tracer("Close session [reuse:" + (reuse === true) + "] : " + this.sid);
	try {
		if (reuse) {
			// store CvgClient in reuse list
			this._cvgClient.setInReuseMode(_, true);
			_listReuse.push(this._cvgClient);
			_tracer && _tracer("Add reuse session [size: " + _listReuse.length + "] - id=" + this._cvgClient.uuid + " - reason=" + reason);
		} else if (this._cvgClient) {
			this._cvgClient.deconnectClient(_, reason || "logout");
		} else {
			_tracer && _tracer("\tNo cvgClient");
		}
		// purge async tracker in any case 
		this._trackers = {};
	} catch (e) {
		console.log("Convergence session close failed");
		console.log(e.stack ? e.stack : e.message ? e.message : e);
	}
};

_sessionProto.cvgUpdateSessionInfo = function(_) {
	var session = this;
	if (session.ignoreStoreSession) return;
	if (!session.updateFunnel) session.updateFunnel = flows.funnel(1);
	return session.updateFunnel(_, function(_) {
		//_tracer && _tracer("cvgSession.updateSessionInfo at " + new Date());
		// store or update session
		var cvgSessionInfo = session.cvgSessionInfo;
		if (!cvgSessionInfo) {
			var db = adminHelper.getCollaborationOrm(_);
			// 
			var factory = db.model.getEntity(_, "cvgSession").factory;
			cvgSessionInfo = factory.createInstance(_, null, db);
			var res = session.cvgAdmSessInfo(_);
			cvgSessionInfo.sid(_, res.sid);
			cvgSessionInfo.remoteaddr(_, res.remoteaddr);
			cvgSessionInfo.creationDate(_, res.creationDate);
			cvgSessionInfo.lastAccess(_, res.lastAccess);
			cvgSessionInfo.httpreferer(_, res.httpreferer);
			cvgSessionInfo.x3func(_, res.x3fun);
			// add cli info 
			cvgSessionInfo.cid(_, res.cid);
			cvgSessionInfo.x3host(_, res.x3host);
			cvgSessionInfo.x3port(_, res.x3port);
			cvgSessionInfo.x3solution(_, res.x3solution);
			cvgSessionInfo.x3folder(_, res.x3folder);
			cvgSessionInfo.x3pid(_, res.x3pid);
			cvgSessionInfo.x3user(_, res.x3user);
			cvgSessionInfo.x3lang(_, res.x3lang);
			cvgSessionInfo.open(_, res.open);
			//
			session.sessionInfo = cvgSessionInfo;
		} else if (cvgSessionInfo.lastAccess(_).equals(session.lastAccess)) {
			return;
		}
		cvgSessionInfo.lastAccess(_, session.lastAccess);
		cvgSessionInfo.save(_);
	});

};

// FDB - Return cvgSession entity data
_sessionProto.cvgAdmSessInfo = function(_) {
	var res = {};
	res.sid = this.sid;
	res.creationDate = this.creationDate;
	res.lastAccess = this.lastAccess;
	res.remoteaddr = this.sessInfo.remoteAddress;
	res.httpreferer = this.sessInfo.httpReferer;
	res.x3func = this.sessInfo.x3Func;
	var cli = this._cvgClient;
	_cvgAdmAddCliInfo(cli, res);
	res.reused = cli && cli.reused;
	return res;
};
exports.newSession = function(_, fsid) {
	return new _cvgSession(fsid);
};

// Info property mame are the name of cvgReuseClient and cvgSession entity  properties
function _cvgAdmAddCliInfo(cli, info) {
	var cfg = cli && cli.clientConfig || {};
	info.cid = cli.uuid;
	info.x3host = cfg.getParam("x3Host");
	info.x3port = "" + cfg.getParam("x3Port");
	info.x3solution = cfg.getParam("x3Solution");
	info.x3folder = cfg.getParam("x3Folder");
	info.x3pid = "" + cfg.getParam("x3Pid");
	info.x3user = cfg.getParam("x3User");
	info.x3lang = cfg.getParam("x3Lang");
	info.open = cli.stream != null;
	return info;
}
exports.cvgAdmReuseClients = function(_, id) {
	var res = [];
	for (var i = 0; i < _listReuse.length; i++) {
		var cli = _listReuse[i];
		if (id && cli.uuid != id) continue;
		// Info property mame is the name of cvgReuseClient entity  property
		var cfg = cli.clientConfig;
		var info = {
			timeout: "" + Math.floor((new Date().getTime() - cli.timeToReuse) / 1000) + "/" + Math.floor(cfg.getParam("timeoutReuse") / 1000),
			creationDate: cli.creationDate
		};
		_cvgAdmAddCliInfo(cli, info);
		res.push(info);
		if (id) break;
	}
	return res;
};
exports.cvgAdmReuseKill = function(_, cid) {
	_tracer && _tracer("cvgAdmReuseKill - nbReused:" + _listReuse.length + " - id:" + cid);
	var cli = null;
	var i = 0;
	for (; i < _listReuse.length && cli == null; i++) {
		if (_listReuse[i].uuid === cid) cli = _listReuse[i];
	}
	if (cli) {
		_listReuse.splice(i - 1, 1);
		_tracer && _tracer("\treused client found - nbReused:" + _listReuse.length);
		cli.deconnectClient(_, "closed by administrator");
	} else {
		_tracer && _tracer("\treused client not found");
	}
	return cli != null;
};