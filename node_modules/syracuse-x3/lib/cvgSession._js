"use strict";

var locale = require("syracuse-core/lib/locale");
var helpers = require("syracuse-core/lib/helpers");
var datetime = require("syracuse-core/lib/types/datetime");
var streams = require("streamline/lib/streams/streams");
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var x3helpers = require("./helpers");
var parseUrl = require('url').parse;
var x3helpers = require("./helpers");
var util = require("util");
var url = require('url');
var check = require("syracuse-license/lib/check");
var x3client = require('syracuse-x3/lib/client');
var CvgClient = require("syracuse-x3/lib/convergence/client/CvgClient").CvgClient;
var CvgException = require("syracuse-x3/lib/convergence/model/CvgException").CvgException;
var recordMgr = require("syracuse-x3/lib/convergence/records/recordMgr").recordMgr;

var _nodeCfg=nodeconfig.config;
var _printCfg = _nodeCfg && _nodeCfg.x3print && _nodeCfg.x3print.server;
var _tracer = _nodeCfg && _nodeCfg.x3fusion && _nodeCfg.x3fusion.sessions && _nodeCfg.x3fusion.sessions.trace;
var _listReuse = [];
var _recModes=["REC","PLAY"];

function _startProfile() {
	return (new Date()).getTime();
}

function _endProfile(startTime) {
	return (new Date()).getTime() - startTime;
}

function _cvgSession(fsid) {
	_tracer && _tracer("New cvgSession - " + fsid);
	this.sessionUrl = "";
	this.sid = fsid;
	this.creationDate=datetime.now();
	//Set by session.updateCvgSession
	this.lastAccess=0;
}

function _getRsrc() {
	try {
		var args = [module];
		for (var i in arguments) {
			args.push(arguments[i]);
		}
		return locale.format.apply(locale, args);
	} catch (e) {
		return "Resource not found [" + arguments[0] + "]";
	}
}

function _getErrDiagnose(e, client, resourceId) {
	console.error("Error: "+e.stack);
	var error, msg = resourceId ? _getRsrc(resourceId) : e.message;
	if (e instanceof CvgException) {
		error = e;
		error.diagnose.message = msg;
	} else {
		console.log(e.stack);
		error = new CvgException(client, e, msg);
	}
	
	return error.diagnose;
}

function _sendResponse(_, context, statusCode, data) {
	context.response.writeHead(statusCode, {
		"content-type": "application/json",
	});
	context.response.write(_, JSON.stringify(data), 'utf8');
	context.response.end();	
}

//-------------------------------------------------------
// localCtrl à true indique que le client :
//		se charge des contrôles de saisie
//		assure le formatage « edit to display » de la zone courante (donc plus de previous dans le reply qui fait suite)
//		assure le déformatage de la zone courante, donc le fld.v dans le body du poste est déjà au format raw.
//		localFormat à true indique que le client se charge de formater toutes les donnée présentes dans les data sources (donc tout ce qui figure sous sap.wins.CdWin.entities d’un reply)
// localFormat à true indique que le client 
//		se charge de formater toutes les donnée présentes dans les data sources (donc tout ce qui figure sous sap.wins.CdWin.entities d’un reply)
var _cliSettingsDef={ 
		format: {
			localCtrl : false,
			localFormat: false
		}
};
function _readClientSettings(_, context){
	try{
		var body=(context.request.readAll(_) || "").trim();
		if (body.length!=0){
			body=JSON.parse(body);
			if (body.settings){
				for (var p in _cliSettingsDef){
					if(body.settings[p]==null) body.settings[p]=_cliSettingsDef[p]
				}
				return body.settings;
			} 
		}
	}catch(e){}
	return _cliSettingsDef;
}
//-------------------------------------------------------
var _sessionProto = _cvgSession.prototype;
//
_sessionProto.connect = function(_, context, config) {
	_tracer && _tracer("Direct Fusion Connect");
	var lic = check.getParsedLicense(_);
	if (lic && !lic.namedUsers) throw locale.format(module, "tooManyBadges");
	var endpoint = context.endpoint;
	var x3server = endpoint.x3server(_);
	var userProfile = context.httpSession.getUserProfile(_);
	var remoteAddr=context.request.connection.remoteAddress;
	var referer=context.request.headers["referer"];
	this.sessInfo={
		remoteAddress: remoteAddr && remoteAddr.length>0 ? remoteAddr : "unknown",
	    httpReferer: referer && referer.length>0 ? url.parse(referer).host : "unknown",
		x3Func: context.parameters.f.split('/')[0]
	}
	var preferences, selLocale = userProfile && userProfile.selectedLocale(_);
	if (selLocale) {
		// FDB - Session Settings required by X3 client - dateOrder (dym-myd-ymd-dm if no year...)/dateSep/decSep/thousandSep
		preferences = x3helpers.dateFormatToX3Prefs(selLocale.shortDate(_));
		var decimalSep = selLocale.numberDecimalSeparator(_);
		var thousandsSep = selLocale.numberGroupSeparator(_);
		var timeSep = x3helpers.getTimeSep(selLocale.shortTime(_));
		if (decimalSep != null) preferences.decimalSep = decimalSep;
		if (thousandsSep != null) preferences.thousandsSep = thousandsSep;
		if (timeSep != null) preferences.timeSep = timeSep;
	}
	var cliCfg = {
		x3User : userProfile && userProfile.user(_) && userProfile.user(_).getEndpointLogin(_, endpoint.$uuid),
		x3Host : x3server.serverHost(_),
		x3Port : x3server.serverPort(_),
		x3Lang : locale.current,
		x3HttpPub : endpoint.getApplicationServerBaseUrl(_),
		x3Folder : endpoint.x3ServerFolder(_),
		x3Solution :  endpoint.x3SolutionName(_),
		timeoutReuse : _nodeCfg && _nodeCfg.x3fusion && _nodeCfg.x3fusion.reuseTimeout || 120000,
		syraPrefs : preferences,
		printSrv : _printCfg,
		// client settings allow web client to enbale/disable CvgClient behaviors
		clientSettings : _readClientSettings(_,context)
	}
	// Check mandatory values
	var err=null;
	for (var p in cliCfg){
		if (p.indexOf("x3")==0 && (cliCfg[p]==null || cliCfg[p].toString().trim().length==0)) err += (err?", " : "") + p;
	}
	if (err) throw new Error ("Bad administration configuration.\nFollowing parameter(s) are mandatory["+err+"]")
	var reuseClient = null;
	_tracer && _tracer("Create session [Nb reuse: "+_listReuse.length+"]");
	if (_listReuse && _listReuse.length !== 0) {
		_tracer && _tracer("Search reuse...");
		var i=0;
		for(i=0; i < _listReuse.length && reuseClient == null ;i++){
			reuseClient = _listReuse[i].isSameContext(cliCfg) ? reuseClient = _listReuse[i] : reuseClient = null;
		}
		// remove client from reuse list
		if(reuseClient){
			_tracer && _tracer("Reuse found ! - id=" + reuseClient.uuid);
			reuseClient.setInReuseMode(_,false);
			_listReuse.splice(i-1,1);
			_tracer && _tracer("\t _listReuse.length"+_listReuse.length+"]");
		}else{
			_tracer && _tracer("Reuse not found !");
		}
	}
	var data = {}, statusCode = 200, response =null;
	try {			
		// Record exchanges - REC or PLAY
		cliCfg.recMode =_recModes[_recModes.indexOf(context.parameters.recmode)];
		// Records data exchangeed between cvgCli and x3/uiCli
		var recorder =null;
		// Force !reuse if cliCfg.recMode - mode record or play
		if (!reuseClient || cliCfg.recMode){
			// player fakes x3client - returned recorded data 
			var player = cliCfg.recMode == "PLAY" ? player = recordMgr.newStreamPlay(_) : null;
			if (player == null){
				_tracer && _tracer("Create new client.");			
				var client = x3client.create({
					port: cliCfg.x3Port,
					address: cliCfg.x3Host,
					_tracer : _tracer,
				});
				var _x3=client.connect(_, {
					server: x3server.serverName(_),
					folder: cliCfg.x3Folder,
					fusion: true,
					locale: locale.current,
				});
				cliCfg.x3Pid = "" + _x3.pid;
				cliCfg.x3SessionUrl = _x3.sessionUrl;
				cliCfg.x3SessionId = _x3.sessionId;
				_tracer && _tracer("Connected...");
				_tracer && _tracer("Create session [username: "+cliCfg.x3User+"]");
				var sid = client.createSession(_, {
					locale: locale.current,
					userName: cliCfg.x3User,
					adxtyp: 25,
					fusionTech: {
						protocol: "150067",
						wkf: context.parameters.f
					},	
				});
				// If enabled records data exchange for replay 
				if (cliCfg.recMode == "REC"){
					recorder = recordMgr.newStreamRec(_, client.getStream(),{fileName:context.parameters.recfile,overwrite:false,x3func:context.parameters.f});
					recorder.dumpHttpReq(_, context);
				}
				_tracer && _tracer("Session ID: " + this.sid);
			}else{
				_tracer && _tracer("Mode PLAY  - No x3 connection");
			}
			this._cvgClient = new CvgClient(_, player ? player : client.getStream(), cliCfg, recorder);
			this._cvgClient.sessionConv = this;
			response = this._cvgClient.connectSart(_);
		}else{
			this._cvgClient = reuseClient;
			_tracer && _tracer("Retrieve existing client.");
			this._cvgClient.isReuse=false;
			response = this._cvgClient.execOpenFunction(_,context.parameters.f);
		}
		if (recorder){			
			recorder.dumpHttpResp(_, response);		
			// We keep _spy mode
			this._cvgClient._spy && this._cvgClient._spy.dumpJSON(_, "RESPONSE", response);	
		}
		return {
			sid: this.sid,
			headers: {
				"content-type": "application/json",
			},
			body: response,
		};
	} catch(e){
		_sendResponse(_, context, 500, _getErrDiagnose(e, this._cvgClient, "connectionFailed"));
	}
}

_sessionProto.destroyReuseClient = function(_, cvgClient){
	_tracer && _tracer("destroyReuseClient - nbReused:" + _listReuse.length + " - id:" + cvgClient.uuid);
	var found = false;
	var i=0;
	for(;i<_listReuse.length && !found ;i++){
		found=_listReuse[i].uuid === cvgClient.uuid;
	}	 
	if (found){
		_listReuse.splice(i-1,1);
		_tracer && _tracer("\treused client found - nbReused:" + _listReuse.length);
		// FDB - disconnected only if found ??
		cvgClient.deconnectClient(_,"timeout reuse");
	}else{
		_tracer && _tracer("\treused client not found");
	}
}

_sessionProto.processRequest = function(_, context) {
	var data = null, statusCode = 500;
	try{
		data = this._cvgClient.processRequest(_, context);
		statusCode = 200;
	}catch(e){
		data = _getErrDiagnose(e, this._cvgClient);	
	}
	_sendResponse(_, context, statusCode, data);
}


_sessionProto.proxy = function(_, context, config) {
	try {
		var svc = context.segments[context.segments.length - 1];
		switch (svc) {
			case 'requestSvc':
				return this.processRequest(_, context);
			case 'formatSvc':
				return this._cvgClient.services.formatSvc.processRequest(_, context);
			case 'blobSvc':
				return this._cvgClient.services.blobSvc.processRequest(_, context);
			default:
				throw new Error("invalid convergence service: " + svc);
		}
	} catch(e) {
		_sendResponse(_, context, 500, _getErrDiagnose(e, this._cvgClient, "proxyFailed"));
	}	
}

_sessionProto.close = function(_, reuse) {
	_tracer && _tracer("Close session [reuse:"+(reuse === true)+"] : "+this.sid);
	try {
		if (reuse){
			// store CvgClient in reuse list
			this._cvgClient.setInReuseMode(_,true);
			_listReuse.push(this._cvgClient);
			_tracer && _tracer("Add reuse session [size: "+_listReuse.length+"] - id=" + this._cvgClient.uuid);
		}else if (this._cvgClient.stream) {
			this._cvgClient.deconnectClient(_,"logout");
		}
	} catch (e) {
		console.error("Convergence session close failed");
		console.error(e.stack);
	}
}

// FDB - Return cvgSession entity data
_sessionProto.cvgAdmSessInfo = function(_) {
	var res={};
	res.sid=this.sid;
	res.creationDate=this.creationDate;
	res.lastAccess=this.lastAccess;
	res.remoteaddr = this.sessInfo.remoteAddress;
	res.httpreferer = this.sessInfo.httpReferer;
	res.x3func = this.sessInfo.x3Func;
	var cli=this._cvgClient;
	_cvgAdmAddCliInfo(cli,res);	
	res.reused=cli && cli.reused;
	return res;
}
exports.newSession = function(_, fsid) {
	return new _cvgSession(fsid);
}
// global function called from sessions cleanup
exports.closeSession = function(_, fsid, sessionUrl) {
	var options = {
		url: sessionUrl,
		method: "DELETE"
	}
	var request = streams.httpRequest(options);
	var resp = request.end();
	//	var respStr = request.end().response(_).readAll(_).toString("utf8");
	// TODO: decode response ?
}
// Info property mame are the name of cvgReuseClient and cvgSession entity  properties
function _cvgAdmAddCliInfo(cli, info){
	var cfg=cli && cli.clientConfig || {};
	info.cid = cli.uuid;
	info.x3host = cfg.getParam("x3Host");
	info.x3port = "" + cfg.getParam("x3Port");
	info.x3solution = cfg.getParam("x3Solution");
	info.x3folder = cfg.getParam("x3Folder");
	info.x3pid = "" + cfg.getParam("x3Pid");
	info.x3user = cfg.getParam("x3User");
	info.x3lang = cfg.getParam("x3Lang");
	info.open = cli.stream!=null;
	return info;
}
exports.cvgAdmReuseClients=function(_, id){
	var res=[];
	for(var i=0; i<_listReuse.length;i++){
		var cli=_listReuse[i];
		if (id && cli.uuid!=id) continue;
		// Info property mame is the name of cvgReuseClient entity  property
		var cfg = cli.clientConfig;
		var info={
			timeout : "" + Math.floor((new Date().getTime() - cli.timeToReuse)/1000) + "/" + Math.floor(cfg.getParam("timeoutReuse")/1000),
			creationDate : cli.creationDate
		}
		_cvgAdmAddCliInfo(cli,info);
		res.push(info);
		if (id) break;
	}
	return res;
}
exports.cvgAdmReuseKill=function(_,cid){
	_tracer && _tracer("cvgAdmReuseKill - nbReused:" + _listReuse.length + " - id:" + cid);
	var cli = null;
	var i=0;
	for(;i<_listReuse.length && cli==null;i++){
		if (_listReuse[i].uuid === cid) cli = _listReuse[i];
	}	
	if (cli) {
		_listReuse.splice(i-1,1);
		_tracer && _tracer("\treused client found - nbReused:" + _listReuse.length);
		cli.deconnectClient(_,"closed by administrator");	
	}else{
		_tracer && _tracer("\treused client not found");
	}
	return cli!=null;
}
