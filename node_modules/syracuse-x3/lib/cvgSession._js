"use strict";

var datetime = require('syracuse-core').types.datetime;
var url = require('url');
var check = require("syracuse-license/lib/check");
var flows = require('streamline-runtime').flows;
var locale = require('streamline-locale');
var helpers = require('syracuse-core').helpers;
var datetime = require('syracuse-core').types.datetime;
var cvghelpers = require("./helpers");
var x3client = require('./client');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var ConvTracker = require("./cvgAsync").CvgTracker;
var CvgClient = require("syracuse-x3/lib/convergence/client/CvgClient").CvgClient;
var CvgException = require("syracuse-x3/lib/convergence/model/CvgException").CvgException;
var recordMgr = require("syracuse-x3/lib/convergence/records/recordMgr").recordMgr;
var cvgListReuse = require("syracuse-x3/lib/cvgListReuse");
var tracerSession = require('syracuse-core').getTracer("classic.session");
var OfflinePlayer = require("syracuse-x3/lib/clients/common/offlinePlayer").OfflinePlayer;
var _recModes = ["REC", "PLAY"];
var upath = require('path');
var fs = require("streamline-fs");
var mainFunctions = ["ADSVAL", "GESADS", "CREHISTO", "APATCH", "APATCHA", "PATCH", "ABICREUNV", "ABIVALBAS", "ABIVALTOT", "ABIMAJBAS", "ABIMOVETA"];

mainFunctions = (cvghelpers.config("x3fusion.mainFunctions") && Array.isArray(cvghelpers.config("x3fusion.mainFunctions")) ? cvghelpers.config("x3fusion.mainFunctions").concat(mainFunctions) : mainFunctions); // fixed list of function that have to be launch of the main server

function _getRsrc() {
	try {
		var i, args = [module];
		for (i in arguments) {
			args.push(arguments[i]);
		}
		return locale.format.apply(locale, args);
	} catch (e) {
		return "Resource not found"; // [" + arguments[0] + "]";
	}
}

function _getErrDiagnose(e, client, resourceId) {
	//if (e) console.log("cvgSession Error: " + (e.stack ? "\n" + e.stack : (e.message ? e.message : e)));
	var error, msg = resourceId ? _getRsrc(resourceId) : e.message,
		diag;
	if (e instanceof CvgException) {
		error = e;
		if (error.diagnose.message) {
			error.diagnose.message += "\n" + msg;
		} else {
			error.diagnose.message = msg;
		}
	} else {
		if (e && e.$diagnoses && e.$diagnoses.length > 0) {
			// Diagnoses from peer
			error = new CvgException(client, e.message, msg);
			error.diagnose.$diagnoses = e.$diagnoses;
		} else {
			error = new CvgException(client, e, msg);
		}
	}
	return error;
}

function _sendResponse(_, context, statusCode, data, headers) {
	headers = headers || {};
	headers["content-type"] = "application/json";
	context.response.writeHead(statusCode, headers);
	context.response.write(_, JSON.stringify(data), 'utf8');
	context.response.end();
}

//-------------------------------------------------------
// No current settings - localCtrl/localFormat have been remove - we keep this code just in case we add new settings
var _cliSettingsDef = {};





function _readClientSettings(_, body) {
	try {
		if (body.length !== 0) {
			body = JSON.parse(body);
			if (body.settings) {
				var p;
				for (p in _cliSettingsDef) {
					if (body.settings[p] == null) {
						body.settings[p] = _cliSettingsDef[p];
					}
				}
				return body.settings;
			}
		}
	} catch (e) {}
	return _cliSettingsDef;
}

function _isFunctionRuntimeMain(functionName) {
	return functionName && mainFunctions && mainFunctions.indexOf(functionName) !== -1;
}
//-------------------------------------------------------
var CvgSession = helpers.defineClass(function _cvgSession(fsid) {
	tracerSession.info && tracerSession.info("New cvgSession - " + fsid);
	this.sessionUrl = "";
	this.sid = fsid;
	this.creationDate = datetime.now();
	//Set by session.updateCvgSession
	this.lastAccess = datetime.now();
	this._trackers = {};
}, null, {
	connect: function(_, context, config) {

		function getOfflinePlayer(_, fileName) {
			// read fileName and parse as JSON and then create an offlineplayer
			var _defDataDir = upath.join(process.mainModule.filename.substring(0, process.mainModule.filename.indexOf("index.js")), "node_modules/syracuse-x3/lib/convergence/data/cvgRecords/");
			return new OfflinePlayer(JSON.parse(fs.readFile(_defDataDir + "/" + fileName)));
		}

		tracerSession.info && tracerSession.info("Direct Fusion Connect");
		// console.log(util.inspect(context));
		var self = this;
		var lic = check.getParsedLicense(_);
		if (lic && !lic.namedUsers) {
			throw locale.format(module, "tooManyBadges");
		}
		var httpSession = context.httpSession;
		this.syraid = httpSession.id;
		var endpoint = context.endpoint;
		var x3solution = endpoint.x3solution(_);
		var userProfile = httpSession.getUserProfile(_);
		this.syralogin = userProfile.user(_).login(_);

		var runtimeConfig = (httpSession.x3SessionConfig && httpSession.x3SessionConfig.runtime) || {};
		var remoteAddr = context.request.connection.remoteAddress;
		var referer = context.request.headers.referer;
		this.sessInfo = {
			remoteAddress: remoteAddr && remoteAddr.length > 0 ? remoteAddr : "unknown",
			httpReferer: referer && referer.length > 0 ? url.parse(referer).host : "unknown",
			x3Func: context.parameters.f.split('/')[0],
			serverUrl: ((context.request.context && context.request.context.url) || "").split("/").slice(0, 3).join("/")
		};
		// We need to store string to pass to recorder
		var requestBody = (context.request.readAll(_) || "").trim();
		var reuseTimeout = cvghelpers.config("x3fusion.reuseTimeout", null, 20 * 60 * 1000);

		var cliCfg = {
			x3User: userProfile && userProfile.user(_) && userProfile.user(_).getEndpointLogin(_, endpoint.$uuid),
			//			x3Host: x3server.serverHost(_),
			//			x3Port: x3server.serverPort(_),
			x3Lang: locale.current,
			x3HttpPub: endpoint.getWebServerBaseUrl(_),
			x3Folder: endpoint.x3ServerFolder(_),
			x3Solution: endpoint.getSolutionName(_),
			timeoutReuse: (reuseTimeout < 1000 ? reuseTimeout * 60 * 1000 : reuseTimeout),
			printConfig: cvghelpers.config("x3print"),
			appHost: x3solution.serverHost(_),
			endpointUuid: endpoint.$uuid // needed for historical folder
		};
		// Record exchanges - REC or PLAY
		cliCfg.recmode = context.parameters ? _recModes[_recModes.indexOf(context.parameters.recmode)] : null;
		// Add Syracuse preferences - dateOrder, thousandSep....
		cvghelpers.addLocaleConfig(_, cliCfg, userProfile);
		// Check mandatory values
		var p, err = null;
		for (p in cliCfg) {
			if (p.indexOf("x3") === 0 && (cliCfg[p] == null || cliCfg[p].toString().trim().length === 0)) {
				err += (err ? ", " : "") + p;
			}
		}
		if (err) {
			throw new Error("Bad administration configuration.\nFollowing parameter(s) are mandatory[" + err + "]");
		}
		var reuseClient = null;
		// Force !reuse if cliCfg.recmode = record or play
		if (cliCfg.recmode == null) {
			// check if the reuseClient is connected to the main server else we have to use new client
			reuseClient = cvgListReuse.getClient(_, context, cliCfg); //TODO change get client to retrieve directly a client on main server if we launch a functionMain server
		}
		var data = {}, statusCode = 200,
			response = null;
		try {
			// Records data exchanged between cvgCli and x3/uiCli
			var recorder = null;
			var isActivateRLog = runtimeConfig.runtimeLog && !runtimeConfig.dataset || endpoint.dataset(_) === runtimeConfig.dataset;

			tracerSession.info && tracerSession.info("reuse not null " + (reuseClient !== null));
			var isMainFunction = _isFunctionRuntimeMain(this.sessInfo.x3Func);
			tracerSession.info && tracerSession.info("reuse isFunction main " + isMainFunction);

			var isMain = reuseClient && x3solution.isMainRuntime(_, reuseClient.initConfig.x3Host, reuseClient.initConfig.x3Port);
			if (reuseClient && isMainFunction && !isMain) {
				tracerSession.info && tracerSession.info("reuse isRuntime main " + isMain);
				// readd the client in the reuse list
				cvgListReuse.addReuse(_, reuseClient, reuseClient.sessionInfo, this.syraid, "not matched - need main server");
				reuseClient = null;
			}



			if (!reuseClient || isActivateRLog) {
				// readd reuse in reuseL

				// player fakes x3client - returned recorded data
				var player = cliCfg.recmode == "PLAY" ? (context.parameters.onlyx3 ? getOfflinePlayer(_, context.parameters.recfile) : recordMgr.getPlayer(context.parameters.recfile)) : null;
				if (player == null) {
					tracerSession.info && tracerSession.info("Create new client.");
					//

					this.client = x3client.create({
						x3solution: x3solution,
						x3serverTags: isMainFunction ? "MAIN" : userProfile.getX3ServerTags(_), // force main server if current function in for main
						tracer: tracerSession
					});
					var _x3 = this.client.connect(_, {
						server: x3solution.serverHost(_),
						folder: cliCfg.x3Folder,
						fusion: true,
						locale: locale.current,
						runtimeLog: !runtimeConfig.dataset || endpoint.dataset(_) === runtimeConfig.dataset ? runtimeConfig.logFlag : "",
						runtimeLogDir: !runtimeConfig.dataset || endpoint.dataset(_) === runtimeConfig.dataset ? runtimeConfig.logDir : ""

					});
					cliCfg.useProxy = x3solution.proxy(_);
					// use x3server instance selected by x3 client
					cliCfg.x3Host = this.client.x3server.serverHost(_);
					cliCfg.x3Port = this.client.x3server.serverPort(_);
					cliCfg.x3Pid = "" + _x3.pid;
					cliCfg.x3SessionUrl = _x3.sessionUrl;
					cliCfg.x3SessionId = _x3.sessionId;
					tracerSession.info && tracerSession.info("Connected...");
					tracerSession.info && tracerSession.info("Create session [username: " + cliCfg.x3User + "]");
					tracerSession.info && tracerSession.info("session context fct  [" + context.parameters.f + "]");

					var adminEP = adminHelper.getCollaborationEndpoint(_);
					var sysAuthToken;
					if (userProfile) {
						var u = userProfile.user(_);
						if (u && u.infov6(_)) {
							sysAuthToken = new Buffer(u.userv6(_) + ":" + u.passwordv6(_), "utf8").toString("base64");
						}
					}
					var sid = this.client.createSession(_, {
						locale: locale.current,
						userName: cliCfg.x3User,
						adxtyp: httpSession.getData("adxtyp") || 25,
						sysAuthToken: sysAuthToken,
						fusionTech: {
							protocol: "150067",
							wkf: context.parameters.f
						},
						localePreferences: userProfile.selectedLocale(_),
						baseUrl: context.baseUrl,
						collaborationBaseUrl: adminEP ? context.request.session.host + adminHelper.getCollaborationEndpoint(_).getBaseUrl(_) : "",
						peerAddress: (httpSession.getData("requestInfo") || {}).peerAddress
					});
					// If enabled records data exchange for replay
					if (cliCfg.recmode == "REC") {
						var opts = {
							fileName: context.parameters.recfile,
							overwrite: false,
							x3Func: this.sessInfo.x3Func,
							endpoint: {
								application: context.applicationName,
								contract: context.contractName,
								dataset: endpoint.dataset(_)
							},
							cliCfg: {}
						};
						recorder = recordMgr.newRecorder(_, this.client.getStream(), opts, cliCfg);
						if (context.parameters.reconlyx3) {
							recorder.onlyx3 = true;
						}
					}
					tracerSession.info && tracerSession.info("Session ID: " + this.sid);
				} else {
					tracerSession.info && tracerSession.info("cvgSession.connect - Mode PLAY  - No x3 connection");
					// Set cliCfg with data stored during recording
					// Player will run with same x3User and Syra preferences as recored ones independently of cuurent user profile
					player.restoreClientConfig(cliCfg);
				}
				this._cvgClient = new CvgClient().init(_, this, (player ? player : this.client.getStream()), cliCfg, recorder, context);
				this._cvgClient.activateRuntimeLog = runtimeConfig.runtimeLog;

				this._doAsync(_, context, 'connect', requestBody);
			} else {

				self.sessionInfo = reuseClient.sessionInfo;
				tracerSession.info && tracerSession.info("Reuse found ! - id=" + reuseClient.uuid);
				reuseClient.setInReuseMode(_, false);
				self.sessionInfo.reused(_, false);

				this._cvgClient = reuseClient;
				tracerSession.info && tracerSession.info("Retrieve existing client.");
				this._cvgClient.setCvgSession(this);
				this._cvgClient.isReuse = false;
				this._doAsync(_, context, 'reuse', requestBody);
			}
			if (requestBody) {
				var sett = JSON.parse(requestBody);
				this._cvgClient.srvTrace = sett && sett.settings && sett.settings.srvTrace ? sett.settings.srvTrace : null;
			}
			this.cvgUpdateSessionInfo(_);
			return {
				sid: this.sid,
				headers: {
					"content-type": "application/json"
				},
				body: response
			};
		} catch (e) {
			throw _getErrDiagnose(e, this._cvgClient, this._cvgClient && this._cvgClient.clientConfig.modePLAY ? null : "connectionFailed");
		}
	},

	destroyReuseClient: function(_, cvgClient) {
		cvgListReuse.destroyReuseClient(_, cvgClient, this.syraid);
	},


	// Asynchronous call to X3 processes
	_doAsync: function(_, context, connectAct, bodyStr) {
		var self = this,
			data = null,
			tracker = null,
			excep = null,
			trackId = context.parameters.trackngId || "",
			trackAct = null;

		var observer;
		if (context.observer && context.observer === "plugin") {
			var id = "default"; // id by default for upload , use the last ilog plugin
			if (bodyStr) {
				id = JSON.parse(bodyStr);
				id = id && id.param && id.param.plugin && id.param.plugin.id;
			}
			// get id of plugin and retrive the right plugin observer // assign in the same time plugin with the correct id
			if (id) {
				observer = self._cvgClient.cvgPlugin["ilog-" + id] = self._cvgClient.cvgPlugin["ilog-" + id] || self._cvgClient.cvgPlugin["ilog-default"];
				if (id !== "default")
					observer.id = id;
			} else {
				observer = self._cvgClient.cvgPlugin["ilog-default"];
			}
		} else {
			// default one is the client
			observer = self._cvgClient;
		}
		//

		if (trackId.length > 0) {
			// 'trackngId' parameters means start tracking
			trackAct = "START";
		} else {
			// '$trackers' parameters means track an existing tracker
			trackId = context.parameters.$trackers || "";
			if (trackId.length > 0) {
				trackAct = "TRACK";
			}
		}
		// will be done by the syracuse session in checkInterval
		// self.cvgUpdateSessionInfo(_);
		if (trackAct == null) {
			if (self._cvgClient.recorder && !context.parameters.onlyx3) {
				self._cvgClient.recorder.dumpHttpReq(_, context, bodyStr);
			}
			// execute request in synchronous mode

			if ('connect' === connectAct) { // connection mode
				self._cvgClient.connectStart(_, context);
				context.reply(_, 200, self._cvgClient.generateResponse(_, true), self._cvgClient.response.head);
			} else if ('reuse' === connectAct) { // reuse mode
				self._cvgClient.execOpenFunction(_, context);
				context.reply(_, 200, self._cvgClient.generateResponse(_, true), self._cvgClient.response.head);
			} else if ('requestSvc' === connectAct) {
				self._cvgClient.processRequest(_, context, bodyStr);
				context.reply(_, 200, self._cvgClient.generateResponse(_, false), self._cvgClient.response.head);
			} else if ('blobSvc' === connectAct) {
				observer.services.blobSvc.processRequest(_, context, bodyStr);
			}

			if (self._cvgClient.recorder && !context.parameters.onlyx3) {
				self._cvgClient.recorder.dumpHttpResp(_, data.body);
			}
		} else {
			try {
				if (trackAct == "START") {
					// Start tracking request
					self._trackers[context.observer] = self._trackers[context.observer] || {};
					if (self._trackers[context.observer][trackId]) { // tracker is prefix by observer to allow to use the same id for plugin
						throw new Error("Tracker already exist. trackId[" + trackId + "]");
					}
					tracker = self._trackers[context.observer][trackId] = new ConvTracker(context, trackId, observer, connectAct === "reuse" || connectAct === "connect");
					data = null;
					var statusCode = 500;
					try {
						// function that stop tracker and write response in normal case

						if (self._cvgClient.recorder && !self._cvgClient.onlyx3) {
							self._cvgClient.recorder.dumpHttpReq(_, context, bodyStr);
						}
						// if we are in orhestration mode the asyncWait must be less that less 1 second
						var asyncWait = _asynchWait;
						if (Object.keys(self._cvgClient.cvgPlugin).length > 0)
							asyncWait = 500;
						tracker.start(_, context, asyncWait);
						// console.log("\tprocessRequest.begin");

						if (connectAct === 'connect') {
							self._cvgClient.connectStart(_, context, tracker);
						} else if (connectAct === 'reuse') {
							self._cvgClient.execOpenFunction(_, context, tracker);
						} else if (connectAct === 'requestSvc') {
							observer.processRequest(_, context, bodyStr, tracker); // process the rquest of the client or other observer link the client
						} else if (connectAct === 'blobSvc') {
							observer.services.blobSvc.processRequest(_, context, bodyStr, tracker);
						}


					} catch (e) {
						statusCode = 500;
						console.error(e.stack);
						var body = e.toJSON ? e.diagnose.toJSON() : _getErrDiagnose(e, this._cvgClient, "connectionFailed").diagnose.toJSON();
						data = {
							head: {},
							body: body
						};
						//console.log("\tprocessRequest.end "+statusCode+" data "+JSON.stringify(data));
						tracker.stop(_, context, data, statusCode); // tracker in the case of no excpetion is closed
						if (statusCode == 200 && self._cvgClient.recorder && !self._cvgClient.onlyx3) {
							self._cvgClient.recorder.dumpHttpResp(_, data.body);
						}
						// delete session in case of failure
						context.httpSession.closeCvgSession(self.sid, context.parameters, "Closed by server (failed connection)", _);

						//self.close(_,{}, "connection failed");
					}
				} else {
					// trackAct == "TRACK"
					// Pooling tracking request
					trackId = context.parameters.$trackers;

					switch (context.method) {
						case 'get':
							tracker = self._trackers[context.observer][trackId];
							if (!tracker) {
								return context.reply(_, 404, "tracker not found: " + trackId);
							}
							tracker.track(_, context.response);
							break;
						case 'delete':
							delete self._trackers[context.observer][trackId];
							context.reply(_, 204);
							break;
						default:
							throw new Error("_doAsynch.track - Bad method: " + context.method);
					}
				}
			} catch (e) {
				console.log("cvgSession._doAsync - ERROR " + (e.stack ? e.stack : e));
				excep = e;
				var exp = e.toJSON ? e : new CvgException(self[observer], e, "");
				//context.reply(_,500 , body,{});
				throw exp;

			} finally {
				// Clear trackers list
				if (excep != null || (tracker && tracker.isFlushed())) {
					// console.log("cvgSession._doAsync - Clear tracker " + trackId)
					if (tracker) {
						tracker.destroy(_);
					}
					delete self._trackers[context.observer][trackId];
				}
			}
		}
	},

	proxy: function(_, context, config) {
		try {
			// Read requestbody - only one call to readAll is allowed
			var bodyStr;
			var svc = context.segments[context.segments.length - 1];
			switch (svc) {
				case 'requestSvc':
					bodyStr = context.request.readAll(_) || "{}";
					this._doAsync(_, context, "requestSvc", bodyStr);
					break;
				case 'blobSvc':
					this._doAsync(_, context, "blobSvc", bodyStr);
					//this._cvgClient.services.blobSvc.processRequest(_, context, bodyStr);
					break;
				default:
					// connection case
					bodyStr = context.request.readAll(_) || "{}";
					this._doAsync(_, context, "requestSvc", bodyStr);
					//throw new Error("invalid convergence service: " + svc);
			}
		} catch (e) {
			_sendResponse(_, context, 500, _getErrDiagnose(e, this._cvgClient, "proxyFailed").diagnose.toJSON());
		}
	},

	/*
	 close all reuse client that are assoiciate to that http session
	 */

	close: function(_, params, reason) {
		tracerSession.info && tracerSession.info("Close session [reuse:" + (params.reuse === true) + "] : " + this.sid);
		try {
			if (params.reuse && !this._cvgClient.activateRuntimeLog) {
				// store CvgClient in reuse list
				var self = this;
				self.sessionInfo.reused(_, true);
				self.cvgUpdateSessionInfo(_);
				cvgListReuse.addReuse(_, self._cvgClient, self.sessionInfo, this.syraid, reason);

			} else if (this._cvgClient) {
				var self = this;
				flows.setTimeout(function(_) {
					self._cvgClient.disconnectClient(_, params, reason || "logout");
					self.sessionInfo.deleteSelf(_, {
						ignoreRestrictions: true
					});

				}, 1); //ghost session deconnect can blocked if a action is in progress. To prevent blocking of logout we delay the close
			} else {
				tracerSession.info && tracerSession.info("\tNo cvgClient");
			}
			// purge async tracker in any case
			this._trackers = {};
		} catch (e) {
			console.log("Convergence session close failed");
			console.log(e.stack ? e.stack : e.message ? e.message : e);
		}
	},

	cvgUpdateSessionInfo: function(_) {
		var session = this;
		if (session.ignoreStoreSession) {
			return null;
		}
		//		if (!session.updateFunnel) {
		//			session.updateFunnel = flows.funnel(1);
		//		}
		//		return session.updateFunnel(_, function(_) {
		//_tracer && _tracer("cvgSession.updateSessionInfo at " + new Date());
		// store or update session
		var cvgSessionInfo = session.sessionInfo;
		if (!cvgSessionInfo) {
			var db = adminHelper.getCollaborationOrm(_);
			//
			var factory = db.model.getEntity(_, "cvgSession").factory;
			cvgSessionInfo = factory.createInstance(_, null, db);
			var res = session.cvgAdmSessInfo(_);
			cvgSessionInfo.sid(_, res.sid);
			cvgSessionInfo.syralogin(_, res.syralogin);
			cvgSessionInfo.syraid(_, res.syraid);
			cvgSessionInfo.remoteaddr(_, res.remoteaddr);
			cvgSessionInfo.creationDate(_, res.creationDate);
			cvgSessionInfo.lastAccess(_, res.lastAccess);
			cvgSessionInfo.httpreferer(_, res.httpreferer);
			// add cli info
			cvgSessionInfo.cid(_, res.cid);
			cvgSessionInfo.x3host(_, res.x3host);
			cvgSessionInfo.x3port(_, res.x3port);
			cvgSessionInfo.x3solution(_, res.x3solution);
			cvgSessionInfo.x3folder(_, res.x3folder);
			cvgSessionInfo.x3pid(_, res.x3pid);
			cvgSessionInfo.x3user(_, res.x3user);
			cvgSessionInfo.x3lang(_, res.x3lang);
			cvgSessionInfo.open(_, res.open);
			//
			session.sessionInfo = cvgSessionInfo;
		} else if (cvgSessionInfo.lastAccess(_).equals(session.lastAccess)) {
			return null;
		}
		cvgSessionInfo.lastAccess(_, session.lastAccess);
		return cvgSessionInfo.save(_, null, {
			shallowSerialize: true,
			ignoreRestrictions: true,
			clearDiagnoses: true
		});

	},

	// FDB - Return cvgSession entity data
	cvgAdmSessInfo: function(_) {
		var res = {};
		res.sid = this.sid;
		res.syraid = this.syraid;
		res.syralogin = this.syralogin;

		res.creationDate = this.creationDate;
		res.lastAccess = this.lastAccess;
		res.remoteaddr = this.sessInfo && this.sessInfo.remoteAddress;
		res.httpreferer = this.sessInfo && this.sessInfo.httpReferer;
		res.x3func = this.sessInfo && this.sessInfo.x3Func;
		var cli = this._cvgClient;
		cli && cvgListReuse.cvgAdmAddCliInfo(cli, res);
		res.reused = cli && cli.reused;
		return res;
	}
});
//

// Time to wait before sending the first tracking reply to client
var _asynchWait = cvghelpers.config("x3fusion.tracker.maxTimeBeforeSend", null, 4000);

exports.newSession = function(_, fsid) {
	return new CvgSession(fsid);
};