"use strict";

var convAsync = require("syracuse-x3/lib/convergence/convAsync");
var locale = require("syracuse-core/lib/locale");
var helpers = require("syracuse-core/lib/helpers");
var datetime = require("syracuse-core/lib/types/datetime");
var streams = require("streamline/lib/streams/streams");
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var cvghelpers = require("./helpers");
var util = require("util");
var url = require('url');
var check = require("syracuse-license/lib/check");
var x3client = require('syracuse-x3/lib/client');
var CvgClient = require("syracuse-x3/lib/convergence/client/CvgClient").CvgClient;
var CvgException = require("syracuse-x3/lib/convergence/model/CvgException").CvgException;
var recordMgr = require("syracuse-x3/lib/convergence/records/recordMgr").recordMgr;

var _tracer = cvghelpers.config("x3fusion.sessions.trace");
var _listReuse = [];
var _recModes=["REC","PLAY"];

function _cvgSession(fsid) {
	_tracer && _tracer("New cvgSession - " + fsid);
	this.sessionUrl = "";
	this.sid = fsid;
	this.creationDate=datetime.now();
	//Set by session.updateCvgSession
	this.lastAccess=0;
}

function _getRsrc() {
	try {
		var args = [module];
		for (var i in arguments) {
			args.push(arguments[i]);
		}
		return locale.format.apply(locale, args);
	} catch (e) {
		return "Resource not found [" + arguments[0] + "]";
	}
}

function _getErrDiagnose(e, client, resourceId) {
	if (e) console.error("cvgSession Error: " + (e.stack ? "\n" + e.stack : (e.message ? e.message : e)));
	var error, msg = resourceId ? _getRsrc(resourceId) : e.message;
	if (e instanceof CvgException) {
		error = e;
		if (error.diagnose.message) 
			error.diagnose.message += "\n" + msg;
		else error.diagnose.message = msg;
	} else error = new CvgException(client, e, msg);
	return error.diagnose;
}

function _sendResponse(_, context, statusCode, data, headers) {
	var headers = headers || {};
	headers["content-type"] = "application/json";
	context.response.writeHead(statusCode, headers);
	context.response.write(_, JSON.stringify(data), 'utf8');
	context.response.end();	
}

//-------------------------------------------------------
// No current settings - localCtrl/localFormat have been remove - we keep this code just in case we add new settings
var _cliSettingsDef={};
function _readClientSettings(_, body){
	try{
		if (body.length!=0){
			body=JSON.parse(body);
			if (body.settings){
				for (var p in _cliSettingsDef){
					if(body.settings[p]==null) body.settings[p]=_cliSettingsDef[p]
				}
				return body.settings;
			} 
		}
	}catch(e){}
	return _cliSettingsDef;
}
//-------------------------------------------------------
var _sessionProto = _cvgSession.prototype;
//
_sessionProto.connect = function(_, context, config) {
	_tracer && _tracer("Direct Fusion Connect");
	// console.log(util.inspect(context));
	var lic = check.getParsedLicense(_);
	if (lic && !lic.namedUsers) throw locale.format(module, "tooManyBadges");
	var endpoint = context.endpoint;
	var x3server = endpoint.x3server(_);
	var userProfile = context.httpSession.getUserProfile(_);
	var remoteAddr=context.request.connection.remoteAddress;
	var referer=context.request.headers["referer"];
	this.sessInfo={
		remoteAddress: remoteAddr && remoteAddr.length>0 ? remoteAddr : "unknown",
	    httpReferer: referer && referer.length>0 ? url.parse(referer).host : "unknown",
		x3Func: context.parameters.f.split('/')[0]
	}
	// We need to store string to pass to recorder
	var requestBody=(context.request.readAll(_) || "").trim();
	var cliCfg = {
		x3User : userProfile && userProfile.user(_) && userProfile.user(_).getEndpointLogin(_, endpoint.$uuid),
		x3Host : x3server.serverHost(_),
		x3Port : x3server.serverPort(_),
		x3Lang : locale.current,
		x3HttpPub : endpoint.getApplicationServerBaseUrl(_),
		x3Folder : endpoint.x3ServerFolder(_),
		x3Solution :  endpoint.x3SolutionName(_),
		timeoutReuse : cvghelpers.config("x3fusion.reuseTimeout", null, 120000),
		printSrv : cvghelpers.config("x3print.server")
	}
	// Add Syracuse preferences - dateOrder, thousandSep....
	cvghelpers.addLocaleConfig(_, cliCfg, userProfile);
	// Check mandatory values
	var err=null;
	for (var p in cliCfg){
		if (p.indexOf("x3")==0 && (cliCfg[p]==null || cliCfg[p].toString().trim().length==0)) err += (err?", " : "") + p;
	}
	if (err) throw new Error ("Bad administration configuration.\nFollowing parameter(s) are mandatory["+err+"]")
	var reuseClient = null;
	_tracer && _tracer("Create session [Nb reuse: "+_listReuse.length+"]");
	if (_listReuse && _listReuse.length !== 0) {
		_tracer && _tracer("Search reuse...");
		var i=0;
		for(i=0; i < _listReuse.length && reuseClient == null ;i++){
			reuseClient = _listReuse[i].isSameContext(cliCfg) ? reuseClient = _listReuse[i] : reuseClient = null;
		}
		// remove client from reuse list
		if(reuseClient){
			_tracer && _tracer("Reuse found ! - id=" + reuseClient.uuid);
			reuseClient.setInReuseMode(_,false);
			_listReuse.splice(i-1,1);
			_tracer && _tracer("\t _listReuse.length"+_listReuse.length+"]");
		}else{
			_tracer && _tracer("Reuse not found !");
		}
	}
	var data = {}, statusCode = 200, response =null;
	try {			
		// Record exchanges - REC or PLAY
		cliCfg.recmode =_recModes[_recModes.indexOf(context.parameters.recmode)];
		// Records data exchangeed between cvgCli and x3/uiCli
		var recorder =null;
		// Force !reuse if cliCfg.recmode - mode record or play
		if (!reuseClient || cliCfg.recmode){
			// player fakes x3client - returned recorded data 
			var player = cliCfg.recmode == "PLAY" ? player = recordMgr.getPlayer(context.parameters.recfile, true) : null;
			if (player == null){
				_tracer && _tracer("Create new client.");			
				var client = x3client.create({
					port: cliCfg.x3Port,
					address: cliCfg.x3Host,
					_tracer : _tracer,
				});
				var _x3=client.connect(_, {
					server: x3server.serverName(_),
					folder: cliCfg.x3Folder,
					fusion: true,
					locale: locale.current,
				});
				cliCfg.x3Pid = "" + _x3.pid;
				cliCfg.x3SessionUrl = _x3.sessionUrl;
				cliCfg.x3SessionId = _x3.sessionId;
				_tracer && _tracer("Connected...");
				_tracer && _tracer("Create session [username: "+cliCfg.x3User+"]");
				var sid = client.createSession(_, {
					locale: locale.current,
					userName: cliCfg.x3User,
					adxtyp: 25,
					fusionTech: {
						protocol: "150067",
						wkf: context.parameters.f
					},	
				});
				// If enabled records data exchange for replay 
				if (cliCfg.recmode == "REC"){
					recorder = recordMgr.newRecorder(_, client.getStream(),{fileName:context.parameters.recfile,overwrite:false,x3func:context.parameters.f});
					recorder.dumpHttpReq(_, context, requestBody);
				}
				_tracer && _tracer("Session ID: " + this.sid);
			}else{
				_tracer && _tracer("cvgSession.connect - Mode PLAY  - No x3 connection");
			}
			this._cvgClient = new CvgClient(_, this, player ? player : client.getStream(), cliCfg, recorder);
			response = this._cvgClient.connectSart(_);
		}else{
			this._cvgClient = reuseClient;
			_tracer && _tracer("Retrieve existing client.");
			this._cvgClient.isReuse=false;
			response = this._cvgClient.execOpenFunction(_,context.parameters.f);
		}
		if (recorder){			
			recorder.dumpHttpResp(_, response);		
		}
		return {
			sid: this.sid,
			headers: {
				"content-type": "application/json",
			},
			body: response,
		};
	} catch(e){
		// we set location in order to let client to retreive cvgSessionId even if error
		_sendResponse(_, context, 500, _getErrDiagnose(e, this._cvgClient, "connectionFailed"),{
				location : context.baseUrl +  "/$sessions('" + this.sid + "')"
		});
	}
}

_sessionProto.destroyReuseClient = function(_, cvgClient){
	_tracer && _tracer("destroyReuseClient - nbReused:" + _listReuse.length + " - id:" + cvgClient.uuid);
	var found = false;
	var i=0;
	for(;i<_listReuse.length && !found ;i++){
		found=_listReuse[i].uuid === cvgClient.uuid;
	}	 
	if (found){
		_listReuse.splice(i-1,1);
		_tracer && _tracer("\treused client found - nbReused:" + _listReuse.length);
		// FDB - disconnected only if found ??
		cvgClient.deconnectClient(_,"timeout reuse");
	}else{
		_tracer && _tracer("\treused client not found");
	}
}

_sessionProto.processRequest = function(_, context) {
	var data = null, statusCode = 500;
	try{
		data = this._cvgClient.processRequest(_, context);
		statusCode = 200;
	}catch(e){
		data = _getErrDiagnose(e, this._cvgClient);	
	}
	_sendResponse(_, context, statusCode, data);
}

var _requestMap = {
    trackers: function(_, context, id) {
        return convAsync.track(_, context, id);
    }
}

function _exec(_,context){
	return context.tracker.caller.processRequest(_,context);
}

function _doAsync(_,context,caller){
	var id = context.parameters.trackngId ;
	if (id && id!=="") { // tracking is passed as query string parameter
		// add in context step and maxtime
		var tracker = convAsync.create(context,_exec);
		tracker.location = context.path+"?$trackers=" + tracker.trackngId + "";
		tracker.convStep = 30;
		tracker.caller = caller;
		var convMaxTime = cvghelpers.config("x3fusion.tracker.maxTimeBeforeSend", null, 4000);
		tracker.maxtry = convMaxTime/tracker.convStep;
		tracker.nbtry = 0;
		tracker.start(_);
		return tracker;
	}else {
		var id = context.parameters.$trackers;
		if (id && _requestMap["trackers"]) {// call tracker
			return _requestMap["trackers"](_, context,id);
		}
		caller.processRequest(_,context);
	}
}

_sessionProto.proxy = function(_, context, config) {
	try {
		var svc = context.segments[context.segments.length - 1];
		switch (svc) {
			case 'requestSvc':
				_doAsync(_,context,this);
				break;
			case 'blobSvc':
				this._cvgClient.services.blobSvc.processRequest(_, context);
				break;
			default:
				throw new Error("invalid convergence service: " + svc);
		}
	} catch(e) {
		_sendResponse(_, context, 500, _getErrDiagnose(e, this._cvgClient, "proxyFailed"));
	}	
}

_sessionProto.close = function(_, reuse, reason) {
	_tracer && _tracer("Close session [reuse:"+(reuse === true)+"] : "+this.sid);
	try {
		if (reuse){
			// store CvgClient in reuse list
			this._cvgClient.setInReuseMode(_,true);
			_listReuse.push(this._cvgClient);
			_tracer && _tracer("Add reuse session [size: "+_listReuse.length+"] - id=" + this._cvgClient.uuid + " - reason=" + reason);
		}else if (this._cvgClient.stream) {
			this._cvgClient.deconnectClient(_, reason || "logout");
		}
		// purge async tracker in any case 
		sdataAsync.trackers = [];
	} catch (e) {
		console.error("Convergence session close failed");
		console.error(e.stack ? e.stack : e.message ? e.message : e);
	}
}

// FDB - Return cvgSession entity data
_sessionProto.cvgAdmSessInfo = function(_) {
	var res={};
	res.sid=this.sid;
	res.creationDate=this.creationDate;
	res.lastAccess=this.lastAccess;
	res.remoteaddr = this.sessInfo.remoteAddress;
	res.httpreferer = this.sessInfo.httpReferer;
	res.x3func = this.sessInfo.x3Func;
	var cli=this._cvgClient;
	_cvgAdmAddCliInfo(cli,res);	
	res.reused=cli && cli.reused;
	return res;
}
exports.newSession = function(_, fsid) {
	return new _cvgSession(fsid);
}

// Info property mame are the name of cvgReuseClient and cvgSession entity  properties
function _cvgAdmAddCliInfo(cli, info){
	var cfg=cli && cli.clientConfig || {};
	info.cid = cli.uuid;
	info.x3host = cfg.getParam("x3Host");
	info.x3port = "" + cfg.getParam("x3Port");
	info.x3solution = cfg.getParam("x3Solution");
	info.x3folder = cfg.getParam("x3Folder");
	info.x3pid = "" + cfg.getParam("x3Pid");
	info.x3user = cfg.getParam("x3User");
	info.x3lang = cfg.getParam("x3Lang");
	info.open = cli.stream!=null;
	return info;
}
exports.cvgAdmReuseClients=function(_, id){
	var res=[];
	for(var i=0; i<_listReuse.length;i++){
		var cli=_listReuse[i];
		if (id && cli.uuid!=id) continue;
		// Info property mame is the name of cvgReuseClient entity  property
		var cfg = cli.clientConfig;
		var info={
			timeout : "" + Math.floor((new Date().getTime() - cli.timeToReuse)/1000) + "/" + Math.floor(cfg.getParam("timeoutReuse")/1000),
			creationDate : cli.creationDate
		}
		_cvgAdmAddCliInfo(cli,info);
		res.push(info);
		if (id) break;
	}
	return res;
}
exports.cvgAdmReuseKill=function(_,cid){
	_tracer && _tracer("cvgAdmReuseKill - nbReused:" + _listReuse.length + " - id:" + cid);
	var cli = null;
	var i=0;
	for(;i<_listReuse.length && cli==null;i++){
		if (_listReuse[i].uuid === cid) cli = _listReuse[i];
	}	
	if (cli) {
		_listReuse.splice(i-1,1);
		_tracer && _tracer("\treused client found - nbReused:" + _listReuse.length);
		cli.deconnectClient(_,"closed by administrator");	
	}else{
		_tracer && _tracer("\treused client not found");
	}
	return cli!=null;
}
