"use strict";
var helpers = require('syracuse-core/lib/helpers');
var CStructIst = require('syracuse-x3/lib/fusion/CStructIst').CStructIst;
var CStructResu = require('syracuse-x3/lib/fusion/CStructResu').CStructResu;

var originMillis = new Date(1599, 11, 31).getTime();

var X3Reader = exports.X3Reader = helpers.defineClass(function(ctx, wnd, data) {
	this.ctx = ctx;
	this.wnd = wnd;
	this.pos = 0;
	this.data = data;
}, null, {
	peek: function() {
		return this.pos < this.data.length ? this.data[this.pos] : -1;
	},
	nextByte: function(lenient) {
		if (!lenient && this.pos > this.data.length - 1) throw new Error("nextByte");
		return this.pos < this.data.length ? this.data[this.pos++] : 0;
	},
	nextShort: function() {
		if (this.pos > this.data.length - 2) throw new Error("nextShort");
		return this.pos < this.data.length - 1 ? (this.data[this.pos++] << 8) | this.data[this.pos++] : 0;
	},
	nextLong: function() {
		if (this.pos > this.data.length - 4) throw new Error("nextLong");
		return this.pos < this.data.length - 3 ? (this.data[this.pos++] << 24) | (this.data[this.pos++] << 16) //
		|
		(this.data[this.pos++] << 8) | this.data[this.pos++] : 0;
	},
	peekShort: function() {
		var pos = this.pos,
			val = this.nextShort();
		this.pos = pos;
		return val;
	},
	peekLong: function() {
		var pos = this.pos,
			val = this.nextLong();
		this.pos = pos;
		return val;
	},
	nextLongLong: function() {
		return this.pos < this.data.length - 7 ? (this.nextLong() << 32) | this.nextLong() : 0;
	},
	nextIst: function() {
		return this.pos < this.data.length - 5 ? new CStructIst(this.nextLong(), this.nextShort()) : null;
	},
	nextString: function() {
		var len = this.nextShort() - 2; // next short is included in byte count!
		var nchars = this.nextShort();
		var str = this.data.slice(this.pos, this.pos + len).toString('utf8');
		this.pos += len;
		if (str.length < nchars) throw new Error("bad string: expected " + nchars + ", got " + str.length);
		if (str.length > nchars) {
			console.log("!!!! string too long: " + (str.length - nchars) + " extra, ignoring: '" + str.substring(nchars) + "'");
			str = str.substring(0, nchars);
		}
		return str;
	},
	nextBuf: function() {
		var len = this.nextShort();
		//console.log("nextBuf len=" + len + ", pos=" + this.pos + ", data.len=" + this.data.length);
		//console.log(this.data.slice(this.pos));
		var buf = this.data.slice(this.pos, this.pos + len);
		this.pos += len;
		return buf;
	},
	nextClob: function() {
		if (this.pos !== 0) throw new Error("invalid call: pos=" + this.pos);
		var str = this.data.toString('utf8');
		this.pos = this.data.length;
		return str;
	},
	nextProperties: function() {
		var str = this.nextClob();
		return str.split('\n').reduce(function(result, line) {
			if (line) {
				var pair = line.split('=\u0001');
				result[pair[0]] = pair[1];
			}
			return result;
		}, {});
	},
	nextLines: function() {
		var str = this.nextClob();
		if (str[str.length - 1] !== '\n') throw new Error("missing newline");
		return str.substring(0, str.length - 1).split('\n');
	},
	nextExtend: function() {
		// ???
		var len = this.nextLong();
		var data = this.data.slice(this.pos, this.pos + len);
		this.pos += len;
		return data.toString('utf8');
	},
	nextDefs: function() {
		var buf = this.nextBuf();
		//console.log("DEFS: " + buf.toString("hex"));
		var sub = new X3Reader(this.ctx, this.wnd, buf);
		var n = sub.nextByte();
		var defs = [];
		for (var i = 0; i < n; i++) defs.push(sub.nextResu());
		return defs;
	},
	nextBytes: function(len) {
		var buf = this.data.slice(this.pos, this.pos + len);
		this.pos += len;
		return buf;
	},
	nextUnicode: function(len) {
		//console.log("len=" + len)
		// read trailing 0 (and ignore it)
		var bytes = this.nextBytes(2 * (len + 1));
		var s = "";
		for (var i = 0; i < len; i++) s += String.fromCharCode((bytes[2 * i] << 8) | bytes[2 * i + 1]);
		return s;
	},
	nextResu: function() {
		return CStructResu.read(this);
	},
	nextDate3: function() {
		var days = (this.nextShort() << 8) + this.nextByte();
		if (days === 0) return "00000000";
		var millis = originMillis + days * 86400 * 1000;
		var d = new Date(millis);
		return "" + (d.getFullYear() * 10000 + (d.getMonth() + 1) * 100 + d.getDate());
	},
	nextDcb: function() {
		if (this.pos + 17 > this.data.len) throw new Error("dcb overflow");
		var head = this.data[this.pos++];
		// extract exponent and sign
		var neg = head < 128,
			exp = neg ? 2 * (63 - head) : 2 * (head - 192);
		var str = "",
			dot = false;
		// complement negative values to 100
		if (neg) {
			var found = false;
			for (var i = 15; i >= 0; i--) {
				var b = this.data[this.pos + i];
				if (found) this.data[this.pos + i] = 99 - b;
				else if (b) this.data[this.pos + i] = 100 - b, found = true;
			}
			if (!found) return '0';
		}
		// build complete mantissa
		for (var i = 0; i < 16; i++) {
			var b = this.data[this.pos + i];
			str += b < 10 ? '0' + b : b;
		}
		this.pos += 16;
		//console.log("neg=" + neg + ", str1=" + str + ', exp=' + exp);
		// insert decimal point
		if (exp <= 0) {
			while (exp++ < 0) str = '0' + str;
			str = '0.' + str;
			dot = true;
		} else if (exp >= 32) {
			while (exp-- > 32) str += '0';
		} else {
			str = str.substring(0, exp) + '.' + str.substring(exp);
			dot = true;
		}
		//console.log("str2=" + str + ', exp=' + exp)
		// remove leading and trailing zeros
		if (dot) {
			var i = 0;
			while (str[i] === '0' && str[i + 1] !== '.') i++;
			var j = str.length - 1;
			while (str[j] === '0') j--;
			if (str[j] === '.') j--;
			str = str.substring(i, j + 1);
		} else {
			var i = 0;
			while (str[i] === '0' && i < str.length - 1) i++;
			if (i > 0) str = str.substring(i);
		}
		return neg ? '-' + str : str;
	},
	ensure: function(_, ctx, len) {
		var missing = this.pos + len - this.data.length;
		console.log("ensure: " + len + ", missing=" + missing);
		if (missing > 0) this.data = Buffer.concat([this.data, ctx.stream.read(_, missing)]);
	},
});

function test(str, bytes) {
	var reader = new X3Reader(null, null, new Buffer(bytes));
	var dcb = reader.nextDcb();
	if (dcb !== str) throw new Error("dcb test failed: expected " + str + ", got " + dcb);
}

test('0.000003', [0xBE, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
test('-0.000003', [0x41, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
test('2', [0xC1, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
test('-2', [0x3E, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
test('20', [0xC1, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
test('-20', [0x3E, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
test('24.58', [0xC1, 0x18, 0x3A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
test('24.58', [0xC1, 0x18, 0x3A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
test('-24.58', [0x3E, 0x4B, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
test('101010.1', [0xC3, 0x0A, 0x0A, 0x0A, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x000]);
test('-101010.1', [0x3C, 0x59, 0x59, 0x59, 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
test('0', [0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);