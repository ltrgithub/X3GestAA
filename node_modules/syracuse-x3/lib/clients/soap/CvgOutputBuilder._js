"use strict";
var helpers = require('syracuse-core/lib/helpers');
var binaryHelper = require('syracuse-core/lib/binaryHelper');

var CvgOutputBuilder = helpers.defineClass(function(description, lang) {
	this.description = description;
	this.lang = lang;
}, null, {
	findMenuLabel: function(idMenu, resu) {
		var menus = this.description.ADXMEN.MNU;
		if (!Array.isArray(menus)) {
			menus = [menus];
		}
		var found = null;
		for (var i = 0; i < menus.length && !found; i++) {
			var menu = menus[i];

			if (menu.$.NO === idMenu && this.lang) {
				// find right VAL
				var vals = !Array.isArray(menu.VAL) ? [menu.VAL] : menu.VAL;

				for (var j = 0; j < vals.length && !found; j++) {
					if (parseInt(vals[j].$.IND, 10) === parseInt(resu, 10)) {
						found = vals[j].$["C_" + this.lang];
					}
				}
			}
		}
		return found;
	},
	forceDefaultValue: function(type) {
		switch (type) {
			case "Decimal":
			case "Integer":
				return 0;
			default:
				return;
		}
	}
});

exports.CvgOutputBuilderXml = helpers.defineClass(function(description, lang, resultParamMap) {
	CvgOutputBuilder.call(this, description, lang);
	this.resultParamMap = resultParamMap;
	this.currentIdx = 0;
}, CvgOutputBuilder, {

	_createField: function(elt, field, id, force) {
		var _p, _params = this.resultParamMap[this.currentIdx] && this.resultParamMap[this.currentIdx];
		if (_params) {
			if (field.$.DIM > 1 && field.$.MEN) {
				elt.LST = elt.LST || [];
				var _lst = {
					$: {
						MENULOCAL: field.$.MEN,
						NAME: field.$.NAM,
						SIZE: field.$.DIM,
						TYPE: field.$.TYP
					}
				};
				for (var i = 0; i < field.$.DIM; i++) {
					_p = _params[i];
					_lst.ITM = _lst.ITM || [];
					if (_p && _p.resu) {
						var _itm = {
							$: {
								MENULAB: this.findMenuLabel(field.$.MEN, _p.resu)
							},
							$value: _p.resu
						};
						_lst.ITM.push(_itm);
					}
				}
				if (_lst.ITM && _lst.ITM.length > 0) elt.LST.push(_lst);
			} else {
				_p = _params[id || 0];
				elt.FLD = elt.FLD || [];
				var _fld = {
					$: {}
				};
				if (_p && _p.resu) {
					if (field.$.TYP === "Blob") {
						var buf = new Buffer(_p.resu, "hex");
						_fld.$.BYTES = buf.length;
						_fld.$.MIMETYPE = binaryHelper.calcMimeType(buf);
						_fld.$value = buf.toString('base64');
					} else {
						_fld.$value = _p.resu;
					}
					// Menu set only if a resu is available
					if (field.$.MEN) {
						_fld.$.MENULAB = this.findMenuLabel(field.$.MEN, _p.resu);
						_fld.$.MENULOCAL = field.$.MEN;
					}
					// Keep attributes order
					_fld.$.NAME = field.$.NAM;
					_fld.$.TYPE = field.$.TYP;
					//
					elt.FLD.push(_fld);
				}
				// force default value for table line without resu (if it's not a menu)
				else if (!force || (force && !field.$.MEN)) {
					var _def = this.forceDefaultValue(field.$.TYP);
					if (_def != null) {
						_fld.$value = _def;
					}
					// Keep attributes order
					_fld.$.NAME = field.$.NAM;
					_fld.$.TYPE = field.$.TYP;
					//
					elt.FLD.push(_fld);
				}
			}
		}
	},

	_createGroup: function(elt, grp) {
		var self = this;
		elt.GRP = elt.GRP || [];
		var _grp = ({
			$: {
				ID: grp.$.NAM
			}
		});
		var flds = Array.isArray(grp.FLD) ? grp.FLD : [grp.FLD];
		flds.forEach(function(_fld) {
			self._createField(_grp, _fld);
			self.currentIdx++;
		});
		if ((_grp.FLD && _grp.FLD.length > 0) || (_grp.LST && _grp.LST.length > 0)) elt.GRP.push(_grp);
	},

	_createLine: function(elt, num, flds) {
		var self = this;
		elt.LIN = elt.LIN || [];
		var _lin = {
			$: {
				NUM: num + 1
			}
		};
		flds.forEach(function(_fld) {
			// force field even if resu is null
			self._createField(_lin, _fld, num, true);
			self.currentIdx++;
		});
		if ((_lin.FLD && _lin.FLD.length > 0) || (_lin.LST && _lin.LST.length > 0)) elt.LIN.push(_lin);
	},

	_createTable: function(elt, grp) {
		elt.TAB = elt.TAB || [];
		// Get size param
		var size = this.resultParamMap[this.currentIdx] && this.resultParamMap[this.currentIdx][0].resu || 0;
		this.currentIdx++;
		//
		var _tab = ({
			$: {
				DIM: grp.$.DIM,
				ID: grp.$.NAM,
				SIZE: size
			}
		});
		var flds = Array.isArray(grp.FLD) ? grp.FLD : [grp.FLD];
		for (var i = 0; i < size; i++) {
			this._createLine(_tab, i, flds);
			this.currentIdx -= flds.length;
		}
		//
		if (_tab.LIN && _tab.LIN.length > 0) elt.TAB.push(_tab);
		this.currentIdx += flds.length;
	}
});