"use strict";

var globals = require('streamline-runtime').globals;
var locale = require('syracuse-core').locale;
var helpers = require('syracuse-core').helpers;
var CvgClientAbs = require("syracuse-x3/lib/clients/common/cvg/CvgClientAbs").CvgClientAbs;
var CvgRequestWS = require("syracuse-x3/lib/clients/soap/CvgRequestWS").CvgRequestWS;
var CvgWsException = require("syracuse-x3/lib/clients/soap/CvgWsException").CvgWsException;
var datetime = require('syracuse-core').types.datetime;
var forEachKey = helpers.object.forEachKey;
var OfflinePlayer = require('syracuse-x3/lib/clients/common/offlinePlayer').OfflinePlayer;
var upath = require('path');
var recordMgr = require("syracuse-x3/lib/convergence/records/recordMgr").recordMgr;
var ufs = require('fs');

var x3client = require('syracuse-x3/lib/client');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
//var tracerSession = require('syracuse-core').getTracer("classic.session");
var jsxml = require('js-xml');
var CvgCacheManager = require('syracuse-x3/lib/cvgCacheManager').CvgCacheManager;
var poolManager = require("syracuse-soap/lib/generic/poolManager");
var cacheMgr = new CvgCacheManager();

var tracer = require('syracuse-core').getTracer("soap-generic.ackcall");

var RECUPHDAT = "AWEB:RECUPHDAT";
var CHGLOGINXTEND = "CHGUSR:CHGLOGINXTEND";
var FLUSHADX = "AFLUSHADX:FLUSHADX";

var maxNbTry = 2;

exports.CvgClientWS = helpers.defineClass(function() {
	CvgClientAbs.call(this);
}, CvgClientAbs, {
	init: function(_, context, callContext, recOptions, options) {
		function readJsonPlayer(_, path) {
			var json;
			try {
				json = ufs.readFileSync(path, 'utf8') || "";
				json = json.trim();
				if (json.length === 0) throw new Error("Empty file");
				if (json[json.length - 1] === ',') json = json.substring(0, json.length - 1);
				json = "[" + json + "]";
			} catch (e) {
				throw e;
			}
			try {
				json = JSON.parse(json);
				return json;
			} catch (e) {
				throw e;
			}
			return null;
		}
		context = context || globals.context;
		this.creationDate = datetime.now();
		this.lastAccess = datetime.now();

		// take tags into account to select appropriate server
		this.tags = options && options.tags;

		this.sid = null;
		var configRecords = {};
		if (recOptions && recOptions.path) {
			configRecords = {
				dumpPath: upath.join(process.mainModule.filename.substring(0, process.mainModule.filename.indexOf("node_modules")), recOptions.path)
			};
		}
		this.cliCfg = {};
		this.cliCfg.x3solution = callContext.endpoint.x3solution(_);
		this.useProxy = this.cliCfg.x3solution.proxy(_);
		this._setContextConfig(_, callContext);
		var stream = null;
		this.recOptions = recOptions;
		if (recOptions && recOptions.recMode === 'PLAY') {
			// create player regarding the recOptions
			stream = new OfflinePlayer(_, readJsonPlayer(_, configRecords.dumpPath + "/cvgRecords/" + recOptions.fileName));
			this.recOptions.player = stream;
		} else {
			stream = this._connect(_, context, callContext, recOptions).getStream();
			if (recOptions && recOptions.recMode === 'REC') {
				// create recorder regarding the recOptions
				recOptions.clientType = "WS"; // special recorder to do not record everything
				this.recorder = recordMgr.newRecorder(_, stream, recOptions, {}, configRecords);
				this.recOptions.recorder = this.recorder;
			}
		}
		CvgClientAbs.prototype.init.call(this, stream, this.cliCfg, this.recorder, context);
		this.connectStart(_, context);

		this._checkX3Lang(_, {
			context: context,
			poolInstance: callContext.poolInstance
		});

		this.setFree(callContext);
		return this;
	},
	setFree: function(callContext) {
		// The pool can have been destroyed during the connection
		var pool = poolManager.getPool(this.cliCfg.poolAlias);
		if (pool && !callContext.reserved) {
			pool.free(this);
		}
		callContext.reserved = false;
	},
	setUnavailable: function(_, context) {
		var pool = poolManager.getPool(this.cliCfg.poolAlias);
		if (pool) {
			pool.destroy(_, context, this.pid);
		}
	},
	// Override super
	execAckCall: function(_, subprogName, ackCallParams, wsCall) {
		wsCall.techInfo.poolExecDuration.start();
		var reply;
		try {
			this.lastWsCall = wsCall;
			reply = CvgClientAbs.prototype.execAckCall.call(this, _, subprogName, wsCall.debugInfo, ackCallParams);
		} finally {
			this.lastWsCall = null;
			wsCall.techInfo.poolExecDuration.stop();
		}
		return reply;
	},
	_setContextConfig: function(_, callContext) { // TODO refactor to set that method in super class
		var endpoint = callContext.endpoint;
		this.cliCfg.x3User = callContext.user.getEndpointLogin(_, endpoint.$uuid);

		this.cliCfg.x3Lang = callContext.localePref.code(_);
		this.cliCfg.x3HttpPub = endpoint.getWebServerBaseUrl(_);
		this.cliCfg.x3Folder = endpoint.x3ServerFolder(_);
		this.cliCfg.x3Solution = endpoint.getSolutionName(_);
		this.cliCfg.appHost = endpoint.x3solution(_).serverHost(_);
		this.cliCfg.dataset = endpoint.dataset(_);
		this.cliCfg.poolAlias = callContext.poolAlias;
	},
	_checkX3Lang: function(_, options) {
		var x3lang = this._x3SessionSettings && this._x3SessionSettings.ChangeUserContext && this._x3SessionSettings.ChangeUserContext.split(';')[1];
		var x3langIso = x3lang && locale.defaultIso(x3lang);
		if (x3langIso && this.cliCfg.x3Lang && x3langIso !== this.cliCfg.x3Lang.toLowerCase()) {
			if (options.context) {
				var pool = poolManager.getPool(this.cliCfg.poolAlias);
				if (pool) {
					pool._addTrackerDiagnose(options.context, "warning", locale.format(module, "langReturnedNotMatch", this.cliCfg.x3Lang, x3langIso));
				}
				if (options.poolInstance) {
					var db = adminHelper.getCollaborationOrm(_);
					var locales = db.fetchInstances(_, db.model.getEntity(_, "localePreference"), {
						jsonWhere: {
							code: x3langIso.length === 5 ? x3langIso.substring(0, 3) + x3langIso.substring(3).toUpperCase() : x3langIso
						}
					});
					if (locales && locales[0]) {
						options.poolInstance.localePref(_, locales[0]);
						options.poolInstance.save(_);
					}
				}
			} else if (options.wsCall) {
				options.wsCall.addMessage(2, locale.format(module, "langReturnedNotMatch", this.cliCfg.x3Lang, x3langIso));
			}
			this.cliCfg.x3Lang = x3langIso;
		}
	},
	_connect: function(_, context, callContext, recOptions) {
		var runtimeConfig = (context && context.httpSession && context.httpSession.x3SessionConfig && context.httpSession.x3SessionConfig.runtime) || {};
		var adminEP = adminHelper.getCollaborationEndpoint(_);
		var client = x3client.create({
			x3solution: this.cliCfg.x3solution,
			x3serverTags: this.tags,
		});


		var _x3 = client.connect(_, {
			server: this.cliCfg.appHost,
			folder: this.cliCfg.x3Folder,
			fusion: true,
			locale: this.cliCfg.x3Lang,
			runtimeLog: !runtimeConfig.dataset || this.cliCfg.dataset === runtimeConfig.dataset ? runtimeConfig.logFlag : "",
			runtimeLogDir: !runtimeConfig.dataset || this.cliCfg.dataset === runtimeConfig.dataset ? runtimeConfig.logDir : ""
		});
		this.host = client.x3server.serverHost(_);
		this.port = client.x3server.serverPort(_);

		this.cliCfg.x3Pid = "" + _x3.pid;
		this.pid = this.cliCfg.x3Pid;
		this.cliCfg.x3SessionUrl = _x3.sessionUrl;
		this.cliCfg.x3SessionId = _x3.sessionId;

		var sysAuthToken;
		if (callContext.user && callContext.user.infov6(_)) {
			sysAuthToken = new Buffer(callContext.user.userv6(_) + ":" + callContext.user.passwordv6(_), "utf8").toString("base64");
		}

		var session = context && (context.httpSession || context.session);
		var peer = session && (session.getData("requestInfo") || {}).peerAddress;
		this.sid = client.createSession(_, {
			locale: this.cliCfg.x3Lang,
			userName: this.cliCfg.x3User,
			adxtyp: 20, // adxtyp = 20 for web service session since V9
			sysAuthToken: sysAuthToken,
			fusionTech: {
				protocol: "150067",
			},
			localePreferences: callContext.localePref,
			baseUrl: context && context.baseUrl,
			collaborationBaseUrl: adminEP && session ? session.host + adminHelper.getCollaborationEndpoint(_).getBaseUrl(_) : "",
			peerAddress: peer
		});
		return client;
	},

	disconnectClient: function(_, params, reason, tracker) {

		CvgClientAbs.prototype.disconnectClient.call(this, _, params, reason, tracker);
		this.recorder && this.recorder.close();
		this.stream = null;
	},
	execWs: function(_, context, wsCall, nbtry, ignoreCache) {
		this.lastAccess = datetime.now();
		wsCall.techInfo.poolEntryIdx = this.cliCfg.x3Pid;
		nbtry = nbtry != null ? nbtry : 1;

		try {
			// change context if it's necessary
			this._changeContext(_, wsCall);

			var description, _adxdoc;
			// special actions
			switch (wsCall.action) {
				case "GETSCHEMA":
					var schema = this._getDataXmlSchema(_, context, wsCall);
					if (!schema) {
						this.setFree(wsCall.context);
						return wsCall.getSoapResponse(0);
					}
					wsCall.result = schema;
					this.setFree(wsCall.context);
					return wsCall.getSoapResponse(1);
				case "GETDESCR":
					// get description
					description = this._getDescription(_, context, wsCall, true);
					if (!description) {
						this.setFree(wsCall.context);
						return wsCall.getSoapResponse(0);
					}
					wsCall.result = description;
					this.setFree(wsCall.context);
					return wsCall.getSoapResponse(1);
				default:
					// get description
					description = this._getDescription(_, context, wsCall, ignoreCache);
					if (!description) {
						this.setFree(wsCall.context);
						return wsCall.getSoapResponse(0);
					}
					_adxdoc = jsxml.parse(description).ADXDOC;
					break;
			}

			// add technical parameter for web-service
			wsCall.setAckCallParams(_adxdoc);

			wsCall.callTechParams = [{
				"descr": "WW_OK",
				"dim": 1,
				"nb": 1,
				"size": 0,
				"typ": "INT",
				"resu": -1
			}, {
				"descr": "WW_ZONE",
				"dim": 1,
				"nb": 0,
				"size": 30,
				"typ": "STRU",
			}, {
				"descr": "WW_STAT",
				"dim": 1,
				"nb": 0,
				"size": 0,
				"typ": "INT",
			}, {
				"descr": "WW_GRAVE",
				"dim": 50,
				"nb": 0,
				"size": 0,
				"typ": "INT",
			}, {
				"descr": "WW_MESS",
				"dim": 50,
				"nb": 0,
				"size": 250,
				"typ": "STRU",
			}, {
				"descr": "WW_ACTION",
				"dim": 1,
				"nb": wsCall.action ? 1 : 0,
				"size": wsCall.action.length,
				"typ": "STRU",
				"resu": wsCall.action
			}, {
				"descr": "WW_IDENT",
				"dim": 1,
				"nb": wsCall.wkeys ? 1 : 0,
				"size": 250,
				"typ": "STRU",
				"resu": wsCall.wkeys
			}, {
				"descr": "WW_NB",
				"dim": 1,
				"nb": wsCall.nb ? 1 : 0,
				"size": 0,
				"typ": "INT",
				"resu": wsCall.nb
			}, {
				"descr": "WW_HORDAT",
				"dim": 1,
				"nb": 1,
				"size": 14,
				"typ": "STRU",
				"resu": _adxdoc.$.TIM
			}, {
				"descr": "WW_TAB",
				"dim": 1,
				"nb": wsCall.tab ? 1 : 0,
				"size": wsCall.tab && wsCall.tab.length || 0,
				"typ": "STRU",
				"resu": wsCall.tab
			}, {
				"descr": "WW_PAR",
				"dim": 10,
				"nb": wsCall.par && wsCall.par.length || 0,
				"size": 250,
				"typ": "STRU",
				"resu": wsCall.par
			}, {
				"descr": "WW_TRACE",
				"dim": 1,
				"nb": 1,
				"size": 8,
				"typ": "CLOB",
				"resu": "ADAPI:PUB:" + wsCall.adapiPub.join(';')
			}];


			// concat functional parameter
			var finalParams = wsCall.callTechParams.concat(wsCall.callParams);


			var subprogName = _adxdoc.$.SPG || (wsCall.action === "LIST" ? "LISTE" : "OBJET");
			// Process ackcall
			var subprog = _adxdoc.$.WRP + ":" + subprogName;
			this.trace(wsCall, "info", "---------------------------------------");
			this.trace(wsCall, "info", "Call X3 subprogram '" + subprog + "'");

			// Add request traces
			this.trace(wsCall, "debug", "### Begin Input parameters");
			this.trace(wsCall, "debug", "*** Wrapper arguments: \r\n" + JSON.stringify(wsCall.callTechParams, null, 2));
			this.trace(wsCall, "debug", "*** Sub program arguments: \r\n" + JSON.stringify(wsCall.callParams, null, 2));
			this.trace(wsCall, "debug", "### End Input parameters");

			var reply = this.execAckCall(_, subprog, finalParams, wsCall);
			// validate reply content
			var resultParams = this._validReply(reply, wsCall, 4, 3);

			var self = this;
			// Add request traces
			this.trace(wsCall, "debug", "### Begin Output result");
			this.trace(wsCall, "debug", "*** Technical parameters: \r\n" + JSON.stringify(wsCall.resTechParams, null, 2));
			if (wsCall.resTechParams[11]) {
				this.trace(wsCall, "debug", "------------------------------------------------------------------------------------------");
				this.trace(wsCall, "debug", "*** Adonix traces: \r\n");
				forEachKey(wsCall.resTechParams[11], function(key, value) {
					if (value.resu) {
						self.trace(wsCall, "debug", value.resu);
					}
				});
				this.trace(wsCall, "debug", "------------------------------------------------------------------------------------------");
			}

			this.trace(wsCall, "debug", "*** Result parameters: \r\n" + JSON.stringify(resultParams, null, 2));
			this.trace(wsCall, "debug", "### End Output result");
			//
			//no major error, analyse parameter receive from the supervisor to check the ws call work or if we have to do something (refresh cache)
			var ww_ok = reply.json && reply.json.params && reply.json.params.length && reply.json.params[0] && reply.json.params[0].num === 0 && reply.json.params[0].resu;
			this.trace(wsCall, "info", "Result (" + ww_ok + ")");
			this.trace(wsCall, "info", "---------------------------------------");
			switch (ww_ok) {
				case 0:
					this.setFree(wsCall.context);
					return wsCall.getSoapResponse(0);
				case 1:
					wsCall.computeResult(resultParams);
					var resp = wsCall.getSoapResponse();
					wsCall.context.reserved = false;
					this.setFree(wsCall.context);
					return resp;
					// abnormal status
				case 6: // database closed
					throw new CvgWsException(locale.format(module, "sgbdClosed"));
				case 7: //must resign
					this._changeContext(_, wsCall, true);
					if (nbtry < maxNbTry) {
						return this.execWs(_, context, wsCall, nbtry + 1, true);
					} else {
						throw new Error("Max try reached");
					}
					break;
				case 8: // flush adx wrapper in memory is not coherent
					if (this._flush(_, wsCall)) {
						if (nbtry < maxNbTry) {
							return this.execWs(_, context, wsCall, nbtry + 1, true);
						} else {
							throw new Error("Max try reached");
						}
					}
					break;
				case 9:
					// get hdat and check consistency of description cache and stamp in x3
					if (nbtry < maxNbTry) {
						return this.execWs(_, context, wsCall, nbtry + 1, true);
					} else {
						throw new Error("Max try reached");
					}
					break;
				default:
					throw new CvgWsException(locale.format(module, "spgmNoResult", wsCall.name, ok));
			}

		} catch (e) {
			if (e instanceof CvgWsException) {
				if (nbtry < maxNbTry) {
					wsCall.report.addWarn("WS execution failed on first attempt. A second attempt has been processed to force the reload of the web service description");
					// reset messages
					wsCall.messages = [];
					// retry because maybe the ws has been republished !
					return this.execWs(_, context, wsCall, nbtry + 1, true);
				} else {
					wsCall.report.addError("Even after a second attempt, the WS execution failed");
					wsCall.addMessage(3, e.message);
					this.setFree(wsCall.context);
					return wsCall.getSoapResponse(0);
				}
			}
			// retry when stream closed unexpectedly
			else if (e.message === "stream was closed unexpectedly") {
				this.disconnectClient(_, {}, "failed :" + e.message + "\n" + e.stack);
				if (nbtry < maxNbTry) {
					tracer.warn && tracer.warn("stream was closed unexpectedly : try to reconnect client and execute call again...");
					// reserve client to prevent set it free before the execution
					wsCall.context.reserved = true;
					// reinitialize client
					this.init(_, context, wsCall.context);
					// execute again
					return this.execWs(_, context, wsCall, nbtry + 1);
				} else {
					this.disconnectClient(_, {}, "failed :" + e.message + "\n" + e.stack);
					this.setUnavailable(_, context);
					throw e;
				}
			} else {
				this.disconnectClient(_, {}, "failed :" + e.message + "\n" + e.stack);
				this.setUnavailable(_, context);
				throw e;
			}
		}

	},
	_validReply: function(reply, wsCall, msgMessIdx, msgTypeIdx) {

		wsCall.resTechParams = [],
		wsCall.resParams = [];
		// separate technical parameters and result parameters
		if (reply && reply.json && reply.json.params) {
			reply.json.params.forEach(function(p) {

				if (p.num > 11) {
					// add description and group (for traces informations)
					p.descr = wsCall.callParams && wsCall.callParams[p.num - 12] && wsCall.callParams[p.num - 12].descr;
					p.grp = wsCall.callParams && wsCall.callParams[p.num - 12] && wsCall.callParams[p.num - 12].grp;
					wsCall.resParams.push(p);
				} else if (p.num != null) {
					// add description (for traces informations)
					p.descr = wsCall.callTechParams && wsCall.callTechParams[p.num] && wsCall.callTechParams[p.num].descr;
					wsCall.resTechParams[p.num] = wsCall.resTechParams[p.num] || {};
					wsCall.resTechParams[p.num][p.poste] = p;
				}
			});
		}

		// Manage messages
		if (msgMessIdx && wsCall.resTechParams && wsCall.resTechParams[msgMessIdx]) {
			Object.keys(wsCall.resTechParams[msgMessIdx]).forEach(function(i) {
				var msgType = msgTypeIdx ? wsCall.resTechParams[msgTypeIdx][i].resu : 3;
				wsCall.addMessage(msgType, wsCall.resTechParams[msgMessIdx][i].resu);
			});
		}
		var finalResParams;
		if (wsCall && wsCall.callParams) {
			// Put input params first
			finalResParams = wsCall.callParams.concat(wsCall.resParams);
		}
		// Remove null objects for LIST operation
		if (wsCall.action === "LIST" && finalResParams) {
			finalResParams = finalResParams.filter(function(p) {
				return p && p.resu != null;
			});
		}

		var result = reply && reply.json && reply.json.result;
		if (!result) {
			var extraMessages = "";
			if (this.activeRequest.lastPushedWindow) {
				extraMessages += (extraMessages.length > 0 ? "\n" : "") + locale.format(module, "errOpenWinX3", JSON.stringify(this.activeRequest.lastPushedWindow));
			}
			if (this.activeRequest && this.activeRequest.ist) {
				extraMessages += (extraMessages.length > 0 ? "\n" : "") + "AdxId returned by X3 server: " + this.activeRequest.ist.toString();
			}
			wsCall.addMessage(3, locale.format(module, "noResult", extraMessages));
			throw new CvgWsException();
		} else if (!(result && !result.errn && !result.errm)) {
			//an error occurs raise an error
			wsCall.addMessage(3, result ? ("X3 Error: " + result.errp + ", message:" + result.errm + ", line :" + result.errl + ", type:" + result.errt) : "can't get result from X3");
			throw new CvgWsException();
		}
		return finalResParams;
	},

	_getDescription: function(_, context, wsCall, ignoreCache) {
		wsCall.techInfo.loadWebsDuration.start();
		var _adxdoc, res;
		var x3HttpPub = this.clientConfig.getParam("x3HttpPub");
		var x3Folder = this.clientConfig.getParam("x3Folder");
		var url = x3HttpPub + "/" + x3Folder + "/GEN/ALL/WEBS/" + wsCall.name + ".xml";


		// get description in cache
		if (!ignoreCache && cacheMgr.cacheContains(url)) {
			res = cacheMgr.getResource(_, url, null, {
				ignoreProxy: !this.useProxy,
				force: true
			}, this.recOptions);
			_adxdoc = jsxml.parse(res).ADXDOC;
		}
		// retrieve real description
		else {
			try {
				res = cacheMgr.getResource(_, url, null, {
					ignoreProxy: !this.useProxy
				}, this.recOptions);
				_adxdoc = jsxml.parse(res).ADXDOC;
			} catch (e) {
				// Do nothing to be able to call recupHDAT
				console.error("Get ws resource error: " + e.stack);
			}
			try {
				this._recupHDAT(_, wsCall, _adxdoc && _adxdoc.$.TIM);
			} catch (e) {
				if (e instanceof CvgWsException) {
					wsCall.addMessage(3, locale.format(module, "errorRecupHordat", RECUPHDAT, e.message, '', wsCall.name));
					wsCall.techInfo.loadWebsDuration.stop();
					return;
				}
				throw e;
			}
		}
		wsCall.techInfo.loadWebsDuration.stop();
		return res;
	},
	_getDataXmlSchema: function(_, context, wsCall) {
		wsCall.techInfo.loadWebsDuration.start();
		var res;
		var x3HttpPub = this.clientConfig.getParam("x3HttpPub");
		var x3Folder = this.clientConfig.getParam("x3Folder");
		var url = x3HttpPub + "/" + x3Folder + "/GEN/ALL/WEBS/" + wsCall.name + ".xsd";
		res = cacheMgr.getResource(_, url, null, {
			ignoreProxy: !this.useProxy
		}, this.recOptions);
		wsCall.techInfo.loadWebsDuration.stop();
		return res;
	},
	/*
	 return true if the timestamp passed and the stamp in supervisor side are the same.
	 Else return false if we have a delta between cache description and timestamp in supervisor
	 in other case we raise an exception
	 */
	_recupHDAT: function(_, wsCall, stamp) {
		wsCall.callTechParams = [{
			"descr": "WEBS",
			"dim": 1,
			"nb": 1,
			"size": wsCall.name.length,
			"typ": "STRU",
			"resu": wsCall.name
		}, {
			"descr": "HDAT",
			"dim": 1,
			"nb": stamp ? 1 : 0,
			"size": (stamp && stamp.length) || 0,
			"typ": "STRU",
			"resu": stamp || ""
		}, {
			"descr": "OK",
			"dim": 1,
			"nb": 0,
			"size": 0,
			"typ": "INT"
		}];

		this.trace(wsCall, "info", "---------------------------------------");
		this.trace(wsCall, "info", "Call X3 subprogram '" + RECUPHDAT + "' with timestamp '" + stamp + "'");

		// Add request traces
		this.trace(wsCall, "debug", "### Begin Input parameters");
		this.trace(wsCall, "debug", "*** Sub program arguments: \r\n" + JSON.stringify(wsCall.callTechParams, null, 2));
		this.trace(wsCall, "debug", "### End Input parameters");

		var reply = this.execAckCall(_, RECUPHDAT, wsCall.callTechParams, wsCall);

		this._validReply(reply, wsCall);

		// Add request traces
		this.trace(wsCall, "debug", "### Begin Output result");
		this.trace(wsCall, "debug", "*** Result parameters: \r\n" + JSON.stringify(wsCall.resTechParams, null, 2));
		this.trace(wsCall, "debug", "### End Output result");
		//

		//no major error, analyse parameter receive from the supervisor to check the ws call work or if we have to do something (refresh cache)
		var ok = -1;
		var st = null;
		reply.json && reply.json.params && reply.json.params.forEach(function(p) {
			if (p.num === 2) {
				ok = p.resu;
			} else if (p.num === 1) {
				st = p.resu;
			}
		});
		this.trace(wsCall, "info", "Result (" + ok + ")");
		this.trace(wsCall, "info", "---------------------------------------");
		if (ok === 1) {
			return;
		} else if (ok === 0) {
			throw new CvgWsException(locale.format(module, "statusHordat0"));
		} else if (ok === 9) {
			wsCall.techInfo.reloadWebs = true;
			throw new CvgWsException(locale.format(module, "statusHordat9"));
		} else {
			throw new CvgWsException(locale.format(module, "spgmNoResult", wsCall.name, ok));
		}
	},
	_changeContext: function(_, wsCall, forceChange) {
		var isSame = true;
		var endpoint = wsCall.context.endpoint;
		var currentUser = this.cliCfg.x3User;
		var receiveUser = wsCall.context.user.getEndpointLogin(_, endpoint.$uuid);
		var currentLang = this.cliCfg.x3Lang;
		var receiveLang = wsCall.context.localePref.code(_);
		if (wsCall.techInfo) {
			wsCall.techInfo.changeLanguage = currentLang !== receiveLang;
			wsCall.techInfo.changeUserId = currentUser !== receiveUser;
		}
		isSame = currentUser === receiveUser && currentLang === receiveLang;
		if (!isSame || forceChange) {
			this._changeLogin(_, receiveUser, locale.x3Language(receiveLang), wsCall);
			return true;
		}
		return false;
	},
	/*
	 return true if the change of context works fine. Else we raise an exception with the message coming from X3 or a standard message
	 */
	_changeLogin: function(_, receiveUser, receiveLang, wsCall) {
		wsCall.callTechParams = [{
			"descr": "OK",
			"dim": 1,
			"nb": 1,
			"size": 1,
			"typ": "INT",
			"resu": -1
		}, {
			"descr": "MESSAGE",
			"dim": 1,
			"nb": 0,
			"size": 250,
			"typ": "STRU",
		}, {
			"descr": "LOGIN",
			"dim": 1,
			"nb": 1,
			"size": receiveUser.length,
			"typ": "STRU",
			"resu": receiveUser,
		}, {
			"descr": "LANG",
			"dim": 1,
			"nb": 1,
			"size": receiveLang.length,
			"typ": "STRU",
			"resu": receiveLang
		}];
		this.trace(wsCall, "info", "---------------------------------------");
		this.trace(wsCall, "info", "Call X3 subprogram '" + CHGLOGINXTEND + "'");

		// Add request traces
		this.trace(wsCall, "debug", "### Begin Input parameters");
		this.trace(wsCall, "debug", "*** Sub program arguments: \r\n" + JSON.stringify(wsCall.callTechParams, null, 2));
		this.trace(wsCall, "debug", "### End Input parameters");

		var reply = this.execAckCall(_, CHGLOGINXTEND, wsCall.callTechParams, wsCall);

		this._validReply(reply, wsCall, 1);

		// Add request traces
		this.trace(wsCall, "debug", "### Begin Output result");
		this.trace(wsCall, "debug", "*** Result parameters: \r\n" + JSON.stringify(wsCall.resTechParams, null, 2));
		this.trace(wsCall, "debug", "### End Output result");
		//

		//no major error, analyse parameter receive from the supervisor to check the ws call work or if we have to do something (refresh cache)
		var ok = reply.json && reply.json.params && reply.json.params.length && reply.json.params[0] && reply.json.params[0].num === 0 && reply.json.params[0].resu;
		this.trace(wsCall, "info", "Result (" + ok + ")");
		this.trace(wsCall, "info", "---------------------------------------");
		if (ok === 1) {
			this._setContextConfig(_, wsCall.context);
			this._checkX3Lang(_, {
				wsCall: wsCall
			});
		} else if (ok === 0) {
			throw new CvgWsException("Change login error");
		} else {
			throw new CvgWsException(locale.format(module, "spgmNoResult", wsCall.name, ok));
		}

		return ok;
	},
	/*
	 return true if the flush call works else raise an exception
	 */
	_flush: function(_, wsCall) {

		wsCall.callTechParams = [{
			"descr": "OK",
			"dim": 1,
			"nb": 1,
			"size": 1,
			"typ": "INT",
			"resu": -1
		}];

		this.trace(wsCall, "info", "---------------------------------------");
		this.trace(wsCall, "info", "Call X3 subprogram '" + FLUSHADX + "'");

		// Add request traces
		this.trace(wsCall, "debug", "### Begin Input parameters");
		this.trace(wsCall, "debug", "*** Sub program arguments: \r\n" + JSON.stringify(wsCall.callTechParams, null, 2));
		this.trace(wsCall, "debug", "### End Input parameters");

		var reply = this.execAckCall(_, FLUSHADX, wsCall.callTechParams, wsCall);

		this._validReply(reply, wsCall);

		// Add request traces
		this.trace(wsCall, "debug", "### Begin Output result");
		this.trace(wsCall, "debug", "*** Result parameters: \r\n" + JSON.stringify(wsCall.resTechParams, null, 2));
		this.trace(wsCall, "debug", "### End Output result");
		//

		//no major error, analyse parameter receive from the supervisor to check the ws call work or if we have to do something (refresh cache)
		var ok = reply.json && reply.json.params && reply.json.params.length && reply.json.params[0] && reply.json.params[0].num === 0 && reply.json.params[0].resu;
		this.trace(wsCall, "info", "Result (" + ok + ")");
		this.trace(wsCall, "info", "---------------------------------------");
		if (ok === 1) {
			return true;
		} else if (ok === 0) {
			throw new CvgWsException(locale.format(module, "alreadyFlushAdx", wsCall.name, ok));
		} else {
			throw new CvgWsException(locale.format(module, "spgmNoResult", wsCall.name, ok));
		}
	},
	newRequest: function(reply, sendContext) {
		return new CvgRequestWS(this, reply, sendContext);
	},
	trace: function(wsCall, level, message) {
		tracer[level] && tracer[level](message);
		wsCall.addWsTrace(level, message);
	},
	toJSON: function() {
		return {
			pid: this.pid,
			host: this.host,
			port: this.port,
			user: this.cliCfg.x3User,
			lang: this.cliCfg.x3Lang,
			lastAccess: this.lastAccess.toString(),
			creationDate: this.creationDate.toString()
		};
	}
});