"use strict";

var locale = require("syracuse-core/lib/locale");
var helpers = require('syracuse-core/lib/helpers');
var CvgClientAbs = require("syracuse-x3/lib/clients/common/cvg/CvgClientAbs").CvgClientAbs;
var CvgRequestWS = require("syracuse-x3/lib/clients/soap/CvgRequestWS").CvgRequestWS;
var CvgWsException = require("syracuse-x3/lib/clients/soap/CvgWsException").CvgWsException;
var OfflinePlayer = require('syracuse-x3/lib/clients/common/offlinePlayer').OfflinePlayer;
var upath = require('path');
var recordMgr = require("syracuse-x3/lib/convergence/records/recordMgr").recordMgr;
var ufs = require('fs');

var x3client = require('syracuse-x3/lib/client');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
//var tracerSession = require("syracuse-trace/lib/helper").getTracer("classic.session");
var jsxml = require('jsxml');
var CvgCacheManager = require('syracuse-x3/lib/cvgCacheManager').CvgCacheManager;
var cliManager = require("syracuse-soap/lib/generic/clientManager");
var CvgWSCall = require('syracuse-x3/lib/clients/soap/CvgWSCall').CvgWSCall;
var cacheMgr = new CvgCacheManager();

var tracer = require("syracuse-trace/lib/helper").getTracer("soap-generic.ackcall");

var RECUPHDAT = "AWEB:RECUPHDAT";
var CHGLOGINXTEND = "CHGUSR:CHGLOGINXTEND";
var FLUSHADX = "AFLUSHADX:FLUSHADX";

var maxNbTry = 2; // TODO configure that point

exports.CvgClientWS = helpers.defineClass(function() {
	CvgClientAbs.call(this);
}, CvgClientAbs, {
	init: function(_, context, recOptions) {
		function readJsonPlayer(_, path) {
			var json;
			try {
				json = ufs.readFileSync(path, 'utf8') || "";
				json = json.trim();
				if (json.length === 0) throw new Error("Empty file");
				if (json[json.length - 1] === ',') json = json.substring(0, json.length - 1);
				json = "[" + json + "]";
			} catch (e) {
				throw e;
			}
			try {
				json = JSON.parse(json);
				return json;
			} catch (e) {
				throw e;
			}
			return null;
		}
		// connect to the x3 server
		this.adxtype = 25; // TODO change by the WS type
		this.sid = null;
		var configRecords = {};
		if (recOptions && recOptions.path) {
			configRecords = {
				dumpPath: upath.join(process.mainModule.filename.substring(0, process.mainModule.filename.indexOf("node_modules")), recOptions.path)
			};
		}
		this.isFree = false;
		this.isConnected = false;
		this.poolContext = context.httpSession.genericWsCtx;
		this.cliCfg = this._getContextConfig(_);
		var stream = null;
		if (recOptions && recOptions.recMode === 'PLAY') {
			// create player regarding the recOptions
			stream = new OfflinePlayer(_, readJsonPlayer(_, configRecords.dumpPath + "/cvgRecords/" + recOptions.fileName));
		} else {
			stream = this._connect(_, context, recOptions).getStream();
			if (recOptions && recOptions.recMode === 'REC')
				this.recorder = recordMgr.newRecorder(_, stream, recOptions, {}, configRecords);

		}
		CvgClientAbs.prototype.init.call(this, stream, this.cliCfg, null, context);
		this.connectStart(_, context);
		return this;

	},
	_getContextConfig: function(_) { // TODO refactor to set that method in super class
		var endpoint = this.poolContext.endpoint;
		return {
			x3User: this.poolContext.user.getEndpointLogin(_, endpoint.$uuid),
			x3Host: endpoint.x3server(_).serverHost(_),
			x3Port: endpoint.x3server(_).serverPort(_),
			x3Lang: this.poolContext.localePref.code(_),
			x3HttpPub: endpoint.getWebServerBaseUrl(_),
			x3Folder: endpoint.x3ServerFolder(_),
			x3Solution: endpoint.x3SolutionName(_),
			appHost: endpoint.x3server(_).serverName(_),
			dataset: endpoint.dataset(_) // necessary for scoring system
		};
	},

	_connect: function(_, context, recOptions) { // TODO refactor to set that method in super class
		if (recOptions && recOptions.recmode === 'REC') {
			// TODO add a handle for recording
		}
		var runtimeConfig = (context.httpSession && context.httpSession.x3SessionConfig && context.httpSession.x3SessionConfig.runtime) || {};
		var adminEP = adminHelper.getCollaborationEndpoint(_);
		var sessionCtx = context.httpSession.genericWsCtx;

		var client = x3client.create({
			port: this.cliCfg.x3Port,
			address: this.cliCfg.x3Host,
			//tracer: tracerSession
		});

		var _x3 = client.connect(_, {
			server: this.cliCfg.appHost,
			folder: this.cliCfg.x3Folder,
			fusion: true,
			locale: this.cliCfg.x3Lang,
			runtimeLog: !runtimeConfig.dataset || sessionCtx.endpoint.dataset(_) === runtimeConfig.dataset ? runtimeConfig.logFlag : "",
			runtimeLogDir: !runtimeConfig.dataset || sessionCtx.endpoint.dataset(_) === runtimeConfig.dataset ? runtimeConfig.logDir : ""

		});
		this.cliCfg.x3Pid = "" + _x3.pid;
		this.cliCfg.x3SessionUrl = _x3.sessionUrl;
		this.cliCfg.x3SessionId = _x3.sessionId;

		var sysAuthToken;
		if (sessionCtx.user && sessionCtx.user.infov6(_)) {
			sysAuthToken = new Buffer(sessionCtx.user.userv6(_) + ":" + sessionCtx.user.passwordv6(_), "utf8").toString("base64");
		}

		this.sid = client.createSession(_, {
			locale: this.cliCfg.x3Lang,
			userName: this.cliCfg.x3User,
			adxtyp: this.adxtype,
			sysAuthToken: sysAuthToken,
			fusionTech: {
				protocol: "150067",
			},
			localePreferences: sessionCtx.localePref,
			baseUrl: context.baseUrl,
			collaborationBaseUrl: adminEP ? context.request.session.host + adminHelper.getCollaborationEndpoint(_).getBaseUrl(_) : "",
			peerAddress: (context.httpSession.getData("requestInfo") || {}).peerAddress
		});
		this.isFree = true;
		this.isConnected = true;
		return client;
	},
	_changeContext: function(_, genericWsCtx, debugInfo, techInfo, forceChange) {
		var isSame = true;
		var endpoint = this.poolContext.endpoint;
		var currentUser = this.poolContext.user.getEndpointLogin(_, endpoint.$uuid);
		var receiveUser = genericWsCtx.user.getEndpointLogin(_, endpoint.$uuid);
		var currentLang = this.poolContext.localePref.code(_);
		var receiveLang = genericWsCtx.localePref.code(_);
		techInfo.changeLanguage = currentLang !== receiveLang;
		techInfo.changeUserId = currentUser !== receiveUser;


		isSame = currentUser === receiveUser && currentLang === receiveLang;
		if (!isSame || forceChange) {

			this._changeLogin(_, receiveUser, locale.x3Language(receiveLang), debugInfo, techInfo);
			this.poolContext = genericWsCtx;
		}
		return isSame;
	},
	disconnectClient: function(_, params, reason, tracker) {
		CvgClientAbs.prototype.disconnectClient.call(this, _, params, reason, tracker);
		cliManager.disconnect(this.uuid);
		this.recorder && this.recorder.close();
		this.stream = null;
		this.isConnected = false;
	},
	execWs: function(_, context, params, techInfo, beautify, nbtry, ignoreCache) {
		try {
			techInfo.poolEntryIdx = this.cliCfg.x3Pid;
			var wsCtx = context.httpSession.genericWsCtx;
			this.isFree = false;
			nbtry = nbtry || 1;

			var wsCall = new CvgWSCall(techInfo, this._x3SessionSettings.cdLang, params);
			// change context is it's necessary
			this._changeContext(_, wsCtx, wsCall.debugInfo, techInfo);

			// get description
			var description = this._getDescription(_, wsCall, techInfo, ignoreCache);
			if (!description) return wsCall.getSoapResponse();


			// add technical parameter for web-service
			wsCall.setAckCallParams(description);

			var ackCallParams = [{
				"descr": "WW_OK",
				"dim": 1,
				"nb": 1,
				"size": 0,
				"typ": "INT",
				"resu": -1
			}, {
				"descr": "WW_ZONE",
				"dim": 1,
				"nb": 0,
				"size": 30,
				"typ": "STRU",
			}, {
				"descr": "WW_STAT",
				"dim": 1,
				"nb": 0,
				"size": 0,
				"typ": "INT",
			}, {
				"descr": "WW_GRAVE",
				"dim": 50,
				"nb": 0,
				"size": 0,
				"typ": "INT",
			}, {
				"descr": "WW_MESS",
				"dim": 50,
				"nb": 0,
				"size": 250,
				"typ": "STRU",
			}, {
				"descr": "WW_ACTION",
				"dim": 1,
				"nb": wsCall.action ? 1 : 0,
				"size": wsCall.action.length,
				"typ": "STRU",
				"resu": wsCall.action
			}, {
				"descr": "WW_IDENT",
				"dim": 1,
				"nb": wsCall.wkeys ? 1 : 0,
				"size": 250,
				"typ": "STRU",
				"resu": wsCall.wkeys
			}, {
				"descr": "WW_NB",
				"dim": 1,
				"nb": wsCall.nb ? 1 : 0,
				"size": 0,
				"typ": "INT",
				"resu": wsCall.nb
			}, {
				"descr": "WW_HORDAT",
				"dim": 1,
				"nb": 1,
				"size": 14,
				"typ": "STRU",
				"resu": description.$.TIM
			}, {
				"descr": "WW_TAB",
				"dim": 1,
				"nb": wsCall.tab ? 1 : 0,
				"size": wsCall.tab && wsCall.tab.length || 0,
				"typ": "STRU",
				"resu": wsCall.tab
			}, {
				"descr": "WW_PAR",
				"dim": 1,
				"nb": wsCall.par ? 1 : 0,
				"size": wsCall.par && wsCall.par.length || 0,
				"typ": "STRU",
				"resu": wsCall.par
			}, {
				"descr": "WW_TRACE",
				"dim": 1,
				"nb": 0,
				"size": 8,
				"typ": "CLOB",
				"resu": ""
			}];


			// add functional parameter
			wsCall.callParams && wsCall.callParams.forEach(function(param) {
				ackCallParams.push(param);
			});

			tracer.debug && tracer.debug("ACKCALL PARAMS: " + JSON.stringify(ackCallParams, null, 2));
			var subprogName = description.$.SPG || (wsCall.action === "LIST" ? "LISTE" : "OBJET");
			// Process ackcall
			var subprog = description.$.WRP + ":" + subprogName;
			tracer.info && tracer.info("---------------------------------------");
			tracer.info && tracer.info("Call X3 subprogram '" + subprog + "'");
			var reply = CvgClientAbs.prototype.execAckCall.call(this, _, subprog, wsCall.debugInfo, ackCallParams, techInfo);
			//analyse reply for a web-service we have the status
			var result = reply && reply.json && reply.json.result;

			if (!(result && !result.errn && !result.errm)) {
				//an error occurs raise an error
				throw new Error(result ? ("X3 Error:" + result.errp + ", message:" + result.errm + ", line :" + result.errl + ", type:" + result.errt) : "can't get result from X3");
			} else {
				//no major error, analyse parameter receive from the supervisor to check the ws call work or if we have to do something (refresh cache)
				var ww_ok = reply.json && reply.json.params && reply.json.params.length && reply.json.params[0] && reply.json.params[0].num === 0 && reply.json.params[0].resu;
				tracer.info && tracer.info("Result (" + ww_ok + ")");
				tracer.info && tracer.info("---------------------------------------");
				switch (ww_ok) {
					case 0:
					case 1:
						// abnormal status
					case 6: // database closed
						return wsCall.interpretReply(ww_ok, reply, beautify);
					case 7: //must resign
						this._changeContext(_, wsCtx, wsCall.debugInfo, techInfo, true);
						break;
					case 8: // flush adx wrapper in memory is not coherent
						this._flush(_, techInfo, wsCall.debugInfo);
						if (nbtry < maxNbTry)
							return this.execWs(_, context, params, techInfo, beautify, nbtry++);
						break;
					case 9:
						// get hdat and check consistency of description cache and stamp in x3
						if (nbtry < maxNbTry) {
							return this.execWs(_, context, params, techInfo, beautify, nbtry++, true);
						}
						break;
					default:
						throw new Error(locale.format(module, "failedExec", ww_ok));
				}
			}
		} catch (e) {
			this.disconnectClient(_, {}, "failed :" + e.message + "\n" + e.stack);
			this.isConnected = false;
			throw e;
		} finally {
			this.isFree = true;
		}
	},
	_getDescription: function(_, wsCall, techInfo, ignoreCache) {
		techInfo.loadWebsDuration.start();
		var _description, res;
		var x3HttpPub = this.clientConfig.getParam("x3HttpPub");
		var x3Folder = this.clientConfig.getParam("x3Folder");
		var url = x3HttpPub + "/" + x3Folder + "/GEN/ALL/WEBS/" + wsCall.name + ".xml";

		// get description in cache
		if (!ignoreCache && cacheMgr.cacheContains(url)) {
			res = cacheMgr.cache[url].resource;
			_description = jsxml.parse(res).ADXDOC;
		}
		// retrieve real description
		else {
			try {
				res = cacheMgr.getResource(_, url, null);
				_description = jsxml.parse(res).ADXDOC;
			} catch (e) {
				// Do nothing to be able to call recupHDAT
			}
			try {
				this._recupHDAT(_, wsCall, _description && _description.$.TIM, techInfo);
			} catch (e) {
				if (e instanceof CvgWsException) {
					wsCall.addMessage(3, locale.format(module, "errorRecupHordat", RECUPHDAT, e.message, '', wsCall.name));
					return;
				}
				throw e;
			}
		}
		techInfo.loadWebsDuration.stop();
		return _description;
	},
	/*
	 return true if the timestamp passed and the stamp in supervisor side are the same.
	 Else return false if we have a delta between cache description and timestamp in supervisor
	 in other case we raise an exception
	 */
	_recupHDAT: function(_, wsCall, stamp, techInfo) {
		techInfo.poolExecDuration.start();
		tracer.info && tracer.info("---------------------------------------");
		tracer.info && tracer.info("Call X3 subprogram '" + RECUPHDAT + "'");
		var reply = this.execAckCall(_, RECUPHDAT, wsCall.debugInfo, [{
			"decr": "WEBS",
			"dim": 1,
			"nb": 1,
			"size": wsCall.name.length,
			"typ": "STRU",
			"resu": wsCall.name
		}, {
			"decr": "HDAT",
			"dim": 1,
			"nb": stamp ? 1 : 0,
			"size": (stamp && stamp.length) || 0,
			"typ": "STRU",
			"resu": stamp || ""
		}, {
			"decr": "OK",
			"dim": 1,
			"nb": 0,
			"size": 0,
			"typ": "INT"
		}], techInfo);
		techInfo && techInfo.poolExecDuration.stop();
		var result = reply && reply.json && reply.json.result;
		if (!(result && !result.errn && !result.errm)) {
			//an error occurs raise an error
			throw new Error(result ? ("X3 Error:" + result.errp + ", message:" + result.errm + ", line :" + result.errl + ", type:" + result.errt) : "can't get result from X3");
		} else {
			//no major error, analyse parameter receive from the supervisor to check the ws call work or if we have to do something (refresh cache)
			var ok = -1;
			var st = null;
			reply.json && reply.json.params && reply.json.params.forEach(function(p) {
				if (p.num === 2) {
					ok = p.resu;
				} else if (p.num === 1) {
					st = p.resu;
				}
			});
			tracer.info && tracer.info("Result (" + ok + ")");
			tracer.info && tracer.info("---------------------------------------");
			if (ok === 1) {
				return 1;
			} else if (ok === 0) {
				throw new CvgWsException(this, null, locale.format(module, "statusHordat0"));
			} else if (ok === 9) {
				techInfo.reloadWebs = true;
				throw new CvgWsException(this, null, locale.format(module, "statusHordat9"));
			} else {
				throw new Error("Error on recup hdat call");
			}
		}
	},

	/*
	 return true if the change of context works fine. Else we raise an exception with the message coming from X3 or a standard message
	 */
	_changeLogin: function(_, receiveUser, receiveLang, debugInfo, techInfo) {
		tracer.info && tracer.info("---------------------------------------");
		tracer.info && tracer.info("Call X3 subprogram '" + CHGLOGINXTEND + "'");
		var reply = this.execAckCall(_, CHGLOGINXTEND, debugInfo, [{
			"decr": "OK",
			"dim": 1,
			"nb": 1,
			"size": 1,
			"typ": "INT",
			"resu": -1
		}, {
			"decr": "MESSAGE",
			"dim": 1,
			"nb": 0,
			"size": 250,
			"typ": "STRU",
		}, {
			"decr": "LOGIN",
			"dim": 1,
			"nb": 1,
			"size": receiveUser.length,
			"typ": "STRU",
			"resu": receiveUser,
		}, {
			"decr": "LANG",
			"dim": 1,
			"nb": 1,
			"size": receiveLang.length,
			"typ": "STRU",
			"resu": receiveLang
		}], techInfo);
		var result = reply && reply.json && reply.json.result;

		if (!(result && !result.errn && !result.errm)) {
			//an error occurs raise an error
			throw new Error(result ? ("X3 Error:" + result.errp + ", message:" + result.errm + ", line :" + result.errl + ", type:" + result.errt) : "can't get result from X3");
		} else {
			//no major error, analyse parameter receive from the supervisor to check the ws call work or if we have to do something (refresh cache)
			var ok = reply.json && reply.json.params && reply.json.params.length && reply.json.params[0] && reply.json.params[0].num === 0 && reply.json.params[0].resu;
			tracer.info && tracer.info("Result (" + ok + ")");
			tracer.info && tracer.info("---------------------------------------");
			if (ok === 1) {
				return true;
			} else if (ok === 6) { // pb dbms
				throw new Error("X3 Error: dbms connection failure");

			} else {
				var message = reply.json && reply.json.params && reply.json.params.length && reply.json.params[1] && reply.json.params[1].num === 1 && reply.json.params[1].resu;
				// display message received
				throw new Error("X3 Error: " + (message ? message : "can't change context"));
			}
		}
	},
	/*
	 return true if the flush call works else raise an exception
	 */
	_flush: function(_, techInfo, debugInfo) {
		tracer.info && tracer.info("---------------------------------------");
		tracer.info && tracer.info("Call X3 subprogram '" + FLUSHADX + "'");

		var reply = this.execAckCall(_, FLUSHADX, debugInfo, [{
			"decr": "OK",
			"dim": 1,
			"nb": 1,
			"size": 1,
			"typ": "INT",
			"resu": -1
		}], techInfo);
		var result = reply && reply.json && reply.json.result;

		if (!(result && !result.errn && !result.errm)) {
			//an error occurs raise an error
			throw new Error(result ? ("X3 Error:" + result.errp + ", message:" + result.errm + ", line :" + result.errl + ", type:" + result.errt) : "can't get result from X3");
		} else {
			//no major error, analyse parameter receive from the supervisor to check the ws call work or if we have to do something (refresh cache)
			var ok = reply.json && reply.json.params && reply.json.params.length && reply.json.params[0] && reply.json.params[0].num === 0 && reply.json.params[0].resu;
			tracer.info && tracer.info("Result (" + ok + ")");
			tracer.info && tracer.info("---------------------------------------");
			if (ok === 1) {
				return true;
			} else if (ok === 6) { // pb dbms
				throw new Error("X3 Error: dbms connection failure");
			} else {
				var message = reply.json && reply.json.params && reply.json.params.length && reply.json.params[1] && reply.json.params[1].num === 1 && reply.json.params[1].resu;

				// display message received
				throw new Error("X3 Error: " + (message ? message : "can't change context"));
			}
		}
	},
	newRequest: function(reply, sendContext) {
		return new CvgRequestWS(this, reply, sendContext);
	}
});