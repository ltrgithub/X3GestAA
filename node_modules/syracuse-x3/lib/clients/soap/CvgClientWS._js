"use strict";

var locale = require("syracuse-core/lib/locale");
var helpers = require('syracuse-core/lib/helpers');
var CvgClientAbs = require("syracuse-x3/lib/clients/common/cvg/CvgClientAbs").CvgClientAbs;
var CvgRequestWS = require("syracuse-x3/lib/clients/soap/CvgRequestWS").CvgRequestWS;
var CvgWsException = require("syracuse-x3/lib/clients/soap/CvgWsException").CvgWsException;
var OfflinePlayer = require('syracuse-x3/lib/clients/common/offlinePlayer').OfflinePlayer;
var upath = require('path');
var recordMgr = require("syracuse-x3/lib/convergence/records/recordMgr").recordMgr;
var ufs = require('fs');

var x3client = require('syracuse-x3/lib/client');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
//var tracerSession = require("syracuse-trace/lib/helper").getTracer("classic.session");
var jsxml = require('jsxml');
var CvgCacheManager = require('syracuse-x3/lib/cvgCacheManager').CvgCacheManager;
var cliManager = require("syracuse-soap/lib/generic/clientManager");
var CvgWSCall = require('syracuse-x3/lib/clients/soap/CvgWSCall').CvgWSCall;
var cacheMgr = new CvgCacheManager();

var tracer = require("syracuse-trace/lib/helper").getTracer("soap-generic.ackcall");

var RECUPHDAT = "AWEB:RECUPHDAT";
var CHGLOGINXTEND = "CHGUSR:CHGLOGINXTEND";
var FLUSHADX = "AFLUSHADX:FLUSHADX";

/*
var messageTypes = {
	MESS_INFO: 1,
	MESS_WARN: 2,
	MESS_BLOK: 3,
	MESS_EXEP: 4,
	MESS_ZONE: 5
};
*/

var maxNbTry = 2; // TODO configure that point

exports.CvgClientWS = helpers.defineClass(function() {
	CvgClientAbs.call(this);
}, CvgClientAbs, {
	init: function(_, context, recOptions) {
		function readJsonPlayer(_, path) {
			var json;
			try {
				json = ufs.readFileSync(path, 'utf8') || "";
				json = json.trim();
				if (json.length === 0) throw new Error("Empty file");
				if (json[json.length - 1] === ',') json = json.substring(0, json.length - 1);
				json = "[" + json + "]";
			} catch (e) {
				throw e;
			}
			try {
				json = JSON.parse(json);
				return json;
			} catch (e) {
				throw e;
			}
			return null;
		}
		// connect to the x3 server
		this.sid = null;
		var configRecords = {};
		if (recOptions && recOptions.path) {
			configRecords = {
				dumpPath: upath.join(process.mainModule.filename.substring(0, process.mainModule.filename.indexOf("node_modules")), recOptions.path)
			};
		}
		this.isFree = false;
		this.isConnected = false;
		this.poolContext = context.httpSession.genericWsCtx;
		this.cliCfg = this._getContextConfig(_);
		var stream = null;
		if (recOptions && recOptions.recMode === 'PLAY') {
			// create player regarding the recOptions
			stream = new OfflinePlayer(_, readJsonPlayer(_, configRecords.dumpPath + "/cvgRecords/" + recOptions.fileName));
		} else {
			stream = this._connect(_, context, recOptions).getStream();
			if (recOptions && recOptions.recMode === 'REC')
				this.recorder = recordMgr.newRecorder(_, stream, recOptions, {}, configRecords);

		}
		CvgClientAbs.prototype.init.call(this, stream, this.cliCfg, null, context);
		this.adxtype = 12;
		this.connectStart(_, context);
		return this;
	},
	_getContextConfig: function(_) { // TODO refactor to set that method in super class
		var endpoint = this.poolContext.endpoint;
		return {
			x3User: this.poolContext.user.getEndpointLogin(_, endpoint.$uuid),
			x3Host: endpoint.x3server(_).serverHost(_),
			x3Port: endpoint.x3server(_).serverPort(_),
			x3Lang: this.poolContext.localePref.code(_),
			x3HttpPub: endpoint.getWebServerBaseUrl(_),
			x3Folder: endpoint.x3ServerFolder(_),
			x3Solution: endpoint.x3SolutionName(_),
			appHost: endpoint.x3server(_).serverName(_),
			dataset: endpoint.dataset(_) // necessary for scoring system
		};
	},

	_connect: function(_, context, recOptions) { // TODO refactor to set that method in super class
		if (recOptions && recOptions.recmode === 'REC') {
			// TODO add a handle for recording
		}
		var runtimeConfig = (context.httpSession && context.httpSession.x3SessionConfig && context.httpSession.x3SessionConfig.runtime) || {};
		var adminEP = adminHelper.getCollaborationEndpoint(_);
		var sessionCtx = context.httpSession.genericWsCtx;

		var client = x3client.create({
			port: this.cliCfg.x3Port,
			address: this.cliCfg.x3Host,
			//tracer: tracerSession
		});

		var _x3 = client.connect(_, {
			server: this.cliCfg.appHost,
			folder: this.cliCfg.x3Folder,
			fusion: true,
			locale: this.cliCfg.x3Lang,
			runtimeLog: !runtimeConfig.dataset || sessionCtx.endpoint.dataset(_) === runtimeConfig.dataset ? runtimeConfig.logFlag : "",
			runtimeLogDir: !runtimeConfig.dataset || sessionCtx.endpoint.dataset(_) === runtimeConfig.dataset ? runtimeConfig.logDir : ""

		});
		this.cliCfg.x3Pid = "" + _x3.pid;
		this.cliCfg.x3SessionUrl = _x3.sessionUrl;
		this.cliCfg.x3SessionId = _x3.sessionId;

		var sysAuthToken;
		if (sessionCtx.user && sessionCtx.user.infov6(_)) {
			sysAuthToken = new Buffer(sessionCtx.user.userv6(_) + ":" + sessionCtx.user.passwordv6(_), "utf8").toString("base64");
		}

		this.sid = client.createSession(_, {
			locale: this.cliCfg.x3Lang,
			userName: this.cliCfg.x3User,
			adxtyp: this.adxtype,
			sysAuthToken: sysAuthToken,
			fusionTech: {
				protocol: "150067",
			},
			localePreferences: sessionCtx.localePref,
			baseUrl: context.baseUrl,
			collaborationBaseUrl: adminEP ? context.request.session.host + adminHelper.getCollaborationEndpoint(_).getBaseUrl(_) : "",
			peerAddress: (context.httpSession.getData("requestInfo") || {}).peerAddress
		});
		this.isFree = true;
		this.isConnected = true;
		return client;
	},

	disconnectClient: function(_, params, reason, tracker) {
		CvgClientAbs.prototype.disconnectClient.call(this, _, params, reason, tracker);
		cliManager.disconnect(this.uuid);
		this.recorder && this.recorder.close();
		this.stream = null;
		this.isConnected = false;
	},
	execWs: function(_, context, params, techInfo, beautify, nbtry, ignoreCache) {


		techInfo.poolEntryIdx = this.cliCfg.x3Pid;
		var wsCtx = context.httpSession.genericWsCtx;
		this.isFree = false;
		nbtry = nbtry || 1;

		var wsCall = new CvgWSCall(techInfo, locale.x3Language(context.httpSession.genericWsCtx.localePref.code(_)), params);

		try {
			// change context is it's necessary
			this._changeContext(_, wsCtx, wsCall, techInfo);

			// get description
			var description = this._getDescription(_, wsCall, ignoreCache);
			if (!description) return wsCall.getSoapResponse(1);

			// special actions
			switch (wsCall.action) {
				case "GETSCHEMA": // Not sure exactly the same !!!
				case "GETDESCR":
					wsCall.result = '<?xml version="1.0" encoding="utf-8"?>\n' + jsxml.stringify({
						ADXDOC: description
					}, {
						indent: '\t'
					});
					return wsCall.getSoapResponse(1);
				default:
					break;
			}

			// add technical parameter for web-service
			wsCall.setAckCallParams(description);

			var ackCallParams = [{
				"descr": "WW_OK",
				"dim": 1,
				"nb": 1,
				"size": 0,
				"typ": "INT",
				"resu": -1
			}, {
				"descr": "WW_ZONE",
				"dim": 1,
				"nb": 0,
				"size": 30,
				"typ": "STRU",
			}, {
				"descr": "WW_STAT",
				"dim": 1,
				"nb": 0,
				"size": 0,
				"typ": "INT",
			}, {
				"descr": "WW_GRAVE",
				"dim": 50,
				"nb": 0,
				"size": 0,
				"typ": "INT",
			}, {
				"descr": "WW_MESS",
				"dim": 50,
				"nb": 0,
				"size": 250,
				"typ": "STRU",
			}, {
				"descr": "WW_ACTION",
				"dim": 1,
				"nb": wsCall.action ? 1 : 0,
				"size": wsCall.action.length,
				"typ": "STRU",
				"resu": wsCall.action
			}, {
				"descr": "WW_IDENT",
				"dim": 1,
				"nb": wsCall.wkeys ? 1 : 0,
				"size": 250,
				"typ": "STRU",
				"resu": wsCall.wkeys
			}, {
				"descr": "WW_NB",
				"dim": 1,
				"nb": wsCall.nb ? 1 : 0,
				"size": 0,
				"typ": "INT",
				"resu": wsCall.nb
			}, {
				"descr": "WW_HORDAT",
				"dim": 1,
				"nb": 1,
				"size": 14,
				"typ": "STRU",
				"resu": description.$.TIM
			}, {
				"descr": "WW_TAB",
				"dim": 1,
				"nb": wsCall.tab ? 1 : 0,
				"size": wsCall.tab && wsCall.tab.length || 0,
				"typ": "STRU",
				"resu": wsCall.tab
			}, {
				"descr": "WW_PAR",
				"dim": 10,
				"nb": wsCall.par && wsCall.par.length || 0,
				"size": 250,
				"typ": "STRU",
				"resu": wsCall.par
			}, {
				"descr": "WW_TRACE",
				"dim": 1,
				"nb": 0,
				"size": 8,
				"typ": "CLOB",
				"resu": ""
			}];


			// add functional parameter
			wsCall.callParams && wsCall.callParams.forEach(function(param) {
				ackCallParams.push(param);
			});

			//tracer.debug && tracer.debug("ACKCALL PARAMS: " + JSON.stringify(ackCallParams, null, 2));
			var subprogName = description.$.SPG || (wsCall.action === "LIST" ? "LISTE" : "OBJET");
			// Process ackcall
			var subprog = description.$.WRP + ":" + subprogName;
			tracer.info && tracer.info("---------------------------------------");
			tracer.info && tracer.info("Call X3 subprogram '" + subprog + "'");
			var reply = CvgClientAbs.prototype.execAckCall.call(this, _, subprog, wsCall.debugInfo, ackCallParams, techInfo);

			// validate reply content
			var resultParams = this._validReply(reply, wsCall, 4, 3);

			//no major error, analyse parameter receive from the supervisor to check the ws call work or if we have to do something (refresh cache)
			var ww_ok = reply.json && reply.json.params && reply.json.params.length && reply.json.params[0] && reply.json.params[0].num === 0 && reply.json.params[0].resu;
			tracer.info && tracer.info("Result (" + ww_ok + ")");
			tracer.info && tracer.info("---------------------------------------");
			switch (ww_ok) {
				case 0:
					return wsCall.getSoapResponse();
				case 1:
					wsCall._computeResult(resultParams, beautify);
					return wsCall.getSoapResponse();
					// abnormal status
				case 6: // database closed
					throw new CvgWsException(locale.format(module, "sgbdClosed"));
				case 7: //must resign
					this._changeContext(_, wsCtx, wsCall, techInfo, true);
					break;
				case 8: // flush adx wrapper in memory is not coherent
					if (this._flush(_, wsCall)) {
						if (nbtry < maxNbTry) return this.execWs(_, context, params, techInfo, beautify, nbtry++);
					}
					break;
				case 9:
					// get hdat and check consistency of description cache and stamp in x3
					if (nbtry < maxNbTry) {
						return this.execWs(_, context, params, techInfo, beautify, nbtry++, true);
					}
					break;
				default:
					throw new CvgWsException(locale.format(module, "spgmNoResult", wsCall.name, ok));
			}

		} catch (e) {
			this.disconnectClient(_, {}, "failed :" + e.message + "\n" + e.stack);
			this.isConnected = false;
			if (e instanceof CvgWsException) {
				wsCall.addMessage(3, e.message);
				return wsCall.getSoapResponse(1);
			} else {
				throw e;
			}
		} finally {
			this.isFree = true;
		}
	},
	_validReply: function(reply, wsCall, msgMessIdx, msgTypeIdx) {

		var techParams = [],
			resultParams = [];
		// separate technical parameters and result parameters
		reply && reply.json.params.forEach(function(p) {
			if (p.num > 11) {
				resultParams.push(p);
			} else if (p.num != null) {
				techParams[p.num] = techParams[p.num] || {};
				techParams[p.num][p.poste] = p;
			}
		});
		//tracer.debug && tracer.debug("Technical parameters: "+JSON.stringify(techParams,null,2));
		// Manage messages
		if (msgMessIdx && techParams[msgMessIdx]) {
			for (var i = 0; i < Object.keys(techParams[msgMessIdx]).length; i++) {
				if (techParams[msgMessIdx][i]) {
					var msgType = msgTypeIdx ? techParams[msgTypeIdx][i].resu : 3;
					wsCall.addMessage(msgType, techParams[msgMessIdx][i].resu);
				}
			}
		}
		resultParams = resultParams.concat(wsCall.callParams);
		// Remove null objects for LIST operation
		if (wsCall.action === "LIST") {
			resultParams = resultParams.filter(function(p) {
				return p && p.resu != null;
			});
		}

		var result = reply && reply.json && reply.json.result;
		if (!result) {
			var extraMessages = "";
			if (this.activeRequest.lastPushedWindow) {
				extraMessages += (extraMessages.length > 0 ? "\n" : "") + locale.format(module, "errOpenWinX3", JSON.stringify(this.activeRequest.lastPushedWindow));
			}
			if (this.activeRequest && this.activeRequest.ist) {
				extraMessages += (extraMessages.length > 0 ? "\n" : "") + "AdxId returned by X3 server: " + this.activeRequest.ist.toString();
			}
			wsCall.addMessage(3, locale.format(module, "noResult", extraMessages));
			throw new CvgWsException();
		}
		return resultParams;
	},

	_getDescription: function(_, wsCall, ignoreCache) {
		wsCall.techInfo.loadWebsDuration.start();
		var _description, res;
		var x3HttpPub = this.clientConfig.getParam("x3HttpPub");
		var x3Folder = this.clientConfig.getParam("x3Folder");
		var url = x3HttpPub + "/" + x3Folder + "/GEN/ALL/WEBS/" + wsCall.name + ".xml";

		// get description in cache
		if (!ignoreCache && cacheMgr.cacheContains(url)) {
			res = cacheMgr.cache[url].resource;
			_description = jsxml.parse(res).ADXDOC;
		}
		// retrieve real description
		else {
			try {
				res = cacheMgr.getResource(_, url, null);
				_description = jsxml.parse(res).ADXDOC;
			} catch (e) {
				// Do nothing to be able to call recupHDAT
			}
			try {
				this._recupHDAT(_, wsCall, _description && _description.$.TIM, wsCall.techInfo);
			} catch (e) {
				if (e instanceof CvgWsException) {
					wsCall.addMessage(3, locale.format(module, "errorRecupHordat", RECUPHDAT, e.message, '', wsCall.name));
					return;
				}
				throw e;
			}
		}
		wsCall.techInfo.loadWebsDuration.stop();
		return _description;
	},
	/*
	 return true if the timestamp passed and the stamp in supervisor side are the same.
	 Else return false if we have a delta between cache description and timestamp in supervisor
	 in other case we raise an exception
	 */
	_recupHDAT: function(_, wsCall, stamp, techInfo) {
		tracer.info && tracer.info("---------------------------------------");
		tracer.info && tracer.info("Call X3 subprogram '" + RECUPHDAT + "'");
		techInfo.poolExecDuration.start();
		var reply = this.execAckCall(_, RECUPHDAT, wsCall.debugInfo, [{
			"decr": "WEBS",
			"dim": 1,
			"nb": 1,
			"size": wsCall.name.length,
			"typ": "STRU",
			"resu": wsCall.name
		}, {
			"decr": "HDAT",
			"dim": 1,
			"nb": stamp ? 1 : 0,
			"size": (stamp && stamp.length) || 0,
			"typ": "STRU",
			"resu": stamp || ""
		}, {
			"decr": "OK",
			"dim": 1,
			"nb": 0,
			"size": 0,
			"typ": "INT"
		}]);
		techInfo.poolExecDuration.stop();

		this._validReply(reply, wsCall);

		//no major error, analyse parameter receive from the supervisor to check the ws call work or if we have to do something (refresh cache)
		var ok = -1;
		var st = null;
		reply.json && reply.json.params && reply.json.params.forEach(function(p) {
			if (p.num === 2) {
				ok = p.resu;
			} else if (p.num === 1) {
				st = p.resu;
			}
		});
		tracer.info && tracer.info("Result (" + ok + ")");
		tracer.info && tracer.info("---------------------------------------");
		if (ok === 1) {
			return;
		} else if (ok === 0) {
			throw new CvgWsException(locale.format(module, "statusHordat0"));
		} else if (ok === 9) {
			techInfo.reloadWebs = true;
			throw new CvgWsException(locale.format(module, "statusHordat9"));
		} else {
			throw new CvgWsException(locale.format(module, "spgmNoResult", wsCall.name, ok));
		}
	},
	_changeContext: function(_, genericWsCtx, wsCall, techInfo, forceChange) {
		var isSame = true;
		var endpoint = this.poolContext.endpoint;
		var currentUser = this.poolContext.user.getEndpointLogin(_, endpoint.$uuid);
		var receiveUser = genericWsCtx.user.getEndpointLogin(_, endpoint.$uuid);
		var currentLang = this.poolContext.localePref.code(_);
		var receiveLang = genericWsCtx.localePref.code(_);
		techInfo.changeLanguage = currentLang !== receiveLang;
		techInfo.changeUserId = currentUser !== receiveUser;
		isSame = currentUser === receiveUser && currentLang === receiveLang;
		if (!isSame || forceChange) {
			this._changeLogin(_, receiveUser, locale.x3Language(receiveLang), wsCall, techInfo);
			this.poolContext = genericWsCtx;
		}
		return isSame;
	},
	/*
	 return true if the change of context works fine. Else we raise an exception with the message coming from X3 or a standard message
	 */
	_changeLogin: function(_, receiveUser, receiveLang, wsCall) {
		tracer.info && tracer.info("---------------------------------------");
		tracer.info && tracer.info("Call X3 subprogram '" + CHGLOGINXTEND + "'");
		var reply = this.execAckCall(_, CHGLOGINXTEND, wsCall.debugInfo, [{
			"decr": "OK",
			"dim": 1,
			"nb": 1,
			"size": 1,
			"typ": "INT",
			"resu": -1
		}, {
			"decr": "MESSAGE",
			"dim": 1,
			"nb": 0,
			"size": 250,
			"typ": "STRU",
		}, {
			"decr": "LOGIN",
			"dim": 1,
			"nb": 1,
			"size": receiveUser.length,
			"typ": "STRU",
			"resu": receiveUser,
		}, {
			"decr": "LANG",
			"dim": 1,
			"nb": 1,
			"size": receiveLang.length,
			"typ": "STRU",
			"resu": receiveLang
		}], wsCall.techInfo);

		this._validReply(reply, wsCall);
		//no major error, analyse parameter receive from the supervisor to check the ws call work or if we have to do something (refresh cache)
		var ok = reply.json && reply.json.params && reply.json.params.length && reply.json.params[0] && reply.json.params[0].num === 0 && reply.json.params[0].resu;
		tracer.info && tracer.info("Result (" + ok + ")");
		tracer.info && tracer.info("---------------------------------------");
	},
	/*
	 return true if the flush call works else raise an exception
	 */
	_flush: function(_, wsCall) {
		tracer.info && tracer.info("---------------------------------------");
		tracer.info && tracer.info("Call X3 subprogram '" + FLUSHADX + "'");

		var reply = this.execAckCall(_, FLUSHADX, wsCall.debugInfo, [{
			"decr": "OK",
			"dim": 1,
			"nb": 1,
			"size": 1,
			"typ": "INT",
			"resu": -1
		}], wsCall.techInfo);
		this._validReply(reply, wsCall);
		//no major error, analyse parameter receive from the supervisor to check the ws call work or if we have to do something (refresh cache)
		var ok = reply.json && reply.json.params && reply.json.params.length && reply.json.params[0] && reply.json.params[0].num === 0 && reply.json.params[0].resu;
		tracer.info && tracer.info("Result (" + ok + ")");
		tracer.info && tracer.info("---------------------------------------");
		if (ok === 1) {
			return true;
		} else if (ok === 0) {
			throw new CvgWsException(locale.format(module, "alreadyFlushAdx", wsCall.name, ok));
		} else {
			throw new CvgWsException(locale.format(module, "spgmNoResult", wsCall.name, ok));
		}
	},
	newRequest: function(reply, sendContext) {
		return new CvgRequestWS(this, reply, sendContext);
	}
});