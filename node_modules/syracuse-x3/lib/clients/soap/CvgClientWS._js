"use strict";

var locale = require("syracuse-core/lib/locale");
var util = require('util');
var helpers = require('syracuse-core/lib/helpers');
var CvgClientAbs = require("syracuse-x3/lib/clients/common/cvg/CvgClientAbs").CvgClientAbs;
var CvgRequestWS = require("syracuse-x3/lib/clients/soap/CvgRequestWS").CvgRequestWS;

var x3client = require('syracuse-x3/lib/client');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var tracerSession = require("syracuse-trace/lib/helper").getTracer("classic.session");
var jsxml = require('jsxml');
var CvgCacheManager = require('syracuse-x3/lib/cvgCacheManager').CvgCacheManager;
var cliManager = require("syracuse-soap/lib/generic/clientManager");
var CvgWSCall = require('syracuse-x3/lib/clients/soap/CvgWSCall').CvgWSCall;
var cacheMgr = new CvgCacheManager();

exports.CvgClientWS = helpers.defineClass(function(_, context) {
	// connect to the x3 server
	this.adxtype = 25; // TODO change by the WS type
	this.sid = null;

	this.isFree = false;
	this.isConnected = false;
	this.cliCfg = this._getContextConfig(_, context);
	var cli = this._connect(_, context);
	CvgClientAbs.call(this, cli.getStream(), this.cliCfg, null, context);
	this.connectStart(_, context);
}, CvgClientAbs, {
	_getContextConfig: function(_, context) { // TODO refactor to set that method in super class
		var endpoint = context.httpSession.genericWsCtx.endpoint;
		return {
			x3User: context.httpSession.genericWsCtx.user.getEndpointLogin(_, endpoint.$uuid),
			x3Host: endpoint.x3server(_).serverHost(_),
			x3Port: endpoint.x3server(_).serverPort(_),
			x3Lang: context.httpSession.genericWsCtx.localePref.code(_),
			x3HttpPub: endpoint.getWebServerBaseUrl(_),
			x3Folder: endpoint.x3ServerFolder(_),
			x3Solution: endpoint.x3SolutionName(_),
			appHost: endpoint.x3server(_).serverName(_),
			dataset: endpoint.dataset(_) // necessary for scoring system
		};
	},

	_connect: function(_, context) { // TODO refactor to set that method in super class

		// TODO : runtime config must be set somewhere.
		var runtimeConfig = (context.httpSession && context.httpSession.x3SessionConfig && context.httpSession.x3SessionConfig.runtime) || {};
		var adminEP = adminHelper.getCollaborationEndpoint(_);
		var sessionCtx = context.httpSession.genericWsCtx;

		var client = x3client.create({
			port: this.cliCfg.x3Port,
			address: this.cliCfg.x3Host,
			tracer: tracerSession
		});

		var _x3 = client.connect(_, {
			server: this.cliCfg.appHost,
			folder: this.cliCfg.x3Folder,
			fusion: true,
			locale: this.cliCfg.x3Lang,
			runtimeLog: !runtimeConfig.dataset || sessionCtx.endpoint.dataset(_) === runtimeConfig.dataset ? runtimeConfig.logFlag : "",
			runtimeLogDir: !runtimeConfig.dataset || sessionCtx.endpoint.dataset(_) === runtimeConfig.dataset ? runtimeConfig.logDir : ""

		});
		this.cliCfg.x3Pid = "" + _x3.pid;
		this.cliCfg.x3SessionUrl = _x3.sessionUrl;
		this.cliCfg.x3SessionId = _x3.sessionId;

		var sysAuthToken;
		if (sessionCtx.user && sessionCtx.user.infov6(_)) {
			sysAuthToken = new Buffer(sessionCtx.user.userv6(_) + ":" + sessionCtx.user.passwordv6(_), "utf8").toString("base64");
		}

		this.sid = client.createSession(_, {
			locale: this.cliCfg.x3Lang,
			userName: this.cliCfg.x3User,
			adxtyp: this.adxtype,
			sysAuthToken: sysAuthToken,
			fusionTech: {
				protocol: "150067",
			},
			localePreferences: sessionCtx.localePref,
			baseUrl: context.baseUrl,
			collaborationBaseUrl: adminEP ? context.request.session.host + adminHelper.getCollaborationEndpoint(_).getBaseUrl(_) : "",
			peerAddress: (context.httpSession.getData("requestInfo") || {}).peerAddress
		});
		this.isFree = true;
		this.isConnected = true;
		return client;
	},
	_checkContext: function(_, genericWsCtx) {
		// TODO
		return true;
	},
	disconnectClient: function(_, params, reason, tracker) {
		CvgClientAbs.prototype.disconnectClient.call(this, _, params, reason, tracker);
		cliManager.disconnect(this.uuid);
		this.isConnected = false;
	},
	execWS: function(_, context, params, techInfo) {
		try {
			var wsCtx = context.httpSession.genericWsCtx;
			this.isFree = false;
			if (!this._checkContext(_, wsCtx)) {
				this._changeLogin(_, wsCtx);
			}

			var wsCall = new CvgWSCall(params);

			var description = jsxml.parse(this._getDescription(_, wsCall.name, techInfo)).ADXDOC;

			// try to simulate bad TIM to identify the error to catch before retry
			//description.$.TIM = "20111107154510";

			// add technical parameter for web-service
			var params = [{
				"descr": "WW_OK",
				"dim": 1,
				"nb": 1,
				"size": 0,
				"typ": "INT",
				"resu": -1
			}, {
				"descr": "WW_ZONE",
				"dim": 1,
				"nb": 0,
				"size": 30,
				"typ": "STRU",
			}, {
				"descr": "WW_STAT",
				"dim": 1,
				"nb": 0,
				"size": 0,
				"typ": "INT",
			}, {
				"descr": "WW_GRAVE",
				"dim": 50,
				"nb": 0,
				"size": 0,
				"typ": "INT",
			}, {
				"descr": "WW_MESS",
				"dim": 50,
				"nb": 0,
				"size": 250,
				"typ": "STRU",
			}, {
				"descr": "WW_ACTION",
				"dim": 1,
				"nb": wsCall.action ? 1 : 0,
				"size": 4,
				"typ": "STRU",
				"resu": wsCall.action
			}, {
				"descr": "WW_IDENT",
				"dim": 1,
				"nb": wsCall.wkeys && wsCall.wkeys.length !== 0 ? 1 : 0,
				"size": 250,
				"typ": "STRU",
				"resu": wsCall.wkeys && wsCall.wkeys.length !== 0 && wsCall.wkeys.join("~")
			}, {
				"descr": "WW_NB",
				"dim": 1,
				"nb": wsCall.nb ? 1 : 0,
				"size": 0,
				"typ": "INT",
				"resu": wsCall.nb
			}, {
				"descr": "WW_HORDAT",
				"dim": 1,
				"nb": 1,
				"size": 14,
				"typ": "STRU",
				"resu": description.$.TIM
			}, {
				"descr": "WW_TAB",
				"dim": 1,
				"nb": wsCall.tab ? 1 : 0,
				"size": wsCall.tab && wsCall.tab.length || 0,
				"typ": "STRU",
				"resu": wsCall.tab
			}, {
				"descr": "WW_PAR",
				"dim": 1,
				"nb": wsCall.par ? 1 : 0,
				"size": wsCall.par && wsCall.par.length || 0,
				"typ": "STRU",
				"resu": wsCall.par
			}, {
				"descr": "WW_TRACE",
				"dim": 1,
				"nb": 0,
				"size": 8,
				"typ": "CLOB",
				"resu": ""
			}];


			// add functional parameter
			var paramsCall = wsCall.getAckCallParams(description);
			paramsCall && paramsCall.forEach(function(param) {
				params.push(param);
			});

			console.log("ackcall_param " + JSON.stringify(params, null, 2));
			var reply = CvgClientAbs.prototype.execAckCall.call(this, _, description.$.WRP + ":" + description.$.SPG, wsCall.debugInfo, params);
			//analyse reply for a web-service we have the status
			var result = reply && reply.json && reply.json.result;
			if (!(result && !result.errn && !result.errm)) {
				//an error occurs raise an error
				throw new Error(result ? ("X3 Error:" + result.errp + ", message:" + result.errm + ", line :" + result.errl + ", type:" + result.errt) : "can't get result from X3");
			} else {
				//no major error, analyse parameter receive from the supervisor to check the ws call work or if we have to do something (refresh cache)
				var ww_ok = reply.json && reply.json.params && reply.json.params.length && reply.json.params[0].resu;
				switch (ww_ok) {
					case -1:
						break;
						// ok status
					case 0:
					case 1:
						// filter to compute the result only on non technical parameter


						break;
						// abnormal status
					case 6: // database closed
						throw new Error(locale.format(module, "dbmsClosed"));
						break;
					case 7: //must resign
						this._changeLogin(_, context);
						break;
					case 8: // flush adx wrapper in memory is not coherent
						this._flush(_);
						this.execWs(_, context, params, techInfo);
						break;
					default:
						throw new Error(locale.format(module, "failedExec"));

				}
			}
		} catch (e) {
			this.disconnectClient(_, {}, "failed :" + e.message + "\n" + e.stack);
			this.isConnected = false;
			throw e;
		} finally {
			this.isFree = true;

		}

	},
	_getDescription: function(_, wsName, techInfo, ignoreCache) {
		techInfo.loadWebsDuration.start();
		var res;
		var x3HttpPub = this.clientConfig.getParam("x3HttpPub");
		var x3Folder = this.clientConfig.getParam("x3Folder");
		var url = x3HttpPub + "/" + x3Folder + "/GEN/ALL/WEBS/" + wsName + ".xml";
		if (!ignoreCache && cacheMgr.cacheContains(url)) {
			res = cacheMgr.cache[url].resource;
		} else {
			res = cacheMgr.getResource(_, url, null);
			techInfo.reloadWebs = true;
		}
		techInfo.loadWebsDuration.stop();
		return res;
	},
	_recupHDAT: function(_, wsName, debugInfo, params) {
		//TODO
	},

	_changeLogin: function(_, wsCtx) {
		//TODO
	},

	_flush: function(_) {

	},

	newRequest: function(reply, sendContext) {
		return new CvgRequestWS(this, reply, sendContext);
	}



});