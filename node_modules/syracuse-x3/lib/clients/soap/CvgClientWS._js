"use strict";

var locale = require("syracuse-core/lib/locale");
var util = require('util');
var helpers = require('syracuse-core/lib/helpers');
var CvgClientAbs = require("syracuse-x3/lib/clients/common/cvg/CvgClientAbs").CvgClientAbs;
var CvgRequestWS = require("syracuse-x3/lib/clients/soap/CvgRequestWS").CvgRequestWS;
var OfflinePlayer = require('syracuse-x3/lib/clients/common/offlinePlayer').OfflinePlayer;
var upath = require('path');
var recordMgr = require("syracuse-x3/lib/convergence/records/recordMgr").recordMgr;
var ufs = require('fs');

var x3client = require('syracuse-x3/lib/client');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
//var tracerSession = require("syracuse-trace/lib/helper").getTracer("classic.session");
var jsxml = require('jsxml');
var CvgCacheManager = require('syracuse-x3/lib/cvgCacheManager').CvgCacheManager;
var cliManager = require("syracuse-soap/lib/generic/clientManager");
var CvgWSCall = require('syracuse-x3/lib/clients/soap/CvgWSCall').CvgWSCall;
var cacheMgr = new CvgCacheManager();

var maxNbTry = 2; // TODO configure that point

exports.CvgClientWS = helpers.defineClass(function(_, context, recOptions) {
	function readJsonPlayer(_, path) {
		var json;
		try {
			json = ufs.readFileSync(path, 'utf8') || "";
			json = json.trim();
			if (json.length === 0) throw new Error("Empty file");
			if (json[json.length - 1] === ',') json = json.substring(0, json.length - 1);
			json = "[" + json + "]";
		} catch (e) {
			throw e;
		}
		try {
			json = JSON.parse(json);
			return json;
		} catch (e) {
			throw e;
		}
		return null;
	}
	// connect to the x3 server
	this.adxtype = 25; // TODO change by the WS type
	this.sid = null;
	var configRecords = {};
	if (recOptions && recOptions.path) {
		configRecords = {
			dumpPath: upath.join(process.mainModule.filename.substring(0, process.mainModule.filename.indexOf("node_modules")), recOptions.path)
		};
	}
	this.isFree = false;
	this.isConnected = false;
	this.poolContext = context.httpSession.genericWsCtx;
	this.cliCfg = this._getContextConfig(_);
	var stream = null;
	if (recOptions && recOptions.recMode === 'PLAY') {
		// create player regarding the recOptions
		stream = new OfflinePlayer(_, readJsonPlayer(_, configRecords.dumpPath + "/cvgRecords/" + recOptions.fileName));
	} else {
		stream = this._connect(_, context, recOptions).getStream();
		if (recOptions && recOptions.recMode === 'REC')
			this.recorder = recordMgr.newRecorder(_, stream, recOptions, {}, configRecords);

	}
	CvgClientAbs.call(this, stream, this.cliCfg, null, context);
	this.connectStart(_, context);
}, CvgClientAbs, {
	_getContextConfig: function(_) { // TODO refactor to set that method in super class
		var endpoint = this.poolContext.endpoint;
		return {
			x3User: this.poolContext.user.getEndpointLogin(_, endpoint.$uuid),
			x3Host: endpoint.x3server(_).serverHost(_),
			x3Port: endpoint.x3server(_).serverPort(_),
			x3Lang: this.poolContext.localePref.code(_),
			x3HttpPub: endpoint.getWebServerBaseUrl(_),
			x3Folder: endpoint.x3ServerFolder(_),
			x3Solution: endpoint.x3SolutionName(_),
			appHost: endpoint.x3server(_).serverName(_),
			dataset: endpoint.dataset(_) // necessary for scoring system
		};
	},

	_connect: function(_, context, recOptions) { // TODO refactor to set that method in super class
		if (recOptions && recOptions.recmode === 'REC') {
			// TODO add a handle for recording
		}
		var runtimeConfig = (context.httpSession && context.httpSession.x3SessionConfig && context.httpSession.x3SessionConfig.runtime) || {};
		var adminEP = adminHelper.getCollaborationEndpoint(_);
		var sessionCtx = context.httpSession.genericWsCtx;

		var client = x3client.create({
			port: this.cliCfg.x3Port,
			address: this.cliCfg.x3Host,
			//tracer: tracerSession
		});

		var _x3 = client.connect(_, {
			server: this.cliCfg.appHost,
			folder: this.cliCfg.x3Folder,
			fusion: true,
			locale: this.cliCfg.x3Lang,
			runtimeLog: !runtimeConfig.dataset || sessionCtx.endpoint.dataset(_) === runtimeConfig.dataset ? runtimeConfig.logFlag : "",
			runtimeLogDir: !runtimeConfig.dataset || sessionCtx.endpoint.dataset(_) === runtimeConfig.dataset ? runtimeConfig.logDir : ""

		});
		this.cliCfg.x3Pid = "" + _x3.pid;
		this.cliCfg.x3SessionUrl = _x3.sessionUrl;
		this.cliCfg.x3SessionId = _x3.sessionId;

		var sysAuthToken;
		if (sessionCtx.user && sessionCtx.user.infov6(_)) {
			sysAuthToken = new Buffer(sessionCtx.user.userv6(_) + ":" + sessionCtx.user.passwordv6(_), "utf8").toString("base64");
		}

		this.sid = client.createSession(_, {
			locale: this.cliCfg.x3Lang,
			userName: this.cliCfg.x3User,
			adxtyp: this.adxtype,
			sysAuthToken: sysAuthToken,
			fusionTech: {
				protocol: "150067",
			},
			localePreferences: sessionCtx.localePref,
			baseUrl: context.baseUrl,
			collaborationBaseUrl: adminEP ? context.request.session.host + adminHelper.getCollaborationEndpoint(_).getBaseUrl(_) : "",
			peerAddress: (context.httpSession.getData("requestInfo") || {}).peerAddress
		});
		this.isFree = true;
		this.isConnected = true;
		return client;
	},
	_changeContext: function(_, genericWsCtx, debugInfo, techInfo, forceChange) {
		var isSame = true;
		var endpoint = this.poolContext.endpoint;
		var currentUser = this.poolContext.user.getEndpointLogin(_, endpoint.$uuid);
		var receiveUser = genericWsCtx.user.getEndpointLogin(_, endpoint.$uuid);
		var currentLang = this.poolContext.localePref.code(_);
		var receiveLang = genericWsCtx.localePref.code(_);
		techInfo.changeLanguage = !(currentLang === receiveLang);
		techInfo.changeUserId = !(currentUser === receiveUser);


		isSame = currentUser === receiveUser && currentLang === receiveLang;
		if (!isSame || forceChange) {

			this._changeLogin(_, receiveUser, locale.x3Language(receiveLang), debugInfo);
			this.poolContext = genericWsCtx;
		}
		return isSame;
	},
	disconnectClient: function(_, params, reason, tracker) {
		CvgClientAbs.prototype.disconnectClient.call(this, _, params, reason, tracker);
		cliManager.disconnect(this.uuid);
		this.recorder && this.recorder.close();
		this.stream = null;
		this.isConnected = false;
	},
	execWS: function(_, context, params, techInfo, nbtry) {
		try {
			techInfo.poolExecDuration.start();
			techInfo.poolEntryIdx = this.uuid;
			var wsCtx = context.httpSession.genericWsCtx;
			this.isFree = false;
			nbtry = nbtry || 1;

			var wsCall = new CvgWSCall(params);
			// change context is it's necessary
			this._changeContext(_, wsCtx, wsCall.debugInfo, techInfo);

			var description = jsxml.parse(this._getDescription(_, wsCall.name, techInfo)).ADXDOC;


			// add technical parameter for web-service
			var paramsCall = wsCall.getAckCallParams(description);

			var params = [{
				"descr": "WW_OK",
				"dim": 1,
				"nb": 1,
				"size": 0,
				"typ": "INT",
				"resu": -1
			}, {
				"descr": "WW_ZONE",
				"dim": 1,
				"nb": 0,
				"size": 30,
				"typ": "STRU",
			}, {
				"descr": "WW_STAT",
				"dim": 1,
				"nb": 0,
				"size": 0,
				"typ": "INT",
			}, {
				"descr": "WW_GRAVE",
				"dim": 50,
				"nb": 0,
				"size": 0,
				"typ": "INT",
			}, {
				"descr": "WW_MESS",
				"dim": 50,
				"nb": 0,
				"size": 250,
				"typ": "STRU",
			}, {
				"descr": "WW_ACTION",
				"dim": 1,
				"nb": wsCall.action ? 1 : 0,
				"size": 4,
				"typ": "STRU",
				"resu": wsCall.action
			}, {
				"descr": "WW_IDENT",
				"dim": 1,
				"nb": wsCall.wkeys ? 1 : 0,
				"size": 250,
				"typ": "STRU",
				"resu": wsCall.wkeys
			}, {
				"descr": "WW_NB",
				"dim": 1,
				"nb": wsCall.nb ? 1 : 0,
				"size": 0,
				"typ": "INT",
				"resu": wsCall.nb
			}, {
				"descr": "WW_HORDAT",
				"dim": 1,
				"nb": 1,
				"size": 14,
				"typ": "STRU",
				"resu": description.$.TIM
			}, {
				"descr": "WW_TAB",
				"dim": 1,
				"nb": wsCall.tab ? 1 : 0,
				"size": wsCall.tab && wsCall.tab.length || 0,
				"typ": "STRU",
				"resu": wsCall.tab
			}, {
				"descr": "WW_PAR",
				"dim": 1,
				"nb": wsCall.par ? 1 : 0,
				"size": wsCall.par && wsCall.par.length || 0,
				"typ": "STRU",
				"resu": wsCall.par
			}, {
				"descr": "WW_TRACE",
				"dim": 1,
				"nb": 0,
				"size": 8,
				"typ": "CLOB",
				"resu": ""
			}];


			// add functional parameter
			paramsCall && paramsCall.forEach(function(param) {
				params.push(param);
			});
			var reply = CvgClientAbs.prototype.execAckCall.call(this, _, description.$.WRP + ":" + (description.$.SPG || "OBJET"), wsCall.debugInfo, params);
			//analyse reply for a web-service we have the status
			var result = reply && reply.json && reply.json.result;

			if (!(result && !result.errn && !result.errm)) {
				//an error occurs raise an error
				throw new Error(result ? ("X3 Error:" + result.errp + ", message:" + result.errm + ", line :" + result.errl + ", type:" + result.errt) : "can't get result from X3");
			} else {
				//no major error, analyse parameter receive from the supervisor to check the ws call work or if we have to do something (refresh cache)
				var ww_ok = reply.json && reply.json.params && reply.json.params.length && reply.json.params[0] && reply.json.params[0].num === 0 && reply.json.params[0].resu;
				switch (ww_ok) {
					case 0:
					case 1:
						// filter to compute the result only on non technical parameter
						var paramsResult = reply.json.params.filter(function(param) {
							return param.num > 11; // not include technical parameter
						});
						paramsResult = paramsResult.concat(paramsCall);
						return wsCall.generateResult(description, paramsResult, this._x3SessionSettings.cdLang);

						// abnormal status
					case 6: // database closed
						throw new Error(locale.format(module, "dbmsClosed"));
						break;
					case 7: //must resign
						this._changeContext(_, wsCtx, wsCall.debugInfo, techInfo, true);
						break;
					case 8: // flush adx wrapper in memory is not coherent
						this._flush(_, wsCall.debugInfo);
						if (nbtry < maxNbTry)
							return this.execWs(_, context, params, techInfo, nbtry++);
						break;
					case 9:
						// get hdat and check consistency of description cache and stamp in x3
						techInfo.reloadWebs = true;
						this._recupHDAT(_, description.$.TIM, wsCall.debugInfo, techInfo);
						if (nbtry < maxNbTry)
							return this.execWs(_, context, params, techInfo, nbtry++);
						break;
					default:
						throw new Error(locale.format(module, "failedExec", ww_ok));

				}
			}
		} catch (e) {
			this.disconnectClient(_, {}, "failed :" + e.message + "\n" + e.stack);
			this.isConnected = false;
			throw e;
		} finally {
			techInfo.poolExecDuration.stop();
			this.isFree = true;

		}

	},
	_getDescription: function(_, wsName, techInfo, ignoreCache) {
		techInfo.loadWebsDuration.start();
		var res;
		var x3HttpPub = this.clientConfig.getParam("x3HttpPub");
		var x3Folder = this.clientConfig.getParam("x3Folder");
		var url = x3HttpPub + "/" + x3Folder + "/GEN/ALL/WEBS/" + wsName + ".xml";
		if (!ignoreCache && cacheMgr.cacheContains(url)) {
			res = cacheMgr.cache[url].resource;
		} else {
			res = cacheMgr.getResource(_, url, null);
			techInfo.reloadWebs = true;
		}
		techInfo.loadWebsDuration.stop();
		return res;
	},
	/*
	 return true if the timestamp passed and the stamp in supervisor side are the same.
	 Else return false if we have a delta between cache description and timestamp in supervisor
	 in other case we raise an exception
	 */
	_recupHDAT: function(_, wsName, stamp, debugInfo, techInfo) {
		var reply = this.execAckCall(_, "AWEB:RECUPHDAT", debugInfo, [{
			"decr": "WEBS",
			"dim": 1,
			"nb": 1,
			"size": wsName.length,
			"typ": "STRU",
			"resu": wsName
		}, {
			"decr": "HDAT",
			"dim": 1,
			"nb": 1,
			"size": stamp.length,
			"typ": "STRU",
			"resu": stamp
		}, {
			"decr": "OK",
			"dim": 1,
			"nb": 0,
			"size": 0,
			"typ": "INT"
		}]);
		var result = reply && reply.json && reply.json.result;
		if (!(result && !result.errn && !result.errm)) {
			//an error occurs raise an error
			throw new Error(result ? ("X3 Error:" + result.errp + ", message:" + result.errm + ", line :" + result.errl + ", type:" + result.errt) : "can't get result from X3");
		} else {
			//no major error, analyse parameter receive from the supervisor to check the ws call work or if we have to do something (refresh cache)
			var ok = -1;
			var st = null;
			reply.json && reply.json.params && reply.json.params.forEach(function(p) {
				if (p.num === 2) {
					ok = p.resu;
				} else if (p.num === 1) {
					st = p.resu;
				}
			});
			if (ok === 1) {
				return true;
			} else if (ok === 0) {
				throw new Error("Web Service unknown " + wsName);
			} else if (ok === 9) {
				// get again the cache description and check the stamp

				techInfo.reloadWebs = true;
				var description = jsxml.parse(this._getDescription(_, wsName, techInfo)).ADXDOC;
				if (description.$.TIM === st) {
					return true;
				} else {
					return false;
				}
				return false;
			} else if (ok === 6) { // pb dbms
				throw new Error("X3 Error: dbms connection failure");
			} else {
				var message = reply.json && reply.json.params && reply.json.params.length && reply.json.params[1] && reply.json.params[1].num === 1 && reply.json.params[1].resu;
				// display message received
				throw new Error("X3 Error: " + (message ? message : "can't recup hdat"));

			}
		}
	},

	/*
	 return true if the change of context works fine. Else we raise an exception with the message coming from X3 or a standard message
	 */
	_changeLogin: function(_, receiveUser, receiveLang, debugInfo) {
		var reply = this.execAckCall(_, "CHGUSR:CHGLOGINXTEND", debugInfo, [{
			"decr": "OK",
			"dim": 1,
			"nb": 1,
			"size": 1,
			"typ": "INT",
			"resu": -1
		}, {
			"decr": "MESSAGE",
			"dim": 1,
			"nb": 0,
			"size": 250,
			"typ": "STRU",
		}, {
			"decr": "LOGIN",
			"dim": 1,
			"nb": 1,
			"size": receiveUser.length,
			"typ": "STRU",
			"resu": receiveUser,
		}, {
			"decr": "LANG",
			"dim": 1,
			"nb": 1,
			"size": receiveLang.length,
			"typ": "STRU",
			"resu": receiveLang
		}]);
		var result = reply && reply.json && reply.json.result;

		if (!(result && !result.errn && !result.errm)) {
			//an error occurs raise an error
			throw new Error(result ? ("X3 Error:" + result.errp + ", message:" + result.errm + ", line :" + result.errl + ", type:" + result.errt) : "can't get result from X3");
		} else {
			//no major error, analyse parameter receive from the supervisor to check the ws call work or if we have to do something (refresh cache)
			var ok = reply.json && reply.json.params && reply.json.params.length && reply.json.params[0] && reply.json.params[0].num === 0 && reply.json.params[0].resu;
			if (ok === 1) {
				return true;
			} else if (ok === 6) { // pb dbms
				throw new Error("X3 Error: dbms connection failure");

			} else {
				var message = reply.json && reply.json.params && reply.json.params.length && reply.json.params[1] && reply.json.params[1].num === 1 && reply.json.params[1].resu;

				// display message received
				throw new Error("X3 Error: " + (message ? message : "can't change context"));

			}
		}
	},
	/*
	 return true if the flush call works else raise an exception
	 */
	_flush: function(_, debugInfo) {
		var reply = this.execAckCall(_, "AFLUSHADX:FLUSHADX", debugInfo, [{
			"decr": "OK",
			"dim": 1,
			"nb": 1,
			"size": 1,
			"typ": "INT",
			"resu": -1
		}]);
		var result = reply && reply.json && reply.json.result;

		if (!(result && !result.errn && !result.errm)) {
			//an error occurs raise an error
			throw new Error(result ? ("X3 Error:" + result.errp + ", message:" + result.errm + ", line :" + result.errl + ", type:" + result.errt) : "can't get result from X3");
		} else {
			//no major error, analyse parameter receive from the supervisor to check the ws call work or if we have to do something (refresh cache)
			var ok = reply.json && reply.json.params && reply.json.params.length && reply.json.params[0] && reply.json.params[0].num === 0 && reply.json.params[0].resu;
			if (ok === 1) {
				return true;
			} else if (ok === 6) { // pb dbms
				throw new Error("X3 Error: dbms connection failure");
			} else {
				var message = reply.json && reply.json.params && reply.json.params.length && reply.json.params[1] && reply.json.params[1].num === 1 && reply.json.params[1].resu;

				// display message received
				throw new Error("X3 Error: " + (message ? message : "can't change context"));

			}
		}
	},
	newRequest: function(reply, sendContext) {
		return new CvgRequestWS(this, reply, sendContext);
	}



});