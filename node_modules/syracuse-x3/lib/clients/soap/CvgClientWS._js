"use strict";

var locale = require("syracuse-core/lib/locale");
var helpers = require('syracuse-core/lib/helpers');
var CvgClientAbs = require("syracuse-x3/lib/clients/common/cvg/CvgClientAbs").CvgClientAbs;
var CvgRequestWS = require("syracuse-x3/lib/clients/soap/CvgRequestWS").CvgRequestWS;
var CvgWsException = require("syracuse-x3/lib/clients/soap/CvgWsException").CvgWsException;
var OfflinePlayer = require('syracuse-x3/lib/clients/common/offlinePlayer').OfflinePlayer;
var upath = require('path');
var recordMgr = require("syracuse-x3/lib/convergence/records/recordMgr").recordMgr;
var ufs = require('fs');

var x3client = require('syracuse-x3/lib/client');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
//var tracerSession = require("syracuse-trace/lib/helper").getTracer("classic.session");
var jsxml = require('jsxml');
var CvgCacheManager = require('syracuse-x3/lib/cvgCacheManager').CvgCacheManager;
var poolManager = require("syracuse-soap/lib/generic/poolManager");
var cacheMgr = new CvgCacheManager();

var tracer = require("syracuse-trace/lib/helper").getTracer("soap-generic.ackcall");

var RECUPHDAT = "AWEB:RECUPHDAT";
var CHGLOGINXTEND = "CHGUSR:CHGLOGINXTEND";
var FLUSHADX = "AFLUSHADX:FLUSHADX";

var maxNbTry = 2;

exports.CvgClientWS = helpers.defineClass(function() {
	CvgClientAbs.call(this);
}, CvgClientAbs, {
	init: function(_, context, callContext, recOptions) {
		function readJsonPlayer(_, path) {
			var json;
			try {
				json = ufs.readFileSync(path, 'utf8') || "";
				json = json.trim();
				if (json.length === 0) throw new Error("Empty file");
				if (json[json.length - 1] === ',') json = json.substring(0, json.length - 1);
				json = "[" + json + "]";
			} catch (e) {
				throw e;
			}
			try {
				json = JSON.parse(json);
				return json;
			} catch (e) {
				throw e;
			}
			return null;
		}
		// connect to the x3 server
		this.sid = null;
		var configRecords = {};
		if (recOptions && recOptions.path) {
			configRecords = {
				dumpPath: upath.join(process.mainModule.filename.substring(0, process.mainModule.filename.indexOf("node_modules")), recOptions.path)
			};
		}
		this.cliCfg = this._getContextConfig(_, callContext);
		var stream = null;
		this.recOptions = recOptions;
		if (recOptions && recOptions.recMode === 'PLAY') {
			// create player regarding the recOptions
			stream = new OfflinePlayer(_, readJsonPlayer(_, configRecords.dumpPath + "/cvgRecords/" + recOptions.fileName));
			this.recOptions.player = stream;
		} else {
			stream = this._connect(_, context, callContext, recOptions).getStream();
			if (recOptions && recOptions.recMode === 'REC') {
				// create recorder regarding the recOptions
				this.recorder = recordMgr.newRecorder(_, stream, recOptions, {}, configRecords);
				this.recOptions.recorder = this.recorder;
			}
		}
		CvgClientAbs.prototype.init.call(this, stream, this.cliCfg, null, context);
		this.adxtype = 12;
		this.connectStart(_, context);
		this.setFree(_, callContext);
		return this;
	},
	setFree: function(callContext) {
		// The pool can have been destroyed during the connection
		var pool = poolManager.getPool(this.cliCfg.poolAlias);
		if (pool && !callContext.reserved) {
			pool.free(this);
		}
	},
	// Override super
	execAckCall: function(_, subprogName, ackCallParams, wsCall) {
		wsCall.techInfo.poolExecDuration.start();
		var reply;
		try {
			reply = CvgClientAbs.prototype.execAckCall.call(this, _, subprogName, wsCall.debugInfo, ackCallParams);
		} finally {
			wsCall.techInfo.poolExecDuration.stop();
		}
		return reply;
	},
	_getContextConfig: function(_, callContext) { // TODO refactor to set that method in super class
		var endpoint = callContext.endpoint;
		return {
			x3User: callContext.user.getEndpointLogin(_, endpoint.$uuid),
			x3Host: endpoint.x3server(_).serverHost(_),
			x3Port: endpoint.x3server(_).serverPort(_),
			x3Lang: callContext.localePref.code(_),
			x3HttpPub: endpoint.getWebServerBaseUrl(_),
			x3Folder: endpoint.x3ServerFolder(_),
			x3Solution: endpoint.x3SolutionName(_),
			appHost: endpoint.x3server(_).serverName(_),
			dataset: endpoint.dataset(_),
			poolAlias: callContext.poolAlias
		};
	},

	_connect: function(_, context, callContext, recOptions) {
		var runtimeConfig = (context.httpSession && context.httpSession.x3SessionConfig && context.httpSession.x3SessionConfig.runtime) || {};
		var adminEP = adminHelper.getCollaborationEndpoint(_);

		var client = x3client.create({
			port: this.cliCfg.x3Port,
			address: this.cliCfg.x3Host,
			//tracer: tracerSession
		});

		var _x3 = client.connect(_, {
			server: this.cliCfg.appHost,
			folder: this.cliCfg.x3Folder,
			fusion: true,
			locale: this.cliCfg.x3Lang,
			runtimeLog: !runtimeConfig.dataset || this.cliCfg.dataset === runtimeConfig.dataset ? runtimeConfig.logFlag : "",
			runtimeLogDir: !runtimeConfig.dataset || this.cliCfg.dataset === runtimeConfig.dataset ? runtimeConfig.logDir : ""

		});
		this.cliCfg.x3Pid = "" + _x3.pid;
		this.cliCfg.x3SessionUrl = _x3.sessionUrl;
		this.cliCfg.x3SessionId = _x3.sessionId;

		var sysAuthToken;
		if (callContext.user && callContext.user.infov6(_)) {
			sysAuthToken = new Buffer(callContext.user.userv6(_) + ":" + callContext.user.passwordv6(_), "utf8").toString("base64");
		}

		var session = context.httpSession || context.session;
		var peer = session && (session.getData("requestInfo") || {}).peerAddress;
		this.sid = client.createSession(_, {
			locale: this.cliCfg.x3Lang,
			userName: this.cliCfg.x3User,
			adxtyp: this.adxtype,
			sysAuthToken: sysAuthToken,
			fusionTech: {
				protocol: "150067",
			},
			localePreferences: callContext.localePref,
			baseUrl: context.baseUrl,
			collaborationBaseUrl: adminEP && session ? session.host + adminHelper.getCollaborationEndpoint(_).getBaseUrl(_) : "",
			peerAddress: peer
		});
		return client;
	},

	disconnectClient: function(_, params, reason, tracker) {
		CvgClientAbs.prototype.disconnectClient.call(this, _, params, reason, tracker);
		this.recorder && this.recorder.close();
		this.stream = null;
	},
	execWs: function(_, context, wsCall, nbtry, ignoreCache) {
		wsCall.techInfo.poolEntryIdx = this.cliCfg.x3Pid;
		nbtry = nbtry || 1;

		try {
			// change context is it's necessary
			this._changeContext(_, wsCall);

			// get description
			var description = this._getDescription(_, context, wsCall, ignoreCache);
			if (!description) return wsCall.getSoapResponse(1);

			// special actions
			switch (wsCall.action) {
				case "GETSCHEMA": // Not sure exactly the same !!!
				case "GETDESCR":
					wsCall.result = '<?xml version="1.0" encoding="utf-8"?>\n' + jsxml.stringify({
						ADXDOC: description
					}, {
						indent: '\t'
					});
					return wsCall.getSoapResponse(1);
				default:
					break;
			}

			// add technical parameter for web-service
			wsCall.setAckCallParams(description);

			var ackCallParams = [{
				"descr": "WW_OK",
				"dim": 1,
				"nb": 1,
				"size": 0,
				"typ": "INT",
				"resu": -1
			}, {
				"descr": "WW_ZONE",
				"dim": 1,
				"nb": 0,
				"size": 30,
				"typ": "STRU",
			}, {
				"descr": "WW_STAT",
				"dim": 1,
				"nb": 0,
				"size": 0,
				"typ": "INT",
			}, {
				"descr": "WW_GRAVE",
				"dim": 50,
				"nb": 0,
				"size": 0,
				"typ": "INT",
			}, {
				"descr": "WW_MESS",
				"dim": 50,
				"nb": 0,
				"size": 250,
				"typ": "STRU",
			}, {
				"descr": "WW_ACTION",
				"dim": 1,
				"nb": wsCall.action ? 1 : 0,
				"size": wsCall.action.length,
				"typ": "STRU",
				"resu": wsCall.action
			}, {
				"descr": "WW_IDENT",
				"dim": 1,
				"nb": wsCall.wkeys ? 1 : 0,
				"size": 250,
				"typ": "STRU",
				"resu": wsCall.wkeys
			}, {
				"descr": "WW_NB",
				"dim": 1,
				"nb": wsCall.nb ? 1 : 0,
				"size": 0,
				"typ": "INT",
				"resu": wsCall.nb
			}, {
				"descr": "WW_HORDAT",
				"dim": 1,
				"nb": 1,
				"size": 14,
				"typ": "STRU",
				"resu": description.$.TIM
			}, {
				"descr": "WW_TAB",
				"dim": 1,
				"nb": wsCall.tab ? 1 : 0,
				"size": wsCall.tab && wsCall.tab.length || 0,
				"typ": "STRU",
				"resu": wsCall.tab
			}, {
				"descr": "WW_PAR",
				"dim": 10,
				"nb": wsCall.par && wsCall.par.length || 0,
				"size": 250,
				"typ": "STRU",
				"resu": wsCall.par
			}, {
				"descr": "WW_TRACE",
				"dim": 1,
				"nb": 0,
				"size": 8,
				"typ": "CLOB",
				"resu": ""
			}];


			// add functional parameter
			wsCall.callParams && wsCall.callParams.forEach(function(param) {
				ackCallParams.push(param);
			});

			//tracer.debug && tracer.debug("ACKCALL PARAMS: " + JSON.stringify(ackCallParams, null, 2));
			var subprogName = description.$.SPG || (wsCall.action === "LIST" ? "LISTE" : "OBJET");
			// Process ackcall
			var subprog = description.$.WRP + ":" + subprogName;
			tracer.info && tracer.info("---------------------------------------");
			tracer.info && tracer.info("Call X3 subprogram '" + subprog + "'");
			var reply = this.execAckCall(_, subprog, ackCallParams, wsCall);
			// validate reply content
			var resultParams = this._validReply(reply, wsCall, 4, 3);

			//no major error, analyse parameter receive from the supervisor to check the ws call work or if we have to do something (refresh cache)
			var ww_ok = reply.json && reply.json.params && reply.json.params.length && reply.json.params[0] && reply.json.params[0].num === 0 && reply.json.params[0].resu;
			tracer.info && tracer.info("Result (" + ww_ok + ")");
			tracer.info && tracer.info("---------------------------------------");
			switch (ww_ok) {
				case 0:
					return wsCall.getSoapResponse(0);
				case 1:
					wsCall.computeResult(resultParams);
					return wsCall.getSoapResponse();
					// abnormal status
				case 6: // database closed
					throw new CvgWsException(locale.format(module, "sgbdClosed"));
				case 7: //must resign
					this._changeContext(_, wsCall, true);
					break;
				case 8: // flush adx wrapper in memory is not coherent
					if (this._flush(_, wsCall)) {
						if (nbtry < maxNbTry) return this.execWs(_, context, wsCall, nbtry++);
					}
					break;
				case 9:
					// get hdat and check consistency of description cache and stamp in x3
					if (nbtry < maxNbTry) {
						return this.execWs(_, context, wsCall, nbtry++, true);
					}
					break;
				default:
					throw new CvgWsException(locale.format(module, "spgmNoResult", wsCall.name, ok));
			}

		} catch (e) {
			if (e instanceof CvgWsException) {
				wsCall.addMessage(3, e.message);
				return wsCall.getSoapResponse(0);
			}
			// retry when stream closed unexpectedly
			else if (e.message === "stream was closed unexpectedly") {
				this.disconnectClient(_, {}, "failed :" + e.message + "\n" + e.stack);
				if (nbtry < maxNbTry) {
					tracer.warn && tracer.warn("stream was closed unexpectedly : try to reconnect client and execute call again...");
					// reserve client to prevent set it free before the execution
					wsCall.context.reserved = true;
					// reinitialize client
					this.init(_, context, wsCall.context);
					// execute again
					return this.execWs(_, context, wsCall, nbtry++);
				} else {
					var pool = poolManager.getPool(this.cliCfg.poolAlias);
					if (pool) {
						pool.created--;
					}
					throw e;
				}
			} else {
				this.disconnectClient(_, {}, "failed :" + e.message + "\n" + e.stack);
				var pool = poolManager.getPool(this.cliCfg.poolAlias);
				if (pool) {
					pool.created--;
				}

				throw e;
			}
		}
	},
	_validReply: function(reply, wsCall, msgMessIdx, msgTypeIdx) {


		var techParams = [],
			resultParams = [];
		// separate technical parameters and result parameters
		reply && reply.json.params.forEach(function(p) {
			if (p.num > 11) {
				resultParams.push(p);
			} else if (p.num != null) {
				techParams[p.num] = techParams[p.num] || {};
				techParams[p.num][p.poste] = p;
			}
		});
		//tracer.debug && tracer.debug("Technical parameters: "+JSON.stringify(techParams,null,2));
		// Manage messages
		if (msgMessIdx && techParams[msgMessIdx]) {
			for (var i = 0; i < Object.keys(techParams[msgMessIdx]).length; i++) {
				if (techParams[msgMessIdx][i]) {
					var msgType = msgTypeIdx ? techParams[msgTypeIdx][i].resu : 3;
					wsCall.addMessage(msgType, techParams[msgMessIdx][i].resu);
				}
			}
		}
		if (wsCall && wsCall.callParams) {
			// Put input params first
			resultParams = wsCall.callParams.concat(resultParams);
		}
		// Remove null objects for LIST operation
		if (wsCall.action === "LIST") {
			resultParams = resultParams.filter(function(p) {
				return p && p.resu != null;
			});
		}

		var result = reply && reply.json && reply.json.result;

		if (!result) {
			var extraMessages = "";
			if (this.activeRequest.lastPushedWindow) {
				extraMessages += (extraMessages.length > 0 ? "\n" : "") + locale.format(module, "errOpenWinX3", JSON.stringify(this.activeRequest.lastPushedWindow));
			}
			if (this.activeRequest && this.activeRequest.ist) {
				extraMessages += (extraMessages.length > 0 ? "\n" : "") + "AdxId returned by X3 server: " + this.activeRequest.ist.toString();
			}
			wsCall.addMessage(3, locale.format(module, "noResult", extraMessages));
			throw new CvgWsException();
		} else if (!(result && !result.errn && !result.errm)) {
			//an error occurs raise an error
			wsCall.addMessage(3, result ? ("X3 Error: " + result.errp + ", message:" + result.errm + ", line :" + result.errl + ", type:" + result.errt) : "can't get result from X3");
			throw new CvgWsException();
		}
		return resultParams;
	},

	_getDescription: function(_, context, wsCall, ignoreCache) {
		wsCall.techInfo.loadWebsDuration.start();
		var _description, res;
		var x3HttpPub = this.clientConfig.getParam("x3HttpPub");
		var x3Folder = this.clientConfig.getParam("x3Folder");
		var url = x3HttpPub + "/" + x3Folder + "/GEN/ALL/WEBS/" + wsCall.name + ".xml";

		// get description in cache
		if (!ignoreCache && cacheMgr.cacheContains(url)) {
			res = cacheMgr.getResource(_, url, null, true, this.recOptions);
			_description = jsxml.parse(res).ADXDOC;
		}
		// retrieve real description
		else {
			try {
				res = cacheMgr.getResource(_, url, null, false, this.recOptions);
				_description = jsxml.parse(res).ADXDOC;
			} catch (e) {
				// Do nothing to be able to call recupHDAT
			}
			try {
				this._recupHDAT(_, wsCall, _description && _description.$.TIM);
			} catch (e) {
				if (e instanceof CvgWsException) {
					wsCall.addMessage(3, locale.format(module, "errorRecupHordat", RECUPHDAT, e.message, '', wsCall.name));
					wsCall.techInfo.loadWebsDuration.stop();
					return;
				}
				throw e;
			}
		}
		wsCall.techInfo.loadWebsDuration.stop();
		return _description;
	},
	/*
	 return true if the timestamp passed and the stamp in supervisor side are the same.
	 Else return false if we have a delta between cache description and timestamp in supervisor
	 in other case we raise an exception
	 */
	_recupHDAT: function(_, wsCall, stamp) {
		tracer.info && tracer.info("---------------------------------------");
		tracer.info && tracer.info("Call X3 subprogram '" + RECUPHDAT + "' with timestamp '" + stamp + "'");
		var params = [{
			"decr": "WEBS",
			"dim": 1,
			"nb": 1,
			"size": wsCall.name.length,
			"typ": "STRU",
			"resu": wsCall.name
		}, {
			"decr": "HDAT",
			"dim": 1,
			"nb": stamp ? 1 : 0,
			"size": (stamp && stamp.length) || 0,
			"typ": "STRU",
			"resu": stamp || ""
		}, {
			"decr": "OK",
			"dim": 1,
			"nb": 0,
			"size": 0,
			"typ": "INT"
		}];
		var reply = this.execAckCall(_, RECUPHDAT, params, wsCall);

		this._validReply(reply, wsCall);

		//no major error, analyse parameter receive from the supervisor to check the ws call work or if we have to do something (refresh cache)
		var ok = -1;
		var st = null;
		reply.json && reply.json.params && reply.json.params.forEach(function(p) {
			if (p.num === 2) {
				ok = p.resu;
			} else if (p.num === 1) {
				st = p.resu;
			}
		});
		tracer.info && tracer.info("Result (" + ok + ")");
		tracer.info && tracer.info("---------------------------------------");
		if (ok === 1) {
			return;
		} else if (ok === 0) {
			throw new CvgWsException(locale.format(module, "statusHordat0"));
		} else if (ok === 9) {
			wsCall.techInfo.reloadWebs = true;
			throw new CvgWsException(locale.format(module, "statusHordat9"));
		} else {
			throw new CvgWsException(locale.format(module, "spgmNoResult", wsCall.name, ok));
		}
	},
	_changeContext: function(_, wsCall, forceChange) {
		var isSame = true;
		var endpoint = wsCall.context.endpoint;
		var currentUser = wsCall.context.user.getEndpointLogin(_, endpoint.$uuid);
		var receiveUser = wsCall.context.user.getEndpointLogin(_, endpoint.$uuid);
		var currentLang = wsCall.context.localePref.code(_);
		var receiveLang = wsCall.context.localePref.code(_);
		wsCall.techInfo.changeLanguage = currentLang !== receiveLang;
		wsCall.techInfo.changeUserId = currentUser !== receiveUser;
		isSame = currentUser === receiveUser && currentLang === receiveLang;
		if (!isSame || forceChange) {
			this._changeLogin(_, receiveUser, locale.x3Language(receiveLang), wsCall);
			wsCall.context = wsCall.context;
		}
		return isSame;
	},
	/*
	 return true if the change of context works fine. Else we raise an exception with the message coming from X3 or a standard message
	 */
	_changeLogin: function(_, receiveUser, receiveLang, wsCall) {
		tracer.info && tracer.info("---------------------------------------");
		tracer.info && tracer.info("Call X3 subprogram '" + CHGLOGINXTEND + "'");
		var reply = this.execAckCall(_, CHGLOGINXTEND, [{
			"decr": "OK",
			"dim": 1,
			"nb": 1,
			"size": 1,
			"typ": "INT",
			"resu": -1
		}, {
			"decr": "MESSAGE",
			"dim": 1,
			"nb": 0,
			"size": 250,
			"typ": "STRU",
		}, {
			"decr": "LOGIN",
			"dim": 1,
			"nb": 1,
			"size": receiveUser.length,
			"typ": "STRU",
			"resu": receiveUser,
		}, {
			"decr": "LANG",
			"dim": 1,
			"nb": 1,
			"size": receiveLang.length,
			"typ": "STRU",
			"resu": receiveLang
		}], wsCall);

		this._validReply(reply, wsCall);
		//no major error, analyse parameter receive from the supervisor to check the ws call work or if we have to do something (refresh cache)
		var ok = reply.json && reply.json.params && reply.json.params.length && reply.json.params[0] && reply.json.params[0].num === 0 && reply.json.params[0].resu;
		tracer.info && tracer.info("Result (" + ok + ")");
		tracer.info && tracer.info("---------------------------------------");
		return ok;
	},
	/*
	 return true if the flush call works else raise an exception
	 */
	_flush: function(_, wsCall) {
		tracer.info && tracer.info("---------------------------------------");
		tracer.info && tracer.info("Call X3 subprogram '" + FLUSHADX + "'");

		var reply = this.execAckCall(_, FLUSHADX, [{
			"decr": "OK",
			"dim": 1,
			"nb": 1,
			"size": 1,
			"typ": "INT",
			"resu": -1
		}], wsCall);

		this._validReply(reply, wsCall);
		//no major error, analyse parameter receive from the supervisor to check the ws call work or if we have to do something (refresh cache)
		var ok = reply.json && reply.json.params && reply.json.params.length && reply.json.params[0] && reply.json.params[0].num === 0 && reply.json.params[0].resu;
		tracer.info && tracer.info("Result (" + ok + ")");
		tracer.info && tracer.info("---------------------------------------");
		if (ok === 1) {
			return true;
		} else if (ok === 0) {
			throw new CvgWsException(locale.format(module, "alreadyFlushAdx", wsCall.name, ok));
		} else {
			throw new CvgWsException(locale.format(module, "spgmNoResult", wsCall.name, ok));
		}
	},
	newRequest: function(reply, sendContext) {
		return new CvgRequestWS(this, reply, sendContext);
	}
});