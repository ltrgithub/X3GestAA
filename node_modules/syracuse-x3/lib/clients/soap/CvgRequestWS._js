"use strict";
var helpers = require('@sage/syracuse-core').helpers;
var CvgAction = require('syracuse-x3/lib/convergence/client/CvgAction').Actions;
var CvgException = require('syracuse-x3/lib/convergence/model/CvgException').CvgException;
var CvgMessage = require('syracuse-x3/lib/convergence/model/CvgMessage').CvgMessage;
var CvgReplyAckCall = require('syracuse-x3/lib/convergence/model/CvgReplyAckCall');
var CvgDiagnose = require('syracuse-x3/lib/convergence/model/CvgDiagnose');
var CvgRequestAbs = require("syracuse-x3/lib/clients/common/cvg/CvgRequestAbs").CvgRequestAbs;


var MSG_INFORMATION = 0;
var MSG_WARNING = 1; // Boite d'Avertissement
var MSG_QUESTION = 2; // Boite de Question
var MSG_ERROR = 3;
var MSG_STOP = 4; // Boite Abort
var OU_BAV = 11; /* Boite d'Avertissement */
var OU_BEN = 15; /* Boite end : Abort ! */
var OU_BER = 10; /* Boite d'Erreur */
var OU_BIF = 14; /* Boite d'Information */
var OU_BQU = 12; /* Boite de Question */
var OU_BSE = 13; /* Boite de Selection */

function _postDiag(req, msg, detail) {
	CvgDiagnose.create(req.client, 'WARNING', 99, msg, detail, null, "Protocol", null, true);
}

exports.CvgRequestWS = helpers.defineClass(function(aClient, aAdonixReply, sendContext) {
	CvgRequestAbs.call(this, aClient, aAdonixReply, sendContext);


}, CvgRequestAbs, {

	buildListenNodeMessage: function(aKeyMess, aValue1, aValue2, aModifier) {
		var msg = aValue2 ? this.client.getMessage(aKeyMess, aValue1, aValue2) : this.client.getMessage(aKeyMess, aValue1);
		if (aModifier.hasLogicalErrMess()) {
			msg = msg + "\n\t" + aModifier.logicalErrMess;
		}
		return msg;
	},


	/**
	 * Traitement des noeud NDOBOXI transportant des messages synchrones. Compte
	 * tenu du mecanisme de si le noeud NDOBOXI n'est pas traite ici, il sera
	 * traite dans la methode "listenNodeNDOBOXI" de la classe "CAdonixRequest"
	 *
	 * NDBOXI 0E0108 (MessageBox_Create)
	 *
	 * Transporte les demandes d'affichage synchrone
	 *
	 * Infbox "$$TEMPOPE" + WMESS Infbox "$$TEMPCLO" Infbox "$$VLC_OPE" +
	 * INTTEXT + "^" + INTNUM Titled TITREWINDOW + "^" + WLIB1 + "^" + WLIB2
	 * Infbox "$$VLC_MOD" + VALEXT + "^" + VALNUM Infbox "$$VLC_CLO" Infbox
	 * "$$PROGOPE" Titled TITREWINDOW Infbox "$$PROGMOD" + WMAX + "^" +
	 * WPROGRESS + "^" + WLIB Infbox "$$PROGCLO"
	 *
	 * simulation de close session Infbox "$$SESSCLO"
	 *
	 * pilotage timeout de la requete courante - Timeout d'une heure si
	 * $$DBG_OPE + texte - Timeout standard si $$DBG_CLO + texte
	 */
	listenNodeNDOBOXI: function(_, reader, node, typBox, btnNum, msg, ttl, wSleep) {

		// TODO auto reply
		var defBtn = -1;
		var typMsg = -1;
		try {
			if (typBox === OU_BIF) {
				var p = msg.indexOf("$$");
				// si le message contient "$$" au debut (pos 0 ou 1) : c'est un message d'affichage asynchone
				if (p === 0 || p === 1) {
					_postDiag(this, "Synchronous messages are not implemented in this version[" + msg + "]", 'NDOBOXI');
				}
			}

			if (msg.length > 0) {
				msg.replace('\r', ' ');
			}
			if (ttl.length > 0) {
				ttl.replace('\r', ' ');
			}
			switch (typBox) {
				/* Boite de Question */
				case OU_BQU:
					typMsg = MSG_QUESTION;
					defBtn = 2;
					break;
					/* Boite d'Avertissement */
				case OU_BAV:
					typMsg = MSG_WARNING;
					defBtn = 1;
					break;
					/* Boite d'Erreur */
				case OU_BER:
					typMsg = MSG_ERROR;
					defBtn = 0;
					break;
					/* Boite d'Information */
				case OU_BIF:
					typMsg = MSG_INFORMATION;
					defBtn = 0;
					break;
					/* Boite STOP */
				case OU_BEN:
					typMsg = MSG_STOP;
					defBtn = 0;
					// Who is closing syracuse session ? if (this.client.connecting) this.client.closeClient(_, null, 3);
					break;
				case OU_BSE:
					/* Boite de Selection ??? */
					break;
				default:
					break;
			}

			if (btnNum !== 0 && btnNum !== defBtn) defBtn = btnNum;
			msg = new CvgMessage(typMsg, 0, msg, ttl, defBtn, wSleep, btnNum, this.client);

		} catch (e) {
			console.error(e.stack);
		} finally {
			//console.error("typMsg: "+typMsg);
			if (typMsg === MSG_STOP || typMsg === MSG_ERROR || typMsg === OU_BEN || typMsg === OU_BER) {
				throw new Error("WS POOL [" + this.client.cliCfg.poolAlias + "] X3 MSGBOX: " + ttl + " - " + msg.message);
			}

			this.client.processAsyncAction(_, {
				act: this.client.x3writer.descriptors.actions.SRV_CHAMP_SUIVANT,
				param: {},
				fld: {
					fmtKind: "SHOW",
					ist: null,
					v: defBtn
				}
			});
		}
	},


	// "ist" "l'instance du niveau zero // Ne sert a rien !!!"
	// "errn (short)" "la variable errn valorisée par le moteur " "errn"
	// "errl (short)" "contient la variable errl valorisée par le moteur" "errl"
	// "errp (string)" "id du traitement dans la variable errp valorisée par le moteur"
	// "errt (car)" "contient  la variable errtyp valorisée par le moteur"
	// "errm (string)" "contient  la variable errm valorisée par moteur" "mess"
	listenNodeNDRESULT: function(_, reader, node, ist, errn, errl, errp, errt, errm, resu, tblParams, tblResus) {
		// TOTO reply treatement and manage web-service call error regarding which sub prog is called

		// Instantiate CvgReplyAckCall and store it in client.trackList.RPC
		if (errn !== 0 && this.sendContext.connect) {
			// add diagnosis 
			throw new CvgException(this.client, null, "errt[" + errt + "] errp[" + errp + "] errl[" + errl + "] errn[" + errn + "] errm[" + errm + "]", 'KILL', "4gl runtime");
		}

		CvgReplyAckCall.create(this.client, errn, errl, errp, errt, errm, resu[0], tblParams[0], tblResus[0]);
	},


	listenNodeNDSATAN: function(_, reader, node, ist) {
		this.ist = ist;
	},

	listenNodeNDOWIN: function(_, reader, node, ist, winId, funcId, stamp, extInfos) {
		this.lastPushedWindow = {
			winId: winId,
			funcId: funcId,
			stamp: stamp
		};
	}


});