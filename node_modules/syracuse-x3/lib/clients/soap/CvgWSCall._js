"use strict";
var helpers = require('syracuse-core/lib/helpers');
var locale = require("syracuse-core/lib/locale");
var flows = require('streamline/lib/util/flows');
var jsxml = require('jsxml');

var x3helpers = require('syracuse-x3/lib/helpers');


var mapTypeToResu = {
	Decimal: "DCB",
	Char: "STRU",
	Integer: "INT",
	Blob: "BLOB",
	Date: "DATE",
	// TOOD add other type

};


exports.CvgWSCall = helpers.defineClass(function(opt) {
	this.name = opt.name;

	this.flow = opt.flow && jsxml.parse(opt.flow).PARAM; // ...xml
	this.action = opt.action;
	this.wtrace = opt.trace;
	// for objecg or list
	this.itemKeys = opt.wkeys; // for CRUD and list, criteria or keys elements
	this.wkeys = ""; // string that represent the key
	this.nb = opt.nb; // for list action , number of elements

	this.debugInfo = opt.debugInfo;
	// for action inslig or suplig
	this.tab = opt.tab; //blocKey
	this.par = opt.par; // lineKey

	this.result = null // reply of the ack_call;

}, null, {
	generateResult: function(description, params, lang) {

		/*
		 * resultParamMap is a object in 2 level, first key is the num that correspond to the idx in the description and second is poste link the dimension of the description
		 */
		function getParamFieldOutputXml(resultParamMap, isAlign) {


			function getIdGroupXml(grp, params) {
				if (grp.$.TYB === "Table")
					return 'TAB';


				return "GRP";
			}

			function findMenuLabel(idMenu, resu) {
				var menus = description.ADXMEN.MNU;
				if (!Array.isArray(menus)) {
					menus = [menus];
				}
				var found = null;
				for (var i = 0; i < menus.length && !found; i++) {
					var menu = menus[i];

					if (menu.$.NO === idMenu && lang) {
						// find right VAL
						var vals = !Array.isArray(menu.VAL) ? [menu.VAL] : menu.VAL;

						for (var j = 0; j < vals.length && !found; j++) {
							if (parseInt(vals[j].$.IND, 10) === parseInt(resu, 10)) {
								found = vals[j].$["C_" + lang];
							}
						}
					}
				}
				return found;
			}

			if (description.ADXDATA) {
				var currentidx = 12;
				var paramsOutput = "\n<RESULT>";
				var paramsOutputGrp = {};

				var grps = Array.isArray(description.ADXDATA.GRP) ? description.ADXDATA.GRP : [description.ADXDATA.GRP];
				grps.forEach(function(grp) {
					if (grp.$.DIM > 1) { // parameter describe number of element
						currentidx++;
					}

					var flds = Array.isArray(grp.FLD) ? grp.FLD : [grp.FLD];

					flds.forEach(function(fld) {
						if (resultParamMap[currentidx]) {
							var grpName = getIdGroupXml(grp, resultParamMap[currentidx]);
							if (!paramsOutputGrp[grp.$.NAM]) {
								var att = grpName ? ' DIM="' + grp.$.DIM + '" SIZE="' + resultParamMap[currentidx].length + '"' : '';
								paramsOutputGrp[grp.$.NAM] = {
									xml: {
										start: '<' + grpName + att + ' ID="' + grp.$.NAM + '">',
										end: '</' + grpName + '>'
									}
								};
							}
							// create LIN
							resultParamMap[currentidx].forEach(function(pp) {

								if (pp.resu === null || typeof pp.resu === "undefined") {
									pp.resu = "";
								}
								if (fld.$.MEN && pp.resu || !fld.$.MEN) {

									if (!paramsOutputGrp[grp.$.NAM][pp.poste]) {
										if (grp.$.TYB === "Table") {
											paramsOutputGrp[grp.$.NAM][pp.poste] = {
												xml: {
													start: '<LIN NUM="' + (pp.poste + 1) + '">',
													end: '</LIN>'
												}
											};

										} else {
											paramsOutputGrp[grp.$.NAM][pp.poste] = paramsOutputGrp[grp.$.NAM][pp.poste] || {};
										}
									}
									// check if it's local menu,
									var menuLab = "";
									var menuLocal = "";

									if (fld.$.MEN) {
										// find the label for the menu regarding the resu received
										menuLab = 'MENULAB="' + findMenuLabel(fld.$.MEN, pp.resu) + '"';
										menuLocal = 'MENULOCAL="' + fld.$.MEN + '"';
									}

									var init = {};
									if (fld.$.DIM > 1 && fld.$.MEN) {
										// initialization of list
										init = {
											xml: {
												start: '<LST ' + menuLocal + '  TYPE="' + fld.$.TYP + '" NAME="' + fld.$.NAM + '">',
												end: '</LST>'
											}
										};
										paramsOutputGrp[grp.$.NAM]["M_" + currentidx] = paramsOutputGrp[grp.$.NAM]["M_" + currentidx] || init;

										paramsOutputGrp[grp.$.NAM]["M_" + currentidx][pp.poste] = {
											xml: {
												start: '<ITM ' + menuLab + ' >' + pp.resu,
												end: '</ITM>'
											}
										};
									} else {
										var extra = "";
										var val = pp.resu;
										if (fld.$.TYP === "Blob") {
											extra = 'BYTES="' + val.length + '" MIMETYPE="aa"';
											val = new Buffer(val).toString('base64');

										}
										paramsOutputGrp[grp.$.NAM][pp.poste][currentidx] = {
											xml: {
												start: '<FLD ' + extra + ' ' + menuLab + ' ' + menuLocal + ' NAME="' + fld.$.NAM + '" TYPE="' + fld.$.TYP + '" >' + val,
												end: '</FLD>'
											}
										};
									}



								}
							});
						}
						currentidx++;
					});
				});


				// construct the final xml file
				Object.keys(paramsOutputGrp).forEach(function(grpId) {
					// group level
					paramsOutput += (isAlign ? "\n\t" : "") + paramsOutputGrp[grpId].xml.start;
					Object.keys(paramsOutputGrp[grpId]).forEach(function(poste) {
						// poste level if xml exists
						var lineLevel = false;
						if (paramsOutputGrp[grpId][poste].xml) {
							paramsOutput += (isAlign ? "\n\t\t" : "") + paramsOutputGrp[grpId][poste].xml.start;
							lineLevel = true;
						}

						Object.keys(paramsOutputGrp[grpId][poste]).forEach(function(field) {
							// field level

							if (paramsOutputGrp[grpId][poste][field].xml)
								paramsOutput += (isAlign ? (lineLevel ? "\n\t\t\t" : "\n\t\t") : "") + paramsOutputGrp[grpId][poste][field].xml.start + paramsOutputGrp[grpId][poste][field].xml.end;
						});

						if (paramsOutputGrp[grpId][poste].xml) {
							paramsOutput += (isAlign ? "\n\t\t" : "") + paramsOutputGrp[grpId][poste].xml.end;
						}

					});
					paramsOutput += (isAlign ? "\n\t" : "") + paramsOutputGrp[grpId].xml.end;
				});
				return '<?xml version="1.0" encoding="UTF-8"?>' + paramsOutput + (isAlign ? "\n" : "") + "</RESULT>";
			}
		}

		if (!this.result) {
			// create a map with num (correspond to index) as a id in order to match the description
			var resParamsMap = {};
			params.forEach(function(p) {
				if (p.num) {
					resParamsMap[p.num] = resParamsMap[p.num] || [];
					resParamsMap[p.num].push(p);
				} else if (p.index && !resParamsMap[p.index]) {
					resParamsMap[p.index] = resParamsMap[p.index] || [];
					if (!Array.isArray(p.resu)) {
						p.resu = [p.resu];
					}
					p.resu.forEach(function(resu, idx) {
						resParamsMap[p.index].push({
							num: p.index,
							poste: idx,
							typ: p.typ,
							resu: resu
						});
					});

				}
			});

			this.result = getParamFieldOutputXml(resParamsMap, true);
		}
		return this.result;
	},
	getAckCallParams: function(description) {
		function findDescrGroup(id) {
			if (description.ADXDATA) {
				var grps = Array.isArray(description.ADXDATA.GRP) ? description.ADXDATA.GRP : [description.ADXDATA.GRP];
				var found = null;
				for (var i = 0; i < grps.length && !found; i++) {
					found = grps[i].$.NAM === id ? grps[i] : null;
					if (!found)
						found = grps[i].$.NAME === id ? grps[i] : null;

				}
				return found;
			}
			return null;
		}


		function getParamFieldInput() {
			if (description.ADXDATA) {
				var currentidx = 12;
				var paramsInput = {};
				var grps = Array.isArray(description.ADXDATA.GRP) ? description.ADXDATA.GRP : [description.ADXDATA.GRP];
				grps.forEach(function(grp) {
					if (grp.$.DIM > 1) { // add parameter with te idx
						paramsInput[currentidx] = {
							"index": currentidx,
							"descr": grp.$.IDTAB,
							"dim": 1,
							"nb": 0,
							"size": 0,
							"typ": "INT",
						};
						currentidx++;
					}

					var flds = Array.isArray(grp.FLD) ? grp.FLD : [grp.FLD];
					flds.forEach(function(fld) {

						paramsInput[currentidx] = {
							"index": currentidx,
							"descr": fld.$.NAM || fld.$.NAME,
							"dim": fld.$.DIM || grp.$.DIM,
							"nb": 0,
							"size": 0,
							"typ": mapTypeToResu[fld.$.TYP]
						};
						currentidx++;
					});
				});
				return paramsInput;
			}
		}

		function findDescrfield(id, jsonDescrGrp) {
			if (jsonDescrGrp) {
				var flds = Array.isArray(jsonDescrGrp.FLD) ? jsonDescrGrp.FLD : [jsonDescrGrp.FLD];
				var found = null;
				for (var i = 0; i < flds.length && !found; i++) {
					found = flds[i].$.NAM === id ? flds[i] : null;
					if (!found)
						found = flds[i].$.NAME === id ? flds[i] : null;

				}
				return found;
			}
			return null;
		}

		//console.log("Description: " + JSON.stringify(description, null, 2));
		if (this.itemKeys) {
			// check the key pass and if they correspond the key description
			var adxkey = this.action === "LIST" ? description.ADXKEY.GRP.FLD : description.ADXREAD.GRP.FLD;
			if (!Array.isArray(adxkey)) {
				adxkey = [adxkey];
			}
			var inKey = true;
			for (var i = 0; i < adxkey.length && inKey; i++) {
				// looking for the item that have the name of the current fdl
				var found = false;

				for (var j = 0; j < this.itemKeys.length && !found; j++) {
					if (this.itemKeys[j].key === adxkey[i].$.NAM) {
						found = true;
						this.wkeys += (this.wkeys ? "~" : "") + this.itemKeys[j].value;
					}
				}
			}
		}
		//console.log("key "+this.wkeys);
		var paramsMap = getParamFieldInput();

		// put all input param with no value


		if (this.flow) { // put the value the parameter that have value
			var grps = Array.isArray(this.flow.GRP) ? this.flow.GRP : [this.flow.GRP];
			// check if the group exists in the descirption and analyse all field to create a param
			grps.forEach(function(grp) { // check if the group exists in the
				var descrGrp = findDescrGroup(grp.$.ID);
				// check field in flow and association with field in group in order to create parameter
				var currentidx = 12;
				grp.FLD && grp.FLD.forEach(function(fld) { // TODO manage the order of field regarding description
					var descrFld = findDescrfield(fld.$.NAM || fld.$.NAME, descrGrp);

					if (descrFld) {
						// erase the preview parameter
						paramsMap[currentidx] = {
							"index": currentidx,
							"descr": fld.$.NAM || fld.$.NAME,
							"dim": descrGrp.$.DIM,
							"nb": 1, // TODO manage number of field properly
							"size": mapTypeToResu[descrFld.$.TYP] === "STRU" || mapTypeToResu[descrFld.$.TYP] === 'CLOB' ? fld.$value.length : 1,
							"typ": mapTypeToResu[descrFld.$.TYP],
							"resu": fld.$value
						};
						currentidx++;
					}
				});
			});
			//console.log("params " + JSON.stringify(params, null, 2));
		}
		var paramsMapSorted = Object.keys(paramsMap).sort(function(a, b) {
			var ai = parseInt(a, 10);
			var bi = parseInt(b, 10);
			if (ai > bi) {
				return 1;
			} else if (ai === bi) {
				return 0;
			} else {
				return -1;
			};
		});
		var params = [];
		//console.log("params Sorted "+JSON.stringify(paramsMapSorted,null,2) );
		paramsMapSorted.forEach(function(k) {
			params.push(paramsMap[k]);
		});
		return params;
	},
	getSubprogName: function() {
		// TODO
	},

	getResult: function() {

	},
	toJSON: function() {
		return {
			name: this.name,
			flow: this.flow,
			action: this.action,
			wtrace: this.wtrace,
			// for objecg or list
			wkeys: this.wkeys,
			nb: this.nb,
			debugInfo: this.debugInfo,
			// for action inslig or suplig
			tab: this.tab,
			par: this.par
		};
	}



});