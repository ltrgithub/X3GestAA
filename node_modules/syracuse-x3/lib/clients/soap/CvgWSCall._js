"use strict";
var helpers = require('syracuse-core/lib/helpers');
var jsxml = require('jsxml');
var binaryHelper = require('syracuse-core/lib/binaryHelper');
var locale = require("syracuse-core/lib/locale");
var CvgWsException = require("syracuse-x3/lib/clients/soap/CvgWsException").CvgWsException;

var tracer = require("syracuse-trace/lib/helper").getTracer("soap-generic.ackcall");

var mapTypeToResu = {
	Decimal: "DCB",
	Char: "STRU",
	Integer: "INT",
	Blob: "BLOB",
	Date: "DATE",
	// TOOD add other type

};

function forceDefaultValue(type) {
	switch (type) {
		case "Decimal":
		case "Integer":
			return 0;
		default:
			return;
	}
}

var allowedChildren = {
	PARAM: ["GRP", "TAB"],
	GRP: ["FLD"],
	TAB: ["LIN"],
	LIN: ["FLD"],
	FLD: []
};

exports.CvgWSCall = helpers.defineClass(function(techInfo, lang, params, requestConfig) {
	this.requestConfig = requestConfig || {};
	this.techInfo = techInfo;
	this.report = techInfo.processReport;
	this.lang = lang;
	this.name = params.name;

	this.flow = params.flow && jsxml.parse(params.flow); // ...xml
	this.action = params.action;
	this.wtrace = params.trace;
	// for objecg or list
	this.itemKeys = params.wkeys; // for CRUD and list, criteria or keys elements
	this.wkeys = ""; // string that represent the key
	this.nb = params.nb; // for list action , number of elements

	this.debugInfo = params.debugInfo;
	// for action inslig or suplig
	this.tab = params.tab; //blocKey
	this.par = params.par; // lineKey

	// will be computed !
	this.description = null;
	this.callParams = null;
	this.status = 1;
	this.result = null; // reply of the ack_call;
	this.messages = [];

}, null, {
	addMessage: function(type, message) {
		this.messages.push({
			type: type,
			message: message
		});
	},
	_handleTechParams: function(params) {
		var techParamsMap = [];
		params.forEach(function(p) {
			if (p.num != null) {
				techParamsMap[p.num] = techParamsMap[p.num] || {};
				techParamsMap[p.num][p.poste] = p;
			}
		});
		//tracer.debug && tracer.debug("Technical parameters: "+JSON.stringify(techParamsMap,null,2));

		// Manage messages
		if (techParamsMap[3] && techParamsMap[4]) {
			for (var i = 0; i < Object.keys(techParamsMap[3]).length; i++) {
				this.addMessage(techParamsMap[3][i].resu, techParamsMap[4][i].resu);
			}
		}
	},
	_computeResult: function(params) {
		var self = this;

		function getParamFieldOutputXml(resultParamMap) {

			function findMenuLabel(idMenu, resu) {
				var menus = self.description.ADXMEN.MNU;
				if (!Array.isArray(menus)) {
					menus = [menus];
				}
				var found = null;
				for (var i = 0; i < menus.length && !found; i++) {
					var menu = menus[i];

					if (menu.$.NO === idMenu && self.lang) {
						// find right VAL
						var vals = !Array.isArray(menu.VAL) ? [menu.VAL] : menu.VAL;

						for (var j = 0; j < vals.length && !found; j++) {
							if (parseInt(vals[j].$.IND, 10) === parseInt(resu, 10)) {
								found = vals[j].$["C_" + self.lang];
							}
						}
					}
				}
				return found;
			}

			function _createField(elt, field, id, force) {
				var _p, _params = resultParamMap[currentIdx] && resultParamMap[currentIdx];
				if (_params) {
					if (field.$.DIM > 1 && field.$.MEN) {
						elt.LST = elt.LST || [];
						var _lst = {
							$: {
								MENULOCAL: field.$.MEN,
								NAME: field.$.NAM,
								SIZE: field.$.DIM,
								TYPE: field.$.TYP
							}
						};
						for (var i = 0; i < field.$.DIM; i++) {
							_p = _params[i];
							_lst.ITM = _lst.ITM || [];
							if (_p && _p.resu) {
								var _itm = {
									$: {
										MENULAB: findMenuLabel(field.$.MEN, _p.resu)
									},
									$value: _p.resu
								};
								_lst.ITM.push(_itm);
							}
						}
						if (_lst.ITM && _lst.ITM.length > 0) elt.LST.push(_lst);
					} else {
						_p = _params[id || 0];
						elt.FLD = elt.FLD || [];
						var _fld = {
							$: {}
						};
						if (_p && _p.resu) {
							if (field.$.TYP === "Blob") {
								var buf = new Buffer(_p.resu, "hex");
								_fld.$.BYTES = buf.length;
								_fld.$.MIMETYPE = binaryHelper.calcMimeType(buf);
								_fld.$value = buf.toString('base64');
							} else {
								_fld.$value = _p.resu;
							}
							// Menu set only if a resu is available
							if (field.$.MEN) {
								_fld.$.MENULAB = findMenuLabel(field.$.MEN, _p.resu);
								_fld.$.MENULOCAL = field.$.MEN;
							}
							// Keep attributes order
							_fld.$.NAME = field.$.NAM;
							_fld.$.TYPE = field.$.TYP;
							//
							elt.FLD.push(_fld);
						}
						// force default value for table line without resu (if it's not a menu)
						else if (!force || (force && !field.$.MEN)) {
							var _def = forceDefaultValue(field.$.TYP);
							if (_def != null) {
								_fld.$value = _def;
							}
							// Keep attributes order
							_fld.$.NAME = field.$.NAM;
							_fld.$.TYPE = field.$.TYP;
							//
							elt.FLD.push(_fld);
						}
					}
				}
			}

			function _createGroup(elt, grp) {
				elt.GRP = elt.GRP || [];
				var _grp = ({
					$: {
						ID: grp.$.NAM
					}
				});
				var flds = Array.isArray(grp.FLD) ? grp.FLD : [grp.FLD];
				flds.forEach(function(_fld) {
					_createField(_grp, _fld);
					currentIdx++;
				});
				if ((_grp.FLD && _grp.FLD.length > 0) || (_grp.LST && _grp.LST.length > 0)) elt.GRP.push(_grp);
			}

			function _createLine(elt, num, flds) {
				elt.LIN = elt.LIN || [];
				var _lin = {
					$: {
						NUM: num + 1
					}
				};
				flds.forEach(function(_fld) {
					// force field even if resu is null
					_createField(_lin, _fld, num, true);
					currentIdx++;
				});
				if ((_lin.FLD && _lin.FLD.length > 0) || (_lin.LST && _lin.LST.length > 0)) elt.LIN.push(_lin);
			}

			function _createTable(elt, grp) {
				elt.TAB = elt.TAB || [];
				// Get size param
				var size = resultParamMap[currentIdx] && resultParamMap[currentIdx][0].resu || 0;
				currentIdx++;
				//
				var _tab = ({
					$: {
						DIM: grp.$.DIM,
						ID: grp.$.NAM,
						SIZE: size
					}
				});
				var flds = Array.isArray(grp.FLD) ? grp.FLD : [grp.FLD];
				for (var i = 0; i < size; i++) {
					_createLine(_tab, i, flds);
					currentIdx -= flds.length;
				}
				//
				if (_tab.LIN && _tab.LIN.length > 0) elt.TAB.push(_tab);
				currentIdx += flds.length;
			}

			//
			var output = {
				RESULT: {
					$: {}
				}
			};

			var descripData = self.description.ADXDATA;
			if (self.action === "LIST") {
				descripData = self.description.ADXKEY;
			}

			//			tracer.debug && tracer.debug("Data in description: " + JSON.stringify(descripData, null, 2));
			tracer.debug && tracer.debug("Params: " + JSON.stringify(resultParamMap, null, 2));

			var currentIdx = 0;
			var grps = Array.isArray(descripData.GRP) ? descripData.GRP : [descripData.GRP];
			grps && grps.forEach(function(grp) {
				if (grp) {
					if (grp.$.NAM === "LEFTLIST") {
						var size = resultParamMap.reduce(function(prev, cur) {
							var len = Object.keys(cur).length;
							return len > prev ? len : prev;
						}, 0);
						if (size !== 0) {
							output.RESULT.$.DIM = grp.$.DIM;
							output.RESULT.$.SIZE = size;
							var flds = Array.isArray(grp.FLD) ? grp.FLD : [grp.FLD];
							for (var i = 0; i < output.RESULT.$.SIZE; i++) {
								_createLine(output.RESULT, i, flds);
								currentIdx -= flds.length;
							}
						}
					} else {
						// GRP or TAB ?
						var grpKind = grp.$.TYB === "Table" ? "TAB" : "GRP";
						if (grpKind === "GRP") {
							_createGroup(output.RESULT, grp);
						} else if (grpKind === "TAB") {
							_createTable(output.RESULT, grp, resultParamMap);
						}
					}
				}
			});

			var opt = {};
			var beautify = self.requestConfig["adxwss.beautify"] === "true";
			if (beautify) opt.indent = '\t';
			return '<?xml version="1.0" encoding="UTF-8"?>' + (beautify ? "\n" : "") + jsxml.stringify(output, opt);
		}
		//
		if (!this.result) {
			// create a map with num (correspond to index) as a id in order to match the description
			var resParamsMap = [];
			params.forEach(function(p) {
				if (p && p.num != null) {
					resParamsMap[p.num] = resParamsMap[p.num] || {};
					resParamsMap[p.num][p.poste] = p;
				} else if (p && p.index != null && !resParamsMap[p.index]) {
					resParamsMap[p.index] = resParamsMap[p.index] || {};
					if (!Array.isArray(p.resu)) {
						p.resu = [p.resu];
					}
					p.resu.forEach(function(resu, idx) {
						resParamsMap[p.index][idx] = {
							num: p.index,
							poste: idx,
							typ: p.typ,
							resu: resu
						};
					});

				}
			});
			this.result = getParamFieldOutputXml(resParamsMap.slice(12));
			this.status = 1;
		}
	},
	setAckCallParams: function(description) {
		this.description = description;
		var descriptionSub = this.action === "LIST" ? description.ADXKEY : description.ADXDATA;
		var self = this;

		function getNodes(parent, nodeName) {
			return parent && parent[nodeName] ? (Array.isArray(parent[nodeName]) ? parent[nodeName] : [parent[nodeName]]) : [];
		}

		function getParamFieldInput() {
			if (descriptionSub) {
				var currentidx = 12;
				var paramsInput = {};
				var grps = getNodes(descriptionSub, "GRP");
				grps.forEach(function(grp) {
					if (grp.$.DIM > 1 && self.action !== "LIST") { // add parameter with te idx
						paramsInput[currentidx] = {
							"index": currentidx,
							"descr": grp.$.IDTAB,
							"dim": 1,
							"nb": 0,
							"size": 0,
							"typ": "INT",
						};
						currentidx++;
					}

					var flds = getNodes(grp, "FLD");
					flds.forEach(function(fld) {
						paramsInput[currentidx] = {
							"index": currentidx,
							"descr": fld.$.NAM || fld.$.NAME,
							"dim": fld.$.DIM || grp.$.DIM,
							"nb": 0,
							"size": 0,
							"typ": mapTypeToResu[fld.$.TYP],
							"mod": fld.$.MOD
						};
						currentidx++;
					});
				});
				return paramsInput;
			}
		}


		function findDescrGroup(id) {
			if (descriptionSub) {
				var grps = getNodes(descriptionSub, "GRP");
				var found = null;
				for (var i = 0; i < grps.length && !found; i++) {
					var grpName = grps[i].$.NAM || grps[i].$.NAME;
					found = grpName === id ? grps[i] : null;
					if (found) return found;
				}
			}
			self.report.addError("Node " + id + " not found into X3 description.");
		}

		function findDescrfield(id, jsonDescrGrp) {
			if (jsonDescrGrp) {
				var flds = getNodes(jsonDescrGrp, "FLD");
				var found = null;
				for (var i = 0; i < flds.length && !found; i++) {
					var fldName = flds[i].$.NAM || flds[i].$.NAME;
					found = fldName === id ? flds[i] : null;
					if (found) return found;
				}
			}
			self.report.addError("Field " + id + " not found into group " + jsonDescrGrp.$.NAM + ".");
		}

		function findIndexField(fldName, map) {
			var fldIdx;
			var found = Object.keys(map).some(function(key) {
				var _found = map[key].descr === fldName;
				if (_found) fldIdx = key;
				return _found;
			});
			if (found) return fldIdx;
			self.report.addError("Node " + fldName + " not found into X3 description.");
		}

		function checkAllowedNodes(type, node) {
			Object.keys(node).forEach(function(n) {
				if (n !== '$' && allowedChildren[type].indexOf(n) === -1) {
					self.report.addError("Node " + n + " is not allowed under " + type + ".");
				}
			});
		}

		function checkFields(parentNode, descrGrp, arrayIdx) {
			var flds = getNodes(parentNode, "FLD");
			// check field in flow and association with field in group in order to create parameter
			var _isArray = arrayIdx != null;

			flds && flds.forEach(function(fld) {
				var fldName = fld.$.NAM || fld.$.NAME;
				var descrFld = findDescrfield(fldName, descrGrp);
				if (descrFld) {
					var idx = findIndexField(fldName, paramsMap);
					var _value = fld.$value;

					if (_isArray) {

						_value = paramsMap[idx] && paramsMap[idx].resu && Array.isArray(paramsMap[idx].resu) ? paramsMap[idx].resu : [];
						for (var i = 0; i < arrayIdx; i++) {
							if (_value[i] === undefined) _value[i] = "";
						}
						_value.splice(arrayIdx - 1, 1, fld.$value);
					}

					// erase the previous parameter
					paramsMap[idx] = {
						"index": idx,
						"descr": fldName,
						"dim": descrGrp.$.DIM,
						"nb": _isArray ? _value.length : 1,
						"size": mapTypeToResu[descrFld.$.TYP] === "STRU" || mapTypeToResu[descrFld.$.TYP] === 'CLOB' ? fld.$value.length : 1,
						"typ": mapTypeToResu[descrFld.$.TYP],
						"resu": _value
					};
				}
			});

			if (_isArray) {
				var _paramTabNb = paramsMap[findIndexField(descrGrp.$.IDTAB, paramsMap)];
				if (_paramTabNb.nb > 0) {
					_paramTabNb.resu = arrayIdx > _paramTabNb.resu + 1 ? arrayIdx : _paramTabNb.resu + 1;
				} else {
					_paramTabNb.nb = 1;
					_paramTabNb.resu = arrayIdx > 1 ? arrayIdx : 1;
				}
			}
		}

		function checkGroups(paramNode) {
			var grps = getNodes(paramNode, "GRP");
			// check if the group exists in the descirption and analyse all field to create a param
			grps && grps.forEach(function(grp) { // check if the group exists in the
				if (!grp.$ || !grp.$.ID) {
					self.report.addError("No attribute ID found into GRP tag.");
					return;
				}
				var descrGrp = findDescrGroup(grp.$.ID);
				if (descrGrp) {
					if (descrGrp.$.DIM && descrGrp.$.DIM > 1) {
						self.report.addError("Group [" + descrGrp.$.NAM + "] has a dimension greater than 1. Your have to use TAB Xml tag.");
					}
					checkAllowedNodes("GRP", grp);
					checkFields(grp, descrGrp);
				}
			});
		}

		function checkLines(tabNode, descrGrp) {
			var lins = getNodes(tabNode, "LIN");
			// check if the group exists in the description and analyse all field to create a param
			lins && lins.forEach(function(lin) {
				var num = lin.$ && lin.$.NUM ? parseInt(lin.$.NUM, 10) : 1;
				checkAllowedNodes("LIN", lin);
				checkFields(lin, descrGrp, num);
			});
		}

		function checkTables(paramNode) {
			var tabs = getNodes(paramNode, "TAB");
			// check if the group exists in the description and analyse all field to create a param
			tabs && tabs.forEach(function(tab) {
				var descrGrp = findDescrGroup(tab.$.ID);
				if (descrGrp) {
					if (descrGrp.$.DIM && descrGrp.$.DIM === 1) {
						self.report.addError("Group [" + descrGrp.$.NAM + "] has a dimension equal to 1. Your have to use GRP Xml tag.");
					}
					checkAllowedNodes("TAB", tab);
					checkLines(tab, descrGrp);
				}
			});
		}

		//console.log("Description: " + JSON.stringify(description, null, 2));
		if (this.itemKeys) {
			// check the key pass and if they correspond the key description
			var adxkey = this.action === "LIST" ? description.ADXKEY.GRP.FLD : description.ADXREAD.GRP.FLD;
			if (!Array.isArray(adxkey)) {
				adxkey = [adxkey];
			}
			var inKey = true;
			for (var i = 0; i < adxkey.length && inKey; i++) {
				// looking for the item that have the name of the current fdl
				var found = false;

				for (var j = 0; j < this.itemKeys.length && !found; j++) {
					if (this.itemKeys[j].key === adxkey[i].$.NAM) {
						found = true;
						this.wkeys += (this.wkeys ? "~" : "") + this.itemKeys[j].value;
					}
				}
			}
		}
		//console.log("key "+this.wkeys);
		var paramsMap = getParamFieldInput();

		if (this.flow) { // put the value the parameter that have value
			if (!this.flow.PARAM) self.report.addError("Root node PARAM not found");
			checkAllowedNodes("PARAM", this.flow.PARAM);
			checkGroups(this.flow.PARAM);
			checkTables(this.flow.PARAM);
			//tracer.warn && tracer.warn("paramsMap: " + JSON.stringify(paramsMap, null, 2));
		}
		var paramsMapSorted = Object.keys(paramsMap).sort(function(a, b) {
			var ai = parseInt(a, 10);
			var bi = parseInt(b, 10);
			if (ai > bi) {
				return 1;
			} else if (ai === bi) {
				return 0;
			} else {
				return -1;
			}
		});
		var params = [];
		//console.log("params Sorted "+JSON.stringify(paramsMapSorted,null,2) );
		paramsMapSorted.forEach(function(k) {
			params.push(paramsMap[k]);
		});

		if (this.report.errors.length > 0) {
			this.status = 0;
			throw new CvgWsException(locale.format(module, "cantLoadInputXml"));
		}


		this.callParams = params;

	},
	getSoapResponse: function(status) {
		this.status = status != null ? status : this.status;
		var resp = {
			status: {
				$value: this.status,
			},
			messages: this.messages,
			result: this.result
		};
		if (resp.messages.length > 0) {
			resp.messages.forEach(function(message) {
				if (message.type === 1)
					tracer.info && tracer.info(message.message);
				else if (message.type === 2)
					tracer.warn && tracer.warn(message.message);
				else
					tracer.error && tracer.error(message.message);
			});
		}
		return resp;
	}
});