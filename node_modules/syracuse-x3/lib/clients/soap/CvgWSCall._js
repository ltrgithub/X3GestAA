"use strict";
var helpers = require('syracuse-core/lib/helpers');
var jsxml = require('jsxml');
var binaryHelper = require('syracuse-core/lib/binaryHelper');
var locale = require("syracuse-core/lib/locale");

var tracer = require("syracuse-trace/lib/helper").getTracer("soap-generic.ackcall");

var mapTypeToResu = {
	Decimal: "DCB",
	Char: "STRU",
	Integer: "INT",
	Blob: "BLOB",
	Date: "DATE",
	// TOOD add other type

};

function forceDefaultValue(type) {
	switch (type) {
		case "Decimal":
		case "Integer":
			return 0;
		default:
			return;
	}
}

var messageTypes = {
	MESS_INFO: 1,
	MESS_WARN: 2,
	MESS_BLOK: 3,
	MESS_EXEP: 4,
	MESS_ZONE: 5
};

exports.CvgWSCall = helpers.defineClass(function(techInfo, lang, opt) {
	this.techInfo = techInfo;
	this.lang = lang;
	this.name = opt.name;

	this.flow = opt.flow && jsxml.parse(opt.flow).PARAM; // ...xml
	this.action = opt.action;
	this.wtrace = opt.trace;
	// for objecg or list
	this.itemKeys = opt.wkeys; // for CRUD and list, criteria or keys elements
	this.wkeys = ""; // string that represent the key
	this.nb = opt.nb; // for list action , number of elements

	this.debugInfo = opt.debugInfo;
	// for action inslig or suplig
	this.tab = opt.tab; //blocKey
	this.par = opt.par; // lineKey

	// will be computed !
	this.description = null;
	this.callParam = null;
	this.status = null;
	this.result = null; // reply of the ack_call;
	this.messages = [];

}, null, {
	interpretReply: function(status, reply, beautify) {

		// Success status
		if (status === 1) {
			this.status = 1;

			//tracer.debug && tracer.debug("REPLY : " + JSON.stringify(reply, null, 2));


			var techParams = [],
				resultParams = [];

			// separate technical parameters and result parameters
			reply.json.params.forEach(function(param) {
				if (param.num > 11) {
					resultParams.push(param);
				} else {
					techParams.push(param);
				}
			});
			this._handleTechParams(techParams);

			resultParams = resultParams.concat(this.callParams);
			// Remove null objects for LIST operation
			if (this.action === "LIST") {
				resultParams = resultParams.filter(function(p) {
					return p.resu != null;
				});
			}

			// 
			this._computeResult(resultParams, beautify);
		}
		// Fail status
		else if (status === 0) {
			this.status = 0;
			this._handleTechParams(reply.json.params);
		}
		// database closed
		else if (status === 6) {
			this.status = 0;
			this._handleTechParams(reply.json.params);
			// Not sure we need to personalize message...
			// Maybe a message is sent by X3 ?
			this.addMessage("TODO", locale.format(module, "dbmsClosed"));
		}
		return this.getSoapResponse();
	},
	addMessage: function(type, message) {
		this.messages.push({
			type: type,
			message: message
		});
	},
	_handleTechParams: function(params) {
		var techParamsMap = [];
		params.forEach(function(p) {
			if (p.num != null) {
				techParamsMap[p.num] = techParamsMap[p.num] || {};
				techParamsMap[p.num][p.poste] = p;
			}
		});
		//tracer.debug && tracer.debug("Technical parameters: "+JSON.stringify(techParamsMap,null,2));

		// Manage messages
		if (techParamsMap[3] && techParamsMap[4]) {
			for (var i = 0; i < Object.keys(techParamsMap[3]).length; i++) {
				this.addMessage(techParamsMap[3][i].resu, techParamsMap[4][i].resu);
			}
		}
	},
	_computeResult: function(params, beautify) {
		var self = this;
		/*
		 * resultParamMap is a object in 2 level, first key is the num that correspond to the idx in the description and second is poste link the dimension of the description
		 */
		function getParamFieldOutputXml(resultParamMap) {

			function findMenuLabel(idMenu, resu) {
				var menus = self.description.ADXMEN.MNU;
				if (!Array.isArray(menus)) {
					menus = [menus];
				}
				var found = null;
				for (var i = 0; i < menus.length && !found; i++) {
					var menu = menus[i];

					if (menu.$.NO === idMenu && self.lang) {
						// find right VAL
						var vals = !Array.isArray(menu.VAL) ? [menu.VAL] : menu.VAL;

						for (var j = 0; j < vals.length && !found; j++) {
							if (parseInt(vals[j].$.IND, 10) === parseInt(resu, 10)) {
								found = vals[j].$["C_" + self.lang];
							}
						}
					}
				}
				return found;
			}

			function _createField(elt, field, id, force) {
				var _p, _params = resultParamMap[currentIdx] && resultParamMap[currentIdx];
				if (_params) {
					if (field.$.DIM > 1 && field.$.MEN) {
						elt.LST = elt.LST || [];
						var _lst = {
							$: {
								MENULOCAL: field.$.MEN,
								NAME: field.$.NAM,
								SIZE: field.$.DIM,
								TYPE: field.$.TYP
							}
						};
						for (var i = 0; i < field.$.DIM; i++) {
							_p = _params[i];
							_lst.ITM = _lst.ITM || [];
							if (_p && _p.resu) {
								var _itm = {
									$: {
										MENULAB: findMenuLabel(field.$.MEN, _p && _p.resu)
									}
								};
								_lst.ITM.push(_itm);
							}


						}
						if (_lst.ITM && _lst.ITM.length > 0) elt.LST.push(_lst);
					} else {
						_p = _params[id || 0];
						elt.FLD = elt.FLD || [];
						var _fld = {
							$: {}
						};
						if (_p && _p.resu) {
							if (field.$.TYP === "Blob") {
								var buf = new Buffer(_p.resu, "hex");
								_fld.$.BYTES = buf.length;
								_fld.$.MIMETYPE = binaryHelper.calcMimeType(buf);
								_fld.$value = buf.toString('base64');
							} else {
								_fld.$value = _p.resu;
							}
							// Menu set only if a resu is available
							if (field.$.MEN) {
								_fld.$.MENULAB = findMenuLabel(field.$.MEN, _p && _p.resu);
								_fld.$.MENULOCAL = field.$.MEN;
							}
							// Keep attributes order
							_fld.$.NAME = field.$.NAM;
							_fld.$.TYPE = field.$.TYP;
							//
							elt.FLD.push(_fld);
						}
						// force default value for table line without resu (if it's not a menu)
						else if (!force || (force && !field.$.MEN)) {
							var _def = forceDefaultValue(field.$.TYP);
							if (_def != null) {
								_fld.$value = _def;
							}
							// Keep attributes order
							_fld.$.NAME = field.$.NAM;
							_fld.$.TYPE = field.$.TYP;
							//
							elt.FLD.push(_fld);
						}
					}
				}
			}

			function _createGroup(elt, grp) {
				elt.GRP = elt.GRP || [];
				var _grp = ({
					$: {
						ID: grp.$.NAM
					}
				});
				var flds = Array.isArray(grp.FLD) ? grp.FLD : [grp.FLD];
				flds.forEach(function(_fld) {
					_createField(_grp, _fld);
					currentIdx++;
				});
				if ((_grp.FLD && _grp.FLD.length > 0) || (_grp.LST && _grp.LST.length > 0)) elt.GRP.push(_grp);
			}

			function _createLine(elt, num, flds) {
				elt.LIN = elt.LIN || [];
				var _lin = {
					$: {
						NUM: num + 1
					}
				};
				flds.forEach(function(_fld) {
					// force field even if resu is null
					_createField(_lin, _fld, num, true);
					currentIdx++;
				});
				if ((_lin.FLD && _lin.FLD.length > 0) || (_lin.LST && _lin.LST.length > 0)) elt.LIN.push(_lin);
			}

			function _createTable(elt, grp) {
				elt.TAB = elt.TAB || [];
				// Get size param
				var size = resultParamMap[currentIdx] && resultParamMap[currentIdx][0].resu || 0;
				currentIdx++;
				//
				var _tab = ({
					$: {
						DIM: grp.$.DIM,
						ID: grp.$.NAM,
						SIZE: size
					}
				});
				var flds = Array.isArray(grp.FLD) ? grp.FLD : [grp.FLD];
				for (var i = 0; i < size; i++) {
					_createLine(_tab, i, flds);
					currentIdx -= flds.length;
				}
				//
				if (_tab.LIN && _tab.LIN.length > 0) elt.TAB.push(_tab);
				currentIdx += flds.length;
			}

			//
			var output = {
				RESULT: {
					$: {}
				}
			};

			var descripData = self.description.ADXDATA;
			if (self.action === "LIST") {
				descripData = self.description.ADXKEY;
			}

			//			tracer.debug && tracer.debug("Data in description: " + JSON.stringify(descripData, null, 2));
			//			tracer.debug && tracer.debug("Params: " + JSON.stringify(resultParamMap, null, 2));

			var currentIdx = 0;
			var grps = Array.isArray(descripData.GRP) ? descripData.GRP : [descripData.GRP];
			grps.forEach(function(grp) {


				if (grp.$.NAM === "LEFTLIST") {
					var size = resultParamMap.reduce(function(prev, cur) {
						var len = Object.keys(cur).length;
						return len > prev ? len : prev;
					}, 0);
					if (size !== 0) {
						output.RESULT.$.DIM = grp.$.DIM;
						output.RESULT.$.SIZE = size;
						var flds = Array.isArray(grp.FLD) ? grp.FLD : [grp.FLD];
						for (var i = 0; i < output.RESULT.$.SIZE; i++) {
							_createLine(output.RESULT, i, flds);
							currentIdx -= flds.length;
						}
					}
				} else {
					// GRP or TAB ?
					var grpKind = grp.$.TYB === "Table" ? "TAB" : "GRP";
					if (grpKind === "GRP") {
						_createGroup(output.RESULT, grp);
					} else if (grpKind === "TAB") {
						_createTable(output.RESULT, grp, resultParamMap);
					}
				}
			});
			var opt = {};
			if (beautify) opt.indent = '\t';
			return '<?xml version="1.0" encoding="UTF-8"?>' + (beautify ? "\n" : "") + jsxml.stringify(output, opt);
		}
		//
		if (!this.result) {
			// create a map with num (correspond to index) as a id in order to match the description
			var resParamsMap = [];
			params.forEach(function(p) {
				if (p.num != null) {
					resParamsMap[p.num] = resParamsMap[p.num] || {};
					resParamsMap[p.num][p.poste] = p;
				} else if (p.index != null && !resParamsMap[p.index]) {
					resParamsMap[p.index] = resParamsMap[p.index] || {};
					if (!Array.isArray(p.resu)) {
						p.resu = [p.resu];
					}
					p.resu.forEach(function(resu, idx) {
						resParamsMap[p.index][idx] = {
							num: p.index,
							poste: idx,
							typ: p.typ,
							resu: resu
						};
					});

				}
			});
			this.result = getParamFieldOutputXml(resParamsMap.slice(12));
		}
	},
	setAckCallParams: function(description) {
		this.description = description;
		var descriptionSub = this.action === "LIST" ? description.ADXKEY : description.ADXDATA;
		var self = this;

		function findDescrGroup(id) {
			if (descriptionSub) {
				var grps = Array.isArray(descriptionSub.GRP) ? descriptionSub.GRP : [descriptionSub.GRP];
				var found = null;
				for (var i = 0; i < grps.length && !found; i++) {
					found = grps[i].$.NAM === id ? grps[i] : null;
					if (!found)
						found = grps[i].$.NAME === id ? grps[i] : null;

				}
				return found;
			}
			return null;
		}


		function getParamFieldInput() {
			if (descriptionSub) {
				var currentidx = 12;
				var paramsInput = {};
				var grps = Array.isArray(descriptionSub.GRP) ? descriptionSub.GRP : [descriptionSub.GRP];
				grps.forEach(function(grp) {
					if (grp.$.DIM > 1 && self.action !== "LIST") { // add parameter with te idx
						paramsInput[currentidx] = {
							"index": currentidx,
							"descr": grp.$.IDTAB,
							"dim": 1,
							"nb": 0,
							"size": 0,
							"typ": "INT",
						};
						currentidx++;
					}

					var flds = Array.isArray(grp.FLD) ? grp.FLD : [grp.FLD];
					flds.forEach(function(fld) {

						paramsInput[currentidx] = {
							"index": currentidx,
							"descr": fld.$.NAM || fld.$.NAME,
							"dim": fld.$.DIM || grp.$.DIM,
							"nb": 0,
							"size": 0,
							"typ": mapTypeToResu[fld.$.TYP],
							"mod": fld.$.MOD
						};
						currentidx++;
					});
				});
				return paramsInput;
			}
		}

		function findDescrfield(id, jsonDescrGrp) {
			if (jsonDescrGrp) {
				var flds = Array.isArray(jsonDescrGrp.FLD) ? jsonDescrGrp.FLD : [jsonDescrGrp.FLD];
				var found = null;
				for (var i = 0; i < flds.length && !found; i++) {
					found = flds[i].$.NAM === id ? flds[i] : null;
					if (!found)
						found = flds[i].$.NAME === id ? flds[i] : null;

				}
				return found;
			}
			return null;
		}

		//console.log("Description: " + JSON.stringify(description, null, 2));
		if (this.itemKeys) {
			// check the key pass and if they correspond the key description
			var adxkey = this.action === "LIST" ? description.ADXKEY.GRP.FLD : description.ADXREAD.GRP.FLD;
			if (!Array.isArray(adxkey)) {
				adxkey = [adxkey];
			}
			var inKey = true;
			for (var i = 0; i < adxkey.length && inKey; i++) {
				// looking for the item that have the name of the current fdl
				var found = false;

				for (var j = 0; j < this.itemKeys.length && !found; j++) {
					if (this.itemKeys[j].key === adxkey[i].$.NAM) {
						found = true;
						this.wkeys += (this.wkeys ? "~" : "") + this.itemKeys[j].value;
					}
				}
			}
		}
		//console.log("key "+this.wkeys);
		var paramsMap = getParamFieldInput();

		// put all input param with no value


		if (this.flow) { // put the value the parameter that have value
			var grps = Array.isArray(this.flow.GRP) ? this.flow.GRP : [this.flow.GRP];
			// check if the group exists in the descirption and analyse all field to create a param
			grps.forEach(function(grp) { // check if the group exists in the
				var descrGrp = findDescrGroup(grp.$.ID);
				// check field in flow and association with field in group in order to create parameter
				var currentidx = 12;
				var flds = grp.FLD;
				if (!Array.isArray(flds)) {
					flds = [flds];
				}
				flds && flds.forEach(function(fld) { // TODO manage the order of field regarding description
					var descrFld = findDescrfield(fld.$.NAM || fld.$.NAME, descrGrp);

					if (descrFld) {
						// erase the preview parameter
						paramsMap[currentidx] = {
							"index": currentidx,
							"descr": fld.$.NAM || fld.$.NAME,
							"dim": descrGrp.$.DIM,
							"nb": 1, // TODO manage number of field properly
							"size": mapTypeToResu[descrFld.$.TYP] === "STRU" || mapTypeToResu[descrFld.$.TYP] === 'CLOB' ? fld.$value.length : 1,
							"typ": mapTypeToResu[descrFld.$.TYP],
							"resu": fld.$value
						};
						currentidx++;
					}
				});
			});
			//console.log("params " + JSON.stringify(params, null, 2));
		}
		var paramsMapSorted = Object.keys(paramsMap).sort(function(a, b) {
			var ai = parseInt(a, 10);
			var bi = parseInt(b, 10);
			if (ai > bi) {
				return 1;
			} else if (ai === bi) {
				return 0;
			} else {
				return -1;
			}
		});
		var params = [];
		//console.log("params Sorted "+JSON.stringify(paramsMapSorted,null,2) );
		paramsMapSorted.forEach(function(k) {
			params.push(paramsMap[k]);
		});
		this.callParams = params;
	},
	getSubprogName: function() {
		// TODO
	},
	getSoapResponse: function() {
		var resp = {
			status: {
				$value: this.status,
			},
			messages: this.messages,
			result: this.result
		};
		return resp;
	}
});