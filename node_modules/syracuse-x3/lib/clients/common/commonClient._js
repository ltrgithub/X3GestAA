"use strict";

var helpers = require('syracuse-core/lib/helpers');
var streams = require('streamline/lib/streams/streams');
var OfflinePlayer = require('syracuse-x3/lib/clients/common/offlinePlayer').OfflinePlayer;
var upath = require('path');
var ufs = require('fs');
var configRecords;
var recordMgr = require("syracuse-x3/lib/convergence/records/recordMgr").recordMgr;
var CommClass;



exports.CommonClient = helpers.defineClass(function(_, options, hostname, port, user, password, secured) {


	this.clientDescr = options.clientDescr;
	this.config = options.config;
	this.recOptions = options.recOptions;
	CommClass = options.CommClass;
	if (this.recOptions && this.recOptions.path) {
		this.recOptions = options.recOptions ? options.recOptions : null;
		configRecords = {
			dumpPath: upath.join(process.mainModule.filename.substring(0, process.mainModule.filename.indexOf("node_modules")), this.recOptions.path)
		};
	}

	this.hostname = hostname;
	this.port = port;
	this.user = user;
	this.password = password;
	this.secured = secured;
	this.__connect(_);
}, null, {

	_disconnect: function(_) {
		this.communicator && this.communicator.disconnect(_);
		if (this.stream) {
			this.stream.end();
			this.stream = null;
		}
	},
	__connect: function(_) {
		function readJsonPlayer(_, path) {
			var json;
			try {
				json = ufs.readFileSync(path, 'utf8') || "";
				json = json.trim();
				if (json.length === 0) throw new Error("Empty file");
				if (json[json.length - 1] === ',') json = json.substring(0, json.length - 1);
				json = "[" + json + "]";
			} catch (e) {
				throw e;
			}
			try {
				json = JSON.parse(json);
				return json;
			} catch (e) {
				throw e;
			}
			return null;
		}


		try {
			if (!this.stream || !this.communicator) {

				if (this.recOptions && this.recOptions.recMode === "PLAY") {
					this.stream = new OfflinePlayer(_, readJsonPlayer(_, configRecords.dumpPath + "/cvgRecords/" + this.recOptions.fileName));
				} else {
					this.stream = streams.tcpClient(this.port, this.hostname).connect(_);
					this.stream.setNoDelay(true);
					if (this.recOptions && this.recOptions.recMode === "REC") {
						this.recorder = recordMgr.newRecorder(_, this.stream, this.recOptions, {}, configRecords);

					}
				}

				this.communicator = new CommClass(_, this);
				this.pid = this.communicator.connect(_, this.user, this.password, this.secured);
				this.__setSocketTimeout(_);
			} else {
				this.__setSocketTimeout(_, true);
			}

		} catch (e) {
			console.log(this.clientDescr + " connection error : " + e.stack);
			this.__panicRelease(_);
			throw e;
		}
	},
	__setSocketTimeout: function(_, prevent, timeoutFunc) {
		if (this.socketTimeout && prevent) {
			clearTimeout(this.socketTimeout);
		}
		var self = this;
		this.socketTimeout = timeoutFunc || setTimeout(function() {
			try {
				if (self.stream && self.communicator) {
					//self.communicator.disconnect(_);
					this.recorder && this.recorder.close();
					self.communicator = null;
					self.stream.end();
					self.stream = null;
				}
			} catch (e) {
				console.log(this.clientDescr + " disconnection error: " + e.stack);
				self.stream.end();
				self.stream = null;
				throw e;
			}
		}, (this.config && this.config.timeout) || 10000);
	},
	__panicRelease: function(_) {
		var dis = false;
		try {
			this.recorder && this.recorder.close();
			this.communicator && this.communicator.disconnect(_);
			dis = true;
			this.stream && this.stream.end();
		} catch (e) {
			try {
				if (!dis && this.stream) {
					this.stream.end();
				}
			} catch (e) {}
		} finally {
			this.stream = null;
		}
	}

});