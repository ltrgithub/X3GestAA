"use strict";
var helpers = require('syracuse-core/lib/helpers');

exports.OfflinePlayer = helpers.defineClass(function(_, json) {
	this.json = json ? json : null;
	// skip RECINFO and COMMENT
	this.step = 2;
	this._nextStep();
}, null, {
	_nextStep: function() {
		if (this.step < this.json.length) {
			this.curStep = this.json[this.step++];
			try {
				this.curStep.buf = new Buffer(this.curStep.data, 'hex');
			} catch (e) {
				this.curStep.buf = new Buffer(this.curStep.data, 'utf8');
			}
			this.curStep.offset = 0;
		}
	},
	end: function() {
		// nothin
	},
	read: function(_, size) {
		if (this.step <= this.json.length) {
			if (size == null && this.curStep.type === "READ") size = this.curStep.buf && this.curStep.buf.length;
			else throw new Error("expected READ, got " + this.curStep.type);
			var buf;
			if (this.curStep.type === "READ") {
				if (this.curStep.buf && this.curStep.buf.length >= this.curStep.offset + size) {
					buf = this.curStep.buf.slice(this.curStep.offset, size);
					this.curStep.offset += size;
					if (this.curStep.offset === this.curStep.buf.length) this._nextStep();
					return buf;
				} else { // ask to read with a size > length
					if (this.curStep.buf && this.curStep.offset < this.curStep.buf.length) {
						buf = this.curStep.buf.slice(this.curStep.offset, this.curStep.buf.length);
					}
					this._nextStep();
					buf = Buffer.concat([buf, new Buffer(size - buf.length)]);
				}
			}
			return new Buffer(size);
		}
	},
	write: function(_, buf) {
		if (this.step <= this.json.length) {
			if (this.curStep.type === "WRITE") {
				this.curStep.writeBuf = this.curStep.writeBuf || new Buffer([]);
				this.curStep.writeBuf = Buffer.concat([this.curStep.writeBuf, buf]);
				var len = this.curStep.writeBuf.length;
				if (this.curStep.buf && this.curStep.writeBuf.toString('hex') !== this.curStep.buf.slice(0, len).toString('hex')) {
					console.error("Buffer1: " + JSON.stringify(this.curStep.buf.slice(0, len).toString('utf8')));
					console.error("Buffer2: " + JSON.stringify(this.curStep.writeBuf.toString('utf8')));
					throw new Error("bytes written not correspond to buffer saved written buffer[" + this.curStep.writeBuf.toString('hex') + "] saved buffer[" + this.curStep.buf.slice(0, len).toString('hex') + "]");
				}
				if (this.curStep.buf && this.curStep.writeBuf.length === this.curStep.buf.length) this._nextStep();
				return;
			}
		}
		throw new Error("step not correspond to WRITE step save file curStep " + JSON.stringify(this.curStep, null, 2));
	},
	readHttpResp: function() {
		if (this.step <= this.json.length) {
			if (this.curStep.type === "HTTPRESP") {
				var data = this.curStep.data;
				this._nextStep();
				return data;
			}
		}
		throw new Error("step not correspond to HTTPRESP step save file curStep " + JSON.stringify(this.curStep, null, 2));
	},

});