"use strict";

var helpers = require('syracuse-core/lib/helpers');
var locale = require("syracuse-core/lib/locale");
var flows = require('streamline/lib/util/flows');
var x3helpers = require("syracuse-x3/lib/helpers");
var config = require('syracuse-main/lib/nodeconfig').config;
var clientModule = require('syracuse-x3/lib/client').module;


var CommError = exports.CommError = helpers.defineClass(function(message) {
	Error.call(this);
	Error.captureStackTrace(this, this);
	this.message = message;
}, Error, {});


var traceBuffer = exports.traceBuffer = function(tracer, id, descr, buf) {
	if (buf)
		tracer && tracer("Buffer[" + id + "] (" + descr + ") = " + buf.toString('hex') + " [Length: " + buf.length + "]");
};

function ReadableMemoryStream(data, enc) {
	var self = this;
	//
	var position = 0;
	var buffer = new Buffer(data, enc);
	var encoding = enc;
	//
	self.read = function(_, len) {
		var end = (len ? (len + position) : buffer.length);
		if (position >= buffer.length) return null;
		var buf = buffer.toString(encoding, position, end);
		position = end;
		return buf;
	};
}

function WritableMemoryStream() {
	var self = this;
	//
	var chunks = [];
	//
	self.write = function(_, data, enc) {
		chunks.push(typeof data === "string" ? new Buffer(data, enc || "utf8") : data);
	};
	self.toString = function(enc) {
		return chunks.map(function(chunk) {
			return chunk.toString(enc);
		}).join("");
	};
	self.end = function() {
		// ?
	};
}

function _getSrvErrorFromResponse(mainMess, response, params) {
	var error, message = mainMess,
		diagnoses = null;
	if (response.body && response.body.$diagnoses && response.body.$diagnoses.length > 0) {
		diagnoses = response.body.$diagnoses;
	} else if (response.body && response.body.$diagnoses) {
		diagnoses = [response.body.$diagnoses];
	} else {
		message = mainMess + ": " + JSON.stringify(response.body);
	}
	error = new Error(message);
	if (response.head && response.head.statusCode)
		error.httpStatus = response.head.statusCode;
	if (response.body)
		error.httpBody = response.body;
	if (diagnoses) {

		if (diagnoses[0]) {
			// Customize message for bad logins on connection
			if (diagnoses[0].$message === "Incorrect user / password") {
				diagnoses[0].$message = locale.format(clientModule, "noMatchingUser", params.userName);
			}
			// Concat generic message and details
			diagnoses[0].$message = message + " : " + diagnoses[0].$message;
		}
		error.$diagnoses = diagnoses;
	}
	return error;
}

exports.CommonComm = helpers.defineClass(function(_, stream, tracer) {
	this.stream = stream;
	this.tracer = tracer;
}, null, {
	_checkStream: function() {
		if (!this.stream) throw new CommError(locale.format(module, "streamNull"));
	},

	// Old implementation with old protocol
	_writeBufConnectSafeV1: function(_, params) {
		this.tracer && this.tracer("\n### Create buffer for CONNECTION ###");
		var bufServiceId = new Buffer(1);
		bufServiceId.writeInt8(params.serviceId, 0);
		var buf;
		if (params.user && params.password) {
			var bufUser = new Buffer(params.user, "utf-8");
			var bufPass = new Buffer(params.password, "utf-8");
			var bufLenUser = new Buffer(1);
			bufLenUser.writeInt8(bufUser.length, 0);
			var bufLenPass = new Buffer(1);
			bufLenPass.writeInt8(bufPass.length, 0);
			var bufLenUtil = new Buffer(1);
			bufLenUtil.writeInt8(bufUser.length * 2 + bufPass.length + 3, 0);

			this.tracer && this.tracer("Buffer[0] (Service ID) " + bufServiceId.toString("hex"));
			this.tracer && this.tracer("Buffer[1] (Length to follow) " + bufLenUtil.toString("hex"));
			this.tracer && this.tracer("Buffer[2] (User length) " + bufLenUser.toString("hex"));
			this.tracer && this.tracer("Buffer[3] (User) " + bufUser.toString("hex"));
			this.tracer && this.tracer("Buffer[4] (User length) " + bufLenUser.toString("hex"));
			this.tracer && this.tracer("Buffer[5] (User) " + bufUser.toString("hex"));
			this.tracer && this.tracer("Buffer[6] (Password length) " + bufLenPass.toString("hex"));
			this.tracer && this.tracer("Buffer[7] (Password) " + bufPass.toString("hex"));
			buf = Buffer.concat([bufServiceId, bufLenUtil, bufLenUser, bufUser, bufLenUser, bufUser, bufLenPass, bufPass]);
		} else {
			buf = Buffer.concat([bufServiceId, new Buffer([0])]);
		}
		this.tracer && this.tracer(buf);
		this.stream.write(_, buf);
	},
	// New implementation with wire protocol
	_writeBufConnectSafeV2: function(_, params) {
		this.tracer && this.tracer("\n### Create buffer for CONNECTION ###");
		var bufSyrMode = new Buffer(1);
		bufSyrMode.writeInt8(0, 0);
		var bufServiceId = new Buffer(1);
		bufServiceId.writeInt8(params.serviceId, 0);
		var bufSecMode = new Buffer(1);
		bufSecMode.writeInt8(3, 0);

		this.tracer && this.tracer("Buffer[0] (Syracuse mode) " + bufSyrMode.toString("hex"));
		this.tracer && this.tracer("Buffer[0] (Service ID) " + bufServiceId.toString("hex"));
		this.tracer && this.tracer("Buffer[0] (Security mode) " + bufSecMode.toString("hex"));
		var buf = Buffer.concat([bufSyrMode, bufServiceId, bufSecMode, new Buffer([1])]);

		this.tracer && this.tracer(buf);
		this.stream.write(_, buf);
	},
	_connect: function(_, serviceId, user, password, secured) {
		this._checkStream();

		var impl = "SAFEV2";
		if (user == null && password == null && secured == null) {
			this._writeBufConnectSafeV2(_, {
				serviceId: serviceId
			});
		} else {
			impl = "SAFEV1";
			this._writeBufConnectSafeV1(_, {
				serviceId: serviceId,
				secured: secured,
				user: user,
				password: password
			});
		}
		this.tracer && this.tracer("\n### Read buffer for order: CONNECT ###");
		var buf = this.read(_, 4);
		var pid = buf.readInt32BE(0);
		if (pid > -1) {
			traceBuffer(this.tracer, 0, "PID", buf);
			this.tracer && this.tracer("Adonix process pid: " + pid);
			if (impl === "SAFEV2") this._authenticate(_, pid);
			return pid;
		} else {
			buf = this.read(_, 5);
			traceBuffer(this.tracer, 1, "Message length (1) and error code (4)", buf);
			var msgLen = buf.readInt8(0);
			var errCode = buf.readInt32BE(1);
			buf = this.read(_, msgLen);
			traceBuffer(this.tracer, 2, "Error message", buf);
			var msg = buf.toString('utf-8');
			throw new CommError(locale.format(module, "connectionFailed", errCode, msg));
		}
	},
	read: function(_, len) {
		try {
			return this.stream.read(_, len);
		} catch (e) {
			if (e.code === "ETIMEOUT") e.message = locale.format(clientModule, "x3ReadTimeout", len, this.stream.available());
			// destroy stream
			if (this.stream) this.stream.destroy();
			this.stream = null;
			//
			throw e;
		}
	},
	_authenticate: function(_, pid) {
		var self = this;

		function _outBuffer(code, obj) {
			var toSend;
			if (Buffer.isBuffer(obj)) toSend = obj;
			else {
				toSend = ((typeof obj === "object") ? JSON.stringify(obj) : obj);
				toSend = toSend ? new Buffer(toSend, "utf8") : new Buffer([]);
			}
			var len = toSend.length + 1;
			self.tracer && self.tracer("X3.client.outBuffer: sending length: " + len);
			var buf = new Buffer(len + 4);
			buf[0] = (len >> 24) & 0xff;
			buf[1] = (len >> 16) & 0xff;
			buf[2] = (len >> 8) & 0xff;
			buf[3] = len & 0xff;
			buf[4] = code;
			toSend.copy(buf, 5);
			return buf;
		}

		function _readFrame(_, encoding) {
			self.tracer && self.tracer("reading frame from X3");
			var intro = self.read(_, 5, true);
			if (intro == null) throw new Error("error reading frame: stream closed");
			var len = _readInt(intro);
			self.tracer && self.tracer("reading frame from X3: got len=" + (len - 1));
			var data = self.read(_, len - 1, true);
			self.tracer && self.tracer("frame read ok");
			return {
				code: intro[4],
				data: (encoding ? data && data.toString(encoding) : data)
			};
		}

		function _readInt(chunk) {
			return (chunk[0] << 24) | (chunk[1] << 16) | (chunk[2] << 8) | chunk[3];
		}

		function _checkCode(got, expected) {
			if (got != expected) throw new Error("bad frame code: got " + got + ", expected " + expected);
		}

		function _send(_, header, request, response) {
			self.tracer && self.tracer("sending header: " + JSON.stringify(header));
			if (header && header["x3-referer"]) {
				header.referer = header["x3-referer"];
				delete header["x3-referer"];
			}
			if (header && header["x3-content-length"]) {
				header["content-length"] = header["x3-content-length"];
				delete header["x3-content-length"];
			}

			//
			self.stream.write(_, _outBuffer(1, header));
			var buf;
			while ((buf = request.read(_))) {
				self.tracer && self.tracer("sending chunk: " + (buf ? buf : "null"));
				self.stream.write(_, _outBuffer(2, buf));
			}
			self.tracer && self.tracer("write end frame");
			self.stream.write(_, _outBuffer(3, ""));
			//
			var frame = _readFrame(_, "binary");
			self.tracer && self.tracer("received header frame: " + frame.data);
			_checkCode(frame.code, 1);
			var head = JSON.parse(frame.data);
			head.statusCode = head.status; // compat stuff -- fix protocol
			self.tracer && self.tracer("head.location: " + head.location);

			response.writeHead(head.statusCode, head);
			do {
				frame = _readFrame(_);
				self.tracer && self.tracer("received body frame " + frame.code + ": " + frame.data.toString("utf8"));
				//			this.tracer && this.tracer("received body frame " + frame.code);
				if (head.statusCode === 500) {
					self.tracer && self.tracer("ERROR 500: head=" + JSON.stringify(head) + "\nbody=" + frame.data);
					console.error("ERROR 500: head=" + JSON.stringify(head) + "\nbody=" + frame.data);
				}
				response.write(_, frame.data);
			} while (frame.code == 2);
			_checkCode(frame.code, 3);

			self.tracer && self.tracer("ending response");
			response.end();
			// suicide client if 500 response code as the X3 server might be in inconsistent state
			if (head.statusCode === 500) {
				try {
					//  #3978 - _send is called through a funnel - We force to use a new funnel to disconnect because current _funnel is busy
					self.disconnect(_, flows.funnel(1));
				} catch (e) {
					self.stream = null;
				}
			}
			// for diagnose
			return head;
		}

		function _jsonSend(_, params, funnel) {
			if (!funnel) funnel = flows.funnel(1);
			return funnel.call(null, _, function(_) {
				var response = new WritableMemoryStream();
				response.writeHead = function(statusCode, headers) {
					this.statusCode = statusCode;
					this.headers = headers;
				};
				self.tracer && self.tracer("_jsonSend : " + JSON.stringify(params.body));
				_send(_, params.head, new ReadableMemoryStream(params.raw && typeof(params.body) === "string" ? params.body : JSON.stringify(params.body)), response);
				var respStr = response.toString("utf8");
				self.tracer && self.tracer("_jsonSend got response: " + respStr);
				if (params.raw) {
					// no transformation
				} else if (respStr) try {
					respStr = JSON.parse(respStr);
				} catch (e) {
					// make a diagnose body
					respStr = {
						$diagnoses: [{
							$severity: "error",
							$message: respStr
						}]
					};
				} else respStr = null;
				//
				var result = {
					head: response.headers,
					body: respStr
				};
				result.head.statusCode = response.statusCode;
				//
				return result;
			});
		}

		try {
			var response = _jsonSend(_, {
				head: {
					method: "POST",
					url: "/$connections",
					"content-type": "application/json",
					"accept-language": "en-US"
				},
				body: {
					server: "sadfsq$connections",
					folder: "sadfsq$connections",
					runtimeLog: "",
					runtimeLogDir: ""
				}
			});
			if (response.head.statusCode >= 400) {
				throw _getSrvErrorFromResponse(clientModule.format(module, "connectError"), response);
			}
			if (response.head.statusCode != 201) throw new Error("connect failed: " + JSON.stringify(response));
			var _x3 = {
				pid: pid
			};

			_x3.connectionUrl = response.head.location;
			_x3.connectionId = response.body.id;
			_x3.auth = response.body.auth;
			if (!_x3.connectionUrl) throw new Error("connectionUrl missing");
			if (!_x3.connectionId) throw new Error("connectionId missing");


			var sendParams = {
				head: {
					method: "POST",
					url: "/$sessions", // debug mode is curre,tly not supported: + (nodeconfig && nodeconfig.config && nodeconfig.config.debugMode ? "?debugMode=" + nodeconfig.config.debugMode : ""),
					"content-type": "application/json",
					"accept": "application/json;vnd.sage=syracuse",
					"accept-language": "en-US"
				},
				body: {
					connectionId: _x3.connectionId,
				}
			};

			if (_x3.auth && (_x3.auth.method === "X3RSA")) {
				sendParams.head.authorization = "x3-challenge";
				var pubkeyName = config.sdata.pubkeyName;
				if (config.certificate) {
					pubkeyName = config.certificate.name(_).replace(/[\@\$\.]/g, "_");
				} else if (config.x3key) { // use internal certificate of this server
					pubkeyName = require('os').hostname().toLowerCase().replace(/[\@\$\.]/g, "_");
				}
				self.tracer && self.tracer("pubkeyname " + pubkeyName);
				var auth = sendParams.body.auth = {
					method: "X3RSA",
					pubkey: pubkeyName,
					user: "sage"
				};
				auth.signature = x3helpers.getSignature(_, _x3.auth.challenge, auth.user, config.certificate);
			}

			response = _jsonSend(_, sendParams);
			if (response.head.statusCode >= 400) {
				throw _getSrvErrorFromResponse(locale.format(clientModule, "createSessError"), response, sendParams);
			}
			if (response.head.statusCode != 201) throw new Error("create session failed: " + JSON.stringify(response));
			_x3.sessionUrl = response.head.location;
			_x3.sessionId = response.body.id; // ?
			if (!_x3.sessionUrl) throw new Error("sessionUrl missing");
			if (!_x3.sessionId) throw new Error("sessionId missing");
			//
		} catch (e) {
			// close stream
			if (self.stream) self.stream.destroy();
			self.stream = null;
			throw e;
		}

	}
});