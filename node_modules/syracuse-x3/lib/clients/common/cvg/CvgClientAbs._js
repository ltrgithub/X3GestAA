"use strict";
var helpers = require('syracuse-core/lib/helpers');
var CvgObserver = require("syracuse-x3/lib/convergence/client/CvgObserver").CvgObserver;
var x3helpers = require('syracuse-x3/lib/helpers');
var flows = require('streamline/lib/util/flows');
var datetime = require("syracuse-core/lib/types/datetime");
var locale = require("syracuse-core/lib/locale");
var CvgClientConfig = require("syracuse-x3/lib/convergence/model/CvgClientConfig").CvgClientConfig;
var CONNECT_ACTION = require('syracuse-x3/lib/convergence/client/CvgAction').CONNECT_ACTION;
var CvgRequestAbs = require("syracuse-x3/lib/clients/common/cvg/CvgRequestAbs").CvgRequestAbs;
var CvgException = require('syracuse-x3/lib/convergence/model/CvgException').CvgException;
var CvgIst = require('syracuse-x3/lib/convergence/types/CvgIst').CvgIst;
var localConfig = x3helpers.config("x3fusion", null, {});
var x3writer = require("syracuse-x3/lib/convergence/automata/x3writer");
var CvgResu = require('syracuse-x3/lib/convergence/types/CvgResu').CvgResu;
var CvgResuTdo = require('syracuse-x3/lib/convergence/types/CvgResu').TDO;
var tracerStd = require("syracuse-trace/lib/helper").getTracer("classic.std");
var tracerAction = require("syracuse-trace/lib/helper").getTracer("classic.action");
var tracerProtocol = require("syracuse-trace/lib/helper").getTracer("classic.protocol");
var tracerSession = require("syracuse-trace/lib/helper").getTracer("classic.session");
var CvgReply = require('syracuse-x3/lib/convergence/client/CvgReply').CvgReply;
var perfmon = require('syracuse-perfmon');
var automata = require("syracuse-x3/lib/convergence/automata/x3Automata");

var perfmonEnabled = x3helpers.config("perfmon.activate", localConfig);
var perfmonDetail = x3helpers.config("perfmon.detail", localConfig);
var perfConfig = localConfig.perfmon || {};
var _recModes = ["REC", "PLAY"];

//


exports.CvgClientAbs = helpers.defineClass(function(stream, x3server, aConfig, recorder, context) {
	CvgObserver.call(this);

	var x3server = x3server;
	var user = user;

	this.response = {
		head: {
			statusCode: 200
		},
		body: {}
	};
	// intregration ILOG -  SAM 91439
	this.funnelAction = flows.funnel(1);
	this.cvgWinStubPath = "/../data/";
	this.askKill = false;
	this.lastAckCallSpgmId = [];
	this.isProcessingRequest = false;
	this.timing = {};
	this.srvTrace = null;
	this.baseUrl = context.baseUrl;
	this.recorder = recorder;
	this.creationDate = datetime.now();
	this.stream = stream;
	this.clientConfig = new CvgClientConfig(this, aConfig);
	this._trackLists = this.newTrackLists();
	this._sessionSettings = {};
	this._x3SessionSettings = {};
	this.activeRequest = null;

	this.uuid = helpers.uuid.generate();
	// added by BRJOU - open not called any more
	this.newActiveRequest(new CvgReply(this, CONNECT_ACTION), {
		"reqNum": 0
	});
	this.connecting = false;
	this.context = context;
	this.adxtype = 25; // classic page  by default

}, CvgObserver, {
	disconnectClient: function(_, params, reason, tracker) {
		var pendingNode;
		this.stopRecord();
		try {

			// set askkill at true  to perform when it's possible the deconnection and manage all auto reply message
			this.askKill = true;
			tracerStd.info && tracerStd.info("Deconnect Convergence client - isAlive" + this.isAlive() + "\n\tReason[" + (reason || "none") + "]\n\tAsk X3 server to close");
			if (this.isAlive()) {
				if (this.clientConfig.modePLAY) {
					this.closeSocket();
				} else {
					// create a request for deconnection
					var self = this;
					this.logSession(_, "INFO", "ask Kill CvgClient   uuid=[" + self.uuid + "] reasons=" + reason + " panic=" + (params.panic ? params.panic : false));
					var diag = CvgDiagnose.create(this, null, 500, "a request is already processing", null, "syracuse server", null, "KILL", true);
					diag.statusCode = 500;
					this.funnelAction(_, function(_) {
						var node = {};
						var loopDetection = 10;

						function isLoopState(listNodes) {
							return Object.keys(listNodes).reduce(function(prev, cur, idx, arr) {
								return prev || listNodes[cur] >= loopDetection;
							}, false);
						}

						while (self.activeRequest && self.activeRequest.workingCtx.pendingBlockingNode && !isLoopState(node)) {
							var nodeName = self.activeRequest.workingCtx.pendingBlockingNode.id;
							self.logSession(_, "FINE", "action for blocking node  " + nodeName);
							node[nodeName] = node[nodeName] || 0;

							// Some protocole nodes (like SELIMP, NDGTDT, ND_ASKUI, etc...) could open special windows, outside standard windows stack/interaction. Then it's necessary to release
							// properly these windows, before to close a session, sending proper action expected by runtime for these nodes. Note : just one blocking node by request!
							pendingNode = self.activeRequest.workingCtx.pendingBlockingNode;
							// Response is not used
							// var resp = this[pendingNode.proxy](_, {
							delete self.activeRequest.workingCtx.pendingBlockingNode;

							self[pendingNode.proxy](_, {
								act: pendingNode.act,
								fld: pendingNode.fld || {
									notModified: true
								},
								param: pendingNode.param
							});
							node[nodeName]++;
						}
						if (isLoopState(node)) {
							self.logSession(_, "INFO", "detect loop on ending node ");
						}
						self.logSession(_, "FINE", "process close");
						self.processAsyncAction(_, {
							act: 1075,
							fld: {},
							param: {},
							tech: {}
						});
					});
				}
			}
		} catch (e) {
			this.logSession(_, "INFO", "disconnect CvgClient failed " + e.stack);
		} finally {
			// stop tracker and write response  if async request

			this.activeRequest = null;
			this.logSession(_, "INFO", "disconnect CvgClient uuid=[" + this.uuid + "] completed ");
		}
	},
	logSession: function(_, level, message) {
		if (localConfig.logSession && localConfig.logSession.level === level || level === "INFO") {
			console.log((new Date()).toString() + " : " + level + " : " + message);
		}
	},

	stopRecord: function() {
		if (this.recorder) {
			this.recorder.close();
		}
		this.recorder = null;
	},
	closeClient: function(_, e, reason) {
		tracerStd.info && tracerStd.info("CloseClient Convergence Client\n\tReason[" + reason + "]\n\tAlreadyClosed[" + !(this.connClient && this.connClient.hasSocket()) + "] - Exception[" + mesg + "]");
		this.stopRecord();
		this.closeSocket();

	},
	closeSocket: function() {
		if (this.isAlive()) {
			this.stream.end();
			this.stream = null;
			return true;
		}
		return false;
	},
	// TODO move common method between pool client and classic page client
	newActiveRequest: function(reply, sendContext, modeMerge, noResp) {
		if (!modeMerge) {
			this.razModification();
		}
		if (!noResp) {
			this.timing = {};
		}
		this.activeRequest = this.newRequest(reply, sendContext);
		this.isProcessingRequest = true; // request is in progress
		return this.activeRequest;
	},
	toString: function(aSeparator) {
		return "";
	},
	razModification: function() {
		this.callUiOpenFile = null;
		this._trackLists = this.newTrackLists(); // should be inside request???
	},
	newRequest: function(reply, sendContext) {
		return new CvgRequestAbs(this, reply, sendContext);
	},

	getEntityIstResu: function(ist, body) {
		return null;
	},

	// connect=true -> connectAction -> new client or openFunc on reuse client -> send settings to client
	// !! Reuse - some settings are received at the first connection (new client) and must be stored in order to be sent to reused client
	processAsyncAction: function(_, body, connect, mergeMode, noResp) {
		function _actionParams(body) {
			// params passed to listenSendingArgs are [action, ist (or null ist), params added by append2ActionParams]
			var params = [body.act];
			if (!body.param) {
				return params;
			}
			var target = body.param.target;
			if (target && target.xid != null) {
				params.push(CvgIst.fromTarget(target));
			}
			if (body.param.std) {
				params = params.concat(body.param.std);
			}

			return params;
		}

		var self = this;
		var timing = perfmonEnabled && perfmon.start(module, 'cvgClient.processAction', body.act);
		try {
			var pendingNode;
			tracerAction.info && tracerAction.info("************************************");
			tracerAction.info && tracerAction.info("Begin Process Action:\n" + JSON.stringify(body, null, 2));
			if (self.recorder) {
				self.recorder.dumpAction(_, body.act, false);
			}
			// Create fresh request/reply objects
			var reply = new CvgReply(self, body.act);
			var target = body.param && body.param.target;
			if (target && target.xid != null) {
				self.ctxNDSLB = CvgIst.fromTarget(target);
			} else {
				target = null;
			}
			// get action params (action is recorded into params[0])
			var params = _actionParams(body);
			// cleanup blocking node...
			if (params) {
				pendingNode = self.activeRequest.workingCtx.pendingBlockingNode;
				if (pendingNode && pendingNode.act === params[0]) {
					delete self.activeRequest.workingCtx.pendingBlockingNode;
				}
			}

			self.newActiveRequest(reply, {
				"ctxNDSLB": self.ctxNDSLB,
				"reqNum": body.tech && body.tech.id ? body.tech.id : 0,
				"target": target,
				"connect": connect
			}, mergeMode, noResp);

			var resu, extras = [];
			if (body.fld) {
				if (body.fld.v != null) {
					var entity = null;
					if (body.fld.ist) {
						// Retrieve the instance to obtain the data type of the action's resu
						var ist = CvgIst.fromAction(body.fld.ist);
						tracerAction.info && tracerAction.info("ACTION IST=" + JSON.stringify(ist, null, 2));
						// check value
						resu = this.getEntityIstResu(ist, body);
					}
					if (!body.fld.ist || !resu) {
						var type = typeof body.fld.v === 'string' ? CvgResuTdo.STRU : CvgResuTdo.INT;
						resu = CvgResu.fromAction(type, body.fld.v);
					}
				}
				// Build the list of extra results to send after the first one
				// For only one optional extra: crsr (cursor position)
				// crsr is serialized directly as an int, not as a resu.
				// The EXTRA is added only on first action when it's a super action (!mergeMode)
				var crsr = body.fld.ctx && body.fld.ctx.crsr;
				if (!mergeMode && crsr != null) {
					extras.push(new CvgResu(CvgResuTdo.INT, parseInt(crsr, 10)));
				}
			}
			if (!resu) {
				resu = new CvgResu(CvgResuTdo.NULL, null);
			}
			tracerProtocol.info && tracerProtocol.info("Send true value: " + resu.toString());
			self.activeRequest.listenSendingArgs(body, self, params);
			//this.activeRequest.buildIstDatasOfAction(params[0]);
			// send the action to X3
			x3writer.sendAction(_, self, resu, extras, params);
			//CvgClient.checkFailed
			// run automata to get callbacks from X3 engine and return response

			automata.process(_, self, self.activeRequest, {
				title: "action",
				detail: params[0]
			});

			//var resp = self.getResponse(_, connect);
			if (perfmonEnabled) {
				self.recordTiming(timing, params[0], "processAction");
			}
			tracerAction.info && tracerAction.info("************************************");
			tracerAction.info && tracerAction.info("End Process Action:\n" + JSON.stringify(self.response, null, 2));

			//return resp;
		} catch (e) {
			tracerAction.error && tracerAction.error("processAction error\n" + (e.stack || e));
			self.closeClient(_, e, 102);
			if (e instanceof CvgException) {
				e.diagnose.recovery = "ABORT";
			}
			throw e;
		} finally {
			if (perfmonEnabled) {
				timing.end();
			}

		}
	},
	generateResponse: function(_, connect, isTrack) {
		// abstract do nothin by default
	},
	processAction: function(_, body, connect, mergeMode, noResp) {
		var self = this;

		function exec(_) {
			self.processAsyncAction(_, body, connect, mergeMode, noResp);
		}
		this.funnelAction(_, exec);
	},
});