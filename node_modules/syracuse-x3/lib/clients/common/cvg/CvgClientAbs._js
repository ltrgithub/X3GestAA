"use strict";
var helpers = require('syracuse-core/lib/helpers');
var CvgObserver = require("syracuse-x3/lib/convergence/client/CvgObserver").CvgObserver;
var x3helpers = require('syracuse-x3/lib/helpers');
var flows = require('streamline/lib/util/flows');
var datetime = require("syracuse-core/lib/types/datetime");
var locale = require("syracuse-core/lib/locale");
var props1Serializer = require('syracuse-x3/lib/clients/common/commonComm').props1Serializer;
var CvgClientConfig = require("syracuse-x3/lib/convergence/model/CvgClientConfig").CvgClientConfig;
var CONNECT_ACTION = require('syracuse-x3/lib/convergence/client/CvgAction').CONNECT_ACTION;
var CvgRequestAbs = require("syracuse-x3/lib/clients/common/cvg/CvgRequestAbs").CvgRequestAbs;
var CvgException = require('syracuse-x3/lib/convergence/model/CvgException').CvgException;
var CvgDiagnose = require('syracuse-x3/lib/convergence/model/CvgDiagnose');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var CvgClose = require('syracuse-x3/lib/convergence/model/CvgClose');
var CvgIst = require('syracuse-x3/lib/convergence/types/CvgIst').CvgIst;
var localConfig = x3helpers.config("x3fusion", null, {});
var X3Writer = require("syracuse-x3/lib/convergence/automata/x3writer").X3Writer;
var CvgResu = require('syracuse-x3/lib/convergence/types/CvgResu').CvgResu;
var CvgResuTdo = require('syracuse-x3/lib/convergence/types/CvgResu').TDO;
var tracerStd = require("syracuse-trace/lib/helper").getTracer("classic.std");
var tracerAction = require("syracuse-trace/lib/helper").getTracer("classic.action");
var tracerProtocol = require("syracuse-trace/lib/helper").getTracer("classic.protocol");
var tracerSession = require("syracuse-trace/lib/helper").getTracer("classic.session");
var CvgReply = require('syracuse-x3/lib/convergence/client/CvgReply').CvgReply;
var perfmon = require('syracuse-perfmon');
var X3Automata = require("syracuse-x3/lib/convergence/automata/x3Automata").X3Automata;
var X3Reader = require("syracuse-x3/lib/convergence/automata/x3Reader").X3Reader;
var perfmonEnabled = x3helpers.config("perfmon.activate", localConfig);
var perfConfig = localConfig.perfmon || {};

exports.CvgClientAbs = helpers.defineClass(function(protocolVersion) { // allow to force the protocol to use else we take the last implemented one
	CvgObserver.call(this);
	this.automata = new X3Automata(protocolVersion);
	this.x3writer = new X3Writer(protocolVersion);
}, CvgObserver, {
	init: function(stream, aConfig, recorder, context) {

		this.response = {
			head: {
				statusCode: 200
			},
			body: {}
		};
		// intregration ILOG -  SAM 91439
		this.funnelAction = flows.funnel(1);
		this.cvgWinStubPath = "/../data/";
		this.askKill = false;
		this.lastAckCallSpgmId = [];
		this.isProcessingRequest = false;
		this.timing = {};
		this.srvTrace = null;
		this.baseUrl = context.baseUrl;
		this.recorder = recorder;
		this.creationDate = datetime.now();
		this.stream = stream;
		this.clientConfig = new CvgClientConfig(this, aConfig);
		this.initConfig = aConfig;
		this._trackLists = this.newTrackLists();
		this._sessionSettings = {};
		this._x3SessionSettings = {};
		this.activeRequest = null;

		this.uuid = helpers.uuid.generate();
		// added by BRJOU - open not called any more
		this.newActiveRequest(new CvgReply(this, CONNECT_ACTION), {
			"reqNum": 0
		});
		this.connecting = false;
		this.adxtyp = 25; // classic page  by default
		this.context = context;
		this.x3Reader = new X3Reader(this);
		return this;
	},
	recordTiming: function(timer, action, funcName, result) {
		var t = timer.end(result);
		if (perfConfig.clientRecord) {
			this.timing.action = this.timing.action || {};
			this.timing.action[action] = this.timing.action[action] || {};
			this.timing.action[action][funcName] = this.timing.action[action][funcName] || [];

			this.timing.action[action][funcName].push({
				duration: t && t.duration || 0
			});
		}
	},
	connectStart: function(_, context, tracker) {
		this.connecting = true;

		this.automata.process(_, this, this.activeRequest, {
			title: "action",
			detail: "connect"
		});
		tracerSession.info && tracerSession.info("START CONNECTING OK:\n" + JSON.stringify(this.response, null, 2));

		if (perfmonEnabled) {
			var timing = perfmonEnabled && perfmon.start(module, 'cvgClient.connectStart');
			this.recordTiming(timing, "connect", "connectStart", {
				status: this.response.statusCode
			});
		}
		this.logSession(_, "INFO", "connect Classic Client uuid=[" + this.uuid + "]");

	},
	listenNodeNDDEB: function(_, reader, node) {},
	/**
	 * NDACTOBJ (Adxcpl_displayWin) Affichage d'une fenetre Id=[NDACTOBJ]
	 * x3func=[Adxcpl_displayWin] NbArgs=[2] - ist =[ win=[2] srn=[0] blc=[0]
	 * fld=[0] idx=[0]] - opt=[.x04]
	 */
	listenNodeNDACTOBJ: function(_, reader, node, ist, num) { //nothin
	},
	listenNodeNDCOPMENU: function(_, reader, node, data) {
		//reply.setSplashInfos(data);
	},
	read: function(_, len, withTimeout) {

		var x3TimeRead = this.traceTiming && Date.now();
		var data = this.stream.read(_, len, withTimeout);
		if (x3TimeRead && this.activeRequest) {
			this.activeRequest.rtsTimer.read += Date.now() - x3TimeRead;
		}
		return data;

	},
	write: function(_, data) {
		var x3TimeWrite = this.traceTiming && Date.now();
		this.stream.write(_, data);
		if (x3TimeWrite && this.activeRequest) {
			this.activeRequest.rtsTimer.write += x3TimeWrite - Date.now();
		}
	},

	readNew: function(_, len, withTimeout) {
		return this.stream.read(_, len, withTimeout);
	},
	writeNew: function(_, data) {
		this.stream.write(_, data);
	},
	connectStop: function(_) {
		tracerSession.info && tracerSession.info("STOP CONNECTING OK");
		this.connecting = false;
	},
	listenNodeND_CLT: function(_, reader, node, dummyByte) {
		// 15w_001 - Fiche 36012 - X3Client: Supervision des sockets
		// Si reception du noeud ND_CLT non attendu => not ok fermeture du
		// client depuis le meme thread
		this.closeClient(_, null, this.connecting ? 4 : 3);
	},
	disconnectClient: function(_, params, reason, tracker) {
		var pendingNode;
		this.stopRecord();
		try {

			// set askkill at true  to perform when it's possible the deconnection and manage all auto reply message
			this.askKill = true;
			tracerStd.info && tracerStd.info("Deconnect Convergence client - isAlive" + this.isAlive() + "\n\tReason[" + (reason || "none") + "]\n\tAsk X3 server to close");
			if (this.isAlive()) {
				if (this.clientConfig.modePLAY) {
					this.closeSocket();
				} else {
					// create a request for deconnection
					var self = this;
					this.logSession(_, "INFO", "ask Kill CvgClient   uuid=[" + self.uuid + "] reasons=" + reason + " panic=" + (params && params.panic ? params.panic : false));
					var diag = CvgDiagnose.create(this, null, 500, "a request is already processing", null, "syracuse server", null, "KILL", true);
					diag.statusCode = 500;
					this.funnelAction(_, function(_) {
						var node = {};
						var loopDetection = 10;

						function isLoopState(listNodes) {
							return Object.keys(listNodes).reduce(function(prev, cur, idx, arr) {
								return prev || listNodes[cur] >= loopDetection;
							}, false);
						}

						while (self.activeRequest && self.activeRequest.workingCtx.pendingBlockingNode && !isLoopState(node)) {
							var nodeName = self.activeRequest.workingCtx.pendingBlockingNode.id;
							self.logSession(_, "FINE", "action for blocking node  " + nodeName);
							node[nodeName] = node[nodeName] || 0;

							// Some protocole nodes (like SELIMP, NDGTDT, ND_ASKUI, etc...) could open special windows, outside standard windows stack/interaction. Then it's necessary to release
							// properly these windows, before to close a session, sending proper action expected by runtime for these nodes. Note : just one blocking node by request!
							pendingNode = self.activeRequest.workingCtx.pendingBlockingNode;
							// Response is not used
							// var resp = this[pendingNode.proxy](_, {
							delete self.activeRequest.workingCtx.pendingBlockingNode;

							self[pendingNode.proxy](_, {
								act: pendingNode.act,
								fld: pendingNode.fld || {
									notModified: true
								},
								param: pendingNode.param
							});
							node[nodeName]++;
						}
						if (isLoopState(node)) {
							self.logSession(_, "INFO", "detect loop on ending node ");
						}
						self.logSession(_, "FINE", "process close");
						self.processAsyncAction(_, {
							act: 1075,
							fld: {},
							param: {},
							tech: {}
						});
					});
				}
			}
		} catch (e) {
			this.logSession(_, "INFO", "disconnect CvgClient failed " + e.stack);
		} finally {
			// stop tracker and write response  if async request

			this.activeRequest = null;
			this.logSession(_, "INFO", "disconnect CvgClient uuid=[" + this.uuid + "] completed ");
		}
	},
	logSession: function(_, level, message) {
		if (localConfig.logSession && localConfig.logSession.level === level || level === "INFO") {
			console.error((new Date()).toString() + " : " + level + " : " + message);
		}
	},
	listenNodeNDOMNCO: function(_, reader, node, flag, actId, txt) {
		// nothin
	},

	stopRecord: function() {
		if (this.recorder) {
			this.recorder.close();
		}
		this.recorder = null;
	},
	closeClient: function(_, e, reason) {
		this.stopRecord();
		var mesg = "None";
		if (e) {
			mesg = e.message || e;
		}
		tracerStd.info && tracerStd.info("CloseClient Convergence Client\n\tReason[" + reason + "]\n\tAlreadyClosed[" + !(this.connClient && this.connClient.hasSocket()) + "] - Exception[" + mesg + "]");
		CvgClose.create(this, reason, e, "");

		this.closeSocket();

	},
	isAlive: function() {
		return this.stream != null && !this.stream.closed;
	},
	closeSocket: function() {
		if (this.isAlive()) {
			this.stream.end();
			console.log("is alive " + this.stream != null);

			this.stream = null;
			return true;
		}
		return false;
	},
	// TODO move common method between pool client and classic page client
	newActiveRequest: function(reply, sendContext, modeMerge, noResp) {
		if (!modeMerge) {
			this.razModification();
		}
		if (!noResp) {
			this.timing = {};
		}
		this.activeRequest = this.newRequest(reply, sendContext);
		this.isProcessingRequest = true; // request is in progress
		return this.activeRequest;
	},
	toString: function(aSeparator) {
		return "";
	},
	razModification: function() {
		this.callUiOpenFile = null;
		this._trackLists = this.newTrackLists(); // should be inside request???
	},
	newRequest: function(reply, sendContext) {
		return new CvgRequestAbs(this, reply, sendContext);
	},

	getEntityIstResu: function(ist, body) {
		return null;
	},

	serialize: function(_, props) {
		return props1Serializer.write(_, this, props || {});
	},

	// Connection messages
	listenNodeND_SLF: function(_, reader, node, properties) {
		//console.log("ND_SLF properties: "+JSON.stringify(properties,null,2));
		var result = this.execCallUi(_, properties);
		if (result && result.reply) { // auto reply
			this.serialize(_, result.pValues);
			return true; // write done
		} // else it's a client action that contruct the reply - plugin CR case
	},
	execAckCall: function(_, subprogName, debugInfo, params) {

		var body = {
			act: 1077,
			fld: {
				ist: {
					win: "A",
					xid: "@@0"
				}
			},
			param: {
				target: {
					"win": "A",
					"xid": "@@0"
				},
				std: [{
					json: {
						"spgm": subprogName,
						"params": params
					}
				}]
			}
		};

		this.processAction(_, body, false);
		// TODO : Don't do parse(stringify)
		var rpc = this._trackLists.RPC[0];
		return rpc ? JSON.parse(JSON.stringify(rpc)) : null;
	},
	execCallUi: function(_, values) {
		var props;
		switch (values.UIAction) {
			case "SessionSettings":
				var _settings = this.executeAllSessionSettings(values);
				// folder is historical folder
				if (!this.parentFolder && this._x3SessionSettings.ADXMaskAppName) {
					this.setParentFolder(_, this._x3SessionSettings.ADXMaskAppName);
				}
				props = _settings;
				break;
			case "SetWindFeatures":
				props = this.executeAllSessionSettings(values);
				break;
			case "SetTechnoVers":
				props = this.executeCallUiSetTechnovers(values);
				break;
			default:
				return null;

		}
		return {
			reply: true,
			pValues: props
		};
	},
	setParentFolder: function(_, parentFolderName) {
		this.parentFolder = parentFolderName;
		var httpSession = this.context.httpSession;
		this.syraid = httpSession.id;
		var db = adminHelper.getCollaborationOrm(_);
		var entity = db.getEntity(_, "endPoint");

		var ep = db.fetchInstance(_, entity, {
			sdataWhere: "$uuid eq '" + this.clientConfig._params.endpointUuid + "'"
		});

		if (ep.x3ParentFolder(_) !== parentFolderName) {
			ep.x3ParentFolder(_, parentFolderName);
			ep.save(_);
		}

		var x3solution = ep.x3solution(_);
		var userProfile = httpSession.getUserProfile(_);
		this.clientConfig._params.x3User = userProfile && userProfile.user(_) && userProfile.user(_).getEndpointLogin(_, ep.$uuid);
		this.clientConfig._params.x3Lang = locale.current;
		this.clientConfig._params.x3HttpPub = ep.getWebServerBaseUrl(_);
		this.clientConfig._params.x3Folder = parentFolderName;
		this.clientConfig._params.x3Solution = ep.getSolutionName(_);
		this.clientConfig._params.appHost = x3solution.serverHost(_);

	},
	executeAllSessionSettings: function(values) {
		var i, keys = Object.keys(values);
		for (i = 1; i < keys.length; i++) {
			this._x3SessionSettings[keys[i]] = values[keys[i]];
		}

		// Set formater datePivot
		if (values.DefaultDatePivot != null) {
			this.clientConfig.setDatePivot(this._x3SessionSettings.DefaultDatePivot);
		}
		return {
			UIAction: "SessionSettings"
		};
	},
	processND_GFD: function(_, reader, node, properties) {
		// console.log("ND_GFD properties: "+JSON.stringify(properties,null,2));
		var key = properties[0];
		var result = {};
		result[key] = this.clientConfig.getParam(key);
		if (result[key] === undefined) {
			//console.error("Unsupported param: "+key);
			result[key] = "unsupported";
		}
		return result;
	},
	listenNodeND_GFD: function(_, reader, node, properties) {
		// console.log("ND_GFD properties: "+JSON.stringify(properties,null,2));
		var result = this.processND_GFD(_, reader, node, properties);

		return props1Serializer.build(result, true);
	},
	setUserProfile: function(profil) {
		if (this._x3SessionSettings.usrProfile !== profil) {
			this._x3SessionSettings.usrProfile = profil;
		}
	},
	/**
	 * NDACTOP 0E4000 (Activation_Action) Activation d=[NDACTOP] level=[?]
	 * x3func=[Activation_Action] nb=[2] - ide=[2823] ID Action - typ=[.x01]
	 * Status
	 */
	listenNodeNDACTOP: function(_, reader, node, actId, flag) {},
	/**
	 * Le serveur envoi 3 noeuds ndctsu pour decrire un format dynamique. voir
	 * l'innerclasse "CDynFormat" Id=[NDCTSU] level=[C]
	 * x3func=[Control_DefineType] NbArgs=[3] - opt=[.x65] - su1 =[c] - su2 =[_]
	 */
	listenNodeNDCTSU: function(_, reader, node, type, subType, compl) {

	},
	executeCallUiSetTechnovers: function(values) {
		// TODO manage protocol negociation
		this.executeAllSessionSettings(values);
		return values;
	},
	// connect=true -> connectAction -> new client or openFunc on reuse client -> send settings to client
	// !! Reuse - some settings are received at the first connection (new client) and must be stored in order to be sent to reused client
	processAsyncAction: function(_, body, connect, mergeMode, noResp) {
		function _actionParams(body) {
			// params passed to listenSendingArgs are [action, ist (or null ist), params added by append2ActionParams]
			var params = [body.act];
			if (!body.param) {
				return params;
			}
			var target = body.param.target;
			if (target && target.xid != null) {
				params.push(CvgIst.fromTarget(target));
			}
			if (body.param.std) {
				params = params.concat(body.param.std);
			}

			return params;
		}

		var self = this;
		var timing = perfmonEnabled && perfmon.start(module, 'cvgClient.processAction', body.act);
		try {
			var pendingNode;
			tracerAction.info && tracerAction.info("************************************");
			tracerAction.info && tracerAction.info("Begin Process Action:\n" + JSON.stringify(body, null, 2));
			if (self.recorder) {
				self.recorder.dumpAction(_, body.act, false);
			}
			// Create fresh request/reply objects
			var reply = new CvgReply(self, body.act);
			var target = body.param && body.param.target;
			if (target && target.xid != null) {
				self.ctxNDSLB = CvgIst.fromTarget(target);
			} else {
				target = null;
			}
			// get action params (action is recorded into params[0])
			var params = _actionParams(body);
			// cleanup blocking node...
			if (params) {
				pendingNode = self.activeRequest.workingCtx.pendingBlockingNode;
				if (pendingNode && pendingNode.act === params[0]) {
					delete self.activeRequest.workingCtx.pendingBlockingNode;
				}
			}

			self.newActiveRequest(reply, {
				"ctxNDSLB": self.ctxNDSLB,
				"reqNum": body.tech && body.tech.id ? body.tech.id : 0,
				"target": target,
				"connect": connect
			}, mergeMode, noResp);

			var resu, extras = [];
			if (body.fld) {
				if (body.fld.v != null) {
					var entity = null;
					if (body.fld.ist) {
						// Retrieve the instance to obtain the data type of the action's resu
						var ist = CvgIst.fromAction(body.fld.ist);
						tracerAction.info && tracerAction.info("ACTION IST=" + JSON.stringify(ist, null, 2));
						// check value
						resu = this.getEntityIstResu(ist, body);
					}
					if (!body.fld.ist || !resu) {
						var type = (typeof body.fld.v === 'string' ? CvgResuTdo.STRU : CvgResuTdo.INT);
						resu = CvgResu.fromAction(type, body.fld.v);
					}
				}
				// Build the list of extra results to send after the first one
				// For only one optional extra: crsr (cursor position)
				// crsr is serialized directly as an int, not as a resu.
				// The EXTRA is added only on first action when it's a super action (!mergeMode)
				var crsr = body.fld.ctx && body.fld.ctx.crsr;
				if (!mergeMode && crsr != null) {
					extras.push(new CvgResu(CvgResuTdo.INT, parseInt(crsr, 10)));
				}
			}
			if (!resu) {
				resu = new CvgResu(CvgResuTdo.NULL, null);
			}
			tracerProtocol.info && tracerProtocol.info("Send true value: " + resu.toString());
			// call listenSendingArgs depending of the action
			var p = body.act && this.x3writer.descriptors.Descriptors[body.act] && this.x3writer.descriptors.Descriptors[body.act].listenHandler && this.x3writer.descriptors.Descriptors[body.act].listenHandler(_, {
				body: body,
				client: self,
				params: params,
				name: this.x3writer.descriptors.Descriptors[body.act].name
			});

			//self.activeRequest.listenSendingArgs(body, self, params);
			//this.activeRequest.buildIstDatasOfAction(params[0]);
			// send the action to X3
			p = p ? p : params;
			this.x3writer.sendAction(_, self, resu, extras, p);
			//CvgClient.checkFailed
			// run automata to get callbacks from X3 engine and return response

			this.automata.process(_, self, self.activeRequest, {
				title: "action",
				detail: p[0]
			});

			//var resp = self.getResponse(_, connect);
			if (perfmonEnabled) {
				self.recordTiming(timing, p[0], "processAction");
			}
			tracerAction.info && tracerAction.info("************************************");
			tracerAction.info && tracerAction.info("End Process Action:\n" + JSON.stringify(self.response, null, 2));

			//return resp;
		} catch (e) {
			tracerAction.error && tracerAction.error("processAction error\n" + (e.stack || e));
			self.closeClient(_, e, 102);
			if (e instanceof CvgException) {
				e.diagnose.recovery = "ABORT";
			}
			throw e;
		} finally {
			if (perfmonEnabled) {
				timing.end();
			}

		}
	},
	generateResponse: function(_, connect, isTrack) {
		// abstract do nothin by default
	},
	processAction: function(_, body, connect, mergeMode, noResp) {
		var self = this;

		function exec(_) {
			self.processAsyncAction(_, body, connect, mergeMode, noResp);
		}
		this.funnelAction(_, exec);
	},
});