"use strict";
var helpers = require('syracuse-core/lib/helpers');
var locale = require("syracuse-core/lib/locale");
var flows = require('streamline-runtime').flows;
var jsxml = require('js-xml');
var x3writer = require("syracuse-x3/lib/convergence/automata/x3writer");
var CvgModifier = require('syracuse-x3/lib/convergence/model/CvgModifier').CvgModifier;
var CvgDataSrc = require('syracuse-x3/lib/convergence/model/CvgDataSrc').CvgDataSrc;
var CvgEntity = require('syracuse-x3/lib/convergence/model/CvgEntity').CvgEntity;
var CvgAction = require('syracuse-x3/lib/convergence/client/CvgAction').Actions;
var CvgFormat = require('syracuse-x3/lib/convergence/model/CvgFormat').CvgFormat;
var CvgResu = require('syracuse-x3/lib/convergence/types/CvgResu').CvgResu;
var CvgResuTdo = require('syracuse-x3/lib/convergence/types/CvgResu').TDO;
var CvgResuTag = require('syracuse-x3/lib/convergence/types/CvgResu').TAG;
var CvgIst = require('syracuse-x3/lib/convergence/types/CvgIst').CvgIst;
var CvgLeftListLineNode = require('syracuse-x3/lib/convergence/model/CvgLeftListLineNode').CvgLeftListLineNode;
var CvgException = require('syracuse-x3/lib/convergence/model/CvgException').CvgException;
var CvgWindow = require('syracuse-x3/lib/convergence/model/CvgWindow').CvgWindow;
var CvgMessage = require('syracuse-x3/lib/convergence/model/CvgMessage').CvgMessage;
var CvgVariableCombo = require('syracuse-x3/lib/convergence/model/CvgVariableCombo').CvgVariableCombo;
var CvgPickedLine = require('syracuse-x3/lib/convergence/model/CvgPickedLine').CvgPickedLine;
var CvgReplyAckCall = require('syracuse-x3/lib/convergence/model/CvgReplyAckCall');

var CvgInstanceExeci = require('syracuse-x3/lib/convergence/model/CvgInstanceExeci');
var CvgDiagnose = require('syracuse-x3/lib/convergence/model/CvgDiagnose');
var CvgSessionOpen = require('syracuse-x3/lib/convergence/model/CvgSessionOpen');
var CvgAskUiAction = require('syracuse-x3/lib/convergence/model/CvgAskUiAction');
var CvgReboot = require('syracuse-x3/lib/convergence/model/CvgReboot');
var PrintClient = require('syracuse-x3/lib/clients/print/PrintClient');
var PrintHelpers = require('syracuse-x3/lib/clients/print/PrintHelpers');
var CvgReport = require('syracuse-x3/lib/convergence/model/CvgReport');
var CvgImp = require('syracuse-x3/lib/convergence/model/CvgImp');


var CvgHelp = require('syracuse-x3/lib/convergence/model/CvgHelp').CvgHelp;
var x3helpers = require('syracuse-x3/lib/helpers');
var perfmon = require('syracuse-perfmon');

var localConfig = x3helpers.config("x3fusion", null, {});
var tracerStd = require("syracuse-trace/lib/helper").getTracer("classic.std");

var perfmonEnabled = x3helpers.config("perfmon.activate", localConfig);

var MSG_INFORMATION = 0;
var MSG_WARNING = 1; // Boite d'Avertissement
var MSG_QUESTION = 2; // Boite de Question
var MSG_ERROR = 3;
var MSG_STOP = 4; // Boite Abort
var OU_BAV = 11; /* Boite d'Avertissement */
var OU_BEN = 15; /* Boite end : Abort ! */
var OU_BER = 10; /* Boite d'Erreur */
var OU_BIF = 14; /* Boite d'Information */
var OU_BQU = 12; /* Boite de Question */
var OU_BSE = 13; /* Boite de Selection */

function _postDiag(req, msg, detail) {
	CvgDiagnose.create(req.client, 'WARNING', 99, msg, detail, null, "Protocol", null, true);
}

exports.CvgRequestAbs = helpers.defineClass(function(aClient, aAdonixReply, sendContext) {
	this.client = aClient;
	this.reply = aAdonixReply; // added by BRJOU
	this.nbNodeOpenTempon = 0;
	this.lefListLineSelected = -1;
	this.sendContext = sendContext;
	this.ndofld = 0;
	this.help = null;
	this.workingCtx = {};

}, null, {
	listenNodeNDOMNBO: function(_, reader, node, idm, rnk, ide, flg, actId, txt, acc) {},

	/**
	 * NDCTIT 0E3300 (Adxcpl_setLabel) Mise a jour label d'un objet modelise
	 * Id=[NDCTIT] level=[?] x3func=[Adxcpl_setLabel] nb=[2] ist=[ win=[2]
	 * srn=[0] blc=[0] fld=[0] idx=[0] ] txt =[Utilisateurs]
	 */
	listenNodeNDCTIT: function(_, reader, node, ist, ttl) {},

	buildListenNodeMessage: function(aKeyMess, aValue1, aValue2, aModifier) {
		var msg = aValue2 ? this.client.getMessage(aKeyMess, aValue1, aValue2) : this.client.getMessage(aKeyMess, aValue1);
		if (aModifier.hasLogicalErrMess()) {
			msg = msg + "\n\t" + aModifier.logicalErrMess;
		}
		return msg;
	},


	/* from CAdonixRequest */
	listenNodeNDGIST: function(_, reader, node, ist) {
		// TODO handle the instnace received
		//this.reply.setTargetAdxId(ist, this);
	},



	listenNodeND_INT: function(_, reader, node) {
		// TODO: translate message
		_postDiag(this, "ND_INT node not supported", "ND_INT");
		// 0 means continue 4GL process | 1 means interrupt
		return 0;
	},

	listenNodeNDSYSTEM: function(_, reader, node) {
		// TODO: translate message
		_postDiag(this, "NDSYSTEM node not supported", "NDSYSTEM");
		return [0];
	},


	/**
	 * ND_DCL 0E2400 (LeftList_NewRequete) Debut de chargement liste simple ou
	 * arbre Id=[ND_DCL] func=[LeftList_NewRequete] NbArgs=[1] ist =[ win=[2]
	 * srn=[34] blc=[1] fld=[0] idx=[0]]
	 */
	listenNodeND_DCL: function(_, reader, node) {},

	/**
	 * ND_FCL 0E2500 (LeftList_CloseReq) Fin de chargement liste simple ou arbre
	 * Id=[ND_FCL] func=[LeftList_CloseReq] NbArgs=[1] ist =[ win=[2] srn=[34]
	 * blc=[1] fld=[0] idx=[0]]
	 */
	listenNodeND_FCL: function(_, reader, node) {},


	listenNodeND_REB: function(_, reader, node, str1, str2, str3, str4, str5, str6, str7, str8, str9, str10, str11, str12, str13, str14, str15, str16, str17) {
		// Notify observer
		CvgReboot.create(this.client, str1, str2, str3, str4, str5, str6, str7, str8, str9, str10, str11, str12, str13, str14, str15, str16, str17);
		if (this.client) {
			this.client.closeSocket();
		}
	},


	listenNodeNDEXECI: function(_, reader, node, ist, spgm, dbgflg, paramDefs, paramVal) {
		var self = this;

		// there is a potential large recursion here, for example when X3 calls a web service in a loop.
		// so we need to force a stack unwind with flows.trampoline.
		flows.trampoline(_, function(_) {
			try {
				var serverUrl = reader.ctx && reader.ctx._cvgSession && reader.ctx._cvgSession.sessInfo && reader.ctx._cvgSession.sessInfo.serverUrl;
				if (!serverUrl) {
					serverUrl = self.client && self.client._cvgSession && self.client._cvgSession.sessInfo && self.client._cvgSession.sessInfo.serverUrl;
				}
				if (spgm === "XDT_ILOG:UPLOAD") {
					// add to plugin and create it if not exists the upload ask - first param blob, second filename
					var plugin = self.client.getILogPlugin();
					plugin.addUpload(_, paramVal[0]);
					self.client.orchestraTracker = plugin;

				} else {
					CvgInstanceExeci.create(_, ist, spgm, dbgflg, paramDefs[0], paramVal[0], self.client, serverUrl);
				}
			} finally {

				self.workingCtx.pendingBlockingNode = {
					"proxy": "processAsyncAction",
					"id": "NDEXECI",
					"act": 1081,
					fld: {
						ist: ist
					},
					"param": {
						target: {
							type: "ist",
							ist: ist
						},
						reply: {
							json: {
								result: {
									errp: "CvgRequest._js",
									errm: "can't execute / panic kill",
									errl: 1,
									errn: 1,
									errt: 1
								},
								debugInfos: {
									exceptiondetail: "",
									totalduration: 0,
									execduration: 0,
									trace: ""
								},
								"return": {
									typ: "NULL",
									val: 0
								},
								params: []
							}
						}
					}
				};
			}
		});
	},

	listenNodeNDOMENA: function(_, reader, node, profil) {
		// si le profil change => on le met dans le reply
		this.client.setUserProfile(profil);
	},
	listenSendingArgs: function(body, aCommClient, aParams) {
		var timing = perfmonEnabled && perfmon.start(module, "cvgRequestAbs.listenSendingArgs");
		var res = false;
		switch (body.act) {
			case CvgAction.SRV_EXECI_RESPONSE:
				if (body.param.reply && (body.param.reply.json || body.param.reply.xml)) {
					this.listenSendingArgsAckResi(this, aParams, body.fld.ist, body.param.reply);
				} else {
					_postDiag(this, "SRV_EXECI_RESPONSE - Can't perform remote call", "Json or Xml description missing");
				}
				res = true;
				break;
			case CvgAction.SRV_CALLREMOTEFUNC:
			case CvgAction.SRV_CALLREMOTESPGM:
				this.listenSendingArgsAckCall(this, aParams);
				res = true;
				break;
			default:
				break;
		}
		if (perfmonEnabled) {
			timing.end();
		}
		return res;
	},

	listenSendingArgsAckResi: function(aCommClient, aParams, ist, rpc) {
		// Remove all params except action id
		aParams.splice(1, aParams.length - 1);
		// Instanciate IST and push it in params
		ist = CvgIst.fromTarget(ist);
		aParams.push(ist); // instance
		if (rpc.xml) {
			jsxml.parse(rpc.xml);
		}
		// push errn,l,p,t,m
		// add all status of execution
		aParams.push(rpc.json.result.errn);
		aParams.push(rpc.json.result.errl);
		aParams.push(rpc.json.result.errp);
		aParams.push(rpc.json.result.errt);
		aParams.push(rpc.json.result.errm);
		// push return 
		var returnVal = rpc.xml ? jsxml.parse(rpc.xml) : rpc.json.return;
		var returnResu = CvgResu.fromAction(CvgResuTdo[returnVal.typ], returnVal.resu);
		aParams.push(returnResu);
		// push params
		if (rpc.json.params) {
			var params = rpc.json.params;
			var i, item, listParams = [];
			for (i = 0; i < params.length; i++) {
				// set the resu 
				item = params[i];
				item.resu = CvgResu.fromAction(CvgResuTdo[item.typ], item.resu);
				listParams.push(item);
			}

			aParams.push(listParams);
		} else {
			aParams.push([]);
		}
		// push table of resu debug info
		var debugInfos = [];
		if (rpc.json.debugInfos && rpc.json.debugInfos.exceptiondetail) {
			debugInfos.push(new CvgResu(CvgResuTdo.CLOB, rpc.json.debugInfos.exceptiondetail));
		} else {
			debugInfos.push(new CvgResu(CvgResuTdo.NULL, null));
		}
		if (rpc.json.debugInfos && rpc.json.debugInfos.totalduration) {
			debugInfos.push(new CvgResu(CvgResuTdo.DCB, rpc.json.debugInfos.totalduration));
		} else {
			debugInfos.push(new CvgResu(CvgResuTdo.NULL, null));
		}
		if (rpc.json.debugInfos && rpc.json.debugInfos.execduration) {
			debugInfos.push(new CvgResu(CvgResuTdo.DCB, rpc.json.debugInfos.execduration));
		} else {
			debugInfos.push(new CvgResu(CvgResuTdo.NULL, null));
		}
		if (rpc.json.debugInfos && rpc.json.debugInfos.trace) {
			debugInfos.push(new CvgResu(CvgResuTdo.CLOB, rpc.json.debugInfos.trace));
		} else {
			debugInfos.push(new CvgResu(CvgResuTdo.NULL, null));
		}
		aParams.push(debugInfos);
	},

	listenSendingArgsAckCall: function(aCommClient, aParams) {
		var call = aParams && aParams.length > 2 ? aParams[2] : null,
			ist = aParams && aParams.length > 1 ? aParams[1] : null;
		// Check params
		if (!ist || !call || (!call.json && !call.xml)) {
			_postDiag(this, "SRV_CALLREMOTESPGM - Can't perform remote call", "Json or Xml description missing");
			return;
		}
		// Remove all params except action id
		aParams.splice(1, aParams.length - 1);
		// Instanciate IST and push it in params
		ist = CvgIst.fromTarget(ist);
		aParams.push(ist);
		//		console.log("XML:\n"+call.xml);
		//		console.log("JSON:\n"+JSON.stringify(call.json,null,2));
		var callParams = call.xml ? jsxml.parse(call.xml) : call.json;
		// name of subprog
		var spgmId = call.xml ? callParams.spgm.$.id : callParams.spgm;

		//save last ack_call send to x3 to identify if the nd_result receive has to be deliver to the client or not
		this.client.lastAckCallSpgmId.push(spgmId);
		// push name of su.program
		aParams.push(spgmId);
		// debug flag
		var debugFlags = call.xml ? callParams.spgm.$ : callParams.debugFlags;
		var flag = debugFlags ? (parseInt(debugFlags.trace, 10) << 3 | parseInt(debugFlags.execduration, 10) << 2 | parseInt(debugFlags.totalduration, 10) << 1 | parseInt(debugFlags.exceptiondetail, 10)) : 0;
		aParams.push(flag);
		var defs = []; // must be integer
		var values = []; // must be resu
		var paramDefs = call.xml ? callParams.spgm.param : callParams.params;
		var i, j, listResu, attributes, x3typ, v;
		for (i = 0; i < paramDefs.length; i++) {
			listResu = paramDefs[i].resu;
			attributes = call.xml ? paramDefs[i].$ : paramDefs[i];
			x3typ = CvgResuTag[attributes.typ];
			// add defs param i
			defs.push(parseInt(attributes.dim, 10)); //DIM
			defs.push(parseInt(attributes.nb, 10)); //NbVal
			defs.push(parseInt(attributes.size, 10)); //Size
			defs.push(x3typ + 256); //x3type
			//add value
			if (listResu) {
				if (Array.isArray(listResu)) {
					for (j = 0; j < listResu.length; j++) {
						v = typeof listResu[j] === 'object' ? (call.xml ? listResu[j].$cdata : listResu[j]) : listResu[j];
						values.push(new CvgResu.fromX3Type(x3typ, v));
					}
				} else {
					v = typeof listResu === 'object' ? (call.xml ? listResu.$cdata : listResu) : listResu;
					values.push(new CvgResu.fromX3Type(x3typ, v));
				}
			}
		}
		// tab def
		aParams.push(defs);
		// tab value
		aParams.push(values);
	},




	// "ist" "l'instance du niveau zero // Ne sert a rien !!!"
	// "errn (short)" "la variable errn valorisée par le moteur " "errn"
	// "errl (short)" "contient la variable errl valorisée par le moteur" "errl"
	// "errp (string)" "id du traitement dans la variable errp valorisée par le moteur"
	// "errt (car)" "contient  la variable errtyp valorisée par le moteur"
	// "errm (string)" "contient  la variable errm valorisée par moteur" "mess"
	listenNodeNDRESULT: function(_, reader, node, ist, errn, errl, errp, errt, errm, resu, tblParams, tblResus) {
		// Instantiate CvgReplyAckCall and store it in client.trackList.RPC
		if (errn !== 0 && this.sendContext.connect) {
			// add diagnosis 
			throw new CvgException(this.client, null, "errt[" + errt + "] errp[" + errp + "] errl[" + errl + "] errn[" + errn + "] errm[" + errm + "]", 'KILL', "4gl runtime");
		}

		CvgReplyAckCall.create(this.client, errn, errl, errp, errt, errm, resu[0], tblParams[0], tblResus[0]);
	},



});