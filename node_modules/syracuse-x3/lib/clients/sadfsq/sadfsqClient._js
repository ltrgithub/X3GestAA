"use strict";
var helpers = require('syracuse-core/lib/helpers');
var locale = require("syracuse-core/lib/locale");
var commonClient = require('syracuse-x3/lib/clients/common/commonClient');
var SadFsqFile = require('syracuse-x3/lib/clients/sadfsq/sadfsqFile').SadFsqFile;
var sadFsqComm = require('syracuse-x3/lib/clients/sadfsq/sadfsqComm');
var SadFsqComm = sadFsqComm.SadFsqComm;
var config = require('syracuse-main/lib/nodeconfig').config;
var tracer = config.x3sadfsq && config.x3sadfsq.client && config.x3sadfsq.client.trace;

exports.Mod = {
	O_RDONLY: 0x0000,
	O_WRONLY: 0x0001,
	O_RDWR: 0x0002,
	O_APPEND: 0x0008,
	O_CREAT: 0x0100,
	O_TRUNC: 0x0200,
	O_EXCL: 0x0400
};

exports.Mask = {
	S_IREAD: 0x0100,
	S_IWRITE: 0x0080,
	S_IEXEC: 0x0040
};

function isCommError(e) {
	return e && e.constructor && e.constructor.name && e.constructor.name === "CommError";
}

exports.SadFsqClient = helpers.defineClass(function(_, hostname, port, user, password, secured, recOptions) {
	var options = {
		clientDescr: "SadFsqClient",
		CommClass: SadFsqComm,
		recOptions: recOptions,
		config: config.x3sadfsq
	};
	commonClient.CommonClient.call(this, _, options, hostname, port, user, password, secured);
	this.fdsOpen = {}; // list of opened fd
}, commonClient.CommonClient, {

	/// !doc
	/// 
	/// # SadFsq Client  
	/// SadFsq is provided by simple wrappers around standard POSIX functions.  
	/// The module is using sadfsq protocol layer implemented in [SadFsqComm](./sadfsqComm.md).  
	/// To use this module do require('syracuse-x3/lib/clients/sadfsq/sadfsqClient').SadFsqClient.  
	/// All the methods are asynchronous.  
	/// ``` javascript
	/// var SadFsqClient = require('syracuse-x3/lib/clients/sadfsq/sadfsqClient').SadFsqClient;
	/// var sadfs = new SadFsqClient(_, "server", "port", "user", "password", secure);
	/// ```
	/// * `server` is the hostname of the adxadmin server.  
	/// * `port` is the port on adxadmin is listenning.  
	/// * `user` is the system user to use for the connection.  
	/// * `password` is the password corresponding to the user.  
	/// * `secure` is boolean that define if the connection is secured by user/password.  
	/// 
	/// 

	/// ## General parameters  
	/// In the following described functions, some general parameters would be necessary. This chapter describes these parameters.  
	/// 
	/// ### File Options :  
	/// Some following functions take in parameters `fileOptions`.  
	/// This chapter describes how these options can be used.  
	/// There are severals ways to create the `fileOptions` object :  
	/// 
	/// * Use an absolute path :  
	/// ``` javascript
	/// var fileOptions = {
	///    path: "c:/temp/test.txt"
	/// }
	/// ```
	/// 
	/// * Use a folder name, a relative path, a file name and an extension :  
	/// ``` javascript
	/// var fileOptions = {
	///    folder: "DEMO",
	///    path: "tmp",
	///    name: "test",
	///    extension: "txt"
	/// }
	/// ```
	/// 
	/// * Use a volume, a relative path, a file name and an extension :  
	/// ``` javascript
	/// var fileOptions = {
	///    volume: "c:/",
	///    path: "tmp",
	///    name: "test",
	///    extension: "txt"
	/// }
	/// ```
	/// 
	/// * Use directly a canonical path :  
	/// ``` javascript
	/// var fileOptions = {
	///    canonical: "@SUPERV.tmp/test$txt"
	/// }
	/// ```
	/// 
	/// * It's possible too to use a `server` property to access to a different server through the same adxadmin server :   
	/// ``` javascript
	/// var fileOptions = {
	///    server: "server2_hostname",
	///    ...,
	///    ...
	/// }
	/// ```
	/// 
	/// -------------
	/// ### Flags :  
	/// Some following functions take in parameters `flags`.  
	/// This chapter describes how these options can be used.  
	/// The flags argument points to a string. If the string is one of the following, the file shall be opened in the indicated mode. Otherwise, the behavior is undefined.  
	/// * `r` or `rb` : Open file for reading.  
	/// * `w` or `wb` : Truncate to zero length or create file for writing.  
	/// * `a` or `ab` : Append; open or create file for writing at end-of-file.  
	/// * `r+` or `rb+` or `r+b` : Open file for update (reading and writing).  
	/// * `w+` or `wb+` or `w+b` : Truncate to zero length or create file for update.  
	/// * `a+` or `ab+` or `a+b` : Append; open or create file for update, writing at end-of-file.  
	/// 
	/// 

	/// ## Functions
	/// 
	/// -------------
	/// ### open :
	/// ``` javascript
	/// var fd = sadfs.open(_, fileOptions, flags);  
	/// ```
	/// Open a remote file corresponding to `fileOptions` and associates a stream with it.  
	/// 
	/// * `fileOptions` is the object that represent the sadFsq File options. See [File Options](./sadfsqClient.md#file-options-).  
	/// * `flags` : a string that represent the open mode for the remote file. See [Flags](./sadfsqClient.md#flags-).  
	/// 
	/// Opening a file with read mode (`r` as the first character in the mode argument) shall fail if the file does not exist or cannot be read.  
	/// 
	/// Opening a file with append mode (`a` as the first character in the mode argument) shall cause all subsequent writes to the file to be forced to the then current end-of-file, regardless of intervening calls to [seek()](./sadfsqClient.md#seek-) function.  
	/// 
	/// When a file is opened with update mode ('+' as the second or third character in the mode argument), both input and output may be performed on the associated stream. However, the application shall ensure that output is not directly followed by input without an intervening call to [flush()](./sadfsqClient.md#flush-) or to a file positioning function as [seek()](./sadfsqClient.md#seek-), and input is not directly followed by output without an intervening call to a file positioning function, unless the input operation encounters end-of-file.  
	/// 
	/// If flags is `w`, `wb`, `a`, `ab`, `w+`, `wb+`, `w+b`, `a+`, `ab+`, or `a+b`, and the file did not previously exist, upon successful completion, [open()](./sadfsqClient.md#open-) shall mark for update the last data access, last data modification, and last file status change timestamps of the file and the last file status change and last data modification timestamps of the parent directory.  
	/// 
	/// If flags is `w`, `wb`, `a`, `ab`, `w+`, `wb+`, `w+b`, `a+`, `ab+`, or `a+b`, and the file did not previously exist, [open()](./sadfsqClient.md#open-) shall create a file.  
	/// 
	/// If flags is `w`, `wb`, `w+`, `wb+`, or `w+b`, and the file did previously exist, upon successful completion, [open()](./sadfsqClient.md#open-) shall mark for update the last data modification and last file status change timestamps of the file.  
	/// 
	/// Upon successful completion, [open()](./sadfsqClient.md#open-) shall return a pointer (file descriptor) to the object controlling the stream. Otherwise, an error shall be thrown by adxadmin runtime.  
	/// 
	open: function(_, options, flags) {
		this.__connect(_);
		var sadFile = new SadFsqFile(options);
		var fd;
		try {
			fd = this.communicator.processOUF(_, sadFile, flags);
		} catch (e) { // first failed , retry to connect and open
			if (isCommError(e)) {
				throw e;
			}
			tracer.info() && tracer.info("failed to open " + e.message + "- retry connect and open");
			this.stream = null;
			this.__connect(_);
			fd = this.communicator.processOUF(_, sadFile, flags);
		}
		this.fdsOpen[fd] = {
			sadFile: sadFile,
			fd: fd,
			offset: 0,
			mode: flags
		};

		return fd;
	},


	// not used today with the runtime
	_openSys: function(_, options, mod, umask) {
		this.__connect(_);
		var sadFile = new SadFsqFile(options);
		var fd;
		try {
			fd = this.communicator.processOUS(_, sadFile, mod, umask);
		} catch (e) {
			if (isCommError(e)) {
				throw e;
			}
			tracer.info() && tracer.info("failed to open " + e.message + "- retry connect and open");
			this.stream = null;
			this.__connect(_);
			fd = this.communicator.processOUS(_, sadFile, mod, umask);
		}
		this.fdsOpen[fd] = {
			sadFile: sadFile,
			fd: fd,
			offset: 0,
		};
		return fd;
	},

	/// 
	/// -------------
	/// ### close :
	/// ``` javascript
	/// sadfs.close(_, fd);  
	/// ```
	/// Close the remote file identified by `fd`.  
	/// 
	/// * `fd` is a file descriptor that identify the opened remote file.  
	/// 
	close: function(_, fd) {
		this.__connect(_);
		var opened = this.fdsOpen[fd];
		if (opened) {
			this.communicator && this.communicator.processFER(_, opened.fd);
			delete this.fdsOpen[fd];
		} else {
			throw new Error(locale.format(module, "fdNotValidClose"));
		}
	},

	/// 
	/// -------------
	/// ### stat :
	/// ``` javascript
	/// var stats = sadfs.stat(_, fileOptions, [attributes]);  
	/// ```
	/// Retrieve informations from remote file.  
	/// 
	/// * `fileOptions` is the object that represent the sadFsq File options. See [File Options](./sadfsqClient.md#file-options-).  
	/// * `attributes` is an array of strings that contains the attributes name.  
	///    `attributes` can have the following values :  
	///    `mode`, `ino`, `dev`, `rdev`, `nlink`, `uid`, `gid`, `size`, `atime`, `mtime`, `ctime`.  
	///    If `attributes` is `null` all properties are returned.  
	///
	/// Returns a javascript object that contains attributes keys and values.  
	/// 
	/// ``` javascript
	///    { 
	///       mode: 33188, // file mode  
	///       ino: 48064969, // inode number  
	///       dev: 0, // id of device containing a directory entry  
	///       rdev: 2114, // id of device if special char/block  
	///       nlink: 1, // number of links  
	///       uid: 85, // uid  
	///       gid: 100, // gid  
	///       size: 527, // file size in bytes  
	///       atime: Mon, 10 Oct 2011 23:24:11 GMT, // last time of access  
	///       mtime: Mon, 10 Oct 2011 23:24:11 GMT, // last time of modification  
	///       ctime: Mon, 10 Oct 2011 23:24:11 GMT // last time of file status change  
	///    }
	/// ``` 
	/// 
	stat: function(_, options, attributes) {
		if (attributes && !Array.isArray(attributes)) throw new Error(locale.format(module, "attMustBeArray"));
		var sadFile = new SadFsqFile(options);
		return this._getInfo(_, sadFile, attributes);
	},

	/// 
	/// -------------
	/// ### fstat :
	/// ``` javascript
	/// var stats = sadfs.fstat(_, fd, [attributes]);  
	/// ```
	/// This function is the same that [stat()](./sadfsqClient.md#stat-) but take a file descriptor as first parameter.  
	/// 
	/// * `fd` is a file descriptor that identify the opened remote file.  
	/// 
	fstat: function(_, fd, attributes) {
		if (attributes && !Array.isArray(attributes)) throw new Error(locale.format(module, "attMustBeArray"));
		var sadFile = this.fdsOpen[fd].sadFile;
		return this._getInfo(_, sadFile, attributes);
	},

	_getInfo: function(_, sadFile, attributes) {
		this.__connect(_);
		var fileInfo = {};
		if (!attributes) {
			attributes = sadFsqComm.fileAttributes.slice(1);
		}
		for (var i = 0; i < attributes.length; i++) {
			fileInfo[attributes[i]] = this.communicator.processPRM(_, sadFile, attributes[i]);

		}
		return fileInfo;
	},

	/// 
	/// -------------
	/// ### path :
	/// ``` javascript
	/// var path = sadfs.path(_, fileOptions);  
	/// ```
	/// Retrieve the full path of the remote file.  
	/// 
	/// * `fileOptions` is the object that represent the sadFsq File options. See [File Options](./sadfsqClient.md#file-options-).  
	/// 
	/// Returns the the full path.  
	///
	path: function(_, options) {
		this.__connect(_);
		var sadFile = new SadFsqFile(options);
		var fullPath;
		try {
			fullPath = this.communicator.processPAT(_, sadFile);
		} catch (e) {
			if (isCommError(e)) {
				throw e;
			}
			this.stream = null;
			tracer.info() && tracer.info("failed to get the path " + e.message + " - retry");
			this.__connect(_);
			fullPath = this.communicator.processPAT(_, sadFile);
		}
		return fullPath;
	},

	/// 
	/// -------------
	/// ### feof :
	/// ``` javascript
	/// sadfs.feof(_, fd);  
	/// ```
	/// Test end-of-file indicator on a stream.  
	/// 
	/// * `fd` is a file descriptor that identify the opened remote file.  
	/// 
	/// Shall returns true if and only if the end-of-file indicator is set for stream.
	/// 
	feof: function(_, fd) {
		this.__connect(_);
		if (this.fdsOpen && this.fdsOpen[fd]) {
			return this.communicator.processTFF(_, this.fdsOpen[fd].fd) !== 0;
		} else {
			throw new Error(locale.format(module, "fdNotValidFEOF"));
		}
	},

	/// 
	/// -------------
	/// ### truncate :
	/// ``` javascript
	/// sadfs.truncate(_, fileOptions, len);  
	/// ```
	/// Truncate the remote file specified by `fileOptions`.  
	/// 
	/// * `fileOptions` is the object that represent the sadFsq File options. See [File Options](./sadfsqClient.md#file-options-).  
	/// * `len` is the number of bytes to truncate.  
	/// 
	truncate: function(_, options, len) {
		this.__connect(_);
		var fd = this.open(_, options, "r+");
		var size = this.fstat(_, fd, ["size"]).size;
		if (size - len > 0) { // we need to keep some data in file
			this.ftruncate(_, fd, len);
			this.close(_, fd);
		} else {
			this.close(_, fd);
			fd = this.open(_, options, "w"); // automatically truncate all data in file
			this.close(_, fd);
		}
	},

	/// 
	/// -------------
	/// ### ftruncate :
	/// ``` javascript
	/// sadfs.ftruncate(_, fd, len);  
	/// ```
	/// Truncate the remote file specified by `fileOptions`.  
	/// 
	/// * `fd` is a file descriptor that identify the opened remote file.  
	/// * `len` is the number of bytes to truncate.  
	/// 
	ftruncate: function(_, fd, len) {
		this.__connect(_);
		if (this.fdsOpen && this.fdsOpen[fd] && this.fdsOpen[fd].mode &&
			this.fdsOpen[fd].mode === "r+") {
			var size = this.fstat(_, fd, ["size"]).size;
			var sadFile = this.fdsOpen[fd].sadFile;
			var mod = this.fdsOpen[fd].mode;
			// read the content and not take the bytes that will be truncated
			var buffer = new Buffer(size - len);
			var readLen = this.read(_, fd, buffer, 0, size - len, len);
			if (readLen === size - len) {
				// close file
				this.close(_, fd);
				// delete remote file
				this.unlink(_, sadFile);
				if (mod === "r+") { // create an empty file
					this.communicator.processFER(_, this.communicator.processOUF(_, sadFile, "w+"));

				}
				// create a new file with truncate content
				this.fdsOpen[fd] = { // reassociate the new remote file with same uuid
					sadFile: sadFile,
					fd: this.communicator.processOUF(_, sadFile, mod),
					offset: 0,
					mode: mod
				};
				//this.fdsOpen[fd].size = this.fstat(_, fd, ["size"]).size;
				// write truncate content
				this.write(_, fd, buffer, 0, buffer.length, 0);
			} else {
				throw new Error(locale.format(module, "truncateSizeErr", readLen, size - len));
			}
		} else {
			throw new Error(locale.format(module, "truncateModeErr"));
		}

	},

	/// 
	/// -------------
	/// ### rename :
	/// ``` javascript
	/// sadfs.rename(_, oldFileOptions, newFileOptions);  
	/// ```
	/// Rename the remote file specified by `oldFileOptions` with the `newFileOptions`.  
	/// 
	/// * `oldFileOptions` is the object that represent the old sadFsq File options to rename. See [File Options](./sadfsqClient.md#file-options-).  
	/// * `newFileOptions` is the object that represent the new sadFsq File options. See [File Options](./sadfsqClient.md#file-options-).  
	/// 
	rename: function(_, oldOptions, newOptions) {
		this.__connect(_);
		var oldSadFile = new SadFsqFile(oldOptions);
		var newSadFile = new SadFsqFile(newOptions);
		try {
			this.communicator.processREN(_, oldSadFile, newSadFile);
		} catch (e) {
			if (isCommError(e)) {
				throw e;
			}
			tracer.info() && tracer.info("failed to rename " + e.message + "  - retry");
			this.stream = null;
			this.__connect(_);
			this.communicator.processREN(_, oldSadFile, newSadFile);
		}

	},

	/// 
	/// -------------
	/// ### getPosition :  
	/// ``` javascript  
	/// var position = sadfs.getPosition(_, fd);  
	/// ```
	/// Get the cursor position in the file specified by `fd`. 
	///
	getPosition: function(_, fd) {
		this.__connect(_);
		var opened = this.fdsOpen[fd];
		if (opened) {
			return this.communicator.processPOS(_, opened.fd);
		} else {
			throw new Error(locale.format(module, "posNotOpened"));
		}
	},

	/// 
	/// -------------
	/// ### seek :  
	/// ``` javascript  
	/// sadfs.seek(_, fd, cursor, offset, [strict]);  
	/// ```
	/// Change the cursor position in the in the stream associated to the file specified by `fd`. 
	/// 
	/// * `cursor` is the base of the move. (0: BOF, 1: Current position, 2: EOF)  
	/// * `offset` is a number of bytes to ignore until the new position.  
	/// * `strict` define if the position is allowed to be out of bounds. `true` by default.  
	///
	seek: function(_, fd, cursor, offset, strict) {
		this.__connect(_);
		var opened = this.fdsOpen[fd];
		if (opened) {
			if (strict == null) strict = true;
			if (strict) {
				var size = this.fstat(_, fd, ["size"]).size;
				switch (cursor) {
					case 0:
						if (offset > size) throw new Error(locale.format(module, "seekOffsetTooBig", offset, size));
						break;
					case 1:
						if (offset + opened.offset > size)
							throw new Error(locale.format(module, "seekOffsetTooBig2"));
						break;
					case 2:
						if (offset > 0) throw new Error(locale.format(module, "seekOffsetPositiveEOF"));
						break;
					default:
						throw new Error(locale.format(module, "seekCursorError"));
				}
			}
			this.communicator.processDPL(_, opened.fd, cursor, offset);
			opened.offset += offset;
		} else {
			throw new Error(locale.format(module, "seekNotOpened"));
		}
	},

	/// 
	/// -------------
	/// ### readFile :  
	/// ``` javascript  
	/// var buf = sadfs.readFile(_, fileOptions, [options]);  
	/// ```
	/// Reads the entire contents of a file.  
	/// 
	/// * `fileOptions` is the object that represent the sadFsq File options. See [File Options](./sadfsqClient.md#file-options-).  
	/// * `options` is the object that represent encoding and flag.  
	///     * encoding : `String | null` default = `null`.  
	///     * flag : `String`default = `r`. See [Flags](./sadfsqClient.md#flags-).  
	///       The rules described in [open()](./sadfsqClient.md#open-) function are also applied here.  
	/// 
	/// ``` javascript
	///    var options = {  
	///         encoding:"utf-8",
	///         flag : "r"
	///    };  
	/// ```
	/// 
	/// If no encoding is specified, then the raw buffer is returned.  
	/// 
	readFile: function(_, fileOptions, options) {
		this.__connect(_);
		var fd = this.open(_, fileOptions, options && options.flag ? options.flag : "r");
		// get full size of the file 
		var size = this.fstat(_, fd, ["size"]).size;
		tracer.info() && tracer.info("file size " + size);
		var buffer = new Buffer(size);
		this.read(_, fd, buffer, 0, size);

		this.close(_, fd);
		if (options && options.encoding) {
			return buffer.toString(options.encoding);
		}
		tracer.info() && tracer.info("buff readed " + buffer.toString("hex"));
		return buffer;
	},

	/// 
	/// -------------
	/// ### read :  
	/// ``` javascript  
	/// var buf = sadfs.read(_, fd, buffer, offset, length, [position]);  
	/// ```
	/// Read data from the file specified by `fd`. 
	///
	/// * `buffer` is the buffer that the data will be written to.  
	/// * `offset` is the offset in the buffer to start writing at.  
	/// * `length` is an integer specifying the number of bytes to read.  
	/// * `position` is an integer specifying where to begin reading from in the file. If position is null, data will be read from the current file position.  
	/// 
	/// Returns the size of red bytes.  
	///
	read: function(_, fd, buffer, offset, length, position) {
		this.__connect(_);
		var fdOpened = this.fdsOpen[fd];

		var lenToRead = length;
		if (lenToRead > 0) {
			if (position != null) {
				this.seek(_, fd, 0, position);
			}
			var buf = this.communicator.processLBF(_, fdOpened.fd, lenToRead);
			buf.copy(buffer, offset);
			fdOpened.offset += buf.length;
			return buf.length; // return size of bytes read
		} else {
			return 0;
		}
	},

	/// 
	/// -------------
	/// ### writeFile :  
	/// ``` javascript  
	/// sadfs.writeFile(_, fileOptions, data, [options]);  
	/// ```
	/// Writes data to the remote file, replacing the file if it already exists.  
	/// 
	/// * `fileOptions` is the object that represent the sadFsq File options. See [File Options](./sadfsqClient.md#file-options-).  
	/// * `data` is a `String | Buffer`.  
	/// * `options` is an `object` that could contains :  
	///     * encoding : `String | null` default = `utf-8`.  
	///     * flag : `String`default = `w`. See [Flags](./sadfsqClient.md#flags-).  
	///       The rules described in [open()](./sadfsqClient.md#open-) function are also applied here.  
	/// 
	/// ``` javascript
	///    var options = {  
	///         encoding:"utf-8",
	///         flag : "w"
	///    };  
	/// ```
	/// 
	/// The `encoding` option is ignored if `data` is a buffer. It defaults to 'utf8'.  
	/// 
	writeFile: function(_, fileOptions, data, options) {
		options = options || {};
		options.flag = "w";
		this._writeFile(_, fileOptions, data, options);
	},

	_writeFile: function(_, fileOptions, data, options) {
		this.__connect(_);
		var fd = this.open(_, fileOptions, options.flag);
		// get full size of the file 
		var buffer = data instanceof Buffer ? data : new Buffer(data, options.encoding ? options.encoding : "utf-8");
		this.write(_, fd, buffer, 0, buffer.length, 0, options.lock ? options.lock : false);
		this.close(_, fd);
	},

	/// 
	/// -------------
	/// ### write :  
	/// ``` javascript  
	/// sadfs.write(_, fd, buffer, offset, length, [position], [lock]);  
	/// ```
	/// Write buffer to the remote file specified by `fd`.  
	/// 
	/// * `offset` and `length` determine the part of the buffer to be written.  
	/// * `position` refers to the offset from the beginning of the file where this data should be written. If `position` is `null`, the data will be written at the current position.  
	/// * `lock` is boolean parameter that determines if the write operation use lock. if it's not define, `null` or `false` , the lock and lock test is not applied .  
	/// 
	/// On Linux, positional writes don't work when the file is opened in append mode. The kernel ignores the position argument and always appends the data to the end of the file. See [open()](./sadfsqClient.md#open-) rules.      
	/// 
	write: function(_, fd, buffer, offset, length, position, lock) {
		this.__connect(_);
		var opened = this.fdsOpen[fd];
		if (opened) {
			if (lock) {
				if (!this.lock(_, fd, 2, length, position ? position : 0)) {
					throw new Error(locale.format(module, "writeFileLock"));
				}
			}
			if (position != null) {
				this.flush(_, fd);
				this.seek(_, fd, 0, position);
			}
			var begin = offset || 0;
			var end = begin + length;
			this.communicator.processEBF(_, opened.fd, buffer.slice(begin, end));
			if (lock) {
				if (!this.lock(_, fd, 0, length, position ? position : 0)) {
					throw new Error(locale.format(module, "writeCantUnLock"));
				}
			}

			//this.fdsOpen[fd].size += length;

		} else {
			throw new Error(locale.format(module, "writeNotOpened"));
		}

	},

	/// 
	/// -------------
	/// ### appendFile :  
	/// ``` javascript  
	/// sadfs.appendFile(_, fileOptions, data, [options]);  
	/// ```
	/// Append data to athe remote file, creating the file if it not yet exists.  
	/// 
	/// * `fileOptions` is the object that represent the sadFsq File options. See [File Options](./sadfsqClient.md#file-options-).  
	/// * `data` is a `String | Buffer`.  
	/// * `options` is an `object` that could contains :  
	///     * encoding : `String | null` default = `utf-8`.  
	///     * flag : `String`default = `a`. See [Flags](./sadfsqClient.md#flags-).  
	///       The rules described in [open()](./sadfsqClient.md#open-) function are also applied here.  
	/// 
	/// ``` javascript
	///    var options = {  
	///         encoding:"utf-8",
	///         flag : "a"
	///    };  
	/// ```
	/// 
	/// The `encoding` option is ignored if `data` is a buffer. It defaults to 'utf8'.  
	/// 
	appendFile: function(_, fileOptions, data, options) {
		options = options || {};
		options.flag = "a";
		this._writeFile(_, fileOptions, data, options);
	},

	/// 
	/// -------------
	/// ### unlink :  
	/// ``` javascript  
	/// sadfs.unlink(_, fileOptions);  
	/// ```
	/// Delete the remote file specified by `fileOptions`.  
	/// 
	/// * `fileOptions` is the object that represent the sadFsq File options. See [File Options](./sadfsqClient.md#file-options-).  
	///
	unlink: function(_, fileOptions) {
		var sadFile = new SadFsqFile(fileOptions);
		this._unlink(_, sadFile);
	},

	_unlink: function(_, sadFile) {
		this.__connect(_);
		try {
			this.communicator.processEFF(_, sadFile);
		} catch (e) {
			if (isCommError(e)) {
				throw e;
			}
			tracer.info() && tracer.info("can't remove file " + e.message + " - retry");
			this.stream && this.stream.end;
			this.stream = null;
			this.__connect(_);
			this.communicator.processEFF(_, sadFile);
		}
		return;
	},

	/// 
	/// -------------
	/// ### flush :  
	/// ``` javascript  
	/// sadfs.flush(_, fd);  
	/// ```
	/// Force the buffers to be flushed into the file specified by `fd` without waiting for close.  
	///
	flush: function(_, fd) {
		this.__connect(_);
		var opened = this.fdsOpen[fd];
		if (opened) {
			this.communicator.processVID(_, opened.fd);
		} else {
			throw new Error(locale.format(module, "flushNotOpened"));
		}
	},

	/// 
	/// -------------
	/// ### exists :  
	/// ``` javascript  
	/// sadfs.exists(_, fileOptions);  
	/// ```
	/// Test whether or not the given remote file specified by `fileOptions` exists by checking with the file system.  
	/// 
	/// * `fileOptions` is the object that represent the sadFsq File options. See [File Options](./sadfsqClient.md#file-options-).  
	/// 
	/// Returns true if the file exists.  
	///
	exists: function(_, fileOptions) {
		this.__connect(_);
		try {
			this.stat(_, fileOptions, ["size"]);
			return true;
		} catch (e) {
			return false;
		}
	},

	/// 
	/// -------------
	/// ### lock :  
	/// ``` javascript  
	/// sadfs.lock(_, fd, type, len, pos);  
	/// ```
	/// Allows sections of the file specified by fd to be locked.  
	/// 
	/// * `fd` argument is an open file descriptor. The file descriptor must have Write permission in order to establish locks with this function call.  
	/// * `type` argument is a control value that specifies the action to be taken. The permissible values for function are :  
	///    * 0: unlock previously locked section.  
	///    * 1: lock section for exclusive use.  
	///    * 2: test & lock section for exclusive use.  
	///    * 3: test section for other locks.  
	/// * `len` argument is the number of contiguous bytes to be locked or unlocked.  
	/// * `pos` define where the lock will start. Not including current byte.  
	/// 
	/// Force the buffers to be flushed into the file specified by fd without waiting for close.  
	/// 
	lock: function(_, fd, type, len, pos) {
		this.__connect(_);
		var opened = this.fdsOpen[fd];
		if (opened) {
			return this.communicator.processLCK(_, opened.fd, type, len, pos);
		} else {
			throw new Error(locale.format(module, "lockNotOpened"));
		}
	},

	/// 
	/// -------------
	/// ### mkdir :  
	/// ``` javascript  
	/// sadfs.mkdir(_, fileOptions);  
	/// ```
	/// Create a remote directory   
	/// 
	/// * `fileOptions` is the object that represent the sadFsq File options. See [File Options](./sadfsqClient.md#file-options-).  
	/// 
	/// Returns the output generated by the command `ae_mkdir`.  
	/// 
	mkdir: function(_, fileOptions) {
		// case ae_mkdir fullpath
		return this._execbin(_, "ae_mkdir", this.path(_, fileOptions));
	},

	/// 
	/// -------------
	/// ### rmdir :  
	/// ``` javascript  
	/// sadfs.rmdir(_, fileOptions);  
	/// ```
	/// Remove a remote directory   
	/// 
	/// * `fileOptions` is the object that represent the sadFsq File options. See [File Options](./sadfsqClient.md#file-options-).  
	/// 
	/// Returns the output generated by the command `ae_rmdir`.  
	/// 
	rmdir: function(_, fileOptions) {
		return this._execbin(_, "ae_rmdir", this.path(_, fileOptions));
		// an exception is raise if the launch of process failed
	},

	/// 
	/// -------------
	/// ### readdir :  
	/// ``` javascript  
	/// var array = sadfs.readdir(_, fileOptions);  
	/// ```
	/// List the content of a remote directory   
	/// 
	/// * `fileOptions` is the object that represent the sadFsq File options. See [File Options](./sadfsqClient.md#file-options-).  
	/// 
	/// Returns an array that represents the content of the remote directory.  
	/// 
	readdir: function(_, fileOptions) {
		var res = [];
		this._execbin(_, "lsadx", this.path(_, fileOptions)).split('\n').map(function(item) {
			if (item !== ".." && item !== "." && item.length !== 0) {
				res.push(item);
			}
		});
		return res;
	},

	/// 
	/// -------------
	/// ### exec :  
	/// ``` javascript  
	/// var output = sadfs.exec(_, cmd);  
	/// ```
	/// Execute a remote process.  
	/// 
	/// * `cmd` is the command to launch on the adxadmin server.  
	/// 
	/// Returns the output generated by the command `cmd`.  
	/// 
	exec: function(_, cmd) {
		this.__connect(_);
		var sadFile = new SadFsqFile({
			canonical: cmd + " "
		});
		var pid;
		try {
			tracer.info() && tracer.info("command " + cmd);
			pid = this.communicator.processOUP(_, sadFile, "r");
		} catch (e) {
			if (isCommError(e)) {
				throw e;
			}
			this.stream && this.stream.end;
			this.steam = null;
			tracer.info() && tracer.info("can't execute command " + e.message + " - retry");
			this.__connect(_);
			pid = this.communicator.processOUP(_, sadFile, "r");
		}
		if (pid) {
			var buffer = this.communicator.processLBF(_, pid);
			if (buffer) {
				this.communicator.processFER(_, pid);
				return buffer.toString('utf-8');
			}
		} // else an errar is catch by T_OUP
		throw new Error("failed to exec cmd " + cmd);
	},

	_execbin: function(_, cmd, path) { // execute a command 
		return this.exec(_, cmd + " " + path);
	},

	/// 
	/// -------------
	/// ### kill :  
	/// ``` javascript  
	/// var output = sadfs.kill(_, pid, signal);  
	/// ```
	/// Kill a remote process.  
	/// 
	/// * `pid` is the remote process identifier.  
	/// * `signal` is the signal to send to this process. 1 to 9.  
	/// 
	kill: function(_, pid, signal) {
		this.__connect(_);
		this.communicator.processKUS(_, pid, signal);
	},

	disconnect: function(_) {
		this._disconnect(_);
	},
});