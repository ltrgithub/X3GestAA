"use strict";
/*jshint unused:false */

/// !doc
/// 
/// # PrintComm module
/// 
/// DO NOT USE THIS MODULE DIRECTLY !!!  
/// This documentation is only provided to understand the protocol layer !  
/// 
/// To interface with print server, please refer to [PrintClient module API](https://github.com/Sage-ERP-X3/Syracuse/blob/master/node_modules/syracuse-x3/lib/clients/print/client/PrintClient.md "PrintClient module API").
/// 
/// ---

var helpers = require('syracuse-core/lib/helpers');
var config = require('config');
var locale = require("syracuse-core/lib/locale");
var props1Serializer = require("syracuse-x3/lib/convergence/automata/x3writer").props1Serializer;

var traceProtocol = config.x3print && config.x3print.protocol && config.x3print.protocol.trace;

var ND_SLF = [0x12, 0x0C];
var ND_GFD = [0x12, 0x0B];
var ND_LIM = [0x12, 0x0A];
var ND_GETSTATEREPORT = [0x12, 0x7B];
var ND_GETRESULTREPORT = [0x12, 0x7C];
var ND_DELETEREPORT = [0x12, 0x7F];
var ND_NDOUVIMP = [0x12, 0x01];

var ND_ALLPRINT = [0x42, 0x01];
var ND_MOREPRINT = [0x42, 0x03];
var ND_EXTRAPRINT = [0x42, 0x04];

var ZERO_BYTE = new Buffer([0x00]);
var NODE_ID_LEN = new Buffer([0x00, 0x02]);

function trace(_, spy, str) {
	traceProtocol && traceProtocol(str);
	spy && spy.dumpStr(_, str);
}

function readIntOnUcs2(buf, offset) {
	return new Buffer([buf[offset], buf[offset + 2], buf[offset + 4], buf[offset + 6]]).readInt32BE(0);
}

function writeProperties1(_, stream, propsStr, node) {
	var buf;
	if (propsStr.length !== 0) {
		var bufLen = new Buffer(4);
		bufLen.writeInt32BE(propsStr.length, 0);
		buf = Buffer.concat([new Buffer([0]), bufLen, new Buffer(propsStr, "utf8")]);
	} else {
		buf = new Buffer([]);
	}
	//traceProtocol && traceProtocol("Send properties: "+propsStr);
	var nodeId = new Buffer(node);
	var bufEnd = new Buffer(4);
	bufEnd.writeInt32BE(0, 0);
	stream.write(_, Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId, buf, new Buffer([0]), bufEnd]));
}

function getProperty(map, data, isProperties2) {

	function storeProperty() {
		var keyBuf = new Buffer(key);
		var keyStr = keyBuf.toString('utf8');
		var valueBuf = new Buffer(value);
		var valueStr = valueBuf.toString('utf8');

		map[keyStr] = map[keyStr] || [];
		map[keyStr][idx - 1] = valueStr;
	}
	var idx;
	var key = [];
	var value = [];
	var applyOn = "key";
	var nextIsIdx = false;
	for (var i = 0; i < data.length; i++) {
		if (!nextIsIdx) {
			// =
			if (data[i] === 61) {
				applyOn = "value";
				try {
					idx = parseInt(data[i + 1], 10);
					nextIsIdx = true;
				} catch (e) {
					idx = 0;
				}
			}
			// \n
			else if (!isProperties2 && data[i] === 10) {
				applyOn = "key";
				storeProperty();
				key = [];
				value = [];
			} else {
				if (applyOn === "key") key.push(data[i]);
				else if (applyOn === "value") {
					value.push(data[i]);
				}
			}
		} else {
			nextIsIdx = false;
		}
	}
	if (isProperties2 && idx && idx > 0) {
		storeProperty();
	}
	return map;
}

/// #properties
/// 
/// Several nodes need to serialize/unserialize some properties.  
/// A property mustn't be greater than 250 characters and can be splitted by 4GL language like follow :  
/// 
/// 	- Key/Value
///     key1=\u0001value.........until 250 characters\n
///     key1=\u0002complement\n
///     key2=value2
///     - or just Key
///     key1\n
///     key2\n
/// 
/// 
/// There two kind of properties: propeties1 and propeties2.  
/// 
/// ##properties1  
/// Each property block contains:  
/// 
///   - **1-byte** : fixed: 0x00.  
///   - **4-bytes** : (Integer) corresponding to the property length.  
/// 
/// Each global properties must finish with :  
/// 
///   - **5-bytes** : fixed: 0x00, 0x00, 0x00, 0x00, 0x00  
/// 
/// ##properties2  
/// Each property block contains:  
/// 
///   - **1-byte** : fixed: 0x00.  
///   - **4-bytes** : (Integer) corresponding to the property length.  
/// 
/// Each global properties must finish with :  
/// 
///   - **5-bytes** : fixed: 0x00, 0x00, 0x00, 0x00, 0x00  
/// 

function readProperties1(_, stream) {
	var map = {};
	while (true) {
		var head = stream.read(_, 5);
		var len = head.readInt32BE(1);
		if (len < 0) throw new Error("bad property1 len: " + len);
		if (len === 0) {
			for (var i in map) {
				if (map[i] && Array.isArray(map[i])) map[i] = map[i].join('');
			}
			//console.log("Properties1: "+JSON.stringify(map,null,2));
			return map;
		}
		map = getProperty(map, stream.read(_, len));
	}
}

function readProperties2(_, stream) {
	var map = {};
	while (true) {
		var len = stream.read(_, 1).readInt8(0);
		if (len < 0) throw new Error("bad property2 len: " + len);
		if (len === 0) {
			stream.read(_, 4);
			for (var i in map) {
				if (map[i] && Array.isArray(map[i])) map[i] = map[i].join('');
			}
			//console.log("Properties2: "+JSON.stringify(map,null,2));
			return map;
		}
		map = getProperty(map, stream.read(_, len), true);
	}
}

exports.PrintComm = helpers.defineClass(function(_, client) {
	this.client = client;
	this.stream = client.stream;

	if (config && config.x3print && config.x3print.dump) this._spy = new Spy(_, this.stream);

}, null, {

	/// # Connection / Disconnection
	/// 
	/// This chapter describes connection and disconnection sequences with Safe X3 print server component.
	/// 
	/// ##**Connection**
	/// 
	/// Opening classic TCP/IP socket on 'server:port' with print server.  
	/// 
	///   - **First step** : open session.  
	///      - Request 1 :  
	///         - **2-bytes** : fixed to identify connection type.  
	///      - Reply 1 :  
	///         - **4-bytes** : corresponding to the connection ID gave by the print server.  
	/// 
	///   - **Second step** : Serialization of node ND_SLF (standard Adonix node) to communicate the client's type to the print server.  
	///      - Request 2 :  
	///         - **1-byte** : fixed: 0x00.  
	///         - **2-bytes** : for nodeId length equals to 2: 0x00, 0x02.  
	///         - **2-bytes** : for nodeId: 0x12, 0x0C.  
	///         - **N-bytes** : Serialization of [properties1](##properties1 "properties1") array with version informations (client technoVers).  
	///      - Reply 2 :  
	///         - **N-bytes** : Deserialization of [properties1](##properties1 "properties1") array with version informations (server technoVers).  
	/// 
	/// ---
	connect: function(_) {
		this.dumpHeader(_, "CONNECT");
		this.stream.write(_, new Buffer([5, 0]));
		var buf = this.stream.read(_, 4);
		var pid = buf.readInt32BE(0);
		if (pid === -1) throw new Error(locale.format(module, "connectionFailed"));
		traceProtocol && traceProtocol("Connected: " + pid);
		this.client.srvTechnoVers = this.send_ND_CALLUI(_, this.client.technoVers);
		this.dumpResult(_, pid);
		return pid;
	},

	/// ##**Disconnection**
	/// 
	/// Disconnection is effected for sending the sequence described below, without ack from the server.
	/// 
	///   - Request :  
	///      - **1-byte** : fixed: 0x00. 
	///      - **2-bytes** : (Short) for nodeId length equals to 2: 0x00, 0x02.  
	///      - **2-bytes** : for nodeId: 0x12, 0x63.  
	/// 
	/// ---
	/// 
	disconnect: function(_) {
		this.dumpHeader(_, "DISCONNECT");
		this.send_ND_CLOSE(_);
	},
	send_ND_CLOSE: function(_) {
		this.dumpHeader(_, "ND_CLOSE");
		this.stream.write(_, new Buffer([0x00, 0x00, 0x02, 0x12, 0x63]));
	},
	// Not used
	send_ND_FIN: function(_) {
		this.dumpHeader(_, "ND_FIN");
		this.stream.write(_, new Buffer([0x00, 0x00, 0x02, 0x12, 0x02]));
	},
	// Instruction 4GL "Getui"
	send_ND_GETUI: function(_, arr) {
		var p = arr.join('\n');
		this.dumpHeader(_, "ND_GETUI", p);
		writeProperties1(_, this.stream, p, ND_GFD);
		var res = Object.keys(readProperties1(_, this.stream));
		this.dumpResult(_, res);
		return res;
	},
	// Instruction 4GL "Callui"
	send_ND_CALLUI: function(_, props) {
		var p = props1Serializer.build(props);
		this.dumpHeader(_, "ND_CALLUI", p);
		writeProperties1(_, this.stream, p, ND_SLF);
		var res = readProperties1(_, this.stream);
		this.dumpResult(_, res);
		return res;

	},

	/// #Reports interactions
	/// 
	/// The implementation of the operations of submission / followed progress / delete a print request server publishing results at 4 knots specific protocol presented below.  
	/// 
	/// 
	/// ##**Node OUVIMP**
	/// Submitting a print request.  
	/// 
	///   - Request :  
	///      - **1-byte** : fixed: 0x00. 
	///      - **2-byte** : (Short) for nodeId length equals to 2: 0x00, 0x02.  
	///      - **2-byte** : for nodeId: 0x12, 0x01.  
	///      - Array of strings with print settings, encoded in utf8, structured in the form of N packets as follows:  
	///         - **1-byte** Length of the packet to be followed.  
	///         - **N-bytes** Corresponding to the packet to be followed.
	///         - **1-byte** After the last packet.  
	///         - **4-bytes** to zero corresponding to the end of reading the node
	///   - Reply :  
	///      - **2-bytes** : The sequence number of the saved job by the print server (short coded in portable format standard). Beware the sequence number is valued at 0 if an error occur in the recording job.  
	/// 
	/// ---
	/// 
	send_ND_NDOUVIMP: function(_, properties) {
		this.dumpHeader(_, "ND_NDOUVIMP", properties);
		// Build request
		var nodeId = new Buffer(ND_NDOUVIMP);
		var buf = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId]);

		var bufProps = new Buffer([]);
		for (var i in properties) {
			var str = i + '=\u0001' + properties[i];
			var b = new Buffer(str, 'utf8');
			var l = new Buffer([b.length]);
			bufProps = Buffer.concat([bufProps, l, b]);
		}
		var endBuf = new Buffer(4);
		endBuf.writeInt32BE(0, 0);
		this.stream.write(_, Buffer.concat([buf, bufProps, new Buffer([0]), endBuf]));

		// Get response
		var seqId = this.stream.read(_, 2).readInt16BE(0);
		this.dumpResult(_, seqId);
		return seqId;
	},

	/// ##**Node DELETEREPORT**
	/// Forced stop a print request. No acknowledgment of the server after the sending of the request.  
	/// 
	///   - Request :  
	///      - **1-byte** : fixed: 0x00. 
	///      - **2-bytes** : (Short) for nodeId length equals to 2: 0x00, 0x02.  
	///      - **2-bytes** : for nodeId: 0x12, 0x7F.  
	///      - **1-byte** : corresponding to the lenght of the next Short: 0x02.
	///      - **2-bytes** : corresponding to the sequence number of the request to remove (short standard format). The sequence number corresponds to the value returned by the node NDOUVIMP.
	///      - **1-byte** : fixed: 0x00. 
	///   - Reply :  
	///      - this node does not return a response.
	/// 
	/// ---
	/// 
	send_ND_DELETEREPORT: function(_, seqId) {
		if (typeof seqId === 'string') seqId = parseInt(seqId, 10);
		this.dumpHeader(_, "ND_DELETEREPORT", {
			seqId: seqId
		});
		// Build request
		var nodeId = new Buffer(ND_DELETEREPORT);
		var bufSeq = new Buffer(2);
		bufSeq.writeInt16BE(seqId, 0);
		var buf = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId, new Buffer([2]), bufSeq, ZERO_BYTE]);
		this.stream.write(_, buf);
		// No response
	},

	/// ##**Node GETSTATEREPORT**
	/// Recovery of the current state of a request.  
	/// 
	///   - Request :  
	///      - **1-byte** : fixed: 0x00. 
	///      - **2-bytes** : (Short) for nodeId length equals to 2: 0x00, 0x02.  
	///      - **2-bytes** : for nodeId: 0x12, 0x7B.  
	///      - **1-byte** : corresponding to the length of the UTF-8 buffer containing the identifier of the job as alpha.  
	///      - **1-byte** : UTF-8 buffer containing the identifier of the job as alpha.  
	///   - Reply :  
	///      - **2-bytes** : status code (Short standard format).  
	///      - **N-bytes** : UTF8 buffer corresponding to the error message or information associated with the status code, structured in the form of N packets as follows :  
	///         - **4-bytes** Length of the packet to be followed (Long Standard format).  
	///         - **N-bytes** Corresponding to the packet to be followed.  
	///         - **4-bytes** to zero corresponding to the end of reading the node  
	/// 
	/// ---
	/// 
	send_ND_GETSTATEREPORT: function(_, jobId) {
		this.dumpHeader(_, "ND_GETSTATEREPORT", {
			jobId: jobId
		});
		// Build request
		var bufJob = new Buffer(jobId.toString(), "utf8");
		var nodeId = new Buffer(ND_GETSTATEREPORT);
		var buf = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId, new Buffer([bufJob.length]), bufJob]);
		this.stream.write(_, buf);
		// Get response
		var code = this.stream.read(_, 2).readInt16BE(0);
		var bufMsg = new Buffer([]);
		while (true) {
			var lenBlock = this.stream.read(_, 4).readInt32BE(0);
			if (lenBlock < 0) throw new Error("bad block len: " + lenBlock);
			if (lenBlock === 0) break;
			bufMsg = Buffer.concat([bufMsg, this.stream.read(_, lenBlock)]);
		}
		var msg = bufMsg.toString('utf8');
		var res = {
			code: code,
			message: msg
		};
		this.dumpResult(_, res);
		return res;
	},

	/// ##**Node GETRESULTREPORT**
	/// Recovery of the result of a request.  
	/// 
	///   - Request :  
	///      - **1-byte** : fixed: 0x00. 
	///      - **2-bytes** : (Short) for nodeId length equals to 2: 0x00, 0x02.  
	///      - **2-bytes** : for nodeId: 0x12, 0x7C.  
	///      - **1-byte** : corresponding to the length of the UTF-8 buffer containing the identifier of the job as alpha.  
	///      - **1-byte** : UTF-8 buffer containing the identifier of the job as alpha.  
	///   - Reply :  
	///      - **4-bytes** : overall size of the bitstream corresponding to the result of publishing (Long standard format).  
	///      - **N-bytes** : UTF8 buffer corresponding to the error message or information associated with the status code, structured in the form of N packets as follows :  
	///         - **4-bytes** Length of the packet to be followed (Long Standard format).  
	///         - **N-bytes** Corresponding to the packet to be followed.  
	///         - **4-bytes** to zero corresponding to the end of reading the node  
	/// 
	/// ---
	/// 
	send_ND_GETRESULTREPORT: function(_, jobId) {
		this.dumpHeader(_, "ND_GETRESULTREPORT", {
			jobId: jobId
		});
		// Build request
		var bufJob = new Buffer(jobId.toString(), "utf8");
		var nodeId = new Buffer(ND_GETRESULTREPORT);
		var buf = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId, new Buffer([bufJob.length]), bufJob]);
		this.stream.write(_, buf);
		// Get response
		var lenBin = this.stream.read(_, 4).readInt32BE(0);
		var bufBin = new Buffer([]);
		while (true) {
			var lenBlock = this.stream.read(_, 4).readInt32BE(0);
			if (lenBlock < 0) throw new Error("bad block len: " + lenBlock);
			if (lenBlock === 0) break;
			bufBin = Buffer.concat([bufBin, this.stream.read(_, lenBlock)]);
		}
		var bin = bufBin.toString('binary');
		var res = {
			length: lenBin,
			binary: bin
		};
		this.dumpResult(_, res);
		return res;
	},

	/// ##**Node PRIORITYREPORT**
	/// Change priority of a job. 
	/// 
	/// Serialization of node ND_SLF (standard Adonix node) to send 'ChangeOrderRptJob' informations to change priority of jobs.  
	/// 
	///   - Request :  
	///      - **1-byte** : fixed: 0x00.  
	///      - **2-bytes** : for nodeId length equals to 2: 0x00, 0x02.  
	///      - **2-bytes** : for nodeId: 0x12, 0x0B.  
	///      - **N-bytes** : Serialization of [properties1](##properties1 "properties1") array :  
	/// 
	/// ```
	/// {
	///   SRVAction: 'ChangeOrderRptJob',
	///   SRVRptJobId: 1, // Rank
	///   SRVRptJobOrder = '+|-|MIN|MAX'
	/// }
	/// ```
	/// 
	///   - Reply :  
	///      - **N-bytes** : Deserialization of [properties1](##properties1 "properties1") array with priority changes status.  
	/// 
	/// ---
	/// 
	send_ND_PRIORITYREPORT: function(_, seqId, order) {
		var orderMap = ['MIN', 'MAX', '+', '-'];
		var propsIn = {
			SRVAction: 'ChangeOrderRptJob',
			SRVRptJobId: seqId
		};
		if (order) {
			if (orderMap.indexOf(order) !== -1) {
				propsIn.SRVRptJobOrder = order;
			} else {
				throw new Error(locale.format(module, 'unknowOrder', order, orderMap.join(';')));
			}
		}
		var propsOut = this.send_ND_CALLUI(_, propsIn);
		return propsOut;
	},

	/// ##**Node DISPLAYREPORT**
	/// Dump the list of jobs stacked in the print server. 
	/// 
	/// Serialization of node ND_GFD (standard Adonix node) to ask 'SrvImpDispJobs' informations to the print server.  
	/// 
	///   - Request :  
	///      - **1-byte** : fixed: 0x00.  
	///      - **2-bytes** : for nodeId length equals to 2: 0x00, 0x02.  
	///      - **2-bytes** : for nodeId: 0x12, 0x0B.  
	///      - **N-bytes** : Serialization of [properties1](##properties1 "properties1") array ['SrvImpDispJobs'].  
	///   - Reply :  
	///      - **N-bytes** : Deserialization of [properties1](##properties1 "properties1") array with jobs informations.  
	/// 
	/// ---
	/// 
	send_ND_DISPLAYREPORT: function(_) {
		var propsIn = ['SrvImpDispJobs'];
		var propsOut = this.send_ND_GETUI(_, propsIn);
		var result = [],
			S = "STATUS_",
			P = "PHASE_",
			D = "DESTINATION_";
		for (var i in propsOut) {
			var arr = propsOut[i].split('|');
			var app = arr[9].split(';'),
				s, p, d;
			s = S + parseInt(arr[5], 10);
			p = P + parseInt(arr[6], 10);
			d = D + parseInt(arr[7], 10);
			var prop = {
				order: parseInt(arr[0], 10),
				rank: parseInt(arr[1], 10),
				processId: parseInt(arr[2], 10),
				serverDuration: parseInt(arr[3], 10),
				processDuration: parseInt(arr[4], 10),
				status: locale.format(module, s),
				phase: locale.format(module, p),
				destination: locale.format(module, d),
				report: arr[8],
				application: {
					folder: app[0],
					host: app[1],
					port: app[2]
				},
				user: arr[10],
				workstation: arr[11],
				linked: parseInt(arr[12], 10)
			};
			result.push(prop);
		}
		return result;
	},

	/// #Printer Descriptions
	/// The implementation of the operations of selection / configuration of printers on a server publishing results at 5 knots specific protocol presented below.  
	/// ##**Node ND_LIM**
	/// Retrieving the list of printers attached to a print server.  
	/// 
	///   - Request :  
	///      - **1-byte** : fixed: 0x00. 
	///      - **2-bytes** : (Short) for nodeId length equals to 2: 0x00, 0x02.  
	///      - **2-bytes** : for nodeId: 0x12, 0x0A.  
	///      - **N-bytes** : Serialization of [properties1](##properties1 "properties1") array.  
	///   - Reply :  
	///      - **N-byte** : deserialization of [properties1](##properties1 "properties1") array containing the number of printers (first element) and the names of printers (subsequent occurrences).
	/// 
	/// ---
	/// 
	send_ND_LIM: function(_) {
		var p = props1Serializer.build({});
		this.dumpHeader(_, "ND_LISTPRINTER", p);
		writeProperties1(_, this.stream, p, ND_LIM);
		var props = readProperties1(_, this.stream);
		var n = parseInt(props._NbPrinters.charCodeAt(0), 10);
		props._NbPrinters = n;
		this.dumpResult(_, props);
		return props;
	},

	/// ##**Node GET_ALLPRINTERS**
	/// Retrieving the list of printers and their standard properties.  
	/// 
	///   - Marshalling :  
	///      - Request :  
	///         - **1-byte** : fixed: 0x00. 
	///         - **2-bytes** : (Short) for nodeId length equals to 2: 0x00, 0x02.  
	///         - **2-bytes** : for nodeId: 0x42, 0x01.  
	///      - Reply :  
	///         - **N-bytes** : structured in the form of N packets as follows:  
	///         - **4-byte** : length of response buffer to follow.  
	///         - **N-bytes** : corresponding bytes in buffer binary response.
	///         - **4-bytes** to zero corresponding after the last buffer response.  
	///     
	///   - Structuring binary buffer :  
	///   We have this buffer generate for each printer send back from print server N times this buffer if N is the number of printers :  
	/// 
	///      - 4-bytes : length of printer name (n1)  
	///      - n1-bytes : printer name  
	///      - 4-bytes : length of printer port (n2)  
	///      - n2-bytes : printer port  
	///      - 4-bytes : length of driver name (n3)  
	///      - n3-bytes : driver name  
	///      - 4-bytes : length of comment (n4)  
	///      - n4-bytes : comment  
	///      - 4-bytes : length of location (n5)  
	///      - n5-bytes : location  
	///      - 4-bytes : length of devmod (n6)  
	///      - n6-bytes : devmod  
	///      - 1-bytes : boolean identify capabilities : collate  
	///      - 1-bytes : boolean identify capabilities : copies  
	///      - 1-bytes : boolean identify capabilities : orientation  
	///      - 1-bytes : boolean identify capabilities : duplex  
	/// 
	/// ---
	/// 
	send_ND_GET_ALLPRINTERS: function(_) {
		function readAllPrinterParam() {
			var len = bufBin.readInt32BE(offset);
			offset += 4;
			var elem = "";
			if (len > 0) {
				elem = bufBin.slice(offset, offset + len).toString('ucs2');
				offset += len;
			}
			return elem;
		}

		this.dumpHeader(_, "ND_ALLPRINT");
		var nodeId = new Buffer(ND_ALLPRINT);
		var buf = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId]);
		this.stream.write(_, buf);
		// read all printer info
		var bufBin = new Buffer([]);
		var nbLen = 0;
		while (true) {
			var lenBlock = this.stream.read(_, 4).readInt32BE(0);
			if (lenBlock < 0) throw new Error("bad block len: " + lenBlock);
			if (lenBlock === 0) break;
			bufBin = Buffer.concat([bufBin, this.stream.read(_, lenBlock)]);
		}
		nbLen = bufBin.length;
		var result = [];
		// analysis of bin flux 
		var offset = 0;
		if (nbLen !== 0) {
			do {
				// printerName
				var obj = {
					printerName: readAllPrinterParam(),
					// printer Port
					printerPort: readAllPrinterParam(),
					// driver name
					driverName: readAllPrinterParam(),
					// comment
					comment: readAllPrinterParam(),
					// location 
					location: readAllPrinterParam()
				};
				readAllPrinterParam();
				obj.collate = bufBin[offset++] === 1 ? true : false;
				// copies
				obj.copies = bufBin[offset++] === 1 ? true : false;
				// orientatio
				obj.orientation = bufBin[offset++] === 1 ? true : false;
				// duplex
				obj.duplex = bufBin[offset++] === 1 ? true : false;
				result.push(obj);
			} while (offset < nbLen);
		}
		this.dumpResult(_, result);
		return result;
	},

	/// ##**Node MORE_PRINTER**
	/// Recovery advanced settings for a particular printer.  
	/// 
	///   - Marshalling :  
	///      - Request :  
	///         - **1-byte** : fixed: 0x00. 
	///         - **2-bytes** : (Short) for nodeId length equals to 2: 0x00, 0x02.  
	///         - **2-bytes** : for nodeId: 0x42, 0x03.  
	///         - **4-bytes** : Request buffer length to follow (length coded in portable format standard). The request buffer contains the identifier of the printer whose settings you want to retrieve (UCS-2 LE).  
	///         - **N-byte** : Buffer request.  
	///      - Reply :  
	///         - **4-bytes** : Binary buffer length to follow.  
	///         - **N-bytes** : corresponding to buffer response.  
	///     
	///   - Structuring binary buffer :  
	///   We have this buffer generate for each printer send back from print server N times this buffer if N is the number of printers :  
	/// 
	///      - Buffer request :  
	///         - **4-bytes** : buffer size (Int BE).    
	///         - **N-bytes** : buffer (printerName+"\n"+driver+"\n"+portName).  
	///      - Buffer response :  
	///         - **4-bytes** : full buffer size  
	///         - **8-bytes** : lenght of all papersize + id / 2 (64 + 4 * nb element). As the papersize and length is encoded in ucs2 it's in reality have this length 128+8* nb elem but it's not send devided by 2 by the server.  
	///         - **N * 8-bytes** : list of Id of papersize encoded in UCS2.  
	///         - **N * 128-bytes : list of value of papersize encoded in UCS2.  
	///         - **8-bytes** : lenght of all trays + id / 2 (24 + 4 * nb element). As the trays and length is encoded in ucs2 it's in reality have this length 48+8* nb elem but it's not send devided by 2 by the server.  
	///         - **N * 8-bytes** : list of Id of trays encoded in UCS2.  
	///         - **N * 48-bytes** : list of value of trays encoded in UCS2.  
	/// 
	/// ---
	/// 
	send_ND_MORE_PRINTER: function(_, prName, prPort, prDriver) {
		this.dumpHeader(_, "ND_MORE_PRINTER", {
			printerName: prName,
			printerPort: prPort,
			driverName: prDriver
		});
		var nodeId = new Buffer(ND_MOREPRINT);
		var header = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId]);
		//write  full buffer len
		var buffLen = new Buffer(4);
		var body = prName + '\n' + (prDriver == null ? "" : prDriver) + '\n' + (prPort == null ? "" : prPort);
		var bufBod = new Buffer(body, "ucs2");
		buffLen.writeInt32BE(bufBod.length, 0);
		var buf = Buffer.concat([header, buffLen, bufBod]);

		this.stream.write(_, buf);

		var bufLen = this.stream.read(_, 4);
		var lenBlock = bufLen.readInt32BE(0); // len total
		if (lenBlock < 0) throw new Error("bad block len: " + lenBlock);

		var bufBin = this.stream.read(_, lenBlock);

		var offset = 0;
		var lenPaperSize = readIntOnUcs2(bufBin, offset);
		offset += 8;
		var valueOff = offset;
		var nbElem = lenPaperSize / 68;
		valueOff += nbElem * 8;
		var paperSize = [];
		for (var i = 0; i < nbElem; i++) {
			var tmp = bufBin.slice(valueOff, valueOff + 128);
			tmp = Buffer.concat([tmp, new Buffer([0])]);
			var str = tmp.toString('ucs2');
			str = str.substring(0, str.indexOf('\u0000'));
			paperSize.push({
				$value: readIntOnUcs2(bufBin, offset),
				$title: str
			});
			offset += 8;
			valueOff += 128;
		}

		bufBin = bufBin.slice(valueOff, bufBin.length);

		offset = 0;
		var lenBackSize = readIntOnUcs2(bufBin, offset);
		offset += 8;
		valueOff = offset;
		nbElem = lenBackSize / 28;
		valueOff += nbElem * 8;
		var bac = [];

		for (var j = 0; j < nbElem; j++) {
			var tmp2 = bufBin.slice(valueOff, valueOff + 48);
			tmp2 = Buffer.concat([tmp2, new Buffer([0])]);
			var str2 = tmp2.toString('ucs2');
			str2 = str2.substring(0, str2.indexOf('\u0000'));
			bac.push({
				$value: readIntOnUcs2(bufBin, offset),
				$title: str2
			});
			offset += 8;
			valueOff += 48;
		}

		var res = {
			"paperSize": paperSize,
			"bac": bac
		};
		this.dumpResult(_, res);
		return res;
	},

	/// ##**Node EXTRA_PRINTER**
	/// Recovery of additional options for a given printer, including the size (width / height) of a paper code.  
	/// 
	///   - Marshalling :  
	///      - Request :  
	///         - **1-byte** : fixed: 0x00. 
	///         - **2-bytes** : (Short) for nodeId length equals to 2: 0x00, 0x02.  
	///         - **2-bytes** : for nodeId: 0x42, 0x04.  
	///         - **4-bytes** : Request buffer length to follow (length coded in portable format standard). The request buffer contains the identifier of the printer for which you want to recover the additional options, with the list of identifying options to retrieve (UCS-2 LE).  
	///         - **N-byte** : Buffer request.  
	///      - Reply :  
	///         - **4-bytes** : Binary buffer length to follow.  
	///         - **N-bytes** : corresponding to buffer response.  
	///     
	///   - Structuring binary buffer :  
	///   We have this buffer generate for each printer send back from print server N times this buffer if N is the number of printers :  
	/// 
	///      - Buffer request :  
	///         - **4-bytes** : buffer size (Int BE).  
	///         - **N-bytes** : buffer (printerName+"\n"+driver+"\n"+portName).  
	///         - **4-bytes** : corresponding to the Id of papersize.  
	///      - Buffer response : 
	///         - **4-bytes** : full buffer size  
	///         - **8-bytes** : corresponding to width and height of the paper.    
	/// 
	/// ---
	/// 
	send_ND_EXTRA_PRINTER: function(_, prName, prPort, prDriver, prPaperSizeId) {
		this.dumpHeader(_, "ND_EXTRA_PRINTER", {
			printerName: prName,
			printerPort: prPort,
			driverName: prDriver,
			prPaperSizeId: prPaperSizeId
		});
		var nodeId = new Buffer(ND_EXTRAPRINT);
		var header = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId]);
		//write  full buffer len
		var buffull = new Buffer(4);
		var body = prName + '\n' + (prDriver == null ? "" : prDriver) + '\n' + (prPort == null ? "" : prPort) + "\n";
		var bufBod = new Buffer(body, "ucs2");
		var bufpaper = new Buffer(4);
		bufpaper.writeInt32BE(prPaperSizeId, 0);

		buffull.writeInt32BE(bufBod.length + bufpaper.length, 0);
		var buf = Buffer.concat([header, buffull, bufBod, bufpaper]);
		this.stream.write(_, buf);

		var lenBlock = this.stream.read(_, 4).readInt32BE(0);
		if (lenBlock < 8) throw new Error("bad block len: " + lenBlock);

		var bufBin = this.stream.read(_, lenBlock);

		var res = {
			$width: bufBin.readUInt32LE(0),
			$height: bufBin.readUInt32LE(4)
		};
		this.dumpResult(_, res);
		return res;
	},
	// Not used
	send_ND_END_PRINTER: function(_) {
		this.dumpHeader(_, "ND_END_PRINTER");
		this.stream.write(_, new Buffer([0x00, 0x00, 0x02, 0x42, 0x02]));
	},

	dumpHeader: function(_, nodeName, args) {
		trace(_, this._spy, "************************************************************");
		trace(_, this._spy, "\tSend Node: " + nodeName);
		if (args) trace(_, this._spy, "\tParams: " + JSON.stringify(args, null, 2));
		trace(_, this._spy, "************************************************************");
	},
	dumpResult: function(_, args) {
		if (args) trace(_, this._spy, "***** Result *****\n" + JSON.stringify(args, null, 2));
		trace(_, this._spy, "\n");
	}
});

var Spy = helpers.defineClass(function(_, stream) {
	var self = this;

	this.dumpFile = __dirname + "/../data/dump_" + (new Date().toISOString()).replace(/\:/g, '-') + ".js";
	require('streamline-fs').appendFile(this.dumpFile, '"use strict";\n', 'utf8', _);

	var read = stream.read;
	stream.read = function(_, len) {
		var data = read.call(stream, _, len);
		if (data) self.dumpBytes(_, "READ", data);
		return data;
	};
	var write = stream.write;
	stream.write = function(_, data) {
		write.call(stream, _, data);
		if (data) self.dumpBytes(_, "WRITE", data);
	};
}, null, {
	dumpBytes: function(_, action, data) {
		var line = action + "([0x" + data.toString('hex').match(/.{1,2}/g).join(', 0x') + "]);\n";
		require('streamline-fs').appendFile(this.dumpFile, line, 'utf8', _);
	},
	dumpStr: function(_, str) {
		require('streamline-fs').appendFile(this.dumpFile, str + "\n", 'utf8', _);
	}
});
