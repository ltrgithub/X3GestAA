"use strict";

var Context = require("syracuse-sdata/lib/sdataContext").Context;
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var locale = require('streamline-locale');
var sa = require('syracuse-orm/lib/storageArea');
var PrintClient = require('./PrintClient');
var datetime = require("syracuse-core/lib/types/datetime");
var config = require('config');

function getClient(_, context, cltId) {
	if (!context.printServer) throw new Error('No print server registered in context.');

	if (!context.printClient) {

		if (context && context.request && context.request.headers && context.request.headers["unittest"]) { // for unit test 
			var recOptions = {
				path: "node_modules/syracuse-x3/lib/clients/print/data/dispatch/",
				overwrite: true,
				recMode: context.request.headers["unittest"],
				fileName: "printDispatchTest_UNIT.json"
			};
			context.printClient = PrintClient.getClient(_, context.printServer.hostname, context.printServer.port, "UNIT_TEST", recOptions);

		} else {
			context.printClient = PrintClient.getClient(_, context.printServer.hostname, context.printServer.port, cltId);
		}

	}
	return context.printClient;
}

function getDiagnose(severity, message) {
	return JSON.stringify({
		$diagnoses: [{
			$severity: severity ? severity : "error",
			$message: message
		}]
	});
}

function getErrorDiagnose(error) {
	return JSON.stringify({
		$diagnoses: [{
			$severity: 'error',
			$message: error.message,
			$stackTrace: error.safeStack
		}]
	});
}

//URL is http://host/print/localhost:1890
var _printMap = {
	walk: function(_, context, server) {
		var parts = server.split(':');
		context.printServer = {
			hostname: parts[0],
			port: parts[1]
		};
		return _dispatch(_, context, _serviceMap);
	},
	report: function(_, context, id) {
		context.reportId = id;
		return _dispatch(_, context, _reportMap);
	},
	touch: function(_, context, id) {
		if (context.request.method === "GET") {
			// just return a 204 response this request will be use to maintain the session
			_responseFileOperaton(_, context, {
				code: 0
			});
		}
	}
};
//URL is http://host/print/$report('id')
var _reportMap = {
	get: function(_, context) {
		var headers;
		var filter = {
			jsonWhere: {
				$uuid: context.reportId
			}
		};
		var dd = sa.open(_, filter, null, "printDocument");
		if (!dd) {
			headers = {
				"Content-Type": "application/json"
			};
			context.response.writeHead(404, headers);
			context.response.end(getDiagnose("error", locale.format(module, "documentNotFound")));
		} else {
			var inst = sa.getDocumentInstance(_, filter, null, "printDocument");
			var mimeType = inst.documentType(_);
			headers = {
				"Content-Type": mimeType,
				"Content-Disposition": 'attachment; filename="' + inst.fileName(_) + '"'
			};
			context.response.writeHead(200, headers);
			var buf;
			while (buf = sa.read(_, dd)) {
				context.response.write(_, buf);
			}
			sa.close(_, dd);

			context.response.end();
		}
	},
	"delete": function(_, context) {
		var headers = {
			"Content-Type": "application/json"
		};
		var filter = {
			jsonWhere: {
				$uuid: context.reportId
			}
		};
		var result = sa.remove(_, filter, "printDocument");
		if (result === 1) {
			context.reply(_, 204);
		} else {
			context.reply(_, 500, locale.format(module, "reportNotDeleted"), headers);
		}
	}
};

var fileOperationStatus = {
	10: "not enough memory", //not enough memory
	20: "null size", //null size
	30: "read socket exception", //read socket exception
	31: "write socket exception", //write socket exception
	40: "invalide file name", //invalid file name
	41: "invalid directory", //invalid dierctory
	50: "can't delete", //can't delele
	51: "can't open", //can't open
	52: "can't write", //can't write
	9999: "unexpected error" //unexpected error

};

function _responseFileOperaton(_, context, status) { // generate response
	if (!status) {
		throw new Error("No status returned by print Api");
	} else if (status.code === 0) {
		if (status.ext) {
			// TODO write future usage in response
			context.response.writeHead(200, {});
			context.response.end({
				ext: status.ext
			});
		} else {
			context.response.writeHead(204, {});
			context.response.end();

		}
	} else {
		throw new Error("PrintEngine error : " + fileOperationStatus[status.code] || ("no error message correspond to the status " + status.code));
	}
}

//URL is http://host/print/localhost:1890/$service('id')
var _serviceMap = {
	fileSvc: function(_, context, id) {
		var name = context.request.headers["x-file-name"] || context.parameters.fileName; // header x-file-name
		var location = context.request.headers["x-file-location"] || context.parameters.location; // header x-file-location
		var meta = context.request.headers["x-file-meta"] || context.parameters.meta;
		if (context.request.method === 'PUT') {
			var buffer = context.request.readAll(_);
			//read buffer
			if (buffer != null) {

				_responseFileOperaton(_, context, getClient(_, context, id).filePut(_, name, location, meta, buffer, buffer && buffer.length));
			} else {
				throw new Error("no data in request");
			}
		} else if (context.request.method === 'DELETE') {
			_responseFileOperaton(_, context, getClient(_, context, id).fileDelete(_, name, location, meta));
		}

	},

	getState: function(_, context, id) {
		var _status = {
			99: locale.format(module, "unexpectedError"),
			98: locale.format(module, "unknowJob"),
			97: locale.format(module, "internalError"),
			0: locale.format(module, "jobStarted"),
			1: locale.format(module, "readDbPending"),
			2: locale.format(module, "readFinished"),
			3: locale.format(module, "readCanceled"),
			4: locale.format(module, "jobStacked"),
			5: locale.format(module, "jobFinished"),
			6: locale.format(module, "jobFailed"),
			7: locale.format(module, "jobCanceled")
		};
		var headers = {
			"content-type": "application/json"
		};
		var cli = getClient(_, context, id);
		var result = cli.getState(_, id);
		var body = {
			phase: _status[result.code]
		};
		if (result.message) body.phaseDetail = result.message;
		var baseUrl = context.segments.slice(0, 3).join('/');
		if (result.code >= 0 && result.code < 5) {
			headers.location = baseUrl + "/$getState('" + id + "')";
			body.pollingMillis = 1000;
			context.response.writeHead(202, headers);
			context.response.end(JSON.stringify(body));
		} else if (result.code >= 5 && result.code < 8) {
			headers.location = baseUrl + "/$getReport('" + id + "')";
			context.response.writeHead(201, headers);
			context.response.end(JSON.stringify(body));
		} else {
			context.reply(_, 500, result.message, headers);
		}

	},
	getReport: function(_, context, id) {
		var headers = {
			"content-type": "application/json"
		};
		var cli = getClient(_, context, id);
		var report = cli.getReport(_, id);
		// Store into storage area
		var dateExpire = new Date((new Date()).getTime() + (config && config.x3print && config.x3print.expiration ? config.x3print.expiration : 300000));
		var expirationDate = datetime.fromJsDate(dateExpire);
		var properties = {
			description: "Report_" + report.title + " (" + report.lang + ")",
			content: {
				contentType: report.mimeType,
				fileName: report.filename
			},
			expiration: expirationDate
		};
		var document = sa.writeAll(_, properties, new Buffer(report.binary, 'binary'), "", null, "printDocument");
		var baseUrl = context.segments.slice(0, 2).join('/');
		headers.location = baseUrl + "/$report('" + document.$uuid + "')";
		context.response.writeHead(201, headers);
		context.response.end(getDiagnose('info', locale.format(module, "reportAvailable")));

	},
	cancel: function(_, context, id) {
		var headers = {
			"content-type": "application/json"
		};
		var cli = getClient(_, context, id);
		cli.cancelReport(_, id);
		context.response.writeHead(200, headers);
		context.response.end(getDiagnose('info', locale.format(module, "jobCanceled")));
	}
};

function _parseSegment(segment) {
	var match = /^([^\/(]*)\('([^']*)'\)$/.exec(segment);
	return match ? {
		name: match[1],
		id: match[2]
	} : {
		name: segment
	};
}

function _dispatch(_, context, map) {

	var seg = context.walkUrl();
	if (seg == null) {
		// we reached the end of the URL, dispatch method
		//var method = context.request.method.toLowerCase();
		var method = context.method;
		if (map[method]) return map[method](_, context);
		else throw context.badMethod(method);
	} else {
		var pair = _parseSegment(seg);
		if (pair.name[0] === '$') {
			var name = pair.name.substring(1);
			if (map[name]) {
				return map[name](_, context, pair.id);
			}
		} else if (map.walk) {
			return map.walk(_, context, pair.name, pair.id);
		}
		throw context.badRequest(locale.format(module, "unexpectedSegment", seg));
	}
}

function _logRequest(_, context) {
	if (!context.request.headers["x-history-title"]) return;
	//
	var db = adminHelper.getCollaborationOrm(_);
	var h = db.model.getEntity(_, "navHistory").factory.createInstance(_, null, db);
	h.title(_, context.request.headers["x-history-title"]);
	h.agent(_, context.request.headers["x-history-agent"]);
	h.url(_, context.request.url);
	h.save(_);
}

function _doIt(_, context) {
	var protocol = context.walkUrl();
	if (protocol !== "print") throw new Error(locale.format(module, "badUrl", protocol));
	// fire and forget log call
	_logRequest(!_, context);
	_dispatch(_, context, _printMap);
}

exports.dispatcher = function(config) {
	return function(_, request, response) {
		var context = new Context(request, response, config);
		request.context = context;
		try {
			_doIt(_, context);
		} catch (e) {
			//console.error(e.stack);
			var headers = {
				"content-type": "application/json"
			};
			context.response.writeHead(500, headers);
			context.response.end(getErrorDiagnose(e));
		}
	};
};