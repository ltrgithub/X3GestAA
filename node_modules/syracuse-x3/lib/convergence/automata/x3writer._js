"use strict";
var helpers = require('syracuse-core/lib/helpers');
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var ActionDescriptors = require('syracuse-x3/lib/convergence/client/CvgAction').Descriptors;
var CvgIst = require('syracuse-x3/lib/convergence/types/CvgIst').CvgIst;


var traceProtocol = nodeconfig.config && nodeconfig.config.x3fusion && nodeconfig.config.x3fusion.protocol && nodeconfig.config.x3fusion.protocol.trace;


function sendAction(_, client, resu, extras, params) {

	// serialize resu
	var resuBuf = resu.getBytes();

	// serialize the number of extras on 1 byte + the extras
	var extrasLenBuf = new Buffer([extras.length]);
	var extrasBuf = Buffer.concat(extras.map(function(extra) {
		return extra.getBytes();
	}));

	// serialize the action on 2 bytes
	var act = params[0];
	traceProtocol && traceProtocol("Send Action: "+act);
	var actBuf = new Buffer([(act >> 8) & 0xff, act & 0xff]);

	//if (params.length > 2) params = params.slice(0, 2).concat([params.slice(2)]);
	var serialized = serializeActionParams(act, params.slice(1));
	var paramsBuf = serialized.buf;
	//console.log("PARAMS: " + paramsBuf.toString('hex'));
/*
		// slice to skip first act param.
		// convert the other parameters (optional ist from param.target + param.std) to string resus and serialize them
		var paramsBuf = Buffer.concat(params.slice(1).map(function(p, i) {
			return new CvgResu(CvgResuTdo["STRU"], p).getBytes();
		}));*/

	// serialize length (2 bytes for action + size of its params)
	var lenBuf = new Buffer(2);
	lenBuf.writeInt16BE(2 + serialized.stdLen, 0);

	// concatenate all the pieces and send it
	var data = Buffer.concat([resuBuf, extrasLenBuf, extrasBuf, lenBuf, actBuf, paramsBuf]);
	//console.log("SENDING: " + data.toString('hex'));
	client.stream.write(_, data);
}
	
var serializers = {
	I: function(val) {//instance
		if (!(val instanceof CvgIst)) throw new Error("action parameter type mismatch, expected IST, got " + val);
		return val.getBytes();
	},
	U: function(val) {//string
		if (typeof val !== 'string') throw new Error("action parameter type mismatch, expected string, got " + typeof val);
		var len = Buffer.byteLength(val, 'utf8');
		var buf = new Buffer(len + 4);
		buf.writeInt16BE(len + 2, 0);
		buf.writeInt16BE(val.length, 2);
		buf.write(val, 4, len, 'utf8');
		return buf;
	},
	V: function(val) {// cvgresu
		console.log("seral resu "+JSON.stringify(val,null,2));
		return Buffer.concat([val.getBytes()]);	
	},
	W: function(val, isExtend) {// table of cvgresu
		if (!Array.isArray(val)) throw new Error("action parameter type mismatch, expected array, got " + typeof val);
		var countBuf;
		if (isExtend){
			countBuf = new Buffer(2);
			countBuf.writeInt16BE(val.length, 0);
		} else {
			countBuf = new Buffer([val.length]);
		}
		var valsBuf = Buffer.concat(val.map(function(v) {
			return v.getBytes();
		}));
		//console.log("VALSBUF=" + valsBuf.toString('hex'));
		return Buffer.concat([countBuf, valsBuf]);
	},
	S: function(val) {// short
		if (typeof val !== 'number') throw new Error("action parameter type mismatch, expected number, got " + typeof val);
		return new Buffer([(val >> 8) & 0xff, val & 0xff]);
	},
	T: function(val, isExtend){ // table of short
		if (!Array.isArray(val)) throw new Error("action parameter type mismatch, expected array, got " + typeof val);
		var countBuf;
		if (isExtend){
			countBuf = new Buffer(2);
			countBuf.writeInt16BE(val.length, 0);
		} else {
			countBuf = new Buffer([val.length]);
		}
		var valsBuf = Buffer.concat(val.map(function(v) {
			return new Buffer([(v >> 8) & 0xff, v & 0xff]);
		}));
		return Buffer.concat([countBuf, valsBuf]);
	},
	B: function(val){ // Byte
		return new Buffer(val);
	},
	L: function(val) {//integer 
		if (typeof val !== 'number') throw new Error("action parameter type mismatch, expected number, got " + typeof val);
		return new Buffer([(val >> 24) & 0xff, (val >> 16) & 0xff, (val >> 8) & 0xff, val & 0xff]);
	},
}

function serializeActionParams(act, params) {

	function serialize(p,d, isExtend){
		return Buffer.concat(p.slice(0,d.length).map(function(param, i) {
			traceProtocol && traceProtocol("serializer "+d[i]+" param "+param);
			var fn = serializers[d[i]];
			if (!fn) throw new Error(desc.name + ": unknown serializer: " + d[i]);
			var res = fn(param, isExtend);
			return res;
		}));
	}

	var desc = ActionDescriptors[act] || {name: 'APPLICATIVE ACTION ' + act, params: ''};
	//console.log("ACTION=" + desc.name);
	traceProtocol && traceProtocol("Serialize params: "+JSON.stringify(params,null,2));
	
	var trueParamsLen = desc.params.length - (desc.params.split('x').length - 1);
	if (desc.params === '?') throw new Error("params serialization missing for " + desc.name + " (count got: "+params.length+")");
	if (trueParamsLen !== params.length) console.error("WARNING: " + desc.name + ": param count mismatch: expected " + trueParamsLen + ', got ' + params.length);
	var paramSplited = [];
	var std = null;
	if (desc.params.indexOf('x')!==-1){
		paramSplited = desc.params.split('x'); 
		std = paramSplited[0];
	}else{
		std = desc.params;
	}
	
	// serialize std param
	var buf = serialize(params.slice(0,std.length),std);
	if (paramSplited.length > 1) {
		// serialized extends 
		var offset = std.length;
		var allBuffExt = null;
		for (var i=1;i<paramSplited.length;i++) {
			var buffExt = null;
			for (var j in paramSplited[i]) {
				var b = serialize(params.slice(offset++,offset),paramSplited[i][j], true);
				buffExt ? buffExt = Buffer.concat([buffExt,b]): buffExt = b; // concat element of extends
				console.log("b "+JSON.stringify(b));
			}
			var len = buffExt.length ;
			buffExt = Buffer.concat([new Buffer([(len >> 24) & 0xff, (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff]),buffExt]);
			allBuffExt? allBuffExt = Buffer.concat([allBuffExt,buffExt]) : allBuffExt = buffExt;// concat all extends
		}
		// concat std buf with all extends 
		allBuffExt= Buffer.concat([buf,allBuffExt]);
		return {
			buf: allBuffExt,
			stdLen: buf.length
		}
	}else{
		return {
			buf: buf,
			stdLen: buf.length
		}
	}
}

exports.sendAction = sendAction;
