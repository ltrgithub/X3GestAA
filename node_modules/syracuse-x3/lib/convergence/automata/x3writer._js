"use strict";
var helpers = require('syracuse-core/lib/helpers');
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var ActionDescriptors = require('syracuse-x3/lib/convergence/client/CvgAction').Descriptors;
var CvgIst = require('syracuse-x3/lib/convergence/types/CvgIst').CvgIst;

var traceProtocol = nodeconfig.config && nodeconfig.config.x3fusion && nodeconfig.config.x3fusion.protocol && nodeconfig.config.x3fusion.protocol.trace;

function sendAction(_, client, resu, extras, params) {

	var t0 = new Date().getTime();
	// serialize resu
	var resuBuf = resu.getBytes();
	// serialize the number of extras on 1 byte + the extras
	var extrasLenBuf = new Buffer([extras.length]);
	var extrasBuf = Buffer.concat(extras.map(function(extra) {
		return extra.getBytes();
	}));

	// serialize the action on 2 bytes
	var act = params[0];
	traceProtocol && traceProtocol("Send Action: " + act);
	var actBuf = new Buffer([(act >> 8) & 0xff, act & 0xff]);

	//if (params.length > 2) params = params.slice(0, 2).concat([params.slice(2)]);
	var serialized = serializeActionParams(act, params.slice(1));
	var paramsBuf = serialized.buf;
	//console.log("PARAMS: " + paramsBuf.toString('hex'));
	/*
		// slice to skip first act param.
		// convert the other parameters (optional ist from param.target + param.std) to string resus and serialize them
		var paramsBuf = Buffer.concat(params.slice(1).map(function(p, i) {
			return new CvgResu(CvgResuTdo["STRU"], p).getBytes();
		}));*/

	// serialize length (2 bytes for action + size of its params)
	var lenBuf = new Buffer(2);
	lenBuf.writeInt16BE(2 + serialized.stdLen, 0);

	// concatenate all the pieces and send it
	var data = Buffer.concat([resuBuf, extrasLenBuf, extrasBuf, lenBuf, actBuf, paramsBuf]);
	//console.log("SENDING: " + data.toString('hex'));
	client.stream.write(_, data);

	var t1 = (new Date().getTime() - t0);
	client.activeRequest.timing.binary.write.push(t1);
}

var serializers = {
	I: function(val) { //instance
		if (!(val instanceof CvgIst)) throw new Error("action parameter type mismatch, expected IST, got " + val);
		return val.getBytes();
	},
	U: function(val) { //string
		if (typeof val !== 'string') throw new Error("action parameter type mismatch, expected string, got " + typeof val);
		var len = Buffer.byteLength(val, 'utf8');
		var buf = new Buffer(len + 4);
		buf.writeInt16BE(len + 2, 0);
		buf.writeInt16BE(val.length, 2);
		buf.write(val, 4, len, 'utf8');
		return buf;
	},
	V: function(val) { // cvgresu
		//console.log("seral resu "+JSON.stringify(val,null,2));
		return Buffer.concat([val.getBytes()]);
	},
	W: function(val, isExtend) { // table of cvgresu
		if (!Array.isArray(val)) throw new Error("action parameter type mismatch, expected array, got " + typeof val);
		var countBuf;
		if (isExtend) {
			countBuf = new Buffer(2);
			countBuf.writeInt16BE(val.length, 0);
		} else {
			countBuf = new Buffer([val.length]);
		}
		var valsBuf = Buffer.concat(val.map(function(v) {
			return v.getBytes();
		}));
		//console.log("VALSBUF=" + valsBuf.toString('hex'));
		return Buffer.concat([countBuf, valsBuf]);
	},
	Y: function(val, isExtend) { // table of cvgParam
		if (!Array.isArray(val)) throw new Error("action parameter type mismatch, expected array, got " + typeof val);
		var countBuf;
		if (isExtend) {
			countBuf = new Buffer(2);
			countBuf.writeInt16BE(val.length, 0);
		} else {
			countBuf = new Buffer([val.length]);
		}
		var valsBuf = Buffer.concat(val.map(function(v) {
			return Buffer.concat([serializers['S'](v.num), serializers['S'](v.poste), v.resu.getBytes()]);
		}));
		//console.log("VALSBUF=" + valsBuf.toString('hex'));
		return Buffer.concat([countBuf, valsBuf]);
	},

	S: function(val) { // short
		if (typeof val !== 'number') throw new Error("action parameter type mismatch, expected number, got " + typeof val);
		return new Buffer([(val >> 8) & 0xff, val & 0xff]);
	},
	T: function(val, isExtend) { // table of short
		if (!Array.isArray(val)) throw new Error("action parameter type mismatch, expected array, got " + typeof val);
		var countBuf;
		if (isExtend) {
			countBuf = new Buffer(2);
			countBuf.writeInt16BE(val.length, 0);
		} else {
			countBuf = new Buffer([val.length]);
		}
		var valsBuf = Buffer.concat(val.map(function(v) {
			return new Buffer([(v >> 8) & 0xff, v & 0xff]);
		}));
		return Buffer.concat([countBuf, valsBuf]);
	},
	B: function(val) { // Byte
		var buffer = new Buffer(1);
		if (typeof val !== 'number') throw new Error("action parameter type mismatch, expected byte, got " + typeof val);
		buffer.writeUInt8(val, 0);
		return buffer;
	},
	L: function(val) { //integer 
		if (typeof val !== 'number') throw new Error("action parameter type mismatch, expected number, got " + typeof val);
		return new Buffer([(val >> 24) & 0xff, (val >> 16) & 0xff, (val >> 8) & 0xff, val & 0xff]);
	},
};

function serializeActionParams(act, params) {

	function serialize(p, d, isExtend) {
		return Buffer.concat(p.slice(0, d.length).map(function(param, i) {
			traceProtocol && traceProtocol("serializer " + d[i] + " param " + param);
			var fn = serializers[d[i]];
			if (!fn) throw new Error(desc.name + ": unknown serializer: " + d[i]);
			var res = fn(param, isExtend);
			return res;
		}));
	}

	var desc = ActionDescriptors[act] || {
		name: 'APPLICATIVE ACTION ' + act,
		params: ''
	};
	//console.log("ACTION=" + desc.name);
	traceProtocol && traceProtocol("Serialize params: " + JSON.stringify(params, null, 2));

	var trueParamsLen = desc.params.length - (desc.params.split('x').length - 1);
	if (desc.params === '?') throw new Error("params serialization missing for " + desc.name + " (count got: " + params.length + ")");
	if (trueParamsLen !== params.length) console.error("WARNING: " + desc.name + ": param count mismatch: expected " + trueParamsLen + ', got ' + params.length);
	var paramSplited = [];
	var std = null;
	if (desc.params.indexOf('x') !== -1) {
		paramSplited = desc.params.split('x');
		std = paramSplited[0];
	} else {
		std = desc.params;
	}

	// serialize std param
	var buf = serialize(params.slice(0, std.length), std);
	if (paramSplited.length > 1) {
		// serialized extends 
		var offset = std.length;
		var allBuffExt = null;
		for (var i = 1; i < paramSplited.length; i++) {
			var buffExt = null;
			for (var j in paramSplited[i]) {
				var b = serialize(params.slice(offset++, offset), paramSplited[i][j], true);
				buffExt ? buffExt = Buffer.concat([buffExt, b]) : buffExt = b; // concat element of extends
				//console.log("b "+JSON.stringify(b));
			}
			var len = buffExt.length;
			buffExt = Buffer.concat([new Buffer([(len >> 24) & 0xff, (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff]), buffExt]);
			allBuffExt ? allBuffExt = Buffer.concat([allBuffExt, buffExt]) : allBuffExt = buffExt; // concat all extends
		}
		// concat std buf with all extends 
		allBuffExt = Buffer.concat([buf, allBuffExt]);
		return {
			buf: allBuffExt,
			stdLen: buf.length
		};
	} else {
		return {
			buf: buf,
			stdLen: buf.length
		};
	}
}

exports.writeProperties1 = function writeProperties1(_, client, props) {

	function buildProperties(props) {
		var propsArr = [];
		for (var i in props) {
			propsArr.push(i + '=\u0001' + props[i]);
		}
		var r = propsArr.join('\n');
		return r;
	}
	var propsStr = buildProperties(props);
	var buf;
	if (propsStr.length !== 0) {
		var bufLen = new Buffer(4);
		bufLen.writeInt32BE(propsStr.length, 0);
		buf = Buffer.concat([new Buffer([0]), bufLen, new Buffer(propsStr, "utf8")]);
	} else {
		buf = new Buffer([]);
	}
	var bufEnd = new Buffer(4);
	bufEnd.writeInt32BE(0, 0);
	client.stream.write(_, Buffer.concat([buf, new Buffer([0]), bufEnd]));
};

exports.sendAction = sendAction;