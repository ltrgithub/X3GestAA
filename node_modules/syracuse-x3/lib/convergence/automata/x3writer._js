"use strict";
var helpers = require('syracuse-core/lib/helpers');
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var ActionDescriptors = require('syracuse-x3/lib/convergence/client/CvgAction').Descriptors;
var CvgIst = require('syracuse-x3/lib/convergence/types/CvgIst').CvgIst;
var util = require('util');
var perfmon = require('syracuse-perfmon');

var traceProtocol = nodeconfig.config && nodeconfig.config.x3fusion && nodeconfig.config.x3fusion.protocol && nodeconfig.config.x3fusion.protocol.trace;
var perfmonEnabled = nodeconfig.config && nodeconfig.config.x3fusion && nodeconfig.config.x3fusion.perfmon;

function sendAction(_, client, resu, extras, params) {
	// serialize the action on 2 bytes
	var act = params[0];

	client.timing.action = client.timing.action || {};
	client.timing.action[act] = client.timing.action[act] || [];

	var timing = perfmonEnabled && perfmon.start(module, "x3writer.sendAction", act);

	// serialize resu
	var resuBuf = resu.getBytes();
	// serialize the number of extras on 1 byte + the extras
	var extrasLenBuf = new Buffer([extras.length]);
	var extrasBuf = Buffer.concat(extras.map(function(extra) {
		return extra.getBytes();
	}));

	client.tracer.trace(_, "protocol", "Send Action: " + act, traceProtocol);
	var actBuf = new Buffer([(act >> 8) & 0xff, act & 0xff]);

	//if (params.length > 2) params = params.slice(0, 2).concat([params.slice(2)]);
	var serialized = serializeActionParams(_, client, act, params.slice(1));
	var paramsBuf = serialized.buf;
	//console.log("PARAMS: " + paramsBuf.toString('hex'));
	/*
		// slice to skip first act param.
		// convert the other parameters (optional ist from param.target + param.std) to string resus and serialize them
		var paramsBuf = Buffer.concat(params.slice(1).map(function(p, i) {
			return new CvgResu(CvgResuTdo["STRU"], p).getBytes();
		}));*/

	// serialize length (2 bytes for action + size of its params)
	var lenBuf = new Buffer(2);
	lenBuf.writeInt16BE(2 + serialized.stdLen, 0);

	// concatenate all the pieces and send it
	var data = Buffer.concat([resuBuf, extrasLenBuf, extrasBuf, lenBuf, actBuf, paramsBuf]);
	//console.log("SENDING: " + data.toString('hex'));
	client.stream.write(_, data);

	if (perfmonEnabled) {
		timing.end();
		var t = timing.getTiming();
		t && client.timing.action[act].push({
			sendAction: (t && t.duration) || 0
		});
	}
}

var serializers = {
	I: function(val) { //instance
		if (!(val instanceof CvgIst)) throw new Error("action parameter type mismatch, expected IST, got " + val);
		return val.getBytes();
	},
	U: function(val) { //string
		if (typeof val !== 'string') throw new Error("action parameter type mismatch, expected string, got " + typeof val);
		var len = Buffer.byteLength(val, 'utf8');
		var buf = new Buffer(len + 4);
		buf.writeInt16BE(len + 2, 0);
		buf.writeInt16BE(val.length, 2);
		buf.write(val, 4, len, 'utf8');
		return buf;
	},
	V: function(val) { // cvgresu
		//console.log("seral resu "+JSON.stringify(val,null,2));
		return Buffer.concat([val.getBytes()]);
	},
	W: function(val, isExtend) { // table of cvgresu
		if (!Array.isArray(val)) throw new Error("action parameter type mismatch, expected array, got " + typeof val);
		var countBuf;
		if (isExtend) {
			countBuf = new Buffer(2);
			countBuf.writeInt16BE(val.length, 0);
		} else {
			countBuf = new Buffer([val.length]);
		}
		var valsBuf = Buffer.concat(val.map(function(v) {
			return v.getBytes();
		}));
		//console.log("VALSBUF=" + valsBuf.toString('hex'));
		return Buffer.concat([countBuf, valsBuf]);
	},
	Y: function(val, isExtend) { // table of cvgParam
		if (!Array.isArray(val)) throw new Error("action parameter type mismatch, expected array, got " + typeof val);
		var countBuf;
		if (isExtend) {
			countBuf = new Buffer(2);
			countBuf.writeInt16BE(val.length, 0);
		} else {
			countBuf = new Buffer([val.length]);
		}
		var valsBuf = Buffer.concat(val.map(function(v) {
			return Buffer.concat([serializers.S(v.num), serializers.S(v.poste), v.resu.getBytes()]);
		}));
		//console.log("VALSBUF=" + valsBuf.toString('hex'));
		return Buffer.concat([countBuf, valsBuf]);
	},

	S: function(val) { // short
		if (typeof val !== 'number') throw new Error("action parameter type mismatch, expected number, got " + typeof val);
		return new Buffer([(val >> 8) & 0xff, val & 0xff]);
	},
	T: function(val, isExtend) { // table of short
		if (!Array.isArray(val)) throw new Error("action parameter type mismatch, expected array, got " + typeof val);
		var countBuf;
		if (isExtend) {
			countBuf = new Buffer(2);
			countBuf.writeInt16BE(val.length, 0);
		} else {
			countBuf = new Buffer([val.length]);
		}
		var valsBuf = Buffer.concat(val.map(function(v) {
			return new Buffer([(v >> 8) & 0xff, v & 0xff]);
		}));
		return Buffer.concat([countBuf, valsBuf]);
	},
	B: function(val) { // Byte
		var buffer = new Buffer(1);
		if (typeof val !== 'number') throw new Error("action parameter type mismatch, expected byte, got " + typeof val);
		buffer.writeUInt8(val, 0);
		return buffer;
	},
	L: function(val) { //integer 
		if (typeof val !== 'number') throw new Error("action parameter type mismatch, expected number, got " + typeof val);
		return new Buffer([(val >> 24) & 0xff, (val >> 16) & 0xff, (val >> 8) & 0xff, val & 0xff]);
	},
};

function serializeActionParams(_, client, act, params) {

	function serialize(_, p, d, isExtend) {
		return Buffer.concat(p.slice(0, d.length).map_(_, function(_, param, i) {
			client.tracer.trace(_, "protocol", "\t- index: " + i + "\n\t- serializer: " + d[i] + "\n\t- param: " + util.inspect(param) + "\n\t- is extend: " + (isExtend === true) + "---\n", traceProtocol);
			var fn = serializers[d[i]];
			if (!fn) throw new Error(desc.name + ": unknown serializer: " + d[i]);
			var res = fn(param, isExtend);
			return res;
		}));
	}

	var desc = ActionDescriptors[act] || {
		name: 'APPLICATIVE ACTION ' + act,
		params: ''
	};
	//console.log("ACTION=" + desc.name);
	client.tracer.trace(_, "protocol", "Parameters to serialize: " + JSON.stringify(params, null, 2), traceProtocol);

	var trueParamsLen = desc.params.length - (desc.params.split('x').length - 1);
	if (desc.params === '?') throw new Error("params serialization missing for " + desc.name + " (count got: " + params.length + ")");
	if (trueParamsLen !== params.length) console.error("WARNING: " + desc.name + ": param count mismatch: expected " + trueParamsLen + ', got ' + params.length);
	var paramSplited = [];
	var std = null;
	if (desc.params.indexOf('x') !== -1) {
		paramSplited = desc.params.split('x');
		std = paramSplited[0];
	} else {
		std = desc.params;
	}

	client.tracer.trace(_, "protocol", "===\nSerialization detail\n===", traceProtocol);
	client.tracer.trace(_, "protocol", "\nProcess ALL standard params (nb=" + std.length + "; descr=" + std + ")", traceProtocol);
	// serialize std param
	var buf = serialize(_, params.slice(0, std.length), std);
	if (paramSplited.length > 1) {
		var _extendsDescr = paramSplited.slice(1);
		client.tracer.trace(_, "protocol", "\nProcess extends params one by one (nb=" + _extendsDescr.length + "; descr=" + _extendsDescr + ")", traceProtocol);
		// serialized extends 
		var offset = std.length;
		var allBuffExt = null;
		for (var i = 0; i < _extendsDescr.length; i++) {
			var buffExt = null;
			var _extendDescr = _extendsDescr[i];
			for (var j in _extendDescr) {
				client.tracer.trace(_, "protocol", "\nProcess extend param (descr=" + _extendDescr[j] + ")", traceProtocol);
				var b = serialize(_, params.slice(offset++, offset), _extendDescr[j], true);
				buffExt ? buffExt = Buffer.concat([buffExt, b]) : buffExt = b; // concat element of extends
				//console.log("b "+JSON.stringify(b));
			}
			var len = buffExt.length;
			buffExt = Buffer.concat([new Buffer([(len >> 24) & 0xff, (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff]), buffExt]);
			allBuffExt ? allBuffExt = Buffer.concat([allBuffExt, buffExt]) : allBuffExt = buffExt; // concat all extends
		}
		// concat std buf with all extends 
		allBuffExt = Buffer.concat([buf, allBuffExt]);
		return {
			buf: allBuffExt,
			stdLen: buf.length
		};
	} else {
		return {
			buf: buf,
			stdLen: buf.length
		};
	}
}
exports.props1Serializer = {
	"build": function(props, arrayOuput, maxProperty1Len) {
		var propsArr = [],
			maxLen, len, nbPack, j, prop, idPack, value;
		if (maxProperty1Len === null || maxProperty1Len === undefined) {
			maxProperty1Len = 250;
		}
		for (var i in props) {
			if (maxProperty1Len > 0) {
				prop = "" + props[i];
				len = prop.length;
				maxLen = maxProperty1Len - i.length - 2 - 5 - 1; /* -2 for "'=' a,d rankId", -5 for "header" (code + length) -1 for "PROPERTY_DELIMITER" */
				nbPack = len <= maxLen ? 1 : Math.ceil(len / maxLen);
				for (j = 0; j < nbPack; j++) {
					idPack = j == 9 ? 11 : j + 1;
					value = i + "=" + String.fromCharCode(idPack) + prop.substr(j * maxLen, maxLen) + "\n";
					propsArr.push(arrayOuput ? [value] : value);
				}
			} else {
				value = i + "=" + String.fromCharCode(1) + prop + "\n";
				propsArr.push(arrayOuput ? [value] : value);
			}
		}
		if (propsArr.length === 0 && arrayOuput) {
			propsArr.push([]);
		}
		return arrayOuput ? propsArr : propsArr.join('');
	},
	"write": function(_, client, props) {
		var buf, propsStr = exports.props1Serializer.build(props, false);
		if (propsStr.length !== 0) {
			var bufLen = new Buffer(4);
			bufLen.writeInt32BE(propsStr.length, 0);
			buf = Buffer.concat([new Buffer([0]), bufLen, new Buffer(propsStr, "utf8")]);
		} else {
			buf = new Buffer([]);
		}
		var bufEnd = new Buffer(4);
		bufEnd.writeInt32BE(0, 0);
		client.stream.write(_, Buffer.concat([buf, new Buffer([0]), bufEnd]));
	}
};

exports.sendAction = sendAction;