"use strict";
var helpers = require('@sage/syracuse-core').helpers;
var config = require('config');
var Actions = require('syracuse-x3/lib/convergence/client/CvgAction').Actions;

var CvgIst = require('syracuse-x3/lib/convergence/types/CvgIst').CvgIst;
var util = require('util');
var perfmon = require('../../../../../src/perfmon/record');

var tracerProtocol = require('@sage/syracuse-core').getTracer("classic.protocol");
var perfConfig = (config.x3fusion || {}).perfmon || {};
var perfmonEnabled = perfConfig.activate;
var currentprotocol = require("./x3Descriptors").CURRENTPROTOCOL;
var descriptors = require("./x3Descriptors");
var ACTIONS = {
	150067: new Actions().init(150067),
	150068: new Actions().init(150068),
	150069: new Actions().init(150069)
};

exports.X3Writer = helpers.defineClass(function(protocolVersion) {
	var self = this;
	this.protocolVersion = protocolVersion ? protocolVersion : currentprotocol;

	this.serializers = {
		I: function(val) { //instance
			if (!(val instanceof CvgIst)) throw new Error("action parameter type mismatch, expected IST, got " + val);
			var b = val.getBytes();
			return b;
		},
		n: function() {
			return new Buffer(0);
		},
		U: function(val) { //string
			if (typeof val !== 'string') throw new Error("action parameter type mismatch, expected string, got " + typeof val);
			var len = Buffer.byteLength(val, 'utf8');
			var buf = new Buffer(len + 4);
			buf.writeInt16BE(len + 2, 0);
			buf.writeInt16BE(val.length, 2);
			buf.write(val, 4, len, 'utf8');
			return buf;
		},
		V: function(val) { // cvgresu
			//console.log("seral resu "+JSON.stringify(val,null,2));
			return Buffer.concat([val.getBytes()]);
		},
		W: function(val, isExtend) { // table of cvgresu
			if (!Array.isArray(val)) throw new Error("action parameter type mismatch, expected array, got " + typeof val);
			var countBuf;
			if (isExtend) {
				countBuf = new Buffer(2);
				countBuf.writeInt16BE(val.length, 0);
			} else {
				countBuf = new Buffer([val.length]);
			}
			var valsBuf = Buffer.concat(val.map(function(v) {
				return v.getBytes();
			}));
			//console.log("VALSBUF=" + valsBuf.toString('hex'));
			return Buffer.concat([countBuf, valsBuf]);
		},
		Y: function(val, isExtend) { // table of cvgParam
			var countBuf = self.serializers.getCvgParamLenBuffer(val, isExtend);
			var valsBuf = self.serializers.getCvgParamValueBuffer(val);
			//console.log("VALSBUF=" + valsBuf.toString('hex'));
			var b = Buffer.concat([countBuf, valsBuf]);
			console.log(b);
			return b;
		},
		getCvgParamValueBuffer: function(val) {
			return Buffer.concat(val.map(function(v) {
				return Buffer.concat([self.serializers.S(v.num), self.serializers.S(v.poste), v.resu.getBytes()]);
			}));
		},
		getCvgParamLenBuffer2: function(val, isExtend) {
			if (!Array.isArray(val)) throw new Error("action parameter type mismatch, expected array, got " + typeof val);
			var countBuf;
			if (isExtend) {
				countBuf = new Buffer(4);
				countBuf.writeInt32BE(val.length, 0);
			} else {
				countBuf = new Buffer([val.length]);
			}
			return countBuf;
		},
		getCvgParamLenBuffer: function(val, isExtend) {
			if (!Array.isArray(val)) throw new Error("action parameter type mismatch, expected array, got " + typeof val);
			var countBuf;
			if (isExtend) {
				countBuf = new Buffer(4);
				countBuf.writeInt16BE(val.length, 0);
			} else {
				countBuf = new Buffer([val.length]);
			}
			return countBuf;
		},
		Z: function(val, isExtend) { // table of cvgParam
			var countBuf = self.serializers.getCvgParamLenBuffer2(val, isExtend);
			var valsBuf = self.serializers.getCvgParamValueBuffer(val);
			//console.log("VALSBUF=" + valsBuf.toString('hex'));
			return Buffer.concat([countBuf, valsBuf]);
		},

		M: function(val, isExtend) { // table of cvgParam
			if (!Array.isArray(val)) throw new Error("action parameter type mismatch, expected array, got " + typeof val);
			var countBuf;
			if (isExtend) {
				countBuf = new Buffer(4);
				countBuf.writeInt32BE(val.length, 0);
			} else {
				countBuf = new Buffer([val.length]);
			}
			var valsBuf = Buffer.concat(val.map(function(v) {
				return v.getBytes();
			}));
			//console.log("VALSBUF=" + valsBuf.toString('hex'));
			var b = Buffer.concat([countBuf, valsBuf]);
			return b;
		},
		S: function(val) { // short
			if (typeof val !== 'number') throw new Error("action parameter type mismatch, expected number, got " + (typeof val) + " value :'" + (val) + "'");
			return new Buffer([(val >> 8) & 0xff, val & 0xff]);
		},
		T: function(val, isExtend) { // table of short
			if (!Array.isArray(val)) throw new Error("action parameter type mismatch, expected array, got " + typeof val);
			var countBuf;
			if (isExtend) {
				countBuf = new Buffer(2);
				countBuf.writeInt16BE(val.length, 0);
			} else {
				countBuf = new Buffer([val.length]);
			}
			var valsBuf = Buffer.concat(val.map(function(v) {
				return new Buffer([(v >> 8) & 0xff, v & 0xff]);
			}));
			return Buffer.concat([countBuf, valsBuf]);
		},

		B: function(val) { // Byte
			var buffer = new Buffer(1);
			if (typeof val !== 'number') throw new Error("action parameter type mismatch, expected byte, got " + typeof val);
			buffer.writeUInt8(val, 0);
			return buffer;
		},
		L: function(val) { //integer 
			if (typeof val !== 'number') throw new Error("action parameter type mismatch, expected number, got " + typeof val);
			return new Buffer([(val >> 24) & 0xff, (val >> 16) & 0xff, (val >> 8) & 0xff, val & 0xff]);
		},
	};
	this.descriptors = ACTIONS[this.protocolVersion];
	this.props1Serializer = {
		"build": function(props, arrayOuput, maxProperty1Len) {
			var propsArr = [],
				maxLen, len, nbPack, j, prop, idPack, value;
			if (maxProperty1Len === null || maxProperty1Len === undefined) {
				maxProperty1Len = 250;
			}
			for (var i in props) {
				if (maxProperty1Len > 0) {
					prop = "" + props[i];
					len = prop.length;
					maxLen = maxProperty1Len - i.length - 2 - 5 - 1; /* -2 for "'=' a,d rankId", -5 for "header" (code + length) -1 for "PROPERTY_DELIMITER" */
					nbPack = len <= maxLen ? 1 : Math.ceil(len / maxLen);
					for (j = 0; j < nbPack; j++) {
						idPack = j == 9 ? 11 : j + 1;
						value = i + "=" + String.fromCharCode(idPack) + prop.substr(j * maxLen, maxLen) + "\n";
						propsArr.push(arrayOuput ? [value] : value);
					}
				} else {
					value = i + "=" + String.fromCharCode(1) + prop + "\n";
					propsArr.push(arrayOuput ? [value] : value);
				}
			}
			if (propsArr.length === 0 && arrayOuput) {
				propsArr.push([]);
			}
			return arrayOuput ? propsArr : propsArr.join('');
		},
		"write": function(_, client, props) {

			var buf, propsStr = self.props1Serializer.build(props, false);
			if (propsStr.length !== 0) {
				var bufLen = new Buffer(4);
				var propStrbyte = new Buffer(propsStr, "utf8");
				bufLen.writeInt32BE(propStrbyte.length, 0);
				buf = Buffer.concat([new Buffer([0]), bufLen, propStrbyte]);
			} else {
				buf = new Buffer([]);
			}
			var bufEnd = new Buffer(4);
			bufEnd.writeInt32BE(0, 0);
			var buffSend = Buffer.concat([buf, new Buffer([0]), bufEnd]);
			tracerProtocol.debug && tracerProtocol.debug("SENDING: " + buffSend.toString('hex'));
			client.write(_, buffSend);
		}
	};

}, null, {

	setProtocolVersion: function(protocolVersion) {
		this.protocolVersion = protocolVersion;
		this.descriptors = ACTIONS[protocolVersion];
	},
	sendAction: function(_, client, resu, extras, params) {
		// serialize the action on 2 bytes
		var act = params[0];

		if (perfConfig.clientRecord) {
			client.timing.action = client.timing.action || {};
			client.timing.action[act] = client.timing.action[act] || {};
			client.timing.action[act].x3runtime = client.timing.action[act].x3runtime || [];
		}
		var timing = perfmonEnabled && perfmon.start(module, "x3writer.sendAction", act);

		// serialize resu
		var resuBuf = resu.getBytes();
		// serialize the number of extras on 1 byte + the extras
		var extrasLenBuf = new Buffer([extras.length]);
		var extrasBuf = Buffer.concat(extras.map(function(extra) {
			return extra.getBytes();
		}));
		tracerProtocol.info && tracerProtocol.info("Send Action: " + act);
		var actBuf = new Buffer([(act >> 8) & 0xff, act & 0xff]);

		//if (params.length > 2) params = params.slice(0, 2).concat([params.slice(2)]);
		var serialized = this.serializeActionParams(_, client, act, params.slice(1));
		var paramsBuf = serialized.buf;
		/*
		 // slice to skip first act param.
		 // convert the other parameters (optional ist from param.target + param.std) to string resus and serialize them
		 var paramsBuf = Buffer.concat(params.slice(1).map(function(p, i) {
		 return new CvgResu(CvgResuTdo["STRU"], p).getBytes();
		 }));*/

		// serialize length (2 bytes for action + size of its params)
		var lenBuf = new Buffer(2);
		lenBuf.writeInt16BE(2 + serialized.stdLen, 0);

		// concatenate all the pieces and send it
		var data = Buffer.concat([resuBuf, extrasLenBuf, extrasBuf, lenBuf, actBuf, paramsBuf]);

		tracerProtocol.debug && tracerProtocol.debug("SENDING: " + data.toString('hex'));
		client.write(_, data);

		if (perfmonEnabled) {
			var t = timing.end();
			if (t && perfConfig.clientRecord) {
				client.timing.action[act].x3runtime.push({
					duration: t.duration || 0,
					action: "write"
				});
			}
		}
	},
	serializeActionParams: function(_, client, act, params) {
		var self = this;

		function serialize(_, p, d, isExtend) {
			return Buffer.concat(p.slice(0, d.length).map_(_, function(_, param, i) {
				tracerProtocol.info && tracerProtocol.info("\t- index: " + i + "\n\t- serializer: " + d[i] + "\n\t- param: " + util.inspect(param) + "\n\t- is extend: " + (isExtend === true) + "---\n");

				var fn = self.serializers[d[i]];
				if (!fn) throw new Error(desc.name + ": unknown serializer: " + d[i]);
				var res = fn(param, isExtend);
				return res;
			}));
		}

		var desc = this.descriptors.Descriptors[act] || {
			name: 'APPLICATIVE ACTION ' + act,
			params: ''
		};
		//console.log("ACTION=" + desc.name);
		tracerProtocol.info && tracerProtocol.info("Parameters to serialize: " + JSON.stringify(params, null, 2));

		var trueParamsLen = desc.params.length - (desc.params.split('x').length - 1);
		if (desc.params === '?') throw new Error("params serialization missing for " + desc.name + " (count got: " + params.length + ")");
		if (trueParamsLen !== params.length) console.error("WARNING: " + desc.name + ": param count mismatch: expected " + trueParamsLen + ', got ' + params.length);
		var paramSplited = [];
		var std = null;
		if (desc.params.indexOf('x') !== -1) {
			paramSplited = desc.params.split('x');
			std = paramSplited[0];
		} else {
			std = desc.params;
		}

		tracerProtocol.info && tracerProtocol.info("===\nSerialization detail\n===");
		tracerProtocol.info && tracerProtocol.info("\nProcess ALL standard params (nb=" + std.length + "; descr=" + std + ")");
		// serialize std param
		var buf = serialize(_, params.slice(0, std.length), std);
		if (paramSplited.length > 1) {
			var _extendsDescr = paramSplited.slice(1);
			tracerProtocol.info && tracerProtocol.info("\nProcess extends params one by one (nb=" + _extendsDescr.length + "; descr=" + JSON.stringify(_extendsDescr, null, 2) + ")");
			// serialized extends 
			var offset = std.length;
			var allBuffExt = null;
			for (var i = 0; i < _extendsDescr.length; i++) {
				var buffExt = null;
				var _extendDescr = _extendsDescr[i];
				for (var j = 0; j < _extendDescr.length; j++) { // APS - SAM 101838 don't browser method of the object string , only value
					tracerProtocol.info && tracerProtocol.info("\nProcess extend param (descr=" + _extendDescr[j] + ")");
					var b = serialize(_, params.slice(offset, offset + 1), _extendDescr[j], true);
					offset++;
					buffExt ? buffExt = Buffer.concat([buffExt, b]) : buffExt = b; // concat element of extends
					//console.log("b "+JSON.stringify(b));
				}
				var len = buffExt.length;
				buffExt = Buffer.concat([new Buffer([(len >> 24) & 0xff, (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff]), buffExt]);
				allBuffExt ? allBuffExt = Buffer.concat([allBuffExt, buffExt]) : allBuffExt = buffExt; // concat all extends
			}
			// concat std buf with all extends 
			allBuffExt = Buffer.concat([buf, allBuffExt]);
			return {
				buf: allBuffExt,
				stdLen: buf.length
			};
		} else {
			return {
				buf: buf,
				stdLen: buf.length
			};
		}
	}


});