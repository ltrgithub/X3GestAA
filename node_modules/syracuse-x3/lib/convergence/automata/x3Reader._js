"use strict";
var helpers = require('syracuse-core/lib/helpers');
var CvgIst = require('syracuse-x3/lib/convergence/types/CvgIst').CvgIst;
var CvgResu = require('syracuse-x3/lib/convergence/types/CvgResu').CvgResu;
var CvgResuTdo = require('syracuse-x3/lib/convergence/types/CvgResu').TDO;
var CvgResuTag = require('syracuse-x3/lib/convergence/types/CvgResu').TAG;
var CvgDecimal = require('syracuse-x3/lib/convergence/types/CvgDecimal').CvgDecimal;
var CvgDate = require('syracuse-x3/lib/convergence/types/CvgDate').CvgDate;

var specialProperties2 = [
	"+X3IMP",
	"_FormatExport",
	"_PreVisuOptions",
	"__REPORT",
	"__DESTINATION",
	"__APPLICATION",
	"__APPRPT",
	"__DBSERVER",
	"__DBDATABASE",
	"__DBUSER",
	"__DBPASSWORD",
	"__TYPDBA",
	"__DOCUMENT",
	"__RPTLAN",
	"__CDUSER",
	"__WSTATION",
	"__LOCALRPT",
	"__ADXSOL",
	"__JOBLINKED",
	"__wJobID"
];

var X3Reader = exports.X3Reader = helpers.defineClass(function(client, wnd, data) {
	this.client = client;
	this.wnd = wnd;
	this.pos = 0;
	this.data = data;
}, null, {
	peek: function() {
		return this.pos < this.data.length ? this.data[this.pos] : -1;
	},
	nextByte: function(lenient) {
		if (!lenient && this.pos > this.data.length - 1) throw new Error("nextByte");
		return this.pos < this.data.length ? this.data[this.pos++] : 0;
	},
	nextShort: function() {
		if (this.pos > this.data.length - 2) throw new Error("nextShort");
		var short = this.pos < this.data.length - 1 ? (this.data[this.pos++] << 8) | this.data[this.pos++] : 0;
		return short;
	},
	nextSignedShort: function() {
		if (this.pos > this.data.length - 2) throw new Error("nextSignedShort");
		return this.pos < this.data.length - 1 ? (((this.data[this.pos++] << 8) | this.data[this.pos++]) << 16) >> 16 : 0;
	},
	nextLong: function() {
		if (this.pos > this.data.length - 4) throw new Error("nextLong");
		return this.pos < this.data.length - 3 ? (this.data[this.pos++] << 24) | (this.data[this.pos++] << 16) | //
		(this.data[this.pos++] << 8) | this.data[this.pos++] : 0;
	},
	peekShort: function() {
		var pos = this.pos,
			val = this.nextShort();
		this.pos = pos;
		return val;
	},
	peekLong: function() {
		var pos = this.pos,
			val = this.nextLong();
		this.pos = pos;
		return val;
	},
	nextLongLong: function() {
		return this.pos < this.data.length - 7 ? (this.nextLong() << 32) | this.nextLong() : 0;
	},
	nextIst: function() {
		return this.pos < this.data.length - 5 ? new CvgIst(this.nextLong(), this.nextSignedShort()) : null;
	},
	nextString: function(_) {
		var len = this.nextShort();
		var nchars = this.nextShort();
		len -= 2; // nchars short was included in byte count!
		var str = this.data.slice(this.pos, this.pos + len).toString('utf8');
		this.pos += len;
		if (str.length < nchars) throw new Error("bad string: expected " + nchars + ", got " + str.length);
		if (str.length > nchars) {
			console.log("!!!! string too long: " + (str.length - nchars) + " extra, ignoring: '" + str.substring(nchars) + "'");
			str = str.substring(0, nchars);
		}
		return str;
	},
	nextStringUcs2: function() {
		var len = this.data.length - this.pos;
		var str = this.data.slice(this.pos, this.data.length).toString('utf8');
		this.pos += len;
		return len !== 0 ? str : '';
	},
	nextBuf: function(_) {
		var len = this.nextShort();
		//console.log("nextBuf len=" + len + ", pos=" + this.pos + ", data.len=" + this.data.length);
		//console.log(this.data.slice(this.pos));
		var buf = this.data.slice(this.pos, this.pos + len);
		this.pos += len;
		return buf;
	},
	nextLine: function() {
		if (this.pos !== 0) throw new Error("invalid call: pos=" + this.pos);
		var str = this.data.toString('utf8');
		this.pos = this.data.length;
		return str;
	},
	nextProperties: function(map, isProperties2) {
		this.pos = this.data.length;

		function storeProperty() {
			var valueBuf = new Buffer(value);
			var valueStr = valueBuf.toString('utf8');
			map[keyStr] = map[keyStr] || [];
			map[keyStr][idx - 1] = valueStr;
		}

		function checkIdx(char) {
			try {
				idx = parseInt(char, 10);
				nextIsIdx = true;
			} catch (e) {
				idx = 0;
			}
		}

		var idx;
		var keyStr, keyBuf, key = [];
		var value = [];
		var applyOn = "key";
		var nextIsIdx = false;
		for (var i = 0; i < this.data.length; i++) {
			var charCode = this.data[i];
			//console.log("CharAt["+i+"]:["+charCode+"] "+String.fromCharCode(charCode).toString());
			if (!nextIsIdx) {
				// =
				if (this.data[i] === 61 && applyOn === "key") {
					keyBuf = new Buffer(key);
					keyStr = keyBuf.toString('utf8');
					applyOn = "value";

					if (specialProperties2.indexOf(keyStr) === -1) {
						checkIdx(this.data[i + 1]);
					} else {
						if (this.data[i + 1] === 1) {
							checkIdx(this.data[i + 1]);
						} else {
							idx = 1;
						}
					}
				}
				// \n
				else if (!isProperties2 && this.data[i] === 10) {
					applyOn = "key";
					storeProperty();
					key = [];
					value = [];
				} else {
					if (applyOn === "key") key.push(this.data[i]);
					else if (applyOn === "value") {
						value.push(this.data[i]);
					}
				}
			} else {
				nextIsIdx = false;
			}
		}
		if (isProperties2 && idx && idx > 0) {
			storeProperty();
		}
		return map;
	},
	nextLines: function() {
		var str = this.nextLine();
		if (str[str.length - 1] !== '\n') throw new Error("missing newline");
		return str.substring(0, str.length - 1).split('\n');
	},
	nextExtend: function(_) {
		this.ensure(_, 4);
		var len = this.nextLong();
		this.ensure(_, len);
		var data = this.data.slice(this.pos, this.pos + len);
		return data;
	},
	nextDefs: function(_) {
		var buf = this.nextBuf(_);
		//console.log("DEFS: " + buf.toString("hex"));
		var sub = new X3Reader(this.client, this.wnd, buf);
		var n = sub.nextByte();
		var defs = [];
		for (var i = 0; i < n; i++) defs.push(sub.nextResu(_));
		return defs;
	},
	nextBytes: function(len) {
		if (this.pos + len > this.data.length) throw new Error("read too long: requested=" + len + ", available=" + (this.data.length - this.pos));
		var buf = this.data.slice(this.pos, this.pos + len);
		this.pos += len;
		return buf;
	},
	nextUnicode: function(_, len) {
		//console.log("len=" + len)
		// read trailing 0 (and ignore it)
		var needed = 2 * (len + 1);
		var bytes = this.nextBytes(needed);
		var s = "";
		for (var i = 0; i < len; i++) s += String.fromCharCode((bytes[2 * i] << 8) | bytes[2 * i + 1]);
		return s;
	},
	nextResu: function(_) {
		var tag = this.nextByte();
		var len = this.nextByte();
		switch (tag) {
			case CvgResuTag.NULL:
				return new CvgResu(CvgResuTdo.NULL, null);
			case CvgResuTag.LIB:
				throw new Error("Resu LIB not yet implemented !");
			case CvgResuTag.SHORT:
				return new CvgResu(CvgResuTdo.SHORT, this.nextShort());
			case CvgResuTag.INT:
				return new CvgResu(CvgResuTdo.INT, this.nextLong());
			case CvgResuTag.DCB:
				if (len !== 17) throw new Error("bad bcd len: " + len);
				return new CvgResu(CvgResuTdo.DCB, this.nextBcd());
			case CvgResuTag.STRU:
				return new CvgResu(CvgResuTdo.STRU, this.nextUnicode(_, len));
			case CvgResuTag.DATE:
				if (len !== 3) throw new Error("bad date len: " + len);
				return new CvgResu(CvgResuTdo.DATE, this.nextDate());
			case CvgResuTag.BLOB:
				return new CvgResu(CvgResuTdo.BLOB, this.nextBlob(_));
			case CvgResuTag.CLOB:
				return new CvgResu(CvgResuTdo.CLOB, this.nextClob(_));
			default:
				throw new Error("bad resu tag: " + tag + " (" + String.fromCharCode(tag) + ")");
		}
	},
	nextResuTable: function(_, deserialize) {
		var len = 0;
		if (deserialize) {
			len = this.nextByte();
		} else {
			len = this.nextShort();
		}
		var tbl = [];
		for (var i = 0; i < len; i++) {
			tbl.push(this.nextResu(_));
		}
		return tbl;
	},
	nextShortTable: function() {
		var len = this.nextShort();
		var tbl = [];
		for (var i = 0; i < len; i++) {
			tbl.push(this.nextShort());
		}
		return tbl;
	},
	nextStruct: function(_) {
		var len = this.nextShort();
		var tbl = [];
		for (var i = 0; i < len; i++) {
			var num = this.nextShort();
			var poste = this.nextShort();
			var resu = this.nextResu(_);
			var struct = {
				num: num,
				poste: poste,
				resu: resu
			};
			tbl.push(struct);
		}
		return tbl;
	},
	nextDate: function() {
		var days = (this.nextShort() << 8) + this.nextByte();
		return CvgDate.fromDays(days);
	},
	nextBcd: function() {
		var str = CvgDecimal.fromBytes(this.data, this.pos);
		this.pos += 17;
		return str;
	},
	nextBlob: function(_) {
		var len = this.nextLong();
		return this.nextBytes(len);
	},
	nextClob: function(_) {
		return this.nextBlob(_).toString('utf8');
	},
	// Must be used only for read extends
	ensure: function(_, len) {
		var missing = this.pos + len - this.data.length;
		if (missing > 0) this.data = Buffer.concat([this.data, this.client.read(_, missing, true)]);
	},
});