"use strict";
require('buffer').INSPECT_MAX_BYTES = 2048;
Buffer.prototype.toJSON = function() {
	return this.toString('hex');
};
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var X3Reader = require('syracuse-x3/lib/convergence/automata/x3Reader').X3Reader;
var perfmon = require('syracuse-perfmon');

var trace = nodeconfig.config && nodeconfig.config.x3fusion && nodeconfig.config.x3fusion.protocol && nodeconfig.config.x3fusion.protocol.trace;

var perfmonEnabled = nodeconfig.config && nodeconfig.config.x3fusion && nodeconfig.config.x3fusion.perfmon && nodeconfig.config.x3fusion.perfmon.activate;
var perfmonDetail = nodeconfig.config && nodeconfig.config.x3fusion && nodeconfig.config.x3fusion.perfmon && nodeconfig.config.x3fusion.perfmon.detail;

// !: error
// F: call function
// B: read byte
// S: read short
// L: read long
// U: read UTF8
// N: read UCS2
// I: read ist (long + short)
// A: short + buf
// V: resu
// W: resu table
// T: short table
// Q: special var array of ints
// X: structure (short + short + resu) --> modified parameters table
// x: extends
// D: defs
// l: write long
// digit: repeat N times
var DESCS = [
	[0, "ND_RCN", null],
	[1, "ND_GFD", "[pF[U"],
	[2, "ND_SLF", "[PF[U"],
	[14, "NDEXT", null],
	[17, "ND_CMVD", null],
	[18, "NDIMPR", null],
	[19, "NDOPEN", null],
	[20, "ND_CLF", "IF"], // I is nxtist (LS)
	[21, "ND_CLT", "BF"],
	[22, "ND_INP", null],
	[23, "ND_CRD", "F2l"],
	[25, "NDCSTL", "IUF"],
	[26, "NDCHCR", "IBF"],
	[27, "NDCHTIT", "!"],
	[28, "NDACTOBJ", "IBFB"],
	[31, "NDCOPMENU", "AF"],
	[32, "NDOUVIMP", "{PFBB"],
	[33, "ND_IMF", "BF"],
	[38, "ND_INT", "FB"],
	[42, "ND_ASKUI", "[PF"], // BRJOU: was ND_ASKUI
	[43, "NDSYSTEM", "FB"],
	[45, "NDAFRE", "UF"],

	[49, "NDACV", "LSSUBBF"],

	[56, "NDDEB", ""], // read function was null
	[57, "NDOFENB", "SSSSBSF"],
	[58, "NDOFENH", "UF"],
	[59, "NDOFENA", "SSSSBSF"],
	[60, "NDOFENP", "SSSSBSF"],
	[61, "NDOBOXE", "BBUUBF"],
	[62, "NDOBOXW", "BBUUBF"],
	[63, "NDOBOXQ", "BBUUBF"],
	[64, "NDOBOXS", "SSSSBSF"],
	[65, "NDOBOXI", "BBUUBF"],
	[66, "NDOBOUT", "LUSSUUF"],
	[67, "NDOMNBO", "LSLBSUSF"],
	[68, "NDOMENC", "LF"],
	[69, "NDOMENB", "LF"],
	[70, "NDOMENA", "UF"],

	[73, "NDOTXSC", "IBsUUSF"],

	[80, "NDCREUX", "LSSCCUF"],

	[84, "NDODIAG", "SSSSBSF"], /*  Ouverture Dialogue	*/
	[85, "NDODGSB", "SSSSBSF"], /*  Ouv. Dialogue ss Bt	*/
	[87, "NDOWIN", "IUUUxNF"], /*  Ouverture Fenetre	*/

	[90, "ND_IMG", "UVF"], /*  Affichage Image	*/
	[91, "ND_RAT", "LLSSF2c"], /*  Rattachement	*/

	[94, "ND_EVT", "UCSF"], /*  Evenement/Instance	*/
	[95, "NDOCSX", "LSSBUF"], /*  Ouv. Case a Cocher	*/
	[96, "NDOGRD", "LSSBBF"], /*  Ouv. Groupe Radio	*/
	[97, "NDOBRD", "LBUF"], /*  Ouv. Bouton Radio	*/
	[98, "NDOTBL", "LSS5BBBBUF"], /*  Ouv. Tableau	*/
	[99, "NDOCTB", "LLBSBUF"], /*  Ouv. Colonne Tbl.	*/
	[100, "NDOCMB", "LSSBSF"], /*  Ouverture Combo	*/
	[101, "NDOFRM", "LSSBF"], /*  Ouverture Frame	*/
	[105, "NDOBOG", "LSSBF"], /*  Ouv. Boite a Onglets*/
	[106, "NDOONG", "LUUF"], /*  Ouv. Onglets	*/
	[107, "NDTBLK", "UUF"], /*  Titre des Blocs	*/
	[108, "NDOBPG", "LSSBF"], /*  Barre Progression	*/
	[109, "NDOIMG", "LSSBF"], /*  Cadre Image		*/
	[110, "NDFIMG", "BLBUF"], /*  Image de Fond	*/
	[111, "NDIHLP", "UUF"], /*  Aide d'un Objet	*/
	[112, "NDITTP", "UUF"], /*  ToolTip d'un Objet	*/
	[113, "NDCHVB", "IxVF"], /*  Modif Valeur Bin	*/
	[114, "NDCHVL", "IVF"], /*  Modif. Val. Zone	*/
	[115, "NDGIST", "IF"], /*  Allez a Une Zone	*/
	[116, "NDMIST", "IF"], /*  Allez au Menu Zone	*/
	[118, "NDSUPLI", "ISSF"], /*  Suppression Lignes	*/
	[119, "NDINSLI", "ISSF"], /*  Insertion Lignes	*/
	[120, "NDSATAN", "IF"], /*  Saisie Bas de Page	*/
	[121, "NDOLST", "LSSBF"], /*  Ouverture Liste	*/
	[122, "NDOCLS", "IBAF"], /*  Creation Col. Liste	*/
	[123, "NDOLLS", "ILLAF"], /*  Creat. Ligne Liste	*/

	[125, "NDACTOP", "LBF"], /*  Activation Option	*/
	[126, "NDOJLB", "LBUF"], /*  Creat Jeu Libelle	*/
	[127, "NDAJLB", "LBUF"], /*  Alim Jeu Libelles	*/
	[128, "NDCHFM", "IUF"], /*  Format d'une Zone	*/
	[132, "NDOMNAO", "LSLBSUSF"], /*  Option Menu Appli	*/
	[133, "NDGLLS", "IAF"], /*  Allez a Lg Liste	*/
	[134, "NDOPFN", "LSSBF"], /*  Creat. Part. Fen.	*/
	[136, "NDDTOB", "LBF"], /*  Destruction d'Objet	*/
	[137, "NDCTSU", "BUUF"], /*  Creation Type Prg	*/
	[138, "ND_DCL", "IF"], /*  Debut Chgt Liste	*/
	[139, "ND_FCL", "IF"], /*  Fin Chrgt Liste	*/
	[140, "ND_ICL", "IFB"], /*  Inter Chgt Liste	*/
	[141, "NDOMNCO", "BSUSUF"], /*  Option Menu Surg.	*/
	[142, "NDAFTB", "IBSF"], /*  Disable un Tableau	*/
	[143, "NDCHGR", "IBF"], /*  Actzo/Grizo/Diszo	*/
	[144, "NDRZLS", "IF"], /*  Effacement Liste	*/

	[147, "NDINED", "BUF"], /*  Saisie Editeur	*/
	[149, "NDOARB", "LSSBF"], /*  Ouverture Arbre	*/
	[150, "NDOCAR", "IBDF"], /*  Creation Col. Arbre	*/
	[151, "NDOLAR", "ISBUDDDF"], /*  Creat. Ligne Arbre	*/
	[152, "ND_NAP", "UF"], /*  Nouvelle Session	*/
	[153, "NDGLAR", "IDF"], /*  Allez a Lg Arbre	*/
	[154, "NDRZAR", "IF"], /*  Effacement Arbre	*/
	[155, "ND_DCA", "UF"], /*  Debut Chgt Arbre	*/
	[156, "ND_FCA", "UF"], /*  Fin Chrgt Arbre	*/
	[157, "ND_REB", "UUUUUUUUUUUUUUUUUF"], /*  Reboot Serveur	*/
	[158, "NDOMSG", "!!!FBB"], /* ????  Ouvre Messagerie	*/
	[159, "NDEDBK", "QFBB"], /*  Editeur de Blocs	*/
	[160, "NDULLS", "IAF"], /*  Desel Ligne Liste	*/
	[161, "NDULAR", "IDF"], /*  Desel Ligne Arbre	*/
	[162, "NDPKLS", "IF"], /*  Picking		*/
	[163, "NDPKAR", "IF"], /*  Picking Hierarchise	*/
	[164, "NDGTDT", "[pFBBBBB"], /*  Destinataires	*/
	[165, "NDGTIM", "[PF"], /*  Imprimantes		*/
	[166, "NDCHLP", "ISSUF"], /*  Aide d'un Objet	*/
	[167, "NDCTTP", "ISSUF"], /*  ToolTip d'un Objet	*/
	[168, "NDCTIT", "IUF"], /*  Titre d'un Objet	*/
	[169, "ND_OCX", "[pFBBBBB"], /*  Interface avec OCX	*/
	[170, "NDOFML", "UF"], /*  Ouverture Formule	*/
	[171, "NDOFLD", "IUUUSUUF"], /*  Ouverture Champs	*/
	[172, "NDDSLB", "IBF"], /*  Desactiv Libelle	*/
	[173, "ND_IHM", "F"], /*  Interface avec IHM	*/
	[174, "NDDTLB", "!"], /*  Desactiv Libelle	*/
	[175, "ND_LIM", "F"], /*  Interface avec LIM	*/
	[176, "NDRESULT", "ISSUBUxVxXxWF"], /* AckCall result */
	[177, "NDEXECI", "IULxTxW"],
]; /* FuncIu request */

var NODES = [];
var MAP = {};
var ACTION_ENDING = ['NDGIST', 'NDOBOXI', 'NDEXECI', 'ND_ASKUI', 'NDGTIM', 'ND_LIM'];

DESCS.forEach(function(node) {
	var pat = node[2] || "";
	var params = pat.split('F')[0];
	var acks = pat.split('F')[1] || "";
	var properties = params.split('[')[1] || "";
	params = params.split('[')[0];
	var properties2 = params.split('{')[1] || "";
	params = params.split('{')[0];
	var n = {
		id: node[0],
		name: node[1],
		params: params,
		properties: properties,
		properties2: properties2,
		acks: acks,
		def: 0,
		skipHandler: (node[2] == null),
	};
	NODES[node[0]] = n;
	MAP[node[1]] = n;
});

NODES.forEach(function(node) {
	node.def = NODES[0];
});
MAP.ND_CLT.def = null;
//MAP.NDOWIN.def = null; -- not needed any more
MAP.ND_REB.def = null;

function resolve(v) {
	if (v === 0) return;
	else if (!MAP[v]) throw new Error("bad key: " + v);
	return MAP[v];
}

MAP.ND_RCN.transitions = [ //
	"ND_RCN", 0, 0, 0, 0, 0, 0, 0, //
	0, 0, 0, 0, 0, 0, "NDEXT", 0, //
	0, "ND_CMVD", "NDIMPR", "ND_INP" //
].map(resolve);

MAP.NDEXT.transitions = [ //
	0, "NDOPEN", "ND_RAT", "ND_EVT", "NDTBLK", 0, 0, 0, //
	0, 0, "NDSUPLI", "NDINSLI", "NDSATAN", 0, 0, 0, //
	0, 0, 0, 0, "ND_CLF", "ND_CLT", "NDDTOB", 0, //
	0, "ND_REB", "ND_NAP", 0, 0, 0, "NDGIST", "NDCHGR", //
	"NDMIST", 0, "NDCTSU", 0, "ND_DCL", "ND_FCL", "NDAFTB", "NDRZLS", //
	"NDGLLS", "NDULLS", 0, 0, 0, "NDRZAR", "NDGLAR", "ND_DCA", //
	"ND_FCA", "NDULAR", "NDCHTIT", "NDCTIT", "NDCSTL", 0, 0, 0, //
	0, 0, 0, 0, "NDACTOBJ", 0, 0, "NDFIMG", //
	"NDACTOP", 0, "NDAJLB", "NDCHFM", "NDDSLB", 0, 0, "NDCOPMENU", //
	"NDIHLP", "NDITTP", "NDCHLP", "NDCTTP" //
].map(resolve);

MAP.ND_CMVD.transitions = [ //
	0, 0, 0, 0, 0, "ND_INT", 0, 0, //
	0, 0, "NDSYSTEM", "NDEXECI", 0, 0, 0, 0, //
	"ND_ICL", "ND_CRD", "NDINED", "NDEDBK", 0, "NDAFRE", 0, "NDPKLS", "NDPKAR", //
	0, 0, 0, 0, 0, 0, 0, 0, //
	0, 0, 0, 0, 0, 0, 0, 0, //
	0, 0, 0, 0, 0, 0, 0, 0, //
	0, 0, 0, 0, 0, 0, 0, 0, //
	0, 0, 0, 0, 0, 0, 0, 0, //
	0, 0, "NDCHCR", 0, 0, "NDCHVL", "NDCHVB" //
].map(resolve);

MAP.NDOPEN.transitions = [ //
	0, "NDDEB", "NDOFENB", "NDOFENH", "NDOFENA", "NDOFENP", "NDODIAG", "NDODGSB", //
	"NDOBOXI", 0, "NDOBOXE", "NDOBOXW", "NDOBOXQ", "NDOBOXS", "NDOBOXI", 0, //
	0, 0, 0, 0, "NDOBOUT", "NDOTBL", "NDOCTB", "NDOGRD", //
	"NDOBRD", "NDOCMB", "NDOFRM", "NDOBOG", "NDOONG", "NDOCSX", "NDCREUX", "NDOBPG", //
	"NDOIMG", "NDOLST", "NDOCLS", "NDOLLS", "NDOJLB", "NDOPFN", 0, "NDOFML", //
	"NDOFLD", "NDOARB", "NDOCAR", "NDOLAR", 0, 0, 0, 0, //
	0, 0, 0, 0, 0, 0, 0, 0, //
	0, 0, 0, 0, 0, 0, 0, 0, //
	0, 0, 0, 0, 0, 0, 0, "NDOTXSC", //
	0, 0, 0, 0, 0, 0, 0, 0, //
	0, "NDACV", 0, 0, 0, 0, 0, "NDOWIN", //
	0, 0, 0, 0, 0, 0, "NDOMNCO", "NDOMENC", //
	"NDOMNAO", "NDOMNBO", "NDOMENA", "NDOMENB" //
].map(resolve);

MAP.NDIMPR.transitions = [ //
	0, "NDOUVIMP", "ND_IMF", 0, 0, "NDOMSG", "NDGTDT", "NDGTIM", //
	"ND_OCX", "ND_IHM", "ND_LIM", "ND_GFD", "ND_SLF", "ND_ASKUI" //
].map(resolve);

MAP.ND_INP.transitions = [ //
	0, "NDRESULT" //
].map(resolve);

// nodes that exit the loop
MAP.NDGIST.waitUser = true; // GotoInstance
MAP.NDSATAN.waitUser = true; // Goto_GridCommande
MAP.NDOBOXI.waitUser = true; // MessageBox_Create
MAP.ND_ASKUI.waitUser = true; // AskUi
MAP.NDEXECI.waitUser = true; // CallIU
MAP.ND_REB.waitUser = true; // 
MAP.ND_CLT.waitUser = true; // End of session
//MAP.NDINED.waitUser = true; // Window_ModeEditorL4GOn : NDINED replied automatically because not supported in convergence
MAP.NDEDBK.waitUser = true; // 
MAP.NDGTIM.waitUser = true; // SelImp

function readVal(_, reader, letter, isExtend) {
	switch (letter) {
		case 'B':
			return reader.nextByte();
		case 's':
			return reader.nextSignedShort();
		case 'S':
			return reader.nextShort();
		case 'L':
			return reader.nextLong();
		case 'U':
			return reader.nextString(_);
		case 'T':
			return reader.nextShortTable();
		case 'N':
			// TODO Check real length
			return reader.nextStringUcs2();
		case 'I':
			return reader.nextIst();
		case 'A':
			return reader.nextBuf(_);
		case 'x':
			return reader.nextExtend(_);
		case 'D':
			return reader.nextDefs(_);
		case 'V':
			return reader.nextResu(_);
		case 'W':
			return reader.nextResuTable(_, isExtend);
		case 'X':
			return reader.nextStruct(_);
		default:
			throw new Error("bad arg char: " + letter);

	}
}

function readPropertiesVal(_, reader, letter, map, isProperties2) {
	switch (letter) {
		case 'p':
			return reader.nextLines();
		case 'P':
			return reader.nextProperties(map, isProperties2);
		default:
			throw new Error("bad list char: " + letter);

	}
}

function readProperties1(_, client, letter) {
	var map = {};
	while (true) {
		var head = client.read(_, 5, true);
		var len = head.readInt32BE(1);
		if (len < 0) throw new Error("bad property1 len: " + len);
		if (len === 0) {
			for (var i in map) {
				if (map[i] && Array.isArray(map[i])) map[i] = map[i].join('');
			}
			//console.log("Properties1: "+JSON.stringify(map,null,2));
			return map;
		}
		var reader = new X3Reader(client, head[0], client.read(_, len, true));
		map = readPropertiesVal(_, reader, letter, map);
	}
}

function readProperties2(_, client, letter) {
	var map = {};
	while (true) {
		var len = client.read(_, 1, true).readInt8(0);
		if (len < 0) throw new Error("bad property2 len: " + len);
		if (len === 0) {
			client.read(_, 4, true);
			for (var i in map) {
				if (map[i] && Array.isArray(map[i])) map[i] = map[i].join('');
			}
			//console.log("Properties2: "+JSON.stringify(map,null,2));
			return map;
		}
		var reader = new X3Reader(client, null, client.read(_, len, true));
		map = reader.nextProperties(map, true);
	}
}

function writeVal(_, client, letter, val) {
	var stream = client.stream;
	switch (letter) {
		case 'B':
			stream.write(_, new Buffer([val]));
			break;
		default:
			throw new Error("bad ack char: " + letter);
	}
}

function writeVals(_, client, letter, vals) {
	var stream = client.stream;
	var buf;
	for (var i = 0; i < vals.length; i++) {
		var val = vals[i];
		switch (letter) {
			case 'U':
				buf = new Buffer(5);
				buf[0] = 0;
				buf.writeInt32BE(val.length, 1);
				stream.write(_, buf);
				stream.write(_, new Buffer(val, "utf8"));
				break;
			default:
				throw new Error("bad ack char: " + letter);
		}
	}
	buf = new Buffer(5);
	buf.fill(0);
	stream.write(_, buf);
}

function dummyHandler(_, reader, node) {}

function processNode(_, client, request, reader, node, phase) {

	var timingInfo = {
		nodeName: node.name
	};
	var timing, t;
	timing = perfmonEnabled && perfmon.start(module, "x3Automata.processNode-x3read", node.name);

	var args = [reader, node];
	var t0 = new Date().getTime();
	//console.error("NODE: "+require('util').inspect(node));
	client.tracer.trace(_, "protocol", "Process Node: " + node.name, trace);
	var params = node.params;
	var i;
	for (i = 0; i < params.length; i++) {

		if ('x'.indexOf(params[i]) >= 0) {

			var extend = readVal(_, reader, params[i]);
			var subArgs = [];
			var j = i + 1;
			if (!params[j]) throw new Error("At least one type is needed for extend node !");
			while (params[j] && params[j] !== 'x') {
				if (reader.data.length > reader.pos) {

					var val = readVal(_, reader, params[j]);
					subArgs.push(val);
				}

				j++;
			}
			i = j - 1;
			args.push(subArgs);
		} else {
			args.push(readVal(_, reader, params[i]));
		}

	}
	var properties1 = node.properties;
	for (i = 0; i < properties1.length; i++) {
		args.push(readProperties1(_, client, properties1[i]));
	}

	var properties2 = node.properties2;
	for (i = 0; i < properties2.length; i++) {
		args.push(readProperties2(_, client, properties2[i]));
	}


	//
	timing = perfmonEnabled && perfmon.start(module, "x3Automata.processNode-cvg", node.name);

	client.recorder && !node.skipHandler && client.recorder.dumpNode(_, node.name, args.slice(2));
	client.tracer.trace(_, "protocol", "NODE HANDLER: " + node.name + ": args=" + JSON.stringify(args.slice(2)), trace);

	if (client.connecting && ACTION_ENDING.indexOf(node.name) > -1) {
		// Connection end
		client.connectStop(_);
	}

	var results, timeread;
	setImmediate(~_); // yield
	var fn = node.skipHandler ? dummyHandler : client["listenNode" + node.name];


	if (fn) {
		// add new nbNodeReda
		results = fn.apply_(_, client, args, 0);


	} else {
		fn = request["listenNode" + node.name];
		if (fn) results = fn.apply_(_, request, args, 0);
		else {
			consol.log("LISTENER MISSING: " + node.name);
			throw new Error("LISTENER MISSING: " + node.name);
		}
	}

	if (perfmonEnabled && perfmonDetail) {
		timing.end();
		var t = timing.getTiming();
		client.timing[phase.title][phase.detail] = client.timing[phase.title][phase.detail] || {};
		client.timing[phase.title][phase.detail]["listenNode"] = client.timing[phase.title][phase.detail]["listenNode"] || [];
		t && client.timing[phase.title][phase.detail]["listenNode"].push({
			duration: (t && t.duration) || 0,
			node: node.name
		});
	}
	client.lastListenNode = node;

	timing = perfmonEnabled && perfmon.start(module, "x3automata.autoack");
	var acks = node.acks;
	var ack = 0;
	if (acks.length === 1 && results === undefined) results = [0]; // auto ack
	for (i = 0; i < acks.length; i++) {
		if (acks[i] === '[') {
			i++;
			writeVals(_, client, acks[i], results[ack]);
		} else {
			writeVal(_, client, acks[i], results[ack]);
		}
		ack++;
	}
	if (perfmonEnabled) {
		timing.end();
	}
}

function processRequest(_, client, request, reader, node, phase) { /*  Caractere a Traite  */

	var car = reader.nextByte();
	//trace && trace("car1="+car);
	if (car === 0) return node;

	while (node) {
		//console.log("node=" + node.name + ", car=0x" + car.toString(16));

		if (node.transitions) {
			var nextNode = node.transitions[car];
			if (nextNode) {
				//console.log("transition to " + nextNode.name);
				if (node.finish) node.finish(_, client, reader, car);
				processNode(_, client, request, reader, nextNode, phase);
				node = nextNode;
				if (node.waitUser) return node;
				car = reader.nextByte(true);
				//trace && trace("car2="+car);
				if (car === 0) return nextNode.def;
				else continue;
			}
		}
		/*  Fausse transition vers le Noeud Defaut  */
		if (node === node.def) {
			//return node;
			throw new Error("Infinite loop");
		}
		//console.log("transition to default");
		node = node.def;
	}

	return node;
}

function readRequest(_, client) {
	var head = client.read(_, 3);
	var len = (head[1] << 8) | head[2];
	return new X3Reader(client, head[0], len ? client.read(_, len, true) : new Buffer(0));
}

// was setting def to -40!!!

function process(_, client, request, phase) {
	//console.log("PHASE:"+JSON.stringify(phase,null,2));
	var timing;
	if (perfmonEnabled) {
		client.timing[phase.title] = client.timing[phase.title] || {};
		client.timing[phase.title][phase.detail] = client.timing[phase.title][phase.detail] || {};
		client.timing[phase.title][phase.detail]["x3runtime"] = client.timing[phase.title][phase.detail]["x3runtime"] || [];

		timing = perfmonEnabled && perfmon.start(module, "x3Automata.process", phase.title + "_" + phase.detail);
	}
	var reader, node = NODES[0];
	do {
		var readTiming = perfmonEnabled && perfmon.start(module, "x3Automata.readRequest", "lastListenNode " + (client.lastListenNode && client.lastListenNode.name));
		reader = readRequest(_, client);
		if (perfmonEnabled) {
			readTiming.end();
			var t = readTiming.getTiming();
			t && client.timing[phase.title][phase.detail]["x3runtime"].push({
				duration: (t && t.duration) || 0,
				action: "read"
			});
		}
		var processTiming = perfmonEnabled && perfmon.start(module, "x3Automata.processRequest", "lastListenNode " + (client.lastListenNode && client.lastListenNode.name));
		while (reader.peek() > 0 && node) {
			node = processRequest(_, client, request, reader, node, phase);
		}
		perfmonEnabled && processTiming.end();
	} while (node && !node.waitUser);
	perfmonEnabled && timing.end();
	return node;
}

exports.MAP = MAP;
exports.process = process;
exports.readVal = readVal; // for deserialisation of action