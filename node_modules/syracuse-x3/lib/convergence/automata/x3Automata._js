"use strict";
require('buffer').INSPECT_MAX_BYTES = 2048;
Buffer.prototype.toJSON = function() {
	return this.toString('hex');
};
var config = require('config');
var perfmon = require('@sage/syracuse-lib/src/perfmon/record');
var helpers = require('@sage/syracuse-core').helpers;
var descriptors = require("./x3Descriptors");
var currentprotocol = require("./x3Descriptors").CURRENTPROTOCOL;

var tracerProtocol = require('@sage/syracuse-core').getTracer("classic.protocol");
var perfConfig = (config.x3fusion || {}).perfmon || {};

var perfmonEnabled = perfConfig.activate;
var perfmonDetail = perfConfig.detail;

var Desc = helpers.defineClass(function() {}, null, {
	initDescriptors: function(protocolVersion) {
		this.DESCS = descriptors["Desc" + protocolVersion];
		this.protocolVersion = protocolVersion;
	},
	init: function(protocolVersion) {
		this.initDescriptors(protocolVersion);
		/* FuncIu request */

		this.NODES = [];
		this.MAP = {};
		this.ACTION_ENDING = [];
		var self = this;
		Object.keys(this.DESCS).forEach(function(id) {
			var node = self.DESCS[id];
			var pat = node.desc || "";
			var params = pat.split('F')[0];
			var acks = pat.split('F')[1] || "";
			var properties = params.split('[')[1] || "";
			params = params.split('[')[0];
			var properties2 = params.split('{')[1] || "";
			params = params.split('{')[0];
			var n = {
				id: node.id,
				name: id,
				params: params,
				properties: properties,
				properties2: properties2,
				acks: acks,
				def: 0,
				skipHandler: (node.desc == null),
				listenHandler: node.listenHandler
			};
			if (node.end)
				self.ACTION_ENDING.push(id);
			self.NODES[node.id] = n;
			self.MAP[id] = n;
		});

		this.NODES.forEach(function(node) {
			node.def = self.NODES[0];
		});
		this.MAP.ND_CLT.def = null;
		//MAP.NDOWIN.def = null; -- not needed any more
		this.MAP.ND_REB.def = null;

		function resolve(v) {
			if (v === 0) return;
			else if (!self.MAP[v]) throw new Error("bad key: " + v);
			return self.MAP[v];
		}

		this.MAP.ND_RCN.transitions = [ //
			"ND_RCN", 0, 0, 0, 0, 0, 0, 0, //
			0, 0, 0, 0, 0, 0, "NDEXT", 0, //
			0, "ND_CMVD", "NDIMPR", "ND_INP" //
		].map(resolve);

		this.MAP.NDEXT.transitions = [ //
			0, "NDOPEN", "ND_RAT", "ND_EVT", "NDTBLK", 0, 0, 0, //
			0, 0, "NDSUPLI", "NDINSLI", "NDSATAN", 0, 0, 0, //
			0, 0, 0, 0, "ND_CLF", "ND_CLT", "NDDTOB", 0, //
			0, "ND_REB", "ND_NAP", 0, 0, 0, "NDGIST", "NDCHGR", //
			"NDMIST", 0, "NDCTSU", 0, "ND_DCL", "ND_FCL", "NDAFTB", "NDRZLS", //
			"NDGLLS", "NDULLS", 0, 0, 0, "NDRZAR", "NDGLAR", "ND_DCA", //
			"ND_FCA", "NDULAR", "NDCHTIT", "NDCTIT", "NDCSTL", 0, 0, 0, //
			0, 0, 0, 0, "NDACTOBJ", 0, 0, "NDFIMG", //
			"NDACTOP", 0, "NDAJLB", "NDCHFM", "NDDSLB", 0, 0, "NDCOPMENU", //
			"NDIHLP", "NDITTP", "NDCHLP", "NDCTTP" //
		].map(resolve);

		this.MAP.ND_CMVD.transitions = [ //
			0, 0, 0, 0, 0, "ND_INT", 0, 0, //
			0, 0, "NDSYSTEM", "NDEXECI", 0, 0, 0, 0, //
			"ND_ICL", "ND_CRD", "NDINED", "NDEDBK", 0, "NDAFRE", 0, "NDPKLS", "NDPKAR", //
			0, 0, 0, 0, 0, 0, 0, 0, //
			0, 0, 0, 0, 0, 0, 0, 0, //
			0, 0, 0, 0, 0, 0, 0, 0, //
			0, 0, 0, 0, 0, 0, 0, 0, //
			0, 0, 0, 0, 0, 0, 0, 0, //
			0, 0, "NDCHCR", 0, 0, "NDCHVL", "NDCHVB" //
		].map(resolve);

		this.MAP.NDOPEN.transitions = [ //
			0, "NDDEB", "NDOFENB", "NDOFENH", "NDOFENA", "NDOFENP", "NDODIAG", "NDODGSB", //
			"NDOBOXI", 0, "NDOBOXE", "NDOBOXW", "NDOBOXQ", "NDOBOXS", "NDOBOXI", 0, //
			0, 0, 0, 0, "NDOBOUT", "NDOTBL", "NDOCTB", "NDOGRD", //
			"NDOBRD", "NDOCMB", "NDOFRM", "NDOBOG", "NDOONG", "NDOCSX", "NDCREUX", "NDOBPG", //
			"NDOIMG", "NDOLST", "NDOCLS", "NDOLLS", "NDOJLB", "NDOPFN", 0, "NDOFML", //
			"NDOFLD", "NDOARB", "NDOCAR", "NDOLAR", 0, 0, 0, 0, //
			0, 0, 0, 0, 0, 0, 0, 0, //
			0, 0, 0, 0, 0, 0, 0, 0, //
			0, 0, 0, 0, 0, 0, 0, "NDOTXSC", //
			0, 0, 0, 0, 0, 0, 0, 0, //
			0, "NDACV", 0, 0, 0, 0, 0, "NDOWIN", //
			0, 0, 0, 0, 0, 0, "NDOMNCO", "NDOMENC", //
			"NDOMNAO", "NDOMNBO", "NDOMENA", "NDOMENB" //
		].map(resolve);

		this.MAP.NDIMPR.transitions = [ //
			0, "NDOUVIMP", "ND_IMF", 0, 0, "NDOMSG", "NDGTDT", "NDGTIM", //
			"ND_OCX", "ND_IHM", "ND_LIM", "ND_GFD", "ND_SLF", "ND_ASKUI" //
		].map(resolve);

		this.MAP.ND_INP.transitions = [ //
			0, "NDRESULT" //
		].map(resolve);

		// nodes that exit the loop
		this.MAP.NDGIST.waitUser = true; // GotoInstance
		this.MAP.NDSATAN.waitUser = true; // Goto_GridCommande
		this.MAP.NDOBOXI.waitUser = true; // MessageBox_Create
		this.MAP.ND_ASKUI.waitUser = true; // AskUi
		this.MAP.NDEXECI.waitUser = true; // CallIU
		this.MAP.ND_REB.waitUser = true; //
		this.MAP.ND_CLT.waitUser = true; // End of session
		//MAP.NDINED.waitUser = true; // Window_ModeEditorL4GOn : NDINED replied automatically because not supported in convergence
		this.MAP.NDEDBK.waitUser = true; //
		this.MAP.NDGTIM.waitUser = true; // SelImp
		this.MAP.ND_IHM.waitUser = true; // callilog
		this.MAP.ND_SLF.autoReplyAck = true; // callilog
		return this;
	}
});

var DESC = {
	150067: new Desc().init(150067),
	150068: new Desc().init(150068),
	150069: new Desc().init(150069)
};


exports.X3Automata = helpers.defineClass(function(protocolVersion) {
	this.setProtocolVersion(protocolVersion);
}, null, {
	setProtocolVersion: function(protocolVersion) {
		this.protocolVersion = protocolVersion ? protocolVersion : currentprotocol; // by default
		this.desc = DESC[this.protocolVersion]; // by default
		this.suffixListen = this.protocolVersion.substring(this.protocolVersion.length - 2);
	},
	// !: error
	// F: call function
	// B: read byte
	// S: read short
	// L: read long
	// U: read UTF8
	// N: read UCS2
	// I: read ist (long + short)
	// A: short + buf
	// V: resu
	// W: resu table
	// T: short table
	// Q: special var array of ints
	// X: structure (short + short + resu) --> modified parameters table
	// x: extends
	// D: defs
	// l: write long
	// digit: repeat N time
	readVal: function(_, reader, letter, isExtend) {
		switch (letter) {
			case 'B':
				return reader.nextByte();
			case 's':
				return reader.nextSignedShort();
			case 'S':
				return reader.nextShort();
			case 'L':
				return reader.nextLong();
			case 'U':
				return reader.nextString(_);
			case 'T':
				return reader.nextShortTable();
			case 'n': // just for information that n in the description defined nothin to read (use for null extends protocol 150068)
				return null;
			case 'N':
				// TODO Check real length
				return reader.nextStringUcs2();
			case 'I':
				return reader.nextIst();
			case 'A':
				return reader.nextBuf();
			case 'x':
				return reader.nextExtend(_);
			case 'D':
				return reader.nextDefs(_);
			case 'V':
				return reader.nextResu(_);
			case 'W':
				return reader.nextResuTable(_, isExtend);
			case 'M':
				return reader.nextResuTable2(_, isExtend);
			case 'X':
				return reader.nextStruct(_);
			case 'Y':
				return reader.nextStruct2(_);
			case 'Z':
				return reader.nextStruct3(_);

			default:
				throw new Error("bad arg char: " + letter);

		}
	},
	readPropertiesVal: function(_, reader, letter, map, len) {
		switch (letter) {
			case 'p':
				return reader.nextLines(len);
			case 'P':
				return reader.nextProperties(map, len, false);
			default:
				throw new Error("bad list char: " + letter);

		}
	},
	readProperties1: function(_, client, letter) {
		var map = {};
		var reader = client.x3Reader;
		while (true) {
			reader.ensure(_, 5);
			reader.nextByte();
			var len = reader.nextLong();
			if (len < 0) throw new Error("bad property1 len: " + len);
			if (len === 0) {
				for (var i in map) {
					if (map[i] && Array.isArray(map[i])) map[i] = map[i].join('');
				}
				//console.log("Properties1: "+JSON.stringify(map,null,2));
				return map;
			}
			reader.ensure(_, len);
			map = this.readPropertiesVal(_, reader, letter, map, len);
		}
	},
	readProperties2: function(_, client, letter) {
		var map = {};
		var reader = client.x3Reader;
		while (true) {
			// console.log("loop");
			reader.pos = reader.end;
			reader.ensure(_, 1);
			var len = reader.nextByte();
			if (len < 0) throw new Error("bad property2 len: " + len);
			if (len === 0) {
				reader.ensure(_, 4);
				reader.nextLong();
				for (var i in map) {
					if (map[i] && Array.isArray(map[i])) map[i] = map[i].join('');
				}
				// console.log("Properties2: " + JSON.stringify(map, null, 2));
				return map;
			}
			reader.ensure(_, len);
			map = reader.nextProperties(map, len, true);
		}
	},
	writeVal: function(_, client, letter, val) {
		var stream = client.stream;
		switch (letter) {
			case 'B':
				stream.write(_, new Buffer([val]));
				break;
			default:
				throw new Error("bad ack char: " + letter);
		}
	},
	writeVals: function(_, client, letter, vals) {
		var stream = client.stream;
		var buf;
		var fullBuf;
		for (var i = 0; i < vals.length; i++) {
			var val = vals[i];
			switch (letter) {
				case 'U':
					buf = new Buffer(5);
					buf[0] = 0;
					buf.writeInt32BE(val.length, 1);
					fullBuf = Buffer.concat([buf, new Buffer(val, "utf8")]);
					//stream.write(_, buf);
					//stream.write(_, new Buffer(val, "utf8"));
					break;
				default:
					throw new Error("bad ack char: " + letter);
			}
		}
		buf = new Buffer(5);
		buf.fill(0);
		fullBuf = fullBuf ? Buffer.concat([fullBuf, buf]) : buf;
		stream.write(_, fullBuf);
	},
	dummyHandler: function(_, reader, node) {},
	processNode: function(_, client, request, reader, node, phase) {



		var self = this;

		function _applyListen(_, fnName, args) {
			var ok = false;
			var fn = node.skipHandler ? self.dummyHandler : client[fnName];

			if (fn) {
				// add new nbNodeReda
				results = fn.apply_(_, client, args, 0);
				ok = true;
			} else {

				fn = request[fnName];
				if (fn) {
					results = fn.apply_(_, request, args, 0);
					ok = true;
				}
			}
			return ok;
		}
		var timingInfo = {
			nodeName: node.name
		};
		var timing, t;
		timing = perfmonEnabled && perfmon.start(module, "x3Automata.processNode-x3read", node.name);

		var args = [reader, node];
		var t0 = new Date().getTime();
		//console.error("NODE: "+require('util').inspect(node));
		tracerProtocol.debug && tracerProtocol.debug("Process Node: " + node.name);
		var params = node.params; // TODO regexp to have an array of letter or letter+Digit to map version of deserializer
		var i;
		for (i = 0; i < params.length; i++) {
			var paramReader = params[i];

			// check if the next char is a digit or not
			if ('x'.indexOf(paramReader) >= 0) {

				var extend = this.readVal(_, reader, paramReader);
				var subArgs = [];
				var j = i + 1;
				if (!params[j]) throw new Error("At least one type is needed for extend node !");
				while (params[j] && params[j] !== 'x') {
					if (reader.data.length > reader.pos) {
						var val = this.readVal(_, reader, params[j]);
						subArgs.push(val);
					}
					j++;
				}
				i = j - 1;
				args.push(subArgs);
			} else {
				args.push(this.readVal(_, reader, paramReader));
			}

		}
		var properties1 = node.properties;
		for (i = 0; i < properties1.length; i++) {
			args.push(this.readProperties1(_, client, properties1[i]));
		}

		var properties2 = node.properties2;
		for (i = 0; i < properties2.length; i++) {
			args.push(this.readProperties2(_, client, properties2[i]));
		}

		//
		timing = perfmonEnabled && perfmon.start(module, "x3Automata.processNode-cvg", node.name);

		client.recorder && !node.skipHandler && client.recorder.dumpNode(_, node.name, args.slice(2));
		tracerProtocol.debug && tracerProtocol.debug("NODE HANDLER: " + node.name + ": args=" + JSON.stringify(args.slice(2)));

		if (client.connecting && this.desc.ACTION_ENDING.indexOf(node.name) > -1) {
			// Connection end
			client.connectStop(_);
		}

		var results, timeread;
		//setImmediate(~_); // yield
		// check if a specific listenNode has been implemented for this protocol version (new parameter ...)
		var listenHandler = node.listenHandler;

		if (listenHandler) {
			results = listenHandler(_, client, node.name, args);
		}


		if (perfmonEnabled && perfmonDetail) {
			var t = timing.end();
			if (perfConfig.clientRecord) {
				client.timing[phase.title][phase.detail] = client.timing[phase.title][phase.detail] || {};
				client.timing[phase.title][phase.detail]["listenNode"] = client.timing[phase.title][phase.detail]["listenNode"] || [];
				t && client.timing[phase.title][phase.detail]["listenNode"].push({
					duration: (t && t.duration) || 0,
					node: node.name
				});
			}
		}
		client.lastListenNode = node;
		if (!node.waitUser && !node.autoReplyAck) {
			timing = perfmonEnabled && perfmon.start(module, "x3automata.autoack");

			var acks = node.acks;
			var ack = 0;
			if (acks.length === 1 && results === undefined) results = [0]; // auto ack
			for (i = 0; i < acks.length; i++) {
				if (acks[i] === '[') {
					i++;
					this.writeVals(_, client, acks[i], results[ack]);
				} else {
					this.writeVal(_, client, acks[i], results[ack]);
				}
				ack++;
			}
			if (perfmonEnabled) {
				timing.end();
			}
		}
	},
	processRequest: function(_, client, request, reader, node, phase) { /*  Caractere a Traite  */

		var car = reader.nextByte();
		if (car === 0) return node;

		while (node) {
			//console.log("node ",node)
			node = this.desc.NODES[node.id]; // b e sure we use the right protocol description at anytime
			//console.log("node b",node)
			//console.log("node list",this.desc.NODES)

			//console.log("node=" + node.name + ", car=0x" + car.toString(16));

			if (node.transitions) {
				// get next node of the right decription regarding the protocol

				var nextNode = node.transitions[car];


				if (nextNode) {
					//console.log("transition to " + nextNode.name);
					if (node.finish) node.finish(_, client, reader, car);
					this.processNode(_, client, request, reader, nextNode, phase);
					node = nextNode;
					if (node.waitUser && !client.continuing) // if wait node and autoreplyACk but not write done, the ack is done by the client so wait for action
						return node;
					client.continuing = false;
					car = reader.nextByte(true);
					if (car === 0) return nextNode.def;
					else continue;
				}
			}
			/*  Fausse transition vers le Noeud Defaut  */
			if (node === node.def) {
				//return node;
				throw new Error("Infinite loop");
			}
			//console.log("transition to default");
			node = node.def;
		}

		return node;
	},
	readRequest: function(_, reader) {
		reader.ensure(_, 3);
		reader.nextByte();
		var len = reader.nextShort();
		if (len > 0) reader.ensure(_, len);
		return len;
	},

	// was setting def to -40!!!
	process: function(_, client, request, phase) {
		// for unit test offline
		if (client.qunit) {
			return;
		}
		//console.log("PHASE:"+JSON.stringify(phase,null,2));
		var timing;
		if (perfmonEnabled) {
			if (perfConfig.clientRecord) {
				client.timing[phase.title] = client.timing[phase.title] || {};
				client.timing[phase.title][phase.detail] = client.timing[phase.title][phase.detail] || {};
				client.timing[phase.title][phase.detail]["x3runtime"] = client.timing[phase.title][phase.detail]["x3runtime"] || [];
			}
			timing = perfmonEnabled && perfmon.start(module, "x3Automata.process", phase.title + "_" + phase.detail);
		}
		var reader = client.x3Reader,
			node = this.desc.NODES[0];
		do {
			var readTiming = perfmonEnabled && perfmon.start(module, "x3Automata.readRequest", "lastListenNode " + (client.lastListenNode && client.lastListenNode.name));
			this.readRequest(_, reader);
			if (perfmonEnabled) {
				readTiming.end();
				var t = readTiming.getTiming();
				if (t && perfConfig.clientRecord) {
					client.timing[phase.title][phase.detail]["x3runtime"].push({
						duration: (t && t.duration) || 0,
						action: "read"
					});
				}
			}
			var processTiming = perfmonEnabled && perfmon.start(module, "x3Automata.processRequest", "lastListenNode " + (client.lastListenNode && client.lastListenNode.name));
			while (reader.peek() > 0 && node) {
				node = this.processRequest(_, client, request, reader, node, phase);
			}
			perfmonEnabled && processTiming.end();
		} while (node && !node.waitUser);
		perfmonEnabled && timing.end();
		return node;
	}

});