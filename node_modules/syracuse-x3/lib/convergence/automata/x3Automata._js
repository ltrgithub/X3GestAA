"use strict";
require('buffer').INSPECT_MAX_BYTES = 2048;
Buffer.prototype.toJSON = function() {
	return this.toString('hex');
};
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var X3Reader = require('syracuse-x3/lib/convergence/automata/x3Reader').X3Reader;
var perfmon = require('syracuse-perfmon');

var trace = nodeconfig.config && nodeconfig.config.x3fusion && nodeconfig.config.x3fusion.protocol && nodeconfig.config.x3fusion.protocol.trace;

var perfConfig = ((nodeconfig.config || {}).x3fusion || {}).perfmon || {};
var perfmonEnabled = perfConfig.activate;
var perfmonDetail = perfConfig.detail;

// !: error
// F: call function
// B: read byte
// S: read short
// L: read long
// U: read UTF8
// N: read UCS2
// I: read ist (long + short)
// A: short + buf
// V: resu
// W: resu table
// T: short table
// Q: special var array of ints
// X: structure (short + short + resu) --> modified parameters table
// x: extends
// D: defs
// l: write long
// digit: repeat N times
var DESCS = [
	[0, "ND_RCN", null],
	[1, "ND_GFD", "[pF[U"],
	[2, "ND_SLF", "[PF[U"],
	[14, "NDEXT", null],
	[17, "ND_CMVD", null],
	[18, "NDIMPR", null],
	[19, "NDOPEN", null],
	[20, "ND_CLF", "IF"], // I is nxtist (LS)
	[21, "ND_CLT", "BF"],
	[22, "ND_INP", null],
	[23, "ND_CRD", "F2l"],
	[25, "NDCSTL", "IUF"],
	[26, "NDCHCR", "IBF"],
	[27, "NDCHTIT", "!"],
	[28, "NDACTOBJ", "IBFB"],
	[31, "NDCOPMENU", "AF"],
	[32, "NDOUVIMP", "{PFBB"],
	[33, "ND_IMF", "BF"],
	[38, "ND_INT", "FB"],
	[42, "ND_ASKUI", "[PF"], // BRJOU: was ND_ASKUI
	[43, "NDSYSTEM", "FB"],
	[45, "NDAFRE", "UF"],

	[49, "NDACV", "LSSUBBF"],

	[56, "NDDEB", ""], // read function was null
	[57, "NDOFENB", "SSSSBSF"],
	[58, "NDOFENH", "UF"],
	[59, "NDOFENA", "SSSSBSF"],
	[60, "NDOFENP", "SSSSBSF"],
	[61, "NDOBOXE", "BBUUBF"],
	[62, "NDOBOXW", "BBUUBF"],
	[63, "NDOBOXQ", "BBUUBF"],
	[64, "NDOBOXS", "SSSSBSF"],
	[65, "NDOBOXI", "BBUUBF"],
	[66, "NDOBOUT", "LUSSUUF"],
	[67, "NDOMNBO", "LSLBSUSF"],
	[68, "NDOMENC", "LF"],
	[69, "NDOMENB", "LF"],
	[70, "NDOMENA", "UF"],

	[73, "NDOTXSC", "IBsUUSF"],

	[80, "NDCREUX", "LSSCCUF"],

	[84, "NDODIAG", "SSSSBSF"], /*  Ouverture Dialogue	*/
	[85, "NDODGSB", "SSSSBSF"], /*  Ouv. Dialogue ss Bt	*/
	[87, "NDOWIN", "IUUUxNF"], /*  Ouverture Fenetre	*/

	[90, "ND_IMG", "UVF"], /*  Affichage Image	*/
	[91, "ND_RAT", "LLSSF2c"], /*  Rattachement	*/

	[94, "ND_EVT", "UCSF"], /*  Evenement/Instance	*/
	[95, "NDOCSX", "LSSBUF"], /*  Ouv. Case a Cocher	*/
	[96, "NDOGRD", "LSSBBF"], /*  Ouv. Groupe Radio	*/
	[97, "NDOBRD", "LBUF"], /*  Ouv. Bouton Radio	*/
	[98, "NDOTBL", "LSS5BBBBUF"], /*  Ouv. Tableau	*/
	[99, "NDOCTB", "LLBSBUF"], /*  Ouv. Colonne Tbl.	*/
	[100, "NDOCMB", "LSSBSF"], /*  Ouverture Combo	*/
	[101, "NDOFRM", "LSSBF"], /*  Ouverture Frame	*/
	[105, "NDOBOG", "LSSBF"], /*  Ouv. Boite a Onglets*/
	[106, "NDOONG", "LUUF"], /*  Ouv. Onglets	*/
	[107, "NDTBLK", "UUF"], /*  Titre des Blocs	*/
	[108, "NDOBPG", "LSSBF"], /*  Barre Progression	*/
	[109, "NDOIMG", "LSSBF"], /*  Cadre Image		*/
	[110, "NDFIMG", "BLBUF"], /*  Image de Fond	*/
	[111, "NDIHLP", "UUF"], /*  Aide d'un Objet	*/
	[112, "NDITTP", "UUF"], /*  ToolTip d'un Objet	*/
	[113, "NDCHVB", "IxVF"], /*  Modif Valeur Bin	*/
	[114, "NDCHVL", "IVF"], /*  Modif. Val. Zone	*/
	[115, "NDGIST", "IF"], /*  Allez a Une Zone	*/
	[116, "NDMIST", "IF"], /*  Allez au Menu Zone	*/
	[118, "NDSUPLI", "ISSF"], /*  Suppression Lignes	*/
	[119, "NDINSLI", "ISSF"], /*  Insertion Lignes	*/
	[120, "NDSATAN", "IF"], /*  Saisie Bas de Page	*/
	[121, "NDOLST", "LSSBF"], /*  Ouverture Liste	*/
	[122, "NDOCLS", "IBAF"], /*  Creation Col. Liste	*/
	[123, "NDOLLS", "ILLAF"], /*  Creat. Ligne Liste	*/

	[125, "NDACTOP", "LBF"], /*  Activation Option	*/
	[126, "NDOJLB", "LBUF"], /*  Creat Jeu Libelle	*/
	[127, "NDAJLB", "LBUF"], /*  Alim Jeu Libelles	*/
	[128, "NDCHFM", "IUF"], /*  Format d'une Zone	*/
	[132, "NDOMNAO", "LSLBSUSF"], /*  Option Menu Appli	*/
	[133, "NDGLLS", "IAF"], /*  Allez a Lg Liste	*/
	[134, "NDOPFN", "LSSBF"], /*  Creat. Part. Fen.	*/
	[136, "NDDTOB", "LBF"], /*  Destruction d'Objet	*/
	[137, "NDCTSU", "BUUF"], /*  Creation Type Prg	*/
	[138, "ND_DCL", "IF"], /*  Debut Chgt Liste	*/
	[139, "ND_FCL", "IF"], /*  Fin Chrgt Liste	*/
	[140, "ND_ICL", "IFB"], /*  Inter Chgt Liste	*/
	[141, "NDOMNCO", "BSUSUF"], /*  Option Menu Surg.	*/
	[142, "NDAFTB", "IBSF"], /*  Disable un Tableau	*/
	[143, "NDCHGR", "IBF"], /*  Actzo/Grizo/Diszo	*/
	[144, "NDRZLS", "IF"], /*  Effacement Liste	*/

	[147, "NDINED", "BUF"], /*  Saisie Editeur	*/
	[149, "NDOARB", "LSSBF"], /*  Ouverture Arbre	*/
	[150, "NDOCAR", "IBDF"], /*  Creation Col. Arbre	*/
	[151, "NDOLAR", "ISBUDDDF"], /*  Creat. Ligne Arbre	*/
	[152, "ND_NAP", "UF"], /*  Nouvelle Session	*/
	[153, "NDGLAR", "IDF"], /*  Allez a Lg Arbre	*/
	[154, "NDRZAR", "IF"], /*  Effacement Arbre	*/
	[155, "ND_DCA", "UF"], /*  Debut Chgt Arbre	*/
	[156, "ND_FCA", "UF"], /*  Fin Chrgt Arbre	*/
	[157, "ND_REB", "UUUUUUUUUUUUUUUUUF"], /*  Reboot Serveur	*/
	[158, "NDOMSG", "!!!FBB"], /* ????  Ouvre Messagerie	*/
	[159, "NDEDBK", "QFBB"], /*  Editeur de Blocs	*/
	[160, "NDULLS", "IAF"], /*  Desel Ligne Liste	*/
	[161, "NDULAR", "IDF"], /*  Desel Ligne Arbre	*/
	[162, "NDPKLS", "IF"], /*  Picking		*/
	[163, "NDPKAR", "IF"], /*  Picking Hierarchise	*/
	[164, "NDGTDT", "[pFBBBBB"], /*  Destinataires	*/
	[165, "NDGTIM", "[PF"], /*  Imprimantes		*/
	[166, "NDCHLP", "ISSUF"], /*  Aide d'un Objet	*/
	[167, "NDCTTP", "ISSUF"], /*  ToolTip d'un Objet	*/
	[168, "NDCTIT", "IUF"], /*  Titre d'un Objet	*/
	[169, "ND_OCX", "[pFBBBBB"], /*  Interface avec OCX	*/
	[170, "NDOFML", "UF"], /*  Ouverture Formule	*/
	[171, "NDOFLD", "IUUUSUUF"], /*  Ouverture Champs	*/
	[172, "NDDSLB", "IBF"], /*  Desactiv Libelle	*/
	[173, "ND_IHM", "F"], /*  Interface avec IHM	*/
	[174, "NDDTLB", "!"], /*  Desactiv Libelle	*/
	[175, "ND_LIM", "F"], /*  Interface avec LIM	*/
	[176, "NDRESULT", "ISSUBUxVxXxWF"], /* AckCall result */
	[177, "NDEXECI", "IULxTxW"],
]; /* FuncIu request */

var NODES = [];
var MAP = {};
var ACTION_ENDING = ['NDGIST', 'NDOBOXI', 'NDEXECI', 'ND_ASKUI', 'NDGTIM', 'ND_LIM'];

DESCS.forEach(function(node) {
	var pat = node[2] || "";
	var params = pat.split('F')[0];
	var acks = pat.split('F')[1] || "";
	var properties = params.split('[')[1] || "";
	params = params.split('[')[0];
	var properties2 = params.split('{')[1] || "";
	params = params.split('{')[0];
	var n = {
		id: node[0],
		name: node[1],
		params: params,
		properties: properties,
		properties2: properties2,
		acks: acks,
		def: 0,
		skipHandler: (node[2] == null),
	};
	NODES[node[0]] = n;
	MAP[node[1]] = n;
});

NODES.forEach(function(node) {
	node.def = NODES[0];
});
MAP.ND_CLT.def = null;
//MAP.NDOWIN.def = null; -- not needed any more
MAP.ND_REB.def = null;

function resolve(v) {
	if (v === 0) return;
	else if (!MAP[v]) throw new Error("bad key: " + v);
	return MAP[v];
}

MAP.ND_RCN.transitions = [ //
	"ND_RCN", 0, 0, 0, 0, 0, 0, 0, //
	0, 0, 0, 0, 0, 0, "NDEXT", 0, //
	0, "ND_CMVD", "NDIMPR", "ND_INP" //
].map(resolve);

MAP.NDEXT.transitions = [ //
	0, "NDOPEN", "ND_RAT", "ND_EVT", "NDTBLK", 0, 0, 0, //
	0, 0, "NDSUPLI", "NDINSLI", "NDSATAN", 0, 0, 0, //
	0, 0, 0, 0, "ND_CLF", "ND_CLT", "NDDTOB", 0, //
	0, "ND_REB", "ND_NAP", 0, 0, 0, "NDGIST", "NDCHGR", //
	"NDMIST", 0, "NDCTSU", 0, "ND_DCL", "ND_FCL", "NDAFTB", "NDRZLS", //
	"NDGLLS", "NDULLS", 0, 0, 0, "NDRZAR", "NDGLAR", "ND_DCA", //
	"ND_FCA", "NDULAR", "NDCHTIT", "NDCTIT", "NDCSTL", 0, 0, 0, //
	0, 0, 0, 0, "NDACTOBJ", 0, 0, "NDFIMG", //
	"NDACTOP", 0, "NDAJLB", "NDCHFM", "NDDSLB", 0, 0, "NDCOPMENU", //
	"NDIHLP", "NDITTP", "NDCHLP", "NDCTTP" //
].map(resolve);

MAP.ND_CMVD.transitions = [ //
	0, 0, 0, 0, 0, "ND_INT", 0, 0, //
	0, 0, "NDSYSTEM", "NDEXECI", 0, 0, 0, 0, //
	"ND_ICL", "ND_CRD", "NDINED", "NDEDBK", 0, "NDAFRE", 0, "NDPKLS", "NDPKAR", //
	0, 0, 0, 0, 0, 0, 0, 0, //
	0, 0, 0, 0, 0, 0, 0, 0, //
	0, 0, 0, 0, 0, 0, 0, 0, //
	0, 0, 0, 0, 0, 0, 0, 0, //
	0, 0, 0, 0, 0, 0, 0, 0, //
	0, 0, "NDCHCR", 0, 0, "NDCHVL", "NDCHVB" //
].map(resolve);

MAP.NDOPEN.transitions = [ //
	0, "NDDEB", "NDOFENB", "NDOFENH", "NDOFENA", "NDOFENP", "NDODIAG", "NDODGSB", //
	"NDOBOXI", 0, "NDOBOXE", "NDOBOXW", "NDOBOXQ", "NDOBOXS", "NDOBOXI", 0, //
	0, 0, 0, 0, "NDOBOUT", "NDOTBL", "NDOCTB", "NDOGRD", //
	"NDOBRD", "NDOCMB", "NDOFRM", "NDOBOG", "NDOONG", "NDOCSX", "NDCREUX", "NDOBPG", //
	"NDOIMG", "NDOLST", "NDOCLS", "NDOLLS", "NDOJLB", "NDOPFN", 0, "NDOFML", //
	"NDOFLD", "NDOARB", "NDOCAR", "NDOLAR", 0, 0, 0, 0, //
	0, 0, 0, 0, 0, 0, 0, 0, //
	0, 0, 0, 0, 0, 0, 0, 0, //
	0, 0, 0, 0, 0, 0, 0, "NDOTXSC", //
	0, 0, 0, 0, 0, 0, 0, 0, //
	0, "NDACV", 0, 0, 0, 0, 0, "NDOWIN", //
	0, 0, 0, 0, 0, 0, "NDOMNCO", "NDOMENC", //
	"NDOMNAO", "NDOMNBO", "NDOMENA", "NDOMENB" //
].map(resolve);

MAP.NDIMPR.transitions = [ //
	0, "NDOUVIMP", "ND_IMF", 0, 0, "NDOMSG", "NDGTDT", "NDGTIM", //
	"ND_OCX", "ND_IHM", "ND_LIM", "ND_GFD", "ND_SLF", "ND_ASKUI" //
].map(resolve);

MAP.ND_INP.transitions = [ //
	0, "NDRESULT" //
].map(resolve);

// nodes that exit the loop
MAP.NDGIST.waitUser = true; // GotoInstance
MAP.NDSATAN.waitUser = true; // Goto_GridCommande
MAP.NDOBOXI.waitUser = true; // MessageBox_Create
MAP.ND_ASKUI.waitUser = true; // AskUi
MAP.NDEXECI.waitUser = true; // CallIU
MAP.ND_REB.waitUser = true; // 
MAP.ND_CLT.waitUser = true; // End of session
//MAP.NDINED.waitUser = true; // Window_ModeEditorL4GOn : NDINED replied automatically because not supported in convergence
MAP.NDEDBK.waitUser = true; // 
MAP.NDGTIM.waitUser = true; // SelImp

function readVal(_, reader, letter, isExtend) {
	switch (letter) {
		case 'B':
			return reader.nextByte();
		case 's':
			return reader.nextSignedShort();
		case 'S':
			return reader.nextShort();
		case 'L':
			return reader.nextLong();
		case 'U':
			return reader.nextString(_);
		case 'T':
			return reader.nextShortTable();
		case 'N':
			// TODO Check real length
			return reader.nextStringUcs2();
		case 'I':
			return reader.nextIst();
		case 'A':
			return reader.nextBuf();
		case 'x':
			return reader.nextExtend(_);
		case 'D':
			return reader.nextDefs(_);
		case 'V':
			return reader.nextResu(_);
		case 'W':
			return reader.nextResuTable(_, isExtend);
		case 'X':
			return reader.nextStruct(_);
		default:
			throw new Error("bad arg char: " + letter);

	}
}

function readPropertiesVal(_, reader, letter, map, len) {
	switch (letter) {
		case 'p':
			return reader.nextLines(len);
		case 'P':
			return reader.nextProperties(map, len, false);
		default:
			throw new Error("bad list char: " + letter);

	}
}

function readProperties1(_, client, letter) {
	var map = {};
	var reader = client.x3Reader;
	while (true) {
		reader.ensure(_, 5);
		reader.nextByte();
		var len = reader.nextLong();
		if (len < 0) throw new Error("bad property1 len: " + len);
		if (len === 0) {
			for (var i in map) {
				if (map[i] && Array.isArray(map[i])) map[i] = map[i].join('');
			}
			//console.log("Properties1: "+JSON.stringify(map,null,2));
			return map;
		}
		reader.ensure(_, len);
		map = readPropertiesVal(_, reader, letter, map, len);
	}
}

function readProperties2(_, client, letter) {
	var map = {};
	var reader = client.x3Reader;
	while (true) {
		reader.pos = reader.end;
		reader.ensure(_, 1);
		var len = reader.nextByte();
		if (len < 0) throw new Error("bad property2 len: " + len);
		if (len === 0) {
			reader.ensure(_, 4);
			reader.nextLong();
			for (var i in map) {
				if (map[i] && Array.isArray(map[i])) map[i] = map[i].join('');
			}
			//console.log("Properties2: "+JSON.stringify(map,null,2));
			return map;
		}
		reader.ensure(_, len);
		map = reader.nextProperties(map, len, true);
	}
}

function writeVal(_, client, letter, val) {
	var stream = client.stream;
	switch (letter) {
		case 'B':
			stream.write(_, new Buffer([val]));
			break;
		default:
			throw new Error("bad ack char: " + letter);
	}
}

function writeVals(_, client, letter, vals) {
	var stream = client.stream;
	var buf;
	var fullBuf;
	for (var i = 0; i < vals.length; i++) {
		var val = vals[i];
		switch (letter) {
			case 'U':
				buf = new Buffer(5);
				buf[0] = 0;
				buf.writeInt32BE(val.length, 1);
				fullBuf = Buffer.concat([buf, new Buffer(val, "utf8")]);
				//stream.write(_, buf);
				//stream.write(_, new Buffer(val, "utf8"));
				break;
			default:
				throw new Error("bad ack char: " + letter);
		}
	}
	buf = new Buffer(5);
	buf.fill(0);
	if (fullBuf)
		fullBuf = Buffer.concat([fullBuf, buf]);
	else
		fullBuf = buf;
	stream.write(_, fullBuf);
}

function dummyHandler(_, reader, node) {}

function processNode(_, client, request, reader, node, phase) {

	var timingInfo = {
		nodeName: node.name
	};
	var args = [reader, node];
	var params = node.params;
	var results;

	// var t0 = new Date().getTime();
	//console.error("NODE: "+require('util').inspect(node));
	client.tracer.enabled && client.tracer.trace(_, "protocol", "Process Node: " + node.name, trace);
	// var timingInfo = {
	// 	nodeName: node.name
	// };
	var len = params.length - 1;
	var i;
	for (i = 0; i < params.length; i++) {
		var par = params[i];
		if ('x'.indexOf(par) >= 0) {

			var extend = readVal(_, reader, par);
			var subArgs = [];
			par = params[i + 1];
			// var j = i + 1;
			if (!par) throw new Error("At least one type is needed for extend node !");
			while (par && par !== 'x') {
				if (reader.data.length > reader.pos) {

					var val = readVal(_, reader, par);
					subArgs.push(val);
				}

				par = params[(++i) + 1];
			}
			// i = j - 1;
			args.push(subArgs);
		} else {
			args.push(readVal(_, reader, par));
		}

	}
	var properties1 = node.properties;
	for (i = 0; i < properties1.length; i++) {
		args.push(readProperties1(_, client, properties1[i]));
	}

	var properties2 = node.properties2;
	for (i = 0; i < properties2.length; i++) {
		args.push(readProperties2(_, client, properties2[i]));
	}

	//

	client.recorder && !node.skipHandler && client.recorder.dumpNode(_, node.name, args.slice(2));
	client.tracer.enabled && client.tracer.trace(_, "protocol", "NODE HANDLER: " + node.name + ": args=" + JSON.stringify(args.slice(2)), trace);

	if (client.connecting && ACTION_ENDING.indexOf(node.name) > -1) {
		// Connection end
		client.connectStop(_);
	}

	var results;
	//setImmediate(~_); // yield
	var fn = node.skipHandler ? dummyHandler : client["listenNode" + node.name];

	if (fn) {
		// add new nbNodeReda
		results = fn.apply_(_, client, args, 0);

	} else {
		fn = request["listenNode" + node.name];
		if (fn) results = fn.apply_(_, request, args, 0);
		else {
			//console.log("LISTENER MISSING: " + node.name);
			//don't raise an error some methode cannot be implemented for lightwieght classic page client for SOAP
			// throw new Error("LISTENER MISSING: " + node.name);
		}
	}


	client.lastListenNode = node;

	var acks = node.acks;
	var ack = 0;
	if (acks.length === 1 && results === undefined) results = [0]; // auto ack
	for (i = 0; i < acks.length; i++) {
		if (acks[i] === '[') {
			i++;
			writeVals(_, client, acks[i], results[ack]);
		} else {
			writeVal(_, client, acks[i], results[ack]);
		}
		ack++;
	}
}

function processRequest(_, client, request, reader, node, phase) { /*  Caractere a Traite  */

	var car = reader.nextByte();
	//trace && trace("car1="+car);
	if (car === 0) return node;

	while (node) {
		//console.log("node=" + node.name + ", car=0x" + car.toString(16));

		if (node.transitions) {
			var nextNode = node.transitions[car];
			if (nextNode) {
				//console.log("transition to " + nextNode.name);
				if (node.finish) node.finish(_, client, reader, car);
				processNode(_, client, request, reader, nextNode, phase);
				node = nextNode;
				if (node.waitUser) // if wait node and autoreplyACk but not write done, the ack is done by the client so wait for action
					return node;
				car = reader.nextByte(true);
				//trace && trace("car2="+car);
				if (car === 0) return nextNode.def;
				else continue;
			}
		}
		/*  Fausse transition vers le Noeud Defaut  */
		if (node === node.def) {
			//return node;
			throw new Error("Infinite loop");
		}
		//console.log("transition to default");
		node = node.def;
	}

	return node;
}

function readRequest(_, reader) {
	reader.ensure(_, 3);
	reader.nextByte();
	var len = reader.nextShort();
	if (len > 0) reader.ensure(_, len);
	return len;
}

// was setting def to -40!!!

function process(_, client, request, phase) {
	//console.log("PHASE:"+JSON.stringify(phase,null,2));
	var reader = client.x3Reader,
		node = NODES[0];
	do {
		readRequest(_, reader);
		while (reader.peek() > 0 && node) {
			node = processRequest(_, client, request, reader, node, phase);
		}
	} while (node && !node.waitUser);
	return node;
}

exports.MAP = MAP;
exports.process = process;
exports.readVal = readVal; // for deserialisation of action