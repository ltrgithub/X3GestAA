"use strict";
require('buffer').INSPECT_MAX_BYTES = 2048;
Buffer.prototype.toJSON = function() {
	return this.toString('hex');
}
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var X3Reader = require('syracuse-x3/lib/convergence/automata/x3Reader').X3Reader;

var trace = nodeconfig.config && nodeconfig.config.x3fusion && nodeconfig.config.x3fusion.protocol && nodeconfig.config.x3fusion.protocol.trace;


// !: error
// F: call function
// B: read byte
// S: read short
// L: read long
// U: read UTF8
// N: read UCS2
// I: read ist (long + short)
// A: short + buf
// V: resu
// W: resu table
// Q: special var array of ints
// X: structure (short + short + resu) --> modified parameters table
// x: extends
// D: defs
// l: write long
// digit: repeat N times
var DESCS = [
	[0, "ND_RCN", null],
	[1, "ND_GFD", "[pF[U"],
	[2, "ND_SLF", "[PF[U"],
	[14, "NDEXT", null],
	[17, "ND_CMVD", null],
	[18, "NDIMPR", null],
	[19, "NDOPEN", null],
	[20, "ND_CLF", "IF"], // I is nxtist (LS)
	[21, "ND_CLT", "BF"],
	[22, "ND_INP", null],
	[23, "ND_CRD", "F2l"],
	[25, "NDCSTL", "IUF"],
	[26, "NDCHCR", "IBF"],
	[27, "NDCHTIT", "!"],
	[28, "NDACTOBJ", "IBFB"],
	[31, "NDCOPMENU", "AF"],
	[32, "NDOUVIMP", "BBUUUUFs"],
	[33, "ND_IMF", "BF"],
	[38, "ND_INT", "Fb"],
	[42, "ND_ASK", "!"], // BRJOU: was ND_ASKUI
	[43, "NDSYSTEM", "F2a"],
	[45, "NDAFRE", "UF"],

	[49, "NDACV", "LSSUBBF"],

	[56, "NDDEB", ""], // read function was null
	[57, "NDOFENB", "SSSSBSF"],
	[58, "NDOFENH", "UF"],
	[59, "NDOFENA", "SSSSBSF"],
	[60, "NDOFENP", "SSSSBSF"],
	[61, "NDOBOXE", "BBUUBF"],
	[62, "NDOBOXW", "BBUUBF"],
	[63, "NDOBOXQ", "BBUUBF"],
	[64, "NDOBOXS", "SSSSBSF"],
	[65, "NDOBOXI", "BBUUBF"],
	[66, "NDOBOUT", "LUSSUUF"],
	[67, "NDOMNBO", "LSLBSUSF"],
	[68, "NDOMENC", "LF"],
	[69, "NDOMENB", "LF"],
	[70, "NDOMENA", "UF"],

	[73, "NDOTXSC", "IBSUUSF"],

	[80, "NDCREUX", "LSSCCUF"],

	[84, "NDODIAG", "SSSSBSF"], /*  Ouverture Dialogue	*/
	[85, "NDODGSB", "SSSSBSF"], /*  Ouv. Dialogue ss Bt	*/
	[87, "NDOWIN", "IUUUxNF"], /*  Ouverture Fenetre	*/

	[90, "ND_IMG", "UVF"], /*  Affichage Image	*/
	[91, "ND_RAT", "LLSSF2c"], /*  Rattachement	*/

	[94, "ND_EVT", "UCSF"], /*  Evenement/Instance	*/
	[95, "NDOCSX", "LSSBUF"], /*  Ouv. Case a Cocher	*/
	[96, "NDOGRD", "LSSBBF"], /*  Ouv. Groupe Radio	*/
	[97, "NDOBRD", "LBUF"], /*  Ouv. Bouton Radio	*/
	[98, "NDOTBL", "LSS5BBBBUF"], /*  Ouv. Tableau	*/
	[99, "NDOCTB", "LLBSBUF"], /*  Ouv. Colonne Tbl.	*/
	[100, "NDOCMB", "LSSBSF"], /*  Ouverture Combo	*/
	[101, "NDOFRM", "LSSBF"], /*  Ouverture Frame	*/
	[105, "NDOBOG", "LSSBF"], /*  Ouv. Boite a Onglets*/
	[106, "NDOONG", "LUUF"], /*  Ouv. Onglets	*/
	[107, "NDTBLK", "UUF"], /*  Titre des Blocs	*/
	[108, "NDOBPG", "LSSBF"], /*  Barre Progression	*/
	[109, "NDOIMG", "LSSBF"], /*  Cadre Image		*/
	[110, "NDFIMG", "BLBUF"], /*  Image de Fond	*/
	[111, "NDIHLP", "UUF"], /*  Aide d'un Objet	*/
	[112, "NDITTP", "UUF"], /*  ToolTip d'un Objet	*/
	[113, "NDCHVB", "IxVF"], /*  Modif Valeur Bin	*/
	[114, "NDCHVL", "IVF"], /*  Modif. Val. Zone	*/
	[115, "NDGIST", "IF"], /*  Allez a Une Zone	*/
	[116, "NDMIST", "IF"], /*  Allez au Menu Zone	*/
	[118, "NDSUPLI", "ISSF"], /*  Suppression Lignes	*/
	[119, "NDINSLI", "ISSF"], /*  Insertion Lignes	*/
	[120, "NDSATAN", "IF"], /*  Saisie Bas de Page	*/
	[121, "NDOLST", "LSSBF"], /*  Ouverture Liste	*/
	[122, "NDOCLS", "IBAF"], /*  Creation Col. Liste	*/
	[123, "NDOLLS", "ILLAF"], /*  Creat. Ligne Liste	*/

	[125, "NDACTOP", "LBF"], /*  Activation Option	*/
	[126, "NDOJLB", "LBUF"], /*  Creat Jeu Libelle	*/
	[127, "NDAJLB", "LBUF"], /*  Alim Jeu Libelles	*/
	[128, "NDCHFM", "IUF"], /*  Format d'une Zone	*/
	[132, "NDOMNAO", "LSLBSUSF"], /*  Option Menu Appli	*/
	[133, "NDGLLS", "IAF"], /*  Allez a Lg Liste	*/
	[134, "NDOPFN", "LSSBF"], /*  Creat. Part. Fen.	*/
	[136, "NDDTOB", "LBF"], /*  Destruction d'Objet	*/
	[137, "NDCTSU", "BUUF"], /*  Creation Type Prg	*/
	[138, "ND_DCL", "IF"], /*  Debut Chgt Liste	*/
	[139, "ND_FCL", "IF"], /*  Fin Chrgt Liste	*/
	[140, "ND_ICL", "IFB"], /*  Inter Chgt Liste	*/
	[141, "NDOMNCO", "BSUSUF"], /*  Option Menu Surg.	*/
	[142, "NDAFTB", "IBSF"], /*  Disable un Tableau	*/
	[143, "NDCHGR", "IBF"], /*  Actzo/Grizo/Diszo	*/
	[144, "NDRZLS", "IF"], /*  Effacement Liste	*/

	[147, "NDINED", "BUF"], /*  Saisie Editeur	*/
	[149, "NDOARB", "LSSBF"], /*  Ouverture Arbre	*/
	[150, "NDOCAR", "IBDF"], /*  Creation Col. Arbre	*/
	[151, "NDOLAR", "ISBUDDDF"], /*  Creat. Ligne Arbre	*/
	[152, "ND_NAP", "UF"], /*  Nouvelle Session	*/
	[153, "NDGLAR", "IDF"], /*  Allez a Lg Arbre	*/
	[154, "NDRZAR", "IF"], /*  Effacement Arbre	*/
	[155, "ND_DCA", "UF"], /*  Debut Chgt Arbre	*/
	[156, "ND_FCA", "UF"], /*  Fin Chrgt Arbre	*/
	[157, "ND_REB", "UUUUUUUUUUUUUUUUUF"], /*  Reboot Serveur	*/
	[158, "NDOMSG", "BBFs"], /*  Ouvre Messagerie	*/
	[159, "NDEDBK", "QFqq"], /*  Editeur de Blocs	*/
	[160, "NDULLS", "IAF"], /*  Desel Ligne Liste	*/
	[161, "NDULAR", "IDF"], /*  Desel Ligne Arbre	*/
	[162, "NDPKLS", "IF"], /*  Picking		*/
	[163, "NDPKAR", "IF"], /*  Picking Hierarchise	*/
	[164, "NDGTDT", "F"], /*  Destinataires	*/
	[165, "NDGTIM", "F"], /*  Imprimantes		*/
	[166, "NDCHLP", "ISSUF"], /*  Aide d'un Objet	*/
	[167, "NDCTTP", "ISSUF"], /*  ToolTip d'un Objet	*/
	[168, "NDCTIT", "IUF"], /*  Titre d'un Objet	*/
	[169, "ND_OCX", "F"], /*  Interface avec OCX	*/
	[170, "NDOFML", "UF"], /*  Ouverture Formule	*/
	[171, "NDOFLD", "IUUUSUUF"], /*  Ouverture Champs	*/
	[172, "NDDSLB", "BF"], /*  Desactiv Libelle	*/
	[173, "ND_IHM", "F"], /*  Interface avec IHM	*/
	[174, "NDDTLB", "!"], /*  Desactiv Libelle	*/
	[175, "ND_LIM", "F"], /*  Interface avec LIM	*/
	[176, "NDRESULT", "ISSUBUxVxXxWF"], /* AckCall result */
	[177, "NDEXECI", "IULxTxD"], ]; /* FuncIu request */

var NODES = [];
var MAP = {}

DESCS.forEach(function(node) {
	var pat = node[2] || "";
	var params = pat.split('F')[0];
	var acks = pat.split('F')[1] || "";
	var lists = params.split('[')[1] || "";
	params = params.split('[')[0];
	var n = {
		id: node[0],
		name: node[1],
		params: params,
		lists: lists,
		acks: acks,
		def: 0,
		skipHandler: (node[2] == null),
	};
	NODES[node[0]] = n;
	MAP[node[1]] = n;
})

NODES.forEach(function(node) {
	node.def = NODES[0];
})
MAP.ND_CLT.def = null;
//MAP.NDOWIN.def = null; -- not needed any more
MAP.ND_REB.def = null;

function resolve(v) {
	if (v === 0) return;
	else if (!MAP[v]) throw new Error("bad key: " + v);
	return MAP[v];
}

MAP.ND_RCN.transitions = [ //
"ND_RCN", 0, 0, 0, 0, 0, 0, 0, //
0, 0, 0, 0, 0, 0, "NDEXT", 0, //
0, "ND_CMVD", "NDIMPR", "ND_INP" //
].map(resolve);

MAP.NDEXT.transitions = [ //
0, "NDOPEN", "ND_RAT", "ND_EVT", "NDTBLK", 0, 0, 0, //
0, 0, "NDSUPLI", "NDINSLI", "NDSATAN", 0, 0, 0, //
0, 0, 0, 0, "ND_CLF", "ND_CLT", "NDDTOB", 0, //
0, "ND_REB", "ND_NAP", 0, 0, 0, "NDGIST", "NDCHGR", //
"NDMIST", 0, "NDCTSU", 0, "ND_DCL", "ND_FCL", "NDAFTB", "NDRZLS", //
"NDGLLS", "NDULLS", 0, 0, 0, "NDRZAR", "NDGLAR", "ND_DCA", //
"ND_FCA", "NDULAR", "NDCHTIT", "NDCTIT", "NDCSTL", 0, 0, 0, //
0, 0, 0, 0, "NDACTOBJ", 0, 0, "NDFIMG", //
"NDACTOP", 0, "NDAJLB", "NDCHFM", "NDDSLB", 0, 0, "NDCOPMENU", //
"NDIHLP", "NDITTP", "NDCHLP", "NDCTTP" //
].map(resolve);

MAP.ND_CMVD.transitions = [ //
0, 0, 0, 0, 0, "ND_INT", 0, 0, //
0, 0, "NDSYSTEM", 0, 0, 0, 0, 0, //
"ND_ICL", "ND_CRD", "NDINED", "NDEDBK", 0, "NDAFRE", 0, "NDPKLS", "NDPKAR", //
0, 0, 0, 0, 0, 0, 0, 0, //
0, 0, 0, 0, 0, 0, 0, 0, //
0, 0, 0, 0, 0, 0, 0, 0, //
0, 0, 0, 0, 0, 0, 0, 0, //
0, 0, 0, 0, 0, 0, 0, 0, //
0, 0, "NDCHCR", 0, 0, "NDCHVL", "NDCHVB" //
].map(resolve);

MAP.NDOPEN.transitions = [ //
0, "NDDEB", "NDOFENB", "NDOFENH", "NDOFENA", "NDOFENP", "NDODIAG", "NDODGSB", //
"NDOBOXI", 0, "NDOBOXE", "NDOBOXW", "NDOBOXQ", "NDOBOXS", "NDOBOXI", 0, //
0, 0, 0, 0, "NDOBOUT", "NDOTBL", "NDOCTB", "NDOGRD", //
"NDOBRD", "NDOCMB", "NDOFRM", "NDOBOG", "NDOONG", "NDOCSX", "NDCREUX", "NDOBPG", //
"NDOIMG", "NDOLST", "NDOCLS", "NDOLLS", "NDOJLB", "NDOPFN", 0, "NDOFML", //
"NDOFLD", "NDOARB", "NDOCAR", "NDOLAR", 0, 0, 0, 0, //
0, 0, 0, 0, 0, 0, 0, 0, //
0, 0, 0, 0, 0, 0, 0, 0, //
0, 0, 0, 0, 0, 0, 0, "NDOTXSC", //
0, 0, 0, 0, 0, 0, 0, 0, //
0, "NDACV", 0, 0, 0, 0, 0, "NDOWIN", //
0, 0, 0, 0, 0, 0, "NDOMNCO", "NDOMENC", //
"NDOMNAO", "NDOMNBO", "NDOMENA", "NDOMENB" //
].map(resolve);

MAP.NDIMPR.transitions = [ //
0, "NDOUVIMP", "ND_IMF", 0, 0, "NDOMSG", "NDGTDT", "NDGTIM", //
"ND_OCX", "ND_IHM", "ND_LIM", "ND_GFD", "ND_SLF" //
].map(resolve);

MAP.ND_INP.transitions = [ //
0, "NDRESULT" //
].map(resolve);

// nodes that exit the loop
MAP.NDGIST.waitUser = true; // GotoInstance
MAP.NDSATAN.waitUser = true; // Goto_GridCommande
MAP.NDOBOXI.waitUser = true; // MessageBox_Create
// NDRESULT && aRemoteVers < CCommConfig.PROTOCOL_NUM_150_009
MAP.ND_ASK.waitUser = true; // AskUi
//MAP.NDEXECI.waitUser = true; // CallIU (BRJOU: not found!!)
MAP.ND_REB.waitUser = true; // 
MAP.ND_CLT.waitUser = true; // End of session
MAP.NDINED.waitUser = true; // Window_ModeEditorL4GOn
MAP.NDEDBK.waitUser = true; // 

function readVal(_, reader, letter) {
	switch (letter) {
		case 'B':
			return reader.nextByte();
		case 'S':
			return reader.nextShort();
		case 'L':
			return reader.nextLong();
		case 'U':
			return reader.nextString(_);
		case 'N':
			// TODO Check real length
			return reader.nextStringUcs2();
		case 'I':
			return reader.nextIst();
		case 'A':
			return reader.nextBuf(_);
		case 'x':
			return reader.nextExtend(_);
		case 'D':
			return reader.nextDefs(_);
		case 'V':
			return reader.nextResu(_);
		case 'W':
			return reader.nextResuTable(_);
		case 'X':
			return reader.nextStruct(_);
		default:
			throw new Error("bad arg char: " + letter);

	}
}

function readListVal(_, reader, letter) {
	switch (letter) {
		case 'p':
			return reader.nextLines();
		case 'P':
			return reader.nextProperties();
		default:
			throw new Error("bad list char: " + letter);

	}
}

function readList(_, client, letter) {
	var list = [];
	while (true) {
		var head = client.stream.read(_, 5);
		var len = head.readInt32BE(1);
		if (len < 0) throw new Error("bad list len: " + len);
		if (len === 0) return list;
		var reader = new X3Reader(client, head[0], client.stream.read(_, len));
		list.push(readListVal(_, reader, letter))
	}
}

function writeVal(_, client, letter, val) {
	var stream = client.stream;
	switch (letter) {
		case 'B':
			stream.write(_, new Buffer([val]));
			break;
		default:
			throw new Error("bad ack char: " + letter);
	}
}

function writeVals(_, client, letter, vals) {
	var stream = client.stream;
	for (var i = 0; i < vals.length; i++) {
		var val = vals[i];
		switch (letter) {
			case 'U':
				var buf = new Buffer(5);
				buf[0] = 0;
				buf.writeInt32BE(val.length, 1);
				stream.write(_, buf);
				stream.write(_, new Buffer(val, "utf8"));
				break;
			default:
				throw new Error("bad ack char: " + letter);
		}
	}
	var buf = new Buffer(5);
	buf.fill(0);
	stream.write(_, buf);
}

function dummyHandler(_, reader, node) {}

function processNode(_, client, reader, node) {
	var args = [reader, node];
	//console.error("NODE: "+require('util').inspect(node));
	trace && trace("Process Node: "+node.name);
	client._spy && client._spy.dumpJSON(_, "Red Node", node.name);
	var params = node.params;
	for (var i = 0; i < params.length; i++) {

		if ('x'.indexOf(params[i]) >= 0) {

			
			var extend = readVal(_, reader, params[i]);
			var subArgs = [];
			var j = i + 1;
			if (!params[j])
				throw new Error("At least one type is needed for extend node !");
			while (params[j] && params[j] !== 'x') {
				if (reader.data.length > reader.pos) {

					var val = readVal(_, reader, params[j]);
					subArgs.push(val);
				}

				j++;
			}
			i = j - 1;
			args.push(subArgs);
		}else{
			args.push(readVal(_, reader, params[i]));
		}
		
	}
	var lists = node.lists;
	for (var i = 0; i < lists.length; i++) {
		args.push(readList(_, client, lists[i]));
	}
	client._spy && client._spy.dumpJSON(_, "NODE HANDLER: " + node.name , "args=" + JSON.stringify(args.slice(2)));
	trace && trace("NODE HANDLER: " + node.name + ": args=" + JSON.stringify(args.slice(2)));

	var results;
	var fn = node.skipHandler ? dummyHandler : client["listenNode" + node.name];
	if (fn) {
		results = fn.apply_(_, client, args, 0);
		
	} else {
		fn = client.activeRequest["listenNode" + node.name];
		if (fn) results = fn.apply_(_, client.activeRequest, args, 0);
		else throw new Error("LISTENER MISSING: " + node.name);
	}
	var acks = node.acks;
	var ack = 0;
	if (acks.length === 1 && results === undefined) results = [0]; // auto ack
	for (var i = 0; i < acks.length; i++) {
		if (acks[i] === '[') {
			i++;
			writeVals(_, client, acks[i], results[ack])
		} else {
			writeVal(_, client, acks[i], results[ack]);
		}
		ack++;
	}
}

function processRequest(_, client, reader, node) { /*  Caractere a Traite  */
	var car = reader.nextByte();
	trace && trace("car1="+car);
	if (car === 0) return node;

	while (node) {
		//console.log("node=" + node.name + ", car=0x" + car.toString(16));
		if (node.transitions) {
			var nextNode = node.transitions[car];
			if (nextNode) {
				//console.log("transition to " + nextNode.name);
				if (node.finish) node.finish(_, client, reader, car);
				processNode(_, client, reader, nextNode);
				node = nextNode;
				if (node.waitUser) return node;
				car = reader.nextByte(true);
				trace && trace("car2="+car);
				if (car === 0) return nextNode.def;
				else continue;
			}
		}
		/*  Fausse transition vers le Noeud Defaut  */
		if (node === node.def) {
			//return node;
			throw new Error("Infinite loop");
		}
		//console.log("transition to default");
		node = node.def;
	}
	return node;
}

function readRequest(_, client) {
	var head = client.stream.read(_, 3);
	var len = (head[1] << 8) | head[2];
	return new X3Reader(client, head[0], len ? client.stream.read(_, len) : new Buffer(0));
}

// was setting def to -40!!!

function process(_, client) {
	var reader, node = NODES[0];
	do {
		reader = readRequest(_, client);
		while (reader.peek() > 0 && node) {
			node = processRequest(_, client, reader, node);
		}
	} while (node && !node.waitUser);
	return node;
}

exports.MAP = MAP;
exports.process = process;
