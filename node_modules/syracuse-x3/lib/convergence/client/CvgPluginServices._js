"use strict";
var helpers = require('syracuse-core/lib/helpers');
var x3helpers = require("syracuse-x3/lib/helpers");
var CvgException = require('syracuse-x3/lib/convergence/model/CvgException').CvgException;
var CvgBlobSvc = require('syracuse-x3/lib/convergence/client/CvgBlobSvc').CvgBlobSvc;
var fs = require('fs');

var CvgPluginBlobSvc = helpers.defineClass(function(client) {
	CvgBlobSvc.call(this);
	this.plugin = client;
}, CvgBlobSvc, {

	doPut: function(_, context, tracker) {
		// create ACK_RESI
		var blob = new Buffer(context.request.readAll(_), 'binary');
		this.plugin.sendUpload(_, context, blob);

	},
	doPost: function(_, context, tracker) { // TODO review more generic implem because client and plugin analyse in post the same kind of content;
		var bodyStr = '';
		var buf, boundary;
		var match = /^multipart\/form-data;\s*boundary=(.*)/.exec(context.request.headers["content-type"]);
		if (match) {
			boundary = match[1];
			buf = context.request.read(_, 2048);
			var lines = buf.toString("binary").split('\n');
			if (lines[0].indexOf(boundary) < 0) {
				throw new Error("boundary not found");
			}
			var i;
			for (i = 0; i < lines.length; i++) {
				if (/^\r?$/.test(lines[i])) {
					break;
				}
			}
			len = 0;
			while (i >= 0) {
				len += lines[i--].length + 1;
			}
			context.request.unread(buf.slice(len));
		}
		if (boundary) {
			len = Math.max(boundary.length, 256);

			var s, idx;
			while ((buf = context.request.read(_, 32 * len))) {
				s = buf.toString("binary");
				idx = s.indexOf(boundary);
				if (idx >= 0) {
					idx = s.lastIndexOf('\n', idx);
					bodyStr += s.substring(0, idx);
					context.request.readAll(_); // discard any trailing data
				} else {
					bodyStr += s.substring(0, 31 * len);
					context.request.unread(buf.slice(31 * len));
				}
			}
		}
		var blob = new Buffer(bodyStr, 'binary');
		this.plugin.sendUpload(_, context, blob);
	}

});

exports.create = function(client) {
	return {
		blobSvc: new CvgPluginBlobSvc(client)
	};
};