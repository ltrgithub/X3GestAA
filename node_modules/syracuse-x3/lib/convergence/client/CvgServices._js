"use strict";
var helpers = require('syracuse-core/lib/helpers');
var x3helpers = require("syracuse-x3/lib/helpers");
var CvgException = require('syracuse-x3/lib/convergence/model/CvgException').CvgException;
var fs = require('fs');

var CvgBlobSvc = exports.CvgBlobSvc = helpers.defineClass(function(_, client) {
	this.client = client;
	this.blobs = {};
}, null, {
	// type can be 'image' to make others mime types forbidden
	register: function(uuid, binary, type, options) {
		//console.log("Register: "+uuid);		
		this.blobs[uuid[0]] = this.blobs[uuid[0]] || {};
		this.blobs[uuid[0]][uuid.substring(1, uuid.length)] = {
			mimeType: (options && options.mimeType) || this.calcMimeType(binary, type),
			binary: binary
		};

		if (options && options.filename) this.blobs[uuid[0]][uuid.substring(1, uuid.length)].filename = options.filename;
		return this.blobs[uuid[0]];
	},
	unregister: function(uuid) {
		//console.log("Unregister: "+uuid);
		delete this.blobs[uuid[0]];
	},
	getBlob: function(uuid) {
		//console.log("Get blob: "+uuid);
		var screen = this.blobs[uuid[0]];
		return screen && screen[uuid.substring(1, uuid.length)];
	},
	processRequest: function(_, context, bodyStr) {
		var error = null;
		var header = {};
		var data = {}, dataType = 'utf8';
		var statusCode, type, len, binary, blob;
		try {
			var id = context.parameters.id;
			switch (context.method) {
				case 'get':
					//console.log("GET: "+id);
					//console.log("context.parameters : "+JSON.stringify(context.parameters,null,2));
					blob = this.getBlob(id);
					if (blob && blob.mimeType) {
						header["content-type"] = blob.mimeType;
					}
					if (blob && blob.filename) header["Content-Disposition"] = 'attachment; filename="' + blob.filename + '"';

					if (blob && blob.mimeType && blob.binary) {
						data = blob.binary;
						dataType = 'binary';
					}
					statusCode = !blob ? 404 : 200;

					break;
				case 'put':
					//console.log("PUT: "+id);
					bodyStr = bodyStr || context.request.readAll(_);
					type = context.parameters.type;
					if (!id) throw new Error("Bad blob ID.");
					binary = new Buffer(bodyStr, 'binary');
					this.register(id, binary, type);
					header["content-type"] = 'application/json';
					statusCode = 201;
					break;
				case 'post':
					// IE
					type = context.parameters.type;

					if (!id) throw new Error("Bad blob ID.");


					// getting binary
					bodyStr = '';
					var buf;
					var filename, contentType, boundary;
					var match = /^multipart\/form-data;\s*boundary=(.*)/.exec(context.request.headers["content-type"]);
					if (match) {
						boundary = match[1];
						buf = context.request.read(_, 2048);
						var lines = buf.toString("binary").split('\n');
						if (lines[0].indexOf(boundary) < 0) throw new Error("boundary not found");
						var i = 0;
						for (; i < lines.length; i++) {
							if (/^\r?$/.test(lines[i])) break;
						}
						len = 0;
						while (i >= 0) len += lines[i--].length + 1;
						context.request.unread(buf.slice(len));
					}
					if (boundary) {
						len = Math.max(boundary.length, 256);

						while ((buf = context.request.read(_, 32 * len))) {
							var s = buf.toString("binary");
							var idx = s.indexOf(boundary);
							if (idx >= 0) {
								idx = s.lastIndexOf('\n', idx);
								bodyStr += s.substring(0, idx);
								context.request.readAll(_); // discard any trailing data
							} else {
								bodyStr += s.substring(0, 31 * len);
								context.request.unread(buf.slice(31 * len));
							}
						}
					}
					binary = new Buffer(bodyStr, 'binary');
					this.register(id, binary, type);
					header["content-type"] = 'text/html';
					statusCode = 201;
					break;
				case 'delete':
					//console.log("DELETE: "+id);
					blob = this.getBlob(id);
					// If not exist register again
					if (!blob) blob = this.register(id, '');
					blob.binary = '';
					header["content-type"] = 'application/json';
					statusCode = 204;
					break;
				default:
					throw new Error("bad method: " + context.method);
			}

		} catch (e) {
			error = new CvgException(this.client, e, "Blob service error");
			header["content-type"] = 'application/json';
			statusCode = 500;
			data.$diagnoses = [];
			data.$diagnoses.push(JSON.parse(JSON.stringify(error.diagnose)));
			data = JSON.stringify(data);
		}

		//console.log("blobs: "+JSON.stringify(this.blobs,null,2));
		context.response.writeHead(statusCode, header);
		context.response.write(_, data, dataType);
		context.response.end();

	},
	// if type = 'image' -> control data mime type as gif | jpeg | bmp | png | tif
	calcMimeType: function(bin, type) {
		if (this.isBlobImgGif(bin)) {
			return "image/gif";
		} else if (this.isBlobImgJpg(bin)) {
			return "image/jpeg";
		} else if (this.isBlobImgBMP(bin)) {
			return "image/bmp";
		} else if (this.isBlobImgPng(bin)) {
			return "image/png";
		} else if (this.isBlobImgTiff(bin)) {
			return "image/tiff";
		} else {
			if (type && type.indexOf('image') === 0) throw new Error("Data mime type is not matching authorized image type.");
			return "application/octet-stream";
		}
	},

	/**
	 * BMP Structure du fichier BMP - format OS/2: Relativement à ce que nous
	 * venons de voir, nous voyons que le fichier OS/2 et Windows commencent par
	 * BM, on peut supposer que cela signifie "ceci est un fichier de type BMP"
	 * ensuite le codage diffère. Je suppose que dans l'octet qui suit,
	 * l'information relative à l'option du format OS/2 ou Windows est presente
	 * (0x3E pour OS/2 et 0x5A pour Windows)
	 *
	 * @param bin
	 * @return
	 */
	isBlobImgBMP: function(bin) {
		return bin[0] === 0x42 && bin[1] === 0x4d;
	},

	/**
	 *
	 * GIF Le premier objet rencontre dans un fichier GIF est la "signature"; il
	 * s'agit d'une chaîne de caractères qui permet aux programmes de decodages
	 * de savoir qu'ils manipulent des images GIF. Il n'est pas surprenant de
	 * voir que cette chaîne contient le mot "GIF".
	 *
	 * Le fichier GIF porte generalement la signature GIF87a, les trois
	 * dernières lettres representant des evolution du format et des revision de
	 * ce format. Seules les trois premières lettres de cette chaîne doivent
	 * être testees pour verifier la validite du fichier. Si vous êtes très
	 * pointilleux, vous pouvez modifier le decodeur de manière à ce qu'il
	 * affiche un message d'avertissement quand le numero de revision lu est
	 * different de celui de la signature classique.
	 *
	 * Le standard GIF originel s'appelle GIF87a. Ce format a maintenant evolue
	 * en GIF89a, mais les fichiers GIF sont compatibles descendant avec la
	 * version GIF87a, car la plupart des ameliorations du format consistent en
	 * des elements optionnels comme des texte de commentaires et des options
	 * d'animation.
	 *
	 * Un fichier GIF peut contenir plusieurs images. Il vous est alors possible
	 * de visualiser une image pendant que le programme de decodage decompresse
	 * les images suivantes. Aussi, un en-tête GIF contient des donnees globales
	 * et des donnees locales. Les donnees globales sont associees à toutes les
	 * images du fichier, tandis que les donnees locales ne sont associees qu'à
	 * une seule image de ce fichier.
	 *
	 * Les programmes d'encodages d'images au format GIF traitent cette
	 * distinction de plusieurs manières differentes et un programme de decodage
	 * doit être en mesure de les manipuler, même si vous ne vous interessez
	 * qu'à une seule image dans un même fichier. Pour des fichiers qui ne
	 * contiennent qu'une image, ce qui est generalement le cas, la plupart des
	 * donnees globales et locales ont le même effet, et seul un ensemble de
	 * donnees (globales ou locales) est generalement present dans le fichier.
	 *
	 * L'objet rencontre après la signature dans un fichier GIF est le
	 * "descripteur d'ecran". Ce champ marque le commencement des donnees
	 * globales. La nature de l'ecran qui a servi lors de la creation de l'image
	 * fait partie integrante du format. En pratique, vous ignorez ce champ.
	 *
	 * Les dimensions de l'ecran qui sont stockees dans le fichier n'ont pas
	 * grand chose à voir avec les dimmensions reelles des images contenues dans
	 * ce même fichier. Le descripteur d'ecran ne fait que definir la taille de
	 * l'ecran qui a servi à creer le fichier. Le fragment de programme suivant
	 * montre la structure d'un en-tête de fichier GIF:
	 *
	 * typedef struct { char sig[6]; unsigned int screenwidth, screendepth;
	 * unsigned char flags, background, aspect; } GIFHEADER;
	 *
	 * @param bin
	 * @return
	 */
	isBlobImgGif: function(bin) {
		return bin[0] === 0x47 && bin[1] === 0x49 && bin[2] === 0x46;
	},

	/**
	 *
	 * JPEG marqueur SOI : FFD8
	 *
	 * @param bin
	 * @return
	 */
	isBlobImgJpg: function(bin) {
		return bin[0] === 0xff && bin[1] === 0xd8;
	},

	/**
	 *
	 * PNG file signature The first eight bytes of a PNG file always contain the
	 * following (decimal) values: 137 80 78 71 13 10 26 10
	 *
	 * This signature indicates that the remainder of the file contains a single
	 * PNG image, consisting of a series of chunks beginning with an IHDR chunk
	 * and ending with an IEND chunk.
	 *
	 * The first eight bytes of a PNG file always contain the following values:
	 * (decimal) 137 80 78 71 13 10 26 10 (hexadecimal) 89 50 4e 47 0d 0a 1a 0a
	 * (ASCII C notation) \211 P N G \r \n \032 \n
	 *
	 * This signature both identifies the file as a PNG file and provides for
	 * immediate detection of common file-transfer problems. The first two bytes
	 * distinguish PNG files on systems that expect the first two bytes to
	 * identify the file type uniquely. The first byte is chosen as a non-ASCII
	 * value to reduce the probability that a text file may be misrecognized as
	 * a PNG file; also, it catches bad file transfers that clear bit 7. Bytes
	 * two through four name the format. The CR-LF sequence catches bad file
	 * transfers that alter newline sequences. The control-Z character stops
	 * file display under MS-DOS. The final line feed checks for the inverse of
	 * the CR-LF translation problem.
	 *
	 * A decoder may further verify that the next eight bytes contain an IHDR
	 * chunk header with the correct chunk length; this will catch bad transfers
	 * that drop or alter null (zero) bytes.
	 *
	 * Note that there is no version number in the signature, nor indeed
	 * anywhere in the file. This is intentional: the chunk mechanism provides a
	 * better, more flexible way to handle format extensions, as explained in
	 * Chunk naming conventions.
	 *
	 * @param bin
	 * @return
	 */
	isBlobImgPng: function(bin) {
		return bin[0] === 137 && bin[1] === 80 && bin[2] === 78 && bin[3] === 71 && bin[4] === 13 && bin[5] === 10 && bin[6] === 26 && bin[7] === 10;
	},

	/**
	 *
	 * TIFF Tous les fichiers TIFF commencent par les deux octets 0x49 0x49 ou
	 * 0x4D 0x4D qui sont les codes ASCII des caracteres alphabetiques
	 * respectivement I ou M Le I indique INTEL et le M MOTOROLA, les deux
	 * principaux fournisseurs de micro-processeurs respectivement pour les
	 * IBM-PC et les MACINTOSH Cette distinction est importante pour l?ordre
	 * dans lequel sont rangees les octets representant des valeurs numeriques.
	 * Pour les micro-processeurs Motorola, l?ordre est normal, a savoir valeur
	 * la plus significative a gauche. Pour les micro-processeurs Intel par
	 * contre, cet ordre est inverse, ce qui implique une petite gymnastique
	 * pour la conversion. Le troisieme octet 0x2A = 42 en decimal represente le
	 * numero de version du standard TIFF : 42 dans notre cas. Les 4 octets
	 * suivants apres remise en ordre (le h49 indique que nous sommes chez
	 * Intel) donnent h0008= 8, qui est la longueur de l?en-tete. Nous trouvons
	 * donc 8 octets plus loin la valeur h15=21 qui est le nombre de ?tags? du
	 * fichier. Ces tags ont une longueur fixe de 12 octets et sont identifies
	 * par un numero normalise qui fait toute la richesse du systeme. La figure
	 * 24 montre la structure d?un fichier TIFF
	 *
	 * @param bin
	 * @return
	 */
	isBlobImgTiff: function(bin) {
		return (bin[0] === 0x4D && bin[1] === 0x4D) || (bin[0] === 0x49 && bin[1] === 0x49);
	},
});

exports.create = function(_, client) {
	return {
		blobSvc: new CvgBlobSvc(_, client)
	};
};