"use strict";
var helpers = require('syracuse-core/lib/helpers');
var x3helpers = require("syracuse-x3/lib/helpers");
var CvgException = require('syracuse-x3/lib/convergence/model/CvgException').CvgException;
var fs = require('fs');

var CvgBlobSvc = helpers.defineClass(function(_, client) {
	this.client = client;
	this.blobs = {};
}, null, {
	// type can be 'image' to make others mime types forbidden
	register: function(uuid, binary, type, options) {
		//console.log("Register: "+uuid);		
		this.blobs[uuid[0]] = this.blobs[uuid[0]] || {};
		this.blobs[uuid[0]][uuid.substring(1, uuid.length)] = {
			mimeType: (options && options.mimeType) || this.calcMimeType(binary, type),
			binary: binary
		};

		if (options && options.filename) {
			this.blobs[uuid[0]][uuid.substring(1, uuid.length)].filename = options.filename;
		}
		return this.blobs[uuid[0]];
	},
	unregister: function(uuid) {
		//console.log("Unregister: "+uuid);
		//SAM 112012 - delete the blob in the screen and not all the blob in the screen
		var screen = this.blobs[uuid[0]];
		if (screen && screen[uuid.substring(1, uuid.length)]) {
			delete screen[uuid.substring(1, uuid.length)];
			if (Object.keys(screen).length === 0) {
				delete this.blobs[uuid[0]];
			}
		}
	},
	getBlob: function(uuid) {
		//console.log("Get blob: "+uuid);
		var screen = this.blobs[uuid[0]];
		return screen && screen[uuid.substring(1, uuid.length)];
	},
	processRequest: function(_, context, bodyStr) {
		var error = null;
		var header = {};
		var data = {}, dataType = 'utf8';
		var statusCode, type, len, binary, blob;
		try {
			var id = context.parameters.id;
			switch (context.method) {
				case 'get':
					//console.log("GET: "+id);
					//console.log("context.parameters : "+JSON.stringify(context.parameters,null,2));
					blob = this.getBlob(id);
					if (blob && blob.mimeType) {
						header["content-type"] = blob.mimeType;
					}
					if (blob && blob.filename) {
						header["Content-Disposition"] = 'attachment; filename="' + blob.filename + '"';
					}

					if (blob && blob.mimeType && blob.binary) {
						data = blob.binary;
						dataType = 'binary';
					}
					statusCode = !blob ? 404 : 200;

					break;
				case 'put':
					//console.log("PUT: "+id);
					bodyStr = bodyStr || context.request.readAll(_);
					type = context.parameters.type;
					if (!id) {
						throw new Error("Bad blob ID.");
					}
					binary = new Buffer(bodyStr, 'binary');
					this.register(id, binary, type);
					header["content-type"] = 'application/json';
					statusCode = 201;
					break;
				case 'post':
					// IE
					type = context.parameters.type;

					if (!id) {
						throw new Error("Bad blob ID.");
					}

					// getting binary
					bodyStr = '';
					var buf, boundary;
					var match = /^multipart\/form-data;\s*boundary=(.*)/.exec(context.request.headers["content-type"]);
					if (match) {
						boundary = match[1];
						buf = context.request.read(_, 2048);
						var lines = buf.toString("binary").split('\n');
						if (lines[0].indexOf(boundary) < 0) {
							throw new Error("boundary not found");
						}
						var i;
						for (i = 0; i < lines.length; i++) {
							if (/^\r?$/.test(lines[i])) {
								break;
							}
						}
						len = 0;
						while (i >= 0) {
							len += lines[i--].length + 1;
						}
						context.request.unread(buf.slice(len));
					}
					if (boundary) {
						len = Math.max(boundary.length, 256);

						var s, idx;
						while ((buf = context.request.read(_, 32 * len))) {
							s = buf.toString("binary");
							idx = s.indexOf(boundary);
							if (idx >= 0) {
								idx = s.lastIndexOf('\n', idx);
								bodyStr += s.substring(0, idx);
								context.request.readAll(_); // discard any trailing data
							} else {
								bodyStr += s.substring(0, 31 * len);
								context.request.unread(buf.slice(31 * len));
							}
						}
					}
					binary = new Buffer(bodyStr, 'binary');
					this.register(id, binary, type);
					header["content-type"] = 'text/html';
					statusCode = 201;
					break;
				case 'delete':
					//console.log("DELETE: "+id);
					blob = this.getBlob(id);
					// If not exist register again
					if (!blob) {
						blob = this.register(id, '');
					}
					blob.binary = '';
					header["content-type"] = 'application/json';
					statusCode = 204;
					break;
				default:
					throw new Error("bad method: " + context.method);
			}

		} catch (e) {
			error = new CvgException(this.client, e, "Blob service error");
			header["content-type"] = 'application/json';
			statusCode = 500;
			data.$diagnoses = [];
			data.$diagnoses.push(JSON.parse(JSON.stringify(error.diagnose)));
			data = JSON.stringify(data);
		}

		//console.log("blobs: "+JSON.stringify(this.blobs,null,2));
		context.response.writeHead(statusCode, header);
		context.response.write(_, data, dataType);
		context.response.end();

	},
	// if type = 'image' -> control data mime type as gif | jpeg | bmp | png | tif
	calcMimeType: function(bin, type) {
		var mimeType = "application/octet-stream";
		if (this.isBlobImgGif(bin)) {
			mimeType = "image/gif";
		} else if (this.isBlobImgJpg(bin)) {
			mimeType = "image/jpeg";
		} else if (this.isBlobImgBMP(bin)) {
			mimeType = "image/bmp";
		} else if (this.isBlobImgPng(bin)) {
			mimeType = "image/png";
		} else if (this.isBlobImgTiff(bin)) {
			mimeType = "image/tiff";
		} else if (type && type.indexOf('image') === 0) {
			throw new Error("Data mime type does not match any authorized image type.");
		}
		return mimeType;
	},

	/**
	 * BMP File contains 0x42 0x4d ("BM") in the first two bytes of the file header
	 *
	 * For more information see:
	 * http://en.wikipedia.org/wiki/.BMP
	 *
	 * @param bin
	 * @return
	 */
	isBlobImgBMP: function(bin) {
		return bin[0] === 0x42 && bin[1] === 0x4d;
	},

	/**
	 * GIF Files are identified by the first three characters containing
	 * 0x47 0x49 0x46 - ("GIF") the following 3 characters "87a" or "89a"
	 *
	 * For more information see:
	 * http://en.wikipedia.org/wiki/.GIF
	 *
	 * @param bin
	 * @return
	 */
	isBlobImgGif: function(bin) {
		return bin[0] === 0x47 && bin[1] === 0x49 && bin[2] === 0x46;
	},

	/**
	 *
	 * JPEG SOI (Start of Image) marker : 0xFF 0xD8
	 *
	 * For more information see:
	 * http://en.wikipedia.org/wiki/.JPEG
	 *
	 * @param bin
	 * @return
	 */
	isBlobImgJpg: function(bin) {
		return bin[0] === 0xff && bin[1] === 0xd8;
	},

	/**
	 *
	 * PNG file signature The first eight bytes of a PNG file always contain the
	 * following (hex) 0x89 0x50 0x4e 0x47 0x0d 0x0a 0x1a 0x0a
	 * (ASCII C notation) \211 P N G \r \n \032 \n
	 *
	 * For more information see:
	 * http://en.wikipedia.org/wiki/.PNG
	 *
	 * @param bin
	 * @return
	 */
	isBlobImgPng: function(bin) {
		return bin[0] === 137 && bin[1] === 80 && bin[2] === 78 && bin[3] === 71 && bin[4] === 13 && bin[5] === 10 && bin[6] === 26 && bin[7] === 10;
	},

	/**
	 * TIFF files all begin with a two byte indicator of the byte order
	 * "II" (0x49 0x49) for little-endian (i.e. Intel) or "MM" (0x4D 0x4D) for
	 * big-endian (i.e. Motorola)
	 *
	 * For more information see:
	 * http://en.wikipedia.org/wiki/TIFF
	 *
	 * @param bin
	 * @return
	 */
	isBlobImgTiff: function(bin) {
		return (bin[0] === 0x4D && bin[1] === 0x4D) || (bin[0] === 0x49 && bin[1] === 0x49);
	}
});

exports.create = function(_, client) {
	return {
		blobSvc: new CvgBlobSvc(_, client)
	};
};