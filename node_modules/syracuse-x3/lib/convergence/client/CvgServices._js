"use strict";
var helpers = require('syracuse-core/lib/helpers');
var x3helpers = require("syracuse-x3/lib/helpers");
var CvgException = require('syracuse-x3/lib/convergence/model/CvgException').CvgException;


var CvgBlobSvc = exports.CvgBlobSvc = helpers.defineClass(function(_, client) {
	this.client = client;
	this.blobs = {}
}, null, {
	// type can be 'image' to make others mime types forbidden
	register: function(uuid, binary, type) {
		//console.log("Register: "+uuid);
		this.blobs[uuid[0]] = this.blobs[uuid[0]] || {};
		this.blobs[uuid[0]][uuid.substring(1,uuid.length)] = {
			mimeType: this.calcMimeType(binary, type), 
			binary: binary
		};
		return this.blobs[uuid[0]];
	},
	unregister: function(uuid) {
		//console.log("Unregister: "+uuid);
		delete this.blobs[uuid[0]];
	},
	getBlob: function(uuid) {
		//console.log("Get blob: "+uuid);
		var screen = this.blobs[uuid[0]];
		return screen && screen[uuid.substring(1,uuid.length)]
	},
	processRequest: function(_, context) {
			var error = null;
			var header = {};
			
			var data = {}, dataType = 'utf8';
			var statusCode;
			try{
				var id = context.parameters.id;
				switch(context.method) {
				case 'get':
					//console.log("GET: "+id);
					//console.log("context.parameters : "+JSON.stringify(context.parameters,null,2));
					var blob = this.getBlob(id);
					if (blob && blob.mimeType)
						header["content-type"] = blob.mimeType;
					
					if (blob && blob.mimeType && blob.binary) {
						data = blob.binary;
						dataType = 'binary';
					}
					statusCode = !blob ? 204 : 200;
					
					break;
				case 'put':
					//console.log("PUT: "+id);
					var type = context.parameters.type;
					if (!id) throw new Error("Bad blob ID.");
					var binary = new Buffer(context.request.readAll(_), 'binary');
					this.register(id, binary, type);
					header["content-type"] = 'application/json';
					statusCode = 200;
					break;
				case 'delete':
					//console.log("DELETE: "+id);
					var blob = this.getBlob(id);
					// If not exist register again
					if (!blob) blob = this.register(id, '');
					blob.binary = '';
					header["content-type"] = 'application/json';
					statusCode = 200;
					break;
				default:
					throw new Error("bad method: " + context.method);
				}
							
			}catch(e){
				error = new CvgException(this.client, e, "Blob service error");
				header["content-type"] = 'application/json';
				statusCode = 500;
				data.$diagnoses = [];
				data.$diagnoses.push(JSON.parse(JSON.stringify(error.diagnose)));
				data = JSON.stringify(data);
			}

			//console.log("blobs: "+JSON.stringify(this.blobs,null,2));
			context.response.writeHead(statusCode, header);
			context.response.write(_, data, dataType);
			context.response.end();

	},
	// if type = 'image' -> control data mime type as gif | jpeg | bmp | png | tif
	calcMimeType: function(bin, type) {
		if (this.isBlobImgGif(bin)) {
			return "image/gif";
		} else if (this.isBlobImgJpg(bin)) {
			return "image/jpeg";
		} else if (this.isBlobImgBMP(bin)) {
			return "image/bmp";
		} else if (this.isBlobImgPng(bin)) {
			return "image/png";
		} else if (this.isBlobImgTiff(bin)) {
			return "image/tiff";
		} else {
			if (type && type === 'image')
				throw new Error("Data mime type is not matching authorized image type.");
			return "application/octet-stream";
		}
	},
	
	/**
	 * BMP Structure du fichier BMP - format OS/2: Relativement à ce que nous
	 * venons de voir, nous voyons que le fichier OS/2 et Windows commencent par
	 * BM, on peut supposer que cela signifie "ceci est un fichier de type BMP"
	 * ensuite le codage diffère. Je suppose que dans l'octet qui suit,
	 * l'information relative à l'option du format OS/2 ou Windows est présente
	 * (0x3E pour OS/2 et 0x5A pour Windows)
	 * 
	 * @param bin
	 * @return
	 */
	isBlobImgBMP: function(bin) {
		return bin[0] === 'B' && bin[1] === 'M';
	},

	/**
	 * 
	 * GIF Le premier objet rencontré dans un fichier GIF est la "signature"; il
	 * s'agit d'une chaîne de caractères qui permet aux programmes de décodages
	 * de savoir qu'ils manipulent des images GIF. Il n'est pas surprenant de
	 * voir que cette chaîne contient le mot "GIF".
	 * 
	 * Le fichier GIF porte généralement la signature GIF87a, les trois
	 * dernières lettres représentant des évolution du format et des révision de
	 * ce format. Seules les trois premières lettres de cette chaîne doivent
	 * être testées pour vérifier la validité du fichier. Si vous êtes très
	 * pointilleux, vous pouvez modifier le décodeur de manière à ce qu'il
	 * affiche un message d'avertissement quand le numéro de révision lu est
	 * différent de celui de la signature classique.
	 * 
	 * Le standard GIF originel s'appelle GIF87a. Ce format a maintenant évolué
	 * en GIF89a, mais les fichiers GIF sont compatibles descendant avec la
	 * version GIF87a, car la plupart des améliorations du format consistent en
	 * des éléments optionnels comme des texte de commentaires et des options
	 * d'animation.
	 * 
	 * Un fichier GIF peut contenir plusieurs images. Il vous est alors possible
	 * de visualiser une image pendant que le programme de décodage décompresse
	 * les images suivantes. Aussi, un en-tête GIF contient des données globales
	 * et des données locales. Les données globales sont associées à toutes les
	 * images du fichier, tandis que les données locales ne sont associées qu'à
	 * une seule image de ce fichier.
	 * 
	 * Les programmes d'encodages d'images au format GIF traitent cette
	 * distinction de plusieurs manières différentes et un programme de décodage
	 * doit être en mesure de les manipuler, même si vous ne vous intéréssez
	 * qu'à une seule image dans un même fichier. Pour des fichiers qui ne
	 * contiennent qu'une image, ce qui est généralement le cas, la plupart des
	 * données globales et locales ont le même effet, et seul un ensemble de
	 * données (globales ou locales) est généralement présent dans le fichier.
	 * 
	 * L'objet rencontré après la signature dans un fichier GIF est le
	 * "descripteur d'écran". Ce champ marque le commencement des données
	 * globales. La nature de l'écran qui a servi lors de la création de l'image
	 * fait partie intégrante du format. En pratique, vous ignorez ce champ.
	 * 
	 * Les dimensions de l'écran qui sont stockées dans le fichier n'ont pas
	 * grand chose à voir avec les dimmensions réelles des images contenues dans
	 * ce même fichier. Le descripteur d'écran ne fait que définir la taille de
	 * l'écran qui a servi à créer le fichier. Le fragment de programme suivant
	 * montre la structure d'un en-tête de fichier GIF:
	 * 
	 * typedef struct { char sig[6]; unsigned int screenwidth, screendepth;
	 * unsigned char flags, background, aspect; } GIFHEADER;
	 * 
	 * @param bin
	 * @return
	 */
	isBlobImgGif: function(bin) {
		return bin[0] === 'G' && bin[1] === 'I' && bin[2] === 'F';
	},

	/**
	 * 
	 * JPEG marqueur SOI : FFD8
	 * 
	 * @param bin
	 * @return
	 */
	isBlobImgJpg: function(bin) {
		return bin[0] === 0xff && bin[1] === 0xd8;
	},

	/**
	 * 
	 * PNG file signature The first eight bytes of a PNG file always contain the
	 * following (decimal) values: 137 80 78 71 13 10 26 10
	 * 
	 * This signature indicates that the remainder of the file contains a single
	 * PNG image, consisting of a series of chunks beginning with an IHDR chunk
	 * and ending with an IEND chunk.
	 * 
	 * The first eight bytes of a PNG file always contain the following values:
	 * (decimal) 137 80 78 71 13 10 26 10 (hexadecimal) 89 50 4e 47 0d 0a 1a 0a
	 * (ASCII C notation) \211 P N G \r \n \032 \n
	 * 
	 * This signature both identifies the file as a PNG file and provides for
	 * immediate detection of common file-transfer problems. The first two bytes
	 * distinguish PNG files on systems that expect the first two bytes to
	 * identify the file type uniquely. The first byte is chosen as a non-ASCII
	 * value to reduce the probability that a text file may be misrecognized as
	 * a PNG file; also, it catches bad file transfers that clear bit 7. Bytes
	 * two through four name the format. The CR-LF sequence catches bad file
	 * transfers that alter newline sequences. The control-Z character stops
	 * file display under MS-DOS. The final line feed checks for the inverse of
	 * the CR-LF translation problem.
	 * 
	 * A decoder may further verify that the next eight bytes contain an IHDR
	 * chunk header with the correct chunk length; this will catch bad transfers
	 * that drop or alter null (zero) bytes.
	 * 
	 * Note that there is no version number in the signature, nor indeed
	 * anywhere in the file. This is intentional: the chunk mechanism provides a
	 * better, more flexible way to handle format extensions, as explained in
	 * Chunk naming conventions.
	 * 
	 * @param bin
	 * @return
	 */
	isBlobImgPng: function(bin) {
		return bin[0] === 137 && bin[1] === 80 && bin[2] === 78 && bin[3] === 71 && bin[4] === 13 && bin[5] === 10 && bin[6] === 26 && bin[7] === 10
	},

	/**
	 * 
	 * TIFF Tous les fichiers TIFF commencent par les deux octets 0x49 0x49 ou
	 * 0x4D 0x4D qui sont les codes ASCII des caractères alphabétiques
	 * respectivement I ou M Le I indique INTEL et le M MOTOROLA, les deux
	 * principaux fournisseurs de micro-processeurs respectivement pour les
	 * IBM-PC et les MACINTOSH. Cette distinction est importante pour lordre
	 * dans lequel sont rangées les octets représentant des valeurs numériques.
	 * Pour les micro-processeurs Motorola, lordre est normal, à savoir valeur
	 * la plus significative à gauche. Pour les micro-processeurs Intel par
	 * contre, cet ordre est inversé, ce qui implique une petite gymnastique
	 * pour la conversion. Le troisième octet 0x2A = 42 en décimal représente le
	 * numéro de version du standard TIFF : 42 dans notre cas. Les 4 octets
	 * suivants après remise en ordre (le h49 indique que nous sommes chez
	 * Intel) donnent h0008= 8, qui est la longueur de len-tête. Nous trouvons
	 * donc 8 octets plus loin la valeur h15=21 qui est le nombre de tags du
	 * fichier. Ces tags ont une longueur fixe de 12 octets et sont identifiés
	 * par un numéro normalisé qui fait toute la richesse du système. La figure
	 * 24 montre la structure dun fichier TIFF.
	 * 
	 * @param bin
	 * @return
	 */
	isBlobImgTiff: function(bin) {
		return (bin[0] === 0x4D && bin[1] === 0x4D) || (bin[0] === 0x49 && bin[1] === 0x49);
	},
});


		
		
var CvgFormatSvc = exports.CvgBlobSvc = helpers.defineClass(function(_, client) {
	this.client = client;
	
	
}, null, {
	processRequest: function(_, context) {
			if (context.method !== 'put') throw new Error("bad method: " + context.method);
			var act = context.parameters.act;
			var post = JSON.parse(context.request.readAll(_));
			
			//console.log("FORMATTER SVC POST : "+JSON.stringify(post,null,2));
			

			var act = context.parameters.svc;
			var val = post.value;
			var fmt = {format: post.fmt};
			var typ = post.typ;
			
			var result, error;
			
			if (!val) {
				result = "";
			} else if (fmt == null || fmt.length < 2) {
				result = val;
			} else {
				try{
					switch(act) {
					case 'toRaw':
						// la valeur en entree correspond a du ‘Edit ou du ‘Display
						// , renvoyer la valeur au format interne x3 (YYYYMMDD)
						result = this.formatRaw(val, fmt);
						break;
					case 'toDisp':
						// la valeur en entree correspond a du ‘Edit ou du ‘Display
						// , renvoyer la valeur mise en forme selon le format «
						// Display »
						result = this.formatDisp(val, fmt, false);
						break;
					case 'toEdit':
						// la valeur en entree correspond a du ‘Edit ou du ‘Display
						// , renvoyer la valeur mise en forme selon le format « Edit
						// »
						result = this.formatEdit(val, fmt, typ, false);
						break;
					case 'rawToEdit':
						// a partir d’une valeur au format interne x3 (YYYYMMDD),
						// renvoyer la valeur mise en forme selon le format « Edit »
						result = this.formatEdit(val, fmt, typ, true);
						break;
					case 'rawToDisp':
						// a partir d’une valeur au format interne x3 (YYYYMMDD),
						// renvoyer la valeur mise en forme selon le format «
						// Display »
						result = this.formatDisp(val, fmt, true);
						break;
					default:
						throw new Error("Unknow action [" + act + "]");
					}
				} catch(e) {
					result = null
					error = new CvgException(this.client, e, "Formatter service error");
					data.$diagnoses = [];
					data.$diagnoses.push(JSON.parse(JSON.stringify(error.diagnose)));
				}

			}

			data.result = result;

			context.response.writeHead((error || !result) ? 500 : 200, {
				"content-type": "application/json",
			});
			context.response.write(_, JSON.stringify(data), 'utf8');
			context.response.end();
	},
	
	// --------------------------------------------------------------------
	// Disp ou Edit-> Disp
	formatDisp: function(val, fmt, raw) {
		var strict = true;
		if (!raw) {
			try {
				// Si val est un valeur formatee X3 alors le unformat renvoie la
				// valeur X3
				r = this.client.formater.unformatField(fmt, val, true);
				return this.client.formater.formatField(fmt, r, true, strict);
			} catch (e) {
			}
			// val n'est pas une valeur au format x3 - Valeur saisie par
			// l'utilisateur
			return this.client.formater.formatField(fmt, val, false, strict);
		} else {
			return this.client.formater.formatField(fmt, val, true, strict);
		}

	},

	// --------------------------------------------------------------------
	// Disp ou Edit-> Edit
	formatEdit: function(val, fmtStr, typ, raw) {
		return this.client.formater.inputGetFocusInValue(fmtStr, val, raw);
	},
	
	// --------------------------------------------------------------------
	// Disp ou Edit-> Raw
	formatRaw: function(val, fmt) {
		try {
			// Si val est un valeur formatee X3 alors le unformat renvoie la
			// valeur X3
			// Sinon erreur
			return this.client.formater.unformatField(fmt, val, true);
		} catch (e) {
		}
		// val n'est pas une valeur au format x3 - Valeur saisie par
		// l'utilisateur
		// On formate puis deformate
		val = this.client.formater.formatField(fmt, val, false);
		return this.client.formater.unformatField(fmt, val, true);
	},

});



exports.create = function(_, client) {
	return {
		blobSvc: new CvgBlobSvc(_, client),
		formatSvc: new CvgFormatSvc(_, client),
	}
}
