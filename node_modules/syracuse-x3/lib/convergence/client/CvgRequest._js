"use strict";
var helpers = require('syracuse-core/lib/helpers');
var locale = require("syracuse-core/lib/locale");
var flows = require('streamline/lib/util/flows');
var jsxml = require('jsxml');
var x3writer = require("syracuse-x3/lib/convergence/automata/x3writer");
var CvgModifier = require('syracuse-x3/lib/convergence/model/CvgModifier').CvgModifier;
var CvgDataSrc = require('syracuse-x3/lib/convergence/model/CvgDataSrc').CvgDataSrc;
var CvgEntity = require('syracuse-x3/lib/convergence/model/CvgEntity').CvgEntity;
var CvgAction = require('syracuse-x3/lib/convergence/client/CvgAction').Actions;
var CvgFormat = require('syracuse-x3/lib/convergence/model/CvgFormat').CvgFormat;
var CvgResu = require('syracuse-x3/lib/convergence/types/CvgResu').CvgResu;
var CvgResuTdo = require('syracuse-x3/lib/convergence/types/CvgResu').TDO;
var CvgResuTag = require('syracuse-x3/lib/convergence/types/CvgResu').TAG;
var CvgIst = require('syracuse-x3/lib/convergence/types/CvgIst').CvgIst;
var CvgLeftListLineNode = require('syracuse-x3/lib/convergence/model/CvgLeftListLineNode').CvgLeftListLineNode;
var CvgException = require('syracuse-x3/lib/convergence/model/CvgException').CvgException;
var CvgWindow = require('syracuse-x3/lib/convergence/model/CvgWindow').CvgWindow;
var CvgMessage = require('syracuse-x3/lib/convergence/model/CvgMessage').CvgMessage;
var CvgVariableCombo = require('syracuse-x3/lib/convergence/model/CvgVariableCombo').CvgVariableCombo;
var CvgPickedLine = require('syracuse-x3/lib/convergence/model/CvgPickedLine').CvgPickedLine;
var CvgReplyAckCall = require('syracuse-x3/lib/convergence/model/CvgReplyAckCall');
var CvgInstanceExeci = require('syracuse-x3/lib/convergence/model/CvgInstanceExeci');
var CvgDiagnose = require('syracuse-x3/lib/convergence/model/CvgDiagnose');
var CvgSessionOpen = require('syracuse-x3/lib/convergence/model/CvgSessionOpen');
var CvgAskUiAction = require('syracuse-x3/lib/convergence/model/CvgAskUiAction');
var CvgReboot = require('syracuse-x3/lib/convergence/model/CvgReboot');
var PrintClient = require('syracuse-x3/lib/clients/print/PrintClient');
var PrintHelpers = require('syracuse-x3/lib/clients/print/PrintHelpers');
var CvgReport = require('syracuse-x3/lib/convergence/model/CvgReport');
var CvgImp = require('syracuse-x3/lib/convergence/model/CvgImp');
var CvgHelp = require('syracuse-x3/lib/convergence/model/CvgHelp').CvgHelp;
var x3helpers = require('syracuse-x3/lib/helpers');
var perfmon = require('syracuse-perfmon');

var localConfig = x3helpers.config("x3fusion", null, {});
var tracerStd = require("syracuse-trace/lib/helper").getTracer("classic.std");

var perfmonEnabled = x3helpers.config("perfmon.activate", localConfig);

var MSG_INFORMATION = 0;
var MSG_WARNING = 1; // Boite d'Avertissement
var MSG_QUESTION = 2; // Boite de Question
var MSG_ERROR = 3;
var MSG_STOP = 4; // Boite Abort
var OU_BAV = 11; /* Boite d'Avertissement */
var OU_BEN = 15; /* Boite end : Abort ! */
var OU_BER = 10; /* Boite d'Erreur */
var OU_BIF = 14; /* Boite d'Information */
var OU_BQU = 12; /* Boite de Question */
var OU_BSE = 13; /* Boite de Selection */

function _postDiag(req, msg, detail) {
	CvgDiagnose.create(req.client, 'WARNING', 99, msg, detail, null, "Protocol", null, true);
}

function _getSrvImpId(srvImpName, printConfig) {
	var ret = {}, edtSrvPart = srvImpName ? srvImpName.split(':') : null;
	var cfg = printConfig && printConfig.server;
	ret.host = (edtSrvPart && edtSrvPart[0]) || (cfg ? cfg.hostname : "");
	ret.port = (edtSrvPart && edtSrvPart[1]) || (cfg ? cfg.port : 0);
	return ret;
}

var CDataSrcDeleter = helpers.defineClass(function(cli, aTargetLine, aNbLines) {
	this.cli = cli;
	this.targetLine = aTargetLine;
	this.nbLines = aNbLines;
}, CvgModifier, {
	setModifiable: function(ist, obj) {
		this.done = obj instanceof CvgDataSrc;
		if (this.done) {
			var ds = obj;
			if (this.nbLines === -1) {
				ds.serverRemoveAllLines();
			} else {
				ds.serverRemoveLines(this.targetLine, this.nbLines);
			}
		} else {
			//this.setLogicalErrMess("CDataSrcDeleter - ist[" + obj.getAdxId() + "] - Bad class object - CvgDataSrc expected");
		}
		return this.done;
	}
});

var CDataSrcInserter = helpers.defineClass(function(cli, aTargetLine, aNbLines) {
	this.cli = cli;
	this.zeroBasedIdx = aTargetLine;
	this.nbLines = aNbLines;
}, CvgModifier, {
	setModifiable: function(ist, obj) {
		this.done = obj instanceof CvgDataSrc;
		//console.log("\tsetMod=" + ist.toString() + " - " + this.zeroBasedIdx + " - " + this.nbLines);
		if (this.done) {
			var wDataSrc = obj;
			wDataSrc.serverInsertLines(this.zeroBasedIdx, this.nbLines);
			if (wDataSrc.hasDimOverFlow()) {
				this.setLogicalErrMess(this.cli.getMessage('ERROR_DIM_OVERFLOW', wDataSrc.dim.toString(), this.nbLines.toString(), wDataSrc.lines.length.toString()));
			}
		} else {
			//this.setLogicalErrMess("CDataSrcInserter - ist[" + obj.getAdxId() + "] - Bad class object - CvgDataSrc expected");
		}
		return this.done;
	}
});

var CLeftListAppender = helpers.defineClass(function(aIdx, aBranche, aTxt, aVal, aClf, aClp) {
	CvgModifier.call(this);
	this.idx = aIdx;
	this.branche = aBranche;
	this.txt = aTxt;
	this.val = aVal;
	this.clf = aClf;
	this.clp = aClp;
}, CvgModifier, {
	setModifiable: function(ist, obj) {
		// Returned object is not used so ignore
		obj.appendLeftListLine(this.idx, this.branche, this.txt, this.val, this.clf, this.clp);
		this.done = true;
		return this.done;
	}
});

var NDCOLAR_MODIF_FORMATS = 1;

var CLeftListColumnsModifier = helpers.defineClass(function(aWhat, aDefs) {
	CvgModifier.call(this);
	this.whatModification = aWhat;
	this.defs = aDefs;
}, CvgModifier, {
	// modif des formats
	setModifiable: function(ist, obj) {
		if (this.whatModification === NDCOLAR_MODIF_FORMATS) {
			obj.changeColumnsFormats(this.defs);
		} else {
			obj.changeColumnsTitles(this.defs);
		}
		this.done = true;
		return this.done;
	}
});

var CLeftListDeleter = helpers.defineClass(function() {
	CvgModifier.call(this);
}, CvgModifier, {
	setModifiable: function(ist, obj) {
		obj.serverRemoveAllLines();
		this.done = true;
		return this.done;
	}
});

var CLeftListSelecterByKey = helpers.defineClass(function(selected, aCle) {
	CvgModifier.call(this);
	this.selected = selected;
	this.cle = aCle;
	this.selLineIdx = -1;
}, CvgModifier, {
	setModifiable: function(ist, obj) {
		this.selLineIdx = obj.setServerSelectLine(this.selected, this.cle);
		//console.log("\tselLine:" + this.selLineIdx);
		this.done = true;
		return this.done;
	}
});

var n = 1;

var CFormatSetter = helpers.defineClass(function(cli, aFormat, fmt) {
	CvgModifier.call(this);
	this.format = aFormat;
	this.newVsisibleState = CvgEntity.STATE_DEFAULT;
}, CvgModifier, {
	hasNewVisibleState: function() {
		return this.newVsisibleState !== CvgEntity.STATE_DEFAULT;
	},
	setModifiable: function(ist, obj) {
		//console.log("CFormatSetter")

		obj.number = n++;
		obj.setServerFormat(new CvgFormat(this.format), this.format);
		this.done = true;
		return obj;
	}
});

var CActiveStateSetter = helpers.defineClass(function(aState) {
	CvgModifier.call(this);
	this.entitryState = aState;
}, CvgModifier, {
	setModifiable: function(ist, obj) {
		//obj.stateSet(this.entitryState, true);
		obj.setActGriDiszo(this.entitryState);
		this.done = true;
		return this.done;
	}
});
exports.CActiveStateSetter = CActiveStateSetter;

var CServerColorSetter = helpers.defineClass(function(aColor) {
	CvgModifier.call(this);
	this.color = aColor;
}, CvgModifier, {
	setModifiable: function(ist, obj) {
		obj.setPColor(this.color);
		this.done = true;
		return this.done;
	}
});

var CServerStyleSetter = helpers.defineClass(function(aStyle, applyOn) {
	CvgModifier.call(this);
	this.style = aStyle;
	this.applyOn = applyOn;
}, CvgModifier, {
	setModifiable: function(ist, obj) {
		obj.setServerStyle(this.style, this.applyOn);
		this.done = true;
		return this.done;
	}
});

var CServerTitleSetter = helpers.defineClass(function(aTitle) {
	CvgModifier.call(this);
	this.title = aTitle;
}, CvgModifier, {
	setModifiable: function(ist, obj) {
		obj.setServerTitle(this.title);
		this.done = true;
		return this.done;
	}
});

var CServerValueSetter = helpers.defineClass(function(aResu) {
	CvgModifier.call(this);
	this.resu = aResu;
}, CvgModifier, {
	setModifiable: function(ist, obj) {
		obj.setServerValue(this.resu);
		this.done = true;
		return this.done;
	}
});
exports.CvgRequest = helpers.defineClass(function(aClient, aAdonixReply, sendContext) {
	this.client = aClient;
	this.reply = aAdonixReply; // added by BRJOU
	this.nbNodeOpenTempon = 0;
	this.lefListLineSelected = -1;
	this.sendContext = sendContext;
	this.ndofld = 0;
	this.help = null;
	this.workingCtx = {};

}, null, {

	buildListenNodeMessage: function(aKeyMess, aValue1, aValue2, aModifier) {
		var msg = aValue2 ? this.client.getMessage(aKeyMess, aValue1, aValue2) : this.client.getMessage(aKeyMess, aValue1);
		if (aModifier.hasLogicalErrMess()) {
			msg = msg + "\n\t" + aModifier.logicalErrMess;
		}
		return msg;
	},
	/**
	 * Modifie le contenu de la liste d'arguments reeu du brwowser pour une
	 * action SRV_BRWRAPIDESEL
	 *
	 * SRV_BRWRAPIDESEL (1069) = 1024 + ACK_SLRP (45)
	 *
	 * Recoit : -(a) le resu associe a l'action -(b) l'adxid (ist) de la liste
	 * gauche -(c..k) n resus (sous la forme "adxid^tdo^value" ) des n colonnes
	 * de la liste gauche Supprime : - les n resus Ajoute : - une table de n
	 * instances de CvgResu contenant les n valeurs de filtrage des n
	 * colonnes
	 */
	listenActionArgsBRWRAPIDESEL: function(aClient, aParams) {
		var nbArgs = aParams.length;
		var tabResus = [];
		var i = 2;
		var colValue;
		while (i < nbArgs) {
			colValue = aParams[i];
			// ajoute dans la table un resu deformate construit a partir de la
			// chaine "adxid^tdo^value"
			tabResus.push(new CvgResu(CvgResuTdo.STRU, colValue));
			i++;
		}
		i = nbArgs - 1;
		while (i >= 2) {
			aParams.splice(i, 1);
			i--;
		}
		aParams.push(tabResus);
	},

	/**
	 * Modifie le contenu de la liste d'arguments recu du brwowser pour une
	 * action SRV_BRWCHANGELINE ou SRV_BRWSELECTLINE ou SRV_TREECHANGELINE ou
	 * SRV_TREEEXPANDLINE ou SRV_TREESELECTLINE SRV_BRWCHANGELINE (1051) = 1024
	 * + ACK_CLST (27) SRV_BRWSELECTLINE (1052) = 1024 + ACK_SLST (28)
	 * SRV_TREECHANGELINE (1060) = 1024 + ACK_CABR (36) SRV_TREEEXPANDLINE
	 * (1061) = 1024 + ACK_SABR (37) SRV_TREESELECTLINE (1062) = 1024 + ACK_DABR
	 * (38)
	 *
	 * Recoit : -(a) le resu associe a l'action -(b) l'adxid (IST) de la ligne
	 * selectionnee Modifie : - l'adxid (IST) pour supprimer l'index de la ligne
	 * Ajoute : - la cle apres l'argument IST
	 */
	listenActionArgsDOLEFTLISTLINE: function(aClient, aParams) {
		if (aParams.length >= 3) {
			var act = parseInt(aParams[0], 10);

			var ist = aParams[1];
			if (typeof ist === "string") {
				ist = new CvgIst(aParams[1]);
			} else if (!(ist instanceof CvgIst)) {
				throw new CvgException(this.client, null, "ARG_WRONG - need a 'CvgIst' or a 'String' !");
			}

			if (typeof aParams[2] === "string") {
				var key = [aParams[2]];
				if (aParams[2].indexOf('^') !== -1) {
					key = aParams[2].split('^');
				}
				var resu, i, t, resus = [];
				for (i = 0; i < key.length; i++) {
					var indexSep = key[i].indexOf('~');

					var resu = new CvgResu.fromAction(parseInt(key[i].substr(0, indexSep), 10), key[i].substr(indexSep + 1));
					resus.push(resu);
				}
				aParams.splice(2, 1, resus); // add table of resu
				aParams[1] = ist;
			}
			ist.idx = 0; //ist.setLine(0);
		} else {
			this.listenActionArgsDOLEFTLISTLINE2(aClient, aParams);
		}
	},
	listenActionArgsDOLEFTLISTLINE2: function(aClient, aParams) {
		//console.log("listenActionArgsDOLEFTLISTLINE: "+aParams);
		/*
		 * Construction d'une StructIst designant la ligne selectionnee a partir
		 * du deuxieme argument 14w_006 - Evolution TermServer - Liste gauche /
		 * choose Accepte une instance de CvgIst en tant que deuxieme
		 * parametre
		 */
		var act = parseInt(aParams[0], 10);
		var ist = aParams[1];
		if (typeof ist === "string") {
			ist = new CvgIst(aParams[1]);
		} else if (!(ist instanceof CvgIst)) {
			throw new CvgException(this.client, null, "ARG_WRONG - need a 'CvgIst' or a 'String' !");
		}

		if (!ist.isLineIst()) {
			throw new CvgException(this.client, null, "ARG_WRONG - need a 'line' ist !");
		}
		var leftLstLine = aClient.findModifiable(ist);
		// si l'action porte sur une instance de "CvgLeftListNode" il faut
		// memoriser le noeud de "source de l'action" car le traitement des
		// noeuds en reponse en depend.
		if (leftLstLine) {
			if (leftLstLine instanceof CvgLeftListLineNode) {
				var leftLstNode = leftLstLine;
				/*
				 * Stockage dans la liste gauche recursive de l'id du Node a
				 * "expandre"
				 */
				leftLstNode.dataSrc.setNodeIdToExpanded(ist.idx);
			}

			aParams.splice(2, 1, leftLstLine.cle);
			ist.idx = 0; //ist.setLine(0);
			aParams[1] = ist;
		}
	},

	/**
	 * 15w_002 - Fiche 36375 - VT: accepter CvgIst comme argument de PAGEUP,
	 * PAGEDOWN
	 *
	 * Modifie le contenu de la liste d'arguments recu du brwowser pour une
	 * action SRV_LIST_PAGE_DOWN
	 *
	 * SRV_LIST_PAGE_UP (1072) = 1024 + ACK_FRWD (49)
	 *
	 * Recoit : -(a) le resu associe a l'action -(b) l'adxid (IST) de la ligne
	 * selectionnee Modifie :
	 *
	 * Ajoute : - la cle de la premere ligne apres l'argument IST
	 */
	listenActionArgsLIST_PAGE_DOWN: function(aClient, aParams) {
		var leftLst = this.retrieveLeftList(aClient, aParams);
		var leftLstLine = leftLst.getLastLine();
		if (leftLstLine != null) {
			aParams.push(leftLstLine.cle);
		}
	},

	/**
	 * 15w_002 - Fiche 36375 - VT: accepter CvgIst comme argument de PAGEUP,
	 * PAGEDOWN Modifie le contenu de la liste d'arguments reeu du brwowser pour
	 * une action SRV_LIST_PAGE_UP SRV_LIST_PAGE_DOWN (1073) = 1024 + ACK_REWD
	 * (48)
	 *
	 * Recoit : - le reesu associe a l'action - l'IST de la ligne selectionnee
	 * Modifie :
	 *
	 * Ajoute : - la cle de la derniere ligne apres l'argument IST
	 */
	listenActionArgsLIST_PAGE_UP: function(aClient, aParams) {
		var leftLst = this.retrieveLeftList(aClient, aParams);
		var leftLstLine = leftLst.getFirstLine();
		if (leftLstLine != null) {
			aParams.push(leftLstLine.cle);
		}

	},

	/**
	 * Modifie le contenu de la liste d'arguments recu du brwowser pour une
	 * action SRV_PICKING
	 *
	 * SRV_PICKING (1066) = 1024 + ACK_PICK (42) * Recoit : -(a) le resu associe
	 * a l'action -(b) l'adxid (ist) de la liste gauche -(c) n adxid (IST) des n
	 * lignes a selectionner ou a deselectionner separes par un '^' -(d) n
	 * actions (autant que de lignes) de selection ("1052" SRV_BRWSELECTLINE) ou
	 * de deselection ("1067" SRV_BRWDESELECTLINE) separes par un '^' Modifie :
	 * - l'IST piour supprimer l'index de la ligne Supprime
	 *
	 * Ajoute : - la cle apres l'argument IST
	 */
	listenActionArgsPICKING: function(aClient, aParams) {
		var ist = aParams[1],
			actToPropagate = aParams[3],
			self = this;

		function registerPickedLine(key) {
			if (typeof ist === "string") {
				ist = new CvgIst(ist);
			} else if (ist instanceof CvgIst) {
				ist = new CvgIst(ist.ist);
			} else {
				throw new CvgException(self.client, null, "ARG_WRONG - need a 'CvgIst' or a 'String' !");
			}
			var leftlist = aClient.findModifiable(ist);
			var pickedLine = new CvgPickedLine(ist, key, leftlist, actToPropagate);
			//console.log(">>> Picked line IST: "+pickedLine.ist.toString());
			self.client.pickingAddLine(pickedLine);
		}
		/*
		 * attribut "c" : n adxid (IST) des n lignes a selectionner ou a
		 * deselectionner separes par un '^' stockage des AdxId dans n StructIst
		 * bufferiszes au niveau du client Exemple : <A I="1066" a="" b="B,AH,C"
		 * c="B,AH,C,5^B,AH,C,6" d="1052^1052" T="0" >0^</A>
		 */
		if (Array.isArray(aParams[2])) {
			var i, lines = aParams[2];
			for (i in lines) {
				registerPickedLine(lines[i]);
			}
		} else {
			registerPickedLine(aParams[2]);
		}
		aParams.splice(2, 2);
	},

	/* from CAdonixRequest */
	listenNodeNDGIST: function(_, reader, node, ist) {
		this.reply.setTargetAdxId(ist, this);
	},

	/**
	 * "AskPutFile", "AskSelFile", "AskReadTextFile", "AskExecShell",
	 * "AskGetFile"
	 */
	listenNodeND_ASKUI: function(_, reader, node, properties) {
		try {
			CvgAskUiAction.create(this.client, properties);
		} catch (e) {
			throw e;
		} finally {
			this.workingCtx.pendingBlockingNode = {
				"id": "ND_ASKUI",
				"proxy": "processAction",
				"act": CvgAction.SRV_ASKUI_RESPONSE,
				"param": {},
				"fld": {
					"ist": null,
					"v": "0,statement canceled"
				}
			};
		}
	},

	listenNodeNDINED: function(_, reader, node) {
		x3writer.sendAction(_, this.client, new CvgResu(CvgResuTdo.STRU, ""), [], [CvgAction.SRV_EXECUTE]);
		// TODO: translate message
		_postDiag(this, "NDINED node not supported", "NDINED");
	},

	listenNodeND_INT: function(_, reader, node) {
		// TODO: translate message
		_postDiag(this, "ND_INT node not supported", "ND_INT");
		// 0 means continue 4GL process | 1 means interrupt
		return 0;
	},

	listenNodeNDSYSTEM: function(_, reader, node) {
		// TODO: translate message
		_postDiag(this, "NDSYSTEM node not supported", "NDSYSTEM");
		return [0];
	},

	listenNodeNDEDBK: function(_, reader, node) {
		// TODO: translate message
		_postDiag(this, "NDEDBK node not supported", "NDEDBK");
		return [0, 0];
	},

	listenNodeND_OCX: function(_, reader, node) {
		// TODO: translate message
		_postDiag(this, "ND_OCX node not supported", "ND_OCX");
		return [0, 0, 0, 0, 0];
	},
	listenNodeND_IHM: function(_, reader, node) {
		// TODO: translate message
		_postDiag(this, "ND_IHM node not supported", "ND_IHM");
		return [0, 0, 0, 0, 0];
	},
	listenNodeNDGTDT: function(_, reader, node) {
		// TODO: translate message
		_postDiag(this.client, "NDGTDT node not supported", "NDGTDT");
		return [0, 0, 0, 0, 0];
	},
	listenNodeND_ASKUIGetFile: function(aExtendProperties) {
		_postDiag(this.client, "ASKUIGetFile node not supported", "ASKUIGetFile");
	},

	/**
	 * ND_CLF 0E1400 (Adxcpl_CloseWin) Fermeture d'une fenetre Id=[ND_CLF]
	 * level=[?] x3func=[Adxcpl_CloseWin] nb=[1] ist =[ win=[2] srn=[0] blc=[0]
	 * fld=[0] idx=[0] ]
	 */
	listenNodeND_CLF: function(_, reader, node, ist) {
		// IN--> ist =[ win=[2] srn=[0] blc=[0] fld=[0] idx=[0]]
		// console.log("ND_CLF on ist : " + JSON.stringify(ist,null,2) + " - ist.win = " + ist.win);
		if (this.nbNodeOpenTempon > 0) {
			this.nbNodeOpenTempon--;
			return;
		}
		var stackedWin = this.client.popRequesterWindow(ist);
		var reply = this.reply;
		reply.addPoppedWindow(stackedWin);
		// manage bo check if bo has variable and if it links to current stacked window
		if (this.client.boClient.variable && this.client.boClient.token) {
			var v = this.client.boClient.variable;
			if (v.getAdxIst().win === ist.win) {
				this.client.boClient.logoff(_);
			}
		}

	},

	/**
	 * ND_DCL 0E2400 (LeftList_NewRequete) Debut de chargement liste simple ou
	 * arbre Id=[ND_DCL] func=[LeftList_NewRequete] NbArgs=[1] ist =[ win=[2]
	 * srn=[34] blc=[1] fld=[0] idx=[0]]
	 */
	listenNodeND_DCL: function(_, reader, node) {},

	/**
	 * ND_FCL 0E2500 (LeftList_CloseReq) Fin de chargement liste simple ou arbre
	 * Id=[ND_FCL] func=[LeftList_CloseReq] NbArgs=[1] ist =[ win=[2] srn=[34]
	 * blc=[1] fld=[0] idx=[0]]
	 */
	listenNodeND_FCL: function(_, reader, node) {},

	/**
	 * ND_ICL 111000 (LeftList_SynchroRequete) Interrogation chargement liste *
	 * Id=[ND_ICL] func=[LeftList_SynchroRequete] NbArgs=[1] ist =[ win=[2]
	 * srn=[34] blc=[1] fld=[0] idx=[0]]
	 */
	listenNodeND_ICL: function(_, reader, node) {
		return [1];
	},

	/**
	 * Open a second session
	 */
	listenNodeND_NAP: function(_, reader, node, txt) {
		CvgSessionOpen.create(this.client, txt);
	},
	listenNodeND_REB: function(_, reader, node, str1, str2, str3, str4, str5, str6, str7, str8, str9, str10, str11, str12, str13, str14, str15, str16, str17) {
		// Notify observer
		CvgReboot.create(this.client, str1, str2, str3, str4, str5, str6, str7, str8, str9, str10, str11, str12, str13, str14, str15, str16, str17);
		if (this.client) {
			this.client.closeSocket();
		}
	},
	// Not used in web 6 - No partial loading for web arrays
	listenNodeNDAFTB: function(_, reader, node, ist, affState, nblines) {
		if (affState !== 0 && affState !== 1) {
			_postDiag(this, 'AFTB nodes are not supported - No partial loading for arrays', 'NDAFTB - ' + ist.toString());
		}
	},
	/**
	 * NDCHCR 114300 (Adxcpl_setColor) Modification couleur champ/cellule
	 * tableau Id=[NDCHCR] x3func=[Adxcpl_setColor] elems=[hasArg:2] nb=[2] ist
	 * =[ win=[2] srn=[4] blc=[1] fld=[5] idx=[1] ] st=[.x14]
	 * Dump=[.x00.x00.x09.x11.x43.x02.x04.x01.x05.x00.x01.x14]
	 */
	listenNodeNDCHCR: function(_, reader, node, ist, color) {
		var setter = new CServerColorSetter(color);
		this.client.traverseSettable(ist, setter);
	},

	/**
	 * NDCHFM 0E4300 (Adxcpl_setFormat) Mise a jour Format champ/cellule tableau
	 * Id=[NDCHFM] x3func=[Adxcpl_setFormat] elems=[hasArg:2] nb=[2] ist =[
	 * win=[2] srn=[7] blc=[2] fld=[11] idx=[0] ] txt
	 * =[K:2#[.]2#[.]2#[.]2#[.]2#[ ]]
	 * Dump=[.x00.x00.x2C.x0E.x43.x02.x07.x02.x0B.
	 * x00.x00.x00.x22.x00.x20.x4B.x3A
	 * .x32.x23.x5B.x2E.x5D.x32.x23.x5B.x2E.x5D.x32
	 * .x23.x5B.x2E.x5D.x32.x23.x5B.x2E
	 * .x5D.x32.x23.x5B.x20.x20.x20.x20.x20.x20.x5D]
	 */
	listenNodeNDCHFM: function(_, reader, node, ist, fmt) {

		var setter = new CFormatSetter(this.client, fmt);
		this.client.traverseSettable(ist, setter);
		// if fromat starts with a '-' -> not visible
		// -> if visible status changed on a cell we propagate to the column
		if (!setter.done) {
			_postDiag(this, this.buildListenNodeMessage('ERROR_SETTER_FORMAT', fmt, null, setter), "NDCHFM - " + ist.toString());
		}
	},

	/**
	 * NDCHGR 0E1F00 (Adxcpl_setState) Activation / desactivation champ/cellule
	 * tableau 0 grizo 1 actzo 2 diszo
	 */
	listenNodeNDCHGR: function(_, reader, node, ist, state) {
		// 0 "SRV_GRIZO" - 1 "SRV_ACTZO - 2 "SRV_DISZO";
		var setter = new CActiveStateSetter(CvgEntity.x3State2EntityState(state));
		this.client.traverseSettable(ist, setter);
		if (!setter.done) {
			_postDiag(this, this.buildListenNodeMessage('ERROR_SETTER_STATE', CvgEntity.x3StateToString(state), null, setter), 'NDCHGR - ' + ist.toString());
		}
	},

	listenNodeNDCHVB: function(_, reader, node, ist, resus) {
		var resu = resus[0];
		var setter = new CServerValueSetter(resu);
		this.client.traverseSettable(ist, setter);
		if (!setter.done) {
			_postDiag(this, this.buildListenNodeMessage('ERROR_SETTER_BLOB', resu.value.length, null, setter), 'NDCHVB - ' + ist.toString());
		}
		if (this.client.boClient.variable && !this.client.boClient.token) {
			try {
				var token = this.client.boClient.logon(_);
				if (!token) {
					throw new Error(locale.format(module, "bo_logon_failed"));
				}
			} catch (e) {
				this.client.boClient.variable = null;
				tracerStd.error && tracerStd.error(e.stack);
				this.client.sendNotify(ist, 4, e.message);
			}
		}

	},

	/**
	 * NDCHVL 114600 (Adxcpl_setValue) Mise a jour valeur champ/cellule tableau
	 *
	 * IN--> Id=[NDCHVL] x3func=[Adxcpl_setValue] elems=[hasArg:2] nb=[2] ist =[
	 * win=[2] srn=[4] blc=[1] fld=[2] idx=[4] ] st=[ typ=[122,STRU] val=[CPT] ]
	 * Dump
	 * =[.x00.x00.x12.x11.x46.x02.x04.x01.x02.x00.x04.x7A.x03.x00.x43.x00.x50
	 * .x00.x54.x00.x00]
	 */
	listenNodeNDCHVL: function(_, reader, node, ist, resu) {
		var setter = new CServerValueSetter(resu);
		this.client.traverseSettable(ist, setter);
		if (!setter.done) {
			_postDiag(this, this.buildListenNodeMessage('ERROR_SETTER_VALUE', resu.toString(), null, setter), 'NDCHVL - ' + ist.toString());
		}
		if (this.client.boClient.variable && !this.client.boClient.token) {
			try {
				var token = this.client.boClient.logon(_);
				if (!token) {
					throw new Error(locale.format(module, "bo_logon_failed"));
				}
			} catch (e) {
				tracerStd.error && tracerStd.error(e.stack);
				this.client.boClient.variable = null;
				this.client.sendNotify(ist, 4, e.message);
			}
		}
	},

	/**
	 * NDCHST 0E3400 (Adxcpl_setStyle) Mise a jour Style champ/cellule tableau
	 * Id=[NDCSTL] x3func=[Adxcpl_setStyle] elems=[hasArg:2] nb=[2] ist =[
	 * win=[2] srn=[7] blc=[2] fld=[11] idx=[0] ] txt =[STYLE]
	 */
	listenNodeNDCSTL: function(_, reader, node, ist, sty) {
		var styleApply;
		if (ist.idx === -1) {
			styleApply = 'CHILDS';
		} else if (ist.idx === -2) {
			styleApply = 'TITLE';
		} else {
			styleApply = 'ENTITY';
		}
		var setter = new CServerStyleSetter(sty, styleApply);
		this.client.traverseSettable(ist, setter);
		if (!setter.done) {
			_postDiag(this, this.buildListenNodeMessage('ERROR_SETTER_STYLE', sty, null, setter), 'NDCSTL - ' + ist.toString());
		}
	},

	/**
	 * NDCTIT 0E3300 (Adxcpl_setLabel) Mise a jour label d'un objet modelise
	 * Id=[NDCTIT] level=[?] x3func=[Adxcpl_setLabel] nb=[2] ist=[ win=[2]
	 * srn=[0] blc=[0] fld=[0] idx=[0] ] txt =[Utilisateurs]
	 */
	listenNodeNDCTIT: function(_, reader, node, ist, ttl) {
		this.client.traverseSettable(ist, new CServerTitleSetter(ttl));
	},

	/**
	 * Dynamisme des combos des menus locaux
	 */
	listenNodeNDDSLB: function(_, reader, node, ist, value) {
		var v = this.client.findModifiable(ist);
		if (v != null && v instanceof CvgVariableCombo) {
			v.setServerDisabledChoice(value);
		}
		if (v == null) {
			_postDiag(this, "Variable not found[" + ist.toString() + "]", 'NDDSLB');
		}
	},

	/**
	 * override nedexeci to get the ack_call readed
	 */
	listenNodeNDEXECI: function(_, reader, node, ist, spgm, dbgflg, paramDefs, paramVal) {
		var self = this;
		// there is a potential large recursion here, for example when X3 calls a web service in a loop.
		// so we need to force a stack unwind with flows.trampoline.
		flows.trampoline(_, function(_) {
			var serverUrl = reader.ctx && reader.ctx._cvgSession && reader.ctx._cvgSession.sessInfo && reader.ctx._cvgSession.sessInfo.serverUrl;
			if (!serverUrl) {
				serverUrl = self.client && self.client._cvgSession && self.client._cvgSession.sessInfo && self.client._cvgSession.sessInfo.serverUrl;
			}
			CvgInstanceExeci.create(_, ist, spgm, dbgflg, paramDefs[0], paramVal[0], self.client, serverUrl);
		});
	},

	/**
	 * NDGLAR 0E2E00 (LeftList_SelectLine) Selection ligne dans liste simple ou
	 * arbre
	 */
	listenNodeNDGLAR: function(_, reader, node, ist, key) {
		var selector = new CLeftListSelecterByKey(true, key);
		this.client.traverseSettable(ist, selector);
		if (!selector.done) {
			_postDiag(this, this.buildListenNodeMessage('ERROR_LLLINE_SELECTER', key.toString(), null, selector), 'NDGLAR - ' + ist.toString());
		} else {
			this.lefListLineSelected = selector.selLineIdx;
		}
	},

	/**
	 * NDULAR 0E3100 (LeftList_DeselectLine) Deselection ligne dans liste simple
	 * ou arbre
	 */
	listenNodeNDULAR: function(_, reader, node, ist, key) {
		this.client.traverseSettable(ist, new CLeftListSelecterByKey(false, key));
	},

	/**
	 * NDINSLI 0E0B00 (Adxcpl_addGridLines) Ajout lignes dans tableau
	 *
	 * Parametres : - sX3Adxid *psAdxidTarget : Identifiant de la cible [in] -
	 * short nStartLine : ligne de depart [in] - short nNbLine : Nombre de
	 * lignes [in]
	 *
	 * Id=[NDINSLI] x3func=[Adxcpl_addGridLines] elems=[hasArg:3] nb=[3] ist =[
	 * win=[2] srn=[4] blc=[1] fld=[0] idx=[0] ] sh1=[1] sh2=[44]
	 * Dump=[.x00.x00.x0C.x0E.x0B.x02.x04.x01.x00.x00.x00.x00.x01.x00.x2C]
	 *
	 * Remarque : A la construction d'une fenetre, un tableau est toujours cree
	 * avec une ligne d'en-tete et une ligne vide.
	 */
	listenNodeNDINSLI: function(_, reader, node, ist, targetLine, nbLines) {
		//console.log("INSLI - Start=" + targetLine + " - Nb=" + nbLines);
		var inserter = new CDataSrcInserter(this.client, targetLine, nbLines);
		this.client.traverseSettable(ist, inserter);
		if (inserter.hasLogicalErrMess()) {
			_postDiag(this, this.buildListenNodeMessage('ERROR_INSERTER', nbLines.toString(), targetLine.toString(), inserter), 'NDINSLI - ' + ist.toString());
		}
	},

	/**
	 * Traitement des noeud NDOBOXI transportant des messages synchrones. Compte
	 * tenu du mecanisme de si le noeud NDOBOXI n'est pas traite ici, il sera
	 * traite dans la methode "listenNodeNDOBOXI" de la classe "CAdonixRequest"
	 *
	 * NDBOXI 0E0108 (MessageBox_Create)
	 *
	 * Transporte les demandes d'affichage synchrone
	 *
	 * Infbox "$$TEMPOPE" + WMESS Infbox "$$TEMPCLO" Infbox "$$VLC_OPE" +
	 * INTTEXT + "^" + INTNUM Titled TITREWINDOW + "^" + WLIB1 + "^" + WLIB2
	 * Infbox "$$VLC_MOD" + VALEXT + "^" + VALNUM Infbox "$$VLC_CLO" Infbox
	 * "$$PROGOPE" Titled TITREWINDOW Infbox "$$PROGMOD" + WMAX + "^" +
	 * WPROGRESS + "^" + WLIB Infbox "$$PROGCLO"
	 *
	 * simulation de close session Infbox "$$SESSCLO"
	 *
	 * pilotage timeout de la requete courante - Timeout d'une heure si
	 * $$DBG_OPE + texte - Timeout standard si $$DBG_CLO + texte
	 */
	listenNodeNDOBOXI: function(_, reader, node, typBox, btnNum, msg, ttl, wSleep) {
		if (typBox === OU_BIF) {
			var p = msg.indexOf("$$");
			// si le message contient "$$" au debut (pos 0 ou 1) : c'est un message d'affichage asynchone
			if (p === 0 || p === 1) {
				_postDiag(this, "Synchronous messages are not implemented in this version[" + msg + "]", 'NDOBOXI');
			}
		}
		var typMsg = -1,
			defBtn = -1;
		if (msg.length > 0) {
			msg.replace('\r', ' ');
		}
		if (ttl.length > 0) {
			ttl.replace('\r', ' ');
		}
		switch (typBox) {
			/* Boite de Question */
			case OU_BQU:
				typMsg = MSG_QUESTION;
				defBtn = 2;
				break;
				/* Boite d'Avertissement */
			case OU_BAV:
				typMsg = MSG_WARNING;
				defBtn = 1;
				break;
				/* Boite d'Erreur */
			case OU_BER:
				typMsg = MSG_ERROR;
				defBtn = 0;
				break;
				/* Boite d'Information */
			case OU_BIF:
				typMsg = MSG_INFORMATION;
				defBtn = 0;
				break;
				/* Boite STOP */
			case OU_BEN:
				typMsg = MSG_STOP;
				defBtn = 0;
				// Who is closing syracuse session ? if (this.client.connecting) this.client.closeClient(_, null, 3);
				break;
			case OU_BSE:
				/* Boite de Selection ??? */
				break;
			default:
				break;
		}
		msg = new CvgMessage(typMsg, 0, msg, ttl, defBtn, wSleep, btnNum, this.client);
		// réponse automatique à tous les message si "SRV_CALLREMOTESPGM" (ACK_CALL) ou open connexion
		/*
		var replyAuto = (this.reply.actionId === CONNECT_ACTION);
        if (replyAuto) {
			msg.replyAuto = true;
			if (btnNum !== 0 && btnNum !== defBtn) defBtn = btnNum;
			this.listenNodeNDOBOXISendAutoReply(_, defBtn); // bouton par défaut
			// défini par  l'utilisateur
			// positionnement du fait que l'on a déja envoyé une réponse pour ce segment
			// TODO TCA aSegmentNode.setAutoReplied();
		}*/
	},

	listenNodeNDOBOXISendAutoReply: function(_, btnNum) {
		var resu = new CvgResu(CvgResuTdo.INT, btnNum);
		//var segAct = CSegmentActionFactory.buildSegmentAction(pTracer, true, protocol, CvgAction.SRV_CHAMP_SUIVANT, istDatas);
		// pCommClient.writeSegment(segAct, false);
		x3writer.sendAction(_, this.client, resu, [], [CvgAction.SRV_CHAMP_SUIVANT]);
	},

	listenNodeNDSATAN: function(_, reader, node, ist) {
		this.reply.stayInCommandMode = true;
		// fusion - creation de l'instance target avec le bon mode commande
		this.reply.setTargetAdxId(ist, this);
	},

	listenNodeNDOMENA: function(_, reader, node, profil) {
		// si le profil change => on le met dans le reply
		this.client.setUserProfile(profil);
	},
	/**
	 * NDOCAR 0E012A (LeftList_NewFormat) Mise a jour Label/Format colonnesListe
	 * simple et arbre
	 */
	listenNodeNDOCAR: function(_, reader, node, ist, what, defs) {
		this.client.traverseSettable(ist, new CLeftListColumnsModifier(what, defs));
	},

	/**
	 * NDOFENH 0E0103 (Help_Direct) Demande affichage aide
	 */
	listenNodeNDOFENH: function(_, reader, node, txt) {
		if (!this.help) {
			this.help = new CvgHelp(this.client);
		}
		this.help.addToken(txt);
	},

	/**
	 * 14w_022 - Fiche 34442 - Support du noeud NDOFLD pour l'editeur de formule
	 * Traitemet du noeud specifique d'ajout de definition de champ dans
	 * l'editeur de formule en simulant un noeud NDOLAR pour charge la premiere
	 * liste gauche de 6 colonnes de la fenetre "_FORMULA"
	 *
	 * NDOFLD 0E0128 (de formule) Ajout informations dans les arbres de
	 * l'editeur de Formules
	 * "tsrfld","Lecture des Parametres et Appel a la Fonction"
	 * "ist","nxtist( ist )","ist " "string","nxtstu( st1 )","st1 "
	 * "string","nxtstu( st2 )","st2 " "string","nxtstu( st3 )","st3 "
	 * "short","st0 = nxtint( )","st0" "string","nxtstu( st4 )","st4 "
	 * "string","nxtstu( st5 )","st5 "
	 * add a parameter to simulate the reception of nod from motor left list formula
	 */
	listenNodeNDOFLD: function(_, reader, node, ist, txt1, txt2, txt3, int1, txt4, txt5, target) {
		var list = "A";
		if (target) { // receive on open window
			list = target;
		} else { // receive from the runtime, need to identify the list
			if (int1 > 200) {
				list = "C";
			}
			if (int1 > 500) {
				list = "B";
			}
		}
		ist = new CvgIst(ist.winAlphaId + ",AH," + list);
		//ist.screen = 34;
		//ist.bloc = 1;
		//ist.idx = -1;
		var line = [];
		var r1 = new CvgResu(CvgResuTag.STRU, txt1);
		var r2 = new CvgResu(CvgResuTag.STRU, txt2);
		var r3 = new CvgResu(CvgResuTag.STRU, txt3);
		var iVal = parseInt(int1, 10);
		if (isNaN(iVal)) {
			throw new CvgException(this.client, null, "Protocol error: argument is not an integer");
		}
		var r4 = new CvgResu(CvgResuTag.STRU, String(iVal));
		var r5 = new CvgResu(CvgResuTag.STRU, txt4);
		var r6 = new CvgResu(CvgResuTag.STRU, txt5);
		line.push(r1);
		line.push(r2);
		line.push(r3);
		line.push(r4);
		line.push(r5);
		line.push(r6);
		var clf = [r2];
		var clp = [r1];
		var done = this.client.traverseSettable(ist, new CLeftListAppender(-1, 0, txt3, line, clf, clp));
		if (!done) {
			tracerStd.warn && tracerStd.warn("line not appened :  NDOFLD to list " + ist.toJSON());
		}
	},

	/*
	 * "NDOLAR", "ISBUDDDF"
	 * Ist - Short - Byte - Utf8 - Defs - Defs - Defs - call Function
	 */
	listenNodeNDOLAR: function(_, reader, node, ist, idx, branch, txt, val, clf, clp) {
		this.client.traverseSettable(ist, new CLeftListAppender(idx, branch, txt, val, clf, clp));
	},

	/**
	 * NDOMNBO 0E0161 (menu_New) Stockage parametres d'element de menu -
	 * Exemples: Id=[NDOMNBO] idm=[50504] rng=[10] ide=[-985112310] flg=[.x18]
	 * cod=[1119] txt =[Selection avancee] acc=[0] Id=[NDOMNBO] idm=[307]
	 * rng=[50] ide=[50504] flg=[.x10] cod=[1024] txt =[Selection] acc=[0]
	 * Id=[NDOMNBO] level=[W] x3func=[menu_New] NbArgs=[7] idm=[307] rng=[50]
	 * ide=[50501] flg=[.x10] cod=[1024] txt =[Selection] acc=[0]
	 */
	listenNodeNDOMNBO: function(_, reader, node, idm, rnk, ide, flg, actId, txt, acc) {
		this.reply.addMenuWin(flg, actId, txt, idm, rnk, ide, acc);
	},

	listenNodeNDOMNAO: function(_, reader, node, idm, rnk, ide, flg, actId, txt, acc) {
		this.reply.addMenuWin(flg, actId, txt, idm, rnk, ide, acc);
	},

	/**
	 * Id=[NDOUVIMP] x3func=[Impression_ChargeReport] elems=[hasArg:5,hasExtend]
	 * NbArgs=[5] st1=[.x00] st2=[.x00] buf[1] =[] buf[2] =[] buf[3] =[]
	 * NbExtends=[1] nb=[1] len=[18] 0=[ nb=[23] 0=[ id=[__REPORT]
	 * value=[TABCOUNTRY.rpt] length=[23]] 1=[ id=[__DESTINATION] value=[0]
	 * length=[15]] 2=[ id=[__TYPDBA] value=[1] length=[10]] 3=[
	 * id=[__DBDATABASE] value=[DV140] length=[18]] 4=[ id=[__DBUSER]
	 * value=[GX3APP] length=[15]] 5=[ id=[__DBPASSWORD] value=[tiger]
	 * length=[18]] 6=[ id=[__APPLICATION] value=[GX3APP;gaile610;1940]
	 * length=[34]] 7=[ id=[__APPRPT] value=[GX3APP;gaile610;1940] length=[29]]
	 * 8=[ id=[__RPTLAN] value=[null] length=[9]] 9=[ id=[X3DOS]
	 * value=[GX3APP;gaile610;1940] length=[26]] 10=[ id=[__REQUETE]
	 * value=[81595] length=[15]] 11=[ id=[_PreVisuOptions]
	 * value=[11111111111111111111] length=[36]] 12=[ id=[X3CLI] value=[X3]
	 * length=[8]] 13=[ id=[X3EDT] value=[Etat Adonix Copyright Adonix]
	 * length=[34]] 14=[ id=[X3ETA] value=[TABCOUNTRY] length=[16]] 15=[
	 * id=[X3TIT] value=[Pays] length=[10]] 16=[ id=[X3OPE] value=[Olivier
	 * Gattaz ccc] length=[24]] 17=[ id=[X3USR] value=[OG] length=[8]] 18=[
	 * id=[X3LAN] value=[FRA] length=[9]] 19=[ id=[X3SIT1] value=[*] length=[8]]
	 * 20=[ id=[X3SIT2] value=[z] length=[8]] 21=[ id=[paysdeb] value=[ ]
	 * length=[10]] 22=[ id=[paysfin] value=[zzzzzzzzzz] length=[18]] ]
	 */
	listenNodeNDOUVIMP: function(_, reader, node, properties) {
		//console.log("NDOUVIMP Properties: "+JSON.stringify(properties,null,2));
		function replyError(client, e) {
			CvgReport.submitted(client, {}, e);
			return [0, 0];
		}

		var jobRank, printClient, srvId;
		if (properties['+STATE'] && properties['+STATE'] === "LAUNCHED") {
			try {
				jobRank = parseInt(properties.__wJobRank, 10) || 0;
				var props = {
					host: properties['+X3IMP'],
					trackId: properties.__wJobID,
					title: properties.X3TIT,
					report: properties.__REPORT || "",
					rank: jobRank
				};
				if (!properties._FormatExport) {
					properties._FormatExport = "29";
				}
				props.mime = PrintClient.getMimeFromExport(properties._FormatExport);
				srvId = _getSrvImpId(props.host, this.client.printConfig);
				printClient = PrintClient.getClient(_, srvId.host, srvId.port, props.trackId);
				printClient.launchReport(_, properties, jobRank);
				CvgReport.submitted(this.client, props);
				return [0, 1];
			} catch (e) {
				return replyError(this.client, new CvgException(this.client, e, null, null, "SrvImp Client"));
			}
		} else {
			var jobId = helpers.uuid.generate();
			try {
				properties.__DESTINATION = '3';
				properties._FormatExport = properties._FormatExport || '29';
				properties.__wJobID = jobId;
				srvId = _getSrvImpId(properties['+X3IMP'], this.client.printConfig);
				printClient = PrintClient.getClient(_, srvId.host, srvId.port, jobId);
				var seqId = printClient.launchReport(_, properties);
				if (seqId === 0) {
					// TODO: translate message
					return replyError(this.client, new CvgException(this.client, null, "An error has occured while submitting report to report server.", null, "SrvImp Server"));
				}
				CvgReport.submitted(this.client, {
					host: srvId.host + ":" + srvId.port,
					trackId: jobId,
					title: properties.X3TIT,
					rank: seqId,
					report: properties.__REPORT || "",
					mime: PrintClient.getMimeFromExport(properties._FormatExport)
				});
				var buf = new Buffer(2);
				buf.writeInt16BE(seqId, 0);
				return [buf[0], buf[1]];
			} catch (e) {
				console.error("NDOUVIMP error: " + e.stack);
				return replyError(this.client, new CvgException(this.client, e, null, null, "SrvImp Client"));
			}
		}
	},

	listenNodeNDGTIM: function(_, reader, node, properties) {
		//console.log("NDGTIM Properties IN: "+JSON.stringify(properties,null,2));
		var printClient, srvId;
		try {
			srvId = _getSrvImpId(properties._PrinterServer, this.client.printConfig);
			this.setSrvImp(srvId.host, srvId.port, this.client._cvgSession.sid);
			printClient = PrintClient.getClient(_, srvId.host, srvId.port, this.client._cvgSession.sid);
			var selPr = printClient.getAllPrinters(_);
			var selectedIdx = null,
				selected = properties._PrinterName || null;
			var i, meta = null,
				value, nullVal = -1,
				datasource, records, capabilities;
			// Merge NDGTIM and ALLPRINTER properties
			datasource = PrintHelpers.getDevmodeFromSrvProperties(properties);
			datasource.printers = [];
			records = datasource.printers;
			for (i in selPr) {
				// Find selected printer
				if (selPr[i].printerName === selected) {
					selectedIdx = i;
				}
				capabilities = [];
				records[i] = {};
				records[i].name = selPr[i].printerName || "";
				records[i].driver = selPr[i].driverName || "";
				records[i].port = selPr[i].printerPort || "";
				records[i].location = selPr[i].location || "";
				records[i].comment = selPr[i].comment || "";
				if (selPr[i].collate) {
					capabilities.push("collate");
				}
				if (selPr[i].copies) {
					capabilities.push("copies");
				}
				if (selPr[i].orientation) {
					capabilities.push("orientation");
				}
				if (selPr[i].duplex) {
					capabilities.push("duplex");
				}
				records[i].$capabilities = capabilities.join(',');
			}
			datasource.copies = properties._PrinterCopies ? parseInt(properties._PrinterCopies, 10) || 1 : 1;
			value = parseInt(properties._Orientation, 10);
			datasource.orientation = properties._Orientation ? (isNaN(value) ? nullVal : value) : nullVal;
			datasource.collate = properties._PrinterCollate ? (properties._PrinterCollate === "1" ? true : false) : false;
			datasource.startPage = properties._PrinterStartPage ? parseInt(properties._PrinterStartPage, 10) || null : null;
			datasource.stopPage = properties._PrinterStopPage ? parseInt(properties._PrinterStopPage, 10) || null : null;
			if (datasource.startPage != null && datasource.stopPage != null && datasource.startPage > 0 && datasource.stopPage !== 0 && datasource.stopPage <= 1000000 && datasource.stopPage >= datasource.startPage) {
				datasource.allPages = 1;
			} else {
				datasource.startPage = 1;
				datasource.stopPage = 9999;
				datasource.allPages = 0;
			}

			if (selectedIdx != null) {
				var sel = records.splice(selectedIdx, 1);
				sel[0].$isSelected = true;
				records.splice(0, 0, sel[0]);
			} else if (records.length !== 0) {
				records[0].$isSelected = true;
			}
			CvgImp.config(this.client, datasource, meta);

		} catch (e) {
			console.error(e.stack);
			// Houston?
			if (printClient) {
				printClient.__panicRelease();
			}
			var diag = CvgDiagnose.create(this.client, 'INFO', 99, locale.format(module, "LISTEN_NDGTIM_1"), '"' + srvId.host + ":" + srvId.port + '" : ' + (e.message || ""), e, "Protocol [listenNodeNDGTIM]", null, false);
			CvgImp.config(this.client, null, null, diag);
		} finally {
			this.workingCtx.pendingBlockingNode = {
				"proxy": "processSpecialAction",
				"id": "NDGTIM",
				"act": 514,
				"param": {
					"selpr": {}
				}
			};
		}
	},

	/**
	 * NDOWIN 0E0157 (Adxcpl_OpenWin) Ouverture fenetre (Fille - Independante -
	 * Selection - Formule) IN--> Id=[NDOWIN] x3func=[Adxcpl_OpenWin]
	 * elems=[hasArg:4,hasExtend] nb=[4] ist =[ win=[2] srn=[0] blc=[0] fld=[0]
	 * idx=[0]] nmw =[OAUS] nmf =[GESAUS] tsp =[20030617110837] NbExtends=[1]
	 */
	listenNodeNDOWIN: function(_, reader, node, ist, winId, funcId, stamp, extInfos) {
		// pour executer le traitement "standard" d'un empoilage de fenetre
		// next line is super.listenNodeNDOWIN(aSegmentNode);
		// do we really need it????
		//this.reply.setLastPushedWindow(new CAdonixWindow(winId, funcId, stamp));
		// glute : protection contre les ouvertures de fenetre tempon
		/*if (winId === "TEMPON") {
			this.nbNodeOpenTempon++;
			return true;
		}*/
		// gestion de la compatibilite des prefixes '&' et '_'
		// console.log("NDOWIN on ist : " + JSON.stringify(ist,null,2) + " - win id = " + JSON.stringify(winId,null,2) + " - ist.win = " + ist.win);
		if (winId.charAt(0) === '&') {
			winId = CvgWindow.PREFIX_SPECIAL + winId.substring(1);
		}
		var reply = this.reply;
		// construction et stockage du message Synchone "TYPE_NDOWIN" dans
		// le client
		// instancie une CvgStackedWindow : load la description et
		// instancie les structures
		var stackedWin = this.client.loadWindowDescription(_, ist, winId, funcId, stamp);
		reply.addPushedWindow(stackedWin);
		stackedWin.setNDOWinComplementDescr(extInfos.toString('utf8'));
	},

	/**
	 * NDRZAR 0E2D00 (LeftList_DeleteAllLine) Suppression de toute les lignes
	 * dans liste simple ou arbre
	 */
	listenNodeNDRZAR: function(_, reader, node, ist) {
		this.client.traverseSettable(ist, new CLeftListDeleter());
	},

	/**
	 * NDSUPLI 0E0A00 (Adxcpl_delGridLines) Suppression lignes dans tableau
	 */
	listenNodeNDSUPLI: function(_, reader, node, ist, targetLine, nbLines) {
		var deleter = new CDataSrcDeleter(this.client, targetLine, nbLines);
		this.client.traverseSettable(ist, deleter);
		if (deleter.hasLogicalErrMess()) {
			_postDiag(this, this.buildListenNodeMessage('ERROR_DELETER', nbLines.toString(), targetLine.toString(), deleter), 'NDSUPLI' + ist.toString());
		}
	},
	// "ist" "l'instance du niveau zero // Ne sert a rien !!!"
	// "errn (short)" "la variable errn valorisée par le moteur " "errn"
	// "errl (short)" "contient la variable errl valorisée par le moteur" "errl"
	// "errp (string)" "id du traitement dans la variable errp valorisée par le moteur"
	// "errt (car)" "contient  la variable errtyp valorisée par le moteur"
	// "errm (string)" "contient  la variable errm valorisée par moteur" "mess"
	listenNodeNDRESULT: function(_, reader, node, ist, errn, errl, errp, errt, errm, resu, tblParams, tblResus) {
		// Instantiate CvgReplyAckCall and store it in client.trackList.RPC
		if (errn !== 0 && this.sendContext.connect) {
			// add diagnosis 
			throw new CvgException(this.client, null, "errt[" + errt + "] errp[" + errp + "] errl[" + errl + "] errn[" + errn + "] errm[" + errm + "]", 'KILL', "4gl runtime");
		}

		CvgReplyAckCall.create(this.client, errn, errl, errp, errt, errm, resu[0], tblParams[0], tblResus[0]);
	},

	listenSendingArgsAckResi: function(aCommClient, aParams, ist, rpc) {
		// Remove all params except action id
		aParams.splice(1, aParams.length - 1);
		// Instanciate IST and push it in params
		ist = CvgIst.fromTarget(ist);
		aParams.push(ist); // instance
		if (rpc.xml) {
			jsxml.parse(rpc.xml);
		}
		// push errn,l,p,t,m
		// add all status of execution
		aParams.push(rpc.json.result.errn);
		aParams.push(rpc.json.result.errl);
		aParams.push(rpc.json.result.errp);
		aParams.push(rpc.json.result.errt);
		aParams.push(rpc.json.result.errm);
		// push return 
		var returnVal = rpc.xml ? jsxml.parse(rpc.xml) : rpc.json.return;
		var returnResu = CvgResu.fromAction(CvgResuTdo[returnVal.typ], returnVal.resu);
		aParams.push(returnResu);
		// push params
		if (rpc.json.params) {
			var params = rpc.json.params;
			var i, item, listParams = [];
			for (i = 0; i < params.length; i++) {
				// set the resu 
				item = params[i];
				item.resu = CvgResu.fromAction(CvgResuTdo[item.typ], item.resu);
				listParams.push(item);
			}

			aParams.push(listParams);
		} else {
			aParams.push([]);
		}
		// push table of resu debug info
		var debugInfos = [];
		if (rpc.json.debugInfos.exceptiondetail) {
			debugInfos.push(new CvgResu(CvgResuTdo.CLOB, rpc.json.debugInfos.exceptiondetail));
		} else {
			debugInfos.push(new CvgResu(CvgResuTdo.NULL, null));
		}
		if (rpc.json.debugInfos.totalduration) {
			debugInfos.push(new CvgResu(CvgResuTdo.DCB, rpc.json.debugInfos.totalduration));
		} else {
			debugInfos.push(new CvgResu(CvgResuTdo.NULL, null));
		}
		if (rpc.json.debugInfos.execduration) {
			debugInfos.push(new CvgResu(CvgResuTdo.DCB, rpc.json.debugInfos.execduration));
		} else {
			debugInfos.push(new CvgResu(CvgResuTdo.NULL, null));
		}
		if (rpc.json.debugInfos.trace) {
			debugInfos.push(new CvgResu(CvgResuTdo.CLOB, rpc.json.debugInfos.trace));
		} else {
			debugInfos.push(new CvgResu(CvgResuTdo.NULL, null));
		}
		aParams.push(debugInfos);
	},
	// set params for ack_call by analysing xml
	listenSendingArgsAckCall: function(aCommClient, aParams) {
		var call = aParams && aParams.length > 2 ? aParams[2] : null,
			ist = aParams && aParams.length > 1 ? aParams[1] : null;
		// Check params
		if (!ist || !call || (!call.json && !call.xml)) {
			_postDiag(this, "SRV_CALLREMOTESPGM - Can't perform remote call", "Json or Xml description missing");
			return;
		}
		// Remove all params except action id
		aParams.splice(1, aParams.length - 1);
		// Instanciate IST and push it in params
		ist = CvgIst.fromTarget(ist);
		aParams.push(ist);
		//		console.log("XML:\n"+call.xml);
		//		console.log("JSON:\n"+JSON.stringify(call.json,null,2));
		var callParams = call.xml ? jsxml.parse(call.xml) : call.json;
		// name of subprog
		var spgmId = call.xml ? callParams.spgm.$.id : callParams.spgm;
		// push name of su.program
		aParams.push(spgmId);
		// debug flag
		var debugFlags = call.xml ? callParams.spgm.$ : callParams.debugFlags;
		var flag = debugFlags ? (parseInt(debugFlags.trace, 10) << 3 | parseInt(debugFlags.execduration, 10) << 2 | parseInt(debugFlags.totalduration, 10) << 1 | parseInt(debugFlags.exceptiondetail, 10)) : 0;
		aParams.push(flag);
		var defs = []; // must be integer
		var values = []; // must be resu
		var paramDefs = call.xml ? callParams.spgm.param : callParams.params;
		var i, j, listResu, attributes, x3typ, v;
		for (i = 0; i < paramDefs.length; i++) {
			listResu = paramDefs[i].resu;
			attributes = call.xml ? paramDefs[i].$ : paramDefs[i];
			x3typ = CvgResuTag[attributes.typ];
			// add defs param i
			defs.push(parseInt(attributes.dim, 10)); //DIM
			defs.push(parseInt(attributes.nb, 10)); //NbVal
			defs.push(parseInt(attributes.size, 10)); //Size
			defs.push(x3typ + 256); //x3type
			//add value
			if (listResu) {
				if (Array.isArray(listResu)) {
					for (j = 0; j < listResu.length; j++) {
						v = typeof listResu[j] === 'object' ? (call.xml ? listResu[j].$cdata : listResu[j]) : listResu[j];
						values.push(new CvgResu.fromX3Type(x3typ, v));
					}
				} else {
					v = typeof listResu === 'object' ? (call.xml ? listResu.$cdata : listResu) : listResu;
					values.push(new CvgResu.fromX3Type(x3typ, v));
				}
			}
		}
		// tab def
		aParams.push(defs);
		// tab value
		aParams.push(values);
	},

	listenSendingArgs: function(body, aCommClient, aParams) {
		var timing = perfmonEnabled && perfmon.start(module, "cvgRequest.listenSendingArgs");
		switch (body.act) {
			case CvgAction.SRV_BRWCHANGELINE:
			case CvgAction.SRV_BRWSELECTLINE:
			case CvgAction.SRV_TREECHANGELINE:
			case CvgAction.SRV_TREEEXPANDLINE:
			case CvgAction.SRV_TREESELECTLINE:
				return this.listenActionArgsDOLEFTLISTLINE(aCommClient, aParams);
			case CvgAction.SRV_BRWRAPIDESEL:
				return this.listenActionArgsBRWRAPIDESEL(aCommClient, aParams);
			case CvgAction.SRV_LIST_PAGE_DOWN:
				return this.listenActionArgsLIST_PAGE_DOWN(aCommClient, aParams);
			case CvgAction.SRV_LIST_PAGE_UP:
				return this.listenActionArgsLIST_PAGE_UP(aCommClient, aParams);
			case CvgAction.SRV_PICKING:
				return this.listenActionArgsPICKING(aCommClient, aParams);
			case CvgAction.SRV_EXECI_RESPONSE:
				if (body.param.reply && (body.param.reply.json || body.param.reply.xml)) {
					this.listenSendingArgsAckResi(this, aParams, body.fld.ist, body.param.reply);
				} else {
					_postDiag(this, "SRV_EXECI_RESPONSE - Can't perform remote call", "Json or Xml description missing");
				}
				return;
			case CvgAction.SRV_CALLREMOTEFUNC:
			case CvgAction.SRV_CALLREMOTESPGM:
				this.listenSendingArgsAckCall(this, aParams);
				break;
			default:
				break;
		}
		if (perfmonEnabled) {
			timing.end();
		}
	},
	retrieveLeftList: function(aClient, aParams) {
		return aClient.findModifiable(aParams[1]);
	},
	setSrvImp: function(hostname, port, id) {
		this.srvImp = {
			hostname: hostname,
			port: port,
			id: id
		};
	}
});