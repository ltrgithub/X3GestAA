"use strict";
var helpers = require('syracuse-core/lib/helpers');
var streams = require('streamline/lib/streams/streams');
var jsxml = require('jsxml');
var Cvg = require('syracuse-x3/lib/convergence/model/Cvg').Cvg;
var CvgModifier = require('syracuse-x3/lib/convergence/model/CvgModifier').CvgModifier;
var CvgDataSrc = require('syracuse-x3/lib/convergence/model/CvgDataSrc').CvgDataSrc;
var CvgEntity = require('syracuse-x3/lib/convergence/model/CvgEntity').CvgEntity;
var CvgAction = require('syracuse-x3/lib/convergence/client/CvgAction').Actions;
var CvgFormat = require('syracuse-x3/lib/convergence/model/CvgFormat').CvgFormat;
var CvgResu = require('syracuse-x3/lib/convergence/types/CvgResu').CvgResu;
var CvgIst = require('syracuse-x3/lib/convergence/types/CvgIst').CvgIst;
var CvgLeftListLineNode = require('syracuse-x3/lib/convergence/model/CvgLeftListLineNode').CvgLeftListLineNode;
var CvgException = require('syracuse-x3/lib/convergence/model/CvgException').CvgException;
var CvgWindow = require('syracuse-x3/lib/convergence/model/CvgWindow').CvgWindow;
var CvgMessage = require('syracuse-x3/lib/convergence/model/CvgMessage').CvgMessage;
var CvgVariableCombo = require('syracuse-x3/lib/convergence/model/CvgVariableCombo').CvgVariableCombo;

var CONNECT_ACTION = require('syracuse-x3/lib/convergence/client/CvgAction').CONNECT_ACTION;

var MSG_INFORMATION = 0;
var MSG_WARNING = 1; // Boite d'Avertissement
var MSG_QUESTION = 2; // Boite de Question
var MSG_ERROR = 3;
var MSG_STOP = 4; // Boite Abort
var OU_BAV = 11; /* Boite d'Avertissement */
var OU_BEN = 15; /* Boite end : Abort ! */
var OU_BER = 10; /* Boite d'Erreur */
var OU_BIF = 14; /* Boite d'Information */
var OU_BQU = 12; /* Boite de Question */
var OU_BSE = 13; /* Boite de Selection */


var CAdonixRequest = Object; //require('syracuse-x3/lib/convergence/CAdonixRequest').CAdonixRequest;
var CDataSrcAffStateSetter = exports.CDataSrcAffStateSetter = helpers.defineClass(function(cli, aAftbTyp, aNbLines) {

	this.aftbTyp = aAftbTyp;
	this.nbLines = aNbLines;
	this.cli = cli;
}, CvgModifier, {
	setModifiable: function(aStructIst, aModifiable) {
		this.done = aModifiable instanceof CvgDataSrc;
		if (this.done) {
			aModifiable.setAffState(this.aftbTyp, this.nbLines);
		} else {
			setLogicalErrMess(this.cli.getMessage('ERROR_NOT_RIGHT_MODIFIABLE', aModifiable.getAdxId(), 'CvgDataSrc'));
		}
		return this.done;
	}
});

var CDataSrcDeleter = exports.CDataSrcDeleter = helpers.defineClass(function(cli, aTargetLine, aNbLines) {

	this.cli = cli;
	this.targetLine = aTargetLine;
	this.nbLines = aNbLines;
}, CvgModifier, {
	setModifiable: function(aStructIst, aModifiable) {
		this.done = aModifiable instanceof CvgDataSrc;
		if (this.done) {
			var ds = aModifiable;
			if (this.nbLines == -1) {
				ds.serverRemoveAllLines();
			} else {
				ds.serverRemoveLines(this.targetLine, this.nbLines);
			}
		} else {
			setLogicalErrMess(this.cli.getMessage('ERROR_NOT_RIGHT_MODIFIABLE', aModifiable.getAdxId(), 'CvgDataSrc'));
		}
		return this.done;
	}
});

var CDataSrcInserter = exports.CDataSrcInserter = helpers.defineClass(function(cli, aTargetLine, aNbLines) {

	this.cli = cli;
	this.zeroBasedIdx = aTargetLine;
	this.nbLines = aNbLines;
}, CvgModifier, {
	setModifiable: function(aStructIst, aModifiable) {
		this.done = aModifiable instanceof CvgDataSrc;
		//console.log("\tsetMod=" + aStructIst.toString() + " - " + this.zeroBasedIdx + " - " + this.nbLines);
		if (this.done) {
			var wDataSrc = aModifiable;
			wDataSrc.serverInsertLines(this.zeroBasedIdx, this.nbLines);
			if (wDataSrc.hasDimOverFlow()) {
				setLogicalErrMess(this.cli.getMessage('ERROR_DIM_OVERFLOW', String.valueOf(wDataSrc.dim), String.valueOf(this.nbLines), String.valueOf(wDataSrc.lines.length)));
			}
		} else {
			setLogicalErrMess(this.cli.getMessage('ERROR_NOT_RIGHT_MODIFIABLE', aModifiable.getAdxId(), 'CvgDataSrc'));
		}
		return this.done;
	}
});

var CDownloadListner = exports.CDownloadListner = helpers.defineClass(function(aClient) {
	this.client = aClient;
}, null, {
	listenActivity: function(aActivityLib, aPercent) {
		var wSB = new StringBuilder();
		wSB.append(aActivityLib);
		wSB.append(String.format(" : [%d/100]", aPercent));
		this.client.pushAffSynchroneMessTempOn(wSB.toString());
		return true;
	}
});

var CEntityStateSetter = exports.CEntityStateSetter = helpers.defineClass(function(aEntityState) {
	CvgModifier.call(this);
	this.state = aEntityState;
}, CvgModifier, {
	setModifiable: function(aStructIst, aModifiable) {
		/*
		 * STATE_INVISIBLE, STATE_VISIBLE, STATE_EDITABLE, STATE_GRIZO,
		 * STATE_DISZO, WANT_SELECT, WANT_UNSELECT
		 */
		aModifiable.stateSet(this.state, true);
		this.done = true;
		return this.done;
	}
});

var CLeftListAppender = exports.CLeftListAppender = helpers.defineClass(function(aIdx, aBranche, aTxt, aVal, aClf, aClp) {
	CvgModifier.call(this);
	this.idx = aIdx;
	this.branche = aBranche;
	this.txt = aTxt;
	this.val = aVal;
	this.clf = aClf;
	this.clp = aClp;
}, CvgModifier, {
	setModifiable: function(aStructIst, aModifiable) {
		aModifiable.appendLeftListLine(this.idx, this.branche, this.txt, this.val, this.clf, this.clp);
		this.done = true;
		return this.done;
	}
});

var NDCOLAR_MODIF_FORMATS = 1;

var CLeftListColumnsModifier = exports.CLeftListColumnsModifier = helpers.defineClass(function(aWhat, aDefs) {
	CvgModifier.call(this);
	this.whatModification = aWhat;
	this.defs = aDefs;
}, CvgModifier, {
	// modif des formats
	setModifiable: function(aStructIst, aModifiable) {
		if (this.whatModification == NDCOLAR_MODIF_FORMATS) {
			aModifiable.changeColumnsFormats(this.defs);
		} else {
			aModifiable.changeColumnsTitles(this.defs);
		}
		this.done = true;
		return this.done;
	}
});

var CLeftListDeleter = exports.CLeftListDeleter = helpers.defineClass(function() {
	CvgModifier.call(this);
}, CvgModifier, {
	setModifiable: function(aStructIst, aModifiable) {
		aModifiable.serverRemoveAllLines();
		this.done = true;
		return this.done;
	}
});

var CLeftListPickingSelecter = exports.CLeftListPickingSelecter = helpers.defineClass(function(selected) {
	CvgModifier.call(this);
	this.selected = selected;
}, CvgModifier, {
	setModifiable: function(aStructIst, aModifiable) {
		aModifiable.setLeftListLinePickingSel(this.selected);
		this.done = true;
		return this.done;
	}

});

var CLeftListSelecterByKey = exports.CLeftListSelecterByKey = helpers.defineClass(function(selected, aCle, request) {
	CvgModifier.call(this);
	this.selected = selected;
	this.cle = aCle;
	this.request = request;
}, CvgModifier, {
	setModifiable: function(aStructIst, aModifiable) {
		aModifiable.setServerSelectLine(this.selected, this.cle);
		this.request.setLefListLineSelected(aModifiable.findLineIdx(this.cle));
		this.done = true;
		return this.done;
	}
});

var CServerFormatSetter = exports.CServerFormatSetter = helpers.defineClass(function(cli, aFormat) {
	CvgModifier.call(this);
	this.format = aFormat;
	this.inferredState = CvgEntity.STATE_DEFAULT;
}, CvgModifier, {
	hasInferredState: function() {
		return this.inferredState !== CvgEntity.STATE_DEFAULT;
	},
	setModifiable: function(aStructIst, aModifiable) {
		this.inferredState = aModifiable.setServerFormat(new CvgFormat(this.format));
		this.done = true;
		return this.done;
	}
});

var CServerStateSetter = exports.CServerStateSetter = helpers.defineClass(function(aState) {
	CvgModifier.call(this);
	this.entitryState = aState;
}, CvgModifier, {
	setModifiable: function(aStructIst, aModifiable) {
		aModifiable.stateSet(this.entitryState, true);
		this.done = true;
		return this.done;
	}
});

var CServerStyleSetter = exports.CServerStyleSetter = helpers.defineClass(function(aStyle, applyOn) {
	CvgModifier.call(this);
	this.style = aStyle;
	this.applyOn = applyOn;
}, CvgModifier, {
	setModifiable: function(aStructIst, aModifiable) {
		aModifiable.setServerStyle(this.style, this.applyOn);
		this.done = true;
		return this.done;
	}
});

var CServerTitleSetter = exports.CServerTitleSetter = helpers.defineClass(function(aTitle) {
	CvgModifier.call(this);
	this.title = aTitle;
}, CvgModifier, {
	setModifiable: function(aStructIst, aModifiable) {
		aModifiable.setServerTitle(this.title);
		this.done = true;
		return this.done;
	}
});

var CServerValueSetter = exports.CServerValueSetter = helpers.defineClass(function(aResu) {
	CvgModifier.call(this);
	this.resu = aResu;
}, CvgModifier, {
	setModifiable: function(aStructIst, aModifiable) {
		aModifiable.setServerValue(this.resu);
		this.done = true;
		return this.done;
	}
});

var CvgRequest = exports.CvgRequest = helpers.defineClass(function(aClient, aAdonixReply, aParams, sendContext) {
	CAdonixRequest.call(this, aClient, aAdonixReply, aParams, sendContext);
	this.client = aClient;
	this.reply = aAdonixReply; // added by BRJOU
	this.nbNodeOpenTempon = 0;
	this.lefListLineSelected = -1;
	this.sendContext = sendContext;
}, CAdonixRequest, {
	breakWaiting: function(aCompleteReply) {
		TODO_SUPER.breakWaiting(aCompleteReply);
	},
	buildIstDatasOfAction: function(aParam) {
		var ist = null;
		// si l'objet passe est une instance de CvgIstDatas => fin
		if (aParam && aParam instanceof CvgIst) {
			ist = aParam;
		}
		// si l'objet passe est une string
		else if (aParam && typeof aParam === String) {
			// si l'objet passe est une string vide => fin
			if (aParam.length === 0) {
				return new CvgResu();
			}
		}
		var cli = this.client;
		// si l'objet passe n'a pas permis de construire un istdata => erreur
		if (ist == null) {
			var wMess = cli.getMessage('ERROR_NO_ISTDATA', JSON.stringify(aParam));
			throw new CvgException(this.client, wMess);
		}
		// si cet ist n'a pas d'instance => fin
		if (!ist.hasIst()) {
			return ist;
		}
		// si le browser a retourne un resu "null" => fin
		if (ist.editedResuTyp == CvgResu.X3TYP_NULL) {
			return ist;
		}
		var wEntity = cli.findModifiable(ist.ist);
		// si l'instance n'est pas une variable
		if (!(wEntity instanceof CvgVariable)) {
			return ist;
		}
		var v = wEntity;
		try {
			// si la donnee a un format dedit et editee dans l'IstData est au
			// format "EDIT"
			if (v.acceptEditFormat() && ist.isEditFormat()) {
				// deformatage : format edition => format presentation. Peut
				// lever une exception de formatage ou de valorisation
				ist.setEditedValue(v.formatEditToDisplay(ist.editedValue));
				// ajout d'un noeud "ist" "previous" avec la valeur reformatee.
				// Exemple : <ist which="previous" C="B,B,B5" format="show"
				// IstFmt="N+:5.5#">0,02000</ist>
				this.reply.addInstance(CvgInstance.newprevious(cli, ist.ist, entity.format.format, ist.editedValue, this.reply == null ? false : this.reply.stayInCommandMode));
			}
			// deformatage : format presentation => format brut
			ist.setValueProtected(v.resuTyp, v.unFormatData(ist.editedValue));
			v.setBrowserUnformattedValue(ist);
			return ist;
		} catch (e) {
			console.error("ERR: "+e.stack);
			// Récupération de l'erreur de formatage pour info client
			var instance = CvgInstance.newtarget(cli, ist.ist, v.format.format, ist.editedValue, this.reply == null ? false : this.reply.stayInCommandMode);
			instance.exception = e;
			this.reply.addInstance(instance);
			throw e;
		}
	},
	buildListenNodeMessage: function(aKeyMess, aValue1, aModifier) {
		var wMess = this.client.getMessage(aKeyMess, aValue1);

		if (aModifier.hasLogicalErrMess()) {
			return wMess + aModifier.logicalErrMess;
		} else {
			return wMess;
		}
	},
/* TODO overload
	buildListenNodeMessage: function(aKeyMess, aValue1, aValue2, aModifier) {
		var wMess = this.client.getMessage(aKeyMess, aValue1, aValue2);

		if (aModifier.hasLogicalErrMess()) {
			return wMess + aModifier.logicalErrMess;
		} else {
			return wMess;
		}
	},*/
	getAffSynchroneAction: function(aMess, aPos) {
		var wPosStart = aPos + Cvg.AFF_SYNCHRONE_HEADER_LONG + Cvg.AFF_SYNCHRONE_TYPE_LONG;
		var wPosEnd = wPosStart + Cvg.AFF_SYNCHRONE_ACTION_LONG;
		var wAction = aMess.substring(wPosStart, wPosEnd);
		if (wAction === "MOD") {
			return Cvg.AFF_SYNCHRONE_ACTION_MODIFY;
		}
		if (wAction === "OPE") {
			return Cvg.AFF_SYNCHRONE_ACTION_OPEN;
		}
		if (wAction === "CLO") {
			return Cvg.AFF_SYNCHRONE_ACTION_CLOSE;
		}
		return 0;
	},
	getAffSynchroneType: function(aMess, aPos) {
		var wPosStart = aPos + Cvg.AFF_SYNCHRONE_HEADER_LONG;
		var wPosEnd = wPosStart + Cvg.AFF_SYNCHRONE_TYPE_LONG;
		var wType = aMess.substring(wPosStart, wPosEnd);
		if (wType === "PROG") {
			return Cvg.AFF_SYNCHRONE_TYPE_PROGRESS;
		}
		if (wType === "VLC_") {
			return Cvg.AFF_SYNCHRONE_TYPE_VALIDCAR;
		}
		if (wType === "SESS") {
			return Cvg.AFF_SYNCHRONE_TYPE_SESSION;
		}
		if (wType === "TEMP") {
			return Cvg.AFF_SYNCHRONE_TYPE_TEMPON;
		}
		if (wType === "DBG_") {
			return Cvg.AFF_SYNCHRONE_TYPE_DEBUGON;
		}
		if (wType === "VOIC") {
			return Cvg.AFF_SYNCHRONE_TYPE_VOICE;
		}
		return 0;
	},

	loadWindowDescription: function(_, wWindowsId) {

		var lang = this.client.appSrvSessionSettings.cdLang;
		var adxHttpPub = this.client.adxInfos.adxHttpPub;
		var adxFolder = this.client.adxInfos.adxFolder;

		function getWindowXml(_, wWindowsId) {
			//if (true) return require('fs').readFile(__dirname + "/../data/" + wWindowsId + ".xml", "utf8", _);
			var opt = {
				method: "GET",
				url: adxHttpPub + "/" + adxFolder + "/GEN/" + lang + "/FENS/" + wWindowsId + ".xml",
				headers: {}
			}
			if (helpers.proxy) {
				opt.proxy = "http://" + helpers.proxy.server + ":" + helpers.proxy.port;
			}

			var request = streams.httpRequest(opt);

			var response = request.end().response(_);
			response.setEncoding('utf8');
			console.log("statusCode=" + response.statusCode);
			var body = response.readAll(_);
			if (response.statusCode === 200 && body) {
				return body;
			} else {
				throw new Error(response.statusCode + ": " + body);
			}
			//			return require('fs').readFileSync("./data/OAMK.xml", 'utf8');
		}

		return jsxml.parse(getWindowXml(_, wWindowsId)).WIND;
	},

	/**
	 * Modifie le contenu de la liste d'arguments re�u du brwowser pour une
	 * action SRV_BRWRAPIDESEL
	 *
	 * SRV_BRWRAPIDESEL (1069) = 1024 + ACK_SLRP (45)
	 *
	 * Re�oit : -(a) le r�su associ� � l'action -(b) l'adxid (ist) de la liste
	 * gauche -(c..k) n resus (sous la forme "adxid^tdo^value" ) des n colonnes
	 * de la liste gauche Supprime : - les n r�sus Ajoute : - une table de n
	 * instances de CvgResu contenant les n valeurs de filtrage des n
	 * colonnes
	 */
	listenActionArgsBRWRAPIDESEL: function(aClient, aParams) {
		var wNbArgs = aParams.length;
		var wTabOfResus = new ArrayList();
		var wI = 2;
		var wColValue;
		while (wI < wNbArgs) {
			wColValue = aParams.get(wI);
			// ajoute dans la table un resu deformate construit a partir de la
			// chaine "adxid^tdo^value"
			wTabOfResus.add(new CvgResu(CvgResu.X3TYP_STRU, wColValue));
			wI++;
		}
		wI = wNbArgs - 1;
		while (wI >= 2) {
			aParams.remove(wI);
			wI--;
		}
		aParams.add(wTabOfResus);
	},

	/**
	 * Modifie le contenu de la liste d'arguments re�u du brwowser pour une
	 * action SRV_BRWCHANGELINE ou SRV_BRWSELECTLINE ou SRV_TREECHANGELINE ou
	 * SRV_TREEEXPANDLINE ou SRV_TREESELECTLINE SRV_BRWCHANGELINE (1051) = 1024
	 * + ACK_CLST (27) SRV_BRWSELECTLINE (1052) = 1024 + ACK_SLST (28)
	 * SRV_TREECHANGELINE (1060) = 1024 + ACK_CABR (36) SRV_TREEEXPANDLINE
	 * (1061) = 1024 + ACK_SABR (37) SRV_TREESELECTLINE (1062) = 1024 + ACK_DABR
	 * (38)
	 *
	 * Re�oit : -(a) le r�su associ� � l'action -(b) l'adxid (IST) de la ligne
	 * selectionnee Modifie : - l'adxid (IST) pour supprimer l'index de la ligne
	 * Ajoute : - la cle apr�s l'argument IST
	 */
	listenActionArgsDOLEFTLISTLINE: function(aClient, aParams) {
		console.log(aParams);
		/*
		 * Construction d'une StructIst d�signant la ligne s�lectionn�e � partir
		 * du deuxi�me argument 14w_006 - Evolution TermServer - Liste gauche /
		 * choose Accepte une instance de CvgIst en tant que deuxi�me
		 * param�tre
		 */
		 var wArgIst = aParams[1]
		if (typeof wArgIst === "string")
			wArgIst = new CvgIst(aParams[1]);
		else if (!(wArgIst instanceof CvgIst)) throw new CvgException(this.client, "ARG_WRONG - need a \"CvgIst\" or a \"String\" !");

		if (!wArgIst.isLineIst()) {
			throw new CvgException(this.client, "ARG_WRONG - need a \"line\" ist !");
		}
		var wLeftListLine = aClient.findModifiable(wArgIst);
		// si l'action porte sur une instance de "CvgLeftListNode" il faut
		// memoriser le noeud de "source de l'action" car le traitement des
		// noeuds en reponse en d�pend.
		if (wLeftListLine instanceof CvgLeftListLineNode) {
			var wLeftListNode = wLeftListLine;
			/*
			 * Stockage dans la liste gauche r�cursive de l'id du Node �
			 * "expandre"
			 */
			wLeftListNode.dataSrc.setNodeIdToExpanded(wArgIst.idx);
		}
		aParams.push(wLeftListLine.cle);
		wArgIst.idx = 0; //wArgIst.setLine(0);
		aParams[1] = wArgIst;
	},

	/**
	 * 15w_002 - Fiche 36375 - VT: accepter CvgIst comme argument de PAGEUP,
	 * PAGEDOWN
	 *
	 * Modifie le contenu de la liste d'arguments re�u du brwowser pour une
	 * action SRV_LIST_PAGE_DOWN
	 *
	 * SRV_LIST_PAGE_UP (1072) = 1024 + ACK_FRWD (49)
	 *
	 * Re�oit : -(a) le r�su associ� � l'action -(b) l'adxid (IST) de la ligne
	 * selectionnee Modifie :
	 *
	 * Ajoute : - la cle de la premere ligne apres l'argument IST
	 */
	listenActionArgsLIST_PAGE_DOWN: function(aClient, aParams) {
		var wLeftList = this.retrieveLeftList(aClient, aParams);
		var wLeftListLine = wLeftList.getLastLine();
		if (wLeftListLine != null) {
			aParams.push(wLeftListLine.cle);
		}
	},

	/**
	 * 15w_002 - Fiche 36375 - VT: accepter CvgIst comme argument de PAGEUP,
	 * PAGEDOWN Modifie le contenu de la liste d'arguments reeu du brwowser pour
	 * une action SRV_LIST_PAGE_UP SRV_LIST_PAGE_DOWN (1073) = 1024 + ACK_REWD
	 * (48)
	 *
	 * Recoit : - le reesu associe � l'action - l'IST de la ligne selectionnee
	 * Modifie :
	 *
	 * Ajoute : - la cle de la derniere ligne apres l'argument IST
	 */
	listenActionArgsLIST_PAGE_UP: function(aClient, aParams) {
		var wLeftList = this.retrieveLeftList(aClient, aParams);
		var wLeftListLine = wLeftList.getFirstLine();
		if (wLeftListLine != null) {
			aParams.push(wLeftListLine.cle);
		}

	},

	/**
	 * Modifie le contenu de la liste d'arguments recu du brwowser pour une
	 * action SRV_PICKING
	 *
	 * SRV_PICKING (1066) = 1024 + ACK_PICK (42) * Recoit : -(a) le resu associe
	 * a l'action -(b) l'adxid (ist) de la liste gauche -(c) n adxid (IST) des n
	 * lignes a selectionner ou a deselectionner separes par un '^' -(d) n
	 * actions (autant que de lignes) de selection ("1052" SRV_BRWSELECTLINE) ou
	 * de deselection ("1067" SRV_BRWDESELECTLINE) separes par un '^' Modifie :
	 * - l'IST piour supprimer l'index de la ligne Supprime
	 *
	 * Ajoute : - la cle apres l'argument IST
	 */
	listenActionArgsPICKING: function(aClient, aParams) {
		/*
		 * attribut "c" : n adxid (IST) des n lignes a selectionner ou a
		 * deselectionner separes par un '^' stockage des AdxId dans n StructIst
		 * bufferiszes au niveau du client Exemple : <A I="1066" a="" b="B,AH,C"
		 * c="B,AH,C,5^B,AH,C,6" d="1052^1052" T="0" >0^</A>
		 */
		var wSTAdxids = aParams[2].split('^');
		/*
		 * attribut "d" : action de selection ou de d�s�lection 1052
		 * SRV_BRWSELECTLINE ou 1067 SRV_BRWDESELECTLINE stockage au niveau du
		 * client
		 */
		var wSTActions = aParams[3].split('^');
		// vidage de la liste de ligne pickees
		this.client.clearAdxIstsOfPickedLines();
		// Picking : pas de depickage par programme chargement de la liste
		var wStructIst;
		var wPickedLine;
		var wAction;
		for (var i = 0; i < wSTAdxids.length; i++) {
			wStructIst = new CvgIst(wSTAdxids[i]);
			wAction = parseInt(wSTActions[i], 10);
			wPickedLine = new CvgPickedLine(wStructIst, wAction);
			this.client.traverseSettable(wStructIst, new CLeftListPickingSelecter(wPickedLine.isSelection()));
			this.client.addAdxIstOfPickedLines(wPickedLine);
		}
		aParams.splice(2, 2);
	},

	listenException: function(e) {
		setMemorizedException(e);
		return true;
	},

	/* from CAdonixRequest */
	listenNodeNDGIST: function(_, reader, node, wIst) {
		this.setTargetAdxId(wIst);
	},

	/**
	 * "AskPutFile", "AskSelFile", "AskReadTextFile", "AskExecShell",
	 * "AskGetFile"
	 */
	listenNodeND_ASK: function(_, reader, node) {
		console.log("ND_ASK nodes are ignored in fusion client");
		return true;
	},

	/**
	 * transfert un fichier du serveur dans l'espace temporaire en le renomant.
	 * Le renomage est
	 *
	 * -90 Impossible de se connecter � un serveur sadfsq [%s] avec les
	 * param�tres fournis [%s]. -91 Transfert impossible dossier source
	 * inexistant -92 Transfert impossible dossier source inaccessible (droits)
	 * -93 Transfert impossible parm�tre RemotePath non fourni.
	 */

	listenNodeND_ASKGetFile: function(aExtendProperties) {
		var wRemoteFileDescriber = aExtendProperties.getOnePropertyValue(CAdonixClient.ASKUI_PARAM_REMOTEPATH);
		var wDownloadListner = new CDownloadListner(this.client);
		return this.client.getNewAdonixFileManager(wDownloadListner).getFile(wRemoteFileDescriber);
	},

	listenNodeND_ASKSendAutoReply: function(_, aNumError, aExplaination) {
		var wResponse = new StringBuilder();
		wResponse.append(aNumError);
		wResponse.append(',');
		wResponse.append(aExplaination);
		var wIstDatas = new CvgIstDatas(CvgResu.X3TYP_STRU, wResponse.toString());
		var wProtocolNum = this.adonixClient.remoteProtocolNum;
		var wSegReplyAction = CSegmentActionFactory.buildSegmentAction(true, wProtocolNum, CvgAction.SRV_ASKUI_RESPONSE, wIstDatas);
		try {
			if (this.client.typeClient == ETypeClient.JULIET) {
				this.connClient.writeSegment(wSegReplyAction);
			} else {
				this.adonixClient.writeSegment(wSegReplyAction, false);
			}
		} catch (e) {
			throw e;
			//throw new CCommException(CCommException.CANT_SEND, e, this.client.getMessCantSendAutomaticReply("ND_ASK"););
		}
	},

	/**
	 * ND_CLF 0E1400 (Adxcpl_CloseWin) Fermeture d'une fen�tre Id=[ND_CLF]
	 * level=[?] x3func=[Adxcpl_CloseWin] nb=[1] ist =[ win=[2] srn=[0] blc=[0]
	 * fld=[0] idx=[0] ]
	 */
	listenNodeND_CLF: function(_, reader, node, wIst) {
		// IN--> ist =[ win=[2] srn=[0] blc=[0] fld=[0] idx=[0]]
		if (this.nbNodeOpenTempon > 0) {
			this.nbNodeOpenTempon--;
			return;
		}
		var wStackedWindow = this.client.popRequesterWindow();
		var reply = this.reply;
		reply.addPopedWindow(wStackedWindow);
	},

	/**
	 * ND_DCL 0E2400 (LeftList_NewRequete) Debut de chargement liste simple ou
	 * arbre Id=[ND_DCL] func=[LeftList_NewRequete] NbArgs=[1] ist =[ win=[2]
	 * srn=[34] blc=[1] fld=[0] idx=[0]]
	 */
	listenNodeND_DCL: function(_, reader, node) {},

	/**
	 * ND_FCL 0E2500 (LeftList_CloseReq) Fin de chargement liste simple ou arbre
	 * Id=[ND_FCL] func=[LeftList_CloseReq] NbArgs=[1] ist =[ win=[2] srn=[34]
	 * blc=[1] fld=[0] idx=[0]]
	 */
	listenNodeND_FCL: function(_, reader, node) {},

	/**
	 * ND_ICL 111000 (LeftList_SynchroRequete) Interrogation chargement liste *
	 * Id=[ND_ICL] func=[LeftList_SynchroRequete] NbArgs=[1] ist =[ win=[2]
	 * srn=[34] blc=[1] fld=[0] idx=[0]]
	 */
	listenNodeND_ICL: function(_, reader, node) {
		return [1];
	},

	/**
	 * Ouverture d'une session secondaire
	 */
	listenNodeND_NAP: function(_, reader, node, wTxt) {
		this.reply.setAskOpenSession(wTxt);
	},
	listenNodeND_REB: function(_, reader, node) {
		// Notify observer
		new CvgReboot(this.client);
	},

	/**
	 * NDAFTB 0E2600 (Grid_setRedraw) Activation/Desactivation mode affichage
	 * tableau debut et fin ensemble de neoud de tableau
	 */
	listenNodeNDAFTB: function(_, reader, node, wArgIst, wAffTbState, wNbLines) {
		var wDataSrcAffStateSetter = new CDataSrcAffStateSetter(this.client, wAffTbState, wNbLines);
		this.client.traverseSettable(wArgIst, wDataSrcAffStateSetter);
		if (!wDataSrcAffStateSetter.done) {
			var wState = CvgDataSrc.aftbTypToString(wAffTbState);
			var wMessLE = this.buildListenNodeMessage('ERROR_AFFSTATE', wState, wDataSrcAffStateSetter);
			this.reply.addLogicalErrorMess(this, CProtocolDefs.protocoleDefs.getProtocolDef(this.conn.remoteProtocolNum).findNode(CvgNode.NDAFTB).fullIdInString, wArgIst.toString(), wMessLE);

			// aSegmentNode.setLogicalErrFlag();
		}
	},

	/**
	 * NDCHCR 114300 (Adxcpl_setColor) Modification couleur champ/cellule
	 * tableau Id=[NDCHCR] x3func=[Adxcpl_setColor] elems=[hasArg:2] nb=[2] ist
	 * =[ win=[2] srn=[4] blc=[1] fld=[5] idx=[1] ] st=[.x14]
	 * Dump=[.x00.x00.x09.x11.x43.x02.x04.x01.x05.x00.x01.x14]
	 */
	listenNodeNDCHCR: function(_, reader, node) {},

	/**
	 * NDCHFM 0E4300 (Adxcpl_setFormat) Mise a jour Format champ/cellule tableau
	 * Id=[NDCHFM] x3func=[Adxcpl_setFormat] elems=[hasArg:2] nb=[2] ist =[
	 * win=[2] srn=[7] blc=[2] fld=[11] idx=[0] ] txt
	 * =[K:2#[.]2#[.]2#[.]2#[.]2#[ ]]
	 * Dump=[.x00.x00.x2C.x0E.x43.x02.x07.x02.x0B.
	 * x00.x00.x00.x22.x00.x20.x4B.x3A
	 * .x32.x23.x5B.x2E.x5D.x32.x23.x5B.x2E.x5D.x32
	 * .x23.x5B.x2E.x5D.x32.x23.x5B.x2E
	 * .x5D.x32.x23.x5B.x20.x20.x20.x20.x20.x20.x5D]
	 */
	listenNodeNDCHFM: function(_, reader, node, wArgIst, wFormat) {
		var wFormatSetter = new CServerFormatSetter(this.client, wFormat);
		var wIst = wArgIst;
		this.client.traverseSettable(wIst, wFormatSetter);
		if (wFormatSetter.hasInferredState() && wArgIst.isCellIst()) {
			// pour designer la colonne
			wIst.idx = -1;
			var wStateSetter = new CEntityStateSetter(wFormatSetter.inferredState);
			this.client.traverseSettable(wIst, wStateSetter);
		}
		if (!wFormatSetter.done) {
			var wMessLE = this.buildListenNodeMessage('ERROR_SETTER_FORMAT', wFormat, wFormatSetter);
			this.reply.addLogicalErrorMess(this, 'NDCHFM', wArgIst.toString(), wMessLE);
			// aSegmentNode.setLogicalErrFlag();
		}
	},

	/**
	 * NDCHGR 0E1F00 (Adxcpl_setState) Activation / desactivation champ/cellule
	 * tableau 0 grizo 1 actzo 2 diszo
	 */
	listenNodeNDCHGR: function(_, reader, node, wArgIst, wState) {
		// 0 "SRV_GRIZO";
		// 1 "SRV_ACTZO"
		// 2 "SRV_DISZO";
		// state - status Java
		var state = CvgEntity.x3State2EntityState(wState);
		var wStateSetter = new CServerStateSetter(state);
		this.client.traverseSettable(wArgIst, wStateSetter);
		if (!wStateSetter.done) {
			this.reply.addLogicalErrorMess(this, 'NDCHGR', wArgIst.toString(), buildListenNodeMessage('ERROR_SETTER_STATE', CvgEntity.x3StateToString(wState), wStateSetter));
			// aSegmentNode.setLogicalErrFlag();
		}
	},

	listenNodeNDCHVB: function(_, reader, node, wArgIst, wResus) {
		var wExtendResu = wResus[0]
		var wValueSetter = new CServerValueSetter(wExtendResu.valueResu);
		this.client.traverseSettable(wArgIst, wValueSetter);
		if (!wValueSetter.done) {
			var wBlobSize = String.valueOf(wExtendResu.valueResu.valueLength);
			var wMessLE = this.buildListenNodeMessage('ERROR_SETTER_BLOB', wBlobSize, wValueSetter);
			this.reply.addLogicalErrorMess(this, 'NDCHVB', wArgIst.toString(), wMessLE);
			// aSegmentNode.setLogicalErrFlag();
		}
	},

	/**
	 * NDCHVL 114600 (Adxcpl_setValue) Mise a jour valeur champ/cellule tableau
	 *
	 * IN--> Id=[NDCHVL] x3func=[Adxcpl_setValue] elems=[hasArg:2] nb=[2] ist =[
	 * win=[2] srn=[4] blc=[1] fld=[2] idx=[4] ] st=[ typ=[122,STRU] val=[CPT] ]
	 * Dump
	 * =[.x00.x00.x12.x11.x46.x02.x04.x01.x02.x00.x04.x7A.x03.x00.x43.x00.x50
	 * .x00.x54.x00.x00]
	 */
	listenNodeNDCHVL: function(_, reader, node, ist, resu) {
		var wValueSetter = new CServerValueSetter(resu);
		this.client.traverseSettable(ist, wValueSetter);
		if (!wValueSetter.done) {
			var wMessLE = this.buildListenNodeMessage('ERROR_SETTER_VALUE', resu.toString(), wValueSetter);
			this.reply.addLogicalErrorMess(this, 'NDCHVL', ist.toString(), wMessLE);
			// aSegmentNode.setLogicalErrFlag();
		}
	},

	/**
	 * NDCHST 0E3400 (Adxcpl_setStyle) Mise a jour Style champ/cellule tableau
	 * Id=[NDCSTL] x3func=[Adxcpl_setStyle] elems=[hasArg:2] nb=[2] ist =[
	 * win=[2] srn=[7] blc=[2] fld=[11] idx=[0] ] txt =[STYLE]
	 */
	listenNodeNDCSTL: function(_, reader, node, wArgIst, sty) {
		var styleApply;
		if (wArgIst.idx === -1) {
			styleApply = 'CHILDS';
		} else if (wArgIst.idx === -2) {
			styleApply = 'TITLE';
		} else {
			styleApply = 'ENTITY';
		}
		var wStyleSetter = new CServerStyleSetter(sty, styleApply);
		this.client.traverseSettable(wArgIst, wStyleSetter);
		if (!wStyleSetter.done) {
			var wMessLE = this.buildListenNodeMessage('ERROR_SETTER_STYLE', sty, wStyleSetter);
			this.reply.addLogicalErrorMess(this, 'NDCHST', wArgIst.toString(), wMessLE);
			// aSegmentNode.setLogicalErrFlag();
		}
	},

	/**
	 * NDCTIT 0E3300 (Adxcpl_setLabel) Mise a jour label d'un objet modelise
	 * Id=[NDCTIT] level=[?] x3func=[Adxcpl_setLabel] nb=[2] ist=[ win=[2]
	 * srn=[0] blc=[0] fld=[0] idx=[0] ] txt =[Utilisateurs]
	 */
	listenNodeNDCTIT: function(_, reader, node, wArgIst, wTitle) {
		this.client.traverseSettable(wArgIst, new CServerTitleSetter(wTitle));
	},

	/**
	 * Dynamisme des combos des menus locaux
	 */
	listenNodeNDDSLB: function(_, reader, node, wArgIst, value) {
		var v = null;
		if (this.sendContext) {
			var currentIst = this.sendContext.ctxNDSLB;
			if (currentIst) {
				v = this.client.findModifiable(currentIst);
				if (v != null && v instanceof CvgVariableCombo) {
					v.setServerDisabledChoice(value);
				}
			}
		}
		if (v == null) {
			console.log("NDDSLB - Variable not found[" + wArgIst.toString() + "]");
		}
	},

	/**
	 * override nedexeci to get the ack_call readed
	 */
	listenNodeNDEXECI: function(_, reader, node) {
		var result = TODO_SUPER.listenNodeNDEXECI(aSegmentNode);
		var ack_call = this.reply.execIstArgs;
		// FDB - ON passe this.client.currentField pour le
		// notiyObservers
		new CvgInstanceExeci(ack_call.xml, this.client, this.client.currentField);
		return result;
	},

	/**
	 * NDGLAR 0E2E00 (LeftList_SelectLine) Selection ligne dans liste simple ou
	 * arbre
	 */
	listenNodeNDGLAR: function(_, reader, node, wArgIst, wCle) {
		var wLeftListLineSelecter = new CLeftListSelecterByKey(true, wCle, this);
		this.client.traverseSettable(wArgIst, wLeftListLineSelecter);
		if (!wLeftListLineSelecter.done) {
			var wMessLE = this.buildListenNodeMessage('ERROR_LLLINE_SELECTER', wCle.toString(), wLeftListLineSelecter);
			this.reply.addLogicalErrorMess(this, 'NDGLAR', wArgIst.toString(), wMessLE);
			// aSegmentNode.setLogicalErrFlag();
		}
	},

	/**
	 * NDINSLI 0E0B00 (Adxcpl_addGridLines) Ajout lignes dans tableau
	 *
	 * Parametres : - sX3Adxid *psAdxidTarget : Identifiant de la cible [in] -
	 * short nStartLine : ligne de depart [in] - short nNbLine : Nombre de
	 * lignes [in]
	 *
	 * Id=[NDINSLI] x3func=[Adxcpl_addGridLines] elems=[hasArg:3] nb=[3] ist =[
	 * win=[2] srn=[4] blc=[1] fld=[0] idx=[0] ] sh1=[1] sh2=[44]
	 * Dump=[.x00.x00.x0C.x0E.x0B.x02.x04.x01.x00.x00.x00.x00.x01.x00.x2C]
	 *
	 * Remarque : A la construction d'une fenetre, un tableau est toujours cree
	 * avec une ligne d'en-tete et une ligne vide.
	 */
	listenNodeNDINSLI: function(_, reader, node, wArgIst, wTargetLine, wNbLines) {
		//console.log("INSLI - Start=" + wTargetLine + " - Nb=" + wNbLines);
		var wDataSrcInserter = new CDataSrcInserter(this.client, wTargetLine, wNbLines);
		this.client.traverseSettable(wArgIst, wDataSrcInserter);
		if (wDataSrcInserter.hasLogicalErrMess()) {
			var wMessLE = this.buildListenNodeMessage('ERROR_INSERTER', String.valueOf(wNbLines), String.valueOf(wTargetLine), wDataSrcInserter);
			this.reply.addLogicalErrorMess(this, 'NDINSLI', wArgIst.toString(), wMessLE);
			// aSegmentNode.setLogicalErrFlag();
		}
	},

	/**
	 * Traitement des noeud NDOBOXI transportant des messages synchrones. Compte
	 * tenu du m�canisme de si le noeud NDOBOXI n'est pas trait� ici, il sera
	 * trait� dans la m�thode "listenNodeNDOBOXI" de la classe "CAdonixRequest"
	 *
	 * NDBOXI 0E0108 (MessageBox_Create)
	 *
	 * Transporte les demandes d'affichage synchrone
	 *
	 * Infbox "$$TEMPOPE" + WMESS Infbox "$$TEMPCLO" Infbox "$$VLC_OPE" +
	 * INTTEXT + "^" + INTNUM Titled TITREWINDOW + "^" + WLIB1 + "^" + WLIB2
	 * Infbox "$$VLC_MOD" + VALEXT + "^" + VALNUM Infbox "$$VLC_CLO" Infbox
	 * "$$PROGOPE" Titled TITREWINDOW Infbox "$$PROGMOD" + WMAX + "^" +
	 * WPROGRESS + "^" + WLIB Infbox "$$PROGCLO"
	 *
	 * simulation de close session Infbox "$$SESSCLO"
	 *
	 * pilotage timeout de la requ�te courante - Timeout d'une heure si
	 * $$DBG_OPE + texte - Timeout standard si $$DBG_CLO + texte
	 */
	listenNodeNDOBOXI: function(_, reader, node, wTypeBox, wChx, wMessText, wMessTitre, wSleep) {

		if (wTypeBox == OU_BIF) {
			var wPos = wMessText.indexOf(Cvg.AFF_SYNCHRONE_HEADER);
			// si le message contient "$$" au debut (pos 0 ou 1) : c'est un
			// message d'affichage asynchone
			if (wPos == 0 || wPos == 1) {
				wMessText.replace('\r', ' ');
				wMessTitre.replace('\r', ' ');
				var wAffSynchroneType = this.getAffSynchroneType(wMessText, wPos);
				var wAffSynchroneAction = this.getAffSynchroneAction(wMessText, wPos);
				// si simulation de timeout session, recup timeout reponse
				// automatique
				if (wAffSynchroneType == Cvg.AFF_SYNCHRONE_TYPE_SESSION) {
					wSleep = this.client.maxTimeBeforeAutomaticHangUp;
				} else if (wAffSynchroneType == Cvg.AFF_SYNCHRONE_TYPE_DEBUGON) {
					if (wAffSynchroneAction == Cvg.AFF_SYNCHRONE_ACTION_CLOSE) {
						wAffSynchroneType = Cvg.AFF_SYNCHRONE_TYPE_DEBUGOFF;
					}
				}
				wMessText = this.removeAffSynchronePrefix(wMessText, wPos);
				// construction et stockage du message Synchone dans le client
				var wMessage = new CvgMessage(wAffSynchroneType, wAffSynchroneAction, wMessText, wMessTitre, -1, wSleep, -1, this.client);
				this.client.pushAffSynchroneMessage(wMessage);
				// memorisation dans la requete qu'il y a eu au moins un message
				// Synchrone et qu'il est peut etre du type DEBBUG
				setFlagsMessagesSynchrones(wMessage.isAffSynchroneDebug());
				// pour que le message "$$DBG_OFF" (type 22) arrive au browser,
				// on le met directement dans le reply !
				if (wAffSynchroneType == Cvg.AFF_SYNCHRONE_TYPE_DEBUGOFF) {
					this.reply.addMessage(wMessage);
				}
				// puisque ndboxi pour un affichage synchrone => reply immediat
				var wDefaultButton = 5;
				listenNodeNDOBOXISendAutoReply(_, wDefaultButton);
				// positionnement du fait que l'on a deja envoye une reponse
				// pouyr ce segment
				aSegmentNode.setAutoReplied();
				return true;
			}
		}

		var wTypeMess = -1;
		var wDefaultButton = -1;

		if (wMessText.length > 0) {
			wMessText.replace('\r', ' ');
		}
		if (wMessTitre.length > 0) {
			wMessTitre.replace('\r', ' ');
		}

		switch (wTypeBox) { /* Boite de Question */
		case OU_BQU:
			{
				wTypeMess = MSG_QUESTION;
				wDefaultButton = 2;
				break;
			} /* Boite d'Avertissement */
		case OU_BAV:
			{
				wTypeMess = MSG_WARNING;
				wDefaultButton = 1;
				break;
			} /* Boite d'Erreur */
		case OU_BER:
			{
				wTypeMess = MSG_ERROR;
				wDefaultButton = 0;
				break;
			} /* Boite d'Information */
		case OU_BIF:
			{
				wTypeMess = MSG_INFORMATION;
				wDefaultButton = 0;
				break;
			} /* Boite STOP */
		case OU_BEN:
			{
				wTypeMess = MSG_STOP;
				wDefaultButton = 0;
				break;
			}

		case OU_BSE:
			/* Boite de Selection ??? */
		default:
			break;
		}

		var self = this;
		// 15w_000 - Fiche 34471 - Ack_call silencieux
		// 15w_016 - Fiche 44356 - Dissociation comportement et adxtyp
		var wReplyAuto = this.silent || (this.reply.orderId === CONNECT_ACTION) && (wTypeMess === MSG_STOP || this.client.isInteractiveSession);
		var wNewMess = this.reply.addMessage(new CvgMessage(wTypeMess, 0, wMessText, wMessTitre, wDefaultButton, wSleep, wChx,this.client));
		/**
		 * @version 141 - réponse automatique à tous les message si
		 *          "SRV_CALLREMOTESPGM" (ACK_CALL) ou open connexion
		 */
		if (wReplyAuto) {
			/*
			 * 14w_006 - Evolution TermServer - indicateur ReplyAuto dans
			 * CAdonixMessage
			 */
			wNewMess.replyAuto = true;

			if (wChx !== 0 && wChx !== wDefaultButton) {
				wDefaultButton = wChx;
			}
			this.listenNodeNDOBOXISendAutoReply(_, wDefaultButton); // bouton par défaut
			// défini par
			// l'utilisateur
			/*
			 * positionnement du fait que l'on a déja envoyé une réponse pouyr
			 * ce segment
			 */
			// TODO TCA
			//aSegmentNode.setAutoReplied();
		}
	},

	listenNodeNDOBOXISendAutoReply: function(_, aNumButton) {
		/*
		 * 15w_002 Fiche 37099 - Protocole: formalisation du segment champ
		 * courant
		 */

		var resu = new CvgResu(CvgResu.TDO_INT, aNumButton);
		try {
			//var wSegReplyAction = CSegmentActionFactory.buildSegmentAction(pTracer, true, wProtocolNum, CvgAction.SRV_CHAMP_SUIVANT, wIstDatas);
			// pCommClient.writeSegment(wSegReplyAction, false);
			this.client.sendAction(_, resu, [], [CvgAction.SRV_CHAMP_SUIVANT]);
		}
		catch (e) {
			this.client.connected = false;
			throw e;
		}
	},

	listenNodeNDSATAN: function(_, reader, node, wArgIst) {
		this.reply.stayInCommandMode = true;
		// fusion - creation de l'instance target avec le bon mode commande
		this.reply.setTargetAdxId(wArgIst);
	},

	listenNodeNDOMENA: function(_, reader, node, wProfil) {
		// si le profil change => on le met dans le reply
		if (this.client.appSrvSessionSettings.usrProfile !== wProfil) this.client.appSrvSessionSettings.usrProfile = wProfil;
	},
	/**
	 * NDOCAR 0E012A (LeftList_NewFormat) Mise a jour Label/Format colonnesListe
	 * simple et arbre
	 */
	listenNodeNDOCAR: function(_, reader, node, wArgIst, wWhat, wDefs) {
		var wModifier = new CLeftListColumnsModifier(wWhat, wDefs);
		this.client.traverseSettable(wArgIst, wModifier);
	},

	/**
	 * NDOFENH 0E0103 (Help_Direct) Demande affichage aide
	 */
	listenNodeNDOFENH: function(_, reader, node, wTxt) {
		this.reply.setAskOpenHelpParam(wTxt);
	},

	/**
	 * 14w_022 - Fiche 34442 - Support du noeud NDOFLD pour l'editeur de formule
	 * Traitemet du noeud specifique d'ajout de definition de champ dans
	 * l'editeur de formule en simulant un noeud NDOLAR pour charge la premiere
	 * liste gauche de 6 colonnes de la fenetre "_FORMULA"
	 *
	 * NDOFLD 0E0128 (de formule) Ajout informations dans les arbres de
	 * l'editeur de Formules
	 * "tsrfld","Lecture des Parametres et Appel a la Fonction"
	 * "ist","nxtist( ist )","ist " "string","nxtstu( st1 )","st1 "
	 * "string","nxtstu( st2 )","st2 " "string","nxtstu( st3 )","st3 "
	 * "short","st0 = nxtint( )","st0" "string","nxtstu( st4 )","st4 "
	 * "string","nxtstu( st5 )","st5 "
	 */
	listenNodeNDOFLD: function(_, reader, node, wArgIst, wTxt1, wTxt2, wTxt3, wInt1, wTxt4, wTxt5, wIst) {
		wIst.setScreenLeftList();
		wIst.setBloc(1);
		wIst.setLine(-1);
		var wLine = new CNodeArgTblResu(6);
		wLine.setResu(0, CvgResu.X3TYP_STRU, wTxt1);
		wLine.setResu(1, CvgResu.X3TYP_STRU, wTxt2);
		wLine.setResu(2, CvgResu.X3TYP_STRU, wTxt3);
		wLine.setResu(3, CvgResu.X3TYP_STRU, String.valueOf(wInt1));
		wLine.setResu(4, CvgResu.X3TYP_STRU, wTxt4);
		wLine.setResu(5, CvgResu.X3TYP_STRU, wTxt5);
		var wClf = new CNodeArgTblResu(0);
		this.client.traverseSettable(wIst, new CLeftListAppender(-1, 0, "", wLine, wClf, null));
	},

	/**
	 * NDOLAR E012B (LeftList_AddLine) Ajout ligne dans liste simple et arbre
	 *
	 * Id=[NDOLAR] level=[?] x3func=[LeftList_AddLine] nb=[7] ist =[ win=[2]
	 * srn=[34] blc=[1] fld=[0] idx=[0]] sh1=[19] sh2=[.x00] txt =[] val, st
	 * =[.x02
	 * ;.x7A;.x05;.x00;.x41;.x00;.x53;.x00;.x4E;.x00;.x55;.x00;.x32;.x00;.x00
	 * ;.x7A
	 * ;.x11;.x00;.x55;.x00;.x74;.x00;.x69;.x00;.x6C;.x00;.x69;.x00;.x73;.x00
	 * ;.x61
	 * ;.x00;.x74;.x00;.x65;.x00;.x75;.x00;.x72;.x00;.x20;.x00;.x41;.x00;.x53
	 * ;.x00;.x4E;.x00;.x20;.x00;.x32;.x00;.x00] clf, st
	 * =[.x01;.x7A;.x05;.x00;.x41
	 * ;.x00;.x53;.x00;.x4E;.x00;.x55;.x00;.x32;.x00;.x00] clp, st =[.x00]
	 *
	 * ist short byte stru resu_tbl_old resu_tbl_old resu_tbl_old
	 */
	listenNodeNDOLAR: function(_, reader, node, wArgIst, wIdx, wBranche, wTxt, wVal, wClf, wClp) {
		this.client.traverseSettable(wArgIst, new CLeftListAppender(wIdx, wBranche, wTxt, wVal, wClf, wClp));
	},

	/**
	 * NDOMNBO 0E0161 (menu_New) Stockage param�tres d'element de menu -
	 * Exemples: Id=[NDOMNBO] idm=[50504] rng=[10] ide=[-985112310] flg=[.x18]
	 * cod=[1119] txt =[Selection avancee] acc=[0] Id=[NDOMNBO] idm=[307]
	 * rng=[50] ide=[50504] flg=[.x10] cod=[1024] txt =[Selection] acc=[0]
	 * Id=[NDOMNBO] level=[W] x3func=[menu_New] NbArgs=[7] idm=[307] rng=[50]
	 * ide=[50501] flg=[.x10] cod=[1024] txt =[S�lection] acc=[0]
	 */
	listenNodeNDOMNBO: function(_, reader, node, wIdm, wRng, wIde, wFlg, wActionId, wTxt, wAcc) {
		this.reply.addMenuWin(wFlg, wActionId, wTxt, wIdm, wRng, wIde, wAcc);
	},

	listenNodeNDOMNAO: function(_, reader, node, wIdm, wRng, wIde, wFlg, wActionId, wTxt, wAcc) {
		this.reply.addMenuWin(wFlg, wActionId, wTxt, wIdm, wRng, wIde, wAcc);
	},

	/**
	 * Id=[NDOUVIMP] x3func=[Impression_ChargeReport] elems=[hasArg:5,hasExtend]
	 * NbArgs=[5] st1=[.x00] st2=[.x00] buf[1] =[] buf[2] =[] buf[3] =[]
	 * NbExtends=[1] nb=[1] len=[18] 0=[ nb=[23] 0=[ id=[__REPORT]
	 * value=[TABCOUNTRY.rpt] length=[23]] 1=[ id=[__DESTINATION] value=[0]
	 * length=[15]] 2=[ id=[__TYPDBA] value=[1] length=[10]] 3=[
	 * id=[__DBDATABASE] value=[DV140] length=[18]] 4=[ id=[__DBUSER]
	 * value=[GX3APP] length=[15]] 5=[ id=[__DBPASSWORD] value=[tiger]
	 * length=[18]] 6=[ id=[__APPLICATION] value=[GX3APP;gaile610;1940]
	 * length=[34]] 7=[ id=[__APPRPT] value=[GX3APP;gaile610;1940] length=[29]]
	 * 8=[ id=[__RPTLAN] value=[null] length=[9]] 9=[ id=[X3DOS]
	 * value=[GX3APP;gaile610;1940] length=[26]] 10=[ id=[__REQUETE]
	 * value=[81595] length=[15]] 11=[ id=[_PreVisuOptions]
	 * value=[11111111111111111111] length=[36]] 12=[ id=[X3CLI] value=[X3]
	 * length=[8]] 13=[ id=[X3EDT] value=[Etat Adonix Copyright Adonix]
	 * length=[34]] 14=[ id=[X3ETA] value=[TABCOUNTRY] length=[16]] 15=[
	 * id=[X3TIT] value=[Pays] length=[10]] 16=[ id=[X3OPE] value=[Olivier
	 * Gattaz ccc] length=[24]] 17=[ id=[X3USR] value=[OG] length=[8]] 18=[
	 * id=[X3LAN] value=[FRA] length=[9]] 19=[ id=[X3SIT1] value=[*] length=[8]]
	 * 20=[ id=[X3SIT2] value=[z] length=[8]] 21=[ id=[paysdeb] value=[ ]
	 * length=[10]] 22=[ id=[paysfin] value=[zzzzzzzzzz] length=[18]] ]
	 */
	listenNodeNDOUVIMP: function(_, reader, node) {
		// Les argument du noeud NDOUVIMP ne sont pas pris en compte
		// recuperation de l'extend properties associee au noeud NDOUVIMP
		// FDB Non utilisé - CNodeExtendProperties wExtendProperties =
		// (CNodeExtendProperties) ((CSegmentNodeExtended)
		// aSegmentNode).getNodeExtend(0);
		// FDB Non utilisé -
		// this.reply.addReport(wExtendProperties.properties);
		var wSegReplyBinShort = new CSegmentReplyBinShort(true, 1);
		try {
			if (this.client.typeClient == ETypeClient.JULIET) {
				this.connClient.writeSegment(wSegReplyBinShort);
			} else {
				this.client.writeSegment(wSegReplyBinShort, false);
			}
		} catch (e) {
			this.client.connected = false;
			throw e;
		}
	},

	/**
	 * NDOWIN 0E0157 (Adxcpl_OpenWin) Ouverture fenetre (Fille - Independante -
	 * Selection - Formule) IN--> Id=[NDOWIN] x3func=[Adxcpl_OpenWin]
	 * elems=[hasArg:4,hasExtend] nb=[4] ist =[ win=[2] srn=[0] blc=[0] fld=[0]
	 * idx=[0]] nmw =[OAUS] nmf =[GESAUS] tsp =[20030617110837] NbExtends=[1]
	 */
	listenNodeNDOWIN: function(_, reader, node, wIst, wWindowsId, wFunctionId, wStamp, wExtendedInfos) {
		// pour ex�cuter le traitement "standard" d'un empoilage de fenetre
		// next line is super.listenNodeNDOWIN(aSegmentNode);
		// do we really need it????
		//this.reply.setLastPushedWindow(new CAdonixWindow(wWindowsId, wFunctionId, wStamp));
		// glute : protection contre les ouvertures de fenetre tempon
		if (wWindowsId == "TEMPON") {
			this.nbNodeOpenTempon++;
			return true;
		}
		// gestion de la compatibilite des prefixes '&' et '_'
		if (wWindowsId.charAt(0) === '&') {
			wWindowsId = CvgWindow.PREFIX_SPECIAL + wWindowsId.substring(1);
		}
		var wStackedWindow = null;
		var reply = this.reply;
		// BRJOU disabled TRY/CATCH
		//try {
		reply.setChangeWindow();
		// construction et stockage du message Synchone "TYPE_NDOWIN" dans
		// le client
		// instancie une CvgStackedWindow : load la description et
		// instancie les structures
		var descr = this.loadWindowDescription(_, wWindowsId);
		wStackedWindow = this.client.pushRequesterWindow(wWindowsId, wFunctionId, descr, wStamp, wIst.win);
		reply.addPushedWindow(wStackedWindow);
		reply.setStamp(wStamp);
		//console.log(JSON.stringify(reply.pusheddWindows[0].toJson(), null, 2));
		//var remain = req.ctx.stream.read(_);
		//console.log("remain=" + remain.toString('hex'));
		wStackedWindow.setNDOWinComplementDescr(wExtendedInfos);
		//} catch (e) {
		//	reply.setStatusNOTOK(e);
		//	reply.setAskCloseSession(true);
		//}
	},

	/**
	 * NDRZAR 0E2D00 (LeftList_DeleteAllLine) Suppression de toute les lignes
	 * dans liste simple ou arbre
	 */
	listenNodeNDRZAR: function(_, reader, node, ist) {
		this.client.traverseSettable(ist, new CLeftListDeleter());
	},

	/**
	 * NDSUPLI 0E0A00 (Adxcpl_delGridLines) Suppression lignes dans tableau
	 */
	listenNodeNDSUPLI: function(_, reader, node, wArgIst, wTargetLine, wNbLines) {
		var wDataSrcDeleter = new CDataSrcDeleter(this.client, wTargetLine, wNbLines);
		this.client.traverseSettable(wArgIst, wDataSrcDeleter);
		if (wDataSrcDeleter.hasLogicalErrMess()) {
			var wMessLE = this.buildListenNodeMessage('ERROR_DELETER', String.valueOf(wNbLines), String.valueOf(wTargetLine), wDataSrcDeleter);
			this.reply.addLogicalErrorMess(this, 'NDSUPLI', wArgIst.toString(), wMessLE);
			// aSegmentNode.setLogicalErrFlag();
		}
	},

	/**
	 * NDULAR 0E3100 (LeftList_DeselectLine) Deselection ligne dans liste simple
	 * ou arbre
	 */
	listenNodeNDULAR: function(_, reader, node, wArgIst, wCle) {
		this.client.traverseSettable(wArgIst, new CLeftListSelecterByKey(false, wCle, this));
	},

	/**
	 * Traite les segment "CSegmentNode" et interromp l'attente si neoud
	 * "isNodeWaitUser". (non-Javadoc)
	 */
	listenSegment: function(aSegment) {
		if (!validSegmentNode(aSegment)) {
			return false;
		}
		var wProcessed = false;
		var wSegmentNode = aSegment;
		var wNodeId = wSegmentNode.nodeId;
		switch (wNodeId) {
		case CvgNode.NDOLAR:
			wProcessed = listenNodeNDOLAR(wSegmentNode);
			break;
		case CvgNode.NDCHVL:
			wProcessed = listenNodeNDCHVL(wSegmentNode);
			break;
		case CvgNode.NDCHVB:
			wProcessed = listenNodeNDCHVB(wSegmentNode);
			break;
		case CvgNode.NDCHFM:
			wProcessed = listenNodeNDCHFM(wSegmentNode);
			break;
		case CvgNode.NDCHGR:
			wProcessed = listenNodeNDCHGR(wSegmentNode);
			break;
		case CvgNode.NDCHCR:
			wProcessed = listenNodeNDCHCR(wSegmentNode);
			break;
		case CvgNode.NDOFLD:
			wProcessed = listenNodeNDOFLD(wSegmentNode);
			break;
		case CvgNode.NDCTIT:
			wProcessed = listenNodeNDCTIT(wSegmentNode);
			break;
		case CvgNode.NDCSTL:
			wProcessed = listenNodeNDCSTL(wSegmentNode);
			break;
		case CvgNode.NDGLAR:
			wProcessed = listenNodeNDGLAR(wSegmentNode);
			break;
		case CvgNode.NDINSLI:
			wProcessed = listenNodeNDINSLI(wSegmentNode);
			break;
		case CvgNode.NDOCAR:
			wProcessed = listenNodeNDOCAR(wSegmentNode);
			break;
		case CvgNode.NDSUPLI:
			wProcessed = listenNodeNDSUPLI(wSegmentNode);
			break;
		case CvgNode.NDAFTB:
			wProcessed = listenNodeNDAFTB(wSegmentNode);
			break;
		case CvgNode.NDRZAR:
			wProcessed = listenNodeNDRZAR(wSegmentNode);
			break;
		case CvgNode.NDULAR:
			wProcessed = listenNodeNDULAR(wSegmentNode);
			break;
		case CvgNode.ND_CLF:
			wProcessed = listenNodeND_CLF(wSegmentNode);
			break;
		case CvgNode.NDDSLB:
			wProcessed = listenNodeNDDSLB(wSegmentNode);
			break;
		case CvgNode.ND_NAP:
			wProcessed = listenNodeND_NAP(wSegmentNode);
			break;
		case CvgNode.NDOMNAO:
		case CvgNode.NDOMNBO:
			wProcessed = listenNodeNDOMNBO(wSegmentNode);
			break;
		case CvgNode.NDOUVIMP:
			wProcessed = listenNodeNDOUVIMP(wSegmentNode);
			break;
		case CvgNode.NDOFENH:
			wProcessed = listenNodeNDOFENH(wSegmentNode);
			break;
		case CvgNode.ND_ASK:
			// AskUI_Call]
			wProcessed = listenNodeND_ASK(wSegmentNode);
			break;
		default:
		}
		if (wProcessed) {
			this.receivedSegments.add(wSegmentNode);
			// noeud pour rendre la main a l'utilisateur => traitement du noeud
			// complet et fin d'attente
			if (wSegmentNode.isNodeWaitUser()) {
				if (this.adonixClient.typeClient == ETypeClient.JULIET) {
					breakWaiting(true);
				}
			}
			return wProcessed;
		} else {
			return TODO_SUPER.listenSegment(aSegment);
		}
	},
	listenSendingArgs: function(aRequestId, aCommClient, aParams) {
		switch (aRequestId) {
		case CvgAction.SRV_BRWCHANGELINE:
		case CvgAction.SRV_BRWSELECTLINE:
		case CvgAction.SRV_TREECHANGELINE:
		case CvgAction.SRV_TREEEXPANDLINE:
		case CvgAction.SRV_TREESELECTLINE:
			return this.listenActionArgsDOLEFTLISTLINE(aCommClient, aParams);
		case CvgAction.SRV_BRWRAPIDESEL:
			return this.listenActionArgsBRWRAPIDESEL(aCommClient, aParams);
		case CvgAction.SRV_LIST_PAGE_DOWN:
			return this.listenActionArgsLIST_PAGE_DOWN(aCommClient, aParams);
		case CvgAction.SRV_LIST_PAGE_UP:
			return this.listenActionArgsLIST_PAGE_UP(aCommClient, aParams);
		case CvgAction.SRV_PICKING:
			return this.listenActionArgsPICKING(aCommClient, aParams);
		default:
			break;
		}
	},
	removeAffSynchronePrefix: function(aMess, aPos) {
		var wPosStart = aPos + Cvg.AFF_SYNCHRONE_PREFIX_LONG;
		if (wPosStart < aMess.length() - 1) {
			return aMess.substring(wPosStart);
		} else {
			return "";
		}
	},
	retrieveLeftList: function(aClient, aParams) {
		return aClient.findModifiable(new CvgIst(aParams[1]));
	},
	setLefListLineSelected: function(lefListLineSelected) {
		this.lefListLineSelected = lefListLineSelected;
	},
	setTargetAdxId: function(ist) {
		if (this.reply /*instanceof CvgReply*/ ) {
			this.reply.setTargetAdxId(ist, this);
		} else {
			var reply = new CvgReply(this.client, this);
			reply.setOk(this.reply.status);
			reply.setValue(this.reply.binValue);
			reply.setTargetAdxId(ist, this);
		}
	}
});