"use strict";
var helpers = require('@sage/syracuse-core').helpers;
var CvgPluginTarget = require('../../model/CvgPluginTarget').CvgPluginTarget;
var x3writer = require('../../automata/x3writer');
var flows = require('streamline-runtime').flows;
var CvgObserver = require('../CvgObserver').CvgObserver;
var CvgSpecialAction = require('../CvgAction').SpecialActions;
var automata = require('../../automata/x3Automata');
var CvgServices = require('../CvgPluginServices');
var CvgResu = require('../../types/CvgResu').TDO;
var CvgResuTdo = require('../../types/CvgResu').CvgResu;
var CvgActions = require('../CvgAction').Actions;
var CvgIst = require('../../types/CvgIst').CvgIst;
var CvgPlugin = require('./CvgPlugin').CvgPlugin;
var NAME_GANT = "gantt";
var NAME_SCALE = "scale";
var tracerAction = require("syracuse-trace/lib/helper").getTracer("classic.action");


//

exports.CvgPluginILog = helpers.defineClass(function(client, id, killTimeoutOnCreate) {
	CvgPlugin.call(this, client, id);
	this.automata = client.automata;
	this.replyClient = null;
	this.replyRegister = null;
	this.killTimeout = killTimeoutOnCreate;
	this.noTimeoutApply = false;

	this.download = null;
	this.upload = null;


}, CvgPlugin, {
	razModification: function() {
		CvgPlugin.prototype.razModification.call(this);
		this.download = null;
		this.upload = null;

	},

	processRequest: function(_, context, bodyStr, tracker) {
		this.client.orchestraTracker = this.client; // put in place the orchestration for ilog
		return CvgPlugin.prototype.processRequest.call(this, _, context, bodyStr, tracker);
	},
	addDownload: function(values) {
		this.download = this.download || [];
		this.download.push(values);
		this.getPluginTarget().forceChange();
	},
	addUpload: function(_, paramVal) {
		this.upload = paramVal && paramVal.length > 0 ? paramVal[1].value : null;

		// stop tracker we wait for ack_resi
		this.getPluginTarget().forceChange();
		this.stopTracker && this.stopTracker(_, this.context, this); // if ochrestraTracker is empty we stop the tracker of the plugin
	},



	toJSON: function() {
		var res = CvgPlugin.prototype.toJSON.call(this);


		if (res.plugin.method !== "new") {
			//add cookie session
			delete res.plugin.cookieSess;
			res.plugin.id = this.id;

		}
		return res;
	},
	toJSONPlugin: function() {
		var res = this.toJSON();

		if (this.download) {
			res.plugin.download = this.download;
		}
		if (this.upload) {
			res.plugin.upload = this.upload;
		}

		return res;
	},
	specialAction523: function(_, context, body, tracker) {
		// clear timeout beacuse we get register notif from the client
		clearTimeout(this.timeout);

		if (body.$diagnoses && body.$diagnoses.length) {
			// there error must client and x3 server
			this.sendIlogErrorToX3(_, this.client, body.$diagnoses[0].$message, body.$diagnoses[0].$severity);
		} else {
			this.replyRegister = body && body.param && body.param.plugin && body.param.plugin.return && body.param.plugin.return.property;
			this._writeRegisterILOGReply(_);
		}

		this.stopTracker && this.stopTracker(_, context, this.client.orchestraTracker); // if ochrestraTracker is empty we stop the tracker of the plugin

		return false;
	},
	specialAction525: function(_, context, body, tracker) {
		this.razModification();
		// clean plugin to out of orchestration mode
		this.stopTracker && this.stopTracker(_, context, this); // send 200 to the plugin
		this.writeAckReply(_, body && body.param && body.param.plugin);

		// create a delete to inform client tat the plugin is dead
		this.method = "Delete";
		this.methodid = 3;
		if (this.name !== NAME_GANT) {
			this.methodid = 8;
		}
		var target = CvgPluginTarget.create(this.client, this);
		// launch process node for the getting the next
		this.stopTracker && this.stopTracker(_, context, this.client); // stop tracker of the client and target plugin
		// delete plugin hear tomporary beacuse we never receive 527 because we don't generate the delete target
		//this.client.cvgPlugin = {};
		return;
	},
	specialAction522: function(_, context, body, tracker) {

		this.clientReplyPlugin(_, context, body);
		this.client.orchestraTracker = null; // no stop of tracker client and plugin - need polling

	},

	specialAction524: function(_, context, body, tracker) {
		this.razModification();

		this.writeAckReply(_, body && body.param && body.param.plugin);

		// reprocess automata for the client
		this.automata.process(_, this.client, this.client.activeRequest, {
			title: "special",
			detail: "PLUGIN_ACK"
		});
		// call the right stop tracker
		this.stopTracker && this.stopTracker(_, context, this.client.orchestraTracker);
		return body.param.plugin.method === "delete";
	},
	// instanciate plugin controler from the cvgClient
	call: function(_, nodeName, property) {

		this.hasModification = true; // some change to send
		var fcContext = this["_readPlugin" + nodeName];

		fcContext && fcContext.apply_(_, this, [property], 0); // construct context depending the plugin to call

		var fc = this["_processPlugin" + this.class + this.method]; //  method of plugin to plugin
		fc.apply_(_, this, 0);

	},
	clientReplyPlugin: function(_, context, body) { //TOOD  must improve to validate what kind of reply
		// get reply ilog and not write it until we have the confirmation from teh plugin controler

		this.replyClient = body && body.param && body.param.plugin && body.param.plugin.return && body.param.plugin.return.property;;
		this._writeRegisterILOGReply(_, context);
	},

	createDeleteTargetPlugin: function(_) {
		// create a delete to inform client that the plugin is dead
		this.method = "Delete";
		this.methodid = 3;
		if (this.name !== NAME_GANT) {
			this.methodid = 8;
		}
		var target = CvgPluginTarget.create(this.client, this);
	},

	_writeRegisterILOGReply: function(_, context) {
		// compare reply Register and reply client

		if (this.noTimeoutApply) { // just stop tracker to notify client
			console.log("timeout done - no register ");
		} else if (this.replyClient && this.replyRegister) {

			var prop = {};
			var reply = this.replyClient;
			if (this.replyRegister.name !== this.replyClient.name) {
				reply = this.replyRegister;
			}
			prop[reply.name] = reply.value;
			this.client.serialize(_, prop);
			this.automata.process(_, this.client, this.client.activeRequest, {
				title: "special",
				detail: "REGISTER"
			});
		}
	},


	_processPluginILOGNew: function(_) {
		// set Timeout to send automatic response to don't be blocked
		var self = this;
		self.noTimeoutApply = false; // we don't get the plugin notif in time

		this.timeout = flows.setTimeout(function(_) {
			// all is not ok in time
			self.orchestraTracker = self.client;
			self.client.orchestraTracker = self.client;
			//self.createDeleteTargetPlugin(_);

			console.log('timeout expired ' + require("util").inspect(self.timeout));
			tracerAction.debug && tracerAction.debug("register timeout expired ");
			self.noTimeoutApply = true; // we don't get the plugin notif in time
			self.sendIlogErrorToX3(_, self.client, self.context, "timeout expired", "-1"); // send error to the runtime
			// process to get the next response
			self.client.cvgPlugin.ND_IHM = {};
			automata.process(_, self.client, self.client.activeRequest, {
				title: "special",
				detail: "ERRORREGISTER"
			});
			self._trackLists = this.newTrackLists();
		}, this.killTimeout);
		CvgPluginTarget.create(this.client, this); // notify only classic page client

	},
	_processPluginILOGUpdate: function(_) {
		this.getPluginTarget().forceChange(); // notify only plugin client
	},
	_processPluginILOGDelete: function(_) {
		this.getPluginTarget().forceChange(); // notify plugin client
		CvgPluginTarget.create(this.client, this); // notify classic page client
	},

	sendIlogErrorToX3: function(_, client, errorMess, errorCode) {
		// construct and send error reply property expected by
		var instanceId = this.method === "New" ? 0 : this.id;
		client.serialize(_, {
			"990": "N" + String.fromCharCode(1) + "X" + errorMess.length + "X" + errorCode.length + "F" + String.fromCharCode(instanceId) + errorMess + errorCode
		});
	},

	_readPluginND_OCX: function(_, property) {
		return null;
	},
	_readPluginND_IHM: function(_, property) {
		var name, method;
		switch (property.IAction) {
			case '1':
				name = NAME_GANT;
				method = "New";
				break;
			case '2':
				name = NAME_GANT;
				method = "Update";
				break;
			case '3':
				name = NAME_GANT;
				method = "Delete";
				break;
			case '6':
				name = NAME_SCALE;
				method = "New";
				break;
			case '7':
				name = NAME_SCALE;
				method = "Update";
				break;
			case '8':
				name = NAME_SCALE;
				method = "Delete";
				break;
		}
		this.name = name,
			this.method = method,
			this.id = property.INumber || this.id,
			this.module = property.IModule,
			this.class = "ILOG",
			this.methodid = parseInt(property.IAction, 10);

	},
	processUpload: function(_, context, blob, tracker) {
		// initialize mandatory for stop tracker ending node
		this.razModification();

		this.client.orchestraTracker = this.client; // by default it the client that have a tracker to stop
		this.context = context;
		this.currentTracker = tracker; // set current tracker

		var body = {
			act: this.client.x3writer.descriptors.actions.SRV_EXECI_RESPONSE,
			fld: {
				ist: new CvgIst("A,@,@")
			},
			param: {
				target: {
					type: "ist",
					ist: new CvgIst("A,@,@")
				},
				reply: {
					json: {
						result: {
							errl: 0,
							errn: 0,
							errt: 0,
							errp: "",
							errm: "",
						},
						debugInfos: {
							exceptiondetail: "",
							totalduration: 0,
							execduration: 0,
							trace: ""
						},
						"return": {
							typ: "INT",
							resu: blob ? context.request.headers["content-length"] : 0
						},
						params: [{
							typ: "BLOB",
							num: 0,
							poste: 0,
							resu: blob ? blob : ""
						}]
					}
				}
			}
		};

		this.client.processAsyncAction(_, body, false, true, true);


		this.stopTracker && this.stopTracker(_, context, this.client.orchestraTracker);
	},


}); // Dummy comment to clean up rollout repository #6948