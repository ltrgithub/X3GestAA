"use strict";
var helpers = require('syracuse-core/lib/helpers');
var x3helpers = require("syracuse-x3/lib/helpers");
var CvgException = require('syracuse-x3/lib/convergence/model/CvgException').CvgException;
var fs = require('fs');

/*
  abstract class
 */
exports.CvgBlobSvc = helpers.defineClass(function(_, client) {
	this.client = client;
	this.blobs = {};
}, null, {
	doGet: function(_, context) {
		return 501; // not implemented
	},
	doPost: function(_, context) {
		return 501; // not implemented
	},
	doPut: function(_, context) {
		return 501; // not implemented
	},
	doDelete: function(_, context) {
		return 501; // not implemented
	},
	processRequest: function(_, context, bodyStr) {
		var error = null;
		var header = {};
		var data = {}, dataType = 'utf8';
		var statusCode, type, len, binary, blob;
		try {
			var meth = context.method;
			var fn = this["do" + meth.charAt(0).toUpperCase() + meth.slice(1)];
			if (fn) {
				var res = fn.apply_(_, this, [context], 0);
				statusCode = res.statusCode;
				dataType = res.dataType || dataType;
				header = res.header || header;

			} else {
				throw new Error("bad method: " + context.method);

			}
		} catch (e) {
			error = new CvgException(this.client, e, "Blob service error");
			header["content-type"] = 'application/json';
			statusCode = 500;
			data.$diagnoses = [];
			data.$diagnoses.push(JSON.parse(JSON.stringify(error.diagnose)));
			data = JSON.stringify(data);
		}

		//console.log("blobs: "+JSON.stringify(this.blobs,null,2));
		context.response.writeHead(statusCode, header);
		context.response.write(_, data, dataType);
		context.response.end();
	},
	// if type = 'image' -> control data mime type as gif | jpeg | bmp | png | tif
	calcMimeType: function(bin, type) {
		var mimeType = "application/octet-stream";
		if (this.isBlobImgGif(bin)) {
			mimeType = "image/gif";
		} else if (this.isBlobImgJpg(bin)) {
			mimeType = "image/jpeg";
		} else if (this.isBlobImgBMP(bin)) {
			mimeType = "image/bmp";
		} else if (this.isBlobImgPng(bin)) {
			mimeType = "image/png";
		} else if (this.isBlobImgTiff(bin)) {
			mimeType = "image/tiff";
		} else if (type && type.indexOf('image') === 0) {
			throw new Error("Data mime type does not match any authorized image type.");
		}
		return mimeType;
	},

	/**
	 * BMP File contains 0x42 0x4d ("BM") in the first two bytes of the file header
	 *
	 * For more information see:
	 * http://en.wikipedia.org/wiki/.BMP
	 *
	 * @param bin
	 * @return
	 */
	isBlobImgBMP: function(bin) {
		return bin[0] === 0x42 && bin[1] === 0x4d;
	},

	/**
	 * GIF Files are identified by the first three characters containing
	 * 0x47 0x49 0x46 - ("GIF") the following 3 characters "87a" or "89a"
	 *
	 * For more information see:
	 * http://en.wikipedia.org/wiki/.GIF
	 *
	 * @param bin
	 * @return
	 */
	isBlobImgGif: function(bin) {
		return bin[0] === 0x47 && bin[1] === 0x49 && bin[2] === 0x46;
	},

	/**
	 *
	 * JPEG SOI (Start of Image) marker : 0xFF 0xD8
	 *
	 * For more information see:
	 * http://en.wikipedia.org/wiki/.JPEG
	 *
	 * @param bin
	 * @return
	 */
	isBlobImgJpg: function(bin) {
		return bin[0] === 0xff && bin[1] === 0xd8;
	},

	/**
	 *
	 * PNG file signature The first eight bytes of a PNG file always contain the
	 * following (hex) 0x89 0x50 0x4e 0x47 0x0d 0x0a 0x1a 0x0a
	 * (ASCII C notation) \211 P N G \r \n \032 \n
	 *
	 * For more information see:
	 * http://en.wikipedia.org/wiki/.PNG
	 *
	 * @param bin
	 * @return
	 */
	isBlobImgPng: function(bin) {
		return bin[0] === 137 && bin[1] === 80 && bin[2] === 78 && bin[3] === 71 && bin[4] === 13 && bin[5] === 10 && bin[6] === 26 && bin[7] === 10;
	},

	/**
	 * TIFF files all begin with a two byte indicator of the byte order
	 * "II" (0x49 0x49) for little-endian (i.e. Intel) or "MM" (0x4D 0x4D) for
	 * big-endian (i.e. Motorola)
	 *
	 * For more information see:
	 * http://en.wikipedia.org/wiki/TIFF
	 *
	 * @param bin
	 * @return
	 */
	isBlobImgTiff: function(bin) {
		return (bin[0] === 0x4D && bin[1] === 0x4D) || (bin[0] === 0x49 && bin[1] === 0x49);
	}
});