"use strict";
var helpers = require('syracuse-core').helpers;
var x3helpers = require("syracuse-x3/lib/helpers");
var CvgException = require('syracuse-x3/lib/convergence/model/CvgException').CvgException;
var fs = require('fs');

exports.CvgBlobSvc = helpers.defineClass(function(client) {}, null, {




	processRequest: function(_, context, bodyStr, tracker) {
		var res = {
			header: {}
		};
		var error = null,
			data = {};
		try {
			var id = context.parameters.id;
			var method = context.method;

			var fn = this["do" + method.charAt(0).toUpperCase() + method.slice(1)];

			if (fn) {
				res = fn.apply_(_, this, [context, tracker], 0);
			} else {
				throw new Error("bad method: " + context.method);
			}

		} catch (e) {
			console.log(e.stack);
			error = new CvgException(this.client, e, "Blob service error");
			res.header["content-type"] = 'application/json';
			res.statusCode = 500;
			data.$diagnoses = [];
			data.$diagnoses.push(JSON.parse(JSON.stringify(error.diagnose)));
			res.data = JSON.stringify(data);
		}

		//console.log("blobs: "+JSON.stringify(this.blobs,null,2));
		//console.log("res "+JSON.stringify(res));
		if (!tracker) {
			context.response.writeHead(res.statusCode, res.header || {});
			context.response.end(res.data, res.dataType || "utf8");
		}

	},
	// if type = 'image' -> control data mime type as gif | jpeg | bmp | png | tif
	calcMimeType: function(bin, type) {
		var mimeType = "application/octet-stream";
		if (this.isBlobImgGif(bin)) {
			mimeType = "image/gif";
		} else if (this.isBlobImgJpg(bin)) {
			mimeType = "image/jpeg";
		} else if (this.isBlobImgBMP(bin)) {
			mimeType = "image/bmp";
		} else if (this.isBlobImgPng(bin)) {
			mimeType = "image/png";
		} else if (this.isBlobImgTiff(bin)) {
			mimeType = "image/tiff";
		} else if (type && type.indexOf('image') === 0) {
			throw new Error("Data mime type does not match any authorized image type.");
		}
		return mimeType;
	},

	/**
	 * BMP File contains 0x42 0x4d ("BM") in the first two bytes of the file header
	 *
	 * For more information see:
	 * http://en.wikipedia.org/wiki/.BMP
	 *
	 * @param bin
	 * @return
	 */
	isBlobImgBMP: function(bin) {
		return bin[0] === 0x42 && bin[1] === 0x4d;
	},

	/**
	 * GIF Files are identified by the first three characters containing
	 * 0x47 0x49 0x46 - ("GIF") the following 3 characters "87a" or "89a"
	 *
	 * For more information see:
	 * http://en.wikipedia.org/wiki/.GIF
	 *
	 * @param bin
	 * @return
	 */
	isBlobImgGif: function(bin) {
		return bin[0] === 0x47 && bin[1] === 0x49 && bin[2] === 0x46;
	},

	/**
	 *
	 * JPEG SOI (Start of Image) marker : 0xFF 0xD8
	 *
	 * For more information see:
	 * http://en.wikipedia.org/wiki/.JPEG
	 *
	 * @param bin
	 * @return
	 */
	isBlobImgJpg: function(bin) {
		return bin[0] === 0xff && bin[1] === 0xd8;
	},

	/**
	 *
	 * PNG file signature The first eight bytes of a PNG file always contain the
	 * following (hex) 0x89 0x50 0x4e 0x47 0x0d 0x0a 0x1a 0x0a
	 * (ASCII C notation) \211 P N G \r \n \032 \n
	 *
	 * For more information see:
	 * http://en.wikipedia.org/wiki/.PNG
	 *
	 * @param bin
	 * @return
	 */
	isBlobImgPng: function(bin) {
		return bin[0] === 137 && bin[1] === 80 && bin[2] === 78 && bin[3] === 71 && bin[4] === 13 && bin[5] === 10 && bin[6] === 26 && bin[7] === 10;
	},

	/**
	 * TIFF files all begin with a two byte indicator of the byte order
	 * "II" (0x49 0x49) for little-endian (i.e. Intel) or "MM" (0x4D 0x4D) for
	 * big-endian (i.e. Motorola)
	 *
	 * For more information see:
	 * http://en.wikipedia.org/wiki/TIFF
	 *
	 * @param bin
	 * @return
	 */
	isBlobImgTiff: function(bin) {
		return (bin[0] === 0x4D && bin[1] === 0x4D) || (bin[0] === 0x49 && bin[1] === 0x49);
	}
}); // Dummy comment to clean up rollout repository #6948