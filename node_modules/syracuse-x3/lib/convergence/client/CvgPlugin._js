"use strict";
var helpers = require('syracuse-core/lib/helpers');
var CvgPluginTarget = require('syracuse-x3/lib/convergence/model/CvgPluginTarget').CvgPluginTarget;
var x3writer = require("syracuse-x3/lib/convergence/automata/x3writer");
var flows = require("streamline/lib/util/flows");
var CvgObserver = require("syracuse-x3/lib/convergence/client/CvgObserver").CvgObserver;
var CvgSpecialAction = require('syracuse-x3/lib/convergence/client/CvgAction').SpecialActions;
var automata = require("syracuse-x3/lib/convergence/automata/x3Automata");
var CvgServices = require('syracuse-x3/lib/convergence/client/CvgPluginServices');
var CvgResu = require("syracuse-x3/lib/convergence/types/CvgResu").TDO;
var CvgResuTdo = require("syracuse-x3/lib/convergence/types/CvgResu").CvgResu;
var CvgActions = require('syracuse-x3/lib/convergence/client/CvgAction').Actions;
var CvgIst = require('syracuse-x3/lib/convergence/types/CvgIst').CvgIst;

var NAME_GANT = "gantt";
var NAME_SCALE = "scale";


//

exports.CvgPlugin = helpers.defineClass(function(_, client, killTimeoutOnCreate) {
	CvgObserver.call(this);

	this.client = client;
	this._cvgSession = client._cvgSession;
	this.killTimeout = killTimeoutOnCreate;
	this.replyClient = null;
	this.replyRegister = null;
	this.isPlugin = true;
	this.noTimeoutApply = false;
	this.context = null;


	this.download = null;
	this.upload = null;
	this.services = CvgServices.create(this);

	this._trackLists = this.newTrackLists();
	this.response = {
		head: {
			statusCode: 200
		},
		body: {}
	};

}, CvgObserver, {
	razModification: function() {
		this.response = {
			head: {
				statusCode: 200
			},
			body: {}
		};
		this._trackLists = this.newTrackLists();
		this.target && this.target.razModification();
		this.download = null;
		this.upload = null;

	},

	getPluginTarget: function() {
		if (!this.target) {
			this.target = CvgPluginTarget.create(this, this);
		}
		return this.target;
	},

	addDownload: function(values) {
		this.download = this.download || [];
		this.download.push(values);
		this.getPluginTarget().forceChange();
	},
	addUpload: function(_, paramVal) {
		this.upload = paramVal && paramVal.length > 0 ? paramVal[1].value : null;

		// stop tracker we wait for ack_resi
		this.getPluginTarget().forceChange();
		this.stopTracker && this.stopTracker(_, this.context, this); // if ochrestraTracker is empty we stop the tracker of the plugin
	},
	// process request sent by the ilog client, return true if acknowledgement of delete  else false
	processRequest: function(_, context, bodyStr, tracker) {
		this.currentTracker = tracker; // set current tracker
		this.client.orchestraTracker = this.client; // by default it the client that have a tracker to stop
		this.context = context;
		var body = JSON.parse(bodyStr);
		var specialAction = CvgSpecialAction[body.act];
		if (!specialAction) {
			throw new Error("Bad special action [" + body.act + "]");
		}
		if (specialAction.id !== "REGISTER") {
			this.razModification();
		}
		switch (specialAction.id) {
			case "REGISTER": // notif that the plugin ilog client is launched and operational
				// clear timeout beacuse we get register notif from the client

				clearTimeout(this.timeout);
				if (body.$diagnose && body.$diagnoses.length) {
					// there error must client and x3 server
					this.sendIlogErrorToX3(_, this.client, opt, body.$diagnoses[0].$message, body.$diagnoses[0].$severity);
				} else {
					this.replyRegister = body && body.param && body.param.plugin && body.param.plugin.return &&body.param.plugin.return .property;
					this._writeRegisterIlogReply(_);
				}
				automata.process(_, this.client, this.client.activeRequest, {
					title: "special",
					detail: "REGISTER"
				});
				this.stopTracker && this.stopTracker(_, context, this.client.orchestraTracker); // if ochrestraTracker is empty we stop the tracker of the plugin

				return false;
				break;
			case "DELETE":
				this._writeAckIlogReply(_, body && body.param && body.param.plugin);
				// clean plugin to out of orchestration mode
				this.client.cvgPlugin = {};
				this.stopTracker && this.stopTracker(_, context, this); // must send 200 as a response for the current request
				// launch process node for the getting the next
				automata.process(_, this.client, this.client.activeRequest, {
					title: "special",
					detail: "PLUGIN_ACK"
				});

				this.stopTracker && this.stopTracker(_, context, this.client.orchestraTracker); // stop tracker of the client
				break;
			case "PLUGIN_ACK":
				this._writeAckIlogReply(_, body && body.param && body.param.plugin);

				// reprocess automata for the client
				automata.process(_, this.client, this.client.activeRequest, {
					title: "special",
					detail: "PLUGIN_ACK"
				});
				// call the right stop tracker
				this.stopTracker && this.stopTracker(_, context, this.client.orchestraTracker);
				return body.param.plugin.method === "delete";
				break;

			default:
				throw new Error("action unknown -  can't process " + specialAction.id);
		}

	},

	// instanciate plugin controler from the cvgClient
	call: function(_, nodeName, property) {

		this.hasModification = true; // some change to send
		var fcContext = this["_readPlugin" + nodeName];

		fcContext && fcContext.apply_(_, this, [property], 0); // construct context depending the plugin to call

		var fc = this["_processPlugin" + this.class + this.method]; //  method of plugin to plugin
		fc.apply_(_, this, 0);

	},
	_clientReplyPlugin: function(_, body) { //TOOD  must improve to validate what kind of reply
		// get reply ilog and not write it until we have the confirmation from teh plugin controler

		this.replyClient = body && body.param && body.param.plugin && body.param.plugin.return &&body.param.plugin.return .property;;
		this._writeRegisterIlogReply(_);
	},


	_writeRegisterIlogReply: function(_) {
		// compare reply Register and reply client
		if (this.replyClient && this.replyRegister && !this.noTimeoutApply) {
			var prop = {};
			var reply = this.replyClient;
			if (this.replyRegister.name !== this.replyClient.name) {
				reply = this.replyRegister;
			}
			prop[reply.name] = reply.value;
			x3writer.props1Serializer.write(_, this.client, prop);
		}
	},
	_writeAckIlogReply: function(_, plugin) {
		if (plugin && plugin.return &&plugin.return .property) {
			var prop = {};
			prop[plugin.return .property.name] = plugin.return .property.value;
			x3writer.props1Serializer.write(_, this.client, prop);
		}
	},

	_processPluginIlogNew: function(_) {
		// set Timeout to send automatic response to don't be blocked
		var self = this;
		self.noTimeoutApply = false; // we don't get the plugin notif in time

		this.timeout = flows.setTimeout(function(_) {
			// all is not ok in time
			//console.log('timeout expired ' + require("util").inspect(self.timeout));
			self.noTimeoutApply = true; // we don't get the plugin notif in time
			self.sendIlogErrorToX3(_, self.client, self.context, "timeout expired", "-1"); // send error to the runtime
		}, this.killTimeout);
		CvgPluginTarget.create(this.client, this); // notify only classic page client

	},
	_processPluginIlogUpdate: function(_) {
		this.getPluginTarget().forceChange(); // notify only plugin client
	},
	_processPluginIlogDelete: function(_) {
		this.getPluginTarget().forceChange(); // notify plugin client
		CvgPluginTarget.create(this.client, this); // notify classic page client
	},

	sendIlogErrorToX3: function(_, client, context, errorMess, errorCode) {
		// construct and send error reply property expected by
		var instanceId = this.method === "New" ? 0 : this.id;
		x3writer.props1Serializer.write(_, client, {
			"990": "N" + String.fromCharCode(1) + "X" + errorMess.length + "X" + errorCode.length + "F" + String.fromCharCode(instanceId) + errorMess + errorCode
		});
	},

	_readPluginND_OCX: function(_, property) {
		return null;
	},
	_readPluginND_IHM: function(_, property) {
		var name, method;
		switch (property.IAction) {
			case '1':
				name = NAME_GANT;
				method = "New";
				break;
			case '2':
				name = NAME_GANT;
				method = "Update";
				break;
			case '3':
				name = NAME_GANT;
				method = "Delete";
				break;
			case '6':
				name = NAME_SCALE;
				method = "New";
				break;
			case '7':
				name = NAME_SCALE;
				method = "Update";
				break;
			case '8':
				name = NAME_SCALE;
				method = "Delete";
				break;
		}
		this.name = name,
		this.method = method,
		this.id = property.INumber || null,
		this.type = "asynchronous",
		this.module = property.IModule,
		this.class = "Ilog",
		this.methodid = parseInt(property.IAction, 10);

	},
	sendUpload: function(_, context, blob) {
		var body = {
			act: CvgActions.SRV_EXECI_RESPONSE,
			fld: {
				ist: new CvgIst("A,@,@")
			},
			param: {
				target: {
					type: "ist",
					ist: new CvgIst("A,@,@")
				},
				reply: {
					json: {
						result: {
							errp: 0,
							errm: "",
							errn: 0,
							errt: "",
							errl: ""
						},
						"return": {
							type: 3,
							value: context.request.headers["content-length"] || 0
						},
						params: [{
							type: 9,
							value: blob
						}, {
							type: 7,
							value: this.upload
						}]
					}
				}
			}
		};
		this.client.processAsyncAction(_, body, false, true, true);
		automata.process(_, this.client, this.client.activeRequest, {
			title: "special",
			detail: "PLUGIN_UPLOAD"
		});
		// call the right stop tracker

		this.stopTracker && this.stopTracker(_, context, this.client.orchestraTracker);
	},

	getTarget: function() {
		var lists = this._trackLists;
		return JSON.parse(JSON.stringify(lists.TARGET[lists.TARGET.length - 1]));
	},
	generateResponse: function(_, connect, isTrack) {

		var lists = this._trackLists;
		var response = {
			sap: {}
		};
		var sap = response.sap;
		if (lists.TARGET.length !== 0) {
			var target = this.getTarget();
			if (!isTrack) {
				sap.target = target;
			} else if (sap.target) {
				delete sap.target;
			}
		}

		// serialized NDEXECI
		this.response.body = response;

	}
});