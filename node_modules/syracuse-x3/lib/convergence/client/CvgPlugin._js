"use strict";
var helpers = require('syracuse-core/lib/helpers');
var CvgPluginTarget = require('syracuse-x3/lib/convergence/model/CvgPluginTarget').CvgPluginTarget;
var x3writer = require("syracuse-x3/lib/convergence/automata/x3writer");
var flows = require("streamline/lib/util/flows");
var PluginController = require("syracuse-x3/test/fixtures/pluginILogControler").PluginController;

var NAME_GANT = "gantt";
var NAME_SCALE = "scale";


//

exports.CvgPlugin = helpers.defineClass(function(_, client, killTimeoutOnCreate) {
	this.pluginControler;
	this.client = client;
	this.killTimeout = killTimeoutOnCreate;
	this.newNotif;
	this.newReply;
}, null, {

	call: function(_, nodeName, property) {
		// TODO
		var fcContext = this["_readPlugin" + nodeName];

		var ilog = fcContext && fcContext.apply_(_, this, [property], 0); // construct context depending the plugin to call
		if (!ilog)
			throw new Error("Can't read context to call plugin (node " + nodeName + ")");

		var fc = this["callPlugin" + ilog.class + ilog.method]; //  method of plugin to plugin
		fc.apply_(_, this, [ilog], 0);
		if (ilog.method !== "Update") { // if not update serialize to the classic page client
			CvgPluginTarget.create(this.client, ilog);
			// response expected from the client to serialize ND_IHM response
		}
		return ilog;
	},
	replyIlog: function(_, property) {
		// get reply ilog and not write it until we have the confirmation from teh plugin controler
		this.newReply = property;
		this._writeNewIlogReply(_);
	},

	_writeNewIlogReply: function(_) {
		this.newNotif && this.newReply && x3writer.props1Serializer.write(_, this.client, this.newReply);
	},

	callPluginIlogNew: function(_, opt) {
		// set Timeout to send automatic response to don't be blocked
		var self = this;
		opt.timeout = flows.setTimeout(function(_) {
			// all is not ok in time
			ilog.method = "Delete";
			self.sendIlogErrorToX3(_, ilog, "timeout expired", "-1"); // send error to the runtime
		}, this.killTimeout);

		// call ilog new and wait for notification
		this.pluginControler = new PluginController(_);
		this.pluginControler.callNew(_, opt, function(_, res) {
			- // clear timeout beacuse we get response
			clearTimeout(opt.timeout);
			if (res.$diagnose && res.$diagnoses.length) {
				// there error must client and x3 server
				self.sendIlogErrorToX3(_, opt, res.$diagnoses[0].$message, res.$diagnoses[0].$severity);
			} else {
				self.newNotif = true;
				self._writeNewIlogReply(_);
			}

		});

	},

	callPluginIlogUpdate: function(_, opt) {
		// notify plugin controler
		if (this.pluginControler) {
			var res = this.pluginControler.callUpdate(_, opt);
			// send response to X3
			x3writer.props1Serializer.write(_, this.client, res);
		}

	},

	sendIlogErrorToX3: function(_, ilog, errorMess, errorCode) {
		// construct and send error reply property expected by
		var instanceId = ilog.method === "New" ? 0 : ilog.id;
		x3writer.props1Serializer.write(_, this.cvgClient, {
			"990": "N" + String.fromCharCode(1) + "X" + errMess.length + "X" + errCode.length + "F" + String.fromCharCode(instanceId) + errMess + errCode
		});
	},
	callPluginIlogDelete: function(_, opt) {

	},
	_readPluginND_OCX: function(_, property) {
		return null;
	},
	_readPluginND_IHM: function(_, property) {
		var name, method;
		switch (property.IAction) {
			case '1':
				name = NAME_GANT;
				method = "New";
				break;
			case '2':
				name = NAME_GANT;
				method = "Update";
				break;
			case '3':
				name = NAME_GANT;
				method = "Delete";
				break;
			case '6':
				name = NAME_SCALE;
				method = "New";
				break;
			case '7':
				name = NAME_SCALE;
				method = "Update";
				break;
			case '8':
				name = NAME_SCALE;
				method = "Delete";
				break;
		}
		return {
			name: name,
			method: method,
			id: property.INumber || null,
			type: "asynchronous",
			module: property.IModule,
			"class": "Ilog",
			methodid: parseInt(property.IAction, 10)
		};
	}
});