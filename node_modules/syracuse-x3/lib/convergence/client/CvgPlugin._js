"use strict";
var helpers = require('syracuse-core/lib/helpers');
var CvgPluginTarget = require('syracuse-x3/lib/convergence/model/CvgPluginTarget').CvgPluginTarget;
var x3writer = require("syracuse-x3/lib/convergence/automata/x3writer");
var flows = require("streamline/lib/util/flows");
var CvgObserver = require("syracuse-x3/lib/convergence/client/CvgObserver").CvgObserver;

var NAME_GANT = "gantt";
var NAME_SCALE = "scale";


//

exports.CvgPlugin = helpers.defineClass(function(_, client, killTimeoutOnCreate) {
	CvgObserver.call(this);

	this.client = client;
	this.killTimeout = killTimeoutOnCreate;
	this.notifPlugin = false;
	this.replyClient = false;
	this.noTimeoutApply = false;
	this._trackLists = this.newTrackLists();
	this.response = {
		head: {
			statusCode: 200
		},
		body: {}
	};

}, CvgObserver, {

	// process request sent by the ilog client, return true if acknowledgement of delete  else false
	processRequest: function(_, act, body) {
		switch (act) {
			case "REGISTER": // notif that the plugin ilog client is launched and operational
				// clear timeout beacuse we get register notif from the client
				clearTimeout(this.timeout);
				if (body.$diagnose && body.$diagnoses.length) {
					// there error must client and x3 server
					this.sendIlogErrorToX3(_, this.clietn, opt, body.$diagnoses[0].$message, body.$diagnoses[0].$severity);
				} else {
					this.notifPlugin = true;
					this._writeRegisterIlogReply(_);
				}
				return false;
				break;
			case "PLUGIN_ACK":
				this._writeAckIlogReply(_, body && body.param && body.param.plugin);
				return body.param.plugin.method === "delete";
				break;
			default:
				throw new Error("action unknown -  can't process");
		}

	},

	// instanciate plugin controler from the cvgClient
	call: function(_, nodeName, property) {

		// TODO
		var fcContext = this["_readPlugin" + nodeName];

		var ilog = fcContext && fcContext.apply_(_, this, [property], 0); // construct context depending the plugin to call
		if (!ilog)
			throw new Error("Can't read context to call plugin (node " + nodeName + ")");

		var fc = this["_processPlugin" + ilog.class + ilog.method]; //  method of plugin to plugin
		fc.apply_(_, this, [ilog], 0);

		return ilog;
	},
	_clientReplyPlugin: function(_, property) { //TOOD  must improve to validate what kind of reply
		// get reply ilog and not write it until we have the confirmation from teh plugin controler
		this.replyClient = property;
		this._writeRegisterIlogReply(_);
	},

	_writeRegisterIlogReply: function(_) {
		this.notifPlugin && this.replyClient && !this.noTimeoutApply && x3writer.props1Serializer.write(_, this.client, this.replyClient);
	},
	_writeAckIlogReply: function(_, prop) {
		prop && prop.return &&prop.return .property && x3writer.props1Serializer.write(_, this.client, prop.return .property);
	},

	_processPluginIlogNew: function(_, opt) {
		// set Timeout to send automatic response to don't be blocked
		var self = this;
		this.timeout = flows.setTimeout(function(_) {
			// all is not ok in time

			self.sendIlogErrorToX3(_, self.client, opt, "timeout expired", "-1"); // send error to the runtime
			self.noTimeoutApply = true; // we don't get the plugin notif in time
		}, this.killTimeout);
		CvgPluginTarget.create(this.client, opt); // notify only classic page client

	},
	_processPluginIlogUpdate: function(_, opt) {
		CvgPluginTarget.create(this, opt); // notify only plugin client
	},
	_processPluginIlogDelete: function(_, opt) {
		CvgPluginTarget.create(this, opt); // notify plugin client
		CvgPluginTarget.create(this.client, opt); // notify classic page client
	},

	sendIlogErrorToX3: function(_, client, ilog, errorMess, errorCode) {
		// construct and send error reply property expected by
		var instanceId = ilog.method === "New" ? 0 : ilog.id;
		x3writer.props1Serializer.write(_, client, {
			"990": "N" + String.fromCharCode(1) + "X" + errorMess.length + "X" + errorCode.length + "F" + String.fromCharCode(instanceId) + errorMess + errorCode
		});


	},

	_readPluginND_OCX: function(_, property) {
		return null;
	},
	_readPluginND_IHM: function(_, property) {
		var name, method;
		switch (property.IAction) {
			case '1':
				name = NAME_GANT;
				method = "New";
				break;
			case '2':
				name = NAME_GANT;
				method = "Update";
				break;
			case '3':
				name = NAME_GANT;
				method = "Delete";
				break;
			case '6':
				name = NAME_SCALE;
				method = "New";
				break;
			case '7':
				name = NAME_SCALE;
				method = "Update";
				break;
			case '8':
				name = NAME_SCALE;
				method = "Delete";
				break;
		}
		return {
			name: name,
			method: method,
			id: property.INumber || null,
			type: "asynchronous",
			module: property.IModule,
			"class": "Ilog",
			methodid: parseInt(property.IAction, 10)
		};
	},
	getTarget: function() {
		var lists = this._trackLists;
		return JSON.parse(JSON.stringify(lists.TARGET[lists.TARGET.length - 1]));
	},
	generateResponse: function(_, connect, isTrack) {

		var lists = this._trackLists;
		var response = {
			sap: {}
		};
		var sap = response.sap;
		if (lists.TARGET.length !== 0) {
			var target = this.getTarget();
			if (!isTrack) {
				sap.target = target;
			} else if (sap.target) {
				delete sap.target;
			}
		}

		// serialized NDEXECI
		this.response.body = response;



	}
});