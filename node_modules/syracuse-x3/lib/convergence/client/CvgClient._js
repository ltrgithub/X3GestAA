"use strict";
var helpers = require('syracuse-core/lib/helpers');
var flows = require("streamline/lib/util/flows");
var datetime = require("syracuse-core/lib/types/datetime");
var locale = require("syracuse-core/lib/locale");
var automata = require("syracuse-x3/lib/convergence/automata/x3Automata");
var BoRestClient = require("syracuse-x3/lib/boRestClient").BoRestClient;
var sessionManager = require('syracuse-session/lib/sessionManager').sessionManager;
var x3writer = require("syracuse-x3/lib/convergence/automata/x3writer");
var fs = require('streamline-fs');
var jsxml = require('jsxml');
var httpClient = require("syracuse-httpclient/lib/httpClient");
var os = require('os');
var sfs = require('streamline-fs');
var x3helpers = require('syracuse-x3/lib/helpers');
var CvgClientConfig = require("syracuse-x3/lib/convergence/model/CvgClientConfig").CvgClientConfig;
var CvgModifier = require('syracuse-x3/lib/convergence/model/CvgModifier').CvgModifier;
var CvgEntity = require('syracuse-x3/lib/convergence/model/CvgEntity').CvgEntity;
var CvgStackedWindows = require('syracuse-x3/lib/convergence/model/CvgStackedWindows').CvgStackedWindows;
var CvgStackedWindow = require('syracuse-x3/lib/convergence/model/CvgStackedWindow').CvgStackedWindow;
var CvgReply = require('syracuse-x3/lib/convergence/client/CvgReply').CvgReply;
var CvgRequest = require('syracuse-x3/lib/convergence/client/CvgRequest').CvgRequest;
var CvgInstance = require('syracuse-x3/lib/convergence/model/CvgInstance').CvgInstance;
var CvgStatusBar = require('syracuse-x3/lib/convergence/model/CvgStatusBar').CvgStatusBar;
var CvgMenuAct = require('syracuse-x3/lib/convergence/model/CvgMenuAct').CvgMenuAct;
var CvgCallUiOpenFile = require('syracuse-x3/lib/convergence/model/CvgCallUiOpenFile').CvgCallUiOpenFile;
var CvgMenuCtx = require('syracuse-x3/lib/convergence/model/CvgMenuCtx').CvgMenuCtx;
var CvgDataSrc = require('syracuse-x3/lib/convergence/model/CvgDataSrc').CvgDataSrc;
var CvgDataSrcLine = require('syracuse-x3/lib/convergence/model/CvgDataSrcLine').CvgDataSrcLine;
var CvgVariable = require('syracuse-x3/lib/convergence/model/CvgVariable').CvgVariable;
var CvgClose = require('syracuse-x3/lib/convergence/model/CvgClose').CvgClose;
var CvgIst = require('syracuse-x3/lib/convergence/types/CvgIst').CvgIst;
var CvgResu = require('syracuse-x3/lib/convergence/types/CvgResu').CvgResu;
var CvgResuTdo = require('syracuse-x3/lib/convergence/types/CvgResu').TDO;
var CvgAction = require('syracuse-x3/lib/convergence/client/CvgAction').Actions;
var CvgSuperAction = require('syracuse-x3/lib/convergence/client/CvgAction').SuperActions;
var CvgSpecialAction = require('syracuse-x3/lib/convergence/client/CvgAction').SpecialActions;
var CvgException = require('syracuse-x3/lib/convergence/model/CvgException').CvgException;
var PrintClient = require('syracuse-x3/lib/clients/print/PrintClient');
var PrintHelpers = require('syracuse-x3/lib/clients/print/PrintHelpers');
var CvgImpMore = require('syracuse-x3/lib/convergence/model/CvgImp').CvgImpMore;
var CvgImpConfig = require('syracuse-x3/lib/convergence/model/CvgImp').CvgImpConfig;
var CONNECT_ACTION = require('syracuse-x3/lib/convergence/client/CvgAction').CONNECT_ACTION;
var CvgServices = require('syracuse-x3/lib/convergence/client/CvgServices');
var CvgDiagnose = require('syracuse-x3/lib/convergence/model/CvgDiagnose').CvgDiagnose;
var CvgCacheManager = require('syracuse-x3/lib/cvgCacheManager').CvgCacheManager;
var globals = require('streamline/lib/globals');
var Tracer = require('syracuse-collaboration/lib/entities/x3SessionConfig').Tracer;

var localConfig = x3helpers.config("x3fusion", null, {});
var traceAction = x3helpers.config("actions.trace", localConfig);
var traceProtocol = x3helpers.config("protocol.trace", localConfig);
var traceSessions = x3helpers.config("sessions.trace", localConfig);
var perfmon = require('syracuse-perfmon');

var cacheMgr = new CvgCacheManager();


// Setting sent to client at connection
var _uiCliSettings = {
	"ADXVersion": "ADXVersion",
	"adonix.port": "ADXPort",
	"usrProfile": "usrProfile",
	"x3host": "ADXAppHost",
	"Version": "Version",
	"ADXProduct": "ADXProduct",
	"Protocol": "Protocol",
	"STime": "STime",
	"SDecimal": "SDecimal",
	"ADXLangIso": "ADXLangIso",
	"SThousand": "SThousand",
	"adonix.host": "ADXTrtHost",
	"AdxSolution": "AdxSolution",
	"ADXProductPref": "ADXProductPref",
	"ADXProductLabel": "ADXProductLabel",
	"SetMonthList": "SetMonthList",
	"formater.von": "formater.von",
	"SDate": "SDate",
	"ADXProductInfoVers": "ADXProductInfoVers",
	"ADXSupVers": "ADXSupVers",
	"mnu": "mnu",
	"DefaultDatePivot": "datePivot",
	"x3user": "user",
	"ADXTheme": "ADXTheme",
	"ADXHttpPub": "ADXHttpPub",
	"ADXNamedUser": "ADXNamedUser",
	"ADXfolder": "ADXFolder",
	"cdLang": "cdLang",
	"DefaultDateFormat": "DefaultDateFormat",
	"fmtExt": "fmtExt",
	"ADXStyleFile": "ADXStyleFile",
	"ADXNopatch": "ADXNopatch",
	"ADXRelease": "ADXRelease",
	"IDate": "IDate",
	"ADXProductSuff": "ADXProductSuff",
	"BOSEC": "BOSEC",
	"BOSERV": "BOSERV",
	"BOUSR": "BOUSR",
	"BOPWD": "BOPWD",
	"ADXMaskAppName": "ADXMaskAppName",
	"ADXHelpLocation": "ADXHelpLocation"
};



function _postDiag(client, msg, detail) {
	new CvgDiagnose(client, 'WARNING', 99, msg, detail, null, "Protocol", null, true);
}

function _actionParams(body) {
	// params passed to listenSendingArgs are [action, ist (or null ist), params added by append2ActionParams]
	var params = [body.act];
	if (!body.param) return params;
	var target = body.param.target;
	if (target && target.xid != null) {
		params.push(CvgIst.fromTarget(target));
	}
	if (body.param.std) {
		params = params.concat(body.param.std);
	}

	return params;
}

var CModifiableFinder = exports.CModifiableFinder = helpers.defineClass(function() {
	CvgModifier.call(this);
	this.foundModifiable = null;
}, CvgModifier, {
	setModifiable: function(ist, aModifiable) {
		this.foundModifiable = aModifiable;
		this.done = true;
		return this.done;
	}
});

var CMotherWindow = exports.CMotherWindow = helpers.defineClass(function(aClient) {
	CvgEntity.call(this, aClient, "&ROOT", 1, 'WINDOW');
}, CvgEntity, {
	getAdxId: function() {
		return "mostherWindow - &ROOT";
	},
	toJson: function() {
		throw new Error("Bad tojson MotherWin");
	}
});

var CvgClient = exports.CvgClient = helpers.defineClass(function(_, cvgSession, stream, aConfig, recorder, context) {
	var lastMod;
	try {
		// Last modif until availabilty of Syracuse version number
		var stat = fs.statSync(__dirname + "/../../../.git/FETCH_HEAD");
		lastMod = stat.mtime.toLocaleString();
	} catch (e) {}

	var x3server = context.endpoint.x3server(_);
	var up = context.httpSession.getUserProfile(_);
	var user = "";
	if (up) {
		user = up.user(_) ? up.user(_).getEndpointLogin(_, context.endpoint.$uuid) : "";
	}
	this.srvTrace = null;
	this.baseUrl = context.baseUrl;
	this.callUiOpenFile = null;
	this.mapObj = {};
	this.recorder = recorder;
	this.creationDate = datetime.now();
	this.stream = stream;
	this.clientConfig = new CvgClientConfig(this, aConfig);
	this.printConfig = aConfig.printConfig || {};
	this._trackLists = this.newTrackLists();
	this._sessionSettings = {};
	this._x3SessionSettings = {};
	this.activeRequest = null;
	this._pickedLines = [];
	this._dynFormats = {};
	this._curDynFmt = null;
	this.uuid = helpers.uuid.generate();
	this._motherWin = new CMotherWindow(this);
	this._stackedWin = new CvgStackedWindows();
	// added by BRJOU - open not called any more
	this.newActiveRequest(new CvgReply(this, CONNECT_ACTION), {
		"reqNum": 0
	});
	this.connecting = false;
	this.isReuse = false;
	this.reused = false; // for the settings
	this.timeToReuse = -1; // time when the client was set in reuse
	this._cvgSession = cvgSession;
	this.services = CvgServices.create(_, this);
	this.sessInfo = {
		nodeWS: true,
		node: {
			sid: this._cvgSession.sid,
			sessSettings: sessionManager.getSettings(_),
			x3user: user,
			x3host: x3server.serverHost(_),
			x3port: x3server.serverPort(_),
			x3name: x3server.serverName(_),
			getlastmodif: lastMod
		},
		runtime: {
			x3user: user,
			x3host: x3server.serverHost(_),
			x3port: x3server.serverPort(_)
		}

	};
	this.context = context;
	this.boClient = new BoRestClient(_, null, null, context);

	this.getUiSpecialOrders = {
		GetBoToken: "executeGetUiBO",
		GetBoHost: "executeGetUiBO",
		GetBoPort: "executeGetUiBO"
	};

	this.tracer = new Tracer(this._cvgSession.sid, "Convergence Server", "Cvg");

}, null, {
	read: function(_, len, withTimeout) {
		try {
			return this.stream.read(_, len, withTimeout);
		} catch (e) {
			if (e.code === "ETIMEOUT") e.message = locale.format(module, "x3ReadTimeout", len, this.stream.available());
			// destroy stream
			this.stream.destroy();
			this.stream = null;
			//
			throw e;
		}
	},
	newTrackLists: function() {
		return {
			SESSION: [],
			SESSIONOPEN: [],
			ACT: [],
			TARGETACT: [],
			SESSIONMNU: [],
			TARGET: [],
			MISC: [],
			ENTITY: [],
			FUNCO: [],
			FUNCC: [],
			RPC: [],
			WINDOW: [],
			DIAGNOSE: [],
			GLDIAGNOSE: [],
			REPORT: []
		};
	},
	setInReuseMode: function(_, yes) {
		this.tracer.trace(_, "session", "setInReuseMode + " + yes, traceSessions);
		if (this.boClient.token)
			this.boClient.logoff();
		if (yes) {
			this.stopRecord();
			this.isReuse = true;
			this.reused = true;
			this.timeToReuse = (new Date()).getTime();
			this.tracer.trace(_, "session", "set timeout", traceSessions);
			var timeoutReuse = this.clientConfig.getParam("timeoutReuse");
			var self = this;
			this.tracer.trace(_, "session", "timeout reuse " + timeoutReuse, traceSessions);
			this.reuseTimeoutId = flows.setTimeout(function(_) {
				// get current time and check timeout of reuse
				this.tracer.trace(_, "session", "setTimeout - isReuse:" + self.isReuse + " - id:" + self.uuid, traceSessions);
				if (self.isReuse) { // only if it's reuse
					// reuse session need to be destroy
					if (self._cvgSession) self._cvgSession.destroyReuseClient(_, self);
					self.isReuse = false;
				}
			}, timeoutReuse);
		} else {
			this.isReuse = false;
			this.timeToReuse = -1;
			this.tracer.trace(_, "session", "clear timeout", traceSessions);
			clearTimeout(this.reuseTimeoutId);
		}
	},
	isSameContext: function(config) {
		// check context for reuse session
		return this.clientConfig.isSameContext(config, traceSessions);
	},
	execOpenFunction: function(_, context) {
		var ctx = context.parameters.f;
		var request = {
			act: 1077,
			fld: {
				ist: {
					win: "A",
					xid: "@@0"
				}
			},
			param: {
				target: {
					"win": "A",
					"xid": "@@0"
				},
				std: [{
					json: {
						"spgm": "GESUSER:CONNECT_FONCTION",
						"params": [{
							"dim": 1,
							"nb": 1,
							"size": ctx.length,
							"typ": "STRU",
							"resu": ctx
						}, {
							"dim": 1,
							"nb": 0,
							"size": 1,
							"typ": "STRU"
						}]
					}
				}]
			}
		};
		var data = this.processAction(_, request, true);
		return {
			head: {
				location: context.baseUrl + "/$sessions('" + this._cvgSession.sid + "')"
			},
			body: data
		};
	},
	connectSart: function(_, context) {
		var timing = perfmon.start(module, "cvgClient.connect", this._cvgSession.sid);

		this.connecting = true;

		automata.process(_, this);
		var resp = this.getResponse(_, true);
		this.tracer.trace(_, "session", "START CONNECTING OK:\n" + JSON.stringify(resp, null, 2), traceSessions);
		var startConnect = new Date().getTime();
		var t = timing.getTiming();
		t && this.activeRequest.timing.server.action.push(t);
		return {
			head: {
				location: context.baseUrl + "/$sessions('" + this._cvgSession.sid + "')",
				"syra-proxy-time": new Date().getTime() - startConnect
			},
			body: resp
		};
	},
	connectStop: function(_) {
		this.tracer.trace(_, "action", "STOP CONNECTING OK", traceAction);
		this.connecting = false;
	},
	// connect=true -> connectAction -> new client or openFunc on reuse client -> send settings to client
	// !! Reuse - some settings are received at the first connection (new client) and must be stored in order to be sent to reused client
	processAction: function(_, body, connect, mergeMode) {
		try {
			var timing = perfmon.start(module, 'cvgClient.processAction', body.act);
			var pendingNode;
			this.tracer.trace(_, "action", "************************************", traceAction);
			this.tracer.trace(_, "action", "Begin Process Action:\n" + JSON.stringify(body, null, 2), traceAction);
			this.recorder && this.recorder.dumpAction(_, body.act, false);
			// Create fresh request/reply objects
			var target, reply = new CvgReply(this, body.act);
			if (body.param && (target = body.param.target) && target.xid != null) {
				this.ctxNDSLB = CvgIst.fromTarget(target);
			} else {
				target = null;
			}
			// get action params (action is recorded into params[0])
			var params = _actionParams(body);
			// cleanup blocking node...
			if (params && (pendingNode = this.activeRequest.workingCtx.pendingBlockingNode) && pendingNode.act === params[0]) {
				delete this.activeRequest.workingCtx.pendingBlockingNode;
			}
			this.newActiveRequest(reply, {
				"ctxNDSLB": this.ctxNDSLB,
				"reqNum": body.tech && body.tech.id ? body.tech.id : 0,
				"target": target,
				"connect": connect
			}, mergeMode);
			var resu, extras = [];
			if (body.fld) {
				if (body.fld.v != null) {
					var entity = null;
					if (body.fld.ist) {
						// Retrieve the instance to obtain the data type of the action's resu
						var ist = CvgIst.fromAction(body.fld.ist);
						this.tracer.trace(_, "action", "ACTION IST=" + JSON.stringify(ist, null, 2), traceAction);
						entity = this.findModifiable(ist);
						//console.log("ACTION ENTITY=" + util.inspect(entity));
						if (entity && entity instanceof CvgVariable) {
							if (entity.dataType == null) throw new Error("data type not found: " + JSON.stringify(body));
							var value = body.fld.v;
							try {
								if (value !== undefined) {
									// value is a raw value
									if (entity.dataType === CvgResuTdo.BLOB) { // blob case the value is not send by the client but is store in blobSvc
										value = (this.services.blobSvc.getBlob(value) ? this.services.blobSvc.getBlob(value).binary : "");
									}
									// != null is appropriate to test not null and not undefined
									if (value != null) {
										resu = CvgResu.fromAction(entity.dataType, value);
										entity.setBrowserUnformattedValue(resu);
									}
								}
							} catch (e) {
								console.error("processAction ERROR");
								console.error(e.stack);
								var instance = CvgInstance.newtarget(this, ist, entity.format.format, body.fld.v, this.activeRequest.reply == null ? false : this.activeRequest.reply.stayInCommandMode);
								instance.exception = e;
								return this.getResponse(_);
							}
						}
					}
					if (!body.fld.ist || (entity && !(entity instanceof CvgVariable))) {
						var type = typeof body.fld.v === 'string' ? CvgResuTdo.STRU : CvgResuTdo.INT;
						resu = CvgResu.fromAction(type, body.fld.v);
					}
				}
				// Build the list of extra results to send after the first one
				// For only one optional extra: crsr (cursor position)
				// crsr is serialized directly as an int, not as a resu.
				var crsr = body.fld.ctx && body.fld.ctx.crsr;
				if (crsr != null) extras.push(new CvgResu(CvgResuTdo.INT, parseInt(body.fld.crsr, 10)));
			}
			if (!resu) resu = new CvgResu(CvgResuTdo.NULL, null);
			this.tracer.trace(_, "protocol", "Send true value: " + resu.toString(), traceProtocol);
			this.activeRequest.listenSendingArgs(body, this, params);
			//this.activeRequest.buildIstDatasOfAction(params[0]);
			// send the action to X3
			x3writer.sendAction(_, this, resu, extras, params);
			//CvgClient.checkFailed
			// run automata to get callbacks from X3 engine and return response

			automata.process(_, this);
			var resp = this.getResponse(_, connect);
			// timing trace
			var t = timing.getTiming();
			t && this.activeRequest.timing.all.action.push(t);
			this.tracer.trace(_, "action", "************************************", traceAction);
			this.tracer.trace(_, "action", "End Process Action:\n" + JSON.stringify(resp, null, 2), traceAction);
			return resp;
		} catch (e) {
			console.log("processAction error\n" + (e.stack ? e.stack : e));
			this.closeClient(_, e, 102);
			if (e instanceof CvgException) e.diagnose.recovery = "ABORT";
			throw e;
		}
	},
	processSuperAction: function(_, body) {
		this.tracer.trace(_, "action", "===================================", traceAction);
		this.tracer.trace(_, "action", "Process Super Action:\n" + JSON.stringify(body, null, 2), traceAction);

		var timing = perfmon.start(module, 'cvgClient.processSuperAction', body.act);
		//console.error("SuperAction ID: " + body.act);
		var offset = 768,
			superAction = body.act - offset > 0 ? CvgSuperAction[body.act - offset] : null;
		if (!superAction) throw new Error("Bad super action [" + body.act + "]");
		//console.error("SUPER ACTION: "+JSON.stringify(superAction,null,2));
		this.recorder && this.recorder.dumpAction(_, body.act, true);
		var std = [];
		if (body.param && body.param.sudo) {
			for (var i1 in body.param.sudo)
				std.push(body.param.sudo[i1]);
			delete body.param.sudo;
		}
		var resp = {}, nextFld;
		var stop = false;
		for (var i = 0; i < superAction.actions.length && !stop; i++) {
			var newBody = JSON.parse(JSON.stringify(body));
			var action = superAction.actions[i];
			var j = i;
			do {
				//console.error("Process Action: "+JSON.stringify(action,null,2));
				if (!CvgAction[action.name]) throw new Error("Bad sub-action: " + action.name);
				var processNext = true;
				newBody.act = CvgAction[action.name];
				if (nextFld) {
					newBody.fld.ist = nextFld.ist;
					newBody.fld.v = nextFld.v;
				}
				if (!action.setTarget) {
					this.tracer.trace(_, "action", "DELETE TARGET !!!", traceAction);
					delete newBody.param.target;
				}
				if (std[j]) {
					newBody.param.std = std[j];
					// Use other action sudo params (action number is added to params)
					if (action.propagate) {
						newBody.param.std.push(CvgAction[action.propagate]);
					}
				}
				resp = this.processAction(_, newBody, false, j !== 0);
				resp = JSON.parse(JSON.stringify(resp)); // invoke toJSON methods -- improve later
				var t1 = resp.sap && resp.sap.target && resp.sap.target.type === 'ist' && resp.sap.target.ist;
				if (!t1) stop = true;
				if (action.setTarget) {
					var t0 = newBody.param && newBody.param.target;
					processNext = superAction.processNextAction(CvgAction[action.name], t0, t1, action.checkNumLine);
				}
				//console.error("Process Next: "+processNext + " action.setTarget: "+action.setTarget);
				if (!processNext) {
					stop = true;
					break;
				} else {
					var respTarget = resp.sap.target.ist;
					if (respTarget) {
						nextFld = {
							ist: {
								xid: respTarget.xid,
								win: respTarget.win
							},
							v: respTarget.v
						};
						if (respTarget.nl) nextFld.ist.nl = respTarget.nl;
					}
				}
				j++;
			} while (j < std.length && action.isLoop);
		}
		timing.end();
		var t = timing.getTiming();
		t && this.activeRequest.timing.all.action.push(t);
		return resp;
	},
	processSpecialAction: function(_, body) {
		var timing = perfmon.start(module, 'cvgClient.processSpecialAction', body.act);

		this.tracer.trace(_, "action", "===================================", traceAction);
		this.tracer.trace(_, "action", "Process Special Action:\n" + JSON.stringify(body, null, 2), traceAction);

		var offset = 512,
			specialAction = body.act - offset > 0 ? CvgSpecialAction[body.act - offset] : null;
		if (!specialAction) throw new Error("Bad special action [" + body.act + "]");

		if (specialAction.proxy === "srvImp") {
			var printerName, srvImp, printClient = null;
			srvImp = this.activeRequest.srvImp;
			// Create fresh request/reply objects
			var target, reply = new CvgReply(this, body.act);
			if (body.param && (target = body.param.target) && target.xid != null) {
				this.ctxNDSLB = CvgIst.fromTarget(target);
			} else {
				target = null;
			}
			this.newActiveRequest(reply, {
				"ctxNDSLB": this.ctxNDSLB,
				"reqNum": body.tech && body.tech.id ? body.tech.id : 0,
				"target": body.param && body.param.target,
				"connect": false
			}, false);
			if (srvImp) this.activeRequest.srvImp = srvImp;

			switch (specialAction.id) {
				case "PRINTER_SEL_OPTS":
					printerName = body.param && body.param.selpr && body.param.selpr.printerName;
					if (!printerName) throw new CvgException(this, null, "printerName is required.", null, "srvImpSvc");
					try {
						printClient = PrintClient.getClient(_, srvImp.hostname, srvImp.port, srvImp.id);
						var infos = printClient.getAdvancedParameters(_, printerName, body.param.selpr.port, body.param.selpr.driver);
						new CvgImpMore(this, infos);
					} catch (e) {
						if (printClient) {
							printClient.panicRelease();
							printClient = null;
						}
						var diag = new CvgDiagnose(this, 'INFO', 99, locale.format(module, "GET_PRINTER_OPT_1"), '"' + srvImp.hostname + ":" + srvImp.port + '" : ' + (e.message || ""), e, "Protocol [processSpecialActionPRINTER_SEL_OPTS]", null, false);
						new CvgImpMore(this, null, diag);
					}
					break;

				case "PRINTER_SEL_CANCEL":
					// Send empty properties to back office
					delete this.activeRequest.workingCtx.pendingBlockingNode;
					x3writer.props1Serializer.write(_, this, {});
					automata.process(_, this);
					break;

				case "PRINTER_SEL_OK":
					var selected = body.param && body.param.selpr && body.param.selpr.selected;
					delete this.activeRequest.workingCtx.pendingBlockingNode;
					printerName = selected.name;
					if (!printerName) {
						// Send empty properties to back office
						delete this.activeRequest.workingCtx.pendingBlockingNode;
						x3writer.props1Serializer.write(_, this, {});
						automata.process(_, this);
						break;
					}
					var props = {}, paperProps, devmode = {};
					if (selected.driver) props._PrinterDriver = selected.driver;
					if (selected.name) props._PrinterName = selected.name;
					if (selected.port) props._PrinterPort = selected.port;
					if (srvImp) props._PrinterServer = srvImp.hostname + ":" + srvImp.port;
					props._PrinterCopies = selected.copies || 1;
					if (selected.collate !== null && selected.collate !== undefined) props._PrinterCollate = selected.collate;
					if (selected.startPage) props._PrinterStartPage = selected.startPage;
					if (selected.stopPage) props._PrinterStopPage = selected.stopPage;
					if (selected.orientation !== null && selected.orientation !== undefined) props._Orientation = selected.orientation;
					devmode.duplex = selected.duplex && typeof selected.duplex === "string" ? parseInt(selected.duplex, 10) : selected.duplex;
					// Check paper size/source
					if (printerName && (selected.paperSize || selected.paperSource)) {
						try {
							printClient = PrintClient.getClient(_, srvImp.hostname, srvImp.port, srvImp.id);
						} catch (e) {
							if (printClient) {
								printClient.panicRelease();
								printClient = null;
							}
						}
						if (printClient) {
							//console.log("\t Papers props IN for " + printerName + " : size=" + selected.paperSize + " source=" + selected.paperSource);
							paperProps = printClient.checkPrinterPaper(_, printerName, selected.port, selected.driver, selected.paperSize || null, selected.paperSource || null);
							if (paperProps) {
								//console.log("\t Papers props OUT" + JSON.stringify(paperProps,null, 2));
								devmode.paperSize = paperProps.paperSize;
								devmode.paperSource = paperProps.paperSource;
							}
						}
					}
					PrintHelpers.setDevmodeInSrvProperties(devmode, props);
					//console.log("NDGTIM Properties OUT: " + JSON.stringify(props, null, 2));
					x3writer.props1Serializer.write(_, this, props);
					automata.process(_, this);
					break;

				case "PRINTER_OPTS_CANCEL":
				case "PRINTER_OPTS_OK":
					new CvgImpConfig(this, null);
					break;

				default:
					throw new Error("Unknow SrvImp action [" + specialAction.id + "]");
			}
			timing.end();
			var t = timing.getTiming();
			t && this.activeRequest.timing.all.action.push(t);
			return this.getResponse(_);
		} else {
			throw new Error("Bad proxy [" + specialAction.proxy + "] for special action [" + body.act + "]");
		}
	},
	processRequest: function(_, context, bodyStr) {
		if (context.method !== 'put') throw new Error("bad method: " + context.method);
		var act = parseInt(context.parameters.act, 10);

		// We need to store string to pass to recorder
		bodyStr = bodyStr != null ? bodyStr : context.request.readAll(_);
		var body = JSON.parse(bodyStr),
			resp = "";
		if (body.settings && body.settings.syraTrace) this.srvTrace = body.settings.syraTrace;
		if (parseInt(body.act, 10) !== act) throw new Error("body act mismatch: expected " + act + ", got " + body.act);
		if (act >= 1024) {
			resp = this.processAction(_, body);
		} else if (act >= 768) {
			resp = this.processSuperAction(_, body);
		} else {
			resp = this.processSpecialAction(_, body);
		}

		return {
			body: resp
		};
	},
	loadWindowDescription: function(_, ist, winId, funcId, stamp) {
		var timing = perfmon.start(module, 'cvgClient.loadWindowDescription', funcId);
		var self = this,
			descr;
		var reload = false;

		if (this.clientConfig.modePLAY) {
			// stream fakes data access to X3 and other resources used by cvgClient
			descr = this.stream.readDescr(_);
		} else {
			try {

				var file, jsonDescr;
				try {
					file = sfs.readFile(__dirname + "/../data/" + winId + ".xml", "utf8", _);
				} catch (e) {
					//console.log("failed to read local file (try remote file) "+e.stack);
				}
				if (!file) {
					var url = this.winDescrUrl(winId);
					jsonDescr = cacheMgr.getResource(_, url);
				} else {
					jsonDescr = file;
				}
				descr = jsxml.parse(jsonDescr).WIND;
			} catch (e) {
				throw new CvgException(self, e, locale.format(module, "ERROR_WINMANAGER_LOADING", winId), "KILL", "", (e.message && url ? e.message + " : " + url : (url || null)));
			}
			if (this.recorder) {
				// We need to store description to be able to replay
				this.recorder.dumpWinDescr(_, descr);
			}
		}
		timing.end();
		var t = timing.getTiming();
		t && this.activeRequest.timing.server.action.push(t);

		var win = this.pushRequesterWindow(winId, funcId, descr, stamp, ist.win);
		if (win.id === "_FORMULA") {
			// get default element in
			this.getFormulaItem(_, win, "x3Uoperators", 'B');
			this.getFormulaItem(_, win, "x3Ufunctions", 'C');
		}
		return win;
	},
	getFormulaItem: function(_, win, file, target) {
		var lang = this._x3SessionSettings.cdLang || "";
		if (lang.trim().length === 0) throw new Error('Open window[' + win + '] failed.\nX3 language code (cdLang) has not been received from X3 server\nPlease check X3 folder[' + this.clientConfig.getParam('x3Folder') + '] configuration');
		var x3HttpPub = this.clientConfig.getParam("x3HttpPub");
		var url = x3HttpPub + "/X3_ROOT/GEN/" + lang + "/LIB/" + file + ".xml";
		var opt = {
			method: "GET",
			url: url,
			headers: {}
		};
		var request = httpClient.httpRequest(_, opt);
		var response = request.end().response(_);
		response.setEncoding('utf8');
		//console.log("statusCode=" + response.statusCode);
		var body = response.readAll(_);
		if (response.statusCode === 200 && body) {
			var items = jsxml.parse(body);
			for (var i = 0; i < items.Main.LINE.length; i++) {
				var item = items.Main.LINE[i];
				var col3 = (target === "B" ? 2 : item.COL[3].$cdata);
				this.activeRequest.listenNodeNDOFLD(_, null, null, win.getAdxIst(), item.COL[0].$cdata, item.COL[1].$cdata, item.COL[2].$cdata, col3, item.COL[4].$cdata, item.COL[5].$cdata, target);
			}
		}
	},

	getMessage: function() {
		var args = [module, arguments[0]];
		for (var i = 1; i < arguments.length; i++) {
			args.push(arguments[i] ? arguments[i].toString() : arguments[i]);
		}
		var res = locale.format.apply(null, args);
		return res;
	},
	closeClient: function(_, e, reason) {
		this.stopRecord();
		console.log("CloseClient Convergence Client\n\tReason[" + reason + "]\n\tAlreadyClosed[" + (this.connClient == null || !this.connClient.hasSocket()) + "] - Exception[" + (e == null ? "None" : e.message ? e.message : e) + "]");
		new CvgClose(this, reason, e, "");
		if (this.boClient.token) { // logoff on close if necessary
			this.boClient.logoff(_);
		}
		this.closeSocket();
		if (this.boClient.token) {
			this.boClient.logoff(_);
		}
	},
	containsAdxPubSubFile: function(aListOfProperties) {
		var wProperty;
		var wMax = aListOfProperties.length;
		var wI = 3; // pour demarer a la 4eme propriete !
		while (wI < wMax) {
			wProperty = aListOfProperties.get(wI);
			if (wProperty.hasId() && wProperty.id.toUpperCase() === "UIAdxPubSubFile".toUpperCase()) {
				return true;
			}
			wI++;
		}
		return false;
	},
	deconnectClient: function(_, reason) {
		var pendingNode, resp;
		this.stopRecord();
		try {
			console.log("Deconnect Convergence client - isAlive" + this.isAlive() + "\n\tReason[" + (reason == null ? "none" : reason) + "]\n\tAsk X3 server to close ");
			if (this.isAlive()) {
				if (this.clientConfig.modePLAY) {
					this.closeSocket();
				} else {
					// create a request for deconnection
					if (this.activeRequest && (pendingNode = this.activeRequest.workingCtx.pendingBlockingNode)) {
						// Some protocole nodes (like SELIMP, NDGTDT, ND_ASKUI, etc...) could open special windows, outside standard windows stack/interaction. Then it's necessary to release
						// properly these windows, before to close a session, sending proper action expected by runtime for these nodes. Note : just one blocking node by request!
						resp = this[pendingNode.proxy](_, {
							act: pendingNode.act,
							fld: pendingNode.fld || {
								notModified: true
							},
							param: pendingNode.param
						});
						delete this.activeRequest.workingCtx.pendingBlockingNode;
					}
					this.processAction(_, {
						act: 1075,
						fld: {},
						param: {},
						tech: {}
					});
				}
			}
		} finally {
			this.activeRequest = null;
			this.tracer.close(_);
		}
	},
	closeSocket: function() {
		if (this.isAlive()) {
			this.stream.end();
			this.stream = null;
			return true;
		}
		return false;
	},
	stopRecord: function() {
		if (this.recorder) this.recorder.close();
		this.recorder = null;
	},
	executeCallUiOpenFile: function(values) {
		//console.log(JSON.stringify(values));
		var idx, appSrvShared = null,
			srvPubType, url;
		var localDir = values["UILocalDir"];
		var localFile = values["UILocalFile"].replace("\\", "/");
		if (localFile && (localDir === "HTTP" || localDir === "HTTPS")) {
			srvPubType = values["UIAdxPubSubFile"];
			if (srvPubType !== undefined) {
				srvPubType = parseInt(srvPubType, 10);
				if (srvPubType == 1) {
					idx = localFile.substring("/");
					url = localFile.substring(idx);
				} else if (srvPubType == 2) {
					appSrvShared = true;
				} else if (srvPubType == 3) {
					appSrvShared = false;
				}
			}
			if (this.callUiOpenFile) {
				this.callUiOpenFile.addOpenFile(localDir.toLowerCase(), url || localFile, appSrvShared);
			} else {
				this.callUiOpenFile = new CvgCallUiOpenFile(this, localDir.toLowerCase(), url || localFile, appSrvShared);
			}
		}
		return {};
	},
	execCallUi: function(_, values) {
		if (values.UIAction === "SessionSettings") {
			return this.executeAllSessionSettings(values);
		} else if (values.UIAction === "SetWindFeatures") {
			return this.executeAllSessionSettings(values);
		} else if (values.UIAction === "Sethangup") {
			return this.executeCallUiSetHangHup(values);
		} else if (values.UIAction === "SetTechnoVers") {
			return this.executeCallUiSetTechnovers(values);
		} else if (values.UIAction === "GetFileAlways") {
			//return this.executeCallUiGetFile(true, values);
		} else if (values.UIAction === "GetFile") {
			//return this.executeCallUiGetFile(false, values);
		} else if (values.UIAction === "PutFileAlways") {
			//return this.executeCallUiPutFile(true, values);
		} else if (values.UIAction === "PutFile") {
			//return this.executeCallUiPutFile(false, values);
		} else if (values.UIAction === "OpenFile") {
			return this.executeCallUiOpenFile(values);
		}
		return;
	},
	executeAllSessionSettings: function(values) {
		var keys = Object.keys(values);
		for (var i = 1; i < keys.length; i++) {
			this._x3SessionSettings[keys[i]] = values[keys[i]];
		}

		// Set formater datePivot
		if (values.DefaultDatePivot != null) {
			this.clientConfig.setDatePivot(this._x3SessionSettings.DefaultDatePivot);
		}
		return {
			UIAction: "SessionSettings"
		};
	},
	executeCallUiSetTechnovers: function(values) {
		// TODO manage protocol negociation
		this.executeAllSessionSettings(values);
		return values;
	},
	executeCallUiSetHangHup: function(values) {
		return {
			Sethangup: 1
		};
	},

	executeGetUiBO: function(_, key) {
		var result = {};
		if (key === "GetBoToken") {
			result[key] = this.boClient.token ? this.boClient.token : this.boClient.logon(_, true);
		} else if (key === "GetBoHost") {
			this.boClient.init(_);
			result[key] = this.boClient.bohost;
		} else if (key === "GetBoPort") {
			this.boClient.init(_);
			result[key] = this.boClient.boport;
		}
		return result;
	},
	findModifiable: function(ist) {
		var finder = new CModifiableFinder();
		this.traverseSettable(ist, finder);
		return finder.foundModifiable;
	},
	// Connection messages
	listenNodeND_SLF: function(_, reader, node, properties) {
		//console.log("ND_SLF properties: "+JSON.stringify(properties,null,2));
		var result = this.execCallUi(_, properties);
		return x3writer.props1Serializer.build(result, true);
	},
	listenNodeND_GFD: function(_, reader, node, properties) {
		// console.log("ND_GFD properties: "+JSON.stringify(properties,null,2));
		var key = properties[0];
		var result;
		if (this.getUiSpecialOrders[key]) {
			result = this[this.getUiSpecialOrders[key]](_, key);
		}
		if (!result) {
			result = {};
			result[key] = this.clientConfig.getParam(key);
			if (result[key] === undefined) {
				//console.error("Unsupported param: "+key);
				result[key] = "unsupported";
			}
		}
		return x3writer.props1Serializer.build(result, true);
	},
	listenNodeNDCOPMENU: function(_, reader, node, data) {
		//reply.setSplashInfos(data);
	},
	listenNodeNDDEB: function(_, reader, node) {},

	listenNodeND_CLT: function(_, reader, node, dummyByte) {
		// 15w_001 - Fiche 36012 - X3Client: Supervision des sockets
		// Si reception du noeud ND_CLT non attendu => not ok fermeture du
		// client depuis le meme thread
		this.closeClient(_, null, this.connecting ? 4 : 3);
	},
	/**
	 * NDACTOBJ (Adxcpl_displayWin) Affichage d'une fenetre Id=[NDACTOBJ]
	 * x3func=[Adxcpl_displayWin] NbArgs=[2] - ist =[ win=[2] srn=[0] blc=[0]
	 * fld=[0] idx=[0]] - opt=[.x04]
	 */
	listenNodeNDACTOBJ: function(_, reader, node, ist, num) {
		var WIN_NOHIDDEN = 4;
		if (num > WIN_NOHIDDEN) {
			var win = this.findModifiable(ist);
			if (win != null && win instanceof CvgStackedWindow) {
				win.setScreenToShow(num - WIN_NOHIDDEN + 1);
			}
		} else {
			// TODO
		}
	},

	/**
	 * NDACTOP 0E4000 (Activation_Action) Activation d=[NDACTOP] level=[?]
	 * x3func=[Activation_Action] nb=[2] - ide=[2823] ID Action - typ=[.x01]
	 * Status
	 */
	listenNodeNDACTOP: function(_, reader, node, actId, flag) {
		new CvgMenuAct(this, actId, flag);
	},

	/**
	 * Le serveur envoi 3 noeuds ndctsu pour decrire un format dynamique. voir
	 * l'innerclasse "CDynFormat" Id=[NDCTSU] level=[C]
	 * x3func=[Control_DefineType] NbArgs=[3] - opt=[.x65] - su1 =[c] - su2 =[_]
	 */
	listenNodeNDCTSU: function(_, reader, node, type, subType, compl) {
		/*
		 * Traite le premier noeud NDCTSU contenant le type. Exemple: Type=[g]
		 * SubType=[] Complement=[] Le noeud correspondant: Id=[NDCTSU]
		 * func=[Control_DefineType] NbArgs=[3] opt=[.x67] su1 =[] su2 =[])
		 */
		type = String.fromCharCode(type);
		if (this._curDynFmt == null) {
			this._dynFormats[type] = this._curDynFmt = {};
		}
		/*
		 * Traite le deuxieme noeud NDCTSU contenant le SubType. Exemple:
		 * Type=[g] SubType=[AX] Complement=[] Le noeud correspondant:
		 * Id=[NDCTSU] func=[Control_DefineType] NbArgs=[3] opt=[.x67] su1 =[AX]
		 * su2 =[]
		 */
		else if (this._curDynFmt.subType == null) {
			this._curDynFmt.subType = subType;
		}
		/*
		 * Traite le troisieme noeud NDCTSU contenant le complement (ou non).
		 * Exemple: Type=[g] SubType=[AX] Complement=[] Le noeud correspondant:
		 * Id=[NDCTSU] func=[Control_DefineType] NbArgs=[3] opt=[.x67] su1 =[AX]
		 * su2 =[]
		 */
		else {
			/*
			 * mis en place du complement, creation du format dynamique dans le
			 * formater, et destroy du format dynamique
			 */
			this._curDynFmt.complement = compl;
			this._curDynFmt = null;
		}
	},

	/**
	 * NDOMNCO 0E015E (MenuDyn_New) Id=[NDOMNCO] level=[R] x3func=[MenuDyn_New]
	 * NbArgs=[5] - flg=[.x58] - cod=[1026] - txt=[Selection] - acc=[0] - hlp
	 * =[] parametre passes a la fonction "MenuDyn_New" du client X3 :
	 *
	 * (*fnd)( (flg&0x40)>>6, fen, (flg&0x08)>>3, cod, txt, acc, (flg&0x7), 0,
	 * (flg&0x10)>>4, (flg&0x20)>>5, hlp ) ;
	 *
	 * bFirst Premiere option (vide la liste) ((wByte & 0x40) >> 6) nRang Rang
	 * d'insertion de l'option (0 pas d'option) nType Type de l'option (flg &
	 * 0x08) >>3) nAction Action a renvoyee au serveur pszText texte de l'option
	 * nAccel Accelerateur nCateg Categorie dans le type (flg&0x7) nImage Numero
	 * de l'image bValide Valide ou bien (flg&0x10)>>4 bSelect Selectionne ou
	 * bien (flg&0x20)>>5 pszhelp texte d'aide rapide
	 */
	listenNodeNDOMNCO: function(_, reader, node, flag, actId, txt) {
		var type = (flag & 0x08) >> 3 === 0;
		if (!type && actId > 0) {
			var clearMenuList = (flag & 0x40) !== 0;
			// FDB/CMI - We skip clearMenuList instruction
			// Normally we should send clearMenuList:true/false to client to let it clear menu list
			// but clearMenuList=true is always received before receiveing a new nenu list and client clear the old one by default
			new CvgMenuCtx(this, actId, true, txt);
		}
	},

	/**
	 * Changement element dans barre de statut Id=[NDOTXSC] level=[W]
	 * x3func=[Status_ChangeStatus] NbArgs=[6] - ist =[ win=[2] srn=[0] blc=[0]
	 * fld=[0] idx=[0]] - st[0]=[.x00] (byte) - st[1]=[132] (int) - buf[0] =[]
	 * (stru) - buf[1] =[] (stru) - st[2]=[3058] (int)
	 */
	listenNodeNDOTXSC: function(_, reader, node, ist, numTxt, imgId, txt, dummyTxt, actId) {
		var winFound = null;
		for (var i = 0; i < this._stackedWin.length && winFound == null; i++) {
			var item = this._stackedWin[i];
			if (item && item.getAdxIst().winAlphaId === ist.winAlphaId) {
				winFound = item;
			}
		}
		if (winFound != null) {
			winFound.addStatusIconDef(ist, numTxt, txt, imgId, actId);
		}
	},

	/**
	 * Id=[NDPKAR] func=[LeftList_Picking] NbArgs=[1] - ist =[ win=[2] srn=[34]
	 * blc=[3] fld=[0] idx=[0]]
	 */
	sendNotify: function(ist, level, message) {
		var winFound = null;
		if (ist == null) {
			winFound = this._stackedWin[0];
		}
		for (var i = 0; i < this._stackedWin.length && winFound == null; i++) {
			var item = this._stackedWin[i];
			if (item && item.getAdxIst().winAlphaId === ist.winAlphaId) {
				winFound = item;
			}
		}
		if (winFound != null) {
			winFound.addStatusIconDef(this, 100 + level, message, 0, 0);
		}

	},
	pickingAddLine: function(aPickedLine) {
		this._pickedLines.push(aPickedLine);
	},
	listenNodeNDPKAR: function(_, reader, node) {
		var actArgs;
		if (this._pickedLines.length > 0) {
			var pickedLine = this._pickedLines.splice(0, 1)[0];
			actArgs = [pickedLine.action];
			var ist = pickedLine.ist;
			var keyP = pickedLine.key;
			var leftList = pickedLine.leftList;
			if (keyP != null) {
				// suppression du numero de ligne dans l'adxid de la lisgne pickee ajout de l'argument tdans la liste
				ist.idx = 0;
				actArgs.push(ist);
				// ajout de l'argument tableau de resu qu'est la cle de la ligne  pickee

				if (typeof keyP === "string") {
					var key = [keyP];
					if (keyP.indexOf('^') !== -1) {
						key = keyP.split('^');
					}
					var resus = [];
					for (var i = 0; i < key.length; i++) {
						var t = key[i].split("~");
						var resu = new CvgResu.fromAction(parseInt(t[0], 10), t.slice(1).join("~"));
						resus.push(resu);
					}

					actArgs.push(resus);
					var line = leftList.findLine(resus);
					leftList.setServerSelectLine(pickedLine.isSelection(), resus);
				}
			} else {
				actArgs.push(ist.toString());
				_postDiag(this, this.getMessage('ERROR_CANT_GET_PICKED_LINE_KEY', 'NDPKAR - ' + ist.toString()));
			}
		} else {
			actArgs = [CvgAction.SRV_ABANDON];
		}
		// BRJOU: did not see any resu, pass null
		x3writer.sendAction(_, this, new CvgResu(CvgResuTdo.NULL, null), [], actArgs);
	},
	razModification: function() {
		this.callUiOpenFile = null;
		this._stackedWin.razModifications();
		this._trackLists = this.newTrackLists(); // should be inside request???
	},
	newActiveRequest: function(reply, sendContext, modeMerge) {
		if (!modeMerge) {
			this.razModification();
		}
		this.activeRequest = new CvgRequest(this, reply, sendContext);
		return this.activeRequest;
	},
	popRequesterWindow: function(winIst) {
		var win = this._stackedWin.popStackedWindow(winIst);
		win.setOpened(false);
		win.jsonType = "FUNCC";
		this.track(win);
		return win;
	},
	pushRequesterWindow: function(winId, funcId, descr, stamp, winIdx) {
		var win = new CvgStackedWindow(this, winId, funcId, descr, stamp, winIdx);
		this._stackedWin.pushStackedWindow(win, winIdx);
		win.setStackLevel(this._stackedWin.length);
		win.setOpened(true);
		win.jsonType = "FUNCO";
		this.track(win);
		return win;
	},
	toString: function(aSeparator) {
		return "";
	},
	traverseSettable: function(ist, aModifier) {
		if (ist.isWindowIst() && ist.winZeroBase === -1) {
			return aModifier.setModifiable(ist, this._motherWin);
		} else {
			return this._stackedWin.traverseSettable(ist, aModifier);
		}
	},
	track: function(obj) {
		// add if not exists the current obj
		var list = this._trackLists[obj.jsonType];
		// Allow observable to not send adat - see CvgDiagnose
		if (obj.sendToClient && !obj.sendToClient(list)) return;
		if (obj.getObservableId) {
			// we can add keys directly to the array, they will be ignored by JSON.stringify
			var key = '#' + obj.getObservableId();
			var old = list[key];
			if (old != null) {
				list[old] = undefined;
			}
			list[key] = list.length;
		}
		list.push(obj);
	},
	setUserProfile: function(profil) {
		if (this._x3SessionSettings.usrProfile !== profil) this._x3SessionSettings.usrProfile = profil;
	},
	winDescrUrl: function(winId) {
		var lang = this._x3SessionSettings.cdLang || "";
		var langKnown = {
			"de-DE": "GER",
			"en-GB": "BRI",
			"en-US": "ENG",
			"es-ES": "SPA",
			"fr-FR": "FRA",
			"it-IT": "ITA",
			"pl-PL": "POL",
			"pt-PT": "POR",
			"ru-RU": "RUS"
		};
		if (lang.trim().length === 0) {
			lang = langKnown[this.clientConfig.getParam("x3Lang")];
			if (lang != null) {
				this._x3SessionSettings.cdLang = lang;
				_postDiag(this, this.getMessage('WARNING_CANT_GET_CDLANG_MSG'), this.getMessage('WARNING_CANT_GET_CDLANG_DETAIL', lang));
			} else {
				throw new Error(this.getMessage('WARNING_CANT_GET_CDLANG_ERROR', winId, this.clientConfig.getParam("x3Lang"), this.clientConfig.getParam('x3Folder')));
			}
		}
		var x3HttpPub = this.clientConfig.getParam("x3HttpPub");
		var x3Folder = this.clientConfig.getParam("x3Folder");
		return x3HttpPub + "/" + x3Folder + "/GEN/" + lang + "/FENS/" + winId + ".xml";
	},
	_buildUiClientSettings: function() {
		var res = {};
		for (var i in _uiCliSettings) {
			if (this._sessionSettings[i]) res[_uiCliSettings[i]] = this._sessionSettings[i];
			else if (this._x3SessionSettings[i]) res[_uiCliSettings[i]] = this._x3SessionSettings[i];
		}
		// Add formater settings for client formater
		this.clientConfig.addUiCliSettings(res);
		return res;
	},
	isAlive: function() {
		return this.stream != null && !this.stream.closed;
	},
	// somme value in the timing
	_calculTiming: function(timing) {
		var self = this;

		if (Array.isArray(timing)) {
			// calcul sum
			var sum = 0;
			timing.forEach(function(item) {
				sum += item.duration;
			});
			timing.push({
				id: "sum",
				value: sum
			});
		} else if (Object.keys(timing).length > 1) {
			Object.keys(timing).forEach(function(key) {
				self._calculTiming(timing[key]);
			});
		}
	},

	getResponse: function(_, connect, isTrack) {
		var timing = perfmon.start(module, "cvgClient.getResponse");
		var lists = this._trackLists;
		var isDefined = function(o) {
			return o !== undefined;
		};

		var wins = {}, win, key, i;
		for (i = 0; i < lists.ENTITY.length; i++) {
			var entity = lists.ENTITY[i];
			if (entity === undefined || entity instanceof CvgStackedWindow) continue;

			win = entity instanceof CvgStackedWindow ? entity : (entity instanceof CvgStatusBar ? entity.stackedWindow : this._stackedWin.findWin(entity.getFatherWindowId().charCodeAt(0) - '@'.charCodeAt(0)));
			if (win) {
				var winNode = wins[win.entityIdxAlpha];
				if (!winNode) {
					winNode = wins[win.entityIdxAlpha] || {
						entities: {}
					};
					if (win.statusBarChange) winNode.statBar = win.statusBar.toJSON();
					if (win.hasModifTitle()) winNode.tit = win.title;
					wins[win.entityIdxAlpha] = winNode;
				}
				if (entity instanceof CvgStatusBar) {
					// nothin
				} else if (entity instanceof CvgEntity) {
					var gridParent = null;
					var line = null;
					if (entity instanceof CvgVariable) {
						line = entity.srcLine;
					} else if (entity instanceof CvgDataSrcLine) {
						line = entity;
					} else if (entity instanceof CvgDataSrc) {
						gridParent = entity;
					}
					if (line != null) {
						gridParent = line.dataSrc;
					}
					if (gridParent != null || line != null) {
						if (gridParent == null) {
							gridParent = line.dataSrc;
						}
						if (gridParent.isBlocGrid()) {
							entity = gridParent;
						}
					}

					var jsonKey = entity.getJsonKey();

					if (winNode.entities[jsonKey] == null) {
						var jsonEntity = entity.toJSON();
						if (jsonEntity && Object.keys(jsonEntity).length !== 0) {
							winNode.entities[jsonKey] = jsonEntity;
						}
					}
				}
			}
			/*if (win && win.entityIdxAlpha && Object.keys(wins[win.entityIdxAlpha].entities).length === 0)
				delete wins[win.entityIdxAlpha];*/
		}
		var response = {
			sap: {},
			session: lists.SESSION[0] || {}
		};
		if (lists.SESSIONOPEN && lists.SESSIONOPEN.length !== 0) {
			response.session.open = JSON.parse(JSON.stringify(lists.SESSIONOPEN[0]));
		}
		var sap = response.sap;
		if (lists.MISC && lists.MISC.length !== 0) {
			sap.misc = JSON.parse(JSON.stringify(lists.MISC[0]));
		}
		if (lists.TARGET.length !== 0) {
			var target = JSON.parse(JSON.stringify(lists.TARGET[lists.TARGET.length - 1]));
			if (!isTrack) {
				sap.target = target;
			} else if (sap.target) {
				delete sap.target;
			}
		}
		var acts = lists.ACT.filter(isDefined);
		if (acts && acts.length !== 0) sap.acts = acts;
		if (lists.RPC.length !== 0 && sap.target && sap.target.type !== 'portal') {
			sap.rpc = JSON.parse(JSON.stringify(lists.RPC[0]));
		}
		for (i = 0; i < lists.FUNCO.length; i++) {
			sap.func = sap.func || {};
			win = lists.FUNCO[i];
			key = win && win.entityIdxAlpha;
			if (win && win.isOpened()) {
				// object with key: win
				win.dumpOpened = true;
				sap.func.open = sap.func.open || {};
				sap.func.open[key] = win;
			}
		}
		for (i = 0; i < lists.FUNCC.length; i++) {

			sap.func = sap.func || {};
			win = lists.FUNCC[i];
			key = win && win.entityIdxAlpha;
			if (win && win.dumpOpened) {
				// just an array of keys
				sap.func.close = sap.func.close || [];
				sap.func.close.push(key);
				//				wins[key] = {
				//					tit: win.title,
				//					entities: {}
				//				};
			}
		}
		if (Object.keys(wins).length > 0) sap.wins = wins;
		if (sap.target && sap.target.ist) {
			for (i = 0; i < lists.TARGETACT.length; i++) {
				sap.target.ist.acts = sap.target.ist.acts || [];
				sap.target.ist.acts.push(lists.TARGETACT[i]);
			}
		}
		for (i = 0; i < lists.REPORT.length; i++) {
			sap.jobs = sap.jobs || {};
			sap.jobs.report = sap.jobs.report || {};
			var report = lists.REPORT[i];
			var kind = report.kind;
			sap.jobs.report[kind] = sap.jobs.report[kind] || [];
			sap.jobs.report[kind].push(JSON.parse(JSON.stringify(report)));
		}
		if (true === connect) {
			// Add session settings only at connection
			// add dynamic formats
			this._sessionSettings.fmtExt = {};
			for (var p in this._dynFormats) {
				var dynFmt = this._dynFormats[p];
				var res = {};
				if (dynFmt.complement != null) {
					res.stdType = dynFmt.complement.split('');
				}
				if (dynFmt.subType != null) {
					res.chars = dynFmt.subType.split('');
				}
				this._sessionSettings.fmtExt[p] = res;
			}
			if (!this._sessionSettings.mnu || this._sessionSettings.mnu.length === 0) {
				// Add menus only if received
				// !! Reuse session - We must store menus received at first connexion
				this._sessionSettings.mnu = lists.SESSIONMNU;
			}
			response.session.settings = this._buildUiClientSettings();
		} else {
			if (!this._sessionSettings.mnu || this._sessionSettings.mnu.length === 0) {
				// Add menus only if received
				// !! Reuse session - We must store menus received at first connexion
				this._sessionSettings.mnu = lists.SESSIONMNU;
				response.session.settings = this._buildUiClientSettings();
			}

		}


		response.srvop = {};
		// request object
		var aRqst = this.activeRequest.sendContext;
		response.srvop.request = {
			"id": aRqst.reqNum,
			"v": this.activeRequest.reply.actionId,
			"rqtdist": aRqst.target,
			"connect": 1,
			"status": this.activeRequest.status,
			"session": this.sessionId,
			"server": os.hostname()
		};
		for (i = 0; i < lists.DIAGNOSE.length; i++) {
			response.srvop.$diagnoses = response.srvop.$diagnoses || [];
			response.srvop.$diagnoses.push(JSON.parse(JSON.stringify(lists.DIAGNOSE[i])));
		}
		for (i = 0; i < lists.GLDIAGNOSE.length; i++) {
			response.sap.$4glDiagnoses = response.srvop.$4glDiagnoses || [];
			response.sap.$4glDiagnoses.push(JSON.parse(JSON.stringify(lists.GLDIAGNOSE[i])));
		}

		timing.end();
		var t = timing.getTiming();
		response.toJsonTime = t ? t.duration : 0;
		t && this.activeRequest.timing.server.response.push(t);
		// add sessionInfo
		if (true === connect) {
			// Add session info at connection
			response.srvop.sessionInfo = {
				reused: this.reused,
				nodeWS: this.sessInfo.nodeWS,
				node: this.sessInfo.node,
				runtime: this.sessInfo.runtime
			};
			response.srvop.sessionInfo.runtime.folder = this.clientConfig.getParam("x3Folder");
		}
		if (localConfig.perfmon) {
			this._calculTiming(this.activeRequest.timing);
			response.timing = this.activeRequest.timing;
		}
		return response;
	}
});