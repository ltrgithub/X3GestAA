"use strict";
var helpers = require('syracuse-core/lib/helpers');
var locale = require("syracuse-core/lib/locale");
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var date = require('syracuse-core/lib/types/date');
var automata = require("syracuse-x3/lib/convergence/automata/x3Automata");
var CvgClientConfig = require("syracuse-x3/lib/convergence/model/CvgClientConfig").CvgClientConfig;
var CvgModifier = require('syracuse-x3/lib/convergence/model/CvgModifier').CvgModifier;
var CvgEntity = require('syracuse-x3/lib/convergence/model/CvgEntity').CvgEntity;
var CvgStackedWindows = require('syracuse-x3/lib/convergence/model/CvgStackedWindows').CvgStackedWindows;
var CvgStackedWindow = require('syracuse-x3/lib/convergence/model/CvgStackedWindow').CvgStackedWindow;
var CvgReply = require('syracuse-x3/lib/convergence/client/CvgReply').CvgReply;
var CvgRequest = require('syracuse-x3/lib/convergence/client/CvgRequest').CvgRequest;
var CvgInstance = require('syracuse-x3/lib/convergence/model/CvgInstance').CvgInstance;
var CvgMenuAct = require('syracuse-x3/lib/convergence/model/CvgMenuAct').CvgMenuAct;
var CvgMenuCtx = require('syracuse-x3/lib/convergence/model/CvgMenuCtx').CvgMenuCtx;
var CvgDataSrc = require('syracuse-x3/lib/convergence/model/CvgDataSrc').CvgDataSrc;
var CvgDataSrcLine = require('syracuse-x3/lib/convergence/model/CvgDataSrcLine').CvgDataSrcLine;
var CvgVariable = require('syracuse-x3/lib/convergence/model/CvgVariable').CvgVariable;
var CvgIst = require('syracuse-x3/lib/convergence/types/CvgIst').CvgIst;
var CvgResu = require('syracuse-x3/lib/convergence/types/CvgResu').CvgResu;
var CvgAction = require('syracuse-x3/lib/convergence/client/CvgAction').Actions;
var CvgSuperAction = require('syracuse-x3/lib/convergence/client/CvgAction').SuperActions;
var ActionDescriptors = require('syracuse-x3/lib/convergence/client/CvgAction').Descriptors;
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var formatter = require('syracuse-x3/lib/formatter/format');
var CONNECT_ACTION = require('syracuse-x3/lib/convergence/client/CvgAction').CONNECT_ACTION;

var util = require('util');

var traceAction = nodeconfig.config && nodeconfig.config.x3fusion && nodeconfig.config.x3fusion.actions && nodeconfig.config.x3fusion.actions.trace;


var CFormatterJS = exports.CFormatterJS = helpers.defineClass(function(settings) {
	var self = this;
	this.dateOrder = 1; // TODO get it from somewhere
	this.settings = settings || {};
}, null, {
	razModifications: function() {
		// TODO: reset dynamic formats and month names
	},
	setNewDynamicFormat: function(type, subtype, complement) {
		//throw new Error("dynamic format NIY " + arguments);
	},
	isValid: function() {
		return true;
	},
	formatField: function(format, value, raw) {
		if (!format) return "" + value;

		if (!nodeconfig.config.x3fusion.useJsFormatter) {
			if (format && format.format[0] === 'D' && value) {
				// quick hack to handle dates
				return value.substring(6) + "/" + value.substring(4, 6) + "/" + value.substring(0, 4);
			}
			// quick hacks to handle CvgDecimal "0"
			if (value === "0" && format && format.format.substring(0, 3) === "N+z") return "";
			if (value === "0" && format && format.format.substring(0, 2) === "Nz") return "";
			return "" + value;
		}


		switch (format.format[0]) {
		case 'D':
			var y, m, d, str;
			var parts = value.split(/[^\d]/);
			// ignore raw if parts.length == 2, so that 20/02 gets handled as DD/MM when raw is true
			if ((raw && parts.length !== 2) || this.settings.dateOrder === 'YMD') {
				if (parts.length > 1) {
					y = parseInt(parts[0] || '0', 10);
					m = parseInt(parts[1] || '0', 10);
					d = parseInt(parts[2] || '0', 10);
				} else {
					if (value.length <= 4) {
						y = parseInt(value || '0', 10);
						m = 0;
						d = 0;
						if (y < 1900 || y >= 2200) {
							// reinterpret as YYMM if year does not look valid
							m = y % 100;
							y = Math.floor(y / 100);
						}
					} else if (value.length <= 6) {
						y = parseInt(value.substring(0, 2) || '0', 10);
						m = parseInt(value.substring(2, 4) || '0', 10);
						d = parseInt(value.substring(4) || '0', 10);
					} else {
						y = parseInt(value.substring(0, 4) || '0', 10);
						m = parseInt(value.substring(4, 6) || '0', 10);
						d = parseInt(value.substring(6) || '0', 10);
					}
				}
			} else {
				if (parts.length > 1) {
					d = parseInt(parts[0] || '0', 10);
					m = parseInt(parts[1] || '0', 10);
					y = parts[2] != null ? parseInt(parts[2], 10) : new Date().getFullYear();
				} else {
					if (value.length <= 4) {
						// weird: interpret as MM/YY rather than DD/MM or MM/DD
						d = 0;
						m = parseInt(value.substring(0, 2) || '0', 10);
						y = parseInt(value.substring(2, 4) || '0', 10);
					} else {
						d = parseInt(value.substring(0, 2) || '0', 10);
						m = parseInt(value.substring(2, 4) || '0', 10);
						y = parseInt(value.substring(4) || '0', 10);
					}
				}
				if (this.settings.dateOrder === 'MDY' && d !== 0) { // d test to avoid swap in valude.length <= 4 case
					var tmp = d;
					d = m;
					m = tmp;
				}
			}
			if (y < 100 && value.length > 0) {
				var century = Math.floor(new Date().getFullYear() / 100) * 100;
				y = century + y;
				if (y - 100 >= this.settings.datePivot) y -= 100;
			}
			if (y === 1599 && m === 12 && d === 31) value = date.make(0, 0, 0);
			else value = date.make(y, m, d);
			break;
		case 'N':
			if (!raw) {
				if (this.settings.thousandsChar) value = value.split(this.settings.thousandsChar).join('');
				if (this.settings.decimalChar !== '.') value = value.split(this.settings.decimalChar).join('.');
			}
			break;
		}
		console.log("value: " + value);
		return formatter.format(this.settings, format.format, value);
	},
	inputGetFocusInValue: function(format, val) {
		return val;
	},
	inputGetFocusOutValue: function(format, val) {
		return val;
	},
});

var CDynFormat = exports.CDynFormat = helpers.defineClass(function(aType, aFormater) {
	this.complement = null;
	this.subType = null;
	this.type = aType;
	this.formater = aFormater;
}, null, {
	createInFormater: function() {
		this.formater.setNewDynamicFormat(this.type, this.subType, this.complement);
	},
	hasSubType: function() {
		return this.subType != null;
	},
	setComplement: function(aComplement) {
		this.complement = aComplement;
	},
	setSubType: function(aSubType) {
		this.subType = aSubType;
	},

	/*
	 * c": { "stdType": ["A", "#"], "chars": ["", "-", "/", "_", ","] },
	 */
	toJSon: function() {
		var dynFmt = {};
		if (this.complement != null) {
			dynFmt.stdType = this.complement.split('');
		}
		if (this.subType != null) {
			dynFmt.chars = this.subType.split('');
		}
		return dynFmt;
	}
});

var CModifiableFinder = exports.CModifiableFinder = helpers.defineClass(function() {
	CvgModifier.call(this);
	this.foundModifiable = null;
}, CvgModifier, {
	setModifiable: function(aStructIst, aModifiable) {
		this.foundModifiable = aModifiable;
		this.done = true;
		return this.done;
	}
});

var CMotherWindow = exports.CMotherWindow = helpers.defineClass(function(aClient) {
	CvgEntity.call(this, aClient, "&ROOT", 1, 'WINDOW');
}, CvgEntity, {
	getAdxId: function() {
		return "mostherWindow - &ROOT";
	},
	toJson: function() {
		throw new Error("Bad tojson MotherWin");
	}
});


// move this to Reader class

function formatKeyValues(result) {
	return [Object.keys(result).map(function(key) {
		return key + '=\u0001' + result[key] + '\n';
	})];
}

function checkLen(list, len) {
	if (list.length !== len) throw new Error("bad list length: " + list.length);
}

var SRVOP = {
	"request": {
		"id": 0,
		"v": 0,
		"session": "484cdda6-6a94-4a71-8fe3-578beb12c47a_381272274",
		"status": 0,
		"server": "172.28.8.146"
	},
	"sessionInfo": {
		"cnxid": "33589530-662c-4d82-9a19-0ba6fd0c8aaa_381272274",
		"sessid": "484cdda6-6a94-4a71-8fe3-578beb12c47a_381272274",
		"runtime": {
			"folder": "SYDEV",
			"port": 16667,
			"x3profile": "ADMIN",
			"host": "172.28.20.117",
			"http": "http://aydaix05.sagefr.adinternal.com:80/Adonix_SYDVLP",
			"x3user": "APISU",
			"lang": "FRA"
		},
		"bridge": {
			"port": 27080,
			"config": {
				"jettyPort": "18880",
				"host": "172.28.8.146",
				"systembits": "64",
				"installfix": "1",
				"data": "/home/pisua/.git_repo/x3kilo/com.sage.x3.simulator/bridge/data",
				"builddate": "unknown",
				"installversname": "KILO",
				"systemarch": "",
				"installvers": "SAFE X3 JAV",
				"tools": "/home/pisua/.git_repo/x3kilo/com.sage.x3.simulator/bridge/tool",
				"sdataPort": "27080",
				"systemtype": "windows",
				"installminor": "1",
				"installpatch": "115",
				"installversnum": "16j"
			},
			"ipserver": "172.28.8.146",
			"ipclient": "aysyrsydev.sagefr.adinternal.com"
		},
		"reused": false,
		"node": {
			"proto": "http://172.28.20.117:80/Adonix_SYDVLP/SYDEV/GEN/SYR/FR-FR/FENJ",
			"fusion": "http://172.28.8.146:27080/sdata/x3/trans/-",
			"sessSettings": {
				"auth": "basic",
				"key": "syracuse.sid",
				"timeout": 20,
				"checkInterval": 300
			},
			"x3user": "apisu",
			"x3host": "172.28.20.117",
			"x3port": 16667,
			"x3name": "",
			"gitlastmodif": "Mon Jan 21 2013 11:05:16 GMT+0100 (Paris, Madrid)"
		}
	},
	"tech": {
		"timExec": 3133.922,
		"x3open": 3133.759
	}
};

var serializers = {
	I: function(val) {
		if (!(val instanceof CvgIst)) throw new Error("action parameter type mismatch, expected IST, got " + val);
		return val.getBytes();
	},
	U: function(val) {
		if (typeof val !== 'string') throw new Error("action parameter type mismatch, expected string, got " + typeof val);
		var len = Buffer.byteLength(val, 'utf8');
		var buf = new Buffer(len + 4);
		buf.writeInt16BE(len, 0);
		buf.writeInt16BE(val.length, 2);
		buf.write(val, 4, len, 'utf8');
		return buf;
	},
	D: function(val) {
		console.log(val);
		if (!Array.isArray(val)) throw new Error("action parameter type mismatch, expected array, got " + typeof val);
		var countBuf = new Buffer([val.length]);
		var valsBuf = Buffer.concat(val.map(function(v) {
			return v.getBytes();
		}));
		//console.log("VALSBUF=" + valsBuf.toString('hex'));
		return Buffer.concat([countBuf, valsBuf]);
	},
	S: function(val) {
		if (typeof val !== 'number') throw new Error("action parameter type mismatch, expected number, got " + typeof val);
		return new Buffer([(val >> 8) & 0xff, val & 0xff]);
	},
	L: function(val) {
		if (typeof val !== 'number') throw new Error("action parameter type mismatch, expected number, got " + typeof val);
		return new Buffer([(val >> 24) & 0xff, (val >> 16) & 0xff, (val >> 8) & 0xff, val & 0xff]);
	},
}

function serializeActionParams(act, params) {
	var desc = ActionDescriptors[act] || {name: 'APPLICATIVE ACTION ' + act, params: ''};
	//if (!desc) throw new Error("action descriptor not found: " + act);
	//console.log("ACTION=" + desc.name);
	//console.error("SERIALIZE PARAMS="+JSON.stringify(params,null,2));
	if (desc.params === '?') throw new Error("params serialization missing for " + desc.name + " (count got: "+params.length+")");
	if (desc.params.length !== params.length) console.error("WARNING: " + desc.name + ": param count mismatch: expected " + desc.params.length + ', got ' + params.length);

	return Buffer.concat(params.slice(0,desc.params.length).map(function(param, i) {
			var fn = serializers[desc.params[i]];
			if (!fn) throw new Error(desc.name + ": unknown serializer: " + desc.params[i]);
			var res = fn(param);
			return res;
	}));
}

var CvgClient = exports.CvgClient = helpers.defineClass(function(stream, adxInfos, aConfig, aType) {
	this.stream = stream;
	this.adxInfos = adxInfos;
	this.clientConfig = new CvgClientConfig(aConfig);
	this.isInteractiveSession = this.clientConfig.isInteractiveSession();
	this.trackLists = this.newTrackLists();
	this.sessionSettings = {};
	this.appSrvSessionSettings = {};
	this.srvop = SRVOP;
	this.maxTimeBeforeAutomaticHangUp = -1;
	this.maxTimeBeforeHangUp = -1;
	this.activeRequest = null;
	this.adxIstsOfPickedLines = [];
	this.affSynchroneMessages = [];
	this.applicationID = null;
	this.sessDynFormat = [];

	this.currentDynFormat = null;
	this.formater = null;
	this.logicalErrorMessage = null;
	this.uuid = null;

	this.config = aConfig;
	this.initFormater();
	this.motherWindow = new CMotherWindow(this);
	this.stackedWindows = new CvgStackedWindows();
	this.withLogicalErrDetails = false; //this.clientConfig.getBoolParam(CAdonixConfig.WITH_LOGICAL_ERR_DETAILS);
	// added by BRJOU - open not called any more
	this.newActiveRequest(new CvgReply(this, CONNECT_ACTION), null, null);
	this.connected = false;
}, null, {
	newTrackLists: function() {
		return {
			SESSION: [],
			ACT: [],
			TARGETACT: [],
			SESSIONMNU: [],
			TARGET: [],
			PREVIOUS: [],
			ENTITY: [],
			FUNC: [],
			RPC: [],
			WINDOW: [],
			DIAGNOSE: [],
		};
	},
	start: function(_) {
		this.connected = true;
		automata.process(_, this);
		return this.getResponse();
	},
	actionParams: function(body) {
		// params passed to listenSendingArgs are [action, ist (or null ist), params added by append2ActionParams]
		var params = [body.act];
		if (!body.param) return params;
		var target = body.param.target;
		if (target && target.xid != null) {
			params.push(new CvgIst(this.targetToXid(target)));
		}
		if (body.param.std) params = params.concat(body.param.std);
		return params;
	},
	processAction: function(_, body) {
		traceAction && traceAction("************************************");
		traceAction && traceAction("Begin Process Action:\n" + JSON.stringify(body, null, 2));

		// improve: see getActionsParamsToSend FDB in CSDataPayloadFusionRequest.java
		// Sanity checks
		// Create fresh request/reply objects
		var reply = new CvgReply(this, body.act);
		var ctx;
		if (body.param && body.param.target){
			var target = body.param.target;
			if (target && target.xid != null) {
				ctx = new CvgIst(this.targetToXid(target));
			}
		}
		
		this.newActiveRequest(reply, null, {"ctxNDSLB": ctx});

		var resu, extras = [];
		if (body.fld) {
			if (body.fld.v){
				if (!body.fld.ist) {
					var type = typeof body.fld.v === 'string' ? CvgResu.TDO_ALPHA : CvgResu.TDO_INT;
					resu = CvgResu.fromAction(type, body.fld.v);
	
				}else{
					// Retrieve the instance to obtain the data type of the action's resu
					var ist = CvgIst.fromAction(body.fld.ist);
					traceAction && traceAction("ACTION IST=" + JSON.stringify(ist,null,2));
					var entity = this.findModifiable(ist);
					//console.log("ACTION ENTITY=" + util.inspect(entity));
					//if (entity == null) throw new Error("modifiable not found: " + JSON.stringify(body));
					if (entity && entity instanceof CvgVariable) {
						if (entity.dataType == null) throw new Error("data type not found: " + JSON.stringify(body));
	
							
						try {
							if (entity.acceptEditFormat() && body.fld.fmtKind === 'EDIT') {
								// deformatage : format edition => format presentation. Peut
								// lever une exception de formatage ou de valorisation
								var value = entity.formatEditToDisplay(body.fld.v);
	
								// ajout d'un noeud "ist" "previous" avec la valeur reformatee.
								// Exemple : <ist which="previous" C="B,B,B5" format="show"
								// IstFmt="N+:5.5#">0,02000</ist>
								this.activeRequest.reply.addInstance(CvgInstance.newprevious(this, ist, entity.format.format, value, this.activeRequest.reply == null ? false : this.activeRequest.reply.stayInCommandMode));
							}

						} catch(e) {
							console.error("Err: "+e.stack);
							// Récupération de l'erreur de formatage pour info client
							var instance = CvgInstance.newtarget(this, ist, entity.format.format, body.fld.v, this.activeRequest.reply == null ? false : this.activeRequest.reply.stayInCommandMode);
							instance.exception = e;
							this.activeRequest.reply.addInstance(instance);
						}
						// Build the resu and serialize it
						resu = CvgResu.fromAction(entity.dataType, body.fld.v);
					}
				}
			}
			// Build the list of extra results to send after the first one
			// For only one optional extra: crsr (cursor position)
			// TODO: crsr is serialized directly as an int, not as a resu.
			var crsr = body.fld.ctx && body.fld.ctx.crsr;
			if (crsr != null) extras.push(new CvgResu(CvgResu.TDO_INT, parseInt(body.fld)));
		}
		if (!resu) resu = new CvgResu(CvgResu.TDO_NULL);

		
		
		// get action params (action is recorded into params[0])
		var params = this.actionParams(body);
		this.activeRequest.listenSendingArgs(body.act, this, params);
		//this.activeRequest.buildIstDatasOfAction(params[0]);
		
		// send the action to X3
		this.sendAction(_, resu, extras, params);

		//CvgClient.checkFailed
		// run automata to get callbacks from X3 engine and return response
		automata.process(_, this);
		var resp = this.getResponse();
		traceAction && traceAction("************************************");
		traceAction && traceAction("End Process Action:\n" + JSON.stringify(resp, null, 2));
		return resp;
	},
	sendAction: function(_, resu, extras, params) {
		// see CSDataPayloadFusionRequest/getActionsParamsToSend (FDB comment)

		
		
		// serialize resu
		var resuBuf = resu.getBytes();

		// serialize the number of extras on 1 byte + the extras
		var extrasLenBuf = new Buffer([extras.length]);
		var extrasBuf = Buffer.concat(extras.map(function(extra) {
			return extra.getBytes();
		}));

		// serialize the action on 2 bytes
		var act = params[0];
		var actBuf = new Buffer([(act >> 8) & 0xff, act & 0xff]);

		//if (params.length > 2) params = params.slice(0, 2).concat([params.slice(2)]);
		var paramsBuf = serializeActionParams(act, params.slice(1));
		//console.log("PARAMS: " + paramsBuf.toString('hex'));
/*
		// slice to skip first act param.
		// convert the other parameters (optional ist from param.target + param.std) to string resus and serialize them
		var paramsBuf = Buffer.concat(params.slice(1).map(function(p, i) {
			return new CvgResu(CvgResu.TDO_ALPHA, p).getBytes();
		}));*/

		// serialize length (2 bytes for action + size of its params)
		var lenBuf = new Buffer(2);
		lenBuf.writeInt16BE(2 + paramsBuf.length, 0);

		// concatenate all the pieces and send it
		var data = Buffer.concat([resuBuf, extrasLenBuf, extrasBuf, lenBuf, actBuf, paramsBuf]);
		//console.log("SENDING: " + data.toString('hex'));
		this.stream.write(_, data);
	},
	processSuperAction: function(_, body) {
		traceAction && traceAction("===================================");
		traceAction && traceAction("Process Super Action:\n" + JSON.stringify(body, null, 2));
		//console.error("SuperAction ID: " + body.act);
		var superAction;
		for (var i in CvgSuperAction) {
			if (CvgSuperAction[i].code === body.act) {
				superAction = CvgSuperAction[i];
				break;
			}
		}
		if (!superAction) throw new Error("Bad super action [" + body.act + "]");
		//console.error("SUPER ACTION: "+JSON.stringify(superAction,null,2));
		
		var std = [];
		if (body.param && body.param.sudo) {
			for (var i in body.param.sudo)
				std.push(body.param.sudo[i]);
			delete body.param.sudo;
		}
		
		
		var resp, nextFld;
		for (var i = 0; i < superAction.actions.length; i++) {
			var newBody = JSON.parse(JSON.stringify(body));

			var action = superAction.actions[i];
			//console.error("Process Action: "+JSON.stringify(action,null,2));
			if (!CvgAction[action.name]) throw new Error("Bad sub-action: " + action.name);

			var processNext = true;
			newBody.act = CvgAction[action.name];		
			
			if (nextFld) {
				newBody.fld.ist = nextFld.ist;
				newBody.fld.v = nextFld.v;
			}
			
			if (!action.setTarget) {
				traceAction && traceAction("DELETE TARGET !!!");
				delete newBody.param.target; 
			}
			
			if (std[i])
				newBody.param.std = std[i];

			resp = this.processAction(_, newBody);
			resp = JSON.parse(JSON.stringify(resp)); // invoke toJSON methods -- improve later
			//console.error("Resp: "+JSON.stringify(resp,null,2));
			var t1 = resp.sap && resp.sap.target && resp.sap.target.type === 'ist' && resp.sap.target.ist;
			if (!t1) break;
			if (action.setTarget) {
				var t0 = newBody.param && newBody.param.target;
				processNext = superAction.processNextAction(CvgAction[action.name], t0, t1, action.checkNumLine);
			}
			//console.error("Process Next: "+processNext);
			if (!processNext) {
				break;
			}else{
				var respTarget = resp.sap.target.ist;
				if (respTarget){
					nextFld = {
						ist: {
							xid: respTarget.xid,
							win: respTarget.win
						},
						v: respTarget.v
					}
					if (respTarget.nl)
						nextFld.ist.nl = respTarget.nl;
				}
			}
				
		}
		return resp;
	},
	processRequest: function(_, body) {
		if (body.act > 1024) return this.processAction(_, body);
		else return this.processSuperAction(_, body);
	},
	targetToXid: function(target) {
		var xid0index = target.xid[0];
		if (xid0index === 'b') xid0index = "AH";
		var xid = target.win + ',' + xid0index + ',' + target.xid.substring(1);
		if (target.nl != null && target.nl != "-1") xid += ',' + target.nl;
		return xid;
	},
	getMessage: function() {
		var args = [module, arguments[0]];
		for (var i = 1; i < arguments.length; i++){
			args.push(arguments[i] ? arguments[i].toString() : arguments[i]);
		}
		var res = locale.format.apply(null, args);
		console.error(res);
		return res;
	},
	addAdxIstOfPickedLines: function(aPickedLine) {
		this.adxIstsOfPickedLines.add(aPickedLine);
	},
	addLogicalErrorMess: function(aObject, aMethod, aIst, aMessage) {
		throw new Error(aMessage);
		if (this.hasActiveRequest()) {
			this.activeRequest.reply.addLogicalErrorMess(aObject, aMethod, aIst, aMessage);
		} else {
			if (this.logicalErrorMessage == null) {
				var wMess = this.getMessage('ERROR_LOGICAL');
				this.logicalErrorMessage = new CvgMessage(CvgReply.WEBSERVER, this, wMess, false);
			}
			this.logicalErrorMessage.addWebServerLogicalMess(CvgReply.buildLogicalErrorMess(aObject, aMethod, aIst, aMessage));
		}
	},
	addStatusIconDef: function(instance, aNumText, aTxt, aImgId, aActionId) {
		var winFound = null;
		for (var i = 0; i < this.stackedWindows.length && winFound == null; i++) {
			var item = this.stackedWindows[i];
			if (item.getAdxIst().winAlphaId === instance.winAlphaId) {
				winFound = item;
			}
		}
		if (winFound != null) {
			winFound.addStatusIconDef(instance, aNumText, aTxt, aImgId, aActionId);
		}
	},
	changePivotDate: function(prop) {
		try {
			this.formater.setUserDateFormat(this.config.uiParamIDATE, this.config.uiParamSEPDATE, parseInt(prop.strValue));
		} catch (e) {
			throw new Error("Bad pivot date", e);
		}
		setOneSessionSetting(prop.id, prop.strValueNotNull);
	},
	changeUserContext: function(aAguments) {
		TODO_SUPER.changeUserContext(aAguments);
		if (this.hasActiveRequest()) {
			var reply = this.activeRequest.adonixReply;
			if (reply.hasChangedAdonixLang()) {
				setCacheContext(reply.changedAdonixLang);
			}
		}
	},
	clearAdxIstsOfPickedLines: function() {
		this.adxIstsOfPickedLines.clear();
	},
	// CLoseSocket
	closeClient: function(fromSameThread, e, reason) {
		console.log("CloseClient FusionAdapi Client\n\tReason[" + reason + "]\n\tAlreadyClosed[" + (this.connClient == null || !this.connClient.hasSocket()) + "] - Exception[" + (e == null ? "No" : e.message) + "]");
		//new CvgClose
		//TODO_SUPER.closeClient(fromSameThread, e, reason);
	},
	configFormater: function() {
		console.log("FORMATTER NIY");
		return;
		/*
		 * 0 (mm/jj/aa) si DATE_FORMAT_KEY = 21 ou 22 1 (jj/mm/aa) si
		 * DATE_FORMAT_KEY = 11 ou 12
		 *
		 * MDY=0, DMY=1, YMD=2 => (1, "/", 1950).
		 */
		var wDateOrder = this.config.uiParamIDATE;
		var wDateSep = this.config.uiParamSEPDATE;
		var wPivotDate = this.config.uiParamPIVOTDATE;
		this.formater.setUserDateFormat(wDateOrder, wDateSep, wPivotDate);
		this.formater.setUserDecimalSep(this.config.uiParamSEPDECIMAL);
		this.formater.setUserThousandSep(this.config.uiParamSEPTHOUSAND);
		// pour optilmiser le flux xml vers le browser: suprime les espaces de cadrage a droite pour les valeur alpha.
		this.formater.setVOn(this.config.getFormaterVon());
		this.formater.setZOn(true);
	},
	// retourne vrai si la liste de propri�t� contient la propriete
	containsAdxPubSubFile: function(aListOfProperties) {
		var wProperty;
		var wMax = aListOfProperties.length;
		var wI = 3; // pour demarer a la 4eme propriete !
		while (wI < wMax) {
			wProperty = aListOfProperties.get(wI);
			if (wProperty.hasId() && wProperty.id.toUpperCase() === "UIAdxPubSubFile".toUpperCase()) {
				return true;
			}
			wI++;
		}
		return false;
	},
	// Demande d'une déconnexion au serveur X3
	deconnectClient: function(reason) {
		try {
			console.log("Deconnect client\n\tReason[" + (reason == null ? "none" : reason) + "]\n\tAsk X3 server to close ");
			return checkFailed(deconnect(new CvgReply(this, CvgAction.SRV_FIN_APPL)), "X3 deconnexion failed");
		} finally {
			realeaseActiveRequest();
		}
	},
	execCallUi: function(values) {
		if (values.UIAction === "SessionSettings") {
			return this.executeAllSessionSettings(values);
		} else if (values.UIAction === "SetWindFeatures") {
			return this.executeAllSessionSettings(values);
		} else if (values.UIAction === "Sethangup") {
			return this.executeCallUiSetHangHup(values);
		} else if (values.UIAction === "SetTechnoVers") {
			return this.executeCallUiSetTechnovers(values);
		} else if (values.UIAction === "GetFileAlways") {
			return this.executeCallUiGetFile(true, values);
		} else if (values.UIAction === "GetFile") {
			return this.executeCallUiGetFile(false, values);
		} else if (values.UIAction === "PutFileAlways") {
			return this.executeCallUiPutFile(true, values);
		} else if (values.UIAction === "PutFile") {
			return this.executeCallUiPutFile(false, values);
		} else if (values.UIAction === "OpenFile") {
			return this.executeCallUiOpenFile(values);
		}
	},
	executeAllSessionSettings: function(values) {
		var keys = Object.keys(values);
		for (var i = 1; i < keys.length; i++) {
			//console.error("Set sessionSettings: "+keys[i]+" ["+values[keys[i]]+"]");
			this.appSrvSessionSettings[keys[i]] = values[keys[i]];
		}
		return {
			UIAction: "SessionSettings"
		};
	},
	executeCallUiSetTechnovers: function(values) {
		// TODO manage protocol negociation
		this.executeAllSessionSettings(values);
		return values;
	},
	executeCallUiSetHangHup: function(values) {
		if (values.UITimehangup1) this.maxTimeBeforeHangUp = values.UITimehangup1 < 1 ? -1 : values.UITimehangup1;
		if (values.UITimehangup2) this.maxTimeBeforeAutomaticHangUp = values.UITimehangup2 < 1 ? -1 : values.UITimehangup2;
		return {
			Sethangup: 1
		};
	},
	/*
	 * Demande au serveur UI d'ouvrir un fichier. si le paramere "UILocalDir"
	 * contient HTTP, c'est pour ouvrir un fichier via IE
	 *
	 * Exemples : <ul> <li>0= id=[UIAction] value=[OpenFile]</li> <li>1=
	 * id=[UILocalDir] value=[HTTP]</li> <li>2= id=[UILocalFile]
	 * value=[172.16.12
	 * .41:80/x3webdata/GX3APP/TMP/F5963808_EDITRTWEB_53711.xml]</li> <li>3=
	 * id=[ADXPUB_SubFile] value=[1]</li> </ul>
	 *
	 * Ce CallUi est employe pour ouvrir des exports xml ou excel
	 *
	 * <pre> "UIAction="+chr$(1)+"OpenFile", "UILocalDir="+ chr$(1) +"HTTP",
	 * "UILocalFile="+ chr$(1) +"www.meteo.fr/"
	 *
	 * "UIAction="+chr$(1)+"OpenFile", "UILocalDir="+ chr$(1) +"tmp",
	 * "UILocalFile="+ chr$(1) +"test.txt" </pre>
	 */
	executeCallUiOpenFile: function(aListOfProperties) {
		var wMax = aListOfProperties.length;
		if (wMax > 2) {
			var wLocalDir = aListOfProperties.get(1).strValue;
			var wLocalFile = aListOfProperties.get(2).strValue;

			var wUrl = "";
			/*
			 * si UILocalDir == "HTTP", alors UILocalFile contient un URL
			 */
			if (wLocalDir === "HTTP") {
				wUrl.append(translateLocalFileUrl(wLocalFile, aListOfProperties));
			}
			/*
			 * sinon, et UILocalFile sont des chemins et un nom de
			 * fichier relatifs au dossier HOME de l'utilisateur
			 */
			else {
				wUrl += this.clientConfig.params[CvgClientConfig.USERHOMEVIRTUALPATH];
				wUrl += '/';
				wUrl += wLocalDir;
				wUrl += '/';
				wUrl += wLocalFile;
			}
			var wReply = this.activeRequest.adonixReply;
			var wCallUiOpenFile = wReply.addAskOpenFile(wUrl.toString());
			var wProperty;
			var wPropertyId;
			var wI = 3;
			while (wI < wMax) {
				wProperty = aListOfProperties.get(wI);
				wPropertyId = wProperty.id;
				if (wPropertyId !== "UILocalDir" && wPropertyId !== "UILocalFile") {
					wCallUiOpenFile.addOneParam(wPropertyId.toLowerCase(), wProperty.strValue);
				}
				wI++;
			}
		}
		return CAdonixCallUiReply.OK;
	},
	findModifiable: function(aStructIst) {
		var wSettableFinder = new CModifiableFinder();
		this.traverseSettable(aStructIst, wSettableFinder);
		return wSettableFinder.foundModifiable;
	},
	getNewStackedWindows: function(aWindowId, aFunctionId, aDescr, aStamp, aWindowIdxBaseOne) {
		return new CvgStackedWindow(this, aWindowId, aFunctionId, aDescr, aStamp, aWindowIdxBaseOne);
	},
	hasActiveRequest: function() {
		return this.activeRequest != null;
	},
	hasApplicationId: function() {
		return this.applicationID != null;
	},
	hasValidFormater: function() {
		return this.formater != null && this.formater.isValid();
	},
	initResources: function(aLanguage) {},
	initFormater: function() {
		this.formater = new CFormatterJS();
		this.configFormater();
	},
	initSessionWeight: function(aAdonixContext, aSessionWeight) {
		aAdonixContext.setX3SessionWeight(aSessionWeight);
	},
	isUrlPortalSessionSetting: function(aId) {
		return aId.toLowerCase().startsWith("PortalUrl".toLowerCase());
	},
	isWithLogicalErrDetails: function() {
		return this.withLogicalErrDetails;
	},
	listenException: function(e) {
		if (this.hasActiveRequest()) {
			this.activeRequest.reply.setStatusNOTOK(e);
		}
		return true;
	},
	listenLogicalErr: function(aObject, aMethode, aMessage) {
		if (isWithLogicalErrDetails()) {
			this.addLogicalErrorMess(aObject, aMethode, "", aMessage);
		}

	},
	// Connection messages
	listenNodeND_SLF: function(_, reader, node, properties) {
		checkLen(properties, 1);
		var values = properties[0];
		var result = this.execCallUi(values);
		return formatKeyValues(result);
	},
	listenNodeND_GFD: function(_, reader, node, lines) {
		checkLen(lines, 1);
		var key = lines[0];
		var result = {}
		result[key] = this.clientConfig.params[key];
		if (result[key] === undefined) {
			result[key] = key + " : unsupported param";
		}
		return formatKeyValues(result);
	},
	listenNodeNDCOPMENU: function(_, reader, node, data) {
		//reply.setSplashInfos(data);
	},
	listenNodeNDDEB: function(_, reader, node) {},

	listenNodeND_CLT: function(_, reader, node, dummyByte) {
		// 15w_001 - Fiche 36012 - X3Client: Supervision des sockets
		// Si réception du noeud ND_CLT non attendu => not ok fermeture du
		// client depuis le même thread
		this.closeClient(true, null, "listenNodeND_CLT");
	},
	/**
	 * NDACTOBJ (Adxcpl_displayWin) Affichage d'une fenetre Id=[NDACTOBJ]
	 * x3func=[Adxcpl_displayWin] NbArgs=[2] - ist =[ win=[2] srn=[0] blc=[0]
	 * fld=[0] idx=[0]] - opt=[.x04]
	 */
	listenNodeNDACTOBJ: function(_, reader, node, ist, num) {
		var WIN_NOHIDDEN = 4;
		if (num > WIN_NOHIDDEN) {
			var win = findModifiable(ist);
			if (win != null && win instanceof CvgStackedWindow) {
				win.setScreenToShow(num - WIN_NOHIDDEN + 1);
			}
		} else {
			// TODO
		}
	},

	/**
	 * NDACTOP 0E4000 (Activation_Action) Activation d=[NDACTOP] level=[?]
	 * x3func=[Activation_Action] nb=[2] - ide=[2823] ID Action - typ=[.x01]
	 * Status
	 */
	listenNodeNDACTOP: function(_, reader, node, wActionId, wFlag) {
		new CvgMenuAct(this, wActionId, wFlag);
	},

	/**
	 * Le serveur envoi 3 noeuds ndctsu pour d�crire un format dynamique. voir
	 * l'innerclasse "CDynFormat" Id=[NDCTSU] level=[C]
	 * x3func=[Control_DefineType] NbArgs=[3] - opt=[.x65] - su1 =[c] - su2 =[_]
	 */
	listenNodeNDCTSU: function(_, reader, node, wType, wSubType, wComplement) {
		/*
		 * Traite le premier noeud NDCTSU contenant le type. Exemple: Type=[g]
		 * SubType=[] Complement=[] Le noeud correspondant: Id=[NDCTSU]
		 * func=[Control_DefineType] NbArgs=[3] opt=[.x67] su1 =[] su2 =[])
		 */
		if (this.currentDynFormat == null) {
			this.currentDynFormat = new CDynFormat(String.fromCharCode(wType), this.formater);
			this.sessDynFormat.push(this.currentDynFormat);
		}
		/*
		 * Traite le deuxieme noeud NDCTSU contenant le SubType. Exemple:
		 * Type=[g] SubType=[AX] Complement=[] Le noeud correspondant:
		 * Id=[NDCTSU] func=[Control_DefineType] NbArgs=[3] opt=[.x67] su1 =[AX]
		 * su2 =[]
		 */
		else if (!this.currentDynFormat.hasSubType()) {
			this.currentDynFormat.setSubType(wSubType);
		}
		/*
		 * Traite le troisi�me noeud NDCTSU contenant le complement (ou non).
		 * Exemple: Type=[g] SubType=[AX] Complement=[] Le noeud correspondant:
		 * Id=[NDCTSU] func=[Control_DefineType] NbArgs=[3] opt=[.x67] su1 =[AX]
		 * su2 =[]
		 */
		else {
			/*
			 * mis en place du complement, creation du format dynamique dans le
			 * formater, et destroy du format dynamique
			 */
			this.currentDynFormat.setComplement(wComplement);
			this.currentDynFormat.createInFormater();
			this.currentDynFormat = null;
		}
	},

	/**
	 * NDOMNCO 0E015E (MenuDyn_New) Id=[NDOMNCO] level=[R] x3func=[MenuDyn_New]
	 * NbArgs=[5] - flg=[.x58] - cod=[1026] - txt=[S�lection] - acc=[0] - hlp
	 * =[] parametre passes a la fonction "MenuDyn_New" du client X3 :
	 *
	 * (*fnd)( (flg&0x40)>>6, fen, (flg&0x08)>>3, cod, txt, acc, (flg&0x7), 0,
	 * (flg&0x10)>>4, (flg&0x20)>>5, hlp ) ;
	 *
	 * bFirst Premiere option (vide la liste) ((wByte & 0x40) >> 6) nRang Rang
	 * d'insertion de l'option (0 pas d'option) nType Type de l'option (flg &
	 * 0x08) >>3) nAction Action � renvoy�e au serveur pszText texte de l'option
	 * nAccel Acc�l�rateur nCateg Cat�gorie dans le type (flg&0x7) nImage Num�ro
	 * de l'image bValide Valide ou bien (flg&0x10)>>4 bSelect S�lectionn� ou
	 * bien (flg&0x20)>>5 pszhelp texte d'aide rapide
	 */
	listenNodeNDOMNCO: function(_, reader, node, wFlg, wActionId, wTxt) {
		/*
		 * first node => flg=[.x58] others => flg=[.x18]
		 */
		var wVidage = (wFlg & 0x40) != 0;
		/*
		 * boolean wFlag = ((wByte & 0x40) >> 6) != 0; int wType = ((wByte &
		 * 0x08) >>3); wAcc >> 3
		 */
		var wType = (wFlg & 0x08) >> 3 == 0;
		/*
		 * si ce n'est pas un enoeud de "vidage"
		 */
		if (!wType && wActionId > 0) // ???
		{
			/*
			 * si "vidage" de la liste
			 */
			if (wVidage) {
				this.removeCtxButtons();
			}
			new CvgMenuCtx(this, wActionId, true, wTxt);
		}
	},

	/**
	 * Changement element dans barre de statut Id=[NDOTXSC] level=[W]
	 * x3func=[Status_ChangeStatus] NbArgs=[6] - ist =[ win=[2] srn=[0] blc=[0]
	 * fld=[0] idx=[0]] - st[0]=[.x00] (byte) - st[1]=[132] (int) - buf[0] =[]
	 * (stru) - buf[1] =[] (stru) - st[2]=[3058] (int)
	 */
	listenNodeNDOTXSC: function(_, reader, node, wIst, wNumText, wImgId, wTxt, wTxtDummy, wActionId) {
		this.addStatusIconDef(wIst, wNumText, wTxt, wImgId, wActionId);
	},

	/**
	 * Id=[NDPKAR] func=[LeftList_Picking] NbArgs=[1] - ist =[ win=[2] srn=[34]
	 * blc=[3] fld=[0] idx=[0]]
	 */
	listenNodeNDPKAR: function(_, reader, node) {
		var wActionArgs;
		if (this.adxIstsOfPickedLines.length > 0) {
			var wPickedLine = this.adxIstsOfPickedLines.splice(0, 1)[0];
			var wActionArgs = [wPickedLine.action];
			var wArgIst = wPickedLine.ist;
			var wLeftListLine = this.findModifiable(wArgIst);
			if (wLeftListLine != null) {
				// suppression du numero de ligne dans l'adxid de la lisgne pickee ajout de l'argument tdans la liste
				wArgIst.idx = 0;
				wActionArgs.push(wArgIst.toString());
				// ajout de l'argument tableau de r�su qu'est la cle de la ligne  pickee
				wActionArgs.push(wLeftListLine.cle.toString());
			} else {
				wActionArgs.add(wArgIst.toString());
				var wMess = this.getMessage('ERROR_CANT_GET_PICKED_LINE_KEY', String.valueOf(wArgIst.idx));
				this.addLogicalErrorMess(this, "NDPKAR", wArgIst.toString(), wMess);
			}
		} else {
			wActionArgs = [CvgAction.SRV_ABANDON];
		}
		try {
			// BRJOU: did not see any resu, pass null
			this.sendAction(_, null, [], wActionArgs);
		} catch (e) {
			this.connected = false;
			throw e;
		}
	},

	listenSegment: function(aSegment) {
		var retour = false;
		retour = TODO_SUPER.listenSegment(aSegment);
		if (!retour && aSegment instanceof CSegmentNode) {
			var wSegmentNode = aSegment;
			var wNodeId = wSegmentNode.nodeId;
			switch (wNodeId) {
			case CvgNode.NDACTOP:
				retour = listenNodeNDACTOP(wSegmentNode);
				break;
			case CvgNode.NDOMNCO:
				retour = listenNodeNDOMNCO(wSegmentNode);
				break;
			case CvgNode.NDCTSU:
				retour = listenNodeNDCTSU(wSegmentNode);
				break;
			case CvgNode.NDOTXSC:
				retour = listenNodeNDOTXSC(wSegmentNode);
				break;
			case CvgNode.NDPKAR:
				retour = listenNodeNDPKAR(wSegmentNode);
				break;
			}
		}
		return retour;
	},
	newActiveRequest: function(reply, aParams, sendContext) {
		this.razModifications();
		this.activeRequest = new CvgRequest(this, reply, aParams, sendContext);;
		this.trackLists = this.newTrackLists(); // should be inside request???
		return this.activeRequest;
	},
	open: function(aAdonixContext) {
		throw new Error("not used")
		try {
			//initResources(aAdonixContext.x3Language);
			if (isServerConnected()) {
				throw new Error("CANT_OPEN - one conn already opened !");
			}
			if (!hasApplicationId()) {
				throw new Error("CANT_OPEN - no ApplicationId set!");
			}
			initSessionWeight(aAdonixContext, this.config.sessionWeight);
			validAdonixContext(aAdonixContext);
			setCacheContext(aAdonixContext.x3Language);
			/*
			 * creation de la requete de connexion sans segment action associe.
			 * Utilisation du constructeur de CAdonixRequest sans liste d'Args
			 * et avec une ActionId correspondant a une action locale.
			 */
			var aX3Reply = checkFailed(connect(aAdonixContext, newActiveRequest(new CvgReply(this, CONNECT_ACTION), null, null)), "X3 Open Connexion failed");
			if (isServerConnected() && aX3Reply.isOk()) {
				this.connClientNode.setLogicalErrorListner(this);
			}
			aX3Reply = removeActiveRequest(aX3Reply);
			aX3Reply.setOneSessionSetting("VOn", this.formater.isVOn() ? "1" : "0");
			aX3Reply.setOneSessionSetting("ZOn", this.formater.isZOn() ? "1" : "0");
			return checkFailed(aX3Reply, "X3 Open Connexion failed");
		} finally {
			realeaseActiveRequest();
		}
	},
	popRequesterWindow: function() {
		var window = this.stackedWindows.popStackedWindow();
		window.setOpened(false);
		return window;
	},
	pushAffSynchroneMessage: function(aMessage) {
		this.affSynchroneMessages.addElement(aMessage);
	},
	pushAffSynchroneMessTempOn: function(aMessage) {
		pushAffSynchroneMessage(new CvgMessage(Cvg.AFF_SYNCHRONE_TYPE_TEMPON, this, aMessage, false));
	},
	pushRequesterWindow: function(aWindowId, aFunctionId, aDescr, aStamp, aWindowIdxBaseOne) {
		var wRequesterWindow = this.getNewStackedWindows(aWindowId, aFunctionId, aDescr, aStamp, aWindowIdxBaseOne);
		this.stackedWindows.pushStackedWindow(wRequesterWindow);
		wRequesterWindow.setStackLevel(this.stackedWindows.length);
		wRequesterWindow.setOpened(true);
		return wRequesterWindow;
	},
	razModifications: function() {
		this.stackedWindows.razModifications();
		this.formater.razModifications();
	},
	realeaseActiveRequest: function() {
		var wActiveRequest;
		wActiveRequest = this.activeRequest;
		this.activeRequest = null;
		if (wActiveRequest != null) {
			wActiveRequest.releaseRefs();
		}
	},
	releaseAllAffSynchroneMessages: function() {
		var wNbMess = this.affSynchroneMessages.length;
		if (wNbMess > 0) {
			this.affSynchroneMessages.removeAllElements();
		}
	},
	releaseRefs: function() {
		this.formater.end();
		this.formater = null;
		this.motherWindow = null;
		this.stackedWindows.clear();
		this.stackedWindows = null;
		realeaseActiveRequest();
		this.config = null;
		this.adxIstsOfPickedLines = null;
		releaseAllAffSynchroneMessages();
		this.affSynchroneMessages = null;
		this.applicationID = null;
		this.currentDynFormat = null;
		TODO_SUPER.releaseRefs();

	},
	removeActiveRequest: function(aAdonixReply) {
		var wX3Reply = aAdonixReply;
		if (this.hasActiveRequest()) {
			wX3Reply = this.activeRequest.reply;
			realeaseActiveRequest();
		}
		return wX3Reply;
	},

	sendActionCallRemote: function(aX3ActionArgs) {
		var wX3Reply = new CvgReply(this, CvgAction.SRV_CALLREMOTESPGM, CReply.OK);
		return TODO_SUPER.sendActionCallRemote(wX3Reply, aX3ActionArgs);
	},

	// Pour remontée des erreurs par exception
/* TODO overload
	sendActionCallRemote: function(aSpgmElmt) {
		var reply = this.sendActionCallRemote(CvgIst.IST_WIN_ZERO, aSpgmElmt);
		if (reply.isOk()) {

		}
		return reply;
	},*/
	sendX3Action: function(args, sendContext) {
		try {
			var actionCode = args != null && !args.isEmpty() && args.get(0) instanceof Integer ? args.get(0) : null;
			if (actionCode == null) {
				throw new Error("sendX3Action - Bad first argument - Integer expected");
			}
			return checkFailed(sendAction(new CvgReply(this, actionCode), args, sendContext), "X3 send action failed");
		} finally {
			releaseAllAffSynchroneMessages();
		}
	},
	sendX3ActionAckCall: function(aAdxId, aSpgmElmtl) {
		var wX3ActionDatas = buildAckCallDatas(aAdxId, aSpgmElmtl);
		wX3ActionDatas.add(0, CvgIstDatas.getIstDatasNull());
		wX3ActionDatas.add(0, new Integer(CvgAction.SRV_CALLREMOTESPGM));
		return checkFailed(sendX3Action(wX3ActionDatas, null), "X3 send AckCall failed");

	},
	sendX3ActionAckResi: function(aAdxId, aExecIstResultXml) {
		var wX3ActionDatas = buildActionAckResiDatas(aAdxId, aExecIstResultXml);
		wX3ActionDatas.add(0, CvgIstDatas.getIstDatasNull());
		wX3ActionDatas.add(0, new Integer(CvgAction.SRV_EXECI_RESPONSE));
		return sendX3Action(wX3ActionDatas, null);
	},
	setActiveRequest: function(aRequest) {
		this.activeRequest = aRequest;
		return this.activeRequest;
	},
	setCacheContext: function(aLang) {
		this.adonixContext.setLanguage(aLang);
	},
	setCurrentDynFormat: function(currentDynFormat) {
		this.currentDynFormat = currentDynFormat;
	},
	setCurrentField: function(currentField) {
		this.currentField = currentField;
	},
	setMonthList: function(aStructProperty) {
		try {
			this.formater.setMonthList(aStructProperty.strValue);
		} catch (e) {
			throw new CCommException(CCommException.CANT_EXEC_NODE, e, "ND_SLF AskUi setMonthList");
		}
	},
	storeUrlPortalSessionSetting: function(aId, aUrlPortal) {
		var wSB = new StringBuilder(128);
		var wPos = aUrlPortal.indexOf("/ADX_PORTAL");
		if (wPos == -1) {
			wSB.append("error://le param�tre \"SessionSettings.PortalUrl\" contient un url erron� : absence de la racine du portail \"/ADX_PORTAL\". ");
			wSB.append(aUrlPortal);
		} else {
			/*
			 * par un url relatif au serveur de Web. exemple:
			 * "/x3webheaddata/[solution]
			 */
			wSB.append(this.clientConfig.getParam(CvgClientConfig.VIRTUALPATHPAGES));
			// recuperation du nom de la solution dans l'url http
			var solName = this.httpX3ServerUrl.substring(this.httpX3ServerUrl.indexOf("_")); // prends pour hypothese que l'url est de la forme http://server:port/Adonix_SOL
			if (solName == null) {
				solName = this.adonixContext.x3ServerAppliHostname;
			}
			wSB.append('/').append(solName);
			/*
			 * laisser la racine du portail "/ADX_PORTAL" comp�ter par la
			 * d�signation de la page de d�marrage. exemple :
			 * "/ADX_PORTAL/PortalStartCSF.htm"
			 */
			wSB.append(aUrlPortal.substring(wPos));
			/*
			 * on ajoute � l'URL les param�tres n�cessaires au fonctionnement du
			 * portail depuis le client Web : - DlgMode=WEB - LANG=xxx
			 */
			wSB.append('?').append("DlgMode").append('=').append("WEB");
			wSB.append('&').append("LANG").append('=').append(this.adonixContext.language);
		}
		setOneSessionSetting(aId, wSB.toString());
	},
	toString: function(aSeparator) {
		var wSB = new StringBuilder(512);
		TODO_SUPER.addDescrInSB(wSB, aSeparator);
		if (aSeparator != null) {
			wSB.append(aSeparator);
		}
		CStringFacilities.addInStringDescr(wSB, "NbParamConfig", this.config.size());
		return wSB.toString();
	},

	/**
	 * construit l'Url utilis� par le browser en fonction de la pr�sence ou non
	 * du param�tre "UIAdxPubSubFile"
	 *
	 * cas 1 <li>0= "UIAction="+chr$(1)+"OpenFile", <li>1= "UILocalDir="+
	 * chr$(1) +"HTTP", <li>2= "UILocalFile="+ chr$(1) +"www.meteo.fr/"
	 *
	 * il faut seulelemnt ajouter le pr�fixe "http://" pour obtenir l'url absolu
	 * :
	 *
	 * <pre>
	 * &quot;http://www.meteo.fr/&quot; Le browser utilise l'attribut &quot;url&quot; du noeud &quot;open_file&quot;
	 * </pre>
	 *
	 * tel quel: <open_file url="http://www.meteo.fr/" " ></open_file>
	 *
	 * cas 2 : <li>0= id=[UIAction] value=[OpenFile] <li>1= id=[UILocalDir]
	 * value=[HTTP] <li>2= id=[UILocalFile]
	 * value=[172.16.12.41:80/x3webdata/GX3APP/TMP/F5963808_EDITRTWEB_53711.xml]
	 * <li>3= id=[AdxPubSubFile] value=[1]
	 *
	 * <p>
	 * Comme c'est un sous-fichier du dossier ADX_PUB du serveur d'application,
	 * celui ci doit etre atteind via le proxypass.
	 * <p>
	 * Il faut donc suprimer le pr�fixe de de la forme :
	 * "AdonixApplicationServerHostName:port/adxwedata/"
	 * <p>
	 * Le browser utilise l'attribut "url" du noeud "open_file" en ajoutant le
	 * prefixe "http://ServerWebHostName:port/AliasOfProxyPath/[solution]" :
	 * <open_file url="/GX3APP/TMP/F5963808_EDITRTWEB_53711.xml"
	 * uiadxpubsubfile="1" ></open_file>
	 */
	translateLocalFileUrl: function(aUrlFile, aListOfProperties) {
		var wSB = new StringBuilder(128);
		/*
		 * si ce n'est pas un "subfile" de ADX_PUB => on ajoute seulement
		 * "http://" devant "aUrlFile"
		 */
		if (!containsAdxPubSubFile(aListOfProperties)) {
			wSB.append("http://");
			wSB.append(aUrlFile);
		}
		/*
		 * sinon, si c'est un "subfile" de ADX_PUB, il faut suprimer le pr�fixe
		 * de de la forme "AdonixApplicationServerHostName:port/adxwedata/
		 */
		else {
			// 15w_016 - Fiche 44800 - Erreur d'URL sur export sur requeteur graphique
			aUrlFile = aUrlFile.replace('\\', '/');
			// recherche de la position du "slash" apr�s
			// "AdonixApplicationServerHostName:port"
			var wPos = aUrlFile.indexOf('/');
			// 15w_000 - Fiche 34938 - Protection contre les url malform�s dans les callui openfile
			if (wPos > -1 && wPos < aUrlFile.length() - 1) {
				// recherche de la position du "slash" apr�s l'alias du dossier ADX_PUB
				wPos = aUrlFile.indexOf('/', wPos + 1);
			}
			var wMalformedUrl = wPos == -1 || wPos > aUrlFile.length() - 1;
			if (wMalformedUrl) {
				var wMess = String.format("Malformed url, not an AdxPubSubFile !", aUrlFile);
				var wException = new CCommException(CCommException.ERR_ARG_PROTOCOL, wMess);
				throw wException;
			}
			wSB.append(aUrlFile.substring(wPos));
		}
		return wSB.toString();
	},
	traverseSettable: function(aStructIst, aModifier) {
		if (aStructIst.isWindowIst() && aStructIst.winZeroBase == -1) {
			return aModifier.setModifiable(aStructIst, this.motherWindow);
		} else {
			return this.stackedWindows.traverseSettable(aStructIst, aModifier);
		}
	},

	// Obersver/Observable
	// update: function(object, arg1);
	validAdonixContext: function(aAdonixContext) {
		var wOsUserCrypted = null;
		var wX3PwdCrypted = null;
		try {
			// si userid OS re�u est crypt� "CRYPT:" : memorisation du userid OS crypte "CRYPT:" dans "wOsUserCrypted" et decryptage du userid OS dans "aOsUser"
			if (CCrypton.isCryptedPrefixedString(aAdonixContext.oSUserId)) {
				wOsUserCrypted = aAdonixContext.oSUserId;
				aAdonixContext.setOSUserId(CCrypton.X3DecryptPrefixedString(wOsUserCrypted));
			}
			// sinon, cryptage "CRYPT:" du userid OS dans "wOsUserCrypted"
			else {
				wOsUserCrypted = CCrypton.X3CryptPrefixedString(aAdonixContext.oSUserId);
			}
			// si mot de passe OS re�u est crypte "CRYPT:" : memorisation du mot de passe OS crypte "CRYPT:" dans "wOsPwdCrypted" et decryptage du mot de passe OS dans "aOsPwd"
			if (CCrypton.isCryptedPrefixedString(aAdonixContext.oSPassword)) {
				aAdonixContext.setOSPassword(CCrypton.X3DecryptPrefixedString(aAdonixContext.oSPassword));
			}
			// sinon, cryptage "CRYPT:" du mot de passe OS dans "wOsPwdCrypted"
			// si userid X3 est crypte "CRYPT:" : memorisation du userid X3 crypte "CRYPT:" dans "wX3UserCrypted" et decryptage du userid X3 dans "aX3User"
			if (CCrypton.isCryptedPrefixedString(aAdonixContext.x3UserId)) {
				aAdonixContext.setX3UserId(CCrypton.X3DecryptPrefixedString(aAdonixContext.x3UserId));
			}
			// sinon, cryptage "CRYPT:" du userid X3 dans "wX3UserCrypted"
			// si mot de passe X3 est crypte "CRYPT:" decryptage du mot de passe X3 dans "aOsPwd", et cryptage "CRYX3:" du mot de passe X3 dans "wX3PwdCrypted"
			if (CCrypton.isCryptedPrefixedString(aAdonixContext.x3Password)) {
				var wS = CCrypton.X3DecryptPrefixedString(aAdonixContext.x3Password);
				if (wS.toUpperCase() === CConfigBase.NO_PASSWORD.toUpperCase()) {
					wS = ""; // si aX3Pwd = "none" => ""
				}
				aAdonixContext.setX3Password(wS);
			}
			var wX3password = aAdonixContext.x3Password;
			// si mot de passe X3 est crypte "CRYX3:" : memorisation du mot de passe X3 crypt� "CRYX3:" dans "wX3PwdCrypted"
			if (CCrypton.isPassCryptedPrefixedString(wX3password)) {
				wX3PwdCrypted = wX3password;
			}
			// sinon, cryptage "CRYX3:" du mot de passe X3 dans "wX3UserCrypted"
			else {
				wX3PwdCrypted = CCrypton.X3CyptPass(wX3password);
			}
			aAdonixContext.setX3Password(wX3PwdCrypted);
		} catch (e) {
			var wMess = this.getMessage('ERROR_CONTEXT_NOT_VALID', aAdonixContext.toString());
			throw new CvgException(this, e, "CANT_OPEN - " + wMess);
		}
	},
	track: function(obj) {
		var list = this.trackLists[obj.jsonType];
		if (obj.getObservableId) {
			// we can add keys directly to the array, they will be ignored by JSON.stringify
			var key = '#' + obj.getObservableId();
			var old = list[key];
			if (old != null) list[old] = undefined;
			list[key] = list.length;
		}
		list.push(obj);
	},
	// Fusion
	removeCtxButtons: function() {
		for (var i in this.trackLists) {
			if (this.trackLists[i] instanceof CvgMenuCtx) {
				console.error("instanceof CvgMenuCtx");
			}
		}
	},
	filterSessionSettings: function() {
		var map = {
			"ADXVersion": "ADXVersion",
			"adonix.port": "ADXPort",
			"usrProfile": "usrProfile",
			"session.apphostname": "ADXAppHost",
			"Version": "Version",
			"ADXProduct": "ADXProduct",
			"Protocol": "Protocol",
			"STime": "STime",
			"SDecimal": "SDecimal",
			"ADXLangIso": "ADXLangIso",
			"SThousand": "SThousand",
			"adonix.host": "ADXTrtHost",
			"AdxSolution": "AdxSolution",
			"ADXProductPref": "ADXProductPref",
			"ADXProductLabel": "ADXProductLabel",
			"SetMonthList": "SetMonthList",
			"formater.von": "formater.von",
			"SDate": "SDate",
			"ADXProductInfoVers": "ADXProductInfoVers",
			"ADXSupVers": "ADXSupVers",
			"mnu": "mnu",
			"DefaultDatePivot": "DefaultDatePivot",
			"session.username": "user",
			"ADXTheme": "ADXTheme",
			"ADXHttpPub": "ADXHttpPub",
			"ADXNamedUser": "ADXNamedUser",
			"session.x3folder": "ADXFolder",
			"cdLang": "cdLang",
			"DefaultDateFormat": "DefaultDateFormat",
			"fmtExt": "fmtExt",
			"ADXStyleFile": "ADXStyleFile",
			"ADXNopatch": "ADXNopatch",
			"ADXRelease": "ADXRelease",
			"IDate": "IDate",
			"ADXProductSuff": "ADXProductSuff",
			"BOSEC": "BOSEC",
			"BOSERV": "BOSERV",
			"BOUSR": "BOUSR",
			"BOPWD": "BOPWD",
			"ADXMaskAppName": "ADXMaskAppName"
		}
		var res = {};
		for (var i in map) {
			if (this.sessionSettings[i]) res[map[i]] = this.sessionSettings[i];
			else if (this.appSrvSessionSettings[i]) res[map[i]] = this.appSrvSessionSettings[i];
		}
		return res;
	},
	getResponse: function() {
		var t0 = new Date().getTime();
		var lists = this.trackLists;
		var isDefined = function(o) {
				return o !== undefined;
			};
		var wins = {};
		for (var i = 0; i < lists.ENTITY.length; i++) {
			var entity = lists.ENTITY[i];
			if (entity === undefined) continue;

			var win = this.stackedWindows.findWin(entity.getFatherWindowId().charCodeAt(0) - '@'.charCodeAt(0));
			if (win) {
				var winNode = wins[win.entityIdxAlpha];
				if (!winNode) {
					winNode = wins[win.entityIdxAlpha] || {
						entities: {}
					};
					if (win.statusBar) winNode.statBar = win.statusBar.toJSON();
					if (win.title) winNode.tit = win.title;
					wins[win.entityIdxAlpha] = winNode;
				}
				if (entity instanceof CvgEntity) {
					var gridParent = null;
					var line = null;
					if (entity instanceof CvgVariable) {
						line = entity.srcLine;
					} else if (entity instanceof CvgDataSrcLine) {
						line = entity;
					} else if (entity instanceof CvgDataSrc) {
						gridParent = entity;
					}
					if (line != null) {
						gridParent = line.dataSrc;
					}
					if (gridParent != null || line != null) {
						if (gridParent == null) {
							gridParent = line.dataSrc;
						}
						if (gridParent.isBlocGrid()) {
							entity = gridParent;
						}
					}
					
					var jsonKey = entity.getJsonKey();
	
					if (winNode.entities[jsonKey] == null) {
						var jsonEntity = entity.toJSON();
						if (jsonEntity && Object.keys(jsonEntity).length !== 0) winNode.entities[jsonKey] = jsonEntity;
					}
				}
			}
			if (win && win.entityIdxAlpha && Object.keys(wins[win.entityIdxAlpha].entities).length === 0)
				delete wins[win.entityIdxAlpha];
		}

		var response = {
			sap: {},
			session: lists.SESSION,
		};
		var sap = response.sap;

		if (lists.TARGET[0])
			sap.target = JSON.parse(JSON.stringify(lists.TARGET[0]));
		
		 
		if (lists.PREVIOUS[0]){
			var previous = JSON.parse(JSON.stringify(lists.PREVIOUS[0]));
			sap.previous = {
				v: previous.ist.v,
				xid: previous.ist.xid,
				win: previous.ist.win,
				nl: previous.ist.nl || -1
			}
		}
			
		
		var acts = lists.ACT.filter(isDefined);
		if (acts && acts.length !== 0)
			sap.acts = acts;
		
		for (var i = 0; i < lists.FUNC.length; i++) {
			sap.func = sap.func || {};
			var win = lists.FUNC[i];
			var key = win.entityIdxAlpha;
			if (win && win.isOpened()) {
				// object with key: win 
				sap.func.open = sap.func.open || {};
				sap.func.open[key] = win;
			} else {
				// just an array of keys
				sap.func.close = sap.func.close || [];
				sap.func.close.push(key);
//				wins[key] = {
//					tit: win.title,
//					entities: {}
//				};
			}
		}
		if (Object.keys(wins).length > 0)
			sap.wins = wins;
		

		if (sap.target && sap.target.ist){
			for (var i = 0; i < lists.TARGETACT.length; i++) {
				sap.target.ist.acts = sap.target.ist.acts || [];
				sap.target.ist.acts.push(lists.TARGETACT[i]);
			}
		}

		response.session = {};
		
		if (this.activeRequest.reply.orderId === CONNECT_ACTION){
			if (this.sessDynFormat.length > 0) {
				this.sessionSettings.fmtExt = {};
				for (var i = 0; i < this.sessDynFormat.length; i++) {
					var item = this.sessDynFormat[i];
					this.sessionSettings.fmtExt[item.type] = item.toJSon();
				}
			}
			this.sessionSettings.mnu = lists.SESSIONMNU;
			response.session.settings = this.filterSessionSettings();
		}
		
		response.srvop = {};//this.srvop;
		var t1 = new Date().getTime() - t0;
		response.toJsonTime = (t1/1000)%60;

		return response;
	}
});


CvgClient.checkFailed = function(adxReply, info, reason) {
	if (adxReply == null || !adxReply.isOk()) {
		var t = adxReply != null ? adxReply.throwable : null;
		// Format Exception - pas de throws Exception
		if (t instanceof CvgException && t.formatException) {
			return adxReply;
		}
		var diag = new CDiagnosis(ESDataErrorCode.ApplicationDiagnosis);
		diag.setApplicationCode(EApplicationCode.ERROR.toString());
		var msgs = new StringBuilder();
		if (adxReply != null) {
			if (adxReply.hasWhy()) {
				msgs.append("WHY[" + adxReply.whyString + "]\n");
			}
			if (adxReply.hasMessages()) {
				for (var msg in adxReply.messages) {
					msgs.append(adxReply.messages[msg].mess + "\n");
				}
			}
		}
		msgs.append(t.message).append("\n");
		diag.setMessage(msgs.toString());
		diag.setStatusCode(500);
		diag.setSeverity(ESeverity.ERROR.toString());
		diag.setStackTrace(t);
		FusionExcep.throwExcep(reason, info, new CXSDataException(diag));
	}
	return adxReply;
}

CvgClient.checkFailed = function(adxReply, reason) {
	return checkFailed(adxReply, FusionClientInfo.X3COM, reason);
}
