"use strict";
var helpers = require('syracuse-core/lib/helpers');
var datetime = require("syracuse-core/lib/types/datetime");
var locale = require("syracuse-core/lib/locale");
var date = require('syracuse-core/lib/types/date');
var automata = require("syracuse-x3/lib/convergence/automata/x3Automata");
var x3writer = require("syracuse-x3/lib/convergence/automata/x3writer");
var jsxml = require('jsxml');
var streams = require('streamline/lib/streams/streams');
var os = require('os');
var util = require('util');
var x3helpers = require('syracuse-x3/lib/helpers');
var CvgClientConfig = require("syracuse-x3/lib/convergence/model/CvgClientConfig").CvgClientConfig;
var CvgFormatter = require('syracuse-x3/lib/convergence/types/CvgFormatter').CvgFormatter;
var CvgModifier = require('syracuse-x3/lib/convergence/model/CvgModifier').CvgModifier;
var CvgEntity = require('syracuse-x3/lib/convergence/model/CvgEntity').CvgEntity;
var CvgStackedWindows = require('syracuse-x3/lib/convergence/model/CvgStackedWindows').CvgStackedWindows;
var CvgStackedWindow = require('syracuse-x3/lib/convergence/model/CvgStackedWindow').CvgStackedWindow;
var CvgReply = require('syracuse-x3/lib/convergence/client/CvgReply').CvgReply;
var CvgRequest = require('syracuse-x3/lib/convergence/client/CvgRequest').CvgRequest;
var CvgInstance = require('syracuse-x3/lib/convergence/model/CvgInstance').CvgInstance;
var CvgMenuAct = require('syracuse-x3/lib/convergence/model/CvgMenuAct').CvgMenuAct;
var CvgCallUiOpenFile = require('syracuse-x3/lib/convergence/model/CvgCallUiOpenFile').CvgCallUiOpenFile;
var CvgMenuCtx = require('syracuse-x3/lib/convergence/model/CvgMenuCtx').CvgMenuCtx;
var CvgDataSrc = require('syracuse-x3/lib/convergence/model/CvgDataSrc').CvgDataSrc;
var CvgDataSrcLine = require('syracuse-x3/lib/convergence/model/CvgDataSrcLine').CvgDataSrcLine;
var CvgVariable = require('syracuse-x3/lib/convergence/model/CvgVariable').CvgVariable;
var CvgClose = require('syracuse-x3/lib/convergence/model/CvgClose').CvgClose;
var CvgIst = require('syracuse-x3/lib/convergence/types/CvgIst').CvgIst;
var CvgResu = require('syracuse-x3/lib/convergence/types/CvgResu').CvgResu;
var CvgResuTdo = require('syracuse-x3/lib/convergence/types/CvgResu').TDO;
var CvgAction = require('syracuse-x3/lib/convergence/client/CvgAction').Actions;
var CvgSuperAction = require('syracuse-x3/lib/convergence/client/CvgAction').SuperActions;
var CvgSpecialAction = require('syracuse-x3/lib/convergence/client/CvgAction').SpecialActions;
var CvgException = require('syracuse-x3/lib/convergence/model/CvgException').CvgException;
var PrintClient = require('syracuse-print/lib/PrintClient');
var CvgImpMore = require('syracuse-x3/lib/convergence/model/CvgImp').CvgImpMore;
var CONNECT_ACTION = require('syracuse-x3/lib/convergence/client/CvgAction').CONNECT_ACTION;
var CvgServices = require('syracuse-x3/lib/convergence/client/CvgServices');
var CvgDiagnose = require('syracuse-x3/lib/convergence/model/CvgDiagnose').CvgDiagnose;

var localConfig=x3helpers.config("x3fusion", null, {});
var traceAction = x3helpers.config("actions.trace",localConfig);
var traceProtocol = x3helpers.config("protocol.trace",localConfig);
var traceSessions = x3helpers.config("sessions.trace",localConfig);

// Setting sent to client at connection
var _uiCliSettings = {
	"ADXVersion": "ADXVersion",
	"adonix.port": "ADXPort",
	"usrProfile": "usrProfile",
	"x3host": "ADXAppHost",
	"Version": "Version",
	"ADXProduct": "ADXProduct",
	"Protocol": "Protocol",
	"STime": "STime",
	"SDecimal": "SDecimal",
	"ADXLangIso": "ADXLangIso",
	"SThousand": "SThousand",
	"adonix.host": "ADXTrtHost",
	"AdxSolution": "AdxSolution",
	"ADXProductPref": "ADXProductPref",
	"ADXProductLabel": "ADXProductLabel",
	"SetMonthList": "SetMonthList",
	"formater.von": "formater.von",
	"SDate": "SDate",
	"ADXProductInfoVers": "ADXProductInfoVers",
	"ADXSupVers": "ADXSupVers",
	"mnu": "mnu",
	"DefaultDatePivot": "datePivot",
	"x3user": "user",
	"ADXTheme": "ADXTheme",
	"ADXHttpPub": "ADXHttpPub",
	"ADXNamedUser": "ADXNamedUser",
	"ADXfolder": "ADXFolder",
	"cdLang": "cdLang",
	"DefaultDateFormat": "DefaultDateFormat",
	"fmtExt": "fmtExt",
	"ADXStyleFile": "ADXStyleFile",
	"ADXNopatch": "ADXNopatch",
	"ADXRelease": "ADXRelease",
	"IDate": "IDate",
	"ADXProductSuff": "ADXProductSuff",
	"BOSEC": "BOSEC",
	"BOSERV": "BOSERV",
	"BOUSR": "BOUSR",
	"BOPWD": "BOPWD",
	"ADXMaskAppName": "ADXMaskAppName"
}

function _postDiag(client,msg, detail){
	new CvgDiagnose(client, 'WARNING', 99, msg, detail, null, "Protocol" , null, true);
}


function _actionParams(body) {
	// params passed to listenSendingArgs are [action, ist (or null ist), params added by append2ActionParams]
	var params = [body.act];
	if (!body.param) return params;
	var target = body.param.target;
	if (target && target.xid != null) {
		params.push(CvgIst.fromTarget(target));
	}
	if (body.param.std) {
		params = params.concat(body.param.std);
	}

	return params;
}

var CDynFormat = exports.CDynFormat = helpers.defineClass(function(aType, aFormater) {
	this.complement = null;
	this.subType = null;
	this.type = aType;
	this.formater = aFormater;
}, null, {
	/*
	 * c": { "stdType": ["A", "#"], "chars": ["", "-", "/", "_", ","] },
	 */
	toJSon: function() {
		var dynFmt = {};
		if (this.complement != null) {
			dynFmt.stdType = this.complement.split('');
		}
		if (this.subType != null) {
			dynFmt.chars = this.subType.split('');
		}
		return dynFmt;
	}
});

var CModifiableFinder = exports.CModifiableFinder = helpers.defineClass(function() {
	CvgModifier.call(this);
	this.foundModifiable = null;
}, CvgModifier, {
	setModifiable: function(aStructIst, aModifiable) {
		this.foundModifiable = aModifiable;
		this.done = true;
		return this.done;
	}
});

var CMotherWindow = exports.CMotherWindow = helpers.defineClass(function(aClient) {
	CvgEntity.call(this, aClient, "&ROOT", 1, 'WINDOW');
}, CvgEntity, {
	getAdxId: function() {
		return "mostherWindow - &ROOT";
	},
	toJson: function() {
		throw new Error("Bad tojson MotherWin");
	}
});


// move this to Reader class

function formatKeyValues(result) {
	return [Object.keys(result).map(function(key) {
		return key + '=\u0001' + result[key] + '\n';
	})];
}

var Spy = helpers.defineClass(function(_, stream) {
	var self = this;

	this.dumpFile = __dirname + "/../data/dump_" + (new Date().toISOString()).replace(/\:/g,'-') + ".js";
	require('fs').appendFile(this.dumpFile, '"use strict";\n', 'utf8', _);

	var read = stream.read;
	stream.read = function(_, len) {
		var data = read.call(stream, _, len);
		if (data) self.dumpBytes(_, "READ", data);
		return data;
	};
	var write = stream.write;
	stream.write = function(_, data) {
		if (data) self.dumpBytes(_, "WRITE", data);
		write.call(stream, _, data);
	}
}, null, {
	dumpBytes: function(_, action, data) {
		var line = action + "([0x" + data.toString('hex').match(/.{1,2}/g).join(', 0x') + "]);\n";
		require('fs').appendFile(this.dumpFile, line, 'utf8', _);
	},
	dumpJSON: function(_, action, obj) {
		var line = action + "(" + JSON.stringify(obj) + ");\n";
		require('fs').appendFile(this.dumpFile, line, 'utf8', _);
	}
});

var CvgClient = exports.CvgClient = helpers.defineClass(function(_, stream, aConfig, recorder) {
	this._recorder=recorder;
	// Activate dump
	if (localConfig && localConfig.dump) {
		this._spy = new Spy(_, stream);
	}
	this.creationDate=datetime.now();
	this.stream = stream;
	this.clientConfig = new CvgClientConfig(this, aConfig);
	this.isInteractiveSession = true;
	this._trackLists = this.newTrackLists();
	this._sessionSettings = {};
	this._x3SessionSettings = {};
	this.srvop = {};
	this.activeRequest = null;
	this._pickedLinesIsts = [];
	this.applicationID = null;
	this._sessDynFormat = [];
	this.currentDynFormat = null;
	this.uuid = helpers.uuid.generate();
	this.formater = new CvgFormatter(this.clientConfig.formaterConfig());
	this.motherWindow = new CMotherWindow(this);
	this.stackedWindows = new CvgStackedWindows();
	// added by BRJOU - open not called any more
	this.newActiveRequest(new CvgReply(this, CONNECT_ACTION),{"reqNum":0});
	this.connecting = false;
	this.isReuse = false;
	this.reused = false; // for the settings
	this.timeToReuse = -1;// time when the client was set in reuse
	this.sessionConv = null;
	this.services = CvgServices.create(_, this);

}, null, {
	newTrackLists: function() {
		return {
			SESSION: [],
			ACT: [],
			TARGETACT: [],
			SESSIONMNU: [],
			TARGET: [],
			MISC: [],
			PREVIOUS: [],
			ENTITY: [],
			FUNC: [],
			RPC: [],
			WINDOW: [],
			DIAGNOSE: [],
			REPORT: []
		};
	},
	setInReuseMode: function(_,yes){
		traceSessions && traceSessions("setInReuseMode + " + yes);	
		if (yes) {
			this.isReuse = true;
			this.reused = true;
			this.timeToReuse = (new Date()).getTime();
			traceSessions && traceSessions("set timeout");	
			var timeoutReuse =this.clientConfig.getParam("timeoutReuse");
			var self = this;
			traceSessions && traceSessions("timeout reuse "+timeoutReuse);
			this.reuseTimeoutId = setTimeout(function(_){
				// get current time and check timeout of reuse
				traceSessions && traceSessions("setTimeout - isReuse:"+ self.isReuse + " - id:" + self.uuid);	
				if (self.isReuse) {// only if it's reuse 
					// reuse session need to be destroy
					self.sessionConv.destroyReuseClient(_,self);
					self.isReuse = false;
				}
			},timeoutReuse);
		}else{
			this.isReuse = false;
			this.timeToReuse = -1;
			traceSessions && traceSessions("clear timeout");
			clearTimeout(this.reuseTimeoutId);
		}
	},
	isSameContext: function(config){
		// check context for reuse session
		return this.clientConfig.isSameContext(config, traceSessions);
	},
	execOpenFunction: function(_,context){
		var request = {
			act:1077,
			fld : {
				ist : {
					win : "A",
				}
			},
			param : {
				call : {	
					json : {
						"spgm": "GESUSER:CONNECT_FONCTION",
						"params": [
							{
								"dim": 1,
								"nb": 1,
								"size": context.length,
								"typ": "STRU",
								"resu": context
							},
							{
								"dim": 1,
								"nb": 0,
								"size": 1,
								"typ": "STRU"
							}
						]
					},
				}
			},
		};
		return this.processAction(_,request, true);
	},
	connectSart: function(_) {
		this.connecting = true;
		automata.process(_, this);
		var resp = this.getResponse(true);
		traceSessions && traceSessions("START CONNECTING OK:\n" + JSON.stringify(resp, null, 2));
		return resp;
	},
	connectStop:function(_){
		traceAction && traceAction("STOP CONNECTING OK");
		this.connecting = false;
	},
	// connect=true -> connectAction -> new client or openFunc on reuse client -> send settings to client
	// !! Reuse - some settings are received at the first connection (new client) and must be stored in order to be sent to reused client
	processAction: function(_, body, connect) {
		try {
			traceAction && traceAction("************************************");
			traceAction && traceAction("Begin Process Action:\n" + JSON.stringify(body, null, 2));
			this._spy && this._spy.dumpJSON(_, "Process Action", body.act);
			// Create fresh request/reply objects
			var reply = new CvgReply(this, body.act);
			var ctx
			if (body.param && body.param.target){
				var target = body.param.target;
				if (target && target.xid != null) {
					ctx = CvgIst.fromTarget(target);
				}
			}
			this.newActiveRequest(reply, {"ctxNDSLB": ctx, "reqNum": body.tech && body.tech.id ? body.tech.id : 0});	
			var resu, extras = [];
			if (body.fld) {
				if (body.fld.v != null){
					var entity =null;
					if (body.fld.ist) {					
						// Retrieve the instance to obtain the data type of the action's resu
						var ist = CvgIst.fromAction(body.fld.ist);
						traceAction && traceAction("ACTION IST=" + JSON.stringify(ist,null,2));
						entity = this.findModifiable(ist);
						//console.log("ACTION ENTITY=" + util.inspect(entity));
						//if (entity == null) throw new Error("modifiable not found: " + JSON.stringify(body));
						if (entity && entity instanceof CvgVariable) {
							if (entity.dataType == null) throw new Error("data type not found: " + JSON.stringify(body));		
							var value = body.fld.v;	
							try {
								// fmtLocalCtrl=true --> value has been already unformated by client --> value is a raw value
								if (!this.clientConfig.fmtLocalCtrl){
									if (entity.acceptEditFormat() && body.fld.fmtKind === 'EDIT') {
										// deformatage : format edition => format presentation. Peut
										// lever une exception de formatage ou de valorisation
										value = entity.formatEditToDisplay(value);		
										// ajout d'un noeud "ist" "previous" avec la valeur reformatee.
										// Exemple : <ist which="previous" C="B,B,B5" format="show"
										// IstFmt="N+:5.5#">0,02000</ist>
										CvgInstance.newprevious(this, ist, entity.format.format, value, this.activeRequest.reply == null ? false : this.activeRequest.reply.stayInCommandMode);
									}
									// deformatage : format presentation => format brut
									value = entity.unFormatData(value);
								}
								if (value !== undefined) {
									// value is a raw value
									resu = CvgResu.fromAction(entity.dataType, value);
									entity.setBrowserUnformattedValue(resu);
								}
							} catch(e) {
								//console.error("processAction ERROR");
								//console.error(e.stack);
								var instance = CvgInstance.newtarget(this, ist, entity.format.format, body.fld.v, this.activeRequest.reply == null ? false : this.activeRequest.reply.stayInCommandMode);
								instance.exception = e;
								return this.getResponse();
							}	
						}
					}
					if (!body.fld.ist || (entity && !(entity instanceof CvgVariable)) ) {
						var type = typeof body.fld.v === 'string' ? CvgResuTdo["STRU"] : CvgResuTdo["INT"];
						resu = CvgResu.fromAction(type, body.fld.v);
					}					
				}
				// Build the list of extra results to send after the first one
				// For only one optional extra: crsr (cursor position)
				// crsr is serialized directly as an int, not as a resu.
				var crsr = body.fld.ctx && body.fld.ctx.crsr;
				if (crsr != null) extras.push(new CvgResu(CvgResuTdo["INT"], parseInt(body.fld.crsr)));
			}
			if (!resu) resu = new CvgResu(CvgResuTdo["NULL"], null);
			traceProtocol && traceProtocol("Send true value: "+resu.toString());			
			// get action params (action is recorded into params[0])
			var params = _actionParams(body);
			this.activeRequest.listenSendingArgs(body, this, params);
			//this.activeRequest.buildIstDatasOfAction(params[0]);
			// send the action to X3
			x3writer.sendAction(_, this, resu, extras, params);	
			//CvgClient.checkFailed
			// run automata to get callbacks from X3 engine and return response
			automata.process(_, this);
			var resp = this.getResponse(connect);
			traceAction && traceAction("************************************");
			traceAction && traceAction("End Process Action:\n" + JSON.stringify(resp, null, 2));
			return resp;
		}catch(e) {
			this.closeClient(_, e, 102);
			if (e instanceof CvgException) e.diagnose.recovery = "ABORT";
			throw e;
		}
	},
	processSuperAction: function(_, body) {		
		var excludeList = ['target', 'previous'];
		var mergeResponse = function (to, from) {
		    for (var n in from) {
		        if (typeof to[n] !== 'object') {
		            to[n] = from[n];
		        } else if (typeof from[n] === 'object') {
		            if (excludeList.indexOf(n) === -1) {
		            	to[n] = mergeResponse(to[n], from[n]);
		            } else {
		            	to[n] = from[n];
		            }
		        }
		    }
		    return to;
		};		
		traceAction && traceAction("===================================");
		traceAction && traceAction("Process Super Action:\n" + JSON.stringify(body, null, 2));
		//console.error("SuperAction ID: " + body.act);
		var offset = 768, superAction = body.act - offset > 0 ? CvgSuperAction[body.act - offset] : null;
		if (!superAction) throw new Error("Bad super action [" + body.act + "]");
		//console.error("SUPER ACTION: "+JSON.stringify(superAction,null,2));		
		var std = [];
		if (body.param && body.param.sudo) {
			for (var i in body.param.sudo)
				std.push(body.param.sudo[i]);
			delete body.param.sudo;
		}		
		var resp = {}, nextFld;
		for (var i = 0; i < superAction.actions.length; i++) {
			var newBody = JSON.parse(JSON.stringify(body));
			var action = superAction.actions[i];
			//console.error("Process Action: "+JSON.stringify(action,null,2));
			if (!CvgAction[action.name]) throw new Error("Bad sub-action: " + action.name);
			var processNext = true;
			newBody.act = CvgAction[action.name];			
			if (nextFld) {
				newBody.fld.ist = nextFld.ist;
				newBody.fld.v = nextFld.v;
			}			
			if (!action.setTarget) {
				traceAction && traceAction("DELETE TARGET !!!");
				delete newBody.param.target; 
			}
			if (std[i]) {
				newBody.param.std = std[i];
				// Use other action sudo params (action number is added to params)
				if (action.propagate) {
					newBody.param.std.push(CvgAction[action.propagate]);
				}
			}
			var newResp = this.processAction(_, newBody);
			mergeResponse(resp, newResp);
			resp = JSON.parse(JSON.stringify(resp)); // invoke toJSON methods -- improve later
			//console.error("Resp: "+JSON.stringify(resp,null,2));
			var t1 = resp.sap && resp.sap.target && resp.sap.target.type === 'ist' && resp.sap.target.ist;
			if (!t1) break;
			if (action.setTarget) {
				var t0 = newBody.param && newBody.param.target;
				processNext = superAction.processNextAction(CvgAction[action.name], t0, t1, action.checkNumLine);
			}
			//console.error("Process Next: "+processNext);
			if (!processNext) {
				break;
			}else{
				var respTarget = resp.sap.target.ist;
				if (respTarget){
					nextFld = {
						ist: {
							xid: respTarget.xid,
							win: respTarget.win
						},
						v: respTarget.v
					}
					if (respTarget.nl) nextFld.ist.nl = respTarget.nl;
				}
			}				
		}
		return resp;
	},
	processSpecialAction: function(_, body) {
		traceAction && traceAction("===================================");
		traceAction && traceAction("Process Special Action:\n" + JSON.stringify(body, null, 2));
		
		var offset = 512, specialAction = body.act - offset > 0 ? CvgSpecialAction[body.act - offset] : null;
		if (!specialAction) throw new Error("Bad special action [" + body.act + "]");

		if (specialAction.proxy === "srvImp") {
			switch(specialAction.id) {
				case "PRINTER_SEL_OPTS":
					var printerName = body.param && body.param.selpr && body.param.selpr.printerName;
					if (!printerName)
						throw new CvgException(this, null, "printerName is required.", null, "srvImpSvc");
					
					var srvImp = this.activeRequest.srvImp;
					var printClient = PrintClient.createClient(_, srvImp.hostname, srvImp.port);
					var infos = printClient.getAdvancedParameters(_, printerName);
					new CvgImpMore(this, infos);
					printClient.disconnect(_);
					break;
					
				case "PRINTER_SEL_CANCEL":
					// Send empty properties to back office
					x3writer.writeProperties1(_, this, {});
					automata.process(_, this);
					break;
					
				case "PRINTER_SEL_OK":					
					var selected = body.param && body.param.selpr && body.param.selpr.selected
					var printerName = selected.name
					if (!printerName)
						throw new CvgException(this, null, "printerName is required.", null, "srvImpSvc");
					
					var srvImp = this.activeRequest.srvImp;
					var printClient = PrintClient.createClient(_, srvImp.hostname, srvImp.port);
					var extra = printClient.getExtraParameters(_, printerName, null, null, 9);
					printClient.disconnect(_);
					// TODO: Extra could be sent in properties
					//console.log("Extras: "+JSON.stringify(extra,null,2));
					var props = {};
					if (selected.driver) props._PrinterDriver = selected.driver;
					if (selected.name) props._PrinterName = selected.name;
					if (selected.port) props._PrinterPort = selected.port;
					if (srvImp) props._PrinterServer = srvImp.hostname + ":" + srvImp.port;
					if (selected.copies) props._PrinterCopies = selected.copies;
					if (selected.collate) props._PrinterCollate = selected.collate;
					if (selected.startpage) props._PrinterStartPage = selected.startpage;
					if (selected.stoppage) props._PrinterStopPage = selected.stoppage;
					if (selected.orientation) props._Orientation = selected.orientation;
					x3writer.writeProperties1(_, this, props);
					automata.process(_, this);
					break;
					
				case "PRINTER_OPTS_CANCEL":
				case "PRINTER_OPTS_OK":
					console.log("Special action not yet implemented: "+specialAction.id);
					break;
					
				default:
					throw new Error("Unknow SrvImp action [" + specialAction.id + "]");
			}
			return this.getResponse();
		}
		else {
			throw new Error("Bad proxy ["+specialAction.proxy+"] for special action [" + body.act + "]");
		}
	},
	processRequest: function(_, context) {
		if (context.method !== 'put') throw new Error("bad method: " + context.method);
		var act = parseInt(context.parameters.act, 10);
		var body = JSON.parse(context.request.readAll(_));
		var resp="";
		if (parseInt(body.act, 10) !== act) throw new Error("body act mismatch: expected " + act + ", got " + body.act);
		if (this._recorder){
			this._recorder.dumpHttpReq(_, context);
		}
		this._spy && this._spy.dumpJSON(_, "REQUEST", body);
		if (act >= 1024) {
			resp = this.processAction(_, body);
		}else if (act >= 768) {
			resp = this.processSuperAction(_, body);
		}else {
			resp = this.processSpecialAction(_, body);	
		}		
		if (this._recorder){
			this._recorder.dumpHttpResp(_, resp);
		}
		//console.log("RESPONSE: " + JSON.stringify(resp, null, 2));
		this._spy && this._spy.dumpJSON(_, "RESPONSE", resp);
		return resp;
	},
	loadWindowDescription: function(_, ist, winId, funcId, stamp) {
		var self = this, descr;
		function getWindowXml(_, winId) {
			//if (true) return require('fs').readFile(__dirname + "/../data/" + winId + ".xml", "utf8", _);
			var opt = {
				method: "GET",
				url: self.winDescrUrl(winId),
				headers: {}
			}
			if (helpers.proxy && helpers.proxy.server && helpers.proxy.port) {
				opt.proxy = "http://" + helpers.proxy.server + ":" + helpers.proxy.port;
			}
			var request = streams.httpRequest(opt);
			var response = request.end().response(_);
			response.setEncoding('utf8');
			//console.log("statusCode=" + response.statusCode);
			var body = response.readAll(_);
			if (response.statusCode === 200 && body) {
				return body;
			} else {
				throw new Error(response.statusCode + ": " + body);
			}
		}
		if(this.clientConfig.modePLAY){
			// stream fakes data access to X3 and other resources used by cvgClient
			descr = this.stream.readDescr(_);
		}else{
			descr = jsxml.parse(getWindowXml(_, winId)).WIND;
			if (this._recorder) {
				// We need to store description to be able to replay
				this._recorder.dumpWinDescr(_, descr);
			}
		}
		return this.pushRequesterWindow(winId, funcId, descr, stamp, ist.win);
	},
	getMessage: function() {
		var args = [module, arguments[0]];
		for (var i = 1; i < arguments.length; i++){
			args.push(arguments[i] ? arguments[i].toString() : arguments[i]);
		}
		var res = locale.format.apply(null, args);
		return res;
	},
	addAdxIstOfPickedLines: function(aPickedLine) {
		this._pickedLinesIsts.push(aPickedLine);
	},
	addStatusIconDef: function(instance, aNumText, aTxt, aImgId, aActionId) {
		var winFound = null;
		for (var i = 0; i < this.stackedWindows.length && winFound == null; i++) {
			var item = this.stackedWindows[i];
			if (item.getAdxIst().winAlphaId === instance.winAlphaId) {
				winFound = item;
			}
		}
		if (winFound != null) {
			winFound.addStatusIconDef(instance, aNumText, aTxt, aImgId, aActionId);
		}
	},
	clearAdxIstsOfPickedLines: function() {
		this._pickedLinesIsts = [];
	},
	
	closeClient: function(_, e, reason) {
		console.log("CloseClient Convergence Client\n\tReason[" + reason + "]\n\tAlreadyClosed[" + (this.connClient == null || !this.connClient.hasSocket()) + "] - Exception[" + (e == null ? "No" : e.message) + "]");
		new CvgClose(this, reason, e, "");
		// CloseSocket
		if (this.stream) {
			this.stream.end();
			this.stream = null;
		}
	},
	containsAdxPubSubFile: function(aListOfProperties) {
		var wProperty;
		var wMax = aListOfProperties.length;
		var wI = 3; // pour demarer a la 4eme propriete !
		while (wI < wMax) {
			wProperty = aListOfProperties.get(wI);
			if (wProperty.hasId() && wProperty.id.toUpperCase() === "UIAdxPubSubFile".toUpperCase()) {
				return true;
			}
			wI++;
		}
		return false;
	},
	deconnectClient: function(_,reason) {
		try {
			console.log("Deconnect Convergence client\n\tReason[" + (reason == null ? "none" : reason) + "]\n\tAsk X3 server to close ");
			// create a request for deconnection
			var deconnectReq = {
				act : 1075,
				fld : {},
				param : {},
				tech : {}
			};
			return this.processAction(_,deconnectReq);
		} finally {
			this.realeaseActiveRequest();
		}
	},
	executeCallUiOpenFile : function(values){
		var keys = Object.keys(values);
		//console.log(JSON.stringify(values));
		if (keys.length >= 2){
			var localDir = values[keys[1]];
			var localFile = values[keys[2]].replace("\\","/");
			if (localDir === "HTTP"||localDir === "HTTPS"){
				 //construct url to return 
				var url ="";
				if (JSON.stringify(values).indexOf("UIAdxPubSubFile")!=-1){
					var idx = localFile.substring("/");
					url += localFile.substring(idx);

				}else{
					url += localFile;
				}
				new CvgCallUiOpenFile(this,localDir.toLowerCase(),url);
			}
			return {
				
			}
		}
		// else nothin
	},
	execCallUi: function(values) {
		if (values.UIAction === "SessionSettings") {
			return this.executeAllSessionSettings(values);
		} else if (values.UIAction === "SetWindFeatures") {
			return this.executeAllSessionSettings(values);
		} else if (values.UIAction === "Sethangup") {
			return this.executeCallUiSetHangHup(values);
		} else if (values.UIAction === "SetTechnoVers") {
			return this.executeCallUiSetTechnovers(values);
		} else if (values.UIAction === "GetFileAlways") {
			//return this.executeCallUiGetFile(true, values);
		} else if (values.UIAction === "GetFile") {
			//return this.executeCallUiGetFile(false, values);
		} else if (values.UIAction === "PutFileAlways") {
			//return this.executeCallUiPutFile(true, values);
		} else if (values.UIAction === "PutFile") {
			//return this.executeCallUiPutFile(false, values);
		} else if (values.UIAction === "OpenFile") {
			return this.executeCallUiOpenFile(values);
		}
		return;
	},
	executeAllSessionSettings: function(values) {
		var keys = Object.keys(values);
		for (var i = 1; i < keys.length; i++) {
			this._x3SessionSettings[keys[i]] = values[keys[i]];
		}
		// Set formater datePivot
		if (values.DefaultDatePivot != null){
			this.formater.setDatePivot(this._x3SessionSettings.DefaultDatePivot);
		}
		return {
			UIAction: "SessionSettings"
		};
	},
	executeCallUiSetTechnovers: function(values) {
		// TODO manage protocol negociation
		this.executeAllSessionSettings(values);
		return values;
	},
	executeCallUiSetHangHup: function(values) {
		return {
			Sethangup: 1
		};
	},
	findModifiable: function(aStructIst) {
		var wSettableFinder = new CModifiableFinder();
		this.traverseSettable(aStructIst, wSettableFinder);
		return wSettableFinder.foundModifiable;
	},
	getNewStackedWindows: function(aWindowId, aFunctionId, aDescr, aStamp, aWindowIdxBaseOne) {
		return new CvgStackedWindow(this, aWindowId, aFunctionId, aDescr, aStamp, aWindowIdxBaseOne);
	},
	hasActiveRequest: function() {
		return this.activeRequest != null;
	},
	hasApplicationId: function() {
		return this.applicationID != null;
	},
	// Connection messages
	listenNodeND_SLF: function(_, reader, node, properties) {
		//console.log("ND_SLF properties: "+JSON.stringify(properties,null,2));
		var result = this.execCallUi(properties);
		return formatKeyValues(result);
	},
	listenNodeND_GFD: function(_, reader, node, properties) {
		//console.log("ND_GFD properties: "+JSON.stringify(properties,null,2));
		var key = properties[0];
		var result = {};
		result[key] = this.clientConfig.getParam(key);
		if (result[key] === undefined) {
			//console.error("Unsupported param: "+key);
			result[key] = "unsupported";
		}
		return formatKeyValues(result);
	},
	listenNodeNDCOPMENU: function(_, reader, node, data) {
		//reply.setSplashInfos(data);
	},
	listenNodeNDDEB: function(_, reader, node) {},

	listenNodeND_CLT: function(_, reader, node, dummyByte) {
		// 15w_001 - Fiche 36012 - X3Client: Supervision des sockets
		// Si reception du noeud ND_CLT non attendu => not ok fermeture du
		// client depuis le meme thread
		this.closeClient(_, null, this.connecting ? 4 : 3);
	},
	/**
	 * NDACTOBJ (Adxcpl_displayWin) Affichage d'une fenetre Id=[NDACTOBJ]
	 * x3func=[Adxcpl_displayWin] NbArgs=[2] - ist =[ win=[2] srn=[0] blc=[0]
	 * fld=[0] idx=[0]] - opt=[.x04]
	 */
	listenNodeNDACTOBJ: function(_, reader, node, ist, num) {
		var WIN_NOHIDDEN = 4;
		if (num > WIN_NOHIDDEN) {
			var win = this.findModifiable(ist);
			if (win != null && win instanceof CvgStackedWindow) {
				win.setScreenToShow(num - WIN_NOHIDDEN + 1);
			}
		} else {
			// TODO
		}
	},
		
	/**
	 * NDACTOP 0E4000 (Activation_Action) Activation d=[NDACTOP] level=[?]
	 * x3func=[Activation_Action] nb=[2] - ide=[2823] ID Action - typ=[.x01]
	 * Status
	 */
	listenNodeNDACTOP: function(_, reader, node, wActionId, wFlag) {
		new CvgMenuAct(this, wActionId, wFlag);
	},

	/**
	 * Le serveur envoi 3 noeuds ndctsu pour decrire un format dynamique. voir
	 * l'innerclasse "CDynFormat" Id=[NDCTSU] level=[C]
	 * x3func=[Control_DefineType] NbArgs=[3] - opt=[.x65] - su1 =[c] - su2 =[_]
	 */
	listenNodeNDCTSU: function(_, reader, node, wType, wSubType, wComplement) {
		/*
		 * Traite le premier noeud NDCTSU contenant le type. Exemple: Type=[g]
		 * SubType=[] Complement=[] Le noeud correspondant: Id=[NDCTSU]
		 * func=[Control_DefineType] NbArgs=[3] opt=[.x67] su1 =[] su2 =[])
		 */
		if (this.currentDynFormat == null) {
			this.currentDynFormat = new CDynFormat(String.fromCharCode(wType), this.formater);
			this._sessDynFormat.push(this.currentDynFormat);
		}
		/*
		 * Traite le deuxieme noeud NDCTSU contenant le SubType. Exemple:
		 * Type=[g] SubType=[AX] Complement=[] Le noeud correspondant:
		 * Id=[NDCTSU] func=[Control_DefineType] NbArgs=[3] opt=[.x67] su1 =[AX]
		 * su2 =[]
		 */
		else if (this.currentDynFormat.subType == null) {
			this.currentDynFormat.subType = wSubType;
		}
		/*
		 * Traite le troisieme noeud NDCTSU contenant le complement (ou non).
		 * Exemple: Type=[g] SubType=[AX] Complement=[] Le noeud correspondant:
		 * Id=[NDCTSU] func=[Control_DefineType] NbArgs=[3] opt=[.x67] su1 =[AX]
		 * su2 =[]
		 */
		else {
			/*
			 * mis en place du complement, creation du format dynamique dans le
			 * formater, et destroy du format dynamique
			 */
			this.currentDynFormat.complement = wComplement;
			this.formater.addDynamicFormat(this.currentDynFormat);
			this.currentDynFormat = null;
		}
	},

	/**
	 * NDOMNCO 0E015E (MenuDyn_New) Id=[NDOMNCO] level=[R] x3func=[MenuDyn_New]
	 * NbArgs=[5] - flg=[.x58] - cod=[1026] - txt=[Selection] - acc=[0] - hlp
	 * =[] parametre passes a la fonction "MenuDyn_New" du client X3 :
	 *
	 * (*fnd)( (flg&0x40)>>6, fen, (flg&0x08)>>3, cod, txt, acc, (flg&0x7), 0,
	 * (flg&0x10)>>4, (flg&0x20)>>5, hlp ) ;
	 *
	 * bFirst Premiere option (vide la liste) ((wByte & 0x40) >> 6) nRang Rang
	 * d'insertion de l'option (0 pas d'option) nType Type de l'option (flg &
	 * 0x08) >>3) nAction Action a renvoyee au serveur pszText texte de l'option
	 * nAccel Accelerateur nCateg Categorie dans le type (flg&0x7) nImage Numero
	 * de l'image bValide Valide ou bien (flg&0x10)>>4 bSelect Selectionne ou
	 * bien (flg&0x20)>>5 pszhelp texte d'aide rapide
	 */
	listenNodeNDOMNCO: function(_, reader, node, wFlg, wActionId, wTxt) {
		/*
		 * first node => flg=[.x58] others => flg=[.x18]
		 */
		var wVidage = (wFlg & 0x40) !== 0;
		/*
		 * boolean wFlag = ((wByte & 0x40) >> 6) != 0; int wType = ((wByte &
		 * 0x08) >>3); wAcc >> 3
		 */
		var wType = (wFlg & 0x08) >> 3 === 0;
		/*
		 * si ce n'est pas un enoeud de "vidage"
		 */
		if (!wType && wActionId > 0) // ???
		{
			/*
			 * si "vidage" de la liste
			 */
			if (wVidage) {
				this.removeCtxButtons();
			}
			new CvgMenuCtx(this, wActionId, true, wTxt);
		}
	},

	/**
	 * Changement element dans barre de statut Id=[NDOTXSC] level=[W]
	 * x3func=[Status_ChangeStatus] NbArgs=[6] - ist =[ win=[2] srn=[0] blc=[0]
	 * fld=[0] idx=[0]] - st[0]=[.x00] (byte) - st[1]=[132] (int) - buf[0] =[]
	 * (stru) - buf[1] =[] (stru) - st[2]=[3058] (int)
	 */
	listenNodeNDOTXSC: function(_, reader, node, wIst, wNumText, wImgId, wTxt, wTxtDummy, wActionId) {
		this.addStatusIconDef(wIst, wNumText, wTxt, wImgId, wActionId);
	},

	/**
	 * Id=[NDPKAR] func=[LeftList_Picking] NbArgs=[1] - ist =[ win=[2] srn=[34]
	 * blc=[3] fld=[0] idx=[0]]
	 */
	listenNodeNDPKAR: function(_, reader, node) {
		var actArgs;
		if (this._pickedLinesIsts.length > 0) {
			var pickedLine = this._pickedLinesIsts.splice(0, 1)[0];
			var actArgs = [pickedLine.action];
			var ist = pickedLine.ist;
			var line = this.findModifiable(ist);
			if (line != null) {
				// suppression du numero de ligne dans l'adxid de la lisgne pickee ajout de l'argument tdans la liste
				ist.idx = 0;
				actArgs.push(ist);
				// ajout de l'argument tableau de resu qu'est la cle de la ligne  pickee
				actArgs.push(line.cle);
			} else {
				actArgs.push(ist.toString());
				_postDiag(this, this.getMessage('ERROR_CANT_GET_PICKED_LINE_KEY', 'NDPKAR - ' + ist.toString()));
			}
		} else {
			actArgs = [CvgAction.SRV_ABANDON];
		}
		// BRJOU: did not see any resu, pass null
		x3writer.sendAction(_, this, new CvgResu(CvgResuTdo["NULL"], null), [], actArgs);
	},

	listenSegment: function(aSegment) {
		var retour = false;
		retour = TODO_SUPER.listenSegment(aSegment);
		if (!retour && aSegment instanceof CSegmentNode) {
			var wSegmentNode = aSegment;
			var wNodeId = wSegmentNode.nodeId;
			switch (wNodeId) {
			case CvgNode.NDACTOP:
				retour = listenNodeNDACTOP(wSegmentNode);
				break;
			case CvgNode.NDOMNCO:
				retour = listenNodeNDOMNCO(wSegmentNode);
				break;
			case CvgNode.NDCTSU:
				retour = listenNodeNDCTSU(wSegmentNode);
				break;
			case CvgNode.NDOTXSC:
				retour = listenNodeNDOTXSC(wSegmentNode);
				break;
			case CvgNode.NDPKAR:
				retour = listenNodeNDPKAR(wSegmentNode);
				break;
			}
		}
		return retour;
	},
	newActiveRequest: function(reply, sendContext) {
		this.razModifications();
		this.activeRequest = new CvgRequest(this, reply, sendContext);;
		this._trackLists = this.newTrackLists(); // should be inside request???
		return this.activeRequest;
	},
	popRequesterWindow: function() {
		var window = this.stackedWindows.popStackedWindow();
		window.setOpened(false);
		return window;
	},
	pushRequesterWindow: function(aWindowId, aFunctionId, aDescr, aStamp, aWindowIdxBaseOne) {
		var wRequesterWindow = this.getNewStackedWindows(aWindowId, aFunctionId, aDescr, aStamp, aWindowIdxBaseOne);
		this.stackedWindows.pushStackedWindow(wRequesterWindow);
		wRequesterWindow.setStackLevel(this.stackedWindows.length);
		wRequesterWindow.setOpened(true);
		return wRequesterWindow;
	},
	razModifications: function() {
		this.stackedWindows.razModifications();
		this.formater.razModifications();
	},
	realeaseActiveRequest: function() {
		var wActiveRequest;
		wActiveRequest = this.activeRequest;
		this.activeRequest = null;
		if (wActiveRequest != null) {
			//TODO reimpl method -> wActiveRequest.releaseRefs();
		}
	},
	releaseRefs: function() {
		this.formater.end();
		this.formater = null;
		this.motherWindow = null;
		this.stackedWindows = new CvgStackedWindows();
		this.stackedWindows = null;
		this.realeaseActiveRequest();
		this.clientConfig = null;
		this._pickedLinesIsts = null;
		this.applicationID = null;
		this.currentDynFormat = null;
		TODO_SUPER.releaseRefs();

	},
	removeActiveRequest: function(aAdonixReply) {
		var wX3Reply = aAdonixReply;
		if (this.hasActiveRequest()) {
			wX3Reply = this.activeRequest.reply;
			this.realeaseActiveRequest();
		}
		return wX3Reply;
	},
	toString: function(aSeparator) {
		return "";
		var wSB = new StringBuilder(512);
		TODO_SUPER.addDescrInSB(wSB, aSeparator);
		if (aSeparator != null) {
			wSB.append(aSeparator);
		}
		CStringFacilities.addInStringDescr(wSB, "NbParamConfig", this.config.size());
		return wSB.toString();
	},
	traverseSettable: function(aStructIst, aModifier) {
		if (aStructIst.isWindowIst() && aStructIst.winZeroBase === -1) {
			return aModifier.setModifiable(aStructIst, this.motherWindow);
		} else {
			return this.stackedWindows.traverseSettable(aStructIst, aModifier);
		}
	},
	track: function(obj) {
		var list = this._trackLists[obj.jsonType];
		// Allow observable to not send adat - see CvgDiagnose
		if (obj.sendToClient && !obj.sendToClient (list)) return;
		if (obj.getObservableId) {
			// we can add keys directly to the array, they will be ignored by JSON.stringify
			var key = '#' + obj.getObservableId();
			var old = list[key];
			if (old != null){
				list[old] = undefined;
			}
			list[key] = list.length;
		}
		list.push(obj);
	},
	// Fusion
	removeCtxButtons: function() {
		for (var i in this._trackLists) {
			if (this._trackLists[i] instanceof CvgMenuCtx) {
				console.error("instanceof CvgMenuCtx");
			}
		}
	},
	setUserProfile:function(profil){
		if (this._x3SessionSettings.usrProfile !== profil) this._x3SessionSettings.usrProfile=profil;
	},
	winDescrUrl:function(winId){
		var lang = this._x3SessionSettings.cdLang  || "";
		if (lang.trim().length==0) throw new Error('Open window[' + winId + '] failed.\nX3 language code (cdLang) has not been received from X3 server\nPlease check X3 folder[' + this.clientConfig.getParam('x3Folder') + '] configuration');
		var x3HttpPub = this.clientConfig.getParam("x3HttpPub");
		var x3Folder = this.clientConfig.getParam("x3Folder");
		return x3HttpPub + "/" + x3Folder + "/GEN/" + lang + "/FENS/" + winId + ".xml";
	},
	_buildUiClientSettings: function() {
		var res = {};
		for (var i in _uiCliSettings) {
			if (this._sessionSettings[i]) 
				res[_uiCliSettings[i]] = this._sessionSettings[i];
			else if (this._x3SessionSettings[i]) 
				res[_uiCliSettings[i]] = this._x3SessionSettings[i];
		}
		// Add formater settings for client formater
		this.formater.addUiCliSettings(res);
		return res;
	},
	getResponse: function(connect) {
		var t0 = new Date().getTime();
		var lists = this._trackLists;
		var isDefined = function(o) {
				return o !== undefined;
			};
		var wins = {};
		for (var i = 0; i < lists.ENTITY.length; i++) {
			var entity = lists.ENTITY[i];
			if (entity === undefined) continue;

			var win = this.stackedWindows.findWin(entity.getFatherWindowId().charCodeAt(0) - '@'.charCodeAt(0));
			if (win) {
				var winNode = wins[win.entityIdxAlpha];
				if (!winNode) {
					winNode = wins[win.entityIdxAlpha] || {
						entities: {}
					};
					if (win.statusBar) winNode.statBar = win.statusBar.toJSON();
					if (win.title) winNode.tit = win.title;
					wins[win.entityIdxAlpha] = winNode;
				}
				if (entity instanceof CvgEntity) {
					var gridParent = null;
					var line = null;
					if (entity instanceof CvgVariable) {
						line = entity.srcLine;
					} else if (entity instanceof CvgDataSrcLine) {
						line = entity;
					} else if (entity instanceof CvgDataSrc) {
						gridParent = entity;
					}
					if (line != null) {
						gridParent = line.dataSrc;
					}
					if (gridParent != null || line != null) {
						if (gridParent == null) {
							gridParent = line.dataSrc;
						}
						if (gridParent.isBlocGrid()) {
							entity = gridParent;
						}
					}
					
					var jsonKey = entity.getJsonKey();
	
					if (winNode.entities[jsonKey] == null) {
						var jsonEntity = entity.toJSON();
						if (jsonEntity && Object.keys(jsonEntity).length !== 0) winNode.entities[jsonKey] = jsonEntity;
					}
				}
			}
			if (win && win.entityIdxAlpha && Object.keys(wins[win.entityIdxAlpha].entities).length === 0)
				delete wins[win.entityIdxAlpha];
		}

		var response = {
			sap: {},
			session: lists.SESSION[0] || {},
		};
		var sap = response.sap;
		if( lists.MISC && lists.MISC.length != 0 ){
			sap.misc = JSON.parse(JSON.stringify(lists.MISC[0]));
		}

		if (lists.TARGET.length !== 0){
			sap.target = JSON.parse(JSON.stringify(lists.TARGET[lists.TARGET.length - 1]));
		}
		var ctrlFailed = sap.target && sap.target.ist && sap.target.ist.ctrlFailed;
		if (!ctrlFailed && lists.PREVIOUS.length !== 0){
			var previous = JSON.parse(JSON.stringify(lists.PREVIOUS[lists.PREVIOUS.length - 1]));
			sap.previous = {
				v: previous.ist.v,
				xid: previous.ist.xid,
				win: previous.ist.win,
				nl: previous.ist.nl || -1
			}
		}
		var acts = lists.ACT.filter(isDefined);
		if (acts && acts.length !== 0) sap.acts = acts;
		if (lists.RPC.length !== 0 && sap.target && sap.target.type !== 'portal'){
			sap.rpc = JSON.parse(JSON.stringify(lists.RPC[0]));
		}		
		for (var i = 0; i < lists.FUNC.length; i++) {
			sap.func = sap.func || {};
			var win = lists.FUNC[i];
			var key = win && win.entityIdxAlpha;
			if (win && win.isOpened()) {
				// object with key: win 
				sap.func.open = sap.func.open || {};
				sap.func.open[key] = win;
			} else if(win) {
				// just an array of keys
				sap.func.close = sap.func.close || [];
				sap.func.close.push(key);
//				wins[key] = {
//					tit: win.title,
//					entities: {}
//				};
			}
		}
		if (Object.keys(wins).length > 0) sap.wins = wins;
		if (sap.target && sap.target.ist){
			for (var i = 0; i < lists.TARGETACT.length; i++) {
				sap.target.ist.acts = sap.target.ist.acts || [];
				sap.target.ist.acts.push(lists.TARGETACT[i]);
			}
		}		
		for (var i = 0; i < lists.REPORT.length; i++) {
			sap.jobs = sap.jobs || {};
			sap.jobs.report = sap.jobs.report || {};
			var report = lists.REPORT[i];
			var kind = report.kind;
			sap.jobs.report[kind] = sap.jobs.report[kind] || [];
			sap.jobs.report[kind].push(JSON.parse(JSON.stringify(report)));
		}
		if (true === connect){
			// Add session settings only at connection
			if (this._sessDynFormat.length > 0) {
				// add dynamic formats 
				this._sessionSettings.fmtExt = {};
				for (var i in this._sessDynFormat) {
					var item = this._sessDynFormat[i];
					this._sessionSettings.fmtExt[item.type] = item.toJSon();
				}
			}
			if (!this._sessionSettings.mnu){
				// Add menus only if received
				// !! Reuse session - We must store menus received at first connexion 
				this._sessionSettings.mnu = lists.SESSIONMNU;
			}
			response.session.settings = this._buildUiClientSettings();
		}		
		response.srvop = {};
		// request object 
		var nreq = this.activeRequest.sendContext.reqNum;
		response.srvop.request = {
			"id": nreq,
			"v": this.activeRequest.reply.actionId,
			"connect": 1,
			"status": this.activeRequest.status,
			"session":this.sessionId,
			"server": os.hostname()
		};
		for (var i = 0; i < lists.DIAGNOSE.length; i++) {
			response.srvop.$diagnoses = response.srvop.$diagnoses || [];
			response.srvop.$diagnoses.push(JSON.parse(JSON.stringify(lists.DIAGNOSE[i])));
		}	
		var t1 = new Date().getTime() - t0;
		response.toJsonTime = (t1/1000)%60;		
		// add sessionInfo
		if (true === connect){
			// Add session info at connection
			response.srvop.sessionInfo = {
				reused : this.reused,
				runtime : {}
			};
			response.srvop.sessionInfo.runtime.folder = this.clientConfig.getParam("x3Folder");
		}
		return response;
	}
});
