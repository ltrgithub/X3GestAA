"use strict";
var helpers = require('syracuse-core/lib/helpers');
var flows = require("streamline/lib/util/flows");
var datetime = require("syracuse-core/lib/types/datetime");
var locale = require("syracuse-core/lib/locale");
var automata = require("syracuse-x3/lib/convergence/automata/x3Automata");
var BoRestClient = require("syracuse-x3/lib/boRestClient").BoRestClient;
var sessionManager = require('syracuse-session/lib/sessionManager').sessionManager;
var x3writer = require("syracuse-x3/lib/convergence/automata/x3writer");
var fs = require('streamline-fs');
var jsxml = require('jsxml');
var httpClient = require("syracuse-httpclient/lib/httpClient");
var os = require('os');
var x3helpers = require('syracuse-x3/lib/helpers');
var CvgClientConfig = require("syracuse-x3/lib/convergence/model/CvgClientConfig").CvgClientConfig;
var CvgModifier = require('syracuse-x3/lib/convergence/model/CvgModifier').CvgModifier;
var CvgEntity = require('syracuse-x3/lib/convergence/model/CvgEntity').CvgEntity;
var CvgStackedWindows = require('syracuse-x3/lib/convergence/model/CvgStackedWindows').CvgStackedWindows;
var CvgStackedWindow = require('syracuse-x3/lib/convergence/model/CvgStackedWindow').CvgStackedWindow;
var CvgReply = require('syracuse-x3/lib/convergence/client/CvgReply').CvgReply;
var CvgRequest = require('syracuse-x3/lib/convergence/client/CvgRequest').CvgRequest;
var CvgInstance = require('syracuse-x3/lib/convergence/model/CvgInstance').CvgInstance;
var CvgStatusBar = require('syracuse-x3/lib/convergence/model/CvgStatusBar').CvgStatusBar;
var CvgCallUiOpenFile = require('syracuse-x3/lib/convergence/model/CvgCallUiOpenFile').CvgCallUiOpenFile;
var CvgDataSrc = require('syracuse-x3/lib/convergence/model/CvgDataSrc').CvgDataSrc;
var CvgDataSrcLine = require('syracuse-x3/lib/convergence/model/CvgDataSrcLine').CvgDataSrcLine;
var CvgVariable = require('syracuse-x3/lib/convergence/model/CvgVariable').CvgVariable;
var CvgIst = require('syracuse-x3/lib/convergence/types/CvgIst').CvgIst;
var CvgResu = require('syracuse-x3/lib/convergence/types/CvgResu').CvgResu;
var CvgResuTdo = require('syracuse-x3/lib/convergence/types/CvgResu').TDO;
var CvgAction = require('syracuse-x3/lib/convergence/client/CvgAction').Actions;
var CvgSuperAction = require('syracuse-x3/lib/convergence/client/CvgAction').SuperActions;
var CvgSpecialAction = require('syracuse-x3/lib/convergence/client/CvgAction').SpecialActions;
var CvgException = require('syracuse-x3/lib/convergence/model/CvgException').CvgException;
var PrintClient = require('syracuse-x3/lib/clients/print/PrintClient');
var PrintHelpers = require('syracuse-x3/lib/clients/print/PrintHelpers');
var CvgMenuAct = require('syracuse-x3/lib/convergence/model/CvgMenuAct');
var CvgMenuCtx = require('syracuse-x3/lib/convergence/model/CvgMenuCtx');
var CvgClose = require('syracuse-x3/lib/convergence/model/CvgClose');
var CvgImp = require('syracuse-x3/lib/convergence/model/CvgImp');
var CONNECT_ACTION = require('syracuse-x3/lib/convergence/client/CvgAction').CONNECT_ACTION;
var CvgServices = require('syracuse-x3/lib/convergence/client/CvgClientServices');
var CvgDiagnose = require('syracuse-x3/lib/convergence/model/CvgDiagnose');
var CvgCacheManager = require('syracuse-x3/lib/cvgCacheManager').CvgCacheManager;
var perfmon = require('syracuse-perfmon');
var globals = require('streamline/lib/globals');
var Tracer = require('syracuse-collaboration/lib/entities/x3SessionConfig').Tracer;
var CvgObserver = require("syracuse-x3/lib/convergence/client/CvgObserver").CvgObserver;
var CvgPlugin = require("syracuse-x3/lib/convergence/client/CvgPlugin").CvgPlugin;

var localConfig = x3helpers.config("x3fusion", null, {});

var tracerStd = require("syracuse-trace/lib/helper").getTracer("classic.std");
var tracerAction = require("syracuse-trace/lib/helper").getTracer("classic.action");
var tracerProtocol = require("syracuse-trace/lib/helper").getTracer("classic.protocol");
var tracerSession = require("syracuse-trace/lib/helper").getTracer("classic.session");

var perfmonEnabled = x3helpers.config("perfmon.activate", localConfig);
var perfmonDetail = x3helpers.config("perfmon.detail", localConfig);
var perfConfig = localConfig.perfmon || {};

var cacheMgr = new CvgCacheManager();



// Setting sent to client at connection
var _uiCliSettings = {
	"ADXVersion": "ADXVersion",
	"adonix.port": "ADXPort",
	"usrProfile": "usrProfile",
	"x3host": "ADXAppHost",
	"Version": "Version",
	"ADXProduct": "ADXProduct",
	"Protocol": "Protocol",
	"STime": "STime",
	"SDecimal": "SDecimal",
	"ADXLangIso": "ADXLangIso",
	"SThousand": "SThousand",
	"adonix.host": "ADXTrtHost",
	"AdxSolution": "AdxSolution",
	"ADXProductPref": "ADXProductPref",
	"ADXProductLabel": "ADXProductLabel",
	"SetMonthList": "SetMonthList",
	"formater.von": "formater.von",
	"SDate": "SDate",
	"ADXProductInfoVers": "ADXProductInfoVers",
	"ADXSupVers": "ADXSupVers",
	"mnu": "mnu",
	"DefaultDatePivot": "datePivot",
	"x3user": "user",
	"ADXTheme": "ADXTheme",
	"ADXHttpPub": "ADXHttpPub",
	"ADXNamedUser": "ADXNamedUser",
	"ADXfolder": "ADXFolder",
	"cdLang": "cdLang",
	"DefaultDateFormat": "DefaultDateFormat",
	"fmtExt": "fmtExt",
	"ADXStyleFile": "ADXStyleFile",
	"ADXNopatch": "ADXNopatch",
	"ADXRelease": "ADXRelease",
	"IDate": "IDate",
	"ADXProductSuff": "ADXProductSuff",
	"BOSEC": "BOSEC",
	"BOSERV": "BOSERV",
	"BOUSR": "BOUSR",
	"BOPWD": "BOPWD",
	"ADXMaskAppName": "ADXMaskAppName",
	"ADXHelpLocation": "ADXHelpLocation"
};

function _postDiag(client, msg, detail) {
	CvgDiagnose.create(client, 'WARNING', 99, msg, detail, null, "Protocol", null, true);
}

function _actionParams(body) {
	// params passed to listenSendingArgs are [action, ist (or null ist), params added by append2ActionParams]
	var params = [body.act];
	if (!body.param) {
		return params;
	}
	var target = body.param.target;
	if (target && target.xid != null) {
		params.push(CvgIst.fromTarget(target));
	}
	if (body.param.std) {
		params = params.concat(body.param.std);
	}

	return params;
}

var CModifiableFinder = helpers.defineClass(function() {
	CvgModifier.call(this);
	this.foundModifiable = null;
}, CvgModifier, {
	setModifiable: function(ist, aModifiable) {
		this.foundModifiable = aModifiable;
		this.done = true;
		return this.done;
	}
});

var CMotherWindow = helpers.defineClass(function(aClient) {
	CvgEntity.call(this, aClient, "&ROOT", 1, 'WINDOW');
}, CvgEntity, {
	getAdxId: function() {
		return "mostherWindow - &ROOT";
	},
	toJson: function() {
		throw new Error("Bad tojson MotherWin");
	}
});

exports.CvgClient = helpers.defineClass(function(_, cvgSession, stream, aConfig, recorder, context) {
	CvgObserver.call(this);


	var x3server = context.endpoint.x3server(_);
	var up = context.httpSession.getUserProfile(_);
	var user = "";
	if (up) {
		user = up.user(_) ? up.user(_).getEndpointLogin(_, context.endpoint.$uuid) : "";
	}
	this.response = {
		head: {
			statusCode: 200
		},
		body: {}
	};
	this.syraSessionCookie = null;
	// intregration ILOG -  SAM 91439
	this.cvgPlugin = {}; // instance of plugin interface by node (ilog, etc...)
	this.funnelAction = flows.funnel(1);
	this.cvgWinStubPath = "/../data/";
	this.askKill = false;
	this.lastAckCallSpgmId = [];
	this.isProcessingRequest = false;
	this.timing = {};
	this.srvTrace = null;
	this.baseUrl = context.baseUrl;
	this.endpointDataset = context.endpoint.dataset(_);
	this.callUiOpenFile = null;
	this.recorder = recorder;
	this.creationDate = datetime.now();
	this.stream = stream;
	this.clientConfig = new CvgClientConfig(this, aConfig);
	this.printConfig = aConfig.printConfig || {};
	this._trackLists = this.newTrackLists();
	this._sessionSettings = {};
	this._x3SessionSettings = {};
	this.activeRequest = null;
	this._pickedLines = [];
	this._dynFormats = {};
	this._curDynFmt = null;
	this.uuid = helpers.uuid.generate();
	this._motherWin = new CMotherWindow(this);
	this._stackedWin = new CvgStackedWindows();
	// added by BRJOU - open not called any more
	this.newActiveRequest(new CvgReply(this, CONNECT_ACTION), {
		"reqNum": 0
	});
	this.connecting = false;
	this.isReuse = false;
	this.reused = false; // for the settings
	this.timeToReuse = -1; // time when the client was set in reuse
	this._cvgSession = cvgSession;
	this.services = CvgServices.create(this);
	this.sessInfo = {
		nodeWS: true,
		node: {
			sid: this._cvgSession.sid,
			sessSettings: sessionManager.getSettings(_),
			x3user: user,
			x3host: x3server.serverHost(_),
			x3port: x3server.serverPort(_),
			x3name: x3server.serverName(_)
		},
		runtime: {
			x3user: user,
			x3host: x3server.serverHost(_),
			x3port: x3server.serverPort(_)
		}

	};
	this.context = context;
	this.boClient = new BoRestClient(_, null, null, context);
	this.orchestraTracker = null; // function to call to stop tracker. will be assign to the plugin function or client function depending of the context
	this.getUiSpecialOrders = {
		GetBoToken: "executeGetUiBO",
		GetBoHost: "executeGetUiBO",
		GetBoPort: "executeGetUiBO"
	};
}, CvgObserver, {
	setCvgSession: function(session) {
		this._cvgSession = session;
		var si = this.sessInfo;
		if (session && si && si.node) si.node.sid = session.sid;
	},
	read: function(_, len, withTimeout) {
		try {
			return this.stream.read(_, len, withTimeout);
		} catch (e) {
			if (e.code === "ETIMEOUT") {
				e.message = locale.format(module, "x3ReadTimeout", len, this.stream.available());
			}
			// destroy stream
			this.stream.destroy();
			this.stream = null;
			//
			tracerStd.error && tracerStd.error(e.stack);
			throw e;
		}
	},
	newTrackLists: function() {
		return {
			SESSION: [],
			SESSIONOPEN: [],
			ACT: [],
			TARGETACT: [],
			SESSIONMNU: [],
			TARGET: [],
			MISC: [],
			ENTITY: [],
			FUNCO: [],
			FUNCC: [],
			RPC: [],
			WINDOW: [],
			DIAGNOSE: [],
			GLDIAGNOSE: [],
			REPORT: []
		};
	},
	setInReuseMode: function(_, yes) {
		tracerSession.info && tracerSession.info("setInReuseMode + " + yes);
		if (this.boClient.token) {
			this.boClient.logoff();
		}
		if (yes) {
			this.stopRecord();
			this.isReuse = true;
			this.reused = true;
			this.timeToReuse = (new Date()).getTime();
			tracerSession.info && tracerSession.info("set timeout");
			var timeoutReuse = this.clientConfig.getParam("timeoutReuse");
			var self = this;
			tracerSession.info && tracerSession.info("timeout reuse " + timeoutReuse);
			this.reuseTimeoutId = flows.setTimeout(function(_) {
				// get current time and check timeout of reuse
				tracerSession.info && tracerSession.info("setTimeout - isReuse:" + self.isReuse + " - id:" + self.uuid);
				if (self.isReuse) { // only if it's reuse
					// reuse session need to be destroy
					if (self._cvgSession) {
						self._cvgSession.destroyReuseClient(_, self);
					}
					self.isReuse = false;
				}
			}, timeoutReuse);
		} else {
			this.isReuse = false;
			this.timeToReuse = -1;
			tracerSession.info && tracerSession.info("clear timeout");
			clearTimeout(this.reuseTimeoutId);
		}
	},
	isSameContext: function(config) {
		// check context for reuse session
		return this.clientConfig.isSameContext(config, tracerSession);
	},
	execOpenFunction: function(_, context, tracker) {
		try {
			// retrieve the current session syracuse cookie
			var secure = (context.request.hosting && context.request.hosting.https) || (context.request.connection && 'authorized' in context.request.connection);
			this.syraSessionCookie = sessionManager.secureCookie(secure, sessionManager.getSyracuseCookie(context.request.session, context.request.connection && context.request.connection.localPort));

			this.cvgPlugin = {}; // instance of plugin interface by node (ilog, etc...)

			this.currentTracker = tracker; // set current tracker
			this.orchestraStopTracker = this.stopTracker; // default one

			var ctx = context.parameters.f;
			var request = {
				act: 1077,
				fld: {
					ist: {
						win: "A",
						xid: "@@0"
					}
				},
				param: {
					target: {
						"win": "A",
						"xid": "@@0"
					},
					std: [{
						json: {
							"spgm": "GESUSER:CONNECT_FONCTION",
							"params": [{
								"dim": 1,
								"nb": 1,
								"size": ctx.length,
								"typ": "STRU",
								"resu": ctx
							}, {
								"dim": 1,
								"nb": 0,
								"size": 1,
								"typ": "STRU"
							}]
						}
					}]
				}
			};
			this.processAction(_, request, true);
			// set the head of the response
			this.response.head.location = context.baseUrl + "/$sessions('" + this._cvgSession.sid + "')";
		} finally {
			this.stopTracker && this.stopTracker(_, context, this, true); // if ochrestraTracker is empty we stop the tracker of the client
		}

	},
	recordTiming: function(timer, action, funcName, result) {
		var t = timer.end(result);
		if (perfConfig.clientRecord) {
			this.timing.action = this.timing.action || {};
			this.timing.action[action] = this.timing.action[action] || {};
			this.timing.action[action][funcName] = this.timing.action[action][funcName] || [];

			this.timing.action[action][funcName].push({
				duration: t && t.duration || 0
			});
		}
	},
	connectStart: function(_, context, tracker) {
		try {
			// retrieve the current syracuse session cookie
			var secure = (context.request.hosting && context.request.hosting.https) || (context.request.connection && 'authorized' in context.request.connection);
			this.syraSessionCookie = sessionManager.secureCookie(secure, sessionManager.getSyracuseCookie(context.request.session, context.request.connection && context.request.connection.localPort));

			this.cvgPlugin = {}; // instance of plugin interface by node (ilog, etc...)

			this.currentTracker = tracker; // set current tracker
			this.orchestraStopTracker = this.stopTracker; // default one

			var timing = perfmonEnabled && perfmon.start(module, 'cvgClient.connectStart');
			this.connecting = true;
			automata.process(_, this, this.activeRequest, {
				title: "action",
				detail: "connect"
			});
			tracerSession.info && tracerSession.info("START CONNECTING OK:\n" + JSON.stringify(this.response, null, 2));
			var startConnect = new Date().getTime();
			this.response.head = {
				location: context.baseUrl + "/$sessions('" + this._cvgSession.sid + "')",
				"syra-proxy-time": new Date().getTime() - startConnect
			};
			if (perfmonEnabled) {
				this.recordTiming(timing, "connect", "connectStart", {
					status: this.response.statusCode
				});
			}
			this.logSession(_, "INFO", "connect CvgClient    uuid=[" + this.uuid + "]");
		} finally {
			this.stopTracker && this.stopTracker(_, context, this, true); // if ochrestraTracker is empty we stop the tracker of the client
		}
	},
	connectStop: function(_) {
		tracerSession.info && tracerSession.info("STOP CONNECTING OK");
		this.connecting = false;
	},
	// connect=true -> connectAction -> new client or openFunc on reuse client -> send settings to client
	// !! Reuse - some settings are received at the first connection (new client) and must be stored in order to be sent to reused client
	processAsyncAction: function(_, body, connect, mergeMode, noResp) {
		var self = this;
		var timing = perfmonEnabled && perfmon.start(module, 'cvgClient.processAction', body.act);
		try {
			var pendingNode;
			tracerAction.info && tracerAction.info("************************************");
			tracerAction.info && tracerAction.info("Begin Process Action:\n" + JSON.stringify(body, null, 2));
			if (self.recorder) {
				self.recorder.dumpAction(_, body.act, false);
			}
			// Create fresh request/reply objects
			var reply = new CvgReply(self, body.act);
			var target = body.param && body.param.target;
			if (target && target.xid != null) {
				self.ctxNDSLB = CvgIst.fromTarget(target);
			} else {
				target = null;
			}
			// get action params (action is recorded into params[0])
			var params = _actionParams(body);
			// cleanup blocking node...
			if (params) {
				pendingNode = self.activeRequest.workingCtx.pendingBlockingNode;
				if (pendingNode && pendingNode.act === params[0]) {
					delete self.activeRequest.workingCtx.pendingBlockingNode;
				}
			}

			self.newActiveRequest(reply, {
				"ctxNDSLB": self.ctxNDSLB,
				"reqNum": body.tech && body.tech.id ? body.tech.id : 0,
				"target": target,
				"connect": connect
			}, mergeMode, noResp);

			var resu, extras = [];
			if (body.fld) {
				if (body.fld.v != null) {
					var entity = null;
					if (body.fld.ist) {
						// Retrieve the instance to obtain the data type of the action's resu
						var ist = CvgIst.fromAction(body.fld.ist);
						tracerAction.info && tracerAction.info("ACTION IST=" + JSON.stringify(ist, null, 2));
						entity = self.findModifiable(ist);
						//console.log("ACTION ENTITY=" + util.inspect(entity));
						if (entity && entity instanceof CvgVariable) {
							if (entity.dataType == null) {
								throw new Error("data type not found: " + JSON.stringify(body));
							}
							var value = body.fld.v;
							try {
								if (value !== undefined) {
									// value is a raw value
									if (entity.dataType === CvgResuTdo.BLOB) { // blob case the value is not send by the client but is store in blobSvc
										value = (self.services.blobSvc.getBlob(value) ? self.services.blobSvc.getBlob(value).binary : "");
									}
									// != null is appropriate to test not null and not undefined
									if (value != null) {
										resu = CvgResu.fromAction(entity.dataType, value);
										entity.setBrowserUnformattedValue(resu);
									}
								}
							} catch (e) {
								console.error("processAction ERROR");
								console.error(e.stack);
								var instance = CvgInstance.newtarget(self, ist, entity.format.format, body.fld.v, self.activeRequest.reply ? self.activeRequest.reply.stayInCommandMode : false);
								instance.exception = e;
							}
						}
					}
					if (!body.fld.ist || (entity && !(entity instanceof CvgVariable))) {
						var type = typeof body.fld.v === 'string' ? CvgResuTdo.STRU : CvgResuTdo.INT;
						resu = CvgResu.fromAction(type, body.fld.v);
					}
				}
				// Build the list of extra results to send after the first one
				// For only one optional extra: crsr (cursor position)
				// crsr is serialized directly as an int, not as a resu.
				// The EXTRA is added only on first action when it's a super action (!mergeMode)
				var crsr = body.fld.ctx && body.fld.ctx.crsr;
				if (!mergeMode && crsr != null) {
					extras.push(new CvgResu(CvgResuTdo.INT, parseInt(crsr, 10)));
				}
			}
			if (!resu) {
				resu = new CvgResu(CvgResuTdo.NULL, null);
			}
			tracerProtocol.info && tracerProtocol.info("Send true value: " + resu.toString());
			self.activeRequest.listenSendingArgs(body, self, params);
			//this.activeRequest.buildIstDatasOfAction(params[0]);
			// send the action to X3
			x3writer.sendAction(_, self, resu, extras, params);
			//CvgClient.checkFailed
			// run automata to get callbacks from X3 engine and return response

			automata.process(_, self, self.activeRequest, {
				title: "action",
				detail: params[0]
			});

			//var resp = self.getResponse(_, connect);
			if (perfmonEnabled) {
				self.recordTiming(timing, params[0], "processAction");
			}
			tracerAction.info && tracerAction.info("************************************");
			tracerAction.info && tracerAction.info("End Process Action:\n" + JSON.stringify(self.response, null, 2));

			//return resp;
		} catch (e) {
			tracerAction.error && tracerAction.error("processAction error\n" + (e.stack || e));
			self.closeClient(_, e, 102);
			if (e instanceof CvgException) {
				e.diagnose.recovery = "ABORT";
			}
			throw e;
		} finally {
			if (perfmonEnabled) {
				timing.end();
			}

		}
	},
	processAction: function(_, body, connect, mergeMode, noResp) {
		var self = this;

		function exec(_) {
			self.processAsyncAction(_, body, connect, mergeMode, noResp);
		}
		this.funnelAction(_, exec);
	},
	processSuperAction: function(_, body) {
		var self = this;
		tracerAction.info && tracerAction.info("===================================");
		tracerAction.info && tracerAction.info("Process Super Action:\n" + JSON.stringify(body, null, 2));

		//console.error("SuperAction ID: " + body.act);
		var offset = 768,
			superAction = body.act - offset > 0 ? CvgSuperAction[body.act - offset] : null;
		if (!superAction) {
			throw new Error("Bad super action [" + body.act + "]");
		}
		//console.error("SUPER ACTION: "+JSON.stringify(superAction,null,2));
		if (this.recorder) {
			this.recorder.dumpAction(_, body.act, true);
		}
		var i1, std = [];
		if (body.param && body.param.sudo) {
			for (i1 in body.param.sudo) {
				std.push(body.param.sudo[i1]);
			}
			delete body.param.sudo;
		}
		var resp = {},
			nextFld;
		var i, newBody, action, j, processNext, t0, t1, target, respTarget, stop = false;
		for (i = 0; i < superAction.actions.length && !stop; i++) {
			newBody = JSON.parse(JSON.stringify(body));
			action = superAction.actions[i];
			j = i;
			do {
				//console.error("Process Action: "+JSON.stringify(action,null,2));
				if (!CvgAction[action.name]) {
					throw new Error("Bad sub-action: " + action.name);
				}
				processNext = true;
				newBody.act = CvgAction[action.name];
				if (nextFld) {
					newBody.fld.ist = nextFld.ist;
					newBody.fld.v = nextFld.v;
				}
				if (!action.setTarget) {
					tracerAction.info && tracerAction.info("DELETE TARGET !!!");
					delete newBody.param.target;
				}
				if (std[j]) {
					newBody.param.std = std[j];
					// Use other action sudo params (action number is added to params)
					if (action.propagate) {
						newBody.param.std.push(CvgAction[action.propagate]);
					}
				}
				this.processAction(_, newBody, false, j !== 0);
				target = this.getTarget();
				t1 = target && target.type === 'ist' && target.ist;
				if (!t1) {
					stop = true;
				}
				if (action.setTarget) {
					t0 = newBody.param && newBody.param.target;
					processNext = superAction.processNextAction(CvgAction[action.name], t0, t1, action.checkNumLine, self);
				}
				//console.error("Process Next: "+processNext + " action.setTarget: "+action.setTarget);
				if (processNext) {
					respTarget = target.ist;
					if (respTarget) {
						nextFld = {
							ist: {
								xid: respTarget.xid,
								win: respTarget.win
							},
							v: respTarget.v
						};
						if (respTarget.nl) {
							nextFld.ist.nl = respTarget.nl;
						}
					}
				} else {
					stop = true;
					break;
				}
				j++;
			} while (j < std.length && action.isLoop);
		}
		return resp;
	},
	processSpecialAction: function(_, body) {
		tracerAction.info && tracerAction.info("===================================");
		tracerAction.info && tracerAction.info("Process Special Action:\n" + JSON.stringify(body, null, 2));

		// raz modification
		this.razModification();
		var offset = 512,
			specialAction = CvgSpecialAction[body.act];
		if (!specialAction) {
			throw new Error("Bad special action [" + body.act + "]");
		}

		if (specialAction.proxy === "srvImp") {
			var printerName, srvImp, printClient = null;
			srvImp = this.activeRequest.srvImp;
			// Create fresh request/reply objects
			var reply = new CvgReply(this, body.act);
			var target = body.param && body.param.target;
			if (target && target.xid != null) {
				this.ctxNDSLB = CvgIst.fromTarget(target);
			}
			this.newActiveRequest(reply, {
				"ctxNDSLB": this.ctxNDSLB,
				"reqNum": body.tech && body.tech.id ? body.tech.id : 0,
				"target": body.param && body.param.target,
				"connect": false
			}, false);
			if (srvImp) {
				this.activeRequest.srvImp = srvImp;
			}

			switch (specialAction.id) {
				case "PRINTER_SEL_OPTS":
					printerName = body.param && body.param.selpr && body.param.selpr.printerName;
					if (!printerName) {
						throw new CvgException(this, null, "printerName is required.", null, "srvImpSvc");
					}
					try {
						printClient = PrintClient.getClient(_, srvImp.hostname, srvImp.port, srvImp.id);
						var infos = printClient.getAdvancedParameters(_, printerName, body.param.selpr.port, body.param.selpr.driver);
						CvgImp.more(this, infos);
					} catch (e) {
						if (printClient) {
							printClient.panicRelease();
							printClient = null;
						}
						var diag = new CvgDiagnose(this, 'INFO', 99, locale.format(module, "GET_PRINTER_OPT_1"), '"' + srvImp.hostname + ":" + srvImp.port + '" : ' + (e.message || ""), e, "Protocol [processSpecialActionPRINTER_SEL_OPTS]", null, false);
						CvgImp.more(this, null, diag);
					}
					break;

				case "PRINTER_SEL_CANCEL":
					// Send empty properties to back office
					delete this.activeRequest.workingCtx.pendingBlockingNode;
					x3writer.props1Serializer.write(_, this, {});
					automata.process(_, this, this.activeRequest, {
						title: "special",
						detail: "PRINTER_SEL_CANCEL"
					});
					break;

				case "PRINTER_SEL_OK":
					var selected = body.param && body.param.selpr && body.param.selpr.selected;
					delete this.activeRequest.workingCtx.pendingBlockingNode;
					printerName = selected.name;
					if (!printerName) {
						// Send empty properties to back office
						delete this.activeRequest.workingCtx.pendingBlockingNode;
						x3writer.props1Serializer.write(_, this, {});
						automata.process(_, this, this.activeRequest, {
							title: "special",
							detail: "PRINTER_SEL_OK_1"
						});
						break;
					}
					var props = {},
						paperProps, devmode = {};
					if (selected.driver) {
						props._PrinterDriver = selected.driver;
					}
					if (selected.name) {
						props._PrinterName = selected.name;
					}
					if (selected.port) {
						props._PrinterPort = selected.port;
					}
					if (srvImp) {
						props._PrinterServer = srvImp.hostname + ":" + srvImp.port;
					}
					props._PrinterCopies = selected.copies || 1;
					if (selected.collate !== null && selected.collate !== undefined) {
						props._PrinterCollate = selected.collate;
					}
					if (selected.startPage) {
						props._PrinterStartPage = selected.startPage;
					}
					if (selected.stopPage) {
						props._PrinterStopPage = selected.stopPage;
					}
					if (selected.orientation !== null && selected.orientation !== undefined) {
						props._Orientation = selected.orientation;
					}
					devmode.duplex = selected.duplex && typeof selected.duplex === "string" ? parseInt(selected.duplex, 10) : selected.duplex;
					// Check paper size/source
					if (printerName && (selected.paperSize || selected.paperSource)) {
						try {
							printClient = PrintClient.getClient(_, srvImp.hostname, srvImp.port, srvImp.id);
						} catch (e) {
							if (printClient) {
								printClient.panicRelease();
								printClient = null;
							}
						}
						if (printClient) {
							//console.log("\t Papers props IN for " + printerName + " : size=" + selected.paperSize + " source=" + selected.paperSource);
							paperProps = printClient.checkPrinterPaper(_, printerName, selected.port, selected.driver, selected.paperSize || null, selected.paperSource || null);
							if (paperProps) {
								//console.log("\t Papers props OUT" + JSON.stringify(paperProps,null, 2));
								devmode.paperSize = paperProps.paperSize;
								devmode.paperSource = paperProps.paperSource;
							}
						}
					}
					PrintHelpers.setDevmodeInSrvProperties(devmode, props);
					//console.log("NDGTIM Properties OUT: " + JSON.stringify(props, null, 2));
					x3writer.props1Serializer.write(_, this, props);
					automata.process(_, this, this.activeRequest, {
						title: "special",
						detail: "PRINTER_SEL_OK_2"
					});
					break;

				case "PRINTER_OPTS_CANCEL":
				case "PRINTER_OPTS_OK":
					CvgImp.config(this, null);
					break;

				default:
					throw new Error("Unknow SrvImp action [" + specialAction.id + "]");
			}

			//return this.getResponse(_);
		} else if (specialAction.proxy === "plugin") {
			switch (specialAction.id) {
				case "CLIENT_PLUGIN_REPLY":
					// call method that construct the property as expected by the runtime with the input
					this._clientReplyPlugin(_, "ilog-default", body);
					this.orchestraTracker = null; // no stop of tracker client and plugin - need polling

					break;
				case "CLIENT_DELETE":
					// call method that construct the property as expected by the runtime with the input

					this._clientDeletePlugin(_, "ilog-default", body);
					this.orchestraTracker = this;
					automata.process(_, this, this.activeRequest, {
						title: "special",
						detail: "CLIENT_DELETE"
					});
					break;
				default: // it's the plugin that catch the request and all node
					throw new Error("Unknow SrvImp action [" + specialAction.id + "]");

			}
		} else {

			throw new Error("Bad proxy [" + specialAction.proxy + "] for special action [" + body.act + "]");
		}
	},
	_clientReplyPlugin: function(_, defaultId, body) {
		var id = body && body.param && body.param.plugin && body.param.plugin.id || defaultId;
		if (!this.cvgPlugin.ND_IHM[id]) { //first  client request must associate with id of plugin if it's not the case
			this.cvgPlugin.ND_IHM[id] = this.cvgPlugin.ND_IHM["ilog-default"];
		}
		if (this.cvgPlugin.ND_IHM[id]) {
			if (this.id !== "ilog-default") {
				this.cvgPlugin.ND_IHM[id].id = id;
			}
			this.cvgPlugin.ND_IHM[id].clientReplyPlugin(_, body);
		}
	},
	_clientDeletePlugin: function(_, defaultId, body) {
		// get id of the plugin

		this.cvgPlugin = {};

	},

	generateBusyResponse: function(_) {
		// TODO create a diagnosis or a info box ... need to see with claude Michel
	},
	processRequest: function(_, context, bodyStr, tracker) {
		try {
			this.currentTracker = tracker; // set current tracker. it will be stop on each ending node process method
			this.orchestraTracker = this;
			if (context.method !== 'put') {
				throw new Error("bad method: " + context.method);
			}
			var act = parseInt(context.parameters.act, 10);
			// We need to store string to pass to recorder
			var httptiming = perfmonEnabled && perfmon.start(module, 'cvgClient.processRequest');
			bodyStr = bodyStr != null ? bodyStr : context.request.readAll(_);

			var body = JSON.parse(bodyStr);
			//check if an action is in progress and refuse the action by sending a busy message because it's mandatory
			if (this.isProcessingRequest) { // process already oin progrss
				this.logSession(_, "INFO", "a request is already processing");
				CvgDiagnose.create(this, null, 409, "a request is already processing", null, null, "syracuse server", "BUSY", true, null);

			} else {
				if (body.settings && body.settings.syraTrace) {
					this.srvTrace = body.settings.syraTrace;
				}
				if (parseInt(body.act, 10) !== act) {
					throw new Error("body act mismatch: expected " + act + ", got " + body.act);
				}
				if (act >= 1024) {
					this.processAction(_, body);
				} else if (act >= 768) {
					this.processSuperAction(_, body);
				} else {
					this.processSpecialAction(_, body);
				}
			}

			if (perfmonEnabled) {
				this.recordTiming(httptiming, act, "processRequest", {
					size: bodyStr != null && bodyStr.length
				});
			}
		} catch (e) {
			console.log(e.stack);
			throw e;
		} finally {
			this.stopTracker && this.stopTracker(_, context, this.orchestraTracker); // if ochrestraTracker is empty we stop the tracker of the client
		}
	},
	loadWindowDescription: function(_, ist, winId, funcId, stamp) {
		var timing = perfmonEnabled && perfmon.start(module, 'cvgClient.loadWindowDescription', funcId);
		var self = this,
			descr;

		if (this.clientConfig.modePLAY) {
			// stream fakes data access to X3 and other resources used by cvgClient
			descr = this.stream.readDescr(_);
		} else {
			var url;
			try {

				var file, jsonDescr;
				var filePath = __dirname + this.cvgWinStubPath + winId + ".xml";
				if (fs.exists(filePath, _)) {
					file = fs.readFile(filePath, "utf8", _);
				}

				if (!file) {
					url = this.winDescrUrl(winId);
					jsonDescr = cacheMgr.getResource(_, url);
				} else {
					jsonDescr = file;
				}
				descr = jsxml.parse(jsonDescr).WIND;
			} catch (e) {
				throw new CvgException(self, e, locale.format(module, "ERROR_WINMANAGER_LOADING", winId), "KILL", "", (e.message && url ? e.message + " : " + url : (url || null)));
			}
			if (this.recorder) {
				// We need to store description to be able to replay
				this.recorder.dumpWinDescr(_, descr);
			}
		}
		if (perfmonEnabled) {
			timing.end();
		}

		var win = this.pushRequesterWindow(winId, funcId, descr, stamp, ist.win);
		if (win.id === "_FORMULA") {
			// get default element in
			this.getFormulaItem(_, win, "x3Uoperators", 'B');
			this.getFormulaItem(_, win, "x3Ufunctions", 'C');
		}
		return win;
	},
	getFormulaItem: function(_, win, file, target) {
		var lang = this._x3SessionSettings.cdLang || "";
		if (lang.trim().length === 0) {
			throw new Error('Open window[' + win + '] failed.\nX3 language code (cdLang) has not been received from X3 server\nPlease check X3 folder[' + this.clientConfig.getParam('x3Folder') + '] configuration');
		}
		var x3HttpPub = this.clientConfig.getParam("x3HttpPub");
		var url = x3HttpPub + "/X3_ROOT/GEN/" + lang + "/LIB/" + file + ".xml";
		var opt = {
			method: "GET",
			url: url,
			headers: {}
		};
		var request = httpClient.httpRequest(_, opt);
		var response = request.end().response(_);
		response.setEncoding('utf8');
		//console.log("statusCode=" + response.statusCode);
		var body = response.readAll(_);
		if (response.statusCode === 200 && body) {
			var i, col3, item, items = jsxml.parse(body);
			for (i = 0; i < items.Main.LINE.length; i++) {
				item = items.Main.LINE[i];
				col3 = (target === "B" ? 2 : item.COL[3].$cdata);
				this.activeRequest.listenNodeNDOFLD(_, null, null, win.getAdxIst(), item.COL[0].$cdata, item.COL[1].$cdata, item.COL[2].$cdata, col3, item.COL[4].$cdata, item.COL[5].$cdata, target);
			}
		}
	},

	getMessage: function(messageKey) {
		var i, args = [module, messageKey];
		for (i = 1; i < arguments.length; i++) {
			args.push(arguments[i] ? arguments[i].toString() : arguments[i]);
		}
		var res = locale.format.apply(null, args);
		return res;
	},
	closeClient: function(_, e, reason) {
		this.stopRecord();
		var mesg = "None";
		if (e) {
			mesg = e.message || e;
		}
		tracerStd.info && tracerStd.info("CloseClient Convergence Client\n\tReason[" + reason + "]\n\tAlreadyClosed[" + !(this.connClient && this.connClient.hasSocket()) + "] - Exception[" + mesg + "]");
		CvgClose.create(this, reason, e, "");
		if (this.boClient.token) { // logoff on close if necessary
			this.boClient.logoff(_);
		}
		this.closeSocket();
		if (this.boClient.token) {
			this.boClient.logoff(_);
		}
	},
	containsAdxPubSubFile: function(aListOfProperties) {
		var wProperty;
		var wMax = aListOfProperties.length;
		var wI = 3; // pour demarer a la 4eme propriete !
		while (wI < wMax) {
			wProperty = aListOfProperties.get(wI);
			if (wProperty.hasId() && wProperty.id.toUpperCase() === "UIAdxPubSubFile".toUpperCase()) {
				return true;
			}
			wI++;
		}
		return false;
	},

	logSession: function(_, level, message) {
		if (localConfig.logSession && localConfig.logSession.level === level || level === "INFO") {
			console.log((new Date()).toString() + " : " + level + " : " + message);
		}
	},
	deconnectClient: function(_, params, reason, tracker) {
		var pendingNode;
		this.stopRecord();
		try {

			// set askkill at true  to perform when it's possible the deconnection and manage all auto reply message
			this.askKill = true;
			tracerStd.info && tracerStd.info("Deconnect Convergence client - isAlive" + this.isAlive() + "\n\tReason[" + (reason || "none") + "]\n\tAsk X3 server to close");
			if (this.isAlive()) {
				if (this.clientConfig.modePLAY) {
					this.closeSocket();
				} else {
					// create a request for deconnection
					var self = this;
					this.logSession(_, "INFO", "ask Kill CvgClient   uuid=[" + self.uuid + "] reasons=" + reason + " panic=" + (params.panic ? params.panic : false));
					var diag = CvgDiagnose.create(this, null, 500, "a request is already processing", null, "syracuse server", null, "KILL", true);
					diag.statusCode = 500;
					this.funnelAction(_, function(_) {
						var node = {};
						var loopDetection = 10;

						function isLoopState(listNodes) {
							return Object.keys(listNodes).reduce(function(prev, cur, idx, arr) {
								return prev || listNodes[cur] >= loopDetection;
							}, false);
						}

						while (self.activeRequest && self.activeRequest.workingCtx.pendingBlockingNode && !isLoopState(node)) {
							var nodeName = self.activeRequest.workingCtx.pendingBlockingNode.id;
							self.logSession(_, "FINE", "action for blocking node  " + nodeName);
							node[nodeName] = node[nodeName] || 0;

							// Some protocole nodes (like SELIMP, NDGTDT, ND_ASKUI, etc...) could open special windows, outside standard windows stack/interaction. Then it's necessary to release
							// properly these windows, before to close a session, sending proper action expected by runtime for these nodes. Note : just one blocking node by request!
							pendingNode = self.activeRequest.workingCtx.pendingBlockingNode;
							// Response is not used
							// var resp = this[pendingNode.proxy](_, {
							delete self.activeRequest.workingCtx.pendingBlockingNode;

							self[pendingNode.proxy](_, {
								act: pendingNode.act,
								fld: pendingNode.fld || {
									notModified: true
								},
								param: pendingNode.param
							});
							node[nodeName]++;
						}
						if (isLoopState(node)) {
							self.logSession(_, "INFO", "detect loop on ending node ");
						}
						self.logSession(_, "FINE", "process close");
						self.processAsyncAction(_, {
							act: 1075,
							fld: {},
							param: {},
							tech: {}
						});
					});
				}
			}
		} catch (e) {
			this.logSession(_, "INFO", "disconnect CvgClient failed " + e.stack);
		} finally {
			// stop tracker and write response  if async request

			this.activeRequest = null;
			this.logSession(_, "INFO", "disconnect CvgClient uuid=[" + this.uuid + "] completed ");
		}
	},
	closeSocket: function() {
		if (this.isAlive()) {
			this.stream.end();
			this.stream = null;
			return true;
		}
		return false;
	},
	stopRecord: function() {
		if (this.recorder) {
			this.recorder.close();
		}
		this.recorder = null;
	},
	executeCallUiOpenFile: function(values) {
		//console.log(JSON.stringify(values));
		var idx, appSrvShared = null,
			srvPubType, url;
		var localDir = values.UILocalDir;
		var localFile = values.UILocalFile.replace("\\", "/");
		if (localFile && (localDir === "HTTP" || localDir === "HTTPS")) {
			srvPubType = values.UIAdxPubSubFile;
			if (srvPubType !== undefined) {
				srvPubType = parseInt(srvPubType, 10);
				if (srvPubType == 1) {
					idx = localFile.substring("/");
					url = localFile.substring(idx);
				} else if (srvPubType == 2) {
					appSrvShared = true;
				} else if (srvPubType == 3) {
					appSrvShared = false;
				}
			}
			if (this.callUiOpenFile) {
				this.callUiOpenFile.addOpenFile(localDir.toLowerCase(), url || localFile, appSrvShared);
			} else {
				this.callUiOpenFile = new CvgCallUiOpenFile(this, localDir.toLowerCase(), url || localFile, appSrvShared);
			}
		}
		return {};
	},
	executeCallUiGetFile: function(_, isAlways, values) {
		// check if we are in ilog case else do nothin
		if (values && values.UIDownLoad === "ILOG") {
			// create ilog if it's not the case
			var plug = this.getILogPlugin(_);
			// add download
			plug.addDownload(values);
		}
	},
	newILogPlugin: function(_) {
		// check if we already have a plugin instance for an download or upload and associate that one
		var plug = this.cvgPlugin.ND_IHM["ilog-default"] = new CvgPlugin(_, this, "ilog-default", this.killPluginTimoeut || 20000);
		return plug;
	},
	getILogPlugin: function(_, id) {
		this.cvgPlugin.ND_IHM = this.cvgPlugin.ND_IHM || {};
		var plug;
		var idPlugin = "ilog-default";
		if (id && id.length > 0) {
			idPlugin = id;
		}
		if (!this.cvgPlugin.ND_IHM["ilog-default"]) { //
			plug = this.newILogPlugin(_); // default 120s if it's not defined
		}
		if (!this.cvgPlugin.ND_IHM[idPlugin]) { // if idPlugin != ilog and not exists -> associate current ilog plugin with this id
			plug = this.cvgPlugin.ND_IHM[idPlugin] = this.cvgPlugin.ND_IHM["ilog-default"];
		} else {
			plug = this.cvgPlugin.ND_IHM[idPlugin];
		}
		if (id) {
			plug.id = id;
		}

		//console.log("idPlugin '" + plug.id + "'");
		return plug;
	},
	execCallUi: function(_, values) {
		switch (values.UIAction) {
			case "SessionSettings":
				return this.executeAllSessionSettings(values);
			case "SetWindFeatures":
				return this.executeAllSessionSettings(values);
			case "Sethangup":
				return this.executeCallUiSetHangHup(values);
			case "SetTechnoVers":
				return this.executeCallUiSetTechnovers(values);
			case "OpenFile":
				return this.executeCallUiOpenFile(values);
				// The following values not used
			case "GetFileAlways":
			case "GetFile":
				return this.executeCallUiGetFile(_, false, values);
				//case "PutFileAlways":
				//return this.executeCallUiPutFile(true, values);
				//case "PutFile":
				//return this.executeCallUiPutFile(false, values);
		}
		return;
	},
	executeAllSessionSettings: function(values) {
		var i, keys = Object.keys(values);
		for (i = 1; i < keys.length; i++) {
			this._x3SessionSettings[keys[i]] = values[keys[i]];
		}

		// Set formater datePivot
		if (values.DefaultDatePivot != null) {
			this.clientConfig.setDatePivot(this._x3SessionSettings.DefaultDatePivot);
		}
		return {
			UIAction: "SessionSettings"
		};
	},
	executeCallUiSetTechnovers: function(values) {
		// TODO manage protocol negociation
		this.executeAllSessionSettings(values);
		return values;
	},
	executeCallUiSetHangHup: function(values) {
		return {
			Sethangup: 1
		};
	},

	executeGetUiBO: function(_, key) {
		var result = {};
		if (key === "GetBoToken") {
			result[key] = this.boClient.token || this.boClient.logon(_, true);
		} else if (key === "GetBoHost") {
			this.boClient.init(_);
			result[key] = this.boClient.bohost;
		} else if (key === "GetBoPort") {
			this.boClient.init(_);
			result[key] = this.boClient.boport;
		}
		return result;
	},
	findModifiable: function(ist) {
		var timing = perfmonEnabled && perfmon.start(module, "CvgClient.findModifiable");
		var finder = new CModifiableFinder();
		this.traverseSettable(ist, finder);
		if (perfmonEnabled) {
			timing.end();
		}
		return finder.foundModifiable;
	},
	// Connection messages
	listenNodeND_SLF: function(_, reader, node, properties) {
		//console.log("ND_SLF properties: "+JSON.stringify(properties,null,2));
		var result = this.execCallUi(_, properties);
		return x3writer.props1Serializer.build(result, true);
	},
	listenNodeND_GFD: function(_, reader, node, properties) {
		// console.log("ND_GFD properties: "+JSON.stringify(properties,null,2));
		var key = properties[0];
		var result;
		if (this.getUiSpecialOrders[key]) {
			result = this[this.getUiSpecialOrders[key]](_, key);
		}
		if (!result) {
			result = {};
			result[key] = this.clientConfig.getParam(key);
			if (result[key] === undefined) {
				//console.error("Unsupported param: "+key);
				result[key] = "unsupported";
			}
		}
		return x3writer.props1Serializer.build(result, true);
	},
	listenNodeNDCOPMENU: function(_, reader, node, data) {
		//reply.setSplashInfos(data);
	},
	listenNodeNDDEB: function(_, reader, node) {},

	listenNodeND_CLT: function(_, reader, node, dummyByte) {
		// 15w_001 - Fiche 36012 - X3Client: Supervision des sockets
		// Si reception du noeud ND_CLT non attendu => not ok fermeture du
		// client depuis le meme thread
		this.closeClient(_, null, this.connecting ? 4 : 3);
	},
	/**
	 * NDACTOBJ (Adxcpl_displayWin) Affichage d'une fenetre Id=[NDACTOBJ]
	 * x3func=[Adxcpl_displayWin] NbArgs=[2] - ist =[ win=[2] srn=[0] blc=[0]
	 * fld=[0] idx=[0]] - opt=[.x04]
	 */
	listenNodeNDACTOBJ: function(_, reader, node, ist, num) {
		var WIN_NOHIDDEN = 4;
		if (num > WIN_NOHIDDEN) {
			var win = this.findModifiable(ist);
			if (win != null && win instanceof CvgStackedWindow) {
				win.setScreenToShow(num - WIN_NOHIDDEN + 1);
			}
		} else {
			// TODO
		}
	},

	/**
	 * NDACTOP 0E4000 (Activation_Action) Activation d=[NDACTOP] level=[?]
	 * x3func=[Activation_Action] nb=[2] - ide=[2823] ID Action - typ=[.x01]
	 * Status
	 */
	listenNodeNDACTOP: function(_, reader, node, actId, flag) {
		CvgMenuAct.create(this, actId, flag);
	},

	/**
	 * Le serveur envoi 3 noeuds ndctsu pour decrire un format dynamique. voir
	 * l'innerclasse "CDynFormat" Id=[NDCTSU] level=[C]
	 * x3func=[Control_DefineType] NbArgs=[3] - opt=[.x65] - su1 =[c] - su2 =[_]
	 */
	listenNodeNDCTSU: function(_, reader, node, type, subType, compl) {
		/*
		 * Traite le premier noeud NDCTSU contenant le type. Exemple: Type=[g]
		 * SubType=[] Complement=[] Le noeud correspondant: Id=[NDCTSU]
		 * func=[Control_DefineType] NbArgs=[3] opt=[.x67] su1 =[] su2 =[])
		 */
		type = String.fromCharCode(type);
		if (this._curDynFmt == null) {
			this._dynFormats[type] = this._curDynFmt = {};
		}
		/*
		 * Traite le deuxieme noeud NDCTSU contenant le SubType. Exemple:
		 * Type=[g] SubType=[AX] Complement=[] Le noeud correspondant:
		 * Id=[NDCTSU] func=[Control_DefineType] NbArgs=[3] opt=[.x67] su1 =[AX]
		 * su2 =[]
		 */
		else if (this._curDynFmt.subType == null) {
			this._curDynFmt.subType = subType;
		}
		/*
		 * Traite le troisieme noeud NDCTSU contenant le complement (ou non).
		 * Exemple: Type=[g] SubType=[AX] Complement=[] Le noeud correspondant:
		 * Id=[NDCTSU] func=[Control_DefineType] NbArgs=[3] opt=[.x67] su1 =[AX]
		 * su2 =[]
		 */
		else {
			/*
			 * mis en place du complement, creation du format dynamique dans le
			 * formater, et destroy du format dynamique
			 */
			this._curDynFmt.complement = compl;
			this._curDynFmt = null;
		}
	},

	/**
	 * NDOMNCO 0E015E (MenuDyn_New) Id=[NDOMNCO] level=[R] x3func=[MenuDyn_New]
	 * NbArgs=[5] - flg=[.x58] - cod=[1026] - txt=[Selection] - acc=[0] - hlp
	 * =[] parametre passes a la fonction "MenuDyn_New" du client X3 :
	 *
	 * (*fnd)( (flg&0x40)>>6, fen, (flg&0x08)>>3, cod, txt, acc, (flg&0x7), 0,
	 * (flg&0x10)>>4, (flg&0x20)>>5, hlp ) ;
	 *
	 * bFirst Premiere option (vide la liste) ((wByte & 0x40) >> 6) nRang Rang
	 * d'insertion de l'option (0 pas d'option) nType Type de l'option (flg &
	 * 0x08) >>3) nAction Action a renvoyee au serveur pszText texte de l'option
	 * nAccel Accelerateur nCateg Categorie dans le type (flg&0x7) nImage Numero
	 * de l'image bValide Valide ou bien (flg&0x10)>>4 bSelect Selectionne ou
	 * bien (flg&0x20)>>5 pszhelp texte d'aide rapide
	 */
	listenNodeNDOMNCO: function(_, reader, node, flag, actId, txt) {
		var type = (flag & 0x08) >> 3 === 0;
		if (!type && actId > 0) {
			// FDB/CMI - We skip clearMenuList instruction
			// Normally we should send clearMenuList:true/false to client to let it clear menu list
			// but clearMenuList=true is always received before receiveing a new nenu list and client clear the old one by default
			// var clearMenuList = (flag & 0x40) !== 0;
			CvgMenuCtx.create(this, actId, true, txt);
		}
	},

	/**
	 * Changement element dans barre de statut Id=[NDOTXSC] level=[W]
	 * x3func=[Status_ChangeStatus] NbArgs=[6] - ist =[ win=[2] srn=[0] blc=[0]
	 * fld=[0] idx=[0]] - st[0]=[.x00] (byte) - st[1]=[132] (int) - buf[0] =[]
	 * (stru) - buf[1] =[] (stru) - st[2]=[3058] (int)
	 */
	listenNodeNDOTXSC: function(_, reader, node, ist, numTxt, imgId, txt, dummyTxt, actId) {
		var i, item, winFound = null;
		for (i = 0; i < this._stackedWin.length && winFound == null; i++) {
			item = this._stackedWin[i];
			if (item && item.getAdxIst().winAlphaId === ist.winAlphaId) {
				winFound = item;
			}
		}
		if (winFound != null) {
			winFound.addStatusIconDef(ist, numTxt, txt, imgId, actId);
		}
	},

	/**
	 * Id=[NDPKAR] func=[LeftList_Picking] NbArgs=[1] - ist =[ win=[2] srn=[34]
	 * blc=[3] fld=[0] idx=[0]]
	 */
	sendNotify: function(ist, level, message) {
		var i, item, winFound = null;
		if (ist == null) {
			winFound = this._stackedWin[0];
		}
		for (i = 0; i < this._stackedWin.length && winFound == null; i++) {
			item = this._stackedWin[i];
			if (item && item.getAdxIst().winAlphaId === ist.winAlphaId) {
				winFound = item;
			}
		}
		if (winFound) {
			winFound.addStatusIconDef(this, 100 + level, message, 0, 0);
		}

	},
	pickingAddLine: function(aPickedLine) {
		this._pickedLines.push(aPickedLine);
	},
	listenNodeNDPKAR: function(_, reader, node) {
		var actArgs;
		if (this._pickedLines.length > 0) {
			var pickedLine = this._pickedLines.splice(0, 1)[0];
			actArgs = [pickedLine.action];
			var ist = pickedLine.ist;
			var keyP = pickedLine.key;
			var leftList = pickedLine.leftList;
			if (keyP != null) {
				// suppression du numero de ligne dans l'adxid de la lisgne pickee ajout de l'argument tdans la liste
				ist.idx = 0;
				actArgs.push(ist);
				// ajout de l'argument tableau de resu qu'est la cle de la ligne  pickee

				if (typeof keyP === "string") {
					var key = [keyP];
					if (keyP.indexOf('^') !== -1) {
						key = keyP.split('^');
					}
					var i, t, resu, resus = [];
					for (i = 0; i < key.length; i++) {
						t = key[i].split("~");
						resu = new CvgResu.fromAction(parseInt(t[0], 10), t.slice(1).join("~"));
						resus.push(resu);
					}

					actArgs.push(resus);
					// var line = leftList.findLine(resus);
					leftList.setServerSelectLine(pickedLine.isSelection(), resus);
				}
			} else {
				actArgs.push(ist.toString());
				_postDiag(this, this.getMessage('ERROR_CANT_GET_PICKED_LINE_KEY', 'NDPKAR - ' + ist.toString()));
			}
		} else {
			actArgs = [CvgAction.SRV_ABANDON];
		}
		// BRJOU: did not see any resu, pass null
		x3writer.sendAction(_, this, new CvgResu(CvgResuTdo.NULL, null), [], actArgs);
	},
	razModification: function() {
		this.callUiOpenFile = null;
		this._stackedWin.razModifications();
		this._trackLists = this.newTrackLists(); // should be inside request???
	},
	newActiveRequest: function(reply, sendContext, modeMerge, noResp) {
		if (!modeMerge) {
			this.razModification();
		}
		if (!noResp) {
			this.timing = {};
		}
		this.activeRequest = new CvgRequest(this, reply, sendContext);
		this.isProcessingRequest = true; // request is in progress
		return this.activeRequest;
	},
	popRequesterWindow: function(winIst) {
		var win = this._stackedWin.popStackedWindow(winIst);
		win.setOpened(false);
		win.jsonType = "FUNCC";
		this.track(win);
		// clean map if there only mother windows

		return win;
	},
	pushRequesterWindow: function(winId, funcId, descr, stamp, winIdx) {
		var win = new CvgStackedWindow(this, winId, funcId, descr, stamp, winIdx);
		this._stackedWin.pushStackedWindow(win, winIdx);
		win.setStackLevel(this._stackedWin.length);
		win.setOpened(true);
		win.jsonType = "FUNCO";
		this.track(win);
		return win;
	},
	toString: function(aSeparator) {
		return "";
	},

	traverseSettable: function(ist, aModifier) {

		/*var mod = this.mapIst[ist];
		if (mod) {
			return aModifier.setModifiable(ist, mod);
			// optimisation for cvgEntity (especially for array (INSLI,NDCHVL...etc)
		} else*/
		if (ist.isWindowIst() && ist.winZeroBase === -1) {
			return aModifier.setModifiable(ist, this._motherWin);
		}

		return this._stackedWin.traverseSettable(ist, aModifier);
	},
	track: function(obj) {
		// add if not exists the current obj
		var list = this._trackLists[obj.jsonType];
		// Allow observable to not send adat - see CvgDiagnose
		/*if (obj.sendToClient && !obj.sendToClient(list)) {
			return;
		}*/
		if (obj.getObservableId) {
			// we can add keys directly to the array, they will be ignored by JSON.stringify
			var key = '#' + obj.getObservableId();

			var old = list[key];
			if (old != null) {
				list[old] = undefined;
			}
			list[key] = list.length;
		}
		list.push(obj);
	},
	setUserProfile: function(profil) {
		if (this._x3SessionSettings.usrProfile !== profil) {
			this._x3SessionSettings.usrProfile = profil;
		}
	},
	winDescrUrl: function(winId) {
		var lang = this._x3SessionSettings.cdLang || "";
		var langKnown = {
			"de-DE": "GER",
			"en-GB": "BRI",
			"en-US": "ENG",
			"es-ES": "SPA",
			"fr-FR": "FRA",
			"it-IT": "ITA",
			"pl-PL": "POL",
			"pt-PT": "POR",
			"ru-RU": "RUS"
		};
		if (lang.trim().length === 0) {
			lang = langKnown[this.clientConfig.getParam("x3Lang")];
			if (lang != null) {
				this._x3SessionSettings.cdLang = lang;
				_postDiag(this, this.getMessage('WARNING_CANT_GET_CDLANG_MSG'), this.getMessage('WARNING_CANT_GET_CDLANG_DETAIL', lang));
			} else {
				throw new Error(this.getMessage('WARNING_CANT_GET_CDLANG_ERROR', winId, this.clientConfig.getParam("x3Lang"), this.clientConfig.getParam('x3Folder')));
			}
		}
		var x3HttpPub = this.clientConfig.getParam("x3HttpPub");
		var x3Folder = this.clientConfig.getParam("x3Folder");
		return x3HttpPub + "/" + x3Folder + "/GEN/" + lang + "/FENS/" + winId + ".xml";
	},
	_buildUiClientSettings: function() {
		var i, res = {};
		for (i in _uiCliSettings) {
			if (this._sessionSettings[i]) {
				res[_uiCliSettings[i]] = this._sessionSettings[i];
			} else if (this._x3SessionSettings[i]) {
				res[_uiCliSettings[i]] = this._x3SessionSettings[i];
			}
		}
		// Add formater settings for client formater
		this.clientConfig.addUiCliSettings(res);
		return res;
	},
	isAlive: function() {
		return this.stream != null && !this.stream.closed;
	},
	// somme value in the timing
	_calculTiming: function(timing, key) {
		var self = this;
		var timingk = key ? timing[key] : timing;
		if (Array.isArray(timingk)) {
			// calcul sum
			var total = 0;
			timingk.forEach(function(item) {
				if (item.duration) {
					total += item.duration;
				}
			});
			if (!perfmonDetail && timing[key]) {
				delete timing[key];
			}
			timing['cvgTotal_' + key] = {
				totalDuration: total
			};
		} else if (typeof timingk === "object" && Object.keys(timingk).length >= 1) {
			Object.keys(timingk).forEach(function(id) {
				self._calculTiming(timingk, id);
			});
		}
	},

	getTarget: function() {
		var lists = this._trackLists;
		return JSON.parse(JSON.stringify(lists.TARGET[lists.TARGET.length - 1]));
	},

	getTrackList: function() {
		return this._trackLists;
	},
	generateResponse: function(_, connect, isTrack) {
		var timing = perfmonEnabled && perfmon.start(module, "cvgClient.generateResponse");
		this.isProcessingRequest = false; // request is in finish we generate response

		var lists = this._trackLists;
		var isDefined = function(o) {
			return o !== undefined;
		};

		var wins = {},
			win, key, i, entity, winNode, gridParent, line, jsonKey, jsonEntity;
		for (i = 0; i < lists.ENTITY.length; i++) {
			entity = lists.ENTITY[i];
			if (entity === undefined || entity instanceof CvgStackedWindow) {
				continue;
			}
			win = entity instanceof CvgStackedWindow ? entity : (entity instanceof CvgStatusBar ? entity.stackedWindow : this._stackedWin.findWin(entity.getFatherWindowId().charCodeAt(0) - '@'.charCodeAt(0)));
			if (win) {
				winNode = wins[win.entityIdxAlpha];
				if (!winNode) {
					winNode = wins[win.entityIdxAlpha] || {
						entities: {}
					};
					if (win.statusBarChange) {
						winNode.statBar = win.statusBar.toJSON();
					}
					if (win.hasModifTitle()) {
						winNode.tit = win.title;
					}
					wins[win.entityIdxAlpha] = winNode;
				}
				if (entity instanceof CvgStatusBar) {
					// nothin
				} else if (entity instanceof CvgEntity) {
					gridParent = null;
					line = null;
					if (entity instanceof CvgVariable) {
						line = entity.srcLine;
					} else if (entity instanceof CvgDataSrcLine) {
						line = entity;
					} else if (entity instanceof CvgDataSrc) {
						gridParent = entity;
					}
					if (line != null) {
						gridParent = line.dataSrc;
					}
					if (gridParent != null || line != null) {
						if (gridParent == null) {
							gridParent = line.dataSrc;
						}
						if (gridParent.isBlocGrid()) {
							entity = gridParent;
						}
					}

					jsonKey = entity.getJsonKey();

					if (winNode.entities[jsonKey] == null) {
						timing = perfmonEnabled && perfmon.start(module, entity.getAdxIst() + ".toJSON");
						jsonEntity = entity.toJSON();
						if (perfmonEnabled) {

							timing.end();
							if (perfConfig.clientRecord) {
								this.timing.toJSON = this.timing.toJSON || [];
								this.timing.toJSON.push({
									duration: timing.getTiming() ? timing.getTiming().duration : 0,
									"entity": entity.getAdxIst()
								});
							}
						}
						if (jsonEntity && Object.keys(jsonEntity).length !== 0) {
							winNode.entities[jsonKey] = jsonEntity;
						}
					}
				}
			}
			/*if (win && win.entityIdxAlpha && Object.keys(wins[win.entityIdxAlpha].entities).length === 0)
				delete wins[win.entityIdxAlpha];*/
		}
		var response = {
			sap: {},
			session: lists.SESSION[0] || {}
		};
		if (lists.SESSIONOPEN && lists.SESSIONOPEN.length !== 0) {
			response.session.open = JSON.parse(JSON.stringify(lists.SESSIONOPEN[0]));
		}
		var sap = response.sap;
		if (lists.MISC && lists.MISC.length !== 0) {
			sap.misc = JSON.parse(JSON.stringify(lists.MISC[0]));
		}
		if (lists.TARGET.length !== 0) {
			var target = this.getTarget();
			if (!isTrack) {
				sap.target = target;
			} else if (sap.target) {
				delete sap.target;
			}
		}
		var acts = lists.ACT.filter(isDefined);
		if (acts && acts.length !== 0) {
			sap.acts = acts;
		}
		if (lists.RPC.length !== 0) {
			var rpc = JSON.parse(JSON.stringify(lists.RPC[0]));
			if (this.lastAckCallSpgmId[this.lastAckCallSpgmId.length - 1] === "GESUSER:CONNECT_FONCTION") { // if reuse ack_call return
				if (rpc.json.result.errm && sap.target.type === "portal") {
					var result = rpc.json.result;
					sap.target.portal = {
						$diagnoses: [{
							"$stackTrace": "x3 Error; num:" + result.errn + ", message:" + result.errm + " line:" + result.errl + " type:" + result.errt,
							"$severity": 'ERROR',
							"appCode": 500,
							"$origin": "NodeJS: Convergence Server ",
							"$message": "x3 Error - " + result.errm,
						}]
					};
				}
			} else { // if not reuse ack_call, serialize rpc
				// list of ack call - remove the last ack_call
				sap.rpc = rpc;
			}
			this.lastAckCallSpgmId.pop();

		}
		for (i = 0; i < lists.FUNCO.length; i++) {
			sap.func = sap.func || {};
			win = lists.FUNCO[i];
			key = win && win.entityIdxAlpha;
			if (win && win.isOpened()) {
				// object with key: win
				win.dumpOpened = true;
				sap.func.open = sap.func.open || {};
				sap.func.open[key] = win;
			}
		}
		for (i = 0; i < lists.FUNCC.length; i++) {

			sap.func = sap.func || {};
			win = lists.FUNCC[i];
			key = win && win.entityIdxAlpha;
			if (win && win.dumpOpened) {
				// just an array of keys
				sap.func.close = sap.func.close || [];
				sap.func.close.push(key);
				//				wins[key] = {
				//					tit: win.title,
				//					entities: {}
				//				};
			}
		}
		if (Object.keys(wins).length > 0) {
			sap.wins = wins;
		}
		if (sap.target && sap.target.ist) {
			for (i = 0; i < lists.TARGETACT.length; i++) {
				sap.target.ist.acts = sap.target.ist.acts || [];
				sap.target.ist.acts.push(lists.TARGETACT[i]);
			}
		}
		var report, kind;
		for (i = 0; i < lists.REPORT.length; i++) {
			sap.jobs = sap.jobs || {};
			sap.jobs.report = sap.jobs.report || {};
			report = lists.REPORT[i];
			kind = report.kind;
			sap.jobs.report[kind] = sap.jobs.report[kind] || [];
			sap.jobs.report[kind].push(JSON.parse(JSON.stringify(report)));
		}
		if (true === connect) {
			// Add session settings only at connection
			// add dynamic formats
			this._sessionSettings.fmtExt = {};
			var p, res, dynFmt;
			for (p in this._dynFormats) {
				dynFmt = this._dynFormats[p];
				res = {};
				if (dynFmt.complement != null) {
					res.stdType = dynFmt.complement.split('');
				}
				if (dynFmt.subType != null) {
					res.chars = dynFmt.subType.split('');
				}
				this._sessionSettings.fmtExt[p] = res;
			}
			if (!this._sessionSettings.mnu || this._sessionSettings.mnu.length === 0) {
				// Add menus only if received
				// !! Reuse session - We must store menus received at first connexion
				this._sessionSettings.mnu = lists.SESSIONMNU;
			}
			response.session.settings = this._buildUiClientSettings();
		} else {
			if (!this._sessionSettings.mnu || this._sessionSettings.mnu.length === 0) {
				// Add menus only if received
				// !! Reuse session - We must store menus received at first connexion
				this._sessionSettings.mnu = lists.SESSIONMNU;
				response.session.settings = this._buildUiClientSettings();
			}

		}

		response.srvop = {};
		// request object
		var serverName = "";
		if (this.baseUrl) {
			serverName = this.baseUrl.substr(this.baseUrl.indexOf("://") + 3);
			serverName.substr(0, serverName.indexOf("/"));
		}

		var aRqst = this.activeRequest.sendContext;
		response.srvop.request = {
			"id": aRqst.reqNum,
			"v": this.activeRequest.reply.actionId,
			"rqtdist": aRqst.target,
			"connect": 1,
			"status": this.activeRequest.status,
			"session": this.sessionId,
			"server": serverName // change by baseUrl - more interesting if the server public name is not the same and for unit test
		};

		for (i = 0; i < lists.DIAGNOSE.length; i++) {

			response.srvop.$diagnoses = response.srvop.$diagnoses || [];
			response.srvop.$diagnoses.push(JSON.parse(JSON.stringify(lists.DIAGNOSE[i])));
		}
		for (i = 0; i < lists.GLDIAGNOSE.length; i++) {
			response.sap.$4glDiagnoses = response.srvop.$4glDiagnoses || [];
			response.sap.$4glDiagnoses.push(JSON.parse(JSON.stringify(lists.GLDIAGNOSE[i])));
		}

		// add sessionInfo
		if (true === connect) {
			// Add session info at connection
			response.srvop.sessionInfo = {
				reused: this.reused,
				nodeWS: this.sessInfo.nodeWS,
				node: this.sessInfo.node,
				runtime: this.sessInfo.runtime
			};
			response.srvop.sessionInfo.runtime.folder = this.clientConfig.getParam("x3Folder");
		}
		if (perfmonEnabled) {
			timing.end();
			if (perfConfig.clientRecord) {
				this._calculTiming(this.timing);
				response.timing = this.timing;
			}
		}
		this.response.body = response;
	}
});