"use strict";
var helpers = require('syracuse-core/lib/helpers');
var locale = require("syracuse-core/lib/locale");
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var date = require('syracuse-core/lib/types/date');
var automata = require("syracuse-x3/lib/convergence/automata/x3Automata");
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var jsxml = require('jsxml');
var os = require('os');
var util = require('util');
var CvgClientConfig = require("syracuse-x3/lib/convergence/model/CvgClientConfig").CvgClientConfig;
var CvgFormatter = require('syracuse-x3/lib/convergence/types/CvgFormatter').CvgFormatter;
var CvgModifier = require('syracuse-x3/lib/convergence/model/CvgModifier').CvgModifier;
var CvgEntity = require('syracuse-x3/lib/convergence/model/CvgEntity').CvgEntity;
var CvgStackedWindows = require('syracuse-x3/lib/convergence/model/CvgStackedWindows').CvgStackedWindows;
var CvgStackedWindow = require('syracuse-x3/lib/convergence/model/CvgStackedWindow').CvgStackedWindow;
var CvgReply = require('syracuse-x3/lib/convergence/client/CvgReply').CvgReply;
var CvgRequest = require('syracuse-x3/lib/convergence/client/CvgRequest').CvgRequest;
var CvgInstance = require('syracuse-x3/lib/convergence/model/CvgInstance').CvgInstance;
var CvgMenuAct = require('syracuse-x3/lib/convergence/model/CvgMenuAct').CvgMenuAct;
var CvgMenuCtx = require('syracuse-x3/lib/convergence/model/CvgMenuCtx').CvgMenuCtx;
var CvgDataSrc = require('syracuse-x3/lib/convergence/model/CvgDataSrc').CvgDataSrc;
var CvgDataSrcLine = require('syracuse-x3/lib/convergence/model/CvgDataSrcLine').CvgDataSrcLine;
var CvgVariable = require('syracuse-x3/lib/convergence/model/CvgVariable').CvgVariable;
var CvgClose = require('syracuse-x3/lib/convergence/model/CvgClose').CvgClose;
var CvgIst = require('syracuse-x3/lib/convergence/types/CvgIst').CvgIst;
var CvgResu = require('syracuse-x3/lib/convergence/types/CvgResu').CvgResu;
var CvgResuTdo = require('syracuse-x3/lib/convergence/types/CvgResu').TDO;
var CvgAction = require('syracuse-x3/lib/convergence/client/CvgAction').Actions;
var CvgSuperAction = require('syracuse-x3/lib/convergence/client/CvgAction').SuperActions;
var ActionDescriptors = require('syracuse-x3/lib/convergence/client/CvgAction').Descriptors;
var CONNECT_ACTION = require('syracuse-x3/lib/convergence/client/CvgAction').CONNECT_ACTION;

var CvgServices = require('syracuse-x3/lib/convergence/client/CvgServices');


var traceAction = nodeconfig.config && nodeconfig.config.x3fusion && nodeconfig.config.x3fusion.actions && nodeconfig.config.x3fusion.actions.trace;
var traceProtocol = nodeconfig.config && nodeconfig.config.x3fusion && nodeconfig.config.x3fusion.protocol && nodeconfig.config.x3fusion.protocol.trace;
var traceSessions = nodeconfig.config && nodeconfig.config.x3fusion && nodeconfig.config.x3fusion.sessions && nodeconfig.config.x3fusion.sessions.trace;


var CDynFormat = exports.CDynFormat = helpers.defineClass(function(aType, aFormater) {
	this.complement = null;
	this.subType = null;
	this.type = aType;
	this.formater = aFormater;
}, null, {
	/*
	 * c": { "stdType": ["A", "#"], "chars": ["", "-", "/", "_", ","] },
	 */
	toJSon: function() {
		var dynFmt = {};
		if (this.complement != null) {
			dynFmt.stdType = this.complement.split('');
		}
		if (this.subType != null) {
			dynFmt.chars = this.subType.split('');
		}
		return dynFmt;
	}
});

var CModifiableFinder = exports.CModifiableFinder = helpers.defineClass(function() {
	CvgModifier.call(this);
	this.foundModifiable = null;
}, CvgModifier, {
	setModifiable: function(aStructIst, aModifiable) {
		this.foundModifiable = aModifiable;
		this.done = true;
		return this.done;
	}
});

var CMotherWindow = exports.CMotherWindow = helpers.defineClass(function(aClient) {
	CvgEntity.call(this, aClient, "&ROOT", 1, 'WINDOW');
}, CvgEntity, {
	getAdxId: function() {
		return "mostherWindow - &ROOT";
	},
	toJson: function() {
		throw new Error("Bad tojson MotherWin");
	}
});


// move this to Reader class

function formatKeyValues(result) {
	return [Object.keys(result).map(function(key) {
		return key + '=\u0001' + result[key] + '\n';
	})];
}

function checkLen(list, len) {
	if (list.length !== len) throw new Error("bad list length: " + list.length);
}

var SRVOP = {
	"request": {
		"id": 0,
		"v": 0,
		"session": "484cdda6-6a94-4a71-8fe3-578beb12c47a_381272274",
		"status": 0,
		"server": "172.28.8.146"
	},
	"sessionInfo": {
		"cnxid": "33589530-662c-4d82-9a19-0ba6fd0c8aaa_381272274",
		"sessid": "484cdda6-6a94-4a71-8fe3-578beb12c47a_381272274",
		"runtime": {
			"folder": "SYDEV",
			"port": 16667,
			"x3profile": "ADMIN",
			"host": "172.28.20.117",
			"http": "http://aydaix05.sagefr.adinternal.com:80/Adonix_SYDVLP",
			"x3user": "APISU",
			"lang": "FRA"
		},
		"bridge": {
			"port": 27080,
			"config": {
				"jettyPort": "18880",
				"host": "172.28.8.146",
				"systembits": "64",
				"installfix": "1",
				"data": "/home/pisua/.git_repo/x3kilo/com.sage.x3.simulator/bridge/data",
				"builddate": "unknown",
				"installversname": "KILO",
				"systemarch": "",
				"installvers": "SAFE X3 JAV",
				"tools": "/home/pisua/.git_repo/x3kilo/com.sage.x3.simulator/bridge/tool",
				"sdataPort": "27080",
				"systemtype": "windows",
				"installminor": "1",
				"installpatch": "115",
				"installversnum": "16j"
			},
			"ipserver": "172.28.8.146",
			"ipclient": "aysyrsydev.sagefr.adinternal.com"
		},
		"reused": false,
		"node": {
			"proto": "http://172.28.20.117:80/Adonix_SYDVLP/SYDEV/GEN/SYR/FR-FR/FENJ",
			"fusion": "http://172.28.8.146:27080/sdata/x3/trans/-",
			"sessSettings": {
				"auth": "basic",
				"key": "syracuse.sid",
				"timeout": 20,
				"checkInterval": 300
			},
			"x3user": "apisu",
			"x3host": "172.28.20.117",
			"x3port": 16667,
			"x3name": "",
			"gitlastmodif": "Mon Jan 21 2013 11:05:16 GMT+0100 (Paris, Madrid)"
		}
	},
	"tech": {
		"timExec": 3133.922,
		"x3open": 3133.759
	}
};

var Spy = helpers.defineClass(function(_, stream) {
	var self = this;

	this.dumpFile = __dirname + "/../data/dump_" + (new Date().toISOString()).replace(/\:/g,'-') + ".js";
	require('fs').appendFile(this.dumpFile, '"use strict";\n', 'utf8', _);

	var read = stream.read;
	stream.read = function(_, len) {
		var data = read.call(stream, _, len);
		if (data) self.dumpBytes(_, "READ", data);
		return data;
	};
	var write = stream.write;
	stream.write = function(_, data) {
		if (data) self.dumpBytes(_, "WRITE", data);
		write.call(stream, _, data);
	}
}, null, {
	dumpBytes: function(_, action, data) {
		var line = action + "([0x" + data.toString('hex').match(/.{1,2}/g).join(', 0x') + "]);\n";
		require('fs').appendFile(this.dumpFile, line, 'utf8', _);
	},
	dumpJSON: function(_, action, obj) {
		var line = action + "(" + JSON.stringify(obj) + ");\n";
		require('fs').appendFile(this.dumpFile, line, 'utf8', _);
	}
});

var serializers = {
	I: function(val) {//instance
		if (!(val instanceof CvgIst)) throw new Error("action parameter type mismatch, expected IST, got " + val);
		return val.getBytes();
	},
	U: function(val) {//string
		if (typeof val !== 'string') throw new Error("action parameter type mismatch, expected string, got " + typeof val);
		var len = Buffer.byteLength(val, 'utf8');
		var buf = new Buffer(len + 4);
		buf.writeInt16BE(len + 2, 0);
		buf.writeInt16BE(val.length, 2);
		buf.write(val, 4, len, 'utf8');
		return buf;
	},
	D: function(val, isExtend) {// table of cvgresu
		if (!Array.isArray(val)) throw new Error("action parameter type mismatch, expected array, got " + typeof val);
		var countBuf;
		if (isExtend){
			countBuf = new Buffer(2);
			countBuf.writeInt16BE(val.length, 0);
		} else {
			countBuf = new Buffer([val.length]);
		}
		var valsBuf = Buffer.concat(val.map(function(v) {
			return v.getBytes();
		}));
		//console.log("VALSBUF=" + valsBuf.toString('hex'));
		return Buffer.concat([countBuf, valsBuf]);
	},
	S: function(val) {// short
		if (typeof val !== 'number') throw new Error("action parameter type mismatch, expected number, got " + typeof val);
		return new Buffer([(val >> 8) & 0xff, val & 0xff]);
	},
	T: function(val, isExtend){ // table of short
		if (!Array.isArray(val)) throw new Error("action parameter type mismatch, expected array, got " + typeof val);
		var countBuf;
		if (isExtend){
			countBuf = new Buffer(2);
			countBuf.writeInt16BE(val.length, 0);
		} else {
			countBuf = new Buffer([val.length]);
		}
		var valsBuf = Buffer.concat(val.map(function(v) {
			return new Buffer([(v >> 8) & 0xff, v & 0xff]);
		}));
		return Buffer.concat([countBuf, valsBuf]);
	},
	L: function(val) {//integer 
		if (typeof val !== 'number') throw new Error("action parameter type mismatch, expected number, got " + typeof val);
		return new Buffer([(val >> 24) & 0xff, (val >> 16) & 0xff, (val >> 8) & 0xff, val & 0xff]);
	},
}

function serializeActionParams(act, params) {

	function serialize(p,d, isExtend){
		return Buffer.concat(p.slice(0,d.length).map(function(param, i) {
			traceProtocol && traceProtocol("serializer "+d[i]+" param "+param);
			var fn = serializers[d[i]];
			if (!fn) throw new Error(desc.name + ": unknown serializer: " + d[i]);
			var res = fn(param, isExtend);
			return res;
		}));
	}

	var desc = ActionDescriptors[act] || {name: 'APPLICATIVE ACTION ' + act, params: ''};
	//console.log("ACTION=" + desc.name);
	//console.error("SERIALIZE PARAMS="+JSON.stringify(params,null,2));
	
	var trueParamsLen = desc.params.length - (desc.params.split('x').length - 1);
	if (desc.params === '?') throw new Error("params serialization missing for " + desc.name + " (count got: "+params.length+")");
	if (trueParamsLen !== params.length) console.error("WARNING: " + desc.name + ": param count mismatch: expected " + trueParamsLen + ', got ' + params.length);
	var paramSplited = [];
	var std = null;
	if (desc.params.indexOf('x')!==-1){
		paramSplited = desc.params.split('x'); 
		std = paramSplited[0];
	}else{
		std = desc.params;
	}
	
	// serialize std param
	var buf = serialize(params.slice(0,std.length),std);
	
	if (paramSplited.length > 1) {
		// serialized extends 
		var offset = std.length;
		var allBuffExt = null;
		for (var i=1;i<paramSplited.length;i++) {
			var buffExt = null;
			for (var j in paramSplited[i]) {
				var b = serialize(params.slice(offset++,offset),paramSplited[i][j], true);
				buffExt ? buffExt = Buffer.concat([buffExt,b]): buffExt = b; // concat element of extends
			}
			var len = buffExt.length;
			buffExt = Buffer.concat([new Buffer([(len >> 24) & 0xff, (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff]),buffExt]);
			allBuffExt? allBuffExt = Buffer.concat([allBuffExt,buffExt]) : allBuffExt = buffExt;// concat all extends
		}
		// concat std buf with all extends 
		allBuffExt= Buffer.concat([buf,allBuffExt]);
		return {
			buf: allBuffExt,
			stdLen: buf.length
		}
	}else{
		return {
			buf: buf,
			stdLen: buf.length
		}
	}
}

var CvgClient = exports.CvgClient = helpers.defineClass(function(_, stream, adxInfos, aConfig, aType) {

	// Activate dump
	if (nodeconfig.config && nodeconfig.config.x3fusion && nodeconfig.config.x3fusion.dump)
		this._spy = new Spy(_, stream);
	
	this.sid = aConfig.sessionid;
	this.stream = stream;
	this.adxInfos = adxInfos;
	this.clientConfig = new CvgClientConfig(aConfig);
	this.isInteractiveSession = this.clientConfig.isInteractiveSession();
	this.trackLists = this.newTrackLists();
	this.sessionSettings = {};
	this.appSrvSessionSettings = {};
	this.srvop = {};
	this.maxTimeBeforeAutomaticHangUp = -1;
	this.maxTimeBeforeHangUp = -1;
	this.activeRequest = null;
	this.adxIstsOfPickedLines = [];
	this.affSynchroneMessages = [];
	this.applicationID = null;
	this.sessDynFormat = [];

	this.currentDynFormat = null;
	this.formater = null;
	this.logicalErrorMessage = null;
	this.uuid = null;

	this.config = this.clientConfig;
	this.initFormater();
	this.motherWindow = new CMotherWindow(this);
	this.stackedWindows = new CvgStackedWindows();
	this.withLogicalErrDetails = false; //this.clientConfig.getBoolParam(CAdonixConfig.WITH_LOGICAL_ERR_DETAILS);
	// added by BRJOU - open not called any more
	this.newActiveRequest(new CvgReply(this, CONNECT_ACTION), null,{"reqNum":0,"connectAction":true} );
	this.connecting = false;
	this.isReuse = false;
	this.timeToReuse = -1;// time when the client was set in reuse
	this.sessionConv = null;
	this.services = CvgServices.create(_, this);

}, null, {
	newTrackLists: function() {
		return {
			SESSION: [],
			ACT: [],
			TARGETACT: [],
			SESSIONMNU: [],
			TARGET: [],
			PREVIOUS: [],
			ENTITY: [],
			FUNC: [],
			RPC: [],
			WINDOW: [],
			DIAGNOSE: [],
		};
	},
	setInReuseMode: function(_,bool){
		if (bool) {
			this.isReuse = true;
			this.timeToReuse = (new Date()).getTime();
			traceSessions && traceSessions("set timeout");	
			var timeoutReuse = nodeconfig.config.x3fusion.reuseTimeout || 120000;
			var self = this;
			traceSessions && traceSessions("timeout reuse "+timeoutReuse);
			this.reuseTimeoutId = setTimeout(function(_){
				// get current time and check timeout of reuse
				traceSessions && traceSessions("reuse "+ self.isReuse);	
				if (self.isReuse) {// only if it's reuse 
					// reuse session need to be destroy
					self.sessionConv.destroyReuseClient(_,self);
					self.isReuse = false;
					traceSessions && traceSessions("clear timeout "+JSON.stringify(self.reuseTimeoutId,null,2));
				}
			},timeoutReuse);
		}else{
			this.isReuse = false;
			this.timeToReuse = -1;
			traceSessions && traceSessions("clear timeout");
			clearTimeout(this.reuseTimeoutId);
		}
	},
	isSameContext: function(context){// check context for reuse session
		var paramConfig = this.clientConfig.params;

		if (!context.user  || context.user!==paramConfig.user) {
			console.log("user");
			return false;
		}
		if (!context.adxHttpPub || context.adxHttpPub!==this.adxInfos.adxHttpPub) {
			console.log("pub");
			return false;
		}
		if (!context.server || context.server!==paramConfig.server) {
			console.log("srv");
			return false;
		}
		if (!context.port || context.port!==paramConfig.port) {
			console.log("port");
			return false;
		}
		if (!context.syraPreferences || JSON.stringify(context.syraPreferences)!== JSON.stringify(paramConfig.syraPreferences)) {
			console.log("pref");
			return false;
		}
		if (context.codeLangIso !== paramConfig.codeLangIso) {
			console.log("iso");
			return false;
		}
		return true;

	},
	execOpenFunction: function(_,context){
		var request = {
			act:1077,
			fld : {
				ist : {
					win : "A",
				}
			},
			param : {
				call : {	
					json : {
						"spgm": "GESUSER:CONNECT_FONCTION",
						"params": [
							{
								"dim": 1,
								"nb": 1,
								"size": context.length,
								"typ": "STRU",
								"resu": context
							},
							{
								"dim": 1,
								"nb": 0,
								"size": 1,
								"typ": "STRU"
							}
						]
					},
				}
			},
		};

		return this.processAction(_,request);
	},
	start: function(_) {
		this.connecting = true;
		automata.process(_, this);
		return this.getResponse();
	},
	actionParams: function(body) {
		// params passed to listenSendingArgs are [action, ist (or null ist), params added by append2ActionParams]
		var params = [body.act];
		if (!body.param) return params;
		var target = body.param.target;
		if (target && target.xid != null) {
			params.push(new CvgIst(this.targetToXid(target)));
		}
		if (body.param.std) {
			params = params.concat(body.param.std);
		}

		return params;
	},

	processAction: function(_, body) {
		traceAction && traceAction("************************************");
		traceAction && traceAction("Begin Process Action:\n" + JSON.stringify(body, null, 2));
		this._spy && this._spy.dumpJSON(_, "Process Action", body.act);
		// improve: see getActionsParamsToSend FDB in CSDataPayloadFusionRequest.java
		// Sanity checks
		// Create fresh request/reply objects
		var reply = new CvgReply(this, body.act);
		var ctx;
		if (body.param && body.param.target){
			var target = body.param.target;
			if (target && target.xid != null) {
				ctx = new CvgIst(this.targetToXid(target));
			}
		}
		var connectOrReuse = (body.act === CvgAction.CONNECT_ACTION || (body.act === 1077 &&  body.param.call.spgm === "GESUSER:CONNECT_FONCTION") )? true: false; 
		this.newActiveRequest(reply, null, {"ctxNDSLB": ctx, "reqNum": body.tech && body.tech.id ? body.tech.id : 0,"connectAction":connectOrReuse});

		var resu, extras = [];
		if (body.fld) {
			if (body.fld.v){
				if (!body.fld.ist) {
					var type = typeof body.fld.v === 'string' ? CvgResuTdo["STRU"] : CvgResuTdo["INT"];
					resu = CvgResu.fromAction(type, body.fld.v);
	
				}else{
					// Retrieve the instance to obtain the data type of the action's resu
					var ist = CvgIst.fromAction(body.fld.ist);
					traceAction && traceAction("ACTION IST=" + JSON.stringify(ist,null,2));
					var entity = this.findModifiable(ist);
					//console.log("ACTION ENTITY=" + util.inspect(entity));
					//if (entity == null) throw new Error("modifiable not found: " + JSON.stringify(body));
					if (entity && entity instanceof CvgVariable) {
						if (entity.dataType == null) throw new Error("data type not found: " + JSON.stringify(body));
	
							
						try {
							if (entity.acceptEditFormat() && body.fld.fmtKind === 'EDIT') {
								// deformatage : format edition => format presentation. Peut
								// lever une exception de formatage ou de valorisation
								var value = entity.formatEditToDisplay(body.fld.v);
	
								// ajout d'un noeud "ist" "previous" avec la valeur reformatee.
								// Exemple : <ist which="previous" C="B,B,B5" format="show"
								// IstFmt="N+:5.5#">0,02000</ist>
								this.activeRequest.reply.addInstance(CvgInstance.newprevious(this, ist, entity.format.format, value, this.activeRequest.reply == null ? false : this.activeRequest.reply.stayInCommandMode));
							}
							// deformatage : format presentation => format brut
							var val = entity.unFormatData(body.fld.v);
							if (val !== undefined) {
								resu = CvgResu.fromAction(entity.dataType, val);
								console.log("SEND TRUE VALUE: "+resu.toString());
								entity.setBrowserUnformattedValue(resu);
							}
						} catch(e) {
							console.error(e.stack);
							// Récupération de l'erreur de formatage pour info client
							var instance = CvgInstance.newtarget(this, ist, entity.format.format, body.fld.v, this.activeRequest.reply == null ? false : this.activeRequest.reply.stayInCommandMode);
							instance.exception = e;
							this.activeRequest.reply.addInstance(instance);
							return this.getResponse();
						}

					}
				}
			}
			// Build the list of extra results to send after the first one
			// For only one optional extra: crsr (cursor position)
			// crsr is serialized directly as an int, not as a resu.
			var crsr = body.fld.ctx && body.fld.ctx.crsr;
			if (crsr != null) extras.push(new CvgResu(CvgResuTdo["INT"], parseInt(body.fld)));
		}
		if (!resu) resu = new CvgResu(CvgResuTdo["NULL"], null);

		
		
		// get action params (action is recorded into params[0])
		var params = this.actionParams(body);
		this.activeRequest.listenSendingArgs(body, this, params);
		//this.activeRequest.buildIstDatasOfAction(params[0]);
		
		// send the action to X3
		this.sendAction(_, resu, extras, params);

		//CvgClient.checkFailed
		// run automata to get callbacks from X3 engine and return response
		automata.process(_, this);
		var resp = this.getResponse();
		traceAction && traceAction("************************************");
		traceAction && traceAction("End Process Action:\n" + JSON.stringify(resp, null, 2));
		return resp;
	},
	sendAction: function(_, resu, extras, params) {

		// serialize resu
		var resuBuf = resu.getBytes();

		// serialize the number of extras on 1 byte + the extras
		var extrasLenBuf = new Buffer([extras.length]);
		var extrasBuf = Buffer.concat(extras.map(function(extra) {
			return extra.getBytes();
		}));

		// serialize the action on 2 bytes
		var act = params[0];
		traceProtocol && traceProtocol("Send Action: "+act);
		var actBuf = new Buffer([(act >> 8) & 0xff, act & 0xff]);

		//if (params.length > 2) params = params.slice(0, 2).concat([params.slice(2)]);
		var serialized = serializeActionParams(act, params.slice(1));
		var paramsBuf = serialized.buf;
		//console.log("PARAMS: " + paramsBuf.toString('hex'));
/*
		// slice to skip first act param.
		// convert the other parameters (optional ist from param.target + param.std) to string resus and serialize them
		var paramsBuf = Buffer.concat(params.slice(1).map(function(p, i) {
			return new CvgResu(CvgResuTdo["STRU"], p).getBytes();
		}));*/

		// serialize length (2 bytes for action + size of its params)
		var lenBuf = new Buffer(2);
		lenBuf.writeInt16BE(2 + serialized.stdLen, 0);

		// concatenate all the pieces and send it
		var data = Buffer.concat([resuBuf, extrasLenBuf, extrasBuf, lenBuf, actBuf, paramsBuf]);
		//console.log("SENDING: " + data.toString('hex'));
		this.stream.write(_, data);
	},
	processSuperAction: function(_, body) {
		
		var mergeResponse = function (to, from) {
		    for (var n in from) {
		        if (typeof to[n] !== 'object') {
		            to[n] = from[n];
		        } else if (typeof from[n] === 'object') {
		            to[n] = mergeResponse(to[n], from[n]);
		        }
		    }
		    return to;
		};
		
		traceAction && traceAction("===================================");
		traceAction && traceAction("Process Super Action:\n" + JSON.stringify(body, null, 2));
		//console.error("SuperAction ID: " + body.act);
		var offset = 768, superAction = body.act - offset > 0 ? CvgSuperAction[body.act - offset] : null;
		if (!superAction) throw new Error("Bad super action [" + body.act + "]");
		//console.error("SUPER ACTION: "+JSON.stringify(superAction,null,2));
		
		var std = [];
		if (body.param && body.param.sudo) {
			for (var i in body.param.sudo)
				std.push(body.param.sudo[i]);
			delete body.param.sudo;
		}
		
		
		var resp = {}, nextFld;
		for (var i = 0; i < superAction.actions.length; i++) {
			var newBody = JSON.parse(JSON.stringify(body));

			var action = superAction.actions[i];
			//console.error("Process Action: "+JSON.stringify(action,null,2));
			if (!CvgAction[action.name]) throw new Error("Bad sub-action: " + action.name);

			var processNext = true;
			newBody.act = CvgAction[action.name];		
			
			if (nextFld) {
				newBody.fld.ist = nextFld.ist;
				newBody.fld.v = nextFld.v;
			}
			
			if (!action.setTarget) {
				traceAction && traceAction("DELETE TARGET !!!");
				delete newBody.param.target; 
			}


			
			// Use other action sudo params (action number is added to params)
			if (action.propagate) {
				newBody.param.std = [std[i]];
				newBody.param.std.push(CvgAction[action.propagate]);
			} else if (std[i]) {
				newBody.param.std = std[i];
			}
				
			
			var newResp = this.processAction(_, newBody);
			mergeResponse(resp, newResp);

			resp = JSON.parse(JSON.stringify(resp)); // invoke toJSON methods -- improve later
			//console.error("Resp: "+JSON.stringify(resp,null,2));
			var t1 = resp.sap && resp.sap.target && resp.sap.target.type === 'ist' && resp.sap.target.ist;
			if (!t1) break;
			if (action.setTarget) {
				var t0 = newBody.param && newBody.param.target;
				processNext = superAction.processNextAction(CvgAction[action.name], t0, t1, action.checkNumLine);
			}
			//console.error("Process Next: "+processNext);
			if (!processNext) {
				break;
			}else{
				var respTarget = resp.sap.target.ist;
				if (respTarget){
					nextFld = {
						ist: {
							xid: respTarget.xid,
							win: respTarget.win
						},
						v: respTarget.v
					}
					if (respTarget.nl)
						nextFld.ist.nl = respTarget.nl;
				}
			}
				
		}
		return resp;
	},
	processRequest: function(_, body) {
		if (body.act > 1024) return this.processAction(_, body);
		else return this.processSuperAction(_, body);
	},
	targetToXid: function(target) {
		var xid0index = target.xid[0];
		if (xid0index === 'b') xid0index = "AH";
		var xid = target.win + ',' + xid0index + ',' + target.xid.substring(1);
		if (target.nl != null && target.nl !== "-1") xid += ',' + target.nl;
		return xid;
	},
	getMessage: function() {
		var args = [module, arguments[0]];
		for (var i = 1; i < arguments.length; i++){
			args.push(arguments[i] ? arguments[i].toString() : arguments[i]);
		}
		var res = locale.format.apply(null, args);
		return res;
	},
	addAdxIstOfPickedLines: function(aPickedLine) {
		this.adxIstsOfPickedLines.push(aPickedLine);
	},
	addLogicalErrorMess: function(aObject, aMethod, aIst, aMessage) {
		//throw new Error(aMessage);
		if (this.hasActiveRequest()) {
			this.activeRequest.reply.addLogicalErrorMess(aObject, aMethod, aIst, aMessage);
		} else {
			if (this.logicalErrorMessage == null) {
				var wMess = this.getMessage('ERROR_LOGICAL');
				this.logicalErrorMessage = new CvgMessage(CvgReply.WEBSERVER, this, wMess, false);
			}
			this.logicalErrorMessage.addWebServerLogicalMess(CvgReply.buildLogicalErrorMess(aObject, aMethod, aIst, aMessage));
		}
	},
	addStatusIconDef: function(instance, aNumText, aTxt, aImgId, aActionId) {
		var winFound = null;
		for (var i = 0; i < this.stackedWindows.length && winFound == null; i++) {
			var item = this.stackedWindows[i];
			if (item.getAdxIst().winAlphaId === instance.winAlphaId) {
				winFound = item;
			}
		}
		if (winFound != null) {
			winFound.addStatusIconDef(instance, aNumText, aTxt, aImgId, aActionId);
		}
	},
//	changePivotDate: function(prop) {
//		this.formater.setUserDateFormat(this.config.uiParamIDATE, this.config.uiParamSEPDATE, parseInt(prop.strValue));
//		setOneSessionSetting(prop.id, prop.strValueNotNull);
//	},
//	changeUserContext: function(aAguments) {
//		TODO_SUPER.changeUserContext(aAguments);
//		if (this.hasActiveRequest()) {
//			var reply = this.activeRequest.adonixReply;
//			if (reply.hasChangedAdonixLang()) {
//				setCacheContext(reply.changedAdonixLang);
//			}
//		}
//	},
	clearAdxIstsOfPickedLines: function() {
		this.adxIstsOfPickedLines.clear();
	},
	
	closeClient: function(_, fromSameThread, e, reason) {
		console.log("CloseClient Convergence Client\n\tReason[" + reason + "]\n\tAlreadyClosed[" + (this.connClient == null || !this.connClient.hasSocket()) + "] - Exception[" + (e == null ? "No" : e.message) + "]");
		new CvgClose(this, reason, e, "");
		// CloseSocket
		if (this.stream) {
			this.stream.end();
			this.stream = null;
		}
	},
	configFormater: function() {
		/*
		 * 0 (mm/jj/aa) si DATE_FORMAT_KEY = 21 ou 22 1 (jj/mm/aa) si
		 * DATE_FORMAT_KEY = 11 ou 12
		 *
		 * MDY=0, DMY=1, YMD=2 => (1, "/", 1950).
		 */
		this.formater.settings.dateOrder = this.config.params.IDate;
		this.formater.settings.dateSep = this.config.params.SDate;
		//this.formater.settings.pivotDate = this.config.params.uiParamPIVOTDATE;
		this.formater.settings.decimalSep = this.config.params.SDecimal;
		this.formater.settings.thousandSep = this.config.params.SThousand;
		// pour optilmiser le flux xml vers le browser: suprime les espaces de cadrage a droite pour les valeur alpha.
		this.formater.settings.vOn = this.config.getFormaterVon();
		this.formater.settings.zOn = true;
	},
	// retourne vrai si la liste de propri�t� contient la propriete
	containsAdxPubSubFile: function(aListOfProperties) {
		var wProperty;
		var wMax = aListOfProperties.length;
		var wI = 3; // pour demarer a la 4eme propriete !
		while (wI < wMax) {
			wProperty = aListOfProperties.get(wI);
			if (wProperty.hasId() && wProperty.id.toUpperCase() === "UIAdxPubSubFile".toUpperCase()) {
				return true;
			}
			wI++;
		}
		return false;
	},
	// Demande d'une déconnexion au serveur X3
	deconnectClient: function(_,reason) {
		try {
			console.log("Deconnect client\n\tReason[" + (reason == null ? "none" : reason) + "]\n\tAsk X3 server to close ");
			// create a request for deconnection
			var deconnectReq = {
				act : 1075,
				fld : {},
				param : {},
				tech : {}
			};
			return this.processAction(_,deconnectReq);
		} finally {
			this.realeaseActiveRequest();
		}
	},
	execCallUi: function(values) {
		if (values.UIAction === "SessionSettings") {
			return this.executeAllSessionSettings(values);
		} else if (values.UIAction === "SetWindFeatures") {
			return this.executeAllSessionSettings(values);
		} else if (values.UIAction === "Sethangup") {
			return this.executeCallUiSetHangHup(values);
		} else if (values.UIAction === "SetTechnoVers") {
			return this.executeCallUiSetTechnovers(values);
		} else if (values.UIAction === "GetFileAlways") {
			return this.executeCallUiGetFile(true, values);
		} else if (values.UIAction === "GetFile") {
			return this.executeCallUiGetFile(false, values);
		} else if (values.UIAction === "PutFileAlways") {
			return this.executeCallUiPutFile(true, values);
		} else if (values.UIAction === "PutFile") {
			return this.executeCallUiPutFile(false, values);
		} else if (values.UIAction === "OpenFile") {
			return this.executeCallUiOpenFile(values);
		}
	},
	executeAllSessionSettings: function(values) {
		var keys = Object.keys(values);
		for (var i = 1; i < keys.length; i++) {
			//console.error("Set sessionSettings: "+keys[i]+" ["+values[keys[i]]+"]");
			this.appSrvSessionSettings[keys[i]] = values[keys[i]];
		}
		// Set formater datePivot
		if (!this.formater.settings.datePivot)
			this.formater.settings.datePivot = this.appSrvSessionSettings.DefaultDatePivot || 1963;
		return {
			UIAction: "SessionSettings"
		};
	},
	executeCallUiSetTechnovers: function(values) {
		// TODO manage protocol negociation
		this.executeAllSessionSettings(values);
		return values;
	},
	executeCallUiSetHangHup: function(values) {
		if (values.UITimehangup1) this.maxTimeBeforeHangUp = values.UITimehangup1 < 1 ? -1 : values.UITimehangup1;
		if (values.UITimehangup2) this.maxTimeBeforeAutomaticHangUp = values.UITimehangup2 < 1 ? -1 : values.UITimehangup2;
		return {
			Sethangup: 1
		};
	},
	/*
	 * Demande au serveur UI d'ouvrir un fichier. si le paramere "UILocalDir"
	 * contient HTTP, c'est pour ouvrir un fichier via IE
	 *
	 * Exemples : <ul> <li>0= id=[UIAction] value=[OpenFile]</li> <li>1=
	 * id=[UILocalDir] value=[HTTP]</li> <li>2= id=[UILocalFile]
	 * value=[172.16.12
	 * .41:80/x3webdata/GX3APP/TMP/F5963808_EDITRTWEB_53711.xml]</li> <li>3=
	 * id=[ADXPUB_SubFile] value=[1]</li> </ul>
	 *
	 * Ce CallUi est employe pour ouvrir des exports xml ou excel
	 *
	 * <pre> "UIAction="+chr$(1)+"OpenFile", "UILocalDir="+ chr$(1) +"HTTP",
	 * "UILocalFile="+ chr$(1) +"www.meteo.fr/"
	 *
	 * "UIAction="+chr$(1)+"OpenFile", "UILocalDir="+ chr$(1) +"tmp",
	 * "UILocalFile="+ chr$(1) +"test.txt" </pre>
	 */
	executeCallUiOpenFile: function(aListOfProperties) {
		var wMax = aListOfProperties.length;
		if (wMax > 2) {
			var wLocalDir = aListOfProperties.get(1).strValue;
			var wLocalFile = aListOfProperties.get(2).strValue;

			var wUrl = "";
			/*
			 * si UILocalDir == "HTTP", alors UILocalFile contient un URL
			 */
			if (wLocalDir === "HTTP") {
				wUrl.append(translateLocalFileUrl(wLocalFile, aListOfProperties));
			}
			/*
			 * sinon, et UILocalFile sont des chemins et un nom de
			 * fichier relatifs au dossier HOME de l'utilisateur
			 */
			else {
				wUrl += this.clientConfig.params[CvgClientConfig.USERHOMEVIRTUALPATH];
				wUrl += '/';
				wUrl += wLocalDir;
				wUrl += '/';
				wUrl += wLocalFile;
			}
			var wReply = this.activeRequest.adonixReply;
			var wCallUiOpenFile = wReply.addAskOpenFile(wUrl.toString());
			var wProperty;
			var wPropertyId;
			var wI = 3;
			while (wI < wMax) {
				wProperty = aListOfProperties.get(wI);
				wPropertyId = wProperty.id;
				if (wPropertyId !== "UILocalDir" && wPropertyId !== "UILocalFile") {
					wCallUiOpenFile.addOneParam(wPropertyId.toLowerCase(), wProperty.strValue);
				}
				wI++;
			}
		}
		return CAdonixCallUiReply.OK;
	},
	findModifiable: function(aStructIst) {
		var wSettableFinder = new CModifiableFinder();
		this.traverseSettable(aStructIst, wSettableFinder);
		return wSettableFinder.foundModifiable;
	},
	getNewStackedWindows: function(aWindowId, aFunctionId, aDescr, aStamp, aWindowIdxBaseOne) {
		return new CvgStackedWindow(this, aWindowId, aFunctionId, aDescr, aStamp, aWindowIdxBaseOne);
	},
	hasActiveRequest: function() {
		return this.activeRequest != null;
	},
	hasApplicationId: function() {
		return this.applicationID != null;
	},
	hasValidFormater: function() {
		return this.formater != null && this.formater.isValid();
	},
	initResources: function(aLanguage) {},
	initFormater: function() {
		this.formater = new CvgFormatter();
		this.configFormater();
	},
	initSessionWeight: function(aAdonixContext, aSessionWeight) {
		aAdonixContext.setX3SessionWeight(aSessionWeight);
	},
	isUrlPortalSessionSetting: function(aId) {
		return aId.toLowerCase().startsWith("PortalUrl".toLowerCase());
	},
	isWithLogicalErrDetails: function() {
		return this.withLogicalErrDetails;
	},
	listenLogicalErr: function(aObject, aMethode, aMessage) {
		if (isWithLogicalErrDetails()) {
			this.addLogicalErrorMess(aObject, aMethode, "", aMessage);
		}

	},
	// Connection messages
	listenNodeND_SLF: function(_, reader, node, properties) {
		checkLen(properties, 1);
		var values = properties[0];
		var result = this.execCallUi(values);
		return formatKeyValues(result);
	},
	listenNodeND_GFD: function(_, reader, node, lines) {
		checkLen(lines, 1);
		var key = lines[0];
		var result = {}
		result[key] = this.clientConfig.params[key];
		if (result[key] === undefined) {
			result[key] = key + " : unsupported param";
		}
		return formatKeyValues(result);
	},
	listenNodeNDCOPMENU: function(_, reader, node, data) {
		//reply.setSplashInfos(data);
	},
	listenNodeNDDEB: function(_, reader, node) {},

	listenNodeND_CLT: function(_, reader, node, dummyByte) {
		// 15w_001 - Fiche 36012 - X3Client: Supervision des sockets
		// Si réception du noeud ND_CLT non attendu => not ok fermeture du
		// client depuis le même thread
		this.closeClient(_, true, null, 3);
	},
	/**
	 * NDACTOBJ (Adxcpl_displayWin) Affichage d'une fenetre Id=[NDACTOBJ]
	 * x3func=[Adxcpl_displayWin] NbArgs=[2] - ist =[ win=[2] srn=[0] blc=[0]
	 * fld=[0] idx=[0]] - opt=[.x04]
	 */
	listenNodeNDACTOBJ: function(_, reader, node, ist, num) {
		var WIN_NOHIDDEN = 4;
		if (num > WIN_NOHIDDEN) {
			var win = findModifiable(ist);
			if (win != null && win instanceof CvgStackedWindow) {
				win.setScreenToShow(num - WIN_NOHIDDEN + 1);
			}
		} else {
			// TODO
		}
	},
	
	listenNodeND_INT: function(_, reader, node) {
		// 0 means continue 4GL process | 1 means interrupt
		return 0;
	},

	listenNodeNDSYSTEM: function(_, reader, node) {
		// Not supported anymore
		return [0];
	},
	
	listenNodeNDEDBK: function(_, reader, node) {
		// Not supported bu convergence
		return [0, 0];
	},
	
	listenNodeND_OCX: function(_, reader, node) {
		// Not supported bu convergence
		return [0, 0, 0, 0, 0];
	},
	listenNodeND_IHM: function(_, reader, node) {
		// Not supported bu convergence
		return [0, 0, 0, 0, 0];
	},
	listenNodeNDGTDT: function(_, reader, node) {
		// Not supported bu convergence
		return [0, 0, 0, 0, 0];
	},
	
	/**
	 * NDACTOP 0E4000 (Activation_Action) Activation d=[NDACTOP] level=[?]
	 * x3func=[Activation_Action] nb=[2] - ide=[2823] ID Action - typ=[.x01]
	 * Status
	 */
	listenNodeNDACTOP: function(_, reader, node, wActionId, wFlag) {
		new CvgMenuAct(this, wActionId, wFlag);
	},

	/**
	 * Le serveur envoi 3 noeuds ndctsu pour d�crire un format dynamique. voir
	 * l'innerclasse "CDynFormat" Id=[NDCTSU] level=[C]
	 * x3func=[Control_DefineType] NbArgs=[3] - opt=[.x65] - su1 =[c] - su2 =[_]
	 */
	listenNodeNDCTSU: function(_, reader, node, wType, wSubType, wComplement) {
		/*
		 * Traite le premier noeud NDCTSU contenant le type. Exemple: Type=[g]
		 * SubType=[] Complement=[] Le noeud correspondant: Id=[NDCTSU]
		 * func=[Control_DefineType] NbArgs=[3] opt=[.x67] su1 =[] su2 =[])
		 */
		if (this.currentDynFormat == null) {
			this.currentDynFormat = new CDynFormat(String.fromCharCode(wType), this.formater);
			this.sessDynFormat.push(this.currentDynFormat);
		}
		/*
		 * Traite le deuxieme noeud NDCTSU contenant le SubType. Exemple:
		 * Type=[g] SubType=[AX] Complement=[] Le noeud correspondant:
		 * Id=[NDCTSU] func=[Control_DefineType] NbArgs=[3] opt=[.x67] su1 =[AX]
		 * su2 =[]
		 */
		else if (this.currentDynFormat.subType == null) {
			this.currentDynFormat.subType = wSubType;
		}
		/*
		 * Traite le troisi�me noeud NDCTSU contenant le complement (ou non).
		 * Exemple: Type=[g] SubType=[AX] Complement=[] Le noeud correspondant:
		 * Id=[NDCTSU] func=[Control_DefineType] NbArgs=[3] opt=[.x67] su1 =[AX]
		 * su2 =[]
		 */
		else {
			/*
			 * mis en place du complement, creation du format dynamique dans le
			 * formater, et destroy du format dynamique
			 */
			this.currentDynFormat.complement = wComplement;
			if (nodeconfig.config && nodeconfig.config.x3fusion && nodeconfig.config.x3fusion.enableDynFormats)
				this.formater.addDynamicFormat(this.currentDynFormat);
			this.currentDynFormat = null;
		}
	},

	/**
	 * NDOMNCO 0E015E (MenuDyn_New) Id=[NDOMNCO] level=[R] x3func=[MenuDyn_New]
	 * NbArgs=[5] - flg=[.x58] - cod=[1026] - txt=[S�lection] - acc=[0] - hlp
	 * =[] parametre passes a la fonction "MenuDyn_New" du client X3 :
	 *
	 * (*fnd)( (flg&0x40)>>6, fen, (flg&0x08)>>3, cod, txt, acc, (flg&0x7), 0,
	 * (flg&0x10)>>4, (flg&0x20)>>5, hlp ) ;
	 *
	 * bFirst Premiere option (vide la liste) ((wByte & 0x40) >> 6) nRang Rang
	 * d'insertion de l'option (0 pas d'option) nType Type de l'option (flg &
	 * 0x08) >>3) nAction Action � renvoy�e au serveur pszText texte de l'option
	 * nAccel Acc�l�rateur nCateg Cat�gorie dans le type (flg&0x7) nImage Num�ro
	 * de l'image bValide Valide ou bien (flg&0x10)>>4 bSelect S�lectionn� ou
	 * bien (flg&0x20)>>5 pszhelp texte d'aide rapide
	 */
	listenNodeNDOMNCO: function(_, reader, node, wFlg, wActionId, wTxt) {
		/*
		 * first node => flg=[.x58] others => flg=[.x18]
		 */
		var wVidage = (wFlg & 0x40) !== 0;
		/*
		 * boolean wFlag = ((wByte & 0x40) >> 6) != 0; int wType = ((wByte &
		 * 0x08) >>3); wAcc >> 3
		 */
		var wType = (wFlg & 0x08) >> 3 === 0;
		/*
		 * si ce n'est pas un enoeud de "vidage"
		 */
		if (!wType && wActionId > 0) // ???
		{
			/*
			 * si "vidage" de la liste
			 */
			if (wVidage) {
				this.removeCtxButtons();
			}
			new CvgMenuCtx(this, wActionId, true, wTxt);
		}
	},

	/**
	 * Changement element dans barre de statut Id=[NDOTXSC] level=[W]
	 * x3func=[Status_ChangeStatus] NbArgs=[6] - ist =[ win=[2] srn=[0] blc=[0]
	 * fld=[0] idx=[0]] - st[0]=[.x00] (byte) - st[1]=[132] (int) - buf[0] =[]
	 * (stru) - buf[1] =[] (stru) - st[2]=[3058] (int)
	 */
	listenNodeNDOTXSC: function(_, reader, node, wIst, wNumText, wImgId, wTxt, wTxtDummy, wActionId) {
		this.addStatusIconDef(wIst, wNumText, wTxt, wImgId, wActionId);
	},

	/**
	 * Id=[NDPKAR] func=[LeftList_Picking] NbArgs=[1] - ist =[ win=[2] srn=[34]
	 * blc=[3] fld=[0] idx=[0]]
	 */
	listenNodeNDPKAR: function(_, reader, node) {
		var wActionArgs;
		if (this.adxIstsOfPickedLines.length > 0) {
			var wPickedLine = this.adxIstsOfPickedLines.splice(0, 1)[0];
			var wActionArgs = [wPickedLine.action];
			var wArgIst = wPickedLine.ist;
			var wLeftListLine = this.findModifiable(wArgIst);
			if (wLeftListLine != null) {
				// suppression du numero de ligne dans l'adxid de la lisgne pickee ajout de l'argument tdans la liste
				wArgIst.idx = 0;
				wActionArgs.push(wArgIst);
				// ajout de l'argument tableau de r�su qu'est la cle de la ligne  pickee
				wActionArgs.push(wLeftListLine.cle);
			} else {
				wActionArgs.push(wArgIst.toString());
				var wMess = this.getMessage('ERROR_CANT_GET_PICKED_LINE_KEY', String.valueOf(wArgIst.idx));
				this.addLogicalErrorMess(this, "NDPKAR", wArgIst.toString(), wMess);
			}
		} else {
			wActionArgs = [CvgAction.SRV_ABANDON];
		}
		// BRJOU: did not see any resu, pass null
		this.sendAction(_, new CvgResu(CvgResuTdo["NULL"], null), [], wActionArgs);
	},

	listenSegment: function(aSegment) {
		var retour = false;
		retour = TODO_SUPER.listenSegment(aSegment);
		if (!retour && aSegment instanceof CSegmentNode) {
			var wSegmentNode = aSegment;
			var wNodeId = wSegmentNode.nodeId;
			switch (wNodeId) {
			case CvgNode.NDACTOP:
				retour = listenNodeNDACTOP(wSegmentNode);
				break;
			case CvgNode.NDOMNCO:
				retour = listenNodeNDOMNCO(wSegmentNode);
				break;
			case CvgNode.NDCTSU:
				retour = listenNodeNDCTSU(wSegmentNode);
				break;
			case CvgNode.NDOTXSC:
				retour = listenNodeNDOTXSC(wSegmentNode);
				break;
			case CvgNode.NDPKAR:
				retour = listenNodeNDPKAR(wSegmentNode);
				break;
			}
		}
		return retour;
	},
	newActiveRequest: function(reply, aParams, sendContext) {
		this.razModifications();
		this.activeRequest = new CvgRequest(this, reply, aParams, sendContext);;
		this.trackLists = this.newTrackLists(); // should be inside request???
		return this.activeRequest;
	},
	/*
	open: function(aAdonixContext) {
		throw new Error("not used")
		try {
			//initResources(aAdonixContext.x3Language);
			if (isServerConnected()) {
				throw new Error("CANT_OPEN - one conn already opened !");
			}
			if (!hasApplicationId()) {
				throw new Error("CANT_OPEN - no ApplicationId set!");
			}
			initSessionWeight(aAdonixContext, this.config.sessionWeight);
			validAdonixContext(aAdonixContext);
			setCacheContext(aAdonixContext.x3Language);
			/*
			 * creation de la requete de connexion sans segment action associe.
			 * Utilisation du constructeur de CAdonixRequest sans liste d'Args
			 * et avec une ActionId correspondant a une action locale.
			 *
			var aX3Reply = checkFailed(connect(aAdonixContext, newActiveRequest(new CvgReply(this, CONNECT_ACTION), null,{"reqNum": 0})), "X3 Open Connexion failed");
			if (isServerConnected() && aX3Reply.isOk()) {
				this.connClientNode.setLogicalErrorListner(this);
			}
			aX3Reply = removeActiveRequest(aX3Reply);
			aX3Reply.setOneSessionSetting("VOn", this.formater.isVOn() ? "1" : "0");
			aX3Reply.setOneSessionSetting("ZOn", this.formater.isZOn() ? "1" : "0");
			return checkFailed(aX3Reply, "X3 Open Connexion failed");
		} finally {
			this.realeaseActiveRequest();
		}
	},*/
	popRequesterWindow: function() {
		var window = this.stackedWindows.popStackedWindow();
		window.setOpened(false);
		return window;
	},
	pushAffSynchroneMessage: function(aMessage) {
		this.affSynchroneMessages.addElement(aMessage);
	},
	pushAffSynchroneMessTempOn: function(aMessage) {
		pushAffSynchroneMessage(new CvgMessage(Cvg.AFF_SYNCHRONE_TYPE_TEMPON, this, aMessage, false));
	},
	pushRequesterWindow: function(aWindowId, aFunctionId, aDescr, aStamp, aWindowIdxBaseOne) {
		var wRequesterWindow = this.getNewStackedWindows(aWindowId, aFunctionId, aDescr, aStamp, aWindowIdxBaseOne);
		this.stackedWindows.pushStackedWindow(wRequesterWindow);
		wRequesterWindow.setStackLevel(this.stackedWindows.length);
		wRequesterWindow.setOpened(true);
		return wRequesterWindow;
	},
	razModifications: function() {
		this.stackedWindows.razModifications();
		this.formater.razModifications();
	},
	realeaseActiveRequest: function() {
		var wActiveRequest;
		wActiveRequest = this.activeRequest;
		this.activeRequest = null;
		if (wActiveRequest != null) {
			//TODO reimpl method -> wActiveRequest.releaseRefs();
		}
	},
	releaseAllAffSynchroneMessages: function() {
		var wNbMess = this.affSynchroneMessages.length;
		if (wNbMess > 0) {
			this.affSynchroneMessages.removeAllElements();
		}
	},
	releaseRefs: function() {
		this.formater.end();
		this.formater = null;
		this.motherWindow = null;
		this.stackedWindows.clear();
		this.stackedWindows = null;
		this.realeaseActiveRequest();
		this.config = null;
		this.adxIstsOfPickedLines = null;
		releaseAllAffSynchroneMessages();
		this.affSynchroneMessages = null;
		this.applicationID = null;
		this.currentDynFormat = null;
		TODO_SUPER.releaseRefs();

	},
	removeActiveRequest: function(aAdonixReply) {
		var wX3Reply = aAdonixReply;
		if (this.hasActiveRequest()) {
			wX3Reply = this.activeRequest.reply;
			this.realeaseActiveRequest();
		}
		return wX3Reply;
	},
	/*
	sendX3Action: function(args, sendContext) {
		try {
			var actionCode = args != null && !args.isEmpty() && args.get(0) instanceof Integer ? args.get(0) : null;
			if (actionCode == null) {
				throw new Error("sendX3Action - Bad first argument - Integer expected");
			}
			return checkFailed(sendAction(new CvgReply(this, actionCode), args, sendContext), "X3 send action failed");
		} finally {
			releaseAllAffSynchroneMessages();
		}
	},
	sendX3ActionAckCall: function(aAdxId, aSpgmElmtl) {
		var wX3ActionDatas = buildAckCallDatas(aAdxId, aSpgmElmtl);
		wX3ActionDatas.add(0, CvgIstDatas.getIstDatasNull());
		wX3ActionDatas.add(0, new Integer(CvgAction.SRV_CALLREMOTESPGM));
		return checkFailed(sendX3Action(wX3ActionDatas, null), "X3 send AckCall failed");

	},
	sendX3ActionAckResi: function(aAdxId, aExecIstResultXml) {
		var wX3ActionDatas = buildActionAckResiDatas(aAdxId, aExecIstResultXml);
		wX3ActionDatas.add(0, CvgIstDatas.getIstDatasNull());
		wX3ActionDatas.add(0, new Integer(CvgAction.SRV_EXECI_RESPONSE));
		return sendX3Action(wX3ActionDatas, null);
	},
	*/
	setActiveRequest: function(aRequest) {
		this.activeRequest = aRequest;
		return this.activeRequest;
	},
	setCacheContext: function(aLang) {
		this.adonixContext.setLanguage(aLang);
	},
	setCurrentDynFormat: function(currentDynFormat) {
		this.currentDynFormat = currentDynFormat;
	},
	setCurrentField: function(currentField) {
		this.currentField = currentField;
	},
	setMonthList: function(aStructProperty) {
		this.formater.setMonthList(aStructProperty.strValue);
	},
	storeUrlPortalSessionSetting: function(aId, aUrlPortal) {
		var wSB = new StringBuilder(128);
		var wPos = aUrlPortal.indexOf("/ADX_PORTAL");
		if (wPos === -1) {
			wSB.append("error://le param�tre \"SessionSettings.PortalUrl\" contient un url erron� : absence de la racine du portail \"/ADX_PORTAL\". ");
			wSB.append(aUrlPortal);
		} else {
			/*
			 * par un url relatif au serveur de Web. exemple:
			 * "/x3webheaddata/[solution]
			 */
			wSB.append(this.clientConfig.getParam(CvgClientConfig.VIRTUALPATHPAGES));
			// recuperation du nom de la solution dans l'url http
			var solName = this.httpX3ServerUrl.substring(this.httpX3ServerUrl.indexOf("_")); // prends pour hypothese que l'url est de la forme http://server:port/Adonix_SOL
			if (solName == null) {
				solName = this.adonixContext.x3ServerAppliHostname;
			}
			wSB.append('/').append(solName);
			/*
			 * laisser la racine du portail "/ADX_PORTAL" comp�ter par la
			 * d�signation de la page de d�marrage. exemple :
			 * "/ADX_PORTAL/PortalStartCSF.htm"
			 */
			wSB.append(aUrlPortal.substring(wPos));
			/*
			 * on ajoute � l'URL les param�tres n�cessaires au fonctionnement du
			 * portail depuis le client Web : - DlgMode=WEB - LANG=xxx
			 */
			wSB.append('?').append("DlgMode").append('=').append("WEB");
			wSB.append('&').append("LANG").append('=').append(this.adonixContext.language);
		}
		setOneSessionSetting(aId, wSB.toString());
	},
	toString: function(aSeparator) {
		var wSB = new StringBuilder(512);
		TODO_SUPER.addDescrInSB(wSB, aSeparator);
		if (aSeparator != null) {
			wSB.append(aSeparator);
		}
		CStringFacilities.addInStringDescr(wSB, "NbParamConfig", this.config.size());
		return wSB.toString();
	},

	/**
	 * construit l'Url utilis� par le browser en fonction de la pr�sence ou non
	 * du param�tre "UIAdxPubSubFile"
	 *
	 * cas 1 <li>0= "UIAction="+chr$(1)+"OpenFile", <li>1= "UILocalDir="+
	 * chr$(1) +"HTTP", <li>2= "UILocalFile="+ chr$(1) +"www.meteo.fr/"
	 *
	 * il faut seulelemnt ajouter le pr�fixe "http://" pour obtenir l'url absolu
	 * :
	 *
	 * <pre>
	 * &quot;http://www.meteo.fr/&quot; Le browser utilise l'attribut &quot;url&quot; du noeud &quot;open_file&quot;
	 * </pre>
	 *
	 * tel quel: <open_file url="http://www.meteo.fr/" " ></open_file>
	 *
	 * cas 2 : <li>0= id=[UIAction] value=[OpenFile] <li>1= id=[UILocalDir]
	 * value=[HTTP] <li>2= id=[UILocalFile]
	 * value=[172.16.12.41:80/x3webdata/GX3APP/TMP/F5963808_EDITRTWEB_53711.xml]
	 * <li>3= id=[AdxPubSubFile] value=[1]
	 *
	 * <p>
	 * Comme c'est un sous-fichier du dossier ADX_PUB du serveur d'application,
	 * celui ci doit etre atteind via le proxypass.
	 * <p>
	 * Il faut donc suprimer le pr�fixe de de la forme :
	 * "AdonixApplicationServerHostName:port/adxwedata/"
	 * <p>
	 * Le browser utilise l'attribut "url" du noeud "open_file" en ajoutant le
	 * prefixe "http://ServerWebHostName:port/AliasOfProxyPath/[solution]" :
	 * <open_file url="/GX3APP/TMP/F5963808_EDITRTWEB_53711.xml"
	 * uiadxpubsubfile="1" ></open_file>
	 */
	translateLocalFileUrl: function(aUrlFile, aListOfProperties) {
		var wSB = new StringBuilder(128);
		/*
		 * si ce n'est pas un "subfile" de ADX_PUB => on ajoute seulement
		 * "http://" devant "aUrlFile"
		 */
		if (!containsAdxPubSubFile(aListOfProperties)) {
			wSB.append("http://");
			wSB.append(aUrlFile);
		}
		/*
		 * sinon, si c'est un "subfile" de ADX_PUB, il faut suprimer le pr�fixe
		 * de de la forme "AdonixApplicationServerHostName:port/adxwedata/
		 */
		else {
			// 15w_016 - Fiche 44800 - Erreur d'URL sur export sur requeteur graphique
			aUrlFile = aUrlFile.replace('\\', '/');
			// recherche de la position du "slash" apr�s
			// "AdonixApplicationServerHostName:port"
			var wPos = aUrlFile.indexOf('/');
			// 15w_000 - Fiche 34938 - Protection contre les url malform�s dans les callui openfile
			if (wPos > -1 && wPos < aUrlFile.length() - 1) {
				// recherche de la position du "slash" apr�s l'alias du dossier ADX_PUB
				wPos = aUrlFile.indexOf('/', wPos + 1);
			}
			var wMalformedUrl = wPos === -1 || wPos > aUrlFile.length() - 1;
			if (wMalformedUrl) {
				var wMess = String.format("Malformed url, not an AdxPubSubFile !", aUrlFile);
				var wException = new CCommException(CCommException.ERR_ARG_PROTOCOL, wMess);
				throw wException;
			}
			wSB.append(aUrlFile.substring(wPos));
		}
		return wSB.toString();
	},
	traverseSettable: function(aStructIst, aModifier) {
		if (aStructIst.isWindowIst() && aStructIst.winZeroBase === -1) {
			return aModifier.setModifiable(aStructIst, this.motherWindow);
		} else {
			return this.stackedWindows.traverseSettable(aStructIst, aModifier);
		}
	},
	track: function(obj) {
		var list = this.trackLists[obj.jsonType];
		if (obj.getObservableId) {
			// we can add keys directly to the array, they will be ignored by JSON.stringify
			var key = '#' + obj.getObservableId();
			var old = list[key];
			if (old != null){
				list[old] = undefined;
			}
			list[key] = list.length;
		}
		list.push(obj);
	},
	// Fusion
	removeCtxButtons: function() {
		for (var i in this.trackLists) {
			if (this.trackLists[i] instanceof CvgMenuCtx) {
				console.error("instanceof CvgMenuCtx");
			}
		}
	},
	filterSessionSettings: function() {
		var map = {
			"ADXVersion": "ADXVersion",
			"adonix.port": "ADXPort",
			"usrProfile": "usrProfile",
			"session.apphostname": "ADXAppHost",
			"Version": "Version",
			"ADXProduct": "ADXProduct",
			"Protocol": "Protocol",
			"STime": "STime",
			"SDecimal": "SDecimal",
			"ADXLangIso": "ADXLangIso",
			"SThousand": "SThousand",
			"adonix.host": "ADXTrtHost",
			"AdxSolution": "AdxSolution",
			"ADXProductPref": "ADXProductPref",
			"ADXProductLabel": "ADXProductLabel",
			"SetMonthList": "SetMonthList",
			"formater.von": "formater.von",
			"SDate": "SDate",
			"ADXProductInfoVers": "ADXProductInfoVers",
			"ADXSupVers": "ADXSupVers",
			"mnu": "mnu",
			"DefaultDatePivot": "DefaultDatePivot",
			"session.username": "user",
			"ADXTheme": "ADXTheme",
			"ADXHttpPub": "ADXHttpPub",
			"ADXNamedUser": "ADXNamedUser",
			"session.x3folder": "ADXFolder",
			"cdLang": "cdLang",
			"DefaultDateFormat": "DefaultDateFormat",
			"fmtExt": "fmtExt",
			"ADXStyleFile": "ADXStyleFile",
			"ADXNopatch": "ADXNopatch",
			"ADXRelease": "ADXRelease",
			"IDate": "IDate",
			"ADXProductSuff": "ADXProductSuff",
			"BOSEC": "BOSEC",
			"BOSERV": "BOSERV",
			"BOUSR": "BOUSR",
			"BOPWD": "BOPWD",
			"ADXMaskAppName": "ADXMaskAppName"
		}
		var res = {};
		for (var i in map) {
			if (this.sessionSettings[i]) res[map[i]] = this.sessionSettings[i];
			else if (this.appSrvSessionSettings[i]) res[map[i]] = this.appSrvSessionSettings[i];
		}
		return res;
	},
	getResponse: function() {
		var t0 = new Date().getTime();
		var lists = this.trackLists;
		var isDefined = function(o) {
				return o !== undefined;
			};
		var wins = {};
		for (var i = 0; i < lists.ENTITY.length; i++) {
			var entity = lists.ENTITY[i];
			if (entity === undefined) continue;

			var win = this.stackedWindows.findWin(entity.getFatherWindowId().charCodeAt(0) - '@'.charCodeAt(0));
			if (win) {
				var winNode = wins[win.entityIdxAlpha];
				if (!winNode) {
					winNode = wins[win.entityIdxAlpha] || {
						entities: {}
					};
					if (win.statusBar) winNode.statBar = win.statusBar.toJSON();
					if (win.title) winNode.tit = win.title;
					wins[win.entityIdxAlpha] = winNode;
				}
				if (entity instanceof CvgEntity) {
					var gridParent = null;
					var line = null;
					if (entity instanceof CvgVariable) {
						line = entity.srcLine;
					} else if (entity instanceof CvgDataSrcLine) {
						line = entity;
					} else if (entity instanceof CvgDataSrc) {
						gridParent = entity;
					}
					if (line != null) {
						gridParent = line.dataSrc;
					}
					if (gridParent != null || line != null) {
						if (gridParent == null) {
							gridParent = line.dataSrc;
						}
						if (gridParent.isBlocGrid()) {
							entity = gridParent;
						}
					}
					
					var jsonKey = entity.getJsonKey();
	
					if (winNode.entities[jsonKey] == null) {
						var jsonEntity = entity.toJSON();
						if (jsonEntity && Object.keys(jsonEntity).length !== 0) winNode.entities[jsonKey] = jsonEntity;
					}
				}
			}
			if (win && win.entityIdxAlpha && Object.keys(wins[win.entityIdxAlpha].entities).length === 0)
				delete wins[win.entityIdxAlpha];
		}

		var response = {
			sap: {},
			session: lists.SESSION[0] || {},
		};
		var sap = response.sap;

		if (lists.TARGET.length !== 0)
			sap.target = JSON.parse(JSON.stringify(lists.TARGET[lists.TARGET.length - 1]));
		
		 
		if (lists.PREVIOUS.length !== 0){
			var previous = JSON.parse(JSON.stringify(lists.PREVIOUS[lists.PREVIOUS.length - 1]));
			sap.previous = {
				v: previous.ist.v,
				xid: previous.ist.xid,
				win: previous.ist.win,
				nl: previous.ist.nl || -1
			}
		}

		var acts = lists.ACT.filter(isDefined);
		if (acts && acts.length !== 0)
			sap.acts = acts;

		if (lists.RPC.length !== 0 && sap.target.type !== 'portal'){
			sap.rpc = JSON.parse(JSON.stringify(lists.RPC[0]));
		}
		
		for (var i = 0; i < lists.FUNC.length; i++) {
			sap.func = sap.func || {};
			var win = lists.FUNC[i];
			var key = win && win.entityIdxAlpha;
			if (win && win.isOpened()) {
				// object with key: win 
				sap.func.open = sap.func.open || {};
				sap.func.open[key] = win;
			} else {
				// just an array of keys
				sap.func.close = sap.func.close || [];
				sap.func.close.push(key);
//				wins[key] = {
//					tit: win.title,
//					entities: {}
//				};
			}
		}
		if (Object.keys(wins).length > 0)
			sap.wins = wins;
		

		if (sap.target && sap.target.ist){
			for (var i = 0; i < lists.TARGETACT.length; i++) {
				sap.target.ist.acts = sap.target.ist.acts || [];
				sap.target.ist.acts.push(lists.TARGETACT[i]);
			}
		}

		//response.session = {};
		
		if (this.activeRequest.sendContext.connectAction){
			if (this.sessDynFormat.length > 0) {
				this.sessionSettings.fmtExt = {};
				for (var i = 0; i < this.sessDynFormat.length; i++) {
					var item = this.sessDynFormat[i];
					this.sessionSettings.fmtExt[item.type] = item.toJSon();
				}
			}
			this.sessionSettings.mnu = lists.SESSIONMNU;
			response.session.settings = this.filterSessionSettings();
		}
		
		response.srvop = {};//this.srvop;
		// request object 
		var nreq = this.activeRequest.sendContext.reqNum ;

		response.srvop.request = {
			"id": nreq,
			"v": this.activeRequest.reply.orderId,
			"connect": 1,
			"status": this.activeRequest.status,
			"session":this.sessionId,
			"server": os.hostname()
		};
	
		var t1 = new Date().getTime() - t0;
		response.toJsonTime = (t1/1000)%60;

		return response;
	}
});
