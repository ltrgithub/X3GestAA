"use strict";
var helpers = require('syracuse-core/lib/helpers');
var flows = require("streamline/lib/util/flows");
var locale = require("syracuse-core/lib/locale");
var automata = require("syracuse-x3/lib/convergence/automata/x3Automata");
var BoRestClient = require("syracuse-x3/lib/boRestClient").BoRestClient;
var sessionManager = require('syracuse-session/lib/sessionManager').sessionManager;
var x3writer = require("syracuse-x3/lib/convergence/automata/x3writer");
var fs = require('streamline-fs');
var jsxml = require('jsxml');
var httpClient = require("syracuse-httpclient/lib/httpClient");
var x3helpers = require('syracuse-x3/lib/helpers');
var CvgModifier = require('syracuse-x3/lib/convergence/model/CvgModifier').CvgModifier;
var CvgEntity = require('syracuse-x3/lib/convergence/model/CvgEntity').CvgEntity;
var CvgStackedWindows = require('syracuse-x3/lib/convergence/model/CvgStackedWindows').CvgStackedWindows;
var CvgStackedWindow = require('syracuse-x3/lib/convergence/model/CvgStackedWindow').CvgStackedWindow;
var CvgReply = require('syracuse-x3/lib/convergence/client/CvgReply').CvgReply;
var CvgRequest = require('syracuse-x3/lib/convergence/client/CvgRequest').CvgRequest;
var CvgInstance = require('syracuse-x3/lib/convergence/model/CvgInstance').CvgInstance;
var CvgStatusBar = require('syracuse-x3/lib/convergence/model/CvgStatusBar').CvgStatusBar;
var CvgCallUiOpenFile = require('syracuse-x3/lib/convergence/model/CvgCallUiOpenFile').CvgCallUiOpenFile;
var CvgDataSrc = require('syracuse-x3/lib/convergence/model/CvgDataSrc').CvgDataSrc;
var CvgDataSrcLine = require('syracuse-x3/lib/convergence/model/CvgDataSrcLine').CvgDataSrcLine;
var CvgVariable = require('syracuse-x3/lib/convergence/model/CvgVariable').CvgVariable;
var CvgIst = require('syracuse-x3/lib/convergence/types/CvgIst').CvgIst;
var CvgResu = require('syracuse-x3/lib/convergence/types/CvgResu').CvgResu;
var CvgResuTdo = require('syracuse-x3/lib/convergence/types/CvgResu').TDO;
var CvgAction = require('syracuse-x3/lib/convergence/client/CvgAction').Actions;
var CvgSuperAction = require('syracuse-x3/lib/convergence/client/CvgAction').SuperActions;
var CvgSpecialAction = require('syracuse-x3/lib/convergence/client/CvgAction').SpecialActions;
var CvgException = require('syracuse-x3/lib/convergence/model/CvgException').CvgException;
var PrintClient = require('syracuse-x3/lib/clients/print/PrintClient');
var PrintHelpers = require('syracuse-x3/lib/clients/print/PrintHelpers');
var CvgMenuAct = require('syracuse-x3/lib/convergence/model/CvgMenuAct');
var CvgMenuCtx = require('syracuse-x3/lib/convergence/model/CvgMenuCtx');
var CvgClose = require('syracuse-x3/lib/convergence/model/CvgClose');
var CvgImp = require('syracuse-x3/lib/convergence/model/CvgImp');
var CvgServices = require('syracuse-x3/lib/convergence/client/CvgClientServices');
var CvgDiagnose = require('syracuse-x3/lib/convergence/model/CvgDiagnose');
var CvgCacheManager = require('syracuse-x3/lib/cvgCacheManager').CvgCacheManager;
var perfmon = require('syracuse-perfmon');
var CvgClientAbs = require("syracuse-x3/lib/clients/common/cvg/CvgClientAbs").CvgClientAbs;
var globals = require('streamline/lib/globals');
var Tracer = require('syracuse-collaboration/lib/entities/x3SessionConfig').Tracer;
var CvgObserver = require("syracuse-x3/lib/convergence/client/CvgObserver").CvgObserver;
var CvgPluginILog = require("syracuse-x3/lib/convergence/client/plugin/CvgPluginILog").CvgPluginILog;
var CvgPluginCR = require("syracuse-x3/lib/convergence/client/plugin/CvgPluginCR").CvgPluginCR;

var localConfig = x3helpers.config("x3fusion", null, {});

var tracerStd = require("syracuse-trace/lib/helper").getTracer("classic.std");
var tracerAction = require("syracuse-trace/lib/helper").getTracer("classic.action");
var tracerProtocol = require("syracuse-trace/lib/helper").getTracer("classic.protocol");
var tracerSession = require("syracuse-trace/lib/helper").getTracer("classic.session");

var perfConfig = localConfig.perfmon || {};
var perfmonEnabled = x3helpers.config("perfmon.activate", localConfig);
var perfmonDetail = x3helpers.config("perfmon.detail", localConfig);


var cacheMgr = new CvgCacheManager();

var AT = '@'.charCodeAt(0);

// Setting sent to client at connection
var _uiCliSettings = {
	"ADXVersion": "ADXVersion",
	"adonix.port": "ADXPort",
	"usrProfile": "usrProfile",
	"x3host": "ADXAppHost",
	"Version": "Version",
	"ADXProduct": "ADXProduct",
	"Protocol": "Protocol",
	"STime": "STime",
	"SDecimal": "SDecimal",
	"ADXLangIso": "ADXLangIso",
	"SThousand": "SThousand",
	"adonix.host": "ADXTrtHost",
	"AdxSolution": "AdxSolution",
	"ADXProductPref": "ADXProductPref",
	"ADXProductLabel": "ADXProductLabel",
	"SetMonthList": "SetMonthList",
	"formater.von": "formater.von",
	"SDate": "SDate",
	"ADXProductInfoVers": "ADXProductInfoVers",
	"ADXSupVers": "ADXSupVers",
	"mnu": "mnu",
	"DefaultDatePivot": "datePivot",
	"x3user": "user",
	"ADXTheme": "ADXTheme",
	"ADXHttpPub": "ADXHttpPub",
	"ADXNamedUser": "ADXNamedUser",
	"ADXfolder": "ADXFolder",
	"cdLang": "cdLang",
	"DefaultDateFormat": "DefaultDateFormat",
	"fmtExt": "fmtExt",
	"ADXStyleFile": "ADXStyleFile",
	"ADXNopatch": "ADXNopatch",
	"ADXRelease": "ADXRelease",
	"IDate": "IDate",
	"ADXProductSuff": "ADXProductSuff",
	"BOSEC": "BOSEC",
	"BOSERV": "BOSERV",
	"BOUSR": "BOUSR",
	"BOPWD": "BOPWD",
	"ADXMaskAppName": "ADXMaskAppName",
	"ADXHelpLocation": "ADXHelpLocation"
};

function _postDiag(client, msg, detail) {
	CvgDiagnose.create(client, 'WARNING', 99, msg, detail, null, "Protocol", null, true);
}


var CModifiableFinder = helpers.defineClass(function() {
	CvgModifier.call(this);
	this.foundModifiable = null;
}, CvgModifier, {
	setModifiable: function(ist, aModifiable) {
		this.foundModifiable = aModifiable;
		this.done = true;
		return this.done;
	}
});

var CMotherWindow = helpers.defineClass(function(aClient) {
	CvgEntity.call(this, aClient, "&ROOT", 1, 'WINDOW');
}, CvgEntity, {
	getAdxId: function() {
		return "mostherWindow - &ROOT";
	},
	toJson: function() {
		throw new Error("Bad tojson MotherWin");
	}
});

exports.CvgClient = helpers.defineClass(function() {
	CvgClientAbs.call(this);
}, CvgClientAbs, {

	init: function(_, cvgSession, stream, aConfig, recorder, context) {
		CvgClientAbs.prototype.init.call(this, stream, aConfig, recorder, context);
		var x3solution = context.endpoint.x3solution(_);
		var up = context.httpSession.getUserProfile(_);
		var appRef = up.selectedEndpoint(_).applicationRef(_);
		this.applicationName = appRef.application(_);
		this.contractName = appRef.contract(_);
		var user = "";
		if (up) {
			user = up.user(_) ? up.user(_).getEndpointLogin(_, context.endpoint.$uuid) : "";
		}


		this._cvgSession = cvgSession;

		this.response = {
			head: {
				statusCode: 200
			},
			body: {}
		};
		this.syraSessionCookie = null;
		// intregration ILOG -  SAM 91439
		this.cvgPlugin = {}; // instance of plugin interface by node (ilog, etc...)
		this.callUiOpenFile = null;
		this.printConfig = aConfig.printConfig || {};

		this._pickedLines = [];
		this._dynFormats = {};
		this._curDynFmt = null;
		this._motherWin = new CMotherWindow(this);
		this._stackedWin = new CvgStackedWindows();
		// added by BRJOU - open not called any more

		this.connecting = false;
		this.isReuse = false;
		this.reused = false; // for the settings
		this.timeToReuse = -1; // time when the client was set in reuse
		this._cvgSession = cvgSession;
		this.services = CvgServices.create(this);
		this.sessInfo = {
			nodeWS: true,
			node: {
				sid: this._cvgSession.sid,
				sessSettings: sessionManager.getSettings(_),
				x3user: user,
				x3host: this._cvgSession.client.x3server.serverHost(_),
				x3port: this._cvgSession.client.x3server.serverPort(_),
				x3name: x3solution.serverHost(_)
			},
			runtime: {
				x3user: user,
				x3host: this._cvgSession.client.x3server.serverHost(_),
				x3port: this._cvgSession.client.x3server.serverPort(_)
			}

		};
		this.boClient = new BoRestClient(_, null, null, context);
		this.orchestraTracker = null; // function to call to stop tracker. will be assign to the plugin function or client function depending of the context
		this.getUiSpecialOrders = {
			GetBoToken: "executeGetUiBO",
			GetBoHost: "executeGetUiBO",
			GetBoPort: "executeGetUiBO"
		};
		return this;
	},
	setCvgSession: function(session) {
		this._cvgSession = session;
		var si = this.sessInfo;
		if (session && si && si.node) si.node.sid = session.sid;
	},


	setInReuseMode: function(_, yes) {
		tracerSession.info && tracerSession.info("setInReuseMode + " + yes);
		if (this.boClient.token) {
			this.boClient.logoff();
		}
		if (yes) {
			this.stopRecord();
			this.isReuse = true;
			this.reused = true;
			this.timeToReuse = (new Date()).getTime();
			tracerSession.info && tracerSession.info("set timeout");
			var timeoutReuse = this.clientConfig.getParam("timeoutReuse");
			var self = this;
			tracerSession.info && tracerSession.info("timeout reuse " + timeoutReuse);
			this.reuseTimeoutId = flows.setTimeout(function(_) {
				// get current time and check timeout of reuse
				tracerSession.info && tracerSession.info("setTimeout - isReuse:" + self.isReuse + " - id:" + self.uuid);
				if (self.isReuse) { // only if it's reuse
					// reuse session need to be destroy
					if (self._cvgSession) {
						self._cvgSession.destroyReuseClient(_, self);
					}
					self.isReuse = false;
				}
			}, timeoutReuse);
		} else {
			this.isReuse = false;
			this.timeToReuse = -1;
			tracerSession.info && tracerSession.info("clear timeout");
			clearTimeout(this.reuseTimeoutId);
		}
	},
	isSameContext: function(config) {
		// check context for reuse session
		return this.clientConfig.isSameContext(config, tracerSession);
	},
	execOpenFunction: function(_, context, tracker) {
		try {
			// retrieve the current session syracuse cookie
			var secure = (context.request.hosting && context.request.hosting.https) || (context.request.connection && 'authorized' in context.request.connection);
			this.syraSessionCookie = sessionManager.secureCookie(secure, sessionManager.getSyracuseCookie(context.request.session, context.request.connection && context.request.connection.localPort));

			this.cvgPlugin = {}; // instance of plugin interface by node (ilog, etc...)

			this.currentTracker = tracker; // set current tracker
			this.orchestraStopTracker = this.stopTracker; // default one

			var ctx = context.parameters.f;
			var request = {
				act: 1077,
				fld: {
					ist: {
						win: "A",
						xid: "@@0"
					}
				},
				param: {
					target: {
						"win": "A",
						"xid": "@@0"
					},
					std: [{
						json: {
							"spgm": "GESUSER:CONNECT_FONCTION",
							"params": [{
								"dim": 1,
								"nb": 1,
								"size": ctx.length,
								"typ": "STRU",
								"resu": ctx
							}, {
								"dim": 1,
								"nb": 0,
								"size": 1,
								"typ": "STRU"
							}]
						}
					}]
				}
			};
			this.processAction(_, request, true);
			// set the head of the response
			this.response.head.location = context.baseUrl + "/$sessions('" + this._cvgSession.sid + "')";
		} finally {
			this.stopTracker && this.stopTracker(_, context, this, true); // if ochrestraTracker is empty we stop the tracker of the client
		}

	},
	connectStart: function(_, context, tracker) {
		var excep;
		try {
			var timing = perfmonEnabled && perfmon.start(module, 'cvgClient.connectStart');
			var startConnect = new Date().getTime();

			// retrieve the current syracuse session cookie
			var secure = (context.request.hosting && context.request.hosting.https) || (context.request.connection && 'authorized' in context.request.connection);
			this.syraSessionCookie = sessionManager.secureCookie(secure, sessionManager.getSyracuseCookie(context.request.session, context.request.connection && context.request.connection.localPort));

			this.cvgPlugin = {}; // instance of plugin interface by node (ilog, etc...)

			this.currentTracker = tracker; // set current tracker
			this.orchestraStopTracker = this.stopTracker; // default one

			CvgClientAbs.prototype.connectStart.call(this, _, context, tracker);

			this.response.head = {
				location: context.baseUrl + "/$sessions('" + this._cvgSession.sid + "')",
				"syra-proxy-time": new Date().getTime() - startConnect
			};

		} catch (e) {
			excep = e;
			//console.log(e.stack);
			throw e;
		} finally {
			if (!excep) { // exception is catch and the tracker is stop in CvgSession
				this.stopTracker && this.stopTracker(_, context, this, true); // if ochrestraTracker is empty we stop the tracker of the client
				tracerAction.info && tracerAction.info("End Connect Start:\n" + JSON.stringify(this.response, null, 2));
			} else {
				tracerAction.info && tracerAction.info("End Connect Start");
			}
			tracerAction.info && tracerAction.info("************************************");

		}
	},
	processSuperAction: function(_, body) {
		var self = this;
		tracerAction.info && tracerAction.info("===================================");
		tracerAction.info && tracerAction.info("Process Super Action:\n" + JSON.stringify(body, null, 2));

		//console.error("SuperAction ID: " + body.act);
		var offset = 768,
			superAction = body.act - offset > 0 ? CvgSuperAction[body.act - offset] : null;
		if (!superAction) {
			throw new Error("Bad super action [" + body.act + "]");
		}
		//console.error("SUPER ACTION: "+JSON.stringify(superAction,null,2));
		if (this.recorder) {
			this.recorder.dumpAction(_, body.act, true);
		}
		var i1, std = [];
		if (body.param && body.param.sudo) {
			for (i1 in body.param.sudo) {
				std.push(body.param.sudo[i1]);
			}
			delete body.param.sudo;
		}
		var resp = {},
			nextFld;
		var i, newBody, action, j, processNext, t0, t1, target, respTarget, stop = false;
		for (i = 0; i < superAction.actions.length && !stop; i++) {
			newBody = JSON.parse(JSON.stringify(body));
			action = superAction.actions[i];
			j = i;
			do {
				//console.error("Process Action: "+JSON.stringify(action,null,2));
				if (!CvgAction[action.name]) {
					throw new Error("Bad sub-action: " + action.name);
				}
				processNext = true;
				newBody.act = CvgAction[action.name];
				if (nextFld) {
					newBody.fld.ist = nextFld.ist;
					newBody.fld.v = nextFld.v;
				}
				if (!action.setTarget) {
					tracerAction.info && tracerAction.info("DELETE TARGET !!!");
					delete newBody.param.target;
				}
				if (std[j]) {
					newBody.param.std = std[j];
					// Use other action sudo params (action number is added to params)
					if (action.propagate) {
						newBody.param.std.push(CvgAction[action.propagate]);
					}
				}
				this.processAction(_, newBody, false, j !== 0);
				target = this.getTarget();
				t1 = target && target.type === 'ist' && target.ist;
				if (!t1) {
					stop = true;
				}
				if (action.setTarget) {
					t0 = newBody.param && newBody.param.target;
					processNext = superAction.processNextAction(CvgAction[action.name], t0, t1, action.checkNumLine, self);
				}
				//console.error("Process Next: "+processNext + " action.setTarget: "+action.setTarget);
				if (processNext) {
					respTarget = target.ist;
					if (respTarget) {
						nextFld = {
							ist: {
								xid: respTarget.xid,
								win: respTarget.win
							},
							v: respTarget.v
						};
						if (respTarget.nl) {
							nextFld.ist.nl = respTarget.nl;
						}
					}
				} else {
					stop = true;
					break;
				}
				j++;
			} while (j < std.length && action.isLoop);
		}
		return resp;
	},
	razModification: function() {
		CvgClientAbs.prototype.razModification.call(this);
		this._stackedWin && this._stackedWin.razModifications();
	},
	processSpecialAction: function(_, body, context, bodyStr, tracker) {
		tracerAction.info && tracerAction.info("===================================");
		tracerAction.info && tracerAction.info("Process Special Action:\n" + JSON.stringify(body, null, 2));

		// raz modification
		this.razModification();
		var specialAction = CvgSpecialAction[body.act];
		if (!specialAction) {
			throw new Error("Bad special action [" + body.act + "]");
		}

		if (specialAction.proxy === "srvImp") {
			var printerName, srvImp, printClient = null;
			srvImp = this.activeRequest.srvImp;
			// Create fresh request/reply objects
			var reply = new CvgReply(this, body.act);
			var target = body.param && body.param.target;
			if (target && target.xid != null) {
				this.ctxNDSLB = CvgIst.fromTarget(target);
			}
			this.newActiveRequest(reply, {
				"ctxNDSLB": this.ctxNDSLB,
				"reqNum": body.tech && body.tech.id ? body.tech.id : 0,
				"target": body.param && body.param.target,
				"connect": false
			}, false);
			if (srvImp) {
				this.activeRequest.srvImp = srvImp;
			}

			switch (specialAction.id) {
				case "PRINTER_SEL_OPTS":
					printerName = body.param && body.param.selpr && body.param.selpr.printerName;
					if (!printerName) {
						throw new CvgException(this, null, "printerName is required.", null, "srvImpSvc");
					}
					try {
						printClient = PrintClient.getClient(_, srvImp.hostname, srvImp.port, srvImp.id);
						var infos = printClient.getAdvancedParameters(_, printerName, body.param.selpr.port, body.param.selpr.driver);
						CvgImp.more(this, infos);
					} catch (e) {
						if (printClient) {
							printClient.panicRelease();
							printClient = null;
						}
						var diag = new CvgDiagnose(this, 'INFO', 99, locale.format(module, "GET_PRINTER_OPT_1"), '"' + srvImp.hostname + ":" + srvImp.port + '" : ' + (e.message || ""), e, "Protocol [processSpecialActionPRINTER_SEL_OPTS]", null, false);
						CvgImp.more(this, null, diag);
					}
					break;

				case "PRINTER_SEL_CANCEL":
					// Send empty properties to back office
					delete this.activeRequest.workingCtx.pendingBlockingNode;
					x3writer.props1Serializer.write(_, this, {});
					automata.process(_, this, this.activeRequest, {
						title: "special",
						detail: "PRINTER_SEL_CANCEL"
					});
					break;

				case "PRINTER_SEL_OK":
					var selected = body.param && body.param.selpr && body.param.selpr.selected;
					delete this.activeRequest.workingCtx.pendingBlockingNode;
					printerName = selected.name;
					if (!printerName) {
						// Send empty properties to back office
						delete this.activeRequest.workingCtx.pendingBlockingNode;
						x3writer.props1Serializer.write(_, this, {});
						automata.process(_, this, this.activeRequest, {
							title: "special",
							detail: "PRINTER_SEL_OK_1"
						});
						break;
					}
					var props = {},
						paperProps, devmode = {};
					if (selected.driver) {
						props._PrinterDriver = selected.driver;
					}
					if (selected.name) {
						props._PrinterName = selected.name;
					}
					if (selected.port) {
						props._PrinterPort = selected.port;
					}
					if (srvImp) {
						props._PrinterServer = srvImp.hostname + ":" + srvImp.port;
					}
					props._PrinterCopies = selected.copies || 1;
					if (selected.collate !== null && selected.collate !== undefined) {
						props._PrinterCollate = selected.collate;
					}
					if (selected.startPage) {
						props._PrinterStartPage = selected.startPage;
					}
					if (selected.stopPage) {
						props._PrinterStopPage = selected.stopPage;
					}
					if (selected.orientation !== null && selected.orientation !== undefined) {
						props._Orientation = selected.orientation;
					}
					devmode.duplex = selected.duplex && typeof selected.duplex === "string" ? parseInt(selected.duplex, 10) : selected.duplex;
					// Check paper size/source
					if (printerName && (selected.paperSize || selected.paperSource)) {
						try {
							printClient = PrintClient.getClient(_, srvImp.hostname, srvImp.port, srvImp.id);
						} catch (e) {
							if (printClient) {
								printClient.panicRelease();
								printClient = null;
							}
						}
						if (printClient) {
							//console.log("\t Papers props IN for " + printerName + " : size=" + selected.paperSize + " source=" + selected.paperSource);
							paperProps = printClient.checkPrinterPaper(_, printerName, selected.port, selected.driver, selected.paperSize || null, selected.paperSource || null);
							if (paperProps) {
								//console.log("\t Papers props OUT" + JSON.stringify(paperProps,null, 2));
								devmode.paperSize = paperProps.paperSize;
								devmode.paperSource = paperProps.paperSource;
							}
						}
					}
					PrintHelpers.setDevmodeInSrvProperties(devmode, props);
					//console.log("NDGTIM Properties OUT: " + JSON.stringify(props, null, 2));
					x3writer.props1Serializer.write(_, this, props);
					automata.process(_, this, this.activeRequest, {
						title: "special",
						detail: "PRINTER_SEL_OK_2"
					});
					break;

				case "PRINTER_OPTS_CANCEL":
				case "PRINTER_OPTS_OK":
					CvgImp.config(this, null);
					break;

				default:
					throw new Error("Unknow SrvImp action [" + specialAction.id + "]");
			}

			//return this.getResponse(_);
		} else if (specialAction.proxy === "plugin") {
			if (!specialAction.handler) {
				switch (specialAction.id) {
					case "ILOG_CLIENT_DELETE":
						// call method that construct the property as expected by the runtime with the input
						this._clientILogDeletePlugin(body);
						this.orchestraTracker = this;
						automata.process(_, this, this.activeRequest, {
							title: "special",
							detail: "ILOG_CLIENT_DELETE"
						});
						break;

					default:
						throw new Error("special Action not supported and not properly defined " + specialAction.id);
				}
			} else {
				var plug = this.cvgPlugin[specialAction.handler + "-default"];
				if (plug) {

					var id = body && body.param && body.param.plugin && body.param.plugin.id || specialAction.handler + "-default";
					this.cvgPlugin[specialAction.handler + "-" + id] = plug;
					plug.processRequest(_, context, bodyStr, tracker);
				} else {
					throw new Error("plugin for feature " + specialAction.handler + " not found");
				}
			}
		} else {

			throw new Error("Bad proxy [" + specialAction.proxy + "] for special action [" + body.act + "]");
		}
	},
	_clientReplyPlugin: function(_, defaultId, body) {
		var id = body && body.param && body.param.plugin && body.param.plugin.id || defaultId;
		if (!this.cvgPlugin["ilog-" + id]) { //first  client request must associate with id of plugin if it's not the case
			this.cvgPlugin["ilog-" + id] = this.cvgPlugin["ilog-default"];
		}
		if (this.cvgPlugin["ilog-" + id]) {
			if (this.id !== "default") {
				this.cvgPlugin["ilog-" + id].id = id;
			}
			this.cvgPlugin["ilog-" + id].clientReplyPlugin(_, body);
		}
	},
	_clientILogDeletePlugin: function(body) {
		// get id of the plugin
		var handler = "ilog";
		if (this.cvgPlugin[handler + "-default"]) {
			var id = this.cvgPlugin[handler + "-default"].id;
			delete this.cvgPlugin[handler + "-default"];
			if (this.cvgPlugin[handler + "-" + id])
				delete this.cvgPlugin[handler + "-" + id];
		}
	},

	clientCrDeletePlugin: function() {
		// get id of the plugin
		var handler = "CR";
		if (this.cvgPlugin[handler + "-default"]) {
			var id = this.cvgPlugin[handler + "-default"].id;
			delete this.cvgPlugin[handler + "-default"];
			if (this.cvgPlugin[handler + "-" + id])
				delete this.cvgPlugin[handler + "-" + id];
		}
	},
	generateBusyResponse: function(_) {
		// TODO create a diagnosis or a info box ... need to see with claude Michel
	},
	processRequest: function(_, context, bodyStr, tracker) {
		tracerAction.info && tracerAction.info("************************************");
		tracerAction.info && tracerAction.info("Begin Process Request");
		if (context.parameters && context.parameters.timing) {
			this.traceTiming = true;
			this.perfTimer = perfmon.start(module, 'cvgRequest');
		} else {
			this.traceTiming = false;
		}

		var excep;
		try {
			this.currentTracker = tracker; // set current tracker. it will be stop on each ending node process method
			this.orchestraTracker = this;
			if (context.method !== 'put') {
				throw new Error("bad method: " + context.method);
			}
			var act = parseInt(context.parameters.act, 10);
			// We need to store string to pass to recorder
			var httptiming = perfmonEnabled && perfmon.start(module, 'cvgClient.processRequest');
			bodyStr = bodyStr != null ? bodyStr : context.request.readAll(_);

			var body = JSON.parse(bodyStr);
			//check if an action is in progress and refuse the action by sending a busy message because it's mandatory
			if (this.isProcessingRequest) { // process already oin progrss
				this.logSession(_, "INFO", "a request is already processing");
				CvgDiagnose.create(this, null, 409, "a request is already processing", null, null, "syracuse server", "BUSY", true, null);

			} else {
				if (body.settings && body.settings.syraTrace) {
					this.srvTrace = body.settings.syraTrace;
				}
				if (parseInt(body.act, 10) !== act) {
					throw new Error("body act mismatch: expected " + act + ", got " + body.act);
				}
				if (act >= 1024) {
					this.processAction(_, body);
				} else if (act >= 768) {
					this.processSuperAction(_, body);
				} else {
					this.processSpecialAction(_, body, context, bodyStr, tracker);
				}
			}

			if (perfmonEnabled) {
				this.recordTiming(httptiming, act, "processRequest", {
					size: bodyStr != null && bodyStr.length
				});
			}
		} catch (e) {
			excep = e;
			//console.log(e.stack);
			throw e;
		} finally {
			if (!excep) { // exception is catch and the tracker is stop in CvgSession
				this.stopTracker && this.stopTracker(_, context, this.orchestraTracker); // if ochrestraTracker is empty we stop the tracker of the client
				tracerAction.info && tracerAction.info("End Process Request:\n" + JSON.stringify(this.response, null, 2));
			} else {
				tracerAction.info && tracerAction.info("End Process Request");
			}
			tracerAction.info && tracerAction.info("************************************");
		}
	},
	winDescrUrl: function(winId) {
		var lang = this._x3SessionSettings.cdLang || "";
		var langKnown = {
			"de-DE": "GER",
			"en-GB": "BRI",
			"en-US": "ENG",
			"es-ES": "SPA",
			"fr-FR": "FRA",
			"it-IT": "ITA",
			"pl-PL": "POL",
			"pt-PT": "POR",
			"ru-RU": "RUS"
		};
		if (lang.trim().length === 0) {
			lang = langKnown[this.clientConfig.getParam("x3Lang")];
			if (lang != null) {
				this._x3SessionSettings.cdLang = lang;
				_postDiag(this, this.getMessage('WARNING_CANT_GET_CDLANG_MSG'), this.getMessage('WARNING_CANT_GET_CDLANG_DETAIL', lang));
			} else {
				throw new Error(this.getMessage('WARNING_CANT_GET_CDLANG_ERROR', winId, this.clientConfig.getParam("x3Lang"), this.clientConfig.getParam('x3Folder')));
			}
		}
		var x3HttpPub = this.clientConfig.getParam("x3HttpPub");
		var x3Folder = this.clientConfig.getParam("x3Folder");
		return x3HttpPub + "/" + x3Folder + "/GEN/" + lang + "/FENS/" + winId + ".xml";
	},
	loadWindowDescription: function(_, ist, winId, funcId, stamp) {
		var timing = perfmonEnabled && perfmon.start(module, 'cvgClient.loadWindowDescription', funcId);
		var self = this,
			descr;

		if (this.clientConfig.modePLAY) {
			// stream fakes data access to X3 and other resources used by cvgClient
			descr = this.stream.readDescr(_);
		} else {
			var url;
			try {

				var file, jsonDescr;
				var filePath = __dirname + this.cvgWinStubPath + winId + ".xml";
				if (fs.exists(filePath, _)) {
					file = fs.readFile(filePath, "utf8", _);
				}

				if (!file) {
					url = this.winDescrUrl(winId);
					jsonDescr = cacheMgr.getResource(_, url, null, {
						ignoreProxy: !this.clientConfig._params.useProxy
					});
				} else {
					jsonDescr = file;
				}
				descr = jsxml.parse(jsonDescr).WIND;
			} catch (e) {
				throw new CvgException(self, e, locale.format(module, "ERROR_WINMANAGER_LOADING", winId), "KILL", "", (e.message && url ? e.message + " : " + url : (url || null)));
			}
			if (this.recorder) {
				// We need to store description to be able to replay
				this.recorder.dumpWinDescr(_, descr);
			}
		}
		if (perfmonEnabled) {
			timing.end();
		}

		var win = this.pushRequesterWindow(winId, funcId, descr, stamp, ist.win);
		if (win.id === "_FORMULA") {
			// get default element in
			this.getFormulaItem(_, win, "x3Uoperators", 'B');
			this.getFormulaItem(_, win, "x3Ufunctions", 'C');
		}
		return win;
	},
	getFormulaItem: function(_, win, file, target) {
		var lang = this._x3SessionSettings.cdLang || "";
		if (lang.trim().length === 0) {
			throw new Error('Open window[' + win + '] failed.\nX3 language code (cdLang) has not been received from X3 server\nPlease check X3 folder[' + this.clientConfig.getParam('x3Folder') + '] configuration');
		}
		var x3HttpPub = this.clientConfig.getParam("x3HttpPub");
		var url = x3HttpPub + "/X3_ROOT/GEN/" + lang + "/LIB/" + file + ".xml";
		var opt = {
			method: "GET",
			url: url,
			headers: {},
			ignoreProxy: !this.clientConfig._params.useProxy
		};

		var request = httpClient.httpRequest(_, opt);
		var response = request.end().response(_);
		response.setEncoding('utf8');
		//console.log("statusCode=" + response.statusCode);
		var body = response.readAll(_);
		if (response.statusCode === 200 && body) {
			var i, col3, item, items = jsxml.parse(body);
			for (i = 0; i < items.Main.LINE.length; i++) {
				item = items.Main.LINE[i];
				col3 = (target === "B" ? 2 : item.COL[3].$cdata);
				this.activeRequest.listenNodeNDOFLD(_, null, null, win.getAdxIst(), item.COL[0].$cdata, item.COL[1].$cdata, item.COL[2].$cdata, col3, item.COL[4].$cdata, item.COL[5].$cdata, target);
			}
		}
	},

	getMessage: function(messageKey) {
		var i, args = [module, messageKey];
		for (i = 1; i < arguments.length; i++) {
			args.push(arguments[i] ? arguments[i].toString() : arguments[i]);
		}
		var res = locale.format.apply(null, args);
		return res;
	},

	containsAdxPubSubFile: function(aListOfProperties) {
		var wProperty;
		var wMax = aListOfProperties.length;
		var wI = 3; // pour demarer a la 4eme propriete !
		while (wI < wMax) {
			wProperty = aListOfProperties.get(wI);
			if (wProperty.hasId() && wProperty.id.toUpperCase() === "UIAdxPubSubFile".toUpperCase()) {
				return true;
			}
			wI++;
		}
		return false;
	},

	closeClient: function(_, e, reason) {
		CvgClientAbs.prototype.closeClient.call(this, _, e, reason);
		if (this.boClient.token) { // logoff on close if necessary
			this.boClient.logoff(_);
		}
		if (this.boClient.token) {
			this.boClient.logoff(_);
		}
	},
	executeCallUiOpenFile: function(values) {
		var idx, appSrvShared = null,
			srvPubType, url;
		var options = {};
		var localDir = values.UILocalDir;
		var localFile = values.UILocalFile;
		if (localFile && ["HTTP", "HTTPS", "APP"].indexOf(localDir) >= 0) {
			if (localDir !== "APP") {
				localFile = localFile.replace("\\", "/");
			}
			srvPubType = values.UIAdxPubSubFile;
			if (srvPubType !== undefined) {
				srvPubType = parseInt(srvPubType, 10);
				if (srvPubType == 1) {
					idx = localFile.substring("/");
					url = localFile.substring(idx);
				} else if (srvPubType == 2) {
					appSrvShared = true;
				} else if (srvPubType == 3) {
					appSrvShared = false;
				}
			}
			if (values.UIWindowFeatures) {
				options.windowFeatures = values.UIWindowFeatures;
			}
			if (values.UIWindowTimeOut) {
				options.windowTimeOut = values.UIWindowTimeOut;
			}
			if (this.callUiOpenFile) {
				this.callUiOpenFile.addOpenFile(localDir.toLowerCase(), url || localFile, appSrvShared, options);
			} else {
				this.callUiOpenFile = new CvgCallUiOpenFile(this, localDir.toLowerCase(), url || localFile, appSrvShared, options);
			}
		}
		return {};
	},
	executeCallUiReportDev: function(_, values) {
		var plug = this.cvgPlugin["CR-default"] = this.newCrPlugin();
		plug.addBlindProperties(_, values);
		this.stopTracker && this.stopTracker(_, this.context, this); // if ochrestraTracker is empty we stop the tracker of the plugin

	},
	executeCallUiGetFile: function(_, isAlways, values) {
		// check if we are in ilog case else do nothin
		if (values && values.UIDownLoad === "ILOG") {
			// create ilog if it's not the case
			var plug = this.getILogPlugin();
			// add download
			plug.addDownload(values);
		}
	},
	newILogPlugin: function() {
		// check if we already have a plugin instance for an download or upload and associate that one
		var plug = this.cvgPlugin["ilog-default"] = new CvgPluginILog(this, "default", this.killPluginTimoeut || 20000);
		return plug;
	},
	newCrPlugin: function() {
		// check if we already have a plugin instance for an download or addUpload and associate that one
		var plug = this.cvgPlugin["CR-default"] = new CvgPluginCR(this, "default");
		return plug;
	},
	getILogPlugin: function(id) {
		this.cvgPlugin = this.cvgPlugin || {};
		var plug;
		var idPlugin = "default";
		if (id && id !== "") {
			idPlugin = id;
		}
		if (!this.cvgPlugin["ilog-default"]) { //
			plug = this.newILogPlugin(); // default 120s if it's not defined
		}
		if (!this.cvgPlugin["ilog-" + idPlugin]) { // if idPlugin != ilog and not exists -> associate current ilog plugin with this id
			plug = this.cvgPlugin["ilog-" + idPlugin] = this.cvgPlugin["ilog-default"];
		} else {
			plug = this.cvgPlugin["ilog-" + idPlugin];
		}
		if (id) {
			plug.id = idPlugin;
		}

		return plug;
	},
	execCallUi: function(_, values) {
		var props = null;
		var autoReply = true;
		var res = CvgClientAbs.prototype.execCallUi.call(this, _, values);
		if (res)
			return res;
		switch (values.UIAction) {
			case "Sethangup":
				props = this.executeCallUiSetHangHup(values);
				break;
			case "OpenFile":
				props = this.executeCallUiOpenFile(values);
				break;

				// The following values not used
			case "GetFileAlways":
			case "GetFile":
				props = this.executeCallUiGetFile(_, false, values);
				break;

			case "ReportDev":
				autoReply = false;
				props = this.executeCallUiReportDev(_, values);
				break;

				//case "PutFileAlways":
				//return this.executeCallUiPutFile(true, values);
				//case "PutFile":
				//return this.executeCallUiPutFile(false, values);
		}

		return {
			reply: autoReply,
			pValues: props
		};
	},

	executeCallUiSetTechnovers: function(values) {
		// TODO manage protocol negociation
		this.executeAllSessionSettings(values);
		return values;
	},
	executeCallUiSetHangHup: function(values) {
		return {
			Sethangup: 1
		};
	},

	executeGetUiBO: function(_, key) {
		var result = {};
		if (key === "GetBoToken") {
			result[key] = this.boClient.token || this.boClient.logon(_, true);
		} else if (key === "GetBoHost") {
			this.boClient.init(_);
			result[key] = this.boClient.bohost;
		} else if (key === "GetBoPort") {
			this.boClient.init(_);
			result[key] = this.boClient.boport;
		}
		return result;
	},
	findModifiable: function(ist) {
		var timing = perfmonEnabled && perfmon.start(module, "CvgClient.findModifiable");
		var finder = new CModifiableFinder();
		this.traverseSettable(ist, finder);
		if (perfmonEnabled) {
			timing.end();
		}
		return finder.foundModifiable;
	},

	processND_GFD: function(_, reader, node, properties) {
		// console.log("ND_GFD properties: "+JSON.stringify(properties,null,2));
		var key = properties[0];
		var result;
		if (this.getUiSpecialOrders[key]) {
			result = this[this.getUiSpecialOrders[key]](_, key);
		}
		if (!result) {
			result = CvgClientAbs.prototype.processND_GFD.call(this, _, reader, node, properties);
		}
		return result;
	},

	/**
	 * NDACTOBJ (Adxcpl_displayWin) Affichage d'une fenetre Id=[NDACTOBJ]
	 * x3func=[Adxcpl_displayWin] NbArgs=[2] - ist =[ win=[2] srn=[0] blc=[0]
	 * fld=[0] idx=[0]] - opt=[.x04]
	 */
	listenNodeNDACTOBJ: function(_, reader, node, ist, num) {
		var WIN_NOHIDDEN = 4;
		if (num > WIN_NOHIDDEN) {
			var win = this.findModifiable(ist);
			if (win != null && win instanceof CvgStackedWindow) {
				win.setScreenToShow(num - WIN_NOHIDDEN + 1);
			}
		} else {
			// TODO
		}
	},

	/**
	 * NDACTOP 0E4000 (Activation_Action) Activation d=[NDACTOP] level=[?]
	 * x3func=[Activation_Action] nb=[2] - ide=[2823] ID Action - typ=[.x01]
	 * Status
	 */
	listenNodeNDACTOP: function(_, reader, node, actId, flag) {
		CvgMenuAct.create(this, actId, flag);
	},

	/**
	 * Le serveur envoi 3 noeuds ndctsu pour decrire un format dynamique. voir
	 * l'innerclasse "CDynFormat" Id=[NDCTSU] level=[C]
	 * x3func=[Control_DefineType] NbArgs=[3] - opt=[.x65] - su1 =[c] - su2 =[_]
	 */
	listenNodeNDCTSU: function(_, reader, node, type, subType, compl) {
		/*
		 * Traite le premier noeud NDCTSU contenant le type. Exemple: Type=[g]
		 * SubType=[] Complement=[] Le noeud correspondant: Id=[NDCTSU]
		 * func=[Control_DefineType] NbArgs=[3] opt=[.x67] su1 =[] su2 =[])
		 */
		type = String.fromCharCode(type);
		if (this._curDynFmt == null) {
			this._dynFormats[type] = this._curDynFmt = {};
		}
		/*
		 * Traite le deuxieme noeud NDCTSU contenant le SubType. Exemple:
		 * Type=[g] SubType=[AX] Complement=[] Le noeud correspondant:
		 * Id=[NDCTSU] func=[Control_DefineType] NbArgs=[3] opt=[.x67] su1 =[AX]
		 * su2 =[]
		 */
		else if (this._curDynFmt.subType == null) {
			this._curDynFmt.subType = subType;
		}
		/*
		 * Traite le troisieme noeud NDCTSU contenant le complement (ou non).
		 * Exemple: Type=[g] SubType=[AX] Complement=[] Le noeud correspondant:
		 * Id=[NDCTSU] func=[Control_DefineType] NbArgs=[3] opt=[.x67] su1 =[AX]
		 * su2 =[]
		 */
		else {
			/*
			 * mis en place du complement, creation du format dynamique dans le
			 * formater, et destroy du format dynamique
			 */
			this._curDynFmt.complement = compl;
			this._curDynFmt = null;
		}
	},

	/**
	 * NDOMNCO 0E015E (MenuDyn_New) Id=[NDOMNCO] level=[R] x3func=[MenuDyn_New]
	 * NbArgs=[5] - flg=[.x58] - cod=[1026] - txt=[Selection] - acc=[0] - hlp
	 * =[] parametre passes a la fonction "MenuDyn_New" du client X3 :
	 *
	 * (*fnd)( (flg&0x40)>>6, fen, (flg&0x08)>>3, cod, txt, acc, (flg&0x7), 0,
	 * (flg&0x10)>>4, (flg&0x20)>>5, hlp ) ;
	 *
	 * bFirst Premiere option (vide la liste) ((wByte & 0x40) >> 6) nRang Rang
	 * d'insertion de l'option (0 pas d'option) nType Type de l'option (flg &
	 * 0x08) >>3) nAction Action a renvoyee au serveur pszText texte de l'option
	 * nAccel Accelerateur nCateg Categorie dans le type (flg&0x7) nImage Numero
	 * de l'image bValide Valide ou bien (flg&0x10)>>4 bSelect Selectionne ou
	 * bien (flg&0x20)>>5 pszhelp texte d'aide rapide
	 */
	listenNodeNDOMNCO: function(_, reader, node, flag, actId, txt) {
		var type = (flag & 0x08) >> 3 === 0;
		if (!type && actId > 0) {
			// FDB/CMI - We skip clearMenuList instruction
			// Normally we should send clearMenuList:true/false to client to let it clear menu list
			// but clearMenuList=true is always received before receiveing a new nenu list and client clear the old one by default
			// var clearMenuList = (flag & 0x40) !== 0;
			CvgMenuCtx.create(this, actId, true, txt);
		}
	},

	/**
	 * Changement element dans barre de statut Id=[NDOTXSC] level=[W]
	 * x3func=[Status_ChangeStatus] NbArgs=[6] - ist =[ win=[2] srn=[0] blc=[0]
	 * fld=[0] idx=[0]] - st[0]=[.x00] (byte) - st[1]=[132] (int) - buf[0] =[]
	 * (stru) - buf[1] =[] (stru) - st[2]=[3058] (int)
	 */
	listenNodeNDOTXSC: function(_, reader, node, ist, numTxt, imgId, txt, dummyTxt, actId) {
		var i, item, winFound = null;
		for (i = 0; i < this._stackedWin.length && winFound == null; i++) {
			item = this._stackedWin[i];
			if (item && item.getAdxIst().winAlphaId === ist.winAlphaId) {
				winFound = item;
			}
		}
		if (winFound != null) {
			winFound.addStatusIconDef(ist, numTxt, txt, imgId, actId);
		}
	},

	/**
	 * Id=[NDPKAR] func=[LeftList_Picking] NbArgs=[1] - ist =[ win=[2] srn=[34]
	 * blc=[3] fld=[0] idx=[0]]
	 */
	sendNotify: function(ist, level, message) {
		var i, item, winFound = null;
		if (ist == null) {
			winFound = this._stackedWin[0];
		}
		for (i = 0; i < this._stackedWin.length && winFound == null; i++) {
			item = this._stackedWin[i];
			if (item && item.getAdxIst().winAlphaId === ist.winAlphaId) {
				winFound = item;
			}
		}
		if (winFound) {
			winFound.addStatusIconDef(this, 100 + level, message, 0, 0);
		}

	},
	pickingAddLine: function(aPickedLine) {
		this._pickedLines.push(aPickedLine);
	},
	listenNodeNDPKAR: function(_, reader, node) {
		var actArgs;
		if (this._pickedLines.length > 0) {
			var pickedLine = this._pickedLines.splice(0, 1)[0];
			actArgs = [pickedLine.action];
			var ist = pickedLine.ist;
			var keyP = pickedLine.key;
			var leftList = pickedLine.leftList;
			if (keyP != null) {
				// suppression du numero de ligne dans l'adxid de la lisgne pickee ajout de l'argument tdans la liste
				ist.idx = 0;
				actArgs.push(ist);
				// ajout de l'argument tableau de resu qu'est la cle de la ligne  pickee

				if (typeof keyP === "string") {
					var key = [keyP];
					if (keyP.indexOf('^') !== -1) {
						key = keyP.split('^');
					}
					var i, t, resu, resus = [];
					for (i = 0; i < key.length; i++) {
						t = key[i].split("~");
						resu = new CvgResu.fromAction(parseInt(t[0], 10), t.slice(1).join("~"));
						resus.push(resu);
					}

					actArgs.push(resus);
					// var line = leftList.findLine(resus);
					leftList.setServerSelectLine(pickedLine.isSelection(), resus);
				}
			} else {
				actArgs.push(ist.toString());
				_postDiag(this, this.getMessage('ERROR_CANT_GET_PICKED_LINE_KEY', 'NDPKAR - ' + ist.toString()));
			}
		} else {
			actArgs = [CvgAction.SRV_ABANDON];
		}
		// BRJOU: did not see any resu, pass null
		x3writer.sendAction(_, this, new CvgResu(CvgResuTdo.NULL, null), [], actArgs);
	},

	newRequest: function(reply, sendContext) {
		return new CvgRequest(this, reply, sendContext);

	},
	popRequesterWindow: function(winIst) {
		var win = this._stackedWin.popStackedWindow(winIst);
		win.setOpened(false);
		win.jsonType = "FUNCC";
		this.track(win);
		// clean map if there only mother windows

		return win;
	},
	pushRequesterWindow: function(winId, funcId, descr, stamp, winIdx) {
		var win = new CvgStackedWindow(this, winId, funcId, descr, stamp, winIdx);
		this._stackedWin.pushStackedWindow(win, winIdx);
		win.setStackLevel(this._stackedWin.length);
		win.setOpened(true);
		win.jsonType = "FUNCO";
		this.track(win);
		return win;
	},
	getEntityIstResu: function(ist, body) {
		var resu = null;
		var entity = this.findModifiable(ist);
		var self = this;
		//console.log("ACTION ENTITY=" + util.inspect(entity));
		if (entity && entity instanceof CvgVariable) {
			if (entity.dataType == null) {
				throw new Error("data type not found: " + JSON.stringify(body));
			}
			var value = body.fld.v;
			try {
				if (value !== undefined) {
					// value is a raw value
					if (entity.dataType === CvgResuTdo.BLOB) { // blob case the value is not send by the client but is store in blobSvc
						value = (this.services.blobSvc.getBlob(value) ? this.services.blobSvc.getBlob(value).binary : "");
					}
					// != null is appropriate to test not null and not undefined
					if (value != null) {
						resu = CvgResu.fromAction(entity.dataType, value);
						entity.setBrowserUnformattedValue(resu);
					}
				}
			} catch (e) {
				console.error("processAction ERROR");
				console.error(e.stack);
				var instance = CvgInstance.newtarget(this, ist, entity.format.format, body.fld.v, this.activeRequest.reply ? this.activeRequest.reply.stayInCommandMode : false);
				instance.exception = e;
			}
		}
		return resu;
	},

	traverseSettable: function(ist, aModifier) {

		/*var mod = this.mapIst[ist];
		if (mod) {
			return aModifier.setModifiable(ist, mod);
			// optimisation for cvgEntity (especially for array (INSLI,NDCHVL...etc)
		} else*/
		if (ist.isWindowIst() && ist.winZeroBase === -1) {
			return aModifier.setModifiable(ist, this._motherWin);
		}

		return this._stackedWin.traverseSettable(ist, aModifier);
	},

	_buildUiClientSettings: function() {
		var i, res = {};
		for (i in _uiCliSettings) {
			if (this._sessionSettings[i]) {
				res[_uiCliSettings[i]] = this._sessionSettings[i];
			} else if (this._x3SessionSettings[i]) {
				res[_uiCliSettings[i]] = this._x3SessionSettings[i];
			}
		}
		// Add formater settings for client formater
		this.clientConfig.addUiCliSettings(res);
		return res;
	},

	// somme value in the timing
	_calculTiming: function(timing, key) {
		var self = this;
		var timingk = key ? timing[key] : timing;
		if (Array.isArray(timingk)) {
			// calcul sum
			var total = 0;
			timingk.forEach(function(item) {
				if (item.duration) {
					total += item.duration;
				}
			});
			if (!perfmonDetail && timing[key]) {
				delete timing[key];
			}
			timing['cvgTotal_' + key] = {
				totalDuration: total
			};
		} else if (typeof timingk === "object" && Object.keys(timingk).length >= 1) {
			Object.keys(timingk).forEach(function(id) {
				self._calculTiming(timingk, id);
			});
		}
	},

	getTarget: function() {
		var lists = this._trackLists;
		return JSON.parse(JSON.stringify(lists.TARGET[lists.TARGET.length - 1]));
	},

	getTrackList: function() {
		return this._trackLists;
	},
	generateResponse: function(_, connect, isTrack) {
		var timing = perfmonEnabled && perfmon.start(module, "cvgClient.generateResponse");
		this.isProcessingRequest = false; // request is in finish we generate response

		var lists = this._trackLists;

		function isDefined(o) {
			return o !== undefined;
		};

		var wins = {},
			win, key, i, entity, winNode, gridParent, line, jsonKey, jsonEntity;
		var topic = lists.ENTITY;
		for (i = 0; i < topic.length; i++) {
			entity = topic[i];
			if (entity === undefined || entity instanceof CvgStackedWindow) {
				continue;
			}
			// first condition has already been handled: win = entity instanceof CvgStackedWindow ? entity : (entity instanceof CvgStatusBar ? entity.stackedWindow : this._stackedWin.findWin(entity.getFatherWindowId().charCodeAt(0) - '@'.charCodeAt(0)));
			win = (entity instanceof CvgStatusBar ? entity.stackedWindow : this._stackedWin.findWin(entity.getFatherWindowId().charCodeAt(0) - AT));
			if (win) {
				winNode = wins[win.entityIdxAlpha];
				if (!winNode) {
					/* not necessary any more to check wins[win.entityIdxAlpha] again: winNode = wins[win.entityIdxAlpha] || {
						entities: {}
					}; */
					wins[win.entityIdxAlpha] = winNode = {
						entities: {}
					};
					if (win.statusBarChange) {
						winNode.statBar = win.statusBar.toJSON();
					}
					if (win.hasModifTitle()) {
						winNode.tit = win.title;
					}
				}
				if (entity instanceof CvgStatusBar) {
					// nothin
				} else if (entity instanceof CvgEntity) {
					gridParent = null;
					line = null;
					if (entity instanceof CvgVariable) {
						line = entity.srcLine;
					} else if (entity instanceof CvgDataSrcLine) {
						line = entity;
					} else if (entity instanceof CvgDataSrc) {
						gridParent = entity;
					}
					if (line != null) {
						gridParent = line.dataSrc;
					}
					/* Explanation for simplification of original code:
					if (gridParent != null || line != null) { // the second condition is not necessary, because then gridParent = line.dataSrc has already been set and gridParent is not null
						if (gridParent == null) { // this is vane, because when gridParent is null, line must be != null, and then gridParent = line.dataSrc has already been done 
							gridParent = line.dataSrc;
						}
						if (gridParent.isBlocGrid()) {
							entity = gridParent;
						}
					} */
					if (gridParent != null && gridParent.isBlocGrid()) {
						entity = gridParent;
					}

					jsonKey = entity.getJsonKey();

					if (winNode.entities[jsonKey] == null) {
						timing = perfmonEnabled && perfmon.start(module, entity.getAdxIst() + ".toJSON");
						jsonEntity = entity.toJSON();
						if (perfmonEnabled) {

							timing.end();
							if (perfConfig.clientRecord) {
								this.timing.toJSON = this.timing.toJSON || [];
								this.timing.toJSON.push({
									duration: timing.getTiming() ? timing.getTiming().duration : 0,
									"entity": entity.getAdxIst()
								});
							}
						}
						if (jsonEntity && Object.keys(jsonEntity).length !== 0) {
							winNode.entities[jsonKey] = jsonEntity;
						}
					}
				}
			}
			/*if (win && win.entityIdxAlpha && Object.keys(wins[win.entityIdxAlpha].entities).length === 0)
				delete wins[win.entityIdxAlpha];*/
		}
		var response = {
			sap: {},
			session: lists.SESSION[0] || {}
		};
		if (lists.SESSIONOPEN && lists.SESSIONOPEN.length !== 0) {
			response.session.open = JSON.parse(JSON.stringify(lists.SESSIONOPEN[0]));
		}
		var sap = response.sap;
		if (lists.MISC && lists.MISC.length !== 0) {
			sap.misc = JSON.parse(JSON.stringify(lists.MISC[0]));
		}
		if (lists.TARGET.length !== 0) {
			// code simplification: this.getTarget() need not be computed when isTrack is set
			if (!isTrack) {
				sap.target = this.getTarget();
			} else if (sap.target) {
				delete sap.target;
			}
		}
		var acts = lists.ACT.filter(isDefined);
		if (acts && acts.length !== 0) {
			sap.acts = acts;
		}
		if (lists.RPC.length !== 0) {
			var rpc = JSON.parse(JSON.stringify(lists.RPC[0]));
			if (this.lastAckCallSpgmId[this.lastAckCallSpgmId.length - 1] === "GESUSER:CONNECT_FONCTION") { // if reuse ack_call return
				if (rpc.json.result.errm && sap.target.type === "portal") {
					var result = rpc.json.result;
					sap.target.portal = {
						$diagnoses: [{
							"$stackTrace": "x3 Error; num:" + result.errn + ", message:" + result.errm + " line:" + result.errl + " type:" + result.errt,
							"$severity": 'ERROR',
							"appCode": 500,
							"$origin": "NodeJS: Convergence Server ",
							"$message": "x3 Error - " + result.errm,
						}]
					};
				}
			} else { // if not reuse ack_call, serialize rpc
				// list of ack call - remove the last ack_call
				sap.rpc = rpc;
			}
			this.lastAckCallSpgmId.pop();

		}
		for (i = 0; i < lists.FUNCO.length; i++) {
			sap.func = sap.func || {};
			win = lists.FUNCO[i];
			key = win && win.entityIdxAlpha;
			if (win && win.isOpened()) {
				// object with key: win
				win.dumpOpened = true;
				sap.func.open = sap.func.open || {};
				sap.func.open[key] = win;
			}
		}
		for (i = 0; i < lists.FUNCC.length; i++) {

			sap.func = sap.func || {};
			win = lists.FUNCC[i];
			key = win && win.entityIdxAlpha;
			if (win && win.dumpOpened) {
				// just an array of keys
				sap.func.close = sap.func.close || [];
				sap.func.close.push(key);
				//				wins[key] = {
				//					tit: win.title,
				//					entities: {}
				//				};
			}
		}
		if (Object.keys(wins).length > 0) {
			sap.wins = wins;
		}
		if (sap.target && sap.target.ist) {
			for (i = 0; i < lists.TARGETACT.length; i++) {
				sap.target.ist.acts = sap.target.ist.acts || [];
				sap.target.ist.acts.push(lists.TARGETACT[i]);
			}
		}
		var report, kind;
		for (i = 0; i < lists.REPORT.length; i++) {
			sap.jobs = sap.jobs || {};
			sap.jobs.report = sap.jobs.report || {};
			report = lists.REPORT[i];
			kind = report.kind;
			sap.jobs.report[kind] = sap.jobs.report[kind] || [];
			sap.jobs.report[kind].push(JSON.parse(JSON.stringify(report)));
		}
		if (true === connect) {
			// Add session settings only at connection
			// add dynamic formats
			this._sessionSettings.fmtExt = {};
			var p, res, dynFmt;
			for (p in this._dynFormats) {
				dynFmt = this._dynFormats[p];
				res = {};
				if (dynFmt.complement != null) {
					res.stdType = dynFmt.complement.split('');
				}
				if (dynFmt.subType != null) {
					res.chars = dynFmt.subType.split('');
				}
				this._sessionSettings.fmtExt[p] = res;
			}
			if (!this._sessionSettings.mnu || this._sessionSettings.mnu.length === 0) {
				// Add menus only if received
				// !! Reuse session - We must store menus received at first connexion
				this._sessionSettings.mnu = lists.SESSIONMNU;
			}
			response.session.settings = this._buildUiClientSettings();
		} else {
			if (!this._sessionSettings.mnu || this._sessionSettings.mnu.length === 0) {
				// Add menus only if received
				// !! Reuse session - We must store menus received at first connexion
				this._sessionSettings.mnu = lists.SESSIONMNU;
				response.session.settings = this._buildUiClientSettings();
			}

		}

		response.srvop = {};
		// request object
		var serverName = "";
		if (this.baseUrl) {
			serverName = this.baseUrl.substr(this.baseUrl.indexOf("://") + 3);
			serverName.substr(0, serverName.indexOf("/"));
		}

		var aRqst = this.activeRequest.sendContext;
		response.srvop.request = {
			"id": aRqst.reqNum,
			"v": this.activeRequest.reply.actionId,
			"rqtdist": aRqst.target,
			"connect": 1,
			"status": this.activeRequest.status,
			"session": this.sessionId,
			"server": serverName // change by baseUrl - more interesting if the server public name is not the same and for unit test
		};

		for (i = 0; i < lists.DIAGNOSE.length; i++) {

			response.srvop.$diagnoses = response.srvop.$diagnoses || [];
			response.srvop.$diagnoses.push(JSON.parse(JSON.stringify(lists.DIAGNOSE[i])));
		}
		for (i = 0; i < lists.GLDIAGNOSE.length; i++) {
			response.sap.$4glDiagnoses = response.srvop.$4glDiagnoses || [];
			response.sap.$4glDiagnoses.push(JSON.parse(JSON.stringify(lists.GLDIAGNOSE[i])));
		}

		// add sessionInfo
		if (true === connect) {
			// Add session info at connection
			response.srvop.sessionInfo = {
				reused: this.reused,
				nodeWS: this.sessInfo.nodeWS,
				node: this.sessInfo.node,
				runtime: this.sessInfo.runtime
			};
			response.srvop.sessionInfo.runtime.folder = this.clientConfig.getParam("x3Folder");
		}

		if (perfmonEnabled) {
			timing.end();
			if (perfConfig.clientRecord) {
				this._calculTiming(this.timing);
				response.timing = this.timing;
			}
		}
		if (this.traceTiming && this.perfTimer) {
			this.perfTimer.end();
			var reqTime = this.perfTimer.getTiming();
			reqTime = reqTime && reqTime.duration ? reqTime.duration * 1000 : 0;
			var rtsTime = (this.activeRequest.rtsTimer.read + this.activeRequest.rtsTimer.write);
			response.srvop.timing = {
				rts: Math.round(rtsTime * 1000) / 1000,
				ws: Math.round((reqTime - rtsTime) * 1000) / 1000
			};
		}
		this.response.body = response;
	}
});