"use strict";
var helpers = require('syracuse-core/lib/helpers');

//

exports.CvgObserver = helpers.defineClass(function() {
	this._trackLists = this.newTrackLists();
	this.currentTracker = null;
	this.response;
}, null, {
	newTrackLists: function() {
		return {
			SESSION: [],
			SESSIONOPEN: [],
			ACT: [],
			TARGETACT: [],
			SESSIONMNU: [],
			TARGET: [],
			MISC: [],
			ENTITY: [],
			FUNCO: [],
			FUNCC: [],
			RPC: [],
			WINDOW: [],
			DIAGNOSE: [],
			GLDIAGNOSE: [],
			REPORT: []
		};
	},
	stopTracker: function(_, context, obs, isConnectRequest) {
		var observer = obs; // use current one or the one in parameter
		if (observer && !Array.isArray(observer)) {
			observer = [observer];
		}
		observer && observer.forEach_(_, function(_, obs) {
			if (obs.currentTracker) {
				obs.generateResponse(_, isConnectRequest); // generat response
				var data = obs.response;
				var statusCode = 200;
				//console.log("\tprocessRequest.end "+statusCode+" data "+JSON.stringify(data));
				obs.currentTracker.stop(_, context, data, statusCode); // stop tracker and write response
				if (statusCode == 200 && obs.recorder) {
					obs.recorder.dumpHttpResp(_, data.body); // save data in recorder
				}
				obs.currentTracker = null;
			}
		});
	},
	track: function(obj) {
		// add if not exists the current obj
		var list = this._trackLists[obj.jsonType];
		// Allow observable to not send adat - see CvgDiagnose
		/*if (obj.sendToClient && !obj.sendToClient(list)) {
         return;
         }*/
		if (obj.getObservableId) {
			// we can add keys directly to the array, they will be ignored by JSON.stringify
			var key = '#' + obj.getObservableId();

			var old = list[key];
			if (old != null) {
				list[old] = undefined;
			}
			list[key] = list.length;
		}
		list.push(obj);
	}
});