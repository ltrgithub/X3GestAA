"use strict";
var helpers = require('syracuse-core/lib/helpers');

//

exports.CvgObserver = helpers.defineClass(function() {
	this._trackLists = this.newTrackLists();
	this.currentTracker = null;
	this.response;
}, null, {
	newTrackLists: function() {
		return {
			SESSION: [],
			SESSIONOPEN: [],
			ACT: [],
			TARGETACT: [],
			SESSIONMNU: [],
			TARGET: [],
			MISC: [],
			ENTITY: [],
			FUNCO: [],
			FUNCC: [],
			RPC: [],
			WINDOW: [],
			DIAGNOSE: [],
			GLDIAGNOSE: [],
			REPORT: []
		};
	},
	stopTracker: function(_, context, obser, isConnectRequest) {
		var observer = obser; // use current one or the one in parameter
		if (observer && !Array.isArray(observer)) {
			observer = [observer];
		}

		observer && observer.forEach_(_, function(_, obs) {
			if (obs && obs.currentTracker && !obs.currentTracker.stopped) {
				obs.generateResponse(_, isConnectRequest); // generate response
				var data = obs.response;
				var statusCode = 200;
				//console.log("\t stop tracker " + obs.currentTracker._trackId);
				obs.currentTracker.stop(_, context, data, statusCode); // stop tracker and write response
				obs.currentTracker.stopped = true;

				if (statusCode == 200 && obs.recorder) {
					obs.recorder.dumpHttpResp(_, data.body); // save data in recorder
				}
			}
		});
	},
	track: function(obj) {
		// add if not exists the current obj
		var list = this._trackLists[obj.jsonType];
		// Allow observable to not send adat - see CvgDiagnose
		/*if (obj.sendToClient && !obj.sendToClient(list)) {
         return;
         }*/
		if (obj.getObservableId) {
			// we can add keys directly to the array, they will be ignored by JSON.stringify
			var key = '#' + obj.getObservableId();

			var old = list[key];
			if (old != null) {
				list[old] = undefined;
			}
			list[key] = list.length;
		}
		list.push(obj);
	}
});