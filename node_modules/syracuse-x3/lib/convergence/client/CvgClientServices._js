"use strict";
var helpers = require('syracuse-core/lib/helpers');
var x3helpers = require("syracuse-x3/lib/helpers");
var CvgException = require('syracuse-x3/lib/convergence/model/CvgException').CvgException;
var CvgBlobSvc = require('syracuse-x3/lib/convergence/client/CvgBlobSvc').CvgBlobSvc;
var fs = require('fs');

var CvgClientBlobSvc = helpers.defineClass(function(client) {
	CvgBlobSvc.call(this);
	this.blobs = {};
	this.client = client;

}, CvgBlobSvc, {
	// type can be 'image' to make others mime types forbidden
	register: function(uuid, binary, type, options) {
		//console.log("Register: "+uuid);		
		this.blobs[uuid[0]] = this.blobs[uuid[0]] || {};
		this.blobs[uuid[0]][uuid.substring(1, uuid.length)] = {
			mimeType: (options && options.mimeType) || this.calcMimeType(binary, type),
			binary: binary
		};

		if (options && options.filename) {
			this.blobs[uuid[0]][uuid.substring(1, uuid.length)].filename = options.filename;
		}
		return this.blobs[uuid[0]];
	},
	unregister: function(uuid) {
		//console.log("Unregister: "+uuid);
		//SAM 112012 - delete the blob in the screen and not all the blob in the screen
		var screen = this.blobs[uuid[0]];
		if (screen && screen[uuid.substring(1, uuid.length)]) {
			delete screen[uuid.substring(1, uuid.length)];
			if (Object.keys(screen).length === 0) {
				delete this.blobs[uuid[0]];
			}
		}

	},
	getBlob: function(uuid) {
		//console.log("Get blob: "+uuid);
		var screen = this.blobs[uuid[0]];
		return screen && screen[uuid.substring(1, uuid.length)];
	},

	doGet: function(_, context) {
		var id = context.parameters.id;
		var res = {
			header: {}
		};

		var blob = this.getBlob(id);
		if (blob && blob.mimeType) {
			res.header["content-type"] = blob.mimeType;
		}

		if (blob && blob.filename) {
			res.header["Content-Disposition"] = 'attachment; filename="' + blob.filename + '"';
		}

		if (blob && blob.mimeType && blob.binary) {
			res.data = blob.binary;
			res.dataType = 'binary';
		}
		res.statusCode = !blob ? 404 : 200;
		return res;
	},
	doPost: function(_, context) {
		var id = context.parameters.id;
		// IE
		var boundary, len;
		var type = context.parameters.type;
		var res = {
			dataType: context.parameters.type,
			header: {}
		};
		if (!id) {
			throw new Error("Bad blob ID.");
		}

		// getting binary
		var bodyStr = '';
		var buf, boundary;
		var match = /^multipart\/form-data;\s*boundary=(.*)/.exec(context.request.headers["content-type"]);
		if (match) {
			boundary = match[1];
			buf = context.request.read(_, 2048);
			var lines = buf.toString("binary").split('\n');
			if (lines[0].indexOf(boundary) < 0) {
				throw new Error("boundary not found");
			}
			var i;
			for (i = 0; i < lines.length; i++) {
				if (/^\r?$/.test(lines[i])) {
					break;
				}
			}
			len = 0;
			while (i >= 0) {
				len += lines[i--].length + 1;
			}
			context.request.unread(buf.slice(len));
		}
		if (boundary) {
			len = Math.max(boundary.length, 256);

			var s, idx;
			while ((buf = context.request.read(_, 32 * len))) {
				s = buf.toString("binary");
				idx = s.indexOf(boundary);
				if (idx >= 0) {
					idx = s.lastIndexOf('\n', idx);
					bodyStr += s.substring(0, idx);
					context.request.readAll(_); // discard any trailing data
				} else {
					bodyStr += s.substring(0, 31 * len);
					context.request.unread(buf.slice(31 * len));
				}
			}
		}
		this.register(id, new Buffer(bodyStr, 'binary'), type);
		res.header["content-type"] = 'text/html';
		res.statusCode = 201;
		return res;
	},
	doPut: function(_, context) {
		if (!context.parameters.id) {
			throw new Error("Bad blob ID.");
		}
		var res = {
			dataType: context.parameters.type,
			header: {}
		};

		this.register(context.parameters.id, new Buffer(context.request.readAll(_), 'binary'), context.parameters.type);
		res.header["content-type"] = 'application/json';
		res.statusCode = 201;
		return res;
	},
	doDelete: function(_, context) {
		var id = context.parameters.id;
		var blob = this.getBlob(id);
		var res = {
			header: {}
		};
		// If not exist register again
		if (!blob) {
			blob = this.register(id, '');
		}
		blob.binary = '';
		res.header["content-type"] = 'application/json';
		res.statusCode = 204;
		return res;
	},


	// if type = 'image' -> control data mime type as gif | jpeg | bmp | png | tif
	calcMimeType: function(bin, type) {
		var mimeType = "application/octet-stream";
		if (this.isBlobImgGif(bin)) {
			mimeType = "image/gif";
		} else if (this.isBlobImgJpg(bin)) {
			mimeType = "image/jpeg";
		} else if (this.isBlobImgBMP(bin)) {
			mimeType = "image/bmp";
		} else if (this.isBlobImgPng(bin)) {
			mimeType = "image/png";
		} else if (this.isBlobImgTiff(bin)) {
			mimeType = "image/tiff";
		} else if (type && type.indexOf('image') === 0) {
			throw new Error("Data mime type does not match any authorized image type.");
		}
		return mimeType;
	},

	/**
	 * BMP File contains 0x42 0x4d ("BM") in the first two bytes of the file header
	 *
	 * For more information see:
	 * http://en.wikipedia.org/wiki/.BMP
	 *
	 * @param bin
	 * @return
	 */
	isBlobImgBMP: function(bin) {
		return bin[0] === 0x42 && bin[1] === 0x4d;
	},

	/**
	 * GIF Files are identified by the first three characters containing
	 * 0x47 0x49 0x46 - ("GIF") the following 3 characters "87a" or "89a"
	 *
	 * For more information see:
	 * http://en.wikipedia.org/wiki/.GIF
	 *
	 * @param bin
	 * @return
	 */
	isBlobImgGif: function(bin) {
		return bin[0] === 0x47 && bin[1] === 0x49 && bin[2] === 0x46;
	},

	/**
	 *
	 * JPEG SOI (Start of Image) marker : 0xFF 0xD8
	 *
	 * For more information see:
	 * http://en.wikipedia.org/wiki/.JPEG
	 *
	 * @param bin
	 * @return
	 */
	isBlobImgJpg: function(bin) {
		return bin[0] === 0xff && bin[1] === 0xd8;
	},

	/**
	 *
	 * PNG file signature The first eight bytes of a PNG file always contain the
	 * following (hex) 0x89 0x50 0x4e 0x47 0x0d 0x0a 0x1a 0x0a
	 * (ASCII C notation) \211 P N G \r \n \032 \n
	 *
	 * For more information see:
	 * http://en.wikipedia.org/wiki/.PNG
	 *
	 * @param bin
	 * @return
	 */
	isBlobImgPng: function(bin) {
		return bin[0] === 137 && bin[1] === 80 && bin[2] === 78 && bin[3] === 71 && bin[4] === 13 && bin[5] === 10 && bin[6] === 26 && bin[7] === 10;
	},

	/**
	 * TIFF files all begin with a two byte indicator of the byte order
	 * "II" (0x49 0x49) for little-endian (i.e. Intel) or "MM" (0x4D 0x4D) for
	 * big-endian (i.e. Motorola)
	 *
	 * For more information see:
	 * http://en.wikipedia.org/wiki/TIFF
	 *
	 * @param bin
	 * @return
	 */
	isBlobImgTiff: function(bin) {
		return (bin[0] === 0x4D && bin[1] === 0x4D) || (bin[0] === 0x49 && bin[1] === 0x49);
	}
});

exports.create = function(client) {
	return {
		blobSvc: new CvgClientBlobSvc(client)
	};
};