"use strict";
var helpers = require('syracuse-core/lib/helpers');
var x3helpers = require("syracuse-x3/lib/helpers");
var CvgException = require('syracuse-x3/lib/convergence/model/CvgException').CvgException;
var CvgBlobSvc = require('syracuse-x3/lib/convergence/client/CvgBlobSvc').CvgBlobSvc;

var fs = require('fs');

var CvgClientBlobSvc = helpers.defineClass(function(_, client) {
	this.client = client;
	this.blobs = {};
}, CvgBlobSvc, {
	// type can be 'image' to make others mime types forbidden
	register: function(uuid, binary, type, options) {
		//console.log("Register: "+uuid);		
		this.blobs[uuid[0]] = this.blobs[uuid[0]] || {};
		this.blobs[uuid[0]][uuid.substring(1, uuid.length)] = {
			mimeType: (options && options.mimeType) || this.calcMimeType(binary, type),
			binary: binary
		};

		if (options && options.filename) {
			this.blobs[uuid[0]][uuid.substring(1, uuid.length)].filename = options.filename;
		}
		return this.blobs[uuid[0]];
	},
	unregister: function(uuid) {
		//console.log("Unregister: "+uuid);
		delete this.blobs[uuid[0]];
	},
	getBlob: function(uuid) {
		//console.log("Get blob: "+uuid);
		var screen = this.blobs[uuid[0]];
		return screen && screen[uuid.substring(1, uuid.length)];
	},
	doGet: function(_, context) {
		var statusCode;
		var id = context.parameters.id;
		var header = {};
		//console.log("GET: "+id);
		//console.log("context.parameters : "+JSON.stringify(context.parameters,null,2));
		var blob = this.getBlob(id);
		if (blob && blob.mimeType) {
			header["content-type"] = blob.mimeType;
		}
		if (blob && blob.filename) {
			header["Content-Disposition"] = 'attachment; filename="' + blob.filename + '"';
		}
		var dataType;
		if (blob && blob.mimeType && blob.binary) {
			data = blob.binary;
			dataType = 'binary';
		}
		statusCode = !blob ? 404 : 200;

		return {
			statusCode: statusCode,
			header: header,
			dataType: dataType
		};

	},
	doPost: function(_, context) {
		// IE
		type = context.parameters.type;

		if (!id) {
			throw new Error("Bad blob ID.");
		}

		// getting binary
		bodyStr = '';
		var buf, boundary;
		var match = /^multipart\/form-data;\s*boundary=(.*)/.exec(context.request.headers["content-type"]);
		if (match) {
			boundary = match[1];
			buf = context.request.read(_, 2048);
			var lines = buf.toString("binary").split('\n');
			if (lines[0].indexOf(boundary) < 0) {
				throw new Error("boundary not found");
			}
			var i;
			for (i = 0; i < lines.length; i++) {
				if (/^\r?$/.test(lines[i])) {
					break;
				}
			}
			len = 0;
			while (i >= 0) {
				len += lines[i--].length + 1;
			}
			context.request.unread(buf.slice(len));
		}
		if (boundary) {
			len = Math.max(boundary.length, 256);

			var s, idx;
			while ((buf = context.request.read(_, 32 * len))) {
				s = buf.toString("binary");
				idx = s.indexOf(boundary);
				if (idx >= 0) {
					idx = s.lastIndexOf('\n', idx);
					bodyStr += s.substring(0, idx);
					context.request.readAll(_); // discard any trailing data
				} else {
					bodyStr += s.substring(0, 31 * len);
					context.request.unread(buf.slice(31 * len));
				}
			}
		}
		binary = new Buffer(bodyStr, 'binary');
		this.register(id, binary, type);
		header["content-type"] = 'text/html';
		return {
			statusCode: 201,
			header: header,
			dataType: dataType
		};
	},
	doPut: function(_, context) {
		//console.log("PUT: "+id);
		var bodyStr = bodyStr || context.request.readAll(_);
		var type = context.parameters.type;
		if (!id) {
			throw new Error("Bad blob ID.");
		}
		var binary = new Buffer(bodyStr, 'binary');
		this.register(id, binary, type);
		header["content-type"] = 'application/json';
		return {
			statusCode: 201,
			header: header,
			dataType: dataType
		};
	},
	doDelete: function(_, context) {
		//console.log("DELETE: "+id);
		var blob = this.getBlob(id);
		// If not exist register again
		if (!blob) {
			blob = this.register(id, '');
		}
		blob.binary = '';
		header["content-type"] = 'application/json';
		return {
			statusCode: 204,
			header: header,
			dataType: dataType
		};
	},



});

exports.create = function(_, client) {
	return {
		blobSvc: new CvgClientBlobSvc(_, client)
	};
};