"use strict";

var CH0 = '0'.charCodeAt(0);

function compl100(src, srcpos, dst, dstpos) {
	var found = false;
	for (var i = 15; i >= 0; i--) {
		var b = src[srcpos + i];
		if (found) dst[dstpos + i] = 99 - b;
		else if (b) dst[dstpos + i] = 100 - b, found = true;
		else dst[dstpos + i] = 0;
	}
	return !found;
}

var CvgDecimal = exports.CvgDecimal = {
	fromBytes: function(buf, pos) {
		pos = pos || 0;
		if (pos + 17 > buf.length) throw new Error("bcd read overflow");
		var head = buf[pos++];
		// extract exponent and sign
		var neg = head < 128,
			exp = neg ? 2 * (63 - head) : 2 * (head - 192);
		var str = "",
			dot = false;
		// complement negative values to 100
		if (neg) {
			var nbuf = new Buffer(16);
			var allZeros = compl100(buf, pos, nbuf, 0);
			if (allZeros) return '0';
			buf = nbuf;
			pos = 0;
		}
		// build complete mantissa
		for (var i = 0; i < 16; i++) {
			var b = buf[pos + i];
			str += b < 10 ? '0' + b : b;
		}
		//console.log("neg=" + neg + ", str1=" + str + ', exp=' + exp);
		// insert decimal point
		if (exp <= 0) {
			while (exp++ < 0) str = '0' + str;
			str = '0.' + str;
			dot = true;
		} else if (exp >= 32) {
			while (exp-- > 32) str += '0';
		} else {
			str = str.substring(0, exp) + '.' + str.substring(exp);
			dot = true;
		}
		//console.log("str2=" + str + ', exp=' + exp)
		// remove leading and trailing zeros
		if (dot) {
			var i = 0;
			while (str[i] === '0' && str[i + 1] !== '.') i++;
			var j = str.length - 1;
			while (str[j] === '0') j--;
			if (str[j] === '.') j--;
			str = str.substring(i, j + 1);
		} else {
			var i = 0;
			while (str[i] === '0' && i < str.length - 1) i++;
			if (i > 0) str = str.substring(i);
		}
		return neg ? '-' + str : str;
	},
	toBytes: function(str, buf, pos) {
		buf = buf || new Buffer(17);
		pos = pos || 0;

		if (buf.length < pos + 17) throw new Error("bcd write overflow");
		var matches = /^(-?)0*(\d*)\.?(0*)(\d*)$/.exec(str);
		if (!matches) throw new Error("bad CvgDecimal: " + str);
		var neg = matches[1] === '-';
		var intg = matches[2];
		var dec1 = matches[3];
		var dec2 = matches[4];
		var halfexp, mant;
		if (intg.length > 0) {
			halfexp = Math.floor((intg.length - 1) / 2) + 1;
			console.log('halfExp '+halfexp);
			mant = intg.length % 2 ? '0' + intg + dec1 + dec2 : intg + dec1 + dec2;
		} else if (dec2.length > 0) {
			halfexp = -Math.floor((dec1.length - 1) / 2);
			mant = dec1.length % 2 ? '0' + dec2 : dec2;
		} else { // all zeros
			buf[0] = 0x80;
			buf.fill(0, 1, 17);
			return buf;
		}
		console.log("halfexp=" + halfexp);
		console.log("mant=" + mant);
		// remove all last 0 digit to get only the necessary digit
		var stop = false;
		var i;
		for(i=mant.length-1;i>=0 && !stop;i--){
			stop = mant[i] !== '0';
		}
		mant = mant.splice(0,i);

		buf[pos++] = neg ? (63 - halfexp) : (halfexp + 192);
		for (var i = 0; i < 16; i++) {
			console.log('buf '+((mant.charCodeAt(2 * i) || CH0) - CH0) * 10);
			console.log('buf '+((mant.charCodeAt(2 * i+1) || CH0) - CH0));
			buf[pos + i] = ((mant.charCodeAt(2 * i) || CH0) - CH0) * 10 + //
			((mant.charCodeAt(2 * i + 1) || CH0) - CH0);
		}
		console.log("buf "+buf.toString('hex'));
		if (neg) compl100(buf, pos, buf, pos);
		return buf;
	},
}
