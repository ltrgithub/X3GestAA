"use strict";

var CH0 = '0'.charCodeAt(0);

function compl100(src, srcpos, dst, dstpos) {
	var found = false,
		i, b;
	for (i = 15; i >= 0; i--) {
		b = src[srcpos + i];
		if (found) {
			dst[dstpos + i] = 99 - b;
		} else if (b) {
			dst[dstpos + i] = 100 - b;
			found = true;
		} else {
			dst[dstpos + i] = 0;
		}
	}
	return !found;
}

var CvgDecimal = {
	fromBytes: function(buf, pos) {
		pos = pos || 0;
		if (pos + 17 > buf.length) {
			throw new Error("bcd read overflow");
		}
		var head = buf[pos++];
		// extract exponent and sign
		var neg = head < 128,
			exp = neg ? 2 * (63 - head) : 2 * (head - 192);
		var str = "",
			dot = false,
			i;
		// complement negative values to 100
		if (neg) {
			var nbuf = new Buffer(16);

			var allZeros = compl100(buf, pos, nbuf, 0);
			if (allZeros) {
				return '0';
			}
			buf = nbuf;
			pos = 0;
		}
		// build complete mantissa
		var b;
		for (i = 0; i < 16; i++) {
			b = buf[pos + i];
			str += b < 10 ? '0' + b : b;
		}
		//console.log("neg=" + neg + ", str1=" + str + ', exp=' + exp);
		// insert decimal point
		if (exp <= 0) {
			while (exp++ < 0) {
				str = '0' + str;
			}
			str = '0.' + str;
			dot = true;
		} else if (exp >= 32) {
			while (exp-- > 32) {
				str += '0';
			}
		} else {
			str = str.substring(0, exp) + '.' + str.substring(exp);
			dot = true;
		}
		//console.log("str2=" + str + ', exp=' + exp)
		// remove leading and trailing zeros
		if (dot) {
			i = 0;
			while (str[i] === '0' && str[i + 1] !== '.') {
				i++;
			}

			var j = str.length - 1;
			while (str[j] === '0') {
				j--;
			}
			if (str[j] === '.') {
				j--;
			}
			str = str.substring(i, j + 1);
		} else {
			i = 0;
			while (str[i] === '0' && i < str.length - 1) {
				i++;
			}
			if (i > 0) {
				str = str.substring(i);
			}
		}
		return neg ? '-' + str : str;
	},
	toBytes: function(str, buf, pos) {
		buf = buf || new Buffer(17);
		buf.fill(0, 1, 17);
		pos = pos || 0;

		if (buf.length < pos + 17) {
			throw new Error("bcd write overflow");
		}
		var matches = /^(-?)0*(\d*)\.?(0*)(\d*)$/.exec(str);
		if (!matches) {
			throw new Error("bad CvgDecimal: " + str);
		}
		var neg = matches[1] === '-';
		var intg = matches[2];
		var dec1 = matches[3];
		var dec2 = matches[4];
		var mant;
		var exp = 0;
		if (intg.length > 0) {
			var dec = dec2.length !== 0 ? dec1 + dec2 : dec2;
			mant = intg.length % 2 ? '0' + intg + dec : intg + dec;
			if (dec2.length === 0) {
				exp = intg.length;
			} else {
				exp = (intg.length + dec1.length + dec2.length) - (dec1.length + dec2.length);
			}
		} else if (dec2.length > 0) {
			mant = dec1.length % 2 === 0 ? dec2 : '0' + dec2;
			exp = (intg.length + dec2.length) - (dec1.length + dec2.length);
		} else { // all zeros
			buf[0] = 0x80;
			buf.fill(0, 1, 17);
			return buf;
		}
		mant = mant.length % 2 !== 0 ? mant + '0' : mant;
		var power = exp / 2;
		/*console.log('dec1 '+dec1 );
		console.log('dec2 '+dec2 );
		console.log('intg '+intg );
		console.log('mant '+mant );
		console.log('exp '+exp );
		console.log('pwoer '+power );*/
		power = exp % 2 !== 0 ? Math.floor(power) + 1 : power;
		//power = (exp % 2) !==0 ? power +1:power;
		buf[pos++] = neg ? (63 - power) : (power + 192);
		var i, val;
		for (i = 0; 2 * i + 1 < mant.length; i++) {
			val = parseInt(mant.charAt(2 * i) + mant.charAt(2 * i + 1), 10);
			buf[pos + i] = val;
		}
		if (neg) {
			compl100(buf, pos, buf, pos);
		}
		return buf;
	}
};

exports.CvgDecimal = CvgDecimal;