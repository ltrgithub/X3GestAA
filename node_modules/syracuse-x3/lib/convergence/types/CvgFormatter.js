"use strict";
var helpers = require('syracuse-core/lib/helpers');
var date = require('syracuse-core/lib/types/date');
var formatter = require('syracuse-x3/lib/formatter/format');
var Cvg = require("syracuse-x3/lib/convergence/model/Cvg").Cvg;
var CvgFormat = require('syracuse-x3/lib/convergence/model/CvgFormat').CvgFormat;
var CvgFormatter = exports.CvgFormatter = helpers.defineClass(function(settings) {
	this.settings = settings || {};
}, null, {
	razModifications: function() {
		// TODO: reset dynamic formats and month names
	},
	addDynamicFormat: function(dyn) {
		if (!this.settings.dynFormats) this.settings.dynFormats = {};
		this.settings.dynFormats[dyn.type] = { subType: dyn.subType, complement: dyn.complement };
	},
	isValid: function() {
		return true;
	},
	formatField: function(format, value, raw, strict) {
		if (!format) return "" + value;
		if (value==null) value = ""; else if (typeof value !== 'string') value = value.toString();
		format = this.getRealFormat(format);
		var fmt = format.format;
		switch (fmt[0]) {
			case 'D':
				value=value.trim();
				var dat={d:0,m:0,y:0}, parts = value.split(/[^\d]/);
				if (raw){	
				    // value comes from X3 with format YYYYMMDD - accept also YYMMDD
					if (parts.length!=1) throw new Error ("Bad x3 date["+value+"] - No separator expected - format YYYYMMDD");
					if (value.length==0){
						dat.y = 1599; dat.m = 12; dat.d = 31;
					}else if (value.length >= 6 ) {
						var start=0;
						dat.y = parseInt(value.substring(start ,  start+= value.length-4) || '0', 10);
						dat.m = parseInt(value.substring(start, start+=2) || '0', 10);
						dat.d = parseInt(value.substring(start, start+=2) || '0', 10);
					} else { 
						throw new Error ("Bad x3 date["+value+"] - 8 chars expected - format YYYYMMDD");;
					}
				}else {			 
					// not raw value -> dateOrder is given by format - Try to parse value to read y:m:d according to format
		            if (parts.length > 1) {		
		            	// raw value with sperators            		
			   			var i=0;
			            fmt.substr(fmt.indexOf(':')).replace(/(Y+|M+|D+)/g,function(p1){
			               dat[p1[0].toLowerCase()]=parseInt(parts[i] || '0',10);
			               i++;
			            });
			            if (i>0 && dat.y==0)  dat.y=new Date().getFullYear();
					} else {
		            	// raw value without sperators
						var pos=0, id,l; 
			            fmt.substr(fmt.indexOf(':')).replace(/(Y+|M+|D+)/g,function(p1){
			            	id=p1[0].toLowerCase();
			            	l= id=='y' ? value.length > 6 ? 4 : p1.length : 2;
			            	dat[id]=parseInt(value.substr(pos,l) || '0',10);
				            pos+=l;
			            });
			            // Very special case - DMY or MDY - year with more than 4 digits - Read until end of string 
			            // See unit test - testOptions('D:DD[/]MM[/]YYYY', false, '011000002', '01/10/2002');
			            if (value.length>8 & id=='y') dat.y=parseInt(value.substr(pos-l) || '0',10);
					}					
				}					
				if (dat.y === 1599 && dat.m === 12 && dat.d === 31) {
					value = date.make(0, 0, 0);
				}else{
					dat.y = this._calcCentury(dat.y, value, fmt);
					value = date.make(dat.y, dat.m, dat.d);
				}
				break;
			case 'N':
					if (this.settings.thousandSep) value = value.split(this.settings.thousandSep).join('');
					if (this.settings.decimalSep !== '.') value = value.split(this.settings.decimalSep).join('.');
				break;
		}
		var result;
		try{
			// strict check number of digits i decimal par and throws an error - false by default		
			this.settings.strict=strict;
			result = formatter.format(this.settings, fmt, value);
		}finally{
			delete this.settings.strict;
		}
		if (format.countryDate && format.textMonth){
			// DD3,DD4 formats - remove whitespaces after month's name
			if (format.textMonth) result=result.replace(/\s+/g,' ');
			// Add time after year
			var d = new Date();
			result+=" " + d.getHours() + ":" + d.getMinutes();
			if (format.dateType == '4') result+= ":" + d.getSeconds();
		}
		return result;
	},
	unformatField: function(format, val, check) {		
		function zeroPad(n, len) {
			return n.toString().length > 0 ? (new Array(len + 1).join('0') + n).slice(-len) : "";
		}
		format = this.getRealFormat(format);
		var fmt = format.format, result;		
		switch (fmt[0]) {
			case 'K':
				result= formatter.parse(this.settings, fmt, val).toString().replace(/\s+$/, '');
				break;
			case 'D':
				if(val!=null) val=(val.toString()).trim();
				var dat = formatter.parse(this.settings, fmt, val);
				// Check if it's date null
				if (dat.year !== 1599 || dat.month !== 12 || dat.day !== 31) {
					var realYear = this._calcCentury(dat.year, val, fmt);
					if (dat.year !== realYear) dat = date.make(realYear, dat.month, dat.day);
					if (check===true) this._checkDate(dat,val);
				}
				result = zeroPad(dat.year, 4) + zeroPad(dat.month, 2) + zeroPad(dat.day, 2);
				break;
			case 'N':
				if (val.length === 0) {
					result= "";
				} else {
					result= formatter.parse(this.settings, fmt, val).toString();
				}
				break;
			default:
				result= formatter.parse(this.settings, fmt, val).toString();
			break;
		}
		return result;
		
	},
	formatEdit: function(format, val, raw) {
		var rawVal = raw ? val : this.unformatField(format, val);
		var wResult = this.formatField(new CvgFormat(this.getFormatEdit(format.format)), rawVal, true, false);
		return wResult;
	},
	_checkDate: function(dat,val){
		var d = new Date(dat.year, dat.month-1, dat.day);
		if (d.getFullYear()!=dat.year || (d.getMonth()!=dat.month-1) || d.getDate()!=dat.day){
			throw new Error("Date ["+  dat + "] is not valid");
		}
	},
	_readDigit:function(dat, x, t){
	    if (t=='M' || t=='D'){
	        var max=t=='M'?12:31, n=parseInt(x.substring(0,2),10);
	        if (n>max){
	            n=parseInt(x.substring(0,1),10);
	            x=x.substr(1);
	        }else{
	            x=x.substr(2);
	        }
	        dat[t]=n;
	        return x;
	    }else{
	        dat[t]=parseInt(x.substr(0,4),10);
	        return x.substr(4);
	    }        
	},
	// Parse string str input by user and return a date - srvVal is the default date
	// date is parsed according to current this.settings.dateOrder
	_parseEditDate :function (fmt, str, srvVal){
		var ord='';
		fmt=fmt.substr(fmt.indexOf(':')).replace(/[\x5B][^\x5D]*[\x5D]+/g,"");
        fmt.substr(fmt.indexOf(':')).replace(/(Y+|M+|D+)/g,function(p1){
            ord+=p1[0];
        });
	    var datePivot = this.settings.datePivot;
    	srvVal=srvVal==null?'':srvVal.replace(/[^\d]/g,'');
	    var dateRef;
	    if (srvVal.length==8){
	    	dateRef={        
		            'D':parseInt(srvVal.substr(6,2),10),
		            'M':parseInt(srvVal.substr(4,2),10),
		            'Y':parseInt(srvVal.substr(0,4),10),
		        }
	    }else{
	        var d=new Date();
	        dateRef={        
	            'D':d.getDay(),
	            'M':d.getMonth()-1,
	            'Y':d.getFullYear()
	        }
	    }		    
	    if (!str) return dateRef;
	    var dat={D:null,M:null,Y:null};
	    str=str.trim();
	    var split=str.split(/[^\d]+/g);
	    if (split.length==1){
	    	// only digits 
		    // if ord==DMY - 234 -> 24/4/dateRef.Y - 434 -> 4/3/4 - 412 -> 4/12/dateRef.Y - 413 -> 24/1/3
	        for (var x in ord){
	            str=this._readDigit(dat, str,ord.charAt(x));
	        }    
	    }else{  
	  	     var tmp=ord;
		     split.forEach(function(v){
		        if (v.length>0 && tmp.length!=0){
		             dat[tmp[0]]=parseInt(v,10);
		             tmp=tmp.substr(1);
		         }    
		     })
	    }
	    for (var p in dat){
	        if (dat[p]== null || isNaN(dat[p])) dat[p]=dateRef[p];
	    }
	    // Date X3
	    var res='';
	    var century = (Math.floor(new Date().getFullYear() / 100)-1) * 100;
		res+="" + dat.Y < 100 ? century +  dat.Y < datePivot ? (century + 100) +  dat.Y : century +  dat.Y : dat.Y;  
		res+= dat.M<10?"0"+dat.M:dat.M;
		res+=dat.D<10?"0"+dat.D:dat.D;	
	    return res;
	},
	formatEditToDisplay: function(format, val, srvVal) {
		var editFmt=this.getFormatEdit(format.format);
		if (val==null || val.length==0){
			// Format with X3 format
			return  this.formatField(format, val, false, true);
		}
		if (format.format[0]=='D'){
			val=this._parseEditDate(editFmt, val, srvVal);
		}else{
			try{			
				//  Try std Format
				val= this.unformatField(format, val, true);	
			} catch(e){
				console.error(e.stack);
				//  Try edit Format
				var editFmt=new CvgFormat(editFmt);
				val=this.unformatField(editFmt, this.formatField(editFmt, val, false, true), true);
			}
		}
		val = this.formatField(format, val,true, true);
		return val;
	},
	_calcCentury: function(y, value, fmt) {
		if ((y < 100 ) && value.length > 0) {
			var century = Math.floor(new Date().getFullYear() / 100) * 100;
			y = century + y;
			if (y - 100 >= this.settings.datePivot) y -= 100;
		}else if (y.toString().length === 4 && fmt.replace(/[^Y]*/g, "").length === 2) {
			var century = Math.floor(new Date().getFullYear() / 100) * 100;
			y = century + parseInt(y.toString().substring(2), 10);
			if (y - 100 >= this.settings.datePivot) y -= 100;
		}
		return y;
	},
	getRealFormat: function(format) {
		// National formats
		// DD1 : format$("DD1",[1/1/1994]) -> "01/01"
		// DD2 : format$("DD2",[1/1/1994]) -> "01/01/94"
		// DD3 : format$("DD3",[1/1/1994]) -> "01 Janvier 1994 14:38"
		// DD4 : format$("DD4",[1/1/1994]) -> "01 Janvier 1994 14:38:21"
		var res={
			format:format.format,
			countryDate:format.format.search(/D:DD[1-4]$/)==0
		}
		if (res.countryDate){
			var type = res.dateType = res.format[4];
			var day = 'DD';
			res.textMonth=type === '3' || type === '4';
			// We take 20 for month length an remove whitespaces after formatting
			var month =  res.textMonth ? 'MMMMMMMMMMMMMMMMMMMM' :'MM';			
			var year =  type === '1' ? '' : type === '2' ? 'YY' : "YYYY";
			var s = this._buildDateFormat(day, month, year,true);
			res.format="D:" + s;
		}
		return res;
	},
	_cleanFormat: function(fmt,edit){
		if (!fmt) return "";
		var p=fmt.indexOf(':');
		if (p==-1) throw new Error("Bad format");
		var res={};
		res.left=fmt.substring(0,p);
		res.right=fmt.substr(p+1);
		if (res.left.length==0 || res.right.length==0) throw new Error("Bad format");
		res.right=res.right.replace(/\[[^\]]*\]/g,'');
		if (res.left[0]=='D'){
		    res.month=res.day=res.year=null;
		    res.right.replace(/(M+)|(D+)|(Y+)/g, function(p1) {
		        if (p1.length==0) return "";
		        var x=p1[0];
		        if (x=="D") res.day= edit?"DD":p1;
		        if (x=="M") res.month= edit?"MM":p1;
		        if (x=="Y") res.year=  edit?p1.length>2?"YYYY":"YY":p1;
		        return "";
		    });
		}
		return res;
	},	
	getFormatEdit: function(fmt) {
		var f=this._cleanFormat(fmt,true);
		var type = f.left[0];
		switch(type) {
			case 'N':
			case 'K':
				return type + 'z:' + f.right;
			case 'D':
				var s = type + 'z:' + this._buildDateFormat(f.day, f.month, f.year);
				return s;
			default:
				return fmt
		}
	},
	_buildDateFormat: function (day, month, year) {
		var fmt = '';
		var sep = "[" + (month!=null && month.length>2 ?' ':this.settings.dateSep) + "]";
		function append(){
			  for (var i=0;i<arguments.length;i++){
			      var x=arguments[i];
				  if (x==null || x.length==0) continue;
				  if (fmt.length!=0){
					  fmt+=sep;
				  }
				  fmt+=x;
			  }
		}
		switch(parseInt(this.settings.dateOrder, 10)){
			case Cvg.FTM_X3DATE_DMY:
				append(day,month,year);
			break;
			case Cvg.FTM_X3DATE_YMD:
				append(year,month,day);
				break;
			default:
				append(month,day,year);
			break;		
		}
		return fmt;
	}
});
