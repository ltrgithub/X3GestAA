"use strict";
var helpers = require('syracuse-core/lib/helpers');
var date = require('syracuse-core/lib/types/date');
var formatter = require('syracuse-x3/lib/formatter/format');
var CvgFormat = require('syracuse-x3/lib/convergence/model/CvgFormat').CvgFormat;
var template={
	decimalSep: '.',
	dateOrder: 0,
	thousandSep:',',
	dateSep: '/',
	datePivot: 1957,
	timeSep: ':',
	vOn: true, 
	zOn: true,
	dynFormats:{},
	// Return original value if format is not valid
	skipBadFormat:false,
	tracer:null
}

var FTM_X3DATE_MDY = 0;
var FTM_X3DATE_DMY = 1;
var FTM_X3DATE_YMD = 2;

function toUnicode(char) {
  	var res = char.charCodeAt(0).toString(16).toUpperCase();
    while (res.length < 4) res = '0' + res;
    return '\\u' + res;
}

var CvgFormatter = exports.CvgFormatter = helpers.defineClass(function(values) {
	this.settings = {};
	for (var p in template){
		this.settings[p] = values==null || values[p]==null ? template[p] : values[p];
	}
}, null, {
	// convergence client - called at sessionSettings
	setDatePivot:function(v){
		v=parseInt(v,10)
		if (!isNaN(v)) this.settings.datePivot = v;
	},
	razModifications: function() {
		// TODO: reset dynamic formats and month names
	},
	addDynamicFormat: function(dyn) {
		if (!this.settings.dynFormats) this.settings.dynFormats = {};
		this.settings.dynFormats[dyn.type] = { subType: dyn.subType, complement: dyn.complement };
	},
	isValid: function() {
		return true;
	},
	formatField: function(format, value, raw, strict) {
		if (!format) return "" + value;
		if (value==null) value = ""; else if (typeof value !== 'string') value = value.toString();
		format = this.getRealFormat(format);
		var fmt = format.format, strict = strict === true;
		switch (fmt[0]) {
			case 'D':
				value=value.trim();				
				var dat={d:0,m:0,y:0};				
				// #1208 - strict format
				var parts = value.split(strict ? new RegExp(toUnicode(this.settings.thousandSep)) : /[^\d]/);
				if (strict){
					parts.forEach(function(e){
						if (isNaN(e)) throw new Error("Number expected");
					});
				}
				if (raw){	
				    // value comes from X3 with format YYYYMMDD - accept also YYMMDD
					if (parts.length!=1) throw new Error ("Bad x3 date["+value+"] - No separator expected - format YYYYMMDD");
					if (value.length==0){
						dat.y = 1599; dat.m = 12; dat.d = 31;
					}else if (value.length >= 6 ) {
						var start=0;
						dat.y = parseInt(value.substring(start ,  start+= value.length-4) || '0', 10);
						dat.m = parseInt(value.substring(start, start+=2) || '0', 10);
						dat.d = parseInt(value.substring(start, start+=2) || '0', 10);
					} else { 
						throw new Error ("Bad x3 date["+value+"] - 8 chars expected - format YYYYMMDD");;
					}
				}else {			 
					// not raw value -> dateOrder is given by format - Try to parse value to read y:m:d according to format
		            if (parts.length > 1) {		
		            	// raw value with sperators            		
			   			var i=0;
			            fmt.substr(fmt.indexOf(':')).replace(/(Y+|M+|D+)/g,function(p1){
			               dat[p1[0].toLowerCase()]=parseInt(parts[i] || '0',10);
			               i++;
			            });
			            if (i>0 && dat.y==0)  dat.y=new Date().getFullYear();
					} else {
		            	// raw value without sperators
						var pos=0, id,l; 
			            fmt.substr(fmt.indexOf(':')).replace(/(Y+|M+|D+)/g,function(p1){
			            	id=p1[0].toLowerCase();
			            	l= id=='y' ? value.length > 6 ? 4 : p1.length : 2;
			            	dat[id]=parseInt(value.substr(pos,l) || '0',10);
				            pos+=l;
			            });
			            // Very special case - DMY or MDY - year with more than 4 digits - Read until end of string 
			            // See unit test - testOptions('D:DD[/]MM[/]YYYY', false, '011000002', '01/10/2002');
			            if (value.length>8 & id=='y') dat.y=parseInt(value.substr(pos-l) || '0',10);
					}					
				}					
				if (dat.y === 1599 && dat.m === 12 && dat.d === 31) {
					value = date.make(0, 0, 0);
				}else{
					dat.y = this._calcCentury(dat.y, value, fmt);
					value = date.make(dat.y, dat.m, dat.d);
				}
				break;
			case 'N':
					if (this.settings.thousandSep) value = value.split(this.settings.thousandSep).join('');
					if (this.settings.decimalSep !== '.') value = value.split(this.settings.decimalSep).join('.');
				break;
		}
		var result;
		try{
			// strict check number of digits in decimal part and size overflow and throws an error - false by default		
			this.settings.strict=strict;
			result = formatter.format(this.settings, fmt, value);
		}finally{
			this.settings.strict=false;
		}
		if (format.countryDate && format.textMonth){
			// DD3,DD4 formats - remove whitespaces after month's name
			if (format.textMonth) result=result.replace(/\s+/g,' ');
			// Add time after year
			var d = new Date();
			result+=" " + d.getHours() + ":" + d.getMinutes();
			if (format.dateType == '4') result+= ":" + d.getSeconds();
		}
		return result;
	},
	unformatField: function(format, val, check) {		
		function zeroPad(n, len) {
			return n.toString().length > 0 ? (new Array(len + 1).join('0') + n).slice(-len) : "";
		}
		try{		
			// strict check number of digits in decimal part and size overflow and throws an error - false by default	
			this.settings.strict=check;
			format = this.getRealFormat(format);
			var fmt = format.format, result;		
			switch (fmt[0]) {
				case 'K':
					result= formatter.parse(this.settings, fmt, val).toString().replace(/\s+$/, '');
					break;
				case 'D':
					if(val!=null) val=(val.toString()).trim();
					var dat = formatter.parse(this.settings, fmt, val);
					// Check if it's date null
					if (dat.year !== 1599 || dat.month !== 12 || dat.day !== 31) {
						var realYear = this._calcCentury(dat.year, val, fmt);
						if (dat.year !== realYear) dat = date.make(realYear, dat.month, dat.day);
						if (check===true) this._checkDate(dat,val);
					}
					result = zeroPad(dat.year, 4) + zeroPad(dat.month, 2) + zeroPad(dat.day, 2);
					break;
				case 'N':
					if (val.length === 0) {
						result= "";
					} else {
						result= formatter.parse(this.settings, fmt, val).toString();
					}
					break;
				default:
					result= formatter.parse(this.settings, fmt, val).toString();
				break;
			}
		}finally{
			this.settings.strict=false;
		}
		return result;
		
	},
	formatEdit: function(format, val, raw) {
		var rawVal = raw ? val : this.unformatField(format, val);
		var wResult = this.formatField(new CvgFormat(this.getFormatEdit(format.format)), rawVal, true, false);
		return wResult;
	},
	_checkDate: function(dat,val){
		var d = new Date(dat.year, dat.month-1, dat.day);
		if (d.getFullYear()!=dat.year || (d.getMonth()!=dat.month-1) || d.getDate()!=dat.day){
			throw new Error("Date ["+  dat + "] is not valid");
		}
	},
	_readDigit:function(dat, x, t, y4Digits, dateRef){
	    if (t=='M' || t=='D'){
			dat[t]=parseInt(x.substring(0,2),10);
			if (isNaN(dat[t])){
				if (dateRef && dateRef[t]!=null) dat[t]=dateRef[t];
				else throw new Error((t=='M'?"Month":"Day") + " expected");
			}
			return x.substr(2);
	    }else{	   	    
			dat[t]=parseInt(x.substring(0, y4Digits ? 4 : 2) ,10);
			if (isNaN(dat[t])){
				if (dateRef && dateRef[t]!=null) dat[t]=dateRef[t];
				else throw new Error("year expected");
			}
			return x.substr(y4Digits ? 4 : 2);
	    }   
	},
	// Parse string str input by user and return a date - srvVal is the default date
	// date is parsed according to current this.settings.dateOrder
	_parseEditDate :function (fmt, str, srvVal,y4Digits){
		var ord='';
		// Remove comments
		fmt=fmt.substr(fmt.indexOf(':')).replace(/[\x5B][^\x5D]*[\x5D]+/g,"");
        fmt.substr(fmt.indexOf(':')).replace(/(Y+|M+|D+)/g,function(p1){
            ord+=p1[0];
        });
	    var datePivot = this.settings.datePivot;
    	srvVal=srvVal==null?'':srvVal.replace(/[^\d]/g,'');
	    var dateRef;
	    if (srvVal.length==8){
	    	dateRef={        
		            'D':parseInt(srvVal.substr(6,2),10),
		            'M':parseInt(srvVal.substr(4,2),10),
		            'Y':parseInt(srvVal.substr(0,4),10),
		        }
	    }	    
	    if (!str) return dateRef;
	    var dat={D:null,M:null,Y:null};
	    str=str.trim();
	    // We accept \s\/-._ as separator
	    var split=str.split(/[\x2E\x5F\s\\/-]+/g);
	    if (split.length==1){
		    var tmp=str,i=0;
	        for (var x in ord){
	            tmp=this._readDigit(dat, tmp,ord.charAt(x),str.length>6, dateRef);
	            i++;
	        }    
	        if (tmp.length!=0){
	        	if (i>3 || isNaN(tmp)) throw new Error("Bad input data");
	        }
	    }else{  
	  	     var tmp=ord;
		     split.forEach(function(v, i){
		        if (v.length>0 && tmp.length!=0){
		        	 // Accept only digits
		             var n=Math.floor(v);
		             if (isNaN(n)) throw new Error ("Bad input data");
		             dat[tmp[0]]=n;
		             tmp=tmp.substr(1);
		         }else if (v.length!=0) {
		         	// Error if it remains NaN (5/6/h) data or more than 3 part (5/6/8/9)
		         	if (isNaN(v) || i>2) throw new Error("Bad input data");
		         } 
		     })
	    }
		if (!dateRef){
			// fill missing D/M/Y properties even if no present in format
			// Used to calculate a valid x3Date after parsing
			// In convergence client srvVal is alwas set with serverValue
			var d=new Date();
			dateRef={        
				'D':d.getDay(),
				'M':d.getMonth()-1,
				'Y':d.getFullYear()
			}
		}
    	for (var p in dat){
        	if (dat[p]== null || isNaN(dat[p])) dat[p]=dateRef[p];
    	}
		// #1218 -JMK - we accept 2 or 4 digits dates only
		if ((dat.Y >=100 && dat.Y<=999) || dat.Y > 9999) 	throw new Error("Bad year number");
	    // Date X3
	    var century = (Math.floor(new Date().getFullYear() / 100)-1) * 100;
		dat.Y = + dat.Y < 100 ? century +  dat.Y < datePivot ? (century + 100) +  dat.Y : century +  dat.Y : dat.Y; 
		// Validate full date only	
		if (dat.D<=0 || dat.D>31) 	throw new Error("Bad day number");
		if (dat.M<=0 || dat.M>12) 	throw new Error("Bad month number");
		if (ord.length==3) this._checkDate(date.make(dat.Y,dat.M,dat.D), str);		
	    var res='';
		res+="" + dat.Y;
		res+= dat.M<10?"0"+dat.M:dat.M;
		res+=dat.D<10?"0"+dat.D:dat.D;	
	    return res;
	},
	formatEditToDisplay: function(format, val, srvVal) {
		var editFmt=this.getFormatEdit(format.format);
		if (val==null || val.length==0){
			// Format with X3 format
			return  this.formatField(format, val, false);
		}
		if (format.format[0]=='D'){
			val=this._parseEditDate(editFmt, val, srvVal);
		}else{
			try{			
				//  Try std Format
				val= this.unformatField(format, val, true);	
			} catch(e){
				//  Try edit Format
				var editFmt=new CvgFormat(editFmt);
				val=this.unformatField(editFmt, this.formatField(editFmt, val, false, true), true);
			}
		}
		val = this.formatField(format, val, true, true);
		return val;
	},
	_calcCentury: function(y, value, fmt) {
		if ((y < 100 ) && value.length > 0) {
			var century = Math.floor(new Date().getFullYear() / 100) * 100;
			y = century + y;
			if (y - 100 >= this.settings.datePivot) y -= 100;
		}else if (y.toString().length === 4 && fmt.replace(/[^Y]*/g, "").length === 2) {
			var century = Math.floor(new Date().getFullYear() / 100) * 100;
			y = century + parseInt(y.toString().substring(2), 10);
			if (y - 100 >= this.settings.datePivot) y -= 100;
		}
		return y;
	},
	getRealFormat: function(format) {
		// National formats
		// DD1 : format$("DD1",[1/1/1994]) -> "01/01"
		// DD2 : format$("DD2",[1/1/1994]) -> "01/01/94"
		// DD3 : format$("DD3",[1/1/1994]) -> "01 Janvier 1994 14:38"
		// DD4 : format$("DD4",[1/1/1994]) -> "01 Janvier 1994 14:38:21"
		var res={
			format:format.format,
			countryDate:format.format.search(/D:DD[1-4]$/)==0
		}
		if (res.countryDate){
			var type = res.dateType = res.format[4];
			var day = 'DD';
			res.textMonth=type === '3' || type === '4';
			// We take 20 for month length an remove whitespaces after formatting
			var month =  res.textMonth ? 'MMMMMMMMMMMMMMMMMMMM' :'MM';			
			var year =  type === '1' ? '' : type === '2' ? 'YY' : "YYYY";
			var s = this._buildDateFormat(day, month, year);
			res.format="D:" + s;
		}
		return res;
	},
	_cleanFormat: function(fmt,edit){
		if (!fmt) return "";
		var p=fmt.indexOf(':');
		if (p==-1) throw new Error("Bad format");
		var res={};
		res.left=fmt.substring(0,p);
		res.right=fmt.substr(p+1);
		if (res.left.length==0 || res.right.length==0) throw new Error("Bad format");
		res.right=res.right.replace(/\[[^\]]*\]/g,'');
		if (res.left[0]=='D'){
		    res.month=res.day=res.year=null;
		    res.right.replace(/(M+)|(D+)|(Y+)/g, function(p1) {
		        if (p1.length==0) return "";
		        var x=p1[0];
		        if (x=="D") res.day   = edit ? "DD" : p1;
		        if (x=="M") res.month = edit ? "MM" : p1;
		        if (x=="Y") res.year  = edit ?  p1.length>2 ? "YYYY" : "YY" : p1;
		        return "";
		    });
		}
		return res;
	},	
	getFormatEdit: function(fmt,noFail) {
		try{
			var f=this._cleanFormat(fmt,true);
			var type = f.left[0];
			switch(type) {
				case 'N':
				case 'K':
					return type + 'z:' + f.right;
				case 'D':
					var s = type + 'z:' + this._buildDateFormat(f.day, f.month, f.year);
					return s;
				default:
					return fmt
			}
		}catch(e){
			if (noFail===true) return fmt;
			e.message+=e.message + " - fmt["+fmt+"]";
			throw (e);
		}
	},
	_buildDateFormat: function (day, month, year) {
		var fmt = '';
		var sep = "[" + (month!=null && month.length>2 ?' ':this.settings.dateSep) + "]";
		function append(){
			  for (var i=0;i<arguments.length;i++){
			      var x=arguments[i];
				  if (x==null || x.length==0) continue;
				  if (fmt.length!=0){
					  fmt+=sep;
				  }
				  fmt+=x;
			  }
		}
		switch(this.settings.dateOrder){
			case FTM_X3DATE_DMY:
				append(day,month,year);
			break;
			case FTM_X3DATE_YMD:
				append(year,month,day);
				break;
			default:
				append(month,day,year);
			break;		
		}
		return fmt;
	},
	defaultfDateFmt: function(){
		return new CvgFormat("DZ:" + this._buildDateFormat('DD','MM','YYYY'));		
	},
	typeDate: function(){
		var ord=this.settings.dateOrder;
		ord = ord == FTM_X3DATE_MDY ? 'MDY' : ord == FTM_X3DATE_DMY ? 'DMY' :  ord == FTM_X3DATE_YMD ? 'YMD' : null;
		if (ord) return ord;
		throw new Error("unsupported date order : " + ord) ;		
	}
});
