"use strict";
var helpers = require('syracuse-core/lib/helpers');
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var date = require('syracuse-core/lib/types/date');
var formatter = require('syracuse-x3/lib/formatter/format');
var Cvg = require("syracuse-x3/lib/convergence/model/Cvg").Cvg;

var CvgFormatter = exports.CvgFormatter = helpers.defineClass(function(settings) {
	var self = this;
	// For unit tests
	if (settings && settings.dateOrder != null)
		this.dateOrder = settings.dateOrder;
	this.settings = settings || {};
}, null, {
	razModifications: function() {
		// TODO: reset dynamic formats and month names
	},
	setNewDynamicFormat: function(type, subtype, complement) {
		//throw new Error("dynamic format NIY " + arguments);
	},
	isValid: function() {
		return true;
	},
	testerParse: function(format, val) { // temp hack for unit test
		return formatter.parse(this.settings, format.format, val).toString();
	},
	formatField: function(format, value, raw, isEdit) {
		if (!format) return "" + value;

		if (nodeconfig.config.x3fusion.doNotUseJsFormatter) {
			if (format && format.format[0] === 'D' && value) {
				// quick hack to handle dates
				return value.substring(6) + "/" + value.substring(4, 6) + "/" + value.substring(0, 4);
			}
			// quick hacks to handle CvgDecimal "0"
			if (value === "0" && format && format.format.substring(0, 3) === "N+z") return "";
			if (value === "0" && format && format.format.substring(0, 2) === "Nz") return "";
			return "" + value;
		}
		
		var fmt = this.transform(format.format);
		
		if (isEdit) {
			var fmtEdit = this.getFormatEdit(fmt);
			//console.error("Translate edit format from '"+fmt+"' to '"+fmtEdit+"'");
			fmt = fmtEdit;
		}

//		console.log("dateOrder="+this.dateOrder);
//		console.log("format="+format);
//		console.log("value="+value);
//		console.log("raw="+raw);
		
		switch (fmt[0]) {
		case 'D':

			var y, m, d, str;
			var parts = value.split(/[^\d]/);
			// ignore raw if parts.length == 2, so that 20/02 gets handled as DD/MM when raw is true
			if ((raw && parts.length !== 2) || parseInt(this.dateOrder, 10) === Cvg.FTM_X3DATE_YMD) {
				
				
				if (parts.length > 1) {
					y = parseInt(parts[0] || '0', 10);
					m = parseInt(parts[1] || '0', 10);
					d = parseInt(parts[2] || '0', 10);
				} else {
					if (value.length <= 4) {
						y = parseInt(value || '0', 10);
						m = 0;
						d = 0;
						if (y < 1900 || y >= 2200) {
							// reinterpret as YYMM if year does not look valid
							m = y % 100;
							y = Math.floor(y / 100);
						}
					} else if (value.length <= 6) {
						y = parseInt(value.substring(0, 2) || '0', 10);
						m = parseInt(value.substring(2, 4) || '0', 10);
						d = parseInt(value.substring(4) || '0', 10);
					} else {
						y = parseInt(value.substring(0, 4) || '0', 10);
						m = parseInt(value.substring(4, 6) || '0', 10);
						d = parseInt(value.substring(6) || '0', 10);
					}

					
				}
			} else {
//				console.log("parts.length= "+ parts.length);
//				console.log("parts[0]= "+ parts[0]);
//				console.log("parts[1]= "+ parts[1]);
//				console.log("parts[2]= "+ parts[2]);
				if (parts.length > 1) {
					d = parseInt(parts[0] || '0', 10);
					m = parseInt(parts[1] || '0', 10);
					y = parts[2] != null ? parseInt(parts[2], 10) : new Date().getFullYear();
				} else {
					if (value.length <= 4) {
						// weird: interpret as MM/YY rather than DD/MM or MM/DD
						d = 0;
						m = parseInt(value.substring(0, 2) || '0', 10);
						y = parseInt(value.substring(2, 4) || '0', 10);
					} else {
						d = parseInt(value.substring(0, 2) || '0', 10);
						m = parseInt(value.substring(2, 4) || '0', 10);
						y = parseInt(value.substring(4) || '0', 10);
					}
				}
				if (parseInt(this.dateOrder, 10) === Cvg.FTM_X3DATE_MDY && d !== 0) { // d test to avoid swap in valude.length <= 4 case
					var tmp = d;
					d = m;
					m = tmp;
				}
			}
			if (y < 100 && value.length > 0) {
				var century = Math.floor(new Date().getFullYear() / 100) * 100;
				y = century + y;
				if (y - 100 >= this.settings.datePivot) y -= 100;
			}
//			console.log("y: "+y);
//			console.log("m: "+m);
//			console.log("d: "+d);
			if (y === 1599 && m === 12 && d === 31) value = date.make(0, 0, 0);
			else value = date.make(y, m, d);
			break;
		case 'N':
			if (!raw) {
				if (this.settings.thousandsChar) value = value.split(this.settings.thousandsChar).join('');
				if (this.settings.decimalChar !== '.') value = value.split(this.settings.decimalChar).join('.');
			}
			break;
		}

		var result = formatter.format(this.settings, fmt, value);
		return result;
	},
	unformatField: function(format, val) {
		
		function zeroPad(n, len) {
			return n.toString().length > 0 ? (new Array(len + 1).join('0') + n).slice(-len) : "";
		}
		var fmt = this.transform(format.format);
		switch (fmt[0]) {
			case 'K':
				return formatter.parse(this.settings, fmt, val).toString().replace(/\s+$/, '');
			case 'D':
				var date = formatter.parse(this.settings, fmt, val);
//				console.log("True date: "+date.toString());
				var res = zeroPad(date.year, 4) + zeroPad(date.month, 2) + zeroPad(date.day, 2);
//				console.log("RES="+res);
				return res;
			case 'N':
				if (val.length === 0) {
					return "";
				} else {
					return formatter.parse(this.settings, fmt, val).toString();
				}
			default:
				return formatter.parse(this.settings, fmt, val).toString();
		}
		
	},
	inputGetFocusInValue: function(format, val, raw) {
		
		//console.error("inputGetFocusInValue:\n"+JSON.stringify({format:format,val:val,raw:raw},null,2));
		
		var formatted = this.formatField(format, val, raw, true);
		//console.log("formatted:\n"+JSON.stringify(formatted,null,2));

		return formatted;

	},
	inputGetFocusOutValue: function(format, val, raw) {
		
		
		//console.error("inputGetFocusOutValue:\n"+JSON.stringify({format:format,val:val,raw:raw},null,2));
		var tmp = this.formatField(format, val, false);
		// Deformate pour obtenir une valeur X3
		if (tmp != null) {
			tmp = this.unformatField(format, tmp, true);
		}
		// Formate la valeur X3 avec le format d'affichage
		var unformatted = this.formatField(format, tmp, true);
		

		//console.log("unformatted:\n"+JSON.stringify(unformatted,null,2));
		return unformatted;
	},
	transform: function(format) {
		// National formats
		// DD1 : format$("DD1",[1/1/1994]) -> "01/01"
		// DD2 : format$("DD2",[1/1/1994]) -> "01/01/94"
		// DD3 : format$("DD3",[1/1/1994]) -> "01 Janvier 1994 14:38"
		// DD4 : format$("DD4",[1/1/1994]) -> "01 Janvier 1994 14:38:21"
		if (format.length === 5 && format.indexOf('D:DD') === 0){
			var type = format[4];
			var day = 'DD';
			var month = type === '1' || type === '2' ? 'MM' : 'MMMMM';
			var year = type !== '1' ? type === '2' ? 'YY' : "YYYY" : '';
			var s = this.buildDateFormat(day, month, year);
			return "D:" + s;
		}
		return format;
	},
	getFormatEdit: function(fmt) {
		var parts = fmt.split(':');
		var type = parts[0][0];
		switch(type) {
			case 'N':
			case 'K':
				return type + 'z:' + (parts[1] || '').replace(/\[[^\]]*\]|\>/g,'');
			case 'D':
				var descriptors = (parts[1] || '').replace(/\[[^\]]*\]|\>/g,'');
				var countD = descriptors.split("D").length - 1;
				var countM = descriptors.split("M").length - 1;
				var countY = descriptors.split("Y").length - 1;
				var day = countD !== 0 ? 'DD' : '';
				var month = countM !== 0 ? 'MM' : '';
				var year = countY !== 0 ? (countY === 4 ? 'YYYY' : 'YY') : '';
				var s = type + 'z:' + this.buildDateFormat(day, month, year);
				return s;
			default:
				return fmt
		}
	},
	buildDateFormat: function(day, month, year) {
		var s = '';
		var sep = "[" + this.dateSep + "]";
		if (parseInt(this.dateOrder, 10) === Cvg.FTM_X3DATE_DMY) {
			s += day + sep + month;
			if (year.length > 0) {
				s += sep + year;
			}
		} else if (parseInt(this.dateOrder, 10) === Cvg.FTM_X3DATE_YMD) {
			s += year + sep + month + sep + day;
		} else {
			s += month + sep + day;
			if (year.length > 0) {
				s += sep + year;
			}
		}
		return s;
	}
});