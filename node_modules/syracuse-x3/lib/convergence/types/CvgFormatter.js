"use strict";
var helpers = require('syracuse-core/lib/helpers');
var date = require('syracuse-core/lib/types/date');
var formatter = require('syracuse-x3/lib/formatter/format');
var CvgFormat = require('syracuse-x3/lib/convergence/model/CvgFormat').CvgFormat;
var template = {
	decimalSep: '.',
	dateOrder: 0,
	thousandSep: ',',
	dateSep: '/',
	datePivot: 1957,
	timeSep: ':',
	vOn: true,
	zOn: true,
	dynFormats: {},
	// Return original value if format is not valid - #553 enabled by default
	// #553 - skipBadFormat set to true by default - see comments in format._js
	skipBadFormat: true,
	// #553 - skipBadDynFmt works only if skipBadFormat=true
	// --> false  : an error is thrown if dynamic format is not found
	// --> true   : no error if dynamic format is not found - return initial value
	skipBadDynFmt: true,
	tracer: null
};

var FTM_X3DATE_MDY = 0;
var FTM_X3DATE_DMY = 1;
var FTM_X3DATE_YMD = 2;

function toUnicode(char) {
	var res = char.charCodeAt(0).toString(16).toUpperCase();
	while (res.length < 4) res = '0' + res;
	return '\\u' + res;
}

var CvgFormatter = exports.CvgFormatter = helpers.defineClass(function(values) {
	this.settings = {};
	for (var p in template) {
		this.settings[p] = values == null || values[p] == null ? template[p] : values[p];
	}
}, null, {
	// convergence client - called at sessionSettings
	setDatePivot: function(v) {
		v = parseInt(v, 10);
		if (!isNaN(v)) this.settings.datePivot = v;
	},
	razModifications: function() {
		// TODO: reset dynamic formats and month names
	},
	addDynamicFormat: function(dyn) {
		if (!this.settings.dynFormats) this.settings.dynFormats = {};
		this.settings.dynFormats[dyn.type] = {
			subType: dyn.subType,
			complement: dyn.complement
		};
	},
	isValid: function() {
		return true;
	},
	formatField: function(format, value, raw, strict) {
		if (!format) return "" + value;
		if (value == null) value = "";
		else if (typeof value !== 'string') value = value.toString();
		// #553
		var strValue = value;
		format = this.getRealFormat(format);
		var fmt = format.format,
			strict = strict === true;
		switch (fmt[0]) {
			case 'D':
				value = value.trim();
				var dat = {
					d: 0,
					m: 0,
					y: 0
				};
				// #1208 - strict format
				var parts = value.split(strict ? new RegExp(toUnicode(this.settings.dateSep)) : /[^\d]/);
				if (strict) {
					parts.forEach(function(e) {
						if (isNaN(e)) throw new Error("Number expected");
					});
				}
				if (raw) {
					// value comes from X3 with format YYYYMMDD - accept also YYMMDD
					if (parts.length != 1) throw new Error("Bad x3 date[" + value + "] - No separator expected - format YYYYMMDD");
					if (value.length == 0) {
						dat.y = 1599;
						dat.m = 12;
						dat.d = 31;
					} else if (value.length >= 6) {
						var start = 0;
						dat.y = parseInt(value.substring(start, start += value.length - 4) || '0', 10);
						dat.m = parseInt(value.substring(start, start += 2) || '0', 10);
						dat.d = parseInt(value.substring(start, start += 2) || '0', 10);
						if (dat.y == dat.m && dat.m == dat.d && dat.d == 0) {
							dat.y = 1599;
							dat.m = 12;
							dat.d = 31;
						}
					} else {
						throw new Error("Bad x3 date[" + value + "] - 8 chars expected - format YYYYMMDD");;
					}
				} else {
					// #553
					var rightPart = fmt.substr(fmt.indexOf(':') + 1);
					if (rightPart && rightPart.length > 0) {
						// Remove comments
						rightPart = rightPart.replace(/[\x5B][^\x5D]*[\x5D]+/g, "");
					} else {
						if (this.settings.skipBadFormat === true) return str;
						throw new Error("Bad date format - '" + fmt + "'");
					}
					// not raw value -> dateOrder is given by format - Try to parse value to read y:m:d according to format
					if (parts.length > 1) {
						// raw value with sperators            		
						var i = 0;
						rightPart.replace(/(Y+|M+|D+)/g, function(p1) {
							dat[p1[0].toLowerCase()] = parseInt(parts[i] || '0', 10);
							i++;
						});
						if (i > 0 && dat.y == 0) dat.y = new Date().getFullYear();
					} else {
						// raw value without sperators
						var pos = 0,
							id, l;
						rightPart.replace(/(Y+|M+|D+)/g, function(p1) {
							id = p1[0].toLowerCase();
							l = id == 'y' ? value.length > 6 ? 4 : p1.length : 2;
							dat[id] = parseInt(value.substr(pos, l) || '0', 10);
							pos += l;
						});
						// Very special case - DMY or MDY - year with more than 4 digits - Read until end of string 
						// See unit test - testOptions('D:DD[/]MM[/]YYYY', false, '011000002', '01/10/2002');
						if (value.length > 8 & id == 'y') dat.y = parseInt(value.substr(pos - l) || '0', 10);
					}
				}
				if (dat.y === 1599 && dat.m === 12 && dat.d === 31) {
					value = date.make(0, 0, 0);
				} else {
					dat.y = this._calcCentury(dat.y, value, fmt);
					value = date.make(dat.y, dat.m, dat.d);
				}
				break;
			case 'N':
				if (this.settings.thousandSep) value = value.split(this.settings.thousandSep).join('');
				if (value.length > 0) {
					value = value.replace(/,/g, '.');
				}
				break;
		}
		var result;
		try {
			// strict check number of digits in decimal part and size overflow and throws an error - false by default		
			this.settings.strict = strict;
			result = formatter.format(this.settings, fmt, value);
			// #553 - if format returns the DateTime value that means a bad format error with skipBadFormat == true
			// -> returns original string value (for date format method is not abme to retrun th string value)
			if (fmt[0] === 'D' && result === value) return strValue;
		} finally {
			this.settings.strict = false;
		}
		if (format.countryDate && format.textMonth) {
			// DD3,DD4 formats - remove whitespaces after month's name
			if (format.textMonth) result = result.replace(/\s+/g, ' ');
			// Add time after year
			var d = new Date();
			result += " " + d.getHours() + ":" + d.getMinutes();
			if (format.dateType == '4') result += ":" + d.getSeconds();
		}
		return result;
	},
	unformatField: function(format, val, check) {
		function zeroPad(n, len) {
			return n.toString().length > 0 ? (new Array(len + 1).join('0') + n).slice(-len) : "";
		}
		try {
			// strict check number of digits in decimal part and size overflow and throws an error - false by default	
			this.settings.strict = check;
			format = this.getRealFormat(format);
			var fmt = format.format,
				result;
			switch (fmt[0]) {
				case 'K':
					result = formatter.parse(this.settings, fmt, val).toString().replace(/\s+$/, '');
					break;
				case 'D':
					if (val != null) val = (val.toString()).trim();
					var dat = formatter.parse(this.settings, fmt, val);
					// #553 - see comments in formatField - if bad format error return original value
					if (dat === val) return val;
					// Check if it's date null
					if (dat.year !== 1599 || dat.month !== 12 || dat.day !== 31) {
						var realYear = this._calcCentury(dat.year, val, fmt);
						if (dat.year !== realYear) dat = date.make(realYear, dat.month, dat.day);
						if (check === true) this._checkDate(dat, val);
					}
					result = zeroPad(dat.year, 4) + zeroPad(dat.month, 2) + zeroPad(dat.day, 2);
					break;
				case 'N':
					if (val.length === 0) {
						result = "";
					} else {
						if (this.settings.thousandSep) val = val.split(this.settings.thousandSep).join('');
						if (this.settings.decimalSep === '.')
							val = val.replace(/,/g, '.');
						else
							val = val.replace(/\./g, ',');
						result = formatter.parse(this.settings, fmt, val).toString();
					}
					break;
				default:
					result = formatter.parse(this.settings, fmt, val).toString();
					break;
			}
		} finally {
			this.settings.strict = false;
		}
		return result;

	},
	formatEdit: function(format, val, raw) {
		var rawVal = raw ? val : this.unformatField(format, val);
		var wResult = this.formatField(new CvgFormat(this.getFormatEdit(format.format)), rawVal, true, false);
		return wResult;
	},
	_checkDate: function(dat, val) {
		var d = new Date(dat.year, dat.month - 1, dat.day);
		if (d.getFullYear() != dat.year || (d.getMonth() != dat.month - 1) || d.getDate() != dat.day) {
			throw new Error("Date [" + dat + "] is not valid");
		}
	},
	_readDigit: function(dat, x, t, y4Digits, dateRef) {
		if (t == 'M' || t == 'D') {
			dat[t] = parseInt(x.substring(0, 2), 10);
			if (isNaN(dat[t])) {
				if (dateRef && dateRef[t] != null) dat[t] = dateRef[t];
				else throw new Error((t == 'M' ? "Month" : "Day") + " expected");
			}
			return x.substr(2);
		} else {
			dat[t] = parseInt(x.substring(0, y4Digits ? 4 : 2), 10);
			if (isNaN(dat[t])) {
				if (dateRef && dateRef[t] != null) dat[t] = dateRef[t];
				else throw new Error("year expected");
			}
			return x.substr(y4Digits ? 4 : 2);
		}
	},
	// Parse string str input by user and return a date - srvVal is the default date
	// date is parsed according to current this.settings.dateOrder
	_parseEditDate: function(fmt, str, srvVal, y4Digits) {
		fmt = fmt ? fmt.substr(fmt.indexOf(':') + 1) : null;
		// Remove comments
		if (fmt) fmt = fmt.replace(/[\x5B][^\x5D]*[\x5D]+/g, "");
		// #553 - Check bad format after removing comments
		if (fmt == null || fmt.length == 0 || /[^DMYhms]/.test(fmt)) {
			if (this.settings.skipBadFormat === true) throw new Error("Bad date format - '" + fmt + "'");
			return str;
		}
		// get date order DMY/MDY/YMD
		var ord = '';
		fmt = fmt.replace(/(Y+|M+|D+)/g, function(p1) {
			ord += p1[0];
		});
		var datePivot = this.settings.datePivot;
		srvVal = srvVal == null ? '' : srvVal.replace(/[^\d]/g, '');
		var dateRef;
		if (srvVal.length == 8) {
			dateRef = {
				'D': parseInt(srvVal.substr(6, 2), 10),
				'M': parseInt(srvVal.substr(4, 2), 10),
				'Y': parseInt(srvVal.substr(0, 4), 10),
			};
		}
		if (!str) return dateRef;
		var dat = {
			D: null,
			M: null,
			Y: null
		};
		str = str.trim();
		// We accept \s\/-._ as separator
		var split = str.split(/[\x2E\x5F\s\\/-]+/g);
		if (split.length == 1) {
			var tmp = str,
				i = 0,
				ordl = ord.length;
			for (i = 0; i < ordl; i++) {
				tmp = this._readDigit(dat, tmp, ord.charAt(i), str.length > 6, dateRef);
			}
			if (tmp.length != 0) {
				if (i > 3 || isNaN(tmp)) throw new Error("Bad input data");
			}
		} else {
			var tmp = ord;
			split.forEach(function(v, i) {
				if (v.length > 0 && tmp.length != 0) {
					// Accept only digits
					var n = Math.floor(v);
					if (isNaN(n)) throw new Error("Bad input data");
					dat[tmp[0]] = n;
					tmp = tmp.substr(1);
				} else if (v.length != 0) {
					// Error if it remains NaN (5/6/h) data or more than 3 part (5/6/8/9)
					if (isNaN(v) || i > 2) throw new Error("Bad input data");
				}
			});
		}
		if (!dateRef) {
			// fill missing D/M/Y properties even if no present in format
			// Used to calculate a valid x3Date after parsing
			// In convergence client srvVal is alwas set with serverValue
			var d = new Date();
			dateRef = {
				'D': d.getDay(),
				'M': d.getMonth() - 1,
				'Y': d.getFullYear()
			};
		}
		for (var p in dat) {
			if (dat[p] == null || isNaN(dat[p])) dat[p] = dateRef[p];
		}
		// #1218 -JMK - we accept 2 or 4 digits dates only
		if ((dat.Y >= 100 && dat.Y <= 999) || dat.Y > 9999) throw new Error("Bad year number");
		// Date X3
		var century = (Math.floor(new Date().getFullYear() / 100) - 1) * 100;
		dat.Y = +dat.Y < 100 ? century + dat.Y < datePivot ? (century + 100) + dat.Y : century + dat.Y : dat.Y;
		// Validate full date only	
		if (dat.D <= 0 || dat.D > 31) throw new Error("Bad day number");
		if (dat.M <= 0 || dat.M > 12) throw new Error("Bad month number");
		if (ord.length == 3) this._checkDate(date.make(dat.Y, dat.M, dat.D), str);
		var res = '';
		res += "" + dat.Y;
		res += dat.M < 10 ? "0" + dat.M : dat.M;
		res += dat.D < 10 ? "0" + dat.D : dat.D;
		return res;
	},
	formatEditToDisplay: function(format, val, srvVal) {
		var editFmt = this.getFormatEdit(format.format);
		if (val == null || val.length == 0) {
			// Format with X3 format
			return this.formatField(format, val, false);
		}
		if (format.format[0] == 'D') {
			val = this._parseEditDate(editFmt, val, srvVal);
		} else {
			try {
				//  Try std Format
				val = this.unformatField(format, val, true);
			} catch (e) {
				//  Try edit Format
				var editFmt = new CvgFormat(editFmt);
				val = this.unformatField(editFmt, this.formatField(editFmt, val, false, true), true);
			}
		}
		val = this.formatField(format, val, true, true);
		return val;
	},
	_calcCentury: function(y, value, fmt) {
		if ((y < 100) && value.length > 0) {
			var century = Math.floor(new Date().getFullYear() / 100) * 100;
			y = century + y;
			if (y - 100 >= this.settings.datePivot) y -= 100;
		} else if (y.toString().length === 4 && fmt.replace(/[^Y]*/g, "").length === 2) {
			var century = Math.floor(new Date().getFullYear() / 100) * 100;
			y = century + parseInt(y.toString().substring(2), 10);
			if (y - 100 >= this.settings.datePivot) y -= 100;
		}
		return y;
	},
	getRealFormat: function(format) {
		// National formats
		// DD1 : format$("DD1",[1/1/1994]) -> "01/01"
		// DD2 : format$("DD2",[1/1/1994]) -> "01/01/94"
		// DD3 : format$("DD3",[1/1/1994]) -> "01 Janvier 1994 14:38"
		// DD4 : format$("DD4",[1/1/1994]) -> "01 Janvier 1994 14:38:21"
		var res = {
			format: format.format,
			countryDate: format.format.search(/D:DD[1-4]$/) == 0
		};
		if (res.countryDate) {
			var type = res.dateType = res.format[4];
			var day = 'DD';
			res.textMonth = type === '3' || type === '4';
			// We take 20 for month length an remove whitespaces after formatting
			var month = res.textMonth ? 'MMMMMMMMMMMMMMMMMMMM' : 'MM';
			var year = type === '1' ? '' : type === '2' ? 'YY' : "YYYY";
			var s = this._buildDateFormat(day, month, year);
			res.format = "D:" + s;
		}
		return res;
	},
	_cleanFormat: function(fmt, edit) {
		if (!fmt) return "";
		var p = fmt.indexOf(':');
		if (p == -1) throw new Error("Bad format");
		var res = {};
		res.left = fmt.substring(0, p);
		res.right = fmt.substr(p + 1);
		if (res.left.length == 0 || res.right.length == 0) throw new Error("Bad format");
		res.right = res.right.replace(/\[[^\]]*\]/g, '');
		if (res.left[0] == 'D') {
			res.month = res.day = res.year = null;
			res.right.replace(/(M+)|(D+)|(Y+)/g, function(p1) {
				if (p1.length == 0) return "";
				var x = p1[0];
				if (x == "D") res.day = edit ? "DD" : p1;
				if (x == "M") res.month = edit ? "MM" : p1;
				if (x == "Y") res.year = edit ? p1.length > 2 ? "YYYY" : "YY" : p1;
				return "";
			});
		}
		return res;
	},
	getFormatEdit: function(fmt, noFail) {
		try {
			var f = this._cleanFormat(fmt, true);
			var type = f.left[0];
			switch (type) {
				case 'N':
				case 'K':
					return type + 'z:' + f.right;
				case 'D':
					var s = type + 'z:' + this._buildDateFormat(f.day, f.month, f.year);
					return s;
				default:
					return fmt;
			}
		} catch (e) {
			if (noFail === true) return fmt;
			e.message += e.message + " - fmt[" + fmt + "]";
			throw (e);
		}
	},
	_buildDateFormat: function(day, month, year) {
		var fmt = '';
		var sep = "[" + (month != null && month.length > 2 ? ' ' : this.settings.dateSep) + "]";

		function append() {
			for (var i = 0; i < arguments.length; i++) {
				var x = arguments[i];
				if (x == null || x.length == 0) continue;
				if (fmt.length != 0) {
					fmt += sep;
				}
				fmt += x;
			}
		}
		switch (this.settings.dateOrder) {
			case FTM_X3DATE_DMY:
				append(day, month, year);
				break;
			case FTM_X3DATE_YMD:
				append(year, month, day);
				break;
			default:
				append(month, day, year);
				break;
		}
		return fmt;
	},
	defaultfDateFmt: function() {
		return new CvgFormat("DZ:" + this._buildDateFormat('DD', 'MM', 'YYYY'));
	},
	typeDate: function() {
		var ord = this.settings.dateOrder;
		ord = ord == FTM_X3DATE_MDY ? 'MDY' : ord == FTM_X3DATE_DMY ? 'DMY' : ord == FTM_X3DATE_YMD ? 'YMD' : null;
		if (ord) return ord;
		throw new Error("unsupported date order : " + ord);
	}
});