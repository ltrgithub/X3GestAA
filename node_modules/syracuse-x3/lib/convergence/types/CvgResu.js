"use strict";
var helpers = require('syracuse-core/lib/helpers');
var CvgDate = require('syracuse-x3/lib/convergence/types/CvgDate').CvgDate;
var CvgDecimal = require('syracuse-x3/lib/convergence/types/CvgDecimal').CvgDecimal;
/**
 * "Resu" contenu dans un argument d'un neoud.
 * <p>
 * Le res_u est compose par 2 octets donnant le type et la longueur, suivis de
 * la valeur.
 * <ul>
 * <li>0 indique un résu nul. le 2ieme octet est nul.
 * <li>44 indique un "libelle". le 2ieme octet est nul, le 3ieme indique la
 * valeur
 * <li>45 indique un entier court, le 2ime octet est nul et 3&4 donne la valeur
 * (Little Endian)
 * <li>46 indique un entier long, le 2 est nul, la valeur est sur 4 octets
 * <li>47 indique un CvgDecimal. le 2 indique la lg de mantisse</li>
 * <li>51 indique une date (un entier sur 3 octets),</li>
 * <ul>
 * <li>le 2 est normalement a 3</li>
 * <li>suit le nombre de jours depuis le 1er janvier 1600.</li>
 * </ul>
 * <li>122 indique une chaine unicode:</li>
 * <ul>
 * <li>les 2ème et 3 ème octets donnent la longueur du buffer à suivre (2 + n)</li>
 * <li>les 4ème et 5 ème octets donnent le nombre de caracteres (0 à n)</li>
 * <li>suivent n caractères codés en UTF-8</li>
 * </ul>
 * </ul>
 *
 * <pre>
 *   (moteur) : 44      45       46       47         51    122     125       124
 *   (java)   : Byte    Short    Integer  BigDecimal Date  String  CClob     byte[]
 *   (résu)   : LIB     SHORT    INT      CvgDecimal        DATE  STRU.   CLOB      BLOB
 *   (L4G)    : Libelle Shortint Integer  Decimal    Date  Char    Clobfile  Blobfile
 * </pre>
 *
 * <li>X3TYP_BLOB = 0x7C; //124; (lg sur 4 octets +
 * binaire)
 * <li>X3TYP_CLOB = 0x7D; //125; (lg sur 4 octets +
 * UTF8)
 * <li>X3TYP_DATE = 0x33; //51;
 * <li>X3TYP_BCD = 0x2F; //47;
 * <li>X3TYP_INT = 0x2E; //46;
 * <li>X3TYP_LIBELLE = 0x2C; //44;
 * <li>X3TYP_NULL = 0x00; //0;
 * <li>X3TYP_SHORT = 0x2D; //45;
 * <li>X3TYP_STRU = 0x7A; //122;
 * <li>X3TYP_UNKNOWN = -1;
 *
 * @author Adonix Grenoble
 * @version 140_000
 */

var RAWS_TYPES = [
	['NULL', 'NULL', 0x00], // 0
	['LIB', 'LIB', 0x2c], // 44
	['SHORT', 'SHORT', 0x2d], // 45
	['INT', 'INT', 0x2e], // 46
	['DCB', 'DCB', 0x2f], // 47
	['DECI', 'DCB', 0x2f], // 47
	['FLOT', 'DCB', 0x2f], // 47
	['STRU', 'STRU', 0x7a], // 122
	['DATE', 'DATE', 0x33], // 51
	['BLOB', 'BLOB', 0x7c], // 124 (lg sur 4 octets + binaire)
	['CLOB', 'CLOB', 0x7d] // 125 (lg sur 4 octets + UTF8)
];

//TAG: {
//  "NULL": 0,
//  "LIB": 44,
//  "SHORT": 45,
//  "INT": 46,
//  "DCB": 47,
//  "STRU": 122,
//  "DATE": 51,
//  "BLOB": 124,
//  "CLOB": 125
//}
var TAG = RAWS_TYPES.reduce(function(types, desc) {
	types[desc[1]] = desc[2];
	return types;
}, {});
exports.TAG = TAG;

//TDO: {
//  "NULL": 0,
//  "LIB": 1,
//  "SHORT": 2,
//  "INT": 3,
//  "DCB": 4,
//  "DECI": 5,
//  "FLOT": 6,
//  "STRU": 7,
//  "DATE": 8,
//  "BLOB": 9,
//  "CLOB": 10
//}
var TDO = RAWS_TYPES.reduce(function(types, desc, index) {
	types[desc[0]] = index;
	return types;
}, {});
exports.TDO = TDO;

//TAG_LIB: {
//	"0": "NULL",
//	"44": "LIB",
//	"45": "SHORT",
//	"46": "INT",
//	"47": "DCB",
//	"51": "DATE",
//	"122": "STRU",
//	"124": "BLOB",
//	"125": "CLOB"
//}
var TAG_LIB = RAWS_TYPES.reduce(function(types, desc, index) {
	types[desc[2]] = desc[1];
	return types;
}, {});
exports.TAG_LIB = TAG_LIB;

//TDO_LIB: {
//	"0": "NULL",
//	"1": "LIB",
//	"2": "SHORT",
//	"3": "INT",
//	"4": "DCB",
//	"5": "DECI",
//	"6": "FLOT",
//	"7": "STRU",
//	"8": "DATE",
//	"9": "BLOB",
//	"10": "CLOB"
//}
var TDO_LIB = RAWS_TYPES.reduce(function(types, desc, index) {
	types[index] = desc[0];
	return types;
}, {});
exports.TDO_LIB = TDO_LIB;

function getBufBytes(tag, bytes) {
	var buf = new Buffer(6 + bytes.length);
	buf[0] = tag;
	buf[1] = 0;
	buf.writeInt32BE(bytes.length, 2);
	bytes.copy(buf, 6);
	return buf;
}

var CvgResu = helpers.defineClass(function(type, val) {
	this.type = type;
	this.value = val;
}, null, {
	toString: function() {
		return JSON.stringify(this);
	},
	equals: function(v) {
		return v && v.type === this.type && v.value === this.value;
	},
	isNull: function() {
		return this.type === TDO.NULL;
	},
	isDate: function() {
		return this.type === TDO.DATE;
	},
	isBCD: function() {
		return this.type === TDO.DCB;
	},
	isInt: function() {
		return this.type === TDO.INT;
	},
	isShort: function() {
		return this.type === TDO.SHORT;
	},
	isDateNull: function() {
		return this.isDate() && this.value === CvgDate.DATE_ZERO;
	},
	isNum: function() {
		return this.isBCD() || this.isInt() || this.isShort();
	},
	getBytes: function() {
		var val = this.value;
		var buf, i, ch;
		switch (this.type) {
			case TDO.STRU:
				buf = new Buffer(2 + 2 * (val.length + 1));
				buf[0] = TAG.STRU;
				buf[1] = val.length;
				var i, ch;
				for (i = 0; i < val.length; i++) {
					ch = val.charCodeAt(i);
					buf[2 + 2 * i] = (ch >> 8) & 0xff;
					buf[2 + 2 * i + 1] = ch & 0xff;
				}
				buf[2 + 2 * val.length] = 0;
				buf[2 + 2 * val.length + 1] = 0;
				return buf;
			case TDO.NULL:
				return new Buffer([TAG.NULL, 0]);
			case TDO.SHORT:
				return new Buffer([TAG.SHORT, 0, (val >> 8) & 0xff, val & 0xff]);
			case TDO.INT:
			case TDO.LIB:
				// MENLOC like int
				return new Buffer([TAG.INT, 0, (val >> 24) & 0xff, (val >> 16) & 0xff, //
					(val >> 8) & 0xff, val & 0xff
				]);
			case TDO.DECI:
			case TDO.FLOT:
			case TDO.DCB:
				var bufDcb = CvgDecimal.toBytes(val);
				buf = new Buffer(2);
				buf[0] = 0x2f;
				buf[1] = bufDcb.length;
				return Buffer.concat([buf, bufDcb], 19);
			case TDO.DATE:
				var days = CvgDate.toDays(val);
				return new Buffer([TAG.DATE, 3, (days >>> 16) & 0xff, (days >>> 8) & 0xff, days & 0xff]);
			case TDO.BLOB:
				return getBufBytes(TAG.BLOB, val);
			case TDO.CLOB:
				return getBufBytes(TAG.CLOB, new Buffer(val, 'utf8'));
			default:
				throw new Error("NIY resu to bytes: " + this.type);
		}
	},
	clone: function() {
		return new CvgResu(this.type, this.value);
	}
});
exports.CvgResu = CvgResu;
CvgResu.fromAction = function(type, str) {
	switch (type) {
		case TDO.NULL:
			return new CvgResu(type, null);
		case TDO.SHORT:
		case TDO.INT:
		case TDO.LIB:
			return new CvgResu(type, parseInt(str, 10));
		case TDO.DCB:
		case TDO.STRU:
		case TDO.DATE:
			return new CvgResu(type, str);
		case TDO.BLOB:
			// I'm assuming base64 encoding
			return new CvgResu(type, new Buffer(str, 'base64'));
		case TDO.CLOB:
			return new CvgResu(type, str);
		default:
			throw new Error("bad resu type: " + type);
	}
};

CvgResu.x3TypeToString = function(x3type) {
	return TAG_LIB[x3type];
};

CvgResu.fromX3Type = function(x3type, str) {
	switch (x3type) {
		case TAG.NULL:
			return CvgResu.fromAction(TDO.NULL, str);
		case TAG.SHORT:
			return CvgResu.fromAction(TDO.SHORT, str);
		case TAG.INT:
			return CvgResu.fromAction(TDO.INT, str);
		case TAG.LIBELLE:
			return CvgResu.fromAction(TDO.LIB, str);
		case TAG.BCD:
			return CvgResu.fromAction(TDO.BCD, str);
		case TAG.DCB:
			return CvgResu.fromAction(TDO.DCB, str);
		case TAG.STRU:
			return CvgResu.fromAction(TDO.STRU, str);
		case TAG.DATE:
			return CvgResu.fromAction(TDO.DATE, str);
		case TAG.BLOB:
			return CvgResu.fromAction(TDO.BLOB, str);
		case TAG.CLOB:
			return CvgResu.fromAction(TDO.CLOB, str);
		default:
			throw new Error("can't find type for value " + x3type);
	}
};

exports.CvgResu = CvgResu;