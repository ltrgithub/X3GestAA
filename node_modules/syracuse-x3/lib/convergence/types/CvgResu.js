"use strict";
var helpers = require('syracuse-core/lib/helpers');
var CvgDate = require('syracuse-x3/lib/convergence/types/CvgDate').CvgDate;
var CvgDecimal = require('syracuse-x3/lib/convergence/types/CvgDecimal').CvgDecimal;
/**
 * "Resu" contenu dans un argument d'un neoud.
 * <p>
 * Le res_u est compose par 2 octets donnant le type et la longueur, suivis de
 * la valeur.
 * <ul>
 * <li>0 indique un résu nul. le 2ieme octet est nul.
 * <li>44 indique un "libelle". le 2ieme octet est nul, le 3ieme indique la
 * valeur
 * <li>45 indique un entier court, le 2ime octet est nul et 3&4 donne la valeur
 * (Little Endian)
 * <li>46 indique un entier long, le 2 est nul, la valeur est sur 4 octets
 * <li>47 indique un CvgDecimal. le 2 indique la lg de mantisse</li>
 * <li>51 indique une date (un entier sur 3 octets),</li>
 * <ul>
 * <li>le 2 est normalement a 3</li>
 * <li>suit le nombre de jours depuis le 1er janvier 1600.</li>
 * </ul>
 * <li>122 indique une chaine unicode:</li>
 * <ul>
 * <li>les 2ème et 3 ème octets donnent la longueur du buffer à suivre (2 + n)</li>
 * <li>les 4ème et 5 ème octets donnent le nombre de caracteres (0 à n)</li>
 * <li>suivent n caractères codés en UTF-8</li>
 * </ul>
 * </ul>
 * 
 * <pre>
 *   (moteur) : 44      45       46       47         51    122     125       124
 *   (java)   : Byte    Short    Integer  BigDecimal Date  String  CClob     byte[]
 *   (résu)   : LIB     SHORT    INT      CvgDecimal        DATE  STRU.   CLOB      BLOB
 *   (L4G)    : Libelle Shortint Integer  Decimal    Date  Char    Clobfile  Blobfile
 * </pre>
 * 
 * <li>X3TYP_BLOB = 0x7C; //124; (lg sur 4 octets +
 * binaire)
 * <li>X3TYP_CLOB = 0x7D; //125; (lg sur 4 octets +
 * UTF8)
 * <li>X3TYP_DATE = 0x33; //51;
 * <li>X3TYP_BCD = 0x2F; //47;
 * <li>X3TYP_INT = 0x2E; //46;
 * <li>X3TYP_LIBELLE = 0x2C; //44;
 * <li>X3TYP_NULL = 0x00; //0;
 * <li>X3TYP_SHORT = 0x2D; //45;
 * <li>X3TYP_STRU = 0x7A; //122;
 * <li>X3TYP_UNKNOWN = -1;
 * 
 * @author Adonix Grenoble
 * @version 140_000
 */

function getBufBytes(tag, bytes) {
	var buf = new Buffer(6 + bytes.length);
	buf[0] = tag;
	buf[1] = 0;
	buf.writeInt32BE(bytes.length, 2);
	bytes.copy(buf, 6);
	return buf;
}

var CvgResu = exports.CvgResu = helpers.defineClass(function(type, val) {
	this.type = type;
	this.value = val;
}, null, {
	toString: function() {
		return JSON.stringify(this);
	},
	equals: function(v) {
		return v && v.type === this.type && v.value === this.value;
	},
	isNull: function() {
		return this.type === CvgResu.TDO_NULL;
	},
	isDate: function() {
		return this.type === CvgResu.TDO_DATE;
	},
	isBCD: function() {
		return this.type === CvgResu.TDO_BCD;
	},
	isInt: function() {
		return this.type === CvgResu.TDO_INT;
	},
	isShort: function() {
		return this.type === CvgResu.TDO_SHORT;
	},
	isDateNull: function() {
		return this.isDate() && this.value === "00000000";
	},
	isNum: function() {
		return this.isBCD() || this.isInt() || this.isShort();
	},
	getBytes: function() {
		var val = this.value;
		switch (this.type) {
			case CvgResu.TDO_ALPHA:
				var buf = new Buffer(2 + 2 * (val.length + 1));
				buf[0] = CvgResu.TAG_STRU;
				buf[1] = val.length;
				for (var i = 0; i < val.length; i++) {
					var ch = val.charCodeAt(i);
					buf[2 + 2 * i] = (ch >> 8) & 0xff;
					buf[2 + 2 * i + 1] = ch & 0xff;
				}
				buf[2 + 2 * val.length] = 0;
				buf[2 + 2 * val.length + 1] = 0;
				return buf;
			case CvgResu.TDO_NULL:
				return new Buffer([CvgResu.TAG_NULL, 0]);
			case CvgResu.TDO_SHORT:
				return new Buffer([CvgResu.TAG_SHORT, 0, (val >>> 8) & 0xff, val & 0xff])
			case CvgResu.TDO_INT:
			case CvgResu.TDO_MENLOC:
				// MENLOC like int
				return new Buffer([CvgResu.TAG_INT, 0, (val >> 24) & 0xff, (val >> 16) & 0xff, //
				(val >> 8) & 0xff, val & 0xff]);
			case CvgResu.TDO_BCD:
				var bufDcb = CvgDecimal.toBytes(val);
				var buf = new Buffer(2);
				buf[0] = 0x2f;
				buf[1] = 0x11;
				return Buffer.concat([buf, bufDcb], 19);
			case CvgResu.TDO_DATE:
				var days = CvgDate.toDays(val);
				return new Buffer([CvgResu.TAG_DATE, 3, (days >> 16) & 0xff, (days >> 8) & 0xff, days & 0xff]);
			case CvgResu.TDO_BLOB:
				return getBufBytes(CvgResu.TAG_BLOB, val);
			case CvgResu.TDO_CLOB:
				return getBufBytes(CvgResu.TAG_CLOB, new Buffer(val, 'utf8'));
			default:
				throw new Error("NIY resu to bytes: " + this.type);
		}
	},
	clone: function() {
		return new CvgResu(this.type, this.value)
	},
});



CvgResu.TAG_NULL = 0x00; // 0
CvgResu.TAG_LIBELLE = 0x2c; // 44
CvgResu.TAG_SHORT = 0x2d; // 45
CvgResu.TAG_INT = 0x2e; // 46
CvgResu.TAG_BCD = 0x2f; // 47
CvgResu.TAG_STRU = 0x7a; // 122
CvgResu.TAG_DATE = 0x33; // 51
CvgResu.TAG_BLOB = 0x7c; // 124 (lg sur 4 octets + binaire)
CvgResu.TAG_CLOB = 0x7d; // 125 (lg sur 4 octets + UTF8)


CvgResu.TDO_NULL = 0;
CvgResu.TDO_MENLOC = 1;
CvgResu.TDO_SHORT = 2;
CvgResu.TDO_INT = 3;
CvgResu.TDO_BCD = 4;
CvgResu.TDO_DECI = 5;
CvgResu.TDO_FLOT = 6;
CvgResu.TDO_ALPHA = 7;
CvgResu.TDO_DATE = 8;
CvgResu.TDO_BLOB = 9;
CvgResu.TDO_CLOB = 10;

CvgResu.fromAction = function(type, str) {
	switch (type) {
		case CvgResu.TDO_NULL:
			return new CvgResu(type, null);
		case CvgResu.TDO_SHORT:
		case CvgResu.TDO_INT:
		case CvgResu.TDO_MENLOC:
			return new CvgResu(type, parseInt(str, 10));
		case CvgResu.TDO_BCD:
		case CvgResu.TDO_ALPHA:
		case CvgResu.TDO_DATE:
			return new CvgResu(type, str);
		case CvgResu.TDO_BLOB:
			// I'm assuming base64 encoding
			return new CvgResu(type, new Buffer(str, 'base64'));
		case CvgResu.TDO_CLOB:
			return new CvgResu(type, str);
		default:
			throw new Error("bad resu type: " + type);
	}
}


CvgResu.fromX3Type = function(x3type,str) {
	switch (x3type) {
		case CvgResu.TAG_NULL:
		 	return CvgResu.fromAction(CvgResu.TDO_NULL,str);
		case CvgResu.TAG_SHORT:
		 	return CvgResu.fromAction(CvgResu.TDO_SHORT,str);
		case CvgResu.TAG_INT:
		 	return CvgResu.fromAction(CvgResu.TDO_INT,str);
		case CvgResu.TAG_LIBELLE:
		 	return CvgResu.fromAction(CvgResu.TDO_MENLOC,str);
		case CvgResu.TAG_BCD:
		 	return CvgResu.fromAction(CvgResu.TDO_BCD,str);
		case CvgResu.TAG_STRU:
		 	return CvgResu.fromAction(CvgResu.TDO_ALPHA,str);
		case CvgResu.TAG_DATE:
		 	return CvgResu.fromAction(CvgResu.TDO_DATE,str);
		case CvgResu.TAG_BLOB:
		 	return CvgResu.fromAction(CvgResu.TDO_BLOB,str);
		case CvgResu.TAG_NULL:
		 	return CvgResu.fromAction(CvgResu.TDO_NULL,str);
		default:
			throw new Error("can't find type for value " + x3type);
	}
}

CvgResu.getTypeFromString = function(str) {
	switch (str) {
		case "NULL":
			return CvgResu.TAG_NULL;
		case "SHORT":
			return CvgResu.TAG_SHORT;
		case "INT":
			return CvgResu.TAG_INT;
		case "LIB":
			return CvgResu.TAG_LIBELLE;
		case "DCB":
			return CvgResu.TAG_BCD;
		case "STRU":
			return CvgResu.TAG_STRU;
		case "DATE":
			return CvgResu.TAG_DATE;
		case "BLOB":
			return CvgResu.TAG_BLOB;
			// I'm assuming base64 encoding
		case "CLOB":
			return CvgResu.TAG_NULL;
		default:
			throw new Error("can't find type for name " + str);
	}
}
