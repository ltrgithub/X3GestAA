"use strict";
var helpers = require('syracuse-core/lib/helpers');
var CvgDate = require('syracuse-x3/lib/convergence/types/CvgDate').CvgDate;
var CvgDecimal = require('syracuse-x3/lib/convergence/types/CvgDecimal').CvgDecimal;
/**
 * "Resu" contenu dans un argument d'un neoud.
 * <p>
 * Le res_u est compose par 2 octets donnant le type et la longueur, suivis de
 * la valeur.
 * <ul>
 * <li>0 indique un résu nul. le 2ieme octet est nul.
 * <li>44 indique un "libelle". le 2ieme octet est nul, le 3ieme indique la
 * valeur
 * <li>45 indique un entier court, le 2ime octet est nul et 3&4 donne la valeur
 * (Little Endian)
 * <li>46 indique un entier long, le 2 est nul, la valeur est sur 4 octets
 * <li>47 indique un CvgDecimal. le 2 indique la lg de mantisse</li>
 * <li>51 indique une date (un entier sur 3 octets),</li>
 * <ul>
 * <li>le 2 est normalement a 3</li>
 * <li>suit le nombre de jours depuis le 1er janvier 1600.</li>
 * </ul>
 * <li>122 indique une chaine unicode:</li>
 * <ul>
 * <li>les 2ème et 3 ème octets donnent la longueur du buffer à suivre (2 + n)</li>
 * <li>les 4ème et 5 ème octets donnent le nombre de caracteres (0 à n)</li>
 * <li>suivent n caractères codés en UTF-8</li>
 * </ul>
 * </ul>
 * 
 * <pre>
 *   (moteur) : 44      45       46       47         51    122     125       124
 *   (java)   : Byte    Short    Integer  BigDecimal Date  String  CClob     byte[]
 *   (résu)   : LIB     SHORT    INT      CvgDecimal        DATE  STRU.   CLOB      BLOB
 *   (L4G)    : Libelle Shortint Integer  Decimal    Date  Char    Clobfile  Blobfile
 * </pre>
 * 
 * <li>X3TYP_BLOB = 0x7C; //124; (lg sur 4 octets +
 * binaire)
 * <li>X3TYP_CLOB = 0x7D; //125; (lg sur 4 octets +
 * UTF8)
 * <li>X3TYP_DATE = 0x33; //51;
 * <li>X3TYP_BCD = 0x2F; //47;
 * <li>X3TYP_INT = 0x2E; //46;
 * <li>X3TYP_LIBELLE = 0x2C; //44;
 * <li>X3TYP_NULL = 0x00; //0;
 * <li>X3TYP_SHORT = 0x2D; //45;
 * <li>X3TYP_STRU = 0x7A; //122;
 * <li>X3TYP_UNKNOWN = -1;
 * 
 * @author Adonix Grenoble
 * @version 140_000
 */

function getBufBytes(tag, bytes) {
	var buf = new Buffer(6 + bytes.length);
	buf[0] = tag;
	buf[1] = 0;
	buf.writeInt32BE(bytes.length, 2);
	bytes.copy(buf, 6);
	return buf;
}

var CvgResu = exports.CvgResu = helpers.defineClass(function(type, val) {
	this.type = type;
	this.value = val;
}, null, {
	toString: function() {
		return JSON.stringify(this);
	},
	equals: function(v) {
		return v && v.type === this.type && v.value === this.value;
	},
	isNull: function() {
		return this.type === TDO["NULL"];
	},
	isDate: function() {
		return this.type === TDO["DATE"];
	},
	isBCD: function() {
		return this.type === TDO["DCB"];
	},
	isInt: function() {
		return this.type === TDO["INT"];
	},
	isShort: function() {
		return this.type === TDO["SHORT"];
	},
	isDateNull: function() {
		return this.isDate() && this.value === CvgDate.DATE_ZERO;
	},
	isNum: function() {
		return this.isBCD() || this.isInt() || this.isShort();
	},
	getBytes: function() {
		var val = this.value;
		switch (this.type) {
			case TDO["STRU"]:
				var buf = new Buffer(2 + 2 * (val.length + 1));
				buf[0] = TAG["STRU"];
				buf[1] = val.length;
				for (var i = 0; i < val.length; i++) {
					var ch = val.charCodeAt(i);
					buf[2 + 2 * i] = (ch >> 8) & 0xff;
					buf[2 + 2 * i + 1] = ch & 0xff;
				}
				buf[2 + 2 * val.length] = 0;
				buf[2 + 2 * val.length + 1] = 0;
				return buf;
			case TDO["NULL"]:
				return new Buffer([TAG["NULL"], 0]);
			case TDO["SHORT"]:
				return new Buffer([TAG["SHORT"], 0, (val >> 8) & 0xff, val & 0xff])
			case TDO["INT"]:
			case TDO["LIB"]:
				// MENLOC like int
				return new Buffer([TAG["INT"], 0, (val >> 24) & 0xff, (val >> 16) & 0xff, //
				(val >> 8) & 0xff, val & 0xff]);
			case TDO["DECI"]:
			case TDO["FLOT"]:
			case TDO["DCB"]:
				var bufDcb = CvgDecimal.toBytes(val);
				var buf = new Buffer(2);
				buf[0] = 0x2f;
				buf[1] = 0x11;
				return Buffer.concat([buf, bufDcb], 19);
			case TDO["DATE"]:
				var days = CvgDate.toDays(val);
				return new Buffer([TAG["DATE"], 3, (days >>> 16) & 0xff, (days >>> 8) & 0xff, days & 0xff]);
			case TDO["BLOB"]:
				return getBufBytes(TAG["BLOB"], val);
			case TDO["CLOB"]:
				return getBufBytes(TAG["CLOB"], new Buffer(val, 'utf8'));
			default:
				throw new Error("NIY resu to bytes: " + this.type);
		}
	},
	clone: function() {
		return new CvgResu(this.type, this.value)
	},
});


var RAWS_TYPES = [
	['NULL', 'NULL', 0x00],		// 0
	['LIB', 'LIB', 0x2c],		// 44
	['SHORT', 'SHORT', 0x2d],	// 45
	['INT', 'INT', 0x2e],		// 46
	['DCB', 'DCB', 0x2f],		// 47
	['DECI', 'DCB', 0x2f],		// 47
	['FLOT', 'DCB', 0x2f],		// 47
	['STRU', 'STRU', 0x7a],		// 122
	['DATE', 'DATE', 0x33],		// 51
	['BLOB', 'BLOB', 0x7c],		// 124 (lg sur 4 octets + binaire)
	['CLOB', 'CLOB', 0x7d]		// 125 (lg sur 4 octets + UTF8)
];

//TAG: {
//  "NULL": 0,
//  "LIB": 44,
//  "SHORT": 45,
//  "INT": 46,
//  "DCB": 47,
//  "STRU": 122,
//  "DATE": 51,
//  "BLOB": 124,
//  "CLOB": 125
//}
var TAG = exports.TAG = RAWS_TYPES.reduce(function(types, desc) {
	types[desc[1]] = desc[2];
	return types;
}, {});

//RTAG: {
//  0 : "NULL",
//  44:"LIB",
//  45:"SHORT",
//  46:"INT",
//  47:"DCB",
//  122:"STRU",
//  51:"DATE",
//  124:"BLOB",
//  125:"CLOB": 125
//}
var RTAG = exports.RTAG = RAWS_TYPES.reduce(function(types, desc) {
	types[desc[2]] = desc[1];
	return types;
}, {});

//TDO: {
//  "NULL": 0,
//  "LIB": 1,
//  "SHORT": 2,
//  "INT": 3,
//  "DCB": 4,
//  "DECI": 5,
//  "FLOT": 6,
//  "STRU": 7,
//  "DATE": 8,
//  "BLOB": 9,
//  "CLOB": 10
//}
var TDO = exports.TDO = RAWS_TYPES.reduce(function(types, desc, index) {
	types[desc[0]] = index;
	return types;
}, {});

//TAG_LIB: {
//	"0": "NULL",
//	"44": "LIB",
//	"45": "SHORT",
//	"46": "INT",
//	"47": "DCB",
//	"51": "DATE",
//	"122": "STRU",
//	"124": "BLOB",
//	"125": "CLOB"
//}
var TAG_LIB = exports.TAG_LIB = RAWS_TYPES.reduce(function(types, desc, index) {
	types[desc[2]] = desc[1];
	return types;
}, {});

//TDO_LIB: {
//	"0": "NULL",
//	"1": "LIB",
//	"2": "SHORT",
//	"3": "INT",
//	"4": "DCB",
//	"5": "DECI",
//	"6": "FLOT",
//	"7": "STRU",
//	"8": "DATE",
//	"9": "BLOB",
//	"10": "CLOB"
//}
var TDO_LIB = exports.TDO_LIB = RAWS_TYPES.reduce(function(types, desc, index) {
	types[index] = desc[0];
	return types;
}, {});



CvgResu.fromAction = function(type, str) {
	switch (type) {
		case TDO["NULL"]:
			return new CvgResu(type, null);
		case TDO["SHORT"]:
		case TDO["INT"]:
		case TDO["LIB"]:
			return new CvgResu(type, parseInt(str, 10));
		case TDO["DCB"]:
		case TDO["STRU"]:
		case TDO["DATE"]:
			return new CvgResu(type, str);
		case TDO["BLOB"]:
			// I'm assuming base64 encoding
			return new CvgResu(type, new Buffer(str, 'base64'));
		case TDO["CLOB"]:
			return new CvgResu(type, str);
		default:
			throw new Error("bad resu type: " + type);
	}
}

CvgResu.x3TypeToString = function(x3type) {
	return RTAG[x3type];
}
	
CvgResu.fromX3Type = function(x3type,str) {
	switch (x3type) {
		case TAG["NULL"]:
		 	return CvgResu.fromAction(TDO["NULL"],str);
		case TAG["SHORT"]:
		 	return CvgResu.fromAction(TDO["SHORT"],str);
		case TAG["INT"]:
		 	return CvgResu.fromAction(TDO["INT"],str);
		case TAG["LIBELLE"]:
		 	return CvgResu.fromAction(TDO["LIB"],str);
		case TAG["BCD"]:
		 	return CvgResu.fromAction(TDO["BCD"],str);
		case TAG["STRU"]:
		 	return CvgResu.fromAction(TDO["STRU"],str);
		case TAG["DATE"]:
		 	return CvgResu.fromAction(TDO["DATE"],str);
		case TAG["BLOB"]:
		 	return CvgResu.fromAction(TDO["BLOB"],str);
		case TAG["CLOB"]:
		 	return CvgResu.fromAction(TDO["CLOB"],str);
		default:
			throw new Error("can't find type for value " + x3type);
	}
}

