"use strict";

var helpers = require("syracuse-core/lib/helpers");
var TrackerResponse = require("syracuse-sdata/lib/sdataAsync").TrackerResponse;
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var util = require('util');

var convAsync = exports.convAsync = helpers.defineClass(function() {
	this.trackers = {};

},null,{
	track: function(_, context, id) {
		switch(context.request.method.toLowerCase()) {
			case 'get':
				var tracker = this.trackers[id]; 
				if (!tracker) return context.reply(_, 404, "tracker not found: " + id); 
				tracker.reply(_, context.response);
				break;
			case 'delete':
				delete this.trackers[id];
				context.reply(_, 204);
				break;
			default:
				throw new Error("Bad method: "+context.request.method);
		}
	},
	create : function(context, dispatch) {    
		var trackngId = context.parameters.trackngId;
		var response = context.response;
		var tracker = this.trackers[trackngId];
		if (tracker) {
			throw new Error("Tracker already exists.");
		}
		context.response = new TrackerResponse();
		this.trackers[trackngId] = tracker = new convTracker(this,context, trackngId, dispatch);
		tracker.originResponse = response;
		context.tracker = tracker;
		return tracker;
	},
	clean : function(){
		this.trackers = {};
	}
	
});


var maxValue = 10000;
var convTracker =  helpers.defineClass(function(convAsync,context, trackngId, dispatch) {
	this.trackngId = trackngId;
    this.async = convAsync	
    this.response = context.response;
    this.status = 202;
    this.done = false;
	this.location ;
	this.convStep;
	this.maxtry ;
	this.nbtry ;

    this.context = context;
	this.phase = "Starting";
	this.phaseDetail = null;
	this.progress = null;
	this.elapsedSeconds = null;
	this.remainingSeconds = null;
    this.pollingMillis = 0;// by default value
    this.startTime = new Date().getTime();
	this.dispatch =dispatch;

   }, null, {
    reply: function(_, response) {
		if (!this.done ) {
			if( this.maxtry && this.nbtry < this.maxtry ) {
				this.nbtry ++;
				var self = this;
				setTimeout(function(_){
					self.reply(_,response);
				},this.convStep);
			}else{
				if( this.pollingMillis < maxValue )
					this.pollingMillis += 1000;
				var currentTime = new Date().getTime();
				this.elapsedSeconds = currentTime - this.startTime;
				var headers = {
					"content-type": "application/json",
					location: this.location,
				}
				response.writeHead(this.status, headers);
				var body = {
					phase: this.phase,
					phaseDetail: this.phaseDetail,
					progress: this.progress,
					elapsedSeconds: this.elapsedSeconds,
					remainingSeconds: this.remainingSeconds,
					pollingMillis: this.pollingMillis,
				};
				response.write(_, JSON.stringify(body), "utf8");
				
				response.end();
			}
		} else {
			this.response.flush(_, response);
			delete this.async.trackers[this.trackngId];
		}
    },
	start: function(_){
		var self = this;
		this.dispatch(function(err) {
			self.done = true;
			self.phase = "Completed";
			self.response.finish(err);
		}, this.context);

		this.reply(_, this.originResponse);
	}
});




