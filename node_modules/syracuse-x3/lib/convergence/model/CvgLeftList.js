"use strict";
var helpers = require('syracuse-core/lib/helpers');
var CvgDataSrc = require('syracuse-x3/lib/convergence/model/CvgDataSrc').CvgDataSrc;

var CvgLeftList = exports.CvgLeftList = helpers.defineClass(function(aStackedWindow, aScreen, aEntityIndexBaseOne, aId, aListFormat, aNbColumns) {
	CvgDataSrc.call(this, aStackedWindow, aScreen, aEntityIndexBaseOne, aId, 300, aNbColumns, null, CvgDataSrc.TYPE_LEFTLIST);
	this.listFormat = aListFormat;
	this.columnTitleModified = false;
	this.curLineIdx = -1;
	this.nbColumnModified = false;
	this.colomnFormatChange = false;
}, CvgDataSrc, {
	appendLeftListLine: function(aIdx, aBranche, aTxt, aVal, aClf, aClp) {
		var wLeftListLine = this.entrySup.clone();
		if (aIdx === -1) {
			aIdx = this.lines.length;
		}
		wLeftListLine.setColumns(aIdx - 1, aVal, aClf);
		CvgDataSrc.prototype.appendLeftListLine.call(this, wLeftListLine);
		return wLeftListLine;
	},
	changeColumnsFormats: function(aFormats) {
		var CvgListOfLeftListsFactory = require('syracuse-x3/lib/convergence/model/CvgListOfLeftListsFactory').CvgListOfLeftListsFactory;
		var wLeftListLine;
		if (aFormats.length > this.nbColumns) {
			wLeftListLine = CvgListOfLeftListsFactory.newListEntrySup(this.stackedWindow, this, aFormats.length);
			this.setEntrySup(wLeftListLine);
			this.nbColumnModified = true;
		} else {
			wLeftListLine = this.entrySup;
		}
		wLeftListLine.setColumnsFormats(aFormats);
		this.colomnFormatChange = true;
	},
	changeColumnsTitles: function(aTitles) {
		this.entrySup.setColumnsTitles(aTitles);
		this.columnTitleModified = true;
	},
	findLine: function(selKeys) {

		for (var i=0, l=this.lines.length; i<l; i++){
			var line=this.getLine(i);
			var myKeys=line.cle;
			if (myKeys && (myKeys.length === selKeys.length) ){
				var j = 0;
				for (; j < myKeys.length && myKeys[j].value === selKeys[j].value && myKeys[j].type === selKeys[j].type ; j++){}
				if (j === myKeys.length) {
					return  {
						line:line,
						idx:i
					}
				}					
			}
		}
		return null;
	},
	hasColumnTitleModified: function() {
		return this.columnTitleModified;
	},
	hasNbColumnModified: function() {
		return this.nbColumnModified;
	},
	isColomnFormatChange: function() {
		return this.colomnFormatChange;
	},
	isHierarchic: function() {
		return CvgLeftList.isHierarchicFormat(this.listFormat);
	},
	isListFormat: function(aListFormat) {
		return this.listFormat === aListFormat;
	},
	isRecursive: function() {
		return CvgLeftList.isRecursiveFormat(this.listFormat);
	},
	razModification: function() {
		this.nbColumnModified = false;
		this.columnTitleModified = false;
		CvgDataSrc.prototype.razModification.call(this);
	},
	setColomnFormatChange: function(colomnFormatChange) {
		this.colomnFormatChange = colomnFormatChange;
	},
	// Return selected line or -1
	setServerSelectLine: function(selected, selKeys) {
		//console.log("serverSelectLine->" + this.getAdxId() + " - sel[" + selected + "] - key:" + JSON.stringify(selKeys));
		var sel = this.findLine(selKeys);
		if (sel!=null){
			// console.log("\tselIdx:" + sel.idx + " - curLineIdx:" + this.curLineIdx + " - pickingFlat:" + this.isListFormat(CvgLeftList.FMT_PICKING_FLAT));
			if (this.isListFormat(CvgLeftList.FMT_PICKING_FLAT)) {
				console.log("set selected "+sel.line.getObservableId()+" selected "+selected);
				sel.line.setLeftListLineSelected(selected);
				return sel.idx;
			} else if (sel.idx != this.curLineIdx) {
				if (selected){
					sel.line.setLeftListLineSelected(true);
					if (this.curLineIdx > -1 && this.curLineIdx < this.lines.length) {
						this.getLine(this.curLineIdx).setLeftListLineSelected(false);
					}
					this.curLineIdx = sel.idx;
				} else {
					sel.line.setLeftListLineSelected(false);
					this.curLineIdx = -1;
				}
			}
		} else if (this.curLineIdx > -1 && this.curLineIdx < this.lines.length) {
			this.getLine(this.curLineIdx).setLeftListLineSelected(false);
			this.curLineIdx = -1;
		}
		return this.curLineIdx;
	},
	// Extension à apporter au modèle de données (càd au protototype généré). Utilisé notamment sur l'ouverture des fenêtres de type Choose,
	//  où la description des colonnes de la liste de sélection est fournie dynamiquement par le back-office.
	//  Le contenu de cet objet est donc variable; il doit simplement respecter la structure et la codification du modèle de données.
	// L'exemple ci-dessous illustre ce qui est attendu dans le cas de l'extention du modèle pour une fenêtre de type Choose.
	overrideProto:function(){
		// _CHOOSE window
		if (this.hasColumnTitleModified() || this.isColomnFormatChange()){
			var properties = {};
			for (var it in this.entrySup.vars) {
				var item = this.entrySup.vars[it];
				var itemJs = {};
				if (item.title != null) itemJs.tit = item.title;
				itemJs.fmt = item.format != null ? item.format.format : "";
				properties[item.getJsonKey()] = itemJs;
			}
			return {
				$item :{
					$properties : properties
				}
			}
		}
		return null;
	}

});

CvgLeftList.FMT_HIERARCHIC = 2;
CvgLeftList.FMT_PICKING_FLAT = 5;
CvgLeftList.FMT_PICKING_HIERARCHIC = 3;
CvgLeftList.FMT_RECURSIVE = 4;

CvgLeftList.isHierarchicFormat = function(aFormat) {
	return aFormat === CvgLeftList.FMT_HIERARCHIC || aFormat === CvgLeftList.FMT_PICKING_HIERARCHIC;
}

CvgLeftList.isRecursiveFormat = function(aFormat) {
	return aFormat === CvgLeftList.FMT_RECURSIVE;
}
