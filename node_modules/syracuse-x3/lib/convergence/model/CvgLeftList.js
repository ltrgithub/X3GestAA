"use strict";
var helpers = require('syracuse-core/lib/helpers');
var CvgDataSrc = require('syracuse-x3/lib/convergence/model/CvgDataSrc').CvgDataSrc;

var CvgLeftList = exports.CvgLeftList = helpers.defineClass(function(aStackedWindow, aScreen, aEntityIndexBaseOne, aId, aListFormat, aNbColumns) {
	CvgDataSrc.call(this, aStackedWindow, aScreen, aEntityIndexBaseOne, aId, 300, aNbColumns, null, CvgDataSrc.TYPE_LEFTLIST);
	this.listFormat = aListFormat;
	this.columnTitleModified = false;
	this.currentSelectedLine = -1;
	this.nbColumnModified = false;
	this.colomnFormatChange = false;
}, CvgDataSrc, {
	appendLeftListLine: function(aIdx, aBranche, aTxt, aVal, aClf, aClp) {
		var wLeftListLine = this.entrySup.clone();
		if (aIdx === -1) {
			aIdx = this.lines.length;
		}
		wLeftListLine.setColumns(aIdx - 1, aVal, aClf);
		CvgDataSrc.prototype.appendLeftListLine.call(this, wLeftListLine);
		return wLeftListLine;
	},
	changeColumnsFormats: function(aFormats) {
		var CvgListOfLeftListsFactory = require('syracuse-x3/lib/convergence/model/CvgListOfLeftListsFactory').CvgListOfLeftListsFactory;
		var wLeftListLine;
		if (aFormats.length > this.nbColumns) {
			wLeftListLine = CvgListOfLeftListsFactory.newListEntrySup(this.stackedWindow, this, aFormats.length);
			this.setEntrySup(wLeftListLine);
			this.nbColumnModified = true;
		} else {
			wLeftListLine = this.entrySup;
		}
		wLeftListLine.setColumnsFormats(aFormats);
		this.colomnFormatChange = true;
	},
	changeColumnsTitles: function(aTitles) {
		this.entrySup.setColumnsTitles(aTitles);
		this.columnTitleModified = true;
	},
	findLineIdx: function(aCle) {
		var wCle;
		var wMax = this.lines.length;
		var wI = 0;
		while (wI < wMax) {
			wCle = this.getLine(wI).cle;
			
			if (wCle && (wCle.length === aCle.length) ){
				var match = true;
				for (var i = 0; i < wCle.length && match ; i++){			
					match = wCle[i].equals(aCle[i]);
				}
				if (match)
					return  wI;
				
			}
			wI++;
		}
		return -999;
	},
	hasColumnTitleModified: function() {
		return this.columnTitleModified;
	},
	hasNbColumnModified: function() {
		return this.nbColumnModified;
	},
	isColomnFormatChange: function() {
		return this.colomnFormatChange;
	},
	isHierarchic: function() {
		return CvgLeftList.isHierarchicFormat(this.listFormat);
	},
	isListFormat: function(aListFormat) {
		return this.listFormat === aListFormat;
	},
	isRecursive: function() {
		return CvgLeftList.isRecursiveFormat(this.listFormat);
	},
	razModification: function() {
		this.nbColumnModified = false;
		this.columnTitleModified = false;

		CvgDataSrc.prototype.razModification.call(this);
	},
	setColomnFormatChange: function(colomnFormatChange) {
		this.colomnFormatChange = colomnFormatChange;
	},
	setServerSelectLine: function(selected, aCle) {
		var selIdx = this.findLineIdx(aCle);
		var found = selIdx > -1;
		if (this.isListFormat(CvgLeftList.FMT_PICKING_FLAT)) {
			if (found) {
				this.getLine(selIdx).setLeftListLineSelected(selected, true);
			}
		} else {
			if (selected && selIdx != this.currentSelectedLine) {
				if (selIdx > -1) {
					this.getLine(selIdx).setLeftListLineSelected(selected, true);
					if (this.currentSelectedLine > -1 && this.currentSelectedLine < this.lines.length) {
						this.getLine(this.currentSelectedLine).setLeftListLineSelected(false, false);
					}
				} else if (this.currentSelectedLine > -1 && this.currentSelectedLine < this.lines.length) {
					this.getLine(this.currentSelectedLine).setLeftListLineSelected(false, true);

				}
				this.currentSelectedLine = selIdx;

			} else {
				if (selIdx > -1) {
					this.getLine(selIdx).setLeftListLineSelected(selected, true);
				}
				this.currentSelectedLine = -1;
			}
		}
		return true;
	},
	// Extension à apporter au modèle de données (càd au protototype généré). Utilisé notamment sur l'ouverture des fenêtres de type Choose,
	//  où la description des colonnes de la liste de sélection est fournie dynamiquement par le back-office.
	//  Le contenu de cet objet est donc variable; il doit simplement respecter la structure et la codification du modèle de données.
	// L'exemple ci-dessous illustre ce qui est attendu dans le cas de l'extention du modèle pour une fenêtre de type Choose.
	overrideProto:function(){
		// _CHOOSE window
		if (this.hasColumnTitleModified() || this.isColomnFormatChange()){
			var properties = {};
			for (var it in this.entrySup.vars) {
				var item = this.entrySup.vars[it];
				var itemJs = {};
				if (item.title != null) itemJs.tit = item.title;
				itemJs.fmt = item.format != null ? item.format.format : "";
				properties[item.getJsonKey()] = itemJs;
			}
			return {
				$item :{
					$properties : properties
				}
			}
		}
		return null;
	}

});

CvgLeftList.FMT_HIERARCHIC = 2;
CvgLeftList.FMT_PICKING_FLAT = 5;
CvgLeftList.FMT_PICKING_HIERARCHIC = 3;
CvgLeftList.FMT_RECURSIVE = 4;

CvgLeftList.isHierarchicFormat = function(aFormat) {
	return aFormat === CvgLeftList.FMT_HIERARCHIC || aFormat === CvgLeftList.FMT_PICKING_HIERARCHIC;
}

CvgLeftList.isRecursiveFormat = function(aFormat) {
	return aFormat === CvgLeftList.FMT_RECURSIVE;
}