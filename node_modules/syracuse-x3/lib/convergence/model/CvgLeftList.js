"use strict";
var helpers = require('syracuse-core/lib/helpers');
var CvgDataSrc = require('syracuse-x3/lib/convergence/model/CvgDataSrc').CvgDataSrc;
var CvgResuTDO = require('syracuse-x3/lib/convergence/types/CvgResu').TDO;
var x3helpers = require('syracuse-x3/lib/helpers');

var localConfig = x3helpers.config("x3fusion", null, {});
var traceLog = x3helpers.config("log.trace", localConfig);

var CvgLeftList = exports.CvgLeftList = helpers.defineClass(function(aStackedWindow, aScreen, aEntityIndexBaseOne, aId, aListFormat, aNbColumns) {
	CvgDataSrc.call(this, aStackedWindow, aScreen, aEntityIndexBaseOne, aId, 300, aNbColumns, null, CvgDataSrc.TYPE_LEFTLIST);
	this.listFormat = aListFormat;
	this.columnTitleModified = false;
	this.curLineIdx = -1;
	this.nbColumnModified = false;
	this.colomnFormatChange = false;
}, CvgDataSrc, {
	appendLeftListLine: function(aIdx, aBranche, aTxt, aVal, aClf, aClp) {
		var wLeftListLine = this.entrySup.clone();
		if (aIdx === -1) {
			aIdx = this.lines.length + 1;
		}
		wLeftListLine.setColumns(aIdx - 1, aVal, aClf);
		CvgDataSrc.prototype.appendLeftListLine.call(this, wLeftListLine);
		return wLeftListLine;
	},
	changeColumnsFormats: function(aFormats) {
		var CvgListOfLeftListsFactory = require('syracuse-x3/lib/convergence/model/CvgListOfLeftListsFactory').CvgListOfLeftListsFactory;
		var wLeftListLine;
		if (aFormats.length > this.nbColumns) {
			wLeftListLine = CvgListOfLeftListsFactory.newListEntrySup(this.stackedWindow, this, aFormats.length);
			this.setEntrySup(wLeftListLine);
			this.nbColumnModified = true;
		} else {
			wLeftListLine = this.entrySup;
		}
		wLeftListLine.setColumnsFormats(aFormats);
		this.colomnFormatChange = true;
	},
	changeColumnsTitles: function(aTitles) {
		this.entrySup.setColumnsTitles(aTitles);
		this.columnTitleModified = true;
	},
	findLine: function(selKeys) {

		for (var i = 0, l = this.lines.length; i < l; i++) {
			var line = this.getLine(i);
			var myKeys = line.cle;
			if (myKeys && (myKeys.length === selKeys.length)) {
				var j = 0;
				for (; j < myKeys.length && myKeys[j].value === selKeys[j].value && myKeys[j].type === selKeys[j].type; j++) {}
				if (j === myKeys.length) {
					return {
						line: line,
						idx: i
					};
				}
			}
		}
		return null;
	},
	hasColumnTitleModified: function() {
		return this.columnTitleModified;
	},
	hasNbColumnModified: function() {
		return this.nbColumnModified;
	},
	isColomnFormatChange: function() {
		return this.colomnFormatChange;
	},
	isHierarchic: function() {
		return CvgLeftList.isHierarchicFormat(this.listFormat);
	},
	isListFormat: function(aListFormat) {
		return this.listFormat === aListFormat;
	},
	isRecursive: function() {
		return CvgLeftList.isRecursiveFormat(this.listFormat);
	},
	razModification: function() {
		this.nbColumnModified = false;
		this.columnTitleModified = false;
		CvgDataSrc.prototype.razModification.call(this);
	},
	setColomnFormatChange: function(colomnFormatChange) {
		this.colomnFormatChange = colomnFormatChange;
	},
	// Return selected line or -1
	setServerSelectLine: function(selected, selKeys) {
		//console.log("serverSelectLine->" + this.getAdxId() + " - sel[" + selected + "] - key:" + JSON.stringify(selKeys));
		var sel = this.findLine(selKeys);
		if (sel != null) {
			// console.log("\tselIdx:" + sel.idx + " - curLineIdx:" + this.curLineIdx + " - pickingFlat:" + this.isListFormat(CvgLeftList.FMT_PICKING_FLAT));
			if (this.isListFormat(CvgLeftList.FMT_PICKING_FLAT)) {
				traceLog && traceLog((new Date().toISOString()) + " set selected " + sel.line.getObservableId() + " selected " + selected);
				sel.line.setLeftListLineSelected(selected);
				return sel.idx;
			} else if (sel.idx !== this.curLineIdx) {
				if (selected) {
					sel.line.setLeftListLineSelected(true);
					if (this.curLineIdx > -1 && this.curLineIdx < this.lines.length) {
						this.getLine(this.curLineIdx).setLeftListLineSelected(false);
					}
					this.curLineIdx = sel.idx;
				} else {
					sel.line.setLeftListLineSelected(false);
					this.curLineIdx = -1;
				}
			}
		} else if (this.curLineIdx > -1 && this.curLineIdx < this.lines.length) {
			this.getLine(this.curLineIdx).setLeftListLineSelected(false);
			this.curLineIdx = -1;
		}
		return this.curLineIdx;
	},
	// Extension à apporter au modèle de données (càd au protototype généré). Utilisé notamment sur l'ouverture des fenêtres de type Choose,
	//  où la description des colonnes de la liste de sélection est fournie dynamiquement par le back-office.
	//  Le contenu de cet objet est donc variable; il doit simplement respecter la structure et la codification du modèle de données.
	// L'exemple ci-dessous illustre ce qui est attendu dans le cas de l'extention du modèle pour une fenêtre de type Choose.
	overrideProto: function() {
		// _CHOOSE window
		if (this.hasColumnTitleModified() || this.isColomnFormatChange()) {
			var properties = {};
			for (var it in this.entrySup.vars) {
				var item = this.entrySup.vars[it];
				var itemJs = {};
				if (item.title != null) itemJs.tit = item.title;
				itemJs.fmt = item.format != null ? item.format.format : "";
				// issue 2869 default format 
				switch (item.dataType) {
					case 0:
					case 1: // LIB
					case 7: // STRU
						itemJs.fmt = "K:250X";
						break;
					case 2:
						itemJs.fmt = "N:5#";
						break;
					case 3:
						itemJs.fmt = "N:8#";
						break;
					case 4:
					case 5:
					case 6:
						itemJs.fmt = "N:9.6#";
						break;
					case 8:
						itemJs.fmt = "D:";
						break;
					default:
						itemJs.fmt = "K:250X";
						break;
				}

				properties[item.getJsonKey()] = itemJs;
			}
			return {
				$item: {
					$properties: properties
				}
			};
		}
		return null;
	}

});

CvgLeftList.FMT_HIERARCHIC = 2;
CvgLeftList.FMT_PICKING_FLAT = 5;
CvgLeftList.FMT_PICKING_HIERARCHIC = 3;
CvgLeftList.FMT_RECURSIVE = 4;

CvgLeftList.isHierarchicFormat = function(aFormat) {
	return aFormat === CvgLeftList.FMT_HIERARCHIC || aFormat === CvgLeftList.FMT_PICKING_HIERARCHIC;
};

CvgLeftList.isRecursiveFormat = function(aFormat) {
	return aFormat === CvgLeftList.FMT_RECURSIVE;
};