"use strict";
var helpers = require('syracuse-core/lib/helpers');
var CTraverser = Object; //require('syracuse-x3/lib/convergence/CTraverser').CTraverser;
var CvgLeftList = require('syracuse-x3/lib/convergence/model/CvgLeftList').CvgLeftList;
var CvgDataSrc = require('syracuse-x3/lib/convergence/model/CvgDataSrc').CvgDataSrc;
var CvgLeftListHierarchic = require('syracuse-x3/lib/convergence/model/CvgLeftListHierarchic').CvgLeftListHierarchic;
var CvgLeftListLineNode = require('syracuse-x3/lib/convergence/model/CvgLeftListLineNode').CvgLeftListLineNode;
var CvgResu = require('syracuse-x3/lib/convergence/types/CvgResu').CvgResu;
var CvgResuTag = require('syracuse-x3/lib/convergence/types/CvgResu').TAG;

var CvgLeftNodeAttacher = exports.CvgLeftNodeAttacher = helpers.defineClass(function(aLeftListNode, aClp) {
	this.leftListNode = aLeftListNode;
	this.clp = aClp;
}, CTraverser, {
	doWhenTraverse: function(aValue, aIdx, aWhen) {
		var wTraversingState = false;
		var wLeftListNode = aValue;
		var found = true;
		// check equals on key 
		for(var i= 0 ;found && i<wLeftListNode.cle.length && this.clp.length;i++){
			found = wLeftListNode.cle[i].type === this.clp[i].type;
			found = wLeftListNode.cle[i].value === this.clp[i].value;
		}
		if (found) {
			wLeftListNode.attachLefListNode(this.leftListNode);

		}
		return wTraversingState;
	}
});
var _customCols=[	
    {bind: "$id", 		ttl: "Key", 	typ: "application/x-string", typX3:"STRU"},
    {bind: "$parent", 	ttl: "Parent", 	typ: "application/x-string", typX3:"STRU"}, 
    {bind: "$icon",		ttl: "Image",	typ: "image", typX3:"STRU"},
    {bind: "$description",	ttl: "Title",	typ: "application/x-string", typX3:"STRU"},
    {bind: "$open",		ttl: "Open",	typ: "application/x-boolean", typX3:"STRU"}
];


// CvgLeftNodeAttacher
var CvgLeftNodeFinder = exports.CvgLeftNodeFinder = helpers.defineClass(function(aNodeId) {
	this.nodeId = aNodeId;
	this.leftListNode = null;
}, CTraverser, {
	doWhenTraverse: function(aValue, aIdx, aWhen) {
		var wTraversingState = false;
		var wLeftListNode = aValue;
		var wNodeId = wLeftListNode.nodeId;
		var wFound = wNodeId === this.nodeId;
		if (wFound) {
			this.leftListNode = wLeftListNode;
			wTraversingState = true;
		}
		return wTraversingState;
	},
});

var NODE_INDEX_NULL = -1;

var CvgLeftListRecursiv = exports.CvgLeftListRecursiv = helpers.defineClass(function(aStackedWindow, aScreen, aEntityIndexBaseOne, aId, aListFormat, aNbColumns) {
	CvgLeftList.call(this, aStackedWindow, aScreen, aEntityIndexBaseOne, aId, aListFormat, aNbColumns);
	this.addingLineInEmptyList = false;
	this.nodeIdToExpanded = NODE_INDEX_NULL;
	this.nodeIndex = NODE_INDEX_NULL;
}, CvgLeftListHierarchic, {
	appendLeftListLine: function(idx, branch, txt, val, key, keyParent) {
		var wLeftListNode = this.entrySup.clone();
		var isLeaf = branch == 0;
		this.memoAddingLineInEmptyList();
		this.nodeIndex++;
		var mykey="", mykeyParent="";	
		for (var i= 0; i< key.length;i++){
			if (mykey.length!=0) mykey += "~";
				mykey+= key[i].value;
		}
		console.log("key parent "+JSON.stringify(keyParent));
		for (var i= 0; i< keyParent.length;i++){
			if (mykeyParent.length!=0) mykeyParent += "~";
				mykeyParent+= keyParent[i].value;
		}
	
		var cells={
			"$id": mykey,
			"$parent":mykeyParent,
			// TODO - manage icons
			// verrideProto:function
			"$icon": isLeaf ? "ico.gif" : "Folder.gif",
			"$description":txt,
			// 1 for closed - 2 for open
			"$open":1
		};

		var vars=[];
		// be sure we have the right number of variable in vars 
		var id=this.id;
		id = id.substring(id.length-1);
		for (var i in _customCols){
			var col=_customCols[i];
			if( wLeftListNode.vars.length < i+1 ){
				var v = wLeftListNode.vars[0].clone();
				wLeftListNode.vars.push(v);
			}
			wLeftListNode.vars[i].id = id+i;
			vars.push(new CvgResu(CvgResuTag[col.typX3], cells[col.bind]));
		}
		
		wLeftListNode.setColumns(this.lines.length,vars, key);
		for(var i =0;i<wLeftListNode.vars.length;i++){
			wLeftListNode.vars[i].srvValueModified = true;
		}
		// si la cle pere est vide : ajout au premier niveau
		//CvgDataSrc.prototype.appendLeftListLine.call(this, wLeftListNode);
		// find the father 
		if( keyParent.length === 0 ){
			CvgDataSrc.prototype.appendLeftListLine.call(this, wLeftListNode);
		// no parent 
		}else{
			var isFather = false;
			for(var i=0;!isFather && i<this.lines.length;i++){
				isFather = this.lines[i].isSameCle(keyParent);
			}	
			if( isFather ) {
				this.lines.splice(i+1,0,wLeftListNode);
				this.fusionMvtsInsert(1,i);
			}else{
				// can't find father TODO send error 
			}
		}
			//this.attachLeftListNode(wLeftListNode, keyParent);
		return wLeftListNode;

	},
	attachLeftListNode: function(aLeftListNode, aClp) {
		if (!this.hasNodeIdToExpanded()) {
			var wNodeAttacher = new CvgLeftNodeAttacher(aLeftListNode, aClp);
			this.traverseAllSubNodes(wNodeAttacher);
		} else {
			this.findLeftListNode(this.nodeIdToExpanded).attachLefListNode(aLeftListNode);
		}
	},
	findLeftListNode: function(aNodeId) {
		var wNodeFinder = new CvgLeftNodeFinder(aNodeId);
		traverseAllSubNodes(wNodeFinder);
		var wLeftListNode = wNodeFinder.leftListNode;
		return wLeftListNode;
	},
	hasAddingLineInEmptyList: function() {
		return this.addingLineInEmptyList;
	},
	hasNodeIdToExpanded: function() {
		return this.nodeIdToExpanded !== NODE_INDEX_NULL;
	},
	memoAddingLineInEmptyList: function() {
		if (!this.addingLineInEmptyList) {
			this.addingLineInEmptyList = this.nodeIndex == NODE_INDEX_NULL;
		}
	},
	razModification: function() {
		CvgLeftList.prototype.razModification.call(this);
		this.addingLineInEmptyList = false;
		this.nodeIdToExpanded = NODE_INDEX_NULL;
	},
	serverRemoveAllLines: function() {
		CvgLeftList.prototype.serverRemoveAllLines.call(this);
		this.nodeIndex = NODE_INDEX_NULL;
	},
	setNodeIdToExpanded: function(aNodeId) {
		this.nodeIdToExpanded = aNodeId;
	},
	traverseAllSubNodes: function(aTraverser) {
		return this.traverseNodes(aTraverser, true);
	},
	traverseNodes: function(aTraverser, aWithSubNodes) {
		var wTraversingState = false;
		//  prise en compte des n lignes de premier niveau
		var wLeftListNode;
		var wI = 0;
		while (wI < this.size()) {
			wLeftListNode = this.getLine(wI);

			wTraversingState = aTraverser.doWhenTraverse(wLeftListNode, wI);
			/*
			 * prise en compte des n fils
			 */
			if (wTraversingState !== true && aWithSubNodes && wLeftListNode.hasSubNode()) {
				wTraversingState = wLeftListNode.traverseNodes(aTraverser, aWithSubNodes);
			}

			if (wTraversingState === true) {
				return true;
			}

			wI++;
		}
		return wTraversingState;
	},
	traverseSettable: function(aStructIst, aSetter) {
		if (aStructIst.isLineIst()) {
			var wI = aStructIst.idx;
			var wLeftListNode = this.findLeftListNode(wI);
			return aSetter.setModifiable(aStructIst, wLeftListNode);
		} else {
			return CvgLeftList.prototype.traverseSettable.call(this, aStructIst, aSetter);
		}
	},
	traverseSubNodes: function(aTraverser) {
		return this.traverseNodes(aTraverser, false);
	}
});
