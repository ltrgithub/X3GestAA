"use strict";
var helpers = require('syracuse-core/lib/helpers');
var CTraverser = Object; //require('syracuse-x3/lib/convergence/CTraverser').CTraverser;
var CvgLeftList = require('syracuse-x3/lib/convergence/model/CvgLeftList').CvgLeftList;
var CvgDataSrc = require('syracuse-x3/lib/convergence/model/CvgDataSrc').CvgDataSrc;
var CvgLeftListLineNode = require('syracuse-x3/lib/convergence/model/CvgLeftListLineNode').CvgLeftListLineNode;

var CvgLeftNodeAttacher = exports.CvgLeftNodeAttacher = helpers.defineClass(function(aLeftListNode, aClp) {
	this.leftListNode = aLeftListNode;
	this.clp = aClp;
}, CTraverser, {
	doWhenTraverse: function(aValue, aIdx, aWhen) {
		var wTraversingState = false;
		var wLeftListNode = aValue;
		var wFound = wLeftListNode.cle.equals(this.clp);
		if (wFound) {
			wLeftListNode.attachLefListNode(this.leftListNode);

		}
		return wTraversingState;
	}
});

// CvgLeftNodeAttacher
var CvgLeftNodeFinder = exports.CvgLeftNodeFinder = helpers.defineClass(function(aNodeId) {
	this.nodeId = aNodeId;
	this.leftListNode = null;
}, CTraverser, {
	doWhenTraverse: function(aValue, aIdx, aWhen) {
		var wTraversingState = false;
		var wLeftListNode = aValue;
		var wNodeId = wLeftListNode.nodeId;
		var wFound = wNodeId === this.nodeId;
		if (wFound) {
			this.leftListNode = wLeftListNode;
			wTraversingState = true;
		}
		return wTraversingState;
	},
});

var NODE_INDEX_NULL = -1;

var CvgLeftListRecursiv = exports.CvgLeftListRecursiv = helpers.defineClass(function(aStackedWindow, aScreen, aEntityIndexBaseOne, aId, aListFormat, aNbColumns) {
	CvgLeftList.call(this, aStackedWindow, aScreen, aEntityIndexBaseOne, aId, aListFormat, aNbColumns);
	this.addingLineInEmptyList = false;
	this.nodeIdToExpanded = NODE_INDEX_NULL;
	this.nodeIndex = NODE_INDEX_NULL;
}, CvgLeftList, {
	appendLeftListLine: function(aIdx, aBranche, aTxt, aVal, aClf, aClp) {
		var wLeftListNode = this.entrySup.clone();
		this.memoAddingLineInEmptyList();
		this.nodeIndex++;
		wLeftListNode.setColumns(this.nodeIndex, aTxt, aClf);
		if (aClp.length === 0) {
			// si la cle pere est vide : ajout au premier niveau
			CvgDataSrc.prototype.appendLeftListLine.call(this, wLeftListNode);
			console.log("cle "+wLeftListNode.cle);
		} else {
			// sinon, recherche de tous les noeuds ayant la Clp comme cle pour ajouter
			this.attachLeftListNode(wLeftListNode, aClp);
		}
		return wLeftListNode;

	},
	attachLeftListNode: function(aLeftListNode, aClp) {
		if (!hasNodeIdToExpanded()) {
			var wNodeAttacher = new CvgLeftNodeAttacher(aLeftListNode, aClp);
			this.traverseAllSubNodes(wNodeAttacher);
		} else {
			this.findLeftListNode(this.nodeIdToExpanded).attachLefListNode(aLeftListNode);
		}
	},
	findLeftListNode: function(aNodeId) {
		var wNodeFinder = new CvgLeftNodeFinder(aNodeId);
		traverseAllSubNodes(wNodeFinder);
		var wLeftListNode = wNodeFinder.leftListNode;
		return wLeftListNode;
	},
	hasAddingLineInEmptyList: function() {
		return this.addingLineInEmptyList;
	},
	hasNodeIdToExpanded: function() {
		return this.nodeIdToExpanded !== NODE_INDEX_NULL;
	},
	memoAddingLineInEmptyList: function() {
		if (!this.addingLineInEmptyList) {
			this.addingLineInEmptyList = this.nodeIndex == NODE_INDEX_NULL;
		}
	},
	razModification: function() {
		CvgLeftList.prototype.razModification.call(this);
		this.addingLineInEmptyList = false;
		this.nodeIdToExpanded = NODE_INDEX_NULL;
	},
	serverRemoveAllLines: function() {
		CvgLeftList.prototype.serverRemoveAllLines.call(this);
		this.nodeIndex = NODE_INDEX_NULL;
	},
	setNodeIdToExpanded: function(aNodeId) {
		this.nodeIdToExpanded = aNodeId;
	},
	traverseAllSubNodes: function(aTraverser) {
		return this.traverseNodes(aTraverser, true);
	},
	traverseNodes: function(aTraverser, aWithSubNodes) {
		var wTraversingState = false;
		//  prise en compte des n lignes de premier niveau
		var wLeftListNode;
		var wI = 0;
		while (wI < size()) {
			wLeftListNode = this.getLine(wI);

			wTraversingState = aTraverser.doWhenTraverse(wLeftListNode, wI);
			/*
			 * prise en compte des n fils
			 */
			if (wTraversingState !== true && aWithSubNodes && wLeftListNode.hasSubNode()) {
				wTraversingState = wLeftListNode.traverseNodes(aTraverser, aWithSubNodes);
			}

			if (wTraversingState === true) {
				return true;
			}

			wI++;
		}
		return wTraversingState;
	},
	traverseSettable: function(aStructIst, aSetter) {
		if (aStructIst.isLineIst()) {
			var wI = aStructIst.idx;
			var wLeftListNode = this.findLeftListNode(wI);
			return aSetter.setModifiable(aStructIst, wLeftListNode);
		} else {
			return CvgLeftList.prototype.traverseSettable.call(this, aStructIst, aSetter);
		}
	},
	traverseSubNodes: function(aTraverser) {
		return this.traverseNodes(aTraverser, false);
	}
});
