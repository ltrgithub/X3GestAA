"use strict";
var helpers = require('syracuse-core/lib/helpers');
var CTraverser = Object; //require('syracuse-x3/lib/convergence/CTraverser').CTraverser;
var CvgLeftList = require('syracuse-x3/lib/convergence/model/CvgLeftList').CvgLeftList;
var CvgDataSrc = require('syracuse-x3/lib/convergence/model/CvgDataSrc').CvgDataSrc;
var CvgLeftListHierarchic = require('syracuse-x3/lib/convergence/model/CvgLeftListHierarchic').CvgLeftListHierarchic;
var CvgLeftListLineNode = require('syracuse-x3/lib/convergence/model/CvgLeftListLineNode').CvgLeftListLineNode;
var CvgResu = require('syracuse-x3/lib/convergence/types/CvgResu').CvgResu;
var CvgResuTag = require('syracuse-x3/lib/convergence/types/CvgResu').TAG;

var CvgLeftNodeAttacher = exports.CvgLeftNodeAttacher = helpers.defineClass(function(aLeftListNode, aClp) {
	this.leftListNode = aLeftListNode;
	this.clp = aClp;
}, CTraverser, {
	doWhenTraverse: function(aValue, aIdx, aWhen) {
		var wTraversingState = false;
		var wLeftListNode = aValue;
		var found = true;
		// check equals on key 
		for (var i = 0; found && i < wLeftListNode.cle.length && this.clp.length; i++) {
			found = wLeftListNode.cle[i].type === this.clp[i].type;
			found = wLeftListNode.cle[i].value === this.clp[i].value;
		}
		if (found) {
			wLeftListNode.attachLefListNode(this.leftListNode);

		}
		return wTraversingState;
	}
});
var _customCols = [{
		bind: "$clientId",
		ttl: "Key",
		typ: "application/x-string",
		typX3: "STRU"
	}, {
		bind: "$parent",
		ttl: "Parent",
		typ: "application/x-string",
		typX3: "STRU"
	},
	//{bind: "$icon",		ttl: "Image",	typ: "image", typX3:"STRU"},
	{
		bind: "$description",
		ttl: "Title",
		typ: "application/x-string",
		typX3: "STRU"
	}, {
		bind: "$open",
		ttl: "Open",
		typ: "application/x-boolean",
		typX3: "STRU"
	}
];

// CvgLeftNodeAttacher
var CvgLeftNodeFinder = exports.CvgLeftNodeFinder = helpers.defineClass(function(aNodeId) {
	this.nodeId = aNodeId;
	this.leftListNode = null;
}, CTraverser, {
	doWhenTraverse: function(aValue, aIdx, aWhen) {
		var wTraversingState = false;
		var wLeftListNode = aValue;
		var wNodeId = wLeftListNode.nodeId;
		var wFound = wNodeId === this.nodeId;
		if (wFound) {
			this.leftListNode = wLeftListNode;
			wTraversingState = true;
		}
		return wTraversingState;
	},
});

var NODE_INDEX_NULL = -1;

var CvgLeftListRecursiv = exports.CvgLeftListRecursiv = helpers.defineClass(function(aStackedWindow, aScreen, aEntityIndexBaseOne, aId, aListFormat, aNbColumns) {
	CvgLeftList.call(this, aStackedWindow, aScreen, aEntityIndexBaseOne, aId, aListFormat, aNbColumns);
	this.addingLineInEmptyList = false;
	this.nodeIdToExpanded = NODE_INDEX_NULL;
	this.nodeIndex = NODE_INDEX_NULL;
}, CvgLeftListHierarchic, {
	appendLeftListLine: function(idx, branch, txt, val, key, keyParent) {
		var wLeftListNode = this.entrySup.clone();
		var isLeaf = branch === 0;
		this.memoAddingLineInEmptyList();
		this.nodeIndex++;
		var mykey = "",
			mykeyParent = "",
			i;
		for (i = 0; i < key.length; i++) {
			if (mykey.length !== 0) mykey += "~";
			mykey += key[i].value;
		}
		for (i = 0; i < keyParent.length; i++) {
			if (mykeyParent.length !== 0) mykeyParent += "~";
			mykeyParent += keyParent[i].value;
		}

		var cells = {
			"$clientId": mykey,
			"$parent": mykeyParent,
			// TODO - manage icons
			// verrideProto:function
			//"$icon": isLeaf ? "ico.gif" : "Folder.gif",
			"$description": txt,
			// 1 for closed - 2 for open
			"$open": 1
		};

		var vars = [];
		// be sure we have the right number of variable in vars 
		var id = this.id;
		id = id.substring(id.length - 1);
		for (i in _customCols) {
			var col = _customCols[i];
			if (wLeftListNode.vars.length < i + 1) {
				var v = wLeftListNode.vars[0].clone();
				wLeftListNode.vars.push(v);
			}
			wLeftListNode.vars[i].id = id + i;
			vars.push(new CvgResu(CvgResuTag[col.typX3], cells[col.bind]));
		}

		wLeftListNode.setColumns(this.lines.length, vars, key);
		for (i = 0; i < wLeftListNode.vars.length; i++) {
			wLeftListNode.vars[i].srvValueModified = true;
		}
		// si la cle pere est vide : ajout au premier niveau
		//CvgDataSrc.prototype.appendLeftListLine.call(this, wLeftListNode);
		// find the father 
		CvgDataSrc.prototype.appendLeftListLine.call(this, wLeftListNode);
		// recalculate id for all line

		//this.attachLeftListNode(wLeftListNode, keyParent);
		return wLeftListNode;

	},
	/*toJSON : function(){
		// send raz left list
		this.fusionMvtsReset();
		this.fusionMvtsRemoveAll();

		for(var i=0;i<this.lines.length;i++){
			this.lines[i].zeroBaseLineIdx = i;
			for(var v in this.lines[i].vars) {
				this.lines[i].vars[v].srvValueModified = true;
			}
		}

		// insert all lines
		this.fusionMvtsInsert(this.lines.length,0);
		return CvgDataSrc.prototype.toJSON.call(this);
	},*/
	attachLeftListNode: function(aLeftListNode, aClp) {
		if (!this.hasNodeIdToExpanded()) {
			var wNodeAttacher = new CvgLeftNodeAttacher(aLeftListNode, aClp);
			this.traverseAllSubNodes(wNodeAttacher);
		} else {
			this.findLeftListNode(this.nodeIdToExpanded).attachLefListNode(aLeftListNode);
		}
	},
	findLeftListNode: function(aNodeId) {
		var wNodeFinder = new CvgLeftNodeFinder(aNodeId);
		this.traverseAllSubNodes(wNodeFinder);
		var wLeftListNode = wNodeFinder.leftListNode;
		return wLeftListNode;
	},
	hasAddingLineInEmptyList: function() {
		return this.addingLineInEmptyList;
	},
	hasNodeIdToExpanded: function() {
		return this.nodeIdToExpanded !== NODE_INDEX_NULL;
	},
	memoAddingLineInEmptyList: function() {
		if (!this.addingLineInEmptyList) {
			this.addingLineInEmptyList = this.nodeIndex == NODE_INDEX_NULL;
		}
	},
	razModification: function() {
		CvgLeftList.prototype.razModification.call(this);
		this.addingLineInEmptyList = false;
		this.nodeIdToExpanded = NODE_INDEX_NULL;
	},
	serverRemoveAllLines: function() {
		CvgLeftList.prototype.serverRemoveAllLines.call(this);
		this.nodeIndex = NODE_INDEX_NULL;
	},
	setNodeIdToExpanded: function(aNodeId) {
		this.nodeIdToExpanded = aNodeId;
	},
	traverseAllSubNodes: function(aTraverser) {
		return this.traverseNodes(aTraverser, true);
	},
	traverseNodes: function(aTraverser, aWithSubNodes) {
		var wTraversingState = false;
		//  prise en compte des n lignes de premier niveau
		var wLeftListNode;
		var wI = 0;
		while (wI < this.size()) {
			wLeftListNode = this.getLine(wI);

			wTraversingState = aTraverser.doWhenTraverse(wLeftListNode, wI);
			/*
			 * prise en compte des n fils
			 */
			if (wTraversingState !== true && aWithSubNodes && wLeftListNode.hasSubNode()) {
				wTraversingState = wLeftListNode.traverseNodes(aTraverser, aWithSubNodes);
			}

			if (wTraversingState === true) {
				return true;
			}

			wI++;
		}
		return wTraversingState;
	},
	traverseSettable: function(aStructIst, aSetter) {
		if (aStructIst.isLineIst()) {
			var wI = aStructIst.idx;
			var wLeftListNode = this.findLeftListNode(wI);
			return aSetter.setModifiable(aStructIst, wLeftListNode);
		} else {
			return CvgLeftList.prototype.traverseSettable.call(this, aStructIst, aSetter);
		}
	},
	traverseSubNodes: function(aTraverser) {
		return this.traverseNodes(aTraverser, false);
	}
});