"use strict";
var helpers = require('syracuse-core/lib/helpers');
var CvgEntity = require('syracuse-x3/lib/convergence/model/CvgEntity').CvgEntity;
var CTraverser = Object; //require('syracuse-x3/lib/convergence/CTraverser').CTraverser;
var ArrayList = Array; //require('syracuse-x3/lib/convergence/ArrayList').ArrayList;
var CModificationsErazor = exports.CModificationsErazor = helpers.defineClass(function() {}, CTraverser, {
	doWhenTraverse: function(aValue, aIdx, aWhen) {
		if (!aValue) {
			return false;
		}
		if (aValue instanceof CvgEntity) {
			aValue.razModification();
		}
		if (typeof aValue.traverseChilds === 'function') {
			return aValue.traverseChilds(this);
		} else {
			return false; //pour ne pas arreter de "traverser" les "Values"
		}
	}
});

var CvgStackedWindows = exports.CvgStackedWindows = helpers.defineClass(function() {
	Array.call(this);
}, Array, {
	findWin: function(aWinId) {
		var wStackedWindow;
		var wMax = this.length;
		var wI = wMax - 1;
		while (wI > -1) {
			wStackedWindow = this[wI];
			if (wStackedWindow && wStackedWindow.entityIndexBaseOne === aWinId) {
				return wStackedWindow;
			}
			wI--;
		}
		return null;
	},
	popStackedWindow: function(winIst) {
		var winRank = winIst.win,
			poped, i;
		// console.log("rank to close : " + winRank + " - current stack length : " + this.length);
		if (winRank <= this.length) {
			// Oups, server has closed an other window than the last stacked!
			// console.log("CLOSE behind top stack");
			poped = this.splice(winRank - 2, 1, null);
			return poped[0];
		} else {
			poped = this.pop();
			i = this.length;
			while (i > 0) {
				// Cleanup zombie occurrences
				if (this[--i] == null) {
					this.pop();
				} else {
					break;
				}
			}
		}
		return poped;
	},
	pushStackedWindow: function(aStackedWindow, winRank) {
		// console.log("rank to open : " + winRank + " - current stack length : " + this.length);
		if (this.length >= winRank - 1) {
			// Oups, server has opened a window with a rank lower than the stack length!
			// console.log("OPEN behind top stack");
			this[winRank - 2] = aStackedWindow;
		} else {
			this.push(aStackedWindow);
		}
	},
	razModifications: function() {
		this.traverseChilds(new CModificationsErazor());
	},
	traverseAll: function(aTraverser) {
		var wStackedWindow;
		var wMax = this.length;
		var wI = wMax - 1;
		while (wI > -1) {
			wStackedWindow = this[wI];
			if (aTraverser.doWhenTraverse(wStackedWindow, wI) === true) {
				return true;
			}
			if (wStackedWindow.traverseAll(aTraverser) === true) {
				return true;
			}
			wI--;
		}
		return false;
	},
	traverseChilds: function(aTraverser) {
		var wMax = this.length;
		var wEntry;
		var wI = 0;
		while (wI < wMax) {
			wEntry = this[wI];

			if (aTraverser.doWhenTraverse(wEntry, wI) === true) {
				return true;
			}
			wI++;
		}
		return false;
	},
	traverseSettable: function(aStructIst, aSetter) {
		var wRequesterWindow = this.findWin(aStructIst.win);
		if (wRequesterWindow == null) {
			return false;
		}
		if (!aStructIst.isWindowIst()) {
			return wRequesterWindow.traverseSettable(aStructIst, aSetter);
		} else {
			return aSetter.setModifiable(aStructIst, wRequesterWindow);
		}
	}
});