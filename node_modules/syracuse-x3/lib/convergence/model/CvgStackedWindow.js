"use strict";
var helpers = require('syracuse-core/lib/helpers');
var CvgEntity = require('syracuse-x3/lib/convergence/model/CvgEntity').CvgEntity;
var CvgLeftList = require('syracuse-x3/lib/convergence/model/CvgLeftList').CvgLeftList;
var CvgListOfLocalMenus = require('syracuse-x3/lib/convergence/model/CvgListOfLocalMenusFactory').CvgListOfLocalMenus;
var CvgListOfLocalMenusFactory = require('syracuse-x3/lib/convergence/model/CvgListOfLocalMenusFactory').CvgListOfLocalMenusFactory;
var CvgListOfScreens = require('syracuse-x3/lib/convergence/model/CvgListOfScreens').CvgListOfScreens;
var CvgListOfDataSrcs = require('syracuse-x3/lib/convergence/model/CvgListOfDataSrcs').CvgListOfDataSrcs;
var CvgListOfDataSrcsFactory = require('syracuse-x3/lib/convergence/model/CvgListOfDataSrcsFactory').CvgListOfDataSrcsFactory;
var CvgListOfLeftLists = require('syracuse-x3/lib/convergence/model/CvgListOfLeftLists').CvgListOfLeftLists;
var CvgWindow = require('syracuse-x3/lib/convergence/model/CvgWindow').CvgWindow;
var CvgScreen = require('syracuse-x3/lib/convergence/model/CvgScreen').CvgScreen;
var CvgVariable = require('syracuse-x3/lib/convergence/model/CvgVariable').CvgVariable;
var CvgDataSrcLine = require('syracuse-x3/lib/convergence/model/CvgDataSrcLine').CvgDataSrcLine;

var CvgStackedWindow = require('syracuse-x3/lib/convergence/model/CvgStackedWindow').CvgStackedWindow;
var CvgListOfLeftListsFactory = require('syracuse-x3/lib/convergence/model/CvgListOfLeftListsFactory').CvgListOfLeftListsFactory;
var CvgStatusBar = require('syracuse-x3/lib/convergence/model/CvgStatusBar').CvgStatusBar;
var navPageHelper = require("syracuse-collaboration/lib/entities/page/navPageHelper");

var _lastTick = 0;

function _getTick() {
	// JavaScript number precision does not let us go beyond (fake) microsecond.
	var tick = Date.now() * 1000;
	if (tick <= _lastTick) {
		tick = _lastTick + 1;
	}
	_lastTick = tick;
	return tick;
}

function instanciate(windowDescription) {
	var windowNode = windowDescription;
	var windowType = parseInt(windowNode.$.TYF, 10); // type de fenetre adonix : girl=1, own=2 (modal), comment=3 (fenetre sans bouton), dialogue=4
	var windowModel = parseInt(windowNode.$.WTY, 10);
	var nbLignes = parseInt(windowNode.$.NLI, 10); // nombre de ligne du premier ecran
	var nbColonnes = parseInt(windowNode.$.NCO, 10); // nombre de colonne du premier ecran
	return new CvgWindow(windowModel, windowType, nbLignes, nbColonnes);
}

var CvgStackedWindow = exports.CvgStackedWindow = helpers.defineClass(function(aClient, aWindowId, aFunctionId, aDescr, aStamp, aEnityIndexBaseOne) {
	CvgEntity.call(this, aClient, aWindowId, aEnityIndexBaseOne, 'WINDOW');
	this.statusBar = null;
	this.cache = {};
	this.statusBarChange = false;
	this.opened = false;
	this.window = null;
	this.stamp = _getTick();
	this.menuList = null;
	this.ndOWinComplementDescr = null;
	// Identifiant Serveur de la DataSource "Liste Gauche" standard
	this.primaryLeftListId = null;
	this.screenToShow = -1;
	this.timeStamp = "";
	this.stackLevel = -1;
	// nom de la fonction ayant ouvert la fenetre
	this.functionId = aFunctionId;
	this.timeStamp = aStamp;
	this.localIndex = aEnityIndexBaseOne - 1;
	// Table des menus locaux associees au requester
	this.localMenus = new CvgListOfLocalMenus();
	this.screens = new CvgListOfScreens(this);
	this.listOfDataSrcs = new CvgListOfDataSrcs(this);
	this.listOfLeftLists = new CvgListOfLeftLists(this);
	this.descrDom = aDescr;
	this.dumpOpened = false;
	if (this.hasDescrDom()) {
		var timestamp = this.descrDom.$.TIM;
		if (timestamp == null || timestamp !== aStamp) {
			aStamp = this.descrDom.$.TIM;
		}
		this.window = instanciate(this.descrDom);
		CvgListOfLocalMenusFactory.instanciateLocalMenus(this, this.descrDom, this.localMenus);
		CvgStackedWindow.newScreens(this.client, this, this.descrDom, this.screens, this.listOfDataSrcs);
		CvgListOfLeftListsFactory.addLeftLists(this, this.screens, this.descrDom, this.listOfLeftLists);
	}
	// make the assocition between function code and screen name in order to build the breadcrumb
	var map = navPageHelper.getMenuItemMap();
	map[this.client.applicationName + "." + this.client.contractName + "." + this.id] = map[this.client.applicationName + "." + this.client.contractName + "." + this.functionId];

}, CvgEntity, {

	deleteCache: function(ist) {
		var split = ist.toString().split(",");
		if (split.length) {
			console.log("delete cache ", split.toString());

			var current = this.cache[split[0]] = this.cache[split[0]] ||  {};
			if (split.length === 4) {
				for (var i = 1; i < split.length - 2; i++) {
					current = current[split[i]] = current[split[i]] || {};
				}
				delete current[split[split.length - 2]];
			} else {
				for (var i = 1; i < split.length - 1; i++) {
					current = current[split[i]] = current[split[i]] || {};
				}
				delete current[split[split.length - 1]];

			}
		}
	},
	getCache: function(ist) {
		var split = ist.toString().split(",");
		if (split.length) {

			var current = this.cache[split[0]];
			if (split.length === 4) {
				for (var i = 1; current && i < split.length - 2; i++) {
					current = current[split[i]] = current[split[i]];
				}
				current = current[split[split.length - 1]];
				if (current)
					return current[split[split.length - 2]] && current[split[split.length - 2]].item;
				return null;
			} else {
				for (var i = 1; i < split.length - 1; i++) {
					current = current[split[i]];
				}
				if (current)
					return current[split[split.length - 1]] && current[split[split.length - 1]].item;
				return null;

			}
		}
		console.log("cache not found");
		return null;
	},
	addCache: function(ist, entity) {
		var split = typeof ist !== "string" ? ist.toString().split(",") : ist.split(",");
		if (split.length && split[0] !== "@" && split[1] !== "@" && split[2] !== "@") {
			var current = this.cache[split[0]] = this.cache[split[0]] ||  {};
			if (entity instanceof CvgVariable && (entity.srcLine instanceof CvgDataSrcLine) && split.length === 4) {
				for (var i = 1; i < split.length - 2; i++) {
					current = current[split[i]] = current[split[i]] || {};
				}
				current = current[split[split.length - 1]] = current[split[split.length - 1]] ||  {};
				current[split[split.length - 2]] = {
					item: entity
				};
			} else {
				for (var i = 1; i < split.length - 1; i++) {
					current = current[split[i]] = current[split[i]] || {};
				}
				current[split[split.length - 1]] = {
					item: entity
				};

			}
		}
		//console.log(this.cache);

	},
	addStatusIconDef: function(instance, aNumText, aTxt, aImgId, aActionId) {
		if (this.statusBar == null) {
			this.statusBar = new CvgStatusBar(this.client, this.id, this);
		}
		this.statusBarChange = true;
		this.statusBar.addIconDef(aNumText, aTxt, aImgId, aActionId);
	},
	finLocalMenu: function(aLocalMenuId) {
		return this.localMenus[aLocalMenuId];
	},
	getObservableId: function() {
		if (!this.getAdxId()) return null;
		return this.opened ? "Open-" + this.getAdxId() + this.stamp : "Close-" + this.getAdxId() + this.stamp;
	},
	getAdxId: function() {
		return this.entityIdxAlpha;
	},
	hasDescrDom: function() {
		return this.descrDom != null;
	},
	isOpened: function() {
		return this.opened;
	},
	loadDesrDom: function(aWindowId, forced) {
		/* TODO BRJOU
		 */
	},
	razModification: function() {
		CvgEntity.prototype.razModification.call(this);
		this.statusBarChange = false;
		this.statusBar && this.statusBar.razModification();
	},
	setMenuList: function(menuList) {
		this.menuList = menuList;
	},
	setNDOWinComplementDescr: function(aComplementDescr) {
		this.ndOWinComplementDescr = aComplementDescr;
		if (this.window != null && aComplementDescr.indexOf(';') > -1) {
			var wST = aComplementDescr.split(';');
			if (wST.length >= 3) {
				// wST[0]; // titre
				this.window.setNbLignes(wST[1]); // ligne
				this.window.setNbColonnes(wST[2]); // colonne
			}
		}
	},
	setOpened: function(opened) {
		this.opened = opened;
		//this.setJsonType('FUNC'); // close or open function
		if (this.opened === false) {
			// Clean blobs from SvcBlob
			this.client.services.blobSvc.unregister(this.getAdxId());
		}
		// En dernier
	},
	setScreenToShow: function(aScreenToShow) {
		this.screenToShow = aScreenToShow;
	},
	setStackLevel: function(stackLevel) {
		this.stackLevel = stackLevel;

	},
	toJSON: function() {
		// dump only for open of close function, the dump of entity is done by payloadWin objects
		var winO = {};
		if (this.isOpened()) {
			winO.name = this.id;
			winO.scrnNum = this.screenToShow >= 1 ? this.screenToShow : 1;
			winO.stamp = this.timeStamp;
			winO.extend = this.ndOWinComplementDescr;
			winO.func = this.functionId;
			winO.type = this.window.type;
			// LeftList has the capability to alter representations (model)
			//- >check if the left list have change fmt and/or title to add appendModel
			for (var it in this.listOfLeftLists) {
				var item = this.listOfLeftLists[it];
				if (item instanceof CvgLeftList) {
					var proto = item.overrideProto();
					if (proto) {
						if (!winO.appendModel) winO.appendModel = {};
						//Override description
						winO.appendModel[item.getJsonKey()] = proto;
					}
				}
			}
			winO.mnu = this.menuList == null ? [] : this.menuList.toJSON();
		}
		return winO;
	},
	traverseAll: function(aTraverser) {
		return this.screens.traverseAll(aTraverser);
	},
	traverseChilds: function(aTraverser) {
		return this.screens.traverseChilds(aTraverser);
	},
	traverseSettable: function(aStructIst, aSetter) {
		// use cache for elements of stacked window
		var c = this.getCache(aStructIst.toString());
		if (c) {

			return aSetter.setModifiable(aStructIst, c);
		}
		//console.log("NEU " + aStructIst.toString());
		var self = this;
		var sm = aSetter.setModifiable;
		aSetter.setModifiable = function(ist, obj) {
			self.addCache(ist, obj); // include in cache
			sm.call(aSetter, ist, obj); // call original method
			aSetter.setModifiable = sm; // restore method
		};
		return this.screens.traverseSettable(aStructIst, aSetter);
	}
});

CvgStackedWindow.newScreens = function(client, requesterWindow, windowDescription, screens, listOfDataSrcs) {
	var screensNodes = windowDescription.DATASOURCES.SCRN;
	var max = Array.isArray(screensNodes) ? screensNodes.length : 1;
	var screenNode;
	var screen;
	// String wValue;
	var i = 0;
	while (i < max) {
		screenNode = max === 1 ? screensNodes : screensNodes[i];
		var id = screenNode.$.NAM;
		screen = new CvgScreen(requesterWindow, i + 1, id);
		screens.pushEntity(id, screen);
		CvgListOfDataSrcsFactory.newScreenDataSrcs(requesterWindow, screenNode, screen, listOfDataSrcs);
		i++;
	}
};