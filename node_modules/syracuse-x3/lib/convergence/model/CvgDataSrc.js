"use strict";
var CvgVariable = require('syracuse-x3/lib/convergence/model/CvgVariable').CvgVariable;
var helpers = require('syracuse-core/lib/helpers');
var CvgEntity = require('syracuse-x3/lib/convergence/model/CvgEntity').CvgEntity;


var ACT_INS = 1;
var ACT_DEL = 0;
var IDX_ACT = 0;
var IDX_IDX = 1;
var IDX_NBLINE = 2;

var CvgLineMove = exports.CvgLineMove = helpers.defineClass(function(lefList) {
	this.lefList = lefList;
	this.mvts = [];
	this.removeAll = false;
	this.reset();
}, null, {
	addDelete: function(nbLines, idx) {
		// Idx Ok
		this.mvts.push([ACT_DEL, idx, nbLines]);
	},
	// $mvt[i][0] intege Operation code. 0 : delete - 1 : insert
	// $mvt[i][1] integer The one-based location in the array from which to
	// start apply operation
	// $mvt[i][2] string The number of lines involved in the operation
	addInsert: function(nbLines, idx) {
		if (this.lefList && this.mvts.length !== 0) {
			// Cumul pour left list
			var x = this.mvts[0];
			x[IDX_NBLINE] = x[IDX_NBLINE] + 1;
		} else {
			// idx +1 car X3 0 based
			this.mvts.push([ACT_INS, idx + 1, nbLines]);
		}
	},
	removeAllLines: function() {
		this.removeAll = true;
	},
	reset: function() {
		this.removeAll = false;
		this.mvts = [];
	},
	toJSON: function() {
		var result = [];
		if (this.removeAll) {
			// "$mvt": [[0]]
			result.push([ACT_DEL]);
		}
		var size = this.mvts.length;
		if (size > 0) {
			if (size === 1) {
				result.push(this.mvts[0]);
			} else {
				// clone -> prev is momdified
				var prev = this.mvts[0].slice(0),
					cur = null;
				var curAct, prevAct, curIdx, prevIdx, curNb, prevNb;
				var cumul;
				for (var i = 1; i < size; i++) {
					cumul = false;
					cur = this.mvts[i];
					curAct = cur[IDX_ACT]; // action current move
					prevAct = prev[IDX_ACT]; // action previous move
					if (curAct === prevAct) {
						curIdx = cur[IDX_IDX];
						prevIdx = prev[IDX_IDX];
						curNb = cur[IDX_NBLINE];
						prevNb = prev[IDX_NBLINE];
						if (curAct === 0 && curIdx === prevIdx || curAct === 1 && curIdx === prevIdx + prevNb) {
							// Mvts:[[1,4,1],[1,5,3],[1,6,2],[1,7,1],[1,8,1]] -> [1,4,8]
							// Mvts:[[0,4,1],[1,4,3],[1,4,2],[1,4,1],[1,4,1]] -> [0,4,8]
							prev[IDX_NBLINE] += curNb;
							cumul = true;
						}
					}
					if (!cumul) {
						result.push(prev);
						// clone -> prev is momdified
						prev = cur.slice(0);
					}
				}
				result.push(prev);
			}
		}
		return result;
	},
	toJsonX3Mvts: function() {
		var result = {};
		result.mvts = this.mvts;
		result.removeAll = this.removeAll;
		return result;
	}
});

function emptyJson(o) {
	if (o == null) return true;
	if (Array.isArray(o)) return o.length === 0;
	return Object.keys(o).length === 0; // TODO: find faster test
}

var CvgDataSrc = exports.CvgDataSrc = helpers.defineClass(function(aRequester, aScreen, aEntityIndexBaseOne, aDataSourceID, aDim, aNbField, aVarBasPage, dataSrcType) {
	dataSrcType = dataSrcType !== undefined ? dataSrcType : CvgDataSrc.TYPE_SCREEN;
	CvgEntity.call(this, aRequester && aRequester.client, aDataSourceID, aEntityIndexBaseOne, 'BLOC');
	// Record "suplementaire" pour gerer la ligne a cloner
	this.entrySup = null;
	this.dataSrcType = dataSrcType;
	this.listEventLine = new CvgLineMove(dataSrcType === CvgDataSrc.TYPE_LEFTLIST);
	// Vecteur des lignes de la DataSource
	this.lines = [];
	this.stackedWindow = aRequester;
	this.screen = aScreen;
	// Dimension de la datasource ex:250 pour un tableau
	this.dim = aDim < 1 ? 1 : aDim;
	// Nombre de colonne de la datasource
	this.nbColumns = aNbField;
	// Id de la variable de bas de page
	this.varBasPage = aVarBasPage;
	// En dernier
	this.setJsonType('ENTITY');
}, CvgEntity, {
	appendFirstBlankLine: function(srcLine) {
		this.lines.push(srcLine);
		srcLine.setZeroBaseIdx(0);
		this.fusionMvtsInsert(1, 0);
	},
	appendLeftListLine: function(l) {
		this.lines.push(l);
		if (l != null && l.isFlatLeftList()) {
			this.fusionMvtsInsert(1, 0); // index 0 base and not 1
		}
	},
	blocFicheGetChilds: function() {
		var l = this.getFirstLine();
		if (l == null || l.vars == null) {
			throw new Error("List bloc - Unexpected null first line");
		}
		return l.vars;
	},
	buildMessErrorTraverse: function(aStructIst, aSetter, aKeyOfMessSuffix) {
		var wMess = this.client.getMessage('ERROR_TRAVERSE_SETTABLE', aStructIst.toString(), this.getAdxId(), module.id);
		// TODO TCA
		// aStructIst.toString() doesn't return correct value
		// this.getAdxId() doesn't return correct value
		// module.id isn't corresponding to aSetter.class
		//wMess = locale.format(wMess, aStructIst.toString(), this.getAdxId(), CStringFacilities.getClasseName(aSetter.class));
		return wMess + this.client.getMessage(aKeyOfMessSuffix);
	},
	fusionMvtsDelete: function(nbLines, idx) {
		//console.log(this.id + " - Mvt delete - nbLines[" + nbLines + "] - idx[" + idx + "]");
		this.listEventLine.addDelete(nbLines, idx);
		// Notifie datasrc to genarate JSON
		this.forceChange();
	},
	fusionMvtsInsert: function(nbLines, idx) {
		//console.log(this.id + " - Mvt insert - nbLines[" + nbLines + "] - idx[" + idx + "]");
		this.listEventLine.addInsert(nbLines, idx);
	},
	fusionMvtsRemoveAll: function() {
		this.listEventLine.removeAllLines();
		// Notifie datasrc to genarate JSON
		this.forceChange();
	},
	fusionMvtsReset: function() {
		this.listEventLine.reset();
	},
	getAdxId: function() {
		return this.screen == null ? null : "" + this.screen.getAdxId() + ',' + this.entityIdxAlpha;
	},
	getFirstLine: function() {
		return this.lines.length > 0 ? this.lines[0] : null;

	},
	getJsonMetadata: function(map, metadata) {
		var CvgDataSrcLine = require('syracuse-x3/lib/convergence/model/CvgDataSrcLine').CvgDataSrcLine;
		var CvgVariable = require('syracuse-x3/lib/convergence/model/CvgVariable').CvgVariable;
		var keys = Object.keys(map).sort(function(a, b) {
			return a - b;
		});
		var meta = [];
		var itemJs = null;
		for (var i in keys) {
			var key = keys[i];
			itemJs = [];
			var item = map[key];
			var obsId ;
			if (item instanceof CvgDataSrcLine || item instanceof CvgDataSrc) {
				obsId = this.getObservableId();
			}else{
				obsId = item.getObservableId();
			}
			// remove win id from fullid
			obsId = obsId.substring(1);
			itemJs.push(obsId); // id instance
			if (item instanceof CvgVariable) {
				if (item.srcLine === this.entrySup) {
					// it's a colomn
					itemJs.push(0);
				} else {
					// it's a cell  retrinve line number
					var lineNumber = -1;
					if (item.srcLine instanceof CvgDataSrcLine) {
						lineNumber = item.srcLine.zeroBaseLineIdx + 1;
					}
					itemJs.push(lineNumber);
				}
			} else if (item instanceof CvgDataSrcLine) {
				// it's a line
				itemJs.push(item.zeroBaseLineIdx + 1);
			} else if (item instanceof CvgDataSrc) {
				// it's a line
				itemJs.push(0);
			}
			// indice colomn, cellule
			switch (metadata) {
				case 'STY':
					itemJs.push(item.style); // style
					break;
				case 'STT':
					itemJs.push(item.state); // style
					break;
				case 'FMT':
					if (item.format != null) {
						itemJs.push(item.format.format); // style
					}
					break;
				case 'TIT':
					if (item.title != null) {
						itemJs.push(item.title); // style
					}
					break;
			}
			meta.push(itemJs);
		}
		return meta;
	},
	getLastLine: function() {
		return this.lines.length > 0 ? this.lines[this.lines.length - 1] : null;

	},
	getLine: function(idx) {
		return this.lines[idx];
	},
	// return true if this data source admit column
	hasColumn: function() {
		return this.hasEntrySup();
	},
	// Retourne vrai si la dimension est depassee !
	hasDimOverFlow: function() {
		return this.lines.length > this.dim;
	},
	// return true if EntrySup is not null ( admit entry
	hasEntrySup: function() {
		return this.entrySup != null;
	},
	//retourne si un variable "baspag" est associee a la DataSource
	hasVarBasPage: function() {
		return this.varBasPage != null && this.varBasPage.length > 0;
	},
	isBlocFiche: function() {
		return this.dataSrcType === CvgDataSrc.TYPE_SCREEN && this.dim === 1 && !this.hasVarBasPage();
	},
	isBlocGrid: function() {
		return this.isLeftList() || this.isBlocTableau();
	},
	isBlocTableau: function() {
		return this.dataSrcType === CvgDataSrc.TYPE_SCREEN && this.hasVarBasPage(); // this.dim>1;
	},
	isLeftList: function() {
		return this.dataSrcType === CvgDataSrc.TYPE_LEFTLIST;
	},
	manageMetadata: function(map, line, metadata, lastLine) {
		// check if we need to add change metadata about
		var stampLine = -1;
		var hasValue = false;
		switch (metadata) {
			case 'STY':
				stampLine = line.lastStampModSty;
				hasValue = line.style != null;
				break;
			case 'ACT':
				stampLine = line.lastStampModActzo;
				hasValue = stampLine !== -1;
				break;
			case 'SEL':
				stampLine = line.lastStampModSelected;
				hasValue = stampLine !== -1;
				break;
			case 'VIS':
				stampLine = line.lastStampModVisible;
				hasValue = stampLine !== -1;
				break;
			case 'FMT':
				stampLine = line.lastStampModFmt;
				hasValue = line.format != null;
				break;
			case 'TIT':
				stampLine = line.lastStampModTit;
				hasValue = line.title != null;
				break;
		}

		// check if a colomn has apply a style before
		if (this.entrySup != null) {
			var colEntity = this.entrySup.getListEntityOlderThan(metadata, stampLine, true);
			for (var key in colEntity) map[key] = colEntity[key];
		}
		if (hasValue && stampLine !== -1) {
			map[stampLine] = line;
		}
		// check if an item of the line has a different value
		// for metadata and if the colomn has not the same status we add him
		// analyse list of variable on current line even no change has been done
		// on current line
		var colDiff = line.getListEntityDifferentValue(metadata);
		//console.log("manageMetadata colDiff\n"+ JSON.stringify(colDiff,null,2))
		for (var key in colDiff) map[key] = colDiff[key];

		if (lastLine) {
			// generate style for all column that are younger that the last line
			if (this.entrySup != null) {
				var colEntity = this.entrySup.getListEntityOlderThan(metadata, stampLine, false);

				for (var key in colEntity){
					map[key] = colEntity[key];
				}
			}
			var colDiff = line.getListEntityDifferentValue(metadata);
			for (var key in colDiff) map[key] = colDiff[key];
		}
	},
	manageTableMetadata: function(map, metadata) {
		
		var hasValue = false;
		var stamp = -1
		var meta = metadata.length > 3 ? metadata.substring(0,4) : metadata;
		switch (metadata) {
			case 'STY':
				stamp = this.lastStampModSty;
				hasValue = this.style != null;
				break;
			case 'ACT':
				stamp = this.lastStampModActzo;
				hasValue = stamp !== -1;
				break;
			case 'VIS':
				stamp = this.lastStampModVisible;
				hasValue = stamp !== -1;
				break;
			case 'SEL':
				stamp = this.lastStampModSelected;
				hasValue = stamp !== -1;
				break;
		}
		
		if (hasValue && stamp !== -1) {
			for(var item in map){
				if( item < stamp )
					delete map[item];
			}
			map[stamp] = this;
		}
	},
	razModification: function() {
		for (var line in this.lines) {
			this.lines[line].razModification();
		}
		if (this.entrySup != null) {
		}
		// Reset des modification des mouvements fusion en fin de request client
		this.fusionMvtsReset();
		CvgEntity.prototype.razModification.call(this);
	},
	// insert "apres" aTargetLine
	serverInsertLines: function(zeroBasedIdx, nbLines) {
		for (var i = 0; i < nbLines; i++) {
			// CvgDataSrcLine constructor Notify oberver that a new line has been created
			var srcLine = this.entrySup.clone();
			// GLUTE : gestion des formats dans les colonnes des tableaux pour associer chacune des variables de la nouvelle ligne a sa correspondante dans la ligne "this.entrySup"
			// Note: sert a la propagation du format courant a chaque modification de valeur
			srcLine.setFormaterEntity(this.entrySup);
			this.lines.splice(zeroBasedIdx + i, 0, srcLine);
		}
		this.updateIdx(zeroBasedIdx);
		this.fusionMvtsInsert(nbLines, zeroBasedIdx);
	},
	// Supprime toutes les lignes de la dataSource
	serverRemoveAllLines: function() {
		this.lines = [];
		this.fusionMvtsRemoveAll();

	},
	serverRemoveLines: function(startX3Idx, nbLines) {
		var stop = startX3Idx - 1;
		var start = Math.min(stop + nbLines, this.lines.length);
		this.lines.splice(stop, start - stop);
		this.fusionMvtsDelete(nbLines, startX3Idx);
		this.updateIdx(stop);
	},
	//  Met en place une Entry suplementaire pour les datasources qui ont une
	setEntrySup: function(aDataSrcEntry) {
		this.entrySup = aDataSrcEntry;
	},
	setServerStyle: function(aStyle, applyOn) {
		if ('CHILDS' === applyOn && this.isBlocFiche()) {
			var children = this.blocFicheGetChilds();
			for (var v in children) {
				children[v].setServerStyle(aStyle, 'ENTITY');
			}
		} else {
			CvgEntity.prototype.setServerStyle.call(this, aStyle, applyOn);
		}
	},
	size: function() {
		return this.lines.length;
	},
	toJSON: function() {
		var object = {};
		if (this.isBlocGrid()) {
			// construct metadata json object
			var mapSty = {};
			var mapFmt = {};
			var mapVis = {};
			var mapSel = {};
			var mapAct = {};
			var mapStt = {};
			var mapTit = {};
			var mapDch = null;
			// $rcd
			var records = [];
			for (var i = 0; i < this.lines.length; i++) {
				var line = this.lines[i];
				if (line != null && !line.isDisposed()) {
					this.toJsonAddRCD(line, records);
					// treatement of metadata style - !! a optimiser
					var lastLine = i === this.lines.length - 1;
					this.manageMetadata(mapSty, line, 'STY', lastLine);
					this.manageMetadata(mapSel, line, 'SEL', lastLine);
					this.manageMetadata(mapVis, line, 'VIS', lastLine);
					console.log("mapVis "+JSON.stringify(mapVis));
					this.manageMetadata(mapAct, line, 'ACT', lastLine);
					this.manageMetadata(mapFmt, line, 'FMT', lastLine);
					this.manageMetadata(mapTit, line, 'TIT', lastLine);
					// DCH - cell by cell
					if (line.comboDchModifhas()) {
						if (mapDch == null) {
							mapDch = [];
						}
						line.comboDchAddJSON(mapDch);
					}
				}
			}

			this.manageTableMetadata(mapSty, 'STY');
			this.manageTableMetadata(mapVis, 'VIS');
			this.manageTableMetadata(mapAct, 'ACT');
			this.manageTableMetadata(mapSel, 'SEL');
			
			// get list of all entity first for metat state
			var metaEntity = [];
			for(var item in mapVis){
				metaEntity.push(mapVis[item]);
			}
			for(item in mapAct){
				metaEntity.push(mapAct[item]);
			}
			for(item in mapSel){
				metaEntity.push(mapSel[item]);
			}
			
			// create map of entity state 
			console.log("metaEntity  "+JSON.stringify(metaEntity));
			for(var i=0;i< metaEntity.length;i++){
				
				mapStt[metaEntity[i].calculateState()]= metaEntity[i];
			}
			console.log("mapStt  "+JSON.stringify(mapStt));

			if (!emptyJson(records)) {
				object.$rcd = records; // add record table that represent
			}
			object.$mvt = this.listEventLine.toJSON();
			
			// Not necessary
			//object.X3Mvts = this.listEventLine.toJsonX3Mvts();
			// create metadata
			var metadata = {};
			if (mapDch != null) {
				metadata.dch = mapDch;
			}
			var sty = this.getJsonMetadata(mapSty, 'STY');
			if (!emptyJson(sty)) {
				metadata.sty = sty;
			}
			var fmt = this.getJsonMetadata(mapFmt, 'FMT');
			if (!emptyJson(fmt)) {
				metadata.fmt = fmt;
			}
			var stt = this.getJsonMetadata(mapStt, 'STT');
			if (!emptyJson(stt)) {
				metadata.stt = stt;
			}
			var tit = this.getJsonMetadata(mapTit, 'TIT');
			if (!emptyJson(tit)) {
				metadata.tit = tit;
			}
			if (!emptyJson(metadata)) {
				object.$meta = metadata;
			}
		}
		return object;
	},

	// Pour surcharge par liste recursive
	toJsonAddRCD: function(line, record) {
		var lineJSon = line.toJSON();
		if (lineJSon != null) {
			record.push(lineJSon);
		}
		return lineJSon;
	},
	traverseAll: function(aTraverser) {
		var wMax = this.lines.length;
		var wDataSrcLine;
		var wI = 0;
		while (wI < wMax) {
			wDataSrcLine = this.getLine(wI);
			if (aTraverser.doWhenTraverse(wDataSrcLine, wI) === true) {
				return true;
			}
			if (wDataSrcLine.traverseAll(aTraverser) === true) {
				return true;
			}
			wI++;
		}
		return false;
	},
	traverseChilds: function(aTraverser) {
		var wTraversingState = false;
		var wMax = this.lines.length;
		if (this.hasEntrySup()) {
			wTraversingState = aTraverser.doWhenTraverse(this.entrySup, -1);
			if (wTraversingState === true) {
				return true;
			}
		}
		var wI = 0;
		while (wI < wMax) {
			wTraversingState = aTraverser.doWhenTraverse(this.getLine(wI), wI);
			if (wTraversingState === true) {
				return true;
			}
			wI++;
		}
		return wTraversingState;
	},

	/**
	 * 14w_005 - bug 30654 - mise en place mode "envoi pour rebind"
	 * <p>
	 * Propagation du changement d'etat sur toutes les lignes existante de la
	 * datasource
	 *
	 * 14w_006 - Bug 31739 - gestion tableau
	 * <p>
	 * Application des regles de propagations des changements d'etat
	 * fonctionnant dans le client X3
	 * <li>si sAdxidTarget.nAdxid est de type GRID et sAdxidTarget.nNumLine ==
	 * -1 : on applique le cState a toutes les cellules du tableau
	 * <li>si sAdxidTarget.nAdxid est de type GRID et sAdxidTarget.nNumLine > 0
	 * : on applique le cState a toutes les cellules de la ligne
	 * <li>si sAdxidTarget.nAdxid correspond a une colonne et
	 * sAdxidTarget.nNumLine === -1 : on applique le cState a toutes les cellules
	 * de la colonne
	 * <li>si sAdxidTarget.nAdxid correspond a une colonne et
	 * sAdxidTarget.nNumLine > 0 : on applique le cState a la cellule
	 * colonne/ligne
	 *
	 * @param aStructIst
	 * @param aSetter
	 * @return
	 */
	traverseSettable: function(aStructIst, aSetter) {
		var CActiveStateSetter = require('syracuse-x3/lib/convergence/client/CvgRequest').CActiveStateSetter;
		try {
			// Si la porte est une colonne ou toutes les lignes d'une colonne
			// ATTENTION : il
			// faut tester "this.dim>1 && isColumnIst()" avant "isFieldIst()" car si
			// this.dim>1 on a
			// egalite entre "isColumnIst()" et "isFieldIst()"
			// 16w_115 - gestion des tableau de dimension 1 // on execute
			// traverseSettable si on admet des colonnes
			if (this.hasColumn() && aStructIst.isColumnIst() || aStructIst.isAllLinesOfColumnIst()) {
				// Application sur la ligne suplementaire EntrySup
				var wContinue = this.entrySup.traverseSettable(aStructIst, aSetter);
				// si c'est un changement d'etat: application sur toutes les
				// lignes (pour une colonne)
				if (wContinue && aSetter instanceof CActiveStateSetter) {
					wContinue = this.traverseSettableLines(aStructIst, aSetter);
				}
				return wContinue;
			}
			// Si la porte est le champ ou la ligne: application sur l'entite
			// inferieure designee
			else if (aStructIst.isFieldIst() || aStructIst.isLineIst()) {
				var wI = this.dim > 1 ? aStructIst.idxZeroBase : 0;
				// si numero de ligne incorrect
				if (wI < 0 || wI >= this.lines.length) {
					var wMess = this.client.getMessage('ERROR_LINE_UNKNOWN', wI, this.lines.length, this.getAdxId());
					aSetter.setLogicalErrMess(wMess);
					return false;
				}
				var wDataSrcLine = this.getLine(wI);
				return wDataSrcLine == null ? false : wDataSrcLine.traverseSettable(aStructIst, aSetter);
			}
			// Si la porte est le bloc ou toutes les lignes du bloc :
			// application sur le bloc.
			else if (aStructIst.isBlocIst() || aStructIst.isAllLinesOfBlocIst()) {
				// Application sur le bloc
				var wContinue = aSetter.setModifiable(aStructIst, this);
				// si c'est un changement d'etat :
				if (wContinue && aSetter instanceof CActiveStateSetter) {
					// 16w_104 - Fiche 51885 - RH V5 : zone non saisissable en
					// Web
					// Application sur la ligne suplementaire EntrySup
					wContinue = this.entrySup.traverseSettable(aStructIst, aSetter);
					if (wContinue) {
						// application sur toutes les lignes (pour toutesles
						// colonnes)
						wContinue = this.traverseSettableLines(aStructIst, aSetter);
					}
				}
				return wContinue;
			} else {
				aSetter.setLogicalErrMess(this.buildMessErrorTraverse(aStructIst, aSetter, 'ERROR_TRAVERSE_SETTABLE_CASE'));
				return true;
			}
		} catch (e) {
			var wMess = this.buildMessErrorTraverse(aStructIst, aSetter, 'ERROR_TRAVERSE_SETTABLE_EXCEPT');
			aSetter.setLogicalErrMess(wMess + ' ' + e);
			throw e;
		}
	},
	traverseSettableLines: function(aStructIst, aSetter) {
		var wContinue = true;
		var wI = 0;
		var wMax = this.lines.length;
		var wDataSrcLine;
		while (wI < wMax && wContinue) {
			wDataSrcLine = this.getLine(wI);
			wContinue = wDataSrcLine.traverseSettable(aStructIst, aSetter);
			wI++;
		}
		return wContinue;
	},
	updateIdx: function(startIdx) {
		for (var i = startIdx, l = this.lines.length; i < l; i++) {
			this.lines[i].setZeroBaseIdx(i);
		}
	}
});

CvgDataSrc.TYPE_LEFTLIST = 'Q';
CvgDataSrc.TYPE_SCREEN = 'E';

