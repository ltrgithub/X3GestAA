"use strict";
var CvgVariable = require('syracuse-x3/lib/convergence/model/CvgVariable').CvgVariable;
var CvgDataSrcLine = require('syracuse-x3/lib/convergence/model/CvgDataSrcLine').CvgDataSrcLine;
var CvgObservable = require('syracuse-x3/lib/convergence/model/CvgObservable').CvgObservable;

var helpers = require('syracuse-core/lib/helpers');
var CvgEntity = require('syracuse-x3/lib/convergence/model/CvgEntity').CvgEntity;
var perfmon = require('syracuse-perfmon');
var x3helpers = require('syracuse-x3/lib/helpers');
var localConfig = x3helpers.config("x3fusion", null, {});
var perfmonEnabled = x3helpers.config("perfmon.activate", localConfig);
var perfmonDetail = x3helpers.config("perfmon.detail", localConfig);
var tracerStd = require("syracuse-trace/lib/helper").getTracer("classic.std");
var CActiveStateSetter;

var ACT_INS = 1;
var ACT_DEL = 0;
var IDX_ACT = 0;
var IDX_IDX = 1;
var IDX_NBLINE = 2;

var CvgLineMove = exports.CvgLineMove = helpers.defineClass(function() {
	this.mvts = [];
	this.removeAll = false;
	this.reset();
}, null, {
	addDelete: function(nbLines, idx) {
		if (nbLines > 0) {
			// Idx Ok
			idx = idx + 1;
			this.mvts.push([ACT_DEL, idx, nbLines]);
		}
	},
	// $mvt[i][0] intege Operation code. 0 : delete - 1 : insert
	// $mvt[i][1] integer The one-based location in the array from which to
	// start apply operation
	// $mvt[i][2] string The number of lines involved in the operation
	addInsert: function(nbLines, idx) {
		if (nbLines > 0) {
			// idx +1 car X3 0 based
			this.mvts.push([ACT_INS, idx + 1, nbLines]);
		}
	},
	removeAllLines: function() {
		this.removeAll = true;
		this.mvts = [
			[ACT_DEL]
		];
	},
	reset: function() {
		this.removeAll = false;
		this.mvts = [];
	},
	toJSON: function() {

		var result = [];

		var size = this.mvts.length;
		// clone -> prev is momdified
		if (size > 0) {
			var prev = this.mvts[0].slice(0),
				cur = null;
			var curAct, prevAct, curIdx, prevIdx, curNb, prevNb;
			var i, cumul;
			for (i = 1; i < size; i++) {
				cumul = false;
				cur = this.mvts[i];
				curAct = cur[IDX_ACT]; // action current move
				prevAct = prev[IDX_ACT]; // action previous move
				if (curAct === prevAct) {
					curIdx = cur[IDX_IDX];
					prevIdx = prev.length === 3 ? prev[IDX_IDX] : 0;
					curNb = cur[IDX_NBLINE];
					prevNb = prev.length === 3 ? prev[IDX_NBLINE] : 0;
					if (curAct === 0 && curIdx === prevIdx || curAct === 1 && curIdx === prevIdx + prevNb) {
						// Mvts:[[1,4,1],[1,5,3],[1,6,2],[1,7,1],[1,8,1]] -> [1,4,8]
						// Mvts:[[0,4,1],[1,4,3],[1,4,2],[1,4,1],[1,4,1]] -> [0,4,8]
						prev[IDX_NBLINE] += curNb;
						cumul = true;
					}
				}
				if (!cumul) {
					result.push(prev);
					// clone -> prev is momdified
					prev = cur.slice(0);
				}
			}
			result.push(prev);

		}
		return result;

	},
	toJsonX3Mvts: function() {
		var result = {};
		result.mvts = this.mvts;
		result.removeAll = this.removeAll;
		return result;
	}
});

function emptyJson(o) {
	if (o == null) {
		return true;
	}
	if (Array.isArray(o)) {
		return o.length === 0;
	}
	return Object.keys(o).length === 0; // TODO: find faster test
}

var CvgDataSrc = exports.CvgDataSrc = helpers.defineClass(function(aRequester, aScreen, aEntityIndexBaseOne, aDataSourceID, aDim, aNbField, aVarBasPage, dataSrcType) {
	dataSrcType = dataSrcType !== undefined ? dataSrcType : CvgDataSrc.TYPE_SCREEN;
	CvgEntity.call(this, aRequester && aRequester.client, aDataSourceID, aEntityIndexBaseOne, 'BLOC', aRequester);
	// Record "suplementaire" pour gerer la ligne a cloner
	this.entrySup = null;
	this.win = aRequester;
	this.dataSrcType = dataSrcType;
	this.listEventLine = new CvgLineMove();
	// Vecteur des lignes de la DataSource
	this.lines = [];
	this.linesModified = {};
	this.stackedWindow = aRequester;
	this.screen = aScreen;
	// Dimension de la datasource ex:250 pour un tableau
	this.dim = aDim < 1 ? 1 : aDim;
	// Nombre de colonne de la datasource
	this.nbColumns = aNbField;
	// Id de la variable de bas de page
	this.varBasPage = aVarBasPage;
	// initialize metadata scope
	this.initMetaScope();
	this.metaChange = false;
	this.metaMap = {
		"PCOL": {},
		"STY": {},
		"ACT": {},
		"SEL": {},
		"VIS": {},
		"FMT": {},
		"STT": {},
		"TIT": {}
	};
	// En dernier
	this.setJsonType('ENTITY');
}, CvgEntity, {
	initMetaScope: function() {
		this.metaScope = {
			full: false,
			lines: {},
		};
		this.metaMap = {
			"PCOL": {},
			"STY": {},
			"ACT": {},
			"SEL": {},
			"VIS": {},
			"FMT": {},
			"STT": {},
			"TIT": {}
		};
	},
	getMetaMapToJSON: function() {

		function _computeState(key, item) {
			if (key === "STT" && item && typeof item === "object" && item.value.calculateState) {
				item.value.calculateState();
				return {
					value: item.value.state,
					extra: item.value.getReadableState()
				};
			}
			return item;
		}
		var meta = {};
		var self = this;
		var mapKey = ["STT", "STY", "FMT", "TIT"];
		mapKey.forEach(function(key) {
			var m = meta[key.toLowerCase()] = meta[key.toLowerCase()] || [];
			// compute state if it's stt and a object is store as a value

			if (self.metaMap[key].grid) {
				var item = self.metaMap[key].grid;
				if (item.$id) {

					item.$val = _computeState(key, item.$val);

					var tab = [item.$id, 0, item.$val.value];
					if (item.$val.extra) {
						tab.push(item.$val.extra);
					}
					tab.push(item.$stamp);
					m.push(tab);
				}
			};
			self.metaMap[key].line && Object.keys(self.metaMap[key].line).forEach(function(kLine) {

				var line = self.metaMap[key].line[kLine];

				if (line.$id) {
					line.$val = _computeState(key, line.$val);

					var tab = [line.$id, kLine, line.$val.value];
					if (line.$val.extra) {
						tab.push(line.$val.extra);
					}
					tab.push(line.$stamp);
					m.push(tab);
				}
				line && Object.keys(line).filter(function(i) {
					return i.indexOf(0) !== '$';
				}).forEach(function(k) {
					var item = self.metaMap[key].line[kLine][k];

					if (item.$id) {
						item.$val = _computeState(key, item.$val);

						tab = [item.$id, kLine, item.$val.value];
						if (item.$val.extra) {
							tab.push(item.$val.extra);
						}
						tab.push(item.$stamp);
						m.push(tab);
					}
				});
			});
			self.metaMap[key].col && Object.keys(self.metaMap[key].col).forEach(function(kLine) {

				var v = self.metaMap[key].col[kLine];
				if (v.$id) {
					v.$val = _computeState(key, v.$val);
					var tab = [v.$id, 0, v.$val.value];
					if (v.$val.extra) {
						tab.push(v.$val.extra);
					}
					tab.push(v.$stamp);
					m.push(tab);
				}
			});
			// sort meta
			m = m.sort(function(a, b) {
				if (a[a.length - 1] < b[b.length - 1]) {
					return -1;
				} else {
					return 1;
				}
			}).forEach(function(item) {
				// remove stamp that have been used for sorting the array of array
				item.splice(-1);
			});
		});

		return meta;

	},
	notifyStampValueMeta: function(metadata, value, lastStampMod) {
		this.notifyStampMeta(metadata, "grid," + this.id, value, lastStampMod, this.getObservableId().substring(1));
	},
	notifyStampMeta: function(meta, id, val, stamp, dumpId) { // id is the line number or line number + vars number or column
		var split = id.split(',');
		var metakey = meta;
		this.metaChange = true;
		this.metaMap[meta].line = this.metaMap[meta].line ||  {};
		this.metaMap[meta].col = this.metaMap[meta].col ||  {};

		if (split.length === 2) { // modif line or column only
			if (split[0] === "grid") {
				this.metaMap[meta].grid = {
					$val: val,
					$stamp: stamp,
					$id: dumpId
				};
				if (meta !== "STT") { // don't remove state, we should keep the status as it link to different node
					delete this.metaMap[meta].line;
					delete this.metaMap[meta].col;
				}

			} else if (split[0] === "line") {
				this.metaMap[meta].line[split[1]] = this.metaMap[meta].line[split[1]] || {} // assign line;
				// set the line and remove all meta assign to variable
				this.metaMap[meta].line[split[1]] = {
					$val: val,
					$stamp: stamp,
					$id: dumpId
				};


			} else {
				this.metaMap[meta].col[split[1]] = this.metaMap[meta].col[split[1]] || {} // assign column;

				// set the column and remove the different value of meta assign to variable on this column
				this.metaMap[meta].col[split[1]] = {
					$val: val,
					$stamp: stamp,
					$id: dumpId,
				};
				var self = this;
				Object.keys(this.metaMap[meta].line).forEach(function(key) {
					var item = self.metaMap[meta].line[key];
					delete item[split[1]];
				});
			}
		} else { // modif value
			this.metaMap[meta].line[split[1]] = this.metaMap[meta].line[split[1]] || {} // assign line;
			this.metaMap[meta].line[split[1]][split[2]] = {
				$val: val,
				$stamp: stamp,
				$id: dumpId
			};
		}
	},
	appendFirstBlankLine: function(srcLine) {
		this.lines.push(srcLine);
		srcLine.setZeroBaseIdx(0);
		this.fusionMvtsInsert(1, 0);
	},
	appendLeftListLine: function(l) {
		this.lines.push(l);
		this.fusionMvtsInsert(1, this.lines.length - 1); // index 0 base and not 1
		if (!l.modified) {
			this.linesModified[l.uuid] = l;
			l.cellHasBeenModified();
			l.modified = true;
		}
	},
	blocFicheGetChilds: function() {
		var l = this.getFirstLine();
		if (l == null || l.vars == null) {
			throw new Error("List bloc - Unexpected null first line");
		}
		return l.vars;
	},
	buildMessErrorTraverse: function(aStructIst, aSetter, aKeyOfMessSuffix) {
		var wMess = this.client.getMessage('ERROR_TRAVERSE_SETTABLE', aStructIst.toString(), this.getAdxId(), module.id);
		// TODO TCA
		// aStructIst.toString() doesn't return correct value
		// this.getAdxId() doesn't return correct value
		// module.id isn't corresponding to aSetter.class
		//wMess = locale.format(wMess, aStructIst.toString(), this.getAdxId(), CStringFacilities.getClasseName(aSetter.class));
		return wMess + this.client.getMessage(aKeyOfMessSuffix);
	},
	fusionMvtsDelete: function(nbLines, idx) {
		//console.log(this.id + " - Mvt delete - nbLines[" + nbLines + "] - idx[" + idx + "]");
		this.listEventLine.addDelete(nbLines, idx);
		// Notifie datasrc to genarate JSON
		this.forceChange();
	},
	fusionMvtsInsert: function(nbLines, idx) {
		//console.log(this.id + " - Mvt insert - nbLines[" + nbLines + "] - idx[" + idx + "]");
		this.listEventLine.addInsert(nbLines, idx);
	},
	fusionMvtsRemoveAll: function() {
		this.listEventLine.removeAllLines();
		// Notifie datasrc to genarate JSON
		this.forceChange();
	},
	fusionMvtsReset: function() {
		this.listEventLine.reset();
	},
	getAdxId: function() {
		return this.screen == null ? null : "" + this.screen.getAdxId() + ',' + this.entityIdxAlpha;
	},
	getFirstLine: function() {
		return this.lines.length > 0 ? this.lines[0] : null;

	},
	getLastLine: function() {
		return this.lines.length > 0 ? this.lines[this.lines.length - 1] : null;

	},
	getLine: function(idx) {
		return this.lines[idx];
	},
	// return true if this data source admit column
	hasColumn: function() {
		return this.hasEntrySup();
	},
	// Retourne vrai si la dimension est depassee !
	hasDimOverFlow: function() {
		return this.lines.length > this.dim;
	},
	// return true if EntrySup is not null ( admit entry
	hasEntrySup: function() {
		return this.entrySup != null;
	},
	//retourne si un variable "baspag" est associee a la DataSource
	hasVarBasPage: function() {
		return this.varBasPage != null && this.varBasPage.length > 0;
	},
	isBlocFiche: function() {
		return this.dataSrcType === CvgDataSrc.TYPE_SCREEN && this.dim === 1 && !this.hasVarBasPage();
	},
	isBlocGrid: function() {
		return this.isLeftList() || this.isBlocTableau();
	},
	isBlocTableau: function() {
		return this.dataSrcType === CvgDataSrc.TYPE_SCREEN && this.hasVarBasPage(); // this.dim>1;
	},
	isLeftList: function() {
		return this.dataSrcType === CvgDataSrc.TYPE_LEFTLIST;
	},

	razModification: function() {
		var keys = Object.keys(this.linesModified);
		for (var i = 0; i < keys.length; i++) {
			this.linesModified[keys[i]].razModification();
		}
		this.linesModified = {};
		// Reset des modification des mouvements fusion en fin de request client
		this.fusionMvtsReset();
		CvgEntity.prototype.razModification.call(this);
	},
	// insert "apres" aTargetLine
	serverInsertLines: function(zeroBasedIdx, nbLines) {
		var timeInst = Date.now();
		var i, setFormat = false;
		this.fusionMvtsInsert(nbLines, zeroBasedIdx);
		var indexAfterInsert = zeroBasedIdx;

		for (i = 0; i < nbLines; i++) {

			// CvgDataSrcLine constructor Notify oberver that a new line has been created
			var srcLine = this.entrySup.clone();
			// GLUTE : gestion des formats dans les colonnes des tableaux pour associer chacune des variables de la nouvelle ligne a sa correspondante dans la ligne "this.entrySup"
			// Note: sert a la propagation du format courant a chaque modification de valeur
			//srcLine.setFormaterEntity(this.entrySup);
			setFormat = true;
			srcLine.setZeroBaseIdx(zeroBasedIdx + i);
			this.lines.splice(zeroBasedIdx + i, 0, srcLine);
			indexAfterInsert++;
		}

		this.updateIdxInsert(zeroBasedIdx + i, indexAfterInsert);

	},
	// Supprime toutes les lignes de la dataSource
	serverRemoveAllLines: function() {
		this.lines = [];
		this.linesModified = {};

		this.fusionMvtsRemoveAll();
		this.initMetaScope();
		// remove cache that store all the line of the datasource
		this.win.deleteCache(this.getAdxIst());

	},
	serverRemoveLines: function(startX3Idx, nbLines) {
		var self = this;



		if (startX3Idx === 0) {
			// do nothin startX3Ix must be > 1
			tracerStd.info && tracerStd.info((new Date().toISOString()) + " startX3Idx is not > 0 - do nothin");
		} else {

			var start = startX3Idx - 1;
			var stop = Math.min(start + nbLines, this.lines.length);
			// check for format if the current line entity has format define and set format to the next line if nothin has been assign
			//manageFormat(stop);
			// remove metaScope line if they exist
			for (var i = start; i < stop; i++) {
				this.lines[i].removeCache();
			}
			var self = this;
			this.lines.splice(start, stop - start).forEach(function(item) {
				// remove from lineModified if it exists
				if (self.linesModified[item.uuid]) {
					delete self.linesModified[item.uuid];
				}

			});
			this.fusionMvtsDelete(nbLines, start);
			this.updateIdx(start);

		}
	},
	//  Met en place une Entry suplementaire pour les datasources qui ont une
	setEntrySup: function(aDataSrcEntry) {
		this.entrySup = aDataSrcEntry;
		aDataSrcEntry.isEntrySup = true;

	},
	setServerStyle: function(aStyle, applyOn) {
		if ('CHILDS' === applyOn && this.isBlocFiche()) {
			var v, children = this.blocFicheGetChilds();
			for (v in children) {
				children[v].setServerStyle(aStyle, 'ENTITY');
			}
		} else {
			CvgEntity.prototype.setServerStyle.call(this, aStyle, applyOn);
			for (v in this.lines) {
				this.lines[v].setServerStyle(aStyle, 'ENTITY');
			}
		}
	},
	size: function() {
		return this.lines.length;
	},
	toJSON: function() {
		var object = {};
		if (this.isBlocGrid()) {
			// construct metadata json object
			var mapMeta = {
				"STY": {},
				"PCOL": {},
				"SEL": {},
				"VIS": {},
				"ACT": {},
				"FMT": {},
				"TIT": {}
			};
			/*var mapSty = mapMeta["STY"];
			var mapPCol = mapMeta["PCOL"];
			var mapFmt = mapMeta["FMT"];
			var mapVis = mapMeta["VIS"];
			var mapSel = mapMeta["SEL"];
			var mapAct = mapMeta["ACT"];
			var mapStt = mapMeta["STT"];
			var mapTit = mapMeta["TIT"];*/
			var arrDch = [];
			// $rcd
			var i, records = [];
			var keys = Object.keys(this.linesModified);
			var dline = 0;
			for (i = 0; i < keys.length; i++) {

				var line = this.linesModified[keys[i]];
				if (line) {
					this.toJsonAddRCD(line, records, arrDch);
					// treatement of metadata style - !! a optimiser
					//var lastLine = i === this.lines.length - 1;
					/*var ms = this.metaScope;
					if (ms && (ms.full || ms.lines && ms.lines[line.uuid] !== null) && this.metaChange) {
						//this.manageMeta(mapMeta, line, lastLine);
					}*/

				}

			}
			// console.log("time for line ",this.getObservableId(),dline)
			if (this.metaChange) {
				object.$meta = this.getMetaMapToJSON();
				if (arrDch && arrDch.length)
					object.$meta.dch = arrDch;
				/*
                this.manageTableMetadata(mapPCol, 'PCOL');
				this.manageTableMetadata(mapSty, 'STY');
				this.manageTableMetadata(mapVis, 'VIS');
				this.manageTableMetadata(mapAct, 'ACT');
				this.manageTableMetadata(mapSel, 'SEL');
				this.manageTableMetadata(mapTit, 'TIT');
                var metadata = {};

				// get list of all entity first for metat state
				var item, metaEntity = [];
				for (item in mapVis) {
					metaEntity.push(mapVis[item]);
				}
				for (item in mapAct) {
					metaEntity.push(mapAct[item]);
				}
				for (item in mapSel) {
					metaEntity.push(mapSel[item]);
				}
				// create map of entity state
				mapStt = this.optimizeMetaStt(metaEntity);

				if (mapDch != null) {
					metadata.dch = mapDch;
				}
				var sty = this.getJsonMetadata(mapSty, 'STY');
				if (!emptyJson(sty)) {
					metadata.sty = sty;
				}
				var stypCol = this.getJsonMetadata(mapPCol, 'PCOL');
				// optimize stypcol
				//
				if (!emptyJson(stypCol)) { // add all pCol as style
					if (!metadata.sty) {
						metadata.sty = stypCol;
					}
				}

				var fmt = this.getJsonMetadata(mapFmt, 'FMT');
				if (!emptyJson(fmt)) {
					metadata.fmt = fmt;
				}
				var stt = this.getJsonMetadata(mapStt, 'STT');
				if (!emptyJson(stt)) {
					metadata.stt = stt;
				}
				var tit = this.getJsonMetadata(mapTit, 'TIT');
				if (!emptyJson(tit)) {
					metadata.tit = tit;
				}

                */

			}
			if (!emptyJson(records)) {
				object.$rcd = records; // add record table that represent
			}
			var mvt = this.listEventLine.toJSON();
			if (!emptyJson(mvt)) {
				object.$mvt = mvt;
			}

			// console.log("time event line ",this.getObservableId())
		} else if (this.isBlocFiche()) {
			// #1039 - FDB - Only titles are implemented on client side
			if (this.hasModifTitle()) {
				object.tit = this.title;
				if (this.titleStyle != null) {
					object.stytit = this.titleStyle;
				}
			}
			// TODO on client side
			if (this.hasModifStyle() && this.style != null) {
				object.sty = this.style;
			}
			if (this.hasModifState()) {
				object.stt = this.state;
			}
		}
		// reinit metadata scope
		this.initMetaScope();
		// reset line modified to don't browser all line each time but only modified lines
		this.metaChange = false;
		CvgEntity.prototype.toJSON.call(this);

		return object;
	},

	// Pour surcharge par liste recursive
	toJsonAddRCD: function(line, record, mapDch) {
		var lineJSon = line.toJSON(mapDch);
		if (lineJSon != null) {
			record.splice(line.zeroBaseLineIdx, 0, lineJSon);
		}
		return lineJSon;
	},
	traverseAll: function(aTraverser) {
		var wMax = this.lines.length;
		var wDataSrcLine;
		var wI = 0;
		while (wI < wMax) {
			wDataSrcLine = this.getLine(wI);
			if (aTraverser.doWhenTraverse(wDataSrcLine, wI) === true) {
				return true;
			}
			if (wDataSrcLine.traverseAll(aTraverser) === true) {
				return true;
			}
			wI++;
		}
		return false;
	},
	traverseChilds: function(aTraverser) {
		var wTraversingState = false;
		var wMax = this.lines.length;
		if (this.hasEntrySup()) {
			wTraversingState = aTraverser.doWhenTraverse(this.entrySup, -1);
			if (wTraversingState === true) {
				return true;
			}
		}
		var wI = 0;
		while (wI < wMax) {
			wTraversingState = aTraverser.doWhenTraverse(this.getLine(wI), wI);
			if (wTraversingState === true) {
				return true;
			}
			wI++;
		}
		return wTraversingState;
	},

	/**
	 * 14w_005 - bug 30654 - mise en place mode "envoi pour rebind"
	 * <p>
	 * Propagation du changement d'etat sur toutes les lignes existante de la
	 * datasource
	 *
	 * 14w_006 - Bug 31739 - gestion tableau
	 * <p>
	 * Application des regles de propagations des changements d'etat
	 * fonctionnant dans le client X3
	 * <li>si sAdxidTarget.nAdxid est de type GRID et sAdxidTarget.nNumLine ==
	 * -1 : on applique le cState a toutes les cellules du tableau
	 * <li>si sAdxidTarget.nAdxid est de type GRID et sAdxidTarget.nNumLine > 0
	 * : on applique le cState a toutes les cellules de la ligne
	 * <li>si sAdxidTarget.nAdxid correspond a une colonne et
	 * sAdxidTarget.nNumLine === -1 : on applique le cState a toutes les cellules
	 * de la colonne
	 * <li>si sAdxidTarget.nAdxid correspond a une colonne et
	 * sAdxidTarget.nNumLine > 0 : on applique le cState a la cellule
	 * colonne/ligne
	 *
	 * @param aStructIst
	 * @param aSetter
	 * @return
	 */
	traverseSettable: function(aStructIst, aSetter) {
		var wContinue;
		//try {
		var CActiveStateSetter = CActiveStateSetter || require('syracuse-x3/lib/convergence/client/CvgRequest').CActiveStateSetter;

		if (aStructIst.isBaseBloc()) {
			// Si la porte est une colonne ou toutes les lignes d'une colonne
			// ATTENTION : il
			// faut tester "this.dim>1 && isColumnIst()" avant "isFieldIst()" car si
			// this.dim>1 on a
			// egalite entre "isColumnIst()" et "isFieldIst()"
			// 16w_115 - gestion des tableau de dimension 1 // on execute
			// traverseSettable si on admet des colonnes
			if (aStructIst.field !== 0 && (this.hasColumn() && aStructIst.idx === 0 || aStructIst.idx === -1)) {
				// this is abbreviation for: if (this.hasColumn() && aStructIst.isColumnIst() || aStructIst.isAllLinesOfColumnIst()) {
				this.metaScope.full = true;
				// Application sur la ligne suplementaire EntrySup
				wContinue = this.entrySup.traverseSettable(aStructIst, aSetter);
				// si c'est un changement d'etat: application sur toutes les
				// lignes (pour une colonne)
				if (wContinue && aSetter instanceof CActiveStateSetter) {
					wContinue = this.traverseSettableLines(aStructIst, aSetter);

				}
				return wContinue;
			}
			// Si la porte est le champ ou la ligne: application sur l'entite
			// inferieure designee
			if (aStructIst.isFieldLineIstRed()) {
				// this is abbreviation for: if (aStructIst.isFieldIst() || aStructIst.isLineIst()) {

				var wI = this.dim > 1 ? aStructIst.idxZeroBase : 0;

				// si numero de ligne incorrect
				if (wI < 0 || wI >= this.lines.length) {
					var wMess = this.client.getMessage('ERROR_LINE_UNKNOWN', wI, this.lines.length, this.getAdxId());
					aSetter.setLogicalErrMess(wMess);
					return false;
				}
				var wDataSrcLine = this.getLine(wI);
				// it's better to add the reference of the line instead of the idx. because it will change regarding deletion or insertion
				if (aSetter.applyMeta && !this.metaScope.lines[wDataSrcLine.uuid]) {
					this.metaScope.lines[wDataSrcLine.uuid] = wDataSrcLine;
				}
				return wDataSrcLine == null ? false : wDataSrcLine.traverseSettable(aStructIst, aSetter);
			}
			// Si la porte est le bloc ou toutes les lignes du bloc :
			// application sur le bloc.
			if (aStructIst.isBlocAllLinesBlocIstRed()) {
				// this is abbreviation for: if (aStructIst.isBlocIst() || aStructIst.isAllLinesOfBlocIst()) {
				this.metaScope.full = true;
				// Application sur le bloc
				wContinue = aSetter.setModifiable(aStructIst, this);
				// si c'est un changement d'etat :
				if (wContinue && aSetter instanceof CActiveStateSetter) {
					// 16w_104 - Fiche 51885 - RH V5 : zone non saisissable en
					// Web
					// Application sur la ligne suplementaire EntrySup
					if (this.entrySup) { // if there an entry sup so isBlocTableau and dim > 1 otherwise no entrySup and fail
						wContinue = this.entrySup.traverseSettable(aStructIst, aSetter);
					}
					if (wContinue) {
						// application sur toutes les lignes (pour toutesles
						// colonnes)
						wContinue = this.traverseSettableLines(aStructIst, aSetter);
					}
				}
				return wContinue;
			}
		} else {
			aSetter.setLogicalErrMess(this.buildMessErrorTraverse(aStructIst, aSetter, 'ERROR_TRAVERSE_SETTABLE_CASE'));
			return true;
		}
		/*} catch (e) {
			var wMess = this.buildMessErrorTraverse(aStructIst, aSetter, 'ERROR_TRAVERSE_SETTABLE_EXCEPT');
			aSetter.setLogicalErrMess(wMess + ' ' + e);
			throw e;
		}*/
	},
	traverseSettableLines: function(aStructIst, aSetter) {
		var wContinue = true;
		var wI = 0;
		var wMax = this.lines.length;
		var wDataSrcLine;
		while (wI < wMax && wContinue) {
			wDataSrcLine = this.getLine(wI);
			wContinue = wDataSrcLine.traverseSettable(aStructIst, aSetter);
			wI++;
		}
		return wContinue;
	},
	updateIdx: function(startIdx) {
		var i, l;
		for (i = startIdx, l = this.lines.length; i < l; i++) {
			this.lines[i] && this.lines[i].setZeroBaseIdx(i);
		}

	},
	updateIdxInsert: function(startIdx, indexAfterInsert) {
		var i, l;
		var k = 0;
		for (i = startIdx, l = this.lines.length; i < l; i++) {
			this.lines[i] && this.lines[i].setZeroBaseIdx(indexAfterInsert + k);
			k++;
		}

	}
});

CvgDataSrc.TYPE_LEFTLIST = 'Q';
CvgDataSrc.TYPE_SCREEN = 'E';