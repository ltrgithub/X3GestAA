"use strict";
var helpers = require('syracuse-core/lib/helpers');
var x3helpers = require('syracuse-x3/lib/helpers');
var CvgObservable = require('syracuse-x3/lib/convergence/model/CvgObservable').CvgObservable;
var CvgResu = require('syracuse-x3/lib/convergence/types/CvgResu').CvgResu;
var CvgIst = require('syracuse-x3/lib/convergence/types/CvgIst').CvgIst;
var CvgResu = require('syracuse-x3/lib/convergence/types/CvgResu').CvgResu;
var CvgResuTdo = require('syracuse-x3/lib/convergence/types/CvgResu').TDO;
var CvgResuTagLib = require('syracuse-x3/lib/convergence/types/CvgResu').TAG_LIB;
var CvgActions = require('syracuse-x3/lib/convergence/client/CvgAction').Actions;
var jsRunner = require('syracuse-x3/lib/jsRunner');
var officeXls = require('msoffice/lib/excel/xlsx');
var jsxml = require('jsxml');
var events = require('events');

var localConfig=x3helpers.config("x3fusion", null, {});

function BufferWritableStream(callback) {
	this.buffer = new Buffer([]);
	this.writable = true;
	this.write = function(data) { this.buffer = Buffer.concat([this.buffer, new Buffer(data)]); return true; }
	this.end = function(data) { Buffer.concat([this.buffer, new Buffer(data)]); return callback(null); }
}
BufferWritableStream.prototype = new events.EventEmitter();



var CvgInstanceExeci = exports.CvgInstanceExeci = helpers.defineClass(function(_, ist,spgm,dbgflag,paramDefs,paramVal, client) {
	CvgObservable.call(this, client);
	this.instance = ist;
	this.spgm = spgm;
	this.exceptionDet = dbgflag & 0x01;
	this.totalDuration = dbgflag & 0x02 >> 1 ;
	this.execDuration = dbgflag &0x03 >> 2;
	this.trace = dbgflag & 0x04 >> 3;
	this.defs = paramDefs;
	this.values = paramVal;
	// En dernier
	this.process(_);
}, CvgObservable, {
	process: function(_) {
		// Javascript call
		if (this.spgm === "PROXY_DISPATCH"){
			var trace = x3helpers.config("dispatch.trace",localConfig);
			trace && trace("******************");
			trace && trace("Receive JS call from 4GL process...");
			trace && trace("******************");
			try {
			// exec js 
				var header, body;
				try {
					header = JSON.parse(this.values[0].value);
					trace && trace("Header: "+JSON.stringify(header,null,2));
				}catch(e) {
					throw new Error("Bad Header JSON: "+e.message+": "+this.values[0].value);
				}
				try {
					body = JSON.parse(this.values[1].value);
					trace && trace("Body: "+JSON.stringify(body,null,2));
				}catch(e) {
					throw new Error("Bad Body JSON: "+e.message+": "+this.values[1].value);
				}

				var result, errl = 0, errm = "", errn = 0, errp = "", errt = 0;
			
				// Syracuse function execution
				if (header.url.indexOf('js:') === 0) {
					result = jsRunner.execute(_, header.url.substring(3), body);
					trace && trace("Function Result: "+JSON.stringify(result,null,2));
				}
	            // Http Request
	            else{
	                if (header.method != null) {
	                     if (header.url.indexOf('http://') == 0 || header.url.indexOf('https://') == 0) {
	                    	 result = jsRunner.httpRequest(_, header, body);
	                    	 trace && trace("HTTP Result: "+JSON.stringify(result,null,2));
	                     } else {
	                         throw new Error("Invalid protocol");
	                     }
	                 }
	            }
	         }
	         catch (e) {
	        	 console.error(e.stack);
	             //TODO Catch every error's elements
	             errl = 1;
	             errn = 1;
	             errt = 1;
	             errp = "CvgInstanceExeci._js";
	             errm = e.message;
	             result = {
	                 header: {
	                     "statusCode": "500",
	                     "message": e.message,
	                     "exception": e.stack
	                 },
	                 body: ''
	             }
	         }

	         return this.genExeciNode(_, {typ:"CLOB",resu:JSON.stringify(result)}, errl, errm, errn, errp, errt);
		}
		else{
			// construction of JSON
			// id 
			this.json = {
				spgm : this.spgm,
				debugFlags : {
					execduration : this.execDuration,
					exceptiondetail : this.exceptionDet,
					totalduration : this.totalDuration,
					trace :  this.trace
				},
				params : []
			}
			// params 
			var j =0;
			var i = 0;
			while(i<this.defs.length){
				// read the first 4 short define 1 paramDef
				var dim  = this.defs[i++];
				var nb = this.defs[i++];
				var size = this.defs[i++];
				var type = CvgResuTagLib[this.defs[i++]-256];
				var item = {
					dim : dim,
					nb : nb,
					size : size,
					typ : type,
					resu : []
				}
				// treat current defs of parameter
				if( nb != 0 ){ // if there is some resu
					var offsetresu = j;
					while(j<offsetresu+nb && j<this.values.length){
						var val = this.values[j++]
						item.resu.push(val.value);
					}
					// Excel export
					if(this.spgm === "setDataTableExtractToExcel") {
						if (item.resu.length !== 1)
							throw new Error("Only one resu can be accepted by Excel export.");
						item.resu[0] = this.generateXlsx(_, this.instance, item.resu[0]);
					}
				}
				this.json.params.push(item);
			}
			this.setJsonType('TARGET');// send to client beacus track
		}
	},
	genExeciNode: function(_, resu, errl, errm, errn, errp, errt){
		var body = {
            act: CvgActions['SRV_EXECI_RESPONSE'],
			fld : {
				ist : this.instance
			},
            param: {
                target: {
                	type: "ist",
                	ist: this.instance
                },
                reply: {
                    json:{
						result : {
							errp: errp,
							errm: errm,
							errn: errn,
							errt: errt,
							errl: errl
						},
						debugInfos :{
							exceptiondetail : "",
							totalduration :0,
							execduration :0,
							trace : ""
						},
						"return" : resu,
						params : []
					}
                }
            }
        }; 
		this.client.processAction(_, body);
	},
	format: {
		get: function() {
			return this.instance == null ? "" : this.instance.format;
		}
	},
	getNl: function() {
		return 0;
	},
	getXid: function() {
		return this.instance == null ? "" : (this.instance.ist.blocAlphaId + this.instance.ist.fieldId);
	},
	hasFormat: function() {
		return this.instance == null ? false : this.instance.hasFormat();
	},
	setInstance: function(instance) {
		this.instance = instance;
	},
	setXml: function(xml) {
		this.xml = xml;
	},
	generateXlsx: function(_, ist, params) {
		
		var uuid = ist.toString().split(',').join('');
		//console.log("XML: "+params);
		var json = jsxml.parse(params);
		
		var $proto = [];
		// proto
		var titles = json.X3TAB.GTAB.HTAB.TITLE;
		for (var i in titles) {
			$proto.push({
				"_name" : titles[i].$.NAM,
				"_orgName" : titles[i].$.NAM,
				"_title" : titles[i].$value,
				"_type" : "application/x-string"
			});
		}
		
		var $data = [];
		// Data
		var lines = json.X3TAB.GTAB.DATA.LIG;
		for (var i in lines) {
			$data.push(lines[i].COL);
		}

		var result = {
			proto: JSON.stringify($proto),
			data: JSON.stringify($data)
		};
		//console.log("JSON: "+JSON.stringify(result,null,2));

		var stream = new BufferWritableStream();
		officeXls.render(_, stream, {data: result});
		
		this.client.services.blobSvc.register(uuid, stream.buffer, null, {
			filename: "x3_excel_export.xls",
			mimeType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
		});
		return uuid;
	},
	toJSON: function() {
		var object = {};
		object.type = 'rpc';
		var rpc = {};
		rpc.json = this.json;
		object['rpc'] = rpc;
		var st = this.instance.toString().split(",");
		if( st.length > 0 ){
			rpc.ist = {
				win : st[0],
				xid : st[1]+st[2],
				nl  : 0
			}
		}else{
			rpc.ist = {
				win : "A",
				xid : 0,
				nl  : 0
			}
		}
		return object;
	}
	
});
