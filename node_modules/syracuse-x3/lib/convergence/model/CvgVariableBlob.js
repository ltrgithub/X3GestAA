"use strict";
var helpers = require('syracuse-core/lib/helpers');
var CvgVariable = require('syracuse-x3/lib/convergence/model/CvgVariable').CvgVariable;
var CvgResu = require('syracuse-x3/lib/convergence/types/CvgResu').CvgResu;
var CvgResuTag = require('syracuse-x3/lib/convergence/types/CvgResu').TAG;

var CvgVariableBlob = exports.CvgVariableBlob = helpers.defineClass(function(srcLine, aEntityIndexBaseOne, aVarName, aID, aTdo, aSize, aFormat, aEntityState, blobSvc) {
	CvgVariable.call(this, srcLine, aEntityIndexBaseOne, aVarName, aID, aTdo, aFormat, aEntityState);
	this.indirection = null;
	this.size = aSize;
	this.uuid = null;
	// TODO - Non utilisé - this.url = aUrl;
}, CvgVariable, {

	// Pas de format
	acceptEditFormat: function() {
		return false;
	},
	clone: function() {
		return null;
	},
	controlBlobSize: function(aBlob) {
		var wMaxSize = 1024 * Math.pow(2, this.size) - 4;
		if (aBlob.length > wMaxSize) {
			throw new CvgException(this.client, null, this.client.getMessage('ERROR_UPLOAD_BLOB', aBlob.length.toString(), this.id, wMaxSize.toString(), this.size.toString()), true);
		}
	},
	getDisplayValue: function() {
		return this.uuid;
	},
	hasValueBlob: function() {
		return this.serverValue != null && this.serverValue.hasBlobValue();
	},
	setBrowserUnformattedValue: function(aBuffer) {
		this.setBrowserUnformattedValue(new CvgResu(CvgResuTag["BLOB"], aBuffer));
	},
	/* TODO overload
	setBrowserUnformattedValue: function(aBrowserValue) {
		controlBlobSize(aBrowserValue.geBlobValue());
		CvgVariable.prototype.setBrowserUnformattedValue.call(this,aBrowserValue);
	},
	*/
	setIndirection: function(i) {
		this.indirection = i;
	},
	setServerValue: function(aResu) {

		this.uuid = this.client.services.blobSvc.register(this.calcMimeType(aResu.value),new Buffer(aResu.value).toString('binary'));
		
		CvgVariable.prototype.setServerValue.call(this,aResu);
	},
	calcMimeType: function(blobValue) {
		var bin = new Buffer(blobValue, 'hex').toString('binary');
		if (this.isBlobImgGif(bin)) {
			return "image/gif";
		} else if (this.isBlobImgJpg(bin)) {
			return "image/jpeg";
		} else if (this.isBlobImgBMP(bin)) {
			return "image/bmp";
		} else if (this.isBlobImgPng(bin)) {
			return "image/png";
		} else if (this.isBlobImgTiff(bin)) {
			return "image/tiff";
		} else {
			return "application/octet-stream";
		}
	},
	
	/**
	 * BMP Structure du fichier BMP - format OS/2: Relativement à ce que nous
	 * venons de voir, nous voyons que le fichier OS/2 et Windows commencent par
	 * BM, on peut supposer que cela signifie "ceci est un fichier de type BMP"
	 * ensuite le codage diffère. Je suppose que dans l'octet qui suit,
	 * l'information relative à l'option du format OS/2 ou Windows est présente
	 * (0x3E pour OS/2 et 0x5A pour Windows)
	 * 
	 * @param bin
	 * @return
	 */
	isBlobImgBMP: function(bin) {
		return bin[0] === 'B' && bin[1] === 'M';
	},

	/**
	 * 
	 * GIF Le premier objet rencontré dans un fichier GIF est la "signature"; il
	 * s'agit d'une chaîne de caractères qui permet aux programmes de décodages
	 * de savoir qu'ils manipulent des images GIF. Il n'est pas surprenant de
	 * voir que cette chaîne contient le mot "GIF".
	 * 
	 * Le fichier GIF porte généralement la signature GIF87a, les trois
	 * dernières lettres représentant des évolution du format et des révision de
	 * ce format. Seules les trois premières lettres de cette chaîne doivent
	 * être testées pour vérifier la validité du fichier. Si vous êtes très
	 * pointilleux, vous pouvez modifier le décodeur de manière à ce qu'il
	 * affiche un message d'avertissement quand le numéro de révision lu est
	 * différent de celui de la signature classique.
	 * 
	 * Le standard GIF originel s'appelle GIF87a. Ce format a maintenant évolué
	 * en GIF89a, mais les fichiers GIF sont compatibles descendant avec la
	 * version GIF87a, car la plupart des améliorations du format consistent en
	 * des éléments optionnels comme des texte de commentaires et des options
	 * d'animation.
	 * 
	 * Un fichier GIF peut contenir plusieurs images. Il vous est alors possible
	 * de visualiser une image pendant que le programme de décodage décompresse
	 * les images suivantes. Aussi, un en-tête GIF contient des données globales
	 * et des données locales. Les données globales sont associées à toutes les
	 * images du fichier, tandis que les données locales ne sont associées qu'à
	 * une seule image de ce fichier.
	 * 
	 * Les programmes d'encodages d'images au format GIF traitent cette
	 * distinction de plusieurs manières différentes et un programme de décodage
	 * doit être en mesure de les manipuler, même si vous ne vous intéréssez
	 * qu'à une seule image dans un même fichier. Pour des fichiers qui ne
	 * contiennent qu'une image, ce qui est généralement le cas, la plupart des
	 * données globales et locales ont le même effet, et seul un ensemble de
	 * données (globales ou locales) est généralement présent dans le fichier.
	 * 
	 * L'objet rencontré après la signature dans un fichier GIF est le
	 * "descripteur d'écran". Ce champ marque le commencement des données
	 * globales. La nature de l'écran qui a servi lors de la création de l'image
	 * fait partie intégrante du format. En pratique, vous ignorez ce champ.
	 * 
	 * Les dimensions de l'écran qui sont stockées dans le fichier n'ont pas
	 * grand chose à voir avec les dimmensions réelles des images contenues dans
	 * ce même fichier. Le descripteur d'écran ne fait que définir la taille de
	 * l'écran qui a servi à créer le fichier. Le fragment de programme suivant
	 * montre la structure d'un en-tête de fichier GIF:
	 * 
	 * typedef struct { char sig[6]; unsigned int screenwidth, screendepth;
	 * unsigned char flags, background, aspect; } GIFHEADER;
	 * 
	 * @param bin
	 * @return
	 */
	isBlobImgGif: function(bin) {
		return bin[0] === 'G' && bin[1] === 'I' && bin[2] === 'F';
	},

	/**
	 * 
	 * JPEG marqueur SOI : FFD8
	 * 
	 * @param bin
	 * @return
	 */
	isBlobImgJpg: function(bin) {
		return bin[0] === 0xff && bin[1] === 0xd8;
	},

	/**
	 * 
	 * PNG file signature The first eight bytes of a PNG file always contain the
	 * following (decimal) values: 137 80 78 71 13 10 26 10
	 * 
	 * This signature indicates that the remainder of the file contains a single
	 * PNG image, consisting of a series of chunks beginning with an IHDR chunk
	 * and ending with an IEND chunk.
	 * 
	 * The first eight bytes of a PNG file always contain the following values:
	 * (decimal) 137 80 78 71 13 10 26 10 (hexadecimal) 89 50 4e 47 0d 0a 1a 0a
	 * (ASCII C notation) \211 P N G \r \n \032 \n
	 * 
	 * This signature both identifies the file as a PNG file and provides for
	 * immediate detection of common file-transfer problems. The first two bytes
	 * distinguish PNG files on systems that expect the first two bytes to
	 * identify the file type uniquely. The first byte is chosen as a non-ASCII
	 * value to reduce the probability that a text file may be misrecognized as
	 * a PNG file; also, it catches bad file transfers that clear bit 7. Bytes
	 * two through four name the format. The CR-LF sequence catches bad file
	 * transfers that alter newline sequences. The control-Z character stops
	 * file display under MS-DOS. The final line feed checks for the inverse of
	 * the CR-LF translation problem.
	 * 
	 * A decoder may further verify that the next eight bytes contain an IHDR
	 * chunk header with the correct chunk length; this will catch bad transfers
	 * that drop or alter null (zero) bytes.
	 * 
	 * Note that there is no version number in the signature, nor indeed
	 * anywhere in the file. This is intentional: the chunk mechanism provides a
	 * better, more flexible way to handle format extensions, as explained in
	 * Chunk naming conventions.
	 * 
	 * @param bin
	 * @return
	 */
	isBlobImgPng: function(bin) {
		return bin[0] === 137 && bin[1] === 80 && bin[2] === 78 && bin[3] === 71 && bin[4] === 13 && bin[5] === 10 && bin[6] === 26 && bin[7] === 10
	},

	/**
	 * 
	 * TIFF Tous les fichiers TIFF commencent par les deux octets 0x49 0x49 ou
	 * 0x4D 0x4D qui sont les codes ASCII des caractères alphabétiques
	 * respectivement I ou M Le I indique INTEL et le M MOTOROLA, les deux
	 * principaux fournisseurs de micro-processeurs respectivement pour les
	 * IBM-PC et les MACINTOSH. Cette distinction est importante pour lordre
	 * dans lequel sont rangées les octets représentant des valeurs numériques.
	 * Pour les micro-processeurs Motorola, lordre est normal, à savoir valeur
	 * la plus significative à gauche. Pour les micro-processeurs Intel par
	 * contre, cet ordre est inversé, ce qui implique une petite gymnastique
	 * pour la conversion. Le troisième octet 0x2A = 42 en décimal représente le
	 * numéro de version du standard TIFF : 42 dans notre cas. Les 4 octets
	 * suivants après remise en ordre (le h49 indique que nous sommes chez
	 * Intel) donnent h0008= 8, qui est la longueur de len-tête. Nous trouvons
	 * donc 8 octets plus loin la valeur h15=21 qui est le nombre de tags du
	 * fichier. Ces tags ont une longueur fixe de 12 octets et sont identifiés
	 * par un numéro normalisé qui fait toute la richesse du système. La figure
	 * 24 montre la structure dun fichier TIFF.
	 * 
	 * @param bin
	 * @return
	 */
	isBlobImgTiff: function(bin) {
		return (bin[0] === 0x4D && bin[1] === 0x4D) || (bin[0] === 0x49 && bin[1] === 0x49);
	},

});