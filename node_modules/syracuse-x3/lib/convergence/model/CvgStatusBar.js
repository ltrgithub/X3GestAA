"use strict";
var helpers = require('syracuse-core/lib/helpers');

var _notifySeverity = ["info", "warning", "transient", "error", "fatal", "success"];
var CvgEntity = require('syracuse-x3/lib/convergence/model/CvgEntity').CvgEntity;
var util = require('util');

var CvgStatusIcon = exports.CvgStatusIcon = helpers.defineClass(function(aImgId, aActionId, aVisible) {
	this.imgId = aImgId;
	this.actionId = aActionId;
	this.visible = aVisible;
}, null, {
	toJSON: function() {
		// this.actionId = 0 pour les icone supprimÃ©s
		return [this.visible ? this.actionId : 0, this.imgId];
	},
	update: function(aActionId, aVisible) {
		this.actionId = aActionId;
		this.visible = aVisible;
	}
});

var CvgStatusBar = exports.CvgStatusBar = helpers.defineClass(function(client, windowId, stackedWindow) {
	CvgEntity.call(this, client, windowId, -1, "STATUSBAR");
	this.iconsList = {};
	this.stackedWindow = stackedWindow;
	this.text = [];
	this.notify = [];
	this.setJsonType("ENTITY");

}, CvgEntity, {
	addIconDef: function(aNumtext, aText, aImgId, aActionId) {
		if (aImgId === 0) {
			this.setText(aNumtext, aText);
		} else {
			var wVisible = aImgId > 0;
			if (!wVisible) {
				aImgId = aImgId * -1;
			}
			var key = aImgId;
			var wStatusIcon = this.iconsList[key];
			if (wStatusIcon == null) {
				this.iconsList[key] = new CvgStatusIcon(aImgId, aActionId, wVisible);
			} else {
				wStatusIcon.update(aActionId, wVisible);
			}
		}
		this.forceChange();
	},
	getAdxId: function() {
		return this.stackedWindow && this.stackedWindow.getAdxId();
	},
	setText: function(aNumText, aText) {
		var notifyOffset = 100;
		if (aNumText < 1 || (aNumText > 2 && aNumText < notifyOffset)) {
			aNumText = 1; // protection
		}
		if (aNumText < notifyOffset) {
			this.text[aNumText - 1] = aText != null && aText.length > 0 ? aText : null;
		} else {
			this.notify.push({
				"t": aText,
				"l": aNumText - notifyOffset
			});
		}
	},
	toJSON: function() {
		var statusbar = {
			t: [],
			ico: []
		}, i, len, max = _notifySeverity.length;
		if ((len = this.text.length) > 0) {
			// do not use this.text.map because map skips entries in sparse arrays
			for (i = 0; i < len; i++) {
				statusbar.t[i] = this.text[i] || "";
			}
		}
		if (Object.keys(this.iconsList).length > 0) {
			//  Issue #1238  - return array
			for (var p in this.iconsList) statusbar.ico.push(this.iconsList[p]);
		}
		if ((len = this.notify.length) > 0) {
			statusbar.notify = [];
			for (i = 0; i < this.notify.length; i++) {
				if (this.notify[i].l < max) {
					statusbar.notify[i] = {
						"$message": this.notify[i].t,
						"$severity": _notifySeverity[this.notify[i].l]
					};
				}
			}
			// RAZ notify!
			this.notify = [];
		}
		return statusbar;
	}
});