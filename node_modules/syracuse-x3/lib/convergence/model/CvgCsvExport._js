"use strict";
var helpers = require('@sage/syracuse-core').helpers;
var officeCsv = require('msoffice/lib/excel/csv');
var jsxml = require('js-xml');
var locale = require('streamline-locale');
var ez = require('ez-streams');

var tracerXls = require('@sage/syracuse-core').getTracer("classic.csvExport");

var CvgCsvExport = helpers.defineClass(function(_, client, ist, serverUrl, params) {
	this.client = client;
	this.ist = ist;
	this.serverUrl = serverUrl;
	this.params = params;
}, null, {
	generateCsv: function(_) {

		var uuid = this.ist.toString().split(',').join('');
		tracerXls.info && tracerXls.info("XML: " + this.params);
		var json = jsxml.parse(this.params);
		tracerXls.info && tracerXls.info("JSON: " + JSON.stringify(json, null, 2));
		var $proto = [];
		var $title = [];
		var fileTitle = json.X3TAB.TITLE.$value;

		var titles = json.X3TAB.GTAB.HTAB.TITLE;
		var columns = json.X3TAB.GTAB.LCOL.COL;

		var processTitle = function(tit, col) {

			var def = {
				"_name": tit.$.NAM,
				"_orgName": tit.$.NAM,
				"_title": tit.$value,
				"_type": col.$.TYP
			};
			if (col && col.$ && col.$.TYP === "application/x-decimal") {
				var scale = (col.$.FMT.split('.')[1].match(/0/g) || []).length;
				if (scale > 0) def._scale = scale;
			}
			$proto.push(def);
			$title.push(def._title);
		};

		if (Array.isArray(titles) && Array.isArray(columns)) {
			for (var i = 0; i < titles.length; i++) {
				processTitle(titles[i], columns[i]);
			}
		} else if (!Array.isArray(titles) && !Array.isArray(columns)) {
			processTitle(titles, columns);
		} else {
			throw new Error("The count of titles is not equals to the count of columns.");
		}

		var $data = [];
		var lines = json.X3TAB.GTAB.DATA.LIG;

		var processLine = function(cols, idx) {

			var handleSpecialType = function(val, col) {
				if ((col && col.$ && col.$.TYP) === "application/x-date") {
					if (val === "00/00/0000" || val === "01/10/1600") {
						val = "";
					} else {
						var parts = val.split('/');
						var m = parts[0];
						var d = parts[1];
						var y = parts[2];
						val = y + "-" + m + "-" + d;
					}
				}
				return '"' + (val || "") + '"'; // escape the CSV
			};

			if (Array.isArray(cols) && Array.isArray(columns)) {
				for (var j = 0; j < cols.length; j++) {
					cols[j] = handleSpecialType(cols[j], columns[j]);
				}
				$data.push(cols);
			} else if (!Array.isArray(cols) && !Array.isArray(columns)) {
				cols = handleSpecialType(cols, columns);
				$data.push([cols]);
			} else {
				throw new Error("The count of values found in line '" + idx + "' is not equals to the count of columns.");
			}
		};

		var col;
		if (Array.isArray(lines)) {
			processLine($title, 0);
			for (var k = 0; k < lines.length; k++) {
				col = lines[k].COL;
				processLine(col, k + 1);
			}
		} else if (lines != null) {
			processLine($title, 0);
			col = lines.COL;
			processLine(col, 1);
		} else {
			throw new Error(locale.format(module, "noData"));
		}

		var stream = ez.devices.string.writer();

		officeCsv.csvDirectExport(_, $data, stream);

		this.client.services.blobSvc.register(uuid, stream.toString().substr(1), null, {
			filename: fileTitle + ".csv",
			mimeType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
		});
		return uuid;
	}
});

exports.setDataTableExtractToCsv = function setDataTableExtractToCsv(_, client, instance, serverUrl, params) {
	try {
		var exporter = new CvgCsvExport(_, client, instance, serverUrl, params[0].resu[0]);
		params[0].resu[0] = exporter.generateCsv(_);
	} catch (e) {
		console.error(e.stack);
		params[1].resu[0] = e.message;
	}
	return params;
};