"use strict";
var helpers = require('syracuse-core').helpers;
var CvgEntity = require('syracuse-x3/lib/convergence/model/CvgEntity').CvgEntity;
var CvgVariable = require('syracuse-x3/lib/convergence/model/CvgEntity').CvgVariable;
var CvgVariableCombo = require('syracuse-x3/lib/convergence/model/CvgVariableCombo').CvgVariableCombo;
var helpers = require('syracuse-core').helpers;
var CvgObservable = require('syracuse-x3/lib/convergence/model/CvgObservable').CvgObservable;

var CvgDataSrcLine = exports.CvgDataSrcLine = helpers.defineClass(function(requester, dataSrc, id, nbVars, zeroBaseIdx) {
	CvgEntity.call(this, dataSrc && dataSrc.client, id, 0, 'ROW', requester);
	this.zeroBaseIdx = zeroBaseIdx !== undefined ? zeroBaseIdx : -1;
	this.setZeroBaseIdx(zeroBaseIdx);
	this.requester = requester;
	this.dataSrc = dataSrc;
	this.isEntrySup = false;
	// add a unique identifier
	this.uuid = helpers.uuid.generate();
	// Table des variables => indxees par leur RANG
	this.vars = [];
	this.varsModified = [];

	// Table des variables => indxees par leur NOM
	this.hVars = {};
	this.modified = false;
	// true if a combo cell has a disableChoice modif
	this.comboDchModif = false;

	// En dernier
	this.setJsonType('ENTITY');
}, CvgEntity, {
	addOneVar: function(aVariable) {
		this.hVars[aVariable.id] = aVariable;
		this.vars.push(aVariable);
	},


	// FDB - Suppression des mvts MODIFIED/UNMODIFIED
	// Remplacé par this.modified - Impacte le $rcd de fuison
	cellHasBeenModified: function() {
		if (!this.modified) {
			if (this.zeroBaseLineIdx !== undefined) {
				this.dataSrc && this.dataSrc.linesModified.push(this);
				this.modified = true;

			}
			this.forceServerValueModification(true);
			this.forceChange();
		}
	},
	clone: function() {
		var srcLine = new CvgDataSrcLine(this.requester, this.dataSrc, this.id, this.vars.length, this.zeroBaseLineIdx);
		this.cloneVars(srcLine);
		return srcLine;
	},
	cloneVars: function(srcLine) {
		var wMax = this.vars.length;
		var wClonedVariable;
		var wI = 0;
		while (wI < wMax) {
			wClonedVariable = this.vars[wI].clone(srcLine);
			wClonedVariable.srcLine = srcLine;
			srcLine.vars[wI] = wClonedVariable;
			wI++;
		}
	},
	comboDchAddJSON: function(arr) {
		for (var vv in this.vars) {
			var v = this.vars[vv];
			i;
		}
		return arr;
	},
	comboDchModifhas: function() {
		return this.comboDchModif;

	},
	comboDchModifSet: function() {
		if (!this.comboDchModif) {
			this.comboDchModif = true;
			this.forceChange();
		}
	},
	forceChange: function() {
		if (this.dataSrc != null && this.dataSrc.isBlocGrid()) {
			this.dataSrc.forceChange();
		} else {

		}
	},
	getObservableId: function() {
		var fullId = CvgEntity.prototype.getObservableId.call(this);
		fullId += "-L" + (this.zeroBaseLineIdx + 1);
		return fullId;
	},
	getAdxId: function() {
		var wSB = "";
		wSB += this.getDataSrcAdxId();
		wSB += '0';
		wSB += ',';
		wSB += this.zeroBaseLineIdx + 1;
		return wSB;
	},
	notifyStampValueMeta: function(metadata, value, lastStampMod) {
		this.dataSrc.notifyStampMeta(metadata, "line," + (this.zeroBaseLineIdx + 1), value, lastStampMod, this.dataSrc.getObservableId().substring(1));
	},
	// Retourne l'AdxId de la datasource "mere"
	getDataSrcAdxId: function() {
		return this.dataSrc == null ? null : this.dataSrc.getAdxId();
	},

	getVar: function(aIndex) {
		var wVar = null;
		if (aIndex >= 0 && aIndex < this.vars.length) {
			wVar = this.vars[aIndex];
		}
		return wVar;
	},
	isModiefied: function() {
		return this.modified;
	},
	notifyObservers: function() {
		CvgEntity.prototype.notifyObservers.call(this);
	},
	razModification: function() {
		this.modified = false;
		this.comboDchModif = false;
		for (var item in this.varsModified) {
			this.varsModified[item].razModification();
		}
		this.varsModified = [];
		CvgEntity.prototype.razModification.call(this);
	},
	/**
	 * GLUTE : gestion des formats dans les colonnes des tableaux juste apres sa
	 * construction, on associe a la ligne une ligne "mere". (voir clonage dans
	 * la methode "insertServerLines" de "CvgDataSrc") Note: sert a la
	 * propagation du format courant a chaque modification de valeur
	 */
	setFormaterEntity: function(aLineOfFormater) {
		//console.log("setFormaterEntity->" + this.id);
		var vars = this.vars;
		for (var i = 0; i < vars.length; i++) {
			vars[i].setColumnFormater(aLineOfFormater.getVar(i));
		}
	},
	setVar: function(aIndex, v) {
		if (aIndex >= 0 && aIndex < this.vars.length) {
			this.vars[aIndex] = v;
		}
	},
	setZeroBaseIdx: function(zeroBaseIdx) {
		this.zeroBaseLineIdx = zeroBaseIdx;
		var idx = (zeroBaseIdx + 1);
		if (!this.modified) {
			this.dataSrc && this.dataSrc.linesModified.push(this);
			this.modified = true;
		}
		for (var i = 0; this.zeroBaseLineIdx !== undefined && this.vars && i < this.vars.length; i++) {
			//console.log("add cache ", this.vars[i].getAdxIst().toString() + "," + idx);
			this.win.addCache(this.vars[i].getAdxIst().toString() + "," + idx, this.vars[i]);
		}

	},

	toJSON: function(arrDch) {

		var nbCells = this.varsModified.length;
		// On ne transmet pas le N° de ligne
		if (nbCells <= 1) {
			return null;
		}
		var object = {};
		var filled = false;
		// line number - from 1
		for (var j = 1; j < nbCells; j++) {
			var v = this.varsModified[j];
			if (v.hasServerValueModification()) {
				// Styles separes des data
				object[v.getJsonKey()] = v.getValueForJson();
				filled = true;
			}
			if (this.comboDchModifhas() && v instanceof CvgVariableCombo) {
				var x = [];
				var id = v.getObservableId().substring(1);
				x.push(id);
				x.push(this.zeroBaseLineIdx + 1);
				v.toDchJSON(x);
				arrDch.push(x);
			}
		}
		if (!filled) {
			// Null si aucune variable
			return null;
		} else {
			// used only by fusion client for update mvts
			object.$uuid = this.zeroBaseLineIdx;
		}
		return object;
	},
	traverseAll: function(aTraverser) {
		var wMax = this.vars.length;
		var wVariable;
		var wI = 0;
		while (wI < wMax) {
			wVariable = this.vars[wI];

			if (aTraverser.doWhenTraverse(wVariable, wI) === true) {
				return true;
			}

			wI++;
		}
		return false;
	},
	traverseChilds: function(aTraverser) {
		var wTraversingState = false;
		var wX3Variable;
		var wMax = this.vars.length;
		var wI = 0;
		while (wI < wMax) {
			wX3Variable = this.vars[wI];
			if (wX3Variable == null) {
				wTraversingState = true;
			}
			if (wTraversingState !== true) {
				wTraversingState = aTraverser.doWhenTraverse(wX3Variable, wI);
			}
			if (wTraversingState === true) {
				return wTraversingState;
			}
			wI++;
		}
		return wTraversingState;
	},
	traverseSettable: function(aStructIst, aSetter) {
		/*
		 * 15w_017 - Fiche 46222 - Gestion des colonnes de tableau invisibles Si
		 * la porte est un champ ou une colonne
		 */
		if (aStructIst.isBaseBloc()) {
			if (aStructIst.isFieldAllLinesColumnIstRed()) {
				// this is abbreviation for: if (aStructIst.isFieldIst() || aStructIst.isAllLinesOfColumnIst()) {
				var wI = aStructIst.fieldZeroBase;
				if (wI < 0 || wI >= this.vars.length) {
					var wMess = this.client.getMessage('ERROR_VAR_UNKNOWN', wI.toString(), this.vars.length.toString(), this.getAdxId());
					aSetter.setLogicalErrMess(wMess);
					return false;
				}
				var wVariable = this.vars[wI];
				return aSetter.setModifiable(aStructIst, wVariable);
			}
			/*
			 * Si la porte l'ensemble des lignes
			 */
			// the following is abbreviation for: if (aStructIst.isAllLinesOfBlocIst()) {
			if (aStructIst.isAllLinesOfBlocIstRed()) {
				return this.traverseSettableFields(aStructIst, aSetter);
			}
			/*
			 * Sinon la porte est la ligne
			 */
			// the following is abbreviation for: if (aStructIst.isLineIst()) {
			if (aStructIst.isLineIstRed()) {
				var wContinue = aSetter.setModifiable(aStructIst, this);
				// si c'est un changement d'etat : application sur toutes les champs
				var CActiveStateSetter = require('syracuse-x3/lib/convergence/client/CvgRequest').CActiveStateSetter;
				if (wContinue && aSetter instanceof CActiveStateSetter) {
					wContinue = this.traverseSettableFields(aStructIst, aSetter);
				}
				return wContinue;
			}
		} else {
			var wMess = this.getRsrcMess('ERROR_TRAVERSE_SETTABLE', aStructIst.toString(), this.getAdxId(), module.id);
			// TODO TCA
			// module.id is not corresponding to aSetter.class
			//var wMess = getRsrcMess('ERROR_TRAVERSE_SETTABLE', aStructIst.toString(), this.getAdxId(), CStringFacilities.getClasseName(aSetter.class));
			aSetter.setLogicalErrMess(wMess);
			return false;
		}
	},
	traverseSettableFields: function(aStructIst, aSetter) {
		var wContinue = true;
		var wI = 0;
		var wMax = this.vars.length;
		var wVariable;
		while (wI < wMax && wContinue) {
			wVariable = this.vars[wI];

			wContinue = aSetter.setModifiable(aStructIst, wVariable);

			wI++;
		}
		return wContinue;
	}

});