"use strict";
var helpers = require('syracuse-core/lib/helpers');
var CvgEntity = require('syracuse-x3/lib/convergence/model/CvgEntity').CvgEntity;
var CvgVariable = require('syracuse-x3/lib/convergence/model/CvgEntity').CvgVariable;
var CvgVariableCombo = require('syracuse-x3/lib/convergence/model/CvgVariableCombo').CvgVariableCombo;
var helpers = require('syracuse-core/lib/helpers');
var CvgObservable = require('syracuse-x3/lib/convergence/model/CvgObservable').CvgObservable;

var CvgDataSrcLine = exports.CvgDataSrcLine = helpers.defineClass(function(requester, dataSrc, id, nbVars, zeroBaseIdx) {
	CvgEntity.call(this, dataSrc && dataSrc.client, id, 0, 'ROW', requester);
	this.zeroBaseIdx = zeroBaseIdx !== undefined ? zeroBaseIdx : -1;
	this.setZeroBaseIdx(zeroBaseIdx);
	this.requester = requester;
	this.dataSrc = dataSrc;
	this.isEntrySup = false;
	// add a unique identifier
	this.uuid = helpers.uuid.generate();
	// Table des variables => indxees par leur RANG
	this.vars = [];
	// Table des variables => indxees par leur NOM
	this.hVars = {};
	this.modified = false;
	// true if a combo cell has a disableChoice modif
	this.comboDchModif = false;

	// En dernier
	this.setJsonType('ENTITY');
}, CvgEntity, {
	addOneVar: function(aVariable) {
		this.hVars[aVariable.id] = aVariable;
		this.vars.push(aVariable);
	},


	// FDB - Suppression des mvts MODIFIED/UNMODIFIED
	// Remplac√© par this.modified - Impacte le $rcd de fuison
	cellHasBeenModified: function() {
		if (!this.modified) {
			if (this.zeroBaseLineIdx !== undefined) {
				this.dataSrc && this.dataSrc.linesModified.push(this);
				this.modified = true;

			}
			this.forceServerValueModification(true);
			this.forceChange();
		}
	},
	clone: function() {
		var srcLine = new CvgDataSrcLine(this.requester, this.dataSrc, this.id, this.vars.length, this.zeroBaseLineIdx);
		this.cloneVars(srcLine);
		return srcLine;
	},
	cloneVars: function(srcLine) {
		var wMax = this.vars.length;
		var wClonedVariable;
		var wI = 0;
		while (wI < wMax) {
			wClonedVariable = this.vars[wI].clone(srcLine);
			wClonedVariable.srcLine = srcLine;
			srcLine.vars[wI] = wClonedVariable;
			wI++;
		}
	},
	comboDchAddJSON: function(arr) {
		for (var vv in this.vars) {
			var v = this.vars[vv];
			i;
		}
		return arr;
	},
	comboDchModifhas: function() {
		return this.comboDchModif;

	},
	comboDchModifSet: function() {
		if (!this.comboDchModif) {
			this.comboDchModif = true;
			this.forceChange();
		}
	},
	forceChange: function() {
		if (this.dataSrc != null && this.dataSrc.isBlocGrid()) {
			this.dataSrc.forceChange();
		} else {

		}
	},
	getObservableId: function() {
		var fullId = CvgEntity.prototype.getObservableId.call(this);
		fullId += "-L" + (this.zeroBaseLineIdx + 1);
		return fullId;
	},
	getAdxId: function() {
		var wSB = "";
		wSB += this.getDataSrcAdxId();
		wSB += '0';
		wSB += ',';
		wSB += this.zeroBaseLineIdx + 1;
		return wSB;
	},
	notifyStampValueMeta: function(metadata, value, lastStampMod) {
		this.dataSrc.notifyStampMeta(metadata, "line," + (this.zeroBaseLineIdx + 1), value, lastStampMod, this.dataSrc.getObservableId().substring(1));
	},
	// Retourne l'AdxId de la datasource "mere"
	getDataSrcAdxId: function() {
		return this.dataSrc == null ? null : this.dataSrc.getAdxId();
	},
	getListEntityDifferentValueMeta: function(map) {
		var i = 0;
		// line stamp and value if exists
		var lineStamp = {
			"PCOL": {
				"stamp": this.lastStampModPCol,
				value: this.pColor
			},
			"STY": {
				"stamp": this.lastStampModSty,
				value: this.style
			},
			"ACT": {
				"stamp": this.lastStampModActzo,
				value: this.actzo
			},
			"SEL": {
				"stamp": this.lastStampModSelected,
				value: this.selected
			},
			"VIS": {
				"stamp": this.lastStampModVisible,
				value: this.visible
			},
			"FMT": {
				"stamp": this.lastStampModFmt,
				value: this.formatStr
			},
			"STT": {
				"stamp": this.lastStampModState,
				value: this.state
			},
			"TIT": {
				"stamp": this.lastStampModTit,
				value: this.title
			}
		};
		for (var it in this.vars) {
			// get the column
			var item = this.vars[it];
			if (i !== 0) {
				var colVar = this.dataSrc.entrySup != null ? this.dataSrc.entrySup.vars[i] || {} : {};
				// column value and stamp if exists
				var colStamp = {
					"PCOL": {
						"stamp": colVar.lastStampModPCol,
						value: colVar.pColor
					},
					"STY": {
						"stamp": colVar.lastStampModSty,
						value: colVar.style
					},
					"ACT": {
						"stamp": colVar.lastStampModActzo,
						value: colVar.actzo
					},
					"SEL": {
						"stamp": colVar.lastStampModSelected,
						value: colVar.selected
					},
					"VIS": {
						"stamp": colVar.lastStampModVisible,
						value: colVar.visible
					},
					"FMT": {
						"stamp": colVar.lastStampModFmt,
						value: colVar.formatStr
					},
					"STT": {
						"stamp": colVar.lastStampModState,
						value: colVar.state
					},
					"TIT": {
						"stamp": colVar.lastStampModTit,
						value: colVar.title
					}
				};
				// current cell stamp and value
				var stamp = {
					"PCOL": {
						"value": item.pColor,
						stamp: item.lastStampModPCol
					},
					"STY": {
						"value": item.style,
						stamp: item.lastStampModSty
					},
					"ACT": {
						"value": item.actzo,
						stamp: item.lastStampModActzo
					},
					"SEL": {
						"value": item.selected,
						stamp: item.lastStampModSelected
					},
					"VIS": {
						"value": item.visible,
						stamp: item.lastStampModVisible
					},
					"FMT": {
						"stamp": item.lastStampModFmt,
						value: item.formatStr
					},
					"STT": {
						"value": item.state,
						stamp: item.lastStampModState
					},
					"TIT": {
						"value": item.title,
						stamp: item.lastStampModTitle
					}
				};

				// 'FMT':
				if (item.lastStampModFmt != -1 && item.formatStr && item.formatStr !== "" && item.format.isVisible()) {
					map["FMT"] = map["FMT"] || {};
					map["FMT"][item.lastStampModFmt] = item;
				}
				Object.keys(stamp).forEach(function(metaKey) {
					map[metaKey] = map[metaKey] || {};
					if (stamp[metaKey].stamp !== -1) {
						if (lineStamp[metaKey].stamp > colStamp[metaKey].stamp) { // la ligne est plus recente
							if (stamp[metaKey].value != null && (stamp[metaKey].value !== lineStamp[metaKey].value || stamp[metaKey].value === "") && stamp[metaKey].stamp > lineStamp[metaKey].stamp) {
								map[metaKey][stamp[metaKey].stamp] = item;
							}
						} else {
							if (stamp[metaKey].value != null && (colStamp[metaKey].stamp === -1 || stamp[metaKey].value !== colStamp[metaKey].value || stamp[metaKey].value === "") && stamp[metaKey].stamp > colStamp[metaKey].stamp) {
								map[metaKey][stamp[metaKey].stamp] = item;
							}
						}
					}
				});

			}
			i++;
		}
		return map;
	},
	getListEntityDifferentValue: function(metadata) {
		var map = {};
		var value = "";
		var colVal = "";
		var i = 0;
		var meta = metadata;
		for (var it in this.vars) {
			// get the column 
			var item = this.vars[it];
			if (i !== 0) {
				var colVar = this.dataSrc.entrySup != null ? this.dataSrc.entrySup.vars[i] : null;
				var valueItem = "";
				var stamp = -1;
				var lineStamp = -1;
				var colStamp = -1;
				switch (meta) {
					case 'PCOL':
						valueItem = item.pColor; // value cell
						value = this.pColor; // value line
						if (colVar != null) {
							colVal = colVar.pColor; // value column
							colStamp = colVar.lastStampModPCol;
						}
						stamp = item.lastStampModPCol;
						lineStamp = this.lastStampModPCol;
						break;

					case 'STY':
						valueItem = item.style; // value cell
						value = this.style; // value line
						if (colVar != null) {
							colVal = colVar.style; // value column
							colStamp = colVar.lastStampModSty;
						}
						stamp = item.lastStampModSty;
						lineStamp = this.lastStampModSty;
						break;
					case 'SEL':
						valueItem = item.selected;
						value = this.selected;
						stamp = item.lastStampModSelected;
						lineStamp = this.lastStampModSelected;
						if (colVar != null) {
							colStamp = colVar.lastStampModSelected;
							colVal = colVar.selected; // value column
						}
						break;
					case 'ACT':
						valueItem = item.actzo;
						value = this.actzo;
						stamp = item.lastStampModActzo;
						lineStamp = this.lastStampModActzo;
						if (colVar != null) {
							colStamp = colVar.lastStampModActzo;
							colVal = colVar.actzo;
						}
						break;
					case 'VIS':
						valueItem = item.visible;
						value = this.visible;
						stamp = item.lastStampModVisible;
						lineStamp = this.lastStampModVisible;
						if (colVar != null) {
							colStamp = colVar.lastStampModVisible;
							colVal = colVar.visible; // value column
						}
						break;
					case 'TIT':
						valueItem = item.title;
						value = this.title;
						stamp = item.lastStampModTit;
						lineStamp = this.lastStampModTit;
						if (colVar != null) {
							colStamp = colVar.lastStampModTit;
							colVal = colVar.title; // value column
						}
						break;
					case 'FMT':
						if (item.lastStampModFmt != -1 && item.formatStr && item.formatStr !== "" && item.format.isVisible()) {
							map[item.lastStampModFmt] = item;
						}
						break;
				}

				if (stamp !== -1) {
					if (lineStamp > colStamp) { // la ligne est plus recente
						if (valueItem != null && (valueItem !== value || valueItem === "") && stamp > lineStamp) {
							map[stamp] = item;
						}
					} else {
						if (valueItem != null && (colStamp === -1 || valueItem !== colVal || valueItem === "") && stamp > colStamp) {
							map[stamp] = item;
						}
					}
				}
			}
			i++;
		}
		return map;
	},

	getListEntityOlderThanMeta: function(map, stampLine, olderthan) {
		for (var vv in this.vars) {
			var v = this.vars[vv];
			var stamp = {
				"PCOL": {
					"stamp": v.lastStampModPCol,
					hasValue: v.pColor !== -1
				},
				"STY": {
					"stamp": v.lastStampModSty,
					hasValue: v.style != null
				},
				"ACT": {
					"stamp": v.lastStampModActzo,
					hasValue: v.lastStampModActzo !== -1
				},
				"SEL": {
					"stamp": v.lastStampModSelected,
					hasValue: v.lastStampModSelected !== -1
				},
				"VIS": {
					"stamp": v.lastStampModVisible,
					hasValue: v.lastStampModVisible !== 1
				},
				"FMT": {
					"stamp": v.lastStampModFmt,
					hasValue: v.format != null && v.format.isVisible()
				},
				"TIT": {
					"stamp": v.lastStampModTit,
					hasValue: v.title != null
				}
			};

			Object.keys(stamp).forEach(function(key) {
				map[key] = map[key] || {};
				if (olderthan) {
					if (stamp[key].stamp !== -1) {
						if (stamp[key].stamp < stampLine[key].stamp && stamp[key].hasValue) {
							map[key][stamp[key].stamp] = v;
						}
					}
				} else {
					if (stamp[key].stamp !== -1) {
						if (stamp[key].stamp >= stampLine[key].stamp && stamp[key].hasValue) {
							map[key][stamp[key].stamp] = v;
						}
					}
				}
			});

		}
		return map;
	},
	getListEntityOlderThan: function(metaData, timstamp, olderthan) {
		var map = {};
		var meta = metaData.length < 3 ? metaData.substring(0, 4) : metaData;
		for (var vv in this.vars) {
			var v = this.vars[vv];
			var hasValue = false;
			var stamp = -1;
			switch (metaData) {
				case 'FMT':
					stamp = v.lastStampModFmt;
					hasValue = v.format != null && v.format.isVisible();
					break;
				case 'ACT':
					stamp = v.lastStampModActzo;
					hasValue = stamp !== -1;
					break;
				case 'VIS':
					stamp = v.lastStampModVisible;
					hasValue = stamp !== -1;
					break;
				case 'SEL':
					stamp = v.lastStampModSelected;
					hasValue = stamp !== -1;
					break;
				case 'PCOL':
					stamp = v.lastStampModSty;
					hasValue = v.pColor !== -1;
					break;
				case 'STY':
					stamp = v.lastStampModSty;
					hasValue = v.style != null;
					break;
				case 'TIT':
					stamp = v.lastStampModTit;
					hasValue = v.title != null;
					break;
			}
			if (olderthan) {
				if (stamp !== -1) {
					if (stamp < timstamp && hasValue) {
						map[stamp] = v;
					}
				}
			} else {
				if (stamp !== -1) {
					if (stamp >= timstamp && hasValue) {
						map[stamp] = v;
					}
				}
			}
		}
		return map;
	},
	getVar: function(aIndex) {
		var wVar = null;
		if (aIndex >= 0 && aIndex < this.vars.length) {
			wVar = this.vars[aIndex];
		}
		return wVar;
	},
	isModiefied: function() {
		return this.modified;
	},
	notifyObservers: function() {
		CvgEntity.prototype.notifyObservers.call(this);
	},
	razModification: function() {
		this.modified = false;
		this.comboDchModif = false;
		for (var item in this.vars) {
			this.vars[item].razModification();
		}
		CvgEntity.prototype.razModification.call(this);
	},
	/**
	 * GLUTE : gestion des formats dans les colonnes des tableaux juste apres sa
	 * construction, on associe a la ligne une ligne "mere". (voir clonage dans
	 * la methode "insertServerLines" de "CvgDataSrc") Note: sert a la
	 * propagation du format courant a chaque modification de valeur
	 */
	setFormaterEntity: function(aLineOfFormater) {
		//console.log("setFormaterEntity->" + this.id);
		var vars = this.vars;
		for (var i = 0; i < vars.length; i++) {
			vars[i].setColumnFormater(aLineOfFormater.getVar(i));
		}
	},
	setVar: function(aIndex, v) {
		if (aIndex >= 0 && aIndex < this.vars.length) {
			this.vars[aIndex] = v;
		}
	},
	setZeroBaseIdx: function(zeroBaseIdx) {
		this.zeroBaseLineIdx = zeroBaseIdx;
		var idx = (zeroBaseIdx + 1);
		if (!this.modified) {
			this.dataSrc && this.dataSrc.linesModified.push(this);
			this.modified = true;
		}
		for (var i = 0; this.zeroBaseLineIdx !== undefined && this.vars && i < this.vars.length; i++) {
			//console.log("add cache ", this.vars[i].getAdxIst().toString() + "," + idx);
			this.win.addCache(this.vars[i].getAdxIst().toString() + "," + idx, this.vars[i]);
		}

	},

	toJSON: function(arrDch) {

		var nbCells = this.vars.length;
		// On ne transmet pas le N¬∞ de ligne
		if (nbCells <= 1) {
			return null;
		}
		var object = {};
		var filled = false;
		// line number - from 1
		for (var j = 1; j < nbCells; j++) {
			var v = this.getVar(j);
			if (v.hasServerValueModification()) {
				// Styles separes des data
				object[v.getJsonKey()] = v.getValueForJson();
				filled = true;
			}
			if (this.comboDchModifhas() && v instanceof CvgVariableCombo) {
				var x = [];
				var id = v.getObservableId().substring(1);
				x.push(id);
				x.push(this.zeroBaseLineIdx + 1);
				v.toDchJSON(x);
				arrDch.push(x);
			}
		}
		if (!filled) {
			// Null si aucune variable
			return null;
		} else {
			// used only by fusion client for update mvts
			object.$uuid = this.zeroBaseLineIdx;
		}
		return object;
	},
	traverseAll: function(aTraverser) {
		var wMax = this.vars.length;
		var wVariable;
		var wI = 0;
		while (wI < wMax) {
			wVariable = this.vars[wI];

			if (aTraverser.doWhenTraverse(wVariable, wI) === true) {
				return true;
			}

			wI++;
		}
		return false;
	},
	traverseChilds: function(aTraverser) {
		var wTraversingState = false;
		var wX3Variable;
		var wMax = this.vars.length;
		var wI = 0;
		while (wI < wMax) {
			wX3Variable = this.vars[wI];
			if (wX3Variable == null) {
				wTraversingState = true;
			}
			if (wTraversingState !== true) {
				wTraversingState = aTraverser.doWhenTraverse(wX3Variable, wI);
			}
			if (wTraversingState === true) {
				return wTraversingState;
			}
			wI++;
		}
		return wTraversingState;
	},
	traverseSettable: function(aStructIst, aSetter) {
		/*
		 * 15w_017 - Fiche 46222 - Gestion des colonnes de tableau invisibles Si
		 * la porte est un champ ou une colonne
		 */
		if (aStructIst.isBaseBloc()) {
			if (aStructIst.isFieldAllLinesColumnIstRed()) {
				// this is abbreviation for: if (aStructIst.isFieldIst() || aStructIst.isAllLinesOfColumnIst()) {
				var wI = aStructIst.fieldZeroBase;
				if (wI < 0 || wI >= this.vars.length) {
					var wMess = this.client.getMessage('ERROR_VAR_UNKNOWN', wI.toString(), this.vars.length.toString(), this.getAdxId());
					aSetter.setLogicalErrMess(wMess);
					return false;
				}
				var wVariable = this.vars[wI];
				return aSetter.setModifiable(aStructIst, wVariable);
			}
			/*
			 * Si la porte l'ensemble des lignes
			 */
			// the following is abbreviation for: if (aStructIst.isAllLinesOfBlocIst()) {
			if (aStructIst.isAllLinesOfBlocIstRed()) {
				return this.traverseSettableFields(aStructIst, aSetter);
			}
			/*
			 * Sinon la porte est la ligne
			 */
			// the following is abbreviation for: if (aStructIst.isLineIst()) {
			if (aStructIst.isLineIstRed()) {
				var wContinue = aSetter.setModifiable(aStructIst, this);
				// si c'est un changement d'etat : application sur toutes les champs
				var CActiveStateSetter = require('syracuse-x3/lib/convergence/client/CvgRequest').CActiveStateSetter;
				if (wContinue && aSetter instanceof CActiveStateSetter) {
					wContinue = this.traverseSettableFields(aStructIst, aSetter);
				}
				return wContinue;
			}
		} else {
			var wMess = this.getRsrcMess('ERROR_TRAVERSE_SETTABLE', aStructIst.toString(), this.getAdxId(), module.id);
			// TODO TCA
			// module.id is not corresponding to aSetter.class
			//var wMess = getRsrcMess('ERROR_TRAVERSE_SETTABLE', aStructIst.toString(), this.getAdxId(), CStringFacilities.getClasseName(aSetter.class));
			aSetter.setLogicalErrMess(wMess);
			return false;
		}
	},
	traverseSettableFields: function(aStructIst, aSetter) {
		var wContinue = true;
		var wI = 0;
		var wMax = this.vars.length;
		var wVariable;
		while (wI < wMax && wContinue) {
			wVariable = this.vars[wI];

			wContinue = aSetter.setModifiable(aStructIst, wVariable);

			wI++;
		}
		return wContinue;
	}

});