"use strict";
var helpers = require('syracuse-core/lib/helpers');
var CvgEntity = require('syracuse-x3/lib/convergence/model/CvgEntity').CvgEntity;
var CvgVariable = require('syracuse-x3/lib/convergence/model/CvgEntity').CvgVariable;
var CvgVariableCombo = require('syracuse-x3/lib/convergence/model/CvgVariableCombo').CvgVariableCombo;

var CvgDataSrcLine = exports.CvgDataSrcLine = helpers.defineClass(function(requester, dataSrc, id, nbVars, zeroBaseIdx) {
	CvgEntity.call(this, dataSrc && dataSrc.client, id, 0, 'ROW');
	this.zeroBaseIdx = zeroBaseIdx !== undefined ? zeroBaseIdx : -1;
	this.setZeroBaseIdx(zeroBaseIdx);
	this.requester = requester;
	this.dataSrc = dataSrc;
	// Table des variables => indxees par leur RANG
	this.vars = [];
	// Table des variables => indxees par leur NOM
	this.hVars = {};
	this.modified = false;
	// true if a combo cell has a disableChoice modif
	this.comboDchModif = false;
	// En dernier
	this.setJsonType('ENTITY');
}, CvgEntity, {
	addOneVar: function(aVariable) {
		this.hVars[aVariable.id] = aVariable;
		this.vars.push(aVariable);
	},
	// FDB - Suppression des mvts MODIFIED/UNMODIFIED
	// Remplacé par this.modified - Impacte le $rcd de fuison
	cellHasBeenModified: function() {
		if (!this.modified) {
			this.modified = true;
			this.forceServerValueModification(true);
			this.forceChange();
		}
	},
	clone: function() {
		var srcLine = new CvgDataSrcLine(this.requester, this.dataSrc, this.id, this.vars.length, this.zeroBaseLineIdx);
		this.cloneVars(srcLine);
		return srcLine;
	},
	cloneVars: function(srcLine) {
		var wMax = this.vars.length;
		var wClonedVariable;
		var wI = 0;
		while (wI < wMax) {
			wClonedVariable = this.vars[wI].clone();
			wClonedVariable.srcLine = srcLine;
			srcLine.vars[wI] = wClonedVariable;
			wI++;
		}
	},
	comboDchAddJSON: function(arr) {
		for (var vv in this.vars) {
			var v = this.vars[vv];
			if (v instanceof CvgVariableCombo) {
				var x = [];
				x.push(v.id);
				x.push(this.zeroBaseLineIdx + 1);
				v.toDchJSON(x);
				arr.push(x);
			}
		}
		return arr;
	},
	comboDchModifhas: function() {
		return this.comboDchModif;

	},
	comboDchModifSet: function() {
		if (!this.comboDchModif) {
			this.comboDchModif = true;
			this.forceChange();
		}
	},
	forceChange: function() {
		if (this.dataSrc != null && this.dataSrc.isBlocGrid()) {
			this.dataSrc.forceChange();
		} else {

		}
	},
	getObservableId: function() {
		var fullId = CvgEntity.prototype.getObservableId.call(this);
		fullId += "-L" + (this.zeroBaseLineIdx + 1);
		return fullId;
	},
	getAdxId: function() {
		var wSB = "";
		wSB += this.getDataSrcAdxId();
		wSB += '0';
		wSB += ',';
		wSB += this.zeroBaseLineIdx + 1;
		return wSB;
	},

	// Retourne l'AdxId de la datasource "mere"
	getDataSrcAdxId: function() {
		return this.dataSrc == null ? null : this.dataSrc.getAdxId();
	},
	getListEntityDifferentValue: function(metadata) {
		var map = {};
		var value = "";
		var colVal = "";
		var i = 0;
		for (var it in this.vars) {
			var item = this.vars[it];
			if (i !== 0) {
				var colVar = this.dataSrc.entrySup != null ? this.dataSrc.entrySup.vars[i] : null;
				var valueItem = "";
				var stamp = -1;
				var lineStamp = -1;
				var colStamp = -1;
				switch (metadata) {
					case 'STY':
						valueItem = item.style; // value cell
						value = this.style; // value line
						if (colVar != null) {
							colVal = colVar.style; // value column
							colStamp = colVar.lastStampModSty;
						}
						stamp = item.lastStampModSty;
						lineStamp = this.lastStampModSty;
						break;
					case 'STT':
						valueItem = item.state.toString();
						value = this.state.toString();
						stamp = item.lastStampModState;
						lineStamp = this.lastStampModState;
						if (colVar != null) {
							colStamp = colVar.lastStampModState;
							colVal = colVar.state.toString(); // value column
						}
						break;
					case 'TIT':
						valueItem = item.title;
						value = this.title;
						stamp = item.lastStampModTit;
						lineStamp = this.lastStampModTit;
						if (colVar != null) {
							colStamp = colVar.lastStampModTit;
							colVal = colVar.title; // value column
						}
						break;
					case 'FMT':
						if (item.format != null) {
							valueItem = item.format.format;
							if (this.format != null) {
								value = this.format.format;
							}
							if (colVar != null) {
								if (colVar.format != null) {
									colVal = colVar.format.format; // value column
								}
								colStamp = colVar.lastStampModFmt;
							}
							stamp = item.lastStampModFmt;
							lineStamp = this.lastStampModFmt;
						}
						break;
				}
				if (stamp !== -1) {
					if (lineStamp > colStamp) { // la ligne est plus recente
						if (valueItem != null && (valueItem !== value || valueItem === "") && stamp > lineStamp) {
							map[stamp] = item;
						}
					} else {
						if (valueItem != null && (valueItem !== colVal || valueItem === "") && stamp > colStamp) {
							map[stamp] = item;
						}
					}
				}
			}
			i++;
		}
		return map;
	},
	getListEntityOlderThan: function(metaData, timstamp, olderthan) {
		var map = {};
		for (var vv in this.vars) {
			var v = this.vars[vv];
			var hasValue = false;
			var stamp = -1;
			switch (metaData) {
				case 'FMT':
					stamp = v.lastStampModFmt;
					hasValue = v.format != null;
					break;
				case 'STT':
					stamp = v.lastStampModState;
					hasValue = stamp !== -1;
					break;
				case 'STY':
					stamp = v.lastStampModSty;
					hasValue = v.style != null && v.style.length !== 0;
					break;
				case 'TIT':
					stamp = v.lastStampModTit;
					hasValue = v.title != null && v.title.length !== 0;
					break;
			}
			if (olderthan) {
				if (stamp !== -1) {
					if (stamp < timstamp && hasValue) {
						map[stamp] = v;
					}
				}
			} else {
				if (stamp !== -1) {
					if (stamp >= timstamp && hasValue) {
						map[stamp] = v;
					}
				}
			}
		}
		return map;
	},
	getVar: function(aIndex) {
		var wVar = null;
		if (aIndex >= 0 && aIndex < this.vars.length) {
			wVar = this.vars[aIndex];
		}
		return wVar;
	},
	initVars: function(nbVar) {
		this.vars = new CvgVariable[nbVar];
	},
	isModiefied: function() {
		return this.modified;
	},
	notifyObservers: function() {
		CvgEntity.prototype.notifyObservers.call(this);
	},
	razModification: function() {
		this.modified = false;
		this.comboDchModif = false;
		for (var item in this.vars) {
			this.vars[item].razModification();
		}
		CvgEntity.prototype.razModification.call(this);
	},
	/**
	 * GLUTE : gestion des formats dans les colonnes des tableaux juste apres sa
	 * construction, on associe a la ligne une ligne "mere". (voir clonage dans
	 * la methode "insertServerLines" de "CvgDataSrc") Note: sert a la
	 * propagation du format courant a chaque modification de valeur
	 */
	setFormaterEntity: function(aLineOfFormater) {
		var vars = this.vars;
		for (var i = 0; i < vars.length; i++) {
			vars[i].setColumnFormater(aLineOfFormater.getVar(i));
		}
	},
	setVar: function(aIndex, v) {
		if (aIndex >= 0 && aIndex < this.vars.length) {
			this.vars[aIndex] = v;
		}
	},
	setZeroBaseIdx: function(zeroBaseIdx) {
		this.zeroBaseLineIdx = zeroBaseIdx;
	},
	toJSON: function() {
		var nbCells = this.vars.length;
		// On ne transmet pas le N° de ligne
		if (nbCells <= 1) {
			return null;
		}
		var object = {};
		// line number - from 1
		for (var j = 1; j < nbCells; j++) {
			var v = this.getVar(j);
			if (v.hasServerValueModification()) {
				// Styles separes des data
				object[v.getJsonKey()] = v.getValueForJson();
			}
		}
		if (Object.keys(object).length === 0) {
			// Null si aucune variable
			return null;
		} else {
			// used only by fusion client for update mvts
			object.$uuid = this.zeroBaseLineIdx;
		}
		return object;
	},
	traverseAll: function(aTraverser) {
		var wMax = this.vars.length;
		var wVariable;
		var wI = 0;
		while (wI < wMax) {
			wVariable = this.vars[wI];

			if (aTraverser.doWhenTraverse(wVariable, wI) === true) {
				return true;
			}

			wI++;
		}
		return false;
	},
	traverseChilds: function(aTraverser) {
		var wTraversingState = false;
		var wX3Variable;
		var wMax = this.vars.length;
		var wI = 0;
		while (wI < wMax) {
			wX3Variable = this.vars[wI];
			if (wX3Variable == null) {
				wTraversingState = true;
			}
			if (wTraversingState !== true) {
				wTraversingState = aTraverser.doWhenTraverse(wX3Variable, wI);
			}
			if (wTraversingState === true) {
				return wTraversingState;
			}
			wI++;
		}
		return wTraversingState;
	},
	traverseSettable: function(aStructIst, aSetter) {
		/*
		 * 15w_017 - Fiche 46222 - Gestion des colonnes de tableau invisibles Si
		 * la porte est un champ ou une colonne
		 */
		if (aStructIst.isFieldIst() || aStructIst.isAllLinesOfColumnIst()) {
			var wI = aStructIst.fieldZeroBase;
			if (wI < 0 || wI >= this.vars.length) {
				var wMess = this.client.getMessage('ERROR_VAR_UNKNOWN', wI.toString(), this.vars.length.toString(), this.getAdxId());
				aSetter.setLogicalErrMess(wMess);
				return false;
			}
			var wVariable = this.vars[wI];
			return aSetter.setModifiable(aStructIst, wVariable);
		}
		/*
		 * Si la porte l'ensemble des lignes
		 */
		else if (aStructIst.isAllLinesOfBlocIst()) {
			return this.traverseSettableFields(aStructIst, aSetter);
		}
		/*
		 * Sinon la porte est la ligne
		 */
		else if (aStructIst.isLineIst()) {
			var wContinue = aSetter.setModifiable(aStructIst, this);
			// si c'est un changement d'etat : application sur toutes les champs
			var CServerStateSetter = require('syracuse-x3/lib/convergence/client/CvgRequest').CServerStateSetter;
			if (wContinue && aSetter instanceof CServerStateSetter) {
				wContinue = this.traverseSettableFields(aStructIst, aSetter);
			}
			return wContinue;
		} else {
			var wMess = this.getRsrcMess('ERROR_TRAVERSE_SETTABLE', aStructIst.toString(), this.getAdxId(), module.id);
			// TODO TCA
			// module.id is not corresponding to aSetter.class
			//var wMess = getRsrcMess('ERROR_TRAVERSE_SETTABLE', aStructIst.toString(), this.getAdxId(), CStringFacilities.getClasseName(aSetter.class));
			aSetter.setLogicalErrMess(wMess);
			return false;
		}
	},
	traverseSettableFields: function(aStructIst, aSetter) {
		var wContinue = true;
		var wI = 0;
		var wMax = this.vars.length;
		var wVariable;
		while (wI < wMax && wContinue) {
			wVariable = this.vars[wI];

			wContinue = aSetter.setModifiable(aStructIst, wVariable);

			wI++;
		}
		return wContinue;
	}

});