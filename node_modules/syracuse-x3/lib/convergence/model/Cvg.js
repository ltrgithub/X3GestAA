"use strict";
var helpers = require('syracuse-core/lib/helpers');



var Cvg = exports.Cvg = {
	//sens de la date pour le format - Idem Cvg
	FTM_X3DATE_MDY: 0,
	FTM_X3DATE_DMY: 1,
	FTM_X3DATE_YMD: 2,
	
	AFF_SYNCHRONE_ACTION_CLOSE: 3,
	AFF_SYNCHRONE_ACTION_MODIFY: 2,
	AFF_SYNCHRONE_ACTION_OPEN: 1,
	AFF_SYNCHRONE_TYPE_ACKREQUEST: 24,
	AFF_SYNCHRONE_TYPE_DEBUGOFF: 22,
	AFF_SYNCHRONE_TYPE_DEBUGON: 21,
	AFF_SYNCHRONE_TYPE_PROGRESS: 14,
	AFF_SYNCHRONE_TYPE_SESSION: 20,
	AFF_SYNCHRONE_PREFIX_LONG: 9,
	AFF_SYNCHRONE_TYPE_TEMPON: 12,
	AFF_SYNCHRONE_TYPE_VALIDCAR: 13,
	AFF_SYNCHRONE_TYPE_VOICE: 25,
	AFF_SYNCHRONE_TYPE_LONG: 4,
	AFF_SYNCHRONE_HEADER_LONG: 2,
	AFF_SYNCHRONE_ACTION_LONG: 3,
	AFF_SYNCHRONE_HEADER: "$$",
	END: -1,
	UNKNOWN: 0,

	affSynchroneActionToString: function(aAction) {
		switch (aAction) {
		case AFF_SYNCHRONE_ACTION_CLOSE:
			return "CLO";

		case AFF_SYNCHRONE_ACTION_MODIFY:
			return "MOD";

		case AFF_SYNCHRONE_ACTION_OPEN:
			return "OPE";

		default:
			return null;
		}
	},
	affSynchroneTypeToString: function(aType) {
		switch (aType) {
		case Cvg.AFF_SYNCHRONE_TYPE_ACKREQUEST:
			return "ACK_";

		case AFF_SYNCHRONE_TYPE_VALIDCAR:
			return "VLC_";

		case AFF_SYNCHRONE_TYPE_PROGRESS:
			return "PROG";

		case Cvg.AFF_SYNCHRONE_TYPE_TEMPON:
			return "TEMP";

		case Cvg.AFF_SYNCHRONE_TYPE_SESSION:
			return "SESS";

		case Cvg.AFF_SYNCHRONE_TYPE_DEBUGON:
		case Cvg.AFF_SYNCHRONE_TYPE_DEBUGOFF:
			return "DBG_";

		case Cvg.AFF_SYNCHRONE_TYPE_VOICE:
			return "VOIC";

		default:
			return null;
		}
	},
	puissance: function(aInteger, aPuissance) {
		if (aPuissance === 0) {
			return 1;
		} else {
			var wResult = aInteger;
			for (wI = 1; wI < aPuissance; wI++) {
				wResult *= aInteger;
			}
			return wResult;
		}
	},

	// 20121222113428 --> 2012/12/22 - 11:34:28
	timeStampFormats: function(ts, dateOrder) {
		if (ts == null) {
			return "";
		}
		var y, m, d;
		if (ts.length >= 4) {
			y = ts.substring(0, 4);
			ts = ts.substring(4);
			if (ts.length >= 2) {
				m = ts.substring(0, 2);
				ts = ts.substring(2);
				if (ts.length >= 2) {
					d = ts.substring(0, 2);
					ts = ts.substring(2);
					var sb = "";
					if (dateOrder === Cvg.FTM_X3DATE_DMY) {
						sb += d + '/' + m + '/' + y;
					} else if (dateOrder === Cvg.FTM_X3DATE_YMD) {
						sb += y + '/' + m + '/' + d;
					} else {
						sb += m + '/' + d + '/' + y;
					}
					if (ts.length >= 2) {
						sb += " - " + ts.substring(0, 2);
						ts = ts.substring(2);
						if (ts.length >= 2) {
							sb += ':' + ts.substring(0, 2);
							ts = ts.substring(2);
							if (ts.length >= 2) {
								sb += ':' + ts.substring(0, 2);
								ts = ts.substring(2);
							}
							return sb;
						}
					}
				}
			}
		}
		return ts;

	},
	timeStampToMillisecs: function(aTimeStamp) {
		var wDiviseur = puissance(10, 10);
		var year = new Long(aTimeStamp / wDiviseur).intValue();

		aTimeStamp = aTimeStamp - year * wDiviseur;
		wDiviseur = puissance(10, 8);
		var month = new Long(aTimeStamp / wDiviseur).intValue();

		aTimeStamp = aTimeStamp - month * wDiviseur;
		wDiviseur = puissance(10, 6);
		var date = new Long(aTimeStamp / wDiviseur).intValue();

		aTimeStamp = aTimeStamp - date * wDiviseur;
		wDiviseur = puissance(10, 4);
		var hour = new Long(aTimeStamp / wDiviseur).intValue();

		aTimeStamp = aTimeStamp - hour * wDiviseur;
		wDiviseur = puissance(10, 2);
		var minute = new Long(aTimeStamp / wDiviseur).intValue();

		aTimeStamp = aTimeStamp - minute * wDiviseur;
		wDiviseur = puissance(10, 0);
		var second = new Long(aTimeStamp / wDiviseur).intValue();

		var wCalendar = java.util.Calendar.instance;
		wCalendar.set(year, month - 1, date, hour, minute, second); // mois de 0
		// ï¿½ 11
		wCalendar.set(java.util.Calendar.MILLISECOND, 0);
		return wCalendar.time.time;
	}

}

