"use strict";
var helpers = require('syracuse-core').helpers;
var CvgLeftListLine = require('syracuse-x3/lib/convergence/model/CvgLeftListLine').CvgLeftListLine;
var CvgResu = require('syracuse-x3/lib/convergence/types/CvgResu').CvgResu;
var CvgResuTag = require('syracuse-x3/lib/convergence/types/CvgResu').TAG;

var CvgLeftListLineNode = exports.CvgLeftListLineNode = helpers.defineClass(function(aStackedWindow, aLeftList, aId, aNbVariables, idx) {
	CvgLeftListLine.call(this, aStackedWindow, aLeftList, aId, aNbVariables, idx);
	this.subLeftListNodes = [];
}, CvgLeftListLine, {
	attachLefListNode: function(aLeftListNode) {
		this.subLeftListNodes.push(aLeftListNode);
	},
	clone: function() {
		var idx = this.dataSrc.lines.length;
		var wClone = new CvgLeftListLineNode(this.requester, this.dataSrc, this.id, this.vars.length, idx);
		this.cloneVars(wClone);
		return wClone;
	},
	hasSubNode: function() {
		return this.subLeftListNodes.length > 0;
	},
	traverseChilds: function(aTraverser) {
		var wTraversingState = false;
		if (this.hasSubNode()) {
			wTraversingState = this.traverseSubNodes(aTraverser);
		}
		if (wTraversingState === false) {
			CvgLeftListLine.prototype.traverseChilds.call(this, aTraverser);
		}
		return wTraversingState;
	},
	traverseNodes: function(aTraverser, aWithSubNodes) {

		var wTraversingState = false;
		var wLeftListNode;
		var wMax = this.subLeftListNodes.length;
		var wI = 0;
		while (wI < wMax) {
			wLeftListNode = this.subLeftListNodes[wI];
			wTraversingState = aTraverser.doWhenTraverse(wLeftListNode, wI);
			if (wTraversingState !== true && aWithSubNodes && wLeftListNode.hasSubNode()) {
				wTraversingState = wLeftListNode.traverseNodes(aTraverser, aWithSubNodes);
			}
			if (wTraversingState === true) {
				return true;
			}
			wI++;
		}
		return wTraversingState;
	},
	checkServerModification: function(item) {
		return true; // bypass check , need to always send info
	},
	traverseSubNodes: function(aTraverser) {
		return this.traverseNodes(aTraverser, false);
	}
});