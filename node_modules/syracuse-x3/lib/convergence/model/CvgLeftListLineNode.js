"use strict";
var helpers = require('syracuse-core/lib/helpers');
var CvgLeftListLine = require('syracuse-x3/lib/convergence/model/CvgLeftListLine').CvgLeftListLine;


var CvgLeftListLineNode = exports.CvgLeftListLineNode = helpers.defineClass(function(aStackedWindow, aLeftList, aId, aNbVariables, idx) {
	CvgLeftListLine.call(this, aStackedWindow, aLeftList, aId, aNbVariables, idx);
	this.subLeftListNodes = [];
}, CvgLeftListLine, {
	attachLefListNode: function(aLeftListNode) {
		this.subLeftListNodes.push(aLeftListNode);
	},
	clone: function() {
		var idx = this.dataSrc.lines.length;
		var wClone = new CvgLeftListLineNode(this.requester, this.dataSrc, this.id, this.vars.length, idx);
		this.cloneVars(wClone);
		return wClone;
	},
	hasSubNode: function() {
		return this.subLeftListNodes.length > 0;
	},
	setColumns: function(aIdx, aText, aClf) {
		this.setZeroBaseIdx(aIdx);
		this.setCle(aClf);
		var v = this.getVar(0);
		if (v != null) {
			v.setUnModifiableServerValue(new CvgResu(CvgResu.TAG_STRU, aText));
		}
	},
	traverseChilds: function(aTraverser) {
		var wTraversingState = false;
		if (this.hasSubNode()) {
			wTraversingState = this.traverseSubNodes(aTraverser);
		}
		if (wTraversingState == false) {
			CvgLeftListLine.prototype.traverseChilds.call(this, aTraverser);
		}
		return wTraversingState;
	},
	traverseNodes: function(aTraverser, aWithSubNodes) {

		var wTraversingState = false;
		var wLeftListNode;
		var wMax = this.subLeftListNodes.length;
		var wI = 0;
		while (wI < wMax) {
			wLeftListNode = this.subLeftListNodes[wI];
			wTraversingState = aTraverser.doWhenTraverse(wLeftListNode, wI);
			if (wTraversingState != true && aWithSubNodes && wLeftListNode.hasSubNode()) {
				wTraversingState = wLeftListNode.traverseNodes(aTraverser, aWithSubNodes);
			}
			if (wTraversingState == true) {
				return true;
			}
			wI++;
		}
		return wTraversingState;
	},
	traverseSubNodes: function(aTraverser) {
		return this.traverseNodes(aTraverser, false);
	}
});