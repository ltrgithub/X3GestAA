"use strict";
var helpers = require('syracuse-core/lib/helpers');
var util = require('util');
var ufs = require('streamline-fs');
var ubuf = require('buffer');
var datetime = require("syracuse-core/lib/types/datetime");

exports.Recorder = helpers.defineClass(function(_, stream, file, opts, config) {
	var self = this;
	self._file = file;
	self._config = config;
	self._nbLines = 0;
	self._stream = stream;
	self._startRecord(_, opts);
}, null, {
	close: function() {
		this._stopRecord();
		this._stream = null;
	},
	_startRecord: function(_, opts) {
		var self = this;
		if (!self._stream) return;
		var stream = self._stream;
		self._saveRead = self._stream.read;
		stream.read = function(_, len) {
			var data = self._saveRead.call(stream, _, len);
			if (data) self.dumpBytes(_, "READ", data);

			return data;
		};
		self._saveWrite = stream.write;
		stream.write = function(_, data) {
			if (data) self.dumpBytes(_, "WRITE", data);
			self._saveWrite.call(stream, _, data);
		};
		// !! First line - Contains information about record context displayed in cvgRecord entity
		self._dumpLine(_, {
			type: "RECINFO",
			data: opts
		});
		self.dumpComment(_, "Date : " + datetime.now().toString());
	},
	_stopRecord: function() {
		var self = this;
		// Remove dump handlers on stream object
		// close is needed for reused clients
		try {
			if (!self._stream) return;
			if (self._saveRead) {
				self._stream.read = self._saveRead;
				self._saveRead = null;
			}
			if (self._saveWrite) {
				self._stream.write = self._saveWrite;
				self._saveWrite = null;
			}
		} catch (e) {
			console.log("recorder.close error - " + (e.message ? e.message : e));
		};
	},
	dumpBytes: function(_, action, data) {
		var line = {
			type: action,
			data: data.toString('hex') //Serialized as hexa string	to be instantiated as a buffer in the player			
		};
		this._dumpLine(_, line);
	},
	dumpComment: function(_, txt) {
		var line = {
			type: "COMMENT",
			data: txt
		};
		this._dumpLine(_, line);
	},
	dumpNode: function(_, name, args) {
		var line = {
			type: "NODE",
			data: {
				id: name,
				args: args
			}
		};
		this._dumpLine(_, line);
	},
	dumpAction: function(_, act, superAct) {
		var line = {
			type: "ACT",
			data: {
				id: act,
				superAct: superAct === true
			}
		};
		this._dumpLine(_, line);
	},
	dumpHttpReq: function(_, context, body) {
		var line = {
			type: "HTTPREQ",
			data: {
				url: context.url,
				query: context.query ? JSON.stringify(context.query) : {},
				method: context.method,
				data: body ? body : (context.request.readAll(_) || ""),
				headers: context.request.headers ? JSON.stringify(context.request.headers) : {}
			}
		};
		this._dumpLine(_, line);
	},
	dumpHttpResp: function(_, string) {
		var line = {
			type: "HTTPRESP",
			data: string || ""
		};
		this._dumpLine(_, line);
	},
	dumpWinDescr: function(_, string) {
		var line = {
			type: "WINDESCR",
			data: string || ""
		};
		this._dumpLine(_, line);
	},
	_dumpLine: function(_, line) {
		var record = this._nbLines > 0 ? ",\n" : "";
		record += JSON.stringify(line);
		ufs.appendFile(this._file, record, 'utf8', _);
		this._nbLines++;
	},
	_log: function(txt) {
		if (this._config.trace) this._config.trace(txt);
	},
	logerr: function(e, txt) {
		this._log(txt);
		this._log(e.stack ? e.stack : e.message ? e.message : e);
	}
});