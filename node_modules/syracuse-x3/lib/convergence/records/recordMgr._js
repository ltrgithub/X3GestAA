"use strict";
var util = require('util');
var udatetime = require("syracuse-core/lib/types/datetime");
var ufs =require('fs');
var upath =require('path');
var x3helpers = require('syracuse-x3/lib/helpers');


var _config=x3helpers.config("x3fusion.records", null, {});
var _tracer=_config.trace;


// We need to use a callBack
function exists(callback, path) {
	ufs.exists(path, function(result) {
		return callback(null, result);
	});
}

function logerr(e, txt) {
	_tracer(txt);	
	_tracer(e.stack ? e.stack : e.message ? e.message : e);
}

var _mgr = exports.recordMgr = new function() {
	 var _self = this;	 
	 // Asynchronous initialization step - set working directory
	 function _init(_){
			_self._dataDir = upath.join(__dirname, "/../../../../.././../data");
			_self._dumpDir = null;
			_self._currentPlayer = null;
			try{
				if(exists(_, _self._dataDir)){
					_self._dumpDir =  _self._dataDir + upath.sep + "cvgDump";
					if(!exists(_, _self._dumpDir)) ufs.mkdir(_self._dumpDir,"0777",_);
					_tracer("recordMgr _init OK - path :" + _self._dumpDir);						
				}else{
					throw "recordMgr data directory not found\n" + _self._dataDir;
				}
			} catch(e) {
				logerr(e, "recordMgr._init - ERROR - Recorder/Player are disabled");	
				throw e;
			}
	 }
	 // Future on initialization step - Must be called with a callBack before any process that uses _dataDir/_dumpDir
	 // -> in order to make sure that process can start once asynchronous init step completes
	 var _initFuture = _init(null);
	 // Start asynchronous init process
	 // -> execute code until first '_'
	 _initFuture(null);
	
	this._createFile = function(_, opts){
		var opts= opts || {};
		var fileName =opts.fileName;
		try{
			var path = this._getFullPath(fileName);
			if (exists(_, path)){
				if(fileName==null || opts.overwrite){
					ufs.unlink(path, _);
				}else{
					var r=new RegExp(fileName + "_([\\d]+).js"), max=-1;
					var files = _self._getFileNames(_, function(file){
						var name=upath.basename(file)
						if (name==fileName) return true;
						var num=-1;
						name.replace(r, function (p1,p2){num=p2});
						if (!isNaN(num) && num>=0){
							 max=Math.max(max,num);
							 return true;
						}
						return false;
					})
					path = this._getFullPath(fileName + "_" + (max+1)) ;
				}
			}
			ufs.appendFile(path, '"use strict";\n', 'utf8', _);
			_tracer("recordMgr._createFile :" + path);
			return path;
		}catch(e){
			logerr(e, "recordMgr._createFile - ERROR  - File '" + fileName + ".js'");
			fileName =null;
		}
	}
	
	this._getFullPath = function(fileName){
		if (!fileName)  fileName = ("record_" + new Date().toISOString()).replace(/[^\dA-Za-z]/g,'-');
		if (fileName.indexOf('.') == -1) fileName = fileName + ".js";
		return this._dumpDir + upath.sep + fileName;
	}
	
	this._getFileNames = function(_, filter){
		if (!_self._dumpDir!=null){
			try{
				var files = ufs.readdir(_self._dumpDir, _);
				if (filter) files=files.filter(filter);
				return files;
			}catch(e){
				throw "Error reading record directory\n" + _self._dumpDir + "\n" + e.message;
			}	
		}
		return [];
	}
	// create a recorder
	this.newStreamRec = function(_, stream, opts){
		try{
			_initFuture(_);
			_tracer("recordMgr - new streamRecorder");	
			var klass=require('./streamRecorder').streamRecorder;
			return new klass(_, stream, _self._createFile (_, opts), _config);
		}catch(e){
			logerr(e, "recordMgr - ERROR - Can't create streamRecorder");
			throw e;
		}
	}
	
	this.newStreamPlay = function(_, stream){
		try{
			_initFuture(_);
			_tracer("recordMgr - new streamPlayer");			
			if (this._currentPlayer==null) throw "recordPlayer not initialized";
			var klass=require('./streamPlayer').streamPlayer;
			return new klass(_, stream, this._currentPlayer, _config);
		}catch(e){
			logerr(e, "recordMgr - ERROR - Can't create streamPlayer");
			throw e;
		}
	}
	
	// return cvgRecord entity list
	this.cvgRecordsGet=function(_){
		_initFuture(_);		
		var res=[];
		_self._getFileNames(_).forEach_(_, function(_,fileName){
			try{
				res.push(_self.cvgRecordGet(_, fileName, true));
			}catch(e){
				res.push({fileName: fileName  + " : Error : " + e.message});
			}
		});
		return res;
	}	

	// return cvgRecord entity list
	this.cvgRecordGet=function(_, fileName, fail){
		_initFuture(_);
		try{
			var path=_self._getFullPath(fileName);
			var stats=ufs.stat(path, _);
			return {
				fileName:fileName,
				creationDate:new udatetime.Datetime(stats.ctime),
				lastModifDate:new udatetime.Datetime(stats.mtime)	
			}
		}catch(e){
			if (fail===true) throw e;
			logerr (e, "cvgRecordGet - ERROR");
		}
		return null;
	}

	// Delete filename
	this.cvgRecordDelete = function(_, filename){
		_initFuture(_);
		ufs.unlink(_self._getFullPath(filename),_);
	}
	
	// Play filename record
	this.cvgRecordPlay = function(_, filename, context){
		try{
			_initFuture(_);
			if (_self._currentPlayer) throw new Error("Player is busy\n\t" + _self._currentPlayer + " is running");
			var path=this._getFullPath(filename);
			if (exists(_, path)){
				var _playClass=require('./recordPlayer').recordPlayer;
				_self._currentPlayer = new _playClass(_, path, _config);
				_self._currentPlayer.start(_, context);
			}else{
				throw new Error("Record file not found\n\t" + path);
			}
		}finally{
			_self._currentPlayer=null;
		}
	}
	
}
