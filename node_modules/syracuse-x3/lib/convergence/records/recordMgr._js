"use strict";
var util = require('util');
var udatetime = require("syracuse-core/lib/types/datetime");
var ufs = require('streamline-fs');
var upath = require('path');
var x3helpers = require('syracuse-x3/lib/helpers');
var streams = require("streamline/lib/streams/server/streams");

var _config = x3helpers.config("x3fusion.records", null, {});
var _tracer = _config.trace;
var _players = {};
var _defDataDir = upath.join(process.mainModule.filename.substring(0, process.mainModule.filename.indexOf("index.js")), "node_modules/syracuse-x3/lib/convergence/data");

function formatNum(s) {
	if (s == null) return "";
	s = s.toString();
	if (s.length < 3) return s;
	var x = s.length % 3,
		r = null;;
	if (x > 0) {
		r = s.substr(0, x);
		s = s.substring(x);
	}
	s = s.replace(/\d{3}/g, function(p1, i) {
		return i == 0 ? p1 : " " + p1;
	});
	return r ? r + " " + s : s;
}

// We need to use a callBack

function exists(_, path) {
	return ufs.exists(path, _);
}

function logerr(e, txt) {
	if (_tracer) {
		_tracer(txt);
		_tracer(e.stack ? e.stack : e.message ? e.message : e);
	}
}

function logPlayers(txt) {
	if (_tracer) {
		var r = {};
		for (var p in _players) r[p] = _players[p] ? _players[p].toLog() : "Null player";
		_tracer((txt ? txt + " - " : "") + "_players\n" + JSON.stringify(r, null, 2));
	}
}

function _readJson(_, path) {
	try {
		var json = ufs.readFile(path, 'utf8', _) || "";
		json = json.trim();
		if (json.length == 0) throw new Error("Empty file");
		if (json[json.length - 1] == ',') json = json.substring(0, json.length - 1);
		json = "[" + json + "]";
	} catch (e) {
		throw new Error("Error reading record file [" + path + "]\n" + (e.message ? e.message : e));
	}
	try {
		json = JSON.parse(json);
		return json;
	} catch (e) {
		throw new Error("Error parsing record file [" + path + "]\n" + (e.message ? e.message : e));
	}
}

function _readFileData(_, path, readContent) {
	var stats = ufs.stat(path, _),
		info = null,
		fd = null,
		content = null;
	try {
		// First line should be a RECINFO record which contains record context which will be displayed in cvgRecord entity
		if (readContent) {
			var line = content = ufs.readFile(path, 'utf8', _);
		} else {
			var buffer = new Buffer(1000);
			fd = ufs.open(path, "r", _);
			ufs.read(fd, buffer, 0, Math.min(stats.size, buffer.length), 0, _);
			var line = buffer.toString('utf8');
		}
		var pos = line.search(/([,]\r)|([,]\n)/);
		if (pos == -1) throw new Error("First line not found");
		line = line.substring(0, pos);
		info = JSON.parse(line);
		if (info.type == "RECINFO") return {
			stats: stats,
			info: info.data,
			content: content
		};
		else throw new Error("Unexpected first line - First line doesn't contain record info (type:'RECINFO')");
	} finally {
		if (fd) ufs.close(fd, _);
	}
	return null;
}

var _mgr = exports.recordMgr = new function() {
		var _self = this;
		var conf = _config;
		// Asynchronous initialization step - set working directory

		function _init(_) {
			try {
				_self._dataDir = conf.dumpPath && conf.dumpPath.trim().length > 0 ? conf.dumpPath : _defDataDir;
				_self._dataDir = _self._dataDir.replace("__USERNAME__", (process.env.USER || process.env.USERNAME || ""));
				_self._dumpDir = null;
				if (_self._dataDir.trim().length == 0) throw new Error("No x3fusion.records.dumpPath property in local config");
				if (!exists(_, _self._dataDir)) {
					// create directory where dump will be 
					ufs.mkdir(_self._dataDir, "0777", _);
				}
				_self._dumpDir = _self._dataDir + upath.sep + "cvgRecords";
				if (!exists(_, _self._dumpDir)) {
					_tracer && _tracer("recordMgr - Create dump directory\n\t" + _self._dumpDir);
					ufs.mkdir(_self._dumpDir, "0777", _);
				}
				_tracer && _tracer("recordMgr _init OK - path :" + _self._dumpDir);
			} catch (e) {
				logerr(e, "recordMgr._init - ERROR - Recorder/Player are disabled");
				throw e;
			}
		}
		// Future on initialization step - _init must be called with a _ before any process that uses _dataDir/_dumpDir
		// -> in order to make sure that process can start once asynchronous init step completes
		//var _init = _init(!_);

		this._createFile = function(_, opts) {
			var opts = opts || {};
			var fileName = opts.fileName;
			try {
				var path = this._getFullPath(fileName);
				if (exists(_, path)) {
					if (fileName == null || opts.overwrite) {
						ufs.unlink(path, _);
					} else {
						var r = new RegExp(fileName + "_([\\d]+).json"),
							max = -1;
						var files = _self._getFileNames(_, function(file) {
							var name = upath.basename(file);
							if (name == fileName) return true;
							var num = -1;
							name.replace(r, function(p1, p2) {
								num = p2;
							});
							if (!isNaN(num) && num >= 0) {
								max = Math.max(max, num);
								return true;
							}
							return false;
						});
						path = this._getFullPath(fileName + "_" + (max + 1));
					}
				}
				ufs.appendFile(path, '', 'utf8', _);
				_tracer && _tracer("recordMgr._createFile :" + path);
				return path;
			} catch (e) {
				logerr(e, "recordMgr._createFile - ERROR  - File '" + fileName + ".json'");
				fileName = null;
			}
		};

		this._getFullPath = function(fileName) {
			if (!fileName) fileName = ("record_" + new Date().toISOString()).replace(/[^\dA-Za-z]/g, '-');
			if (fileName.indexOf('.') == -1) fileName = fileName + ".json";
			return this._dumpDir + upath.sep + fileName;
		};

		this._getFileNames = function(_, filter) {
			if (!_self._dumpDir != null) {
				try {
					var files = ufs.readdir(_self._dumpDir, _);
					if (filter) files = files.filter(filter);
					return files;
				} catch (e) {
					throw new Error("Error reading record directory\n" + _self._dumpDir + "\n" + e.message);
				}
			}
			return [];
		};
		// create a recorder
		this.newRecorder = function(_, stream, opts, cliCfg, config) {
			try {
				conf = config ? config : _config;
				_init(_);
				// Record client _self.config in order to restore them in player
				opts.cliCfg = {};
				["x3User", "x3Host", "x3Port", "x3Lang", "x3HttpPub", "x3Solution", "x3Folder", "SDate", "IDate", "SThousand", "SDecimal"].forEach(function(p) {
					opts.cliCfg[p] = cliCfg[p];
				});
				_tracer && _tracer("recordMgr - new recorder");
				var klass = require('syracuse-x3/lib/convergence/records/recorder').Recorder;
				return new klass(_, stream, _self._createFile(_, opts), opts, conf);
			} catch (e) {
				logerr(e, "recordMgr - ERROR - Can't create recorder");
				throw e;
			}
		};

		this.getPlayer = function(fileName, config) {
			try {
				var player = _players[fileName];
				if (!player) throw new Error("No player found - File [" + fileName + "]");
				return player;
			} catch (e) {
				logerr(e, "recordMgr - ERROR - Can't retreive player");
				throw e;
			}
		};

		this._existPlayer = function(fileName) {
			return _players[fileName] != null;
		};

		// return cvgRecord entity list
		this.cvgRecordsGet = function(_, config) {
			conf = config ? config : _config;
			_init(_);
			var res = [];
			_self._getFileNames(_, function(file) {
				return upath.extname(file) == '.json';
			}).forEach_(_, function(_, fileName) {
				var r = _self.cvgRecordGet(_, fileName, false);
				if (r) res.push(r);
			});
			return res;
		};

		// return cvgRecord entity list
		this.cvgRecordGet = function(_, fileName, readContent, config) {
			conf = config ? config : _config;
			_init(_);
			try {
				var path = this._getFullPath(fileName);
				var data = _readFileData(_, path, readContent);
				// New version stores cliCfg in a dedicated object
				var cliCfg = data.info.cliCfg ? data.info.cliCfg : data.info;
				// res properties names are the same as cvgRecord entity
				return {
					fileName: upath.basename(path, ".json"),
					creationDate: new udatetime.Datetime(data.stats.ctime),
					lastModifDate: new udatetime.Datetime(data.stats.mtime),
					size: formatNum(data.stats.size),
					x3func: data.info.x3Func || "",
					x3host: cliCfg.x3Host || "",
					x3port: cliCfg.x3Port != null ? cliCfg.x3Port.toString() : "",
					x3solution: cliCfg.x3Solution || "",
					x3folder: cliCfg.x3Folder || "",
					x3user: cliCfg.x3User || "",
					x3lang: cliCfg.x3Lang || "",
					content: data.content ? "<pre style='font-size:10px'>" + data.content + "</pre>" : ""
				};
			} catch (e) {
				_tracer && _tracer("recordMgr.cvgRecordGet ERROR - File : " + upath.basename(path) + " - " + (e.message ? e.message : e));
			}
			return null;
		};

		// Delete filename
		this.cvgRecordDelete = function(_, filename, config) {
			conf = config ? config : _config;
			_init(_);
			ufs.unlink(_self._getFullPath(filename), _);
		};

		// Play filename record
		this.cvgRecordPlay = function(_, filename, context, config) {
			conf = config ? config : _config;
			try {
				console.log("conf " + JSON.stringify(conf, null, 2));
				_init(_);
				if (_self._existPlayer(filename)) throw new Error("Player is busy\n\t" + filename + " is running");
				var path = this._getFullPath(filename);
				if (exists(_, path)) {
					var klass = require('./player').Player;
					var player = new klass(_, path, _readJson(_, path), context);
					_players[filename] = player;
					player.start(_, context);
				} else {
					throw new Error("Record file not found\n\t" + path);
				}
			} finally {
				_players[filename] = null;
			}
		};

	};