"use strict";
var util = require('util');
var udatetime = require("syracuse-core/lib/types/datetime");
var ufs =require('fs');
var upath =require('path');
var x3helpers = require('syracuse-x3/lib/helpers');
var streams = require("streamline/lib/streams/server/streams");

var _config=x3helpers.config("x3fusion.records", null, {});
var _tracer=_config.trace;
var _players={}
var _defDataDir= upath.join( process.cwd(),"node_modules/syracuse-x3/lib/convergence/data");

function formatNum(s){
	if (s == null) return "";
    s=s.toString();
    if (s.length<3) return s;
    var x = s.length % 3, r = null;;
    if (x>0){
        r = s.substr(0,x);
        s = s.substring(x);
    }
    s = s.replace(/\d{3}/g,function(p1,i){
        return  i==0? p1 : " " + p1;
    });
    return r ? r + " " + s :  s;
}

// We need to use a callBack
function exists(callback, path) {
	ufs.exists(path, function(result) {
		return callback(null, result);
	});
}

function logerr(e, txt) {
	if (_tracer){
		_tracer(txt);	
		_tracer(e.stack ? e.stack : e.message ? e.message : e);
	}
}

function logPlayers(txt){
	if (_tracer){
		var r={};
		for (var p in _players) r[p] = _players[p] ? _players[p].toLog() : "Null player";
		_tracer( (txt ? txt + " - " : "") + "_players\n" + JSON.stringify(r, null, 2))
	}
}
function readRecFile(_, path){
	try {
		var json = ufs.readFile(path, 'utf8', _) || "";
		json = json.trim();
		if (json.length == 0) throw "Empty file"
		if (json[json.length-1] == ',') json =  json.substring(0, json.length-1);
		json = "[" + json + "]";
	}catch(e){
		throw "Error reading record file [" + path + "]\n" + (e.message ? e.message : e)
	}
	try {
		json = JSON.parse(json);
		return json;
	}catch(e){
		throw "Error parsing record file [" + path + "]\n" + (e.message ? e.message : e)
	}
	return null;
}

var _mgr = exports.recordMgr = new function() {
	 var _self = this;	 
	 // Asynchronous initialization step - set working directory
	 function _init(_){
			try{			
				_self._dataDir = _config.dumpPath && _config.dumpPath.trim().length>0  ? _config.dumpPath : _defDataDir;
				_self._dumpDir = null;
				if (_self._dataDir.trim().length==0) throw "No x3fusion.records.dumpPath property in local config"
				if(!exists(_, _self._dataDir)){
					// create directory where dump will be 
					ufs.mkdir(_self._dataDir, "0777" , _)
				}
				_self._dumpDir =  _self._dataDir + upath.sep + "cvgRecords";
				if(!exists(_, _self._dumpDir)) {
					_tracer && _tracer("recordMgr - Create dump directory\n\t" + _self._dumpDir);
					ufs.mkdir(_self._dumpDir,"0777",_);
				}
				_tracer && _tracer("recordMgr _init OK - path :" + _self._dumpDir);						
			} catch(e) {
				logerr(e, "recordMgr._init - ERROR - Recorder/Player are disabled");	
				throw e;
			}
	 }
	 // Future on initialization step - _initFuture must be called with a _ before any process that uses _dataDir/_dumpDir
	 // -> in order to make sure that process can start once asynchronous init step completes
	 var _initFuture = _init(null);
	
	this._createFile = function(_, opts){
		var opts= opts || {};
		var fileName =opts.fileName;
		try{
			var path = this._getFullPath(fileName);
			if (exists(_, path)){
				if(fileName==null || opts.overwrite){
					ufs.unlink(path, _);
				}else{
					var r=new RegExp(fileName + "_([\\d]+).js"), max=-1;
					var files = _self._getFileNames(_, function(file){
						var name=upath.basename(file)
						if (name==fileName) return true;
						var num=-1;
						name.replace(r, function (p1,p2){num=p2});
						if (!isNaN(num) && num>=0){
							 max=Math.max(max,num);
							 return true;
						}
						return false;
					})
					path = this._getFullPath(fileName + "_" + (max+1)) ;
				}
			}
			ufs.appendFile(path, '', 'utf8', _);
			_tracer && _tracer("recordMgr._createFile :" + path);
			return path;
		}catch(e){
			logerr(e, "recordMgr._createFile - ERROR  - File '" + fileName + ".js'");
			fileName =null;
		}
	}
	
	this._getFullPath = function(fileName){
		if (!fileName)  fileName = ("record_" + new Date().toISOString()).replace(/[^\dA-Za-z]/g,'-');
		if (fileName.indexOf('.') == -1) fileName = fileName + ".js";
		return this._dumpDir + upath.sep + fileName;
	}
	
	this._getFileNames = function(_, filter){
		if (!_self._dumpDir!=null){
			try{
				var files = ufs.readdir(_self._dumpDir, _);
				if (filter) files=files.filter(filter);
				return files;
			}catch(e){
				throw "Error reading record directory\n" + _self._dumpDir + "\n" + e.message;
			}	
		}
		return [];
	}
	// create a recorder
	this.newRecorder = function(_, stream, opts){
		try{
			_initFuture(_);
			_tracer && _tracer("recordMgr - new recorder");	
			var klass=require('syracuse-x3/lib/convergence/records/recorder').recorder;
			return new klass(_, stream, _self._createFile (_, opts), opts, _config);
		}catch(e){
			logerr(e, "recordMgr - ERROR - Can't create recorder");
			throw e;
		}
	}
	
	this.getPlayer = function(fileName, fail){
		try{	
			var player = _players[fileName];
			if (!player && fail === true) throw "No player found - File [" + fileName + "]";
			return player;
		}catch(e){
			logerr(e, "recordMgr - ERROR - Can't retreive player");
			throw e;
		}
	}
	
	// return cvgRecord entity list
	this.cvgRecordsGet=function(_){
		_initFuture(_);		
		var res=[];
		_self._getFileNames(_, function(file){
			return upath.extname(file) == '.js';
		}).forEach_(_, function(_,fileName){
			var r = _self.cvgRecordGet(_, fileName, false);
			if (r) res.push(r);
		});
		return res;
	}	

	// return cvgRecord entity list
	this.cvgRecordGet=function(_, fileName, readContent){
		_initFuture(_);
		try{
			var path=_self._getFullPath(fileName);
			var stats=ufs.stat(path, _), info= null, fd = null, content = "";
			try {
				// First line should be a RECINFO record which contains record context which will be displayed in cvgRecord entity
				if (readContent){
					var line = content = ufs.readFile(path, 'utf8',_);
				}else{
					var buffer =  new Buffer(1000);	    
					fd = ufs.open(path, "r", _);
					ufs.read(fd, buffer, 0, Math.min(stats.size, buffer.length), 0, _);
					var line = buffer.toString('utf8');
				}
				line = line.substring(0, line.indexOf(',\n'));
				info = JSON.parse(line);
				if (info.type == "RECINFO") info =  info.data; else throw "Unexpected first line - First line doesn't contain record info (type:'RECINFO'";
			}finally{
				if (fd) ufs.close(fd, _);
			}
			// res properties names are the same as cvgRecord entity
			return  {
				fileName:upath.basename(path),
				creationDate:new udatetime.Datetime(stats.ctime),
				lastModifDate:new udatetime.Datetime(stats.mtime),
				size:formatNum(stats.size),
				x3func : info.x3Func || "",
				x3host : info.x3Host || "",
				x3port : info.x3Port != null ? info.x3Port.toString() : "",
				x3solution : info.x3Solution || "",
				x3folder : info.x3Folder || "",
				x3user : info.x3User || "",
				x3lang : info.x3Lang || "",
				content : "<pre style='font-size:10px'>" + content + "</pre>"
			};
		}catch(e){
			_tracer && _tracer("recordMgr.cvgRecordGet ERROR - File : " + upath.basename(path) + " - " + (e.message ? e.message : e));
		}
		return null;
	}

	// Delete filename
	this.cvgRecordDelete = function(_, filename){
		_initFuture(_);
		ufs.unlink(_self._getFullPath(filename),_);
	}
	
	// Play filename record
	this.cvgRecordPlay = function(_, filename, context){
		try{
			_initFuture(_);
			if (_self.getPlayer(filename)) throw new Error("Player is busy\n\t" + filename + " is running");
			var path=this._getFullPath(filename);
			if (exists(_, path)){
				var klass=require('./player').player;
				var player = new klass(_, path, readRecFile(_, path), _config);
				_players[filename]=player;
				player.start(_, context);
			}else{
				throw new Error("Record file not found\n\t" + path);
			}
		}finally{
			_players[filename]=null;
		}
	}
	
}
