"use strict";
var util = require('util');
var udatetime = require("syracuse-core/lib/types/datetime");
var ufs =require('fs');
var upath =require('path');
var x3helpers = require('syracuse-x3/lib/helpers');

var _config=x3helpers.config("x3fusion.records", null, {});
var _tracer=_config.trace;
var _players={}
var _defDataDir= upath.join( process.cwd(),"node_modules/syracuse-x3/lib/convergence/data");

// We need to use a callBack
function exists(callback, path) {
	ufs.exists(path, function(result) {
		return callback(null, result);
	});
}

function logerr(e, txt) {
	if (_tracer){
		_tracer(txt);	
		_tracer(e.stack ? e.stack : e.message ? e.message : e);
	}
}

var _mgr = exports.recordMgr = new function() {
	 var _self = this;	 
	 // Asynchronous initialization step - set working directory
	 function _init(_){
			try{			
				_self._dataDir = _config.dumpPath && _config.dumpPath.trim().length>0  ? _config.dumpPath : _defDataDir;
				_self._dumpDir = null;
				if (_self._dataDir.trim().length==0) throw "No x3fusion.records.dumpPath property in local config"
				if(!exists(_, _self._dataDir)){
					// create directory where dump will be 
					ufs.mkdir(_self._dataDir, "0777" , _)
				}
				_self._dumpDir =  _self._dataDir + upath.sep + "cvgRecords";
				if(!exists(_, _self._dumpDir)) {
					_tracer && _tracer("recordMgr - Create dump directory\n\t" + _self._dumpDir);
					ufs.mkdir(_self._dumpDir,"0777",_);
				}
				_tracer && _tracer("recordMgr _init OK - path :" + _self._dumpDir);						
			} catch(e) {
				logerr(e, "recordMgr._init - ERROR - Recorder/Player are disabled");	
				throw e;
			}
	 }
	 // Future on initialization step - Must be called with a callBack before any process that uses _dataDir/_dumpDir
	 // -> in order to make sure that process can start once asynchronous init step completes
	 var _initFuture = _init(null);
	 // Start asynchronous init process
	 // -> execute code until first '_'
	 _initFuture(null);
	
	this._createFile = function(_, opts){
		var opts= opts || {};
		var fileName =opts.fileName;
		try{
			var path = this._getFullPath(fileName);
			if (exists(_, path)){
				if(fileName==null || opts.overwrite){
					ufs.unlink(path, _);
				}else{
					var r=new RegExp(fileName + "_([\\d]+).js"), max=-1;
					var files = _self._getFileNames(_, function(file){
						var name=upath.basename(file)
						if (name==fileName) return true;
						var num=-1;
						name.replace(r, function (p1,p2){num=p2});
						if (!isNaN(num) && num>=0){
							 max=Math.max(max,num);
							 return true;
						}
						return false;
					})
					path = this._getFullPath(fileName + "_" + (max+1)) ;
				}
			}
			ufs.appendFile(path, '', 'utf8', _);
			_tracer && _tracer("recordMgr._createFile :" + path);
			return path;
		}catch(e){
			logerr(e, "recordMgr._createFile - ERROR  - File '" + fileName + ".js'");
			fileName =null;
		}
	}
	
	this._getFullPath = function(fileName){
		if (!fileName)  fileName = ("record_" + new Date().toISOString()).replace(/[^\dA-Za-z]/g,'-');
		if (fileName.indexOf('.') == -1) fileName = fileName + ".js";
		return this._dumpDir + upath.sep + fileName;
	}
	
	this._getFileNames = function(_, filter){
		if (!_self._dumpDir!=null){
			try{
				var files = ufs.readdir(_self._dumpDir, _);
				if (filter) files=files.filter(filter);
				return files;
			}catch(e){
				throw "Error reading record directory\n" + _self._dumpDir + "\n" + e.message;
			}	
		}
		return [];
	}
	// create a recorder
	this.newRecorder = function(_, stream, opts){
		try{
			_initFuture(_);
			_tracer && _tracer("recordMgr - new recorder");	
			var klass=require('syracuse-x3/lib/convergence/records/recorder').recorder;
			return new klass(_, stream, _self._createFile (_, opts), opts, _config);
		}catch(e){
			logerr(e, "recordMgr - ERROR - Can't create recorder");
			throw e;
		}
	}
	
	this.getPlayer = function(file, fail){
		try{	
			var player = _players[file];
			if (!player && fail === true) throw "No player found - File [" + file + "]";
			return player;
		}catch(e){
			logerr(e, "recordMgr - ERROR - Can't retreive player");
			throw e;
		}
	}
	
	// return cvgRecord entity list
	this.cvgRecordsGet=function(_){
		_initFuture(_);		
		var res=[];
		_self._getFileNames(_, function(file){
			return upath.extname(file) == '.js';
		}).forEach_(_, function(_,fileName){
			try{
				res.push(_self.cvgRecordGet(_, fileName, true));
			}catch(e){
				res.push({fileName: fileName  + " : Error : " + e.message});
			}
		});
		return res;
	}	

	// return cvgRecord entity list
	this.cvgRecordGet=function(_, fileName, fail){
		_initFuture(_);
		try{
			var path=_self._getFullPath(fileName);
			var stats=ufs.stat(path, _);
			return {
				fileName:fileName,
				creationDate:new udatetime.Datetime(stats.ctime),
				lastModifDate:new udatetime.Datetime(stats.mtime)	
			}
		}catch(e){
			if (fail===true) throw e;
			logerr (e, "cvgRecordGet - ERROR");
		}
		return null;
	}

	// Delete filename
	this.cvgRecordDelete = function(_, filename){
		_initFuture(_);
		ufs.unlink(_self._getFullPath(filename),_);
	}
	
	// Play filename record
	this.cvgRecordPlay = function(_, filename, context){
		try{
			_initFuture(_);
			if (_self.getPlayer(filename)) throw new Error("Player is busy\n\t" + filename + " is running");
			var path=this._getFullPath(filename);
			if (exists(_, path)){
				var _playClass=require('./player').player;
				var player = new _playClass(_, path, _config);
				_players[filename]=player;
				player.start(_, context);
			}else{
				throw new Error("Record file not found\n\t" + path);
			}
		}finally{
			_players[filename]=null;
		}
	}
	
}
