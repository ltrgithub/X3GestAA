"use strict";
var helpers = require('syracuse-core/lib/helpers');
var x3helpers = require('syracuse-x3/lib/helpers');
var util = require('util');
var upath = require('path');
var uurl = require('url');
var ufs = require('streamline-fs');
var streams = require("streamline/lib/streams/streams");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var _config = x3helpers.config("x3fusion.records", null, {});

// Util

function byteToStr(b) {
	var res = '';
	var x = b.match(/.{2}/g);
	x.forEach(function(e) {
		res += String.fromCharCode(parseInt(e, 16));
	});
	console.log(res);
	return res;
}

// TODO - deserialize node data on error

function deserializeAction(_, reader) {
	var X3Reader = require('syracuse-x3/lib/convergence/automata/x3Reader').X3Reader;
	var x3Automata = require('syracuse-x3/lib/convergence/automata/x3Automata');
	var actionDescriptors = require('syracuse-x3/lib/convergence/client/CvgAction').Descriptors;
	// decode the action to get how it serialized
	var lengthExtra = reader.nextByte(); // integer
	var extra = null;
	if (lengthExtra != 0) {
		extra = reader.nextBytes(lengthExtra);
	}
	var lengthbuf = reader.nextShort(); // integer
	var action = reader.nextShort() // integer;
	// get serialization of action
	var desc = actionDescriptors[action];
	// depend of action
	var target = null;
	var params = [];
	for (var i = 0; i < desc.params.length; i++) {
		// call read val 
		var letter = desc.params[i];
		if (i === 0 && letter === 'I') {
			target = x3Automata.readVal(_, reader, letter);
		} else if (desc.params[i] != 'x') {
			params.push(x3Automata.readVal(_, reader, letter, true));
		}
	}

	return {
		act: action,
		params: {
			target: target,
			std: params
		}
	};
}

function exists(_, path) {
	return ufs.exists(path, _);
}

function compare(_, a, b, path, errors) {
	var count = 0;
	// ignore difference in srvop
	if (a === b || path === "root.srvop") return count;
	if (a == null || b == null || typeof a !== 'object' || typeof b !== 'object') {
		// ignore difference in toJsonTime
		if (path === "root.toJsonTime" && typeof a === "number" && typeof b === "number") return count;
		var msg = "Compare Json failed - Path : " + path + '\n&nbsp;&nbsp;&nbsp;expected: ' + (b == null ? "null" : JSON.stringify(b).substring(0, 100)) + '\n&nbsp;&nbsp;&nbsp;got: ' + (a == null ? "null" : JSON.stringify(a).substring(0, 100));
		if (errors) errors.push(msg);
		else console.error(msg);
		return count + 1;
	}
	var keys = Object.keys(a);
	keys.forEach_(_, function(_, k) {
		count += compare(_, a[k], b[k], path + "." + k, errors);
	});
	Object.keys(b).forEach_(_, function(_, k) {
		if (a[k] === undefined) {
			var msg = path + "." + k + ': missing ' + JSON.stringify(b[k]).substring(0, 20);
			if (errors) errors.push(msg);
			else console.error(msg);
			count++;
		}
	});
	return count;
}

var _cookieSkip = ["expires", "max-age", "domain", "path", "secure", "httponly"];

function readCookies(_, resp) {
	var head = resp.headers["set-cookie"];
	if (!head || head.length == 0) throw new Error("No cookies received from Syracuse");
	var cookies = [];
	// Normally we should receive an array with 2 cookies elements syracuse.sid and client.id - bug should be fixed
	// Currently receive only one element with 2 cookies in the same string with set-cookie inside the string - We split this elmt in two entries
	for (var i = 0; i < head.length; i++) {
		if (head[i].indexOf("set-cookie:")) {
			var split = head[i].split(/set-cookie:[\s]+/g);
			for (var j = 0; j < split.length; j++) cookies.push(split[j]);
		} else cookies.push(head[i]);
	}
	// Extract cookies names/value to send to server in next requests
	var httpCookie = "";
	cookies.forEach_(_, function(_, x) {
		x = x.trim();
		var y = x.split(";");
		for (var i = 0; i < y.length; i++) {
			var z = y[i],
				p = z.indexOf("="),
				prop = z.substring(0, p++).trim();
			if (_cookieSkip.indexOf(prop.toLowerCase()) == -1) {
				if (httpCookie.length > 0) httpCookie += ";";
				httpCookie += prop + "=" + z.substring(p).trim();
				break;
			}
		}
	});
	return httpCookie;
}

var _regCvgId = /\$sessions\('(.+)'\)/g;

function _readCvgSessId(_, resp) {
	// Read location header that contains convergence session id
	var head = resp.headers["location"];
	if (!head) throw new Error("location header is missing - Can't get convergence session id");
	// console.log("\tLocation" + "\n\t" + head);
	var x = head.split(_regCvgId);
	// console.log(JSON.stringify(x,null,2));
	if (x.length < 2 || x[1].length == 0) throw new Error("Unexpected location header url - Can't read convergence session id\n" + head);
	return x[1];
}

// resp contains request's body  returned by cvgClient
// try to find a message posted by player
// If found returns player's message else returns std message
// Sometimes (connect request) cvgClient returns it's own user message (Connection failed) . Cause error is stored in $diagnose 
var _errPref = "Stream player error";

function findPlayerErr(_, resp) {
	var respBody = resp ? resp.readAll(_) : null;
	if (respBody && respBody.trim().length > 0) {
		try {
			respBody = JSON.parse(respBody);
			if (respBody.message && respBody.message.indexOf(_errPref) >= 0) return respBody.message;
			var diags = respBody["$diagnoses"];
			if (diags) {
				for (var i = 0; i < diags.length; i++) {
					var diag = diags[i];
					if (diag.message && diag.message.indexOf(_errPref) >= 0) return diag.message;
				}
			}
			return respBody.message;
		} catch (e) {}
	}
	return null;
}
var _report = function(fileName) {
	this.fileName = fileName;
	this.x3Func = "";
	this.actCount = 0;
	this.nodeCount = 0;
	this.readBytes = 0;
	this.writeBytes = 0;
	this.times = [];
	this.mainTime = 0;
	this.recInfo = null;
	this.toJSON = function() {
		var msgs = [],
			indent = "&nbsp;&nbsp;&nbsp;&nbsp;";
		// new version stores client config in cliCfg object
		var clicfg = this.recInfo.cliCfg ? this.recInfo.cliCfg : this.recInfo;
		msgs.push("X3 function " + this.x3Func + " - Duration " + this.mainTime + " ms");
		if (this.recInfo) {
			msgs.push("X3 folder : " + clicfg.x3Solution + " / " + clicfg.x3Folder);
			msgs.push("X3 host : " + clicfg.x3Host + " / " + clicfg.x3Port);
			msgs.push("X3 user : " + clicfg.x3User + " / " + clicfg.x3Lang);
		}
		msgs.push(this.actCount + " actions called - " + this.nodeCount + " nodes proccessed");
		msgs.push(this.readBytes + " bytes read - " + this.writeBytes + " bytes write");
		msgs.push("Average times");
		var hash = {};
		for (var i in this.times) {
			var step = this.times[i].step;
			if (!hash[step]) hash[step] = {
				n: 0,
				time: 0
			};
			hash[step].n++;
			hash[step].time += this.times[i].time;
		}
		for (var p in hash) {
			msgs.push(indent + p + " (" + hash[p].n + ") : " + Math.floor(hash[p].time / hash[p].n) + " ms");
		}
		return {
			"$diagnoses": [{
				$severity: "info",
				$message: ("<b>Test succeeded</b> - File name " + fileName + "<br>" + indent + msgs.join("<br>" + indent))
			}]
		};
	};
};
exports.Player = helpers.defineClass(function(_, filePath, json, context) {
	this.filePath = filePath;
	this.fileName = upath.basename(filePath, ".json");
	this._ctxUrl = context && uurl.parse(context.url);
	this._curStep = null;
	this._curStepIdx = 0;
	this._curByteIdx = 0;
	this._httpCookie = null;
	this._bytesInfo = [];
	this._closed = false;
	this._report = new _report(upath.basename(filePath));
	this.x3Func = "";
	this._recInfo = null;
	this._processJson(_, json);
}, null, {
	restoreClientConfig: function(cliCfg) {
		if (this._recInfo && this._recInfo.cliCfg) {
			// New version stores client config - Player restores settings
			for (var p in this._recInfo.cliCfg) {
				cliCfg[p] = this._recInfo.cliCfg[p];
			}
		}
	},
	start: function(_, context) {
		var self = this,
			ex = null,
			x3Act = "",
			respHttp = null,
			connectReq = null;
		self._curStep = null;
		self._curStepIdx = 0;
		try {
			var mainTime = new Date().getTime();
			self._log("START PLAY - " + self.fileName);
			self._steps.forEach_(_, function(_, e) {
				var startTime = new Date().getTime();
				self._log("Start step - " + self._curStepIdx);
				self._curStep = e;
				self._curByteIdx = 0;
				if (e.connect) {
					connectReq = e.httpReq;
					self._report.x3Func = self.x3Func;
					self._log("\tConnect x3 function : " + self.x3Func);
				} else {
					x3Act = e.httpReq.query.act;
					self._log("\tSend x3 action : " + x3Act);
					self._report.actCount++;
				}
				respHttp = self._sendHttpReq(_, e.httpReq);
				self._report.times.push({
					step: e.connect ? "Connect" : "Act" + x3Act,
					time: new Date().getTime() - startTime
				});
				if (respHttp.statusCode < 200 || respHttp.statusCode > 202) {
					// We need to identify http errors returned by cvgClient
					throw new Error("Http Error");
				} else {
					if (!self._httpCookie) {
						// read http cookie - session id
						self._httpCookie = readCookies(_, respHttp);
						self._log("\tRead cookies - " + self._httpCookie);
						// Read location header that contains convergence session id
						self._cvgSessId = _readCvgSessId(_, respHttp);
						self._log("\tRead convergence session id - " + self._cvgSessId);
					}
					try {
						var respBody = respHttp.readAll(_) || "";
						//self._log("ResBody\n" + respBody.toString("utf-8"));
						respBody = JSON.parse(respBody);
					} catch (e) {
						throw new Error("Error reading/parsing response body\n" + (e.message ? e.message : e));
					}
					var recBody = e.httpResp ? e.httpResp.data || "" : "";
					var errors = [];
					var count = compare(_, recBody, respBody, "root", errors);
					self._log("\tCompare response body -> " + (count == 0 ? "Ok" : ("KO - nbDifs=" + count)));
					if (count > 0) {
						self._log("\t" + errors.join("\n\t"));
						throw new Error("Bad response content - " + count + " errors\n" + errors.join("\n"));
					}
					self._log("Stop step - " + self._curStepIdx + " OK");
					self._curStepIdx++;
				}
			});
		} catch (e) {
			self._logerr(e, "PLAYER ERROR" + (self._curStep ? " - reqLine[" + self._curStep.lineNum + "]" : ""));
			ex = e;
		} finally {
			try {
				self._log("STOP PLAYER - " + self.fileName + " - " + (ex == null ? "OK" : "KO"));
				if (ex != null) {
					var errMsg = (ex.message || ex);
					if (errMsg == "Http Error") {
						// cvgClient Error
						errMsg = findPlayerErr(_, respHttp);
						if (errMsg == null) errMsg = "Http Error - StatusCode " + respHttp.statusCode;
					} else {
						errMsg = (ex.message || ex);
					}
					var message = "Error playing X3 function " + self.x3Func + " - file[" + self.fileName + "]";
					if (self._curStep) {
						message += " - request Line[" + self._curStep.lineNum + "]\nError occured in " + (self._curStep.connect ? "connection action" : " action " + x3Act);
					}
					message += "\n" + errMsg;
					// Temporary - Just to display a readable error 
					throw (message.replace(/\\n/g, '<br>'));
				} else {
					self._report.mainTime = new Date().getTime() - mainTime;
					if (context) {
						context.response.writeHead(200, {
							"content-type": "application/json"
						});
						context.response.write(_, JSON.stringify(self._report.toJSON()), "utf-8");
					}
				}
			} finally {
				self._sendHttpCloseReq(_, connectReq);
				self._curStep = null;
			}
		}
	},
	_sendHttpCloseReq: function(_, connectReq) {
		var self = this;
		if (connectReq && self._cvgSessId) {
			try {
				var options = {
					url: connectReq.url + "('" + self._cvgSessId + "')",
					method: "delete",
					headers: {}
				};
				self._log("\tSend Close Reques - Method[" + options.method + "]\n\t" + options.url);
				if (self._httpCookie) options.headers.cookie = self._httpCookie;
				var resp = streams.httpRequest(options).end().response(_);
				self._log("\tClose response code " + resp.statusCode);
			} catch (e) {
				self._logerr(e, "Error sending close request\n\t" + connectReq.url + "('" + self._cvgSessId + "')");
			}
		}
	},
	_sendHttpReq: function(_, req) {
		var self = this;
		self._log("\tPlayer - sendHttpReq - Method:" + req.method);
		// make a request to the web server for entity.xml
		var url = req.url;
		// Replace convergence session id $session url if there is a cvgId
		if (self._cvgSessId) {
			url = url.replace(_regCvgId, function() {
				return "$sessions('" + self._cvgSessId + "')";
			});
			// self._log("\tSet convergence id\t\t" + req.url + "\n\t\t"  + url);
		}
		var query = req.query || {};
		query.recmode = 'PLAY';
		query.recfile = self.fileName;
		var options = {
			url: url + helpers.url.queryStringify(query),
			method: req.method,
			headers: {}
		};
		self._log("\turl - " + options.url);
		var sendHeaders = ["accept", "accept-encoding", "content-type"];
		sendHeaders.forEach(function(h) {
			options.headers[h] = req.headers[h];
		});
		if (self._httpCookie) {
			//self._log("\tcookie found");
			options.headers.cookie = self._httpCookie;
		} else {
			var usr = _config.user;
			if (usr == null || usr.length == 0) throw new Error("No user found in config file");
			self._log("\tNo cookie -> headers.Authorization -> user=" + usr);
			options.headers.Authorization = 'Basic ' + new Buffer(usr + ":" + _config.password).toString('base64');
		}
		var request = streams.httpRequest(options);
		// self._log("\tREQ DATA \n\t" + req.data || "");
		request.write(_, req.data || "", "utf8");
		return request.end().response(_);
	},
	_processJson: function(_, json) {
		var self = this;
		var lineNum = 0;
		try {
			var step = null,
				newEndPoint = null,
				curEndPoint;
			self._steps = [];
			var stopRecording = false;
			json.forEach_(_, function(_, e, i) {
				// Stop if deconnect action
				stopRecording = stopRecording || (e.type == "ACT" && e.data.id == 1075);
				if (stopRecording) return;
				lineNum = i + 1;
				if (e.type == "NODE" || e.type == "ACT") {
					if (e.type == "NODE") self._report.nodeCount++;
					// Used to retreive node name or action id on failure
					self._bytesInfo.push({
						lineNum: lineNum,
						type: e.type,
						data: e.data
					});
				} else if (e.type == "COMMENT") {
					// SKIP						
				} else if (e.type == "RECINFO") {
					// SKIP						
					self._recInfo = self._report.recInfo = e.data;
					var epCrit = e.data.endpoint;
					if (epCrit) {
						// Check endpoint if recorded
						// If endpoint not found try to find a substitution endpoint with same application/contract to generate valid requests
						// Endoint is just used by x3Dispatcher to dipacth request- no impact on palyer result
						curEndPoint = epCrit.dataset;
						var ep = adminHelper.getEndpoint(_, {
							jsonWhere: epCrit
						});
						if (!ep) {
							self._log("Endpoint " + curEndPoint + " not found in database -> Try to find another one");
							delete epCrit.dataset;
							var ep = adminHelper.getEndpoints(_, {
								jsonWhere: epCrit
							});
							if (ep == null || ep.length == 0) {
								throw new Error("Endpoint " + curEndPoint + " not found in database and no '" + epCrit.contract + "/" + epCrit.application + "' endpoint has been found in current database");
							}
							newEndPoint = ep[0].dataset(_);
							self._log("New EndPoint found -> " + newEndPoint);
						} else {
							self._log("Endpoint " + e.data.endpoint.dataset + " found in database");
						}
					}
				} else if (e.type == "HTTPREQ") {
					if (step != null) throw new Error("Unexpected HTTPREQ record");
					step = {
						lineNum: lineNum,
						httpReq: {},
						bytes: [],
						descr: null,
						httpResp: null
					};
					var req = step.httpReq;
					for (var p in e.data) req[p] = p == "query" || p == "headers" ? JSON.parse(e.data[p]) : e.data[p];
					if (req.query) {
						var x3Func = (req.query.f || "").trim();
						step.connect = x3Func.length > 1;
						if (step.connect) {
							self.x3Func = x3Func.split('/')[0];
						}
					}
					var oldUrl = req.url;
					// Change endpoint in url
					if (newEndPoint && newEndPoint != curEndPoint) {
						var r = new RegExp("/" + curEndPoint + "/\\$sessions");
						req.url = req.url.replace(r, "/" + newEndPoint + "/$sessions");
					}
					// Change host/port
					var newUrl = self._ctxUrl.protocol + "//" + self._ctxUrl.hostname;
					if (self._ctxUrl.port != null) newUrl += ':' + self._ctxUrl.port.toString();
					req.url = decodeURIComponent((newUrl + uurl.parse(req.url).pathname));
					if (oldUrl != req.url && step.connect) {
						// Trace url changes
						self._log("Change all urls\n\tOld url -> " + oldUrl + "\n\tNew url -> " + req.url);
					}
				} else {
					if (step == null) {
						step = {
							lineNum: lineNum,
							httpReq: {},
							bytes: [],
							descr: null,
							httpResp: null
						};
					}

					var data = {
						lineNum: lineNum,
						data: e.data
					};
					if (e.type == "HTTPRESP") {
						self._steps.push(step);
						step.httpResp = data;
						step = null;
					} else if (e.type == "WINDESCR") {
						step.descr = data;
					} else if (e.type == "READ" || e.type == "WRITE") {
						data.op = e.type;
						data.data = new Buffer(e.data, 'hex');
						step.bytes.push(data);
					} else {
						throw new Error("Uknown record type '" + e.type + "'");
					}
				}
			});
			if (_config.trace) {
				var jsonFile = upath.dirname(self.filePath) + upath.sep + 'processRecord.json';
				if (exists(_, jsonFile)) ufs.unlink(jsonFile, _);
				ufs.appendFile(jsonFile, JSON.stringify(self._steps, null, 2), _);
			}
		} catch (e) {
			console.log(e.stack);
			throw new Error("Error creating JSON file\n\tRecord file [" + self.fileName + "] - Line[" + lineNum + "]\n\t" + (e.message ? e.message : e) + "\n\tfullPath" + self.filePath);
		}
	},
	_log: function(txt) {
		if (_config.trace) _config.trace(txt);
	},
	_logerr: function(e, txt) {
		this._log(txt);
		this._log(e.stack ? e.stack : e.message ? e.message : e);
	},
	// Called by cvgClient
	write: function(_, buf) {
		var self = this;
		if (self._closed) return;
		var idx = self._curByteIdx;
		// TEST - if (self._curStep.bytes[self._curByteIdx].lineNum==554)  self._throwByteErr (_, "test write error", idx);
		// TEST - if (self._curStepIdx == 4) self._throwByteErr (_, "test write error", idx);
		// self._log("PLAYER -> WRITE BYTES");
		var recBuf = self._nextBuffer(_, "WRITE");
		self._report.writeBytes += buf.length;
		var ok = recBuf.length == buf.length;
		if (ok) {
			var i = 0;
			for (; i < recBuf.length && ok; i++) {
				ok = ok && recBuf[i] == buf[i];
			}
			if (!ok) self._throwByteErr(_, "Bad write sequence - pos[" + i + "]\n\tbuffer : " + buf.toString('hex') + "\n\trecorded : " + recBuf.toString('hex'), idx);
		} else {
			self._throwByteErr(_, "Bad write size", idx);
		}
	},
	// Called by cvgClient
	read: function(_, size) {
		var self = this;
		var idx = self._curByteIdx;
		if (self._closed) self._throwClientErr("can't read bytes - Player is closed", "READ");
		// self._log("PLAYER -> READ BYTES");
		//  TEST - if (self._curStepIdx == 3) self._throwByteErr (_, "test read error", idx);
		var buf = self._nextBuffer(_, "READ");
		self._report.readBytes += size;
		if (buf.length != size) self._throwByteErr(_, "Bad read size - size[" + size + "] - recorded Size[" + buf.length + "]", idx);
		return buf;
	},
	// Called by cvgClient
	end: function() {
		this._log("Player.end - Close");
		this._closed = true;
	},
	// Called by cvgClient
	readDescr: function(_) {
		var self = this;
		// self._log("PLAYER -> READ DESCR");
		var d = self._curStep.descr.data;
		if (d == null) self._throwClientErr("Try to read unexisting window description", "WINDESCR");
		return d;
	},
	_nextBuffer: function(_, op) {
		var self = this;
		var bytes = self._curStep.bytes;
		if (self._curByteIdx >= bytes.length) self._throwByteErr(_, "Unexpected " + op + " operation - End of bytes", self._curByteIdx);
		var e = bytes[self._curByteIdx];
		if (e.op != op) self._throwByteErr(_, "Unexpected " + op + " operation - " + e.op + " operation expected", self._curByteIdx);
		self._curByteIdx++;
		return e.data;
	},
	_throwByteErr: function(_, txt, idx) {
		var self = this;
		var msg = "Bytes sequence do not match";
		var e = self._curStep.bytes[idx];
		var info = null;
		if (e) {
			// Search for node or action that triggered the read/write bytes
			var prevnode = null,
				prevact = null;
			for (var i = 0; i < self._bytesInfo.length; i++) {
				var x = self._bytesInfo[i];
				// Skip previous requests
				if (x.lineNum < self._curStep.lineNum) continue;
				// NODE info is stored before WRITE and after READ in dump file 
				if (x.lineNum > e.lineNum) {
					info = e.op == "READ" ? x : prevnode;
					break;
				}
				if (x.type == "ACT") prevact = x;
				else prevnode = x;
			}
			if (info) info = "\nNode : " + JSON.stringify(info);
			if (prevact) info = (info || "") + "\nAction : " + JSON.stringify(prevact);
		}
		msg += "\n" + txt;
		if (info) msg += info;
		self._log(msg);
		self._throwClientErr(msg, e ? e.op : null, e ? e.lineNum : null);
	},
	// Throws exception for cvgClient - Uses to identify error to build response
	_throwClientErr: function(e, op, lineNum) {
		var pref = _errPref;
		if (op != null) pref += " - operation[" + op + "]";
		if (lineNum != null) pref += " - line[" + lineNum + "]";
		pref += "\n";
		if (typeof e == "string") {
			e = new Error(pref + e);
		} else {
			e.message = pref + e.message;
		}
		throw e;
	},
	toLog: function() {
		var step = this._curStep;
		return {
			step: step ? step.connect ? "Connect" : "Act" + step.httpReq.query.act : "Not running",
			x3Func: this.x3Func
		};
	}
});