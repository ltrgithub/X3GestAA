"use strict";
var helpers = require('syracuse-core/lib/helpers');
var util = require('util');
var upath =require('path');
var uurl =require('url');
var ufs =require('fs');
var X3Reader = require('syracuse-x3/lib/convergence/automata/x3Reader').X3Reader;
var x3Automata = require('syracuse-x3/lib/convergence/automata/x3Automata');
var actionDescriptors = require('syracuse-x3/lib/convergence/client/CvgAction').Descriptors;
var recorder=require('./player').recorder;
var streams = require("streamline/lib/streams/streams");

function exists(callback, path) {
	ufs.exists(path, function(result) {
		return callback(null, result);
	});
}

function deserializeAction(_,reader){
	// decode the action to get how it serialized
	var lengthExtra = reader.nextByte(); // integer
	var extra = null;
	if( lengthExtra != 0 ){
	 	extra= reader.nextBytes(lengthExtra);
	}
	var lengthbuf = reader.nextShort(); // integer
	var action = reader.nextShort() // integer
	// get serialisation of action
	var desc = actionDescriptors[action]
	// depend of action
	var target = null;
	var params = []
	var isExtend = false;
	for(var i=0;i< desc.params.length;i++){
		// call read val 
		var letter = desc.params[i];
		if( i === 0 && letter === 'I'){
			target = x3Automata.readVal(_,reader,letter);
		}else if( desc.params[i] != 'x'){
			params.push(x3Automata.readVal(_,reader,letter,isExtend));
		}else{
			isExtend = true;
		}
	}
	
	return {
		act : action,
		params :{
			target : target,
			std : params
		}
	}
}

function compare(a, b, path, errors) {
	var count = 0;
	// ignore difference in srvop
	if (a === b || path === "root.srvop") return count;
	if (a == null || b == null || typeof a !== 'object' || typeof b !== 'object') {
		// ignore difference in toJsonTime
		if (path === "root.toJsonTime" && typeof a === "number" && typeof b === "number") return count;
		var msg=path + ': expected ' + JSON.stringify(b) + ', got ' + JSON.stringify(a).substring(0,20);
		if (errors) errors.push(msg);
		else console.error(msg);
		return count + 1;
	}
	var keys = Object.keys(a);
	keys.forEach(function(k) {
		count += compare(a[k], b[k], path + "." + k, errors);
	});
	Object.keys(b).forEach(function(k) {
		if (a[k] === undefined) {
			var msg=path + "." + k + ': missing ' + JSON.stringify(b[k]).substring(0,20);
			if (errors) errors.push(msg);
			else console.error(msg);
			count++;
		}
	});
	return count;
}

exports.player = helpers.defineClass(function(_, filePath, config) {
	this.filePath =filePath;
	this.fileName = upath.basename (filePath);	
	this._config = config;	
	this._curStep=null;
	this._curStepIdx=0;
	this._curByteIdx=0;
	this._processFile(_);
	this._httpCookie=null;
}, null, {
	start:function(_, context){
		var self=this, ex=null;
		try{
			self._log("START PLAY - " + self.fileName);
			self._curStep=null, self._curStepIdx=0;
			self._steps.forEach_(_, function(_, e){
				self._log("\tStart step - " + self._curStepIdx);
				self._curStep = e;
				self._curByteIdx=0;
				var resp = self._sendHttpReq(_, e.httpReq);
				var respBody = resp.readAll(_) || "";
				if( resp.statusCode < 200 || resp.statusCode > 202) {
					throw "Http request error - status[" + resp.statusCode + "]\n" + respBody;
				}
				try{
					//self._log("ResBody\n" + respBody);
					respBody =  JSON.parse(respBody);
				}catch(e){
					throw "Error parsing response body\n" + (e.message ? e.message : e);
				}
				var recBody = e.httpResp || "";
				var errors = [];
				var count = compare(recBody, respBody,"root", errors);
				self._log("\tnb difs=" + count);
				if (count>0){
					self._log("\t" + errors.join("\n\t"));
					throw ("Bad response content - " + count + " errors\n" + errors);
				}
				self._curStepIdx++;
			});
		}catch(e){
			self._logerr(e, "PLAYER ERROR");
			ex=e;
		}finally{
			self._stop(_, ex, context);			
		}
	},
	_stop: function(_, exep, context){
		var self=this;
		this._curStep=null;
		self._log("STOP PLAYER - " + this.fileName + " - " + (exep==null ? "OK" : "KO"));
		if (exep!=null) throw exep;		
	},
	_sendHttpReq:function(_, req){
		var self = this;
		self._log("Player - sendHttpReq - Method:" + req.method);
		// make a request to the web server for entity.xml
		var url=uurl.parse(req.url);
		var host = "localhost";
		if (url.port != null) host += (':' + url.port.toString());
		var myUrl = url.protocol + "//" + host + url.pathname;
		var query = {
				f:req.query.f,
				recmode : 'PLAY'
			};
		myUrl += helpers.url.queryStringify(query);
		self._log("\tmyUrl->" + myUrl);
		var options = {
			url: myUrl,
			method: req.method,
			headers: {}
		}
		if (!self._headers) self._headers = ["accept", "accept-encoding", "content-type"];
		self._headers.forEach(function(h){
			options.headers[h] = req.headers[h];
		});
		if (self._httpCookie){
			self._log("\thas cookie ->" +  self._httpCookie);
			options.headers.cookie = self._httpCookie;
		}else{
			var usr = this._config.user;
			if (usr==null || usr.length==0) throw "No user found in config file";
			self._log("\tNo cookie -> user=" +  usr);
			options.headers.Authorization = 'Basic ' + new Buffer(usr + ":" + this._config.password).toString('base64') 
		}
		var request = streams.httpRequest(options);
		if (req.data && req.data.length==0) request.write(_, data, "utf8");
		var resp = request.end().response(_);
		self._log("\tResponse code " + resp.statusCode);
		return resp;
	},
	_processFile: function(_){
		var self = this;
		try {
			var json = ufs.readFile(this.filePath, 'utf8', _) || "";
			json = json.trim();
			if (json.length == 0) throw "Empty file"
			if (json[json.length-1] == ',') json =  json.substring(0, json.length-1);
			json = "[" + json + "]";
		}catch(e){
			throw "Error reading record file [" + this.filePath + "]\n" + (e.message ? e.message : e)
		}
		try {
			json = JSON.parse(json);
		}catch(e){
			throw "Error parsing record file [" + this.filePath + "]\n" + (e.message ? e.message : e)
		}
		try {
			var step = null;
			self._steps = [];
			json.forEach_(_, function(_, e, i){
				 if (e.type == "COMMENT"){
						// SKIP						
				}else if (e.type =="HTTPREQ"){
					if (step != null) throw "Unexpected HTTPREQ record";
					step={
						lineNum:i+1,
						httpReq:{},
						bytes:[],
						descr:null,
						httpResp : null						
					};
					for (var p in e.data) step.httpReq[p]= p == "query" || p == "headers" ? JSON.parse(e.data[p]) : e.data[p];					
				}else {
					if (step == null) throw "Unexpected " + e.type + " record";
					if (e.type == "HTTPRESP"){
						self._steps.push(step);
						step.httpResp = e.data;
						step=null;
					}else if (e.type == "WINDESCR"){
						step.descr = e.data;
					}else if (e.type == "READ" || e.type =="WRITE"){
						step.bytes.push({op:e.type,buffer:new Buffer(e.data,'hex')});
					}else {
						throw "Uknown record type '" + e.type + "'";
					}
				}				
			});
			if (true){
				var jsonFile = upath.dirname(self.filePath) + upath.sep + 'processRecord.json';
				if (exists(_, jsonFile)) ufs.unlink(jsonFile,_);
				ufs.appendFile(jsonFile,JSON.stringify(self._steps,null, 2), _);
			}
		}catch(e){
			throw "Error processing record file [" + this.filePath + "]\n" + (e.message ? e.message : e)
		}		
	},
	_log:function(txt){
		if (this._config.trace) this._config.trace(txt);
	},
	_logerr:function(e, txt) {
		this._log(txt);	
		this._log(e.stack ? e.stack : e.message ? e.message : e);
	}, 
	// Interface stream
	write:function(_, buf){
		var self = this;
		// self._log("PLAYER -> WRITE BYTES");
		var recBuf = self._nextBuffer(_,"WRITE");
		var ok= recBuf.length == buf.length;
		if (ok){
			var i=0;
			for (; i<recBuf.length && ok; i++){
				ok = ok && recBuf[i] == buf[i];
			}
			if (!ok){
				var res = deserialize(_,buff);
				self._throwByteErr("Bad write sequence - pos[" + i + "], serialize element "+JSON.strindify(res));
			}
		}else{
			self._throwByteErr("Bad write size, serialize element "+JSON.strindify(res));
		}
	}, 
	read:function (_, size){
		var self = this;
		// self._log("PLAYER -> READ BYTES");
		var buf = self._nextBuffer(_,"READ");
		if (buf.length != size) self._throwByteErr ("Bad read size - size[" + size + "] - recorded Size[" + buf.length + "]");
		return buf;
	},
	readDescr:function (_){
		var self = this;
		// self._log("PLAYER -> READ DESCR");
		var d = self._curStep.descr;
		if (d == null) throw "Try to read unexisting window description";
		return d;
	},
	_nextBuffer: function(_,op){
		var self = this;
		var bytes = self._curStep.bytes;
		if (self._curByteIdx >= bytes.length) self._throwByteErr ("Unexpected " + op + " operation - End of bytes");
		var e = bytes[self._curByteIdx];
		if (e.op != op) self._throwByteErr ("Unexpected " + op + " operation - " + e.op + " opeartion expected");
		self._curByteIdx++;
		return e.buffer;
	},
	_throwByteErr:function(txt){
		var msg = "Bytes sequence do not match - file[" + this.fileName + "] - lineNum[" + this._curStep.lineNum + "]\n";
		msg+=txt;
		this._log(msg);
		throw msg;
	}
});
