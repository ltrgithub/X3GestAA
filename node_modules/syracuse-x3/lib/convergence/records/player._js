"use strict";
var helpers = require('syracuse-core/lib/helpers');
var util = require('util');
var upath =require('path');
var uurl =require('url');
var ufs =require('fs');
var streams = require("streamline/lib/streams/streams");
var syraCfg = require('syracuse-main/lib/nodeconfig').config;

// TODO - deserialize node data on error
function deserializeAction(_,reader){
	var X3Reader = require('syracuse-x3/lib/convergence/automata/x3Reader').X3Reader;
	var x3Automata = require('syracuse-x3/lib/convergence/automata/x3Automata');
	var actionDescriptors = require('syracuse-x3/lib/convergence/client/CvgAction').Descriptors;
	// decode the action to get how it serialized
	var lengthExtra = reader.nextByte(); // integer
	var extra = null;
	if( lengthExtra != 0 ){
	 	extra= reader.nextBytes(lengthExtra);
	}
	var lengthbuf = reader.nextShort(); // integer
	var action = reader.nextShort() // integer
	// get serialisation of action
	var desc = actionDescriptors[action]
	// depend of action
	var target = null;
	var params = []
	for(var i=0;i< desc.params.length;i++){
		// call read val 
		var letter = desc.params[i];
		if( i === 0 && letter === 'I'){
			target = x3Automata.readVal(_,reader,letter);
		}else if( desc.params[i] != 'x'){
			params.push(x3Automata.readVal(_,reader,letter,true));
		}
	}
	
	return {
		act : action,
		params :{
			target : target,
			std : params
		}
	}
}

function exists(callback, path) {
	ufs.exists(path, function(result) {
		return callback(null, result);
	});
}

function compare(_, a, b, path, errors) {
	var count = 0;
	// ignore difference in srvop
	if (a === b || path === "root.srvop") return count;
	if (a == null || b == null || typeof a !== 'object' || typeof b !== 'object') {
		// ignore difference in toJsonTime
		if (path === "root.toJsonTime" && typeof a === "number" && typeof b === "number") return count;
		var msg=path + ': expected ' + JSON.stringify(b) + ', got ' + JSON.stringify(a).substring(0,20);
		if (errors) errors.push(msg);
		else console.error(msg);
		return count + 1;
	}
	var keys = Object.keys(a);
	keys.forEach_(_, function(_, k) {
		count += compare(_, a[k], b[k], path + "." + k, errors);
	});
	Object.keys(b).forEach_(_, function(_, k) {
		if (a[k] === undefined) {
			var msg=path + "." + k + ': missing ' + JSON.stringify(b[k]).substring(0,20);
			if (errors) errors.push(msg);
			else console.error(msg);
			count++;
		}
	});
	return count;
}

var _cookieSkip=["expires","max-age","domain","path","secure","httponly"];
function readCookies (_, resp) {
	var head =  resp.headers["set-cookie"];
	if (!head || head.length==0) throw "No cookies received from Syracuse";
	var cookies=[];
	// Normally we should receive an array with 2 cookies elements syracuse.sid and client.id - bug should be fixed
	// Currently receive only one element with 2 cookies in the same string with set-cookie inside the string - We split this elmt in two entries
	for (var i=0; i<head.length; i++){
		if (head[i].indexOf("set-cookie:")){
			var split = head[i].split(/set-cookie:[\s]+/g);
			for (var j=0; j<split.length; j++) cookies.push(split[j]);
		}else cookies.push(head[i]);
	}
	// Extract cookies names/value to send to server in next requests
	var httpCookie="";
	cookies.forEach_(_, function (_, x){
	    x=x.trim();
	    var y=x.split(";");
	    for (var i= 0;i<y.length; i++){
	    	var z=y[i], p = z.indexOf("="), prop=z.substring(0,p++).trim();
	        if (_cookieSkip.indexOf(prop.toLowerCase()) == -1){
	        	if (httpCookie.length>0) httpCookie += ";"
	        	httpCookie += prop + "=" + z.substring(p).trim();
	        	break;
	        }
	    }
	});
	return httpCookie;
}

var _regCvgId =/\$sessions\('(.+)'\)/g;
function _readCvgSessId(_, resp){
	// Read location header that contains convergence session id
	var head =  resp.headers["location"];
	if (!head) throw "location header is missing - Can't get convergence session id"
	// console.log("\tLocation" + "\n\t" + head);
	var x=head.split(_regCvgId);
	// console.log(JSON.stringify(x,null,2));
	if (x.length<2 || x[1].length==0) throw "Unexpected location header url - Can't read convergence session id\n" + head;
	return x[1];
}

// resp contains request's body  returned by cvgClient
// try to find a message posted by player
// If found returns player's message else returns std message
// Sometimes (connect request) cvgClient returns it's own user message (Connection failed) . Cause error is stored in $diagnose 
var _errPref= "Stream player error";
function findPlayerErr(_, resp){
	var respBody = resp ? resp.readAll(_) : null;
	if (respBody && respBody.trim().length>0){
		try{
			respBody =  JSON.parse(respBody);
			if (respBody.message && respBody.message.indexOf(_errPref)>=0) return respBody.message;
			var diags = respBody["$diagnoses"];
			if (diags){		
				for (var i=0;i<diags.length;i++){
					var diag = diags[i];
					if (diag.message && diag.message.indexOf(_errPref)>=0) return diag.message;
				} 
			}
			return respBody.message;
		}catch(e){}
	}
	return null;
}
exports.player = helpers.defineClass(function(_, filePath, config) {
	this.filePath =filePath;
	this.fileName = upath.basename (filePath);	
	this._config = config;	
	this._curStep=null;
	this._curStepIdx=0;
	this._curByteIdx=0;
	this._httpCookie=null;
	this._bytesInfo=[];
	this._closed= false;
	this._processFile(_);
}, null, {
	start:function(_, context){
		var self=this, ex=null, x3Func="", x3Act = "", respHttp = null;
		self._curStep=null;
		self._curStepIdx=0;
		try{
			self._log("START PLAY - " + self.fileName);
			self._steps.forEach_(_, function(_, e){
				self._log("Start step - " + self._curStepIdx);
				self._curStep = e;
				self._curByteIdx=0;
				if (e.httpReq.connect) {
					x3Func = e.httpReq.query.f.split('/')[0];
					self._log("\tConnect x3 function : " + x3Func);
				}else{
					x3Act = e.httpReq.query.act;
					self._log("\tSend x3 action : " + x3Act);
				}
				respHttp = self._sendHttpReq(_, e.httpReq);
				if( respHttp.statusCode < 200 || respHttp.statusCode > 202) {
					// We need to identify http errors returned by cvgClient
					throw "Http Error";
				}else{
					try{
						var respBody = respHttp.readAll(_) || "";
						//self._log("ResBody\n" + respBody);
						respBody =  JSON.parse(respBody);
					}catch(e){
						throw "Error reading/parsing response body\n" + (e.message ? e.message : e);
					}
					var recBody = e.httpResp ? e.httpResp.data || "" : "";
					var errors = [];
					var count = compare(_,recBody, respBody,"root", errors);
					self._log("\tCompare response body -> " + (count == 0 ? "Ok": ("KO - nbDifs=" +  count)));
					if (count>0){
						self._log("\t" + errors.join("\n\t"));
						throw ("Bad response content - " + count + " errors\n" + errors);
					}
					self._log("Stop step - " + self._curStepIdx + " OK");
					self._curStepIdx++;
				}
			});
		}catch(e){
			self._logerr(e, "PLAYER ERROR" +  (self._curStep ? " - reqLine[" + self._curStep.lineNum + "]" : ""));
			ex=e;
		}finally{
			try{
				self._log("STOP PLAYER - " + this.fileName + " - " + (ex==null ? "OK" : "KO"));
				if (ex!=null){
					var errMsg=null;
					if (ex == "Http Error"){
						// cvgClient Error
						errMsg = findPlayerErr(_, respHttp);
						if (errMsg==null)  errMsg = "Http Error - StatusCode " + respHttp.statusCode;
					}else{
						errMsg = (ex.message || ex);
					}
					var message="Error playing X3 function " + x3Func + " - file[" + this.fileName + "]";
					if (self._curStep) {
						message +=  " - request Line[" + self._curStep.lineNum + "]\nError occured in " + (self._curStep.httpReq.connect ? "connection action" :  " action " + x3Act );
					}
					message +=  "\n" + errMsg;
					// Temporary - Just to display a readable error 
					throw (message.replace(/\\n/g,'<br>'));	
				}
			}finally{
				this._curStep=null;
			}
		}
	},
	_sendHttpReq:function(_, req){
		var self = this;
		self._log("\tPlayer - sendHttpReq - Method:" + req.method);
		// make a request to the web server for entity.xml
		var url=req.url;
		// Replace convergence session id $session url if there is a cvgId
		if (self._cvgSessId){
			url = url.replace(_regCvgId, function(){
				return"$sessions('" + self._cvgSessId + "')"
			});
			// self._log("\tSet convergence id\t\t" + req.url + "\n\t\t"  + url);
		}
		url=uurl.parse(url);
		var host = "localhost", port = syraCfg.port == null ? 8124 :  syraCfg.port;
		host += (':' + port.toString());
		var myUrl = url.protocol + "//" + host + url.pathname;
		var query = req.query || {};
		query.recmode = 'PLAY';
		query.recfile = self.fileName;
		myUrl += helpers.url.queryStringify(query);
		// self._log("\turl - " + myUrl);
		var options = {
			url: myUrl,
			method: req.method,
			headers: {}
		}
		var sendHeaders = ["accept", "accept-encoding", "content-type"];
		sendHeaders.forEach(function(h){
			options.headers[h] = req.headers[h];
		});
		if (self._httpCookie){
			//self._log("\tcookie found");
			options.headers.cookie = self._httpCookie;
		}else{
			var usr = this._config.user;
			if (usr==null || usr.length==0) throw "No user found in config file";
			self._log("\tNo cookie -> headers.Authorization -> user=" +  usr);
			options.headers.Authorization = 'Basic ' + new Buffer(usr + ":" + this._config.password).toString('base64') 
		}
		var request = streams.httpRequest(options);
		// self._log("\tREQ DATA \n\t" + req.data || "");
		request.write(_, req.data || "", "utf8");
		var resp = request.end().response(_);
		//self._log("\tResponse code " + resp.statusCode);
		if (200<=resp.statusCode && resp.statusCode<203 && !self._httpCookie) {
			// read http cookie - session id
			self._httpCookie = readCookies(_, resp);
			self._log("\tRead cookies - " + self._httpCookie);
			// Read location header that contains convergence session id
			self._cvgSessId = _readCvgSessId (_, resp);
			self._log("\tRead convergence session id - " + self._cvgSessId);
		}
		return resp;
	},
	_processFile: function(_){
		var self = this;
		try {
			var json = ufs.readFile(this.filePath, 'utf8', _) || "";
			json = json.trim();
			if (json.length == 0) throw "Empty file"
			if (json[json.length-1] == ',') json =  json.substring(0, json.length-1);
			json = "[" + json + "]";
		}catch(e){
			throw "Error reading record file [" + this.filePath + "]\n" + (e.message ? e.message : e)
		}
		try {
			json = JSON.parse(json);
		}catch(e){
			throw "Error parsing record file [" + this.filePath + "]\n" + (e.message ? e.message : e)
		}
		var lineNum = 0;
		try {
			var step = null;
			self._steps = [];
			var stopRecording = false;
			json.forEach_(_, function(_, e, i){
				// Stop if deconnect action
				stopRecording = stopRecording || (e.type == "ACT" && e.data.id == 1075);
				if (stopRecording) return;
				lineNum = i+1;
				 if (e.type == "NODE" || e.type == "ACT"){
					 // Used to retreive node name or action id on failure
					 self._bytesInfo.push({
						 lineNum:lineNum,
						 type: e.type,
						 data:e.data
					 });					
				}else if (e.type == "COMMENT"){
						// SKIP						
				}else if (e.type =="HTTPREQ"){
					if (step != null) throw "Unexpected HTTPREQ record";
					step={
						lineNum:lineNum,
						httpReq:{},
						bytes:[],
						descr:null,
						httpResp : null						
					};
					var req = step.httpReq;
					for (var p in e.data) req[p]= p == "query" || p == "headers" ? JSON.parse(e.data[p]) : e.data[p];		
					if (req.query){
						var x3Func= (req.query.f || "").trim();
						req.connect = x3Func.length>0;					
					}
				}else {
					if (step == null) throw "Unexpected " + e.type + " record";
					var data={lineNum: lineNum, data: e.data}
					if (e.type == "HTTPRESP"){
						self._steps.push(step);
						step.httpResp =data;
						step=null;
					}else if (e.type == "WINDESCR"){
						step.descr = data;
					}else if (e.type == "READ" || e.type =="WRITE"){
						data.op = e.type;
						data.data = new Buffer(e.data,'hex');						
						step.bytes.push(data);
					}else {
						throw "Uknown record type '" + e.type + "'";
					}
				}				
			});
			if (true){
				var jsonFile = upath.dirname(self.filePath) + upath.sep + 'processRecord.json';
				if (exists(_, jsonFile)) ufs.unlink(jsonFile,_);
				ufs.appendFile(jsonFile,JSON.stringify(self._steps,null, 2), _);
			}
		}catch(e){
			throw "Error processing record file [" + this.fileName + "] - Line[" + lineNum + "]\n" + (e.message ? e.message : e) + "\nfullPath" + this.filePath;
		}		
	},
	_log:function(txt){
		if (this._config.trace) this._config.trace(txt);
	},
	_logerr:function(e, txt) {
		this._log(txt);	
		this._log(e.stack ? e.stack : e.message ? e.message : e);
	}, 
	// Called by cvgClient
	write:function(_, buf){
		var self = this;
		if (self._closed) return;
		var idx=self._curByteIdx;
		// TEST - if (self._curStep.bytes[self._curByteIdx].lineNum==554)  self._throwByteErr (_, "test write error", idx);
	    // TEST - if (self._curStepIdx == 4) self._throwByteErr (_, "test write error", idx);
		// self._log("PLAYER -> WRITE BYTES");
		var recBuf = self._nextBuffer(_,"WRITE");
		var ok= recBuf.length == buf.length;
		if (ok){
			var i=0;
			for (; i<recBuf.length && ok; i++){
				ok = ok && recBuf[i] == buf[i];
			}
			if (!ok) self._throwByteErr(_,"Bad write sequence - pos[" + i + "]\n\tbuffer : " + buf.toString('hex') + "\n\trecorded : " + recBuf.toString('hex'), idx);
		}else{
			self._throwByteErr(_,"Bad write size", idx);
		}
	}, 
	// Called by cvgClient
	read:function (_, size){
		var self = this;
		var idx=self._curByteIdx;
		if (self._closed) self._throwClientErr("can't read bytes - Player is closed", "READ");
		// self._log("PLAYER -> READ BYTES");
		//  TEST - if (self._curStepIdx == 3) self._throwByteErr (_, "test read error", idx);
		var buf = self._nextBuffer(_,"READ");
		if (buf.length != size) self._throwByteErr (_,"Bad read size - size[" + size + "] - recorded Size[" + buf.length + "]", idx);
		return buf;
	},
	// Called by cvgClient
	end:function(){
		this._log("Player.end - Close");
		this._closed= true;
	},
	// Called by cvgClient
	readDescr:function (_){
		var self = this;
		// self._log("PLAYER -> READ DESCR");
		var d = self._curStep.descr.data;
		if (d == null) self._throwClientErr("Try to read unexisting window description","WINDESCR");
		return d;
	},
	_nextBuffer: function(_,op){
		var self = this;
		var bytes = self._curStep.bytes;
		if (self._curByteIdx >= bytes.length) self._throwByteErr (_,"Unexpected " + op + " operation - End of bytes", self._curByteIdx);
		var e = bytes[self._curByteIdx];
		if (e.op != op) self._throwByteErr (_,"Unexpected " + op + " operation - " + e.op + " operation expected", self._curByteIdx);
		self._curByteIdx++;
		return e.data;
	},
	_throwByteErr:function(_, txt, idx){
		var self = this;
		var msg = "Bytes sequence do not match";
		var e = self._curStep.bytes[idx];
		var info=null;
		if (e)  {
			// Search for node or action that triggered the read/write bytes
			var prevnode = null, prevact = null;
			for (var i=0;i<self._bytesInfo.length;i++){
				var x = self._bytesInfo[i];
				// Skip previous requests
				if (x.lineNum < self._curStep.lineNum) continue;
				// NODE info is stored before WRITE and after READ in dump file 
				if (x.lineNum > e.lineNum) {
					info = e.op == "READ" ? x : prevnode;
					break;
				}				
				if (x.type=="ACT") prevact = x; else prevnode = x;
			}
			if (info) info = "\nNode : " + JSON.stringify(info);
			if (prevact) info = (info || "" ) + "\nAction : " + JSON.stringify(prevact);
		}
		msg += "\n" + txt;
		if (info) msg += info;
		self._log(msg);
		self._throwClientErr  (msg, e ? e.op : null, e ? e.lineNum : null);
	},
	// Throws exception for cvgClient - Uses to identify error to build response
	_throwClientErr: function(e, op, lineNum){
		var pref= _errPref;
		if (op!=null) pref += " - operation[" + op + "]";
		if (lineNum!=null) pref += " - line[" + lineNum + "]";
		pref += "\n";
		if(typeof e =="string"){
			e =  pref  + e;
		}else{
			e.message = pref + e.message;
		}
		throw e;
	}
});
