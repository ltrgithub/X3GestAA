"use strict";
var helpers = require('syracuse-core/lib/helpers');
var util = require('util');
var upath =require('path');
var ufs =require('fs');
var recorder=require('./player').recorder;
var streams = require("streamline/lib/streams/streams");

function exists(callback, path) {
	ufs.exists(path, function(result) {
		return callback(null, result);
	});
}


exports.player = helpers.defineClass(function(_, filePath, config) {
	this.filePath =filePath;
	this.fileName = upath.basename (filePath);	
	this._config = config;	
	this._curStep=null;
	this._curStepIdx=0;
	this._curByteIdx=0;
	this._processFile(_);
}, null, {
	start:function(_, context){
		var self=this, ex=null;
		try{
			self._log("START PLAY - " + self.fileName);
			self._curStep=null, self._curStepIdx=0;
			self._steps.forEach_(_, function(_, e){
				self._log("\tStart step - " + self._curStepIdx);
				self._curStep = e;
				self._curByteIdx=0;
				var req=e.httpReq;
				self._log("\t\tReq - " + req.url);
				// Send httpreq
				// read httpresp
				// if !200 throw error
				// check if all bytes have been read
				if (false && self._curByteIdx != e.bytes.bytes.length){
					self._throwByteErr("Remaining byte sequence");
				}
				var res=e.httpResp;
				self._curStepIdx++;
			});
		}catch(e){
			self._logerr(e, "PLAYER ERROR");
			ex=e;
		}finally{
			self._stop(_, ex, context);			
		}
	},
	_stop: function(_, exep, context){
		var self=this;
		this._curStep=null;
		try{
			self._log("STOP PLAYER - " + this.fileName + " - " + (exep==null ? "OK" : "KO"));
			if (exep!=null) throw exep;
		}catch(e){
			self._logerr(e, "STOP PLAYER ERROR\n");
		}
	},
	_sendHttpReq:function(_, req){
		// make a request to the web server for entity.xml
		var url=req.ur;
		if (req.query){
			
		}
		var options = {
			url: url,
			method: "GET",
			headers: {
				"accept-charset": "utf-8"
			}
		}
		var request = streams.httpRequest(options);
		return request.end().response(_);
	},
	_processFile: function(_){
		var self = this;
		try {
			var json = ufs.readFile(this.filePath, 'utf8', _) || "";
			json = json.trim();
			if (json.length == 0) throw "Empty file"
			if (json[json.length-1] == ',') json =  json.substring(0, json.length-1);
			json = "[" + json + "]";
		}catch(e){
			throw "Error reading record file [" + this.filePath + "]\n" + (e.message ? e.message : e)
		}
		try {
			json = JSON.parse(json);
		}catch(e){
			throw "Error parsing record file [" + this.filePath + "]\n" + (e.message ? e.message : e)
		}
		try {
			var step = null;
			self._steps = [];
			json.forEach_(_, function(_, e, i){
				 if (e.type == "COMMENT"){
						// SKIP						
				}else if (e.type =="HTTPREQ"){
					if (step != null) throw "Unexpected HTTPREQ record";
					step={
						lineNum:i+1,
						httpReq:{},
						bytes:[],
						descr:null,
						httpResp : null						
					};
					for (var p in e.data) step.httpReq[p]= p == "query" || p == "headers" ? JSON.parse(e.data[p]) : e.data[p];					
				}else {
					if (step == null) throw "Unexpected " + e.type + " record";
					if (e.type == "HTTPRESP"){
						self._steps.push(step);
						step.httpResp = e.data;
						step=null;
					}else if (e.type == "WINDESCR"){
						step.descr = e.data;
					}else if (e.type == "READ" || e.type =="WRITE"){
						step.bytes.push({op:e.type,buffer:new Buffer(e.data,'hex')});
					}else {
						throw "Uknown record type '" + e.type + "'";
					}
				}				
			});
			if (true){
				var jsonFile = upath.dirname(self.filePath) + upath.sep + 'processRecord.json';
				if (exists(_, jsonFile)) ufs.unlink(jsonFile,_);
				ufs.appendFile(jsonFile,JSON.stringify(self._steps,null, 2), _);
			}
		}catch(e){
			throw "Error processing record file [" + this.filePath + "]\n" + (e.message ? e.message : e)
		}		
	},
	_log:function(txt){
		if (this._config.trace) this._config.trace(txt);
	},
	_logerr:function(e, txt) {
		this._log(txt);	
		this._log(e.stack ? e.stack : e.message ? e.message : e);
	}, 
	// Interface stream
	write:function(_, buf){
		var self = this;
		var recBuf = self._nextBuffer(_,"WRITE");
		var ok= recBuf.length == buf.length;
		if (ok){
			var i=0;
			for (; i<recBuf.length && ok; i++){
				ok = ok && recBuf[i] == buf[i];
			}
			if (!ok) self._throwByteErr("Bad write sequence - pos[" + i + "]");
		}else{
			self._throwByteErr("Bad write size");
		}
	}, 
	read:function (_, size){
		var self = this;
		var buf = self._nextBuffer(_,"READ");
		if (buf.length != size) self._throwByteErr ("Bad read size - size[" + size + "] - recorded Size[" + buf.length + "]");
		return buf;
	},
	readDescr:function (_){
		var d = self._curStep.descr;
		if (d == null) throw "Try to read unexisting window description";
		if (d.trim().length == 0) throw "Empty window description";
		return d;
	},
	_nextBuffer: function(_,op){
		var self = this;
		var bytes = self._curStep.bytes.bytes;
		if (self._curByteIdx >= bytes.length) self._throwByteErr ("Unexpected " + op + " operation - End of bytes");
		var e = bytes[self._curByteIdx];
		if (e.type != op) self._throwByteErr ("Unexpected " + op + " operation - " + e.type + " opeartion expected");
		self._curByteIdx++;
		return e.buffer;
	},
	_throwByteErr:function(txt){
		var msg = "Bytes sequence do not match - file[" + this.fileName + "] - lineNum[" + this._curStep.lineNum + "]\n";
		msg+=txt;
		this._log(msg);
		throw msg;
	}
});
