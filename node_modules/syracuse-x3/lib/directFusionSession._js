"use strict";

var locale = require("syracuse-core/lib/locale");
var helpers = require("syracuse-core/lib/helpers");
var streams = require("streamline/lib/streams/streams");
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var x3helpers = require("./helpers");
var dispatcher = require('./proxyFusionDispatcher');
var parseUrl = require('url').parse;
var x3helpers = require("./helpers");
var globals = require('streamline/lib/globals');
var sys = require("util");
var httpHelpers = require("syracuse-sdata/lib/httpHelper");
var check = require("syracuse-license/lib/check");
var x3client = require('syracuse-x3/lib/client');

var protocol = require("syracuse-x3/lib/automata/x3Protocol");
var CAdapiClient = require("syracuse-x3/lib/fusion/client/CAdapiClient").CAdapiClient;


var tracer = null;

function _startProfile() {
	return (new Date()).getTime();
}

function _endProfile(startTime) {
	return (new Date()).getTime() - startTime;
}

function FusionSession(fsid) {
	this.sessionUrl = "";
	this.isXmlSessionFormat = false;
}

function _getRsrc() {
	try {
		var args = [module];
		for (var i in arguments) {
			args.push(arguments[i]);
		}
		return locale.format.apply(locale, args);
	} catch (e) {
		return "Resource not found [" + arguments[0] + "]";
	}
}

function _getErrMsg(_, ex, rsrcId, context) {
	var msg = rsrcId ? _getRsrc(rsrcId) : null;
	if (msg == undefined) msg = "";
	if (ex.message && ex.message.search(/ECONNREFUSED/i) >= 0) {
		msg += "\n" + _getRsrc("bridgeNotAvail");
	}
	var ep = context.endpoint;
	if (ep) {
		var baseUrl = ep.getFusionDataServerBaseUrl(_);
		baseUrl = baseUrl ? parseUrl(baseUrl) : "";
		// BRJOU DISABLE: msg += "\n--------------\n" + _getRsrc("endpointInfo", baseUrl.host, ep.getApplicationServerName(_), ep.getSolutionName(_), ep.getX3FolderName(_));
	}
	return msg;
}

function _fusionErr(_, ex, rsrcId, context) {
	throw new x3helpers.Error(_getErrMsg(_, ex, rsrcId, context), ex, ex.statusCode);
}
var sessionProto = FusionSession.prototype;
//
var SETTINGS = {
	"SDate": "/",
	"STime": ":",
	"SDecimal": ".",
	"SThousand": " ",
	"IDate": "0",

	"BOSEC": "SecEnterprise",
	"BOSERV": "sodged02.sagefr.adinternal.com:6400",
	"BOUSR": "CRYPT:udosdoQfsgrUgr",
	"BOPWD": "CRYPT:udorw3RgrskUksvaxvascc",

	"ADXAppHost": "172.28.16.106",
	"ADXFolder": "SUPERV",
	"ADXPort": "17000",
	"ADXTrtHost": "172.28.16.106",

	"usrProfile": "ADMIN",
	"formater.von": "on",
	"user": "cmi"
};

sessionProto.connect = function(_, context, config) {
	try {
		var client = x3client.create({
			port: 17000,
			address: "172.28.16.106",
		});
		var cid = client.connect(_, {
			fusion: true,
		});
		console.log("CONNECTED: " + cid)
		var sid = client.createSession(_, {
			userName: "DOM",
			adxtyp: 25,
			fusionTech: {
				protocol: "150067",
				wkf: "GESAMK/2//M/"
			},
		});
		console.log("SESSION OK: " + sid);

		this._fusionClient = new CAdapiClient(client.getStream(), {
			isInteractiveSession: true,
			dateFormat: 1,
			datePivot: 2,
			serverDateFormat: "",
			sessionSettings: SETTINGS,
		});
		protocol.process(_, this._fusionClient);
		console.log("*** FINISHED CONNECTION SEQUENCE !!! ***");

		var response = this._fusionClient.getResponse();
		return {
			headers: {
				"content-type": "application/json",
			},
			body: response
		};
	} catch (ex) {
		throw _fusionErr(_, ex, "connectionFailed", context);
	}
}

sessionProto.processRequest = function(_, context) {
	if (context.method !== 'put') throw new Error("bad method: " + context.method);
	var act = context.parameters.act;
	var post = JSON.parse(context.request.readAll(_));
	if (post.act !== context.parameters.act) throw new Error("act mismatch: expected " + context.parameters.act + ", got " + post.act);
	this._fusionClient.beginRequest(_, post);
	protocol.process(_, this._fusionClient);
	console.log("*** FINISHED REQUEST SEQUENCE !!! ***");
	var response = this._fusionClient.getResponse();

	context.response.writeHead(200, {
		"content-type": "application/json",
	});
	context.response.write(_, JSON.stringify(response), 'utf8');
	context.response.end();
}

// something to do to check action
// if standard action branch to CAdapiClient.sendAction (OLD)
// sendAction implemented in superclass CAdonixClient, does a newActiveRequest and calls sendAction on it.
// beautiful sleep(2) in CActionSender to synchronize thread!!!
// then client.writeSegment on segmentToSend
// NEW client branches to writeSegment on 
// writeSegment is in CComClientBase: sends it over the wire and runs the automata.
// I just need to find how payload is converted to segment.
/*
					String paramStr = serviceRequest.getProviderContext().getParamGet(QUERY_ACT);
				int param = CXStringUtils.strToInt(paramStr, -1);
				CAdonixReply x3Reply = null;
				if (param == -1 && param != webPayload.getAction()) {
					// catch action in body if not present in url
					param = webPayload.getAction();
				}
				webResponse.setTechProp(JSON_ACTION, EAction.num2Name(param));
				if (param == EAction.CALL.getNumber()) {
					// get the xml of call
					x3Reply = execCall(webPayload);
				} else if (param == EAction.REPLY.getNumber()) {
					// send xml reply for the execi
					x3Reply = execReply(webPayload);
				} else if (param >= EAction.APPLICATIVE.getNumber()) {
					// execute applicative action
					x3Reply = executeStandardRequest(webPayload);

				} else if (param < EAction.APPLICATIVE.getNumber()) { // super
					// action retrieve the class that manage action and execute
					// it
					// Return last action response
					webResponse = execSuperAction(webRequest, param);
				}

				if (x3Reply != null) {
					CAdapiClient.checkFailed(x3Reply, FusionClientInfo.REQHDL, null);
					webResponse.setTechProp(JSON_X3REPLY, x3Reply);
				}
				// recuperation du reply et du request pour generate un state
				// fusion
				webResponse.setTechNano(JSON_TIMEEXEC, System.nanoTime() - start);
				fusionOutput.setSDataPayload(webResponse);
				// add in response header ADXLangIso
				fusionOutput.dumpInString(CONTENTYPE.JSON, false);
				*/


sessionProto.processFormat = function(_, context) {
	throw new Error('NIY');
}

sessionProto.processMisc = function(_, context) {
	throw new Error('NIY');
}

sessionProto.proxy = function(_, context, config) {
	try {
		console.log(context.segments);
		var svc = context.segments[context.segments.length - 1];
		switch (svc) {
			case 'requestSvc':
				return this.processRequest(_, context);
			case 'formatSvc':
				return this.processFormat(_, context);
			case 'miscSvc':
				return this.processMisc(_, context);
			default:
				throw new Error("invalid fusion service: " + svc);
		}

		/*
		var start = _startProfile();
		var tracer = config && config.tracer;
		var profiler = config && config.profiler;
		//
		var toWalk = context.toWalk();
		var baseUrl = context.endpoint.getFusionDataServerBaseUrl(_) + "/$sessions('" + this.sid + "')" + (toWalk ? "/" + toWalk : "");
		var clientReq = context.request;
		//clientReq.setEncoding("binary");
		//	var params = Object.keys(context.parameters).map(function(key) {return key + "=" + encodeURIComponent(context.parameters[key]); }).join("&");
		var params = context.rawQuery;
		var options = {
			url: baseUrl + (params ? ("?" + params) : ""),
			method: context.method,
			headers: clientReq.headers
		}
		tracer && tracer("FusionSession.proxy url: " + options.url);
		var proxyReq = streams.httpRequest(options);
		var buf;
		while (buf = clientReq.read(_))
		proxyReq.write(_, buf, "utf8");
		var proxyResp = proxyReq.end().response(_);
		var respHeaders = httpHelpers.parseHeaders(proxyResp.headers);
		proxyResp.setEncoding(respHeaders.toNodeCharset());
		var clientResp = context.response;
		var dis = dispatcher.create(context, function(data) {
			// data.headers and data.status have been forwarded by dispatcher only if dispatch is true
			if (!data.headers) data.headers = proxyResp.headers;
			if (!data.status) data.status = proxyResp.statusCode;

			// Add response time in httpheaders (dvlp)
			data.headers["syra-proxy-time"] = _endProfile(start);
			clientResp.writeHead(data.status, data.headers);
			// data.body has been forwarded by dispatcher
			clientResp.write(null, data.body, respHeaders.toNodeCharset());
			clientResp.end();
			profiler && profiler("PROFILE; Transition proxy roundtrip: " + _endProfile(start));
		});

		while (buf = proxyResp.read(_)) {
			dis.write(buf, respHeaders.toNodeCharset());
		}
		dis.forward(_, this.sid);
		*/
	} catch (ex) {
		throw _fusionErr(_, ex, "proxyFailed", context);
	}
}

sessionProto.close = function(_, reuse) {
	function _addReuse(url) {
		if (!reuse) return url;
		if (url.indexOf("?") >= 0) return url + "&reuse=" + reuse;
		else return url + "?reuse=" + reuse;
	}
	try {
		if (!this._baseUrl) return;
		// delete connection and session
		if (this._sessionUrl) {
			var options = {
				url: _addReuse(this._baseUrl + this._sessionUrl),
				method: "DELETE",
				headers: {
					"accept-charset": "utf-8"
				}
			}
			var request = streams.httpRequest(options);
			// response
			var resp = request.end().response(_);
			// check code
			if (resp.statusCode !== 204) {
				tracer && tracer("Delete session " + this.cid + " statusCode: " + resp.statusCode);
				// resp contains JSON error message sent by Java Bridge server
				var respHeaders = httpHelpers.parseHeaders(resp.headers);
				var respData = resp.readAll(_).toString(respHeaders.toNodeCharset());
				if (respHeaders.isJSON()) respData = JSON.parse(respData);
				//resp.setEncoding("binary");
				return {
					body: respData,
					statusCode: resp.statusCode
				}
			}
			tracer && tracer("Session " + this.sid + " deleted" + (reuse ? " with reuse" : ""));
		}
		if (this._connectionUrl) {
			var options = {
				url: _addReuse(this._baseUrl + this._connectionUrl),
				method: "DELETE",
				headers: {
					"accept-charset": "utf-8"
				}
			}
			var request = streams.httpRequest(options);
			// response
			var resp = request.end().response(_);
			// check code
			if ((resp.statusCode !== 204) && (resp.statusCode !== 404)) {
				tracer && tracer("Delete connection " + this.cid + " statusCode: " + resp.statusCode);
				// resp contains JSON error message sent by Java Bridge server
				var respHeaders = httpHelpers.parseHeaders(resp.headers);
				var respData = resp.readAll(_).toString(respHeaders.toNodeCharset());
				if (respHeaders.isJSON()) respData = JSON.parse(respData);
				return {
					body: respData,
					statusCode: resp.statusCode
				}
			}
			tracer && tracer("Connection " + this.cid + " deleted" + (reuse ? " with reuse" : ""));
		}
	} catch (ex) {
		throw _fusionErr(_, ex, "closeFailed", context);
	}
}

exports.getFusionSession = function(_, fsid) {
	return new FusionSession(fsid);
}

// global function called from sessions cleanup
exports.closeSession = function(_, fsid, sessionUrl) {
	var options = {
		url: sessionUrl,
		method: "DELETE"
	}
	var request = streams.httpRequest(options);
	var resp = request.end();
	//	var respStr = request.end().response(_).readAll(_).toString("utf8");
	// TODO: decode response ?
}

exports.install = function() {
	var bridge = require('./fusionSession');
	Object.keys(bridge).forEach(function(key) {
		bridge[key] = exports[key];
	})
}