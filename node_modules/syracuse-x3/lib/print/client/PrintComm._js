"use strict";
var helpers = require('syracuse-core/lib/helpers');
var nodeconfig = require('syracuse-main/lib/nodeconfig');

var traceProtocol = nodeconfig.config && nodeconfig.config.x3print && nodeconfig.config.x3print.protocol && nodeconfig.config.x3print.protocol.trace;


var ND_SLF = [0x00, 0x00, 0x02, 0x12, 0x0C];
var ND_GFD = [0x00, 0x00, 0x02, 0x12, 0x0B];
var GETSTATEREPORT = [0x00, 0x00, 0x02, 0x12, 0x7B];

var serializers = {
	U: function(val) {//string
		if (typeof val !== 'string') throw new Error("action parameter type mismatch, expected string, got " + typeof val);
		var len = Buffer.byteLength(val, 'utf8');
		var buf = new Buffer(len + 4);
		buf.writeInt16BE(len + 2, 0);
		buf.writeInt16BE(val.length, 2);
		buf.write(val, 4, len, 'utf8');
		return buf;
	},
	S: function(val) {// short
		if (typeof val !== 'number') throw new Error("action parameter type mismatch, expected number, got " + typeof val);
		return new Buffer([(val >> 8) & 0xff, val & 0xff]);
	},
	B: function(val){ // Byte
		return new Buffer([val]);
	},
	L: function(val) {// Integer 
		if (typeof val !== 'number') throw new Error("action parameter type mismatch, expected number, got " + typeof val);
		return new Buffer([(val >> 24) & 0xff, (val >> 16) & 0xff, (val >> 8) & 0xff, val & 0xff]);
	},
}

function getBytes(val, type) {
	switch (type) {
		case "ANSI":
			var buf = new Buffer(val.length );
			for (var i = 0; i < val.length; i++) {
				var ch = val.charCodeAt(i);
				buf[ i ] = ch & 0xff;
			}
			return buf;
		case "NULL":
			return new Buffer([0]);
		case "SHORT":
			return new Buffer([0, (val >> 8) & 0xff, val & 0xff])
		case "INT":
			return new Buffer([0, (val >> 24) & 0xff, (val >> 16) & 0xff, //
			(val >> 8) & 0xff, val & 0xff]);
		default:
			throw new Error("NIY getBytes for: " + this.type);
	}
}

function fromBytes(buf, type) {
	switch (type) {
		case "INT":
			return (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
		default:
			throw new Error("NIY fromBytes for: " + this.type);
	}
}

function getProperties(data) {
	var str = data.toString('utf8');
	return str.split('\n').reduce(function(result, line) {
		if (line) {
			var pair = line.split('=\u0001');
			if (pair[0] && pair[0] !== "")
				result[pair[0]] = pair[1];
		}
		return result || {};
	}, {});
}

function buildProperties(props, node) {
	var propsArr = [];
	for (var i in props){
		propsArr.push(i + '=\u0001' + props[i]);
	}
	var propsStr = propsArr.join('\n');
	var buf =  Buffer.concat([serializers['L'](propsStr.length), getBytes(propsStr, "ANSI")]);
	traceProtocol && traceProtocol("Send properties: "+propsStr);
	var nodeId = new Buffer(node);
	return Buffer.concat([nodeId,  serializers['B'](0), buf, serializers['B'](0), serializers['L'](0)]);
}


var printComm = exports.printComm = helpers.defineClass(function(_, stream) {
	this.stream = stream;
	
	if (nodeconfig.config && nodeconfig.config.x3print && nodeconfig.config.x3print.dump)
		this._spy = new Spy(_, this.stream);
	
	this.technoVers = {
			UIAction: 'SetTechnoVers',
			Version: '100.001',
			Id: '2',
			Protocol: '150067',
	};
	this.srvTechnoVers = null;
}, null, {
	connect: function(_) {
		this.stream.write(_, new Buffer([5, 0]));
		var buf = this.stream.read(_, 4);
		var pid = fromBytes(buf, "INT");
		traceProtocol && traceProtocol("Connected: "+pid);
		this.srvTechnoVers = this.send_ND_CALLUI(_, this.technoVers, this.technoVers);
		traceProtocol && traceProtocol("TechnoVers: "+JSON.stringify(this.srvTechnoVers));
		
		return pid;
	},
	disconnect: function(_) {
		this.send_ND_CLOSE(_);
	},
	
	/*
	 * Demandes de Type "Report"
	 * 
	 */
	// Exécution d'un rapport
	send_ND_NEWREPORT: function(){
		
	},
	// Changement du niveau de priorité d'un job
	send_ND_PRIORITYREPORT: function(){
		
	},
	// Interrogation demandes en cours ou en attentes
	send_ND_DISPLAYREPORT: function(){
		
	},
	// Arrêt-Suppression d'un job
	send_ND_DELETEREPORT: function(){
		
	},
	// Enumération imprimantes
	send_ND_LISTPRINTER: function(){
		
	},
	// Sélection-configuration d'une imprimante
	send_ND_SELPRINTER: function(){
		
	},
	// Recupération du statut d'un job
	send_ND_GETSTATEREPORT: function(){
		
	},
	// Recuperation du resultat d'un Job
	send_ND_GETRESULTREPORT: function(){
		
	},
	// Implementation de l'instruction L4G "Getui"
	send_ND_GETUI: function(_, props){
		this.stream.write(_, buildProperties(props, ND_GFD));
	},
	// Implementation de l'instruction L4G "Callui"
	send_ND_CALLUI: function(_, props){
		this.stream.write(_, buildProperties(props, ND_SLF));
		var head = this.stream.read(_, 5);
		var len = head.readInt32BE(1);
		return getProperties(this.stream.read(_, len));
	},
	// Fin de la connexion
	send_ND_CLOSE: function(_){
		this.stream.write(_, new Buffer([0x00, 0x00, 0x02, 0x12, 0x63]));
	},
	send_ND_FIN: function(){
		
	},
	
	/*
	 * Demandes de Type "Description Imprimantes"
	 * 
	 */
	// Récupération caractéristiques des imprimantes
	send_ND_DISPLAYALLPRINTER: function(){
		
	},
	send_ND_MOREONPRINTER: function(){
		
	},
	send_ND_EXTRAPRINTER: function(){
		
	},
	send_ND_PRINTERFIN: function(){
		
	},

});

var Spy = helpers.defineClass(function(_, stream) {
	var self = this;

	this.dumpFile = __dirname + "/../data/dump_" + (new Date().toISOString()).replace(/\:/g,'-') + ".js";
	require('fs').appendFile(this.dumpFile, '"use strict";\n', 'utf8', _);

	var read = stream.read;
	stream.read = function(_, len) {
		var data = read.call(stream, _, len);
		if (data) self.dumpBytes(_, "READ", data);
		return data;
	};
	var write = stream.write;
	stream.write = function(_, data) {
		if (data) self.dumpBytes(_, "WRITE", data);
		write.call(stream, _, data);
	}
}, null, {
	dumpBytes: function(_, action, data) {
		var line = action + "([0x" + data.toString('hex').match(/.{1,2}/g).join(', 0x') + "]);\n";
		require('fs').appendFile(this.dumpFile, line, 'utf8', _);
	},
	dumpJSON: function(_, action, obj) {
		var line = action + "(" + JSON.stringify(obj) + ");\n";
		require('fs').appendFile(this.dumpFile, line, 'utf8', _);
	}
});
