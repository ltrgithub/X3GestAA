"use strict";
var helpers = require('syracuse-core/lib/helpers');
var nodeconfig = require('syracuse-main/lib/nodeconfig');

var traceProtocol = nodeconfig.config && nodeconfig.config.x3print && nodeconfig.config.x3print.protocol && nodeconfig.config.x3print.protocol.trace;

var ND_SLF = [0x12, 0x0C];
var ND_GFD = [0x12, 0x0B];
var ND_GETSTATEREPORT = [0x12, 0x7B];
var ND_GETRESULTREPORT = [0x12, 0x7C];

var ND_ALLPRINT = [0x44, 0x01];
var ND_MOREPRINT = [0x44, 0x03];
var ND_EXTRAPRINT = [0x44, 0x04];

var ZERO_BYTE = new Buffer([0x00]);
var NODE_ID_LEN = new Buffer([0x00, 0x02]);



function buildProperties(props, node) {
	var propsArr = [];
	for (var i in props){
		propsArr.push(i + '=\u0001' + props[i]);
	}
	var propsStr = propsArr.join('\n');
	var bufLen = new Buffer(4);
	bufLen.writeInt32BE(propsStr.length, 0);
	var buf =  Buffer.concat([new Buffer([0]), bufLen, new Buffer(propsStr, "utf8")]);
	//traceProtocol && traceProtocol("Send properties: "+propsStr);
	var nodeId = new Buffer(node);
	var bufEnd = new Buffer(4);
	bufEnd.writeInt32BE(0, 0);
	return Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId, buf, new Buffer([0]), bufEnd]);
}

function readProperties(_, stream) {
	
	function getProperty(data) {
		var str = data.toString('utf8');
		return str.split('\n').reduce(function(result, line) {
			if (line) {
				var pair = line.split('=\u0001');
				if (pair[0] && pair[0] !== "")
					properties[pair[0]] = pair[1];
			}
			return;
		}, {});
	}
	var properties = {};
	while (true) {
		var head = stream.read(_, 5);
		var len = head.readInt32BE(1);
		if (len < 0) throw new Error("bad property len: " + len);
		if (len === 0) return properties;
		getProperty(stream.read(_, len));
	}
}


var printComm = exports.printComm = helpers.defineClass(function(_, stream) {
	this.stream = stream;
	
	if (nodeconfig.config && nodeconfig.config.x3print && nodeconfig.config.x3print.dump)
		this._spy = new Spy(_, this.stream);
	
	this.technoVers = {
			UIAction: 'SetTechnoVers',
			Version: '100.001',
			Id: '2',
			Protocol: '150067',
	};
	this.srvTechnoVers = null;
}, null, {
	connect: function(_) {
		this.stream.write(_, new Buffer([5, 0]));
		var buf = this.stream.read(_, 4);
		var pid = buf.readInt32BE(0);
		traceProtocol && traceProtocol("Connected: "+pid);
		this.srvTechnoVers = this.send_ND_CALLUI(_, this.technoVers);
		traceProtocol && traceProtocol("TechnoVers: "+JSON.stringify(this.srvTechnoVers));
		
		return pid;
	},
	disconnect: function(_) {
		this.send_ND_CLOSE(_);
	},
	
	/*
	 * Demandes de Type "Report"
	 * 
	 */
	// Exécution d'un rapport
	send_ND_NDOUVIMP: function(){
		
	},
	// Changement du niveau de priorité d'un job
	send_ND_PRIORITYREPORT: function(){
		
	},
	// Interrogation demandes en cours ou en attentes
	send_ND_DISPLAYREPORT: function(){
		
	},
	// Arrêt-Suppression d'un job
	send_ND_DELETEREPORT: function(){
		
	},
	// Enumération imprimantes
	send_ND_LISTPRINTER: function(){
		
	},
	// Sélection-configuration d'une imprimante
	send_ND_SELPRINTER: function(){
		
	},
	// Recupération du statut d'un job
	send_ND_GETSTATEREPORT: function(_, jobId){
		var nodeId = new Buffer(ND_GETSTATEREPORT);
		var buf = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId,  new Buffer([jobId.length]), new Buffer(jobId, "utf8")]);
		this.stream.write(_, buf);
		var bufState = this.stream.read(_, 2);
		var state = bufState.readInt16BE(0);
		var bufMsg = new Buffer([]);
		while (true) {
			var lenBlock = this.stream.read(_, 4).readInt32BE(0);
			if (lenBlock < 0) throw new Error("bad block len: " + len);
			if (lenBlock === 0) break;
			Buffer.concat([bufMsg, this.stream.read(_, lenBlock)]);
		}
		var msg = bufMsg.toString('utf8');
		return {
			state: state,
			message: msg
		};
	},
	// Recuperation du resultat d'un Job
	send_ND_GETRESULTREPORT: function(_, jobId){
		var nodeId = new Buffer(ND_GETRESULTREPORT);
		var buf = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId,  new Buffer([jobId.length]), new Buffer(jobId, "utf8")]);

		var lenBin = this.stream.read(_, 4).readInt32BE(0);
		
		
	},
	// Implementation de l'instruction L4G "Getui"
	send_ND_GETUI: function(_, props){
		this.stream.write(_, buildProperties(props, ND_GFD));
		return readProperties(_, this.stream);
	},
	// Implementation de l'instruction L4G "Callui"
	send_ND_CALLUI: function(_, props){
		this.stream.write(_, buildProperties(props, ND_SLF));
		return readProperties(_, this.stream);
	},
	// Fin de la connexion
	send_ND_CLOSE: function(_){
		this.stream.write(_, new Buffer([0x00, 0x00, 0x02, 0x12, 0x63]));
	},
	send_ND_FIN: function(){
		
	},
	
	/*
	 * Demandes de Type "Description Imprimantes"
	 * 
	 */
	// Récupération caractéristiques des imprimantes
	send_ND_DISPLAYALLPRINTER: function(_){
		var nodeId = new Buffer(ND_ALLPRINT);
		var buf = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId]);
		this.stream.write(_,buf);
		// read all printer info
		var read = this.stream.read(_,4);
		var len = read.readInt32BE(1);
		var bufBin = this.stream.read(_,len);
		console.log("bufBin " + bufBin.toString('hex'));
	},
	// params is table contains id printer and options asked 
	send_ND_MOREONPRINTER: function(_, prName, prPort, prDriver, prTaille, pBufType){
		var nodeId = new Buffer(ND_MOREPRINT);
		var bufLen = new Buffer(4);
		bufLen.writeInt32BE(body.length, 0);
		var header = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId, bufLen]);
		var body = prName+"\n"+prDriver+"\n"+prPort+"\n";
		var buf = Buffer.concat([header,Buffer.concat([new Buffer(body,"utf8")])]);
		this.stream.write(_,buf);

		var read = this.stream.read(_,4);
		var len = read.readInt32BE(1);
		var bufBin = this.stream.read(_,len);
		console.log("bufBin : "+bufBin.toString('hex'));

		
	},
	send_ND_EXTRAPRINTER: function(_){
		var body = "";//TODO
		var bufLen = new Buffer(4);
		bufLen.writeInt32BE(body.length, 0);
		var nodeId = new Buffer(ND_MOREPRINT);
		var header = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId, bufLen]);
		//TODO add buffer bin request
		var buf = Buffer.concat([header,body]);
		this.stream.write(_,buf);

		var read = this.stream.read(_,4);
		var len = read.readInt32BE(1);
		var bufBin = this.stream.read(_,len);
		// TODO create structure correspond to all printer list


	},
	send_ND_PRINTERFIN: function(_){
		var nodeId = new Buffer(ND_ALLPRINT);
		var buf = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId]);
		this.stream.write(_,buf);
		var read = this.stream.read(_,4);
		var len = read.readInt32BE(1);
		var bufBin = this.stream.read(_,len);
		// TODO create structure correspond to all printer list

	},

});

var Spy = helpers.defineClass(function(_, stream) {
	var self = this;

	this.dumpFile = __dirname + "/../data/dump_" + (new Date().toISOString()).replace(/\:/g,'-') + ".js";
	require('fs').appendFile(this.dumpFile, '"use strict";\n', 'utf8', _);

	var read = stream.read;
	stream.read = function(_, len) {
		var data = read.call(stream, _, len);
		if (data) self.dumpBytes(_, "READ", data);
		return data;
	};
	var write = stream.write;
	stream.write = function(_, data) {
		if (data) self.dumpBytes(_, "WRITE", data);
		write.call(stream, _, data);
	}
}, null, {
	dumpBytes: function(_, action, data) {
		var line = action + "([0x" + data.toString('hex').match(/.{1,2}/g).join(', 0x') + "]);\n";
		require('fs').appendFile(this.dumpFile, line, 'utf8', _);
	},
	dumpJSON: function(_, action, obj) {
		var line = action + "(" + JSON.stringify(obj) + ");\n";
		require('fs').appendFile(this.dumpFile, line, 'utf8', _);
	}
});
