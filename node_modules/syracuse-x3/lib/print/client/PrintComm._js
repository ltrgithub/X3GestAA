"use strict";
var helpers = require('syracuse-core/lib/helpers');
var nodeconfig = require('syracuse-main/lib/nodeconfig');

var traceProtocol = nodeconfig.config && nodeconfig.config.x3print && nodeconfig.config.x3print.protocol && nodeconfig.config.x3print.protocol.trace;

var ND_SLF = [0x12, 0x0C];
var ND_GFD = [0x12, 0x0B];
var ND_GETSTATEREPORT = [0x12, 0x7B];
var ND_GETRESULTREPORT = [0x12, 0x7C];
var ND_ALLPRINT = [0x44, 0x01];
var ND_MOREPRINT = [0x44, 0x03];
var ND_EXTRAPRINT = [0x44, 0x04];


var ZERO_BYTE = new Buffer([0x00]);
var NODE_ID_LEN = new Buffer([0x00, 0x02]);


var readers = {
	S: function(buf) {// short
		return (buf[0] << 8) | buf[1];
	},
}
var serializers = {
	U: function(val) {//string
		if (typeof val !== 'string') throw new Error("action parameter type mismatch, expected string, got " + typeof val);
		var len = Buffer.byteLength(val, 'utf8');
		var buf = new Buffer(len + 4);
		buf.writeInt16BE(len + 2, 0);
		buf.writeInt16BE(val.length, 2);
		buf.write(val, 4, len, 'utf8');
		return buf;
	},
	S: function(val) {// short
		if (typeof val !== 'number') throw new Error("action parameter type mismatch, expected number, got " + typeof val);
		return new Buffer([(val >> 8) & 0xff, val & 0xff]);
	},
	B: function(val){ // Byte
		return new Buffer([val]);
	},
	L: function(val) {// Integer 
		if (typeof val !== 'number') throw new Error("action parameter type mismatch, expected number, got " + typeof val);
		return new Buffer([(val >> 24) & 0xff, (val >> 16) & 0xff, (val >> 8) & 0xff, val & 0xff]);
	},
}

function getBytes(val, type) {
	switch (type) {
		case "UTF8":
			var buf = new Buffer(val.length );
			for (var i = 0; i < val.length; i++) {
				var ch = val.charCodeAt(i);
				buf[ i ] = ch & 0xff;
			}
			return buf;
		case "NULL":
			return new Buffer([0]);
		case "SHORT":
			return new Buffer([0, (val >> 8) & 0xff, val & 0xff])
		case "INT":
			return new Buffer([0, (val >> 24) & 0xff, (val >> 16) & 0xff, //
			(val >> 8) & 0xff, val & 0xff]);
		default:
			throw new Error("NIY getBytes for: " + this.type);
	}
}

function fromBytes(buf, type) {
	switch (type) {
		case "INT":
			return (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
		default:
			throw new Error("NIY fromBytes for: " + this.type);
	}
}



function buildProperties(props, node) {
	var propsArr = [];
	for (var i in props){
		propsArr.push(i + '=\u0001' + props[i]);
	}
	var propsStr = propsArr.join('\n');
	var buf =  Buffer.concat([serializers['B'](0), serializers['L'](propsStr.length), getBytes(propsStr, "UTF8")]);
	//traceProtocol && traceProtocol("Send properties: "+propsStr);
	var nodeId = new Buffer(node);
	return Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId, buf, serializers['B'](0), serializers['L'](0)]);
}

function readProperties(_, stream) {
	
	function getProperty(data) {
		var str = data.toString('utf8');
		return str.split('\n').reduce(function(result, line) {
			if (line) {
				var pair = line.split('=\u0001');
				if (pair[0] && pair[0] !== "")
					properties[pair[0]] = pair[1];
			}
			return;
		}, {});
	}
	var properties = {};
	while (true) {
		var head = stream.read(_, 5);
		var len = head.readInt32BE(1);
		if (len < 0) throw new Error("bad property len: " + len);
		if (len === 0) return properties;
		getProperty(stream.read(_, len));
	}
}


var printComm = exports.printComm = helpers.defineClass(function(_, stream) {
	this.stream = stream;
	
	if (nodeconfig.config && nodeconfig.config.x3print && nodeconfig.config.x3print.dump)
		this._spy = new Spy(_, this.stream);
	
	this.technoVers = {
			UIAction: 'SetTechnoVers',
			Version: '100.001',
			Id: '2',
			Protocol: '150067',
	};
	this.srvTechnoVers = null;
}, null, {
	connect: function(_) {
		this.stream.write(_, new Buffer([5, 0]));
		var buf = this.stream.read(_, 4);
		var pid = fromBytes(buf, "INT");
		traceProtocol && traceProtocol("Connected: "+pid);
		this.srvTechnoVers = this.send_ND_CALLUI(_, this.technoVers);
		traceProtocol && traceProtocol("TechnoVers: "+JSON.stringify(this.srvTechnoVers));
		
		return pid;
	},
	disconnect: function(_) {
		this.send_ND_CLOSE(_);
	},
	
	/*
	 * Demandes de Type "Report"
	 * 
	 */
	// Exécution d'un rapport
	send_ND_NEWREPORT: function(){
		
	},
	// Changement du niveau de priorité d'un job
	send_ND_PRIORITYREPORT: function(){
		
	},
	// Interrogation demandes en cours ou en attentes
	send_ND_DISPLAYREPORT: function(){
		
	},
	// Arrêt-Suppression d'un job
	send_ND_DELETEREPORT: function(){
		
	},
	// Enumération imprimantes
	send_ND_LISTPRINTER: function(){
		
	},
	// Sélection-configuration d'une imprimante
	send_ND_SELPRINTER: function(){
		
	},
	// Recupération du statut d'un job
	send_ND_GETSTATEREPORT: function(_, jobId){
		var nodeId = new Buffer(ND_GETSTATEREPORT);
		var buf = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId,  serializers['B'](jobId.length), getBytes(jobId, "UTF8")]);
		this.stream.write(_, buf);
		var bufState = this.stream.read(_, 2);
		var state = readers['S'](bufState);
		var bufMsg = new Buffer([]);
		while (true) {
			var lenBlock = this.stream.read(_, 4).readInt32BE(0);
			if (lenBlock < 0) throw new Error("bad block len: " + len);
			if (lenBlock === 0) break;
			Buffer.concat([bufMsg, this.stream.read(_, lenBlock)]);
		}
		var msg = bufMsg.toString('utf8');
		return {
			state: state,
			message: msg
		};
	},
	// Recuperation du resultat d'un Job
	send_ND_GETRESULTREPORT: function(){
		var nodeId = new Buffer(ND_GETRESULTREPORT);
		
		
		
	},
	// Implementation de l'instruction L4G "Getui"
	send_ND_GETUI: function(_, props){
		this.stream.write(_, buildProperties(props, ND_GFD));
		return readProperties(_, this.stream);
	},
	// Implementation de l'instruction L4G "Callui"
	send_ND_CALLUI: function(_, props){
		this.stream.write(_, buildProperties(props, ND_SLF));
		return readProperties(_, this.stream);
	},
	// Fin de la connexion
	send_ND_CLOSE: function(_){
		this.stream.write(_, new Buffer([0x00, 0x00, 0x02, 0x12, 0x63]));
	},
	send_ND_FIN: function(){
		
	},
	
	/*
	 * Demandes de Type "Description Imprimantes"
	 * 
	 */
	// Récupération caractéristiques des imprimantes
	send_ND_DISPLAYALLPRINTER: function(){
		var buf = Buffer.concat([serializers['B'](0), serializers['S'](2),serializers['S'](ND_ALLPRINT));
		this.stream.write(_,buf);
		// read all printer info
		var read = this.stream.read(_,4);
		var len = read.readInt32BE(1);
		var bufBin = this.stream.read(_,len);
		// TODO create structure correspond to all printer list
	},
	// params is table contains id printer and options asked 
	send_ND_MOREONPRINTER: function(prName,prPort,prDriver,prTaille,pBufType){
		var lenBody = body.length;
		var header = Buffer.concat([serializers['B'](0), serializers['S'](2),serializers['S'](ND_MOREPRINT),serializers['L'](lenBody)]);
		var body = prName+"\n"+prDriver+"\n"+prPort+"\n";
		var buf = Buffer.concat([header,Buffer.concat([getBytes(body,"ANSI")])]);
		this.stream.write(_,buf);

		var read = this.stream.read(_,4);
		var len = read.readInt32BE(1);
		var bufBin = this.stream.read(_,len);
		console.log("bufBin : "+bufBin.toString('hex'));

		
	},
	send_ND_EXTRAPRINTER: function(){
		var body = "";//TODO
		var lenBody = body.length;
		var header = Buffer.concat([serializers['B'](0), serializers['S'](2),serializers['S'](ND_MOREPRINT),serializers['L'](lenBody));
		//TODO add buffer bin request
		var buf = Buffer.concat([header,body]);
		this.stream.write(_,buf);

		var read = this.stream.read(_,4);
		var len = read.readInt32BE(1);
		var bufBin = this.stream.read(_,len);
		// TODO create structure correspond to all printer list


	},
	send_ND_PRINTERFIN: function(){
		var buf = Buffer.concat([serializers['B'](0), serializers['S'](2),serializers['S'](ND_ALLPRINT));
		this.stream.write(_,buf);
		var read = this.stream.read(_,4);
		var len = read.readInt32BE(1);
		var bufBin = this.stream.read(_,len);
		// TODO create structure correspond to all printer list

	},

});

var Spy = helpers.defineClass(function(_, stream) {
	var self = this;

	this.dumpFile = __dirname + "/../data/dump_" + (new Date().toISOString()).replace(/\:/g,'-') + ".js";
	require('fs').appendFile(this.dumpFile, '"use strict";\n', 'utf8', _);

	var read = stream.read;
	stream.read = function(_, len) {
		var data = read.call(stream, _, len);
		if (data) self.dumpBytes(_, "READ", data);
		return data;
	};
	var write = stream.write;
	stream.write = function(_, data) {
		if (data) self.dumpBytes(_, "WRITE", data);
		write.call(stream, _, data);
	}
}, null, {
	dumpBytes: function(_, action, data) {
		var line = action + "([0x" + data.toString('hex').match(/.{1,2}/g).join(', 0x') + "]);\n";
		require('fs').appendFile(this.dumpFile, line, 'utf8', _);
	},
	dumpJSON: function(_, action, obj) {
		var line = action + "(" + JSON.stringify(obj) + ");\n";
		require('fs').appendFile(this.dumpFile, line, 'utf8', _);
	}
});
