"use strict";
var helpers = require('syracuse-core/lib/helpers');
var nodeconfig = require('syracuse-main/lib/nodeconfig');

var traceProtocol = nodeconfig.config && nodeconfig.config.x3print && nodeconfig.config.x3print.protocol && nodeconfig.config.x3print.protocol.trace;

var ND_SLF = [0x12, 0x0C];
var ND_GFD = [0x12, 0x0B];
var ND_LIM = [0x12, 0x0A];
var ND_GETSTATEREPORT = [0x12, 0x7B];
var ND_GETRESULTREPORT = [0x12, 0x7C];
var ND_DELETEREPORT = [0x12, 0x7F];
var ND_NDOUVIMP = [0x12, 0x01];

var ND_ALLPRINT = [0x42, 0x01];
var ND_MOREPRINT = [0x42, 0x03];
var ND_EXTRAPRINT = [0x42, 0x04];

var ZERO_BYTE = new Buffer([0x00]);
var NODE_ID_LEN = new Buffer([0x00, 0x02]);

function trace(_, spy, str) {
	traceProtocol && traceProtocol(str);
	spy && spy.dumpStr(_, str);
}

function readIntOnUcs2(buf,offset){
	return new Buffer([buf[offset],buf[offset+2],buf[offset+4],buf[offset+6]]).readInt32BE(0);
}

function buildProperties(props) {
	var propsArr = [];
	for (var i in props){
		propsArr.push(i + '=\u0001' + props[i]);
	}
	var r = propsArr.join('\n');
	return r;
}

function writeProperties1(_, stream, propsStr, node){
	var buf;
	if (propsStr.length !== 0) {
		var bufLen = new Buffer(4);
		bufLen.writeInt32BE(propsStr.length, 0);
		buf =  Buffer.concat([new Buffer([0]), bufLen, new Buffer(propsStr, "utf8")]);
	}
	else {
		buf = new Buffer([]);
	}
	//traceProtocol && traceProtocol("Send properties: "+propsStr);
	var nodeId = new Buffer(node);
	var bufEnd = new Buffer(4);
	bufEnd.writeInt32BE(0, 0);
	stream.write(_,  Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId, buf, new Buffer([0]), bufEnd]));	
}

function getProperty(map, data, isProperties2) {
	
	function storeProperty() {
		var keyBuf = new Buffer(key);
		var keyStr = keyBuf.toString('utf8');
		var valueBuf = new Buffer(value);
		var valueStr = valueBuf.toString('utf8');

		map[keyStr] = map[keyStr] || [];
		map[keyStr][idx - 1] = valueStr;
	}
	var idx;
	var key = [];
	var value = [];
	var applyOn = "key";
	var nextIsIdx = false;
	for (var i=0; i < data.length ; i++) {
		var charCode = data[i];
		//console.log("CharAt["+i+"]:["+charCode+"] "+String.fromCharCode(charCode).toString());
		if (!nextIsIdx) {
			// =
			if (data[i] === 61) {
				applyOn = "value";
				try {
					idx = parseInt(data[i+1], 10);
					nextIsIdx = true;
				}catch(e){
					idx=0;
				}
			}
			// \n
			else if (!isProperties2 && data[i] === 10){
				applyOn = "key";
				storeProperty();
				key = []; value = [];
			}
			else {
				if (applyOn === "key")
					key.push(data[i]);
				else if(applyOn === "value") {
					value.push(data[i]);
				}
			}
		}else {
			nextIsIdx = false;
		}
	}
	if (isProperties2 && idx && idx > 0) {
		storeProperty();
	}
	return map;
}

function readProperties1(_, stream) {
	var map = {};
	while (true) {
		var head = stream.read(_, 5);
		var len = head.readInt32BE(1);
		if (len < 0) throw new Error("bad property1 len: " + len);
		if (len === 0) {
			for (var i in map) {
				if (map[i] && Array.isArray(map[i]))
					map[i] = map[i].join('');
			}
			//console.log("Properties1: "+JSON.stringify(map,null,2));
			return map;
		}
		map = getProperty(map, stream.read(_, len));
	}
}

function readProperties2(_, stream) {
	var map = {};
	while (true) {
		var len = stream.read(_, 1).readInt8(0);;
		if (len < 0) throw new Error("bad property2 len: " + len);
		if (len === 0) {
			stream.read(_, 4);
			for (var i in map) {
				if (map[i] && Array.isArray(map[i]))
					map[i] = map[i].join('');
			}
			//console.log("Properties2: "+JSON.stringify(map,null,2));
			return map;
		}
		map = getProperty(map, stream.read(_, len), true);
	}
}

var printComm = exports.printComm = helpers.defineClass(function(_, stream) {
	this.stream = stream;
	
	if (nodeconfig.config && nodeconfig.config.x3print && nodeconfig.config.x3print.dump)
		this._spy = new Spy(_, this.stream);
	
	this.technoVers = {
			UIAction: 'SetTechnoVers',
			Version: '100.001',
			Id: '2',
			Protocol: '150067',
	};
	this.srvTechnoVers = null;
}, null, {
	connect: function(_) {
		this.dumpHeader(_, "CONNECT");
		this.stream.write(_, new Buffer([5, 0]));
		var buf = this.stream.read(_, 4);
		var pid = buf.readInt32BE(0);
		if (pid === -1)
			throw new Error("SrvImp connection failed.");
		traceProtocol && traceProtocol("Connected: "+pid);
		this.srvTechnoVers = this.send_ND_CALLUI(_, this.technoVers);
		this.dumpResult(_, pid);
		return pid;
	},
	disconnect: function(_) {
		this.dumpHeader(_, "DISCONNECT");
		this.send_ND_CLOSE(_);
	},
	
	/*
	 * Demandes de Type "Report"
	 * 
	 */
	// Exécution d'un rapport
	send_ND_NDOUVIMP: function(_, properties){
		this.dumpHeader(_, "ND_NDOUVIMP", properties);
		// Build request
		var nodeId = new Buffer(ND_NDOUVIMP);
		var buf = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId]);
		
		var bufProps = new Buffer([]);
		for (var i in properties) {
			
			var str = i + '=\u0001' + properties[i];
			var b = new Buffer(str, 'utf8');
			var l = new Buffer([b.length]);
			bufProps = Buffer.concat([bufProps, l, b]);
		}
		var endBuf = new Buffer(4);
		endBuf.writeInt32BE(0, 0);
		this.stream.write(_, Buffer.concat([buf, bufProps, new Buffer([0]), endBuf]));
		
		// Get response
		var seqId = this.stream.read(_, 2).readInt16BE(0);
		this.dumpResult(_, seqId);
		return seqId;
	},
	// Arrêt-Suppression d'un job
	send_ND_DELETEREPORT: function(_, seqId){
		this.dumpHeader(_, "ND_DELETEREPORT", {seqId: seqId});
		// Build request
		var nodeId = new Buffer(ND_DELETEREPORT);
		var bufSeq = new Buffer(2);
		bufSeq.writeInt16BE(seqId, 0);
		var buf = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId, new Buffer([2]), bufSeq, ZERO_BYTE]);
		this.stream.write(_, buf);
		// No response
	},

	// Recupération du statut d'un job
	send_ND_GETSTATEREPORT: function(_, jobId){
		this.dumpHeader(_, "ND_GETSTATEREPORT", {jobId: jobId});
		// Build request
		var bufJob = new Buffer(jobId.toString(), "utf8");
		var nodeId = new Buffer(ND_GETSTATEREPORT);
		var buf = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId,  new Buffer([bufJob.length]), bufJob]);
		this.stream.write(_, buf);
		// Get response
		var state = this.stream.read(_, 2).readInt16BE(0);
		var bufMsg = new Buffer([]);
		while (true) {
			var lenBlock = this.stream.read(_, 4).readInt32BE(0);
			if (lenBlock < 0) throw new Error("bad block len: " + len);
			if (lenBlock === 0) break;
			bufMsg = Buffer.concat([bufMsg, this.stream.read(_, lenBlock)]);
		}
		var msg = bufMsg.toString('utf8');
		var res = {
			state: state,
			message: msg
		};
		this.dumpResult(_, res);
		return res;
	},
	// Recuperation du resultat d'un Job
	send_ND_GETRESULTREPORT: function(_, jobId){
		this.dumpHeader(_, "ND_GETRESULTREPORT", {jobId: jobId});
		// Build request
		var bufJob = new Buffer(jobId.toString(), "utf8");
		var nodeId = new Buffer(ND_GETRESULTREPORT);
		var buf = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId,  new Buffer([bufJob.length]), bufJob]);
		this.stream.write(_, buf);
		// Get response
		var lenBin = this.stream.read(_, 4).readInt32BE(0);
		var bufBin = new Buffer([]);
		while (true) {
			var lenBlock = this.stream.read(_, 4).readInt32BE(0);
			if (lenBlock < 0) throw new Error("bad block len: " + len);
			if (lenBlock === 0) break;
			bufBin = Buffer.concat([bufBin, this.stream.read(_, lenBlock)]);
		}
		var bin = bufBin.toString('binary');
		var res = {
			length: lenBin,
			binary: bin
		};
		this.dumpResult(_, res);
		return res;
	},
	// Enumération imprimantes
	send_ND_LISTPRINTER: function(_){
		var p = buildProperties({});
		this.dumpHeader(_, "ND_LISTPRINTER", p);
		writeProperties1(_, this.stream, p, ND_LIM);
		var props = readProperties1(_, this.stream);
		var n = parseInt(props._NbPrinters.charCodeAt(0), 10);
		props._NbPrinters = n;
		this.dumpResult(_, props);
		return props;
	},
	// Implementation de l'instruction L4G "Getui"
	send_ND_GETUI: function(_, props){
		var p = buildProperties(props);
		this.dumpHeader(_, "ND_GETUI", p);
		writeProperties1(_, this.stream, p, ND_GFD);
		var res = readProperties1(_, this.stream);
		this.dumpResult(_, res);
		return res;
	},
	// Implementation de l'instruction L4G "Callui"
	send_ND_CALLUI: function(_, props){
		var p = buildProperties(props);
		this.dumpHeader(_, "ND_CALLUI", p);
		writeProperties1(_, this.stream, p, ND_SLF);
		var res = readProperties1(_, this.stream);
		this.dumpResult(_, res);
		return res;
		
	},
	// Fin de la connexion
	send_ND_CLOSE: function(_){
		this.dumpHeader(_, "ND_CLOSE");
		this.stream.write(_, new Buffer([0x00, 0x00, 0x02, 0x12, 0x63]));
	},
	send_ND_FIN: function(_){
		this.dumpHeader(_, "ND_FIN");
		this.stream.write(_, new Buffer([0x00, 0x00, 0x02, 0x12, 0x02]));
	},
	// NYI
	// Changement du niveau de priorité d'un job
	send_ND_PRIORITYREPORT: function(){
		console.log("ND_PRIORITYREPORT not yet implemented");
	},
	// Interrogation demandes en cours ou en attentes
	send_ND_DISPLAYREPORT: function(){
		console.log("ND_DISPLAYREPORT not yet implemented");
	},
	/*
	 * Demandes de Type "Description Imprimantes"
	 * return a structure like 
	 *   {
	 *		 "printName":"\\\\172.28.8.4\\HP3390-grenoblye",		
	 *       "portName":"172.28.8.151",
     *		 "driverName":"HP Universal Printing PCL 5",
	 *		 "comment":"",
	 *		 "location":""
	 *	}
	 * 
	 */
	// Récupération caractéristiques des imprimantes
	send_ND_ALL_PRINTER: function(_){
		function readAllPrinterParam(){
			var len = bufBin.readInt32BE(offset);
			offset +=4; 
			var elem = "";
			if (len > 0){
					elem = bufBin.slice(offset, offset+len).toString('ucs2');
					offset+=len;
			}
			return elem;
		}

		this.dumpHeader(_, "ND_ALLPRINT");
		var nodeId = new Buffer(ND_ALLPRINT);
		var buf = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId]);
		this.stream.write(_,buf);
		// read all printer info
		var bufBin = new Buffer([]);
		var nbLen = 0;
		while (true) {
			var lenBlock = this.stream.read(_, 4).readInt32BE(0);
			if (lenBlock < 0) throw new Error("bad block len: " + len);
			if (lenBlock === 0) break;
			bufBin = Buffer.concat([bufBin, this.stream.read(_, lenBlock)]);
		}
		nbLen = bufBin.length;
		var result = [];
		// analysis of bin flux 
		var offset = 0;
		var readed = 0;
		do{
			// printerName
			var obj = {
				printerName: readAllPrinterParam(),
				// printer Port
				printerPort: readAllPrinterParam(),
				// driver name
				driverName: readAllPrinterParam(),
				// comment
				comment: readAllPrinterParam(),
				// location 
				location: readAllPrinterParam(),
			};
			readAllPrinterParam();
			obj.collate = bufBin[offset++] === 1 ? true : false;
				// copies
			obj.copies = bufBin[offset++] === 1 ? true : false;
				// orientatio
			obj.orientation = bufBin[offset++] === 1 ? true : false;
				// duplex
			obj.duplex = bufBin[offset++] === 1 ? true : false;
			result.push(obj);
		}while(offset < nbLen); 
		this.dumpResult(_, result);
		return result;
	},
	// params is table contains id printer and options asked 
	send_ND_MORE_PRINTER: function(_, prName, prPort, prDriver){
		this.dumpHeader(_, "ND_MORE_PRINTER",{
			printerName: prName,
			printerPort: prPort,
			driverName: prDriver
		});
		var nodeId = new Buffer(ND_MOREPRINT);
		var header = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId]);
		//write  full buffer len
		var buffLen = new Buffer(4);
		var body = prName + '\n' + (prDriver == null ? "" : prDriver) + '\n' + (prPort == null ? "" : prPort);
		var bufBod = new Buffer(body,"ucs2");
		buffLen.writeInt32BE(bufBod.length,0);
		var buf = Buffer.concat([header, buffLen, bufBod]);

		this.stream.write(_,buf);

		var bufLen = this.stream.read(_, 4);
		var lenBlock = bufLen.readInt32BE(0); // len total
		if (lenBlock < 0) throw new Error("bad block len: " + lenBlock);

		var bufBin = this.stream.read(_, lenBlock);
		
		var offset = 0;
		var lenPaperSize = readIntOnUcs2(bufBin, offset);
		offset+=8
		var valueOff = offset;
		var nbElem = lenPaperSize / 68 ;
		valueOff += nbElem*8;
		var paperSize = [];
		for(var i=0; i < nbElem; i++){
			var tmp = bufBin.slice(valueOff, valueOff + 128);
			tmp = Buffer.concat([tmp, new Buffer([0])]);
			var str = tmp.toString('ucs2');
			str = str.substring(0, str.indexOf('\u0000'));
			paperSize.push({
				id: readIntOnUcs2(bufBin, offset),
				name:  str
			});			
			offset += 8;
			valueOff += 128;
		}
		
		bufBin = bufBin.slice(valueOff, bufBin.length);
		
		offset = 0;
		var lenBackSize = readIntOnUcs2(bufBin, offset);
		offset += 8
		valueOff = offset;
		nbElem = lenBackSize / 28 ;
		valueOff += nbElem * 8;
		var bac = [];

		for(var i=0; i < nbElem; i++){
			var tmp = bufBin.slice(valueOff, valueOff + 48);
			tmp = Buffer.concat([tmp, new Buffer([0])]);
			var str = tmp.toString('ucs2');
			str = str.substring(0, str.indexOf('\u0000'));
			bac.push({
				id: readIntOnUcs2(bufBin, offset),
				name:  str
			});			
			offset += 8;
			valueOff += 48;
		}

		var res = {
			"paperSize" : paperSize,
			"bac" : bac
		};
		this.dumpResult(_, res);
		return res;
	},
	send_ND_EXTRA_PRINTER: function(_,prName, prPort, prDriver, prPaperSizeId){
		this.dumpHeader(_, "ND_EXTRA_PRINTER",{
			printerName: prName,
			printerPort: prPort,
			driverName: prDriver,
			prPaperSizeId: prPaperSizeId
		});
		var nodeId = new Buffer(ND_EXTRAPRINT);
		var header = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId]);
		//write  full buffer len
		var buffull = new Buffer(4);
		var body = prName + '\n' + (prDriver == null ? "" : prDriver) + '\n' + (prPort == null ? "" : prPort) + "\n";
		var bufBod = new Buffer(body, "ucs2");
		var bufpaper = new Buffer(4);
		bufpaper.writeInt32BE(prPaperSizeId, 0);

		buffull.writeInt32BE(bufBod.length + bufpaper.length, 0);
		var buf = Buffer.concat([header, buffull, bufBod, bufpaper]);
		this.stream.write(_, buf);

		var lenBlock = this.stream.read(_, 4).readInt32BE(0);
		if (lenBlock < 0) throw new Error("bad block len: " + len);

		var bufBin = this.stream.read(_, lenBlock);
		
		var res = {
			$width: bufBin.readUInt32LE(0),
			$length: bufBin.readUInt32LE(4)
		}	
		this.dumpResult(_, res);
		return res;
	},
	send_ND_END_PRINTER: function(_){
		this.dumpHeader(_, "ND_END_PRINTER");
		this.stream.write(_, new Buffer([0x00, 0x00, 0x02, 0x42, 0x02]));
	},


	dumpHeader: function(_, nodeName, args) {
		trace(_, this._spy, "************************************************************");
		trace(_, this._spy, "\tSend Node: " + nodeName);
		if (args)
			trace(_, this._spy, "\tParams: " + JSON.stringify(args,null,2));
		trace(_, this._spy, "************************************************************");
	},
	dumpResult: function(_, args) {
		if (args)
			trace(_, this._spy, "***** Result *****\n" + JSON.stringify(args,null,2));
		trace(_, this._spy, "\n");
	},
});

var Spy = helpers.defineClass(function(_, stream) {
	var self = this;

	this.dumpFile = __dirname + "/../data/dump_" + (new Date().toISOString()).replace(/\:/g,'-') + ".js";
	require('fs').appendFile(this.dumpFile, '"use strict";\n', 'utf8', _);

	var read = stream.read;
	stream.read = function(_, len) {
		var data = read.call(stream, _, len);
		if (data) self.dumpBytes(_, "READ", data);
		return data;
	};
	var write = stream.write;
	stream.write = function(_, data) {
		write.call(stream, _, data);
		if (data) self.dumpBytes(_, "WRITE", data);
	}
}, null, {
	dumpBytes: function(_, action, data) {
		var line = action + "([0x" + data.toString('hex').match(/.{1,2}/g).join(', 0x') + "]);\n";
		require('fs').appendFile(this.dumpFile, line, 'utf8', _);
	},
	dumpStr: function(_, str) {
		require('fs').appendFile(this.dumpFile, str + "\n", 'utf8', _);
	}
});
