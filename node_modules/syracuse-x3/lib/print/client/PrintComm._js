"use strict";
var helpers = require('syracuse-core/lib/helpers');
var nodeconfig = require('syracuse-main/lib/nodeconfig');

var traceProtocol = nodeconfig.config && nodeconfig.config.x3print && nodeconfig.config.x3print.protocol && nodeconfig.config.x3print.protocol.trace;

var ND_SLF = [0x12, 0x0C];
var ND_GFD = [0x12, 0x0B];
var ND_GETSTATEREPORT = [0x12, 0x7B];
var ND_GETRESULTREPORT = [0x12, 0x7C];
var ND_DELETEREPORT = [0x12, 0x7F];
var ND_NDOUVIMP = [0x12, 0x01];

var ND_ALLPRINT = [0x42, 0x01];
var ND_MOREPRINT = [0x42, 0x03];
var ND_EXTRAPRINT = [0x42, 0x04];

var ZERO_BYTE = new Buffer([0x00]);
var NODE_ID_LEN = new Buffer([0x00, 0x02]);



function buildProperties(props, node) {
	var propsArr = [];
	for (var i in props){
		propsArr.push(i + '=\u0001' + props[i]);
	}
	var propsStr = propsArr.join('\n');
	var bufLen = new Buffer(4);
	bufLen.writeInt32BE(propsStr.length, 0);
	var buf =  Buffer.concat([new Buffer([0]), bufLen, new Buffer(propsStr, "utf8")]);
	//traceProtocol && traceProtocol("Send properties: "+propsStr);
	var nodeId = new Buffer(node);
	var bufEnd = new Buffer(4);
	bufEnd.writeInt32BE(0, 0);
	return Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId, buf, new Buffer([0]), bufEnd]);
}

function readProperties(_, stream) {
	
	function getProperty(data) {
		var str = data.toString('utf8');
		return str.split('\n').reduce(function(result, line) {
			if (line) {
				var pair = line.split('=\u0001');
				if (pair[0] && pair[0] !== "")
					properties[pair[0]] = pair[1];
			}
			return;
		}, {});
	}
	var properties = {};
	while (true) {
		var head = stream.read(_, 5);
		var len = head.readInt32BE(1);
		if (len < 0) throw new Error("bad property len: " + len);
		if (len === 0) return properties;
		getProperty(stream.read(_, len));
	}
}


var printComm = exports.printComm = helpers.defineClass(function(_, stream) {
	this.stream = stream;
	
	if (nodeconfig.config && nodeconfig.config.x3print && nodeconfig.config.x3print.dump)
		this._spy = new Spy(_, this.stream);
	
	this.technoVers = {
			UIAction: 'SetTechnoVers',
			Version: '100.001',
			Id: '2',
			Protocol: '150067',
	};
	this.srvTechnoVers = null;
}, null, {
	connect: function(_) {
		this.stream.write(_, new Buffer([5, 0]));
		var buf = this.stream.read(_, 4);
		var pid = buf.readInt32BE(0);
		traceProtocol && traceProtocol("Connected: "+pid);
		this.srvTechnoVers = this.send_ND_CALLUI(_, this.technoVers);
		traceProtocol && traceProtocol("TechnoVers: "+JSON.stringify(this.srvTechnoVers));
		
		return pid;
	},
	disconnect: function(_) {
		this.send_ND_CLOSE(_);
	},
	
	/*
	 * Demandes de Type "Report"
	 * 
	 */
	// Exécution d'un rapport
	send_ND_NDOUVIMP: function(_, properties){
		// Build request
		var nodeId = new Buffer(ND_NDOUVIMP);
		var buf = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId]);
		
		var bufProps = new Buffer([]);
		for (var i in properties) {
			
			var str = i + '=\u0001' + properties[i];
			var b = new Buffer(str, 'utf8');
			var l = new Buffer([b.length]);
			bufProps = Buffer.concat([bufProps, l, b]);
		}
		var endBuf = new Buffer(4);
		endBuf.writeInt32BE(0, 0);
		this.stream.write(_, Buffer.concat([buf, bufProps, new Buffer([0]), endBuf]));
		
		// Get response
		var seqId = this.stream.read(_, 2).readInt16BE(0);
		return seqId;
	},

	// Enumération imprimantes
	send_ND_LISTPRINTER: function(){
		
	},
	// Arrêt-Suppression d'un job
	send_ND_DELETEREPORT: function(_, seqId){
		// Build request
		var nodeId = new Buffer(ND_DELETEREPORT);
		var bufSeq = new Buffer(2);
		bufSeq.writeInt16BE(seqId, 0);
		var buf = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId, bufSeq]);
		this.stream.write(_, buf);
		// No response
	},

	// Recupération du statut d'un job
	send_ND_GETSTATEREPORT: function(_, jobId){
		// Build request
		var bufJob = new Buffer(jobId.toString(), "utf8");
		var nodeId = new Buffer(ND_GETSTATEREPORT);
		var buf = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId,  new Buffer([bufJob.length]), bufJob]);
		this.stream.write(_, buf);
		// Get response
		var state = this.stream.read(_, 2).readInt16BE(0);
		var bufMsg = new Buffer([]);
		while (true) {
			var lenBlock = this.stream.read(_, 4).readInt32BE(0);
			if (lenBlock < 0) throw new Error("bad block len: " + len);
			if (lenBlock === 0) break;
			bufMsg = Buffer.concat([bufMsg, this.stream.read(_, lenBlock)]);
		}
		var msg = bufMsg.toString('utf8');
		return {
			state: state,
			message: msg
		};

	},
	// Recuperation du resultat d'un Job
	send_ND_GETRESULTREPORT: function(_, jobId){
		// Build request
		var bufJob = new Buffer(jobId.toString(), "utf8");
		var nodeId = new Buffer(ND_GETRESULTREPORT);
		var buf = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId,  new Buffer([bufJob.length]), bufJob]);
		this.stream.write(_, buf);
		// Get response
		var lenBin = this.stream.read(_, 4).readInt32BE(0);
		var bufBin = new Buffer([]);
		while (true) {
			var lenBlock = this.stream.read(_, 4).readInt32BE(0);
			if (lenBlock < 0) throw new Error("bad block len: " + len);
			if (lenBlock === 0) break;
			bufBin = Buffer.concat([bufBin, this.stream.read(_, lenBlock)]);
		}
		var bin = bufBin.toString('binary');
		return {
			length: lenBin,
			binary: bin
		};
	},
	// Implementation de l'instruction L4G "Getui"
	send_ND_GETUI: function(_, props){
		this.stream.write(_, buildProperties(props, ND_GFD));
		return readProperties(_, this.stream);
	},
	// Implementation de l'instruction L4G "Callui"
	send_ND_CALLUI: function(_, props){
		this.stream.write(_, buildProperties(props, ND_SLF));
		return readProperties(_, this.stream);
	},
	// Fin de la connexion
	send_ND_CLOSE: function(_){
		this.stream.write(_, new Buffer([0x00, 0x00, 0x02, 0x12, 0x63]));
	},
	send_ND_FIN: function(_){
		this.stream.write(_, new Buffer([0x00, 0x00, 0x02, 0x12, 0x02]));
	},
	// NYI
	// Changement du niveau de priorité d'un job
	send_ND_PRIORITYREPORT: function(){
		console.log("ND_PRIORITYREPORT not yet implemented");
	},
	// Interrogation demandes en cours ou en attentes
	send_ND_DISPLAYREPORT: function(){
		console.log("ND_DISPLAYREPORT not yet implemented");
	},

	
	/*
	 * Demandes de Type "Description Imprimantes"
	 * return a structure like 
	 * {
	 *		"printName":"\\\\172.28.8.4\\HP3390-grenoblye",		*	   "portName":"172.28.8.151",
     *		 "driverName":"HP Universal Printing PCL 5",
	 *		 "comment":"",
	 *		 "location":""
	 *	}
	 * 
	 */
	// Récupération caractéristiques des imprimantes
	send_ND_ALL_PRINTER: function(_){
		var nodeId = new Buffer(ND_ALLPRINT);
		var buf = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId]);
		this.stream.write(_,buf);
		// read all printer info
		var bufBin = new Buffer([]);
		while (true) {
			var lenBlock = this.stream.read(_, 4).readInt32BE(0);
			if (lenBlock < 0) throw new Error("bad block len: " + len);
			if (lenBlock === 0) break;
			bufBin = Buffer.concat([bufBin, this.stream.read(_, lenBlock)]);
		}
		var result = {};
		// analysis of bin flux 
		var offset = 0;
		// printName
		var len = bufBin.readInt32BE(offset);
		offset +=4; 
		result.printName = bufBin.slice(offset,offset+len).toString('ucs2');
		offset+=len;
		//port 
		len = bufBin.readInt32BE(offset);
		offset +=4; 
		result.portName = bufBin.slice(offset,offset+len).toString('ucs2');
		offset+=len;
		// driver name
		len = bufBin.readInt32BE(offset);
		offset +=4; 
		result.driverName = bufBin.slice(offset,offset+len).toString('ucs2');
		offset+=len;
		// comment 
		len = bufBin.readInt32BE(offset);
		offset +=4; 
		result.comment = bufBin.slice(offset,offset+len).toString('ucs2');
		offset+=len;
		// location
		len = bufBin.readInt32BE(offset);
		offset +=4; 
		result.location = bufBin.slice(offset,offset+len).toString('ucs2');
		offset+=len;
		//devmod
		len = bufBin.readInt32BE(offset);
		offset +=4; 
		result.devmod = bufBin.slice(offset,offset+len).toString('ucs2');
		return result;

	},
	// params is table contains id printer and options asked 
	send_ND_MORE_PRINTER: function(_, prName, prPort, prDriver){
		var nodeId = new Buffer(ND_MOREPRINT);
		var header = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId]);
		//write  full buffer len
		var buffull = new Buffer(4);
		var body = prName+'\n'+prDriver+'\n'+prPort;
		buffull.writeInt32BE(body.length,0);
		var buf = Buffer.concat([header,buffull,new Buffer(body,"ucs2")]);

		console.log("write "+buffull.toString("hex"));
		this.stream.write(_,buf);

		var bufBin = new Buffer([]);
		var lenBlock = this.stream.read(_, 4).readInt32BE(0);
		if (lenBlock < 0) throw new Error("bad block len: " + len);

		console.log("read size "+lenBlock);
		bufBin = Buffer.concat([bufBin, this.stream.read(_, lenBlock)]);
		var bin = bufBin.toString('binary');
		console.log("buf "+bin);


		
	},
	send_ND_EXTRA_PRINTER: function(_,prName, prPort, prDriver,prPaperSize){
		var body = prName+"\n"+prDriver+"\n"+prPort+"\n";
		var bufLen = new Buffer(4);
		bufLen.writeInt32BE(body.length, 0);
		var paperSize = new Buffer(4);
		paperSize.writeInt32BE(prPaperSize, 0);
		var nodeId = new Buffer(ND_MOREPRINT);
		var header = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId, bufLen]);
		var buf = Buffer.concat([header,Buffer.concat([new Buffer(body,"utf8")]),paperSize]);
		this.stream.write(_,buf);
		while (true) {
			var lenBlock = this.stream.read(_, 4).readInt32BE(0);
			if (lenBlock < 0) throw new Error("bad block len: " + len);
			if (lenBlock === 0) break;
			Buffer.concat([bufBin, this.stream.read(_, lenBlock)]);
		}
		var bin = bufBin.toString('binary');
		return {
			length: lenBin,
			binary: bin
		};


	},
	send_ND_END_PRINTER: function(_){
		var nodeId = new Buffer(ND_ENDPRINT);
		var buf = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId]);
		this.stream.write(_,buf);

	},

});

var Spy = helpers.defineClass(function(_, stream) {
	var self = this;

	this.dumpFile = __dirname + "/../data/dump_" + (new Date().toISOString()).replace(/\:/g,'-') + ".js";
	require('fs').appendFile(this.dumpFile, '"use strict";\n', 'utf8', _);

	var read = stream.read;
	stream.read = function(_, len) {
		var data = read.call(stream, _, len);
		if (data) self.dumpBytes(_, "READ", data);
		return data;
	};
	var write = stream.write;
	stream.write = function(_, data) {
		if (data) self.dumpBytes(_, "WRITE", data);
		write.call(stream, _, data);
	}
}, null, {
	dumpBytes: function(_, action, data) {
		var line = action + "([0x" + data.toString('hex').match(/.{1,2}/g).join(', 0x') + "]);\n";
		require('fs').appendFile(this.dumpFile, line, 'utf8', _);
	},
	dumpJSON: function(_, action, obj) {
		var line = action + "(" + JSON.stringify(obj) + ");\n";
		require('fs').appendFile(this.dumpFile, line, 'utf8', _);
	}
});
