"use strict";
var helpers = require('syracuse-core/lib/helpers');
var nodeconfig = require('syracuse-main/lib/nodeconfig');

var traceProtocol = nodeconfig.config && nodeconfig.config.x3print && nodeconfig.config.x3print.protocol && nodeconfig.config.x3print.protocol.trace;

var ND_SLF = [0x12, 0x0C];
var ND_GFD = [0x12, 0x0B];
var ND_LIM = [0x12, 0x0A];
var ND_GETSTATEREPORT = [0x12, 0x7B];
var ND_GETRESULTREPORT = [0x12, 0x7C];
var ND_DELETEREPORT = [0x12, 0x7F];
var ND_NDOUVIMP = [0x12, 0x01];

var ND_ALLPRINT = [0x42, 0x01];
var ND_MOREPRINT = [0x42, 0x03];
var ND_EXTRAPRINT = [0x42, 0x04];

var ZERO_BYTE = new Buffer([0x00]);
var NODE_ID_LEN = new Buffer([0x00, 0x02]);



 function readIntOnUcs2(buf,offset){
	  return new Buffer([buf[offset],buf[offset+2],buf[offset+4],buf[offset+6]]).readInt32BE(0);
 }


function buildProperties(props) {
	var propsArr = [];
	for (var i in props){
		propsArr.push(i + '=\u0001' + props[i]);
	}
	var r = propsArr.join('\n');
	return r;
}

function writeProperties1(_, stream, propsStr, node){
	var buf;
	if (propsStr.length !== 0) {
		var bufLen = new Buffer(4);
		bufLen.writeInt32BE(propsStr.length, 0);
		buf =  Buffer.concat([new Buffer([0]), bufLen, new Buffer(propsStr, "utf8")]);
	}
	else {
		buf = new Buffer([]);
	}
	//traceProtocol && traceProtocol("Send properties: "+propsStr);
	var nodeId = new Buffer(node);
	var bufEnd = new Buffer(4);
	bufEnd.writeInt32BE(0, 0);
	stream.write(_,  Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId, buf, new Buffer([0]), bufEnd]));	
}

function getProperty(map, data, isProperties2) {
	
	function storeProperty() {
		var keyBuf = new Buffer(key);
		var keyStr = keyBuf.toString('utf8');
		var valueBuf = new Buffer(value);
		var valueStr = valueBuf.toString('utf8');

		map[keyStr] = map[keyStr] || [];
		map[keyStr][idx - 1] = valueStr;
	}
	var idx;
	var key = [];
	var value = [];
	var applyOn = "key";
	var nextIsIdx = false;
	for (var i=0; i < data.length ; i++) {
		var charCode = data[i];
		//console.log("CharAt["+i+"]:["+charCode+"] "+String.fromCharCode(charCode).toString());
		if (!nextIsIdx) {
			// =
			if (data[i] === 61) {
				applyOn = "value";
				try {
					idx = parseInt(data[i+1], 10);
					nextIsIdx = true;
				}catch(e){
					idx=0;
				}
			}
			// \n
			else if (!isProperties2 && data[i] === 10){
				applyOn = "key";
				storeProperty();
				key = []; value = [];
			}
			else {
				if (applyOn === "key")
					key.push(data[i]);
				else if(applyOn === "value") {
					value.push(data[i]);
				}
			}
		}else {
			nextIsIdx = false;
		}
	}
	if (isProperties2 && idx && idx > 0) {
		storeProperty();
	}
	return map;
}

function readProperties1(_, stream) {
	var map = {};
	while (true) {
		console.log("AAAAAAA");

		var head = stream.read(_, 5);

		var len = head.readInt32BE(1);
		console.log("LENGTH: "+len);
		if (len < 0) throw new Error("bad property1 len: " + len);
		if (len === 0) {
			for (var i in map) {
				if (map[i] && Array.isArray(map[i]))
					map[i] = map[i].join('');
			}
			console.log("Properties1: "+JSON.stringify(map,null,2));
			return map;
		}
		map = getProperty(map, stream.read(_, len));
		console.log("MapProp1: "+JSON.stringify(map));
	}
}

function readProperties2(_, stream) {
	var map = {};
	while (true) {
		var len = stream.read(_, 1).readInt8(0);;
		if (len < 0) throw new Error("bad property2 len: " + len);
		if (len === 0) {
			stream.read(_, 4);
			for (var i in map) {
				if (map[i] && Array.isArray(map[i]))
					map[i] = map[i].join('');
			}
			//console.log("Properties2: "+JSON.stringify(map,null,2));
			return map;
		}
		map = getProperty(map, stream.read(_, len), true);
	}
}

var printComm = exports.printComm = helpers.defineClass(function(_, stream) {
	this.stream = stream;
	
	if (nodeconfig.config && nodeconfig.config.x3print && nodeconfig.config.x3print.dump)
		this._spy = new Spy(_, this.stream);
	
	this.technoVers = {
			UIAction: 'SetTechnoVers',
			Version: '100.001',
			Id: '2',
			Protocol: '150067',
	};
	this.srvTechnoVers = null;
}, null, {
	connect: function(_) {
		this.dumpHeader(_, "CONNECT");
		this.stream.write(_, new Buffer([5, 0]));
		var buf = this.stream.read(_, 4);
		var pid = buf.readInt32BE(0);
		traceProtocol && traceProtocol("Connected: "+pid);
		this.srvTechnoVers = this.send_ND_CALLUI(_, this.technoVers);
		traceProtocol && traceProtocol("TechnoVers: "+JSON.stringify(this.srvTechnoVers));
		
		return pid;
	},
	disconnect: function(_) {
		this.dumpHeader(_, "DISCONNECT");
		this.send_ND_CLOSE(_);
	},
	
	/*
	 * Demandes de Type "Report"
	 * 
	 */
	// Exécution d'un rapport
	send_ND_NDOUVIMP: function(_, properties){
		this.dumpHeader(_, "ND_NDOUVIMP", properties);
		// Build request
		var nodeId = new Buffer(ND_NDOUVIMP);
		var buf = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId]);
		
		var bufProps = new Buffer([]);
		for (var i in properties) {
			
			var str = i + '=\u0001' + properties[i];
			var b = new Buffer(str, 'utf8');
			var l = new Buffer([b.length]);
			bufProps = Buffer.concat([bufProps, l, b]);
		}
		var endBuf = new Buffer(4);
		endBuf.writeInt32BE(0, 0);
		this.stream.write(_, Buffer.concat([buf, bufProps, new Buffer([0]), endBuf]));
		
		// Get response
		var seqId = this.stream.read(_, 2).readInt16BE(0);
		return seqId;
	},
	// Arrêt-Suppression d'un job
	send_ND_DELETEREPORT: function(_, seqId){
		this.dumpHeader(_, "ND_DELETEREPORT", {seqId: seqId});
		// Build request
		var nodeId = new Buffer(ND_DELETEREPORT);
		var bufSeq = new Buffer(2);
		bufSeq.writeInt16BE(seqId, 0);
		var buf = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId, new Buffer([2]), bufSeq, ZERO_BYTE]);
		this.stream.write(_, buf);
		// No response
	},

	// Recupération du statut d'un job
	send_ND_GETSTATEREPORT: function(_, jobId){
		this.dumpHeader(_, "ND_GETSTATEREPORT", {jobId: jobId});
		// Build request
		var bufJob = new Buffer(jobId.toString(), "utf8");
		var nodeId = new Buffer(ND_GETSTATEREPORT);
		var buf = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId,  new Buffer([bufJob.length]), bufJob]);
		this.stream.write(_, buf);
		// Get response
		var state = this.stream.read(_, 2).readInt16BE(0);
		var bufMsg = new Buffer([]);
		while (true) {
			var lenBlock = this.stream.read(_, 4).readInt32BE(0);
			if (lenBlock < 0) throw new Error("bad block len: " + len);
			if (lenBlock === 0) break;
			bufMsg = Buffer.concat([bufMsg, this.stream.read(_, lenBlock)]);
		}
		var msg = bufMsg.toString('utf8');
		return {
			state: state,
			message: msg
		};

	},
	// Recuperation du resultat d'un Job
	send_ND_GETRESULTREPORT: function(_, jobId){
		this.dumpHeader(_, "ND_GETRESULTREPORT", {jobId: jobId});
		// Build request
		var bufJob = new Buffer(jobId.toString(), "utf8");
		var nodeId = new Buffer(ND_GETRESULTREPORT);
		var buf = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId,  new Buffer([bufJob.length]), bufJob]);
		this.stream.write(_, buf);
		// Get response
		var lenBin = this.stream.read(_, 4).readInt32BE(0);
		var bufBin = new Buffer([]);
		while (true) {
			var lenBlock = this.stream.read(_, 4).readInt32BE(0);
			if (lenBlock < 0) throw new Error("bad block len: " + len);
			if (lenBlock === 0) break;
			bufBin = Buffer.concat([bufBin, this.stream.read(_, lenBlock)]);
		}
		var bin = bufBin.toString('binary');
		return {
			length: lenBin,
			binary: bin
		};
	},
	// Enumération imprimantes
	send_ND_LISTPRINTER: function(_){
		var p = buildProperties({});
		this.dumpHeader(_, "ND_LISTPRINTER", p);
		writeProperties1(_, this.stream, p, ND_LIM);
		var props = readProperties1(_, this.stream);
		var n = parseInt(props._NbPrinters.charCodeAt(0), 10);
		props._NbPrinters = n;
		console.log("P: "+JSON.stringify(p, null, 2));
		return props;
	},
	// Implementation de l'instruction L4G "Getui"
	send_ND_GETUI: function(_, props){
		var p = buildProperties(props);
		this.dumpHeader(_, "ND_GETUI", p);
		writeProperties1(_, this.stream, p, ND_GFD);
		return readProperties1(_, this.stream);
	},
	// Implementation de l'instruction L4G "Callui"
	send_ND_CALLUI: function(_, props){
		var p = buildProperties(props);
		this.dumpHeader(_, "ND_CALLUI", p);
		writeProperties1(_, this.stream, p, ND_SLF);
		return readProperties1(_, this.stream);
	},
	// Fin de la connexion
	send_ND_CLOSE: function(_){
		this.dumpHeader(_, "ND_CLOSE");
		this.stream.write(_, new Buffer([0x00, 0x00, 0x02, 0x12, 0x63]));
	},
	send_ND_FIN: function(_){
		this.dumpHeader(_, "ND_FIN");
		this.stream.write(_, new Buffer([0x00, 0x00, 0x02, 0x12, 0x02]));
	},
	// NYI
	// Changement du niveau de priorité d'un job
	send_ND_PRIORITYREPORT: function(){
		console.log("ND_PRIORITYREPORT not yet implemented");
	},
	// Interrogation demandes en cours ou en attentes
	send_ND_DISPLAYREPORT: function(){
		console.log("ND_DISPLAYREPORT not yet implemented");
	},

	
	/*
	 * Demandes de Type "Description Imprimantes"
	 * return a structure like 
	 *   {
	 *		 "printName":"\\\\172.28.8.4\\HP3390-grenoblye",		
	 *       "portName":"172.28.8.151",
     *		 "driverName":"HP Universal Printing PCL 5",
	 *		 "comment":"",
	 *		 "location":""
	 *	}
	 * 
	 */
	// Récupération caractéristiques des imprimantes
	send_ND_ALL_PRINTER: function(_){
		this.dumpHeader(_, "ND_ALLPRINT");
		var nodeId = new Buffer(ND_ALLPRINT);
		var buf = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId]);
		this.stream.write(_,buf);
		// read all printer info
		var bufBin = new Buffer([]);
		while (true) {
			var lenBlock = this.stream.read(_, 4).readInt32BE(0);

			if (lenBlock < 0) throw new Error("bad block len: " + len);
			if (lenBlock === 0) break;
			bufBin = Buffer.concat([bufBin, this.stream.read(_, lenBlock)]);
		}
		var result = {
			printer : []
		};
		// analysis of bin flux 
		var offset = 0;
		var readed = 0;
		
		// printName
		var len = bufBin.readInt32BE(offset);
		do{
			if (len>0){
				offset +=4; 
				result.printer.push( bufBin.slice(offset,offset+len).toString('ucs2'));
				offset+=len;
			}
			len = bufBin.readInt32BE(offset);
		console.log(offset);
		console.log(lenBlock);
		}while(offset < lenBlock); 
		return result;
	},
	// params is table contains id printer and options asked 
	send_ND_MORE_PRINTER: function(_, prName, prPort, prDriver){
		this.dumpHeader(_, "ND_MORE_PRINTER",{
			printerName : prName,
			printerPort : prPort,
			driverName : prDriver
		});
		var nodeId = new Buffer(ND_MOREPRINT);
		var header = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId]);
		//write  full buffer len
		var buffLen = new Buffer(4);
		var body = prName+'\n'+prDriver+'\n'+prPort;
		var bufBod = new Buffer(body,"ucs2");
		buffLen.writeInt32BE(bufBod.length,0);
		var buf = Buffer.concat([header,buffLen,bufBod]);

		this.stream.write(_,buf);

		var bufLen = this.stream.read(_, 4);
		var lenBlock = bufLen.readInt32BE(0); // len total
		if (lenBlock < 0) throw new Error("bad block len: " + lenBlock);

		var bufBin = this.stream.read(_, lenBlock);

		
		return this.readOptionPrinter(bufBin);
		
	},
	readOptionPrinter : function(bufBin){
		try{
			var offset = 0;
			var lenPaperSize = readIntOnUcs2(bufBin,offset);
			console.log("len "+lenPaperSize);
			offset+=8
			var valueOff = offset;
			var nbElem = lenPaperSize / 68 ;
			valueOff += nbElem*8;
			var paperSize = [];
			for(var i=0;i<nbElem;i++){
				var tmp = bufBin.slice(valueOff,valueOff+128);
				tmp = Buffer.concat([tmp,new Buffer([0])]);
				paperSize.push({
					id : readIntOnUcs2(bufBin,offset),
					name :  tmp.toString('ucs2')
				});			
				offset+=8;
				valueOff+=128;
			}
			

			bufBin =bufBin.slice(valueOff,bufBin.length);
			offset = 0;
			var lenBackSize = readIntOnUcs2(bufBin,offset);
			offset+=8
			valueOff = offset;
			nbElem = lenBackSize / 28 ;
			valueOff += nbElem*8;
			var back = [];

			for(var i=0;i<nbElem;i++){
				var tmp = bufBin.slice(valueOff,valueOff+48);
				tmp = Buffer.concat([tmp,new Buffer([0])]);
				back.push({
					id : readIntOnUcs2(bufBin,offset),
					name :  tmp.toString('ucs2')
				});			
				offset+=8;
				valueOff+=48;
			}

			return {
				"paperSizeList" : paperSize,
				"backList" : back
			}
		}catch(e){
			console.error(e.stack);
		}

	},
	send_ND_EXTRA_PRINTER: function(_,prName, prPort, prDriver,prPaperSize){
		var nodeId = new Buffer(ND_EXTRAPRINT);
		var header = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId]);
		//write  full buffer len
		var buffull = new Buffer(4);
		var body = prName+'\n'+prDriver+'\n'+prPort+"\n";
		buffull.writeInt32BE(body.length+4,0);
		var buf = Buffer.concat([header,buffull,new Buffer(body,"ucs2"),(new Buffer(4)).writeInt32BE(prPaperSize)]);

		this.stream.write(_,buf);

		var bufBin = new Buffer([]);
		var lenBlock = this.stream.read(_, 4).readInt32BE(0);
		if (lenBlock < 0) throw new Error("bad block len: " + len);

		bufBin = this.stream.read(_, lenBlock);
		
		return this.readOptionPrinter(bufBin);

	},
	send_ND_END_PRINTER: function(_){
		var nodeId = new Buffer(ND_ENDPRINT);
		var buf = Buffer.concat([ZERO_BYTE, NODE_ID_LEN, nodeId]);
		this.stream.write(_,buf);

	},


	dumpHeader: function(_, nodeName, args) {
		this._spy && this._spy.dumpStr(_, "************************************************************");
		this._spy && this._spy.dumpStr(_, "\tSend Node: " + nodeName);
		if (args)
			this._spy && this._spy.dumpStr(_, "\tParams: " + JSON.stringify(args,null,2));
		this._spy && this._spy.dumpStr(_, "************************************************************");

	},
});

var Spy = helpers.defineClass(function(_, stream) {
	var self = this;

	this.dumpFile = __dirname + "/../data/dump_" + (new Date().toISOString()).replace(/\:/g,'-') + ".js";
	require('fs').appendFile(this.dumpFile, '"use strict";\n', 'utf8', _);

	var read = stream.read;
	stream.read = function(_, len) {
		var data = read.call(stream, _, len);
		if (data) self.dumpBytes(_, "READ", data);
		return data;
	};
	var write = stream.write;
	stream.write = function(_, data) {
		write.call(stream, _, data);
		if (data) self.dumpBytes(_, "WRITE", data);
	}
}, null, {
	dumpBytes: function(_, action, data) {
		var line = action + "([0x" + data.toString('hex').match(/.{1,2}/g).join(', 0x') + "]);\n";
		require('fs').appendFile(this.dumpFile, line, 'utf8', _);
	},
	dumpStr: function(_, str) {
		require('fs').appendFile(this.dumpFile, str + "\n", 'utf8', _);
	}
});
