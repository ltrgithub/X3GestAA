"use strict";
var fsp = require("path");
var flows = require('streamline-runtime').flows;
var locale = require('streamline-locale');
var sadFsq = require('syracuse-x3/lib/clients/sadfsq/sadfsqClient');
var SadFsqClient = sadFsq.SadFsqClient;
var config = require('syracuse-main/lib/nodeconfig').config;
var tracerFileService = require('@sage/syracuse-core').getTracer("fileService");

/// !doc
/// 
/// # File service  
/// This module is build on top of the SadFsqClient class and provide an automatic connection and disconnect mechanism.
/// All the methods are asynchronous.
///   
/// ``` javascript  
///		var x3fs = require("syracuse-x3/lib/fileService");
/// ```
/// The first aim of this module is to give a service replacement of the X3 based upload service.
/// The file names provided in the different method support the the standard naming `dir/file.ext` as well as the x3 volume naming `[vol]/dir/file.ext`.
/// Volumes are resolved using the X3 AVOLUME class.
/// ## Security
/// All methods verify the file name path using the following rules:  
///   
/// * `[vol]` is replace by the actual volume dir and if it cannot be resolved `tmp` is assumed
/// * The final path is normalized and if the first part is not equal to the volume dir the operation is rejected
/// 
/// Examples:  
///  
/// * `[TMP]/myfile.txt` is **resolved** as `tmp/myfile.txt`
/// * `[TMP]/../TRT/SUBADC.adx` is **rejected**
/// * `mydata.dat` is **resolved** as `tmp/mydata.dat`
/// * `../TRT/SUBADC.adx` is **rejected**
/// 

var sadfsqPool = (function() {
	var pools = {},
		keepTimeout = 10 * 60 * 1000,
		interval;

	function _ensureCleanupInterval(_) {
		if (interval) return;

		tracerFileService.info && tracerFileService.info("[sadfsqPool] _ensureCleanupInterval");

		interval = flows.setInterval(function(_) {
			var tick = Date.now(),
				free = [],
				keep = [],
				entry;
			tracerFileService.info && tracerFileService.info("[sadfsqPool] interval");
			Object.keys(pools).forEach_(_, function(_, k) {
				pools[k].forEach(function(entry) {
					if (tick - entry.tick > keepTimeout)
						free.push(entry);
					else
						keep.push(entry);
				});
				pools[k] = keep;
				free.forEach_(_, function(_, entry) {
					tracerFileService.info && tracerFileService.info("[sadfsqPool] free " + (entry.client.hostname + ":" + entry.client.port));
					entry.client && entry.client.disconnect(_);
				});
			});
		}, keepTimeout);
	}

	function _release(_, client) {
		var key = client.hostname + ":" + client.port,
			q = pools[key] || (pools[key] = []);

		q.push({
			tick: Date.now(),
			client: client
		});
		tracerFileService.info && tracerFileService.info("[sadfsqPool] release " + key + ", queue.length=" + q.length + ", q[0]=" + (q[0].client.hostname + ":" + q[0].client.hostname) + " tick=" + q[0].tick);

		_ensureCleanupInterval(_);
	}


	return {
		getClient: function(_, endpoint, opts) {
			var x3solution = endpoint.x3solution(_),
				key = x3solution.serverHost(_) + ":" + x3solution.serverPort(_),
				q = pools[key] || (pools[key] = []),
				entry = q[0],
				client;
			if (entry) {
				q = pools[key] = q.slice(1);
				client = entry.client;
				tracerFileService.info && tracerFileService.info("[sadfsqPool] getClient from released queue: " + q.length);

			} else {
				tracerFileService.info && tracerFileService.info("[sadfsqPool] getClient create new client");
				client = new SadFsqClient(_, endpoint, null, null, false);
				if (client.release)
					throw new Error("Function collision: 'release' already exist");
				client.release = function(_) {
					_release(_, this);
				};
			}
			return client;
		},
		release: _release
	};
})();

function SadfsqReadableStream(endpoint, fileOptions, options) {
	this.options = options || {};
	this.position = 0;
	this.endpoint = endpoint;
	this.fileOptions = fileOptions;
}

SadfsqReadableStream.prototype = {
	read: function(_, len) {
		if (this.endpoint.protocol(_) !== "x3")
			throw new Error("Bad endpoint protocol");
		var client = this.client;

		if (!this.fd) {
			client = this.client || (this.client = sadfsqPool.getClient(_, this.endpoint, this.options));
			var fullname = this.fileOptions.path + "/" + this.fileOptions.name + "." + this.fileOptions.extension;
			// get full size of the file 
			this.size(_);
			tracerFileService.info && tracerFileService.info("[SadfsqReadableStream] start reading " + fullname + " to " + client.hostname + ":" + client.port);
			this.fd = client.open(_, this.fileOptions, "r");
		}
		var buffer = null,
			readLen = 0;
		if (this.position < this._size) {
			buffer = new Buffer(len);
			readLen = client.read(_, this.fd, buffer, 0, len);
			tracerFileService.info && tracerFileService.info("[SadfsqReadableStream] read: [" + this.position + ":" + len + "] " + Math.round(this.position * 100 / this._size) + "%");
		}
		if (readLen === 0) {
			this.fd && client.close(_, this.fd);
			client.release && client.release(_);
			tracerFileService.info && tracerFileService.info("[SadfsqReadableStream] final read: length=" + this.position);
			return null;
		}
		this.position += readLen;
		return buffer && buffer.slice(0, readLen);
	},
	size: function(_) {
		var client;
		if (!this._size) {
			client = this.client || (this.client = sadfsqPool.getClient(_, this.endpoint, this.options));
			this._size = client.stat(_, this.fileOptions, ["size"]).size;
		}
		tracerFileService.info && tracerFileService.info("[SadfsqReadableStream] file size: " + this._size);
		return this._size;
	}
};

function SadfsqWritableStream(endpoint, fileOptions, options) {
	this.options = options || {};
	this.position = 0;
	this.endpoint = endpoint;
	this.fileOptions = fileOptions;
	tracerFileService.info && tracerFileService.info("[SadfsqWritableStream] new instance name=" + (this.fileOptions.path + "/" + this.fileOptions.name + "." + this.fileOptions.extension));
}

SadfsqWritableStream.prototype = {
	write: function(_, data, enc) {

		tracerFileService.info && tracerFileService.info("[SadfsqWritableStream] receive data len=" + (data && data.length));
		if (this.endpoint.protocol(_) !== "x3")
			throw new Error("Bad endpoint protocol");
		if (!this.fd) {
			this.client = sadfsqPool.getClient(_, this.endpoint, this.options);
			var fullname = this.fileOptions.path + "/" + this.fileOptions.name + "." + this.fileOptions.extension;
			tracerFileService.info && tracerFileService.info("[SadfsqWritableStream] start writing to name=" + fullname + " on " + this.client.hostname + ":" + this.client.port);
			this.fd = this.client.open(_, this.fileOptions, "w");
		}
		if (data == null) {
			tracerFileService.info && tracerFileService.info("[SadfsqWritableStream] final write fd=" + this.fd + ", length=" + this.position);
			this.fd && this.client.close(_, this.fd);
			this.client.release && this.client.release(_);
		} else {
			var buffer = data instanceof Buffer ? data : new Buffer(data, this.options.encoding || "utf8");
			tracerFileService.info && tracerFileService.info("[SadfsqWritableStream] write fd=" + this.fd + ", enc=" + enc + " [" + this.position + ":" + data.length + "]");
			try {
				this.client.write(_, this.fd, buffer, 0, buffer.length, null, this.options.lock);
				this.position += buffer.length;
			} catch (e) {
				tracerFileService.info && tracerFileService.info("EXCEPTION: " + e.message + "\nat" + e.stack);
				// do not reuse it
				this.client && this.client.disconnect(_);
				throw e;
			}
		}
	},
	end: function() {
		tracerFileService.info && tracerFileService.info("[SadfsqWritableStream] end");
	}
};

/// ## Module level functions  
/// 

/// -------------
/// ### createDownloadStream :  
/// ``` javascript  
///		var x3fs = require("syracuse-x3/lib/fileService");
/// 	var stream = x3fs.createDownloadStream(_, endpoint, path, [options]);
/// ```
/// Return a readable stream for downloading file.  
/// This function use an internal pool that release the client at the end of streaming. 
//  The underneath client can be reused later or disconnected by the pool manager if the timeout is reached.
/// 
/// * `endpoint` the endpoint that while receive the file  
/// * `path` the remote file path  
/// * `options` is an `object` that could contains:  
///     * encoding : `String | null` default = `utf-8`.  
/// 
/// The `encoding` option is ignored if `data` is a buffer. It defaults to 'utf8'.  
/// 
/// The is automatically released at the end of streaming. The underlying client connection can be reused after that.  
/// 
exports.createDownloadStream = function(_, endpoint, path, opts) {
	var fileOptions = _getFileOptions(_, endpoint, path);
	var stream = _createReadableStream(_, endpoint, fileOptions, opts || {});
	return stream && stream.size(_) <= 0 ? null : stream;
};

/// -------------
/// ### createUploadStream :  
/// ``` javascript  
///		var x3fs = require("syracuse-x3/lib/fileService");
/// 	var stream = x3fs.createUploadStream(_, endpoint, path, [options]);
/// ```
/// Return a writable stream for uploading file.  
/// This function use an internal pool that release the client at the end of streaming. 
//  The underneath client can be reused later or disconnected by the pool manager if the timeout is reached.
/// 
/// * `endpoint` the endpoint that while receive the file  
/// * `path` the remote file path  
/// * `options` is an `object` that could contains:  
///     * encoding : `String | null` default = `utf-8`.  
/// 
/// The `encoding` option is ignored if `data` is a buffer. It defaults to 'utf8'.  
/// 
/// The is automatically released at the end of streaming. The underlying client connection can be reused after that.  
/// 
exports.createUploadStream = function(_, endpoint, path, opts) {
	var fileOptions = _getFileOptions(_, endpoint, path);
	return _createWritableStream(_, endpoint, fileOptions, opts || {});
};

/// 
/// -------------
/// ### deleteFile :  
/// ``` javascript  
///		var x3fs = require("syracuse-x3/lib/fileService");
/// 	var stream = x3fs.deleteFile(_, endpoint, path, [options]);
/// ```
/// Delete the given file.  
/// This function use an internal pool that release the client at the end of streaming. 
//  The client can be reuse later or disconnect by the pool manager if the timeout is reached.
/// 
/// * `endpoint` the endpoint that host the file  
/// * `path` the remote file path  
/// 
/// The `encoding` option is ignored if `data` is a buffer. It defaults to 'utf8'.  
/// 
/// The is automatically released at the end of streaming. The underlying client connection can be reused after that.  
/// 
exports.deleteFile = function(_, endpoint, path, opts) {
	var client;
	try {
		var fileOptions = _getFileOptions(_, endpoint, path);
		client = sadfsqPool.getClient(_, endpoint, opts);
		client.unlink(_, fileOptions);
	} finally {
		client && client.release(_);
	}
};


function _createReadableStream(_, endpoint, fileOptions, options) {
	return new SadfsqReadableStream(endpoint, fileOptions, options);
}

function _createWritableStream(_, endpoint, fileOptions, options) {
	return new SadfsqWritableStream(endpoint, fileOptions, options);
}

function _getFileOptions(_, endpoint, path) {
	if (endpoint.protocol(_) !== "x3")
		throw new Error("Bad endpoint protocol");

	if (!path)
		throw new Error("No filename");

	tracerFileService.info && tracerFileService.info("_getFileOptions: path='" + path + "'");
	path = path.replace(/^'([^']+)'$/, "$1");

	// Does it match an X3 volume: [VOL]/dir/file.ext
	var root, m = /^(\[(.*)\])(.*)$/.exec(path);
	tracerFileService.info && tracerFileService.info("    path='" + path + "', m=" + m);

	if (m) {
		var db = endpoint.getOrm(_),
			entity = db && db.getEntity(_, 'AVOLUME', "$details"),
			vpath = entity && db.fetchInstance(_, entity, m[2]);
		root = vpath && vpath.ROOT && vpath.ROOT(_);
		path = m[3];
		tracerFileService.info && tracerFileService.info("    volume='" + m[2] + "', root='" + root + "'");
	}
	return exports.resolveFileDesc(endpoint.x3ServerFolder(_), root, path);
}

exports.resolveFileDesc = function(folder, root, path) {
	tracerFileService.info && tracerFileService.info("initial path='" + path + "', root='" + root + "'");
	if (!path)
		throw new Error("Bad filename");
	root = (root || "tmp").replace(/\\/g, "/");
	path = path.replace(/\\/g, "/").replace(/^\/+/, "");

	path = fsp.normalize(path).replace(/\\/g, "/");
	// Verify that we did not try to change the root by using '..' notation
	tracerFileService.info && tracerFileService.info("modified path='" + path + "', root='" + root + "'");

	if (path.indexOf("../") === 0)
		throw new Error("Bad filename");

	var ext = fsp.extname(path),
		opt = {
			folder: folder,
			path: root,
			name: ext ? path.slice(0, -ext.length) : path,
			extension: ext.substring(1)
		};
	tracerFileService.info && tracerFileService.info("  => '" + path + "'\n    " + JSON.stringify(opt));
	return opt;
};