"use strict";
var fsp = require("path");
var flows = require('streamline/lib/util/flows');
var locale = require("syracuse-core/lib/locale");
var sadFsq = require('syracuse-x3/lib/clients/sadfsq/sadfsqClient');
var SadFsqClient = sadFsq.SadFsqClient;
var tracer; // = console.log;

/// !doc
/// 
/// # File service  
/// This module is build on top of the SadFsqClient class and provide an automatic connection and disconnect mechanism.
/// All the methods are asynchronous.
///   
/// ``` javascript  
///		var x3fs = require("syracuse-x3/lib/fileService");
/// ```
/// The first aim of this module is to give a service replacement of the X3 based upload service.
/// The file names provided in the different method support the the standard naming `dir/file.ext` as well as the x3 volume naming `[vol]/dir/file.ext`.
/// Volumes are resolved using the X3 AVOLUME class.
/// ## Security
/// All methods verify the file name path using the following rules:  
///   
/// * `[vol]` is replace by the actual volume dir and if it cannot be resolved `tmp` is assumed
/// * The final path is normalized and if the first part is not equal to the volume dir the operation is rejected
/// 
/// Examples:  
///  
/// * `[TMP]/myfile.txt` is **resolved** as `tmp/myfile.txt`
/// * `[TMP]/../TRT/SUBADC.adx` is **rejected**
/// * `mydata.dat` is **resolved** as `tmp/mydata.dat`
/// * `../TRT/SUBADC.adx` is **rejected**
/// 

var sadfsqPool = (function() {
	var pools = {}, keepTimeout = 10 * 60 * 1000,
		interval;

	function _ensureCleanupInterval(_) {
		if (interval) return;

		tracer && tracer("[sadfsqPool] _ensureCleanupInterval");

		interval = flows.setInterval(function(_) {
			var tick = Date.now(),
				free = [],
				keep = [],
				entry;
			tracer && tracer("[sadfsqPool] interval");
			Object.keys(pools).forEach_(_, function(_, k) {
				pools[k].forEach(function(entry) {
					if (tick - entry.tick > keepTimeout)
						free.push(entry);
					else
						keep.push(entry);
				});
				pools[k] = keep;
				free.forEach_(_, function(_, entry) {
					tracer && tracer("[sadfsqPool] free " + (entry.client.hostname + ":" + entry.client.port));
					entry.client && entry.client.disconnect(_);
				});
			});
		}, keepTimeout);
	}

	function _release(_, client) {
		var key = client.hostname + ":" + client.port,
			q = pools[key] || (pools[key] = []);

		q.push({
			tick: Date.now(),
			client: client
		});
		tracer && tracer("[sadfsqPool] release " + key + ", queue.length=" + q.length + ", q[0]=" + (q[0].client.hostname + ":" + q[0].client.hostname) + " tick=" + q[0].tick);

		_ensureCleanupInterval(_);
	}


	return {
		getClient: function(_, endpoint) {
			var x3server = endpoint.x3server(_),
				key = x3server.serverHost(_) + ":" + x3server.serverPort(_),
				q = pools[key] || (pools[key] = []),
				entry = q[0],
				client;
			if (entry) {
				q = pools[key] = q.slice(1);
				client = entry.client;
				tracer && tracer("[sadfsqPool] getClient from released queue: " + q.length);

			} else {
				tracer && tracer("[sadfsqPool] getClient create new client: " + q.length);
				client = new SadFsqClient(_, x3server.serverHost(_), x3server.serverPort(_));
				if (client.release)
					throw new Error("Function collision: 'release' already exist");
				client.release = function(_) {
					_release(_, this);
				};
			}
			return client;
		},
		release: _release
	};
})();

function ReadableMemoryStream(data, enc) {
	this.position = 0;
	this.buffer = new Buffer(data, enc);
	this.encoding = enc;
}

ReadableMemoryStream.prototype = {
	read: function(_, len) {
		var end = (len ? (len + this.position) : this.buffer.length);
		if (this.position >= this.buffer.length) return null;
		var buf = this.buffer.toString(this.encoding, this.position, end);
		this.position = end;
		return buf;
	}
};

function SadfsqReadableStream(endpoint, fileOptions, options) {
	this.options = options || {};
	this.position = 0;
	this.endpoint = endpoint;
	this.fileOptions = fileOptions;
}

SadfsqReadableStream.prototype = {
	read: function(_, len) {
		if (this.endpoint.protocol(_) !== "x3")
			throw new Error("Bad endpoint protocol");
		var client = this.client;

		if (!this.fd) {
			client = this.client || (this.client = sadfsqPool.getClient(_, this.endpoint));
			var fullname = this.fileOptions.path + "/" + this.fileOptions.name + "." + this.fileOptions.extension;
			// get full size of the file 
			this.size(_);
			tracer && tracer("[SadfsqReadableStream] start reading " + fullname + " to " + client.hostname + ":" + client.port);
			this.fd = client.open(_, this.fileOptions, "r");
		}
		var buffer = null,
			readLen = 0;
		if (this.position < this._size) {
			buffer = new Buffer(len);
			readLen = client.read(_, this.fd, buffer, 0, len);
			tracer && tracer("[SadfsqReadableStream] read: [" + this.position + ":" + len + "] " + Math.round(this.position * 100 / this._size) + "%");
		}
		if (readLen === 0) {
			this.fd && client.close(_, this.fd);
			client.release && client.release(_);
			tracer && tracer("[SadfsqReadableStream] final read: length=" + this.position);
			return null;
		}
		this.position += readLen;
		return buffer && buffer.slice(0, readLen);
	},
	size: function(_) {
		var client;
		if (!this._size) {
			client = this.client || (this.client = sadfsqPool.getClient(_, this.endpoint));
			this._size = client.stat(_, this.fileOptions, ["size"]).size;
		}
		tracer && tracer("[SadfsqReadableStream] file size: " + this._size);
		return this._size;
	}
};

function SadfsqWritableStream(endpoint, fileOptions, options) {
	this.options = options || {};
	this.position = 0;
	this.endpoint = endpoint;
	this.fileOptions = fileOptions;
}

SadfsqWritableStream.prototype = {
	write: function(_, data, enc) {
		if (this.endpoint.protocol(_) !== "x3")
			throw new Error("Bad endpoint protocol");
		if (!this.fd) {
			this.client = sadfsqPool.getClient(_, this.endpoint);
			var fullname = this.fileOptions.path + "/" + this.fileOptions.name + "." + this.fileOptions.extension;
			tracer && tracer("[SadfsqWritableStream] start writing " + fullname + " to " + this.client.hostname + ":" + this.client.port);
			this.fd = this.client.open(_, this.fileOptions, "w");
		}
		if (data == null) {
			this.fd && this.client.close(_, this.fd);
			this.client.release && this.client.release(_);
			tracer && tracer("[SadfsqWritableStream] final write: length=" + this.position);
		} else {
			var buffer = data instanceof Buffer ? data : new Buffer(data, this.options.encoding || "utf8");
			this.client.write(_, this.fd, buffer, 0, buffer.length, this.position, this.options.lock);
			tracer && tracer("[SadfsqWritableStream] write: " + enc + " [" + this.position + ":" + data.length + "]");
			this.position += buffer.length;
		}
	},
	end: function() {
		tracer && tracer("[SadfsqWritableStream] end");
	}
};

/// ## Module level functions  
/// 

/// -------------
/// ### createDownloadStream :  
/// ``` javascript  
///		var x3fs = require("syracuse-x3/lib/fileService");
/// 	var stream = x3fs.createDownloadStream(_, endpoint, path, [options]);
/// ```
/// Return a readable stream for downloading file.  
/// This function use an internal pool that release the client at the end of streaming. 
//  The underneath client can be reused later or disconnected by the pool manager if the timeout is reached.
/// 
/// * `endpoint` the endpoint that while receive the file  
/// * `path` the remote file path  
/// * `options` is an `object` that could contains:  
///     * encoding : `String | null` default = `utf-8`.  
/// 
/// The `encoding` option is ignored if `data` is a buffer. It defaults to 'utf8'.  
/// 
/// The is automatically released at the end of streaming. The underlying client connection can be reused after that.  
/// 
exports.createDownloadStream = function(_, endpoint, path, opts) {
	var fileOptions = _getFileOptions(_, endpoint, path);
	var stream = _createReadableStream(_, endpoint, fileOptions, opts || {});
	return stream && stream.size(_) <= 0 ? null : stream;
};

/// -------------
/// ### createUploadStream :  
/// ``` javascript  
///		var x3fs = require("syracuse-x3/lib/fileService");
/// 	var stream = x3fs.createUploadStream(_, endpoint, path, [options]);
/// ```
/// Return a writable stream for uploading file.  
/// This function use an internal pool that release the client at the end of streaming. 
//  The underneath client can be reused later or disconnected by the pool manager if the timeout is reached.
/// 
/// * `endpoint` the endpoint that while receive the file  
/// * `path` the remote file path  
/// * `options` is an `object` that could contains:  
///     * encoding : `String | null` default = `utf-8`.  
/// 
/// The `encoding` option is ignored if `data` is a buffer. It defaults to 'utf8'.  
/// 
/// The is automatically released at the end of streaming. The underlying client connection can be reused after that.  
/// 
exports.createUploadStream = function(_, endpoint, path, opts) {
	var fileOptions = _getFileOptions(_, endpoint, path);
	return _createWritableStream(_, endpoint, fileOptions, opts || {});
};

/// 
/// -------------
/// ### deleteFile :  
/// ``` javascript  
///		var x3fs = require("syracuse-x3/lib/fileService");
/// 	var stream = x3fs.deleteFile(_, endpoint, path, [options]);
/// ```
/// Delete the given file.  
/// This function use an internal pool that release the client at the end of streaming. 
//  The client can be reuse later or disconnect by the pool manager if the timeout is reached.
/// 
/// * `endpoint` the endpoint that host the file  
/// * `path` the remote file path  
/// 
/// The `encoding` option is ignored if `data` is a buffer. It defaults to 'utf8'.  
/// 
/// The is automatically released at the end of streaming. The underlying client connection can be reused after that.  
/// 
exports.deleteFile = function(_, endpoint, path) {
	try {
		var fileOptions = _getFileOptions(_, endpoint, path);
		var client = sadfsqPool.getClient(_, endpoint);
		client.unlink(_, fileOptions);
	} finally {
		client && client.release(_);
	}
};


function _createReadableStream(_, endpoint, fileOptions, options) {
	return new SadfsqReadableStream(endpoint, fileOptions, options);
}

function _createWritableStream(_, endpoint, fileOptions, options) {
	return new SadfsqWritableStream(endpoint, fileOptions, options);
}

function _getFileOptions(_, endpoint, path) {
	if (endpoint.protocol(_) !== "x3")
		throw new Error("Bad endpoint protocol");

	if (!path)
		throw new Error("No filename");

	tracer && tracer("_getFileOptions: path=" + path);
	path = path.replace(/^'([^']+)'$/, "$1");

	// Does it match an X3 volume: [VOL]/dir/file.ext
	var root, m = /^(\[(.*)\])(.*)$/.exec(path);
	tracer && tracer("    path=" + path + ", m=" + m);

	if (m) {
		var db = endpoint.getOrm(_),
			entity = db && db.getEntity(_, 'AVOLUME', "$details"),
			vpath = entity && db.fetchInstance(_, entity, m[2]);
		root = vpath && vpath.ROOT && vpath.ROOT(_);
		path = m[3];
		tracer && tracer("    volume=" + m[2] + ", root=" + root);
	}
	root = root || "tmp";
	path = fsp.normalize(fsp.join(root, path)).replace(/\\/g, "/");
	// Verify that we did not try to change the root by using '..' notation
	if (path.split(/[\\\/]/)[0] != root)
		throw new Error("Bad filename");

	var ext = fsp.extname(path),
		opt = {
			folder: endpoint.x3ServerFolder(_),
			path: fsp.dirname(path),
			name: fsp.basename(path, ext),
			extension: ext.substring(1)
		};
	tracer && tracer("  => " + path + "\n    " + JSON.stringify(opt));
	return opt;
}