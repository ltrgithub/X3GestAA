"use strict";
var _listReuse = {};
var flows = require('streamline-runtime').flows;

var funnelReuse = flows.funnel(1);
var tracerSession = require("syracuse-trace/lib/helper").getTracer("classic.session");

exports.getClient = function(_, context, cliCfg) {
	var reuseClient = null;
	funnelReuse(_, function(_) {
		_listReuse[context.httpSession.id] = _listReuse[context.httpSession.id] || [];
		tracerSession.info && tracerSession.info("Create session [Nb reuse: " + _listReuse[context.httpSession.id].length + "]");

		if (_listReuse[context.httpSession.id] && _listReuse[context.httpSession.id].length !== 0) {
			var i = 0;
			tracerSession.info && tracerSession.info("Search reuse...");
			for (i = 0; i < _listReuse[context.httpSession.id].length && reuseClient == null; i++) {
				reuseClient = _listReuse[context.httpSession.id][i].isSameContext(cliCfg) ? reuseClient = _listReuse[context.httpSession.id][i] : reuseClient = null;
			}
			if (reuseClient) {
				_listReuse[context.httpSession.id].splice(i - 1, 1);
			}
		}
	});

	return reuseClient;
};

exports.closeReuseSession = function(_, syraid) {
	funnelReuse(_, function(_) {
		_listReuse[syraid] && _listReuse[syraid].forEach_(_, function(_, cvgClient) {
			console.log("close client identified by pid=" + cvgClient.clientConfig.getParam("x3Pid") + " session id " + syraid);
			cvgClient.sessionInfo.deleteSelf(_, {
				ignoreRestrictions: true
			});
			delete cvgClient.sessionInfo;
			cvgClient.disconnectClient(_, {}, "closed by administrator");
		});
		if (_listReuse[syraid])
			delete _listReuse[syraid];
	});
};
// Info property mame are the name of cvgReuseClient and cvgSession entity  properties

exports.cvgAdmAddCliInfo = function(cli, info) {
	var cfg = cli && cli.clientConfig || {};
	info.cid = cli.uuid;
	info.x3host = cfg.getParam("x3Host");
	info.x3port = "" + cfg.getParam("x3Port");
	info.x3solution = cfg.getParam("x3Solution");
	info.x3folder = cfg.getParam("x3Folder");
	info.x3pid = "" + cfg.getParam("x3Pid");
	info.x3user = cfg.getParam("x3User");
	info.x3lang = cfg.getParam("x3Lang");
	info.open = cli.stream != null;
	return info;
};
exports.cvgAdmReuseClients = function(_, id) {
	var i, res = [];
	for (var ii = 0; ii < Object.keys(_listReuse).length; ii++) {
		var key = Object.keys(_listReuse)[ii];
		for (i = 0; i < _listReuse[key].length; i++) {
			var cli = _listReuse[key][i];
			if (id && cli.uuid != id) {
				continue;
			}
			// Info property mame is the name of cvgReuseClient entity  property
			var cfg = cli.clientConfig;
			var info = {
				timeout: "" + Math.floor((new Date().getTime() - cli.timeToReuse) / 1000) + "/" + Math.floor(cfg.getParam("timeoutReuse") / 1000),
				creationDate: cli.creationDate
			};
			exports.cvgAdmAddCliInfo(cli, info);
			res.push(info);
			if (id) {
				break;
			}
		}
	}
	return res;
};

exports.cvgAdmReuseKill = function(_, cid) {
	var cli = null;
	var i, j;
	funnelReuse(_, function(_) {
		tracerSession.info && tracerSession.info("cvgAdmReuseKill - nbReused:" + _listReuse.length + " - id:" + cid);
		for (i = 0; i < Object.keys(_listReuse).length && cli == null; i++) {
			var key = Object.keys(_listReuse)[i];
			for (j = 0; j < _listReuse[key].length && cli == null; j++) {

				if (_listReuse[key][j].uuid === cid) {
					cli = _listReuse[key][j];
				}
			}
			if (cli) {
				_listReuse[key].splice(i - 1, 1);
				tracerSession.info && tracerSession.info("\treused client found - nbReused:" + _listReuse.length);
				cli.sessionInfo.deleteSelf(_, {
					ignoreRestrictions: true
				});
				delete cli.sessionInfo;
				cli.disconnectClient(_, {}, "closed by administrator");
			} else {
				tracerSession.info && tracerSession.info("\treused client not found");
			}
		}
	});
	return cli != null;
};
exports.addReuse = function(_, cvgClient, sessionInfo, syraid, reason) {
	funnelReuse(_, function(_) {
		// store CvgClient in reuse list
		cvgClient.setInReuseMode(_, true);

		cvgClient.sessionInfo = sessionInfo; // save sessionInfo
		_listReuse[syraid] = _listReuse[syraid] || [];
		_listReuse[syraid].push(cvgClient);
		tracerSession.info && tracerSession.info("Add reuse session [size: " + _listReuse[syraid].length + "] - id=" + cvgClient.uuid + " - reason=" + reason);
	});
};

exports.destroyReuseClient = function(_, cvgClient, syraid) {
	var found = false;
	var i;
	funnelReuse(_, function(_) {
		tracerSession.info && tracerSession.info("destroyReuseClient - nbReused:" + _listReuse[syraid].length + " - id:" + cvgClient.uuid);
		for (i = 0; i < _listReuse[syraid].length && !found; i++) {
			found = _listReuse[syraid][i].uuid === cvgClient.uuid;
		}
		if (found) {
			_listReuse[syraid].splice(i - 1, 1);
			tracerSession.info && tracerSession.info("\treused client found - nbReused:" + _listReuse[syraid].length);

			if (_listReuse[syraid].length === 0)
				delete _listReuse[syraid];
			// FDB - disconnected only if found ??
			cvgClient.sessionInfo.deleteSelf(_, {
				ignoreRestrictions: true
			});
			tracerSession.info && tracerSession.info("delete sessionInfo: " + cvgClient.sessionInfo.sid(_));
			cvgClient.disconnectClient(_, {}, "timeout reuse");
		} else {
			tracerSession.info && tracerSession.info("\treused client not found");
		}
	});
};