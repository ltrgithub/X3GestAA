"use strict";

var crypto = require('crypto');
var util = require('util');
var sys = util;
var fs = require('streamline-fs');
var fsp = require("path");
var dateUtil = require('syracuse-core/lib/types/datetime');
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var helpers = require("syracuse-core/lib/helpers");
var locale = require("syracuse-core/lib/locale");

exports.config=function(path, config, def){
	if (path==null) return null;
	if (!util.isArray(path)) path=path.toString().split(/[\s-._/\\]/);
	var n=config || nodeconfig.config || {};
	for (var i=0;i<path.length;i++){
		n=n[path[i]];
		if (n==null) return def;
	}
	return n;
}

exports.getSignature = function(_, challenge, userName) {
	var toSign = new Buffer(userName + "\0" + challenge, "utf8");
	var signer = crypto.createSign(nodeconfig.config.sdata.signAlgorithm);
	signer.update(toSign);
	return signer.sign(fs.readFile(fsp.join(__dirname, "../key.pem"), "ascii", _), "base64");
}
	
exports.dateFormatToX3Format = function(dateFormat) {
	if(!dateFormat) return "";
	var fullDayPos = -1;
	var shortDayPos = -1;
	var result = ["D:"];
	//
	dateUtil.walkFormat(dateFormat, {
		literal: function(literal) { result.push("[" + literal + "]"); },
		d: function(repeat) {
			if(repeat > 2)
				fullDayPos = result.length;
			else
				shortDayPos = result.length;
			result.push("DD");
		},
		M: function(repeat) {
			switch(repeat) {
				case 1:
				case 2:
					result.push("MM");
					break;
				case 3:
					result.push("MMM");
					break;
				case 4:
					result.push("MMMMMMMMMM");
					break;
			}
		},
		y: function(repeat) {
			switch(repeat) {
				case 2:
					result.push("YY");
					break;
				case 4:
					result.push("YYYY");
					break;
			}
		},
		h: function(repeat) {
			result.push("hh");
		},
		H: function(repeat) {
			result.push("hh");
		},
		m: function(repeat) {
			result.push("mm");
		},
		s: function(repeat) {
			result.push("ss");
		},
		t: function(repeat) {
			
		}
	});
	// X3 doesn't support full day name so if there is a short date name, delete full date name
	if((shortDayPos >= 0) && (fullDayPos >= 0)) {
		result.splice(fullDayPos, 1);
		// don't start with " ", ",", "." ?
		while(["[ ]", "[,]", "[.]"].indexOf(result[1]) >= 0)
			result.splice(1, 1);
	}
	//
	return result.join("");
}
// Add x3 SDate IDate SThousand STime SDecimal parameters
exports.addLocaleConfig = function(_, cliCfg, userProfile) {
	var selLocale = userProfile && userProfile.selectedLocale(_);
	var x3DateOrder = null, dateSep = null;
	if(selLocale && selLocale.shortDate(_)){
		// We need to parse dateFormat to extract dateSep and dateOrder
		var dateOrder=[];
		dateUtil.walkFormat(selLocale.shortDate(_), {
			// We assume that first literal is the date separator
			literal: function(literal) { if (dateSep==null) dateSep = literal; },
			d: function(repeat) {
				if (dateOrder.indexOf('d')==-1) dateOrder.push('d');
			},
			M: function(repeat) {
				if (dateOrder.indexOf('m')==-1) dateOrder.push('m');
			},
			y: function(repeat) {
				if (dateOrder.indexOf('y')==-1) dateOrder.push('y');
			}
		});
		if(dateOrder.length>0){
			// 0	Month-Day-Year - 1	Day-Month-Year - 2	Year-Month-Day
			switch (dateOrder[0].toLowerCase()){
				case  'd':
					x3DateOrder = "1";
				break;
				case  'm' :
					x3DateOrder = "0";
				break;
				case  'y' :
					x3DateOrder = "2";
				break;
			}
		}	
	}	
	var cliCfg =  cliCfg || {};
	// Date
	cliCfg.SDate = dateSep && dateSep.length > 0 ? dateSep : "/";
	cliCfg.IDate = x3DateOrder && x3DateOrder.length > 0  ? x3DateOrder : "0";
	// thousandsSep
	var sep =  selLocale ? selLocale.numberGroupSeparator(_) : null;
	cliCfg.SThousand = sep && sep.length > 0   ? sep : " ";
	// timeSep
	sep =  selLocale ? exports.getTimeSep(selLocale.shortTime(_)) : null;
	cliCfg.STime = sep  && sep.length > 0  ? sep : ":";
	// decimalSep
	sep = selLocale ? selLocale.numberDecimalSeparator(_) : null;
	cliCfg.SDecimal = sep  && sep.length > 0   ? sep : ".";
	return cliCfg;
}

exports.getTimeSep = function(timeFormat) {
	var timeSep=null, dummy=function(){};
	if(timeFormat){
		dateUtil.walkFormat(timeFormat, {
			// We assume that first literal is the date separator
			literal: function(literal) { if (timeSep==null) timeSep = literal; },
			H:dummy,
            h:dummy,
            m:dummy,
            s:dummy,
            t:dummy
		});
	}
	// X3 client don't need date format - only dateOrder and dateSep
	return timeSep==null?':':timeSep;
}
// Remove node.js root directory from files path in error stack trace
exports.errShortPath=function(msg){
	if (!msg) return msg;
	msg=msg.replace(/\\/g, '/');
	var root=process.cwd().replace(/\\/g, '/') + '/node_modules/';
	return msg.split(root).join('')
}
function fusionError(userMsg, cause, statusCode) {	
    this.cause = cause;
    this.message = userMsg || "No user message";
	this.statusCode=statusCode==undefined?500:statusCode;
}
exports.Error=helpers.defineClass(fusionError, Error, {
	toJson: function(filter) {
		if (!filter) filter=function(str){return str;};
		var res={
			msgDefault:filter(this.message)
		};
		var diags=[];
		var kause=this.cause;
		while(kause){
			diags.push({
				message: filter(exports.errShortPath((kause.stack?kause.stack:kause.toString())))
			});
			kause=kause.cause && kause.cause!=kause?kause.cause:null;
		}
		if (diags.length>0) res.diagnoses=diags;
		return res;
	},
	toString: function(){
		// convert string with \n to arrays to get beter display in console and log files
		var res=this.toJSON(function(str){
			if (!str || str.indexOf('\n')==-1) return str;
			return str.split('\n');
		});
		return JSON.stringify(res,null,"  ");
	}
})

	


