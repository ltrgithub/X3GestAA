"use strict";

var crypto = require('crypto');
var util = require('util');
var sys = util;
var fs = require('streamline-fs');
var fsp = require("path");
var dateUtil = require('@sage/syracuse-core').types.datetime;
var config = require('config');
var helpers = require('@sage/syracuse-core').helpers;
var locale = require('streamline-locale');

exports.config = function(path, cfg, def) {
	if (path == null) {
		return null;
	}
	if (!util.isArray(path)) {
		path = path.toString().split(/[\s-._/\\]/);
	}
	var i, n = cfg || config || {};
	for (i = 0; i < path.length; i++) {
		n = n[path[i]];
		if (n == null) {
			return def;
		}
	}
	return n;
};

exports.getSignature = function(_, challenge, userName, certificate) {
	var toSign = new Buffer(userName + "\0" + challenge, "utf8");
	var result;
	if (certificate) {
		result = certificate.sign(_, config.sdata.signAlgorithm, toSign, {
			"output_encoding": "base64"
		});
		return result;
	} else {
		if (config.x3key) {
			result = require('syracuse-load/lib/certTools').sign(_, null, config.sdata.signAlgorithm, toSign, {
				"output_encoding": "base64"
			});
		} else {
			var signer = crypto.createSign(config.sdata.signAlgorithm);
			signer.update(toSign);
			result = signer.sign(fs.readFile(fsp.join(__dirname, "../key.pem"), "ascii", _), "base64");
		}
		return result;
	}
};

exports.dateFormatToX3Format = function(dateFormat) {
	if (!dateFormat) {
		return "";
	}
	var fullDayPos = -1;
	var shortDayPos = -1;
	var result = ["D:"];
	//
	dateUtil.walkFormat(dateFormat, {
		literal: function(literal) {
			result.push("[" + literal + "]");
		},
		d: function(repeat) {
			if (repeat > 2) {
				fullDayPos = result.length;
			} else {
				shortDayPos = result.length;
			}
			result.push("DD");
		},
		M: function(repeat) {
			switch (repeat) {
				case 1:
				case 2:
					result.push("MM");
					break;
				case 3:
					result.push("MMM");
					break;
				case 4:
					result.push("MMMMMMMMMM");
					break;
			}
		},
		y: function(repeat) {
			switch (repeat) {
				case 2:
					result.push("YY");
					break;
				case 4:
					result.push("YYYY");
					break;
			}
		},
		h: function(repeat) {
			result.push("hh");
		},
		H: function(repeat) {
			result.push("hh");
		},
		m: function(repeat) {
			result.push("mm");
		},
		s: function(repeat) {
			result.push("ss");
		},
		t: function(repeat) {

		}
	});
	// X3 doesn't support full day name so if there is a short date name, delete full date name
	if ((shortDayPos >= 0) && (fullDayPos >= 0)) {
		result.splice(fullDayPos, 1);
		// don't start with " ", ",", "." ?
		while (["[ ]", "[,]", "[.]"].indexOf(result[1]) >= 0) {
			result.splice(1, 1);
		}
	}
	//
	return result.join("");
};

exports.getX3Preferences = function(_, localePreferences) {
	return {
		shortDateFormat: exports.dateFormatToX3Format(localePreferences.shortDate(_)),
		longDateFormat: exports.dateFormatToX3Format(localePreferences.longDate(_)),
		shortTimeFormat: exports.dateFormatToX3Format(localePreferences.shortTime(_)),
		longTimeFormat: exports.dateFormatToX3Format(localePreferences.longTime(_)),
		shortDatetimeFormat: exports.dateFormatToX3Format(localePreferences.shortDatetime(_)),
		longDatetimeFormat: exports.dateFormatToX3Format(localePreferences.longDatetime(_)),
		decimalSep: localePreferences.numberDecimalSeparator(_),
		thousandsSep: localePreferences.numberGroupSeparator(_),
		twoDigitYearMax: localePreferences.twoDigitYearMax(_),
		firstDayOfWeek: localePreferences.firstDayOfWeek(_),
		firstWeekOfYear: localePreferences.firstWeekOfYear(_)
	};
}

// Add x3 SDate IDate SThousand STime SDecimal parameters
exports.addLocaleConfig = function(_, cliCfg, userProfile) {
	var selLocale = userProfile && userProfile.selectedLocale(_);
	var x3DateOrder = null,
		dateSep = null;
	cliCfg = cliCfg || {};
	if (selLocale && selLocale.shortDate(_)) {
		// We need to parse dateFormat to extract dateSep and dateOrder
		var dateOrder = [];
		dateUtil.walkFormat((cliCfg.SShortDate = selLocale.shortDate(_)), {
			// We assume that first literal is the date separator
			literal: function(literal) {
				if (dateSep == null) {
					dateSep = literal;
				}
			},
			d: function(repeat) {
				if (dateOrder.indexOf('d') == -1) {
					dateOrder.push('d');
				}
			},
			M: function(repeat) {
				if (dateOrder.indexOf('m') == -1) {
					dateOrder.push('m');
				}
			},
			y: function(repeat) {
				if (dateOrder.indexOf('y') == -1) {
					dateOrder.push('y');
				}
			}
		});
		if (dateOrder.length > 0) {
			// 0	Month-Day-Year - 1	Day-Month-Year - 2	Year-Month-Day
			switch (dateOrder[0].toLowerCase()) {
				case 'd':
					x3DateOrder = "1";
					break;
				case 'm':
					x3DateOrder = "0";
					break;
				case 'y':
					x3DateOrder = "2";
					break;
			}
		}
	}
	// Date
	cliCfg.SDate = dateSep && dateSep.length > 0 ? dateSep : "/";
	cliCfg.IDate = x3DateOrder && x3DateOrder.length > 0 ? x3DateOrder : "0";
	// thousandsSep
	var sep = selLocale ? selLocale.numberGroupSeparator(_) : null;
	cliCfg.SThousand = sep && sep.length > 0 ? sep : " ";
	// timeSep
	sep = selLocale ? exports.getTimeSep(selLocale.shortTime(_)) : null;
	cliCfg.STime = sep && sep.length > 0 ? sep : ":";
	// decimalSep
	sep = selLocale ? selLocale.numberDecimalSeparator(_) : null;
	cliCfg.SDecimal = sep && sep.length > 0 ? sep : ".";
	return cliCfg;
};

exports.getTimeSep = function(timeFormat) {
	var timeSep = null,
		dummy = function() {};
	if (timeFormat) {
		dateUtil.walkFormat(timeFormat, {
			// We assume that first literal is the date separator
			literal: function(literal) {
				if (timeSep == null) {
					timeSep = literal;
				}
			},
			H: dummy,
			h: dummy,
			m: dummy,
			s: dummy,
			t: dummy
		});
	}
	// X3 client don't need date format - only dateOrder and dateSep
	return timeSep == null ? ':' : timeSep;
};
// Remove node.js root directory from files path in error stack trace
exports.errShortPath = function(msg) {
	if (!msg) {
		return msg;
	}
	msg = msg.replace(/\\/g, '/');
	var root = process.cwd().replace(/\\/g, '/') + '/node_modules/';
	return msg.split(root).join('');
};


exports.Error = helpers.defineClass(function fusionError(userMsg, cause, statusCode) {
	this.cause = cause;
	this.message = userMsg || "No user message";
	this.statusCode = statusCode ? 500 : statusCode;
}, Error, {
	toJson: function(filter) {
		if (!filter) {
			filter = function(str) {
				return str;
			};
		}
		var res = {
			msgDefault: filter(this.message)
		};
		var diags = [];
		var kause = this.cause;
		while (kause) {
			diags.push({
				message: filter(exports.errShortPath((kause.stack ? kause.safeStack : kause.toString())))
			});
			kause = kause.cause && kause.cause != kause ? kause.cause : null;
		}
		if (diags.length > 0) {
			res.diagnoses = diags;
		}
		return res;
	},
	toString: function() {
		// convert string with \n to arrays to get beter display in console and log files
		var res = this.toJSON(function(str) {
			if (!str || str.indexOf('\n') == -1) {
				return str;
			}
			return str.split('\n');
		});
		return JSON.stringify(res, null, "  ");
	}
});