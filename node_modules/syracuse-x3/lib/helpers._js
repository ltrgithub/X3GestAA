"use strict";

var crypto = require('crypto');
var util = require('util');
var fs = require('fs');
var fsp = require("path");
var dateUtil = require('syracuse-core/lib/types/datetime');
var nodeconfig = require('syracuse-main/lib/nodeconfig');
var helpers = require("syracuse-core/lib/helpers");
var locale = require("syracuse-core/lib/locale");

exports.getSignature = function(_, challenge, userName) {
	var toSign = new Buffer(userName + "\0" + challenge, "utf8");
	var signer = crypto.createSign(nodeconfig.config.sdata.signAlgorithm);
	signer.update(toSign);
	return signer.sign(fs.readFile(fsp.join(__dirname, "../key.pem"), "ascii", _), "base64");
}
	
// unused
exports.dateFormatToX3Format = function(dateFormat) {
	if(!dateFormat) return "";
	var result = "D:";
	//
	dateUtil.walkFormat(dateFormat, {
		literal: function(literal) { result += "[" + literal + "]"; },
		d: function(repeat) {
			result += "DD";
		},
		M: function(repeat) {
			switch(repeat) {
				case 1:
				case 2:
					result += "MM";
					break;
				case 3:
					result += "MMM";
					break;
				case 4:
					result += "MMMMMMMMMM";
					break;
			}
		},
		y: function(repeat) {
			switch(repeat) {
				case 2:
					result += "YY";
					break;
				case 4:
					result += "YYYY";
					break;
			}
		},
		h: function(repeat) {
			result += "hh";
		},
		H: function(repeat) {
			result += "hh";
		},
		m: function(repeat) {
			result += "mm";
		},
		s: function(repeat) {
			result += "ss";
		},
		t: function(repeat) {
			
		}
	});
	//
	return result;
}

exports.dateFormatToX3Prefs = function(dateFormat) {
	var dateSep=null;
	var dateOrder=[];
	if(dateFormat){
		dateUtil.walkFormat(dateFormat, {
			// We assume that first literal is the date separator
			literal: function(literal) { if (dateSep==null) dateSep = literal; },
			d: function(repeat) {
				if (dateOrder.indexOf('d')==-1) dateOrder.push('d');
			},
			M: function(repeat) {
				if (dateOrder.indexOf('m')==-1) dateOrder.push('m');
			},
			y: function(repeat) {
				if (dateOrder.indexOf('y')==-1) dateOrder.push('y');
			}
		});
	}
	// X3 client don't need date format - only dateOrder and dateSep
	return {
			dateSep:dateSep,
			dateOrder: dateOrder.join('')
		};
}

exports.getTimeSep = function(timeFormat) {
	var timeSep=null;
	var dummy=function(){};
	if(timeFormat){
		dateUtil.walkFormat(timeFormat, {
			// We assume that first literal is the date separator
			literal: function(literal) { if (timeSep==null) timeSep = literal; },
			H:dummy,
            h:dummy,
            m:dummy,
            s:dummy,
            t:dummy
		});
	}
	// X3 client don't need date format - only dateOrder and dateSep
	return timeSep==null?':':timeSep;
}
// Remove node.js root directory from files path in error stack trace
exports.errShortPath=function(msg){
	if (!msg) return msg;
	msg=msg.replace(/\\/g, '/');
	var root=process.cwd().replace(/\\/g, '/') + '/node_modules/';
	return msg.split(root).join('')
}
function fusionError(userMsg, cause, statusCode) {	
    this.cause = cause;
    this.message = userMsg || "No user message";
	this.statusCode=statusCode==undefined?500:statusCode;
}
exports.Error=helpers.defineClass(fusionError, Error, {
	toJson: function(filter) {
		if (!filter) filter=function(str){return str;};
		var res={
			msgDefault:filter(this.message)
		};
		var diags=[];
		var kause=this.cause;
		var root=process.cwd().replace(/\\/g, '/') + '/node_modules/';
		while(kause){
			diags.push({
				message: filter(exports.errShortPath((kause.stack?kause.stack:kause.toString())))
			});
			kause=kause.cause && kause.cause!=kause?kause.cause:null;
		}
		if (diags.length>0) res.diagnoses=diags;
		return res;
	},
	toString: function(){
		// convert string with \n to arrays to get beter display in console and log files
		var res=this.toJson(function(str){
			if (!str || str.indexOf('\n')==-1) return str;
			return str.split('\n');
		});
		return JSON.stringify(res,null,"  ");
	}
})

	

