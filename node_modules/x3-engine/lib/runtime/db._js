"use strict";

var util = require('./util');
var variables = require('./variables');
var operators = require('./operators');
var flowControl = require('./flowControl');
var X3Error = require('./errors').X3Error;
var trace// = console.log;
var undefined;

// this code is specific to mysql
// TODO: investigate why we need this to load db-oracle
//require.paths.push('/usr/local/lib/node_modules');

function _connect(_, frame) {
	var cx = frame.context;
	if (cx.db) return cx.db;

	var opts = cx.dbConfig;
	//console.error("DRIVER: " + opts.driver);
	var driver = require(opts.driver);
	var db = new driver.Database({
		hostname: opts.hostname,
		user: opts.user,
		password: opts.password,
		database: opts.database
	});
	db.connect(_);
	cx.db = db;
	return db;
}

exports.connect = _connect; // for dbTest

function describe(_, frame, name) {
	var cx = frame.context;
	var desc = cx.tableDescs[name];
	if (desc !== undefined) return desc;

	desc = {
		name: name,
	};
	var db = _connect(_, frame);
	var rows = db.query().select('*').from('information_schema.columns').where("table_name=?", [name]).execute(_);
	if (rows.length === 0) {
		cx.tableDescs[name] = null;
		return null;
	}

	function undefNull(val) {
		return val === null ? undefined : val
	};

	function mapType(s) {
		switch (s) {
		case 'varchar':
		case 'text':
			return 'string';
		case 'decimal':
		case 'int':
			return 'number';
		case 'date':
			return 'date';
		case 'binary':
			return 'binary';
		default:
			throw new Error("unknown MySQL type: " + s);
		}
	}
	desc.columns = rows.reduce_(_, function(_, columns, row) {
		var under = row.COLUMN_NAME.lastIndexOf('_');
		var colName = row.COLUMN_NAME.substring(0, under);
		var i = parseInt(row.COLUMN_NAME.substring(under + 1), 10);
		var col = (columns[colName] = columns[colName] || {
			name: colName,
			type: mapType(row.DATA_TYPE),
			maxLength: undefNull(row.CHARACTER_MAXIMUM_LENGTH),
			precision: undefNull(row.NUMERIC_PRECISION),
			scale: undefNull(row.NUMERIC_SCALE),
			nullable: row.IS_NULLABLE !== 'NO'
		});
		col.dim = Math.max(i + 1, col.dim || 0);
		return columns;
	}, {});
	rows = db.query().select('*').from('information_schema.statistics').where("table_name=?", [name]).order({
		table_name: true,
		index_name: true,
		seq_in_index: true
	}).execute(_);
	desc.indexes = rows.reduce_(_, function(_, indexes, row) {
		var index = indexes[row.INDEX_NAME] = indexes[row.INDEX_NAME] || {
			name: row.INDEX_NAME,
			columns: []
		};
		index.columns.push(row.COLUMN_NAME);
		index.unique = !row.NON_UNIQUE;
		return indexes;
	}, {});
	desc.abbrev = desc.abbrev || db.query().select('ABRFIC_0').from('ATABLE').where("CODFIC_0=?", [name]).execute(_)[0].ABRFIC_0;
	cx.tableDescs[name] = desc;
	return desc;
}

function escape(s) {
	return '`' + s + '`';
}

function parseSrf(text) {
	var lines = text.split("\n");
	if (!lines[0] || lines[0].substring(0, 8) !== "#<AdxFL>") throw new Error("bad magic");
	var colCount = parseInt(lines[4], 10);
	var indexCount = parseInt(lines[5 + colCount], 10);
	return {
		tableName: lines[1],
		columns: lines.slice(5, 5 + colCount).map(function(line) {
			var fields = line.split("\t");
			return {
				name: fields[0],
				type: fields[1],
				size: fields[2],
				dim: fields[3],
				title: fields[4].substring(1, fields[4].length - 1)
			};
		}),
		indexes: lines.slice(6 + colCount, 6 + colCount + indexCount).map(function(line) {
			var fields = line.split("\t")
			return {
				name: fields[0],
				unique: fields[1] == "2",
				formula: fields[2]
			};
		})
	};
}

exports.functions = {
	FILECLA: {
		count: 0
	},
	FILETYP: {
		count: 0
	},
};

function concat(a1, a2) {
	return (a1 && a2) ? a1.concat(a2) : (a1 || a2);
}

function genSql(_, frame, exp) {
	var val = typeof exp === 'function' ? exp(_, frame) : exp;
	if (val && val.sql) return val;
	return {
		sql: typeof val === "string" ? "'" + val.replace(/'/g, "''") + "'" : "" + val,
		type: typeof val
	};
}

function binaryOp(op, sqlOp, type, numOp, numType) {
	return function(op1, op2) {
		return function binaryOp$do(_, frame) {
			if (!frame.tryingSql) return operators.instructions[op](op1, op2)(_, frame);
			var v1 = genSql(_, frame, op1);
			var v2 = genSql(_, frame, op2);
			if (numOp && v1.type === v2.type && v1.type === "number") sqlOp = numOp, type = numType;
			var sql;
			if (sqlOp === "CONCAT") {
				if (numOp === '-') {
					v1.sql = "RTRIM(" + v1.sql + "),' '";
					v2.sql = "' ',LTRIM(" + v2.sql + ")";
				}
				sql = "CONCAT(" + v1.sql + "," + v2.sql + ")";
			} else sql = "(" + v1.sql + " " + sqlOp + " " + v2.sql + ")";
			return {
				sql: sql,
				type: type,
			};
		}
	}
}

function mapRow(row) {
	return Object.keys(row).reduce(function(obj, key) {
		obj[key] = row[key]; // for now!
		return obj;
	}, {})
}

function sqlFn(name, type) {
	return function() {
		return {
			sql: name + "(" + Array.prototype.map.call(arguments, function(arg) {
				return arg.sql;
			}).join(',') + ")",
			type: type,
		};
	}
}

function tooComplex() {
	return {
		tooComplexForSql: true
	};
}

function defVal(type) {
	switch (type) {
	case 'string':
		return '';
	case 'number':
		return 0;
	default:
		throw new Error('unsupported column type: ' + type)
	}
}

var sqlFunctions = {
	// string functions
	LEN: sqlFn("LENGTH", "number"),
	LEFT$: sqlFn("LEFT", "string"),
	RIGHT$: sqlFn("RIGHT", "string"),
	MID$: sqlFn("SUBSTRING", "string"),
	TOUPPER: sqlFn("UPPER", "string"),
	TOLOWER: sqlFn("LOWER", "string"),
	CHR$: sqlFn("CHAR", "string"),
	SEG$: function(arg, first, last) {
		return {
			sql: "SUBSTRING(" + arg.sql + "," + first.sql + "," + last.sql + " + 1 - " + first.sql + ")",
			type: "string",
		}
	},
	CTRANS: function(arg) {
		if (arguments.length > 1) throw tooComplex();
		return {
			sql: "CONVERT(" + arg.sql + " USING ASCII)",
			type: "string",
		}
	},
	PAT: function(str, pat) {
		if (/[?#!]/.match(pat.sql)) throw tooComplex();
		return {
			sql: "(" + str.sql + " LIKE " + pat.sql.replace(/%/g, '%%').replace(/\*/g, '%') + ")",
			type: "string",
		}
	},

	// Numeric functions
	ABS: sqlFn("ABS", "number"),
	MOD: sqlFn("MOD", "number"),
	// investigate neg values
	ARR2: function(arg) {
		return {
			sql: "ROUND(" + arg.sql + ",2)",
			type: "number",
		}
	},
	ARR: sqlFn("ROUND", "number"),
	FIX: sqlFn("TRUNCATE", "number"),
	INT: sqlFn("FLOOR", "number"),

	SQR: sqlFn("SQRT", "number"),
	COS: sqlFn("COS", "number"),
	SIN: sqlFn("SIN", "number"),
	TAN: sqlFn("TAN", "number"),
	ACOS: sqlFn("ACOS", "number"),
	ASIN: sqlFn("ASIN", "number"),
	ATAN: sqlFn("ATAN", "number"),
	PI: sqlFn("PI", "number"),
	EXP: sqlFn("EXP", "number"),
	LN: sqlFn("LOG", "number"),
	LOG: sqlFn("LOG10", "number"),

	// Find
	FIND: function(arg) {
		var vals = Array.prototype.slice.call(arguments, 1);
		return {
			sql: "FIND_IN_SET(" + arg.sql + ",'" + vals.map(function(val) {
				if (!/['\-\d]/.test(val.sql[0])) throw tooComplex();
				return val.sql.substring(1, val.sql.length - 1);
			}).join(',') + "')",
			type: "number",
		}
	}

	// see later about date functions
}

function findTable(frame, abbrev) {
	// use frame's default abbrev by default
	var table = frame.context.tables[abbrev || frame.abbrev];
	if (!table) throw new X3Error(7, "bad table abbrev: " + abbrev);
	return table;
}

function findView(frame, abbrev) {
	// use frame's default abbrev by default
	var abb = abbrev || frame.abbrev;
	var table = frame.context.tables[abb];
	if (!table) throw new X3Error(7, "bad table abbrev: " + abbrev);
	return table.views[abb];
}

function findIndex(table, name) {
	var index = table.desc.indexes[name];
	if (!index) throw new X3Error(21, "bad index: " + name);
	return index;
}

function allocateSlots(frame, abb, columns, first) {
	var data = frame.context.data;
	if (data.abbrevs.indexOf(abb) >= 0) return;
	var values = data.values;
	var types = data.types;
	Object.keys(columns).forEach(function(colName) {
		var type = columns[colName].type;
		var key = abb + "_" + colName;
		values[key] = defVal(type);
		types[key] = type;
	})
	// insert the abbrev into the lookup list
	first ? data.abbrevs.splice(0, 0, abb) : data.abbrevs.push(abb);

}

exports.instructions = {
	KEY: function(letter, abbrev, name, indices) {
		return function key$do(_, frame) {
			return {
				letter: letter,
				abbrev: abbrev,
				name: name,
				indices: indices && indices.map_(_, function(_, exp) {
					return exp(_, frame);
				})
			};
		};
	},
	FILEF: function(name, abbrev, where, order) {
		var loc = util.sourceLoc;
		return function file$do(_, frame) {
			frame.sub.loc = loc;
			var nameVal = name(_, frame);
			var desc = describe(_, frame, nameVal);
			if (!desc) throw new X3Error(7, "unknown table or unsupport FILE syntax: " + nameVal);
			var abb = abbrev || desc.abbrev;
			var table = frame.context.tables[abb] = {
				abbrev: abb,
				desc: desc,
				views: {},
			};
			// allocate column slots
			allocateSlots(frame, abb, desc.columns, true);
			// add link to self with where and order clauses
			table.views[abb] = {
				table: table,
				joins: [],
				where: where && where(_, frame),
				order: order && order(_, frame),
				filter: {},
			};
			// record last abbrev as default one
			frame.abbrev = abb;
		}
	},
	FILTER: function(abbrev, where, order) {
		var loc = util.sourceLoc;
		return function filter$do(_, frame) {
			frame.sub.loc = loc;
			var view = findView(frame, abbrev);
			view.filter = {
				where: where && where(_, frame),
				order: order && order(_, frame)
			}
		}
	},
	COLUMNS: function(abbrev, columns) {
		var loc = util.sourceLoc;
		return function columns$do(_, frame) {
			frame.sub.loc = loc;
			var view = findView(frame, abbrev);
			// columns is an array of [abbrev, field] pairs
			table.columns = columns;
		};
	},
	LINKITEM: function(key, outer, values) {
		return function linkitem$do(_, frame) {
			var k = key(_, frame);
			var table = findTable(frame, k.abbrev);
			var index = findIndex(table, k.name);
			allocateSlots(frame, k.abbrev, table.desc.columns);
			var sql = (outer ? " LEFT" : " INNER") + " JOIN " + table.desc.name + " AS " + k.abbrev //
			+ " ON " + values.map_(_, function(_, val, i) {
				frame.tryingSql = true;
				try {
					val = genSql(_, frame, val);
					frame.tryingSql = false;
					return k.abbrev + "." + index.columns[i].substring(1) + "_0 = " + val.sql;
				} catch (ex) {
					frame.tryingSql = false;
					throw ex; // TODO: handle this
					if (!ex.tooComplexForSql) throw ex;
					//exps.push(exp);
				}
			});
			return {
				sql: sql,
				abbrev: k.abbrev
			};
		}
	},
	LINK: function(abbrev, as, joins, where, order) {
		var loc = util.sourceLoc;
		return function link$do(_, frame) {
			frame.sub.loc = loc;
			var table = findTable(frame, abbrev);
			// main table is also accessible with the link abbrev
			frame.context.tables[as] = table;
			// link information is 
			table.views[as] = {
				table: table,
				joins: joins.map_(_, function(_, join) {
					return genSql(_, frame, join);
				}),
				where: where && where(_, frame),
				order: order && order(_, frame),
				filter: {},
			}
			// TODO: should we insert it in dicts (table is already there)?
		}
	},
	WRITE: function(abbrev) {
		var loc = util.sourceLoc;
		return function write$do(_, frame) {
			frame.sub.loc = loc;
			var table = findTable(frame, abbrev);
			var colNames = Object.keys(table.desc.columns);
			var sql = table.insert || (table.insert = "INSERT INTO " + escape(table.desc.name) + " (" + colNames.map(function(colName) {
				return colName + "_0";
			}) + ") VALUES (" + colNames.map(function(colName) {
				return "?";
			}) + ")");
			var row = frame.context.data.values;
			var abbrev = table.abbrev;
			var values = colNames.map(function(colName) {
				var val = row[abbrev + "_" + colName];
				if (val == null) throw new Error(abbrev + "_" + colName + ": bad value: " + val);
				return val;
			});
			trace && trace(sql);
			trace && trace(values);
			_connect(_, frame).query(sql, values).execute(_);
		}
	},
	FORF: function(key, where, p, end, block) {
		var loc = util.sourceLoc;
		return function forf$do(_, frame) {
			frame.sub.loc = loc;
			var k = key(_, frame);
			var view = findView(frame, k.abbrev);

			function identity(x) {
				return x;
			}

			// generate WHERE clause
			var whereSqls = [],
				whereExps = [];
			[view.where, view.filter.where, where && where(_, frame)].filter(identity).forEach(function(w) {
				w.sql && whereSqls.push(w.sql);
				whereExps = concat(whereExps, w.exps);
			});

			var whereSql = whereSqls.length ? " WHERE " + whereSqls.join(' AND ') : '';

			// generate ORDER BY clause
			var ord = view.filter.order || view.order;
			var orderBySql = ord ? " ORDER BY " + ord.items.map(function(item) {
				return item.substring(1) + "_0" + (item[0] === '-' ? ' DESC' : ' ASC');
			}).join(',') : '';

			//var tablesSql = abbrevs.map(function(abbrev) {
			//	return escape(findTable(frame, abbrev).desc.name) + " AS " + abbrev;
			//});
			var abbrevs = [view.table.abbrev];
			var tablesSql = escape(view.table.desc.name) + " AS " + view.table.abbrev + view.joins.map(function(join) {
				abbrevs.push(join.abbrev);
				return join.sql;
			}).join('');

			var columnsSql = (view.columns ? view.columns.map(function(column) {
				return column[0] + "." + column[1] + "_0 AS " + column[0] + "_" + column[1];
			}) : abbrevs.reduce(function(result, abbrev) {
				Object.keys(findTable(frame, abbrev).desc.columns).forEach(function(column) {
					result.push(abbrev + "." + column + "_0 AS " + abbrev + "_" + column);
				});
				return result;
			}, [])).join(',')

			var sql = "SELECT " + columnsSql + " FROM " + tablesSql + whereSql + orderBySql;

			trace && trace(sql);
			whereExps.length > 0 && console.log(whereExps.length + " WHERE clause(s) not translated to SQL.")
			var q = _connect(_, frame).query(sql);

			var cursor = q.execute(_, {
				useCursor: true
			});

			var level = ++frame.loopLevel;
			while (frame.loopLevel === level) {
				var row = cursor.next(_);
				if (row) {
					frame.context.data.values = mapRow(row);
					//console.log(frame.context.data.values);
					if (whereExps.every_(_, function(_, exp) {
						return exp(_, frame);
					})) block(_, frame);
				} else {
					frame.loopLevel = level - 1;
				}
			}
			if (frame.loopLevel === level - 1) p[end](_, frame);
		}
	},
	WHERE: function(wheres) {
		return function(_, frame) {
			var sqls = [],
				exps = [];
			wheres.forEach_(_, function(_, exp) {
				frame.tryingSql = true;
				try {
					var r = genSql(_, frame, exp);
					sqls.push(r.sql);

					frame.tryingSql = false;
				} catch (ex) {
					frame.tryingSql = false;
					if (!ex.tooComplexForSql) throw ex;
					exps.push(exp);
				}
			});
			return {
				sql: sqls.join(" AND "),
				exps: exps,
			};
		}
	},
	ORDER: function(keyName, by, withExp) {
		return function(_, frame) {
			var items = by;
			if (withExp) {
				items = withExp(_, frame).split(';').map(function(s) {
					var pair = s.split(' ');
					return (pair[1] && pair[1].toLowerCase() === 'desc' ? '-' : '+') + pair[0];
				});
			}
			return {
				name: keyName,
				items: items
			};
		}
	},

	SQLV: function(field) {
		return function sqlv$do(_, frame) {
			if (!frame.tryingSql) return variables.instructions.V(field)(_, frame);
			var data = frame.context.data;
			for (var i = 0; i < data.abbrevs.length; i++) {
				var abbrev = data.abbrevs[i];
				var key = abbrev + '_' + field;
				if (data.values[key] !== undefined) return {
					sql: abbrev + '.' + field + '_0',
					type: data.types[key],
				}
			}
			return variables.instructions.V(field)(_, frame);
		};
	},
	SQLCV: function(letter, abbrev, field) {
		return function sqlcv$do(_, frame) {
			if (!frame.tryingSql || letter === 'L' || letter === 'V' || letter === 'S') return variables.instructions.CV(letter, abbrev, field)(_, frame);
			var table = frame.context.tables[abbrev];
			var col = table && table.desc && table.desc.columns[field];
			return {
				sql: abbrev + '.' + field + '_0',
				type: col && col.type,
			};
		};
	},
	SQLF: function(field, args) {
		var sqlFunc = sqlFunctions[field];
		if (!sqlFunc) return flowControl.instructions.F(field, args);
		return function sqlf$do(_, frame) {
			if (!frame.tryingSql) return flowControl.instructions.F(field, args)(_, frame);
			var argSqls = args.map_(_, function(_, arg) {
				return genSql(_, frame, arg);
			});
			return sqlFunc.apply(this, argSqls);
		};
	},
	SQLAND: binaryOp('AND', 'AND', 'boolean'),
	SQLOR: binaryOp('OR', 'OR', 'boolean'),
	SQLEQ: binaryOp('EQ', '=', 'boolean'),
	SQLNE: binaryOp('NE', '<>', 'boolean'),
	SQLLT: binaryOp('LT', '<', 'boolean'),
	SQLLE: binaryOp('LE', '<=', 'boolean'),
	SQLGT: binaryOp('GT', '>', 'boolean'),
	SQLGE: binaryOp('GE', '>=', 'boolean'),
	SQLADD: binaryOp('ADD', 'CONCAT', 'string', '+', 'number'),
	SQLSUB: binaryOp('SUB', 'CONCAT', 'string', '-', 'number'),
	SQLMUL: binaryOp('MUL', '*', 'number'),
	SQLDIV: binaryOp('DIV', '/', 'number'),
}