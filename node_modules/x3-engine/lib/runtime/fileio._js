"use strict";

var fs = require('fs');
var path = require('path');
var util = require('./util');
var variables = require('./variables');
/* 
 * Sequential I/0
 */

function File(name, fd, offset) {
	this.adxifs = ' ';
	this.adxirs = '\n';
	this.adxium = 50;

	this.write = function(_, str) {
		var len = fs.write(fd, str, offset, 'utf8', _);
		offset += len;
		return len;
	}
	this.close = function(_, frame) {
		var oldFd = fd;
		fd = null;
		oldFd && fs.close(oldFd, _);
	}
}

exports.functions = {
	DIR$: {
		count: 0,
		fn: function() {
			return process.cwd();
		}
	},
	FILCOM: {
		count: 1
	},
	FILPATH: {
		count: -1,
		fn: function(folder, name, ext, app, drive, host) {
			util.checkString(folder);
			util.checkString(name);
			util.checkString(ext);
			app = app || "test";
			return path.join(__dirname, "../../" + app + "/" + folder + "/" + name + "." + ext);
		}
	},
};

function findFile(frame, abbrev) {
	var file = frame.context.files[abbrev];
	if (!file) throw new X3Error(7, "Sequential file abbrev not found: " + abbrev);
	return file;
}
exports.instructions = {
	OPEN: function(abbrev, name, mode, seek) {
		var loc = util.sourceLoc;
		seek = seek || util.instructions.C(0);
		return function open$do(_, frame) {
			frame.sub.loc = loc;
			var nameVal = name(_, frame);
			var seekVal = seek(_, frame);
			if (seekVal < 0) {
				if (mode === "w") mode = "a";
				else if (mode === "r+") mode = "a+";
			}
			var fd = fs.open(nameVal, mode, _);
			frame.context.files[abbrev] = new File(nameVal, fd, seekVal);
		}
	},
	CLOSE: function(abbrev) {
		var loc = util.sourceLoc;
		return function close$do(_, frame) {
			frame.sub.loc = loc;
			var file = findFile(frame, abbrev);
			file.close(_, frame);
		}
	},
	IOMODE: function(abbrev, mode, value) {
		var loc = util.sourceLoc;
		mode = mode.toLowerCase();
		return function iomode$do(_, frame) {
			frame.sub.loc = loc;
			var file = findFile(frame, abbrev);
			var val = value(_, frame);
			if (file[mode] === undefined) throw new X3Error(22, "bad iomode: " + val)
			file[mode] = val;
		}
	},
	WRSEQ: function(abbrev, exps, sep) {
		var loc = util.sourceLoc;
		sep = sep || util.instructions.C(',');
		return function wrseq$do(_, frame) {
			frame.sub.loc = loc;
			var file = findFile(frame, abbrev);
			var vals = exps(_, frame);
			var sepVal = sep === null ? file.adxifs : sep(_, frame);
			return file.write(_, vals.join(sepVal) + file.adxirs);
		}
	}
}