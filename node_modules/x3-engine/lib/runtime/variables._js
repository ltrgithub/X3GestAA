"use strict";

var util = require('./util');
var date = require('syracuse-core/lib/types/date');
var X3Error = require('./errors').X3Error;
var undefined;

var _warn = util.warn;
var _tracer = util.tracer;

exports.createStack = function(config) {
	var cx = {
		globals: {
			values: {},
			types: {}
		},
		sys: {
			values: {},
			types: {}
		},
		data: {
			values: {},
			types: {},
			abbrevs: [],
		},
		dbConfig: config.db,
		tableDescs: {},
		tables: {},
		loginName: process.env.USER || "<unknown>",
		// for now
		// seq file stuff
		files: {}
	};

	function sysVar(name, type, value) {
		cx.sys.values[name] = value;
		cx.sys.types[name] = type;
	}
	sysVar('ADXIFS', 'S', ',');
	sysVar('ADXIRS', 'S', '\n');
	sysVar('ADXIUM', 'I', 0);
	sysVar('ADXSCA', 'S', '?? .#*???');

	var frame = {
		values: {},
		types: {},
		context: cx,
		loc: {},
		loopLevel: 0,
	};
	frame.sub = frame;
	// TODO: investigate how data (F class) is managed - global for now
	frame.dicts = [frame, cx.globals, cx.sys, cx.data];
	frame.tablePos = 2;
	return frame;
};

exports.functions = {
	DIM: {
		count: -1,
		fn: function(arr, dim) {
			//console.error("DIM: " + JSON.stringify(arr) + " dim=" + dim)
			if (arr === undefined) return -1;
			if (!Array.isArray(arr)) // basic values are considered to be arrays of 1 elt.
			return dim === -1 ? 0 : 1;
			if (dim === undefined) dim = 1;
			var ndims = arr[0];
			if (dim === 0) return ndims;
			if (!(dim >= -ndims && dim <= ndims)) throw util.badArgumentType(dim);
			var sliced = arr.length === 3 + 4 * ndims;
			if (sliced) {
				if (dim > 0) return arr[4 + 2 * (ndims + (dim - 1))];
				else return arr[3 + 2 * -(dim + 1)];
			} else {
				if (dim > 0) return arr[4 + 2 * (dim - 1)];
				else return arr[3 + 2 * -(dim + 1)];
			}
		}
	},
	TYPE: {
		count: 1,
		fn: function(t) {
			if (!t) return -1;
			var type = exports[t[1]];
			if (!type) throw new X3Error(26, "bad type: " + t);
			return type.value === 10 && t.length > 2 ? 10 + parseInt(t.substring(2), 10) : type.value;
		}
	},
	VARMODE: {
		count: 0
	},
	CLANAM: {
		count: 1
	},
	CLAVAR: {
		count: 1
	},
};

exports.types = {
	D: {
		name: 'DATE',
		value: 3,
		def: date.make(0, 0, 0)
	},
	B: {
		name: 'BLBFILE',
		value: 522,
		def: new Buffer(0)
	},
	I: {
		name: 'INTEGER',
		value: 4,
		def: 0
	},
	J: {
		name: 'SHORTINT',
		value: 2,
		def: 0
	},
	N: {
		name: 'DECIMAL',
		value: 7,
		def: 0
	},
	S: {
		name: 'CHAR',
		value: 10,
		def: ""
	},
	T: {
		name: 'CLBFILE',
		value: 523,
		def: ""
	},
	U: {
		name: 'SCHAR',
		value: 10,
		// ? not listed in doc
		def: ""
	},
	V: {
		name: 'LIBELLE',
		value: 1,
		def: ""
	},
	X: {
		name: 'ANY',
		value: -1,
		def: null
	},
};

// storage classes
exports.dictClasses = {
	VARIABLE: 'A',
	VALUE: 'B',
	CONST: 'C',
	DEFAULT: 'D',
	GLOBAL: 'V',
	LOCAL: 'L',
	// + F (table), M (mask) and S (sequential) that don't have keywords
};

var raz = {};

exports.instructions = {
	V: function(field) {
		return function v$do(_, frame, assign, val, silent) {
			var dicts = frame.dicts;

			if (assign && val == null) throw new X3Error(26, "invalid value '" + val + "' assigned to '" + field + "'");

			for (var i = 0, len = dicts.length; i < len; i++) {
				var dict = dicts[i];
				var key, v, found;
				if (dict.abbrevs) {
					for (var j = 0; !found && j < dict.abbrevs.length; j++) {
						key = dict.abbrevs[j] + "_" + field;
						v = dict.values[key];
						found = (v !== undefined);
					}
				} else {
					key = field;
					v = dict.values[key];
					found = (v !== undefined);
				}
				if (found) {
					if (_tracer) {
						if (assign) _tracer(frame.sub.loc.line + ": SET " + field + " <-  " + val);
						else _tracer(frame.sub.loc.line + ": GET " + field + " ->  " + v);
					}
					if (assign) {
						val = val === raz ? exports.types[dict.types[key][1]].def : val;
						if (val === undefined) throw new X3Error(26, "undefined assigned to '" + field + "'");
						dict.values[key] = val;
						return;
					} else return v;
				}
			}
			// not found, create in local dict if assign
			if (_tracer) {
				if (assign) _tracer(frame.sub.loc.line + ": SET " + field + " <-  " + val);
				else _tracer(frame.sub.loc.line + ": GET " + field + " ->  " + v);
			}
			if (assign) frame.values[field] = val;
			else return;
		};
	},
	TYPEV: function(field) {
		return function typev$do(_, frame) {
			var dicts = frame.dicts;
			for (var i = 0, len = dicts.length; i < len; i++) {
				var dict = dicts[i];
				var key, t;
				if (dict.abbrevs) {
					for (var j = 0; !found && j < dict.abbrevs.length; j++) {
						key = dict.abbrevs[j] + "_" + field;
						t = dict.types[key];
						if (t) return t;
					}
				} else {
					key = field;
					t = dict.types[key];
					if (t) return t;
				}
			}
			return null;
		};
	},
	CV: function(letter, abbrev, field) {
		return function cv$do(_, frame, assign, val, silent) {
			var dict;

			if (assign && val == null) throw new X3Error(26, "invalid value '" + val + "' assigned to '" + field + "'");

			var key = field;
			switch (letter) {
				case 'L':
					dict = frame;
					break;
				case 'V':
					dict = frame.context.globals;
					break;
				case 'S':
					dict = frame.context.sys;
					break;
				case 'F':
				case '?':
					dict = frame.context.data;
					if (abbrev) key = abbrev + "_" + field;
					else {
						var found;
						for (var i = 0; !found && i < dict.abbrevs.length; i++) {
							key = dict.abbrevs[i] + "_" + field;
							found = (dict.values[key] !== undefined);
						}
						if (!found) throw new X3Error(7, 'unknown class: [' + letter + ':' + abbrev + ']' + field);
					}
					break;
				default:
					throw new X3Error(7, 'unknown class: [' + letter + ']');

			}

			if (!dict) {
				if (false && frame.tryingSql) { // REVIEW!!!
					var err = new Error("trying sql (ignore)");
					err.tooComplexForSql = true;
					throw err;
				}
			}
			if (_tracer) {
				if (assign) _tracer(frame.sub.loc.line + ": SET " + field + " <-  " + val);
				else _tracer(frame.sub.loc.line + ": GET " + field + " ->  " + dict.values[key]);
			}

			if (assign) {
				val = val === raz ? exports.types[dict.types[key][1]].def : val;
				dict.values[key] = val;
			} else return dict.values[key];
		};
	},
	TYPECV: function(letter, abbrev, field) {
		return function typecv$do(_, frame) {
			var dict;
			var key = field,
				t;
			switch (letter) {
				case 'L':
					dict = frame;
					break;
				case 'V':
					dict = frame.context.globals;
					break;
				case 'S':
					dict = frame.context.sys;
					break;
				case 'F':
				case '?':
					dict = frame.context.data;
					if (abbrev) key = abbrev + "_" + field;
					else {
						for (var i = 0; !found && i < dict.abbrevs.length; i++) {
							key = dict.abbrevs[i] + "_" + field;
							t = dict.types[key];
							if (t) return t;
						}
						throw new X3Error(7, 'unknown class: [' + letter + ':' + abbrev + ']' + field);
					}
					break;
				default:
					throw new X3Error(7, 'unknown class: [' + letter + ']');

			}
			return dict && dict.types[key];
		};
	},
	DECL: function(key, field, lens0, ranges0) {
		var loc = util.sourceLoc;
		return function decl$do(_, frame) {
			frame.sub.loc = loc;
			var lens = lens0,
				ranges = ranges0;
			var letter = key[0];
			var dict = letter === 'V' ? frame.context.globals : frame;
			var values = dict.values;
			if (letter === 'L' || letter === 'V') delete values[field];

			var t = key[1];
			if (t !== 'S' && t !== 'T' && lens) {
				ranges = lens;
				lens = undefined;
			}
			if (lens) {
				key += lens(_, frame)[0];
			}
			dict.types[field] = key;
			if (ranges) {
				var rangesVals = ranges(_, frame);
				var ndims = rangesVals.length;
				var arr = values[field];
				if (arr === undefined) {
					var def = exports.types[t].def;
					arr = [ndims, def, []];
					for (var dim = 0; dim < ndims; dim++) {
						var range = rangesVals[dim];
						if (typeof range === 'number') range = [0, range];
						arr = arr.concat(range);
					}
					values[field] = arr;
				} else {
					if (!Array.isArray(arr)) throw new X3Error(26, "initial value for '" + field + "' is not an array!");
					values[field] = arr = arr.slice(0); // clone it
					if (ndims != arr[0]) throw new X3Error(26, "dimensions mismatch for '" + field + "': expected " + ndims + ", got " + arr[0]);
					// note: array was copied when parameter was assigned - so we can modify it
					var sliced = arr.length === 3 + 4 * ndims;
					for (var dim = 0; dim < ndims; dim++) {
						var range = rangesVals[dim];
						//console.error("RANGE=" + range)
						if (range) {
							if (typeof range === 'number') range = [0, range];
							arr[3 + 2 * dim] = range[0];
							if (range[1]) {
								var count = sliced ? arr[4 + 2 * (ndims + dim)] : arr[4 + 2 * dim];
								if (count !== range[1]) throw new X3Error(26, "range mismatch for '" + field + "': expected " + count + ", got " + range[1]);
							}
						}
					}
				}
			} else {
				if (values[field] === undefined) {
					var def = exports.types[t].def;
					values[field] = def;
				}
			}
		};
	},
	CA: function(field, exps) {
		var decl = exports.instructions.DECL('LX', field, util.instructions.A([util.instructions.C(exps.length)]));
		var aexps = util.instructions.A(exps);
		return function ca$do(_, frame) {
			decl(_, frame);
			var val = frame.values[field];
			var vals = aexps(_, frame);
			val[2] = vals;
		};
	},
	GET: function(obj, prop) {
		return function get$do(_, frame) {
			//console.error("GET " + prop);
			//console.error(obj);
			return obj[prop];
		};
	},
	SET: function(lhs, rhs, silent) {
		var loc = util.sourceLoc;
		return function set$do(_, frame) {
			frame.sub.loc = loc;
			lhs(_, frame, true, rhs.value !== undefined ? rhs.value : rhs(_, frame), silent);
		};
	},
	RAZ: function(exps) {
		var loc = util.sourceLoc;
		return function raz$do(_, frame) {
			frame.sub.loc = loc;
			exps.forEach_(_, function(_, exp) {
				exp(_, frame, true, raz);
			});
		};

	},
	DOT: util.instructions.NIY
};