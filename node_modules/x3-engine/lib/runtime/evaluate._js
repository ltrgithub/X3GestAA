"use strict";
/*
 * Eval
 */
var Parser = require("../parser").Parser;
var instructions;

var util = require('./util');
var variables = require('./variables');

function buildLiteral(node) {
	return util.instructions.C(node.value);
}

var _buildExports;
var _buildRequire;

var builders = {
	STRING: buildLiteral,
	DECIMAL: buildLiteral,
	INTEGER: buildLiteral,
	IDENT: function(node) {
		return instructions.V(node.value);
	},
	CLAS: function(node) {
		return instructions.CV(node.letter, node.abbrev, node.field);
	},
	OP: function(node) {
		return instructions[node.op].apply(null, node.args.map(_build));
	},
	FCALL: function(node) {
		return instructions.F(node.name, (node.args || []).map(_build));
	},
	EVALUE: function(node) {
		return instructions.EVALUE(_buildRequire, _buildExports, _build(node.arg));
	},
	SIGMA: function(node) {
		return instructions.SIGMA(node.field, node.args.map(_build));
	},
	FUNC: function(node) {
		return instructions.CALL(node.from ? instructions.REQ(_buildRequire, _build(node.from)) : instructions.C(_buildExports), _build(node.name), (node.args || []).map(_build));
	},
	INDEX: function(node) {
		return instructions.INDEX(_build(node.target), node.args.map(_build));
	},
	DATE: function(node) {
		return instructions.DATE(node.year, node.month, node.day);
	}
}

function _build(node) {
	var builder = builders[node.tag];
	if (!builder) throw new X3Error(200, "unsupported eval construct: " + node.tag);
	return builder(node);
}

exports.functions = {
		EVALUE: { // parser needs it in this table but fn will never be called
		count: -1
	},
};

exports.instructions = {
	EVALUE: function(req, ns, arg) {
		var loc = util.sourceLoc;
		return function evalue$do(_, frame) {
			instructions = instructions || require('./index').instructions;
			frame.sub.loc = loc;
			var argVal = arg(_, frame);
			util.checkString(argVal);
			var node = new Parser(argVal, "eval").parseExp(true);
			_buildRequire = req;
			_buildExports = ns;
			var fn = _build(node);
			return fn(_, frame);
		}
	}
};