"use strict";
var inspect = require('util').inspect;
var variables = require('./runtime/variables');
var db = require('./runtime/db');
var X3Error = require("./runtime/errors").X3Error;

exports.generate = function(node, fname) {
	var used = {};
	var scopeName = ""; // for errors
	var warn = function(node, message) {
			console.error(node.line + ": " + message);
		}

	function error(node, message) {
		return new X3Error(26, message, fname, node.line, scopeName);
	}

	function unreachable(node) {
		warn(node, node.tag + " is not reachable");
		return "";
	}

	function id(node) {
		return node._id || (node._id = ++lastId);
	}

	var result = "z.MAIN(e);e.MAIN=B(";
	var line = 1,
		lastLine = 1;
	var tail = ");";
	var lastId = 0;
	var comma = "";
	var skipping;

	function insert(node, arg, beg, end) {
		if (node && arg && !tail) {
			if (skipping) return "";
			skipping = true;
			return unreachable(node);
		} else {
			skipping = false;
		}
		var result = "";
		if (node && arg && line > lastLine) {
			arg = "NL(" + (line - lastLine) + ")," + arg;
			lastLine = line;
		}
		if (tail && arg) {
			result = comma + arg;
			comma = ","
		}
		if (beg) {
			result += tail + beg;
			tail = "";
		}
		if (end) {
			comma = "";
			tail = end + tail;
		}
		return result;
	}

	function genArray(arr) {
		used.A = true;
		return "A([" + arr.map(gen0).join(',') + "])";

	}

	function genClosing(node) {
		return insert(node, "", "p[" + id(node) + "]=B(", ");");
	}

	var types = {};
	for (var key in variables.types)
	types[variables.types[key].name] = key;

	function leaf(node) {
		return node.branch ? leaf(node.branch) : node;
	}

	var tmp;

	var generators = {
		IDENT: function(node, variant) {
			var inst = (variant || '') + "V";
			used[inst] = true;
			return inst + "('" + node.value + "')";
		},
		CLAS: function(node, variant) {
			var inst = (variant || '') + "CV";
			used[inst] = true;
			return inst + "('" + node.letter + "','" + (node.abbrev || "") + "','" + node.field + "')";
		},


		STRING: function(node) {
			used.C = true;
			var val = node.value.replace(/\\/g, "\\\\");
			return node.value.indexOf("'") >= 0 ? 'C("' + val + '")' : "C('" + val + "')";
		},
		INTEGER: tmp = function(node) {
			used.C = true;
			return "C(" + node.value + ")";
		},
		DECIMAL: tmp,
		DATE: function(node) {
			used.DATE = true;
			return "DATE(" + node.year + "," + node.month + "," + node.day + ")";
		},


		OP: function(node, variant) {
			if (variant && db.instructions[variant + node.op]) {
				used[variant + node.op] = true;
				return variant + node.op + "(" + node.args.map(genVariant(variant)).join(',') + ")"
			} else {
				used[node.op] = true;
				return node.op + "(" + node.args.map(gen0).join(',') + ")";
			}
		},
		FCALL: function(node, variant) {
			var inst = (variant || '') + "F";
			used[inst] = true;
			if (node.name === 'TYPE') variant = "TYPE";
			return inst + "('" + node.name + "'" + (node.args ? ",[" + node.args.map(genVariant(variant)).join(",") + "]" : "") + ")";
		},
		EVALUE: function(node) {
			used.EVALUE = true;
			return "EVALUE(r, e, " + gen(node.arg) + ")";
		},
		SIGMA: function(node) {
			used.SIGMA = true;
			return "SIGMA('" + node.field + "',[" + node.args.map(gen0).join(",") + "])";
		},
		SORTA: function(node) {
			used.SORTA = true;
			return insert(node, "SORTA(" + gen(node.rep) + ",[" + (node.vars || []).map(gen0) + "],[" + ((node.order && node.order.exps) || []).map(gen0) + "])");
		},
		INSA: tmp = function(node) {
			used[node.tag] = true;
			return insert(node, node.tag + "([" + node.intExps.map(gen0) + "],[" + node.vars.map(gen0) + "])");
		},
		DELA: tmp,
		INDEX: function(node) {
			used.INDEX = true;
			return "INDEX(" + gen(node.target) + ",[" + node.args.map(gen0) + "])";
		},
		DECL: function(node) {
			used.DECL = true;
			return node.items.map(function(decl) {
				// TODO: dims, using and sized
				var key = (variables.dictClasses[node.mode] || '?') + (types[node.type] || '?');
				if (key.indexOf('?') >= 0) warn && warn(node, "unsupported decl: mode=" + node.mode + ", type=" + node.type)
				return insert(decl, "DECL('" + key + "','" + decl.name + "'" + (decl.lens ? "," + gen(decl.lens) : "") + (decl.ranges ? "," + gen(decl.ranges) : "") + ")")
			}).join("");
		},
		STATEMENT: function(node) {
			used[node.op] = true;
			return insert(node, node.op + "(" + gen(node.lhs) + "," + gen(node.rhs) + ")");
		},
		RAZ: function(node) {
			used.RAZ = true;
			return insert(node, "RAZ([" + node.expressions.map(gen0) + "])");
		},
		DYN: function(node) {
			return gen(node.exp);
		},


		GOSUB: tmp = function(node) {
			used.REQ = true;
			var from = node.from ? "REQ(r," + gen(node.from) + ")" : "C(e)";
			used[node.tag] = true;
			if (!node.label && node.tag != "ONERRGO") throw error(node, "label missing");
			return insert(node, node.tag + "(" + from + (node.label ? ",'" + node.label + "'" : "") + ")")
		},
		ONERRGO: tmp,
		LABEL: function(node) {
			used.GO = true;
			scopeName = node.name;
			return insert(null, "GO(e,'" + node.name + "')", "e." + node.name + "=B(", ");");
		},
		RETURN: function(node) {
			used.RET = true;
			return insert(node, "RET(" + (node.result ? gen(node.result) : "") + ")", " ", ""); // beg is space to force close
		},
		RESUME: function(node) {
			used.RESUME = true;
			return insert(node, "RESUME()", " ", ""); // beg is space to force close
		},
		SUBPROG: tmp = function(node) {
			used.PROG = true;
			scopeName = node.name;
			return insert(null, "", "PROG(e,'" + node.name + "',[" + node.items.map(quote) + "],B(", "));");
		},
		FUNPROG: tmp,
		END: function(node) {
			used.END = true;
			return insert(node, "END(" + (node.result ? gen(node.result) : "") + ")", " ", ""); // beg is space to force close
		},


		CALL: function(node) {
			used.REQ = true;
			var from = node.from ? "REQ(r," + gen(node.from) + ")" : "C(e)";
			used.CALL = true;
			return insert(node, "CALL(" + from + "," + gen(node.name) + ",[" + (node.args || []).map(gen0) + "])");
		},
		FUNC: function(node) {
			used.REQ = true;
			var from = node.from ? "REQ(r," + gen(node.from) + ")" : "C(e)";
			used.CALL = true;
			return "CALL(" + from + "," + gen(node.name) + ",[" + (node.args || []).map(gen0) + "])";
		},


		IF: function(node) {
			used.IF = used.GO = true;
			return insert(node, "IF(" + gen(node.condition) + ",p," + id(node.branch) + ",B(", "", ",GO(p," + id(leaf(node)) + ")))");
		},
		ELSIF: function(node) {
			return insert(node, "", "p[" + id(node) + "]=IF(" + gen(node.condition) + ",p," + id(node.branch) + ",B(", ",GO(p," + id(leaf(node)) + ")));");
		},
		ELSE: function(node) {
			used.GO = true;
			return insert(node, "", "p[" + id(node) + "]=B(", ",GO(p," + id(leaf(node)) + "));");
		},
		ENDIF: genClosing,


		CASE: function(node) {
			used.CASE = true;
			return insert(node, "CASE(" + gen(node.expression) + ",p," + id(node.branch) + "," + id(leaf(node)) + ")", "", "");
		},
		WHEN: function(node) {
			used.WHEN = used.GO = true;
			return insert(node, "", "p[" + id(node) + "]=WHEN([" + node.expressions.map(gen0) + "],p," + id(node.branch) + ",B(", ",GO(p," + id(leaf(node)) + ")));");
		},
		ENDCASE: genClosing,

		KEY: function(node) {
			used.KEY = true;
			return "KEY('" + (node.letter || '') + "','" + (node.abbrev || '') + "','" + (node.field || '') + "'" + (node.indices ? ",[" + node.indices.map(gen0) + "]" : "") + ")";
		},
		FOR: function(node) {
			used.GO = used.DECL = used.SET = used.WHILE = used.V = true;
			var setup;
			if (node.key) {
				used.FORF = true;
				return insert(node, "FORF(" + gen(node.key) + "," + generators.WHERE(node.where) + ",p," + id(node.branch) + ",B(", "", "))");
			} else if (node.from) {
				used.FORV = true;
				return insert(node, "FORV('" + node.varName + "'," + gen(node.from) + "," + gen(node.to) + "," + genDefNull(node.step) + ",p," + id(node.branch) + ",B(", "", "))");
			} else if (node.ins) {
				used.FORIN = true;
				return insert(node, "FORIN('" + node.varName + "',[" + node.ins.map(gen0) + "],p," + id(node.branch) + ",B(", "", "))");
			} else {
				throw error(node, "invalid FOR syntax");
			}
		},
		NEXT: genClosing,
		WHILE: function(node) {
			used.GO = used.WHILE = true;
			//return insert(node, "GO(p," + id(node) + ")", "p[" + id(node) + "]=WHILE(" + gen(node.condition) + ",p," + id(node.branch) + ",B(", "));");
			return insert(node, "WHILE(" + gen(node.condition) + ",p," + id(node.branch) + ",B(", "", "))");
		},
		WEND: genClosing,
		REPEAT: function(node) {
			used.GO = used.WHILE = true;
			return insert(node, "WHILE(" + gen(node.branch.condition) + ",p," + id(node.branch) + ",B(", "", "),true)");
		},
		UNTIL: genClosing,
		BREAK: function(node) {
			used.BREAK = true;
			return insert(node, "BREAK(p," + (node.level ? gen(node.level) : "C(1)") + ')');
		},


		FILES: function(node) {
			// TODO: worry about node.scope
			return node.files.map(function(node) {
				if (node.vars) {
					console.log(error(node, "unsupported FILE syntax").stack);
					//throw error(node, "unsupported FILE syntax");			
				} else {
					var abbrev = node.clas && node.clas.abbrev;
					used.FILEF = true;
					return insert(node, "FILEF(" + gen(node.name) + "," + genDefNull(abbrev) + "," + generators.WHERE(node.where) + "," + genDefNull(node.order) + ")");
				}
			}).join("")
		},
		FILTER: function(node) {
			used.FILTER = true;
			var abbrev = node.clas && node.clas.abbrev;
			return insert(node, "FILTER(" + genDefNull(abbrev) + "," + genDefNull(node.where) + "," + genDefNull(node.order) + ")");
		},
		WHERE: function(node) {
			if (!node) return "null";
			if (!node.exps || node.exps.length !== 1) throw error(node, "unsupported where clause: " + node.exps);
			var exp = node.exps[0];
			var ands = [];
			while (exp.tag === 'OP' && exp.op === 'AND') {
				ands.push(exp.args[0]);
				exp = exp.args[1];
			}
			ands.push(exp);
			used.WHERE = true;
			return "WHERE([" + ands.map(genVariant("SQL")) + "])";
		},
		ORDER: function(node) {
			used.ORDER = true;
			var name = node.keyName ? "'" + node.keyName + "'" : "null";
			return "ORDER(" + name + ",[" + (node.keyBy || []).map(gen0) + "]," + genDefNull(node.keyWith) + ")";
		},
		ORDERITEM: function(node) {
			return "'" + (node.dir < 0 ? '-' : '+') + node.name + "'";
		},
		COLUMN: function(node) {
			return "['" + (node.abbrev || '') + "','" + (node.field) + "']";
		},
		COLUMNS: function(node) {
			used.COLUMNS = true;
			return "COLUMNS('" + (node.clas.abbrev || '') + "'" + (node.columns ? "[" + node.columns.map(gen0) + "]" : '') + ")";
		},
		LINK: function(node) {
			used.LINK = true;
			return insert(node, "LINK('" + node.clas.abbrev + "','" + node.as.abbrev + "',[" + node.items.map(gen0) + "]," //
			+ genDefNull(node.where) + "," + genDefNull(node.order) + ")");
		},
		LINKITEM: function(node) {
			used.LINKITEM = true;
			return "LINKITEM(" + gen(node.key, "SQL") + "," + node.outer + ",[" + node.values.map(genVariant("SQL")) + "])";
		},
		WRITE: function(node) {
			used.WRITE = true;
			var abbrev = node.clas && node.clas.abbrev;
			return insert(node, "WRITE('" + abbrev + "')");
		},
		COMMIT: function(node) {
			used.COMMIT = true;
			return insert(node, "COMMIT()");
		},
		ROLLBACK: function(node) {
			used.ROLLBACK = true;
			return insert(node, "ROLLBACK()");
		},

		OPEN: function(node) {
			used.OPEN = used.CLOSE = true;
			var abbrev = node.using ? node.using.abbrev : '';
			if (node.name) return insert(node, "OPEN('" + abbrev + "'," + gen(node.name) + ",'" + node.mode + "'" + (node.seek ? "," + gen(node.seek) : "") + ")");
			else return insert(node, "CLOSE('" + abbrev + "')")
		},
		IOMODE: function(node) {
			used.IOMODE = true;
			var abbrev = node.using ? node.using.abbrev : '';
			return insert(node, "IOMODE('" + abbrev + "','" + node.mode + "'," + gen(node.value) + ")");
		},
		WRSEQ: function(node) {
			used.WRSEQ = true;
			var abbrev = node.using ? node.using.abbrev : '';
			return insert(node, "WRSEQ('" + abbrev + "'," + gen(node.values) + (node.sep ? "," + gen(node.sep) : "") + ")");
		},


		CALLJS: function(node) {
			used.CALLJS = true;
			return insert(node, "CALLJS(" + gen(node.mode) + "," + gen(node.from) + ",'" + node.name + "'" + (node.args ? ',' + genArray(node.args) : "") + ")");
		},
		ERRBOX: function(node) {
			used.BOX = true;
			// worry about titled, using, etc. later (if ever)
			return insert(node, "BOX('error',[" + gen(node.arg) + "])");
		},
		INFBOX: function(node) {
			used.BOX = true;
			// worry about titled, using, etc. later (if ever)
			return insert(node, "BOX('info',[" + node.args.map(gen0) + "])");
		},
	}

	function genAuto(node, topLevel) {
		used.NIY = true;
		var str = "NIY({";
		var comma = "";
		for (var key in node) {
			if (node.hasOwnProperty(key) && key !== 'line' && key !== 'col' && key !== 'parentLoop' && key !== 'chainType' && key !== 'branch') {
				var val = node[key];
				str += comma + key + ":" + gen0(val);
				comma = ",";
			}
		}
		str += "})"
		//console.log("skipping " + node.tag)
		return topLevel ? insert(node, str) : str;
	}

	function gen(node, variant, topLevel) {
		used.A = true;
		if (node == null) return "C(null)"; // for now
		if (Array.isArray(node)) return ("A([" + node.map(gen0).join(',') + "])");
		if (node.tag == null) return "'" + node.toString() + "'";
		var fn = generators[node.tag];
		if (fn) return fn(node, variant);
		else {
			return genAuto(node, topLevel);
		}

	}

	function genDefNull(node) {
		return node ? gen(node) : "null";
	}

	function gen0(node) { // for map, etc.
		return gen(node);
	}

	function quote(s) {
		return "'" + s + "'";
	}

	function genVariant(variant) {
		return function(node) {
			return gen(node, variant);
		}
	}
	//console.log(node);
	var statements = node.statements;
	//var returns = false;
	for (var i = 0, len = statements.length; i < len; i++) {
		var statement = statements[i];
		while (line < statement.line) {
			result += "\n";
			line++;
		}
		result += gen(statement, false, true);
		//returns = statement.returns;
	}
	result += insert(node, "", "\n", "");

	var head = "var z = require('x3-engine/lib/runtime').instructions,r=require,e=exports,p=[],B=z.B,NL=z.NL";
	for (var key in used) {
		head += "," + key + "=z." + key;
	}
	return head + ";z.BEGIN(module);NL(0);" + result;
}