"use strict";

var t0 = Date.now();
try {
	var fs = require("fs");
	var streams = require("streamline/lib/streams/server/streams");
	var readers = require("streamline/lib/streams/readers");
	var root = __dirname + "/../../../../../SUPERV";

	var fin = new streams.ReadableStream(fs.createReadStream(root + "/superv.sql"));
	fin.setEncoding("ascii");
	var rd = new readers.Reader(fin);
	var wr;

	var line;

	var mode = "",
		count = 0;
	var meta;

	var record = function(columns, values) {
			columns = columns.split(',');
			var i = 0;
			return columns.reduce(function(obj, key) {
				var j = i + 1,
					val;
				var quoted = values[i] === "'";
				if (quoted) {
					while (j < values.length) {
						if (values[j++] === "'") {
							if (values[j] === "'") j++;
							else break;
						}
					}
					val = values.substring(i + 1, j - 1);
				} else if (values[i] === 't' && values.substring(i, i + 9) === "to_date('") {
					if (values.substring(i + 17, i + 30) !== "','DD/MM/RR')") throw new Error('bad date: ' + values.substring(i));
					val = (values[i + 15] < 3 ? "20" : "19") + values.substring(i + 15, i + 17) + "-" + values.substring(i + 12, i + 14) + "-" + values.substring(i + 9, i + 11);
					j = i + 30;
				} else if (values[i] === 't' && values.substring(i, i + 14) === "to_timestamp('") {
					var k = values.indexOf("','DD/MM/RR HH24:MI:SS,FF'", i + 14);
					if (k < i + 32) throw new Error('bad timestamp: ' + values.substring(i));
					val = (values[i + 20] < 3 ? "20" : "19") + values.substring(i + 20, i + 22) + "-" + values.substring(i + 17, i + 19) + "-" + values.substring(i + 14, i + 16);
					val += "T" + values.substring(i + 23, i + 31) + "." + values.substring(i + 32, k);
					j = k + 26;
				} else if (values[i] === 'n' && values.substring(i, i + 4) === 'null') {
					val = null;
					j = i + 4;
				} else {
					j = values.indexOf(/[,)]/, i);
					if (j < i) throw new Error("end of value not found near: " + values.substring(i));
					val = values.substring(i, j);
					val = parseFloat(val);
					if (isNaN(val)) throw new Error("bad value: " + values.substring(i, j) + "\nvalues=" + values);
				}
				if (!/(,|$)/.exec(values[j])) throw new Error("bad value near: " + values.substring(i, j) + '\nvalues=' + values);
				obj[key] = val;
				i = j + 1;
				return obj;
			}, {});
			if (i !== values.length) throw new Error("value trailer: " + values.substring(i));
		}

	while ((line = rd.readItem(_)) != null) {
		line = line.replace(/\r/g, '<CR>')

		if (line.length === 0 || line[0] === '-' || line === ' ' || /^\s*(STORAGE|PCTINCREASE|TABLESPACE|LOB|NOCACHE|REM|SET|PCTFREE)\W.*$/.exec(line)) {
			if (mode === 'insert') {
				wr.write(_, 'null]');
				wr && wr.close(_);
				wr = null;
				mode = "";
			}
			continue;
		}
		var match;
		if (match = /^  CREATE TABLE \"(\w+)\"\.\"(\w+)\"/.exec(line)) {
			console.log("create " + match[2]);
			mode = "create";
			meta = {
				folder: match[1],
				name: match[2],
				columns: {},
				indexes: []
			};
		} else if (mode === "create") {
			if (/^   \) PCTFREE.*/.exec(line)) {
				mode = "";
				fs.writeFile(root + "/schema/" + meta.name + ".json", JSON.stringify(meta, null, '\t'), "utf8", _);
			} else if (match = /^\s*\(?\s*\"(\w+)\" (.*)/.exec(line)) {
				var type = match[2];
				type = type[type.length - 2] === ',' ? type.substring(0, type.length - 2) : type;
				meta.columns[match[1]] = {
					type: type,
					nullable: true
				};
			} else {
				throw new Error("bad create line " + line);
			}
		} else if (match = /^Insert into (\w+)\.(\w+) \(([^)]*)\) values \((.*)/.exec(line)) {
			//throw new Error("interrupted");
			var name = match[2];
			var columns = match[3];
			var values = match[4];
			while (values.substring(values.length - 2, values.length) != ');') {
				line = rd.readItem(_);
				if (!line || values.length > 1000000 || line.indexOf('Insert into') === 0) throw new Error("end of insert not found: " + values);
				values += '<NL>' + line; // TODO: better placeholder
			}
			values = values.substring(0, values.length - 2);

			if (mode !== 'insert') {
				wr && wr.close(_);
				wr = new streams.WritableStream(fs.createWriteStream(root + "/data/" + name + ".json", {
					encoding: "ascii"
				}));
				mode = 'insert';
				count = 0;
				wr.write(_, '[\n');
			}
			count % 10000 === 0 && console.log(name + ": " + count);
			wr.write(_, JSON.stringify(record(columns, values)) + ',\n');
			count++;
		} else if (match = /^\s*CREATE (UNIQUE )?INDEX \"(\w+)\"\.\"(\w+)\" ON \"(\w+)\"\.\"(\w+)\" \(([^)]*)\).*/.exec(line)) {
			var unique = !! match[1],
				indexName = match[3],
				tableName = match[5],
				columns = match[6];
			columns = columns.split(', ').map(function(s) {
				var i = s.indexOf('" DESC');
				return (i > 0 ? '-' : '+') + s.substring(1, i > 0 ? i : s.length - 1);
			});
			if (mode !== 'index') {
				console.log("adding indexes");
				mode = 'index';
			}
			meta = JSON.parse(fs.readFile(root + "/schema/" + tableName + ".json", "utf8", _));
			meta.indexes.push({
				name: indexName,
				unique: unique,
				columns: columns
			});
			fs.writeFile(root + "/schema/" + meta.name + ".json", JSON.stringify(meta, null, '\t'), "utf8", _);
		} else if (match = /^\s*ALTER TABLE \"(\w+)\"\.\"(\w+)\" MODIFY \(\"(\w+)\" NOT NULL ENABLE\);.*/.exec(line)) {
			if (mode !== 'alter') {
				console.log("altering tables");
				mode = 'alter';
			}
			var tableName = match[2],
				column = match[3];
			meta = JSON.parse(fs.readFile(root + "/schema/" + tableName + ".json", "utf8", _));
			meta.columns[column].nullable = false;
			fs.writeFile(root + "/schema/" + meta.name + ".json", JSON.stringify(meta, null, '\t'), "utf8", _);
		} else {
			//throw new Error("bad line " + line);
			if (!wr) wr = new streams.WritableStream(fs.createWriteStream(root + "/remain.sql", {
				encoding: "ascii"
			}));
			wr.write(_, line + '\n');
		}

	}
	if (wr) wr.close(_);
} catch (ex) {
	console.log(ex.stack);
}
console.log("completed in " + (Date.now() - t0) / 1000 + " s");