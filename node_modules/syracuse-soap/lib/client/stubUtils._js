"use strict";

var util = require("util");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var locale = require('streamline-locale');
var stubUtils = require('./stubUtils');
var soapUtils = require('../server/soapUtils');
var types = require('syracuse-core').types;

exports.getSoapStubs = function(_) {
	var db = adminHelper.getCollaborationOrm(_);
	var stubsEntity = db.getEntity(_, "soapStub");
	var instances = db.fetchInstances(_, stubsEntity);

	var insts = [];
	for (var i in instances) {
		var instance = instances[i];
		var serializedInstance = instance.serializeInstance(_);
		insts.push(serializedInstance);
	}
	//console.log("INSTANCES="+JSON.stringify(insts, null,2));
	return insts;
};

exports.getSoapStub = function(_, stubName, context, stubType) {

	if (stubType && stubType !== "stub") {
		var entityName = stubType === "generic-in" ? "soapGeneric" : "soapWebService";
		return soapUtils.getSoapWebService(_, stubName, context, entityName).stub(_);
	} else {

		var db = adminHelper.getCollaborationOrm(_);
		var model = db.model;
		var stubsEntity = model.getEntity(_, "soapStub");
		if (!stubsEntity) throw context.notFound("Entity not found: soapStub");
		var filter = {
			sdataWhere: "name eq '" + stubName + "'"
		};
		var instances = db.fetchInstances(_, stubsEntity, filter);

		// Must not append
		if (instances.length > 1) throw context.notFound(locale.format(module, "severalStubs", stubName));

		if (instances.length !== 1) throw context.notFound(locale.format(module, "stubNotFound", stubName));

		return db.fetchInstance(_, stubsEntity, instances[0].$key);
	}
};

exports.getSoapStubPorts = function(_, stubName, context, serialized, stubType) {
	stubType = stubType || "stub";
	var stub = stubUtils.getSoapStub(_, stubName, context, stubType);

	if (serialized) {
		var ports = stub.ports(_).toArray(_);
		var insts = [];
		for (var i in ports) {
			var instance = ports[i];
			var serializedInstance = instance.serializeInstance(_);
			insts.push(serializedInstance);
		}
		//console.log("INSTANCES="+JSON.stringify(insts, null,2));
		return insts;
	} else {
		return stub.ports(_).toArray(_);
	}
};

exports.getSoapStubPort = function(_, stubName, portName, context, stubType) {
	stubType = stubType || "stub";
	var ports = stubUtils.getSoapStubPorts(_, stubName, context, null, stubType);

	for (var i in ports) {
		if (ports[i].name(_) === portName) return ports[i];
	}

	throw context.notFound(locale.format(module, "stubPortNotFound", portName));

};

exports.getSoapStubPortOperations = function(_, stubName, portName, context, serialized, stubType) {
	stubType = stubType || "stub";
	var port = stubUtils.getSoapStubPort(_, stubName, portName, context, stubType);

	if (serialized) {
		var operations = port.operations(_).toArray(_);
		var insts = [];
		for (var i in operations) {
			var instance = operations[i];
			var serializedInstance = instance.serializeInstance(_);
			insts.push(serializedInstance);
		}
		//console.log("INSTANCES="+JSON.stringify(insts, null,2));
		return insts;
	} else {
		return port.operations(_).toArray(_);
	}
};

exports.getSoapStubPortOperation = function(_, stubName, portName, operationName, context, stubType) {
	stubType = stubType || "stub";
	var operations = stubUtils.getSoapStubPortOperations(_, stubName, portName, context, null, stubType);

	for (var i in operations) {
		if (operations[i].name(_) === operationName) {
			return operations[i];
		}
	}

	throw context.notFound(locale.format(module, "stubPortOpNotFound", operationName));

};

exports.getOperationPrototype = function(_, stubName, portName, operationName, facet, context, stubType) {
	stubType = stubType || "stub";
	var operation = stubUtils.getSoapStubPortOperation(_, stubName, portName, operationName, context, stubType);

	var store;
	if (facet === "$request") {
		store = operation.requestPrototype(_);
	} else if (facet === "$response") {
		store = operation.responsePrototype(_);
	} else {
		throw new Error(locale.format(module, "protoUnavailable"));
	}

	if (!store.fileExists(_)) throw new Error(locale.format(module, "protoFileNotExists"));
	return JSON.parse(store.createReadableStream(_).readAll(_).toString());
};

exports.convertValue = function(name, type, value) {
	//console.log("Convert '" + name + "' value '" + value + "' for type: '" + type);
	try {
		if (value == null) return "";
		switch (type) {
			case null:
			case undefined:
				throw new Error("Type undefined.");
			case "application/x-date":
				return types.date.parse(value).toString();
			case "application/x-time":
				return types.time.parse(value).toString();
			case "application/x-datetime":
				return types.datetime.parse(value).toString();
			case "application/x-uuid":
			case "application/x-password":
			case "application/x-choice":
			case "application/x-string":
			case "text/plain":
				return value;
			case "application/x-integer":
				return parseInt(value, 10);
			case "application/x-real":
			case "application/x-decimal":
				return parseFloat(value);
			case "application/x-boolean":
				if (typeof value === "string") value === 'true';
				return value;
			case "application/x-json":
				return JSON.stringify(value);
			default:
				throw new Error(locale.format(module, "typeNotValid", type));
		}
	} catch (e) {
		throw new Error(locale.format(module, "convertValueErr", util.inspect(value), type, e.safeStack));

	}
};

exports.injectLocalizations = function(translations, proto) {
	if (translations) {
		proto.$localization = {};
		Object.keys(translations).forEach(function(prop) {
			proto.$localization["@" + prop] = translations[prop];
		});
	}
};