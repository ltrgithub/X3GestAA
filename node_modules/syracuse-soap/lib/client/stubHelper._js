"use strict";

var helpers = require('syracuse-core/lib/helpers');
var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var util = require("util");
var fs = require('fs');
var jsxml = require('jsxml');
var streams = require('streamline/lib/streams/streams');
var config = require('syracuse-main/lib/nodeconfig').config;
var soapTracer = require('../common/soapTracer');
var globals = require('streamline/lib/globals');
var forEachKey = helpers.object.forEachKey;



var tracer = soapTracer.create("client");

var __http = "http://schemas.xmlsoap.org/wsdl/http/";
var __http2 = "http://www.w3.org/2003/05/soap/bindings/HTTP/";
var __soapHttp = "http://schemas.xmlsoap.org/soap/http";
var __soap = "http://schemas.xmlsoap.org/wsdl/soap/";
var __soap12 = "http://schemas.xmlsoap.org/wsdl/soap12/";
var __XMLSchema = "http://www.w3.org/2001/XMLSchema";



//// XSD elements
//var _eltMap = {
//	_all: "all",
//	_annotation: "annotation",
//	_any: "any",
//	_anyAttribute: "anyAttribute",
//	_appInfo: "appInfo",
//	_attribute: "attribute",
//	_attributeGroup: "attributeGroup",
//	_choice: "choice",
//	_complexContent: "complexContent",
//	_complexType: "complexType",
//	_documentation: "documentation",
//	_element: "element",
//	_extension: "extension",
//	_field: "field",
//	_group: "group",
//	_import: "import",
//	_include: "include",
//	_key: "key",
//	_keyref: "keyref",
//	_list: "list",
//	_notation: "notation",
//	_redefine: "redefine",
//	_restriction: "restriction",
//	_schema: "schema",
//	_selector: "selector",
//	_sequence: "sequence",
//	_simpleContent: "simpleContent",
//	_simpleType: "simpleType",
//	_union: "union",
//	_unique: "unique"
//}
//
//// XSD restrictions
//var _restrictMap = {
//	_enumeration: "enumeration",
//	_pattern: "pattern",
//	_whiteSpace: "whiteSpace",
//	_length: "length",
//	_minLength: "minLength",
//	_maxLength: "maxLength",
//	_minInclusive: "minInclusive",
//	_maxInclusive: "maxInclusive",
//	_minExclusive: "minExclusive",
//	_maxExclusive: "maxExclusive",
//	_fractionDigits: "fractionDigits",
//	_totalDigits: "totalDigits"
//}

// XSD elements
var _all = "all";
var _annotation = "annotation";
var _any = "any";
var _anyAttribute = "anyAttribute";
var _appInfo = "appInfo";
var _attribute = "attribute";
var _attributeGroup = "attributeGroup";
var _choice = "choice";
var _complexContent = "complexContent";
var _complexType = "complexType";
var _documentation = "documentation";
var _element = "element";
var _extension = "extension";
var _field = "field";
var _group = "group";
var _import = "import";
var _include = "include";
var _key = "key";
var _keyref = "keyref";
var _list = "list";
var _notation = "notation";
var _redefine = "redefine";
var _restriction = "restriction";
var _schema = "schema";
var _selector = "selector";
var _sequence = "sequence";
var _simpleContent = "simpleContent";
var _simpleType = "simpleType";
var _union = "union";
var _unique = "unique";


// XSD restrictions
var _enumeration = "enumeration";
var _pattern = "pattern";
var _whiteSpace = "whiteSpace";
var _length = "length";
var _minLength = "minLength";
var _maxLength = "maxLength";
var _minInclusive = "minInclusive";
var _maxInclusive = "maxInclusive";
var _minExclusive = "minExclusive";
var _maxExclusive = "maxExclusive";
var _fractionDigits = "fractionDigits";
var _totalDigits = "totalDigits";


var stubHelper = helpers.defineClass(function(_, name, wsdl, url, options) {

	this.name = name;
	this.wsdl = wsdl;
	this.options = options;
	
	if (!this.wsdl)
		this.wsdl = this.getWsdl(_, url, options);
	this.ports = [];
	this.warnings = [];
	
}, null, {
	getWsdl: function(_, url, options){
		
		
		tracer.traceSection("Retrieve WSDL from URI: "+url);

		var opt = {
			method: "GET",
			url: url,
			headers: {}
		};
		
		if (options && options.auth){
			if (options.auth.type === "basic"){
				opt.headers.Authorization = "Basic "+new Buffer(options.auth.user+":"+options.auth.password).toString('base64')
			}
		}
		
		
		if (helpers.proxy){
			opt.proxy = "http://"+helpers.proxy.server+":"+helpers.proxy.port;
		}
			
		var request = streams.httpRequest(opt);
		var response = request.end().response(_);
		var body = response.readAll(_);

		if (response.statusCode === 200 && body){
			return body;
		}else{
			throw new Error(response.statusCode + ": "+body);
		}
		
	},
	parseWsdl: function(_){
		
		function addWarning(warn){
			tracer.warning(warn);
			self.warnings.push(warn);
		}
		
//		function getSubNode(node, ns, name){
//			if (!node)
//				return;
//			if (name.indexOf(':') !== -1){
//				return node[name];
//			}else{
//				return ns ? node[ns+":"+name] : node[name];
//			}
//			
//		}
		
		
		function getSubNode(node, ns, name){

			if (!node){
				return;
			}
				
			if (name.indexOf(':') !== -1){
				var sec = splitNs(name).type
				if (node[name]){
					return node[name];
				}else{
					return node[sec];
				}
			}else{

				if (ns && node[ns+":"+name]){
					return node[ns+":"+name];
				}else{
					return node[name];
				}
			}
			
		}

		
		function splitNs(word){
			if (word.indexOf(':') !== -1){
				var splited = word.split(':');
				return {
					ns: splited[0],
					type: splited[1]
				};
			}else{
				return {
					type: word
				};
			}
		}
		
		function checkIntegrity(){
			if (!definitions)
				throw new Error("Root node 'definitions' not found.");
			if (!types)
				throw new Error("No 'types' Node found.");
			if (!message)
				throw new Error("No 'message' node found.");
			if (!portType)
				throw new Error("No 'portType' node found.");
			if (!binding)
				throw new Error("No 'binding' node found.");
			if (!service)
				throw new Error("No 'service' node found.");
		}
		
		function getElement(schema, eltName){
			var elements = getSubNode(schema, xsdNs, _element);
			if (Array.isArray(elements)){
				for (var i in elements){
					if (elements[i].$ && elements[i].$.name === eltName)
						return elements[i];
				}
			}else if (elements){
				if (elements.$ && elements.$.name === eltName)
					return elements;
			}
			return;
		}
		
		function getComplexType(schema, cpName){
			var complexTypes = getSubNode(schema, xsdNs, _complexType);
			if (Array.isArray(complexTypes)){
				for (var i in complexTypes){
					if (complexTypes[i].$ && complexTypes[i].$.name === cpName)
						return complexTypes[i];
				}
			}else if (complexTypes){
				if (complexTypes.$ && complexTypes.$.name === cpName)
					return complexTypes;
			}
			return;
		}
		
		function getSimpleType(schema, spName){
			var simpleTypes = getSubNode(schema, xsdNs, _simpleType);
			if (Array.isArray(simpleTypes)){
				for (var i in simpleTypes){
					if (simpleTypes[i].$ && simpleTypes[i].$.name === spName)
						return simpleTypes[i];
				}
			}else if (simpleTypes){
				if (simpleTypes.$ && simpleTypes.$.name === spName)
					return simpleTypes;
			}
			return;
		}
		
		function getAttribute(schema, attName){
			var attributes = getSubNode(schema, xsdNs, _attribute);
			if (Array.isArray(attributes)){
				for (var i in attributes){
					if (attributes[i].$ && attributes[i].$.name === attName)
						return attributes[i];
				}
			}else if (attributes){
				if (attributes.$ && attributes.$.name === attName)
					return attributes;
			}
			return;
		}
		
		function getNamespaceUrl(prefix){
			var xmlns = "xmlns";
			
			for (var key in definitions.$){
				if (!prefix){
					return definitions.$.xmlns;
				}
				else if (key === (xmlns + ":" + prefix)){
					return definitions.$[key];
				}
					
			}
			throw new Error("No namespace match to prefix: 'xmlns:" + prefix + "'");
		}
			
		function getNamespacePrefix(url){
			var xmlns = "xmlns:";
			
			for (var key in definitions.$){
				if (key.indexOf(xmlns) === 0 && definitions.$[key].indexOf(url) === 0)
					return key.substring(xmlns.length);
			}
			throw new Error("No namespace match to Url: '" + url + "'");
		}
		
		function getSchema(nsPrefix){
			
			function isMatchingSchema(tns, sc){
				if (tns){
					return sc.$.targetNamespace === definitions.$["xmlns:"+tns];
				}else{
					return sc.$.targetNamespace === definitions.$.targetNamespace;
				}
			}
			
			var schemas = getSubNode(types, xsdNs, 'schema');
			if (!schemas)
				schemas = getSubNode(types, null, 'schema');
			
			if (Array.isArray(schemas)){
				for (var i in schemas){
					if (isMatchingSchema(nsPrefix, schemas[i]))
						return schemas[i];
				}
			}else if (schemas){
				if (isMatchingSchema(nsPrefix, schemas))
					return schemas;
			}
			
			throw new Error("No scheme found corresponding to namespace: '"+nsPrefix+"'");
		}
		
		function getMessage(messageName){
			if (messageName.indexOf(':') !== -1)
				messageName = messageName.split(':')[1];
			
			for (var i in messages){
				if (messages[i].$.name === messageName){
					return messages[i];
				}
			}
			throw new Error("Message not found: "+messageName);
		}
		
		
		function getPortType(ptName){
			if (Array.isArray(portTypes)){
				for (var i in portTypes){
					if (portTypes[i].$.name === ptName)
						return portTypes[i];
				}
			}else{
				if (portTypes.$.name === ptName)
					return portTypes;
			}
			throw new Error("PortType not found: "+ptName);
		}
		
		function getBinding(bindingName){
			var binding;
			if (Array.isArray(bindings)){
				for (var i in bindings){
					if (bindings[i].$.name === bindingName)
						return bindings[i];
				}
			}else{
				if (bindings.$.name === bindingName)
					return bindings;
			}
			throw new Error("Binding not found: "+bindingName);
		}
		
		function addPort(_, port){
			

			
			
			function addOperation(_, bindingOperation){
				
				
				
				function createPrototype(_, msgName, store, isInput){
					

					function buildProperty(name, type, constraints, schema){
						
						
						function inspectElement(elt, nature){
							
							function defineProperty(aElt, aProp, isEmbedded, parentConstraints){
								
								if (aElt.$.type){
									var splited = splitNs(aElt.$.type);
									var eltNs = splited.ns;
									var eltType = splited.type;
									setProperty(aProp, aElt, eltNs, eltType, aElt.$);
								}else if (isEmbedded){
									setProperty(aProp, aElt, null, null, parentConstraints);
									//handleElement(aElt);
								}
							}
							
							function handleSequence(sequence){
								if (typeof sequence === 'object')
								forEachKey(sequence, function(key, value) {
									if (key === xsdPrefix + _element){
										if (Array.isArray(value)){
											value.forEach(function(subElement){
												defineProperty(subElement, prop, true, sequence.$);
											});
										}else if (value){
											defineProperty(value, prop, true, sequence.$);
										}
									}else if (key !== '$'){
										addWarning("Handle of sequence '"+elt.$.name+"' sub node: '"+key+"' is not yet implemented");
									}
								});

								// TODO: handle 'any'
							}
							
							function handleRestriction(restriction){
								
								function nyi(_key){
									addWarning("handle '"+_key+"' restriction not yet implemented");
								}
								
								var base = splitNs(restriction.$.base).type;
								if (typeof restriction === 'object')
								forEachKey(restriction, function(key, value) {
									if (key === xsdPrefix + _enumeration){
									// Handle enumerations

										prop.$type = "application/x-choice";
										prop.$value = prop.$value || {};
										prop.$value.$type = convertType(base);
										prop.$value.$enum = [];
										
										if (Array.isArray(value)){
											value.forEach(function(_enum){
												prop.$value.$enum.push({
													$value: _enum.$.value,
													$title: _enum.$.value
												});
											});
										}else{
											prop.$value.$enum.push({
												$value: value.$.value,
												$title: value.$.value
											});
										}
									}
									// Handle pattern
									else if (key === xsdPrefix + _pattern){
										// TODO
										nyi(key);
									}
									// Handle length
									else if (key === xsdPrefix + _length){
										// TODO
										nyi(key);
									}
									// Handle minLength
									else if (key === xsdPrefix + _minLength){
										// TODO
										nyi(key);
									}
									// Handle maxLength
									else if (key === xsdPrefix + _maxLength){
										// TODO
										nyi(key);
									}					
									// Handle whiteSpace
									else if (key === xsdPrefix + _whiteSpace){
										// TODO
										nyi(key);
									}
									// Handle minInclusive
									else if (key === xsdPrefix + _minInclusive){
										// TODO
										nyi(key);
									}
									// Handle maxInclusive
									else if (key === xsdPrefix + _maxInclusive){
										// TODO
										nyi(key);
									}
									// Handle minExclusive
									else if (key === xsdPrefix + _minExclusive){
										// TODO
										nyi(key);
									}
									// Handle maxExclusive
									else if (key === xsdPrefix + _maxExclusive){
										// TODO
										nyi(key);
									}
									// Handle fractionDigits
									else if (key === xsdPrefix + _fractionDigits){
										// TODO
										nyi(key);
									}
									// Handle totalDigits
									else if (key === xsdPrefix + _totalDigits){
										// TODO
										nyi(key);
									}
									else if (key !== '$'){
										nyi(key);
									}
								});

							} // End handleRestriction
														
							function handleComplexType(_cp){
								
								function nyi(_key){
									addWarning("Handle of complexType '"+_cp.$.name+"' sub node: '"+_key+"' is not yet implemented");
								}
								
								var _cp = _cp || elt;
								if (typeof _cp === 'object')
								forEachKey(_cp, function(key, value) {
									// annotation?
									if (key === xsdPrefix + _annotation){
										// TODO
										nyi(key, elt);
									}
									else if (key === xsdPrefix + _simpleContent){
										// TODO
										nyi(key);
									}
									else if (key === xsdPrefix + _complexContent){
										// TODO
										nyi(key);
									}
									else if (key === xsdPrefix + _group){
										// TODO
										nyi(key);
									}
									else if (key === xsdPrefix + _all){
										// TODO
										nyi(key);
									}
									else if (key === xsdPrefix + _choice){
										// TODO
										nyi(key);
									}
									else if (key === xsdPrefix + _sequence){
										handleSequence(value);
									}
									else if (key === xsdPrefix + _attribute){
										if (Array.isArray(value)){
											value.forEach(function(attrib){
												if (attrib.$.type){
													defineProperty(attrib, prop);
												}else{
													defineProperty(attrib, prop, true, _cp.$);
												}
											});
										}else if (value){
											if (value.$.type){
												defineProperty(value, prop);
											}else{
												defineProperty(value, prop, true, _cp.$);
											}
										}
									}
									else if (key === xsdPrefix + _attributeGroup){
										// TODO
										nyi(key);
									}
									else if (key === xsdPrefix + _anyAttribute){
										// TODO
										nyi(key);
									}
									else if (key !== '$'){
										nyi(key);		
									}
								});
							} // handleComplexType
							
							function handleSimpleType(_sp){
								
								function nyi(_key){
									addWarning("Handle of simpleType '"+_sp.$.name+"' sub node: '"+_key+"' is not yet implemented");
								}
								
								var _sp = _sp || elt;
								if (typeof _sp === 'object')
								forEachKey(_sp, function(key, value) {
									if (key === xsdPrefix + _restriction){
										handleRestriction(value);
									}else if (key !== '$'){
										nyi(key);
									}
								});

							} // handleSimpleType
							
							function handleAttribute(_att){
								
								function nyi(_key){
									addWarning("Handle of attribute '"+_att.$.name+"' sub node: '"+_key+"' is not yet implemented");
								}
								
								var _att = _att || elt;
								if (typeof _att === 'object')
								forEachKey(_att, function(key, value) {
									if (key === xsdPrefix + _simpleType){
										handleSimpleType(value);
									}else if (key === xsdPrefix + _annotation){
										// TODO
										nyi(key);
									}else if (key !== '$'){
										nyi(key);
									}
								});

							} // handleAttribute
							
							function handleElement(_elt){
								
								function nyi(_key){
									addWarning("Handle of element '"+_elt.$.name+"' sub node: '"+_key+"' is not yet implemented");
								}
								
								if (typeof _elt === 'object')
								forEachKey(_elt, function(key, value) {
									if (key === xsdPrefix + _complexType){
										handleComplexType(value);
									}else if(key === xsdPrefix + _simpleType){
										handleSimpleType(value);
									}else if(key === "element"){
										// Do nothing: 'element' subNode is only provided by 'message' part and we don't care of it
									}else if (key !== '$'){
										nyi(key);
									}
								});

							} // handleElement
							
							//
							//
							//
							//console.log("Element: "+JSON.stringify(elt,null,2));
							if (elt.$.type){
								defineProperty(elt, prop);

							}else{
								

								if (nature === _complexType){
									handleComplexType();
								}else if (nature === _simpleType){
									handleSimpleType();
								}else if (nature === _attribute){
									handleAttribute();
								}else if (nature === _element){
									handleElement(elt);
								}
							}
							
						} // End inspectElement

						function handleConstraints(){
							
							function nyi(_key){
								addWarning("Handle of element '"+name+"' attribute: '"+_key+"' is not yet implemented");
							}
							
							var ignoreAttributeMap = ['name', 'type', 'element'];
							if (typeof constraints === 'object')
							forEachKey(constraints, function(key, value) {
								//console.log(key + "=" + value);
								if (ignoreAttributeMap.indexOf(key) !== -1){
									// Do nothing: some attributes are not constraints
								}
								else if(key === "minOccurs"){
									if (value !== "0")
										prop.$isMandatory = true;
								}
								else if(key === "maxOccurs"){
									if (value !== "1")
										prop.$type = "application/x-array";
								}
								else if(key === "nillable"){
									if (value !== "true")
										prop.$isNullable = true;
								}
								else{
									nyi(key);
								}
								
								if (!constraints.minOccurs)
									prop.$isMandatory = true;
							});
						}
						tracer.trace("-> Build property '"+name+"' with type: '"+type+"'");

						var xsdPrefix = "";
						var prop = {
							$title: name
						};
						
						handleConstraints();
						
						if (schema){

							if (schema.$.xmlns && (schema.$.xmlns !== getNamespaceUrl(xsdNs)))
								xsdPrefix = xsdNs + ":";
							
							prop.$type = prop.$type || "application/x-object";

							var element = getElement(schema, type);

							if (!element || elementsMap[type]){
								var cp = getComplexType(schema, type);

								if (!cp){
									var sp = getSimpleType(schema, type);
									
									if (!sp){
										var att = getAttribute(schema, type);
										
										if (!att){
											throw new Error("No element match to: "+type);
										}else{
											//console.log("Attribute: "+type+" = "+JSON.stringify(att,null,2));
											attributesMap[type] = att;
											inspectElement(att, _attribute);
										}
									}else{
										//console.log("SimpleType: "+type+" = "+JSON.stringify(sp,null,2));
										simpleTypesMap[type] = sp;
										inspectElement(sp, _simpleType);
									}
								}else{
									//console.log("ComplexType: "+type+" = "+JSON.stringify(cp,null,2));
									complexTypesMap[type] = cp;
									inspectElement(cp, _complexType);
								}
							}else{
								//console.log("Element: "+type+" = "+JSON.stringify(element,null,2));
								elementsMap[type] = element;
								inspectElement(element, _element);
								
							}
						}else if (typeof type === 'object'){
							
							prop.$type = prop.$type || "application/x-object";

							inspectElement(type, _element);
							
						}else{
							prop.$type = convertType(type);
						}
						//console.log("Property builded: "+JSON.stringify(prop,null,2));
						return prop;
					
					} // End buildProperty
					
					function convertType(type){
						switch(type){
							case "string":
								return "application/x-string";
							case "boolean":
								return "application/x-boolean";
							case "float":
							case "double":
							case "decimal":
								return "application/x-decimal";
							case "integer":
							case "int":
							case "long":
							case "short":
								return "application/x-integer";
							case "date":
								return "application/x-date";
							case "time":
								return "application/x-time";
							case "dateTime":
								return "application/x-datetime";
							case "byte":
							case "duration":
							case "hexBinary":
							case "base64Binary":
							case "anyURI":
							case "ID":
							case "IDREF":
							case "ENTITY":
							case "NOTATION":
							case "normalizedString":
							case "token":
							case "language":
							case "IDREFS":
							case "ENTITIES":
							case "NMTOKEN":
							case "NMTOKENS":
							case "Name":
							case "QName":
							case "NCName":
							case "nonNegativeInteger":
							case "positiveInteger":
							case "nonPositiveInteger":
							case "negativeInteger":
							case "unsignedByte":
							case "unsignedInt":
							case "unsignedLong":
							case "unsignedShort":
							case "gYearMonth":
							case "gYear":
							case "gMonthDay":
							case "gDay":
							case "gMonth":
							default:
								addWarning("XMLSchema-datatypes '" + type + "' is not supported yet by Syracuse.");
	
						}
						
					} // End convertType
					

					
					function setProperty(proto, element, ns, type, constraints){
											
						var name = element.$.name;
						//console.log("## Set property: "+name+" | type: "+type);

						var loc;
						
						if (proto.$type === "application/json"){
							proto.$properties = proto.$properties || {};
							loc = proto;
						}else{
							proto.$item = proto.$item || {
								$properties: (proto.$item && proto.$item.$properties) || {}
							};
							loc = proto.$item;
						}
	
						if (!type){
							loc.$properties[name] = buildProperty(name, element, constraints);
						}else if(typeof type === 'string'){
							// native type
							if (getNamespaceUrl(ns).indexOf(__XMLSchema) === 0){
								loc.$properties[name] = buildProperty(name, type, constraints);
							}
							// schema's type
							else{
								loc.$properties[name] = buildProperty(name, type, constraints, getSchema(ns));
							}	
						}

					} // End setProperty
					
					function readMsgPart(part){
						tracer.traceSubSection("Read message part: "+msgName);
						var name = part.$.name;
						
						var partType = part.$.type || part.$.element;

						if (partType){

							var splited = splitNs(partType);
							var partNs = splited.ns;
							var partType = splited.type;

							setProperty(proto, part, partNs, partType, part.$);
							

						}else{
							throw new Error("The part of the message '" + msgName + "' doesn't contain 'element' or 'type' attribute");
						}
					
					} // End readMsgPart
					
					
					var elementsMap = {}, complexTypesMap = {}, simpleTypesMap = {};
					
					var splited = splitNs(msgName);
					var msgNs = splited.ns;
					var msgName = splited.type;

					var facet = isInput ? "$request" : "$response";
					
					var proto = {
						$descriptor: "prototype "+operationName+"." + facet,
						$type: "application/json",
						$prototype: "{$baseUrl}/$prototypes('"+operationName+"."+facet+"')",
						$baseType: "application/json;vnd.sage=syracuse",
						$baseUrl: globals.context.session.host + "/soap-stubs/syracuse/collaboration/syracuse/" + self.name + "/" + port.$.name,
						$value: documentation,
						$title: operationName,
						$description: msgName + " : " + operationName + " : " + documentation,
						$representation: operationName,
						$properties: {}
					};
					
					
					var message = getMessage(msgName);
					var messagePart = getSubNode(message, wsdlNs, 'part');
					if (Array.isArray(messagePart)){
						messagePart.forEach(function(mp){
							readMsgPart(mp);
						});
					}else if (messagePart){
						readMsgPart(messagePart);
					}

					storePrototype(_, msgName, store, JSON.stringify(proto,null,2));

				} // End createPrototype

				function storePrototype(_, prototypeName, instanceProperty, proto){
					//tracer.traceSubSection("Create Prototype: "+prototypeName, proto);
					// Store WSDL
					if (!instanceProperty.fileExists(_)){
						var buf = new Buffer(proto, 'utf8').toString('binary');
						if (buf != null && buf.length !== 0){
							var props = {
									length: buf.length,
									contentType: "application/json",
									fileName: prototypeName + ".json"
							}
							var store = instanceProperty;
							var stream = store.createWritableStream(_, props);
							stream.write(_, buf, "binary");
							stream.write(_, null);
						}
					}else{
						throw new Error("File already exists.");
					}
					
					
					
				} // End storePrototype
				
				
				function getPortTypeOperation(opName){
					if (Array.isArray(portTypeOperations)){
						for (var i in portTypeOperations){
							if (portTypeOperations[i].$.name === opName)
								return portTypeOperations[i];
						}
					}else{
						if (portTypeOperations.$.name === opName)
							return portTypeOperations;
					}
					throw new Error("PortType operation not found: "+opName);
				}
				//
				//
				var operationName = bindingOperation.$.name;
				var portTypeOperation = getPortTypeOperation(operationName);
				tracer.traceSubSection(" - Add Operation: "+operationName);
				
				var entity = model.getEntity("soapStubOperation");
				var operationInstance = entity.factory.createInstance(_, null, db);
				
				operationInstance.name(_, operationName);
				var documentation = getSubNode(portTypeOperation, wsdlNs, 'documentation');
				documentation = (documentation && documentation.$value) || documentation;
				operationInstance.description(_, documentation);
				
				// Set URL of Tester
				operationInstance.tester(_, globals.context.session.host + "/soap-stubs/syracuse/collaboration/syracuse/" + self.name + "/" + port.$.name + "/" + operationName + "?representation=('" + operationName + ".$request')");
				
				var opInfos = getSubNode(bindingOperation, protocolNs, 'operation');
				var opInputEnc = getSubNode(bindingOperation, wsdlNs, 'input')[protocolNs + ":body"];
				var opOutputEnc = getSubNode(bindingOperation, wsdlNs, 'output')[protocolNs + ":body"];
				
				if (protocol === __soap || protocol === __soap12){
					if (opInfos && opInfos.$){
						operationInstance.soapAction(_, opInfos.$.soapAction);
						operationInstance.style(_, opInfos.$.style || (subBindingNode ? subBindingNode.$.style : "document"));
					}else{
						operationInstance.style(_, subBindingNode ? subBindingNode.$.style : "document");
						
					}
					if (opInputEnc && opInputEnc.$)
						operationInstance.inputEncoding(_, opInputEnc.$.use);
					if (opOutputEnc && opOutputEnc.$)
						operationInstance.outputEncoding(_, opOutputEnc.$.use);
					
				}else if (protocol === __http || protocol === __http2){
					if (opInfos && opInfos.$)
						operationInstance.location(_, opInfos.$.location);
				}else{
					throw new Error("Protocol '"+definitions.$["xmlns:"+protocol]+"' is not supported.");
				}
				
				
				var inputName = getSubNode(portTypeOperation, wsdlNs, 'input').$.message;
				operationInstance.inputName(_, inputName);
				createPrototype(_, inputName, operationInstance.inputPrototype(_), true);
				
				var outputName = getSubNode(portTypeOperation, wsdlNs, 'output').$.message;
				operationInstance.outputName(_, outputName);
				createPrototype(_, outputName, operationInstance.outputPrototype(_), false);
				
				
				//console.log("OPERATION SERIALIZED:"+JSON.stringify(operationInstance.serializeInstance(_),null,2));
				
				
				
				portInstance.operations(_).set(_, operationInstance);

			} // End addOperation
			

			
			
			
			tracer.traceSection("Add Port: "+port.$.name);
			
			var soapStubPortEntity = model.getEntity("soapStubPort");
			var portInstance = soapStubPortEntity.factory.createInstance(_, null, db);
			
			portInstance.name(_, port.$.name);
			
			
			var protocolNs, protocol, location;
			Object.keys(port).forEach_(_, function(_, key){
				if (key.indexOf(":address") !== -1){
					protocolNs = key.split(':')[0];
					protocol = definitions.$["xmlns:" + protocolNs];
					location = port[key].$.location;
				}
			});
			
			if (!protocol)
				throw new Error("Port protocol not found.");
			
			if (!location)
				throw new Error("Port location not found.");
			
			portInstance.protocol(_, protocol);
			portInstance.location(_, location);
			
			// Get binding infos
			var bindingName = port.$.binding.indexOf(':') !== -1 ? port.$.binding.split(':')[1] : port.$.binding;
			var binding = getBinding(bindingName);
			
			var subBindingNode = getSubNode(binding, protocolNs, 'binding');
			// Set transport protocol
			var transport;
			if (subBindingNode){
				transport = subBindingNode.$.transport
				if (transport){
					portInstance.transport(_, transport);
				}else{
					portInstance.transport(_, __soapHttp);
				}

				if (protocol.indexOf(__http) === 0 || protocol.indexOf(__http2) === 0){
					var verb = subBindingNode.$.verb;
					portInstance.method(_, verb);
				}else{
					portInstance.method(_, "POST");
				}
			}else{
				portInstance.transport(_, __soapHttp);
				portInstance.method(_, "POST");
			}

			
			// Get portType Infos
			var portTypeName = binding.$.type.indexOf(':') !== -1 ? binding.$.type.split(':')[1] : binding.$.type;
			var portType = getPortType(portTypeName);
			var portTypeOperations = getSubNode(portType, wsdlNs, 'operation');
			
			// Register operations
			var bindingOperations = getSubNode(binding, wsdlNs, 'operation');
			if (Array.isArray(bindingOperations)){
				bindingOperations.forEach_(_, function(_, op){
					addOperation(_, op);
				});
			}else{
				addOperation(_, bindingOperations);
			}
			
			//console.log("PORT:"+JSON.stringify(portInstance.serializeInstance(_),null,2));
			self.ports.push(portInstance);
		}
		
		var self = this;
		var db = adminHelper.getCollaborationOrm(_);
		var model = db.model;
		
		var wsdl = jsxml.parse(self.wsdl);
		//console.log("WSDL="+JSON.stringify(wsdl,null,2));
		var rootNode = Object.keys(wsdl)[0];
		
		var wsdlNs = rootNode.split(':').length === 2 ? rootNode.split(':')[0] : "";
		
		
		var definitions = getSubNode(wsdl, wsdlNs, 'definitions');
		var types = getSubNode(definitions, wsdlNs, 'types');
		var messages = getSubNode(definitions, wsdlNs, 'message');
		var portTypes = getSubNode(definitions, wsdlNs, 'portType');
		var bindings = getSubNode(definitions, wsdlNs, 'binding');
		var service = getSubNode(definitions, wsdlNs, 'service');

		self.description = service.documentation;
		
		var xsdNs = getNamespacePrefix(__XMLSchema);
		


		
		
		
		
		
		var ports = getSubNode(service, wsdlNs, 'port');

		if (Array.isArray(ports)){
			ports.forEach_(_, function(_, p){
				addPort(_, p);
			});
		}else{
			addPort(_, ports);
		}

		
	}

});



exports.create = function(_, name, wsdl, url, options){
	try{

		var stub = new stubHelper(_, name, wsdl, url, options);
		
		stub.parseWsdl(_);

		return stub;
	}catch(e){
		console.error("STACK="+e.stack);
		throw new Error(e.message);
	}
}