"use strict";

var helpers = require('syracuse-core/lib/helpers');
var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var util = require("util");
var fs = require('fs');
var jsxml = require('jsxml');
var streams = require('streamline/lib/streams/streams');
var config = require('syracuse-main/lib/nodeconfig').config;
var soapTracer = require('../common/soapTracer');
var globals = require('streamline/lib/globals');
var forEachKey = helpers.object.forEachKey;



var tracer = soapTracer.create("client");

var __http = "http://schemas.xmlsoap.org/wsdl/http/";
var __soap = "http://schemas.xmlsoap.org/wsdl/soap/";
var __soap12 = "http://schemas.xmlsoap.org/wsdl/soap12/";
var __XMLSchema = "http://www.w3.org/2001/XMLSchema";



var stubHelper = helpers.defineClass(function(_, name, wsdl, url, options) {

	this.name = name;
	this.wsdl = wsdl;
	this.options = options;
	
	if (!this.wsdl)
		this.wsdl = this.getWsdl(_, url, options);
	this.ports = [];
	
}, null, {
	getWsdl: function(_, url, options){
		
		
		tracer.traceSection("Retrieve WSDL from URI: "+url);

		var opt = {
			method: "GET",
			url: url,
			headers: {}
		};
		
		if (options && options.auth){
			if (options.auth.type === "basic"){
				opt.headers.Authorization = "Basic "+new Buffer(options.auth.user+":"+options.auth.password).toString('base64')
			}
		}
		
		
		if (helpers.proxy){
			opt.proxy = "http://"+helpers.proxy.server+":"+helpers.proxy.port;
		}
			
		var request = streams.httpRequest(opt);
		var response = request.end().response(_);
		var body = response.readAll(_);

		if (response.statusCode === 200 && body){
			return body;
		}else{
			throw new Error(response.statusCode + ": "+body);
		}
		
	},
	parseWsdl: function(_){
		

		
		function getSubNode(node, ns, name){
			return ns ? node[ns+":"+name] : node[name];
		}
		
		function splitNs(word){
			if (word.indexOf(':') !== -1){
				var splited = word.split(':');
				return {
					ns: splited[0],
					type: splited[1]
				};
			}else{
				return {
					type: word
				};
			}
		}
		
		function checkIntegrity(){
			if (!definitions)
				throw new Error("Root node 'definitions' not found.");
			if (!types)
				throw new Error("No 'types' Node found.");
			if (!message)
				throw new Error("No 'message' node found.");
			if (!portType)
				throw new Error("No 'portType' node found.");
			if (!binding)
				throw new Error("No 'binding' node found.");
			if (!service)
				throw new Error("No 'service' node found.");
		}
		
		function getElement(schema, eltName){
			var elements = getSubNode(schema, xsdNs, "element");
			if (Array.isArray(elements)){
				for (var i in elements){
					if (elements[i].$ && elements[i].$.name === eltName)
						return elements[i];
				}
			}else if (elements){
				if (elements.$ && elements.$.name === eltName)
					return elements;
			}
			return;
		}
		
		function getComplexType(schema, cpName){
			var complexTypes = getSubNode(schema, xsdNs, "complexType");
			if (Array.isArray(complexTypes)){
				for (var i in complexTypes){
					if (complexTypes[i].$ && complexTypes[i].$.name === cpName)
						return complexTypes[i];
				}
			}else if (complexTypes){
				if (complexTypes.$ && complexTypes.$.name === cpName)
					return complexTypes;
			}
			return;
		}
		
		function getNamespaceUrl(prefix){
			var xmlns = "xmlns:";
			
			for (var key in definitions.$){
				if (key === (xmlns + prefix))
					return definitions.$[key];
			}
			throw new Error("No namespace match to prefix: 'xmlns:" + prefix + "'");
		}
			
		function getNamespacePrefix(url){
			var xmlns = "xmlns:";
			
			for (var key in definitions.$){
				if (key.indexOf(xmlns) === 0 && definitions.$[key].indexOf(url) === 0)
					return key.substring(xmlns.length);
			}
			throw new Error("No namespace match to Url: '" + url + "'");
		}
		
		function getSchema(nsPrefix){
			
			function isMatchingSchema(tns, sc){
				if (tns){
					return sc.$.targetNamespace === definitions.$["xmlns:"+tns];
				}else{
					return sc.$.targetNamespace === definitions.$.targetNamespace;
				}
			}
			
			var schemas = getSubNode(types, xsdNs, 'schema');

			if (Array.isArray(schemas)){
				for (var i in schemas){
					if (isMatchingSchema(nsPrefix, schemas[i]))
						return schemas[i];
				}
			}else{
				if (isMatchingSchema(nsPrefix, schemas))
					return schemas;
			}
			throw new Error("No scheme found corresponding to namespace: '"+pNs+"'");
		}
		
		function getMessage(messageName){
			if (messageName.indexOf(':') !== -1)
				messageName = messageName.split(':')[1];
			
			for (var i in messages){
				if (messages[i].$.name === messageName){
					return messages[i];
				}
			}
			throw new Error("Message not found: "+messageName);
		}
		
		
		function getPortType(ptName){
			if (Array.isArray(portTypes)){
				for (var i in portTypes){
					if (portTypes[i].$.name === ptName)
						return portTypes[i];
				}
			}else{
				if (portTypes.$.name === ptName)
					return portTypes;
			}
			throw new Error("PortType not found: "+ptName);
		}
		
		function getBinding(bindingName){
			var binding;
			if (Array.isArray(bindings)){
				for (var i in bindings){
					if (bindings[i].$.name === bindingName)
						return bindings[i];
				}
			}else{
				if (bindings.$.name === bindingName)
					return bindings;
			}
			throw new Error("Binding not found: "+bindingName);
		}
		
		function addPort(_, port){
			

			
			
			function addOperation(_, bindingOperation){
				
				
				
				function createPrototype(_, msgName, store){
					

					function buildProperty(name, type, schema, searchInCp){
						
						
						function setElement(element, isComplexType){
							if (element.$.type){
								console.log("referenced type");
								
								
								var splited = splitNs(element.$.type);
								var eltNs = splited.ns;
								var eltType = splited.type;
								
								if (eltType !== type){
									console.log("new type");
									setProperty(prop, element.$.name, eltNs, eltType);
								}else{
									console.log("same type");
									setProperty(prop, element.$.name, eltNs, eltType, true);
								}
								
								
							}else{
								console.log("embedded complexType");
								if (!parent)
									parent = type;
								tracer.trace("-> Parent: '"+parent+"'");
								var cp = isComplexType ? element : getSubNode(element, xsdNs, "complexType");
								if (cp){
							
									var subElements = getSubNode(getSubNode(cp, xsdNs, "sequence"), xsdNs, "element");
									if (Array.isArray(subElements)){
										for (var i in subElements){
											var splited = splitNs(subElements[i].$.type);
											var subEltNs = splited.ns;
											var subEltType = splited.type;
											
											setProperty(prop, subElements[i].$.name, subEltNs, subEltType);
											
										}
									}else if (subElements){
										var splited = splitNs(subElements.$.type);
										var subEltNs = splited.ns;
										var subEltType = splited.type;
										
										setProperty(prop, subElements.$.name, subEltNs, subEltType);
										
									}
								
								}else{
									throw new Error("No information found on element: '"+element.$.name+"'");
								}
							}
						}
						

						var parent;

						
						
						tracer.trace("-> Build property '"+name+"' with type: '"+type+"'");

						var prop = {
							$title: name
						};
						

						switch(type){
							case "string":
								prop.$type = "application/x-string";
								return prop;
							case "boolean":
								prop.$type = "application/x-boolean";
								return prop;
							case "float":
							case "double":
							case "decimal":
								prop.$type = "application/x-decimal";
								return prop;
							case "integer":
							case "int":
							case "long":
							case "short":
								prop.$type = "application/x-integer";
								return prop;
							case "date":
								prop.$type = "application/x-date";
								return prop;
							case "time":
								prop.$type = "application/x-time";
								return prop;
							case "dateTime":
								prop.$type = "application/x-datetime";
								return prop;
							case "byte":
							case "duration":
							case "hexBinary":
							case "base64Binary":
							case "anyURI":
							case "ID":
							case "IDREF":
							case "ENTITY":
							case "NOTATION":
							case "normalizedString":
							case "token":
							case "language":
							case "IDREFS":
							case "ENTITIES":
							case "NMTOKEN":
							case "NMTOKENS":
							case "Name":
							case "QName":
							case "NCName":
							case "nonNegativeInteger":
							case "positiveInteger":
							case "nonPositiveInteger":
							case "negativeInteger":
							case "unsignedByte":
							case "unsignedInt":
							case "unsignedLong":
							case "unsignedShort":
							case "gYearMonth":
							case "gYear":
							case "gMonthDay":
							case "gDay":
							case "gMonth":
								throw new Error("XMLSchema-datatypes '" + type + "' is not supported yet by Syracuse.");
							default:
								prop.$type = "application/json";
							
								prop.$properties = {};
							
								var element = getElement(schema, type);
								//console.log("Element: "+name+" = "+JSON.stringify(element,null,2));
								
								
								if (searchInCp || !element){
									var cp = getComplexType(schema, type);
									setElement(cp, true);
								}else{
									setElement(element);
								}
									
								

								

								
								
								return prop;
							
							
						}
						
					}
					
					function setProperty(proto, name, ns, type, searchInCp){
						// native type
						if (getNamespaceUrl(ns).indexOf(__XMLSchema) === 0){
							proto.$properties[name] = buildProperty(name, type);
						}
						// schema's type
						else{
							proto.$properties[name] = buildProperty(name, type, getSchema(ns), searchInCp);
						}	
					}
					
					function readMsgPart(part){
						tracer.traceSubSection("Read message part: "+msgName,JSON.stringify(part,null,2));
						var name = part.$.name;
						
						var partType = part.$.type || part.$.element;

						if (partType){
							var splited = splitNs(partType);
							var partNs = splited.ns;
							var partType = splited.type;

							setProperty(proto, name, partNs, partType);
							

						}else{
							throw new Error("The part of the message '" + msgName + "' doesn't contain 'element' or 'type' attribute");
						}
					
					}
					
					
					var splited = splitNs(msgName);
					var msgNs = splited.ns;
					var msgName = splited.type;

					
					var proto = {
						$descriptor: "prototype "+operationName+".$request",
						$type: "application/json",
						$prototype: globals.context.session.host + "/soap-stubs/syracuse/collaboration/syracuse/" + self.name + "/" + port.$.name + "/$prototypes('"+operationName+".$request')",
						$baseType: "application/json;vnd.sage=syracuse",
						$baseUrl: globals.context.session.host + "/soap-stubs/syracuse/collaboration/syracuse/" + self.name + "/" + port.$.name,
						$value: documentation,
						$title: operationName,
						$description: msgName + " : " + operationName + " : " + documentation,
						$representation: operationName,
						$properties: {}
					};
					
					
					var message = getMessage(msgName);
					var messagePart = getSubNode(message, wsdlNs, 'part');
					if (Array.isArray(messagePart)){
						messagePart.forEach(function(mp){
							readMsgPart(mp);
						});
					}else{
						readMsgPart(messagePart);
					}

					storePrototype(_, msgName, store, JSON.stringify(proto,null,2));

				} // End createPrototype

				function storePrototype(_, prototypeName, instanceProperty, proto){
					tracer.traceSubSection("Create Prototype: "+prototypeName, proto);
					// Store WSDL
					if (!instanceProperty.fileExists(_)){
						var buf = new Buffer(proto, 'utf8').toString('binary');
						if (buf != null && buf.length !== 0){
							var props = {
									length: buf.length,
									contentType: "application/json",
									fileName: prototypeName + ".json"
							}
							var store = instanceProperty;
							var stream = store.createWritableStream(_, props);
							stream.write(_, buf, "binary");
							stream.write(_, null);
						}
					}else{
						throw new Error("File already exists.");
					}
					
					
					
				} // End storePrototype
				
				
				function getPortTypeOperation(opName){
					if (Array.isArray(portTypeOperations)){
						for (var i in portTypeOperations){
							if (portTypeOperations[i].$.name === opName)
								return portTypeOperations[i];
						}
					}else{
						if (portTypeOperations.$.name === opName)
							return portTypeOperations;
					}
					throw new Error("PortType operation not found: "+opName);
				}
				//
				//
				var operationName = bindingOperation.$.name;
				var portTypeOperation = getPortTypeOperation(operationName);
				tracer.trace(" - Add Operation: "+operationName);
				
				var entity = model.getEntity("soapStubOperation");
				var operationInstance = entity.factory.createInstance(_, null, db);
				
				operationInstance.name(_, operationName);
				var documentation = getSubNode(portTypeOperation, wsdlNs, 'documentation');
				documentation = (documentation && documentation.$value) || documentation;
				operationInstance.description(_, documentation);
				
				// Set URL of Tester
				operationInstance.tester(_, globals.context.session.host + "/syracuse-main/html/main.html?url=/soap-stubs/syracuse/collaboration/syracuse/" + self.name + "/" + port.$.name + "/$prototypes('" + operationName + ".$request')");
				
				var opInfos = getSubNode(bindingOperation, protocolNs, 'operation');
				var opInputEnc = getSubNode(bindingOperation, wsdlNs, 'input')[protocolNs + ":body"];
				var opOutputEnc = getSubNode(bindingOperation, wsdlNs, 'output')[protocolNs + ":body"];
				
				if (protocol === __soap || protocol === __soap12){
					operationInstance.soapAction(_, opInfos.$.soapAction);
					operationInstance.style(_, opInfos.$.style);
					if (opInputEnc)
						operationInstance.inputEncoding(_, opInputEnc.$.use);
					if (opOutputEnc)
						operationInstance.outputEncoding(_, opOutputEnc.$.use);
				}else if (protocol === __http){
					operationInstance.location(_, opInfos.$.location);
				}else{
					throw new Error("Protocol '"+definitions.$["xmlns:"+protocol]+"' is not supported.");
				}
				
				
				var inputName = getSubNode(portTypeOperation, wsdlNs, 'input').$.message;
				operationInstance.inputName(_, inputName);
				createPrototype(_, inputName, operationInstance.inputPrototype(_));
				
				var outputName = getSubNode(portTypeOperation, wsdlNs, 'output').$.message;
				operationInstance.outputName(_, outputName);
				createPrototype(_, outputName, operationInstance.outputPrototype(_));
				
				
				//console.log("OPERATION SERIALIZED:"+JSON.stringify(operationInstance.serializeInstance(_),null,2));
				
				
				
				portInstance.operations(_).set(_, operationInstance);

			} // End addOperation
			

			
			
			
			tracer.traceSection("Add Port: "+port.$.name);
			
			var soapStubPortEntity = model.getEntity("soapStubPort");
			var portInstance = soapStubPortEntity.factory.createInstance(_, null, db);
			
			portInstance.name(_, port.$.name);
			
			
			var protocolNs, protocol, location;
			Object.keys(port).forEach_(_, function(_, key){
				if (key.indexOf(":address") !== -1){
					protocolNs = key.split(':')[0];
					protocol = definitions.$["xmlns:" + protocolNs];
					location = port[key].$.location;
				}
			});
			
			if (!protocol)
				throw new Error("Port protocol not found.");
			
			if (!location)
				throw new Error("Port location not found.");
			
			portInstance.protocol(_, protocol);
			portInstance.location(_, location);
			
			// Get binding infos
			var bindingName = port.$.binding.indexOf(':') !== -1 ? port.$.binding.split(':')[1] : port.$.binding;
			var binding = getBinding(bindingName);
			
			// Set transport protocol
			var transport = getSubNode(binding, protocolNs, 'binding').$.transport
			if (transport){
				portInstance.transport(_, transport);
			}else if (protocol.indexOf("http://schemas.xmlsoap.org/wsdl/http") === 0){
				var verb = getSubNode(binding, protocolNs, 'binding').$.verb;
				portInstance.transport(_, verb);
			}else{
				throw new Error("Port protocol transport unknow.");
			}
			
			// Get portType Infos
			var portTypeName = binding.$.type.indexOf(':') !== -1 ? binding.$.type.split(':')[1] : binding.$.type;
			var portType = getPortType(portTypeName);
			var portTypeOperations = getSubNode(portType, wsdlNs, 'operation');
			
			// Register operations
			var bindingOperations = getSubNode(binding, wsdlNs, 'operation');
			if (Array.isArray(bindingOperations)){
				bindingOperations.forEach_(_, function(_, op){
					addOperation(_, op);
				});
			}else{
				addOperation(_, bindingOperations);
			}
			
			//console.log("PORT:"+JSON.stringify(portInstance.serializeInstance(_),null,2));
			self.ports.push(portInstance);
		}
		
		var self = this;
		var db = adminHelper.getCollaborationOrm(_);
		var model = db.model;
		
		var wsdl = jsxml.parse(self.wsdl);
		//console.log("WSDL="+JSON.stringify(wsdl,null,2));
		var rootNode = Object.keys(wsdl)[0];
		
		var wsdlNs = rootNode.split(':').length === 2 ? rootNode.split(':')[0] : "";
		
		
		var definitions = getSubNode(wsdl, wsdlNs, 'definitions');
		var types = getSubNode(definitions, wsdlNs, 'types');
		var messages = getSubNode(definitions, wsdlNs, 'message');
		var portTypes = getSubNode(definitions, wsdlNs, 'portType');
		var bindings = getSubNode(definitions, wsdlNs, 'binding');
		var service = getSubNode(definitions, wsdlNs, 'service');

		self.description = service.documentation;
		
		var xsdNs = getNamespacePrefix(__XMLSchema);

		var ports = getSubNode(service, wsdlNs, 'port');

		if (Array.isArray(ports)){
			ports.forEach_(_, function(_, p){
				addPort(_, p);
			});
		}else{
			addPort(_, ports);
		}

		
	}

});



exports.create = function(_, name, wsdl, url, options){
	try{

		var stub = new stubHelper(_, name, wsdl, url, options);
		
		stub.parseWsdl(_);

		return stub;
	}catch(e){
		console.error("STACK="+e.stack);
		throw new Error(e.message);
	}
}