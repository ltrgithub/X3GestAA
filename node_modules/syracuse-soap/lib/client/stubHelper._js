"use strict";

var helpers = require('syracuse-core/lib/helpers');
var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var util = require("util");
var fs = require('fs');
var jsxml = require('jsxml');
var streams = require('streamline/lib/streams/streams');
var config = require('syracuse-main/lib/nodeconfig').config;
var soapTracer = require('../common/soapTracer');
var stubUtils = require('./stubUtils');
var globals = require('streamline/lib/globals');
var forEachKey = helpers.object.forEachKey;



var tracer = soapTracer.create("client");

var __http = "http://schemas.xmlsoap.org/wsdl/http/";
var __http2 = "http://www.w3.org/2003/05/soap/bindings/HTTP/";
var __soapHttp = "http://schemas.xmlsoap.org/soap/http";
var __soap = "http://schemas.xmlsoap.org/wsdl/soap/";
var __soap12 = "http://schemas.xmlsoap.org/wsdl/soap12/";
var __XMLSchema = "http://www.w3.org/2001/XMLSchema";


var _primitive = "primitive";
// XSD elements
var _all = "all";
var _annotation = "annotation";
var _any = "any";
var _anyAttribute = "anyAttribute";
var _appInfo = "appInfo";
var _attribute = "attribute";
var _attributeGroup = "attributeGroup";
var _choice = "choice";
var _complexContent = "complexContent";
var _complexType = "complexType";
var _documentation = "documentation";
var _element = "element";
var _extension = "extension";
var _field = "field";
var _group = "group";
var _import = "import";
var _include = "include";
var _key = "key";
var _keyref = "keyref";
var _list = "list";
var _notation = "notation";
var _redefine = "redefine";
var _restriction = "restriction";
var _schema = "schema";
var _selector = "selector";
var _sequence = "sequence";
var _simpleContent = "simpleContent";
var _simpleType = "simpleType";
var _union = "union";
var _unique = "unique";


// XSD restrictions
var _enumeration = "enumeration";
var _pattern = "pattern";
var _whiteSpace = "whiteSpace";
var _length = "length";
var _minLength = "minLength";
var _maxLength = "maxLength";
var _minInclusive = "minInclusive";
var _maxInclusive = "maxInclusive";
var _minExclusive = "minExclusive";
var _maxExclusive = "maxExclusive";
var _fractionDigits = "fractionDigits";
var _totalDigits = "totalDigits";


var stubHelper = helpers.defineClass(function(_, name, wsdl, url, options) {

	this.name = name;
	this.wsdl = wsdl;
	this.options = options;
	
	if (!this.wsdl)
		this.wsdl = this.getWsdl(_, url, options);
	this.ports = [];
	this.warnings = [];
	
}, null, {
	getWsdl: function(_, url, options){
		
		
		tracer.traceSection("Retrieve WSDL from URI: "+url);

		var opt = {
			method: "GET",
			url: url,
			headers: {}
		};
		
		if (options && options.auth){
			if (options.auth.type === "basic"){
				opt.headers.Authorization = "Basic "+new Buffer(options.auth.user+":"+options.auth.password).toString('base64')
			}
		}
		
		
		if (helpers.proxy){
			opt.proxy = "http://"+helpers.proxy.server+":"+helpers.proxy.port;
		}
			
		var request = streams.httpRequest(opt);
		var response = request.end().response(_);
		var body = response.readAll(_);

		if (response.statusCode === 200 && body){
			return body;
		}else{
			throw new Error(response.statusCode + ": "+body);
		}
		
	},
	parseWsdl: function(_){
		
		function addWarning(warn){
			tracer.warning(warn);
			self.warnings.push(warn);
		}
		

		function getSubNode(node, ns, name){

			if (!node){
				return;
			}
				
			if (name.indexOf(':') !== -1){
				var sec = splitNs(name).type
				if (node[name]){
					return node[name];
				}else{
					return node[sec];
				}
			}else{

				if (ns && node[ns+":"+name]){
					return node[ns+":"+name];
				}else{
					return node[name];
				}
			}
			
		}

		
		function splitNs(word){
			if (word.indexOf(':') !== -1){
				var splited = word.split(':');
				return {
					ns: splited[0],
					type: splited[1]
				};
			}else{
				return {
					type: word
				};
			}
		}
		
		function checkIntegrity(){
			if (!definitions)
				throw new Error("Root node 'definitions' not found.");
			if (!types)
				throw new Error("No 'types' Node found.");
			if (!message)
				throw new Error("No 'message' node found.");
			if (!portType)
				throw new Error("No 'portType' node found.");
			if (!binding)
				throw new Error("No 'binding' node found.");
			if (!service)
				throw new Error("No 'service' node found.");
		}
		
		function getElement(schema, eltName){
			var elements = getSubNode(schema, xsdNs, _element);
			if (Array.isArray(elements)){
				for (var i in elements){
					if (elements[i].$ && elements[i].$.name === eltName)
						return elements[i];
				}
			}else if (elements){
				if (elements.$ && elements.$.name === eltName)
					return elements;
			}
			return;
		}
		
		function getComplexType(schema, cpName){
			var complexTypes = getSubNode(schema, xsdNs, _complexType);
			if (Array.isArray(complexTypes)){
				for (var i in complexTypes){
					if (complexTypes[i].$ && complexTypes[i].$.name === cpName)
						return complexTypes[i];
				}
			}else if (complexTypes){
				if (complexTypes.$ && complexTypes.$.name === cpName)
					return complexTypes;
			}
			return;
		}
		
		function getSimpleType(schema, spName){
			var simpleTypes = getSubNode(schema, xsdNs, _simpleType);
			if (Array.isArray(simpleTypes)){
				for (var i in simpleTypes){
					if (simpleTypes[i].$ && simpleTypes[i].$.name === spName)
						return simpleTypes[i];
				}
			}else if (simpleTypes){
				if (simpleTypes.$ && simpleTypes.$.name === spName)
					return simpleTypes;
			}
			return;
		}
		
		function getType(schema, tName){
			var cp = getComplexType(schema, tName);
			if (cp)
				return cp;
			var sp = getSimpleType(schema, tName);
			if (sp)
				return sp;
			return;
		}
		
		function getAttribute(schema, attName){
			var attributes = getSubNode(schema, xsdNs, _attribute);
			if (Array.isArray(attributes)){
				for (var i in attributes){
					if (attributes[i].$ && attributes[i].$.name === attName)
						return attributes[i];
				}
			}else if (attributes){
				if (attributes.$ && attributes.$.name === attName)
					return attributes;
			}
			return;
		}
		
		function getNamespaceUrl(prefix){
			var xmlns = "xmlns";
			
			for (var key in definitions.$){
				if (!prefix){
					return definitions.$.xmlns;
				}
				else if (key === (xmlns + ":" + prefix)){
					return definitions.$[key];
				}
					
			}
			throw new Error("No namespace match to prefix: 'xmlns:" + prefix + "'");
		}
			
		function getNamespacePrefix(url){
			var xmlns = "xmlns:";
			
			for (var key in definitions.$){
				if (key.indexOf(xmlns) === 0 && definitions.$[key].indexOf(url) === 0)
					return key.substring(xmlns.length);
			}
			throw new Error("No namespace match to Url: '" + url + "'");
		}
		
		function getSchema(nsPrefix){
			
			function isMatchingSchema(tns, sc){
				if (tns){
					return sc.$.targetNamespace === definitions.$["xmlns:"+tns];
				}else{
					return sc.$.targetNamespace === definitions.$.targetNamespace;
				}
			}
			
			var schemas = getSubNode(types, xsdNs, 'schema');

			if (!schemas)
				schemas = getSubNode(types, null, 'schema');

			if (Array.isArray(schemas)){
				for (var i in schemas){
					if (isMatchingSchema(nsPrefix, schemas[i]))
						return schemas[i];
				}
			}else if (schemas){
				if (isMatchingSchema(nsPrefix, schemas))
					return schemas;
			}
			
			throw new Error("No scheme found corresponding to namespace: '"+nsPrefix+"'");
		}
		
		function getMessage(messageName){
			if (messageName.indexOf(':') !== -1)
				messageName = messageName.split(':')[1];
			
			for (var i in messages){
				if (messages[i].$.name === messageName){
					return messages[i];
				}
			}
			throw new Error("Message not found: "+messageName);
		}
		
		
		function getPortType(ptName){
			if (Array.isArray(portTypes)){
				for (var i in portTypes){
					if (portTypes[i].$.name === ptName)
						return portTypes[i];
				}
			}else{
				if (portTypes.$.name === ptName)
					return portTypes;
			}
			throw new Error("PortType not found: "+ptName);
		}
		
		function getBinding(bindingName){
			var binding;
			if (Array.isArray(bindings)){
				for (var i in bindings){
					if (bindings[i].$.name === bindingName)
						return bindings[i];
				}
			}else{
				if (bindings.$.name === bindingName)
					return bindings;
			}
			throw new Error("Binding not found: "+bindingName);
		}
		
		function addPort(_, port){
			

			
			
			function addOperation(_, bindingOperation){
				
				
				
				function createPrototype(_, content, store, facet){
					

					function buildProperty(name, element, nature, constraints, schema){
						
						var params = {name: name, nature: nature, constraints: constraints, useSchema: schema != null};
						//tracer.trace("-> Build property :"+JSON.stringify(params,null,2));

							
						function defineProperty(aElt, aProp, aNature, isEmbedded){
							
							if (aElt.$.type){
								var splited = splitNs(aElt.$.type);
								var eltNs = splited.ns;
								var eltType = splited.type;
								setProperty(aProp, aElt, eltNs, aNature);
							}else if (isEmbedded){
								setProperty(aProp, aElt, null, aNature);
							}
						}
						
						function handleSequence(sequence){
							
							if (typeof sequence === 'object')
							forEachKey(sequence, function(key, value) {
								if (key === xsdPrefix + _element){
									if (Array.isArray(value)){
										value.forEach(function(subElement){
											defineProperty(subElement, prop, _element, true);
										});
									}else if (value){
										defineProperty(value, prop, _element, true);
									}
								}else if (key !== '$'){
									addWarning("Handle of sequence '"+element.$.name+"' sub node: '"+key+"' is not yet implemented");
								}
							});

							// TODO: handle 'any'
						}
						
						function handleRestriction(restriction){
							
							function nyi(_key){
								addWarning("handle '"+_key+"' restriction not yet implemented");
							}
							
							var base = splitNs(restriction.$.base).type;
							if (typeof restriction === 'object')
							forEachKey(restriction, function(key, value) {
								if (key === xsdPrefix + _enumeration){
								// Handle enumerations

									prop.$type = "application/x-choice";
									prop.$value = prop.$value || {};
									prop.$value.$type = convertType(base);
									prop.$value.$enum = [];
									
									if (Array.isArray(value)){
										value.forEach(function(_enum){
											prop.$value.$enum.push({
												$value: _enum.$.value,
												$title: _enum.$.value
											});
										});
									}else{
										prop.$value.$enum.push({
											$value: value.$.value,
											$title: value.$.value
										});
									}
								}
								// Handle pattern
								else if (key === xsdPrefix + _pattern){
									prop.$pattern = value;
								}
								// Handle length
								else if (key === xsdPrefix + _length){
									var len = parseInt(value);
									prop.$minLength = len;
									prop.$maxLength = len;
								}
								// Handle minLength
								else if (key === xsdPrefix + _minLength){
									prop.$minLength = parseInt(value);
								}
								// Handle maxLength
								else if (key === xsdPrefix + _maxLength){
									prop.$maxLength = parseInt(value);
								}					
								// Handle whiteSpace
								else if (key === xsdPrefix + _whiteSpace){
									// TODO
									nyi(key);
								}
								// Handle minInclusive
								else if (key === xsdPrefix + _minInclusive){
									prop.$minimum = parseInt(value);
									prop.$exclusiveMinimum = false;
								}
								// Handle maxInclusive
								else if (key === xsdPrefix + _maxInclusive){
									prop.$maximum = parseInt(value);
									prop.$exclusiveMaximum = false;
								}
								// Handle minExclusive
								else if (key === xsdPrefix + _minExclusive){
									prop.$minimum = parseInt(value);
									prop.$exclusiveMinimum = true;
								}
								// Handle maxExclusive
								else if (key === xsdPrefix + _maxExclusive){
									prop.$maximum = parseInt(value);
									prop.$exclusiveMaximum = true;
								}
								// Handle fractionDigits
								else if (key === xsdPrefix + _fractionDigits){
									var format = "0.";
									for (var i = 0; i < parseInt(value); i++){
										format += "#";
									}
								}
								// Handle totalDigits
								else if (key === xsdPrefix + _totalDigits){
									if (['float', 'double', 'decimal'].indexOf(base) !== -1){
										addWarning("handle '"+_key+"' restriction of type '"+base+"' not yet implemented");
									}else if (['integer', 'int', 'long', 'short', 'nonNegativeInteger', 'positiveInteger', 'nonPositiveInteger', 'negativeInteger', 'unsignedInt', 'unsignedLong', 'unsignedShort'].indexOf(base) !== -1){
										var format = "";
										for (var i = 0; i < parseInt(value); i++){
											format += "0";
										}
										prop.$format = format;
									}
								}
								else if (key !== '$'){
									nyi(key);
								}
							});

						} // End handleRestriction
													
						function handleComplexType(_cp){
							function nyi(_key){
								addWarning("Handle of complexType '"+_cp.$.name+"' sub node: '"+_key+"' is not yet implemented");
							}
							
							var _cp = _cp || element;
							if (typeof _cp === 'object')
							forEachKey(_cp, function(key, value) {
								// annotation?
								if (key === xsdPrefix + _annotation){
									// TODO
									nyi(key, element);
								}
								else if (key === xsdPrefix + _simpleContent){
									// TODO
									nyi(key);
								}
								else if (key === xsdPrefix + _complexContent){
									// TODO
									nyi(key);
								}
								else if (key === xsdPrefix + _group){
									// TODO
									nyi(key);
								}
								else if (key === xsdPrefix + _all){
									// TODO
									nyi(key);
								}
								else if (key === xsdPrefix + _choice){
									// TODO
									nyi(key);
								}
								else if (key === xsdPrefix + _sequence){
									handleSequence(value);
								}
								else if (key === xsdPrefix + _attribute){
									if (Array.isArray(value)){
										value.forEach(function(attrib){
											if (attrib.$.type){
												defineProperty(attrib, prop, _attribute);
											}else{
												defineProperty(attrib, prop, _attribute, true);
											}
										});
									}else if (value){
										if (value.$.type){
											defineProperty(value, prop, _attribute);
										}else{
											defineProperty(value, prop, _attribute, true);
										}
									}
								}
								else if (key === xsdPrefix + _attributeGroup){
									// TODO
									nyi(key);
								}
								else if (key === xsdPrefix + _anyAttribute){
									// TODO
									nyi(key);
								}
								else if (key !== '$'){
									nyi(key);		
								}
							});
						} // handleComplexType
						
						function handleSimpleType(_sp){
							
							function nyi(_key){
								addWarning("Handle of simpleType '"+_sp.$.name+"' sub node: '"+_key+"' is not yet implemented");
							}
							
							var _sp = _sp || element;
							if (typeof _sp === 'object')
							forEachKey(_sp, function(key, value) {
								if (key === xsdPrefix + _restriction){
									handleRestriction(value);
								}else if (key !== '$'){
									nyi(key);
								}
							});

						} // handleSimpleType
						
						function handleAttribute(_att){
							
							function nyi(_key){
								addWarning("Handle of attribute '"+_att.$.name+"' sub node: '"+_key+"' is not yet implemented");
							}
							
							var _att = _att || element;
							if (typeof _att === 'object')
							forEachKey(_att, function(key, value) {
								if (key === xsdPrefix + _simpleType){
									handleSimpleType(value);
								}else if (key === xsdPrefix + _annotation){
									// TODO
									nyi(key);
								}else if (key !== '$'){
									nyi(key);
								}
							});

						} // handleAttribute
						
						function handleElement(_elt){
							function nyi(_key){
								addWarning("Handle of element '"+elt.$.name+"' sub node: '"+_key+"' is not yet implemented");
							}
							
							if (typeof _elt === 'object')
							forEachKey(_elt, function(key, value) {
								if (key === '$'){
									if (value.type){
										var splited = splitNs(value.type);
										var eltNs = splited.ns;
										var eltType = splited.type;
										
										var sc = getSchema(eltNs);

										var xsdComplexType = getComplexType(sc, eltType);
										if (xsdComplexType){
											handleComplexType(xsdComplexType);
										}else{
											var xsdSimpleType = getSimpleType(sc, eltType);
											if (xsdSimpleType){
												handleSimpleType(xsdSimpleType);
											}else{
												throw new Error("XSD type '"+partType+"' not found.");
											}
										}

									}
										
								}else if (key === xsdPrefix + _complexType){
									handleComplexType(value);
								}else if(key === xsdPrefix + _simpleType){
									handleSimpleType(value);
								}else {
									nyi(key);
								}
							});

						} // handleElement
							



						function handleConstraints(){
							
							function nyi(_key){
								addWarning("Handle of element '"+name+"' attribute: '"+_key+"' is not yet implemented");
							}
							
							var ignoreAttributeMap = ['name', 'type', 'element'];
							if (typeof constraints === 'object')
							forEachKey(constraints, function(key, value) {
								//console.log(key + "=" + value);
								if (ignoreAttributeMap.indexOf(key) !== -1){
									// Do nothing: some attributes are not constraints
								}
								else if(key === "minOccurs"){
									if (value !== "0")
										prop.$isMandatory = true;
								}
								else if(key === "maxOccurs"){
									if (value !== "1")
										prop.$type = "application/x-array";
								}
								else if(key === "nillable"){
									if (value === "true")
										prop.$isNullable = true;
								}
								else if(key === "default"){
									prop.$default = stubUtils.convertValue(key, prop.$type, value);
								}
								else{
									nyi(key);
									
								}

							});
							
							if (!constraints.minOccurs && !prop.$isNullable){
								prop.$isMandatory = true;
							}
						}


						var xsdPrefix = "";
						var prop = {
							$title: name
						};
						
						
						
						if (schema){

							if (schema.$.xmlns !== getNamespaceUrl(xsdNs))
								xsdPrefix = xsdNs + ":";
							
											
							
							prop.$type = prop.$type || "application/x-object";
							prop.$item = prop.$item || {
								$properties: (prop.$item && prop.$item.$properties) || {}
							};
							
							handleConstraints();
							
							if (nature === _primitive){
								addWarning("Primititve not expected here !!!");
								defineProperty(element, prop, _primitive);
							}else if (nature === _complexType){
								handleComplexType();
							}else if (nature === _simpleType){
								handleSimpleType();
							}else if (nature === _attribute){
								handleAttribute();
							}else if (nature === _element){
								handleElement(element);
							}else{
								throw new Error('Nature error');
							}
							
							
						}
						else if (nature === _primitive){
							
							if (prop.$type !== "application/x-array"){
								prop.$type = convertType(element.$.type);
								
							}else{
								prop.$item = {
									$properties: {}
								}
								prop.$item.$properties[name] = {
									$title: name,
									$type: convertType(element.$.type)
								}
							}
							handleConstraints();	
						}

						else{
							throw new Error("Unexpected error occured");
						}
						//console.log("Property builded: "+JSON.stringify(prop,null,2));
						return prop;
					
					} // End buildProperty
					
					function convertType(type){
						if (type.indexOf(':') !== -1)
							type = type.split(':')[1];
						switch(type){
							case "string":
								return "application/x-string";
							case "boolean":
								return "application/x-boolean";
							case "float":
							case "double":
							case "decimal":
								return "application/x-decimal";
							case "integer":
							case "int":
							case "long":
							case "short":
							case "nonNegativeInteger":
							case "positiveInteger":
							case "nonPositiveInteger":
							case "negativeInteger":
							case "unsignedInt":
							case "unsignedLong":
							case "unsignedShort":
								return "application/x-integer";
							case "date":
								return "application/x-date";
							case "time":
								return "application/x-time";
							case "dateTime":
								return "application/x-datetime";
							case "byte":
							case "duration":
							case "hexBinary":
							case "base64Binary":
							case "anyURI":
							case "ID":
							case "IDREF":
							case "ENTITY":
							case "NOTATION":
							case "normalizedString":
							case "token":
							case "language":
							case "IDREFS":
							case "ENTITIES":
							case "NMTOKEN":
							case "NMTOKENS":
							case "Name":
							case "QName":
							case "NCName":
							case "unsignedByte":
							case "gYearMonth":
							case "gYear":
							case "gMonthDay":
							case "gDay":
							case "gMonth":
							default:
								addWarning("XMLSchema-datatypes '" + type + "' is not supported yet by Syracuse.");
	
						}
						
					} // End convertType
					

					
					function setProperty(prop, element, ns, nature){
										
						
						
						var params = {element: element};
						//tracer.traceSubSection("-> Set property :",JSON.stringify(params,null,2));
						
						var name = element.$.name;

						var loc;
						
						if (prop.$type === "application/json"){
							prop.$properties = prop.$properties || {};
							loc = prop;
						}else{
							if (prop.$type === "application/x-array"){
								if (facet === "$request"){
									prop.$capabilities = "sort,insert,append,delete,filter";
								}else if (facet === "$response"){
									prop.$capabilities = "sort,filter";
								}
							}
								
							prop.$item = prop.$item || {
								$properties: (prop.$item && prop.$item.$properties) || {}
							};
							loc = prop.$item;
						}

						// primitive type
						if (ns && getNamespaceUrl(ns).indexOf(__XMLSchema) === 0){
							loc.$properties[name] = buildProperty(name, element, _primitive, element.$);
						}
						// schema's type
						else{
							loc.$properties[name] = buildProperty(name, element, nature, element.$, getSchema(ns));
						}	
						

					} // End setProperty
					
					function readMsgPart(part, prop){
						tracer.traceSubSection("Read message part: "+msgName, JSON.stringify(part,null,2));

						if (part.$.type){
							
							var splited = splitNs(part.$.type);
							var partNs = splited.ns;
							var partType = splited.type;
							
							var nsUrl = getNamespaceUrl(partNs);
							prop.$xmlns = partNs + ":" + nsUrl;
							
							if (nsUrl.indexOf(__XMLSchema) === 0){
								setProperty(prop, part, partNs, _primitive);
							}else{
								var sc = getSchema(partNs);

								var xsdComplexType = getComplexType(sc, partType);
								if (xsdComplexType){
									setProperty(prop, xsdComplexType, partNs, _complexType);
								}else{
									var xsdSimpleType = getSimpleType(sc, partType);
									if (xsdSimpleType){
										setProperty(prop, xsdSimpleType, partNs, _simpleType);
									}else{
										throw new Error("XSD type '"+partType+"' not found.");
									}
								}
							}

							
						}else if(part.$.element){
							
							var splited = splitNs(part.$.element);
							var partNs = splited.ns;
							var partElement = splited.type;
							
							prop.$xmlns = partNs + ":" + getNamespaceUrl(partNs);
							
							var sc = getSchema(partNs);

							var xsdElement = getElement(sc, partElement);
							if (xsdElement){
								setProperty(prop, xsdElement, partNs, _element);
							}else{
								throw new Error("XSD element '"+partElement+"' not found.");
							}
							
						}


					
					} // End readMsgPart
					

					
					var elementsMap = {}, complexTypesMap = {}, simpleTypesMap = {};
					


					
					var proto = {
						$descriptor: "prototype "+operationName+"." + facet,
						$type: "application/json",
						$prototype: "{$baseUrl}/$prototypes('"+operationName+"."+facet+"')",
						$baseType: "application/json;vnd.sage=syracuse",
						$baseUrl: globals.context.session.host + "/soap-stubs/syracuse/collaboration/syracuse/" + self.name + "/" + port.$.name,
						$value: documentation,
						$title: operationName,
						$description: operationName + " " + facet + " : " + documentation,
						$representation: operationName,
						$properties: {}
					};
					
					
					///////
					
					
//					var content = {
//							type: "input",
//							binding: {
//								header: getSubNode(bindingInput, protocolNs, 'header'),
//								body: getSubNode(bindingInput, protocolNs, 'body')
//							},
//							portType: getSubNode(portTypeOperation, wsdlNs, 'input')
//						};
					

					
					
					if (content.binding.header){
						
						var handleHeader = function(header){
							
							var headerMsgName, headerMsgPart;
	
							if (header.$){
								headerMsgName = header.$.message;
								headerMsgPart = header.$.part;
								
								
								var splited = splitNs(headerMsgName);
								var msgNs = splited.ns;
								var msgName = splited.type;
								
								
								var message = getMessage(msgName);
								var messagePart = getSubNode(message, wsdlNs, 'part');
								if (Array.isArray(messagePart)){
									
									if (headerMsgPart){
										for (var i in messagePart){
											if (messagePart[i].$.name === headerMsgPart){
												readMsgPart(messagePart[i], proto.$properties.header);
											}
										}
									}else{
										messagePart.forEach(function(mp){
											readMsgPart(mp, proto.$properties.header);
										});
									}
								}else if (messagePart){
									if (headerMsgPart){
										if (messagePart.$.name === headerMsgPart){
											readMsgPart(messagePart, proto.$properties.header);
										}
									}else{
										readMsgPart(messagePart, proto.$properties.header);
									}
	
								}
							}
						} // handleHeader function


						proto.$properties.header = {
							$title: "Header",
							$isMandatory: true,
					        $type: "application/x-object",
					        $item: {
					        	$properties: {}
					        }
						}
						
						
						
						
						if (Array.isArray(content.binding.header)){
							content.binding.header.forEach(function(header){
								handleHeader(header);
							});
						}else{
							handleHeader(content.binding.header);
						}
						
						
						
					}
					
					if (content.binding.body){
						
						proto.$properties.body = {
							$title: "Body",
							$isMandatory: true,
					        $type: "application/x-object",
					        $item: {
					        	$properties: {}
					        }
						}
						
						
						var bodyMsgName;
						if (content.binding.body.$)
							operationInstance[content.type + "BodyEncoding"](_, content.binding.body.$.use);
						if (content.portType.$ && content.portType.$.message){
							bodyMsgName = content.portType.$.message;
							operationInstance[content.type + "BodyName"](_, bodyMsgName);
							
							var splited = splitNs(bodyMsgName);
							var msgNs = splited.ns;
							var msgName = splited.type;
							
							
							var message = getMessage(msgName);
							var messagePart = getSubNode(message, wsdlNs, 'part');
							if (Array.isArray(messagePart)){
								messagePart.forEach(function(mp){
									readMsgPart(mp, proto.$properties.body);
								});
							}else if (messagePart){
								readMsgPart(messagePart, proto.$properties.body);
							}
							
							
						}else{
							throw new Error("Attribute 'message' not found in '"+content.type+"' portType of operation '"+operationName+"'");
						}
						
					}
					
					
					//////


					storePrototype(_, operationName + "_" + facet, store, JSON.stringify(proto,null,2));

				} // End createPrototype

				function storePrototype(_, prototypeName, instanceProperty, proto){

					//tracer.traceSubSection("Create Prototype: "+prototypeName, proto);
					// Store WSDL
					if (!instanceProperty.fileExists(_)){
						var buf = new Buffer(proto, 'utf8').toString('binary');
						if (buf != null && buf.length !== 0){
							var props = {
									length: buf.length,
									contentType: "application/json",
									fileName: prototypeName + ".json"
							}
							var store = instanceProperty;
							var stream = store.createWritableStream(_, props);
							stream.write(_, buf, "binary");
							stream.write(_, null);
						}
					}else{
						throw new Error("File already exists.");
					}
					
					
					
				} // End storePrototype
				
				
				function getPortTypeOperation(opName){
					if (Array.isArray(portTypeOperations)){
						for (var i in portTypeOperations){
							if (portTypeOperations[i].$.name === opName)
								return portTypeOperations[i];
						}
					}else{
						if (portTypeOperations.$.name === opName)
							return portTypeOperations;
					}
					throw new Error("PortType operation not found: "+opName);
				}
				//
				//
				var operationName = bindingOperation.$.name;
				var portTypeOperation = getPortTypeOperation(operationName);
				tracer.traceSubSection(" - Add Operation: "+operationName);
				
				var entity = model.getEntity("soapStubOperation");
				var operationInstance = entity.factory.createInstance(_, null, db);
				
				operationInstance.name(_, operationName);
				var documentation = getSubNode(portTypeOperation, wsdlNs, 'documentation');
				documentation = (documentation && documentation.$value) || documentation;
				operationInstance.description(_, documentation);
				
				// Set URL of Tester
				operationInstance.tester(_, "/soap-stubs/syracuse/collaboration/syracuse/" + self.name + "/" + port.$.name + "/" + operationName + "?representation=" + operationName + ".$request");
				
				var opInfos = getSubNode(bindingOperation, protocolNs, 'operation');

				
				if (protocol === __soap || protocol === __soap12){
					if (opInfos && opInfos.$){
						operationInstance.soapAction(_, opInfos.$.soapAction);
						operationInstance.style(_, opInfos.$.style || (subBindingNode ? subBindingNode.$.style : "document"));
					}else{
						operationInstance.style(_, subBindingNode ? subBindingNode.$.style : "document");
						
					}

					
				}
				// Not supported
				else if (protocol === __http || protocol === __http2){
					if (opInfos && opInfos.$)
						operationInstance.location(_, opInfos.$.location);
				}else{
					throw new Error("Protocol '"+definitions.$["xmlns:"+protocol]+"' is not supported.");
				}
				
				
				var bindingInput = getSubNode(bindingOperation, wsdlNs, 'input');
				var bindingOutput = getSubNode(bindingOperation, wsdlNs, 'output');
				var bindingFault = getSubNode(bindingOperation, wsdlNs, 'fault');
				
				
				var input = {
					type: "input",
					binding: {
						header: getSubNode(bindingInput, protocolNs, 'header'),
						body: getSubNode(bindingInput, protocolNs, 'body')
					},
					portType: getSubNode(portTypeOperation, wsdlNs, 'input')
				};
				createPrototype(_, input, operationInstance.requestPrototype(_), "$request");
				
				var output = {
					type: "output",
					binding: {
						header: getSubNode(bindingOutput, protocolNs, 'header'),
						body: getSubNode(bindingOutput, protocolNs, 'body')
					},
					portType: getSubNode(portTypeOperation, wsdlNs, 'output')
				};
				createPrototype(_, output, operationInstance.responsePrototype(_), "$response");
				
//				var fault = {
//					type: "fault",
//					binding: {
//						fault: getSubNode(bindingFault, protocolNs, 'fault')
//					},
//					portType: getSubNode(portTypeOperation, wsdlNs, 'fault')
//				};
//				createPrototype(_, fault, operationInstance.faultPrototype(_), "$fault");
//				
						

				


				
				//console.log("OPERATION SERIALIZED:"+JSON.stringify(operationInstance.serializeInstance(_),null,2));
				
				
				
				portInstance.operations(_).set(_, operationInstance);

			} // End addOperation
			

			
			
			

			
			
			var protocolNs, protocol, location;
			Object.keys(port).forEach_(_, function(_, key){
				if (key.indexOf(":address") !== -1){
					protocolNs = key.split(':')[0];
					protocol = definitions.$["xmlns:" + protocolNs];
					location = port[key].$.location;
				}
			});
			
			if (!protocol)
				throw new Error("Port protocol not found.");
			
			if (!location)
				throw new Error("Port location not found.");
			
			
			if (protocol === __soap || protocol === __soap12){
			
				tracer.traceSection("Add Port: "+port.$.name);
				
				var soapStubPortEntity = model.getEntity("soapStubPort");
				var portInstance = soapStubPortEntity.factory.createInstance(_, null, db);
				
				portInstance.name(_, port.$.name);
				
				portInstance.protocol(_, protocol);
				portInstance.location(_, location);
				
				// Get binding infos
				var bindingName = port.$.binding.indexOf(':') !== -1 ? port.$.binding.split(':')[1] : port.$.binding;
				var binding = getBinding(bindingName);
				
				var subBindingNode = getSubNode(binding, protocolNs, 'binding');
				// Set transport protocol
				var transport;
				if (subBindingNode){
					transport = subBindingNode.$.transport
					if (transport){
						portInstance.transport(_, transport);
					}else{
						portInstance.transport(_, __soapHttp);
					}
					portInstance.method(_, "POST");
//					if (protocol.indexOf(__http) === 0 || protocol.indexOf(__http2) === 0){
//						var verb = subBindingNode.$.verb;
//						portInstance.method(_, verb);
//					}else{
//						portInstance.method(_, "POST");
//					}
				}else{
					portInstance.transport(_, __soapHttp);
					portInstance.method(_, "POST");
				}
	
				
				// Get portType Infos
				var portTypeName = binding.$.type.indexOf(':') !== -1 ? binding.$.type.split(':')[1] : binding.$.type;
				var portType = getPortType(portTypeName);
				var portTypeOperations = getSubNode(portType, wsdlNs, 'operation');
				
				// Register operations
				var bindingOperations = getSubNode(binding, wsdlNs, 'operation');
				if (Array.isArray(bindingOperations)){
					bindingOperations.forEach_(_, function(_, op){
						addOperation(_, op);
					});
				}else{
					addOperation(_, bindingOperations);
				}
				
				//console.log("PORT:"+JSON.stringify(portInstance.serializeInstance(_),null,2));
				self.ports.push(portInstance);
			}else{
				addWarning("protocol '"+protocol+"' is not supprted for port '"+port.$.name+"'");
			}
		}
		
		var self = this;
		var db = adminHelper.getCollaborationOrm(_);
		var model = db.model;
		
		var wsdl = jsxml.parse(self.wsdl);
		//console.log("WSDL="+JSON.stringify(wsdl,null,2));
		var rootNode = Object.keys(wsdl)[0];
		
		var wsdlNs = rootNode.split(':').length === 2 ? rootNode.split(':')[0] : "";
		
		
		var definitions = getSubNode(wsdl, wsdlNs, 'definitions');
		var types = getSubNode(definitions, wsdlNs, 'types');
		var messages = getSubNode(definitions, wsdlNs, 'message');
		var portTypes = getSubNode(definitions, wsdlNs, 'portType');
		var bindings = getSubNode(definitions, wsdlNs, 'binding');
		var service = getSubNode(definitions, wsdlNs, 'service');

		self.description = service.documentation;
		
		var xsdNs = getNamespacePrefix(__XMLSchema);
		


		
		
		
		
		
		var ports = getSubNode(service, wsdlNs, 'port');

		if (Array.isArray(ports)){
			ports.forEach_(_, function(_, p){
				addPort(_, p);
			});
		}else{
			addPort(_, ports);
		}

		
	}

});



exports.create = function(_, name, wsdl, url, options){
	try{

		var stub = new stubHelper(_, name, wsdl, url, options);
		
		stub.parseWsdl(_);

		return stub;
	}catch(e){
		console.error("STACK="+e.stack);
		throw new Error(e.message);
	}
}