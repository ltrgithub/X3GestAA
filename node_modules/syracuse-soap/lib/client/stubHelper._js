"use strict";

var helpers = require('syracuse-core/lib/helpers');
var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var util = require("util");
var fs = require('fs');
var jsxml = require('jsxml');
var streams = require('streamline/lib/streams/streams');
var config = require('syracuse-main/lib/nodeconfig').config;
var soapTracer = require('../common/soapTracer');
var globals = require('streamline/lib/globals');
var forEachKey = helpers.object.forEachKey;



var tracer = soapTracer.create("client");

var __http = "http://schemas.xmlsoap.org/wsdl/http/";
var __soap = "http://schemas.xmlsoap.org/wsdl/soap/";
var __soap12 = "http://schemas.xmlsoap.org/wsdl/soap12/";



var stubHelper = helpers.defineClass(function(_, name, wsdl, url, options) {

	this.name = name;
	this.wsdl = wsdl;
	this.options = options;
	
	if (!this.wsdl)
		this.wsdl = this.getWsdl(_, url, options);
	this.ports = [];
	
}, null, {
	getWsdl: function(_, url, options){
		
		
		tracer.traceSection("Retrieve WSDL from URI: "+url);

		var opt = {
			method: "GET",
			url: url,
			headers: {}
		};
		
		if (options && options.auth){
			if (options.auth.type === "basic"){
				opt.headers.Authorization = "Basic "+new Buffer(options.auth.user+":"+options.auth.password).toString('base64')
			}
		}
		
		
		if (helpers.proxy){
			opt.proxy = "http://"+helpers.proxy.server+":"+helpers.proxy.port;
		}
			
		var request = streams.httpRequest(opt);
		var response = request.end().response(_);
		var body = response.readAll(_);

		if (response.statusCode === 200 && body){
			return body;
		}else{
			throw new Error(response.statusCode + ": "+body);
		}
		
	},
	parseWsdl: function(_){
		
		
		function getSubNode(node, ns, name){
			return ns ? node[ns+":"+name] : node[name];
		}
		
		function checkIntegrity(){
			if (!definitions)
				throw new Error("Root node 'definitions' not found.");
			if (!types)
				throw new Error("No 'types' Node found.");
			if (!message)
				throw new Error("No 'message' node found.");
			if (!portType)
				throw new Error("No 'portType' node found.");
			if (!binding)
				throw new Error("No 'binding' node found.");
			if (!service)
				throw new Error("No 'service' node found.");
		}
		

		
		function addPort(_, port){
			

			
			
			function addOperation(_, bindingOperation){
				
				
				
				function createPrototype(_, type, store){
					
					var pName, pNs = '';
					if (type.indexOf(":") !== -1){
						var parts = type.split(":");
						pNs = parts[0];
						pName = parts[1];
					}else{
						pName = type;
					}
					

					
					var proto = {
						$type: "application/json",
						$prototype: "{$baseUrl}/$prototypes('{$representation}.$edit')",
						$baseType: "application/json;vnd.sage=syracuse",
						$description: pName + " : " + operationName + " : " + documentation
					};

					
					storePrototype(_, pName, store, JSON.stringify(proto,null,2));

				} // End createPrototype

				function storePrototype(_, prototypeName, instanceProperty, proto){
					// Store WSDL
					if (!instanceProperty.fileExists(_)){
						console.log("Create prototype: "+prototypeName);
						var buf = new Buffer(proto, 'utf8').toString('binary');
						if (buf != null && buf.length !== 0){
							var props = {
									length: buf.length,
									contentType: "application/json",
									fileName: prototypeName + ".json"
							}
							var store = instanceProperty;
							var stream = store.createWritableStream(_, props);
							stream.write(_, buf, "binary");
							stream.write(_, null);
						}
					}else{
						throw new Error("File already exists.");
					}
				} // End storePrototype
				
				//
				//
				var operationName = bindingOperation.$.name;
				var portTypeOperation = getPortTypeOperation(operationName);
				tracer.trace(" - Add Operation: "+operationName);
				
				var entity = model.getEntity("soapStubOperation");
				var operationInstance = entity.factory.createInstance(_, null, db);
				
				operationInstance.name(_, operationName);
				var documentation = getSubNode(portTypeOperation, wsdlNs, 'documentation')
				operationInstance.description(_, (documentation && documentation.$value) || documentation);
				
				var opInfos = getSubNode(bindingOperation, protocolNs, 'operation');
				var opInputEnc = getSubNode(bindingOperation, wsdlNs, 'input')[protocolNs + ":body"];
				var opOutputEnc = getSubNode(bindingOperation, wsdlNs, 'output')[protocolNs + ":body"];
				
				if (protocol === __soap || protocol === __soap12){
					operationInstance.soapAction(_, opInfos.$.soapAction);
					operationInstance.style(_, opInfos.$.style);
					if (opInputEnc)
						operationInstance.inputEncoding(_, opInputEnc.$.use);
					if (opOutputEnc)
						operationInstance.outputEncoding(_, opOutputEnc.$.use);
				}else if (protocol === __http){
					operationInstance.location(_, opInfos.$.location);
				}else{
					throw new Error("Protocol '"+definitions.$["xmlns:"+protocol]+"' is unknow.");
				}
				
				
				var inputName = getSubNode(portTypeOperation, wsdlNs, 'input').$.message;
				operationInstance.inputName(_, inputName);
				createPrototype(_, inputName, operationInstance.inputPrototype(_));
				
				var outputName = getSubNode(portTypeOperation, wsdlNs, 'output').$.message;
				operationInstance.outputName(_, outputName);
				createPrototype(_, outputName, operationInstance.outputPrototype(_));
				
				//console.log("OPERATION:"+JSON.stringify(operationInstance.serializeInstance(_),null,2));
				
				
				
				portInstance.operations(_).set(_, operationInstance);

			} // End addOperation
			
			function getPortTypeOperation(name){
				var found;
				if (Array.isArray(portTypeOperations)){
					portTypeOperations.forEach(function(op){
						if (op.$.name === name)
							found = op;
					});
				}else{
					if (portTypeOperations.$.name === name)
						found = portTypeOperations;
				}
				return found;
			}
			
			function getPortType(name){
				var found;
				if (Array.isArray(portTypes)){
					portTypes.forEach(function(p){
						if (p.$.name === name)
							found = p;
					});
				}else{
					if (portTypes.$.name === name)
						found = portTypes;
				}
				return found;
			}
			
			function getBinding(name){
				var found;
				if (Array.isArray(bindings)){
					bindings.forEach(function(b){
						if (b.$.name === name)
							found = b;
					});
				}else{
					if (bindings.$.name === name)
						found = bindings;
				}
				return found;
			}
			
			
			
			tracer.traceSection("Add Port: "+port.$.name);
			
			var soapStubPortEntity = model.getEntity("soapStubPort");
			var portInstance = soapStubPortEntity.factory.createInstance(_, null, db);
			
			portInstance.name(_, port.$.name);
			
			
			var protocolNs, protocol, location;
			Object.keys(port).forEach_(_, function(_, key){
				if (key.indexOf(":address") !== -1){
					protocolNs = key.split(':')[0];
					protocol = definitions.$["xmlns:" + protocolNs];
					location = port[key].$.location;
				}
			});
			
			if (!protocol)
				throw new Error("Port protocol not found.");
			
			if (!location)
				throw new Error("Port location not found.");
			
			portInstance.protocol(_, protocol);
			portInstance.location(_, location);
			
			// Get binding infos
			var bindingName = port.$.binding.indexOf(':') !== -1 ? port.$.binding.split(':')[1] : port.$.binding;
			var binding = getBinding(bindingName);
			
			// Set transport protocol
			var transport = getSubNode(binding, protocolNs, 'binding').$.transport
			if (transport){
				portInstance.transport(_, transport);
			}else if (protocol.indexOf("http://schemas.xmlsoap.org/wsdl/http") === 0){
				var verb = getSubNode(binding, protocolNs, 'binding').$.verb;
				portInstance.transport(_, verb);
			}else{
				throw new Error("Port protocol transport unknow.");
			}
			
			// Get portType Infos
			var portTypeName = binding.$.type.indexOf(':') !== -1 ? binding.$.type.split(':')[1] : binding.$.type;
			var portType = getPortType(portTypeName);
			var portTypeOperations = getSubNode(portType, wsdlNs, 'operation');
			
			// Register operations
			var bindingOperations = getSubNode(binding, wsdlNs, 'operation');
			if (Array.isArray(bindingOperations)){
				bindingOperations.forEach_(_, function(_, op){
					addOperation(_, op);
				});
			}else{
				addOperation(_, bindingOperations);
			}
			
			//console.log("PORT:"+JSON.stringify(portInstance.serializeInstance(_),null,2));
			self.ports.push(portInstance);
		}
		
		var self = this;
		var db = adminHelper.getCollaborationOrm(_);
		var model = db.model;
		
		var wsdl = jsxml.parse(self.wsdl);
		//console.log("WSDL="+JSON.stringify(wsdl,null,2));
		var rootNode = Object.keys(wsdl)[0];
		
		var wsdlNs = rootNode.split(':').length === 2 ? rootNode.split(':')[0] : "";
		
		var definitions = getSubNode(wsdl, wsdlNs, 'definitions');
		var types = getSubNode(definitions, wsdlNs, 'types');
		var messages = getSubNode(definitions, wsdlNs, 'message');
		var portTypes = getSubNode(definitions, wsdlNs, 'portType');
		var bindings = getSubNode(definitions, wsdlNs, 'binding');
		var service = getSubNode(definitions, wsdlNs, 'service');

		self.description = service.documentation;
		
		

		var ports = getSubNode(service, wsdlNs, 'port');

		if (Array.isArray(ports)){
			ports.forEach_(_, function(_, p){
				addPort(_, p);
			});
		}else{
			addPort(_, ports);
		}

		
	}

});



exports.create = function(_, name, wsdl, url, options){
	try{

		var stub = new stubHelper(_, name, wsdl, url, options);
		
		stub.parseWsdl(_);

		return stub;
	}catch(e){
		console.log("STACK="+e.stack);
		throw new Error(e.message);
	}
}