"use strict";

var helpers = require("syracuse-core/lib/helpers");
var Context = require("syracuse-sdata/lib/sdataContext").Context;
var registry = require("syracuse-sdata/lib/sdataRegistry");
var dataModel = require("syracuse-orm/lib/dataModel");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var locale = require("syracuse-core/lib/locale");
var util = require("util");
var fs = require('fs');
var stubUtils = require('./stubUtils');



var _soapStubsMap = {
	walk: function(_, context, name, id) {
		context.applicationName = name;
		context.application = registry.applications[name];
//			if (!context.application && !helpers.stubsPath) throw context.notFound("application not found: " + name);
		return _dispatch(_, context, _applicationMap);
	},
	get: function(_, context) {
		return context.replyDictionaryPage(_, registry.applications, "application");
	}
}

//URL is http://host/soap-stubs/app
var _applicationMap = {
	walk: function(_, context, name, id) {
		context.contractName = name;
		if (context.application)
			context.contract = context.application.contracts[name];
		//
		var app = adminHelper.getApplication(_, context.applicationName, context.contractName);
		if(!app && !context.application && !helpers.stubsPath) throw context.notFound(locale.format(module, "applicationNotFound", context.applicationName, context.contractName));
		context.applicationRef = app;
		if (app && (app.protocol(_) !== "syracuse"))
			throw new Error("Only Syracuse protocol is allowed.");
		return _dispatch(_, context, _syracuseContractMap);
	}
	,
	get: function(_, context) {
		return context.replyDictionaryPage(_, context.application.contracts, "contract");
	}
}



//URL is http://host/soap-stubs/app/contract
var _syracuseContractMap = {
	walk: function(_, context, name, id) {
		// allow stubs
		
		if(context.contract) {
			var ds = registry.getDataset(_, context.contract, name);
			if (!ds) throw context.notFound("dataset not found: " + name);
			context.dataset = name;
			context.model = dataModel.make(context.contract, context.dataset);
			context.db = dataModel.getOrm(_, context.model, ds);
			context.baseUrl = context.walked();
		}
		return _dispatch(_, context, _syracuseDatasetMap);
	}
	,
	get: function(_, context) {
		return context.replyDictionaryPage(_, context.contract.datasets, "dataset");
	}
}




// URL is http://host/soap-stubs/app/contract/dataset
// for syracuse endpoints
var _syracuseDatasetMap = {
	walk: function(_, context, name, id) {

		if (id) {
			throw context.badRequest("unexpected URL ID: ('" + id + "')");
		} else {
			return _dispatch(_, context, _stubMap);
		}
	},
	get: function(_, context) {
		var baseUrl = context.walked();
		return context.replyDictionaryPage(_, stubUtils.getSoapStubs(_, context), "soapStub", function(name, stub) {
			return {
				$url: baseUrl + "/" + stub.name,
				$key: stub.name,
				$descriptor: "Description: " + stub.description,
				name: stub.name
			}
		});
	},

}

// http://host/soap-stubs/app/contract/dataset/stub
var _stubMap = {
	walk: function(_, context, name, id) {

		if (id) {
			throw context.badRequest("unexpected URL ID: ('" + id + "')");
		} else {
			return _dispatch(_, context, _portMap);
		}
	},
	get: function(_, context) {
		var baseUrl = context.walked();
		var parts = context.request.url.split("/");
		var stubName = parts[5];
		return context.replyDictionaryPage(_, stubUtils.getSoapStubPorts(_, stubName, context, true), "soapStub", function(name, stub) {
			return {
				$url: baseUrl + "/" + stub.name,
				$key: stub.name,
				$descriptor: "Description: " + stub.description,
				name: stub.name
			}
		});
	},

}

//http://host/soap-stubs/app/contract/dataset/stub/port
var _portMap = {
	prototypes: function(_, context, id) {
		if (id) {
			context.prototypeId = id;
			return _dispatch(_, context, _prototypeMap);
		} else {
			return _dispatch(_, context, _prototypesMap);
		}
	},
	get: function(_, context) {
		var baseUrl = context.walked();
		var parts = context.request.url.split("/");
		var stubName = parts[5];
		var portName = parts[6];

		return context.replyDictionaryPage(_, stubUtils.getSoapStubPortOperations(_, stubName, portName, context, true), "soapStubPortOperations", function(name, operation) {
			return {
				$url: baseUrl + "/$prototypes('" + operation.name + ".$request')",
				$key: operation.name + "Request",
				$descriptor: "Request prototype",
				name: operation.name + "Request"
			}			
		});
	},

}


//http://host/soap-stubs/app/contract/dataset/stub/port/$prototypes
var _prototypesMap = {
	get: function(_, context) {
		throw context.niy("prototypes list");
	}
}

//http://host/soap-stubs/app/contract/dataset/stub/port/$prototypes('id')
var _prototypeMap = {
		get: function(_, context) {
			
			var baseUrl = context.walked();
			var parts = context.request.url.split("/");
			var stubName = parts[5];
			var portName = parts[6];

			
			
			
			var keys = context.prototypeId.split(".");
			var operationName = keys[0];
			var facet = keys[1];

			var operation = stubUtils.getSoapStubPortOperation(_, stubName, portName, operationName, context);
			
			if(!operation)
				context.reply(_, 404, locale.format(module, "operationNotFound", operationName));
				
			
			
			console.log("PROTO: "+util.inspect(operation));
			var store;
			if (facet === "$request"){
				store = operation.inputPrototype(_);
			}else if (facet === "$response"){
				store = operation.outputPrototype(_);
			}else{
				throw new Error("Only '$request' and '$response' prototypes are availables.");
			}
			

			if (!store.fileExists(_)) throw new Error("Prototype file doesn't exist");
			var proto = store.createReadableStream(_).readAll(_).toString();
			
			if(proto)
				context.reply(_, 200, proto);
			else
				context.reply(_, 404, locale.format(module, "prototypeNotFound", context.prototypeId));
			
		}
	}

function _parseSegment(segment) {
	var match = /^([^\/(]*)\('([^']*)'\)$/.exec(segment);
	return match ? {
		name: match[1],
		id: match[2]
	} : {
		name: segment
	}
}


function _dispatch(_, context, map) {

	var seg = context.walkUrl();
	if (seg == null) {
		// we reached the end of the URL, dispatch method
		//var method = context.request.method.toLowerCase();
		var method = context.method;
		if (map[method]) return map[method](_, context);
		else throw context.badMethod(method);
	} else {
		var pair = _parseSegment(seg);
		if (pair.name[0] == '$') {
			
			var name = pair.name.substring(1);
			if (map[name]) {
				return map[name](_, context, pair.id);
			}
		} else if (map.walk) {
			return map.walk(_, context, pair.name, pair.id);
		}
		throw context.badRequest(locale.format(module, "unexpectedSegment", seg));
	}
}



function _logRequest(_, context) {
	if(!context.request.headers["x-history-title"]) return;
	//
	var db = adminHelper.getCollaborationOrm(_);
	var h = db.model.getEntity("navHistory").factory.createInstance(_, null, db);
	h.title(_, context.request.headers["x-history-title"]);
	h.agent(_, context.request.headers["x-history-agent"]);
	h.url(_, context.request.url);
	h.save(_);
}

function _doIt(_, context) {
	try {
		var protocol = context.walkUrl();
		if (protocol != "soap-stubs") throw new Error(locale.format(module, "badUrl", protocol));
		
		// fire and forget log call
		_logRequest(null, context);
		
		_dispatch(_, context, _soapStubsMap);
	} catch (ex) {
		if (ex.httpStatus) {
			return context.reply(_, ex.httpStatus, ex.message + "\n" + ex.stack);
		} else if (ex.stack) {
			console.error(ex.message + "\n" + ex.stack);
			return context.reply(_, 500, ex.message + "\n" + ex.stack);
		} else {
			console.error("CAUGHT NON ERROR: " + ex)
			return context.reply(_, 500, ex.toString());
		}
	}
}


exports.dispatcher = function(config) {
	// setup config here
//	_config = (config && config.x3fusion) || {};
//	tracer = config && config.x3fusion && config.x3fusion.tracer;
//	profiler = config && config.x3fusion && config.x3fusion.profiler;
	//
	return function(_, request, response) {
		var context = new Context(request, response);
		request.context = context;
		try {
			_doIt(_, context);
		} catch (err) {
			helpers.log.exception(module, err);
			context.reply(_, 500, err.message + "\n" + err.stack);
		}
	}
}