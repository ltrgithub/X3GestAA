"use strict";

var syracuse;
var mock = require('syracuse-load/lib/mock');
var config = require('config');
var helpers = require("syracuse-core/lib/helpers");
var locale = require("syracuse-core/lib/locale");
var http = require('http');
var httpClient = require("syracuse-httpclient/lib/httpClient");
var jsxml = require('jsxml');
var forEachKey = helpers.object.forEachKey;
var soapTracer = require('../common/soapTracer');
var soapTimer = require('../common/soapTimer');
var stubUtils = require('./stubUtils');

var tracer = soapTracer.create("client");
var timer = soapTimer.create("runtime");

function mergeObject(obj1, obj2) {
	var obj3 = {};
	for (var attrname in obj1) {
		obj3[attrname] = obj1[attrname];
	}
	for (var attrname2 in obj2) {
		obj3[attrname2] = obj2[attrname2];
	}
	return obj3;
}

var Runtime = helpers.defineClass(function(_, stubName, portName, operationName, data, context, stubType, localizations) {
	this.data = data;

	this.stub = stubUtils.getSoapStub(_, stubName, context, stubType);
	this.port = stubUtils.getSoapStubPort(_, stubName, portName, context, stubType);
	this.operation = stubUtils.getSoapStubPortOperation(_, stubName, portName, operationName, context, stubType);

	this.requestPrototype = stubUtils.getOperationPrototype(_, stubName, portName, operationName, "$request", context, stubType);
	this.responsePrototype = stubUtils.getOperationPrototype(_, stubName, portName, operationName, "$response", context, stubType);
	if (localizations) {
		stubUtils.injectLocalizations(localizations, this.requestPrototype);
		stubUtils.injectLocalizations(localizations, this.responsePrototype);
	}

}, null, {
	execute: function(_, context) {

		function send(_, envelope) {
			syracuse = syracuse || require('syracuse-main/lib/syracuse');
			envelope = '<?xml version="1.0" encoding="utf-8"?>\n' + envelope;
			tracer.traceSubSection("Send request parameters:", envelope);

			var location = self.port.location(_);
			if (location && location.indexOf('http') !== 0) {
				var host = (context.secure ? "https" : "http") + "://" + context.request.headers.host;
				location = host + location;
			}
			var opt = {
				method: self.port.method(_),
				url: location,
				headers: {
					"content-type": "text/xml; charset=utf-8",
					"content-length": Buffer.byteLength(envelope, "utf8")
				}
			};

			if (location.indexOf("https:") === 0) {
				opt.rejectUnauthorized = false;
			}
			var isChild = self.stub.isChild(_) || false;
			var authentication = self.stub.authentication(_);
			if (!isChild && authentication !== "none") {
				if (authentication === "basic") {
					opt.headers.Authorization = "Basic " + new Buffer(self.stub.authUser(_) + ":" + self.stub.authPassword(_)).toString('base64');
				}
			} else if (isChild) {
				if (syracuse.server instanceof mock.MockStreamServer) {
					opt.headers.authorization = "Nanny " + new Buffer(context.request.session.authData.user).toString('base64');
				} else {
					// to identify tester is used
					context.httpSession.wstester = true;
					opt.headers.cookie = context.httpSession.cookie;
				}
			}

			var soapAction = self.operation.soapAction(_);
			if (soapAction) {
				opt.headers.soapaction = soapAction;
			} else {
				opt.headers.soapaction = "";
			}


			var response;
			if (isChild && syracuse.server instanceof mock.MockStreamServer) {
				opt.url = require('url').parse(opt.url).path;
				// prepare for authenticated connection
				// change soaptest-generic into soap-generic 
				// so that request will be executed on Web service child process
				opt.url = opt.url.replace("soaptest-generic", "soap-generic");
				opt.headers.host = context.request.headers.host;
				opt.connection = {
					remoteAddress: context.request.connection.remoteAddress,
					localPort: context.request.connection.localPort,
				};
				try {
					response = config.mockServer.mockClient.simpleRequest(opt, envelope, _);
				} catch (e) {
					return {
						statusCode: e.STATUS_CODE,
						body: e.message
					};
				}
				return {
					statusCode: 200,
					body: response
				};
			}
			var request = httpClient.httpRequest(_, opt);
			response = request.end(envelope).response(_);
			var body = response.readAll(_);

			return {
				statusCode: response.statusCode,
				body: body
			};
		}

		function buildRequestProperty(name, prototype, data, hasNamespace) {
			var target = {};
			if (prototype.$type === "application/x-object") {
				forEachKey(prototype.$item.$properties, function(key, value) {
					var val;
					if (value.$type === "application/x-object") {
						val = buildRequestProperty(key, value, data && data[key]);
						target[prefix + ":" + key] = val || {};
						if (hasNamespace) {
							target[prefix + ":" + key].$ = {};
							target[prefix + ":" + key].$["xmlns:" + prefix] = namespace;
						}

					} else if (value.$type === "application/x-array") {
						var subTarget = [];
						if (data && data[key]) data[key].forEach(function(elt) {
							var test = {};
							forEachKey(value.$item.$properties, function(k, v) {
								val = elt[k];
								if (!val && v.$isMandatory) val = v.$default;
								test = mergeObject(test, buildRequestProperty(k, v, val));
							});
							if (Object.keys(test).length !== 0) {
								subTarget.push(test);
							}
						});
						if (subTarget.length !== 0) target[prefix + ":" + key] = subTarget;
					} else {
						val = data && data[key];
						if (!val && value.$isMandatory) val = value.$default;

						if (val) {
							val = stubUtils.convertValue(key, value.$type, val);

							target[prefix + ":" + key] = {};
							target[prefix + ":" + key].$value = val.toString();
						}
					}
				});

			} else if (prototype.$type === "application/x-array") {

				throw new Error(locale.format(module, "rootArrayNYI"));

			} else {
				var val = data;
				if (!val && prototype.$isMandatory) val = prototype.$default;

				if (val) {
					val = stubUtils.convertValue(name, prototype.$type, val);

					target[prefix + ":" + name] = {};
					target[prefix + ":" + name].$value = val.toString();
				}

			}
			return Object.keys(target).length !== 0 ? target : null;

		} // End buildRequestProperty

		function buildResponseProperty(properties, name, node, ns) {

			var target = {};

			if (typeof node === 'object' && Object.keys(node).length !== 0) {
				var obj;
				if (Array.isArray(node)) {
					obj = Object.keys(node[0]);
				} else {
					obj = Object.keys(node);
				}

				forEachKey(obj, function(key, value) {
					if (value !== '$') {

						var nodeName = ns ? value.split(':')[1] : value;

						var property = properties[nodeName];
						//tracer.traceSubSection("BUILD PROPERTY: "+nodeName);
						if (property.$type === "application/x-array") {

							var subTarget = [];

							var handleArray = function(aVal, aTarget) {
								var sub;
								if (typeof aVal === 'object') {

									sub = {};
									forEachKey(aVal, function(k, nod) {
										var subNodeName = ns ? k.split(':')[1] : k;
										var subProp = property.$item.$properties[subNodeName];

										if (subProp.$type === "application/x-object" || subProp.$type === "application/x-array") {
											sub[subNodeName] = buildResponseProperty(subProp.$item.$properties, subNodeName, nod, ns);
										} else {
											sub[subNodeName] = stubUtils.convertValue(subNodeName, subProp.$type, nod);
										}

									});
									aTarget.push(sub);

								} else if (typeof aVal === 'string') {
									//console.log("TEST="+JSON.stringify(property,null,2));
									var subNodeName = Object.keys(property.$item.$properties)[0];
									var subProp = property.$item.$properties[subNodeName];

									sub = {};
									sub[nodeName] = stubUtils.convertValue(subNodeName, subProp.$type, aVal);

									aTarget.push(sub);
								}
							}; // End handleArray

							if (Array.isArray(node[value])) {
								node[value].forEach(function(val) {
									handleArray(val, subTarget);
								});
							} else {
								handleArray(node[value], subTarget);
							}

							target[nodeName] = subTarget;

						} else if (property.$type === "application/x-object") {
							target[nodeName] = buildResponseProperty(property.$item.$properties, nodeName, node[value], ns);
						} else {
							if (typeof node[value] === 'string') {
								target[nodeName] = stubUtils.convertValue(nodeName, property.$type, node[value]);
							} else if (node[value].$value) {
								target[nodeName] = stubUtils.convertValue(nodeName, property.$type, node[value].$value);
							} else if (node[value].$cdata) {
								target[nodeName] = stubUtils.convertValue(nodeName, property.$type, node[value].$cdata);
							}
						}
					}
				});
			} else if (properties.$type) {

				target[name] = stubUtils.convertValue(name, properties.$type, node);

			}

			return target;
		} // buildResponseProperty

		function throwSoapFault(faultNode) {

			var faultCode = typeof faultNode.faultcode === 'object' ? faultNode.faultcode.$value : faultNode.faultcode;
			var faultString = typeof faultNode.faultstring === 'object' ? faultNode.faultstring.$value : faultNode.faultstring;
			var detail = typeof faultNode.detail === 'object' ? faultNode.detail.$value : faultNode.detail;

			throw new Error("Soap fault [" + faultCode + "]: " + (detail || ""));
		}

		var prefix, namespace;

		function calcNamespace(xmlns) {
			prefix = "";
			namespace = null;
			if (xmlns) {
				prefix = xmlns.substring(0, xmlns.indexOf(':'));
				namespace = xmlns.substring(prefix.length + 1);
			}
		} // End calcNamespace

		var self = this;
		var envelope = {
			"soap:Envelope": {

				$: {
					"xmlns:soap": "http://schemas.xmlsoap.org/soap/envelope/"
					//						"xmlns:xs": "http://www.w3.org/2001/XMLSchema",
					//						"xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance"
				}
			}
		};

		//console.log("Data="+JSON.stringify(this.data,null,2));
		timer.start();
		var proto;
		if (this.requestPrototype.$properties.header) {
			proto = this.requestPrototype.$properties.header;
			calcNamespace(proto.$xmlns);
			envelope["soap:Envelope"]["soap:Header"] = buildRequestProperty('header', proto, this.data && this.data.header, true);
		}

		if (this.requestPrototype.$properties.body) {
			proto = this.requestPrototype.$properties.body;
			calcNamespace(proto.$xmlns);
			envelope["soap:Envelope"]["soap:Body"] = buildRequestProperty('body', proto, this.data && this.data.body, true);
			//console.log("Body request="+JSON.stringify(envelope["soap:Envelope"]["soap:Body"],null,2));

		}

		var envXml = jsxml.stringify(envelope, {
			indent: '\t'
		});
		tracer.trace("Request transformation duration: " + timer.calc() + " ms");

		timer.start();
		var jsonResp, resp = send(_, envXml);

		tracer.trace("Send request duration: " + timer.calc() + " ms");
		if (resp) {

			if (resp.statusCode === 200 && resp.body) {

				jsonResp = jsxml.parse(resp.body);
				tracer.traceSubSection("Receive response:", JSON.stringify(jsonResp, null, 2));

				timer.start();
				var root = Object.keys(jsonResp)[0];
				var soapNs = '';
				if (root.indexOf(':') !== -1) soapNs = root.split(':')[0] + ':';

				var wsNs;
				if (this.responsePrototype.$properties.header) {

					var headerNode = jsonResp[root][soapNs + "Header"];
					if (headerNode) {

						var headerRoot = Object.keys(headerNode)[0];
						wsNs = null;

						if (headerRoot !== (soapNs + "Fault")) {
							if (headerRoot.indexOf(':') !== -1) wsNs = headerRoot.split(':')[0] + ':';

							this.responsePrototype.header = buildResponseProperty(this.responsePrototype.$properties.header.$item.$properties, 'header', headerNode, wsNs);

						} else {
							throwSoapFault(headerNode[headerRoot]);
						}
					} else {
						throw new Error(locale.format(module, "headerNotReceived"));
					}

				}

				if (this.responsePrototype.$properties.body) {

					var bodyNode = jsonResp[root][soapNs + "Body"];
					if (bodyNode) {

						var bodyRoot = Object.keys(bodyNode)[0];
						wsNs = null;

						if (bodyRoot !== (soapNs + "Fault")) {
							if (bodyRoot.indexOf(':') !== -1) wsNs = bodyRoot.split(':')[0] + ':';

							this.responsePrototype.body = buildResponseProperty(this.responsePrototype.$properties.body.$item.$properties, 'body', bodyNode, wsNs);
						} else {
							throwSoapFault(bodyNode[bodyRoot]);
						}
						//console.log("BODY=" + JSON.stringify(this.responsePrototype.body, null, 2));
					} else {
						throw new Error(locale.format(module, "bodyNotReceived"));
					}

				}
				tracer.trace("Response transformation duration: " + timer.calc() + " ms");
			} else if (resp.body) {
				var text = resp.body;
				try { // maybe extract message from JSON structure
					var r = JSON.parse(resp.body);
					if (r && r.$diagnoses && r.$diagnoses[0]) {
						text = r.$diagnoses[0].$message;
					}
				} catch (e) {
					// ignore parse error;
				}
				throw new Error(text);
			} else {
				throw new Error(http.STATUS_CODES[resp.statusCode]);
			}
		} else {

			throw new Error(resp.statusCode + ": " + locale.format(module, "commError"));
		}
		return {
			$prototype: this.responsePrototype
		};
	}

});

exports.execute = function(_, stubName, portName, operationName, data, context, stubType, localizations) {
	var response;
	var runtime = new Runtime(_, stubName, portName, operationName, data, context, stubType, localizations);
	tracer.traceSection("Execute SOAP operation: '" + operationName + "' on port '" + portName + "' of service: '" + stubName + "'");
	response = runtime.execute(_, context);
	return response;
};