"use strict";

var helpers = require("syracuse-core/lib/helpers");
var util = require("util");
var jsxml = require('jsxml');
var streams = require('streamline/lib/streams/streams');
var types = require('syracuse-core/lib/types/allTypes');
var forEachKey = helpers.object.forEachKey;
var soapTracer = require('../common/soapTracer');
var soapTimer = require('../common/soapTimer');
var stubUtils = require('./stubUtils');

var tracer = soapTracer.create("client");
var timer = soapTimer.create("runtime");

var Runtime = helpers.defineClass(function(_, stubName, portName, operationName, data, context) {
	
	
	this.context = context;

	this.data = data;

	this.stub = stubUtils.getSoapStub(_, stubName, context);
	this.port = stubUtils.getSoapStubPort(_, stubName, portName, context);
	this.operation = stubUtils.getSoapStubPortOperation(_, stubName, portName, operationName, context);

	this.requestPrototype = stubUtils.getOperationPrototype(_, stubName, portName, operationName, "$request", context);
	this.responsePrototype = stubUtils.getOperationPrototype(_, stubName, portName, operationName, "$response", context);
	
	

	
	
	
	
}, null, {
	execute: function(_){
		
		

		
		
		function send(_, envelope){
			
			var envelope = '<?xml version="1.0" encoding="utf-8"?>\n' + envelope;
			tracer.traceSubSection("Send request parameters:",envelope);
			var opt = {
				method: self.port.method(_),
				url: self.port.location(_),
				headers: {
					"content-type": "text/xml; charset=utf-8",
					"content-length": Buffer.byteLength(envelope, "utf8")
				}
			};
			
			var authentication = self.stub.authentication(_);
			if (authentication !== "none"){
				if (authentication === "basic"){
					opt.headers.Authorization = "Basic "+new Buffer(self.stub.authUser(_)+":"+self.stub.authPassword(_)).toString('base64')
				}
			}
			
			var soapAction = self.operation.soapAction(_);
			if (soapAction){
				opt.headers.soapaction = soapAction;
			}

			if (helpers.proxy){
				opt.proxy = "http://"+helpers.proxy.server+":"+helpers.proxy.port;
			}
				
			var request = streams.httpRequest(opt);
			var response = request.end(envelope).response(_);
			var body = response.readAll(_);

			if (response.statusCode === 200 && body){
				return body;
			}else{
				self.context.reply(_, response.statusCode, body);
			}
		}

		
		function buildRequestProperty(name, prototype, data, hasNamespace){
			var target = {};
			if (prototype.$type === "application/x-object"){
				forEachKey(prototype.$item.$properties, function(key, value) {
					if (value.$type === "application/x-object"){						
						var val = buildRequestProperty(key, value, data && data[key])
						target[prefix + ":" + key] = val || {};
						if (hasNamespace){
							target[prefix + ":" + key].$ = {};
							target[prefix + ":" + key].$["xmlns:"+prefix] = namespace;
						}

					}else if (value.$type === "application/x-array"){
						var subTarget = [];
						
						forEachKey(value.$item.$properties, function(k, v) {
							if (data && data[key])
							data[key].forEach(function(elt){
								var val = elt[k]
									if (!val && v.$isMandatory)
										val = v.$default;
									if (val)
										subTarget.push(buildRequestProperty(k, v, val));
							});
						});
						
						if (subTarget.length !== 0)
							target[prefix + ":" + key] = subTarget;
						
					}else{	
						var val = data && data[key];
						if (!val && value.$isMandatory)
							val = value.$default;
						
						if (val){
							val = convertValue(key, value.$type, val);
							
							target[prefix + ":" + key] = {};
							target[prefix + ":" + key].$value = val.toString();
						}
					}
				});

			}else if (prototype.$type === "application/x-array"){
				
				throw new Error("Root element as Array is supported yet.");
			
			}else{
				var val = data;
				if (!val && prototype.$isMandatory)
					val = prototype.$default;
				
				if (val){
					val = convertValue(name, prototype.$type, val);
					
					target[prefix + ":" + name] = {};
					target[prefix + ":" + name].$value = val.toString();
				}
				
				
			}
			return Object.keys(target).length !== 0 ? target : null;
			
		} // End buildRequestProperty
		
		function buildResponseProperty(properties, name, node, ns){

			var target = {};
			
			if (typeof node ==='object' && Object.keys(node).length !== 0){

				forEachKey(Object.keys(node), function(key, value) {
					if (value !== '$'){

						var nodeName = ns ? value.split(':')[1] : value;
						//console.log("BUILD PROPERTY: "+nodeName);
						var property = properties[nodeName];

						if (property.$type === "application/x-object"){
							target[nodeName] = buildResponseProperty(property.$item.$properties, nodeName, node[value], ns);
						}
						else if (property.$type === "application/x-array"){
							
							var subTarget = [];

							var handleArray = function(aVal, aTarget){
								if (typeof aVal === 'object'){
									
									var sub = {};
									forEachKey(aVal, function(k, nod) {
										var subNodeName = ns ? k.split(':')[1] : k;
										var subProp = property.$item.$properties[subNodeName];

										if (subProp.$type === "application/x-object" || subProp.$type === "application/x-array"){
											sub[subNodeName] = buildResponseProperty(subProp.$item.$properties, subNodeName, nod, ns);
										}else{
											sub[subNodeName] = convertValue(subNodeName, subProp.$type, nod);
										}

									});
									aTarget.push(sub);
									
									
								}
								else if (typeof aVal === 'string'){
									var subNodeName = Object.keys(property.$item.$properties)[0];
									var subProp = property.$item.$properties[subNodeName];

									var sub = {};
									sub[nodeName] = convertValue(subNodeName, subProp.$type, aVal);

									aTarget.push(sub);
								}
							} // End handleArray
							
							
							if (Array.isArray(node[value])){
								node[value].forEach(function(val){
									handleArray(val, subTarget);
								});
							}else{
								handleArray(node[value], subTarget);
							}

							target[nodeName] = subTarget;

						}
						else if (typeof node[value] === 'string'){
							target[nodeName] = convertValue(nodeName, property.$type, node[value]);
						}
					}
				});
			}else if (properties.$type){
				
				target[name] = convertValue(name, properties.$type, node);
				
			}

			return target;
		} // buildResponseProperty

		
		var prefix, namespace;
		function calcNamespace(xmlns){
			prefix = "";
			namespace = null;
			if (xmlns){
				prefix = xmlns.substring(0, xmlns.indexOf(':'));
				namespace = xmlns.substring(prefix.length + 1);
			}
		} // End calcNamespace
		
		
		var self = this;
		var envelope = {
			"soap:Envelope": {

				$: {
					"xmlns:soap": "http://schemas.xmlsoap.org/soap/envelope/"
//						"xmlns:xs": "http://www.w3.org/2001/XMLSchema",
//						"xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance"
				}
			}
		};

		//console.log("Data="+JSON.stringify(this.data,null,2));
		timer.start();
		if (this.requestPrototype.$properties.header){
			var proto = this.requestPrototype.$properties.header;
			calcNamespace(proto.$xmlns);
			envelope["soap:Envelope"]["soap:Header"] = buildRequestProperty('header', proto, this.data && this.data.header, true);
		}
		
		
		if (this.requestPrototype.$properties.body){
			var proto = this.requestPrototype.$properties.body;
			calcNamespace(proto.$xmlns);
			envelope["soap:Envelope"]["soap:Body"] = buildRequestProperty('body', proto, this.data && this.data.body, true);
			console.log("Body request="+JSON.stringify(envelope["soap:Envelope"]["soap:Body"],null,2));

		}

		
		var envXml = jsxml.stringify(envelope, { indent: '\t' });
		console.log("Request transformation duration: "+ timer.calc()+" ms");
			

		
		
		timer.start();
		var jsonResp, resp = send(_, envXml);
		
		console.log("Send request duration: "+ timer.calc()+" ms");
		if (resp){
			jsonResp = jsxml.parse(resp);
			tracer.traceSubSection("Receive response:", JSON.stringify(jsonResp,null,2));
			
			timer.start();
			var root = Object.keys(jsonResp)[0];
			var soapNs = '';
			if (root.indexOf(':') !== -1)
				soapNs = root.split(':')[0] + ':';
			
			
			if (this.responsePrototype.$properties.header){
				
				var headerNode = jsonResp[root][soapNs + "Header"];
				if (headerNode){
					
					var headerRoot = Object.keys(headerNode)[0];
					var wsNs = null;

					if (headerRoot !== (soapNs + "Fault")){
						if (headerRoot.indexOf(':') !== -1)
							wsNs = headerRoot.split(':')[0] + ':';
						
						this.responsePrototype.header = buildResponseProperty(this.responsePrototype.$properties.header.$item.$properties, 'header', headerNode, wsNs);
						
					}else{
						throw new Error("Header Soap fault.");
					}
				}else{
					throw new Error("Expected 'soap:Header' not received.")
				}
				
				
			}
			
			
			if (this.responsePrototype.$properties.body){
				
				var bodyNode = jsonResp[root][soapNs + "Body"];
				if (bodyNode){
					
					var bodyRoot = Object.keys(bodyNode)[0];
					var wsNs = null;
					
					if (bodyRoot !== (soapNs + "Fault")){
						if (bodyRoot.indexOf(':') !== -1)
							wsNs = bodyRoot.split(':')[0] + ':';
	
						this.responsePrototype.body = buildResponseProperty(this.responsePrototype.$properties.body.$item.$properties, 'body', bodyNode, wsNs)
					}else{
						throw new Error("Body Soap fault.");
					}
					//console.log("BODY="+JSON.stringify(this.responsePrototype.body,null,2));
				}else{
					throw new Error("Expected 'soap:Body' not received.")
				}
				
				
			}
			console.log("Response transformation duration: "+ timer.calc()+" ms");

		}else{
			throw new Error("An error has occured on remote server.");
		}
		return {$prototype: this.responsePrototype};
	}

});


function convertValue(name, type, value){
	//console.log("Convert '"+name+"' value '"+value+"' for type: '"+type);
	try{
		if (value == null)
			return "";
		switch (type) {
			case "application/x-date":
					return types.date.parse(value).toString();
			case "application/x-time":
					return types.time.parse(value).toString();
			case "application/x-datetime":
					return types.datetime.parse(value).toString();
			case "application/x-uuid":
			case "application/x-password":
			case "application/x-choice":
			case "application/x-string":
				return value;
			case "application/x-integer":
				return parseInt(value);
			case "application/x-real":
			case "application/x-decimal":
				return parseFloat(value);
			case "application/x-boolean":
				return value == "true";
			case "application/x-json":
				return JSON.parse(value);
			default:
				throw new Error("Type: '"+type+"' is not valid.");
		}
	}catch(e){
		throw new Error("Error in convertValue: "+e.stack);

	}
}

exports.execute = function(_, stubName, portName, operationName, data, context){
	
	var response;
	var runtime = new Runtime(_, stubName, portName, operationName, data, context);
	try{
		tracer.traceSection("Execute SOAP operation: '"+operationName+"' on port '"+portName+"' of service: '" + stubName +"'");
		response = runtime.execute(_);
	}catch(e){
		console.error(e.stack);
		//response = runtime.addSoapBodyException(e, "soap:Server");
	}finally{

		//console.log("SOAP Call duration: "+ timer.calc()+" ms");
		return response
	}
}