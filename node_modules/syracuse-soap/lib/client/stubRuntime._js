"use strict";

var helpers = require("syracuse-core/lib/helpers");
var locale = require("syracuse-core/lib/locale");
var http = require('http');
var httpClient = require("syracuse-httpclient/lib/httpClient");
var jsxml = require('jsxml');
var forEachKey = helpers.object.forEachKey;
var soapTracer = require('../common/soapTracer');
var soapTimer = require('../common/soapTimer');
var stubUtils = require('./stubUtils');

var tracer = soapTracer.create("client");
var timer = soapTimer.create("runtime");

var Runtime = helpers.defineClass(function(_, stubName, portName, operationName, data, context, isIncomingChild) {

	this.context = context;

	this.data = data;

	this.stub = stubUtils.getSoapStub(_, stubName, context, isIncomingChild);
	this.port = stubUtils.getSoapStubPort(_, stubName, portName, context, isIncomingChild);
	this.operation = stubUtils.getSoapStubPortOperation(_, stubName, portName, operationName, context, isIncomingChild);

	this.requestPrototype = stubUtils.getOperationPrototype(_, stubName, portName, operationName, "$request", context, isIncomingChild);
	this.responsePrototype = stubUtils.getOperationPrototype(_, stubName, portName, operationName, "$response", context, isIncomingChild);

}, null, {
	execute: function(_) {

		function send(_, envelope) {
			envelope = '<?xml version="1.0" encoding="utf-8"?>\n' + envelope;
			tracer.traceSubSection("Send request parameters:", envelope);
			var opt = {
				method: self.port.method(_),
				url: self.port.location(_),
				headers: {
					"content-type": "text/xml; charset=utf-8",
					"content-length": Buffer.byteLength(envelope, "utf8")
				}
			};

			var isChild = self.stub.isChild(_) || false;
			var authentication = self.stub.authentication(_);
			if (!isChild && authentication !== "none") {
				if (authentication === "basic") {
					opt.headers.Authorization = "Basic " + new Buffer(self.stub.authUser(_) + ":" + self.stub.authPassword(_)).toString('base64');
				}
			} else if (isChild) {
				opt.headers.cookie = self.context.httpSession.cookie;
			}

			var soapAction = self.operation.soapAction(_);
			if (soapAction) {
				opt.headers.soapaction = soapAction;
			} else {
				opt.headers.soapaction = "";
			}

			var request = httpClient.httpRequest(_, opt);
			var response = request.end(envelope).response(_);
			var body = response.readAll(_);

			return {
				statusCode: response.statusCode,
				body: body
			};
		}

		function buildRequestProperty(name, prototype, data, hasNamespace) {
			var target = {};
			if (prototype.$type === "application/x-object") {
				forEachKey(prototype.$item.$properties, function(key, value) {
					var val;
					if (value.$type === "application/x-object") {
						val = buildRequestProperty(key, value, data && data[key]);
						target[prefix + ":" + key] = val || {};
						if (hasNamespace) {
							target[prefix + ":" + key].$ = {};
							target[prefix + ":" + key].$["xmlns:" + prefix] = namespace;
						}

					} else if (value.$type === "application/x-array") {
						var subTarget = [];

						forEachKey(value.$item.$properties, function(k, v) {
							if (data && data[key]) data[key].forEach(function(elt) {
								val = elt[k];
								if (!val && v.$isMandatory) val = v.$default;
								if (val) subTarget.push(buildRequestProperty(k, v, val));
							});
						});

						if (subTarget.length !== 0) target[prefix + ":" + key] = subTarget;

					} else {
						val = data && data[key];
						if (!val && value.$isMandatory) val = value.$default;

						if (val) {
							val = stubUtils.convertValue(key, value.$type, val);

							target[prefix + ":" + key] = {};
							target[prefix + ":" + key].$value = val.toString();
						}
					}
				});

			} else if (prototype.$type === "application/x-array") {

				throw new Error(locale.format(module, "rootArrayNYI"));

			} else {
				var val = data;
				if (!val && prototype.$isMandatory) val = prototype.$default;

				if (val) {
					val = stubUtils.convertValue(name, prototype.$type, val);

					target[prefix + ":" + name] = {};
					target[prefix + ":" + name].$value = val.toString();
				}

			}
			return Object.keys(target).length !== 0 ? target : null;

		} // End buildRequestProperty

		function buildResponseProperty(properties, name, node, ns) {

			var target = {};

			if (typeof node === 'object' && Object.keys(node).length !== 0) {
				var obj;
				if (Array.isArray(node)) {
					obj = Object.keys(node[0]);
				} else {
					obj = Object.keys(node);
				}

				forEachKey(obj, function(key, value) {
					if (value !== '$') {

						var nodeName = ns ? value.split(':')[1] : value;

						var property = properties[nodeName];
						//tracer.traceSubSection("BUILD PROPERTY: "+nodeName);

						if (property.$type === "application/x-array") {

							var subTarget = [];

							var handleArray = function(aVal, aTarget) {
								var sub;
								if (typeof aVal === 'object') {

									sub = {};
									forEachKey(aVal, function(k, nod) {
										var subNodeName = ns ? k.split(':')[1] : k;
										var subProp = property.$item.$properties[subNodeName];

										if (subProp.$type === "application/x-object" || subProp.$type === "application/x-array") {
											sub[subNodeName] = buildResponseProperty(subProp.$item.$properties, subNodeName, nod, ns);
										} else {
											sub[subNodeName] = stubUtils.convertValue(subNodeName, subProp.$type, nod);
										}

									});
									aTarget.push(sub);

								} else if (typeof aVal === 'string') {
									//console.log("TEST="+JSON.stringify(property,null,2));
									var subNodeName = Object.keys(property.$item.$properties)[0];
									var subProp = property.$item.$properties[subNodeName];

									sub = {};
									sub[nodeName] = stubUtils.convertValue(subNodeName, subProp.$type, aVal);

									aTarget.push(sub);
								}
							}; // End handleArray

							if (Array.isArray(node[value])) {
								node[value].forEach(function(val) {
									handleArray(val, subTarget);
								});
							} else {
								handleArray(node[value], subTarget);
							}

							target[nodeName] = subTarget;

						} else if (property.$type === "application/x-object") {
							target[nodeName] = buildResponseProperty(property.$item.$properties, nodeName, node[value], ns);
						} else if (typeof node[value] === 'string') {
							target[nodeName] = stubUtils.convertValue(nodeName, property.$type, node[value]);
						}
					}
				});
			} else if (properties.$type) {

				target[name] = stubUtils.convertValue(name, properties.$type, node);

			}

			return target;
		} // buildResponseProperty

		function throwSoapFault(faultNode) {

			var faultCode = typeof faultNode.faultcode === 'object' ? faultNode.faultcode.$value : faultNode.faultcode;
			var faultString = typeof faultNode.faultstring === 'object' ? faultNode.faultstring.$value : faultNode.faultstring;
			var detail = typeof faultNode.detail === 'object' ? faultNode.detail.$value : faultNode.detail;

			throw new Error("Soap fault [" + faultCode + "]: " + (detail || ""));
		}

		var prefix, namespace;

		function calcNamespace(xmlns) {
			prefix = "";
			namespace = null;
			if (xmlns) {
				prefix = xmlns.substring(0, xmlns.indexOf(':'));
				namespace = xmlns.substring(prefix.length + 1);
			}
		} // End calcNamespace

		var self = this;
		var envelope = {
			"soap:Envelope": {

				$: {
					"xmlns:soap": "http://schemas.xmlsoap.org/soap/envelope/"
					//						"xmlns:xs": "http://www.w3.org/2001/XMLSchema",
					//						"xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance"
				}
			}
		};

		//console.log("Data="+JSON.stringify(this.data,null,2));
		timer.start();
		var proto;
		if (this.requestPrototype.$properties.header) {
			proto = this.requestPrototype.$properties.header;
			calcNamespace(proto.$xmlns);
			envelope["soap:Envelope"]["soap:Header"] = buildRequestProperty('header', proto, this.data && this.data.header, true);
		}

		if (this.requestPrototype.$properties.body) {
			proto = this.requestPrototype.$properties.body;
			calcNamespace(proto.$xmlns);
			envelope["soap:Envelope"]["soap:Body"] = buildRequestProperty('body', proto, this.data && this.data.body, true);
			//console.log("Body request="+JSON.stringify(envelope["soap:Envelope"]["soap:Body"],null,2));

		}

		var envXml = jsxml.stringify(envelope, {
			indent: '\t'
		});
		console.log("Request transformation duration: " + timer.calc() + " ms");

		timer.start();
		var jsonResp, resp = send(_, envXml);

		console.log("Send request duration: " + timer.calc() + " ms");
		if (resp) {

			if (resp.statusCode === 200 && resp.body) {

				jsonResp = jsxml.parse(resp.body);
				tracer.traceSubSection("Receive response:", JSON.stringify(jsonResp, null, 2));

				timer.start();
				var root = Object.keys(jsonResp)[0];
				var soapNs = '';
				if (root.indexOf(':') !== -1) soapNs = root.split(':')[0] + ':';

				var wsNs;
				if (this.responsePrototype.$properties.header) {

					var headerNode = jsonResp[root][soapNs + "Header"];
					if (headerNode) {

						var headerRoot = Object.keys(headerNode)[0];
						wsNs = null;

						if (headerRoot !== (soapNs + "Fault")) {
							if (headerRoot.indexOf(':') !== -1) wsNs = headerRoot.split(':')[0] + ':';

							this.responsePrototype.header = buildResponseProperty(this.responsePrototype.$properties.header.$item.$properties, 'header', headerNode, wsNs);

						} else {
							throwSoapFault(headerNode[headerRoot]);
						}
					} else {
						throw new Error(locale.format(module, "headerNotReceived"));
					}

				}

				if (this.responsePrototype.$properties.body) {

					var bodyNode = jsonResp[root][soapNs + "Body"];
					if (bodyNode) {

						var bodyRoot = Object.keys(bodyNode)[0];
						wsNs = null;

						if (bodyRoot !== (soapNs + "Fault")) {
							if (bodyRoot.indexOf(':') !== -1) wsNs = bodyRoot.split(':')[0] + ':';

							this.responsePrototype.body = buildResponseProperty(this.responsePrototype.$properties.body.$item.$properties, 'body', bodyNode, wsNs);
						} else {
							throwSoapFault(bodyNode[bodyRoot]);
						}
						//console.log("BODY="+JSON.stringify(this.responsePrototype.body,null,2));
					} else {
						throw new Error(locale.format(module, "bodyNotReceived"));
					}

				}
				console.log("Response transformation duration: " + timer.calc() + " ms");
			} else {
				throw new Error(http.STATUS_CODES[resp.statusCode]);
			}
		} else {

			throw new Error(resp.statusCode + ": " + locale.format(module, "commError"));
		}
		return {
			$prototype: this.responsePrototype
		};
	}

});

exports.execute = function(_, stubName, portName, operationName, data, context, isIncomingChild) {

	var response;
	var runtime = new Runtime(_, stubName, portName, operationName, data, context, isIncomingChild);
	try {
		tracer.traceSection("Execute SOAP operation: '" + operationName + "' on port '" + portName + "' of service: '" + stubName + "'");
		response = runtime.execute(_);
		return response;
	} catch (e) {
		context.reply(_, 500, e.message);
	} finally {

	}
};