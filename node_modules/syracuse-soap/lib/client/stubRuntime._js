"use strict";

var helpers = require("syracuse-core/lib/helpers");
var util = require("util");
var locale = require("syracuse-core/lib/locale");
var jsxml = require('jsxml');
var globals = require('streamline/lib/globals');
var streams = require('streamline/lib/streams/streams');
var types = require('syracuse-core/lib/types/allTypes');
var forEachKey = helpers.object.forEachKey;
var soapTracer = require('../common/soapTracer');
var soapTimer = require('../common/soapTimer');
var stubUtils = require('./stubUtils');

var tracer = soapTracer.create("client");
var timer = soapTimer.create("runtime");

var Runtime = helpers.defineClass(function(_, stubName, portName, operationName, data, context, isIncomingChild) {
	
	
	this.context = context;

	this.data = data;

	this.stub = stubUtils.getSoapStub(_, stubName, context, isIncomingChild);
	this.port = stubUtils.getSoapStubPort(_, stubName, portName, context, isIncomingChild);
	this.operation = stubUtils.getSoapStubPortOperation(_, stubName, portName, operationName, context, isIncomingChild);

	this.requestPrototype = stubUtils.getOperationPrototype(_, stubName, portName, operationName, "$request", context, isIncomingChild);
	this.responsePrototype = stubUtils.getOperationPrototype(_, stubName, portName, operationName, "$response", context, isIncomingChild);
	
	

	
	
	
	
}, null, {
	execute: function(_){
		
		

		
		
		function send(_, envelope){
			
			try{
				var envelope = '<?xml version="1.0" encoding="utf-8"?>\n' + envelope;
				tracer.traceSubSection("Send request parameters:",envelope);
				var opt = {
					method: self.port.method(_),
					url: self.port.location(_),
					headers: {
						"content-type": "text/xml; charset=utf-8",
						"content-length": Buffer.byteLength(envelope, "utf8")
					}
				};
				
				var isChild = self.stub.isChild(_) || false;
				var authentication = self.stub.authentication(_);
				if (!isChild && authentication !== "none"){
					if (authentication === "basic"){
						opt.headers.Authorization = "Basic "+new Buffer(self.stub.authUser(_)+":"+self.stub.authPassword(_)).toString('base64')
					}
				}else if (isChild){
					opt.headers.cookie = self.context.httpSession.cookie;
				}
				
				var soapAction = self.operation.soapAction(_);
				if (soapAction){
					opt.headers.soapaction = soapAction;
				}else{
					opt.headers.soapaction = "";
				}
	
				if (helpers.proxy){
					opt.proxy = "http://"+helpers.proxy.server+":"+helpers.proxy.port;
				}
					
				var request = streams.httpRequest(opt);
				var response = request.end(envelope).response(_);
				var body = response.readAll(_);
	
				return {
					statusCode: response.statusCode,
					body: body
				}
			}catch(e){
				throw new Error(locale.format(module, "sendError", e.message))
			}

		}

		
		function buildRequestProperty(name, prototype, data, hasNamespace){
			var target = {};
			if (prototype.$type === "application/x-object"){
				forEachKey(prototype.$item.$properties, function(key, value) {
					if (value.$type === "application/x-object"){						
						var val = buildRequestProperty(key, value, data && data[key])
						target[prefix + ":" + key] = val || {};
						if (hasNamespace){
							target[prefix + ":" + key].$ = {};
							target[prefix + ":" + key].$["xmlns:"+prefix] = namespace;
						}

					}else if (value.$type === "application/x-array"){
						var subTarget = [];
						
						forEachKey(value.$item.$properties, function(k, v) {
							if (data && data[key])
							data[key].forEach(function(elt){
								var val = elt[k]
									if (!val && v.$isMandatory)
										val = v.$default;
									if (val)
										subTarget.push(buildRequestProperty(k, v, val));
							});
						});
						
						if (subTarget.length !== 0)
							target[prefix + ":" + key] = subTarget;
						
					}else{	
						var val = data && data[key];
						if (!val && value.$isMandatory)
							val = value.$default;
						
						if (val){
							val = stubUtils.convertValue(key, value.$type, val);
							
							target[prefix + ":" + key] = {};
							target[prefix + ":" + key].$value = val.toString();
						}
					}
				});

			}else if (prototype.$type === "application/x-array"){
				
				throw new Error(locale.format(module, "rootArrayNYI"));
			
			}else{
				var val = data;
				if (!val && prototype.$isMandatory)
					val = prototype.$default;
				
				if (val){
					val = stubUtils.convertValue(name, prototype.$type, val);
					
					target[prefix + ":" + name] = {};
					target[prefix + ":" + name].$value = val.toString();
				}
				
				
			}
			return Object.keys(target).length !== 0 ? target : null;
			
		} // End buildRequestProperty
		
		function buildResponseProperty(properties, name, node, ns){

			var target = {};
			
			if (typeof node ==='object' && Object.keys(node).length !== 0){
				var obj;
				if (Array.isArray(node)){
					obj = Object.keys(node[0]);
				}else{
					obj = Object.keys(node);
				}
				
				forEachKey(obj, function(key, value) {
					if (value !== '$'){

						var nodeName = ns ? value.split(':')[1] : value;

						
						var property = properties[nodeName];
						//tracer.traceSubSection("BUILD PROPERTY: "+nodeName);

						if (property.$type === "application/x-array"){
							
							var subTarget = [];

							var handleArray = function(aVal, aTarget){
								if (typeof aVal === 'object'){
									
									var sub = {};
									forEachKey(aVal, function(k, nod) {
										var subNodeName = ns ? k.split(':')[1] : k;
										var subProp = property.$item.$properties[subNodeName];

										if (subProp.$type === "application/x-object" || subProp.$type === "application/x-array"){
											sub[subNodeName] = buildResponseProperty(subProp.$item.$properties, subNodeName, nod, ns);
										}else{
											sub[subNodeName] = stubUtils.convertValue(subNodeName, subProp.$type, nod);
										}

									});
									aTarget.push(sub);
									
									
								}
								else if (typeof aVal === 'string'){
									//console.log("TEST="+JSON.stringify(property,null,2));
									var subNodeName = Object.keys(property.$item.$properties)[0];
									var subProp = property.$item.$properties[subNodeName];

									var sub = {};
									sub[nodeName] = stubUtils.convertValue(subNodeName, subProp.$type, aVal);

									aTarget.push(sub);
								}
							} // End handleArray
							
							
							if (Array.isArray(node[value])){
								node[value].forEach(function(val){
									handleArray(val, subTarget);
								});
							}else{
								handleArray(node[value], subTarget);
							}

							target[nodeName] = subTarget;

						}
						else if (property.$type === "application/x-object"){
							target[nodeName] = buildResponseProperty(property.$item.$properties, nodeName, node[value], ns);
						}
						else if (typeof node[value] === 'string'){
							target[nodeName] = stubUtils.convertValue(nodeName, property.$type, node[value]);
						}
					}
				});
			}else if (properties.$type){
				
				target[name] = stubUtils.convertValue(name, properties.$type, node);
				
			}

			return target;
		} // buildResponseProperty

		
		function throwSoapFault(faultNode){
			
			var faultCode = typeof faultNode.faultcode === 'object' ? faultNode.faultcode.$value : faultNode.faultcode;
			var faultString = typeof faultNode.faultstring === 'object' ? faultNode.faultstring.$value : faultNode.faultstring;
			var detail = typeof faultNode.detail === 'object' ? faultNode.detail.$value : faultNode.detail;

			throw new Error("Soap fault ["+faultCode+"]: "+(detail || ""));
		}
		
		var prefix, namespace;
		function calcNamespace(xmlns){
			prefix = "";
			namespace = null;
			if (xmlns){
				prefix = xmlns.substring(0, xmlns.indexOf(':'));
				namespace = xmlns.substring(prefix.length + 1);
			}
		} // End calcNamespace
		
		
		var self = this;
		var envelope = {
			"soap:Envelope": {

				$: {
					"xmlns:soap": "http://schemas.xmlsoap.org/soap/envelope/"
//						"xmlns:xs": "http://www.w3.org/2001/XMLSchema",
//						"xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance"
				}
			}
		};

		//console.log("Data="+JSON.stringify(this.data,null,2));
		timer.start();
		if (this.requestPrototype.$properties.header){
			var proto = this.requestPrototype.$properties.header;
			calcNamespace(proto.$xmlns);
			envelope["soap:Envelope"]["soap:Header"] = buildRequestProperty('header', proto, this.data && this.data.header, true);
		}
		
		
		if (this.requestPrototype.$properties.body){
			var proto = this.requestPrototype.$properties.body;
			calcNamespace(proto.$xmlns);
			envelope["soap:Envelope"]["soap:Body"] = buildRequestProperty('body', proto, this.data && this.data.body, true);
			//console.log("Body request="+JSON.stringify(envelope["soap:Envelope"]["soap:Body"],null,2));

		}

		
		var envXml = jsxml.stringify(envelope, { indent: '\t' });
		console.log("Request transformation duration: "+ timer.calc()+" ms");
			

		
		
		timer.start();
		var jsonResp, resp = send(_, envXml);

		console.log("Send request duration: "+ timer.calc()+" ms");
		if (resp){

			if (resp.statusCode === 200 && resp.body){
				

				jsonResp = jsxml.parse(resp.body);
				tracer.traceSubSection("Receive response:", JSON.stringify(jsonResp,null,2));
				
				timer.start();
				var root = Object.keys(jsonResp)[0];
				var soapNs = '';
				if (root.indexOf(':') !== -1)
					soapNs = root.split(':')[0] + ':';
				
				
				if (this.responsePrototype.$properties.header){
					
					var headerNode = jsonResp[root][soapNs + "Header"];
					if (headerNode){
						
						var headerRoot = Object.keys(headerNode)[0];
						var wsNs = null;
	
						if (headerRoot !== (soapNs + "Fault")){
							if (headerRoot.indexOf(':') !== -1)
								wsNs = headerRoot.split(':')[0] + ':';
							
							this.responsePrototype.header = buildResponseProperty(this.responsePrototype.$properties.header.$item.$properties, 'header', headerNode, wsNs);
							
						}else{
							throwSoapFault(headerNode[headerRoot]);
						}
					}else{
						throw new Error(locale.format(module, "headerNotReceived"));
					}
					
					
				}
				
				
				if (this.responsePrototype.$properties.body){
					
					var bodyNode = jsonResp[root][soapNs + "Body"];
					if (bodyNode){
						
						var bodyRoot = Object.keys(bodyNode)[0];
						var wsNs = null;
						
						if (bodyRoot !== (soapNs + "Fault")){
							if (bodyRoot.indexOf(':') !== -1)
								wsNs = bodyRoot.split(':')[0] + ':';
		
							this.responsePrototype.body = buildResponseProperty(this.responsePrototype.$properties.body.$item.$properties, 'body', bodyNode, wsNs)
						}else{
							throwSoapFault(bodyNode[bodyRoot]);
						}
						//console.log("BODY="+JSON.stringify(this.responsePrototype.body,null,2));
					}else{
						throw new Error(locale.format(module, "bodyNotReceived"));
					}
					
					
				}
				console.log("Response transformation duration: "+ timer.calc()+" ms");
			}else{
				throw new Error(resp.body || locale.format(module, "unknowError"));
			}
		}else{
			
			
			throw new Error(resp.statusCode+": "+locale.format(module, "commError"));
		}
		return {$prototype: this.responsePrototype};
	}

});




exports.execute = function(_, stubName, portName, operationName, data, context, isIncomingChild){
	
	var response;
	var runtime = new Runtime(_, stubName, portName, operationName, data, context, isIncomingChild);
	try{
		tracer.traceSection("Execute SOAP operation: '"+operationName+"' on port '"+portName+"' of service: '" + stubName +"'");
		response = runtime.execute(_);
		return response;
	}catch(e){
		console.error(e.stack);
		context.reply(_, 500, e.message);
	}finally{

		
	}
}