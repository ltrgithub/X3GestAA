"use strict";
var helpers = require('syracuse-core/lib/helpers');
var binaryHelper = require('syracuse-core/lib/binaryHelper');
var jsxml = require('jsxml');

var OutputBuilder = helpers.defineClass(function(wsCall, resultParamMap, options) {
	this.options = options || {};
	// temp to say MUST match to old implementation (V6)
	this.options.v6 = true;

	this.resultParamMap = resultParamMap;
	this.currentIdx = 0;

	this.action = wsCall.action;
	this.description = wsCall.description;
	this.lang = (wsCall.context && wsCall.context.x3language) || "ENG";
	this.beautify = wsCall.beautify;
}, null, {
	findMenuLabel: function(idMenu, resu) {
		var menus = this.description.ADXMEN.MNU;
		if (!Array.isArray(menus)) {
			menus = [menus];
		}
		var found = null;
		for (var i = 0; i < menus.length && !found; i++) {
			var menu = menus[i];

			if (menu.$.NO === idMenu && this.lang) {
				// find right VAL
				var vals = !Array.isArray(menu.VAL) ? [menu.VAL] : menu.VAL;

				for (var j = 0; j < vals.length && !found; j++) {
					if (parseInt(vals[j].$.IND, 10) === parseInt(resu, 10)) {
						found = vals[j].$["C_" + this.lang];
					}
				}
			}
		}
		return found;
	}
});

exports.OutputBuilderXml = helpers.defineClass(function(wsCall, resultParamMap, options) {
	OutputBuilder.call(this, wsCall, resultParamMap, options);
	// ignore some types for null values
	this.typesIgnoredNull = ["Date", "Blob"];
	// some fields are related to localmenus with DIM > 1 : these fields have not same default values
	this.specialFieldsIdx = [];
}, OutputBuilder, {
	build: function() {
		var self = this;
		var output = {
			RESULT: {
				$: {}
			}
		};
		var descripData = self.description.ADXDATA;
		if (this.action === "LIST") {
			descripData = self.description.ADXKEY;
		}
		var grps = Array.isArray(descripData.GRP) ? descripData.GRP : [descripData.GRP];
		grps && grps.forEach(function(grp) {
			if (grp) {
				if (grp.$.NAM === "LEFTLIST") {
					var size = self.resultParamMap.reduce(function(prev, cur) {
						var len = Object.keys(cur).length;
						return len > prev ? len : prev;
					}, 0);
					if (size !== 0) {
						var flds = Array.isArray(grp.FLD) ? grp.FLD : [grp.FLD];
						var isEmpty = size === 1 && !self.resultParamMap.some(function(_param) {
							return _param[0].resu != null;
						});
						if (!isEmpty) {
							output.RESULT.$.DIM = grp.$.DIM;
							output.RESULT.$.SIZE = size;
							for (var i = 0; i < size; i++) {
								self._createLine(output.RESULT, i, flds);
								self.currentIdx -= flds.length;
							}
						}
					}
				} else {
					// GRP or TAB ?
					var grpKind = grp.$.TYB === "Table" || (grp.$.DIM && parseInt(grp.$.DIM, 10) > 1) ? "TAB" : "GRP";
					if (grpKind === "GRP") {
						self._createGroup(output.RESULT, grp);
					} else if (grpKind === "TAB") {
						self._createTable(output.RESULT, grp);
					}
				}
			}
		});
		var opt = {};
		if (this.beautify) opt.indent = '\t';
		return '<?xml version="1.0" encoding="UTF-8"?>' + (this.beautify ? "\n" : "") + jsxml.stringify(output, opt);
	},
	_createField: function(elt, field, id) {
		var _p, _params = this.resultParamMap[this.currentIdx] && this.resultParamMap[this.currentIdx];
		var _def;
		if (_params && field.$.UNSEL !== "true") {
			if (field.$.DIM > 1) {
				elt.LST = elt.LST || [];

				var _lst = {
					$: {}
				};
				if (field.$.MEN != null) {
					_lst.$.MENULOCAL = field.$.MEN;
				}

				_lst.$.NAME = field.$.NAM;
				_lst.$.SIZE = field.$.DIM;
				_lst.$.TYPE = field.$.TYP;

				for (var i = 0; i < field.$.DIM; i++) {
					_p = _params[i];
					_lst.ITM = _lst.ITM || [];
					var _itm = {
						$: {}
					};
					if (_p && _p.resu != null) {
						_itm.$value = _p.resu;
						// for local menus
						if (field.$.MEN != null) {
							_itm.$.MENULAB = this.findMenuLabel(field.$.MEN, _p.resu);
						}
					} else {
						// some types must not returned with default values
						if (this.typesIgnoredNull.indexOf(field.$.TYP) === -1) {
							_def = this.forceDefaultValue(field.$.TYP);
							if (_def != null) {
								_itm.$value = _def;
							}
						} else {
							_itm.$value = "";
						}
					}
					_lst.ITM.push(_itm);

					// handle special fields
					if (field.$.MEN != null) {
						this.specialFieldsIdx.push(this.currentIdx + i + 1);
					}

				}
				if (_lst.ITM && _lst.ITM.length > 0) {
					_lst.$.SIZE = _lst.ITM.length;
					elt.LST.push(_lst);
				}

			} else {
				_p = _params[id || 0];
				elt.FLD = elt.FLD || [];
				var _fld = {
					$: {}
				};
				if (_p && _p.resu != null) {
					if (field.$.TYP === "Blob") {
						var buf = new Buffer(_p.resu, "hex");
						_fld.$.BYTES = buf.length;
						_fld.$.MIMETYPE = binaryHelper.calcMimeType(buf);
						_fld.$value = buf.toString('base64');
					} else {
						_fld.$value = _p.resu;
					}
					// Menu set only if a resu is available
					if (field.$.MEN != null) {
						_fld.$.MENULAB = this.findMenuLabel(field.$.MEN, _p.resu);
						_fld.$.MENULOCAL = field.$.MEN;
					}
				}
				// force default value for table line without resu (if it's not a menu)
				else if (this.specialFieldsIdx.indexOf(this.currentIdx) < 0) {
					// Menu set only if a resu is available
					if (field.$.MEN != null) {
						_fld.$.MENULAB = "";
						_fld.$.MENULOCAL = field.$.MEN;
						_fld.$value = 0;
					} else {
						// some types must not returned with default values
						if (this.typesIgnoredNull.indexOf(field.$.TYP) === -1) {
							_def = this.forceDefaultValue(field.$.TYP);
							if (_def != null) {
								_fld.$value = _def;
							}
						} else {
							_fld.$value = "";
						}
					}
				}
				// Keep attributes order
				_fld.$.NAME = field.$.NAM;
				// hack to return Integer instead of Char for LEFLIST Menulocals
				if (this.action === "LIST" && field.$.MEN != null) {
					_fld.$.TYPE = "Integer";
				} else {
					_fld.$.TYPE = field.$.TYP;
				}
				//
				elt.FLD.push(_fld);
			}
		}
	},

	_createGroup: function(elt, grp) {
		var self = this;
		elt.GRP = elt.GRP || [];
		var _grp = ({
			$: {
				ID: grp.$.NAM
			}
		});
		var flds = Array.isArray(grp.FLD) ? grp.FLD : [grp.FLD];
		flds.forEach(function(_fld) {
			self._createField(_grp, _fld);
			self.currentIdx++;
		});
		if ((_grp.FLD && _grp.FLD.length > 0) || (_grp.LST && _grp.LST.length > 0)) elt.GRP.push(_grp);
	},

	_createLine: function(elt, num, flds) {
		var self = this;
		elt.LIN = elt.LIN || [];
		var _lin = {
			$: {
				NUM: num + 1
			}
		};
		flds.forEach(function(_fld) {
			self._createField(_lin, _fld, num);
			self.currentIdx++;
		});
		if ((_lin.FLD && _lin.FLD.length > 0) || (_lin.LST && _lin.LST.length > 0)) elt.LIN.push(_lin);
	},

	_createTable: function(elt, grp) {
		elt.TAB = elt.TAB || [];
		// Get size param
		var size;
		if (this.action !== "EXEC") {
			// for objects, the table size is given by the previous parameter
			size = this.resultParamMap[this.currentIdx] && this.resultParamMap[this.currentIdx][0].resu || 0;
			this.currentIdx++;
		} else {
			// for subprograms, we need to compute the table size
			size = this.resultParamMap[this.currentIdx] && Object.keys(this.resultParamMap[this.currentIdx]).length;
		}

		//
		var _tab = ({
			$: {
				DIM: grp.$.DIM,
				ID: grp.$.NAM,
				SIZE: size
			}
		});
		var flds = Array.isArray(grp.FLD) ? grp.FLD : [grp.FLD];
		for (var i = 0; i < size; i++) {
			this._createLine(_tab, i, flds);
			this.currentIdx -= flds.length;
		}
		//
		if (_tab.LIN && _tab.LIN.length > 0) elt.TAB.push(_tab);
		this.currentIdx += flds.length;
	},
	forceDefaultValue: function(type) {
		switch (type) {
			case "Decimal":
			case "Integer":
				return 0;
			default:
				return;
		}
	}
});


exports.OutputBuilderJson = helpers.defineClass(function(wsCall, resultParamMap, options) {
	OutputBuilder.call(this, wsCall, resultParamMap, options);
	// some fields are related to localmenus with DIM > 1 : these fields have not same default values
	this.specialFieldsIdx = [];
}, OutputBuilder, {
	build: function() {
		var self = this;
		var output = {};
		var descripData = self.description.ADXDATA;
		if (this.action === "LIST") {
			output = [];
			descripData = self.description.ADXKEY;
		}
		var grps = Array.isArray(descripData.GRP) ? descripData.GRP : [descripData.GRP];
		grps && grps.forEach(function(grp) {
			if (grp) {
				if (grp.$.NAM === "LEFTLIST") {
					var size = self.resultParamMap.reduce(function(prev, cur) {
						var len = Object.keys(cur).length;
						return len > prev ? len : prev;
					}, 0);
					if (size !== 0) {
						var flds = Array.isArray(grp.FLD) ? grp.FLD : [grp.FLD];
						var isEmpty = size === 1 && !self.resultParamMap.some(function(_param) {
							return _param[0].resu != null;
						});
						if (!isEmpty) {
							for (var i = 0; i < size; i++) {
								self._createLine(output, i, flds);
								self.currentIdx -= flds.length;
							}
						}
					}
				} else {
					// GRP or TAB ?
					var grpKind = grp.$.TYB === "Table" || (grp.$.DIM && parseInt(grp.$.DIM, 10) > 1) ? "TAB" : "GRP";
					if (grpKind === "GRP") {
						self._createGroup(output, grp);
					} else if (grpKind === "TAB") {
						self._createTable(output, grp);
					}
				}
			}
		});
		return this.beautify ? JSON.stringify(output, null, "\t") : JSON.stringify(output);
	},
	_createField: function(elt, field, id) {
		var _p, _params = this.resultParamMap[this.currentIdx] && this.resultParamMap[this.currentIdx];
		if (_params && field.$.UNSEL !== "true") {
			var _val;
			if (field.$.DIM > 1) {

				var _lst = [];
				var _lstLbl = [];
				for (var i = 0; i < field.$.DIM; i++) {
					_p = _params[i];
					if (_p && _p.resu != null) {
						_val = _p.resu;
						if (this.options.v6) {
							// because V6 JSON implementation return integer as string
							if (typeof _val === "number") _val = JSON.stringify(_val);
						}
						_lst.push(_val);
						if (field.$.MEN != null) _lstLbl.push(this.findMenuLabel(field.$.MEN, _p.resu));
					} else {
						_lst.push(this.forceDefaultValue(field.$.TYP));
					}

					// handle special fields
					if (field.$.MEN != null) {
						this.specialFieldsIdx.push(this.currentIdx + i + 1);
					}
				}
				elt[field.$.NAM] = _lst;
				if (_lstLbl.length > 0) elt[field.$.NAM + "_LBL"] = _lstLbl;
			} else {
				_p = _params[id || 0];
				var isResuNull = !_p || _p.resu == null;
				if (field.$.TYP === "Blob" && !isResuNull) {
					var buf = new Buffer(_p.resu, "hex");
					elt[field.$.NAM] = buf.toString('base64');
					elt[field.$.NAM + "_MIME"] = binaryHelper.calcMimeType(buf);
				} else {
					_val = !isResuNull ? _p.resu : this.forceDefaultValue(field.$.TYP);
					if (this.options.v6) {
						// because V6 JSON implementation return integer as string
						if (typeof _val === "number") _val = JSON.stringify(_val);
					}
					elt[field.$.NAM] = _val;
				}
				// Menu set only if a resu is available
				if (field.$.MEN != null) {
					if (isResuNull) elt[field.$.NAM] = null;
					elt[field.$.NAM + "_LBL"] = !isResuNull ? this.findMenuLabel(field.$.MEN, _p.resu) : "";
				}
			}
		}
	},

	_createGroup: function(elt, grp) {
		var self = this;
		var _grp = {};
		var flds = Array.isArray(grp.FLD) ? grp.FLD : [grp.FLD];
		flds.forEach(function(_fld) {
			self._createField(_grp, _fld);
			self.currentIdx++;
		});
		if (Object.keys(_grp).length > 0) elt[grp.$.NAM] = _grp;
	},

	_createLine: function(elt, num, flds) {
		var self = this;
		var _lin = {};
		flds.forEach(function(_fld) {
			// force field even if resu is null
			self._createField(_lin, _fld, num);
			self.currentIdx++;
		});
		if (Object.keys(_lin).length > 0) elt.push(_lin);
	},

	_createTable: function(elt, grp) {
		// Get size param
		var size;
		if (this.action !== "EXEC") {
			// for objects, the table size is given by the previous parameter
			size = this.resultParamMap[this.currentIdx] && this.resultParamMap[this.currentIdx][0].resu || 0;
			this.currentIdx++;
		} else {
			// for subprograms, we need to compute the table size
			size = this.resultParamMap[this.currentIdx] && Object.keys(this.resultParamMap[this.currentIdx]).length;
		}


		//
		var _tab = [];
		var flds = Array.isArray(grp.FLD) ? grp.FLD : [grp.FLD];
		for (var i = 0; i < size; i++) {
			this._createLine(_tab, i, flds);
			this.currentIdx -= flds.length;
		}
		//
		elt[grp.$.NAM] = _tab;
		this.currentIdx += flds.length;
	},
	forceDefaultValue: function(type) {
		if (this.specialFieldsIdx.indexOf(this.currentIdx) >= 0) {
			return null;
		}
		switch (type) {
			case "Decimal":
			case "Integer":
				return "0";
			case "Char":
				return "";
			case "Date":
				return null;
			default:
				return;
		}
	}
});