"use strict";

var flows = require('streamline/lib/util/flows');
var locale = require("syracuse-core/lib/locale");
var ez = require('ez-streams');
var helpers = require("syracuse-core/lib/helpers");
var x3client = require('syracuse-x3/lib/client');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var CvgClientWS = require('syracuse-x3/lib/clients/soap/CvgClientWS').CvgClientWS;
var CvgWsException = require("syracuse-x3/lib/clients/soap/CvgWsException").CvgWsException;
var WsCall = require('syracuse-soap/lib/generic/wsCall').WsCall;
var tracer = require("syracuse-trace/lib/helper").getTracer("soap-generic.pool");

var lbMode = (process.argv[2] && (process.argv[2].substr(0, 1) === "W" || process.argv[2].substr(0, 1) === "N"));

// CLIENTS WEIGHTS :
var W_USER = 2;
var W_LANG = 1;
// CvgWSClient are kept in memory here !!!
var pools = {};

exports.getPool = function(alias) {
	//console.error("POOLS KEYS: " + JSON.stringify(Object.keys(pools), null, 2));
	return pools[alias];
};

exports.ClientPool = helpers.defineClass(function(options) {
	options = options || {};
	this.queueSize = options.queueSize || 100000;
	this.created = 0;
	this.avail = 0;
	this.clients = [];
	this.q = ez.devices.queue({
		max: this.queueSize,
	});
	this.readFunnel = flows.funnel(1);
	this.productChecked = false;
	// metadata can be used to store any information
	this.metadata = {};
}, null, {
	_addTrackerDiagnose: function(context, severity, message, stack) {
		var diag = {
			$severity: severity,
			$message: message,
			$exception: stack
		};
		if (context && context.tracker && context.tracker.$diagnoses) {
			context.tracker.$diagnoses.push(diag);
		} else if (lbMode) {
			this.tempDiags.push(diag);
		}
	},
	_getlicenseInfos: function(_, context, endpoint, user, localePref) {
		try {
			var config = {
				address: endpoint.x3server(_).serverHost(_),
				port: endpoint.x3server(_).serverPort(_),
				certificate: endpoint.x3server(_).certificate(_)
			};

			var client = x3client.create(config);
			//
			tracer.debug && tracer.debug("[" + this.alias + "] Initialize connection to get product information on endpoint '" + endpoint.dataset(_) + "'");
			client.connect(_, {
				server: endpoint.x3server(_).serverName(_),
				folder: endpoint.x3ServerFolder(_),
				locale: localePref.code(_),
				runtimeLog: "",
				runtimeLogDir: ""
			});
			//
			var userName = user.getEndpointLogin(_, endpoint.$uuid);
			tracer.info && tracer.info("[" + this.alias + "] Web service pool initialization : found login " + userName + " for endpoint " + endpoint.description(_));
			//
			var session = context && (context.httpSession || context.session);
			var peer = session && (session.getData("requestInfo") || {}).peerAddress;
			var adminEP = adminHelper.getCollaborationEndpoint(_);
			client.createSession(_, {
				sessionType: "primary",
				locale: localePref.code(_),
				localePreferences: localePref,
				userName: userName,
				baseUrl: context && context.baseUrl,
				collaborationBaseUrl: adminEP && session ? session.host + adminHelper.getCollaborationEndpoint(_).getBaseUrl(_) : "",
				peerAddress: peer,
				noCheckLicense: true
			});
			if (client.licenseData) {
				this.metadata.product = {
					code: client.licenseData.product,
					version: client.licenseData.version
				};
				tracer.debug && tracer.debug("[" + this.alias + "] --> Product information found: " + JSON.stringify(this.metadata.product));
			} else {
				tracer.debug && tracer.debug("[" + this.alias + "] --> No product information found");
				// reset product information 
				this.metadata.product = null;
			}
			client.disconnect(_);
		} finally {
			this.productChecked = true;
		}
	},
	_applyContextChanges: function(_, context, endpoint, user, localePref) {
		if (this.started) {
			var msg;
			if (this.metadata.x3ServerHost !== endpoint.x3server(_).serverHost(_) ||
				this.metadata.x3ServerPort !== endpoint.x3server(_).serverPort(_) ||
				this.metadata.x3Solution !== endpoint.x3SolutionName(_) ||
				this.metadata.x3Folder !== endpoint.x3ServerFolder(_)) {
				tracer.debug && tracer.debug("[" + this.alias + "] !!! " + msg);
				msg = locale.format(module, "endpointContextChanged");
				this._addTrackerDiagnose(context, "warning", msg);
				// destroy all clients
				this.stop(_, context, true, this.tempDiags);
				this._storeMetadata(_, endpoint, user, localePref);
				return;
			}
			var changeLogin = false;
			if (this.metadata.locale !== localePref.code(_)) {
				changeLogin = true;
				msg = locale.format(module, "langContextChanged");
				tracer.debug && tracer.debug("[" + this.alias + "] !!! " + msg);
				this._addTrackerDiagnose(context, "warning", msg);
			}
			if (this.metadata.userName !== user.getEndpointLogin(_, endpoint.$uuid)) {
				changeLogin = true;
				msg = locale.format(module, "userContextChanged");
				tracer.debug && tracer.debug("[" + this.alias + "] !!! " + msg);
				this._addTrackerDiagnose(context, "warning", msg);
			}
			if (changeLogin) {
				var self = this;
				var nbErr = 0;
				this.clients.forEach_(_, function(_, c) {
					var wsCall = new WsCall();
					try {
						wsCall.context = {
							endpoint: endpoint,
							user: user,
							localePref: localePref
						};
						var res = c._changeContext(_, wsCall);
						if (res) self._addTrackerDiagnose(context, "info", locale.format(module, "contextChangeSucceeded", c.pid));
					} catch (e) {
						if (e instanceof CvgWsException) {
							nbErr++;
							wsCall.messages.forEach(function(msg) {
								self._addTrackerDiagnose(context, "error", locale.format(module, "contextChangeFailed", c.pid, msg.message));
							});
						} else {
							throw e;
						}
					}
				});
				if (nbErr > 0) self._addTrackerDiagnose(context, "warning", locale.format(module, "contextChangeHasErr"));
			}
		}
		this._storeMetadata(_, endpoint, user, localePref);
	},
	_storeMetadata: function(_, endpoint, user, localePref) {
		this.metadata.x3ServerHost = endpoint.x3server(_).serverHost(_);
		this.metadata.x3ServerPort = endpoint.x3server(_).serverPort(_);
		this.metadata.x3Solution = endpoint.x3SolutionName(_);
		this.metadata.x3Folder = endpoint.x3ServerFolder(_);
		this.metadata.locale = localePref.code(_);
		this.metadata.userName = user.getEndpointLogin(_, endpoint.$uuid);
	},
	init: function(_, context, poolInstance) {
		this.alias = poolInstance.alias(_);
		// changes would be applied if the pool configuration changed
		this._applyContextChanges(_, context, poolInstance.endpoint(_), poolInstance.user(_), poolInstance.localePref(_));

		// Get license information
		if (!this.productChecked) {
			this._getlicenseInfos(_, context, poolInstance.endpoint(_), poolInstance.user(_), poolInstance.localePref(_));
		}

		this.autoStart = poolInstance.autoStart(_) || false;
		this.initSize = poolInstance.initSize(_) || 0;
		this.maxSize = poolInstance.maxSize(_) || 0;

		this.createFunnel = flows.funnel(this.maxSize);
		pools[this.alias] = this;


		if (this.started && this.created > this.initSize) {
			// disconnect clients until we match with init size
			this.stop(_, context, false, this.tempDiags);
		}

		tracer.info && tracer.info("[" + this.alias + "] Pool initialized");
		this.initialized = true;
		return this;
	},
	destroy: function(_, pid) {
		var self = this;
		this.readFunnel(_, function(_) {
			self.clients = self.clients.filter(function(cli) {
				return cli.pid !== pid;
			});
			self.created--;
			self.avail--;
		});
	},
	start: function(_, force, context, poolInstance) {
		this.tempDiags = [];
		this.init(_, context, poolInstance);
		this.started = true;

		var reuseMode;
		try {
			if (force || this.autoStart) {
				if (this.created < this.initSize) {
					for (var i = this.created; i < this.initSize; i++) {
						this.createClient(_, context, {
							poolAlias: poolInstance.alias(_),
							localePref: poolInstance.localePref(_),
							user: poolInstance.user(_),
							endpoint: poolInstance.endpoint(_)
						});
					}
				} else {
					reuseMode = true;
				}
			}
		} finally {
			if (reuseMode) {
				this._addTrackerDiagnose(context, "success", locale.format(module, "nbClientsReused", this.avail));
			} else if (this.avail === this.initSize) {
				this._addTrackerDiagnose(context, "success", locale.format(module, "nbClientsCreated", this.avail));
			} else {
				this._addTrackerDiagnose(context, "warning", locale.format(module, "onlyClientsCreated", this.avail));
			}
		}
		return this.tempDiags;
	},
	stop: function(_, context, all, diags) {
		this.tempDiags = diags || [];
		var min = all ? 0 : this.initSize;
		var max = this.created;
		var stopped = 0;
		for (var i = min; i < max; i++) {
			var cli = this.q.read(_);
			this.destroy(_, cli.pid);
			this._addTrackerDiagnose(context, "info", locale.format(module, "clientStopped", cli.pid));
			cli.disconnectClient(_, {}, "[" + this.alias + "] Pool " + (all ? " has been stopped" : " has been updated"));
			stopped++;
		}
		if (this.avail <= 0) {
			this._addTrackerDiagnose(context, "success", locale.format(module, "allClientsStopped"));
			this.started = false;
		} else {
			this._addTrackerDiagnose(context, "success", locale.format(module, "nbClientsStopped", stopped));
		}
		return this.tempDiags;
	},
	alloc: function(_, context, wsCall) {
		function sameUser(cli) {
			return cli.cliCfg.login === wsCall.context.user.login;
		}

		function sameLang(cli) {
			return cli.cliCfg.x3Lang === wsCall.context.x3Lang;
		}

		function computeWeight(cli) {
			var weight = 0;
			weight += sameUser(cli) ? W_USER : 0;
			weight += sameLang(cli) ? W_LANG : 0;
		}
		// this will be used before read on queue when implemented
		function sort(cliA, cliB) {
			return computeWeight(cliA) - computeWeight(cliB);
		}

		var self = this;
		var res = this.readFunnel(_, function(_) {
			// Wait for pool ends
			wsCall && wsCall.techInfo && wsCall.techInfo.poolWaitDuration.stop();
			wsCall && wsCall.techInfo && wsCall.techInfo.poolDistribDuration.start();
			tracer.debug && tracer.debug("[" + self.alias + "] Nb clients available: " + self.avail);
			if (self.avail > 0) {
				self.avail--;
				var cli = self.q.read(_);
				tracer.debug && tracer.debug("[" + self.alias + "] Reuse free client: " + cli.pid);
				return cli;
			} else if (self.created < self.maxSize) {
				// set reserved to not let it be free
				wsCall.context.reserved = true;
				return self.createClient(!_, context, wsCall.context);
			} else {
				tracer.debug && tracer.debug("[" + self.alias + "] Max clients reached: wait for free one");
				self.avail--;
				return self.q.read(_);
			}
		});
		if (typeof res === "function") {
			res = res(_);
		}
		res.free = false;
		return res;
	},
	free: function(res) {
		if (!this.started) {
			tracer.debug && tracer.debug("[" + this.alias + "] Pool is stopped, so clients will be disconnected...");
			res.disconnectClient(_ >> function(err) {
				if (err) throw err;
			}, {}, "Pool '" + this.alias + "' is stopped");
		} else if (this.avail < this.maxSize) {
			tracer.debug && tracer.debug("[" + this.alias + "] Set free client: " + res.pid);
			if (this.q.put(res)) {
				this.avail++;
				res.free = true;
			}
			tracer.debug && tracer.debug("[" + this.alias + "] avail=" + this.avail + " - maxSize:" + this.maxSize + " - initSize:" + this.initSize);
		}
	},
	createClient: function(_, context, callContext) {
		var self = this;
		return this.createFunnel(_, function(_) {

			var newCli;
			// special condition for unit tests
			if (context && context.request && context.request.headers && context.request.headers.unittest) { // for unit test 
				var headerParts = context.request.headers.unittest.split('~');
				var recMode = headerParts[0],
					fileName = headerParts[1];
				var recOptions = {
					path: "node_modules/syracuse-soap/test/data/generic/dispatch",
					recMode: recMode,
					fileName: fileName + ".json"
				};
				if (recOptions.recMode === "REC") recOptions.overwrite = true; // always override file
				newCli = new CvgClientWS().init(_, context, callContext, recOptions);
			} else {
				try {
					newCli = new CvgClientWS().init(_, context, callContext);
				} catch (e) {
					self._addTrackerDiagnose(context, "error", e.message, e.safeStack);
					throw e;
				}

			}
			self.clients.push(newCli);
			self.created++;
			tracer.debug && tracer.debug("[" + self.alias + "] New client created: " + newCli.pid);
			self._addTrackerDiagnose(context, "info", locale.format(module, "newClientCreated", newCli.pid));
			return newCli;
		});
	},
	getInfo: function() {
		return {
			alias: this.alias,
			started: this.started,
			autoStart: this.autoStart,
			initSize: this.initSize,
			maxSize: this.maxSize,
			created: this.created,
			available: this.avail,
			channels: this.clients
		};
	}
});

// Must be called only at server startup
exports.initializePools = function(_) {
	var db = adminHelper.getCollaborationOrm(_);
	var pools = db.fetchInstances(_, db.model.getEntity(_, "soapClassicPool"), {});
	pools.forEach_(_, function(_, p) {
		p.startAuto(_);
	});
};