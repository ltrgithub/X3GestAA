"use strict";

var flows = require('streamline/lib/util/flows');
var ez = require('ez-streams');
var helpers = require("syracuse-core/lib/helpers");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var CvgClientWS = require('syracuse-x3/lib/clients/soap/CvgClientWS').CvgClientWS;
var tracer = require("syracuse-trace/lib/helper").getTracer("soap-generic.pool");

// CLIENTS WEIGHTS :
var W_USER = 2;
var W_LANG = 1;
// CvgWSClient are kept in memory here !!!
var pools = {};

exports.getPool = function(alias) {
	return pools[alias];
};

exports.ClientPool = helpers.defineClass(function(options) {
	options = options || {};
	this.queueSize = options.queueSize || 100000;
	this.created = 0;
	this.avail = 0;
	this.q = ez.devices.queue({
		max: this.queueSize,
	});
	this.readFunnel = flows.funnel(1);
}, null, {

	init: function(_, context, poolInstance) {
		this.alias = poolInstance.alias(_);

		this.autoStart = poolInstance.autoStart(_) || false;
		this.initSize = poolInstance.initSize(_) || 0;
		this.maxSize = poolInstance.maxSize(_) || 0;

		this.createFunnel = flows.funnel(this.maxSize);
		pools[this.alias] = this;
		var self = this;

		this.started = true;
		if (this.autoStart && this.created < this.initSize) {
			for (var i = this.created; i < this.initSize; i++) {
				//self.created++;
				self.createClient(_, context, {
					poolAlias: poolInstance.alias(_),
					localePref: poolInstance.localePref(_),
					user: poolInstance.user(_),
					endpoint: poolInstance.endpoint(_)
				});
			}
		} else if (this.started && this.created > this.initSize) {
			this.stop(_);
		}

		tracer.info && tracer.info("Pool initialized: " + this.alias);
	},
	stop: function(_, all) {
		var min = all ? 0 : this.initSize;
		var max = this.created;
		for (var i = min; i < max; i++) {
			this.avail--;
			this.created--;
			this.q.read(_).disconnectClient(_, {}, "Pool '" + this.alias + (all ? "' has been stopped" : "' has been updated"));
		}
		if (this.created > 0) this.started = false;
	},
	alloc: function(_, context, wsCall) {
		function sameUser(cli) {
			return cli.cliCfg.login === wsCall.context.user.login;
		}

		function sameLang(cli) {
			return cli.cliCfg.x3Lang === wsCall.context.x3Lang;
		}

		function computeWeight(cli) {
			var weight = 0;
			weight += sameUser(cli) ? W_USER : 0;
			weight += sameLang(cli) ? W_LANG : 0;
		}
		// this will be used before read on queue when implemented
		function sort(cliA, cliB) {
			return computeWeight(cliA) - computeWeight(cliB);
		}

		var self = this;
		var res = this.readFunnel(_, function(_) {
			// Wait for pool ends
			wsCall && wsCall.techInfo && wsCall.techInfo.poolWaitDuration.stop();
			wsCall && wsCall.techInfo && wsCall.techInfo.poolDistribDuration.start();
			tracer.debug && tracer.debug("Nb clients available: " + self.avail);
			if (self.avail > 0) {
				self.avail--;
				var cli = self.q.read(_);
				tracer.debug && tracer.debug("Reuse free client: " + cli.uuid);
				return cli;
			} else if (self.created < self.maxSize) {
				//self.created++;
				// set reserved to not let it be free
				wsCall.context.reserved = true;
				return self.createClient(!_, context, wsCall.context);
			} else {
				tracer.debug && tracer.debug("Max clients reached: wait for free one");
				self.avail--;
				return self.q.read(_);
			}
		});
		if (typeof res === "function") {
			res = res(_);
		}
		return res;
	},
	free: function(res) {
		if (!this.started) {
			tracer.debug && tracer.debug("Pool '" + this.alias + "' is stopped, so clients will be disconnected...");
			res.disconnectClient(_ >> function(err) {
				if (err) throw err;
			}, {}, "Pool '" + this.alias + "' is stopped");
		} else if (this.avail < this.maxSize) {
			tracer.debug && tracer.debug("Set free client: " + res.uuid);

			if (this.q.put(res)) this.avail++;
			tracer.debug && tracer.debug("avail=" + this.avail + " - maxSize:" + this.maxSize + " - initSize:" + this.initSize);
		}
	},
	createClient: function(_, context, callContext, retry) {
		var nbTry = retry ? retry : 1;
		var self = this;
		return this.createFunnel(_, function(_) {

			var newCli;
			// special condition for unit tests
			if (context && context.request && context.request.headers && context.request.headers.unittest) { // for unit test 
				var headerParts = context.request.headers.unittest.split('~');
				var recMode = headerParts[0],
					fileName = headerParts[1];
				var recOptions = {
					path: "node_modules/syracuse-soap/test/data/generic/dispatch",
					recMode: recMode,
					fileName: fileName + ".json"
				};
				if (recOptions.recMode === "REC") recOptions.overwrite = true; // always override file
				newCli = new CvgClientWS().init(_, context, callContext, recOptions);
			} else {
				try {
					newCli = new CvgClientWS().init(_, context, callContext);
				} catch (e) {
					console.error(e.stack);
					// 3 attempt to instanciate client
					if (nbTry < 3) {
						newCli = self.createClient(_, context, callContext, nbTry++);
					} else {
						self.created--;
						throw e;
					}
				}
			}
			if (nbTry === 1) self.created++;
			tracer.debug && tracer.debug("New client created: " + newCli.uuid);
			return newCli;
		});
	},
	getInfo: function() {
		return {
			alias: this.alias,
			started: this.started,
			autoStart: this.autoStart,
			initSize: this.initSize,
			maxSize: this.maxSize,
			created: this.created,
			available: this.avail
		};
	}
});

// Must be called only at server startup
exports.initializePools = function(_) {
	var db = adminHelper.getCollaborationOrm(_);
	var pools = db.fetchInstances(_, db.model.getEntity(_, "soapClassicPool"), {});
	pools.forEach_(_, function(_, p) {
		if (p.status(_) === "started") {
			p.status(_, "stopped");
			p.save(_);
		}
		p.update(_);
	});
};