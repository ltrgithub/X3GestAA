"use strict";

var flows = require('streamline/lib/util/flows');
var ez = require('ez-streams');
var helpers = require("syracuse-core/lib/helpers");
var x3client = require('syracuse-x3/lib/client');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var CvgClientWS = require('syracuse-x3/lib/clients/soap/CvgClientWS').CvgClientWS;
var tracer = require("syracuse-trace/lib/helper").getTracer("soap-generic.pool");

// CLIENTS WEIGHTS :
var W_USER = 2;
var W_LANG = 1;
// CvgWSClient are kept in memory here !!!
var pools = {};

exports.getPool = function(alias) {
	//console.error("POOLS KEYS: " + JSON.stringify(Object.keys(pools), null, 2));
	return pools[alias];
};

exports.ClientPool = helpers.defineClass(function(options) {
	options = options || {};
	this.queueSize = options.queueSize || 100000;
	this.created = 0;
	this.avail = 0;
	this.q = ez.devices.queue({
		max: this.queueSize,
	});
	this.readFunnel = flows.funnel(1);
	this.productChecked = false;
	// metadata can be used to store any information
	this.metadata = {};
}, null, {
	_getlicenseInfos: function(_, context, endpoint, user, localePref) {
		try {
			var config = {
				address: endpoint.x3server(_).serverHost(_),
				port: endpoint.x3server(_).serverPort(_),
				certificate: endpoint.x3server(_).certificate(_)
			};

			var client = x3client.create(config);
			//
			tracer.debug && tracer.debug("[" + this.alias + "] Initialize connection to get product information on endpoint '" + endpoint.dataset(_) + "'");
			client.connect(_, {
				server: endpoint.x3server(_).serverName(_),
				folder: endpoint.x3ServerFolder(_),
				locale: localePref.code(_),
				runtimeLog: "",
				runtimeLogDir: ""
			});
			//
			var userName = user.getEndpointLogin(_, endpoint.$uuid);
			tracer.info && tracer.info("[" + this.alias + "] Web service pool initialization : found login " + userName + " for endpoint " + endpoint.description(_));
			//
			var session = context.httpSession || context.session;
			var peer = session && (session.getData("requestInfo") || {}).peerAddress;
			var adminEP = adminHelper.getCollaborationEndpoint(_);
			client.createSession(_, {
				sessionType: "primary",
				locale: localePref.code(_),
				localePreferences: localePref,
				userName: userName,
				baseUrl: context.baseUrl,
				collaborationBaseUrl: adminEP && session ? session.host + adminHelper.getCollaborationEndpoint(_).getBaseUrl(_) : "",
				peerAddress: peer,
				noCheckLicense: true
			});
			if (client.licenseData) {
				this.metadata.product = {
					code: client.licenseData.product,
					version: client.licenseData.version
				};
				tracer.debug && tracer.debug("[" + this.alias + "] --> Product information found: " + JSON.stringify(this.metadata.product));
			} else {
				tracer.debug && tracer.debug("[" + this.alias + "] --> No product information found");
				// reset product information 
				this.metadata.product = null;
			}
			client.disconnect(_);
		} catch (e) {
			console.error("[" + this.alias + "] An error occured during the first connection to get product information : " + e.stack);
			throw e;
		} finally {
			this.productChecked = true;
		}
	},
	_applyContextChanges: function(_, endpoint, user, localePref) {
		if (this.started) {
			if (this.metadata.x3ServerHost !== endpoint.x3server(_).serverHost(_) ||
				this.metadata.x3ServerPort !== endpoint.x3server(_).serverPort(_) ||
				this.metadata.x3Solution !== endpoint.x3SolutionName(_) ||
				this.metadata.x3Folder !== endpoint.x3ServerFolder(_)) {
				tracer.debug && tracer.debug("[" + this.alias + "] !!! X3 server context changed. All clients will be destroyed and recreated.");
				// TODO : disconnect all clients

				this._storeMetadata(_, endpoint, user, localePref);
				return;
			}
			var changeLogin = false;
			if (this.metadata.locale !== localePref.code(_)) {
				changeLogin = true;
				tracer.debug && tracer.debug("[" + this.alias + "] !!! Initialization language changed. All clients will be reconfigured.");
			}
			if (this.metadata.userName !== user.getEndpointLogin(_, endpoint.$uuid)) {
				changeLogin = true;
				tracer.debug && tracer.debug("[" + this.alias + "] !!! Initialization language changed. All clients will be reconfigured.");
			}
			if (changeLogin) {
				// TODO : call changeLogin on every clients
			}
		}
		this._storeMetadata(_, endpoint, user, localePref);
	},
	_storeMetadata: function(_, endpoint, user, localePref) {
		this.metadata.x3ServerHost = endpoint.x3server(_).serverHost(_);
		this.metadata.x3ServerPort = endpoint.x3server(_).serverPort(_);
		this.metadata.x3Solution = endpoint.x3SolutionName(_);
		this.metadata.x3Folder = endpoint.x3ServerFolder(_);
		this.metadata.locale = localePref.code(_);
		this.metadata.userName = user.getEndpointLogin(_, endpoint.$uuid);
	},
	init: function(_, context, poolInstance) {
		this.alias = poolInstance.alias(_);
		try {
			// changes would be applied if the pool configuration changed
			this._applyContextChanges(_, poolInstance.endpoint(_), poolInstance.user(_), poolInstance.localePref(_));

			// Get license information
			if (!this.productChecked) {
				this._getlicenseInfos(_, context, poolInstance.endpoint(_), poolInstance.user(_), poolInstance.localePref(_));
			}
		} catch (e) {
			console.error("ERR: " + e.stack);
		}
		this.autoStart = poolInstance.autoStart(_) || false;
		this.initSize = poolInstance.initSize(_) || 0;
		this.maxSize = poolInstance.maxSize(_) || 0;

		this.createFunnel = flows.funnel(this.maxSize);
		pools[this.alias] = this;


		if (this.started && this.created > this.initSize) {
			// disconnect clients until we match with init size
			this.stop(_);
		}

		tracer.info && tracer.info("[" + this.alias + "] Pool initialized");
		this.initialized = true;
		return this;
	},
	start: function(_, force, context, poolInstance) {
		this.init(_, context, poolInstance);
		this.started = true;
		if ((force || this.autoStart) && this.created < this.initSize) {
			for (var i = this.created; i < this.initSize; i++) {
				//self.created++;
				this.createClient(_, context, {
					poolAlias: poolInstance.alias(_),
					localePref: poolInstance.localePref(_),
					user: poolInstance.user(_),
					endpoint: poolInstance.endpoint(_)
				});
			}
		}
	},
	stop: function(_, all) {
		var min = all ? 0 : this.initSize;
		var max = this.created;
		for (var i = min; i < max; i++) {
			this.avail--;
			this.created--;
			this.q.read(_).disconnectClient(_, {}, "[" + this.alias + "] Pool " + (all ? " has been stopped" : " has been updated"));
		}
		if (this.created <= 0) this.started = false;
	},
	alloc: function(_, context, wsCall) {
		function sameUser(cli) {
			return cli.cliCfg.login === wsCall.context.user.login;
		}

		function sameLang(cli) {
			return cli.cliCfg.x3Lang === wsCall.context.x3Lang;
		}

		function computeWeight(cli) {
			var weight = 0;
			weight += sameUser(cli) ? W_USER : 0;
			weight += sameLang(cli) ? W_LANG : 0;
		}
		// this will be used before read on queue when implemented
		function sort(cliA, cliB) {
			return computeWeight(cliA) - computeWeight(cliB);
		}

		var self = this;
		var res = this.readFunnel(_, function(_) {
			// Wait for pool ends
			wsCall && wsCall.techInfo && wsCall.techInfo.poolWaitDuration.stop();
			wsCall && wsCall.techInfo && wsCall.techInfo.poolDistribDuration.start();
			tracer.debug && tracer.debug("[" + this.alias + "] Nb clients available: " + self.avail);
			if (self.avail > 0) {
				self.avail--;
				var cli = self.q.read(_);
				tracer.debug && tracer.debug("[" + this.alias + "] Reuse free client: " + cli.uuid);
				return cli;
			} else if (self.created < self.maxSize) {
				//self.created++;
				// set reserved to not let it be free
				wsCall.context.reserved = true;
				return self.createClient(!_, context, wsCall.context);
			} else {
				tracer.debug && tracer.debug("[" + this.alias + "] Max clients reached: wait for free one");
				self.avail--;
				return self.q.read(_);
			}
		});
		if (typeof res === "function") {
			res = res(_);
		}
		return res;
	},
	free: function(res) {
		if (!this.started) {
			tracer.debug && tracer.debug("[" + this.alias + "] Pool is stopped, so clients will be disconnected...");
			res.disconnectClient(_ >> function(err) {
				if (err) throw err;
			}, {}, "Pool '" + this.alias + "' is stopped");
		} else if (this.avail < this.maxSize) {
			tracer.debug && tracer.debug("[" + this.alias + "] Set free client: " + res.uuid);

			if (this.q.put(res)) this.avail++;
			tracer.debug && tracer.debug("[" + this.alias + "] avail=" + this.avail + " - maxSize:" + this.maxSize + " - initSize:" + this.initSize);
		}
	},
	createClient: function(_, context, callContext, retry) {
		var nbTry = retry != null ? retry : 1;
		var self = this;
		return this.createFunnel(_, function(_) {

			var newCli;
			// special condition for unit tests
			if (context && context.request && context.request.headers && context.request.headers.unittest) { // for unit test 
				var headerParts = context.request.headers.unittest.split('~');
				var recMode = headerParts[0],
					fileName = headerParts[1];
				var recOptions = {
					path: "node_modules/syracuse-soap/test/data/generic/dispatch",
					recMode: recMode,
					fileName: fileName + ".json"
				};
				if (recOptions.recMode === "REC") recOptions.overwrite = true; // always override file
				newCli = new CvgClientWS().init(_, context, callContext, recOptions);
			} else {
				//				try {
				newCli = new CvgClientWS().init(_, context, callContext);
				//				} catch (e) {
				//					console.error(e.stack);
				//					// 3 attempt to instanciate client
				//					if (nbTry < 3) {
				//						newCli = self.createClient(_, context, callContext, nbTry++);
				//					} else {
				//						self.created--;
				//						throw e;
				//					}
				//				}
			}
			if (nbTry === 1) self.created++;
			tracer.debug && tracer.debug("[" + self.alias + "] New client created: " + newCli.uuid);
			return newCli;
		});
	},
	getInfo: function() {
		return {
			alias: this.alias,
			started: this.started,
			autoStart: this.autoStart,
			initSize: this.initSize,
			maxSize: this.maxSize,
			created: this.created,
			available: this.avail
		};
	}
});

// Must be called only at server startup
exports.initializePools = function(_) {
	var db = adminHelper.getCollaborationOrm(_);
	var pools = db.fetchInstances(_, db.model.getEntity(_, "soapClassicPool"), {});
	pools.forEach_(_, function(_, p) {
		p.start(_);
	});
};