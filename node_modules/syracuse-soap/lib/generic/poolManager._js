"use strict";

var flows = require('streamline/lib/util/flows');
var ez = require('ez-streams');
var helpers = require("syracuse-core/lib/helpers");
var CvgClientWS = require('syracuse-x3/lib/clients/soap/CvgClientWS').CvgClientWS;
var tracer = require("syracuse-trace/lib/helper").getTracer("soap-generic.pool");

// CLIENTS WEIGHTS :
var W_USER = 2;
var W_LANG = 1;
// CvgWSClient are kept in memory here !!!
var pools = {};

exports.getPool = function(alias) {
	return pools[alias];
};

exports.ClientPool = helpers.defineClass(function(options) {
	options = options || {};
	this.queueSize = options.queueSize || 100000;
	this.created = 0;
	this.avail = 0;
	this.q = ez.devices.queue({
		max: this.queueSize,
	});
	this.readFunnel = flows.funnel(1);
}, null, {

	init: function(_, context, poolInstance) {
		this.alias = poolInstance.alias(_);
		this.autoStart = poolInstance.autoStart(_) || false;
		this.initSize = poolInstance.initSize(_) || 0;
		this.maxSize = poolInstance.maxSize(_) || 0;
		this.createFunnel = flows.funnel(this.maxSize);
		pools[this.alias] = this;
		var self = this;

		if (this.autoStart && this.created < this.initSize) {
			for (var i = this.created; i < this.initSize; i++) {
				self.createClient(!_, context, {
					poolAlias: poolInstance.alias(_),
					localePref: poolInstance.localePref(_),
					user: poolInstance.user(_),
					endpoint: poolInstance.endpoint(_)
				});
			}
		}
		tracer.info && tracer.info("Pool initialized: " + this.alias);

	},
	alloc: function(_, context, wsCall) {
		function sameUser(cli) {
			return cli.cliCfg.login === wsCall.context.user.login;
		}

		function sameLang(cli) {
			return cli.cliCfg.x3Lang === wsCall.context.x3Lang;
		}

		function computeWeight(cli) {
			var weight = 0;
			weight += sameUser(cli) ? W_USER : 0;
			weight += sameLang(cli) ? W_LANG : 0;
		}
		// this will be used before read on queue when implemented
		function sort(cliA, cliB) {
			return computeWeight(cliA) - computeWeight(cliB);
		}

		var self = this;
		var res = this.readFunnel(_, function(_) {
			// Wait for pool ends
			wsCall && wsCall.techInfo && wsCall.techInfo.poolWaitDuration.stop();
			wsCall && wsCall.techInfo && wsCall.techInfo.poolDistribDuration.start();
			tracer.debug && tracer.debug("Nb clients available: " + self.avail);
			if (self.avail > 0) {
				self.avail--;
				var cli = self.q.read(_);
				tracer.debug && tracer.debug("Reuse free client: " + cli.uuid);
				return cli;
			} else if (self.created < self.maxSize) {
				self.created++;
				// set reserved to not let it be free
				wsCall.context.reserved = true;
				return self.createClient(!_, context, wsCall.context);
			} else {
				tracer.debug && tracer.debug("Max clients reached: wait for free one");
				self.avail--;
				return self.q.read(_);
			}
		});
		if (typeof res === "function") {
			res = res(_);
		}
		return res;
	},
	free: function(res, reserved) {
		if (!reserved && this.avail < this.maxSize) {
			tracer.debug && tracer.debug("Set free client: " + res.uuid);
			this.avail++;
			this.q.put(res);
			tracer.debug && tracer.debug("avail=" + this.avail + " - maxSize:" + this.maxSize + " - initSize:" + this.initSize);
		}
	},
	createClient: function(_, context, callContext, retry) {
		var self = this;
		return this.createFunnel(_, function(_) {
			var newCli;
			// special condition for unit tests
			if (context && context.request && context.request.headers && context.request.headers.unittest) { // for unit test 
				var headerParts = context.request.headers.unittest.split('~');
				var recMode = headerParts[0],
					fileName = headerParts[1];
				var recOptions = {
					path: "node_modules/syracuse-soap/test/data/generic/dispatch",
					recMode: recMode,
					fileName: fileName + ".json"
				};
				if (recOptions.recMode === "REC") recOptions.overwrite = true; // always override file
				newCli = new CvgClientWS().init(_, context, callContext, recOptions);
			} else {
				try {
					newCli = new CvgClientWS().init(_, context, callContext);
				} catch (e) {
					console.error(e.stack);
					if (!retry) {
						self.createClient(_, context, callContext, true);
					} else {
						throw e;
					}
				}
			}
			tracer.debug && tracer.debug("New client created: " + newCli.uuid);
			return newCli;
		});
	},
	getInfo: function() {
		return {
			alias: this.alias,
			autoStart: this.autoStart,
			initSize: this.initSize,
			maxSize: this.maxSize,
			created: this.created,
			available: this.avail
		};
	}
});