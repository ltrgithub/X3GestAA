"use strict";

var flows = require('streamline/lib/util/flows');
var locale = require("syracuse-core/lib/locale");
var ez = require('ez-streams');
var helpers = require("syracuse-core/lib/helpers");
var x3client = require('syracuse-x3/lib/client');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var CvgClientWS = require('syracuse-x3/lib/clients/soap/CvgClientWS').CvgClientWS;
var CvgWsException = require("syracuse-x3/lib/clients/soap/CvgWsException").CvgWsException;
var WsCall = require('syracuse-soap/lib/generic/wsCall').WsCall;
var tracer = require("syracuse-trace/lib/helper").getTracer("soap-generic.pool");
var config0 = require('config');
var globals = require('streamline/lib/globals');
var currentProtocol = require("syracuse-x3/lib/convergence/automata/x3Descriptors").CURRENTPROTOCOL;

var multiTenant = (config0.hosting && config0.hosting.multiTenant);


var lbMode = (process.argv[2] && (process.argv[2].substr(0, 1) === "W" || process.argv[2].substr(0, 1) === "N"));

// CLIENTS WEIGHTS :
var W_USER = 2;
var W_LANG = 1;
// CvgWSClient are kept in memory here !!!
var pools = {};

exports.getPool = function(alias) {
	if (multiTenant) {
		var tenantId = globals.context.tenantId;
		var pools0 = pools[tenantId];
		return pools0 ? pools0[alias] : undefined;
	}
	//console.error("POOLS KEYS: " + JSON.stringify(Object.keys(pools), null, 2));
	return pools[alias];
};

//fetch soapClassicPool instance by $uuid
function _fetchPoolByAlias(_, alias) {
	if (!alias) throw new Error("No alias for fetching soapClassicPool");

	var db = adminHelper.getCollaborationOrm(_);
	var instance = db.fetchInstance(_, db.model.getEntity(_, "soapClassicPool"), {
		jsonWhere: {
			alias: alias
		}
	});
	// console.log("Fetch "+uuid+" "+instance);
	if (!instance) throw new Error("Wrong alias " + alias);
	return instance;
}

exports.ClientPool = helpers.defineClass(function(options) {
	options = options || {};
	this.queueSize = options.queueSize || 100000;
	this.created = 0;
	this.avail = 0;
	this.startStopFunnel = flows.funnel(1);
	this.clients = [];
	this.q = ez.devices.queue({
		max: this.queueSize,
	});
	this.readFunnel = flows.funnel(1);
	this.destroyFunnel = flows.funnel(1);
	this.productChecked = false;
	// metadata can be used to store any information
	this.metadata = {};
}, null, {
	_addTrackerDiagnose: function(context, severity, message, stack) {
		var diag = {
			$severity: severity,
			$message: message,
			$exception: stack
		};
		if (context && context.tracker && context.tracker.$diagnoses) {
			context.tracker.$diagnoses.push(diag);
		} else if (lbMode) {
			this.tempDiags.push(diag);
		}
	},
	_getlicenseInfos: function(_, context, endpoint, user, localePref) {
		try {
			var config = {
				x3solution: endpoint.x3solution(_),
				x3serverTags: this.tags,
				certificate: endpoint.x3solution(_).certificate(_)
			};

			var client = x3client.create(config);
			//
			tracer.debug && tracer.debug("[" + this.alias + "] Initialize connection to get product information on endpoint '" + endpoint.dataset(_) + "'");
			// initialization done on MAIN server
			client.connect(_, {
				server: endpoint.x3solution(_).serverHost(_),
				folder: endpoint.x3ServerFolder(_),
				locale: localePref.code(_),
				runtimeLog: "",
				runtimeLogDir: ""
			});
			//
			var userName = user.getEndpointLogin(_, endpoint.$uuid);
			tracer.info && tracer.info("[" + this.alias + "] Web service pool initialization : found login " + userName + " for endpoint " + endpoint.description(_));
			//
			var session = context && (context.httpSession || context.session);
			var peer = session && (session.getData("requestInfo") || {}).peerAddress;
			var adminEP = adminHelper.getCollaborationEndpoint(_);
			client.createSession(_, {
				sessionType: "primary",
				locale: localePref.code(_),
				localePreferences: localePref,
				userName: userName,
				baseUrl: context && context.baseUrl,
				collaborationBaseUrl: adminEP && session ? session.host + adminHelper.getCollaborationEndpoint(_).getBaseUrl(_) : "",
				peerAddress: peer,
				noCheckLicense: true
			});
			if (client.licenseData) {
				this.metadata.product = {
					code: client.licenseData.product,
					version: client.licenseData.version
				};
				tracer.debug && tracer.debug("[" + this.alias + "] --> Product information found: " + JSON.stringify(this.metadata.product));
			} else {
				tracer.debug && tracer.debug("[" + this.alias + "] --> No product information found");
				// reset product information 
				this.metadata.product = null;
			}
			client.disconnect(_);
		} finally {
			this.productChecked = true;
		}
	},
	_applyContextChanges: function(_, context, endpoint, user, localePref) {
		if (this.started) {
			var msg;
			if (this.metadata.x3Solution !== endpoint.getSolutionName(_) ||
				this.metadata.x3Folder !== endpoint.x3ServerFolder(_) ||
				this.metadata.tags !== this.tags) {
				tracer.debug && tracer.debug("[" + this.alias + "] !!! " + msg);
				msg = locale.format(module, "endpointContextChanged");
				this._addTrackerDiagnose(context, "warning", msg);
				// destroy all clients
				// no funnel, because this is called only within init
				this._stop_no_funnel(_, context, true, this.tempDiags);
				this._storeMetadata(_, endpoint, user, localePref);
				return;
			}
			var changeLogin = false;
			if (this.metadata.locale !== localePref.code(_)) {
				changeLogin = true;
				msg = locale.format(module, "langContextChanged");
				tracer.debug && tracer.debug("[" + this.alias + "] !!! " + msg);
				this._addTrackerDiagnose(context, "warning", msg);
			}
			if (this.metadata.userName !== user.getEndpointLogin(_, endpoint.$uuid)) {
				changeLogin = true;
				msg = locale.format(module, "userContextChanged");
				tracer.debug && tracer.debug("[" + this.alias + "] !!! " + msg);
				this._addTrackerDiagnose(context, "warning", msg);
			}
			if (changeLogin) {
				var self = this;
				var nbErr = 0;
				this.clients.forEach_(_, function(_, c) {
					var wsCall = new WsCall();
					try {
						wsCall.context = {
							endpoint: endpoint,
							user: user,
							localePref: localePref
						};
						var res = c._changeContext(_, wsCall);
						if (res) self._addTrackerDiagnose(context, "info", locale.format(module, "contextChangeSucceeded", c.pid));
					} catch (e) {
						if (e instanceof CvgWsException) {
							nbErr++;
							wsCall.messages.forEach(function(msg) {
								self._addTrackerDiagnose(context, "error", locale.format(module, "contextChangeFailed", c.pid, msg.message));
							});
						} else {
							throw e;
						}
					}
				});
				if (nbErr > 0) self._addTrackerDiagnose(context, "warning", locale.format(module, "contextChangeHasErr"));
			}
		}
		this._storeMetadata(_, endpoint, user, localePref);
	},
	_storeMetadata: function(_, endpoint, user, localePref) {
		this.metadata.x3Solution = endpoint.getSolutionName(_);
		this.metadata.x3Folder = endpoint.x3ServerFolder(_);
		this.metadata.locale = localePref.code(_);
		this.metadata.userName = user.getEndpointLogin(_, endpoint.$uuid);
		this.metadata.tags = this.tags;
	},
	init: function(_, context, poolInstance, dontStop) {
		if (poolInstance) {
			this.alias = poolInstance.alias(_);
			this.tags = poolInstance.x3serverTags(_);
			this.protocolVersion = poolInstance.protocolVersion(_) || currentProtocol;
			// changes would be applied if the pool configuration changed
			this._applyContextChanges(_, context, poolInstance.endpoint(_), poolInstance.user(_), poolInstance.localePref(_));

			// Get license information
			if (!this.productChecked) {
				this._getlicenseInfos(_, context, poolInstance.endpoint(_), poolInstance.user(_), poolInstance.localePref(_));
			}

			this.autoStart = poolInstance.autoStart(_) || false;
			this.autoStartDisabled = poolInstance.autoStartDisabled(_) || false;
			this.initSize = poolInstance.initSize(_) || 0;
			this.maxSize = poolInstance.maxSize(_) || 0;

			this.createFunnel = flows.funnel(this.maxSize);
			if (multiTenant) {
				var tenantId = globals.context.tenantId;
				var pools0 = pools[tenantId];
				if (!pools0)
					pools0 = pools[tenantId] = {};
				pools0[this.alias] = this;
			} else
				pools[this.alias] = this;
		}

		if (!dontStop && this.started && this.created > this.initSize) {
			// disconnect clients until we match with init size
			// no funnel, because this is called only within init: avoid deadlock if called from 'start:' function
			this._stop_no_funnel(_, context, false, this.tempDiags);
		}

		tracer.info && tracer.info("[" + this.alias + "] Pool initialized");
		this.initialized = true;
		return this;
	},
	destroy: function(_, context, pid) {
		var self = this;
		this.destroyFunnel(_, function(_) {
			self.clients = self.clients.filter(function(cli) {
				return cli.pid !== pid;
			});
			self.created = self.clients.length;
		});
		tracer.debug && tracer.debug("[" + this.alias + "] Destroying client " + pid + ", created=" + this.created);
	},
	start: function(_, force, context, poolInstance, oneSyncOnly) {
		var self = this;
		return this.startStopFunnel(_, function(_) {
			self.tempDiags = [];
			self.init(_, context, poolInstance);
			self.started = true;
			self.autoStartDisabled = false;
			if (poolInstance.autoStartDisabled(_)) {
				poolInstance.autoStartDisabled(_, false);
				// Setting params 'parameter' and 'option' is mandatory to avoid error 'undefined is not a function'
				var res = poolInstance.save(_, null, {
					ignoreRestrictions: true
				});
			}

			var reuseMode;
			try {
				if (force || self.autoStart) {
					if (self.created < self.initSize) {
						for (var i = self.created; i < self.initSize; i++) {
							var opts = {
								poolAlias: poolInstance.alias(_),
								localePref: poolInstance.localePref(_),
								user: poolInstance.user(_),
								endpoint: poolInstance.endpoint(_),
								poolInstance: poolInstance
							};
							// in multi tenant mode, the pool is started with the first request received.
							// So we start only one client synchronously
							if (oneSyncOnly) {
								if (i === 0) {
									self.createClient(_, context, opts);
								} else {
									self.createClient(!_, context, opts);
								}
							} else {
								self.createClient(_, context, opts);
							}
						}
					} else {
						reuseMode = true;
					}
				}
			} finally {
				if (reuseMode) {
					self._addTrackerDiagnose(context, "success", locale.format(module, "nbClientsReused", self.avail));
				} else if (self.avail === self.initSize) {
					self._addTrackerDiagnose(context, "success", locale.format(module, "nbClientsCreated", self.avail));
				} else {
					self._addTrackerDiagnose(context, "warning", locale.format(module, "onlyClientsCreated", self.avail));
				}
			}
			return self.tempDiags;
		});
	},
	stop: function(_, context, all, diags) {
		var self = this;
		return this.startStopFunnel(_, function(_) {
			var db = adminHelper.getCollaborationOrm(_);
			var pool = db.fetchInstance(_, db.model.getEntity(_, "soapClassicPool"), {
				jsonWhere: {
					alias: self.alias
				}
			});
			// The service has been stopped manually, on purpose: we save the status autoStartDisabled in db
			if (pool) {
				pool.autoStartDisabled(_, true);
				// Setting params 'parameter' and 'option' is mandatory to avoid error 'undefined is not a function'
				var res = pool.save(_, null, {
					ignoreRestrictions: true
				});
				self.autoStartDisabled = true;
			}
			return self._stop_no_funnel(_, context, all, diags);
		});
	},
	// internal stop function bypassing funnel to avoid deadlock within _applyContextChanges
	// special naming to point out that this function should be used only with great care!
	_stop_no_funnel: function(_, context, all, diags) {
		this.tempDiags = diags || [];
		var min = all ? 0 : this.initSize;
		var max = this.created;
		var stopped = 0;
		for (var i = min; i < max; i++) {
			var cli = this.q.read(_);
			this.avail--;
			this.destroy(_, context, cli.pid);
			this._addTrackerDiagnose(context, "info", locale.format(module, "clientStopped", cli.pid));
			cli.disconnectClient(_, {}, "[" + this.alias + "] Pool " + (all ? " has been stopped" : " has been updated"));
			stopped++;
		}
		if (this.avail <= 0) {
			this._addTrackerDiagnose(context, "success", locale.format(module, "allClientsStopped"));
			this.started = false;
		} else {
			this._addTrackerDiagnose(context, "success", locale.format(module, "nbClientsStopped", stopped));
		}
		return this.tempDiags;
	},
	alloc: function(_, context, wsCall) {
		var self = this;

		function sameUser(cli) {
			return cli.cliCfg.login === wsCall.context.user.login;
		}

		function sameLang(cli) {
			return cli.cliCfg.x3Lang === wsCall.context.x3Lang;
		}

		function computeWeight(cli) {
			var weight = 0;
			weight += sameUser(cli) ? W_USER : 0;
			weight += sameLang(cli) ? W_LANG : 0;
			return weight;
		}
		// this will be used before read on queue when implemented
		function sortByWeight(cliA, cliB) {
			return computeWeight(cliB) - computeWeight(cliA);
		}

		function sortByPid(cliA, cliB) {
			if (wsCall.context.pid === cliA.pid) {
				return -1;
			} else if (wsCall.context.pid === cliB.pid) {
				return 1;
			}
			return 0;
		}

		function popClient(_) {
			if (self.avail > 0) {
				self.avail--;
				return self.q.read(_);
			}
		}

		var res = this.readFunnel(_, function(_) {
			// Wait for pool ends
			wsCall && wsCall.techInfo && wsCall.techInfo.poolWaitDuration.stop();
			wsCall && wsCall.techInfo && wsCall.techInfo.poolDistribDuration.start();
			tracer.debug && tracer.debug("[" + self.alias + "] Nb clients available: " + self.avail);
			if (self.avail > 0) {

				// apply sort function to get more corresponding client
				if (wsCall.context.pid) {
					self.q.adjust(function(arr) {
						return arr.sort(sortByPid);
					});
				} else {
					self.q.adjust(function(arr) {
						return arr.sort(sortByWeight);
					});
				}

				var cli;
				while ((cli = popClient(_)) && cli.stream == null) {
					tracer.debug && tracer.debug("[" + self.alias + "] Dead client: " + cli.pid);
					self.destroy(_, context, cli.pid);
					cli = null;
				}
				if (!cli) {
					return self.createClient(!_, context, wsCall.context);
				}
				tracer.debug && tracer.debug("[" + self.alias + "] Reuse free client: " + cli.pid);
				return cli;
			}
			// The WebService Pool has been stopped manually and on purpose: we dont want the service to restart for the moment 
			else if (self.autoStartDisabled) {

				tracer.debug && tracer.debug("[" + self.alias + "] Alloc refused:  Pool stopped manually");
				throw new Error("[" + self.alias + "] Alloc refused: Pool has been stopped manually");

			} else if (self.created < self.maxSize) {
				if (self.created + 1 < self.maxSize) {
					// prepare one more client to be ready
					self.createClient(!_, context, helpers.object.clone(wsCall.context));
				}
				// set reserved to not let it be free
				wsCall.context.reserved = true;
				self.started = true;
				return self.createClient(!_, context, wsCall.context);
			} else {
				tracer.debug && tracer.debug("[" + self.alias + "] Max clients reached: wait for free one");
				self.avail--;
				return self.q.read(_);
			}
		});
		if (typeof res === "function") {
			res = res(_);
		}
		res.free = false;
		return res;
	},
	free: function(res) {
		if (!this.started) {
			tracer.debug && tracer.debug("[" + this.alias + "] Pool is stopped, so clients will be disconnected...");
			res.disconnectClient(_ >> function(err) {
				if (err) throw err;
			}, {}, "Pool '" + this.alias + "' is stopped");
		} else if (this.avail < this.maxSize) {
			if (res.stream == null) {
				tracer.debug && tracer.debug("[" + this.alias + "] Free dead client: " + res.pid);
				this.destroy(_ >> function(err) {
					if (err) throw err;
				}, null, res.pid);
			} else {
				tracer.debug && tracer.debug("[" + this.alias + "] Set free client: " + res.pid);
				if (this.q.put(res)) {
					this.avail++;
					res.free = true;
				}
			}
			tracer.debug && tracer.debug("[" + this.alias + "] created=" + this.created + " - avail=" + this.avail + " - maxSize:" + this.maxSize + " - initSize:" + this.initSize);
		}
	},
	createClient: function(_, context, callContext) {
		var self = this;
		return this.createFunnel(_, function(_) {
			var newCli;
			try {
				// special condition for unit tests
				if (context && context.request && context.request.headers && context.request.headers.unittest) { // for unit test 
					var headerParts = context.request.headers.unittest.split('~');
					var recMode = headerParts[0],
						fileName = headerParts[1];
					var recOptions = {
						path: "node_modules/syracuse-soap/test/data/generic/dispatch",
						recMode: recMode,
						fileName: fileName + ".json"
					};
					if (recOptions.recMode === "REC") recOptions.overwrite = true; // always override file
					newCli = new CvgClientWS(self.protocolVersion).init(_, context, callContext, recOptions, {
						tags: self.tags
					});
				} else {
					try {
						newCli = new CvgClientWS(self.protocolVersion).init(_, context, callContext, null, {
							tags: self.tags
						});
					} catch (e) {
						self._addTrackerDiagnose(context, "error", e.message, e.safeStack);
						throw e;
					}

				}
				self.clients.push(newCli);
				tracer.debug && tracer.debug("[" + self.alias + "] New client created: " + newCli.pid);
				self._addTrackerDiagnose(context, "info", locale.format(module, "newClientCreated", newCli.pid));
				return newCli;
			} catch (e) {
				tracer.error && tracer.error("[" + self.alias + "] New client creation failed: " + e.message);
				self._addTrackerDiagnose(context, "error", e.message);
				throw e;
			} finally {
				self.created = self.clients.length;
				tracer.debug && tracer.debug("[" + self.alias + "] Client count: " + self.created);
			}
		});
	},
	getInfo: function() {
		return {
			alias: this.alias,
			started: this.started,
			autoStart: this.autoStart,
			autoStartDisabled: this.autoStartDisabled,
			initSize: this.initSize,
			maxSize: this.maxSize,
			created: this.created,
			available: this.avail,
			channels: this.clients
		};
	}
});

// Must be called only at server startup
exports.initializePools = function(_) {
	if (multiTenant) return; // in multi tenant mode, pool will be initialized by the request itself calling tryInitializePool behind
	var db = adminHelper.getCollaborationOrm(_);
	var pools = db.fetchInstances(_, db.model.getEntity(_, "soapClassicPool"), {});
	pools.forEach_(_, function(_, p) {
		p.startAuto(_);
	});
};


var initPoolFunnel = flows.funnel(1);

//Should be called only in multi tenant mode
exports.tryInitializePool = function(_, poolAlias) {
	if (!multiTenant) return;
	var db = adminHelper.getCollaborationOrm(_);
	var pool = db.fetchInstance(_, db.model.getEntity(_, "soapClassicPool"), {
		sdataWhere: "alias eq '" + poolAlias + "'"
	});
	if (!pool) {
		return false;
	} else {
		// funnel necessary because other calls can arrive during first initialization
		return initPoolFunnel(_, function(_) {
			// check if the previous funnel entry created the pool
			if (!exports.getPool(poolAlias)) {
				pool.startSync(_);
			}
			return true;
		});
	}
};