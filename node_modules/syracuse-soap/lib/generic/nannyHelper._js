"use strict";

var syracuse;
var globals = require('streamline-runtime').globals;
var locale = require('streamline-locale');
var mock = require('syracuse-load/lib/mock');
var url = require('url');
var config = require('config');
var querystring = require('querystring');
var multiTenant = config.hosting && config.hosting.multiTenant;
var helpers = require('syracuse-core').helpers;
var forEachKey = helpers.object.forEachKey;

var IGNORED = "--Ignored--";

var soapClassicPool = require('syracuse-soap/lib/generic/entities/soapClassicPool');

exports._process = function(_, request, response) {
	syracuse = syracuse || require('syracuse-main/lib/syracuse');
	if (syracuse.server instanceof mock.MockStreamServer && !request.fromNanny && !request._request.fromNanny || !(syracuse.server instanceof mock.MockStreamServer) && (!config.system || !config.system.enableDevelopmentFeatures)) {
		response.writeHead("404", {});
		return response.end("Resource not found.");
	}
	var parsed = url.parse(request.url, true);
	var tenant = parsed.query.tenantId;
	if (multiTenant && tenant && !syracuse.initializedTenant(tenant)) {
		response.writeHead("200", {});
		console.log(IGNORED);
		return response.end(IGNORED);
	} else {
		globals.context.tenantId = tenant;
	}
	var data = request.readAll(_);
	if (data && data.length > 0) {
		try {
			data = JSON.parse(data);
			globals.context.session = {
				id: data.id,
				clientId: data.clientId,
				serverName: data.serverName,
				getData: function(code) {
					return data.data && data.data[code];
				}
			};
		} catch (e) {
			console.error("Can't parse nanny request data: " + e.safeStack);
		}
	}
	//console.log("TENANT " + globals.context.tenantId);
	var cmdName = parsed.pathname.split('/')[2];
	var diags;
	try {

		switch (cmdName) {
			case "update":
				diags = soapClassicPool.updateExternal(_, parsed.query.uuid);
				response.end(JSON.stringify(diags));
				break;
			case "stop":
				diags = soapClassicPool.stopExternal(_, parsed.query.uuid);
				response.end(JSON.stringify(diags));
				break;
			case "getInfos":
				var res = soapClassicPool.getInfosExternal(_, parsed.query.uuid);
				response.end(JSON.stringify(res));
				break;
			default:
				response.writeHead("404", {});
				return response.end("Nanny command not found.");
		}
	} catch (e) {
		console.error("Error during process nannyCommand: " + e.stack);
		response.writeHead("500", {});
		response.end(JSON.stringify({
			$severity: "error",
			$message: e.message,
			$stackTrace: e.safeStack
		}));
	}
	return;
};

exports._parseDiagnoses = function(instance, input) {
	function addDiag(d, port) {
		if (d.$severity && d.$message) {
			instance.$diagnoses.push({
				$severity: d.$severity,
				$message: (port ? port + " : " : "") + d.$message,
				$stackTrace: d.$stackTrace
			});
		}
	}
	instance.$diagnoses = instance.$diagnoses || [];
	// for nanny error thrown
	if (typeof input === "object" && input.$severity) {
		instance.$diagnoses.push(input);
		return;
	}
	// for nanny diagnoses returned
	forEachKey(input, function(port, diags) {
		if (Array.isArray(diags)) {
			diags.forEach(function(d) {
				addDiag(d, port);
			});
		} else {

			addDiag(diags, port);
		}
	});
};

function getPortsDiagnoses(_, out) {
	var res = {};
	var server = "";
	var lines = out.split(/[\r\n]+/);
	lines.forEach(function(line) {
		if (line.charAt(0) === '{') {
			line = JSON.parse(line);
			var port = line.port;
			var message = line.message;
			if (message && message !== IGNORED) {
				res[server + port] = (message.charAt(0) === '{' || message.charAt(0) === '[') ? JSON.parse(message) : message;
			}
		} else {
			var len = line.length;
			if (line[len - 1] === ":")
				server = line;
		}
	});
	return res;
}

var parsers = {
	getInfos: getPortsDiagnoses,
	update: getPortsDiagnoses,
	stop: getPortsDiagnoses,
};

//propagation only when load balancer is available!
exports._propagate = function(_, instance, method, action, parameters) {
	parameters = parameters || {};
	var path = action + "?" + querystring.stringify(parameters);
	if (multiTenant) {
		parameters.tenantId = globals.context.tenantId;
		path += ((path.indexOf('?') >= 0 ? '&' : '?') + 'tenantId=' + globals.context.tenantId);
		console.log("Set tenant " + path);
	}

	if ("mockServer" in config) {
		var options = {
			path: "/nannyCommand/notifyW/soap-wsdl/" + path,
			method: method,
			headers: {
				hostname: (globals.context.tenantId || "")
			}
		};
		options.headers[mock.BALANCER_HEADER] = config.port;

		var session = globals.context.session;
		var stringifiedSession = {
			id: session.id,
			clientId: session.clientId,
			serverName: session.serverName,
			data: {
				badge: session.data && session.data.badge
			}
		};

		try {
			var res0 = config.mockServer.mockClient.simpleRequest(options, JSON.stringify(stringifiedSession), _);
			console.log("MOCK ANSWER " + path + " " + res0);
			var res = parsers[action] ? parsers[action](_, res0) : res0;
			console.log("MA 2 " + require('util').format(res));
			if (instance && (!res || Object.keys(res).length === 0)) {
				instance.$addDiagnose("warning", (multiTenant && res0.indexOf(IGNORED) >= 0) ? locale.format(module, "noWsProcessesStarted") : locale.format(module, "noWsProcesses"));
			}
			return res;
		} catch (e) {
			console.error("Error propagate on mock server: " + e.stack);
			return {
				$severity: "error",
				$message: e.message,
				$stackTrace: e.safeStack
			};
		}
	}
};