"use strict";

var syracuse;
var globals = require('streamline-runtime').globals;
var locale = require('streamline-locale');
var mock = require('syracuse-load/lib/mock');
var url = require('url');
var config = require('config');
var querystring = require('querystring');
var multiTenant = config.hosting && config.hosting.multiTenant;
var helpers = require('syracuse-core').helpers;
var forEachKey = helpers.object.forEachKey;

var IGNORED = "--Ignored--";

var soapClassicPool = require('syracuse-soap/lib/generic/entities/soapClassicPool');

exports._process = function(_, request, response) {
	syracuse = syracuse || require('syracuse-main/lib/syracuse');
	if (syracuse.server instanceof mock.MockStreamServer && !request.fromNanny && !request._request.fromNanny || !(syracuse.server instanceof mock.MockStreamServer) && (!config.system || !config.system.enableDevelopmentFeatures)) {
		response.writeHead("404", {});
		return response.end("Resource not found.");
	}
	var parsed = url.parse(request.url, true);
	var tenant = parsed.query.tenantId;
	if (multiTenant && tenant && !syracuse.initializedTenant(tenant)) {
		response.writeHead("200", {});
		console.log(IGNORED);
		return response.end(IGNORED);
	} else {
		globals.context.tenantId = tenant;
	}
	var data = request.readAll(_);
	if (data && data.length > 0) {
		try {
			data = JSON.parse(data);
			globals.context.session = {
				id: data.id,
				clientId: data.clientId,
				serverName: data.serverName,
				getData: function(code) {
					return data.data && data.data[code];
				}
			};
		} catch (e) {
			console.error("Can't parse nanny request data: " + e.safeStack);
		}
	}
	//console.log("TENANT " + globals.context.tenantId);
	var cmdName = parsed.pathname.split('/')[2];
	var diags;
	try {

		switch (cmdName) {
			case "update":
				// returns an object not an array of diagnoses (see parsers.update)
				diags = soapClassicPool.updateExternal(_, parsed.query.uuid);
				response.end(JSON.stringify({
					$diagnoses: diags || []
				}));
				break;
			case "stop":
				// returns an object not an array of diagnoses (see parsers.stop)
				diags = soapClassicPool.stopExternal(_, parsed.query.uuid);
				response.end(JSON.stringify({
					$diagnoses: diags || []
				}));
				break;
			case "getInfos":
				var res = soapClassicPool.getInfosExternal(_, parsed.query.uuid);
				response.end(JSON.stringify(res));
				break;
			default:
				response.writeHead("404", {});
				return response.end("Nanny command not found.");
		}
	} catch (e) {
		console.error("Error during process nannyCommand: " + e.stack);
		response.writeHead("500", {});
		response.end(JSON.stringify({
			$severity: "error",
			$message: e.message,
			$stackTrace: e.safeStack
		}));
	}
	return;
};

exports._parseDiagnoses = function(instance, input) {
	function addDiag(d, port) {
		if (d.$severity && d.$message) {
			instance.$diagnoses.push({
				$severity: d.$severity,
				$message: (port ? port + " : " : "") + d.$message,
				$stackTrace: d.$stackTrace
			});
		}
	}
	instance.$diagnoses = instance.$diagnoses || [];
	// for nanny error thrown
	if (typeof input === "object" && input.$severity) {
		instance.$diagnoses.push(input);
		return;
	}
	// for nanny diagnoses returned
	forEachKey(input, function(port, diags) {
		if (Array.isArray(diags)) {
			diags.forEach(function(d) {
				addDiag(d, port);
			});
		} else {

			addDiag(diags, port);
		}
	});
};
/**
 * out: multi-lines structure like below:
 * 		MacBookPro-Domi.local:
 * 		OK notifyW
 *	 	{"port":"W0","message":"{\"$diagnoses\":[{\"$severity\":\"info\",\"$message\":\"New soap classic channel created: 3066\"},{\"$severity\":\"success\",\"$message\":\"1 classic channels have been created\"}]}"}
 *
 *	Returns {"server:Port": {},...}
 *	 	{
 *	 		"MacBookPro-Domi.local:W0": {
 *	 			"$diagnoses": [{
 *	 				"$severity": "info",
 *	 				"$message": "New soap classic channel created: 3066"
 *	 			},
 *	 			{
 *	 				"$severity": "success",
 *	 				"$message": "1 classic channels have been created"
 *	 	 		}]
 *	 		}
 *	 	}
 */
function getPortsDiagnoses(_, out) {
	var res = {};
	var server = "";
	var lines = out.split(/[\r\n]+/);
	lines.forEach(function(line) {
		if (line.charAt(0) === '{') {
			line = JSON.parse(line);
			var port = line.port;
			var message = line.message;
			if (message && message !== IGNORED) {
				res[server + port] = (message.charAt(0) === '{' || message.charAt(0) === '[') ? JSON.parse(message) : message;
			}
		} else {
			var len = line.length;
			if (line[len - 1] === ":")
				server = line;
		}
	});
	return res;
}
/**
 * returns a regular $diagnoses object with the concatenation of diagnoses return by all W* process
 * if nb processes > 1 -> $message if prefixed by process id [W*]
 */
function extractDiagnoses(_, out) {
	var res = getPortsDiagnoses(_, out);
	var diags = [];
	var keys = Object.keys(res);
	if (keys && keys.length > 0) {
		keys.forEach(function(key) {
			var port = key.lastIndexOf(":");
			if (port > 0) {
				port = key.substr(port + 1);
			} else {
				port = null;
			}
			if (res[key] && res[key].$diagnoses) {
				if (port && keys.length > 1) {
					res[key].$diagnoses.forEach(function(diag) {
						diag.$message = "[" + port + "] " + diag.$message
					})
				}

				diags = diags.concat(res[key].$diagnoses)
			}
		})
	}
	return {
		$diagnoses: diags
	}
}

var parsers = {
	getInfos: getPortsDiagnoses,
	update: extractDiagnoses,
	stop: extractDiagnoses,
};

//propagation only when load balancer is available!
exports._propagate = function(_, instance, method, action, parameters) {
	parameters = parameters || {};
	var path = action + "?" + querystring.stringify(parameters);
	if (multiTenant) {
		parameters.tenantId = globals.context.tenantId;
		path += ((path.indexOf('?') >= 0 ? '&' : '?') + 'tenantId=' + globals.context.tenantId);
		console.log("Set tenant " + path);
	}

	if ("mockServer" in config) {
		var options = {
			path: "/nannyCommand/notifyW/soap-wsdl/" + path,
			method: method,
			headers: {
				hostname: (globals.context.tenantId || "")
			}
		};
		options.headers[mock.BALANCER_HEADER] = config.port;

		var session = globals.context.session;
		var stringifiedSession = {
			id: session.id,
			clientId: session.clientId,
			serverName: session.serverName,
			data: {
				badge: session.data && session.data.badge
			}
		};

		try {
			var res0 = config.mockServer.mockClient.simpleRequest(options, JSON.stringify(stringifiedSession), _);
			console.log("MOCK ANSWER " + path + " " + res0);
			var res = parsers[action] ? parsers[action](_, res0) : res0;
			console.log("MA 2 " + require('util').format(res));
			if (instance && (!res || Object.keys(res).length === 0)) {
				instance.$addDiagnose("warning", (multiTenant && res0.indexOf(IGNORED) >= 0) ? locale.format(module, "noWsProcessesStarted") : locale.format(module, "noWsProcesses"));
			}
			return res;
		} catch (e) {
			console.error("Error propagate on mock server: " + e.stack);
			return {
				$severity: "error",
				$message: e.message,
				$stackTrace: e.safeStack
			};
		}
	}
};