"use strict";

var syracuse;
var globals = require("streamline/lib/globals");
var locale = require("syracuse-core/lib/locale");
var mock = require('syracuse-load/lib/mock');
var url = require('url');
var config = require('config');
var querystring = require('querystring');
var multiTenant = config.hosting && config.hosting.multiTenant;
var soapClassicPool = require('syracuse-soap/lib/generic/entities/soapClassicPool');

exports._process = function(_, request, response) {
	syracuse = syracuse || require('syracuse-main/lib/syracuse');
	if (syracuse.server instanceof mock.MockStreamServer && !request.fromNanny && !request._request.fromNanny) {
		response.writeHead("404", {});
		return response.end("Resource not found.");
	}
	var parsed = url.parse(request.url, true);
	var tenant = parsed.query.tenantId;
	if (multiTenant && tenant && !syracuse.initializedTenant(tenant)) {
		response.writeHead("200", {});
		console.log("Ignored");
		return response.end("Ignored");
	} else {
		globals.context.tenantId = tenant;
	}
	var data = request.readAll(_);
	if (data && data.length > 0) {
		try {
			data = JSON.parse(data);
			globals.context.session = {
				id: data.id,
				clientId: data.clientId,
				serverName: data.serverName,
				getData: function(code) {
					return data.data && data.data[code];
				}
			};
		} catch (e) {
			console.error("Can't parse nanny request data: " + e.safeStack);
		}
	}
	//console.log("TENANT " + globals.context.tenantId);
	var cmdName = parsed.pathname.split('/')[2];
	var diags;
	try {

		switch (cmdName) {
			case "update":
				diags = soapClassicPool.updateExternal(_, parsed.query.uuid);
				response.end(JSON.stringify(diags));
				break;
			case "stop":
				diags = soapClassicPool.stopExternal(_, parsed.query.uuid);
				response.end(JSON.stringify(diags));
				break;
			case "getInfos":
				var res = soapClassicPool.getInfosExternal(_, parsed.query.uuid);
				response.end(JSON.stringify(res));
				break;
			default:
				response.writeHead("404", {});
				return response.end("Nanny command not found.");
		}
	} catch (e) {
		console.error(e.stack);
		response.writeHead("500", {});
		response.end(JSON.stringify({
			$severity: "error",
			$message: e.message,
			$safeStack: e.stack
		}));
	}
	return;
};

function getPortsDiagnoses(_, out) {
	var res = {};
	var lines = out.split(/[\r\n]+/);
	lines.forEach(function(line) {
		if (line.charAt(0) === '{') {
			line = JSON.parse(line);
			var port = line.port;
			var message = line.message;
			if (message) {
				res[port] = message.charAt(0) === '{' || message.charAt(0) === '[' ? JSON.parse(message) : message;
			}
		}
	});
	return res;
}

var parsers = {
	getInfos: getPortsDiagnoses,
	update: getPortsDiagnoses,
	stop: getPortsDiagnoses,
};

//propagation only when load balancer is available!
exports._propagate = function(_, instance, method, action, parameters) {

	if (multiTenant) {
		parameters.tenantId = globals.context.tenantId;
		path += ((path.indexOf('?') >= 0 ? '&' : '?') + 'tenantId=' + globals.context.tenantId);
		console.log("Set tenant " + path);
	}
	parameters = parameters || {};
	parameters.nannyCommand = true;
	var path = action + "?" + querystring.stringify(parameters);
	if ("mockServer" in config) {
		var options = {
			path: "/nannyCommand/notifyW/soap-wsdl/" + path,
			method: method,
			headers: {
				hostname: (globals.context.tenantId || "")
			}
		};
		options.headers[mock.BALANCER_HEADER] = config.port;
		var session = globals.context.session;
		var stringifiedSession = {
			id: session.id,
			clientId: session.clientId,
			serverName: session.serverName,
			data: {
				badge: session.data && session.data.badge
			}
		};

		try {
			var res = config.mockServer.mockClient.simpleRequest(options, JSON.stringify(stringifiedSession), _);
			res = parsers[action] ? parsers[action](_, res) : res;
			if (!res || Object.keys(res).length === 0) {
				instance && instance.$diagnoses && instance.$diagnoses.push({
					$severity: "warning",
					$message: locale.format(module, "noWsProcesses")
				});
			}
			return res;
		} catch (e) {
			console.error("Error " + e.stack);
			return e.stack;
		}
	}
};