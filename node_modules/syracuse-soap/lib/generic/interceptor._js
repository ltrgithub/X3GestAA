"use strict";

var helpers = require("syracuse-core/lib/helpers");
var jsxml = require('jsxml');
var locale = require("syracuse-core/lib/locale");
var forEachKey = helpers.object.forEachKey;
var soapUtils = require('../server/soapUtils');
var soapTools = require('../common/soapTools');
var ackcallExecutor = require('./executor');
var stubUtils = require("syracuse-soap/lib/client/stubUtils");
var WsCall = require('syracuse-soap/lib/generic/wsCall').WsCall;

var tracer = require("syracuse-trace/lib/helper").getTracer("soap-generic.request");

function removeNamespaces(node) {
	var obj = Array.isArray(node) ? [] : {};
	// remove namespaces
	forEachKey(node, function(key, value) {
		if (key.indexOf(':') !== -1) {
			var keyParts = key.split(':');
			obj[keyParts[1]] = value != null && typeof value === "object" ? removeNamespaces(value) : value;
		} else {
			obj[key] = value != null && typeof value === "object" ? removeNamespaces(value) : value;
		}
	});
	return obj;
}

function validateProperties(properties, params) {
	function validateProperty(_property, _param, key) {

		if (_property.$isMandatory && _param === undefined) {
			throw new Error(locale.format(module, "mandatoryProperty", _property.$title));
		}
		if (_property.$type === "application/x-object") {
			//tracer.warn && tracer.warn(JSON.stringify(_property,null,2));
			return validateProperties(_property.$item.$properties, _param);
		} else if (_property.$type === "application/x-array") {
			var arr = [];

			var arrVal = _param ? (_param && _param.item ? _param.item : _param) : null;
			if (arrVal) {
				if (Array.isArray(arrVal)) {
					arrVal.forEach(function(it) {
						var p;
						if (typeof it === "object") {
							p = validateProperties(_property.$item.$properties, it);
						} else {
							p = stubUtils.convertValue(_property.$item.$properties[key].$title, _property.$item.$properties[key].$type, it);
						}
						arr.push(p);
					});
				} else {
					var p;
					if (typeof arrVal === "object") {
						p = validateProperties(_property.$item.$properties, arrVal);
					} else {
						p = stubUtils.convertValue(_property.$item.$properties[key].$title, _property.$item.$properties[key].$type, arrVal);
					}
					arr.push(p);
				}
			}
			return arr;
		} else {
			return stubUtils.convertValue(_property.$title, _property.$type, _param);
		}
	}
	var result = {};
	if (params) forEachKey(properties, function(key, value) {
		result[key] = validateProperty(value, params[key], key);
	});
	return result;
}

var __soapEnc = "http://schemas.xmlsoap.org/soap/encoding/";
var __soapEnv = "http://schemas.xmlsoap.org/soap/envelope/";
var __soapSage = "http://www.adonix.com/WSS";

var Interceptor = helpers.defineClass(function(serviceName) {
	this.serviceName = serviceName;
	this.ws;
	this.reqProto = {};
	this.respProto = {};
	console.error("Create Interceptor for service: " + serviceName);
}, null, {

	run: function(_, context) {

		var response, responseRoot, useSoapStyle, wsCall, responseProperties;
		try {
			wsCall = new WsCall();
			// start total timer
			wsCall.techInfo.totalDuration.start();

			this.ws = this.ws || soapUtils.getSoapWebService(_, this.serviceName, context, "soapGeneric");
			if (!this.ws) throw new Error(locale.format(module, "wsNotFound", this.serviceName));

			var reqHeader = context.request.headers;
			tracer.debug && tracer.debug("Header : " + JSON.stringify(reqHeader, null, 2));

			if (!reqHeader.soapaction) throw new Error(locale.format(module, "soapActMissing"));
			var soapAction = reqHeader.soapaction.replace(/\"/g, '');

			var reqBody = context.request.readAll(_);
			tracer.info && tracer.info("Body : " + reqBody);

			useSoapStyle = reqBody.indexOf(__soapEnc) !== -1;
			tracer.info && tracer.info("Soap encoding style enabled: " + useSoapStyle);

			// translate request
			tracer.debug && tracer.debug("\n");
			tracer.debug && tracer.debug("##################################################");
			tracer.debug && tracer.debug("#    Translate SOAP Action : " + soapAction);
			tracer.debug && tracer.debug("##################################################");
			reqBody = jsxml.parse(reqBody);

			// get namespaces
			var reqEnv = reqBody[Object.keys(reqBody)[0]];
			var ns = {
				soapenv: soapTools.getNamespacePrefix(reqEnv, __soapEnv),
				soapenc: soapTools.getNamespacePrefix(reqEnv, __soapEnc),
			};

			// translate request to be compliant with soap encoding
			var soapRequest = soapTools.translateRequest(reqBody, ns, useSoapStyle);
			tracer.debug && tracer.debug("# " + JSON.stringify(reqBody, null, 2));

			// Do not need ns
			var opRequest = removeNamespaces(soapRequest.body);

			var opRequestName = Object.keys(opRequest)[0];

			if (!opRequest) throw new Error(locale.format(module, "requestNotFound"));

			// Reuse or store request prototype in Executor instance
			this.reqProto[opRequestName] = this.reqProto[opRequestName] || stubUtils.getOperationPrototype(_, this.serviceName, this.serviceName, opRequestName, "$request", context, "generic-in");
			if (!this.reqProto[opRequestName]) throw new Error(locale.format(module, "errGetProto", opRequestName, "request"));
			this.respProto[opRequestName] = this.respProto[opRequestName] || stubUtils.getOperationPrototype(_, this.serviceName, this.serviceName, opRequestName, "$response", context, "generic-in");
			if (!this.respProto[opRequestName]) throw new Error(locale.format(module, "errGetProto", opRequestName, "response"));


			// Validate received parameters with expected properties + convert values
			var requestProperties = this.reqProto[opRequestName].$properties.body.$item.$properties[opRequestName].$item.$properties;
			if (!requestProperties) throw new Error(locale.format(module, "propsNotFound", this.reqProto[opRequestName].$descriptor));



			var responseNodeName = Object.keys(this.respProto[opRequestName].$properties.body.$item.$properties)[0];
			var returnNodeName = Object.keys(this.respProto[opRequestName].$properties.body.$item.$properties[responseNodeName].$item.$properties)[0];

			responseProperties = this.respProto[opRequestName].$properties.body.$item.$properties[responseNodeName].$item.$properties[returnNodeName].$item.$properties;
			if (!responseProperties) throw new Error(locale.format(module, "propsNotFound", this.respProto[opRequestName].$descriptor));

			opRequest[opRequestName] = validateProperties(requestProperties, opRequest[opRequestName]);

			responseRoot = {};
			responseRoot[responseNodeName] = {};

			tracer.info && tracer.info("\n");
			tracer.info && tracer.info("##################################################");
			tracer.info && tracer.info("#    Intercept SOAP Request for service : " + this.serviceName);
			tracer.info && tracer.info("##################################################");
			// get or create executor 
			this.executor = this.executor || ackcallExecutor.create(this.serviceName);
			// execute request
			response = responseRoot[responseNodeName][returnNodeName] = this.executor.execute(_, context, opRequestName, opRequest[opRequestName], wsCall);

		} catch (e) {
			if (!response) throw e;
			tracer.error && tracer.error(e.message, e);
			//soapResponse = addSoapBodyException(envelope, e, "soap:Server");
			wsCall.addMessage(3, e.message);
			wsCall.addMessage(4, JSON.stringify(e.safeStack));
			wsCall.status = 0;
		}

		// translate response to be compliant with soap encoding
		responseRoot = soapTools.translateResponse(responseRoot, responseProperties, useSoapStyle);


		// end of pool request
		wsCall.techInfo.poolRequestDuration.stop();

		var envelope = {
			"soapenv:Envelope": {
				$: {
					"xmlns:soapenv": __soapEnv,
					"xmlns:xs": "http://www.w3.org/2001/XMLSchema",
					"xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
					"xmlns:soapenc": __soapEnc,
					"xmlns:wss": __soapSage
				},
				"soapenv:Body": {}
			}
		};

		// build envelope
		envelope["soapenv:Envelope"]["soapenv:Body"] = responseRoot;

		// set technical informations in response flow
		response.technicalInfos = wsCall.techInfo.stringify();
		var soapResponse = jsxml.stringify(envelope, {
			indent: '\t'
		});

		soapResponse = '<?xml version="1.0" encoding="utf-8"?>\n' + soapResponse;
		tracer.info && tracer.info("\n");
		tracer.info && tracer.info("##################################################");
		tracer.info && tracer.info("#    Send SOAP Reply  : ");
		tracer.info && tracer.info("##################################################");
		tracer.info && tracer.info(soapResponse);

		wsCall.techInfo.totalDuration.stop();
		return soapResponse;
	}
});

function addSoapBodyException(envelope, ex, code) {
	// Special error
	if (ex.message && ex.message.indexOf("\n"))
		ex.message = ex.message.split("\n")[0];
	envelope["soap:Envelope"]["soap:Body"]["soap:Fault"] = {
		faultcode: {
			$: {
				"xsi:type": "xsd:string"
			},
			$value: code
		},
		faultstring: {
			$: {
				"xsi:type": "xsd:string"
			},
			$value: ex.message
		},
		detail: {
			$: {
				"xsi:type": "xsd:string"
			},
			$value: ex.safeStack,
		}

	};
	return jsxml.stringify(envelope, {
		indent: '\t'
	});
}
var interceptors = [];
exports.intercept = function(_, serviceName, context) {

	interceptors[serviceName] = interceptors[serviceName] || new Interceptor(serviceName);

	return interceptors[serviceName].run(_, context);

};