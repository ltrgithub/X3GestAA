"use strict";

var helpers = require("syracuse-core/lib/helpers");
var jsxml = require('jsxml');
var revivers = require('jsxml/lib/revivers');
var locale = require("syracuse-core/lib/locale");
var forEachKey = helpers.object.forEachKey;
var soapUtils = require('../server/soapUtils');
var ackcallExecutor = require('./executor');
var TechInfo = require('syracuse-soap/lib/generic/techInfo').TechInfo;
var tracer = require("syracuse-trace/lib/helper").getTracer("soap-generic.request");

var Interceptor = helpers.defineClass(function(serviceName, context) {
	this.context = context;
	this.serviceName = serviceName;
}, null, {
	run: function(_, context, envelope, techInfo) {
		var ws = soapUtils.getSoapWebService(_, this.serviceName, context, "soapGeneric");
		if (!ws) throw new Error(locale.format(module, "wsNotFound", this.serviceName));

		var reqHeader = context.request.headers;
		tracer.debug && tracer.debug("Header : " + JSON.stringify(reqHeader, null, 2));

		if (!reqHeader.soapaction) throw new Error(locale.format(module, "soapActMissing"));
		var soapAction = reqHeader.soapaction.replace(/\"/g, '');



		var reqBody = context.request.readAll(_);
		tracer.info && tracer.info("Body : " + reqBody);

		// translate request
		tracer.debug && tracer.debug("\n");
		tracer.debug && tracer.debug("##################################################");
		tracer.debug && tracer.debug("#    Translate SOAP Action : " + soapAction);
		tracer.debug && tracer.debug("##################################################");
		reqBody = jsxml.parse(reqBody, revivers.simplify);
		tracer.debug && tracer.debug("# " + JSON.stringify(reqBody, null, 2));

		var nsSoap, key;
		for (key in reqBody) {
			nsSoap = key.split(':')[0] + ':';
		}

		// maybe header will be useful
		var soapHeader = reqBody[nsSoap + "Envelope"][nsSoap + "Header"];
		var soapBody = reqBody[nsSoap + "Envelope"][nsSoap + "Body"];

		var nsEntity = '';
		var opRequestName, opRequest;

		// remove namespaces
		forEachKey(soapBody, function(key, value) {
			if (key.indexOf(':') !== -1) {
				var keyParts = key.split(':');
				nsEntity = keyParts[0] + ':';
				opRequestName = keyParts[1];
			} else {
				opRequestName = key;
			}
			opRequest = value;
		});
		if (!opRequest) throw new Error(locale.format(module, "requestNotFound"));

		// get or create executor 
		this.executor = this.executor || ackcallExecutor.create(this.serviceName);

		// execute request
		var response = this.executor.execute(_, context, opRequestName, opRequest, techInfo);
		techInfo.totalDuration.stop();
		response.technicalInfos = techInfo.stringify();

		// build envelope
		envelope["soap:Envelope"]["soap:Body"][opRequestName + "Response"] = response;
		return jsxml.stringify(envelope, {
			indent: '\t'
		});
	}
});

function addSoapBodyException(envelope, ex, code) {
	// Special error
	if (ex.message && ex.message.indexOf("\n"))
		ex.message = ex.message.split("\n")[0];
	envelope["soap:Envelope"]["soap:Body"]["soap:Fault"] = {
		faultcode: {
			$: {
				"xsi:type": "xsd:string"
			},
			$value: code
		},
		faultstring: {
			$: {
				"xsi:type": "xsd:string"
			},
			$value: ex.message
		},
		detail: {
			$: {
				"xsi:type": "xsd:string"
			},
			$value: ex.safeStack,
		}

	};
	return jsxml.stringify(envelope, {
		indent: '\t'
	});
}
var interceptors = [];
exports.intercept = function(_, serviceName, context) {
	// instanciate technical information
	var techInfo = new TechInfo();
	techInfo.totalDuration.start();
	var soapResponse;
	var envelope = {
		"soap:Envelope": {
			$: {
				"xmlns:soap": "http://schemas.xmlsoap.org/soap/envelope/",
				"xmlns:xs": "http://www.w3.org/2001/XMLSchema",
				"xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance"
			},
			"soap:Body": {}
		}
	};
	interceptors[serviceName] = interceptors[serviceName] || new Interceptor(serviceName);
	try {
		tracer.info && tracer.info("\n");
		tracer.info && tracer.info("##################################################");
		tracer.info && tracer.info("#    Intercept SOAP Request for service : " + serviceName);
		tracer.info && tracer.info("##################################################");
		soapResponse = interceptors[serviceName].run(_, context, envelope, techInfo);
	} catch (e) {
		tracer.error && tracer.error(e.message, e);
		soapResponse = addSoapBodyException(envelope, e, "soap:Server");
	} finally {
		soapResponse = '<?xml version="1.0" encoding="utf-8"?>\n' + soapResponse;
		tracer.info && tracer.info("\n");
		tracer.info && tracer.info("##################################################");
		tracer.info && tracer.info("#    Send SOAP Reply  : ");
		tracer.info && tracer.info("##################################################");
		tracer.info && tracer.info(soapResponse);

		tracer.debug && tracer.debug("Technical information: " + JSON.stringify(techInfo, null, 2));
		return soapResponse;
	}
};