"use strict";

var helpers = require("syracuse-core/lib/helpers");
var util = require("util");
var jsxml = require('jsxml');
var locale = require("syracuse-core/lib/locale");
var forEachKey = helpers.object.forEachKey;

var soapTracer = require('../common/soapTracer');
var soapTimer = require('../common/soapTimer');
var soapUtils = require('../server/soapUtils');
var ackcallExecutor = require('./executor');
var tracer = soapTracer.create("request");
var timer = soapTimer.create("interceptor");

var Interceptor = helpers.defineClass(function(_, serviceName, context) {

	this.context = context;
	this.serviceName = serviceName;
	this.app = context.applicationName;

	this.envelope = {
		"soap:Envelope": {

			//			$: {
			//				"xmlns:soap": "http://schemas.xmlsoap.org/soap/envelope/",
			//				"xmlns:xs": "http://www.w3.org/2001/XMLSchema",
			//				"xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance"
			//			},
			"soap:Body": {}
		}
	};

}, null, {
	run: function(_) {
		var ws = soapUtils.getSoapWebService(_, this.serviceName, this.context, "soapGeneric");
		if (!ws) throw new Error(locale.format(module, "wsNotFound", this.serviceName));

		var reqHeader = this.context.request.headers;
		tracer.trace("Header : " + JSON.stringify(reqHeader, null, 2));

		if (!reqHeader.soapaction) throw new Error(locale.format(module, "soapActMissing"));
		var soapAction = reqHeader.soapaction.replace(/\"/g, '');

		var reqBody = this.context.request.readAll(_);
		tracer.trace("Body : " + reqBody);

		return this.translateRequest(_, soapAction, jsxml.parse(reqBody));

	},
	translateRequest: function(_, soapAction, reqBody) {
		tracer.traceSection("Translate SOAP Action : " + soapAction, JSON.stringify(reqBody, null, 2));

		function format(element) {
			var newElement = {};
			for (var key in element) {
				var newKey;
				if (key.indexOf(nsEntity) === 0) {
					newKey = key.substring(nsEntity.length);
				} else {
					newKey = key;
				}
				if (newKey.indexOf('_') === 0) newKey = '$' + newKey.substring(1);
				newElement[newKey] = Array.isArray(element[key]) || typeof element[key] === 'object' ? format(element[key]) : element[key];
			}
			return newElement;
		}

		var nsSoap, key;
		for (key in reqBody) {
			nsSoap = key.split(':')[0] + ':';
		}

		// maybe header will be useful
		var soapHeader = reqBody[nsSoap + "Envelope"][nsSoap + "Header"];
		var soapBody = reqBody[nsSoap + "Envelope"][nsSoap + "Body"];

		var nsEntity = '';
		var opRequestName, opRequest;

		forEachKey(soapBody, function(key, value) {
			if (key.indexOf(':') !== -1) {
				var keyParts = key.split(':');
				nsEntity = keyParts[0] + ':';
				opRequestName = keyParts[1];
			} else {
				opRequestName = key;
			}
			opRequest = value;
		});
		if (!opRequest) throw new Error(locale.format(module, "requestNotFound"));

		var executor = ackcallExecutor.create(_, this.context, this.serviceName);

		if (opRequest.$) delete opRequest.$;

		var params = format(opRequest);

		var response = executor.execute(_, opRequestName, params);
		this.addSoapBodyResponse(opRequestName, response);
		console.log("this.envelope: " + JSON.stringify(this.envelope, null, 2));
		return jsxml.stringify(this.envelope, {
			indent: '\t'
		});

	},

	addSoapBodyResponse: function(method, response) {
		this.envelope["soap:Envelope"]["soap:Body"][method + "Response"] = response;
	},
	addSoapBodyException: function(ex, code) {
		// Special error
		if (ex.message && ex.message.indexOf("\n"))
			ex.message = ex.message.split("\n")[0];
		this.envelope["soap:Envelope"]["soap:Body"]["soap:Fault"] = {
			faultcode: {
				$: {
					"xsi:type": "xsd:string"
				},
				$value: code
			},
			faultstring: {
				$: {
					"xsi:type": "xsd:string"
				},
				$value: ex.message
			},
			detail: {
				$: {
					"xsi:type": "xsd:string"
				},
				$value: ex.safeStack,
			}

		};
		return jsxml.stringify(this.envelope, {
			indent: '\t'
		});
	}
});

exports.intercept = function(_, serviceName, context) {
	timer.start();
	var soapResponse;
	var interceptor = new Interceptor(_, serviceName, context);
	try {
		tracer.traceSection("PROTOCOL: " + interceptor.protocol);
		tracer.traceSection("Intercept SOAP Request for service : " + serviceName);
		soapResponse = interceptor.run(_);
	} catch (e) {
		tracer.trace("Error: " + e.stack);
		soapResponse = interceptor.addSoapBodyException(e, "soap:Server");
	} finally {
		soapResponse = '<?xml version="1.0" encoding="utf-8"?>\n' + soapResponse;
		tracer.traceSection("Send SOAP Reply  : ", soapResponse);
		//console.log("SOAP Call duration: "+ timer.calc()+" ms");
		return soapResponse;
	}
};