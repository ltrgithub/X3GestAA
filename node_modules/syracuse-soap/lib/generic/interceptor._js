"use strict";

var helpers = require("syracuse-core/lib/helpers");
var jsxml = require('jsxml');
var locale = require("syracuse-core/lib/locale");
var forEachKey = helpers.object.forEachKey;
var soapUtils = require('../server/soapUtils');
var soapTools = require('../common/soapTools');
var ackcallExecutor = require('./executor');
var stubUtils = require("syracuse-soap/lib/client/stubUtils");
var WsCall = require('syracuse-soap/lib/generic/wsCall').WsCall;

var tracer = require("syracuse-trace/lib/helper").getTracer("soap-generic.request");


function removeNamespaces(node) {
	var obj = Array.isArray(node) ? [] : {};
	// remove namespaces
	forEachKey(node, function(key, value) {
		if (key.indexOf(':') !== -1) {
			var keyParts = key.split(':');
			obj[keyParts[1]] = value != null && typeof value === "object" ? removeNamespaces(value) : value;
		} else {
			obj[key] = value != null && typeof value === "object" ? removeNamespaces(value) : value;
		}
	});
	return obj;
}

function validateProperties(properties, params) {
	function validateProperty(_property, _param, key) {

		if (_property.$isMandatory && _param === undefined) {
			throw new Error(locale.format(module, "mandatoryProperty", _property.$title));
		}
		if (_property.$type === "application/x-object") {
			//tracer.warn && tracer.warn(JSON.stringify(_property,null,2));
			return validateProperties(_property.$item.$properties, _param);
		} else if (_property.$type === "application/x-array") {
			var arr = [];

			var arrVal = _param ? (_param && _param.item ? _param.item : _param) : null;
			if (arrVal) {
				if (Array.isArray(arrVal)) {
					arrVal.forEach(function(it) {
						var p;
						if (typeof it === "object") {
							p = validateProperties(_property.$item.$properties, it);
						} else {
							p = stubUtils.convertValue(_property.$item.$properties[key].$title, _property.$item.$properties[key].$type, it);
						}
						arr.push(p);
					});
				} else {
					var p;
					if (typeof arrVal === "object") {
						p = validateProperties(_property.$item.$properties, arrVal);
					} else {
						p = stubUtils.convertValue(_property.$item.$properties[key].$title, _property.$item.$properties[key].$type, arrVal);
					}
					arr.push(p);
				}
			}
			return arr;
		} else {
			return stubUtils.convertValue(_property.$title, _property.$type, _param);
		}
	}
	var result = {};
	if (params) forEachKey(properties, function(key, value) {
		result[key] = validateProperty(value, params[key], key);
	});
	return result;
}

var Interceptor = helpers.defineClass(function(serviceName, context) {
	this.context = context;
	this.serviceName = serviceName;
	this.reqProto = {};
	this.respProto = {};
	console.error("Create Interceptor for service: " + serviceName);
}, null, {
	run: function(_, context, envelope) {
		var wsCall = new WsCall();
		wsCall.techInfo.totalDuration.start();

		var ws = soapUtils.getSoapWebService(_, this.serviceName, context, "soapGeneric");
		if (!ws) throw new Error(locale.format(module, "wsNotFound", this.serviceName));

		var reqHeader = context.request.headers;
		tracer.debug && tracer.debug("Header : " + JSON.stringify(reqHeader, null, 2));

		if (!reqHeader.soapaction) throw new Error(locale.format(module, "soapActMissing"));
		var soapAction = reqHeader.soapaction.replace(/\"/g, '');

		var reqBody = context.request.readAll(_);
		tracer.info && tracer.info("Body : " + reqBody);

		// translate request
		tracer.debug && tracer.debug("\n");
		tracer.debug && tracer.debug("##################################################");
		tracer.debug && tracer.debug("#    Translate SOAP Action : " + soapAction);
		tracer.debug && tracer.debug("##################################################");
		reqBody = jsxml.parse(reqBody);
		var soapRequest = soapTools.translateRequest(reqBody);
		tracer.debug && tracer.debug("# " + JSON.stringify(reqBody, null, 2));

		var opRequest = removeNamespaces(soapRequest.body);

		var opRequestName = Object.keys(opRequest)[0];

		if (!opRequest) throw new Error(locale.format(module, "requestNotFound"));

		// Reuse or store request prototype in Executor instance
		this.reqProto[opRequestName] = this.reqProto[opRequestName] || stubUtils.getOperationPrototype(_, this.serviceName, this.serviceName, opRequestName, "$request", context, "generic-in");
		if (!this.reqProto[opRequestName]) throw new Error(locale.format(module, "errGetProto", opRequestName, "request"));
		this.respProto[opRequestName] = this.respProto[opRequestName] || stubUtils.getOperationPrototype(_, this.serviceName, this.serviceName, opRequestName, "$response", context, "generic-in");
		if (!this.respProto[opRequestName]) throw new Error(locale.format(module, "errGetProto", opRequestName, "response"));


		// Validate received parameters with expected properties + convert values
		var requestProperties = this.reqProto[opRequestName].$properties.body.$item.$properties[opRequestName].$item.$properties;
		if (!requestProperties) throw new Error(locale.format(module, "reqPropsNotFound", this.reqProto[opRequestName].$descriptor));

		var responseNodeName = Object.keys(this.respProto[opRequestName].$properties.body.$item.$properties)[0];
		var returnNodeName = Object.keys(this.respProto[opRequestName].$properties.body.$item.$properties[responseNodeName].$item.$properties)[0];

		opRequest[opRequestName] = validateProperties(requestProperties, opRequest[opRequestName]);

		var responseRoot = {
			$: {
				"xmlns": "TODO"
			}
		};
		responseRoot[responseNodeName] = {};
		var response = responseRoot[responseNodeName][returnNodeName] = {};

		try {
			tracer.info && tracer.info("\n");
			tracer.info && tracer.info("##################################################");
			tracer.info && tracer.info("#    Intercept SOAP Request for service : " + this.serviceName);
			tracer.info && tracer.info("##################################################");
			// get or create executor 
			this.executor = this.executor || ackcallExecutor.create(this.serviceName);
			// execute request
			this.executor.execute(_, context, opRequestName, opRequest[opRequestName], wsCall);
		} catch (e) {
			tracer.error && tracer.error(e.message, e);
			//soapResponse = addSoapBodyException(envelope, e, "soap:Server");
			wsCall.addMessage(3, e.message);
			//wsCall.addMessage(3, e.safeStack);
			wsCall.status = 0;
		} finally {
			var resultName = "resultXml";
			response[resultName] = {};
			if (wsCall.result) {
				response[resultName].$cdata = wsCall.result;
			} else {
				response[resultName].$value = null;
			}
			response.messages = wsCall.messages;
			response.status = wsCall.status;

			wsCall.techInfo.totalDuration.stop();
			response.technicalInfos = wsCall.techInfo.stringify();

			// build envelope
			envelope["soap:Envelope"]["soap:Body"] = responseRoot;
			var soapResponse = jsxml.stringify(envelope, {
				indent: '\t'
			});

			soapResponse = '<?xml version="1.0" encoding="utf-8"?>\n' + soapResponse;
			tracer.info && tracer.info("\n");
			tracer.info && tracer.info("##################################################");
			tracer.info && tracer.info("#    Send SOAP Reply  : ");
			tracer.info && tracer.info("##################################################");
			tracer.info && tracer.info(soapResponse);
			return soapResponse;
		}
	}
});

function addSoapBodyException(envelope, ex, code) {
	// Special error
	if (ex.message && ex.message.indexOf("\n"))
		ex.message = ex.message.split("\n")[0];
	envelope["soap:Envelope"]["soap:Body"]["soap:Fault"] = {
		faultcode: {
			$: {
				"xsi:type": "xsd:string"
			},
			$value: code
		},
		faultstring: {
			$: {
				"xsi:type": "xsd:string"
			},
			$value: ex.message
		},
		detail: {
			$: {
				"xsi:type": "xsd:string"
			},
			$value: ex.safeStack,
		}

	};
	return jsxml.stringify(envelope, {
		indent: '\t'
	});
}
var interceptors = [];
exports.intercept = function(_, serviceName, context) {
	var envelope = {
		"soap:Envelope": {
			$: {
				"xmlns:soap": "http://schemas.xmlsoap.org/soap/envelope/",
				"xmlns:xs": "http://www.w3.org/2001/XMLSchema",
				"xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance"
			},
			"soap:Body": {}
		}
	};
	interceptors[serviceName] = interceptors[serviceName] || new Interceptor(serviceName);

	return interceptors[serviceName].run(_, context, envelope);

};