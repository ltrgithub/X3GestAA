"use strict";
var helpers = require('syracuse-core/lib/helpers');
var jsxml = require('jsxml');
var locale = require("syracuse-core/lib/locale");
var CvgWsException = require("syracuse-x3/lib/clients/soap/CvgWsException").CvgWsException;


var mapTypeToResu = {
	Decimal: "DCB",
	Char: "STRU",
	Integer: "INT",
	Blob: "BLOB",
	Date: "DATE",
	// TODO add other type

};

var allowedChildren = {
	PARAM: ["GRP", "TAB"],
	GRP: ["FLD"],
	TAB: ["LIN"],
	LIN: ["FLD"],
	FLD: []
};

var InputParser = helpers.defineClass(function(wsCall) {
	this.wsCall = wsCall;
	this.descriptionSub = this.wsCall.action === "LIST" ? this.wsCall.description.ADXKEY : this.wsCall.description.ADXDATA;
	this.paramsMap = this._getParamFieldInput();
}, null, {
	_sortParams: function() {
		var self = this;
		var paramsMapSorted = Object.keys(this.paramsMap).sort(function(a, b) {
			var ai = parseInt(a, 10);
			var bi = parseInt(b, 10);
			if (ai > bi) {
				return 1;
			} else if (ai === bi) {
				return 0;
			} else {
				return -1;
			}
		});
		var params = [];
		//console.log("params Sorted "+JSON.stringify(paramsMapSorted,null,2) );
		paramsMapSorted.forEach(function(k) {
			params.push(self.paramsMap[k]);
		});
		return params;
	},
	_getNodes: function(parent, nodeName) {
		return parent && parent[nodeName] ? (Array.isArray(parent[nodeName]) ? parent[nodeName] : [parent[nodeName]]) : [];
	},
	_getParamFieldInput: function() {
		var self = this;
		if (this.descriptionSub) {
			var currentidx = 12;
			var paramsInput = {};
			var grps = this._getNodes(this.descriptionSub, "GRP");
			grps.forEach(function(grp) {
				if (grp.$.DIM > 1 && self.wsCall.action !== "LIST") { // add parameter with te idx
					paramsInput[currentidx] = {
						"index": currentidx,
						"descr": grp.$.IDTAB,
						"dim": 1,
						"nb": 0,
						"size": 0,
						"typ": "INT",
					};
					currentidx++;
				}

				var flds = self._getNodes(grp, "FLD");
				flds.forEach(function(fld) {
					paramsInput[currentidx] = {
						"index": currentidx,
						"descr": fld.$.NAM || fld.$.NAME,
						"dim": fld.$.DIM || grp.$.DIM,
						"nb": 0,
						"size": 0,
						"typ": mapTypeToResu[fld.$.TYP],
						"mod": fld.$.MOD
					};
					currentidx++;
				});
			});
			return paramsInput;
		}
	}
});

exports.InputParserXml = helpers.defineClass(function(wsCall) {
	InputParser.call(this, wsCall);
}, InputParser, {
	parse: function() {
		if (this.wsCall.flow) { // put the value the parameter that have value
			try {
				this.wsCall.flow = jsxml.parse(this.wsCall.flow);
			} catch (e) {
				this.wsCall.status = 0;
				throw new CvgWsException(locale.format(module, "cantLoadInput", "XML"));
			}
			if (!this.wsCall.flow.PARAM) this.wsCall.report.addError(locale.format(module, "noParamTag"));
			this._checkAllowedNodes("PARAM", this.wsCall.flow.PARAM);
			this._checkGroups(this.wsCall.flow.PARAM);
			this._checkTables(this.wsCall.flow.PARAM);
		}
		//
		if (this.wsCall.report.errors.length > 0) {
			this.wsCall.status = 0;
			throw new CvgWsException(locale.format(module, "cantLoadInput", "XML"));
		}
		return this._sortParams();
	},
	_findDescrGroup: function(id) {
		if (this.descriptionSub) {
			var grps = this._getNodes(this.descriptionSub, "GRP");
			var found = null;
			for (var i = 0; i < grps.length && !found; i++) {
				var grpName = grps[i].$.NAM || grps[i].$.NAME;
				found = grpName === id ? grps[i] : null;
				if (found) return found;
			}
		}
		this.wsCall.report.addError(locale.format(module, "nodeIdNotFound", id));
	},
	_findDescrfield: function(id, jsonDescrGrp) {
		if (jsonDescrGrp) {
			var flds = this._getNodes(jsonDescrGrp, "FLD");
			var found = null;
			for (var i = 0; i < flds.length && !found; i++) {
				var fldName = flds[i].$.NAM || flds[i].$.NAME;
				found = fldName === id ? flds[i] : null;
				if (found) return found;
			}
		}
		this.wsCall.report.addError(locale.format(module, "fldIdNotFound", id, jsonDescrGrp.$.NAM));
	},
	_findIndexField: function(fldName, map) {
		var fldIdx;
		var found = Object.keys(map).some(function(key) {
			var _found = map[key].descr === fldName;
			if (_found) fldIdx = key;
			return _found;
		});
		if (found) return fldIdx;
		this.wsCall.report.addError(locale.format(module, "fldNotFound", fldName));
	},
	_checkAllowedNodes: function(type, node) {
		var self = this;
		Object.keys(node).forEach(function(n) {
			if (n !== '$' && allowedChildren[type].indexOf(n) === -1) {
				self.wsCall.report.addError(locale.format(module, "nodeLocForbidden", n, type));
			}
		});
	},
	_checkFields: function(parentNode, descrGrp, arrayIdx) {
		var self = this;
		var flds = this._getNodes(parentNode, "FLD");
		// check field in flow and association with field in group in order to create parameter
		var _isArray = arrayIdx != null;

		flds && flds.forEach(function(fld) {
			var fldName = fld.$.NAM || fld.$.NAME;
			var descrFld = self._findDescrfield(fldName, descrGrp);
			if (descrFld) {
				var idx = self._findIndexField(fldName, self.paramsMap);
				var _value = fld.$value;

				if (_isArray) {

					_value = self.paramsMap[idx] && self.paramsMap[idx].resu && Array.isArray(self.paramsMap[idx].resu) ? self.paramsMap[idx].resu : [];
					for (var i = 0; i < arrayIdx; i++) {
						if (_value[i] === undefined) _value[i] = "";
					}
					_value.splice(arrayIdx - 1, 1, fld.$value);
				}

				// erase the previous parameter
				self.paramsMap[idx] = {
					"index": idx,
					"descr": fldName,
					"dim": descrGrp.$.DIM,
					"nb": _isArray ? _value.length : 1,
					"size": mapTypeToResu[descrFld.$.TYP] === "STRU" || mapTypeToResu[descrFld.$.TYP] === 'CLOB' ? fld.$value.length : 1,
					"typ": mapTypeToResu[descrFld.$.TYP],
					"resu": _value
				};
			}
		});

		if (_isArray) {
			var _paramTabNb = self.paramsMap[self._findIndexField(descrGrp.$.IDTAB, self.paramsMap)];
			if (_paramTabNb.nb > 0) {
				_paramTabNb.resu = arrayIdx > _paramTabNb.resu + 1 ? arrayIdx : _paramTabNb.resu + 1;
			} else {
				_paramTabNb.nb = 1;
				_paramTabNb.resu = arrayIdx > 1 ? arrayIdx : 1;
			}
		}
	},
	_checkGroups: function(paramNode) {
		var self = this;
		var grps = this._getNodes(paramNode, "GRP");
		// check if the group exists in the description and analyse all field to create a param
		grps && grps.forEach(function(grp) { // check if the group exists in the
			if (!grp.$ || !grp.$.ID) {
				self.wsCall.report.addError(locale.format(module, "noIdInGrp"));
				return;
			}
			var descrGrp = self._findDescrGroup(grp.$.ID);
			if (descrGrp) {
				if (descrGrp.$.DIM && descrGrp.$.DIM > 1) {
					self.wsCall.report.addError(locale.format(module, "grpDimGtXml", descrGrp.$.NAM));
				}
				self._checkAllowedNodes("GRP", grp);
				self._checkFields(grp, descrGrp);
			}
		});
	},
	_checkLines: function(tabNode, descrGrp) {
		var self = this;
		var lins = this._getNodes(tabNode, "LIN");
		// check if the group exists in the description and analyse all field to create a param
		lins && lins.forEach(function(lin) {
			var num = lin.$ && lin.$.NUM ? parseInt(lin.$.NUM, 10) : 1;
			self._checkAllowedNodes("LIN", lin);
			self._checkFields(lin, descrGrp, num);
		});
	},
	_checkTables: function(paramNode) {
		var self = this;
		var tabs = this._getNodes(paramNode, "TAB");
		// check if the group exists in the description and analyse all field to create a param
		tabs && tabs.forEach(function(tab) {
			var descrGrp = self._findDescrGroup(tab.$.ID);
			if (descrGrp) {
				if (descrGrp.$.DIM && descrGrp.$.DIM === 1) {
					self.wsCall.report.addError(locale.format(module, "tabDimEqXml", descrGrp.$.NAM));
				}
				self._checkAllowedNodes("TAB", tab);
				self._checkLines(tab, descrGrp);
			}
		});
	}
});


exports.InputParserJson = helpers.defineClass(function(wsCall) {
	InputParser.call(this, wsCall);
}, InputParser, {
	parse: function() {
		if (this.wsCall.flow) { // put the value the parameter that have value
			try {
				this.wsCall.flow = JSON.parse(this.wsCall.flow);
			} catch (e) {
				console.error("Error parse: " + e.stack);
				this.wsCall.status = 0;
				throw new CvgWsException(locale.format(module, "cantLoadInput", "JSON"));
			}
			this._checkGroups(this.wsCall.flow);
		}
		//
		if (this.wsCall.report.errors.length > 0) {
			this.wsCall.status = 0;
			throw new CvgWsException(locale.format(module, "cantLoadInput", "JSON"));
		}
		return this._sortParams();
	},
	_findDescrGroup: function(id) {
		if (this.descriptionSub) {
			var grps = this._getNodes(this.descriptionSub, "GRP");
			var found = null;
			for (var i = 0; i < grps.length && !found; i++) {
				var grpName = grps[i].$.NAM || grps[i].$.NAME;
				found = grpName === id ? grps[i] : null;
				if (found) return found;
			}
		}
		this.wsCall.report.addError(locale.format(module, "nodeIdNotFound", id));
	},
	_findDescrfield: function(id, jsonDescrGrp) {
		if (jsonDescrGrp) {
			var flds = this._getNodes(jsonDescrGrp, "FLD");
			var found = null;
			for (var i = 0; i < flds.length && !found; i++) {
				var fldName = flds[i].$.NAM || flds[i].$.NAME;
				found = fldName === id ? flds[i] : null;
				if (found) return found;
			}
		}
		this.wsCall.report.addError(locale.format(module, "fldIdNotFound", id, jsonDescrGrp.$.NAM));
	},
	_findIndexField: function(fldName, map) {
		var fldIdx;
		var found = Object.keys(map).some(function(key) {
			var _found = map[key].descr === fldName;
			if (_found) fldIdx = key;
			return _found;
		});
		if (found) return fldIdx;
		this.wsCall.report.addError(locale.format(module, "fldNotFound", fldName));
	},
	_checkFields: function(parentNode, descrGrp, arrayIdx) {
		var self = this;
		var fldKeys = Object.keys(parentNode);
		// check field in flow and association with field in group in order to create parameter
		var _isArray = arrayIdx != null;

		fldKeys && fldKeys.forEach(function(fldName) {
			var _value = parentNode[fldName];
			var descrFld = self._findDescrfield(fldName, descrGrp);
			if (descrFld) {
				var idx = self._findIndexField(fldName, self.paramsMap);
				if (_isArray) {
					_value = self.paramsMap[idx] && self.paramsMap[idx].resu && Array.isArray(self.paramsMap[idx].resu) ? self.paramsMap[idx].resu : [];
					for (var i = 0; i < arrayIdx; i++) {
						if (_value[i] === undefined) _value[i] = "";
					}
					_value.splice(arrayIdx - 1, 1, _value);
				}

				// erase the previous parameter
				self.paramsMap[idx] = {
					"index": idx,
					"descr": fldName,
					"dim": descrGrp.$.DIM,
					"nb": _isArray ? _value.length : 1,
					"size": mapTypeToResu[descrFld.$.TYP] === "STRU" || mapTypeToResu[descrFld.$.TYP] === 'CLOB' ? _value.length : 1,
					"typ": mapTypeToResu[descrFld.$.TYP],
					"resu": _value
				};
			}
		});

		if (_isArray) {
			var _paramTabNb = self.paramsMap[self._findIndexField(descrGrp.$.IDTAB, self.paramsMap)];
			if (_paramTabNb.nb > 0) {
				_paramTabNb.resu = arrayIdx > _paramTabNb.resu + 1 ? arrayIdx : _paramTabNb.resu + 1;
			} else {
				_paramTabNb.nb = 1;
				_paramTabNb.resu = arrayIdx > 1 ? arrayIdx : 1;
			}
		}
	},
	_checkGroups: function(paramNode) {
		var self = this;
		var grpKeys = Object.keys(paramNode);
		// check if the group exists in the description and analyse all field to create a param
		grpKeys && grpKeys.forEach(function(key) { // check if the group exists in the
			var grp = paramNode[key];
			var descrGrp = self._findDescrGroup(key);
			if (descrGrp) {
				var isArray = Array.isArray(grp);
				// This function checks groups and tables (not like for XML)
				if (descrGrp.$.DIM && descrGrp.$.DIM > 1 && !isArray) {
					self.wsCall.report.addError(locale.format(module, "grpDimGtJson", descrGrp.$.NAM));
				} else if (descrGrp.$.DIM && descrGrp.$.DIM === 1 && isArray) {
					self.wsCall.report.addError(locale.format(module, "tabDimEqJson", descrGrp.$.NAM));
				}
				if (isArray) {
					self._checkLines(grp, descrGrp);
				} else {
					self._checkFields(grp, descrGrp);
				}
			}
		});
	},
	_checkLines: function(tabNode, descrGrp) {
		var self = this;
		var linKeys = Object.keys(tabNode);
		// check if the group exists in the description and analyse all field to create a param
		linKeys && linKeys.forEach(function(key, num) {
			var lin = tabNode[key];
			self._checkFields(lin, descrGrp, num + 1);
		});
	}
});