"use strict";
var helpers = require('syracuse-core/lib/helpers');
var jsxml = require('jsxml');
var locale = require("syracuse-core/lib/locale");
var CvgWsException = require("syracuse-x3/lib/clients/soap/CvgWsException").CvgWsException;
var forEachKey = helpers.object.forEachKey;


var mapTypeToResu = {
	Decimal: "DCB",
	Char: "STRU",
	Integer: "INT",
	Blob: "BLOB",
	Date: "DATE",
	// TODO add other type

};

var allowedChildren = {
	PARAM: ["GRP", "TAB", "FLD"],
	GRP: ["FLD", "LST"],
	TAB: ["LIN"],
	LIN: ["FLD"],
	FLD: []
};

var InputParser = helpers.defineClass(function(wsCall) {
	this.wsCall = wsCall;
	this.descriptionSub = this.wsCall.action === "LIST" ? this.wsCall.description.ADXKEY : this.wsCall.description.ADXDATA;
	this.paramsMap = this._getParamFieldInput();
}, null, {
	_sortParams: function() {
		var self = this;
		var paramsMapSorted = Object.keys(this.paramsMap).sort(function(a, b) {
			var ai = parseInt(a, 10);
			var bi = parseInt(b, 10);
			if (ai > bi) {
				return 1;
			} else if (ai === bi) {
				return 0;
			} else {
				return -1;
			}
		});
		var params = [];
		//console.log("params Sorted "+JSON.stringify(paramsMapSorted,null,2) );
		paramsMapSorted.forEach(function(k) {
			params.push(self.paramsMap[k]);
		});
		return params;
	},
	_getNodes: function(parent, nodeName) {
		return parent && parent[nodeName] ? (Array.isArray(parent[nodeName]) ? parent[nodeName] : [parent[nodeName]]) : [];
	},
	_getParamFieldInput: function() {
		var self = this;
		if (this.descriptionSub) {
			var currentidx = 12;
			var paramsInput = {};
			var grps = this._getNodes(this.descriptionSub, "GRP");
			grps.forEach(function(grp) {
				if (grp.$.DIM > 1 && self.wsCall.action !== "LIST" && self.wsCall.action !== "EXEC") { // add parameter with te idx
					paramsInput[currentidx] = {
						"index": currentidx,
						"grp": grp.$.NAM,
						"descr": grp.$.IDTAB,
						"dim": 1,
						"nb": 0,
						"size": 0,
						"typ": "INT",
					};
					currentidx++;
				}

				var flds = self._getNodes(grp, "FLD");
				flds.forEach(function(fld) {
					paramsInput[currentidx] = {
						"index": currentidx,
						"grp": grp.$.NAM,
						"descr": fld.$.NAM || fld.$.NAME,
						"dim": self.wsCall.action !== "LIST" ? fld.$.DIM || grp.$.DIM : self.wsCall.nb,
						"nb": 0,
						"size": fld.$.LEN || 0,
						"typ": mapTypeToResu[fld.$.TYP],
						"mod": fld.$.MOD
					};
					currentidx++;
				});
			});
			return paramsInput;
		}
	},
	// This function is really important. All the parameters map is built here !!!
	_replaceOldValue: function(fld, descrGrp, arrayIdx) {
		var _isArray = arrayIdx != null;
		var fldName = fld.$.NAM || fld.$.NAME;
		var isItm = fld.$.isITM;
		var descrFld = this._findDescrfield(fldName, descrGrp);
		if (descrFld) {
			var idx = this._findIndexField(fldName, this.paramsMap);
			var _value = fld.$value;
			var _len = fld.$value && (mapTypeToResu[descrFld.$.TYP] === "STRU" || mapTypeToResu[descrFld.$.TYP] === 'CLOB') ? fld.$value.length : 1;

			var defVal = this.forceDefaultValue(descrFld.$.TYP);
			if (_isArray) {
				_value = this.paramsMap[idx] && this.paramsMap[idx].resu && Array.isArray(this.paramsMap[idx].resu) ? this.paramsMap[idx].resu : [];
				for (var i = 0; i < arrayIdx; i++) {
					if (_value[i] == null) _value[i] = defVal;
				}
				_value.splice(arrayIdx - 1, 1, fld.$value || defVal);
				// ensure bigger size will be used in param
				_value.forEach(function(v) {
					if (v && v.length > _len) _len = v.length;
				});
				if (!isItm && _value.length > parseInt(descrGrp.$.DIM, 10)) {
					this.wsCall.report.addError("Line number out of range for field [" + descrGrp.$.NAM + ":" + fldName + "]. The rule to follow description is [" + descrGrp.$.DIM + ">= NumLine >=1].");
					throw new CvgWsException(locale.format(module, "cantLoadInput", ""));
				}
			} else if (!_value && descrFld.$.PAR === "Value" && descrFld.$.MOD === "Input") {
				_value = defVal;
				_len = _value.length;
			}

			// erase the previous parameter
			this.paramsMap[idx] = {
				"index": idx,
				"grp": descrGrp.$.NAM,
				"descr": fldName,
				"dim": isItm ? _value.length : descrGrp.$.DIM,
				"nb": _isArray ? _value.length : (_value ? 1 : 0),
				"size": _len,
				"typ": mapTypeToResu[descrFld.$.TYP],
				"resu": _value
			};
		}
	},
	_findDescrGroup: function(id, ignoreErr) {
		if (this.descriptionSub) {
			var grps = this._getNodes(this.descriptionSub, "GRP");
			var found = null;
			for (var i = 0; i < grps.length && !found; i++) {
				var grpName = grps[i].$.NAM || grps[i].$.NAME;
				found = grpName === id ? grps[i] : null;
				if (found) return found;
			}
		}
		if (ignoreErr) return false;
		this.wsCall.report.addError(locale.format(module, "nodeIdNotFound", id));
	},
	_findIndexField: function(fldName, map) {
		var fldIdx;
		var found = Object.keys(map).some(function(key) {
			var _found = map[key].descr === fldName;
			if (_found) fldIdx = key;
			return _found;
		});
		if (found) return fldIdx;
		this.wsCall.report.addError(locale.format(module, "fldNotFound", fldName));
	},
	_findDescrfield: function(id, jsonDescrGrp) {
		if (jsonDescrGrp) {
			var flds = this._getNodes(jsonDescrGrp, "FLD");
			var found = null;
			for (var i = 0; i < flds.length && !found; i++) {
				var fldName = flds[i].$.NAM || flds[i].$.NAME;
				found = fldName === id ? flds[i] : null;
				if (found) return found;
			}
		}
		// ignore field not found when ends by _LBL --> Only needed for JSON parameters
		if (id.indexOf("_LBL") === id.length - 4) return false;
		this.wsCall.report.addError(locale.format(module, "fldIdNotFound", id, jsonDescrGrp.$.NAM));
	},
	// this function takes an array as parameter with FLD names : e.g. ["USR", "LOGIN", "PRFMEN"]
	// and return an object with GRP matches : {"AUS1_0": ["USR", "LOGIN"], "AUS1_1": ["PRFMEN"]}
	_belongsToGrps: function(fldNamesArr) {
		function checkFld(_fld) {
			var idx = fldNamesArr.indexOf(_fld.$.NAM);
			if (idx !== -1) {
				map[grp.$.NAM] = map[grp.$.NAM] || [];
				map[grp.$.NAM].push(_fld.$.NAM);
				fldNamesArr.splice(idx, 1);
			}
		}
		var map = {};
		var grps = this._getNodes(this.descriptionSub, "GRP");
		for (var i = 0; i < grps.length; i++) {
			var grp = grps[i];
			if (grp.FLD) {
				if (Array.isArray(grp.FLD)) {
					for (var j = 0; j < grp.FLD.length; j++) {
						var fld = grp.FLD[j];
						checkFld(fld);
					}
				} else {
					checkFld(grp.FLD);
				}
			}
			if (fldNamesArr.length === 0) break;

		}
		this.wsCall.addMessage(2, locale.format(module, "perfBetterWithGrp"));
		return map;
	},
	forceDefaultValue: function(type) {
		switch (type) {
			case "Decimal":
			case "Integer":
				return "0";
			case "Char":
				return "";
			default:
				return;
		}
	}
});

exports.InputParserXml = helpers.defineClass(function(wsCall) {
	InputParser.call(this, wsCall);
}, InputParser, {
	parse: function() {
		if (this.wsCall.flow) { // put the value the parameter that have value
			try {
				if (typeof this.wsCall.flow !== "object") this.wsCall.flow = jsxml.parse(this.wsCall.flow);
			} catch (e) {
				console.error("Error jsxml parse: " + e.stack);
				console.error("Received flow: " + JSON.stringify(this.wsCall.flow));
				this.wsCall.status = 0;
				throw new CvgWsException(locale.format(module, "cantLoadInput", "XML"));
			}
			if (!this.wsCall.flow.PARAM) this.wsCall.report.addError(locale.format(module, "noParamTag"));
			this._checkAllowedNodes("PARAM", this.wsCall.flow.PARAM);

			// special case where GRP are not here !!!
			if (this.wsCall.flow.PARAM.FLD) {
				if (!Array.isArray(this.wsCall.flow.PARAM.FLD)) this.wsCall.flow.PARAM.FLD = [this.wsCall.flow.PARAM.FLD];
				this._computeGroupsFromFlds();
			}

			this._checkGroups(this.wsCall.flow.PARAM);
			this._checkTables(this.wsCall.flow.PARAM);
		}
		//
		if (this.wsCall.report.errors.length > 0) {
			this.wsCall.status = 0;
			throw new CvgWsException(locale.format(module, "cantLoadInput", "XML"));
		}
		return this._sortParams();
	},
	_computeGroupsFromFlds: function() {
		var self = this;
		var fldNames = this.wsCall.flow.PARAM.FLD.map(function(fld) {
			if (!fld.$ || (!fld.$.NAME && !fld.$.NAM)) throw new CvgWsException(locale.format(module, "nameManadatoryOnFld"));
			return fld.$.NAME || fld.$.NAM;
		});
		var grpMap = this._belongsToGrps(fldNames);
		this.wsCall.flow.PARAM.GRP = [];
		forEachKey(grpMap, function(key, grpFlds) {
			var flds = [];
			self.wsCall.flow.PARAM.FLD.forEach(function(fld, idx) {
				if (grpFlds.indexOf(fld.$.NAME || fld.$.NAM) !== -1) {
					flds.push(fld);
					delete self.wsCall.flow.PARAM.FLD[idx];
				}
			});
			self.wsCall.flow.PARAM.GRP.push({
				$: {
					ID: key
				},
				FLD: flds
			});

		});
		delete self.wsCall.flow.PARAM.FLD;
	},
	_checkAllowedNodes: function(type, node) {
		var self = this;
		if (node) {
			Object.keys(node).forEach(function(n) {
				if (n !== '$' && allowedChildren[type].indexOf(n) === -1) {
					self.wsCall.report.addError(locale.format(module, "nodeLocForbidden", n, type));
				}
			});
		}
	},
	_checkFields: function(parentNode, descrGrp, arrayIdx, nodeNameToCheck) {
		var self = this;
		var flds = this._getNodes(parentNode, nodeNameToCheck || "FLD");
		// check field in flow and association with field in group in order to create parameter
		var _isArray = arrayIdx != null;

		flds && flds.forEach(function(fld) {
			self._replaceOldValue(fld, descrGrp, arrayIdx);
		});

		// manage LST
		var lsts = this._getNodes(parentNode, "LST");
		lsts && lsts.forEach(function(lst) {
			var itms = self._getNodes(lst, "ITM");
			itms && itms.forEach(function(value, idx) {
				var itm = {
					$: {
						isITM: true,
						NAME: lst.$ && lst.$.NAME,
						SIZE: lst.$ && lst.$.SIZE,
						TYPE: lst.$ && lst.$.TYPE
					},
					$value: value
				};
				self._replaceOldValue(itm, descrGrp, idx + 1);
			});
		});

		if (_isArray && this.wsCall.action !== "EXEC") {
			var _paramTabNb = self.paramsMap[self._findIndexField(descrGrp.$.IDTAB, self.paramsMap)];
			if (_paramTabNb.nb > 0) {
				_paramTabNb.resu = arrayIdx > _paramTabNb.resu + 1 ? arrayIdx : _paramTabNb.resu + 1;
			} else {
				_paramTabNb.nb = 1;
				_paramTabNb.resu = arrayIdx > 1 ? arrayIdx : 1;
			}
		}
	},
	_checkGroups: function(paramNode) {
		var self = this;
		var grps = this._getNodes(paramNode, "GRP");
		// check if the group exists in the description and analyse all field to create a param
		grps && grps.forEach(function(grp) { // check if the group exists in the
			if (!grp.$ || !grp.$.ID) {
				self.wsCall.report.addError(locale.format(module, "noIdInGrp"));
				return;
			}
			var descrGrp = self._findDescrGroup(grp.$.ID);
			if (descrGrp) {
				if (descrGrp.$.DIM && descrGrp.$.DIM > 1) {
					self.wsCall.report.addError(locale.format(module, "grpDimGtXml", descrGrp.$.NAM));
				}
				self._checkAllowedNodes("GRP", grp);
				self._checkFields(grp, descrGrp);
			}
		});
	},
	_checkLines: function(tabNode, descrGrp) {
		var self = this;
		var lins = this._getNodes(tabNode, "LIN");
		// check if the group exists in the description and analyse all field to create a param
		lins && lins.forEach(function(lin) {
			var num = lin.$ && lin.$.NUM ? parseInt(lin.$.NUM, 10) : 1;
			self._checkAllowedNodes("LIN", lin);
			self._checkFields(lin, descrGrp, num);
		});
	},
	_checkTables: function(paramNode) {
		var self = this;
		var tabs = this._getNodes(paramNode, "TAB");
		// check if the group exists in the description and analyse all field to create a param
		tabs && tabs.forEach(function(tab) {
			var descrGrp = self._findDescrGroup(tab.$.ID);
			if (descrGrp) {
				if (descrGrp.$.DIM && descrGrp.$.DIM === 1) {
					self.wsCall.report.addError(locale.format(module, "tabDimEqXml", descrGrp.$.NAM));
				}
				self._checkAllowedNodes("TAB", tab);
				self._checkLines(tab, descrGrp);
			}
		});
	},
});


exports.InputParserJson = helpers.defineClass(function(wsCall) {
	InputParser.call(this, wsCall);
}, InputParser, {
	parse: function() {
		if (this.wsCall.flow) { // put the value the parameter that have value
			try {
				if (typeof this.wsCall.flow !== "object") this.wsCall.flow = JSON.parse(this.wsCall.flow);
			} catch (e) {
				console.error("Error json parse: " + e.stack);
				console.error("Received flow: " + JSON.stringify(this.wsCall.flow));
				this.wsCall.status = 0;
				throw new CvgWsException(locale.format(module, "cantLoadInput", "JSON"));
			}

			// special case where groups are not defined !!! 
			if (!this._grpsProvided()) {
				this._computeGroupsFromFlds();
			}

			this._checkGroups(this.wsCall.flow);
		}
		//
		if (this.wsCall.report.errors.length > 0) {
			this.wsCall.status = 0;
			throw new CvgWsException(locale.format(module, "cantLoadInput", "JSON"));
		}
		return this._sortParams();
	},
	_grpsProvided: function() {
		var grpKeys = Object.keys(this.wsCall.flow);
		for (var i = 0; i < grpKeys.length; i++) {
			// if at least one group doesn't exist, consider only FLD are passed and we should compute groups name
			if (!this._findDescrGroup(grpKeys[i], true)) return false;
		}
		return true;
	},
	_computeGroupsFromFlds: function() {
		var self = this;
		var fldNames = Object.keys(this.wsCall.flow);
		var grpMap = this._belongsToGrps(fldNames);
		var updatedFlow = {};
		forEachKey(grpMap, function(key, grpFlds) {
			updatedFlow[key] = updatedFlow[key] || {};
			grpFlds.forEach(function(fldKey) {
				updatedFlow[key][fldKey] = self.wsCall.flow[fldKey];
			});
		});
		this.wsCall.flow = updatedFlow;
	},
	_checkFields: function(parentNode, descrGrp, arrayIdx) {
		var self = this;
		var fldKeys = Object.keys(parentNode);
		// check field in flow and association with field in group in order to create parameter
		var _isArray = arrayIdx != null;

		function __replaceOldValue(fldName, val, idx) {
			var fld = {
				$: {
					NAM: fldName
				},
				$value: val
			};
			if (!arrayIdx && idx) {
				// that means this is LST and not TAB !!!
				fld.$.isITM = true;
			}
			self._replaceOldValue(fld, descrGrp, arrayIdx || idx);
		}
		fldKeys && fldKeys.forEach(function(fldName) {
			if (Array.isArray(parentNode[fldName])) {
				parentNode[fldName].forEach(function(val, idx) {
					__replaceOldValue(fldName, val, idx + 1);
				});
			} else {
				__replaceOldValue(fldName, parentNode[fldName]);
			}
		});

		if (_isArray && this.wsCall.action !== "EXEC") {
			var _paramTabNb = self.paramsMap[self._findIndexField(descrGrp.$.IDTAB, self.paramsMap)];
			if (_paramTabNb.nb > 0) {
				_paramTabNb.resu = arrayIdx > _paramTabNb.resu + 1 ? arrayIdx : _paramTabNb.resu + 1;
			} else {
				_paramTabNb.nb = 1;
				_paramTabNb.resu = arrayIdx > 1 ? arrayIdx : 1;
			}
		}
	},
	_checkGroups: function(paramNode) {
		var self = this;
		var grpKeys = Object.keys(paramNode);
		// check if the group exists in the description and analyse all field to create a param
		grpKeys && grpKeys.forEach(function(key) { // check if the group exists in the
			var grp = paramNode[key];
			var descrGrp = self._findDescrGroup(key);
			if (descrGrp) {
				var isArray = Array.isArray(grp);
				// This function checks groups and tables (not like for XML)
				if (descrGrp.$.DIM && descrGrp.$.DIM > 1 && !isArray) {
					self.wsCall.report.addError(locale.format(module, "grpDimGtJson", descrGrp.$.NAM));
				} else if (descrGrp.$.DIM && descrGrp.$.DIM === 1 && isArray) {
					self.wsCall.report.addError(locale.format(module, "tabDimEqJson", descrGrp.$.NAM));
				}
				if (isArray) {
					self._checkLines(grp, descrGrp);
				} else {
					self._checkFields(grp, descrGrp);
				}
			}
		});
	},
	_checkLines: function(tabNode, descrGrp) {
		var self = this;
		var linKeys = Object.keys(tabNode);
		// check if the group exists in the description and analyse all field to create a param
		linKeys && linKeys.forEach(function(key, num) {
			var lin = tabNode[key];
			self._checkFields(lin, descrGrp, num + 1);
		});
	}
});