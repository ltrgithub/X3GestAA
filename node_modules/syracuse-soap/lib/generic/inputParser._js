"use strict";
var helpers = require('syracuse-core').helpers;
var jsxml = require('js-xml');
var locale = require('streamline-locale');
var CvgWsException = require("syracuse-x3/lib/clients/soap/CvgWsException").CvgWsException;
var forEachKey = helpers.object.forEachKey;


var mapTypeToResu = {
	Decimal: "DCB",
	Char: "STRU",
	Integer: "INT",
	Blob: "BLOB",
	Date: "DATE",
	Clob: "CLOB"
		// TODO add other type

};

var allowedChildren = {
	PARAM: ["GRP", "TAB", "FLD", "LST"],
	GRP: ["FLD", "LST"],
	TAB: ["LIN"],
	LIN: ["FLD"],
	FLD: []
};

var InputParser = helpers.defineClass(function(wsCall) {
	this.wsCall = wsCall;
	this.descriptionSub = this.wsCall.action === "LIST" ? this.wsCall.description.ADXKEY : this.wsCall.description.ADXDATA;
	this.paramsMap = this._getParamFieldInput();
}, null, {
	_sortParams: function() {
		var self = this;
		var paramsMapSorted = Object.keys(this.paramsMap).sort(function(a, b) {
			var ai = parseInt(a, 10);
			var bi = parseInt(b, 10);
			if (ai > bi) {
				return 1;
			} else if (ai === bi) {
				return 0;
			} else {
				return -1;
			}
		});
		var params = [];
		//console.log("params Sorted "+JSON.stringify(paramsMapSorted,null,2) );
		paramsMapSorted.forEach(function(k) {
			params.push(self.paramsMap[k]);
		});
		return params;
	},
	_getNodes: function(parent, nodeName) {
		return parent && parent[nodeName] ? (Array.isArray(parent[nodeName]) ? parent[nodeName] : [parent[nodeName]]) : [];
	},
	_getParamFieldInput: function() {
		var self = this;
		if (this.descriptionSub) {
			var currentidx = 12;
			var paramsInput = {};
			var grps = this._getNodes(this.descriptionSub, "GRP");
			grps.forEach(function(grp) {
				if (grp.$.DIM > 1 && self.wsCall.action !== "LIST" && self.wsCall.action !== "EXEC") { // add parameter with te idx
					paramsInput[currentidx] = {
						"index": currentidx,
						"grp": grp.$.NAM,
						"descr": grp.$.IDTAB,
						"dim": 1,
						"nb": 0,
						"size": 0,
						"typ": "INT",
					};
					currentidx++;
				}

				var flds = self._getNodes(grp, "FLD");
				flds.forEach(function(fld) {
					paramsInput[currentidx] = {
						"index": currentidx,
						"grp": grp.$.NAM,
						"descr": fld.$.NAM || fld.$.NAME,
						"dim": self.wsCall.action !== "LIST" ? fld.$.DIM || grp.$.DIM : self.wsCall.nb,
						"nb": 0,
						"size": fld.$.LEN || 0,
						"typ": mapTypeToResu[fld.$.TYP],
						"mod": fld.$.MOD
					};
					currentidx++;
				});
			});
			return paramsInput;
		}
	},
	// This function is really important. All the parameters map is built here !!!
	_replaceOldValue: function(fld, descrGrp, arrayIdx) {
		var _isArray = arrayIdx != null;
		var fldName = fld.$.NAM || fld.$.NAME;
		var isItm = fld.$.isITM;
		var descrFld = this._findDescrfield(fldName, descrGrp);
		if (descrFld) {
			var idx = this._findIndexField(fldName, descrGrp.$.NAM || descrGrp.$.NAME, this.paramsMap);
			var _value = fld.$value;
			var _len = fld.$value && (mapTypeToResu[descrFld.$.TYP] === "STRU" || mapTypeToResu[descrFld.$.TYP] === 'CLOB') ? fld.$value.length : 1;

			var defVal = this.forceDefaultValue(descrFld.$.TYP);
			if (_isArray) {
				_value = this.paramsMap[idx] && this.paramsMap[idx].resu && Array.isArray(this.paramsMap[idx].resu) ? this.paramsMap[idx].resu : [];
				for (var i = 0; i < arrayIdx; i++) {
					if (_value[i] == null) _value[i] = defVal;
				}
				_value.splice(arrayIdx - 1, 1, fld.$value || defVal);
				// ensure bigger size will be used in param
				_value.forEach(function(v) {
					if (v && v.length > _len) _len = v.length;
				});
				if (!isItm && _value.length > parseInt(descrGrp.$.DIM, 10)) {
					this.wsCall.report.addError("Line number out of range for field [" + descrGrp.$.NAM + ":" + fldName + "]. The rule to follow description is [" + descrGrp.$.DIM + ">= NumLine >=1].");
					throw new CvgWsException(locale.format(module, "cantLoadInput", ""));
				}
			} else if (!_value && descrFld.$.PAR === "Value" && descrFld.$.MOD === "Input") {
				_value = defVal;
				_len = _value.length;
			}
			// special case for JSON flow where ITM can be passed as simple element instead of array
			else if (!Array.isArray(_value) && descrFld.$ && descrFld.$.DIM && descrFld.$.DIM > 1) {
				isItm = true;
				_value = [_value];
			}

			// erase the previous parameter
			this.paramsMap[idx] = {
				"index": idx,
				"grp": descrGrp.$.NAM,
				"descr": fldName,
				"dim": isItm ? (descrFld.$.DIM || _value.length) : descrGrp.$.DIM,
				"nb": _isArray ? _value.length : (_value ? 1 : 0),
				"size": descrFld.$.LEN || _len,
				"typ": mapTypeToResu[descrFld.$.TYP],
				"resu": _value
			};
		}
	},
	_findDescrGroup: function(id, ignoreErr) {
		if (this.descriptionSub) {
			var grps = this._getNodes(this.descriptionSub, "GRP");
			var found = null;
			for (var i = 0; i < grps.length && !found; i++) {
				var grpName = grps[i].$.NAM || grps[i].$.NAME;
				found = grpName === id ? grps[i] : null;
				if (found) return found;
			}
		}
		if (ignoreErr) return false;
		this.wsCall.report.addError(locale.format(module, "nodeIdNotFound", id));
	},
	_findIndexField: function(fldName, grpName, map) {
		var fldIdx;
		var found = Object.keys(map).some(function(key) {
			var _found = map[key].descr === fldName && map[key].grp === grpName;
			if (_found) fldIdx = key;
			return _found;
		});
		if (found) return fldIdx;
		this.wsCall.report.addError(locale.format(module, "fldNotFound", fldName));
	},
	_findDescrfield: function(id, jsonDescrGrp) {
		if (jsonDescrGrp) {
			var flds = this._getNodes(jsonDescrGrp, "FLD");
			var found = null;
			for (var i = 0; i < flds.length && !found; i++) {
				var fldName = flds[i].$.NAM || flds[i].$.NAME;
				found = fldName === id ? flds[i] : null;
				if (found) return found;
			}
		}
		// ignore field not found when ends by _LBL --> Only needed for JSON parameters
		if (id.indexOf("_LBL") === id.length - 4) return false;
		this.wsCall.report.addError(locale.format(module, "fldIdNotFound", id, jsonDescrGrp.$.NAM));
	},
	// this function takes an array as parameter with FLD names : e.g. ["USR", "LOGIN", "PRFMEN"]
	// and return an object with GRP matches : {"AUS1_0": ["USR", "LOGIN"], "AUS1_1": ["PRFMEN"]}
	_belongsToGrps: function(fldNamesArr) {
		function checkFld(_fld, _grp) {
			var idx = fldNamesArr.indexOf(_fld.$.NAM);
			if (idx !== -1) {
				map[grp.$.NAM] = map[grp.$.NAM] || [];
				map[grp.$.NAM].push(_fld.$.NAM);
				fldNamesArr.splice(idx, 1);
				if (_grp.$.DIM != null && _grp.$.DIM > 1) {
					self.wsCall.report.addError(locale.format(module, "underRootForbidden", "FLD", _fld.$.NAM));
					return true;
				}
			}
		}
		//
		var self = this;
		var map = {};
		var grps = this._getNodes(this.descriptionSub, "GRP");
		for (var i = 0; i < grps.length; i++) {
			var grp = grps[i];
			if (grp.FLD) {
				if (Array.isArray(grp.FLD)) {
					for (var j = 0; j < grp.FLD.length; j++) {
						var fld = grp.FLD[j];
						if (checkFld(fld, grp)) return;
					}
				} else {
					if (checkFld(grp.FLD, grp)) return;
				}
			}
			if (fldNamesArr.length === 0) break;

		}
		// Do not display this message anymore, because it's not totally true regarding the parsing time
		//this.wsCall.addMessage(2, locale.format(module, "perfBetterWithGrp"));
		return map;
	},
	_setIdTabValue: function(descrGrp, arrayIdx) {
		if (arrayIdx != null && this.wsCall.action !== "EXEC") {
			var paramTabNb = this.paramsMap[this._findIndexField(descrGrp.$.IDTAB, descrGrp.$.NAM || descrGrp.$.NAME, this.paramsMap)];
			if (paramTabNb.nb > 0) {
				paramTabNb.resu = arrayIdx > paramTabNb.resu ? arrayIdx : paramTabNb.resu;
			} else {
				paramTabNb.nb = 1;
				paramTabNb.resu = arrayIdx > 1 ? arrayIdx : 1;
			}
			// console.log("_setIdTabValue paramTabNb:", arrayIdx, paramTabNb);
		}
	},
	forceDefaultValue: function(type) {
		switch (type) {
			case "Decimal":
			case "Integer":
				return "0";
			case "Date":
				return "[0/0/0]";
			case "Blob":
			case "Clob":
			case "Char":
				return "";
			default:
				return;
		}
	}
});

exports.InputParserXml = helpers.defineClass(function(wsCall) {
	InputParser.call(this, wsCall);
}, InputParser, {
	parse: function() {
		if (this.wsCall.flow) { // put the value the parameter that have value
			try {
				if (typeof this.wsCall.flow !== "object") this.wsCall.flow = jsxml.parse(this.wsCall.flow);
			} catch (e) {
				console.error("Error jsxml parse: " + e.stack);
				console.error("Received flow: " + JSON.stringify(this.wsCall.flow));
				this.wsCall.status = 0;
				throw new CvgWsException(locale.format(module, "cantLoadInput", "XML"));
			}
			if (this.wsCall.flow.PARAM == null) this.wsCall.report.addError(locale.format(module, "noParamTag"));
			this._checkAllowedNodes("PARAM", this.wsCall.flow.PARAM);

			// special cases where GRP are not here !!!
			if (this.wsCall.flow.PARAM.FLD) {
				if (!Array.isArray(this.wsCall.flow.PARAM.FLD)) this.wsCall.flow.PARAM.FLD = [this.wsCall.flow.PARAM.FLD];
				this._computeGroupsFromChildren("FLD");
			}
			if (this.wsCall.flow.PARAM.LST) {
				if (!Array.isArray(this.wsCall.flow.PARAM.LST)) this.wsCall.flow.PARAM.LST = [this.wsCall.flow.PARAM.LST];
				this._computeGroupsFromChildren("LST");
			}
			//
			this._checkGroups(this.wsCall.flow.PARAM);
			this._checkTables(this.wsCall.flow.PARAM);
		}
		//
		if (this.wsCall.report.errors.length > 0) {
			this.wsCall.status = 0;
			throw new CvgWsException(locale.format(module, "cantLoadInput", "XML"));
		}
		return this._sortParams();
	},
	_computeGroupsFromChildren: function(type) {
		var self = this;
		var eltNames = this.wsCall.flow.PARAM[type].map(function(elt) {
			if (!elt.$ || (!elt.$.NAME && !elt.$.NAM)) throw new CvgWsException(locale.format(module, "nameManadatoryOnFld"));
			return elt.$.NAME || elt.$.NAM;
		});
		var grpMap = this._belongsToGrps(eltNames);

		// prepare GRP object
		if (this.wsCall.flow.PARAM.GRP && !Array.isArray(this.wsCall.flow.PARAM.GRP)) {
			this.wsCall.flow.PARAM.GRP = [this.wsCall.flow.PARAM.GRP];
		} else {
			this.wsCall.flow.PARAM.GRP = this.wsCall.flow.PARAM.GRP || [];
		}

		forEachKey(grpMap, function(key, grpElts) {
			var elts = [];
			self.wsCall.flow.PARAM[type].forEach(function(elt, idx) {
				if (grpElts.indexOf(elt.$.NAME || elt.$.NAM) !== -1) {
					elts.push(elt);
					delete self.wsCall.flow.PARAM[type][idx];
				}
			});
			var grp = {
				$: {
					ID: key
				}
			};
			grp[type] = elts;
			self.wsCall.flow.PARAM.GRP.push(grp);
		});
		delete self.wsCall.flow.PARAM[type];
	},
	_checkAllowedNodes: function(type, node) {
		var self = this;
		if (node && typeof node === "object") {
			Object.keys(node).forEach(function(n) {
				if (n !== '$' && allowedChildren[type].indexOf(n) === -1) {
					self.wsCall.report.addError(locale.format(module, "nodeLocForbidden", n, type));
				}
			});
		}
	},
	_checkFields: function(parentNode, descrGrp, arrayIdx, nodeNameToCheck) {
		var self = this;
		var flds = this._getNodes(parentNode, nodeNameToCheck || "FLD");
		// check field in flow and association with field in group in order to create parameter

		flds && flds.forEach(function(fld) {
			self._replaceOldValue(fld, descrGrp, arrayIdx);
		});

		// manage LST
		var lsts = this._getNodes(parentNode, "LST");
		lsts && lsts.forEach(function(lst) {
			var itms = self._getNodes(lst, "ITM");
			itms && itms.forEach(function(value, idx) {
				var itm = {
					$: {
						isITM: true,
						NAME: lst.$ && lst.$.NAME,
						SIZE: lst.$ && lst.$.SIZE,
						TYPE: lst.$ && lst.$.TYPE
					},
					$value: value
				};
				self._replaceOldValue(itm, descrGrp, idx + 1);
			});
		});

		this._setIdTabValue(descrGrp, arrayIdx);
	},
	_checkGroups: function(paramNode) {
		var self = this;
		var grps = this._getNodes(paramNode, "GRP");
		// check if the group exists in the description and analyse all field to create a param
		grps && grps.forEach(function(grp) { // check if the group exists in the
			if (!grp.$ || !grp.$.ID) {
				self.wsCall.report.addError(locale.format(module, "noIdInGrp"));
				return;
			}
			var descrGrp = self._findDescrGroup(grp.$.ID);
			if (descrGrp) {
				if (descrGrp.$.DIM && descrGrp.$.DIM > 1) {
					self.wsCall.report.addError(locale.format(module, "grpDimGtXml", descrGrp.$.NAM));
				}
				self._checkAllowedNodes("GRP", grp);
				self._checkFields(grp, descrGrp);
			}
		});
	},
	_checkLines: function(tabNode, descrGrp) {
		var self = this;
		var lins = this._getNodes(tabNode, "LIN");
		// check if the group exists in the description and analyse all field to create a param
		lins && lins.forEach(function(lin, idx) {
			var num = lin.$ && lin.$.NUM ? parseInt(lin.$.NUM, 10) : (idx + 1);
			self._checkAllowedNodes("LIN", lin);
			self._checkFields(lin, descrGrp, num);
		});
	},
	_checkTables: function(paramNode) {
		var self = this;
		var tabs = this._getNodes(paramNode, "TAB");
		// check if the group exists in the description and analyse all field to create a param
		tabs && tabs.forEach(function(tab) {
			var descrGrp = self._findDescrGroup(tab.$.ID);
			if (descrGrp) {
				if (descrGrp.$.DIM && descrGrp.$.DIM === 1) {
					self.wsCall.report.addError(locale.format(module, "tabDimEqXml", descrGrp.$.NAM));
				}
				self._checkAllowedNodes("TAB", tab);
				self._checkLines(tab, descrGrp);
				var nblig = tab.$.NBLIG;
				if (nblig != null) self._setIdTabValue(descrGrp, nblig);
			}
		});
	},
});


exports.InputParserJson = helpers.defineClass(function(wsCall) {
	InputParser.call(this, wsCall);
}, InputParser, {
	parse: function() {
		if (this.wsCall.flow) { // put the value the parameter that have value
			try {
				if (typeof this.wsCall.flow !== "object") this.wsCall.flow = JSON.parse(this.wsCall.flow);
			} catch (e) {
				console.error("Error json parse: " + e.stack);
				console.error("Received flow: " + JSON.stringify(this.wsCall.flow));
				this.wsCall.status = 0;
				throw new CvgWsException(locale.format(module, "cantLoadInput", "JSON"));
			}

			// special case where groups are not defined !!! 
			if (!this._grpsProvided()) {
				this._computeGroupsFromFlds();
			}

			this._checkGroups(this.wsCall.flow);
		}
		//
		if (this.wsCall.report.errors.length > 0) {
			this.wsCall.status = 0;
			throw new CvgWsException(locale.format(module, "cantLoadInput", "JSON"));
		}
		return this._sortParams();
	},
	_grpsProvided: function() {
		var grpKeys = Object.keys(this.wsCall.flow);
		for (var i = 0; i < grpKeys.length; i++) {
			// if at least one group doesn't exist, consider only FLD are passed and we should compute groups name
			if (!this._findDescrGroup(grpKeys[i], true)) return false;
		}
		return true;
	},
	_computeGroupsFromFlds: function() {
		var self = this;
		var fldNames = Object.keys(this.wsCall.flow);
		var grpMap = this._belongsToGrps(fldNames);
		var updatedFlow = {};
		forEachKey(grpMap, function(key, grpFlds) {
			updatedFlow[key] = updatedFlow[key] || {};
			grpFlds.forEach(function(fldKey) {
				updatedFlow[key][fldKey] = self.wsCall.flow[fldKey];
			});
		});

		// if some keys were no FLD but real GRP, we must take them back
		if (fldNames.length > 0) {
			fldNames.forEach(function(key) {
				updatedFlow[key] = self.wsCall.flow[key];
			});

		}

		this.wsCall.flow = updatedFlow;
	},
	_checkFields: function(parentNode, descrGrp, arrayIdx) {
		var self = this;
		var fldKeys = parentNode && Object.keys(parentNode);
		// check field in flow and association with field in group in order to create parameter

		function __replaceOldValue(fldName, val, idx) {
			var fld = {
				$: {
					NAM: fldName
				},
				$value: val
			};
			if (!arrayIdx && idx) {
				// that means this is LST and not TAB !!!
				fld.$.isITM = true;
			}
			self._replaceOldValue(fld, descrGrp, arrayIdx || idx);
		}
		fldKeys && fldKeys.forEach(function(fldName) {
			if (Array.isArray(parentNode[fldName])) {
				parentNode[fldName].forEach(function(val, idx) {
					__replaceOldValue(fldName, val, idx + 1);
				});
			} else {
				__replaceOldValue(fldName, parentNode[fldName]);
			}
		});

		this._setIdTabValue(descrGrp, arrayIdx);
	},
	_checkGroups: function(paramNode) {
		var self = this;
		var grpKeys = Object.keys(paramNode);
		// check if the group exists in the description and analyse all field to create a param
		grpKeys && grpKeys.forEach(function(key) { // check if the group exists in the
			var grp = paramNode[key];
			var descrGrp = self._findDescrGroup(key);
			if (descrGrp) {
				var isArray = Array.isArray(grp);
				// This function checks groups and tables (not like for XML)
				if (descrGrp.$.DIM && descrGrp.$.DIM > 1 && !isArray) {
					self.wsCall.report.addError(locale.format(module, "grpDimGtJson", descrGrp.$.NAM));
				} else if (descrGrp.$.DIM && descrGrp.$.DIM === 1 && isArray) {
					self.wsCall.report.addError(locale.format(module, "tabDimEqJson", descrGrp.$.NAM));
				}
				if (isArray) {
					self._checkLines(grp, descrGrp);
				} else {
					self._checkFields(grp, descrGrp);
				}
			}
		});
	},
	_checkLines: function(tabNode, descrGrp) {
		var self = this;
		var linKeys = Object.keys(tabNode);
		// check if the group exists in the description and analyse all field to create a param
		linKeys && linKeys.forEach(function(key, num) {
			var lin = tabNode[key];
			self._checkFields(lin, descrGrp, num + 1);
		});
	}
});