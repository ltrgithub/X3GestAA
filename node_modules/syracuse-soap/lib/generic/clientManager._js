"use strict";

var flows = require('streamline/lib/util/flows');
var ez = require('ez-streams');
var helpers = require("syracuse-core/lib/helpers");
var CvgClientWS = require('syracuse-x3/lib/clients/soap/CvgClientWS').CvgClientWS;
var tracer = require("syracuse-trace/lib/helper").getTracer("soap-generic.pool");

// CLIENTS WEIGHTS :
var W_CONNECTED = 4;
var W_USER = 2;
var W_LANG = 1;
//CvgWSClient are kept in memory here !!!
var managers = {};

var createClient = function(_, context, wsCall) {
	var newCli;
	// special condition for unit tests
	if (context && context.request && context.request.headers && context.request.headers.unittest) { // for unit test 
		var headerParts = context.request.headers.unittest.split('~');
		var recMode = headerParts[0],
			fileName = headerParts[1];
		var recOptions = {
			path: "node_modules/syracuse-soap/test/data/generic/dispatch",
			recMode: recMode,
			fileName: fileName + ".json"
		};
		if (recOptions.recMode === "REC") recOptions.overwrite = true; // always override file
		newCli = new CvgClientWS().init(_, context, wsCall, recOptions);
	} else {
		newCli = new CvgClientWS().init(_, context, wsCall);
	}
	tracer.debug && tracer.debug("New client created: " + newCli.uuid);
	//clients[newCli.uuid] = newCli;
	return newCli;
};

exports.getManager = function(dataset) {
	return managers[dataset];
};

exports.ClientManager = helpers.defineClass(function(options) {
	this.dataset = options.dataset;
	this.queueSize = options.queueSize || 1000;
	this.poolSize = options.poolSize || 100;
	this.q = ez.devices.queue({
		max: options.queueSize,
	});
	this.readFunnel = flows.funnel(1);
	this.createFunnel = flows.funnel(options.poolSize);
	this.created = 0;
	this.avail = 0;
	console.error("Create client manager for dataset: " + this.dataset);
	managers[this.dataset] = this;
}, null, {
	alloc: function(_, context, wsCall) {
		function sameUser(cli) {
			return cli.cliCfg.login === wsCall.context.user.login;
		}

		function sameLang(cli) {
			return cli.cliCfg.x3Lang === wsCall.context.x3Lang;
		}

		function computeWeight(cli) {
			var weight = 0;
			weight += cli.isConnected ? W_CONNECTED : 0;
			weight += sameUser(cli) ? W_USER : 0;
			weight += sameLang(cli) ? W_LANG : 0;
		}
		// this will be used before read on queue when implemented
		function sort(cliA, cliB) {
			return computeWeight(cliA) - computeWeight(cliB);
		}

		var self = this;
		var res = this.readFunnel(_, function(_) {
			// Wait for pool ends
			wsCall.techInfo.poolWaitDuration.stop();
			wsCall.techInfo.poolDistribDuration.start();
			tracer.debug && tracer.debug("Nb clients available: " + self.avail);
			if (self.avail > 0) {
				tracer.debug && tracer.debug("Reuse free client");
				self.avail--;
				return self.q.read(_);
			} else if (self.created < self.poolSize) {
				self.created++;
				return createClient(!_, context, wsCall);
			} else {
				tracer.debug && tracer.debug("Max clients reached: wait for free one");

				self.avail--;
				return self.q.read(_);
			}
		});
		if (typeof res === "function") {
			res = this.createFunnel(_, function(_) {

				return res(_);
			});
		}
		return res;
	},
	free: function(res) {
		this.avail++;
		this.q.put(res);
	},
});