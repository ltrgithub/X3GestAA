"use strict";

var globals = require('streamline-runtime').globals;
var locale = require('streamline-locale');
var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var nannyHelper = require("syracuse-soap/lib/generic/nannyHelper");
var poolManager = require("syracuse-soap/lib/generic/poolManager");
var ClientPool = poolManager.ClientPool;
var currentProtocol = require("syracuse-x3/lib/convergence/automata/x3Descriptors").CURRENTPROTOCOL;
var tracer; // = console.error;
var lbMode = (process.argv[2] && (process.argv[2].substr(0, 1) === "W" || process.argv[2].substr(0, 1) === "N"));

var multiTenant = null;

function _multiTenant() {
	if (multiTenant === null) {
		var config = require('config');
		multiTenant = (config.hosting && config.hosting.multiTenant);
	}
	return multiTenant;
}

function getX3FolderLangs(_, db) {
	var x3folderIsoLangs = [];
	var tablanQuery = db.getEntity(_, "TABLAN", "$query");
	var tablan = db.fetchInstances(_, tablanQuery, {
		sdataWhere: "LANISO ne '' and LANCON eq true"
	});
	tablan && tablan.forEach_(_, function(_, f) {
		x3folderIsoLangs.push(f.LANISO(_));
	});
	return x3folderIsoLangs;
}
exports.entity = {
	$titleTemplate: "Pool configuration: {alias}",
	$helpPage: "Administration-reference_SoapClassicPool",
	$valueTemplate: "{alias}",
	$properties: {
		alias: {
			$title: "Alias",
			$isMandatory: true,
			$isUnique: true,
			$pattern: "^[-\\w]+$",
			$linksToDetails: true,
		},
		maxSize: {
			$title: "Maximum size",
			$type: "integer",
			$isMandatory: true,
			$default: 0
		},
		initSize: {
			$title: "Initialization size",
			$type: "integer",
			$isMandatory: true,
			$default: 0
		},
		autoStart: {
			$title: "Auto start",
			$type: "boolean",
			$isHidden: function(_, instance) {
				return _multiTenant();
			},
			$default: false,
		},
		autoStartDisabled: {
			$title: "Stopped manually",
			$type: "boolean",
			$isHidden: function(_, instance) {
				return _multiTenant();
			},
			$isNullable: true,
			$default: false,
		},
		x3serverTags: {
			$title: "X3 server TAGS",
			$description: "Tags can be used to prefer some X3 process server defined in X3 solution"
		},
		protocolVersion: {
			$title: "Protocol version to use",
			$description: "Protocol version to use"
		}
	},
	$relations: {
		endpoint: {
			$title: "Endpoint",
			$type: "endPoint",
			$isMandatory: true
		},
		localePref: {
			$title: "Locale",
			$type: "localePreference",
			$isMandatory: true,
			$lookupFilter: function(_, instance) {
				var ep = instance.endpoint(_);
				var filter;
				var x3IsoLangs = [];
				if (ep) {
					var db = ep.getOrm(_);
					try {
						x3IsoLangs = getX3FolderLangs(_, db);
						x3IsoLangs.forEach_(_, function(_, l) {
							filter = filter || {
								$or: []
							};
							filter.$or.push({
								"code": l
							});
						});
					} catch (e) {
						console.error(locale.format(module, "repAdossierMissing", ep.dataset(_), e.message));
					}
				} else {
					filter = {
						code: {
							$in: []
						}
					};
				}
				return filter;
			}
		},
		user: {
			$title: "User",
			$type: "user",
			$isMandatory: true
		}
	},
	$functions: {
		getPool: function(_, start, noerror) {
			var pool = poolManager.getPool(this.alias(_));
			if (!pool) {
				if (start) {
					pool = new ClientPool();
				} else {
					if (noerror) return undefined;
					throw new Error("Pool is not initialized");
				}
			}
			return pool;
		},
		// Future for server startup
		startAuto: function(_, force) {
			this.getPool(_, true).start(!_, force, globals.context, this);
		},
		// Used for multi tenant mode
		startSync: function(_) {
			this.getPool(_, true).start(_, true, globals.context, this, true);
		},
		// No future for service invocation
		start: function(_, force, context) {
			return this.getPool(_, true).start(_, force, context, this);
		},
		stop: function(_, context) {
			// stop all clients
			return this.getPool(_).stop(_, context, true);
		},
		getInfos: function(_) {
			var pool = this.getPool(_, false, true);
			if (pool) return pool.getInfo();
			else return {
				alias: this.alias(_),
				started: false,
				autoStart: this.autoStart(_),
				autoStartDisabled: this.autoStartDisabled(_),
				initSize: this.initSize(_),
				maxSize: this.maxSize(_),
				created: 0,
				available: 0,
				channels: [],
				init: false
			};

		},
	},
	$services: {
		start: {
			$title: "Start/Update",
			$isMethod: true,
			$method: "POST",
			$invocationMode: "async",
			$isDisabled: function(_, instance) {
				return _multiTenant();
			},
			$execute: function(_, context, instance, parameters) {
				var t = context && context.tracker;
				instance.$diagnoses = instance.$diagnoses || [];
				if (t) {
					t.$diagnoses = t.$diagnoses || instance.$diagnoses;
				}
				if (lbMode) {
					var result = nannyHelper._propagate(_, instance, "POST", "update", {
						uuid: instance.$uuid
					});
					tracer && tracer("update pool: " + JSON.stringify(result, null, 2));
					nannyHelper._parseDiagnoses(instance, result);
				} else {
					instance.start(_, true, context);
				}
			}
		},
		stop: {
			$title: "Stop",
			$isMethod: true,
			$method: "POST",
			$invocationMode: "async",
			$execute: function(_, context, instance, parameters) {
				var t = context && context.tracker;
				instance.$diagnoses = instance.$diagnoses || [];
				if (t) {
					t.$diagnoses = t.$diagnoses || instance.$diagnoses;
				}
				if (lbMode) {
					var result = nannyHelper._propagate(_, instance, "POST", "stop", {
						uuid: instance.$uuid
					});
					tracer && tracer("stop pool: " + JSON.stringify(result, null, 2));
					nannyHelper._parseDiagnoses(instance, result);
				} else {
					instance.stop(_, context);
				}
			},
		},
		getState: {
			$method: "GET",
			$isMethod: true,
			$title: "Status",
			$parameters: {
				$url: "{$baseUrl}/soapClassicPoolStatuses/$template/$workingCopies?representation=soapClassicPoolStatus.$edit&uuid={$uuid}&alias={alias}",
				$method: "POST",
				$properties: {
					uuid: {
						$type: "application/x-string"
					},
					alias: {
						$type: "application/x-string"
					},
				}
			},
			$execute: function(_, context, instance) {
				// Do nothing
			},
		},

	},
	$events: {
		$beforeSave: [

			function(_, instance) {

				instance.$diagnoses = instance.$diagnoses || [];
				if (instance.maxSize(_) < instance.initSize(_)) {
					instance.$diagnoses.push({
						$severity: "warning",
						$message: locale.format(module, "maxSizeLtInitSize")
					});
					instance.initSize(_, instance.maxSize(_));
				}
			}
		],
		$afterSave: [

			function(_, instance) {
				if (_multiTenant()) return; // in multi tenant mode, pool will be initialized by the request itself calling tryInitializePool behind

				if (instance.autoStart(_) && !instance.autoStartDisabled(_)) {
					instance.startAuto(_);
				}
			}
		],
	},
};

//fetch soapClassicPool instance by $uuid
function _fetchPool(_, uuid) {
	if (!uuid) throw new Error("No uuid for fetching soapClassicPool " + uuid);

	var db = adminHelper.getCollaborationOrm(_);
	var instance = db.fetchInstance(_, db.model.getEntity(_, "soapClassicPool"), {
		jsonWhere: {
			$uuid: uuid
		}
	});
	// console.log("Fetch "+uuid+" "+instance);
	if (!instance) throw new Error("Wrong uuid " + uuid);
	return instance;
}

exports.updateExternal = function(_, uuid) {
	return _fetchPool(_, uuid).start(_, true);
};

exports.stopExternal = function(_, uuid) {
	return _fetchPool(_, uuid).stop(_);
};

exports.getInfosExternal = function(_, uuid) {
	return _fetchPool(_, uuid).getInfos(_);
};