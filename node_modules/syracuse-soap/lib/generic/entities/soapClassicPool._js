"use strict";

var globals = require('streamline/lib/globals');
var locale = require("syracuse-core/lib/locale");
var helpers = require('syracuse-core/lib/helpers');
var forEachKey = helpers.object.forEachKey;
var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var nannyHelper = require("syracuse-soap/lib/generic/nannyHelper");
var poolManager = require("syracuse-soap/lib/generic/poolManager");
var ClientPool = poolManager.ClientPool;

var tracer = console.error;
var lbMode = (process.argv[2] && (process.argv[2].substr(0, 1) === "W" || process.argv[2].substr(0, 1) === "N"));

exports.entity = {
	$titleTemplate: "Pool configuration: {alias}",
	$valueTemplate: "{alias}",
	$properties: {
		alias: {
			$title: "Alias",
			$isMandatory: true,
			$isUnique: true,
			$pattern: "^[-\\w]+$",
			$linksToDetails: true,
		},
		maxSize: {
			$title: "Maximum size",
			$type: "integer",
			$isMandatory: true,
			$default: 0
		},
		initSize: {
			$title: "Initialization size",
			$type: "integer",
			$isMandatory: true,
			$default: 0
		},
		autoStart: {
			$title: "Auto start",
			$type: "boolean",
			$default: false,
		},
		x3serverTags: {
			$title: "X3 server TAGS",
			$description: "Tags can be used to prefer some X3 process server defined in X3 solution"
		}
	},
	$relations: {
		endpoint: {
			$title: "Endpoint",
			$type: "endPoint",
			$isMandatory: true
		},
		localePref: {
			$title: "Locale",
			$type: "localePreference",
			$isMandatory: true
		},
		user: {
			$title: "User",
			$type: "user",
			$isMandatory: true
		}
	},
	$functions: {
		getPool: function(_, start) {
			var pool = poolManager.getPool(this.alias(_));
			if (!pool) {
				if (start) {
					pool = new ClientPool();
				} else {
					throw new Error("Pool is not initialized");
				}
			}
			return pool;
		},
		// Future for server startup
		startAuto: function(_, force) {
			this.getPool(_, true).start(!_, force, globals.context, this);
		},
		// No future for service invocation
		start: function(_, force, context) {
			return this.getPool(_, true).start(_, force, context, this);
		},
		stop: function(_, context) {
			// stop all clients
			return this.getPool(_).stop(_, context, true);
		},
		getInfos: function(_) {
			return this.getPool(_).getInfo();
		}
	},
	$services: {
		start: {
			$title: "Start/Update",
			$isMethod: true,
			$method: "POST",
			$invocationMode: "async",
			$execute: function(_, context, instance, parameters) {
				var t = context && context.tracker;
				instance.$diagnoses = instance.$diagnoses || [];
				if (t) {
					t.$diagnoses = t.$diagnoses || instance.$diagnoses;
				}
				if (lbMode) {
					var result = nannyHelper._propagate(_, "POST", "update", {
						uuid: instance.$uuid
					});
					//tracer && tracer("update pool: " + JSON.stringify(result,null,2));
					forEachKey(result, function(port, diags) {
						diags.forEach(function(d) {
							instance.$diagnoses.push({
								$severity: d.$severity,
								$message: port + " : " + d.$message,
								$exception: d.$exception
							});
						});
					});
				} else {
					instance.start(_, true, context);
				}
			}
		},
		stop: {
			$title: "Stop",
			$isMethod: true,
			$method: "POST",
			$invocationMode: "async",
			$execute: function(_, context, instance, parameters) {
				var t = context && context.tracker;
				instance.$diagnoses = instance.$diagnoses || [];
				if (t) {
					t.$diagnoses = t.$diagnoses || instance.$diagnoses;
				}
				if (lbMode) {
					var result = nannyHelper._propagate(_, "POST", "stop", {
						uuid: instance.$uuid
					});
					tracer && tracer("stop pool: " + JSON.stringify(result, null, 2));
					forEachKey(result, function(port, diags) {
						diags.forEach(function(d) {
							instance.$diagnoses.push({
								$severity: d.$severity,
								$message: port + " : " + d.$message,
								$exception: d.$exception
							});
						});
					});
				} else {
					instance.stop(_, context);
				}
			},
		},
		getState: {
			$method: "GET",
			$isMethod: true,
			$title: "Status",
			$parameters: {
				$url: "{$baseUrl}/soapClassicPoolStatuses/$template/$workingCopies?representation=soapClassicPoolStatus.$edit&uuid={$uuid}&alias={alias}",
				$method: "POST",
				$properties: {
					uuid: {
						$type: "application/x-string"
					},
					alias: {
						$type: "application/x-string"
					},
				}
			},
			$execute: function(_, context, instance) {
				// Do nothing
			},
		},

	},
	$events: {
		$beforeSave: [

			function(_, instance) {

				instance.$diagnoses = instance.$diagnoses || [];
				if (instance.maxSize(_) < instance.initSize(_)) {
					instance.$diagnoses.push({
						$severity: "warning",
						$message: locale.format(module, "maxSizeLtInitSize")
					});
					instance.initSize(_, instance.maxSize(_));
				}
			}
		]
	},
};

//fetch soapClassicPool instance by $uuid
function _fetchPool(_, uuid) {
	if (!uuid) throw new Error("No uuid for fetching soapClassicPool " + uuid);

	var db = adminHelper.getCollaborationOrm(_);
	var instance = db.fetchInstance(_, db.model.getEntity(_, "soapClassicPool"), {
		jsonWhere: {
			$uuid: uuid
		}
	});
	// console.log("Fetch "+uuid+" "+instance);
	if (!instance) throw new Error("Wrong uuid " + uuid);
	return instance;
}

exports.updateExternal = function(_, uuid) {
	return _fetchPool(_, uuid).start(_, true);
};

exports.stopExternal = function(_, uuid) {
	return _fetchPool(_, uuid).stop(_);
};

exports.getInfosExternal = function(_, uuid) {
	return _fetchPool(_, uuid).getInfos(_);
};