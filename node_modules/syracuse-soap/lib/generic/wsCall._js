"use strict";
var helpers = require('syracuse-core/lib/helpers');
var outputBuilder = require('./outputBuilder');
var OutputBuilderXml = outputBuilder.OutputBuilderXml;
var OutputBuilderJson = outputBuilder.OutputBuilderJson;
var inputParser = require('./inputParser');
var InputParserXml = inputParser.InputParserXml;
var InputParserJson = inputParser.InputParserJson;
var TechInfo = require('syracuse-soap/lib/generic/techInfo').TechInfo;

var tracer = require("syracuse-trace/lib/helper").getTracer("soap-generic.ackcall");

exports.WsCall = helpers.defineClass(function() {
	// will be computed !
	this.description = null;
	this.callParams = null;
	this.status = 1;
	this.result = null; // reply of the ack_call;
	this.messages = [];

	this.techInfo = new TechInfo();
	this.report = this.techInfo.processReport;
}, null, {
	init: function(params, requestConfig) {
		// manage params
		this.name = params.name;
		this.flow = params.flow;
		this.action = params.action;
		this.wtrace = params.trace;
		// for object or list
		this.itemKeys = params.wkeys; // for CRUD and list, criteria or keys elements
		this.wkeys = ""; // string that represent the key
		this.nb = params.nb; // for list action , number of elements
		this.debugInfo = params.debugInfo;
		// for action inslig or suplig
		this.tab = params.tab; //blocKey
		this.par = params.par; // lineKey

		// manage requestConfig
		this.requestConfig = requestConfig || {};

		this.format = this.requestConfig["adxwss.optreturn"] && this.requestConfig["adxwss.optreturn"].toLowerCase() === "json" ? "JSON" : "XML";
		this.inputFormat = this.flow && this.flow.indexOf('<') === 0 ? "XML" : "JSON";

		this.wsTraces = this.requestConfig["adxwss.trace.on"] && this.requestConfig["adxwss.trace.on"].toLowerCase() === "on";
		this.adxTraces = this.requestConfig["adonix.trace.on"] && this.requestConfig["adonix.trace.on"].toLowerCase() === "on";

		this.beautify = this.requestConfig["adxwss.beautify"] === "true";

		var reqId = this.requestConfig["adxwss.requestid"] || helpers.uuid.generate('-');
		this.adapiPub = ["adxwss.requestid=" + reqId];
		if (this.wsTraces && this.adxTraces) {
			this.adapiPub.push("adonix.trace.on=" + this.requestConfig["adonix.trace.on"]);
			if (this.requestConfig["adonix.trace.size"]) this.adapiPub.push("adonix.trace.size=" + this.requestConfig["adonix.trace.size"]);
			if (this.requestConfig["adonix.trace.level"]) this.adapiPub.push("adonix.trace.level=" + this.requestConfig["adonix.trace.level"]);
		}

		this._traceRequestSummary();
		return this;
	},
	_traceRequestSummary: function() {
		if (this.wsTraces) {
			this.addWsTrace("info", "### Begin Request summary");
			this.addWsTrace("info", "*** request config: \r\n" + JSON.stringify(this.requestConfig, null, 2));
			this.addWsTrace("info", "*** Object keys: [nb:" + (this.itemKeys != null ? this.itemKeys.length : 0) + "]\r\n" + JSON.stringify(this.itemKeys, null, 2));
			this.addWsTrace("info", "*** Line keys: [nb:" + (this.par != null ? this.par.length : 0) + "]" + (this.par ? "\r\n" + JSON.stringify(this.par, null, 2) : ""));
			this.addWsTrace("info", "*** Block key: [nb:" + (this.tab != null ? 1 : 0) + "]" + (this.tab ? "\r\n" + JSON.stringify(this.tab, null, 2) : ""));

			this.addWsTrace("info", "### End Request summary\r\n");

		}
	},
	addMessage: function(type, message) {
		this.messages.push({
			type: type,
			message: message
		});
	},
	addWsTrace: function(level, trace) {
		if (this.wsTraces) this.techInfo.traceRequest.addLine(trace);
	},
	_handleTechParams: function(params) {
		var techParamsMap = [];
		params.forEach(function(p) {
			if (p.num != null) {
				techParamsMap[p.num] = techParamsMap[p.num] || {};
				techParamsMap[p.num][p.poste] = p;
			}
		});
		tracer.debug && tracer.debug("Technical parameters: " + JSON.stringify(techParamsMap, null, 2));

		// Manage messages
		if (techParamsMap[3] && techParamsMap[4]) {
			for (var i = 0; i < Object.keys(techParamsMap[3]).length; i++) {
				this.addMessage(techParamsMap[3][i].resu, techParamsMap[4][i].resu);
			}
		}
	},
	computeResult: function(params) {
		var self = this;

		function getParamFieldOutputXml(resultParamMap) {
			//tracer.debug && tracer.debug("Data in description: " + JSON.stringify(descripData, null, 2));
			//tracer.debug && tracer.debug("Params: " + JSON.stringify(resultParamMap, null, 2));
			var _outputBuilder;
			if (self.format === "JSON") {
				_outputBuilder = new OutputBuilderJson(self, resultParamMap);
				return _outputBuilder.build();
			} else {
				_outputBuilder = new OutputBuilderXml(self, resultParamMap);
				return _outputBuilder.build();
			}
		}
		//
		if (!this.result) {
			// create a map with num (correspond to index) as a id in order to match the description
			var resParamsMap = [];
			params.forEach(function(p) {
				if (p && p.num != null) {
					resParamsMap[p.num] = resParamsMap[p.num] || {};
					resParamsMap[p.num][p.poste] = p;
				} else if (p && p.index != null && !resParamsMap[p.index]) {
					resParamsMap[p.index] = resParamsMap[p.index] || {};
					if (!Array.isArray(p.resu)) {
						p.resu = [p.resu];
					}
					p.resu.forEach(function(resu, idx) {
						resParamsMap[p.index][idx] = {
							num: p.index,
							poste: idx,
							typ: p.typ,
							resu: resu
						};
					});

				}
			});
			this.result = getParamFieldOutputXml(resParamsMap.slice(12));
			this.status = 1;
		}
	},
	_findMenuIndex: function(idMenu, value) {
		var menus = this.description.ADXMEN.MNU;
		if (!Array.isArray(menus)) {
			menus = [menus];
		}
		var found = null;
		for (var i = 0; i < menus.length && !found; i++) {
			var menu = menus[i];

			if (menu.$.NO === idMenu && this.context.x3language) {
				// find right VAL
				var vals = !Array.isArray(menu.VAL) ? [menu.VAL] : menu.VAL;

				for (var j = 0; j < vals.length && !found; j++) {
					if (vals[j].$["C_" + this.context.x3language] === value) {
						found = parseInt(vals[j].$.IND, 10);
					}
				}
			}
		}
		return found;
	},
	setAckCallParams: function(description) {
		this.description = description;
		var self = this;

		//console.log("Description: " + JSON.stringify(description, null, 2));
		if (this.itemKeys) {
			// check the key pass and if they correspond the key description
			var adxkey = this.action === "LIST" ? description.ADXKEY.GRP.FLD : description.ADXREAD.GRP.FLD;
			if (!Array.isArray(adxkey)) {
				adxkey = [adxkey];
			}
			if (!Array.isArray(this.itemKeys)) {
				this.itemKeys = [this.itemKeys];
			}
			var inKey = true;
			var tempKeys = [];
			for (var i = 0; i < adxkey.length && inKey; i++) {
				// looking for the item that have the name of the current fld
				var found = false;

				for (var j = 0; j < this.itemKeys.length && !found; j++) {
					if (this.itemKeys[j].key === adxkey[i].$.NAM) {
						found = true;
						if (adxkey[i].$.MEN != null) {
							var menuindex = self._findMenuIndex(adxkey[i].$.MEN, this.itemKeys[j].value);
							tempKeys.push(menuindex || this.itemKeys[j].value);
						} else {
							tempKeys.push(this.itemKeys[j].value);
						}
					}
				}
				if (!found) tempKeys.push("");
			}
			this.wkeys = tempKeys.join("~");
			//console.error("keys "+this.wkeys);
		}

		var _inputParser;
		if (self.inputFormat === "JSON") {
			_inputParser = new InputParserJson(this);
			this.callParams = _inputParser.parse();
		} else {
			_inputParser = new InputParserXml(this);
			this.callParams = _inputParser.parse();
		}
	},
	getSoapResponse: function(status) {
		this.status = status != null ? status : this.status;
		var resp = {
			status: {
				$value: this.status,
			},
			messages: this.messages,
			result: this.result
		};
		if (resp.messages.length > 0) {
			resp.messages.forEach(function(message) {
				if (message.type === 1)
					tracer.info && tracer.info(message.message);
				else if (message.type === 2)
					tracer.warn && tracer.warn(message.message);
				else
					tracer.error && tracer.error(message.message);
			});
		}
		return resp;
	}
});