"use strict";
var helpers = require('syracuse-core/lib/helpers');
var outputBuilder = require('./outputBuilder');
var OutputBuilderXml = outputBuilder.OutputBuilderXml;
var OutputBuilderJson = outputBuilder.OutputBuilderJson;
var inputParser = require('./inputParser');
var InputParserXml = inputParser.InputParserXml;
var InputParserJson = inputParser.InputParserJson;
var TechInfo = require('syracuse-soap/lib/generic/techInfo').TechInfo;

var tracer = require("syracuse-trace/lib/helper").getTracer("soap-generic.ackcall");

exports.WsCall = helpers.defineClass(function() {
	// will be computed !
	this.description = null;
	this.callParams = null;
	this.status = 1;
	this.result = null; // reply of the ack_call;
	this.messages = [];

	this.techInfo = new TechInfo();
	this.report = this.techInfo.processReport;
}, null, {
	init: function(params, requestConfig) {
		// manage params
		this.name = params.name;
		this.flow = params.flow;
		this.action = params.action;
		this.wtrace = params.trace;
		// for object or list
		this.itemKeys = params.wkeys; // for CRUD and list, criteria or keys elements
		this.wkeys = ""; // string that represent the key
		this.nb = params.nb; // for list action , number of elements
		this.debugInfo = params.debugInfo;
		// for action inslig or suplig
		this.tab = params.tab; //blocKey
		this.par = params.par; // lineKey

		// manage requestConfig
		this.requestConfig = requestConfig || {};
		this.format = this.requestConfig["adxwss.optreturn"] && this.requestConfig["adxwss.optreturn"].toLowerCase() === "json" ? "JSON" : "XML";
		this.beautify = this.requestConfig["adxwss.beautify"] === "true";
	},
	addMessage: function(type, message) {
		this.messages.push({
			type: type,
			message: message
		});
	},
	_handleTechParams: function(params) {
		var techParamsMap = [];
		params.forEach(function(p) {
			if (p.num != null) {
				techParamsMap[p.num] = techParamsMap[p.num] || {};
				techParamsMap[p.num][p.poste] = p;
			}
		});
		//tracer.debug && tracer.debug("Technical parameters: "+JSON.stringify(techParamsMap,null,2));

		// Manage messages
		if (techParamsMap[3] && techParamsMap[4]) {
			for (var i = 0; i < Object.keys(techParamsMap[3]).length; i++) {
				this.addMessage(techParamsMap[3][i].resu, techParamsMap[4][i].resu);
			}
		}
	},
	computeResult: function(params) {
		var self = this;

		function getParamFieldOutputXml(resultParamMap) {
			//tracer.debug && tracer.debug("Data in description: " + JSON.stringify(descripData, null, 2));
			//tracer.debug && tracer.debug("Params: " + JSON.stringify(resultParamMap, null, 2));
			var _outputBuilder;
			if (self.format === "JSON") {
				_outputBuilder = new OutputBuilderJson(self, resultParamMap);
				return _outputBuilder.build();
			} else {
				_outputBuilder = new OutputBuilderXml(self, resultParamMap);
				return _outputBuilder.build();
			}
		}
		//
		if (!this.result) {
			// create a map with num (correspond to index) as a id in order to match the description
			var resParamsMap = [];
			params.forEach(function(p) {
				if (p && p.num != null) {
					resParamsMap[p.num] = resParamsMap[p.num] || {};
					resParamsMap[p.num][p.poste] = p;
				} else if (p && p.index != null && !resParamsMap[p.index]) {
					resParamsMap[p.index] = resParamsMap[p.index] || {};
					if (!Array.isArray(p.resu)) {
						p.resu = [p.resu];
					}
					p.resu.forEach(function(resu, idx) {
						resParamsMap[p.index][idx] = {
							num: p.index,
							poste: idx,
							typ: p.typ,
							resu: resu
						};
					});

				}
			});
			this.result = getParamFieldOutputXml(resParamsMap.slice(12));
			this.status = 1;
		}
	},
	setAckCallParams: function(description) {
		this.description = description;
		var self = this;

		//console.log("Description: " + JSON.stringify(description, null, 2));
		if (this.itemKeys) {
			// check the key pass and if they correspond the key description
			var adxkey = this.action === "LIST" ? description.ADXKEY.GRP.FLD : description.ADXREAD.GRP.FLD;
			if (!Array.isArray(adxkey)) {
				adxkey = [adxkey];
			}
			var inKey = true;
			for (var i = 0; i < adxkey.length && inKey; i++) {
				// looking for the item that have the name of the current fdl
				var found = false;

				for (var j = 0; j < this.itemKeys.length && !found; j++) {
					if (this.itemKeys[j].key === adxkey[i].$.NAM) {
						found = true;
						this.wkeys += (this.wkeys ? "~" : "") + this.itemKeys[j].value;
					}
				}
			}
		}
		//console.log("key "+this.wkeys);


		var _inputParser;
		if (self.format === "JSON") {
			_inputParser = new InputParserJson(this);
			this.callParams = _inputParser.parse();
		} else {
			_inputParser = new InputParserXml(this);
			this.callParams = _inputParser.parse();
		}
	},
	getSoapResponse: function(status) {
		this.status = status != null ? status : this.status;
		var resp = {
			status: {
				$value: this.status,
			},
			messages: this.messages,
			result: this.result
		};
		if (resp.messages.length > 0) {
			resp.messages.forEach(function(message) {
				if (message.type === 1)
					tracer.info && tracer.info(message.message);
				else if (message.type === 2)
					tracer.warn && tracer.warn(message.message);
				else
					tracer.error && tracer.error(message.message);
			});
		}
		return resp;
	}
});