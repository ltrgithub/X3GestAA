"use strict";

var helpers = require("syracuse-core/lib/helpers");
var Context = require("syracuse-sdata/lib/sdataContext").Context;
var registry = require("syracuse-sdata/lib/sdataRegistry");
var dataModel = require("syracuse-orm/lib/dataModel");
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var locale = require("syracuse-core/lib/locale");
var executor = require('./executor');
var soapUtils = require('../server/soapUtils');
var stubUtils = require('../client/stubUtils');
var stubRuntime = require('../client/stubRuntime');
var globals = require('streamline-runtime').globals;
var fs = require('fs');
var path = require('path');


function getLocalizations(stubName) {
	var filePath = path.resolve(__dirname + "/resources/" + stubName);
	var translations;
	if (fs.existsSync(filePath + "-" + locale.current + ".json")) {
		translations = JSON.parse(fs.readFileSync(filePath + "-" + locale.current + ".json"));
	} else if (fs.existsSync(filePath + "-" + locale.current.substring(0, 2) + ".json")) {
		translations = JSON.parse(fs.readFileSync(filePath + "-" + locale.current.substring(0, 2) + ".json"));
	} else if (fs.existsSync(filePath + "-en.json")) {
		translations = JSON.parse(fs.readFileSync(filePath + "-en.json"));
	}
	return translations;
}

var _soapMap = {
	walk: function(_, context, name) {
		context.applicationName = name;
		context.application = registry.applications[name];
		//			if (!context.application && !helpers.stubsPath) throw context.notFound("application not found: " + name);
		return _dispatch(_, context, _applicationMap);
	},
	get: function(_, context) {
		return context.replyDictionaryPage(_, registry.applications, "application");
	}
};

//URL is http://host/soap-generic/app
var _applicationMap = {
	walk: function(_, context, name) {
		context.contractName = name;
		if (context.application) context.contract = context.application.contracts[name];
		// helpers.stubsPath is to be deprecated
		var stubsPath = ((globals.context.config || {}).system || {}).stubsPath || helpers.stubsPath;
		//
		var app = adminHelper.getApplication(_, context.applicationName, context.contractName);
		if (!app && !context.application && !stubsPath) throw context.notFound(locale.format(module, "applicationNotFound", context.applicationName, context.contractName));
		context.applicationRef = app;
		return _dispatch(_, context, (app && (app.protocol(_) !== "syracuse")) ? _x3ContractMap : _syracuseContractMap);
	},
	get: function(_, context) {
		return context.replyDictionaryPage(_, context.application.contracts, "contract");
	}
};

//URL is http://host/soap-generic/app/contract
var _syracuseContractMap = {
	walk: function(_, context, name) {
		// allow stubs
		if (context.contract) {
			var ds = registry.getDataset(_, context.contract, name);
			if (!ds) throw context.notFound(locale.format(module, "datasetNotFound", name));
			context.dataset = name;
			context.model = dataModel.make(context.contract, context.dataset);
			context.db = dataModel.getOrm(_, context.model, ds);
			context.baseUrl = context.walked();
		}
		return _dispatch(_, context, _syracuseDatasetMap);
	},
	get: function(_, context) {
		return context.replyDictionaryPage(_, context.contract.datasets, "dataset");
	}
};

var _x3ContractMap = {
	walk: function(_, context, name) {
		if (context.applicationRef) { // TEST to allow stubs
			// find the endpoint
			var ep = adminHelper.getEndpoint(_, {
				application: context.applicationName,
				contract: context.contractName,
				dataset: name
			});

			if (!ep) throw context.notFound(locale.format(module, "endpointNotFound", context.applicationName, context.contractName, name));
			context.baseUrl = context.walked();
			context.endpoint = ep;
			context.db = ep.getOrm(_);
		}
		return _dispatch(_, context, _x3DatasetMap);
	}
};

// URL is http://host/soap-generic/app/contract/dataset
// for syracuse endpoints
var _syracuseDatasetMap = {
	walk: function(_, context, name, id) {

		if (id) {
			throw context.badRequest(locale.format(module, "unexpectedId", id));
		} else {
			return _dispatch(_, context, _entityMap);
		}
	},
	get: function(_, context) {
		var baseUrl = context.walked();
		return context.replyDictionaryPage(_, soapUtils.getSoapWebServices(_, "soapGeneric"), "soapGeneric", function(name, ws) {
			return {
				$url: baseUrl + "/" + ws.name + "?wsdl",
				$key: ws.name,
				$descriptor: "entity " + ws.description,
				name: ws.name
			};
		});
	}
};

var _x3DatasetMap = {
	walk: function(_, context, name, id) {
		if (id) {
			throw context.badRequest(locale.format(module, "unexpectedId", id));
		} else {
			return _dispatch(_, context, _entityMap);
		}
	}
};

//URL is http://host/soap-generic/app/contract/dataset/entity (or deeper)
var _entityMap = {
	post: function(_, context) {
		var serviceName = context.request.url.split("/")[5];
		// All real ws calls are intercepted here !!!
		var result = executor.intercept(_, serviceName, context);
		var header = {
			"content-type": "text/xml; charset=utf-8",
			"content-length": result.length
		};

		context.response.writeHead(200, header);
		context.response.end(result, "utf8");
	},
	walk: function(_, context, name, id) {

		if (id) {
			throw context.badRequest(locale.format(module, "unexpectedId", id));
		} else {
			return _dispatch(_, context, _portMap);
		}
	}
};

//http://host/soap-generic/app/contract/dataset/entity/port
var _portMap = {
	walk: function(_, context, name, id) {

		if (id) {
			throw context.badRequest(locale.format(module, "unexpectedId", id));
		} else {
			return _dispatch(_, context, _operationMap);
		}
	},
	prototypes: function(_, context, id) {
		if (id) {
			context.prototypeId = id;
			return _dispatch(_, context, _prototypeMap);
		} else {
			return _dispatch(_, context, _prototypesMap);
		}
	},
	get: function(_, context) {
		var baseUrl = context.walked();
		var parts = context.request.url.split("/");
		var stubName = parts[5];
		var portName = parts[6];

		return context.replyDictionaryPage(_, stubUtils.getSoapStubPortOperations(_, stubName, portName, context, true, true), "soapStubPortOperations", function(name, operation) {
			return {
				$url: baseUrl + "/" + operation.name,
				$key: operation.name + "operation",
				$descriptor: operation.description,
				name: operation.name + "Operation"
			};
		});
	}
};

// http://host/soap-generic/app/contract/dataset/entity/port/operation
var _operationMap = {
	invoke: function(_, context) {
		return _dispatch(_, context, _invokeMap);
	},
	get: function(_, context) {
		var baseUrl = context.walked();
		var parts = context.request.url.split("/");
		var stubName = parts[5];
		var portName = parts[6];
		var operationName = parts[7];
		var match = /(.*)[?!\?](.*)[?!\=]([^.]*).([^']*)$/.exec(operationName);
		if (match) {
			operationName = match[1];
			var paramName = match[2];
			//var representation = match[3];
			var facet = match[4];

			if (paramName === "representation") {
				var proto = stubUtils.getOperationPrototype(_, stubName, portName, operationName, facet, context, "generic-in");
				// replace soap-generic with soaptest-generic so that this request will be executed on
				// local process even with load balancer. Within that execution, the request will
				// be forwarded internally to the Web service process using the soap-generic URL.
				var baseUrl2 = baseUrl.replace("soap-generic", "soaptest-generic");
				proto.$links = {
					$invoke: {
						$title: "Invoke",
						$url: baseUrl2 + "/$invoke",
						$method: "POST"
					}
				};
				if (proto) {
					stubUtils.injectLocalizations(getLocalizations(stubName), proto);
					context.reply(_, 200, {
						$prototype: proto
					});
				} else {
					context.reply(_, 404, locale.format(module, "prototypeNotFound", context.prototypeId));
				}
			} else {
				throw context.badRequest(locale.format(module, "unexpectedParam", paramName));
			}
		} else {

			baseUrl = baseUrl.substring(0, baseUrl.length - operationName.length - 1);

			var protos = [{
				name: operationName,
				facet: "$request"
			}, {
				name: operationName,
				facet: "$response"
			}];
			return context.replyDictionaryPage(_, protos, "soapStubPortOperations", function(name, proto) {
				return {
					$url: baseUrl + "/$prototypes('" + proto.name + "." + proto.facet + "')",
					$key: proto.name + "." + proto.facet,
					$descriptor: proto.name + " prototype " + proto.facet,
					name: proto.name + "Prototype." + proto.facet
				};
			});
		}
	}
};

//http://host/soap-generic/app/contract/dataset/entity/port/$prototypes
var _invokeMap = {
	post: function(_, context) {
		var parts = context.request.url.split("/");
		var stubName = parts[5];
		var portName = parts[6];
		var operationName = parts[7];

		var data = JSON.parse(context.request.readAll(_));
		var response = stubRuntime.execute(_, stubName, portName, operationName, data, context, "generic-in", getLocalizations(stubName));
		context.reply(_, 200, response);
	}
};

//http://host/soap-generic/app/contract/dataset/entity/port/$prototypes
var _prototypesMap = {
	get: function(_, context) {
		throw context.niy("prototypes list");
	}
};

//http://host/soap-generic/app/contract/dataset/entity/port/$prototypes('id')
var _prototypeMap = {
	get: function(_, context) {
		var parts = context.request.url.split("/");
		var stubName = parts[5];
		var portName = parts[6];

		var keys = context.prototypeId.split(".");
		var operationName = keys[0];
		var facet = keys[1];

		var proto = stubUtils.getOperationPrototype(_, stubName, portName, operationName, facet, context, "generic-in");
		if (proto) {
			stubUtils.injectLocalizations(getLocalizations(stubName), proto);
			context.reply(_, 200, proto);
		} else context.reply(_, 404, locale.format(module, "prototypeNotFound", context.prototypeId));

	}
};

function _parseSegment(segment) {
	var match = /^([^\/(]*)\('([^']*)'\)$/.exec(segment);
	return match ? {
		name: match[1],
		id: match[2]
	} : {
		name: segment
	};
}

function _dispatch(_, context, map) {

	var seg = context.walkUrl();
	if (seg == null) {
		// we reached the end of the URL, dispatch method
		//var method = context.request.method.toLowerCase();
		var method = context.method;
		if (map[method]) return map[method](_, context);
		else throw context.badMethod(method);
	} else {
		var pair = _parseSegment(seg);
		if (pair.name[0] === '$') {
			var name = pair.name.substring(1);
			if (map[name]) {
				return map[name](_, context, pair.id);
			}
		} else if (map.walk) {
			return map.walk(_, context, pair.name, pair.id);
		}
		throw context.badRequest(locale.format(module, "unexpectedSegment", seg));
	}
}

function _logRequest(_, context) {
	if (!context.request.headers["x-history-title"]) return;
	//
	var db = adminHelper.getCollaborationOrm(_);
	var h = db.model.getEntity(_, "navHistory").factory.createInstance(_, null, db);
	h.title(_, context.request.headers["x-history-title"]);
	h.agent(_, context.request.headers["x-history-agent"]);
	h.url(_, context.request.url);
	h.save(_);
}

function _doIt(_, context) {
	try {
		var protocol = context.walkUrl();
		if (protocol !== "soap-generic" && protocol !== "soaptest-generic") throw new Error(locale.format(module, "badUrl", protocol));

		// fire and forget log call
		_logRequest(!_, context);

		_dispatch(_, context, _soapMap);
	} catch (ex) {
		console.error("ERROR: " + ex.stack);
		if (ex.$httpStatus) {
			return context.reply(_, ex.$httpStatus, ex.message);
		} else if (ex.stack) {

			return context.reply(_, 500, ex.message);
		} else {
			return context.reply(_, 500, ex.toString());
		}
	}
}

exports.dispatcher = function(config) {
	return function(_, request, response) {
		var context = new Context(request, response, config);
		request.context = context;
		request.session.statelessExecute(_, function(_) {
			try {
				_doIt(_, context);
			} catch (err) {
				helpers.log.exception(module, err);
				context.reply(_, 500, err.safeStack);
			}
		});
		request.context = null;
		request.session = null;
	};
};