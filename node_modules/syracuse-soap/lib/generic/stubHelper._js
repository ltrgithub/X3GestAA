"use strict";

/*
 * This module has been duplicated to be not dependent of standard stubHelper implementation
 */
var helpers = require('syracuse-core/lib/helpers');
var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var http = require('http');
var httpClient = require("syracuse-httpclient/lib/httpClient");
var locale = require("syracuse-core/lib/locale");
var jsxml = require('jsxml');
var stubUtils = require('../client/stubUtils');
var globals = require('streamline/lib/globals');
var forEachKey = helpers.object.forEachKey;
var config = require('config');
var os = require("os");
var soapTools = require('../common/soapTools');

var tracer = require("syracuse-trace/lib/helper").getTracer("soap-generic.stub");

var __http = "http://schemas.xmlsoap.org/wsdl/http/";
var __http2 = "http://www.w3.org/2003/05/soap/bindings/HTTP/";
var __soapHttp = "http://schemas.xmlsoap.org/soap/http";
var __soap = "http://schemas.xmlsoap.org/wsdl/soap/";
var __soap12 = "http://schemas.xmlsoap.org/wsdl/soap12/";
var __XMLSchema = "http://www.w3.org/2001/XMLSchema";
var __soapEnc = "http://schemas.xmlsoap.org/soap/encoding/";
var __wsdl = "http://schemas.xmlsoap.org/wsdl/";

var _primitive = "primitive";
// XSD elements
var _all = "all";
var _annotation = "annotation";
var _any = "any";
var _anyAttribute = "anyAttribute";
var _appInfo = "appInfo";
var _attribute = "attribute";
var _attributeGroup = "attributeGroup";
var _choice = "choice";
var _complexContent = "complexContent";
var _complexType = "complexType";
var _documentation = "documentation";
var _element = "element";
var _extension = "extension";
var _field = "field";
var _group = "group";
var _import = "import";
var _include = "include";
var _key = "key";
var _keyref = "keyref";
var _list = "list";
var _notation = "notation";
var _redefine = "redefine";
var _restriction = "restriction";
var _schema = "schema";
var _selector = "selector";
var _sequence = "sequence";
var _simpleContent = "simpleContent";
var _simpleType = "simpleType";
var _union = "union";
var _unique = "unique";

// XSD restrictions
var _enumeration = "enumeration";
var _pattern = "pattern";
var _whiteSpace = "whiteSpace";
var _length = "length";
var _minLength = "minLength";
var _maxLength = "maxLength";
var _minInclusive = "minInclusive";
var _maxInclusive = "maxInclusive";
var _minExclusive = "minExclusive";
var _maxExclusive = "maxExclusive";
var _fractionDigits = "fractionDigits";
var _totalDigits = "totalDigits";


var plainTextProperties = ["resultXml", "objectXml", "lineXml", "inputXml", "traceRequest", "processReport"];

function getForcedType(elt) {
	if (plainTextProperties.indexOf(elt && elt.$ && elt.$.name) !== -1) {
		return "text/plain";
	}
}

var translations = {};

function manageTranslation(value) {
	if (value.indexOf("{") !== 0) {
		translations[value] = value;
		return "{@" + value + "}";
	}
	return value;
}


var StubHelper = helpers.defineClass(function(_, instance, wsdl) {

	this.name = instance.name(_);
	this.instance = instance;
	this.wsdl = wsdl;

	this.isChild = instance.isChild(_) || false;
	this.dispatcher = "soap-generic";

	if (!this.wsdl) this.wsdl = this.getWsdl(_, this.instance.url(_));

	if (!this.instance.wsdl(_).fileExists(_)) {

		var buf1 = new Buffer(this.wsdl, 'utf8').toString('binary');
		if (buf1 != null && buf1.length !== 0) {
			var props1 = {
				length: buf1.length,
				contentType: "application/xml",
				fileName: this.instance.name(_) + ".wsdl"
			};
			var store1 = this.instance.wsdl(_);
			var stream = store1.createWritableStream(_, props1);
			stream.write(_, buf1, "binary");
			stream.write(_, null);
		}
	}

}, null, {
	getWsdl: function(_, url) {

		var options = {};
		if (!this.isChild && this.instance && this.instance.authentication(_) !== "none") {
			options.auth = {
				type: this.instance.authentication(_),
				user: this.instance.authUser(_),
				password: this.instance.authPassword(_)
			};

		}
		tracer.debug && tracer.debug("\n");
		tracer.debug && tracer.debug("##################################################");
		tracer.debug && tracer.debug("#    Retrieve WSDL from URI: " + url);
		tracer.debug && tracer.debug("##################################################");

		var opt = {
			method: "GET",
			url: url,
			headers: {}
		};

		if (options && options.auth) {
			if (options.auth.type === "basic") {
				opt.headers.Authorization = "Basic " + new Buffer(options.auth.user + ":" + options.auth.password).toString('base64');
			}
		}
		if (this.isChild) {
			opt.headers.cookie = globals.context.httpSession.cookie;
		}

		var request = httpClient.httpRequest(_, opt);
		var response = request.end().response(_);
		var body = response.readAll(_);

		if (response.statusCode === 200 && body) {
			return body;
		} else {
			throw new Error(response.statusCode + ": " + http.STATUS_CODES[response.statusCode]);
		}

	},
	parseWsdl: function(_) {

		function addWarning(warn) {
			tracer.warn && tracer.warn(warn);
			self.instance.$diagnoses.push({
				$severity: "warning",
				$message: warn
			});

		}

		function getSubNode(node, ns, name) {

			if (!node) {
				return;
			}

			if (name.indexOf(':') !== -1) {
				var sec = splitNs(name).type;
				if (node[name]) {
					return node[name];
				} else {
					return node[sec];
				}
			} else {

				if (ns && node[ns + ":" + name]) {
					return node[ns + ":" + name];
				} else {
					return node[name];
				}
			}

		}

		function splitNs(word) {
			if (word.indexOf(':') !== -1) {
				var splited = word.split(':');
				return {
					ns: splited[0],
					type: splited[1]
				};
			} else {
				return {
					type: word
				};
			}
		}

		function checkIntegrity() {
			if (!definitions) throw new Error(locale.format(module, "rootNodeNotFound"));
			if (!types) throw new Error(locale.format(module, "typesNodeNotFound"));
			if (!messages) throw new Error(locale.format(module, "messageNodeNotFound"));
			if (!portTypes) throw new Error(locale.format(module, "portTypeNodeNotFound"));
			if (!bindings) throw new Error(locale.format(module, "bindingNodeNotFound"));
			if (!service) throw new Error(locale.format(module, "serviceNodeNotFound"));
		}

		function getElement(schema, eltName) {
			var elements = getSubNode(schema, xsdNs, _element);
			if (Array.isArray(elements)) {
				for (var i in elements) {
					if (elements[i].$ && elements[i].$.name === eltName) return elements[i];
				}
			} else if (elements) {
				if (elements.$ && elements.$.name === eltName) return elements;
			}
			return;
		}

		function getComplexType(schema, cpName) {
			var complexTypes = getSubNode(schema, xsdNs, _complexType);
			if (Array.isArray(complexTypes)) {
				for (var i in complexTypes) {
					if (complexTypes[i].$ && complexTypes[i].$.name === cpName) return complexTypes[i];
				}
			} else if (complexTypes) {
				if (!cpName || (complexTypes.$ && complexTypes.$.name === cpName)) return complexTypes;
			}
			return;
		}

		function getSimpleType(schema, spName) {
			var simpleTypes = getSubNode(schema, xsdNs, _simpleType);
			if (Array.isArray(simpleTypes)) {
				for (var i in simpleTypes) {
					if (simpleTypes[i].$ && simpleTypes[i].$.name === spName) return simpleTypes[i];
				}
			} else if (simpleTypes) {
				if (simpleTypes.$ && simpleTypes.$.name === spName) return simpleTypes;
			}
			return;
		}

		function getType(schema, tName) {
			var cp = getComplexType(schema, tName);
			if (cp) return cp;
			var sp = getSimpleType(schema, tName);
			if (sp) return sp;
			return;
		}

		function getAttribute(schema, attName) {
			var attributes = getSubNode(schema, xsdNs, _attribute);
			if (Array.isArray(attributes)) {
				for (var i in attributes) {
					if (attributes[i].$ && attributes[i].$.name === attName) return attributes[i];
				}
			} else if (attributes) {
				if (attributes.$ && attributes.$.name === attName) return attributes;
			}
			return;
		}

		//		function getNamespaceUrl(prefix) {
		//			return soapTools.getNamespaceUrl(definitions, prefix, false);
		//		}

		function getNamespaceUrl(prefix) {
			var xmlns = "xmlns";

			for (var key in definitions.$) {
				if (!prefix) {
					return definitions.$.xmlns;
				} else if (key === (xmlns + ":" + prefix)) {
					return definitions.$[key];
				}

			}
			throw new Error(locale.format(module, "nsNotMatchPref", prefix));
		}

		function getNamespacePrefix(url) {
			var xmlns = "xmlns:";

			for (var key in definitions.$) {
				if (key.indexOf(xmlns) === 0 && definitions.$[key].indexOf(url) === 0) return key.substring(xmlns.length);
			}
			throw new Error(locale.format(module, "nsNotMatchUrl", url));
		}
		//		function getNamespacePrefix(url) {
		//			return soapTools.getNamespacePrefix(definitions, url, false);
		//		}

		function getSchema(nsPrefix) {

			function isMatchingSchema(tns, sc) {
				if (tns) {
					return sc.$.targetNamespace === definitions.$["xmlns:" + tns];
				} else {
					return sc.$.targetNamespace === definitions.$.targetNamespace;
				}
			}

			var schemas = getSubNode(types, xsdNs, 'schema');

			if (!schemas) schemas = getSubNode(types, null, 'schema');

			if (Array.isArray(schemas)) {
				for (var i in schemas) {
					if (isMatchingSchema(nsPrefix, schemas[i])) return schemas[i];
				}
			} else if (schemas) {
				if (isMatchingSchema(nsPrefix, schemas)) return schemas;
			}

			// EM: name changed to 'noSchemaMatchNs'
			throw new Error(locale.format(module, "noSchemaMatchNs", nsPrefix));
		}

		function getMessage(messageName) {
			if (messageName.indexOf(':') !== -1) messageName = messageName.split(':')[1];

			for (var i in messages) {
				if (messages[i].$.name === messageName) {
					return messages[i];
				}
			}
			throw new Error(locale.format(module, "messageNotFound", messageName));
		}

		function getPortType(ptName) {
			if (Array.isArray(portTypes)) {
				for (var i in portTypes) {
					if (portTypes[i].$.name === ptName) return portTypes[i];
				}
			} else {
				if (portTypes.$.name === ptName) return portTypes;
			}
			throw new Error(locale.format(module, "portTypeNotFound", ptName));
		}

		function getBinding(bindingName) {
			if (Array.isArray(bindings)) {
				for (var i in bindings) {
					if (bindings[i].$.name === bindingName) return bindings[i];
				}
			} else {
				if (bindings.$.name === bindingName) return bindings;
			}
			throw new Error(locale.format(module, "bindingNotFound", bindingName));
		}

		function addPort(_, port) {

			function addOperation(_, bindingOperation) {

				function createPrototype(_, content, store, facet) {

					function buildProperty(name, element, nature, constraints, schema) {

						var params = {
							name: name,
							nature: nature,
							constraints: constraints,
							useSchema: schema != null
						};
						constraints = constraints || {},
						tracer.debug && tracer.debug("-> Build property: " + name);
						tracer.debug && tracer.debug("-> Parameters : " + JSON.stringify(params, null, 2));

						function defineProperty(aElt, aProp, aNature, isEmbedded) {

							if (aElt.$ && aElt) {
								var aType;
								if (aElt.$.type) {
									tracer.debug && tracer.debug("---> Define property type: " + aElt.$.type);
									aType = aElt.$.type;
								} else if (aElt.$.ref) {
									tracer.debug && tracer.debug("---> Define property ref: " + aElt.$.ref);
									aType = aElt.$.ref;
								}
								var splited = splitNs(aType);
								var eltNs = splited.ns;
								var eltType = splited.type;
								setProperty(aProp, aElt, eltNs, aNature);
							} else if (isEmbedded) {
								setProperty(aProp, aElt, null, aNature);
							}
						}

						function handleSequence(sequence) {

							if (typeof sequence === 'object') forEachKey(sequence, function(key, value) {
								if (key === xsdPrefix + _element) {
									if (Array.isArray(value)) {
										value.forEach(function(subElement) {
											defineProperty(subElement, prop, _element, true);
										});
									} else if (value) {
										defineProperty(value, prop, _element, true);
									}
								} else if (key !== '$') {
									addWarning(locale.format(module, "seqSubNodeNYI", element.$.name, key));
								}
							});

							// TODO: handle 'any'
						}

						function handleRestriction(restriction) {

							function nyi(_key) {
								addWarning(locale.format(module, "restrictNYI", _key));
							}

							var base = splitNs(restriction.$.base).type;
							var format, i;
							if (typeof restriction === 'object') forEachKey(restriction, function(key, value) {
								if (key === xsdPrefix + _enumeration) {
									// Handle enumerations

									prop.$type = "application/x-choice";
									prop.$value = prop.$value || {};
									prop.$value.$type = convertType(base);
									prop.$value.$enum = [];

									if (Array.isArray(value)) {
										value.forEach(function(_enum) {
											prop.$value.$enum.push({
												$value: _enum.$.value,
												$title: manageTranslation(_enum.$.value)
											});
										});
									} else {
										prop.$value.$enum.push({
											$value: value.$.value,
											$title: manageTranslation(value.$.value)
										});
									}
								}
								// Handle pattern
								else if (key === xsdPrefix + _pattern) {
									prop.$pattern = value;
								}
								// Handle length
								else if (key === xsdPrefix + _length) {
									var len = parseInt(value, 10);
									prop.$minLength = len;
									prop.$maxLength = len;
								}
								// Handle minLength
								else if (key === xsdPrefix + _minLength) {
									prop.$minLength = parseInt(value, 10);
								}
								// Handle maxLength
								else if (key === xsdPrefix + _maxLength) {
									prop.$maxLength = parseInt(value, 10);
								}
								// Handle whiteSpace
								else if (key === xsdPrefix + _whiteSpace) {
									// TODO
									nyi(key);
								}
								// Handle minInclusive
								else if (key === xsdPrefix + _minInclusive) {
									prop.$minimum = parseInt(value, 10);
									prop.$exclusiveMinimum = false;
								}
								// Handle maxInclusive
								else if (key === xsdPrefix + _maxInclusive) {
									prop.$maximum = parseInt(value, 10);
									prop.$exclusiveMaximum = false;
								}
								// Handle minExclusive
								else if (key === xsdPrefix + _minExclusive) {
									prop.$minimum = parseInt(value, 10);
									prop.$exclusiveMinimum = true;
								}
								// Handle maxExclusive
								else if (key === xsdPrefix + _maxExclusive) {
									prop.$maximum = parseInt(value, 10);
									prop.$exclusiveMaximum = true;
								}
								// Handle fractionDigits
								else if (key === xsdPrefix + _fractionDigits) {
									format = "0.";
									for (i = 0; i < parseInt(value, 10); i++) {
										format += "#";
									}
								}
								// Handle totalDigits
								else if (key === xsdPrefix + _totalDigits) {
									if (['float', 'double', 'decimal'].indexOf(base) !== -1) {
										addWarning("handle '" + _key + "' restriction of type '" + base + "' not yet implemented");
									} else if (['integer', 'int', 'long', 'short', 'nonNegativeInteger', 'positiveInteger', 'nonPositiveInteger', 'negativeInteger', 'unsignedInt', 'unsignedLong', 'unsignedShort'].indexOf(base) !== -1) {
										format = "";
										for (i = 0; i < parseInt(value, 10); i++) {
											format += "0";
										}
										prop.$format = format;
									}
								}
								// Handle attribute
								else if (key === xsdPrefix + _attribute) {
									handleAttribute(value);
								} else if (key !== '$') {
									nyi(key);
								}
							});

						} // End handleRestriction

						function handleComplexContent(_cc) {
							function nyi(_key) {
								addWarning(locale.format(module, "ccSubNodeNYI", _cc.$.name, _key));
							}

							if (typeof _cc === 'object') forEachKey(_cc, function(key, value) {
								if (key === xsdPrefix + _annotation) {
									nyi(key, element);
								} else if (key === xsdPrefix + _restriction) {
									handleRestriction(value);
								} else if (key === xsdPrefix + _extension) {
									nyi(key);
								}
							});

							// TODO: handle 'any'
						}

						function handleComplexType(_cp) {
							function nyi(_key) {
								addWarning(locale.format(module, "cpSubNodeNYI", _cp.$.name, _key));
							}

							_cp = _cp || element;
							if (typeof _cp === 'object') forEachKey(_cp, function(key, value) {
								// annotation?
								if (key === xsdPrefix + _annotation) {
									// TODO
									nyi(key, element);
								} else if (key === xsdPrefix + _simpleContent) {
									// TODO
									nyi(key);
								} else if (key === xsdPrefix + _complexContent) {
									handleComplexContent(value);
								} else if (key === xsdPrefix + _group) {
									// TODO
									nyi(key);
								} else if (key === xsdPrefix + _all) {
									// TODO
									nyi(key);
								} else if (key === xsdPrefix + _choice) {
									// TODO
									nyi(key);
								} else if (key === xsdPrefix + _sequence) {
									handleSequence(value);
								} else if (key === xsdPrefix + _attribute) {
									if (Array.isArray(value)) {
										value.forEach(function(attrib) {
											if (attrib.$.type) {
												defineProperty(attrib, prop, _attribute);
											} else {
												defineProperty(attrib, prop, _attribute, true);
											}
										});
									} else if (value) {
										if (value.$.type) {
											defineProperty(value, prop, _attribute);
										} else {
											defineProperty(value, prop, _attribute, true);
										}
									}
								} else if (key === xsdPrefix + _attributeGroup) {
									// TODO
									nyi(key);
								} else if (key === xsdPrefix + _anyAttribute) {
									// TODO
									nyi(key);
								} else if (key !== '$') {
									nyi(key);
								}
							});
						} // handleComplexType

						function handleSimpleType(_sp) {

							function nyi(_key) {
								addWarning(locale.format(module, "spSubNodeNYI", _sp.$.name, _key));
							}

							_sp = _sp || element;
							if (typeof _sp === 'object') forEachKey(_sp, function(key, value) {
								if (key === xsdPrefix + _restriction) {
									handleRestriction(value);
								} else if (key !== '$') {
									nyi(key);
								}
							});

						} // handleSimpleType

						function handleAttribute(_att) {

							function nyi(_key) {
								addWarning(locale.format(module, "attSubNodeNYI", _att.$.name || _att.$.ref, _key));
							}

							_att = _att || element;
							if (typeof _att === 'object') {
								if (Object.keys(_att).length === 1 && Object.keys(_att)[0] === "$") {
									if (_att.$.type) {
										defineProperty(_att, prop, _attribute);
									} else {
										defineProperty(_att, prop, _attribute, true);
									}
								} else {
									forEachKey(_att, function(key, value) {
										if (key === xsdPrefix + _simpleType) {
											handleSimpleType(value);
										} else if (key === xsdPrefix + _annotation) {
											// TODO
											nyi(key);
										} else if (key !== '$') {
											nyi(key);
										}
									});
								}
							}

						} // handleAttribute

						function handleElement(_elt) {
							function nyi(_key) {
								addWarning(locale.format(module, "eltSubNodeNYI", _elt.$.name, _key));
							}

							if (typeof _elt === 'object') {


								if (Object.keys(_elt).length === 1 && Object.keys(_elt)[0] === "$") {
									if (_elt.$.type) {
										var splited = splitNs(_elt.$.type);
										var eltNs = splited.ns;
										var eltType = splited.type;

										var sc = getSchema(eltNs);

										var xsdComplexType = getComplexType(sc, eltType);
										if (xsdComplexType) {
											handleComplexType(xsdComplexType);
										} else {
											var xsdSimpleType = getSimpleType(sc, eltType);
											if (xsdSimpleType) {
												handleSimpleType(xsdSimpleType);
											} else {
												throw new Error(locale.format(module, "xsdTypeNotFound", eltType));
											}
										}
									}
								} else {
									forEachKey(_elt, function(key, value) {
										if (key === xsdPrefix + _complexType) {
											handleComplexType(value);
										} else if (key === xsdPrefix + _simpleType) {
											handleSimpleType(value);
										} else if (key !== '$') {
											nyi(key);
										}
									});
								}
							}
						} // handleElement

						var xsdPrefix = "";
						var prop = {
							$title: manageTranslation(name)
						};

						if (constraints.maxOccurs) {
							if (constraints.maxOccurs !== "1") prop.$type = "application/x-array";
						}
						//
						if (constraints.nillable) {
							prop.$isNullable = (constraints.nillable === "true");
						}
						//
						if (constraints.minOccurs) {
							prop.$isMandatory = (constraints.minOccurs !== "0");
						} else if (!prop.$isNullable) {
							prop.$isMandatory = true;
						}

						if (schema) {

							if (schema.$.xmlns !== getNamespaceUrl(xsdNs)) xsdPrefix = xsdNs + ":";

							prop.$type = prop.$type || "application/x-object";
							prop.$item = prop.$item || {
								$properties: (prop.$item && prop.$item.$properties) || {}
							};
							if (constraints['default']) prop.$default = stubUtils.convertValue("default", prop.$type, constraints['default']);

							if (nature === _primitive) {
								addWarning(locale.format(module, "primitiveNotExpected"));
								defineProperty(element, prop, _primitive);
							} else if (nature === _complexType) {
								handleComplexType();
							} else if (nature === _simpleType) {
								handleSimpleType();
							} else if (nature === _attribute) {
								handleAttribute();
							} else if (nature === _element) {
								handleElement(element);
							} else {
								throw new Error('Nature error');
							}

						} else if (nature === _primitive) {

							if (prop.$type !== "application/x-array") {
								prop.$type = convertType(element.$.type);

							} else {
								prop.$item = {
									$properties: {}
								};
								prop.$item.$properties[name] = {
									$title: manageTranslation(name),
									$type: convertType(element.$.type)
								};
							}
							if (constraints['default']) prop.$default = stubUtils.convertValue("default", prop.$type, constraints['default']);

						} else {
							throw new Error(locale.format(module, "unexpectedError"));
						}
						//console.log("Property builded: "+JSON.stringify(prop,null,2));
						return prop;

					} // End buildProperty

					function convertType(type) {
						if (type.indexOf(':') !== -1) type = type.split(':')[1];
						switch (type) {
							case "string":
								return "application/x-string";
							case "boolean":
								return "application/x-boolean";
							case "float":
							case "double":
							case "decimal":
								return "application/x-decimal";
							case "integer":
							case "int":
							case "long":
							case "short":
							case "nonNegativeInteger":
							case "positiveInteger":
							case "nonPositiveInteger":
							case "negativeInteger":
							case "unsignedInt":
							case "unsignedLong":
							case "unsignedShort":
								return "application/x-integer";
							case "date":
								return "application/x-date";
							case "time":
								return "application/x-time";
							case "dateTime":
								return "application/x-datetime";
							case "byte":
							case "duration":
							case "hexBinary":
							case "base64Binary":
							case "anyURI":
							case "ID":
							case "IDREF":
							case "ENTITY":
							case "NOTATION":
							case "normalizedString":
							case "token":
							case "language":
							case "IDREFS":
							case "ENTITIES":
							case "NMTOKEN":
							case "NMTOKENS":
							case "Name":
							case "QName":
							case "NCName":
							case "unsignedByte":
							case "gYearMonth":
							case "gYear":
							case "gMonthDay":
							case "gDay":
							case "gMonth":
								addWarning(locale.format(module, "dataTypeNotSupported", type));
								return;
							default:
								addWarning(locale.format(module, "dataTypeNotSupported", type));
								return;
						}

					} // End convertType

					function setProperty(prop, element, ns, nature) {
						tracer.debug && tracer.debug("\n");
						tracer.debug && tracer.debug("--------------------------------------------------");
						tracer.debug && tracer.debug("|    -> Set property");
						tracer.debug && tracer.debug("--------------------------------------------------");
						//tracer.debug && tracer.debug(JSON.stringify(element,null,2));

						var name = element.$ && (element.$.title || element.$.name);
						var loc;

						if (prop.$type === "application/json") {
							prop.$properties = prop.$properties || {};
							loc = prop;
						} else {
							if (prop.$type === "application/x-array") {
								if (facet === "$request") {
									prop.$capabilities = "sort,insert,append,delete,filter";
								} else if (facet === "$response") {
									prop.$capabilities = "sort,filter";
								}
							}


							prop.$item = prop.$item || {
								$properties: (prop.$item && prop.$item.$properties) || {}
							};
							loc = prop.$item;
						}

						//TODO: Do not build property for cycle dependencies

						// primitive type
						if (ns && getNamespaceUrl(ns).indexOf(__XMLSchema) === 0) {
							loc.$properties[name] = buildProperty(name, element, _primitive, element.$);

							// SPECIFIC FOR GENERIC WS : force type for XML fields
							var forcedType = getForcedType(element);
							if (forcedType) loc.$properties[name].$type = forcedType;
						}


						// Special code for soapenc elements
						else if (ns && getNamespaceUrl(ns).indexOf(__soapEnc) === 0) {

							// Special section for arrayType
							if (element && element.$ && element.$.ref === ns + ":arrayType") {
								prop.$type = "application/x-array";
								var constraints = {
									minOccurs: 0,
									maxOccurs: "unbounded"
								};
								var arrTypeKey = element.$[getNamespacePrefix(__wsdl) + ":arrayType"];
								if (arrTypeKey) {
									var parts = arrTypeKey.split(':');
									var attType = parts[1].indexOf('[]') !== -1 ? parts[1].substring(0, parts[1].length - 2) : parts[1];
									// need to store real type for soapArrays because of multi references
									prop.$soapType = attType;
									var tmpName = prop.$title;
									var tmpProp;
									if (getNamespaceUrl(parts[0]).indexOf(__XMLSchema) === 0) {
										tmpProp = buildProperty(tmpName, {
											$: {
												type: attType
											}
										}, _primitive, constraints);
									} else {
										var arrSc = getSchema(parts[0]);
										var arrCp = getType(arrSc, attType);
										tmpProp = buildProperty(tmpName, arrCp, _complexType, constraints, arrSc);
									}


									forEachKey(tmpProp, function(key, value) {
										prop[key] = value;
									});
									prop.$capabilities = "sort,insert,append,delete,filter";
									// Array would never be mandatory
									prop.$isMandatory = false;
								}
							}
						}

						// schema's type
						else {
							loc.$properties[name] = buildProperty(name, element, nature, element.$, getSchema(ns));
						}

					} // End setProperty

					function readMsgPart(part, prop) {

						function prepareProperty(_name) {
							if (facet === "$request") _name = operationName;
							prop.$item.$properties[_name] = prop.$item.$properties[_name] || {
								$title: manageTranslation(_name),
								$isMandatory: true,
								$type: "application/x-object",
								$item: {
									$properties: {}
								}
							};
							loc = prop.$item.$properties[_name];
						}

						tracer.debug && tracer.debug("\n");
						tracer.debug && tracer.debug("--------------------------------------------------");
						tracer.debug && tracer.debug("|    Read message part: " + msgName);
						tracer.debug && tracer.debug("--------------------------------------------------");
						tracer.debug && tracer.debug(JSON.stringify(part, null, 2));


						var loc, splited, partNs, sc;
						var msgTitle = part.$.name;
						if (part.$.type) {
							splited = splitNs(part.$.type);
							partNs = splited.ns;
							var partType = splited.type;

							var nsUrl = getNamespaceUrl(partNs);
							//if (!prop.$xmlns) prop.$xmlns = partNs + ":" + nsUrl;
							prepareProperty(msgName);
							if (nsUrl.indexOf(__XMLSchema) === 0) {
								setProperty(loc, part, partNs, _primitive);
							} else {
								sc = getSchema(partNs);

								var xsdComplexType = getComplexType(sc, partType);
								if (xsdComplexType) {
									if (msgTitle) xsdComplexType.$.title = msgTitle;
									setProperty(loc, xsdComplexType, partNs, _complexType);
								} else {
									var xsdSimpleType = getSimpleType(sc, partType);
									if (xsdSimpleType) {
										if (msgTitle) xsdSimpleType.$.title = msgTitle;
										setProperty(loc, xsdSimpleType, partNs, _simpleType);
									} else {
										throw new Error(locale.format(module, "dataTypeNotFound", partType));
									}
								}
							}

						} else if (part.$.element) {

							splited = splitNs(part.$.element);
							partNs = splited.ns;
							var partElement = splited.type;

							//prop.$xmlns = partNs + ":" + getNamespaceUrl(partNs);

							sc = getSchema(partNs);

							var xsdElement = getElement(sc, partElement);
							if (xsdElement) {
								var _type;
								prepareProperty(xsdElement.$.name);
								if ((_type = getComplexType(xsdElement))) {
									var _p = buildProperty(msgTitle, _type, _complexType, _type.$, sc);

									loc.$item = _p.$item;
								} else {
									setProperty(loc, xsdElement, partNs, _element);
								}
							} else {
								throw new Error(locale.format(module, "xsdEltNotFound", partElement));
							}

						}
					} // End readMsgPart

					var host = globals.context.session && globals.context.session.host;
					// for automatic import
					if (!host) {
						host = "http://" + os.hostname().toLowerCase() + ":" + config.port;
					}
					var proto = {
						$descriptor: "prototype " + operationName + "." + facet,
						$type: "application/json",
						$prototype: "{$baseUrl}/$prototypes('" + operationName + "." + facet + "')",
						$baseType: "application/json;vnd.sage=syracuse",
						$baseUrl: "/" + self.dispatcher + "/syracuse/collaboration/syracuse/" + self.name + "/" + port.$.name,
						$value: documentation,
						$title: operationName,
						$description: operationName + " " + facet + " : " + documentation,
						$representation: operationName,
						$properties: {}
					};

					///////

					//					var content = {
					//							type: "input",
					//							binding: {
					//								header: getSubNode(bindingInput, protocolNs, 'header'),
					//								body: getSubNode(bindingInput, protocolNs, 'body')
					//							},
					//							portType: getSubNode(portTypeOperation, wsdlNs, 'input')
					//						};

					if (content.binding.header) {

						var handleHeader = function(header) {

							var headerMsgName, headerMsgPart;

							if (header.$) {
								headerMsgName = header.$.message;
								headerMsgPart = header.$.part;

								var splited = splitNs(headerMsgName);
								//var msgNs = splited.ns;
								var msgName = splited.type;

								var message = getMessage(msgName);
								var messagePart = getSubNode(message, wsdlNs, 'part');
								if (Array.isArray(messagePart)) {

									if (headerMsgPart) {
										for (var i in messagePart) {
											if (messagePart[i].$.name === headerMsgPart) {
												readMsgPart(messagePart[i], proto.$properties.header);
											}
										}
									} else {
										messagePart.forEach(function(mp) {
											readMsgPart(mp, proto.$properties.header);
										});
									}
								} else if (messagePart) {
									if (headerMsgPart) {
										if (messagePart.$.name === headerMsgPart) {
											readMsgPart(messagePart, proto.$properties.header);
										}
									} else {
										readMsgPart(messagePart, proto.$properties.header);
									}

								}
							}
						}; // handleHeader function

						proto.$properties.header = {
							$title: "Header",
							$isMandatory: true,
							$type: "application/x-object",
							$item: {
								$properties: {}
							}
						};

						if (Array.isArray(content.binding.header)) {
							content.binding.header.forEach(function(header) {
								handleHeader(header);
							});
						} else {
							handleHeader(content.binding.header);
						}

					}

					if (content.binding.body) {

						proto.$properties.body = {
							$title: "Body",
							$isMandatory: true,
							$type: "application/x-object",
							$item: {
								$properties: {}
							}
						};

						var bodyMsgName;
						if (content.binding.body.$) operationInstance[content.type + "BodyEncoding"](_, content.binding.body.$.use);
						if (content.portType.$ && content.portType.$.message) {
							bodyMsgName = content.portType.$.message;
							operationInstance[content.type + "BodyName"](_, bodyMsgName);

							var splited = splitNs(bodyMsgName);
							//
							var nsUrl = content.binding.body.$ && content.binding.body.$.namespace;
							var nsPrefix = nsUrl && getNamespacePrefix(nsUrl);
							var ns = nsPrefix && nsUrl ? nsPrefix + ":" + nsUrl : null;
							if (!ns) {
								nsPrefix = splited.ns;
								nsUrl = getNamespaceUrl(nsPrefix);
								ns = nsPrefix && nsUrl ? nsPrefix + ":" + nsUrl : null;
							}
							if (!ns) {
								throw new Error("no ns found");
							}
							proto.$properties.body.$xmlns = ns;

							var msgName = splited.type;

							var message = getMessage(msgName);
							var messagePart = getSubNode(message, wsdlNs, 'part');
							if (Array.isArray(messagePart)) {
								messagePart.forEach(function(mp) {
									readMsgPart(mp, proto.$properties.body);
								});
							} else if (messagePart) {
								readMsgPart(messagePart, proto.$properties.body);
							}

						} else {
							throw new Error(locale.format(module, "attMsgNotFound", content.type, operationName));
						}

					}

					//////

					storePrototype(_, operationName + "_" + facet, store, JSON.stringify(proto, null, 2));

				} // End createPrototype

				function storePrototype(_, prototypeName, instanceProperty, proto) {
					tracer.debug && tracer.debug("\n");
					tracer.debug && tracer.debug("--------------------------------------------------");
					tracer.debug && tracer.debug("|   Create Prototype: " + prototypeName);
					tracer.debug && tracer.debug("--------------------------------------------------");
					tracer.debug && tracer.debug(JSON.stringify(proto, null, 2));

					// Store WSDL
					if (!instanceProperty.fileExists(_)) {
						var buf = new Buffer(proto, 'utf8').toString('binary');
						if (buf != null && buf.length !== 0) {
							var props = {
								length: buf.length,
								contentType: "application/json",
								fileName: prototypeName + ".json"
							};
							var store = instanceProperty;
							var stream = store.createWritableStream(_, props);
							stream.write(_, buf, "binary");
							stream.write(_, null);
						}
					} else {
						throw new Error(locale.format(module, "fileAlreadyExists"));
					}

				} // End storePrototype

				function getPortTypeOperation(opName) {
					if (Array.isArray(portTypeOperations)) {
						for (var i in portTypeOperations) {
							if (portTypeOperations[i].$.name === opName) return portTypeOperations[i];
						}
					} else {
						if (portTypeOperations.$.name === opName) return portTypeOperations;
					}
					throw new Error(locale.format(module, "portTypeOperationNotFound", opName));
				}
				//
				//
				var operationName = bindingOperation.$.name;
				var portTypeOperation = getPortTypeOperation(operationName);
				tracer.debug && tracer.debug("\n");
				tracer.debug && tracer.debug("--------------------------------------------------");
				tracer.debug && tracer.debug("|    - Add Operation: " + operationName);
				tracer.debug && tracer.debug("--------------------------------------------------");


				var entity = model.getEntity(_, "soapStubOperation");
				var operationInstance = entity.factory.createInstance(_, null, db);

				operationInstance.name(_, operationName);
				var documentation = getSubNode(portTypeOperation, wsdlNs, 'documentation');
				documentation = (documentation && documentation.$value) || documentation;
				operationInstance.description(_, documentation);

				// Set URL of Tester
				operationInstance.tester(_, "/" + self.dispatcher + "/syracuse/collaboration/syracuse/" + self.name + "/" + port.$.name + "/" + operationName + "?representation=" + operationName + ".$request");

				var opInfos = getSubNode(bindingOperation, protocolNs, 'operation');

				if (protocol === __soap || protocol === __soap12) {
					if (opInfos && opInfos.$) {
						operationInstance.soapAction(_, opInfos.$.soapAction);
						operationInstance.style(_, opInfos.$.style || (subBindingNode ? subBindingNode.$.style : "document"));
					} else {
						operationInstance.style(_, subBindingNode ? subBindingNode.$.style : "document");
					}

					// Force soapAction even if not given in wsdl
					if (!operationInstance.soapAction(_) || operationInstance.soapAction(_) === "") {
						operationInstance.soapAction(_, bindingOperation.$.name);
					}
				}
				// Not supported
				else if (protocol === __http || protocol === __http2) {
					if (opInfos && opInfos.$) operationInstance.location(_, opInfos.$.location);
				} else {
					throw new Error(locale.format(module, "protocolNotSupported", definitions.$["xmlns:" + protocol]));
				}

				var bindingInput = getSubNode(bindingOperation, wsdlNs, 'input');
				var bindingOutput = getSubNode(bindingOperation, wsdlNs, 'output');
				var bindingFault = getSubNode(bindingOperation, wsdlNs, 'fault');

				var input = {
					type: "input",
					binding: {
						header: getSubNode(bindingInput, protocolNs, 'header'),
						body: getSubNode(bindingInput, protocolNs, 'body')
					},
					portType: getSubNode(portTypeOperation, wsdlNs, 'input')
				};
				createPrototype(_, input, operationInstance.requestPrototype(_), "$request");

				var output = {
					type: "output",
					binding: {
						header: getSubNode(bindingOutput, protocolNs, 'header'),
						body: getSubNode(bindingOutput, protocolNs, 'body')
					},
					portType: getSubNode(portTypeOperation, wsdlNs, 'output')
				};
				createPrototype(_, output, operationInstance.responsePrototype(_), "$response");

				//				var fault = {
				//					type: "fault",
				//					binding: {
				//						fault: getSubNode(bindingFault, protocolNs, 'fault')
				//					},
				//					portType: getSubNode(portTypeOperation, wsdlNs, 'fault')
				//				};
				//				createPrototype(_, fault, operationInstance.faultPrototype(_), "$fault");
				//				

				//console.log("OPERATION SERIALIZED:"+JSON.stringify(operationInstance.serializeInstance(_),null,2));

				portInstance.operations(_).set(_, operationInstance);

			} // End addOperation

			var protocolNs, protocol, location;
			Object.keys(port).forEach_(_, function(_, key) {
				if (key.indexOf(":address") !== -1) {
					protocolNs = key.split(':')[0];
					protocol = definitions.$["xmlns:" + protocolNs];
					location = port[key].$.location;
				}
			});

			if (!protocol) throw new Error(locale.format(module, "portProtocolNotFound"));

			if (!location) throw new Error(locale.format(module, "portLocationNotFound"));

			if (protocol === __soap || protocol === __soap12) {
				tracer.debug && tracer.debug("\n");
				tracer.debug && tracer.debug("##################################################");
				tracer.debug && tracer.debug("#    Add Port: " + port.$.name);
				tracer.debug && tracer.debug("##################################################");

				var soapStubPortEntity = model.getEntity(_, "soapStubPort");
				var portInstance = soapStubPortEntity.factory.createInstance(_, null, db);

				portInstance.name(_, port.$.name);

				portInstance.protocol(_, protocol);
				portInstance.location(_, location);

				// Get binding infos
				var bindingName = port.$.binding.indexOf(':') !== -1 ? port.$.binding.split(':')[1] : port.$.binding;
				var binding = getBinding(bindingName);

				var subBindingNode = getSubNode(binding, protocolNs, 'binding');
				// Set transport protocol
				var transport;
				if (subBindingNode) {
					transport = subBindingNode.$.transport;
					if (transport) {
						portInstance.transport(_, transport);
					} else {
						portInstance.transport(_, __soapHttp);
					}
					portInstance.method(_, "POST");
					//					if (protocol.indexOf(__http) === 0 || protocol.indexOf(__http2) === 0){
					//						var verb = subBindingNode.$.verb;
					//						portInstance.method(_, verb);
					//					}else{
					//						portInstance.method(_, "POST");
					//					}
				} else {
					portInstance.transport(_, __soapHttp);
					portInstance.method(_, "POST");
				}

				// Get portType Infos
				var portTypeName = binding.$.type.indexOf(':') !== -1 ? binding.$.type.split(':')[1] : binding.$.type;
				var portType = getPortType(portTypeName);
				var portTypeOperations = getSubNode(portType, wsdlNs, 'operation');

				// Register operations
				var bindingOperations = getSubNode(binding, wsdlNs, 'operation');
				if (Array.isArray(bindingOperations)) {
					bindingOperations.forEach_(_, function(_, op) {
						addOperation(_, op);
					});
				} else {
					addOperation(_, bindingOperations);
				}

				//console.log("PORT:"+JSON.stringify(portInstance.serializeInstance(_),null,2));

				//self.ports.push(portInstance);
				self.instance.ports(_).set(_, portInstance);
			} else {
				addWarning(locale.format(module, "portProtocolNotSupported", protocol, port.$.name));
			}
		}

		var self = this;
		var db = adminHelper.getCollaborationOrm(_);
		var model = db.model;

		var wsdl = jsxml.parse(self.wsdl);
		//console.log("WSDL="+JSON.stringify(wsdl,null,2));
		var rootNode = Object.keys(wsdl)[0];

		var wsdlNs = rootNode.split(':').length === 2 ? rootNode.split(':')[0] : "";

		var definitions = getSubNode(wsdl, wsdlNs, 'definitions');
		var types = getSubNode(definitions, wsdlNs, 'types');
		var messages = getSubNode(definitions, wsdlNs, 'message');
		var portTypes = getSubNode(definitions, wsdlNs, 'portType');
		var bindings = getSubNode(definitions, wsdlNs, 'binding');
		var service = getSubNode(definitions, wsdlNs, 'service');

		self.instance.description(_, service.documentation || "");
		var xsdNs = getNamespacePrefix(__XMLSchema);

		// RESET DOESN'T WORK !!!
		//instance.ports(_).reset(_);
		var instPorts = self.instance.ports(_);
		for (var rel in instPorts._data) {
			instPorts.deleteInstance(_, rel);
		}

		var ports = getSubNode(service, wsdlNs, 'port');

		if (Array.isArray(ports)) {
			ports.forEach_(_, function(_, p) {
				addPort(_, p);
			});
		} else {
			addPort(_, ports);
		}

	}

});

exports.create = function(_, instance, wsdl) {
	try {

		var stub = new StubHelper(_, instance, wsdl);
		//console.log(wsdl);
		stub.parseWsdl(_);
		return stub;
	} catch (e) {
		tracer.error && tracer.error(e);
		throw new Error(e.message);
	}
};