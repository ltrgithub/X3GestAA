"use strict";

var helpers = require("syracuse-core/lib/helpers");
var locale = require("syracuse-core/lib/locale");
var forEachKey = helpers.object.forEachKey;
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var stubUtils = require("syracuse-soap/lib/client/stubUtils");
var cliManager = require("syracuse-soap/lib/generic/clientManager");
var tracer = require("syracuse-trace/lib/helper").getTracer("soap-generic.request");

var callMap = {
	CAdxWebServiceXmlCC: {
		"run": function(action, params) {
			return {
				name: params.publicName,
				flow: params.inputXml,
				action: action
			};
		},
		"save": function(action, params) {
			return {
				name: params.publicName,
				flow: params.objectXml,
				action: action
			};
		},
		"delete": function(action, params) {
			return {
				name: params.publicName,
				wkeys: params.objectKeys,
				action: action
			};
		},
		"read": function(action, params) {
			return {
				name: params.publicName,
				wkeys: params.objectKeys,
				action: action
			};
		},
		"query": function(action, params) {
			return {
				name: params.publicName,
				wkeys: params.objectKeys,
				nb: params.listSize,
				action: action
			};
		},
		"getDescription": function(action, params) {
			return {
				name: params.publicName,
				action: action,
			};
		},
		"modify": function(action, params) {
			return {
				name: params.publicName,
				wkeys: params.objectKeys,
				flow: params.objectXml,
				action: action
			};
		},
		"actionObject": function(action, params) {
			return {
				name: params.publicName,
				flow: params.objectXml,
				action: params.actionCode
			};
		},
		"actionObjectKeys": function(action, params) {
			return {
				name: params.publicName,
				wkeys: params.objectKeys,
				action: params.actionCode
			};
		},
		"insertLines": function(action, params) {
			return {
				name: params.publicName,
				wkeys: params.objectKeys,
				tab: params.blocKey,
				par: params.lineKey,
				flow: params.lineXml,
				action: action
			};
		},
		"deleteLines": function(action, params) {
			return {
				name: params.publicName,
				wkeys: params.objectKeys,
				tab: params.blocKey,
				par: params.lineKeys,
				action: action
			};
		}
	}
};

// Mapping between operations and actions
var actionMap = {
	run: "EXEC",
	save: "CREATE",
	delete: "DELETE",
	read: "READ",
	query: "LIST",
	getDescription: "GETDESCR",
	modify: "MODIFY",
	actionObject: null, // specific
	actionObjectKeys: null, // specific
	getDataXmlSchema: "GETSCHEMA",
	insertLines: "INSLIG",
	deleteLines: "SUPLIG"
};


function validateProperties(properties, params) {
	function validateProperty(_property, _param, key) {

		if (_property.$isMandatory && _param === undefined) {
			throw new Error(locale.format(module, "mandatoryProperty", _property.$title));
		}
		if (_property.$type === "application/x-object") {
			//tracer.warn && tracer.warn(JSON.stringify(_property,null,2));
			return validateProperties(_property.$item.$properties, _param);
		} else if (_property.$type === "application/x-array") {
			var arr = [];

			if (_param.item) {
				if (Array.isArray(_param.item)) {
					_param.item.forEach(function(it) {
						var p;
						if (typeof it === "object") {
							p = validateProperties(_property.$item.$properties, it);
						} else {
							p = stubUtils.convertValue(_property.$item.$properties[key].$title, _property.$item.$properties[key].$type, it);
						}
						arr.push(p);
					});
				} else {
					var p;
					if (typeof _param.item === "object") {
						p = validateProperties(_property.$item.$properties, _param.item);
					} else {
						p = stubUtils.convertValue(_property.$item.$properties[key].$title, _property.$item.$properties[key].$type, _param.item);
					}
					arr.push(p);
				}
			}
			return arr;
		} else {
			return stubUtils.convertValue(_property.$title, _property.$type, _param);
		}
	}
	var result = {};
	forEachKey(properties, function(key, value) {
		result[key] = validateProperty(value, params[key], key);
	});
	return result;
}

var AckcallExecutor = helpers.defineClass(function(serviceName) {
	this.serviceName = serviceName;
	this.reqProto = {};
}, null, {
	_setSessionContext: function(_, callContext, context) {
		var sessionContext = context.httpSession.genericWsCtx = context.httpSession.genericWsCtx || {};
		var up = context.getUserProfile(_);

		if (callContext) {
			// locale
			if (callContext.codeLang) {
				var x3lang = callContext.codeLang;
				var iso = locale.defaultIso(x3lang);
				if (!iso) throw new Error(locale.format, "langIncorrect", x3lang);
				if (iso.length === 2) iso = locale.longIso(iso);
				locale.setCurrent(_, iso);
				if (!sessionContext.localePref || sessionContext.localePref.code(_) !== iso) {
					var codeIso = iso.substring(0, 3) + iso.substring(3).toUpperCase();
					tracer.info && tracer.info("Use language: " + codeIso);
					var db = adminHelper.getCollaborationOrm(_);
					sessionContext.localePref = db.fetchInstances(_, db.model.getEntity(_, "localePreference"), {
						jsonWhere: {
							code: codeIso
						}
					})[0];
				}
			} else {
				sessionContext.localePref = up.selectedLocale();
			}
			sessionContext.x3Lang = sessionContext.localePref.code(_);

			// endpoint
			if (!callContext.poolAlias) throw new Error(locale.format(module, "poolAliasMissing"));
			var epName = callContext.poolAlias;

			if (!sessionContext.endpoint || sessionContext.endpoint.dataset(_) !== epName) {
				sessionContext.endpoint = adminHelper.getEndpoint(_, {
					dataset: epName
				});
				if (!sessionContext.endpoint) throw new Error(locale.format(module, "noEndpointMatch", epName));
				sessionContext.dataset = sessionContext.endpoint.dataset(_);
			}

			// user
			if (!sessionContext.user || sessionContext.user.login(_) !== up.user(_).login(_)) {
				var user = up.user(_);
				sessionContext.user = user;
				sessionContext.x3User = user.getEndpointLogin(_, sessionContext.endpoint.$uuid);
			}
		} else {
			throw new Error(locale.format(module, "noCallContext"));
		}
	},
	execute: function(_, context, method, params, techInfo) {
		// Check soap action
		var func = callMap[this.serviceName] && callMap[this.serviceName][method];
		if (!func) throw new Error(locale.format(module, "invalidSoapAction", method));

		// Set context (in session)
		this._setSessionContext(_, params.callContext, context);

		// Reuse or store request prototype in Executor instance
		this.reqProto[method] = this.reqProto[method] || stubUtils.getOperationPrototype(_, this.serviceName, this.serviceName, method, "$request", context, "generic-in");
		if (!this.reqProto[method]) throw new Error(locale.format(module, "errGetProto", method, "request"));

		// Validate received parameters with expected properties + convert values
		var requestProperties = this.reqProto[method].$properties.body.$item.$properties[method].$item.$properties;
		if (!requestProperties) throw new Error(locale.format(module, "reqPropsNotFound", this.reqProto[method].$descriptor));


		params = validateProperties(requestProperties, params);

		var response = {
			$: {
				"xmlns": "TODO"
			}
		};


		// transform parameters
		var transformed = func(actionMap[method], params);

		tracer.debug && tracer.debug("\n");
		tracer.debug && tracer.debug("##################################################");
		tracer.debug && tracer.debug("#    Execute Ackcall for method : " + method);
		tracer.debug && tracer.debug("##################################################");
		tracer.debug && tracer.debug("# Parameters : " + JSON.stringify(transformed, null, 2));

		// Select a client
		techInfo.poolDistribDuration.start();
		var wsClient = cliManager.selectClient(context);
		if (!wsClient) wsClient = cliManager.createClient(_, context);
		techInfo.poolDistribDuration.stop();

		// Execute ackcall
		var wsCall = wsClient.execWs(_, context, transformed, techInfo, true);

		var resultName = "resultXml";
		response[resultName] = {};
		if (wsCall.result) {
			response[resultName].$cdata = wsCall.result;
		} else {
			response[resultName].$value = null;
		}
		response.messages = wsCall.messages;
		response.status = wsCall.status;

		return response;
	},
});

exports.create = function(serviceName) {
	return new AckcallExecutor(serviceName);
};