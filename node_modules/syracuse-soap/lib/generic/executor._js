"use strict";

var helpers = require("syracuse-core/lib/helpers");
var locale = require("syracuse-core/lib/locale");
var parser = require('syracuse-sdata/lib/parser/parser');
var flows = require('streamline-runtime').flows;
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var poolManager = require("syracuse-soap/lib/generic/poolManager");
var querystring = require('querystring');
var jsxml = require('js-xml');
var forEachKey = helpers.object.forEachKey;
var soapUtils = require('../server/soapUtils');
var soapTools = require('../common/soapTools');
var stubUtils = require("syracuse-soap/lib/client/stubUtils");
var WsCall = require('syracuse-soap/lib/generic/wsCall').WsCall;
var check = require('syracuse-license/lib/check');
var tracer = require("syracuse-trace/lib/helper").getTracer("soap-generic.request");

var __soapEnc = "http://schemas.xmlsoap.org/soap/encoding/";
var __soapEnv = "http://schemas.xmlsoap.org/soap/envelope/";
var __soapSage = "http://www.adonix.com/WSS";
var __soapXsd = "http://www.w3.org/2001/XMLSchema";
var __soapXsi = "http://www.w3.org/2001/XMLSchema-instance";

var callMap = {
	CAdxWebServiceXmlCC: {
		"run": function(action, params) {
			return {
				name: params.publicName,
				flow: params.inputXml,
				action: action
			};
		},
		"save": function(action, params) {
			return {
				name: params.publicName,
				flow: params.objectXml,
				action: action
			};
		},
		"delete": function(action, params) {
			return {
				name: params.publicName,
				wkeys: params.objectKeys,
				action: action
			};
		},
		"read": function(action, params) {
			return {
				name: params.publicName,
				wkeys: params.objectKeys,
				action: action
			};
		},
		"query": function(action, params) {
			return {
				name: params.publicName,
				wkeys: params.objectKeys,
				nb: params.listSize,
				action: action
			};
		},
		"getDescription": function(action, params) {
			return {
				name: params.publicName,
				action: action,
			};
		},
		"getDataXmlSchema": function(action, params) {
			return {
				name: params.publicName,
				action: action,
			};
		},
		"modify": function(action, params) {
			return {
				name: params.publicName,
				wkeys: params.objectKeys,
				flow: params.objectXml,
				action: action
			};
		},
		"actionObject": function(action, params) {
			return {
				name: params.publicName,
				flow: params.objectXml,
				action: params.actionCode
			};
		},
		"actionObjectKeys": function(action, params) {
			return {
				name: params.publicName,
				wkeys: params.objectKeys,
				action: params.actionCode
			};
		},
		"insertLines": function(action, params) {
			return {
				name: params.publicName,
				wkeys: params.objectKeys,
				tab: params.blocKey,
				par: params.lineKey,
				flow: params.lineXml,
				action: action
			};
		},
		"deleteLines": function(action, params) {
			return {
				name: params.publicName,
				wkeys: params.objectKeys,
				tab: params.blocKey,
				par: params.lineKeys,
				action: action
			};
		}
	}
};



// Mapping between operations and actions
var actionMap = {
	run: "EXEC",
	save: "CREATE",
	delete: "DELETE",
	read: "READ",
	query: "LIST",
	getDescription: "GETDESCR",
	modify: "MODIFY",
	actionObject: null, // specific
	actionObjectKeys: null, // specific
	getDataXmlSchema: "GETSCHEMA",
	insertLines: "INSLIG",
	deleteLines: "SUPLIG"
};

function removeNamespaces(node) {
	var obj = Array.isArray(node) ? [] : {};
	// remove namespaces
	forEachKey(node, function(key, value) {
		if (key.indexOf(':') !== -1) {
			var keyParts = key.split(':');
			obj[keyParts[1]] = value != null && typeof value === "object" ? removeNamespaces(value) : value;
		} else {
			obj[key] = value != null && typeof value === "object" ? removeNamespaces(value) : value;
		}
	});
	return obj;
}

function validateProperties(properties, params) {
	function validateProperty(_property, _param, key) {

		if (_property.$isMandatory && _param === undefined) {
			throw new Error(locale.format(module, "mandatoryProperty", _property.$title));
		}
		if (_property.$type === "application/x-object") {
			//tracer.warn && tracer.warn(JSON.stringify(_property,null,2));
			return validateProperties(_property.$item.$properties, _param);
		} else if (_property.$type === "application/x-array") {
			var arr = [];
			var _itm = _param && (_param.item || _param.Item);
			var arrVal = _param ? (_itm ? _itm : _param) : null;
			if (arrVal) {
				if (Array.isArray(arrVal)) {
					arrVal.forEach(function(it) {
						var p;
						if (typeof it === "object") {
							p = validateProperties(_property.$item.$properties, it);
						} else {
							p = stubUtils.convertValue(_property.$item.$properties[key].$title, _property.$item.$properties[key].$type, it);
						}
						arr.push(p);
					});
				} else {
					var p;
					if (typeof arrVal === "object") {
						p = validateProperties(_property.$item.$properties, arrVal);
					} else {
						if (_property.$item.$properties[key]) {
							p = stubUtils.convertValue(_property.$item.$properties[key].$title, _property.$item.$properties[key].$type, arrVal);
						}
					}
					if (p) arr.push(p);
				}
			}
			return arr;
		} else {
			return stubUtils.convertValue(_property.$title, _property.$type, _param);
		}
	}
	var result = {};
	if (params) forEachKey(properties, function(key, value) {
		result[key] = validateProperty(value, params[key], key);
	});
	return result;
}

function canReadInstance(_, context, instance) {
	var sp = context && context.httpSession && context.httpSession.getSecurityProfile(_);
	if (sp) {
		var r = sp.canReadClass(_, instance.getEntity(_).name);
		if (typeof r === "boolean") {
			if (r === false) {
				return false;
			}
		} else {
			r = sp.replacePredefinedVars(_, r);
			return instance.match(_, parser.Parser.parse(r));
		}
	}
	return true;
}

var respMap = {
	CAdxWebServiceXmlCC: function(wsCall) {
		var response = {
			resultXml: {}
		};
		if (wsCall.result) {
			response.resultXml.$cdata = wsCall.result;
		} else {
			response.resultXml.$value = null;
		}
		response.messages = wsCall.messages;
		response.status = wsCall.status;
		return response;
	}
};

var AckcallExecutor = helpers.defineClass(function(serviceName) {
	this.serviceName = serviceName;
	this.ws;
	this.reqProto = {};
	this.respProto = {};
	tracer.info && tracer.info("Create Executor for service: " + serviceName);
}, null, {
	_setSessionContext: function(_, callContext, context) {
		var up = context.getUserProfile(_);
		if (callContext) {
			var sessionContext = {};
			var db = adminHelper.getCollaborationOrm(_);
			// locale
			var acceptLang;
			// do not consider accept-language with tester
			if (!context.httpSession.wstester) forEachKey(context.request.headers, function(key, value) {
				if (key.toLowerCase() === "accept-language") acceptLang = value;
			});
			if (acceptLang || !callContext.codeLang) {
				var userPrefs = up.user(_).getPreferences(_);
				if (userPrefs) userPrefs.lastLocaleCode(_, (acceptLang || "").split(",")[0]);
				var localeCode = (userPrefs && userPrefs.lastLocaleCode(_)) || "en-US";
				if (localeCode) up.selectedLocale(_, up.user(_).getUserLocaleByCode(_, localeCode) || up.user(_).getUserLocaleByCode(_, "en-US"));

				sessionContext.localePref = up.selectedLocale(_);
				sessionContext.x3language = locale.x3Language(sessionContext.localePref.code(_));
			} else if (callContext.codeLang) {
				sessionContext.x3language = callContext.codeLang;
				var iso = locale.defaultIso(sessionContext.x3language);
				if (!iso) throw new Error(locale.format(module, "langIncorrect", sessionContext.x3language));
				if (iso.length === 2) iso = locale.longIso(iso);
				locale.setCurrent(_, iso);
				if (!sessionContext.localePref || sessionContext.localePref.code(_) !== iso) {
					var codeIso = iso.substring(0, 3) + iso.substring(3).toUpperCase();
					tracer.debug && tracer.debug("Use language: " + codeIso);

					sessionContext.localePref = db.fetchInstances(_, db.model.getEntity(_, "localePreference"), {
						jsonWhere: {
							code: codeIso
						}
					})[0];
				}
			}
			sessionContext.x3Lang = sessionContext.localePref.code(_);
			// endpoint
			if (!callContext.poolAlias) throw new Error(locale.format(module, "poolAliasMissing"));
			var poolAlias = callContext.poolAlias;
			sessionContext.poolAlias = callContext.poolAlias;
			if (!sessionContext.endpoint || !sessionContext.pool || sessionContext.pool.alias(_) !== poolAlias) {
				sessionContext.pool = db.fetchInstance(_, db.model.getEntity(_, "soapClassicPool"), {
					jsonWhere: {
						alias: poolAlias
					}
				});
				if (!sessionContext.pool) throw new Error(locale.format(module, "noPoolMatch", poolAlias));

				if (!canReadInstance(_, context, sessionContext.pool)) {
					throw new Error(locale.format(module, "noPoolRight", poolAlias));
				}

				sessionContext.endpoint = sessionContext.pool.endpoint(_);
			}

			// user
			if (!sessionContext.user || sessionContext.user.login(_) !== up.user(_).login(_)) {
				var user = up.user(_);
				sessionContext.user = user;
				sessionContext.x3User = user.getEndpointLogin(_, sessionContext.endpoint.$uuid);
			}

			// to force client pid
			if (callContext.poolId != null) {
				sessionContext.pid = callContext.poolId;
			}

			return sessionContext;
		} else {
			throw new Error(locale.format(module, "noCallContext"));
		}
	},
	intercept: function(_, context) {
		var response, responseRoot, useSoapStyle, wsCall, responseProperties, responseNodeName, returnNodeName;
		try {
			wsCall = new WsCall();
			// start total timer
			wsCall.techInfo.totalDuration.start();

			this.ws = this.ws || soapUtils.getSoapWebService(_, this.serviceName, context, "soapGeneric");
			if (!this.ws) throw new Error(locale.format(module, "wsNotFound", this.serviceName));

			var reqHeader = context.request.headers;
			tracer.debug && tracer.debug("Header : " + JSON.stringify(reqHeader, null, 2));

			if (!reqHeader.soapaction) throw new Error(locale.format(module, "soapActMissing"));
			var soapAction = reqHeader.soapaction.replace(/\"/g, '');

			var reqBody = context.request.readAll(_);
			var reqSize = reqBody.length;
			tracer.debug && tracer.debug("Body : " + reqBody);



			useSoapStyle = reqBody.indexOf(__soapEnc) !== -1;
			tracer.debug && tracer.debug("Soap encoding style enabled: " + useSoapStyle);

			// translate request
			tracer.debug && tracer.debug("\n");
			tracer.debug && tracer.debug("##################################################");
			tracer.debug && tracer.debug("#    Translate SOAP Action : " + soapAction);
			tracer.debug && tracer.debug("##################################################");
			reqBody = jsxml.parse(reqBody);

			// get namespaces
			var reqEnv = reqBody[Object.keys(reqBody)[0]];
			var ns = {
				soapenv: soapTools.getNamespacePrefix(reqEnv, __soapEnv),
				soapenc: soapTools.getNamespacePrefix(reqEnv, __soapEnc),
			};
			// translate request to be compliant with soap encoding
			var soapRequest = soapTools.translateRequest(reqBody, ns, useSoapStyle);
			tracer.debug && tracer.debug("# " + JSON.stringify(reqBody, null, 2));

			// Do not need ns
			var opRequest = removeNamespaces(soapRequest.body);
			if (!opRequest) throw new Error(locale.format(module, "requestNotFound"));
			var method = Object.keys(opRequest)[0];


			tracer.info && tracer.info("Web service call: name: " + this.serviceName + " - operation: " + method);
			// Reuse or store request prototype in Executor instance
			this.reqProto[method] = this.reqProto[method] || stubUtils.getOperationPrototype(_, this.serviceName, this.serviceName, method, "$request", context, "generic-in");
			if (!this.reqProto[method]) throw new Error(locale.format(module, "errGetProto", method, "request"));
			this.respProto[method] = this.respProto[method] || stubUtils.getOperationPrototype(_, this.serviceName, this.serviceName, method, "$response", context, "generic-in");
			if (!this.respProto[method]) throw new Error(locale.format(module, "errGetProto", method, "response"));


			// Validate received parameters with expected properties + convert values
			var requestProperties = this.reqProto[method].$properties.body.$item.$properties[method].$item.$properties;
			if (!requestProperties) throw new Error(locale.format(module, "propsNotFound", this.reqProto[method].$descriptor));

			responseNodeName = Object.keys(this.respProto[method].$properties.body.$item.$properties)[0];
			returnNodeName = Object.keys(this.respProto[method].$properties.body.$item.$properties[responseNodeName].$item.$properties)[0];

			responseProperties = this.respProto[method].$properties.body.$item.$properties[responseNodeName].$item.$properties[returnNodeName].$item.$properties;
			if (!responseProperties) throw new Error(locale.format(module, "propsNotFound", this.respProto[method].$descriptor));

			opRequest[method] = validateProperties(requestProperties, opRequest[method]);

			responseRoot = {};
			responseRoot[responseNodeName] = {};

			tracer.debug && tracer.debug("\n");
			tracer.debug && tracer.debug("##################################################");
			tracer.debug && tracer.debug("#    Intercept SOAP Request for service : " + this.serviceName);
			tracer.debug && tracer.debug("##################################################");

			// execute request
			var params = opRequest[method];

			// Check soap action
			var func = callMap[this.serviceName] && callMap[this.serviceName][method];
			if (!func) throw new Error(locale.format(module, "invalidSoapAction", method));

			// hack to take correct language with tester on nanny mode
			if (context.request.headers.authorization && context.request.headers.authorization.indexOf("Nanny") === 0) context.httpSession.wstester = true;

			// Set context (no more in session)
			wsCall.context = this._setSessionContext(_, params.callContext, context);

			// example of request config
			//adxwss.trace.on=on&adxwss.trace.size16384&adonix.trace.on=on&adonix.trace.level=3&adonix.trace.size=8&adxwss.optreturn=XML

			var options = {};
			if (params.callContext && params.callContext.requestConfig) {
				options.requestConfig = querystring.parse(params.callContext.requestConfig);
				tracer.debug && tracer.debug("Request config parameters: " + JSON.stringify(options.requestConfig, null, 2));
			}

			// transform parameters
			var transformed = func(actionMap[method], params);

			tracer.debug && tracer.debug("\n");
			tracer.debug && tracer.debug("##################################################");
			tracer.debug && tracer.debug("#    Execute Ackcall for method : " + method);
			tracer.debug && tracer.debug("##################################################");
			tracer.debug && tracer.debug("# Parameters : " + JSON.stringify(transformed, null, 2));

			// Select a client
			wsCall.techInfo.poolWaitDuration.start();
			wsCall.techInfo.poolRequestDuration.start();
			// Init start time in traceRequest
			wsCall.techInfo.traceRequest.init(wsCall.techInfo.poolRequestDuration.startTime);

			var poolAlias = wsCall.context.pool.alias(_);
			var pool = poolManager.getPool(poolAlias);
			if (!pool) throw new Error("No Pool: " + poolAlias);

			// set pool metadata into call context
			wsCall.context.poolMetadata = pool.metadata;

			// Consider request flow into license counter
			if (!context.httpSession.wstester) check.step(_, reqSize, wsCall.context.poolMetadata);

			var wsClient = pool.alloc(_, context, wsCall);
			wsCall.techInfo.poolDistribDuration.stop();
			// Initialize call
			wsCall.init(transformed, options.requestConfig);
			// Execute ackcall
			wsClient.execWs(_, context, wsCall);
			//
			//
			response = responseRoot[responseNodeName][returnNodeName] = respMap[this.serviceName](wsCall);
		} catch (e) {
			if (!response && (!responseRoot || !responseNodeName || !returnNodeName)) throw e;
			tracer.error && tracer.error(e.message, e);
			wsCall.addMessage(4, e.message);
			wsCall.status = 0;
			response = responseRoot[responseNodeName][returnNodeName] = respMap[this.serviceName](wsCall);
		}
		// translate response to be compliant with soap encoding
		responseRoot = soapTools.translateResponse(responseRoot, responseProperties, useSoapStyle);


		// end of pool request
		wsCall.techInfo.poolRequestDuration.stop();

		var envelope = {
			"soapenv:Envelope": {
				$: {
					"xmlns:soapenv": __soapEnv,
					"xmlns:xs": __soapXsd,
					"xmlns:xsi": __soapXsi,
					"xmlns:soapenc": __soapEnc,
					"xmlns:wss": __soapSage
				},
				"soapenv:Body": {}
			}
		};

		// build envelope
		envelope["soapenv:Envelope"]["soapenv:Body"] = responseRoot;
		wsCall.techInfo.totalDuration.stop();

		// set technical informations in response flow
		if (response) response.technicalInfos = wsCall.techInfo.stringify();
		var soapResponse = jsxml.stringify(envelope);
		tracer.info && tracer.info("End call");
		soapResponse = '<?xml version="1.0" encoding="utf-8"?>' + soapResponse;
		tracer.debug && tracer.debug("\n");
		tracer.debug && tracer.debug("##################################################");
		tracer.debug && tracer.debug("#    Send SOAP Reply  : ");
		tracer.debug && tracer.debug("##################################################");
		tracer.debug && tracer.debug(soapResponse);



		var bufResp = new Buffer(soapResponse, "utf8");

		// Manage license
		if (wsCall.context && wsCall.context.poolMetadata) {
			var licenseCheck = 0;

			if (!context.httpSession.wstester) {
				var traceRequest = wsCall.techInfo.traceRequest.stringify();
				var traceReqSize = traceRequest && traceRequest.length > 0 ? new Buffer(wsCall.techInfo.traceRequest.stringify(), "utf8").length : 0;
				var sizeToConsider = bufResp.length - traceReqSize;
				licenseCheck = check.step(_, sizeToConsider, wsCall.context.poolMetadata);
			} else {
				tracer.info && tracer.info("Ignore licensing with internal tester");
			}

			// Web services system will blocked --> the grace limit is exceeded
			if (licenseCheck < 0) {
				wsCall.status = 0;
				wsCall.result = null;
				wsCall.addMessage(3, locale.format(module, "systemBlocked", "WSGRACELIMIT"));
				response = responseRoot[responseNodeName][returnNodeName] = respMap[this.serviceName](wsCall);
				// reserialize final response to update last information
				if (response) {
					delete response.technicalInfos;
					//response.technicalInfos = wsCall.techInfo.stringify();
				}
				soapResponse = jsxml.stringify(envelope);
				bufResp = new Buffer(soapResponse, "utf8");
			}

			// web service system will be slown down
			else if (licenseCheck > 0) {
				// if poolRequestDuration is not set, it means that an error occured, so do not need to slow the system
				if (wsCall.techInfo && wsCall.techInfo.poolRequestDuration && wsCall.techInfo.poolRequestDuration.value) {
					wsCall.techInfo.totalDuration.start();
					// Web services system will be slowed --> size limit is exceeded
					flows.sleep(_, (licenseCheck - 1) * wsCall.techInfo.poolRequestDuration.value); // N times slower
					wsCall.addMessage(2, locale.format(module, "sizeLimitReached", "WSSIZELIMIT"));
					wsCall.techInfo.totalDuration.stop();

					// reserialize final response to update last information
					if (response) response.technicalInfos = wsCall.techInfo.stringify();
					soapResponse = jsxml.stringify(envelope);
					bufResp = new Buffer(soapResponse, "utf8");
				}
			}
			// else Continue normally
		}
		return bufResp;
	},

});

var executors = [];

function getExecutor(serviceName) {
	executors[serviceName] = executors[serviceName] || new AckcallExecutor(serviceName);
	return executors[serviceName];
}

exports.intercept = function(_, serviceName, context) {
	return getExecutor(serviceName).intercept(_, context);
};