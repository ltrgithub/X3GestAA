"use strict";

var helpers = require("syracuse-core/lib/helpers");
var locale = require("syracuse-core/lib/locale");
var forEachKey = helpers.object.forEachKey;
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var stubUtils = require("syracuse-soap/lib/client/stubUtils");
var CvgClientWS = require('syracuse-x3/lib/clients/soap/CvgClientWS').CvgClientWS;

var tracer = require("syracuse-trace/lib/helper").getTracer("soap-generic.request");

// CvgWSClient are kept in memory here !!!
var WSCLIENTS = [];

// temporary hard coded
var MAXWEBSERVICES = 100;

// scoring system
function getMatchingClient(client, endpoint, user, localePref, context) {
	function sameEndpoint(_, cli) {
		return cli.cliCfg.endpoint.dataset(_) === endpoint.dataset(_);
	}

	function sameUser(_, cli) {
		return cli.cliCfg.user.login(_) === user.login(_);
	}

	function sameLang(_, cli) {
		return cli.cliCfg.x3Lang === localePref.code(_);
	}

	function newClient(_) {
		var newCli = new CvgClientWS(_, endpoint, user, localePref, context);
		WSCLIENTS.push(newCli);
		return newCli;
	}
	//

	// Keep same client if same context (it should be connected !)
	// Check is free two times !!!
	if (client && client.isFree && sameEndpoint(_, client) && sameUser(_, client) && sameLang(_, client) && client.isFree) {
		// Set busy right now to protect it from other callers !!!
		client.isFree = false;
		return client;
	}

	// First filter by endpoint
	var sameEpClients = WSCLIENTS.filter_(_, function(_, cli) {
		return cli.isFree && sameEndpoint(_, cli);
	});

	if (sameEpClients.length === 0) {
		// If not found same endpoint, create new client
		return newClient(_);
	}
	// ckeck free again (in case where filter was applied in the same time than an other caller took it)
	else if (sameEpClients.length === 1 && sameEpClients[0].isFree) {
		// Return if only one client match
		// Set busy right now to protect it from other callers !!!
		sameEpClients[0].isFree = false;
		return sameEpClients[0];
	}

	// Second filter by user
	var sameEpUserClients = sameEpClients.filter_(_, function(_, cli) {
		return cli.isFree && sameUser(_, cli);
	});

	// Return if only one client match
	// ckeck free again (in case where filter was applied in the same time than an other caller took it)
	if (sameEpUserClients.length === 1 && sameEpUserClients[0].isFree) {
		// Set busy right now to protect it from other callers !!!
		sameEpUserClients[0].isFree = false;
		return sameEpUserClients[0];
	} else if (sameEpUserClients.length > 1) {
		// Third filter by lang
		var sameEpUserLangClients = sameEpUserClients.filter_(_, function(_, cli) {
			return cli.isFree && sameLang(_, cli);
		});
		// ckeck free again (in case where filter was applied in the same time than an other caller took it)
		if (sameEpUserLangClients.length === 1 && sameEpUserLangClients[0].isFree) {
			// Return if only one client match
			// Set busy right now to protect it from other callers !!!
			sameEpUserLangClients[0].isFree = false;
			return sameEpUserLangClients[0];
		} else if (sameEpUserLangClients.length > 1) {
			var sameEpUserLangConnectedClients = sameEpUserLangClients.filter_(_, function(_, cli) {
				return cli.isFree && cli.isConnected;
			});
			if (sameEpUserLangConnectedClients.length > 1) {
				// Return randomly the first of the list
				// Set busy right now to protect it from other callers !!!
				sameEpUserLangConnectedClients[0].isFree = false;
				return sameEpUserLangConnectedClients[0];
			}
			// ckeck free again (in case where filter was applied in the same time than an other caller took it)
			else if (sameEpUserLangConnectedClients.length === 1 && sameEpUserLangConnectedClients[0].isFree) {
				// Return if only one client match
				// Set busy right now to protect it from other callers !!!
				sameEpUserLangConnectedClients[0].isFree = false;
				return sameEpUserLangConnectedClients[0];
			} else {
				// filter again epUserLang to be sure of free clients
				sameEpUserLangClients = sameEpUserLangClients.filter_(_, function(_, cli) {
					return cli.isFree;
				});
				// Return randomly the first of the list
				// Set busy right now to protect it from other callers !!!
				sameEpUserLangClients[0].isFree = false;
				return sameEpUserLangClients[0];
			}
		}
	} else {

	}
}




// TODO : Handle pool of clients - funnel and implementation will be here
function findWsClient(_, endpoint, user, localePref, context) {
	return new CvgClientWS(_, endpoint, user, localePref, context);
}



//			response.runReturn = {
//				messages: ["test1", "test2", "test3"],
//				resultXml: "",
//				status: 1,
//				technicalInfos: {
//					busy: false,
//					changeLanguage: false,
//					changeUserId: false,
//					flushAdx: false,
//					loadWebsDuration: 15,
//					nbDistributionCycle: 1,
//					poolDistribDuration: 4,
//					poolEntryIdx: 0,
//					poolExecDuration: 150,
//					poolRequestDuration: 158.26,
//					poolWaitDuration: 3,
//					processReport: null,
//					processReportSize: 0,
//					reloadWebs: false,
//					resumitAfterDBOpen: false,
//					rowInDistribStack: 1,
//					totalDuration: 355,
//					traceRequest: null,
//					traceRequestSize: 0
//				}
//			};




var callMap = {
	CAdxWebServiceXmlCC: {
		"run": function(action, params, response) {
			return {
				name: params.publicName,
				flow: params.inputXml,
				action: action
			};
		},
		"save": function(action, params, response) {
			return {
				name: params.publicName,
				flow: params.objectXml,
				action: action
			};
		},
		"delete": function(action, params, response) {

		},
		"read": function(action, params, response) {
			return {
				name: params.publicName,
				wkeys: params.objectKeys,
				action: action
			};
		},
		"query": function(action, params, response) {
			return {
				name: params.publicName,
				wkeys: params.objectKeys,
				action: action
			};
		},
		"getDescription": function(action, params, response) {

		},
		"modify": function(action, params, response) {

		},
		"actionObject": function(action, params, response) {

		},
		"actionObjectKeys": function(action, params, response) {

		},
		"insertLines": function(action, params, response) {

		},
		"deleteLines": function(action, params, response) {

		}
	}
};



var actionMap = {
	run: "EXEC",
	save: "CREATE",
	delete: "DELETE",
	read: "READ",
	query: "LIST",
	getDescription: "GETDESCR",
	modify: "MODIFY",
	actionObject: "",
	actionObjectKeys: "",
	getDataXmlSchema: "GETSCHEMA",
	insertLines: "INSLIG",
	deleteLines: "SUPLIG"
};


function validateProperties(properties, params) {
	function validateProperty(_property, _param) {
		if (_property.$isMandatory && _param === undefined) {
			throw new Error(locale.format(module, "mandatoryProperty", _property.$title));
		}
		if (["application/x-object", "application/x-array"].indexOf(_property.$type) !== -1) {
			//tracer.warn && tracer.warn(JSON.stringify(_property,null,2));
			validateProperties(_property.$item.$properties, _param);
		}
	}
	forEachKey(properties, function(key, value) {
		validateProperty(value, params[key]);
	});
}

var AckcallExecutor = helpers.defineClass(function(serviceName) {
	this.localePref; // Instance
	this.user; // Instance
	this.endpoint; // Instance
	this.serviceName = serviceName;
	this.messages = [];
}, null, {
	_setCallContext: function(_, callContext) {
		var up = this.context.getUserProfile(_);
		if (!this.user || this.user.login(_) !== up.user(_).login(_)) {
			this.user = up.user(_);
		}
		if (callContext) {
			// locale
			if (callContext.codeLang) {
				var x3lang = callContext.codeLang;
				var iso = locale.defaultIso(x3lang);
				if (!iso) throw new Error(locale.format, "langIncorrect", x3lang);
				if (iso.length === 2) iso = locale.longIso(iso);
				locale.setCurrent(_, iso);
				if (!this.localePref || this.localePref.code(_) !== iso) {
					var codeIso = iso.substring(0, 3) + iso.substring(3).toUpperCase();
					tracer.info && tracer.info("Use language: " + codeIso);
					var db = adminHelper.getCollaborationOrm(_);
					this.localePref = db.fetchInstances(_, db.model.getEntity(_, "localePreference"), {
						jsonWhere: {
							code: codeIso
						}
					})[0];
				}
			} else {
				this.localePref = up.selectedLocale();
			}
			// endpoint
			if (!callContext.poolAlias) throw new Error(locale.format(module, "poolAliasMissing"));
			var epName = callContext.poolAlias;

			if (!this.endpoint || this.endpoint.dataset(_) !== epName) {
				this.endpoint = adminHelper.getEndpoint(_, {
					dataset: epName
				});
			}
			if (!this.endpoint) throw new Error(locale.format(module, "noEndpointMatch", epName));
		} else {
			throw new Error(locale.format(module, "noCallContext"));
		}
	},
	_addMessage: function(type, message) {
		this.messages.push({
			type: type,
			message: message
		});
	},
	// Maybe not useful
	_hasError: function() {
		return this.messages.some(function(m) {
			return m.type === "error";
		});
	},
	execute: function(_, context, method, params) {
		tracer.debug && tracer.debug("\n");
		tracer.debug && tracer.debug("##################################################");
		tracer.debug && tracer.debug("#    Execute Ackcall for method : " + method);
		tracer.debug && tracer.debug("##################################################");
		tracer.debug && tracer.debug("# Parameters : " + JSON.stringify(params, null, 2));

		this.context = context;

		var func = callMap[this.serviceName] && callMap[this.serviceName][method];
		if (!func) throw new Error(locale.format(module, "invalidSoapAction", method));
		this._setCallContext(_, params.callContext);

		var proto = stubUtils.getOperationPrototype(_, this.serviceName, this.serviceName, method, "$request", this.context, "generic-in");
		if (!proto) throw new Error(locale.format(module, "errGetProto", method, "request"));

		var requestProperties = proto.$properties.body.$item.$properties[method].$item.$properties;
		if (!requestProperties) throw new Error(locale.format(module, "reqPropsNotFound", proto.$descriptor));
		validateProperties(requestProperties, params);
		// Not necessary to send callContext to CvgClientWS
		delete params.callContext;





		var response = {
			$: {
				"xmlns": "TODO"
			}
		};




		var transformed = func(actionMap[method], params, response);

		var wsClient = findWsClient(_, this.endpoint, this.user, this.localePref, this.context);
		wsClient.execWS(_, {
			user: this.user,
			lang: this.lang
		}, transformed);
		return response;
	},
});

exports.create = function(serviceName) {
	return new AckcallExecutor(serviceName);
};