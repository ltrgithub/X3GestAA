"use strict";

var helpers = require("syracuse-core/lib/helpers");
var locale = require("syracuse-core/lib/locale");
var parser = require('syracuse-sdata/lib/parser/parser');
var flows = require('streamline/lib/util/flows');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var poolManager = require("syracuse-soap/lib/generic/poolManager");
var jsxml = require('jsxml');
var forEachKey = helpers.object.forEachKey;
var soapUtils = require('../server/soapUtils');
var soapTools = require('../common/soapTools');
var stubUtils = require("syracuse-soap/lib/client/stubUtils");
var WsCall = require('syracuse-soap/lib/generic/wsCall').WsCall;
var check = require('syracuse-license/lib/check');
var tracer = require("syracuse-trace/lib/helper").getTracer("soap-generic.request");

var __soapEnc = "http://schemas.xmlsoap.org/soap/encoding/";
var __soapEnv = "http://schemas.xmlsoap.org/soap/envelope/";
var __soapSage = "http://www.adonix.com/WSS";
var __soapXsd = "http://www.w3.org/2001/XMLSchema";
var __soapXsi = "http://www.w3.org/2001/XMLSchema-instance";

var callMap = {
	CAdxWebServiceXmlCC: {
		"run": function(action, params) {
			return {
				name: params.publicName,
				flow: params.inputXml,
				action: action
			};
		},
		"save": function(action, params) {
			return {
				name: params.publicName,
				flow: params.objectXml,
				action: action
			};
		},
		"delete": function(action, params) {
			return {
				name: params.publicName,
				wkeys: params.objectKeys,
				action: action
			};
		},
		"read": function(action, params) {
			return {
				name: params.publicName,
				wkeys: params.objectKeys,
				action: action
			};
		},
		"query": function(action, params) {
			return {
				name: params.publicName,
				wkeys: params.objectKeys,
				nb: params.listSize,
				action: action
			};
		},
		"getDescription": function(action, params) {
			return {
				name: params.publicName,
				action: action,
			};
		},
		"getDataXmlSchema": function(action, params) {
			return {
				name: params.publicName,
				action: action,
			};
		},
		"modify": function(action, params) {
			return {
				name: params.publicName,
				wkeys: params.objectKeys,
				flow: params.objectXml,
				action: action
			};
		},
		"actionObject": function(action, params) {
			return {
				name: params.publicName,
				flow: params.objectXml,
				action: params.actionCode
			};
		},
		"actionObjectKeys": function(action, params) {
			return {
				name: params.publicName,
				wkeys: params.objectKeys,
				action: params.actionCode
			};
		},
		"insertLines": function(action, params) {
			return {
				name: params.publicName,
				wkeys: params.objectKeys,
				tab: params.blocKey,
				par: params.lineKey,
				flow: params.lineXml,
				action: action
			};
		},
		"deleteLines": function(action, params) {
			return {
				name: params.publicName,
				wkeys: params.objectKeys,
				tab: params.blocKey,
				par: params.lineKeys,
				action: action
			};
		}
	}
};



// Mapping between operations and actions
var actionMap = {
	run: "EXEC",
	save: "CREATE",
	delete: "DELETE",
	read: "READ",
	query: "LIST",
	getDescription: "GETDESCR",
	modify: "MODIFY",
	actionObject: null, // specific
	actionObjectKeys: null, // specific
	getDataXmlSchema: "GETSCHEMA",
	insertLines: "INSLIG",
	deleteLines: "SUPLIG"
};

function removeNamespaces(node) {
	var obj = Array.isArray(node) ? [] : {};
	// remove namespaces
	forEachKey(node, function(key, value) {
		if (key.indexOf(':') !== -1) {
			var keyParts = key.split(':');
			obj[keyParts[1]] = value != null && typeof value === "object" ? removeNamespaces(value) : value;
		} else {
			obj[key] = value != null && typeof value === "object" ? removeNamespaces(value) : value;
		}
	});
	return obj;
}

function validateProperties(properties, params) {
	function validateProperty(_property, _param, key) {

		if (_property.$isMandatory && _param === undefined) {
			throw new Error(locale.format(module, "mandatoryProperty", _property.$title));
		}
		if (_property.$type === "application/x-object") {
			//tracer.warn && tracer.warn(JSON.stringify(_property,null,2));
			return validateProperties(_property.$item.$properties, _param);
		} else if (_property.$type === "application/x-array") {
			var arr = [];
			var _itm = _param && (_param.item || _param.Item);
			var arrVal = _param ? (_itm ? _itm : _param) : null;
			if (arrVal) {
				if (Array.isArray(arrVal)) {
					arrVal.forEach(function(it) {
						var p;
						if (typeof it === "object") {
							p = validateProperties(_property.$item.$properties, it);
						} else {
							p = stubUtils.convertValue(_property.$item.$properties[key].$title, _property.$item.$properties[key].$type, it);
						}
						arr.push(p);
					});
				} else {
					var p;
					if (typeof arrVal === "object") {
						p = validateProperties(_property.$item.$properties, arrVal);
					} else {
						p = stubUtils.convertValue(_property.$item.$properties[key].$title, _property.$item.$properties[key].$type, arrVal);
					}
					arr.push(p);
				}
			}
			return arr;
		} else {
			return stubUtils.convertValue(_property.$title, _property.$type, _param);
		}
	}
	var result = {};
	if (params) forEachKey(properties, function(key, value) {
		result[key] = validateProperty(value, params[key], key);
	});
	return result;
}

function canReadInstance(_, context, instance) {
	var sp = context && context.httpSession && context.httpSession.getSecurityProfile(_);
	if (sp) {
		var r = sp.canReadClass(_, instance.getEntity(_).name);
		if (typeof r === "boolean") {
			if (r === false) {
				return false;
			}
		} else {
			r = sp.replacePredefinedVars(_, r);
			return instance.match(_, parser.Parser.parse(r));
		}
	}
	return true;
}

var respMap = {
	CAdxWebServiceXmlCC: function(wsCall) {
		var response = {
			resultXml: {}
		};
		if (wsCall.result) {
			response.resultXml.$cdata = wsCall.result;
		} else {
			response.resultXml.$value = null;
		}
		response.messages = wsCall.messages;
		response.status = wsCall.status;
		return response;
	}
};

var AckcallExecutor = helpers.defineClass(function(serviceName) {
	this.serviceName = serviceName;
	this.ws;
	this.reqProto = {};
	this.respProto = {};
	console.error("Create Executor for service: " + serviceName);
}, null, {
	_setSessionContext: function(_, callContext, context) {
		var up = context.getUserProfile(_);
		if (callContext) {
			var sessionContext = {};
			var db = adminHelper.getCollaborationOrm(_);
			// locale
			if (callContext.codeLang) {
				sessionContext.x3language = callContext.codeLang;
				var iso = locale.defaultIso(sessionContext.x3language);
				if (!iso) throw new Error(locale.format(module, "langIncorrect", sessionContext.x3language));
				if (iso.length === 2) iso = locale.longIso(iso);
				locale.setCurrent(_, iso);
				if (!sessionContext.localePref || sessionContext.localePref.code(_) !== iso) {
					var codeIso = iso.substring(0, 3) + iso.substring(3).toUpperCase();
					tracer.debug && tracer.debug("Use language: " + codeIso);

					sessionContext.localePref = db.fetchInstances(_, db.model.getEntity(_, "localePreference"), {
						jsonWhere: {
							code: codeIso
						}
					})[0];
				}
			} else {
				sessionContext.localePref = up.selectedLocale();
				if (!sessionContext.localePref) {
					sessionContext.localePref = db.fetchInstances(_, db.model.getEntity(_, "localePreference"), {
						jsonWhere: {
							code: "en-US"
						}
					})[0];
				}
				sessionContext.x3language = locale.x3Language(sessionContext.localePref.code(_));
			}
			sessionContext.x3Lang = sessionContext.localePref.code(_);
			// endpoint
			if (!callContext.poolAlias) throw new Error(locale.format(module, "poolAliasMissing"));
			var poolAlias = callContext.poolAlias;
			sessionContext.poolAlias = callContext.poolAlias;
			if (!sessionContext.endpoint || !sessionContext.pool || sessionContext.pool.alias(_) !== poolAlias) {
				sessionContext.pool = db.fetchInstance(_, db.model.getEntity(_, "soapClassicPool"), {
					jsonWhere: {
						alias: poolAlias
					}
				});
				if (!sessionContext.pool) throw new Error(locale.format(module, "noPoolMatch", poolAlias));

				if (!canReadInstance(_, context, sessionContext.pool)) {
					throw new Error(locale.format(module, "noPoolRight", poolAlias));
				}

				sessionContext.endpoint = sessionContext.pool.endpoint(_);
			}

			// user
			if (!sessionContext.user || sessionContext.user.login(_) !== up.user(_).login(_)) {
				var user = up.user(_);
				sessionContext.user = user;
				sessionContext.x3User = user.getEndpointLogin(_, sessionContext.endpoint.$uuid);
			}
			return sessionContext;
		} else {
			throw new Error(locale.format(module, "noCallContext"));
		}
	},
	execute: function(_, context, method, params, wsCall) {
		// Check soap action
		var func = callMap[this.serviceName] && callMap[this.serviceName][method];
		if (!func) throw new Error(locale.format(module, "invalidSoapAction", method));

		// Set context (no more in session)
		wsCall.context = this._setSessionContext(_, params.callContext, context);

		// example of request config
		//adxwss.trace.on=on&adxwss.trace.size16384&adonix.trace.on=on&adonix.trace.level=3&adonix.trace.size=8&adxwss.optreturn=XML

		var options = {};
		if (params.callContext && params.callContext.requestConfig) {
			options.requestConfig = {};
			if (params.callContext.requestConfig.indexOf('&') !== -1) {
				var parts = params.callContext.requestConfig.split('&');
				parts.forEach(function(p) {
					if (p.indexOf('=')) {
						var splited = p.split('=');
						options.requestConfig[splited[0]] = splited[1];
					}
				});
			} else {
				if (params.callContext.requestConfig.indexOf('=')) {
					var splited = params.callContext.requestConfig.split('=');
					options.requestConfig[splited[0]] = splited[1];
				}
			}
			tracer.debug && tracer.debug("Request config parameters: " + JSON.stringify(options.requestConfig, null, 2));
		}



		// transform parameters
		var transformed = func(actionMap[method], params);

		tracer.debug && tracer.debug("\n");
		tracer.debug && tracer.debug("##################################################");
		tracer.debug && tracer.debug("#    Execute Ackcall for method : " + method);
		tracer.debug && tracer.debug("##################################################");
		tracer.debug && tracer.debug("# Parameters : " + JSON.stringify(transformed, null, 2));

		// Select a client
		wsCall.techInfo.poolWaitDuration.start();
		wsCall.techInfo.poolRequestDuration.start();
		// Init start time in traceRequest
		wsCall.techInfo.traceRequest.init(wsCall.techInfo.poolRequestDuration.startTime);

		var poolAlias = wsCall.context.pool.alias(_);
		var pool = poolManager.getPool(poolAlias);
		if (!pool) throw new Error("No Pool: " + poolAlias);

		// set pool metadata into call context
		wsCall.context.poolMetadata = pool.metadata;

		var wsClient = pool.alloc(_, context, wsCall);
		wsCall.techInfo.poolDistribDuration.stop();
		// Initialize call
		wsCall.init(transformed, options.requestConfig);
		// Execute ackcall
		wsClient.execWs(_, context, wsCall);
	},
	intercept: function(_, context) {
		var response, responseRoot, useSoapStyle, wsCall, responseProperties, responseNodeName, returnNodeName;
		try {
			wsCall = new WsCall();
			// start total timer
			wsCall.techInfo.totalDuration.start();

			this.ws = this.ws || soapUtils.getSoapWebService(_, this.serviceName, context, "soapGeneric");
			if (!this.ws) throw new Error(locale.format(module, "wsNotFound", this.serviceName));

			var reqHeader = context.request.headers;
			tracer.debug && tracer.debug("Header : " + JSON.stringify(reqHeader, null, 2));

			if (!reqHeader.soapaction) throw new Error(locale.format(module, "soapActMissing"));
			var soapAction = reqHeader.soapaction.replace(/\"/g, '');

			var reqBody = context.request.readAll(_);
			tracer.debug && tracer.debug("Body : " + reqBody);

			useSoapStyle = reqBody.indexOf(__soapEnc) !== -1;
			tracer.debug && tracer.debug("Soap encoding style enabled: " + useSoapStyle);

			// translate request
			tracer.debug && tracer.debug("\n");
			tracer.debug && tracer.debug("##################################################");
			tracer.debug && tracer.debug("#    Translate SOAP Action : " + soapAction);
			tracer.debug && tracer.debug("##################################################");
			reqBody = jsxml.parse(reqBody);

			// get namespaces
			var reqEnv = reqBody[Object.keys(reqBody)[0]];
			var ns = {
				soapenv: soapTools.getNamespacePrefix(reqEnv, __soapEnv),
				soapenc: soapTools.getNamespacePrefix(reqEnv, __soapEnc),
			};
			// translate request to be compliant with soap encoding
			var soapRequest = soapTools.translateRequest(reqBody, ns, useSoapStyle);
			tracer.debug && tracer.debug("# " + JSON.stringify(reqBody, null, 2));

			// Do not need ns
			var opRequest = removeNamespaces(soapRequest.body);
			if (!opRequest) throw new Error(locale.format(module, "requestNotFound"));
			var opRequestName = Object.keys(opRequest)[0];


			tracer.info && tracer.info("Web service call: name: " + this.serviceName + " - operation: " + opRequestName);
			// Reuse or store request prototype in Executor instance
			this.reqProto[opRequestName] = this.reqProto[opRequestName] || stubUtils.getOperationPrototype(_, this.serviceName, this.serviceName, opRequestName, "$request", context, "generic-in");
			if (!this.reqProto[opRequestName]) throw new Error(locale.format(module, "errGetProto", opRequestName, "request"));
			this.respProto[opRequestName] = this.respProto[opRequestName] || stubUtils.getOperationPrototype(_, this.serviceName, this.serviceName, opRequestName, "$response", context, "generic-in");
			if (!this.respProto[opRequestName]) throw new Error(locale.format(module, "errGetProto", opRequestName, "response"));


			// Validate received parameters with expected properties + convert values
			var requestProperties = this.reqProto[opRequestName].$properties.body.$item.$properties[opRequestName].$item.$properties;
			if (!requestProperties) throw new Error(locale.format(module, "propsNotFound", this.reqProto[opRequestName].$descriptor));



			responseNodeName = Object.keys(this.respProto[opRequestName].$properties.body.$item.$properties)[0];
			returnNodeName = Object.keys(this.respProto[opRequestName].$properties.body.$item.$properties[responseNodeName].$item.$properties)[0];

			responseProperties = this.respProto[opRequestName].$properties.body.$item.$properties[responseNodeName].$item.$properties[returnNodeName].$item.$properties;
			if (!responseProperties) throw new Error(locale.format(module, "propsNotFound", this.respProto[opRequestName].$descriptor));

			opRequest[opRequestName] = validateProperties(requestProperties, opRequest[opRequestName]);

			responseRoot = {};
			responseRoot[responseNodeName] = {};

			tracer.debug && tracer.debug("\n");
			tracer.debug && tracer.debug("##################################################");
			tracer.debug && tracer.debug("#    Intercept SOAP Request for service : " + this.serviceName);
			tracer.debug && tracer.debug("##################################################");

			// execute request
			this.execute(_, context, opRequestName, opRequest[opRequestName], wsCall);
			response = responseRoot[responseNodeName][returnNodeName] = respMap[this.serviceName](wsCall);

		} catch (e) {
			console.error("Error in intercept: " + e.stack);
			if (!response && (!responseRoot || !responseNodeName || !returnNodeName)) throw e;
			tracer.error && tracer.error(e.message, e);
			wsCall.addMessage(4, e.message);
			wsCall.status = 0;
			response = responseRoot[responseNodeName][returnNodeName] = respMap[this.serviceName](wsCall);
		}
		console.error("responseRoot: " + JSON.stringify(responseRoot, null, 2));
		// translate response to be compliant with soap encoding
		responseRoot = soapTools.translateResponse(responseRoot, responseProperties, useSoapStyle);


		// end of pool request
		wsCall.techInfo.poolRequestDuration.stop();

		var envelope = {
			"soapenv:Envelope": {
				$: {
					"xmlns:soapenv": __soapEnv,
					"xmlns:xs": __soapXsd,
					"xmlns:xsi": __soapXsi,
					"xmlns:soapenc": __soapEnc,
					"xmlns:wss": __soapSage
				},
				"soapenv:Body": {}
			}
		};

		// build envelope
		envelope["soapenv:Envelope"]["soapenv:Body"] = responseRoot;
		wsCall.techInfo.totalDuration.stop();

		// set technical informations in response flow
		if (response) response.technicalInfos = wsCall.techInfo.stringify();
		var soapResponse = jsxml.stringify(envelope);
		tracer.info && tracer.info("End call");
		soapResponse = '<?xml version="1.0" encoding="utf-8"?>' + soapResponse;
		tracer.debug && tracer.debug("\n");
		tracer.debug && tracer.debug("##################################################");
		tracer.debug && tracer.debug("#    Send SOAP Reply  : ");
		tracer.debug && tracer.debug("##################################################");
		tracer.debug && tracer.debug(soapResponse);



		var bufResp = new Buffer(soapResponse, "utf8");

		// Manage license
		if (wsCall.context && wsCall.context.poolMetadata) {
			var licenseCheck = check.step(_, bufResp.length, wsCall.context.poolMetadata);

			// Web services system will blocked --> the grace limit is exceeded
			if (licenseCheck < 0) {
				wsCall.status = 0;
				wsCall.result = null;
				wsCall.addMessage(3, locale.format(module, "systemBlocked", "WS_GRACE_LIMIT"));
				response = responseRoot[responseNodeName][returnNodeName] = respMap[this.serviceName](wsCall);
				// reserialize final response to update last information
				if (response) response.technicalInfos = wsCall.techInfo.stringify();
				soapResponse = jsxml.stringify(envelope);
				bufResp = new Buffer(soapResponse, "utf8");
			}

			// web service system will be slown down
			else if (licenseCheck > 0) {
				// if poolRequestDuration is not set, it means that an error occured, so do not need to slow the system
				if (wsCall.techInfo && wsCall.techInfo.poolRequestDuration && wsCall.techInfo.poolRequestDuration.value) {
					wsCall.techInfo.totalDuration.start();
					// Web services system will be slowed --> size limit is exceeded
					flows.sleep(_, (licenseCheck - 1) * wsCall.techInfo.poolRequestDuration.value); // N times slower
					wsCall.addMessage(2, locale.format(module, "sizeLimitReached", "WS_SIZE_LIMIT"));
					wsCall.techInfo.totalDuration.stop();

					// reserialize final response to update last information
					if (response) response.technicalInfos = wsCall.techInfo.stringify();
					soapResponse = jsxml.stringify(envelope);
					bufResp = new Buffer(soapResponse, "utf8");
				}
			}
			// else Continue normally
		}
		return bufResp;
	},

});

var executors = [];

function getExecutor(serviceName) {
	executors[serviceName] = executors[serviceName] || new AckcallExecutor(serviceName);
	return executors[serviceName];
}

exports.intercept = function(_, serviceName, context) {
	return getExecutor(serviceName).intercept(_, context);
};