"use strict";

var helpers = require('syracuse-core/lib/helpers');
var jsxml = require('jsxml');
var locale = require("syracuse-core/lib/locale");
var globals = require('streamline/lib/globals');
var soapTracer = require('../common/soapTracer');
var soapHelper = require('./soapHelper');
var restUtils = require('./restUtils');
var genericOperations = require('./genericOperations');

var tracer = soapTracer.create("wsdl");

var Generator = helpers.defineClass(function(_, service, representations) {

	this.context = globals.context;
	this.serviceName = service.name(_);
	this.representations = representations;

	this.application = service.applicationName(_);
	this.contract = service.contractName(_);
	this.dataset = service.endpointName(_);
	this.model = service.endpoint(_).getOrm(_).model;

	this.baseUrl = this.context.session.host + "/soap-ws/" + this.application + "/" + this.contract + "/" + this.dataset;

	this.url = this.baseUrl + "/" + this.serviceName;
	this.namespace = this.dataset + "." + this.contract + "." + this.application;

}, null, {
	makeWsdl: function(_) {

		function getPrototype(_, name, facet) {
			try {
				// wait to handle $edit in X3... Remove those two lines after it will be handled
				if (self.application === "x3" && facet === "$edit") facet = "$details";

				var sc = restUtils.getPrototype(_, self.context.request.headers, self.baseUrl, name, facet);
				if (!sc) throw new Error(locale.format(module, "errGetProto", facet, name, facet, ""));

				return sc;
			} catch (e) {
				throw new Error(locale.format(module, "errGetProto", facet, name, facet, e.stack));
			}

		}

		function addOperations(entityName, generics) {
			for (var key in generics) {
				addOperation(entityName, generics[key]);
			}
		}

		function addOperation(entityName, op) {
			addBinding(op.$title);
			addPortType(op.$title);
			addMessages(entityName, op.$title);
		}

		function addMessages(entityName, name) {
			addMessage(entityName, name + "Request");
			addMessage(entityName, name + "Response");
		}

		function addMessage(entityName, name) {
			var message = {
				$: {
					name: name
				},
				part: {
					$: {
						name: "parameters",
						element: entityName + ":" + name
					}
				}
			};
			wsdl.definitions.message.push(message);
		}

		function addPortType(name) {
			var portType = {
				$: {
					name: name
				},
				documentation: "",
				input: {
					$: {
						message: "tns:" + name + "Request"
					}
				},
				output: {
					$: {
						message: "tns:" + name + "Response"
					}
				}
			};
			wsdl.definitions.portType.operation.push(portType);
		}

		function addBinding(name) {
			var binding = {
				$: {
					name: name
				},
				"soap:operation": {
					$: {
						soapAction: name,
						style: "document"
					}
				},
				input: {
					"soap:body": {
						$: {
							use: "literal"
						}
					}
				},
				output: {
					"soap:body": {
						$: {
							use: "literal"
						}
					}
				}
			};
			wsdl.definitions.binding.operation.push(binding);
		}

		function addSchema(_, entityName, representationName, generics) {

			function format(title, element, listType, facet) {

				function formatChoice(elt) {
					tracer.traceSubSection("Format Choice: " + title + " element", JSON.stringify(elt, null, 2));
					var type = elt.$value.$type;
					if (type && type.indexOf(ns) !== 0 && type.indexOf('xs:') !== 0) {
						type = sHelper.convertType(type);
					}
					if (type != null) {
						formatted.$.type = ns + title + customFacet + "--enum";
						var $enum = {
							$: {
								"name": title + customFacet + "--enum"
							}
						};
						$enum["xs:restriction"] = {
							$: {
								base: type
							},
							"xs:enumeration": []
						};
						for (var key in elt.$value.$enum) {
							var xsenum = {
								$: {
									value: elt.$value.$enum[key].$value.toString()
								}
							};
							$enum["xs:restriction"]["xs:enumeration"].push(xsenum);
						}
						xsd["xs:simpleType"].push($enum);
						return formatted;
					} else {
						tracer.trace("Ignore 'x-choice' subtype: '" + elt.$type + "' for elt: '" + title + "'");
						return;
					}
				}

				var customFacet = facet ? "-" + facet : "";
				var formatted = {
					$: {
						"name": title.indexOf('$') === 0 ? '_' + title.substring(1) : title
					}
				};
				if (!element.$isMandatory) formatted.$.minOccurs = "0";

				if (element.$default != null) formatted.$['default'] = element.$default;

				var type;
				switch (element.$type) {
					case "application/x-array":
						tracer.traceSubSection("Format Collection: " + title + " element", JSON.stringify(element, null, 2));
						tracer.trace("  Sub item type : " + element.$item.$type);
						type = element.$item.$type;

						if (type === "application/x-choice") {
							formatChoice(element.$item);
							type = ns + title + customFacet + "--enum-list";
							if (!complexTypeExists(title + customFacet + "--enum-list")) {
								addComplexList(title, false, facet, "enum");
							}
						} else if (type && type.indexOf(ns) !== 0 && type.indexOf('xs:') !== 0) {
							type = sHelper.convertType(type);
						}

						var entityType, elementType;
						if (type != null) {
							formatted.$.type = type;

						} else {
							entityType = sHelper.getEntityType(title, element.$item);

							if (self.application !== "x3") {
								if (entityType !== self.model.singularize(entityName)) {
									elementType = entityType;
								} else {
									elementType = representationName;
								}
							} else {
								elementType = entityType;
							}
							tracer.trace("Entity type: " + elementType);

							if (elementType != null) {

								if (sHelper.isParent(title, element, elementName)) {
									formatted.$.type = ns + elementType + customFacet + "--ref-list";
									if (!complexTypeExists(elementType + customFacet + "--ref")) {

										addComplexType(elementType + customFacet + "--ref", element.$item, facet);
									}
									if (!complexTypeExists(elementType + customFacet + "--ref-list")) {
										addComplexList(elementType, elementType !== elementName, facet, 'parent');
									}

								} else {
									formatted.$.type = ns + elementType + customFacet + "--list";
									if (!complexTypeExists(elementType + customFacet + "--type")) {

										addComplexType(elementType + customFacet + "--type", element.$item, facet);
									}
									if (!complexTypeExists(elementType + customFacet + "--list")) {
										addComplexList(elementType, elementType !== elementName, facet);
									}

								}
							} else {
								formatted.$.type = type;
							}
							if (listType && listType.name) {
								if (listType.kind === 'ref') {
									formatted.$.type = ns + listType.name + customFacet + "--ref";
								} else if (listType.kind === 'enum') {
									formatted.$.type = ns + listType.name + customFacet + "--enum";
								} else {
									formatted.$.type = ns + listType.name + customFacet + "--type";
								}
								formatted.$.minOccurs = element.$isMandatory && element.$isMandatory === true ? "1" : "0";
								formatted.$.maxOccurs = "unbounded";
							}
						}

						return formatted;
					case "application/x-choice":
						return formatChoice(element);
					case "application/x-object":
					case "application/x-reference":
						tracer.traceSubSection("Format Reference: '" + title + "' element", JSON.stringify(element, null, 2));
						entityType = sHelper.getEntityType(title, element);
						elementType;
						if (self.application !== "x3") {
							if (entityType !== self.model.singularize(entityName)) {
								elementType = entityType;
							} else {
								elementType = representationName;
							}
						} else {
							elementType = entityType;
						}
						if (!elementType) throw new Error("An error has occured while retrieving element type for reference [" + title + "]");
						if (sHelper.isParent(title, element, elementName)) {
							formatted.$.type = ns + elementType + customFacet + "--ref";
							if (!complexTypeExists(elementType + customFacet + "--ref")) {
								addComplexType(elementType + customFacet + "--ref", element, facet);
							}
						} else {
							formatted.$.type = ns + elementType + customFacet + "--type";
							if (!complexTypeExists(elementType + customFacet + "--type")) {
								addComplexType(elementType + customFacet + "--type", element, facet);
							}
						}
						return formatted;
					default:
						type = element.$type;
						if (type && type.indexOf(ns) !== 0 && type.indexOf('xs:') !== 0) {
							type = sHelper.convertType(type);
						}
						if (type != null) {
							tracer.traceSubSection("Format '" + title + "' element", JSON.stringify(element, null, 2));
							if (type === "b64") {
								formatted.$.type = ns + title + "-binary--type";
								addbase64ComplexType(title + "-binary--type", facet);
							} else {
								formatted.$.type = type;
							}
							return formatted;
						} else {
							tracer.trace("Ignore type: '" + element.$type + "' for element: '" + title + "'");
							return;
						}
				}
			}

			function addbase64ComplexType(title, facet) {
				var b64cp = {
					$nokey: true,
					$type: "application/x-reference",
					$: {
						content: {
							$type: "xs:base64Binary",
							$default: ""
						},
						length: {
							$type: "xs:integer"
						},
						contentType: {
							$type: "xs:string"
						},
						fileName: {
							$type: "xs:string"
						},
						uploadDate: {
							$type: "xs:dateTime"
						}
					}
				};
				addComplexType(title, b64cp, facet);
			}

			function createOrderByComplexType() {
				addComplexList("orderBy", false);
				addComplexType("orderBy--type", genericOperations.get(elementName).$list.$orderBy);
			}

			function complexTypeExists(title) {
				var cp = xsd["xs:complexType"];
				for (var i in cp) {
					if (cp[i].$.name === title) {
						return true;
					}
				}
				return false;
			}

			function addOperationComplexTypes(title, element) {
				addElement(title + "Request");
				addElement(title + "Response");
				addComplexType(title + "Request", element.$request);
				addComplexType(title + "Response", element.$response);
			}

			function addComplexList(cpTitle, withDeleteMissing, facet, eltKind) {
				tracer.traceSection("Add addComplexList : " + cpTitle + " with facet: " + facet);
				withDeleteMissing = withDeleteMissing != null ? withDeleteMissing : true;
				var customFacet = facet ? "-" + facet : "";

				var listCp = {
					$nokey: true,
					$type: "application/x-reference",
					$properties: {}
				};

				if (withDeleteMissing) {
					listCp.$properties.$deleteMissing = {
						$type: "xs:boolean",
						$default: "false"
					};
				}

				listCp.$properties[cpTitle] = {
					$type: "application/x-array",
					$item: {
						$nokey: true,
						$type: "application/x-reference",
						$properties: {}
					}
				};

				var cpListType, cpListTitle;
				if (eltKind === "parent") {
					cpListType = ns + elementName + customFacet + "--ref";
					cpListTitle = cpTitle + customFacet + "--ref-list";
				} else if (eltKind === "enum") {
					cpListType = ns + elementName + customFacet + "--enum";
					cpListTitle = cpTitle + customFacet + "--enum-list";
				} else {
					cpListType = ns + elementName + customFacet + "--type";
					cpListTitle = cpTitle + customFacet + "--list";
				}

				listCp.$properties[cpTitle].$item.$properties[elementName] = {
					$nokey: true,
					$type: cpListType
				};

				addComplexType(cpListTitle, listCp, facet);
			}

			function addElement(name) {
				var element = {
					$: {
						name: name,
						type: ns + name
					}
				};
				xsd["xs:element"].push(element);
			}

			function addComplexType(title, element, facet) {

				if (!complexTypeExists(title)) {
					tracer.traceSection("Add ComplexType : " + title + " with facet: " + facet);
					var cp = {
						$: {
							name: title
						},
						"xs:sequence": {
							"xs:element": []
						}
					};
					if (!element.$nokey) {
						var _key = {
							$: {
								name: "_key",
								minOccurs: "0",
								type: "xs:string"
							}
						};
						cp["xs:sequence"]["xs:element"].push(_key);
					}

					xsd["xs:complexType"].push(cp);

					var len, listType = null;
					if (title.indexOf("--list") === (title.length - 6)) {
						len = facet ? title.length - 6 - facet.length - 1 : title.length - 6;
						listType = {
							name: title.substring(0, len)
						};
					}
					if (title.indexOf("--ref-list") === (title.length - 10)) {
						len = facet ? title.length - 10 - facet.length - 1 : title.length - 10;
						listType = {
							name: title.substring(0, len),
							kind: 'ref'
						};
					}
					if (title.indexOf("--enum-list") === (title.length - 11)) {
						len = facet ? title.length - 11 - facet.length - 1 : title.length - 11;
						listType = {
							name: title.substring(0, len),
							kind: 'enum'
						};
					}
					var elt = element.$item || element;
					for (var key in elt.$properties) {

						tracer.trace("Add Sequence : " + key);
						var formatted = format(key, elt.$properties[key], listType, facet);

						if (formatted) cp["xs:sequence"]["xs:element"].push(formatted);
					}

					return cp;
				}
			}

			var ns = representationName + ":";
			var sHelper, elementName;
			var xsd = {
				$: {
					elementFormDefault: "qualified",
					//version: "1.0",
					targetNamespace: representationName + "." + self.namespace
				},
				"xs:element": [],
				"xs:complexType": [],
				"xs:simpleType": []

			};

			sHelper = soapHelper.create(self.application, schemas.$edit);
			elementName = sHelper.getEntityType(entityName, schemas.$edit);
			if (!elementName) throw new Error("An error has occured while retrieving element name.");

			// Edit complexType
			addComplexType(elementName + "-edit--type", schemas.$edit, "edit");
			//xsd["xs:complexType"][0] = editCP;

			sHelper = soapHelper.create(self.application, schemas.$details);
			elementName = sHelper.getEntityType(entityName, schemas.$details);
			// Details complexType
			addComplexType(elementName + "-details--type", schemas.$details, "details");

			sHelper = soapHelper.create(self.application, schemas.$query);
			elementName = sHelper.getEntityType(entityName, schemas.$query);
			// Query complexType
			addComplexType(elementName + "-query--type", schemas.$query, "query");

			addComplexList(elementName, false, 'query');
			createOrderByComplexType();

			for (var key in generics) {
				addOperationComplexTypes(generics[key].$title, generics[key]);
			}

			return xsd;

		}

		var self = this;
		var wsTitle = this.serviceName.charAt(0).toUpperCase() + this.serviceName.slice(1);

		var wsdl = {
			definitions: {

				$: {
					name: wsTitle,
					xmlns: "http://schemas.xmlsoap.org/wsdl/",
					"xmlns:soap": "http://schemas.xmlsoap.org/wsdl/soap/",
					"xmlns:xs": "http://www.w3.org/2001/XMLSchema",
					"xmlns:tns": this.namespace,
					targetNamespace: this.namespace
				},
				types: {
					"xs:schema": []
				},
				message: [],
				portType: {
					$: {
						name: wsTitle + "SoapType"
					},
					operation: []
				},
				binding: {
					$: {
						name: wsTitle + "SoapBinding",
						type: "tns:" + wsTitle + "SoapType"
					},
					"soap:binding": {
						$: {
							style: "document",
							transport: "http://schemas.xmlsoap.org/soap/http"
						}
					},
					operation: []
				},
				service: {
					$: {
						name: wsTitle
					},
					port: {
						$: {
							name: wsTitle + "Soap",
							binding: "tns:" + wsTitle + "SoapBinding"
						},
						"soap:address": {
							$: {
								location: this.url
							}
						}
					}

				}
			}
		};

		try {

			if (this.representations.length === 0) throw new Error(locale.format(module, "atLeastOneRepr", this.serviceName));

			for (var rep in this.representations) {

				var representation = this.representations[rep];
				var name = representation.name(_);
				var entityName = representation.entityName(_);

				//console.log("Query proto="+JSON.stringify(schemaQuery,null,2));
				var schemas = {
					$edit: getPrototype(_, name, "$edit"),
					$details: getPrototype(_, name, "$details"),
					$query: getPrototype(_, name, "$query").$properties.$resources.$item
				};

				var generics = genericOperations.get(name);
				// Add a definitions namespace
				wsdl.definitions.$["xmlns:" + name] = name + "." + this.namespace;
				// Add schema
				wsdl.definitions.types["xs:schema"].push(addSchema(_, entityName, name, generics));
				// Add operations
				addOperations(name, generics);

			}

			//console.log("WSDL="+JSON.stringify(wsdl,null,2));
			wsdl = '<?xml version="1.0" encoding="utf-8"?>\n' + jsxml.stringify(wsdl, {
				indent: '\t'
			});
			tracer.traceSection("End WSDL Generation");
		} catch (e) {
			throw new Error("Error : " + e.stack);
		}
		return wsdl;
	}

});

exports.generate = function(_, service) {
	try {
		var representations = service.representations(_).toArray(_);
		tracer.traceSection("Generate WSDL description for SOAP Web Service: " + service.name(_));
		var gen = new Generator(_, service, representations);
		return gen.makeWsdl(_);

	} catch (e) {
		console.log("STACK=" + e.stack);
		throw new Error(e.message);
	}
};