"use strict";

var helpers = require('syracuse-core/lib/helpers');
var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var util = require("util");
var fs = require('fs');
var jsxml = require('jsxml');

var soapTracer = require('../common/soapTracer');
var soapHelper = require('./soapHelper');
var restUtils = require('./restUtils');
var genericOperations = require('./genericOperations');

var Template = require('syracuse-core/lib/resource/resourceProxy').Template;
var streams = require('streamline/lib/streams/streams');
var config = require('syracuse-main/lib/nodeconfig').config;






var tracer = soapTracer.create("wsdl");

var Generator = helpers.defineClass(function(entityName, application, contract, dataset) {

	this.application = application;
	this.contract = contract;
	this.dataset = dataset;
	this.entityName = entityName;
	this.namespace = application + "." + contract + "." + dataset
	this.requestType = "$edit";
	if (this.application === "x3")
		this.requestType = "$details";
}, null, {
	runSyracuse: function(_, context){
		var schema = context.getPrototypeResource(_, this.entityName + "." + this.requestType);
		//tracer.traceSubSection("Entity Schema : " + this.entityName, JSON.stringify(schema,null,2));
		return makeWsdl(_, this.entityName, this.application, this.namespace, schema, "syracuse", context.url);
	},
	runX3: function(_, context){	
		var schema = restUtils.getPrototype(_, context, this.entityName, this.requestType);
		//tracer.traceSubSection("Entity Schema : " + this.entityName, JSON.stringify(schema,null,2));		
		return makeWsdl(_, this.entityName, this.application, this.namespace, schema, "x3", context.url);
	}

	
});



exports.generate = function(_, entityName, context){
	try{
		switch(context.applicationName){
			case "qunit":
			case "syracuse":
				tracer.traceSection("SYRACUSE: Generate WSDL Description for entity : "+ context.entity.name, "");
				var gen = new Generator(context.entity.name, context.application.name, context.contract.name, context.dataset);
				return gen.runSyracuse(_, context);
			case "x3":
				tracer.traceSection("X3: Generate WSDL Description for entity : " + entityName, "");
				var gen = new Generator(entityName, context.endpoint._data.application, context.endpoint._data.contract, context.endpoint._data.dataset);
				return gen.runX3(_, context);
			default:
				throw context.badRequest("Application not valid");
		}

	}catch(e){
		console.log("STACK="+e.stack);
		throw context.badRequest("An error has occured while generating WSDL file for entity : "+ entityName + "\n" + e.stack);
	}
}

function makeWsdl(_, entityName, application, namespace, schema, protocol, wsUrl){

	function addOperations(){

		var generics = genericOperations.get(entityName);
		
		for(var key in generics) {
			addOperation(generics[key].$title, generics[key]);
		}
		
	}
	
	function addOperation(title, op){
		addBinding(title);
		addElements(title);
		addPortType(title);
		addMessages(title);
		createOrderByComplexType();
		addOperationComplexTypes(title, op);
	}
	
	function createOrderByComplexType(){
		addComplexList("orderBy", false);
		addComplexType("orderBy--type", genericOperations.get(entityName).$list.$orderBy);
	}
	
	function addOperationComplexTypes(title, element){
		addComplexType(title + "Request", element.$request);
		addComplexType(title + "Response", element.$response);
	}
	
	function addElements(name){
		addElement(name + "Request");
		addElement(name + "Response");

	}
	
	function addElement(name){
		var element = {
			$: {
				name: name,
				type: "tns:" + name
			}
		}
		wsdl.definitions.types["xs:schema"]["xs:element"].push(element);
	}
	
	function addMessages(name){
		addMessage(name + "Request");
		addMessage(name + "Response");
	}
	
	function addMessage(name){
		var message = {
			$: {
				name: name
			},
			part: {
				$: {
					name: "parameters",
					element: "tns:" + name
				}
			}
		}
		wsdl.definitions.message.push(message);
	}
	
	function addPortType(name){
		var portType = {
			$: {
				name: name
			},
			documentation: "",
			input: {
				$: {
					message: "tns:" + name + "Request"
				}
			},
			output: {
				$: {
					message: "tns:" + name + "Response"
				}
			}
		}
		wsdl.definitions.portType.operation.push(portType);
	}
	
	function addBinding(name){
		var binding = {
			$: {
				name: name
			},
			"soap:operation": {
				$: {
					soapAction: name,
					style: "document"
				}
			},
			input: {
				"soap:body": {
					$: {
						use: "literal"
					}
				}
			},
			output: {
				"soap:body": {
					$: {
						use: "literal"
					}
				}
			}
		}
		wsdl.definitions.binding.operation.push(binding);
	}


	
	function format(title, element, listType){

		var formatted = {
            $: {
              "name": title.indexOf('$') === 0 ? '_' + title.substring(1) : title,
            }
        }
//		if (element.$isMandatory && element.$isMandatory === true)
//			formatted.$.minOccurs = "1";
		
		if (element.$default != null)
			formatted.$.default = element.$default;
		

		
		switch(element.$type){
			case "application/x-collection":
				tracer.traceSubSection("Format Collection: "+ title + " element",JSON.stringify(element,null,2));
				tracer.trace("  Sub item type : "+element.$item.$type);
				var type = element.$item.$type;
				
				if (type && type.indexOf('tns:') !== 0 && type.indexOf('xs:') !== 0){
					type = sHelper.convertType(type);
				}
				if (type != null){
					formatted.$.type = type;

				}else{
					var entityType = sHelper.getEntityType(title, element.$item);
					tracer.trace("Entity type: "+entityType);

					if (entityType != null ){
						formatted.$.type = "tns:" + entityType + "--list";
						if ((!complexTypeExists(entityType + "--type") && !complexTypeExists(entityType + "--list"))  ||  (sHelper.isChild(title,element, entityName))){
							
							if (!complexTypeExists(entityType + "--type")){
								
								addComplexType(entityType + "--type", element.$item);
							}
							if (!complexTypeExists(entityType + "--list")){
									addComplexList(entityType, entityType !== entityName);
							}
						}
					}
					if (listType){
						formatted.$.type = "tns:" + listType + "--type";
						formatted.$.minOccurs = element.$isMandatory && element.$isMandatory === true ? "1" : "0";
						formatted.$.maxOccurs = "unbounded";
					}
				}

				return formatted;
			case "application/x-choice":
				tracer.traceSubSection("Format Choice: "+ title + " element",JSON.stringify(element,null,2));
				var type = element.$value.$type;
				if (type && type.indexOf('tns:') !== 0 && type.indexOf('xs:') !== 0){
					type = sHelper.convertType(type);
				}
				if (type != null){					
					formatted.$.type = "tns:" + title + "--enum";
					var $enum = {
			                $: {
			                  "name": title + "--enum",
			                }
			            }
					$enum["xs:restriction"] = {
						$: {
							base: type
						},
						"xs:enumeration": []
					}
					for( var key in element.$value.$constraints.$enum ) {
						var xsenum = {
							$: {
								value: element.$value.$constraints.$enum[key].$value.toString()
							}
						}
						$enum["xs:restriction"]["xs:enumeration"].push(xsenum);
					}
					wsdl.definitions.types["xs:schema"]["xs:simpleType"].push($enum);
					return formatted;
				}else{
					tracer.trace("Ignore 'x-choice' subtype: '" + element.$type + "' for element: '" + title + "'");
					return;
				}
			case "application/json":
			case "application/x-reference":
				tracer.traceSubSection("Format Reference: "+ title + " element",JSON.stringify(element,null,2));
				var entityType = sHelper.getEntityType(title, element);
				if (!complexTypeExists(entityType)){
					formatted.$.type = "tns:" + entityType + "--type";
					addComplexType(entityType + "--type", element);
					return formatted;
				}else{
					return;
				}
			default:
				tracer.traceSubSection("Format Divers: "+ title + " element",JSON.stringify(element,null,2));
				var type = element.$type;
				if (type && type.indexOf('tns:') !== 0 && type.indexOf('xs:') !== 0){
					type = sHelper.convertType(type);
				}
				if (type != null){
					if (type === "b64"){
						formatted.$.type = "tns:" + title + "-binary--type";
						addbase64ComplexType(title + "-binary--type");
					}else{
						formatted.$.type = type;
					}
					return formatted;
				}else{
					tracer.trace("Ignore type: '" + element.$type + "' for element: '" + title + "'");
					return;
				}
		}
	}
	

	
	function addbase64ComplexType(title){
		var b64cp = {
				$nokey: true,
				$type: "application/x-reference",
				$: {
					content: {
						$type: "xs:base64Binary",
						$default: ""
					},
					length: {
						$type: "xs:integer"
					},
					contentType: {
						$type: "xs:string"
					},
					fileName: {
						$type: "xs:string"
					},
					uploadDate: {
						$type: "xs:dateTime"
					}
				}
		}
		addComplexType(title, b64cp);
	}

	function complexTypeExists(title){
		var cp = wsdl.definitions.types["xs:schema"]["xs:complexType"];
		for (var i in cp){
			if (cp[i].$.name === title){
				return true;
			}
		}
		return false;
	}
	
	
	function addComplexList(cpTitle, withDeleteMissing){
		
		withDeleteMissing = withDeleteMissing != null ? withDeleteMissing : true;
		var listCp = {						
			$nokey: true,
			$type: "application/x-reference",
			$: {}
		};
		
		if (withDeleteMissing){
			listCp.$.$deleteMissing = {
				$type: "xs:boolean",
				$default: "false"
			}
		}

		listCp.$[cpTitle] = {
			$type: "application/x-collection",
			$item: {
				$nokey: true,
				$type: "application/x-reference",
				$: {}
		    }
		};
		
		listCp.$[cpTitle].$item.$[entityName] = {
			$nokey: true,
			$type: "tns:" + entityName +"--type"
		}
		
		addComplexType(cpTitle + "--list", listCp);
	}
	

	function addComplexType(title, element){
		if (!complexTypeExists(title)){
			tracer.traceSection("Add ComplexType : "+title);
			var cp = {
				$: {
					name: title
				},
				"xs:sequence": {
					"xs:element": []
				}
			}
			if (!element.$nokey){
				var _key = {
		                $: {
		                  name: "_key",
		                  minOccurs: "1",
		                  type: "xs:string"
		                }
		            }
				cp["xs:sequence"]["xs:element"].push(_key);
			}
			
			wsdl.definitions.types["xs:schema"]["xs:complexType"].push(cp);
			
			var listType = null;
			if (title.indexOf("--list") === (title.length - 6)){
				listType = title.substring(0,title.length - 6);
			}
			for( var key in element.$ ) {
				tracer.trace("Add Sequence : "+key);
				var formatted = format(key, element.$[key], listType);
				if (formatted)
					cp["xs:sequence"]["xs:element"].push(formatted);
			}
			
			return cp;
		}
	}
	
	var sHelper = soapHelper.create(application, schema);
	entityName =  sHelper.getEntityType(entityName, schema);

	var wsTitle = entityName.charAt(0).toUpperCase() + entityName.slice(1);

	var wsdl = {
		definitions: {

			$: {
				name: wsTitle,
				xmlns: "http://schemas.xmlsoap.org/wsdl/",
				"xmlns:soap": "http://schemas.xmlsoap.org/wsdl/soap/",
				"xmlns:xs": "http://www.w3.org/2001/XMLSchema",
				"xmlns:tns": namespace,
			    targetNamespace: namespace,
			},
			types:{
				"xs:schema": {
					$: {
						elementFormDefault: "qualified",
						version: "1.0",
						targetNamespace: namespace
					},
					"xs:element": [],
					"xs:complexType": [],
					"xs:simpleType": []
				}
			},
			message:[],
			portType:{
				$: {
					name: wsTitle + "SoapType"
				},
				operation: []
			},
			binding:{
				$: {
					name: wsTitle + "SoapBinding",
					type: "tns:" + wsTitle + "SoapType"
				},
				"soap:binding": {
					$: {
						style: "document",
						transport: "http://schemas.xmlsoap.org/soap/http"
					}
				},
				operation: []
			},
			service:{
				$: {
					name: wsTitle
				},
				port: {
					$: {
						name: wsTitle + "Soap",
						binding: "tns:" + wsTitle + "SoapBinding"
					},
					"soap:address": {
						$: {
							location: wsUrl
						}
					}
				}
				
			}
		}
	};


	
	try{

		var primaryCP = addComplexType(entityName + "--type", schema);
		wsdl.definitions.types["xs:schema"]["xs:complexType"][0] = primaryCP;
		addComplexList(entityName, false);
		addOperations();
		//console.log("WSDL="+JSON.stringify(wsdl,null,2));
		wsdl = '<?xml version="1.0" encoding="utf-8"?>\n' + jsxml.stringify(wsdl, { indent: '\t' });
		tracer.traceSection("End WSDL Generation");
	}catch(e){
		throw new Error("Error : "+ e.stack);
	}
	return wsdl;
}