"use strict";

var helpers = require("syracuse-core/lib/helpers");
var util = require("util");
var fs = require('fs');
var jsxml = require('jsxml');
var soapTracer = require('../common/soapTracer');
var ormUtils = require('../common/ormUtils');
var soapUtils = require('../common/soapUtils');
var genericOperations = require('./genericOperations');

var tracer = helpers.soap != null && helpers.soap.wsdl != null && helpers.soap.wsdl.tracer != null ? helpers.soap.wsdl.tracer : false;

var requestType = "$edit";//"$schema";

var tracer = soapTracer.create();

var Generator = helpers.defineClass(function(context) {
	this.context = context;
	this.application = this.context.application.name;
	this.contract = this.context.contract.name;
	this.dataset = this.context.dataset;
	this.entity = this.context.entity;
	this.entityName = this.context.entity.name;
	
}, null, {
	run: function(_){
		var schema = this.context.getPrototypeResource(_, this.entityName + "." + requestType);
		//tracer.traceSubSection("Entity Schema : " + this.entityName, JSON.stringify(schema,null,2));
		return this.makeWsdl(_, schema);
		//this.write(_, wsdl);
	},
	makeWsdl: function(_, schema){

		function addOperations(){

			var generics = genericOperations.get(entityName);
			
			// Add orderBy--list type
			
			for(var key in generics) {
				addOperation(generics[key].$title, generics[key]);
			}
			
		}
		
		function addOperation(title, op){
			addBinding(title);
			addElements(title);
			addPortType(title);
			addMessages(title);
			createOrderByComplexType();
			addOperationComplexTypes(title, op);
		}
		
		function createOrderByComplexType(){
			addComplexList("orderBy", false);
			addComplexType("orderBy--type", genericOperations.get(entityName).$list.$orderBy);
		}
		
		function addOperationComplexTypes(title, element){
			addComplexType(title + "Request", element.$request);
			addComplexType(title + "Response", element.$response);
		}
		
		function addElements(name){
			addElement(name + "Request");
			addElement(name + "Response");

		}
		
		function addElement(name){
			var element = {
				$: {
					name: name,
					type: "tns:" + name
				}
			}
			wsdl.definitions.types["xs:schema"]["xs:element"].push(element);
		}
		
		function addMessages(name){
			addMessage(name + "Request");
			addMessage(name + "Response");
		}
		
		function addMessage(name){
			var message = {
				$: {
					name: name
				},
				part: {
					$: {
						name: "parameters",
						element: "tns:" + name
					}
				}
			}
			wsdl.definitions.message.push(message);
		}
		
		function addPortType(name){
			var portType = {
				$: {
					name: name
				},
				documentation: "",
				input: {
					$: {
						message: "tns:" + name + "Request"
					}
				},
				output: {
					$: {
						message: "tns:" + name + "Response"
					}
				}
			}
			wsdl.definitions.portType.operation.push(portType);
		}
		
		function addBinding(name){
			var binding = {
				$: {
					name: name
				},
				"soap:operation": {
					$: {
						soapAction: name,
						style: "document"
					}
				},
				input: {
					"soap:body": {
						$: {
							use: "literal"
						}
					}
				},
				output: {
					"soap:body": {
						$: {
							use: "literal"
						}
					}
				}
			}
			wsdl.definitions.binding.operation.push(binding);
		}

		function format(title, element, listType){
			var formatted = {
                $: {
                  "name": title.indexOf('$') === 0 ? '_' + title.substring(1) : title,
                }
            }
//			if (element.$isMandatory && element.$isMandatory === true)
//				formatted.$.minOccurs = "1";
			
			if (element.$default != null)
				formatted.$.default = element.$default;
			

			
			switch(element.$type){
				case "application/x-collection":
					tracer.traceSubSection("Format Collection: "+ title + " element",JSON.stringify(element,null,2));
					tracer.trace("  Sub item type : "+element.$item.$type);
					var type = element.$item.$type;
					
					if (type && type.indexOf('tns:') !== 0 && type.indexOf('xs:') !== 0){
						type = soapUtils.convertType(type);
					}
					if (type != null){
						formatted.$.type = type;

					}else{
						
						// WILL NOT WORK WITH REST API
						// TODO: FIND A WAY TO GET ENTITY TYPE WITHOUT ORM !!!
						var entityType = ormUtils.getRelationType(title, context);
						tracer.trace("Entity type: "+entityType);
						
						if (entityType != null){
							formatted.$.type = "tns:" + entityType + "--list";
							if (!complexTypeExists(entityType + "--type")){
								
								addComplexType(entityType + "--type", element.$item);
							}
							if (!complexTypeExists(entityType + "--list")){
									addComplexList(entityType);
							}

						}else{
							
							if (listType){
								formatted.$.type = "tns:" + listType + "--type";
								formatted.$.minOccurs = element.$isMandatory && element.$isMandatory === true ? "1" : "0";
								formatted.$.maxOccurs = "unbounded";
							}
						}

					}

					return formatted;
				case "application/x-choice":
					tracer.traceSubSection("Format Choice: "+ title + " element",JSON.stringify(element,null,2));
					var type = element.$value.$type;
					if (type && type.indexOf('tns:') !== 0 && type.indexOf('xs:') !== 0){
						type = soapUtils.convertType(type);
					}
					if (type != null){					
						formatted.$.type = "tns:" + title + "--enum";
						var $enum = {
				                $: {
				                  "name": title + "--enum",
				                }
				            }
						$enum["xs:restriction"] = {
							$: {
								base: type
							},
							"xs:enumeration": []
						}
						for( var key in element.$value.$constraints.$enum ) {
							var xsenum = {
								$: {
									value: element.$value.$constraints.$enum[key].$value.toString()
								}
							}
							$enum["xs:restriction"]["xs:enumeration"].push(xsenum);
						}
						wsdl.definitions.types["xs:schema"]["xs:simpleType"].push($enum);
						return formatted;
					}else{
						tracer.trace("Ignore 'x-choice' subtype: '" + element.$type + "' for element: '" + title + "'");
						return;
					}
				case "application/json":
				case "application/x-reference":
					tracer.traceSubSection("Format Reference: "+ title + " element",JSON.stringify(element,null,2));

					if (!complexTypeExists(title)){
						formatted.$.type = "tns:" + title + "--type";
						addComplexType(title + "--type", element);
						return formatted;
					}else{
						return;
					}
				default:
					tracer.traceSubSection("Format Divers: "+ title + " element",JSON.stringify(element,null,2));
					var type = element.$type;
					if (type && type.indexOf('tns:') !== 0 && type.indexOf('xs:') !== 0){
						type = soapUtils.convertType(type);
					}
					if (type != null){
						if (type === "b64"){
							formatted.$.type = "tns:" + title + "--type";
							addbase64ComplexType(title + "--type");
						}else{
							formatted.$.type = type;
						}
						return formatted;
					}else{
						tracer.trace("Ignore type: '" + element.$type + "' for element: '" + title + "'");
						return;
					}
			}
		}
		

		
		function addbase64ComplexType(title){
			var b64cp = {
					$nokey: true,
					$type: "application/x-reference",
					$: {
						content: {
							$type: "xs:base64Binary",
							$default: ""
						},
						length: {
							$type: "xs:integer"
						},
						contentType: {
							$type: "xs:string"
						},
						fileName: {
							$type: "xs:string"
						},
						uploadDate: {
							$type: "xs:dateTime"
						}
					}
			}
			addComplexType(title, b64cp);
		}

		function complexTypeExists(title){
			var cp = wsdl.definitions.types["xs:schema"]["xs:complexType"];
			for (var i in cp){
				if (cp[i].$.name === title){
					return true;
				}
			}
			return false;
		}
		
		
		function addComplexList(cpTitle, withDeleteMissing){
			
			withDeleteMissing = withDeleteMissing != null ? withDeleteMissing : true;
			var listCp = {						
				$nokey: true,
				$type: "application/x-reference",
				$: {}
			};
			
			if (withDeleteMissing){
				listCp.$.$deleteMissing = {
					$type: "xs:boolean",
					$default: "false"
				}
			}

			listCp.$[cpTitle] = {
				$type: "application/x-collection",
				$item: {
					$nokey: true,
					$type: "application/x-reference",
					$: {}
			    }
			};
			
			listCp.$[cpTitle].$item.$[entityName] = {
				$nokey: true,
				$type: "tns:" + entityName +"--type"
			}
			
			addComplexType(cpTitle + "--list", listCp);
		}
		

		function addComplexType(title, element){
			if (!complexTypeExists(title)){
				tracer.traceSection("Add ComplexType : "+title);
				var cp = {
					$: {
						name: title
					},
					"xs:sequence": {
						"xs:element": []
					}
				}
				if (!element.$nokey){
					var _key = {
			                $: {
			                  name: "_key",
			                  minOccurs: "1",
			                  type: "xs:string"
			                }
			            }
					cp["xs:sequence"]["xs:element"].push(_key);
				}
				
				wsdl.definitions.types["xs:schema"]["xs:complexType"].push(cp);
				
				var listType = null;
				if (title.indexOf("--list") === (title.length - 6)){
					listType = title.substring(0,title.length - 6);
				}
				for( var key in element.$ ) {
					tracer.trace("Add Sequence : "+key);
					var formatted = format(key, element.$[key], listType);
					if (formatted)
						cp["xs:sequence"]["xs:element"].push(formatted);
				}
				
				return cp;
			}
		}
		
		var context = this.context;
		var namespace = this.application + "." + this.contract + "." + this.dataset;
		var entity = this.entity;
		var entityName = this.entityName;
		var title = this.entityName.charAt(0).toUpperCase() + this.entityName.slice(1);
		var description = schema.$description;
		var plural = schema.$pluralType;


		var wsdl = {
			definitions: {

				$: {
					name: title,
					xmlns: "http://schemas.xmlsoap.org/wsdl/",
					"xmlns:soap": "http://schemas.xmlsoap.org/wsdl/soap/",
					"xmlns:xs": "http://www.w3.org/2001/XMLSchema",
					"xmlns:tns": namespace,
				    targetNamespace: namespace,
				},
				types:{
					"xs:schema": {
						$: {
							elementFormDefault: "qualified",
							version: "1.0",
							targetNamespace: namespace
						},
						"xs:element": [],
						"xs:complexType": [],
						"xs:simpleType": []
					}
				},
				message:[],
				portType:{
					$: {
						name: title + "SoapType"
					},
					operation: []
				},
				binding:{
					$: {
						name: title + "SoapBinding",
						type: "tns:" + title + "SoapType"
					},
					"soap:binding": {
						$: {
							style: "document",
							transport: "http://schemas.xmlsoap.org/soap/http"
						}
					},
					operation: []
				},
				service:{
					$: {
						name: title
					},
					documentation: description,
					port: {
						$: {
							name: title + "Soap",
							binding: "tns:" + title + "SoapBinding"
						},
						"soap:address": {
							$: {
								location: schema.$baseUrl + "/" + plural
							}
						}
					}
					
				}
			}
		};



		
		
		try{
			var primaryCP = addComplexType(this.entityName + "--type", schema);
			wsdl.definitions.types["xs:schema"]["xs:complexType"][0] = primaryCP;
			addComplexList(this.entityName);
			addOperations();
			//console.log("WSDL="+JSON.stringify(wsdl,null,2));
			wsdl = '<?xml version="1.0" encoding="utf-8"?>\n' + jsxml.stringify(wsdl, { indent: '\t' });
			tracer.traceSection("End WSDL Generation");
		}catch(e){
			throw new Error("Error : "+ e.stack);
		}
		return wsdl;
	}
	
});



exports.generate = function(_, context){
	try{
		tracer.traceSection("Generate WSDL Description for entity : "+ context.entity.name, "");
		var gen = new Generator(context);
		return gen.run(_);
	}catch(e){
		console.log("STACK="+e.stack);
		throw context.badRequest("An error has occured while generating WSDL file for entity : "+ context.entity.name + "\n" + e.stack);
	}
}