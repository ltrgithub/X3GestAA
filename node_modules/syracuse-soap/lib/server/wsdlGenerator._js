"use strict";

var helpers = require('syracuse-core/lib/helpers');
var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var util = require("util");
var fs = require('fs');
var jsxml = require('jsxml');
var globals = require('streamline/lib/globals');
var soapTracer = require('../common/soapTracer');
var soapHelper = require('./soapHelper');
var restUtils = require('./restUtils');
var genericOperations = require('./genericOperations');

var Template = require('syracuse-core/lib/resource/resourceProxy').Template;
var streams = require('streamline/lib/streams/streams');


var tracer = soapTracer.create("wsdl");

var Generator = helpers.defineClass(function(_, service, entities) {

	this.context = globals.context;
	this.serviceName = service.name(_);
	this.entities = entities;

	this.application = service.applicationName(_);
	this.contract = service.contractName(_);
	this.dataset = service.endpointName(_);
	this.model = service.endpoint(_).getOrm(_).model;


	this.baseUrl = this.context.session.host + "/soap/" + this.application + "/" + this.contract + "/" + this.dataset;

	this.url = this.baseUrl + "/" + this.serviceName;
	this.namespace = this.dataset + "." + this.contract + "." + this.application

	this.requestType = "$edit";
	if (this.application === "x3")
		this.requestType = "$details";
	
}, null, {
	makeWsdl: function(_){
	
		function addOperations(entityName, generics){
			for(var key in generics) {
				addOperation(entityName, generics[key].$title, generics[key]);
			}
		}
		
		function addOperation(entityName, title, op){
			addBinding(title);
			
			addPortType(title);
			addMessages(entityName, title);
	
		}

		function addMessages(entityName, name){
			addMessage(entityName, name + "Request");
			addMessage(entityName, name + "Response");
		}
		
		function addMessage(entityName, name){
			var message = {
				$: {
					name: name
				},
				part: {
					$: {
						name: "parameters",
						element: entityName + ":" + name
					}
				}
			}
			wsdl.definitions.message.push(message);
		}
		
		function addPortType(name){
			var portType = {
				$: {
					name: name
				},
				documentation: "",
				input: {
					$: {
						message: "tns:" + name + "Request"
					}
				},
				output: {
					$: {
						message: "tns:" + name + "Response"
					}
				}
			}
			wsdl.definitions.portType.operation.push(portType);
		}
		
		function addBinding(name){
			var binding = {
				$: {
					name: name
				},
				"soap:operation": {
					$: {
						soapAction: name,
						style: "document"
					}
				},
				input: {
					"soap:body": {
						$: {
							use: "literal"
						}
					}
				},
				output: {
					"soap:body": {
						$: {
							use: "literal"
						}
					}
				}
			}
			wsdl.definitions.binding.operation.push(binding);
		}
	
	
	
		
		
		
		function addSchema(_, entityName, representationName, schema, generics){
					
			function format(title, element, listType){
	
				var formatted = {
		            $: {
		              "name": title.indexOf('$') === 0 ? '_' + title.substring(1) : title,
		            }
		        }
	//			if (element.$isMandatory && element.$isMandatory === true)
	//				formatted.$.minOccurs = "1";
				
				if (element.$default != null)
					formatted.$.default = element.$default;
				
	
				
				switch(element.$type){
					case "application/x-collection":
						tracer.traceSubSection("Format Collection: "+ title + " element",JSON.stringify(element,null,2));
						tracer.trace("  Sub item type : "+element.$item.$type);
						var type = element.$item.$type;
						
						if (type && type.indexOf(ns) !== 0 && type.indexOf('xs:') !== 0){
							type = sHelper.convertType(type);
						}
						if (type != null){
							formatted.$.type = type;
	
						}else{
							var entityType = sHelper.getEntityType(title, element.$item);
							var elementType;
							if (self.application !== "x3"){
								if (entityType !== self.model.singularize(entityName)){
									elementType = entityType;
								}else{
									elementType = representationName;
								}
							}else{
								elementType = entityType;
							}
							tracer.trace("Entity type: "+elementType);
	
							if (elementType != null ){
								formatted.$.type = ns + elementType + "--list";
								if ((!complexTypeExists(elementType + "--type") && !complexTypeExists(elementType + "--list"))  ||  (sHelper.isChild(title,element, elementName))){
									
									if (!complexTypeExists(elementType + "--type")){
										
										addComplexType(elementType + "--type", element.$item);
									}
									if (!complexTypeExists(elementType + "--list")){
											addComplexList(elementType, elementType !== elementName);
									}
								}
							}
							if (listType){
								formatted.$.type = ns + listType + "--type";
								formatted.$.minOccurs = element.$isMandatory && element.$isMandatory === true ? "1" : "0";
								formatted.$.maxOccurs = "unbounded";
							}
						}
	
						return formatted;
					case "application/x-choice":
						tracer.traceSubSection("Format Choice: "+ title + " element",JSON.stringify(element,null,2));
						var type = element.$value.$type;
						if (type && type.indexOf(ns) !== 0 && type.indexOf('xs:') !== 0){
							type = sHelper.convertType(type);
						}
						if (type != null){					
							formatted.$.type = ns + title + "--enum";
							var $enum = {
					                $: {
					                  "name": title + "--enum",
					                }
					            }
							$enum["xs:restriction"] = {
								$: {
									base: type
								},
								"xs:enumeration": []
							}
							for( var key in element.$value.$constraints.$enum ) {
								var xsenum = {
									$: {
										value: element.$value.$constraints.$enum[key].$value.toString()
									}
								}
								$enum["xs:restriction"]["xs:enumeration"].push(xsenum);
							}
							xsd["xs:simpleType"].push($enum);
							return formatted;
						}else{
							tracer.trace("Ignore 'x-choice' subtype: '" + element.$type + "' for element: '" + title + "'");
							return;
						}
					case "application/json":
					case "application/x-reference":
						tracer.traceSubSection("Format Reference: "+ title + " element",JSON.stringify(element,null,2));
						var entityType = sHelper.getEntityType(title, element);
						var elementType;
						if (self.application !== "x3"){
							if (entityType !== self.model.singularize(entityName)){
								elementType = entityType;
							}else{
								elementType = representationName;
							}
						}else{
							elementType = entityType;
						}

						if (!complexTypeExists(elementType)){
							formatted.$.type = ns + elementType + "--type";
							addComplexType(elementType + "--type", element);
							return formatted;
						}else{
							return;
						}
					default:
						tracer.traceSubSection("Format Divers: "+ title + " element",JSON.stringify(element,null,2));
						var type = element.$type;
						if (type && type.indexOf(ns) !== 0 && type.indexOf('xs:') !== 0){
							type = sHelper.convertType(type);
						}
						if (type != null){
							if (type === "b64"){
								formatted.$.type = ns + title + "-binary--type";
								addbase64ComplexType(title + "-binary--type");
							}else{
								formatted.$.type = type;
							}
							return formatted;
						}else{
							tracer.trace("Ignore type: '" + element.$type + "' for element: '" + title + "'");
							return;
						}
				}
			}
			
	
			
			function addbase64ComplexType(title){
				var b64cp = {
						$nokey: true,
						$type: "application/x-reference",
						$: {
							content: {
								$type: "xs:base64Binary",
								$default: ""
							},
							length: {
								$type: "xs:integer"
							},
							contentType: {
								$type: "xs:string"
							},
							fileName: {
								$type: "xs:string"
							},
							uploadDate: {
								$type: "xs:dateTime"
							}
						}
				}
				addComplexType(title, b64cp);
			}
	
			function createOrderByComplexType(){
				addComplexList("orderBy", false);
				addComplexType("orderBy--type", genericOperations.get(elementName).$list.$orderBy);
			}
			
			
			function complexTypeExists(title){
				var cp = xsd["xs:complexType"];
				for (var i in cp){
					if (cp[i].$.name === title){
						return true;
					}
				}
				return false;
			}
			
	
			function addOperationComplexTypes(title, element){
				addElement(title + "Request");
				addElement(title + "Response");
				addComplexType(title + "Request", element.$request);
				addComplexType(title + "Response", element.$response);
			}
			
			function addComplexList(cpTitle, withDeleteMissing){
				
				withDeleteMissing = withDeleteMissing != null ? withDeleteMissing : true;
				var listCp = {						
					$nokey: true,
					$type: "application/x-reference",
					$: {}
				};
				
				if (withDeleteMissing){
					listCp.$.$deleteMissing = {
						$type: "xs:boolean",
						$default: "false"
					}
				}
	
				listCp.$[cpTitle] = {
					$type: "application/x-collection",
					$item: {
						$nokey: true,
						$type: "application/x-reference",
						$: {}
				    }
				};
				
				listCp.$[cpTitle].$item.$[elementName] = {
					$nokey: true,
					$type: ns + elementName +"--type"
				}
				
				addComplexType(cpTitle + "--list", listCp);
			}
			

			
			function addElement(name){
				var element = {
					$: {
						name: name,
						type: ns + name
					}
				}
				xsd["xs:element"].push(element);
			}
			
			function addComplexType(title, element){
				if (!complexTypeExists(title)){
					tracer.traceSection("Add ComplexType : "+title);
					var cp = {
						$: {
							name: title
						},
						"xs:sequence": {
							"xs:element": []
						}
					}
					if (!element.$nokey){
						var _key = {
				                $: {
				                  name: "_key",
				                  minOccurs: "1",
				                  type: "xs:string"
				                }
				            }
						cp["xs:sequence"]["xs:element"].push(_key);
					}
					
					xsd["xs:complexType"].push(cp);
					
					var listType = null;
					if (title.indexOf("--list") === (title.length - 6)){
						listType = title.substring(0,title.length - 6);
					}
					for( var key in element.$ ) {
						tracer.trace("Add Sequence : "+key);
						var formatted = format(key, element.$[key], listType);
						if (formatted)
							cp["xs:sequence"]["xs:element"].push(formatted);
					}
					
					return cp;
				}
			}
			
			var ns = representationName + ":";


			var sHelper = soapHelper.create(self.application, schema);
			var elementName =  sHelper.getEntityType(entityName, schema);

			var xsd = {
				$: {
					elementFormDefault: "qualified",
					//version: "1.0",
					targetNamespace: representationName + "." + self.namespace
				},
				"xs:element": [],
				"xs:complexType": [],
				"xs:simpleType": []
			
			};
			
			
			var primaryCP = addComplexType(elementName + "--type", schema);
			xsd["xs:complexType"][0] = primaryCP;
			addComplexList(elementName, false);
			createOrderByComplexType();
			
			for(var key in generics) {
				addOperationComplexTypes(generics[key].$title, generics[key]);
			}
			
	
			
			return xsd;
			
		}
		
		
		
		
		
	
		var self = this;
		var wsTitle = this.serviceName.charAt(0).toUpperCase() + this.serviceName.slice(1);
	
		var wsdl = {
			definitions: {
	
				$: {
					name: wsTitle,
					xmlns: "http://schemas.xmlsoap.org/wsdl/",
					"xmlns:soap": "http://schemas.xmlsoap.org/wsdl/soap/",
					"xmlns:xs": "http://www.w3.org/2001/XMLSchema",
					"xmlns:tns": this.namespace,
				    targetNamespace: this.namespace,
				},
				types:{
					"xs:schema": [],
				},
				message:[],
				portType:{
					$: {
						name: wsTitle + "SoapType"
					},
					operation: []
				},
				binding:{
					$: {
						name: wsTitle + "SoapBinding",
						type: "tns:" + wsTitle + "SoapType"
					},
					"soap:binding": {
						$: {
							style: "document",
							transport: "http://schemas.xmlsoap.org/soap/http"
						}
					},
					operation: []
				},
				service:{
					$: {
						name: wsTitle
					},
					port: {
						$: {
							name: wsTitle + "Soap",
							binding: "tns:" + wsTitle + "SoapBinding"
						},
						"soap:address": {
							$: {
								location: this.url
							}
						}
					}
					
				}
			}
		};
	
	
		
		try{
	
			if (this.entities.length === 0)
				throw new Error("The web service '"+this.serviceName+"' must contains at least one entity.");
			
			for (var ent in this.entities){
				var entity = this.entities[ent];
				var entityName = entity.name;
				var representations = entity.representations;
				
				var i = 0;
				if (representations.length === 0)
					throw new Error("The entity '"+entityName+"' must contains at least one representation.");
				
				for (var rep in representations){
					var representation, schema;
					representation = representations[rep];
					schema = restUtils.getPrototype(_, this.context.request.headers, this.baseUrl, representation, this.requestType);
					if (!schema)
						throw new Error("An error has occured while retrieving protoype: " +representation + "." + this.requestType);
					
					
					var generics = genericOperations.get(representation);
					// Add a definitions namespace
					wsdl.definitions.$["xmlns:" + representation] = representation + "." + this.namespace;
					// Add schema
					wsdl.definitions.types["xs:schema"].push(addSchema(_, entityName, representation, schema, generics));
					// Add operations
					addOperations(representation, generics);
					i++;
				}
			}

			//console.log("WSDL="+JSON.stringify(wsdl,null,2));
			wsdl = '<?xml version="1.0" encoding="utf-8"?>\n' + jsxml.stringify(wsdl, { indent: '\t' });
			tracer.traceSection("End WSDL Generation");
		}catch(e){
			throw new Error("Error : "+ e.stack);
		}
		return wsdl;
	}
	
});



exports.generate = function(_, service){
	try{

		var entities = [];

		var soapEntities = service.entities(_).toArray(_);
		for (var i in soapEntities){
			var entity = {
					name: soapEntities[i].name(_),
					representations: []
			}
			var representations = soapEntities[i].representations(_).toArray(_);
			for (var j in representations){
				entity.representations.push(representations[j].name(_));
			}
			entities.push(entity);
		}

			
		tracer.traceSection("Generate WSDL description for SOAP Web Service: "+service.name(_), "Included entities: "+JSON.stringify(entities,null,2));
		var gen = new Generator(_, service, entities);
		return gen.makeWsdl(_);

	}catch(e){
		console.log("STACK="+e.stack);
		throw new Error(e.message);
	}
}
