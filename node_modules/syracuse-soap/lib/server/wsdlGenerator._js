"use strict";

var helpers = require('syracuse-core/lib/helpers');
var adminHelper = require('syracuse-collaboration/lib/helpers').AdminHelper;
var util = require("util");
var fs = require('fs');
var jsxml = require('jsxml');

var soapTracer = require('../common/soapTracer');
var soapHelper = require('./soapHelper');
var restUtils = require('./restUtils');
var genericOperations = require('./genericOperations');

var Template = require('syracuse-core/lib/resource/resourceProxy').Template;
var streams = require('streamline/lib/streams/streams');
var config = require('syracuse-main/lib/nodeconfig').config;






var tracer = soapTracer.create("wsdl");

var Generator = helpers.defineClass(function(serviceName, context, entities) {

	this.context = context;
	this.serviceName = serviceName;
	this.entities = entities;
	
	if (context.applicationName === "x3"){
		this.application = context.endpoint._data.application;
		this.contract = context.endpoint._data.contract;
		this.dataset = context.endpoint._data.dataset;
	}else{
		this.application = context.application.name;
		this.contract = context.contract.name;
		this.dataset = context.dataset;
	}
	
	this.url = this.context.baseUrl.replace("/sdata/", "/soap/") + "/" + serviceName;
	this.namespace = this.dataset + "." + this.contract + "." + this.application

	this.requestType = "$edit";
	if (this.application === "x3")
		this.requestType = "$details";
	
}, null, {
	makeWsdl: function(_){
	
		function addOperations(entityName, generics){
			for(var key in generics) {
				addOperation(entityName, generics[key].$title, generics[key]);
			}
		}
		
		function addOperation(entityName, title, op){
			addBinding(title);
			
			addPortType(title);
			addMessages(entityName, title);
	
		}

		function addMessages(entityName, name){
			addMessage(entityName, name + "Request");
			addMessage(entityName, name + "Response");
		}
		
		function addMessage(entityName, name){
			var message = {
				$: {
					name: name
				},
				part: {
					$: {
						name: "parameters",
						element: entityName + ":" + name
					}
				}
			}
			wsdl.definitions.message.push(message);
		}
		
		function addPortType(name){
			var portType = {
				$: {
					name: name
				},
				documentation: "",
				input: {
					$: {
						message: "tns:" + name + "Request"
					}
				},
				output: {
					$: {
						message: "tns:" + name + "Response"
					}
				}
			}
			wsdl.definitions.portType.operation.push(portType);
		}
		
		function addBinding(name){
			var binding = {
				$: {
					name: name
				},
				"soap:operation": {
					$: {
						soapAction: name,
						style: "document"
					}
				},
				input: {
					"soap:body": {
						$: {
							use: "literal"
						}
					}
				},
				output: {
					"soap:body": {
						$: {
							use: "literal"
						}
					}
				}
			}
			wsdl.definitions.binding.operation.push(binding);
		}
	
	
	
		
		
		
		function addSchema(_, entityName, schema, generics){
			
			function format(title, element, listType){
	
				var formatted = {
		            $: {
		              "name": title.indexOf('$') === 0 ? '_' + title.substring(1) : title,
		            }
		        }
	//			if (element.$isMandatory && element.$isMandatory === true)
	//				formatted.$.minOccurs = "1";
				
				if (element.$default != null)
					formatted.$.default = element.$default;
				
	
				
				switch(element.$type){
					case "application/x-collection":
						tracer.traceSubSection("Format Collection: "+ title + " element",JSON.stringify(element,null,2));
						tracer.trace("  Sub item type : "+element.$item.$type);
						var type = element.$item.$type;
						
						if (type && type.indexOf(ns) !== 0 && type.indexOf('xs:') !== 0){
							type = sHelper.convertType(type);
						}
						if (type != null){
							formatted.$.type = type;
	
						}else{
							var entityType = sHelper.getEntityType(title, element.$item);
							tracer.trace("Entity type: "+entityType);
	
							if (entityType != null ){
								formatted.$.type = ns + entityType + "--list";
								if ((!complexTypeExists(entityType + "--type") && !complexTypeExists(entityType + "--list"))  ||  (sHelper.isChild(title,element, entityName))){
									
									if (!complexTypeExists(entityType + "--type")){
										
										addComplexType(entityType + "--type", element.$item);
									}
									if (!complexTypeExists(entityType + "--list")){
											addComplexList(entityType, entityType !== entityName);
									}
								}
							}
							if (listType){
								formatted.$.type = ns + listType + "--type";
								formatted.$.minOccurs = element.$isMandatory && element.$isMandatory === true ? "1" : "0";
								formatted.$.maxOccurs = "unbounded";
							}
						}
	
						return formatted;
					case "application/x-choice":
						tracer.traceSubSection("Format Choice: "+ title + " element",JSON.stringify(element,null,2));
						var type = element.$value.$type;
						if (type && type.indexOf(ns) !== 0 && type.indexOf('xs:') !== 0){
							type = sHelper.convertType(type);
						}
						if (type != null){					
							formatted.$.type = ns + title + "--enum";
							var $enum = {
					                $: {
					                  "name": title + "--enum",
					                }
					            }
							$enum["xs:restriction"] = {
								$: {
									base: type
								},
								"xs:enumeration": []
							}
							for( var key in element.$value.$constraints.$enum ) {
								var xsenum = {
									$: {
										value: element.$value.$constraints.$enum[key].$value.toString()
									}
								}
								$enum["xs:restriction"]["xs:enumeration"].push(xsenum);
							}
							xsd["xs:simpleType"].push($enum);
							return formatted;
						}else{
							tracer.trace("Ignore 'x-choice' subtype: '" + element.$type + "' for element: '" + title + "'");
							return;
						}
					case "application/json":
					case "application/x-reference":
						tracer.traceSubSection("Format Reference: "+ title + " element",JSON.stringify(element,null,2));
						var entityType = sHelper.getEntityType(title, element);
						if (!complexTypeExists(entityType)){
							formatted.$.type = ns + entityType + "--type";
							addComplexType(entityType + "--type", element);
							return formatted;
						}else{
							return;
						}
					default:
						tracer.traceSubSection("Format Divers: "+ title + " element",JSON.stringify(element,null,2));
						var type = element.$type;
						if (type && type.indexOf(ns) !== 0 && type.indexOf('xs:') !== 0){
							type = sHelper.convertType(type);
						}
						if (type != null){
							if (type === "b64"){
								formatted.$.type = ns + title + "-binary--type";
								addbase64ComplexType(title + "-binary--type");
							}else{
								formatted.$.type = type;
							}
							return formatted;
						}else{
							tracer.trace("Ignore type: '" + element.$type + "' for element: '" + title + "'");
							return;
						}
				}
			}
			
	
			
			function addbase64ComplexType(title){
				var b64cp = {
						$nokey: true,
						$type: "application/x-reference",
						$: {
							content: {
								$type: "xs:base64Binary",
								$default: ""
							},
							length: {
								$type: "xs:integer"
							},
							contentType: {
								$type: "xs:string"
							},
							fileName: {
								$type: "xs:string"
							},
							uploadDate: {
								$type: "xs:dateTime"
							}
						}
				}
				addComplexType(title, b64cp);
			}
	
			function createOrderByComplexType(){
				addComplexList("orderBy", false);
				addComplexType("orderBy--type", genericOperations.get(entityName).$list.$orderBy);
			}
			
			
			function complexTypeExists(title){
				var cp = xsd["xs:complexType"];
				for (var i in cp){
					if (cp[i].$.name === title){
						return true;
					}
				}
				return false;
			}
			
	
			function addOperationComplexTypes(title, element){
				addElement(title + "Request");
				addElement(title + "Response");
				addComplexType(title + "Request", element.$request);
				addComplexType(title + "Response", element.$response);
			}
			
			function addComplexList(cpTitle, withDeleteMissing){
				
				withDeleteMissing = withDeleteMissing != null ? withDeleteMissing : true;
				var listCp = {						
					$nokey: true,
					$type: "application/x-reference",
					$: {}
				};
				
				if (withDeleteMissing){
					listCp.$.$deleteMissing = {
						$type: "xs:boolean",
						$default: "false"
					}
				}
	
				listCp.$[cpTitle] = {
					$type: "application/x-collection",
					$item: {
						$nokey: true,
						$type: "application/x-reference",
						$: {}
				    }
				};
				
				listCp.$[cpTitle].$item.$[entityName] = {
					$nokey: true,
					$type: ns + entityName +"--type"
				}
				
				addComplexType(cpTitle + "--list", listCp);
			}
			

			
			function addElement(name){
				var element = {
					$: {
						name: name,
						type: ns + name
					}
				}
				xsd["xs:element"].push(element);
			}
			
			function addComplexType(title, element){
				if (!complexTypeExists(title)){
					tracer.traceSection("Add ComplexType : "+title);
					var cp = {
						$: {
							name: title
						},
						"xs:sequence": {
							"xs:element": []
						}
					}
					if (!element.$nokey){
						var _key = {
				                $: {
				                  name: "_key",
				                  minOccurs: "1",
				                  type: "xs:string"
				                }
				            }
						cp["xs:sequence"]["xs:element"].push(_key);
					}
					
					xsd["xs:complexType"].push(cp);
					
					var listType = null;
					if (title.indexOf("--list") === (title.length - 6)){
						listType = title.substring(0,title.length - 6);
					}
					for( var key in element.$ ) {
						tracer.trace("Add Sequence : "+key);
						var formatted = format(key, element.$[key], listType);
						if (formatted)
							cp["xs:sequence"]["xs:element"].push(formatted);
					}
					
					return cp;
				}
			}
			
			var ns = entityName + ":";


			var sHelper = soapHelper.create(self.application, schema);
			entityName =  sHelper.getEntityType(entityName, schema);

			var xsd = {
				$: {
					elementFormDefault: "qualified",
					//version: "1.0",
					targetNamespace: entityName + "." + self.namespace
				},
				"xs:element": [],
				"xs:complexType": [],
				"xs:simpleType": []
			
			};
			
			
			var primaryCP = addComplexType(entityName + "--type", schema);
			xsd["xs:complexType"][0] = primaryCP;
			addComplexList(entityName, false);
			createOrderByComplexType();
			
			for(var key in generics) {
				addOperationComplexTypes(generics[key].$title, generics[key]);
			}
			
	
			
			return xsd;
			
		}
		
		
		
		
		
	
		var self = this;
		var wsTitle = this.serviceName.charAt(0).toUpperCase() + this.serviceName.slice(1);
	
		var wsdl = {
			definitions: {
	
				$: {
					name: wsTitle,
					xmlns: "http://schemas.xmlsoap.org/wsdl/",
					"xmlns:soap": "http://schemas.xmlsoap.org/wsdl/soap/",
					"xmlns:xs": "http://www.w3.org/2001/XMLSchema",
					"xmlns:tns": this.namespace,
				    targetNamespace: this.namespace,
				},
				types:{
					"xs:schema": [],
				},
				message:[],
				portType:{
					$: {
						name: wsTitle + "SoapType"
					},
					operation: []
				},
				binding:{
					$: {
						name: wsTitle + "SoapBinding",
						type: "tns:" + wsTitle + "SoapType"
					},
					"soap:binding": {
						$: {
							style: "document",
							transport: "http://schemas.xmlsoap.org/soap/http"
						}
					},
					operation: []
				},
				service:{
					$: {
						name: wsTitle
					},
					port: {
						$: {
							name: wsTitle + "Soap",
							binding: "tns:" + wsTitle + "SoapBinding"
						},
						"soap:address": {
							$: {
								location: this.url
							}
						}
					}
					
				}
			}
		};
	
	
		
		try{
	
			var i = 0;
			for (var entity in this.entities){
				var entityName, schema;
				if (self.context.applicationName === "x3"){
					entityName = this.entities[entity];
					schema = restUtils.getPrototype(_, this.context, entityName, this.requestType);
				}else{
					
					entityName = this.context.model.singularize(this.entities[entity]);
					schema = this.context.getPrototypeResource(_, entityName + "." + this.requestType);
				}
				
				if (!schema)
					throw new Error("An error has occured while retrieving protoype: " +entityName + "." + this.requestType);
				
				
				var generics = genericOperations.get(entityName);
				wsdl.definitions.$["xmlns:" + entityName] = entityName + "." + this.namespace;
				wsdl.definitions.types["xs:schema"].push(addSchema(_, entityName, schema, generics));
				addOperations(entityName, generics);
				i++;
			}
			
	
			
			//console.log("WSDL="+JSON.stringify(wsdl,null,2));
			wsdl = '<?xml version="1.0" encoding="utf-8"?>\n' + jsxml.stringify(wsdl, { indent: '\t' });
			tracer.traceSection("End WSDL Generation");
		}catch(e){
			throw new Error("Error : "+ e.stack);
		}
		return wsdl;
	}
	
});



exports.generate = function(_, serviceName, context, soapEntities){
	try{
//		console.log("SERVICE NAME="+serviceName);
//		var entities = [];
//		//console.log("ent="+util.inspect(soapEntities));
//		for (var i in soapEntities){
//			
//			
//			entities.push(soapEntities[i].name(_));
//		}
		tracer.traceSection("Generate WSDL description for SOAP Web Service: "+serviceName, "Included entities: "+JSON.stringify(soapEntities,null,2));
		var gen = new Generator(serviceName, context, soapEntities);
		return gen.makeWsdl(_);

	}catch(e){
		console.log("STACK="+e.stack);
		throw context.badRequest("An error has occured while generating WSDL file for service : "+ serviceName + "\n" + e.stack);
	}
}
