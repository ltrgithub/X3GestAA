"use strict";

var helpers = require("syracuse-core/lib/helpers");
var util = require("util");
var fs = require('fs');
var jsxml = require('jsxml');
var soapHelper = require('./soapHelper');
var soapTracer = require('../common/soapTracer');
var date = require('syracuse-core/lib/types/date');
var time = require('syracuse-core/lib/types/time');
var datetime = require('syracuse-core/lib/types/datetime');
var locale = require("syracuse-core/lib/locale");
var registry = require("syracuse-sdata/lib/sdataRegistry");
var Context = require("syracuse-sdata/lib/sdataContext").Context;
var dataModel = require("syracuse-orm/lib/dataModel");
var dataContext = require("syracuse-orm/lib/dataContext");


var tracer = soapTracer.create("request");



var ormExecutor = helpers.defineClass(function(_,entityName, representation, context) {


	this.context = context;
	
	this.endpoint = context.endpoint;

	this.app = context.applicationName;
	if (this.app === "qunit")
		this.app = "syracuse";
	

	this.application = context.application.name;
	this.contract = context.contract.name;
	this.dataset = context.dataset;
	
	if (!this.context.entity && this.context.db) {

		this.context.entity = this.context.db.getEntity(_, entityName);
		if (!this.context.entity) throw new Error(locale.format(module, "entityNotFound", entityName));
	}
	
	
	this.entityName = this.context.entity.name;
	this.representation = representation;
	this.title = representation.charAt(0).toUpperCase() + representation.slice(1);

	
}, null, {
	execute: function(_, method, params){

		function getPrototype(_, facetName){
			
			if (self.app === "x3"){
				return self.context.entity.getPrototype(_, self.context.entity.name, facetName); 

			}else{
				return self.context.getPrototypeResource(_, self.representation + "." + facetName);
			}
			

		}
		function getBinary(_, title){
			if (params.$binary === "true"){
				var store = instance[title](_);
				// read the binary content
				if (!store.fileExists(_)) throw new Error("File doesn't exist");
				
				var buf = store.createReadableStream(_).readAll(_);
				var props = store.getProperties(_);

				return {
					content: buf.toString('base64'),
					length: props.length.toString(),
					contentType: props.contentType,
					fileName: props.fileName,
					uploadDate : datetime.fromJsDate(props.uploadDate).toString()
				}
			}else{
				return;
			}
		}
		
		function setBinary(_, binaryInstance, param){

			
			var buf = new Buffer(param.content, 'base64').toString('binary');

			if (buf != null && buf.length !== 0){
				
				var props = {
						length: buf.length,
						contentType: param.contentType,
						fileName: param.fileName
				}
			
				var store = binaryInstance;

				var stream = store.createWritableStream(_, props);
				stream.write(_, buf, "binary");
				stream.end(null, "", _);
			}

		}
		

		function $details(_){

			if (params.$key === "")
				throw new Error("The '_key' parameter must not be undefined for 'READ' operation.");
			
			schema = getPrototype(_, "$details");
			if (!schema)
				throw new Error("An error has occured while retrieving prototype: " + self.entityName + ".$details");
			//console.log("Schema = "+JSON.stringify(schema,null,2));
			
			var instance = self.context.db.fetchInstance(_, self.context.entity, params.$key);
			
			if (instance != null){

				
				
				var sHelper = soapHelper.create(self.application, schema);
				
				var serializedInstance = instance.serializeInstance(_);
				//tracer.trace("Instance = " +JSON.stringify(serializedInstance,null,2));

				response[self.representation] = {};
				response[self.representation]._key = instance.$key;
				for( var key in schema.$properties ) {

					if (serializedInstance[key] != null){
						if(serializedInstance[key].length === 0){
							response[self.representation][key] = "";
						}else{
							var formatted = sHelper.formatValueForXml(_, key, schema.$properties[key], serializedInstance, getBinary);
							if (formatted){
								if (key.indexOf('$') === 0)
									key = '_' + key.substring(1);
								response[self.representation][key] = formatted;
							}
						}
					}
					else if(serializedInstance[key] === null){
						response[self.representation][key] = {$: {"xsi:nil": "true"}};
					}
					// DO NOTHING for undefined
					
				}
			}else{
				response[self.representation] = {$: {"xsi:nil": "true"}};
			}
			return response;
		}
		
		function $edit(_, isUpdate){
			
			
			
			function writeInstance(_, instance, parameters){
				
			
				function mustWrite(param, isUpdateReq){
					if (param == null){
						return false;
					}else if (param.$key && typeof param.$key === 'object'){
						return false;
					}else if (param.$key != null && !isUpdateReq){
						return true;
					}else if (isUpdateReq){
						return true;
					}else{
						return true;
					}
				}//End mustWrite
				
				function writeInstanceParam(_, paramName, param){
					
					function writeInstanceProperty(_, propertyName){
						if (param.$ && param.$["xsi:nil"] === "true"){
							instance[propertyName](_, null);
						}else{
							var converted = sHelper.convertValue(schema.$properties[propertyName].$type, param);
							if (converted != null){
								if (converted !== "b64"){
									if (converted !== instance[propertyName](_)){
										//tracer.trace("Set instance property '" + propertyName + "' with value : '" + converted + "'");
										instance[propertyName](_, converted);
									}
								}else{
									//tracer.trace("Set store property: " + propertyName);
									setBinary(_, instance[propertyName](_), param);
								}
							}else{
								tracer.trace("## Ignore property: " + propertyName + " because type "+schema.$properties[propertyName].$type +" is not compatible");
							}
						}
					}//End writeInstanceProperty
					
					function writeInstanceRelation(_, relationName){
						
						
						function getInstance(_, subParams, entityType, isChild){
							tracer.trace(" - Sub param: "+entityType);
							var entity = self.context.model.getEntity(entityType);
							var subInst = self.context.db.fetchInstance(_, entity, subParams.$key);
							
							if (isChild){
								if (!subInst){
									var newChildParam = null;
									var factory = entity.factory;
									tracer.traceSubSection("Create Child Instance with $uuid :" +subParams.$key,"");
									subInst = factory.createInstance(_, null, self.context.db);
									if (subParams.$key != null && subParams.$key !== ""){
										subInst.$uuid = subParams.$key;
										subInst.$key = subParams.$key;
									}
									writeInstance(_, subInst, subParams).$key;

								}else{
									tracer.trace("Child ["+uuid+"] already exists.");
								}
							}else{
								if (subParams.$key){
									if (!subInst)
										throw new Error("No '" + entityType + "' instance found with identifier '" + subParams.$key + "'");
								}else{
									return;
								}
							}
							return subInst;
						}// End getInstance
						
						
						function writeInstanceRelationReference(_){
							tracer.trace("$relation: Reference");
							
							if (param.$key){
								if (inst != null && isUpdate){
									// Save oldKey only for update
									var oldKey = inst.$key;
								}
								var relationInstance = instance._meta.$relations[relationName];
								// Get instance or create it if it's child and doesn't exists
								inst = getInstance(_, param, relationInstance.$type, relationInstance.isChild);
							}
	
							if (mustWrite(param, isUpdate)){
								if (param.$key){
									if(oldKey)
										tracer.trace("Old key: " +oldKey);
									// If it's a creation or if it's an update and keys are differents
									if (oldKey == null || param.$key !== oldKey){
										tracer.trace("  --> Add one " + relationName + ":\n" + param.$key);
										instance[relationName](_, inst);
									}else{
										tracer.trace("No change on " + relationName + ":\n" + inst.$key);
									}
								}else{
									if (inst){
										tracer.trace("  --> Delete relation " + relationName + ":\n" + inst.$key);
										instance[relationName](_, null);
									}
								}
							}else{
								tracer.trace("PROBLEM: Don't write");
							}
						}// End writeInstanceRelationReference
						
						function writeInstanceRelationCollection(_){
							
							function setRelation(_, relParam){
								// Get instance or create it if it's child and doesn't exists
								var subInst = getInstance(_, relParam, instType, inst._relMeta.isChild);
								if (subInst != null){
									tracer.trace("  --> Add " + instType +": " + subInst.$key + "\n");
									inst.set(_, subInst);
								}
							}
							
							var instType = self.context.model.singularize(inst._relMeta.type);
												
							tracer.trace("$relation: Collection of type: "+instType);

							var colElements = [];
							
							if (param[instType]){
								// Multiple elements
								if (!param[instType].$key){
									for (var i in param[instType]){
										if (mustWrite(param[instType][i], isUpdate)){
											colElements.push(param[instType][i]);
										}
									}
								}
								// Only one element
								else{
									if (mustWrite(param[instType], isUpdate)){
										colElements.push(param[instType]);
									}
								}
							}
							for (var elt in colElements){
								setRelation(_, colElements[elt]);
							}
							
							// $deleteMissing decide if keep missing relations
							if (param.$deleteMissing === "true"){
								tracer.trace(" $deleteMissing = true");
								for (var rel in inst._data){
									var found = false;
									for (var elt in colElements){
										if (colElements[elt].$key === rel){
											found = true;
											break;
										}
									}
									if (!found){
										tracer.trace("  --> Delete relation " + relationName + ": " + rel);
										inst.deleteInstance(_,rel);
									}
								}
							}

						}// End writeInstanceRelationCollection

						// Retrieve current instance
						var inst = instance[relationName](_);
						// Process $relations references
						if (!inst || !inst._relMeta || !inst._relMeta.isPlural){
							writeInstanceRelationReference(_);
						}
						// Process $relations collections
						else{
							writeInstanceRelationCollection(_);
						}
					
					}//End writeInstanceRelation
					
					
					//----------------------------------------------------------
					if (mustWrite(param, isUpdate)){
						tracer.traceSubSection("Write instance parameter: "+paramName);//,"value: "+JSON.stringify(param,null,2));

						if (instance._meta.$properties[paramName]){
							writeInstanceProperty(_, paramName);
						}else if (instance._meta.$relations[paramName]){
							writeInstanceRelation(_, paramName);
						}
					}
				}//End writeInstanceParam


				tracer.traceSection("Write instance : "+instance.$uuid,"");


				for( var key in schema.$properties ) {
					//var param = params[self.representation][key];
					var param = parameters[key];
					writeInstanceParam(_, key, param, instance);
				}

				return instance;

			}//End writeInstance
				
			schema = getPrototype(_, "$edit");
			if (!schema)
				throw new Error("An error has occured while retrieving prototype: " + self.representation + ".$edit");
			//console.log("Schema = "+JSON.stringify(schema,null,2));
			
			isUpdate = isUpdate != null ? isUpdate : false;
			var primaryInstance;
			if (isUpdate){
				primaryInstance = self.context.db.fetchInstance(_, self.context.entity, params[self.representation].$key);
				if (!primaryInstance)
					throw new Error("No '" + self.representation + "' instance found with identifier '" + params[self.representation].$key + "'");
					
			}else{
				var factory = self.context.entity.factory;
				primaryInstance = factory.createInstance(_, null, self.context.db);
			}

			

			
			var sHelper = soapHelper.create(self.application, schema);
			
			primaryInstance = writeInstance(_, primaryInstance, params[self.representation]);
			
			
			//tracer.traceSubSection("Save instance: " + primaryInstance.$uuid, JSON.stringify(primaryInstance.serializeInstance(_),null,2));
			var res = primaryInstance.save(_);
			//tracer.trace("Save Result: "+JSON.stringify(res,null,2));
			soapHelper.ckeckDiagnoses(res);

			response._key = primaryInstance.$key;

			return response;
		}
		
		
		
		
		
		function $delete(_){
			if (params.$key === "")
				throw new Error("The '_key' parameter must not be undefined for 'DELETE' operation.");
			
			
			var instance = self.context.db.fetchInstance(_, self.context.entity, params.$key);
			if (instance != null){
				// TODO: canDelete must be remove when cristi add it in deleteSelf function
				if (instance.canDelete(_)){
					var res = instance.deleteSelf(_);
					if (res){
						response.deleted = "true";
					}else{
						throw new Error(instance.deleteError);
					}
				}else{
					throw new Error(instance.deleteError);
				}
			}else{
				throw new Error("No '" + self.representation + "' instance found with identifier '" + params.$key + "'");
			}
			return response;
		}
		
		function $query(_){

			var fetchParams = {};
			
			// count
			if (params.$count)
				fetchParams.count = parseInt(params.$count);

			// sdataWhere
			if (params.$sdataWhere)
				fetchParams.sdataWhere = params.$sdataWhere;
			
			// orderBy
			if (params.$orderBy){
				fetchParams.orderBy = [];
				if (!params.$orderBy.orderBy.$binding){
					for (var elt in params.$orderBy.orderBy){
						var paramOrderBy = {
								binding: params.$orderBy.orderBy[elt].$binding,
								descending: params.$orderBy.orderBy[elt].$descending === "true"
						};
						fetchParams.orderBy.push(paramOrderBy);
					}
				}else{
					var paramOrderBy = {
						binding: params.$orderBy.orderBy.$binding,
						descending: params.$orderBy.orderBy.$descending === "true"
					}
					fetchParams.orderBy.push(paramOrderBy);
				}
			}
			
			// startIndex
			if (self.app !== "x3"){
				if (params.$pageInfo)
					fetchParams.startIndex = parseInt(params.$pageInfo);
			}else{
				if (params.$pageInfo !== "null")
					fetchParams.key = params.$pageInfo;
			}
			
			tracer.trace("Fetch parameters: "+JSON.stringify(fetchParams,null,2));
			
			
			
			schema = getPrototype(_, "$query");
			if (!schema)
				throw new Error("An error has occured while retrieving prototype: " + self.representation + ".$query");
			
			//console.log("Schema="+JSON.stringify(schema,null,2));
			
			var instances = self.context.db.fetchInstances(_, self.context.entity, fetchParams);
		
			
			// No 'startIndex' and 'totalResults' for X3 $query
			if (self.app !== "x3"){
				response._pageInfo = (params.$pageInfo != null && params.$pageInfo.length !== 0) ? params.$pageInfo : "1";
				response._totalResults = self.context.db.count(_, self.context.entity, fetchParams).toString();
			}else{
				if (fetchParams.key)
					response._pageInfo = fetchParams.key;					
			}

			
			response._itemsPerPage = params.$count != null ? params.$count.toString() : "20";

			var sHelper = soapHelper.create(self.application, schema);
			
			response[self.representation + "List"] = {};
			response[self.representation + "List"][self.representation] = [];
			for (var i in instances){
				var instance = instances[i];
				var serializedInstance = instance.serializeInstance(_);
				//tracer.trace("Instance = \n" +JSON.stringify(serializedInstance,null,2));

				response[self.representation + "List"][self.representation][i] = {};
				
				response[self.representation + "List"][self.representation][i] = {};
				response[self.representation + "List"][self.representation][i]._key = instance.$key;
				for( var key in schema.$properties.$resources.$item.$properties ) {
					if (instance[key]){
						var formatted = sHelper.formatValueForXml(_, key, schema.$properties.$resources.$item.$properties[key], serializedInstance, getBinary, "syracuse");
						if (formatted){
							if (key.indexOf('$') === 0)
								key = '_' + key.substring(1);
							response[self.representation + "List"][self.representation][i][key] = formatted;
						}
					}
				}

			}
			//response._totalResults = response[self.representation + "List"][self.representation].length.toString();
			return response;
		}
		
		
	 
		//tracer.traceSection("Execute REST Request for method : " + method , "Parameters=\n" + JSON.stringify(params,null,2));
		var self = this;
		var namespace = this.representation + "." + this.dataset + "." + this.contract + "." + this.application;
		var schema;
		
		var response = {
			$: {
				"xmlns": namespace
			}
		};

		switch(method){
			case ("read" + this.title):
				return $details(_);
			case ("list" + this.title):
				return $query(_);
			case ("create" + this.title):
				return $edit(_);
			case ("update" + this.title):
				return $edit(_, true);
			case ("delete" + this.title):
				return $delete(_);
			default:
				throw new Error("Invalid soap action:" + method);
		}

	}
});




exports.create = function(_, entityName, representation, context){
	return new ormExecutor(_, entityName, representation, context);
}


