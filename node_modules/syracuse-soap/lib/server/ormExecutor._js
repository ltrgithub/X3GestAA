"use strict";

var helpers = require("syracuse-core/lib/helpers");
var soapHelper = require('./soapHelper');
var soapTracer = require('../common/soapTracer');
var datetime = require('syracuse-core/lib/types/datetime');
var locale = require("syracuse-core/lib/locale");

var tracer = soapTracer.create("request");

var OrmExecutor = helpers.defineClass(function(_, entityName, representation, context) {

	this.context = context;

	this.endpoint = context.endpoint;

	this.app = context.applicationName;
	if (this.app === "qunit") this.app = "syracuse";

	this.application = context.application.name;
	this.contract = context.contract.name;
	this.dataset = context.dataset;

	if (!this.context.entity && this.context.db) {

		this.context.entity = this.context.db.getEntity(_, entityName);
		if (!this.context.entity) throw new Error(locale.format(module, "entityNotFound", entityName));
	}

	this.entityName = this.context.entity.name;
	this.representation = representation;
	this.title = representation.charAt(0).toUpperCase() + representation.slice(1);

}, null, {
	execute: function(_, method, params) {

		function getPrototype(_, facetName) {

			if (self.app === "x3") {
				return self.context.entity.getPrototype(_, self.context.entity.name, facetName);

			} else {
				return self.context.getPrototypeResource(_, self.representation + "." + facetName);
			}

		}

		function getBinary(_, title, instance) {
			//			console.log("INSTANCE="+util.inspect(instance));
			if (params.$binary === "true") {
				var store = instance[title](_);
				// read the binary content
				if (!store.fileExists(_)) throw new Error(locale.format(module, "fileNotExist"));

				var buf = store.createReadableStream(_).readAll(_);
				var props = store.getProperties(_);

				return {
					content: buf.toString('base64'),
					length: props.length.toString(),
					contentType: props.contentType,
					fileName: props.fileName,
					uploadDate: datetime.fromJsDate(props.uploadDate).toString()
				};
			} else {
				return;
			}
		}

		function setBinary(_, binaryInstance, param) {

			//console.log("PARAM="+util.inspect(param));
			var buf = new Buffer(param.content, 'base64').toString('binary');

			if (buf != null && buf.length !== 0) {

				var props = {
					length: buf.length,
					contentType: param.contentType,
					fileName: param.fileName
				};

				var store = binaryInstance;

				var stream = store.createWritableStream(_, props);
				stream.write(_, buf, "binary");
				stream.end(null, "", _);
			}

		}

		function $details(_) {

			if (params.$key === "") throw new Error(locale.format(module, "keyNeededForOperation", "READ"));

			schema = getPrototype(_, "$details");
			if (!schema) throw new Error(locale.format(module, "errGetProto", self.entityName, "details"));
			//console.log("Schema = "+JSON.stringify(schema,null,2));

			var instance = self.context.db.fetchInstance(_, self.context.entity, params.$key);

			if (instance != null) {

				var sHelper = soapHelper.create(self.application, schema);

				var serializedInstance = instance.serializeInstance(_);
				//tracer.trace("Instance = " +JSON.stringify(serializedInstance,null,2));

				response[self.representation] = {};
				response[self.representation]._key = instance.$key;
				for (var key in schema.$properties) {
					if (serializedInstance[key] != null) {
						if (serializedInstance[key].length === 0) {
							response[self.representation][key] = "";
						} else {
							var formatted = sHelper.formatValueForXml(_, key, schema.$properties[key], serializedInstance, getBinary);
							if (formatted) {
								if (key.indexOf('$') === 0) key = '_' + key.substring(1);
								response[self.representation][key] = formatted;
							}
						}
					} else if (serializedInstance[key] === null) {
						response[self.representation][key] = {
							$: {
								"xsi:nil": "true"
							}
						};
					}
					// DO NOTHING for undefined

				}
			} else {
				response[self.representation] = {
					$: {
						"xsi:nil": "true"
					}
				};
			}
			return response;
		}

		function $edit(_, isUpdate) {

			function writeInstance(_, instance, parameters) {

				function mustWrite(param, isUpdateReq) {
					if (param == null) {
						return false;
					} else if (param.$key && typeof param.$key === 'object') {
						return false;
					} else if (param.$key != null && !isUpdateReq) {
						return true;
					} else if (isUpdateReq) {
						return true;
					} else {
						return true;
					}
				} //End mustWrite

				function writeInstanceParam(_, paramName, param) {

					function writeInstanceProperty(_, propertyName) {
						if (param.$ && param.$["xsi:nil"] === "true") {
							instance[propertyName](_, null);
						} else {
							var converted = sHelper.convertValue(schema.$properties[propertyName].$type, param);
							if (converted != null) {
								if (converted !== "b64") {
									if (converted !== instance[propertyName](_)) {
										//tracer.trace("Set instance property '" + propertyName + "' with value : '" + converted + "'");
										instance[propertyName](_, converted);
									}
								} else {
									//tracer.trace("Set store property: " + propertyName);

									if (param && (typeof param === 'string')) setBinary(_, instance[propertyName](_), param);
								}
							} else {
								tracer.trace("## Ignore property: " + propertyName + " because type " + schema.$properties[propertyName].$type + " is not compatible");
							}
						}
					} //End writeInstanceProperty

					function writeInstanceRelation(_, relationName) {

						function getInstance(_, subParams, entityType, isChild) {
							tracer.trace(" - Sub param: " + entityType);
							var entity = self.context.model.getEntity(_, entityType);
							var subInst = self.context.db.fetchInstance(_, entity, subParams.$key);

							if (isChild) {
								if (!subInst) {
									var factory = entity.factory;
									tracer.traceSubSection("Create Child Instance with $uuid :" + subParams.$key, "");
									subInst = factory.createInstance(_, null, self.context.db);
									if (subParams.$key != null && subParams.$key !== "") {
										subInst.$uuid = subParams.$key;
										subInst.$key = subParams.$key;
									}
									writeInstance(_, subInst, subParams).$key;

								} else {
									tracer.trace("Child [" + subInst.$uuid + "] already exists.");
								}
							} else {
								if (subParams.$key) {
									if (!subInst) throw new Error(locale.format(module, "entityTypeNotFound", entityType, subParams.$key));
								} else {
									return;
								}
							}
							return subInst;
						} // End getInstance

						function writeInstanceRelationReference(_) {
							tracer.trace("$relation: Reference");
							var oldKey;
							if (param.$key) {
								if (inst != null && isUpdate) {
									// Save oldKey only for update
									oldKey = inst.$key;
								}
								var relationInstance = instance._meta.$relations[relationName];
								// Get instance or create it if it's child and doesn't exists
								inst = getInstance(_, param, relationInstance.$type, relationInstance.getIsChild());
							}

							if (mustWrite(param, isUpdate)) {
								if (param.$key) {
									if (oldKey) tracer.trace("Old key: " + oldKey);
									// If it's a creation or if it's an update and keys are differents
									if (oldKey == null || param.$key !== oldKey) {
										tracer.trace("  --> Add one " + relationName + ":\n" + param.$key);
										instance[relationName](_, inst);
									} else {
										tracer.trace("No change on " + relationName + ":\n" + inst.$key);
									}
								} else {
									if (inst) {
										tracer.trace("  --> Delete relation " + relationName + ":\n" + inst.$key);
										instance[relationName](_, null);
									}
								}
							} else {
								tracer.trace("PROBLEM: Don't write");
							}
						} // End writeInstanceRelationReference

						function writeInstanceRelationCollection(_) {

							function setRelation(_, relParam) {
								// Get instance or create it if it's child and doesn't exists
								var subInst = getInstance(_, relParam, instType, inst._relMeta.getIsChild());
								if (subInst != null) {
									tracer.trace("  --> Add " + instType + ": " + subInst.$key + "\n");
									inst.set(_, subInst);
								}
							}

							var instType = self.context.model.singularize(inst._relMeta.type);

							tracer.trace("$relation: Collection of type: " + instType);

							var colElements = [];

							if (param[instType]) {
								// Multiple elements
								if (!param[instType].$key) {
									for (var i in param[instType]) {
										if (mustWrite(param[instType][i], isUpdate)) {
											colElements.push(param[instType][i]);
										}
									}
								}
								// Only one element
								else {
									if (mustWrite(param[instType], isUpdate)) {
										colElements.push(param[instType]);
									}
								}
							}
							var elt;
							for (elt in colElements) {
								setRelation(_, colElements[elt]);
							}

							// $deleteMissing decide if keep missing relations
							if (param.$deleteMissing === "true") {
								tracer.trace(" $deleteMissing = true");
								for (var rel in inst._data) {
									var found = false;
									for (elt in colElements) {
										if (colElements[elt].$key === rel) {
											found = true;
											break;
										}
									}
									if (!found) {
										tracer.trace("  --> Delete relation " + relationName + ": " + rel);
										inst.deleteInstance(_, rel);
									}
								}
							}

						} // End writeInstanceRelationCollection

						// Retrieve current instance
						var inst = instance[relationName](_);
						// Process $relations references
						if (!inst || !inst._relMeta || !inst._relMeta.isPlural) {
							writeInstanceRelationReference(_);
						}
						// Process $relations collections
						else {
							writeInstanceRelationCollection(_);
						}

					} //End writeInstanceRelation

					//----------------------------------------------------------
					if (mustWrite(param, isUpdate)) {
						tracer.traceSubSection("Write instance parameter: " + paramName); //,"value: "+JSON.stringify(param,null,2));

						if (instance._meta.$properties[paramName]) {
							writeInstanceProperty(_, paramName);
						} else if (instance._meta.$relations[paramName]) {
							writeInstanceRelation(_, paramName);
						}
					}
				} //End writeInstanceParam

				tracer.traceSection("Write instance : " + instance.$uuid, "");

				for (var key in schema.$properties) {
					//var param = params[self.representation][key];
					var param = parameters[key];
					writeInstanceParam(_, key, param, instance);
				}

				return instance;

			} //End writeInstance

			schema = getPrototype(_, "$edit");
			if (!schema) throw new Error(locale.format(module, "errGetProto", self.representation, "edit"));
			//console.log("Schema = "+JSON.stringify(schema,null,2));

			isUpdate = isUpdate != null ? isUpdate : false;
			var primaryInstance;
			if (isUpdate) {
				primaryInstance = self.context.db.fetchInstance(_, self.context.entity, params[self.representation].$key);
				if (!primaryInstance) throw new Error(locale.format(module, "entityTypeNotFound", self.representation, params[self.representation].$key));

			} else {
				var factory = self.context.entity.factory;
				primaryInstance = factory.createInstance(_, null, self.context.db);
			}

			var sHelper = soapHelper.create(self.application, schema);

			primaryInstance = writeInstance(_, primaryInstance, params[self.representation]);

			//tracer.traceSubSection("Save instance: " + primaryInstance.$uuid, JSON.stringify(primaryInstance.serializeInstance(_),null,2));
			var res = primaryInstance.save(_);
			//tracer.trace("Save Result: "+JSON.stringify(res,null,2));
			soapHelper.ckeckDiagnoses(res);

			response._key = primaryInstance.$key;

			return response;
		}

		function $delete(_) {
			if (params.$key === "") throw new Error(locale.format(module, "keyNeededForOperation", "DELETE"));

			var instance = self.context.db.fetchInstance(_, self.context.entity, params.$key);
			if (instance != null) {
				// TODO: $canDelete must be remove when cristi add it in deleteSelf function
				if (instance.$canDelete(_)) {
					var res = instance.deleteSelf(_);
					if (res) {
						response.deleted = "true";
					} else {
						throw new Error(instance.deleteError);
					}
				} else {
					throw new Error(instance.deleteError);
				}
			} else {
				throw new Error(locale.format(module, "entityTypeNotFound", self.representation, params.$key));
			}
			return response;
		}

		function $query(_) {

			var fetchParams = {};
			schema = getPrototype(_, "$query");
			if (!schema) throw new Error(locale.format(module, "errGetProto", self.representation, "query"));
			//console.log("Schema="+JSON.stringify(schema,null,2));
			var sHelper = soapHelper.create(self.application, schema);

			// count
			if (params.$count) fetchParams.count = parseInt(params.$count, 10);

			// sdataWhere
			if (params.$sdataWhere) {
				sHelper.checkWhere(params.$sdataWhere);
				fetchParams.sdataWhere = params.$sdataWhere;
			}

			// orderBy
			if (params.$orderBy && params.$orderBy.orderBy) {
				fetchParams.orderBy = [];
				var paramOrderBy;
				if (!params.$orderBy.orderBy.$binding) {
					for (var elt in params.$orderBy.orderBy) {
						paramOrderBy = {
							binding: params.$orderBy.orderBy[elt].$binding,
							descending: params.$orderBy.orderBy[elt].$descending === "true"
						};
						fetchParams.orderBy.push(paramOrderBy);
					}
				} else {
					paramOrderBy = {
						binding: params.$orderBy.orderBy.$binding,
						descending: params.$orderBy.orderBy.$descending === "true"
					};
					fetchParams.orderBy.push(paramOrderBy);
				}
			}
			// startIndex
			if (self.app !== "x3") {
				if (params.$pageInfo) fetchParams.startIndex = parseInt(params.$pageInfo, 10);
			} else {
				if (params.$pageInfo !== "null") fetchParams.key = params.$pageInfo;
			}

			tracer.trace("Fetch parameters: " + JSON.stringify(fetchParams, null, 2));
			var instances = self.context.db.fetchInstances(_, self.context.entity, fetchParams);

			// No 'startIndex' and 'totalResults' for X3 $query
			if (self.app !== "x3") {
				response._pageInfo = (params.$pageInfo != null && params.$pageInfo.length !== 0) ? params.$pageInfo : "1";
				response._totalResults = self.context.db.count(_, self.context.entity, fetchParams).toString();
			} else {
				if (fetchParams.key) response._pageInfo = fetchParams.key;
			}

			response._itemsPerPage = params.$count != null ? params.$count.toString() : "20";

			response[self.representation + "List"] = {};
			response[self.representation + "List"][self.representation] = [];
			for (var i in instances) {
				var instance = instances[i];
				var serializedInstance = instance.serializeInstance(_);
				//tracer.trace("Instance = \n" +JSON.stringify(serializedInstance,null,2));

				response[self.representation + "List"][self.representation][i] = {};

				response[self.representation + "List"][self.representation][i] = {};
				response[self.representation + "List"][self.representation][i]._key = instance.$key;
				for (var key in schema.$properties.$resources.$item.$properties) {
					if (instance[key]) {
						var formatted = sHelper.formatValueForXml(_, key, schema.$properties.$resources.$item.$properties[key], serializedInstance, getBinary, "syracuse");
						if (formatted) {
							if (key.indexOf('$') === 0) key = '_' + key.substring(1);
							response[self.representation + "List"][self.representation][i][key] = formatted;
						}
					}
				}

			}
			//response._totalResults = response[self.representation + "List"][self.representation].length.toString();
			return response;
		}

		//tracer.traceSection("Execute REST Request for method : " + method , "Parameters=\n" + JSON.stringify(params,null,2));
		var self = this;
		var namespace = this.representation + "." + this.dataset + "." + this.contract + "." + this.application;
		var schema;

		var response = {
			$: {
				"xmlns": namespace
			}
		};

		switch (method) {
			case ("read" + this.title):
				return $details(_);
			case ("list" + this.title):
				return $query(_);
			case ("create" + this.title):
				return $edit(_);
			case ("update" + this.title):
				return $edit(_, true);
			case ("delete" + this.title):
				return $delete(_);
			default:
				throw new Error(locale.format(module, "invalidSoapAction", method));
		}

	}
});

exports.create = function(_, entityName, representation, context) {
	return new OrmExecutor(_, entityName, representation, context);
};