"use strict";

var helpers = require("syracuse-core/lib/helpers");
var util = require("util");
var fs = require('fs');
var jsxml = require('jsxml');
var soapUtils = require('../common/soapUtils');
var ormUtils = require('../common/ormUtils');
var soapTracer = require('../common/soapTracer');
var date = require('syracuse-core/lib/types/date');
var time = require('syracuse-core/lib/types/time');
var datetime = require('syracuse-core/lib/types/datetime');

var registry = require("syracuse-sdata/lib/sdataRegistry");
var Context = require("syracuse-sdata/lib/sdataContext").Context;
var dataModel = require("syracuse-orm/lib/dataModel");
var dataContext = require("syracuse-orm/lib/dataContext");


var tracer = soapTracer.create();



var ormExecutor = helpers.defineClass(function(context) {
	this.context = context;
	this.application = this.context.application.name;
	this.contract = this.context.contract.name;
	this.dataset = this.context.dataset;
	this.entityName = this.context.entity.name;
	this.title = this.entityName.charAt(0).toUpperCase() + this.entityName.slice(1);

	
}, null, {
	execute: function(_, method, params){

		function getBinary(_, title){
			if (params.$binary === "true"){
				var store = instance[title](_);
				// read the binary content
				if (!store.fileExists(_)) throw new Error("File doesn't exist");
				
				var buf = store.createReadableStream(_).readAll(_);
				var props = store.getProperties(_);

				return {
					content: buf.toString('base64'),
					length: props.length.toString(),
					contentType: props.contentType,
					fileName: props.fileName,
					uploadDate : datetime.fromJsDate(props.uploadDate).toString()
				}
			}else{
				return;
			}
		}
		
		function setBinary(_, binaryInstance, param){

			
			var buf = new Buffer(param.content, 'base64').toString('binary');

			if (buf != null && buf.length !== 0){
				
				var props = {
						length: buf.length,
						contentType: param.contentType,
						fileName: param.fileName
				}
			
				var store = binaryInstance;

				var stream = store.createWritableStream(_, props);
				stream.write(_, buf, "binary");
				stream.end(null, "", _);
			}

		}
		

		function format(_, title, element, serializedInstance){
			
			function returnValue(_){
				var result;
				if (val != null){
					var type = soapUtils.convertType(element.$type);
					// $ properties are not the same as other instance properties
					if (title.indexOf("$") === 0){
						if (type === "xs:date"){
								return date.fromJsDate(new Date(val), true).toString();
						}else if (type === "xs:time"){
								return time.fromJsDate(new Date(val), true).toString();
						}else if (type === "xs:dateTime"){
								return datetime.fromJsDate(val).toString();
						}
					}
					if (type === "b64"){
						return getBinary(_, title);
					}else{
						try{
							var json = JSON.parse(val);
							if (typeof json === 'object'){
								return JSON.stringify(json,null,0);
							}else{
								return val.toString();
							}
						}catch(e){
							return val.toString();
						}
					}
				}else{
					return;
				}

			}
			
			function formatReference(_){
				tracer.trace("formatReference");
				var ref = {};
				if (val != null && val.$uuid){
					ref._key = val.$uuid
				}
					
				for( var key in element.$ ) {
					if (val != null){
						var formatted = format(_, key, element.$[key], val);
						if (formatted)
							ref[key] = formatted;
					}
				}
				return ref;
			}
			
			function formatCollection(_){
				

				
				var relationType = ormUtils.isChild(title, self.context) ? self.entityName : ormUtils.getRelationType(title, self.context);
				tracer.trace("format Collection of type: "+relationType);
				var col = {};
				col[relationType] = [];
				for (var i in val){
					var item = {};
					col[relationType][i] = item;
					if (val[i] != null && val[i].$uuid){
						col[relationType][i]._key = val[i].$uuid
					}
					for( var key in element.$item.$ ) {
						var formatted = format(_, key, element.$item.$[key], val[i]);
						if (formatted)
							item[key] = formatted;
					}
				}					
				return col[relationType].length !== 0 ? col : null;
			}
			
			function formatJson(_){
				tracer.trace("formatJson");
				var ref = {};
				if (val != null && val.$uuid){
					ref._key = val.$uuid
				}
					
				for( var key in element.$item.$ ) {
					if (val != null){
						var formatted = format(_, key, element.$item.$[key], val);
						if (formatted)
							ref[key] = formatted;
					}
				}
				return ref;
			}
			
			var val = serializedInstance[title];
			tracer.traceSection("Resolve: "+title , "type: "+element.$type+"\nValue: "+ JSON.stringify(val,null,2));
			switch(element.$type){
			case "application/x-collection":
				return formatCollection(_);
			case "application/x-choice":
				return returnValue(_);
			case "application/json":
				return formatJson(_);
			case "application/x-reference":
				return formatReference(_);
			case "application/x-range":
				tracer.trace("Ignore type: '" + element.$type + "' for element: '" + title + "'");
				return;
			case "application/x-graph":
				tracer.trace("Ignore type: '" + element.$type + "' for element: '" + title + "'");
				return;

			default:
				var type = element.$type;
				if (type != null){
					return returnValue(_);
				}else{
					// if $type absent type is considered to application/json
					if (element.$item != null){
						return formatJson(_);
					}else{
						tracer.trace("**Ignore type: '" + element.$type + "' for element: '" + title + "'");
						return;
					}
				}
			}

		}
		

		
		function ckeckDiagnoses(obj){
			//tracer.trace(util.inspect(obj));

			for (var i in obj.$diagnoses){
				if (obj.$diagnoses[i] != null){
					throw new Error(obj.$diagnoses[i].severity + ": " + obj.$diagnoses[i].message);
				}
			}
			Object.keys(obj.$).forEach(function(elt){
				if (obj.$[elt].$diagnoses != null && obj.$[elt].$diagnoses.length !== 0){
					obj.$[elt].$diagnoses.forEach(function(diag){
						if (diag.severity === "error"){
							throw new Error(diag.severity + " in element: " + elt + " : " + diag.message);
						}else{
							tracer.trace(diag.severity + " in element: " + elt + " : " + diag.message);
						}
					});
				}
			});
			Object.keys(obj.$actions).forEach(function(elt){
				if (obj.$actions[elt].$diagnoses != null && obj.$actions[elt].$diagnoses.length !== 0){
					obj.$actions[elt].$diagnoses.forEach(function(diag){
						if (diag.severity === "error"){
							throw new Error(diag.severity + " in element: " + elt + " : " + diag.message);
						}else{
							tracer.trace(diag.severity + " in element: " + elt + " : " + diag.message);
						}
					});
				}
			});
	
		}
		
		
		
		function $details(_){

			if (params.$key === "")
				throw new Error("The '_key' parameter must not be undefined for 'READ' operation.");
			
			
			var instance = self.context.db.fetchInstance(_, self.context.entity, params.$key);
			
			if (instance != null){
				schema = self.context.getPrototypeResource(_, self.entityName + ".$details");
				//tracer.trace("Schema = "+JSON.stringify(schema,null,2));
				var serializedInstance = instance.serializeInstance(_);
				//tracer.trace("Instance = " +JSON.stringify(serializedInstance,null,2));

				response[self.entityName] = {};
				response[self.entityName]._key = instance.$key;
				for( var key in schema.$ ) {

					if (serializedInstance[key] != null){
						if(serializedInstance[key].length === 0){
							response[self.entityName][key] = "";
						}else{
							var formatted = format(_, key, schema.$[key], serializedInstance);
							if (formatted){
								if (key.indexOf('$') === 0)
									key = '_' + key.substring(1);
								response[self.entityName][key] = formatted;
							}
						}
					}
					else if(serializedInstance[key] === null){
						response[self.entityName][key] = {$: {"xsi:nil": "true"}};
					}
					// DO NOTHING for undefined
					
				}
			}else{
				response[self.entityName] = {$: {"xsi:nil": "true"}};
			}
			return response;
		}
		
		function $edit(_, isUpdate){
			
			
			
			function writeInstance(_, instance, parameters){
				
			
				function mustWrite(param, isUpdateReq){
					if (param == null){
						return false;
					}else if (param.$key && typeof param.$key === 'object'){
						return false;
					}else if (param.$key != null && !isUpdateReq){
						return true;
					}else if (isUpdateReq){
						return true;
					}else{
						return true;
					}
				}//End mustWrite
				
				function writeInstanceParam(_, paramName, param){
					
					function writeInstanceProperty(_, propertyName){
						if (param.$ && param.$["xsi:nil"] === "true"){
							instance[propertyName](_, null);
						}else{
							var converted = soapUtils.convertValue(schema.$[propertyName].$type, param);
							if (converted != null){
								if (converted !== "b64"){
									if (converted !== instance[propertyName](_)){
										//tracer.trace("Set instance property '" + propertyName + "' with value : '" + converted + "'");
										instance[propertyName](_, converted);
									}
								}else{
									//tracer.trace("Set store property: " + propertyName);
									setBinary(_, instance[propertyName](_), param);
								}
							}else{
								tracer.trace("## Ignore property: " + propertyName + " because type "+schema.$[propertyName].$type +" is not compatible");
							}
						}
					}//End writeInstanceProperty
					
					function writeInstanceRelation(_, relationName){
						
						
						function getInstance(_, subParams, entityType, isChild){
							tracer.trace(" - Sub param: "+entityType);
							var entity = self.context.model.getEntity(entityType);
							var subInst = self.context.db.fetchInstance(_, entity, subParams.$key);
							
							if (isChild){
								if (!subInst){
									var newChildParam = null;
									var factory = entity.factory;
									tracer.traceSubSection("Create Child Instance with $uuid :" +subParams.$key,"");
									subInst = factory.createInstance(_, null, self.context.db);
									if (subParams.$key != null && subParams.$key !== ""){
										subInst.$uuid = subParams.$key;
										subInst.$key = subParams.$key;
									}
									writeInstance(_, subInst, subParams).$key;

								}else{
									tracer.trace("Child ["+uuid+"] already exists.");
								}
							}else{
								if (!subInst)
									throw new Error("No '" + entityType + "' instance found with identifier '" + subParams.$key + "'");
							}
							return subInst;
						}// End getInstance
						
						
						function writeInstanceRelationReference(_){
							tracer.trace("$relation: Reference");
							
							if (param.$key){
								if (inst != null && isUpdate){
									// Save oldKey only for update
									var oldKey = inst.$key;
								}
								var relationInstance = instance._meta.$relations[relationName];
								// Get instance or create it if it's child and doesn't exists
								inst = getInstance(_, param, relationInstance.$type, relationInstance.isChild);
							}
	
							if (mustWrite(param, isUpdate)){
								if (param.$key){
									if(oldKey)
										tracer.trace("Old key: " +oldKey);
									// If it's a creation or if it's an update and keys are differents
									if (oldKey == null || param.$key !== oldKey){
										tracer.trace("  --> Add one " + relationName + ":\n" + param.$key);
										instance[relationName](_, inst);
									}else{
										tracer.trace("No change on " + relationName + ":\n" + inst.$key);
									}
								}else{
									if (inst){
										tracer.trace("  --> Delete relation " + relationName + ":\n" + inst.$key);
										instance[relationName](_, null);
									}
								}
							}else{
								tracer.trace("PROBLEM: Don't write");
							}
						}// End writeInstanceRelationReference
						
						function writeInstanceRelationCollection(_){
							
							function setRelation(_, relParam){
								// Get instance or create it if it's child and doesn't exists
								var subInst = getInstance(_, relParam, instType, inst._relMeta.isChild);
								tracer.trace("  --> Add " + instType +": " + subInst.$key + "\n");
								inst.set(_, subInst);
							}
							
							var instType = self.context.model.singularize(inst._relMeta.type);
												
							tracer.trace("$relation: Collection of type: "+instType);

							var colElements = [];
							// Multiple elements
							if (param[instType]){
								if (!param[instType].$key){
									for (var i in param[instType]){
										if (mustWrite(param[instType][i], isUpdate)){
											colElements.push(param[instType][i]);
										}
									}
								}
								// Only one element
								else{
									if (mustWrite(param[instType], isUpdate)){
										colElements.push(param[instType]);
									}
								}
							}
							for (var elt in colElements){
								setRelation(_, colElements[elt]);
							}
							
							// $deleteMissing decide if keep missing relations
							if (param.$deleteMissing === "true"){
								tracer.trace(" $deleteMissing = true");
								for (var rel in inst._data){
									var found = false;
									for (var elt in colElements){
										if (colElements[elt].$key === rel){
											found = true;
											break;
										}
									}
									if (!found){
										tracer.trace("  --> Delete relation " + relationName + ": " + rel);
										inst.deleteInstance(_,rel);
									}
								}
							}

						}// End writeInstanceRelationCollection

						// Retrieve current instance
						var inst = instance[relationName](_);
						// Process $relations references
						if (!inst || !inst._relMeta || !inst._relMeta.isPlural){
							writeInstanceRelationReference(_);
						}
						// Process $relations collections
						else{
							writeInstanceRelationCollection(_);
						}
					
					}//End writeInstanceRelation
					
					
					//----------------------------------------------------------
					if (mustWrite(param, isUpdate)){
						tracer.traceSubSection("Write instance parameter: "+paramName);//,"value: "+JSON.stringify(param,null,2));

						if (instance._meta.$properties[paramName]){
							writeInstanceProperty(_, paramName);
						}else if (instance._meta.$relations[paramName]){
							writeInstanceRelation(_, paramName);
						}
					}
				}//End writeInstanceParam


				tracer.traceSection("Write instance : "+instance.$uuid,"");


				for( var key in schema.$ ) {
					//var param = params[self.entityName][key];
					var param = parameters[key];
					writeInstanceParam(_, key, param, instance);
				}

				return instance;

			}//End writeInstance
				

			isUpdate = isUpdate != null ? isUpdate : false;
			var primaryInstance;
			if (isUpdate){
				primaryInstance = self.context.db.fetchInstance(_, self.context.entity, params[self.entityName].$key);
				if (!primaryInstance)
					throw new Error("No '" + self.entityName + "' instance found with identifier '" + params[self.entityName].$key + "'");
					
			}else{
				var factory = self.context.entity.factory;
				primaryInstance = factory.createInstance(_, null, self.context.db);
			}

			
			schema = self.context.getPrototypeResource(_, self.entityName + ".$edit");
			//tracer.trace("Schema = "+JSON.stringify(schema,null,2));
			

			primaryInstance = writeInstance(_, primaryInstance, params[self.entityName]);
			
			
			//tracer.traceSubSection("Save instance: " + primaryInstance.$uuid, JSON.stringify(primaryInstance.serializeInstance(_),null,2));
			var res = primaryInstance.save(_);
			//tracer.trace("Save Result: "+JSON.stringify(res,null,2));
			ckeckDiagnoses(res);

			response._key = primaryInstance.$key;

			return response;
		}
		
		
		
		
		
		function $delete(_){
			if (params.$key === "")
				throw new Error("The '_key' parameter must not be undefined for 'DELETE' operation.");
			
			
			var instance = self.context.db.fetchInstance(_, self.context.entity, params.$key);
			if (instance != null){
				// TODO: canDelete must be remove when cristi add it in deleteSelf function
				if (instance.canDelete(_)){
					var res = instance.deleteSelf(_);
					if (res){
						response.deleted = "true";
					}else{
						throw new Error(instance.deleteError);
					}
				}else{
					throw new Error(instance.deleteError);
				}
			}else{
				throw new Error("No " + self.entityName + " instance found with identifier '" + params.$key + "'");
			}
			return response;
		}
		
		function $query(_){

			var fetchParams = {};
			
			// count
			if (params.$count)
				fetchParams.count = parseInt(params.$count);
			
			// startIndex
			if (params.$startIndex)
				fetchParams.startIndex = parseInt(params.$startIndex);
			
			// sdataWhere
			if (params.$sdataWhere)
				fetchParams.sdataWhere = params.$sdataWhere;
			
			// orderBy
			if (params.$orderBy){
				fetchParams.orderBy = [];
				if (Array.isArray(params.$orderBy)){
					for (var elt in params.$orderBy){
						var paramOrderBy = {
								binding: params.$orderBy[elt].$binding,
								descending: params.$orderBy[elt].$descending === "true"
						};
						fetchParams.orderBy.push(paramOrderBy);
					}
				}else{
					var paramOrderBy = {
						binding: params.$orderBy.orderBy.$binding,
						descending: params.$orderBy.orderBy.$descending === "true"
					}
					fetchParams.orderBy.push(paramOrderBy);
				}
			}
			
			//tracer.trace("Fetch parameters: "+JSON.stringify(fetchParams,null,2));
			
			var instances = self.context.db.fetchInstances(_, self.context.entity, fetchParams);

			response._startIndex = params.$startIndex != null ? params.$startIndex : "1";
			response._itemsPerPage = fetchParams.count.toString();
			response._totalResults = self.context.db.count(_, self.context.entity, fetchParams).toString();
			
			schema = self.context.getPrototypeResource(_, self.entityName + ".$query");
			//tracer.trace("Schema="+JSON.stringify(schema,null,2));
			response[self.entityName + "List"] = {};
			response[self.entityName + "List"][self.entityName] = [];
			for (var i in instances){
				var instance = instances[i];
				var serializedInstance = instance.serializeInstance(_);
				//tracer.trace("Instance = \n" +JSON.stringify(serializedInstance,null,2));

				response[self.entityName + "List"][self.entityName][i] = {};
				
				response[self.entityName + "List"][self.entityName][i] = {};
				response[self.entityName + "List"][self.entityName][i]._key = instance.$key;
				for( var key in schema.$.$resources.$item.$ ) {
					if (instance[key]){
						var formatted = format(_, key, schema.$.$resources.$item.$[key], serializedInstance);
						if (formatted){
							if (key.indexOf('$') === 0)
								key = '_' + key.substring(1);
							response[self.entityName + "List"][self.entityName][i][key] = formatted;
						}
					}
				}

			}
			//response._totalResults = response[self.entityName + "List"][self.entityName].length.toString();
			return response;
		}
		
		
	 
		//tracer.traceSection("Execute REST Request for method : " + method , "Parameters=\n" + JSON.stringify(params,null,2));
		var self = this;
		var namespace = this.application + "." + this.contract + "." + this.dataset;
		var schema;
		
		var response = {
			$: {
				"xmlns": namespace
			}
		};

		switch(method){
			case ("read" + this.title):
				return $details(_);
			case ("list" + this.title):
				return $query(_);
			case ("create" + this.title):
				return $edit(_);
			case ("update" + this.title):
				return $edit(_, true);
			case ("delete" + this.title):
				return $delete(_);
		}

	}
});




exports.create = function(_, context){
	return new ormExecutor(context);
}


