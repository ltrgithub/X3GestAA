"use strict";

var helpers = require("syracuse-core/lib/helpers");
var util = require("util");
var fs = require('fs');
var jsxml = require('jsxml');
var ormExecutor = require('./ormExecutor');
var restExecutor = require('./restExecutor');
var soapTracer = require('../common/soapTracer');
var soapTimer = require('../common/soapTimer');
var date = require('syracuse-core/lib/types/date');
var time = require('syracuse-core/lib/types/time');
var datetime = require('syracuse-core/lib/types/datetime');
var config = require('syracuse-main/lib/nodeconfig').config;
var registry = require("syracuse-sdata/lib/sdataRegistry");
var Context = require("syracuse-sdata/lib/sdataContext").Context;
var dataModel = require("syracuse-orm/lib/dataModel");
var dataContext = require("syracuse-orm/lib/dataContext");

var tracer = soapTracer.create("request");
var timer = soapTimer.create("interceptor");

var Interceptor = helpers.defineClass(function(_, entityName, context) {
	
	
	this.context = context;

	function defineProtocol(proposed){
		if (proposed.toUpperCase() !== "REST" && proposed.toUpperCase() !== "ORM")
			throw new Error("Invalid protocol requested: Only 'REST' and 'ORM' are valid protocol.");
		return proposed.toUpperCase();
	}
	
	this.app = context.applicationName;
	
	// Force application for unit tests
	if (this.app === "qunit")
		this.app = "syracuse";
	
	if (this.app === "syracuse"){
		this.entityName = context.entity.name;
	}else if (this.app === "x3"){
		this.entityName = entityName;
	}else{
		throw context.badRequest("Application not valid");
	}
	
	// Define protocol
	var forced = context.request._request.headers["syra-protocol"];
	if (forced){
		this.protocol = defineProtocol(forced);
	}else if(config.soap && config.soap.promote){
		this.protocol = defineProtocol(config.soap.promote);
	}else{
		this.protocol = "ORM";
	}
	
//	// TODO: TEMP: FORCE X3 TO USE REST IMPLEMENTATION
//	if (this.app === "x3"){
//		this.protocol = "REST";
//	}
	
	// Define Executor
	if (this.protocol === "ORM"){
		this.executor = ormExecutor.create(_, this.entityName, context);
	}
	else if (this.protocol === "REST"){
		this.executor = restExecutor.create(_, this.entityName, context);
	}

	this.envelope = {
		"soap:Envelope": {

			$: {
				"xmlns:soap": "http://schemas.xmlsoap.org/soap/envelope/",
				"xmlns:xs": "http://www.w3.org/2001/XMLSchema",
				"xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance"
			},
			"soap:Body":{}
		}
	};
	
}, null, {
	run: function(_){

			var reqHeader = this.context.request.headers
			tracer.trace("Header : " + JSON.stringify(reqHeader,null,2));
			
			var soapAction = reqHeader.soapaction.replace(/\"/g,'');
			
			var reqBody = this.context.request.readAll(_);
			tracer.trace("Body : " + reqBody);


			return this.translateRequest(_, soapAction, jsxml.parse(reqBody));
				
	},
	translateRequest: function(_, soapAction, reqBody){
		tracer.traceSection("Translate SOAP Action : " + soapAction, JSON.stringify(reqBody,null,2));
		
		function format(element){
				var newElement = {};
				for( var key in element ) {
					var newKey;
					if (key.indexOf(nsEntity) === 0){
						newKey = key.substring(nsEntity.length);
					}else{
						newKey = key;
					}
					if (newKey.indexOf('_') === 0)
						newKey = '$' + newKey.substring(1);
					newElement[newKey] = Array.isArray(element[key]) || typeof element[key] === 'object' ? format(element[key]) : element[key];
				}
			return newElement;
		}

		var nsSoap;
		for( var key in reqBody ) {
			nsSoap = key.split(':')[0] + ':';
		}

		var soapHeader = reqBody[nsSoap + "Envelope"][nsSoap + "Header"];
		var soapBody = reqBody[nsSoap + "Envelope"][nsSoap + "Body"];
		
		var nsEntity = '';
		var opRequestName, opRequest;

		for( var key in soapBody ) {
			if (key.indexOf(soapAction + "Request") !== -1){
				if (key.indexOf(':') !== -1)
					nsEntity = key.split(':')[0] + ':';
				opRequestName = key;
				opRequest = soapBody[key];
			}
		}
		if (!opRequest)
			throw new Error("SOAP Request not found.");

		var methodName = opRequestName.substring(nsEntity.length,opRequestName.toLowerCase().indexOf(this.entityName.toLowerCase()) + this.entityName.length);

		if (opRequest.$)
			delete opRequest.$;
		
		var params = format(opRequest);
		
		var response = this.executor.execute(_, methodName, params);
		this.addSoapBodyResponse(methodName, response);
		
		return jsxml.stringify(this.envelope,{ indent: '\t' });

		
	},

	addSoapBodyResponse: function(method, response){
		this.envelope["soap:Envelope"]["soap:Body"][method + "Response"] = response;
	},
	addSoapBodyException: function(ex, code){
		this.envelope["soap:Envelope"]["soap:Body"]["soap:Fault"] = {
				faultcode : {
					$: {
						"xsi:type": "xsd:string"
					},
					$value: code
				},
				faultstring : {
					$: {
						"xsi:type": "xsd:string"
					},
					$value: ex.message
				},
				detail: {
					$: {
						"xsi:type": "xsd:string"
					},
					$value: util.inspect(ex.stack)
				}
				
		}
		
		return jsxml.stringify(this.envelope,{ indent: '\t' });
	}
});




exports.intercept = function(_, entityName, context){
	timer.start();
	var interceptor = new Interceptor(_, entityName, context);
	var soapResponse;
	try{
		console.log("PROTOCOL: " + interceptor.protocol);
		tracer.traceSection("PROTOCOL: " + interceptor.protocol);
		tracer.traceSection("Intercept SOAP Request for entity : " + entityName);
		soapResponse = interceptor.run(_);
	}catch(e){
		console.error(e.stack);
		soapResponse = interceptor.addSoapBodyException(e, "soap:Server");

	}finally{
		soapResponse = '<?xml version="1.0" encoding="utf-8"?>\n' + soapResponse;
		tracer.traceSection("Send SOAP Reply  : ", soapResponse);
		console.log("SOAP Call duration: "+ timer.calc()+" ms");
		return soapResponse
	}
}