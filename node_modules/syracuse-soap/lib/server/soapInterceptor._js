"use strict";

var helpers = require("syracuse-core/lib/helpers");
var util = require("util");
var fs = require('fs');
var jsxml = require('jsxml');
var ormExecutor = require('./ormExecutor');
var soapUtils = require('../common/soapUtils');
var soapTracer = require('../common/soapTracer');
var date = require('syracuse-core/lib/types/date');
var time = require('syracuse-core/lib/types/time');
var datetime = require('syracuse-core/lib/types/datetime');

var registry = require("syracuse-sdata/lib/sdataRegistry");
var Context = require("syracuse-sdata/lib/sdataContext").Context;
var dataModel = require("syracuse-orm/lib/dataModel");
var dataContext = require("syracuse-orm/lib/dataContext");

var tracer = soapTracer.create();

var Interceptor = helpers.defineClass(function(_, context) {
	this.context = context;
	this.application = this.context.application.name;
	this.contract = this.context.contract.name;
	this.dataset = this.context.dataset;
	this.entity = this.context.entity.name;
	this.title = this.entity.charAt(0).toUpperCase() + this.entity.slice(1);
	this.executor = ormExecutor.create(_, this.context);
	
	this.envelope = {
		"soap:Envelope": {

			$: {
				"xmlns:soap": "http://schemas.xmlsoap.org/soap/envelope/",
				"xmlns:xs": "http://www.w3.org/2001/XMLSchema",
				"xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance"
			},
			"soap:Body":{}
		}
	};
	
}, null, {
	run: function(_){

			var reqHeader = this.context.request.headers
			tracer.trace("Header : " + JSON.stringify(reqHeader,null,2));
			
			var soapAction = reqHeader.soapaction.replace(/\"/g,'');
			
			var reqBody = this.context.request.readAll(_);
			tracer.trace("Body : " + reqBody);


			return this.translateRequest(_, soapAction, jsxml.parse(reqBody));
				
	},
	translateRequest: function(_, soapAction, reqBody){
		tracer.traceSection("Translate SOAP Action : " + soapAction, JSON.stringify(reqBody,null,2));
		
		function format(element){
				var newElement = {};
				for( var key in element ) {
					var newKey;
					if (key.indexOf(nsEntity) === 0){
						newKey = key.substring(nsEntity.length);
					}else{
						newKey = key;
					}
					if (newKey.indexOf('_') === 0)
						newKey = '$' + newKey.substring(1);
					newElement[newKey] = Array.isArray(element[key]) || typeof element[key] === 'object' ? format(element[key]) : element[key];
				}
			return newElement;
		}

		var nsSoap;
		for( var key in reqBody ) {
			nsSoap = key.split(':')[0] + ':';
		}

		var soapHeader = reqBody[nsSoap + "Envelope"][nsSoap + "Header"];
		var soapBody = reqBody[nsSoap + "Envelope"][nsSoap + "Body"];
		
		var nsEntity = '';
		var opRequestName, opRequest;

		for( var key in soapBody ) {
			if (key.indexOf(soapAction + "Request") !== -1){
				if (key.indexOf(':') !== -1)
					nsEntity = key.split(':')[0] + ':';
				opRequestName = key;
				opRequest = soapBody[key];
			}
		}
		if (!opRequest)
			throw new Error("SOAP Request not found.");

		var methodName = opRequestName.substring(nsEntity.length,opRequestName.toLowerCase().indexOf(this.entity.toLowerCase()) + this.entity.length);

		if (opRequest.$)
			delete opRequest.$;
		
		var params = format(opRequest);
		
		var response = this.executor.execute(_, methodName, params);
		this.addSoapBodyResponse(methodName, response);
		
		return jsxml.stringify(this.envelope,{ indent: '\t' });

		
	},

	addSoapBodyResponse: function(method, response){
		this.envelope["soap:Envelope"]["soap:Body"][method + "Response"] = response;
	},
	addSoapBodyException: function(ex, code){
		this.envelope["soap:Envelope"]["soap:Body"]["soap:Fault"] = {
				faultcode : {
					$: {
						"xsi:type": "xsd:string"
					},
					$value: code
				},
				faultstring : {
					$: {
						"xsi:type": "xsd:string"
					},
					$value: ex.message
				}
//				,
//				detail: {
//					$: {
//						"xsi:type": "xsd:string"
//					},
//					$value: ex.stack
//				}
				
		}
		
		
		return jsxml.stringify(this.envelope,{ indent: '\t' });
	}
});




exports.intercept = function(_, context){
	var interceptor = new Interceptor(_, context);
	var soapResponse;
	try{

		
		tracer.traceSection("Intercept SOAP Request for entity : " + context.entity.name, "");
		soapResponse = interceptor.run(_);
	}catch(e){
		//tracer.trace(e.stack);
		soapResponse = interceptor.addSoapBodyException(e, "soap:Server");

	}finally{
		soapResponse = '<?xml version="1.0" encoding="utf-8"?>\n' + soapResponse;
		tracer.traceSection("Send SOAP Reply  : ", soapResponse);
		return soapResponse
	}
}