"use strict";

var helpers = require("syracuse-core/lib/helpers");
var util = require("util");
var jsxml = require('jsxml');
var locale = require("syracuse-core/lib/locale");
var ormExecutor = require('./ormExecutor');
var restExecutor = require('./restExecutor');
var soapTracer = require('../common/soapTracer');
var soapTimer = require('../common/soapTimer');
var soapUtils = require('./soapUtils');

var tracer = soapTracer.create("request");
var timer = soapTimer.create("interceptor");

var Interceptor = helpers.defineClass(function(_, serviceName, context) {

	this.context = context;
	this.serviceName = serviceName;
	this.app = context.applicationName;

	// Force application for unit tests
	if (this.app === "qunit") this.app = "syracuse";
	if (this.app === "syracuse") {
		this.protocol = "ORM";

	} else if (this.app === "x3") {
		this.protocol = "REST";
	} else {
		throw context.badRequest(locale.format(module, "appNotValid"));
	}

	this.envelope = {
		"soap:Envelope": {

			$: {
				"xmlns:soap": "http://schemas.xmlsoap.org/soap/envelope/",
				"xmlns:xs": "http://www.w3.org/2001/XMLSchema",
				"xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance"
			},
			"soap:Body": {}
		}
	};

}, null, {
	run: function(_) {

		if (this.app === "syracuse") {
			var ws = soapUtils.getSoapWebService(_, this.serviceName, this.context);
			if (!ws) throw new Error(locale.format(module, "wsNotFound", this.serviceName));
		}
		var reqHeader = this.context.request.headers;
		tracer.trace("Header : " + JSON.stringify(reqHeader, null, 2));

		if (!reqHeader.soapaction) throw new Error(locale.format(module, "soapActMissing"));
		var soapAction = reqHeader.soapaction.replace(/\"/g, '');

		var reqBody = this.context.request.readAll(_);
		tracer.trace("Body : " + reqBody);

		return this.translateRequest(_, soapAction, jsxml.parse(reqBody));

	},
	translateRequest: function(_, soapAction, reqBody) {
		tracer.traceSection("Translate SOAP Action : " + soapAction, JSON.stringify(reqBody, null, 2));

		function format(element) {
			var newElement = {};
			for (var key in element) {
				var newKey;
				if (key.indexOf(nsEntity) === 0) {
					newKey = key.substring(nsEntity.length);
				} else {
					newKey = key;
				}
				if (newKey.indexOf('_') === 0) newKey = '$' + newKey.substring(1);
				newElement[newKey] = Array.isArray(element[key]) || typeof element[key] === 'object' ? format(element[key]) : element[key];
			}
			return newElement;
		}

		var nsSoap, key;
		for (key in reqBody) {
			nsSoap = key.split(':')[0] + ':';
		}

		// maybe header will be useful
		var soapHeader = reqBody[nsSoap + "Envelope"][nsSoap + "Header"];
		var soapBody = reqBody[nsSoap + "Envelope"][nsSoap + "Body"];

		var nsEntity = '';
		var opRequestName, opRequest;

		for (key in soapBody) {
			if (key.indexOf(soapAction + "Request") !== -1) {
				if (key.indexOf(':') !== -1) nsEntity = key.split(':')[0] + ':';
				opRequestName = key;
				opRequest = soapBody[key];
			}
		}
		if (!opRequest) throw new Error(locale.format(module, "requestNotFound"));

		var namespace, namespaceDeclaration = "xmlns:" + nsEntity.slice(0, nsEntity.length - 1);
		var representation;
		if (reqBody[nsSoap + "Envelope"].$[namespaceDeclaration]) {
			namespace = reqBody[nsSoap + "Envelope"].$[namespaceDeclaration];
			representation = namespace.split(".")[0];
		} else if (opRequest.$ && opRequest.$[namespaceDeclaration]) {
			namespace = opRequest.$[namespaceDeclaration];
			representation = namespace.split(".")[0];
		} else {
			if (opRequest.$ && opRequest.$.xmlns) {
				namespace = opRequest.$.xmlns;
				representation = namespace.split(".")[0];
			} else {
				throw new Error(locale.format(module, "nsNotFound", namespaceDeclaration));
			}
		}

		var entityName;
		var executor;
		if (this.app === "syracuse") {

			//
			//			if (this.context.contract && this.context.contract.representations && !this.context.contract.representations[representation])
			//				throw new Error("Representation not found: "+ representation);
			//			
			if (this.context.contract.representations && this.context.contract.representations[representation]) {
				entityName = this.context.contract.representations[representation].$entityName;
			} else {
				entityName = representation;
			}
			executor = ormExecutor.create(_, entityName, representation, this.context);
		} else if (this.app === "x3") {
			// Temp: while it's not possible to retrieve representations list for X3
			entityName = representation;
			executor = restExecutor.create(_, entityName, representation, this.context);
		}

		var opRequestMethod;
		if (opRequestName.indexOf(":") !== -1) {
			opRequestMethod = opRequestName.split(":")[1];
		} else {
			opRequestMethod = opRequestName;
		}
		var methodName = opRequestMethod.substring(0, opRequestMethod.toLowerCase().indexOf(representation.toLowerCase()) + representation.length);

		if (opRequest.$) delete opRequest.$;

		var params = format(opRequest);

		var response = executor.execute(_, methodName, params);
		this.addSoapBodyResponse(methodName, response);

		return jsxml.stringify(this.envelope, {
			indent: '\t'
		});

	},

	addSoapBodyResponse: function(method, response) {
		this.envelope["soap:Envelope"]["soap:Body"][method + "Response"] = response;
	},
	addSoapBodyException: function(ex, code) {
		// Special error
		if (ex.message && ex.message.indexOf("\n"))
			ex.message = ex.message.split("\n")[0];
		this.envelope["soap:Envelope"]["soap:Body"]["soap:Fault"] = {
			faultcode: {
				$: {
					"xsi:type": "xsd:string"
				},
				$value: code
			},
			faultstring: {
				$: {
					"xsi:type": "xsd:string"
				},
				$value: ex.message
			},
			detail: {
				$: {
					"xsi:type": "xsd:string"
				},
				$value: ex.safeStack,
			}

		};
		return jsxml.stringify(this.envelope, {
			indent: '\t'
		});
	}
});

exports.intercept = function(_, serviceName, context) {
	timer.start();
	var soapResponse;
	var interceptor = new Interceptor(_, serviceName, context);
	try {
		tracer.traceSection("PROTOCOL: " + interceptor.protocol);
		tracer.traceSection("Intercept SOAP Request for service : " + serviceName);
		soapResponse = interceptor.run(_);
	} catch (e) {
		console.error("Error: " + e.stack);
		soapResponse = interceptor.addSoapBodyException(e, "soap:Server");
	} finally {
		soapResponse = '<?xml version="1.0" encoding="utf-8"?>\n' + soapResponse;
		tracer.traceSection("Send SOAP Reply  : ", soapResponse);
		//console.log("SOAP Call duration: "+ timer.calc()+" ms");
		return soapResponse;
	}
};