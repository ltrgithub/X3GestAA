"use strict";

var helpers = require("syracuse-core/lib/helpers");
var locale = require("syracuse-core/lib/locale");
var soapTracer = require('../common/soapTracer');
var types = require('syracuse-core/lib/types/allTypes');
var Template = require('syracuse-core/lib/resource/resourceProxy').Template;
var Parser = require('syracuse-sdata/lib/parser/parser.js').Parser;
var util = require("util");

var tracer = soapTracer.create("request");

var SoapHelper = helpers.defineClass(function(app, schema) {
	this.app = app;
	this.schema = schema;
}, null, {
	convertType: function(type) {
		switch (type) {
			case "application/x-uuid":
			case "application/x-password":
			case "application/x-string":
				return "xs:string";
			case "application/x-integer":
				return "xs:integer";
			case "application/x-real":
				return "xs:float";
			case "application/x-decimal":
				return "xs:decimal";
			case "application/x-boolean":
				return "xs:boolean";
			case "application/x-date":
				return "xs:date";
			case "application/x-time":
				return "xs:time";
			case "application/x-datetime":
				return "xs:dateTime";
			default:
				if (isRichMediaContent(type)) {
					return "b64";
				} else {
					return;
				}
		}
	},

	convertValue: function(type, value) {

		try {
			if (value == null) return "";
			switch (type) {
				case "application/x-date":
					return types.date.parse(value);
				case "application/x-time":
					return types.time.parse(value);
				case "application/x-datetime":
					return types.datetime.parse(value);
				case "application/x-uuid":
				case "application/x-password":
				case "application/x-choice":
				case "application/x-string":
					return value;
				case "application/x-integer":
					return parseInt(value, 10);
				case "application/x-real":
				case "application/x-decimal":
					return parseFloat(value);
				case "application/x-boolean":
					return value === "true";
				case "application/x-json":
					return JSON.stringify(value);
				default:
					if (isRichMediaContent(type)) {
						return "b64";
					} else {
						return;
					}
			}
		} catch (e) {
			console.error(locale.format(module, "convertValueErr", util.inspect(value), type, e.safeStack));
			return;
		}
	},

	isParent: function(title, elt, aType) {

		if (elt.$item) {
			//console.log(title + " is parent of "+aType + " ? "+(this.getEntityType(title, elt.$item) === aType));
			if (this.getEntityType(title, elt.$item) === aType) {
				return true;
			}
			return false;
		} else {
			//console.log(title + " is parent of "+aType + " ? "+(this.getEntityType(title, elt) === aType));
			if (elt && this.getEntityType(title, elt) === aType) {
				return true;
			}
			return false;
		}

	},

	getEntityType: function(title, elt) {

		if (this.app === "x3") {
			// TODO: must use $prototype
			//console.log("SEARCH ENTITY TYPE: "+title+" IN ELEMENT: "+JSON.stringify(elt,null,2));
			if (title !== "orderBy") return title;
			return;
		}
		// else Syracuse App
		else {

			var resource = {
				$baseUrl: this.schema.$baseUrl,
				$representation: elt.$item ? elt.$item.$representation : elt.$representation
			};
			var proto = elt.$item ? elt.$item.$prototype : elt.$prototype;
			var temp = (new Template(proto)).resolve(resource);

			return temp ? temp.split("$prototypes('")[1].split(".")[0] : null;

		}

	},

	formatValueForXml: function(_, title, element, instance, getBinaryFunc) {

		function returnValue(_) {
			if (val != null) {
				if (typeof(val) !== 'string') {
					var type = self.convertType(element.$type);
					// $ properties are not the same as other instance properties
					if (title.indexOf("$") === 0) {
						if (type === "xs:date") {
							return types.date.fromJsDate(new Date(val), true).toString();
						} else if (type === "xs:time") {
							return types.time.parse(val).toString();
						} else if (type === "xs:dateTime") {
							return types.datetime.fromJsDate(val).toString();
						}
					}
					if (type === "b64") {
						return getBinaryFunc(_, title, instance);
					} else {
						try {
							var json = JSON.parse(val);
							if (typeof json === 'object') {
								return JSON.stringify(json, null, 0);
							} else {
								return val.toString();
							}
						} catch (e) {
							return JSON.stringify(val);
							//return val.toString();
						}
					}
				} else {
					return val;
				}
			} else {
				return;
			}

		}

		function formatReference(_) {
			tracer.trace("formatReference");
			var ref = {};
			if (val != null && val.$uuid) {
				ref._key = val.$uuid;
			}

			var elt = element.$item || element;
			for (var key in elt.$properties) {
				if (val != null) {
					var formatted = self.formatValueForXml(_, key, elt.$properties[key], val, getBinaryFunc);
					if (formatted) ref[key] = formatted;
				}
			}
			return ref;
		}

		function formatCollection(_) {

			var relationType = self.getEntityType(title, element.$item);
			tracer.trace("format Collection of type: " + relationType);
			var col = {};
			col[relationType] = [];
			for (var i in val) {
				var item = {};
				col[relationType][i] = item;
				if (val[i] != null && val[i].$uuid) {
					col[relationType][i]._key = val[i].$uuid;
				}
				var elt = element.$item.$item || element.$item;
				for (var key in elt.$properties) {
					var formatted = self.formatValueForXml(_, key, elt.$properties[key], val[i], getBinaryFunc);
					if (formatted) item[key] = formatted;
				}
			}
			return col[relationType].length !== 0 ? col : null;
		}

		function formatJson(_) {
			tracer.trace("formatJson");
			var ref = {};
			if (val != null && val.$uuid) {
				ref._key = val.$uuid;
			}

			for (var key in element.$item.$properties) {
				if (val != null) {
					var formatted = self.formatValueForXml(_, key, element.$item.$properties[key], val, getBinaryFunc);
					if (formatted) ref[key] = formatted;
				}
			}
			return ref;
		}

		var self = this;
		var val = instance[title];

		if (val === null) return;

		tracer.traceSection("Resolve: " + title, "type: " + element.$type + "\nValue: " + JSON.stringify(val, null, 2));

		switch (element.$type) {
			case "application/x-array":
				return formatCollection(_);
			case "application/x-choice":
				return returnValue(_);
			case "application/x-object":
				return formatJson(_);
			case "application/x-reference":
				return formatReference(_);
			case "application/x-range":
				tracer.trace("Ignore type: '" + element.$type + "' for element: '" + title + "'");
				return;
			case "application/x-graph":
				tracer.trace("Ignore type: '" + element.$type + "' for element: '" + title + "'");
				return;

			default:
				var type = element.$type;
				if (type != null) {
					return returnValue(_);
				} else {
					// if $type absent type is considered to application/x-object
					if (element.$item != null) {
						return formatJson(_);
					} else {
						tracer.trace("**Ignore type: '" + element.$type + "' for element: '" + title + "'");
						return;
					}
				}
		}

	},

	formatJsonForJsxml: function(key, obj) {
		var formatted;
		if (obj === null) {
			formatted = {
				$: {
					"xsi:nil": "true"
				}
			};
		} else if (typeof obj === 'object') {
			if (Array.isArray(obj)) {
				formatted = [];
				for (var i in obj) {
					formatted.push(this.formatJsonForJsxml(subkey, obj[i]));
				}
			} else {
				formatted = {};
				for (var subkey in obj) {
					formatted[subkey] = this.formatJsonForJsxml(subkey, obj[subkey]);
				}
			}
		} else {
			if (obj != null) {
				formatted = {
					$value: obj.toString()
				};
			}
		}
		return formatted;
	},

	checkWhere: function(where) {
		function parseChildren(exp) {
			if (exp.children.length !== 0) {
				for (var i in exp.children) {
					var child = exp.children[i];
					if (child.type === "identifier" && child.value === "$key") {
						throw new Error(locale.format(module, "keyForbidden"));
					}
					if (child.children) parseChildren(child);
				}
			}
		}
		if (this.app === "x3") {
			var exp = Parser.parse(where);
			parseChildren(exp);
		}
	}

});

function isRichMediaContent(type) {
	var richMediaContentTypes = [
		"text/plain",
		"text/html",
		"text/xml",
		"image",
		"sound",
		"video",
		"application/octet-stream",
		"application/x-binary"
	];
	return richMediaContentTypes.indexOf(type) !== -1;
}

exports.create = function(app, schema) {
	return new SoapHelper(app, schema);
};

exports.ckeckDiagnoses = function(obj) {
	tracer.trace(JSON.stringify(obj, null, 2));

	if (obj && obj.$diagnoses) {
		for (var i in obj.$diagnoses) {
			if (obj.$diagnoses[i] != null) {
				var severity = obj.$diagnoses[i].$severity || obj.$diagnoses[i].severity;
				var message = obj.$diagnoses[i].$message || obj.$diagnoses[i].message;
				if (severity === "error") {
					throw new Error(severity + ": " + util.inspect(message));
				} else {
					tracer.trace("Objects diagnoses: " + severity + ": " + util.inspect(message));
				}
			}
		}
	}
	if (obj && obj.$properties) {
		Object.keys(obj.$properties).forEach(function(elt) {
			if (obj.$properties[elt] && obj.$properties[elt].$diagnoses != null && obj.$properties[elt].$diagnoses.length !== 0) {
				obj.$properties[elt].$diagnoses.forEach(function(diag) {
					var severity = diag.$severity || diag.severity;
					var message = diag.$message || diag.message;
					if (severity === "error") {
						throw new Error(severity + " in element: " + elt + " : " + message);
					} else {
						tracer.trace("Properties diagnoses: " + severity + " in element: " + elt + " : " + message);
					}
				});
			}
		});
	}
	if (obj && obj.$actions) {
		Object.keys(obj.$actions).forEach(function(elt) {
			if (obj.$actions[elt] && obj.$actions[elt].$diagnoses != null && obj.$actions[elt].$diagnoses.length !== 0) {
				obj.$actions[elt].$diagnoses.forEach(function(diag) {
					var severity = diag.$severity || diag.severity;
					var message = diag.$message || diag.message;
					if (severity === "error") {
						throw new Error(severity + " in element: " + elt + " : " + message);
					} else {
						tracer.trace("Actions diagnoses: " + severity + " in element: " + elt + " : " + message);
					}
				});
			}
		});
	}

};