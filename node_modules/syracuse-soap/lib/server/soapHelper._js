"use strict";

var helpers = require("syracuse-core/lib/helpers");
var soapTracer = require('../common/soapTracer');
var types = require('syracuse-core/lib/types/allTypes');
var Template = require('syracuse-core/lib/resource/resourceProxy').Template;
var util = require("util");

var tracer = soapTracer.create("request");


var SoapHelper = helpers.defineClass(function(app, schema) {
	this.app = app;
	this.schema = schema;
}, null, {
	convertType: function(type){
		switch (type) {
			case "application/x-uuid":
			case "application/x-password":
			case "application/x-string":
				return "xs:string";
			case "application/x-integer":
				return "xs:integer";
			case "application/x-real":
				return "xs:float";
			case "application/x-decimal":
				return "xs:decimal";
			case "application/x-boolean":
				return "xs:boolean";
			case "application/x-date":
				return "xs:date";
			case "application/x-time":
				return "xs:time";
			case "application/x-datetime":
				return "xs:dateTime";
			default:
				if (isRichMediaContent(type)){
					return "b64";
				}else{
					return;
				}
		}
	},

	convertValue: function(type, value){

		try{
			if (value == null)
				return "";
			switch (type) {
				case "application/x-date":
						return types.date.parse(value);
				case "application/x-time":
						return types.time.parse(value);
				case "application/x-datetime":
						return types.datetime.parse(value);
				case "application/x-uuid":
				case "application/x-password":
				case "application/x-choice":
				case "application/x-string":
					return value;
				case "application/x-integer":
					return parseInt(value);
				case "application/x-real":
				case "application/x-decimal":
					return parseFloat(value);
				case "application/x-boolean":
					return value == "true";
				case "application/x-json":
					return JSON.stringify(value);
				default:
					if (isRichMediaContent(type)){
						return "b64";
					}else{
						return;
					}
			}
		}catch(e){
			console.error("error in convertValue: '"+util.inspect(value)+"' of type: '"+type+"'"+e.stack);
			return;
		}
	},

	isParent: function(title, elt, aType){
		
		
		if (elt.$item){
			//console.log(title + " is parent of "+aType + " ? "+(this.getEntityType(title, elt.$item) === aType));
			if (this.getEntityType(title, elt.$item) === aType){
				return true;
			}
			return false;
		}else{
			//console.log(title + " is parent of "+aType + " ? "+(this.getEntityType(title, elt) === aType));
			if (elt && this.getEntityType(title, elt) === aType){
				return true;
			}
			return false;
		}

	},
	
	getEntityType: function(title, elt){
		
		if (this.app === "x3"){
			// TODO: must use $prototype
			//console.log("SEARCH ENTITY TYPE: "+title+" IN ELEMENT: "+JSON.stringify(elt,null,2));
			if (title !== "orderBy")
				return title;
			return;
		}
		// else Syracuse App
		else{

			var resource = {$baseUrl: this.schema.$baseUrl, $representation: elt.$representation};
			var temp = (new Template(elt.$prototype)).resolve(resource);

			return temp ? temp.split("$prototypes('")[1].split(".")[0] : null;

		}
		
	},


	formatValueForXml: function(_, title, element, instance, getBinaryFunc){
		
		function returnValue(_){
			var result;
			if (val != null){
				if (typeof(val) !== 'string'){
					var type = self.convertType(element.$type);
					// $ properties are not the same as other instance properties
					if (title.indexOf("$") === 0){
						if (type === "xs:date"){
								return types.date.fromJsDate(new Date(val), true).toString();
						}else if (type === "xs:time"){
							return types.time.parse(val).toString();
						}else if (type === "xs:dateTime"){
								return types.datetime.fromJsDate(val).toString();
						}
					}
					if (type === "b64"){
						return getBinaryFunc(_, title, instance);
					}else{
						try{
							var json = JSON.parse(val);
							if (typeof json === 'object'){
								return JSON.stringify(json,null,0);
							}else{
								return val.toString();
							}
						}catch(e){
							return JSON.stringify(val);
							//return val.toString();
						}
					}
				}else{
					return val;
				}
			}else{
				return;
			}

		}
		
		function formatReference(_){
			tracer.trace("formatReference");
			var ref = {};
			if (val != null && val.$uuid){
				ref._key = val.$uuid
			}
				
			for( var key in element.$properties ) {
				if (val != null){
					var formatted = self.formatValueForXml(_, key, element.$properties[key], val, getBinaryFunc);
					if (formatted)
						ref[key] = formatted;
				}
			}
			return ref;
		}
		
		function formatCollection(_){
			

			
			var relationType = self.getEntityType(title, element.$item);
			tracer.trace("format Collection of type: "+relationType);
			var col = {};
			col[relationType] = [];
			for (var i in val){
				var item = {};
				col[relationType][i] = item;
				if (val[i] != null && val[i].$uuid){
					col[relationType][i]._key = val[i].$uuid
				}
				for( var key in element.$item.$properties ) {
					var formatted = self.formatValueForXml(_, key, element.$item.$properties[key], val[i], getBinaryFunc);
					if (formatted)
						item[key] = formatted;
				}
			}					
			return col[relationType].length !== 0 ? col : null;
		}
		
		function formatJson(_){
			tracer.trace("formatJson");
			var ref = {};
			if (val != null && val.$uuid){
				ref._key = val.$uuid
			}
				
			for( var key in element.$item.$properties ) {
				if (val != null){
					var formatted = self.formatValueForXml(_, key, element.$item.$properties[key], val, getBinaryFunc);
					if (formatted)
						ref[key] = formatted;
				}
			}
			return ref;
		}
		
		var self = this;
		var val = instance[title];
		
		if (val === null)
			return;
		
		tracer.traceSection("Resolve: "+title , "type: "+element.$type+"\nValue: "+ JSON.stringify(val,null,2));
		
		switch(element.$type){
		case "application/x-array":
			return formatCollection(_);
		case "application/x-choice":
			return returnValue(_);
		case "application/x-object":
			return formatJson(_);
		case "application/x-reference":
			return formatReference(_);
		case "application/x-range":
			tracer.trace("Ignore type: '" + element.$type + "' for element: '" + title + "'");
			return;
		case "application/x-graph":
			tracer.trace("Ignore type: '" + element.$type + "' for element: '" + title + "'");
			return;

		default:
			var type = element.$type;
			if (type != null){
				return returnValue(_);
			}else{
				// if $type absent type is considered to application/x-object
				if (element.$item != null){
					return formatJson(_);
				}else{
					tracer.trace("**Ignore type: '" + element.$type + "' for element: '" + title + "'");
					return;
				}
			}
		}

	},

	formatJsonForJsxml: function(key, obj){
		var formatted;
		if (obj === null){
			formatted = {$: {"xsi:nil": "true"}};
		}else if (typeof obj === 'object'){
			if (Array.isArray(obj)){
				formatted = [];
				for (var i in obj){
					formatted.push(this.formatJsonForJsxml(subkey, obj[i]));
				}
			}else{
				formatted = {};
				for (var subkey in obj){
					formatted[subkey] = this.formatJsonForJsxml(subkey, obj[subkey]);
				}
			}
		}else{
			if (obj != null){
				formatted = {$value: obj.toString()};
			}
		}
		return formatted;
	}


	
});




function isRichMediaContent(type){
	var richMediaContentTypes = [
        "text/plain",
        "text/html",
        "text/xml",
        "image",
        "sound",
        "video",
        "application/octet-stream",
        "application/x-binary"
        ];
	return richMediaContentTypes.indexOf(type) !== -1;
}



exports.create = function(app, schema){
	return new SoapHelper(app, schema);
}

exports.ckeckDiagnoses = function(obj){
	//tracer.trace(util.inspect(obj));

	if (obj && obj.$diagnoses){
		for (var i in obj.$diagnoses){
			if (obj.$diagnoses[i] != null){
				if (obj.$diagnoses[i].severity === "error"){
					throw new Error(obj.$diagnoses[i].severity + ": " + util.inspect(obj.$diagnoses[i].message));
				}else{
					tracer.trace(obj.$diagnoses[i].severity + ": " + util.inspect(obj.$diagnoses[i].message));
				}
			}
		}
	}
	if (obj && obj.$properties){
		Object.keys(obj.$properties).forEach(function(elt){
			if (obj.$properties[elt] && obj.$properties[elt].$diagnoses != null && obj.$properties[elt].$diagnoses.length !== 0){
				obj.$properties[elt].$diagnoses.forEach(function(diag){
					if (diag.severity === "error"){
						throw new Error(diag.severity + " in element: " + elt + " : " + diag.message);
					}else{
						tracer.trace(diag.severity + " in element: " + elt + " : " + diag.message);
					}
				});
			}
		});
	}
	if (obj && obj.$actions){
		Object.keys(obj.$actions).forEach(function(elt){
			if (obj.$actions[elt] && obj.$actions[elt].$diagnoses != null && obj.$actions[elt].$diagnoses.length !== 0){
				obj.$actions[elt].$diagnoses.forEach(function(diag){
					if (diag.severity === "error"){
						throw new Error(diag.severity + " in element: " + elt + " : " + diag.message);
					}else{
						tracer.trace(diag.severity + " in element: " + elt + " : " + diag.message);
					}
				});
			}
		});
	}

}



