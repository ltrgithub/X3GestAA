"use strict";

var helpers = require("syracuse-core/lib/helpers");
var util = require("util");
var fs = require('fs');
var jsxml = require('jsxml');
var soapHelper = require('./soapHelper');
var restUtils = require('./restUtils');
var soapTracer = require('../common/soapTracer');

var Template = require('syracuse-core/lib/resource/resourceProxy').Template;

var registry = require("syracuse-sdata/lib/sdataRegistry");
var Context = require("syracuse-sdata/lib/sdataContext").Context;
var dataModel = require("syracuse-orm/lib/dataModel");
var dataContext = require("syracuse-orm/lib/dataContext");


var tracer = soapTracer.create("request");



var restExecutor = helpers.defineClass(function(entityName, context) {
	this.context = context;

	this.app = context.applicationName;
	if (this.app === "qunit")
		this.app = "syracuse";
	
	if (this.app === "syracuse"){
		this.application = context.application.name;
		this.contract = context.contract.name;
		this.dataset = context.dataset;
		
	}else if (this.app === "x3"){
		this.application = context.endpoint._data.application; 
		this.contract = context.endpoint._data.contract;
		this.dataset = context.endpoint._data.dataset;

	}else{
		throw context.badRequest("Application not valid");
	}
	
	this.url = context.url.replace("/soap/", "/sdata/");
	this.entityName = entityName;
	this.title = this.entityName.charAt(0).toUpperCase() + this.entityName.slice(1);

	
}, null, {
	execute: function(_, method, params){

		function getBinary(_, title){
			if (params.$binary === "true"){
//				var store = instance[title](_);
//				// read the binary content
//				if (!store.fileExists(_)) throw new Error("File doesn't exist");
//				
//				var buf = store.createReadableStream(_).readAll(_);
//				var props = store.getProperties(_);

				return {
//					content: buf.toString('base64'),
//					length: props.length.toString(),
//					contentType: props.contentType,
//					fileName: props.fileName,
//					uploadDate : datetime.fromJsDate(props.uploadDate).toString()
				}
			}else{
				return;
			}
		}
		
		function setBinary(_, binaryInstance, param){

//			
//			var buf = new Buffer(param.content, 'base64').toString('binary');
//
//			if (buf != null && buf.length !== 0){
//				
//				var props = {
//						length: buf.length,
//						contentType: param.contentType,
//						fileName: param.fileName
//				}
//			
//				var store = binaryInstance;
//
//				var stream = store.createWritableStream(_, props);
//				stream.write(_, buf, "binary");
//				stream.end(null, "", _);
//			}

		}
		


		
		
		function computeKey(obj, item){
			if (self.app === "x3"){
				var computed = (new Template(item.$key)).resolve(obj);
				return computed;
			}else{
				return obj.$uuid
			}
		}
		
		
		function $details(_){

			if (params.$key === "")
				throw new Error("The '_key' parameter must not be undefined for 'READ' operation.");
			
			
			
			schema = restUtils.getPrototype(_, self.context, self.entityName, "$details");

			//tracer.trace("Schema="+JSON.stringify(schema,null,2));
			var sHelper = soapHelper.create(self.application, schema);
			var resource = {
				$baseUrl: schema.$baseUrl,
				$pluralType: schema.$pluralType,
				$key: params.$key
			};
			var httpResp = restUtils.getRepresentation(_, self.context, schema.$url, resource);

			var instance = httpResp.body;
			soapHelper.ckeckDiagnoses(instance);
			//tracer.trace("Instance = " +JSON.stringify(instance,null,2));
			
			if (instance != null){

				response[self.entityName] = {};
				response[self.entityName]._key = computeKey(instance, schema);
				for( var key in schema.$ ) {

					if (instance[key] != null){
						if(instance[key].length === 0){
							response[self.entityName][key] = "";
						}else{
							var formatted = sHelper.formatValueForXml(_, key, schema.$[key], instance, getBinary, self.app);
							if (formatted){
								if (key.indexOf('$') === 0)
									key = '_' + key.substring(1);
								response[self.entityName][key] = formatted;
							}
						}
					}
					else if(instance[key] === null){
						response[self.entityName][key] = {$: {"xsi:nil": "true"}};
					}
					// DO NOTHING for undefined
					
				}
			}else{
				response[self.entityName] = {$: {"xsi:nil": "true"}};
			}
			return response;
		}
		
		function $edit(_, isUpdate){
			
			
			
			function prepareData(data, parameters){
				
			
				function mustWrite(param, isUpdateReq){
					if (param == null){
						return false;
					}else if (typeof param === 'object' && Object.keys(param).length === 0){
						return false;
					}else if (param.$key != null && (typeof param.$key === 'object' || param.$key.length === 0)){
						return false;
					}else if (param.$key != null && !isUpdateReq){
						return true;
					}else if (isUpdateReq){
						return true;
					}else{
						return true;
					}
				}//End mustWrite
				
				function prepareDataParam(paramName, param){
					
					function addProperty(element, name, value){
						if (!props)
							props = {};
						if (!props[element])
							props[element] = {};
						props[element][name] = value;
					}
					
					function prepareDataProperty(propertyName){
						if (param.$ && param.$["xsi:nil"] === "true"){
							data[propertyName] = null;
						}else{
							
							var converted = sHelper.convertValue(schema.$[propertyName].$type, param);
							if (converted != null){
								if (converted !== "b64"){
									tracer.trace("Set data property '" + propertyName + "' with value : '" + converted.toString() + "'");
									data[propertyName] = converted.toString();

								}else{
									//tracer.trace("Set store property: " + propertyName);
									//setBinary(_, instance[propertyName](_), param);
								}
							}else{
								tracer.trace("## Ignore property: " + propertyName + " because type "+schema.$[propertyName].$type +" is not compatible");
							}
						}
					}//End prepareDataProperty
					
					function prepareDataRelation(relationName){
						

						function prepareDataRelationReference(){
							if (mustWrite(param, isUpdate)){
								tracer.trace("$relation: Reference");
								tracer.trace("Ref: "+JSON.stringify(param,null,2));
								

								
								
								data[relationName] = {};
								
								if (param.$ && param.$["xsi:nil"] === "true"){
									data[relationName] = null;
								}else{
									var node = schema.$[relationName];
									if (sHelper.isChild(relationName, schema.$[relationName], self.entityName)){
										node = schema.$[relationName].$item;
									}
									for (var key in param){
										if (key !== "$key"){
											

											var converted = sHelper.convertValue(node.$[key].$type, param[key]);
											if (converted != null){
												if (converted !== "b64"){
													tracer.trace("Set data relation reference '" + relationName + "' with value : '" + converted + "'");
													data[relationName][key] = converted;
												}else{
													//tracer.trace("Set store property: " + propertyName);
													//setBinary(_, instance[propertyName](_), param);
												}
											}else{
												tracer.trace("## Ignore property: " + relationName + " because type "+node.$[key].$type +" is not compatible");
											}

										}else{
											data[relationName].$uuid = param[key];
										}
									}
								}

								return data[relationName];
							}else{
								return;
							}


						}// End prepareDataRelationReference
						
						function prepareDataRelationCollection(){
							
							function setRelation(relation){
								var rel = {}
								for (var key in relation){
									
									if (key !== "$key"){
										var converted = sHelper.convertValue(schema.$[relationName].$item.$[key].$type, relation[key]);
										if (converted != null){
											if (converted !== "b64"){
												tracer.trace("Set data relation collection '" + relationName + "' with value : '" + converted + "'");
												rel[key] = converted;
											}else{
												//tracer.trace("Set store property: " + propertyName);
												//setBinary(_, instance[propertyName](_), param);
											}
										}else{
											tracer.trace("## Ignore property: " + relationName + " because type "+schema.$[relationName].$[key].$type +" is not compatible");
										}
										 
									}else{
										rel.$uuid = relation[key];
									}
								}
								return rel;
							}// End setRelation
							
							function addRelation(relation){
								if (!data[relationName])
									data[relationName] = [];
								data[relationName].push(relation)
							}
							var instType = sHelper.getEntityType(relationName, schema.$[relationName].$item);
								
													
							tracer.trace("$relation: Collection of type: "+instType);
	
							var parameter = param[instType];
							if (instType === self.entityName){
								parameter = param;
							}
							
							if (parameter){
								// Multiple elements
								if (!parameter.$key){
									for (var i in parameter){
										if (mustWrite(parameter[i], isUpdate)){
											var relation = setRelation(parameter[i]);
											if (Object.keys(relation).length !== 0)
												addRelation(relation);
										}
									}
								}
								// Only one element
								else{
									if (mustWrite(parameter, isUpdate)){
										var relation = setRelation(parameter)
										if (Object.keys(relation).length !== 0)
											addRelation(relation);
									}
								}
							}

							
							// $deleteMissing decide if keep missing relations
							if (param.$deleteMissing === "true"){
								tracer.trace(" $deleteMissing = true");
								addProperty(relationName, "$deleteMissing", true);
							}

						}// End writeInstanceRelationCollection

						
						// Process $relations references
						if (schema.$[paramName].$type === "application/x-collection"){
							prepareDataRelationCollection();
						}else{
							prepareDataRelationReference();
						}
						

						
					}//End prepareDataRelation
					
					
					//----------------------------------------------------------
					if (mustWrite(param, isUpdate)){
						if (paramName.indexOf("$") !== 0){
							tracer.traceSubSection("Prepare data parameter: "+paramName,"value: "+JSON.stringify(param,null,2));
//							tracer.traceSubSection("Schema: "+JSON.stringify(schema.$[paramName],null,2));
							if (schema.$[paramName].$type === "application/x-collection" || schema.$[paramName].$type === "application/x-reference"){
								prepareDataRelation(paramName);
							}else if (schema.$[paramName].$item && schema.$[paramName].$item.$type === "application/json"){
								prepareDataRelation(paramName);
							}else{
								prepareDataProperty(paramName);
							}
						}
					}
				}//End prepareDataParam

				tracer.traceSection("Prepare DATA");
				for( var key in schema.$ ) {
					var param = parameters[key];
					prepareDataParam(key, param, data);
				}
				return data;

			}//End prepareData
				

			schema = restUtils.getPrototype(_, self.context, self.entityName, "$edit");

			//tracer.trace("Schema="+JSON.stringify(schema,null,2));

			var sHelper = soapHelper.create(self.application, schema);
			
			var props,
				method,
				url,
				principalData = {};
			
			if (!isUpdate){
				method = "POST";
				url = self.url;
			}else{
				method = "PUT";
				url = self.url + "('" + params[self.entityName].$key + "')";
			}

			
			principalData = prepareData(principalData, params[self.entityName]);
			if (props)
				principalData.$properties = props;
			
			//console.log("DATA="+JSON.stringify(principalData,null,2));
			var resp = restUtils.sendRequest(_, self.context, method, url, principalData);

			soapHelper.ckeckDiagnoses(resp.body);
			response._key = computeKey(resp.body, schema);

			return response;
		}
		
		
		
		
		
		function $delete(_){
			if (params.$key === "")
				throw new Error("The '_key' parameter must not be undefined for 'DELETE' operation.");
			

			var url = self.url + "('" + params.$key + "')";
			var resp = restUtils.sendRequest(_, self.context, "DELETE", url);
			
			
			soapHelper.ckeckDiagnoses(resp.body);
			if (resp.statusCode === 404){
				throw new Error("No '" + self.entityName + "' instance found with identifier '" + params.$key + "'");
			}else if (resp.statusCode !== 200){
				response.deleted = "false";
			}else{
				response.deleted = "true";
			}

			return response;
		}
		
		function $query(_){

			
			function getLinksKey(url){
				var params = url.split("?")[1];
				var parts = params.split("&");
				for (var i in parts){
					var param = parts[i].split("=");
					if (param[0] === "key")
						return param[1];
				}
				return;
			}
			
			
			//console.log("PARAMS="+JSON.stringify(params,null,2));

			// INTERPRET REQUEST
			
			var fetchParams = {};

			// count
			if (params.$count)
				fetchParams.count = parseInt(params.$count);

			// sdataWhere
			if (params.$sdataWhere != null && !(typeof params.$sdataWhere === 'object' && Object.keys(params.$sdataWhere).length === 0) && params.$sdataWhere.length !== 0){
				fetchParams.where = "("+params.$sdataWhere+")";
				fetchParams.where = encodeURIComponent(fetchParams.where);
			}
			// orderBy
			if (params.$orderBy != null && !(typeof params.$orderBy === 'object' && Object.keys(params.$orderBy).length === 0) && params.$orderBy.length !== 0){
				fetchParams.orderBy = "";
				if (!params.$orderBy.orderBy.$binding){
					var i = 0;
					for (var elt in params.$orderBy.orderBy){
						if (params.$orderBy.orderBy[elt].$binding && params.$orderBy.orderBy[elt].$binding.length !== 0){
							if (i !== 0)
								fetchParams.orderBy += ",";
							var order = {
									binding: params.$orderBy.orderBy[elt].$binding,
									descending: params.$orderBy.orderBy[elt].$descending === "true" ? "desc" : "asc"
							};
							fetchParams.orderBy += order.binding + " " + order.descending;
							i++;
						}
					}
				}else{
					if (params.$orderBy.orderBy.$binding && params.$orderBy.orderBy.$binding.length !== 0){
						var order = {
							binding: params.$orderBy.orderBy.$binding,
							descending: params.$orderBy.orderBy.$descending === "true" ? "desc" : "asc"
						}
						fetchParams.orderBy += order.binding + " " + order.descending;
					}
				}
				if (fetchParams.orderBy.length === 0){
					delete fetchParams.orderBy
				}else{
					fetchParams.orderBy = encodeURIComponent(fetchParams.orderBy);
				}
				
			}
			
			// No 'startIndex' for X3 $query
			if (self.app !== "x3"){
				if (params.$pageInfo)
					fetchParams.startIndex = params.$pageInfo;
			}else{
				if (params.$pageInfo !== "null")
					fetchParams.key = params.$pageInfo;
			}
			
			
			//tracer.trace("Fetch parameters: "+JSON.stringify(fetchParams,null,2));
			schema = restUtils.getPrototype(_, self.context, self.entityName, "$query");

			//tracer.trace("Schema="+JSON.stringify(schema,null,2));
			var sHelper = soapHelper.create(self.application, schema);
			
			var httpResp = restUtils.getRepresentation(_, self.context, schema.$url, null, fetchParams);
			if (httpResp.statusCode !== 200)
				throw new Error("An error has occured while retreiving $query representation for entity: "+ self.entityName);
			
			var repQuery = httpResp.body;
			soapHelper.ckeckDiagnoses(repQuery);
			var instances = repQuery.$resources;
			//tracer.trace("Instances="+JSON.stringify(instances,null,2));

			
			// BUILD RESPONSE
			
			// No 'startIndex' and 'totalResults' for X3 $query
			if (self.app !== "x3"){
				response._pageInfo = repQuery.$startIndex != null ? repQuery.$startIndex.toString() : "1";
				response._totalResults = repQuery.$totalResults.toString();
			}else{
				if (fetchParams.key)
					response._pageInfo = fetchParams.key;
				if (repQuery.$links){
					if (repQuery.$links.$first){
						var keyFirst = getLinksKey(repQuery.$links.$first.$url);
						if (keyFirst)
							response._first = keyFirst;
					}
						
					if (repQuery.$links.$previous){
						var keyPrev = getLinksKey(repQuery.$links.$previous.$url);
						if (keyPrev)
							response._previous = keyPrev;
					}
						
					if (repQuery.$links.$next){
						var keyNext = getLinksKey(repQuery.$links.$next.$url);
						if (keyNext)
							response._next = keyNext;
					}
						
					if (repQuery.$links.$last){
						var keyLast = getLinksKey(repQuery.$links.$last.$url);
						if (keyLast)
							response._last = keyLast;
					}
				}
					
			}
			
			
			response._itemsPerPage = repQuery.$itemsPerPage != null ? repQuery.$itemsPerPage.toString() : "20";
			
			
			
			
			
			response[self.entityName + "List"] = {};
			response[self.entityName + "List"][self.entityName] = [];
			
			for (var i in instances){
				var instance = instances[i];
				response[self.entityName + "List"][self.entityName][i] = {};
				
				response[self.entityName + "List"][self.entityName][i] = {};
				response[self.entityName + "List"][self.entityName][i]._key = computeKey(instance, schema.$.$resources.$item);
				for( var key in schema.$.$resources.$item.$ ) {
					if (instance[key]){
						var formatted = sHelper.formatValueForXml(_, key, schema.$.$resources.$item.$[key], instance, getBinary, self.app);
						if (formatted){
							if (key.indexOf('$') === 0)
								key = '_' + key.substring(1);
							response[self.entityName + "List"][self.entityName][i][key] = formatted;
						}
					}
				}
			}
			return response;
		}
		
		
	 
		//tracer.traceSection("Execute REST Request for method : " + method , "Parameters=\n" + JSON.stringify(params,null,2));
		var self = this;
		var namespace = this.application + "." + this.contract + "." + this.dataset;
		var schema;
		
		var response = {
			$: {
				"xmlns": namespace
			}
		};

		switch(method){
			case ("read" + this.title):
				return $details(_);
			case ("list" + this.title):
				return $query(_);
			case ("create" + this.title):
				return $edit(_);
			case ("update" + this.title):
				return $edit(_, true);
			case ("delete" + this.title):
				return $delete(_);
			default:
				throw new Error("Invalid soap action");
		}

	}
});




exports.create = function(_, entityName, context){
	return new restExecutor(entityName, context);
}


