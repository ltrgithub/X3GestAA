"use strict";

var helpers = require("syracuse-core/lib/helpers");
var util = require("util");
var fs = require('fs');
var jsxml = require('jsxml');
var soapHelper = require('./soapHelper');
var restUtils = require('./restUtils');
var soapTracer = require('../common/soapTracer');
var date = require('syracuse-core/lib/types/date');
var time = require('syracuse-core/lib/types/time');
var datetime = require('syracuse-core/lib/types/datetime');

var registry = require("syracuse-sdata/lib/sdataRegistry");
var Context = require("syracuse-sdata/lib/sdataContext").Context;
var dataModel = require("syracuse-orm/lib/dataModel");
var dataContext = require("syracuse-orm/lib/dataContext");


var tracer = soapTracer.create("request");



var restExecutor = helpers.defineClass(function(entityName, context) {
	this.context = context;
	this.mode = "REST";

	this.app = context.applicationName;
	if (this.app === "qunit")
		this.app = "syracuse";
	
	if (this.app === "syracuse"){
		this.application = context.application.name;
		this.contract = context.contract.name;
		this.dataset = context.dataset;
		
	}else if (this.app === "x3"){
		this.application = context.endpoint._data.application; 
		this.contract = context.endpoint._data.contract;
		this.dataset = context.endpoint._data.dataset;

	}else{
		throw context.badRequest("Application not valid");
	}
	
	this.url = context.url.replace("/soap/", "/sdata/");
	this.entityName = entityName;
	this.title = this.entityName.charAt(0).toUpperCase() + this.entityName.slice(1);

	
}, null, {
	execute: function(_, method, params){

		function getBinary(_, title){
			if (params.$binary === "true"){
//				var store = instance[title](_);
//				// read the binary content
//				if (!store.fileExists(_)) throw new Error("File doesn't exist");
//				
//				var buf = store.createReadableStream(_).readAll(_);
//				var props = store.getProperties(_);

				return {
//					content: buf.toString('base64'),
//					length: props.length.toString(),
//					contentType: props.contentType,
//					fileName: props.fileName,
//					uploadDate : datetime.fromJsDate(props.uploadDate).toString()
				}
			}else{
				return;
			}
		}
		
		function setBinary(_, binaryInstance, param){

//			
//			var buf = new Buffer(param.content, 'base64').toString('binary');
//
//			if (buf != null && buf.length !== 0){
//				
//				var props = {
//						length: buf.length,
//						contentType: param.contentType,
//						fileName: param.fileName
//				}
//			
//				var store = binaryInstance;
//
//				var stream = store.createWritableStream(_, props);
//				stream.write(_, buf, "binary");
//				stream.end(null, "", _);
//			}

		}
		

		function ckeckDiagnoses(body){
			//tracer.trace(util.inspect(obj));

			
			if (body && body.$diagnoses){
				for (var i in body.$diagnoses){
					if (body.$diagnoses[i] != null){
						if (body.$diagnoses[i].severity === "error"){
							throw new Error(body.$diagnoses[i].severity + ": " + util.inspect(body.$diagnoses[i].message));
						}else{
							tracer.trace(body.$diagnoses[i].severity + ": " + util.inspect(body.$diagnoses[i].message));
						}
					}
				}
			}
	
		}
		
		
		
		function $details(_){

			if (params.$key === "")
				throw new Error("The '_key' parameter must not be undefined for 'READ' operation.");
			
			
			
			var httpResp = restUtils.getPrototype(_, self.context, self.entityName, "$details");
			if (httpResp.statusCode !== 200)
				throw new Error("An error has occured while retreiving $query prototype for entity: "+ self.entityName);
			schema = httpResp.body;
			//tracer.trace("Schema="+JSON.stringify(schema,null,2));
			var sHelper = soapHelper.create(self.application, schema);
			var resource = {
				$baseUrl: schema.$baseUrl,
				$pluralType: schema.$pluralType,
				$key: params.$key
			};
			httpResp = restUtils.getRepresentation(_, self.context, schema.$url, resource);
			if (httpResp.statusCode !== 200)
				throw new Error("An error has occured while retreiving $query representation for entity: "+ self.entityName);
			
			var instance = httpResp.body;
			ckeckDiagnoses(instance);
			//tracer.trace("Instance = " +JSON.stringify(instance,null,2));
			
			if (instance != null){

				response[self.entityName] = {};
				response[self.entityName]._key = instance.$uuid;
				for( var key in schema.$ ) {

					if (instance[key] != null){
						if(instance[key].length === 0){
							response[self.entityName][key] = "";
						}else{
							var formatted = sHelper.formatValueForXml(_, key, schema.$[key], instance, getBinary, self.app);
							if (formatted){
								if (key.indexOf('$') === 0)
									key = '_' + key.substring(1);
								response[self.entityName][key] = formatted;
							}
						}
					}
					else if(instance[key] === null){
						response[self.entityName][key] = {$: {"xsi:nil": "true"}};
					}
					// DO NOTHING for undefined
					
				}
			}else{
				response[self.entityName] = {$: {"xsi:nil": "true"}};
			}
			return response;
		}
		
		function $edit(_, isUpdate){
			
			
			
			function writeInstance(_, instance, parameters){
				
			
				function mustWrite(param, isUpdateReq){
					if (param == null){
						return false;
					}else if (param.$key && typeof param.$key === 'object'){
						return false;
					}else if (param.$key != null && !isUpdateReq){
						return true;
					}else if (isUpdateReq){
						return true;
					}else{
						return true;
					}
				}//End mustWrite
				
				function writeInstanceParam(_, paramName, param){
					
					function writeInstanceProperty(_, propertyName){
						if (param.$ && param.$["xsi:nil"] === "true"){
							instance[propertyName](_, null);
						}else{
							var converted = sHelper.convertValue(schema.$[propertyName].$type, param);
							if (converted != null){
								if (converted !== "b64"){
									if (converted !== instance[propertyName](_)){
										//tracer.trace("Set instance property '" + propertyName + "' with value : '" + converted + "'");
										instance[propertyName](_, converted);
									}
								}else{
									//tracer.trace("Set store property: " + propertyName);
									setBinary(_, instance[propertyName](_), param);
								}
							}else{
								tracer.trace("## Ignore property: " + propertyName + " because type "+schema.$[propertyName].$type +" is not compatible");
							}
						}
					}//End writeInstanceProperty
					
					function writeInstanceRelation(_, relationName){
						
						
						function getInstance(_, subParams, entityType, isChild){
							tracer.trace(" - Sub param: "+entityType);
							var entity = self.context.model.getEntity(entityType);
							var subInst = self.context.db.fetchInstance(_, entity, subParams.$key);
							
							if (isChild){
								if (!subInst){
									var newChildParam = null;
									var factory = entity.factory;
									tracer.traceSubSection("Create Child Instance with $uuid :" +subParams.$key,"");
									subInst = factory.createInstance(_, null, self.context.db);
									if (subParams.$key != null && subParams.$key !== ""){
										subInst.$uuid = subParams.$key;
										subInst.$key = subParams.$key;
									}
									writeInstance(_, subInst, subParams).$key;

								}else{
									tracer.trace("Child ["+uuid+"] already exists.");
								}
							}else{
								if (!subInst)
									throw new Error("No '" + entityType + "' instance found with identifier '" + subParams.$key + "'");
							}
							return subInst;
						}// End getInstance
						
						
						function writeInstanceRelationReference(_){
							tracer.trace("$relation: Reference");
							
							if (param.$key){
								if (inst != null && isUpdate){
									// Save oldKey only for update
									var oldKey = inst.$key;
								}
								var relationInstance = instance._meta.$relations[relationName];
								// Get instance or create it if it's child and doesn't exists
								inst = getInstance(_, param, relationInstance.$type, relationInstance.isChild);
							}
	
							if (mustWrite(param, isUpdate)){
								if (param.$key){
									if(oldKey)
										tracer.trace("Old key: " +oldKey);
									// If it's a creation or if it's an update and keys are differents
									if (oldKey == null || param.$key !== oldKey){
										tracer.trace("  --> Add one " + relationName + ":\n" + param.$key);
										instance[relationName](_, inst);
									}else{
										tracer.trace("No change on " + relationName + ":\n" + inst.$key);
									}
								}else{
									if (inst){
										tracer.trace("  --> Delete relation " + relationName + ":\n" + inst.$key);
										instance[relationName](_, null);
									}
								}
							}else{
								tracer.trace("PROBLEM: Don't write");
							}
						}// End writeInstanceRelationReference
						
						function writeInstanceRelationCollection(_){
							
							function setRelation(_, relParam){
								// Get instance or create it if it's child and doesn't exists
								var subInst = getInstance(_, relParam, instType, inst._relMeta.isChild);
								tracer.trace("  --> Add " + instType +": " + subInst.$key + "\n");
								inst.set(_, subInst);
							}
							
							var instType = self.context.model.singularize(inst._relMeta.type);
												
							tracer.trace("$relation: Collection of type: "+instType);

							var colElements = [];
							// Multiple elements
							if (param[instType]){
								if (!param[instType].$key){
									for (var i in param[instType]){
										if (mustWrite(param[instType][i], isUpdate)){
											colElements.push(param[instType][i]);
										}
									}
								}
								// Only one element
								else{
									if (mustWrite(param[instType], isUpdate)){
										colElements.push(param[instType]);
									}
								}
							}
							for (var elt in colElements){
								setRelation(_, colElements[elt]);
							}
							
							// $deleteMissing decide if keep missing relations
							if (param.$deleteMissing === "true"){
								tracer.trace(" $deleteMissing = true");
								for (var rel in inst._data){
									var found = false;
									for (var elt in colElements){
										if (colElements[elt].$key === rel){
											found = true;
											break;
										}
									}
									if (!found){
										tracer.trace("  --> Delete relation " + relationName + ": " + rel);
										inst.deleteInstance(_,rel);
									}
								}
							}

						}// End writeInstanceRelationCollection

						// Retrieve current instance
						var inst = instance[relationName](_);
						// Process $relations references
						if (!inst || !inst._relMeta || !inst._relMeta.isPlural){
							writeInstanceRelationReference(_);
						}
						// Process $relations collections
						else{
							writeInstanceRelationCollection(_);
						}
					
					}//End writeInstanceRelation
					
					
					//----------------------------------------------------------
					if (mustWrite(param, isUpdate)){
						tracer.traceSubSection("Write instance parameter: "+paramName);//,"value: "+JSON.stringify(param,null,2));

						if (instance._meta.$properties[paramName]){
							writeInstanceProperty(_, paramName);
						}else if (instance._meta.$relations[paramName]){
							writeInstanceRelation(_, paramName);
						}
					}
				}//End writeInstanceParam


				tracer.traceSection("Write instance : "+instance.$uuid,"");


				for( var key in schema.$ ) {
					//var param = params[self.entityName][key];
					var param = parameters[key];
					writeInstanceParam(_, key, param, instance);
				}

				return instance;

			}//End writeInstance
				

			isUpdate = isUpdate != null ? isUpdate : false;
			var primaryInstance;
			if (isUpdate){
				primaryInstance = self.context.db.fetchInstance(_, self.context.entity, params[self.entityName].$key);
				if (!primaryInstance)
					throw new Error("No '" + self.entityName + "' instance found with identifier '" + params[self.entityName].$key + "'");
					
			}else{
				var factory = self.context.entity.factory;
				primaryInstance = factory.createInstance(_, null, self.context.db);
			}

			
			schema = self.context.getPrototypeResource(_, self.entityName + ".$edit");
			//tracer.trace("Schema = "+JSON.stringify(schema,null,2));
			

			primaryInstance = writeInstance(_, primaryInstance, params[self.entityName]);
			
			
			//tracer.traceSubSection("Save instance: " + primaryInstance.$uuid, JSON.stringify(primaryInstance.serializeInstance(_),null,2));
			var res = primaryInstance.save(_);
			//tracer.trace("Save Result: "+JSON.stringify(res,null,2));
			ckeckDiagnoses(res);

			response._key = primaryInstance.$key;

			return response;
		}
		
		
		
		
		
		function $delete(_){
			if (params.$key === "")
				throw new Error("The '_key' parameter must not be undefined for 'DELETE' operation.");
			

			var url = self.url + "('" + params.$key + "')";
			var resp = restUtils.sendRequest(_, self.context, "DELETE", url);
			
			
			ckeckDiagnoses(resp.body);
			if (resp.statusCode === 404){
				throw new Error("No '" + self.entityName + "' instance found with identifier '" + params.$key + "'");
			}else if (resp.statusCode !== 200){
				response.deleted = "false";
			}else{
				response.deleted = "true";
			}

			return response;
		}
		
		function $query(_){

			var fetchParams = {};
			
			// count
			if (params.$count)
				fetchParams.count = parseInt(params.$count);
			
			// startIndex
			if (params.$startIndex)
				fetchParams.startIndex = parseInt(params.$startIndex);
			
			// sdataWhere
			if (params.$sdataWhere)
				fetchParams.sdataWhere = params.$sdataWhere;
			
			// orderBy
			if (params.$orderBy){
				fetchParams.orderBy = [];
				if (Array.isArray(params.$orderBy)){
					for (var elt in params.$orderBy){
						var paramOrderBy = {
								binding: params.$orderBy[elt].$binding,
								descending: params.$orderBy[elt].$descending === "true"
						};
						fetchParams.orderBy.push(paramOrderBy);
					}
				}else{
					var paramOrderBy = {
						binding: params.$orderBy.orderBy.$binding,
						descending: params.$orderBy.orderBy.$descending === "true"
					}
					fetchParams.orderBy.push(paramOrderBy);
				}
			}
			
			//tracer.trace("Fetch parameters: "+JSON.stringify(fetchParams,null,2));
			var httpResp = restUtils.getPrototype(_, self.context, self.entityName, "$query");
			if (httpResp.statusCode !== 200)
				throw new Error("An error has occured while retreiving $query prototype for entity: "+ self.entityName);
			schema = httpResp.body;
			//tracer.trace("Schema="+JSON.stringify(schema,null,2));
			var sHelper = soapHelper.create(self.application, schema);
			
			httpResp = restUtils.getRepresentation(_, self.context, schema.$url);
			if (httpResp.statusCode !== 200)
				throw new Error("An error has occured while retreiving $query representation for entity: "+ self.entityName);
			
			var repQuery = httpResp.body;
			ckeckDiagnoses(repQuery);
			var instances = repQuery.$resources;
			//tracer.trace("Instances="+JSON.stringify(instances,null,2));

			response._startIndex = repQuery.$startIndex != null ? repQuery.$startIndex.toString() : "1";
			response._itemsPerPage = repQuery.$itemsPerPage != null ? repQuery.$itemsPerPage.toString() : "20";
			
			if (repQuery.$totalResults)
				response._totalResults = repQuery.$totalResults.toString();

			response[self.entityName + "List"] = {};
			response[self.entityName + "List"][self.entityName] = [];
			
			for (var i in instances){
				var instance = instances[i];
				response[self.entityName + "List"][self.entityName][i] = {};
				
				response[self.entityName + "List"][self.entityName][i] = {};
				response[self.entityName + "List"][self.entityName][i]._key = instance.$uuid;
				for( var key in schema.$.$resources.$item.$ ) {
					if (instance[key]){
						var formatted = sHelper.formatValueForXml(_, key, schema.$.$resources.$item.$[key], instance, getBinary, self.app);
						if (formatted){
							if (key.indexOf('$') === 0)
								key = '_' + key.substring(1);
							response[self.entityName + "List"][self.entityName][i][key] = formatted;
						}
					}
				}
			}
			return response;
		}
		
		
	 
		//tracer.traceSection("Execute REST Request for method : " + method , "Parameters=\n" + JSON.stringify(params,null,2));
		var self = this;
		var namespace = this.application + "." + this.contract + "." + this.dataset;
		var schema;
		
		var response = {
			$: {
				"xmlns": namespace
			}
		};

		switch(method){
			case ("read" + this.title):
				return $details(_);
			case ("list" + this.title):
				return $query(_);
			case ("create" + this.title):
				return $edit(_);
			case ("update" + this.title):
				return $edit(_, true);
			case ("delete" + this.title):
				return $delete(_);
			default:
				throw new Error("Invalid soap action");
		}

	}
});




exports.create = function(_, entityName, context){
	return new restExecutor(entityName, context);
}


