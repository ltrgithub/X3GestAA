"use strict";

var helpers = require("syracuse-core/lib/helpers");
var locale = require("syracuse-core/lib/locale");
var soapHelper = require('./soapHelper');
var restUtils = require('./restUtils');
var soapTracer = require('../common/soapTracer');
var Template = require('syracuse-core/lib/resource/resourceProxy').Template;

var tracer = soapTracer.create("request");

var RestExecutor = helpers.defineClass(function(entityName, representation, context) {
	this.context = context;

	this.app = context.applicationName;
	if (this.app === "qunit") this.app = "syracuse";

	this.application = context.endpoint._data.application;
	this.contract = context.endpoint._data.contract;
	this.dataset = context.endpoint._data.dataset;

	this.baseUrl = context.httpSession.host + "/soap-ws/" + this.application + "/" + this.contract + "/" + this.dataset;
	this.url = context.url.replace("/soap-ws/", "/sdata/");
	this.entityName = entityName;
	this.representation = representation;
	this.title = this.representation.charAt(0).toUpperCase() + this.representation.slice(1);

}, null, {
	execute: function(_, method, params) {
		function getBinary(_, title) {
			if (params.$binary === "true") {
				//				var store = instance[title](_);
				//				// read the binary content
				//				if (!store.fileExists(_)) throw new Error("File doesn't exist");
				//				
				//				var buf = store.createReadableStream(_).readAll(_);
				//				var props = store.getProperties(_);

				return {
					//					content: buf.toString('base64'),
					//					length: props.length.toString(),
					//					contentType: props.contentType,
					//					fileName: props.fileName,
					//					uploadDate : datetime.fromJsDate(props.uploadDate).toString()
				};
			} else {
				return;
			}
		}

		function setBinary(_, binaryInstance, param) {

			//			
			//			var buf = new Buffer(param.content, 'base64').toString('binary');
			//
			//			if (buf != null && buf.length !== 0){
			//				
			//				var props = {
			//						length: buf.length,
			//						contentType: param.contentType,
			//						fileName: param.fileName
			//				}
			//			
			//				var store = binaryInstance;
			//
			//				var stream = store.createWritableStream(_, props);
			//				stream.write(_, buf, "binary");
			//				stream.end(null, "", _);
			//			}

		}

		function computeKey(obj, item) {
			if (self.app === "x3") {
				var computed = (new Template(item.$key)).resolve(obj);
				return computed;
			} else {
				return obj.$uuid;
			}
		}

		function $details(_) {

			if (params.$key === "") throw new Error(locale.format(module, "keyNeededForOperation", "READ"));

			schema = restUtils.getPrototype(_, self.context.request.headers, self.baseUrl, self.representation, "$details");

			//tracer.trace("Schema="+JSON.stringify(schema,null,2));
			var sHelper = soapHelper.create(self.application, schema);
			var resource = {
				$baseUrl: schema.$baseUrl,
				$pluralType: schema.$pluralType,
				$key: params.$key
			};
			var httpResp = restUtils.getRepresentation(_, self.context.request.headers, self.baseUrl, schema.$url, resource);

			var instance = httpResp.body;
			soapHelper.ckeckDiagnoses(instance);
			//tracer.trace("Instance = " +JSON.stringify(instance,null,2));

			if (instance != null) {

				response[self.representation] = {};
				response[self.representation]._key = computeKey(instance, schema);
				for (var key in schema.$properties) {

					if (instance[key] != null) {
						if (instance[key].length === 0) {
							response[self.representation][key] = "";
						} else {
							var formatted = sHelper.formatValueForXml(_, key, schema.$properties[key], instance, getBinary, self.app);
							if (formatted) {
								if (key.indexOf('$') === 0) key = '_' + key.substring(1);
								response[self.representation][key] = formatted;
							}
						}
					} else if (instance[key] === null) {
						response[self.representation][key] = {
							$: {
								"xsi:nil": "true"
							}
						};
					}
					// DO NOTHING for undefined

				}
			} else {
				response[self.representation] = {
					$: {
						"xsi:nil": "true"
					}
				};
			}
			return response;
		}

		function $edit(_, isUpdate) {

			function prepareData(data, parameters) {

				function mustWrite(param, isUpdateReq) {
					if (param == null) {
						return false;
					} else if (typeof param === 'object' && Object.keys(param).length === 0) {
						return false;
					} else if (param.$key != null && (typeof param.$key === 'object' || param.$key.length === 0)) {
						return false;
					} else if (param.$key != null && !isUpdateReq) {
						return true;
					} else if (isUpdateReq) {
						return true;
					} else {
						return true;
					}
				} //End mustWrite

				function prepareDataParam(paramName, param) {

					function addProperty(element, name, value) {
						if (!props) props = {};
						if (!props[element]) props[element] = {};
						props[element][name] = value;
					}

					function prepareDataProperty(propertyName) {
						if (param.$ && param.$["xsi:nil"] === "true") {
							data[propertyName] = null;
						} else {

							var converted = sHelper.convertValue(schema.$properties[propertyName].$type, param);
							if (converted != null) {
								if (converted !== "b64") {
									tracer.trace("Set data property '" + propertyName + "' with value : '" + converted.toString() + "'");
									data[propertyName] = converted.toString();

								} else {
									//tracer.trace("Set store property: " + propertyName);
									//setBinary(_, instance[propertyName](_), param);
								}
							} else {
								tracer.trace("## Ignore property: " + propertyName + " because type " + schema.$properties[propertyName].$type + " is not compatible");
							}
						}
					} //End prepareDataProperty

					function prepareDataRelation(relationName) {

						function prepareDataRelationReference() {
							if (mustWrite(param, isUpdate)) {
								tracer.trace("$relation: Reference");
								tracer.trace("Ref: " + JSON.stringify(param, null, 2));

								data[relationName] = {};

								if (param.$ && param.$["xsi:nil"] === "true") {
									data[relationName] = null;
								} else {
									var node = schema.$properties[relationName];
									if (sHelper.isParent(relationName, schema.$properties[relationName], self.representation)) {
										node = schema.$properties[relationName].$item;
									}
									for (var key in param) {
										if (key !== "$key") {
											//console.log("NODE: "+JSON.stringify(node,null,2));
											var converted = sHelper.convertValue(node.$item.$properties[key].$type, param[key]);
											if (converted != null) {
												if (converted !== "b64") {
													tracer.trace("Set data relation reference '" + relationName + "' with value : '" + converted + "'");
													data[relationName][key] = converted;
												} else {
													//tracer.trace("Set store property: " + propertyName);
													//setBinary(_, instance[propertyName](_), param);
												}
											} else {
												tracer.trace("## Ignore property: " + relationName + " because type " + node.$properties[key].$type + " is not compatible");
											}

										} else {
											data[relationName].$uuid = param[key];
										}
									}
								}

								return data[relationName];
							} else {
								return;
							}

						} // End prepareDataRelationReference

						function prepareDataRelationCollection() {

							function setRelation(relation) {
								var rel = {};
								for (var key in relation) {

									if (key !== "$key") {
										var converted = sHelper.convertValue(schema.$properties[relationName].$item.$properties[key].$type, relation[key]);
										if (converted != null) {
											if (converted !== "b64") {
												tracer.trace("Set data relation collection '" + relationName + "' with value : '" + converted + "'");
												rel[key] = converted;
											} else {
												//tracer.trace("Set store property: " + propertyName);
												//setBinary(_, instance[propertyName](_), param);
											}
										} else {
											tracer.trace("## Ignore property: " + relationName + " because type " + schema.$properties[relationName].$properties[key].$type + " is not compatible");
										}

									} else {
										rel.$uuid = relation[key];
									}
								}
								return rel;
							} // End setRelation

							function addRelation(relation) {
								if (!data[relationName]) data[relationName] = [];
								data[relationName].push(relation);
							}
							var instType = sHelper.getEntityType(relationName, schema.$properties[relationName].$item);

							tracer.trace("$relation: Collection of type: " + instType);

							var parameter = param[instType];
							if (instType === self.representation) {
								parameter = param;
							}

							if (parameter) {
								var relation;
								// Multiple elements
								if (!parameter.$key) {
									for (var i in parameter) {
										if (mustWrite(parameter[i], isUpdate)) {
											relation = setRelation(parameter[i]);
											if (Object.keys(relation).length !== 0) addRelation(relation);
										}
									}
								}
								// Only one element
								else {
									if (mustWrite(parameter, isUpdate)) {
										relation = setRelation(parameter);
										if (Object.keys(relation).length !== 0) addRelation(relation);
									}
								}
							}

							// $deleteMissing decide if keep missing relations
							if (param.$deleteMissing === "true") {
								tracer.trace(" $deleteMissing = true");
								addProperty(relationName, "$deleteMissing", true);
							}

						} // End writeInstanceRelationCollection

						// Process $relations references
						if (schema.$properties[paramName].$type === "application/x-array") {
							prepareDataRelationCollection();
						} else {
							prepareDataRelationReference();
						}

					} //End prepareDataRelation

					//----------------------------------------------------------
					if (mustWrite(param, isUpdate)) {
						if (paramName.indexOf("$") !== 0) {
							tracer.traceSubSection("Prepare data parameter: " + paramName, "value: " + JSON.stringify(param, null, 2));
							//							tracer.traceSubSection("Schema: "+JSON.stringify(schema.$properties[paramName],null,2));
							if (schema.$properties[paramName].$type === "application/x-array" || schema.$properties[paramName].$type === "application/x-reference") {
								prepareDataRelation(paramName);
							} else if (schema.$properties[paramName].$item && schema.$properties[paramName].$item.$type === "application/x-object") {
								prepareDataRelation(paramName);
							} else {
								prepareDataProperty(paramName);
							}
						}
					}
				} //End prepareDataParam

				tracer.traceSection("Prepare DATA");
				for (var key in schema.$properties) {
					var param = parameters[key];
					prepareDataParam(key, param, data);
				}
				return data;

			} //End prepareData

			schema = restUtils.getPrototype(_, self.context.request.headers, self.baseUrl, self.representation, "$edit");

			//tracer.trace("Schema="+JSON.stringify(schema,null,2));

			var sHelper = soapHelper.create(self.application, schema);

			var props,
				key,
				principalData = {};

			if (isUpdate) {
				key = params[self.representation].$key;
			}

			principalData = prepareData(principalData, params[self.representation]);
			if (props) principalData.$ = props;


			//console.log("DATA="+JSON.stringify(principalData,null,2));
			//var resp = restUtils.sendRequest(_, self.context.request.headers, method, url, principalData);
			restUtils.useWorkingCopy(_, self.context.request.headers, self.baseUrl, self.url, self.entityName, self.representation, principalData, key);
			response._key = computeKey(principalData, schema);

			return response;
		}

		function $delete(_) {
			if (params.$key === "") throw new Error(locale.format(module, "keyNeededForOperation", "DELETE"));

			var url = self.baseUrl + "/" + self.entityName + "('" + params.$key + "')?representation=" + self.representation + ".$query";
			var resp = restUtils.sendRequest(_, self.context.request.headers, "DELETE", url);

			soapHelper.ckeckDiagnoses(resp.body);
			if (resp.statusCode === 404) {
				throw new Error(locale.format(module, "entityTypeNotFound", self.entityName, params.$key));
			} else if (resp.statusCode !== 200) {
				response.deleted = "false";
			} else {
				response.deleted = "true";
			}

			return response;
		}

		function $query(_) {

			function getLinksKey(url) {
				var params = url.split("?")[1];
				var parts = params.split("&");
				for (var i in parts) {
					var param = parts[i].split("=");
					if (param[0] === "key") return param[1];
				}
				return;
			}

			//console.log("PARAMS="+JSON.stringify(params,null,2));

			// INTERPRET REQUEST

			var fetchParams = {};
			schema = restUtils.getPrototype(_, self.context.request.headers, self.baseUrl, self.representation, "$query");
			//tracer.trace("Schema="+JSON.stringify(schema,null,2));
			var sHelper = soapHelper.create(self.application, schema);

			// count
			if (params.$count) fetchParams.count = parseInt(params.$count, 10);

			// sdataWhere
			if (params.$sdataWhere != null && !(typeof params.$sdataWhere === 'object' && Object.keys(params.$sdataWhere).length === 0) && params.$sdataWhere.length !== 0) {
				sHelper.checkWhere(params.$sdataWhere);
				fetchParams.where = "(" + params.$sdataWhere + ")";
				fetchParams.where = encodeURIComponent(fetchParams.where);
			}
			// orderBy
			if (params.$orderBy != null && !(typeof params.$orderBy === 'object' && Object.keys(params.$orderBy).length === 0) && params.$orderBy.length !== 0) {
				fetchParams.orderBy = "";
				var order;
				if (!params.$orderBy.orderBy.$binding) {
					var i = 0;
					for (var elt in params.$orderBy.orderBy) {
						if (params.$orderBy.orderBy[elt].$binding && params.$orderBy.orderBy[elt].$binding.length !== 0) {
							if (i !== 0) fetchParams.orderBy += ",";
							order = {
								binding: params.$orderBy.orderBy[elt].$binding,
								descending: params.$orderBy.orderBy[elt].$descending === "true" ? "desc" : "asc"
							};
							fetchParams.orderBy += order.binding + " " + order.descending;
							i++;
						}
					}
				} else {
					if (params.$orderBy.orderBy.$binding && params.$orderBy.orderBy.$binding.length !== 0) {
						order = {
							binding: params.$orderBy.orderBy.$binding,
							descending: params.$orderBy.orderBy.$descending === "true" ? "desc" : "asc"
						};
						fetchParams.orderBy += order.binding + " " + order.descending;
					}
				}
				if (fetchParams.orderBy.length === 0) {
					delete fetchParams.orderBy;
				} else {
					fetchParams.orderBy = encodeURIComponent(fetchParams.orderBy);
				}
			}
			if (params.$pageInfo) {
				// No 'startIndex' for X3 $query
				if (self.app !== "x3") {
					fetchParams.startIndex = params.$pageInfo;
				} else {
					fetchParams.key = params.$pageInfo;
				}
			}

			//tracer.trace("Fetch parameters: "+JSON.stringify(fetchParams,null,2));
			var httpResp = restUtils.getRepresentation(_, self.context.request.headers, self.baseUrl, schema.$url, null, fetchParams);
			if (httpResp.statusCode !== 200) throw new Error(locale.format(module, "errGetRepr", self.representation));

			var repQuery = httpResp.body;
			soapHelper.ckeckDiagnoses(repQuery);
			var instances = repQuery.$resources;
			//tracer.trace("Instances="+JSON.stringify(instances,null,2));

			// BUILD RESPONSE

			// No 'startIndex' and 'totalResults' for X3 $query
			if (self.app !== "x3") {
				response._pageInfo = repQuery.$startIndex != null ? repQuery.$startIndex.toString() : "1";
				response._totalResults = repQuery.$totalResults.toString();
			} else {
				if (fetchParams.key) response._pageInfo = fetchParams.key;
				if (repQuery.$links) {
					if (repQuery.$links.$first) {
						var keyFirst = getLinksKey(repQuery.$links.$first.$url);
						if (keyFirst) response._first = keyFirst;
					}

					if (repQuery.$links.$previous) {
						var keyPrev = getLinksKey(repQuery.$links.$previous.$url);
						if (keyPrev) response._previous = keyPrev;
					}

					if (repQuery.$links.$next) {
						var keyNext = getLinksKey(repQuery.$links.$next.$url);
						if (keyNext) response._next = keyNext;
					}

					if (repQuery.$links.$last) {
						var keyLast = getLinksKey(repQuery.$links.$last.$url);
						if (keyLast) response._last = keyLast;
					}
				}

			}

			response._itemsPerPage = repQuery.$itemsPerPage != null ? repQuery.$itemsPerPage.toString() : "20";

			response[self.representation + "List"] = {};
			response[self.representation + "List"][self.representation] = [];

			for (var j in instances) {
				var instance = instances[j];
				response[self.representation + "List"][self.representation][j] = {};

				response[self.representation + "List"][self.representation][j] = {};
				response[self.representation + "List"][self.representation][j]._key = computeKey(instance, schema.$properties.$resources.$item);
				for (var key in schema.$properties.$resources.$item.$properties) {
					if (instance[key]) {
						var formatted = sHelper.formatValueForXml(_, key, schema.$properties.$resources.$item.$properties[key], instance, getBinary, self.app);
						if (formatted) {
							if (key.indexOf('$') === 0) key = '_' + key.substring(1);
							response[self.representation + "List"][self.representation][j][key] = formatted;
						}
					}
				}
			}
			return response;
		}

		//tracer.traceSection("Execute REST Request for method : " + method , "Parameters=\n" + JSON.stringify(params,null,2));
		var self = this;
		var namespace = this.representation + "." + this.dataset + "." + this.contract + "." + this.application;
		var schema;

		var response = {
			$: {
				"xmlns": namespace
			}
		};

		switch (method) {
			case ("read" + this.title):
				return $details(_);
			case ("list" + this.title):
				return $query(_);
			case ("create" + this.title):
				return $edit(_);
			case ("update" + this.title):
				return $edit(_, true);
			case ("delete" + this.title):
				return $delete(_);
			default:
				// EM: added argument this.title
				throw new Error(locale.format(module, "invalidSoapAction", this.title));
		}

	}
});

exports.create = function(_, entityName, representation, context) {
	return new RestExecutor(entityName, representation, context);
};