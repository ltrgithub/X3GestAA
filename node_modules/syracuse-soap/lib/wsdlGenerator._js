"use strict";

var helpers = require("syracuse-core/lib/helpers");
var util = require("util");
var fs = require('fs');
var jsxml = require('jsxml');
var soapUtils = require('./soapUtils');
var genericOperations = require('./genericOperations');

var tracer = helpers.soap && helpers.soap.tracer != null ? helpers.soap.tracer : false;

var requestType = "$details";//"$schema";

var Generator = helpers.defineClass(function(context) {
	this.context = context;
	this.application = this.context.application.name;
	this.contract = this.context.contract.name;
	this.dataset = this.context.dataset;
	this.entity = this.context.entity.name;
	
}, null, {
	run: function(_){
		var schema = this.context.getPrototypeResource(_, this.entity + "." + requestType);
		//traceSection("Entity Schema : " + this.entity, JSON.stringify(schema,null,2));
		var wsdl = this.makeWsdl(_, schema);
		this.write(_, wsdl);
	},
	write: function(_, content){
		var path = require("path").resolve(__dirname, "../") + "/descriptions/" + this.application + "/" + this.contract + "/" + this.dataset + "/" + this.entity + ".wsdl";
		fs.writeFile(path, content, 'utf8', _);
	},
	makeWsdl: function(_, schema){

		
		
		function addOperations(_){

			var generics = genericOperations.get(entity);
			for(var key in generics) {
				addOperation(generics[key].$title, generics[key]);
			}
			
		}
		
		function addOperation(title, op){
			addBinding(title);
			addElements(title);
			addPortType(title);
			addMessages(title);
			addOperationComplexTypes(title, op);
		}
		
		function addOperationComplexTypes(title, element){
			format(title + "Request", element.$request);
			format(title + "Response", element.$response);
		}
		
		function addElements(name){
			addElement(name + "Request");
			addElement(name + "Response");

		}
		
		function addElement(name){
			var element = {
				$: {
					name: name,
					type: "tns:" + name
				}
			}
			wsdl.definitions.types["xs:schema"]["xs:element"].push(element);
		}
		
		function addMessages(name){
			addMessage(name + "Request");
			addMessage(name + "Response");
		}
		
		function addMessage(name){
			var message = {
				$: {
					name: name
				},
				part: {
					$: {
						name: "parameters",
						element: "tns:" + name
					}
				}
			}
			wsdl.definitions.message.push(message);
		}
		
		function addPortType(name){
			var portType = {
				$: {
					name: name
				},
				documentation: "",
				input: {
					$: {
						message: "tns:" + name + "Request"
					}
				},
				output: {
					$: {
						message: "tns:" + name + "Response"
					}
				}
			}
			wsdl.definitions.portType.operation.push(portType);
		}
		
		function addBinding(name){
			var binding = {
				$: {
					name: name
				},
				"soap:operation": {
					$: {
						soapAction: name,
						style: "document"
					}
				},
				input: {
					"soap:body": {
						$: {
							use: "literal"
						}
					}
				},
				output: {
					"soap:body": {
						$: {
							use: "literal"
						}
					}
				}
			}
			wsdl.definitions.binding.operation.push(binding);
		}

		
		function format(title, element){
			var formatted = {
                $: {
                  "name": title.indexOf('$') === 0 ? '_' + title.substring(1) : title,
                }
            }
			if (element.$isMandatory && element.$isMandatory === true)
				formatted.$.minOccurs = "1";
			
			if (element.$default != null)
				formatted.$.default = element.$default;
			
			//trace("Format "+ title + " element with type : "+ element.$type);
			switch(element.$type){
				case "application/x-collection":
					//trace("  Sub item type : "+element.$item.$type);
					var type = element.$item.$type;
					if (type.indexOf('tns:') !== 0 && type.indexOf('xs:') !== 0){
						type = soapUtils.convertType(type);
					}
					if (type != null){
						formatted.$.type = type;
					}else{
						formatted.$.type = "tns:" + title;
						addComplexType(title, element.$item);
					}
					formatted.$.minOccurs = element.$isMandatory && element.$isMandatory === true ? "1" : "0";
					formatted.$.maxOccurs = "unbounded";
					return formatted;
				case "application/x-choice":
					var type = element.$value.$type;
					if (type.indexOf('tns:') !== 0 && type.indexOf('xs:') !== 0){
						type = soapUtils.convertType(type);
					}
					if (type != null){					
						formatted.$.type = "tns:" + title + "-type";
						var $enum = {
				                $: {
				                  "name": title + "-type",
				                }
				            }
						$enum["xs:restriction"] = {
							$: {
								base: type
							},
							"xs:enumeration": []
						}
						for( var key in element.$value.$constraints.$enum ) {
							var xsenum = {
								$: {
									value: element.$value.$constraints.$enum[key].$value.toString()
								}
							}
							$enum["xs:restriction"]["xs:enumeration"].push(xsenum);
						}
						wsdl.definitions.types["xs:schema"]["xs:simpleType"].push($enum);
						return formatted;
					}else{
						trace("Ignore 'x-choice' subtype: '" + element.$type + "' for element: '" + title + "'");
						return;
					}
				case "application/x-reference" || "application/json":
					if (!complexTypeExists()){
						formatted.$.type = "tns:" + title;
						addComplexType(title, element);
						return formatted;
					}else{
						return;
					}
				case "application/x-range":
				case "application/x-graph":
					trace("Ignore type: '" + element.$type + "' for element: '" + title + "'");
					return;
				default:
					var type = element.$type;
					if (type.indexOf('tns:') !== 0 && type.indexOf('xs:') !== 0){
						type = soapUtils.convertType(type);
					}
					if (type != null){
						if (type === "b64"){
							formatted.$.type = "tns:" + title + "-type";
							addbase64ComplexType(title + "-type");
						}else{
							formatted.$.type = type;
						}
						return formatted;
					}else{
						trace("Ignore type: '" + element.$type + "' for element: '" + title + "'");
						return;
					}
			}
		}
		
		function addbase64ComplexType(title){
			var b64cp = {
					$type: "application/x-reference",
					$: {
						content: {
							$type: "xs:base64Binary",
							$default: ""
						},
						length: {
							$type: "xs:integer"
						},
						contentType: {
							$type: "xs:string"
						},
						fileName: {
							$type: "xs:string"
						},
						uploadDate: {
							$type: "xs:dateTime"
						}
					}
			}
			addComplexType(title, b64cp);
		}

		function complexTypeExists(title){
			var cp = wsdl.definitions.types["xs:schema"]["xs:complexType"];
			for (var i in cp){
				if (cp[i].$.name === title){
					return true;
				}
			}
			return false;
		}
		
		function addComplexType(title, element){
			trace("Add ComplexType : "+title);
			var cp = {
				$: {
					name: title
				},
				"xs:sequence": {
					"xs:element": []
				}
			}
			if (title.indexOf("Request") === -1 && title.indexOf("Response") === -1){
				var _key = {
		                $: {
		                  name: "_key",
		                  minOccurs: "1",
		                  type: "xs:string"
		                }
		            }
				cp["xs:sequence"]["xs:element"].push(_key);
			}
			for( var key in element.$ ) {
					//trace("Add Sequence : "+key);
					var formatted = format(key, element.$[key]);
					//trace("FORMAT="+JSON.stringify(formatted,null,2));
					if (formatted)
						cp["xs:sequence"]["xs:element"].push(formatted);
			}
			


			
			wsdl.definitions.types["xs:schema"]["xs:complexType"].push(cp);
		}
		

		
		var namespace = this.application + "." + this.contract + "." + this.dataset;
		var entity = this.entity;
		var title = entity.charAt(0).toUpperCase() + entity.slice(1);
		var description = schema.$description;
		var plural = schema.$pluralType;


		var wsdl = {
			definitions: {

				$: {
					name: title,
					xmlns: "http://schemas.xmlsoap.org/wsdl/",
					"xmlns:soap": "http://schemas.xmlsoap.org/wsdl/soap/",
					"xmlns:xs": "http://www.w3.org/2001/XMLSchema",
					"xmlns:tns": namespace,
				    targetNamespace: namespace,
				},
				types:{
					"xs:schema": {
						$: {
							elementFormDefault: "qualified",
							version: "1.0",
							targetNamespace: namespace
						},
						"xs:element": [],
						"xs:complexType": [],
						"xs:simpleType": []
					}
				},
				message:[],
				portType:{
					$: {
						name: title + "SoapType"
					},
					operation: []
				},
				binding:{
					$: {
						name: title + "SoapBinding",
						type: "tns:" + title + "SoapType"
					},
					"soap:binding": {
						$: {
							style: "document",
							transport: "http://schemas.xmlsoap.org/soap/http"
						}
					},
					operation: []
				},
				service:{
					$: {
						name: title
					},
					documentation: description,
					port: {
						$: {
							name: title + "Soap",
							binding: "tns:" + title + "SoapBinding"
						},
						"soap:address": {
							$: {
								location: schema.$baseUrl + "/" + plural
							}
						}
					}
					
				}
			}
		};



		
		
		try{
			
			addComplexType(entity, schema);
			addOperations(_);
			//trace("TERMINE :\n" + JSON.stringify(wsdl,null,2));
			wsdl = '<?xml version="1.0" encoding="utf-8"?>\n' + jsxml.stringify(wsdl, { indent: '\t' });
		}catch(e){
			throw new Error("Error : "+ e.stack);
		}
		return wsdl;
	}
	
});

function traceSection(title, content){
	trace("\n");
	trace("##################################################");
	trace("#    "+title);
	trace("##################################################");
	
	trace(content);
}
	
function trace(str){
	if (tracer === true)
		console.log(str);
}

exports.generate = function(_, context){
	try{
		traceSection("Generate WSDL Description for entity : "+ context.entity.name, "");
		var gen = new Generator(context);
		return gen.run(_);
	}catch(e){
		throw context.badRequest("An error has occured while generating WSDL file for entity : "+ context.entity.name + "\n" + e.stack);
	}
}