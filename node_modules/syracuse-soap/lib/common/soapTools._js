"use strict";
var helpers = require('syracuse-core').helpers;
var forEachKey = helpers.object.forEachKey;
var jsxml = require('js-xml');
var revivers = require('js-xml/lib/revivers');
var locale = require('streamline-locale');

exports.translateRequest = function(reqBody, ns, useSoapStyle) {
	function addRef(r) {
		if (r.$ && r.$.id) {
			refs[r.$.id] = r;
		} else {
			throw new Error("Multiref ID not found");
		}
	}

	function replaceRefs(obj, parentKey) {
		function _replaceRef(_key, _value) {
			var ref = refs[_value.$.href.substring(1)];
			if (ref) {
				obj[_key] = ref;
			} else {
				throw new Error("Ref not found: " + _value.$.href);
			}
		}
		if (typeof obj === "object") {
			var isArrayType = false;
			if (obj.$ && Object.keys(obj.$).some(function(k) {
					return obj.$[k] === "soapenc:Array";
				})) {
				isArrayType = true;
			}
			forEachKey(obj, function(_key, _value) {
				if (_key !== "$") {
					if (_value && _value.$ && _value.$.href && _value.$.href[0] === "#") {
						_replaceRef(_key, _value);
					}
					replaceRefs(obj[_key], _key);
				}
			});
			if (isArrayType && parentKey && obj[parentKey] !== null) {
				obj.item = obj[parentKey];
				delete obj[parentKey];
			}
		}
	}

	function inspectObject(obj) {
		forEachKey(obj, function(key) {
			var elt = obj[key];
			if (Array.isArray(elt)) {
				elt.forEach(function(r) {
					if (r.$ && r.$.id) {
						addRef(r);
					}
				});
			} else if (typeof elt === "object") {
				if (elt.$ && elt.$.id) {
					addRef(elt);
				}
				inspectObject(elt);
			}
		});
	}

	var key, env, soapHeader, soapBody;
	// find envelope
	for (key in reqBody) {
		if (key.indexOf("Envelope") !== -1) {
			env = reqBody[key];
			break;
		}
	}
	if (!env) throw new Error("No Envelope found in soap request");

	// maybe header will be useful later
	// find header
	for (key in env) {
		if (key.indexOf("Header") !== -1) {
			soapHeader = env[key];
			break;
		}
	}

	// find body
	for (key in env) {
		if (key.indexOf("Body") !== -1) {
			soapBody = env[key];
			break;
		}
	}
	if (!soapBody) throw new Error("No Body found in soap request");

	var refs = {};
	if (useSoapStyle) {
		// get references
		inspectObject(soapBody);
		// replace references by real objects
		replaceRefs(soapBody);
	}

	var result = {
		header: soapHeader,
		body: jsxml.revive(soapBody, revivers.simplify)
	};
	//console.error("RESULT: "+JSON.stringify(result,null,2));
	return result;
};

exports.translateResponse = function(soapBody, protoResp, useSoapStyle) {

	var idref = 0;

	function replaceArray(_key, _array, _property, _parent) {
		var multiRefs = helpers.object.clone(_array);
		_parent[_key] = {};
		_parent[_key][_key] = [];
		multiRefs.forEach(function(multiRef) {
			if (typeof multiRef === "object") parseObject(multiRef);
			var refObj = {
				$: {}
			};
			var itemId = idref++;
			refObj.$.href = "#id" + itemId;
			_parent[_key].$ = {
				"xsi:type": "soapenc:Array",
				"soapenv:encodingStyle": "http://schemas.xmlsoap.org/soap/encoding/"
			};
			_parent[_key][_key].push(refObj);

			addMultiRef(itemId, multiRef, _property);
		});
		if (_parent[_key].$ && _property.$soapType) {
			_parent[_key].$["soapenc:arrayType"] = "wss:" + _property.$soapType + "[" + (Object.keys(_parent[_key][_key]).length) + "]";
		}

	}

	function addMultiRef(id, multiRef, property) {
		soapBody.multiRef = soapBody.multiRef || [];
		multiRef.$ = {
			"id": "id" + id,
			"soapenc:root": "0",
			"soapenv:encodingStyle": "http://schemas.xmlsoap.org/soap/encoding/",
			"xsi:type": "wss:" + property.$soapType
		};
		soapBody.multiRef.push(multiRef);
	}

	function parseObject(obj, props) {
		forEachKey(obj, function(_key, _value) {
			if (_key !== "$cdata") {
				if (Array.isArray(_value) && _value.length > 0) {
					if (useSoapStyle) replaceArray(_key, _value, props[_key], obj);
				} else if (typeof _value !== "object" || _value === null) {
					if (props && props[_key] && props[_key].$xsdType) {
						obj[_key] = {
							$: {
								"xsi:type": props[_key].$xsdType
							},
							$value: _value
						};
					}
				} else {
					parseObject(_value, (props && props[_key] && props[_key].$item && props[_key].$item.$properties) || props);

					if (props && props[_key] && props[_key].$xsdType) {
						obj[_key].$ = obj[_key].$ || {};
						obj[_key].$["xsi:type"] = props[_key].$xsdType;
					}
				}
			}
		});
	}
	//
	parseObject(soapBody, protoResp);
	return soapBody;
};

exports.getNamespaceUrl = function(envelope, prefix, strict) {
	try {
		var xmlns = "xmlns";
		for (var key in envelope.$) {
			if (!prefix) {
				return envelope.$.xmlns;
			} else if (key === (xmlns + ":" + prefix)) {
				return envelope.$[key];
			}

		}
	} catch (e) {
		console.error(e.stack);
		throw e;
	}
	if (strict) throw new Error(locale.format(module, "nsNotMatchPref", prefix));
};

exports.getNamespacePrefix = function(envelope, url, strict, excludes) {
	var xmlns = "xmlns:";
	excludes = excludes || [];
	for (var key in envelope.$) {
		if (key.indexOf(xmlns) === 0 && excludes.indexOf(key.substring(6)) !== -1 && envelope.$[key].indexOf(url) === 0) return key.substring(xmlns.length);
	}
	if (strict) throw new Error(locale.format(module, "nsNotMatchUrl", url));
};