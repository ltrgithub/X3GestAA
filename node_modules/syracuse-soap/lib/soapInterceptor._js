"use strict";

var helpers = require("syracuse-core/lib/helpers");
var util = require("util");
var fs = require('fs');
var jsxml = require('jsxml');
var soapUtils = require('./soapUtils');
var date = require('syracuse-core/lib/types/date');
var time = require('syracuse-core/lib/types/time');
var datetime = require('syracuse-core/lib/types/datetime');

var registry = require("syracuse-sdata/lib/sdataRegistry");
var Context = require("syracuse-sdata/lib/sdataContext").Context;
var dataModel = require("syracuse-orm/lib/dataModel");
var dataContext = require("syracuse-orm/lib/dataContext");


var tracer = helpers.soap && helpers.soap.tracer != null ? helpers.soap.tracer : false;

var Interceptor = helpers.defineClass(function(context) {
	this.context = context;
	this.application = this.context.application.name;
	this.contract = this.context.contract.name;
	this.dataset = this.context.dataset;
	this.entity = this.context.entity.name;
	this.title = this.entity.charAt(0).toUpperCase() + this.entity.slice(1);
	
	this.includeBinaries = false;
	
}, null, {
	run: function(_){

			var reqHeader = this.context.request.headers
			trace("Header : \n" + JSON.stringify(reqHeader,null,2));
			
			var soapAction = reqHeader.soapaction.replace(/\"/g,'');
			
			var reqBody = this.context.request.readAll(_);
			trace("Body : \n" + reqBody);


			return this.translateRequest(_, soapAction, jsxml.parse(reqBody));
				
	},
	translateRequest: function(_, soapAction, reqBody){
		traceSection("Translate SOAP Action : " + soapAction, JSON.stringify(reqBody,null,2));
		
		function format(element){
				var newElement = {};
				for( var key in element ) {
					var newKey;
					if (key.indexOf(nsEntity) === 0){
						newKey = key.substring(nsEntity.length);
					}else{
						newKey = key;
					}
					if (newKey.indexOf('_') === 0)
						newKey = '$' + newKey.substring(1);
					newElement[newKey] = Array.isArray(element[key]) || typeof element[key] === 'object' ? format(element[key]) : element[key];
				}
			return newElement;
		}

		var nsSoap;
		for( var key in reqBody ) {
			nsSoap = key.split(':')[0] + ':';
		}

		var soapHeader = reqBody[nsSoap + "Envelope"][nsSoap + "Header"];
		var soapBody = reqBody[nsSoap + "Envelope"][nsSoap + "Body"];
		
		var nsEntity = '';
		var opRequestName, opRequest;

		for( var key in soapBody ) {
			if (key.indexOf(soapAction + "Request") !== -1){
				if (key.indexOf(':') !== -1)
					nsEntity = key.split(':')[0] + ':';
				opRequestName = key;
				opRequest = soapBody[key];
			}
		}
		if (!opRequest)
			throw new Error("SOAP Request not found.");
		
		var methodName = opRequestName.substring(nsEntity.length,opRequestName.toLowerCase().indexOf(this.entity) + this.entity.length);

		if (opRequest.$)
			delete opRequest.$;
		
		var params = format(opRequest);
		
		return this.execute(_, methodName, params);

		
	},
	execute: function(_, method, params){

		function getBinary(_, title){
			if (params.$binary === "true"){
				var store = instance[title](_);
				// read the binary content
				if (!store.fileExists(_)) throw new Error("File doesn't exist");
				// get file meta example
				var props = store.getProperties(_);
				store.readOpen(_);
				var buf;
				var len = 0;
				var buffers = [];
				while(buf = store.read(_, props.chunkSize)){
					len += buf.length;
					buffers.push(buf);
				}
				return {
					content: Buffer.concat(buffers, len).toString('base64'),
					length: props.length.toString(),
					contentType: props.contentType,
					fileName: props.fileName,
					uploadDate : datetime.fromJsDate(props.uploadDate).toString()
				}
			}else{
				return;
			}
		}
		

		function format(_, title, element, serializedInstance){
			
			function returnValue(_){
				var result;
				if (val != null){
					var type = soapUtils.convertType(element.$type);
					if (type === "xs:date"){
						return date.fromJsDate(new Date(val), true).toString();
					}else if (type === "xs:time"){
						return time.fromJsDate(new Date(val), true).toString();
					}else if (type === "xs:dateTime"){
						return datetime.fromJsDate(val).toString();
					}else if (type === "b64"){
						return getBinary(_, title);
					}else{
						return val.toString();
					}
				}else{
					return;
				}

			}
			
			var val = serializedInstance[title];
			traceSection("Resolve: "+title ,"type: "+element.$type+"\nvalue: "+util.inspect(val));
			switch(element.$type){
			case "application/x-collection":
				var col = [];
				for (var i in val){
					var item = {};
					col[i] = item;
					if (val[i] != null && val[i].$uuid){
						col[i]._key = val[i].$uuid
					}
					for( var key in element.$item.$ ) {
						var formatted = format(_, key, element.$item.$[key], val[i]);
						if (formatted)
							item[key] = formatted;
					}

					

				}					
				return col.length !== 0 ? col : null;
			case "application/x-choice":
				return returnValue(_);
			case "application/x-reference" || "application/json":
				var ref = {};
				traceSection("Resolve reference: " + title, util.inspect(val));
				if (val != null && val.$uuid){
					ref._key = val.$uuid
				}
					
				for( var key in element.$ ) {
					if (val != null){
						var formatted = format(_, key, element.$[key], val);
						if (formatted)
							ref[key] = formatted;
					}
				}
				return ref;
			case "application/x-range":
				trace("Ignore type: '" + element.$type + "' for element: '" + title + "'");
				return;
			case "application/x-graph":
				trace("Ignore type: '" + element.$type + "' for element: '" + title + "'");
				return;
			default:
				var type = element.$type;
				if (type != null){
					return returnValue(_);
				}else{
					trace("**Ignore type: '" + element.$type + "' for element: '" + title + "'");
					return;
				}
			}

		}
		
		function setRelations(_,inst, key, param, isUpdate){
			//trace("Instance = \n" +util.inspect(inst,null,2));
			if (inst._relMeta && inst._relMeta.isPlural){
				var arr = {
					$key: "$uuid",
					$items: []
				}

				if (param != null){
					if (!param.$key){
						for (var i in param){
							if ((param[i].$key != null && param[i].$key != "" && typeof param[i].$key !== 'object') || isUpdate){
								arr.$items.push(param[i].$key);
							}
						}
					}else{
						if ((param.$key != null && param.$key != "" && typeof param.$key !== 'object')|| isUpdate){
							arr.$items.push(param.$key);
						}
					}
				}
				if (arr.$items.length !== 0){
					trace("Add " + key +":\n" + JSON.stringify(arr.$items,null,2));
					inst.setArray(_, arr);
				}
			}else{
				trace("Add " + key + ":\n" + inst.$key);
				instance[key](_, inst);
			}
		}
		

		
		
		function ckeckDiagnoses(obj){
			//trace(util.inspect(obj));

			Object.keys(obj.$).forEach(function(elt){
				if (obj.$[elt].$diagnoses != null && obj.$[elt].$diagnoses.length !== 0){
					obj.$[elt].$diagnoses.forEach(function(diag){
						throw new Error(diag.severity + " in element: " + elt + " : " + diag.message);
					});
				}
			});
	
		}
		
		/*
		 * Begin of request interceptor
		 */
		
		//traceSection("Execute REST Request for method : " + method , "Parameters=\n" + JSON.stringify(params,null,2));


		var namespace = this.application + "." + this.contract + "." + this.dataset;
		var schema;
		
		this.envelope = {
				"soap:Envelope": {

					$: {
						"xmlns:soap": "http://schemas.xmlsoap.org/soap/envelope/",
						"xmlns:xs": "http://www.w3.org/2001/XMLSchema",
						"xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance"
					},
					"soap:Body":{}
				}
			};

		var response = {
				$: {
					"xmlns": namespace
				}
			};

		if (method === "read" + this.title){

			if (params.$key === "")
				throw new Error("The '_key' parameter must not be undefined for 'READ' operation.");
			
			
			var instance = this.context.db.fetchInstance(_, this.context.entity, params.$key);

			if (instance != null){
				schema = this.context.getPrototypeResource(_, this.entity + ".$details");
				
				var serializedInstance = instance.serializeInstance(_);
				trace("Instance = \n" +JSON.stringify(serializedInstance,null,2));

				response[this.entity] = {};
				response[this.entity]._key = instance.$key;
				for( var key in schema.$ ) {

					if (serializedInstance[key]){
						var formatted = format(_, key, schema.$[key], serializedInstance);
						if (formatted){
							if (key.indexOf('$') === 0)
								key = '_' + key.substring(1);
							response[this.entity][key] = formatted;
						}
					}
				}
			}
			this.addSoapBodyResponse(method, response);
			
		}else if (method === "list" + this.title){
			var instances = this.context.db.fetchInstances(_, this.context.entity);
			
			schema = this.context.getPrototypeResource(_, this.entity + ".$query");
			
			response["ArrayOf" + this.title] = [];
			for (var i in instances){
				var instance = instances[i];
				var serializedInstance = instance.serializeInstance(_);
				//trace("Instance = \n" +JSON.stringify(serializedInstance,null,2));

				response["ArrayOf" + this.title][i] = {};
				
				response["ArrayOf" + this.title][i][this.entity] = {};
				response["ArrayOf" + this.title][i][this.entity]._key = instance.$key;
				for( var key in schema.$.$resources.$item.$ ) {
					if (instance[key]){
						var formatted = format(_, key, schema.$.$resources.$item.$[key], serializedInstance);
						if (formatted){
							if (key.indexOf('$') === 0)
								key = '_' + key.substring(1);
							response["ArrayOf" + this.title][i][this.entity][key] = formatted;
						}
					}
				}

			}
			this.addSoapBodyResponse(method, response);
			
		}
		
		else if (method === "create" + this.title){
			var factory = this.context.entity.factory;

			var instance = factory.createInstance(_, null, this.context.db);
			//trace("Instance = \n" +util.inspect(instance,null,2));
			schema = this.context.getPrototypeResource(_, this.entity + ".$details");
			
			var serializedInstance = instance.serializeInstance(_);
			//trace("Serialized Instance = \n" +JSON.stringify(serializedInstance,null,2));
			response._key = instance.$key;

			for( var key in schema.$ ) {
				var param = params[this.entity][key];			
				if (instance._meta.$properties[key]){
					var converted = soapUtils.convertValue(schema.$[key].$type, param);
					if (converted != null){
						if (converted !== "b64"){
							trace("Set instance property: " + key + " with value :'" + converted + "'");
							instance[key](_, converted);
						}else{
							trace("TODO: Ignore b64 property: " + key);
						}
					}else{
						trace("##### Ignore relation property: " + key + " because type "+schema.$[key].$type +" is not compatible");
					}

				}else if (instance._meta.$relations[key]){
		
					var inst = instance[key](_);
					
					if (inst){
						setRelations(_, inst, key, param);
						
					}else{
						
						if (param != null){

							if (param.$key){
								if (param.$key != null){
									var entity;
									if (instance._meta.$relations[key].$type === this.entity){
										entity = instance._meta.$relations[key].targetEntity;
									}else{
										entity = this.context.db.model.getEntity(instance._meta.$relations[key].$type);
									}
									inst = this.context.db.fetchInstance(_, entity, param.$key);
									if (inst){
										//trace("Instance = \n" +util.inspect(inst,null,2));
										setRelations(_, inst, key, param);
									}else{
										throw new Error("No " + key + " instance found with identifier '" + param.$key + "'");
									}
								}
							}
						}
					}
				}
			}

			var res = instance.save(_);
			
			ckeckDiagnoses(res);

			this.addSoapBodyResponse(method, response);
			
		}
		
		else if (method === "delete" + this.title){
			
			if (params.$key === "")
				throw new Error("The '_key' parameter must not be undefined for 'READ' operation.");
			
			
			var instance = this.context.db.fetchInstance(_, this.context.entity, params.$key);
			if (instance != null){
				// TODO: canDelete must be remove when criti add it in deleteSelf function
				if (instance.canDelete(_)){
					var res = instance.deleteSelf(_);
					if (res){
						response.deleted = "true";
					}else{
						throw new Error(instance.deleteError);
					}
				}else{
					throw new Error(instance.deleteError);
				}
			}else{
				throw new Error("No " + this.entity + " instance found with identifier '" + params.$key + "'");
			}
			this.addSoapBodyResponse(method, response);

		}
		
		else if (method === "update" + this.title){
			
			// TODO
			
			
			
			
			
		}
		
		//trace(JSON.stringify(this.envelope,null,2));
		return jsxml.stringify(this.envelope,{ indent: '\t' });


	},
	addSoapBodyResponse: function(method, response){
		this.envelope["soap:Envelope"]["soap:Body"][method + "Response"] = response;
	},
	addSoapBodyException: function(ex, code){
		this.envelope["soap:Envelope"]["soap:Body"]["soap:Fault"] = {
				faultcode : {
					$: {
						"xsi:type": "xsd:string"
					},
					$value: code
				},
				faultstring : {
					$: {
						"xsi:type": "xsd:string"
					},
					$value: ex.message
				}
//				,
//				detail: {
//					$: {
//						"xsi:type": "xsd:string"
//					},
//					$value: ex.stack
//				}
				
		}
		return jsxml.stringify(this.envelope,{ indent: '\t' });
	}
});


function traceSection(title, content){
	trace("\n");
	trace("##################################################");
	trace("#    "+title);
	trace("##################################################");
	
	trace(content);
}
	
function trace(str){
	if (tracer === true)
		console.log(str);
}

exports.intercept = function(_, context){
	var interceptor = new Interceptor(context);
	var soapResponse;
	try{

		
		traceSection("Intercept SOAP Request for entity : " + context.entity.name, "");
		soapResponse = interceptor.run(_);
	}catch(e){
		trace(e.stack);
		soapResponse = interceptor.addSoapBodyException(e, "soap:Server");

	}finally{
		soapResponse = '<?xml version="1.0" encoding="utf-8"?>\n' + soapResponse;
		traceSection("Send SOAP Reply  : ", soapResponse);
		return soapResponse
	}
}