"use strict";

var helpers = require("syracuse-core/lib/helpers");
var util = require("util");
var fs = require('fs');
var jsxml = require('jsxml');
var soapUtils = require('./soapUtils');
var date = require('syracuse-core/lib/types/date');
var time = require('syracuse-core/lib/types/time');
var datetime = require('syracuse-core/lib/types/datetime');

var registry = require("syracuse-sdata/lib/sdataRegistry");
var Context = require("syracuse-sdata/lib/sdataContext").Context;
var dataModel = require("syracuse-orm/lib/dataModel");
var dataContext = require("syracuse-orm/lib/dataContext");


var tracer = helpers.soap && helpers.soap.tracer != null ? helpers.soap.tracer : false;

var Interceptor = helpers.defineClass(function(context) {
	this.context = context;
	this.application = this.context.application.name;
	this.contract = this.context.contract.name;
	this.dataset = this.context.dataset;
	this.entity = this.context.entity.name;
	this.title = this.entity.charAt(0).toUpperCase() + this.entity.slice(1);
	
	this.includeBinaries = false;
	
}, null, {
	run: function(_){

			var reqHeader = this.context.request.headers
			trace("Header : \n" + JSON.stringify(reqHeader,null,2));
			
			var soapAction = reqHeader.soapaction.replace(/\"/g,'');
			
			var reqBody = this.context.request.readAll(_);
			trace("Body : \n" + reqBody);


			return this.translateRequest(_, soapAction, jsxml.parse(reqBody));
				
	},
	translateRequest: function(_, soapAction, reqBody){
		traceSection("Translate SOAP Action : " + soapAction, JSON.stringify(reqBody,null,2));
		
		function format(element){
				var newElement = {};
				for( var key in element ) {
					var newKey;
					if (key.indexOf(nsEntity) === 0){
						newKey = key.substring(nsEntity.length);
					}else{
						newKey = key;
					}
					if (newKey.indexOf('_') === 0)
						newKey = '$' + newKey.substring(1);
					newElement[newKey] = Array.isArray(element[key]) || typeof element[key] === 'object' ? format(element[key]) : element[key];
				}
			return newElement;
		}

		var nsSoap;
		for( var key in reqBody ) {
			nsSoap = key.split(':')[0] + ':';
		}

		var soapHeader = reqBody[nsSoap + "Envelope"][nsSoap + "Header"];
		var soapBody = reqBody[nsSoap + "Envelope"][nsSoap + "Body"];
		
		var nsEntity = '';
		var opRequestName, opRequest;

		for( var key in soapBody ) {
			if (key.indexOf(soapAction + "Request") !== -1){
				if (key.indexOf(':') !== -1)
					nsEntity = key.split(':')[0] + ':';
				opRequestName = key;
				opRequest = soapBody[key];
			}
		}
		if (!opRequest)
			throw new Error("SOAP Request not found.");

		var methodName = opRequestName.substring(nsEntity.length,opRequestName.toLowerCase().indexOf(this.entity.toLowerCase()) + this.entity.length);

		if (opRequest.$)
			delete opRequest.$;
		
		var params = format(opRequest);
		
		return this.execute(_, methodName, params);

		
	},
	execute: function(_, method, params){

		function getBinary(_, title){
			if (params.$binary === "true"){
				var store = instance[title](_);
				// read the binary content
				if (!store.fileExists(_)) throw new Error("File doesn't exist");
				
				var buf = store.createReadableStream(_).readAll(_);
				var props = store.getProperties(_);

				return {
					content: buf.toString('base64'),
					length: props.length.toString(),
					contentType: props.contentType,
					fileName: props.fileName,
					uploadDate : datetime.fromJsDate(props.uploadDate).toString()
				}
			}else{
				return;
			}
		}
		
		function setBinary(_, binaryInstance, param){

			
			var buf = new Buffer(param.content, 'base64').toString('binary');

			if (buf != null && buf.length !== 0){
				
				var props = {
						length: buf.length,
						contentType: param.contentType,
						fileName: param.fileName
				}
			
				var store = binaryInstance;

				var stream = store.createWritableStream(_, props);
				stream.write(_, buf, "binary");
				stream.end(null, "", _);
			}

		}
		

		function format(_, title, element, serializedInstance){
			
			function returnValue(_){
				var result;
				if (val != null){
					var type = soapUtils.convertType(element.$type);
					if (type === "xs:date"){
						return date.fromJsDate(new Date(val), true).toString();
					}else if (type === "xs:time"){
						return time.fromJsDate(new Date(val), true).toString();
					}else if (type === "xs:dateTime"){
						return datetime.fromJsDate(val).toString();
					}else if (type === "b64"){
						return getBinary(_, title);
					}else{
						return val.toString();
					}
				}else{
					return;
				}

			}
			
			var val = serializedInstance[title];
			traceSection("Resolve: "+title ,"type: "+element.$type);
			switch(element.$type){
			case "application/x-collection":
				var col = [];
				for (var i in val){
					var item = {};
					col[i] = item;
					if (val[i] != null && val[i].$uuid){
						col[i]._key = val[i].$uuid
					}
					for( var key in element.$item.$ ) {
						var formatted = format(_, key, element.$item.$[key], val[i]);
						if (formatted)
							item[key] = formatted;
					}

					

				}					
				return col.length !== 0 ? col : null;
			case "application/x-choice":
				return returnValue(_);
			case "application/x-reference" || "application/json":
				var ref = {};
				if (val != null && val.$uuid){
					ref._key = val.$uuid
				}
					
				for( var key in element.$ ) {
					if (val != null){
						var formatted = format(_, key, element.$[key], val);
						if (formatted)
							ref[key] = formatted;
					}
				}
				return ref;
			case "application/x-range":
				trace("Ignore type: '" + element.$type + "' for element: '" + title + "'");
				return;
			case "application/x-graph":
				trace("Ignore type: '" + element.$type + "' for element: '" + title + "'");
				return;
			default:
				var type = element.$type;
				if (type != null){
					return returnValue(_);
				}else{
					trace("**Ignore type: '" + element.$type + "' for element: '" + title + "'");
					return;
				}
			}

		}
		
		function mustWrite(param, isUpdateReq){
			if (param.$key != null && param.$key != "" && typeof param.$key !== 'object' && !isUpdateReq){
				return true;
			}else if (isUpdateReq && typeof param.$key !== 'object'){
				return true;
			}else{
				return false;
			}
		}
		
		function ckeckDiagnoses(obj){
			//trace(util.inspect(obj));

			for (var i in obj.$diagnoses){
				if (obj.$diagnoses[i] != null){
					throw new Error(obj.$diagnoses[i].severity + ": " + obj.$diagnoses[i].message);
				}
			}
			Object.keys(obj.$).forEach(function(elt){
				if (obj.$[elt].$diagnoses != null && obj.$[elt].$diagnoses.length !== 0){
					obj.$[elt].$diagnoses.forEach(function(diag){
						throw new Error(diag.severity + " in element: " + elt + " : " + diag.message);
					});
				}
			});
	
		}
		
		/*
		 * Begin of request interceptor
		 */
		
		//traceSection("Execute REST Request for method : " + method , "Parameters=\n" + JSON.stringify(params,null,2));


		var namespace = this.application + "." + this.contract + "." + this.dataset;
		var schema;
		
		this.envelope = {
			"soap:Envelope": {

				$: {
					"xmlns:soap": "http://schemas.xmlsoap.org/soap/envelope/",
					"xmlns:xs": "http://www.w3.org/2001/XMLSchema",
					"xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance"
				},
				"soap:Body":{}
			}
		};

		var response = {
			$: {
				"xmlns": namespace
			}
		};

		// READ
		if (method === "read" + this.title){

			if (params.$key === "")
				throw new Error("The '_key' parameter must not be undefined for 'READ' operation.");
			
			
			var instance = this.context.db.fetchInstance(_, this.context.entity, params.$key);
			
			if (instance != null){
				schema = this.context.getPrototypeResource(_, this.entity + ".$details");
				
				var serializedInstance = instance.serializeInstance(_);
				//trace("Instance = \n" +JSON.stringify(serializedInstance,null,2));

				response[this.entity] = {};
				response[this.entity]._key = instance.$key;
				for( var key in schema.$ ) {

					if (serializedInstance[key]){
						var formatted = format(_, key, schema.$[key], serializedInstance);
						if (formatted){
							if (key.indexOf('$') === 0)
								key = '_' + key.substring(1);
							response[this.entity][key] = formatted;
						}
					}
				}
			}
			this.addSoapBodyResponse(method, response);
			
		}
		// LIST
		else if (method === "list" + this.title){
			var instances = this.context.db.fetchInstances(_, this.context.entity);
			
			schema = this.context.getPrototypeResource(_, this.entity + ".$query");
			
			response["ArrayOf" + this.title] = [];
			for (var i in instances){
				var instance = instances[i];
				var serializedInstance = instance.serializeInstance(_);
				//trace("Instance = \n" +JSON.stringify(serializedInstance,null,2));

				response["ArrayOf" + this.title][i] = {};
				
				response["ArrayOf" + this.title][i][this.entity] = {};
				response["ArrayOf" + this.title][i][this.entity]._key = instance.$key;
				for( var key in schema.$.$resources.$item.$ ) {
					if (instance[key]){
						var formatted = format(_, key, schema.$.$resources.$item.$[key], serializedInstance);
						if (formatted){
							if (key.indexOf('$') === 0)
								key = '_' + key.substring(1);
							response["ArrayOf" + this.title][i][this.entity][key] = formatted;
						}
					}
				}

			}
			this.addSoapBodyResponse(method, response);
			
		}
		
		// CREATE & UPDATE
		else if (method === "create" + this.title || method === "update" + this.title){
			var instance, isUpdate;
			if (method === "update" + this.title){
				isUpdate = true;
				instance = this.context.db.fetchInstance(_, this.context.entity, params[this.entity].$key);
				if (!instance)
					throw new Error("No '" + this.entity + "' instance found with identifier '" + params[this.entity].$key + "'");
					
			}else{
				var factory = this.context.entity.factory;
				isUpdate = false;
				instance = factory.createInstance(_, null, this.context.db);
			}

			//trace("Instance = \n" +util.inspect(instance,null,2));
			schema = this.context.getPrototypeResource(_, this.entity + ".$edit");

			response._key = instance.$key;

			for( var key in schema.$ ) {
				var param = params[this.entity][key];
				traceSection("Process "+key+" param","");
				if (instance._meta.$properties[key]){
					if (param != null){
						var converted = soapUtils.convertValue(schema.$[key].$type, param);
						if (converted != null){
							if (converted !== "b64"){
								if (converted !== instance[key](_)){
									trace("Set instance property '" + key + "' with value : '" + converted + "'");
									instance[key](_, converted);
								}
							}else{
								trace("Set store property: " + key);
								setBinary(_, instance[key](_), param);
							}
						}else{
							trace("## Ignore property: " + key + " because type "+schema.$[key].$type +" is not compatible");
						}
					}else{
						trace("Ignore property: " + key + " because value is null");
					}
				}else if (instance._meta.$relations[key]){

					if (param != null){
						// Retrieve current instance
						var inst = instance[key](_);
						
						//trace("Instance = \n" +util.inspect(inst,null,2));
						// Process $relations references
						if (!inst || !inst._relMeta || !inst._relMeta.isPlural){
							trace("$relation: Reference");

							if (param.$key && param.$key !== ""){
								if (inst != null && isUpdate){
									// Save oldKey only for update
									var oldKey = inst.$key;
								}
								var entity;
								// Retrieve entity type
								if (instance._meta.$relations[key].$type === this.entity){
									entity = instance._meta.$relations[key].targetEntity;
								}else{
									entity = this.context.db.model.getEntity(instance._meta.$relations[key].$type);
								}
								// Retrieve new instance
								inst = this.context.db.fetchInstance(_, entity, param.$key);
								if (!inst)
									throw new Error("No '" + entity.name + "' instance found with identifier '" + param.$key + "'");
							}

							if (mustWrite(param, isUpdate)){
								if (param.$key && param.$key !== ""){
									if(oldKey)
										trace("Old key: " +oldKey);
									// If it's a creation or if it's an update and keys are differents
									if (oldKey == null || param.$key !== oldKey){
										trace("Add one " + key + ":\n" + param.$key);
										instance[key](_, inst);
									}else{
										trace("No change on " + key + ":\n" + inst.$key);
									}
								}else{
									if (inst){
										trace("Delete " + key + ":\n" + inst.$key);
										instance[key](_, null);
									}
								}
							}else{
								trace("PROBLEM: Don't write");
							}

						}
						// Process $relations collections
						else{
							trace("$relation: Collection");
							var arr = {
								$key: "$uuid",
								$items: []
							}
							if (isUpdate){
								trace("Delete all " + key + " relations.");
								inst.reset(_);
							}
							// Multiple elements
							if (!param.$key){
								for (var i in param){
									if (mustWrite(param[i], isUpdate) && param[i].$key !== ""){
										arr.$items.push(param[i].$key);
									}
								}
							}
							// Only one element
							else{
								if (mustWrite(param, isUpdate) && param.$key !== ""){
									arr.$items.push(param.$key);
								}
							}
							if (arr.$items.length !== 0){
								trace("Add multiple " + key +":\n" + JSON.stringify(arr.$items,null,2));
								inst.setArray(_, arr);
							}

						}
					}
				}
			}

			var res = instance.save(_);
			//trace("RES_SAVE="+util.inspect(res));
			ckeckDiagnoses(res);

			this.addSoapBodyResponse(method, response);
			
		}
		
		else if (method === "delete" + this.title){
			
			if (params.$key === "")
				throw new Error("The '_key' parameter must not be undefined for 'READ' operation.");
			
			
			var instance = this.context.db.fetchInstance(_, this.context.entity, params.$key);
			if (instance != null){
				// TODO: canDelete must be remove when cristi add it in deleteSelf function
				if (instance.canDelete(_)){
					var res = instance.deleteSelf(_);
					if (res){
						response.deleted = "true";
					}else{
						throw new Error(instance.deleteError);
					}
				}else{
					throw new Error(instance.deleteError);
				}
			}else{
				throw new Error("No " + this.entity + " instance found with identifier '" + params.$key + "'");
			}
			this.addSoapBodyResponse(method, response);

		}
		

		
		//trace(JSON.stringify(this.envelope,null,2));
		return jsxml.stringify(this.envelope,{ indent: '\t' });


	},
	addSoapBodyResponse: function(method, response){
		this.envelope["soap:Envelope"]["soap:Body"][method + "Response"] = response;
	},
	addSoapBodyException: function(ex, code){
		this.envelope["soap:Envelope"]["soap:Body"]["soap:Fault"] = {
				faultcode : {
					$: {
						"xsi:type": "xsd:string"
					},
					$value: code
				},
				faultstring : {
					$: {
						"xsi:type": "xsd:string"
					},
					$value: ex.message
				}
//				,
//				detail: {
//					$: {
//						"xsi:type": "xsd:string"
//					},
//					$value: ex.stack
//				}
				
		}
		return jsxml.stringify(this.envelope,{ indent: '\t' });
	}
});


function traceSection(title, content){
	trace("\n");
	trace("##################################################");
	trace("#    "+title);
	trace("##################################################");
	
	trace(content);
}
	
function trace(str){
	if (tracer === true)
		console.log(str);
}

exports.intercept = function(_, context){
	var interceptor = new Interceptor(context);
	var soapResponse;
	try{

		
		traceSection("Intercept SOAP Request for entity : " + context.entity.name, "");
		soapResponse = interceptor.run(_);
	}catch(e){
		trace(e.stack);
		soapResponse = interceptor.addSoapBodyException(e, "soap:Server");

	}finally{
		soapResponse = '<?xml version="1.0" encoding="utf-8"?>\n' + soapResponse;
		traceSection("Send SOAP Reply  : ", soapResponse);
		return soapResponse
	}
}