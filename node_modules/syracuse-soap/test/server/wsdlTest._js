"use strict";

var qmodule = QUnit.module;

var util = require("util");
var baseUrl = "http://localhost:3004";
var port = 3004;
var helpers = require('syracuse-core/lib/helpers');
var types = require('syracuse-core/lib/types/allTypes');
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var mongodb = require("mongodb");
var adminTestFixtures = require("syracuse-collaboration/test/fixtures/adminTestFixtures");
var streams = require('streamline/lib/streams/streams');
var forEachKey = helpers.object.forEachKey;
var jsxml = require('jsxml');
var wsdlGenerator = require('syracuse-soap/lib/server/wsdlGenerator');

var tracer = console.log;
//var tracer = null;

//force basic auth
config.session = config.session || {};
config.session.auth = "basic";

var endPoint = adminTestFixtures.modifyCollaborationEndpoint("mongodb_admin_test");

var testData = require('syracuse-sdata/test/fixtures/testDB');
var testEndPoint = testData.endpoint;
// Replace contract name
testEndPoint.contract.contract = "soapTest";

testEndPoint.datasets = {
	test: {
		driver: "mongodb",
		database: "test",
		hostname: "localhost",
		port: 27017
	}
};

config.sdata.endpoints.push(testEndPoint);

var cookie;

var doStop = false;
qmodule("wsdl-generator", {
	setup: function() {},
	teardown: function() {
		if (doStop) {
			//syracuse.server.close();
			setTimeout(function() {
				process.kill(process.pid);
			}, 500)
		}
	}
});

asyncTest("init database", 1, function(_) {
	var server = new mongodb.Server(testEndPoint.datasets.test.hostname, testEndPoint.datasets.test.port, {});
	var db = new mongodb.Db(testEndPoint.datasets.test.database, server, {});
	db = db.open(_);
	db.dropDatabase(_);
	//trace("dropping admin db");
	var db = new mongodb.Db("mongodb_admin_test", server, {});
	db = db.open(_);
	db.dropDatabase(_);
	ok(true, "mongodb initialized");
	
	start();
});

//start syracuse server
var syracuse;
// wait server initialization
asyncTest("initialize syracuse test server", 1, function(_) {
	syracuse = require('syracuse-main/lib/syracuse');
	syracuse.initializerStatus.on("initialized", function() {
		ok(true, "server initialized");
		syracuse.server.listen(null, port);
		start();
	});
});

function getCookie(_, otherBaseUrl, login, pass) {
	var response = new streams.httpRequest({
		url: otherBaseUrl != null ? otherBaseUrl + "/syracuse-main/html/main.html" : baseUrl + "/syracuse-main/html/main.html",
		user: login || "guest",
		password: pass || "guest"
	}).end().response(_);
	response.readAll(_);
	strictEqual(response.statusCode, 200, "user authenticated");
	return response.headers["set-cookie"];
}

function get(_, cookie, url, statusCode, headers) {
	var head = {
		cookie: cookie
	}
	headers && forEachKey(headers, function(key, value) {
		head[key] = value;
	});
	var response = streams.httpRequest({
		method: "get",
		url: url.indexOf("http") == 0 ? url : baseUrl + "/soap/qunit/soapTest/test/" + url,
		headers: head
	}).end().response(_);
	strictEqual(response.statusCode, 200, "status verified");
	var resp = response.readAll(_);
	try {
		return JSON.parse(resp);
	} catch (ex) {
		return resp;
	}
}

function checkDefinitions(title, definitions, tns){
	
	strictEqual(definitions.$.name, title, "name verified");
	strictEqual(definitions.$.xmlns, "http://schemas.xmlsoap.org/wsdl/", "xmlns verified");
	strictEqual(definitions.$["xmlns:soap"], "http://schemas.xmlsoap.org/wsdl/soap/", "xmlns:soap verified");
	strictEqual(definitions.$["xmlns:xs"], "http://www.w3.org/2001/XMLSchema", "xmlns:xs verified");
	strictEqual(definitions.$["xmlns:tns"], tns, "xmlns:tns verified");
	strictEqual(definitions.$.targetNamespace, tns, "targetNamespace verified");


}

function checkMessages(title, messages){
	
	function checkMessage(message, expected){
		strictEqual(message.$.name, expected, "Message name [" + expected + "] ok");
		strictEqual(message.part.$.name, "parameters", "Message part name ok");
		strictEqual(message.part.$.element, "tns:" + expected, "Message part element [" + "tns:" + expected + "] ok");
	}
	strictEqual(messages.length, 10, "Messages count ok");
	
	checkMessage(messages[0], "create" + title + "Request");
	checkMessage(messages[1], "create" + title + "Response");
	checkMessage(messages[2], "read" + title + "Request");
	checkMessage(messages[3], "read" + title + "Response");
	checkMessage(messages[4], "update" + title + "Request");
	checkMessage(messages[5], "update" + title + "Response");
	checkMessage(messages[6], "delete" + title + "Request");
	checkMessage(messages[7], "delete" + title + "Response");
	checkMessage(messages[8], "list" + title + "Request");
	checkMessage(messages[9], "list" + title + "Response");
}

function checkPortType(title, portType){
	
	function checkOperation(operation, expected){
		strictEqual(operation.$.name, expected, "PortType operation name [" + expected + "] ok");
		strictEqual(operation.input.$.message, "tns:"+expected+"Request", "PortType operation input ok");
		strictEqual(operation.output.$.message, "tns:"+expected+"Response", "PortType operation output ok");
	}
	strictEqual(portType.$.name, title + "SoapType", "PortType name ["+portType.$.name+"] ok");
	strictEqual(portType.operation.length, 5, "PortType operations count ok");

	checkOperation(portType.operation[0], "create" + title);
	checkOperation(portType.operation[1], "read" + title);
	checkOperation(portType.operation[2], "update" + title);
	checkOperation(portType.operation[3], "delete" + title);
	checkOperation(portType.operation[4], "list" + title);
}

function checkBinding(title, binding){
	
	function checkOperation(operation, expected){
		strictEqual(operation.$.name, expected, "Binding operation name [" + expected + "] ok");
		strictEqual(operation["soap:operation"].$.soapAction, expected, "Binding operation soapAction [" + expected + "] ok");
		strictEqual(operation["soap:operation"].$.style, "document", "Binding operation style ok");
		strictEqual(operation.input["soap:body"].$.use, "literal", "Binding operation input ok");
		strictEqual(operation.output["soap:body"].$.use, "literal", "Binding operation output ok");
	}
	strictEqual(binding.$.name, title + "SoapBinding", "Binding name ["+binding.$.name+"] ok");
	strictEqual(binding.$.type, "tns:" + title + "SoapType", "Binding type ["+binding.$.type+"] ok");
	strictEqual(binding["soap:binding"].$.style, "document", "SOAP Binding style ok");
	strictEqual(binding["soap:binding"].$.transport, "http://schemas.xmlsoap.org/soap/http", "SOAP Binding transport ok");
	strictEqual(binding.operation.length, 5, "Binding operations count ok");

	checkOperation(binding.operation[0], "create" + title);
	checkOperation(binding.operation[1], "read" + title);
	checkOperation(binding.operation[2], "update" + title);
	checkOperation(binding.operation[3], "delete" + title);
	checkOperation(binding.operation[4], "list" + title);
}


function checkService(title, url, service){

	strictEqual(service.$.name, title, "Service name ["+title+"] ok");
	strictEqual(service.port.$.name, title + "Soap", "Service port name ["+service.port.$.name+"] ok");
	strictEqual(service.port.$.binding, "tns:" + title + "SoapBinding", "Service port binding ["+service.port.$.binding+"] ok");
	strictEqual(service.port["soap:address"].$.location, url, "Service location ["+url+"] ok");
}


function checkRequiredElements(title, elements){
	function checkElement(element, expected){
		strictEqual(element.$.name, expected, "Element name ["+element.$.name+"] ok");
		strictEqual(element.$.type, "tns:" + expected, "Element type ["+element.$.type+"] ok");
	}
	strictEqual(elements.length, 10, "Elements count ok");
	
	checkElement(elements[0], "create" + title + "Request");
	checkElement(elements[1], "create" + title + "Response");
	checkElement(elements[2], "read" + title + "Request");
	checkElement(elements[3], "read" + title + "Response");
	checkElement(elements[4], "update" + title + "Request");
	checkElement(elements[5], "update" + title + "Response");
	checkElement(elements[6], "delete" + title + "Request");
	checkElement(elements[7], "delete" + title + "Response");
	checkElement(elements[8], "list" + title + "Request");
	checkElement(elements[9], "list" + title + "Response");
}


function checkRequiredComplexTypes(entityName, complexTypes, prototype){
	
	function checkComplexType(complexType){

		var name = complexType.$.name;
		var element = complexType["xs:sequence"]["xs:element"];

		if (name.indexOf("read") === 0){
			if (name.indexOf("Request") !== -1){
				strictEqual(element[0].$.name, "_key", "ComplexType element[0] name ["+element[0].$.name+"] ok");

				strictEqual(element[0].$.type, "xs:string", "ComplexType element[0] type ["+element[0].$.type+"] ok");
				strictEqual(element[1].$.name, "_binary", "ComplexType element[1] name ["+element[1].$.name+"] ok");
				strictEqual(element[1].$.default, "false", "ComplexType element[1] default ok");
				strictEqual(element[1].$.type, "xs:boolean", "ComplexType element[1] type ["+element[1].$.type+"] ok");
			}else if (name.indexOf("Response") !== -1){
				strictEqual(element.$.name, entityName, "ComplexType element[0] name ["+element.$.name+"] ok");
				strictEqual(element.$.type, "tns:" + entityName + "--type", "ComplexType element[0] type ["+element.$.type+"] ok");
			}
		}

		else if (name.indexOf("create") === 0 || name.indexOf("update") === 0){
			if (name.indexOf("Request") !== -1){
				strictEqual(element.$.name, entityName, "ComplexType element name ["+element.$.name+"] ok");

				strictEqual(element.$.type, "tns:" + entityName + "--type", "ComplexType element type ["+element.$.type+"] ok");
			}else if (name.indexOf("Response") !== -1){
				strictEqual(element.$.name, "_key", "ComplexType element name ["+element.$.name+"] ok");

				strictEqual(element.$.type, "xs:string", "ComplexType element type ["+element.$.type+"] ok");
			}
		}

		else if (name.indexOf("delete") === 0){
			if (name.indexOf("Request") !== -1){
				strictEqual(element.$.name, "_key", "ComplexType element name ["+element.$.name+"] ok");

				strictEqual(element.$.type, "xs:string", "ComplexType element type ["+element.$.type+"] ok");
			}else if (name.indexOf("Response") !== -1){
				strictEqual(element.$.name, "deleted", "ComplexType element name ["+element.$.name+"] ok");
				strictEqual(element.$.type, "xs:boolean", "ComplexType element type ["+element.$.type+"] ok");
			}
		}

		else if (name.indexOf("list") === 0){
			if (name.indexOf("Request") !== -1){
				
				strictEqual(element[0].$.name, "_binary", "ComplexType element name ["+element[0].$.name+"] ok");
				strictEqual(element[0].$.default, "false", "ComplexType element default ok");
				strictEqual(element[0].$.type, "xs:boolean", "ComplexType element type ["+element[0].$.type+"] ok");
				strictEqual(element[1].$.name, "_startIndex", "ComplexType element name ["+element[1].$.name+"] ok");
				strictEqual(element[1].$.default, "1", "ComplexType element default ok");
				strictEqual(element[1].$.type, "xs:integer", "ComplexType element type ["+element[1].$.type+"] ok");
				strictEqual(element[2].$.name, "_count", "ComplexType element name ["+element[2].$.name+"] ok");
				strictEqual(element[2].$.default, "20", "ComplexType element default ok");
				strictEqual(element[2].$.type, "xs:integer", "ComplexType element type ["+element[2].$.type+"] ok");
				strictEqual(element[3].$.name, "_sdataWhere", "ComplexType element name ["+element[3].$.name+"] ok");
				strictEqual(element[3].$.type, "xs:string", "ComplexType element type ["+element[3].$.type+"] ok");
				strictEqual(element[4].$.name, "_orderBy", "ComplexType element name ["+element[4].$.name+"] ok");
				strictEqual(element[4].$.type, "tns:orderBy--list", "ComplexType element type ["+element[4].$.type+"] ok");
			}else if (name.indexOf("Response") !== -1){
				strictEqual(element[0].$.name, "_startIndex", "ComplexType element name ["+element[0].$.name+"] ok");
				strictEqual(element[0].$.type, "xs:integer", "ComplexType element type ["+element[0].$.type+"] ok");
				strictEqual(element[1].$.name, "_itemsPerPage", "ComplexType element name ["+element[1].$.name+"] ok");
				strictEqual(element[1].$.type, "xs:integer", "ComplexType element type ["+element[1].$.type+"] ok");
				strictEqual(element[2].$.name, "_totalResults", "ComplexType element name ["+element[2].$.name+"] ok");
				strictEqual(element[2].$.type, "xs:integer", "ComplexType element type ["+element[2].$.type+"] ok");
				strictEqual(element[3].$.name, entityName + "List", "ComplexType element name ["+element[3].$.name+"] ok");
				strictEqual(element[3].$.type, "tns:" + entityName + "--list", "ComplexType element type ["+element[3].$.type+"] ok");
			}
		}
		
		else if (name.indexOf("orderBy") === 0){
			if (name.indexOf("--type") !== -1){
				strictEqual(element[0].$.name, "_binding", "ComplexType element name ["+element[0].$.name+"] ok");
				strictEqual(element[0].$.type, "xs:string", "ComplexType element type ["+element[0].$.type+"] ok");
				strictEqual(element[1].$.name, "_descending", "ComplexType element name ["+element[1].$.name+"] ok");
				strictEqual(element[1].$.type, "xs:boolean", "ComplexType element type ["+element[1].$.type+"] ok");
				strictEqual(element[1].$.default, "false", "ComplexType default ok");
			}else if (name.indexOf("--list") !== -1){
				strictEqual(element.$.name, "orderBy", "ComplexType element name ["+element.$.name+"] ok");
				strictEqual(element.$.type, "tns:orderBy--type", "ComplexType element type ["+element.$.type+"] ok");
				strictEqual(element.$.minOccurs, "0", "ComplexType element minOccurs ["+element.$.minOccurs+"] ok");
				strictEqual(element.$.maxOccurs, "unbounded", "ComplexType element maxOccurs ["+element.$.maxOccurs+"] ok");
			}
		}

	}

	var title = entityName.charAt(0).toUpperCase() + entityName.slice(1);
	
	for (var cp in complexTypes){
		checkComplexType(complexTypes[cp]);
	}

}

// 57 tests
function checkTypes(entityName, schema, prototype, tns){
	strictEqual(schema.$.elementFormDefault, "qualified", "Schema elementFormDefault ok");
	strictEqual(schema.$.targetNamespace, tns, "Schema targetNamespace ok");
	
	var title = entityName.charAt(0).toUpperCase() + entityName.slice(1);
	
	strictEqual(isValidSchema(entityName, schema), true, "Schema is valid ok");
	checkRequiredElements(title, schema["xs:element"]);
	checkRequiredComplexTypes(entityName, schema["xs:complexType"], prototype);
	
}


function isValidSchema(entityName, schema){
	
	function alreadySearched(name){
		for (var key in cpSearched){
			if (name === cpSearched[key]){
				//trace("Already searched !");
				return true;
			}
		}
		return false;
	}
	
	function checkSimpleType(name){

		if (!alreadySearched(name)){
			//trace("---------------------------------");
			//trace("! Search simpleType ["+name+"]");
			cpSearched.push(name);
			for (var sp in simpleTypes){
				if (!Array.isArray(simpleTypes)){
					sp = simpleTypes;
				}else{
					sp = simpleTypes[sp];
				}
				if (sp.$.name === name){
					//trace(" - SimpleType ["+name+"] found");
					//trace("---------------------------------");
					return true;
				}
			}
			//trace("---------------------------------");
			return false;
		}else{
			return true;
		}
	}
	function checkComplexType(name){

		if (!alreadySearched(name)){
			//trace("---------------------------------");
			//trace("! Search complexType ["+name+"]");
			cpSearched.push(name);
			var valid = true,
				found = false;
			for (var cp in complexTypes){
				if (!Array.isArray(complexTypes)){
					cp = complexTypes;
				}else{
					cp = complexTypes[cp];
				}
				if (cp.$.name === name){
					found = true;
					//trace(" - ComplexType ["+name+"] found");
					var elements = cp["xs:sequence"]["xs:element"];
					for (var elt in elements){
						if (!Array.isArray(elements)){
							elt = elements;
						}else{
							elt = elements[elt];
						}
						//trace("! Check element ["+elt.$.name+"]");
						if (elt.$.type.indexOf("tns:") === 0){
							valid = checkComplexType(elt.$.type.substring(4));
							if (!valid)
								valid = checkSimpleType(elt.$.type.substring(4));
							if (!valid)
								return false;
						}else if (elt.$.type.indexOf("xs:") === 0){
							//trace(" - OK");
							// DO NOTHING
						}else{
							//trace("### INVALID SCHEMA ###");
							// SCHEMA INVALID
							return false;
						}
					}
				}
			}
			//trace("---------------------------------");
			return (found && valid);
		}else{
			return false;
		}
	}
	try{
		var cpSearched = [];
		var complexTypes = schema["xs:complexType"];
		var simpleTypes = schema["xs:simpleType"];
		return checkComplexType(entityName + "--type");
	}catch(e){
		console.error("ERROR: "+e.stack);
	}
}

function executeCompleteTest(entityName, baseHostUrl, baseDatasetUrl){

	var title = entityName.charAt(0).toUpperCase() + entityName.slice(1),
		protoUrl, 
		serviceUrl,
		prototype, 
		wsdl,
		plural,
		tns;
	
	if (baseDatasetUrl){
		var parts = baseDatasetUrl.split('/');
		tns = parts[1] + "." + parts[2] + "." + parts[3];
	}else{
		tns = "qunit.soapTest.test";
	}
	/*
	 * BEGIN TESTS
	 */
	asyncTest(entityName+": Get prototype", 2, function(_){
		try{
			if (baseHostUrl && baseDatasetUrl){
				protoUrl = baseHostUrl+ "/sdata" + baseDatasetUrl + "$prototypes('" + entityName + ".$edit')";
			}else{
				protoUrl = baseUrl + "/sdata/qunit/soapTest/test/$prototypes('" + entityName + ".$edit')";
			}
			cookie = getCookie(_, baseHostUrl);
			prototype = get(_, cookie, protoUrl, 200, {accept: "application/json"});
			//tracer("PROTOTYPE="+util.inspect(prototype));
			plural = prototype.$pluralType;
		} catch(e){
			console.error(e.stack);
		} 	
		start();
	});
	
	asyncTest(entityName+": WSDL Generation", 2, function(_){
		try{
			var entity =  plural != null ? plural : entityName;
			if (baseHostUrl && baseDatasetUrl){
				serviceUrl = baseHostUrl+ "/soap" + baseDatasetUrl + entity;
			}else{
				serviceUrl = baseUrl + "/soap/qunit/soapTest/test/" + entity;
			}
			cookie = getCookie(_, baseHostUrl);
			wsdl = get(_, cookie, serviceUrl + "?wsdl");
			//tracer("WSDL="+util.inspect(wsdl));
			wsdl = jsxml.parse(wsdl);
		} catch(e){
			console.error(e.stack);
		} 	
		start();
	});
	
	asyncTest(entityName+": Check definitions", 6, function(_){
		try{
			checkDefinitions(title, wsdl.definitions, tns);
		} catch(e){
			console.error(e.stack);
		} 	
		start();
	});
	
	asyncTest(entityName+": Check messages", 31, function(_){
		try{
			checkMessages(title, wsdl.definitions.message);
		} catch(e){
			console.error(e.stack);
		} 	
		start();
	});
	
	asyncTest(entityName+": Check portType", 17, function(_){
		try{
			checkPortType(title, wsdl.definitions.portType);
		} catch(e){
			console.error(e.stack);
		} 	
		start();
	});
	
	asyncTest(entityName+": Check binding", 30, function(_){
		try{
			checkBinding(title, wsdl.definitions.binding);
		} catch(e){
			console.error(e.stack);
		} 	
		start();
	});
	
	asyncTest(entityName+": Check service", 4, function(_){
		try{
			checkService(title, serviceUrl, wsdl.definitions.service);
		} catch(e){
			console.error(e.stack);
		} 	
		start();
	});
	
	asyncTest(entityName+": Check types", 73, function(_){
		try{
			checkTypes(entityName, wsdl.definitions.types["xs:schema"], prototype.$, tns);
		} catch(e){
			console.error(e.stack);
		} 	
		start();
	});
	
}


executeCompleteTest("string");
executeCompleteTest("bool");
executeCompleteTest("integer");
executeCompleteTest("real");
executeCompleteTest("datetime");
executeCompleteTest("date");
executeCompleteTest("time");
executeCompleteTest("uuid");
executeCompleteTest("json");
executeCompleteTest("parent");
executeCompleteTest("child");
executeCompleteTest("other");

executeCompleteTest("group", "http://localhost:8124", "/syracuse/collaboration/syracuse/");
executeCompleteTest("user", "http://localhost:8124", "/syracuse/collaboration/syracuse/");
executeCompleteTest("endPoint", "http://localhost:8124", "/syracuse/collaboration/syracuse/");
executeCompleteTest("document", "http://localhost:8124", "/syracuse/collaboration/syracuse/");
executeCompleteTest("ATABLE", "http://ecchambard-001:8124", "/x3/erp/SUPERV/");


asyncTest("stop  tests", 0, function(_) {
	doStop = true;
	start();
});