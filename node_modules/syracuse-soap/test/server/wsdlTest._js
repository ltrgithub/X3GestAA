"use strict";

var jsxml = require('jsxml'),
	wsdlGenerator = require('syracuse-soap/lib/server/wsdlGenerator'),
	soapUtils = require('syracuse-soap/lib/common/soapUtils'),
	qmodule = QUnit.module;
var util = require("util");
var baseUrl = "http://localhost:3004"
var port = 3004;
var helpers = require('syracuse-core/lib/helpers');
var types = require('syracuse-core/lib/types/allTypes');
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var mongodb = require("mongodb");
var adminTestFixtures = require("syracuse-collaboration/test/fixtures/adminTestFixtures");
var streams = require('streamline/lib/streams/streams');

var tracer = console.log;
//var tracer = null;

//force basic auth
config.session = config.session || {};
config.session.auth = "basic";

var endPoint = adminTestFixtures.modifyCollaborationEndpoint("mongodb_admin_test");

var testData = require('syracuse-sdata/test/fixtures/testDB');
var testEndPoint = testData.endpoint;
// Replace contract name
testEndPoint.contract.contract = "soapTest";

testEndPoint.datasets = {
	test: {
		driver: "mongodb",
		database: "test",
		hostname: "localhost",
		port: 27017
	}
};

config.sdata.endpoints.push(testEndPoint);

var cookie;

var doStop = false;
qmodule("wsdl-generator", {
	setup: function() {},
	teardown: function() {
		if (doStop) {
			//syracuse.server.close();
			setTimeout(function() {
				process.kill(process.pid);
			}, 100)
		}
	}
});

asyncTest("init database", 1, function(_) {
	var server = new mongodb.Server(testEndPoint.datasets.test.hostname, testEndPoint.datasets.test.port, {});
	var db = new mongodb.Db(testEndPoint.datasets.test.database, server, {});
	db = db.open(_);
	db.dropDatabase(_);
	tracer("dropping admin db");
	var db = new mongodb.Db("mongodb_admin_test", server, {});
	db = db.open(_);
	db.dropDatabase(_);
	ok(true, "mongodb initialized");
	
	start();
});

//start syracuse server
var syracuse;
// wait server initialization
asyncTest("initialize syracuse test server", 1, function(_) {
	syracuse = require('syracuse-main/lib/syracuse');
	syracuse.initializerStatus.on("initialized", function() {
		ok(true, "server initialized");
		syracuse.server.listen(null, port);
		start();
	});
});


// 1 test
function getCookie(_, otherBaseUrl, login, pass) {
	var response = new streams.httpRequest({
		url: otherBaseUrl != null ? otherBaseUrl + "/syracuse-main/html/main.html" : baseUrl + "/syracuse-main/html/main.html",
		user: login || "guest",
		password: pass || "guest"
	}).end().response(_);
	response.readAll(_);
	strictEqual(response.statusCode, 200, "user authenticated");
	return response.headers["set-cookie"];
}


// 1 test
function get(_, cookie, url, statusCode, headers) {
	var head = {
		cookie: cookie
	}
	headers && forEachKey(headers, function(key, value) {
		head[key] = value;
	});
	var response = streams.httpRequest({
		method: "get",
		url: url.indexOf("http") == 0 ? url : baseUrl + "/soap/qunit/soapTest/test/" + url,
		headers: head
	}).end().response(_);
	strictEqual(response.statusCode, statusCode || 200, "status verified");
	var resp = response.readAll(_);
	try {
		return JSON.parse(resp);
	} catch (ex) {
		return resp;
	}
}




// 6 tests
function checkDefinitions(title, definitions, tns){
	
	strictEqual(definitions.$.name, title, "name verified");
	strictEqual(definitions.$.xmlns, "http://schemas.xmlsoap.org/wsdl/", "xmlns verified");
	strictEqual(definitions.$["xmlns:soap"], "http://schemas.xmlsoap.org/wsdl/soap/", "xmlns:soap verified");
	strictEqual(definitions.$["xmlns:xs"], "http://www.w3.org/2001/XMLSchema", "xmlns:xs verified");
	strictEqual(definitions.$["xmlns:tns"], tns, "xmlns:tns verified");
	strictEqual(definitions.$.targetNamespace, tns, "targetNamespace verified");


}

// 31 tests
function checkMessages(title, messages){
	
	function checkMessage(message, expected){
		strictEqual(message.$.name, expected, "Message name [" + expected + "] ok");
		strictEqual(message.part.$.name, "parameters", "Message part name ok");
		strictEqual(message.part.$.element, "tns:" + expected, "Message part element [" + "tns:" + expected + "] ok");
	}
	strictEqual(messages.length, 10, "Messages count ok");
	
	checkMessage(messages[0], "create" + title + "Request");
	checkMessage(messages[1], "create" + title + "Response");
	checkMessage(messages[2], "read" + title + "Request");
	checkMessage(messages[3], "read" + title + "Response");
	checkMessage(messages[4], "update" + title + "Request");
	checkMessage(messages[5], "update" + title + "Response");
	checkMessage(messages[6], "delete" + title + "Request");
	checkMessage(messages[7], "delete" + title + "Response");
	checkMessage(messages[8], "list" + title + "Request");
	checkMessage(messages[9], "list" + title + "Response");
}


// 17 tests
function checkPortType(title, portType){
	
	function checkOperation(operation, expected){
		strictEqual(operation.$.name, expected, "PortType operation name [" + expected + "] ok");
		strictEqual(operation.input.$.message, "tns:"+expected+"Request", "PortType operation input ok");
		strictEqual(operation.output.$.message, "tns:"+expected+"Response", "PortType operation output ok");
	}
	strictEqual(portType.$.name, title + "SoapType", "PortType name ["+portType.$.name+"] ok");
	strictEqual(portType.operation.length, 5, "PortType operations count ok");

	checkOperation(portType.operation[0], "create" + title);
	checkOperation(portType.operation[1], "read" + title);
	checkOperation(portType.operation[2], "update" + title);
	checkOperation(portType.operation[3], "delete" + title);
	checkOperation(portType.operation[4], "list" + title);
}

// 30 tests
function checkBinding(title, binding){
	
	function checkOperation(operation, expected){
		strictEqual(operation.$.name, expected, "Binding operation name [" + expected + "] ok");
		strictEqual(operation["soap:operation"].$.soapAction, expected, "Binding operation soapAction [" + expected + "] ok");
		strictEqual(operation["soap:operation"].$.style, "document", "Binding operation style ok");
		strictEqual(operation.input["soap:body"].$.use, "literal", "Binding operation input ok");
		strictEqual(operation.output["soap:body"].$.use, "literal", "Binding operation output ok");
	}
	strictEqual(binding.$.name, title + "SoapBinding", "Binding name ["+binding.$.name+"] ok");
	strictEqual(binding.$.type, "tns:" + title + "SoapType", "Binding type ["+binding.$.type+"] ok");
	strictEqual(binding["soap:binding"].$.style, "document", "SOAP Binding style ok");
	strictEqual(binding["soap:binding"].$.transport, "http://schemas.xmlsoap.org/soap/http", "SOAP Binding transport ok");
	strictEqual(binding.operation.length, 5, "Binding operations count ok");

	checkOperation(binding.operation[0], "create" + title);
	checkOperation(binding.operation[1], "read" + title);
	checkOperation(binding.operation[2], "update" + title);
	checkOperation(binding.operation[3], "delete" + title);
	checkOperation(binding.operation[4], "list" + title);
}

// 4 tests
function checkService(title, url, service){

	strictEqual(service.$.name, title, "Service name ["+title+"] ok");
	strictEqual(service.port.$.name, title + "Soap", "Service port name ["+service.port.$.name+"] ok");
	strictEqual(service.port.$.binding, "tns:" + title + "SoapBinding", "Service port binding ["+service.port.$.binding+"] ok");
	strictEqual(service.port["soap:address"].$.location, url, "Service location ["+url+"] ok");
}

// 21 tests
function checkRequiredElements(title, elements){
	function checkElement(element, expected){
		strictEqual(element.$.name, expected, "Element name ["+element.$.name+"] ok");
		strictEqual(element.$.type, "tns:" + expected, "Element type ["+element.$.type+"] ok");
	}
	strictEqual(elements.length, 10, "Elements count ok");
	
	checkElement(elements[0], "create" + title + "Request");
	checkElement(elements[1], "create" + title + "Response");
	checkElement(elements[2], "read" + title + "Request");
	checkElement(elements[3], "read" + title + "Response");
	checkElement(elements[4], "update" + title + "Request");
	checkElement(elements[5], "update" + title + "Response");
	checkElement(elements[6], "delete" + title + "Request");
	checkElement(elements[7], "delete" + title + "Response");
	checkElement(elements[8], "list" + title + "Request");
	checkElement(elements[9], "list" + title + "Response");
}


// 34 tests
function checkRequiredComplexTypes(entityName, complexTypes, prototype){
	
	function checkComplexType(complexType){

		var name = complexType.$.name;
		var element = complexType["xs:sequence"]["xs:element"];

		// 8 tests
		if (name.indexOf("read") === 0){
			if (name.indexOf("Request") !== -1){
				strictEqual(element[0].$.name, "_key", "ComplexType element[0] name ["+element[0].$.name+"] ok");
				strictEqual(element[0].$.minOccurs, "1", "ComplexType element[0] minOccurs ok");
				strictEqual(element[0].$.type, "xs:string", "ComplexType element[0] type ["+element[0].$.type+"] ok");
				strictEqual(element[1].$.name, "_binary", "ComplexType element[1] name ["+element[1].$.name+"] ok");
				strictEqual(element[1].$.default, "false", "ComplexType element[1] default ok");
				strictEqual(element[1].$.type, "xs:boolean", "ComplexType element[1] type ["+element[1].$.type+"] ok");
			}else if (name.indexOf("Response") !== -1){
				strictEqual(element.$.name, entityName, "ComplexType element[0] name ["+element.$.name+"] ok");
				strictEqual(element.$.type, "tns:" + entityName, "ComplexType element[0] type ["+element.$.type+"] ok");
			}
		}
		// 2 x 6 tests
		else if (name.indexOf("create") === 0 || name.indexOf("update") === 0){
			if (name.indexOf("Request") !== -1){
				strictEqual(element.$.name, entityName, "ComplexType element name ["+element.$.name+"] ok");
				strictEqual(element.$.minOccurs, "1", "ComplexType element minOccurs ok");
				strictEqual(element.$.type, "tns:" + entityName, "ComplexType element type ["+element.$.type+"] ok");
			}else if (name.indexOf("Response") !== -1){
				strictEqual(element.$.name, "_key", "ComplexType element name ["+element.$.name+"] ok");
				strictEqual(element.$.minOccurs, "1", "ComplexType element minOccurs ok");
				strictEqual(element.$.type, "xs:string", "ComplexType element type ["+element.$.type+"] ok");
			}
		}
		// 5 tests
		else if (name.indexOf("delete") === 0){
			if (name.indexOf("Request") !== -1){
				strictEqual(element.$.name, "_key", "ComplexType element name ["+element.$.name+"] ok");
				strictEqual(element.$.minOccurs, "1", "ComplexType element minOccurs ok");
				strictEqual(element.$.type, "xs:string", "ComplexType element type ["+element.$.type+"] ok");
			}else if (name.indexOf("Response") !== -1){
				strictEqual(element.$.name, "deleted", "ComplexType element name ["+element.$.name+"] ok");
				strictEqual(element.$.type, "xs:boolean", "ComplexType element type ["+element.$.type+"] ok");
			}
		}
		// 7 tests
		else if (name.indexOf("list") === 0){
			if (name.indexOf("Request") !== -1){
				strictEqual(element.$.name, "_binary", "ComplexType element name ["+element.$.name+"] ok");
				strictEqual(element.$.default, "false", "ComplexType element default ok");
				strictEqual(element.$.type, "xs:boolean", "ComplexType element type ["+element.$.type+"] ok");
			}else if (name.indexOf("Response") !== -1){
				strictEqual(element.$.name, "ArrayOf" + title, "ComplexType element name ["+element.$.name+"] ok");
				strictEqual(element.$.minOccurs, "0", "ComplexType element minOccurs ok");
				strictEqual(element.$.maxOccurs, "unbounded", "ComplexType element maxOccurs ok");
				strictEqual(element.$.type, "tns:ArrayOf" + title, "ComplexType element type ["+element.$.type+"] ok");
			}
		}
		// 2 tests
		else if (name === "ArrayOf" + title){
			strictEqual(element.$.name, entityName, "ComplexType element name ["+element.$.name+"] ok");
			strictEqual(element.$.type, "tns:" + entityName, "ComplexType element type ["+element.$.type+"] ok");
		}
	}

	var title = entityName.charAt(0).toUpperCase() + entityName.slice(1);
	
	for (var cp in complexTypes){
		checkComplexType(complexTypes[cp]);
	}

}

// 57 tests
function checkTypes(entityName, schema, prototype, tns){
	strictEqual(schema.$.elementFormDefault, "qualified", "Schema elementFormDefault ok");
	strictEqual(schema.$.targetNamespace, tns, "Schema targetNamespace ok");
	
	var title = entityName.charAt(0).toUpperCase() + entityName.slice(1);
	
	strictEqual(isValidSchema(entityName, schema), true, "Schema is valid ok");
	checkRequiredElements(title, schema["xs:element"]);
	checkRequiredComplexTypes(entityName, schema["xs:complexType"], prototype);
	
}


function isValidSchema(entityName, schema){
	
	
	function checkSimpleType(name){
		//tracer("---------------------------------");
		//tracer("! Search simpleType ["+name+"]");
		for (var sp in simpleTypes){
			if (!Array.isArray(simpleTypes)){
				sp = simpleTypes;
			}else{
				sp = simpleTypes[sp];
			}
			if (sp.$.name === name){
				//tracer(" - SimpleType ["+name+"] found");
				//tracer("---------------------------------");
				return true;
			}
		}
		//tracer("---------------------------------");
		return false;
	}
	function checkComplexType(name){
		//tracer("---------------------------------");
		//tracer("! Search complexType ["+name+"]");
		var valid = true,
			found = false;
		for (var cp in complexTypes){
			if (!Array.isArray(complexTypes)){
				cp = complexTypes;
			}else{
				cp = complexTypes[cp];
			}
			if (cp.$.name === name){
				found = true;
				//tracer(" - ComplexType ["+name+"] found");
				var elements = cp["xs:sequence"]["xs:element"];
				for (var elt in elements){
					if (!Array.isArray(elements)){
						elt = elements;
					}else{
						elt = elements[elt];
					}
					//tracer("! Check element ["+elt.$.name+"]");
					if (elt.$.type.indexOf("tns:") === 0){
						valid = checkComplexType(elt.$.type.substring(4));
						if (!valid)
							valid = checkSimpleType(elt.$.type.substring(4));
						if (!valid)
							return false;
					}else if (elt.$.type.indexOf("xs:") === 0){
						//tracer(" - OK");
						// DO NOTHING
					}else{
						//tracer("### INVALID SCHEMA ###");
						// SCHEMA INVALID
						return false;
					}
				}
			}
		}
		//tracer("---------------------------------");
		return (found && valid);
	}
	
	var complexTypes = schema["xs:complexType"];
	var simpleTypes = schema["xs:simpleType"];
	return checkComplexType(entityName);
}

function executeCompleteTest(entityName, baseHostUrl, baseDatasetUrl){

	var title = entityName.charAt(0).toUpperCase() + entityName.slice(1),
		protoUrl, 
		serviceUrl,
		prototype, 
		wsdl,
		plural,
		tns;
	
	if (baseDatasetUrl){
		var parts = baseDatasetUrl.split('/');
		tns = parts[1] + "." + parts[2] + "." + parts[3];
	}else{
		tns = "qunit.soapTest.test";
	}
	/*
	 * BEGIN TESTS
	 */
	asyncTest(entityName+": Get prototype", 2, function(_){
		try{
			if (baseHostUrl && baseDatasetUrl){
				protoUrl = baseHostUrl+ "/sdata" + baseDatasetUrl + "$prototypes('" + entityName + ".$edit')";
			}else{
				protoUrl = baseUrl + "/sdata/qunit/soapTest/test/$prototypes('" + entityName + ".$edit')";
			}
			cookie = getCookie(_, baseHostUrl);
			prototype = get(_, cookie, protoUrl);
			//tracer("PROTOTYPE="+util.inspect(prototype));
			plural = prototype.$pluralType;
		} catch(e){
			console.error(e.stack);
		} 	
		start();
	});
	
	asyncTest(entityName+": WSDL Generation", 2, function(_){
		try{
			if (baseHostUrl && baseDatasetUrl){
				serviceUrl = baseHostUrl+ "/soap" + baseDatasetUrl + plural;
			}else{
				serviceUrl = baseUrl + "/soap/qunit/soapTest/test/" + plural;
			}
			cookie = getCookie(_, baseHostUrl);
			wsdl = get(_, cookie, serviceUrl + "?wsdl");
			//tracer("WSDL="+util.inspect(wsdl));
			wsdl = jsxml.parse(wsdl);
		} catch(e){
			console.error(e.stack);
		} 	
		start();
	});
	
	asyncTest(entityName+": Check definitions", 6, function(_){
		try{
			checkDefinitions(title, wsdl.definitions, tns);
		} catch(e){
			console.error(e.stack);
		} 	
		start();
	});
	
	asyncTest(entityName+": Check messages", 31, function(_){
		try{
			checkMessages(title, wsdl.definitions.message);
		} catch(e){
			console.error(e.stack);
		} 	
		start();
	});
	
	asyncTest(entityName+": Check portType", 17, function(_){
		try{
			checkPortType(title, wsdl.definitions.portType);
		} catch(e){
			console.error(e.stack);
		} 	
		start();
	});
	
	asyncTest(entityName+": Check binding", 30, function(_){
		try{
			checkBinding(title, wsdl.definitions.binding);
		} catch(e){
			console.error(e.stack);
		} 	
		start();
	});
	
	asyncTest(entityName+": Check service", 4, function(_){
		try{
			checkService(title, serviceUrl, wsdl.definitions.service);
		} catch(e){
			console.error(e.stack);
		} 	
		start();
	});
	
	asyncTest(entityName+": Check types", 58, function(_){
		try{
			checkTypes(entityName, wsdl.definitions.types["xs:schema"], prototype.$, tns);
		} catch(e){
			console.error(e.stack);
		} 	
		start();
	});
	
}

executeCompleteTest("group", "http://localhost:8124", "/syracuse/collaboration/syracuse/");
executeCompleteTest("user", "http://localhost:8124", "/syracuse/collaboration/syracuse/");
executeCompleteTest("endPoint", "http://localhost:8124", "/syracuse/collaboration/syracuse/");
executeCompleteTest("document", "http://localhost:8124", "/syracuse/collaboration/syracuse/");
executeCompleteTest("string");
executeCompleteTest("bool");
executeCompleteTest("integer");
executeCompleteTest("real");
executeCompleteTest("datetime");
executeCompleteTest("date");
executeCompleteTest("time");
executeCompleteTest("uuid");
executeCompleteTest("json");
executeCompleteTest("parent");
executeCompleteTest("child");
executeCompleteTest("other");




asyncTest("stop  tests", 0, function(_) {
	doStop = true;
	start();
});