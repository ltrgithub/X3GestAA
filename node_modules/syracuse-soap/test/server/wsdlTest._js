"use strict";
/* jshint -W079 */
/* jshint unused: false */
/* global QUnit: false, ok: false, asyncTest: false, test: false, strictEqual: false, same: false, start: false, stop: false */

var util = require("util");
var config = require('config'); // must be first syracuse require
var port = (config.unit_test && config.unit_test.serverPort) || 3004;
var baseUrl = "http://localhost:" + port;
var helpers = require('@sage/syracuse-core').helpers;
var types = require('@sage/syracuse-core').types;
var mongodb = require('mongodb');
var adminHelper = require("syracuse-collaboration/lib/helpers").AdminHelper;
var testAdmin = require('@sage/syracuse-core').apis.get('test-admin');
var ez = require('ez-streams');
var forEachKey = helpers.object.forEachKey;
var jsxml = require('js-xml');
var wsdlGenerator = require('syracuse-soap/lib/server/wsdlGenerator');

var syrEntities = require('syracuse-collaboration/lib/contract').contract.entities;

var tracer; // = console.log;

//force basic auth
config.session = config.session || {};
config.session.auth = "basic";
//no integration server
config.integrationServer = null;

var endPoint = testAdmin.modifyCollaborationEndpoint("mongodb_admin_test");

var testData = require('syracuse-sdata/test/fixtures/testDB');
var testEndPoint = testData.endpoint;
// Replace application and contract name

testEndPoint.datasets = {
	test: {
		driver: "mongodb",
		database: "test",
		hostname: "localhost",
		port: config.collaboration.port || 27017
	}
};

config.sdata.endpoints.push(testEndPoint);

var cookie;

QUnit.module(module.id);

asyncTest("init database", 1, function(_) {
	var server = new mongodb.Server(testEndPoint.datasets.test.hostname, testEndPoint.datasets.test.port, {});
	var db = testAdmin.newMongoDb(testEndPoint.datasets.test.database, server, {});
	db = db.open(_);
	db.dropDatabase(_);
	tracer && tracer("dropping admin db");
	server = new mongodb.Server(testEndPoint.datasets.test.hostname, testEndPoint.datasets.test.port, {});
	db = testAdmin.newMongoDb("mongodb_admin_test", server, {});
	db = db.open(_);
	db.dropDatabase(_);
	ok(true, "mongodb initialized");

	start();
});

//start syracuse server
asyncTest("initialize syracuse test server", 1, function(_) {
	require('syracuse-main/lib/syracuse').startServers(_, port);
	ok(true, "server initialized");
	start();
});

function getCookie(_, otherBaseUrl, login, pass) {
	var response = new ez.devices.http.client({
		url: otherBaseUrl != null ? otherBaseUrl + "/syracuse-main/html/main.html" : baseUrl + "/syracuse-main/html/main.html",
		user: login || "guest",
		password: pass || "guest"
	}).end().response(_);
	response.readAll(_);
	strictEqual(response.statusCode, 200, "user authenticated");
	return response.headers["set-cookie"];
}

function get(_, cookie, url, statusCode, headers) {
	var head = {
		cookie: cookie,
		accept: "application/json"
	};
	headers && forEachKey(headers, function(key, value) {
		head[key] = value;
	});
	url = url.indexOf("http") === 0 ? url : baseUrl + "/sdata/qunit/sdataTest/test/" + url;
	var response = ez.devices.http.client({
		method: "get",
		url: url,
		headers: head
	}).end().response(_);

	if (statusCode) strictEqual(response.statusCode, statusCode, "status verified");

	var resp = response.readAll(_);
	if (response.statusCode !== (statusCode || 200)) {
		tracer && tracer("GET Request URL: " + url);
		tracer && tracer("Bad response: " + JSON.stringify(resp, null, 2));
	}
	try {
		return JSON.parse(resp);
	} catch (ex) {
		return resp;
	}
}

function post(_, cookie, url, data, statusCode, adminUrl) {
	url = url.indexOf("http") === 0 ? url : baseUrl + "/sdata/qunit/sdataTest/test/" + url;
	var response = ez.devices.http.client({
		method: "post",
		url: url,
		headers: {
			"content-type": "application/json",
			cookie: cookie,
			accept: "application/json"
		}
	}).end(JSON.stringify(data)).response(_);

	if (statusCode) strictEqual(response.statusCode, statusCode, "status verified");

	var content = response.readAll(_);
	var resp;
	try {
		resp = JSON.parse(content);
	} catch (e) {
		tracer && tracer("Error while parsing: " + content);
	}
	if (response.statusCode !== (statusCode || 201)) {
		tracer && tracer("POST Request URL: " + url + "\nData: " + JSON.stringify(data, null, 2));
		tracer && tracer("Bad response: " + JSON.stringify(resp, null, 2));
	}
	return resp;
}

function put(_, cookie, url, data, statusCode) {
	url = url.indexOf("http") === 0 ? url : baseUrl + "/sdata/qunit/sdataTest/test/" + url;
	var response = ez.devices.http.client({
		method: "put",
		url: url,
		headers: {
			"content-type": "application/json",
			cookie: cookie,
			accept: "application/json"
		}
	}).end(JSON.stringify(data)).response(_);

	if (statusCode) strictEqual(response.statusCode, statusCode, "status verified");

	var resp = JSON.parse(response.readAll(_));
	if (response.statusCode !== (statusCode || 200)) {
		tracer && tracer("PUT Request URL: " + url + "\nData: " + JSON.stringify(data, null, 2));
		tracer && tracer("Bad response: " + JSON.stringify(resp, null, 2));
	}
	return resp;
}

var appUuid = {},
	endpointUuid = {},
	x3serverUuid, x3UserEndpoint;

function addApplication(_, cookie, url, application, contract) {

	var appBody;

	if (!appUuid[application]) {

		appBody = get(_, cookie, url + "applications?sdataWhere=(application eq '" + application + "' and contract eq '" + contract + "')");
		if (appBody.$resources && appBody.$resources[0] && appBody.$resources[0].$uuid) {
			appUuid[application] = appBody.$resources[0].$uuid;
			ok(true, "Application already exists");
		} else {
			// Create Application
			appBody = post(_, cookie, url + "applications", {
				description: "SOAP Unit tests application for " + application.toUpperCase(),
				protocol: application !== "x3" ? "syracuse" : "x3",
				application: application,
				contract: contract
			});
			//tracer && tracer("appBody="+JSON.stringify(appBody,null,2));
			appUuid[application] = appBody.$uuid;
			ok(true, "Set Application");
		}
	} else {
		ok(true, "Application already set");

	}
}

function addEndpoint(_, cookie, url, application, contract, dataset) {

	var endpointBody;

	if (!endpointUuid[application]) {

		endpointBody = get(_, cookie, url + "endPoints?sdataWhere=(application eq '" + application + "' and contract eq '" + contract + "' and dataset eq '" + dataset + "')");
		if (endpointBody.$resources && endpointBody.$resources[0] && endpointBody.$resources[0].$uuid) {
			endpointUuid[application] = endpointBody.$resources[0].$uuid;
			ok(true, "Endpoint already exists");
		} else {
			var endPointData = {
				description: "SOAP Unit tests endpoint for " + application.toUpperCase(),
				application: application,
				contract: contract,
				dataset: dataset,
				enableSearch: false,
				databaseDriver: "mongodb",
				databaseHost: "localhost",
				databasePort: config.collaboration.port || 27017,
				applicationRef: {
					$uuid: appUuid[application]
				}
			};

			if (application === "x3") {
				addX3Server(_, cookie, url);
				endPointData.x3server = {
					$uuid: x3serverUuid
				};
				endPointData.x3ServerFolder = "SUPERV";

			}

			// Create Endpoint
			endpointBody = post(_, cookie, url + "endPoints", endPointData);
			if (application === "x3") {
				addX3UserEndpoint(_, cookie, url, endpointBody.$uuid);
			}

			endpointUuid[application] = endpointBody.$uuid;
			ok(true, "Set Endpoint");
		}
	} else {
		ok(true, "Endpoint already set");
	}
}

function addX3Server(_, cookie, url) {

	if (!x3serverUuid) {

		var x3serverBody = post(_, cookie, url + "x3servers", {
			description: "172.28.16.106",
			serverName: null,
			serverHost: "172.28.16.106",
			serverPort: 17000,
			serverTimeout: 60000,
			webServerPort: 80
		});
		x3serverUuid = x3serverBody.$uuid;

	}
}

function addX3UserEndpoint(_, cookie, url, epUuid) {

	if (!x3UserEndpoint) {
		var guestUuid;
		var guestBody = get(_, cookie, url + "users?sdataWhere=(login eq 'guest')");
		if (guestBody.$resources && guestBody.$resources[0] && guestBody.$resources[0].$uuid) {
			guestUuid = guestBody.$resources[0].$uuid;
		} else {
			throw new Error("User 'guest' not found");
		}

		var epBody = put(_, cookie, url + "users('" + guestUuid + "')", {
			endpoints: [{
				login: "TC",
				endpoint: {
					$uuid: epUuid
				}

			}]
		});
		//tracer && tracer("BODY="+JSON.stringify(epBody,null,2));
		x3UserEndpoint = epBody.$uuid;

	}
}

function addWebService(_, cookie, application, contract, dataset, name, description, representations) {

	var url = baseUrl + "/sdata/syracuse/collaboration/mongodb_admin_test/";

	addApplication(_, cookie, url, application, contract);
	addEndpoint(_, cookie, url, application, contract, dataset);

	var reps = [];
	for (var rep in representations) {
		var representation = representations[rep];

		// Create soapRepresentations
		var repBody = post(_, cookie, url + "soapRepresentations", {
			name: representation.name,
			title: representation.title,
			entityName: representation.entityName
		});
		strictEqual(repBody.name, representation.name, "representation name test roundtrip");
		strictEqual(repBody.title, representation.title, "representation title test roundtrip");
		reps.push(repBody);
	}

	var trackingId = helpers.uuid.generate();
	// Create soapWebService working copy
	var wcBody = post(_, cookie, url + "soapWebServices/$template/$workingCopies?representation=soapWebService.$edit&trackingId=" + trackingId, {});

	var wsBody = put(_, cookie, url + "$workingCopies('" + trackingId + "')?representation=soapWebService.$edit", {
		$uuid: wcBody.$uuid,
		name: name,
		description: description,
		application: {
			$uuid: appUuid[application]
		},
		endpoint: {
			$uuid: endpointUuid[application]
		},
		representations: reps,
		$etag: wcBody.$etag
	});
	//tracer && tracer("wsBody="+JSON.stringify(wsBody,null,2));

	var savBody = put(_, cookie, url + "$workingCopies('" + trackingId + "')?representation=soapWebService.$edit", {
		$uuid: wcBody.$uuid,
		$actions: {
			$save: {
				$isRequested: true
			}
		},
		$etag: wsBody.$etag
	});

	strictEqual(savBody.name, name, "web service name test roundtrip");
	strictEqual(savBody.description, description, "web service description test roundtrip");

	//tracer && tracer("savBody="+JSON.stringify(savBody,null,2));
}

function executeCompleteTest(entityName, representation, baseDatasetUrl) {

	function checkDefinitions(title, definitions, tns) {

		strictEqual(definitions.$.name, serviceName, "name verified");
		strictEqual(definitions.$.xmlns, "http://schemas.xmlsoap.org/wsdl/", "xmlns verified");
		strictEqual(definitions.$["xmlns:soap"], "http://schemas.xmlsoap.org/wsdl/soap/", "xmlns:soap verified");
		strictEqual(definitions.$["xmlns:xs"], "http://www.w3.org/2001/XMLSchema", "xmlns:xs verified");
		strictEqual(definitions.$["xmlns:tns"], tns, "xmlns:tns verified");
		strictEqual(definitions.$.targetNamespace, tns, "targetNamespace verified");

	}

	function checkMessages(title, messages) {

		function checkMessage(message, expected) {
			strictEqual(message.$.name, expected, "Message name [" + expected + "] ok");
			strictEqual(message.part.$.name, "parameters", "Message part name ok");
			strictEqual(message.part.$.element, representation + ":" + expected, "Message part element [" + representation + ":" + expected + "] ok");
		}
		strictEqual(messages.length, 10, "Messages count ok");

		checkMessage(messages[0], "create" + title + "Request");
		checkMessage(messages[1], "create" + title + "Response");
		checkMessage(messages[2], "read" + title + "Request");
		checkMessage(messages[3], "read" + title + "Response");
		checkMessage(messages[4], "update" + title + "Request");
		checkMessage(messages[5], "update" + title + "Response");
		checkMessage(messages[6], "delete" + title + "Request");
		checkMessage(messages[7], "delete" + title + "Response");
		checkMessage(messages[8], "list" + title + "Request");
		checkMessage(messages[9], "list" + title + "Response");
	}

	function checkPortType(title, portType) {

		function checkOperation(operation, expected) {
			strictEqual(operation.$.name, expected, "PortType operation name [" + expected + "] ok");
			strictEqual(operation.input.$.message, "tns:" + expected + "Request", "PortType operation input ok");
			strictEqual(operation.output.$.message, "tns:" + expected + "Response", "PortType operation output ok");
		}
		strictEqual(portType.$.name, serviceName + "SoapType", "PortType name [" + portType.$.name + "] ok");
		strictEqual(portType.operation.length, 5, "PortType operations count ok");

		checkOperation(portType.operation[0], "create" + title);
		checkOperation(portType.operation[1], "read" + title);
		checkOperation(portType.operation[2], "update" + title);
		checkOperation(portType.operation[3], "delete" + title);
		checkOperation(portType.operation[4], "list" + title);
	}

	function checkBinding(title, binding) {

		function checkOperation(operation, expected) {
			strictEqual(operation.$.name, expected, "Binding operation name [" + expected + "] ok");
			strictEqual(operation["soap:operation"].$.soapAction, expected, "Binding operation soapAction [" + expected + "] ok");
			strictEqual(operation["soap:operation"].$.style, "document", "Binding operation style ok");
			strictEqual(operation.input["soap:body"].$.use, "literal", "Binding operation input ok");
			strictEqual(operation.output["soap:body"].$.use, "literal", "Binding operation output ok");
		}
		strictEqual(binding.$.name, serviceName + "SoapBinding", "Binding name [" + binding.$.name + "] ok");
		strictEqual(binding.$.type, "tns:" + serviceName + "SoapType", "Binding type [" + binding.$.type + "] ok");
		strictEqual(binding["soap:binding"].$.style, "document", "SOAP Binding style ok");
		strictEqual(binding["soap:binding"].$.transport, "http://schemas.xmlsoap.org/soap/http", "SOAP Binding transport ok");
		strictEqual(binding.operation.length, 5, "Binding operations count ok");

		checkOperation(binding.operation[0], "create" + title);
		checkOperation(binding.operation[1], "read" + title);
		checkOperation(binding.operation[2], "update" + title);
		checkOperation(binding.operation[3], "delete" + title);
		checkOperation(binding.operation[4], "list" + title);
	}

	function checkService(title, url, service) {

		strictEqual(service.$.name, serviceName, "Service name [" + title + "] ok");
		strictEqual(service.port.$.name, serviceName + "Soap", "Service port name [" + service.port.$.name + "] ok");
		strictEqual(service.port.$.binding, "tns:" + serviceName + "SoapBinding", "Service port binding [" + service.port.$.binding + "] ok");
		strictEqual(service.port["soap:address"].$.location, url, "Service location [" + url + "] ok");
	}

	function checkRequiredElements(title, elements) {
		function checkElement(element, expected) {
			strictEqual(element.$.name, expected, "Element name [" + element.$.name + "] ok");
			strictEqual(element.$.type, representation + ":" + expected, "Element type [" + element.$.type + "] ok");
		}
		strictEqual(elements.length, 10, "Elements count ok");

		checkElement(elements[0], "create" + title + "Request");
		checkElement(elements[1], "create" + title + "Response");
		checkElement(elements[2], "read" + title + "Request");
		checkElement(elements[3], "read" + title + "Response");
		checkElement(elements[4], "update" + title + "Request");
		checkElement(elements[5], "update" + title + "Response");
		checkElement(elements[6], "delete" + title + "Request");
		checkElement(elements[7], "delete" + title + "Response");
		checkElement(elements[8], "list" + title + "Request");
		checkElement(elements[9], "list" + title + "Response");
	}

	function checkRequiredComplexTypes(entityName, complexTypes, prototype) {

		function checkComplexType(complexType) {

			var name = complexType.$.name;
			var element = complexType["xs:sequence"]["xs:element"];

			if (name.indexOf("read") === 0) {
				if (name.indexOf("Request") !== -1) {
					strictEqual(element[0].$.name, "_key", "ComplexType element[0] name [" + element[0].$.name + "] ok");

					strictEqual(element[0].$.type, "xs:string", "ComplexType element[0] type [" + element[0].$.type + "] ok");
					strictEqual(element[1].$.name, "_binary", "ComplexType element[1] name [" + element[1].$.name + "] ok");
					strictEqual(element[1].$['default'], "false", "ComplexType element[1] default ok");
					strictEqual(element[1].$.type, "xs:boolean", "ComplexType element[1] type [" + element[1].$.type + "] ok");
				} else if (name.indexOf("Response") !== -1) {
					strictEqual(element.$.name, entityName, "ComplexType element[0] name [" + element.$.name + "] ok");
					strictEqual(element.$.type, representation + ":" + entityName + "-details--type", "ComplexType element[0] type [" + element.$.type + "] ok");
				}
			} else if (name.indexOf("create") === 0 || name.indexOf("update") === 0) {
				if (name.indexOf("Request") !== -1) {
					strictEqual(element.$.name, entityName, "ComplexType element name [" + element.$.name + "] ok");

					strictEqual(element.$.type, representation + ":" + entityName + "-edit--type", "ComplexType element type [" + element.$.type + "] ok");
				} else if (name.indexOf("Response") !== -1) {
					strictEqual(element.$.name, "_key", "ComplexType element name [" + element.$.name + "] ok");

					strictEqual(element.$.type, "xs:string", "ComplexType element type [" + element.$.type + "] ok");
				}
			} else if (name.indexOf("delete") === 0) {
				if (name.indexOf("Request") !== -1) {
					strictEqual(element.$.name, "_key", "ComplexType element name [" + element.$.name + "] ok");

					strictEqual(element.$.type, "xs:string", "ComplexType element type [" + element.$.type + "] ok");
				} else if (name.indexOf("Response") !== -1) {
					strictEqual(element.$.name, "deleted", "ComplexType element name [" + element.$.name + "] ok");
					strictEqual(element.$.type, "xs:boolean", "ComplexType element type [" + element.$.type + "] ok");
				}
			} else if (name.indexOf("list") === 0) {
				if (name.indexOf("Request") !== -1) {

					strictEqual(element[0].$.name, "_binary", "ComplexType element name [" + element[0].$.name + "] ok");
					strictEqual(element[0].$['default'], "false", "ComplexType element default ok");
					strictEqual(element[0].$.type, "xs:boolean", "ComplexType element type [" + element[0].$.type + "] ok");
					strictEqual(element[1].$.name, "_count", "ComplexType element name [" + element[1].$.name + "] ok");
					strictEqual(element[1].$['default'], "20", "ComplexType element default ok");
					strictEqual(element[1].$.type, "xs:integer", "ComplexType element type [" + element[1].$.type + "] ok");
					strictEqual(element[2].$.name, "_sdataWhere", "ComplexType element name [" + element[2].$.name + "] ok");
					strictEqual(element[2].$.type, "xs:string", "ComplexType element type [" + element[2].$.type + "] ok");
					strictEqual(element[3].$.name, "_orderBy", "ComplexType element name [" + element[3].$.name + "] ok");
					strictEqual(element[3].$.type, representation + ":orderBy--list", "ComplexType element type [" + element[3].$.type + "] ok");
					strictEqual(element[4].$.name, "_pageInfo", "ComplexType element name [" + element[4].$.name + "] ok");
					strictEqual(element[4].$.type, "xs:string", "ComplexType element type [" + element[4].$.type + "] ok");
				} else if (name.indexOf("Response") !== -1) {
					strictEqual(element[0].$.name, "_itemsPerPage", "ComplexType element name [" + element[0].$.name + "] ok");
					strictEqual(element[0].$.type, "xs:integer", "ComplexType element type [" + element[0].$.type + "] ok");
					strictEqual(element[1].$.name, "_pageInfo", "ComplexType element name [" + element[1].$.name + "] ok");
					strictEqual(element[1].$.type, "xs:string", "ComplexType element type [" + element[1].$.type + "] ok");
					strictEqual(element[2].$.name, "_first", "ComplexType element name [" + element[1].$.name + "] ok");
					strictEqual(element[2].$.type, "xs:string", "ComplexType element type [" + element[1].$.type + "] ok");
					strictEqual(element[3].$.name, "_previous", "ComplexType element name [" + element[1].$.name + "] ok");
					strictEqual(element[3].$.type, "xs:string", "ComplexType element type [" + element[1].$.type + "] ok");
					strictEqual(element[4].$.name, "_next", "ComplexType element name [" + element[1].$.name + "] ok");
					strictEqual(element[4].$.type, "xs:string", "ComplexType element type [" + element[1].$.type + "] ok");
					strictEqual(element[5].$.name, "_last", "ComplexType element name [" + element[1].$.name + "] ok");
					strictEqual(element[5].$.type, "xs:string", "ComplexType element type [" + element[1].$.type + "] ok");
					strictEqual(element[6].$.name, "_totalResults", "ComplexType element name [" + element[2].$.name + "] ok");
					strictEqual(element[6].$.type, "xs:integer", "ComplexType element type [" + element[2].$.type + "] ok");
					strictEqual(element[7].$.name, entityName + "List", "ComplexType element name [" + element[3].$.name + "] ok");
					strictEqual(element[7].$.type, representation + ":" + entityName + "-query--list", "ComplexType element type [" + element[3].$.type + "] ok");
				}
			} else if (name.indexOf("orderBy") === 0) {
				if (name.indexOf("--type") !== -1) {
					strictEqual(element[0].$.name, "_binding", "ComplexType element name [" + element[0].$.name + "] ok");
					strictEqual(element[0].$.type, "xs:string", "ComplexType element type [" + element[0].$.type + "] ok");
					strictEqual(element[1].$.name, "_descending", "ComplexType element name [" + element[1].$.name + "] ok");
					strictEqual(element[1].$.type, "xs:boolean", "ComplexType element type [" + element[1].$.type + "] ok");
					strictEqual(element[1].$['default'], "false", "ComplexType default ok");
				} else if (name.indexOf("--list") !== -1) {
					strictEqual(element.$.name, "orderBy", "ComplexType element name [" + element.$.name + "] ok");
					strictEqual(element.$.type, representation + ":orderBy--type", "ComplexType element type [" + element.$.type + "] ok");
					strictEqual(element.$.minOccurs, "0", "ComplexType element minOccurs [" + element.$.minOccurs + "] ok");
					strictEqual(element.$.maxOccurs, "unbounded", "ComplexType element maxOccurs [" + element.$.maxOccurs + "] ok");
				}
			}

		}

		var title = entityName.charAt(0).toUpperCase() + entityName.slice(1);

		for (var cp in complexTypes) {
			checkComplexType(complexTypes[cp]);
		}

	}

	// 57 tests

	function checkTypes(entityName, schema, prototype, tns) {
		strictEqual(schema.$.elementFormDefault, "qualified", "Schema elementFormDefault ok");
		strictEqual(schema.$.targetNamespace, tns, "Schema targetNamespace ok");

		var title = entityName.charAt(0).toUpperCase() + entityName.slice(1);

		strictEqual(isValidSchema(entityName, schema), true, "Schema is valid ok");
		checkRequiredElements(title, schema["xs:element"]);
		checkRequiredComplexTypes(entityName, schema["xs:complexType"], prototype);

	}

	function isValidSchema(entityName, schema) {

		function alreadySearched(name) {
			for (var key in cpSearched) {
				if (name === cpSearched[key]) {
					tracer && tracer("Already searched !");
					return true;
				}
			}
			return false;
		}

		function checkSimpleType(name) {

			if (!alreadySearched(name)) {
				tracer && tracer("---------------------------------");
				tracer && tracer("! Search simpleType [" + name + "]");
				cpSearched.push(name);
				for (var sp in simpleTypes) {
					if (!Array.isArray(simpleTypes)) {
						sp = simpleTypes;
					} else {
						sp = simpleTypes[sp];
					}
					if (sp.$.name === name) {
						tracer && tracer(" - SimpleType [" + name + "] found");
						tracer && tracer("---------------------------------");
						return true;
					}
				}
				tracer && tracer("---------------------------------");
				return false;
			} else {
				return true;
			}
		}

		function checkComplexType(name) {

			if (!alreadySearched(name)) {
				tracer && tracer("---------------------------------");
				tracer && tracer("! Search complexType [" + name + "]");
				cpSearched.push(name);
				var valid = true,
					found = false;
				for (var cp in complexTypes) {
					if (!Array.isArray(complexTypes)) {
						cp = complexTypes;
					} else {
						cp = complexTypes[cp];
					}
					if (cp.$.name === name) {
						found = true;
						tracer && tracer(" - ComplexType [" + name + "] found");
						var elements = cp["xs:sequence"]["xs:element"];
						for (var elt in elements) {
							if (!Array.isArray(elements)) {
								elt = elements;
							} else {
								elt = elements[elt];
							}
							tracer && tracer("! Check element [" + elt.$.name + "]");
							if (elt.$ && elt.$.type && elt.$.type.indexOf(representation + ":") === 0) {
								valid = checkComplexType(elt.$.type.substring(4));
								if (!valid) valid = checkSimpleType(elt.$.type.substring(4));
								if (!valid) {
									tracer && tracer("Simple type invalid: " + JSON.stringify(elt, null, 2));
									return false;
								}

							} else if (elt.$ && elt.$.type && elt.$.type.indexOf("xs:") === 0) {
								tracer && tracer(" - OK");
								// DO NOTHING
							} else {
								tracer && tracer("### INVALID SCHEMA ###");
								tracer && tracer("Element: '" + elt.$.name + "' has no valid type !");
								// SCHEMA INVALID
								return false;
							}
						}
					}
				}
				tracer && tracer("---------------------------------");
				return (found && valid);
			} else {
				return false;
			}
		}
		try {
			var cpSearched = [];
			var complexTypes = schema["xs:complexType"];
			var simpleTypes = schema["xs:simpleType"];
			var well = checkComplexType(entityName + "-details--type");
			if (well) well = checkComplexType(entityName + "-edit--type");
			if (well) well = checkComplexType(entityName + "-query--type");
			return well;
		} catch (e) {
			console.error("ERROR: " + e.stack);
		}
	}


	/*
	 * BEGIN DECLARATIONS
	 */
	var title = representation.charAt(0).toUpperCase() + representation.slice(1),
		serviceName = representation.charAt(0).toUpperCase() + representation.slice(1),
		protoUrl,
		serviceUrl,
		prototype,
		wsdl,
		plural,
		tns,
		application,
		contract,
		dataset;

	if (baseDatasetUrl) {
		var parts = baseDatasetUrl.split('/');
		application = parts[1];
		contract = parts[2];
		dataset = parts[3];

	} else {
		application = "qunit";
		contract = "sdataTest";
		dataset = "test";
	}
	tns = dataset + "." + contract + "." + application;

	/*
	 * BEGIN TESTS
	 */

	asyncTest(representation + ": Web service creation", 7, function(_) {
		try {

			cookie = getCookie(_, baseUrl);

			addWebService(_, cookie, application, contract, dataset, representation, representation, [{
				name: representation,
				title: representation,
				entityName: entityName
			}]);

		} catch (e) {
			console.error(e.stack);
		}
		start();
	});

	//	
	asyncTest(representation + ": Get prototype", 2, function(_) {
		try {
			if (baseDatasetUrl) {
				protoUrl = baseUrl + "/sdata" + baseDatasetUrl + "$prototypes('" + representation + ".$edit')";
			} else {
				protoUrl = baseUrl + "/sdata/qunit/sdataTest/test/$prototypes('" + representation + ".$edit')";
			}
			cookie = getCookie(_, baseUrl);
			prototype = get(_, cookie, protoUrl, 200, {
				accept: "application/json"
			});
			tracer && tracer("PROTOTYPE=" + util.inspect(prototype));
			plural = prototype.$pluralType;

		} catch (e) {
			console.error(e.stack);
		}
		start();
	});

	asyncTest(representation + ": WSDL Generation", 2, function(_) {
		try {
			if (baseDatasetUrl) {
				serviceUrl = baseUrl + "/soap-ws" + baseDatasetUrl + representation;
			} else {
				serviceUrl = baseUrl + "/soap-ws/" + application + "/" + contract + "/" + dataset + "/" + representation;
			}
			cookie = getCookie(_, baseUrl);
			wsdl = get(_, cookie, serviceUrl + "?wsdl", 200);
			wsdl = jsxml.parse(wsdl);
			//tracer && tracer("WSDL="+JSON.stringify(wsdl,null,2));
		} catch (e) {
			console.error(e.stack);
		}
		start();
	});

	asyncTest(representation + ": Check definitions", 6, function(_) {
		try {
			checkDefinitions(title, wsdl.definitions, tns);
		} catch (e) {
			console.error(e.stack);
		}
		start();
	});

	asyncTest(representation + ": Check messages", 31, function(_) {
		try {
			checkMessages(title, wsdl.definitions.message);
		} catch (e) {
			console.error(e.stack);
		}
		start();
	});

	asyncTest(representation + ": Check portType", 17, function(_) {
		try {
			checkPortType(title, wsdl.definitions.portType);
		} catch (e) {
			console.error(e.stack);
		}
		start();
	});

	asyncTest(representation + ": Check binding", 30, function(_) {
		try {
			checkBinding(title, wsdl.definitions.binding);
		} catch (e) {
			console.error(e.stack);
		}
		start();
	});

	asyncTest(representation + ": Check service", 4, function(_) {
		try {
			checkService(title, serviceUrl, wsdl.definitions.service);
		} catch (e) {
			console.error(e.stack);
		}
		start();
	});

	asyncTest(representation + ": Check types", 80, function(_) {
		try {
			checkTypes(representation, wsdl.definitions.types["xs:schema"], prototype.$, representation + "." + tns);
		} catch (e) {
			console.error(e.stack);
		}
		start();
	});

}
//
// Test entities
//
executeCompleteTest("strings", "string");
executeCompleteTest("bools", "bool");
executeCompleteTest("integers", "integer");
executeCompleteTest("reals", "real");
executeCompleteTest("datetimes", "datetime");
executeCompleteTest("dates", "date");
executeCompleteTest("times", "time");
executeCompleteTest("uuids", "uuid");
executeCompleteTest("jsons", "json");
executeCompleteTest("parents", "parent");
executeCompleteTest("childs", "child");
executeCompleteTest("others", "other");
//
// Collaboration entities
//
executeCompleteTest("groups", "group", "/syracuse/collaboration/mongodb_admin_test/");
executeCompleteTest("users", "user", "/syracuse/collaboration/mongodb_admin_test/");
executeCompleteTest("endPoints", "endPoint", "/syracuse/collaboration/mongodb_admin_test/");
executeCompleteTest("documents", "document", "/syracuse/collaboration/mongodb_admin_test/");
//
// X3 entities
//
//executeCompleteTest("ATABLE", "ATABLE", "/x3/erp/SUPERV/");