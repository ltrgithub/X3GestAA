"use strict";

var jsxml = require('jsxml'),
	wsdlGenerator = require('syracuse-soap/lib/server/wsdlGenerator'),
	qmodule = QUnit.module;
var util = require("util");
var baseUrl = "http://localhost:3004"
var port = 3004;
var helpers = require('syracuse-core/lib/helpers');
var types = require('syracuse-core/lib/types/allTypes');
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var mongodb = require("mongodb");
var adminTestFixtures = require("syracuse-collaboration/test/fixtures/adminTestFixtures");
var streams = require('streamline/lib/streams/streams');

var tracer = console.log;
//var tracer = null;

//force basic auth
config.session = config.session || {};
config.session.auth = "basic";

var endPoint = adminTestFixtures.modifyCollaborationEndpoint("mongodb_admin_test");

var testData = require('syracuse-sdata/test/fixtures/testDB');
var testEndPoint = testData.endpoint;
// Replace contract name
testEndPoint.contract.contract = "soapTest";

testEndPoint.datasets = {
	test: {
		driver: "mongodb",
		database: "test",
		hostname: "localhost",
		port: 27017
	}
};

config.sdata.endpoints.push(testEndPoint);

var cookie;

var doStop = false;
qmodule("soapTest", {
	setup: function() {},
	teardown: function() {
		if (doStop) {
			//syracuse.server.close();
			setTimeout(function() {
				process.kill(process.pid);
			}, 1000)
		}
	}
});

asyncTest("init database", 1, function(_) {
	var server = new mongodb.Server(testEndPoint.datasets.test.hostname, testEndPoint.datasets.test.port, {});
	var db = new mongodb.Db(testEndPoint.datasets.test.database, server, {});
	db = db.open(_);
	db.dropDatabase(_);
	console.log("dropping admin db");
	var db = new mongodb.Db("mongodb_admin_test", server, {});
	db = db.open(_);
	db.dropDatabase(_);
	ok(true, "mongodb initialized");
	
	start();
});

//start syracuse server
var syracuse;
// wait server initialization
asyncTest("initialize syracuse test server", 1, function(_) {
	syracuse = require('syracuse-main/lib/syracuse');
	syracuse.initializerStatus.on("initialized", function() {
		ok(true, "server initialized");
		syracuse.server.listen(null, port);
		start();
	});
});



function getCookie(_, otherBaseUrl, login, pass) {
	var response = new streams.httpRequest({
		url: otherBaseUrl != null ? otherBaseUrl + "/syracuse-main/html/main.html" : baseUrl + "/syracuse-main/html/main.html",
		user: login || "guest",
		password: pass || "guest"
	}).end().response(_);
	response.readAll(_);
	strictEqual(response.statusCode, 200, "user authenticated");
	return response.headers["set-cookie"];
}


function post(_, cookie, url, soapAction, data, statusCode, adminUrl) {
	var response = streams.httpRequest({
		method: "post",
		url: url.indexOf("http") == 0 ? url : baseUrl + "/soap/qunit/soapTest/test/" + url,
		headers: {
			"content-type": "text/xml",
			soapaction: soapAction,
			cookie: cookie
		}
	}).end(data).response(_);
	strictEqual(response.statusCode, statusCode || 200, "status verified");
	return response.readAll(_);
}

function postSoap(_, url, soapAction, data, errorExpected){
	var envelope = {
		"soap:Envelope": {
			$:{
				"xmlns:soap": 'http://schemas.xmlsoap.org/soap/envelope/',
				"xmlns": 'qunit.sdataTest.test'
			},
			"soap:Header": {},
			"soap:Body": {}
		}
	};
	envelope["soap:Envelope"]["soap:Body"] = formatJson(soapAction, data);
	//console.log("\nJSON DATA="+JSON.stringify(envelope, null,2));
	var xmlData = '<?xml version="1.0" encoding="utf-8"?>' +jsxml.stringify(envelope);

	cookie = getCookie(_, baseUrl);
	var result = jsxml.parse(post(_, cookie, url, soapAction, xmlData));
	if (errorExpected){
			if (result["soap:Envelope"]["soap:Body"]["soap:Fault"]){
				//tracer("Fault: "+result["soap:Envelope"]["soap:Body"]["soap:Fault"].faultstring.$value);
				return {fault: result["soap:Envelope"]["soap:Body"]["soap:Fault"].faultstring.$value};
			}else{
				return {fault: null};
			}
	}
	else{
		return result["soap:Envelope"]["soap:Body"][soapAction + "Response"];
	}
	
}

function formatJson(soapAction, json){

	function format(key, obj){
		var formatted;
		if (obj === null){
			formatted = {$: {"xsi:nil": "true"}};
		}else if (typeof obj === 'object'){
			if (Array.isArray(obj)){
				formatted = [];
				for (var i in obj){
					formatted.push(format(subkey, obj[i]));
				}
			}else{
				formatted = {};
				for (var subkey in obj){
					formatted[subkey] = format(subkey, obj[subkey]);
				}
			}
		}else{
			if (obj != null){
				formatted = {$value: obj.toString()};
			}
		}
		return formatted;
	}

	var $array = soapAction.split(/[A-Z][^A-Z]/);
	var method = $array[0]
	var name = soapAction.substring(method.length);
	name = name.charAt(0).toLowerCase() + name.slice(1);
	
	var jsonXml = {};

	jsonXml[soapAction + "Request"] = {};
	jsonXml[soapAction + "Request"][name] = {$: {}};
	
	var obj = {};
	for (var key in json){
		obj[key] = format(key, json[key]);
	}

	if (method === "create" || method === "update"){
		jsonXml[soapAction + "Request"] = {};
		jsonXml[soapAction + "Request"][name] = obj;
	}else if (method === "read" || method === "list" || method === "delete"){
		jsonXml[soapAction + "Request"] = obj;
	}else{
		throw new Error("Operation not allowed.");
	}

	return jsonXml;
}

function count(json){
	var count = 0;
	for (var key in json){
		count++;
	}
	return count;
}

asyncTest("strings", 17, function(_){
	try{

		var body1 = postSoap(_, "strings", "createString", {
			string: "01234567890123456789",
			stringTiny: "01234567890123456789",
			stringNormal: "01234567890123456789",
			string10: "0123456789",
			string100: "01234567890123456789",
			string1000: "01234567890123456789",
			stringNullable1: "01234567890123456789",
			stringNullable2: null
		});
		strictEqual(body1._key != null, true, "result _key [" + body1._key + "] ok");

		var body2 = postSoap(_, "strings", "readString", {_key: body1._key}).string;
		strictEqual(body2._key, body1._key, "result _key [" + body2._key + "] ok");
		strictEqual(body2.string, "01234567890123456789", "string roundtrip");
		strictEqual(body2.stringTiny, "01234567890123456789", "string roundtrip");
		strictEqual(body2.stringNormal, "01234567890123456789", "string roundtrip");
		strictEqual(body2.string10, "0123456789", "string10 roundtrip");
		strictEqual(body2.string100, "01234567890123456789", "string100 roundtrip");
		strictEqual(body2.string1000, "01234567890123456789", "string1000 roundtrip");
		strictEqual(body2.stringNullable1, "01234567890123456789", "stringNullable roundtrip");
		strictEqual(body2.stringNullable2.$["xsi:nil"], "true", "stringNullable  null roundtrip");
		strictEqual(body2.stringDef1, "", "string default empty roundtrip");
		strictEqual(body2.stringDef2, "a'b", "string default non empty roundtrip");
		strictEqual(body2.stringDefNull.$["xsi:nil"], "true", "string default null roundtrip");

		
	} catch(e){
		console.error(e.stack);
	} 	
	start();
});


asyncTest("integers", 22, function(_){
	try{		
		var body1 = postSoap(_, "integers", "createInteger", {
			int1: 0,
			int2: 1,
			intTiny1: 127,
			intTiny2: -128,
			intSmall1: 0x7fff,
			intSmall2: -0x7fff - 1,
			intMedium1: 0x7fffff,
			intMedium2: -0x7fffff - 1,
			intNormal1: 0x7fffffff,
			intNormal2: -0x7fffffff - 1,
			intBig1: 0x003fffffffffffff,
			intBig2: -0x003fffffffffffff - 1,
			intNullable1: 0,
			intNullable2: null
		});
		strictEqual(body1._key != null, true, "result _key [" + body1._key + "] ok");

		var body2 = postSoap(_, "integers", "readInteger", {_key: body1._key}).integer;
		strictEqual(body2.int1, (0).toString(), "integer 0 roundtrip");
		strictEqual(body2.int2, (1).toString(), "integer 1 roundtrip");
		strictEqual(body2.intTiny1, (127).toString(), "integer tiny max roundtrip");
		strictEqual(body2.intTiny2, (-128).toString(), "integer tiny min roundtrip");
		strictEqual(body2.intSmall1, (0x7fff).toString(), "integer small max roundtrip");
		strictEqual(body2.intSmall2, (-0x7fff - 1).toString(), "integer small min roundtrip");
		strictEqual(body2.intMedium1, (0x7fffff).toString(), "integer medium max roundtrip");
		strictEqual(body2.intMedium2, (-0x7fffff - 1).toString(), "integer medium min roundtrip");
		strictEqual(body2.intNormal1, (0x7fffffff).toString(), "integer normal max roundtrip");
		strictEqual(body2.intNormal2, (-0x7fffffff - 1).toString(), "integer normal min roundtrip");
		strictEqual(body2.intBig1, (0x003fffffffffffff).toString(), "integer big max roundtrip");
		strictEqual(body2.intBig2, (-0x003fffffffffffff - 1).toString(), "integer big min roundtrip");
		strictEqual(body2.intNullable1, (0).toString(), "integer nullable 0 roundtrip");
		strictEqual(body2.intNullable2.$["xsi:nil"], "true", "integer null roundtrip");
		strictEqual(body2.intDef1, (0).toString(), "integer default 0 roundtrip");
		strictEqual(body2.intDef2, (1).toString(), "integer default 1 roundtrip");
		strictEqual(body2.intDefNull.$["xsi:nil"], "true", "integer default null roundtrip");

		
	} catch(e){
		console.error(e.stack);
	} 	
	start();
});

asyncTest("reals", 16, function(_){
	try{		

		var body1 = postSoap(_, "reals", "createReal", {
			real1: 0,
			real2: 1,
			realSmall1: 3.40282e38,
			realSmall2: -3.40282e38,
			realNormal1: 1.79769313486231e308,
			realNormal2: -1.79769313486231e308,
			realNullable1: 0,
			realNullable2: null
		});
		strictEqual(body1._key != null, true, "result _key [" + body1._key + "] ok");

		var body2 = postSoap(_, "reals", "readReal", {_key: body1._key}).real;
		strictEqual(body2.real1, (0).toString(), "real 0 roundtrip");
		strictEqual(body2.real2, (1).toString(), "real 1 roundtrip");
		strictEqual(body2.realSmall1, (3.40282e38).toString(), "real small max roundtrip");
		strictEqual(body2.realSmall2, (-3.40282e38).toString(), "real small min roundtrip");
		strictEqual(body2.realNormal1, (1.79769313486231e308).toString(), "real normal max roundtrip");
		strictEqual(body2.realNormal2, (-1.79769313486231e308).toString(), "real normal min roundtrip");
		strictEqual(body2.realNullable1, (0).toString(), "real nullable 0 roundtrip");
		strictEqual(body2.realNullable2.$["xsi:nil"], "true", "real null roundtrip");
		strictEqual(body2.realDef1, (0).toString(), "real default 0 roundtrip");
		strictEqual(body2.realDef2, (1).toString(), "real default 1 roundtrip");
		strictEqual(body2.realDefNull.$["xsi:nil"], "true", "real default null roundtrip");

	} catch(e){
		console.error(e.stack);
	} 	
	start();
});

asyncTest("dateTimes", 12, function(_){
	try{		
		var body1 = postSoap(_, "datetimes", "createDatetime", {
			datetime1: testData.testDateTime,
			datetimeNullable1: testData.testDateTime,
			datetimeNullable2: null
		});
		strictEqual(body1._key != null, true, "result _key [" + body1._key + "] ok");

		var body2 = postSoap(_, "datetimes", "readDatetime", {_key: body1._key}).datetime;
		var datetimeBefore = types.datetime.now(false);
		strictEqual(body2.datetime1, testData.testDateTime, "datetime test roundtrip 1");
		strictEqual(body2.datetimeNullable1, testData.testDateTime, "datetime nullable test roundtrip");
		strictEqual(body2.datetimeNullable2.$["xsi:nil"], "true", "datetime null roundtrip");
		strictEqual(body2.datetimeDef1, testData.testDateTime, "datetime default roundtrip");
		ok(body2.datetimeDefNow >= datetimeBefore.toString(), "datetime default now roundtrip 1");
		ok((body2.datetimeDefNow <= types.datetime.now(false).toString()), "datetime default now roundtrip 2");
		strictEqual(body2.datetimeDefNull.$["xsi:nil"], "true", "datetime default null roundtrip");


	} catch(e){
		console.error(e.stack);
	} 	
	start();
});

asyncTest("dates", 11, function(_){
	try{		

		var body1 = postSoap(_, "dates", "createDate", {
			date1: testData.testDate,
			dateNullable1: testData.testDate,
			dateNullable2: null
		});
		strictEqual(body1._key != null, true, "result _key [" + body1._key + "] ok");

		var body2 = postSoap(_, "dates", "readDate", {_key: body1._key}).date;
		strictEqual(body2.date1, testData.testDate, "date test roundtrip 1");
		strictEqual(body2.dateNullable1, testData.testDate, "date nullable test roundtrip");
		strictEqual(body2.dateNullable2.$["xsi:nil"], "true", "date null roundtrip");
		strictEqual(body2.dateDef1, testData.testDate, "date default roundtrip");
		strictEqual(body2.dateDefToday, types.date.today().toString(), "date def today roundtrip");
		strictEqual(body2.dateDefNull.$["xsi:nil"], "true", "date default null roundtrip");

	} catch(e){
		console.error(e.stack);
	} 	
	start();
});

asyncTest("times", 12, function(_){
	try{		

		var body1 = postSoap(_, "times", "createTime", {
			time1: testData.testTime,
			timeNullable1: testData.testTime,
			timeNullable2: null
		});
		strictEqual(body1._key != null, true, "result _key [" + body1._key + "] ok");

		var body2 = postSoap(_, "times", "readTime", {_key: body1._key}).time;
		var timeBefore = types.time.now();
		strictEqual(body2.time1, testData.testTime, "time test roundtrip");
		strictEqual(body2.timeNullable1, testData.testTime, "time nullable test roundtrip");
		strictEqual(body2.timeNullable2.$["xsi:nil"], "true", "time null roundtrip");
		strictEqual(body2.timeDef1, testData.testTime, "time default roundtrip");
		ok(body2.timeDefNow >= timeBefore.toString(), "time def now roundtrip >=");
		ok(body2.timeDefNow <= types.time.now().toString(), "time def now roundtrip <=");
		strictEqual(body2.timeDefNull.$["xsi:nil"], "true", "time default null roundtrip");

	} catch(e){
		console.error(e.stack);
	} 	
	start();
});

asyncTest("uuids", 11, function(_){
	try{		

		var body1 = postSoap(_, "uuids", "createUuid", {
			uuid1: testData.testUuid,
			uuidNullable1: testData.testUuid,
			uuidNullable2: null
		});
		strictEqual(body1._key != null, true, "result _key [" + body1._key + "] ok");

		var body2 = postSoap(_, "uuids", "readUuid", {_key: body1._key}).uuid;
		strictEqual(body2.uuid1, testData.testUuid, "uuid test roundtrip");
		strictEqual(body2.uuidNullable1, testData.testUuid, "uuid nullable test roundtrip");
		strictEqual(body2.uuidNullable2.$["xsi:nil"], "true", "uuid null roundtrip");
		strictEqual(body2.uuidDef1, testData.testUuid, "uuid default roundtrip");
		strictEqual(body2.uuidDefAuto, testData.testUuid, "uuid def auto roundtrip");
		strictEqual(body2.uuidDefNull.$["xsi:nil"], "true", "uuid default null roundtrip");


	} catch(e){
		console.error(e.stack);
	} 	
	start();
});

asyncTest("jsons", 10, function(_){
	try{		

		var body1 = postSoap(_, "jsons", "createJson", {
			json1: testData.testJson,
			jsonNullable1: testData.testJson,
			jsonNullable2: null
		});
		strictEqual(body1._key != null, true, "result _key [" + body1._key + "] ok");

		var body2 = postSoap(_, "jsons", "readJson", {_key: body1._key}).json;
		same(body2.json1, JSON.stringify(testData.testJson), "json test roundtrip");
		same(body2.jsonNullable1, JSON.stringify(testData.testJson), "json nullable test roundtrip");
		strictEqual(body2.jsonNullable2 && body2.jsonNullable2.$["xsi:nil"] === "true", true, "json null roundtrip");
		same(body2.jsonDef1, JSON.stringify(testData.testJson), "json default roundtrip");
		strictEqual(body2.jsonDefNull && body2.jsonDefNull.$["xsi:nil"] === "true", true, "json default null roundtrip");


	} catch(e){
		console.error(e.stack);
	} 	
	start();
});

asyncTest("parents", 71, function(_){
	try{		

		var body = postSoap(_, "others", "createOther", {
			name: "other1"
		});
		var other1 = body._key;
		strictEqual(body._key != null, true, "result other1 _key [" + other1 + "] ok");

		var body = postSoap(_, "others", "createOther", {
			name: "other2"
		});
		var other2 = body._key;
		strictEqual(body._key != null, true, "result other2 _key [" + other2 + "] ok");
		
		var body = postSoap(_, "refers", "createRefer", {
			name: "ref1"
		});
		var ref1 = body._key;
		strictEqual(body._key != null, true, "result ref1 _key [" + ref1 + "] ok");
		
		var body = postSoap(_, "refers", "createRefer", {
			name: "ref2"
		});
		var ref2 = body._key;
		strictEqual(body._key != null, true, "result ref2 _key [" + ref2 + "] ok");
		
		
		var body = postSoap(_, "associates", "createAssociate", {
			name: "associate1"
		});
		var associate1 = body._key;
		strictEqual(body._key != null, true, "result associate1 _key [" + associate1 + "] ok");
		
		var body = postSoap(_, "associates", "createAssociate", {
			name: "associate2"
		});
		var associate2 = body._key;
		strictEqual(body._key != null, true, "result associate2 _key [" + associate2 + "] ok");
		
		var body = postSoap(_, "associates", "createAssociate", {
			name: "associate3"
		});
		var associate3 = body._key;
		strictEqual(body._key != null, true, "result associate3 _key [" + associate3 + "] ok");
		
		
		var mcuuid = helpers.uuid.generate();
		// CREATE
		var body = postSoap(_, "parents", "createParent", {
			name: "parent1",
			children: { 
				child: [{
					_key: helpers.uuid.generate(),
					name: "child1"
				}, {
					_key: "",
					name: "child2"
				}, {
					_key: helpers.uuid.generate(),
					name: "child3"
				}]
			},
			mandatoryChild: {
				_key: mcuuid,
				name: "mandatoryChild"
			},
			mandatoryRef: {
				_key: ref1
			},
			associates: {
				associate: [{
					_key: associate1
				}, {
					_key: associate2
				}]
			}
			
		});
		var parent = body._key;
		strictEqual(parent != null, true, "result create parent1 _key [" + parent + "] ok");
		
		// READ
		var body = postSoap(_, "parents", "readParent", {_key: parent}).parent;

		strictEqual(body.name, "parent1", "result read parent1 name [" + body.name + "] ok");
		strictEqual(body.children.parent.length, 3, "children length");
		strictEqual(body.children.parent[0].name, "child1", "first child name");
		strictEqual(body.children.parent[1].name, "child2", "second child name");
		strictEqual(body.children.parent[2].name, "child3", "third child name");
		strictEqual(body.mandatoryChild != null, true, "mandatoryChild exists 1");
		strictEqual(body.mandatoryChild.name, "mandatoryChild", "mandatory child name");
		strictEqual(body.mandatoryChild._key, mcuuid, "mandatory child $uuid");
		strictEqual(body.optionalChild.$["xsi:nil"], "true", "optional child is null");
		strictEqual(body.mandatoryRef != null, true, "mandatoryRef exists");
		strictEqual(body.mandatoryRef._key, ref1, "mandatoryRef ok");
		strictEqual(body.optionalRef.$["xsi:nil"], "true", "optionalRef null");
		strictEqual(body.associates != null, true, "associates != null");
		strictEqual(body.associates.associate.length, 2, "associates length 1");
		var gotKeys = body.associates.associate.map(function(elt) {
			return elt._key
		});
		var expectedKeys = [associate1, associate2];
		gotKeys.sort();
		expectedKeys.sort();
		same(gotKeys, expectedKeys, "associates keys ok");
		
		var parentKey = body._key;
		// UPDATE
		var body = postSoap(_, "parents", "updateParent", {
			_key: parentKey,
			name: "parent1",
			children: {
				_deleteMissing: true,
				child: [{
					_key: helpers.uuid.generate(),
					name: "child4"
				}, {
					_key: body.children.parent[1]._key,
				}]
			},
			optionalChild: {
				_key: helpers.uuid.generate(),
				name: "optionalChild"
			},
			optionalRef: {
				_key: ref2
			},
			associates: {
				_deleteMissing: true,
				associate: [{			
					_key: associate3
				}, {
					_key: associate1
				}]
			}

		});
		var parent = body._key;
		strictEqual(parent != null, true, "result update parent1 _key [" + parent + "] ok");
		
		// READ
		var body = postSoap(_, "parents", "readParent", {_key: parent}).parent;
		
		strictEqual(body.name, "parent1", "result read parent1 name [" + body.name + "] ok");
		strictEqual(body.children.parent.length, 2, "children length 2");
		strictEqual(body.children.parent[0].name, "child2", "first child name");
		strictEqual(body.children.parent[1].name, "child4", "second child name");
		strictEqual(body.mandatoryChild != null, true, "mandatoryChild exists 3");
		strictEqual(body.mandatoryChild.name, "mandatoryChild", "mandatory child name");
		strictEqual(body.optionalChild != null, true, "optional child exists");
		strictEqual(body.optionalChild.name, "optionalChild", "optional child name");
		strictEqual(body.mandatoryRef != null, true, "mandatoryRef exists");
		strictEqual(body.mandatoryRef._key, ref1, "mandatoryRef ok");
		strictEqual(body.optionalRef != null, true, "optionalRef exists");
		strictEqual(body.optionalRef._key, ref2, "optionalRef ok");
		
		strictEqual(body.associates.associate.length, 2, "associates length 2");
		var gotKeys = body.associates.associate.map(function(elt) {
			return elt._key
		});
		var expectedKeys = [associate1, associate3];
		gotKeys.sort();
		expectedKeys.sort();
		same(gotKeys, expectedKeys, "associates keys ok");
		

		var parentKey = body._key;
		// UPDATE
		var body = postSoap(_, "parents", "updateParent", {
			_key: parentKey,
			mandatoryRef: {
				_key: ref2
			},
			optionalRef: null
		});
		var parent = body._key;
		strictEqual(parent != null, true, "result update2 parent1 _key [" + parent + "] ok");
		
		
		// READ
		var body = postSoap(_, "parents", "readParent", {_key: parent}).parent;
		strictEqual(body.mandatoryRef != null, true, "mandatoryRef exists");
		strictEqual(body.mandatoryRef._key, ref2, "mandatoryRef ok");
		strictEqual(body.optionalRef.$["xsi:nil"], "true", "optionalRef null");
		
		// create parent without mandatory ref. must fail
		var body = postSoap(_, "parents", "createParent", {
			name: "parent2",
			mandatoryChild: {
				$uuid: mcuuid,
				name: "mandatoryChild"
			}
		}, true);
		strictEqual(body.fault != null, true, "read parent fail ok: fault: "+body.fault);

	} catch(e){
		console.error(e.stack);
	} 	
	start();
});

asyncTest("paging", 27, function(_){

	var body = postSoap(_, "pageds", "createPaged", {
		name: "r1"
	});
	var body = postSoap(_, "pageds", "createPaged", {
		name: "r2"
	});
	var body = postSoap(_, "pageds", "createPaged", {
		name: "r3"
	});
	var body = postSoap(_, "pageds", "listPaged", {_count: "1", _orderBy: {orderBy:{binding: "name"}}});
	strictEqual(body._startIndex, "1", "startIndex ok(1)");
	strictEqual(body._totalResults, "3", "totalResults ok(1)");
	strictEqual(body._itemsPerPage, "1", "itemsPerPage ok");
	strictEqual(count(body.pagedList), 1, "length ok");
	strictEqual(body.pagedList.paged.name, "r1", "name ok");


	var body = postSoap(_, "pageds", "listPaged", {_count: "1", _startIndex: "2", _orderBy: {orderBy:{binding: "name"}}});
	strictEqual(body._startIndex, "2", "startIndex ok(2)");
	strictEqual(body._totalResults, "3", "totalResults ok(2)");
	strictEqual(body._itemsPerPage, "1", "itemsPerPage ok");
	strictEqual(count(body.pagedList), 1, "length ok");
	strictEqual(body.pagedList.paged.name, "r2", "name ok");

	var body = postSoap(_, "pageds", "listPaged", {_count: "3", _startIndex: "1", _orderBy: {orderBy:{_binding: "name",_descending: "true"}}});
	strictEqual(body._startIndex, "1", "startIndex ok(3)");
	strictEqual(body._totalResults, "3", "totalResults ok(3)");
	strictEqual(body._itemsPerPage, "3", "itemsPerPage ok");
	strictEqual(count(body.pagedList.paged), 3, "length ok");
	strictEqual(body.pagedList.paged[0].name, "r3", "name ok");
		
	start();
});
	
asyncTest("delete test", 98, function(_) {

	// create the parent
	var body = postSoap(_, "deleteTestParents", "createDeleteTestParent", {
		name: "testParent"
	});
	var parentId = body._key;
	strictEqual(parentId != null, true, "create parent ok");
	// create refering childs
	body = postSoap(_, "deleteTestRefOnes", "createDeleteTestRefOne", {
		name: "testRefOne", ref: {_key:parentId}
	});
	var refId = body._key;
	strictEqual(refId != null, true, "create child ok");
	ok(true, "delete ref one start");
	// try to delete parent, must get error
	body = postSoap(_, "deleteTestParents", "deleteDeleteTestParent", {
		_key: parentId
	},true);
	strictEqual(body.fault != null, true, "delete parent fail ok: fault: "+body.fault);
	
	// delete refering child
	body = postSoap(_, "deleteTestRefOnes", "deleteDeleteTestRefOne", {
		_key: refId
	});
	strictEqual(body.deleted, "true", "delete refering child ok");
	// delete parent, must succeed
	body = postSoap(_, "deleteTestParents", "deleteDeleteTestParent", {
		_key: parentId
	});
	strictEqual(body.deleted, "true", "delete parent ok");
	//
	ok(true, "delete ref many start");
	// recreate parent
	body = postSoap(_, "deleteTestParents", "createDeleteTestParent", {
		name: "testParent"
	});
	parentId = body._key;
	strictEqual(parentId != null, true, "create parent ok");
	//
	body = postSoap(_, "deleteTestRefManies", "createDeleteTestRefMany", {
		name: "testRefMany", refs: {deleteTestParent: [{_key:parentId}]}
	});
	refId = body._key;
	strictEqual(refId != null, true, "create child ok");
	// try to delete parent, must fail
	body = postSoap(_, "deleteTestParents", "deleteDeleteTestParent", {
		_key: parentId
	},true);
	strictEqual(body.fault != null, true, "delete parent fail ok: fault: "+body.fault);
	// delete refering child
	body = postSoap(_, "deleteTestRefManies", "deleteDeleteTestRefMany", {
		_key: refId
	});
	strictEqual(body.deleted, "true", "delete refering child ok");

	// delete parent, must succeed
	body = postSoap(_, "deleteTestParents", "deleteDeleteTestParent", {
		_key: parentId
	});
	strictEqual(body.deleted, "true", "delete parent ok");
	//
	ok(true, "delete multi ref start");
	// recreate parent
	body = postSoap(_, "deleteTestParents", "createDeleteTestParent", {
		name: "testParent"
	});
	parentId = body._key;
	strictEqual(parentId != null, true, "create parent ok");
	//
	body = postSoap(_, "deleteTestMultiRefes", "createDeleteTestMultiRefe", {
		name: "testRef1", ref1: {_key:parentId}
	});
	var refId1 = body._key;
	strictEqual(refId1 != null, true, "create child 1 ok");
	
	body = postSoap(_, "deleteTestMultiRefes", "createDeleteTestMultiRefe", {
		name: "testRef2", ref2: {_key:parentId}
	});
	var refId2 = body._key;
	strictEqual(refId2 != null, true, "create child 2 ok");
	
	// try to delete parent, must fail
	body = postSoap(_, "deleteTestParents", "deleteDeleteTestParent", {
		_key: parentId
	},true);
	strictEqual(body.fault != null, true, "delete parent fail ok: fault: "+body.fault);
	// delete refering child 1
	body = postSoap(_, "deleteTestMultiRefes", "deleteDeleteTestMultiRefe", {
		_key: refId1
	});
	strictEqual(body.deleted, "true", "delete refering child1 ok");
	// try to delete parent, must fail
	body = postSoap(_, "deleteTestParents", "deleteDeleteTestParent", {
		_key: parentId
	},true);
	strictEqual(body.fault != null, true, "delete parent fail ok: fault: "+body.fault);
	// delete refering child 2
	body = postSoap(_, "deleteTestMultiRefes", "deleteDeleteTestMultiRefe", {
		_key: refId2
	});
	strictEqual(body.deleted, "true", "delete refering child2 ok");
	// delete parent, must succeed
	body = postSoap(_, "deleteTestParents", "deleteDeleteTestParent", {
		_key: parentId
	});
	strictEqual(body.deleted, "true", "delete parent ok");
	
	// cascade delete
	body = postSoap(_, "deleteTestCascadeMasters", "createDeleteTestCascadeMaster", {
		name: "Cascade Master"
	});
	var masterUuid = body._key;
	strictEqual(masterUuid != null, true, "create cascade master ok");
	body = postSoap(_, "deleteTestCascadeDetails", "createDeleteTestCascadeDetail", {
		name: "Cascade Detail 1",
		master: { _key: masterUuid }
	});
	var detail1Uuid = body._key;
	strictEqual(detail1Uuid != null, true, "create cascade details 1 ok");
	body = postSoap(_, "deleteTestCascadeDetails", "createDeleteTestCascadeDetail", {
		name: "Cascade Detail 2"
	});
	var detail2Uuid = body._key;
	strictEqual(detail2Uuid != null, true, "create cascade details 2 ok");
	body = postSoap(_, "deleteTestCascadeMasters", "updateDeleteTestCascadeMaster", {
		_key: masterUuid,
		detailsWoInv: {deleteTestCascadeDetail: [{ _key: detail2Uuid}]}
	});
	// check
	body = postSoap(_, "deleteTestCascadeMasters", "readDeleteTestCascadeMaster", {
		_key: masterUuid
	}).deleteTestCascadeMaster;

	strictEqual(count(body.detailsWInv), 1, "Has detail with inv ok");
	strictEqual(count(body.detailsWoInv), 1, "Has detail w/o inv ok");
	// delete details, must pass
	body = postSoap(_, "deleteTestCascadeDetails", "deleteDeleteTestCascadeDetail", {
		_key: detail1Uuid
	});
	strictEqual(body.deleted, "true", "delete cascade details ok");
	body = postSoap(_, "deleteTestCascadeDetails", "deleteDeleteTestCascadeDetail", {
		_key: detail2Uuid
	});
	strictEqual(body.deleted, "true", "delete cascade details ok");

	// check
	body = postSoap(_, "deleteTestCascadeMasters", "readDeleteTestCascadeMaster", {
		_key: masterUuid
	}).deleteTestCascadeMaster;
	
	ok((!body.detailsWInv || !body.detailsWInv.length), "Del detail with inv ok");
	// This test will fail as if there is no inverse relation is no way (yet) for the relation to be notified of the delete
	ok((!body.detailsWoInv || !body.detailsWoInv.length), "Del detail w/o inv ok");
	// recreate details
	body = postSoap(_, "deleteTestCascadeDetails", "createDeleteTestCascadeDetail", {
		name: "Cascade Detail 1",
		master: { _key: masterUuid }
	});
	var detail1Uuid = body._key;
	strictEqual(detail1Uuid != null, true, "create cascade details 1 ok");

	body = postSoap(_, "deleteTestCascadeMasters", "readDeleteTestCascadeMaster", {
		_key: masterUuid
	}).deleteTestCascadeMaster;

	strictEqual(count(body.detailsWInv), 1, "Has detail with inv ok");
	strictEqual(count(body.detailsWoInv), 1, "Has detail w/o inv ok");
	// delete master, must pass
	body = postSoap(_, "deleteTestCascadeMasters", "deleteDeleteTestCascadeMaster", {
		_key: masterUuid
	});
	strictEqual(body.deleted, "true", "delete cascade master ok");

	// details must not exists
	body = postSoap(_, "deleteTestCascadeDetails", "readDeleteTestCascadeDetail", {
		_key: detail1Uuid
	}).deleteTestCascadeDetail;
	strictEqual(body.$["xsi:nil"], "true", "read deleted cascade details null ok");
	body = postSoap(_, "deleteTestCascadeDetails", "readDeleteTestCascadeDetail", {
		_key: detail2Uuid
	}).deleteTestCascadeDetail;

	strictEqual(body.$["xsi:nil"], "true", "read deleted cascade details null ok");
	
	start();
});

asyncTest("stop  tests", 0, function(_) {
	doStop = true;
	start();
});