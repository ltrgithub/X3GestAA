"use strict";
/* jshint -W079 */
/* jshint unused: false */
/* global QUnit: false, ok: false, asyncTest: false, test: false, strictEqual: false, same: false, start: false, stop: false */

var util = require("util");
var baseUrl = "http://localhost:3004";
var port = 3004;
var helpers = require('syracuse-core/lib/helpers');
var types = require('syracuse-core/lib/types/allTypes');
var config = require('syracuse-main/lib/nodeconfig').config; // must be first syracuse require
var mongodb = require('streamline-mongodb');
var adminTestFixtures = require("syracuse-collaboration/test/fixtures/adminTestFixtures");
var streams = require('streamline/lib/streams/streams');
var forEachKey = helpers.object.forEachKey;

var jsxml = require('jsxml');
var wsdlGenerator = require('syracuse-soap/lib/server/wsdlGenerator');

var tracer; // = console.log;
var application, contract, dataset;

//force basic auth
config.session = config.session || {};
config.session.auth = "basic";
//no integration server
config.integrationServer = null;

var endPoint = adminTestFixtures.modifyCollaborationEndpoint("mongodb_admin_test");

var testData = require('syracuse-sdata/test/fixtures/testDB');
var testEndPoint = testData.endpoint;

testEndPoint.datasets = {
	test: {
		driver: "mongodb",
		database: "test",
		hostname: "localhost",
		port: 27017
	}
};

config.sdata.endpoints.push(testEndPoint);

var cookie;

var doStop = false;
QUnit.module(module.id, {
	setup: function() {},
	teardown: function() {
		if (doStop) {
			setTimeout(function() {
				process.kill(process.pid);
			}, 500);
		}
	}
});

asyncTest("init database", 1, function(_) {
	var server = new mongodb.Server(testEndPoint.datasets.test.hostname, testEndPoint.datasets.test.port, {});
	var db = adminTestFixtures.newMongoDb(testEndPoint.datasets.test.database, server, {});
	db = db.open(_);
	db.dropDatabase(_);
	tracer && tracer("dropping admin db");
	server = new mongodb.Server(testEndPoint.datasets.test.hostname, testEndPoint.datasets.test.port, {});
	db = adminTestFixtures.newMongoDb("mongodb_admin_test", server, {});
	db = db.open(_);
	db.dropDatabase(_);
	ok(true, "mongodb initialized");

	start();
});

//start syracuse server
asyncTest("initialize syracuse test server", 1, function(_) {
	require('syracuse-main/lib/syracuse').startServers(_, port);
	ok(true, "server initialized");
	start();
});

function getCookie(_, otherBaseUrl, login, pass) {
	var response = new streams.httpRequest({
		url: otherBaseUrl != null ? otherBaseUrl + "/syracuse-main/html/main.html" : baseUrl + "/syracuse-main/html/main.html",
		user: login || "guest",
		password: pass || "guest"
	}).end().response(_);
	response.readAll(_);
	strictEqual(response.statusCode, 200, "user authenticated");
	return response.headers["set-cookie"];
}

function get(_, cookie, url, statusCode, headers) {
	var head = {
		cookie: cookie,
		accept: "application/json"
	};
	headers && forEachKey(headers, function(key, value) {
		head[key] = value;
	});
	url = url.indexOf("http") === 0 ? url : baseUrl + "/sdata/qunit/sdataTest/test/" + url;
	var response = streams.httpRequest({
		method: "get",
		url: url,
		headers: head
	}).end().response(_);

	if (statusCode) strictEqual(response.statusCode, statusCode, "status verified");

	var resp = response.readAll(_);
	if (response.statusCode !== (statusCode || 200)) {
		tracer && tracer("GET Request URL: " + url);
		tracer && tracer("Bad response: " + JSON.stringify(resp, null, 2));
	}
	try {
		return JSON.parse(resp);
	} catch (ex) {
		return resp;
	}
}

function post(_, cookie, url, data, statusCode, adminUrl) {
	url = url.indexOf("http") === 0 ? url : baseUrl + "/sdata/qunit/sdataTest/test/" + url;
	var response = streams.httpRequest({
		method: "post",
		url: url,
		headers: {
			"content-type": "application/json",
			cookie: cookie,
			accept: "application/json"
		}
	}).end(JSON.stringify(data)).response(_);

	if (statusCode) strictEqual(response.statusCode, statusCode, "status verified");

	var content = response.readAll(_);
	var resp;
	try {
		resp = JSON.parse(content);
	} catch (e) {
		tracer && tracer("Error while parsing: " + content);
	}
	if (response.statusCode !== (statusCode || 201)) {
		tracer && tracer("POST Request URL: " + url + "\nData: " + JSON.stringify(data, null, 2));
		tracer && tracer("Bad response: " + JSON.stringify(resp, null, 2));
	}
	return resp;
}

function put(_, cookie, url, data, statusCode) {
	url = url.indexOf("http") === 0 ? url : baseUrl + "/sdata/qunit/sdataTest/test/" + url;
	var response = streams.httpRequest({
		method: "put",
		url: url,
		headers: {
			"content-type": "application/json",
			cookie: cookie,
			accept: "application/json"
		}
	}).end(JSON.stringify(data)).response(_);

	if (statusCode) strictEqual(response.statusCode, statusCode, "status verified");

	var resp = JSON.parse(response.readAll(_));
	if (response.statusCode !== (statusCode || 200)) {
		tracer && tracer("PUT Request URL: " + url + "\nData: " + JSON.stringify(data, null, 2));
		tracer && tracer("Bad response: " + JSON.stringify(resp, null, 2));
	}
	return resp;
}

var appUuid = {}, endpointUuid = {}, x3serverUuid, x3UserEndpoint;

function addApplication(_, cookie, url, application, contract) {

	var appBody;

	if (!appUuid[application]) {

		appBody = get(_, cookie, url + "applications?sdataWhere=(application eq '" + application + "' and contract eq '" + contract + "')");
		if (appBody.$resources && appBody.$resources[0] && appBody.$resources[0].$uuid) {
			appUuid[application] = appBody.$resources[0].$uuid;
			ok(true, "Application already exists");
		} else {
			// Create Application
			appBody = post(_, cookie, url + "applications", {
				description: "SOAP Unit tests application for " + application.toUpperCase(),
				protocol: application !== "x3" ? "syracuse" : "x3",
				application: application,
				contract: contract
			});
			//tracer && tracer("appBody="+JSON.stringify(appBody,null,2));
			appUuid[application] = appBody.$uuid;
			ok(true, "Set Application");
		}
	} else {
		ok(true, "Application already set");

	}
}

function addEndpoint(_, cookie, url, application, contract, dataset) {

	var endpointBody;

	if (!endpointUuid[application]) {

		endpointBody = get(_, cookie, url + "endPoints?sdataWhere=(application eq '" + application + "' and contract eq '" + contract + "' and dataset eq '" + dataset + "')");
		if (endpointBody.$resources && endpointBody.$resources[0] && endpointBody.$resources[0].$uuid) {
			endpointUuid[application] = endpointBody.$resources[0].$uuid;
			ok(true, "Endpoint already exists");
		} else {
			var endPointData = {
				description: "SOAP Unit tests endpoint for " + application.toUpperCase(),
				application: application,
				contract: contract,
				dataset: dataset,
				enableSearch: false,
				databaseDriver: "mongodb",
				databaseHost: "localhost",
				databasePort: 27017,
				applicationRef: {
					$uuid: appUuid[application]
				}
			};

			if (application === "x3") {
				addX3Server(_, cookie, url);
				endPointData.x3server = {
					$uuid: x3serverUuid
				};
				endPointData.x3ServerFolder = "SUPERV";

			}

			// Create Endpoint
			endpointBody = post(_, cookie, url + "endPoints", endPointData);
			if (application === "x3") {
				addX3UserEndpoint(_, cookie, url, endpointBody.$uuid);
			}

			endpointUuid[application] = endpointBody.$uuid;
			ok(true, "Set Endpoint");
		}
	} else {
		ok(true, "Endpoint already set");
	}
}

function addX3Server(_, cookie, url) {

	if (!x3serverUuid) {

		var x3serverBody = post(_, cookie, url + "x3servers", {
			description: "172.28.16.106",
			serverName: null,
			serverHost: "172.28.16.106",
			serverPort: 17000,
			serverTimeout: 60000,
			webServerPort: 80
		});
		x3serverUuid = x3serverBody.$uuid;

	}

}

function addX3UserEndpoint(_, cookie, url, epUuid) {

	if (!x3UserEndpoint) {
		var guestUuid;
		var guestBody = get(_, cookie, url + "users?sdataWhere=(login eq 'guest')");
		if (guestBody.$resources && guestBody.$resources[0] && guestBody.$resources[0].$uuid) {
			guestUuid = guestBody.$resources[0].$uuid;
		} else {
			throw new Error("User 'guest' not found");
		}

		var epBody = put(_, cookie, url + "users('" + guestUuid + "')", {
			endpoints: [{
				login: "TC",
				endpoint: {
					$uuid: epUuid
				}
			}]
		});
		//tracer && tracer("BODY="+JSON.stringify(epBody,null,2));
		x3UserEndpoint = epBody.$uuid;

	}
}

function addWebService(_, application, contract, dataset, name, description, representations) {

	var url = baseUrl + "/sdata/syracuse/collaboration/mongodb_admin_test/";
	cookie = getCookie(_, baseUrl);

	addApplication(_, cookie, url, application, contract);
	addEndpoint(_, cookie, url, application, contract, dataset);

	var reps = [];
	for (var rep in representations) {
		var representation = representations[rep];

		// Create soapRepresentations
		var repBody = post(_, cookie, url + "soapRepresentations", {
			name: representation.name,
			title: representation.title,
			entityName: representation.entityName
		});
		strictEqual(repBody.name, representation.name, "representation name test roundtrip");
		strictEqual(repBody.title, representation.title, "representation title test roundtrip");
		reps.push(repBody);
	}

	var trackingId = helpers.uuid.generate();
	// Create soapWebService working copy
	var wcBody = post(_, cookie, url + "soapWebServices/$template/$workingCopies?representation=soapWebService.$edit&trackingId=" + trackingId, {});

	var wsBody = put(_, cookie, url + "$workingCopies('" + trackingId + "')?representation=soapWebService.$edit", {
		$uuid: wcBody.$uuid,
		name: name,
		description: description,
		application: {
			$uuid: appUuid[application]
		},
		endpoint: {
			$uuid: endpointUuid[application]
		},
		representations: reps,
		$etag: wcBody.$etag
	});
	//tracer && tracer("wsBody="+JSON.stringify(wsBody,null,2));

	var savBody = put(_, cookie, url + "$workingCopies('" + trackingId + "')?representation=soapWebService.$edit", {
		$uuid: wcBody.$uuid,
		$actions: {
			$save: {
				$isRequested: true
			}
		},
		$etag: wsBody.$etag
	});
	strictEqual(savBody.name, name, "web service name test roundtrip");
	strictEqual(savBody.description, description, "web service description test roundtrip");
	//tracer && tracer("savBody="+JSON.stringify(savBody,null,2));

}

function postSoap(_, service, soapAction, data, errorExpected) {
	var envelope = {
		"soap:Envelope": {
			$: {
				"xmlns:soap": 'http://schemas.xmlsoap.org/soap/envelope/'
			},
			"soap:Header": {},
			"soap:Body": {}
		}
	};

	var $array = soapAction.split(/[A-Z][^A-Z]/);
	var method = $array[0];
	var name = soapAction.substring(method.length);
	name = name.charAt(0).toLowerCase() + name.slice(1);

	envelope["soap:Envelope"].$["xmlns:" + name] = name + "." + dataset + "." + contract + "." + application;
	envelope["soap:Envelope"]["soap:Body"] = formatJson(soapAction, method, name, data);
	//tracer && tracer("\nJSON DATA="+JSON.stringify(envelope, null,2));
	var xmlData = '<?xml version="1.0" encoding="utf-8"?>' + jsxml.stringify(envelope);

	cookie = getCookie(_, baseUrl);

	var response = streams.httpRequest({
		method: "post",
		url: baseUrl + "/soap-ws/" + application + "/" + contract + "/" + dataset + "/" + service,
		headers: {
			"content-type": "text/xml",
			soapaction: soapAction,
			cookie: cookie
		}
	}).end(xmlData).response(_);

	strictEqual(response.statusCode, 200, "status verified");

	var result = jsxml.parse(response.readAll(_));
	//tracer && tracer("RESULT="+JSON.stringify(result,null,2));
	if (errorExpected) {
		if (result["soap:Envelope"]["soap:Body"]["soap:Fault"]) {
			//tracer("Fault: "+result["soap:Envelope"]["soap:Body"]["soap:Fault"].faultstring.$value);
			return {
				fault: result["soap:Envelope"]["soap:Body"]["soap:Fault"].faultstring.$value.toString()
			};
		} else {
			return {
				fault: null
			};
		}
	} else if (!result["soap:Envelope"]["soap:Body"][soapAction + "Response"]) {
		throw new Error(result["soap:Envelope"]["soap:Body"]["soap:Fault"].faultstring.$value + ": " + result["soap:Envelope"]["soap:Body"]["soap:Fault"].detail.$value);
	} else {
		return result["soap:Envelope"]["soap:Body"][soapAction + "Response"];
	}
}

function formatJson(soapAction, method, name, json) {

	function format(key, obj) {
		var formatted;
		if (obj === null) {
			formatted = {
				$: {
					"xsi:nil": "true"
				}
			};
		} else if (typeof obj === 'object') {
			if (Array.isArray(obj)) {
				formatted = [];
				for (var i in obj) {
					formatted.push(format(subkey, obj[i]));
				}
			} else {
				formatted = {};
				for (var subkey in obj) {
					formatted[subkey] = format(subkey, obj[subkey]);
				}
			}
		} else {
			if (obj != null) {
				formatted = {
					$value: obj.toString()
				};
			}
		}
		return formatted;
	}

	var ns = name;

	var jsonXml = {};

	jsonXml[ns + ":" + soapAction + "Request"] = {};
	jsonXml[ns + ":" + soapAction + "Request"][ns + ":" + name] = {
		$: {}
	};

	var obj = {};
	for (var key in json) {
		obj[ns + ":" + key] = format(key, json[key]);
	}

	if (method === "create" || method === "update") {
		jsonXml[ns + ":" + soapAction + "Request"] = {};
		jsonXml[ns + ":" + soapAction + "Request"][ns + ":" + name] = obj;
	} else if (method === "read" || method === "list" || method === "delete") {
		jsonXml[ns + ":" + soapAction + "Request"] = obj;
	} else {
		throw new Error("Operation not allowed.");
	}

	return jsonXml;
}

function count(json) {
	var cnt = 0;
	for (var key in json) {
		cnt++;
	}
	return cnt;
}

function createWebService(_, entityName, description, representations) {

	var def = [{
		name: description,
		title: description,
		entityName: entityName
	}];

	addWebService(_, application, contract, dataset, entityName, description, representations ? representations : def);
}

application = "qunit";
contract = "sdataTest";
dataset = "test";

//asyncTest("strings", 24, function(_) {
//	try {
//
//		createWebService(_, "testStrings", "string");
//
//		var body1 = postSoap(_, "testStrings", "createString", {
//			string: "01234567890123456789",
//			stringTiny: "01234567890123456789",
//			stringNormal: "01234567890123456789",
//			string10: "0123456789",
//			string100: "01234567890123456789",
//			string1000: "01234567890123456789",
//			stringNullable1: "01234567890123456789",
//			stringNullable2: null
//		});
//		strictEqual(body1._key != null, true, "result _key [" + body1._key + "] ok");
//
//		var body2 = postSoap(_, "testStrings", "readString", {
//			_key: body1._key
//		}).string;
//		strictEqual(body2._key, body1._key, "result _key [" + body2._key + "] ok");
//		strictEqual(body2.string, "01234567890123456789", "string roundtrip");
//		strictEqual(body2.stringTiny, "01234567890123456789", "string roundtrip");
//		strictEqual(body2.stringNormal, "01234567890123456789", "string roundtrip");
//		strictEqual(body2.string10, "0123456789", "string10 roundtrip");
//		strictEqual(body2.string100, "01234567890123456789", "string100 roundtrip");
//		strictEqual(body2.string1000, "01234567890123456789", "string1000 roundtrip");
//		strictEqual(body2.stringNullable1, "01234567890123456789", "stringNullable roundtrip");
//		strictEqual(body2.stringNullable2.$["xsi:nil"], "true", "stringNullable  null roundtrip");
//		strictEqual(body2.stringDef1, "", "string default empty roundtrip");
//		strictEqual(body2.stringDef2, "a'b", "string default non empty roundtrip");
//		strictEqual(body2.stringDefNull.$["xsi:nil"], "true", "string default null roundtrip");
//
//	} catch (e) {
//		console.error(e.stack);
//	}
//	start();
//});
//
//asyncTest("integers", 29, function(_) {
//	try {
//
//		createWebService(_, "testIntegers", "integer");
//		var body1 = postSoap(_, "testIntegers", "createInteger", {
//			int1: 0,
//			int2: 1,
//			intTiny1: 127,
//			intTiny2: -128,
//			intSmall1: 0x7fff,
//			intSmall2: -0x7fff - 1,
//			intMedium1: 0x7fffff,
//			intMedium2: -0x7fffff - 1,
//			intNormal1: 0x7fffffff,
//			intNormal2: -0x7fffffff - 1,
//			intBig1: 0x003fffffffffffff,
//			intBig2: -0x003fffffffffffff - 1,
//			intNullable1: 0,
//			intNullable2: null
//		});
//		strictEqual(body1._key != null, true, "result _key [" + body1._key + "] ok");
//
//		var body2 = postSoap(_, "testIntegers", "readInteger", {
//			_key: body1._key
//		}).integer;
//		strictEqual(body2.int1, (0).toString(), "integer 0 roundtrip");
//		strictEqual(body2.int2, (1).toString(), "integer 1 roundtrip");
//		strictEqual(body2.intTiny1, (127).toString(), "integer tiny max roundtrip");
//		strictEqual(body2.intTiny2, (-128).toString(), "integer tiny min roundtrip");
//		strictEqual(body2.intSmall1, (0x7fff).toString(), "integer small max roundtrip");
//		strictEqual(body2.intSmall2, (-0x7fff - 1).toString(), "integer small min roundtrip");
//		strictEqual(body2.intMedium1, (0x7fffff).toString(), "integer medium max roundtrip");
//		strictEqual(body2.intMedium2, (-0x7fffff - 1).toString(), "integer medium min roundtrip");
//		strictEqual(body2.intNormal1, (0x7fffffff).toString(), "integer normal max roundtrip");
//		strictEqual(body2.intNormal2, (-0x7fffffff - 1).toString(), "integer normal min roundtrip");
//		strictEqual(body2.intBig1, (0x003fffffffffffff).toString(), "integer big max roundtrip");
//		strictEqual(body2.intBig2, (-0x003fffffffffffff - 1).toString(), "integer big min roundtrip");
//		strictEqual(body2.intNullable1, (0).toString(), "integer nullable 0 roundtrip");
//		strictEqual(body2.intNullable2.$["xsi:nil"], "true", "integer null roundtrip");
//		strictEqual(body2.intDef1, (0).toString(), "integer default 0 roundtrip");
//		strictEqual(body2.intDef2, (1).toString(), "integer default 1 roundtrip");
//		strictEqual(body2.intDefNull.$["xsi:nil"], "true", "integer default null roundtrip");
//
//	} catch (e) {
//		console.error(e.stack);
//	}
//	start();
//});
//
//asyncTest("reals", 23, function(_) {
//	try {
//
//		createWebService(_, "testReals", "real");
//
//		var body1 = postSoap(_, "testReals", "createReal", {
//			real1: 0,
//			real2: 1,
//			realSmall1: 3.40282e38,
//			realSmall2: -3.40282e38,
//			realNormal1: 1.79769313486231e308,
//			realNormal2: -1.79769313486231e308,
//			realNullable1: 0,
//			realNullable2: null
//		});
//		strictEqual(body1._key != null, true, "result _key [" + body1._key + "] ok");
//
//		var body2 = postSoap(_, "testReals", "readReal", {
//			_key: body1._key
//		}).real;
//		strictEqual(body2.real1, (0).toString(), "real 0 roundtrip");
//		strictEqual(body2.real2, (1).toString(), "real 1 roundtrip");
//		strictEqual(body2.realSmall1, (3.40282e38).toString(), "real small max roundtrip");
//		strictEqual(body2.realSmall2, (-3.40282e38).toString(), "real small min roundtrip");
//		strictEqual(body2.realNormal1, (1.79769313486231e308).toString(), "real normal max roundtrip");
//		strictEqual(body2.realNormal2, (-1.79769313486231e308).toString(), "real normal min roundtrip");
//		strictEqual(body2.realNullable1, (0).toString(), "real nullable 0 roundtrip");
//		strictEqual(body2.realNullable2.$["xsi:nil"], "true", "real null roundtrip");
//		strictEqual(body2.realDef1, (0).toString(), "real default 0 roundtrip");
//		strictEqual(body2.realDef2, (1).toString(), "real default 1 roundtrip");
//		strictEqual(body2.realDefNull.$["xsi:nil"], "true", "real default null roundtrip");
//
//	} catch (e) {
//		console.error(e.stack);
//	}
//	start();
//});
//
//asyncTest("datetimes", 19, function(_) {
//	try {
//
//		createWebService(_, "testDatetimes", "datetime");
//
//		var body1 = postSoap(_, "testDatetimes", "createDatetime", {
//			datetime1: testData.testDateTime,
//			datetimeNullable1: testData.testDateTime,
//			datetimeNullable2: null
//		});
//		strictEqual(body1._key != null, true, "result _key [" + body1._key + "] ok");
//
//		var body2 = postSoap(_, "testDatetimes", "readDatetime", {
//			_key: body1._key
//		}).datetime;
//		var datetimeBefore = types.datetime.now(false);
//		strictEqual(body2.datetime1, testData.testDateTime, "datetime test roundtrip 1");
//		strictEqual(body2.datetimeNullable1, testData.testDateTime, "datetime nullable test roundtrip");
//		strictEqual(body2.datetimeNullable2.$["xsi:nil"], "true", "datetime null roundtrip");
//		strictEqual(body2.datetimeDef1, testData.testDateTime, "datetime default roundtrip");
//		ok(body2.datetimeDefNow >= datetimeBefore.toString(), "datetime default now roundtrip 1");
//		ok((body2.datetimeDefNow <= types.datetime.now(false).toString()), "datetime default now roundtrip 2");
//		strictEqual(body2.datetimeDefNull.$["xsi:nil"], "true", "datetime default null roundtrip");
//
//	} catch (e) {
//		console.error(e.stack);
//	}
//	start();
//});
//
//asyncTest("dates", 18, function(_) {
//	try {
//
//		createWebService(_, "testDates", "date");
//
//		var body1 = postSoap(_, "testDates", "createDate", {
//			date1: testData.testDate,
//			dateNullable1: testData.testDate,
//			dateNullable2: null
//		});
//		strictEqual(body1._key != null, true, "result _key [" + body1._key + "] ok");
//
//		var body2 = postSoap(_, "testDates", "readDate", {
//			_key: body1._key
//		}).date;
//		strictEqual(body2.date1, testData.testDate, "date test roundtrip 1");
//		strictEqual(body2.dateNullable1, testData.testDate, "date nullable test roundtrip");
//		strictEqual(body2.dateNullable2.$["xsi:nil"], "true", "date null roundtrip");
//		strictEqual(body2.dateDef1, testData.testDate, "date default roundtrip");
//		strictEqual(body2.dateDefToday, types.date.today().toString(), "date def today roundtrip");
//		strictEqual(body2.dateDefNull.$["xsi:nil"], "true", "date default null roundtrip");
//
//	} catch (e) {
//		console.error(e.stack);
//	}
//	start();
//});
//
//asyncTest("times", 19, function(_) {
//	try {
//		createWebService(_, "testTimes", "time");
//		var body1 = postSoap(_, "testTimes", "createTime", {
//			time1: testData.testTime,
//			timeNullable1: testData.testTime,
//			timeNullable2: null
//		});
//		strictEqual(body1._key != null, true, "result _key [" + body1._key + "] ok");
//
//		var body2 = postSoap(_, "testTimes", "readTime", {
//			_key: body1._key
//		}).time;
//		var timeBefore = types.time.now();
//		strictEqual(body2.time1, testData.testTime, "time test roundtrip");
//		strictEqual(body2.timeNullable1, testData.testTime, "time nullable test roundtrip");
//		strictEqual(body2.timeNullable2.$["xsi:nil"], "true", "time null roundtrip");
//		strictEqual(body2.timeDef1, testData.testTime, "time default roundtrip");
//		ok(body2.timeDefNow >= timeBefore.toString(), "time def now roundtrip >=");
//		ok(body2.timeDefNow <= types.time.now().toString(), "time def now roundtrip <=");
//		strictEqual(body2.timeDefNull.$["xsi:nil"], "true", "time default null roundtrip");
//
//	} catch (e) {
//		console.error(e.stack);
//	}
//	start();
//});
//
//asyncTest("uuids", 18, function(_) {
//	try {
//
//		createWebService(_, "testUuids", "uuid");
//		var body1 = postSoap(_, "testUuids", "createUuid", {
//			uuid1: testData.testUuid,
//			uuidNullable1: testData.testUuid,
//			uuidNullable2: null
//		});
//		strictEqual(body1._key != null, true, "result _key [" + body1._key + "] ok");
//
//		var body2 = postSoap(_, "testUuids", "readUuid", {
//			_key: body1._key
//		}).uuid;
//		strictEqual(body2.uuid1, testData.testUuid, "uuid test roundtrip");
//		strictEqual(body2.uuidNullable1, testData.testUuid, "uuid nullable test roundtrip");
//		strictEqual(body2.uuidNullable2.$["xsi:nil"], "true", "uuid null roundtrip");
//		strictEqual(body2.uuidDef1, testData.testUuid, "uuid default roundtrip");
//		strictEqual(body2.uuidDefAuto, testData.testUuid, "uuid def auto roundtrip");
//		strictEqual(body2.uuidDefNull.$["xsi:nil"], "true", "uuid default null roundtrip");
//
//	} catch (e) {
//		console.error(e.stack);
//	}
//	start();
//});
//
//asyncTest("jsons", 17, function(_) {
//	try {
//		createWebService(_, "testJsons", "json");
//		var body1 = postSoap(_, "testJsons", "createJson", {
//			json1: testData.testJson,
//			jsonNullable1: testData.testJson,
//			jsonNullable2: null
//		});
//		strictEqual(body1._key != null, true, "result _key [" + body1._key + "] ok");
//
//		var body2 = postSoap(_, "testJsons", "readJson", {
//			_key: body1._key
//		}).json;
//		same(body2.json1, JSON.stringify(testData.testJson), "json test roundtrip");
//		same(body2.jsonNullable1, JSON.stringify(testData.testJson), "json nullable test roundtrip");
//		strictEqual(body2.jsonNullable2 && body2.jsonNullable2.$["xsi:nil"] === "true", true, "json null roundtrip");
//		same(body2.jsonDef1, JSON.stringify(testData.testJson), "json default roundtrip");
//		strictEqual(body2.jsonDefNull && body2.jsonDefNull.$["xsi:nil"] === "true", true, "json default null roundtrip");
//
//	} catch (e) {
//		console.error(e.stack);
//	}
//	start();
//});
//
//asyncTest("parents", 83, function(_) {
//	try {
//
//		var entities = [{
//			name: "other",
//			title: "other",
//			entityName: "others"
//		}, {
//			name: "refer",
//			title: "refer",
//			entityName: "refers"
//		}, {
//			name: "associate",
//			title: "associate",
//			entityName: "associates"
//		}, {
//			name: "parent",
//			title: "parent",
//			entityName: "parents"
//		}];
//		createWebService(_, "testMultiple", "Multiple entities in same ws", entities);
//
//		var body = postSoap(_, "testMultiple", "createOther", {
//			name: "other1"
//		});
//		var other1 = body._key;
//		strictEqual(body._key != null, true, "result other1 _key [" + other1 + "] ok");
//
//		body = postSoap(_, "testMultiple", "createOther", {
//			name: "other2"
//		});
//		var other2 = body._key;
//		strictEqual(body._key != null, true, "result other2 _key [" + other2 + "] ok");
//
//		body = postSoap(_, "testMultiple", "createRefer", {
//			name: "ref1"
//		});
//		var ref1 = body._key;
//		strictEqual(body._key != null, true, "result ref1 _key [" + ref1 + "] ok");
//
//		body = postSoap(_, "testMultiple", "createRefer", {
//			name: "ref2"
//		});
//		var ref2 = body._key;
//		strictEqual(body._key != null, true, "result ref2 _key [" + ref2 + "] ok");
//
//		body = postSoap(_, "testMultiple", "createAssociate", {
//			name: "associate1"
//		});
//		var associate1 = body._key;
//		strictEqual(body._key != null, true, "result associate1 _key [" + associate1 + "] ok");
//
//		body = postSoap(_, "testMultiple", "createAssociate", {
//			name: "associate2"
//		});
//		var associate2 = body._key;
//		strictEqual(body._key != null, true, "result associate2 _key [" + associate2 + "] ok");
//
//		body = postSoap(_, "testMultiple", "createAssociate", {
//			name: "associate3"
//		});
//		var associate3 = body._key;
//		strictEqual(body._key != null, true, "result associate3 _key [" + associate3 + "] ok");
//
//		var mcuuid = helpers.uuid.generate();
//		// CREATE
//		body = postSoap(_, "testMultiple", "createParent", {
//			name: "parent1",
//			children: {
//				child: [{
//					_key: helpers.uuid.generate(),
//					name: "child1"
//				}, {
//					_key: helpers.uuid.generate(),
//					name: "child2"
//				}, {
//					_key: helpers.uuid.generate(),
//					name: "child3"
//				}]
//			},
//			mandatoryChild: {
//				_key: mcuuid,
//				name: "mandatoryChild"
//			},
//			mandatoryRef: {
//				_key: ref1
//			},
//			associates: {
//				associate: [{
//					_key: associate1
//				}, {
//					_key: associate2
//				}]
//			}
//
//		});
//		var parent = body._key;
//		strictEqual(parent != null, true, "result create parent1 _key [" + parent + "] ok");
//
//		// READ
//		body = postSoap(_, "testMultiple", "readParent", {
//			_key: parent
//		}).parent;
//		strictEqual(body.name, "parent1", "result read parent1 name [" + body.name + "] ok");
//
//		strictEqual(body.children.child.length, 3, "children length");
//		strictEqual(body.children.child[0].name, "child1", "first child name");
//		strictEqual(body.children.child[1].name, "child2", "second child name");
//		strictEqual(body.children.child[2].name, "child3", "third child name");
//		strictEqual(body.mandatoryChild != null, true, "mandatoryChild exists 1");
//		strictEqual(body.mandatoryChild.name, "mandatoryChild", "mandatory child name");
//		strictEqual(body.mandatoryChild._key, mcuuid, "mandatory child $uuid");
//		strictEqual(body.optionalChild.$["xsi:nil"], "true", "optional child is null");
//		strictEqual(body.mandatoryRef != null, true, "mandatoryRef exists");
//		strictEqual(body.mandatoryRef._key, ref1, "mandatoryRef ok");
//		strictEqual(body.optionalRef.$["xsi:nil"], "true", "optionalRef null");
//		strictEqual(body.associates != null, true, "associates != null");
//		strictEqual(body.associates.associate.length, 2, "associates length 1");
//		var gotKeys = body.associates.associate.map(function(elt) {
//			return elt._key;
//		});
//		var expectedKeys = [associate1, associate2];
//		gotKeys.sort();
//		expectedKeys.sort();
//		same(gotKeys, expectedKeys, "associates keys ok");
//
//		var parentKey = body._key;
//
//		// UPDATE
//		body = postSoap(_, "testMultiple", "updateParent", {
//			_key: parentKey,
//			name: "parent1",
//			children: {
//				_deleteMissing: true,
//				child: [{
//					_key: helpers.uuid.generate(),
//					name: "child4"
//				}, {
//					_key: body.children.child[1]._key,
//					name: body.children.child[1].name
//				}]
//			},
//			optionalChild: {
//				_key: helpers.uuid.generate(),
//				name: "optionalChild"
//			},
//			optionalRef: {
//				_key: ref2
//			},
//			associates: {
//				_deleteMissing: true,
//				associate: [{
//					_key: associate3
//				}, {
//					_key: associate1
//				}]
//			}
//
//		});
//
//		parent = body._key;
//		strictEqual(parent != null, true, "result update parent1 _key [" + parent + "] ok");
//
//		// READ
//		body = postSoap(_, "testMultiple", "readParent", {
//			_key: parent
//		}).parent;
//
//		strictEqual(body.name, "parent1", "result read parent1 name [" + body.name + "] ok");
//		strictEqual(body.children.child.length, 2, "children length 2");
//		strictEqual(body.children.child[0].name, "child2", "first child name");
//		strictEqual(body.children.child[1].name, "child4", "second child name");
//		strictEqual(body.mandatoryChild != null, true, "mandatoryChild exists 3");
//		strictEqual(body.mandatoryChild.name, "mandatoryChild", "mandatory child name");
//		strictEqual(body.optionalChild != null, true, "optional child exists");
//		strictEqual(body.optionalChild.name, "optionalChild", "optional child name");
//		strictEqual(body.mandatoryRef != null, true, "mandatoryRef exists");
//		strictEqual(body.mandatoryRef._key, ref1, "mandatoryRef ok");
//		strictEqual(body.optionalRef != null, true, "optionalRef exists");
//		strictEqual(body.optionalRef._key, ref2, "optionalRef ok");
//
//		strictEqual(body.associates.associate.length, 2, "associates length 2");
//		gotKeys = body.associates.associate.map(function(elt) {
//			return elt._key;
//		});
//		expectedKeys = [associate1, associate3];
//		gotKeys.sort();
//		expectedKeys.sort();
//		same(gotKeys, expectedKeys, "associates keys ok");
//
//		parentKey = body._key;
//		// UPDATE
//		body = postSoap(_, "testMultiple", "updateParent", {
//			_key: parentKey,
//			mandatoryRef: {
//				_key: ref2
//			},
//			optionalRef: null
//		});
//		parent = body._key;
//		strictEqual(parent != null, true, "result update2 parent1 _key [" + parent + "] ok");
//
//		// READ
//		body = postSoap(_, "testMultiple", "readParent", {
//			_key: parent
//		}).parent;
//		strictEqual(body.mandatoryRef != null, true, "mandatoryRef exists");
//		strictEqual(body.mandatoryRef._key, ref2, "mandatoryRef ok");
//		strictEqual(body.optionalRef.$["xsi:nil"], "true", "optionalRef null");
//
//		// create parent without mandatory ref. must fail
//		body = postSoap(_, "testMultiple", "createParent", {
//			name: "parent2",
//			mandatoryChild: {
//				$uuid: mcuuid,
//				name: "mandatoryChild"
//			}
//		}, true);
//		// Disabled test because faults are not handled properly yet.
//		//strictEqual(body.fault != null, true, "read parent fail ok: fault: "+(body.fault != null ? body.fault : "null"));
//
//	} catch (e) {
//		console.error("ERROR=" + e.stack);
//	}
//	start();
//});

asyncTest("paging", 43, function(_) {

	createWebService(_, "testPageds", "paged");

	var body = postSoap(_, "testPageds", "createPaged", {
		name: "r1"
	});
	body = postSoap(_, "testPageds", "createPaged", {
		name: "r2"
	});
	body = postSoap(_, "testPageds", "createPaged", {
		name: "r3"
	});
	body = postSoap(_, "testPageds", "listPaged", {
		_count: "1",
		_orderBy: {
			orderBy: {
				_binding: "name"
			}
		}
	});
	strictEqual(body._pageInfo, "1", "pageInfo ok(1)");
	strictEqual(body._totalResults, "3", "totalResults ok(1)");
	strictEqual(body._itemsPerPage, "1", "itemsPerPage ok");
	strictEqual(count(body.pagedList), 1, "length ok");
	strictEqual(body.pagedList.paged.name, "r1", "name ok");

	body = postSoap(_, "testPageds", "listPaged", {
		_count: "1",
		_pageInfo: "2",
		_orderBy: {
			orderBy: {
				_binding: "name"
			}
		}
	});
	strictEqual(body._pageInfo, "2", "pageInfo ok(2)");
	strictEqual(body._totalResults, "3", "totalResults ok(2)");
	strictEqual(body._itemsPerPage, "1", "itemsPerPage ok");
	strictEqual(count(body.pagedList), 1, "length ok");
	strictEqual(body.pagedList.paged.name, "r2", "name ok");

	body = postSoap(_, "testPageds", "listPaged", {
		_count: "3",
		_pageInfo: "1",
		_orderBy: {
			orderBy: {
				_binding: "name",
				_descending: "true"
			}
		}
	});
	strictEqual(body._pageInfo, "1", "pageInfo ok(3)");
	strictEqual(body._totalResults, "3", "totalResults ok(3)");
	strictEqual(body._itemsPerPage, "3", "itemsPerPage ok");
	strictEqual(count(body.pagedList.paged), 3, "length ok");
	strictEqual(body.pagedList.paged[0].name, "r3", "name ok");

	for (var i in body.pagedList.paged) {
		var subbody = postSoap(_, "testPageds", "deletePaged", {
			_key: body.pagedList.paged[i]._key
		});
		strictEqual(subbody.deleted, "true", "delete paged ok");
	}

	start();
});
//
//asyncTest("delete test", 115, function(_) {
//
//	var entities = [{
//		name: "deleteTestParent",
//		title: "deleteTestParent",
//		entityName: "deleteTestParents"
//	}, {
//		name: "deleteTestRefOne",
//		title: "deleteTestRefOne",
//		entityName: "deleteTestRefOnes"
//	}, {
//		name: "deleteTestRefMany",
//		title: "deleteTestRefMany",
//		entityName: "deleteTestRefManies"
//	}, {
//		name: "deleteTestMultiRefe",
//		title: "deleteTestMultiRefe",
//		entityName: "deleteTestMultiRefes"
//	}, {
//		name: "deleteTestCascadeMaster",
//		title: "deleteTestCascadeMaster",
//		entityName: "deleteTestCascadeMasters"
//	}, {
//		name: "deleteTestCascadeDetail",
//		title: "deleteTestCascadeDetail",
//		entityName: "deleteTestCascadeDetails"
//	}];
//	createWebService(_, "testMultipleDelete", "Multiple entities in same ws for delete", entities);
//
//	// create the parent
//	var body = postSoap(_, "testMultipleDelete", "createDeleteTestParent", {
//		name: "testParent"
//	});
//	var parentId = body._key;
//	strictEqual(parentId != null, true, "create parent ok");
//	// create refering childs
//	body = postSoap(_, "testMultipleDelete", "createDeleteTestRefOne", {
//		name: "testRefOne",
//		ref: {
//			_key: parentId
//		}
//	});
//	var refId = body._key;
//	strictEqual(refId != null, true, "create child ok");
//	ok(true, "delete ref one start");
//	// try to delete parent, must get error
//	body = postSoap(_, "testMultipleDelete", "deleteDeleteTestParent", {
//		_key: parentId
//	}, true);
//	strictEqual(body.fault != null, true, "delete parent fail ok: fault: " + body.fault);
//
//	// delete refering child
//	body = postSoap(_, "testMultipleDelete", "deleteDeleteTestRefOne", {
//		_key: refId
//	});
//	strictEqual(body.deleted, "true", "delete refering child ok");
//	// delete parent, must succeed
//	body = postSoap(_, "testMultipleDelete", "deleteDeleteTestParent", {
//		_key: parentId
//	});
//	strictEqual(body.deleted, "true", "delete parent ok");
//	//
//	ok(true, "delete ref many start");
//	// recreate parent
//	body = postSoap(_, "testMultipleDelete", "createDeleteTestParent", {
//		name: "testParent"
//	});
//	parentId = body._key;
//	strictEqual(parentId != null, true, "create parent ok");
//	//
//	body = postSoap(_, "testMultipleDelete", "createDeleteTestRefMany", {
//		name: "testRefMany",
//		refs: {
//			deleteTestParent: [{
//				_key: parentId
//			}]
//		}
//	});
//	refId = body._key;
//	strictEqual(refId != null, true, "create child ok");
//	// try to delete parent, must fail
//	body = postSoap(_, "testMultipleDelete", "deleteDeleteTestParent", {
//		_key: parentId
//	}, true);
//	strictEqual(body.fault != null, true, "delete parent fail ok: fault: " + body.fault);
//	// delete refering child
//	body = postSoap(_, "testMultipleDelete", "deleteDeleteTestRefMany", {
//		_key: refId
//	});
//	strictEqual(body.deleted, "true", "delete refering child ok");
//
//	// delete parent, must succeed
//	body = postSoap(_, "testMultipleDelete", "deleteDeleteTestParent", {
//		_key: parentId
//	});
//	strictEqual(body.deleted, "true", "delete parent ok");
//	//
//	ok(true, "delete multi ref start");
//	// recreate parent
//	body = postSoap(_, "testMultipleDelete", "createDeleteTestParent", {
//		name: "testParent"
//	});
//	parentId = body._key;
//	strictEqual(parentId != null, true, "create parent ok");
//	//
//	body = postSoap(_, "testMultipleDelete", "createDeleteTestMultiRefe", {
//		name: "testRef1",
//		ref1: {
//			_key: parentId
//		}
//	});
//	var refId1 = body._key;
//	strictEqual(refId1 != null, true, "create child 1 ok");
//
//	body = postSoap(_, "testMultipleDelete", "createDeleteTestMultiRefe", {
//		name: "testRef2",
//		ref2: {
//			_key: parentId
//		}
//	});
//	var refId2 = body._key;
//	strictEqual(refId2 != null, true, "create child 2 ok");
//
//	// try to delete parent, must fail
//	body = postSoap(_, "testMultipleDelete", "deleteDeleteTestParent", {
//		_key: parentId
//	}, true);
//	strictEqual(body.fault != null, true, "delete parent fail ok: fault: " + body.fault);
//	// delete refering child 1
//	body = postSoap(_, "testMultipleDelete", "deleteDeleteTestMultiRefe", {
//		_key: refId1
//	});
//	strictEqual(body.deleted, "true", "delete refering child1 ok");
//	// try to delete parent, must fail
//	body = postSoap(_, "testMultipleDelete", "deleteDeleteTestParent", {
//		_key: parentId
//	}, true);
//	strictEqual(body.fault != null, true, "delete parent fail ok: fault: " + body.fault);
//	// delete refering child 2
//	body = postSoap(_, "testMultipleDelete", "deleteDeleteTestMultiRefe", {
//		_key: refId2
//	});
//	strictEqual(body.deleted, "true", "delete refering child2 ok");
//	// delete parent, must succeed
//	body = postSoap(_, "testMultipleDelete", "deleteDeleteTestParent", {
//		_key: parentId
//	});
//	strictEqual(body.deleted, "true", "delete parent ok");
//
//	// cascade delete
//	body = postSoap(_, "testMultipleDelete", "createDeleteTestCascadeMaster", {
//		name: "Cascade Master"
//	});
//	var masterUuid = body._key;
//	strictEqual(masterUuid != null, true, "create cascade master ok");
//	body = postSoap(_, "testMultipleDelete", "createDeleteTestCascadeDetail", {
//		name: "Cascade Detail 1",
//		master: {
//			_key: masterUuid
//		}
//	});
//	var detail1Uuid = body._key;
//	strictEqual(detail1Uuid != null, true, "create cascade details 1 ok");
//	body = postSoap(_, "testMultipleDelete", "createDeleteTestCascadeDetail", {
//		name: "Cascade Detail 2"
//	});
//	var detail2Uuid = body._key;
//	strictEqual(detail2Uuid != null, true, "create cascade details 2 ok");
//	body = postSoap(_, "testMultipleDelete", "updateDeleteTestCascadeMaster", {
//		_key: masterUuid,
//		detailsWoInv: {
//			deleteTestCascadeDetail: [{
//				_key: detail2Uuid
//			}]
//		}
//	});
//	// check
//	body = postSoap(_, "testMultipleDelete", "readDeleteTestCascadeMaster", {
//		_key: masterUuid
//	}).deleteTestCascadeMaster;
//
//	strictEqual(count(body.detailsWInv), 1, "Has detail with inv ok");
//	strictEqual(count(body.detailsWoInv), 1, "Has detail w/o inv ok");
//	// delete details, must pass
//	body = postSoap(_, "testMultipleDelete", "deleteDeleteTestCascadeDetail", {
//		_key: detail1Uuid
//	});
//	strictEqual(body.deleted, "true", "delete cascade details ok");
//	body = postSoap(_, "testMultipleDelete", "deleteDeleteTestCascadeDetail", {
//		_key: detail2Uuid
//	});
//	strictEqual(body.deleted, "true", "delete cascade details ok");
//
//	// check
//	body = postSoap(_, "testMultipleDelete", "readDeleteTestCascadeMaster", {
//		_key: masterUuid
//	}).deleteTestCascadeMaster;
//
//	ok((!body.detailsWInv || !body.detailsWInv.length), "Del detail with inv ok");
//	// This test will fail as if there is no inverse relation is no way (yet) for the relation to be notified of the delete
//	ok((!body.detailsWoInv || !body.detailsWoInv.length), "Del detail w/o inv ok");
//	// recreate details
//	body = postSoap(_, "testMultipleDelete", "createDeleteTestCascadeDetail", {
//		name: "Cascade Detail 1",
//		master: {
//			_key: masterUuid
//		}
//	});
//	detail1Uuid = body._key;
//	strictEqual(detail1Uuid != null, true, "create cascade details 1 ok");
//
//	body = postSoap(_, "testMultipleDelete", "readDeleteTestCascadeMaster", {
//		_key: masterUuid
//	}).deleteTestCascadeMaster;
//
//	strictEqual(count(body.detailsWInv), 1, "Has detail with inv ok");
//	strictEqual(count(body.detailsWoInv), 1, "Has detail w/o inv ok");
//	// delete master, must pass
//	body = postSoap(_, "testMultipleDelete", "deleteDeleteTestCascadeMaster", {
//		_key: masterUuid
//	});
//	strictEqual(body.deleted, "true", "delete cascade master ok");
//
//	// details must not exists
//	body = postSoap(_, "testMultipleDelete", "readDeleteTestCascadeDetail", {
//		_key: detail1Uuid
//	}).deleteTestCascadeDetail;
//	strictEqual(body.$["xsi:nil"], "true", "read deleted cascade details null ok");
//	body = postSoap(_, "testMultipleDelete", "readDeleteTestCascadeDetail", {
//		_key: detail2Uuid
//	}).deleteTestCascadeDetail;
//
//	strictEqual(body.$["xsi:nil"], "true", "read deleted cascade details null ok");
//
//	start();
//});

asyncTest("stop  tests", 0, function(_) {
	doStop = true;
	start();
});